void sub_100002728(int *a1, int a2)
{
  NSObject *v3;
  int v4;
  const char *v5;

  *a1 = a2;
  if (dword_10008FA20)
  {
    v3 = ne_log_obj();
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      v4 = 136315138;
      v5 = sub_10003DBB8(0, 0, a2);
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "state changed to: %s\n", (uint8_t *)&v4, 0xCu);
    }
  }
}

uint64_t sub_1000027EC(uint64_t a1, void *a2)
{
  uint64_t v4 = 0;
  int v5 = *(_DWORD *)(a1 + 16);
  if (v5 <= 5439)
  {
    if (v5 > 5220)
    {
      if (v5 == 5221)
      {
        if (sub_100016D7C(a1, a2)) {
          return 0;
        }
      }
      else
      {
        if (v5 != 5281) {
          return v4;
        }
        if (sub_100011FBC(a1, (uint64_t)a2)) {
          return 0;
        }
      }
    }
    else if (v5 == 5217)
    {
      if (sub_1000158C8(a1, (uint64_t)a2)) {
        return 0;
      }
    }
    else
    {
      if (v5 != 5219) {
        return v4;
      }
      if (sub_100016130(a1, (uint64_t)a2)) {
        return 0;
      }
    }
    goto LABEL_34;
  }
  if (v5 <= 5475)
  {
    if (v5 == 5440)
    {
      uint64_t v8 = sub_100017258(a1, (uint64_t)a2);
      if (v8)
      {
        uint64_t v4 = v8;
        if (!dword_10008FA20) {
          goto LABEL_48;
        }
        v9 = ne_log_obj();
        if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR)) {
LABEL_26:
        }
          sub_100056A8C();
LABEL_45:
        if (dword_10008FA20)
        {
          v15 = ne_log_obj();
          if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR)) {
            sub_1000569E4();
          }
        }
        goto LABEL_48;
      }
    }
    else
    {
      if (v5 != 5474) {
        return v4;
      }
      if (sub_100017A0C(a1, (uint64_t)a2)) {
        return 0;
      }
    }
LABEL_34:
    v10 = *(void **)(a1 + 128);
    if (v10)
    {
      sub_10003FA78(v10);
      *(void *)(a1 + 128) = 0;
    }
    uint64_t v11 = *(unsigned int *)(a1 + 120);
    if (v11)
    {
      sub_10003AC14(v11);
      *(_DWORD *)(a1 + 120) = 0;
    }
    if (dword_10008FA20)
    {
      v12 = ne_log_obj();
      if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG)) {
        sub_100056A4C();
      }
    }
    uint64_t v13 = sub_100002AA0(a1, (uint64_t)a2);
    if (v13)
    {
      uint64_t v4 = v13;
      if (dword_10008FA20)
      {
        v14 = ne_log_obj();
        if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR)) {
          sub_100056A18();
        }
        goto LABEL_45;
      }
LABEL_48:
      sub_10004B710(a1);
      return v4;
    }
    if ((*(unsigned char *)(a1 + 17) & 0x20) != 0) {
      sub_100022478(a1);
    }
    return 0;
  }
  switch(v5)
  {
    case 5476:
      if (sub_10001823C(a1, a2)) {
        return 0;
      }
      goto LABEL_34;
    case 5504:
      uint64_t v6 = sub_1000132C0(a1, (uint64_t)a2);
      if (v6)
      {
        uint64_t v4 = v6;
        if (!dword_10008FA20) {
          goto LABEL_48;
        }
        v7 = ne_log_obj();
        if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR)) {
          goto LABEL_26;
        }
        goto LABEL_45;
      }
      goto LABEL_34;
    case 5538:
      if (sub_100014348(a1, a2)) {
        return 0;
      }
      goto LABEL_34;
  }
  return v4;
}

uint64_t sub_100002AA0(uint64_t a1, uint64_t a2)
{
  int v3 = *(_DWORD *)(a1 + 16);
  uint64_t v4 = 0xFFFFFFFFLL;
  if (v3 > 5440)
  {
    if (v3 <= 5444)
    {
      if (v3 == 5441)
      {
        uint64_t v5 = sub_1000175EC(a1, a2);
        goto LABEL_22;
      }
      if (v3 == 5443)
      {
        uint64_t v5 = sub_100017EE0(a1, a2);
        goto LABEL_22;
      }
    }
    else
    {
      switch(v3)
      {
        case 5445:
          uint64_t v5 = sub_1000187EC(a1, a2);
          goto LABEL_22;
        case 5505:
          uint64_t v5 = sub_1000138F8(a1, a2);
          goto LABEL_22;
        case 5507:
          uint64_t v5 = sub_1000148A8(a1, a2);
          goto LABEL_22;
      }
    }
LABEL_23:
    int v6 = sub_100009F24(a1);
    sub_100049388((unsigned __int16)v4, 0, v6, 0, 0);
    return v4;
  }
  switch(v3)
  {
    case 5184:
      uint64_t v5 = sub_1000154A8(a1, a2);
      break;
    case 5185:
    case 5187:
    case 5189:
      goto LABEL_23;
    case 5186:
      uint64_t v5 = sub_100015C84(a1, a2);
      break;
    case 5188:
      uint64_t v5 = sub_100016674(a1, a2);
      break;
    case 5190:
      uint64_t v5 = sub_1000171C8(a1);
      break;
    default:
      if (v3 == 5248)
      {
        uint64_t v5 = sub_1000119A0(a1, a2);
      }
      else
      {
        if (v3 != 5250) {
          goto LABEL_23;
        }
        uint64_t v5 = sub_100012B80(a1, a2);
      }
      break;
  }
LABEL_22:
  uint64_t v4 = v5;
  if (v5) {
    goto LABEL_23;
  }
  return v4;
}

uint64_t sub_100002C2C(uint64_t a1, void *a2)
{
  uint64_t result = 0;
  int v5 = *(_DWORD *)(a1 + 56);
  uint64_t v6 = 0xFFFFFFFFLL;
  if (v5 <= 6591)
  {
    switch(v5)
    {
      case 6369:
        uint64_t v7 = sub_10001CD04(a1, a2);
        break;
      case 6371:
        uint64_t v7 = sub_10001DD90(a1, a2);
        break;
      case 6384:
        return result;
      default:
        goto LABEL_19;
    }
  }
  else
  {
    if (v5 > 6639)
    {
      if (v5 != 6640 && v5 != 10240) {
        goto LABEL_19;
      }
      return result;
    }
    if (v5 == 6592)
    {
      uint64_t v7 = sub_10001E238(a1, a2);
    }
    else
    {
      if (v5 != 6626) {
        goto LABEL_19;
      }
      uint64_t v7 = sub_10001FB3C(a1, a2);
    }
  }
  uint64_t v6 = v7;
  if (v7)
  {
LABEL_19:
    if (dword_10008FA20)
    {
      v9 = ne_log_obj();
      if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR)) {
        sub_100056A8C();
      }
    }
    if (v6 == -1) {
      sub_10003B880();
    }
    sub_10001AD08(*(void *)(a1 + 256), v6, 0);
LABEL_25:
    if (dword_10008FA20)
    {
      v10 = ne_log_obj();
      if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR)) {
        sub_100056AC0();
      }
    }
    goto LABEL_28;
  }
  uint64_t v11 = *(void **)(a1 + 80);
  if (v11)
  {
    sub_10003FA78(v11);
    *(void *)(a1 + 80) = 0;
  }
  else if (*(_DWORD *)(a1 + 56) != 6593)
  {
    if (dword_10008FA20)
    {
      v14 = ne_log_obj();
      if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR)) {
        sub_100056AF4();
      }
      uint64_t v6 = 0xFFFFFFFFLL;
      goto LABEL_25;
    }
    uint64_t v6 = 0xFFFFFFFFLL;
    goto LABEL_28;
  }
  uint64_t v12 = *(unsigned int *)(a1 + 68);
  if (v12)
  {
    sub_10003AC14(v12);
    *(_DWORD *)(a1 + 68) = 0;
  }
  if (*(_DWORD *)(a1 + 56) == 6344) {
    return 0;
  }
  uint64_t result = sub_100002E74(a1, (uint64_t)a2);
  if (result)
  {
    uint64_t v6 = result;
    if (dword_10008FA20)
    {
      uint64_t v13 = ne_log_obj();
      if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR)) {
        sub_100056A18();
      }
      goto LABEL_25;
    }
LABEL_28:
    sub_10004B62C((void *)a1);
    return v6;
  }
  return result;
}

uint64_t sub_100002E74(uint64_t a1, uint64_t a2)
{
  int v2 = *(_DWORD *)(a1 + 56);
  if (v2 > 6594)
  {
    switch(v2)
    {
      case 6595:
        return sub_10001FE88(a1, a2);
      case 6596:
        return sub_1000201D4(a1);
      case 6608:
        return sub_10001F358(a1, a2);
    }
  }
  else
  {
    switch(v2)
    {
      case 6338:
        return sub_10001D91C(a1, a2);
      case 6352:
        return sub_10001C650(a1, a2);
      case 6593:
        return sub_10001F248(a1);
    }
  }
  return 0xFFFFFFFFLL;
}

void sub_100002EEC(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_error_impl(a1, a2, OS_LOG_TYPE_ERROR, a4, &a9, 2u);
}

BOOL sub_100002F14(int a1)
{
  return sub_100002F34(a1) != 0;
}

char **sub_100002F34(int a1)
{
  uint64_t v1 = 0;
  while (1)
  {
    int v2 = &(&off_10008C000)[v1];
    if (*((_DWORD *)&off_10008C000 + 2 * v1 + 3) == a1) {
      break;
    }
    v1 += 7;
    if (v1 == 35) {
      return 0;
    }
  }
  if (dword_10008FA20)
  {
    int v3 = ne_log_obj();
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEBUG)) {
      sub_100056B28();
    }
  }
  return v2;
}

uint64_t sub_100002FB8(int a1)
{
  uint64_t v1 = 0;
  while (LODWORD((&off_10008C000)[v1 + 1]) != a1)
  {
    v1 += 7;
    if (v1 == 35) {
      return 0xFFFFFFFFLL;
    }
  }
  return *((unsigned int *)&off_10008C000 + 2 * v1 + 3);
}

uint64_t sub_100002FF0(int a1)
{
  uint64_t v1 = sub_100002F34(a1);
  if (!v1) {
    return 0;
  }
  int v2 = (uint64_t (*)(void))v1[5];
  if (!v2) {
    return 0;
  }

  return v2();
}

const char *sub_100003030(int a1)
{
  uint64_t v1 = sub_100002F34(a1);
  if (v1) {
    return *v1;
  }
  else {
    return "*UNKNOWN*";
  }
}

uint64_t sub_10000305C(int a1, uint64_t a2)
{
  int v3 = sub_100002F34(a1);
  if (!v3 || !v3[5]) {
    return 0;
  }
  uint64_t v4 = v3[6];

  return ((uint64_t (*)(uint64_t))v4)(a2);
}

uint64_t sub_1000030B4(int a1)
{
  uint64_t v1 = 0;
  while (LODWORD((&off_100088950)[v1 + 1]) != a1)
  {
    v1 += 7;
    if (v1 == 35) {
      return 0xFFFFFFFFLL;
    }
  }
  return *((unsigned int *)&off_100088950 + 2 * v1 + 3);
}

uint64_t sub_1000030EC(int a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = 0;
  while (*((_DWORD *)&off_100088950 + 2 * v5 + 3) != a1)
  {
    v5 += 7;
    if (v5 == 35) {
      return 0;
    }
  }
  if (dword_10008FA20)
  {
    uint64_t v7 = ne_log_obj();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG)) {
      sub_100056B90();
    }
  }
  return ((uint64_t (*)(uint64_t, uint64_t))(&off_100088950)[v5 + 6])(a2, a3);
}

BOOL sub_100003198(int a1)
{
  return sub_1000031B8(a1) != 0;
}

char **sub_1000031B8(int a1)
{
  uint64_t v1 = 0;
  while (1)
  {
    int v2 = &(&off_10008C118)[v1];
    if (*((_DWORD *)&off_10008C118 + 2 * v1 + 3) == a1) {
      break;
    }
    v1 += 7;
    if (v1 == 21) {
      return 0;
    }
  }
  if (dword_10008FA20)
  {
    int v3 = ne_log_obj();
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEBUG)) {
      sub_100056BF8();
    }
  }
  return v2;
}

uint64_t sub_10000323C(int a1)
{
  uint64_t v1 = 0;
  while (LODWORD((&off_10008C118)[v1 + 1]) != a1)
  {
    v1 += 7;
    if (v1 == 21) {
      return 0xFFFFFFFFLL;
    }
  }
  return *((unsigned int *)&off_10008C118 + 2 * v1 + 3);
}

uint64_t sub_100003274(int a1, uint64_t a2)
{
  int v3 = sub_1000031B8(a1);
  if (!v3) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v4 = v3[6];
  if (!v4) {
    return 0xFFFFFFFFLL;
  }

  return ((uint64_t (*)(uint64_t))v4)(a2);
}

uint64_t sub_1000032C8(int a1)
{
  uint64_t v1 = sub_1000031B8(a1);
  if (v1) {
    return *((unsigned int *)v1 + 4);
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

const char *sub_1000032F0(int a1)
{
  uint64_t v1 = sub_1000031B8(a1);
  if (v1) {
    return *v1;
  }
  else {
    return "*UNKNOWN*";
  }
}

uint64_t sub_10000331C(int a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7 = sub_1000031B8(a1);
  if (!v7) {
    return 0;
  }
  uint64_t v8 = v7[4];
  if (!v8) {
    return 0;
  }

  return ((uint64_t (*)(uint64_t, uint64_t, uint64_t))v8)(a2, a3, a4);
}

uint64_t sub_10000338C(int a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7 = sub_1000031B8(a1);
  if (!v7) {
    return 0;
  }
  uint64_t v8 = v7[3];
  if (!v8) {
    return 0;
  }

  return ((uint64_t (*)(uint64_t, uint64_t, uint64_t))v8)(a2, a3, a4);
}

uint64_t sub_1000033FC(int a1)
{
  uint64_t v1 = 0;
  while (LODWORD((&off_100088A68)[v1 + 1]) != a1)
  {
    v1 += 7;
    if (v1 == 42) {
      return 0xFFFFFFFFLL;
    }
  }
  return *((unsigned int *)&off_100088A68 + 2 * v1 + 3);
}

uint64_t sub_100003434(int a1, uint64_t a2)
{
  uint64_t v3 = 0;
  while (*((_DWORD *)&off_100088A68 + 2 * v3 + 3) != a1)
  {
    v3 += 7;
    if (v3 == 42) {
      return 0xFFFFFFFFLL;
    }
  }
  if (dword_10008FA20)
  {
    uint64_t v5 = ne_log_obj();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG)) {
      sub_100056BF8();
    }
  }
  return ((uint64_t (*)(uint64_t))(&off_100088A68)[v3 + 6])(a2);
}

uint64_t sub_1000034D8(int a1)
{
  uint64_t v1 = 0;
  while (LODWORD((&off_100088BB8)[v1 + 1]) != a1)
  {
    v1 += 7;
    if (v1 == 56) {
      return 0xFFFFFFFFLL;
    }
  }
  return *((unsigned int *)&off_100088BB8 + 2 * v1 + 3);
}

uint64_t sub_100003510(int a1)
{
  uint64_t v1 = 0;
  while (*((_DWORD *)&off_100088BB8 + 2 * v1 + 3) != a1)
  {
    v1 += 7;
    if (v1 == 56) {
      return 0xFFFFFFFFLL;
    }
  }
  if (dword_10008FA20)
  {
    uint64_t v3 = ne_log_obj();
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEBUG)) {
      sub_100056B90();
    }
  }
  return ((uint64_t (*)(void))(&off_100088BB8)[v1 + 5])();
}

uint64_t sub_1000035A4(int a1)
{
  uint64_t v1 = 0;
  while (LODWORD((&off_100088D78)[v1 + 1]) != a1)
  {
    v1 += 2;
    if (v1 == 6) {
      return 0xFFFFFFFFLL;
    }
  }
  return *((unsigned int *)&off_100088D78 + 2 * v1 + 3);
}

BOOL sub_1000035DC(int a1)
{
  return sub_1000035FC(a1) != 0;
}

char **sub_1000035FC(int a1)
{
  uint64_t v1 = 0;
  while (1)
  {
    int v2 = &(&off_10008C1C0)[v1];
    if (*((_DWORD *)&off_10008C1C0 + 2 * v1 + 3) == a1) {
      break;
    }
    v1 += 3;
    if (v1 == 24) {
      return 0;
    }
  }
  if (dword_10008FA20)
  {
    uint64_t v3 = ne_log_obj();
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEBUG)) {
      sub_100056B90();
    }
  }
  return v2;
}

uint64_t sub_100003680(int a1)
{
  uint64_t v1 = 0;
  while (LODWORD((&off_10008C1C0)[v1 + 1]) != a1)
  {
    v1 += 3;
    if (v1 == 24) {
      return 0xFFFFFFFFLL;
    }
  }
  return *((unsigned int *)&off_10008C1C0 + 2 * v1 + 3);
}

char **sub_1000036B8(int a1)
{
  uint64_t result = sub_1000035FC(a1);
  if (result) {
    return (char **)result[2];
  }
  return result;
}

const char *sub_1000036D8(int a1)
{
  uint64_t v1 = sub_1000035FC(a1);
  if (v1) {
    return *v1;
  }
  else {
    return "*UNKNOWN*";
  }
}

uint64_t sub_100003704(int a1)
{
  uint64_t v1 = 0;
  while (LODWORD((&off_100088DA8)[v1 + 1]) != a1)
  {
    v1 += 2;
    if (v1 == 32) {
      return 0xFFFFFFFFLL;
    }
  }
  return *((unsigned int *)&off_100088DA8 + 2 * v1 + 3);
}

const char *sub_10000373C(int a1)
{
  uint64_t v2 = 0;
  uint64_t result = "*UNKNOWN*";
  while (*((_DWORD *)&off_100088DA8 + 2 * v2 + 3) != a1)
  {
    v2 += 2;
    if (v2 == 32) {
      return result;
    }
  }
  return (&off_100088DA8)[v2];
}

uint64_t sub_10000377C(int a1, int a2)
{
  if (a1 != 3 && a1 || (a2 - 4) > 9) {
    return 0;
  }
  else {
    return dword_10006E430[a2 - 4];
  }
}

uint64_t sub_1000037AC(int a1, unsigned int a2, int a3)
{
  if (a1 && a1 != 3)
  {
    if (dword_10008FA20)
    {
      uint64_t v6 = ne_log_obj();
      if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR)) {
        sub_100056C60(a1, v6);
      }
    }
  }
  else if (a2 <= 0xD && ((1 << a2) & 0x30D0) != 0)
  {
    if ((a3 & 7) != 0)
    {
      if (dword_10008FA20)
      {
        uint64_t v5 = ne_log_obj();
        if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR)) {
          sub_100056D60(a3, v5);
        }
      }
    }
    else
    {
      switch(a2)
      {
        case 4u:
          if ((a3 - 40) < 0x7D1) {
            return 0;
          }
          goto LABEL_29;
        case 6u:
          if ((a3 - 40) < 0x59) {
            return 0;
          }
          goto LABEL_29;
        case 7u:
          if ((a3 - 40) < 0x199) {
            return 0;
          }
          goto LABEL_29;
        case 0xCu:
          uint64_t result = 0;
          if (a3 == 128 || a3 == 192 || a3 == 256) {
            return result;
          }
          goto LABEL_29;
        case 0xDu:
          if ((a3 - 40) < 0xD9) {
            return 0;
          }
LABEL_29:
          if (dword_10008FA20)
          {
            uint64_t v9 = ne_log_obj();
            if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR)) {
              sub_100056D1C(v9);
            }
          }
          break;
        default:
          goto LABEL_15;
      }
    }
  }
  else
  {
LABEL_15:
    if (!a3) {
      return 0;
    }
    if (dword_10008FA20)
    {
      uint64_t v7 = ne_log_obj();
      if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR)) {
        sub_100056CD8(v7);
      }
    }
  }
  return 0xFFFFFFFFLL;
}

uint64_t sub_100003988(int a1, int a2)
{
  switch(a1)
  {
    case 0:
      for (uint64_t i = 0; i != 42; i += 7)
      {
        uint64_t v3 = &(&off_100088A68)[i];
        if (LODWORD((&off_100088A68)[i + 1]) == a2) {
          return *((unsigned int *)v3 + 3);
        }
      }
      return 0xFFFFFFFFLL;
    case 1:
      uint64_t v4 = 0;
      while (1)
      {
        uint64_t v3 = &(&off_100088BB8)[v4];
        if (LODWORD((&off_100088BB8)[v4 + 1]) == a2) {
          break;
        }
        v4 += 7;
        if (v4 == 56) {
          return 0xFFFFFFFFLL;
        }
      }
      return *((unsigned int *)v3 + 3);
    case 2:
      uint64_t v5 = 0;
      while (1)
      {
        uint64_t v3 = &(&off_100088D78)[v5];
        if (LODWORD((&off_100088D78)[v5 + 1]) == a2) {
          break;
        }
        v5 += 2;
        if (v5 == 6) {
          return 0xFFFFFFFFLL;
        }
      }
      return *((unsigned int *)v3 + 3);
    case 3:
      uint64_t v6 = 0;
      while (1)
      {
        uint64_t v3 = &(&off_10008C118)[v6];
        if (LODWORD((&off_10008C118)[v6 + 1]) == a2) {
          break;
        }
        v6 += 7;
        if (v6 == 21) {
          return 0xFFFFFFFFLL;
        }
      }
      return *((unsigned int *)v3 + 3);
    case 4:
      uint64_t v7 = 0;
      while (1)
      {
        uint64_t v3 = &(&off_10008C000)[v7];
        if (LODWORD((&off_10008C000)[v7 + 1]) == a2) {
          break;
        }
        v7 += 7;
        if (v7 == 35) {
          return 0xFFFFFFFFLL;
        }
      }
      return *((unsigned int *)v3 + 3);
    case 5:
      uint64_t v8 = 0;
      while (1)
      {
        uint64_t v3 = &(&off_10008C1C0)[v8];
        if (LODWORD((&off_10008C1C0)[v8 + 1]) == a2) {
          break;
        }
        v8 += 3;
        if (v8 == 24) {
          return 0xFFFFFFFFLL;
        }
      }
      return *((unsigned int *)v3 + 3);
    case 6:
      uint64_t v9 = 0;
      break;
    default:
      return 0xFFFFFFFFLL;
  }
  while (1)
  {
    uint64_t v3 = &(&off_100088DA8)[v9];
    if (LODWORD((&off_100088DA8)[v9 + 1]) == a2) {
      break;
    }
    v9 += 2;
    if (v9 == 32) {
      return 0xFFFFFFFFLL;
    }
  }
  return *((unsigned int *)v3 + 3);
}

uint64_t sub_100003B14(unsigned int a1)
{
  if (a1 > 6) {
    return 0xFFFFFFFFLL;
  }
  else {
    return dword_10006E458[a1];
  }
}

void sub_100003B34(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_debug_impl(a1, a2, OS_LOG_TYPE_DEBUG, a4, &a9, 0xCu);
}

void sub_100003B50(uint64_t a1@<X8>)
{
  *(void *)(v1 - 8) = a1;
}

SecCertificateRef sub_100003B68(uint64_t a1)
{
  CFDataRef v1 = CFDataCreateWithBytesNoCopy(0, *(const UInt8 **)(a1 + 8), *(void *)a1, kCFAllocatorNull);
  if (v1)
  {
    CFDataRef v2 = v1;
    SecCertificateRef v3 = SecCertificateCreateWithData(0, v1);
    CFRelease(v2);
    if (v3) {
      return v3;
    }
  }
  else
  {
    SecCertificateRef v3 = 0;
  }
  if (dword_10008FA20)
  {
    uint64_t v4 = ne_log_obj();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR)) {
      sub_100056DD8();
    }
  }
  return v3;
}

uint64_t sub_100003C04()
{
  double Current = CFAbsoluteTimeGetCurrent();
  if (Current == 0.0)
  {
    if (dword_10008FA20)
    {
      uint64_t v4 = ne_log_obj();
      if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR)) {
        sub_100056E74();
      }
    }
    return 5;
  }
  CFAbsoluteTime v1 = Current;
  if (!SecCertificateIsValid())
  {
    CFDateRef v5 = CFDateCreate(0, v1);
    SecCertificateNotValidBefore();
    CFAbsoluteTime v7 = v6;
    if (v6 == 0.0) {
      CFDateRef v8 = 0;
    }
    else {
      CFDateRef v8 = CFDateCreate(0, v6);
    }
    SecCertificateNotValidAfter();
    CFAbsoluteTime v10 = v9;
    if (v9 == 0.0) {
      CFDateRef v11 = 0;
    }
    else {
      CFDateRef v11 = CFDateCreate(0, v9);
    }
    uint64_t v20 = 0;
    uint64_t v21 = 0;
    int v19 = 0;
    uint64_t v12 = CFCalendarCreateWithIdentifier(kCFAllocatorDefault, kCFGregorianCalendar);
    if (v12)
    {
      uint64_t v13 = v12;
      if (v7 != 0.0)
      {
        CFCalendarDecomposeAbsoluteTime(v12, v7, "yMdHm", (char *)&v21 + 4, &v21, (char *)&v20 + 4, &v20, &v19);
        if (dword_10008FA20)
        {
          v14 = ne_log_obj();
          if (os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)buf = 67110144;
            int v23 = HIDWORD(v21);
            __int16 v24 = 1024;
            int v25 = v21;
            __int16 v26 = 1024;
            int v27 = HIDWORD(v20);
            __int16 v28 = 1024;
            int v29 = v20;
            __int16 v30 = 1024;
            int v31 = v19;
            _os_log_debug_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEBUG, "Certificate not valid before yr %d, mon %d, days %d, hours %d, min %d\n", buf, 0x20u);
          }
        }
      }
      if (v10 != 0.0)
      {
        CFCalendarDecomposeAbsoluteTime(v13, v10, "yMdHm", (char *)&v21 + 4, &v21, (char *)&v20 + 4, &v20, &v19);
        if (dword_10008FA20)
        {
          v15 = ne_log_obj();
          if (os_log_type_enabled(v15, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)buf = 67110144;
            int v23 = HIDWORD(v21);
            __int16 v24 = 1024;
            int v25 = v21;
            __int16 v26 = 1024;
            int v27 = HIDWORD(v20);
            __int16 v28 = 1024;
            int v29 = v20;
            __int16 v30 = 1024;
            int v31 = v19;
            _os_log_debug_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEBUG, "Certificate not valid after yr %d, mon %d, days %d, hours %d, min %d\n", buf, 0x20u);
          }
        }
      }
      CFRelease(v13);
    }
    if (!v5) {
      goto LABEL_36;
    }
    if (v8 && CFDateCompare(v5, v8, 0) == kCFCompareLessThan)
    {
      if (dword_10008FA20)
      {
        v18 = ne_log_obj();
        if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR)) {
          sub_100056E40();
        }
      }
      uint64_t v3 = 1;
      goto LABEL_47;
    }
    if (v11 && CFDateCompare(v5, v11, 0) == kCFCompareGreaterThan)
    {
      if (dword_10008FA20)
      {
        v16 = ne_log_obj();
        if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR)) {
          sub_100056E0C();
        }
      }
      uint64_t v3 = 2;
    }
    else
    {
LABEL_36:
      uint64_t v3 = 0;
    }
    if (!v8)
    {
      if (!v11) {
        goto LABEL_40;
      }
      goto LABEL_39;
    }
LABEL_47:
    CFRelease(v8);
    if (!v11)
    {
LABEL_40:
      if (v5) {
        CFRelease(v5);
      }
      return v3;
    }
LABEL_39:
    CFRelease(v11);
    goto LABEL_40;
  }
  if (!dword_10008FA20) {
    return 0;
  }
  CFDataRef v2 = ne_log_obj();
  uint64_t v3 = 0;
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Certificate expiration date is OK\n", buf, 2u);
    return 0;
  }
  return v3;
}

uint64_t sub_100004024(uint64_t a1, uint64_t a2, void *a3, SecKeyRef *a4)
{
  *(void *)keys = kSecPolicyName;
  values = a3;
  CFAbsoluteTime v7 = &dword_10008FA20;
  if (!a3)
  {
LABEL_11:
    SecPolicyRef v11 = SecPolicyCreateWithProperties(kSecPolicyAppleIPsec, 0);
    goto LABEL_12;
  }
  CFDictionaryRef v8 = CFDictionaryCreate(0, (const void **)keys, (const void **)&values, 1, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (v8) {
    BOOL v9 = 1;
  }
  else {
    BOOL v9 = dword_10008FA20 == 0;
  }
  if (!v9)
  {
    uint64_t v12 = ne_log_obj();
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR)) {
      sub_1000572DC();
    }
    goto LABEL_11;
  }
  CFDictionaryRef v10 = v8;
  SecPolicyRef v11 = SecPolicyCreateWithProperties(kSecPolicyAppleIPsec, v8);
  if (v10) {
    CFRelease(v10);
  }
LABEL_12:
  uint64_t v14 = 0xFFFFFFFFLL;
  if (!a1 || !a2) {
    return v14;
  }
  int v15 = 0;
  uint64_t v16 = -1;
  uint64_t v17 = a2;
  do
  {
    uint64_t v17 = *(void *)(v17 + 40);
    ++v16;
    v15 += 8;
  }
  while (v17);
  if (v16)
  {
    if (dword_10008FA20)
    {
      v18 = ne_log_obj();
      if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG)) {
        sub_100057250(v16 + 1, v18);
      }
    }
  }
  int v19 = (const void **)CFAllocatorAllocate(0, v15, 0);
  if (!v19) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v20 = v19;
  bzero(v19, v15);
  SecCertificateRef v21 = sub_100003B68(a1 + 8);
  *uint64_t v20 = v21;
  if (!v21)
  {
    CFIndex v23 = 0;
    int v22 = 0;
    do
    {
LABEL_32:
      if (a2 != a1)
      {
        SecCertificateRef v28 = sub_100003B68(a2 + 8);
        v20[v23] = v28;
        if (v28)
        {
          if (!*(_DWORD *)(a2 + 32))
          {
            int v30 = sub_100003C04();
            *(_DWORD *)(a2 + 32) = v30;
            if (v30)
            {
              int v31 = v7;
              if (*v7)
              {
                v32 = ne_log_obj();
                if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR))
                {
                  int v33 = *(_DWORD *)(a2 + 32);
                  *(_DWORD *)keys = 67109120;
                  *(_DWORD *)&keys[4] = v33;
                  _os_log_error_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_ERROR, "other certificate in chain failed date verification: %d.\n", keys, 8u);
                }
              }
              CFAbsoluteTime v7 = v31;
              if (!v22) {
                int v22 = *(_DWORD *)(a2 + 32);
              }
            }
          }
          ++v23;
        }
      }
      a2 = *(void *)(a2 + 40);
      if (a2) {
        BOOL v29 = v23 <= v16;
      }
      else {
        BOOL v29 = 0;
      }
    }
    while (v29);
    goto LABEL_25;
  }
  if (*(_DWORD *)(a1 + 32))
  {
    int v22 = 0;
  }
  else
  {
    int v22 = sub_100003C04();
    *(_DWORD *)(a1 + 32) = v22;
    if (v22)
    {
      if (dword_10008FA20)
      {
        v35 = ne_log_obj();
        BOOL v36 = os_log_type_enabled(v35, OS_LOG_TYPE_ERROR);
        int v22 = *(_DWORD *)(a1 + 32);
        if (v36)
        {
          *(_DWORD *)keys = 67109120;
          *(_DWORD *)&keys[4] = v22;
          _os_log_error_impl((void *)&_mh_execute_header, v35, OS_LOG_TYPE_ERROR, "host certificate failed date verification: %d.\n", keys, 8u);
          int v22 = *(_DWORD *)(a1 + 32);
        }
      }
    }
  }
  CFIndex v23 = 1;
  if (v16) {
    goto LABEL_32;
  }
LABEL_25:
  values = 0;
  SecTrustResultType result = kSecTrustResultInvalid;
  CFArrayRef v24 = CFArrayCreate(0, v20, v23, &kCFTypeArrayCallBacks);
  if (v24)
  {
    CFArrayRef v25 = v24;
    unsigned int v26 = SecTrustCreateWithCertificates(v24, v11, (SecTrustRef *)&values);
    if (!v26)
    {
      unsigned int v26 = SecTrustEvaluate((SecTrustRef)values, &result);
      if (!v26)
      {
        SecTrustResultType v27 = result;
        if (result == kSecTrustResultProceed || result == kSecTrustResultUnspecified)
        {
          unsigned int v26 = 0;
          *a4 = SecTrustCopyPublicKey((SecTrustRef)values);
        }
        else
        {
          if (*v7)
          {
            v37 = ne_log_obj();
            if (os_log_type_enabled(v37, OS_LOG_TYPE_ERROR)) {
              sub_10005721C();
            }
            SecTrustResultType v27 = result;
          }
          switch(v27)
          {
            case kSecTrustResultInvalid:
              if (*v7)
              {
                v38 = ne_log_obj();
                if (os_log_type_enabled(v38, OS_LOG_TYPE_DEBUG)) {
                  sub_1000570B0();
                }
              }
              break;
            case kSecTrustResultProceed:
              if (*v7)
              {
                v39 = ne_log_obj();
                if (os_log_type_enabled(v39, OS_LOG_TYPE_DEBUG)) {
                  sub_1000570E4();
                }
              }
              break;
            case kSecTrustResultDeny:
              if (*v7)
              {
                v41 = ne_log_obj();
                if (os_log_type_enabled(v41, OS_LOG_TYPE_DEBUG)) {
                  sub_100057118();
                }
              }
              break;
            case kSecTrustResultUnspecified:
              if (*v7)
              {
                v42 = ne_log_obj();
                if (os_log_type_enabled(v42, OS_LOG_TYPE_DEBUG)) {
                  sub_10005714C();
                }
              }
              break;
            case kSecTrustResultRecoverableTrustFailure:
              if (*v7)
              {
                v43 = ne_log_obj();
                if (os_log_type_enabled(v43, OS_LOG_TYPE_DEBUG)) {
                  sub_100057180();
                }
              }
              break;
            case kSecTrustResultFatalTrustFailure:
              if (*v7)
              {
                v44 = ne_log_obj();
                if (os_log_type_enabled(v44, OS_LOG_TYPE_DEBUG)) {
                  sub_1000571B4();
                }
              }
              break;
            case kSecTrustResultOtherError:
              if (*v7)
              {
                v45 = ne_log_obj();
                if (os_log_type_enabled(v45, OS_LOG_TYPE_DEBUG)) {
                  sub_1000571E8();
                }
              }
              break;
            default:
              if (*v7)
              {
                v40 = ne_log_obj();
                if (os_log_type_enabled(v40, OS_LOG_TYPE_DEBUG)) {
                  sub_100057034((int *)&result, v40);
                }
              }
              break;
          }
          CFArrayRef v46 = SecTrustCopyProperties((SecTrustRef)values);
          if (v46)
          {
            CFArrayRef v47 = v46;
            CFIndex Count = CFArrayGetCount(v46);
            if (*v7)
            {
              v49 = ne_log_obj();
              if (os_log_type_enabled(v49, OS_LOG_TYPE_ERROR)) {
                sub_100057000();
              }
            }
            if (Count >= 1)
            {
              CFIndex v50 = 0;
              CFArrayRef v69 = v47;
              do
              {
                CFDictionaryRef ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(v47, v50);
                if (ValueAtIndex)
                {
                  CFDictionaryRef v52 = ValueAtIndex;
                  CFTypeID v53 = CFGetTypeID(ValueAtIndex);
                  if (v53 == CFDictionaryGetTypeID())
                  {
                    CFStringRef Value = (const __CFString *)CFDictionaryGetValue(v52, kSecPropertyKeyType);
                    if (Value)
                    {
                      CFStringRef v55 = Value;
                      CFTypeID v56 = CFGetTypeID(Value);
                      BOOL v9 = v56 == CFStringGetTypeID();
                      CFArrayRef v47 = v69;
                      if (v9)
                      {
                        CStringPtr = CFStringGetCStringPtr(v55, 0);
                        if (CStringPtr)
                        {
                          if (dword_10008FA20)
                          {
                            v58 = CStringPtr;
                            log = ne_log_obj();
                            if (os_log_type_enabled(log, OS_LOG_TYPE_ERROR))
                            {
                              *(_DWORD *)keys = 136315138;
                              *(void *)&keys[4] = v58;
                              _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "type = %s.\n", keys, 0xCu);
                            }
                          }
                        }
                      }
                    }
                    CFStringRef v59 = (const __CFString *)CFDictionaryGetValue(v52, kSecPropertyKeyValue);
                    if (v59)
                    {
                      CFStringRef v60 = v59;
                      CFTypeID v61 = CFGetTypeID(v59);
                      BOOL v9 = v61 == CFStringGetTypeID();
                      CFArrayRef v47 = v69;
                      if (v9)
                      {
                        v62 = CFStringGetCStringPtr(v60, 0);
                        if (v62)
                        {
                          if (dword_10008FA20)
                          {
                            v63 = v62;
                            v64 = ne_log_obj();
                            if (os_log_type_enabled(v64, OS_LOG_TYPE_ERROR))
                            {
                              *(_DWORD *)keys = 136315138;
                              *(void *)&keys[4] = v63;
                              _os_log_error_impl((void *)&_mh_execute_header, v64, OS_LOG_TYPE_ERROR, "value = %s.\n", keys, 0xCu);
                            }
                          }
                        }
                      }
                    }
                  }
                }
                ++v50;
              }
              while (Count != v50);
            }
            CFAbsoluteTime v7 = &dword_10008FA20;
            if (dword_10008FA20)
            {
              v65 = ne_log_obj();
              if (os_log_type_enabled(v65, OS_LOG_TYPE_ERROR)) {
                sub_100056FCC();
              }
            }
            CFRelease(v47);
          }
          unsigned int v26 = -1;
        }
      }
    }
    CFRelease(v25);
    if (values) {
      CFRelease(values);
    }
    if (v26 - 1 > 0xFFFFFFFD) {
      goto LABEL_118;
    }
    if (*v7)
    {
      v66 = ne_log_obj();
      if (os_log_type_enabled(v66, OS_LOG_TYPE_ERROR)) {
        sub_100056F54();
      }
    }
  }
  else if (*v7)
  {
    v34 = ne_log_obj();
    if (os_log_type_enabled(v34, OS_LOG_TYPE_ERROR)) {
      sub_100056F20();
    }
  }
  unsigned int v26 = -1;
LABEL_118:
  while (v23)
    CFRelease(v20[--v23]);
  CFAllocatorDeallocate(0, v20);
  if (v11) {
    CFRelease(v11);
  }
  if (v26 - 1 <= 0xFFFFFFFD)
  {
    if (*v7)
    {
      v67 = ne_log_obj();
      if (os_log_type_enabled(v67, OS_LOG_TYPE_ERROR)) {
        sub_100056EA8();
      }
    }
    return 0xFFFFFFFFLL;
  }
  if ((v22 - 1) < 2) {
    return 0xFFFFFFFFLL;
  }
  else {
    return v26;
  }
}

const char *sub_100004868(int a1)
{
  switch(a1)
  {
    case -25318:
      SecTrustResultType result = "errSecCreateChainFailed";
      break;
    case -25317:
      SecTrustResultType result = "errSecDataNotModifiable";
      break;
    case -25316:
      SecTrustResultType result = "errSecDataNotAvailable";
      break;
    case -25315:
      SecTrustResultType result = "errSecInteractionRequired";
      break;
    case -25314:
      SecTrustResultType result = "errSecNoPolicyModule";
      break;
    case -25313:
      SecTrustResultType result = "errSecNoCertificateModule";
      break;
    case -25312:
      SecTrustResultType result = "errSecNoStorageModule";
      break;
    case -25311:
      SecTrustResultType result = "errSecKeySizeNotAllowed";
      break;
    case -25310:
      SecTrustResultType result = "errSecWrongSecVersion";
      break;
    case -25309:
      SecTrustResultType result = "errSecReadOnlyAttr";
      break;
    case -25308:
      SecTrustResultType result = "errSecInteractionNotAllowed";
      break;
    case -25307:
      SecTrustResultType result = "errSecNoDefaultKeychain";
      break;
    case -25306:
      SecTrustResultType result = "errSecNoSuchClass";
      break;
    case -25305:
      SecTrustResultType result = "errSecInvalidSearchRef";
      break;
    case -25304:
      SecTrustResultType result = "errSecInvalidItemRef";
      break;
    case -25303:
      SecTrustResultType result = "errSecNoSuchAttr";
      break;
    case -25302:
      SecTrustResultType result = "errSecDataTooLarge";
      break;
    case -25301:
      SecTrustResultType result = "errSecBufferTooSmall";
      break;
    case -25300:
      SecTrustResultType result = "errSecItemNotFound";
      break;
    case -25299:
      SecTrustResultType result = "errSecDuplicateItem";
      break;
    case -25298:
      SecTrustResultType result = "errSecInvalidCallback";
      break;
    case -25297:
      SecTrustResultType result = "errSecDuplicateCallback";
      break;
    case -25296:
      SecTrustResultType result = "errSecDuplicateKeychain";
      break;
    case -25295:
      SecTrustResultType result = "errSecInvalidKeychain";
      break;
    case -25294:
      SecTrustResultType result = "errSecNoSuchKeychain";
      break;
    case -25293:
      SecTrustResultType result = "errSecAuthFailed";
      break;
    case -25292:
      SecTrustResultType result = "errSecReadOnly";
      break;
    case -25291:
      SecTrustResultType result = "errSecNotAvailable";
      break;
    case -25290:
    case -25289:
    case -25288:
    case -25287:
    case -25286:
    case -25285:
    case -25284:
    case -25283:
    case -25282:
    case -25281:
    case -25280:
    case -25279:
    case -25278:
    case -25277:
    case -25276:
    case -25275:
    case -25274:
    case -25273:
    case -25272:
    case -25271:
    case -25270:
    case -25269:
    case -25268:
    case -25267:
    case -25266:
    case -25265:
    case -25264:
    case -25263:
    case -25262:
    case -25261:
    case -25260:
    case -25259:
    case -25258:
    case -25257:
    case -25256:
    case -25255:
    case -25254:
    case -25253:
    case -25252:
    case -25251:
    case -25250:
    case -25249:
    case -25248:
    case -25247:
    case -25246:
    case -25245:
      goto LABEL_5;
    case -25244:
      SecTrustResultType result = "errSecInvalidOwnerEdit";
      break;
    case -25243:
      SecTrustResultType result = "errSecNoAccessForItem";
      break;
    case -25242:
      SecTrustResultType result = "errSecInvalidTrustSetting";
      break;
    case -25241:
      SecTrustResultType result = "errSecPolicyNotFound";
      break;
    case -25240:
      SecTrustResultType result = "errSecACLNotSimple";
      break;
    default:
      if (a1) {
LABEL_5:
      }
        SecTrustResultType result = "<unknown>";
      else {
        SecTrustResultType result = "noErr";
      }
      break;
  }
  return result;
}

uint64_t sub_100004B7C(__SecKey *a1, uint64_t a2, uint64_t a3, int a4)
{
  if (a4) {
    SecPadding v4 = 32770;
  }
  else {
    SecPadding v4 = 1;
  }
  return SecKeyRawVerify(a1, v4, *(const uint8_t **)(a2 + 8), *(void *)a2, *(const uint8_t **)(a3 + 8), *(void *)a3);
}

size_t *sub_100004B9C(void *a1, uint64_t a2)
{
  SecKeyRef privateKeyRef = 0;
  CFTypeRef result = 0;
  keys[0] = (void *)kSecReturnRef;
  keys[1] = (void *)kSecValuePersistentRef;
  keys[2] = (void *)kSecClass;
  keys[3] = (void *)kSecUseSystemKeychain;
  values[0] = kCFBooleanTrue;
  values[1] = a1;
  values[2] = (void *)kSecClassIdentity;
  values[3] = kCFBooleanTrue;
  CFDictionaryRef v3 = CFDictionaryCreate(0, (const void **)keys, (const void **)values, 4, 0, 0);
  CFDictionaryRef v4 = v3;
  if (v3)
  {
    OSStatus v5 = SecItemCopyMatching(v3, &result);
    if (v5 || (OSStatus v5 = SecIdentityCopyPrivateKey((SecIdentityRef)result, &privateKeyRef)) != 0)
    {
      OSStatus v6 = v5;
      CFAbsoluteTime v7 = 0;
    }
    else
    {
      CFAbsoluteTime v7 = sub_10003F940(0x400uLL);
      if (v7) {
        OSStatus v6 = SecKeyRawSign(privateKeyRef, 1u, *(const uint8_t **)(a2 + 8), *(void *)a2, (uint8_t *)v7[1], v7);
      }
      else {
        OSStatus v6 = 0;
      }
    }
  }
  else
  {
    CFAbsoluteTime v7 = 0;
    OSStatus v6 = -1;
  }
  if (result) {
    CFRelease(result);
  }
  if (privateKeyRef) {
    CFRelease(privateKeyRef);
  }
  if (v4) {
    CFRelease(v4);
  }
  if (v6 && v7)
  {
    sub_10003FA78(v7);
    CFAbsoluteTime v7 = 0;
  }
  if ((v6 + 1) >= 2)
  {
    if (dword_10008FA20)
    {
      CFDictionaryRef v8 = ne_log_obj();
      if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR)) {
        sub_100057310();
      }
    }
  }
  return v7;
}

void *sub_100004D60(void *a1, _DWORD *a2)
{
  CFTypeRef result = 0;
  SecCertificateRef certificateRef = 0;
  keys[0] = (void *)kSecReturnRef;
  keys[1] = (void *)kSecValuePersistentRef;
  keys[2] = (void *)kSecClass;
  keys[3] = (void *)kSecUseSystemKeychain;
  values[0] = kCFBooleanTrue;
  values[1] = a1;
  values[2] = (void *)kSecClassIdentity;
  values[3] = kCFBooleanTrue;
  CFDictionaryRef v3 = CFDictionaryCreate(0, (const void **)keys, (const void **)values, 4, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  CFDictionaryRef v4 = v3;
  if (!v3)
  {
    CFDataRef v7 = 0;
    CFDictionaryRef v8 = 0;
    LODWORD(v6) = -1;
    goto LABEL_7;
  }
  OSStatus v5 = SecItemCopyMatching(v3, &result);
  if (v5 || (OSStatus v5 = SecIdentityCopyCertificate((SecIdentityRef)result, &certificateRef)) != 0)
  {
    LODWORD(v6) = v5;
    CFDataRef v7 = 0;
LABEL_5:
    CFDictionaryRef v8 = 0;
    goto LABEL_7;
  }
  CFDataRef v11 = SecCertificateCopyData(certificateRef);
  CFDataRef v7 = v11;
  if (v11)
  {
    size_t Length = CFDataGetLength(v11);
    CFIndex v6 = Length;
    if (!Length) {
      goto LABEL_5;
    }
    uint64_t v13 = sub_10003F940(Length);
    CFDictionaryRef v8 = v13;
    if (v13)
    {
      v18.location = 0;
      v18.length = v6;
      CFDataGetBytes(v7, v18, (UInt8 *)v13[1]);
      if (a2)
      {
        LODWORD(v6) = 0;
        *a2 = sub_100003C04();
        goto LABEL_7;
      }
    }
  }
  else
  {
    CFDictionaryRef v8 = 0;
  }
  LODWORD(v6) = 0;
LABEL_7:
  if (result) {
    CFRelease(result);
  }
  if (certificateRef) {
    CFRelease(certificateRef);
  }
  if (v4) {
    CFRelease(v4);
  }
  if (v7) {
    CFRelease(v7);
  }
  if ((v6 + 1) >= 2)
  {
    if (dword_10008FA20)
    {
      BOOL v9 = ne_log_obj();
      if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR)) {
        sub_100057388();
      }
    }
  }
  return v8;
}

void sub_100004F7C(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_debug_impl(a1, a2, OS_LOG_TYPE_DEBUG, a4, &a9, 2u);
}

void sub_100004F98(void *a1, uint64_t a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_error_impl(a1, v9, OS_LOG_TYPE_ERROR, a4, &a9, 0x12u);
}

uint64_t *sub_100004FC4(CCOperation a1, CCAlgorithm a2, CCOptions a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  size_t v21 = 0;
  uint64_t v12 = sub_10003F940(*(void *)a4);
  uint64_t v13 = v12;
  if (v12)
  {
    CCCryptorStatus v14 = CCCrypt(a1, a2, a3, *(const void **)(a5 + 8), *(void *)a5, *(const void **)(a6 + 8), *(const void **)(a4 + 8), *(void *)a4, (void *)v12[1], *v12, &v21);
    if (v14)
    {
      if (dword_10008FA20)
      {
        CCCryptorStatus v15 = v14;
        uint64_t v16 = ne_log_obj();
        if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 67109632;
          CCOperation v23 = a1;
          __int16 v24 = 1024;
          CCAlgorithm v25 = a2;
          __int16 v26 = 1024;
          LODWORD(v27) = v15;
          _os_log_error_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_ERROR, "crypt %d %d error. status %d.\n", buf, 0x14u);
        }
      }
      sub_10003FA78(v13);
      return 0;
    }
    else if (*v13 != v21 && dword_10008FA20 != 0)
    {
      CFRange v18 = ne_log_obj();
      if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
      {
        uint64_t v20 = *v13;
        *(_DWORD *)buf = 67109888;
        CCOperation v23 = a1;
        __int16 v24 = 1024;
        CCAlgorithm v25 = a2;
        __int16 v26 = 2048;
        uint64_t v27 = v20;
        __int16 v28 = 2048;
        size_t v29 = v21;
        _os_log_error_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "crypt %d %d length mismatch. expected: %zd. got: %zd.\n", buf, 0x22u);
      }
    }
  }
  return v13;
}

uint64_t *sub_1000051A0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return sub_100004FC4(0, 1u, 0, a1, a2, a3);
}

uint64_t *sub_1000051BC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return sub_100004FC4(1u, 1u, 0, a1, a2, a3);
}

uint64_t sub_1000051D8()
{
  return 0;
}

uint64_t sub_1000051E0(int a1)
{
  if ((a1 & 0xFFFFFFBF) != 0) {
    return 0xFFFFFFFFLL;
  }
  else {
    return 64;
  }
}

uint64_t *sub_1000051F0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return sub_100004FC4(0, 2u, 0, a1, a2, a3);
}

uint64_t *sub_10000520C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return sub_100004FC4(1u, 2u, 0, a1, a2, a3);
}

uint64_t sub_100005228()
{
  return 0;
}

uint64_t sub_100005230(int a1)
{
  if (a1) {
    BOOL v1 = a1 == 192;
  }
  else {
    BOOL v1 = 1;
  }
  if (v1) {
    return 192;
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

uint64_t *sub_100005244(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return sub_100004FC4(0, 0, 0, a1, a2, a3);
}

uint64_t *sub_100005260(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return sub_100004FC4(1u, 0, 0, a1, a2, a3);
}

uint64_t sub_10000527C(uint64_t result)
{
  HIDWORD(v2) = result;
  LODWORD(v2) = result;
  int v1 = v2 >> 6;
  unsigned int v3 = v1 - 2;
  if (v1) {
    unsigned int v4 = -1;
  }
  else {
    unsigned int v4 = 128;
  }
  if (v3 >= 3) {
    return v4;
  }
  else {
    return result;
  }
}

uint64_t sub_1000052A0()
{
  return 0;
}

uint64_t sub_1000052A8()
{
  return 0;
}

uint64_t sub_1000052B0()
{
  return 0;
}

void *sub_1000052B8(uint64_t a1, uint64_t a2)
{
  unsigned int v4 = (CCHmacContext *)malloc_type_malloc(0x180uLL, 0x10000400F47AF14uLL);
  CCHmacInit(v4, 4u, *(const void **)(a1 + 8), *(void *)a1);
  CCHmacUpdate(v4, *(const void **)(a2 + 8), *(void *)a2);

  return sub_100005384(v4);
}

CCHmacContext *sub_10000532C(uint64_t a1)
{
  unint64_t v2 = (CCHmacContext *)malloc_type_malloc(0x180uLL, 0x10000400F47AF14uLL);
  CCHmacInit(v2, 4u, *(const void **)(a1 + 8), *(void *)a1);
  return v2;
}

void sub_100005378(CCHmacContext *a1, uint64_t a2)
{
}

void *sub_100005384(CCHmacContext *a1)
{
  unint64_t v2 = sub_10003F940(0x40uLL);
  unsigned int v3 = v2;
  if (v2)
  {
    CCHmacFinal(a1, (void *)v2[1]);
    *unsigned int v3 = 64;
    free(a1);
  }
  return v3;
}

void *sub_1000053D4(uint64_t a1, uint64_t a2)
{
  unsigned int v4 = (CCHmacContext *)malloc_type_malloc(0x180uLL, 0x10000400F47AF14uLL);
  CCHmacInit(v4, 3u, *(const void **)(a1 + 8), *(void *)a1);
  CCHmacUpdate(v4, *(const void **)(a2 + 8), *(void *)a2);

  return sub_1000054A0(v4);
}

CCHmacContext *sub_100005448(uint64_t a1)
{
  unint64_t v2 = (CCHmacContext *)malloc_type_malloc(0x180uLL, 0x10000400F47AF14uLL);
  CCHmacInit(v2, 3u, *(const void **)(a1 + 8), *(void *)a1);
  return v2;
}

void sub_100005494(CCHmacContext *a1, uint64_t a2)
{
}

void *sub_1000054A0(CCHmacContext *a1)
{
  unint64_t v2 = sub_10003F940(0x30uLL);
  unsigned int v3 = v2;
  if (v2)
  {
    CCHmacFinal(a1, (void *)v2[1]);
    *unsigned int v3 = 48;
    free(a1);
  }
  return v3;
}

void *sub_1000054F0(uint64_t a1, uint64_t a2)
{
  unsigned int v4 = (CCHmacContext *)malloc_type_malloc(0x180uLL, 0x10000400F47AF14uLL);
  CCHmacInit(v4, 2u, *(const void **)(a1 + 8), *(void *)a1);
  CCHmacUpdate(v4, *(const void **)(a2 + 8), *(void *)a2);

  return sub_1000055BC(v4);
}

CCHmacContext *sub_100005564(uint64_t a1)
{
  unint64_t v2 = (CCHmacContext *)malloc_type_malloc(0x180uLL, 0x10000400F47AF14uLL);
  CCHmacInit(v2, 2u, *(const void **)(a1 + 8), *(void *)a1);
  return v2;
}

void sub_1000055B0(CCHmacContext *a1, uint64_t a2)
{
}

void *sub_1000055BC(CCHmacContext *a1)
{
  unint64_t v2 = sub_10003F940(0x20uLL);
  unsigned int v3 = v2;
  if (v2)
  {
    CCHmacFinal(a1, (void *)v2[1]);
    *unsigned int v3 = 32;
    free(a1);
  }
  return v3;
}

void *sub_10000560C(uint64_t a1, uint64_t a2)
{
  unsigned int v4 = (CCHmacContext *)malloc_type_malloc(0x180uLL, 0x10000400F47AF14uLL);
  CCHmacInit(v4, 0, *(const void **)(a1 + 8), *(void *)a1);
  CCHmacUpdate(v4, *(const void **)(a2 + 8), *(void *)a2);

  return sub_1000056D8(v4);
}

CCHmacContext *sub_100005680(uint64_t a1)
{
  unint64_t v2 = (CCHmacContext *)malloc_type_malloc(0x180uLL, 0x10000400F47AF14uLL);
  CCHmacInit(v2, 0, *(const void **)(a1 + 8), *(void *)a1);
  return v2;
}

void sub_1000056CC(CCHmacContext *a1, uint64_t a2)
{
}

void *sub_1000056D8(CCHmacContext *a1)
{
  unint64_t v2 = sub_10003F940(0x14uLL);
  unsigned int v3 = v2;
  if (v2)
  {
    CCHmacFinal(a1, (void *)v2[1]);
    *unsigned int v3 = 20;
    free(a1);
  }
  return v3;
}

void *sub_100005728(uint64_t a1, uint64_t a2)
{
  unsigned int v4 = (CCHmacContext *)malloc_type_malloc(0x180uLL, 0x10000400F47AF14uLL);
  CCHmacInit(v4, 1u, *(const void **)(a1 + 8), *(void *)a1);
  CCHmacUpdate(v4, *(const void **)(a2 + 8), *(void *)a2);

  return sub_1000057F4(v4);
}

CCHmacContext *sub_10000579C(uint64_t a1)
{
  unint64_t v2 = (CCHmacContext *)malloc_type_malloc(0x180uLL, 0x10000400F47AF14uLL);
  CCHmacInit(v2, 1u, *(const void **)(a1 + 8), *(void *)a1);
  return v2;
}

void sub_1000057E8(CCHmacContext *a1, uint64_t a2)
{
}

void *sub_1000057F4(CCHmacContext *a1)
{
  unint64_t v2 = sub_10003F940(0x10uLL);
  unsigned int v3 = v2;
  if (v2)
  {
    CCHmacFinal(a1, (void *)v2[1]);
    *unsigned int v3 = 16;
    free(a1);
  }
  return v3;
}

void *sub_100005844(uint64_t a1, uint64_t a2)
{
  unsigned int v4 = (CCHmacContext *)malloc_type_malloc(0x180uLL, 0x10000400F47AF14uLL);
  CCHmacInit(v4, 0, *(const void **)(a1 + 8), *(void *)a1);
  CCHmacUpdate(v4, *(const void **)(a2 + 8), *(void *)a2);

  return sub_100005910(v4);
}

CCHmacContext *sub_1000058B8(uint64_t a1)
{
  unint64_t v2 = (CCHmacContext *)malloc_type_malloc(0x180uLL, 0x10000400F47AF14uLL);
  CCHmacInit(v2, 0, *(const void **)(a1 + 8), *(void *)a1);
  return v2;
}

void sub_100005904(CCHmacContext *a1, uint64_t a2)
{
}

void *sub_100005910(CCHmacContext *a1)
{
  unint64_t v2 = (CCHmacContext *)malloc_type_malloc(0x14uLL, 0x16DB4ACAuLL);
  if (!v2) {
    return 0;
  }
  unsigned int v3 = v2;
  unsigned int v4 = sub_10003F940(0xCuLL);
  if (v4)
  {
    CCHmacFinal(a1, v3);
    uint64_t v5 = v4[1];
    uint64_t v6 = *(void *)v3->ctx;
    *(_DWORD *)(v5 + 8) = v3->ctx[2];
    *(void *)uint64_t v5 = v6;
    *unsigned int v4 = 12;
    free(v3);
    CFDataRef v7 = a1;
  }
  else
  {
    CFDataRef v7 = v3;
  }
  free(v7);
  return v4;
}

void *sub_1000059AC(uint64_t a1, uint64_t a2)
{
  unsigned int v4 = (CCHmacContext *)malloc_type_malloc(0x180uLL, 0x10000400F47AF14uLL);
  CCHmacInit(v4, 1u, *(const void **)(a1 + 8), *(void *)a1);
  CCHmacUpdate(v4, *(const void **)(a2 + 8), *(void *)a2);

  return sub_100005A6C(v4);
}

CCHmacContext *sub_100005A20(uint64_t a1)
{
  unint64_t v2 = (CCHmacContext *)malloc_type_malloc(0x180uLL, 0x10000400F47AF14uLL);
  CCHmacInit(v2, 1u, *(const void **)(a1 + 8), *(void *)a1);
  return v2;
}

void *sub_100005A6C(CCHmacContext *a1)
{
  unint64_t v2 = (CCHmacContext *)malloc_type_malloc(0x10uLL, 0xCCDBC132uLL);
  if (!v2) {
    return 0;
  }
  unsigned int v3 = v2;
  unsigned int v4 = sub_10003F940(0xCuLL);
  if (v4)
  {
    CCHmacFinal(a1, v3);
    uint64_t v5 = v4[1];
    uint64_t v6 = *(void *)v3->ctx;
    *(_DWORD *)(v5 + 8) = v3->ctx[2];
    *(void *)uint64_t v5 = v6;
    *unsigned int v4 = 12;
    free(v3);
    CFDataRef v7 = a1;
  }
  else
  {
    CFDataRef v7 = v3;
  }
  free(v7);
  return v4;
}

CC_SHA512_CTX *sub_100005B08()
{
  v0 = (CC_SHA512_CTX *)malloc_type_malloc(0xD0uLL, 0x10000400F93440CuLL);
  CC_SHA512_Init(v0);
  return v0;
}

uint64_t sub_100005B48(CC_SHA512_CTX *a1, uint64_t a2)
{
  return CC_SHA512_Update(a1, *(const void **)(a2 + 8), *(_DWORD *)a2);
}

void *sub_100005B58(CC_SHA512_CTX *a1)
{
  unint64_t v2 = sub_10003F940(0x40uLL);
  unsigned int v3 = v2;
  if (v2)
  {
    CC_SHA512_Final((unsigned __int8 *)v2[1], a1);
    free(a1);
  }
  return v3;
}

void *sub_100005BA0(uint64_t a1)
{
  unint64_t v2 = (CC_SHA512_CTX *)malloc_type_malloc(0xD0uLL, 0x10000400F93440CuLL);
  CC_SHA512_Init(v2);
  CC_SHA512_Update(v2, *(const void **)(a1 + 8), *(_DWORD *)a1);

  return sub_100005B58(v2);
}

uint64_t sub_100005C04()
{
  return 512;
}

CC_SHA512_CTX *sub_100005C0C()
{
  v0 = (CC_SHA512_CTX *)malloc_type_malloc(0xD0uLL, 0x10000400F93440CuLL);
  CC_SHA384_Init(v0);
  return v0;
}

uint64_t sub_100005C4C(CC_SHA512_CTX *a1, uint64_t a2)
{
  return CC_SHA384_Update(a1, *(const void **)(a2 + 8), *(_DWORD *)a2);
}

void *sub_100005C5C(CC_SHA512_CTX *a1)
{
  unint64_t v2 = sub_10003F940(0x30uLL);
  unsigned int v3 = v2;
  if (v2)
  {
    CC_SHA384_Final((unsigned __int8 *)v2[1], a1);
    free(a1);
  }
  return v3;
}

void *sub_100005CA4(uint64_t a1)
{
  unint64_t v2 = (CC_SHA512_CTX *)malloc_type_malloc(0xD0uLL, 0x10000400F93440CuLL);
  CC_SHA384_Init(v2);
  CC_SHA384_Update(v2, *(const void **)(a1 + 8), *(_DWORD *)a1);

  return sub_100005C5C(v2);
}

uint64_t sub_100005D08()
{
  return 384;
}

CC_SHA256_CTX *sub_100005D10()
{
  v0 = (CC_SHA256_CTX *)malloc_type_malloc(0x68uLL, 0x1000040ED882C02uLL);
  CC_SHA256_Init(v0);
  return v0;
}

uint64_t sub_100005D50(CC_SHA256_CTX *a1, uint64_t a2)
{
  return CC_SHA256_Update(a1, *(const void **)(a2 + 8), *(_DWORD *)a2);
}

void *sub_100005D60(CC_SHA256_CTX *a1)
{
  unint64_t v2 = sub_10003F940(0x20uLL);
  unsigned int v3 = v2;
  if (v2)
  {
    CC_SHA256_Final((unsigned __int8 *)v2[1], a1);
    free(a1);
  }
  return v3;
}

void *sub_100005DA8(uint64_t a1)
{
  unint64_t v2 = (CC_SHA256_CTX *)malloc_type_malloc(0x68uLL, 0x1000040ED882C02uLL);
  CC_SHA256_Init(v2);
  CC_SHA256_Update(v2, *(const void **)(a1 + 8), *(_DWORD *)a1);

  return sub_100005D60(v2);
}

uint64_t sub_100005E0C()
{
  return 256;
}

CC_SHA1_CTX *sub_100005E14()
{
  v0 = (CC_SHA1_CTX *)malloc_type_malloc(0x60uLL, 0x1000040565EDBD2uLL);
  CC_SHA1_Init(v0);
  return v0;
}

uint64_t sub_100005E54(CC_SHA1_CTX *a1, uint64_t a2)
{
  return CC_SHA1_Update(a1, *(const void **)(a2 + 8), *(_DWORD *)a2);
}

void *sub_100005E64(CC_SHA1_CTX *a1)
{
  unint64_t v2 = sub_10003F940(0x14uLL);
  unsigned int v3 = v2;
  if (v2)
  {
    CC_SHA1_Final((unsigned __int8 *)v2[1], a1);
    free(a1);
  }
  return v3;
}

void *sub_100005EAC(uint64_t a1)
{
  unint64_t v2 = (CC_SHA1_CTX *)malloc_type_malloc(0x60uLL, 0x1000040565EDBD2uLL);
  CC_SHA1_Init(v2);
  CC_SHA1_Update(v2, *(const void **)(a1 + 8), *(_DWORD *)a1);

  return sub_100005E64(v2);
}

uint64_t sub_100005F10()
{
  return 160;
}

CC_MD5_CTX *sub_100005F18()
{
  v0 = (CC_MD5_CTX *)malloc_type_malloc(0x5CuLL, 0x100004034A301B9uLL);
  CC_MD5_Init(v0);
  return v0;
}

uint64_t sub_100005F58(CC_MD5_CTX *a1, uint64_t a2)
{
  return CC_MD5_Update(a1, *(const void **)(a2 + 8), *(_DWORD *)a2);
}

void *sub_100005F68(CC_MD5_CTX *a1)
{
  unint64_t v2 = sub_10003F940(0x10uLL);
  unsigned int v3 = v2;
  if (v2)
  {
    CC_MD5_Final((unsigned __int8 *)v2[1], a1);
    free(a1);
  }
  return v3;
}

void *sub_100005FB0(uint64_t a1)
{
  unint64_t v2 = (CC_MD5_CTX *)malloc_type_malloc(0x5CuLL, 0x100004034A301B9uLL);
  CC_MD5_Init(v2);
  CC_MD5_Update(v2, *(const void **)(a1 + 8), *(_DWORD *)a1);

  return sub_100005F68(v2);
}

uint64_t sub_100006014()
{
  return 128;
}

void *sub_10000601C(unsigned int a1)
{
  size_t v1 = a1;
  unint64_t v2 = sub_10003F940(a1);
  if (v2 && SecRandomCopyBytes(kSecRandomDefault, v1, (void *)v2[1]))
  {
    sub_10003FA78(v2);
    return 0;
  }
  return v2;
}

uint64_t sub_100006078()
{
  v0 = sub_10000601C(4u);
  uint64_t v1 = *(unsigned int *)v0[1];
  sub_10003FA78(v0);
  return v1;
}

void *sub_1000060AC()
{
  CFTypeRef result = malloc_type_calloc(0x10uLL, 1uLL, 0x46AAAA86uLL);
  *CFTypeRef result = 0;
  result[1] = result;
  return result;
}

void *sub_1000060D8(uint64_t *a1, uint64_t a2)
{
  CFTypeRef result = malloc_type_calloc(0x18uLL, 1uLL, 0x9D051F30uLL);
  *CFTypeRef result = a2;
  uint64_t v5 = *a1;
  result[1] = *a1;
  if (v5) {
    uint64_t v6 = (void *)(v5 + 16);
  }
  else {
    uint64_t v6 = a1 + 1;
  }
  *uint64_t v6 = result + 1;
  *a1 = (uint64_t)result;
  result[2] = a1;
  return result;
}

void *sub_10000613C(uint64_t a1, uint64_t a2)
{
  CFTypeRef result = malloc_type_calloc(0x18uLL, 1uLL, 0xD063D6B9uLL);
  result[1] = 0;
  *CFTypeRef result = a2;
  uint64_t v5 = *(void **)(a1 + 8);
  result[2] = v5;
  *uint64_t v5 = result;
  *(void *)(a1 + 8) = result + 1;
  return result;
}

uint64_t sub_100006190(void *a1, uint64_t (*a2)(void, uint64_t), uint64_t a3)
{
  unsigned int v3 = (void *)*a1;
  if (!*a1) {
    return 0;
  }
  while (1)
  {
    uint64_t result = a2(*v3, a3);
    if (result) {
      break;
    }
    unsigned int v3 = (void *)v3[1];
    if (!v3) {
      return 0;
    }
  }
  return result;
}

uint64_t sub_1000061E0(void *a1, void *a2)
{
  if (a1)
  {
    unint64_t v2 = (void *)*a1;
    if (!a2)
    {
      if (!v2) {
        return 0;
      }
      return *v2;
    }
  }
  else
  {
    if (!a2) {
      return 0;
    }
    unint64_t v2 = (void *)*a2;
    if (*a2) {
      unint64_t v2 = (void *)v2[1];
    }
  }
  *a2 = v2;
  if (v2) {
    return *v2;
  }
  return 0;
}

void sub_10000621C(void *a1, void (*a2)(void))
{
  for (uint64_t i = **(void ***)(a1[1] + 8); i; uint64_t i = **(void ***)(a1[1] + 8))
  {
    uint64_t v5 = i[1];
    uint64_t v6 = (void *)i[2];
    if (v5)
    {
      *(void *)(v5 + 16) = v6;
      uint64_t v6 = (void *)i[2];
    }
    else
    {
      a1[1] = v6;
    }
    *uint64_t v6 = v5;
    if (a2) {
      a2(*i);
    }
    free(i);
  }

  free(a1);
}

void *sub_1000062AC()
{
  uint64_t v0 = qword_10008F848;
  uint64_t result = *(void **)(qword_10008F848 + 120);
  if (result)
  {
    do
    {
      unint64_t v2 = (void *)*result;
      sub_1000062F4(result);
      uint64_t result = v2;
    }
    while (v2);
    uint64_t v0 = qword_10008F848;
  }
  *(void *)(v0 + 120) = 0;
  return result;
}

void sub_1000062F4(void *a1)
{
  unint64_t v2 = (void *)a1[1];
  if (v2) {
    free(v2);
  }
  unsigned int v3 = (void *)a1[5];
  if (v3) {
    free(v3);
  }

  free(a1);
}

uint64_t *sub_100006340(const sockaddr *a1, int a2)
{
  uint64_t i = 0;
  if (!getnameinfo(a1, a1->sa_len, __s1, 0x401u, 0, 0, 2))
  {
    for (uint64_t i = *(uint64_t **)(qword_10008F848 + 120); i; uint64_t i = (uint64_t *)*i)
    {
      uint64_t v5 = (const sockaddr *)i[1];
      if (v5 && (a2 != 0) == (*((_DWORD *)i + 8) != 0) && a1->sa_family == v5->sa_family)
      {
        if (getnameinfo(v5, v5->sa_len, __s2, 0x401u, 0, 0, 2)) {
          return 0;
        }
        if (!strcmp(__s1, __s2)) {
          return i;
        }
      }
    }
  }
  return i;
}

void sub_100006468()
{
  v35 = 0;
  if (getifaddrs(&v35))
  {
    if (dword_10008FA20)
    {
      size_t v29 = ne_log_obj();
      if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR)) {
        sub_1000575D0(v29);
      }
    }
    goto LABEL_74;
  }
  for (uint64_t i = *(uint64_t **)(qword_10008F848 + 120); i; uint64_t i = (uint64_t *)*i)
    *((_DWORD *)i + 9) = 0;
  uint64_t v1 = v35;
  if (!v35)
  {
    __int16 v28 = 0;
    goto LABEL_55;
  }
  unint64_t v2 = "llw";
  do
  {
    ifa_addr = v1->ifa_addr;
    int sa_family = ifa_addr->sa_family;
    if (sa_family != 30 && sa_family != 2) {
      goto LABEL_52;
    }
    ifa_name = v1->ifa_name;
    if (ifa_name)
    {
      if (strnstr(v1->ifa_name, "awdl", 0x10uLL) || strnstr(ifa_name, v2, 0x10uLL)) {
        goto LABEL_52;
      }
      ifa_addr = v1->ifa_addr;
      int sa_family = ifa_addr->sa_family;
    }
    if (sa_family != 2)
    {
      if (sa_family != 30) {
        goto LABEL_49;
      }
      int v7 = socket(30, 2, 0);
      if (v7 == -1)
      {
        if (dword_10008FA20)
        {
          int v22 = ne_log_obj();
          if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR)) {
            sub_1000574D0(&v41, &v42);
          }
        }
        goto LABEL_49;
      }
      int v8 = v7;
      uint64_t v9 = v2;
      if (fcntl(v7, 4, 4) == -1)
      {
        if (dword_10008FA20)
        {
          uint64_t v10 = ne_log_obj();
          if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR)) {
            sub_100057590(&v36, v37, v10);
          }
        }
      }
      long long v57 = 0u;
      long long v58 = 0u;
      long long v55 = 0u;
      long long v56 = 0u;
      long long v53 = 0u;
      long long v54 = 0u;
      long long v51 = 0u;
      long long v52 = 0u;
      long long v49 = 0u;
      long long v50 = 0u;
      long long v47 = 0u;
      long long v48 = 0u;
      long long v45 = 0u;
      long long v46 = 0u;
      long long v44 = 0u;
      memset(buf, 0, sizeof(buf));
      __strlcpy_chk();
      long long v11 = *(_OWORD *)&ifa_addr->sa_data[10];
      *(sockaddr *)&buf[16] = *ifa_addr;
      *(_OWORD *)&buf[28] = v11;
      if (ioctl(v8, 0xC1206949uLL, buf) < 0)
      {
        unint64_t v2 = v9;
        if (dword_10008FA20)
        {
          CCOperation v23 = ne_log_obj();
          if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR)) {
            sub_100057530(&v39, &v40);
          }
        }
        close(v8);
LABEL_49:
        if (dword_10008FA20)
        {
          __int16 v24 = ne_log_obj();
          if (os_log_type_enabled(v24, OS_LOG_TYPE_DEBUG))
          {
            CCAlgorithm v25 = v1->ifa_name;
            __int16 v26 = sub_10003CE24(v1->ifa_addr);
            *(_DWORD *)buf = 136315394;
            *(void *)&uint8_t buf[4] = v25;
            *(_WORD *)&buf[12] = 2080;
            *(void *)&buf[14] = v26;
            _os_log_debug_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEBUG, "unsuitable address: %s %s\n", buf, 0x16u);
          }
        }
        goto LABEL_52;
      }
      close(v8);
      unint64_t v2 = v9;
      if ((buf[16] & 0x1D) != 0) {
        goto LABEL_49;
      }
      ifa_addr = v1->ifa_addr;
    }
    uint64_t v12 = sub_100006340(ifa_addr, 0);
    if (v12)
    {
      uint64_t v13 = (long long *)v12;
      *((_DWORD *)v12 + 9) = 1;
      CCCryptorStatus v14 = sub_100006340(v1->ifa_addr, 1);
      if (v14)
      {
        *((_DWORD *)v14 + 9) = 1;
        goto LABEL_52;
      }
      if (sub_1000404AC())
      {
        size_t v21 = sub_100006A10(v13);
        if (v21) {
          goto LABEL_44;
        }
        if (dword_10008FA20)
        {
          v34 = ne_log_obj();
          if (os_log_type_enabled(v34, OS_LOG_TYPE_ERROR)) {
            goto LABEL_73;
          }
        }
        goto LABEL_74;
      }
    }
    else
    {
      CCCryptorStatus v15 = sub_100006B4C();
      if (!v15)
      {
        if (dword_10008FA20)
        {
          int v30 = ne_log_obj();
          if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR)) {
            sub_100057400();
          }
        }
        goto LABEL_74;
      }
      uint64_t v16 = v15;
      uint64_t v17 = (const sockaddr *)sub_10003CC74();
      v16[1] = v17;
      if (!v17)
      {
        if (dword_10008FA20)
        {
          int v31 = ne_log_obj();
          if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR)) {
            sub_100057434();
          }
        }
        goto LABEL_74;
      }
      CFRange v18 = v17;
      int v19 = strdup(v1->ifa_name);
      v16[5] = v19;
      if (!v19)
      {
        if (dword_10008FA20)
        {
          v32 = ne_log_obj();
          if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR)) {
            sub_100057468();
          }
        }
        goto LABEL_74;
      }
      *((_DWORD *)v16 + 9) = 1;
      if (getnameinfo(v18, v18->sa_len, v38, 0x401u, 0, 0, 2)) {
        __strlcpy_chk();
      }
      if (dword_10008FA20)
      {
        uint64_t v20 = ne_log_obj();
        if (os_log_type_enabled(v20, OS_LOG_TYPE_DEBUG))
        {
          uint64_t v27 = v1->ifa_name;
          *(_DWORD *)buf = 136315394;
          *(void *)&uint8_t buf[4] = v38;
          *(_WORD *)&buf[12] = 2080;
          *(void *)&buf[14] = v27;
          _os_log_debug_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEBUG, "my interface: %s (%s)\n", buf, 0x16u);
        }
      }
      void *v16 = *(void *)(qword_10008F848 + 120);
      *(void *)(qword_10008F848 + 120) = v16;
      if (sub_1000404AC())
      {
        size_t v21 = sub_100006A10((long long *)v16);
        if (v21)
        {
LABEL_44:
          *((_DWORD *)v21 + 8) = 1;
          goto LABEL_52;
        }
        if (dword_10008FA20)
        {
          int v33 = ne_log_obj();
          if (os_log_type_enabled(v33, OS_LOG_TYPE_ERROR)) {
LABEL_73:
          }
            sub_10005749C();
        }
LABEL_74:
        exit(1);
      }
    }
LABEL_52:
    uint64_t v1 = v1->ifa_next;
  }
  while (v1);
  __int16 v28 = v35;
LABEL_55:
  freeifaddrs(v28);
}

void *sub_100006A10(long long *a1)
{
  unint64_t v2 = malloc_type_calloc(1uLL, 0x30uLL, 0x1030040DBADB428uLL);
  if (!v2)
  {
    if (dword_10008FA20)
    {
      uint64_t v9 = ne_log_obj();
      if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR)) {
        sub_100057664();
      }
    }
    return 0;
  }
  unsigned int v3 = v2;
  long long v4 = *a1;
  long long v5 = a1[2];
  v2[1] = a1[1];
  v2[2] = v5;
  *unint64_t v2 = v4;
  uint64_t v6 = sub_10003CC74();
  v3[1] = v6;
  if (!v6)
  {
    if (dword_10008FA20)
    {
      uint64_t v10 = ne_log_obj();
      if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR)) {
        sub_100057698();
      }
    }
    goto LABEL_16;
  }
  int v7 = (const char *)*((void *)a1 + 5);
  if (v7)
  {
    int v8 = strdup(v7);
    v3[5] = v8;
    if (!v8)
    {
      if (dword_10008FA20)
      {
        long long v11 = ne_log_obj();
        if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR)) {
          sub_1000576CC();
        }
      }
      free((void *)v3[1]);
LABEL_16:
      free(v3);
      return 0;
    }
  }
  v3[3] = 0;
  *((_DWORD *)v3 + 4) = -1;
  *unsigned int v3 = *(void *)a1;
  *(void *)a1 = v3;
  return v3;
}

void *sub_100006B4C()
{
  uint64_t v0 = malloc_type_calloc(1uLL, 0x30uLL, 0x1030040DBADB428uLL);
  uint64_t v1 = v0;
  if (v0)
  {
    v0[3] = 0;
    void *v0 = 0;
    v0[1] = 0;
    *((_DWORD *)v0 + 4) = -1;
  }
  else if (dword_10008FA20)
  {
    unint64_t v2 = ne_log_obj();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR)) {
      sub_100057664();
    }
  }
  return v1;
}

uint64_t sub_100006BD4()
{
  if (dword_10008FA20)
  {
    uint64_t v0 = ne_log_obj();
    if (os_log_type_enabled(v0, OS_LOG_TYPE_DEBUG)) {
      sub_100057778();
    }
  }
  uint64_t v1 = *(uint64_t **)(qword_10008F848 + 120);
  if (v1)
  {
    int v2 = 0;
    do
    {
      if (*((_DWORD *)v1 + 8)) {
        uint64_t v3 = 18;
      }
      else {
        uint64_t v3 = 16;
      }
      sub_10003D910(v1[1], *(unsigned __int16 *)(qword_10008F848 + v3));
      ++v2;
      uint64_t v1 = (uint64_t *)*v1;
    }
    while (v1);
  }
  else
  {
    int v2 = 0;
  }
  if (dword_10008FA20)
  {
    long long v4 = ne_log_obj();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG)) {
      sub_100057700(v2, v4);
    }
  }
  return 0;
}

uint64_t sub_100006CB0(unint64_t a1)
{
  uint64_t v1 = *(void **)(qword_10008F848 + 120);
  if (v1)
  {
    uint64_t v3 = 0;
    do
    {
      long long v5 = v1 + 1;
      unint64_t v4 = v1[1];
      if (v4 && !sub_10003B8E4(a1, v4))
      {
        uint64_t v6 = v1;
        if (!v3) {
          goto LABEL_6;
        }
        int v7 = *(unsigned __int8 *)(*v5 + 1);
        if (v7 == 30 || v7 == 2)
        {
          if (*(_WORD *)(*v5 + 2) == 500) {
            uint64_t v6 = v1;
          }
          else {
            uint64_t v6 = v3;
          }
          goto LABEL_6;
        }
        if (dword_10008FA20)
        {
          int v8 = ne_log_obj();
          if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR)) {
            sub_1000577AC(v10, (uint64_t)(v1 + 1), &v11, v8);
          }
        }
      }
      uint64_t v6 = v3;
LABEL_6:
      uint64_t v1 = (void *)*v1;
      uint64_t v3 = v6;
    }
    while (v1);
  }
  return 62465;
}

void *sub_100006DD8(void *result, void *a2)
{
  *uint64_t result = *a2;
  *a2 = result;
  return result;
}

uint64_t sub_100006DE8()
{
  sub_100006468();
  sub_100023DB8();
  sub_100006BD4();

  return sub_100022FFC();
}

uint64_t sub_100006E18()
{
  if (!*(void *)(qword_10008F848 + 120) && *(_DWORD *)(qword_10008F848 + 112) == 1)
  {
    sub_100006468();
    sub_100006BD4();
  }
  return 0;
}

uint64_t sub_100006E58(unsigned __int8 *__s1)
{
  int v2 = *(void **)(qword_10008F848 + 120);
  if (v2)
  {
    uint64_t v3 = 0;
    do
    {
      unint64_t v4 = (unsigned __int8 *)v2[1];
      if (v4)
      {
        if (__s1[1] == v4[1])
        {
          size_t v5 = *__s1;
          uint64_t v3 = v2;
          if (v5 == *v4)
          {
            int v6 = memcmp(__s1, v4, v5);
            uint64_t v3 = v2;
            if (!v6)
            {
              uint64_t v3 = v2;
              return *((unsigned int *)v3 + 4);
            }
          }
        }
      }
      int v2 = (void *)*v2;
    }
    while (v2);
    if (!v3) {
      goto LABEL_10;
    }
    return *((unsigned int *)v3 + 4);
  }
  else
  {
LABEL_10:
    if (dword_10008FA20)
    {
      int v8 = ne_log_obj();
      if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR)) {
        sub_100057800((uint64_t)__s1, v8);
      }
    }
    return 0xFFFFFFFFLL;
  }
}

void sub_100006F20()
{
  memset(v5, 0, 512);
  while (1)
  {
    unsigned int v0 = read(*(_DWORD *)(qword_10008F848 + 36), v5, 0x45CuLL);
    if ((v0 & 0x80000000) == 0) {
      break;
    }
    if (*__error() != 4)
    {
      if (dword_10008FA20)
      {
        uint64_t v1 = ne_log_obj();
        if (os_log_type_enabled(v1, OS_LOG_TYPE_DEBUG)) {
          sub_10005787C();
        }
      }
      return;
    }
  }
  if (v0 >= LOWORD(v5[0]))
  {
    if (BYTE3(v5[0]) <= 0xEu && ((1 << SBYTE3(v5[0])) & 0x7004) != 0)
    {
      if (dword_10008FA20)
      {
        unint64_t v4 = ne_log_obj();
        if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG)) {
          sub_100057934((unsigned __int8 *)v5 + 3, v4);
        }
      }
      sub_100006DE8();
    }
  }
  else if (dword_10008FA20)
  {
    int v2 = ne_log_obj();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEBUG)) {
      sub_100057900();
    }
  }
}

void sub_1000070AC()
{
  *(void *)(qword_10008F848 + 56) = 0;
}

uint64_t sub_1000070E4()
{
  int v0 = socket(17, 3, 0);
  *(_DWORD *)(qword_10008F848 + 36) = v0;
  if (v0 < 0)
  {
    if (dword_10008FA20)
    {
      int v7 = ne_log_obj();
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG)) {
        sub_1000579B0();
      }
    }
  }
  else
  {
    if (fcntl(v0, 4, 4) == -1 && dword_10008FA20 != 0)
    {
      int v2 = ne_log_obj();
      if (os_log_type_enabled(v2, OS_LOG_TYPE_DEBUG)) {
        sub_100057A68();
      }
    }
    uint64_t v3 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_read, *(int *)(qword_10008F848 + 36), 0, (dispatch_queue_t)&_dispatch_main_q);
    *(void *)(qword_10008F848 + 56) = v3;
    if (v3)
    {
      dispatch_source_set_event_handler_f(v3, (dispatch_function_t)sub_100006F20);
      int v4 = *(_DWORD *)(qword_10008F848 + 36);
      size_t v5 = *(NSObject **)(qword_10008F848 + 56);
      handler[0] = _NSConcreteStackBlock;
      handler[1] = 0x40000000;
      handler[2] = sub_100007288;
      handler[3] = &unk_100088EA8;
      int v10 = v4;
      dispatch_source_set_cancel_handler(v5, handler);
      dispatch_resume(*(dispatch_object_t *)(qword_10008F848 + 56));
      return 0;
    }
    if (dword_10008FA20)
    {
      int v8 = ne_log_obj();
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG)) {
        sub_100057A34();
      }
    }
  }
  return 0xFFFFFFFFLL;
}

uint64_t sub_100007288(uint64_t a1)
{
  return close(*(_DWORD *)(a1 + 32));
}

void sub_100007290(void *a1, uint64_t a2, uint64_t a3, const char *a4)
{
  _os_log_error_impl(a1, v4, OS_LOG_TYPE_ERROR, a4, v5, 0xCu);
}

void sub_1000072B0(void *a1, uint64_t a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_debug_impl(a1, v9, OS_LOG_TYPE_DEBUG, a4, &a9, 0xCu);
}

uint64_t sub_1000072D0(uint64_t a1, void *a2)
{
  if (a1)
  {
    return sub_100007340(a1, a2);
  }
  else
  {
    uint64_t v4 = qword_1000906D0;
    if (qword_1000906D0)
    {
      while (1)
      {
        uint64_t result = sub_100007340(v4, a2);
        if (result) {
          break;
        }
        uint64_t v4 = *(void *)(v4 + 1712);
        if (!v4) {
          return 0;
        }
      }
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t sub_100007340(uint64_t a1, void *a2)
{
  for (uint64_t result = *(void *)(a1 + 1696); result; uint64_t result = *(void *)(result + 456))
  {
    if ((*(unsigned char *)(result + 17) & 0x40) == 0 && *(void *)result == *a2 && *(void *)(result + 8) == a2[1]) {
      break;
    }
  }
  return result;
}

uint64_t sub_100007370(uint64_t a1, void *a2)
{
  if (a1)
  {
    return sub_1000073E0(a1, a2);
  }
  else
  {
    uint64_t v4 = qword_1000906D0;
    if (qword_1000906D0)
    {
      while (1)
      {
        uint64_t result = sub_1000073E0(v4, a2);
        if (result) {
          break;
        }
        uint64_t v4 = *(void *)(v4 + 1712);
        if (!v4) {
          return 0;
        }
      }
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t sub_1000073E0(uint64_t a1, void *a2)
{
  for (uint64_t result = *(void *)(a1 + 1696); result; uint64_t result = *(void *)(result + 456))
  {
    if ((*(unsigned char *)(result + 17) & 0x40) == 0 && *(void *)result == *a2) {
      break;
    }
  }
  return result;
}

uint64_t sub_10000740C(uint64_t a1, const sockaddr *a2, const sockaddr *a3)
{
  if (dword_10008FA20)
  {
    uint64_t v6 = ne_log_obj();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG)) {
      sub_100057CB4();
    }
    if (dword_10008FA20)
    {
      int v7 = ne_log_obj();
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG)) {
        sub_100057C38(a2);
      }
      if (dword_10008FA20)
      {
        int v8 = ne_log_obj();
        if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG)) {
          sub_100057BBC(a3);
        }
      }
    }
  }
  uint64_t v9 = *(void *)(a1 + 1696);
  if (v9)
  {
    while (1)
    {
      if ((*(unsigned char *)(v9 + 17) & 0x40) == 0)
      {
        if (dword_10008FA20)
        {
          uint64_t v10 = ne_log_obj();
          if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG)) {
            sub_100057B60(&v17, v9, &v18);
          }
          if (dword_10008FA20)
          {
            int v11 = ne_log_obj();
            if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG)) {
              sub_100057B04(&v15, v9, &v16);
            }
          }
        }
        if (!sub_10003BB04((unint64_t)a2, *(void *)(v9 + 56))
          && !sub_10003BB04((unint64_t)a3, *(void *)(v9 + 48)))
        {
          break;
        }
      }
      uint64_t v9 = *(void *)(v9 + 456);
      if (!v9) {
        goto LABEL_21;
      }
    }
    if (dword_10008FA20)
    {
      CCCryptorStatus v14 = ne_log_obj();
      if (os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG)) {
        sub_100057AD0();
      }
    }
  }
  else
  {
LABEL_21:
    if (dword_10008FA20)
    {
      uint64_t v12 = ne_log_obj();
      if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG)) {
        sub_100057A9C();
      }
    }
    return 0;
  }
  return v9;
}

uint64_t sub_100007614(uint64_t a1, unint64_t a2, unint64_t a3)
{
  if (a1)
  {
    return sub_10000769C(a1, a2, a3);
  }
  else
  {
    uint64_t v6 = qword_1000906D0;
    if (qword_1000906D0)
    {
      while (1)
      {
        uint64_t result = sub_10000769C(v6, a2, a3);
        if (result) {
          break;
        }
        uint64_t v6 = *(void *)(v6 + 1712);
        if (!v6) {
          return 0;
        }
      }
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t sub_10000769C(uint64_t a1, unint64_t a2, unint64_t a3)
{
  for (uint64_t i = *(void *)(a1 + 1696); i; uint64_t i = *(void *)(i + 456))
  {
    if ((*(unsigned char *)(i + 17) & 0x40) == 0
      && !sub_10003B8E4(a2, *(void *)(i + 56))
      && !sub_10003B8E4(a3, *(void *)(i + 48)))
    {
      break;
    }
  }
  return i;
}

uint64_t sub_100007704(uint64_t a1, unint64_t a2)
{
  for (uint64_t i = *(void *)(a1 + 1696); i; uint64_t i = *(void *)(i + 456))
  {
    if ((*(unsigned char *)(i + 17) & 0x40) == 0)
    {
      if (*(unsigned char *)(a2 + 1) == 2 && *(_DWORD *)(i + 28))
      {
        nw_nat64_extract_v4();
        if (!*(_DWORD *)(a2 + 4)) {
          return i;
        }
      }
      else if (!sub_10003B8E4(a2, *(void *)(i + 48)))
      {
        return i;
      }
    }
  }
  return i;
}

uint64_t sub_100007798(uint64_t a1, unint64_t a2)
{
  if (a1)
  {
    return sub_100007704(a1, a2);
  }
  else
  {
    uint64_t v4 = qword_1000906D0;
    if (qword_1000906D0)
    {
      while (1)
      {
        uint64_t result = sub_100007704(v4, a2);
        if (result) {
          break;
        }
        uint64_t v4 = *(void *)(v4 + 1712);
        if (!v4) {
          return 0;
        }
      }
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t sub_100007808(uint64_t a1)
{
  uint64_t v1 = *(void *)(*(void *)(a1 + 440) + 1696);
  if (!v1) {
    return 1;
  }
  while (1)
  {
    if ((*(unsigned char *)(v1 + 432) & 2) == 0 && (*(unsigned char *)(v1 + 17) & 0x40) == 0)
    {
      uint64_t result = sub_10003BB04(*(void *)(a1 + 48), *(void *)(v1 + 48));
      if (v1 != a1 && !result) {
        break;
      }
    }
    uint64_t v1 = *(void *)(v1 + 456);
    if (!v1) {
      return 1;
    }
  }
  return result;
}

unsigned char *sub_100007868(char a1)
{
  int v2 = malloc_type_calloc(1uLL, 0x1D8uLL, 0x10A0040AC7A52B7uLL);
  uint64_t v3 = v2;
  if (v2)
  {
    v2[80] = a1;
    *((_DWORD *)v2 + 92) = 0;
    *((void *)v2 + 47) = 0;
    *((void *)v2 + 48) = 0;
    *((_DWORD *)v2 + 98) = 0;
    v2[432] &= ~2u;
    if (dword_10008FA20)
    {
      uint64_t v4 = ne_log_obj();
      if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
      {
        v6[0] = 0;
        _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "New Phase 1\n", (uint8_t *)v6, 2u);
      }
    }
  }
  return v3;
}

void sub_100007920(uint64_t a1)
{
  if (a1)
  {
    int v2 = *(void **)(a1 + 88);
    if (v2)
    {
      free(v2);
      *(void *)(a1 + 88) = 0;
    }
    if (*(void *)(a1 + 408)) {
      sub_10004502C(a1);
    }
    uint64_t v3 = *(void **)(a1 + 424);
    if (v3)
    {
      sub_10003FA78(v3);
      *(void *)(a1 + 424) = 0;
    }
    uint64_t v4 = *(unsigned int *)(a1 + 388);
    if (v4)
    {
      sub_10003AC14(v4);
      *(_DWORD *)(a1 + 388) = 0;
    }
    uint64_t v5 = *(unsigned int *)(a1 + 392);
    if (v5)
    {
      sub_10003AC14(v5);
      *(_DWORD *)(a1 + 392) = 0;
    }
    uint64_t v6 = *(void **)(a1 + 48);
    if (v6)
    {
      free(v6);
      *(void *)(a1 + 48) = 0;
    }
    int v7 = *(void **)(a1 + 56);
    if (v7)
    {
      free(v7);
      *(void *)(a1 + 56) = 0;
    }
    int v8 = *(void **)(a1 + 72);
    if (v8)
    {
      sub_100038EB0(v8);
      *(void *)(a1 + 72) = 0;
    }
    sub_10003AC68(a1);
    uint64_t v9 = *(unsigned int *)(a1 + 112);
    if (v9)
    {
      sub_10003AC14(v9);
      *(_DWORD *)(a1 + 112) = 0;
    }
    uint64_t v10 = *(unsigned int *)(a1 + 116);
    if (v10)
    {
      sub_10003AC14(v10);
      *(_DWORD *)(a1 + 116) = 0;
    }
    uint64_t v11 = *(unsigned int *)(a1 + 120);
    if (v11)
    {
      sub_10003AC14(v11);
      *(_DWORD *)(a1 + 120) = 0;
    }
    uint64_t v12 = *(void **)(a1 + 128);
    if (v12)
    {
      sub_10003FA78(v12);
      *(void *)(a1 + 128) = 0;
    }
    uint64_t v13 = *(void **)(a1 + 144);
    if (v13)
    {
      sub_10003FA78(v13);
      *(void *)(a1 + 144) = 0;
    }
    CCCryptorStatus v14 = *(void **)(a1 + 152);
    if (v14)
    {
      sub_10003FA78(v14);
      *(void *)(a1 + 152) = 0;
    }
    int v15 = *(void **)(a1 + 160);
    if (v15)
    {
      sub_10003FA78(v15);
      *(void *)(a1 + 160) = 0;
    }
    uint64_t v16 = *(void **)(a1 + 168);
    if (v16)
    {
      sub_10003FA78(v16);
      *(void *)(a1 + 168) = 0;
    }
    int v17 = *(void **)(a1 + 176);
    if (v17)
    {
      sub_10003FA78(v17);
      *(void *)(a1 + 176) = 0;
    }
    CFRange v18 = *(void **)(a1 + 184);
    if (v18)
    {
      sub_10003FA78(v18);
      *(void *)(a1 + 184) = 0;
    }
    int v19 = *(void **)(a1 + 192);
    if (v19)
    {
      sub_10003FA78(v19);
      *(void *)(a1 + 192) = 0;
    }
    uint64_t v20 = *(void **)(a1 + 200);
    if (v20)
    {
      sub_10003FA78(v20);
      *(void *)(a1 + 200) = 0;
    }
    size_t v21 = *(void **)(a1 + 208);
    if (v21)
    {
      sub_10003FA78(v21);
      *(void *)(a1 + 208) = 0;
    }
    int v22 = *(void **)(a1 + 216);
    if (v22)
    {
      sub_10003FA78(v22);
      *(void *)(a1 + 216) = 0;
    }
    CCOperation v23 = *(void **)(a1 + 224);
    if (v23)
    {
      sub_10003FA78(v23);
      *(void *)(a1 + 224) = 0;
    }
    __int16 v24 = *(void **)(a1 + 232);
    if (v24)
    {
      sub_10003FA78(v24);
      *(void *)(a1 + 232) = 0;
    }
    CCAlgorithm v25 = *(void **)(a1 + 240);
    if (v25)
    {
      sub_10003FA78(v25);
      *(void *)(a1 + 240) = 0;
    }
    __int16 v26 = *(void **)(a1 + 248);
    if (v26)
    {
      sub_10003FA78(v26);
      *(void *)(a1 + 248) = 0;
    }
    uint64_t v27 = *(void **)(a1 + 256);
    if (v27)
    {
      sub_10003FA78(v27);
      *(void *)(a1 + 256) = 0;
    }
    __int16 v28 = *(void **)(a1 + 264);
    if (v28)
    {
      sub_10003FA78(v28);
      *(void *)(a1 + 264) = 0;
    }
    size_t v29 = *(void **)(a1 + 272);
    if (v29)
    {
      sub_10003FA78(v29);
      *(void *)(a1 + 272) = 0;
    }
    sub_10002BC10(*(void **)(a1 + 280));
    *(void *)(a1 + 280) = 0;
    sub_10002BC10(*(void **)(a1 + 288));
    *(void *)(a1 + 288) = 0;
    sub_10002BC10(*(void **)(a1 + 296));
    *(void *)(a1 + 296) = 0;
    sub_10002BC10(*(void **)(a1 + 304));
    *(void *)(a1 + 304) = 0;
    int v30 = *(void **)(a1 + 312);
    if (v30)
    {
      sub_10003FA78(v30);
      *(void *)(a1 + 312) = 0;
    }
    int v31 = *(void **)(a1 + 320);
    if (v31)
    {
      sub_10003FA78(v31);
      *(void *)(a1 + 320) = 0;
    }
    v32 = *(void **)(a1 + 72);
    if (v32) {
      sub_100038EB0(v32);
    }
    int v33 = *(void **)(a1 + 328);
    if (v33)
    {
      sub_10002DA30(v33);
      *(void *)(a1 + 328) = 0;
    }
    v34 = *(void **)(a1 + 336);
    if (v34)
    {
      sub_10003FA78(v34);
      *(void *)(a1 + 336) = 0;
    }
    v35 = *(void **)(a1 + 344);
    if (v35)
    {
      sub_10003FA78(v35);
      *(void *)(a1 + 344) = 0;
    }
    uint8_t v36 = *(void **)(a1 + 64);
    if (v36)
    {
      sub_100038F78(v36);
      *(void *)(a1 + 64) = 0;
    }
    if (*(void *)(a1 + 136)) {
      SecDHDestroy();
    }
    free((void *)a1);
  }
}

void sub_100007BDC(uint64_t a1, int a2)
{
  uint64_t v2 = *(void *)(a1 + 1696);
  while (v2)
  {
    uint64_t v4 = v2;
    uint64_t v2 = *(void *)(v2 + 456);
    if (a2)
    {
      uint64_t v5 = *(void *)(v4 + 440);
      if (v5 && (*(_WORD *)(v5 + 264) & 0x20) == 0 && (*(unsigned char *)(v5 + 280) & 4) != 0)
      {
        if (!dword_10008FA20) {
          continue;
        }
        uint64_t v12 = ne_log_obj();
        if (!os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT)) {
          continue;
        }
        uint64_t v13 = sub_100023BEC(v4, 0);
        *(_DWORD *)buf = 136315138;
        int v15 = v13;
        int v8 = v12;
        uint64_t v9 = "Skipping Phase 1 %s that's asserted...\n";
LABEL_23:
        _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, v9, buf, 0xCu);
        continue;
      }
      if ((*(unsigned char *)(v4 + 17) & 0x20) != 0)
      {
        if (sub_10004E630(v5) || sub_10004E6AC(*(void *)(v4 + 440)))
        {
          if (!dword_10008FA20) {
            continue;
          }
          uint64_t v6 = ne_log_obj();
          if (!os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT)) {
            continue;
          }
          int v7 = sub_100023BEC(v4, 0);
          *(_DWORD *)buf = 136315138;
          int v15 = v7;
          int v8 = v6;
          uint64_t v9 = "Skipping Phase 1 %s that's established... because it's needed by children Phase 2s\n";
          goto LABEL_23;
        }
LABEL_13:
        if (dword_10008FA20)
        {
          uint64_t v10 = ne_log_obj();
          if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v11 = sub_100023BEC(v4, 0);
            *(_DWORD *)buf = 136315138;
            int v15 = v11;
            _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "Got a Phase 1 %s to flush...\n", buf, 0xCu);
          }
        }
        sub_10001A098(v4);
      }
    }
    else if ((*(unsigned char *)(v4 + 17) & 0x20) != 0)
    {
      goto LABEL_13;
    }
    sub_10004D8F4(*(void *)(v4 + 440), (uint64_t)off_10008C500[0]);
    sub_10004B710(v4);
  }
}

uint64_t sub_100007DF0(int a1)
{
  if (dword_10008FA20)
  {
    uint64_t v2 = ne_log_obj();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      v5[0] = 67109120;
      v5[1] = a1;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Flushing Phase 1 handles: ignore_estab_or_assert %d...\n", (uint8_t *)v5, 8u);
    }
  }
  uint64_t result = qword_1000906D0;
  if (qword_1000906D0)
  {
    do
    {
      uint64_t v4 = *(void *)(result + 1712);
      sub_100007BDC(result, a1);
      uint64_t result = v4;
    }
    while (v4);
  }
  return result;
}

uint64_t sub_100007EC0(int a1)
{
  uint64_t v1 = qword_1000906D0;
  if (!qword_1000906D0) {
    return 0;
  }
  while (1)
  {
    uint64_t v2 = *(void *)(v1 + 1704);
    if (v2) {
      break;
    }
LABEL_5:
    uint64_t v1 = *(void *)(v1 + 1712);
    if (!v1) {
      return 0;
    }
  }
  while (*(_DWORD *)(v2 + 52) != a1)
  {
    uint64_t v2 = *(void *)(v2 + 296);
    if (!v2) {
      goto LABEL_5;
    }
  }
  return v2;
}

uint64_t sub_100007F00(int a1)
{
  uint64_t v1 = qword_1000906D0;
  if (!qword_1000906D0) {
    return 0;
  }
  while (1)
  {
    uint64_t v2 = *(void *)(v1 + 1704);
    if (v2) {
      break;
    }
LABEL_5:
    uint64_t v1 = *(void *)(v1 + 1712);
    if (!v1) {
      return 0;
    }
  }
  while (*(_DWORD *)(v2 + 100) != a1)
  {
    uint64_t v2 = *(void *)(v2 + 296);
    if (!v2) {
      goto LABEL_5;
    }
  }
  return v2;
}

uint64_t sub_100007F40(uint64_t a1, int a2)
{
  for (uint64_t result = *(void *)(*(void *)(a1 + 440) + 1704); result; uint64_t result = *(void *)(result + 296))
  {
    if (*(_DWORD *)(result + 108) == a2 && (*(unsigned char *)(result + 264) & 4) == 0) {
      break;
    }
  }
  return result;
}

uint64_t sub_100007F6C(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 448);
  if (v1)
  {
    uint64_t result = 0;
    while (!result)
    {
      uint64_t result = v1;
      uint64_t v1 = *(void *)(v1 + 296);
      if (!v1) {
        return result;
      }
    }
  }
  return 0;
}

uint64_t sub_100007F98(unint64_t a1, unint64_t a2, int a3)
{
  uint64_t v3 = qword_1000906D0;
  while (v3)
  {
    uint64_t v7 = *(void *)(v3 + 1704);
    uint64_t v3 = *(void *)(v3 + 1712);
    while (v7)
    {
      uint64_t v8 = v7;
      uint64_t v7 = *(void *)(v7 + 296);
      if (*(_DWORD *)(v8 + 52) == a3
        && !sub_10003BB04(a1, *(void *)v8)
        && !sub_10003BB04(a2, *(void *)(v8 + 8)))
      {
        if ((*(unsigned char *)(v8 + 57) & 0x60) != 0
          || *(_DWORD *)(v8 + 72)
          || *(_DWORD *)(v8 + 64)
          || *(_DWORD *)(v8 + 68)
          || *(_DWORD *)(v8 + 96))
        {
          return v8;
        }
        if (dword_10008FA20)
        {
          uint64_t v9 = ne_log_obj();
          if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)uint64_t v11 = 0;
            _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "Zombie ph2 found, expiring it\n", v11, 2u);
          }
        }
        sub_100024ED0((void *)v8);
      }
    }
  }
  return 0;
}

void *sub_1000080D0(uint64_t a1, uint64_t a2, int a3, int a4)
{
  uint64_t v4 = qword_1000906D0;
  if (qword_1000906D0)
  {
    while (1)
    {
      uint64_t result = *(void **)(v4 + 1704);
      if (result) {
        break;
      }
LABEL_17:
      uint64_t v4 = *(void *)(v4 + 1712);
      if (!v4) {
        return 0;
      }
    }
    while (1)
    {
      uint64_t v7 = result[15];
      uint64_t v6 = result[16];
      if (v7)
      {
        if (v6) {
          goto LABEL_11;
        }
        for (uint64_t i = *(void *)(v7 + 32); i; uint64_t i = *(void *)(i + 72))
        {
          if (*(_DWORD *)i != a3) {
            break;
          }
          if (*(_DWORD *)(i + 24) == a4) {
            return result;
          }
        }
      }
      else if (v6)
      {
LABEL_11:
        uint64_t v9 = *(void *)(v6 + 32);
        if (v9)
        {
          while (*(_DWORD *)v9 == a3)
          {
            if (*(_DWORD *)(v9 + 24) == a4 || *(_DWORD *)(v9 + 28) == a4) {
              return result;
            }
            uint64_t v9 = *(void *)(v9 + 72);
            if (!v9) {
              break;
            }
          }
        }
      }
      uint64_t result = (void *)result[37];
      if (!result) {
        goto LABEL_17;
      }
    }
  }
  return 0;
}

void *sub_100008170(uint64_t a1, uint64_t a2, int a3, int a4, _DWORD *a5)
{
  uint64_t v5 = qword_1000906D0;
  if (qword_1000906D0)
  {
    while (1)
    {
      uint64_t result = *(void **)(v5 + 1704);
      if (result) {
        break;
      }
LABEL_18:
      uint64_t v5 = *(void *)(v5 + 1712);
      if (!v5) {
        return 0;
      }
    }
    while (1)
    {
      uint64_t v8 = result[15];
      uint64_t v7 = result[16];
      if (v8)
      {
        if (v7) {
          goto LABEL_12;
        }
        uint64_t v9 = *(void *)(v8 + 32);
        if (v9)
        {
          while (*(_DWORD *)v9 == a3)
          {
            int v10 = *(_DWORD *)(v9 + 24);
            if (v10 == a4) {
              goto LABEL_20;
            }
            if (*(_DWORD *)(v9 + 28) == a4) {
              goto LABEL_22;
            }
            uint64_t v9 = *(void *)(v9 + 72);
            if (!v9) {
              break;
            }
          }
        }
      }
      else if (v7)
      {
LABEL_12:
        uint64_t v9 = *(void *)(v7 + 32);
        if (v9)
        {
          while (1)
          {
            if (*(_DWORD *)v9 != a3) {
              goto LABEL_17;
            }
            int v10 = *(_DWORD *)(v9 + 24);
            if (v10 == a4) {
              break;
            }
            if (*(_DWORD *)(v9 + 28) == a4)
            {
LABEL_22:
              if (!a5) {
                return result;
              }
              goto LABEL_23;
            }
            uint64_t v9 = *(void *)(v9 + 72);
            if (!v9) {
              goto LABEL_17;
            }
          }
LABEL_20:
          if (!a5) {
            return result;
          }
          int v10 = *(_DWORD *)(v9 + 28);
LABEL_23:
          *a5 = v10;
          return result;
        }
      }
LABEL_17:
      uint64_t result = (void *)result[37];
      if (!result) {
        goto LABEL_18;
      }
    }
  }
  return 0;
}

unsigned char *sub_100008234(char a1, int a2)
{
  uint64_t v4 = malloc_type_calloc(1uLL, 0x148uLL, 0x10A00406469B766uLL);
  uint64_t v5 = v4;
  if (v4)
  {
    v4[61] = a1;
    *((_DWORD *)v4 + 12) = a2;
    v4[264] &= ~2u;
    if (dword_10008FA20)
    {
      uint64_t v6 = ne_log_obj();
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
      {
        v8[0] = 0;
        _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "New Phase 2\n", (uint8_t *)v8, 2u);
      }
    }
  }
  return v5;
}

void sub_1000082F0(uint64_t a1)
{
  sub_10003AC68(a1);
  *(void *)(a1 + 64) = 0;
  uint64_t v2 = *(void **)(a1 + 80);
  if (v2)
  {
    sub_10003FA78(v2);
    *(void *)(a1 + 80) = 0;
  }
  uint64_t v3 = *(void **)(a1 + 88);
  if (v3)
  {
    sub_10003FA78(v3);
    *(void *)(a1 + 88) = 0;
  }
  uint64_t v4 = *(void *)(a1 + 120);
  if (v4)
  {
    for (uint64_t i = *(void *)(v4 + 32); i; uint64_t i = *(void *)(i + 72))
      *(_DWORD *)(i + 24) = 0;
  }
  uint64_t v6 = *(uint64_t **)(a1 + 128);
  if (v6)
  {
    sub_100036420(v6);
    *(void *)(a1 + 128) = 0;
  }
  uint64_t v7 = *(void **)(a1 + 136);
  if (v7)
  {
    sub_1000351A8(v7);
    free(*(void **)(a1 + 136));
    *(void *)(a1 + 136) = 0;
  }
  uint64_t v8 = *(void **)(a1 + 152);
  if (v8)
  {
    sub_1000294BC(v8);
    *(void *)(a1 + 152) = 0;
  }
  uint64_t v9 = *(void **)(a1 + 160);
  if (v9)
  {
    sub_10003FA78(v9);
    *(void *)(a1 + 160) = 0;
  }
  int v10 = *(void **)(a1 + 168);
  if (v10)
  {
    sub_10003FA78(v10);
    *(void *)(a1 + 168) = 0;
  }
  uint64_t v11 = *(void **)(a1 + 176);
  if (v11)
  {
    sub_10003FA78(v11);
    *(void *)(a1 + 176) = 0;
  }
  uint64_t v12 = *(void **)(a1 + 184);
  if (v12)
  {
    sub_10003FA78(v12);
    *(void *)(a1 + 184) = 0;
  }
  uint64_t v13 = *(void **)(a1 + 192);
  if (v13)
  {
    sub_10003FA78(v13);
    *(void *)(a1 + 192) = 0;
  }
  CCCryptorStatus v14 = *(void **)(a1 + 200);
  if (v14)
  {
    sub_10003FA78(v14);
    *(void *)(a1 + 200) = 0;
  }
  int v15 = *(void **)(a1 + 208);
  if (v15)
  {
    sub_10003FA78(v15);
    *(void *)(a1 + 208) = 0;
  }
  uint64_t v16 = *(void **)(a1 + 216);
  if (v16)
  {
    sub_10003FA78(v16);
    *(void *)(a1 + 216) = 0;
  }
  int v17 = *(void **)(a1 + 224);
  if (v17)
  {
    sub_10003FA78(v17);
    *(void *)(a1 + 224) = 0;
  }
  CFRange v18 = *(void **)(a1 + 232);
  if (v18)
  {
    sub_10003FA78(v18);
    *(void *)(a1 + 232) = 0;
  }
  int v19 = *(void **)(a1 + 240);
  if (v19)
  {
    sub_10002DA30(v19);
    *(void *)(a1 + 240) = 0;
  }
}

void sub_10000843C(uint64_t a1)
{
  sub_1000082F0(a1);
  if (*(void *)a1)
  {
    free(*(void **)a1);
    *(void *)a1 = 0;
  }
  uint64_t v2 = *(void **)(a1 + 8);
  if (v2)
  {
    free(v2);
    *(void *)(a1 + 8) = 0;
  }
  uint64_t v3 = *(void **)(a1 + 32);
  if (v3)
  {
    free(v3);
    *(void *)(a1 + 32) = 0;
  }
  uint64_t v4 = *(void **)(a1 + 40);
  if (v4)
  {
    free(v4);
    *(void *)(a1 + 40) = 0;
  }
  uint64_t v5 = *(uint64_t **)(a1 + 120);
  if (v5)
  {
    sub_100036420(v5);
    *(void *)(a1 + 120) = 0;
  }
  uint64_t v6 = *(void **)(a1 + 112);
  if (v6)
  {
    sub_10003A7B8(v6);
    *(void *)(a1 + 112) = 0;
  }
  uint64_t v7 = *(void **)(a1 + 192);
  if (v7)
  {
    sub_10003FA78(v7);
    *(void *)(a1 + 192) = 0;
  }
  uint64_t v8 = *(void **)(a1 + 200);
  if (v8)
  {
    sub_10003FA78(v8);
    *(void *)(a1 + 200) = 0;
  }
  uint64_t v9 = *(void **)(a1 + 280);
  if (v9)
  {
    sub_10003FA78(v9);
    *(void *)(a1 + 280) = 0;
  }
  int v10 = *(void **)(a1 + 288);
  if (v10)
  {
    sub_10003FA78(v10);
    *(void *)(a1 + 288) = 0;
  }
  uint64_t v11 = *(unsigned int *)(a1 + 64);
  if (v11)
  {
    sub_10003AC14(v11);
    *(_DWORD *)(a1 + 64) = 0;
  }
  uint64_t v12 = *(unsigned int *)(a1 + 68);
  if (v12) {
    sub_10003AC14(v12);
  }

  free((void *)a1);
}

void sub_100008530(uint64_t a1, int a2)
{
  uint64_t v2 = *(void *)(a1 + 1704);
  while (v2)
  {
    uint64_t v4 = v2;
    uint64_t v2 = *(void *)(v2 + 296);
    if ((*(unsigned char *)(v4 + 264) & 2) != 0) {
      continue;
    }
    int v5 = *(_DWORD *)(v4 + 56);
    if ((v5 & 0x4000) != 0) {
      continue;
    }
    if (a2)
    {
      uint64_t v6 = *(void *)(v4 + 272);
      if (v6 && (*(_WORD *)(v6 + 264) & 0x20) == 0 && (*(unsigned char *)(v6 + 280) & 4) != 0)
      {
        if (!dword_10008FA20) {
          continue;
        }
        CCCryptorStatus v14 = ne_log_obj();
        if (!os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT)) {
          continue;
        }
        *(_WORD *)buf = 0;
        uint64_t v9 = v14;
        int v10 = "skipping phase2 handle that's asserted...\n";
LABEL_26:
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, v10, buf, 2u);
        continue;
      }
      int v7 = dword_10008FA20;
      if ((v5 & 0x2000) != 0)
      {
        if (!dword_10008FA20) {
          continue;
        }
        uint64_t v8 = ne_log_obj();
        if (!os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT)) {
          continue;
        }
        *(_WORD *)buf = 0;
        uint64_t v9 = v8;
        int v10 = "skipping ph2 handler that's established...\n";
        goto LABEL_26;
      }
    }
    else
    {
      int v7 = dword_10008FA20;
      if ((v5 & 0x2000) != 0)
      {
        if (dword_10008FA20)
        {
          uint64_t v13 = ne_log_obj();
          if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)buf = 0;
            _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "got an established ph2 handler to flush...\n", buf, 2u);
          }
        }
        sub_10001A600(v4);
        goto LABEL_20;
      }
    }
    if (v7)
    {
      uint64_t v11 = ne_log_obj();
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
      {
        int v12 = *(_DWORD *)(v4 + 56);
        *(_DWORD *)buf = 67109120;
        int v16 = v12;
        _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "got a ph2 handler to flush (state %d)\n", buf, 8u);
      }
    }
LABEL_20:
    sub_10004D8F4(*(void *)(v4 + 272), (uint64_t)off_10008C500[0]);
    sub_100026AB8(v4);
    sub_10004B62C((void *)v4);
  }
}

uint64_t sub_100008750(int a1)
{
  if (dword_10008FA20)
  {
    uint64_t v2 = ne_log_obj();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      v5[0] = 67109120;
      v5[1] = a1;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "flushing ph2 handles: ignore_estab_or_assert %d...\n", (uint8_t *)v5, 8u);
    }
  }
  uint64_t result = qword_1000906D0;
  if (qword_1000906D0)
  {
    do
    {
      uint64_t v4 = *(void *)(result + 1712);
      sub_100008530(result, a1);
      uint64_t result = v4;
    }
    while (v4);
  }
  return result;
}

uint64_t sub_100008820(uint64_t result, unint64_t a2, int a3)
{
  uint64_t v3 = qword_1000906D0;
  if (qword_1000906D0)
  {
    unint64_t v6 = result;
    do
    {
      uint64_t v7 = *(void *)(v3 + 1704);
      uint64_t v3 = *(void *)(v3 + 1712);
LABEL_4:
      while (v7)
      {
        uint64_t v8 = v7;
        uint64_t v7 = *(void *)(v7 + 296);
        if ((*(unsigned char *)(v8 + 264) & 2) == 0
          && (*(unsigned char *)(v8 + 57) & 0x40) == 0
          && (*(void *)(v8 + 120) || *(void *)(v8 + 128)))
        {
          uint64_t result = sub_10003B8E4(v6, *(void *)v8);
          if (!result)
          {
            uint64_t result = sub_10003B8E4(a2, *(void *)(v8 + 8));
            if (!result)
            {
              uint64_t v9 = *(void *)(v8 + 128);
              if (v9)
              {
                uint64_t v10 = *(void *)(v9 + 32);
                if (v10)
                {
                  while (*(_DWORD *)v10 != a3)
                  {
                    uint64_t v10 = *(void *)(v10 + 72);
                    if (!v10) {
                      goto LABEL_4;
                    }
                  }
                  goto LABEL_21;
                }
              }
              else
              {
                uint64_t v11 = *(void *)(v8 + 120);
                if (v11)
                {
                  uint64_t v12 = *(void *)(v11 + 32);
                  if (v12)
                  {
                    while (*(_DWORD *)v12 != a3)
                    {
                      uint64_t v12 = *(void *)(v12 + 72);
                      if (!v12) {
                        goto LABEL_4;
                      }
                    }
LABEL_21:
                    if (dword_10008FA20)
                    {
                      uint64_t v13 = ne_log_obj();
                      if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
                      {
                        *(_WORD *)CCCryptorStatus v14 = 0;
                        _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "deleteallph2: got a ph2 handler...\n", v14, 2u);
                      }
                    }
                    if ((*(unsigned char *)(v8 + 57) & 0x20) != 0) {
                      sub_10001A600(v8);
                    }
                    sub_10004D8F4(*(void *)(v8 + 272), (uint64_t)off_10008C500[0]);
                    uint64_t result = sub_10004B62C((void *)v8);
                  }
                }
              }
            }
          }
        }
      }
    }
    while (v3);
  }
  return result;
}

uint64_t sub_1000089A8(uint64_t result, unint64_t a2)
{
  uint64_t v2 = qword_1000906D0;
  if (qword_1000906D0)
  {
    unint64_t v4 = result;
    do
    {
      uint64_t v5 = *(void *)(v2 + 1696);
      uint64_t v2 = *(void *)(v2 + 1712);
      while (v5)
      {
        uint64_t v6 = v5;
        uint64_t v5 = *(void *)(v5 + 456);
        uint64_t result = sub_10003B8E4(v4, *(void *)(v6 + 56));
        if (!result)
        {
          uint64_t result = sub_10003B8E4(a2, *(void *)(v6 + 48));
          if (!result)
          {
            if (dword_10008FA20)
            {
              uint64_t v7 = ne_log_obj();
              if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
              {
                *(_WORD *)uint64_t v8 = 0;
                _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "deleteallph1: got a ph1 handler...\n", v8, 2u);
              }
            }
            if ((*(unsigned char *)(v6 + 17) & 0x20) != 0) {
              sub_10001A098(v6);
            }
            sub_10004D8F4(*(void *)(v6 + 440), (uint64_t)off_10008C500[0]);
            uint64_t result = sub_10004B710(v6);
          }
        }
      }
    }
    while (v2);
  }
  return result;
}

unint64_t *sub_100008AC0(unint64_t a1)
{
  uint64_t v1 = (unint64_t *)qword_10008C538;
  if (qword_10008C538)
  {
    do
    {
      if (!sub_10003BB04(a1, *v1)) {
        break;
      }
      uint64_t v1 = (unint64_t *)v1[1];
    }
    while (v1);
  }
  return v1;
}

uint64_t sub_100008B08()
{
  int v0 = malloc_type_calloc(1uLL, 0x18uLL, 0xA0040E93CF5C4uLL);
  if (!v0) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v1 = v0;
  uint64_t v2 = sub_10003CC74();
  *uint64_t v1 = v2;
  if (!v2)
  {
    if (dword_10008FA20)
    {
      uint64_t v5 = ne_log_obj();
      if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR)) {
        sub_100057CE8();
      }
    }
    free(v1);
    return 0xFFFFFFFFLL;
  }
  uint64_t v3 = qword_10008C538;
  v1[1] = qword_10008C538;
  if (v3) {
    *(void *)(v3 + 16) = v1 + 1;
  }
  uint64_t result = 0;
  qword_10008C538 = (uint64_t)v1;
  v1[2] = &qword_10008C538;
  return result;
}

void sub_100008BC8()
{
  uint64_t v0 = qword_10008C538;
  if (qword_10008C538)
  {
    uint64_t v1 = *(void *)(qword_10008C538 + 8);
    uint64_t v2 = *(void **)(qword_10008C538 + 16);
    if (v1)
    {
      do
      {
        uint64_t v3 = v1;
        *(void *)(v1 + 16) = v2;
        **(void **)(v0 + 16) = v1;
        free(*(void **)v0);
        free((void *)v0);
        uint64_t v1 = *(void *)(v3 + 8);
        uint64_t v2 = *(void **)(v3 + 16);
        uint64_t v0 = v3;
      }
      while (v1);
    }
    else
    {
      uint64_t v3 = qword_10008C538;
    }
    *uint64_t v2 = 0;
    free(*(void **)v3);
    free((void *)v3);
  }
}

void sub_100008C58()
{
  qword_10008C538 = 0;
}

uint64_t sub_100008C64(int a1, int a2)
{
  if (a1 < 4) {
    int v2 = 1;
  }
  else {
    int v2 = a1;
  }
  return v2 * a2;
}

uint64_t sub_100008C78(const sockaddr *a1, uint64_t a2, uint64_t a3)
{
  time_t v5 = time(0);
  uint64_t v6 = sub_100005FB0(a3);
  if (!v6)
  {
    if (dword_10008FA20)
    {
      uint64_t v11 = ne_log_obj();
      if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR)) {
        sub_100057CE8();
      }
    }
    return 0xFFFFFFFFLL;
  }
  uint64_t v7 = v6;
  uint64_t v8 = qword_10008C540;
  if (!qword_10008C540)
  {
LABEL_6:
    sub_10003FA78(v7);
    return 0;
  }
  uint64_t v9 = (const void *)v6[1];
  while (memcmp(v9, *(const void **)(*(void *)(v8 + 16) + 8), **(void **)(v8 + 16)))
  {
    uint64_t v8 = *(void *)(v8 + 72);
    if (!v8) {
      goto LABEL_6;
    }
  }
  sub_10003FA78(v7);
  if (sub_10003B8E4((unint64_t)a1, *(void *)v8)) {
    return 2;
  }
  if (v5 <= *(void *)(v8 + 40))
  {
    if (dword_10008FA20)
    {
      uint64_t v12 = ne_log_obj();
      if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
      {
        int v28 = 136315138;
        size_t v29 = sub_10003CAE4(a1);
        _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "the packet retransmitted in a short time from %s\n", (uint8_t *)&v28, 0xCu);
      }
    }
  }
  uint64_t result = sub_100006E58(*(unsigned __int8 **)(v8 + 8));
  if (result != -1)
  {
    uint64_t v13 = result;
    uint64_t v14 = *(void *)(v8 + 40);
    if (v14)
    {
      uint64_t v15 = v5 - v14;
      if (v5 > v14 && v15 < *(void *)(v8 + 56))
      {
        if (dword_10008FA20)
        {
          int v16 = ne_log_obj();
          if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR)) {
            sub_100057D1C(v15, v16);
          }
        }
        return 1;
      }
    }
    if (*(_DWORD *)(v8 + 64) && **(void **)(v8 + 24) >= 0x501uLL)
    {
      if (dword_10008FA20)
      {
        int v17 = ne_log_obj();
        if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR)) {
          sub_100057E6C();
        }
      }
      int v18 = sub_1000151F8(v13, *(unint64_t **)(v8 + 24), *(unsigned __int8 **)(v8 + 8), *(unsigned __int8 **)v8, *(unsigned int *)(qword_10008F848 + 276), *(_DWORD *)(v8 + 64));
    }
    else
    {
      if (dword_10008FA20)
      {
        int v19 = ne_log_obj();
        if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR)) {
          sub_100057DC8((int *)(v8 + 64), v8, v19);
        }
      }
      int v18 = sub_10003C350(v13, *(const void **)(*(void *)(v8 + 24) + 8), **(void **)(v8 + 24), *(unsigned __int8 **)(v8 + 8), *(unsigned __int8 **)v8, *(_DWORD *)(qword_10008F848 + 276));
    }
    if (v18 != -1)
    {
      int v20 = *(_DWORD *)(v8 + 32);
      BOOL v21 = __OFSUB__(v20, 1);
      int v22 = v20 - 1;
      *(_DWORD *)(v8 + 32) = v22;
      if ((v22 < 0) ^ v21 | (v22 == 0))
      {
        uint64_t v23 = *(void *)(v8 + 72);
        if (v23) {
          *(void *)(v23 + 80) = *(void *)(v8 + 80);
        }
        **(void **)(v8 + 80) = v23;
        sub_10000900C((void **)v8);
        if (dword_10008FA20)
        {
          __int16 v24 = ne_log_obj();
          if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
          {
            CCAlgorithm v25 = sub_10003CAE4(a1);
            int v28 = 136315138;
            size_t v29 = v25;
            _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "deleted the retransmission packet to %s.\n", (uint8_t *)&v28, 0xCu);
          }
        }
      }
      else
      {
        *(void *)(v8 + 40) = v5;
        int v27 = *(_DWORD *)(qword_10008F848 + 268) - v22;
        if (v27 < 4) {
          int v27 = 1;
        }
        *(void *)(v8 + 56) = *(int *)(qword_10008F848 + 272) * (uint64_t)v27;
      }
      return 1;
    }
    if (dword_10008FA20)
    {
      __int16 v26 = ne_log_obj();
      if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR)) {
        sub_100057D94();
      }
    }
    return 0xFFFFFFFFLL;
  }
  return result;
}

void sub_10000900C(void **a1)
{
  int v2 = *a1;
  if (v2) {
    free(v2);
  }
  uint64_t v3 = a1[1];
  if (v3) {
    free(v3);
  }
  unint64_t v4 = a1[2];
  if (v4) {
    sub_10003FA78(v4);
  }
  time_t v5 = a1[3];
  if (v5) {
    sub_10003FA78(v5);
  }

  free(a1);
}

uint64_t sub_100009070(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6)
{
  if (!*(_DWORD *)(qword_10008F848 + 268)) {
    return 0;
  }
  uint64_t v10 = malloc_type_calloc(1uLL, 0x58uLL, 0x10A0040B33E3A73uLL);
  if (!v10)
  {
    if (dword_10008FA20)
    {
      int v19 = ne_log_obj();
      if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR)) {
        sub_100057CE8();
      }
    }
    return 0xFFFFFFFFLL;
  }
  uint64_t v11 = (uint64_t)v10;
  uint64_t v12 = sub_100005FB0(a4);
  *(void *)(v11 + 16) = v12;
  if (!v12)
  {
    if (!dword_10008FA20) {
      goto LABEL_39;
    }
    int v20 = ne_log_obj();
    if (!os_log_type_enabled(v20, OS_LOG_TYPE_ERROR)) {
      goto LABEL_39;
    }
    goto LABEL_38;
  }
  uint64_t v13 = sub_10003CC74();
  *(void *)uint64_t v11 = v13;
  if (!v13)
  {
    if (!dword_10008FA20) {
      goto LABEL_39;
    }
    BOOL v21 = ne_log_obj();
    if (!os_log_type_enabled(v21, OS_LOG_TYPE_ERROR)) {
      goto LABEL_39;
    }
    goto LABEL_38;
  }
  uint64_t v14 = sub_10003CC74();
  *(void *)(v11 + 8) = v14;
  if (!v14)
  {
    if (!dword_10008FA20) {
      goto LABEL_39;
    }
    int v22 = ne_log_obj();
    if (!os_log_type_enabled(v22, OS_LOG_TYPE_ERROR)) {
      goto LABEL_39;
    }
    goto LABEL_38;
  }
  if (!a5)
  {
    uint64_t v23 = sub_10003FAC0(a3);
    *(void *)(v11 + 24) = v23;
    if (v23) {
      goto LABEL_26;
    }
    if (!dword_10008FA20) {
      goto LABEL_39;
    }
    int v30 = ne_log_obj();
    if (!os_log_type_enabled(v30, OS_LOG_TYPE_ERROR)) {
      goto LABEL_39;
    }
LABEL_38:
    sub_100057CE8();
LABEL_39:
    sub_10000900C((void **)v11);
    return 0xFFFFFFFFLL;
  }
  if (dword_10008FA20)
  {
    uint64_t v15 = ne_log_obj();
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEBUG)) {
      sub_100057ED4();
    }
  }
  int v16 = sub_10003F940(*(void *)a3 + a5);
  *(void *)(v11 + 24) = v16;
  if (!v16)
  {
    if (dword_10008FA20)
    {
      size_t v29 = ne_log_obj();
      if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR)) {
        sub_100057EA0();
      }
    }
    goto LABEL_39;
  }
  int v17 = (_DWORD *)v16[1];
  *int v17 = 0;
  memcpy((char *)v17 + a5, *(const void **)(a3 + 8), *(void *)a3);
LABEL_26:
  *(_DWORD *)(v11 + 32) = *(_DWORD *)(qword_10008F848 + 268);
  *(void *)(v11 + 40) = 0;
  *(void *)(v11 + 48) = time(0);
  if (a6) {
    *(_DWORD *)(v11 + 64) = a6;
  }
  uint64_t v24 = qword_10008F848;
  int v25 = *(_DWORD *)(qword_10008F848 + 268);
  uint64_t v26 = qword_10008C540;
  *(void *)(v11 + 72) = qword_10008C540;
  int v27 = v25 - *(_DWORD *)(v11 + 32);
  int v28 = *(_DWORD *)(v24 + 272);
  if (v27 < 4) {
    int v27 = 1;
  }
  *(void *)(v11 + 56) = v28 * (uint64_t)v27;
  if (v26) {
    *(void *)(v26 + 80) = v11 + 72;
  }
  uint64_t result = 0;
  qword_10008C540 = v11;
  *(void *)(v11 + 80) = &qword_10008C540;
  return result;
}

uint64_t sub_100009338()
{
  uint64_t v0 = qword_10008C540;
  if (qword_10008C540)
  {
    uint64_t v1 = *(void *)(qword_10008C540 + 72);
    if (v1)
    {
      do
      {
        uint64_t v2 = v1;
        *(void *)(v1 + 80) = *(void *)(v0 + 80);
        **(void **)(v0 + 80) = v1;
        sub_10000900C((void **)v0);
        uint64_t v1 = *(void *)(v2 + 72);
        uint64_t v0 = v2;
      }
      while (v1);
    }
    else
    {
      uint64_t v2 = qword_10008C540;
    }
    **(void **)(v2 + 80) = 0;
    sub_10000900C((void **)v2);
  }

  return sub_10003AC68((uint64_t)&qword_10008C540);
}

void *sub_1000093BC()
{
  uint64_t v0 = *(int *)(qword_10008F848 + 272) * (uint64_t)*(int *)(qword_10008F848 + 268);
  qword_10008C540 = 0;
  return sub_10003AA24(v0, (uint64_t)sub_1000093F4, (uint64_t)&qword_10008C540);
}

void *sub_1000093F4()
{
  time_t v0 = time(0);
  uint64_t v1 = *(int *)(qword_10008F848 + 272) * (uint64_t)*(int *)(qword_10008F848 + 268);
  uint64_t v2 = qword_10008C540;
  if (qword_10008C540)
  {
    do
    {
      uint64_t v3 = *(void *)(v2 + 72);
      if (v0 - *(void *)(v2 + 48) > v1)
      {
        if (v3) {
          *(void *)(v3 + 80) = *(void *)(v2 + 80);
        }
        **(void **)(v2 + 80) = v3;
        sub_10000900C((void **)v2);
      }
      uint64_t v2 = v3;
    }
    while (v3);
  }

  return sub_10003AA24(v1, (uint64_t)sub_1000093F4, (uint64_t)&qword_10008C540);
}

uint64_t sub_1000094A8(uint64_t a1)
{
  if (!a1) {
    return 0;
  }
  uint64_t v2 = *(void *)(a1 + 1704);
  if (v2)
  {
    uint64_t v3 = 0;
    do
    {
      if ((*(unsigned char *)(v2 + 264) & 2) == 0 && (*(unsigned char *)(v2 + 57) & 0x40) == 0)
      {
        sub_100024ED0((void *)v2);
        uint64_t v3 = (v3 + 1);
      }
      uint64_t v2 = *(void *)(v2 + 296);
    }
    while (v2);
  }
  else
  {
    uint64_t v3 = 0;
  }
  uint64_t v4 = *(void *)(a1 + 1696);
  while (v4)
  {
    uint64_t v5 = v4;
    uint64_t v4 = *(void *)(v4 + 456);
    if ((*(unsigned char *)(v5 + 432) & 2) == 0 && (*(unsigned char *)(v5 + 17) & 0x40) == 0)
    {
      sub_10004DB98(v5);
      if ((*(unsigned char *)(v5 + 17) & 0x20) != 0) {
        sub_10001A098(v5);
      }
      sub_100022854(v5);
      uint64_t v3 = (v3 + 1);
    }
  }
  return v3;
}

uint64_t sub_100009560(unint64_t a1)
{
  uint64_t v1 = qword_1000906D0;
  if (!qword_1000906D0) {
    return 0;
  }
  uint64_t v3 = 0;
  do
  {
    uint64_t v4 = v1;
    uint64_t v1 = *(void *)(v1 + 1712);
    for (uint64_t i = *(void *)(v4 + 1704); i; uint64_t i = *(void *)(i + 296))
    {
      if ((*(unsigned char *)(i + 264) & 2) == 0
        && (*(unsigned char *)(i + 57) & 0x40) == 0
        && !sub_10003B8E4(a1, *(void *)(i + 8)))
      {
        if (dword_10008FA20)
        {
          uint64_t v6 = ne_log_obj();
          if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 136315138;
            uint64_t v11 = "ike_session_purgephXbydstaddrwop";
            _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "in %s... purging Phase 2 structures\n", buf, 0xCu);
          }
        }
        if ((*(unsigned char *)(i + 57) & 0x20) != 0) {
          sub_10001A600(i);
        }
        sub_100024ED0((void *)i);
        uint64_t v3 = (v3 + 1);
      }
    }
    for (uint64_t j = *(void *)(v4 + 1696); j; uint64_t j = *(void *)(j + 456))
    {
      if ((*(unsigned char *)(j + 432) & 2) == 0
        && (*(unsigned char *)(j + 17) & 0x40) == 0
        && !sub_10003B8E4(a1, *(void *)(j + 48)))
      {
        if (dword_10008FA20)
        {
          uint64_t v8 = ne_log_obj();
          if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 136315138;
            uint64_t v11 = "ike_session_purgephXbydstaddrwop";
            _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "in %s... purging Phase 1 and related Phase 2 structures\n", buf, 0xCu);
          }
        }
        sub_10004DB98(j);
        if ((*(unsigned char *)(j + 17) & 0x20) != 0) {
          sub_10001A098(j);
        }
        sub_100022854(j);
        uint64_t v3 = (v3 + 1);
      }
    }
  }
  while (v1);
  return v3;
}

void *sub_100009758(void *result, int a2)
{
  uint64_t v2 = qword_1000906D0;
  if (qword_1000906D0)
  {
    int v4 = (int)result;
    do
    {
      uint64_t v5 = v2;
      uint64_t v2 = *(void *)(v2 + 1712);
      uint64_t v6 = *(void *)(v5 + 1704);
      if (v6)
      {
        do
        {
          uint64_t v7 = v6;
          uint64_t v6 = *(void *)(v6 + 296);
          if (*(_DWORD *)(v7 + 52) == v4 && (*(unsigned char *)(v7 + 264) & 2) == 0)
          {
            int v8 = *(_DWORD *)(v7 + 56);
            if ((v8 & 0x4000) == 0)
            {
              if ((v8 & 0x2000) != 0) {
                sub_10001A600(v7);
              }
              sub_10004D8F4(*(void *)(v7 + 272), (uint64_t)off_10008C500[0]);
              uint64_t result = sub_100024ED0((void *)v7);
            }
          }
        }
        while (v6);
        uint64_t v9 = *(void *)(v5 + 1704);
        while (v9)
        {
          uint64_t v10 = v9;
          uint64_t v9 = *(void *)(v9 + 296);
          if (a2)
          {
            if (*(_DWORD *)(v10 + 52) == v4)
            {
              uint64_t v11 = *(void *)(v10 + 272);
              if (v11)
              {
                uint64_t v12 = *(void *)(v11 + 1696);
                while (v12)
                {
                  uint64_t v13 = v12;
                  uint64_t v12 = *(void *)(v12 + 456);
                  if ((*(unsigned char *)(v13 + 432) & 2) == 0)
                  {
                    int v14 = *(_DWORD *)(v13 + 16);
                    if ((v14 & 0x4000) == 0)
                    {
                      if ((v14 & 0x2000) != 0) {
                        sub_10001A098(v13);
                      }
                      uint64_t result = sub_100022854(v13);
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    while (v2);
  }
  return result;
}

uint64_t sub_10000986C(unint64_t a1)
{
  uint64_t v1 = qword_1000906D0;
  if (!qword_1000906D0) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v3 = 0xFFFFFFFFLL;
  do
  {
    for (uint64_t i = *(void *)(v1 + 1696); i; uint64_t i = *(void *)(i + 456))
    {
      if (!sub_10003B8E4(a1, *(void *)(i + 48)))
      {
        if ((*(unsigned char *)(i + 17) & 0x20) != 0
          && (*(unsigned char *)(i + 432) & 2) == 0
          && *(_DWORD *)(i + 368)
          && *(_DWORD *)(*(void *)(i + 64) + 216))
        {
          if (*(unsigned char *)(i + 386))
          {
            if (dword_10008FA20)
            {
              uint64_t v5 = ne_log_obj();
              if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
              {
                LOWORD(v13[0]) = 0;
                _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "Skipping forced-DPD for Phase 1 (dpd already in progress).\n", (uint8_t *)v13, 2u);
              }
            }
          }
          else
          {
            sub_10001BCA8(i);
            uint64_t v3 = 0;
          }
          uint64_t v11 = *(void *)(i + 440);
          if (v11) {
            *(unsigned char *)(v11 + 280) |= 1u;
          }
        }
        else if (dword_10008FA20)
        {
          uint64_t v6 = ne_log_obj();
          if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
          {
            int v7 = *(_DWORD *)(i + 16);
            int v8 = *(unsigned __int8 *)(i + 432) << 30 >> 31;
            int v9 = *(_DWORD *)(i + 368);
            int v10 = *(_DWORD *)(*(void *)(i + 64) + 216);
            v13[0] = 67109888;
            v13[1] = v7;
            __int16 v14 = 1024;
            int v15 = v8;
            __int16 v16 = 1024;
            int v17 = v9;
            __int16 v18 = 1024;
            int v19 = v10;
            _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "Skipping forced-DPD for Phase 1 (status %d, dying %d, dpd-support %d, dpd-interval %d).\n", (uint8_t *)v13, 0x1Au);
          }
        }
      }
    }
    uint64_t v1 = *(void *)(v1 + 1712);
  }
  while (v1);
  return v3;
}

void sub_100009A5C()
{
  uint64_t v0 = qword_1000906D0;
  while (v0)
  {
    uint64_t v1 = v0;
    uint64_t v0 = *(void *)(v0 + 1712);
    uint64_t v2 = *(void *)(v1 + 1696);
    if (v2)
    {
      while (1)
      {
        uint64_t v3 = v2;
        uint64_t v2 = *(void *)(v2 + 456);
        uint64_t v4 = *(void *)(v3 + 440);
        if (v4)
        {
          if ((*(unsigned char *)(v4 + 280) & 4) != 0) {
            break;
          }
        }
        if ((*(unsigned char *)(v3 + 432) & 2) == 0 && (*(unsigned char *)(v3 + 17) & 0x40) == 0)
        {
          int v5 = *(_DWORD *)(v3 + 112);
          if (v5)
          {
            *(void *)int v33 = 0;
            if (sub_10003ABC4(v5, v33))
            {
              if (*(uint64_t *)v33 <= qword_1000906F0)
              {
                uint64_t v6 = *(unsigned int *)(v3 + 112);
                if (v6)
                {
                  sub_10003AC14(v6);
                  *(_DWORD *)(v3 + 112) = 0;
                }
                uint64_t v7 = *(unsigned int *)(v3 + 116);
                if (v7)
                {
                  sub_10003AC14(v7);
                  *(_DWORD *)(v3 + 116) = 0;
                }
                *(unsigned char *)(v3 + 432) |= 2u;
                sub_100002728((int *)(v3 + 16), 17408);
                sub_10004C2B0(v3);
                *(_DWORD *)(v3 + 112) = sub_10003AA24(1, (uint64_t)sub_1000248EC, v3);
                if (dword_10008FA20)
                {
                  int v8 = ne_log_obj();
                  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
                  {
                    int v9 = sub_100023BEC(v3, 0);
                    *(_DWORD *)buf = 136315138;
                    *(void *)&uint8_t buf[4] = v9;
                    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "Phase 1 %s expired while sleeping: quick deletion.\n", buf, 0xCu);
                  }
                }
              }
            }
          }
          int v10 = *(_DWORD *)(v3 + 116);
          if (v10)
          {
            *(void *)buf = 0;
            if (sub_10003ABC4(v10, buf))
            {
              if ((*(unsigned char *)(v3 + 17) & 0x40) != 0 || *(uint64_t *)buf <= qword_1000906F0)
              {
                uint64_t v11 = *(unsigned int *)(v3 + 116);
                if (v11)
                {
                  sub_10003AC14(v11);
                  *(_DWORD *)(v3 + 116) = 0;
                }
              }
            }
          }
          int v12 = *(_DWORD *)(v3 + 120);
          if (v12)
          {
            *(void *)buf = 0;
            if (sub_10003ABC4(v12, buf))
            {
              if ((*(unsigned char *)(v3 + 17) & 0x40) != 0 || *(uint64_t *)buf <= qword_1000906F0)
              {
                uint64_t v13 = *(unsigned int *)(v3 + 120);
                if (v13)
                {
                  sub_10003AC14(v13);
                  *(_DWORD *)(v3 + 120) = 0;
                }
              }
            }
          }
          int v14 = *(_DWORD *)(v3 + 388);
          if (v14)
          {
            *(void *)buf = 0;
            if (sub_10003ABC4(v14, buf))
            {
              if ((*(unsigned char *)(v3 + 17) & 0x40) != 0 || *(uint64_t *)buf <= qword_1000906F0)
              {
                uint64_t v15 = *(unsigned int *)(v3 + 388);
                if (v15)
                {
                  sub_10003AC14(v15);
                  *(_DWORD *)(v3 + 388) = 0;
                }
              }
            }
          }
          goto LABEL_42;
        }
        if (dword_10008FA20)
        {
          __int16 v16 = ne_log_obj();
          if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
          {
            int v17 = sub_100023BEC(v3, 0);
            *(_DWORD *)buf = 136315138;
            *(void *)&uint8_t buf[4] = v17;
            __int16 v18 = v16;
            int v19 = "Skipping sweep of Phase 1 %s because it's already expired.\n";
LABEL_41:
            _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, v19, buf, 0xCu);
          }
        }
LABEL_42:
        if (!v2) {
          goto LABEL_43;
        }
      }
      if (!dword_10008FA20) {
        goto LABEL_42;
      }
      int v20 = ne_log_obj();
      if (!os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_42;
      }
      BOOL v21 = sub_100023BEC(v3, 0);
      *(_DWORD *)buf = 136315138;
      *(void *)&uint8_t buf[4] = v21;
      __int16 v18 = v20;
      int v19 = "Skipping sweep of Phase 1 %s because it's been asserted.\n";
      goto LABEL_41;
    }
LABEL_43:
    uint64_t v22 = *(void *)(v1 + 1704);
    while (v22)
    {
      uint64_t v23 = v22;
      uint64_t v22 = *(void *)(v22 + 296);
      uint64_t v24 = *(void *)(v23 + 272);
      if (v24 && (*(unsigned char *)(v24 + 280) & 4) != 0)
      {
        if (dword_10008FA20)
        {
          v32 = ne_log_obj();
          if (os_log_type_enabled(v32, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)buf = 0;
            int v30 = v32;
            int v31 = "Skipping sweep of Phase 2 because it's been asserted.\n";
LABEL_67:
            _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_DEFAULT, v31, buf, 2u);
          }
        }
      }
      else if ((*(unsigned char *)(v23 + 264) & 2) != 0 || (*(unsigned char *)(v23 + 57) & 0x40) != 0)
      {
        if (dword_10008FA20)
        {
          size_t v29 = ne_log_obj();
          if (os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)buf = 0;
            int v30 = v29;
            int v31 = "Skipping sweep of Phase 2 because it's already expired.\n";
            goto LABEL_67;
          }
        }
      }
      else
      {
        int v25 = *(_DWORD *)(v23 + 64);
        if (v25)
        {
          *(void *)buf = 0;
          if (sub_10003ABC4(v25, buf))
          {
            if (*(uint64_t *)buf <= qword_1000906F0)
            {
              sub_100002728((int *)(v23 + 56), 18432);
              *(unsigned char *)(v23 + 264) |= 2u;
              sub_100024ED0((void *)v23);
              sub_10004D8F4(*(void *)(v23 + 272), (uint64_t)off_10008C518[0]);
              if (dword_10008FA20)
              {
                uint64_t v26 = ne_log_obj();
                if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
                {
                  *(_WORD *)int v33 = 0;
                  _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "Phase 2 expired while sleeping: quick deletion.\n", v33, 2u);
                }
              }
            }
          }
        }
        int v27 = *(_DWORD *)(v23 + 68);
        if (v27)
        {
          *(void *)buf = 0;
          if (sub_10003ABC4(v27, buf))
          {
            if ((*(unsigned char *)(v23 + 57) & 0x40) != 0 || *(uint64_t *)buf <= qword_1000906F0)
            {
              uint64_t v28 = *(unsigned int *)(v23 + 68);
              if (v28)
              {
                sub_10003AC14(v28);
                *(_DWORD *)(v23 + 68) = 0;
              }
            }
          }
        }
      }
    }
  }
  sub_10004F3E0();
}

uint64_t sub_100009F24(uint64_t a1)
{
  unsigned int v6 = 0;
  uint64_t v1 = *(void *)(a1 + 48);
  int v2 = *(unsigned __int8 *)(v1 + 1);
  if (v2 != 30)
  {
    if (v2 == 2) {
      return *(unsigned int *)(v1 + 4);
    }
    goto LABEL_9;
  }
  if (!*(_DWORD *)(a1 + 28))
  {
LABEL_9:
    if (dword_10008FA20)
    {
      uint64_t v4 = ne_log_obj();
      if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR)) {
        sub_100057F08();
      }
    }
    return v6;
  }
  if ((nw_nat64_extract_v4() & 1) == 0)
  {
    if (dword_10008FA20)
    {
      uint64_t v3 = ne_log_obj();
      if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR)) {
        sub_100057F7C();
      }
    }
  }
  return v6;
}

uint64_t sub_10000A008(uint64_t a1)
{
  unsigned int v6 = 0;
  uint64_t v1 = *(void *)(a1 + 8);
  int v2 = *(unsigned __int8 *)(v1 + 1);
  if (v2 != 30)
  {
    if (v2 == 2) {
      return *(unsigned int *)(v1 + 4);
    }
    goto LABEL_9;
  }
  if (!*(_DWORD *)(a1 + 16))
  {
LABEL_9:
    if (dword_10008FA20)
    {
      uint64_t v4 = ne_log_obj();
      if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR)) {
        sub_100057FB0();
      }
    }
    return v6;
  }
  if ((nw_nat64_extract_v4() & 1) == 0)
  {
    if (dword_10008FA20)
    {
      uint64_t v3 = ne_log_obj();
      if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR)) {
        sub_100058024();
      }
    }
  }
  return v6;
}

void sub_10000A104(void *a1, uint64_t a2, uint64_t a3, const char *a4)
{
  _os_log_debug_impl(a1, v4, OS_LOG_TYPE_DEBUG, a4, v5, 0xCu);
}

void sub_10000A124(void *a1, uint64_t a2, os_log_t log, const char *a4, ...)
{
  va_start(va, a4);
  _os_log_error_impl(a1, log, OS_LOG_TYPE_ERROR, a4, (uint8_t *)va, 0xEu);
}

uint64_t sub_10000A144(unint64_t *a1, void *a2)
{
  uint64_t v3 = sub_10000A3A8(a1, 0);
  if (!v3) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v4 = v3;
  uint64_t v6 = (void **)(a2 + 9);
  int v5 = (void *)a2[9];
  if (v5)
  {
    sub_100038EB0(v5);
    *uint64_t v6 = 0;
  }
  uint64_t v7 = 0;
  memset(v25, 0, sizeof(v25));
  while (1)
  {
    int v8 = (uint64_t *)v4[v7];
    if (v8) {
      break;
    }
LABEL_10:
    if (++v7 == 256)
    {
      if (dword_10008C280)
      {
        for (uint64_t i = 0; i != 256; ++i)
        {
          for (uint64_t j = (uint64_t *)v4[i]; j; uint64_t j = (uint64_t *)j[2])
          {
            uint64_t v13 = j;
            do
            {
              sub_10000BC1C(v13, *(void *)(a2[8] + 248));
              uint64_t v13 = (uint64_t *)v13[3];
            }
            while (v13);
          }
        }
      }
      if (dword_10008FA20)
      {
        int v14 = ne_log_obj();
        if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR)) {
          sub_100058058();
        }
      }
      goto LABEL_39;
    }
  }
LABEL_6:
  int v9 = v8;
  while (1)
  {
    int v10 = sub_10000AC9C(v9, *(void *)(a2[8] + 248), v25, *(_DWORD *)(a2[8] + 172));
    if (v10) {
      break;
    }
    int v9 = (uint64_t *)v9[3];
    if (!v9)
    {
      int v8 = (uint64_t *)v8[2];
      if (v8) {
        goto LABEL_6;
      }
      goto LABEL_10;
    }
  }
  uint64_t v15 = v10;
  if (dword_10008FA20)
  {
    __int16 v16 = ne_log_obj();
    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG)) {
      sub_100058114();
    }
  }
  __int16 v18 = (void **)(v15 + 16);
  uint64_t v17 = *((void *)v15 + 8);
  if (v17)
  {
    if (*(void *)(v17 + 8) && *(_DWORD *)(v17 + 16)) {
      goto LABEL_32;
    }
    if (dword_10008FA20)
    {
      int v19 = ne_log_obj();
      if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)uint64_t v24 = 0;
        _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "invalid DH parameter found, use default.\n", v24, 2u);
      }
    }
    sub_1000294BC(*v18);
    NSObject *v18 = 0;
  }
  if (sub_100029A30(v15[15], (uint64_t)(v15 + 16)) == -1)
  {
    free(v15);
    goto LABEL_39;
  }
LABEL_32:
  *uint64_t v6 = v15;
  if (dword_10008FA20)
  {
    int v20 = ne_log_obj();
    if (os_log_type_enabled(v20, OS_LOG_TYPE_DEBUG)) {
      sub_10005808C((uint64_t)(a2 + 9));
    }
  }
  BOOL v21 = sub_10000C608(v9, (uint64_t)a2);
  if (v21)
  {
    uint64_t v22 = v21;
    sub_10000AC28(v4);
    uint64_t result = 0;
    a2[43] = v22;
    return result;
  }
  sub_100038EB0(*v6);
  *uint64_t v6 = 0;
LABEL_39:
  sub_10000AC28(v4);
  return 0xFFFFFFFFLL;
}

void *sub_10000A3A8(unint64_t *a1, unsigned int a2)
{
  unint64_t v4 = *a1;
  unint64_t v3 = a1[1];
  if (a2 <= 1)
  {
    if (v4 <= 7)
    {
      if (dword_10008FA20)
      {
        int v5 = ne_log_obj();
        if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR)) {
          sub_10005814C();
        }
      }
      return 0;
    }
    if (*(_DWORD *)v3 != 0x1000000)
    {
      if (dword_10008FA20)
      {
        int v9 = ne_log_obj();
        if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR)) {
          sub_10005845C();
        }
      }
      return 0;
    }
    unsigned int v6 = bswap32(*(_DWORD *)(v3 + 4));
    if (v6 != 1)
    {
      if (v6 == 4 || v6 == 2)
      {
        if (dword_10008FA20)
        {
          int v8 = ne_log_obj();
          if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR)) {
            sub_1000583F4();
          }
        }
      }
      else if (dword_10008FA20)
      {
        v62 = ne_log_obj();
        if (os_log_type_enabled(v62, OS_LOG_TYPE_ERROR)) {
          sub_1000581B4();
        }
      }
      return 0;
    }
    v3 += 8;
    LODWORD(v4) = v4 - 8;
  }
  int v10 = malloc_type_calloc(1uLL, 0x800uLL, 0x2004093837F09uLL);
  if (!v10)
  {
    if (dword_10008FA20)
    {
      v42 = ne_log_obj();
      if (os_log_type_enabled(v42, OS_LOG_TYPE_ERROR)) {
        sub_10005821C();
      }
    }
    return 0;
  }
  uint64_t v11 = v10;
  int v12 = sub_100022CA8(2u, (unsigned __int8 *)v3, v4);
  if (!v12)
  {
LABEL_107:
    free(v11);
    return 0;
  }
  int v66 = 0;
  v65 = v12;
  for (uint64_t i = v12[1]; *(unsigned char *)i == 2; i += 4)
  {
    unsigned int v14 = i[1];
    if (v14 <= 7)
    {
      if (dword_10008FA20)
      {
        long long v54 = ne_log_obj();
        if (os_log_type_enabled(v54, OS_LOG_TYPE_ERROR)) {
          sub_1000582EC((uint64_t)(i + 1), v54, v55, v56, v57, v58, v59, v60);
        }
      }
LABEL_106:
      sub_10003FA78(v65);
      goto LABEL_107;
    }
    uint64_t v15 = *((void *)i + 1);
    if (dword_10008FA20)
    {
      __int16 v16 = ne_log_obj();
      if (os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG))
      {
        int v40 = *(unsigned __int8 *)(v15 + 4);
        *(_DWORD *)buf = 67109376;
        *(_DWORD *)v68 = v40;
        *(_WORD *)&v68[4] = 1024;
        *(_DWORD *)&v68[6] = v14;
        _os_log_debug_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEBUG, "proposal #%u len=%d\n", buf, 0xEu);
      }
    }
    if ((a2 & 0xFFFFFFFE) == 2)
    {
      if (dword_10008FA20)
      {
        uint64_t v17 = ne_log_obj();
        if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 67109120;
          *(_DWORD *)v68 = a2;
          _os_log_error_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_ERROR, "unsupported mode %d\n", buf, 8u);
        }
      }
    }
    else if ((((uint64_t (*)(void))off_100088EC8[a2])(*(unsigned __int8 *)(v15 + 5)) & 0x80000000) == 0 {
           && (sub_10000CD64(*(unsigned __int8 *)(v15 + 5), *(unsigned __int8 *)(v15 + 6)) & 0x80000000) == 0)
    }
    {
      uint64_t v18 = *(unsigned __int8 *)(v15 + 6);
      if (v18 + 8 <= (unint64_t)(int)i[1])
      {
        int v19 = sub_100022CA8(3u, (unsigned __int8 *)(v15 + v18 + 8), (bswap32(*(unsigned __int16 *)(v15 + 2)) >> 16) - v18 - 8);
        if (!v19) {
          goto LABEL_106;
        }
        int v20 = v19;
        BOOL v21 = (unsigned __int8 *)v19[1];
LABEL_37:
        if (*v21 != 3)
        {
          if (!*v21) {
            goto LABEL_68;
          }
          if (!dword_10008FA20) {
            goto LABEL_68;
          }
          v34 = ne_log_obj();
          if (!os_log_type_enabled(v34, OS_LOG_TYPE_ERROR)) {
            goto LABEL_68;
          }
          int v35 = *v21;
          *(_DWORD *)buf = 67109120;
          *(_DWORD *)v68 = v35;
          uint8_t v36 = v34;
          v37 = "Invalid payload type=%u\n";
          uint32_t v38 = 8;
          goto LABEL_71;
        }
        unsigned int v22 = *((_DWORD *)v21 + 1);
        if (v22 <= 7)
        {
          if (!dword_10008FA20) {
            goto LABEL_68;
          }
          int v39 = ne_log_obj();
          if (!os_log_type_enabled(v39, OS_LOG_TYPE_ERROR)) {
            goto LABEL_68;
          }
          int v41 = *((_DWORD *)v21 + 1);
          *(_DWORD *)buf = 134218240;
          *(void *)v68 = 8;
          *(_WORD *)&v68[8] = 1024;
          int v69 = v41;
          uint8_t v36 = v39;
          v37 = "get_transform invalid length of transform, expected %lu actual %d\n";
          uint32_t v38 = 18;
LABEL_71:
          _os_log_error_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_ERROR, v37, buf, v38);
LABEL_68:
          sub_10003FA78(v20);
          continue;
        }
        uint64_t v23 = *((void *)v21 + 1);
        if (dword_10008FA20)
        {
          uint64_t v24 = ne_log_obj();
          if (os_log_type_enabled(v24, OS_LOG_TYPE_DEBUG))
          {
            int v33 = *(unsigned __int8 *)(v23 + 4);
            *(_DWORD *)buf = 67109376;
            *(_DWORD *)v68 = v33;
            *(_WORD *)&v68[4] = 1024;
            *(_DWORD *)&v68[6] = v22;
            _os_log_debug_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEBUG, "transform #%u len=%u\n", buf, 0xEu);
          }
        }
        uint64_t v25 = *(unsigned __int8 *)(v15 + 5);
        if (v25 < 5)
        {
          if (*(unsigned char *)(v15 + 5))
          {
            if ((qword_100088EE8[v25](*(unsigned __int8 *)(v23 + 5)) & 0x80000000) == 0
              && !qword_100088F10[*(unsigned __int8 *)(v15 + 5)](v23))
            {
              int v27 = malloc_type_calloc(1uLL, 0x20uLL, 0x20040DC1BFBCFuLL);
              if (!v27)
              {
                if (dword_10008FA20)
                {
                  v64 = ne_log_obj();
                  if (os_log_type_enabled(v64, OS_LOG_TYPE_ERROR)) {
                    sub_10005821C();
                  }
                }
                sub_10003FA78(v20);
                goto LABEL_106;
              }
              *int v27 = v15;
              v27[1] = v23;
              uint64_t v28 = *(unsigned __int8 *)(v15 + 4);
              size_t v29 = (void *)*((void *)v11 + v28);
              do
              {
                if (!v29)
                {
                  *((void *)v11 + v28) = v27;
                  ++v66;
                  goto LABEL_60;
                }
                int v30 = v29;
                size_t v29 = (void *)v29[2];
              }
              while (v29);
              if (*v30 == v15)
              {
                do
                {
                  int v31 = v30;
                  int v30 = (void *)v30[3];
                }
                while (v30);
                v31[3] = v27;
              }
              else
              {
                v30[2] = v27;
              }
            }
          }
          else if (dword_10008FA20)
          {
            uint64_t v26 = ne_log_obj();
            if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
            {
LABEL_59:
              int v32 = *(unsigned __int8 *)(v15 + 5);
              *(_DWORD *)buf = 67109120;
              *(_DWORD *)v68 = v32;
              _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "unsupported proto_id %u\n", buf, 8u);
            }
          }
        }
        else if (dword_10008FA20)
        {
          uint64_t v26 = ne_log_obj();
          if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT)) {
            goto LABEL_59;
          }
        }
LABEL_60:
        v21 += 16;
        goto LABEL_37;
      }
      if (dword_10008FA20)
      {
        v63 = ne_log_obj();
        if (os_log_type_enabled(v63, OS_LOG_TYPE_ERROR)) {
          sub_10005836C();
        }
      }
      goto LABEL_106;
    }
  }
  if (*(unsigned char *)i)
  {
    if (dword_10008FA20)
    {
      long long v52 = ne_log_obj();
      if (os_log_type_enabled(v52, OS_LOG_TYPE_ERROR)) {
        sub_100058250();
      }
    }
    goto LABEL_106;
  }
  sub_10003FA78(v65);
  for (uint64_t j = 0; j != 256; ++j)
  {
    if (*((void *)v11 + j))
    {
      if (dword_10008FA20)
      {
        long long v44 = ne_log_obj();
        if (os_log_type_enabled(v44, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)buf = 67109120;
          *(_DWORD *)v68 = j;
          _os_log_debug_impl((void *)&_mh_execute_header, v44, OS_LOG_TYPE_DEBUG, "pair %d:\n", buf, 8u);
        }
      }
      sub_1000379EC(7, *((void *)v11 + j));
      long long v45 = (void *)*((void *)v11 + j);
      if (v45)
      {
        int v46 = 0;
        uint64_t v47 = *((void *)v11 + j);
        while (*(void *)(v47 + 8))
        {
          uint64_t v48 = v47;
          do
          {
            ++v46;
            uint64_t v48 = *(void *)(v48 + 24);
          }
          while (v48);
          uint64_t v47 = *(void *)(v47 + 16);
          if (!v47) {
            goto LABEL_91;
          }
        }
        do
        {
          long long v49 = (void *)v45[2];
          free(v45);
          long long v45 = v49;
        }
        while (v49);
        *((void *)v11 + j) = 0;
        --v66;
      }
      else
      {
        int v46 = 0;
LABEL_91:
        if (dword_10008FA20)
        {
          long long v50 = ne_log_obj();
          if (os_log_type_enabled(v50, OS_LOG_TYPE_DEBUG))
          {
            int v51 = *(unsigned __int8 *)(**((void **)v11 + j) + 4);
            *(_DWORD *)buf = 67109376;
            *(_DWORD *)v68 = v51;
            *(_WORD *)&v68[4] = 1024;
            *(_DWORD *)&v68[6] = v46;
            _os_log_debug_impl((void *)&_mh_execute_header, v50, OS_LOG_TYPE_DEBUG, "proposal #%u: %d transform\n", buf, 0xEu);
          }
        }
      }
    }
  }
  if (v66 <= 0)
  {
    if (dword_10008FA20)
    {
      long long v53 = ne_log_obj();
      if (os_log_type_enabled(v53, OS_LOG_TYPE_ERROR)) {
        sub_1000582B8();
      }
    }
    goto LABEL_107;
  }
  return v11;
}

void sub_10000AC28(void *a1)
{
  for (uint64_t i = 0; i != 256; ++i)
  {
    unint64_t v3 = (void *)a1[i];
    while (v3)
    {
      unint64_t v4 = v3;
      unint64_t v3 = (void *)v3[2];
      do
      {
        int v5 = (void *)v4[3];
        free(v4);
        unint64_t v4 = v5;
      }
      while (v5);
    }
    a1[i] = 0;
  }

  free(a1);
}

_DWORD *sub_10000AC9C(uint64_t *a1, uint64_t a2, _OWORD *a3, int a4)
{
  uint64_t v8 = *a1;
  uint64_t v7 = a1[1];
  memset(v58, 0, sizeof(v58));
  if (dword_10008FA20)
  {
    int v9 = ne_log_obj();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG)) {
      sub_1000585C0(v8);
    }
    if (dword_10008FA20)
    {
      int v10 = ne_log_obj();
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG)) {
        sub_100058520(v7, v8);
      }
    }
  }
  if (a3) {
    uint64_t v11 = a3;
  }
  else {
    uint64_t v11 = v58;
  }
  v11[4] = 0u;
  v11[5] = 0u;
  v11[2] = 0u;
  v11[3] = 0u;
  *uint64_t v11 = 0u;
  v11[1] = 0u;
  if ((sub_10000B400(v7, (uint64_t)v11) & 0x80000000) != 0) {
    return 0;
  }
  if (a2)
  {
    if (a3) {
      int v12 = a3;
    }
    else {
      int v12 = v58;
    }
    while (1)
    {
      int v13 = sub_10000BB7C(*(unsigned int *)(a2 + 48));
      int v14 = sub_10000BB7C(*((unsigned int *)v12 + 12));
      if (dword_10008FA20)
      {
        uint64_t v15 = ne_log_obj();
        if (os_log_type_enabled(v15, OS_LOG_TYPE_DEBUG)) {
          sub_1000584F4(&v56, v57);
        }
        if (dword_10008FA20)
        {
          __int16 v16 = ne_log_obj();
          if (os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG))
          {
            int v25 = *(_DWORD *)a2;
            int v26 = *(_DWORD *)v11;
            *(_DWORD *)buf = 67109376;
            *(_DWORD *)uint64_t v60 = v25;
            *(_WORD *)&v60[4] = 1024;
            *(_DWORD *)&v60[6] = v26;
            _os_log_debug_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEBUG, "(version = %d:%d)\n", buf, 0xEu);
          }
          if (dword_10008FA20)
          {
            uint64_t v17 = ne_log_obj();
            if (os_log_type_enabled(v17, OS_LOG_TYPE_DEBUG))
            {
              uint64_t v27 = *(void *)(a2 + 16);
              uint64_t v28 = (char *)*((void *)v12 + 2);
              *(_DWORD *)buf = 134218240;
              *(void *)uint64_t v60 = v27;
              *(_WORD *)&v60[8] = 2048;
              CFTypeID v61 = v28;
              _os_log_debug_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEBUG, "(lifetime = %ld:%ld)\n", buf, 0x16u);
            }
            if (dword_10008FA20)
            {
              uint64_t v18 = ne_log_obj();
              if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
              {
                uint64_t v29 = *(void *)(a2 + 32);
                int v30 = (char *)*((void *)v12 + 4);
                *(_DWORD *)buf = 134218240;
                *(void *)uint64_t v60 = v29;
                *(_WORD *)&v60[8] = 2048;
                CFTypeID v61 = v30;
                _os_log_debug_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEBUG, "(lifebyte = %zu:%zu)\n", buf, 0x16u);
              }
              if (dword_10008FA20)
              {
                int v19 = ne_log_obj();
                if (os_log_type_enabled(v19, OS_LOG_TYPE_DEBUG))
                {
                  int v31 = sub_10003EC84(1, *(unsigned int *)(a2 + 40));
                  int v32 = sub_10003EC84(1, *((unsigned int *)v12 + 10));
                  *(_DWORD *)buf = 136315394;
                  *(void *)uint64_t v60 = v31;
                  *(_WORD *)&v60[8] = 2080;
                  CFTypeID v61 = v32;
                  _os_log_debug_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEBUG, "enctype = %s:%s\n", buf, 0x16u);
                }
                if (dword_10008FA20)
                {
                  int v20 = ne_log_obj();
                  if (os_log_type_enabled(v20, OS_LOG_TYPE_DEBUG))
                  {
                    int v34 = *(_DWORD *)(a2 + 44);
                    int v35 = *((_DWORD *)v12 + 11);
                    *(_DWORD *)buf = 67109376;
                    *(_DWORD *)uint64_t v60 = v34;
                    *(_WORD *)&v60[4] = 1024;
                    *(_DWORD *)&v60[6] = v35;
                    _os_log_debug_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEBUG, "(encklen = %d:%d)\n", buf, 0xEu);
                  }
                  if (dword_10008FA20)
                  {
                    BOOL v21 = ne_log_obj();
                    if (os_log_type_enabled(v21, OS_LOG_TYPE_DEBUG))
                    {
                      uint8_t v36 = sub_10003EC84(2, *(unsigned int *)(a2 + 52));
                      v37 = sub_10003EC84(2, *((unsigned int *)v12 + 13));
                      *(_DWORD *)buf = 136315394;
                      *(void *)uint64_t v60 = v36;
                      *(_WORD *)&v60[8] = 2080;
                      CFTypeID v61 = v37;
                      _os_log_debug_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEBUG, "hashtype = %s:%s\n", buf, 0x16u);
                    }
                    if (dword_10008FA20)
                    {
                      unsigned int v22 = ne_log_obj();
                      if (os_log_type_enabled(v22, OS_LOG_TYPE_DEBUG))
                      {
                        uint32_t v38 = sub_10003EC84(3, *(unsigned int *)(a2 + 48));
                        int v39 = sub_10003EC84(3, *((unsigned int *)v12 + 12));
                        *(_DWORD *)buf = 136315394;
                        *(void *)uint64_t v60 = v38;
                        *(_WORD *)&v60[8] = 2080;
                        CFTypeID v61 = v39;
                        _os_log_debug_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEBUG, "authmethod = %s:%s\n", buf, 0x16u);
                      }
                      if (dword_10008FA20)
                      {
                        uint64_t v23 = ne_log_obj();
                        if (os_log_type_enabled(v23, OS_LOG_TYPE_DEBUG))
                        {
                          int v40 = sub_10003EC84(4, *(unsigned int *)(a2 + 60));
                          int v41 = sub_10003EC84(4, *((unsigned int *)v12 + 15));
                          *(_DWORD *)buf = 136315394;
                          *(void *)uint64_t v60 = v40;
                          *(_WORD *)&v60[8] = 2080;
                          CFTypeID v61 = v41;
                          _os_log_debug_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEBUG, "dh_group = %s:%s\n", buf, 0x16u);
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
      if (*((_DWORD *)v12 + 10) == *(_DWORD *)(a2 + 40))
      {
        BOOL v24 = *((_DWORD *)v12 + 12) == v13 || v14 == v13;
        if (v24
          && *((_DWORD *)v12 + 13) == *(_DWORD *)(a2 + 52)
          && *((_DWORD *)v12 + 15) == *(_DWORD *)(a2 + 60)
          && *((_DWORD *)v12 + 11) == *(_DWORD *)(a2 + 44)
          && *(_DWORD *)v11 == *(_DWORD *)a2)
        {
          break;
        }
      }
LABEL_61:
      a2 = *(void *)(a2 + 80);
      if (!a2) {
        goto LABEL_65;
      }
    }
    switch(a4)
    {
      case 1:
        break;
      case 2:
        if (*((void *)v12 + 2) > *(void *)(a2 + 16) || *((void *)v12 + 4) > *(void *)(a2 + 32)) {
          goto LABEL_61;
        }
        break;
      case 3:
        uint64_t v52 = *((void *)v12 + 2);
        if (v52 < *(void *)(a2 + 16)) {
          *(void *)(a2 + 16) = v52;
        }
        unint64_t v53 = *((void *)v12 + 4);
        if (v53 < *(void *)(a2 + 32)) {
          *(void *)(a2 + 32) = v53;
        }
        break;
      case 4:
        if (*((void *)v12 + 2) != *(void *)(a2 + 16) || *((void *)v12 + 4) != *(void *)(a2 + 32)) {
          goto LABEL_61;
        }
        break;
      default:
        if (dword_10008FA20)
        {
          int v33 = ne_log_obj();
          if (os_log_type_enabled(v33, OS_LOG_TYPE_ERROR)) {
            sub_1000584C4(&v54, v55);
          }
        }
        goto LABEL_61;
    }
  }
  else
  {
    int v13 = 0;
    int v14 = 0;
  }
LABEL_65:
  if (a3) {
    v43 = a3;
  }
  else {
    v43 = v58;
  }
  long long v44 = (void *)*((void *)v43 + 8);
  if (v44)
  {
    sub_1000294BC(v44);
    *((void *)v43 + 8) = 0;
  }
  uint64_t result = sub_100039E50(a2);
  if (result)
  {
    if (a4 == 3)
    {
      long long v49 = v58;
      if (a3) {
        long long v50 = a3;
      }
      else {
        long long v50 = v58;
      }
      uint64_t v51 = *((void *)v50 + 2);
      if (v51 < *((void *)result + 2)) {
        *((void *)result + 2) = v51;
      }
      if (a3) {
        long long v49 = a3;
      }
      unint64_t v46 = *((void *)v49 + 4);
      if (v46 >= *((void *)result + 4)) {
        goto LABEL_78;
      }
    }
    else
    {
      if (a4 != 2 && a4 != 1) {
        goto LABEL_78;
      }
      long long v45 = v58;
      if (a3) {
        long long v45 = a3;
      }
      *((void *)result + 2) = *((void *)v45 + 2);
      unint64_t v46 = *((void *)v45 + 4);
    }
    *((void *)result + 4) = v46;
LABEL_78:
    uint64_t v47 = v58;
    if (a3) {
      uint64_t v47 = a3;
    }
    int v48 = *((_DWORD *)v47 + 12);
    if (v48 != v13 && v14 == v13) {
      result[12] = v48;
    }
  }
  return result;
}

uint64_t sub_10000B400(uint64_t a1, uint64_t a2)
{
  unsigned int v4 = *(unsigned __int16 *)(a1 + 2);
  *(void *)(a2 + 16) = 28800;
  *(void *)(a2 + 32) = 0;
  int v5 = malloc_type_calloc(1uLL, 0x30uLL, 0x10200409D20112CuLL);
  *(void *)(a2 + 64) = v5;
  if (!v5) {
    return 0xFFFFFFFFLL;
  }
  unsigned int v6 = bswap32(v4) >> 16;
  if (v6 < 9) {
    return 0;
  }
  uint64_t v7 = 0;
  int v46 = 0;
  uint64_t v8 = 0;
  int v9 = v6 - 8;
  int v10 = (unsigned __int16 *)(a1 + 8);
  long long v44 = (unsigned int *)(a2 + 40);
  int v45 = 1;
  do
  {
    unint64_t v11 = v9;
    if (v9 <= 3)
    {
      if (dword_10008FA20)
      {
        int v35 = ne_log_obj();
        if (os_log_type_enabled(v35, OS_LOG_TYPE_ERROR)) {
          sub_100058680();
        }
      }
      return 0xFFFFFFFFLL;
    }
    int v12 = *v10;
    unsigned int v13 = bswap32(v12 & 0xFFFFFF7F) >> 16;
    int v14 = (v12 << 8) & 0x8000;
    if (dword_10008FA20)
    {
      uint64_t v15 = ne_log_obj();
      if (os_log_type_enabled(v15, OS_LOG_TYPE_DEBUG))
      {
        int v31 = sub_10003E928(v13);
        int v32 = sub_10003EC84(v13, bswap32(v10[1]) >> 16);
        *(_DWORD *)buf = 136315650;
        *(void *)long long v50 = v31;
        *(_WORD *)&v50[8] = 1024;
        v51[0] = v14;
        LOWORD(v51[1]) = 2080;
        *(void *)((char *)&v51[1] + 2) = v32;
        _os_log_debug_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEBUG, "type=%s, flag=0x%04x, lorv=%s\n", buf, 0x1Cu);
      }
    }
    if (v13 <= 0x10 && ((1 << v13) & 0x117C0) != 0)
    {
      uint64_t v17 = v10 + 1;
      if (v14)
      {
        LODWORD(v18) = 2;
      }
      else
      {
        uint64_t v18 = bswap32(*v17) >> 16;
        if (v18 + 4 > v11)
        {
          if (dword_10008FA20)
          {
            v37 = ne_log_obj();
            if (os_log_type_enabled(v37, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)buf = 67109632;
              *(_DWORD *)long long v50 = v13;
              *(_WORD *)&v50[4] = 1024;
              *(_DWORD *)&v50[6] = v18;
              LOWORD(v51[0]) = 2048;
              *(void *)((char *)v51 + 2) = v11 - 4;
              _os_log_error_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_ERROR, "invalid ISAKMP-SA attr(%d), attr-len %d, overall-len %lu\n", buf, 0x18u);
            }
          }
          return 0xFFFFFFFFLL;
        }
        uint64_t v17 = v10 + 2;
      }
      size_t v19 = v18;
      int v20 = sub_10003F940(v18);
      if (!v20) {
        return 0xFFFFFFFFLL;
      }
      uint64_t v7 = v20;
      memcpy((void *)v20[1], v17, v19);
    }
    switch(v13)
    {
      case 1u:
        unsigned int *v44 = bswap32(v10[1]) >> 16;
        if (v14) {
          goto LABEL_62;
        }
        break;
      case 2u:
        *(_DWORD *)(a2 + 52) = bswap32(v10[1]) >> 16;
        if (!v14) {
          break;
        }
        goto LABEL_62;
      case 3u:
        *(_DWORD *)(a2 + 48) = bswap32(v10[1]) >> 16;
        if (!v14) {
          break;
        }
        goto LABEL_62;
      case 4u:
        *(_DWORD *)(a2 + 60) = bswap32(v10[1]) >> 16;
        if (!v14) {
          break;
        }
        goto LABEL_62;
      case 5u:
        if (v10[1] != 256) {
          return 0xFFFFFFFFLL;
        }
        *(_DWORD *)(*(void *)(a2 + 64) + 4) = 1;
        if (!v14) {
          break;
        }
        goto LABEL_62;
      case 6u:
        *(void *)(*(void *)(a2 + 64) + 8) = v7;
        if (!v14) {
          break;
        }
        goto LABEL_62;
      case 7u:
        sub_10003FA78(v7);
        size_t v21 = bswap32(v10[1]) >> 16;
        if (!v14)
        {
          *(_DWORD *)(*(void *)(a2 + 64) + 16) = v21;
          LODWORD(v24) = v21;
          goto LABEL_70;
        }
        uint64_t v22 = *(void *)(a2 + 64);
        *(_DWORD *)(v22 + 16) = 0;
        uint64_t v23 = (void *)(v22 + 16);
        if (v21 > 4) {
          return 0xFFFFFFFFLL;
        }
        if (v21 + 4 > v11)
        {
          if (dword_10008FA20)
          {
            int v39 = ne_log_obj();
            if (os_log_type_enabled(v39, OS_LOG_TYPE_ERROR)) {
              sub_1000587C8();
            }
          }
          return 0xFFFFFFFFLL;
        }
        memcpy(v23, v10 + 2, v21);
        *(_DWORD *)(*(void *)(a2 + 64) + 16) = bswap32(*(_DWORD *)(*(void *)(a2 + 64) + 16));
        goto LABEL_62;
      case 8u:
        sub_10003FA78(v7);
        size_t v24 = bswap32(v10[1]) >> 16;
        if (!v14)
        {
          *(_DWORD *)(*(void *)(a2 + 64) + 20) = v24;
          goto LABEL_69;
        }
        uint64_t v25 = *(void *)(a2 + 64);
        *(_DWORD *)(v25 + 20) = 0;
        int v26 = (void *)(v25 + 20);
        if (v24 > 4) {
          return 0xFFFFFFFFLL;
        }
        if (v24 + 4 > v11)
        {
          if (dword_10008FA20)
          {
            int v40 = ne_log_obj();
            if (os_log_type_enabled(v40, OS_LOG_TYPE_ERROR)) {
              sub_100058838();
            }
          }
          return 0xFFFFFFFFLL;
        }
        memcpy(v26, v10 + 2, v24);
        *(_DWORD *)(*(void *)(a2 + 64) + 20) = bswap32(*(_DWORD *)(*(void *)(a2 + 64) + 20));
        goto LABEL_62;
      case 9u:
        *(void *)(*(void *)(a2 + 64) + 24) = v7;
        if (!v14) {
          break;
        }
        goto LABEL_62;
      case 0xAu:
        *(void *)(*(void *)(a2 + 64) + 32) = v7;
        if (!v14) {
          break;
        }
        goto LABEL_62;
      case 0xBu:
        unsigned int v27 = bswap32(v10[1]) >> 16;
        if ((((_WORD)v27 - 1) & 0xFFFE) != 0) {
          unsigned int v27 = 1;
        }
        goto LABEL_46;
      case 0xCu:
        if (v8 && (*v8 & 0xFF7F) == 0xB00)
        {
          if (v45 == 2)
          {
            *(void *)(a2 + 32) = sub_10000C0F4((uint64_t)v7);
            sub_10003FA78(v7);
            if (*(void *)(a2 + 32))
            {
              unsigned int v27 = 2;
LABEL_46:
              int v45 = v27;
              if (v14) {
                goto LABEL_62;
              }
              break;
            }
            if (!dword_10008FA20) {
              return 0xFFFFFFFFLL;
            }
            v43 = ne_log_obj();
            if (!os_log_type_enabled(v43, OS_LOG_TYPE_ERROR)) {
              return 0xFFFFFFFFLL;
            }
LABEL_103:
            sub_100058940();
            return 0xFFFFFFFFLL;
          }
          if (v45 == 1)
          {
            *(void *)(a2 + 16) = sub_10000C0F4((uint64_t)v7);
            sub_10003FA78(v7);
            if (*(void *)(a2 + 16))
            {
              unsigned int v27 = 1;
              goto LABEL_46;
            }
            if (!dword_10008FA20) {
              return 0xFFFFFFFFLL;
            }
            v42 = ne_log_obj();
            if (!os_log_type_enabled(v42, OS_LOG_TYPE_ERROR)) {
              return 0xFFFFFFFFLL;
            }
            goto LABEL_103;
          }
          sub_10003FA78(v7);
          if (dword_10008FA20)
          {
            int v41 = ne_log_obj();
            if (os_log_type_enabled(v41, OS_LOG_TYPE_ERROR)) {
              sub_1000588D8();
            }
          }
          return 0xFFFFFFFFLL;
        }
        if (dword_10008FA20 && (uint64_t v29 = ne_log_obj(), os_log_type_enabled(v29, OS_LOG_TYPE_ERROR)))
        {
          sub_1000588A8(&v47, v48);
          if (v14)
          {
LABEL_62:
            int v9 = v11 - 4;
            uint64_t v30 = (uint64_t)(v10 + 2);
            goto LABEL_72;
          }
        }
        else
        {
LABEL_61:
          if (v14) {
            goto LABEL_62;
          }
        }
        break;
      case 0xEu:
        unsigned int v28 = bswap32(v10[1]) >> 16;
        if ((v28 & 7) != 0)
        {
          if (dword_10008FA20)
          {
            uint32_t v38 = ne_log_obj();
            if (os_log_type_enabled(v38, OS_LOG_TYPE_ERROR)) {
              sub_100058974();
            }
          }
          return 0xFFFFFFFFLL;
        }
        *(_DWORD *)(a2 + 44) = v28;
        ++v46;
        if (v14) {
          goto LABEL_62;
        }
        break;
      case 0x10u:
        *(void *)(*(void *)(a2 + 64) + 40) = v7;
        if (!v14) {
          break;
        }
        goto LABEL_62;
      default:
        goto LABEL_61;
    }
    LODWORD(v24) = bswap32(v10[1]) >> 16;
LABEL_69:
    LODWORD(v21) = v24;
LABEL_70:
    int v9 = v11 - v24 - 4;
    if (v9 < 0)
    {
      if (dword_10008FA20)
      {
        uint8_t v36 = ne_log_obj();
        if (os_log_type_enabled(v36, OS_LOG_TYPE_ERROR)) {
          sub_1000586E8();
        }
      }
      return 0xFFFFFFFFLL;
    }
    uint64_t v30 = (uint64_t)v10 + v21 + 4;
LABEL_72:
    uint64_t v8 = v10;
    int v10 = (unsigned __int16 *)v30;
  }
  while (v9 > 0);
  if (v46 && (*v44 | 4) == 5)
  {
    if (dword_10008FA20)
    {
      int v33 = ne_log_obj();
      if (os_log_type_enabled(v33, OS_LOG_TYPE_ERROR)) {
        sub_10005875C();
      }
    }
    return 0xFFFFFFFFLL;
  }
  return 0;
}

uint64_t sub_10000BB7C(uint64_t result)
{
  switch((int)result)
  {
    case 65002:
      uint64_t result = 65001;
      break;
    case 65003:
    case 65005:
    case 65007:
    case 65009:
      return result;
    case 65004:
      uint64_t result = 65003;
      break;
    case 65006:
      uint64_t result = 65005;
      break;
    case 65008:
      uint64_t result = 65007;
      break;
    case 65010:
      uint64_t result = 65009;
      break;
    default:
      if (result == 64222) {
        unsigned int v1 = 64221;
      }
      else {
        unsigned int v1 = result;
      }
      if (result == 64224) {
        uint64_t result = 64223;
      }
      else {
        uint64_t result = v1;
      }
      break;
  }
  return result;
}

void sub_10000BC1C(uint64_t *a1, uint64_t a2)
{
  *(_OWORD *)long long v50 = 0u;
  long long v51 = 0u;
  long long v48 = 0u;
  long long v49 = 0u;
  memset(v47, 0, sizeof(v47));
  if ((sub_10000B400(a1[1], (uint64_t)v47) & 0x80000000) == 0)
  {
    if (a2)
    {
      uint64_t v3 = DWORD2(v48);
      do
      {
        if (v3 != *(_DWORD *)(a2 + 40) && dword_10008FA20 != 0)
        {
          int v5 = ne_log_obj();
          if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
          {
            int v21 = *(_DWORD *)(a2 + 4);
            int v22 = *(_DWORD *)(a2 + 8);
            int v23 = *(unsigned __int8 *)(*a1 + 4);
            int v24 = *(unsigned __int8 *)(a1[1] + 4);
            uint64_t v25 = sub_10003EC84(1, *(unsigned int *)(a2 + 40));
            int v26 = sub_10003EC84(1, v3);
            *(_DWORD *)buf = 67110402;
            int v53 = v21;
            __int16 v54 = 1024;
            int v55 = v22;
            __int16 v56 = 1024;
            int v57 = v23;
            __int16 v58 = 1024;
            int v59 = v24;
            __int16 v60 = 2080;
            CFTypeID v61 = v25;
            __int16 v62 = 2080;
            *(void *)v63 = v26;
            _os_log_error_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "rejected enctype: DB(prop#%d:trns#%d):Peer(prop#%d:trns#%d) = %s:%s\n", buf, 0x2Eu);
          }
        }
        uint64_t v6 = v49;
        if (v49 != *(_DWORD *)(a2 + 48) && dword_10008FA20 != 0)
        {
          uint64_t v8 = ne_log_obj();
          if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
          {
            int v27 = *(_DWORD *)(a2 + 4);
            int v28 = *(_DWORD *)(a2 + 8);
            int v29 = *(unsigned __int8 *)(*a1 + 4);
            int v30 = *(unsigned __int8 *)(a1[1] + 4);
            int v31 = sub_10003EC84(3, *(unsigned int *)(a2 + 48));
            int v32 = sub_10003EC84(3, v6);
            *(_DWORD *)buf = 67110402;
            int v53 = v27;
            __int16 v54 = 1024;
            int v55 = v28;
            __int16 v56 = 1024;
            int v57 = v29;
            __int16 v58 = 1024;
            int v59 = v30;
            __int16 v60 = 2080;
            CFTypeID v61 = v31;
            __int16 v62 = 2080;
            *(void *)v63 = v32;
            _os_log_error_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "rejected authmethod: DB(prop#%d:trns#%d):Peer(prop#%d:trns#%d) = %s:%s\n", buf, 0x2Eu);
          }
        }
        uint64_t v9 = DWORD1(v49);
        if (DWORD1(v49) != *(_DWORD *)(a2 + 52))
        {
          if (dword_10008FA20)
          {
            int v10 = ne_log_obj();
            if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
            {
              int v33 = *(_DWORD *)(a2 + 4);
              int v34 = *(_DWORD *)(a2 + 8);
              int v35 = *(unsigned __int8 *)(*a1 + 4);
              int v36 = *(unsigned __int8 *)(a1[1] + 4);
              v37 = sub_10003EC84(2, *(unsigned int *)(a2 + 52));
              uint32_t v38 = sub_10003EC84(2, v9);
              *(_DWORD *)buf = 67110402;
              int v53 = v33;
              __int16 v54 = 1024;
              int v55 = v34;
              __int16 v56 = 1024;
              int v57 = v35;
              __int16 v58 = 1024;
              int v59 = v36;
              __int16 v60 = 2080;
              CFTypeID v61 = v37;
              __int16 v62 = 2080;
              *(void *)v63 = v38;
              _os_log_error_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "rejected hashtype: DB(prop#%d:trns#%d):Peer(prop#%d:trns#%d) = %s:%s\n", buf, 0x2Eu);
            }
          }
        }
        uint64_t v11 = LODWORD(v50[1]);
        if (v50[1] != *(void **)(a2 + 72))
        {
          if (dword_10008FA20)
          {
            int v12 = ne_log_obj();
            if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
            {
              int v15 = *(_DWORD *)(a2 + 4);
              int v45 = *(_DWORD *)(a2 + 8);
              int v16 = *(unsigned __int8 *)(*a1 + 4);
              int v17 = *(unsigned __int8 *)(a1[1] + 4);
              uint64_t v18 = sub_10003EC84(2, *(unsigned int *)(a2 + 72));
              int v19 = *(_DWORD *)(a2 + 76);
              int v20 = sub_10003EC84(2, v11);
              *(_DWORD *)buf = 67110914;
              int v53 = v15;
              __int16 v54 = 1024;
              int v55 = v45;
              __int16 v56 = 1024;
              int v57 = v16;
              __int16 v58 = 1024;
              int v59 = v17;
              __int16 v60 = 2080;
              CFTypeID v61 = v18;
              __int16 v62 = 1024;
              *(_DWORD *)v63 = v19;
              *(_WORD *)&v63[4] = 2080;
              *(void *)&v63[6] = v20;
              __int16 v64 = 1024;
              int v65 = HIDWORD(v50[1]);
              _os_log_error_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, "rejected prf: DB(prop#%d:trns#%d):Peer(prop#%d:trns#%d) = %s.%d:%s.%d\n", buf, 0x3Au);
            }
          }
        }
        uint64_t v13 = HIDWORD(v49);
        if (HIDWORD(v49) != *(_DWORD *)(a2 + 60))
        {
          if (dword_10008FA20)
          {
            int v14 = ne_log_obj();
            if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
            {
              int v39 = *(_DWORD *)(a2 + 4);
              int v40 = *(_DWORD *)(a2 + 8);
              int v41 = *(unsigned __int8 *)(*a1 + 4);
              int v42 = *(unsigned __int8 *)(a1[1] + 4);
              v43 = sub_10003EC84(4, *(unsigned int *)(a2 + 60));
              long long v44 = sub_10003EC84(4, v13);
              *(_DWORD *)buf = 67110402;
              int v53 = v39;
              __int16 v54 = 1024;
              int v55 = v40;
              __int16 v56 = 1024;
              int v57 = v41;
              __int16 v58 = 1024;
              int v59 = v42;
              __int16 v60 = 2080;
              CFTypeID v61 = v43;
              __int16 v62 = 2080;
              *(void *)v63 = v44;
              _os_log_error_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, "rejected dh_group: DB(prop#%d:trns#%d):Peer(prop#%d:trns#%d) = %s:%s\n", buf, 0x2Eu);
            }
          }
        }
        a2 = *(void *)(a2 + 80);
      }
      while (a2);
    }
    if (v50[0]) {
      sub_1000294BC((void *)v50[0]);
    }
  }
}

uint64_t sub_10000C0F4(uint64_t result)
{
  if (result)
  {
    if (*(void *)result == 4) {
      return bswap32(**(_DWORD **)(result + 8));
    }
    if (*(void *)result == 2) {
      return bswap32(**(unsigned __int16 **)(result + 8)) >> 16;
    }
    if (dword_10008FA20)
    {
      unsigned int v1 = ne_log_obj();
      uint64_t result = os_log_type_enabled(v1, OS_LOG_TYPE_ERROR);
      if (!result) {
        return result;
      }
      sub_1000589DC();
    }
    return 0;
  }
  return result;
}

uint64_t sub_10000C184(uint64_t a1)
{
  int v2 = sub_10000A3A8(*(unint64_t **)(a1 + 224), 1u);
  if (!v2) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v3 = v2;
  unsigned int v4 = sub_10000C21C(a1, (uint64_t)v2);
  sub_10000AC28(v3);
  if (!v4) {
    return 0xFFFFFFFFLL;
  }
  *(void *)(a1 + 232) = sub_10000C608(v4, *(void *)(a1 + 256));
  do
  {
    int v5 = v4;
    unsigned int v4 = (void *)v4[2];
    do
    {
      uint64_t v6 = (void *)v5[3];
      free(v5);
      int v5 = v6;
    }
    while (v6);
  }
  while (v4);
  if (*(void *)(a1 + 232)) {
    return 0;
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

_OWORD *sub_10000C21C(uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + 128) = 0;
  if (dword_10008FA20)
  {
    unsigned int v4 = ne_log_obj();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG)) {
      sub_100058B5C();
    }
  }
  for (uint64_t i = 0; i != 256; ++i)
  {
    uint64_t v6 = *(void *)(a2 + 8 * i);
    if (v6)
    {
      if (dword_10008FA20)
      {
        uint64_t v7 = ne_log_obj();
        BOOL v8 = os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG);
        uint64_t v6 = *(void *)(a2 + 8 * i);
        if (v8)
        {
          *(_DWORD *)buf = 67109376;
          int v45 = i;
          __int16 v46 = 2048;
          uint64_t v47 = v6;
          _os_log_debug_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEBUG, "pair[%d]: %p\n", buf, 0x12u);
          uint64_t v6 = *(void *)(a2 + 8 * i);
        }
      }
      sub_1000379EC(7, v6);
      uint64_t v9 = *(uint64_t **)(a2 + 8 * i);
      int v10 = sub_100036A00(v9);
      if (v10)
      {
        uint64_t v11 = v10;
        uint64_t v12 = (uint64_t)v10;
        while (1)
        {
          uint64_t v13 = *(void *)(a1 + 120);
          if (v13) {
            break;
          }
LABEL_23:
          uint64_t v12 = *(void *)(v12 + 40);
          if (!v12)
          {
            sub_100036420(v11);
            goto LABEL_54;
          }
        }
        while (1)
        {
          if (dword_10008FA20)
          {
            int v14 = ne_log_obj();
            if (os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG)) {
              sub_100058B30(&v42, v43);
            }
          }
          sub_100036F44(7, v12);
          if (dword_10008FA20)
          {
            int v15 = ne_log_obj();
            if (os_log_type_enabled(v15, OS_LOG_TYPE_DEBUG)) {
              sub_100058B04(&v40, v41);
            }
          }
          sub_100036F44(7, v13);
          int v16 = sub_1000357BC(*(void *)(a1 + 256), v12, v13, *(unsigned __int8 *)(a1 + 60));
          if (v16) {
            break;
          }
          if (dword_10008FA20)
          {
            int v17 = ne_log_obj();
            if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR)) {
              sub_100058A78(&v38, v39);
            }
          }
          uint64_t v13 = *(void *)(v13 + 40);
          if (!v13) {
            goto LABEL_23;
          }
        }
        uint64_t v18 = v16;
        sub_100036420(v11);
        if (dword_10008FA20)
        {
          int v19 = ne_log_obj();
          if (os_log_type_enabled(v19, OS_LOG_TYPE_DEBUG)) {
            sub_100058AD8(&v36, v37);
          }
        }
        *(void *)(a1 + 128) = v18;
        if (v9)
        {
          int v20 = 0;
          while (1)
          {
            uint64_t v21 = v18[4];
            if (!v21) {
              break;
            }
            while (*(_DWORD *)v21 != *(unsigned __int8 *)(*v9 + 5))
            {
              uint64_t v21 = *(void *)(v21 + 72);
              if (!v21) {
                goto LABEL_54;
              }
            }
            int v22 = *(int **)(v21 + 64);
            if (*((void *)v22 + 2)) {
              break;
            }
            int v23 = *v22;
            int v24 = v9;
            while (v23 != *(unsigned __int8 *)(v24[1] + 4))
            {
              int v24 = (uint64_t *)v24[3];
              if (!v24) {
                goto LABEL_54;
              }
            }
            uint64_t v25 = malloc_type_calloc(1uLL, 0x20uLL, 0x20040DC1BFBCFuLL);
            if (!v25)
            {
              if (dword_10008FA20)
              {
                int v31 = ne_log_obj();
                if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR)) {
                  sub_100058AA8(&v34, v35);
                }
              }
              break;
            }
            long long v26 = *(_OWORD *)v24;
            *uint64_t v25 = *(_OWORD *)v24;
            int v27 = v20;
            do
            {
              if (!v27)
              {
                int v20 = v25;
                goto LABEL_48;
              }
              int v28 = v27;
              int v27 = (void *)v27[2];
            }
            while (v27);
            int v29 = v28 + 2;
            if (*v28 == (void)v26)
            {
              do
              {
                int v30 = v28;
                int v28 = (void *)v28[3];
              }
              while (v28);
              int v29 = v30 + 3;
            }
            *int v29 = v25;
LABEL_48:
            uint64_t v9 = (uint64_t *)v9[2];
            if (!v9)
            {
              if (!v20) {
                break;
              }
              return v20;
            }
          }
        }
      }
    }
LABEL_54:
    ;
  }
  if (dword_10008FA20)
  {
    int v32 = ne_log_obj();
    if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR)) {
      sub_100058A44();
    }
  }
  return 0;
}

void *sub_10000C608(void *a1, uint64_t a2)
{
  uint64_t v3 = a1;
  signed int v4 = 8 * (*(unsigned char *)(a2 + 80) == 16);
  if (a1)
  {
    int v5 = a1;
    do
    {
      v4 += *(unsigned __int8 *)(*v5 + 6) + (bswap32(*(unsigned __int16 *)(v5[1] + 2)) >> 16) + 8;
      int v5 = (void *)v5[2];
    }
    while (v5);
  }
  uint64_t v6 = sub_10003F940(v4);
  uint64_t v7 = v6;
  if (v6)
  {
    BOOL v8 = (int8x8_t *)v6[1];
    v8->i16[1] = bswap32(v4) >> 16;
    if (*(unsigned char *)(a2 + 80) == 16) {
      *v8++ = vrev32_s8(*(int8x8_t *)(*(void *)(a2 + 64) + 24));
    }
    if (v3)
    {
      uint64_t v9 = 0;
      do
      {
        int v10 = v8;
        uint64_t v11 = (const void *)*v3;
        uint64_t v12 = *(unsigned __int8 *)(*v3 + 6);
        unsigned int v13 = *(unsigned __int16 *)(v3[1] + 2);
        if (v9)
        {
          v9->i8[0] = 2;
          uint64_t v11 = (const void *)*v3;
        }
        uint64_t v14 = v12 + 8;
        size_t v15 = __rev16(v13);
        memcpy(v10, v11, v12 + 8);
        v10->i8[0] = 0;
        v10->i16[1] = bswap32(v15 + v14) >> 16;
        v10->i8[7] = 1;
        bzero(&v10[1], *(unsigned __int8 *)(*v3 + 6));
        int v16 = (int8x8_t *)((char *)v10 + v14);
        memcpy(v16, (const void *)v3[1], v15);
        v16->i8[0] = 0;
        v16->i16[1] = v13;
        BOOL v8 = (int8x8_t *)((char *)v16 + v15);
        uint64_t v9 = v10;
        uint64_t v3 = (void *)v3[2];
      }
      while (v3);
    }
  }
  else if (dword_10008FA20)
  {
    int v17 = ne_log_obj();
    if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR)) {
      sub_100058B94();
    }
  }
  return v7;
}

uint64_t sub_10000C788(uint64_t a1)
{
  int v2 = sub_10000A3A8(*(unint64_t **)(a1 + 224), 1u);
  if (!v2)
  {
    if (dword_10008FA20)
    {
      int v10 = ne_log_obj();
      if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR)) {
        sub_100058BC8();
      }
    }
    return 0xFFFFFFFFLL;
  }
  uint64_t v3 = v2;
  signed int v4 = sub_10000A3A8(*(unint64_t **)(a1 + 232), 1u);
  if (!v4)
  {
    if (dword_10008FA20)
    {
      uint64_t v11 = ne_log_obj();
      if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR)) {
        sub_100058BC8();
      }
    }
    sub_10000AC28(v3);
    return 0xFFFFFFFFLL;
  }
  int v5 = v4;
  uint64_t v6 = 0;
  int v7 = 0;
  int v8 = 0;
  do
  {
    if (v4[v6])
    {
      int v8 = v6;
      ++v7;
    }
    ++v6;
  }
  while (v6 != 256);
  if (v7 == 1)
  {
    uint64_t v13 = v8;
    if (v3[v8]) {
      BOOL v14 = 1;
    }
    else {
      BOOL v14 = dword_10008FA20 == 0;
    }
    if (!v14)
    {
      size_t v15 = ne_log_obj();
      if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 67109120;
        int v45 = 256;
        _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "invalid proposal number:%d received.\n", buf, 8u);
      }
    }
    int v16 = (unsigned __int8 **)v5[v13];
    if (v16[3])
    {
      if (dword_10008FA20)
      {
        int v17 = ne_log_obj();
        if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR)) {
          sub_100058D84();
        }
      }
    }
    else
    {
      uint64_t v21 = (void *)v3[v13];
      if (v21)
      {
        while (2)
        {
          int v22 = v21;
          while (v16[1][4] != *(unsigned __int8 *)(v22[1] + 4))
          {
            int v22 = (void *)v22[3];
            if (!v22)
            {
              if (!dword_10008FA20) {
                goto LABEL_33;
              }
              v37 = ne_log_obj();
              if (os_log_type_enabled(v37, OS_LOG_TYPE_ERROR)) {
                sub_100058D50();
              }
              goto LABEL_76;
            }
          }
          int v23 = *v16;
          uint64_t v24 = *v22;
          if ((*v16)[4] != *(unsigned __int8 *)(*v22 + 4) && dword_10008FA20 != 0)
          {
            long long v26 = ne_log_obj();
            BOOL v27 = os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT);
            int v23 = *v16;
            uint64_t v24 = *v22;
            if (v27)
            {
              int v28 = *(unsigned __int8 *)(v24 + 4);
              int v29 = v23[4];
              *(_DWORD *)buf = 67109376;
              int v45 = v28;
              __int16 v46 = 1024;
              int v47 = v29;
              _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "proposal #%d mismatched, expected #%d.\n", buf, 0xEu);
              int v23 = *v16;
              uint64_t v24 = *v22;
            }
          }
          if (v23[5] == *(unsigned __int8 *)(v24 + 5))
          {
            if (v23[7] != 1 && dword_10008FA20 != 0)
            {
              int v31 = ne_log_obj();
              if (os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT))
              {
                int v32 = (*v16)[7];
                *(_DWORD *)buf = 67109120;
                int v45 = v32;
                _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_DEFAULT, "#of transform is %d, but expected 1.\n", buf, 8u);
              }
            }
            if (v16[1][5] != *(unsigned __int8 *)(v22[1] + 5))
            {
              if (dword_10008FA20)
              {
                int v33 = ne_log_obj();
                if (os_log_type_enabled(v33, OS_LOG_TYPE_DEFAULT))
                {
                  *(_WORD *)buf = 0;
                  _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_DEFAULT, "transform number has been modified.\n", buf, 2u);
                }
              }
            }
            if (*((unsigned __int16 *)v16[1] + 3) != *(unsigned __int16 *)(v22[1] + 6))
            {
              if (dword_10008FA20)
              {
                char v34 = ne_log_obj();
                if (os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT))
                {
                  *(_WORD *)buf = 0;
                  _os_log_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_DEFAULT, "reserved field should be zero.\n", buf, 2u);
                }
              }
            }
            if (memcmp(v16[1] + 8, (const void *)(v22[1] + 8), (bswap32(*(unsigned __int16 *)(v22[1] + 2)) >> 16) - 8))
            {
              if (dword_10008FA20)
              {
                int v35 = ne_log_obj();
                if (os_log_type_enabled(v35, OS_LOG_TYPE_DEFAULT))
                {
                  *(_WORD *)buf = 0;
                  _os_log_impl((void *)&_mh_execute_header, v35, OS_LOG_TYPE_DEFAULT, "attribute has been modified.\n", buf, 2u);
                }
              }
            }
            int v16 = (unsigned __int8 **)v16[2];
            uint64_t v21 = (void *)v21[2];
            if (v16 && v21) {
              continue;
            }
            if ((v16 != 0) != (v21 != 0)) {
              goto LABEL_70;
            }
            char v40 = sub_10000C21C(a1, (uint64_t)v5);
            if (v40)
            {
              int v41 = v40;
              int v19 = *(void **)(a1 + 232);
              *(void *)(a1 + 232) = sub_10000C608(v40, *(void *)(a1 + 256));
              do
              {
                char v42 = v41;
                int v41 = (void *)v41[2];
                do
                {
                  v43 = (void *)v42[3];
                  free(v42);
                  char v42 = v43;
                }
                while (v43);
              }
              while (v41);
              if (*(void *)(a1 + 232)) {
                uint64_t v12 = 0;
              }
              else {
                uint64_t v12 = 0xFFFFFFFFLL;
              }
              goto LABEL_34;
            }
            goto LABEL_33;
          }
          break;
        }
        if (!dword_10008FA20) {
          goto LABEL_33;
        }
        int v39 = ne_log_obj();
        if (os_log_type_enabled(v39, OS_LOG_TYPE_ERROR)) {
          sub_100058CCC();
        }
      }
      else
      {
LABEL_70:
        if (!dword_10008FA20) {
          goto LABEL_33;
        }
        char v36 = ne_log_obj();
        if (os_log_type_enabled(v36, OS_LOG_TYPE_ERROR)) {
          sub_100058C98();
        }
      }
LABEL_76:
      if (dword_10008FA20)
      {
        char v38 = ne_log_obj();
        if (os_log_type_enabled(v38, OS_LOG_TYPE_ERROR)) {
          sub_100058C64();
        }
      }
    }
  }
  else if (v7)
  {
    if (dword_10008FA20)
    {
      uint64_t v18 = ne_log_obj();
      if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR)) {
        sub_100058BFC();
      }
    }
  }
  else if (dword_10008FA20)
  {
    uint64_t v9 = ne_log_obj();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR)) {
      sub_100058C30();
    }
  }
LABEL_33:
  int v19 = 0;
  uint64_t v12 = 0xFFFFFFFFLL;
LABEL_34:
  sub_10000AC28(v5);
  sub_10000AC28(v3);
  if (v19) {
    sub_10003FA78(v19);
  }
  return v12;
}

uint64_t sub_10000CD64(int a1, int a2)
{
  if ((a1 - 2) < 2)
  {
    if (a2 == 4) {
      return 0;
    }
    if (dword_10008FA20)
    {
      uint64_t v6 = ne_log_obj();
      if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR)) {
        sub_100058DB8();
      }
    }
    return 0xFFFFFFFFLL;
  }
  if (a1 == 4)
  {
    uint64_t result = 0;
    if (a2 == 2 || a2 == 4) {
      return result;
    }
    if (dword_10008FA20)
    {
      int v5 = ne_log_obj();
      if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR)) {
        sub_100058E20();
      }
    }
    return 0xFFFFFFFFLL;
  }
  if (a1 != 1) {
    return 0xFFFFFFFFLL;
  }
  uint64_t result = 0;
  if (a2)
  {
    if (dword_10008FA20)
    {
      uint64_t v3 = ne_log_obj();
      BOOL v4 = os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT);
      uint64_t result = 0;
      if (v4)
      {
        *(_WORD *)int v7 = 0;
        _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "SPI size isn't zero, but IKE proposal.\n", v7, 2u);
        return 0;
      }
    }
  }
  return result;
}

uint64_t sub_10000CE98(uint64_t a1)
{
  int v2 = sub_10000A3A8(*(unint64_t **)(a1 + 232), 1u);
  if (!v2) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v3 = v2;
  uint64_t v4 = 0;
  while (!v2[v4])
  {
    if (++v4 == 256) {
      goto LABEL_8;
    }
  }
  uint64_t v6 = (void *)v2[v4];
  if (!v6[3])
  {
    uint64_t v8 = *(void *)(a1 + 128);
    while (1)
    {
      uint64_t v9 = *(void *)(v8 + 32);
      if (!v9) {
        break;
      }
      while (*(_DWORD *)v9 != *(unsigned __int8 *)(*v6 + 5)
           || *(_DWORD *)(*(void *)(v9 + 64) + 4) != *(unsigned __int8 *)(v6[1] + 5))
      {
        uint64_t v9 = *(void *)(v9 + 72);
        if (!v9) {
          goto LABEL_8;
        }
      }
      memcpy((void *)(*v6 + 8), (const void *)(v9 - *(void *)(v9 + 8) + 28), *(void *)(v9 + 8));
      uint64_t v5 = 0;
      uint64_t v6 = (void *)v6[2];
      if (!v6) {
        goto LABEL_9;
      }
    }
  }
LABEL_8:
  uint64_t v5 = 0xFFFFFFFFLL;
LABEL_9:
  sub_10000AC28(v3);
  return v5;
}

void *sub_10000CF7C(int *a1, unint64_t *a2)
{
  uint64_t v3 = sub_10000A3A8(a2, 1u);
  if (v3)
  {
    uint64_t v4 = v3;
    uint64_t v5 = 0;
    signed int v6 = 8;
    if (a1)
    {
      int v7 = a1;
      while (*((void *)v3 + *v7))
      {
        for (uint64_t i = *((void *)v7 + 4); i; uint64_t i = *(void *)(i + 72))
        {
          v6 += *(_DWORD *)(i + 8) + 8;
          for (uint64_t j = *(void *)(i + 64); j; uint64_t j = *(void *)(j + 16))
          {
            uint64_t v5 = (const void **)*((void *)v3 + *v7);
            while (1)
            {
              int v10 = (unsigned __int8 *)v5[1];
              if (*(_DWORD *)j == v10[4]) {
                break;
              }
              uint64_t v5 = (const void **)v5[3];
              if (!v5) {
                goto LABEL_39;
              }
            }
            v6 += bswap32(*((unsigned __int16 *)v10 + 1)) >> 16;
          }
        }
        int v7 = (int *)*((void *)v7 + 5);
        if (!v7) {
          goto LABEL_14;
        }
      }
      goto LABEL_39;
    }
LABEL_14:
    uint64_t v11 = sub_10003F940(v6);
    if (!v11)
    {
      if (dword_10008FA20)
      {
        int v23 = ne_log_obj();
        if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR)) {
          sub_100058E88();
        }
      }
LABEL_39:
      uint64_t v12 = 0;
      goto LABEL_40;
    }
    uint64_t v12 = v11;
    uint64_t v13 = v11[1];
    *(_WORD *)(v13 + 2) = bswap32(v6) >> 16;
    if (!a1)
    {
LABEL_40:
      free(v4);
      return v12;
    }
    BOOL v14 = 0;
    size_t v15 = (unsigned char *)(v13 + 8);
    while (1)
    {
      uint64_t v16 = *((void *)a1 + 4);
      if (v16) {
        break;
      }
      uint64_t v18 = v14;
LABEL_32:
      a1 = (int *)*((void *)a1 + 5);
      BOOL v14 = v18;
      if (!a1) {
        goto LABEL_40;
      }
    }
    while (1)
    {
      uint64_t v17 = *(void *)(v16 + 64);
      if (v17) {
        break;
      }
      uint64_t v18 = v14;
LABEL_29:
      uint64_t v16 = *(void *)(v16 + 72);
      BOOL v14 = v18;
      if (!v16) {
        goto LABEL_32;
      }
    }
    uint64_t __n = *((unsigned __int8 *)*v5 + 6) + 8;
    while (1)
    {
      uint64_t v18 = v15;
      uint64_t v5 = (const void **)*((void *)v4 + *a1);
      if (!v5) {
        break;
      }
      while (1)
      {
        int v19 = (unsigned __int8 *)v5[1];
        if (*(_DWORD *)v17 == v19[4]) {
          break;
        }
        uint64_t v5 = (const void **)v5[3];
        if (!v5) {
          goto LABEL_34;
        }
      }
      unsigned int v20 = *((unsigned __int16 *)v19 + 1);
      if (v14) {
        unsigned char *v14 = 2;
      }
      size_t v21 = __rev16(v20);
      memcpy(v15, *v5, __n);
      unsigned char *v18 = 0;
      *((_WORD *)v18 + 1) = bswap32(v21 + __n) >> 16;
      v18[7] = 1;
      int v22 = &v18[__n];
      memcpy(&v18[__n], v5[1], v21);
      *int v22 = 0;
      *((_WORD *)v22 + 1) = v20;
      size_t v15 = &v18[__n + v21];
      BOOL v14 = v18;
      uint64_t v17 = *(void *)(v17 + 16);
      if (!v17) {
        goto LABEL_29;
      }
    }
LABEL_34:
    free(v4);
    sub_10003FA78(v12);
  }
  return 0;
}

uint64_t sub_10000D1C8(uint64_t a1)
{
  unsigned int v1 = bswap32(*(unsigned __int16 *)(a1 + 2)) >> 16;
  if (v1 < 9) {
    return 0;
  }
  int v2 = v1 - 8;
  uint64_t v3 = (unsigned __int16 *)(a1 + 8);
  while (2)
  {
    if (v2 <= 3)
    {
      if (dword_10008FA20)
      {
        size_t v15 = ne_log_obj();
        if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR)) {
          sub_100058EBC();
        }
      }
      return 0xFFFFFFFFLL;
    }
    int v4 = *v3;
    unsigned int v5 = bswap32(v4 & 0xFFFFFF7F) >> 16;
    int v6 = (v4 << 8) & 0x8000;
    unsigned int v7 = v3[1];
    uint64_t v8 = __rev16(v7);
    if (dword_10008FA20)
    {
      uint64_t v9 = ne_log_obj();
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
      {
        char v36 = sub_10003E928(v5);
        uint64_t v12 = sub_10003EC84(v5, v8);
        *(_DWORD *)buf = 136315650;
        char v38 = v36;
        __int16 v39 = 1024;
        int v40 = v6;
        __int16 v41 = 2080;
        char v42 = v12;
        _os_log_debug_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEBUG, "type=%s, flag=0x%04x, lorv=%s\n", buf, 0x1Cu);
      }
    }
    if (v5 > 0xF || ((1 << v5) & 0xE83E) == 0)
    {
      BOOL v11 = v6 == 0;
      if (!(v6 | v7))
      {
        if (dword_10008FA20)
        {
          int v19 = ne_log_obj();
          if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR)) {
            sub_100058F24(v5, v19, v20);
          }
        }
        return 0xFFFFFFFFLL;
      }
    }
    else
    {
      if (!v6)
      {
        if (dword_10008FA20)
        {
          uint64_t v16 = ne_log_obj();
          if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR)) {
            sub_100059440();
          }
        }
        return 0xFFFFFFFFLL;
      }
      BOOL v11 = 0;
    }
    switch(v5)
    {
      case 1u:
        if (sub_100003198(v8)) {
          goto LABEL_14;
        }
        if (dword_10008FA20)
        {
          int v30 = ne_log_obj();
          if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR)) {
            sub_100059008();
          }
        }
        return 0xFFFFFFFFLL;
      case 2u:
        if (sub_100002F14(v8)) {
          goto LABEL_14;
        }
        if (dword_10008FA20)
        {
          int v31 = ne_log_obj();
          if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR)) {
            sub_1000590DC();
          }
        }
        return 0xFFFFFFFFLL;
      case 3u:
        if ((int)v8 > 65000)
        {
          if ((v8 - 65001) > 9) {
            goto LABEL_84;
          }
          if (((1 << (v8 + 23)) & 0x13) == 0) {
            goto LABEL_43;
          }
          goto LABEL_14;
        }
        if (v8 <= 5)
        {
          if (((1 << v8) & 0xA) != 0) {
            goto LABEL_14;
          }
          if (((1 << v8) & 0x34) != 0) {
            goto LABEL_43;
          }
        }
        if (v8 == 64221)
        {
LABEL_14:
          v2 -= 4;
          if (v11)
          {
            v2 -= v8;
            if (v2 < 0)
            {
              if (dword_10008FA20)
              {
                uint64_t v17 = ne_log_obj();
                if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR)) {
                  sub_100059070();
                }
              }
              return 0xFFFFFFFFLL;
            }
            uint64_t v3 = (unsigned __int16 *)((char *)v3 + v8 + 4);
          }
          else
          {
            v3 += 2;
          }
          if (v2 <= 0) {
            return 0;
          }
          continue;
        }
        if ((v8 - 64222) >= 3)
        {
LABEL_84:
          if (dword_10008FA20)
          {
            int v35 = ne_log_obj();
            if (os_log_type_enabled(v35, OS_LOG_TYPE_ERROR)) {
              sub_100059144();
            }
          }
        }
        else
        {
LABEL_43:
          if (dword_10008FA20)
          {
            uint64_t v13 = ne_log_obj();
            if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR)) {
              sub_1000591AC(v8, v13);
            }
          }
        }
        return 0xFFFFFFFFLL;
      case 4u:
        if (sub_1000035DC(v8)) {
          goto LABEL_14;
        }
        if (dword_10008FA20)
        {
          int v32 = ne_log_obj();
          if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR)) {
            sub_10005922C();
          }
        }
        return 0xFFFFFFFFLL;
      case 5u:
        if (v7 == 256) {
          goto LABEL_14;
        }
        if (dword_10008FA20)
        {
          int v33 = ne_log_obj();
          if (os_log_type_enabled(v33, OS_LOG_TYPE_ERROR)) {
            sub_100059294();
          }
        }
        return 0xFFFFFFFFLL;
      case 6u:
      case 7u:
      case 0xCu:
      case 0xDu:
      case 0xEu:
      case 0x10u:
        goto LABEL_14;
      case 8u:
      case 9u:
      case 0xAu:
        if (dword_10008FA20)
        {
          uint64_t v18 = ne_log_obj();
          if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR)) {
            sub_1000592FC();
          }
        }
        return 0xFFFFFFFFLL;
      case 0xBu:
        if ((unsigned __int16)(v8 - 1) < 2u) {
          goto LABEL_14;
        }
        if (dword_10008FA20)
        {
          char v34 = ne_log_obj();
          if (os_log_type_enabled(v34, OS_LOG_TYPE_ERROR)) {
            sub_100059364();
          }
        }
        return 0xFFFFFFFFLL;
      case 0xFu:
        if (dword_10008FA20)
        {
          size_t v21 = ne_log_obj();
          if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR)) {
            sub_1000593CC(v21, v22, v23, v24, v25, v26, v27, v28);
          }
        }
        return 0xFFFFFFFFLL;
      default:
        if (v5 == 0x4000) {
          goto LABEL_14;
        }
        if (dword_10008FA20)
        {
          int v29 = ne_log_obj();
          if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR)) {
            sub_100058FA0();
          }
        }
        return 0xFFFFFFFFLL;
    }
  }
}

uint64_t sub_10000D724(int a1, uint64_t a2)
{
  unsigned int v4 = bswap32(*(unsigned __int16 *)(a2 + 2)) >> 16;
  long long v49 = 0u;
  long long v50 = 0u;
  long long v51 = 0u;
  long long v52 = 0u;
  if (v4 < 9)
  {
    BOOL v21 = 0;
    goto LABEL_54;
  }
  int v5 = v4 - 8;
  int v6 = (unsigned __int16 *)(a2 + 8);
  char v38 = (unsigned __int8 *)(a2 + 5);
  while (2)
  {
    if (v5 <= 3)
    {
      if (dword_10008FA20)
      {
        uint64_t v20 = ne_log_obj();
        if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR)) {
          sub_1000594A8();
        }
      }
      return 0xFFFFFFFFLL;
    }
    int v7 = *v6;
    unsigned int v8 = bswap32(v7 & 0xFFFFFF7F) >> 16;
    int v9 = (v7 << 8) & 0x8000;
    unsigned int v10 = v6[1];
    uint64_t v11 = __rev16(v10);
    if (dword_10008FA20)
    {
      uint64_t v12 = ne_log_obj();
      if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG))
      {
        int v37 = a1;
        size_t v15 = sub_10003E618(v8);
        uint64_t v16 = sub_10003E80C(v8, v11);
        *(_DWORD *)buf = 136315650;
        long long v44 = v15;
        a1 = v37;
        __int16 v45 = 1024;
        int v46 = v9;
        __int16 v47 = 2080;
        long long v48 = v16;
        _os_log_debug_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEBUG, "type=%s, flag=0x%04x, lorv=%s\n", buf, 0x1Cu);
      }
    }
    if (v8 <= 0xF) {
      ++*((_DWORD *)&v49 + v8);
    }
    switch(v8)
    {
      case 1u:
        if (!v9)
        {
          if (dword_10008FA20)
          {
            uint64_t v25 = ne_log_obj();
            if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR)) {
              sub_1000597C0();
            }
          }
          return 0xFFFFFFFFLL;
        }
        if ((unsigned __int16)(v11 - 1) >= 2u)
        {
          if (dword_10008FA20)
          {
            int v30 = ne_log_obj();
            if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR)) {
              sub_100059364();
            }
          }
          return 0xFFFFFFFFLL;
        }
        goto LABEL_33;
      case 2u:
        if (v9)
        {
          if (dword_10008FA20)
          {
            uint64_t v13 = ne_log_obj();
            if (os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG)) {
              sub_100059894(&v39, v40);
            }
          }
          goto LABEL_33;
        }
        if (!v10)
        {
          if (dword_10008FA20)
          {
            int v33 = ne_log_obj();
            if (os_log_type_enabled(v33, OS_LOG_TYPE_ERROR)) {
              sub_1000597F4();
            }
          }
          return 0xFFFFFFFFLL;
        }
        int v5 = v5 - v11 - 4;
        if (v5 < 0)
        {
          if (dword_10008FA20)
          {
            char v34 = ne_log_obj();
            if (os_log_type_enabled(v34, OS_LOG_TYPE_ERROR)) {
              sub_100059828();
            }
          }
          return 0xFFFFFFFFLL;
        }
        int v6 = (unsigned __int16 *)((char *)v6 + v11 + 4);
        goto LABEL_34;
      case 3u:
        if (!v9)
        {
          if (dword_10008FA20)
          {
            uint64_t v26 = ne_log_obj();
            if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR)) {
              sub_1000598C0();
            }
          }
          return 0xFFFFFFFFLL;
        }
        if (!sub_1000035DC(v11))
        {
          if (dword_10008FA20)
          {
            int v31 = ne_log_obj();
            if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR)) {
              sub_1000598F4();
            }
          }
          return 0xFFFFFFFFLL;
        }
LABEL_33:
        v5 -= 4;
        v6 += 2;
LABEL_34:
        if (v5 > 0) {
          continue;
        }
        BOOL v21 = DWORD1(v50) != 0;
LABEL_54:
        if (a1 == 2 && !v21)
        {
          if (dword_10008FA20)
          {
            uint64_t v18 = ne_log_obj();
            if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR)) {
              sub_1000595E0();
            }
          }
          return 0xFFFFFFFFLL;
        }
        if (a1 == 3)
        {
          if (*(unsigned char *)(a2 + 5) != 11) {
            BOOL v21 = 1;
          }
          if (!v21)
          {
            if (dword_10008FA20)
            {
              uint64_t v22 = ne_log_obj();
              if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR)) {
                sub_1000595AC();
              }
            }
            return 0xFFFFFFFFLL;
          }
        }
        return 0;
      case 4u:
        if (!v9)
        {
          if (dword_10008FA20)
          {
            uint64_t v27 = ne_log_obj();
            if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR)) {
              sub_100059510();
            }
          }
          return 0xFFFFFFFFLL;
        }
        if ((v11 - 1) < 2) {
          goto LABEL_33;
        }
        if ((v11 - 61443) >= 2 && (v11 - 3) > 1)
        {
          if (dword_10008FA20)
          {
            char v36 = ne_log_obj();
            if (os_log_type_enabled(v36, OS_LOG_TYPE_ERROR)) {
              sub_100059544();
            }
          }
          return 0xFFFFFFFFLL;
        }
        if (dword_10008FA20)
        {
          BOOL v14 = ne_log_obj();
          if (os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG)) {
            sub_100059614(&v41, v42);
          }
        }
        goto LABEL_33;
      case 5u:
        if (v9)
        {
          switch((int)v11)
          {
            case 1:
              if (a1 != 2 || *v38 == 2) {
                goto LABEL_33;
              }
              break;
            case 2:
              if (a1 != 2 || *v38 == 3) {
                goto LABEL_33;
              }
              break;
            case 3:
            case 4:
              if (dword_10008FA20)
              {
                int v32 = ne_log_obj();
                if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR)) {
                  sub_100059758();
                }
              }
              return 0xFFFFFFFFLL;
            case 5:
              if (a1 != 2 || *v38 == 5) {
                goto LABEL_33;
              }
              break;
            case 6:
              if (a1 != 2 || *v38 == 6) {
                goto LABEL_33;
              }
              break;
            case 7:
              if (a1 != 2 || *v38 == 7) {
                goto LABEL_33;
              }
              break;
            default:
              if (dword_10008FA20)
              {
                int v35 = ne_log_obj();
                if (os_log_type_enabled(v35, OS_LOG_TYPE_ERROR)) {
                  sub_100059674();
                }
              }
              return 0xFFFFFFFFLL;
          }
          if (dword_10008FA20)
          {
            uint64_t v17 = ne_log_obj();
            if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR)) {
              sub_1000596DC(v38, v11, v17);
            }
          }
        }
        else if (dword_10008FA20)
        {
          uint64_t v28 = ne_log_obj();
          if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR)) {
            sub_100059640();
          }
        }
        return 0xFFFFFFFFLL;
      case 6u:
        if (v9) {
          goto LABEL_33;
        }
        if (dword_10008FA20)
        {
          int v29 = ne_log_obj();
          if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR)) {
            sub_10005995C();
          }
        }
        return 0xFFFFFFFFLL;
      case 7u:
      case 8u:
      case 9u:
        if (dword_10008FA20)
        {
          uint64_t v23 = ne_log_obj();
          if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR)) {
            sub_1000592FC();
          }
        }
        return 0xFFFFFFFFLL;
      default:
        if (dword_10008FA20)
        {
          uint64_t v24 = ne_log_obj();
          if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR)) {
            sub_100058FA0();
          }
        }
        return 0xFFFFFFFFLL;
    }
  }
}

uint64_t sub_10000DE20(uint64_t a1)
{
  unsigned int v1 = bswap32(*(unsigned __int16 *)(a1 + 2)) >> 16;
  memset(v42, 0, sizeof(v42));
  if (v1 < 9) {
    return 0;
  }
  int v2 = v1 - 8;
  uint64_t v3 = (unsigned __int16 *)(a1 + 8);
  while (v2 > 3)
  {
    int v4 = *v3;
    unsigned int v5 = bswap32(v4 & 0xFFFFFF7F) >> 16;
    int v6 = (v4 << 8) & 0x8000;
    unsigned int v7 = v3[1];
    unsigned int v8 = __rev16(v7);
    if (dword_10008FA20)
    {
      int v9 = ne_log_obj();
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 67109632;
        unsigned int v37 = v5;
        __int16 v38 = 1024;
        int v39 = v6;
        __int16 v40 = 1024;
        unsigned int v41 = v8;
        _os_log_debug_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEBUG, "type=%d, flag=0x%04x, lorv=0x%04x\n", buf, 0x14u);
      }
    }
    if (v5 <= 0xF) {
      ++*((_DWORD *)v42 + v5);
    }
    switch(v5)
    {
      case 1u:
        if (!v6)
        {
          if (dword_10008FA20)
          {
            uint64_t v24 = ne_log_obj();
            if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR)) {
              sub_1000597C0();
            }
          }
          return 0xFFFFFFFFLL;
        }
        if ((unsigned __int16)(v8 - 1) >= 2u)
        {
          if (dword_10008FA20)
          {
            uint64_t v27 = ne_log_obj();
            if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR)) {
              sub_100059364();
            }
          }
          return 0xFFFFFFFFLL;
        }
        goto LABEL_27;
      case 2u:
        if (v6)
        {
          if (dword_10008FA20)
          {
            unsigned int v10 = ne_log_obj();
            if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG)) {
              sub_100059894(&v32, v33);
            }
          }
          goto LABEL_27;
        }
        if (!v7)
        {
          if (dword_10008FA20)
          {
            int v29 = ne_log_obj();
            if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR)) {
              sub_1000597F4();
            }
          }
          return 0xFFFFFFFFLL;
        }
        int v2 = v2 - v8 - 4;
        if (v2 < 0)
        {
          if (dword_10008FA20)
          {
            int v30 = ne_log_obj();
            if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR)) {
              sub_1000599F8();
            }
          }
          return 0xFFFFFFFFLL;
        }
        uint64_t v3 = (unsigned __int16 *)((char *)v3 + v8 + 4);
        goto LABEL_28;
      case 3u:
        if (!v6)
        {
          if (dword_10008FA20)
          {
            uint64_t v25 = ne_log_obj();
            if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR)) {
              sub_1000598C0();
            }
          }
          return 0xFFFFFFFFLL;
        }
        if (!sub_1000035DC(v8))
        {
          if (dword_10008FA20)
          {
            uint64_t v28 = ne_log_obj();
            if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR)) {
              sub_1000598F4();
            }
          }
          return 0xFFFFFFFFLL;
        }
        goto LABEL_27;
      case 4u:
        if (!v6)
        {
          if (dword_10008FA20)
          {
            uint64_t v26 = ne_log_obj();
            if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR)) {
              sub_100059510();
            }
          }
          return 0xFFFFFFFFLL;
        }
        if (v8 - 1 >= 2)
        {
          if (v8 - 61443 >= 2 && v8 - 3 > 1)
          {
            if (dword_10008FA20)
            {
              int v31 = ne_log_obj();
              if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR)) {
                sub_100059544();
              }
            }
            return 0xFFFFFFFFLL;
          }
          if (dword_10008FA20)
          {
            uint64_t v11 = ne_log_obj();
            if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG)) {
              sub_100059614(&v34, v35);
            }
          }
        }
LABEL_27:
        v2 -= 4;
        v3 += 2;
LABEL_28:
        if (v2 <= 0) {
          return 0;
        }
        break;
      case 5u:
        if (dword_10008FA20)
        {
          uint64_t v16 = ne_log_obj();
          if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR)) {
            sub_100059A64(v16, v17, v18, v19, v20, v21, v22, v23);
          }
        }
        return 0xFFFFFFFFLL;
      case 6u:
      case 7u:
      case 8u:
      case 9u:
        if (dword_10008FA20)
        {
          BOOL v14 = ne_log_obj();
          if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR)) {
            sub_1000592FC();
          }
        }
        return 0xFFFFFFFFLL;
      default:
        if (dword_10008FA20)
        {
          size_t v15 = ne_log_obj();
          if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR)) {
            sub_100058FA0();
          }
        }
        return 0xFFFFFFFFLL;
    }
  }
  if (dword_10008FA20)
  {
    uint64_t v13 = ne_log_obj();
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR)) {
      sub_100059990();
    }
  }
  return 0xFFFFFFFFLL;
}

void *sub_10000E2C8(uint64_t a1)
{
  if (!a1) {
    return 0;
  }
  uint64_t v2 = *(void *)(*(void *)(a1 + 64) + 248);
  int v3 = *(unsigned __int8 *)(a1 + 80);
  int v4 = sub_10000E384(a1, 0);
  unsigned int v5 = sub_10003F940(v4 + 8 * (v3 == 16));
  if (!v5)
  {
    if (dword_10008FA20)
    {
      unsigned int v8 = ne_log_obj();
      if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR)) {
        sub_100059AD8();
      }
    }
    return 0;
  }
  int v6 = v5;
  if (v3 == 16)
  {
    unsigned int v7 = (int8x8_t *)v5[1];
    int8x8_t *v7 = vrev32_s8(*(int8x8_t *)(*(void *)(v2 + 88) + 24));
    sub_10000E384(a1, (uint64_t)&v7[1]);
  }
  return v6;
}

uint64_t sub_10000E384(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(*(void *)(a1 + 64) + 248);
  if (a2)
  {
    *(_WORD *)a2 = 0;
    *(unsigned char *)(a2 + 4) = *(_DWORD *)(v3 + 4);
    *(_WORD *)(a2 + 5) = 1;
    uint64_t v4 = a2 + 8;
  }
  else
  {
    if (!v3) {
      return 8;
    }
    uint64_t v4 = 0;
  }
  char v5 = 0;
  int v6 = 0;
  char v30 = a2 != 0;
  LODWORD(v7) = 8;
  do
  {
    if (v6) {
      *int v6 = 3;
    }
    if (v4)
    {
      *(unsigned char *)uint64_t v4 = 0;
      *(unsigned char *)(v4 + 4) = *(_DWORD *)(v3 + 8);
      *(unsigned char *)(v4 + 5) = 1;
      unsigned int v8 = (_WORD *)(v4 + 8);
    }
    else
    {
      unsigned int v8 = 0;
    }
    uint64_t v9 = *(void *)(v3 + 16);
    if (v9)
    {
      unsigned int __src = bswap32(v9);
      if (v9 < 0x10000) {
        int v10 = 8;
      }
      else {
        int v10 = 12;
      }
      if (v8)
      {
        uint64_t v11 = sub_100025E18(v8, 11, 1u);
        uint64_t v12 = *(void *)(v3 + 16);
        if (v12 < 0x10000) {
          uint64_t v13 = (uint64_t)sub_100025E18(v11, 12, v12);
        }
        else {
          uint64_t v13 = sub_100025DC4(v11, 0xCu, &__src, 4);
        }
        BOOL v14 = (_WORD *)v13;
      }
      else
      {
        BOOL v14 = 0;
      }
    }
    else
    {
      int v10 = 0;
      BOOL v14 = v8;
    }
    unint64_t v15 = *(void *)(v3 + 32);
    if (v15)
    {
      unsigned int v31 = bswap32(v15);
      if (v15 >> 16) {
        int v16 = 12;
      }
      else {
        int v16 = 8;
      }
      if (v8)
      {
        uint64_t v17 = sub_100025E18(v14, 11, 2u);
        unint64_t v18 = *(void *)(v3 + 32);
        if (v18 < 0x10000) {
          uint64_t v19 = (uint64_t)sub_100025E18(v17, 12, v18);
        }
        else {
          uint64_t v19 = sub_100025DC4(v17, 0xCu, &v31, 4);
        }
        BOOL v14 = (_WORD *)v19;
      }
      v10 += v16;
    }
    unsigned int v20 = *(_DWORD *)(v3 + 40);
    if (v20)
    {
      if (!v8)
      {
        if (*(_DWORD *)(v3 + 44)) {
          v10 += 8;
        }
        else {
          v10 += 4;
        }
        goto LABEL_41;
      }
      BOOL v14 = sub_100025E18(v14, 1, v20);
      v10 += 4;
    }
    unsigned int v21 = *(_DWORD *)(v3 + 44);
    if (v21)
    {
      v10 += 4;
      if (v8) {
        BOOL v14 = sub_100025E18(v14, 14, v21);
      }
    }
LABEL_41:
    uint64_t v22 = *(unsigned int *)(v3 + 48);
    if (v22)
    {
      if (!v8)
      {
        if (*(_DWORD *)(v3 + 52)) {
          v10 += 8;
        }
        else {
          v10 += 4;
        }
        goto LABEL_50;
      }
      unsigned int v23 = sub_10000BB7C(v22);
      BOOL v14 = sub_100025E18(v14, 3, v23);
      v10 += 4;
    }
    unsigned int v24 = *(_DWORD *)(v3 + 52);
    if (v24)
    {
      v10 += 4;
      if (v8) {
        BOOL v14 = sub_100025E18(v14, 2, v24);
      }
    }
LABEL_50:
    unsigned int v25 = *(_DWORD *)(v3 + 60);
    if (v25 > 0x12) {
      goto LABEL_55;
    }
    if (((1 << v25) & 0x7C026) != 0)
    {
      v10 += 4;
      if (!v8) {
        goto LABEL_55;
      }
      uint64_t v26 = v14;
      int v27 = 4;
      goto LABEL_54;
    }
    if (((1 << v25) & 0x18) != 0)
    {
      v10 += 4;
      if (v8)
      {
        uint64_t v26 = v14;
        int v27 = 5;
        unsigned int v25 = 3;
LABEL_54:
        sub_100025E18(v26, v27, v25);
      }
    }
LABEL_55:
    uint64_t v28 = (v10 + 8);
    if (v4) {
      *(_WORD *)(v4 + 2) = __rev16(v28);
    }
    uint64_t v7 = (v28 + v7);
    if (a2) {
      int v6 = (unsigned char *)v4;
    }
    v5 += v30;
    if (!a2) {
      uint64_t v28 = 0;
    }
    v4 += v28;
    uint64_t v3 = *(void *)(v3 + 80);
  }
  while (v3);
  if (a2)
  {
    *(_WORD *)(a2 + 2) = bswap32(v7) >> 16;
    *(unsigned char *)(a2 + 7) = v5;
  }
  return v7;
}

uint64_t sub_10000E688(uint64_t a1, int a2)
{
  int v2 = a2;
  uint64_t v4 = 128;
  if (!a2) {
    uint64_t v4 = 120;
  }
  uint64_t v5 = *(void *)(a1 + v4);
  if (*(unsigned char *)(a1 + 61) == 16)
  {
    int v6 = (void **)sub_10003F940(8uLL);
    if (!v6)
    {
      if (dword_10008FA20)
      {
        __int16 v47 = ne_log_obj();
        if (os_log_type_enabled(v47, OS_LOG_TYPE_ERROR)) {
          sub_100059AD8();
        }
      }
      return 0xFFFFFFFFLL;
    }
    uint64_t v7 = v6;
    *(void *)v6[1] = 0x100000001000000;
    if (!v5) {
      goto LABEL_86;
    }
  }
  else
  {
    uint64_t v7 = 0;
    if (!v5)
    {
LABEL_86:
      uint64_t result = 0;
      if (v2) {
        *(void *)(a1 + 232) = v7;
      }
      else {
        *(void *)(a1 + 224) = v7;
      }
      return result;
    }
  }
  int64_t v55 = 0;
  int v54 = v2;
LABEL_9:
  unsigned int v8 = *(int **)(v5 + 32);
  if (!v8) {
    goto LABEL_85;
  }
LABEL_10:
  if (*v8 == 4) {
    goto LABEL_84;
  }
  __int16 v56 = v7;
  if ((*(unsigned char *)(*(void *)(a1 + 256) + 96) & 6) == 0)
  {
    if (*(unsigned char *)(a1 + 61) != 16) {
      goto LABEL_105;
    }
    goto LABEL_18;
  }
  if (dword_10008FA20)
  {
    uint64_t v9 = ne_log_obj();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "NAT detected -> UDP encapsulation\n", buf, 2u);
    }
  }
  v8[5] = 1;
  if (*(unsigned char *)(a1 + 61) == 16)
  {
    v8[4] += *(unsigned __int16 *)(*(void *)(*(void *)(a1 + 256) + 88) + 12);
LABEL_18:
    int v10 = (void **)sub_10003F940(0xCuLL);
    if (!v10) {
      goto LABEL_99;
    }
    uint64_t v11 = v10;
    uint64_t v12 = (char *)v10[1];
    char *v12 = 0;
    v12[4] = *(_DWORD *)v5;
    int v13 = *v8;
    v12[5] = *v8;
    v12[7] = 1;
    if (v13 == 4)
    {
      BOOL v14 = (char *)v8 + 26;
      NSObject *v10 = (char *)*v10 - 2;
      size_t v15 = 2;
    }
    else
    {
      BOOL v14 = v8 + 6;
      size_t v15 = 4;
    }
    v12[6] = v15;
    memcpy(v12 + 8, v14, v15);
    uint64_t v16 = *((void *)v8 + 8);
    if (!v16)
    {
LABEL_102:
      if (dword_10008FA20)
      {
        long long v51 = ne_log_obj();
        if (os_log_type_enabled(v51, OS_LOG_TYPE_ERROR)) {
          sub_100059B0C();
        }
      }
      goto LABEL_99;
    }
    uint64_t v17 = 0;
    uint64_t v18 = v15 | 8;
    while (*v8 == 3 && *(_DWORD *)(v16 + 4) == 11 && *(_DWORD *)(v16 + 12) == 254)
    {
LABEL_74:
      uint64_t v16 = *(void *)(v16 + 16);
      if (!v16)
      {
        if (!v17) {
          goto LABEL_102;
        }
        size_t v44 = (size_t)*v11;
        *((_WORD *)v12 + 1) = bswap32(*v11) >> 16;
        if (v56) {
          __int16 v45 = sub_10003F9BC(v56, (size_t)*v56 + v44);
        }
        else {
          __int16 v45 = (void **)sub_10003F940(v44);
        }
        uint64_t v7 = v45;
        int v2 = v54;
        if (!v45)
        {
          if (dword_10008FA20)
          {
            int v53 = ne_log_obj();
            if (os_log_type_enabled(v53, OS_LOG_TYPE_ERROR)) {
              sub_100059AD8();
            }
          }
          long long v50 = v11;
          goto LABEL_100;
        }
        memcpy((void *)((char *)*v45 + (void)v45[1] - (char *)*v11), v11[1], (size_t)*v11);
        if (v55 && *(unsigned char *)(a1 + 61) == 16) {
          *((unsigned char *)v7[1] + v55) = 2;
        }
        int64_t v55 = (unsigned char *)*v7 - (unsigned char *)*v11;
        sub_10003FA78(v11);
LABEL_84:
        unsigned int v8 = (int *)*((void *)v8 + 9);
        if (!v8)
        {
LABEL_85:
          uint64_t v5 = *(void *)(v5 + 40);
          if (!v5) {
            goto LABEL_86;
          }
          goto LABEL_9;
        }
        goto LABEL_10;
      }
    }
    if (v17)
    {
      *(unsigned char *)uint64_t v17 = 3;
      ++v12[7];
    }
    uint64_t v19 = *(void *)(v5 + 8);
    if (v19 < 0x10000) {
      int v20 = 8;
    }
    else {
      int v20 = 12;
    }
    if (v19) {
      int v21 = v20;
    }
    else {
      int v21 = 0;
    }
    int v22 = *(_DWORD *)(v5 + 16);
    if (v22)
    {
      int v23 = v22 < 0x10000 ? 8 : 12;
      int v24 = v21 + v23;
      if (v22 != 0x7FFFFFFF) {
        int v21 = v24;
      }
    }
    if (*(_DWORD *)(v16 + 8)) {
      int v25 = 8;
    }
    else {
      int v25 = 4;
    }
    unsigned int v26 = v25 + v21;
    int v27 = *v8;
    if (*v8 == 2)
    {
      if (*(_DWORD *)(v16 + 12) == 254)
      {
        if (dword_10008FA20)
        {
          long long v49 = ne_log_obj();
          if (os_log_type_enabled(v49, OS_LOG_TYPE_ERROR)) {
            sub_100059BAC();
          }
        }
        goto LABEL_98;
      }
      v26 += 4;
    }
    else if (v27 != 4)
    {
      if (v27 != 3)
      {
        if (dword_10008FA20)
        {
          long long v48 = ne_log_obj();
          if (os_log_type_enabled(v48, OS_LOG_TYPE_ERROR)) {
            sub_100059B40();
          }
        }
LABEL_98:
        sub_10003FA78(v11);
        goto LABEL_99;
      }
      if (*(_DWORD *)(v16 + 12) != 254) {
        v26 += 4;
      }
    }
    BOOL v28 = sub_1000035DC(*(_DWORD *)(*(void *)(a1 + 112) + 36));
    LODWORD(v29) = v26 + 4;
    if (v28) {
      uint64_t v29 = v29;
    }
    else {
      uint64_t v29 = v26;
    }
    uint64_t v30 = v29 + 8;
    unsigned int v31 = sub_10003F9BC(v11, (size_t)*v11 + v29 + 8);
    if (!v31) {
      goto LABEL_99;
    }
    uint64_t v11 = v31;
    uint64_t v12 = (char *)v31[1];
    char v32 = &v12[v18];
    char *v32 = 0;
    int v33 = *(_DWORD *)(v16 + 4);
    v32[4] = *(_DWORD *)v16;
    v32[5] = v33;
    char v34 = &v12[v18 + 8];
    if (*(void *)(v5 + 8))
    {
      int v35 = sub_100025E18(v34, 1, 1u);
      uint64_t v36 = *(void *)(v5 + 8);
      if (v36 < 0x10000)
      {
        char v34 = (char *)sub_100025E18(v35, 2, v36);
      }
      else
      {
        unsigned int __src = bswap32(v36);
        char v34 = (char *)sub_100025DC4(v35, 2u, &__src, 4);
      }
    }
    int v37 = *(_DWORD *)(v5 + 16);
    if (v37 && v37 != 0x7FFFFFFF)
    {
      __int16 v38 = sub_100025E18(v34, 1, 2u);
      signed int v39 = *(_DWORD *)(v5 + 16);
      if (v39 < 0x10000)
      {
        char v34 = (char *)sub_100025E18(v38, 2, v39);
      }
      else
      {
        unsigned int v58 = bswap32(v39);
        char v34 = (char *)sub_100025DC4(v38, 2u, &v58, 4);
      }
    }
    __int16 v40 = sub_100025E18(v34, 4, v8[4]);
    unsigned int v41 = v40;
    unsigned int v42 = *(_DWORD *)(v16 + 8);
    if (v42) {
      unsigned int v41 = sub_100025E18(v40, 6, v42);
    }
    if (*v8 == 3)
    {
      unsigned int v43 = *(_DWORD *)(v16 + 12);
      if (v43 != 254) {
        goto LABEL_70;
      }
    }
    else if (*v8 == 2)
    {
      unsigned int v43 = *(_DWORD *)(v16 + 12);
LABEL_70:
      unsigned int v41 = sub_100025E18(v41, 5, v43);
    }
    if (sub_1000035DC(*(_DWORD *)(*(void *)(a1 + 112) + 36))) {
      sub_100025E18(v41, 3, *(_DWORD *)(*(void *)(a1 + 112) + 36));
    }
    uint64_t v17 = (uint64_t)v11[1] + v18;
    *(_WORD *)(v17 + 2) = __rev16(v30);
    v18 += v30;
    goto LABEL_74;
  }
LABEL_105:
  if (dword_10008FA20)
  {
    long long v52 = ne_log_obj();
    if (os_log_type_enabled(v52, OS_LOG_TYPE_ERROR)) {
      sub_100059BE0();
    }
  }
LABEL_99:
  long long v50 = v56;
  if (v56) {
LABEL_100:
  }
    sub_10003FA78(v50);
  return 0xFFFFFFFFLL;
}

uint64_t sub_10000EC9C(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 120);
  if (!v1) {
    return 1;
  }
  while (1)
  {
    uint64_t v2 = *(void *)(v1 + 32);
    if (v2) {
      break;
    }
LABEL_12:
    uint64_t v1 = *(void *)(v1 + 40);
    if (!v1) {
      return 1;
    }
  }
  while (1)
  {
    int v3 = *(_DWORD *)(v2 + 16);
    BOOL v4 = v3 == 1 || v3 == 61443;
    if (!v4 && v3 != 3) {
      return 0;
    }
    uint64_t v2 = *(void *)(v2 + 72);
    if (!v2) {
      goto LABEL_12;
    }
  }
}

uint64_t sub_10000ECE4(uint64_t result)
{
  if (result)
  {
    while (1)
    {
      uint64_t v1 = *(void *)(result + 32);
      if (v1) {
        break;
      }
LABEL_11:
      uint64_t result = *(void *)(result + 40);
      if (!result) {
        return result;
      }
    }
    while (1)
    {
      int v2 = *(_DWORD *)(v1 + 16);
      BOOL v3 = v2 == 2 || v2 == 4;
      if (v3 || v2 == 61444) {
        return 1;
      }
      uint64_t v1 = *(void *)(v1 + 72);
      if (!v1) {
        goto LABEL_11;
      }
    }
  }
  return result;
}

uint64_t sub_10000ED24(uint64_t a1)
{
  if (!a1) {
    return 1;
  }
  while (1)
  {
    uint64_t v1 = *(void *)(a1 + 32);
    if (v1) {
      break;
    }
LABEL_5:
    a1 = *(void *)(a1 + 40);
    if (!a1) {
      return 1;
    }
  }
  while (*(_DWORD *)(v1 + 16) == 2)
  {
    uint64_t v1 = *(void *)(v1 + 72);
    if (!v1) {
      goto LABEL_5;
    }
  }
  return 0;
}

uint64_t sub_10000ED5C()
{
  return 28800;
}

uint64_t sub_10000ED64(int a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a1 == 2)
  {
    if (!a3 || a4 | a2)
    {
      if (!dword_10008FA20) {
        return 0xFFFFFFFFLL;
      }
      uint64_t v7 = ne_log_obj();
      if (!os_log_type_enabled(v7, OS_LOG_TYPE_ERROR)) {
        return 0xFFFFFFFFLL;
      }
      int v11 = 136315650;
      uint64_t v12 = sub_10003EE1C(0, a2);
      __int16 v13 = 2080;
      BOOL v14 = sub_10003EE1C(1, a3);
      __int16 v15 = 2080;
      uint64_t v16 = sub_10003EE1C(2, a4);
      unsigned int v8 = "illegal algorithm defined AH enc=%s auth=%s comp=%s.\n";
      goto LABEL_25;
    }
    return 0;
  }
  if (a1 == 4)
  {
    if (a3 | a2 || !a4)
    {
      if (!dword_10008FA20) {
        return 0xFFFFFFFFLL;
      }
      uint64_t v7 = ne_log_obj();
      if (!os_log_type_enabled(v7, OS_LOG_TYPE_ERROR)) {
        return 0xFFFFFFFFLL;
      }
      int v11 = 136315650;
      uint64_t v12 = sub_10003EE1C(0, a2);
      __int16 v13 = 2080;
      BOOL v14 = sub_10003EE1C(1, a3);
      __int16 v15 = 2080;
      uint64_t v16 = sub_10003EE1C(2, a4);
      unsigned int v8 = "illegal algorithm defined IPcomp enc=%s auth=%s comp=%s.\n";
      goto LABEL_25;
    }
    return 0;
  }
  if (a1 != 3)
  {
    if (dword_10008FA20)
    {
      int v10 = ne_log_obj();
      if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR)) {
        sub_100059C14();
      }
    }
    return 0xFFFFFFFFLL;
  }
  if (a2 && !a4) {
    return 0;
  }
  if (!dword_10008FA20) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v7 = ne_log_obj();
  if (!os_log_type_enabled(v7, OS_LOG_TYPE_ERROR)) {
    return 0xFFFFFFFFLL;
  }
  int v11 = 136315650;
  uint64_t v12 = sub_10003EE1C(0, a2);
  __int16 v13 = 2080;
  BOOL v14 = sub_10003EE1C(1, a3);
  __int16 v15 = 2080;
  uint64_t v16 = sub_10003EE1C(2, a4);
  unsigned int v8 = "illegal algorithm defined ESP enc=%s auth=%s comp=%s.\n";
LABEL_25:
  _os_log_error_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, v8, (uint8_t *)&v11, 0x20u);
  return 0xFFFFFFFFLL;
}

uint64_t sub_10000EFF0(int a1)
{
  if (a1 == 50) {
    int v1 = 3;
  }
  else {
    int v1 = -1;
  }
  if (a1 == 51) {
    unsigned int v2 = 2;
  }
  else {
    unsigned int v2 = v1;
  }
  if (a1 == 108) {
    return 4;
  }
  else {
    return v2;
  }
}

uint64_t sub_10000F01C(int a1)
{
  if ((a1 - 2) > 2) {
    return 0xFFFFFFFFLL;
  }
  else {
    return dword_10006E4F0[a1 - 2];
  }
}

uint64_t sub_10000F040(void *a1, uint64_t a2)
{
  if (*(void *)a2 != 4) {
    return 1;
  }
  if (*a1 != 8) {
    return 1;
  }
  unsigned int v2 = (unsigned int *)a1[1];
  if (v2[1] != -1) {
    return 1;
  }
  unsigned int v4 = bswap32(*v2);
  unsigned int v5 = bswap32(**(_DWORD **)(a2 + 8));
  BOOL v6 = v4 >= v5;
  BOOL v7 = v4 > v5;
  int v8 = !v6;
  return (v7 - v8);
}

uint64_t sub_10000F098(void *a1, void *a2)
{
  if (*a2 == 16 && *a1 == 32)
  {
    unsigned int v2 = (unint64_t *)a1[1];
    uint64_t v3 = 16;
    while (*((unsigned __int8 *)v2 + v3) == 255)
    {
      if (++v3 == 32)
      {
        unsigned int v4 = (unint64_t *)a2[1];
        unint64_t v5 = bswap64(*v2);
        unint64_t v6 = bswap64(*v4);
        if (v5 == v6)
        {
          unint64_t v5 = bswap64(v2[1]);
          unint64_t v6 = bswap64(v4[1]);
          if (v5 == v6) {
            return 0;
          }
        }
        if (v5 < v6) {
          return 0xFFFFFFFFLL;
        }
        return 1;
      }
    }
  }
  return 1;
}

uint64_t sub_10000F124(uint64_t a1)
{
  int v1 = *(void **)(a1 + 320);
  if (!v1)
  {
    if (dword_10008FA20)
    {
      unint64_t v5 = ne_log_obj();
      if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR)) {
        sub_100059C7C();
      }
    }
    return 0xFFFFFFFFLL;
  }
  uint64_t v3 = (void **)(a1 + 320);
  if (*v1 <= 3uLL)
  {
    if (dword_10008FA20)
    {
      unsigned int v4 = ne_log_obj();
      if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR)) {
        sub_100059CB0();
      }
    }
    return 18;
  }
  BOOL v7 = (unsigned __int8 *)v1[1];
  if (*(unsigned char *)(a1 + 80) == 16
    && *(unsigned char *)(a1 + 81) == 2
    && *(_DWORD *)(*(void *)(a1 + 72) + 48) == 1
    && (*(unsigned char *)(a1 + 96) & 4) == 0)
  {
    unsigned int v8 = *v7;
    if ((v8 | 4) != 5)
    {
      if (dword_10008FA20)
      {
        uint64_t v9 = ne_log_obj();
        if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR)) {
          sub_100059D1C(v7, v9);
        }
      }
      return 18;
    }
  }
  else
  {
    unsigned int v8 = *v7;
  }
  if (v8 <= 8 && ((1 << v8) & 0x1D0) != 0)
  {
    if (dword_10008FA20)
    {
      int v11 = ne_log_obj();
      BOOL v12 = os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT);
      unsigned int v8 = *v7;
      if (v12)
      {
        *(_DWORD *)buf = 136315138;
        *(void *)&uint8_t buf[4] = sub_10003E8B0(v8);
        _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "such ID type %s is not proper.\n", buf, 0xCu);
        unsigned int v8 = *v7;
      }
    }
  }
  if ((v8 | 4) == 5)
  {
    if (v7[1] == 17)
    {
      unsigned int v18 = *((unsigned __int16 *)v7 + 1);
      if (v18 == 62465) {
        goto LABEL_48;
      }
      uint64_t v19 = *(void *)(a1 + 48);
      int v20 = *(unsigned __int8 *)(v19 + 1);
      if (v20 != 30 && v20 != 2)
      {
        if (dword_10008FA20)
        {
          signed int v39 = ne_log_obj();
          if (os_log_type_enabled(v39, OS_LOG_TYPE_ERROR)) {
            sub_100059DD8();
          }
        }
        return 18;
      }
      int v22 = *(unsigned __int16 *)(v19 + 2);
      if (__rev16(v18) == v22 || dword_10008FA20 == 0) {
        goto LABEL_48;
      }
      BOOL v14 = ne_log_obj();
      if (!os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_48;
      }
      unsigned int v24 = bswap32(*((unsigned __int16 *)v7 + 1)) >> 16;
      *(_DWORD *)buf = 67109376;
      *(_DWORD *)&uint8_t buf[4] = v22;
      *(_WORD *)&uint8_t buf[8] = 1024;
      *(_DWORD *)&buf[10] = v24;
      uint64_t v17 = "port %d expected, but %d\n";
      goto LABEL_47;
    }
    if (!v7[1] && *((_WORD *)v7 + 1) && dword_10008FA20 != 0)
    {
      BOOL v14 = ne_log_obj();
      if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
      {
        int v15 = v7[1];
        unsigned int v16 = bswap32(*((unsigned __int16 *)v7 + 1)) >> 16;
        *(_DWORD *)buf = 67109376;
        *(_DWORD *)&uint8_t buf[4] = v15;
        *(_WORD *)&uint8_t buf[8] = 1024;
        *(_DWORD *)&buf[10] = v16;
        uint64_t v17 = "protocol ID and Port mismatched. proto_id:%d port:%d\n";
LABEL_47:
        _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, v17, buf, 0xEu);
      }
    }
  }
LABEL_48:
  uint64_t result = sub_1000061E0(*(void **)(*(void *)(a1 + 64) + 56), 0);
  if (result)
  {
    *(void *)buf = 0;
    uint64_t v25 = sub_1000061E0(*(void **)(*(void *)(a1 + 64) + 56), buf);
    if (v25)
    {
      unsigned int v26 = (int *)v25;
      int v27 = 0;
      BOOL v28 = v7 + 4;
      do
      {
        int v29 = *v26;
        if (v29 == sub_10000F63C(*v7))
        {
          uint64_t v30 = *((void *)v26 + 1);
          if (!v30) {
            goto LABEL_84;
          }
          if (!v27
            || (sub_10003FA78(v27), (uint64_t v30 = *((void *)v26 + 1)) != 0)
            || (v31 = *v26, (uint64_t v30 = *(void *)(qword_10008F848 + 8 * v31 + 176)) != 0))
          {
            int v27 = sub_10003FAC0(v30);
            LODWORD(v31) = *v26;
          }
          else
          {
            int v27 = 0;
          }
          if (v31 == 4)
          {
            size_t v32 = v27[1];
            int v33 = *(unsigned __int8 *)(v32 + 1);
            if (v33 == 30)
            {
              if (**v3 == 20)
              {
                uint64_t v35 = *(void *)(v32 + 8);
                uint64_t v34 = *(void *)(v32 + 16);
                if (v35 == *v28 && v34 == *(void *)(v7 + 12)) {
                  goto LABEL_85;
                }
              }
            }
            else if (v33 == 2 && **v3 == 8 && *(_DWORD *)(v32 + 4) == *(_DWORD *)v28)
            {
              goto LABEL_85;
            }
          }
          else
          {
            if (v31 == 5)
            {
              if (dword_10008FA20)
              {
                __int16 v38 = ne_log_obj();
                if (os_log_type_enabled(v38, OS_LOG_TYPE_DEFAULT))
                {
                  v40[0] = 0;
                  _os_log_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_DEFAULT, "ASN1DN ID matching not implemented - passed.\n", (uint8_t *)v40, 2u);
                }
              }
LABEL_84:
              if (!v27) {
                return 0;
              }
LABEL_85:
              sub_10003FA78(v27);
              return 0;
            }
            if (!memcmp((const void *)v27[1], v7 + 4, *v27)) {
              goto LABEL_85;
            }
          }
        }
        unsigned int v26 = (int *)sub_1000061E0(0, buf);
      }
      while (v26);
      if (v27) {
        sub_10003FA78(v27);
      }
    }
    if (dword_10008FA20)
    {
      int v37 = ne_log_obj();
      if (os_log_type_enabled(v37, OS_LOG_TYPE_DEBUG)) {
        sub_100059DA0();
      }
    }
    if (*(_DWORD *)(*(void *)(a1 + 64) + 136)) {
      return 18;
    }
    return 0;
  }
  return result;
}

uint64_t sub_10000F63C(int a1)
{
  int v2 = a1 - 1;
  if (a1 - 1) < 0xB && ((0x53Fu >> v2)) {
    return dword_10006E4FC[v2];
  }
  if (dword_10008FA20)
  {
    uint64_t v3 = ne_log_obj();
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      int v5 = 136315138;
      unint64_t v6 = sub_10003E8B0(a1);
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Inproper idtype:%s in this function.\n", (uint8_t *)&v5, 0xCu);
    }
  }
  return 4;
}

uint64_t sub_10000F71C(uint64_t a1)
{
  uint64_t v45 = 0;
  uint64_t v46 = 0;
  uint64_t v2 = *(void *)(a1 + 64);
  uint64_t v3 = *(unsigned int *)(v2 + 32);
  switch((int)v3)
  {
    case 1:
      uint64_t v4 = *(void *)(v2 + 40);
      if (!v4)
      {
        uint64_t v4 = *(void *)(qword_10008F848 + 184);
        if (!v4) {
          goto LABEL_70;
        }
      }
      int v5 = 2;
      goto LABEL_29;
    case 2:
      uint64_t v4 = *(void *)(v2 + 40);
      if (!v4)
      {
        uint64_t v4 = *(void *)(qword_10008F848 + 192);
        if (!v4) {
          goto LABEL_70;
        }
      }
      int v5 = 3;
      goto LABEL_29;
    case 3:
    case 8:
      uint64_t v4 = *(void *)(v2 + 40);
      if (!v4)
      {
        uint64_t v4 = *(void *)(qword_10008F848 + 8 * v3 + 176);
        if (!v4) {
          goto LABEL_70;
        }
      }
      int v5 = 11;
      goto LABEL_29;
    case 4:
      uint64_t v6 = *(void *)(v2 + 40);
      if (!v6) {
        goto LABEL_13;
      }
      BOOL v7 = *(uint64_t **)(v6 + 8);
      if (!v7) {
        goto LABEL_13;
      }
      goto LABEL_14;
    case 5:
      uint64_t v4 = *(void *)(v2 + 40);
      if (v4)
      {
        int v5 = 9;
LABEL_29:
        int v15 = sub_10003FAC0(v4);
        if (v15)
        {
          BOOL v14 = v15;
          int v11 = 0;
          __int16 v12 = 0;
          goto LABEL_31;
        }
      }
      else
      {
        if ((sub_10002B60C(a1) & 0x80000000) != 0)
        {
          if (!dword_10008FA20) {
            return 0xFFFFFFFFLL;
          }
          signed int v39 = ne_log_obj();
          if (os_log_type_enabled(v39, OS_LOG_TYPE_ERROR)) {
            sub_100059EE4();
          }
          goto LABEL_42;
        }
        SecCertificateRef v31 = sub_100003B68(*(void *)(a1 + 280) + 8);
        if (v31)
        {
          SecCertificateRef v32 = v31;
          CFDataRef v33 = (const __CFData *)j__SecCertificateCopySubjectSequence();
          if (v33)
          {
            CFDataRef v34 = v33;
            int Length = CFDataGetLength(v33);
            BytePtr = CFDataGetBytePtr(v34);
            size_t v37 = Length;
            __int16 v38 = sub_10003F940(Length);
            if (v38)
            {
              BOOL v14 = v38;
              memcpy((void *)v38[1], BytePtr, v37);
              CFRelease(v32);
              CFRelease(v34);
              int v11 = 0;
              __int16 v12 = 0;
              int v5 = 9;
              goto LABEL_31;
            }
            if (dword_10008FA20)
            {
              unsigned int v43 = ne_log_obj();
              if (os_log_type_enabled(v43, OS_LOG_TYPE_ERROR)) {
                sub_100059F4C();
              }
            }
            CFRelease(v32);
            CFDataRef v42 = v34;
          }
          else
          {
            if (dword_10008FA20)
            {
              unsigned int v41 = ne_log_obj();
              if (os_log_type_enabled(v41, OS_LOG_TYPE_ERROR)) {
                sub_100059F4C();
              }
            }
            CFDataRef v42 = v32;
          }
          CFRelease(v42);
        }
        else
        {
          if (!dword_10008FA20) {
            return 0;
          }
          __int16 v40 = ne_log_obj();
          if (os_log_type_enabled(v40, OS_LOG_TYPE_ERROR)) {
            sub_100059F18();
          }
        }
      }
LABEL_70:
      if (!dword_10008FA20) {
        return 0;
      }
      size_t v44 = ne_log_obj();
      uint64_t result = os_log_type_enabled(v44, OS_LOG_TYPE_ERROR);
      if (result)
      {
        sub_100059EB0();
        return 0;
      }
      return result;
    default:
LABEL_13:
      BOOL v7 = *(uint64_t **)(a1 + 56);
LABEL_14:
      int v8 = *((unsigned __int8 *)v7 + 1);
      if (v8 == 2) {
        goto LABEL_18;
      }
      if (v8 != 30)
      {
        if (!dword_10008FA20) {
          return 0xFFFFFFFFLL;
        }
        int v27 = ne_log_obj();
        if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR)) {
          sub_100059E7C();
        }
LABEL_42:
        if (dword_10008FA20)
        {
          BOOL v28 = ne_log_obj();
          if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR)) {
            sub_100059E48();
          }
        }
        return 0xFFFFFFFFLL;
      }
      if (*(_DWORD *)(a1 + 28))
      {
        uint64_t v46 = 0;
        LOWORD(v45) = 528;
        WORD1(v45) = *((_WORD *)v7 + 1);
        HIDWORD(v45) = 0;
        BOOL v7 = &v45;
LABEL_18:
        uint64_t v9 = (char *)v7 + 4;
        int v5 = 1;
        size_t v10 = 4;
      }
      else
      {
        uint64_t v9 = v7 + 1;
        int v5 = 5;
        size_t v10 = 16;
      }
      if (*(unsigned char *)(a1 + 80) == 16) {
        int v11 = -201261056;
      }
      else {
        int v11 = 0;
      }
      if (*(unsigned char *)(a1 + 80) == 16) {
        __int16 v12 = 4352;
      }
      else {
        __int16 v12 = 0;
      }
      __int16 v13 = sub_10003F940(v10);
      if (v13)
      {
        BOOL v14 = v13;
        memcpy((void *)v13[1], v9, *v13);
LABEL_31:
        unsigned int v16 = sub_10003F940(*v14 + 4);
        if (v16)
        {
          uint64_t v17 = v16;
          *(_DWORD *)v16[1] = v11 & 0xFFFF0000 | v12 & 0x1F00 | v5;
          memcpy((void *)(v16[1] + 4), (const void *)v14[1], *v14);
          *(void *)(a1 + 312) = v17;
          if (dword_10008C2C8 >= 7)
          {
            int v20 = v17;
            unint64_t v19 = *v17;
            uint64_t v18 = v20[1];
            char v21 = sub_10003E8B0(v5);
            sub_100033908(7, v18, v19, "use ID type of %s\n", v22, v23, v24, v25, v21);
          }
          sub_10003FA78(v14);
          return 0;
        }
        if (dword_10008FA20)
        {
          unsigned int v26 = ne_log_obj();
          if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR)) {
            sub_100059EB0();
          }
        }
        sub_10003FA78(v14);
        goto LABEL_42;
      }
      if (dword_10008FA20)
      {
        uint64_t v30 = ne_log_obj();
        uint64_t result = os_log_type_enabled(v30, OS_LOG_TYPE_ERROR);
        if (!result) {
          return result;
        }
        sub_100059EB0();
      }
      return 0;
  }
}

uint64_t sub_10000FBF0(void ***a1, int a2, uint64_t a3)
{
  return sub_10000FBF8(a1, a2, a3, 0);
}

uint64_t sub_10000FBF8(void ***a1, int a2, uint64_t a3, unsigned int a4)
{
  if (a3)
  {
    int v5 = 0;
    switch(a2)
    {
      case 1:
      case 2:
        if (*(void *)a3 > 1uLL) {
          goto LABEL_11;
        }
        if (dword_10008FA20)
        {
          BOOL v7 = ne_log_obj();
          if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR)) {
            sub_10005A000();
          }
        }
        return 0xFFFFFFFFLL;
      case 3:
        if (a4 >= 2)
        {
          if (a4 == 2)
          {
            uint64_t v9 = (void **)sub_10003F940(*(void *)a3 - 1);
            if (v9)
            {
LABEL_12:
              int v5 = v9;
              memcpy(v9[1], *(const void **)(a3 + 8), (size_t)*v9);
              goto LABEL_13;
            }
            if (dword_10008FA20)
            {
              char v21 = ne_log_obj();
              if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR)) {
                sub_10005A11C();
              }
            }
          }
          else if (dword_10008FA20)
          {
            uint64_t v22 = ne_log_obj();
            if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR)) {
              sub_10005A080();
            }
          }
        }
        else
        {
          BOOL v14 = fopen(*(const char **)(a3 + 8), "r");
          if (v14)
          {
            int v15 = v14;
            int v16 = fread(__ptr, 1uLL, 0x200uLL, v14);
            if (!v16)
            {
              int v5 = 0;
LABEL_47:
              fclose(v15);
              goto LABEL_13;
            }
            int v17 = 0;
            int v5 = 0;
            while (1)
            {
              int v18 = v16 + v17;
              unint64_t v19 = sub_10003F9BC(v5, v16 + v17);
              if (!v19) {
                break;
              }
              int v5 = v19;
              memcpy((char *)v19[1] + v17, __ptr, v16);
              int v16 = fread(__ptr, 1uLL, 0x200uLL, v15);
              int v17 = v18;
              if (!v16) {
                goto LABEL_47;
              }
            }
            fclose(v15);
          }
          else if (dword_10008FA20)
          {
            uint64_t v24 = ne_log_obj();
            if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR)) {
              sub_10005A0B4();
            }
          }
        }
        return 0xFFFFFFFFLL;
      case 4:
        if (!*(void *)a3)
        {
          int v5 = 0;
          goto LABEL_13;
        }
        int v11 = sub_10003D1DC(*(const char **)(a3 + 8), 0);
        if (v11)
        {
          __int16 v12 = v11;
          __int16 v13 = (void **)sub_10003F940(*v11);
          if (v13)
          {
            int v5 = v13;
            memcpy(v13[1], v12, (size_t)*v13);
            free(v12);
LABEL_13:
            uint64_t result = 0;
            *a1 = v5;
            return result;
          }
          free(v12);
        }
        else if (dword_10008FA20)
        {
          uint64_t v23 = ne_log_obj();
          if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR)) {
            sub_10005A150();
          }
        }
        break;
      case 5:
        if (dword_10008FA20)
        {
          int v20 = ne_log_obj();
          if (os_log_type_enabled(v20, OS_LOG_TYPE_DEBUG)) {
            sub_10005A1B8();
          }
        }
        return 0xFFFFFFFFLL;
      case 6:
      case 8:
LABEL_11:
        uint64_t v9 = (void **)sub_10003F940(*(void *)a3 - 1);
        if (v9) {
          goto LABEL_12;
        }
        return 0xFFFFFFFFLL;
      default:
        goto LABEL_13;
    }
  }
  else
  {
    if ((a2 - 1) > 1) {
      return 0;
    }
    if (dword_10008FA20)
    {
      int v8 = ne_log_obj();
      if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR)) {
        sub_100059F80();
      }
    }
  }
  return 0xFFFFFFFFLL;
}

uint64_t sub_10000FF98(uint64_t a1)
{
  uint64_t v2 = sub_10003511C(*(_DWORD *)(a1 + 52));
  if (!v2)
  {
    if (dword_10008FA20)
    {
      int v29 = ne_log_obj();
      if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR)) {
        sub_10005A1F0();
      }
    }
    return 0xFFFFFFFFLL;
  }
  uint64_t v3 = v2;
  long long v34 = 0uLL;
  uint64_t v4 = (unsigned __int8 *)(v2 + 2);
  int v5 = (long long *)(v2 + 3);
  unsigned int v6 = *((unsigned __int8 *)v2 + 280);
  if (*((unsigned char *)v2 + 153) == 30 && *(_DWORD *)(a1 + 16))
  {
    int v5 = &v34;
    HIDWORD(v34) = 0;
    *(void *)((char *)&v34 + 4) = 0;
    LOWORD(v34) = 528;
    WORD1(v34) = *((_WORD *)v2 + 13);
    inet_pton(2, "192.168.2.2", (char *)&v34 + 4);
    unsigned int v6 = 32;
  }
  BOOL v7 = sub_10001026C((uint64_t)v5, v6, *((unsigned __int16 *)v3 + 141));
  *(void *)(a1 + 192) = v7;
  if (!v7)
  {
    if (dword_10008FA20)
    {
      uint64_t v30 = ne_log_obj();
      if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR)) {
        sub_10005A25C(v4, v30);
      }
    }
    return 0xFFFFFFFFLL;
  }
  int v8 = *(unsigned __int8 *)v7[1];
  if ((v8 == 4 || v8 == 1) && *(unsigned char *)(a1 + 60) == 1)
  {
    uint64_t v10 = *(void *)(a1 + 256);
    if (v10)
    {
      if ((*(unsigned char *)(v10 + 96) & 2) != 0)
      {
        if (*(void *)(qword_10008F848 + 296))
        {
          sub_10003FA78(v7);
          BOOL v7 = sub_10003FAC0(*(void *)(qword_10008F848 + 296));
          *(void *)(a1 + 192) = v7;
          if (!v7) {
            return 0xFFFFFFFFLL;
          }
        }
      }
    }
  }
  int v11 = (long long *)(v3 + 19);
  if (dword_10008C2C8 >= 7)
  {
    unint64_t v13 = *v7;
    __int16 v12 = (unsigned __int8 *)v7[1];
    char v14 = sub_10003E8B0(*v12);
    sub_100033908(7, (uint64_t)v12, v13, "use local ID type %s\n", v15, v16, v17, v18, v14);
  }
  long long v33 = 0uLL;
  unsigned int v19 = *((unsigned __int8 *)v3 + 281);
  if (*((unsigned char *)v3 + 153) == 30 && *(_DWORD *)(a1 + 16))
  {
    int v11 = &v33;
    HIDWORD(v33) = 0;
    *(void *)((char *)&v33 + 4) = 0;
    LOWORD(v33) = 528;
    WORD1(v33) = *((_WORD *)v3 + 77);
    nw_nat64_extract_v4();
    unsigned int v19 = 32;
  }
  int v20 = sub_10001026C((uint64_t)v11, v19, *((unsigned __int16 *)v3 + 141));
  *(void *)(a1 + 200) = v20;
  if (!v20)
  {
    if (dword_10008FA20)
    {
      SecCertificateRef v31 = ne_log_obj();
      if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR)) {
        sub_10005A25C(v4, v31);
      }
    }
    SecCertificateRef v32 = *(void **)(a1 + 192);
    if (v32)
    {
      sub_10003FA78(v32);
      *(void *)(a1 + 192) = 0;
    }
    return 0xFFFFFFFFLL;
  }
  if (dword_10008C2C8 >= 7)
  {
    unint64_t v22 = *v20;
    char v21 = (unsigned __int8 *)v20[1];
    char v23 = sub_10003E8B0(*v21);
    sub_100033908(7, (uint64_t)v21, v22, "use remote ID type %s\n", v24, v25, v26, v27, v23);
  }
  return 0;
}

size_t *sub_10001026C(uint64_t a1, unsigned int a2, int a3)
{
  unsigned int v4 = a2;
  int v5 = *(unsigned __int8 *)(a1 + 1);
  if (v5 != 30)
  {
    if (v5 != 2)
    {
      if (dword_10008FA20)
      {
        int v8 = ne_log_obj();
        if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR)) {
          sub_10005A2DC();
        }
      }
      return 0;
    }
    if (a2 == 32)
    {
      unsigned int v6 = 0;
      char v7 = 1;
LABEL_12:
      uint64_t v9 = (const void *)(a1 + 4);
      size_t v10 = 4;
      goto LABEL_16;
    }
    if (a2 < 0x20)
    {
      char v7 = 4;
      unsigned int v6 = 4;
      goto LABEL_12;
    }
    if (!dword_10008FA20) {
      return 0;
    }
    int v20 = ne_log_obj();
    if (!os_log_type_enabled(v20, OS_LOG_TYPE_ERROR)) {
      return 0;
    }
LABEL_33:
    sub_10005A344();
    return 0;
  }
  if (a2 == 128)
  {
    unsigned int v6 = 0;
    char v7 = 5;
  }
  else
  {
    if (a2 >= 0x80)
    {
      if (!dword_10008FA20) {
        return 0;
      }
      char v21 = ne_log_obj();
      if (!os_log_type_enabled(v21, OS_LOG_TYPE_ERROR)) {
        return 0;
      }
      goto LABEL_33;
    }
    unsigned int v6 = 16;
    char v7 = 6;
  }
  uint64_t v9 = (const void *)(a1 + 8);
  size_t v10 = 16;
LABEL_16:
  __int16 v11 = *(_WORD *)(a1 + 2);
  __int16 v12 = sub_10003F940(v10 + v6 + 4);
  if (!v12)
  {
    if (dword_10008FA20)
    {
      unsigned int v19 = ne_log_obj();
      if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR)) {
        sub_100059EB0();
      }
    }
    return 0;
  }
  unint64_t v13 = v12;
  bzero((void *)v12[1], *v12);
  size_t v14 = v13[1];
  *(unsigned char *)size_t v14 = v7;
  if (a3 == 255) {
    char v15 = 0;
  }
  else {
    char v15 = a3;
  }
  *(unsigned char *)(v14 + 1) = v15;
  *(_WORD *)(v14 + 2) = v11;
  memcpy((void *)(v14 + 4), v9, v10);
  if (v6)
  {
    size_t v16 = v13[1];
    uint64_t v17 = (unsigned char *)(v16 + v10 + 4);
    if (v4 >= 8)
    {
      uint64_t v18 = (v4 - 8) >> 3;
      memset(v17, 255, v18 + 1);
      uint64_t v17 = (unsigned char *)(v10 + v18 + v16 + 5);
      v4 &= 7u;
    }
    if (v4) {
      *uint64_t v17 = -1 << (8 - v4);
    }
  }
  return v13;
}

size_t *sub_100010490(uint64_t a1, uint64_t a2, int a3)
{
  int v3 = *(unsigned __int8 *)(a1 + 1);
  if (v3 != *(unsigned __int8 *)(a2 + 1))
  {
    if (dword_10008FA20)
    {
      uint64_t v9 = ne_log_obj();
      if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR)) {
        sub_10005A3AC();
      }
    }
    return 0;
  }
  if (v3 == 2)
  {
    char v7 = 7;
    size_t v8 = 4;
  }
  else
  {
    if (v3 != 30)
    {
      if (dword_10008FA20)
      {
        size_t v14 = ne_log_obj();
        if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR)) {
          sub_10005A2DC();
        }
      }
      return 0;
    }
    char v7 = 8;
    size_t v8 = 16;
  }
  size_t v10 = sub_10003F940((2 * v8) | 4);
  if (!v10)
  {
    if (dword_10008FA20)
    {
      char v15 = ne_log_obj();
      if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR)) {
        sub_100059EB0();
      }
    }
    return 0;
  }
  __int16 v11 = v10;
  bzero((void *)v10[1], *v10);
  size_t v12 = v11[1];
  *(unsigned char *)size_t v12 = v7;
  if (a3 == 255) {
    char v13 = 0;
  }
  else {
    char v13 = a3;
  }
  *(unsigned char *)(v12 + 1) = v13;
  *(_WORD *)(v12 + 2) = *(_WORD *)(a1 + 2);
  memcpy((void *)(v12 + 4), (const void *)(a1 + 4), v8);
  memcpy((void *)(v11[1] + v8 + 4), (const void *)(a2 + 4), v8);
  return v11;
}

uint64_t sub_100010604(unint64_t *a1, uint64_t a2, unsigned char *a3, __int16 *a4, int a5)
{
  int v5 = (unsigned __int8 *)a1[1];
  int v6 = *v5;
  if ((v6 - 5) < 2)
  {
    *(_WORD *)a2 = 7708;
    *(_WORD *)(a2 + 2) = *((_WORD *)v5 + 1);
    *(_OWORD *)(a2 + 8) = *(_OWORD *)(v5 + 4);
  }
  else
  {
    if (v6 != 4 && v6 != 1)
    {
      if (dword_10008FA20)
      {
        __int16 v11 = ne_log_obj();
        if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR)) {
          sub_10005A3E0();
        }
      }
      return 18;
    }
    *(_WORD *)a2 = 528;
    *(_WORD *)(a2 + 2) = *((_WORD *)v5 + 1);
    *(_DWORD *)(a2 + 4) = *((_DWORD *)v5 + 1);
  }
  LOBYTE(v8) = 0;
  switch(*v5)
  {
    case 1u:
      LOBYTE(v8) = 32;
      goto LABEL_34;
    case 4u:
    case 6u:
      if (*v5 == 6) {
        unint64_t v9 = 16;
      }
      else {
        unint64_t v9 = 4;
      }
      if (*a1 < v9) {
        return 0xFFFFFFFFLL;
      }
      unint64_t v12 = a1[1];
      int v13 = *(unsigned __int8 *)(v12 + v9 + 4);
      if (v13 != 255)
      {
        LOBYTE(v8) = 0;
        goto LABEL_27;
      }
      unsigned int v14 = 8 * v9;
      char v15 = (unsigned __int8 *)(v9 + v12 + 5);
      unsigned int v16 = 8;
      while (1)
      {
        unsigned int v8 = v16;
        if (v16 >= v14) {
          break;
        }
        int v17 = *v15++;
        int v13 = v17;
        v16 += 8;
        if (v17 != 255) {
          goto LABEL_31;
        }
      }
      int v13 = 255;
LABEL_31:
      if (v8 < v14)
      {
        if (v13 == 255)
        {
          char v18 = 0;
LABEL_29:
          LOBYTE(v8) = v8 + v18 + 8;
          goto LABEL_34;
        }
LABEL_27:
        char v18 = 0;
        unsigned int v19 = v13 ^ 0xFF;
        do
        {
          --v18;
          BOOL v20 = v19 > 1;
          v19 >>= 1;
        }
        while (v20);
        goto LABEL_29;
      }
LABEL_34:
      *a3 = v8;
      if (a5 != 16) {
        return 0;
      }
      uint64_t result = 0;
      __int16 v21 = v5[1];
      if (!v5[1]) {
        __int16 v21 = 255;
      }
      *a4 = v21;
      return result;
    case 5u:
      LOBYTE(v8) = 0x80;
      goto LABEL_34;
    default:
      goto LABEL_34;
  }
}

unsigned char *sub_1000107E8(uint64_t a1)
{
  int v1 = *(unsigned __int8 **)(a1 + 8);
  memset(v30, 0, sizeof(v30));
  int v2 = *v1;
  switch(*v1)
  {
    case 1u:
    case 4u:
    case 7u:
      *(_WORD *)&v30[0].sa_len = 528;
      *(_DWORD *)&v30[0].sa_data[2] = *((_DWORD *)v1 + 1);
      goto LABEL_8;
    case 2u:
    case 3u:
LABEL_10:
      if (*(_DWORD *)a1 - 4 >= 512) {
        int v6 = 512;
      }
      else {
        int v6 = *(_DWORD *)a1 - 4;
      }
      __memcpy_chk();
      goto LABEL_48;
    case 5u:
    case 6u:
    case 8u:
      *(_WORD *)&v30[0].sa_len = 7708;
      *(sockaddr *)&v30[0].sa_data[6] = *(sockaddr *)(v1 + 4);
      if (v30[0].sa_data[6] == 254 && (v30[0].sa_data[7] & 0xC0) == 0x80) {
        int v4 = *((_DWORD *)v1 + 6);
      }
      else {
        int v4 = 0;
      }
      *(_DWORD *)&v30[1].sa_data[6] = v4;
LABEL_8:
      switch(v2)
      {
        case 1:
        case 5:
          sub_10003CE24(v30);
          int v5 = snprintf((char *)&qword_10008C548, 0x200uLL, "%s");
          goto LABEL_47;
        case 2:
        case 3:
          goto LABEL_10;
        case 4:
        case 6:
          if (v2 == 6) {
            unint64_t v9 = 16;
          }
          else {
            unint64_t v9 = 4;
          }
          if (*(void *)a1 < v9) {
            goto LABEL_49;
          }
          int v10 = v1[v9 + 4];
          if (v10 != 255) {
            goto LABEL_40;
          }
          unsigned int v11 = 8 * v9;
          unint64_t v12 = &v1[v9 + 5];
          unsigned int v13 = 8;
          break;
        case 7:
          unsigned int v16 = sub_10003CE24(v30);
          unsigned int v17 = snprintf((char *)&qword_10008C548, 0x200uLL, "%s-", v16);
          int v6 = v17;
          int v18 = *(_DWORD *)(*(void *)(a1 + 8) + 8);
          *(_DWORD *)&v30[0].sa_len = 528;
          *(_DWORD *)&v30[0].sa_data[2] = v18;
          if ((v17 & 0x80000000) != 0) {
            goto LABEL_50;
          }
          unsigned int v19 = (char *)&qword_10008C548 + v17;
          goto LABEL_39;
        case 8:
          BOOL v20 = sub_10003CE24(v30);
          unsigned int v21 = snprintf((char *)&qword_10008C548, 0x200uLL, "%s-", v20);
          int v6 = v21;
          *(_DWORD *)&v30[0].sa_len = 7708;
          *(sockaddr *)&v30[0].sa_data[6] = *(sockaddr *)(*(void *)(a1 + 8) + 20);
          if (v30[0].sa_data[6] == 254 && (v30[0].sa_data[7] & 0xC0) == 0x80) {
            int v22 = *((_DWORD *)v1 + 6);
          }
          else {
            int v22 = 0;
          }
          *(_DWORD *)&v30[1].sa_data[6] = v22;
          if ((v21 & 0x80000000) != 0) {
            goto LABEL_50;
          }
          unsigned int v19 = (char *)&qword_10008C548 + v21;
LABEL_39:
          char v23 = sub_10003CE24(v30);
          v6 += snprintf(v19, 512 - v6, "%s", v23);
          goto LABEL_48;
        case 9:
        case 10:
          goto LABEL_14;
        case 11:
          goto LABEL_18;
        default:
          goto LABEL_19;
      }
      break;
    case 9u:
    case 0xAu:
LABEL_14:
      if (dword_10008FA20)
      {
        char v7 = ne_log_obj();
        if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR)) {
          sub_10005A4B0();
        }
      }
      strcpy((char *)&qword_10008C548, "<ASN1-DN>");
      int v6 = 9;
      goto LABEL_50;
    case 0xBu:
LABEL_18:
      strcpy((char *)&qword_10008C548, "<KEY-ID>");
      int v6 = 8;
      goto LABEL_50;
    default:
LABEL_19:
      if (dword_10008FA20)
      {
        unsigned int v8 = ne_log_obj();
        if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR)) {
          sub_10005A448();
        }
      }
      goto LABEL_49;
  }
  while (1)
  {
    unsigned int v14 = v13;
    if (v13 >= v11) {
      break;
    }
    int v15 = *v12++;
    int v10 = v15;
    v13 += 8;
    if (v15 != 255) {
      goto LABEL_44;
    }
  }
  int v10 = 255;
LABEL_44:
  if (v14 < v11 && v10 != 255)
  {
LABEL_40:
    int v24 = 0;
    unsigned int v25 = v10 ^ 0xFF;
    do
    {
      --v24;
      BOOL v26 = v25 > 1;
      v25 >>= 1;
    }
    while (v26);
  }
  sub_10003CE24(v30);
  int v5 = snprintf((char *)&qword_10008C548, 0x200uLL, "%s/%i");
LABEL_47:
  int v6 = v5;
LABEL_48:
  if (!v6)
  {
LABEL_49:
    LODWORD(qword_10008C548) = 4079420;
    int v6 = 3;
  }
LABEL_50:
  uint64_t v27 = malloc_type_malloc(v6 + 1, 0xD287029BuLL);
  BOOL v28 = v27;
  if (v27)
  {
    memcpy(v27, &qword_10008C548, v6);
    v28[v6] = 0;
  }
  return v28;
}

uint64_t sub_100010C74(uint64_t a1, uint64_t a2, _DWORD *a3, _DWORD *a4)
{
  uint64_t result = 0;
  *a4 = *(unsigned __int8 *)(a1 + 4);
  a4[1] = *(unsigned __int8 *)(a1 + 5);
  unsigned int v6 = *(unsigned __int16 *)(a1 + 2);
  *(void *)(a2 + 8) = 28800;
  char v7 = (void *)(a2 + 8);
  *(_DWORD *)(a2 + 16) = 0;
  a4[3] = 254;
  unsigned int v8 = bswap32(v6) >> 16;
  if (v8 >= 9)
  {
    unsigned int v11 = 0;
    int v12 = v8 - 8;
    unsigned int v13 = (unsigned __int16 *)(a1 + 8);
    unsigned int v58 = (_DWORD *)(a2 + 16);
    uint64_t v14 = 1;
    while (1)
    {
      unint64_t v15 = v12;
      if (v12 <= 3) {
        break;
      }
      int v16 = *v13;
      unsigned int v17 = bswap32(v16 & 0xFFFFFF7F) >> 16;
      int v18 = (v16 << 8) & 0x8000;
      if (dword_10008FA20)
      {
        uint64_t v19 = v14;
        BOOL v20 = ne_log_obj();
        BOOL v21 = os_log_type_enabled(v20, OS_LOG_TYPE_DEBUG);
        uint64_t v14 = v19;
        if (v21)
        {
          int v57 = v7;
          uint64_t v36 = a3;
          size_t v37 = sub_10003E618(v17);
          __int16 v38 = sub_10003E80C(v17, bswap32(v13[1]) >> 16);
          *(_DWORD *)buf = 136315650;
          v63 = v37;
          a3 = v36;
          char v7 = v57;
          __int16 v64 = 1024;
          int v65 = v18;
          __int16 v66 = 2080;
          v67 = v38;
          _os_log_debug_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEBUG, "type=%s, flag=0x%04x, lorv=%s\n", buf, 0x1Cu);
          uint64_t v14 = v19;
        }
      }
      switch(v17)
      {
        case 1u:
          unsigned int v22 = bswap32(v13[1]);
          uint64_t v14 = HIWORD(v22);
          if ((unsigned __int16)(HIWORD(v22) - 1) <= 1u) {
            goto LABEL_54;
          }
          if (dword_10008FA20)
          {
            char v23 = ne_log_obj();
            if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
            {
              *(_WORD *)buf = 0;
              _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "invalid life duration type. use default\n", buf, 2u);
            }
          }
          goto LABEL_53;
        case 2u:
          if (v11 && (*v11 & 0xFF7F) == 0x100)
          {
            if (v18)
            {
              int v24 = v14;
              unsigned int v25 = a3;
              BOOL v26 = sub_10003F940(2uLL);
              if (!v26)
              {
                if (!dword_10008FA20) {
                  return 0xFFFFFFFFLL;
                }
                long long v49 = ne_log_obj();
                if (!os_log_type_enabled(v49, OS_LOG_TYPE_ERROR)) {
                  return 0xFFFFFFFFLL;
                }
                goto LABEL_81;
              }
              uint64_t v27 = v26;
              *(_WORD *)v26[1] = v13[1];
            }
            else
            {
              size_t v39 = bswap32(v13[1]) >> 16;
              if (v39 + 4 > v15)
              {
                if (dword_10008FA20)
                {
                  int v53 = ne_log_obj();
                  if (os_log_type_enabled(v53, OS_LOG_TYPE_ERROR)) {
                    sub_10005A5C0(v15, v39, v53);
                  }
                }
                return 0xFFFFFFFFLL;
              }
              int v24 = v14;
              unsigned int v25 = a3;
              __int16 v40 = sub_10003F940(v39);
              if (!v40)
              {
                if (!dword_10008FA20) {
                  return 0xFFFFFFFFLL;
                }
                int v54 = ne_log_obj();
                if (!os_log_type_enabled(v54, OS_LOG_TYPE_ERROR)) {
                  return 0xFFFFFFFFLL;
                }
LABEL_81:
                sub_10005A65C();
                return 0xFFFFFFFFLL;
              }
              uint64_t v27 = v40;
              memcpy((void *)v40[1], v13 + 2, v39);
            }
            if (v24 != 2)
            {
              if (v24 != 1)
              {
                sub_10003FA78(v27);
                if (dword_10008FA20)
                {
                  long long v50 = ne_log_obj();
                  if (os_log_type_enabled(v50, OS_LOG_TYPE_ERROR)) {
                    sub_1000588D8();
                  }
                }
                return 0xFFFFFFFFLL;
              }
              unsigned int v41 = sub_10000C0F4((uint64_t)v27);
              sub_10003FA78(v27);
              if (!v41)
              {
                if (!dword_10008FA20) {
                  return 0xFFFFFFFFLL;
                }
                long long v51 = ne_log_obj();
                if (!os_log_type_enabled(v51, OS_LOG_TYPE_ERROR)) {
                  return 0xFFFFFFFFLL;
                }
                goto LABEL_87;
              }
              if (*v7 != 28800)
              {
                if (*v7 != v41)
                {
                  if (dword_10008FA20)
                  {
                    __int16 v56 = ne_log_obj();
                    if (os_log_type_enabled(v56, OS_LOG_TYPE_ERROR)) {
                      sub_10005A690();
                    }
                  }
                  return 0xFFFFFFFFLL;
                }
                a3 = v25;
LABEL_53:
                uint64_t v14 = 1;
                goto LABEL_54;
              }
              void *v7 = v41;
              uint64_t v14 = 1;
              goto LABEL_59;
            }
            int v42 = sub_10000C0F4((uint64_t)v27);
            sub_10003FA78(v27);
            if (!v42)
            {
              if (!dword_10008FA20) {
                return 0xFFFFFFFFLL;
              }
              long long v52 = ne_log_obj();
              if (!os_log_type_enabled(v52, OS_LOG_TYPE_ERROR)) {
                return 0xFFFFFFFFLL;
              }
LABEL_87:
              sub_100058940();
              return 0xFFFFFFFFLL;
            }
            if (!*v58)
            {
              _DWORD *v58 = v42;
              uint64_t v14 = 2;
LABEL_59:
              a3 = v25;
              if (v18) {
                goto LABEL_55;
              }
              goto LABEL_29;
            }
            if (*v58 != v42)
            {
              if (dword_10008FA20)
              {
                int64_t v55 = ne_log_obj();
                if (os_log_type_enabled(v55, OS_LOG_TYPE_ERROR)) {
                  sub_10005A70C();
                }
              }
              return 0xFFFFFFFFLL;
            }
            a3 = v25;
            uint64_t v14 = 2;
            if (v18) {
              goto LABEL_55;
            }
          }
          else
          {
            if (!dword_10008FA20) {
              goto LABEL_54;
            }
            uint64_t v34 = v14;
            uint64_t v35 = ne_log_obj();
            if (os_log_type_enabled(v35, OS_LOG_TYPE_ERROR)) {
              sub_1000588A8(&v60, v61);
            }
            uint64_t v14 = v34;
            if (v18) {
              goto LABEL_55;
            }
          }
          goto LABEL_29;
        case 3u:
          int v28 = *(_DWORD *)(a2 + 20);
          unsigned int v29 = bswap32(v13[1]) >> 16;
          if (!v28)
          {
            *(_DWORD *)(a2 + 20) = v29;
            if (v18) {
              goto LABEL_55;
            }
            goto LABEL_29;
          }
          if (v28 != v29)
          {
            if (dword_10008FA20)
            {
              long long v48 = ne_log_obj();
              if (os_log_type_enabled(v48, OS_LOG_TYPE_ERROR)) {
                sub_10005A778();
              }
            }
            return 0xFFFFFFFFLL;
          }
LABEL_54:
          if (!v18) {
            goto LABEL_29;
          }
          goto LABEL_55;
        case 4u:
          int v30 = a3[4];
          unsigned int v31 = bswap32(v13[1]) >> 16;
          if (v30 && v30 != v31)
          {
            if (dword_10008FA20)
            {
              uint64_t v45 = ne_log_obj();
              if (os_log_type_enabled(v45, OS_LOG_TYPE_ERROR)) {
                sub_10005A7AC();
              }
            }
            return 0xFFFFFFFFLL;
          }
          a3[4] = v31;
          if (!v18) {
            goto LABEL_29;
          }
          goto LABEL_55;
        case 5u:
          if (a4[3] != 254)
          {
            if (dword_10008FA20)
            {
              uint64_t v46 = ne_log_obj();
              if (os_log_type_enabled(v46, OS_LOG_TYPE_ERROR)) {
                sub_10005A7E0();
              }
            }
            return 0xFFFFFFFFLL;
          }
          a4[3] = bswap32(v13[1]) >> 16;
          if (!v18) {
            goto LABEL_29;
          }
          goto LABEL_55;
        case 6u:
          if (*a3 != 3)
          {
            if (dword_10008FA20)
            {
              __int16 v47 = ne_log_obj();
              if (os_log_type_enabled(v47, OS_LOG_TYPE_ERROR)) {
                sub_10005A814();
              }
            }
            return 0xFFFFFFFFLL;
          }
          a4[2] = bswap32(v13[1]) >> 16;
          if (v18)
          {
LABEL_55:
            int v12 = v15 - 4;
            uint64_t v33 = (uint64_t)(v13 + 2);
          }
          else
          {
LABEL_29:
            unsigned int v32 = bswap32(v13[1]);
            uint64_t v33 = (uint64_t)v13 + HIWORD(v32) + 4;
            int v12 = v15 - HIWORD(v32) - 4;
            if (v12 < 0)
            {
              if (dword_10008FA20)
              {
                size_t v44 = ne_log_obj();
                if (os_log_type_enabled(v44, OS_LOG_TYPE_ERROR)) {
                  sub_10005A54C();
                }
              }
              return 0xFFFFFFFFLL;
            }
          }
          unsigned int v11 = v13;
          unsigned int v13 = (unsigned __int16 *)v33;
          if (v12 <= 0) {
            return 0;
          }
          break;
        default:
          goto LABEL_54;
      }
    }
    if (dword_10008FA20)
    {
      unsigned int v43 = ne_log_obj();
      if (os_log_type_enabled(v43, OS_LOG_TYPE_ERROR)) {
        sub_10005A4E4();
      }
    }
    return 0xFFFFFFFFLL;
  }
  return result;
}

uint64_t sub_100011410(int a1)
{
  if ((a1 - 1) < 7) {
    return dword_10006E528[a1 - 1];
  }
  if (dword_10008FA20)
  {
    int v2 = ne_log_obj();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR)) {
      sub_10005A848();
    }
  }
  return 0xFFFFFFFFLL;
}

uint64_t sub_100011484(unsigned int a1)
{
  if (a1 > 5) {
    return 255;
  }
  else {
    return dword_10006E4D8[a1];
  }
}

uint64_t sub_1000114A4(int a1)
{
  if (a1 == 1) {
    return 0;
  }
  if (dword_10008FA20)
  {
    int v2 = ne_log_obj();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR)) {
      sub_10005A8B0();
    }
  }
  return 0xFFFFFFFFLL;
}

uint64_t sub_100011510(int a1)
{
  if ((a1 - 2) < 3) {
    return 0;
  }
  if (dword_10008FA20)
  {
    int v2 = ne_log_obj();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR)) {
      sub_10005A918();
    }
  }
  return 0xFFFFFFFFLL;
}

uint64_t sub_100011580(int a1)
{
  if (a1 == 1) {
    return 0;
  }
  if (dword_10008FA20)
  {
    int v2 = ne_log_obj();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR)) {
      sub_10005A980();
    }
  }
  return 0xFFFFFFFFLL;
}

uint64_t sub_1000115EC(unsigned int a1)
{
  if (a1 > 7) {
    goto LABEL_14;
  }
  if (((1 << a1) & 0xEC) != 0) {
    return 0;
  }
  if (a1 == 4)
  {
    if (dword_10008FA20)
    {
      int v2 = ne_log_obj();
      if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR)) {
        sub_10005AA5C(v2, v3, v4, v5, v6, v7, v8, v9);
      }
    }
  }
  else
  {
LABEL_14:
    if (dword_10008FA20)
    {
      int v10 = ne_log_obj();
      if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR)) {
        sub_10005A9F4();
      }
    }
  }
  return 0xFFFFFFFFLL;
}

uint64_t sub_1000116A0(unsigned int a1)
{
  uint64_t result = 0;
  if (a1 <= 0xC)
  {
    if (((1 << a1) & 0x18DC) != 0) {
      return result;
    }
    if (((1 << a1) & 0x722) != 0)
    {
      if (dword_10008FA20)
      {
        uint64_t v3 = ne_log_obj();
        if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR)) {
          sub_10005AB38();
        }
      }
      return 0xFFFFFFFFLL;
    }
  }
  if (a1 != 253)
  {
    if (dword_10008FA20)
    {
      uint64_t v4 = ne_log_obj();
      if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR)) {
        sub_10005AAD0();
      }
    }
    return 0xFFFFFFFFLL;
  }
  return result;
}

uint64_t sub_100011760(int a1)
{
  if ((a1 - 1) < 3) {
    return 0;
  }
  if (dword_10008FA20)
  {
    int v2 = ne_log_obj();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR)) {
      sub_10005ABA0();
    }
  }
  return 0xFFFFFFFFLL;
}

uint64_t sub_1000117D0(uint64_t a1)
{
  return sub_10000D724(2, a1);
}

uint64_t sub_1000117DC(uint64_t a1)
{
  return sub_10000D724(3, a1);
}

void sub_1000117E8(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_error_impl(a1, a2, OS_LOG_TYPE_ERROR, a4, &a9, 8u);
}

void sub_100011804(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint8_t *a5)
{
  _os_log_error_impl(a1, a2, OS_LOG_TYPE_ERROR, a4, a5, 2u);
}

unsigned char *sub_100011828(unsigned char *result, unsigned char *a2)
{
  *uint64_t result = 0;
  *a2 = 0;
  return result;
}

void sub_100011854(void *a1, int a2, os_log_t log, const char *a4, uint8_t *a5)
{
  _os_log_debug_impl(a1, log, OS_LOG_TYPE_DEBUG, a4, a5, 2u);
}

void sub_100011870(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_error_impl(a1, a2, OS_LOG_TYPE_ERROR, a4, &a9, 0xCu);
}

void sub_10001188C(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint8_t *a5)
{
  _os_log_debug_impl(a1, a2, OS_LOG_TYPE_DEBUG, a4, a5, 2u);
}

void sub_1000118A4(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint8_t *a5)
{
  _os_log_error_impl(a1, a2, OS_LOG_TYPE_ERROR, a4, a5, 0xCu);
}

void sub_1000118BC(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_error_impl(a1, a2, OS_LOG_TYPE_ERROR, a4, &a9, 0x12u);
}

void sub_1000118E4(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint8_t *a5)
{
  _os_log_error_impl(a1, a2, OS_LOG_TYPE_ERROR, a4, a5, 0xEu);
}

void sub_1000118FC(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint8_t *a5)
{
  _os_log_error_impl(a1, a2, OS_LOG_TYPE_ERROR, a4, a5, 0x12u);
}

uint64_t sub_1000119A0(uint64_t a1, uint64_t a2)
{
  int v42 = 0;
  memset(v43, 0, sizeof(v43));
  int v2 = (int *)(a1 + 16);
  if (*(_DWORD *)(a1 + 16) != 5248)
  {
    if (dword_10008FA20)
    {
      uint64_t v4 = ne_log_obj();
      if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR)) {
        sub_10005AED8();
      }
    }
    goto LABEL_9;
  }
  if (a2)
  {
    if (dword_10008FA20)
    {
      uint64_t v3 = ne_log_obj();
      if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR)) {
        sub_10005AEA4();
      }
    }
LABEL_9:
    uint64_t v5 = 0;
    uint64_t v6 = 0;
    uint64_t v7 = 0;
    uint64_t v8 = 0xFFFFFFFFLL;
    goto LABEL_10;
  }
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  sub_100025FD0((void *)a1, *(void *)(a1 + 48), *(void *)(a1 + 56));
  if ((sub_10000F71C(a1) & 0x80000000) != 0)
  {
    if (dword_10008FA20)
    {
      unsigned int v25 = ne_log_obj();
      if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR)) {
        sub_10005AC08();
      }
    }
    goto LABEL_9;
  }
  unsigned int v13 = sub_10000E2C8(a1);
  *(void *)(a1 + 336) = v13;
  if (!v13)
  {
    if (dword_10008FA20)
    {
      BOOL v26 = ne_log_obj();
      if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR)) {
        sub_10005AC3C();
      }
    }
    goto LABEL_9;
  }
  uint64_t v14 = a1 + 64;
  uint64_t v15 = *(void *)(*(void *)(a1 + 64) + 192);
  if (!v15)
  {
    if (dword_10008FA20)
    {
      uint64_t v27 = ne_log_obj();
      if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR)) {
        sub_10005AC70();
      }
    }
    goto LABEL_9;
  }
  if ((sub_10002972C(v15, (size_t **)(a1 + 152), (void *)(a1 + 136)) & 0x80000000) != 0)
  {
    if (dword_10008FA20)
    {
      int v28 = ne_log_obj();
      if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR)) {
        sub_10005ACA4();
      }
    }
    goto LABEL_9;
  }
  int v16 = sub_10000601C(*(_DWORD *)(*(void *)(a1 + 64) + 140));
  *(void *)(a1 + 176) = v16;
  if (!v16)
  {
    if (dword_10008FA20)
    {
      unsigned int v29 = ne_log_obj();
      if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR)) {
        sub_10005ACD8();
      }
    }
    goto LABEL_9;
  }
  int v17 = *(_DWORD *)(*(void *)(*(void *)v14 + 248) + 48);
  if (!*(void *)(*(void *)v14 + 272) || v17 != 65001)
  {
    BOOL v18 = (v17 - 65005) > 4 || ((1 << (v17 + 19)) & 0x15) == 0;
    BOOL v19 = !v18 || v17 == 65500;
    if (!v19 && v17 != 64221)
    {
      uint64_t v5 = 0;
LABEL_46:
      uint64_t v6 = 0;
      goto LABEL_47;
    }
  }
  uint64_t v5 = sub_10003F70C(16);
  if (!v5)
  {
    if (dword_10008FA20)
    {
      BOOL v21 = ne_log_obj();
      if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR)) {
        sub_10005AE70();
      }
    }
  }
  uint64_t v6 = sub_10003F70C(17);
  if (!v6 && dword_10008FA20)
  {
    unsigned int v22 = ne_log_obj();
    if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR)) {
      sub_10005AE3C();
    }
    goto LABEL_46;
  }
LABEL_47:
  if (!*(_DWORD *)(*(void *)v14 + 148))
  {
LABEL_70:
    int v24 = 0;
    goto LABEL_71;
  }
  char v23 = (void **)sub_10003F70C(18);
  if (v23) {
    int v24 = sub_100015144(v23, 0x80000000);
  }
  else {
    int v24 = 0;
  }
  if (!v24 && dword_10008FA20)
  {
    int v30 = ne_log_obj();
    if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR)) {
      sub_10005AE08();
    }
    goto LABEL_70;
  }
LABEL_71:
  if (*(_DWORD *)(*(void *)v14 + 120) && sub_10002CBD4(*(_DWORD *)(*(void *)(*(void *)v14 + 248) + 48)))
  {
    unsigned int v31 = sub_10002C9C0(a1);
    if (!v31)
    {
      if (dword_10008FA20)
      {
        unsigned int v41 = ne_log_obj();
        if (os_log_type_enabled(v41, OS_LOG_TYPE_ERROR)) {
          sub_10005ADD4();
        }
      }
      uint64_t v7 = 0;
      uint64_t v8 = 0xFFFFFFFFLL;
      goto LABEL_105;
    }
    unsigned int v32 = v31;
    char v33 = 0;
  }
  else
  {
    unsigned int v32 = 0;
    char v33 = 1;
  }
  if (dword_10008FA20)
  {
    uint64_t v34 = ne_log_obj();
    if (os_log_type_enabled(v34, OS_LOG_TYPE_DEBUG)) {
      sub_10005AD40(a1 + 64, v34);
    }
  }
  uint64_t v35 = sub_100026474(0, *(void *)(a1 + 336), 1);
  uint64_t v36 = sub_100026474(v35, *(void *)(a1 + 152), 4);
  size_t v37 = sub_100026474(v36, *(void *)(a1 + 176), 10);
  __int16 v38 = (uint64_t **)sub_100026474(v37, *(void *)(a1 + 312), 5);
  size_t v39 = v38;
  int v42 = v38;
  if ((v33 & 1) == 0)
  {
    size_t v39 = (uint64_t **)sub_100026474(v38, (uint64_t)v32, 7);
    int v42 = v39;
  }
  if (v24)
  {
    size_t v39 = (uint64_t **)sub_100026474(v39, (uint64_t)v24, 13);
    int v42 = v39;
  }
  if (*(_DWORD *)(*(void *)v14 + 176))
  {
    size_t v39 = (uint64_t **)sub_1000404F0(v39, v43);
    int v42 = v39;
  }
  if (v5)
  {
    size_t v39 = (uint64_t **)sub_100026474(v39, (uint64_t)v5, 13);
    int v42 = v39;
  }
  if (v6)
  {
    size_t v39 = (uint64_t **)sub_100026474(v39, (uint64_t)v6, 13);
    int v42 = v39;
  }
  if (*(_DWORD *)(*(void *)v14 + 208))
  {
    uint64_t v7 = sub_10003F70C(19);
    if (v7) {
      int v42 = (uint64_t **)sub_100026474(v39, (uint64_t)v7, 13);
    }
  }
  else
  {
    uint64_t v7 = 0;
  }
  *(void *)(a1 + 128) = sub_1000264D0(&v42, a1);
  *(_DWORD *)(a1 + 124) = *(_DWORD *)(*(void *)(a1 + 64) + 200);
  if (sub_100024104(a1) == -1)
  {
    if (dword_10008FA20)
    {
      __int16 v40 = ne_log_obj();
      if (os_log_type_enabled(v40, OS_LOG_TYPE_ERROR)) {
        sub_10005AD0C();
      }
    }
    uint64_t v8 = 0xFFFFFFFFLL;
  }
  else
  {
    sub_100002728(v2, 5281);
    uint64_t v8 = 0;
  }
  if (v32) {
    sub_10003FA78(v32);
  }
LABEL_105:
  if (v24) {
    sub_10003FA78(v24);
  }
LABEL_10:
  for (uint64_t i = 0; i != 96; i += 8)
  {
    int v10 = *(void **)((char *)v43 + i);
    if (!v10) {
      break;
    }
    sub_10003FA78(v10);
  }
  if (v5) {
    sub_10003FA78(v5);
  }
  if (v6) {
    sub_10003FA78(v6);
  }
  if (v7) {
    sub_10003FA78(v7);
  }
  return v8;
}

uint64_t sub_100011FBC(uint64_t a1, uint64_t a2)
{
  uint64_t v69 = 0;
  v70 = &v69;
  v71 = 0;
  uint64_t v3 = (int *)(a1 + 16);
  if (*(_DWORD *)(a1 + 16) != 5281)
  {
    if (dword_10008FA20)
    {
      BOOL v19 = ne_log_obj();
      if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR)) {
        sub_10005AED8();
      }
    }
    goto LABEL_49;
  }
  uint64_t v5 = sub_100022FA8(a2);
  if (!v5)
  {
    if (dword_10008FA20)
    {
      BOOL v20 = ne_log_obj();
      if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR)) {
        sub_10005AF40();
      }
    }
LABEL_49:
    char v21 = 0;
    uint64_t v22 = 0xFFFFFFFFLL;
    goto LABEL_93;
  }
  uint64_t v6 = v5;
  uint64_t v7 = (unsigned __int8 *)v5[1];
  *(void *)(a1 + 352) = 0;
  if (*v7 != 1)
  {
    if (dword_10008FA20)
    {
      char v23 = ne_log_obj();
      if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR)) {
        sub_10005B3AC();
      }
    }
    goto LABEL_91;
  }
  if ((sub_1000261F4((size_t **)&v71, *((void *)v7 + 1)) & 0x80000000) != 0)
  {
    if (dword_10008FA20)
    {
      int v24 = ne_log_obj();
      if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR)) {
        sub_10005AF74();
      }
    }
    goto LABEL_91;
  }
  v63 = v6;
  int v8 = 0;
  int v9 = 0;
  __int16 v64 = (size_t **)(a1 + 184);
  while (2)
  {
    v7 += 16;
    int v10 = *v7;
    switch(*v7)
    {
      case 0u:
        if (v8) {
          sub_10002BB90((void *)a1);
        }
        uint64_t v6 = v63;
        if (!*(void *)(a1 + 160) || !*v64)
        {
          if (dword_10008FA20)
          {
            char v33 = ne_log_obj();
            if (os_log_type_enabled(v33, OS_LOG_TYPE_ERROR)) {
              sub_10005B014();
            }
          }
          goto LABEL_91;
        }
        if (sub_10000F124(a1))
        {
          if (dword_10008FA20)
          {
            BOOL v26 = ne_log_obj();
            if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR)) {
              sub_10005B180();
            }
          }
          goto LABEL_91;
        }
        if ((sub_10000A144((unint64_t *)v71, (void *)a1) & 0x80000000) != 0)
        {
          if (dword_10008FA20)
          {
            int v57 = ne_log_obj();
            if (os_log_type_enabled(v57, OS_LOG_TYPE_ERROR)) {
              sub_10005B048();
            }
          }
          goto LABEL_91;
        }
        unsigned int v41 = *(void **)(a1 + 344);
        if (v41)
        {
          sub_10003FA78(v41);
          *(void *)(a1 + 344) = 0;
        }
        *(void *)(a1 + 8) = *(void *)(*(void *)(a2 + 8) + 8);
        if (*(unsigned char *)(a1 + 96))
        {
          if (dword_10008FA20)
          {
            int v42 = ne_log_obj();
            if (os_log_type_enabled(v42, OS_LOG_TYPE_DEFAULT))
            {
              unsigned int v43 = sub_10003F504(**(_DWORD **)(a1 + 88));
              *(_DWORD *)buf = 136315138;
              *(void *)v73 = v43;
              _os_log_impl((void *)&_mh_execute_header, v42, OS_LOG_TYPE_DEFAULT, "Selected NAT-T version: %s\n", buf, 0xCu);
            }
          }
          *(_DWORD *)(a1 + 96) |= 6u;
          for (uint64_t i = v69; v69; uint64_t i = v69)
          {
            int v45 = sub_10003FD90(a1, *(void *)(i + 8), *(_DWORD *)i);
            if (dword_10008FA20)
            {
              int v46 = v45;
              __int16 v47 = ne_log_obj();
              if (os_log_type_enabled(v47, OS_LOG_TYPE_DEFAULT))
              {
                int v48 = *(_DWORD *)i - 1;
                if (v46) {
                  long long v49 = "verified";
                }
                else {
                  long long v49 = "doesn't match";
                }
                *(_DWORD *)buf = 67109378;
                *(_DWORD *)v73 = v48;
                *(_WORD *)&v73[4] = 2080;
                *(void *)&v73[6] = v49;
                _os_log_impl((void *)&_mh_execute_header, v47, OS_LOG_TYPE_DEFAULT, "NAT-D payload #%d %s\n", buf, 0x12u);
              }
            }
            sub_10003FA78(*(void **)(i + 8));
            uint64_t v50 = *(void *)(i + 16);
            long long v51 = *(void **)(i + 24);
            if (v50)
            {
              *(void *)(v50 + 24) = v51;
              long long v51 = *(void **)(i + 24);
            }
            else
            {
              v70 = *(uint64_t **)(i + 24);
            }
            *long long v51 = v50;
            free((void *)i);
          }
          if (dword_10008FA20)
          {
            long long v52 = ne_log_obj();
            if (os_log_type_enabled(v52, OS_LOG_TYPE_DEFAULT))
            {
              int v53 = "detected:";
              int v54 = *(_DWORD *)(a1 + 96);
              int64_t v55 = "ME ";
              if ((v54 & 6) == 0) {
                int v53 = "not detected";
              }
              if ((v54 & 2) == 0) {
                int64_t v55 = (const char *)&unk_100081F6D;
              }
              *(_DWORD *)buf = 136315650;
              *(void *)v73 = v53;
              *(_WORD *)&v73[8] = 2080;
              *(void *)&v73[10] = v55;
              if ((v54 & 4) != 0) {
                __int16 v56 = "PEER";
              }
              else {
                __int16 v56 = (const char *)&unk_100081F6D;
              }
              __int16 v74 = 2080;
              v75 = v56;
              _os_log_impl((void *)&_mh_execute_header, v52, OS_LOG_TYPE_DEFAULT, "NAT %s %s%s\n", buf, 0x20u);
            }
          }
          uint64_t v6 = v63;
          if ((*(unsigned char *)(a1 + 96) & 6) != 0) {
            sub_100040318(a1);
          }
          sub_10004F200(a1);
        }
        if ((sub_10002952C(*(void *)(*(void *)(a1 + 64) + 192), *(void **)(a1 + 160), (void **)(a1 + 168), (void *)(a1 + 136)) & 0x80000000) != 0)
        {
          if (dword_10008FA20)
          {
            unsigned int v58 = ne_log_obj();
            if (os_log_type_enabled(v58, OS_LOG_TYPE_ERROR)) {
              sub_10005B07C();
            }
          }
          goto LABEL_91;
        }
        if ((sub_10002CDA4(a1) & 0x80000000) != 0)
        {
          if (dword_10008FA20)
          {
            int v59 = ne_log_obj();
            if (os_log_type_enabled(v59, OS_LOG_TYPE_ERROR)) {
              sub_10005B0B0();
            }
          }
          goto LABEL_91;
        }
        if ((sub_10002D164(a1) & 0x80000000) != 0)
        {
          if (dword_10008FA20)
          {
            char v60 = ne_log_obj();
            if (os_log_type_enabled(v60, OS_LOG_TYPE_ERROR)) {
              sub_10005B0E4();
            }
          }
          goto LABEL_91;
        }
        if ((sub_10002D410((void *)a1) & 0x80000000) != 0)
        {
          if (!dword_10008FA20) {
            goto LABEL_91;
          }
          CFTypeID v61 = ne_log_obj();
          if (os_log_type_enabled(v61, OS_LOG_TYPE_ERROR)) {
            sub_10005B118();
          }
          goto LABEL_110;
        }
        if ((sub_10002D828(a1) & 0x80000000) != 0)
        {
          if (dword_10008FA20)
          {
            __int16 v62 = ne_log_obj();
            if (os_log_type_enabled(v62, OS_LOG_TYPE_ERROR)) {
              sub_10005B14C();
            }
          }
          goto LABEL_110;
        }
        uint64_t v22 = sub_10002ABA8(a1);
        if (v22 == -1)
        {
          char v21 = 0;
          goto LABEL_92;
        }
        if (!v22)
        {
          sub_10002CAB4(a1);
          sub_100002728(v3, 5250);
          char v21 = 1;
          sub_1000496DC(1, 1, a1, 0);
          goto LABEL_92;
        }
        sub_10001AD08(a1, v22, 0);
        goto LABEL_91;
      case 1u:
      case 2u:
      case 3u:
      case 0xCu:
      case 0xEu:
      case 0x10u:
      case 0x11u:
      case 0x12u:
      case 0x13u:
        goto LABEL_56;
      case 4u:
        if ((sub_1000261F4((size_t **)(a1 + 160), *((void *)v7 + 1)) & 0x80000000) == 0) {
          continue;
        }
        if (!dword_10008FA20) {
          goto LABEL_110;
        }
        uint64_t v27 = ne_log_obj();
        uint64_t v6 = v63;
        if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR)) {
          sub_10005B1B4();
        }
        goto LABEL_91;
      case 5u:
        if ((sub_1000261F4((size_t **)(a1 + 320), *((void *)v7 + 1)) & 0x80000000) == 0) {
          continue;
        }
        if (!dword_10008FA20) {
          goto LABEL_110;
        }
        int v28 = ne_log_obj();
        uint64_t v6 = v63;
        if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR)) {
          sub_10005B21C();
        }
        goto LABEL_91;
      case 6u:
        if ((sub_10002C5EC(a1, *((void *)v7 + 1)) & 0x80000000) != 0)
        {
          if (dword_10008FA20)
          {
            unsigned int v29 = ne_log_obj();
            uint64_t v6 = v63;
            if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR)) {
              sub_10005B284();
            }
            goto LABEL_91;
          }
LABEL_110:
          char v21 = 0;
          uint64_t v22 = 0xFFFFFFFFLL;
          uint64_t v6 = v63;
          goto LABEL_92;
        }
        int v8 = 1;
        continue;
      case 7u:
        if ((sub_10002C89C(a1, *((void *)v7 + 1)) & 0x80000000) == 0) {
          continue;
        }
        if (!dword_10008FA20) {
          goto LABEL_110;
        }
        int v30 = ne_log_obj();
        uint64_t v6 = v63;
        if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR)) {
          sub_10005B250();
        }
        goto LABEL_91;
      case 8u:
        *(void *)(a1 + 352) = *((void *)v7 + 1);
        continue;
      case 9u:
        if ((sub_1000261F4((size_t **)(a1 + 272), *((void *)v7 + 1)) & 0x80000000) == 0) {
          continue;
        }
        if (!dword_10008FA20) {
          goto LABEL_110;
        }
        unsigned int v31 = ne_log_obj();
        uint64_t v6 = v63;
        if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR)) {
          sub_10005B2B8();
        }
        goto LABEL_91;
      case 0xAu:
        if ((sub_1000261F4(v64, *((void *)v7 + 1)) & 0x80000000) == 0) {
          continue;
        }
        if (!dword_10008FA20) {
          goto LABEL_110;
        }
        unsigned int v32 = ne_log_obj();
        uint64_t v6 = v63;
        if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR)) {
          sub_10005B1E8();
        }
        goto LABEL_91;
      case 0xBu:
        sub_10001B78C(*((void *)v7 + 1), a1);
        continue;
      case 0xDu:
        int v15 = sub_10003F7B0(*((void *)v7 + 1));
        int v16 = v15;
        if (*(_DWORD *)(*(void *)(a1 + 64) + 176) && sub_10003FB98(v15)) {
          sub_1000403F4(a1, v16);
        }
        switch(v16)
        {
          case 16:
            **(_DWORD **)(a1 + 408) |= 1u;
            break;
          case 17:
            **(_DWORD **)(a1 + 408) |= 2u;
            break;
          case 18:
            if ((sub_100014BFC(*((void *)v7 + 1)) & 0x80000000) != 0)
            {
              if (dword_10008FA20)
              {
                int v17 = ne_log_obj();
                if (os_log_type_enabled(v17, OS_LOG_TYPE_DEBUG)) {
                  sub_10005B318(&v65, v66);
                }
              }
              *(_DWORD *)(a1 + 100) = 1;
            }
            break;
          case 19:
            if (*(_DWORD *)(*(void *)(a1 + 64) + 208))
            {
              *(_DWORD *)(a1 + 368) = 1;
              if (dword_10008FA20)
              {
                BOOL v18 = ne_log_obj();
                if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG)) {
                  sub_10005B2EC(&v67, v68);
                }
              }
            }
            break;
          default:
            continue;
        }
        continue;
      case 0xFu:
      case 0x14u:
        goto LABEL_10;
      default:
        if (v10 != 130)
        {
LABEL_56:
          if (dword_10008FA20)
          {
            unsigned int v25 = ne_log_obj();
            uint64_t v6 = v63;
            if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR)) {
              sub_10005AFA8();
            }
            goto LABEL_91;
          }
          goto LABEL_110;
        }
LABEL_10:
        if ((*(unsigned char *)(a1 + 96) & 1) == 0) {
          continue;
        }
        uint64_t v11 = *(void *)(a1 + 88);
        if (!v11 || *(unsigned __int16 *)(v11 + 14) != v10) {
          continue;
        }
        int v12 = malloc_type_malloc(0x20uLL, 0x10A00400E9F9246uLL);
        if (v12)
        {
          unsigned int v13 = (uint64_t *)v12;
          *((void *)v12 + 1) = 0;
          if ((sub_1000261F4((size_t **)v12 + 1, *((void *)v7 + 1)) & 0x80000000) != 0)
          {
            if (dword_10008FA20)
            {
              __int16 v40 = ne_log_obj();
              if (os_log_type_enabled(v40, OS_LOG_TYPE_ERROR)) {
                sub_10005B378();
              }
            }
            free(v13);
            goto LABEL_110;
          }
          *(_DWORD *)unsigned int v13 = v9;
          _DWORD v13[2] = 0;
          ++v9;
          uint64_t v14 = v70;
          v13[3] = (uint64_t)v70;
          uint64_t *v14 = (uint64_t)v13;
          v70 = v13 + 2;
          continue;
        }
        if (!dword_10008FA20) {
          goto LABEL_110;
        }
        uint64_t v34 = ne_log_obj();
        uint64_t v6 = v63;
        if (os_log_type_enabled(v34, OS_LOG_TYPE_ERROR)) {
          sub_10005B344();
        }
LABEL_91:
        char v21 = 0;
        uint64_t v22 = 0xFFFFFFFFLL;
LABEL_92:
        sub_10003FA78(v6);
LABEL_93:
        if (v71) {
          sub_10003FA78(v71);
        }
        if ((v21 & 1) == 0)
        {
          uint64_t v35 = *(void **)(a1 + 160);
          if (v35)
          {
            sub_10003FA78(v35);
            *(void *)(a1 + 160) = 0;
          }
          uint64_t v36 = *(void **)(a1 + 184);
          if (v36)
          {
            sub_10003FA78(v36);
            *(void *)(a1 + 184) = 0;
          }
          size_t v37 = *(void **)(a1 + 320);
          if (v37)
          {
            sub_10003FA78(v37);
            *(void *)(a1 + 320) = 0;
          }
          sub_10002BC10(*(void **)(a1 + 288));
          *(void *)(a1 + 288) = 0;
          sub_10002BC10(*(void **)(a1 + 296));
          *(void *)(a1 + 296) = 0;
          __int16 v38 = *(void **)(a1 + 272);
          if (v38)
          {
            sub_10003FA78(v38);
            *(void *)(a1 + 272) = 0;
          }
          sub_10002BC10(*(void **)(a1 + 304));
          *(void *)(a1 + 304) = 0;
        }
        return v22;
    }
  }
}

uint64_t sub_100012B80(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (int *)(a1 + 16);
  int v2 = *(_DWORD *)(a1 + 16);
  __int16 v62 = 0;
  if (v2 != 5250)
  {
    if (dword_10008FA20)
    {
      int v12 = ne_log_obj();
      if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR)) {
        sub_10005AED8();
      }
    }
    return 0xFFFFFFFFLL;
  }
  if (dword_10008FA20)
  {
    uint64_t v6 = ne_log_obj();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG)) {
      sub_10005B6B4();
    }
  }
  uint64_t v7 = sub_10002A3E8(a1, 1);
  *(void *)(a1 + 256) = v7;
  if (!v7)
  {
    if (dword_10008FA20)
    {
      unsigned int v13 = ne_log_obj();
      if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR)) {
        sub_10005B424();
      }
    }
    return 0xFFFFFFFFLL;
  }
  uint64_t v8 = v7;
  int v9 = *(_DWORD *)(*(void *)(a1 + 72) + 48);
  if (*(void *)(*(void *)(a1 + 64) + 272)) {
    BOOL v10 = v9 == 65001;
  }
  else {
    BOOL v10 = 0;
  }
  if (v10) {
    goto LABEL_28;
  }
  uint64_t v11 = 0;
  if (v9 <= 64220)
  {
    if (v9 == 1) {
      goto LABEL_28;
    }
    if (v9 != 3) {
      goto LABEL_30;
    }
    goto LABEL_23;
  }
  switch(v9)
  {
    case 65500:
LABEL_28:
      int v15 = 0;
      int v16 = 8;
LABEL_29:
      uint64_t v11 = (uint64_t **)sub_100026474(v15, v8, v16);
      __int16 v62 = v11;
      break;
    case 65005:
LABEL_23:
      if ((sub_10002B60C(a1) & 0x80000000) != 0)
      {
        if (dword_10008FA20)
        {
          long long v49 = ne_log_obj();
          if (os_log_type_enabled(v49, OS_LOG_TYPE_ERROR)) {
            sub_10005B64C();
          }
        }
        return 0xFFFFFFFFLL;
      }
      if ((sub_10002B924((void *)a1) & 0x80000000) != 0)
      {
        if (dword_10008FA20)
        {
          long long v51 = ne_log_obj();
          if (os_log_type_enabled(v51, OS_LOG_TYPE_ERROR)) {
            sub_10005B680();
          }
        }
        return 0xFFFFFFFFLL;
      }
      uint64_t v14 = *(void *)(a1 + 280);
      if (v14 && *(_DWORD *)(*(void *)(a1 + 64) + 116)) {
        int v15 = sub_100026474(0, *(void *)(v14 + 24), 6);
      }
      else {
        int v15 = 0;
      }
      uint64_t v8 = *(void *)(a1 + 264);
      int v16 = 9;
      goto LABEL_29;
    case 64221:
      goto LABEL_28;
  }
LABEL_30:
  if ((*(unsigned char *)(a1 + 96) & 1) == 0)
  {
    int v17 = 0;
    BOOL v18 = 0;
    goto LABEL_48;
  }
  if (dword_10008FA20)
  {
    BOOL v19 = ne_log_obj();
    if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "Adding remote and local NAT-D payloads.\n", buf, 2u);
    }
  }
  uint64_t v20 = sub_10003FBA8((void *)a1, *(void *)(a1 + 48));
  if (!v20)
  {
    if (dword_10008FA20)
    {
      uint64_t v27 = ne_log_obj();
      if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR)) {
        sub_10005B5D8((const sockaddr **)(a1 + 48));
      }
    }
    return 0xFFFFFFFFLL;
  }
  int v17 = (void *)v20;
  uint64_t v21 = sub_10003FBA8((void *)a1, *(void *)(a1 + 56));
  if (!v21)
  {
    if (dword_10008FA20)
    {
      int v28 = ne_log_obj();
      if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR)) {
        sub_10005B5D8((const sockaddr **)(a1 + 56));
      }
    }
    unsigned int v29 = 0;
    int v30 = 0;
    BOOL v18 = 0;
    uint64_t v31 = 0xFFFFFFFFLL;
    goto LABEL_112;
  }
  BOOL v18 = (void *)v21;
  uint64_t v22 = *(void *)(a1 + 88);
  int v23 = *(unsigned __int16 *)(v22 + 14);
  if (*(_DWORD *)v22 == 14)
  {
    int v24 = sub_100026474(v11, v21, v23);
    int v25 = *(unsigned __int16 *)(*(void *)(a1 + 88) + 14);
    uint64_t v26 = (uint64_t)v17;
  }
  else
  {
    int v24 = sub_100026474(v11, (uint64_t)v17, v23);
    int v25 = *(unsigned __int16 *)(*(void *)(a1 + 88) + 14);
    uint64_t v26 = (uint64_t)v18;
  }
  uint64_t v11 = (uint64_t **)sub_100026474(v24, v26, v25);
  __int16 v62 = v11;
LABEL_48:
  if ((~**(_DWORD **)(a1 + 408) & 3) != 0)
  {
    int v30 = 0;
    unsigned int v29 = 0;
    goto LABEL_63;
  }
  int v32 = *(_DWORD *)(*(void *)(a1 + 72) + 48);
  if ((v32 != 65001 || *(void *)(*(void *)(a1 + 64) + 272) == 0) && v32 == 64221)
  {
    __int16 v40 = sub_10002CBF8(a1);
    if (v40)
    {
      unsigned int v41 = v40;
      uint64_t v42 = sub_100029B74(*(void *)(a1 + 192), (uint64_t)v40, a1);
      if (v42)
      {
        uint64_t v43 = v42;
        sub_10003FA78(v41);
        unsigned int v59 = *(_DWORD *)(*(void *)(a1 + 64) + 24);
        size_t v44 = sub_10003F940(*(void *)v43 + 24);
        if (v44)
        {
          int v30 = v44;
          *(void *)v44[1] = bswap32(v59) | 0x379E100100000000;
          uint64_t v45 = v44[1];
          *(_OWORD *)(v45 + 8) = *(_OWORD *)a1;
          memcpy((void *)(v45 + 24), *(const void **)(v43 + 8), *(void *)v43);
          sub_10003FA78((void *)v43);
          uint64_t v11 = (uint64_t **)sub_100026474(v11, (uint64_t)v30, 11);
          __int16 v62 = v11;
          goto LABEL_57;
        }
        if (dword_10008FA20)
        {
          int64_t v55 = ne_log_obj();
          if (os_log_type_enabled(v55, OS_LOG_TYPE_ERROR)) {
            sub_10005B508();
          }
        }
        int v54 = (void *)v43;
      }
      else
      {
        if (dword_10008FA20)
        {
          int v53 = ne_log_obj();
          if (os_log_type_enabled(v53, OS_LOG_TYPE_ERROR)) {
            sub_10005B4D4();
          }
        }
        int v54 = v41;
      }
      sub_10003FA78(v54);
    }
    else if (dword_10008FA20)
    {
      uint64_t v50 = ne_log_obj();
      if (os_log_type_enabled(v50, OS_LOG_TYPE_ERROR)) {
        sub_10005B458(a1);
      }
    }
    int v30 = 0;
    goto LABEL_109;
  }
  int v30 = 0;
LABEL_57:
  if ((*(unsigned char *)(a1 + 432) & 1) == 0
    && *(_DWORD *)(*(void *)(a1 + 64) + 168)
    && !sub_100008AC0(*(void *)(a1 + 48)))
  {
    unsigned int v60 = *(_DWORD *)(*(void *)(a1 + 64) + 24);
    __int16 v56 = sub_10003F940(0x18uLL);
    if (v56)
    {
      unsigned int v29 = v56;
      *(void *)v56[1] = bswap32(v60) | 0x260100100000000;
      *(_OWORD *)(v56[1] + 8) = *(_OWORD *)a1;
      __int16 v62 = (uint64_t **)sub_100026474(v11, (uint64_t)v56, 11);
      if (sub_100008B08() == -1)
      {
        if (dword_10008FA20)
        {
          int v57 = ne_log_obj();
          if (os_log_type_enabled(v57, OS_LOG_TYPE_ERROR)) {
            sub_10005B5A4();
          }
        }
      }
      goto LABEL_61;
    }
    if (dword_10008FA20)
    {
      unsigned int v58 = ne_log_obj();
      if (os_log_type_enabled(v58, OS_LOG_TYPE_ERROR)) {
        sub_10005B508();
      }
    }
LABEL_109:
    unsigned int v29 = 0;
    goto LABEL_110;
  }
  unsigned int v29 = 0;
LABEL_61:
  *(unsigned char *)(a1 + 82) |= 1u;
LABEL_63:
  uint64_t v35 = sub_1000264D0(&v62, a1);
  *(void *)(a1 + 128) = v35;
  if ((~**(_DWORD **)(a1 + 408) & 3) == 0)
  {
    uint64_t v36 = sub_10002E41C(a1, (uint64_t)v35, *(void *)(*(void *)(a1 + 328) + 8), **(void **)(a1 + 328));
    if (!v36)
    {
      if (dword_10008FA20)
      {
        int v48 = ne_log_obj();
        if (os_log_type_enabled(v48, OS_LOG_TYPE_ERROR)) {
          sub_10005B53C();
        }
      }
      goto LABEL_110;
    }
    uint64_t v35 = v36;
    sub_10003FA78(*(void **)(a1 + 128));
    *(void *)(a1 + 128) = v35;
  }
  if ((sub_100023E30(a1, v35) & 0x80000000) != 0)
  {
    if (dword_10008FA20)
    {
      int v46 = ne_log_obj();
      if (os_log_type_enabled(v46, OS_LOG_TYPE_ERROR)) {
        sub_10005AD0C();
      }
    }
  }
  else
  {
    size_t v37 = *(void **)(a1 + 128);
    if (*(_DWORD *)(a1 + 100) && *v37 >= 0x501uLL)
    {
      uint64_t v38 = 0;
      LODWORD(v39) = *(_DWORD *)(a1 + 96);
    }
    else
    {
      unint64_t v39 = *(unsigned int *)(a1 + 96);
      uint64_t v38 = (v39 >> 3) & 4;
    }
    if (sub_100009070(*(void *)(a1 + 48), *(void *)(a1 + 56), (uint64_t)v37, a2, v38, (v39 >> 5) & 1) != -1)
    {
      *(unsigned char *)(a1 + 82) |= 1u;
      sub_100002728(v3, 9216);
      uint64_t v31 = 0;
      goto LABEL_111;
    }
    if (dword_10008FA20)
    {
      __int16 v47 = ne_log_obj();
      if (os_log_type_enabled(v47, OS_LOG_TYPE_ERROR)) {
        sub_10005B570();
      }
    }
  }
LABEL_110:
  uint64_t v31 = 0xFFFFFFFFLL;
LABEL_111:
  if (v17) {
LABEL_112:
  }
    sub_10003FA78(v17);
  if (v18) {
    sub_10003FA78(v18);
  }
  if (v30) {
    sub_10003FA78(v30);
  }
  if (v29) {
    sub_10003FA78(v29);
  }
  return v31;
}

uint64_t sub_1000132C0(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (int *)(a1 + 16);
  if (*(_DWORD *)(a1 + 16) == 5504)
  {
    uint64_t v4 = sub_100022FA8(a2);
    if (v4)
    {
      uint64_t v5 = v4;
      uint64_t v6 = (unsigned __int8 *)v4[1];
      if (*v6 == 1)
      {
        if ((sub_1000261F4((size_t **)(a1 + 336), *((void *)v6 + 1)) & 0x80000000) != 0)
        {
          if (dword_10008FA20)
          {
            uint64_t v22 = ne_log_obj();
            if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR)) {
              sub_10005AF74();
            }
          }
        }
        else
        {
          int v9 = v6[16];
          uint64_t v8 = v6 + 16;
          int v7 = v9;
          if (v9)
          {
            while (2)
            {
              if (dword_10008FA20)
              {
                BOOL v10 = ne_log_obj();
                if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG)) {
                  sub_10005B6F4(v43, v8, &v44, v10);
                }
                int v7 = *v8;
              }
              switch(v7)
              {
                case 4:
                  if ((sub_1000261F4((size_t **)(a1 + 160), *((void *)v8 + 1)) & 0x80000000) == 0) {
                    goto LABEL_35;
                  }
                  if (dword_10008FA20)
                  {
                    int v32 = ne_log_obj();
                    if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR)) {
                      sub_10005B1B4();
                    }
                  }
                  goto LABEL_58;
                case 5:
                  if ((sub_1000261F4((size_t **)(a1 + 320), *((void *)v8 + 1)) & 0x80000000) == 0) {
                    goto LABEL_35;
                  }
                  if (dword_10008FA20)
                  {
                    char v33 = ne_log_obj();
                    if (os_log_type_enabled(v33, OS_LOG_TYPE_ERROR)) {
                      sub_10005B21C();
                    }
                  }
                  goto LABEL_58;
                case 7:
                  if ((sub_10002C89C(a1, *((void *)v8 + 1)) & 0x80000000) == 0) {
                    goto LABEL_35;
                  }
                  if (dword_10008FA20)
                  {
                    uint64_t v34 = ne_log_obj();
                    if (os_log_type_enabled(v34, OS_LOG_TYPE_ERROR)) {
                      sub_10005B250();
                    }
                  }
                  goto LABEL_58;
                case 10:
                  if ((sub_1000261F4((size_t **)(a1 + 184), *((void *)v8 + 1)) & 0x80000000) == 0) {
                    goto LABEL_35;
                  }
                  if (dword_10008FA20)
                  {
                    uint64_t v35 = ne_log_obj();
                    if (os_log_type_enabled(v35, OS_LOG_TYPE_ERROR)) {
                      sub_10005B1E8();
                    }
                  }
                  goto LABEL_58;
                case 13:
                  int v11 = sub_10003F7B0(*((void *)v8 + 1));
                  int v12 = v11;
                  if (*(_DWORD *)(*(void *)(a1 + 64) + 176) && sub_10003FB98(v11))
                  {
                    sub_1000403F4(a1, v12);
                  }
                  else
                  {
                    switch(v12)
                    {
                      case 16:
                        unsigned int v13 = *(int **)(a1 + 408);
                        int v14 = *v13 | 1;
                        goto LABEL_25;
                      case 17:
                        unsigned int v13 = *(int **)(a1 + 408);
                        int v14 = *v13 | 2;
LABEL_25:
                        *unsigned int v13 = v14;
                        break;
                      case 18:
                        if ((sub_100014BFC(*((void *)v8 + 1)) & 0x80000000) != 0)
                        {
                          if (dword_10008FA20)
                          {
                            int v15 = ne_log_obj();
                            if (os_log_type_enabled(v15, OS_LOG_TYPE_DEBUG)) {
                              sub_10005B318(&v37, v38);
                            }
                          }
                          *(_DWORD *)(a1 + 100) = 1;
                        }
                        break;
                      case 19:
                        if (*(_DWORD *)(*(void *)(a1 + 64) + 208))
                        {
                          *(_DWORD *)(a1 + 368) = 1;
                          if (dword_10008FA20)
                          {
                            int v16 = ne_log_obj();
                            if (os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG)) {
                              sub_10005B2EC(&v39, v40);
                            }
                          }
                        }
                        break;
                      default:
                        break;
                    }
                  }
LABEL_35:
                  int v17 = v8[16];
                  v8 += 16;
                  int v7 = v17;
                  if (!v17) {
                    break;
                  }
                  continue;
                default:
                  if (dword_10008FA20)
                  {
                    uint64_t v31 = ne_log_obj();
                    if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR)) {
                      sub_10005AFA8();
                    }
                  }
                  goto LABEL_58;
              }
              break;
            }
          }
          if (*(void *)(a1 + 160) && *(void *)(a1 + 184))
          {
            if (sub_10000F124(a1))
            {
              if (dword_10008FA20)
              {
                uint64_t v21 = ne_log_obj();
                if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR)) {
                  sub_10005B180();
                }
              }
            }
            else
            {
              if (*(unsigned char *)(a1 + 96))
              {
                if (dword_10008FA20)
                {
                  unsigned int v29 = ne_log_obj();
                  if (os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
                  {
                    int v30 = sub_10003F504(**(_DWORD **)(a1 + 88));
                    *(_DWORD *)buf = 136315138;
                    uint64_t v42 = v30;
                    _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEFAULT, "Selected NAT-T version: %s\n", buf, 0xCu);
                  }
                }
                sub_10004F200(a1);
              }
              if ((sub_10000A144(*(unint64_t **)(a1 + 336), (void *)a1) & 0x80000000) == 0)
              {
                sub_10002CAB4(a1);
                sub_100002728(v3, 5505);
                sub_10003FA78(v5);
                return 0;
              }
              if (dword_10008FA20)
              {
                uint64_t v36 = ne_log_obj();
                if (os_log_type_enabled(v36, OS_LOG_TYPE_ERROR)) {
                  sub_10005B048();
                }
              }
            }
          }
          else if (dword_10008FA20)
          {
            int v23 = ne_log_obj();
            if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR)) {
              sub_10005B014();
            }
          }
        }
      }
      else if (dword_10008FA20)
      {
        uint64_t v20 = ne_log_obj();
        if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR)) {
          sub_10005B3AC();
        }
      }
LABEL_58:
      sub_10003FA78(v5);
    }
    else if (dword_10008FA20)
    {
      BOOL v19 = ne_log_obj();
      if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR)) {
        sub_10005AF40();
      }
    }
  }
  else if (dword_10008FA20)
  {
    BOOL v18 = ne_log_obj();
    if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR)) {
      sub_10005AED8();
    }
  }
  int v24 = *(void **)(a1 + 336);
  if (v24)
  {
    sub_10003FA78(v24);
    *(void *)(a1 + 336) = 0;
  }
  int v25 = *(void **)(a1 + 160);
  if (v25)
  {
    sub_10003FA78(v25);
    *(void *)(a1 + 160) = 0;
  }
  uint64_t v26 = *(void **)(a1 + 184);
  if (v26)
  {
    sub_10003FA78(v26);
    *(void *)(a1 + 184) = 0;
  }
  uint64_t v27 = *(void **)(a1 + 320);
  if (v27)
  {
    sub_10003FA78(v27);
    *(void *)(a1 + 320) = 0;
  }
  sub_10002BC10(*(void **)(a1 + 304));
  *(void *)(a1 + 304) = 0;
  return 0xFFFFFFFFLL;
}

uint64_t sub_1000138F8(uint64_t a1, uint64_t a2)
{
  __int16 v74 = 0;
  int v2 = (int *)(a1 + 16);
  if (*(_DWORD *)(a1 + 16) != 5505)
  {
    if (dword_10008FA20)
    {
      BOOL v10 = ne_log_obj();
      if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR)) {
        sub_10005AED8();
      }
    }
    return 0xFFFFFFFFLL;
  }
  sub_100025FD0((void *)(a1 + 8), *(void *)(a1 + 48), *(void *)(a1 + 56));
  if ((sub_10000F71C(a1) & 0x80000000) != 0)
  {
    if (dword_10008FA20)
    {
      int v11 = ne_log_obj();
      if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR)) {
        sub_10005AC08();
      }
    }
    return 0xFFFFFFFFLL;
  }
  if ((sub_10002972C(*(void *)(*(void *)(a1 + 64) + 192), (size_t **)(a1 + 152), (void *)(a1 + 136)) & 0x80000000) != 0)
  {
    if (dword_10008FA20)
    {
      int v12 = ne_log_obj();
      if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR)) {
        sub_10005ACA4();
      }
    }
    return 0xFFFFFFFFLL;
  }
  uint64_t v5 = sub_10000601C(*(_DWORD *)(*(void *)(a1 + 64) + 140));
  *(void *)(a1 + 176) = v5;
  if (!v5)
  {
    if (dword_10008FA20)
    {
      unsigned int v13 = ne_log_obj();
      if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR)) {
        sub_10005ACD8();
      }
    }
    return 0xFFFFFFFFLL;
  }
  if ((sub_10002952C(*(void *)(*(void *)(a1 + 72) + 64), *(void **)(a1 + 160), (void **)(a1 + 168), (void *)(a1 + 136)) & 0x80000000) != 0)
  {
    if (dword_10008FA20)
    {
      int v14 = ne_log_obj();
      if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR)) {
        sub_10005B07C();
      }
    }
    return 0xFFFFFFFFLL;
  }
  if ((sub_10002CDA4(a1) & 0x80000000) != 0)
  {
    if (dword_10008FA20)
    {
      int v15 = ne_log_obj();
      if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR)) {
        sub_10005B0B0();
      }
    }
    return 0xFFFFFFFFLL;
  }
  if ((sub_10002D164(a1) & 0x80000000) != 0)
  {
    if (dword_10008FA20)
    {
      int v16 = ne_log_obj();
      if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR)) {
        sub_10005B0E4();
      }
    }
    return 0xFFFFFFFFLL;
  }
  if ((sub_10002D410((void *)a1) & 0x80000000) != 0)
  {
    if (dword_10008FA20)
    {
      int v17 = ne_log_obj();
      if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR)) {
        sub_10005B118();
      }
    }
    return 0xFFFFFFFFLL;
  }
  if ((sub_10002D828(a1) & 0x80000000) != 0)
  {
    if (dword_10008FA20)
    {
      BOOL v18 = ne_log_obj();
      if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR)) {
        sub_10005B14C();
      }
    }
    return 0xFFFFFFFFLL;
  }
  if (dword_10008FA20)
  {
    uint64_t v6 = ne_log_obj();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG)) {
      sub_10005B8CC();
    }
  }
  uint64_t v7 = sub_10002A3E8(a1, 1);
  *(void *)(a1 + 256) = v7;
  if (!v7)
  {
    if (dword_10008FA20)
    {
      uint64_t v20 = ne_log_obj();
      if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR)) {
        sub_10005B760();
      }
    }
    return 0xFFFFFFFFLL;
  }
  if (*(_DWORD *)(*(void *)(a1 + 64) + 120) && sub_10002CBD4(*(_DWORD *)(*(void *)(a1 + 72) + 48)))
  {
    uint64_t v8 = sub_10002C9C0(a1);
    if (v8)
    {
      uint64_t v70 = (uint64_t)v8;
      char v9 = 0;
      goto LABEL_46;
    }
    if (dword_10008FA20)
    {
      int v32 = ne_log_obj();
      if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR)) {
        sub_10005B898();
      }
    }
    return 0xFFFFFFFFLL;
  }
  uint64_t v70 = 0;
  char v9 = 1;
LABEL_46:
  if (*(unsigned char *)(a1 + 96))
  {
    v71 = sub_10003F70C(**(_DWORD **)(a1 + 88));
    if (dword_10008FA20)
    {
      int v23 = ne_log_obj();
      if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "Adding remote and local NAT-D payloads.\n", buf, 2u);
      }
    }
    uint64_t v24 = sub_10003FBA8((void *)a1, *(void *)(a1 + 48));
    if (v24)
    {
      BOOL v19 = (void *)v24;
      uint64_t v69 = sub_10003FBA8((void *)a1, *(void *)(a1 + 56));
      if (v69) {
        goto LABEL_58;
      }
      if (dword_10008FA20)
      {
        char v37 = ne_log_obj();
        unsigned int v29 = v71;
        if (os_log_type_enabled(v37, OS_LOG_TYPE_ERROR)) {
          sub_10005B5D8((const sockaddr **)(a1 + 56));
        }
        int v30 = 0;
        uint64_t v31 = 0;
LABEL_96:
        uint64_t v38 = 0;
        int v25 = 0;
        uint64_t v27 = 0;
LABEL_155:
        uint64_t v21 = 0xFFFFFFFFLL;
        int v46 = (void *)v70;
        goto LABEL_160;
      }
      int v30 = 0;
      uint64_t v31 = 0;
    }
    else
    {
      if (dword_10008FA20)
      {
        int v28 = ne_log_obj();
        unsigned int v29 = v71;
        if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR)) {
          sub_10005B5D8((const sockaddr **)(a1 + 48));
        }
        int v30 = 0;
        uint64_t v31 = 0;
        BOOL v19 = 0;
        goto LABEL_96;
      }
      int v30 = 0;
      uint64_t v31 = 0;
      BOOL v19 = 0;
    }
    uint64_t v38 = 0;
    int v25 = 0;
    uint64_t v27 = 0;
    goto LABEL_104;
  }
  v71 = 0;
  BOOL v19 = 0;
  uint64_t v69 = 0;
LABEL_58:
  if (*(_DWORD *)(a1 + 368) && *(_DWORD *)(*(void *)(a1 + 64) + 208)) {
    int v25 = sub_10003F70C(19);
  }
  else {
    int v25 = 0;
  }
  if (*(_DWORD *)(a1 + 100))
  {
    uint64_t v26 = (void **)sub_10003F70C(18);
    if (v26) {
      uint64_t v27 = sub_100015144(v26, 0x80000000);
    }
    else {
      uint64_t v27 = 0;
    }
    if (v27 || !dword_10008FA20) {
      goto LABEL_78;
    }
    char v33 = ne_log_obj();
    if (os_log_type_enabled(v33, OS_LOG_TYPE_ERROR)) {
      sub_10005B864();
    }
  }
  uint64_t v27 = 0;
LABEL_78:
  int v34 = *(_DWORD *)(*(void *)(a1 + 72) + 48);
  if (*(void *)(*(void *)(a1 + 64) + 272) && v34 == 65001)
  {
    uint64_t v35 = 0;
    goto LABEL_114;
  }
  uint64_t v35 = 0;
  if (v34 <= 64221)
  {
    if (v34 == 1)
    {
LABEL_97:
      char v39 = sub_100026474(0, *(void *)(a1 + 344), 1);
      __int16 v40 = sub_100026474(v39, *(void *)(a1 + 152), 4);
      unsigned int v41 = sub_100026474(v40, *(void *)(a1 + 176), 10);
      uint64_t v42 = sub_100026474(v41, *(void *)(a1 + 312), 5);
      uint64_t v43 = *(void *)(a1 + 256);
      int v44 = 8;
LABEL_112:
      long long v51 = (uint64_t **)sub_100026474(v42, v43, v44);
      uint64_t v35 = v51;
      __int16 v74 = v51;
      if ((v9 & 1) == 0)
      {
        uint64_t v35 = (uint64_t **)sub_100026474(v51, v70, 7);
        __int16 v74 = v35;
      }
LABEL_114:
      int v52 = **(_DWORD **)(a1 + 408);
      if ((v52 & 1) == 0)
      {
        int v30 = 0;
        goto LABEL_121;
      }
      if (dword_10008FA20)
      {
        int v53 = ne_log_obj();
        if (os_log_type_enabled(v53, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)v72 = 0;
          _os_log_impl((void *)&_mh_execute_header, v53, OS_LOG_TYPE_DEFAULT, "Adding xauth VID payload.\n", v72, 2u);
        }
      }
      int v54 = sub_10003F70C(16);
      if (v54)
      {
        int v30 = v54;
        uint64_t v35 = (uint64_t **)sub_100026474(v35, (uint64_t)v54, 13);
        __int16 v74 = v35;
        int v52 = **(_DWORD **)(a1 + 408);
LABEL_121:
        if ((v52 & 2) == 0)
        {
          uint64_t v31 = 0;
          goto LABEL_125;
        }
        int64_t v55 = sub_10003F70C(17);
        if (v55)
        {
          uint64_t v31 = v55;
          uint64_t v35 = (uint64_t **)sub_100026474(v35, (uint64_t)v55, 13);
          __int16 v74 = v35;
LABEL_125:
          if (v71)
          {
            __int16 v56 = sub_100026474(v35, (uint64_t)v71, 13);
            uint64_t v57 = *(void *)(a1 + 88);
            int v58 = *(unsigned __int16 *)(v57 + 14);
            if (*(_DWORD *)v57 == 14)
            {
              unsigned int v59 = sub_100026474(v56, v69, v58);
              int v60 = *(unsigned __int16 *)(*(void *)(a1 + 88) + 14);
              uint64_t v61 = (uint64_t)v19;
            }
            else
            {
              unsigned int v59 = sub_100026474(v56, (uint64_t)v19, v58);
              int v60 = *(unsigned __int16 *)(*(void *)(a1 + 88) + 14);
              uint64_t v61 = v69;
            }
            uint64_t v35 = (uint64_t **)sub_100026474(v59, v61, v60);
            __int16 v74 = v35;
          }
          if (v27)
          {
            uint64_t v35 = (uint64_t **)sub_100026474(v35, (uint64_t)v27, 13);
            __int16 v74 = v35;
          }
          if (v25) {
            __int16 v74 = (uint64_t **)sub_100026474(v35, (uint64_t)v25, 13);
          }
          *(void *)(a1 + 128) = sub_1000264D0(&v74, a1);
          *(_DWORD *)(a1 + 124) = *(_DWORD *)(*(void *)(a1 + 64) + 200);
          if (sub_100024104(a1) == -1)
          {
            if (dword_10008FA20)
            {
              char v65 = ne_log_obj();
              unsigned int v29 = v71;
              uint64_t v38 = (void *)v69;
              if (os_log_type_enabled(v65, OS_LOG_TYPE_ERROR)) {
                sub_10005AD0C();
              }
              goto LABEL_155;
            }
          }
          else
          {
            __int16 v62 = *(void **)(a1 + 128);
            if (*(_DWORD *)(a1 + 100) && *v62 >= 0x501uLL)
            {
              uint64_t v63 = 0;
              LODWORD(v64) = *(_DWORD *)(a1 + 96);
            }
            else
            {
              unint64_t v64 = *(unsigned int *)(a1 + 96);
              uint64_t v63 = (v64 >> 3) & 4;
            }
            if (sub_100009070(*(void *)(a1 + 48), *(void *)(a1 + 56), (uint64_t)v62, a2, v63, (v64 >> 5) & 1) != -1)
            {
              sub_100002728(v2, 5538);
              sub_1000496DC(1, 0, a1, 0);
              uint64_t v21 = 0;
LABEL_159:
              int v46 = (void *)v70;
              unsigned int v29 = v71;
              uint64_t v38 = (void *)v69;
              goto LABEL_160;
            }
            if (dword_10008FA20)
            {
              char v67 = ne_log_obj();
              unsigned int v29 = v71;
              uint64_t v38 = (void *)v69;
              if (os_log_type_enabled(v67, OS_LOG_TYPE_ERROR)) {
                sub_10005B794();
              }
              goto LABEL_155;
            }
          }
LABEL_158:
          uint64_t v21 = 0xFFFFFFFFLL;
          goto LABEL_159;
        }
        if (dword_10008FA20)
        {
          v68 = ne_log_obj();
          unsigned int v29 = v71;
          uint64_t v38 = (void *)v69;
          if (os_log_type_enabled(v68, OS_LOG_TYPE_ERROR)) {
            sub_10005B7C8();
          }
          goto LABEL_154;
        }
LABEL_157:
        uint64_t v31 = 0;
        goto LABEL_158;
      }
      if (dword_10008FA20)
      {
        __int16 v66 = ne_log_obj();
        unsigned int v29 = v71;
        uint64_t v38 = (void *)v69;
        if (os_log_type_enabled(v66, OS_LOG_TYPE_ERROR)) {
          sub_10005B7FC();
        }
LABEL_147:
        int v30 = 0;
LABEL_154:
        uint64_t v31 = 0;
        goto LABEL_155;
      }
LABEL_156:
      int v30 = 0;
      goto LABEL_157;
    }
    if (v34 != 3) {
      goto LABEL_114;
    }
  }
  else if (v34 != 64222 && v34 != 65006)
  {
    if (v34 != 65002) {
      goto LABEL_114;
    }
    goto LABEL_97;
  }
  if ((sub_10002B60C(a1) & 0x80000000) != 0)
  {
    if (dword_10008FA20)
    {
      uint64_t v45 = ne_log_obj();
      unsigned int v29 = v71;
      uint64_t v38 = (void *)v69;
      if (os_log_type_enabled(v45, OS_LOG_TYPE_ERROR)) {
        sub_10005B830();
      }
      goto LABEL_147;
    }
    goto LABEL_156;
  }
  if ((sub_10002B924((void *)a1) & 0x80000000) == 0)
  {
    if (*(void *)(a1 + 280)) {
      BOOL v36 = *(_DWORD *)(*(void *)(a1 + 64) + 116) == 0;
    }
    else {
      BOOL v36 = 1;
    }
    int v48 = sub_100026474(0, *(void *)(a1 + 344), 1);
    long long v49 = sub_100026474(v48, *(void *)(a1 + 152), 4);
    uint64_t v50 = sub_100026474(v49, *(void *)(a1 + 176), 10);
    uint64_t v42 = sub_100026474(v50, *(void *)(a1 + 312), 5);
    if (!v36) {
      uint64_t v42 = sub_100026474(v42, *(void *)(*(void *)(a1 + 280) + 24), 6);
    }
    uint64_t v43 = *(void *)(a1 + 264);
    int v44 = 9;
    goto LABEL_112;
  }
  uint64_t v38 = (void *)v69;
  if (dword_10008FA20)
  {
    __int16 v47 = ne_log_obj();
    unsigned int v29 = v71;
    if (os_log_type_enabled(v47, OS_LOG_TYPE_ERROR)) {
      sub_10005B680();
    }
    goto LABEL_147;
  }
  int v30 = 0;
  uint64_t v31 = 0;
LABEL_104:
  uint64_t v21 = 0xFFFFFFFFLL;
  int v46 = (void *)v70;
  unsigned int v29 = v71;
LABEL_160:
  if (v46) {
    sub_10003FA78(v46);
  }
  if (v30) {
    sub_10003FA78(v30);
  }
  if (v31) {
    sub_10003FA78(v31);
  }
  if (v29) {
    sub_10003FA78(v29);
  }
  if (v19) {
    sub_10003FA78(v19);
  }
  if (v38) {
    sub_10003FA78(v38);
  }
  if (v25) {
    sub_10003FA78(v25);
  }
  if (v27) {
    sub_10003FA78(v27);
  }
  return v21;
}

uint64_t sub_100014348(uint64_t a1, void *a2)
{
  uint64_t v3 = (int *)(a1 + 16);
  if (*(_DWORD *)(a1 + 16) != 5538)
  {
    if (dword_10008FA20)
    {
      uint64_t v5 = ne_log_obj();
      if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR)) {
        sub_10005AED8();
      }
    }
    goto LABEL_7;
  }
  if (*(unsigned char *)(a2[1] + 19))
  {
    uint64_t v4 = sub_10002E028(a1, a2, **(void **)(a1 + 328), *(void *)(*(void *)(a1 + 328) + 8));
    if (v4) {
      goto LABEL_9;
    }
    if (dword_10008FA20)
    {
      uint64_t v26 = ne_log_obj();
      if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR)) {
        sub_10005B9A8();
      }
    }
LABEL_7:
    uint64_t v6 = 0xFFFFFFFFLL;
    goto LABEL_76;
  }
  uint64_t v4 = sub_10003FAC0((uint64_t)a2);
LABEL_9:
  uint64_t v7 = sub_100022FA8((uint64_t)v4);
  if (!v7)
  {
    if (dword_10008FA20)
    {
      BOOL v18 = ne_log_obj();
      if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR)) {
        sub_10005AF40();
      }
    }
    char v19 = 0;
    uint64_t v6 = 0xFFFFFFFFLL;
    if (v4) {
      goto LABEL_74;
    }
    goto LABEL_75;
  }
  uint64_t v8 = v7;
  int v9 = 0;
  int v10 = 0;
  *(void *)(a1 + 352) = 0;
  int v11 = (unsigned __int8 *)v7[1];
  while (2)
  {
    int v12 = *v11;
    switch(*v11)
    {
      case 6u:
        if ((sub_10002C5EC(a1, *((void *)v11 + 1)) & 0x80000000) == 0)
        {
          int v10 = 1;
          goto LABEL_32;
        }
        if (dword_10008FA20)
        {
          int v28 = ne_log_obj();
          if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR)) {
            sub_10005B90C();
          }
        }
        goto LABEL_72;
      case 7u:
      case 0xAu:
      case 0xCu:
      case 0xEu:
      case 0xFu:
      case 0x10u:
      case 0x11u:
      case 0x12u:
      case 0x13u:
        goto LABEL_58;
      case 8u:
        *(void *)(a1 + 352) = *((void *)v11 + 1);
        goto LABEL_32;
      case 9u:
        if ((sub_1000261F4((size_t **)(a1 + 272), *((void *)v11 + 1)) & 0x80000000) == 0) {
          goto LABEL_32;
        }
        if (dword_10008FA20)
        {
          unsigned int v29 = ne_log_obj();
          if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR)) {
            sub_10005B940();
          }
        }
        goto LABEL_72;
      case 0xBu:
        sub_10001B78C(*((void *)v11 + 1), a1);
        goto LABEL_32;
      case 0xDu:
        sub_10003F7B0(*((void *)v11 + 1));
        goto LABEL_32;
      case 0x14u:
        goto LABEL_15;
      default:
        if (v12 == 130)
        {
LABEL_15:
          if (*(unsigned char *)(a1 + 96))
          {
            uint64_t v13 = *(void *)(a1 + 88);
            if (v13)
            {
              if (*(unsigned __int16 *)(v13 + 14) == v12)
              {
                char v33 = 0;
                if ((sub_1000261F4((size_t **)&v33, *((void *)v11 + 1)) & 0x80000000) != 0)
                {
                  if (dword_10008FA20)
                  {
                    int v30 = ne_log_obj();
                    if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR)) {
                      sub_10005B974();
                    }
                  }
LABEL_72:
                  char v19 = 0;
                  uint64_t v6 = 0xFFFFFFFFLL;
                  goto LABEL_73;
                }
                if (!v9) {
                  *(_DWORD *)(a1 + 96) |= 6u;
                }
                int v14 = sub_10003FD90(a1, (uint64_t)v33, v9);
                if (dword_10008FA20)
                {
                  int v15 = v14;
                  int v16 = ne_log_obj();
                  if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
                  {
                    *(_DWORD *)buf = 67109378;
                    int v17 = "verified";
                    if (!v15) {
                      int v17 = "doesn't match";
                    }
                    *(_DWORD *)uint64_t v35 = v9;
                    *(_WORD *)&v35[4] = 2080;
                    *(void *)&v35[6] = v17;
                    _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "NAT-D payload #%d %s\n", buf, 0x12u);
                  }
                }
                ++v9;
                sub_10003FA78(v33);
              }
            }
          }
LABEL_32:
          v11 += 16;
          continue;
        }
        if (*v11)
        {
LABEL_58:
          if (dword_10008FA20)
          {
            uint64_t v27 = ne_log_obj();
            if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR)) {
              sub_10005AFA8();
            }
          }
          goto LABEL_72;
        }
        if (*(unsigned char *)(a1 + 96))
        {
          if (dword_10008FA20)
          {
            uint64_t v20 = ne_log_obj();
            if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
            {
              uint64_t v21 = "detected:";
              int v22 = *(_DWORD *)(a1 + 96);
              int v23 = "ME ";
              if ((v22 & 6) == 0) {
                uint64_t v21 = "not detected";
              }
              if ((v22 & 2) == 0) {
                int v23 = (const char *)&unk_100081F6D;
              }
              *(_DWORD *)buf = 136315650;
              *(void *)uint64_t v35 = v21;
              *(_WORD *)&v35[8] = 2080;
              *(void *)&v35[10] = v23;
              if ((v22 & 4) != 0) {
                uint64_t v24 = "PEER";
              }
              else {
                uint64_t v24 = (const char *)&unk_100081F6D;
              }
              __int16 v36 = 2080;
              char v37 = v24;
              _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "NAT %s %s%s\n", buf, 0x20u);
            }
          }
        }
        if (v10) {
          sub_10002BB90((void *)a1);
        }
        uint64_t v25 = sub_10002ABA8(a1);
        uint64_t v6 = v25;
        if (v25 == -1)
        {
          char v19 = 0;
        }
        else
        {
          if (v25)
          {
            sub_10001AD08(a1, v25, 0);
            goto LABEL_72;
          }
          sub_100002728(v3, 5507);
          char v19 = 1;
        }
LABEL_73:
        sub_10003FA78(v8);
        if (v4) {
LABEL_74:
        }
          sub_10003FA78(v4);
LABEL_75:
        if ((v19 & 1) == 0)
        {
LABEL_76:
          sub_10002BC10(*(void **)(a1 + 288));
          *(void *)(a1 + 288) = 0;
          sub_10002BC10(*(void **)(a1 + 296));
          *(void *)(a1 + 296) = 0;
          uint64_t v31 = *(void **)(a1 + 272);
          if (v31)
          {
            sub_10003FA78(v31);
            *(void *)(a1 + 272) = 0;
          }
        }
        return v6;
    }
  }
}

uint64_t sub_1000148A8(uint64_t a1, uint64_t a2)
{
  int v2 = (int *)(a1 + 16);
  if (*(_DWORD *)(a1 + 16) == 5507)
  {
    if (*(unsigned char *)(*(void *)(a2 + 8) + 19)) {
      memcpy(*(void **)(**(void **)(a1 + 328) + 8), *(const void **)(*(void *)(*(void *)(a1 + 328) + 8) + 8), ***(void ***)(a1 + 328));
    }
    *(unsigned char *)(a1 + 82) |= 1u;
    sub_100002728(v2, 9216);
    return 0;
  }
  else
  {
    if (dword_10008FA20)
    {
      uint64_t v5 = ne_log_obj();
      if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR)) {
        sub_10005AED8();
      }
    }
    return 0xFFFFFFFFLL;
  }
}

void sub_100014954(void *a1, uint64_t a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_error_impl(a1, v9, OS_LOG_TYPE_ERROR, a4, &a9, 0xCu);
}

uint64_t *sub_10001499C(const sockaddr **a1)
{
  int v2 = *a1;
  return sub_10003CAE4(v2);
}

uint64_t sub_1000149B4(uint64_t a1, unint64_t *a2)
{
  int v4 = *(_DWORD *)(a1 + 96);
  int v5 = sub_100006E58(*(unsigned __int8 **)(a1 + 56));
  if (v5 == -1) {
    return 0xFFFFFFFFLL;
  }
  unint64_t v6 = *a2;
  if (*a2)
  {
    int v7 = v5;
    LODWORD(v8) = 0;
    int v9 = v4 & 0x20;
    unint64_t v10 = (unint64_t)(v4 & 0x20) >> 3;
    int v11 = (unsigned char *)a2[1];
    char v38 = v11[18];
    while (1)
    {
      size_t v12 = v6 >= 0x4DC ? 1244 : v6;
      uint64_t v13 = sub_10003F940(v12 + 36);
      if (!v13) {
        break;
      }
      int v14 = v13;
      uint64_t v8 = (v8 + 1);
      sub_100026364((uint64_t)v13, a1, 132);
      size_t v15 = v14[1];
      *(unsigned char *)(v15 + 18) = v38;
      *(_WORD *)(v15 + 28) = 0;
      *(_WORD *)(v15 + 30) = bswap32(v12 + 8) >> 16;
      *(_WORD *)(v15 + 32) = 256;
      *(unsigned char *)(v15 + 34) = v8;
      *(unsigned char *)(v15 + 35) = v6 < 0x4DD;
      memcpy((void *)(v15 + 36), v11, v12);
      if (v9)
      {
        int v16 = sub_10003F940(*v14 + v10);
        if (!v16)
        {
          if (dword_10008FA20)
          {
            unsigned int v29 = ne_log_obj();
            if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR)) {
              sub_10005BAFC(v29, v30, v31, v32, v33, v34, v35, v36);
            }
          }
          goto LABEL_27;
        }
        int v17 = v16;
        BOOL v18 = (_DWORD *)v16[1];
        _DWORD *v18 = 0;
        memcpy((char *)v18 + v10, (const void *)v14[1], *v14);
        sub_10003FA78(v14);
        int v14 = v17;
      }
      if (sub_10003C350(v7, (const void *)v14[1], *v14, *(unsigned __int8 **)(a1 + 56), *(unsigned __int8 **)(a1 + 48), *(_DWORD *)(qword_10008F848 + 276)) == -1)
      {
        if (dword_10008FA20)
        {
          uint64_t v21 = ne_log_obj();
          if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR)) {
            sub_10005BA84(v21, v22, v23, v24, v25, v26, v27, v28);
          }
        }
LABEL_27:
        sub_10003FA78(v14);
        return 0xFFFFFFFFLL;
      }
      sub_10003FA78(v14);
      v11 += v12;
      v6 -= v12;
      if (!v6) {
        goto LABEL_15;
      }
    }
    if (dword_10008FA20)
    {
      uint64_t v20 = ne_log_obj();
      if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR)) {
        sub_10005BA50();
      }
    }
    return 0xFFFFFFFFLL;
  }
  uint64_t v8 = 0;
LABEL_15:
  if (dword_10008FA20)
  {
    char v19 = ne_log_obj();
    if (os_log_type_enabled(v19, OS_LOG_TYPE_DEBUG)) {
      sub_10005B9DC();
    }
  }
  return v8;
}

uint64_t sub_100014BFC(uint64_t a1)
{
  return bswap32(*(_DWORD *)(a1 + (((uint64_t)(int)sub_100006014() >> 3) & 0xFFFFFFFFFFFFFFFCLL) + 4));
}

uint64_t sub_100014C34(uint64_t a1, void *a2)
{
  if (*a2 <= 0x23uLL)
  {
    if (dword_10008FA20)
    {
      int v2 = ne_log_obj();
      if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR)) {
        sub_10005BB74();
      }
    }
    return 0xFFFFFFFFLL;
  }
  uint64_t v3 = a2[1];
  uint64_t v4 = bswap32(*(unsigned __int16 *)(v3 + 30)) >> 16;
  if (*a2 < (unint64_t)(v4 + 28) || v4 <= 8)
  {
    if (dword_10008FA20)
    {
      unint64_t v6 = ne_log_obj();
      if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR)) {
        sub_10005BBA8();
      }
    }
    return 0xFFFFFFFFLL;
  }
  uint64_t v8 = sub_10003F940(v4 - 8);
  if (!v8)
  {
    if (dword_10008FA20)
    {
      uint64_t v30 = ne_log_obj();
      if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR)) {
        sub_10005BA50();
      }
    }
    return 0xFFFFFFFFLL;
  }
  int v9 = v8;
  unint64_t v10 = malloc_type_malloc(0x20uLL, 0x102004035CFEAE3uLL);
  if (!v10)
  {
    if (dword_10008FA20)
    {
      uint64_t v31 = ne_log_obj();
      if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR)) {
        sub_10005BA50();
      }
    }
    sub_10003FA78(v9);
    return 0xFFFFFFFFLL;
  }
  int v11 = v10;
  _OWORD *v10 = 0u;
  v10[1] = 0u;
  memcpy((void *)v9[1], (const void *)(v3 + 36), *v9);
  int v13 = *(unsigned __int8 *)(v3 + 34);
  uint64_t v12 = v3 + 34;
  *(_DWORD *)int v11 = v13;
  int v14 = *(unsigned char *)(v12 + 1) & 1;
  *((_DWORD *)v11 + 1) = v14;
  v11[2] = 0;
  v11[3] = v9;
  *((_WORD *)v11 + 4) = bswap32(*(unsigned __int16 *)(v12 - 2)) >> 16;
  if (!dword_10008FA20
    || (size_t v15 = ne_log_obj(),
        BOOL v16 = os_log_type_enabled(v15, OS_LOG_TYPE_DEBUG),
        int v14 = *((_DWORD *)v11 + 1),
        !v16))
  {
    if (!v14) {
      goto LABEL_18;
    }
    goto LABEL_17;
  }
  int v32 = *(_DWORD *)v11;
  int v33 = *((unsigned __int16 *)v11 + 4);
  int v34 = 136315906;
  uint64_t v35 = "isakmp_frag_extract";
  __int16 v36 = 1024;
  int v37 = v32;
  __int16 v38 = 1024;
  int v39 = v33;
  __int16 v40 = 1024;
  int v41 = v14;
  _os_log_debug_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEBUG, "%s: received fragment #%d  frag ID=%d  last frag=%d\n", (uint8_t *)&v34, 0x1Eu);
  int v14 = *((_DWORD *)v11 + 1);
  if (v14) {
LABEL_17:
  }
    int v14 = *(_DWORD *)v11;
LABEL_18:
  uint64_t v17 = *(void *)(a1 + 104);
  if (v17)
  {
    uint64_t v18 = *(void *)(a1 + 104);
    while (*(_DWORD *)v18 != *(_DWORD *)v11)
    {
      if (*(_DWORD *)(v18 + 4)) {
        int v14 = *(_DWORD *)v18;
      }
      uint64_t v18 = *(void *)(v18 + 16);
      if (!v18) {
        goto LABEL_24;
      }
    }
    sub_10003FA78((void *)v11[3]);
    free(v11);
    return 0;
  }
LABEL_24:
  v11[2] = v17;
  *(void *)(a1 + 104) = v11;
  if (!v14) {
    return 0;
  }
  if (v14 >= 1)
  {
    int v19 = 1;
    do
    {
      uint64_t v20 = v11;
      while (*(_DWORD *)v20 != v19)
      {
        uint64_t result = 0;
        uint64_t v20 = (void *)v20[2];
        if (!v20) {
          return result;
        }
      }
    }
    while (v19++ != v14);
  }
  if (dword_10008FA20)
  {
    uint64_t v23 = ne_log_obj();
    if (os_log_type_enabled(v23, OS_LOG_TYPE_DEBUG)) {
      sub_10005BBDC(v12, v23, v24, v25, v26, v27, v28, v29);
    }
  }
  return 1;
}

void *sub_100014F5C(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 104);
  if (!v2)
  {
    if (!dword_10008FA20)
    {
      uint64_t v8 = 0;
LABEL_34:
      *(void *)(a1 + 104) = 0;
      return v8;
    }
    int v14 = ne_log_obj();
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR)) {
      sub_10005BC60();
    }
    goto LABEL_29;
  }
  size_t v3 = 0;
  int v4 = 0;
  int v5 = 0;
  do
  {
    if (*(_DWORD *)v2 > v5 && *(_DWORD *)(v2 + 4)) {
      int v5 = *(_DWORD *)v2;
    }
    uint64_t v6 = v2 + 16;
    uint64_t v2 = *(void *)(v2 + 16);
    v3 += **(void **)(v6 + 8);
    ++v4;
  }
  while (v2);
  int v7 = sub_10003F940(v3);
  if (!v7)
  {
    if (dword_10008FA20)
    {
      BOOL v16 = ne_log_obj();
      if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR)) {
        sub_10005BA50();
      }
    }
LABEL_29:
    uint64_t v8 = 0;
LABEL_30:
    uint64_t v17 = *(void *)(a1 + 104);
    if (v17)
    {
      do
      {
        uint64_t v18 = *(void *)(v17 + 16);
        sub_10003FA78(*(void **)(v17 + 24));
        free((void *)v17);
        uint64_t v17 = v18;
      }
      while (v18);
    }
    goto LABEL_34;
  }
  uint64_t v8 = v7;
  if (v5 < 1)
  {
LABEL_16:
    if (dword_10008FA20)
    {
      int v13 = ne_log_obj();
      if (os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG)) {
        sub_10005BC94();
      }
    }
    goto LABEL_30;
  }
  int v9 = (char *)v7[1];
  int v10 = 1;
LABEL_10:
  uint64_t v11 = *(void *)(a1 + 104);
  do
  {
    if (*(_DWORD *)v11 == v10)
    {
      memcpy(v9, *(const void **)(*(void *)(v11 + 24) + 8), **(void **)(v11 + 24));
      v9 += **(void **)(v11 + 24);
      if (v10++ == v5) {
        goto LABEL_16;
      }
      goto LABEL_10;
    }
    uint64_t v11 = *(void *)(v11 + 16);
  }
  while (v11);
  if (dword_10008FA20)
  {
    size_t v15 = ne_log_obj();
    if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR)) {
      sub_10005BD08(v10, v15);
    }
  }
  sub_10003FA78(v8);
  return 0;
}

void **sub_100015144(void **a1, unsigned int a2)
{
  int v4 = sub_100006014();
  int v5 = (char *)*a1;
  if (*a1 != (void *)(v4 >> 3)) {
    goto LABEL_4;
  }
  uint64_t v6 = sub_10003F9BC(a1, (size_t)(v5 + 4));
  if (v6)
  {
    a1 = v6;
    *(_DWORD *)&v5[(void)v6[1]] = 0;
LABEL_4:
    *(_DWORD *)((char *)a1[1] + ((uint64_t)v4 >> 3)) |= bswap32(a2);
    return a1;
  }
  if (dword_10008FA20)
  {
    uint64_t v8 = ne_log_obj();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR)) {
      sub_10005BA50();
    }
  }
  return 0;
}

uint64_t sub_1000151F8(uint64_t a1, unint64_t *a2, unsigned __int8 *a3, unsigned __int8 *a4, uint64_t a5, char a6)
{
  unint64_t v6 = *a2;
  if (*a2)
  {
    LODWORD(v11) = 0;
    int v12 = a6 & 1;
    uint64_t v40 = (4 * v12);
    int v13 = (char *)a2[1];
    uint64_t v42 = v13;
    int v39 = v12;
    while (1)
    {
      size_t v14 = v6 >= 0x4DC ? 1244 : v6;
      size_t v15 = sub_10003F940(v14 + 36);
      if (!v15) {
        break;
      }
      BOOL v16 = v15;
      uint64_t v11 = (v11 + 1);
      size_t v17 = v15[1];
      long long v18 = *(_OWORD *)v42;
      uint64_t v19 = *((void *)v42 + 2);
      *(_DWORD *)(v17 + 24) = *((_DWORD *)v42 + 6);
      *(void *)(v17 + 16) = v19;
      *(_OWORD *)size_t v17 = v18;
      *(_DWORD *)(v17 + 24) = bswap32(*(_DWORD *)v15);
      *(unsigned char *)(v17 + 16) = -124;
      *(_WORD *)(v17 + 28) = 0;
      *(_WORD *)(v17 + 30) = bswap32(v14 + 8) >> 16;
      *(_WORD *)(v17 + 32) = 256;
      *(unsigned char *)(v17 + 34) = v11;
      *(unsigned char *)(v17 + 35) = v6 < 0x4DD;
      memcpy((void *)(v17 + 36), v13, v14);
      if (v12)
      {
        unsigned int v41 = v11;
        uint64_t v20 = a1;
        uint64_t v21 = a3;
        uint64_t v22 = a4;
        uint64_t v23 = a5;
        uint64_t v24 = sub_10003F940(*v16 + v40);
        if (!v24)
        {
          if (dword_10008FA20)
          {
            uint64_t v30 = ne_log_obj();
            if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR)) {
              sub_10005BE28(v30, v31, v32, v33, v34, v35, v36, v37);
            }
          }
          goto LABEL_26;
        }
        uint64_t v25 = v24;
        uint64_t v26 = (_DWORD *)v24[1];
        *uint64_t v26 = 0;
        memcpy((char *)v26 + v40, (const void *)v16[1], *v16);
        sub_10003FA78(v16);
        BOOL v16 = v25;
        a5 = v23;
        a4 = v22;
        a3 = v21;
        a1 = v20;
        uint64_t v11 = v41;
        int v12 = v39;
      }
      if (sub_10003C350(a1, (const void *)v16[1], *v16, a3, a4, a5) == -1)
      {
        if (dword_10008FA20)
        {
          uint64_t v29 = ne_log_obj();
          if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR)) {
            sub_10005BDF4();
          }
        }
LABEL_26:
        sub_10003FA78(v16);
        return 0xFFFFFFFFLL;
      }
      sub_10003FA78(v16);
      v13 += v14;
      v6 -= v14;
      if (!v6) {
        goto LABEL_14;
      }
    }
    if (dword_10008FA20)
    {
      uint64_t v28 = ne_log_obj();
      if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR)) {
        sub_10005BA50();
      }
    }
    return 0xFFFFFFFFLL;
  }
  else
  {
    uint64_t v11 = 0;
LABEL_14:
    if (dword_10008FA20)
    {
      uint64_t v27 = ne_log_obj();
      if (os_log_type_enabled(v27, OS_LOG_TYPE_DEBUG)) {
        sub_10005BD80();
      }
    }
  }
  return v11;
}

void sub_100015478(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_debug_impl(a1, a2, OS_LOG_TYPE_DEBUG, a4, &a9, 0x12u);
}

uint64_t sub_1000154A8(uint64_t a1, uint64_t a2)
{
  uint64_t v30 = 0;
  memset(v31, 0, sizeof(v31));
  uint64_t v2 = (int *)(a1 + 16);
  if (*(_DWORD *)(a1 + 16) != 5184)
  {
    if (dword_10008FA20)
    {
      int v4 = ne_log_obj();
      if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR)) {
        sub_10005AED8();
      }
    }
    goto LABEL_9;
  }
  if (a2)
  {
    if (dword_10008FA20)
    {
      size_t v3 = ne_log_obj();
      if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR)) {
        sub_10005BF3C();
      }
    }
LABEL_9:
    int v5 = 0;
    unint64_t v6 = 0;
    int v7 = 0;
    uint64_t v8 = 0xFFFFFFFFLL;
    goto LABEL_10;
  }
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  sub_100025FD0((void *)a1, *(void *)(a1 + 48), *(void *)(a1 + 56));
  int v13 = sub_10000E2C8(a1);
  *(void *)(a1 + 336) = v13;
  if (!v13)
  {
    if (dword_10008FA20)
    {
      uint64_t v22 = ne_log_obj();
      if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR)) {
        sub_10005BEA0();
      }
    }
    goto LABEL_9;
  }
  size_t v14 = (uint64_t **)sub_100026474(0, (uint64_t)v13, 1);
  size_t v15 = v14;
  uint64_t v30 = v14;
  uint64_t v16 = *(void *)(a1 + 64);
  if (*(_DWORD *)(v16 + 176))
  {
    size_t v15 = (uint64_t **)sub_1000404F0(v14, v31);
    uint64_t v30 = v15;
    uint64_t v16 = *(void *)(a1 + 64);
  }
  uint64_t v17 = *(void *)(v16 + 272);
  int v18 = *(_DWORD *)(*(void *)(v16 + 248) + 48);
  if (v17 && v18 == 65001
    || ((v18 - 65005) <= 4 ? (BOOL v19 = ((1 << (v18 + 19)) & 0x15) == 0) : (BOOL v19 = 1),
        v19 ? (BOOL v20 = v18 == 65500) : (BOOL v20 = 1),
        !v20 ? (BOOL v21 = v18 == 64221) : (BOOL v21 = 1),
        v21))
  {
    int v7 = sub_10003F70C(16);
    if (v7)
    {
      size_t v15 = (uint64_t **)sub_100026474(v15, (uint64_t)v7, 13);
      uint64_t v30 = v15;
    }
    else if (dword_10008FA20)
    {
      uint64_t v23 = ne_log_obj();
      if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR)) {
        sub_10005BF08();
      }
    }
    uint64_t v24 = sub_10003F70C(17);
    if (v24)
    {
      unint64_t v6 = v24;
      size_t v15 = (uint64_t **)sub_100026474(v15, (uint64_t)v24, 13);
      uint64_t v30 = v15;
      goto LABEL_50;
    }
    if (dword_10008FA20)
    {
      uint64_t v25 = ne_log_obj();
      if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR)) {
        sub_10005BED4();
      }
    }
  }
  else
  {
    int v7 = 0;
  }
  unint64_t v6 = 0;
LABEL_50:
  if (*(_DWORD *)(*(void *)(a1 + 64) + 148))
  {
    uint64_t v26 = (void **)sub_10003F70C(18);
    if (v26)
    {
      uint64_t v27 = sub_100015144(v26, 0x80000000);
      size_t v15 = (uint64_t **)sub_100026474(v15, (uint64_t)v27, 13);
      uint64_t v30 = v15;
      goto LABEL_57;
    }
    if (dword_10008FA20)
    {
      uint64_t v28 = ne_log_obj();
      if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR)) {
        sub_10005B864();
      }
    }
  }
  uint64_t v27 = 0;
LABEL_57:
  if (*(_DWORD *)(*(void *)(a1 + 64) + 208))
  {
    int v5 = sub_10003F70C(19);
    if (v5) {
      uint64_t v30 = (uint64_t **)sub_100026474(v15, (uint64_t)v5, 13);
    }
  }
  else
  {
    int v5 = 0;
  }
  *(void *)(a1 + 128) = sub_1000264D0(&v30, a1);
  *(_DWORD *)(a1 + 124) = *(_DWORD *)(*(void *)(a1 + 64) + 200);
  if (sub_100024104(a1) != -1)
  {
    sub_100002728(v2, 5217);
    uint64_t v8 = 0;
    if (!v27) {
      goto LABEL_10;
    }
    goto LABEL_68;
  }
  if (dword_10008FA20)
  {
    uint64_t v29 = ne_log_obj();
    if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR)) {
      sub_10005AD0C();
    }
  }
  uint64_t v8 = 0xFFFFFFFFLL;
  if (v27) {
LABEL_68:
  }
    sub_10003FA78(v27);
LABEL_10:
  for (uint64_t i = 0; i != 96; i += 8)
  {
    int v10 = *(void **)((char *)v31 + i);
    if (!v10) {
      break;
    }
    sub_10003FA78(v10);
  }
  if (v7) {
    sub_10003FA78(v7);
  }
  if (v6) {
    sub_10003FA78(v6);
  }
  if (v5) {
    sub_10003FA78(v5);
  }
  return v8;
}

uint64_t sub_1000158C8(uint64_t a1, uint64_t a2)
{
  uint64_t v26 = 0;
  uint64_t v2 = (int *)(a1 + 16);
  if (*(_DWORD *)(a1 + 16) != 5217)
  {
    if (dword_10008FA20)
    {
      int v13 = ne_log_obj();
      if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR)) {
        sub_10005AED8();
      }
    }
    goto LABEL_28;
  }
  int v4 = sub_100022FA8(a2);
  if (!v4)
  {
    if (dword_10008FA20)
    {
      size_t v14 = ne_log_obj();
      if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR)) {
        sub_10005AF40();
      }
    }
LABEL_28:
    uint64_t v15 = 0xFFFFFFFFLL;
    goto LABEL_53;
  }
  int v5 = v4;
  unint64_t v6 = v4[1];
  if (*(unsigned char *)v6 == 1)
  {
    if ((sub_1000261F4((size_t **)&v26, v6[1]) & 0x80000000) != 0)
    {
      if (dword_10008FA20)
      {
        BOOL v20 = ne_log_obj();
        if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR)) {
          sub_10005AF74();
        }
      }
    }
    else
    {
      for (uint64_t i = (char *)(v6 + 2); *i == 13; i += 16)
      {
        int v8 = sub_10003F7B0(*((void *)i + 1));
        int v9 = v8;
        if (*(_DWORD *)(*(void *)(a1 + 64) + 176) && sub_10003FB98(v8)) {
          sub_1000403F4(a1, v9);
        }
        switch(v9)
        {
          case 16:
            int v10 = *(int **)(a1 + 408);
            int v11 = *v10 | 1;
            goto LABEL_13;
          case 17:
            int v10 = *(int **)(a1 + 408);
            int v11 = *v10 | 2;
LABEL_13:
            int *v10 = v11;
            break;
          case 18:
            if ((sub_100014BFC(*((void *)i + 1)) & 0x80000000) != 0)
            {
              if (dword_10008FA20)
              {
                int v12 = ne_log_obj();
                if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG)) {
                  sub_10005BFD8(&v24, v25, v12);
                }
              }
              *(_DWORD *)(a1 + 100) = 1;
            }
            break;
          case 19:
            if (*(_DWORD *)(*(void *)(a1 + 64) + 208)) {
              *(_DWORD *)(a1 + 368) = 1;
            }
            break;
          default:
            continue;
        }
      }
      if (*i)
      {
        if (dword_10008FA20)
        {
          BOOL v21 = ne_log_obj();
          if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR)) {
            sub_10005BF70();
          }
        }
      }
      else
      {
        if (*(unsigned char *)(a1 + 96))
        {
          if (dword_10008FA20)
          {
            uint64_t v17 = ne_log_obj();
            if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
            {
              int v18 = sub_10003F504(**(_DWORD **)(a1 + 88));
              *(_DWORD *)buf = 136315138;
              uint64_t v28 = v18;
              _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "Selected NAT-T version: %s\n", buf, 0xCu);
            }
          }
          sub_10004F200(a1);
        }
        if ((sub_10000A144((unint64_t *)v26, (void *)a1) & 0x80000000) == 0)
        {
          BOOL v19 = *(void **)(a1 + 344);
          if (v19)
          {
            sub_10003FA78(v19);
            *(void *)(a1 + 344) = 0;
          }
          sub_100002728(v2, 5186);
          sub_1000496DC(1, 1, a1, 0);
          uint64_t v15 = 0;
          goto LABEL_52;
        }
        if (dword_10008FA20)
        {
          uint64_t v22 = ne_log_obj();
          if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR)) {
            sub_10005B048();
          }
        }
      }
    }
  }
  else if (dword_10008FA20)
  {
    uint64_t v16 = ne_log_obj();
    if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR)) {
      sub_10005B3AC();
    }
  }
  uint64_t v15 = 0xFFFFFFFFLL;
LABEL_52:
  sub_10003FA78(v5);
LABEL_53:
  if (v26) {
    sub_10003FA78(v26);
  }
  return v15;
}

uint64_t sub_100015C84(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = (int *)(a1 + 16);
  if (*(_DWORD *)(a1 + 16) == 5186)
  {
    *(void *)(a1 + 8) = *(void *)(*(void *)(a2 + 8) + 8);
    if ((sub_10002972C(*(void *)(*(void *)(a1 + 72) + 64), (size_t **)(a1 + 152), (void *)(a1 + 136)) & 0x80000000) != 0)
    {
      if (dword_10008FA20)
      {
        int v11 = ne_log_obj();
        if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR)) {
          sub_10005ACA4();
        }
      }
    }
    else
    {
      int v5 = sub_10000601C(*(_DWORD *)(*(void *)(a1 + 64) + 140));
      *(void *)(a1 + 176) = v5;
      if (v5)
      {
        unint64_t v6 = sub_100015EAC(a1);
        *(void *)(a1 + 128) = v6;
        if (v6)
        {
          *(_DWORD *)(a1 + 124) = *(_DWORD *)(*(void *)(a1 + 64) + 200);
          if (sub_100024104(a1) == -1)
          {
            if (dword_10008FA20)
            {
              uint64_t v15 = ne_log_obj();
              if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR)) {
                sub_10005AD0C();
              }
            }
          }
          else
          {
            int v7 = *(void **)(a1 + 128);
            if (*(_DWORD *)(a1 + 100) && *v7 >= 0x501uLL)
            {
              uint64_t v8 = 0;
              LODWORD(v9) = *(_DWORD *)(a1 + 96);
            }
            else
            {
              unint64_t v9 = *(unsigned int *)(a1 + 96);
              uint64_t v8 = (v9 >> 3) & 4;
            }
            if (sub_100009070(*(void *)(a1 + 48), *(void *)(a1 + 56), (uint64_t)v7, a2, v8, (v9 >> 5) & 1) != -1)
            {
              sub_100002728(v2, 5219);
              return 0;
            }
            if (dword_10008FA20)
            {
              uint64_t v16 = ne_log_obj();
              if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR)) {
                sub_10005B794();
              }
            }
          }
        }
        else if (dword_10008FA20)
        {
          int v13 = ne_log_obj();
          if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR)) {
            sub_10005C018();
          }
        }
      }
      else if (dword_10008FA20)
      {
        int v12 = ne_log_obj();
        if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR)) {
          sub_10005ACD8();
        }
      }
    }
  }
  else if (dword_10008FA20)
  {
    int v10 = ne_log_obj();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR)) {
      sub_10005AED8();
    }
  }
  return 0xFFFFFFFFLL;
}

void *sub_100015EAC(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 20) != 1
    || !*(_DWORD *)(*(void *)(a1 + 64) + 120)
    || !sub_10002CBD4(*(_DWORD *)(*(void *)(a1 + 72) + 48)))
  {
    size_t v3 = 0;
    char v4 = 1;
LABEL_7:
    int v5 = sub_100026474(0, *(void *)(a1 + 152), 4);
    unint64_t v6 = (uint64_t **)sub_100026474(v5, *(void *)(a1 + 176), 10);
    int v7 = v6;
    uint8_t v24 = v6;
    if ((v4 & 1) == 0)
    {
      int v7 = (uint64_t **)sub_100026474(v6, (uint64_t)v3, 7);
      uint8_t v24 = v7;
    }
    if ((*(unsigned char *)(a1 + 96) & 1) == 0)
    {
      uint64_t v8 = 0;
      unint64_t v9 = 0;
      goto LABEL_30;
    }
    uint64_t v10 = sub_10003FBA8((void *)a1, *(void *)(a1 + 48));
    if (v10)
    {
      uint64_t v8 = (void *)v10;
      uint64_t v11 = sub_10003FBA8((void *)a1, *(void *)(a1 + 56));
      if (v11)
      {
        unint64_t v9 = (void *)v11;
        if (dword_10008FA20)
        {
          int v12 = ne_log_obj();
          if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)uint64_t v23 = 0;
            _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "Adding remote and local NAT-D payloads.\n", v23, 2u);
          }
        }
        uint64_t v13 = *(void *)(a1 + 88);
        int v14 = *(unsigned __int16 *)(v13 + 14);
        if (*(_DWORD *)v13 == 14)
        {
          uint64_t v15 = sub_100026474(v7, (uint64_t)v9, v14);
          int v16 = *(unsigned __int16 *)(*(void *)(a1 + 88) + 14);
          uint64_t v17 = (uint64_t)v8;
        }
        else
        {
          uint64_t v15 = sub_100026474(v7, (uint64_t)v8, v14);
          int v16 = *(unsigned __int16 *)(*(void *)(a1 + 88) + 14);
          uint64_t v17 = (uint64_t)v9;
        }
        uint8_t v24 = (uint64_t **)sub_100026474(v15, v17, v16);
LABEL_30:
        BOOL v19 = sub_1000264D0(&v24, a1);
        if (!v3)
        {
LABEL_32:
          if (v8) {
            sub_10003FA78(v8);
          }
          if (v9) {
            sub_10003FA78(v9);
          }
          return v19;
        }
LABEL_31:
        sub_10003FA78(v3);
        goto LABEL_32;
      }
      if (dword_10008FA20)
      {
        BOOL v20 = ne_log_obj();
        if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR)) {
          sub_10005C04C((const sockaddr **)(a1 + 56));
        }
      }
      BOOL v19 = 0;
    }
    else
    {
      if (dword_10008FA20)
      {
        int v18 = ne_log_obj();
        if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR)) {
          sub_10005C04C((const sockaddr **)(a1 + 48));
        }
      }
      BOOL v19 = 0;
      uint64_t v8 = 0;
    }
    unint64_t v9 = 0;
    if (!v3) {
      goto LABEL_32;
    }
    goto LABEL_31;
  }
  uint64_t v2 = sub_10002C9C0(a1);
  if (v2)
  {
    size_t v3 = v2;
    char v4 = 0;
    goto LABEL_7;
  }
  if (dword_10008FA20)
  {
    uint64_t v22 = ne_log_obj();
    if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR)) {
      sub_10005C0CC();
    }
  }
  return 0;
}

uint64_t sub_100016130(uint64_t a1, uint64_t a2)
{
  uint64_t v35 = 0;
  size_t v3 = (int *)(a1 + 16);
  if (*(_DWORD *)(a1 + 16) == 5219)
  {
    char v4 = sub_100022FA8(a2);
    if (v4)
    {
      int v5 = v4;
      int v6 = 0;
      for (uint64_t i = (unsigned __int8 *)v4[1]; ; i += 16)
      {
        unsigned int v8 = *i;
        if (v8 <= 0x13) {
          break;
        }
        if (v8 != 20 && v8 != 130)
        {
LABEL_58:
          if (dword_10008FA20)
          {
            uint64_t v26 = ne_log_obj();
            if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR)) {
              sub_10005BF70();
            }
          }
          goto LABEL_76;
        }
LABEL_10:
        if (*(unsigned char *)(a1 + 96))
        {
          uint64_t v9 = *(void *)(a1 + 88);
          if (v9)
          {
            if (*(unsigned __int16 *)(v9 + 14) == v8)
            {
              uint64_t v35 = 0;
              if ((sub_1000261F4((size_t **)&v35, *((void *)i + 1)) & 0x80000000) != 0)
              {
                if (dword_10008FA20)
                {
                  uint64_t v31 = ne_log_obj();
                  if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR)) {
                    sub_10005B974();
                  }
                }
                goto LABEL_76;
              }
              if (!v6) {
                *(_DWORD *)(a1 + 96) |= 6u;
              }
              int v10 = sub_10003FD90(a1, (uint64_t)v35, v6);
              if (dword_10008FA20)
              {
                int v11 = v10;
                int v12 = ne_log_obj();
                if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
                {
                  *(_DWORD *)buf = 67109378;
                  uint64_t v13 = "verified";
                  if (!v11) {
                    uint64_t v13 = "doesn't match";
                  }
                  *(_DWORD *)uint64_t v37 = v6;
                  *(_WORD *)&v37[4] = 2080;
                  *(void *)&v37[6] = v13;
                  _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "NAT-D payload #%d %s\n", buf, 0x12u);
                }
              }
              ++v6;
              sub_10003FA78(v35);
            }
          }
        }
LABEL_34:
        ;
      }
      switch(*i)
      {
        case 4u:
          if ((sub_1000261F4((size_t **)(a1 + 160), *((void *)i + 1)) & 0x80000000) == 0) {
            goto LABEL_34;
          }
          if (dword_10008FA20)
          {
            uint64_t v27 = ne_log_obj();
            if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR)) {
              sub_10005B1B4();
            }
          }
          break;
        case 5u:
        case 6u:
        case 8u:
        case 9u:
        case 0xBu:
        case 0xCu:
        case 0xEu:
          goto LABEL_58;
        case 7u:
          if ((sub_10002C89C(a1, *((void *)i + 1)) & 0x80000000) == 0) {
            goto LABEL_34;
          }
          if (dword_10008FA20)
          {
            uint64_t v28 = ne_log_obj();
            if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR)) {
              sub_10005B250();
            }
          }
          break;
        case 0xAu:
          if ((sub_1000261F4((size_t **)(a1 + 184), *((void *)i + 1)) & 0x80000000) == 0) {
            goto LABEL_34;
          }
          if (dword_10008FA20)
          {
            uint64_t v29 = ne_log_obj();
            if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR)) {
              sub_10005B1E8();
            }
          }
          break;
        case 0xDu:
          int v14 = sub_10003F7B0(*((void *)i + 1));
          if (v14 == 19)
          {
            if (*(_DWORD *)(*(void *)(a1 + 64) + 208)) {
              *(_DWORD *)(a1 + 368) = 1;
            }
          }
          else
          {
            if (v14 == 17)
            {
              uint64_t v15 = *(int **)(a1 + 408);
              int v16 = *v15 | 2;
            }
            else
            {
              if (v14 != 16) {
                goto LABEL_34;
              }
              uint64_t v15 = *(int **)(a1 + 408);
              int v16 = *v15 | 1;
            }
            int *v15 = v16;
          }
          goto LABEL_34;
        case 0xFu:
          goto LABEL_10;
        default:
          if (*i) {
            goto LABEL_58;
          }
          int v19 = *(_DWORD *)(a1 + 96);
          if (v19)
          {
            if (dword_10008FA20)
            {
              BOOL v20 = ne_log_obj();
              BOOL v21 = os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT);
              int v19 = *(_DWORD *)(a1 + 96);
              if (v21)
              {
                uint64_t v22 = "detected:";
                uint64_t v23 = "ME ";
                if ((v19 & 6) == 0) {
                  uint64_t v22 = "not detected";
                }
                if ((v19 & 2) == 0) {
                  uint64_t v23 = (const char *)&unk_100081F6D;
                }
                *(_DWORD *)buf = 136315650;
                *(void *)uint64_t v37 = v22;
                *(_WORD *)&v37[8] = 2080;
                *(void *)&v37[10] = v23;
                if ((v19 & 4) != 0) {
                  uint8_t v24 = "PEER";
                }
                else {
                  uint8_t v24 = (const char *)&unk_100081F6D;
                }
                __int16 v38 = 2080;
                int v39 = v24;
                _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "NAT %s %s%s\n", buf, 0x20u);
                int v19 = *(_DWORD *)(a1 + 96);
              }
            }
            if ((v19 & 6) != 0) {
              sub_100040318(a1);
            }
          }
          if (*(void *)(a1 + 160) && *(void *)(a1 + 184))
          {
            sub_10002CAB4(a1);
            sub_100002728(v3, 5188);
            sub_10003FA78(v5);
            return 0;
          }
          if (dword_10008FA20)
          {
            uint64_t v30 = ne_log_obj();
            if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR)) {
              sub_10005B014();
            }
          }
          break;
      }
LABEL_76:
      sub_10003FA78(v5);
    }
    else if (dword_10008FA20)
    {
      int v18 = ne_log_obj();
      if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR)) {
        sub_10005AF40();
      }
    }
  }
  else if (dword_10008FA20)
  {
    uint64_t v17 = ne_log_obj();
    if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR)) {
      sub_10005AED8();
    }
  }
  uint64_t v32 = *(void **)(a1 + 160);
  if (v32)
  {
    sub_10003FA78(v32);
    *(void *)(a1 + 160) = 0;
  }
  uint64_t v33 = *(void **)(a1 + 184);
  if (v33)
  {
    sub_10003FA78(v33);
    *(void *)(a1 + 184) = 0;
  }
  uint64_t v34 = *(void **)(a1 + 320);
  if (v34)
  {
    sub_10003FA78(v34);
    *(void *)(a1 + 320) = 0;
  }
  sub_10002BC10(*(void **)(a1 + 304));
  *(void *)(a1 + 304) = 0;
  return 0xFFFFFFFFLL;
}

uint64_t sub_100016674(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = (int *)(a1 + 16);
  if (*(_DWORD *)(a1 + 16) == 5188)
  {
    if ((sub_10002952C(*(void *)(*(void *)(a1 + 72) + 64), *(void **)(a1 + 160), (void **)(a1 + 168), (void *)(a1 + 136)) & 0x80000000) != 0)
    {
      if (dword_10008FA20)
      {
        int v11 = ne_log_obj();
        if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR)) {
          sub_10005B07C();
        }
      }
    }
    else if ((sub_10002CDA4(a1) & 0x80000000) != 0)
    {
      if (dword_10008FA20)
      {
        int v12 = ne_log_obj();
        if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR)) {
          sub_10005B0B0();
        }
      }
    }
    else if ((sub_10002D164(a1) & 0x80000000) != 0)
    {
      if (dword_10008FA20)
      {
        uint64_t v13 = ne_log_obj();
        if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR)) {
          sub_10005B0E4();
        }
      }
    }
    else if ((sub_10002D410((void *)a1) & 0x80000000) != 0)
    {
      if (dword_10008FA20)
      {
        int v14 = ne_log_obj();
        if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR)) {
          sub_10005B118();
        }
      }
    }
    else if ((sub_10002D828(a1) & 0x80000000) != 0)
    {
      if (dword_10008FA20)
      {
        uint64_t v15 = ne_log_obj();
        if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR)) {
          sub_10005B14C();
        }
      }
    }
    else if ((sub_10000F71C(a1) & 0x80000000) != 0)
    {
      if (dword_10008FA20)
      {
        int v16 = ne_log_obj();
        if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR)) {
          sub_10005AC08();
        }
      }
    }
    else
    {
      uint64_t v5 = sub_10002A3E8(a1, 1);
      *(void *)(a1 + 256) = v5;
      if (v5)
      {
        *(unsigned char *)(a1 + 82) |= 1u;
        int v6 = sub_1000169E0(a1);
        *(void *)(a1 + 128) = v6;
        if (v6)
        {
          *(_DWORD *)(a1 + 124) = *(_DWORD *)(*(void *)(a1 + 64) + 200);
          if (sub_100024104(a1) == -1)
          {
            if (dword_10008FA20)
            {
              BOOL v20 = ne_log_obj();
              if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR)) {
                sub_10005AD0C();
              }
            }
          }
          else
          {
            int v7 = *(void **)(a1 + 128);
            if (*(_DWORD *)(a1 + 100) && *v7 >= 0x501uLL)
            {
              uint64_t v8 = 0;
              LODWORD(v9) = *(_DWORD *)(a1 + 96);
            }
            else
            {
              unint64_t v9 = *(unsigned int *)(a1 + 96);
              uint64_t v8 = (v9 >> 3) & 4;
            }
            if (sub_100009070(*(void *)(a1 + 48), *(void *)(a1 + 56), (uint64_t)v7, a2, v8, (v9 >> 5) & 1) != -1)
            {
              memcpy(*(void **)(*(void *)(*(void *)(a1 + 328) + 8) + 8), *(const void **)(**(void **)(a1 + 328) + 8), ***(void ***)(a1 + 328));
              sub_100002728(v2, 5221);
              return 0;
            }
            if (dword_10008FA20)
            {
              BOOL v21 = ne_log_obj();
              if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR)) {
                sub_10005B794();
              }
            }
          }
        }
        else if (dword_10008FA20)
        {
          int v18 = ne_log_obj();
          if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR)) {
            sub_10005C134();
          }
        }
      }
      else if (dword_10008FA20)
      {
        uint64_t v17 = ne_log_obj();
        if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR)) {
          sub_10005C100();
        }
      }
    }
  }
  else if (dword_10008FA20)
  {
    int v10 = ne_log_obj();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR)) {
      sub_10005AED8();
    }
  }
  return 0xFFFFFFFFLL;
}

void *sub_1000169E0(uint64_t a1)
{
  uint64_t v2 = a1 + 72;
  int v3 = *(_DWORD *)(*(void *)(a1 + 72) + 48);
  if (*(void *)(*(void *)(a1 + 64) + 272)) {
    BOOL v4 = v3 == 65001;
  }
  else {
    BOOL v4 = 0;
  }
  if (v4) {
    goto LABEL_22;
  }
  if (v3 > 65004)
  {
    if ((v3 - 65007) < 4) {
      goto LABEL_12;
    }
    if ((v3 - 65005) < 2) {
      goto LABEL_42;
    }
    int v7 = 65500;
LABEL_21:
    if (v3 != v7)
    {
LABEL_52:
      if (dword_10008FA20)
      {
        uint64_t v23 = ne_log_obj();
        if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR)) {
          sub_10005C19C();
        }
      }
      return 0;
    }
    goto LABEL_22;
  }
  if (v3 > 64220)
  {
    if (v3 == 64221) {
      goto LABEL_22;
    }
    if (v3 == 64222) {
      goto LABEL_42;
    }
    int v7 = 65002;
    goto LABEL_21;
  }
  if ((v3 - 4) < 2)
  {
LABEL_12:
    if (dword_10008FA20)
    {
      uint64_t v5 = ne_log_obj();
      if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR)) {
        sub_10005C238();
      }
    }
    return 0;
  }
  if (v3 == 1)
  {
LABEL_22:
    uint64_t v8 = sub_100026474(0, *(void *)(a1 + 312), 5);
    unint64_t v9 = (uint64_t **)sub_100026474(v8, *(void *)(a1 + 256), 8);
    int v10 = v9;
    int v11 = 0;
LABEL_23:
    uint64_t v28 = v9;
    goto LABEL_24;
  }
  if (v3 != 3) {
    goto LABEL_52;
  }
LABEL_42:
  if ((sub_10002B60C(a1) & 0x80000000) != 0)
  {
    if (dword_10008FA20)
    {
      uint64_t v22 = ne_log_obj();
      if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR)) {
        sub_10005B830();
      }
    }
    return 0;
  }
  if ((sub_10002B924((void *)a1) & 0x80000000) != 0)
  {
    if (dword_10008FA20)
    {
      uint8_t v24 = ne_log_obj();
      if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR)) {
        sub_10005B680();
      }
    }
    return 0;
  }
  if (!*(_DWORD *)(a1 + 20)
    && *(_DWORD *)(*(void *)(a1 + 64) + 120)
    && sub_10002CBD4(*(_DWORD *)(*(void *)v2 + 48)))
  {
    uint64_t v25 = sub_10002C9C0(a1);
    if (!v25)
    {
      if (dword_10008FA20)
      {
        uint64_t v27 = ne_log_obj();
        if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR)) {
          sub_10005C204();
        }
      }
      return 0;
    }
    int v11 = v25;
    char v17 = 0;
  }
  else
  {
    int v11 = 0;
    char v17 = 1;
  }
  if (*(void *)(a1 + 280))
  {
    int v18 = *(_DWORD *)(*(void *)(a1 + 64) + 116);
    int v19 = sub_100026474(0, *(void *)(a1 + 312), 5);
    if (!v18) {
      goto LABEL_64;
    }
    uint64_t v20 = *(void *)(*(void *)(a1 + 280) + 24);
    int v21 = 6;
  }
  else
  {
    uint64_t v20 = *(void *)(a1 + 312);
    int v19 = 0;
    int v21 = 5;
  }
  int v19 = sub_100026474(v19, v20, v21);
LABEL_64:
  uint64_t v26 = (uint64_t **)sub_100026474(v19, *(void *)(a1 + 264), 9);
  int v10 = v26;
  uint64_t v28 = v26;
  if ((v17 & 1) == 0)
  {
    unint64_t v9 = (uint64_t **)sub_100026474(v26, (uint64_t)v11, 7);
    int v10 = v9;
    goto LABEL_23;
  }
LABEL_24:
  if (*(_DWORD *)(a1 + 20)) {
    int v12 = 0;
  }
  else {
    int v12 = sub_1000271D0(a1, v10);
  }
  int v6 = sub_1000264D0(&v28, a1);
  uint64_t v13 = sub_10002E41C(a1, (uint64_t)v6, *(void *)(*(void *)(a1 + 328) + 8), **(void **)(a1 + 328));
  if (v13)
  {
    sub_10003FA78(v6);
    int v6 = v13;
    if (!v11) {
      goto LABEL_34;
    }
    goto LABEL_33;
  }
  if (dword_10008FA20)
  {
    int v14 = ne_log_obj();
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
    {
      sub_10005C168();
      if (!v11) {
        goto LABEL_34;
      }
      goto LABEL_33;
    }
  }
  if (v11) {
LABEL_33:
  }
    sub_10003FA78(v11);
LABEL_34:
  if (v13) {
    BOOL v15 = 1;
  }
  else {
    BOOL v15 = v6 == 0;
  }
  if (!v15)
  {
    sub_10003FA78(v6);
    int v6 = 0;
  }
  if (v12) {
    sub_10003FA78(v12);
  }
  return v6;
}

uint64_t sub_100016D7C(uint64_t a1, void *a2)
{
  int v3 = (int *)(a1 + 16);
  if (*(_DWORD *)(a1 + 16) != 5221)
  {
    if (dword_10008FA20)
    {
      uint64_t v5 = ne_log_obj();
      if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR)) {
        sub_10005AED8();
      }
    }
    goto LABEL_9;
  }
  if ((*(unsigned char *)(a2[1] + 19) & 1) == 0)
  {
    if (dword_10008FA20)
    {
      BOOL v4 = ne_log_obj();
      if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR)) {
        sub_10005C2A0();
      }
    }
LABEL_9:
    uint64_t v6 = 0xFFFFFFFFLL;
LABEL_10:
    int v7 = *(void **)(a1 + 320);
    if (v7)
    {
      sub_10003FA78(v7);
      *(void *)(a1 + 320) = 0;
    }
    sub_10002BC10(*(void **)(a1 + 288));
    *(void *)(a1 + 288) = 0;
    sub_10002BC10(*(void **)(a1 + 296));
    *(void *)(a1 + 296) = 0;
    uint64_t v8 = *(void **)(a1 + 272);
    if (v8)
    {
      sub_10003FA78(v8);
      *(void *)(a1 + 272) = 0;
    }
    return v6;
  }
  int v10 = sub_10002E028(a1, a2, **(void **)(a1 + 328), *(void *)(*(void *)(a1 + 328) + 8));
  if (!v10)
  {
    if (dword_10008FA20)
    {
      int v16 = ne_log_obj();
      if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR)) {
        sub_10005C2D4();
      }
    }
    goto LABEL_9;
  }
  int v11 = v10;
  int v12 = sub_100022FA8((uint64_t)v10);
  if (!v12)
  {
    if (dword_10008FA20)
    {
      char v17 = ne_log_obj();
      if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR)) {
        sub_10005AF40();
      }
    }
    sub_10003FA78(v11);
    goto LABEL_9;
  }
  uint64_t v13 = v12;
  int v14 = 0;
  *(void *)(a1 + 352) = 0;
  BOOL v15 = v12[1];
  while (2)
  {
    switch(*(unsigned char *)v15)
    {
      case 0:
        if (v14) {
          sub_10002BB90((void *)a1);
        }
        if (sub_10000F124(a1))
        {
          if (dword_10008FA20)
          {
            int v18 = ne_log_obj();
            if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR)) {
              sub_10005B180();
            }
          }
          goto LABEL_56;
        }
        uint64_t v24 = sub_10002ABA8(a1);
        uint64_t v6 = v24;
        if (v24 == -1)
        {
          char v23 = 0;
        }
        else
        {
          if (v24)
          {
            sub_10001AD08(a1, v24, 0);
            goto LABEL_56;
          }
          if (dword_10008C2C8 >= 7) {
            sub_100033908(7, *(void *)(*(void *)(a1 + 320) + 8), **(void **)(a1 + 320), "peer's ID:", v25, v26, v27, v28, v29);
          }
          memcpy(*(void **)(**(void **)(a1 + 328) + 8), *(const void **)(*(void *)(*(void *)(a1 + 328) + 8) + 8), **(void **)(*(void *)(a1 + 328) + 8));
          sub_100002728(v3, 5190);
          uint64_t v6 = 0;
          char v23 = 1;
        }
        goto LABEL_57;
      case 5:
        if ((sub_1000261F4((size_t **)(a1 + 320), v15[1]) & 0x80000000) == 0) {
          goto LABEL_30;
        }
        if (dword_10008FA20)
        {
          uint64_t v20 = ne_log_obj();
          if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR)) {
            sub_10005B21C();
          }
        }
        goto LABEL_56;
      case 6:
        if ((sub_10002C5EC(a1, v15[1]) & 0x80000000) == 0)
        {
          int v14 = 1;
LABEL_30:
          v15 += 2;
          continue;
        }
        if (dword_10008FA20)
        {
          int v21 = ne_log_obj();
          if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR)) {
            sub_10005B90C();
          }
        }
LABEL_56:
        char v23 = 0;
        uint64_t v6 = 0xFFFFFFFFLL;
LABEL_57:
        sub_10003FA78(v13);
        sub_10003FA78(v11);
        if ((v23 & 1) == 0) {
          goto LABEL_10;
        }
        return v6;
      case 8:
        *(void *)(a1 + 352) = v15[1];
        goto LABEL_30;
      case 9:
        if ((sub_1000261F4((size_t **)(a1 + 272), v15[1]) & 0x80000000) == 0) {
          goto LABEL_30;
        }
        if (dword_10008FA20)
        {
          uint64_t v22 = ne_log_obj();
          if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR)) {
            sub_10005B940();
          }
        }
        goto LABEL_56;
      case 0xB:
        sub_10001B78C(v15[1], a1);
        goto LABEL_30;
      case 0xD:
        if (sub_10003F7B0(v15[1]) == 19 && *(_DWORD *)(*(void *)(a1 + 64) + 208)) {
          *(_DWORD *)(a1 + 368) = 1;
        }
        goto LABEL_30;
      default:
        if (dword_10008FA20)
        {
          int v19 = ne_log_obj();
          if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR)) {
            sub_10005BF70();
          }
        }
        goto LABEL_56;
    }
  }
}

uint64_t sub_1000171C8(uint64_t a1)
{
  uint64_t v1 = (int *)(a1 + 16);
  if (*(_DWORD *)(a1 + 16) == 5190)
  {
    memcpy(*(void **)(**(void **)(a1 + 328) + 8), *(const void **)(*(void *)(*(void *)(a1 + 328) + 8) + 8), ***(void ***)(a1 + 328));
    sub_100002728(v1, 9216);
    return 0;
  }
  else
  {
    if (dword_10008FA20)
    {
      int v3 = ne_log_obj();
      if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR)) {
        sub_10005AED8();
      }
    }
    return 0xFFFFFFFFLL;
  }
}

uint64_t sub_100017258(uint64_t a1, uint64_t a2)
{
  int v3 = (int *)(a1 + 16);
  if (*(_DWORD *)(a1 + 16) == 5440)
  {
    BOOL v4 = sub_100022FA8(a2);
    if (v4)
    {
      uint64_t v5 = v4;
      uint64_t v6 = v4[1];
      if (*(unsigned char *)v6 == 1)
      {
        if ((sub_1000261F4((size_t **)(a1 + 336), v6[1]) & 0x80000000) != 0)
        {
          if (dword_10008FA20)
          {
            int v19 = ne_log_obj();
            if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR)) {
              sub_10005AF74();
            }
          }
        }
        else
        {
          for (uint64_t i = (char *)(v6 + 2); *i == 13; i += 16)
          {
            int v8 = sub_10003F7B0(*((void *)i + 1));
            int v9 = v8;
            if (*(_DWORD *)(*(void *)(a1 + 64) + 176) && sub_10003FB98(v8)) {
              sub_1000403F4(a1, v9);
            }
            switch(v9)
            {
              case 16:
                int v10 = *(int **)(a1 + 408);
                int v11 = *v10 | 1;
                goto LABEL_13;
              case 17:
                int v10 = *(int **)(a1 + 408);
                int v11 = *v10 | 2;
LABEL_13:
                int *v10 = v11;
                break;
              case 18:
                if ((sub_100014BFC(*((void *)i + 1)) & 0x80000000) != 0)
                {
                  if (dword_10008FA20)
                  {
                    int v12 = ne_log_obj();
                    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG)) {
                      sub_10005BFD8(&v23, v24, v12);
                    }
                  }
                  *(_DWORD *)(a1 + 100) = 1;
                }
                break;
              case 19:
                if (*(_DWORD *)(*(void *)(a1 + 64) + 208)) {
                  *(_DWORD *)(a1 + 368) = 1;
                }
                break;
              default:
                continue;
            }
          }
          if (*i)
          {
            if (dword_10008FA20)
            {
              uint64_t v20 = ne_log_obj();
              if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR)) {
                sub_10005BF70();
              }
            }
          }
          else
          {
            if (*(unsigned char *)(a1 + 96))
            {
              if (dword_10008FA20)
              {
                int v16 = ne_log_obj();
                if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
                {
                  char v17 = sub_10003F504(**(_DWORD **)(a1 + 88));
                  *(_DWORD *)buf = 136315138;
                  uint64_t v26 = v17;
                  _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "Selected NAT-T version: %s\n", buf, 0xCu);
                }
              }
              sub_10004F200(a1);
            }
            if ((sub_10000A144(*(unint64_t **)(a1 + 336), (void *)a1) & 0x80000000) == 0)
            {
              sub_100002728(v3, 5441);
              sub_10003FA78(v5);
              return 0;
            }
            if (dword_10008FA20)
            {
              int v21 = ne_log_obj();
              if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR)) {
                sub_10005B048();
              }
            }
          }
        }
      }
      else if (dword_10008FA20)
      {
        BOOL v15 = ne_log_obj();
        if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR)) {
          sub_10005B3AC();
        }
      }
      sub_10003FA78(v5);
    }
    else if (dword_10008FA20)
    {
      int v14 = ne_log_obj();
      if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR)) {
        sub_10005AF40();
      }
    }
  }
  else if (dword_10008FA20)
  {
    uint64_t v13 = ne_log_obj();
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR)) {
      sub_10005AED8();
    }
  }
  uint64_t v22 = *(void **)(a1 + 336);
  if (v22)
  {
    sub_10003FA78(v22);
    *(void *)(a1 + 336) = 0;
  }
  return 0xFFFFFFFFLL;
}

uint64_t sub_1000175EC(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = (int *)(a1 + 16);
  if (*(_DWORD *)(a1 + 16) != 5441)
  {
    if (dword_10008FA20)
    {
      int v9 = ne_log_obj();
      if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR)) {
        sub_10005AED8();
      }
    }
    return 0xFFFFFFFFLL;
  }
  sub_100025FD0((void *)(a1 + 8), *(void *)(a1 + 48), *(void *)(a1 + 56));
  uint64_t v5 = (uint64_t **)sub_100026474(0, *(void *)(a1 + 344), 1);
  char v29 = v5;
  int v6 = **(_DWORD **)(a1 + 408);
  if (v6)
  {
    if (dword_10008FA20)
    {
      int v11 = ne_log_obj();
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)uint64_t v28 = 0;
        _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "Adding xauth VID payload.\n", v28, 2u);
      }
    }
    int v12 = sub_10003F70C(16);
    if (v12)
    {
      int v7 = v12;
      uint64_t v5 = (uint64_t **)sub_100026474(v5, (uint64_t)v12, 13);
      char v29 = v5;
      if ((**(_DWORD **)(a1 + 408) & 2) == 0) {
        goto LABEL_4;
      }
      goto LABEL_14;
    }
    if (dword_10008FA20)
    {
      uint64_t v24 = ne_log_obj();
      if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR)) {
        sub_10005B7FC();
      }
    }
    return 0xFFFFFFFFLL;
  }
  int v7 = 0;
  if ((v6 & 2) == 0)
  {
LABEL_4:
    int v8 = 0;
    goto LABEL_16;
  }
LABEL_14:
  uint64_t v13 = sub_10003F70C(17);
  if (!v13)
  {
    if (dword_10008FA20)
    {
      uint64_t v27 = ne_log_obj();
      if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR)) {
        sub_10005B7C8();
      }
    }
    int v18 = 0;
    BOOL v15 = 0;
    int v8 = 0;
    uint64_t v10 = 0xFFFFFFFFLL;
    if (!v7) {
      goto LABEL_53;
    }
    goto LABEL_52;
  }
  int v8 = v13;
  uint64_t v5 = (uint64_t **)sub_100026474(v5, (uint64_t)v13, 13);
  char v29 = v5;
LABEL_16:
  if (*(unsigned char *)(a1 + 96))
  {
    int v14 = sub_10003F70C(**(_DWORD **)(a1 + 88));
    if (v14)
    {
      uint64_t v5 = (uint64_t **)sub_100026474(v5, (uint64_t)v14, 13);
      char v29 = v5;
    }
  }
  else
  {
    int v14 = 0;
  }
  if (*(_DWORD *)(*(void *)(a1 + 64) + 208))
  {
    BOOL v15 = sub_10003F70C(19);
    if (v15)
    {
      uint64_t v5 = (uint64_t **)sub_100026474(v5, (uint64_t)v15, 13);
      char v29 = v5;
    }
  }
  else
  {
    BOOL v15 = 0;
  }
  if (*(_DWORD *)(a1 + 100))
  {
    int v16 = (void **)sub_10003F70C(18);
    if (v16)
    {
      char v17 = sub_100015144(v16, 0x80000000);
      if (v17)
      {
        int v18 = v17;
        char v29 = (uint64_t **)sub_100026474(v5, (uint64_t)v17, 13);
        goto LABEL_32;
      }
    }
    if (dword_10008FA20)
    {
      int v19 = ne_log_obj();
      if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR)) {
        sub_10005B864();
      }
    }
  }
  int v18 = 0;
LABEL_32:
  *(void *)(a1 + 128) = sub_1000264D0(&v29, a1);
  *(_DWORD *)(a1 + 124) = *(_DWORD *)(*(void *)(a1 + 64) + 200);
  if (sub_100024104(a1) == -1)
  {
    if (dword_10008FA20)
    {
      uint8_t v23 = ne_log_obj();
      if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR)) {
        sub_10005AD0C();
      }
    }
LABEL_49:
    uint64_t v10 = 0xFFFFFFFFLL;
    if (!v14) {
      goto LABEL_51;
    }
    goto LABEL_50;
  }
  uint64_t v20 = *(void **)(a1 + 128);
  if (*(_DWORD *)(a1 + 100) && *v20 >= 0x501uLL)
  {
    uint64_t v21 = 0;
    LODWORD(v22) = *(_DWORD *)(a1 + 96);
  }
  else
  {
    unint64_t v22 = *(unsigned int *)(a1 + 96);
    uint64_t v21 = (v22 >> 3) & 4;
  }
  if (sub_100009070(*(void *)(a1 + 48), *(void *)(a1 + 56), (uint64_t)v20, a2, v21, (v22 >> 5) & 1) == -1)
  {
    if (dword_10008FA20)
    {
      uint64_t v25 = ne_log_obj();
      if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR)) {
        sub_10005B794();
      }
    }
    goto LABEL_49;
  }
  sub_100002728(v2, 5474);
  sub_1000496DC(1, 0, a1, 0);
  uint64_t v10 = 0;
  if (v14) {
LABEL_50:
  }
    sub_10003FA78(v14);
LABEL_51:
  if (v7) {
LABEL_52:
  }
    sub_10003FA78(v7);
LABEL_53:
  if (v8) {
    sub_10003FA78(v8);
  }
  if (v15) {
    sub_10003FA78(v15);
  }
  if (v18) {
    sub_10003FA78(v18);
  }
  return v10;
}

uint64_t sub_100017A0C(uint64_t a1, uint64_t a2)
{
  int v3 = (int *)(a1 + 16);
  if (*(_DWORD *)(a1 + 16) == 5474)
  {
    BOOL v4 = sub_100022FA8(a2);
    if (v4)
    {
      uint64_t v5 = v4;
      int v6 = 0;
      for (uint64_t i = (unsigned __int8 *)v4[1]; ; i += 16)
      {
        unsigned int v8 = *i;
        if (v8 <= 0x13) {
          break;
        }
        if (v8 != 20 && v8 != 130)
        {
LABEL_50:
          if (dword_10008FA20)
          {
            uint8_t v23 = ne_log_obj();
            if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR)) {
              sub_10005BF70();
            }
          }
          goto LABEL_65;
        }
LABEL_10:
        if (*(unsigned char *)(a1 + 96))
        {
          uint64_t v9 = *(void *)(a1 + 88);
          if (v9)
          {
            if (*(unsigned __int16 *)(v9 + 14) == v8)
            {
              uint64_t v31 = 0;
              if ((sub_1000261F4((size_t **)&v31, *((void *)i + 1)) & 0x80000000) != 0)
              {
                if (dword_10008FA20)
                {
                  uint64_t v27 = ne_log_obj();
                  if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR)) {
                    sub_10005B974();
                  }
                }
                goto LABEL_65;
              }
              if (!v6) {
                *(_DWORD *)(a1 + 96) |= 6u;
              }
              int v10 = sub_10003FD90(a1, (uint64_t)v31, v6);
              if (dword_10008FA20)
              {
                int v11 = v10;
                int v12 = ne_log_obj();
                if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
                {
                  *(_DWORD *)buf = 67109378;
                  uint64_t v13 = "verified";
                  if (!v11) {
                    uint64_t v13 = "doesn't match";
                  }
                  *(_DWORD *)uint64_t v33 = v6;
                  *(_WORD *)&v33[4] = 2080;
                  *(void *)&v33[6] = v13;
                  _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "NAT-D payload #%d %s\n", buf, 0x12u);
                }
              }
              ++v6;
              sub_10003FA78(v31);
            }
          }
        }
LABEL_28:
        ;
      }
      switch(*i)
      {
        case 4u:
          if ((sub_1000261F4((size_t **)(a1 + 160), *((void *)i + 1)) & 0x80000000) == 0) {
            goto LABEL_28;
          }
          if (dword_10008FA20)
          {
            uint64_t v24 = ne_log_obj();
            if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR)) {
              sub_10005B1B4();
            }
          }
          break;
        case 5u:
        case 6u:
        case 8u:
        case 9u:
        case 0xBu:
        case 0xCu:
        case 0xEu:
          goto LABEL_50;
        case 7u:
          if (dword_10008FA20)
          {
            int v14 = ne_log_obj();
            if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
            {
              *(_WORD *)buf = 0;
              _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "CR received, ignore it. It should be in other exchange.\n", buf, 2u);
            }
          }
          goto LABEL_28;
        case 0xAu:
          if ((sub_1000261F4((size_t **)(a1 + 184), *((void *)i + 1)) & 0x80000000) == 0) {
            goto LABEL_28;
          }
          if (dword_10008FA20)
          {
            uint64_t v25 = ne_log_obj();
            if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR)) {
              sub_10005B1E8();
            }
          }
          break;
        case 0xDu:
          sub_10003F7B0(*((void *)i + 1));
          goto LABEL_28;
        case 0xFu:
          goto LABEL_10;
        default:
          if (*i) {
            goto LABEL_50;
          }
          if (*(unsigned char *)(a1 + 96))
          {
            if (dword_10008FA20)
            {
              char v17 = ne_log_obj();
              if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
              {
                int v18 = "detected:";
                int v19 = *(_DWORD *)(a1 + 96);
                uint64_t v20 = "ME ";
                if ((v19 & 6) == 0) {
                  int v18 = "not detected";
                }
                if ((v19 & 2) == 0) {
                  uint64_t v20 = (const char *)&unk_100081F6D;
                }
                *(_DWORD *)buf = 136315650;
                *(void *)uint64_t v33 = v18;
                *(_WORD *)&uint8_t v33[8] = 2080;
                *(void *)&v33[10] = v20;
                if ((v19 & 4) != 0) {
                  uint64_t v21 = "PEER";
                }
                else {
                  uint64_t v21 = (const char *)&unk_100081F6D;
                }
                __int16 v34 = 2080;
                uint64_t v35 = v21;
                _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "NAT %s %s%s\n", buf, 0x20u);
              }
            }
          }
          if (*(void *)(a1 + 160) && *(void *)(a1 + 184))
          {
            sub_100002728(v3, 5443);
            sub_10003FA78(v5);
            return 0;
          }
          if (dword_10008FA20)
          {
            uint64_t v26 = ne_log_obj();
            if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR)) {
              sub_10005B014();
            }
          }
          break;
      }
LABEL_65:
      sub_10003FA78(v5);
    }
    else if (dword_10008FA20)
    {
      int v16 = ne_log_obj();
      if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR)) {
        sub_10005AF40();
      }
    }
  }
  else if (dword_10008FA20)
  {
    BOOL v15 = ne_log_obj();
    if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR)) {
      sub_10005AED8();
    }
  }
  uint64_t v28 = *(void **)(a1 + 160);
  if (v28)
  {
    sub_10003FA78(v28);
    *(void *)(a1 + 160) = 0;
  }
  char v29 = *(void **)(a1 + 184);
  if (v29)
  {
    sub_10003FA78(v29);
    *(void *)(a1 + 184) = 0;
  }
  uint64_t v30 = *(void **)(a1 + 320);
  if (v30)
  {
    sub_10003FA78(v30);
    *(void *)(a1 + 320) = 0;
  }
  return 0xFFFFFFFFLL;
}

uint64_t sub_100017EE0(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = (int *)(a1 + 16);
  if (*(_DWORD *)(a1 + 16) == 5443)
  {
    if ((sub_10002972C(*(void *)(*(void *)(a1 + 72) + 64), (size_t **)(a1 + 152), (void *)(a1 + 136)) & 0x80000000) != 0)
    {
      if (dword_10008FA20)
      {
        int v11 = ne_log_obj();
        if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR)) {
          sub_10005ACA4();
        }
      }
    }
    else
    {
      uint64_t v5 = sub_10000601C(*(_DWORD *)(*(void *)(a1 + 64) + 140));
      *(void *)(a1 + 176) = v5;
      if (v5)
      {
        int v6 = sub_100015EAC(a1);
        *(void *)(a1 + 128) = v6;
        if (v6)
        {
          *(_DWORD *)(a1 + 124) = *(_DWORD *)(*(void *)(a1 + 64) + 200);
          if (sub_100024104(a1) == -1)
          {
            if (dword_10008FA20)
            {
              BOOL v15 = ne_log_obj();
              if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR)) {
                sub_10005AD0C();
              }
            }
          }
          else
          {
            int v7 = *(void **)(a1 + 128);
            if (*(_DWORD *)(a1 + 100) && *v7 >= 0x501uLL)
            {
              uint64_t v8 = 0;
              LODWORD(v9) = *(_DWORD *)(a1 + 96);
            }
            else
            {
              unint64_t v9 = *(unsigned int *)(a1 + 96);
              uint64_t v8 = (v9 >> 3) & 4;
            }
            if (sub_100009070(*(void *)(a1 + 48), *(void *)(a1 + 56), (uint64_t)v7, a2, v8, (v9 >> 5) & 1) == -1)
            {
              if (dword_10008FA20)
              {
                int v16 = ne_log_obj();
                if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR)) {
                  sub_10005B794();
                }
              }
            }
            else if ((sub_10002952C(*(void *)(*(void *)(a1 + 72) + 64), *(void **)(a1 + 160), (void **)(a1 + 168), (void *)(a1 + 136)) & 0x80000000) != 0)
            {
              if (dword_10008FA20)
              {
                char v17 = ne_log_obj();
                if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR)) {
                  sub_10005B07C();
                }
              }
            }
            else if ((sub_10002CDA4(a1) & 0x80000000) != 0)
            {
              if (dword_10008FA20)
              {
                int v18 = ne_log_obj();
                if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR)) {
                  sub_10005B0B0();
                }
              }
            }
            else if ((sub_10002D164(a1) & 0x80000000) != 0)
            {
              if (dword_10008FA20)
              {
                int v19 = ne_log_obj();
                if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR)) {
                  sub_10005B0E4();
                }
              }
            }
            else if ((sub_10002D410((void *)a1) & 0x80000000) != 0)
            {
              if (dword_10008FA20)
              {
                uint64_t v20 = ne_log_obj();
                if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR)) {
                  sub_10005B118();
                }
              }
            }
            else
            {
              if ((sub_10002D828(a1) & 0x80000000) == 0)
              {
                sub_100002728(v2, 5476);
                return 0;
              }
              if (dword_10008FA20)
              {
                uint64_t v21 = ne_log_obj();
                if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR)) {
                  sub_10005B14C();
                }
              }
            }
          }
        }
        else if (dword_10008FA20)
        {
          uint64_t v13 = ne_log_obj();
          if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR)) {
            sub_10005C134();
          }
        }
      }
      else if (dword_10008FA20)
      {
        int v12 = ne_log_obj();
        if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR)) {
          sub_10005ACD8();
        }
      }
    }
  }
  else if (dword_10008FA20)
  {
    int v10 = ne_log_obj();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR)) {
      sub_10005AED8();
    }
  }
  return 0xFFFFFFFFLL;
}

uint64_t sub_10001823C(uint64_t a1, void *a2)
{
  int v3 = (int *)(a1 + 16);
  if (*(_DWORD *)(a1 + 16) != 5476)
  {
    if (dword_10008FA20)
    {
      uint64_t v5 = ne_log_obj();
      if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR)) {
        sub_10005AED8();
      }
    }
    goto LABEL_9;
  }
  if ((*(unsigned char *)(a2[1] + 19) & 1) == 0)
  {
    if (dword_10008FA20)
    {
      BOOL v4 = ne_log_obj();
      if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR)) {
        sub_10005C308();
      }
    }
LABEL_9:
    uint64_t v6 = 0xFFFFFFFFLL;
LABEL_10:
    int v7 = *(void **)(a1 + 320);
    if (v7)
    {
      sub_10003FA78(v7);
      *(void *)(a1 + 320) = 0;
    }
    sub_10002BC10(*(void **)(a1 + 288));
    *(void *)(a1 + 288) = 0;
    sub_10002BC10(*(void **)(a1 + 296));
    *(void *)(a1 + 296) = 0;
    uint64_t v8 = *(void **)(a1 + 272);
    if (v8)
    {
      sub_10003FA78(v8);
      *(void *)(a1 + 272) = 0;
    }
    sub_10002BC10(*(void **)(a1 + 304));
    *(void *)(a1 + 304) = 0;
    return v6;
  }
  int v10 = sub_10002E028(a1, a2, **(void **)(a1 + 328), *(void *)(*(void *)(a1 + 328) + 8));
  if (!v10)
  {
    if (dword_10008FA20)
    {
      char v17 = ne_log_obj();
      if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR)) {
        sub_10005C2D4();
      }
    }
    goto LABEL_9;
  }
  int v11 = v10;
  int v12 = sub_100022FA8((uint64_t)v10);
  if (!v12)
  {
    if (dword_10008FA20)
    {
      int v18 = ne_log_obj();
      if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR)) {
        sub_10005AF40();
      }
    }
    sub_10003FA78(v11);
    goto LABEL_9;
  }
  uint64_t v13 = v12;
  int v14 = 0;
  *(void *)(a1 + 352) = 0;
  BOOL v15 = v12[1];
  int v16 = (unint64_t **)(a1 + 320);
  while (2)
  {
    switch(*(unsigned char *)v15)
    {
      case 0:
        if (v14) {
          sub_10002BB90((void *)a1);
        }
        int v19 = *(_DWORD *)(*(void *)(a1 + 72) + 48);
        if (*(void *)(*(void *)(a1 + 64) + 272)) {
          BOOL v20 = v19 == 65001;
        }
        else {
          BOOL v20 = 0;
        }
        if (v20) {
          goto LABEL_75;
        }
        if (v19 > 64221)
        {
          switch(v19)
          {
            case 65002:
              goto LABEL_69;
            case 65003:
            case 65004:
            case 65005:
            case 65007:
            case 65009:
              goto LABEL_75;
            case 65006:
              goto LABEL_65;
            case 65008:
            case 65010:
              goto LABEL_70;
            default:
              if (v19 == 64222) {
                goto LABEL_69;
              }
              goto LABEL_75;
          }
        }
        if ((v19 - 4) < 2) {
          goto LABEL_70;
        }
        if (v19 == 1)
        {
LABEL_69:
          if (!*v16) {
            goto LABEL_78;
          }
LABEL_70:
          if (!*(void *)(a1 + 352)) {
            goto LABEL_78;
          }
        }
        else
        {
          if (v19 != 3)
          {
LABEL_75:
            if (dword_10008FA20)
            {
              uint64_t v27 = ne_log_obj();
              if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR)) {
                sub_10005C33C();
              }
            }
            goto LABEL_81;
          }
LABEL_65:
          if (!*v16 || !*(void *)(a1 + 272))
          {
LABEL_78:
            if (dword_10008FA20)
            {
              uint64_t v28 = ne_log_obj();
              if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR)) {
                sub_10005B014();
              }
            }
            goto LABEL_81;
          }
        }
        if (sub_10000F124(a1))
        {
          if (dword_10008FA20)
          {
            uint64_t v26 = ne_log_obj();
            if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR)) {
              sub_10005B180();
            }
          }
          goto LABEL_81;
        }
        uint64_t v6 = sub_10002ABA8(a1);
        if (v6 == -1)
        {
          char v29 = 0;
        }
        else
        {
          if (v6)
          {
            sub_10001AD08(a1, v6, 0);
            goto LABEL_81;
          }
          sub_10002CAB4(a1);
          if (dword_10008C2C8 >= 7) {
            sub_100033908(7, (*v16)[1], **v16, "peer's ID\n", v30, v31, v32, v33, v34);
          }
          memcpy(*(void **)(**(void **)(a1 + 328) + 8), *(const void **)(*(void *)(*(void *)(a1 + 328) + 8) + 8), **(void **)(*(void *)(a1 + 328) + 8));
          sub_100002728(v3, 5445);
          uint64_t v6 = 0;
          char v29 = 1;
        }
        goto LABEL_82;
      case 5:
        if ((sub_1000261F4((size_t **)(a1 + 320), v15[1]) & 0x80000000) == 0) {
          goto LABEL_31;
        }
        if (dword_10008FA20)
        {
          unint64_t v22 = ne_log_obj();
          if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR)) {
            sub_10005B21C();
          }
        }
        goto LABEL_81;
      case 6:
        if ((sub_10002C5EC(a1, v15[1]) & 0x80000000) == 0)
        {
          int v14 = 1;
LABEL_31:
          v15 += 2;
          continue;
        }
        if (dword_10008FA20)
        {
          uint8_t v23 = ne_log_obj();
          if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR)) {
            sub_10005B90C();
          }
        }
LABEL_81:
        char v29 = 0;
        uint64_t v6 = 0xFFFFFFFFLL;
LABEL_82:
        sub_10003FA78(v13);
        sub_10003FA78(v11);
        if ((v29 & 1) == 0) {
          goto LABEL_10;
        }
        return v6;
      case 7:
        if ((sub_10002C89C(a1, v15[1]) & 0x80000000) == 0) {
          goto LABEL_31;
        }
        if (dword_10008FA20)
        {
          uint64_t v24 = ne_log_obj();
          if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR)) {
            sub_10005B250();
          }
        }
        goto LABEL_81;
      case 8:
        *(void *)(a1 + 352) = v15[1];
        goto LABEL_31;
      case 9:
        if ((sub_1000261F4((size_t **)(a1 + 272), v15[1]) & 0x80000000) == 0) {
          goto LABEL_31;
        }
        if (dword_10008FA20)
        {
          uint64_t v25 = ne_log_obj();
          if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR)) {
            sub_10005B940();
          }
        }
        goto LABEL_81;
      case 0xB:
        sub_10001B78C(v15[1], a1);
        goto LABEL_31;
      case 0xD:
        sub_10003F7B0(v15[1]);
        goto LABEL_31;
      default:
        if (dword_10008FA20)
        {
          uint64_t v21 = ne_log_obj();
          if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR)) {
            sub_10005BF70();
          }
        }
        goto LABEL_81;
    }
  }
}

uint64_t sub_1000187EC(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = (int *)(a1 + 16);
  if (*(_DWORD *)(a1 + 16) == 5445)
  {
    if ((sub_10000F71C(a1) & 0x80000000) != 0)
    {
      if (dword_10008FA20)
      {
        int v12 = ne_log_obj();
        if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR)) {
          sub_10005AC08();
        }
      }
    }
    else
    {
      if (dword_10008FA20)
      {
        uint64_t v5 = ne_log_obj();
        if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG)) {
          sub_10005B8CC();
        }
      }
      uint64_t v6 = sub_10002A3E8(a1, 1);
      *(void *)(a1 + 256) = v6;
      if (v6)
      {
        *(unsigned char *)(a1 + 82) |= 1u;
        int v7 = sub_1000169E0(a1);
        *(void *)(a1 + 128) = v7;
        if (v7)
        {
          if ((sub_100023E30(a1, v7) & 0x80000000) != 0)
          {
            if (dword_10008FA20)
            {
              int v16 = ne_log_obj();
              if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR)) {
                sub_10005AD0C();
              }
            }
          }
          else
          {
            uint64_t v8 = *(void **)(a1 + 128);
            if (*(_DWORD *)(a1 + 100) && *v8 >= 0x501uLL)
            {
              uint64_t v9 = 0;
              LODWORD(v10) = *(_DWORD *)(a1 + 96);
            }
            else
            {
              unint64_t v10 = *(unsigned int *)(a1 + 96);
              uint64_t v9 = (v10 >> 3) & 4;
            }
            if (sub_100009070(*(void *)(a1 + 48), *(void *)(a1 + 56), (uint64_t)v8, a2, v9, (v10 >> 5) & 1) != -1)
            {
              memcpy(*(void **)(*(void *)(*(void *)(a1 + 328) + 8) + 8), *(const void **)(**(void **)(a1 + 328) + 8), ***(void ***)(a1 + 328));
              sub_100002728(v2, 9216);
              return 0;
            }
            if (dword_10008FA20)
            {
              char v17 = ne_log_obj();
              if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR)) {
                sub_10005B794();
              }
            }
          }
        }
        else if (dword_10008FA20)
        {
          int v14 = ne_log_obj();
          if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR)) {
            sub_10005C018();
          }
        }
      }
      else if (dword_10008FA20)
      {
        uint64_t v13 = ne_log_obj();
        if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR)) {
          sub_10005C100();
        }
      }
    }
  }
  else if (dword_10008FA20)
  {
    int v11 = ne_log_obj();
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR)) {
      sub_10005AED8();
    }
  }
  return 0xFFFFFFFFLL;
}

uint64_t sub_100018A28(uint64_t a1, void *a2)
{
  if (dword_10008FA20)
  {
    BOOL v4 = ne_log_obj();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "receive Information.\n", buf, 2u);
    }
  }
  uint64_t v5 = a2[1];
  char v6 = *(unsigned char *)(v5 + 19);
  int v7 = *(_DWORD *)(v5 + 20);
  if ((v6 & 1) == 0)
  {
    uint64_t v8 = sub_10003FAC0((uint64_t)a2);
    uint64_t v9 = v8;
    if (*v8 < 0x20)
    {
LABEL_6:
      if (dword_10008FA20)
      {
        unint64_t v10 = ne_log_obj();
        if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR)) {
          sub_10005C3A4();
        }
      }
      goto LABEL_9;
    }
    unint64_t v21 = v8[1];
    int v23 = *(unsigned __int8 *)(v21 + 28);
    char v17 = (unsigned __int8 *)(v21 + 28);
    int v22 = v23;
    int v24 = *(unsigned __int8 *)(a1 + 81);
    if (v24 == 4)
    {
      int v25 = *(_DWORD *)(a1 + 16);
      if ((v25 & 0x2000) == 0)
      {
        int v28 = *(_DWORD *)(a1 + 20);
        if (v25 == 5283 && !v28) {
          goto LABEL_50;
        }
        if (v25 == 5507 && v28 == 1) {
          goto LABEL_50;
        }
      }
    }
    else
    {
      if (v24 != 2) {
        goto LABEL_253;
      }
      int v25 = *(_DWORD *)(a1 + 16);
    }
    if ((v25 & 0x2000) == 0)
    {
      int v29 = *(_DWORD *)(a1 + 20);
      if (v29 == 1)
      {
        int v30 = 5445;
      }
      else
      {
        if (v29) {
          goto LABEL_253;
        }
        if (v25 == 5190)
        {
LABEL_50:
          uint64_t v33 = (uint64_t)v8;
          goto LABEL_51;
        }
        int v30 = 5221;
      }
      if (v25 == v30) {
        goto LABEL_50;
      }
    }
LABEL_253:
    BOOL v11 = !v22 && (v131 = *(_DWORD *)(a1 + 16), (v131 & 0x2000) == 0) && v131 == 5281 && *(_DWORD *)(a1 + 20) == 0;
    if (dword_10008FA20)
    {
      v133 = ne_log_obj();
      if (os_log_type_enabled(v133, OS_LOG_TYPE_ERROR)) {
        sub_10005C3D8(v22, a1, v133);
      }
    }
    uint64_t v12 = 0;
    goto LABEL_266;
  }
  if (!*(void *)(a1 + 328))
  {
    if (dword_10008FA20)
    {
      uint64_t v26 = ne_log_obj();
      if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR)) {
        sub_10005C790();
      }
    }
    return 0xFFFFFFFFLL;
  }
  uint64_t v13 = sub_10002DAA8(a1, v7);
  if (!v13)
  {
    if (dword_10008FA20)
    {
      uint64_t v27 = ne_log_obj();
      if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR)) {
        sub_10005C7C4();
      }
    }
    return 0xFFFFFFFFLL;
  }
  int v14 = v13;
  uint64_t v9 = sub_10002E028(a1, a2, *v13, v13[1]);
  sub_10002DA30(v14);
  if (!v9)
  {
    if (dword_10008FA20)
    {
      uint64_t v31 = ne_log_obj();
      if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR)) {
        sub_10005C7F8();
      }
    }
    return 0xFFFFFFFFLL;
  }
  unint64_t v15 = *v9;
  if (*v9 <= 0x1F) {
    goto LABEL_6;
  }
  unint64_t v16 = v9[1];
  if (*(unsigned char *)(v16 + 16) != 8)
  {
    if (dword_10008FA20)
    {
      uint64_t v32 = ne_log_obj();
      if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR)) {
        sub_10005CA0C();
      }
    }
    goto LABEL_9;
  }
  char v17 = (unsigned __int8 *)(v16 + 28);
  int v18 = *(unsigned __int8 *)(v16 + 28);
  if ((*(unsigned char *)(a1 + 17) & 0x20) == 0 && (!*(void *)(a1 + 72) || !*(void *)(a1 + 208)))
  {
    if (dword_10008FA20)
    {
      v142 = ne_log_obj();
      if (os_log_type_enabled(v142, OS_LOG_TYPE_ERROR)) {
        sub_10005C82C();
      }
    }
    goto LABEL_9;
  }
  uint64_t v19 = bswap32(*(unsigned __int16 *)(v16 + 30)) >> 16;
  if (v15 < v19 + 32)
  {
    if (dword_10008FA20)
    {
      BOOL v20 = ne_log_obj();
      if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR)) {
        sub_10005C860();
      }
    }
    goto LABEL_9;
  }
  v139 = (unsigned __int16 *)&v17[v19];
  size_t v140 = bswap32(*(unsigned __int16 *)&v17[v19 + 2]) >> 16;
  if (v15 - v19 - 28 < v140)
  {
    if (dword_10008FA20)
    {
      v141 = ne_log_obj();
      if (os_log_type_enabled(v141, OS_LOG_TYPE_ERROR)) {
        sub_10005C894();
      }
    }
    goto LABEL_9;
  }
  if (v140 <= 3)
  {
    if (dword_10008FA20)
    {
      v143 = ne_log_obj();
      if (os_log_type_enabled(v143, OS_LOG_TYPE_ERROR)) {
        sub_10005C8C8();
      }
    }
    goto LABEL_9;
  }
  v144 = sub_10003F940(v140);
  if (!v144)
  {
    if (dword_10008FA20)
    {
      v152 = ne_log_obj();
      if (os_log_type_enabled(v152, OS_LOG_TYPE_ERROR)) {
        sub_10005C8FC();
      }
    }
    goto LABEL_9;
  }
  v145 = v144;
  memcpy((void *)v144[1], v139, bswap32(v139[1]) >> 16);
  uint64_t v146 = sub_10002A314(a1, *(_DWORD *)(v16 + 20), (uint64_t)v145);
  if (!v146)
  {
    if (dword_10008FA20)
    {
      v153 = ne_log_obj();
      if (os_log_type_enabled(v153, OS_LOG_TYPE_ERROR)) {
        sub_10005C930();
      }
    }
    goto LABEL_316;
  }
  v147 = (void *)v146;
  size_t v148 = (bswap32(*(unsigned __int16 *)(v16 + 30)) >> 16) - 4;
  if (v148 != *(void *)v146)
  {
    if (dword_10008FA20)
    {
      v154 = ne_log_obj();
      if (os_log_type_enabled(v154, OS_LOG_TYPE_ERROR)) {
        sub_10005C9D8();
      }
    }
    goto LABEL_315;
  }
  if (timingsafe_bcmp((const void *)(v16 + 32), *(const void **)(v146 + 8), v148))
  {
    if (dword_10008FA20)
    {
      v149 = ne_log_obj();
      if (os_log_type_enabled(v149, OS_LOG_TYPE_ERROR)) {
        sub_10005C9A4();
      }
    }
LABEL_315:
    sub_10003FA78(v147);
LABEL_316:
    sub_10003FA78(v145);
    goto LABEL_9;
  }
  if (dword_10008FA20)
  {
    v155 = ne_log_obj();
    if (os_log_type_enabled(v155, OS_LOG_TYPE_DEBUG)) {
      sub_10005C964();
    }
  }
  sub_10003FA78(v147);
  sub_10003FA78(v145);
  uint64_t v33 = (uint64_t)v9;
  int v22 = v18;
LABEL_51:
  char v34 = sub_100022FA8(v33);
  if (!v34)
  {
    if (dword_10008FA20)
    {
      v136 = (unint64_t *)v33;
      v137 = ne_log_obj();
      if (os_log_type_enabled(v137, OS_LOG_TYPE_ERROR)) {
        sub_10005AF40();
      }
      BOOL v11 = 0;
      uint64_t v12 = 0xFFFFFFFFLL;
      uint64_t v9 = v136;
      goto LABEL_266;
    }
    uint64_t v9 = (unint64_t *)v33;
LABEL_9:
    BOOL v11 = 0;
    uint64_t v12 = 0xFFFFFFFFLL;
    goto LABEL_266;
  }
  uint64_t v9 = (unint64_t *)v34;
  v157 = (void *)v33;
  v158 = v17;
  int v156 = v22;
  uint64_t v12 = 0;
  BOOL v11 = 0;
  int v159 = v6 & 1;
  uint64_t v35 = (uint64_t)v34[1] + 8;
  while (2)
  {
    switch(*(unsigned char *)(v35 - 8))
    {
      case 8:
        goto LABEL_242;
      case 9:
        goto LABEL_96;
      case 0xA:
        if (dword_10008FA20)
        {
          uint64_t v36 = ne_log_obj();
          if (os_log_type_enabled(v36, OS_LOG_TYPE_ERROR)) {
            sub_10005C760(&v160, v161);
          }
        }
        goto LABEL_242;
      case 0xB:
        uint64_t v37 = *(void *)v35;
        unsigned int v38 = *(unsigned __int16 *)(*(void *)v35 + 10);
        if (v38 == 3584)
        {
          int v39 = *(_DWORD *)(a1 + 16);
          if ((v39 & 0x2000) == 0 && v39 == 5281 && *(_DWORD *)(a1 + 20) == 0)
          {
            if (dword_10008FA20)
            {
              uint64_t v69 = ne_log_obj();
              if (os_log_type_enabled(v69, OS_LOG_TYPE_ERROR))
              {
                v121 = sub_10003E1DC(v156);
                v122 = sub_10003E164(14);
                int v123 = *(_DWORD *)(a1 + 16);
                int v124 = *(_DWORD *)(a1 + 20);
                *(_DWORD *)buf = 136315906;
                *(void *)v173 = v121;
                *(_WORD *)&v173[8] = 2080;
                *(void *)&v173[10] = v122;
                *(_WORD *)&v173[18] = 1024;
                *(_DWORD *)v174 = v123;
                *(_WORD *)&v174[4] = 1024;
                *(_DWORD *)v175 = v124;
                _os_log_error_impl((void *)&_mh_execute_header, v69, OS_LOG_TYPE_ERROR, "%s message with %s notification receveid, status 0x%x, side %d\n", buf, 0x22u);
              }
            }
            BOOL v11 = 1;
            goto LABEL_242;
          }
        }
        int v41 = __rev16(v38);
        if (v41 > 36135)
        {
          if (v41 > 40499)
          {
            if (v41 == 40500) {
              goto LABEL_212;
            }
            if (v41 == 40501)
            {
              if (*(_DWORD *)(a1 + 20))
              {
                if (!dword_10008FA20) {
                  goto LABEL_212;
                }
                __int16 v66 = ne_log_obj();
                if (!os_log_type_enabled(v66, OS_LOG_TYPE_DEFAULT)) {
                  goto LABEL_212;
                }
                *(_WORD *)buf = 0;
                char v67 = v66;
                v68 = "LOAD-BALANCE notification ignored - we are not the initiator.\n";
              }
              else if (v159)
              {
                if (*(_WORD *)(v37 + 2) == 0x2000)
                {
                  int v96 = sub_100009F24(a1);
                  v97 = (unsigned int *)(v37 + 28);
                  sub_100049388(0x9E35u, 1u, v96, 4u, (const void *)(v37 + 28));
                  if (dword_10008FA20)
                  {
                    v98 = ne_log_obj();
                    if (os_log_type_enabled(v98, OS_LOG_TYPE_DEFAULT))
                    {
                      *(_WORD *)buf = 0;
                      _os_log_impl((void *)&_mh_execute_header, v98, OS_LOG_TYPE_DEFAULT, "Received LOAD_BALANCE notification.\n", buf, 2u);
                    }
                  }
                  if (*(_DWORD *)(*(void *)(a1 + 48) + 4) != bswap32(*v97))
                  {
                    if (dword_10008FA20)
                    {
                      v99 = ne_log_obj();
                      if (os_log_type_enabled(v99, OS_LOG_TYPE_DEFAULT))
                      {
                        unsigned int v100 = bswap32(*v97);
                        *(_DWORD *)buf = 67109120;
                        *(_DWORD *)v173 = v100;
                        _os_log_impl((void *)&_mh_execute_header, v99, OS_LOG_TYPE_DEFAULT, "Deleting old Phase 1 because of LOAD_BALANCE notification - redirect address=%x.\n", buf, 8u);
                      }
                    }
                    if ((*(unsigned char *)(a1 + 17) & 0x20) != 0) {
                      sub_10001A098(a1);
                    }
                    sub_100022854(a1);
                  }
                  goto LABEL_212;
                }
                if (!dword_10008FA20
                  || (v107 = ne_log_obj(), !os_log_type_enabled(v107, OS_LOG_TYPE_DEFAULT)))
                {
LABEL_212:
                  unint64_t v108 = *(unsigned __int8 *)(v37 + 9);
                  if (*(unsigned char *)(v37 + 9))
                  {
                    if (v108 + 12 > bswap32(*(unsigned __int16 *)(v37 + 2)) >> 16)
                    {
                      if (dword_10008FA20)
                      {
                        v138 = ne_log_obj();
                        if (os_log_type_enabled(v138, OS_LOG_TYPE_ERROR)) {
                          sub_10005C53C();
                        }
                      }
                      goto LABEL_279;
                    }
                    v109 = sub_10003D954(v37 + 12, v108);
                    if (dword_10008FA20)
                    {
                      v110 = ne_log_obj();
                      if (os_log_type_enabled(v110, OS_LOG_TYPE_DEFAULT))
                      {
                        v111 = sub_10003E164(v41);
                        unsigned int v112 = bswap32(*(_DWORD *)(v37 + 4));
                        int v113 = *(unsigned __int8 *)(v37 + 8);
                        int v114 = *(unsigned __int8 *)(v37 + 9);
                        *(_DWORD *)buf = 67110402;
                        *(_DWORD *)v173 = v41;
                        *(_WORD *)&v173[4] = 2080;
                        *(void *)&v173[6] = v111;
                        *(_WORD *)&v173[14] = 1024;
                        *(_DWORD *)&v173[16] = v112;
                        *(_WORD *)v174 = 1024;
                        *(_DWORD *)&v174[2] = v113;
                        *(_WORD *)v175 = 2080;
                        *(void *)&v175[2] = v109;
                        __int16 v176 = 1024;
                        int v177 = v114;
                        _os_log_impl((void *)&_mh_execute_header, v110, OS_LOG_TYPE_DEFAULT, "Notification message %d:%s, doi=%d proto_id=%d spi=%s(size=%d).\n", buf, 0x2Eu);
                      }
                    }
                    free(v109);
                  }
                  if ((unsigned __int16)(v41 - 1) <= 0x3FFEu)
                  {
                    uint64_t v115 = (bswap32(*(unsigned __int16 *)(v37 + 2)) >> 16) - 12;
                    uint64_t v116 = *(unsigned __int8 *)(v37 + 9);
                    if (v115 != v116)
                    {
                      v117 = sub_10003F940(v115 - v116);
                      if (v117)
                      {
                        v118 = v117;
                        memcpy((void *)v117[1], (const void *)(v116 + v37 + 12), *v117);
                        if (dword_10008FA20)
                        {
                          v119 = ne_log_obj();
                          if (os_log_type_enabled(v119, OS_LOG_TYPE_ERROR))
                          {
                            v127 = sub_10002911C((char *)v118[1], *v118);
                            *(_DWORD *)buf = 136315138;
                            *(void *)v173 = v127;
                            _os_log_error_impl((void *)&_mh_execute_header, v119, OS_LOG_TYPE_ERROR, "Message: '%s'.\n", buf, 0xCu);
                          }
                        }
                        sub_10003FA78(v118);
                      }
                      else if (dword_10008FA20)
                      {
                        v120 = ne_log_obj();
                        if (os_log_type_enabled(v120, OS_LOG_TYPE_ERROR)) {
                          sub_10005C50C(&v162, v163);
                        }
                      }
                    }
                  }
                  goto LABEL_241;
                }
                *(_WORD *)buf = 0;
                char v67 = v107;
                v68 = "isakmp_info_recv_lb Invalid length of payload\n";
              }
              else
              {
                if (!dword_10008FA20) {
                  goto LABEL_212;
                }
                v91 = ne_log_obj();
                if (!os_log_type_enabled(v91, OS_LOG_TYPE_DEFAULT)) {
                  goto LABEL_212;
                }
                *(_WORD *)buf = 0;
                char v67 = v91;
                v68 = "LOAD-BALANCE notification ignored - not protected.\n";
              }
              _os_log_impl((void *)&_mh_execute_header, v67, OS_LOG_TYPE_DEFAULT, v68, buf, 2u);
              goto LABEL_212;
            }
LABEL_146:
            if ((unsigned __int16)(v41 - 1) > 0x3FFEu)
            {
              if (dword_10008FA20)
              {
                v83 = ne_log_obj();
                if (os_log_type_enabled(v83, OS_LOG_TYPE_ERROR)) {
                  sub_10005C600((uint64_t)v178, v41);
                }
              }
            }
            else
            {
              if (!v7)
              {
                if (dword_10008FA20)
                {
                  v151 = ne_log_obj();
                  if (os_log_type_enabled(v151, OS_LOG_TYPE_ERROR)) {
                    sub_10005C4D8();
                  }
                }
                goto LABEL_279;
              }
              if (sub_100007F40(a1, v7))
              {
                if (dword_10008FA20)
                {
                  v78 = ne_log_obj();
                  if (os_log_type_enabled(v78, OS_LOG_TYPE_ERROR)) {
                    sub_10005C5B8((uint64_t)v179, v41);
                  }
                }
              }
              else if (dword_10008FA20)
              {
                v101 = ne_log_obj();
                if (os_log_type_enabled(v101, OS_LOG_TYPE_ERROR)) {
                  sub_10005C570((uint64_t)v180, v41);
                }
              }
            }
            goto LABEL_212;
          }
          if (v41 != 36136)
          {
            if (v41 == 36137)
            {
              if (v159)
              {
                if (dword_10008FA20)
                {
                  __int16 v62 = ne_log_obj();
                  if (os_log_type_enabled(v62, OS_LOG_TYPE_DEFAULT))
                  {
                    *(_WORD *)buf = 0;
                    _os_log_impl((void *)&_mh_execute_header, v62, OS_LOG_TYPE_DEFAULT, "DPD R-U-There-Ack received\n", buf, 2u);
                  }
                }
                int v63 = *(unsigned __int16 *)(a1 + 384);
                if (bswap32(*(_DWORD *)(v37 + 28)) == v63)
                {
                  if (*(void *)(v37 + 12) == *(void *)a1 && *(void *)(v37 + 20) == *(void *)(a1 + 8))
                  {
                    *(unsigned char *)(a1 + 386) = 0;
                    *(_WORD *)(a1 + 384) = v63 + 1;
                    *(void *)(a1 + 376) = time(0);
                    uint64_t v129 = *(unsigned int *)(a1 + 388);
                    if (v129)
                    {
                      sub_10003AC14(v129);
                      *(_DWORD *)(a1 + 388) = 0;
                    }
                    sub_10001BF60(a1, 0);
                    if (dword_10008FA20)
                    {
                      v130 = ne_log_obj();
                      if (os_log_type_enabled(v130, OS_LOG_TYPE_DEFAULT))
                      {
                        *(_WORD *)buf = 0;
                        _os_log_impl((void *)&_mh_execute_header, v130, OS_LOG_TYPE_DEFAULT, "received an R-U-THERE-ACK\n", buf, 2u);
                      }
                    }
                    sub_100049A44(1, a1);
                  }
                  else if (dword_10008FA20)
                  {
                    unint64_t v64 = ne_log_obj();
                    if (os_log_type_enabled(v64, OS_LOG_TYPE_ERROR)) {
                      sub_10005C6AC(&v166, v167);
                    }
                  }
                }
                else if (dword_10008FA20)
                {
                  v92 = ne_log_obj();
                  if (os_log_type_enabled(v92, OS_LOG_TYPE_ERROR))
                  {
                    unsigned int v93 = bswap32(*(_DWORD *)(v37 + 28));
                    int v94 = *(unsigned __int16 *)(a1 + 384);
                    *(_DWORD *)buf = 67109376;
                    *(_DWORD *)v173 = v93;
                    *(_WORD *)&v173[4] = 1024;
                    *(_DWORD *)&v173[6] = v94;
                    v87 = v92;
                    v88 = "Wrong DPD sequence number (%d, %d expected).\n";
LABEL_206:
                    uint32_t v89 = 14;
LABEL_207:
                    _os_log_error_impl((void *)&_mh_execute_header, v87, OS_LOG_TYPE_ERROR, v88, buf, v89);
                  }
                }
                goto LABEL_241;
              }
              goto LABEL_212;
            }
            goto LABEL_146;
          }
          if (!v159) {
            goto LABEL_212;
          }
          if (dword_10008FA20)
          {
            v73 = ne_log_obj();
            if (os_log_type_enabled(v73, OS_LOG_TYPE_DEFAULT))
            {
              *(_WORD *)buf = 0;
              _os_log_impl((void *)&_mh_execute_header, v73, OS_LOG_TYPE_DEFAULT, "DPD R-U-There received\n", buf, 2u);
            }
          }
          __int16 v74 = sub_10003F940(0x20uLL);
          if (v74)
          {
            v75 = v74;
            uint64_t v76 = v74[1];
            *(unsigned char *)uint64_t v76 = 0;
            *(_WORD *)(v76 + 2) = 0x2000;
            *(void *)(v76 + 4) = 0x298D100101000000;
            *(void *)(v76 + 12) = *(void *)(v37 + 12);
            *(void *)(v76 + 20) = *(void *)(v37 + 20);
            *(_DWORD *)(v76 + 28) = *(_DWORD *)(v37 + 28);
            uint64_t v12 = sub_10001A15C(a1, (uint64_t)v74, 11, 1);
            sub_10003FA78(v75);
            if (dword_10008FA20)
            {
              v77 = ne_log_obj();
              if (os_log_type_enabled(v77, OS_LOG_TYPE_DEFAULT))
              {
                *(_WORD *)buf = 0;
                _os_log_impl((void *)&_mh_execute_header, v77, OS_LOG_TYPE_DEFAULT, "received a valid R-U-THERE, ACK sent\n", buf, 2u);
              }
            }
          }
          else
          {
            if (dword_10008FA20)
            {
              v95 = ne_log_obj();
              if (os_log_type_enabled(v95, OS_LOG_TYPE_ERROR)) {
                sub_10005C67C(&v164, v165);
              }
            }
            uint64_t v12 = *__error();
          }
          if ((v12 & 0x80000000) != 0) {
            goto LABEL_280;
          }
LABEL_242:
          v35 += 16;
          continue;
        }
        if (v41 > 24576)
        {
          if (v41 == 24577) {
            goto LABEL_212;
          }
          if (v41 != 24578) {
            goto LABEL_146;
          }
          if (!v159) {
            goto LABEL_212;
          }
          sub_10001B420(a1);
LABEL_241:
          uint64_t v12 = 0;
          goto LABEL_242;
        }
        if (v41 == 0x4000) {
          goto LABEL_212;
        }
        if (v41 != 24576) {
          goto LABEL_146;
        }
        if (!v159) {
          goto LABEL_212;
        }
        unint64_t v42 = *(unsigned __int8 *)(v37 + 9);
        if (v42 + 12 <= bswap32(*(unsigned __int16 *)(v37 + 2)) >> 16)
        {
          uint64_t v43 = sub_10003D954(v37 + 12, v42);
          if (dword_10008FA20)
          {
            int v44 = ne_log_obj();
            if (os_log_type_enabled(v44, OS_LOG_TYPE_DEFAULT))
            {
              unsigned int v45 = bswap32(*(_DWORD *)(v37 + 4));
              int v46 = *(unsigned __int8 *)(v37 + 8);
              int v47 = *(unsigned __int8 *)(v37 + 9);
              *(_DWORD *)buf = 67109890;
              *(_DWORD *)v173 = v45;
              *(_WORD *)&v173[4] = 1024;
              *(_DWORD *)&v173[6] = v46;
              *(_WORD *)&v173[10] = 2080;
              *(void *)&v173[12] = v43;
              *(_WORD *)v174 = 1024;
              *(_DWORD *)&v174[2] = v47;
              _os_log_impl((void *)&_mh_execute_header, v44, OS_LOG_TYPE_DEFAULT, "notification message ISAKMP-SA RESPONDER-LIFETIME, doi=%d proto_id=%d spi=%s(size=%d).\n", buf, 0x1Eu);
            }
          }
          free(v43);
          goto LABEL_241;
        }
        if (dword_10008FA20)
        {
          v150 = ne_log_obj();
          if (os_log_type_enabled(v150, OS_LOG_TYPE_ERROR)) {
            sub_10005C648();
          }
        }
LABEL_279:
        uint64_t v12 = 0xFFFFFFFFLL;
LABEL_280:
        sub_10003FA78(v157);
LABEL_266:
        sub_10003FA78(v9);
        if (v11)
        {
          uint64_t v134 = *(void *)(a1 + 440);
          if (v134)
          {
            gettimeofday((timeval *)(v134 + 336), 0);
            if (!*(void *)(v134 + 296)) {
              *(void *)(v134 + 296) = off_10008C528;
            }
            sub_10004DAD4(v134);
          }
        }
        return v12;
      case 0xC:
        uint64_t v48 = *(void *)v35;
        int v170 = 0;
        int v49 = dword_10008FA20;
        if (*(_DWORD *)(v48 + 4) == 0x1000000) {
          goto LABEL_74;
        }
        if (dword_10008FA20)
        {
          uint64_t v61 = ne_log_obj();
          if (os_log_type_enabled(v61, OS_LOG_TYPE_ERROR)) {
            sub_10005C70C(v181, (unsigned int *)(v48 + 4), v182, v61);
          }
        }
        if ((**(unsigned char **)(a1 + 408) & 2) == 0 || *(_DWORD *)(v48 + 4)) {
          goto LABEL_241;
        }
        int v49 = dword_10008FA20;
LABEL_74:
        uint64_t v50 = bswap32(*(unsigned __int16 *)(v48 + 10)) >> 16;
        if ((bswap32(*(unsigned __int16 *)(v48 + 2)) >> 16) - 12 != *(unsigned __int8 *)(v48 + 9) * v50)
        {
          if (v49)
          {
            char v65 = ne_log_obj();
            if (os_log_type_enabled(v65, OS_LOG_TYPE_ERROR)) {
              sub_10005C6DC(&v168, v169);
            }
          }
          goto LABEL_241;
        }
        if (v49)
        {
          long long v51 = ne_log_obj();
          if (os_log_type_enabled(v51, OS_LOG_TYPE_DEFAULT))
          {
            int v52 = sub_10003E344(*(unsigned __int8 *)(v48 + 8));
            *(_DWORD *)buf = 136315138;
            *(void *)v173 = v52;
            _os_log_impl((void *)&_mh_execute_header, v51, OS_LOG_TYPE_DEFAULT, "delete payload for protocol %s\n", buf, 0xCu);
          }
        }
        uint64_t v53 = *(void *)(a1 + 64);
        if (*(_DWORD *)(v53 + 240) | v159)
        {
          int v54 = *(unsigned __int8 *)(v48 + 8);
          if ((v54 - 2) < 2)
          {
            if (*(unsigned char *)(v48 + 9) != 4)
            {
              if (dword_10008FA20)
              {
                v90 = ne_log_obj();
                if (os_log_type_enabled(v90, OS_LOG_TYPE_ERROR))
                {
LABEL_205:
                  int v105 = *(unsigned __int8 *)(v48 + 9);
                  int v106 = *(unsigned __int8 *)(v48 + 8);
                  *(_DWORD *)buf = 67109376;
                  *(_DWORD *)v173 = v105;
                  *(_WORD *)&v173[4] = 1024;
                  *(_DWORD *)&v173[6] = v106;
                  v87 = v90;
                  v88 = "delete payload with strange spi size %d(proto_id:%d)\n";
                  goto LABEL_206;
                }
              }
              goto LABEL_241;
            }
            if (*(_DWORD *)(v53 + 180) && (*(_WORD *)(*(void *)(a1 + 440) + 264) & 8) != 0)
            {
              v79 = sub_1000080D0(*(void *)(a1 + 56), *(void *)(a1 + 48), *(unsigned __int8 *)(v48 + 8), *(_DWORD *)(v48 + 12));
              if (v79)
              {
                *((unsigned char *)v79 + 264) |= 4u;
                if (!dword_10008FA20) {
                  goto LABEL_241;
                }
                v80 = ne_log_obj();
                if (!os_log_type_enabled(v80, OS_LOG_TYPE_DEFAULT))
                {
LABEL_237:
                  if (dword_10008FA20)
                  {
                    v126 = ne_log_obj();
                    if (os_log_type_enabled(v126, OS_LOG_TYPE_DEFAULT))
                    {
                      *(_WORD *)buf = 0;
                      v71 = v126;
                      v72 = "purged SAs.\n";
                      goto LABEL_240;
                    }
                  }
                  goto LABEL_241;
                }
                *(_WORD *)buf = 0;
                v81 = v80;
                v82 = "Ignoring SA delete from peer for L2TP server\n";
LABEL_246:
                _os_log_impl((void *)&_mh_execute_header, v81, OS_LOG_TYPE_DEFAULT, v82, buf, 2u);
                goto LABEL_237;
              }
              int v54 = *(unsigned __int8 *)(v48 + 8);
            }
            unint64_t v102 = *(void *)(a1 + 48);
            v103 = (int *)(v48 + 12);
            int v104 = v54;
          }
          else
          {
            if (v54 != 4)
            {
              if (v54 != 1)
              {
                if (dword_10008FA20)
                {
                  v85 = ne_log_obj();
                  if (os_log_type_enabled(v85, OS_LOG_TYPE_ERROR))
                  {
                    int v86 = *(unsigned __int8 *)(v48 + 8);
                    *(_DWORD *)buf = 67109120;
                    *(_DWORD *)v173 = v86;
                    v87 = v85;
                    v88 = "deletion message received, invalid proto_id: %d\n";
                    uint32_t v89 = 8;
                    goto LABEL_207;
                  }
                }
                goto LABEL_241;
              }
              if (*(unsigned char *)(v48 + 9) != 16)
              {
                if (dword_10008FA20)
                {
                  v90 = ne_log_obj();
                  if (os_log_type_enabled(v90, OS_LOG_TYPE_ERROR)) {
                    goto LABEL_205;
                  }
                }
                goto LABEL_241;
              }
              uint64_t v55 = sub_1000072D0(*(void *)(a1 + 440), (void *)(v48 + 12));
              if (!v55) {
                goto LABEL_237;
              }
              uint64_t v56 = v55;
              if (*(_DWORD *)(v55 + 116))
              {
                uint64_t v57 = *(void *)(v55 + 440);
                if (v57)
                {
                  int v58 = *(unsigned __int16 *)(v57 + 264);
                  if ((~v58 & 0x401) == 0 && ((v58 & 8) == 0 || !*(_DWORD *)(*(void *)(v55 + 64) + 180))) {
                    sub_1000248F0(v55, 0);
                  }
                }
              }
              uint64_t v59 = *(unsigned int *)(v56 + 120);
              if (v59)
              {
                sub_10003AC14(v59);
                *(_DWORD *)(v56 + 120) = 0;
              }
              if (*(_DWORD *)(v56 + 24)
                || (*(unsigned char *)(v56 + 432) & 1) != 0
                && (uint64_t v125 = *(void *)(v56 + 440)) != 0
                && (*(_WORD *)(v125 + 264) & 0x400) != 0)
              {
                if (sub_100007808(v56)) {
                  sub_10001AA00(v56, 1, 50002, 0);
                }
              }
              if (!*(_DWORD *)(*(void *)(v56 + 64) + 180) || (*(_WORD *)(*(void *)(v56 + 440) + 264) & 8) == 0)
              {
                sub_100022854(v56);
                goto LABEL_237;
              }
              if (!dword_10008FA20) {
                goto LABEL_241;
              }
              v128 = ne_log_obj();
              if (!os_log_type_enabled(v128, OS_LOG_TYPE_DEFAULT)) {
                goto LABEL_237;
              }
              *(_WORD *)buf = 0;
              v81 = v128;
              v82 = "Ignoring IKE delete from peer for L2TP server\n";
              goto LABEL_246;
            }
            int v170 = 0;
            int v84 = *(unsigned __int8 *)(v48 + 9);
            if (v84 == 4)
            {
              int v170 = *(_DWORD *)(v48 + 12);
            }
            else
            {
              if (v84 != 2)
              {
                if (dword_10008FA20)
                {
                  v90 = ne_log_obj();
                  if (os_log_type_enabled(v90, OS_LOG_TYPE_ERROR)) {
                    goto LABEL_205;
                  }
                }
                goto LABEL_241;
              }
              HIWORD(v170) = *(_WORD *)(v48 + 12);
            }
            unint64_t v102 = *(void *)(a1 + 48);
            v103 = &v170;
            int v104 = 4;
          }
          sub_10001B0C4(v102, v104, v103, v50, 0, 0);
          goto LABEL_237;
        }
        if (dword_10008FA20)
        {
          uint64_t v70 = ne_log_obj();
          if (os_log_type_enabled(v70, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)buf = 0;
            v71 = v70;
            v72 = "Ignoring unencrypted delete payload (check the weak_phase1_check option)\n";
LABEL_240:
            _os_log_impl((void *)&_mh_execute_header, v71, OS_LOG_TYPE_DEFAULT, v72, buf, 2u);
            goto LABEL_241;
          }
        }
        goto LABEL_241;
      default:
        if (!*(unsigned char *)(v35 - 8)) {
          goto LABEL_280;
        }
LABEL_96:
        if (dword_10008FA20)
        {
          int v60 = ne_log_obj();
          if (os_log_type_enabled(v60, OS_LOG_TYPE_ERROR)) {
            sub_10005C480((uint64_t)v171, v158);
          }
        }
        goto LABEL_241;
    }
  }
}

uint64_t sub_10001A098(uint64_t a1)
{
  if ((*(unsigned char *)(a1 + 17) & 0x20) == 0) {
    return 0;
  }
  int v3 = sub_10003F940(0x1CuLL);
  if (v3)
  {
    BOOL v4 = v3;
    uint64_t v5 = v3[1];
    *(unsigned char *)uint64_t v5 = 0;
    *(_WORD *)(v5 + 2) = 7168;
    *(void *)(v5 + 4) = 0x100100101000000;
    *(_OWORD *)(v5 + 12) = *(_OWORD *)a1;
    uint64_t v6 = sub_10001A15C(a1, (uint64_t)v3, 12, 0);
    sub_10003FA78(v4);
    return v6;
  }
  else
  {
    if (dword_10008FA20)
    {
      int v7 = ne_log_obj();
      if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR)) {
        sub_10005CA40();
      }
    }
    return *__error();
  }
}

uint64_t sub_10001A15C(uint64_t a1, uint64_t a2, int a3, char a4)
{
  uint64_t v8 = sub_100008234(16, 1);
  if (!v8)
  {
    if (dword_10008FA20)
    {
      uint64_t v19 = ne_log_obj();
      if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR)) {
        sub_10005CA74();
      }
    }
    return 0xFFFFFFFFLL;
  }
  uint64_t v9 = (uint64_t)v8;
  unint64_t v10 = sub_10003CC74();
  *(void *)(v9 + 8) = v10;
  if (!v10)
  {
    if (dword_10008FA20)
    {
      BOOL v20 = ne_log_obj();
      if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR)) {
        sub_10005CAA8();
      }
    }
    goto LABEL_43;
  }
  BOOL v11 = sub_10003CC74();
  *(void *)uint64_t v9 = v11;
  if (!v11)
  {
    if (dword_10008FA20)
    {
      unint64_t v21 = ne_log_obj();
      if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR)) {
        sub_10005CADC();
      }
    }
    goto LABEL_43;
  }
  int v12 = *(unsigned __int8 *)(*(void *)(a1 + 48) + 1);
  if (v12 != 2 && v12 != 30)
  {
    if (dword_10008FA20)
    {
      int v22 = ne_log_obj();
      if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR)) {
        sub_10005CB10(a1 + 48, v22);
      }
    }
LABEL_43:
    sub_10000843C(v9);
    return 0xFFFFFFFFLL;
  }
  *(unsigned char *)(v9 + 60) = 0;
  sub_100002728((int *)(v9 + 56), 63);
  int v14 = sub_100026328(a1);
  *(_DWORD *)(v9 + 108) = v14;
  if (*(void *)(a1 + 208))
  {
    unint64_t v15 = sub_10002DAA8(a1, v14);
    *(void *)(v9 + 240) = v15;
    if (!v15)
    {
      if (dword_10008FA20)
      {
        int v30 = ne_log_obj();
        if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR)) {
          sub_10005B14C();
        }
      }
      goto LABEL_43;
    }
    unint64_t v16 = (const void **)sub_10002A314(a1, *(_DWORD *)(v9 + 108), a2);
    if (!v16)
    {
      if (dword_10008FA20)
      {
        uint64_t v32 = ne_log_obj();
        if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR)) {
          sub_10005C100();
        }
      }
      goto LABEL_43;
    }
    char v17 = v16;
    uint64_t v18 = *(int *)v16 + 32;
  }
  else
  {
    char v17 = 0;
    uint64_t v18 = 28;
  }
  char v23 = v17 != 0;
  if ((a4 & 4) != 0) {
    char v23 = 4 * (v17 != 0);
  }
  *(unsigned char *)(v9 + 105) = v23;
  sub_10004C148(a1, (void *)v9);
  uint64_t v24 = v18 + *(void *)a2;
  int v25 = sub_10003F940((int)v24);
  *(void *)(v9 + 80) = v25;
  if (!v25)
  {
    if (dword_10008FA20)
    {
      uint64_t v31 = ne_log_obj();
      if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR)) {
        sub_10005CB90();
      }
    }
    goto LABEL_67;
  }
  uint64_t v26 = v25[1];
  *(void *)uint64_t v26 = *(void *)a1;
  *(void *)(v26 + 8) = *(void *)(a1 + 8);
  if (v17) {
    char v27 = 8;
  }
  else {
    char v27 = a3;
  }
  *(unsigned char *)(v26 + 16) = v27;
  *(unsigned char *)(v26 + 17) = *(unsigned char *)(a1 + 80);
  *(unsigned char *)(v26 + 18) = 5;
  *(unsigned char *)(v26 + 19) = *(unsigned char *)(v9 + 105);
  *(_DWORD *)(v26 + 20) = *(_DWORD *)(v9 + 108);
  *(_DWORD *)(v26 + 24) = bswap32(v24);
  if (v17)
  {
    *(unsigned char *)(v26 + 28) = a3;
    size_t v28 = (size_t)*v17;
    *(_WORD *)(v26 + 30) = bswap32(*v17 + 4) >> 16;
    memcpy((void *)(v26 + 32), v17[1], v28);
    int v29 = (char *)*v17 + v26 + 32;
  }
  else
  {
    int v29 = (char *)(v26 + 28);
  }
  memcpy(v29, *(const void **)(a2 + 8), *(void *)a2);
  uint64_t v35 = *(size_t **)(v9 + 80);
  if (*(unsigned char *)(v26 + 19))
  {
    uint64_t v35 = sub_10002E41C(*(void *)(v9 + 256), *(void *)(v9 + 80), *(void *)(*(void *)(v9 + 240) + 8), **(void **)(v9 + 240));
    uint64_t v36 = *(void **)(v9 + 80);
    if (v36)
    {
      sub_10003FA78(v36);
      *(void *)(v9 + 80) = 0;
    }
    if (!v35)
    {
      if (dword_10008FA20)
      {
        int v41 = ne_log_obj();
        if (os_log_type_enabled(v41, OS_LOG_TYPE_ERROR)) {
          sub_10005CBC4();
        }
      }
      goto LABEL_67;
    }
    *(void *)(v9 + 80) = v35;
  }
  if ((sub_100023E30(*(void *)(v9 + 256), v35) & 0x80000000) == 0)
  {
    if (dword_10008FA20)
    {
      uint64_t v37 = ne_log_obj();
      if (os_log_type_enabled(v37, OS_LOG_TYPE_DEFAULT))
      {
        int v42 = 136315138;
        uint64_t v43 = sub_10003E1DC(a3);
        _os_log_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_DEFAULT, "sendto Information %s.\n", (uint8_t *)&v42, 0xCu);
      }
    }
    unsigned int v38 = *(void **)(v9 + 80);
    if (v38)
    {
      sub_10003FA78(v38);
      uint64_t v33 = 0;
      *(void *)(v9 + 80) = 0;
    }
    else
    {
      uint64_t v33 = 0;
    }
    goto LABEL_68;
  }
  if (dword_10008FA20)
  {
    int v39 = ne_log_obj();
    if (os_log_type_enabled(v39, OS_LOG_TYPE_ERROR)) {
      sub_10005AD0C();
    }
  }
  uint64_t v40 = *(void **)(v9 + 80);
  if (v40)
  {
    sub_10003FA78(v40);
    *(void *)(v9 + 80) = 0;
  }
LABEL_67:
  uint64_t v33 = 0xFFFFFFFFLL;
LABEL_68:
  sub_10004B62C((void *)v9);
  if (v17) {
    sub_10003FA78(v17);
  }
  return v33;
}

uint64_t sub_10001A600(uint64_t a1)
{
  if ((*(unsigned char *)(a1 + 57) & 0x20) == 0) {
    return 0;
  }
  uint64_t v2 = sub_10004C648(*(void *)(a1 + 272));
  if (!v2)
  {
    uint64_t v2 = sub_10000740C(*(void *)(a1 + 272), *(const sockaddr **)a1, *(const sockaddr **)(a1 + 8));
    if (!v2)
    {
      if (dword_10008FA20)
      {
        BOOL v11 = ne_log_obj();
        uint64_t v9 = 0;
        if (!os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT)) {
          return v9;
        }
        *(_WORD *)uint64_t v13 = 0;
        _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "No ph1 handler found, could not send DELETE_SA\n", v13, 2u);
      }
      return 0;
    }
  }
  uint64_t v3 = *(void *)(*(void *)(a1 + 128) + 32);
  if (!v3) {
    return 0;
  }
  while (1)
  {
    signed int v4 = *(_DWORD *)(v3 + 8) + 12;
    uint64_t v5 = sub_10003F940(v4);
    if (!v5) {
      break;
    }
    uint64_t v6 = v5;
    uint64_t v7 = v5[1];
    *(unsigned char *)uint64_t v7 = 0;
    *(_WORD *)(v7 + 2) = bswap32(v4) >> 16;
    *(_DWORD *)(v7 + 4) = 0x1000000;
    *(unsigned char *)(v7 + 8) = *(_DWORD *)v3;
    size_t v8 = *(void *)(v3 + 8);
    *(unsigned char *)(v7 + 9) = v8;
    *(_WORD *)(v7 + 10) = 256;
    memcpy((void *)(v7 + 12), (const void *)(v3 - v8 + 28), v8);
    uint64_t v9 = sub_10001A15C(v2, v6, 12, 0);
    sub_10003FA78(v6);
    uint64_t v3 = *(void *)(v3 + 72);
    if (!v3) {
      return v9;
    }
  }
  if (dword_10008FA20)
  {
    unint64_t v10 = ne_log_obj();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR)) {
      sub_10005CA40();
    }
  }
  return *__error();
}

uint64_t sub_10001A78C(uint64_t a1, sockaddr *a2, uint64_t a3, unsigned int a4, uint64_t a5)
{
  uint64_t v10 = sub_10004B7EC(a3, (uint64_t)a2, 0, 0);
  BOOL v11 = sub_1000388FC(a2);
  if (v11)
  {
    uint64_t v12 = (uint64_t)v11;
    uint64_t v13 = sub_100007868(16);
    if (v13)
    {
      uint64_t v14 = (uint64_t)v13;
      *uint64_t v13 = *(void *)a1;
      sub_100025FD0(v13 + 1, (uint64_t)a2, a3);
      sub_100002728((int *)(v14 + 16), 63);
      *(void *)(v14 + 64) = v12;
      sub_100038F68(v12);
      *(_DWORD *)(v14 + 20) = 0;
      *(unsigned char *)(v14 + 80) = *(unsigned char *)(a1 + 17);
      *(unsigned char *)(v14 + 82) = 0;
      *(_DWORD *)(v14 + 84) = 0;
      unint64_t v15 = sub_100045224();
      *(void *)(v14 + 408) = v15;
      if (!v15) {
        goto LABEL_27;
      }
      *(_DWORD *)(v14 + 100) = 0;
      *(void *)(v14 + 104) = 0;
      if ((sub_1000222A8(v14, v12, (uint64_t)a2, a3) & 0x80000000) == 0)
      {
        if (a5) {
          signed int v16 = *(_DWORD *)a5 + 12;
        }
        else {
          signed int v16 = 12;
        }
        unint64_t v21 = sub_10003F940(v16);
        if (v21)
        {
          int v22 = v21;
          uint64_t v23 = v21[1];
          *(unsigned char *)uint64_t v23 = 0;
          *(_WORD *)(v23 + 2) = bswap32(v16) >> 16;
          *(_DWORD *)(v23 + 4) = 0x1000000;
          *(_WORD *)(v23 + 8) = 1;
          *(_WORD *)(v23 + 10) = bswap32(a4) >> 16;
          if (a5) {
            memcpy((void *)(v23 + 12), *(const void **)(a5 + 8), *(void *)a5);
          }
          sub_10001AA00(v14, 0, a4, (unsigned __int16 *)a5);
          if (sub_10004BEF0(v10, v14)) {
            sub_10003B880();
          }
          uint64_t v20 = sub_10001A15C(v14, (uint64_t)v22, 11, 0);
          sub_10003FA78(v22);
          goto LABEL_28;
        }
        if (dword_10008FA20)
        {
          uint64_t v24 = ne_log_obj();
          if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR)) {
            sub_10005CB90();
          }
        }
LABEL_27:
        uint64_t v20 = 0xFFFFFFFFLL;
LABEL_28:
        sub_10004B710(v14);
        return v20;
      }
      if (dword_10008FA20)
      {
        uint64_t v19 = ne_log_obj();
        if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR)) {
          sub_10005CC60();
        }
      }
    }
    else if (dword_10008FA20)
    {
      uint64_t v18 = ne_log_obj();
      if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR)) {
        sub_10005CC2C();
      }
    }
  }
  else if (dword_10008FA20)
  {
    char v17 = ne_log_obj();
    if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR)) {
      sub_10005CBF8();
    }
  }
  return 0xFFFFFFFFLL;
}

uint64_t sub_10001AA00(uint64_t a1, int a2, int a3, unsigned __int16 *a4)
{
  uint64_t result = sub_100009F24(a1);
  int v9 = result;
  if (a2 == 1)
  {
    int v10 = sub_10002B5E8(*(void *)(a1 + 280), 1);
    int v11 = sub_10002B5E8(*(void *)(a1 + 280), 2);
    if (v10)
    {
      if (dword_10008FA20)
      {
        uint64_t v12 = ne_log_obj();
        if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, ">>> Server reports client's certificate is pre-mature\n", buf, 2u);
        }
      }
      LOWORD(a3) = -15532;
    }
    else if (v11)
    {
      if (dword_10008FA20)
      {
        uint64_t v18 = ne_log_obj();
        if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)uint64_t v32 = 0;
          _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, ">>> Server reports client's certificate is expired\n", v32, 2u);
        }
      }
      LOWORD(a3) = -15531;
    }
    unsigned int v19 = (unsigned __int16)a3;
    unsigned int v20 = 1;
    int v21 = v9;
    unsigned int v22 = 0;
    uint64_t v23 = 0;
  }
  else
  {
    if (a3 > 30) {
      return result;
    }
    int v13 = sub_10002B5E8(*(void *)(a1 + 288), 1);
    int v14 = sub_10002B5E8(*(void *)(a1 + 288), 2);
    int v15 = sub_10002B5E8(*(void *)(a1 + 288), 3);
    int v16 = sub_10002B5E8(*(void *)(a1 + 288), 4);
    if (v13)
    {
      if (dword_10008FA20)
      {
        char v17 = ne_log_obj();
        if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)uint64_t v31 = 0;
          _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, ">>> Server's certificate is pre-mature\n", v31, 2u);
        }
      }
      LOWORD(a3) = -15530;
    }
    else if (v14)
    {
      if (dword_10008FA20)
      {
        uint64_t v24 = ne_log_obj();
        if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)int v30 = 0;
          _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, ">>> Server's certificate is expired\n", v30, 2u);
        }
      }
      LOWORD(a3) = -15529;
    }
    else if (v15)
    {
      if (dword_10008FA20)
      {
        int v25 = ne_log_obj();
        if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)int v29 = 0;
          _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, ">>> Server's certificate subject name not valid\n", v29, 2u);
        }
      }
      LOWORD(a3) = -15528;
    }
    else if (v16)
    {
      if (dword_10008FA20)
      {
        uint64_t v26 = ne_log_obj();
        if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)size_t v28 = 0;
          _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, ">>> Server's certificate subject alternate name not valid\n", v28, 2u);
        }
      }
      LOWORD(a3) = -15527;
    }
    if (a4)
    {
      unsigned __int16 v27 = *a4;
      uint64_t v23 = (const void *)*((void *)a4 + 1);
    }
    else
    {
      unsigned __int16 v27 = 0;
      uint64_t v23 = 0;
    }
    unsigned int v19 = (unsigned __int16)a3;
    unsigned int v22 = v27;
    unsigned int v20 = 0;
    int v21 = v9;
  }
  return sub_100049388(v19, v20, v21, v22, v23);
}

uint64_t sub_10001AD08(uint64_t a1, unsigned int a2, uint64_t a3)
{
  if (a2 == 24578 || a2 == 40501) {
    uint64_t v7 = 16;
  }
  else {
    uint64_t v7 = 0;
  }
  signed int v8 = v7 | 0xC;
  if (a3) {
    v8 += *(_DWORD *)a3;
  }
  int v9 = sub_10003F940(v8);
  if (v9)
  {
    int v10 = v9;
    uint64_t v11 = v9[1];
    *(unsigned char *)uint64_t v11 = 0;
    *(_WORD *)(v11 + 2) = bswap32(v8) >> 16;
    *(_DWORD *)(v11 + 4) = bswap32(*(_DWORD *)(*(void *)(a1 + 64) + 24));
    *(unsigned char *)(v11 + 8) = 1;
    *(unsigned char *)(v11 + 9) = v7;
    *(_WORD *)(v11 + 10) = bswap32(a2) >> 16;
    if (a2 == 40501 || a2 == 24578) {
      *(_OWORD *)(v11 + 12) = *(_OWORD *)a1;
    }
    if (a3) {
      memcpy((void *)(v11 + v7 + 12), *(const void **)(a3 + 8), *(void *)a3);
    }
    sub_10001AA00(a1, 0, a2, (unsigned __int16 *)a3);
    uint64_t v12 = sub_10001A15C(a1, (uint64_t)v10, 11, *(unsigned char *)(a1 + 82));
    sub_10003FA78(v10);
    return v12;
  }
  else
  {
    if (dword_10008FA20)
    {
      int v14 = ne_log_obj();
      if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR)) {
        sub_10005CB90();
      }
    }
    return *__error();
  }
}

uint64_t sub_10001AE5C(uint64_t a1, unsigned int a2, uint64_t a3)
{
  uint64_t v3 = *(void *)(a1 + 128);
  if (!v3) {
    return 22;
  }
  uint64_t v7 = *(_DWORD **)(v3 + 32);
  signed int v8 = v7[2] + 12;
  if (a3) {
    v8 += *(_DWORD *)a3;
  }
  uint64_t v9 = *(void *)(a1 + 256);
  int v10 = sub_10003F940(v8);
  if (v10)
  {
    uint64_t v11 = v10;
    uint64_t v12 = v10[1];
    *(unsigned char *)uint64_t v12 = 0;
    *(_WORD *)(v12 + 2) = bswap32(v8) >> 16;
    *(_DWORD *)(v12 + 4) = 0x1000000;
    *(unsigned char *)(v12 + 8) = *v7;
    *(unsigned char *)(v12 + 9) = *((void *)v7 + 1);
    *(_WORD *)(v12 + 10) = bswap32(a2) >> 16;
    *(_DWORD *)(v12 + 12) = v7[6];
    uint64_t v13 = v12 + 12;
    if (a3) {
      memcpy((void *)(v13 + *((void *)v7 + 1)), *(const void **)(a3 + 8), *(void *)a3);
    }
    char v14 = *(unsigned char *)(a1 + 105) | 1;
    *(unsigned char *)(a1 + 105) = v14;
    uint64_t v15 = sub_10001A15C(v9, (uint64_t)v11, 11, v14);
    sub_10003FA78(v11);
    return v15;
  }
  else
  {
    if (dword_10008FA20)
    {
      char v17 = ne_log_obj();
      if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR)) {
        sub_10005CB90();
      }
    }
    return *__error();
  }
}

void *sub_10001AF94(void **a1, unsigned char **a2, unsigned int a3, _DWORD *a4, uint64_t a5)
{
  if (*a2) {
    **a2 = 11;
  }
  signed int v9 = a4[2] + 12;
  if (a5) {
    v9 += *(_DWORD *)a5;
  }
  if (a1)
  {
    int v10 = *a1;
    uint64_t v11 = sub_10003F9BC(a1, (size_t)*a1 + v9);
    uint64_t v12 = (int)v10;
    if (v11)
    {
LABEL_7:
      uint64_t v13 = v11[1] + v12;
      *(unsigned char *)uint64_t v13 = 0;
      *(_WORD *)(v13 + 2) = bswap32(v9) >> 16;
      *(_DWORD *)(v13 + 4) = 0x1000000;
      *(unsigned char *)(v13 + 8) = *a4;
      *(unsigned char *)(v13 + 9) = *((void *)a4 + 1);
      *(_WORD *)(v13 + 10) = bswap32(a3) >> 16;
      *(_DWORD *)(v13 + 12) = a4[6];
      if (a5) {
        memcpy((void *)(v13 + 12 + *((void *)a4 + 1)), *(const void **)(a5 + 8), *(void *)a5);
      }
      *a2 = (unsigned char *)v13;
      return v11;
    }
  }
  else
  {
    uint64_t v11 = sub_10003F940(v9);
    uint64_t v12 = 0;
    if (v11) {
      goto LABEL_7;
    }
  }
  if (dword_10008FA20)
  {
    char v14 = ne_log_obj();
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR)) {
      sub_10005CC94();
    }
  }
  return v11;
}

void sub_10001B0C4(unint64_t a1, int a2, int *a3, uint64_t a4, uint64_t a5, unint64_t *a6)
{
  long long v57 = 0u;
  long long v58 = 0u;
  long long v55 = 0u;
  long long v56 = 0u;
  long long v53 = 0u;
  long long v54 = 0u;
  long long v51 = 0u;
  long long v52 = 0u;
  long long v49 = 0u;
  long long v50 = 0u;
  long long v47 = 0u;
  long long v48 = 0u;
  long long v46 = 0u;
  memset(v45, 0, sizeof(v45));
  unsigned int v11 = sub_10002F070(a2);
  uint64_t v12 = sub_10002EB30(v11);
  if (v12)
  {
    uint64_t v36 = v12;
    if ((uint64_t)*v12 < 1)
    {
      unint64_t v40 = 0;
    }
    else
    {
      uint64_t v32 = a3;
      uint64_t v33 = a4;
      unint64_t v40 = 0;
      unint64_t v13 = (unint64_t)v12[1];
      char v14 = (char *)*v12 + v13;
      unint64_t v34 = a1;
      uint64_t v35 = a5;
      if (a5) {
        BOOL v15 = a6 == 0;
      }
      else {
        BOOL v15 = 1;
      }
      int v16 = !v15;
      int v37 = v16;
      unsigned int v38 = a6;
      do
      {
        unint64_t v17 = *(unsigned __int16 *)(v13 + 4);
        if (v17 < 2) {
          break;
        }
        if (*(unsigned char *)(v13 + 1) == 10)
        {
          if (sub_100042570(v13, (uint64_t)v45) || sub_100042670((uint64_t)v45))
          {
            if (dword_10008FA20)
            {
              uint64_t v18 = ne_log_obj();
              if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR)) {
                sub_10005CCC8();
              }
            }
          }
          else
          {
            uint64_t v19 = *((void *)&v45[0] + 1);
            if (*((void *)&v45[0] + 1))
            {
              uint64_t v20 = *((void *)&v46 + 1);
              if (*((void *)&v46 + 1))
              {
                if ((void)v47)
                {
                  if (*(unsigned __int8 *)(*((void *)&v45[0] + 1) + 9) - 1 <= 1)
                  {
                    int v21 = (unsigned __int8 *)(v47 + 8);
                    if (!sub_10003BA4C(v34, v47 + 8))
                    {
                      uint64_t v22 = v33;
                      if (v33)
                      {
                        uint64_t v23 = (unsigned __int8 *)(v20 + 8);
                        uint64_t v24 = v32;
                        do
                        {
                          if (*v24 == *(_DWORD *)(v19 + 4))
                          {
                            if (v37)
                            {
                              if (v40 >= *a6) {
                                int v25 = 0;
                              }
                              else {
                                int v25 = (_DWORD *)(v35 + 4 * v40);
                              }
                            }
                            else
                            {
                              int v25 = 0;
                            }
                            uint64_t v26 = sub_100008170((uint64_t)v23, (uint64_t)v21, a2, *v24, v25);
                            sub_100041398(*(_DWORD *)(qword_10008F848 + 32), *(unsigned char *)(v13 + 3), 0, v23, v21, *(_DWORD *)(v19 + 4));
                            if (v26)
                            {
                              sub_100026AB8((uint64_t)v26);
                              sub_10004B62C(v26);
                              unint64_t v27 = v40;
                              if (v25) {
                                unint64_t v27 = v40 + 1;
                              }
                              unint64_t v40 = v27;
                            }
                            a6 = v38;
                            if (dword_10008FA20)
                            {
                              size_t v28 = ne_log_obj();
                              if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
                              {
                                int v29 = sub_10003E344(a2);
                                unsigned int v30 = bswap32(*v24);
                                *(_DWORD *)buf = 136315394;
                                int v42 = v29;
                                __int16 v43 = 1024;
                                unsigned int v44 = v30;
                                _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, "Purged IPsec-SA proto_id=%s spi=%u.\n", buf, 0x12u);
                              }
                            }
                          }
                          ++v24;
                          --v22;
                        }
                        while (v22);
                      }
                    }
                  }
                }
              }
            }
          }
        }
        v13 += 8 * v17;
      }
      while (v13 < (unint64_t)v14);
    }
    if (a6) {
      *a6 = v40;
    }
    sub_10003FA78(v36);
  }
  else if (dword_10008FA20)
  {
    uint64_t v31 = ne_log_obj();
    if (os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_DEFAULT, "pfkey_dump_sadb returned nothing.\n", buf, 2u);
    }
  }
}

void sub_10001B420(uint64_t a1)
{
  if (!dword_10008F858)
  {
    long long v37 = 0u;
    long long v38 = 0u;
    long long v35 = 0u;
    long long v36 = 0u;
    long long v33 = 0u;
    long long v34 = 0u;
    long long v31 = 0u;
    long long v32 = 0u;
    long long v29 = 0u;
    long long v30 = 0u;
    long long v27 = 0u;
    long long v28 = 0u;
    long long v26 = 0u;
    memset(v25, 0, sizeof(v25));
    uint64_t v2 = sub_10002EB30(0);
    if (v2)
    {
      uint64_t v3 = v2;
      if ((uint64_t)*v2 >= 1)
      {
        unint64_t v4 = (unint64_t)v2[1];
        uint64_t v5 = (char *)*v2 + v4;
        do
        {
          unint64_t v6 = *(unsigned __int16 *)(v4 + 4);
          if (v6 < 2) {
            break;
          }
          if (*(unsigned char *)(v4 + 1) == 10)
          {
            if (sub_100042570(v4, (uint64_t)v25) || sub_100042670((uint64_t)v25))
            {
              if (dword_10008FA20)
              {
                uint64_t v7 = ne_log_obj();
                if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR)) {
                  sub_10005CCC8();
                }
              }
            }
            else
            {
              uint64_t v8 = *((void *)&v25[0] + 1);
              if (*((void *)&v25[0] + 1)
                && *((void *)&v26 + 1)
                && (void)v27
                && *(unsigned __int8 *)(*((void *)&v25[0] + 1) + 9) - 1 <= 1)
              {
                signed int v9 = (unsigned __int8 *)(*((void *)&v26 + 1) + 8);
                int v21 = (unsigned __int8 *)(v27 + 8);
                unint64_t v10 = *(void *)(a1 + 56);
                unint64_t v11 = *((void *)&v26 + 1) + 8;
                if ((*(unsigned char *)(a1 + 96) & 6) != 0)
                {
                  if (!sub_10003BB04(v10, v11)
                    && !sub_10003BB04(*(void *)(a1 + 48), (unint64_t)v21)
                    || !sub_10003BB04(*(void *)(a1 + 48), (unint64_t)v9)
                    && !sub_10003BB04(*(void *)(a1 + 56), (unint64_t)v21))
                  {
                    goto LABEL_28;
                  }
                }
                else if (!sub_10003B8E4(v10, v11) {
                       && !sub_10003B8E4(*(void *)(a1 + 48), (unint64_t)v21)
                }
                       || !sub_10003B8E4(*(void *)(a1 + 48), (unint64_t)v9)
                       && !sub_10003B8E4(*(void *)(a1 + 56), (unint64_t)v21))
                {
LABEL_28:
                  uint64_t v12 = 0;
                  unint64_t v13 = byte_100089050;
                  while (1)
                  {
                    int v14 = *v13;
                    v13 += 16;
                    if (v14 == *(unsigned __int8 *)(v4 + 3)) {
                      break;
                    }
                    if (++v12 == 3) {
                      goto LABEL_12;
                    }
                  }
                  if (v12 != 3)
                  {
                    if (dword_10008FA20)
                    {
                      log = ne_log_obj();
                      if (os_log_type_enabled(log, OS_LOG_TYPE_DEFAULT))
                      {
                        unsigned int v15 = bswap32(*(_DWORD *)(v8 + 4));
                        *(_DWORD *)buf = 67109120;
                        unsigned int v23 = v15;
                        _os_log_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_DEFAULT, "purging spi=%u.\n", buf, 8u);
                      }
                    }
                    sub_100041398(*(_DWORD *)(qword_10008F848 + 32), *(unsigned char *)(v4 + 3), 0, v9, v21, *(_DWORD *)(v8 + 4));
                    int v16 = sub_10002F0E4(*(unsigned __int8 *)(v4 + 3));
                    unint64_t v17 = sub_1000080D0((uint64_t)v9, (uint64_t)v21, v16, *(_DWORD *)(v8 + 4));
                    if (v17)
                    {
                      uint64_t v18 = v17;
                      sub_100026AB8((uint64_t)v17);
                      sub_10004B62C(v18);
                    }
                  }
                }
              }
            }
          }
LABEL_12:
          v4 += 8 * v6;
        }
        while (v4 < (unint64_t)v5);
      }
      sub_10003FA78(v3);
    }
    else if (dword_10008FA20)
    {
      uint64_t v19 = ne_log_obj();
      if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)uint64_t v24 = 0;
        _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "pfkey_dump_sadb returned nothing.\n", v24, 2u);
      }
    }
  }
}

void sub_10001B78C(uint64_t a1, uint64_t a2)
{
  if (dword_10008FA20)
  {
    unint64_t v4 = ne_log_obj();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v15) = 0;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Notify Message received\n", (uint8_t *)&v15, 2u);
    }
  }
  unsigned int v6 = *(unsigned __int16 *)(a1 + 10);
  uint64_t v5 = (unsigned __int16 *)(a1 + 10);
  signed int v7 = bswap32(v6) >> 16;
  if (v7 <= 40499)
  {
    if ((v7 - 24576) >= 2 && v7 != 0x4000)
    {
      if (v7 == 24578)
      {
        if (dword_10008FA20)
        {
          uint64_t v8 = ne_log_obj();
          if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
          {
            LOWORD(v15) = 0;
            signed int v9 = "Ignore INITIAL-CONTACT notification, because it is only accepted after Phase 1.\n";
LABEL_23:
            uint64_t v12 = v8;
            uint32_t v13 = 2;
            goto LABEL_24;
          }
        }
        return;
      }
LABEL_17:
      sub_10001AD08(a2, 1u, 0);
      if (dword_10008FA20)
      {
        int v14 = ne_log_obj();
        if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR)) {
          sub_10005CD1C(v5);
        }
      }
      return;
    }
LABEL_14:
    if (dword_10008FA20)
    {
      unint64_t v10 = ne_log_obj();
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
      {
        unint64_t v11 = sub_10003E164(bswap32(*v5) >> 16);
        int v15 = 136315138;
        int v16 = v11;
        signed int v9 = "Ignore %s notification.\n";
        uint64_t v12 = v10;
        uint32_t v13 = 12;
LABEL_24:
        _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, v9, (uint8_t *)&v15, v13);
        return;
      }
    }
    return;
  }
  if (v7 == 40503) {
    goto LABEL_14;
  }
  if (v7 != 40501)
  {
    if (v7 != 40500) {
      goto LABEL_17;
    }
    goto LABEL_14;
  }
  if (dword_10008FA20)
  {
    uint64_t v8 = ne_log_obj();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v15) = 0;
      signed int v9 = "Ignore LOAD-BALANCE notification, because it is only accepted after Phase 1.\n";
      goto LABEL_23;
    }
  }
}

void sub_10001B9A8(uint64_t a1, uint64_t a2)
{
  if (dword_10008FA20)
  {
    unint64_t v4 = ne_log_obj();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v22) = 0;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Phase 2 Notify Message received\n", (uint8_t *)&v22, 2u);
    }
  }
  uint64_t v5 = (unsigned __int16 *)(a1 + 10);
  signed int v6 = bswap32(*(unsigned __int16 *)(a1 + 10)) >> 16;
  int v7 = 24577;
  if (v6 > 24577)
  {
    if (v6 > 40500)
    {
      if (v6 != 40501)
      {
        int v7 = 40503;
LABEL_16:
        if (v6 != v7)
        {
          sub_10001AD08(*(void *)(a2 + 256), 1u, 0);
          if (dword_10008FA20)
          {
            int v16 = ne_log_obj();
            if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR)) {
              sub_10005CD1C(v5);
            }
          }
          return;
        }
        goto LABEL_17;
      }
      if (!dword_10008FA20) {
        return;
      }
      int v15 = ne_log_obj();
      if (!os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT)) {
        return;
      }
      LOWORD(v22) = 0;
      uint64_t v12 = "Ignore LOAD-BALANCE notification, because it is only accepted after Phase 1.\n";
    }
    else
    {
      if (v6 != 24578)
      {
        int v7 = 40500;
        goto LABEL_16;
      }
      if (!dword_10008FA20) {
        return;
      }
      int v15 = ne_log_obj();
      if (!os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT)) {
        return;
      }
      LOWORD(v22) = 0;
      uint64_t v12 = "Ignore INITIAL-CONTACT notification, because it is only accepted after Phase 1.\n";
    }
    uint32_t v13 = v15;
    uint32_t v14 = 2;
    goto LABEL_27;
  }
  if (v6 != 0x4000)
  {
    if (v6 == 24576)
    {
      unint64_t v8 = *(unsigned __int8 *)(a1 + 9);
      if (v8 + 12 <= bswap32(*(unsigned __int16 *)(a1 + 2)) >> 16)
      {
        unint64_t v17 = sub_10003D954(a1 + 12, v8);
        if (dword_10008FA20)
        {
          uint64_t v18 = ne_log_obj();
          if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
          {
            unsigned int v19 = bswap32(*(_DWORD *)(a1 + 4));
            int v20 = *(unsigned __int8 *)(a1 + 8);
            int v21 = *(unsigned __int8 *)(a1 + 9);
            int v22 = 67109890;
            *(_DWORD *)unsigned int v23 = v19;
            *(_WORD *)&v23[4] = 1024;
            *(_DWORD *)&v23[6] = v20;
            __int16 v24 = 2080;
            int v25 = v17;
            __int16 v26 = 1024;
            int v27 = v21;
            _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "notification message IPSEC-SA RESPONDER-LIFETIME, doi=%d proto_id=%d spi=%s(size=%d).\n", (uint8_t *)&v22, 0x1Eu);
          }
        }
        free(v17);
      }
      else if (dword_10008FA20)
      {
        signed int v9 = ne_log_obj();
        if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR)) {
          sub_10005CD94();
        }
      }
      return;
    }
    goto LABEL_16;
  }
LABEL_17:
  if (dword_10008FA20)
  {
    unint64_t v10 = ne_log_obj();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      unint64_t v11 = sub_10003E164(bswap32(*v5) >> 16);
      int v22 = 136315138;
      *(void *)unsigned int v23 = v11;
      uint64_t v12 = "Ignore %s notification.\n";
      uint32_t v13 = v10;
      uint32_t v14 = 12;
LABEL_27:
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, v12, (uint8_t *)&v22, v14);
    }
  }
}

void sub_10001BCA8(uint64_t a1)
{
  if ((*(unsigned char *)(a1 + 17) & 0x20) != 0)
  {
    if (*(_DWORD *)(*(void *)(a1 + 64) + 220) <= (int)*(unsigned __int8 *)(a1 + 386))
    {
      int v16 = sub_100009F24(a1);
      sub_100049388(0xC351u, 0, v16, 0, 0);
      sub_1000265E0(a1);
      if (dword_10008FA20)
      {
        unint64_t v17 = ne_log_obj();
        if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
        {
          LOWORD(v19) = 0;
          unint64_t v4 = "DPD: remote seems to be dead\n";
          uint32_t v14 = v17;
          uint32_t v15 = 2;
          goto LABEL_19;
        }
      }
    }
    else
    {
      uint64_t v5 = sub_10003F940(0x20uLL);
      if (v5)
      {
        signed int v6 = v5;
        uint64_t v7 = v5[1];
        *(unsigned char *)uint64_t v7 = 0;
        *(_WORD *)(v7 + 2) = 0x2000;
        *(void *)(v7 + 4) = 0x288D100101000000;
        *(void *)(v7 + 12) = *(void *)a1;
        *(void *)(v7 + 20) = *(void *)(a1 + 8);
        unsigned int v8 = *(unsigned __int16 *)(a1 + 384);
        if (!*(_WORD *)(a1 + 384))
        {
          unsigned int v9 = time(0);
          srand(v9);
          __int16 v10 = rand();
          unsigned int v8 = v10 & 0xFFF;
          *(_WORD *)(a1 + 384) = v10 & 0xFFF;
        }
        *(_DWORD *)(v7 + 28) = bswap32(v8);
        int v11 = sub_10001A15C(a1, (uint64_t)v6, 11, 0);
        sub_10003FA78(v6);
        if (dword_10008FA20)
        {
          uint64_t v12 = ne_log_obj();
          if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
          {
            int v19 = 67109120;
            int v20 = v11;
            _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "DPD R-U-There sent (%d)\n", (uint8_t *)&v19, 8u);
          }
        }
        ++*(unsigned char *)(a1 + 386);
        sub_10001BF60(a1, 1);
        if (dword_10008FA20)
        {
          uint64_t v2 = ne_log_obj();
          if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
          {
            int v13 = *(_DWORD *)(*(void *)(a1 + 64) + 212);
            int v19 = 67109120;
            int v20 = v13;
            unint64_t v4 = "rescheduling send_r_u (%d).\n";
            goto LABEL_15;
          }
        }
      }
      else if (dword_10008FA20)
      {
        uint64_t v18 = ne_log_obj();
        if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR)) {
          sub_10005CA40();
        }
      }
    }
  }
  else if (dword_10008FA20)
  {
    uint64_t v2 = ne_log_obj();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      int v3 = *(_DWORD *)(a1 + 16);
      int v19 = 67109120;
      int v20 = v3;
      unint64_t v4 = "DPD r-u send aborted, invalid Phase 1 status %d....\n";
LABEL_15:
      uint32_t v14 = v2;
      uint32_t v15 = 8;
LABEL_19:
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, v4, (uint8_t *)&v19, v15);
    }
  }
}

uint64_t sub_10001BF60(uint64_t a1, int a2)
{
  if (!a1) {
    return 1;
  }
  int v3 = *(int **)(a1 + 64);
  if (!v3) {
    return 1;
  }
  if (!*(_DWORD *)(a1 + 368)) {
    return 0;
  }
  uint64_t result = v3[54];
  if (!result) {
    return result;
  }
  if (a2)
  {
    uint64_t result = v3[53];
LABEL_12:
    uint64_t v5 = sub_10001BCA8;
    goto LABEL_13;
  }
  if ((v3[56] - 1) > 1) {
    goto LABEL_12;
  }
  uint64_t v5 = sub_10001C008;
LABEL_13:
  unsigned int v6 = sub_10003AA24(result, (uint64_t)v5, a1);
  uint64_t result = 0;
  *(_DWORD *)(a1 + 388) = v6;
  return result;
}

void sub_10001C008(uint64_t a1)
{
  if (!a1) {
    return;
  }
  uint64_t v2 = *(void *)(a1 + 64);
  if (!v2) {
    return;
  }
  int v3 = *(_DWORD *)(v2 + 224);
  if (v3 != 2)
  {
    if (v3 != 1)
    {
      if (dword_10008FA20)
      {
        unint64_t v4 = ne_log_obj();
        if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
        {
          int v8 = *(_DWORD *)(*(void *)(a1 + 64) + 224);
          int v17 = 67109120;
          int v18 = v8;
          unsigned int v6 = "DPD monitoring aborted, invalid algorithm %d....\n";
          goto LABEL_16;
        }
      }
      return;
    }
    if ((*(unsigned char *)(a1 + 17) & 0x20) == 0)
    {
      if (dword_10008FA20)
      {
        unint64_t v4 = ne_log_obj();
        if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
        {
          int v5 = *(_DWORD *)(a1 + 16);
          int v17 = 67109120;
          int v18 = v5;
          unsigned int v6 = "DPD monitoring (for ALGORITHM_INBOUND_DETECT) aborted, invalid Phase 1 status %d....\n";
LABEL_16:
          unsigned int v9 = v4;
          uint32_t v10 = 8;
LABEL_17:
          _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, v6, (uint8_t *)&v17, v10);
          return;
        }
      }
      return;
    }
    if (dword_10008FA20)
    {
      int v11 = ne_log_obj();
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(v17) = 0;
        _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "DPD monitoring (for ALGORITHM_INBOUND_DETECT) ....\n", (uint8_t *)&v17, 2u);
      }
    }
    if (*(unsigned char *)(a1 + 387))
    {
      *(unsigned char *)(a1 + 387) = 0;
      sub_10001BF60(a1, 0);
      if (dword_10008FA20)
      {
        uint64_t v12 = ne_log_obj();
        if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
        {
          LOWORD(v17) = 0;
          unsigned int v6 = "ike packets received from peer... reschedule monitor.\n";
          unsigned int v9 = v12;
          uint32_t v10 = 2;
          goto LABEL_17;
        }
      }
      return;
    }
    if ((*(_WORD *)(*(void *)(a1 + 440) + 264) & 0x40) != 0)
    {
      sub_10001BF60(a1, 0);
      if (dword_10008FA20)
      {
        int v16 = ne_log_obj();
        if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
        {
          LOWORD(v17) = 0;
          _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "rescheduling DPD monitoring (for ALGORITHM_INBOUND_DETECT).\n", (uint8_t *)&v17, 2u);
        }
      }
    }
    else
    {
      sub_10001BCA8(a1);
    }
LABEL_34:
    *(_WORD *)(*(void *)(a1 + 440) + 264) &= ~0x40u;
    return;
  }
  if ((*(unsigned char *)(a1 + 17) & 0x20) != 0)
  {
    if (dword_10008FA20)
    {
      int v13 = ne_log_obj();
      if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(v17) = 0;
        _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "DPD monitoring (for ALGORITHM_BLACKHOLE_DETECT) ....\n", (uint8_t *)&v17, 2u);
      }
    }
    if ((*(_WORD *)(*(void *)(a1 + 440) + 264) & 0x140) == 0x100)
    {
      sub_10001BCA8(a1);
    }
    else
    {
      sub_10001BF60(a1, 0);
      if (dword_10008FA20)
      {
        uint32_t v14 = ne_log_obj();
        if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
        {
          int v15 = *(unsigned __int16 *)(*(void *)(a1 + 440) + 264);
          int v17 = 67109376;
          int v18 = v15 << 23 >> 31;
          __int16 v19 = 1024;
          int v20 = v15 << 25 >> 31;
          _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "rescheduling DPD monitoring (for ALGORITHM_BLACKHOLE_DETECT) uint64_t i = %d, peer %d.\n", (uint8_t *)&v17, 0xEu);
        }
      }
    }
    *(_WORD *)(*(void *)(a1 + 440) + 264) &= ~0x100u;
    goto LABEL_34;
  }
  if (dword_10008FA20)
  {
    unint64_t v4 = ne_log_obj();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      int v7 = *(_DWORD *)(a1 + 16);
      int v17 = 67109120;
      int v18 = v7;
      unsigned int v6 = "DPD monitoring (for ALGORITHM_BLACKHOLE_DETECT) aborted, invalid Phase 1 status %d....\n";
      goto LABEL_16;
    }
  }
}

void sub_10001C398(uint64_t a1, uint64_t a2)
{
  if (a1)
  {
    if ((*(unsigned char *)(a1 + 17) & 0x20) != 0)
    {
      if (*(_DWORD *)(a1 + 368))
      {
        uint64_t v3 = *(void *)(a1 + 64);
        if (*(_DWORD *)(v3 + 216))
        {
          if (*(_DWORD *)(v3 + 224))
          {
            if (!*(unsigned char *)(a1 + 387))
            {
              uint64_t v5 = *(unsigned int *)(a1 + 388);
              if (v5)
              {
                sub_10003AC14(v5);
                *(_DWORD *)(a1 + 388) = 0;
              }
              sub_10001BF60(a1, 0);
              if (dword_10008FA20)
              {
                unsigned int v6 = ne_log_obj();
                if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
                {
                  int v7 = 136315138;
                  uint64_t v8 = a2;
                  _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "%s... rescheduling send_r_u.\n", (uint8_t *)&v7, 0xCu);
                }
              }
            }
            ++*(unsigned char *)(a1 + 387);
          }
        }
      }
    }
  }
}

char *sub_10001C4AC(uint64_t a1, int a2)
{
  return sub_10003E164(a2);
}

uint64_t sub_10001C4CC(uint64_t result, float a2)
{
  *uint64_t v3 = a2;
  *uint64_t v2 = result;
  return result;
}

char *sub_10001C4D8(unsigned __int16 *a1)
{
  unsigned int v2 = bswap32(*a1) >> 16;
  return sub_10003E164(v2);
}

uint64_t sub_10001C4F8(uint64_t a1)
{
  uint64_t v1 = (int *)(a1 + 56);
  if (*(_DWORD *)(a1 + 56) != 6336)
  {
    if (dword_10008FA20)
    {
      unsigned int v6 = ne_log_obj();
      if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR)) {
        sub_10005AED8();
      }
    }
    return 0xFFFFFFFFLL;
  }
  int v3 = sub_100026328(*(void *)(a1 + 256));
  *(_DWORD *)(a1 + 108) = v3;
  unint64_t v4 = *(void **)(a1 + 240);
  if (v4)
  {
    sub_10002DA30(v4);
    int v3 = *(_DWORD *)(a1 + 108);
  }
  uint64_t result = (uint64_t)sub_10002DAA8(*(void *)(a1 + 256), v3);
  *(void *)(a1 + 240) = result;
  if (result)
  {
    sub_100002728(v1, 6384);
    if (dword_10008F858) {
      return 0;
    }
    if ((sub_10002F924(a1) & 0x80000000) == 0)
    {
      if (dword_10008FA20)
      {
        int v7 = ne_log_obj();
        if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG)) {
          sub_10005CDFC();
        }
      }
      unsigned int v8 = sub_10003AA24(*(int *)(qword_10008F848 + 284), (uint64_t)sub_10002F7D4, a1);
      uint64_t result = 0;
      *(_DWORD *)(a1 + 64) = v8;
      return result;
    }
    if (dword_10008FA20)
    {
      unsigned int v9 = ne_log_obj();
      if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR)) {
        sub_10005CDC8();
      }
    }
    return 0xFFFFFFFFLL;
  }
  return result;
}

uint64_t sub_10001C650(uint64_t a1, uint64_t a2)
{
  unsigned int v44 = 0;
  unsigned int v45 = 0;
  if (a2)
  {
    if (dword_10008FA20)
    {
      unsigned int v2 = ne_log_obj();
      if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR)) {
        sub_10005CF68();
      }
    }
LABEL_73:
    uint64_t v35 = 0xFFFFFFFFLL;
    goto LABEL_74;
  }
  unint64_t v4 = (int *)(a1 + 56);
  if (*(_DWORD *)(a1 + 56) != 6352)
  {
    if (dword_10008FA20)
    {
      int v21 = ne_log_obj();
      if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR)) {
        sub_10005AED8();
      }
    }
    goto LABEL_73;
  }
  if ((sub_10000E688(a1, 0) & 0x80000000) != 0)
  {
    if (dword_10008FA20)
    {
      int v22 = ne_log_obj();
      if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR)) {
        sub_10005CE30();
      }
    }
    goto LABEL_73;
  }
  uint64_t v5 = sub_10000601C(*(_DWORD *)(*(void *)(*(void *)(a1 + 256) + 64) + 140));
  *(void *)(a1 + 208) = v5;
  if (!v5)
  {
    if (dword_10008FA20)
    {
      unsigned int v23 = ne_log_obj();
      if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR)) {
        sub_10005ACD8();
      }
    }
    goto LABEL_73;
  }
  uint64_t v6 = *(void *)(a1 + 120);
  int v7 = *(_DWORD *)(v6 + 20);
  if (v7)
  {
    if ((sub_100029A30(*(_DWORD *)(v6 + 20), a1 + 152) & 0x80000000) != 0)
    {
      if (dword_10008FA20)
      {
        long long v36 = ne_log_obj();
        if (os_log_type_enabled(v36, OS_LOG_TYPE_ERROR)) {
          sub_10005CF34();
        }
      }
      goto LABEL_73;
    }
    if ((sub_10002972C(*(void *)(a1 + 152), (size_t **)(a1 + 168), (void *)(a1 + 144)) & 0x80000000) != 0)
    {
      if (dword_10008FA20)
      {
        long long v38 = ne_log_obj();
        if (os_log_type_enabled(v38, OS_LOG_TYPE_ERROR)) {
          sub_10005ACA4();
        }
      }
      goto LABEL_73;
    }
  }
  if ((sub_10000FF98(a1) & 0x80000000) != 0)
  {
    if (dword_10008FA20)
    {
      long long v37 = ne_log_obj();
      if (os_log_type_enabled(v37, OS_LOG_TYPE_ERROR)) {
        sub_10005CE64();
      }
    }
    goto LABEL_73;
  }
  if (dword_10008C2C8 >= 7)
  {
    sub_100033908(7, *(void *)(*(void *)(a1 + 192) + 8), **(void **)(a1 + 192), "IDci:\n", v8, v9, v10, v11, (char)v44);
    if (dword_10008C2C8 >= 7) {
      sub_100033908(7, *(void *)(*(void *)(a1 + 200) + 8), **(void **)(a1 + 200), "IDcr:\n", v12, v13, v14, v15, (char)v44);
    }
  }
  BOOL v16 = *(unsigned char *)(*(void *)(*(void *)(a1 + 192) + 8) + 1)
     || *(unsigned char *)(*(void *)(*(void *)(a1 + 200) + 8) + 1)
     || *(_DWORD *)(*(void *)(*(void *)(a1 + 256) + 64) + 160)
     || !sub_10000ED24(*(void *)(a1 + 120));
  uint64_t v17 = **(void **)(a1 + 224) + **(void **)(a1 + 208) + 8;
  if (v7) {
    uint64_t v17 = **(void **)(a1 + 168) + (int)v17 + 4;
  }
  if (v16) {
    LODWORD(v17) = v17 + **(_DWORD **)(a1 + 192) + **(_DWORD **)(a1 + 200) + 8;
  }
  if (sub_10000ECE4(*(void *)(a1 + 120)) && (*(unsigned char *)(*(void *)(a1 + 256) + 96) & 6) != 0)
  {
    int v18 = sub_10003FF90(a1, &v45, &v44);
    int v19 = v18;
    if (v18)
    {
      if (v18 == -1)
      {
        if (dword_10008FA20)
        {
          int v20 = ne_log_obj();
          if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR)) {
            sub_10005CF00();
          }
        }
        goto LABEL_73;
      }
      LODWORD(v17) = v17 + *(_DWORD *)v45 + *(_DWORD *)v44 + 8;
    }
  }
  else
  {
    int v19 = 0;
  }
  __int16 v24 = sub_10003F940((int)v17);
  if (!v24)
  {
    if (dword_10008FA20)
    {
      int v39 = ne_log_obj();
      if (os_log_type_enabled(v39, OS_LOG_TYPE_ERROR)) {
        sub_10005CB90();
      }
    }
    goto LABEL_73;
  }
  int v25 = v24;
  __int16 v26 = sub_1000263E0(v24[1], *(uint64_t **)(a1 + 224), 10);
  if (v16) {
    int v27 = 5;
  }
  else {
    int v27 = v19;
  }
  if (v7) {
    int v28 = 4;
  }
  else {
    int v28 = v27;
  }
  long long v29 = sub_1000263E0((uint64_t)v26, *(uint64_t **)(a1 + 208), v28);
  if (v7) {
    long long v29 = sub_1000263E0((uint64_t)v29, *(uint64_t **)(a1 + 168), v27);
  }
  if (v16)
  {
    long long v30 = sub_1000263E0((uint64_t)v29, *(uint64_t **)(a1 + 192), 5);
    long long v29 = sub_1000263E0((uint64_t)v30, *(uint64_t **)(a1 + 200), v19);
  }
  if (v19)
  {
    long long v31 = sub_1000263E0((uint64_t)v29, (uint64_t *)v45, v19);
    sub_1000263E0((uint64_t)v31, (uint64_t *)v44, 0);
  }
  long long v32 = (uint64_t *)sub_10002A314(*(void *)(a1 + 256), *(_DWORD *)(a1 + 108), (uint64_t)v25);
  if (!v32)
  {
    if (dword_10008FA20)
    {
      unint64_t v40 = ne_log_obj();
      if (os_log_type_enabled(v40, OS_LOG_TYPE_ERROR)) {
        sub_10005CE98();
      }
    }
    sub_10003FA78(v25);
    goto LABEL_73;
  }
  long long v33 = v32;
  long long v34 = sub_10001CBBC(a1, (uint64_t)v25, v32);
  *(void *)(a1 + 80) = v34;
  if (!v34)
  {
    if (dword_10008FA20)
    {
      int v42 = ne_log_obj();
      if (os_log_type_enabled(v42, OS_LOG_TYPE_ERROR)) {
        sub_10005CECC();
      }
    }
    goto LABEL_86;
  }
  *(_DWORD *)(a1 + 72) = *(_DWORD *)(*(void *)(*(void *)(a1 + 256) + 64) + 200);
  if (sub_1000246C0(a1) == -1)
  {
    if (dword_10008FA20)
    {
      __int16 v43 = ne_log_obj();
      if (os_log_type_enabled(v43, OS_LOG_TYPE_ERROR)) {
        sub_10005AD0C();
      }
    }
LABEL_86:
    uint64_t v35 = 0xFFFFFFFFLL;
    goto LABEL_87;
  }
  sub_100002728(v4, 6369);
  uint64_t v35 = 0;
LABEL_87:
  sub_10003FA78(v25);
  sub_10003FA78(v33);
LABEL_74:
  if (v45) {
    sub_10003FA78(v45);
  }
  if (v44) {
    sub_10003FA78(v44);
  }
  return v35;
}

void *sub_10001CBBC(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v6 = sub_10003F940(*(_DWORD *)a3 + *(_DWORD *)a2 + 32);
  if (!v6)
  {
    if (dword_10008FA20)
    {
      uint64_t v12 = ne_log_obj();
      if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR)) {
        sub_10005CB90();
      }
    }
    return 0;
  }
  int v7 = v6;
  *(unsigned char *)(a1 + 105) |= 1u;
  uint64_t v8 = sub_1000263C8((uint64_t)v6, a1, 8);
  if (!v8)
  {
    if (dword_10008FA20)
    {
      uint64_t v13 = ne_log_obj();
      if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR)) {
        sub_10005CF9C();
      }
    }
    goto LABEL_14;
  }
  uint64_t v9 = sub_1000263E0(v8, a3, 1);
  memcpy(v9, *(const void **)(a2 + 8), *(void *)a2);
  uint64_t v10 = sub_10002E41C(*(void *)(a1 + 256), (uint64_t)v7, *(void *)(*(void *)(a1 + 240) + 8), **(void **)(a1 + 240));
  if (!v10)
  {
    if (dword_10008FA20)
    {
      uint64_t v14 = ne_log_obj();
      if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR)) {
        sub_10005CBC4();
      }
    }
LABEL_14:
    sub_10003FA78(v7);
    return 0;
  }
  uint64_t v11 = v10;
  sub_10003FA78(v7);
  return v11;
}

uint64_t sub_10001CD04(uint64_t a1, void *a2)
{
  int v3 = (int *)(a1 + 56);
  if (*(_DWORD *)(a1 + 56) != 6369)
  {
    if (dword_10008FA20)
    {
      uint64_t v6 = ne_log_obj();
      if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR)) {
        sub_10005AED8();
      }
    }
    goto LABEL_9;
  }
  uint64_t v4 = a2[1];
  if ((*(unsigned char *)(v4 + 19) & 1) == 0)
  {
    if (dword_10008FA20)
    {
      uint64_t v5 = ne_log_obj();
      if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR)) {
        sub_10005CFD0();
      }
    }
LABEL_9:
    uint64_t v7 = 0xFFFFFFFFLL;
LABEL_10:
    uint64_t v8 = *(void **)(a1 + 232);
    if (v8)
    {
      sub_10003FA78(v8);
      *(void *)(a1 + 232) = 0;
    }
    uint64_t v9 = *(void **)(a1 + 216);
    if (v9)
    {
      sub_10003FA78(v9);
      *(void *)(a1 + 216) = 0;
    }
    uint64_t v10 = *(void **)(a1 + 176);
    if (v10)
    {
      sub_10003FA78(v10);
      *(void *)(a1 + 176) = 0;
    }
    return v7;
  }
  uint64_t v12 = sub_10002E028(*(void *)(a1 + 256), a2, **(void **)(a1 + 240), *(void *)(*(void *)(a1 + 240) + 8));
  if (!v12)
  {
    if (dword_10008FA20)
    {
      int v63 = ne_log_obj();
      if (os_log_type_enabled(v63, OS_LOG_TYPE_ERROR)) {
        sub_10005C2D4();
      }
    }
    goto LABEL_9;
  }
  uint64_t v13 = v12;
  uint64_t v14 = sub_100022FA8((uint64_t)v12);
  if (!v14)
  {
    if (dword_10008FA20)
    {
      unint64_t v64 = ne_log_obj();
      if (os_log_type_enabled(v64, OS_LOG_TYPE_ERROR)) {
        sub_10005AF40();
      }
    }
    sub_10003FA78(v13);
    goto LABEL_9;
  }
  uint64_t v15 = v14;
  BOOL v16 = v14[1];
  if (*v16 != 8)
  {
    if (dword_10008FA20)
    {
      char v65 = ne_log_obj();
      if (os_log_type_enabled(v65, OS_LOG_TYPE_ERROR)) {
        sub_10005D344();
      }
    }
    goto LABEL_115;
  }
  int v18 = v16[16];
  uint64_t v17 = v16 + 16;
  uint64_t v19 = *((void *)v17 - 1);
  if (v18 != 1 && dword_10008FA20 != 0)
  {
    int v21 = ne_log_obj();
    if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
    {
      int v22 = *v17;
      *(_DWORD *)buf = 67109376;
      *(_DWORD *)&uint8_t buf[4] = v22;
      *(_WORD *)&uint8_t buf[8] = 1024;
      *(_DWORD *)&buf[10] = 8;
      _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "received invalid next payload type %d, expecting %d.\n", buf, 0xEu);
    }
  }
  unsigned int v24 = *(_DWORD *)(v4 + 24);
  unsigned int v23 = (unsigned int *)(v4 + 24);
  unsigned int v25 = **(_DWORD **)(a1 + 208) + bswap32(v24);
  if ((int)(v25 - 28) < 0)
  {
    if (dword_10008FA20)
    {
      __int16 v66 = ne_log_obj();
      if (os_log_type_enabled(v66, OS_LOG_TYPE_ERROR)) {
        sub_10005D004((uint64_t **)(a1 + 208), v23, v66);
      }
    }
    goto LABEL_115;
  }
  __int16 v26 = (void **)sub_10003F940(v25 - 28);
  if (!v26)
  {
    if (dword_10008FA20)
    {
      char v67 = ne_log_obj();
      if (os_log_type_enabled(v67, OS_LOG_TYPE_ERROR)) {
        sub_10005D09C();
      }
    }
LABEL_115:
    long long v29 = 0;
    int v28 = 0;
    uint64_t v7 = 0xFFFFFFFFLL;
    goto LABEL_116;
  }
  v90 = (size_t **)(a1 + 208);
  uint64_t v91 = v19;
  v92 = v26;
  int v27 = (char *)v26[1];
  *(void *)(a1 + 232) = 0;
  v95 = (size_t **)(a1 + 232);
  if (!*v17)
  {
    int v30 = 0;
    long long v29 = 0;
    int v28 = 0;
LABEL_123:
    if (v91 && *v95 && *(void *)(a1 + 216))
    {
      v68 = v29;
      memcpy(v92[1], (const void *)(*v90)[1], **v90);
      if (dword_10008FA20)
      {
        uint64_t v69 = ne_log_obj();
        if (os_log_type_enabled(v69, OS_LOG_TYPE_DEBUG))
        {
          int v84 = *v92;
          size_t v85 = **v90 + v30;
          *(_DWORD *)buf = 134218240;
          *(void *)&uint8_t buf[4] = v84;
          *(_WORD *)&buf[12] = 2048;
          size_t v100 = v85;
          _os_log_debug_impl((void *)&_mh_execute_header, v69, OS_LOG_TYPE_DEBUG, "HASH allocated:hbuf->l=%zu actual:tlen=%zu\n", buf, 0x16u);
        }
      }
      NSObject *v92 = (void *)(**(void **)(a1 + 208) + v30);
      uint64_t v70 = sub_10002A314(*(void *)(a1 + 256), *(_DWORD *)(a1 + 108), (uint64_t)v92);
      if (v70)
      {
        v71 = (void *)v70;
        int v72 = timingsafe_bcmp(*(const void **)(v70 + 8), (const void *)(v91 + 4), *(void *)v70);
        sub_10003FA78(v71);
        if (v72)
        {
          if (dword_10008FA20)
          {
            v73 = ne_log_obj();
            if (os_log_type_enabled(v73, OS_LOG_TYPE_DEBUG)) {
              sub_10005D104();
            }
          }
          uint64_t v7 = 23;
        }
        else
        {
          long long v29 = v68;
          if ((sub_10000C788(a1) & 0x80000000) == 0)
          {
            sub_100002728(v3, 6338);
            uint64_t v7 = 0;
            goto LABEL_164;
          }
          if (!dword_10008FA20)
          {
            uint64_t v7 = 14;
            goto LABEL_164;
          }
          v82 = ne_log_obj();
          if (os_log_type_enabled(v82, OS_LOG_TYPE_ERROR)) {
            sub_10005D0D0();
          }
          uint64_t v7 = 14;
        }
      }
      else
      {
        if (dword_10008FA20)
        {
          uint64_t v76 = ne_log_obj();
          if (os_log_type_enabled(v76, OS_LOG_TYPE_ERROR)) {
            sub_10005CE98();
          }
        }
        uint64_t v7 = 0xFFFFFFFFLL;
      }
      long long v29 = v68;
      goto LABEL_164;
    }
    if (dword_10008FA20)
    {
      __int16 v74 = v29;
      v75 = ne_log_obj();
      if (os_log_type_enabled(v75, OS_LOG_TYPE_ERROR)) {
        sub_10005B014();
      }
LABEL_138:
      uint64_t v7 = 0xFFFFFFFFLL;
      goto LABEL_139;
    }
LABEL_163:
    uint64_t v7 = 0xFFFFFFFFLL;
    goto LABEL_164;
  }
  int v28 = 0;
  long long v29 = 0;
  int v30 = 0;
  int v96 = 0;
  long long v31 = &v27[**(void **)(a1 + 208)];
  uint32_t v89 = &v102;
  while (2)
  {
    memcpy(v31, *((const void **)v17 + 1), *((int *)v17 + 1));
    unsigned int v32 = *v17;
    if (v32 > 0xF)
    {
      BOOL v35 = v32 == 16 || v32 == 21;
      if (v35 || v32 == 131)
      {
        *(void *)buf = 0;
        sub_1000261F4((size_t **)buf, *((void *)v17 + 1));
        if (*(void *)buf)
        {
          long long v36 = sub_1000401E0(*(uint64_t *)buf);
          if (v36)
          {
            long long v37 = (const sockaddr *)v36;
            if (v29)
            {
              if (v28)
              {
                free(v36);
              }
              else if (dword_10008FA20)
              {
                long long v51 = ne_log_obj();
                if (os_log_type_enabled(v51, OS_LOG_TYPE_DEBUG)) {
                  sub_10005D2FC((uint64_t)v101, v37);
                }
                int v28 = (sockaddr *)v37;
              }
              else
              {
                int v28 = (sockaddr *)v36;
              }
            }
            else
            {
              if (dword_10008FA20)
              {
                long long v50 = ne_log_obj();
                if (os_log_type_enabled(v50, OS_LOG_TYPE_DEBUG)) {
                  sub_10005D2B4((uint64_t)v103, v37);
                }
              }
              long long v29 = (sockaddr *)v37;
            }
          }
          sub_10003FA78(*(void **)buf);
        }
        goto LABEL_97;
      }
LABEL_153:
      if (dword_10008FA20)
      {
        __int16 v74 = v29;
        v79 = ne_log_obj();
        if (os_log_type_enabled(v79, OS_LOG_TYPE_ERROR)) {
          sub_10005BF70();
        }
        goto LABEL_138;
      }
      goto LABEL_163;
    }
    switch(*v17)
    {
      case 1u:
        if (*v95)
        {
          if (dword_10008FA20)
          {
            long long v33 = v29;
            long long v34 = ne_log_obj();
            if (os_log_type_enabled(v34, OS_LOG_TYPE_ERROR)) {
              sub_10005D138(&v97, v98, v34);
            }
            long long v29 = v33;
          }
          goto LABEL_97;
        }
        if ((sub_1000261F4(v95, *((void *)v17 + 1)) & 0x80000000) == 0) {
          goto LABEL_97;
        }
        if (!dword_10008FA20) {
          goto LABEL_163;
        }
        __int16 v74 = v29;
        v81 = ne_log_obj();
        if (os_log_type_enabled(v81, OS_LOG_TYPE_ERROR)) {
          sub_10005AF74();
        }
        goto LABEL_138;
      case 4u:
        if ((sub_1000261F4((size_t **)(a1 + 176), *((void *)v17 + 1)) & 0x80000000) == 0) {
          goto LABEL_97;
        }
        if (!dword_10008FA20) {
          goto LABEL_163;
        }
        __int16 v74 = v29;
        v77 = ne_log_obj();
        if (os_log_type_enabled(v77, OS_LOG_TYPE_ERROR)) {
          sub_10005B1B4();
        }
        goto LABEL_138;
      case 5u:
        long long v38 = *(void **)(a1 + 192);
        if (!v38 || !*(void *)(a1 + 200)) {
          goto LABEL_163;
        }
        unsigned int v93 = v28;
        if (v96) {
          long long v38 = *(void **)(a1 + 200);
        }
        int v39 = (unsigned __int8 *)v38[1];
        uint64_t v40 = *((void *)v17 + 1);
        int v41 = (const void *)(v40 + 4);
        if (*v39 == *(unsigned __int8 *)(v40 + 4)
          && (!*(unsigned char *)(v40 + 5) || *(unsigned __int8 *)(v40 + 5) == v39[1])
          && (!*(_WORD *)(v40 + 6) || *(unsigned __int16 *)(v40 + 6) == *((unsigned __int16 *)v39 + 1))
          && !memcmp(v39 + 4, (const void *)(v40 + 8), *v38 - 4))
        {
          goto LABEL_80;
        }
        if ((*(unsigned char *)(*(void *)(a1 + 256) + 96) & 6) != 0)
        {
          int v94 = v29;
          if (dword_10008FA20)
          {
            int v42 = ne_log_obj();
            if (os_log_type_enabled(v42, OS_LOG_TYPE_DEFAULT))
            {
              *(_WORD *)buf = 0;
              _os_log_impl((void *)&_mh_execute_header, v42, OS_LOG_TYPE_DEFAULT, "mismatched ID was returned - ignored because nat traversal is being used.\n", buf, 2u);
            }
          }
          int v43 = *(_DWORD *)(*(void *)(a1 + 256) + 96);
          if (v96)
          {
            long long v29 = v94;
            if ((v43 & 4) != 0)
            {
              unsigned int v44 = *(void **)(a1 + 288);
              if (v44) {
                sub_10003FA78(v44);
              }
              unsigned int v45 = sub_10003F940((bswap32(*(unsigned __int16 *)(v40 + 2)) >> 16) - 4);
              *(void *)(a1 + 288) = v45;
              if (v45)
              {
                memcpy((void *)v45[1], v41, *v45);
                if (dword_10008C2C8 >= 7) {
                  sub_100033908(7, *(void *)(*(void *)(a1 + 288) + 8), **(void **)(a1 + 288), "peer's external nat address saved.\n", v46, v47, v48, v49, (char)v89);
                }
                goto LABEL_80;
              }
              if (dword_10008FA20)
              {
                v83 = ne_log_obj();
                int v28 = v93;
                if (os_log_type_enabled(v83, OS_LOG_TYPE_ERROR)) {
                  sub_10005D280();
                }
                goto LABEL_184;
              }
              uint64_t v7 = 0xFFFFFFFFLL;
LABEL_186:
              int v28 = v93;
              goto LABEL_164;
            }
          }
          else
          {
            long long v29 = v94;
            if ((v43 & 2) != 0)
            {
              long long v52 = *(void **)(qword_10008F848 + 296);
              if (v52) {
                sub_10003FA78(v52);
              }
              unsigned int v53 = *(unsigned __int16 *)(v40 + 2);
              if (v53 <= 3)
              {
                if (dword_10008FA20)
                {
                  int v86 = ne_log_obj();
                  if (os_log_type_enabled(v86, OS_LOG_TYPE_ERROR)) {
                    sub_10005D1AC();
                  }
                }
              }
              else
              {
                long long v54 = sub_10003F940(__rev16(v53) - 4);
                *(void *)(qword_10008F848 + 296) = v54;
                if (v54)
                {
                  memcpy((void *)v54[1], v41, *v54);
                  long long v55 = *(void **)(a1 + 280);
                  if (v55) {
                    sub_10003FA78(v55);
                  }
                  long long v56 = sub_10003FAC0(*(void *)(qword_10008F848 + 296));
                  *(void *)(a1 + 280) = v56;
                  int v28 = v93;
                  if (v56)
                  {
                    if (dword_10008C2C8 >= 7) {
                      sub_100033908(7, v56[1], *v56, "external nat address saved.\n", v57, v58, v59, v60, (char)v89);
                    }
                    int v96 = 1;
                    goto LABEL_97;
                  }
                  if (dword_10008FA20)
                  {
                    v88 = ne_log_obj();
                    if (os_log_type_enabled(v88, OS_LOG_TYPE_ERROR)) {
                      sub_10005D24C();
                    }
                  }
LABEL_184:
                  uint64_t v7 = 0xFFFFFFFFLL;
                  long long v29 = v94;
                  goto LABEL_164;
                }
                if (dword_10008FA20)
                {
                  v87 = ne_log_obj();
                  if (os_log_type_enabled(v87, OS_LOG_TYPE_ERROR)) {
                    sub_10005D218();
                  }
                }
              }
              uint64_t v7 = 0xFFFFFFFFLL;
              int v28 = v93;
              long long v29 = v94;
              goto LABEL_164;
            }
          }
LABEL_80:
          int v96 = 1;
          int v28 = v93;
LABEL_97:
          int v61 = v17[16];
          v17 += 16;
          uint64_t v62 = *((int *)v17 - 3);
          v31 += v62;
          v30 += v62;
          if (!v61) {
            goto LABEL_123;
          }
          continue;
        }
        if (!dword_10008FA20)
        {
          uint64_t v7 = 13;
          goto LABEL_186;
        }
        __int16 v74 = v29;
        v80 = ne_log_obj();
        int v28 = v93;
        if (os_log_type_enabled(v80, OS_LOG_TYPE_ERROR)) {
          sub_10005D178();
        }
        uint64_t v7 = 13;
LABEL_139:
        long long v29 = v74;
LABEL_164:
        sub_10003FA78(v92);
LABEL_116:
        sub_10003FA78(v15);
        sub_10003FA78(v13);
        if (v29) {
          free(v29);
        }
        if (v28) {
          free(v28);
        }
        if (v7) {
          goto LABEL_10;
        }
        return v7;
      case 0xAu:
        if ((sub_1000261F4((size_t **)(a1 + 216), *((void *)v17 + 1)) & 0x80000000) == 0) {
          goto LABEL_97;
        }
        if (!dword_10008FA20) {
          goto LABEL_163;
        }
        __int16 v74 = v29;
        v78 = ne_log_obj();
        if (os_log_type_enabled(v78, OS_LOG_TYPE_ERROR)) {
          sub_10005B1E8();
        }
        goto LABEL_138;
      case 0xBu:
        sub_10001B9A8(*((void *)v17 + 1), a1);
        goto LABEL_97;
      default:
        goto LABEL_153;
    }
  }
}

uint64_t sub_10001D91C(uint64_t a1, uint64_t a2)
{
  unsigned int v2 = (int *)(a1 + 56);
  if (*(_DWORD *)(a1 + 56) == 6338)
  {
    if (dword_10008FA20)
    {
      uint64_t v5 = ne_log_obj();
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG)) {
        sub_10005D55C();
      }
    }
    uint64_t v6 = sub_10003F940(**(void **)(a1 + 216) + **(void **)(a1 + 208));
    if (v6)
    {
      uint64_t v7 = v6;
      memcpy((void *)v6[1], *(const void **)(*(void *)(a1 + 208) + 8), **(void **)(a1 + 208));
      memcpy((void *)(v7[1] + **(void **)(a1 + 208)), *(const void **)(*(void *)(a1 + 216) + 8), **(void **)(a1 + 216));
      uint64_t v8 = (uint64_t *)sub_10002A230(*(void *)(a1 + 256), *(_DWORD *)(a1 + 108), (uint64_t)v7);
      sub_10003FA78(v7);
      if (v8)
      {
        uint64_t v9 = sub_10003F940(*(_DWORD *)v8 + 32);
        if (!v9)
        {
          if (dword_10008FA20)
          {
            int v21 = ne_log_obj();
            if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR)) {
              sub_10005CB90();
            }
          }
          uint64_t v19 = 0xFFFFFFFFLL;
          goto LABEL_74;
        }
        uint64_t v10 = v9;
        uint64_t v11 = sub_1000263C8((uint64_t)v9, a1, 8);
        if (!v11)
        {
          if (dword_10008FA20)
          {
            int v22 = ne_log_obj();
            if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR)) {
              sub_10005D3BC();
            }
          }
          goto LABEL_72;
        }
        sub_1000263E0(v11, v8, 0);
        uint64_t v12 = sub_10002E41C(*(void *)(a1 + 256), (uint64_t)v10, *(void *)(*(void *)(a1 + 240) + 8), **(void **)(a1 + 240));
        *(void *)(a1 + 80) = v12;
        if (!v12)
        {
          if (dword_10008FA20)
          {
            unsigned int v23 = ne_log_obj();
            if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR)) {
              sub_10005CBC4();
            }
          }
          goto LABEL_72;
        }
        uint64_t v13 = v12;
        uint64_t v14 = *(void *)(a1 + 256);
        if ((*(unsigned char *)(a1 + 105) & 2) != 0)
        {
          *(_DWORD *)(a1 + 72) = *(_DWORD *)(*(void *)(v14 + 64) + 200);
          if (sub_1000246C0(a1) == -1)
          {
            if (dword_10008FA20)
            {
              long long v33 = ne_log_obj();
              if (os_log_type_enabled(v33, OS_LOG_TYPE_ERROR)) {
                sub_10005D528();
              }
            }
            goto LABEL_72;
          }
        }
        else if ((sub_100023E30(v14, v13) & 0x80000000) != 0)
        {
          if (dword_10008FA20)
          {
            uint64_t v15 = ne_log_obj();
            if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR)) {
              sub_10005AD0C();
            }
          }
LABEL_72:
          uint64_t v19 = 0xFFFFFFFFLL;
          goto LABEL_73;
        }
        unint64_t v24 = *(void *)(a1 + 256);
        uint64_t v25 = *(void *)(v24 + 48);
        uint64_t v26 = *(void *)(v24 + 56);
        int v27 = *(void **)(a1 + 80);
        if (*(_DWORD *)(v24 + 100) && *v27 >= 0x501uLL)
        {
          uint64_t v28 = 0;
          LODWORD(v24) = *(_DWORD *)(v24 + 96);
        }
        else
        {
          unint64_t v24 = *(unsigned int *)(v24 + 96);
          uint64_t v28 = (v24 >> 3) & 4;
        }
        if (sub_100009070(v25, v26, (uint64_t)v27, a2, v28, (v24 >> 5) & 1) == -1)
        {
          if (dword_10008FA20)
          {
            unsigned int v32 = ne_log_obj();
            if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR)) {
              sub_10005B794();
            }
          }
          goto LABEL_72;
        }
        if ((sub_100029C94(a1, 0) & 0x80000000) != 0)
        {
          if (dword_10008FA20)
          {
            long long v34 = ne_log_obj();
            if (os_log_type_enabled(v34, OS_LOG_TYPE_ERROR)) {
              sub_10005D3F0();
            }
          }
          goto LABEL_72;
        }
        if ((*(unsigned char *)(a1 + 105) & 2) != 0)
        {
          sub_100002728(v2, 6371);
        }
        else
        {
          sub_100002728(v2, 6344);
          if (dword_10008FA20)
          {
            long long v29 = ne_log_obj();
            if (os_log_type_enabled(v29, OS_LOG_TYPE_DEBUG)) {
              sub_10005D4F4();
            }
          }
          if ((sub_10002FD58(a1) & 0x80000000) != 0)
          {
            if (dword_10008FA20)
            {
              BOOL v35 = ne_log_obj();
              if (os_log_type_enabled(v35, OS_LOG_TYPE_ERROR)) {
                sub_10005D424();
              }
            }
            goto LABEL_72;
          }
          if (dword_10008FA20)
          {
            int v30 = ne_log_obj();
            if (os_log_type_enabled(v30, OS_LOG_TYPE_DEBUG)) {
              sub_10005D4C0();
            }
          }
          if ((sub_100030134(a1) & 0x80000000) != 0)
          {
            if (dword_10008FA20)
            {
              long long v36 = ne_log_obj();
              if (os_log_type_enabled(v36, OS_LOG_TYPE_ERROR)) {
                sub_10005D458();
              }
            }
            goto LABEL_72;
          }
          if (dword_10008FA20)
          {
            long long v31 = ne_log_obj();
            if (os_log_type_enabled(v31, OS_LOG_TYPE_DEBUG)) {
              sub_10005D48C();
            }
          }
        }
        uint64_t v19 = 0;
LABEL_73:
        sub_10003FA78(v10);
LABEL_74:
        sub_10003FA78(v8);
        return v19;
      }
      if (dword_10008FA20)
      {
        int v18 = ne_log_obj();
        if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR)) {
          sub_10005CE98();
        }
      }
    }
    else if (dword_10008FA20)
    {
      uint64_t v17 = ne_log_obj();
      if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR)) {
        sub_10005D09C();
      }
    }
  }
  else if (dword_10008FA20)
  {
    BOOL v16 = ne_log_obj();
    if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR)) {
      sub_10005AED8();
    }
  }
  return 0xFFFFFFFFLL;
}

uint64_t sub_10001DD90(uint64_t a1, void *a2)
{
  unsigned int v2 = (int *)(a1 + 56);
  if (*(_DWORD *)(a1 + 56) != 6371)
  {
    if (dword_10008FA20)
    {
      uint64_t v4 = ne_log_obj();
      if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR)) {
        sub_10005AED8();
      }
    }
    return 0xFFFFFFFFLL;
  }
  if ((*(unsigned char *)(a2[1] + 19) & 1) == 0)
  {
    if (dword_10008FA20)
    {
      int v3 = ne_log_obj();
      if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR)) {
        sub_10005CFD0();
      }
    }
    return 0xFFFFFFFFLL;
  }
  uint64_t v8 = sub_10002E028(*(void *)(a1 + 256), a2, **(void **)(a1 + 240), *(void *)(*(void *)(a1 + 240) + 8));
  if (!v8)
  {
    if (dword_10008FA20)
    {
      uint64_t v17 = ne_log_obj();
      if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR)) {
        sub_10005D590();
      }
    }
    return 0xFFFFFFFFLL;
  }
  uint64_t v9 = v8;
  uint64_t v10 = sub_100022FA8((uint64_t)v8);
  if (!v10)
  {
    if (dword_10008FA20)
    {
      int v22 = ne_log_obj();
      if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR)) {
        sub_10005D5C4();
      }
    }
    sub_10003FA78(v9);
    return 0xFFFFFFFFLL;
  }
  uint64_t v11 = 0;
  uint64_t v12 = 0;
  unsigned int v32 = v10;
  for (uint64_t i = (unsigned __int8 *)v10[1]; ; i += 16)
  {
    int v14 = *i;
    if (v14 == 8)
    {
      uint64_t v11 = *((void *)i + 1);
      continue;
    }
    if (v14 != 11) {
      break;
    }
    if (v12)
    {
      if (dword_10008FA20)
      {
        uint64_t v15 = ne_log_obj();
        if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "Ignoring multiple notifications\n", buf, 2u);
        }
      }
    }
    else
    {
      sub_10001B9A8(*((void *)i + 1), a1);
      BOOL v16 = sub_10003F940(*((int *)i + 1));
      if (!v16)
      {
        if (dword_10008FA20)
        {
          uint64_t v25 = ne_log_obj();
          int v21 = v32;
          if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR)) {
            sub_10005D660();
          }
          uint64_t v12 = 0;
LABEL_52:
          uint64_t v5 = 0xFFFFFFFFLL;
          goto LABEL_58;
        }
        uint64_t v12 = 0;
LABEL_56:
        uint64_t v5 = 0xFFFFFFFFLL;
LABEL_57:
        int v21 = v32;
        goto LABEL_58;
      }
      uint64_t v12 = v16;
      memcpy((void *)v16[1], *((const void **)i + 1), *v16);
    }
  }
  if (*i)
  {
    if (dword_10008FA20)
    {
      unsigned int v23 = ne_log_obj();
      int v21 = v32;
      if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR)) {
        sub_10005BF70();
      }
      goto LABEL_52;
    }
    goto LABEL_56;
  }
  if (!v11)
  {
    if (dword_10008FA20)
    {
      unint64_t v24 = ne_log_obj();
      int v21 = v32;
      if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR)) {
        sub_10005B014();
      }
      goto LABEL_52;
    }
    goto LABEL_56;
  }
  uint64_t v18 = sub_10002A314(*(void *)(a1 + 256), *(_DWORD *)(a1 + 108), (uint64_t)v12);
  sub_10003FA78(0);
  if (!v18)
  {
    if (dword_10008FA20)
    {
      uint64_t v26 = ne_log_obj();
      int v21 = v32;
      if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR)) {
        sub_10005D5F8();
      }
      goto LABEL_52;
    }
    goto LABEL_56;
  }
  int v19 = timingsafe_bcmp(*(const void **)(v18 + 8), (const void *)(v11 + 4), *(void *)v18);
  sub_10003FA78((void *)v18);
  if (v19)
  {
    if (!dword_10008FA20)
    {
      uint64_t v5 = 23;
      goto LABEL_57;
    }
    int v20 = ne_log_obj();
    int v21 = v32;
    if (os_log_type_enabled(v20, OS_LOG_TYPE_DEBUG)) {
      sub_10005D62C();
    }
    uint64_t v5 = 23;
  }
  else
  {
    sub_100002728(v2, 6344);
    *(unsigned char *)(a1 + 105) ^= 2u;
    if (dword_10008F858)
    {
      uint64_t v5 = 0;
      goto LABEL_57;
    }
    if (dword_10008FA20)
    {
      int v27 = ne_log_obj();
      if (os_log_type_enabled(v27, OS_LOG_TYPE_DEBUG)) {
        sub_10005D4F4();
      }
    }
    if ((sub_10002FD58(a1) & 0x80000000) != 0)
    {
      if (dword_10008FA20)
      {
        int v30 = ne_log_obj();
        int v21 = v32;
        if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR)) {
          sub_10005D424();
        }
        goto LABEL_52;
      }
      goto LABEL_56;
    }
    if (dword_10008FA20)
    {
      uint64_t v28 = ne_log_obj();
      if (os_log_type_enabled(v28, OS_LOG_TYPE_DEBUG)) {
        sub_10005D4C0();
      }
    }
    if ((sub_100030134(a1) & 0x80000000) != 0)
    {
      int v21 = v32;
      if (dword_10008FA20)
      {
        long long v31 = ne_log_obj();
        if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR)) {
          sub_10005D458();
        }
      }
      goto LABEL_52;
    }
    int v21 = v32;
    if (dword_10008FA20)
    {
      long long v29 = ne_log_obj();
      if (os_log_type_enabled(v29, OS_LOG_TYPE_DEBUG)) {
        sub_10005D48C();
      }
    }
    uint64_t v5 = 0;
  }
LABEL_58:
  sub_10003FA78(v9);
  sub_10003FA78(v21);
  if (v12) {
    sub_10003FA78(v12);
  }
  return v5;
}

uint64_t sub_10001E238(uint64_t a1, void *a2)
{
  int v3 = (int *)(a1 + 56);
  if (*(_DWORD *)(a1 + 56) != 6592)
  {
    if (dword_10008FA20)
    {
      uint64_t v8 = ne_log_obj();
      if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR)) {
        sub_10005AED8();
      }
    }
    goto LABEL_9;
  }
  uint64_t v5 = a2[1];
  if ((*(unsigned char *)(v5 + 19) & 1) == 0)
  {
    if (dword_10008FA20)
    {
      uint64_t v6 = ne_log_obj();
      uint64_t v7 = 16;
      if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR)) {
        sub_10005CFD0();
      }
    }
    else
    {
      uint64_t v7 = 16;
    }
    goto LABEL_10;
  }
  uint64_t v15 = sub_10002E028(*(void *)(a1 + 256), a2, **(void **)(a1 + 240), *(void *)(*(void *)(a1 + 240) + 8));
  if (!v15)
  {
    if (dword_10008FA20)
    {
      unsigned int v23 = ne_log_obj();
      if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR)) {
        sub_10005D590();
      }
    }
    goto LABEL_9;
  }
  BOOL v16 = v15;
  uint64_t v17 = sub_100022FA8((uint64_t)v15);
  if (!v17)
  {
    if (dword_10008FA20)
    {
      unint64_t v24 = ne_log_obj();
      if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR)) {
        sub_10005D5C4();
      }
    }
    sub_10003FA78(v16);
LABEL_9:
    uint64_t v7 = 0xFFFFFFFFLL;
LABEL_10:
    uint64_t v9 = *(void **)(a1 + 224);
    if (v9)
    {
      sub_10003FA78(v9);
      *(void *)(a1 + 224) = 0;
    }
    uint64_t v10 = *(void **)(a1 + 216);
    if (v10)
    {
      sub_10003FA78(v10);
      *(void *)(a1 + 216) = 0;
    }
    uint64_t v11 = *(void **)(a1 + 176);
    if (v11)
    {
      sub_10003FA78(v11);
      *(void *)(a1 + 176) = 0;
    }
    uint64_t v12 = *(void **)(a1 + 192);
    if (v12)
    {
      sub_10003FA78(v12);
      *(void *)(a1 + 192) = 0;
    }
    uint64_t v13 = *(void **)(a1 + 200);
    if (v13)
    {
      sub_10003FA78(v13);
      *(void *)(a1 + 200) = 0;
    }
    return v7;
  }
  uint64_t v18 = v17;
  int v19 = v17[1];
  if (*v19 != 8)
  {
    if (dword_10008FA20)
    {
      uint64_t v25 = ne_log_obj();
      if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR)) {
        sub_10005D344();
      }
    }
    uint64_t v26 = 0;
    int v27 = 0;
    uint64_t v7 = 15;
    goto LABEL_163;
  }
  int v21 = v19[16];
  int v20 = v19 + 16;
  uint64_t v22 = *((void *)v20 - 1);
  if (v21 == 1)
  {
    uint64_t v7 = 0xFFFFFFFFLL;
  }
  else
  {
    if (dword_10008FA20)
    {
      uint64_t v28 = ne_log_obj();
      if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
      {
        int v29 = *v20;
        *(_DWORD *)buf = 67109376;
        int v93 = v29;
        __int16 v94 = 1024;
        int v95 = 1;
        _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, "received invalid next payload type %d, expecting %d.\n", buf, 0xEu);
      }
    }
    uint64_t v7 = 15;
  }
  unsigned int v30 = bswap32(*(_DWORD *)(v5 + 24));
  if ((int)(v30 - 28) < 0)
  {
    if (dword_10008FA20)
    {
      long long v51 = ne_log_obj();
      if (os_log_type_enabled(v51, OS_LOG_TYPE_ERROR)) {
        sub_10005D694();
      }
    }
    goto LABEL_97;
  }
  long long v31 = sub_10003F940(v30 - 28);
  if (!v31)
  {
    if (dword_10008FA20)
    {
      long long v52 = ne_log_obj();
      if (os_log_type_enabled(v52, OS_LOG_TYPE_ERROR)) {
        sub_10005D09C();
      }
    }
LABEL_97:
    uint64_t v26 = 0;
    int v27 = 0;
    goto LABEL_163;
  }
  uint64_t v76 = v22;
  v77 = v18;
  long long v36 = (char *)v31[1];
  *(void *)(a1 + 216) = 0;
  *(void *)(a1 + 224) = 0;
  v80 = (size_t **)(a1 + 216);
  v81 = (size_t **)(a1 + 224);
  *(void *)(a1 + 176) = 0;
  v78 = v31;
  *(void *)(a1 + 200) = 0;
  v79 = (unint64_t **)(a1 + 200);
  *(void *)(a1 + 192) = 0;
  v82 = (unint64_t **)(a1 + 192);
  if (!*v20)
  {
    int v38 = 0;
    v83 = 0;
    size_t v85 = 0;
LABEL_99:
    uint64_t v18 = v77;
    if (!v76 || !*v81 || !*v80)
    {
      if (dword_10008FA20)
      {
        uint64_t v58 = ne_log_obj();
        uint64_t v7 = 16;
        int v27 = (sockaddr *)v85;
        if (os_log_type_enabled(v58, OS_LOG_TYPE_ERROR)) {
          sub_10005D700();
        }
        goto LABEL_117;
      }
      uint64_t v7 = 16;
      goto LABEL_161;
    }
    unsigned int v53 = dword_10008C2C8;
    if (*v79 && dword_10008C2C8 >= 7)
    {
      sub_100033908(7, (*v79)[1], **v79, "received IDci2:", v32, v33, v34, v35, (char)v75);
      unsigned int v53 = dword_10008C2C8;
    }
    if (*v82 && v53 >= 7) {
      sub_100033908(7, (*v82)[1], **v82, "received IDcr2:", v32, v33, v34, v35, (char)v75);
    }
    void *v78 = v38;
    uint64_t v54 = sub_10002A314(*(void *)(a1 + 256), *(_DWORD *)(a1 + 108), (uint64_t)v78);
    if (!v54)
    {
      if (dword_10008FA20)
      {
        uint64_t v59 = ne_log_obj();
        int v27 = (sockaddr *)v85;
        if (os_log_type_enabled(v59, OS_LOG_TYPE_ERROR)) {
          sub_10005D5F8();
        }
        goto LABEL_117;
      }
      goto LABEL_161;
    }
    long long v55 = (void *)v54;
    int v56 = timingsafe_bcmp(*(const void **)(v54 + 8), (const void *)(v76 + 4), *(void *)v54);
    sub_10003FA78(v55);
    if (v56)
    {
      if (dword_10008FA20)
      {
        uint64_t v57 = ne_log_obj();
        int v27 = (sockaddr *)v85;
        if (os_log_type_enabled(v57, OS_LOG_TYPE_ERROR)) {
          sub_10005D86C();
        }
        uint64_t v7 = 23;
        goto LABEL_117;
      }
      uint64_t v7 = 23;
      goto LABEL_161;
    }
    if (sub_10001ED90((uint64_t *)a1))
    {
      if (dword_10008FA20)
      {
        unint64_t v64 = ne_log_obj();
        int v27 = (sockaddr *)v85;
        if (os_log_type_enabled(v64, OS_LOG_TYPE_ERROR)) {
          sub_10005D838();
        }
        uint64_t v7 = 0xFFFFFFFFLL;
        goto LABEL_117;
      }
      goto LABEL_158;
    }
    uint64_t v68 = sub_10001F198(a1);
    if (v68)
    {
      uint64_t v7 = v68;
      if (v68 != -2)
      {
        if (dword_10008FA20)
        {
          int v72 = ne_log_obj();
          if (os_log_type_enabled(v72, OS_LOG_TYPE_ERROR)) {
            sub_10005D734();
          }
        }
        goto LABEL_161;
      }
      if (sub_100037D44(a1))
      {
        if (dword_10008FA20)
        {
          uint64_t v69 = ne_log_obj();
          if (os_log_type_enabled(v69, OS_LOG_TYPE_ERROR)) {
            sub_10005D804();
          }
        }
LABEL_158:
        uint64_t v7 = 0xFFFFFFFFLL;
        goto LABEL_161;
      }
    }
    if ((sub_10000C184(a1) & 0x80000000) != 0)
    {
      if (dword_10008FA20)
      {
        v73 = ne_log_obj();
        if (os_log_type_enabled(v73, OS_LOG_TYPE_ERROR)) {
          sub_10005D768();
        }
      }
      goto LABEL_185;
    }
    int v70 = *(_DWORD *)(*(void *)(a1 + 128) + 20);
    if (*(void *)(a1 + 176))
    {
      if (!v70)
      {
        if (dword_10008FA20)
        {
          v71 = ne_log_obj();
          if (os_log_type_enabled(v71, OS_LOG_TYPE_ERROR)) {
            sub_10005D7D0();
          }
        }
LABEL_185:
        uint64_t v7 = 14;
        goto LABEL_161;
      }
    }
    else if (v70)
    {
      if (dword_10008FA20)
      {
        __int16 v74 = ne_log_obj();
        if (os_log_type_enabled(v74, OS_LOG_TYPE_ERROR)) {
          sub_10005D79C();
        }
      }
      goto LABEL_185;
    }
    sub_10004BE1C(a1);
    *(void *)(a1 + 88) = sub_10003FAC0((uint64_t)a2);
    sub_100002728(v3, 6593);
    uint64_t v7 = 0;
    goto LABEL_161;
  }
  v83 = 0;
  size_t v85 = 0;
  int v37 = 0;
  int v38 = 0;
  v75 = v91;
  while (2)
  {
    memcpy(v36, *((const void **)v20 + 1), *((int *)v20 + 1));
    int v43 = *v20;
    if (v43 != 5) {
      int v37 = 0;
    }
    if (*v20 > 0xFu)
    {
      BOOL v44 = v43 == 16 || v43 == 21;
      if (v44 || v43 == 131)
      {
        v87 = 0;
        sub_1000261F4((size_t **)&v87, *((void *)v20 + 1));
        if (v87)
        {
          unsigned int v45 = sub_1000401E0((uint64_t)v87);
          if (v45)
          {
            uint64_t v46 = (const sockaddr *)v45;
            if (v85)
            {
              if (v83)
              {
                free(v45);
              }
              else
              {
                if (dword_10008FA20)
                {
                  int v84 = ne_log_obj();
                  if (os_log_type_enabled(v84, OS_LOG_TYPE_DEBUG)) {
                    sub_10005DAC8((uint64_t)v90, v46);
                  }
                }
                v83 = v46;
              }
            }
            else
            {
              if (dword_10008FA20)
              {
                int v86 = ne_log_obj();
                if (os_log_type_enabled(v86, OS_LOG_TYPE_DEBUG)) {
                  sub_10005DA80((uint64_t)buf, v46);
                }
              }
              size_t v85 = v46;
            }
          }
          sub_10003FA78(v87);
        }
        goto LABEL_89;
      }
LABEL_139:
      if (!dword_10008FA20)
      {
        uint64_t v7 = 16;
        goto LABEL_160;
      }
      char v65 = ne_log_obj();
      uint64_t v7 = 16;
      uint64_t v18 = v77;
      int v27 = (sockaddr *)v85;
      if (os_log_type_enabled(v65, OS_LOG_TYPE_ERROR)) {
        sub_10005D8A0();
      }
      goto LABEL_117;
    }
    switch(*v20)
    {
      case 1u:
        if (*v81)
        {
          if (dword_10008FA20)
          {
            uint64_t v60 = ne_log_obj();
            uint64_t v18 = v77;
            int v27 = (sockaddr *)v85;
            if (os_log_type_enabled(v60, OS_LOG_TYPE_ERROR)) {
              sub_10005D93C();
            }
            goto LABEL_117;
          }
          goto LABEL_160;
        }
        if ((sub_1000261F4(v81, *((void *)v20 + 1)) & 0x80000000) != 0)
        {
          if (dword_10008FA20)
          {
            int v63 = ne_log_obj();
            uint64_t v18 = v77;
            int v27 = (sockaddr *)v85;
            if (os_log_type_enabled(v63, OS_LOG_TYPE_ERROR)) {
              sub_10005D908();
            }
            goto LABEL_117;
          }
          goto LABEL_160;
        }
        goto LABEL_89;
      case 4u:
        if ((sub_1000261F4((size_t **)(a1 + 176), *((void *)v20 + 1)) & 0x80000000) == 0) {
          goto LABEL_89;
        }
        if (!dword_10008FA20) {
          goto LABEL_160;
        }
        int v61 = ne_log_obj();
        uint64_t v18 = v77;
        int v27 = (sockaddr *)v85;
        if (os_log_type_enabled(v61, OS_LOG_TYPE_ERROR)) {
          sub_10005D9A4();
        }
        goto LABEL_117;
      case 5u:
        if (!*v79)
        {
          if ((sub_1000261F4(v79, *((void *)v20 + 1)) & 0x80000000) == 0)
          {
            ++v37;
            goto LABEL_89;
          }
          if (!dword_10008FA20) {
            goto LABEL_160;
          }
          char v67 = ne_log_obj();
          uint64_t v18 = v77;
          int v27 = (sockaddr *)v85;
          if (os_log_type_enabled(v67, OS_LOG_TYPE_ERROR)) {
            sub_10005D9D8();
          }
LABEL_117:
          uint64_t v26 = (sockaddr *)v83;
          goto LABEL_162;
        }
        if (*v82)
        {
          if (dword_10008C2C8 >= 3) {
            sub_100033908(3, (*v82)[1], **v82, "received too many ID payloads", v39, v40, v41, v42, (char)v91);
          }
          uint64_t v7 = 18;
          goto LABEL_160;
        }
        if (v37) {
          BOOL v47 = 1;
        }
        else {
          BOOL v47 = dword_10008FA20 == 0;
        }
        if (!v47)
        {
          uint64_t v48 = ne_log_obj();
          if (os_log_type_enabled(v48, OS_LOG_TYPE_ERROR)) {
            sub_10005DA40(&v88, v89, v48);
          }
        }
        if ((sub_1000261F4(v82, *((void *)v20 + 1)) & 0x80000000) == 0)
        {
LABEL_89:
          int v49 = v20[16];
          v20 += 16;
          uint64_t v50 = *((int *)v20 - 3);
          v36 += v50;
          v38 += v50;
          if (!v49) {
            goto LABEL_99;
          }
          continue;
        }
        if (dword_10008FA20)
        {
          __int16 v66 = ne_log_obj();
          uint64_t v18 = v77;
          int v27 = (sockaddr *)v85;
          if (os_log_type_enabled(v66, OS_LOG_TYPE_ERROR)) {
            sub_10005DA0C();
          }
          goto LABEL_117;
        }
LABEL_160:
        uint64_t v18 = v77;
LABEL_161:
        uint64_t v26 = (sockaddr *)v83;
        int v27 = (sockaddr *)v85;
LABEL_162:
        sub_10003FA78(v78);
LABEL_163:
        sub_10003FA78(v16);
        sub_10003FA78(v18);
        if (v27) {
          free(v27);
        }
        if (v26) {
          free(v26);
        }
        if (v7) {
          goto LABEL_10;
        }
        return v7;
      case 0xAu:
        if ((sub_1000261F4(v80, *((void *)v20 + 1)) & 0x80000000) == 0) {
          goto LABEL_89;
        }
        if (!dword_10008FA20) {
          goto LABEL_160;
        }
        uint64_t v62 = ne_log_obj();
        uint64_t v18 = v77;
        int v27 = (sockaddr *)v85;
        if (os_log_type_enabled(v62, OS_LOG_TYPE_ERROR)) {
          sub_10005D970();
        }
        goto LABEL_117;
      case 0xBu:
        sub_10001B9A8(*((void *)v20 + 1), a1);
        goto LABEL_89;
      default:
        goto LABEL_139;
    }
  }
}

uint64_t sub_10001ED90(uint64_t *a1)
{
  uint64_t v2 = a1[24];
  if (v2)
  {
    int v3 = sub_10003FAC0(v2);
  }
  else
  {
    int v4 = *(unsigned __int8 *)(*a1 + 1);
    if (v4 == 2)
    {
      unsigned int v5 = 32;
    }
    else
    {
      if (v4 != 30)
      {
        if (dword_10008FA20)
        {
          uint64_t v13 = ne_log_obj();
          if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR)) {
            sub_100059DD8();
          }
        }
        return 0xFFFFFFFFLL;
      }
      unsigned int v5 = 128;
    }
    int v3 = sub_10001026C(*a1, v5, 255);
  }
  uint64_t v6 = v3;
  if (!v3)
  {
    if (dword_10008FA20)
    {
      uint64_t v9 = ne_log_obj();
      if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR)) {
        sub_10005DB10();
      }
    }
    return 0xFFFFFFFFLL;
  }
  uint64_t v7 = a1[25];
  if (v7)
  {
    uint64_t v8 = sub_10003FAC0(v7);
LABEL_22:
    int v14 = v8;
    if (v8)
    {
      uint64_t v15 = (void *)sub_10003A168((uint64_t)v6, (uint64_t)v8, *(void *)(a1[32] + 320), 0);
      BOOL v16 = v15;
      a1[14] = (uint64_t)v15;
      uint64_t v17 = a1 + 14;
      if (v15)
      {
        if (*v15) {
          goto LABEL_65;
        }
        uint64_t v18 = a1[34];
        if (!v18 || (*(_WORD *)(v18 + 264) & 0x400) == 0) {
          goto LABEL_65;
        }
      }
      uint64_t v19 = a1[32];
      if ((*(unsigned char *)(v19 + 96) & 2) != 0 && *(void *)(qword_10008F848 + 296))
      {
        uint64_t v15 = (void *)sub_10003A168((uint64_t)v6, (uint64_t)v14, *(void *)(v19 + 320), 1);
        *uint64_t v17 = (uint64_t)v15;
      }
      if (v15 && dword_10008FA20)
      {
        int v20 = ne_log_obj();
        if (os_log_type_enabled(v20, OS_LOG_TYPE_DEBUG)) {
          sub_10005DCC4();
        }
        uint64_t v15 = (void *)*v17;
      }
      if (v15)
      {
        if (*v15) {
          goto LABEL_65;
        }
        uint64_t v21 = a1[34];
        if (!v21 || (*(_WORD *)(v21 + 264) & 0x400) == 0) {
          goto LABEL_65;
        }
      }
      sub_10004EDDC((uint64_t)a1);
      uint64_t v28 = (void *)a1[14];
      if (v28 && dword_10008FA20)
      {
        int v29 = ne_log_obj();
        if (os_log_type_enabled(v29, OS_LOG_TYPE_DEBUG)) {
          sub_10005DC90();
        }
        uint64_t v28 = (void *)*v17;
      }
      if (v28 && *v28) {
        goto LABEL_65;
      }
      if (a1[25])
      {
        if (dword_10008FA20)
        {
          unsigned int v30 = ne_log_obj();
          if (os_log_type_enabled(v30, OS_LOG_TYPE_DEBUG)) {
            sub_10005DC5C();
          }
        }
        uint64_t v31 = sub_10003A34C(a1[25], *(void *)(a1[32] + 320), v22, v23, v24, v25, v26, v27);
        a1[14] = v31;
        if (v31)
        {
          if (dword_10008FA20)
          {
            uint64_t v32 = ne_log_obj();
            if (os_log_type_enabled(v32, OS_LOG_TYPE_DEBUG)) {
              sub_10005DC28();
            }
          }
          goto LABEL_65;
        }
      }
      else if (v28)
      {
        goto LABEL_65;
      }
      if (!v16)
      {
        if (dword_10008FA20)
        {
          uint64_t v40 = ne_log_obj();
          if (os_log_type_enabled(v40, OS_LOG_TYPE_ERROR)) {
            sub_10005D838();
          }
        }
        goto LABEL_70;
      }
      *uint64_t v17 = (uint64_t)v16;
LABEL_65:
      sub_10003A7A8(*v17);
      uint64_t v36 = *(void *)(*v17 + 16);
      if (!v36 || !sub_100046B44(a1[32], (char **)(v36 + 8), 1))
      {
        if (dword_10008FA20)
        {
          int v38 = ne_log_obj();
          if (os_log_type_enabled(v38, OS_LOG_TYPE_DEBUG)) {
            sub_10005DB78((uint64_t **)v17);
          }
        }
        uint64_t v35 = 0;
        goto LABEL_75;
      }
      if (dword_10008FA20)
      {
        int v37 = ne_log_obj();
        if (os_log_type_enabled(v37, OS_LOG_TYPE_ERROR)) {
          sub_10005DBF4();
        }
      }
LABEL_70:
      uint64_t v35 = 0xFFFFFFFFLL;
LABEL_75:
      sub_10003FA78(v6);
      sub_10003FA78(v14);
      return v35;
    }
    if (dword_10008FA20)
    {
      uint64_t v33 = ne_log_obj();
      if (os_log_type_enabled(v33, OS_LOG_TYPE_ERROR)) {
        sub_10005DB44();
      }
    }
    goto LABEL_60;
  }
  uint64_t v10 = a1[1];
  int v11 = *(unsigned __int8 *)(v10 + 1);
  if (v11 == 2)
  {
    unsigned int v12 = 32;
    goto LABEL_21;
  }
  if (v11 == 30)
  {
    unsigned int v12 = 128;
LABEL_21:
    uint64_t v8 = sub_10001026C(v10, v12, 255);
    goto LABEL_22;
  }
  if (dword_10008FA20)
  {
    uint64_t v34 = ne_log_obj();
    if (os_log_type_enabled(v34, OS_LOG_TYPE_ERROR)) {
      sub_100059DD8();
    }
  }
LABEL_60:
  sub_10003FA78(v6);
  return 0xFFFFFFFFLL;
}

uint64_t sub_10001F198(uint64_t a1)
{
  uint64_t result = sub_100020574(a1, 0);
  if (result == -2 || !result) {
    return result;
  }
  if ((*(unsigned char *)(*(void *)(a1 + 256) + 96) & 2) == 0 || !*(void *)(qword_10008F848 + 296))
  {
    uint64_t v3 = *(void *)(a1 + 272);
    if (!v3 || (*(_WORD *)(v3 + 264) & 0x400) == 0) {
      return result;
    }
    goto LABEL_10;
  }
  uint64_t v3 = *(void *)(a1 + 272);
  if (v3)
  {
LABEL_10:
    if ((*(_WORD *)(v3 + 264) & 0x400) != 0) {
      uint64_t result = sub_10004F034(a1);
    }
  }
  if (result != -2 && result)
  {
    return sub_100020574(a1, 1);
  }
  return result;
}

uint64_t sub_10001F248(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 56) != 6593)
  {
    if (dword_10008FA20)
    {
      unsigned int v5 = ne_log_obj();
      if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR)) {
        sub_10005AED8();
      }
    }
    return 0xFFFFFFFFLL;
  }
  sub_100002728((int *)(a1 + 56), 6640);
  if ((sub_10002F924(a1) & 0x80000000) != 0)
  {
    if (dword_10008FA20)
    {
      uint64_t v6 = ne_log_obj();
      if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR)) {
        sub_10005DCF8();
      }
    }
    return 0xFFFFFFFFLL;
  }
  if (dword_10008FA20)
  {
    uint64_t v2 = ne_log_obj();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEBUG)) {
      sub_10005CDFC();
    }
  }
  unsigned int v3 = sub_10003AA24(*(int *)(qword_10008F848 + 284), (uint64_t)sub_10002F7D4, a1);
  uint64_t result = 0;
  *(_DWORD *)(a1 + 64) = v3;
  return result;
}

uint64_t sub_10001F358(uint64_t a1, uint64_t a2)
{
  v71 = 0;
  int v72 = 0;
  int v70 = 0;
  if (a2)
  {
    if (dword_10008FA20)
    {
      uint64_t v2 = ne_log_obj();
      if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR)) {
        sub_10005DF00();
      }
    }
    goto LABEL_107;
  }
  int v4 = (int *)(a1 + 56);
  if (*(_DWORD *)(a1 + 56) != 6608)
  {
    if (dword_10008FA20)
    {
      uint64_t v13 = ne_log_obj();
      if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR)) {
        sub_10005AED8();
      }
    }
    goto LABEL_107;
  }
  if ((sub_10000CE98(a1) & 0x80000000) != 0)
  {
    if (dword_10008FA20)
    {
      int v14 = ne_log_obj();
      if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR)) {
        sub_10005DD2C();
      }
    }
    goto LABEL_107;
  }
  unsigned int v5 = sub_10000601C(*(_DWORD *)(*(void *)(*(void *)(a1 + 256) + 64) + 140));
  *(void *)(a1 + 208) = v5;
  if (!v5)
  {
    if (dword_10008FA20)
    {
      uint64_t v15 = ne_log_obj();
      if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR)) {
        sub_10005ACD8();
      }
    }
    goto LABEL_107;
  }
  int v6 = *(_DWORD *)(*(void *)(a1 + 128) + 20);
  uint64_t v7 = *(void *)(a1 + 176);
  if (v7 && v6)
  {
    if ((sub_100029A30(*(_DWORD *)(*(void *)(a1 + 128) + 20), a1 + 152) & 0x80000000) != 0)
    {
      if (dword_10008FA20)
      {
        uint64_t v54 = ne_log_obj();
        if (os_log_type_enabled(v54, OS_LOG_TYPE_ERROR)) {
          sub_10005DD60();
        }
      }
      goto LABEL_107;
    }
    if ((sub_10002972C(*(void *)(a1 + 152), (size_t **)(a1 + 168), (void *)(a1 + 144)) & 0x80000000) != 0)
    {
      if (dword_10008FA20)
      {
        long long v55 = ne_log_obj();
        if (os_log_type_enabled(v55, OS_LOG_TYPE_ERROR)) {
          sub_10005DD94();
        }
      }
      goto LABEL_107;
    }
    unsigned int v5 = *(void **)(a1 + 208);
    uint64_t v7 = *(void *)(a1 + 176);
  }
  uint64_t v8 = **(void **)(a1 + 232) + *v5 + 8;
  if (v7 && v6) {
    uint64_t v8 = **(void **)(a1 + 168) + (int)v8 + 4;
  }
  uint64_t v9 = *(_DWORD **)(a1 + 200);
  if (v9) {
    LODWORD(v8) = *v9 + **(_DWORD **)(a1 + 192) + v8 + 8;
  }
  if (sub_10000ECE4(*(void *)(a1 + 128)) && (*(unsigned char *)(*(void *)(a1 + 256) + 96) & 6) != 0)
  {
    int v10 = sub_10003FF90(a1, &v72, &v71);
    int v11 = v10;
    if (v10)
    {
      if (v10 == -1)
      {
        if (dword_10008FA20)
        {
          unsigned int v12 = ne_log_obj();
          if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR)) {
            sub_10005DECC();
          }
        }
        goto LABEL_107;
      }
      LODWORD(v8) = v8 + *(_DWORD *)v72 + *(_DWORD *)v71 + 8;
    }
  }
  else
  {
    int v11 = 0;
  }
  if (dword_10008FA20)
  {
    BOOL v16 = ne_log_obj();
    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG)) {
      sub_10005DE98();
    }
  }
  sub_100036F44(7, *(void *)(a1 + 128));
  uint64_t v17 = sub_10003F940((int)v8);
  if (!v17)
  {
    if (dword_10008FA20)
    {
      uint64_t v21 = ne_log_obj();
      if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR)) {
        sub_10005CB90();
      }
    }
    goto LABEL_107;
  }
  uint64_t v18 = (uint64_t)v17;
  uint64_t v19 = sub_1000263E0(v17[1], *(uint64_t **)(a1 + 232), 10);
  int v70 = v19;
  if (*(void *)(a1 + 176) && v6)
  {
    int v20 = 4;
  }
  else if (*(void *)(a1 + 200))
  {
    int v20 = 5;
  }
  else
  {
    int v20 = v11;
  }
  uint64_t v22 = sub_1000263E0((uint64_t)v19, *(uint64_t **)(a1 + 208), v20);
  uint64_t v23 = v22;
  if (*(void *)(a1 + 176) && v6)
  {
    int v70 = v22;
    if (*(void *)(a1 + 200)) {
      int v24 = 5;
    }
    else {
      int v24 = v11;
    }
    uint64_t v23 = sub_1000263E0((uint64_t)v22, *(uint64_t **)(a1 + 168), v24);
  }
  uint64_t v25 = *(uint64_t **)(a1 + 200);
  if (v25)
  {
    unsigned int v30 = sub_1000263E0((uint64_t)v23, v25, 5);
    if (dword_10008C2C8 >= 7) {
      sub_100033908(7, *(void *)(*(void *)(a1 + 200) + 8), **(void **)(a1 + 200), "sending IDci2:", v26, v27, v28, v29, v68);
    }
    int v70 = v30;
    uint64_t v23 = sub_1000263E0((uint64_t)v30, *(uint64_t **)(a1 + 192), v11);
    if (dword_10008C2C8 >= 7) {
      sub_100033908(7, *(void *)(*(void *)(a1 + 192) + 8), **(void **)(a1 + 192), "sending IDcr2:", v31, v32, v33, v34, v68);
    }
  }
  uint64_t v35 = *(void *)(a1 + 128);
  int v36 = *(_DWORD *)(v35 + 24);
  if ((v36 & 1) == 0)
  {
    if ((v36 & 2) == 0) {
      goto LABEL_72;
    }
    int v37 = 0;
    goto LABEL_65;
  }
  unsigned int v69 = bswap32(*(_DWORD *)(v35 + 8));
  int v38 = (void **)sub_100025F14(0, 1, 1u);
  if (!v38)
  {
    if (dword_10008FA20)
    {
      int v56 = ne_log_obj();
      if (os_log_type_enabled(v56, OS_LOG_TYPE_ERROR)) {
        sub_10005DDFC();
      }
    }
    goto LABEL_106;
  }
  uint64_t v39 = (void **)sub_100025E3C(v38, 2u, &v69, 4);
  if (!v39)
  {
    if (!dword_10008FA20) {
      goto LABEL_106;
    }
    uint64_t v59 = ne_log_obj();
    if (!os_log_type_enabled(v59, OS_LOG_TYPE_ERROR)) {
      goto LABEL_106;
    }
    goto LABEL_105;
  }
  int v37 = v39;
  if ((*(unsigned char *)(v35 + 24) & 2) != 0)
  {
LABEL_65:
    unsigned int v69 = bswap32(*(_DWORD *)(v35 + 16));
    uint64_t v40 = (void **)sub_100025F14(v37, 1, 2u);
    if (!v40)
    {
      if (dword_10008FA20)
      {
        uint64_t v58 = ne_log_obj();
        if (os_log_type_enabled(v58, OS_LOG_TYPE_ERROR)) {
          sub_10005DDFC();
        }
      }
      goto LABEL_106;
    }
    uint64_t v41 = (void **)sub_100025E3C(v40, 2u, &v69, 4);
    if (v41)
    {
      int v37 = v41;
      goto LABEL_68;
    }
    if (!dword_10008FA20 || (int v61 = ne_log_obj(), !os_log_type_enabled(v61, OS_LOG_TYPE_ERROR)))
    {
LABEL_106:
      sub_10003FA78((void *)v18);
LABEL_107:
      uint64_t v62 = 0xFFFFFFFFLL;
      goto LABEL_108;
    }
LABEL_105:
    sub_10005DE30();
    goto LABEL_106;
  }
LABEL_68:
  uint64_t v42 = *(void *)(v35 + 32);
  if (v42)
  {
    while (1)
    {
      int v43 = sub_10001AF94((void **)v18, &v70, 0x6000u, (_DWORD *)v42, (uint64_t)v37);
      if (!v43) {
        break;
      }
      uint64_t v18 = (uint64_t)v43;
      uint64_t v42 = *(void *)(v42 + 72);
      if (!v42) {
        goto LABEL_71;
      }
    }
    if (dword_10008FA20)
    {
      unint64_t v64 = ne_log_obj();
      if (os_log_type_enabled(v64, OS_LOG_TYPE_ERROR)) {
        sub_10005DE64();
      }
    }
    uint64_t v62 = 0xFFFFFFFFLL;
    goto LABEL_111;
  }
LABEL_71:
  sub_10003FA78(v37);
LABEL_72:
  if (v11)
  {
    BOOL v44 = sub_1000263E0((uint64_t)v23, (uint64_t *)v72, v11);
    sub_1000263E0((uint64_t)v44, (uint64_t *)v71, 0);
  }
  unsigned int v45 = sub_10003F940(*(void *)v18 + **(void **)(a1 + 216));
  if (!v45)
  {
    if (dword_10008FA20)
    {
      uint64_t v57 = ne_log_obj();
      if (os_log_type_enabled(v57, OS_LOG_TYPE_ERROR)) {
        sub_10005D09C();
      }
    }
    goto LABEL_106;
  }
  uint64_t v46 = v45;
  memcpy((void *)v45[1], *(const void **)(*(void *)(a1 + 216) + 8), **(void **)(a1 + 216));
  memcpy((void *)(v46[1] + **(void **)(a1 + 216)), *(const void **)(v18 + 8), *(void *)v18);
  BOOL v47 = (uint64_t *)sub_10002A314(*(void *)(a1 + 256), *(_DWORD *)(a1 + 108), (uint64_t)v46);
  sub_10003FA78(v46);
  if (!v47)
  {
    if (dword_10008FA20)
    {
      uint64_t v60 = ne_log_obj();
      if (os_log_type_enabled(v60, OS_LOG_TYPE_ERROR)) {
        sub_10005CE98();
      }
    }
    goto LABEL_106;
  }
  uint64_t v48 = sub_10001CBBC(a1, v18, v47);
  *(void *)(a1 + 80) = v48;
  if (!v48)
  {
    if (dword_10008FA20)
    {
      char v65 = ne_log_obj();
      if (os_log_type_enabled(v65, OS_LOG_TYPE_ERROR)) {
        sub_10005DDC8();
      }
    }
    goto LABEL_129;
  }
  *(_DWORD *)(a1 + 72) = *(_DWORD *)(*(void *)(*(void *)(a1 + 256) + 64) + 200);
  if (sub_1000246C0(a1) == -1)
  {
    if (dword_10008FA20)
    {
      __int16 v66 = ne_log_obj();
      if (os_log_type_enabled(v66, OS_LOG_TYPE_ERROR)) {
        sub_10005AD0C();
      }
    }
    goto LABEL_129;
  }
  unint64_t v49 = *(void *)(a1 + 256);
  uint64_t v50 = *(void *)(v49 + 48);
  uint64_t v51 = *(void *)(v49 + 56);
  long long v52 = *(void **)(a1 + 80);
  if (*(_DWORD *)(v49 + 100) && *v52 >= 0x501uLL)
  {
    uint64_t v53 = 0;
    LODWORD(v49) = *(_DWORD *)(v49 + 96);
  }
  else
  {
    unint64_t v49 = *(unsigned int *)(v49 + 96);
    uint64_t v53 = (v49 >> 3) & 4;
  }
  if (sub_100009070(v50, v51, (uint64_t)v52, *(void *)(a1 + 88), v53, (v49 >> 5) & 1) == -1)
  {
    if (dword_10008FA20)
    {
      char v67 = ne_log_obj();
      if (os_log_type_enabled(v67, OS_LOG_TYPE_ERROR)) {
        sub_10005B794();
      }
    }
LABEL_129:
    uint64_t v62 = 0xFFFFFFFFLL;
    goto LABEL_130;
  }
  sub_100002728(v4, 6626);
  uint64_t v62 = 0;
LABEL_130:
  sub_10003FA78((void *)v18);
  sub_10003FA78(v47);
LABEL_108:
  if (v72) {
    sub_10003FA78(v72);
  }
  int v37 = (void **)v71;
  if (v71) {
LABEL_111:
  }
    sub_10003FA78(v37);
  return v62;
}

uint64_t sub_10001FB3C(uint64_t a1, void *a2)
{
  uint64_t v2 = (int *)(a1 + 56);
  if (*(_DWORD *)(a1 + 56) != 6626)
  {
    if (dword_10008FA20)
    {
      int v4 = ne_log_obj();
      if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR)) {
        sub_10005AED8();
      }
    }
    return 0xFFFFFFFFLL;
  }
  if ((*(unsigned char *)(a2[1] + 19) & 1) == 0)
  {
    if (dword_10008FA20)
    {
      unsigned int v3 = ne_log_obj();
      if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR)) {
        sub_10005CFD0();
      }
    }
    return 0xFFFFFFFFLL;
  }
  uint64_t v8 = sub_10002E028(*(void *)(a1 + 256), a2, **(void **)(a1 + 240), *(void *)(*(void *)(a1 + 240) + 8));
  if (!v8)
  {
    if (dword_10008FA20)
    {
      int v20 = ne_log_obj();
      if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR)) {
        sub_10005D590();
      }
    }
    return 0xFFFFFFFFLL;
  }
  uint64_t v9 = v8;
  int v10 = sub_100022FA8((uint64_t)v8);
  if (!v10)
  {
    if (dword_10008FA20)
    {
      uint64_t v21 = ne_log_obj();
      if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR)) {
        sub_10005D5C4();
      }
    }
    uint64_t v5 = 0xFFFFFFFFLL;
    goto LABEL_49;
  }
  int v11 = v10;
  uint64_t v12 = 0;
  for (uint64_t i = (unsigned __int8 *)v10[1]; ; i += 16)
  {
    int v14 = *i;
    if (v14 != 8) {
      break;
    }
    uint64_t v12 = *((void *)i + 1);
LABEL_18:
    ;
  }
  if (v14 == 11)
  {
    sub_10001B9A8(*((void *)i + 1), a1);
    goto LABEL_18;
  }
  if (*i)
  {
    if (dword_10008FA20)
    {
      uint64_t v22 = ne_log_obj();
      if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR)) {
        sub_10005BF70();
      }
    }
    goto LABEL_47;
  }
  if (!v12)
  {
    if (dword_10008FA20)
    {
      uint64_t v23 = ne_log_obj();
      if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR)) {
        sub_10005B014();
      }
    }
    goto LABEL_47;
  }
  uint64_t v15 = sub_10003F940(**(void **)(a1 + 208) + **(void **)(a1 + 216));
  if (!v15)
  {
    if (dword_10008FA20)
    {
      int v24 = ne_log_obj();
      if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR)) {
        sub_10005D09C();
      }
    }
    goto LABEL_47;
  }
  BOOL v16 = v15;
  memcpy((void *)v15[1], *(const void **)(*(void *)(a1 + 216) + 8), **(void **)(a1 + 216));
  memcpy((void *)(v16[1] + **(void **)(a1 + 216)), *(const void **)(*(void *)(a1 + 208) + 8), **(void **)(a1 + 208));
  uint64_t v17 = sub_10002A230(*(void *)(a1 + 256), *(_DWORD *)(a1 + 108), (uint64_t)v16);
  sub_10003FA78(v16);
  if (!v17)
  {
    if (dword_10008FA20)
    {
      uint64_t v25 = ne_log_obj();
      if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR)) {
        sub_10005D5F8();
      }
    }
LABEL_47:
    uint64_t v5 = 0xFFFFFFFFLL;
    goto LABEL_48;
  }
  int v18 = timingsafe_bcmp(*(const void **)(v17 + 8), (const void *)(v12 + 4), *(void *)v17);
  sub_10003FA78((void *)v17);
  if (v18)
  {
    if (dword_10008FA20)
    {
      uint64_t v19 = ne_log_obj();
      if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR)) {
        sub_10005DF34();
      }
    }
    uint64_t v5 = 23;
  }
  else
  {
    if ((*(unsigned char *)(a1 + 105) & 2) != 0) {
      int v26 = 6595;
    }
    else {
      int v26 = 6596;
    }
    sub_100002728(v2, v26);
    uint64_t v5 = 0;
  }
LABEL_48:
  sub_10003FA78(v11);
LABEL_49:
  sub_10003FA78(v9);
  return v5;
}

uint64_t sub_10001FE88(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = (int *)(a1 + 56);
  if (*(_DWORD *)(a1 + 56) == 6595)
  {
    if (dword_10008FA20)
    {
      uint64_t v5 = ne_log_obj();
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG)) {
        sub_10005DF9C();
      }
    }
    signed int v6 = *(_DWORD *)(*(void *)(*(void *)(a1 + 128) + 32) + 8) + 12;
    uint64_t v7 = sub_10003F940(v6);
    if (v7)
    {
      uint64_t v8 = (uint64_t)v7;
      uint64_t v9 = v7[1];
      *(unsigned char *)uint64_t v9 = 0;
      *(_WORD *)(v9 + 2) = bswap32(v6) >> 16;
      *(_DWORD *)(v9 + 4) = 0x1000000;
      uint64_t v10 = *(void *)(*(void *)(a1 + 128) + 32);
      *(unsigned char *)(v9 + 8) = *(_DWORD *)v10;
      *(unsigned char *)(v9 + 9) = 8;
      *(_WORD *)(v9 + 10) = 64;
      memcpy((void *)(v9 + 12), (const void *)(v10 + 24), *(void *)(v10 + 8));
      int v11 = (uint64_t *)sub_10002A314(*(void *)(a1 + 256), *(_DWORD *)(a1 + 108), v8);
      if (!v11)
      {
        if (dword_10008FA20)
        {
          int v26 = ne_log_obj();
          if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR)) {
            sub_10005CE98();
          }
        }
        uint64_t v25 = 0xFFFFFFFFLL;
        goto LABEL_47;
      }
      uint64_t v12 = v11;
      uint64_t v13 = sub_10003F940(*(_DWORD *)v11 + *(_DWORD *)v8 + 32);
      if (!v13)
      {
        if (dword_10008FA20)
        {
          uint64_t v27 = ne_log_obj();
          if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR)) {
            sub_10005CB90();
          }
        }
        uint64_t v25 = 0xFFFFFFFFLL;
        goto LABEL_46;
      }
      int v14 = v13;
      uint64_t v15 = sub_1000263C8((uint64_t)v13, a1, 8);
      if (v15)
      {
        BOOL v16 = sub_1000263E0(v15, v12, 11);
        memcpy(v16, *(const void **)(v8 + 8), *(void *)v8);
        uint64_t v17 = sub_10002E41C(*(void *)(a1 + 256), (uint64_t)v14, *(void *)(*(void *)(a1 + 240) + 8), **(void **)(a1 + 240));
        *(void *)(a1 + 80) = v17;
        if (v17)
        {
          if ((sub_100023E30(*(void *)(a1 + 256), v17) & 0x80000000) != 0)
          {
            if (dword_10008FA20)
            {
              unsigned int v30 = ne_log_obj();
              if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR)) {
                sub_10005AD0C();
              }
            }
          }
          else
          {
            unint64_t v18 = *(void *)(a1 + 256);
            uint64_t v19 = *(void *)(v18 + 48);
            uint64_t v20 = *(void *)(v18 + 56);
            uint64_t v21 = *(void **)(a1 + 80);
            if (*(_DWORD *)(v18 + 100) && *v21 >= 0x501uLL)
            {
              uint64_t v22 = 0;
              LODWORD(v18) = *(_DWORD *)(v18 + 96);
            }
            else
            {
              unint64_t v18 = *(unsigned int *)(v18 + 96);
              uint64_t v22 = (v18 >> 3) & 4;
            }
            if (sub_100009070(v19, v20, (uint64_t)v21, a2, v22, (v18 >> 5) & 1) != -1)
            {
              sub_100002728(v2, 6596);
              uint64_t v25 = 0;
LABEL_45:
              sub_10003FA78(v14);
LABEL_46:
              sub_10003FA78(v12);
LABEL_47:
              sub_10003FA78((void *)v8);
              return v25;
            }
            if (dword_10008FA20)
            {
              uint64_t v31 = ne_log_obj();
              if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR)) {
                sub_10005B794();
              }
            }
          }
        }
        else if (dword_10008FA20)
        {
          uint64_t v29 = ne_log_obj();
          if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR)) {
            sub_10005CBC4();
          }
        }
      }
      else if (dword_10008FA20)
      {
        uint64_t v28 = ne_log_obj();
        if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR)) {
          sub_10005DF68();
        }
      }
      uint64_t v25 = 0xFFFFFFFFLL;
      goto LABEL_45;
    }
    if (dword_10008FA20)
    {
      int v24 = ne_log_obj();
      if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR)) {
        sub_10005D660();
      }
    }
  }
  else if (dword_10008FA20)
  {
    uint64_t v23 = ne_log_obj();
    if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR)) {
      sub_10005AED8();
    }
  }
  return 0xFFFFFFFFLL;
}

uint64_t sub_1000201D4(uint64_t a1)
{
  uint64_t v1 = (int *)(a1 + 56);
  if (*(_DWORD *)(a1 + 56) != 6596)
  {
    if (dword_10008FA20)
    {
      int v4 = ne_log_obj();
      if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR)) {
        sub_10005AED8();
      }
    }
    return 0xFFFFFFFFLL;
  }
  if ((sub_100029C94(a1, 1) & 0x80000000) != 0)
  {
    if (dword_10008FA20)
    {
      uint64_t v5 = ne_log_obj();
      if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR)) {
        sub_10005DFD0();
      }
    }
    return 0xFFFFFFFFLL;
  }
  sub_100002728(v1, 6600);
  *(unsigned char *)(a1 + 105) ^= 2u;
  if (dword_10008F858) {
    return 0;
  }
  if (dword_10008FA20)
  {
    signed int v6 = ne_log_obj();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG)) {
      sub_10005D4F4();
    }
  }
  if ((sub_10002FD58(a1) & 0x80000000) != 0)
  {
    if (dword_10008FA20)
    {
      uint64_t v15 = ne_log_obj();
      if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR)) {
        sub_10005D424();
      }
    }
    return 0xFFFFFFFFLL;
  }
  if (dword_10008FA20)
  {
    uint64_t v7 = ne_log_obj();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG)) {
      sub_10005D4C0();
    }
  }
  if ((sub_100030134(a1) & 0x80000000) != 0)
  {
    if (dword_10008FA20)
    {
      BOOL v16 = ne_log_obj();
      if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR)) {
        sub_10005D458();
      }
    }
    return 0xFFFFFFFFLL;
  }
  if (dword_10008FA20)
  {
    uint64_t v8 = ne_log_obj();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG)) {
      sub_10005D48C();
    }
  }
  if (!*(void *)(a1 + 136)) {
    return 0;
  }
  uint64_t v9 = *(void *)a1;
  uint64_t v10 = *(void *)(a1 + 8);
  *(void *)a1 = v10;
  *(void *)(a1 + 8) = v9;
  if ((sub_100030510(a1) & 0x80000000) != 0)
  {
    if (dword_10008FA20)
    {
      uint64_t v17 = ne_log_obj();
      if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR)) {
        sub_10005E004();
      }
    }
    return 0xFFFFFFFFLL;
  }
  if (dword_10008FA20)
  {
    int v11 = ne_log_obj();
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG)) {
      sub_10005E0A0();
    }
  }
  uint64_t v12 = *(void *)(a1 + 136);
  *(void *)a1 = v9;
  *(void *)(a1 + 8) = v10;
  *(unsigned char *)uint64_t v12 = 2;
  long long v23 = *(_OWORD *)(v12 + 72);
  long long v24 = *(_OWORD *)(v12 + 88);
  long long v25 = *(_OWORD *)(v12 + 104);
  long long v26 = *(_OWORD *)(v12 + 120);
  long long v19 = *(_OWORD *)(v12 + 8);
  long long v20 = *(_OWORD *)(v12 + 24);
  long long v21 = *(_OWORD *)(v12 + 40);
  long long v22 = *(_OWORD *)(v12 + 56);
  *(_OWORD *)(v12 + 8) = *(_OWORD *)(v12 + 136);
  *(_OWORD *)(v12 + 24) = *(_OWORD *)(v12 + 152);
  *(_OWORD *)(v12 + 40) = *(_OWORD *)(v12 + 168);
  *(_OWORD *)(v12 + 120) = *(_OWORD *)(v12 + 248);
  *(_OWORD *)(v12 + 104) = *(_OWORD *)(v12 + 232);
  *(_OWORD *)(v12 + 88) = *(_OWORD *)(v12 + 216);
  *(_OWORD *)(v12 + 72) = *(_OWORD *)(v12 + 200);
  *(_OWORD *)(v12 + 56) = *(_OWORD *)(v12 + 184);
  *(_OWORD *)(v12 + 184) = v22;
  *(_OWORD *)(v12 + 168) = v21;
  *(_OWORD *)(v12 + 152) = v20;
  *(_OWORD *)(v12 + 136) = v19;
  *(_OWORD *)(v12 + 248) = v26;
  *(_OWORD *)(v12 + 232) = v25;
  *(_OWORD *)(v12 + 216) = v24;
  *(_OWORD *)(v12 + 200) = v23;
  char v13 = *(unsigned char *)(v12 + 264);
  *(unsigned char *)(v12 + 264) = *(unsigned char *)(v12 + 265);
  *(unsigned char *)(v12 + 265) = v13;
  if ((sub_100030510(a1) & 0x80000000) != 0)
  {
    if (dword_10008FA20)
    {
      unint64_t v18 = ne_log_obj();
      if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR)) {
        sub_10005E038();
      }
    }
    return 0xFFFFFFFFLL;
  }
  if (dword_10008FA20)
  {
    int v14 = ne_log_obj();
    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG)) {
      sub_10005E06C();
    }
  }
  sub_1000351A8(*(void **)(a1 + 136));
  free(*(void **)(a1 + 136));
  uint64_t result = 0;
  *(void *)(a1 + 136) = 0;
  *(_DWORD *)(a1 + 248) = 1;
  return result;
}

uint64_t sub_100020574(uint64_t a1, int a2)
{
  memset(__src, 0, sizeof(__src));
  uint64_t v4 = *(void *)(a1 + 192);
  if (*(void *)(a1 + 200))
  {
    if (v4)
    {
LABEL_3:
      if (!a2 && (*(void *)(a1 + 32) || *(void *)(a1 + 40)))
      {
        if (dword_10008FA20)
        {
          int v14 = ne_log_obj();
          if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR)) {
            sub_10005E4C0();
          }
        }
        return 0xFFFFFFFFLL;
      }
      if (dword_10008FA20)
      {
        uint64_t v5 = ne_log_obj();
        if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG)) {
          sub_10005E434(a2, v5);
        }
      }
      memset(__src, 0, sizeof(__src));
      LOBYTE(__src[0]) = 1;
      if (!a2
        && (uint64_t v6 = *(void *)(a1 + 192)) != 0
        && (unsigned int v7 = **(unsigned __int8 **)(v6 + 8), v7 <= 6)
        && ((1 << v7) & 0x72) != 0)
      {
        uint64_t result = sub_100010604((unint64_t *)v6, (uint64_t)&__src[8] + 8, (unsigned char *)&__src[16] + 9, (__int16 *)&__src[16] + 5, *(unsigned __int8 *)(a1 + 61));
        if (result) {
          return result;
        }
        int v9 = **(unsigned __int8 **)(*(void *)(a1 + 192) + 8);
        if (v9 == 5)
        {
          uint64_t result = sub_1000270E0((uint64_t)&__src[8] + 8, *(void *)a1);
          if (result) {
            return result;
          }
          int v9 = **(unsigned __int8 **)(*(void *)(a1 + 192) + 8);
        }
        if (v9 == 5) {
          int v10 = 5;
        }
        else {
          int v10 = 0;
        }
        if (v9 == 1) {
          int v11 = 1;
        }
        else {
          int v11 = v10;
        }
      }
      else
      {
        if (dword_10008FA20)
        {
          char v13 = ne_log_obj();
          if (os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG)) {
            sub_10005E400();
          }
        }
        __memcpy_chk();
        if (BYTE9(__src[8]) == 30)
        {
          int v11 = 0;
          BYTE9(__src[16]) = 0x80;
          if (a2) {
            goto LABEL_55;
          }
        }
        else if (BYTE9(__src[8]) == 2)
        {
          int v11 = 0;
          BYTE9(__src[16]) = 32;
          WORD5(__src[8]) = 0;
          if (a2) {
            goto LABEL_55;
          }
        }
        else
        {
          int v11 = 0;
          BYTE9(__src[16]) = 0;
          if (a2) {
            goto LABEL_55;
          }
        }
      }
      uint64_t v15 = *(void *)(a1 + 200);
      if (v15)
      {
        unsigned int v16 = **(unsigned __int8 **)(v15 + 8);
        if (v16 <= 6 && ((1 << v16) & 0x72) != 0)
        {
          uint64_t result = sub_100010604((unint64_t *)v15, (uint64_t)__src + 8, (unsigned char *)&__src[16] + 8, (__int16 *)&__src[16] + 5, *(unsigned __int8 *)(a1 + 61));
          if (result) {
            return result;
          }
          int v17 = **(unsigned __int8 **)(*(void *)(a1 + 200) + 8);
          if (v17 == 5)
          {
            uint64_t result = sub_1000270E0((uint64_t)__src + 8, *(void *)(a1 + 8));
            if (result) {
              return result;
            }
            int v17 = **(unsigned __int8 **)(*(void *)(a1 + 200) + 8);
          }
          if (v11 == v17 && BYTE9(__src[8]) == BYTE9(__src[0]))
          {
            unint64_t v18 = sub_10003CC74();
            *(void *)(a1 + 32) = v18;
            if (!v18)
            {
              if (!dword_10008FA20) {
                return 0xFFFFFFFFLL;
              }
              uint64_t v39 = ne_log_obj();
              if (!os_log_type_enabled(v39, OS_LOG_TYPE_ERROR)) {
                return 0xFFFFFFFFLL;
              }
LABEL_113:
              sub_10005E14C();
              return 0xFFFFFFFFLL;
            }
            long long v19 = sub_10003CC74();
            *(void *)(a1 + 40) = v19;
            if (!v19)
            {
              if (!dword_10008FA20) {
                return 0xFFFFFFFFLL;
              }
              long long v20 = ne_log_obj();
              if (!os_log_type_enabled(v20, OS_LOG_TYPE_ERROR)) {
                return 0xFFFFFFFFLL;
              }
              goto LABEL_113;
            }
          }
LABEL_63:
          if (dword_10008FA20)
          {
            long long v22 = ne_log_obj();
            if (os_log_type_enabled(v22, OS_LOG_TYPE_DEBUG)) {
              sub_10005E338((uint64_t)__src);
            }
            if (dword_10008FA20)
            {
              long long v23 = ne_log_obj();
              if (os_log_type_enabled(v23, OS_LOG_TYPE_DEBUG)) {
                sub_10005E2A4((uint64_t)__src);
              }
            }
          }
          if (!WORD5(__src[16])) {
            WORD5(__src[16]) = 255;
          }
          uint64_t v24 = sub_1000349D4((unsigned __int8 *)__src, (unint64_t *)a1);
          uint64_t v25 = v24;
          if (v24)
          {
            if (*(_DWORD *)(v24 + 292) != 5)
            {
              int v29 = 1;
              goto LABEL_85;
            }
            if (*(_DWORD *)(*(void *)(*(void *)(a1 + 256) + 64) + 164))
            {
              if (!dword_10008FA20) {
                goto LABEL_82;
              }
              long long v26 = ne_log_obj();
              if (!os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT)) {
                goto LABEL_82;
              }
              *(_DWORD *)buf = 136315138;
              *(void *)&uint8_t buf[4] = sub_100035558((unsigned __int8 *)__src);
              uint64_t v27 = "Update the generated policy : %s\n";
LABEL_81:
              _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, v27, buf, 0xCu);
LABEL_82:
              uint64_t v28 = malloc_type_malloc(0x110uLL, 0x1000040DDC4BC7FuLL);
              *(void *)(a1 + 136) = v28;
              if (!v28)
              {
                if (dword_10008FA20)
                {
                  int v36 = ne_log_obj();
                  if (os_log_type_enabled(v36, OS_LOG_TYPE_ERROR)) {
                    sub_10005E14C();
                  }
                }
                return 0xFFFFFFFFLL;
              }
              memcpy(v28, __src, 0x110uLL);
              int v29 = 0;
LABEL_85:
              LOBYTE(__src[0]) = 2;
              long long v46 = *(_OWORD *)((char *)&__src[4] + 8);
              long long v47 = *(_OWORD *)((char *)&__src[5] + 8);
              long long v48 = *(_OWORD *)((char *)&__src[6] + 8);
              long long v49 = *(_OWORD *)((char *)&__src[7] + 8);
              *(_OWORD *)buf = *(_OWORD *)((char *)__src + 8);
              long long v43 = *(_OWORD *)((char *)&__src[1] + 8);
              long long v44 = *(_OWORD *)((char *)&__src[2] + 8);
              long long v45 = *(_OWORD *)((char *)&__src[3] + 8);
              *(_OWORD *)((char *)&__src[3] + 8) = *(_OWORD *)((char *)&__src[11] + 8);
              *(_OWORD *)((char *)&__src[2] + 8) = *(_OWORD *)((char *)&__src[10] + 8);
              *(_OWORD *)((char *)&__src[1] + 8) = *(_OWORD *)((char *)&__src[9] + 8);
              *(_OWORD *)((char *)&__src[7] + 8) = *(_OWORD *)((char *)&__src[15] + 8);
              *(_OWORD *)((char *)&__src[6] + 8) = *(_OWORD *)((char *)&__src[14] + 8);
              *(_OWORD *)((char *)&__src[5] + 8) = *(_OWORD *)((char *)&__src[13] + 8);
              *(_OWORD *)((char *)&__src[4] + 8) = *(_OWORD *)((char *)&__src[12] + 8);
              *(_OWORD *)((char *)__src + 8) = *(_OWORD *)((char *)&__src[8] + 8);
              *(_OWORD *)((char *)&__src[11] + 8) = v45;
              *(_OWORD *)((char *)&__src[10] + 8) = v44;
              *(_OWORD *)((char *)&__src[9] + 8) = v43;
              *(_OWORD *)((char *)&__src[8] + 8) = *(_OWORD *)buf;
              *(_OWORD *)((char *)&__src[15] + 8) = v49;
              *(_OWORD *)((char *)&__src[14] + 8) = v48;
              *(_OWORD *)((char *)&__src[13] + 8) = v47;
              *(_OWORD *)((char *)&__src[12] + 8) = v46;
              char v30 = BYTE8(__src[16]);
              BYTE8(__src[16]) = BYTE9(__src[16]);
              BYTE9(__src[16]) = v30;
              uint64_t v31 = sub_1000349D4((unsigned __int8 *)__src, (unint64_t *)a1);
              uint64_t v32 = v31;
              if (v31)
              {
                if (!*(_DWORD *)(a1 + 52)) {
                  *(_DWORD *)(a1 + 52) = *(_DWORD *)(v31 + 288);
                }
              }
              else
              {
                if (!dword_10008FA20) {
                  goto LABEL_96;
                }
                uint64_t v34 = ne_log_obj();
                if (os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT))
                {
                  int v40 = 136315138;
                  uint64_t v41 = sub_100035558((unsigned __int8 *)__src);
                  _os_log_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_DEFAULT, "no outbound policy found: %s\n", (uint8_t *)&v40, 0xCu);
                }
              }
              if (dword_10008FA20)
              {
                uint64_t v35 = ne_log_obj();
                if (os_log_type_enabled(v35, OS_LOG_TYPE_DEBUG))
                {
                  sub_10005E22C((unsigned __int8 *)__src);
                  if (v29)
                  {
LABEL_97:
                    if (*(_DWORD *)(v25 + 292) == 2)
                    {
                      if ((sub_1000379F4(a1, v25, v32) & 0x80000000) == 0) {
                        return 0;
                      }
                      if (dword_10008FA20)
                      {
                        int v38 = ne_log_obj();
                        if (os_log_type_enabled(v38, OS_LOG_TYPE_ERROR)) {
                          sub_10005E180();
                        }
                      }
                    }
                    else if (dword_10008FA20)
                    {
                      int v37 = ne_log_obj();
                      if (os_log_type_enabled(v37, OS_LOG_TYPE_ERROR)) {
                        sub_10005E1B4((unsigned __int8 *)__src);
                      }
                    }
                    return 0xFFFFFFFFLL;
                  }
                  return 4294967294;
                }
              }
LABEL_96:
              if (v29) {
                goto LABEL_97;
              }
              return 4294967294;
            }
          }
          else if (*(_DWORD *)(*(void *)(*(void *)(a1 + 256) + 64) + 164))
          {
            if (!dword_10008FA20) {
              goto LABEL_82;
            }
            long long v26 = ne_log_obj();
            if (!os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT)) {
              goto LABEL_82;
            }
            *(_DWORD *)buf = 136315138;
            *(void *)&uint8_t buf[4] = sub_100035558((unsigned __int8 *)__src);
            uint64_t v27 = "no policy found, try to generate the policy : %s\n";
            goto LABEL_81;
          }
          if (dword_10008FA20)
          {
            uint64_t v33 = ne_log_obj();
            if (os_log_type_enabled(v33, OS_LOG_TYPE_ERROR)) {
              sub_10005E0D4((unsigned __int8 *)__src);
            }
          }
          return 0xFFFFFFFFLL;
        }
      }
LABEL_55:
      if (dword_10008FA20)
      {
        long long v21 = ne_log_obj();
        if (os_log_type_enabled(v21, OS_LOG_TYPE_DEBUG)) {
          sub_10005E3CC();
        }
      }
      __memcpy_chk();
      if (BYTE9(__src[0]) == 30)
      {
        BYTE8(__src[16]) = 0x80;
      }
      else if (BYTE9(__src[0]) == 2)
      {
        BYTE8(__src[16]) = 32;
        WORD5(__src[0]) = 0;
      }
      else
      {
        BYTE8(__src[16]) = 0;
      }
      goto LABEL_63;
    }
  }
  else if (!v4)
  {
    goto LABEL_3;
  }
  if (dword_10008FA20)
  {
    uint64_t v12 = ne_log_obj();
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR)) {
      sub_10005E4F4();
    }
  }
  return 18;
}

uint64_t *sub_100020D74(uint64_t a1, const sockaddr *a2)
{
  return sub_10003CAE4(a2);
}

void sub_100020DD0(void *a1, uint64_t a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_debug_impl(a1, v9, OS_LOG_TYPE_DEBUG, a4, &a9, 0x18u);
}

void sub_100020DF0(int a1)
{
  memset(v50, 0, 28);
  memset(v49, 0, sizeof(v49));
  long long v47 = 0u;
  long long v48 = 0u;
  long long v45 = 0u;
  long long v46 = 0u;
  long long v43 = 0u;
  long long v44 = 0u;
  sockaddr v41 = (sockaddr)0;
  long long v42 = 0u;
  memset(v40, 0, sizeof(v40));
  socklen_t v35 = 128;
  unsigned int v34 = 128;
  if (xmmword_1000906E0 == 0)
  {
    while (1)
    {
      unsigned int v3 = sub_10003C050(a1, (uint64_t)v49, 0x40uLL, 2, &v41, &v35, (uint64_t)v40, &v34);
      if ((v3 & 0x80000000) == 0) {
        break;
      }
      if (*__error() != 4)
      {
        if (dword_10008FA20)
        {
          uint64_t v4 = ne_log_obj();
          if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
          {
LABEL_9:
            sub_10005E55C();
            return;
          }
        }
        return;
      }
    }
    if (v3 == 1 && LOBYTE(v49[0]) == 255)
    {
      if (recvfrom(a1, v49, 1uLL, 0, &v41, &v35) != 1)
      {
        if (dword_10008FA20)
        {
          uint64_t v5 = ne_log_obj();
          if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR)) {
            sub_10005E5DC();
          }
        }
      }
    }
    else
    {
      if (v49[1]) {
        BOOL v6 = v49[0] == 0;
      }
      else {
        BOOL v6 = 0;
      }
      if (v6) {
        uint64_t v7 = 4;
      }
      else {
        uint64_t v7 = 0;
      }
      v50[0] = *(_OWORD *)((unint64_t)v49 | v7);
      *(_OWORD *)((char *)v50 + 12) = *(_OWORD *)(((unint64_t)v49 | v7) + 0xC);
      if (v3 >= 0x1C && (unsigned int v8 = bswap32(DWORD2(v50[1])), v8 > 0x1B))
      {
        if (v8 < 0x10000)
        {
          char v13 = sub_10003F940(v8 + v7);
          if (v13)
          {
            int v14 = v13;
            while (1)
            {
              int v15 = sub_10003C050(a1, v14[1], *v14, 0, &v41, &v35, (uint64_t)v40, &v34);
              if ((v15 & 0x80000000) == 0) {
                break;
              }
              if (*__error() != 4)
              {
                if (dword_10008FA20)
                {
                  unsigned int v16 = ne_log_obj();
                  if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR)) {
                    sub_10005E55C();
                  }
                }
LABEL_76:
                int v29 = v14;
                goto LABEL_77;
              }
            }
            if (v15 < (int)v7)
            {
              if (dword_10008FA20)
              {
                long long v19 = ne_log_obj();
                if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR)) {
                  sub_10005E790();
                }
              }
              goto LABEL_76;
            }
            size_t v20 = v15 - v7;
            long long v21 = sub_10003F940(v20);
            if (!v21)
            {
              if (dword_10008FA20)
              {
                uint64_t v28 = ne_log_obj();
                if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR)) {
                  sub_10005E80C();
                }
              }
              goto LABEL_76;
            }
            long long v22 = v21;
            memcpy((void *)v21[1], (const void *)(v14[1] + v7), *v21);
            if (v20 == *v22)
            {
              if (dword_10008FA20)
              {
                long long v23 = ne_log_obj();
                if (os_log_type_enabled(v23, OS_LOG_TYPE_DEBUG))
                {
                  uint64_t v33 = sub_10003D0A8("from %s to %s", &v41, v40);
                  *(_DWORD *)buf = 134218242;
                  size_t v37 = v20;
                  __int16 v38 = 2080;
                  uint64_t v39 = v33;
                  _os_log_debug_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEBUG, "%zd bytes message received %s\n", buf, 0x16u);
                }
              }
              if (v41.sa_family == 30 || v41.sa_family == 2)
              {
                if (*(_WORD *)v41.sa_data)
                {
                  if (sub_100008C78(&v41, (uint64_t)v40, (uint64_t)v22))
                  {
                    if (dword_10008FA20)
                    {
                      uint64_t v24 = ne_log_obj();
                      if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
                      {
                        uint64_t v25 = sub_10003CAE4(&v41);
                        *(_DWORD *)buf = 136315138;
                        size_t v37 = (size_t)v25;
                        _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "Received retransmitted packet from %s.\n", buf, 0xCu);
                      }
                      if (dword_10008FA20)
                      {
                        long long v26 = ne_log_obj();
                        if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
                        {
                          uint64_t v27 = sub_10003CAE4(&v41);
                          *(_DWORD *)buf = 136315138;
                          size_t v37 = (size_t)v27;
                          _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "the packet is retransmitted by %s.\n", buf, 0xCu);
                        }
                      }
                    }
                  }
                  else
                  {
                    sub_1000214B4(v22, &v41, (unint64_t)v40);
                  }
                }
                else if (dword_10008FA20)
                {
                  uint64_t v32 = ne_log_obj();
                  if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR)) {
                    sub_10005E8EC();
                  }
                }
              }
              else if (dword_10008FA20)
              {
                uint64_t v31 = ne_log_obj();
                if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR)) {
                  sub_10005E880();
                }
              }
            }
            else if (dword_10008FA20)
            {
              char v30 = ne_log_obj();
              if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR)) {
                sub_10005E920();
              }
            }
            sub_10003FA78(v14);
            int v29 = v22;
LABEL_77:
            sub_10003FA78(v29);
          }
          else
          {
            if (dword_10008FA20)
            {
              int v17 = ne_log_obj();
              if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR)) {
                sub_10005E714();
              }
            }
            if (recvfrom(a1, v50, 0x1CuLL, 0, &v41, &v35) < 0)
            {
              if (dword_10008FA20)
              {
                unint64_t v18 = ne_log_obj();
                if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR)) {
                  goto LABEL_9;
                }
              }
            }
          }
        }
        else
        {
          if (dword_10008FA20)
          {
            int v11 = ne_log_obj();
            if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR)) {
              sub_10005E6E0();
            }
          }
          if (recvfrom(a1, v50, 0x1CuLL, 0, &v41, &v35) < 0)
          {
            if (dword_10008FA20)
            {
              uint64_t v12 = ne_log_obj();
              if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR)) {
                goto LABEL_9;
              }
            }
          }
        }
      }
      else
      {
        if (dword_10008FA20)
        {
          int v9 = ne_log_obj();
          if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR)) {
            sub_10005E65C();
          }
        }
        if (recvfrom(a1, v50, 0x1CuLL, 0, &v41, &v35) < 0)
        {
          if (dword_10008FA20)
          {
            uint64_t v10 = ne_log_obj();
            if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR)) {
              sub_10005E55C();
            }
          }
        }
      }
    }
  }
  else if (dword_10008FA20)
  {
    uint64_t v1 = ne_log_obj();
    if (os_log_type_enabled(v1, OS_LOG_TYPE_DEBUG)) {
      sub_10005E528();
    }
  }
}

void sub_1000214B4(void *a1, sockaddr *a2, unint64_t a3)
{
  uint64_t v3 = a1[1];
  if (*(void *)v3 == qword_10008F840)
  {
    if (dword_10008FA20)
    {
      int v29 = ne_log_obj();
      if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR)) {
        sub_10005E9A4();
      }
    }
    return;
  }
  uint64_t v4 = *(unsigned __int8 *)(v3 + 17);
  if ((v4 & 0xF0) != 0x10)
  {
    if (dword_10008FA20)
    {
      char v30 = ne_log_obj();
      if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR)) {
        sub_10005EE48(v4, v30, v31, v32, v33, v34, v35, v36);
      }
    }
    return;
  }
  if (v4 != 16) {
    return;
  }
  BOOL v6 = (char *)(v3 + 19);
  unsigned int v5 = *(unsigned __int8 *)(v3 + 19);
  if (v5 >= 8)
  {
    if (dword_10008FA20)
    {
      size_t v37 = ne_log_obj();
      if (os_log_type_enabled(v37, OS_LOG_TYPE_ERROR)) {
        sub_10005EDDC();
      }
    }
    return;
  }
  if ((v5 & 2) != 0 && !*(_DWORD *)(v3 + 20))
  {
    sub_10001A78C(a1[1], a2, a3, 8u, 0);
    if (dword_10008FA20)
    {
      __int16 v38 = ne_log_obj();
      if (os_log_type_enabled(v38, OS_LOG_TYPE_ERROR)) {
        sub_10005EDA8();
      }
    }
    return;
  }
  uint64_t v10 = sub_10004B7EC(a3, (uint64_t)a2, 0, (void *)v3);
  if (!v10)
  {
    uint64_t v10 = sub_10004B7EC(a3, (uint64_t)a2, 1, 0);
    if (!v10)
    {
      if (dword_10008FA20)
      {
        int v11 = ne_log_obj();
        if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "failed to allocate or find ike session.\n", buf, 2u);
        }
      }
      sub_10003B880();
    }
  }
  uint64_t v12 = sub_1000072D0(v10, (void *)v3);
  uint64_t v13 = v12;
  if (v12)
  {
    if (*(void *)(v3 + 8) == qword_10008F840 && !*(_DWORD *)(v12 + 20))
    {
      if (dword_10008FA20)
      {
        uint64_t v51 = ne_log_obj();
        if (os_log_type_enabled(v51, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)buf = 0;
          long long v52 = "Malformed cookie received or the initiator's cookies collide.\n";
LABEL_93:
          _os_log_impl((void *)&_mh_execute_header, v51, OS_LOG_TYPE_DEFAULT, v52, buf, 2u);
        }
      }
      return;
    }
    if ((*(_DWORD *)(v12 + 96) & 9) == 1)
    {
      int v14 = (void *)(v12 + 48);
      if (sub_10003BB04(*(void *)(v12 + 48), (unint64_t)a2)
        || sub_10003BB04(*(void *)(v13 + 56), a3))
      {
        free(*(void **)(v13 + 48));
        free(*(void **)(v13 + 56));
        void *v14 = 0;
        *(void *)(v13 + 56) = 0;
        int v15 = sub_10003CC74();
        *(void *)(v13 + 48) = v15;
        if (!v15)
        {
          if (dword_10008FA20)
          {
            unsigned int v16 = ne_log_obj();
            if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR)) {
              sub_10005ED74();
            }
          }
          sub_10003B880();
        }
        int v17 = sub_10003CC74();
        *(void *)(v13 + 56) = v17;
        if (!v17)
        {
          if (dword_10008FA20)
          {
            unint64_t v18 = ne_log_obj();
            if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR)) {
              sub_10005ED74();
            }
          }
          sub_10003B880();
        }
        *(_DWORD *)(v13 + 96) |= 0x28u;
        if (dword_10008FA20)
        {
          long long v19 = ne_log_obj();
          if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
          {
            size_t v20 = sub_10003D0A8("%s<->%s", *(const sockaddr **)(v13 + 48), *(sockaddr **)(v13 + 56));
            *(_DWORD *)buf = 136315138;
            *(void *)char v65 = v20;
            _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "NAT-T: ports changed to: %s\n", buf, 0xCu);
          }
        }
      }
    }
    if (!sub_10003BB04(*(void *)(v13 + 48), (unint64_t)a2)) {
      goto LABEL_39;
    }
    long long v21 = sub_10003CAE4(*(const sockaddr **)(v13 + 48));
    long long v22 = strdup((const char *)v21);
    long long v23 = sub_10003CAE4(a2);
    uint64_t v24 = strdup((const char *)v23);
    if (v22)
    {
      uint64_t v25 = v24;
      if (v24)
      {
        if (dword_10008FA20)
        {
          log = ne_log_obj();
          if (os_log_type_enabled(log, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 136315394;
            *(void *)char v65 = v22;
            *(_WORD *)&v65[8] = 2080;
            *(void *)&v65[10] = v25;
            _os_log_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_DEFAULT, "Remote address mismatched. db=%s, act=%s\n", buf, 0x16u);
          }
        }
        free(v22);
        free(v25);
LABEL_39:
        sub_10001C398(v13, (uint64_t)"IKE packet received from peer");
        goto LABEL_40;
      }
      if (dword_10008FA20)
      {
        uint64_t v62 = ne_log_obj();
        if (os_log_type_enabled(v62, OS_LOG_TYPE_ERROR)) {
          goto LABEL_131;
        }
      }
    }
    else if (dword_10008FA20)
    {
      int v61 = ne_log_obj();
      if (os_log_type_enabled(v61, OS_LOG_TYPE_ERROR)) {
LABEL_131:
      }
        sub_10005ED40();
    }
    exit(1);
  }
LABEL_40:
  uint64_t v27 = (unsigned __int8 *)(v3 + 18);
  int v26 = *(unsigned __int8 *)(v3 + 18);
  switch(*(unsigned char *)(v3 + 18))
  {
    case 2:
    case 4:
      if (*(_DWORD *)(v3 + 20))
      {
        if (dword_10008FA20)
        {
          uint64_t v28 = ne_log_obj();
          if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR)) {
            sub_10005EB0C();
          }
        }
        return;
      }
      if (v13) {
        goto LABEL_82;
      }
      uint64_t v47 = sub_100007370(v10, (void *)v3);
      if (v47)
      {
        uint64_t v13 = v47;
        int v26 = *v27;
LABEL_82:
        if (*(unsigned __int8 *)(v13 + 81) == v26)
        {
          if (*(unsigned __int8 *)(v3 + 16) == 132) {
            goto LABEL_101;
          }
          sub_1000027EC(v13, a1);
        }
        else if (dword_10008FA20)
        {
          uint64_t v54 = ne_log_obj();
          if (os_log_type_enabled(v54, OS_LOG_TYPE_ERROR)) {
            sub_10005EA58((unsigned __int8 *)(v13 + 81), (unsigned __int8 *)(v3 + 18), v54);
          }
        }
      }
      else if (*(void *)(v3 + 8) == qword_10008F840)
      {
        sub_100027404(v10, (uint64_t)a1, a2, a3, *v27);
      }
      else if (dword_10008FA20)
      {
        uint64_t v51 = ne_log_obj();
        if (os_log_type_enabled(v51, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)buf = 0;
          long long v52 = "Malformed cookie received or the spi expired.\n";
          goto LABEL_93;
        }
      }
      return;
    case 3:
      goto LABEL_62;
    case 5:
      goto LABEL_56;
    case 6:
      if (v13)
      {
        if ((*(unsigned char *)(v13 + 17) & 0x20) != 0)
        {
          if (*(unsigned __int8 *)(v3 + 16) == 132) {
            goto LABEL_101;
          }
          sub_100042AA8(v13, a1);
        }
        else if (dword_10008FA20)
        {
          int v40 = ne_log_obj();
          if (os_log_type_enabled(v40, OS_LOG_TYPE_ERROR))
          {
            int v41 = *v27;
            long long v42 = sub_10003CAE4(a2);
            sub_100023BEC(v13, *(_DWORD *)(v13 + 84));
            *(_DWORD *)buf = 67109634;
            *(_DWORD *)char v65 = v41;
            *(_WORD *)&v65[4] = 2080;
            *(void *)&v65[6] = v42;
            *(_WORD *)&v65[14] = 2080;
            *(void *)&v65[16] = &xmmword_10008C748;
            _os_log_error_impl((void *)&_mh_execute_header, v40, OS_LOG_TYPE_ERROR, "mode config %d from %s, but ISAKMP-SA %s isn't established.\n", buf, 0x1Cu);
          }
        }
      }
      else if (dword_10008FA20)
      {
        uint64_t v53 = ne_log_obj();
        if (os_log_type_enabled(v53, OS_LOG_TYPE_ERROR)) {
          sub_10005ECC0(v3 + 18, a2);
        }
      }
      return;
    default:
      if (v26 == 32)
      {
        int v43 = *(_DWORD *)(v3 + 20);
        if (v13)
        {
          uint64_t v44 = *(void *)(v13 + 408);
          if (v44)
          {
            long long v45 = *(void **)(v44 + 1176);
            if (v45)
            {
              sub_10002DA30(v45);
              *(void *)(*(void *)(v13 + 408) + 1176) = 0;
            }
          }
          if (*(unsigned __int8 *)(v3 + 16) == 132)
          {
LABEL_101:
            sub_1000277C4(v13, a1, a2, a3);
            return;
          }
          if ((*(unsigned char *)(v13 + 17) & 0x20) != 0)
          {
            uint64_t v57 = sub_100007F40(v13, v43);
            if (v57)
            {
              char v58 = *v6;
              if ((*v6 & 2) != 0) {
                *(unsigned char *)(v57 + 105) |= 2u;
              }
              if ((v58 & 1) == 0 || (uint64_t v59 = *(void *)(v57 + 256)) != 0 && *(void *)(v59 + 72))
              {
                sub_100002C2C(v57, a1);
              }
              else if (dword_10008FA20)
              {
                uint64_t v60 = ne_log_obj();
                if (os_log_type_enabled(v60, OS_LOG_TYPE_ERROR)) {
                  sub_10005EC8C();
                }
              }
            }
            else
            {
              sub_1000279A0(v13, a1);
            }
          }
          else if (dword_10008FA20)
          {
            long long v46 = ne_log_obj();
            if (os_log_type_enabled(v46, OS_LOG_TYPE_ERROR)) {
              sub_10005EC04(v13);
            }
          }
        }
        else
        {
          sub_10001A78C(v3, a2, a3, 4u, 0);
          if (dword_10008FA20)
          {
            long long v55 = ne_log_obj();
            if (os_log_type_enabled(v55, OS_LOG_TYPE_ERROR)) {
              sub_10005EB74((unsigned int *)(v3 + 20), v3);
            }
          }
        }
      }
      else if (v26 == 34)
      {
LABEL_56:
        if (v13) {
          goto LABEL_57;
        }
        uint64_t v48 = sub_100007370(v10, (void *)v3);
        if (v48)
        {
          uint64_t v13 = v48;
          if (sub_10003BB04(*(void *)(v48 + 48), (unint64_t)a2))
          {
            if (dword_10008FA20)
            {
              long long v49 = ne_log_obj();
              if (os_log_type_enabled(v49, OS_LOG_TYPE_DEFAULT))
              {
                uint64_t v50 = sub_10003CAE4(*(const sockaddr **)(v13 + 48));
                *(_DWORD *)buf = 136315138;
                *(void *)char v65 = v50;
                _os_log_impl((void *)&_mh_execute_header, v49, OS_LOG_TYPE_DEFAULT, "Remote address mismatched. db=%s\n", buf, 0xCu);
              }
            }
          }
LABEL_57:
          if (*(unsigned __int8 *)(v3 + 16) != 132)
          {
            sub_100018A28(v13, a1);
            return;
          }
          goto LABEL_101;
        }
        if (dword_10008FA20)
        {
          int v56 = ne_log_obj();
          if (os_log_type_enabled(v56, OS_LOG_TYPE_ERROR)) {
            sub_10005EB40();
          }
        }
      }
      else
      {
LABEL_62:
        if (dword_10008FA20)
        {
          uint64_t v39 = ne_log_obj();
          if (os_log_type_enabled(v39, OS_LOG_TYPE_ERROR)) {
            sub_10005E9D8(v3 + 18, a2);
          }
        }
      }
      break;
  }
}

uint64_t sub_100021EA8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5, _OWORD *a6)
{
  uint64_t v11 = a1;
  if (!a1)
  {
    uint64_t v11 = sub_10004B7EC(a4, a3, 1, 0);
    if (!v11)
    {
      if (dword_10008FA20)
      {
        uint64_t v12 = ne_log_obj();
        if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
        {
          LOWORD(v31) = 0;
          _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "failed to allocate or find ike session.\n", (uint8_t *)&v31, 2u);
        }
      }
      sub_10003B880();
    }
  }
  uint64_t v13 = sub_100007868(16);
  if (!v13) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v14 = (uint64_t)v13;
  *((void *)v13 + 8) = a2;
  sub_100038F68(a2);
  *(_DWORD *)(v14 + 20) = 0;
  *(_DWORD *)(v14 + 24) = a5;
  if (a6) {
    *(_OWORD *)(v14 + 28) = *a6;
  }
  *(unsigned char *)(v14 + 80) = 16;
  *(_DWORD *)(v14 + 84) = 0;
  *(unsigned char *)(v14 + 82) = 0;
  *(_DWORD *)(v14 + 400) = 0;
  int v15 = sub_100045224();
  *(void *)(v14 + 408) = v15;
  if (!v15) {
    goto LABEL_16;
  }
  *(_DWORD *)(v14 + 100) = *(_DWORD *)(a2 + 148) == 2;
  *(void *)(v14 + 104) = 0;
  *(void *)(v14 + 72) = 0;
  if ((sub_1000222A8(v14, a2, a3, a4) & 0x80000000) != 0) {
    return 0xFFFFFFFFLL;
  }
  if (sub_10004BEF0(v11, v14))
  {
    if (dword_10008FA20)
    {
      unsigned int v16 = ne_log_obj();
      if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(v31) = 0;
        _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "Failed to link ph1 to session\n", (uint8_t *)&v31, 2u);
      }
    }
LABEL_16:
    sub_100007920(v14);
    return 0xFFFFFFFFLL;
  }
  if (a5 == 3 && (*(unsigned char *)(v14 + 432) & 1) == 0)
  {
    *(_WORD *)(*(void *)(v14 + 440) + 264) |= 1u;
    ++*(_DWORD *)(*(void *)(v14 + 440) + 364);
    *(unsigned char *)(v14 + 432) |= 1u;
  }
  int v18 = **(unsigned __int8 **)(a2 + 16);
  *(unsigned char *)(v14 + 81) = v18;
  if (v18 == 2)
  {
    int v19 = 5184;
  }
  else
  {
    if (v18 != 4) {
      return 0xFFFFFFFFLL;
    }
    int v19 = 5248;
  }
  sub_100002728((int *)(v14 + 16), v19);
  if (dword_10008FA20)
  {
    size_t v20 = ne_log_obj();
    if (os_log_type_enabled(v20, OS_LOG_TYPE_DEBUG)) {
      sub_10005EEB4();
    }
  }
  long long v21 = sub_10003CAE4(*(const sockaddr **)(v14 + 56));
  long long v22 = strdup((const char *)v21);
  if (!v22)
  {
    if (dword_10008FA20)
    {
      char v30 = ne_log_obj();
      if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR)) {
        sub_10005ED40();
      }
    }
    exit(1);
  }
  long long v23 = v22;
  if (dword_10008FA20)
  {
    uint64_t v24 = ne_log_obj();
    if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v25 = sub_10003CAE4(*(const sockaddr **)(v14 + 48));
      int v31 = 136315394;
      uint64_t v32 = v23;
      __int16 v33 = 2080;
      uint64_t v34 = v25;
      _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "initiate new phase 1 negotiation: %s<=>%s\n", (uint8_t *)&v31, 0x16u);
    }
    int v26 = dword_10008FA20;
    free(v23);
    if (v26)
    {
      uint64_t v27 = ne_log_obj();
      if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v28 = sub_10003E0EC(*(unsigned __int8 *)(v14 + 81));
        int v31 = 136315138;
        uint64_t v32 = v28;
        _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "begin %s mode.\n", (uint8_t *)&v31, 0xCu);
      }
      if (dword_10008FA20)
      {
        int v29 = ne_log_obj();
        if (os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
        {
          LOWORD(v31) = 0;
          _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEFAULT, "IPSec Phase 1 started (Initiated by me).\n", (uint8_t *)&v31, 2u);
        }
      }
    }
  }
  else
  {
    free(v22);
  }
  if (sub_100002AA0(v14, 0))
  {
    sub_10004B710(v14);
    return 0xFFFFFFFFLL;
  }
  sub_1000496DC(1, 0, v14, 0);
  return 0;
}

uint64_t sub_1000222A8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7 = (unsigned __int8 *)sub_10003CC74();
  *(void *)(a1 + 48) = v7;
  if (!v7) {
    goto LABEL_27;
  }
  int v8 = v7[1];
  if (v8 != 30 && v8 != 2)
  {
    if (!dword_10008FA20) {
      goto LABEL_27;
    }
    uint64_t v12 = ne_log_obj();
    if (!os_log_type_enabled(v12, OS_LOG_TYPE_ERROR)) {
      goto LABEL_27;
    }
LABEL_26:
    sub_10005EEE8();
    goto LABEL_27;
  }
  int v10 = *((unsigned __int16 *)v7 + 1);
  int v9 = (__int16 *)(v7 + 2);
  if (v10)
  {
    if (a4)
    {
LABEL_6:
      uint64_t v11 = (unsigned __int8 *)sub_10003CC74();
      goto LABEL_14;
    }
  }
  else
  {
    __int16 v13 = *(_WORD *)(*(void *)a2 + 2);
    if (!v13) {
      __int16 v13 = -3071;
    }
    __int16 *v9 = v13;
    if (a4) {
      goto LABEL_6;
    }
  }
  uint64_t v11 = (unsigned __int8 *)sub_10003BCB0(*(const sockaddr **)(a1 + 48));
LABEL_14:
  unint64_t v14 = (unint64_t)v11;
  *(void *)(a1 + 56) = v11;
  if (!v11)
  {
LABEL_27:
    sub_100007920(a1);
    return 0xFFFFFFFFLL;
  }
  int v15 = v11[1];
  if (v15 != 30 && v15 != 2)
  {
    if (!dword_10008FA20) {
      goto LABEL_27;
    }
    int v19 = ne_log_obj();
    if (!os_log_type_enabled(v19, OS_LOG_TYPE_ERROR)) {
      goto LABEL_27;
    }
    goto LABEL_26;
  }
  int v16 = *((unsigned __int16 *)v11 + 1);
  if (!*(_WORD *)(v14 + 2))
  {
    int v16 = sub_100006CB0(v14);
    *(_WORD *)(v14 + 2) = v16;
  }
  if (v16 != bswap32(*(unsigned __int16 *)(qword_10008F848 + 18)) >> 16) {
    return 0;
  }
  if (dword_10008FA20)
  {
    int v17 = ne_log_obj();
    if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)size_t v20 = 0;
      _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "Marking ports as changed\n", v20, 2u);
    }
  }
  uint64_t result = 0;
  *(_DWORD *)(a1 + 96) |= 0x20u;
  return result;
}

uint64_t sub_100022478(uint64_t a1)
{
  int v2 = *(_DWORD *)(*(void *)(a1 + 64) + 168);
  if (*(_DWORD *)(a1 + 20) == 1
    && (uint64_t v3 = *(void *)(a1 + 56), *(unsigned char *)(v3 + 1) == 2)
    && (uint64_t v4 = *(void *)(qword_10008F848 + 72)) != 0)
  {
    if (*(_DWORD *)(v3 + 4) == *(_DWORD *)(v4 + 16))
    {
      unsigned int v5 = sub_10003F940(4uLL);
      if (v5)
      {
        BOOL v6 = v5;
        *(_DWORD *)v5[1] = *(_DWORD *)(v4 + 20);
        sub_10001AD08(a1, 0x9E35u, (uint64_t)v5);
        if (dword_10008FA20)
        {
          uint64_t v7 = ne_log_obj();
          if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
          {
            unsigned int v8 = bswap32(*(_DWORD *)(v4 + 20));
            v30[0] = 67109120;
            v30[1] = v8;
            _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "sent redirect notification - address = %x.\n", (uint8_t *)v30, 8u);
          }
        }
        sub_10003FA78(v6);
        if (*(_WORD *)(v4 + 24))
        {
          sub_10004C2B0(a1);
          sub_100022854(a1);
        }
      }
      else if (dword_10008FA20)
      {
        int v29 = ne_log_obj();
        if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR)) {
          sub_10005EFB8();
        }
      }
    }
  }
  else
  {
    time((time_t *)(a1 + 360));
    *(_DWORD *)(a1 + 112) = sub_10003AA24(*(void *)(*(void *)(a1 + 72) + 16), (uint64_t)sub_100022A40, a1);
    if (*(_DWORD *)(*(void *)(a1 + 64) + 280))
    {
      if (*(_DWORD *)(a1 + 20))
      {
        unint64_t v9 = bswap64(*(void *)(a1 + 8));
        unint64_t v10 = bswap64(*(void *)a1);
        BOOL v11 = v9 >= v10;
        BOOL v12 = v9 > v10;
        int v13 = !v11;
        unsigned int v14 = v12 - v13;
        if (!v14) {
          unsigned int v14 = -1;
        }
      }
      else
      {
        unint64_t v15 = bswap64(*(void *)a1);
        unint64_t v16 = bswap64(*(void *)(a1 + 8));
        BOOL v11 = v15 >= v16;
        BOOL v17 = v15 > v16;
        int v18 = !v11;
        unsigned int v14 = v17 - v18;
        if (v14 <= 1) {
          unsigned int v14 = 1;
        }
      }
      unsigned int v19 = sub_10004B3C8((int)v14 > 0, *(_DWORD *)(*(void *)(a1 + 72) + 16));
      if (v19)
      {
        *(_DWORD *)(a1 + 116) = sub_10003AA24(v19, (uint64_t)sub_100022A44, a1);
      }
      else if (dword_10008FA20)
      {
        size_t v20 = ne_log_obj();
        if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR)) {
          sub_10005EF84();
        }
      }
    }
    if (*(unsigned char *)(a1 + 432) & 1) == 0 && (**(unsigned char **)(a1 + 408))
    {
      int v21 = *(_DWORD *)(*(void *)(a1 + 72) + 48);
      if (!*(void *)(*(void *)(a1 + 64) + 272) || v21 != 65001)
      {
        BOOL v23 = (v21 - 65002) > 8 || ((1 << (v21 + 22)) & 0x151) == 0;
        if (!v23 || v21 == 64222)
        {
          sub_1000464E4(a1);
          int v2 = 0;
        }
      }
    }
    if (*(_DWORD *)(a1 + 368) && *(_DWORD *)(*(void *)(a1 + 64) + 216)) {
      sub_10001BF60(a1, 0);
    }
    if ((*(unsigned char *)(a1 + 432) & 1) == 0 && !dword_10008F858 && v2 != 0 && !sub_100008AC0(*(void *)(a1 + 48)))
    {
      sub_10001AD08(a1, 0x6002u, 0);
      if (sub_100008B08() == -1)
      {
        if (dword_10008FA20)
        {
          int v26 = ne_log_obj();
          if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR)) {
            sub_10005EF50();
          }
        }
      }
    }
    sub_100022A4C(a1);
    if (dword_10008FA20)
    {
      uint64_t v27 = ne_log_obj();
      if (os_log_type_enabled(v27, OS_LOG_TYPE_DEBUG)) {
        sub_10005EEB4();
      }
    }
    sub_10004D3C4(*(void *)(a1 + 440), a1);
    sub_1000496DC(0, 0, a1, 0);
    sub_100049A44(1, a1);
  }
  return 0;
}

void *sub_100022854(uint64_t a1)
{
  uint64_t v2 = *(unsigned int *)(a1 + 112);
  if (v2)
  {
    sub_10003AC14(v2);
    *(_DWORD *)(a1 + 112) = 0;
  }
  uint64_t v3 = *(unsigned int *)(a1 + 388);
  if (v3)
  {
    sub_10003AC14(v3);
    *(_DWORD *)(a1 + 388) = 0;
  }
  if ((*(unsigned char *)(a1 + 17) & 0x40) == 0)
  {
    uint64_t v4 = sub_10003CAE4(*(const sockaddr **)(a1 + 56));
    unsigned int v5 = strdup((const char *)v4);
    BOOL v6 = sub_10003CAE4(*(const sockaddr **)(a1 + 48));
    uint64_t v7 = strdup((const char *)v6);
    if (v5)
    {
      unsigned int v8 = v7;
      if (v7)
      {
        if (dword_10008FA20)
        {
          unint64_t v9 = ne_log_obj();
          if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
          {
            sub_100023BEC(a1, 0);
            int v14 = 136315650;
            unint64_t v15 = v5;
            __int16 v16 = 2080;
            BOOL v17 = v8;
            __int16 v18 = 2080;
            unsigned int v19 = &xmmword_10008C748;
            _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "ISAKMP-SA expired %s-%s spi:%s\n", (uint8_t *)&v14, 0x20u);
          }
        }
        free(v5);
        free(v8);
        sub_100002728((int *)(a1 + 16), 17408);
        sub_10004C2B0(a1);
        goto LABEL_12;
      }
      if (dword_10008FA20)
      {
        int v13 = ne_log_obj();
        if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR)) {
          goto LABEL_21;
        }
      }
    }
    else if (dword_10008FA20)
    {
      BOOL v12 = ne_log_obj();
      if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR)) {
LABEL_21:
      }
        sub_10005ED40();
    }
    exit(1);
  }
LABEL_12:
  if (*(void *)(a1 + 448)) {
    unint64_t v10 = sub_100022A40;
  }
  else {
    unint64_t v10 = sub_1000248EC;
  }
  uint64_t result = sub_10003AA24(1, (uint64_t)v10, a1);
  *(_DWORD *)(a1 + 112) = result;
  return result;
}

void sub_100022A44(uint64_t a1)
{
}

void sub_100022A4C(uint64_t a1)
{
  uint64_t v2 = sub_10003CAE4(*(const sockaddr **)(a1 + 56));
  uint64_t v3 = strdup((const char *)v2);
  uint64_t v4 = sub_10003CAE4(*(const sockaddr **)(a1 + 48));
  unsigned int v5 = strdup((const char *)v4);
  if (!v3)
  {
    if (dword_10008FA20)
    {
      BOOL v12 = ne_log_obj();
      if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR)) {
        goto LABEL_22;
      }
    }
    goto LABEL_23;
  }
  BOOL v6 = v5;
  if (!v5)
  {
    if (dword_10008FA20)
    {
      int v13 = ne_log_obj();
      if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR)) {
LABEL_22:
      }
        sub_10005ED40();
    }
LABEL_23:
    exit(1);
  }
  if (!dword_10008FA20) {
    goto LABEL_15;
  }
  uint64_t v7 = ne_log_obj();
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    sub_100023BEC(a1, 0);
    int v14 = 136315138;
    unint64_t v15 = &xmmword_10008C748;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "ISAKMP-SA established spi:%s\n", (uint8_t *)&v14, 0xCu);
  }
  if (dword_10008FA20)
  {
    unsigned int v8 = ne_log_obj();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
    {
      sub_100023BEC(a1, 0);
      int v14 = 136315650;
      unint64_t v15 = (long long *)v3;
      __int16 v16 = 2080;
      BOOL v17 = v6;
      __int16 v18 = 2080;
      unsigned int v19 = &xmmword_10008C748;
      _os_log_debug_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEBUG, "ISAKMP-SA established %s-%s spi:%s\n", (uint8_t *)&v14, 0x20u);
    }
    int v9 = dword_10008FA20;
    free(v3);
    free(v6);
    if (v9)
    {
      unint64_t v10 = ne_log_obj();
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
      {
        if (*(_DWORD *)(a1 + 20)) {
          BOOL v11 = "peer";
        }
        else {
          BOOL v11 = "me";
        }
        int v14 = 136315138;
        unint64_t v15 = (long long *)v11;
        _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "IPSec Phase 1 established (Initiated by %s).\n", (uint8_t *)&v14, 0xCu);
      }
    }
  }
  else
  {
LABEL_15:
    free(v3);
    free(v6);
  }
}

void **sub_100022CA8(unsigned __int8 a1, unsigned __int8 *a2, int a3)
{
  if (dword_10008FA20)
  {
    BOOL v6 = ne_log_obj();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG)) {
      sub_10005F054();
    }
  }
  uint64_t v7 = (void **)sub_10003F940(0x50uLL);
  if (!v7)
  {
    if (dword_10008FA20)
    {
      long long v22 = ne_log_obj();
      if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR)) {
        sub_10005821C();
      }
    }
    return 0;
  }
  unsigned int v8 = v7;
  unint64_t v9 = (unint64_t)v7[1];
  if (a3 < 1 || (char v10 = a1) == 0)
  {
LABEL_25:
    *(unsigned char *)unint64_t v9 = 0;
    *(_DWORD *)(v9 + 4) = 0;
    *(void *)(v9 + 8) = 0;
    if (dword_10008FA20)
    {
      int v21 = ne_log_obj();
      if (os_log_type_enabled(v21, OS_LOG_TYPE_DEBUG)) {
        sub_10005F020();
      }
    }
    return v8;
  }
  int v11 = a1;
  unint64_t v12 = (unint64_t)*v7 + v9 - 16;
  while (1)
  {
    if (a3 <= 4)
    {
      if (dword_10008FA20)
      {
        BOOL v23 = ne_log_obj();
        if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR)) {
          sub_10005EFEC();
        }
      }
      goto LABEL_37;
    }
    if (dword_10008FA20)
    {
      int v13 = ne_log_obj();
      if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
      {
        int v14 = sub_10003E1DC(v11);
        *(_DWORD *)buf = 67109378;
        int v29 = v11;
        __int16 v30 = 2080;
        int v31 = v14;
        _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "seen nptype=%u(%s)\n", buf, 0x12u);
      }
    }
    *(unsigned char *)unint64_t v9 = v10;
    unsigned int v15 = bswap32(*((unsigned __int16 *)a2 + 1)) >> 16;
    *(_DWORD *)(v9 + 4) = v15;
    if (v15 < 4 || a3 < v15)
    {
      if (dword_10008FA20)
      {
        uint64_t v24 = ne_log_obj();
        if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "isakmp_parsewoh invalid length of payload (2)\n", buf, 2u);
        }
      }
LABEL_37:
      uint64_t v25 = v8;
      goto LABEL_38;
    }
    *(void *)(v9 + 8) = a2;
    v9 += 16;
    if (v12 <= v9) {
      break;
    }
LABEL_20:
    int v11 = *a2;
    a2 += v15;
    a3 -= v15;
    BOOL v20 = a3 < 1 || v11 == 0;
    char v10 = v11;
    if (v20) {
      goto LABEL_25;
    }
  }
  BOOL v17 = v8[1];
  __int16 v18 = sub_10003F9BC(v8, 2 * (void)*v8);
  if (v18)
  {
    unsigned int v8 = v18;
    unsigned int v19 = v18[1];
    unint64_t v12 = (unint64_t)*v18 + (void)v19 - 16;
    unint64_t v9 = (unint64_t)v19 + 16 * (int)((v9 - (unint64_t)v17) >> 4);
    unsigned int v15 = bswap32(*((unsigned __int16 *)a2 + 1)) >> 16;
    goto LABEL_20;
  }
  if (dword_10008FA20)
  {
    uint64_t v27 = ne_log_obj();
    if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "failed to realloc buffer.\n", buf, 2u);
    }
  }
  uint64_t v25 = 0;
LABEL_38:
  sub_10003FA78(v25);
  return 0;
}

void **sub_100022FA8(uint64_t a1)
{
  return sub_100022CA8(*(unsigned char *)(*(void *)(a1 + 8) + 16), (unsigned __int8 *)(*(void *)(a1 + 8) + 28), *(_DWORD *)a1 - 28);
}

uint64_t sub_100022FC4()
{
  if ((sub_100022FFC() & 0x80000000) == 0) {
    return 0;
  }
  sub_100023D5C();
  sub_1000062AC();
  return 0xFFFFFFFFLL;
}

uint64_t sub_100022FFC()
{
  int v64 = 1;
  uint64_t v0 = *(uint64_t **)(qword_10008F848 + 120);
  if (v0)
  {
    int v1 = 0;
    int v2 = 0;
    int v3 = 0;
    while (1)
    {
      unsigned int v5 = v0 + 1;
      uint64_t v4 = v0[1];
      if (!v4) {
        goto LABEL_107;
      }
      if (*((_DWORD *)v0 + 4) != -1)
      {
        ++v1;
        if (*((_DWORD *)v0 + 8)) {
          ++v3;
        }
        goto LABEL_107;
      }
      int v6 = *(unsigned __int8 *)(v4 + 1);
      if (v6 != 30) {
        break;
      }
      if (!*(_DWORD *)(v4 + 8)
        && !*(_DWORD *)(v4 + 12)
        && !*(_DWORD *)(v4 + 16)
        && !*(_DWORD *)(v4 + 20)
        && dword_10008FA20 != 0)
      {
        unint64_t v12 = ne_log_obj();
        if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)buf = 0;
          unint64_t v9 = v12;
          char v10 = "listening to wildcard address, broadcast IKE packet may kill you\n";
LABEL_16:
          _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, v10, buf, 2u);
        }
      }
LABEL_26:
      int v13 = (sockaddr *)*v5;
      if (*(unsigned char *)(*v5 + 1) == 30 && v13->sa_data[6] == 255)
      {
        if (dword_10008FA20)
        {
          int v21 = ne_log_obj();
          BOOL v22 = os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT);
          int v13 = (sockaddr *)*v5;
          if (v22)
          {
            BOOL v23 = sub_10003CAE4(v13);
            *(_DWORD *)buf = 136315138;
            *(void *)&uint8_t buf[4] = v23;
            _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "Ignoring multicast address %s\n", buf, 0xCu);
            int v13 = (sockaddr *)*v5;
          }
        }
        free(v13);
        *unsigned int v5 = 0;
      }
      else
      {
        int v14 = socket(*(unsigned __int8 *)(*v5 + 1), 2, 0);
        *((_DWORD *)v0 + 4) = v14;
        if (v14 < 0)
        {
          if (dword_10008FA20)
          {
            BOOL v20 = ne_log_obj();
            if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR)) {
              sub_10005F114();
            }
          }
          goto LABEL_105;
        }
        if (fcntl(v14, 4, 4) == -1 && dword_10008FA20 != 0)
        {
          __int16 v16 = ne_log_obj();
          if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR)) {
            sub_10005F450(&v62, v63, v16);
          }
        }
        int v17 = *(unsigned __int8 *)(*v5 + 1);
        if (v17 == 30)
        {
          *(_DWORD *)__int16 v66 = 0;
          *(_DWORD *)__int16 v66 = if_nametoindex((const char *)v0[5]);
          if (*(_DWORD *)v66 && setsockopt(*((_DWORD *)v0 + 4), 41, 125, v66, 4u) < 0)
          {
            if (dword_10008FA20)
            {
              uint64_t v39 = ne_log_obj();
              if (os_log_type_enabled(v39, OS_LOG_TYPE_ERROR)) {
                sub_10005F400();
              }
            }
            goto LABEL_105;
          }
          if (setsockopt(*((_DWORD *)v0 + 4), 41, 61, &v64, 4u) < 0)
          {
            if (dword_10008FA20)
            {
              uint64_t v34 = ne_log_obj();
              if (os_log_type_enabled(v34, OS_LOG_TYPE_ERROR))
              {
                uint64_t v35 = __error();
                uint64_t v36 = strerror(*v35);
                *(_DWORD *)buf = 67109378;
                *(_DWORD *)&uint8_t buf[4] = 61;
                *(_WORD *)&uint8_t buf[8] = 2080;
                *(void *)&buf[10] = v36;
                _os_log_error_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_ERROR, "setsockopt IPV6_RECVDSTADDR (%d):%s\n", buf, 0x12u);
              }
            }
            goto LABEL_105;
          }
        }
        else if (v17 == 2)
        {
          *(_DWORD *)buf = 0;
          *(_DWORD *)buf = if_nametoindex((const char *)v0[5]);
          if (*(_DWORD *)buf && setsockopt(*((_DWORD *)v0 + 4), 0, 25, buf, 4u) < 0)
          {
            if (dword_10008FA20)
            {
              __int16 v38 = ne_log_obj();
              if (os_log_type_enabled(v38, OS_LOG_TYPE_ERROR)) {
                sub_10005F3B0();
              }
            }
            goto LABEL_105;
          }
          if (setsockopt(*((_DWORD *)v0 + 4), 0, 7, &v64, 4u) < 0)
          {
            if (dword_10008FA20)
            {
              __int16 v18 = ne_log_obj();
              if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR)) {
                sub_10005F360();
              }
            }
            goto LABEL_105;
          }
        }
        uint64_t v24 = *(unsigned __int8 *)(*v5 + 1);
        if (v24 == 30)
        {
          if (setsockopt(*((_DWORD *)v0 + 4), 41, 42, &v64, 4u) < 0)
          {
            if (dword_10008FA20)
            {
              long long v55 = ne_log_obj();
              if (os_log_type_enabled(v55, OS_LOG_TYPE_ERROR)) {
                sub_10005F164();
              }
            }
            return 0xFFFFFFFFLL;
          }
          uint64_t v24 = *(unsigned __int8 *)(*v5 + 1);
        }
        if ((sub_10003BE80(*((_DWORD *)v0 + 4), v24) & 0x80000000) != 0) {
          goto LABEL_105;
        }
        if (setsockopt(*((_DWORD *)v0 + 4), 0xFFFF, 4, &v64, 4u) < 0)
        {
          if (dword_10008FA20)
          {
            __int16 v33 = ne_log_obj();
            if (os_log_type_enabled(v33, OS_LOG_TYPE_ERROR)) {
              sub_10005F1E4();
            }
          }
          goto LABEL_105;
        }
        if (setsockopt(*((_DWORD *)v0 + 4), 0xFFFF, 512, &v64, 4u) < 0)
        {
          if (dword_10008FA20)
          {
            size_t v37 = ne_log_obj();
            if (os_log_type_enabled(v37, OS_LOG_TYPE_ERROR)) {
              sub_10005F234();
            }
          }
          goto LABEL_105;
        }
        if (sub_10003D80C(*v5) == 500 && setsockopt(*((_DWORD *)v0 + 4), 0xFFFF, 4134, &v64, 4u) < 0)
        {
          if (dword_10008FA20)
          {
            long long v46 = ne_log_obj();
            if (os_log_type_enabled(v46, OS_LOG_TYPE_ERROR)) {
              sub_10005F284();
            }
          }
          goto LABEL_105;
        }
        if ((bind(*((_DWORD *)v0 + 4), (const sockaddr *)v0[1], *(unsigned __int8 *)v0[1]) & 0x80000000) == 0)
        {
          if (*((_DWORD *)v0 + 8)) {
            ++v3;
          }
          int v25 = *((_DWORD *)v0 + 4);
          int v26 = v0[3];
          int v27 = v25;
          if (v26)
          {
            dispatch_source_cancel(v26);
            v0[3] = 0;
            int v27 = *((_DWORD *)v0 + 4);
          }
          uint64_t v28 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_read, v27, 0, (dispatch_queue_t)&_dispatch_main_q);
          v0[3] = (uint64_t)v28;
          if (!v28)
          {
            if (dword_10008FA20)
            {
              int v56 = ne_log_obj();
              if (os_log_type_enabled(v56, OS_LOG_TYPE_ERROR)) {
                sub_10005F32C();
              }
            }
            return 0xFFFFFFFFLL;
          }
          ++v1;
          handler[0] = _NSConcreteStackBlock;
          handler[1] = 0x40000000;
          handler[2] = sub_100023CD4;
          handler[3] = &unk_100088F38;
          int v61 = v25;
          dispatch_source_set_event_handler(v28, handler);
          int v29 = v0[3];
          v58[0] = _NSConcreteStackBlock;
          v58[1] = 0x40000000;
          v58[2] = sub_100023CDC;
          v58[3] = &unk_100088F58;
          int v59 = v25;
          v58[4] = v29;
          dispatch_source_set_cancel_handler(v29, v58);
          dispatch_resume((dispatch_object_t)v0[3]);
          if (dword_10008FA20)
          {
            __int16 v30 = ne_log_obj();
            if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
            {
              int v31 = sub_10003CAE4((const sockaddr *)v0[1]);
              int v32 = *((_DWORD *)v0 + 4);
              *(_DWORD *)buf = 136315394;
              *(void *)&uint8_t buf[4] = v31;
              *(_WORD *)&buf[12] = 1024;
              *(_DWORD *)&unsigned char buf[14] = v32;
              _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_DEFAULT, "%s used as isakmp port (fd=%d)\n", buf, 0x12u);
            }
          }
          goto LABEL_107;
        }
        int v40 = *__error();
        if (dword_10008FA20)
        {
          int v41 = ne_log_obj();
          if (os_log_type_enabled(v41, OS_LOG_TYPE_ERROR))
          {
            uint64_t v57 = sub_10003CAE4((const sockaddr *)*v5);
            long long v49 = strerror(v40);
            *(_DWORD *)buf = 136315394;
            *(void *)&uint8_t buf[4] = v57;
            *(_WORD *)&buf[12] = 2080;
            *(void *)&unsigned char buf[14] = v49;
            _os_log_error_impl((void *)&_mh_execute_header, v41, OS_LOG_TYPE_ERROR, "failed to bind to address %s (%s).\n", buf, 0x16u);
          }
        }
        if (v40 != 49 || *(unsigned char *)(*v5 + 1) != 30) {
          goto LABEL_104;
        }
        long long v84 = 0u;
        long long v85 = 0u;
        long long v82 = 0u;
        long long v83 = 0u;
        long long v80 = 0u;
        long long v81 = 0u;
        long long v78 = 0u;
        long long v79 = 0u;
        long long v76 = 0u;
        long long v77 = 0u;
        long long v74 = 0u;
        long long v75 = 0u;
        long long v72 = 0u;
        long long v73 = 0u;
        long long v71 = 0u;
        memset(buf, 0, sizeof(buf));
        __strlcpy_chk();
        long long v42 = (_OWORD *)v0[1];
        long long v43 = *(_OWORD *)((char *)v42 + 12);
        *(_OWORD *)&uint8_t buf[16] = *v42;
        *(_OWORD *)&buf[28] = v43;
        if (ioctl(*((_DWORD *)v0 + 4), 0xC1206949uLL, buf) < 0)
        {
          if (dword_10008FA20)
          {
            uint64_t v47 = ne_log_obj();
            if (os_log_type_enabled(v47, OS_LOG_TYPE_ERROR)) {
              sub_10005F2D4((uint64_t)v65, (const sockaddr **)v0 + 1);
            }
          }
LABEL_104:
          close(*((_DWORD *)v0 + 4));
          *((_DWORD *)v0 + 4) = -1;
LABEL_105:
          free((void *)v0[1]);
          v0[1] = 0;
          *((_DWORD *)v0 + 4) = -1;
          if (!*(_DWORD *)(qword_10008F848 + 112) && *(_DWORD *)(qword_10008F848 + 308)) {
            return 0xFFFFFFFFLL;
          }
          goto LABEL_107;
        }
        if ((buf[16] & 0x1D) != 0)
        {
          if (dword_10008FA20)
          {
            uint64_t v44 = ne_log_obj();
            if (os_log_type_enabled(v44, OS_LOG_TYPE_ERROR))
            {
              long long v45 = sub_10003CAE4((const sockaddr *)*v5);
              *(_DWORD *)__int16 v66 = 136315394;
              char v67 = v45;
              __int16 v68 = 1024;
              int v69 = *(_DWORD *)&buf[16];
              _os_log_error_impl((void *)&_mh_execute_header, v44, OS_LOG_TYPE_ERROR, "failed to bind to address %s: because of interface address error, flags %x.\n", v66, 0x12u);
            }
          }
          goto LABEL_104;
        }
        if (dword_10008FA20)
        {
          uint64_t v48 = ne_log_obj();
          if (os_log_type_enabled(v48, OS_LOG_TYPE_ERROR))
          {
            uint64_t v50 = sub_10003CAE4((const sockaddr *)*v5);
            *(_DWORD *)__int16 v66 = 136315394;
            char v67 = v50;
            __int16 v68 = 1024;
            int v69 = *(_DWORD *)&buf[16];
            _os_log_error_impl((void *)&_mh_execute_header, v48, OS_LOG_TYPE_ERROR, "failed to bind to address %s: because interface address is/was not ready (flags %x).\n", v66, 0x12u);
          }
        }
        close(*((_DWORD *)v0 + 4));
        *((_DWORD *)v0 + 4) = -1;
        int v2 = 1;
      }
LABEL_107:
      uint64_t v0 = (uint64_t *)*v0;
      if (!v0)
      {
        if (!v1) {
          goto LABEL_125;
        }
        if (sub_1000404AC() && !v3 && dword_10008FA20)
        {
          uint64_t v51 = ne_log_obj();
          if (os_log_type_enabled(v51, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)buf = 0;
            _os_log_impl((void *)&_mh_execute_header, v51, OS_LOG_TYPE_DEFAULT, "NAT-T is enabled in at least one remote{} section,\n", buf, 2u);
          }
          if (dword_10008FA20)
          {
            long long v52 = ne_log_obj();
            if (os_log_type_enabled(v52, OS_LOG_TYPE_DEFAULT))
            {
              *(_WORD *)buf = 0;
              _os_log_impl((void *)&_mh_execute_header, v52, OS_LOG_TYPE_DEFAULT, "but no 'isakmp_natt' address was specified!\n", buf, 2u);
            }
          }
        }
        if (v2) {
          sub_10003AA24(5, (uint64_t)sub_100006DE8, 0);
        }
        return 0;
      }
    }
    if (v6 != 2)
    {
      if (dword_10008FA20)
      {
        unsigned int v19 = ne_log_obj();
        if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR)) {
          sub_10005F0BC(v86, &v87, v19);
        }
      }
      goto LABEL_105;
    }
    if (*(_DWORD *)(v4 + 4)) {
      BOOL v7 = 1;
    }
    else {
      BOOL v7 = dword_10008FA20 == 0;
    }
    if (v7) {
      goto LABEL_26;
    }
    unsigned int v8 = ne_log_obj();
    if (!os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_26;
    }
    *(_WORD *)buf = 0;
    unint64_t v9 = v8;
    char v10 = "listening to wildcard address,broadcast IKE packet may kill you\n";
    goto LABEL_16;
  }
LABEL_125:
  if (dword_10008FA20)
  {
    uint64_t v54 = ne_log_obj();
    if (os_log_type_enabled(v54, OS_LOG_TYPE_ERROR)) {
      sub_10005F088();
    }
  }
  return 0xFFFFFFFFLL;
}

void *sub_100023B9C()
{
  sub_100023D5C();

  return sub_1000062AC();
}

void sub_100023BC4()
{
  sub_100009338();

  sub_100008BC8();
}

long long *sub_100023BEC(uint64_t a1, unsigned int a2)
{
  uint64_t v4 = 0;
  int v5 = 0;
  xmmword_10008C768 = 0u;
  unk_10008C778 = 0u;
  xmmword_10008C748 = 0u;
  unk_10008C758 = 0u;
  do
  {
    snprintf((char *)&xmmword_10008C748 + v5, 64 - v5, "%02x", *(unsigned __int8 *)(a1 + v4));
    uint64_t v6 = v5 + 2;
    if (v4 == 7)
    {
      *((unsigned char *)&xmmword_10008C748 + v6) = 58;
      LODWORD(v6) = v5 + 3;
    }
    ++v4;
    int v5 = v6;
  }
  while (v4 != 16);
  if (a2) {
    snprintf((char *)&xmmword_10008C748 + (int)v6, 64 - (int)v6, ":%08x", bswap32(a2) >> 16);
  }
  return &xmmword_10008C748;
}

void sub_100023CD4(uint64_t a1)
{
}

void sub_100023CDC(uint64_t a1)
{
  close(*(_DWORD *)(a1 + 40));
  int v2 = *(NSObject **)(a1 + 32);

  dispatch_release(v2);
}

void sub_100023D18()
{
  for (uint64_t i = *(void **)(qword_10008F848 + 120); i; uint64_t i = (void *)*i)
  {
    int v1 = i[3];
    if (v1) {
      dispatch_suspend(v1);
    }
  }
}

void sub_100023D5C()
{
  for (uint64_t i = *(uint64_t **)(qword_10008F848 + 120); i; uint64_t i = (uint64_t *)*i)
  {
    if (i[1])
    {
      int v1 = i[3];
      if (v1)
      {
        dispatch_source_cancel(v1);
        i[3] = 0;
        *((_DWORD *)i + 9) = 0;
        *((_DWORD *)i + 4) = -1;
      }
    }
  }
}

void sub_100023DB8()
{
  int v1 = (void *)(qword_10008F848 + 120);
  uint64_t v0 = *(uint64_t **)(qword_10008F848 + 120);
  if (v0)
  {
    do
    {
      int v2 = (uint64_t *)*v0;
      if (*((_DWORD *)v0 + 9))
      {
        int v1 = v0;
      }
      else
      {
        int v3 = v0[3];
        uint64_t v4 = (uint64_t *)*v0;
        if (v3)
        {
          dispatch_source_cancel(v3);
          v0[3] = 0;
          uint64_t v4 = (uint64_t *)*v0;
        }
        *int v1 = v4;
        sub_1000062F4(v0);
      }
      uint64_t v0 = v2;
    }
    while (v2);
  }
}

uint64_t sub_100023E30(uint64_t a1, size_t *a2)
{
  int v2 = a2;
  unsigned int v4 = (*(_DWORD *)(a1 + 96) >> 3) & 4;
  if (*(_DWORD *)(a1 + 100) && *a2 > 0x500) {
    unsigned int v4 = 0;
  }
  uint64_t v5 = v4;
  if (v4) {
    BOOL v6 = dword_10008FA20 == 0;
  }
  else {
    BOOL v6 = 1;
  }
  if (v6)
  {
    if (!v4)
    {
      BOOL v7 = 0;
      goto LABEL_15;
    }
  }
  else
  {
    unsigned int v8 = ne_log_obj();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG)) {
      sub_10005F52C();
    }
  }
  char v10 = sub_10003F940(*v2 + v5);
  if (!v10)
  {
    if (dword_10008FA20)
    {
      int v17 = ne_log_obj();
      if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR)) {
        sub_10005F490();
      }
    }
    return 0xFFFFFFFFLL;
  }
  BOOL v7 = v10;
  int v11 = (_DWORD *)v10[1];
  *int v11 = 0;
  memcpy((char *)v11 + v5, (const void *)v2[1], *v2);
  int v2 = v7;
LABEL_15:
  int v12 = sub_100006E58(*(unsigned __int8 **)(a1 + 56));
  if (v12 == -1) {
    goto LABEL_35;
  }
  int v13 = v12;
  if (dword_10008FA20)
  {
    int v14 = ne_log_obj();
    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG))
    {
      size_t v20 = *v2;
      int v21 = sub_10003D0A8("from %s to %s", *(const sockaddr **)(a1 + 56), *(sockaddr **)(a1 + 48));
      int v22 = 134218242;
      size_t v23 = v20;
      __int16 v24 = 2080;
      int v25 = v21;
      _os_log_debug_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEBUG, "%zu bytes %s\n", (uint8_t *)&v22, 0x16u);
    }
  }
  unint64_t v15 = *v2;
  if (!*(_DWORD *)(a1 + 100) || v15 < 0x501)
  {
    if (sub_10003C350(v13, (const void *)v2[1], v15, *(unsigned __int8 **)(a1 + 56), *(unsigned __int8 **)(a1 + 48), *(_DWORD *)(qword_10008F848 + 276)) != -1)goto LABEL_30; {
    if (dword_10008FA20)
    }
    {
      unsigned int v19 = ne_log_obj();
      if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
      {
        sub_10005F4F8();
        if (!v7) {
          return 0xFFFFFFFFLL;
        }
        goto LABEL_36;
      }
    }
LABEL_35:
    if (!v7) {
      return 0xFFFFFFFFLL;
    }
LABEL_36:
    sub_10003FA78(v7);
    return 0xFFFFFFFFLL;
  }
  if (sub_1000149B4(a1, v2) == -1)
  {
    if (dword_10008FA20)
    {
      __int16 v16 = ne_log_obj();
      if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
      {
        sub_10005F4C4();
        if (!v7) {
          return 0xFFFFFFFFLL;
        }
        goto LABEL_36;
      }
    }
    goto LABEL_35;
  }
LABEL_30:
  if (v7) {
    sub_10003FA78(v7);
  }
  return 0;
}

uint64_t sub_1000240AC(uint64_t a1)
{
  uint64_t result = sub_100024104();
  if ((result & 0x80000000) != 0)
  {
    uint64_t v3 = *(unsigned int *)(a1 + 120);
    if (v3)
    {
      sub_10003AC14(v3);
      *(_DWORD *)(a1 + 120) = 0;
    }
    return sub_10004B710(a1);
  }
  return result;
}

uint64_t sub_100024104(uint64_t a1)
{
  if (!*(void *)(a1 + 128)) {
    return 0xFFFFFFFFLL;
  }
  if (*(int *)(a1 + 124) > 0)
  {
    sub_10004FD58(a1);
    if ((sub_100023E30(a1, *(size_t **)(a1 + 128)) & 0x80000000) == 0)
    {
      if (dword_10008FA20)
      {
        int v2 = ne_log_obj();
        if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
        {
          sub_100023BEC(a1, *(_DWORD *)(a1 + 84));
          int v10 = 136315138;
          int v11 = &xmmword_10008C748;
          _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Resend Phase 1 packet %s\n", (uint8_t *)&v10, 0xCu);
        }
      }
      int v3 = *(_DWORD *)(a1 + 124) - 1;
      *(_DWORD *)(a1 + 124) = v3;
      uint64_t v4 = sub_100008C64(*(_DWORD *)(*(void *)(a1 + 64) + 200) - v3, *(_DWORD *)(*(void *)(a1 + 64) + 204));
      unsigned int v5 = sub_10003AA24(v4, (uint64_t)sub_1000240AC, a1);
      uint64_t result = 0;
      *(_DWORD *)(a1 + 120) = v5;
      return result;
    }
    if (dword_10008FA20)
    {
      unint64_t v9 = ne_log_obj();
      if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR)) {
        sub_10005F5E8(a1);
      }
    }
    return 0xFFFFFFFFLL;
  }
  if (dword_10008FA20)
  {
    BOOL v7 = ne_log_obj();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR)) {
      sub_10005F560(a1);
    }
  }
  if (*(_DWORD *)(a1 + 20)) {
    return 0xFFFFFFFFLL;
  }
  if ((*(unsigned char *)(a1 + 432) & 1) == 0) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v8 = *(void *)(a1 + 440);
  if (!v8) {
    return 0xFFFFFFFFLL;
  }
  if ((*(_WORD *)(v8 + 264) & 0x400) == 0) {
    return 0xFFFFFFFFLL;
  }
  uint64_t result = sub_1000242C4(a1);
  if (result) {
    return 0xFFFFFFFFLL;
  }
  return result;
}

uint64_t sub_1000242C4(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 112) || *(_DWORD *)(a1 + 116)) {
    return 0xFFFFFFFFLL;
  }
  int v3 = *(_DWORD *)(a1 + 16);
  BOOL v4 = v3 == 5281 || v3 == 5217;
  if (!v4
    || (*(unsigned char *)(a1 + 96) & 8) == 0
    || sub_10003D80C(*(void *)(a1 + 56)) != 4500
    && sub_10003D80C(*(void *)(a1 + 48)) != 4500
    || (*(unsigned char *)(a1 + 432) & 2) != 0)
  {
    return 0xFFFFFFFFLL;
  }
  unsigned int v5 = sub_10003CAE4(*(const sockaddr **)(a1 + 56));
  BOOL v6 = strdup((const char *)v5);
  BOOL v7 = (uint64_t *)(a1 + 48);
  uint64_t v8 = sub_10003CAE4(*(const sockaddr **)(a1 + 48));
  unint64_t v9 = strdup((const char *)v8);
  if (!v6)
  {
    if (dword_10008FA20)
    {
      size_t v20 = ne_log_obj();
      if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR)) {
        goto LABEL_50;
      }
    }
    goto LABEL_51;
  }
  int v10 = v9;
  if (!v9)
  {
    if (dword_10008FA20)
    {
      int v21 = ne_log_obj();
      if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR)) {
LABEL_50:
      }
        sub_10005ED40();
    }
LABEL_51:
    exit(1);
  }
  if (dword_10008FA20)
  {
    int v11 = ne_log_obj();
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      sub_100023BEC(a1, 0);
      int v22 = 136315650;
      size_t v23 = v6;
      __int16 v24 = 2080;
      int v25 = v10;
      __int16 v26 = 2080;
      int v27 = &xmmword_10008C748;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "ISAKMP-SA rekey failed... retrying %s-%s spi:%s\n", (uint8_t *)&v22, 0x20u);
    }
  }
  free(v6);
  free(v10);
  if (!sub_10004F234(*(void *)(a1 + 440), 1))
  {
    if (sub_10004CA6C(*(void *)(a1 + 440), a1))
    {
      if (!dword_10008FA20) {
        return 0xFFFFFFFFLL;
      }
      int v14 = ne_log_obj();
      if (!os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT)) {
        return 0xFFFFFFFFLL;
      }
      LOWORD(v22) = 0;
      unint64_t v15 = "request to retry ISAKMP-SA rekey was ignored due to another established ph1.\n";
    }
    else
    {
      if (sub_10003D80C(*(void *)(a1 + 56)) == 4500) {
        sub_10003D910(*(void *)(a1 + 56), 0x1F4u);
      }
      if (sub_10003D80C(*v7) == 4500) {
        sub_10003D910(*v7, 0x1F4u);
      }
      *(_DWORD *)(a1 + 96) &= ~8u;
      __int16 v16 = sub_1000388FC(*(sockaddr **)(a1 + 48));
      if (!v16)
      {
        if (dword_10008FA20)
        {
          unsigned int v19 = ne_log_obj();
          if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR)) {
            sub_10005F670((const sockaddr **)v7);
          }
        }
        return 0xFFFFFFFFLL;
      }
      int v17 = v16;
      if (dword_10008FA20)
      {
        __int16 v18 = ne_log_obj();
        if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
        {
          LOWORD(v22) = 0;
          _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "begin Phase 1 rekey retry.\n", (uint8_t *)&v22, 2u);
        }
      }
      if ((sub_100021EA8(*(void *)(a1 + 440), v17, *(void *)(a1 + 48), *(void *)(a1 + 56), 0, a1 + 28) & 0x80000000) == 0)
      {
        uint64_t result = 0;
        *(unsigned char *)(a1 + 432) |= 1u;
        return result;
      }
      if (!dword_10008FA20) {
        return 0xFFFFFFFFLL;
      }
      int v14 = ne_log_obj();
      if (!os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT)) {
        return 0xFFFFFFFFLL;
      }
      LOWORD(v22) = 0;
      unint64_t v15 = "Phase 1 rekey retry Failed.\n";
    }
    _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, v15, (uint8_t *)&v22, 2u);
    return 0xFFFFFFFFLL;
  }
  if (!dword_10008FA20) {
    return 0;
  }
  int v12 = ne_log_obj();
  BOOL v13 = os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT);
  uint64_t result = 0;
  if (v13)
  {
    LOWORD(v22) = 0;
    _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "request for ISAKMP-SA rekey was ignored due to idleness.\n", (uint8_t *)&v22, 2u);
    return 0;
  }
  return result;
}

uint64_t sub_100024678(void *a1)
{
  uint64_t result = sub_1000246C0();
  if ((result & 0x80000000) != 0)
  {
    return sub_10004B62C(a1);
  }
  return result;
}

uint64_t sub_1000246C0(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 256);
  if (!v1)
  {
    if (dword_10008FA20)
    {
      BOOL v7 = ne_log_obj();
      if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR)) {
        sub_10005F6EC();
      }
    }
    return 0xFFFFFFFFLL;
  }
  int v3 = (uint64_t *)(a1 + 256);
  if ((*(unsigned char *)(v1 + 17) & 0x40) != 0)
  {
    if (dword_10008FA20)
    {
      uint64_t v8 = ne_log_obj();
      if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR)) {
        sub_10005F820(v3, a1);
      }
    }
    return 0xFFFFFFFFLL;
  }
  if (*(int *)(a1 + 72) <= 0)
  {
    if (dword_10008FA20)
    {
      unint64_t v9 = ne_log_obj();
      if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR)) {
        sub_10005F720(v3, a1);
      }
    }
    return 0xFFFFFFFFLL;
  }
  sub_10004FC6C(a1);
  if ((sub_100023E30(*(void *)(a1 + 256), *(size_t **)(a1 + 80)) & 0x80000000) != 0)
  {
    if (dword_10008FA20)
    {
      int v10 = ne_log_obj();
      if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR)) {
        sub_10005F7A0(v3, a1);
      }
    }
    return 0xFFFFFFFFLL;
  }
  if (dword_10008FA20)
  {
    BOOL v4 = ne_log_obj();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      sub_100023BEC(*(void *)(a1 + 256), *(_DWORD *)(a1 + 108));
      int v11 = 136315138;
      int v12 = &xmmword_10008C748;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Resend Phase 2 packet %s\n", (uint8_t *)&v11, 0xCu);
    }
  }
  --*(_DWORD *)(a1 + 72);
  uint64_t v5 = sub_100008C64(*(_DWORD *)(*(void *)(*(void *)(a1 + 256) + 64) + 200) - *(_DWORD *)(*(void *)(a1 + 256) + 124), *(_DWORD *)(*(void *)(*(void *)(a1 + 256) + 64) + 204));
  uint64_t result = (uint64_t)sub_10003AA24(v5, (uint64_t)sub_100024678, a1);
  *(_DWORD *)(a1 + 68) = result;
  if (result)
  {
    sub_10001C398(*v3, (uint64_t)"Phase 2 packets sent to peer: retransmit timer armed");
    return 0;
  }
  return result;
}

void sub_1000248F0(uint64_t a1, int a2)
{
  uint64_t v4 = *(unsigned int *)(a1 + 116);
  if (v4)
  {
    sub_10003AC14(v4);
    *(_DWORD *)(a1 + 116) = 0;
  }
  if (*(_DWORD *)(a1 + 112)
    || (uint64_t v13 = *(void *)(*(void *)(a1 + 72) + 24)) != 0
    && (unsigned int v14 = sub_10003AA24(v13, (uint64_t)sub_100022A40, a1), (*(_DWORD *)(a1 + 112) = v14) != 0))
  {
    if ((*(unsigned char *)(a1 + 17) & 0x20) != 0 && (*(unsigned char *)(a1 + 432) & 2) == 0)
    {
      uint64_t v5 = sub_10003CAE4(*(const sockaddr **)(a1 + 56));
      BOOL v6 = strdup((const char *)v5);
      BOOL v7 = (const sockaddr **)(a1 + 48);
      uint64_t v8 = sub_10003CAE4(*(const sockaddr **)(a1 + 48));
      unint64_t v9 = strdup((const char *)v8);
      if (v6)
      {
        int v10 = v9;
        if (v9)
        {
          if (dword_10008FA20)
          {
            int v11 = ne_log_obj();
            if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
            {
              sub_100023BEC(a1, 0);
              int v22 = 136315650;
              size_t v23 = v6;
              __int16 v24 = 2080;
              int v25 = v10;
              __int16 v26 = 2080;
              int v27 = &xmmword_10008C748;
              _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "ISAKMP-SA rekey-timer expired %s-%s spi:%s\n", (uint8_t *)&v22, 0x20u);
            }
          }
          free(v6);
          free(v10);
          if (a2 || !sub_10004F234(*(void *)(a1 + 440), 1))
          {
            if (sub_10004CA6C(*(void *)(a1 + 440), a1))
            {
              if (dword_10008FA20)
              {
                int v12 = ne_log_obj();
                if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
                {
                  LOWORD(v22) = 0;
                  _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "Request for ISAKMP-SA rekey was ignored due to another established ph1.\n", (uint8_t *)&v22, 2u);
                }
              }
            }
            else if (sub_10004CAB0(*(void *)(a1 + 440), a1))
            {
              if (dword_10008FA20)
              {
                unint64_t v15 = ne_log_obj();
                if (os_log_type_enabled(v15, OS_LOG_TYPE_DEBUG)) {
                  sub_10005F91C();
                }
              }
              *(_DWORD *)(a1 + 116) = sub_10003AA24(1, (uint64_t)sub_100022A44, a1);
            }
            else
            {
              __int16 v16 = *(_DWORD **)(a1 + 64);
              if (v16 || (__int16 v16 = sub_1000388FC((sockaddr *)*v7)) != 0)
              {
                if (dword_10008FA20)
                {
                  int v17 = ne_log_obj();
                  if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
                  {
                    LOWORD(v22) = 0;
                    _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "Begin Phase 1 rekey.\n", (uint8_t *)&v22, 2u);
                  }
                }
                if ((sub_100021EA8(*(void *)(a1 + 440), (uint64_t)v16, *(void *)(a1 + 48), *(void *)(a1 + 56), 0, (_OWORD *)(a1 + 28)) & 0x80000000) != 0)
                {
                  if (dword_10008FA20)
                  {
                    __int16 v18 = ne_log_obj();
                    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
                    {
                      LOWORD(v22) = 0;
                      _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "Phase 1 rekey Failed.\n", (uint8_t *)&v22, 2u);
                    }
                  }
                }
                *(unsigned char *)(a1 + 432) |= 1u;
              }
              else if (dword_10008FA20)
              {
                unsigned int v19 = ne_log_obj();
                if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR)) {
                  sub_10005F8A0(v7);
                }
              }
            }
          }
          return;
        }
        if (dword_10008FA20)
        {
          int v21 = ne_log_obj();
          if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR)) {
            goto LABEL_45;
          }
        }
      }
      else if (dword_10008FA20)
      {
        size_t v20 = ne_log_obj();
        if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR)) {
LABEL_45:
        }
          sub_10005ED40();
      }
      exit(1);
    }
  }
}

void *sub_100024C84(uint64_t a1)
{
  uint64_t v2 = *(unsigned int *)(a1 + 112);
  if (v2)
  {
    sub_10003AC14(v2);
    *(_DWORD *)(a1 + 112) = 0;
  }
  uint64_t v3 = *(unsigned int *)(a1 + 116);
  if (v3)
  {
    sub_10003AC14(v3);
    *(_DWORD *)(a1 + 116) = 0;
  }
  uint64_t v4 = *(unsigned int *)(a1 + 388);
  if (v4)
  {
    sub_10003AC14(v4);
    *(_DWORD *)(a1 + 388) = 0;
  }
  if (*(void *)(a1 + 448))
  {
    uint64_t result = sub_10003AA24(1, (uint64_t)sub_1000248EC, a1);
    *(_DWORD *)(a1 + 112) = result;
    return result;
  }
  sub_10001A098(a1);
  BOOL v6 = sub_10003CAE4(*(const sockaddr **)(a1 + 56));
  BOOL v7 = strdup((const char *)v6);
  uint64_t v8 = sub_10003CAE4(*(const sockaddr **)(a1 + 48));
  unint64_t v9 = strdup((const char *)v8);
  if (!v7)
  {
    if (dword_10008FA20)
    {
      uint64_t v13 = ne_log_obj();
      if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR)) {
        goto LABEL_23;
      }
    }
    goto LABEL_24;
  }
  int v10 = v9;
  if (!v9)
  {
    if (dword_10008FA20)
    {
      unsigned int v14 = ne_log_obj();
      if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR)) {
LABEL_23:
      }
        sub_10005ED40();
    }
LABEL_24:
    exit(1);
  }
  if (dword_10008FA20)
  {
    int v11 = ne_log_obj();
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      sub_100023BEC(a1, 0);
      int v15 = 136315138;
      __int16 v16 = &xmmword_10008C748;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "ISAKMP-SA deleted spi:%s\n", (uint8_t *)&v15, 0xCu);
    }
    if (dword_10008FA20)
    {
      int v12 = ne_log_obj();
      if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG))
      {
        sub_100023BEC(a1, 0);
        int v15 = 136315650;
        __int16 v16 = (long long *)v7;
        __int16 v17 = 2080;
        __int16 v18 = v10;
        __int16 v19 = 2080;
        size_t v20 = &xmmword_10008C748;
        _os_log_debug_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEBUG, "ISAKMP-SA deleted %s-%s spi:%s\n", (uint8_t *)&v15, 0x20u);
      }
    }
  }
  free(v7);
  free(v10);
  return (void *)sub_10004B710(a1);
}

void *sub_100024ED0(void *result)
{
  if ((*((unsigned char *)result + 57) & 0x40) != 0) {
    return result;
  }
  uint64_t v1 = (uint64_t)result;
  uint64_t v2 = *((unsigned int *)result + 16);
  if (v2)
  {
    sub_10003AC14(v2);
    *(_DWORD *)(v1 + 64) = 0;
  }
  uint64_t v3 = sub_10003CE24(*(const sockaddr **)v1);
  uint64_t v4 = strdup(v3);
  uint64_t v5 = sub_10003CE24(*(const sockaddr **)(v1 + 8));
  BOOL v6 = strdup(v5);
  if (!v4)
  {
    if (dword_10008FA20)
    {
      uint64_t v13 = ne_log_obj();
      if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR)) {
        goto LABEL_24;
      }
    }
    goto LABEL_25;
  }
  BOOL v7 = v6;
  if (!v6)
  {
    if (dword_10008FA20)
    {
      unsigned int v14 = ne_log_obj();
      if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR)) {
LABEL_24:
      }
        sub_10005ED40();
    }
LABEL_25:
    exit(1);
  }
  if (dword_10008FA20)
  {
    uint64_t v8 = ne_log_obj();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      int v15 = 136315394;
      __int16 v16 = v4;
      __int16 v17 = 2080;
      __int16 v18 = v7;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "Phase 2 sa expired %s-%s\n", (uint8_t *)&v15, 0x16u);
    }
  }
  free(v4);
  free(v7);
  if ((*(unsigned char *)(v1 + 57) & 0x20) != 0)
  {
    uint64_t v9 = *(void *)(v1 + 128);
    if (v9)
    {
      for (uint64_t i = *(void *)(v9 + 32); i; uint64_t i = *(void *)(i + 72))
      {
        if (*(_DWORD *)(i + 56))
        {
          int v11 = *(_DWORD *)(qword_10008F848 + 32);
          char v12 = sub_10002F070(*(_DWORD *)i);
          sub_100041398(v11, v12, 0, *(unsigned __int8 **)v1, *(unsigned __int8 **)(v1 + 8), *(_DWORD *)(i + 28));
        }
      }
    }
  }
  if (*(unsigned char *)(v1 + 61) == 16) {
    sub_100002728((int *)(v1 + 56), 18432);
  }
  uint64_t result = sub_10003AA24(1, (uint64_t)sub_1000250D4, v1);
  *(_DWORD *)(v1 + 64) = result;
  return result;
}

uint64_t sub_1000250D8(uint64_t a1)
{
  uint64_t v2 = *(unsigned int *)(a1 + 64);
  if (v2)
  {
    sub_10003AC14(v2);
    *(_DWORD *)(a1 + 64) = 0;
  }
  uint64_t v3 = sub_10003CE24(*(const sockaddr **)a1);
  uint64_t v4 = strdup(v3);
  uint64_t v5 = sub_10003CE24(*(const sockaddr **)(a1 + 8));
  BOOL v6 = strdup(v5);
  if (!v4)
  {
    if (dword_10008FA20)
    {
      int v10 = ne_log_obj();
      if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR)) {
        goto LABEL_14;
      }
    }
    goto LABEL_15;
  }
  BOOL v7 = v6;
  if (!v6)
  {
    if (dword_10008FA20)
    {
      int v11 = ne_log_obj();
      if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR)) {
LABEL_14:
      }
        sub_10005ED40();
    }
LABEL_15:
    exit(1);
  }
  if (dword_10008FA20)
  {
    uint64_t v8 = ne_log_obj();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      int v12 = 136315394;
      uint64_t v13 = v4;
      __int16 v14 = 2080;
      int v15 = v7;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "Phase 2 sa deleted %s-%s\n", (uint8_t *)&v12, 0x16u);
    }
  }
  free(v4);
  free(v7);
  return sub_10004B62C((void *)a1);
}

uint64_t sub_100025240(uint64_t a1)
{
  if (dword_10008FA20)
  {
    uint64_t v2 = ne_log_obj();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEBUG)) {
      sub_10005F9CC();
    }
  }
  uint64_t v3 = (const sockaddr **)(a1 + 8);
  uint64_t v4 = sub_1000388FC(*(sockaddr **)(a1 + 8));
  if (!v4)
  {
    if (dword_10008FA20)
    {
      uint64_t v13 = ne_log_obj();
      if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR)) {
        sub_10005F950(v3);
      }
    }
    return 0xFFFFFFFFLL;
  }
  uint64_t v5 = (uint64_t)v4;
  if (v4[36])
  {
    if (!dword_10008FA20) {
      return 0;
    }
    BOOL v6 = ne_log_obj();
    BOOL v7 = os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT);
    uint64_t result = 0;
    if (v7)
    {
      uint64_t v9 = sub_10003CE24(*v3);
      int v25 = 136315138;
      __int16 v26 = v9;
      int v10 = "Because of passive mode, ignore the acquire message for %s.\n";
      int v11 = v6;
      uint32_t v12 = 12;
LABEL_9:
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, v10, (uint8_t *)&v25, v12);
      return 0;
    }
    return result;
  }
  if (sub_10004CBD0(*(void *)(a1 + 272), a1))
  {
    if (dword_10008FA20)
    {
      __int16 v14 = ne_log_obj();
      if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(v25) = 0;
        _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "Request for establishing IPsec-SA was ignored due to another negoing ph2.\n", (uint8_t *)&v25, 2u);
      }
    }
    return 0xFFFFFFFFLL;
  }
  if (*(unsigned char *)(a1 + 264)) {
    sub_10004DCF4((uint64_t *)a1);
  }
  if (*(unsigned char *)(a1 + 61) != 16 || (uint64_t v15 = sub_10004C85C(a1)) == 0)
  {
    *(_DWORD *)(a1 + 96) = *(_DWORD *)(qword_10008F848 + 280);
    sub_10003AA24(1, (uint64_t)sub_10002561C, a1);
    if (dword_10008FA20)
    {
      __int16 v19 = ne_log_obj();
      if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
      {
        size_t v20 = sub_10003CE24(*v3);
        int v25 = 136315138;
        __int16 v26 = v20;
        _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "IPsec-SA request for %s queued due to no Phase 1 found.\n", (uint8_t *)&v25, 0xCu);
      }
    }
    if (sub_10004E538(*(void *)(a1 + 272)))
    {
      if (!dword_10008FA20) {
        return 0;
      }
      __int16 v17 = ne_log_obj();
      BOOL v21 = os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT);
      uint64_t result = 0;
      if (!v21) {
        return result;
      }
      LOWORD(v25) = 0;
      int v10 = "Request for Phase 1 was ignored due to another negotiating Phase 1.\n";
    }
    else
    {
      int v22 = sub_100021EA8(*(void *)(a1 + 272), v5, *(void *)(a1 + 8), *(void *)a1, 0, (_OWORD *)(a1 + 16));
      uint64_t result = 0;
      if ((v22 & 0x80000000) == 0) {
        return result;
      }
      if (!dword_10008FA20) {
        return result;
      }
      __int16 v17 = ne_log_obj();
      BOOL v23 = os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT);
      uint64_t result = 0;
      if (!v23) {
        return result;
      }
      LOWORD(v25) = 0;
      int v10 = "Request for Phase 1 failed. Will try later.\n";
    }
LABEL_39:
    int v11 = v17;
    uint32_t v12 = 2;
    goto LABEL_9;
  }
  uint64_t v16 = v15;
  if ((*(unsigned char *)(v15 + 17) & 0x20) != 0)
  {
    if (dword_10008FA20)
    {
      __int16 v24 = ne_log_obj();
      if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(v25) = 0;
        _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "Begin QUICK mode.\n", (uint8_t *)&v25, 2u);
      }
    }
    if (sub_100025620(v16, a1)) {
      return 0xFFFFFFFFLL;
    }
    else {
      return 0;
    }
  }
  *(_DWORD *)(a1 + 96) = *(_DWORD *)(qword_10008F848 + 280);
  sub_10003AA24(1, (uint64_t)sub_10002561C, a1);
  if (!dword_10008FA20) {
    return 0;
  }
  __int16 v17 = ne_log_obj();
  BOOL v18 = os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT);
  uint64_t result = 0;
  if (v18)
  {
    LOWORD(v25) = 0;
    int v10 = "Request for establishing IPsec-SA was queued due to no phase1 found.\n";
    goto LABEL_39;
  }
  return result;
}

uint64_t sub_100025620(uint64_t a1, uint64_t a2)
{
  if (sub_1000471C0((void *)a1))
  {
    if (dword_10008FA20)
    {
      uint64_t v4 = ne_log_obj();
      if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR)) {
        sub_10005FA34();
      }
    }
    return 0xFFFFFFFFLL;
  }
  if (dword_10008FA20)
  {
    uint64_t v5 = ne_log_obj();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG)) {
      sub_10005EEB4();
    }
    if (dword_10008FA20)
    {
      BOOL v6 = ne_log_obj();
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG)) {
        sub_10005FA00();
      }
    }
  }
  BOOL v7 = sub_10003CAE4(*(const sockaddr **)a2);
  uint64_t v8 = strdup((const char *)v7);
  if (!v8)
  {
    if (dword_10008FA20)
    {
      __int16 v14 = ne_log_obj();
      if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR)) {
        sub_10005ED40();
      }
    }
    exit(1);
  }
  uint64_t v9 = v8;
  if (dword_10008FA20)
  {
    int v10 = ne_log_obj();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      int v11 = sub_10003CAE4(*(const sockaddr **)(a2 + 8));
      int v15 = 136315394;
      uint64_t v16 = v9;
      __int16 v17 = 2080;
      BOOL v18 = v11;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "initiate new phase 2 negotiation: %s<=>%s\n", (uint8_t *)&v15, 0x16u);
    }
  }
  free(v9);
  *(unsigned char *)(a2 + 264) &= ~2u;
  *(_OWORD *)(a2 + 16) = *(_OWORD *)(a1 + 28);
  sub_100002728((int *)(a2 + 56), 6336);
  if (dword_10008FA20)
  {
    uint32_t v12 = ne_log_obj();
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v15) = 0;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "IPSec Phase 2 started (Initiated by me).\n", (uint8_t *)&v15, 2u);
    }
  }
  if (sub_10001C4F8(a2)) {
    return 0xFFFFFFFFLL;
  }
  sub_1000496DC(1, 0, 0, a2);
  return 0;
}

uint64_t sub_100025848(uint64_t a1)
{
  if ((*(unsigned char *)(*(void *)(a1 + 256) + 17) & 0x40) != 0)
  {
    if (dword_10008FA20)
    {
      uint64_t v4 = ne_log_obj();
      if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR)) {
        sub_10005FA68();
      }
    }
    return 0xFFFFFFFFLL;
  }
  uint64_t v2 = (int *)(a1 + 56);
  if (*(unsigned char *)(a1 + 60)) {
    int v3 = 6608;
  }
  else {
    int v3 = 6352;
  }
  sub_100002728(v2, v3);
  if (*(unsigned char *)(a1 + 60) != 1)
  {
    if (*(unsigned char *)(a1 + 60) || !sub_10001C650(a1, 0)) {
      return 0;
    }
    return 0xFFFFFFFFLL;
  }
  if (sub_10001F358(a1, 0)) {
    return 0xFFFFFFFFLL;
  }
  return 0;
}

void sub_100025900(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 61) == 16 && *(_DWORD *)(a1 + 56) != 6336 || (*(unsigned char *)(a1 + 264) & 2) != 0)
  {
    if (dword_10008FA20)
    {
      BOOL v7 = ne_log_obj();
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
      {
        int v8 = *(_DWORD *)(a1 + 56);
        int v9 = *(unsigned __int8 *)(a1 + 264) << 30 >> 31;
        v30[0] = 67109632;
        v30[1] = v8;
        __int16 v31 = 1024;
        int v32 = 6336;
        __int16 v33 = 1024;
        int v34 = v9;
        _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "CHKPH1THERE: ph2 handle has advanced too far (status %d, START %d, dying %d)... ignoring\n", (uint8_t *)v30, 0x14u);
      }
    }
  }
  else
  {
    int v2 = *(_DWORD *)(a1 + 96);
    *(_DWORD *)(a1 + 96) = v2 - 1;
    if (v2 <= 0)
    {
      if (dword_10008FA20)
      {
        int v10 = ne_log_obj();
        if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR)) {
          sub_10005FA9C(a1);
        }
        if (dword_10008FA20)
        {
          int v11 = ne_log_obj();
          if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
          {
            LOWORD(v30[0]) = 0;
            _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "delete Phase 2 handler.\n", (uint8_t *)v30, 2u);
          }
        }
      }
      sub_10002F854(a1);
LABEL_51:
      sub_10004B62C((void *)a1);
      return;
    }
    uint64_t v3 = sub_10004C85C(a1);
    uint64_t v4 = v3;
    if (!v3 || (*(unsigned char *)(v3 + 17) & 0x20) == 0)
    {
      if (sub_10004E538(*(void *)(a1 + 272))) {
        goto LABEL_8;
      }
      int v25 = sub_1000388FC(*(sockaddr **)(a1 + 8));
      if (v25)
      {
        if (v4) {
          __int16 v26 = (_OWORD *)(v4 + 28);
        }
        else {
          __int16 v26 = 0;
        }
        int v27 = sub_100021EA8(*(void *)(a1 + 272), (uint64_t)v25, *(void *)(a1 + 8), *(void *)a1, 0, v26);
        int v5 = dword_10008FA20;
        if ((v27 & 0x80000000) == 0 || !dword_10008FA20) {
          goto LABEL_9;
        }
        uint64_t v28 = ne_log_obj();
        if (!os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
        {
LABEL_8:
          int v5 = dword_10008FA20;
LABEL_9:
          if (v5)
          {
            BOOL v6 = ne_log_obj();
            if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
            {
              LOWORD(v30[0]) = 0;
              _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "CHKPH1THERE: no established ph1 handler found\n", (uint8_t *)v30, 2u);
            }
          }
          goto LABEL_12;
        }
        LOWORD(v30[0]) = 0;
        int v29 = "CHKPH1THERE: no established/negoing ph1 handler found... failed to initiate new one\n";
      }
      else
      {
        if (!dword_10008FA20)
        {
LABEL_12:
          sub_10003AA24(1, (uint64_t)sub_10002561C, a1);
          return;
        }
        uint64_t v28 = ne_log_obj();
        if (!os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_8;
        }
        LOWORD(v30[0]) = 0;
        int v29 = "CHKPH1THERE: no remoteconf found... failed to initiate new one\n";
      }
      _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, v29, (uint8_t *)v30, 2u);
      goto LABEL_8;
    }
    if (dword_10008FA20)
    {
      uint32_t v12 = ne_log_obj();
      if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG)) {
        sub_10005FDFC();
      }
      if (dword_10008FA20)
      {
        uint64_t v13 = ne_log_obj();
        if (os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG)) {
          sub_10005FD80(v4);
        }
        if (dword_10008FA20)
        {
          __int16 v14 = ne_log_obj();
          if (os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG)) {
            sub_10005FD04(v4);
          }
          if (dword_10008FA20)
          {
            int v15 = ne_log_obj();
            if (os_log_type_enabled(v15, OS_LOG_TYPE_DEBUG)) {
              sub_10005FCD0();
            }
            if (dword_10008FA20)
            {
              uint64_t v16 = ne_log_obj();
              if (os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG)) {
                sub_10005FBA4((const sockaddr **)a1);
              }
              if (dword_10008FA20)
              {
                __int16 v17 = ne_log_obj();
                if (os_log_type_enabled(v17, OS_LOG_TYPE_DEBUG)) {
                  sub_10005FC54(a1);
                }
              }
            }
          }
        }
      }
    }
    uint64_t v18 = *(void *)a1;
    unsigned int v19 = sub_10003D80C(*(void *)(v4 + 56));
    sub_10003D910(v18, v19);
    uint64_t v20 = *(void *)(a1 + 8);
    unsigned int v21 = sub_10003D80C(*(void *)(v4 + 48));
    sub_10003D910(v20, v21);
    if (dword_10008FA20)
    {
      int v22 = ne_log_obj();
      if (os_log_type_enabled(v22, OS_LOG_TYPE_DEBUG)) {
        sub_10005FC20();
      }
      if (dword_10008FA20)
      {
        BOOL v23 = ne_log_obj();
        if (os_log_type_enabled(v23, OS_LOG_TYPE_DEBUG)) {
          sub_10005FBA4((const sockaddr **)a1);
        }
        if (dword_10008FA20)
        {
          __int16 v24 = ne_log_obj();
          if (os_log_type_enabled(v24, OS_LOG_TYPE_DEBUG)) {
            sub_10005FB28((const sockaddr **)(a1 + 8));
          }
        }
      }
    }
    if (sub_100025620(v4, a1)) {
      goto LABEL_51;
    }
  }
}

uint64_t sub_100025DC4(_WORD *a1, unsigned int a2, void *__src, signed int a4)
{
  *a1 = bswap32(a2) >> 16;
  a1[1] = bswap32(a4) >> 16;
  int v5 = a1 + 2;
  memcpy(a1 + 2, __src, a4);
  return (uint64_t)v5 + a4;
}

_WORD *sub_100025E18(_WORD *a1, int a2, unsigned int a3)
{
  *a1 = bswap32(a2 | 0x8000) >> 16;
  a1[1] = bswap32(a3) >> 16;
  return a1 + 2;
}

void *sub_100025E3C(void **a1, unsigned int a2, const void *a3, signed int a4)
{
  int v7 = a4 + 4;
  if (a1)
  {
    int v8 = *a1;
    int v9 = sub_10003F9BC(a1, (int)(v7 + *a1));
    uint64_t v10 = (int)v8;
    if (v9)
    {
LABEL_3:
      int v11 = (_WORD *)(v9[1] + v10);
      *int v11 = bswap32(a2) >> 16;
      v11[1] = bswap32(a4) >> 16;
      memcpy(v11 + 2, a3, a4);
      return v9;
    }
  }
  else
  {
    int v9 = sub_10003F940(v7);
    uint64_t v10 = 0;
    if (v9) {
      goto LABEL_3;
    }
  }
  if (dword_10008FA20)
  {
    uint32_t v12 = ne_log_obj();
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR)) {
      sub_10005FE30();
    }
  }
  return v9;
}

void *sub_100025F14(void **a1, int a2, unsigned int a3)
{
  if (a1)
  {
    int v5 = *a1;
    BOOL v6 = sub_10003F9BC(a1, (int)(*a1 + 4));
    uint64_t v7 = (int)v5;
    if (v6)
    {
LABEL_3:
      int v8 = (_WORD *)(v6[1] + v7);
      *int v8 = bswap32(a2 | 0x8000) >> 16;
      v8[1] = bswap32(a3) >> 16;
      return v6;
    }
  }
  else
  {
    BOOL v6 = sub_10003F940(4uLL);
    uint64_t v7 = 0;
    if (v6) {
      goto LABEL_3;
    }
  }
  if (dword_10008FA20)
  {
    int v9 = ne_log_obj();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR)) {
      sub_10005FE30();
    }
  }
  return v6;
}

uint64_t sub_100025FD0(void *a1, uint64_t a2, uint64_t a3)
{
  int v3 = *(unsigned __int8 *)(a2 + 1);
  if (v3 != *(unsigned __int8 *)(a3 + 1))
  {
    if (dword_10008FA20)
    {
      int v9 = ne_log_obj();
      if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR)) {
        sub_10005FF0C();
      }
    }
    return 0xFFFFFFFFLL;
  }
  if (v3 == 30)
  {
    uint64_t v7 = (_DWORD *)(a2 + 8);
    int v8 = (_DWORD *)(a3 + 8);
  }
  else
  {
    if (v3 != 2)
    {
      if (dword_10008FA20)
      {
        unsigned int v19 = ne_log_obj();
        if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR)) {
          sub_10005E880();
        }
      }
      return 0xFFFFFFFFLL;
    }
    uint64_t v7 = (_DWORD *)(a2 + 4);
    int v8 = (_DWORD *)(a3 + 4);
  }
  uint64_t v10 = sub_10003F940(*(_DWORD *)(qword_10008F848 + 304) + 20);
  if (!v10)
  {
    if (dword_10008FA20)
    {
      uint64_t v20 = ne_log_obj();
      if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR)) {
        sub_10005FE64();
      }
    }
    return 0xFFFFFFFFLL;
  }
  int v11 = v10;
  uint64_t v12 = v10[1];
  *(_DWORD *)uint64_t v12 = *v7;
  *(_WORD *)(v12 + 4) = *(_WORD *)(a2 + 2);
  *(_DWORD *)(v12 + 6) = *v8;
  *(_WORD *)(v12 + 10) = *(_WORD *)(a3 + 2);
  *(void *)(v12 + 12) = time(0);
  uint64_t v13 = sub_10000601C(*(_DWORD *)(qword_10008F848 + 304));
  if (!v13)
  {
    sub_10003FA78(v11);
    return 0xFFFFFFFFLL;
  }
  __int16 v14 = v13;
  memcpy((void *)(v12 + 20), (const void *)v13[1], *(int *)(qword_10008F848 + 304));
  sub_10003FA78(v14);
  int v15 = sub_100005EAC((uint64_t)v11);
  *a1 = *(void *)v15[1];
  uint64_t v16 = sub_10003D954((uint64_t)a1, 8uLL);
  if (dword_10008FA20)
  {
    __int16 v17 = ne_log_obj();
    if (os_log_type_enabled(v17, OS_LOG_TYPE_DEBUG)) {
      sub_10005FE98();
    }
  }
  free(v16);
  sub_10003FA78(v11);
  sub_10003FA78(v15);
  return 0;
}

uint64_t sub_1000261F4(size_t **a1, uint64_t a2)
{
  if (*a1)
  {
    if (dword_10008FA20)
    {
      int v2 = ne_log_obj();
      if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
      {
        v10[0] = 0;
        _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "ignore this payload, same payload type exist.\n", (uint8_t *)v10, 2u);
      }
    }
  }
  else
  {
    uint64_t v4 = bswap32(*(unsigned __int16 *)(a2 + 2)) >> 16;
    if (v4 > 3)
    {
      uint64_t v7 = sub_10003F940(v4 - 4);
      *a1 = v7;
      if (v7)
      {
        memcpy((void *)v7[1], (const void *)(a2 + 4), *v7);
        return 0;
      }
      if (dword_10008FA20)
      {
        int v9 = ne_log_obj();
        if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR)) {
          sub_10005821C();
        }
      }
    }
    else if (dword_10008FA20)
    {
      int v5 = ne_log_obj();
      if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR)) {
        sub_10005FF90();
      }
    }
  }
  return 0xFFFFFFFFLL;
}

uint64_t sub_100026328(uint64_t a1)
{
  do
    uint64_t v2 = sub_100006078();
  while (sub_100007F40(a1, v2));
  return v2;
}

uint64_t sub_100026364(uint64_t a1, uint64_t a2, char a3)
{
  return sub_100026374(a1, a2, a3, *(unsigned char *)(a2 + 81), *(unsigned char *)(a2 + 82), *(_DWORD *)(a2 + 84));
}

uint64_t sub_100026374(uint64_t a1, uint64_t a2, char a3, char a4, char a5, int a6)
{
  if (*(void *)a1 < 0x1CuLL) {
    return 0;
  }
  uint64_t v7 = *(void *)(a1 + 8);
  *(void *)uint64_t v7 = *(void *)a2;
  *(void *)(v7 + 8) = *(void *)(a2 + 8);
  *(unsigned char *)(v7 + 16) = a3;
  *(unsigned char *)(v7 + 17) = *(unsigned char *)(a2 + 80);
  *(unsigned char *)(v7 + 18) = a4;
  *(unsigned char *)(v7 + 19) = a5;
  unsigned int v8 = bswap32(*(_DWORD *)a1);
  *(_DWORD *)(v7 + 20) = a6;
  *(_DWORD *)(v7 + 24) = v8;
  return *(void *)(a1 + 8) + 28;
}

uint64_t sub_1000263C8(uint64_t a1, uint64_t a2, char a3)
{
  return sub_100026374(a1, *(void *)(a2 + 256), a3, 32, *(unsigned char *)(a2 + 105), *(_DWORD *)(a2 + 108));
}

char *sub_1000263E0(uint64_t a1, uint64_t *a2, int a3)
{
  if (dword_10008FA20)
  {
    BOOL v6 = ne_log_obj();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG)) {
      sub_100060004(a2, a3, v6);
    }
  }
  *(unsigned char *)a1 = a3;
  size_t v8 = *a2;
  uint64_t v7 = (const void *)a2[1];
  *(_WORD *)(a1 + 2) = bswap32(*a2 + 4) >> 16;
  int v9 = (char *)(a1 + 4);
  memcpy(v9, v7, v8);
  return &v9[*a2];
}

void *sub_100026474(void *a1, uint64_t a2, int a3)
{
  uint64_t result = malloc_type_malloc(0x20uLL, 0x102004055CCDE27uLL);
  if (a1) {
    *a1 = result;
  }
  *uint64_t result = 0;
  result[1] = a1;
  result[2] = a2;
  *((_DWORD *)result + 6) = a3;
  return result;
}

void *sub_1000264D0(uint64_t ***a1, uint64_t a2)
{
  uint64_t v4 = *a1;
  do
  {
    int v5 = v4;
    uint64_t v4 = (uint64_t **)v4[1];
  }
  while (v4);
  size_t v6 = 28;
  uint64_t v7 = v5;
  do
  {
    v6 += *v7[2] + 4;
    uint64_t v7 = (uint64_t **)*v7;
  }
  while (v7);
  size_t v8 = sub_10003F940(v6);
  if (!v8)
  {
    if (dword_10008FA20)
    {
      __int16 v14 = ne_log_obj();
      if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR)) {
        sub_10005CB90();
      }
    }
    return 0;
  }
  int v9 = v8;
  uint64_t v10 = sub_100026374((uint64_t)v8, a2, *((_DWORD *)v5 + 6), *(unsigned char *)(a2 + 81), *(unsigned char *)(a2 + 82), *(_DWORD *)(a2 + 84));
  if (!v10)
  {
    sub_10003FA78(v9);
    return 0;
  }
  int v11 = (char *)v10;
  do
  {
    if (*v5) {
      int v12 = *((_DWORD *)*v5 + 6);
    }
    else {
      int v12 = 0;
    }
    int v11 = sub_1000263E0((uint64_t)v11, v5[2], v12);
    uint64_t v13 = *v5;
    free(v5);
    int v5 = (uint64_t **)v13;
  }
  while (v13);
  *a1 = 0;
  return v9;
}

void sub_1000265E0(uint64_t a1)
{
  long long v46 = 0u;
  long long v47 = 0u;
  long long v44 = 0u;
  long long v45 = 0u;
  long long v42 = 0u;
  long long v43 = 0u;
  long long v40 = 0u;
  long long v41 = 0u;
  long long v38 = 0u;
  long long v39 = 0u;
  long long v36 = 0u;
  long long v37 = 0u;
  long long v35 = 0u;
  memset(v34, 0, sizeof(v34));
  if (dword_10008FA20)
  {
    uint64_t v2 = ne_log_obj();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      sub_100023BEC(a1, *(_DWORD *)(a1 + 84));
      *(_DWORD *)buf = 136315138;
      v33[0] = &xmmword_10008C748;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "purging ISAKMP-SA spi=%s.\n", buf, 0xCu);
    }
  }
  sub_100002728((int *)(a1 + 16), 17408);
  uint64_t v3 = sub_10004C2B0(a1);
  uint64_t v4 = sub_10002EB30(0);
  if (v4)
  {
    int v5 = v4;
    if ((uint64_t)*v4 >= 1)
    {
      unint64_t v6 = (unint64_t)v4[1];
      uint64_t v7 = (char *)*v4 + v6;
      while (1)
      {
        unint64_t v8 = *(unsigned __int16 *)(v6 + 4);
        if (v8 < 2) {
          goto LABEL_41;
        }
        if (*(unsigned char *)(v6 + 1) == 10)
        {
          if (sub_100042570(v6, (uint64_t)v34) || sub_100042670((uint64_t)v34))
          {
            if (dword_10008FA20)
            {
              int v9 = ne_log_obj();
              if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR)) {
                sub_100060090();
              }
            }
            goto LABEL_14;
          }
          uint64_t v10 = *((void *)&v34[0] + 1);
          if (*((void *)&v34[0] + 1)
            && *((void *)&v35 + 1)
            && (void)v36
            && *(unsigned __int8 *)(*((void *)&v34[0] + 1) + 9) <= 2u)
          {
            int v11 = (unsigned __int8 *)(*((void *)&v35 + 1) + 8);
            unint64_t v12 = v36 + 8;
            if (!sub_10003BB04(*(void *)(a1 + 56), *((void *)&v35 + 1) + 8)
              && !sub_10003BB04(*(void *)(a1 + 48), v12))
            {
              break;
            }
            if (!sub_10003BB04(*(void *)(a1 + 56), v12)
              && !sub_10003BB04(*(void *)(a1 + 48), (unint64_t)v11))
            {
              break;
            }
          }
        }
LABEL_14:
        v6 += 8 * v8;
        if (v6 >= (unint64_t)v7) {
          goto LABEL_41;
        }
      }
      int v13 = sub_10002F0E4(*(unsigned __int8 *)(v6 + 3));
      __int16 v14 = sub_1000080D0((uint64_t)v11, v12, v13, *(_DWORD *)(v10 + 4));
      int v15 = v14;
      if (v3)
      {
        if (v14)
        {
          uint64_t v16 = v14[32];
          if (v16 && v16 != a1) {
            goto LABEL_14;
          }
          if ((*((unsigned char *)v14 + 57) & 0x60) != 0)
          {
            if (!dword_10008FA20) {
              goto LABEL_14;
            }
            __int16 v17 = ne_log_obj();
            if (!os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT)) {
              goto LABEL_14;
            }
            unsigned int v18 = bswap32(*(_DWORD *)(v10 + 4));
            sub_100023BEC(v3, *(_DWORD *)(v3 + 84));
            *(_DWORD *)buf = 67109378;
            LODWORD(v33[0]) = v18;
            WORD2(v33[0]) = 2080;
            *(void *)((char *)v33 + 6) = &xmmword_10008C748;
            unsigned int v19 = v17;
            uint64_t v20 = "keeping IPsec-SA spi=%u - found valid ISAKMP-SA spi=%s.\n";
            uint32_t v21 = 18;
            goto LABEL_40;
          }
        }
        else if (dword_10008FA20)
        {
          log = ne_log_obj();
          BOOL v22 = os_log_type_enabled(log, OS_LOG_TYPE_DEFAULT);
          int v15 = 0;
          if (v22)
          {
            unsigned int v23 = bswap32(*(_DWORD *)(v10 + 4));
            *(_DWORD *)buf = 67109120;
            LODWORD(v33[0]) = v23;
            _os_log_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_DEFAULT, "Unknown IPsec-SA spi=%u, hmmmm?\n", buf, 8u);
            int v15 = 0;
          }
        }
      }
      __int16 v24 = (unsigned __int8 *)v12;
      int v25 = v15;
      sub_100041398(*(_DWORD *)(qword_10008F848 + 32), *(unsigned char *)(v6 + 3), 0, v11, v24, *(_DWORD *)(v10 + 4));
      if (v25)
      {
        sub_100026AB8((uint64_t)v25);
        sub_10004B62C(v25);
      }
      if (!dword_10008FA20) {
        goto LABEL_14;
      }
      __int16 v26 = ne_log_obj();
      if (!os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_14;
      }
      unsigned int v27 = bswap32(*(_DWORD *)(v10 + 4));
      *(_DWORD *)buf = 67109120;
      LODWORD(v33[0]) = v27;
      unsigned int v19 = v26;
      uint64_t v20 = "purged IPsec-SA spi=%u.\n";
      uint32_t v21 = 8;
LABEL_40:
      _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, v20, buf, v21);
      goto LABEL_14;
    }
LABEL_41:
    sub_10003FA78(v5);
    if (dword_10008FA20)
    {
      uint64_t v28 = ne_log_obj();
      if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
      {
        sub_100023BEC(a1, *(_DWORD *)(a1 + 84));
        *(_DWORD *)buf = 136315138;
        v33[0] = &xmmword_10008C748;
        _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, "purged ISAKMP-SA spi=%s.\n", buf, 0xCu);
      }
    }
    uint64_t v29 = *(unsigned int *)(a1 + 112);
    if (v29)
    {
      sub_10003AC14(v29);
      *(_DWORD *)(a1 + 112) = 0;
    }
    *(_DWORD *)(a1 + 112) = sub_10003AA24(1, (uint64_t)sub_1000248EC, a1);
  }
  else if (dword_10008FA20)
  {
    __int16 v30 = ne_log_obj();
    if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_DEFAULT, "pfkey_dump_sadb returned nothing.\n", buf, 2u);
    }
  }
}

void sub_100026AB8(uint64_t a1)
{
  if (a1 && *(_DWORD *)(a1 + 248))
  {
    long long v2 = 0uLL;
    long long v37 = 0u;
    memset(v38, 0, sizeof(v38));
    long long v35 = 0u;
    long long v36 = 0u;
    long long v33 = 0u;
    long long v34 = 0u;
    long long v31 = 0u;
    long long v32 = 0u;
    long long v30 = 0u;
    uint64_t v3 = *(void *)a1;
    uint64_t v4 = *(void *)(a1 + 8);
    if (dword_10008FA20)
    {
      int v5 = ne_log_obj();
      BOOL v6 = os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT);
      long long v2 = 0uLL;
      if (v6)
      {
        LOWORD(v27[0]) = 0;
        _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "generated policy, deleting it.\n", (uint8_t *)v27, 2u);
        long long v2 = 0uLL;
      }
    }
    char v38[15] = v2;
    v38[16] = v2;
    v38[13] = v2;
    v38[14] = v2;
    v38[11] = v2;
    v38[12] = v2;
    v38[9] = v2;
    v38[10] = v2;
    v38[7] = v2;
    v38[8] = v2;
    v38[5] = v2;
    v38[6] = v2;
    v38[3] = v2;
    v38[4] = v2;
    v38[1] = v2;
    v38[2] = v2;
    v38[0] = v2;
    *(void *)(a1 + 136) = v38;
    *(void *)a1 = v4;
    *(void *)(a1 + 8) = v3;
    LOBYTE(v38[0]) = 1;
    uint64_t v7 = *(void *)(a1 + 192);
    if (v7 && (unsigned int v8 = **(unsigned __int8 **)(v7 + 8), v8 <= 6) && ((1 << v8) & 0x72) != 0)
    {
      if (sub_100010604((unint64_t *)v7, (uint64_t)&v38[8] + 8, (unsigned char *)&v38[16] + 9, (__int16 *)&v38[16] + 5, *(unsigned __int8 *)(a1 + 61)))goto LABEL_72; {
      int v9 = **(unsigned __int8 **)(*(void *)(a1 + 192) + 8);
      }
      if (v9 == 5)
      {
        if (sub_1000270E0((uint64_t)&v38[8] + 8, *(void *)a1)) {
          goto LABEL_72;
        }
        int v9 = **(unsigned __int8 **)(*(void *)(a1 + 192) + 8);
      }
      if (v9 == 5) {
        int v10 = 5;
      }
      else {
        int v10 = 0;
      }
      if (v9 == 1) {
        int v11 = 1;
      }
      else {
        int v11 = v10;
      }
    }
    else
    {
      if (dword_10008FA20)
      {
        unint64_t v12 = ne_log_obj();
        if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
        {
          LOWORD(v27[0]) = 0;
          _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "Get a destination address of SP index from Phase 1 address due to no ID payloads found OR because ID type is not address.\n", (uint8_t *)v27, 2u);
        }
      }
      __memcpy_chk();
      if (BYTE9(v38[8]) == 30)
      {
        int v11 = 0;
        char v13 = 0x80;
      }
      else
      {
        if (BYTE9(v38[8]) != 2)
        {
          int v11 = 0;
          BYTE9(v38[16]) = 0;
          goto LABEL_28;
        }
        int v11 = 0;
        char v13 = 32;
      }
      BYTE9(v38[16]) = v13;
    }
LABEL_28:
    uint64_t v14 = *(void *)(a1 + 200);
    if (v14)
    {
      unsigned int v15 = **(unsigned __int8 **)(v14 + 8);
      if (v15 <= 6 && ((1 << v15) & 0x72) != 0)
      {
        if (!sub_100010604((unint64_t *)v14, (uint64_t)v38 + 8, (unsigned char *)&v38[16] + 8, (__int16 *)&v38[16] + 5, *(unsigned __int8 *)(a1 + 61)))
        {
          int v16 = **(unsigned __int8 **)(*(void *)(a1 + 200) + 8);
          if (v16 != 5)
          {
LABEL_35:
            if (v11 == v16 && BYTE9(v38[8]) == BYTE9(v38[0]))
            {
              *(void *)(a1 + 32) = sub_10003CC74();
              *(void *)(a1 + 40) = sub_10003CC74();
            }
            goto LABEL_47;
          }
          if (!sub_1000270E0((uint64_t)v38 + 8, *(void *)(a1 + 8)))
          {
            int v16 = **(unsigned __int8 **)(*(void *)(a1 + 200) + 8);
            goto LABEL_35;
          }
        }
LABEL_72:
        *(void *)(a1 + 136) = 0;
        return;
      }
    }
    if (dword_10008FA20)
    {
      __int16 v17 = ne_log_obj();
      if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(v27[0]) = 0;
        _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "Get a source address of SP index from Phase 1 address due to no ID payloads found OR because ID type is not address.\n", (uint8_t *)v27, 2u);
      }
    }
    __memcpy_chk();
    if (BYTE9(v38[0]) == 30)
    {
      char v18 = 0x80;
    }
    else
    {
      if (BYTE9(v38[0]) != 2)
      {
        BYTE8(v38[16]) = 0;
        goto LABEL_47;
      }
      char v18 = 32;
    }
    BYTE8(v38[16]) = v18;
LABEL_47:
    if (dword_10008FA20)
    {
      unsigned int v19 = ne_log_obj();
      if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
      {
        v27[0] = 67109376;
        v27[1] = BYTE8(v38[16]);
        __int16 v28 = 1024;
        int v29 = WORD5(v38[16]);
        _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "get src/dst address from ID payload prefixlen=%u ul_proto=%u\n", (uint8_t *)v27, 0xEu);
      }
      if (dword_10008FA20)
      {
        uint64_t v20 = ne_log_obj();
        if (os_log_type_enabled(v20, OS_LOG_TYPE_DEBUG)) {
          sub_1000601D0();
        }
        if (dword_10008FA20)
        {
          uint32_t v21 = ne_log_obj();
          if (os_log_type_enabled(v21, OS_LOG_TYPE_DEBUG)) {
            sub_100060144();
          }
        }
      }
    }
    if (!WORD5(v38[16])) {
      WORD5(v38[16]) = 255;
    }
    if ((sub_1000309D4(a1) & 0x80000000) != 0)
    {
      if (dword_10008FA20)
      {
        unsigned int v23 = ne_log_obj();
        if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR)) {
          sub_100060110();
        }
      }
    }
    else if (dword_10008FA20)
    {
      BOOL v22 = ne_log_obj();
      if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(v27[0]) = 0;
        _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "pfkey spddelete(inbound) sent.\n", (uint8_t *)v27, 2u);
      }
    }
    *(void *)a1 = v3;
    *(void *)(a1 + 8) = v4;
    LOBYTE(v38[0]) = 2;
    long long v34 = *(_OWORD *)((char *)&v38[4] + 8);
    long long v35 = *(_OWORD *)((char *)&v38[5] + 8);
    long long v36 = *(_OWORD *)((char *)&v38[6] + 8);
    long long v37 = *(_OWORD *)((char *)&v38[7] + 8);
    long long v30 = *(_OWORD *)((char *)v38 + 8);
    long long v31 = *(_OWORD *)((char *)&v38[1] + 8);
    long long v32 = *(_OWORD *)((char *)&v38[2] + 8);
    long long v33 = *(_OWORD *)((char *)&v38[3] + 8);
    *(_OWORD *)((char *)&v38[3] + 8) = *(_OWORD *)((char *)&v38[11] + 8);
    *(_OWORD *)((char *)&v38[2] + 8) = *(_OWORD *)((char *)&v38[10] + 8);
    *(_OWORD *)((char *)&v38[1] + 8) = *(_OWORD *)((char *)&v38[9] + 8);
    *(_OWORD *)((char *)&v38[7] + 8) = *(_OWORD *)((char *)&v38[15] + 8);
    *(_OWORD *)((char *)&v38[6] + 8) = *(_OWORD *)((char *)&v38[14] + 8);
    *(_OWORD *)((char *)&v38[5] + 8) = *(_OWORD *)((char *)&v38[13] + 8);
    *(_OWORD *)((char *)&v38[4] + 8) = *(_OWORD *)((char *)&v38[12] + 8);
    *(_OWORD *)((char *)v38 + 8) = *(_OWORD *)((char *)&v38[8] + 8);
    *(_OWORD *)((char *)&v38[11] + 8) = v33;
    *(_OWORD *)((char *)&v38[10] + 8) = v32;
    *(_OWORD *)((char *)&v38[9] + 8) = v31;
    *(_OWORD *)((char *)&v38[8] + 8) = v30;
    *(_OWORD *)((char *)&v38[15] + 8) = v37;
    *(_OWORD *)((char *)&v38[14] + 8) = v36;
    *(_OWORD *)((char *)&v38[13] + 8) = v35;
    *(_OWORD *)((char *)&v38[12] + 8) = v34;
    char v24 = BYTE8(v38[16]);
    BYTE8(v38[16]) = BYTE9(v38[16]);
    BYTE9(v38[16]) = v24;
    if ((sub_1000309D4(a1) & 0x80000000) != 0)
    {
      if (dword_10008FA20)
      {
        __int16 v26 = ne_log_obj();
        if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR)) {
          sub_1000600DC();
        }
      }
    }
    else if (dword_10008FA20)
    {
      int v25 = ne_log_obj();
      if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(v27[0]) = 0;
        _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "pfkey spddelete(outbound) sent.\n", (uint8_t *)v27, 2u);
      }
    }
    goto LABEL_72;
  }
}

uint64_t sub_1000270E0(uint64_t a1, uint64_t a2)
{
  int v2 = *(unsigned __int8 *)(a1 + 8);
  if (v2 == 255 || v2 == 254 && ((unsigned int v3 = *(unsigned __int8 *)(a1 + 9), (v3 & 0xC0) == 0x80) || v3 >= 0xC0))
  {
    if (*(unsigned char *)(a2 + 1) == 30)
    {
      if (*(unsigned __int8 *)(a2 + 8) == 254 && (*(unsigned char *)(a2 + 9) & 0xC0) == 0x80)
      {
        uint64_t v4 = 0;
        *(_DWORD *)(a1 + 24) = *(_DWORD *)(a2 + 24);
        return v4;
      }
      if (dword_10008FA20)
      {
        BOOL v6 = ne_log_obj();
        if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR)) {
          sub_10006025C();
        }
      }
    }
    else if (dword_10008FA20)
    {
      int v5 = ne_log_obj();
      if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR)) {
        sub_100060290();
      }
    }
    return 0xFFFFFFFFLL;
  }
  return 0;
}

void *sub_1000271D0(uint64_t a1, void *a2)
{
  if ((*(unsigned char *)(a1 + 432) & 1) != 0
    || !*(_DWORD *)(*(void *)(a1 + 64) + 168)
    || sub_100008AC0(*(void *)(a1 + 48)))
  {
    if (dword_10008FA20)
    {
      uint64_t v4 = ne_log_obj();
      if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
      {
        int v5 = *(unsigned char *)(a1 + 432) & 1;
        int v6 = *(_DWORD *)(*(void *)(a1 + 64) + 168);
        uint64_t v7 = sub_100008AC0(*(void *)(a1 + 48));
        v16[0] = 67109632;
        v16[1] = v5;
        __int16 v17 = 1024;
        int v18 = v6;
        __int16 v19 = 1024;
        BOOL v20 = v7 != 0;
        _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "failed to add initial-contact payload: rekey %d, ini-contact %d, contacted %d.\n", (uint8_t *)v16, 0x14u);
      }
    }
    return 0;
  }
  else
  {
    unsigned int v10 = *(_DWORD *)(*(void *)(a1 + 64) + 24);
    int v11 = sub_10003F940(0x18uLL);
    unsigned int v8 = v11;
    if (v11)
    {
      *(void *)v11[1] = bswap32(v10) | 0x260100100000000;
      *(_OWORD *)(v11[1] + 8) = *(_OWORD *)a1;
      unint64_t v12 = malloc_type_malloc(0x20uLL, 0x102004055CCDE27uLL);
      if (a2) {
        *a2 = v12;
      }
      void *v12 = 0;
      v12[1] = a2;
      v12[2] = v8;
      *((_DWORD *)v12 + 6) = 11;
      if (dword_10008FA20)
      {
        char v13 = ne_log_obj();
        if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
        {
          LOWORD(v16[0]) = 0;
          _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "added initial-contact payload.\n", (uint8_t *)v16, 2u);
        }
      }
      if (sub_100008B08() == -1)
      {
        if (dword_10008FA20)
        {
          uint64_t v14 = ne_log_obj();
          if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR)) {
            sub_10005EF50();
          }
        }
      }
    }
    else if (dword_10008FA20)
    {
      unsigned int v15 = ne_log_obj();
      if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR)) {
        sub_10005B508();
      }
    }
  }
  return v8;
}

void sub_100027404(uint64_t a1, uint64_t a2, sockaddr *a3, uint64_t a4, int a5)
{
  uint64_t v10 = *(void *)(a2 + 8);
  int v11 = sub_1000388FC(a3);
  if (!v11)
  {
    if (dword_10008FA20)
    {
      __int16 v19 = ne_log_obj();
      if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR)) {
        sub_1000602C4();
      }
    }
    return;
  }
  uint64_t v12 = (uint64_t)v11;
  uint64_t v13 = sub_100039040((uint64_t)v11, a5);
  if (!v13)
  {
    if (dword_10008FA20)
    {
      BOOL v20 = ne_log_obj();
      if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR)) {
        sub_1000602F8(a5);
      }
    }
    return;
  }
  uint64_t v14 = (unsigned __int8 *)v13;
  unsigned int v15 = sub_100007868(16);
  if (!v15) {
    return;
  }
  uint64_t v16 = (uint64_t)v15;
  void *v15 = *(void *)v10;
  v15[8] = v12;
  sub_100038F68(v12);
  *(unsigned char *)(v16 + 82) = 0;
  *(void *)(v16 + 20) = 1;
  int v17 = *v14;
  *(unsigned char *)(v16 + 81) = v17;
  *(unsigned char *)(v16 + 80) = *(unsigned char *)(v10 + 17);
  *(_DWORD *)(v16 + 84) = 0;
  if (v17 == 2)
  {
    int v18 = 5440;
  }
  else
  {
    if (v17 != 4)
    {
LABEL_19:
      sub_100007920(v16);
      return;
    }
    int v18 = 5504;
  }
  sub_100002728((int *)(v16 + 16), v18);
  uint32_t v21 = sub_100045224();
  *(void *)(v16 + 408) = v21;
  if (!v21) {
    goto LABEL_19;
  }
  *(_DWORD *)(v16 + 100) = 0;
  *(void *)(v16 + 104) = 0;
  *(void *)(v16 + 72) = 0;
  if (sub_10003D80C(a4) == *(unsigned __int16 *)(qword_10008F848 + 18)) {
    *(_DWORD *)(v16 + 96) |= 8u;
  }
  if ((sub_1000222A8(v16, v12, (uint64_t)a3, a4) & 0x80000000) == 0)
  {
    if (sub_10004BEF0(a1, v16)) {
      goto LABEL_19;
    }
    if (dword_10008FA20)
    {
      BOOL v22 = ne_log_obj();
      if (os_log_type_enabled(v22, OS_LOG_TYPE_DEBUG)) {
        sub_10005EEB4();
      }
    }
    unsigned int v23 = sub_10003CAE4(*(const sockaddr **)(v16 + 56));
    char v24 = strdup((const char *)v23);
    if (!v24)
    {
      if (dword_10008FA20)
      {
        long long v32 = ne_log_obj();
        if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR)) {
          sub_10005ED40();
        }
      }
      exit(1);
    }
    int v25 = v24;
    if (dword_10008FA20)
    {
      __int16 v26 = ne_log_obj();
      if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
      {
        unsigned int v27 = sub_10003CAE4(*(const sockaddr **)(v16 + 48));
        int v33 = 136315394;
        long long v34 = v25;
        __int16 v35 = 2080;
        long long v36 = v27;
        _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "respond new phase 1 negotiation: %s<=>%s\n", (uint8_t *)&v33, 0x16u);
      }
      int v28 = dword_10008FA20;
      free(v25);
      if (v28)
      {
        int v29 = ne_log_obj();
        if (os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
        {
          long long v30 = sub_10003E0EC(a5);
          int v33 = 136315138;
          long long v34 = v30;
          _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEFAULT, "begin %s mode.\n", (uint8_t *)&v33, 0xCu);
        }
        if (dword_10008FA20)
        {
          long long v31 = ne_log_obj();
          if (os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT))
          {
            LOWORD(v33) = 0;
            _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_DEFAULT, "IPSec Phase 1 started (Initiated by peer).\n", (uint8_t *)&v33, 2u);
          }
        }
      }
    }
    else
    {
      free(v24);
    }
    sub_1000214B4(a2, a3, a4);
  }
}

void sub_1000277C4(uint64_t a1, void *a2, const sockaddr *a3, uint64_t a4)
{
  if (sub_100014C34(a1, a2) == 1)
  {
    uint64_t v7 = sub_100014F5C(a1);
    if (v7)
    {
      unsigned int v8 = v7;
      if ((int)sub_100008C78(a3, a4, (uint64_t)v7) < 1)
      {
        sub_1000214B4(v8, a3, a4);
        sub_10003FA78(v8);
      }
      else
      {
        if (dword_10008FA20)
        {
          int v9 = ne_log_obj();
          if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
          {
            int v13 = 136315138;
            uint64_t v14 = sub_10003CAE4(a3);
            _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "Received (reassembled) retransmitted packet from %s.\n", (uint8_t *)&v13, 0xCu);
          }
          if (dword_10008FA20)
          {
            uint64_t v10 = ne_log_obj();
            if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
            {
              int v11 = sub_10003CAE4(a3);
              int v13 = 136315138;
              uint64_t v14 = v11;
              _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "the reassembled packet is retransmitted by %s.\n", (uint8_t *)&v13, 0xCu);
            }
          }
        }
        sub_10003FA78(v8);
      }
    }
    else if (dword_10008FA20)
    {
      uint64_t v12 = ne_log_obj();
      if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR)) {
        sub_100060374();
      }
    }
  }
}

void sub_1000279A0(uint64_t a1, void *a2)
{
  uint64_t v4 = a2[1];
  if (sub_1000471C0((void *)a1))
  {
    if (dword_10008FA20)
    {
      int v5 = ne_log_obj();
      if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR)) {
        sub_1000603DC();
      }
    }
    return;
  }
  int v6 = sub_100008234(16, 0);
  if (v6)
  {
    uint64_t v7 = (uint64_t)v6;
    *((_WORD *)v6 + 30) = 4097;
    sub_100002728((int *)v6 + 14, 6592);
    *(unsigned char *)(v7 + 105) = *(unsigned char *)(v4 + 19);
    *(_DWORD *)(v7 + 108) = *(_DWORD *)(v4 + 20);
    *(_DWORD *)(v7 + 100) = sub_100030EFC();
    unsigned int v8 = sub_10002DAA8(a1, *(_DWORD *)(v7 + 108));
    *(void *)(v7 + 240) = v8;
    if (!v8) {
      goto LABEL_28;
    }
    int v9 = (unsigned __int8 *)sub_10003CC74();
    *(void *)(v7 + 8) = v9;
    if (!v9) {
      goto LABEL_28;
    }
    int v10 = v9[1];
    if (v10 != 2 && v10 != 30)
    {
      if (!dword_10008FA20) {
        goto LABEL_30;
      }
      unsigned int v23 = ne_log_obj();
      if (!os_log_type_enabled(v23, OS_LOG_TYPE_ERROR)) {
        goto LABEL_30;
      }
      goto LABEL_39;
    }
    uint64_t v12 = (unsigned __int8 *)sub_10003CC74();
    *(void *)uint64_t v7 = v12;
    if (!v12)
    {
LABEL_28:
      goto LABEL_30;
    }
    int v13 = v12[1];
    if (v13 != 2 && v13 != 30)
    {
      if (!dword_10008FA20) {
        goto LABEL_30;
      }
      char v24 = ne_log_obj();
      if (!os_log_type_enabled(v24, OS_LOG_TYPE_ERROR)) {
        goto LABEL_30;
      }
LABEL_39:
      sub_10005EEE8();
LABEL_30:
      sub_10000843C(v7);
      return;
    }
    if (!sub_10004C148(a1, (void *)v7))
    {
      *(unsigned char *)(v7 + 264) &= ~2u;
      *(_OWORD *)(v7 + 16) = *(_OWORD *)(a1 + 28);
      if (dword_10008FA20)
      {
        uint64_t v14 = ne_log_obj();
        if (os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG)) {
          sub_10005EEB4();
        }
      }
      unsigned int v15 = sub_10003CAE4(*(const sockaddr **)v7);
      uint64_t v16 = strdup((const char *)v15);
      if (!v16)
      {
        if (dword_10008FA20)
        {
          int v25 = ne_log_obj();
          if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR)) {
            sub_10005ED40();
          }
        }
        exit(1);
      }
      int v17 = v16;
      if (dword_10008FA20)
      {
        int v18 = ne_log_obj();
        if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
        {
          __int16 v19 = sub_10003CAE4(*(const sockaddr **)(v7 + 8));
          int v26 = 136315394;
          unsigned int v27 = v17;
          __int16 v28 = 2080;
          int v29 = v19;
          _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "respond new phase 2 negotiation: %s<=>%s\n", (uint8_t *)&v26, 0x16u);
        }
        int v20 = dword_10008FA20;
        free(v17);
        if (v20)
        {
          uint32_t v21 = ne_log_obj();
          if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
          {
            LOWORD(v26) = 0;
            _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "IPSec Phase 2 started (Initiated by peer).\n", (uint8_t *)&v26, 2u);
          }
        }
      }
      else
      {
        free(v16);
      }
      if (!sub_100002C2C(v7, a2)) {
        sub_1000496DC(1, 1, 0, v7);
      }
    }
  }
  else if (dword_10008FA20)
  {
    BOOL v22 = ne_log_obj();
    if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR)) {
      sub_1000603A8();
    }
  }
}

int *sub_100027D3C()
{
  return __error();
}

long long *sub_100027D78(uint64_t *a1, uint64_t a2)
{
  uint64_t v3 = *a1;
  unsigned int v4 = *(_DWORD *)(a2 + 108);
  return sub_100023BEC(v3, v4);
}

void sub_100027DA4()
{
  qword_10008F848 = (uint64_t)malloc_type_calloc(1uLL, 0x140uLL, 0x10B004027E15F99uLL);
  if (!qword_10008F848) {
    sub_100060410();
  }
  sub_100027E14();
  uint64_t v0 = (void *)qword_10008F848;
  *(_DWORD *)(qword_10008F848 + 28) = -1;
  void *v0 = "/etc/racoon/racoon.conf";
  uint64_t v1 = qword_10008F848;
  *(void *)(qword_10008F848 + 96) = 0;
  *(void *)(v1 + 104) = v1 + 96;
}

double sub_100027E14()
{
  uint64_t v0 = qword_10008F848;
  *(void *)(qword_10008F848 + 8) = 0;
  *(_DWORD *)(v0 + 112) = 1;
  *(_DWORD *)(v0 + 16) = 294912500;
  *(_DWORD *)(v0 + 24) = 2;
  *(_OWORD *)(v0 + 248) = xmmword_10006E570;
  *(_OWORD *)(v0 + 264) = xmmword_10006E580;
  *(void *)(v0 + 280) = 0x1E0000001ELL;
  *(void *)&double result = 16;
  *(void *)(v0 + 304) = 16;
  *(_DWORD *)(v0 + 312) = 1;
  *(_DWORD *)(v0 + 288) = 20;
  *(void *)(v0 + 80) = *(_DWORD *)(v0 + 80) & 0xFFFFFFEE | 0x10;
  return result;
}

void sub_100027E8C()
{
  sub_100027E14();
  sub_1000062AC();
  uint64_t v0 = qword_10008F848;
  for (uint64_t i = 136; i != 176; i += 8)
  {
    uint64_t v2 = *(void **)(v0 + i);
    if (v2)
    {
      free(v2);
      *(void *)(qword_10008F848 + i) = 0;
      uint64_t v0 = qword_10008F848;
    }
  }
  do
  {
    uint64_t v3 = qword_10008F848;
    unsigned int v4 = *(void **)(qword_10008F848 + i);
    if (v4)
    {
      sub_10003FA78(v4);
      uint64_t v3 = qword_10008F848;
    }
    *(void *)(v3 + i) = 0;
    i += 8;
  }
  while (i != 248);
  int v5 = *(void **)(qword_10008F848 + 296);
  if (v5)
  {
    sub_10003FA78(v5);
    *(void *)(qword_10008F848 + 296) = 0;
  }
}

void sub_100027F1C()
{
  qword_10008F850 = qword_10008F848;
  qword_10008F848 = 0;
  sub_100027DA4();
}

void sub_100027F34()
{
  qword_10008F848 = qword_10008F850;
  qword_10008F850 = 0;
}

size_t *sub_100027F70(void *a1)
{
  if (dword_10008FA20)
  {
    uint64_t v2 = ne_log_obj();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEBUG)) {
      sub_100060460();
    }
  }
  uint64_t v3 = (char *)malloc_type_calloc(1uLL, *a1 - 3, 0x681A2B4uLL);
  if (v3)
  {
    unsigned int v4 = v3;
    memcpy(v3, (const void *)(a1[1] + 4), *a1 - 4);
    v4[*a1 - 4] = 0;
    int v5 = sub_100028054(v4, *(_DWORD *)a1 - 4);
    free(v4);
  }
  else
  {
    if (dword_10008FA20)
    {
      int v6 = ne_log_obj();
      if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR)) {
        sub_10006042C();
      }
    }
    return 0;
  }
  return v5;
}

size_t *sub_100028054(const char *a1, int a2)
{
  size_t i = 0;
  if (dword_10008FA20)
  {
    unsigned int v4 = ne_log_obj();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG)) {
      sub_100060550();
    }
  }
  if (sub_100039FF0(*(const char **)(qword_10008F848 + 144), 1)
    || (uint64_t v7 = fopen(*(const char **)(qword_10008F848 + 144), "r")) == 0)
  {
    if (dword_10008FA20)
    {
      int v5 = ne_log_obj();
      if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR)) {
        sub_100060494(v5);
      }
    }
    return 0;
  }
  unsigned int v8 = v7;
  if (!fgets(__s1, 1024, v7)) {
    goto LABEL_31;
  }
  size_t v9 = a2;
  while (2)
  {
    char v10 = __s1[0];
    if (!__s1[0] || __s1[0] == 35) {
      goto LABEL_30;
    }
    int v11 = __s1;
    while ((v10 & 0x80) == 0)
    {
      if ((_DefaultRuneLocale.__runetype[v10] & 0x4000) != 0) {
        goto LABEL_21;
      }
LABEL_19:
      int v12 = *++v11;
      char v10 = v12;
      if (!v12) {
        goto LABEL_30;
      }
    }
    if (!__maskrune(v10, 0x4000uLL)) {
      goto LABEL_19;
    }
LABEL_21:
    if (!*v11) {
      goto LABEL_30;
    }
    *int v11 = 0;
    do
    {
      while (1)
      {
        __darwin_ct_rune_t v14 = *++v11;
        __darwin_ct_rune_t v13 = v14;
        if (v14 < 0) {
          break;
        }
        if ((_DefaultRuneLocale.__runetype[v13] & 0x4000) == 0) {
          goto LABEL_27;
        }
      }
    }
    while (__maskrune(v13, 0x4000uLL));
LABEL_27:
    if (!v13 || strncmp(__s1, a1, v9) || __s1[v9])
    {
LABEL_30:
      if (!fgets(__s1, 1024, v8)) {
        goto LABEL_31;
      }
      continue;
    }
    break;
  }
  size_t v16 = 0;
  for (size_t i = 0; v11[v16] && v11[v16] != 10; size_t i = v16)
    ++v16;
  v11[v16] = 0;
  if (strncmp(v11, "0x", 2uLL))
  {
    int v18 = 0;
    goto LABEL_43;
  }
  int v11 = sub_10003DA30(v11 + 2, 16, &i);
  int v18 = v11;
  if (!v11)
  {
    if (dword_10008FA20)
    {
      uint32_t v21 = ne_log_obj();
      if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR)) {
        sub_10006042C();
      }
    }
    goto LABEL_31;
  }
LABEL_43:
  __int16 v19 = sub_10003F940(i);
  if (!v19)
  {
    if (dword_10008FA20)
    {
      int v20 = ne_log_obj();
      if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR)) {
        sub_10006051C();
      }
    }
LABEL_31:
    int v6 = 0;
    goto LABEL_32;
  }
  int v6 = v19;
  memcpy((void *)v19[1], v11, *v19);
  if (v18) {
    free(v18);
  }
LABEL_32:
  fclose(v8);
  return v6;
}

size_t *sub_100028330(sockaddr *a1)
{
  if (dword_10008FA20)
  {
    uint64_t v2 = ne_log_obj();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEBUG)) {
      sub_100060584();
    }
  }
  if (getnameinfo(a1, a1->sa_len, __s, 0x401u, v5, 0x20u, 10))
  {
    __strlcpy_chk();
    __strlcpy_chk();
  }
  int v3 = strlen(__s);
  return sub_100028054(__s, v3);
}

void sub_100028424(char *__str, int a2, int a3, const char *a4)
{
  if (*a4 == 47)
  {
    int v5 = (const char *)&unk_100081F6D;
    int v6 = (const char *)&unk_100081F6D;
  }
  else
  {
    int v6 = *(const char **)(qword_10008F848 + 8 * a3 + 136);
    int v5 = "/";
  }
  snprintf(__str, a2, "%s%s%s", v6, v5, a4);
  if (dword_10008FA20)
  {
    uint64_t v7 = ne_log_obj();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG)) {
      sub_1000605B8((uint64_t)__str, v7);
    }
  }
}

uint64_t sub_1000284D0(unsigned int a1)
{
  if (a1 > 2) {
    return 0xFFFFFFFFLL;
  }
  else {
    return dword_10006E598[a1];
  }
}

uint64_t sub_1000284F0(int a1)
{
  if (a1) {
    return 0xFFFFFFFFLL;
  }
  else {
    return 1;
  }
}

uint64_t start(int a1, char **a2)
{
  sub_1000502D0();
  sub_100034584();
  if (geteuid()) {
    sub_100060850();
  }
  umask(0x3Fu);
  if (umask(0x3Fu) != 63) {
    sub_100060834();
  }
  sub_100027DA4();
  sub_100039030();
  sub_1000291C8();
  sub_10003F550();
  unsigned int v4 = strrchr(*a2, 47);
  qword_10008F9E8 = (uint64_t)v4;
  if (v4) {
    int v5 = v4 + 1;
  }
  else {
    int v5 = *a2;
  }
  qword_10008F9E8 = (uint64_t)v5;
  while (1)
  {
    while (1)
    {
      while (1)
      {
        while (1)
        {
          int v6 = getopt(a1, a2, "dDLFp:P:a:f:l:vsZBCx46");
          if (v6 <= 89) {
            break;
          }
          if (v6 > 101)
          {
            switch(v6)
            {
              case 'p':
                *(_WORD *)(qword_10008F848 + 16) = atoi(optarg);
                continue;
              case 'q':
              case 'r':
              case 't':
              case 'u':
              case 'w':
                goto LABEL_80;
              case 's':
                *(_DWORD *)(qword_10008F848 + 80) &= ~0x10u;
                continue;
              case 'v':
                ++dword_10008C284;
                continue;
              case 'x':
                byte_10008C78C = 1;
                continue;
              default:
                if (v6 == 102)
                {
                  *(void *)qword_10008F848 = optarg;
                }
                else
                {
                  if (v6 != 108) {
                    goto LABEL_80;
                  }
                  *(void *)(qword_10008F848 + 128) = optarg;
                }
                break;
            }
          }
          else
          {
            switch(v6)
            {
              case 'Z':
                puts("Local test mode.");
                dword_10008F858 = 1;
                break;
              case 'd':
                sub_100034044(7);
                break;
              case 'a':
                fprintf(__stderrp, "%s: the option is disabled in the configuration\n", (const char *)qword_10008F9E8);
                goto LABEL_79;
              default:
LABEL_80:
                sub_100028DF4();
            }
          }
        }
        if (v6 <= 66) {
          break;
        }
        switch(v6)
        {
          case 'C':
            ++dword_10008C788;
            continue;
          case 'D':
            if (dword_10008F9F0) {
              goto LABEL_78;
            }
            dword_10008F860 = 1;
            continue;
          case 'E':
          case 'G':
          case 'H':
          case 'I':
          case 'J':
          case 'K':
            goto LABEL_80;
          case 'F':
            if (dword_10008F860)
            {
LABEL_78:
              fwrite("-D and -F are mutually exclusive\n", 0x21uLL, 1uLL, __stderrp);
              goto LABEL_79;
            }
            puts("Foreground mode.");
            dword_10008F9F0 = 1;
            break;
          case 'L':
            dword_10008F9F4 = 1;
            continue;
          default:
            if (v6 != 80) {
              goto LABEL_80;
            }
            *(_WORD *)(qword_10008F848 + 18) = atoi(optarg);
            continue;
        }
      }
      if (v6 != 52) {
        break;
      }
      *(_DWORD *)(qword_10008F848 + 24) = 2;
    }
    if (v6 != 54) {
      break;
    }
    *(_DWORD *)(qword_10008F848 + 24) = 30;
  }
  if (v6 != -1 || optind != a1) {
    goto LABEL_80;
  }
  if (dword_10008FA20)
  {
    uint64_t v7 = ne_log_obj();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 67109632;
      *(_DWORD *)&uint8_t buf[4] = getpid();
      *(_WORD *)&uint8_t buf[8] = 1024;
      *(_DWORD *)&buf[10] = getppid();
      *(_WORD *)&unsigned char buf[14] = 1024;
      *(_DWORD *)&uint8_t buf[16] = dword_10008F860;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "racoon started: pid=%d  started by: %d, launchdlaunched %d\n", buf, 0x14u);
    }
    if (dword_10008FA20)
    {
      unsigned int v8 = ne_log_obj();
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136315138;
        *(void *)&uint8_t buf[4] = aRacoonIpsecToo_0;
        _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "%s\n", buf, 0xCu);
      }
      if (dword_10008FA20)
      {
        size_t v9 = ne_log_obj();
        if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v10 = *(void *)qword_10008F848;
          *(_DWORD *)buf = 136315138;
          *(void *)&uint8_t buf[4] = v10;
          _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "Reading configuration from \"%s\"\n", buf, 0xCu);
        }
      }
    }
  }
  if ((sub_10002ED04() & 0x80000000) != 0) {
    sub_100060630();
  }
  word_10008C78E = *(_WORD *)(qword_10008F848 + 16);
  if (sub_100053928()) {
    sub_100060818();
  }
  uint64_t v11 = qword_10008F848;
  *(_WORD *)(qword_10008F848 + 16) = word_10008C78E;
  if (!*(void *)(v11 + 128) && !byte_10008FA24) {
    sub_100033F80(*(char **)(v11 + 168));
  }
  *(_DWORD *)buf = 4500;
  if (sysctlbyname("net.inet.ipsec.esp_port", 0, 0, buf, 4uLL)) {
    sub_1000607E0((int *)buf);
  }
  if (!xmmword_10008FE38 || qword_10008FE90 || (uint64_t result = sub_100045560(255), !result))
  {
    if (dword_10008C788) {
      sub_100039128();
    }
    if (dword_10008F9F0)
    {
      close(0);
      goto LABEL_60;
    }
    if ((byte_10008C78C & 1) != 0 || !dword_10008F860)
    {
      if (!byte_10008C78C)
      {
        uint64_t v38 = 0;
        long long v37 = 0u;
        long long v36 = 0u;
        long long v35 = 0u;
        long long v34 = 0u;
        long long v33 = 0u;
        long long v32 = 0u;
        long long v31 = 0u;
        long long v30 = 0u;
        long long v29 = 0u;
        long long v28 = 0u;
        long long v27 = 0u;
        long long v26 = 0u;
        long long v25 = 0u;
        long long v24 = 0u;
        long long v23 = 0u;
        *(_OWORD *)&uint8_t buf[8] = 0u;
        __envp = 0;
        if (a1 < 33)
        {
          if (daemon(0, 0) < 0) {
            sub_1000606B4();
          }
          if (setuid(0))
          {
            if (dword_10008FA20)
            {
              __int16 v19 = ne_log_obj();
              if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR)) {
                sub_1000607AC();
              }
            }
          }
          else if (setgid(0))
          {
            if (dword_10008FA20)
            {
              int v20 = ne_log_obj();
              if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR)) {
                sub_100060778();
              }
            }
          }
          else
          {
            *(void *)buf = "/usr/sbin/racoon";
            if (a1 >= 2) {
              memcpy(&buf[8], a2 + 1, 8 * (a1 - 1));
            }
            int v17 = &buf[8 * a1];
            *int v17 = "-x";
            v17[1] = 0;
            execve("/usr/sbin/racoon", (char *const *)buf, &__envp);
            if (dword_10008FA20)
            {
              int v18 = ne_log_obj();
              if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR)) {
                sub_1000606E4(v18);
              }
            }
          }
        }
        else if (dword_10008FA20)
        {
          size_t v16 = ne_log_obj();
          if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR)) {
            sub_100060680();
          }
        }
LABEL_79:
        exit(1);
      }
      if (atexit((void (*)(void))sub_100028D1C) < 0)
      {
        if (dword_10008FA20)
        {
          unsigned int v15 = ne_log_obj();
          if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR)) {
LABEL_70:
          }
            sub_10006064C();
        }
      }
    }
    else
    {
      if (dword_10008FA20)
      {
        __darwin_ct_rune_t v13 = ne_log_obj();
        if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "racoon launched by launchd.\n", buf, 2u);
        }
      }
      byte_10008C78C = 1;
      if (atexit((void (*)(void))sub_100028D1C) < 0)
      {
        if (dword_10008FA20)
        {
          __darwin_ct_rune_t v14 = ne_log_obj();
          if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR)) {
            goto LABEL_70;
          }
        }
      }
    }
LABEL_60:
    sub_10005059C();
    sub_10003AD3C();
  }
  return result;
}

uint64_t sub_100028D1C()
{
  uint64_t result = getpid();
  if (dword_10008F85C == result)
  {
    uint64_t v1 = *(unsigned char **)(qword_10008F848 + 160);
    if (!v1 || *v1 == 47)
    {
      __strlcpy_chk();
    }
    else
    {
      __strlcat_chk();
      __strlcat_chk();
    }
    return unlink(v2);
  }
  return result;
}

void sub_100028DF4()
{
}

uint64_t sub_100028ED8(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    for (uint64_t i = 0; i != a2; ++i)
    {
      if (i && (i & 0x1F) == 0) {
        putchar(10);
      }
      if ((i & 3) == 0) {
        putchar(32);
      }
      printf("%02x", *(unsigned __int8 *)(a1 + i));
    }
  }
  putchar(10);
  return 0;
}

const char *sub_100028F68(unsigned int a1, int a2)
{
  if (a2 > 128) {
    return "Failed to convert.";
  }
  uint64_t v2 = byte_10008C790;
  __memset_chk();
  byte_10008C790[a2] = 0;
  int v5 = a2 - 1;
  if (a2 >= 1)
  {
    uint64_t v6 = 0;
    do
    {
      if ((a1 >> v6)) {
        byte_10008C790[v5] = 49;
      }
      ++v6;
      --v5;
    }
    while (a2 != v6);
  }
  return v2;
}

char *sub_100028FFC(char *a1, uint64_t a2, uint64_t a3)
{
  if (a3) {
    snprintf(byte_10008C811, 0x400uLL, "%s:%d:%s()");
  }
  else {
    snprintf(byte_10008C811, 0x400uLL, "%s:%d");
  }
  return byte_10008C811;
}

uint64_t sub_100029088(const char *a1)
{
  memset(&v2, 0, sizeof(v2));
  if (stat(a1, &v2)) {
    return 0xFFFFFFFFLL;
  }
  else {
    return LODWORD(v2.st_size);
  }
}

double sub_1000290D0(uint64_t a1, uint64_t a2)
{
  int v2 = *(_DWORD *)(a2 + 8);
  int v3 = *(_DWORD *)(a1 + 8);
  if (v2 >= v3)
  {
    uint64_t v4 = -*(void *)a1;
  }
  else
  {
    v2 += 1000000;
    uint64_t v4 = ~*(void *)a1;
  }
  return (double)(v2 - v3) / 1000000.0 + (double)(*(void *)a2 + v4);
}

char *sub_10002911C(char *a1, uint64_t a2)
{
  if (a2)
  {
    uint64_t v3 = a2;
    int v4 = 0;
    int v5 = a1;
    while (1)
    {
      __darwin_ct_rune_t v7 = *v5++;
      __darwin_ct_rune_t v6 = v7;
      if (v7 < 0)
      {
        if (__maskrune(v6, 0x800uLL)) {
          goto LABEL_10;
        }
      }
      else if ((_DefaultRuneLocale.__runetype[v6] & 0x800) != 0)
      {
        goto LABEL_10;
      }
      if (!v4 || a1[v4 - 1] == 32) {
        goto LABEL_11;
      }
      LOBYTE(v6) = 32;
LABEL_10:
      a1[v4++] = v6;
LABEL_11:
      if (!--v3) {
        goto LABEL_14;
      }
    }
  }
  int v4 = 0;
LABEL_14:
  a1[v4] = 0;
  return a1;
}

uint64_t sub_1000291C8()
{
  uint64_t v1 = 0;
  int v2 = 0;
  int v2 = sub_10003DA30("FFFFFFFF FFFFFFFF C90FDAA2 2168C234 C4C6628B 80DC1CD129024E08 8A67CC74 020BBEA6 3B139B22 514A0879 8E3404DDEF9519B3 CD3A431B 302B0A6D F25F1437 4FE1356D 6D51C245E485B576 625E7EC6 F44C42E9 A63A3620 FFFFFFFF FFFFFFFF", 16, &v1);
  *(_OWORD *)&qword_10008F990 = 0u;
  unk_10008F9A0 = 0u;
  qword_10008F9B0 = 0;
  qword_10008F988 = 0x100000001;
  qword_10008F990 = (uint64_t)sub_10003FAC0((uint64_t)&v1);
  qword_10008F998 = 2;
  free(v2);
  uint64_t v1 = 0;
  int v2 = 0;
  int v2 = sub_10003DA30("FFFFFFFF FFFFFFFF C90FDAA2 2168C234 C4C6628B 80DC1CD129024E08 8A67CC74 020BBEA6 3B139B22 514A0879 8E3404DDEF9519B3 CD3A431B 302B0A6D F25F1437 4FE1356D 6D51C245E485B576 625E7EC6 F44C42E9 A637ED6B 0BFF5CB6 F406B7EDEE386BFB 5A899FA5 AE9F2411 7C4B1FE6 49286651 ECE65381FFFFFFFF FFFFFFFF", 16, &v1);
  *(_OWORD *)&qword_10008F870 = 0u;
  unk_10008F880 = 0u;
  qword_10008F890 = 0;
  qword_10008F868 = 0x100000002;
  qword_10008F870 = (uint64_t)sub_10003FAC0((uint64_t)&v1);
  qword_10008F878 = 2;
  free(v2);
  uint64_t v1 = 0;
  int v2 = 0;
  int v2 = sub_10003DA30("FFFFFFFF FFFFFFFF C90FDAA2 2168C234 C4C6628B 80DC1CD129024E08 8A67CC74 020BBEA6 3B139B22 514A0879 8E3404DDEF9519B3 CD3A431B 302B0A6D F25F1437 4FE1356D 6D51C245E485B576 625E7EC6 F44C42E9 A637ED6B 0BFF5CB6 F406B7EDEE386BFB 5A899FA5 AE9F2411 7C4B1FE6 49286651 ECE45B3DC2007CB8 A163BF05 98DA4836 1C55D39A 69163FA8 FD24CF5F83655D23 DCA3AD96 1C62F356 208552BB 9ED52907 7096966D670C354E 4ABC9804 F1746C08 CA237327 FFFFFFFF FFFFFFFF", 16, &v1);
  *(_OWORD *)&qword_10008F8A0 = 0u;
  *(_OWORD *)algn_10008F8B0 = 0u;
  qword_10008F8C0 = 0;
  qword_10008F898 = 0x100000005;
  qword_10008F8A0 = (uint64_t)sub_10003FAC0((uint64_t)&v1);
  qword_10008F8A8 = 2;
  free(v2);
  uint64_t v1 = 0;
  int v2 = 0;
  int v2 = sub_10003DA30("FFFFFFFF FFFFFFFF C90FDAA2 2168C234 C4C6628B 80DC1CD129024E08 8A67CC74 020BBEA6 3B139B22 514A0879 8E3404DDEF9519B3 CD3A431B 302B0A6D F25F1437 4FE1356D 6D51C245E485B576 625E7EC6 F44C42E9 A637ED6B 0BFF5CB6 F406B7EDEE386BFB 5A899FA5 AE9F2411 7C4B1FE6 49286651 ECE45B3DC2007CB8 A163BF05 98DA4836 1C55D39A 69163FA8 FD24CF5F83655D23 DCA3AD96 1C62F356 208552BB 9ED52907 7096966D670C354E 4ABC9804 F1746C08 CA18217C 32905E46 2E36CE3BE39E772C 180E8603 9B2783A2 EC07A28F B5C55DF0 6F4C52C9DE2BCBF6 95581718 3995497C EA956AE5 15D22618 98FA051015728E5A 8AACAA68 FFFFFFFF FFFFFFFF", 16, &v1);
  *(_OWORD *)&qword_10008F8D0 = 0u;
  unk_10008F8E0 = 0u;
  qword_10008F8F0 = 0;
  qword_10008F8C8 = 0x10000000ELL;
  qword_10008F8D0 = (uint64_t)sub_10003FAC0((uint64_t)&v1);
  qword_10008F8D8 = 2;
  free(v2);
  uint64_t v1 = 0;
  int v2 = 0;
  int v2 = sub_10003DA30("FFFFFFFF FFFFFFFF C90FDAA2 2168C234 C4C6628B 80DC1CD129024E08 8A67CC74 020BBEA6 3B139B22 514A0879 8E3404DDEF9519B3 CD3A431B 302B0A6D F25F1437 4FE1356D 6D51C245E485B576 625E7EC6 F44C42E9 A637ED6B 0BFF5CB6 F406B7EDEE386BFB 5A899FA5 AE9F2411 7C4B1FE6 49286651 ECE45B3DC2007CB8 A163BF05 98DA4836 1C55D39A 69163FA8 FD24CF5F83655D23 DCA3AD96 1C62F356 208552BB 9ED52907 7096966D670C354E 4ABC9804 F1746C08 CA18217C 32905E46 2E36CE3BE39E772C 180E8603 9B2783A2 EC07A28F B5C55DF0 6F4C52C9DE2BCBF6 95581718 3995497C EA956AE5 15D22618 98FA051015728E5A 8AAAC42D AD33170D 04507A33 A85521AB DF1CBA64ECFB8504 58DBEF0A 8AEA7157 5D060C7D B3970F85 A6E1E4C7ABF5AE8C DB0933D7 1E8C94E0 4A25619D CEE3D226 1AD2EE6BF12FFA06 D98A0864 D8760273 3EC86A64 521F2B18 177B200CBBE11757 7A615D6C 770988C0 BAD946E2 08E24FA0 74E5AB3143DB5BFC E0FD108E 4B82D120 A93AD2CA FFFFFFFF FFFFFFFF", 16, &v1);
  *(_OWORD *)&qword_10008F900 = 0u;
  *(_OWORD *)algn_10008F910 = 0u;
  qword_10008F920 = 0;
  qword_10008F8F8 = 0x10000000FLL;
  qword_10008F900 = (uint64_t)sub_10003FAC0((uint64_t)&v1);
  qword_10008F908 = 2;
  free(v2);
  uint64_t v1 = 0;
  int v2 = 0;
  int v2 = sub_10003DA30("FFFFFFFF FFFFFFFF C90FDAA2 2168C234 C4C6628B 80DC1CD129024E08 8A67CC74 020BBEA6 3B139B22 514A0879 8E3404DDEF9519B3 CD3A431B 302B0A6D F25F1437 4FE1356D 6D51C245E485B576 625E7EC6 F44C42E9 A637ED6B 0BFF5CB6 F406B7EDEE386BFB 5A899FA5 AE9F2411 7C4B1FE6 49286651 ECE45B3DC2007CB8 A163BF05 98DA4836 1C55D39A 69163FA8 FD24CF5F83655D23 DCA3AD96 1C62F356 208552BB 9ED52907 7096966D670C354E 4ABC9804 F1746C08 CA18217C 32905E46 2E36CE3BE39E772C 180E8603 9B2783A2 EC07A28F B5C55DF0 6F4C52C9DE2BCBF6 95581718 3995497C EA956AE5 15D22618 98FA051015728E5A 8AAAC42D AD33170D 04507A33 A85521AB DF1CBA64ECFB8504 58DBEF0A 8AEA7157 5D060C7D B3970F85 A6E1E4C7ABF5AE8C DB0933D7 1E8C94E0 4A25619D CEE3D226 1AD2EE6BF12FFA06 D98A0864 D8760273 3EC86A64 521F2B18 177B200CBBE11757 7A615D6C 770988C0 BAD946E2 08E24FA0 74E5AB3143DB5BFC E0FD108E 4B82D120 A9210801 1A723C12 A787E6D788719A10 BDBA5B26 99C32718 6AF4E23C 1A946834 B6150BDA2583E9CA 2AD44CE8 DBBBC2DB 04DE8EF9 2E8EFC14 1FBECAA6287C5947 4E6BC05D 99B2964F A090C3A2 233BA186 515BE7ED1F612970 CEE2D7AF B81BDD76 2170481C D0069127 D5B05AA993B4EA98 8D8FDDC1 86FFB7DC 90A6C08F 4DF435C9 34063199FFFFFFFF FFFFFFFF", 16, &v1);
  *(_OWORD *)&qword_10008F930 = 0u;
  unk_10008F940 = 0u;
  qword_10008F950 = 0;
  qword_10008F928 = 0x100000010;
  qword_10008F930 = (uint64_t)sub_10003FAC0((uint64_t)&v1);
  qword_10008F938 = 2;
  free(v2);
  uint64_t v1 = 0;
  int v2 = 0;
  int v2 = sub_10003DA30("FFFFFFFF FFFFFFFF C90FDAA2 2168C234 C4C6628B 80DC1CD129024E08 8A67CC74 020BBEA6 3B139B22 514A0879 8E3404DDEF9519B3 CD3A431B 302B0A6D F25F1437 4FE1356D 6D51C245E485B576 625E7EC6 F44C42E9 A637ED6B 0BFF5CB6 F406B7EDEE386BFB 5A899FA5 AE9F2411 7C4B1FE6 49286651 ECE45B3DC2007CB8 A163BF05 98DA4836 1C55D39A 69163FA8 FD24CF5F83655D23 DCA3AD96 1C62F356 208552BB 9ED52907 7096966D670C354E 4ABC9804 F1746C08 CA18217C 32905E46 2E36CE3BE39E772C 180E8603 9B2783A2 EC07A28F B5C55DF0 6F4C52C9DE2BCBF6 95581718 3995497C EA956AE5 15D22618 98FA051015728E5A 8AAAC42D AD33170D 04507A33 A85521AB DF1CBA64ECFB8504 58DBEF0A 8AEA7157 5D060C7D B3970F85 A6E1E4C7ABF5AE8C DB0933D7 1E8C94E0 4A25619D CEE3D226 1AD2EE6BF12FFA06 D98A0864 D8760273 3EC86A64 521F2B18 177B200CBBE11757 7A615D6C 770988C0 BAD946E2 08E24FA0 74E5AB3143DB5BFC E0FD108E 4B82D120 A9210801 1A723C12 A787E6D788719A10 BDBA5B26 99C32718 6AF4E23C 1A946834 B6150BDA2583E9CA 2AD44CE8 DBBBC2DB 04DE8EF9 2E8EFC14 1FBECAA6287C5947 4E6BC05D 99B2964F A090C3A2 233BA186 515BE7ED1F612970 CEE2D7AF B81BDD76 2170481C D0069127 D5B05AA993B4EA98 8D8FDDC1 86FFB7DC 90A6C08F 4DF435C9 3402849236C3FAB4 D27C7026 C1D4DCB2 602646DE C9751E76 3DBA37BDF8FF9406 AD9E530E E5DB382F 413001AE B06A53ED 9027D831179727B0 865A8918 DA3EDBEB CF9B14ED 44CE6CBA CED4BB1BDB7F1447 E6CC254B 33205151 2BD7AF42 6FB8F401 378CD2BF5983CA01 C64B92EC F032EA15 D1721D03 F482D7CE 6E74FEF6D55E702F 46980C82 B5A84031 900B1C9E 59E7C97F BEC7E8F323A97A7E 36CC88BE 0F1D45B7 FF585AC5 4BD407B2 2B4154AACC8F6D7E BF48E1D8 14CC5ED2 0F8037E0 A79715EE F29BE32806A1D58B B7C5DA76 F550AA3D 8A1FBFF0 EB19CCB1 A313D55CDA56C9EC 2EF29632 387FE8D7 6E3C0468 043E8F66 3F4860EE12BF2D5B 0B7474D6 E694F91E 6DCC4024 FFFFFFFF FFFFFFFF", 16, &v1);
  *(_OWORD *)&qword_10008F960 = 0u;
  *(_OWORD *)algn_10008F970 = 0u;
  qword_10008F980 = 0;
  qword_10008F958 = 0x100000011;
  qword_10008F960 = (uint64_t)sub_10003FAC0((uint64_t)&v1);
  qword_10008F968 = 2;
  free(v2);
  uint64_t v1 = 0;
  int v2 = 0;
  int v2 = sub_10003DA30("FFFFFFFF FFFFFFFF C90FDAA2 2168C234 C4C6628B 80DC1CD129024E08 8A67CC74 020BBEA6 3B139B22 514A0879 8E3404DDEF9519B3 CD3A431B 302B0A6D F25F1437 4FE1356D 6D51C245E485B576 625E7EC6 F44C42E9 A637ED6B 0BFF5CB6 F406B7EDEE386BFB 5A899FA5 AE9F2411 7C4B1FE6 49286651 ECE45B3DC2007CB8 A163BF05 98DA4836 1C55D39A 69163FA8 FD24CF5F83655D23 DCA3AD96 1C62F356 208552BB 9ED52907 7096966D670C354E 4ABC9804 F1746C08 CA18217C 32905E46 2E36CE3BE39E772C 180E8603 9B2783A2 EC07A28F B5C55DF0 6F4C52C9DE2BCBF6 95581718 3995497C EA956AE5 15D22618 98FA051015728E5A 8AAAC42D AD33170D 04507A33 A85521AB DF1CBA64ECFB8504 58DBEF0A 8AEA7157 5D060C7D B3970F85 A6E1E4C7ABF5AE8C DB0933D7 1E8C94E0 4A25619D CEE3D226 1AD2EE6BF12FFA06 D98A0864 D8760273 3EC86A64 521F2B18 177B200CBBE11757 7A615D6C 770988C0 BAD946E2 08E24FA0 74E5AB3143DB5BFC E0FD108E 4B82D120 A9210801 1A723C12 A787E6D788719A10 BDBA5B26 99C32718 6AF4E23C 1A946834 B6150BDA2583E9CA 2AD44CE8 DBBBC2DB 04DE8EF9 2E8EFC14 1FBECAA6287C5947 4E6BC05D 99B2964F A090C3A2 233BA186 515BE7ED1F612970 CEE2D7AF B81BDD76 2170481C D0069127 D5B05AA993B4EA98 8D8FDDC1 86FFB7DC 90A6C08F 4DF435C9 3402849236C3FAB4 D27C7026 C1D4DCB2 602646DE C9751E76 3DBA37BDF8FF9406 AD9E530E E5DB382F 413001AE B06A53ED 9027D831179727B0 865A8918 DA3EDBEB CF9B14ED 44CE6CBA CED4BB1BDB7F1447 E6CC254B 33205151 2BD7AF42 6FB8F401 378CD2BF5983CA01 C64B92EC F032EA15 D1721D03 F482D7CE 6E74FEF6D55E702F 46980C82 B5A84031 900B1C9E 59E7C97F BEC7E8F323A97A7E 36CC88BE 0F1D45B7 FF585AC5 4BD407B2 2B4154AACC8F6D7E BF48E1D8 14CC5ED2 0F8037E0 A79715EE F29BE32806A1D58B B7C5DA76 F550AA3D 8A1FBFF0 EB19CCB1 A313D55CDA56C9EC 2EF29632 387FE8D7 6E3C0468 043E8F66 3F4860EE12BF2D5B 0B7474D6 E694F91E 6DBE1159 74A3926F 12FEE5E438777CB6 A932DF8C D8BEC4D0 73B931BA 3BC832B6 8D9DD300741FA7BF 8AFC47ED 2576F693 6BA42466 3AAB639C 5AE4F5683423B474 2BF1C978 238F16CB E39D652D E3FDB8BE FC848AD922222E04 A4037C07 13EB57A8 1A23F0C7 3473FC64 6CEA306B4BCBC886 2F8385DD FA9D4B7F A2C087E8 79683303 ED5BDD3A062B3CF5 B3A278A6 6D2A13F8 3F44F82D DF310EE0 74AB6A364597E899 A0255DC1 64F31CC5 0846851D F9AB4819 5DED7EA1B1D510BD 7EE74D73 FAF36BC3 1ECFA268 359046"
         "F4 EB879F924009438B 481C6CD7 889A002E D5EE382B C9190DA6 FC026E479558E447 5677E9AA 9E3050E2 765694DF C81F56E8 80"
         "B96E7160C980DD 98EDD3DF FFFFFFFF FFFFFFFF",
         16,
         &v1);
  *(_OWORD *)&qword_10008F9C0 = 0u;
  *(_OWORD *)algn_10008F9D0 = 0u;
  qword_10008F9E0 = 0;
  qword_10008F9B8 = 0x100000012;
  qword_10008F9C0 = (uint64_t)sub_10003FAC0((uint64_t)&v1);
  qword_10008F9C8 = 2;
  free(v2);
  return 0;
}

void sub_1000294BC(void *a1)
{
  int v2 = (void *)a1[1];
  if (v2)
  {
    sub_10003FA78(v2);
    a1[1] = 0;
  }
  uint64_t v3 = (void *)a1[3];
  if (v3)
  {
    sub_10003FA78(v3);
    a1[3] = 0;
  }
  int v4 = (void *)a1[4];
  if (v4)
  {
    sub_10003FA78(v4);
    a1[4] = 0;
  }
  int v5 = (void *)a1[5];
  if (v5) {
    sub_10003FA78(v5);
  }

  free(a1);
}

uint64_t sub_10002952C(uint64_t a1, void *a2, void **a3, void *a4)
{
  if (dword_10008FA20)
  {
    unsigned int v8 = ne_log_obj();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG)) {
      sub_10006097C();
    }
  }
  if (*a2 != **(void **)(a1 + 8))
  {
    if (dword_10008FA20)
    {
      __darwin_ct_rune_t v13 = ne_log_obj();
      if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR)) {
        sub_100060908();
      }
    }
    goto LABEL_16;
  }
  size_t v9 = SecDHGetMaxKeyLength();
  uint64_t v10 = sub_10003F940(v9);
  if (!v10)
  {
    if (dword_10008FA20)
    {
      __darwin_ct_rune_t v14 = ne_log_obj();
      if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR)) {
        sub_10006086C();
      }
    }
LABEL_16:
    uint64_t v11 = 0;
LABEL_17:
    if (*a4)
    {
      SecDHDestroy();
      *a4 = 0;
    }
    sub_10003FA78(*a3);
    sub_10003FA78(v11);
    return 0xFFFFFFFFLL;
  }
  uint64_t v11 = v10;
  size_t __n = *v10;
  if (SecDHComputeKey())
  {
    if (dword_10008FA20)
    {
      int v12 = ne_log_obj();
      if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR)) {
        sub_1000608D4();
      }
    }
    goto LABEL_17;
  }
  size_t v16 = sub_10003F940(v9);
  *a3 = v16;
  if (!v16)
  {
    if (dword_10008FA20)
    {
      int v18 = ne_log_obj();
      if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR)) {
        sub_10006086C();
      }
    }
    goto LABEL_17;
  }
  memcpy((void *)(v16[1] + v9 - __n), (const void *)v11[1], __n);
  if (dword_10008FA20)
  {
    int v17 = ne_log_obj();
    if (os_log_type_enabled(v17, OS_LOG_TYPE_DEBUG)) {
      sub_1000608A0();
    }
  }
  if (*a4)
  {
    SecDHDestroy();
    *a4 = 0;
  }
  sub_10003FA78(v11);
  return 0;
}

uint64_t sub_10002972C(uint64_t a1, size_t **a2, void *a3)
{
  if (dword_10008FA20)
  {
    __darwin_ct_rune_t v6 = ne_log_obj();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG)) {
      sub_100060BC0();
    }
  }
  *a2 = 0;
  int v7 = *(_DWORD *)(a1 + 4);
  if ((v7 - 2) >= 2)
  {
    if (v7 != 1)
    {
      if (dword_10008FA20)
      {
        uint64_t v10 = ne_log_obj();
        if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR)) {
          sub_1000609B0();
        }
      }
      goto LABEL_16;
    }
    if (SecDHCreate())
    {
      if (dword_10008FA20)
      {
        size_t v9 = ne_log_obj();
        if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR)) {
          sub_100060B20();
        }
      }
      goto LABEL_16;
    }
    size_t v13 = SecDHGetMaxKeyLength();
    uint64_t v11 = sub_10003F940(v13);
    size_t __n = *v11;
    if (SecDHGenerateKeypair())
    {
      if (dword_10008FA20)
      {
        __darwin_ct_rune_t v14 = ne_log_obj();
        if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR)) {
          sub_100060AEC();
        }
      }
      goto LABEL_17;
    }
    if (dword_10008FA20)
    {
      unsigned int v15 = ne_log_obj();
      if (os_log_type_enabled(v15, OS_LOG_TYPE_DEBUG)) {
        sub_100060AB8();
      }
    }
    size_t v16 = sub_10003F940(v13);
    *a2 = v16;
    if (!v16)
    {
      if (dword_10008FA20)
      {
        uint32_t v21 = ne_log_obj();
        if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR)) {
          sub_10006086C();
        }
      }
      goto LABEL_17;
    }
    memcpy((void *)(v16[1] + v13 - __n), (const void *)v11[1], __n);
    int v17 = *(size_t **)(a1 + 8);
    int v18 = *a2;
    size_t v19 = **a2;
    if (*v17 != v19)
    {
      if (*v17 < v19)
      {
        if (!dword_10008FA20) {
          goto LABEL_17;
        }
        int v20 = ne_log_obj();
        if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR)) {
          sub_100060A50();
        }
LABEL_42:
        if (dword_10008FA20)
        {
          long long v25 = ne_log_obj();
          if (os_log_type_enabled(v25, OS_LOG_TYPE_DEBUG)) {
            sub_100060A1C();
          }
        }
        goto LABEL_17;
      }
      BOOL v22 = sub_10003F940(*v17);
      if (!v22)
      {
        if (!dword_10008FA20) {
          goto LABEL_17;
        }
        long long v24 = ne_log_obj();
        if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR)) {
          sub_100060A84();
        }
        goto LABEL_42;
      }
      long long v23 = v22;
      memcpy((void *)(v22[1] + *v17 - *v18), (const void *)v18[1], *v18);
      sub_10003FA78(*a2);
      *a2 = v23;
    }
    sub_10003FA78(v11);
    return 0;
  }
  if (dword_10008FA20)
  {
    unsigned int v8 = ne_log_obj();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR)) {
      sub_100060B54();
    }
  }
LABEL_16:
  uint64_t v11 = 0;
LABEL_17:
  if (*a3)
  {
    SecDHDestroy();
    *a3 = 0;
  }
  sub_10003FA78(*a2);
  sub_10003FA78(v11);
  return 0xFFFFFFFFLL;
}

uint64_t sub_100029A30(int a1, uint64_t a2)
{
  *(void *)a2 = 0;
  uint64_t v3 = sub_1000036B8(a1);
  if (!v3)
  {
    if (dword_10008FA20)
    {
      uint64_t v11 = ne_log_obj();
      if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR)) {
        sub_100060BF4();
      }
    }
    return 0xFFFFFFFFLL;
  }
  int v4 = v3;
  if (!*((_DWORD *)v3 + 1) || !v3[1] || !*((_DWORD *)v3 + 4))
  {
    if (dword_10008FA20)
    {
      uint64_t v10 = ne_log_obj();
      if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR)) {
        sub_100060C5C();
      }
    }
    return 0xFFFFFFFFLL;
  }
  int v5 = malloc_type_calloc(1uLL, 0x30uLL, 0x10200409D20112CuLL);
  *(void *)a2 = v5;
  if (v5)
  {
    long long v6 = *(_OWORD *)v4;
    long long v7 = *((_OWORD *)v4 + 2);
    v5[1] = *((_OWORD *)v4 + 1);
    _DWORD v5[2] = v7;
    *int v5 = v6;
    unsigned int v8 = sub_10003FAC0((uint64_t)v4[1]);
    uint64_t result = 0;
    *(void *)(*(void *)a2 + 8) = v8;
    return result;
  }
  if (!dword_10008FA20) {
    return 0;
  }
  int v12 = ne_log_obj();
  uint64_t result = os_log_type_enabled(v12, OS_LOG_TYPE_ERROR);
  if (result)
  {
    sub_100060A84();
    return 0;
  }
  return result;
}

uint64_t sub_100029B74(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(void *)(a3 + 72);
  if (!v3 || *(unsigned char *)(a3 + 80) != 16 || (uint64_t result = sub_1000030EC(*(_DWORD *)(v3 + 52), a1, a2)) == 0)
  {
    if (dword_10008FA20)
    {
      int v5 = ne_log_obj();
      if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR)) {
        sub_100060CC4();
      }
    }
    return 0;
  }
  return result;
}

uint64_t sub_100029C00(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 72);
  if (v2 && *(unsigned char *)(a2 + 80) == 16) {
    int v3 = *(_DWORD *)(v2 + 52);
  }
  else {
    int v3 = 1;
  }
  uint64_t v4 = sub_10000305C(v3, a1);
  if (!v4)
  {
    if (dword_10008FA20)
    {
      int v5 = ne_log_obj();
      if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR)) {
        sub_100060D2C();
      }
    }
  }
  return v4;
}

uint64_t sub_100029C94(uint64_t a1, int a2)
{
  if (*(_DWORD *)(*(void *)(a1 + 128) + 20))
  {
    uint64_t v4 = *(void **)(a1 + 176);
    if (v4)
    {
      if ((sub_10002952C(*(void *)(a1 + 152), v4, (void **)(a1 + 184), (void *)(a1 + 144)) & 0x80000000) != 0) {
        return 0xFFFFFFFFLL;
      }
    }
  }
  if ((sub_100029D40(a1, a2, 1) & 0x80000000) != 0 || (sub_100029D40(a1, a2, 0) & 0x80000000) != 0) {
    return 0xFFFFFFFFLL;
  }
  if (dword_10008FA20)
  {
    int v5 = ne_log_obj();
    uint64_t result = os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG);
    if (!result) {
      return result;
    }
    sub_100060D94();
  }
  return 0;
}

uint64_t sub_100029D40(uint64_t a1, int a2, int a3)
{
  if (*(_DWORD *)(*(void *)(a1 + 128) + 20) && (long long v6 = *(void **)(a1 + 184)) != 0)
  {
    uint64_t v7 = *v6 + 5;
    int v8 = 1;
  }
  else
  {
    int v8 = 0;
    LODWORD(v7) = 5;
  }
  size_t v9 = sub_10003F940((int)v7 + **(_DWORD **)(a1 + 208) + **(_DWORD **)(a1 + 216));
  if (!v9)
  {
    if (dword_10008FA20)
    {
      long long v42 = ne_log_obj();
      if (os_log_type_enabled(v42, OS_LOG_TYPE_ERROR)) {
        sub_100060DC8();
      }
    }
LABEL_73:
    long long v33 = 0;
    goto LABEL_74;
  }
  uint64_t v10 = *(void *)(*(void *)(a1 + 128) + 32);
  if (!v10)
  {
    long long v33 = 0;
    uint64_t v40 = 0;
LABEL_81:
    sub_10003FA78(v9);
    goto LABEL_82;
  }
  BOOL v11 = a2 == 0;
  if (a2) {
    uint64_t v12 = 216;
  }
  else {
    uint64_t v12 = 208;
  }
  if (v11) {
    uint64_t v13 = 216;
  }
  else {
    uint64_t v13 = 208;
  }
  int v52 = v8;
  int v53 = a3;
  uint64_t v50 = v13;
  uint64_t v51 = v12;
  while (2)
  {
    size_t v14 = v9[1];
    if (v8)
    {
      memcpy((void *)v9[1], *(const void **)(*(void *)(a1 + 184) + 8), **(void **)(a1 + 184));
      v14 += **(void **)(a1 + 184);
    }
    *(unsigned char *)size_t v14 = *(_DWORD *)v10;
    uint64_t v15 = 24;
    if (a3 != 1) {
      uint64_t v15 = 28;
    }
    *(_DWORD *)(v14 + 1) = *(_DWORD *)(v10 + v15);
    size_t v16 = (char *)(v14 + 5);
    uint64_t v17 = *(void *)(a1 + v12);
    memcpy(v16, *(const void **)(v17 + 8), *(void *)v17);
    memcpy(&v16[*(void *)v17], *(const void **)(*(void *)(a1 + v13) + 8), **(void **)(a1 + v13));
    uint64_t v18 = sub_100029B74(*(void *)(*(void *)(a1 + 256) + 200), (uint64_t)v9, *(void *)(a1 + 256));
    if (!v18) {
      goto LABEL_73;
    }
    uint64_t v19 = v18;
    if (*(_DWORD *)v10 == 2)
    {
      uint64_t v25 = *(void *)(v10 + 64);
      if (v25)
      {
        int v21 = 0;
        do
        {
          int v26 = sub_100003510(*(_DWORD *)(v25 + 4));
          if (v26 > v21) {
            int v21 = v26;
          }
          uint64_t v25 = *(void *)(v25 + 16);
        }
        while (v25);
        int v22 = 0;
        goto LABEL_36;
      }
    }
    else if (*(_DWORD *)v10 == 3)
    {
      uint64_t v20 = *(void *)(v10 + 64);
      if (v20)
      {
        int v21 = 0;
        int v22 = 0;
        do
        {
          int v23 = sub_100003434(*(_DWORD *)(v20 + 4), *(unsigned int *)(v20 + 8));
          if (v23 > v22) {
            int v22 = v23;
          }
          int v24 = sub_100003510(*(_DWORD *)(v20 + 12));
          if (v24 > v21) {
            int v21 = v24;
          }
          uint64_t v20 = *(void *)(v20 + 16);
        }
        while (v20);
        goto LABEL_36;
      }
    }
    int v22 = 0;
    int v21 = 0;
LABEL_36:
    if (dword_10008FA20)
    {
      long long v27 = ne_log_obj();
      if (os_log_type_enabled(v27, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 67109376;
        int v55 = v22;
        __int16 v56 = 1024;
        int v57 = v21;
        _os_log_debug_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEBUG, "encklen=%d authklen=%d\n", buf, 0xEu);
      }
    }
    size_t v28 = *(void *)v19;
    long long v29 = sub_10003F940(*v9 + *(void *)v19);
    if (v29)
    {
      uint64_t v30 = (uint64_t)v29;
      int v31 = v21 + v22;
      if (v21 + v22 < 0 != __OFADD__(v21, v22)) {
        int v31 = v21 + v22 + 7;
      }
      unint64_t v32 = ((uint64_t)v31 >> 3) / v28;
      if ((int)v32 <= 1) {
        LODWORD(v32) = 1;
      }
      long long v33 = (void **)v19;
      do
      {
        int v34 = v32;
        memcpy(*(void **)(v30 + 8), *(const void **)(v19 + 8), *(void *)v19);
        memcpy((void *)(*(void *)(v30 + 8) + *(void *)v19), (const void *)v9[1], *v9);
        long long v35 = (void **)sub_100029B74(*(void *)(*(void *)(a1 + 256) + 200), v30, *(void *)(a1 + 256));
        if (!v35)
        {
          if (dword_10008FA20)
          {
            long long v43 = ne_log_obj();
            if (os_log_type_enabled(v43, OS_LOG_TYPE_ERROR)) {
              sub_100060DFC();
            }
          }
          if ((void **)v19 != v33) {
            sub_10003FA78((void *)v19);
          }
          sub_10003FA78(0);
          sub_10003FA78((void *)v30);
          goto LABEL_74;
        }
        long long v36 = v35;
        long long v37 = (char *)*v33;
        uint64_t v38 = sub_10003F9BC(v33, (size_t)*v33 + (void)*v35);
        if ((void **)v19 == v33) {
          uint64_t v19 = (uint64_t)v38;
        }
        if (!v38)
        {
          if (dword_10008FA20 && (long long v44 = ne_log_obj(), os_log_type_enabled(v44, OS_LOG_TYPE_ERROR)))
          {
            sub_100060DC8();
            if (v19) {
LABEL_71:
            }
              sub_10003FA78((void *)v19);
          }
          else if (v19)
          {
            goto LABEL_71;
          }
          sub_10003FA78(v36);
          sub_10003FA78((void *)v30);
          goto LABEL_73;
        }
        long long v39 = v38;
        long long v33 = v38;
        memcpy(&v37[(void)v38[1]], v36[1], (size_t)*v36);
        if ((void **)v19 != v39) {
          sub_10003FA78((void *)v19);
        }
        LODWORD(v32) = v34 - 1;
        uint64_t v19 = (uint64_t)v36;
      }
      while (v34);
      if (v36 != v39) {
        sub_10003FA78(v36);
      }
      sub_10003FA78((void *)v30);
      uint64_t v40 = 0;
      int v8 = v52;
      a3 = v53;
      uint64_t v41 = 40;
      if (v53 == 1) {
        uint64_t v41 = 32;
      }
      *(void *)(v10 + v41) = v33;
      uint64_t v10 = *(void *)(v10 + 72);
      long long v33 = 0;
      uint64_t v13 = v50;
      uint64_t v12 = v51;
      if (v10) {
        continue;
      }
      goto LABEL_81;
    }
    break;
  }
  if (dword_10008FA20)
  {
    long long v49 = ne_log_obj();
    if (os_log_type_enabled(v49, OS_LOG_TYPE_ERROR)) {
      sub_100060DC8();
    }
  }
  long long v33 = (void **)v19;
LABEL_74:
  for (uint64_t i = *(void **)(*(void *)(a1 + 128) + 32); i; uint64_t i = (void *)i[9])
  {
    long long v46 = (void *)i[4];
    if (v46)
    {
      sub_10003FA78(v46);
      i[4] = 0;
    }
    long long v47 = (void *)i[5];
    if (v47)
    {
      sub_10003FA78(v47);
      i[5] = 0;
    }
  }
  uint64_t v40 = 0xFFFFFFFFLL;
  if (v9) {
    goto LABEL_81;
  }
LABEL_82:
  if (v33) {
    sub_10003FA78(v33);
  }
  return v40;
}

uint64_t sub_10002A230(uint64_t a1, int a2, uint64_t a3)
{
  long long v6 = sub_10003F940(*(_DWORD *)a3 + 5);
  if (v6)
  {
    uint64_t v7 = v6;
    *(unsigned char *)v6[1] = 0;
    *(_DWORD *)(v6[1] + 1) = a2;
    memcpy((void *)(v6[1] + 5), *(const void **)(a3 + 8), *(void *)a3);
    uint64_t v8 = sub_100029B74(*(void *)(a1 + 208), (uint64_t)v7, a1);
    sub_10003FA78(v7);
    return v8;
  }
  else
  {
    if (dword_10008FA20)
    {
      uint64_t v10 = ne_log_obj();
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)BOOL v11 = 0;
        _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "failed to get hash buffer\n", v11, 2u);
      }
    }
    return 0;
  }
}

uint64_t sub_10002A314(uint64_t a1, int a2, uint64_t a3)
{
  long long v6 = sub_10003F940(*(_DWORD *)a3 + 4);
  if (v6)
  {
    uint64_t v7 = v6;
    uint64_t v8 = (_DWORD *)v6[1];
    *uint64_t v8 = a2;
    memcpy(v8 + 1, *(const void **)(a3 + 8), *(void *)a3);
    uint64_t v9 = sub_100029B74(*(void *)(a1 + 208), (uint64_t)v7, a1);
    sub_10003FA78(v7);
    return v9;
  }
  else
  {
    if (dword_10008FA20)
    {
      BOOL v11 = ne_log_obj();
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)uint64_t v12 = 0;
        _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "failed to get hash buffer\n", v12, 2u);
      }
    }
    return 0;
  }
}

uint64_t sub_10002A3E8(uint64_t a1, int a2)
{
  if (a2 == 1) {
    uint64_t v4 = 312;
  }
  else {
    uint64_t v4 = 320;
  }
  int v5 = sub_10003F940(**(_DWORD **)(a1 + 152)
                   + **(_DWORD **)(a1 + 160)
                   + **(_DWORD **)(a1 + 336)
                   + **(_DWORD **)(a1 + v4) + 16);
  if (v5)
  {
    long long v6 = v5;
    BOOL v7 = a2 == 1;
    BOOL v8 = a2 == 1;
    BOOL v9 = a2 != 1;
    uint64_t v10 = v5[1];
    if (v7) {
      uint64_t v11 = 152;
    }
    else {
      uint64_t v11 = 160;
    }
    uint64_t v12 = *(void *)(a1 + v11);
    if (v7) {
      uint64_t v13 = 160;
    }
    else {
      uint64_t v13 = 152;
    }
    memcpy((void *)v5[1], *(const void **)(v12 + 8), *(void *)v12);
    size_t v14 = (char *)(v10 + *(void *)v12);
    uint64_t v15 = *(void *)(a1 + v13);
    memcpy(v14, *(const void **)(v15 + 8), *(void *)v15);
    size_t v16 = &v14[*(void *)v15];
    if (*(_DWORD *)(a1 + 20)) {
      uint64_t v17 = 8 * v8;
    }
    else {
      uint64_t v17 = 8 * v9;
    }
    *(void *)size_t v16 = *(void *)(a1 + v17);
    if (*(_DWORD *)(a1 + 20)) {
      uint64_t v18 = 8 * v9;
    }
    else {
      uint64_t v18 = 8 * v8;
    }
    *((void *)v16 + 1) = *(void *)(a1 + v18);
    uint64_t v19 = v16 + 16;
    uint64_t v20 = *(void *)(a1 + 336);
    memcpy(v16 + 16, *(const void **)(v20 + 8), *(void *)v20);
    memcpy((char *)v19 + *(void *)v20, *(const void **)(*(void *)(a1 + v4) + 8), **(void **)(a1 + v4));
    uint64_t v21 = sub_100029B74(*(void *)(a1 + 192), (uint64_t)v6, a1);
    sub_10003FA78(v6);
    return v21;
  }
  else
  {
    if (dword_10008FA20)
    {
      int v23 = ne_log_obj();
      if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR)) {
        sub_100060E30();
      }
    }
    return 0;
  }
}

uint64_t sub_10002A570(uint64_t a1, int a2)
{
  if (*(unsigned char *)(a1 + 81) != 1)
  {
    if (dword_10008FA20)
    {
      BOOL v7 = ne_log_obj();
      if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR)) {
        sub_100060F00();
      }
    }
    return 0;
  }
  int v4 = *(_DWORD *)(*(void *)(a1 + 72) + 48);
  if (*(void *)(*(void *)(a1 + 64) + 272)) {
    BOOL v5 = v4 == 65001;
  }
  else {
    BOOL v5 = 0;
  }
  if (v5) {
    goto LABEL_21;
  }
  if (v4 <= 64220)
  {
    if ((v4 - 4) >= 2 && v4 != 1)
    {
      if (v4 != 3)
      {
LABEL_57:
        if (dword_10008FA20)
        {
          uint64_t v30 = ne_log_obj();
          if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR)) {
            sub_100060E98();
          }
        }
        return 0;
      }
      goto LABEL_45;
    }
    goto LABEL_21;
  }
  if ((v4 - 65002) <= 8)
  {
    int v6 = 1 << (v4 + 22);
    if ((v6 & 0x1E1) == 0)
    {
      if ((v6 & 0x18) != 0) {
        goto LABEL_45;
      }
      goto LABEL_10;
    }
LABEL_21:
    uint64_t v9 = *(void *)(a1 + 192);
    if (!v9)
    {
      if (dword_10008FA20)
      {
        uint64_t v20 = ne_log_obj();
        if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR)) {
          sub_100060E64();
        }
      }
      return 0;
    }
    uint64_t v10 = 0;
    goto LABEL_23;
  }
LABEL_10:
  if ((v4 - 64221) >= 2)
  {
    if (v4 != 65500) {
      goto LABEL_57;
    }
    goto LABEL_21;
  }
LABEL_45:
  int v23 = sub_10003F940(**(_DWORD **)(a1 + 184) + **(_DWORD **)(a1 + 176));
  if (!v23)
  {
    if (dword_10008FA20)
    {
      long long v29 = ne_log_obj();
      if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR)) {
        sub_100060E30();
      }
    }
    return 0;
  }
  size_t v14 = v23;
  uint64_t v24 = v23[1];
  if (a2 == 1) {
    uint64_t v25 = 184;
  }
  else {
    uint64_t v25 = 176;
  }
  uint64_t v26 = *(void *)(a1 + v25);
  if (a2 == 1) {
    uint64_t v27 = 176;
  }
  else {
    uint64_t v27 = 184;
  }
  memcpy((void *)v23[1], *(const void **)(v26 + 8), *(void *)v26);
  memcpy((void *)(v24 + *(void *)v26), *(const void **)(*(void *)(a1 + v27) + 8), **(void **)(a1 + v27));
  uint64_t v28 = sub_100029C00((uint64_t)v14, a1);
  if (!v28)
  {
    uint64_t v19 = 0;
    goto LABEL_33;
  }
  uint64_t v9 = v28;
  sub_10003FA78(v14);
  uint64_t v10 = (void *)v9;
LABEL_23:
  if (a2 == 1) {
    uint64_t v11 = 152;
  }
  else {
    uint64_t v11 = 160;
  }
  if (a2 == 1) {
    uint64_t v12 = 312;
  }
  else {
    uint64_t v12 = 320;
  }
  uint64_t v13 = sub_10003F940(**(_DWORD **)(a1 + v11) + **(_DWORD **)(a1 + 336) + **(_DWORD **)(a1 + v12) + 16);
  size_t v14 = v13;
  if (v13)
  {
    uint64_t v15 = (char *)v13[1];
    uint64_t v16 = *(void *)(a1 + v11);
    memcpy(v15, *(const void **)(v16 + 8), *(void *)v16);
    uint64_t v17 = &v15[*(void *)v16];
    *(void *)uint64_t v17 = *(void *)a1;
    *((void *)v17 + 1) = *(void *)(a1 + 8);
    uint64_t v18 = v17 + 16;
    memcpy(v17 + 16, *(const void **)(*(void *)(a1 + 336) + 8), **(void **)(a1 + 336));
    memcpy((char *)v18 + **(void **)(a1 + 336), *(const void **)(*(void *)(a1 + v12) + 8), **(void **)(a1 + v12));
    uint64_t v19 = sub_100029B74(v9, (uint64_t)v14, a1);
    if (!v10) {
      goto LABEL_32;
    }
    goto LABEL_31;
  }
  if (dword_10008FA20)
  {
    int v22 = ne_log_obj();
    if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR)) {
      sub_100060E30();
    }
  }
  uint64_t v19 = 0;
  if (v10) {
LABEL_31:
  }
    sub_10003FA78(v10);
LABEL_32:
  if (v14) {
LABEL_33:
  }
    sub_10003FA78(v14);
  return v19;
}

uint64_t sub_10002A8C0(uint64_t a1, int a2)
{
  if (*(unsigned char *)(a1 + 81) != 1)
  {
    if (dword_10008FA20)
    {
      BOOL v8 = ne_log_obj();
      if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR)) {
        sub_100060F00();
      }
    }
    return 0;
  }
  int v4 = *(_DWORD *)(*(void *)(a1 + 72) + 48);
  if (*(void *)(*(void *)(a1 + 64) + 272)) {
    BOOL v5 = v4 == 65001;
  }
  else {
    BOOL v5 = 0;
  }
  if (!v5)
  {
    if (v4 > 65004)
    {
      if ((v4 - 65005) >= 2 && v4 != 65500) {
        goto LABEL_11;
      }
    }
    else if ((v4 - 64221) >= 2 && v4 != 3)
    {
LABEL_11:
      if (dword_10008FA20)
      {
        BOOL v7 = ne_log_obj();
        if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR)) {
          sub_100060E98();
        }
      }
      return 0;
    }
  }
  uint64_t v10 = sub_10003F940(**(_DWORD **)(a1 + 184) + **(_DWORD **)(a1 + 176));
  if (!v10)
  {
    if (dword_10008FA20)
    {
      long long v29 = ne_log_obj();
      if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR)) {
        sub_100060E30();
      }
    }
    return 0;
  }
  uint64_t v11 = v10;
  uint64_t v12 = v10[1];
  if (a2 == 1) {
    uint64_t v13 = 184;
  }
  else {
    uint64_t v13 = 176;
  }
  uint64_t v14 = *(void *)(a1 + v13);
  if (a2 == 1) {
    uint64_t v15 = 176;
  }
  else {
    uint64_t v15 = 184;
  }
  memcpy((void *)v10[1], *(const void **)(v14 + 8), *(void *)v14);
  memcpy((void *)(v12 + *(void *)v14), *(const void **)(*(void *)(a1 + v15) + 8), **(void **)(a1 + v15));
  uint64_t v16 = (void *)sub_100029C00((uint64_t)v11, a1);
  sub_10003FA78(v11);
  if (!v16) {
    return 0;
  }
  if (a2 == 1) {
    uint64_t v17 = 160;
  }
  else {
    uint64_t v17 = 152;
  }
  if (a2 == 1) {
    uint64_t v18 = 152;
  }
  else {
    uint64_t v18 = 160;
  }
  if (a2 == 1) {
    uint64_t v19 = 320;
  }
  else {
    uint64_t v19 = 312;
  }
  uint64_t v20 = sub_10003F940(**(_DWORD **)(a1 + v17)
                    + **(_DWORD **)(a1 + v18)
                    + **(_DWORD **)(a1 + 336)
                    + **(_DWORD **)(a1 + v19) + 16);
  if (v20)
  {
    uint64_t v21 = v20;
    int v22 = (char *)v20[1];
    uint64_t v23 = *(void *)(a1 + v17);
    memcpy(v22, *(const void **)(v23 + 8), *(void *)v23);
    uint64_t v24 = &v22[*(void *)v23];
    uint64_t v25 = *(void *)(a1 + v18);
    memcpy(v24, *(const void **)(v25 + 8), *(void *)v25);
    uint64_t v26 = &v24[*(void *)v25];
    *(void *)uint64_t v26 = *(void *)a1;
    *((void *)v26 + 1) = *(void *)(a1 + 8);
    uint64_t v27 = v26 + 16;
    memcpy(v26 + 16, *(const void **)(*(void *)(a1 + 336) + 8), **(void **)(a1 + 336));
    memcpy((char *)v27 + **(void **)(a1 + 336), *(const void **)(*(void *)(a1 + v19) + 8), **(void **)(a1 + v19));
    uint64_t v28 = sub_100029B74((uint64_t)v16, (uint64_t)v21, a1);
    sub_10003FA78(v21);
  }
  else
  {
    if (dword_10008FA20)
    {
      int v31 = ne_log_obj();
      if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR)) {
        sub_100060E30();
      }
    }
    uint64_t v28 = 0;
  }
  sub_10003FA78(v16);
  return v28;
}

uint64_t sub_10002ABA8(uint64_t a1)
{
  CFTypeRef cf = 0;
  uint64_t v2 = a1 + 64;
  uint64_t v3 = *(void *)(*(void *)(a1 + 64) + 272);
  uint64_t v4 = a1 + 72;
  int v5 = *(_DWORD *)(*(void *)(a1 + 72) + 48);
  int v6 = 65001;
  if (v3) {
    BOOL v7 = v5 == 65001;
  }
  else {
    BOOL v7 = 0;
  }
  if (v7) {
    goto LABEL_26;
  }
  if (v5 > 65004)
  {
    if ((v5 - 65007) < 4)
    {
LABEL_12:
      if (*(void *)(a1 + 320) && *(void *)(a1 + 352))
      {
        if (dword_10008FA20)
        {
          BOOL v8 = ne_log_obj();
          if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR)) {
            sub_1000613C8(v4);
          }
        }
        return 0xFFFFFFFFLL;
      }
      if (!dword_10008FA20) {
        return 16;
      }
      uint64_t v9 = ne_log_obj();
      uint64_t v10 = 16;
      if (!os_log_type_enabled(v9, OS_LOG_TYPE_ERROR)) {
        return v10;
      }
      goto LABEL_19;
    }
    if ((v5 - 65005) < 2) {
      goto LABEL_51;
    }
    int v11 = 65500;
LABEL_25:
    int v6 = *(_DWORD *)(*(void *)(a1 + 72) + 48);
    if (v5 != v11)
    {
LABEL_83:
      if (dword_10008FA20)
      {
        int v34 = ne_log_obj();
        if (os_log_type_enabled(v34, OS_LOG_TYPE_ERROR)) {
          sub_10005C33C();
        }
      }
      return 0xFFFFFFFFLL;
    }
    goto LABEL_26;
  }
  if (v5 > 64220)
  {
    if (v5 == 64221) {
      goto LABEL_51;
    }
    if (v5 == 64222)
    {
      if (**(unsigned char **)(a1 + 408))
      {
        if (dword_10008FA20)
        {
          uint64_t v41 = ne_log_obj();
          uint64_t v10 = 0;
          if (!os_log_type_enabled(v41, OS_LOG_TYPE_DEFAULT)) {
            return v10;
          }
          LOWORD(v67) = 0;
          _os_log_impl((void *)&_mh_execute_header, v41, OS_LOG_TYPE_DEFAULT, "No SIG was passed, but hybrid auth is enabled\n", (uint8_t *)&v67, 2u);
        }
        return 0;
      }
      if (!dword_10008FA20) {
        return 3;
      }
      long long v33 = ne_log_obj();
      if (!os_log_type_enabled(v33, OS_LOG_TYPE_ERROR)) {
        return 3;
      }
LABEL_81:
      sub_100060F34();
      return 3;
    }
    int v11 = 65002;
    goto LABEL_25;
  }
  if ((v5 - 4) < 2) {
    goto LABEL_12;
  }
  int v6 = *(_DWORD *)(*(void *)(a1 + 72) + 48);
  if (v5 == 1)
  {
LABEL_26:
    if (*(void *)(a1 + 320))
    {
      uint64_t v12 = *(void *)(a1 + 352);
      if (v12)
      {
        BOOL v14 = v6 == 65001 && v3 != 0 || v6 == 65500;
        if (v14 && (**(unsigned char **)(a1 + 408) & 1) == 0)
        {
          if (!dword_10008FA20) {
            return 3;
          }
          uint64_t v15 = ne_log_obj();
          if (!os_log_type_enabled(v15, OS_LOG_TYPE_ERROR)) {
            return 3;
          }
          goto LABEL_81;
        }
        if (*(unsigned char *)(a1 + 80) != 16) {
          return 0xFFFFFFFFLL;
        }
        int v17 = *(unsigned __int8 *)(a1 + 81);
        if (v17 == 1)
        {
          if (*(_DWORD *)(a1 + 20))
          {
            uint64_t v37 = sub_10002A570(a1, 0);
LABEL_96:
            uint64_t v38 = (void *)v37;
            if (!v37) {
              return 0xFFFFFFFFLL;
            }
            int v39 = memcmp(*(const void **)(v37 + 8), (const void *)(v12 + 4), *(void *)v37);
            sub_10003FA78(v38);
            if (!v39)
            {
              if (dword_10008FA20)
              {
                long long v42 = ne_log_obj();
                if (os_log_type_enabled(v42, OS_LOG_TYPE_DEBUG)) {
                  sub_100060FD4();
                }
              }
              return 0;
            }
            if (dword_10008FA20)
            {
              uint64_t v40 = ne_log_obj();
              if (os_log_type_enabled(v40, OS_LOG_TYPE_ERROR)) {
                sub_100061008();
              }
            }
            return 23;
          }
        }
        else if (v17 != 4 && v17 != 2)
        {
          if (dword_10008FA20)
          {
            uint64_t v18 = ne_log_obj();
            if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR)) {
              sub_100060F68();
            }
          }
          return 7;
        }
        uint64_t v37 = sub_10002A3E8(a1, 0);
        goto LABEL_96;
      }
    }
    if (!dword_10008FA20) {
      return 16;
    }
    uint64_t v16 = ne_log_obj();
    uint64_t v10 = 16;
    if (!os_log_type_enabled(v16, OS_LOG_TYPE_ERROR)) {
      return v10;
    }
LABEL_19:
    sub_10005B014();
    return v10;
  }
  if (v5 != 3) {
    goto LABEL_83;
  }
LABEL_51:
  if (!*(void *)(a1 + 320))
  {
    if (dword_10008FA20)
    {
      unint64_t v32 = ne_log_obj();
      uint64_t v10 = 16;
      if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR)) {
        sub_10006103C();
      }
      return v10;
    }
    return 16;
  }
  if (!*(void *)(a1 + 272))
  {
    if (dword_10008FA20)
    {
      long long v35 = ne_log_obj();
      uint64_t v10 = 16;
      if (os_log_type_enabled(v35, OS_LOG_TYPE_ERROR)) {
        sub_100061070();
      }
      return v10;
    }
    return 16;
  }
  if (dword_10008FA20)
  {
    uint64_t v19 = ne_log_obj();
    if (os_log_type_enabled(v19, OS_LOG_TYPE_DEBUG)) {
      sub_100061394();
    }
  }
  if (*(_DWORD *)(*(void *)v2 + 108) != 1)
  {
    if (dword_10008FA20)
    {
      long long v36 = ne_log_obj();
      if (os_log_type_enabled(v36, OS_LOG_TYPE_ERROR)) {
        sub_100061324();
      }
    }
    return 0xFFFFFFFFLL;
  }
  if (!*(void *)(a1 + 288))
  {
    if (dword_10008FA20)
    {
      long long v43 = ne_log_obj();
      if (os_log_type_enabled(v43, OS_LOG_TYPE_ERROR)) {
        sub_1000610A4();
      }
    }
    return 0xFFFFFFFFLL;
  }
  if (!*(_DWORD *)(*(void *)v2 + 124)) {
    goto LABEL_124;
  }
  uint64_t v10 = sub_10002B49C(a1);
  if (v10) {
    return v10;
  }
  uint64_t v20 = *(void *)v2;
  if (!*(_DWORD *)(*(void *)v2 + 124) || *(_DWORD *)(v20 + 108) != 1)
  {
LABEL_124:
    if (dword_10008FA20)
    {
      uint64_t v48 = ne_log_obj();
      if (os_log_type_enabled(v48, OS_LOG_TYPE_DEBUG)) {
        sub_100061254();
      }
    }
    if (*(unsigned char *)(a1 + 80) != 16) {
      return 0xFFFFFFFFLL;
    }
    int v49 = *(unsigned __int8 *)(a1 + 81);
    if (v49 == 1)
    {
      if (*(_DWORD *)(a1 + 20)) {
        uint64_t v50 = sub_10002A570(a1, 0);
      }
      else {
        uint64_t v50 = sub_10002A8C0(a1, 0);
      }
LABEL_138:
      int v52 = (void *)v50;
      if (v50)
      {
        uint64_t v53 = *(void *)v2;
        int v54 = *(_DWORD *)(*(void *)v2 + 104);
        uint64_t v55 = *(void *)(v53 + 272);
        int v56 = *(_DWORD *)(*(void *)v4 + 48);
        BOOL v57 = v56 != 65001 || v55 == 0;
        if (v57 && v56 == 64221) {
          int v54 = **(unsigned __int8 **)(a1 + 288);
        }
        if (v54 != 4)
        {
          if (dword_10008FA20)
          {
            uint8_t v62 = ne_log_obj();
            if (os_log_type_enabled(v62, OS_LOG_TYPE_ERROR)) {
              sub_1000611EC();
            }
          }
          sub_10003FA78(v52);
          return 0xFFFFFFFFLL;
        }
        if (!cf)
        {
          if (dword_10008FA20)
          {
            char v58 = ne_log_obj();
            if (os_log_type_enabled(v58, OS_LOG_TYPE_ERROR)) {
              sub_1000611B8();
            }
          }
        }
        if (*(unsigned char *)(a1 + 80) == 16)
        {
          int v59 = sub_100004B7C((__SecKey *)cf, (uint64_t)v52, *(void *)(a1 + 272), 0);
          if (v59)
          {
            if (dword_10008FA20)
            {
              uint64_t v60 = ne_log_obj();
              if (os_log_type_enabled(v60, OS_LOG_TYPE_ERROR)) {
                sub_100061140(v59);
              }
            }
          }
          CFRelease(cf);
          sub_10003FA78(v52);
          if (v59)
          {
            if (dword_10008FA20)
            {
              int v61 = ne_log_obj();
              if (os_log_type_enabled(v61, OS_LOG_TYPE_ERROR)) {
                sub_1000610D8();
              }
            }
            return 25;
          }
        }
        else
        {
          CFRelease(cf);
          sub_10003FA78(v52);
        }
        if (dword_10008FA20)
        {
          int v64 = ne_log_obj();
          if (os_log_type_enabled(v64, OS_LOG_TYPE_DEBUG)) {
            sub_10006110C();
          }
        }
        return 0;
      }
      return 0xFFFFFFFFLL;
    }
    if (v49 == 4 || v49 == 2)
    {
      uint64_t v50 = sub_10002A3E8(a1, 0);
      goto LABEL_138;
    }
    if (dword_10008FA20)
    {
      uint64_t v51 = ne_log_obj();
      if (os_log_type_enabled(v51, OS_LOG_TYPE_ERROR)) {
        sub_100060F68();
      }
    }
    return 7;
  }
  int v21 = *(_DWORD *)(v20 + 104);
  int v22 = *(_DWORD *)(*(void *)v4 + 48);
  BOOL v23 = v22 != 65001 || *(void *)(v20 + 272) == 0;
  if (v23 && v22 == 64221) {
    int v21 = **(unsigned __int8 **)(a1 + 288);
  }
  if (v21 != 4)
  {
    if (dword_10008FA20)
    {
      long long v44 = ne_log_obj();
      if (os_log_type_enabled(v44, OS_LOG_TYPE_ERROR)) {
        sub_1000611EC();
      }
    }
    return 0xFFFFFFFFLL;
  }
  uint64_t v24 = 0;
  uint64_t v67 = 0;
  if (*(_DWORD *)(v20 + 132) != 1)
  {
LABEL_117:
    uint64_t v45 = sub_10002B53C(a1);
    int v46 = sub_100004024(v45, *(void *)(a1 + 288), v24, (SecKeyRef *)&cf);
    if (v24) {
      CFRelease(v24);
    }
    if (v46)
    {
      if (dword_10008FA20)
      {
        long long v47 = ne_log_obj();
        if (os_log_type_enabled(v47, OS_LOG_TYPE_ERROR)) {
          sub_1000612F0();
        }
      }
      return 22;
    }
    goto LABEL_124;
  }
  uint64_t v25 = sub_1000061E0(*(void **)(v20 + 56), &v67);
  uint64_t v26 = *(CFIndex **)(v25 + 8);
  CFIndex v27 = v26[1];
  if (*(_DWORD *)v25 != 4)
  {
    CFStringRef v31 = CFStringCreateWithBytes(0, (const UInt8 *)v27, *v26, 0x8000100u, 0);
    goto LABEL_116;
  }
  int v28 = *(unsigned __int8 *)(v27 + 1);
  if (v28 == 30) {
    return 18;
  }
  if (v28 == 2)
  {
    v29.s_addr = *(_DWORD *)(v27 + 4);
    uint64_t v30 = inet_ntoa(v29);
    CFStringRef v31 = CFStringCreateWithCString(0, v30, 0x8000100u);
LABEL_116:
    uint64_t v24 = (__CFString *)v31;
    if (v31) {
      goto LABEL_117;
    }
    if (dword_10008FA20)
    {
      char v65 = ne_log_obj();
      if (os_log_type_enabled(v65, OS_LOG_TYPE_ERROR)) {
        sub_1000612BC();
      }
    }
    return 18;
  }
  if (dword_10008FA20)
  {
    __int16 v66 = ne_log_obj();
    if (os_log_type_enabled(v66, OS_LOG_TYPE_ERROR)) {
      sub_100061288();
    }
  }
  return 24;
}

uint64_t sub_10002B49C(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 320);
  if (v1 && (uint64_t v2 = *(void *)(a1 + 288)) != 0)
  {
    uint64_t v3 = *(unsigned __int8 **)(v1 + 8);
    int v6 = *v3;
    uint64_t v4 = (uint64_t)(v3 + 4);
    int v5 = v6;
    int v7 = *(_DWORD *)v1 - 4;
    while (1)
    {
      uint64_t result = sub_10002BC44(v2 + 8, v5, v7, v4, (_DWORD *)(v2 + 32));
      if (!result) {
        break;
      }
      uint64_t v2 = *(void *)(v2 + 40);
      if (!v2) {
        return 18;
      }
    }
  }
  else
  {
    if (dword_10008FA20)
    {
      uint64_t v9 = ne_log_obj();
      if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR)) {
        sub_100061448();
      }
    }
    return 18;
  }
  return result;
}

uint64_t sub_10002B53C(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 320);
  if (v1 && (uint64_t v2 = *(void *)(a1 + 288)) != 0)
  {
    if (*(void *)(v2 + 40))
    {
      uint64_t v3 = *(unsigned __int8 **)(v1 + 8);
      int v4 = *(_DWORD *)v1 - 4;
      do
      {
        if (!sub_10002BC44(v2 + 8, *v3, v4, (uint64_t)(v3 + 4), (_DWORD *)(v2 + 32))) {
          break;
        }
        uint64_t v2 = *(void *)(v2 + 40);
      }
      while (v2);
    }
  }
  else
  {
    if (dword_10008FA20)
    {
      int v5 = ne_log_obj();
      if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR)) {
        sub_100061448();
      }
    }
    return 0;
  }
  return v2;
}

uint64_t sub_10002B5E8(uint64_t result, int a2)
{
  if (result)
  {
    while (*(_DWORD *)(result + 32) != a2)
    {
      uint64_t result = *(void *)(result + 40);
      if (!result) {
        return result;
      }
    }
    return 1;
  }
  return result;
}

uint64_t sub_10002B60C(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 64);
  if (*(_DWORD *)(v1 + 104) != 4)
  {
    if (dword_10008FA20)
    {
      int v4 = ne_log_obj();
      if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR)) {
        sub_10006163C();
      }
    }
    return 0xFFFFFFFFLL;
  }
  if (*(void *)(a1 + 280)) {
    return 0;
  }
  int v25 = 0;
  if (!*(_DWORD *)(v1 + 64))
  {
    if (dword_10008FA20)
    {
      uint64_t v13 = ne_log_obj();
      if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR)) {
        sub_10006147C();
      }
    }
    goto LABEL_24;
  }
  CFDataRef v24 = 0;
  int v5 = *(uint64_t **)(v1 + 72);
  if (!v5 || sub_10002BA14(v5, &v24)) {
    return 0xFFFFFFFFLL;
  }
  CFDataRef v6 = v24;
  int v7 = sub_100004D60(v24, &v25);
  if (dword_10008FA20)
  {
    BOOL v8 = ne_log_obj();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG)) {
      sub_1000615D0();
    }
  }
  CFRelease(v6);
  if (!v7)
  {
    if (dword_10008FA20)
    {
      uint64_t v19 = ne_log_obj();
      if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR)) {
        sub_1000614B0(v19);
      }
    }
    return 0xFFFFFFFFLL;
  }
  uint64_t v9 = sub_10002D760();
  *(void *)(a1 + 280) = v9;
  if (!v9)
  {
    if (dword_10008FA20)
    {
      uint64_t v20 = ne_log_obj();
      if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR)) {
        sub_100061534();
      }
    }
    goto LABEL_49;
  }
  *(void *)(*(void *)(a1 + 280) + 24) = sub_10003F940(*v7 + 1);
  uint64_t v10 = *(void *)(*(void *)(a1 + 280) + 24);
  if (!v10)
  {
    if (dword_10008FA20)
    {
      int v21 = ne_log_obj();
      if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR)) {
        sub_100061568();
      }
    }
    int v22 = *(void **)(a1 + 280);
    if (v22)
    {
      do
      {
        BOOL v23 = (void *)v22[5];
        sub_10002D7E0(v22);
        int v22 = v23;
      }
      while (v23);
    }
    *(void *)(a1 + 280) = 0;
LABEL_49:
    sub_10003FA78(v7);
    return 0xFFFFFFFFLL;
  }
  memcpy((void *)(*(void *)(v10 + 8) + 1), (const void *)v7[1], *v7);
  **(unsigned char **)(*(void *)(*(void *)(a1 + 280) + 24) + 8) = *(_DWORD *)(*(void *)(a1 + 64) + 104);
  uint64_t v11 = *(void *)(a1 + 280);
  *(unsigned char *)uint64_t v11 = *(_DWORD *)(*(void *)(a1 + 64) + 104);
  *(_DWORD *)(v11 + 32) = v25;
  *(void *)(v11 + 16) = *(void *)(*(void *)(v11 + 24) + 8) + 1;
  *(void *)(*(void *)(a1 + 280) + 8) = **(void **)(*(void *)(a1 + 280) + 24) - 1;
  if (dword_10008FA20)
  {
    uint64_t v12 = ne_log_obj();
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG)) {
      sub_10006159C();
    }
  }
  sub_10003FA78(v7);
LABEL_24:
  uint64_t v14 = *(void *)(a1 + 280);
  if (!v14) {
    return 0;
  }
  uint64_t v15 = *(void *)(a1 + 280);
  do
  {
    int v16 = *(_DWORD *)(v15 + 32);
    if (v16 == 1) {
      break;
    }
    uint64_t v15 = *(void *)(v15 + 40);
  }
  while (v15);
  do
  {
    if (*(_DWORD *)(v14 + 32) == 2)
    {
      if (v16 == 1) {
        unsigned __int16 v17 = -15532;
      }
      else {
        unsigned __int16 v17 = -15531;
      }
      goto LABEL_36;
    }
    uint64_t v14 = *(void *)(v14 + 40);
  }
  while (v14);
  if (v16 != 1) {
    return 0;
  }
  unsigned __int16 v17 = -15532;
LABEL_36:
  int v18 = sub_100009F24(a1);
  sub_100049388(v17, 0, v18, 0, 0);
  return 0xFFFFFFFFLL;
}

uint64_t sub_10002B924(void *a1)
{
  uint64_t v1 = a1[8];
  if (*(_DWORD *)(v1 + 104) == 4 && *(_DWORD *)(v1 + 64))
  {
    CFDataRef v8 = 0;
    uint64_t v3 = *(uint64_t **)(v1 + 72);
    if (v3 && !sub_10002BA14(v3, &v8))
    {
      CFDataRef v4 = v8;
      a1[33] = sub_100004B9C(v8, a1[32]);
      CFRelease(v4);
      if (a1[33]) {
        return 0;
      }
      if (dword_10008FA20)
      {
        int v7 = ne_log_obj();
        if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR)) {
          sub_1000616AC();
        }
      }
    }
  }
  else if (dword_10008FA20)
  {
    CFDataRef v6 = ne_log_obj();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR)) {
      sub_10006163C();
    }
  }
  return 0xFFFFFFFFLL;
}

uint64_t sub_10002BA14(uint64_t *a1, CFDataRef *a2)
{
  uint64_t v4 = *a1;
  uint64_t v3 = (unsigned __int8 *)a1[1];
  int v5 = (UInt8 *)malloc_type_malloc((int)*a1, 0x5EE5E58uLL);
  if (v5)
  {
    CFDataRef v6 = v5;
    if ((int)v4 < 1)
    {
      int v10 = 0;
    }
    else
    {
      int v7 = 0;
      int v8 = 0;
      int v9 = 0;
      int v10 = 0;
      do
      {
        unsigned int v12 = *v3++;
        uint64_t v11 = v12;
        if (v12 == 61)
        {
          ++v9;
        }
        else
        {
          if ((v11 & 0x80) != 0) {
            __uint32_t v13 = __maskrune(v11, 0x4000uLL);
          }
          else {
            __uint32_t v13 = _DefaultRuneLocale.__runetype[v11] & 0x4000;
          }
          if (!v13) {
            int v9 = 0;
          }
        }
        if ((byte_10006E5F0[v11] & 0x80000000) == 0)
        {
          ++v7;
          int v8 = byte_10006E5F0[v11] + (v8 << 6);
          if ((v7 & 3) == 0)
          {
            v6[v10] = BYTE2(v8);
            if (v9 > 1)
            {
              ++v10;
            }
            else
            {
              uint64_t v14 = v10 + 2;
              v6[v10 + 1] = BYTE1(v8);
              if (v9 == 1)
              {
                v10 += 2;
              }
              else
              {
                v10 += 3;
                v6[v14] = v8;
              }
            }
          }
        }
        LODWORD(v4) = v4 - 1;
      }
      while (v4);
    }
    *a2 = CFDataCreate(0, v6, v10);
    free(v6);
    if (*a2) {
      return 0;
    }
    else {
      return 0xFFFFFFFFLL;
    }
  }
  else
  {
    sub_10005668C();
    return 0xFFFFFFFFLL;
  }
}

void *sub_10002BB90(void *result)
{
  if (*(_DWORD *)(result[8] + 124))
  {
    uint64_t v1 = result;
    uint64_t result = (void *)sub_10002B49C((uint64_t)result);
    if (result)
    {
      if (dword_10008FA20)
      {
        uint64_t v2 = ne_log_obj();
        if (os_log_type_enabled(v2, OS_LOG_TYPE_DEBUG)) {
          sub_1000616E0();
        }
      }
      uint64_t result = (void *)v1[36];
      if (result)
      {
        do
        {
          uint64_t v3 = (void *)result[5];
          sub_10002D7E0(result);
          uint64_t result = v3;
        }
        while (v3);
      }
      v1[36] = 0;
    }
  }
  return result;
}

void *sub_10002BC10(void *result)
{
  if (result)
  {
    do
    {
      uint64_t v1 = (void *)result[5];
      sub_10002D7E0(result);
      uint64_t result = v1;
    }
    while (v1);
  }
  return result;
}

uint64_t sub_10002BC44(uint64_t a1, int a2, int a3, uint64_t a4, _DWORD *a5)
{
  LODWORD(v8) = a3;
  switch(a2)
  {
    case 1:
    case 5:
      SecCertificateRef v9 = sub_100003B68(a1);
      if (!v9)
      {
        if (!dword_10008FA20) {
          goto LABEL_113;
        }
        long long v72 = ne_log_obj();
        if (!os_log_type_enabled(v72, OS_LOG_TYPE_ERROR)) {
          goto LABEL_113;
        }
        sub_10006178C();
        if (a5) {
          goto LABEL_114;
        }
        return 20;
      }
      SecCertificateRef v10 = v9;
      CFArrayRef v11 = (const __CFArray *)SecCertificateCopyIPAddresses();
      if (v11)
      {
        CFArrayRef v12 = v11;
        CFIndex Count = CFArrayGetCount(v11);
        if (Count < 1)
        {
LABEL_43:
          if (dword_10008FA20)
          {
            uint64_t v37 = ne_log_obj();
            if (os_log_type_enabled(v37, OS_LOG_TYPE_ERROR)) {
              sub_100061950();
            }
            if (dword_10008FA20)
            {
              uint64_t v38 = ne_log_obj();
              if (os_log_type_enabled(v38, OS_LOG_TYPE_ERROR)) {
                sub_1000618D8(a2);
              }
            }
          }
          if (dword_10008C2C8 >= 3) {
            sub_100033908(3, a4, (int)v8, "ID:\n", v14, v15, v16, v17, v92);
          }
          goto LABEL_80;
        }
        CFIndex v18 = Count;
        CFIndex v19 = 0;
        BOOL v21 = a2 == 1 && v8 > 3;
        BOOL v22 = a2 == 5 && v8 >= 0x10;
        char v23 = !v22;
        BOOL v93 = v21;
        char v94 = v23;
        while (1)
        {
          memset(v95, 0, sizeof(v95));
          int v96 = 0;
          CFStringRef ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(v12, v19);
          if (!CFStringGetLength(ValueAtIndex)) {
            goto LABEL_42;
          }
          int v25 = (char *)malloc_type_malloc(0x40uLL, 0x81734572uLL);
          if (!v25)
          {
            if (dword_10008FA20)
            {
              long long v80 = ne_log_obj();
              if (os_log_type_enabled(v80, OS_LOG_TYPE_ERROR)) {
                sub_100061984();
              }
            }
            uint64_t v61 = 0xFFFFFFFFLL;
            goto LABEL_134;
          }
          uint64_t v26 = v25;
          if (CFStringGetCString(ValueAtIndex, v25, 64, 0x8000100u) != 1)
          {
LABEL_29:
            free(v26);
            goto LABEL_42;
          }
          if (a2 == 1)
          {
            int v27 = inet_pton(2, v26, v95);
            free(v26);
            if (!v27) {
              goto LABEL_42;
            }
            if (v93)
            {
              unsigned int v28 = bswap32(*(_DWORD *)a4);
              unsigned int v29 = bswap32(*(unsigned int *)v95);
              BOOL v22 = v28 >= v29;
              BOOL v30 = v28 > v29;
              int v31 = !v22;
              int v32 = v30 - v31;
              goto LABEL_41;
            }
            if (v94) {
              goto LABEL_42;
            }
          }
          else
          {
            if (a2 != 5) {
              goto LABEL_29;
            }
            int v33 = inet_pton(30, v26, &v95[4]);
            free(v26);
            char v34 = v94;
            if (!v33) {
              char v34 = 1;
            }
            if (v34) {
              goto LABEL_42;
            }
          }
          unint64_t v35 = bswap64(*(void *)a4);
          unint64_t v36 = bswap64(*(unint64_t *)v95);
          if (v35 == v36
            && (v35 = bswap64(*(void *)(a4 + 8)), unint64_t v36 = bswap64(*(unint64_t *)&v95[8]), v35 == v36))
          {
            int v32 = 0;
          }
          else if (v35 < v36)
          {
            int v32 = -1;
          }
          else
          {
            int v32 = 1;
          }
LABEL_41:
          if (!v32)
          {
            uint64_t v61 = 0;
LABEL_134:
            CFRelease(v12);
            CFRelease(v10);
            return v61;
          }
LABEL_42:
          if (v18 == ++v19) {
            goto LABEL_43;
          }
        }
      }
      if (!dword_10008FA20) {
        goto LABEL_122;
      }
      long long v73 = ne_log_obj();
      if (!os_log_type_enabled(v73, OS_LOG_TYPE_ERROR)) {
        goto LABEL_122;
      }
      sub_100059F4C();
      if (a5) {
        goto LABEL_123;
      }
      goto LABEL_146;
    case 2:
      SecCertificateRef v39 = sub_100003B68(a1);
      if (!v39)
      {
        if (!dword_10008FA20) {
          goto LABEL_113;
        }
        long long v74 = ne_log_obj();
        if (!os_log_type_enabled(v74, OS_LOG_TYPE_ERROR)) {
          goto LABEL_113;
        }
        sub_10006178C();
        if (a5) {
          goto LABEL_114;
        }
        return 20;
      }
      SecCertificateRef v10 = v39;
      CFArrayRef v40 = (const __CFArray *)SecCertificateCopyDNSNames();
      if (!v40)
      {
        if (!dword_10008FA20) {
          goto LABEL_122;
        }
        long long v77 = ne_log_obj();
        if (!os_log_type_enabled(v77, OS_LOG_TYPE_ERROR)) {
          goto LABEL_122;
        }
        sub_100059F4C();
        if (a5) {
          goto LABEL_123;
        }
        goto LABEL_146;
      }
      CFArrayRef v12 = v40;
      CFIndex v41 = CFArrayGetCount(v40);
      unint64_t v8 = (int)v8;
      CFStringRef v42 = CFStringCreateWithBytes(kCFAllocatorDefault, (const UInt8 *)a4, (int)v8, 0x8000100u, 0);
      if (!v42)
      {
        if (dword_10008FA20)
        {
          long long v81 = ne_log_obj();
          if (os_log_type_enabled(v81, OS_LOG_TYPE_ERROR)) {
            sub_1000619B8();
          }
        }
        goto LABEL_139;
      }
      CFStringRef v47 = v42;
      if (v41 >= 1)
      {
        for (CFIndex i = 0; i != v41; ++i)
        {
          CFStringRef v49 = (const __CFString *)CFArrayGetValueAtIndex(v12, i);
          if (CFEqual(v49, v47)) {
            goto LABEL_135;
          }
        }
      }
      if (dword_10008FA20)
      {
        uint64_t v50 = ne_log_obj();
        if (os_log_type_enabled(v50, OS_LOG_TYPE_ERROR)) {
          sub_100061950();
        }
        if (dword_10008FA20)
        {
          uint64_t v51 = ne_log_obj();
          if (os_log_type_enabled(v51, OS_LOG_TYPE_ERROR)) {
            sub_1000619EC();
          }
        }
      }
      goto LABEL_77;
    case 3:
      SecCertificateRef v52 = sub_100003B68(a1);
      if (!v52)
      {
        if (dword_10008FA20)
        {
          long long v75 = ne_log_obj();
          if (os_log_type_enabled(v75, OS_LOG_TYPE_ERROR))
          {
            sub_10006178C();
            if (a5) {
              goto LABEL_114;
            }
            return 20;
          }
        }
        goto LABEL_113;
      }
      SecCertificateRef v10 = v52;
      CFArrayRef v53 = (const __CFArray *)SecCertificateCopyRFC822Names();
      if (!v53)
      {
        if (dword_10008FA20 && (long long v78 = ne_log_obj(), os_log_type_enabled(v78, OS_LOG_TYPE_ERROR)))
        {
          sub_100059F4C();
          if (!a5)
          {
LABEL_146:
            CFRelease(v10);
            return 20;
          }
        }
        else
        {
LABEL_122:
          if (!a5) {
            goto LABEL_146;
          }
        }
LABEL_123:
        if (!*a5) {
          *a5 = 4;
        }
        goto LABEL_146;
      }
      CFArrayRef v12 = v53;
      CFIndex v54 = CFArrayGetCount(v53);
      unint64_t v8 = (int)v8;
      CFStringRef v55 = CFStringCreateWithBytes(kCFAllocatorDefault, (const UInt8 *)a4, (int)v8, 0x8000100u, 0);
      if (!v55)
      {
        if (dword_10008FA20 && (long long v82 = ne_log_obj(), os_log_type_enabled(v82, OS_LOG_TYPE_ERROR)))
        {
          sub_1000619B8();
          if (a5)
          {
LABEL_143:
            if (!*a5) {
              *a5 = 5;
            }
          }
        }
        else if (a5)
        {
          goto LABEL_143;
        }
        CFRelease(v12);
        goto LABEL_146;
      }
      CFStringRef v47 = v55;
      if (v54 >= 1)
      {
        for (CFIndex j = 0; j != v54; ++j)
        {
          CFStringRef v57 = (const __CFString *)CFArrayGetValueAtIndex(v12, j);
          if (CFEqual(v57, v47))
          {
LABEL_135:
            CFRelease(v47);
            goto LABEL_139;
          }
        }
      }
      if (dword_10008FA20)
      {
        char v58 = ne_log_obj();
        if (os_log_type_enabled(v58, OS_LOG_TYPE_ERROR)) {
          sub_100061950();
        }
        if (dword_10008FA20)
        {
          int v59 = ne_log_obj();
          if (os_log_type_enabled(v59, OS_LOG_TYPE_ERROR)) {
            sub_100061A68();
          }
        }
      }
LABEL_77:
      if (dword_10008C2C8 >= 3) {
        sub_100033908(3, a4, v8, "ID:\n", v43, v44, v45, v46, v92);
      }
      CFRelease(v47);
LABEL_80:
      CFRelease(v12);
      CFRelease(v10);
      if (a5 && !*a5) {
        *a5 = 4;
      }
      return 18;
    case 9:
      SecCertificateRef v62 = sub_100003B68(a1);
      if (!v62)
      {
        if (dword_10008FA20)
        {
          long long v76 = ne_log_obj();
          if (os_log_type_enabled(v76, OS_LOG_TYPE_ERROR))
          {
            sub_10006178C();
            if (!a5) {
              return 20;
            }
            goto LABEL_114;
          }
        }
LABEL_113:
        if (!a5) {
          return 20;
        }
LABEL_114:
        if (!*a5) {
          *a5 = 5;
        }
        return 20;
      }
      CFArrayRef v12 = v62;
      CFDataRef v63 = (const __CFData *)j__SecCertificateCopySubjectSequence();
      SecCertificateRef v10 = v63;
      if (v63)
      {
        int Length = CFDataGetLength(v63);
        BytePtr = CFDataGetBytePtr(v10);
        if (BytePtr)
        {
          uint64_t v70 = (uint64_t)BytePtr;
          if (Length == v8 && !memcmp((const void *)a4, BytePtr, (int)v8))
          {
LABEL_139:
            CFRelease(v12);
LABEL_169:
            CFRelease(v10);
            return 0;
          }
          if (!dword_10008FA20) {
            goto LABEL_155;
          }
          long long v71 = ne_log_obj();
          if (os_log_type_enabled(v71, OS_LOG_TYPE_ERROR)) {
            sub_10006183C();
          }
LABEL_152:
          if (dword_10008FA20 && (long long v84 = ne_log_obj(), os_log_type_enabled(v84, OS_LOG_TYPE_ERROR)))
          {
            sub_10006183C();
            if (v70) {
              goto LABEL_155;
            }
          }
          else if (v70)
          {
LABEL_155:
            if (dword_10008C2C8 < 3) {
              goto LABEL_165;
            }
            char v85 = sub_10003E8B0(9);
            sub_100033908(3, v70, Length, "subjectName (type %s):\n", v86, v87, v88, v89, v85);
LABEL_163:
            if (dword_10008C2C8 >= 3) {
              sub_100033908(3, a4, (int)v8, "ID:\n", v64, v65, v66, v67, v92);
            }
LABEL_165:
            if (a5 && !*a5) {
              *a5 = 3;
            }
            CFRelease(v12);
            if (!v10) {
              return 0;
            }
            goto LABEL_169;
          }
          if (dword_10008FA20)
          {
            v90 = ne_log_obj();
            if (os_log_type_enabled(v90, OS_LOG_TYPE_ERROR)) {
              sub_1000617C0();
            }
          }
          goto LABEL_163;
        }
        if (!dword_10008FA20) {
          goto LABEL_163;
        }
        long long v83 = ne_log_obj();
        if (os_log_type_enabled(v83, OS_LOG_TYPE_ERROR)) {
          sub_1000618A4();
        }
LABEL_151:
        uint64_t v70 = 0;
        goto LABEL_152;
      }
      if (dword_10008FA20 && (long long v79 = ne_log_obj(), os_log_type_enabled(v79, OS_LOG_TYPE_ERROR)))
      {
        sub_100061870();
        if (a5)
        {
LABEL_128:
          if (!*a5)
          {
            int Length = 0;
            uint64_t v70 = 0;
            *a5 = 3;
            goto LABEL_152;
          }
        }
      }
      else if (a5)
      {
        goto LABEL_128;
      }
      int Length = 0;
      goto LABEL_151;
    default:
      if (dword_10008FA20)
      {
        uint64_t v60 = ne_log_obj();
        if (os_log_type_enabled(v60, OS_LOG_TYPE_ERROR)) {
          sub_100061714(a2);
        }
      }
      return 18;
  }
}

uint64_t sub_10002C5EC(uint64_t a1, uint64_t a2)
{
  if (*(unsigned char *)(a2 + 4) != 4)
  {
    if (dword_10008FA20)
    {
      CFArrayRef v11 = ne_log_obj();
      if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR)) {
        sub_100061B4C();
      }
    }
    return 0xFFFFFFFFLL;
  }
  if (*(void *)(a1 + 288)) {
    BOOL v4 = dword_10008FA20 == 0;
  }
  else {
    BOOL v4 = 1;
  }
  if (!v4)
  {
    int v5 = ne_log_obj();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t v14 = 0;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "preexisting CERT payload... chaining.\n", v14, 2u);
    }
  }
  uint64_t result = (uint64_t)sub_10002C764(a2);
  if (!result)
  {
    if (dword_10008FA20)
    {
      CFArrayRef v12 = ne_log_obj();
      if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR)) {
        sub_100061AE4();
      }
    }
    return 0xFFFFFFFFLL;
  }
  if (*(unsigned char *)result == 4)
  {
    uint64_t v7 = *(void *)(a1 + 288);
    if (v7)
    {
      uint64_t v8 = *(void *)(a1 + 288);
      do
      {
        uint64_t v9 = v8;
        uint64_t v8 = *(void *)(v8 + 40);
      }
      while (v8);
      *(void *)(v9 + 40) = result;
    }
    else
    {
      uint64_t v7 = result;
    }
    *(void *)(a1 + 288) = v7;
    if (!dword_10008FA20) {
      return 0;
    }
    __uint32_t v13 = ne_log_obj();
    uint64_t result = os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG);
    if (result)
    {
      sub_100061B18();
      return 0;
    }
  }
  else
  {
    do
    {
      uint64_t v10 = *(void *)(result + 40);
      sub_10002D7E0((void *)result);
      uint64_t result = v10;
    }
    while (v10);
  }
  return result;
}

void *sub_10002C764(uint64_t a1)
{
  if (bswap32(*(unsigned __int16 *)(a1 + 2)) >> 16 <= 4)
  {
    if (dword_10008FA20)
    {
      uint64_t v1 = ne_log_obj();
      if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR)) {
        sub_100061BB4();
      }
    }
    return 0;
  }
  uint64_t v3 = sub_10002D760();
  if (!v3)
  {
    if (dword_10008FA20)
    {
      uint64_t v8 = ne_log_obj();
      if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR)) {
        sub_100061AE4();
      }
    }
    return 0;
  }
  BOOL v4 = v3;
  int v5 = sub_10003F940((bswap32(*(unsigned __int16 *)(a1 + 2)) >> 16) - 4);
  v4[3] = v5;
  if (v5)
  {
    memcpy((void *)v5[1], (const void *)(a1 + 4), *v5);
    uint64_t v6 = *(void *)v4[3];
    uint64_t v7 = *(unsigned char **)(v4[3] + 8);
    *(unsigned char *)BOOL v4 = *v7;
    v4[1] = v6 - 1;
    v4[2] = v7 + 1;
  }
  else
  {
    if (dword_10008FA20)
    {
      uint64_t v10 = ne_log_obj();
      if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR)) {
        sub_100061BE8();
      }
    }
    do
    {
      CFArrayRef v11 = (void *)v4[5];
      sub_10002D7E0(v4);
      BOOL v4 = v11;
    }
    while (v11);
  }
  return v4;
}

uint64_t sub_10002C89C(uint64_t a1, uint64_t a2)
{
  if (*(unsigned char *)(a2 + 4) != 4)
  {
    if (dword_10008FA20)
    {
      uint64_t v10 = ne_log_obj();
      if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR)) {
        sub_100061C84();
      }
    }
    return 0xFFFFFFFFLL;
  }
  BOOL v4 = *(void **)(a1 + 304);
  if (v4)
  {
    do
    {
      int v5 = (void *)v4[5];
      sub_10002D7E0(v4);
      BOOL v4 = v5;
    }
    while (v5);
    *(void *)(a1 + 304) = 0;
  }
  uint64_t v6 = sub_10002C764(a2);
  if (!v6)
  {
    if (dword_10008FA20)
    {
      CFArrayRef v11 = ne_log_obj();
      if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR)) {
        sub_100061C1C();
      }
    }
    return 0xFFFFFFFFLL;
  }
  uint64_t v7 = *(void **)(a1 + 304);
  if (v7)
  {
    uint64_t v8 = *(void *)(a1 + 304);
    do
    {
      uint64_t v9 = v8;
      uint64_t v8 = *(void *)(v8 + 40);
    }
    while (v8);
    *(void *)(v9 + 40) = v6;
  }
  else
  {
    uint64_t v7 = v6;
  }
  *(void *)(a1 + 304) = v7;
  if (dword_10008FA20)
  {
    __uint32_t v13 = ne_log_obj();
    uint64_t result = os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG);
    if (!result) {
      return result;
    }
    sub_100061C50();
  }
  return 0;
}

void *sub_10002C9C0(uint64_t a1)
{
  uint64_t v2 = sub_10003F940(1uLL);
  uint64_t v3 = v2;
  if (v2)
  {
    uint64_t v6 = *(void *)(a1 + 64);
    uint64_t v5 = a1 + 64;
    uint64_t v4 = v6;
    int v7 = *(_DWORD *)(v6 + 104);
    if (v7)
    {
      *(unsigned char *)v2[1] = v7;
      if (dword_10008FA20)
      {
        uint64_t v8 = ne_log_obj();
        if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG)) {
          sub_100061DA0(v5);
        }
      }
    }
    else
    {
      *(unsigned char *)v2[1] = *(_DWORD *)(v4 + 112);
      if (dword_10008FA20)
      {
        uint64_t v10 = ne_log_obj();
        if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG)) {
          sub_100061D20(v5);
        }
      }
    }
  }
  else if (dword_10008FA20)
  {
    uint64_t v9 = ne_log_obj();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR)) {
      sub_100061CEC();
    }
  }
  return v3;
}

uint64_t sub_10002CAB4(uint64_t a1)
{
  uint64_t v1 = *(unsigned __int8 **)(a1 + 304);
  if (!v1) {
    return 0;
  }
  uint64_t v3 = (unsigned __int8 **)(a1 + 304);
  if (dword_10008FA20)
  {
    uint64_t v4 = ne_log_obj();
    BOOL v5 = os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG);
    uint64_t v1 = *v3;
    if (v5)
    {
      uint64_t v8 = sub_10003E074(*v1);
      int v9 = 136315138;
      uint64_t v10 = v8;
      _os_log_debug_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEBUG, "peer transmitted CR: %s\n", (uint8_t *)&v9, 0xCu);
      uint64_t v1 = *v3;
    }
  }
  if (*(_DWORD *)(*(void *)(a1 + 64) + 104) == *v1) {
    return 0;
  }
  if (dword_10008FA20)
  {
    int v7 = ne_log_obj();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR)) {
      sub_100061E20();
    }
  }
  return 0xFFFFFFFFLL;
}

BOOL sub_10002CBD4(int a1)
{
  return (a1 - 65005) < 2 || a1 == 3 || a1 == 64221;
}

size_t *sub_10002CBF8(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 64);
  uint64_t v3 = *(void *)(v2 + 88);
  if (!v3)
  {
    if (*(unsigned char *)(a1 + 81) != 2)
    {
      uint64_t v4 = sub_100027F70(*(void **)(a1 + 320));
      if (v4) {
        return v4;
      }
      if (*(_DWORD *)(*(void *)(a1 + 64) + 136))
      {
        if (dword_10008FA20)
        {
          uint64_t v10 = ne_log_obj();
          if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR)) {
            sub_100061F0C();
          }
        }
        return 0;
      }
    }
LABEL_6:
    if (dword_10008FA20)
    {
      BOOL v5 = ne_log_obj();
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)__uint32_t v13 = 0;
        _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "try to get pskey by the peer's address.\n", v13, 2u);
      }
    }
    int v7 = *(sockaddr **)(a1 + 48);
    uint64_t v6 = (const sockaddr **)(a1 + 48);
    uint64_t v4 = sub_100028330(v7);
    if (!v4 && dword_10008FA20)
    {
      uint64_t v8 = ne_log_obj();
      if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR)) {
        sub_100061E90(v6);
      }
      return 0;
    }
    return v4;
  }
  if (*(_DWORD *)(v2 + 80) == 1)
  {
    uint64_t v4 = sub_100028054(*(const char **)(v3 + 8), *(_DWORD *)v3 - 1);
    if (v4) {
      return v4;
    }
    goto LABEL_6;
  }
  int v9 = sub_10003F940(*(void *)v3 - 1);
  if (!v9)
  {
    if (dword_10008FA20)
    {
      CFArrayRef v11 = ne_log_obj();
      if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR)) {
        sub_10006086C();
      }
    }
    return 0;
  }
  uint64_t v4 = v9;
  memcpy((void *)v9[1], *(const void **)(*(void *)(*(void *)(a1 + 64) + 88) + 8), *v9);
  return v4;
}

uint64_t sub_10002CDA4(uint64_t a1)
{
  uint64_t v2 = a1 + 72;
  int v3 = *(_DWORD *)(*(void *)(a1 + 72) + 48);
  if (*(void *)(*(void *)(a1 + 64) + 272)) {
    BOOL v4 = v3 == 65001;
  }
  else {
    BOOL v4 = 0;
  }
  if (v4) {
    goto LABEL_31;
  }
  if (v3 > 65004)
  {
    if ((v3 - 65007) < 4) {
      goto LABEL_12;
    }
    if ((v3 - 65005) < 2) {
      goto LABEL_18;
    }
    int v7 = 65500;
LABEL_30:
    if (v3 != v7)
    {
LABEL_58:
      if (dword_10008FA20)
      {
        int v32 = ne_log_obj();
        if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR)) {
          sub_100062024();
        }
      }
      return 0xFFFFFFFFLL;
    }
    goto LABEL_31;
  }
  if (v3 <= 64220)
  {
    if ((v3 - 4) >= 2)
    {
      if (v3 != 1)
      {
        if (v3 != 3) {
          goto LABEL_58;
        }
        goto LABEL_18;
      }
LABEL_31:
      uint64_t v16 = sub_10002CBF8(a1);
      if (!v16)
      {
        if (dword_10008FA20)
        {
          unsigned int v29 = ne_log_obj();
          if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR)) {
            sub_100061F40(a1);
          }
        }
        return 0xFFFFFFFFLL;
      }
      uint64_t v21 = (uint64_t)v16;
      if (dword_10008FA20)
      {
        BOOL v22 = ne_log_obj();
        if (os_log_type_enabled(v22, OS_LOG_TYPE_DEBUG)) {
          sub_100061FF0();
        }
      }
      if (dword_10008C2C8 >= 7) {
        sub_100033908(7, *(void *)(v21 + 8), *(void *)v21, "psk: ", v17, v18, v19, v20, v33);
      }
      char v23 = sub_10003F940(**(_DWORD **)(a1 + 184) + **(_DWORD **)(a1 + 176));
      if (!v23)
      {
        if (dword_10008FA20)
        {
          BOOL v30 = ne_log_obj();
          if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR)) {
            sub_100061FBC();
          }
        }
        sub_10003FA78((void *)v21);
        return 0xFFFFFFFFLL;
      }
      int v9 = v23;
      uint64_t v24 = v23[1];
      if (*(_DWORD *)(a1 + 20)) {
        uint64_t v25 = 184;
      }
      else {
        uint64_t v25 = 176;
      }
      uint64_t v26 = *(void *)(a1 + v25);
      memcpy((void *)v23[1], *(const void **)(v26 + 8), *(void *)v26);
      if (*(_DWORD *)(a1 + 20)) {
        uint64_t v27 = 176;
      }
      else {
        uint64_t v27 = 184;
      }
      memcpy((void *)(v24 + *(void *)v26), *(const void **)(*(void *)(a1 + v27) + 8), **(void **)(a1 + v27));
      uint64_t v14 = sub_100029B74(v21, (uint64_t)v9, a1);
      *(void *)(a1 + 192) = v14;
      sub_10003FA78((void *)v21);
      goto LABEL_45;
    }
LABEL_12:
    if (dword_10008FA20)
    {
      BOOL v5 = ne_log_obj();
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v6 = sub_10003EA90(*(_DWORD *)(*(void *)v2 + 48));
        int v33 = 136315138;
        char v34 = v6;
        _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "not supported authentication method %s\n", (uint8_t *)&v33, 0xCu);
      }
    }
    return 0xFFFFFFFFLL;
  }
  if ((v3 - 64221) >= 2)
  {
    int v7 = 65002;
    goto LABEL_30;
  }
LABEL_18:
  uint64_t v8 = sub_10003F940(**(_DWORD **)(a1 + 184) + **(_DWORD **)(a1 + 176));
  if (!v8)
  {
    if (dword_10008FA20)
    {
      uint64_t v15 = ne_log_obj();
      if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR)) {
        sub_10006208C();
      }
    }
    return 0xFFFFFFFFLL;
  }
  int v9 = v8;
  uint64_t v10 = v8[1];
  if (*(_DWORD *)(a1 + 20)) {
    uint64_t v11 = 184;
  }
  else {
    uint64_t v11 = 176;
  }
  uint64_t v12 = *(void *)(a1 + v11);
  memcpy((void *)v8[1], *(const void **)(v12 + 8), *(void *)v12);
  if (*(_DWORD *)(a1 + 20)) {
    uint64_t v13 = 176;
  }
  else {
    uint64_t v13 = 184;
  }
  memcpy((void *)(v10 + *(void *)v12), *(const void **)(*(void *)(a1 + v13) + 8), **(void **)(a1 + v13));
  uint64_t v14 = sub_100029B74((uint64_t)v9, *(void *)(a1 + 168), a1);
  *(void *)(a1 + 192) = v14;
LABEL_45:
  if (v14) {
    uint64_t v28 = 0;
  }
  else {
    uint64_t v28 = 0xFFFFFFFFLL;
  }
  sub_10003FA78(v9);
  return v28;
}

uint64_t sub_10002D164(uint64_t a1)
{
  if (!*(void *)(a1 + 192))
  {
    if (dword_10008FA20)
    {
      uint64_t v18 = ne_log_obj();
      if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR)) {
        sub_1000620C0();
      }
    }
    return 0xFFFFFFFFLL;
  }
  uint64_t v2 = sub_10003F940(**(_DWORD **)(a1 + 168) + 17);
  if (!v2)
  {
    if (!dword_10008FA20) {
      return 0xFFFFFFFFLL;
    }
    uint64_t v19 = ne_log_obj();
    if (!os_log_type_enabled(v19, OS_LOG_TYPE_ERROR)) {
      return 0xFFFFFFFFLL;
    }
    goto LABEL_22;
  }
  int v3 = v2;
  BOOL v4 = (char *)v2[1];
  memcpy(v4, *(const void **)(*(void *)(a1 + 168) + 8), **(void **)(a1 + 168));
  BOOL v5 = &v4[**(void **)(a1 + 168)];
  *(void *)BOOL v5 = *(void *)a1;
  *((void *)v5 + 1) = *(void *)(a1 + 8);
  v5[16] = 0;
  uint64_t v6 = sub_100029B74(*(void *)(a1 + 192), (uint64_t)v3, a1);
  *(void *)(a1 + 200) = v6;
  if (v6)
  {
    sub_10003FA78(v3);
    int v7 = sub_10003F940(**(_DWORD **)(a1 + 168) + **(_DWORD **)(a1 + 200) + 17);
    if (!v7)
    {
      if (!dword_10008FA20) {
        return 0xFFFFFFFFLL;
      }
      uint64_t v20 = ne_log_obj();
      if (!os_log_type_enabled(v20, OS_LOG_TYPE_ERROR)) {
        return 0xFFFFFFFFLL;
      }
      goto LABEL_22;
    }
    int v3 = v7;
    uint64_t v8 = (char *)v7[1];
    memcpy(v8, *(const void **)(*(void *)(a1 + 200) + 8), **(void **)(a1 + 200));
    int v9 = &v8[**(void **)(a1 + 200)];
    memcpy(v9, *(const void **)(*(void *)(a1 + 168) + 8), **(void **)(a1 + 168));
    uint64_t v10 = &v9[**(void **)(a1 + 168)];
    *(void *)uint64_t v10 = *(void *)a1;
    *((void *)v10 + 1) = *(void *)(a1 + 8);
    v10[16] = 1;
    uint64_t v11 = sub_100029B74(*(void *)(a1 + 192), (uint64_t)v3, a1);
    *(void *)(a1 + 208) = v11;
    if (v11)
    {
      sub_10003FA78(v3);
      uint64_t v12 = sub_10003F940(**(_DWORD **)(a1 + 168) + **(_DWORD **)(a1 + 208) + 17);
      if (v12)
      {
        int v3 = v12;
        uint64_t v13 = (char *)v12[1];
        memcpy(v13, *(const void **)(*(void *)(a1 + 208) + 8), **(void **)(a1 + 208));
        uint64_t v14 = &v13[**(void **)(a1 + 208)];
        memcpy(v14, *(const void **)(*(void *)(a1 + 168) + 8), **(void **)(a1 + 168));
        uint64_t v15 = &v14[**(void **)(a1 + 168)];
        *(void *)uint64_t v15 = *(void *)a1;
        *((void *)v15 + 1) = *(void *)(a1 + 8);
        v15[16] = 2;
        uint64_t v16 = sub_100029B74(*(void *)(a1 + 192), (uint64_t)v3, a1);
        *(void *)(a1 + 224) = v16;
        if (v16)
        {
          sub_10003FA78(v3);
          return 0;
        }
        goto LABEL_15;
      }
      if (!dword_10008FA20) {
        return 0xFFFFFFFFLL;
      }
      uint64_t v21 = ne_log_obj();
      if (!os_log_type_enabled(v21, OS_LOG_TYPE_ERROR)) {
        return 0xFFFFFFFFLL;
      }
LABEL_22:
      sub_100061FBC();
      return 0xFFFFFFFFLL;
    }
  }
LABEL_15:
  sub_10003FA78(v3);
  return 0xFFFFFFFFLL;
}

uint64_t sub_10002D410(void *a1)
{
  uint64_t v2 = (uint64_t)(a1 + 9);
  unsigned int v3 = sub_100003274(*(_DWORD *)(a1[9] + 40), *(unsigned int *)(a1[9] + 44));
  if (v3 == -1)
  {
    if (dword_10008FA20)
    {
      char v23 = ne_log_obj();
      if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR)) {
        sub_1000620F4(v2, v23);
      }
    }
    return 0xFFFFFFFFLL;
  }
  BOOL v4 = sub_10003F940(v3 >> 3);
  a1[30] = v4;
  BOOL v5 = (uint64_t **)(a1 + 30);
  if (!v4)
  {
    if (!dword_10008FA20) {
      return 0xFFFFFFFFLL;
    }
    uint64_t v24 = ne_log_obj();
    if (!os_log_type_enabled(v24, OS_LOG_TYPE_ERROR)) {
      return 0xFFFFFFFFLL;
    }
    goto LABEL_27;
  }
  unsigned int v6 = sub_100002FF0(*(_DWORD *)(*(void *)v2 + 52));
  if (v6 == -1)
  {
    if (dword_10008FA20)
    {
      uint64_t v25 = ne_log_obj();
      if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR)) {
        sub_1000621B4();
      }
    }
    return 0xFFFFFFFFLL;
  }
  uint64_t v7 = a1[28];
  uint64_t v8 = a1[30];
  if (*(void *)v8 <= *(void *)v7)
  {
    memcpy(*(void **)(v8 + 8), *(const void **)(v7 + 8), *(void *)v8);
    return 0;
  }
  unsigned int v9 = v6;
  if (dword_10008FA20)
  {
    uint64_t v10 = ne_log_obj();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG)) {
      sub_100062294();
    }
  }
  size_t v11 = v9 >> 3;
  uint64_t v12 = sub_10003F940(v11);
  if (v12)
  {
    uint64_t v13 = (uint64_t)v12;
    uint64_t v14 = **v5;
    if (v14 >= 1)
    {
      uint64_t v15 = (char *)(*v5)[1];
      uint64_t v16 = &v15[v14];
      int v17 = 1;
      while (1)
      {
        if (v15 == (char *)(*v5)[1])
        {
          **(unsigned char **)(v13 + 8) = 0;
          *(void *)uint64_t v13 = 1;
        }
        uint64_t v18 = sub_100029B74(a1[28], v13, (uint64_t)a1);
        if (!v18) {
          break;
        }
        uint64_t v19 = v18;
        if (dword_10008FA20)
        {
          uint64_t v20 = ne_log_obj();
          if (os_log_type_enabled(v20, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)buf = 67109120;
            int v30 = v17;
            _os_log_debug_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEBUG, "compute intermediate encryption key K%d\n", buf, 8u);
          }
        }
        LODWORD(v21) = v16 - v15;
        if (*(void *)v19 < (unint64_t)(v16 - v15)) {
          uint64_t v21 = *(void *)v19;
        }
        uint64_t v22 = (int)v21;
        memcpy(v15, *(const void **)(v19 + 8), (int)v21);
        *(void *)uint64_t v13 = v11;
        if (*(void *)v19 != v11)
        {
          if (dword_10008FA20)
          {
            uint64_t v28 = ne_log_obj();
            if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR)) {
              sub_100062224();
            }
          }
          sub_10003FA78((void *)v19);
          break;
        }
        v15 += v22;
        memcpy(*(void **)(v13 + 8), *(const void **)(v19 + 8), v11);
        sub_10003FA78((void *)v19);
        ++v17;
        if (v15 >= v16) {
          goto LABEL_35;
        }
      }
      sub_10003FA78((void *)v13);
      return 0xFFFFFFFFLL;
    }
LABEL_35:
    sub_10003FA78((void *)v13);
    return 0;
  }
  if (dword_10008FA20)
  {
    uint64_t v26 = ne_log_obj();
    if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR)) {
LABEL_27:
    }
      sub_100062180();
  }
  return 0xFFFFFFFFLL;
}

void *sub_10002D760()
{
  uint64_t v0 = malloc_type_calloc(1uLL, 0x30uLL, 0x1030040C42573BEuLL);
  uint64_t v1 = v0;
  if (v0)
  {
    v0[3] = 0;
    v0[5] = 0;
  }
  else if (dword_10008FA20)
  {
    uint64_t v2 = ne_log_obj();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR)) {
      sub_10006231C();
    }
  }
  return v1;
}

void sub_10002D7E0(void *a1)
{
  if (a1)
  {
    uint64_t v2 = (void *)a1[3];
    if (v2) {
      sub_10003FA78(v2);
    }
    free(a1);
  }
}

uint64_t sub_10002D828(uint64_t a1)
{
  uint64_t v2 = sub_10003F940(**(_DWORD **)(a1 + 160) + **(_DWORD **)(a1 + 152));
  if (!v2)
  {
    if (dword_10008FA20)
    {
      uint64_t v16 = ne_log_obj();
      if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR)) {
        sub_100062350();
      }
    }
    return 0xFFFFFFFFLL;
  }
  unsigned int v3 = v2;
  uint64_t v4 = v2[1];
  if (*(_DWORD *)(a1 + 20)) {
    uint64_t v5 = 160;
  }
  else {
    uint64_t v5 = 152;
  }
  uint64_t v6 = *(void *)(a1 + v5);
  memcpy((void *)v2[1], *(const void **)(v6 + 8), *(void *)v6);
  if (*(_DWORD *)(a1 + 20)) {
    uint64_t v7 = 152;
  }
  else {
    uint64_t v7 = 160;
  }
  memcpy((void *)(v4 + *(void *)v6), *(const void **)(*(void *)(a1 + v7) + 8), **(void **)(a1 + v7));
  uint64_t v8 = (uint64_t *)malloc_type_calloc(1uLL, 0x10uLL, 0x20040A4A59CD2uLL);
  if (!v8)
  {
    if (dword_10008FA20)
    {
      int v17 = ne_log_obj();
      if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR)) {
        sub_100062350();
      }
    }
    sub_10003FA78(v3);
    return 0xFFFFFFFFLL;
  }
  unsigned int v9 = v8;
  uint64_t v10 = sub_100029C00((uint64_t)v3, a1);
  uint64_t *v9 = v10;
  if (!v10)
  {
LABEL_28:
    sub_10003FA78(v3);
    sub_10002DA30(v9);
    return 0xFFFFFFFFLL;
  }
  int v11 = sub_1000032C8(*(_DWORD *)(*(void *)(a1 + 72) + 40));
  uint64_t v12 = *v9;
  *(void *)uint64_t *v9 = v11;
  if (v11 == -1)
  {
    if (dword_10008FA20)
    {
      uint64_t v18 = ne_log_obj();
      if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR)) {
        sub_100062384();
      }
    }
    goto LABEL_28;
  }
  uint64_t v13 = sub_10003FAC0(v12);
  v9[1] = (uint64_t)v13;
  if (!v13)
  {
    if (dword_10008FA20)
    {
      uint64_t v19 = ne_log_obj();
      if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR)) {
        sub_1000623EC();
      }
    }
    goto LABEL_28;
  }
  sub_10003FA78(v3);
  uint64_t v14 = *(void **)(a1 + 328);
  if (v14) {
    sub_10002DA30(v14);
  }
  uint64_t result = 0;
  *(void *)(a1 + 328) = v9;
  return result;
}

void sub_10002DA30(void *a1)
{
  if (a1)
  {
    uint64_t v2 = (void *)*a1;
    if (v2) {
      sub_10003FA78(v2);
    }
    unsigned int v3 = (void *)a1[1];
    if (v3) {
      sub_10003FA78(v3);
    }
    free(a1);
    if (dword_10008FA20)
    {
      uint64_t v4 = ne_log_obj();
      if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG)) {
        sub_10006246C();
      }
    }
  }
}

uint64_t *sub_10002DAA8(uint64_t a1, int a2)
{
  uint64_t v4 = sub_10003F940(***(_DWORD ***)(a1 + 328) + 4);
  if (v4)
  {
    uint64_t v5 = v4;
    uint64_t v6 = (char *)v4[1];
    memcpy(v6, *(const void **)(**(void **)(a1 + 328) + 8), ***(void ***)(a1 + 328));
    *(_DWORD *)&v6[***(void ***)(a1 + 328)] = a2;
    if (dword_10008FA20)
    {
      uint64_t v7 = ne_log_obj();
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG)) {
        sub_1000624A0();
      }
    }
    uint64_t v8 = (uint64_t *)malloc_type_calloc(1uLL, 0x10uLL, 0x20040A4A59CD2uLL);
    if (v8)
    {
      unsigned int v9 = v8;
      uint64_t v10 = sub_100029C00((uint64_t)v5, a1);
      uint64_t *v9 = v10;
      if (v10)
      {
        int v11 = sub_1000032C8(*(_DWORD *)(*(void *)(a1 + 72) + 40));
        uint64_t v12 = *v9;
        *(void *)uint64_t *v9 = v11;
        if (v11 == -1)
        {
          if (dword_10008FA20)
          {
            int v17 = ne_log_obj();
            if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR)) {
              sub_100062384();
            }
          }
        }
        else
        {
          uint64_t v13 = sub_10003FAC0(v12);
          v9[1] = (uint64_t)v13;
          if (v13)
          {
LABEL_24:
            sub_10003FA78(v5);
            return v9;
          }
          if (dword_10008FA20)
          {
            uint64_t v14 = ne_log_obj();
            if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR)) {
              sub_1000623EC();
            }
          }
        }
      }
      sub_10002DA30(v9);
    }
    else if (dword_10008FA20)
    {
      uint64_t v16 = ne_log_obj();
      if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR)) {
        sub_100062350();
      }
    }
    unsigned int v9 = 0;
    goto LABEL_24;
  }
  if (dword_10008FA20)
  {
    uint64_t v15 = ne_log_obj();
    if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR)) {
      sub_100062350();
    }
  }
  return 0;
}

void *sub_10002DC80(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  if (dword_10008FA20)
  {
    uint64_t v8 = ne_log_obj();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG)) {
      sub_100062770();
    }
  }
  int v9 = sub_1000032C8(*(_DWORD *)(*(void *)(a1 + 72) + 40));
  if (v9 == -1)
  {
    if (dword_10008FA20)
    {
      uint64_t v25 = ne_log_obj();
      if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR)) {
        sub_100062384();
      }
    }
    return 0;
  }
  int v10 = v9;
  bzero(*(void **)(a4 + 8), *(void *)a4);
  memcpy(*(void **)(a4 + 8), (const void *)(a2[1] + *a2 - v10), v10);
  if (dword_10008C2C8 >= 7) {
    sub_100033908(7, *(void *)(a4 + 8), *(void *)a4, "IV was saved for next processing:\n", v11, v12, v13, v14, v38);
  }
  uint64_t v15 = a2[1];
  size_t v16 = *(_DWORD *)a2 - 28;
  int v17 = sub_10003F940(v16);
  if (!v17)
  {
    if (dword_10008FA20)
    {
      uint64_t v28 = ne_log_obj();
      if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR)) {
        sub_1000624D4();
      }
    }
    return 0;
  }
  uint64_t v18 = v17;
  memcpy((void *)v17[1], (const void *)(v15 + 28), v16);
  uint64_t v19 = (uint64_t *)sub_10000331C(*(_DWORD *)(*(void *)(a1 + 72) + 40), (uint64_t)v18, *(void *)(a1 + 240), a3);
  uint64_t v20 = v19;
  if (v19 && v19[1] && *v19)
  {
    sub_10003FA78(v18);
    if (dword_10008FA20)
    {
      uint64_t v21 = ne_log_obj();
      if (os_log_type_enabled(v21, OS_LOG_TYPE_DEBUG)) {
        sub_10006273C();
      }
    }
    if (*(_DWORD *)(qword_10008F848 + 264)) {
      unsigned __int8 v22 = *(unsigned char *)(*v20 + v20[1] - 1) + 1;
    }
    else {
      unsigned __int8 v22 = *(unsigned char *)(*v20 + v20[1] - 1);
    }
    if (dword_10008FA20)
    {
      char v23 = ne_log_obj();
      if (os_log_type_enabled(v23, OS_LOG_TYPE_DEBUG)) {
        sub_1000626D0();
      }
    }
    if (*(_DWORD *)(qword_10008F848 + 260))
    {
      if (*v20 < (unint64_t)v22)
      {
        if (dword_10008FA20)
        {
          uint64_t v24 = ne_log_obj();
          if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR)) {
            sub_10006260C(v22, v20, v24);
          }
        }
        goto LABEL_50;
      }
      *v20 -= v22;
      if (dword_10008FA20)
      {
        int v30 = ne_log_obj();
        if (os_log_type_enabled(v30, OS_LOG_TYPE_DEBUG)) {
          sub_10006269C();
        }
      }
    }
    else if (dword_10008FA20)
    {
      unsigned int v29 = ne_log_obj();
      if (os_log_type_enabled(v29, OS_LOG_TYPE_DEBUG)) {
        sub_1000625D8();
      }
    }
    int v31 = sub_10003F940(*(_DWORD *)v20 + 28);
    if (v31)
    {
      uint64_t v27 = v31;
      int v32 = (_OWORD *)v31[1];
      int v33 = (long long *)a2[1];
      long long v34 = *v33;
      *(_OWORD *)((char *)v32 + 12) = *(long long *)((char *)v33 + 12);
      _OWORD *v32 = v34;
      memcpy((void *)(v31[1] + 28), (const void *)v20[1], *v20);
      *(_DWORD *)(v27[1] + 24) = bswap32(*(_DWORD *)v27);
      if (dword_10008FA20)
      {
        unint64_t v35 = ne_log_obj();
        if (os_log_type_enabled(v35, OS_LOG_TYPE_DEBUG)) {
          sub_1000625A4();
        }
      }
      goto LABEL_51;
    }
    if (dword_10008FA20)
    {
      unint64_t v36 = ne_log_obj();
      if (os_log_type_enabled(v36, OS_LOG_TYPE_ERROR)) {
        sub_100062570();
      }
    }
LABEL_50:
    uint64_t v27 = 0;
LABEL_51:
    sub_10003FA78(v20);
    return v27;
  }
  if (dword_10008FA20)
  {
    uint64_t v26 = ne_log_obj();
    if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR)) {
      sub_100062508();
    }
  }
  sub_10003FA78(v18);
  uint64_t v27 = 0;
  if (v20) {
    goto LABEL_51;
  }
  return v27;
}

void *sub_10002E028(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  if (*(unsigned char *)(a1 + 80) == 16)
  {
    return sub_10002DC80(a1, a2, a3, a4);
  }
  else
  {
    if (dword_10008FA20)
    {
      uint64_t v5 = ne_log_obj();
      if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR)) {
        sub_1000627A4();
      }
    }
    return 0;
  }
}

void *sub_10002E0A0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (dword_10008FA20)
  {
    uint64_t v8 = ne_log_obj();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG)) {
      sub_100062910();
    }
  }
  int v9 = sub_1000032C8(*(_DWORD *)(*(void *)(a1 + 72) + 40));
  if (v9 == -1)
  {
    if (dword_10008FA20)
    {
      int v32 = ne_log_obj();
      if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR)) {
        sub_100062384();
      }
    }
    return 0;
  }
  int v10 = v9;
  uint64_t v39 = a3;
  uint64_t v11 = *(void *)(a2 + 8);
  uint64_t v37 = a2;
  int v12 = *(_DWORD *)a2 - 28;
  int v13 = v9 + 28 - *(_DWORD *)a2 + v12 / v9 * v9;
  uint64_t v38 = a4;
  if (*(_DWORD *)(qword_10008F848 + 252)) {
    v13 += v9 + v9 * (sub_100006078() % (*(_DWORD *)(qword_10008F848 + 256) + 1));
  }
  if (dword_10008FA20)
  {
    uint64_t v14 = ne_log_obj();
    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG)) {
      sub_1000628A8();
    }
  }
  uint64_t v15 = sub_10003F940((v13 + v12));
  if (!v15)
  {
    if (dword_10008FA20)
    {
      int v33 = ne_log_obj();
      if (os_log_type_enabled(v33, OS_LOG_TYPE_ERROR)) {
        sub_1000627D8();
      }
    }
    return 0;
  }
  uint64_t v16 = (uint64_t)v15;
  int v17 = (const void *)(v11 + 28);
  if (v13 && *(_DWORD *)(qword_10008F848 + 248))
  {
    uint64_t v18 = (unsigned char *)(v15[1] + v12);
    int v19 = v13;
    do
    {
      *v18++ = sub_100006078();
      --v19;
    }
    while (v19);
  }
  memcpy(*(void **)(v16 + 8), v17, v12);
  *(unsigned char *)(*(void *)(v16 + 8) + (v13 + v12 - 1)) = v13 - (*(_DWORD *)(qword_10008F848 + 264) != 0);
  if (dword_10008C2C8 >= 7) {
    sub_100033908(7, *(void *)(v16 + 8), *(void *)v16, "About to encrypt %d bytes", v20, v21, v22, v23, *(void *)v16);
  }
  uint64_t v24 = sub_10000338C(*(_DWORD *)(*(void *)(a1 + 72) + 40), v16, *(void *)(a1 + 240), v39);
  if (!v24)
  {
    if (dword_10008FA20)
    {
      long long v34 = ne_log_obj();
      if (os_log_type_enabled(v34, OS_LOG_TYPE_ERROR)) {
        sub_10006280C();
      }
    }
    sub_10003FA78((void *)v16);
    return 0;
  }
  uint64_t v25 = v24;
  sub_10003FA78((void *)v16);
  bzero(*(void **)(v38 + 8), *(void *)v38);
  memcpy(*(void **)(v38 + 8), (const void *)(*(void *)(v25 + 8) + *(void *)v25 - v10), v10);
  uint64_t v26 = sub_10003F940(*(_DWORD *)v25 + 28);
  uint64_t v27 = v26;
  if (v26)
  {
    uint64_t v28 = (_OWORD *)v26[1];
    unsigned int v29 = *(long long **)(v37 + 8);
    long long v30 = *v29;
    *(_OWORD *)((char *)v28 + 12) = *(long long *)((char *)v29 + 12);
    *uint64_t v28 = v30;
    memcpy((void *)(v26[1] + 28), *(const void **)(v25 + 8), *(void *)v25);
    *(_DWORD *)(v27[1] + 24) = bswap32(*(_DWORD *)v27);
    if (dword_10008FA20)
    {
      int v31 = ne_log_obj();
      if (os_log_type_enabled(v31, OS_LOG_TYPE_DEBUG)) {
        sub_100062874();
      }
    }
  }
  else if (dword_10008FA20)
  {
    unint64_t v35 = ne_log_obj();
    if (os_log_type_enabled(v35, OS_LOG_TYPE_ERROR)) {
      sub_1000627D8();
    }
  }
  sub_10003FA78((void *)v25);
  return v27;
}

void *sub_10002E41C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (*(unsigned char *)(a1 + 80) == 16)
  {
    return sub_10002E0A0(a1, a2, a3, a4);
  }
  else
  {
    if (dword_10008FA20)
    {
      uint64_t v5 = ne_log_obj();
      if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR)) {
        sub_100062944();
      }
    }
    return 0;
  }
}

void sub_10002E4BC(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_debug_impl(a1, a2, OS_LOG_TYPE_DEBUG, a4, &a9, 8u);
}

void sub_10002E4D8(void *a1, uint64_t a2, os_log_t log, const char *a4, ...)
{
  va_start(va, a4);
  _os_log_error_impl(a1, log, OS_LOG_TYPE_ERROR, a4, (uint8_t *)va, 0x16u);
}

uint64_t sub_10002E4F8(uint64_t a1)
{
  uint64_t v1 = (void *)a1;
  memset(v25, 0, sizeof(v25));
  if (sub_100042570(a1, (uint64_t)v25))
  {
    if (dword_10008FA20)
    {
      uint64_t v2 = ne_log_obj();
      if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR)) {
        sub_100062B08();
      }
    }
    goto LABEL_9;
  }
  if (!sub_100042670((uint64_t)v25))
  {
    uint64_t v1 = *(void **)&v25[0];
    uint64_t v6 = (unsigned __int8 *)(*(void *)&v25[0] + 1);
    uint64_t v7 = (unsigned __int8 *)(*(void *)&v25[0] + 2);
    int v8 = *(unsigned __int8 *)(*(void *)&v25[0] + 2);
    if (*(unsigned char *)(*(void *)&v25[0] + 2))
    {
      if (dword_10008FA20)
      {
        int v9 = *v6;
        int v10 = ne_log_obj();
        uint64_t v11 = v10;
        if (v8 != 2 || v9 != 18)
        {
          if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR)) {
            sub_1000629E0();
          }
          goto LABEL_30;
        }
        if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
        {
          int v12 = sub_10003EEB4(*v6);
          int v13 = strerror(*v7);
          int v21 = 136315394;
          uint64_t v22 = v12;
          __int16 v23 = 2080;
          uint64_t v24 = v13;
          uint64_t v14 = "pfkey %s failed: %s\n";
          uint64_t v15 = v11;
          uint32_t v16 = 22;
LABEL_29:
          _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, v14, (uint8_t *)&v21, v16);
        }
      }
    }
    else
    {
      unint64_t v17 = *v6;
      if (v17 >= 0x1B)
      {
        if (dword_10008FA20)
        {
          uint64_t v18 = ne_log_obj();
          if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR)) {
            sub_100062978();
          }
        }
        goto LABEL_30;
      }
      if (((0x7521CA1uLL >> v17) & 1) == 0)
      {
        uint64_t v4 = (qword_100088F78[v17](v25) >> 31);
        goto LABEL_10;
      }
      if (dword_10008FA20)
      {
        int v19 = ne_log_obj();
        if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v20 = sub_10003EEB4(*v6);
          int v21 = 136315138;
          uint64_t v22 = v20;
          uint64_t v14 = "unsupported PF_KEY message %s\n";
          uint64_t v15 = v19;
          uint32_t v16 = 12;
          goto LABEL_29;
        }
      }
    }
LABEL_30:
    uint64_t v4 = 0xFFFFFFFFLL;
    goto LABEL_10;
  }
  if (dword_10008FA20)
  {
    unsigned int v3 = ne_log_obj();
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR)) {
      sub_100062A90();
    }
  }
LABEL_9:
  uint64_t v4 = 0xFFFFFFFFLL;
  if (v1) {
LABEL_10:
  }
    free(v1);
  return v4;
}

void sub_10002E7B0()
{
  if (xmmword_1000906E0 == 0)
  {
    unint64_t v5 = 0;
    uint64_t v1 = sub_10002E8E0(*(_DWORD *)(qword_10008F848 + 32), &v5);
    if (v1)
    {
      sub_10002E4F8((uint64_t)v1);
    }
    else if ((v5 & 0x8000000000000000) != 0)
    {
      if (dword_10008FA20)
      {
        unsigned int v3 = ne_log_obj();
        if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR)) {
          sub_100062BB4();
        }
      }
    }
    else if (dword_10008FA20)
    {
      uint64_t v2 = ne_log_obj();
      if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)uint64_t v4 = 0;
        _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "recv short message from pfkey\n", v4, 2u);
      }
    }
  }
  else if (dword_10008FA20)
  {
    uint64_t v0 = ne_log_obj();
    if (os_log_type_enabled(v0, OS_LOG_TYPE_DEBUG)) {
      sub_100062B80();
    }
  }
}

void *sub_10002E8E0(int a1, unint64_t *a2)
{
  socklen_t v9 = 4;
  LODWORD(size) = 0;
  if (getsockopt(a1, 0xFFFF, 4128, &size, &v9) < 0 || !size) {
    return 0;
  }
  uint64_t v4 = malloc_type_calloc(1uLL, (int)size, 0xD32FE939uLL);
  if (v4)
  {
    do
    {
      unint64_t v5 = recv(a1, v4, (int)size, 0);
      *a2 = v5;
      if ((v5 & 0x8000000000000000) == 0) {
        goto LABEL_10;
      }
    }
    while (*__error() == 4);
    if (dword_10008FA20)
    {
      uint64_t v6 = ne_log_obj();
      if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR)) {
        sub_100062C34();
      }
    }
    unint64_t v5 = *a2;
    if ((*a2 & 0x8000000000000000) != 0)
    {
LABEL_14:
      free(v4);
      return 0;
    }
LABEL_10:
    if (v5 < 0x10 || v5 != (int)size) {
      goto LABEL_14;
    }
  }
  return v4;
}

void sub_10002E9D8()
{
  if (xmmword_1000906E0 == 0)
  {
    uint64_t v1 = *(void **)(qword_10008F848 + 96);
    if (v1)
    {
      do
      {
        uint64_t v2 = (void *)*v1;
        sub_10002E4F8(v1[2]);
        unsigned int v3 = (void *)*v1;
        uint64_t v4 = (void *)v1[1];
        if (*v1)
        {
          v3[1] = v4;
          uint64_t v4 = (void *)v1[1];
        }
        else
        {
          *(void *)(qword_10008F848 + 104) = v4;
        }
        *uint64_t v4 = v3;
        free(v1);
        uint64_t v1 = v2;
      }
      while (v2);
    }
  }
  else if (dword_10008FA20)
  {
    uint64_t v0 = ne_log_obj();
    if (os_log_type_enabled(v0, OS_LOG_TYPE_DEFAULT))
    {
      v5[0] = 0;
      _os_log_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_DEFAULT, "ignoring (saved) pfkey messages until power-mgmt event is handled.\n", (uint8_t *)v5, 2u);
    }
  }
}

uint64_t sub_10002EAC4(uint64_t a1)
{
  uint64_t v2 = malloc_type_calloc(0x18uLL, 1uLL, 0x54107A01uLL);
  if (!v2) {
    return 0xFFFFFFFFLL;
  }
  unsigned int v3 = v2;
  uint64_t result = 0;
  *unsigned int v3 = 0;
  unint64_t v5 = *(void **)(qword_10008F848 + 104);
  v3[1] = v5;
  v3[2] = a1;
  *unint64_t v5 = v3;
  *(void *)(qword_10008F848 + 104) = v3;
  return result;
}

void **sub_10002EB30(unsigned int a1)
{
  pid_t v2 = getpid();
  unint64_t v16 = 0;
  int v3 = sub_100042448();
  if (v3 < 0)
  {
    if (dword_10008FA20)
    {
      int v12 = ne_log_obj();
      if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR)) {
        sub_100062CB4();
      }
    }
    return 0;
  }
  else
  {
    int v4 = v3;
    if (dword_10008FA20)
    {
      unint64_t v5 = ne_log_obj();
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG)) {
        sub_100062DD8();
      }
    }
    if ((sub_100041C84(v4, a1) & 0x80000000) != 0)
    {
      if (dword_10008FA20)
      {
        int v13 = ne_log_obj();
        if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR)) {
          sub_100062D2C();
        }
      }
      uint64_t v6 = 0;
    }
    else
    {
      uint64_t v6 = 0;
LABEL_7:
      uint64_t v7 = 0;
      while (1)
      {
        do
        {
          while (1)
          {
            if (v7) {
              free(v7);
            }
            int v8 = sub_10002E8E0(v4, &v16);
            uint64_t v7 = v8;
            if (v8) {
              break;
            }
            if ((v16 & 0x8000000000000000) != 0) {
              goto LABEL_30;
            }
          }
          if (*((unsigned char *)v8 + 1) != 10)
          {
            sub_10002EAC4((uint64_t)v8);
            goto LABEL_7;
          }
        }
        while (v8[3] != v2);
        socklen_t v9 = v6 ? (char *)*v6 : 0;
        size_t v10 = 8 * *((unsigned __int16 *)v8 + 2);
        uint64_t v11 = sub_10003F9BC(v6, (size_t)&v9[v10]);
        uint64_t v6 = v11;
        if (!v11) {
          break;
        }
        memcpy(&v9[(void)v11[1]], v7, v10);
        if (!v7[2]) {
          goto LABEL_35;
        }
      }
      if (dword_10008FA20)
      {
        uint64_t v15 = ne_log_obj();
        if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR)) {
          sub_100062DA4();
        }
      }
LABEL_35:
      free(v7);
    }
LABEL_30:
    sub_10004254C(v4);
  }
  return v6;
}

uint64_t sub_10002ED04()
{
  int v0 = sub_100042448();
  *(_DWORD *)(qword_10008F848 + 32) = v0;
  if (v0 < 0)
  {
    if (dword_10008FA20)
    {
      socklen_t v9 = ne_log_obj();
      if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR)) {
        sub_100062E0C();
      }
    }
  }
  else
  {
    uint64_t v1 = 0;
    int v2 = 0;
    int v3 = &off_100089058;
    do
    {
      if (dword_10008FA20)
      {
        int v4 = ne_log_obj();
        if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG)) {
          sub_100062F64(v22, v1, &v23, v4);
        }
      }
      if ((sub_100041758(*(_DWORD *)(qword_10008F848 + 32), *((unsigned __int8 *)v3 - 8)) & 0x80000000) != 0
        || (sub_100041930(*(_DWORD *)(qword_10008F848 + 32)) & 0x80000000) != 0)
      {
        if (dword_10008FA20)
        {
          unint64_t v5 = ne_log_obj();
          if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v6 = *v3;
            uint64_t v7 = ipsec_strerror();
            *(_DWORD *)buf = 136315394;
            int v19 = v6;
            __int16 v20 = 2080;
            int v21 = v7;
            _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "failed to register %s (%s)\n", buf, 0x16u);
          }
        }
        ++v2;
      }
      ++v1;
      v3 += 2;
    }
    while (v1 != 3);
    if (v2 == 3)
    {
      if (dword_10008FA20)
      {
        int v8 = ne_log_obj();
        if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR)) {
          sub_100062E84();
        }
      }
      close(*(_DWORD *)(qword_10008F848 + 32));
    }
    else
    {
      sub_10003552C();
      size_t v10 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_read, *(int *)(qword_10008F848 + 32), 0, (dispatch_queue_t)&_dispatch_main_q);
      *(void *)(qword_10008F848 + 48) = v10;
      if (v10)
      {
        dispatch_source_set_event_handler_f(v10, (dispatch_function_t)sub_10002E7B0);
        int v11 = *(_DWORD *)(qword_10008F848 + 32);
        int v12 = *(NSObject **)(qword_10008F848 + 48);
        handler[0] = _NSConcreteStackBlock;
        handler[1] = 0x40000000;
        handler[2] = sub_10002F030;
        handler[3] = &unk_100089080;
        int v17 = v11;
        dispatch_source_set_cancel_handler(v12, handler);
        dispatch_resume(*(dispatch_object_t *)(qword_10008F848 + 48));
        if ((sub_10004243C(*(_DWORD *)(qword_10008F848 + 32)) & 0x80000000) == 0) {
          return 0;
        }
        if (dword_10008FA20)
        {
          uint64_t v15 = ne_log_obj();
          if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR)) {
            sub_100062EEC();
          }
        }
        dispatch_source_cancel(*(dispatch_source_t *)(qword_10008F848 + 48));
        *(void *)(qword_10008F848 + 48) = 0;
      }
      else if (dword_10008FA20)
      {
        uint64_t v14 = ne_log_obj();
        if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR)) {
          sub_100062EB8();
        }
      }
    }
  }
  return 0xFFFFFFFFLL;
}

uint64_t sub_10002F030(uint64_t a1)
{
  return sub_10004254C(*(_DWORD *)(a1 + 32));
}

void sub_10002F038()
{
  *(void *)(qword_10008F848 + 48) = 0;
}

uint64_t sub_10002F070(int a1)
{
  if ((a1 - 2) < 3) {
    return dword_10006E674[a1 - 2];
  }
  if (dword_10008FA20)
  {
    int v2 = ne_log_obj();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR)) {
      sub_100062FC0();
    }
  }
  return 0xFFFFFFFFLL;
}

uint64_t sub_10002F0E4(uint64_t a1)
{
  uint64_t v1 = a1;
  if (a1 != 2)
  {
    if (a1 == 9)
    {
      return 4;
    }
    else if (a1 != 3)
    {
      if (dword_10008FA20)
      {
        int v2 = ne_log_obj();
        if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR)) {
          sub_100063028();
        }
      }
      return 0xFFFFFFFFLL;
    }
  }
  return v1;
}

uint64_t sub_10002F160(int a1)
{
  uint64_t result = 2;
  switch(a1)
  {
    case 1:
    case 3:
      return result;
    case 2:
    case 4:
      goto LABEL_4;
    default:
      if (a1 != 61443)
      {
        if (a1 == 61444)
        {
LABEL_4:
          uint64_t result = 1;
        }
        else
        {
          if (dword_10008FA20)
          {
            int v3 = ne_log_obj();
            if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR)) {
              sub_100063090();
            }
          }
          uint64_t result = 0xFFFFFFFFLL;
        }
      }
      break;
  }
  return result;
}

uint64_t sub_10002F218(unsigned int a1)
{
  if (a1 < 3) {
    return dword_10006E680[a1];
  }
  if (dword_10008FA20)
  {
    int v2 = ne_log_obj();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR)) {
      sub_100063090();
    }
  }
  return 0xFFFFFFFFLL;
}

uint64_t sub_10002F288(uint64_t a1, int a2, uint64_t a3, uint64_t a4, _DWORD *a5, unsigned int *a6, _DWORD *a7, unsigned int *a8, _DWORD *a9)
{
  int v14 = a3;
  *a9 = 0;
  if (a2 != 2)
  {
    if (a2 == 4)
    {
      int v22 = sub_10002F76C(a3);
      *a5 = v22;
      if (v22 != -1)
      {
        uint64_t result = 0;
        *a6 = 0;
        *a9 = 128;
        *a7 = 0;
        *a8 = 0;
        if (*a5) {
          return result;
        }
        if (dword_10008FA20)
        {
          uint64_t v23 = ne_log_obj();
          if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR)) {
            sub_1000631FC();
          }
        }
      }
    }
    else if (a2 == 3)
    {
      int v15 = sub_10002F514(a3);
      *a5 = v15;
      if (v15 != -1)
      {
        unsigned int v16 = sub_100003434(v14, *a6);
        if (v16 == -1 && dword_10008FA20)
        {
          int v17 = ne_log_obj();
          if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR)) {
            sub_100063160();
          }
          *a6 = -1;
        }
        else
        {
          *a6 = v16;
          if (v16 != -1)
          {
            *a6 = v16 >> 3;
            int v25 = sub_10002F628(a4);
            *a7 = v25;
            if (v25 != -1)
            {
              unsigned int v26 = sub_10002F700(a4);
              *a8 = v26;
              if (v26 != -1)
              {
                *a8 = v26 >> 3;
                if (*a5) {
                  return 0;
                }
                if (dword_10008FA20)
                {
                  uint64_t v27 = ne_log_obj();
                  if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR)) {
                    sub_10006312C();
                  }
                }
              }
            }
          }
        }
      }
    }
    else if (dword_10008FA20)
    {
      uint64_t v24 = ne_log_obj();
      if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR)) {
        sub_1000630F8();
      }
    }
    goto LABEL_27;
  }
  int v18 = sub_10002F628(a4);
  *a7 = v18;
  if (v18 == -1 || (unsigned int v19 = sub_10002F700(a4), *a8 = v19, v19 == -1))
  {
LABEL_27:
    *__error() = 22;
    return 0xFFFFFFFFLL;
  }
  *a8 = v19 >> 3;
  if (v14 == 1 && a4 == 4)
  {
    *a7 = 3;
    *a9 |= 1u;
  }
  uint64_t result = 0;
  *a5 = 0;
  *a6 = 0;
  if (!*a7)
  {
    if (dword_10008FA20)
    {
      int v21 = ne_log_obj();
      if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR)) {
        sub_1000631C8();
      }
    }
    goto LABEL_27;
  }
  return result;
}

uint64_t sub_10002F514(int a1)
{
  int v1 = a1 - 1;
  uint64_t result = 1;
  switch(v1)
  {
    case 0:
    case 1:
    case 8:
      return result;
    case 2:
      uint64_t result = 2;
      break;
    case 4:
    case 7:
    case 9:
      if (dword_10008FA20)
      {
        int v3 = ne_log_obj();
        if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR)) {
          sub_100063298();
        }
      }
      goto LABEL_9;
    case 5:
      uint64_t result = 5;
      break;
    case 6:
      uint64_t result = 4;
      break;
    case 10:
      uint64_t result = 3;
      break;
    case 11:
      uint64_t result = 12;
      break;
    default:
      if (dword_10008FA20)
      {
        int v4 = ne_log_obj();
        if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR)) {
          sub_100063230();
        }
      }
LABEL_9:
      uint64_t result = 0xFFFFFFFFLL;
      break;
  }
  return result;
}

uint64_t sub_10002F628(int a1)
{
  uint64_t result = 1;
  switch(a1)
  {
    case 1:
      return result;
    case 2:
      return 2;
    case 3:
      if (dword_10008FA20)
      {
        int v3 = ne_log_obj();
        if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR)) {
          sub_100063300(v3, v4, v5, v6, v7, v8, v9, v10);
        }
      }
      return 0xFFFFFFFFLL;
    case 4:
      return 0;
    case 5:
      return 6;
    case 6:
      return 7;
    case 7:
      return 8;
    default:
      if (a1 == 252) {
        return result;
      }
      if (a1 == 253) {
        return 2;
      }
      else {
        return 0;
      }
  }
}

uint64_t sub_10002F700(uint64_t result)
{
  if (result)
  {
    uint64_t result = sub_100003510(result);
    if (result == -1)
    {
      if (dword_10008FA20)
      {
        int v1 = ne_log_obj();
        if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR)) {
          sub_100063374();
        }
      }
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

uint64_t sub_10002F76C(uint64_t a1)
{
  uint64_t v1 = a1;
  if ((a1 - 1) >= 3)
  {
    if (dword_10008FA20)
    {
      int v2 = ne_log_obj();
      if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR)) {
        sub_100063230();
      }
    }
    return 0xFFFFFFFFLL;
  }
  return v1;
}

uint64_t sub_10002F7D8(uint64_t a1)
{
  if (dword_10008FA20)
  {
    int v2 = ne_log_obj();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR)) {
      sub_1000633DC(a1);
    }
  }
  uint64_t v3 = *(unsigned int *)(a1 + 64);
  if (v3)
  {
    sub_10003AC14(v3);
    *(_DWORD *)(a1 + 64) = 0;
  }
  if (!*(unsigned char *)(a1 + 60)) {
    sub_10002F854(a1);
  }
  return sub_10004B62C((void *)a1);
}

uint64_t sub_10002F854(uint64_t a1)
{
  int v2 = (char *)malloc_type_calloc(1uLL, 0x10uLL, 0x764284ADuLL);
  if (v2)
  {
    uint64_t v3 = v2;
    *((void *)v2 + 1) = 0;
    *(void *)(v2 + 3) = 0;
    *(_WORD *)int v2 = 1538;
    v2[2] = 2;
    v2[3] = *(unsigned char *)(a1 + 104);
    *((_WORD *)v2 + 2) = 2;
    *((_DWORD *)v2 + 2) = *(_DWORD *)(a1 + 100);
    *((_DWORD *)v2 + 3) = getpid();
    sub_100040DB0(*(_DWORD *)(qword_10008F848 + 32), v3, 0x10u);
    free(v3);
    return 0;
  }
  else
  {
    if (dword_10008FA20)
    {
      uint64_t v5 = ne_log_obj();
      if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR)) {
        sub_100063458();
      }
    }
    return 0xFFFFFFFFLL;
  }
}

uint64_t sub_10002F924(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 60))
  {
    uint64_t v2 = *(void *)(a1 + 128);
    uint64_t v3 = *(void *)(a1 + 112);
    if (!v3 || !*(void *)(v3 + 40)) {
      goto LABEL_9;
    }
LABEL_6:
    uint64_t v4 = (sockaddr **)(a1 + 32);
    if (*(void *)(a1 + 32))
    {
      uint64_t v5 = (sockaddr **)(a1 + 40);
      if (*(void *)(a1 + 40))
      {
        if (sub_10000ED24(v2)) {
          goto LABEL_10;
        }
      }
    }
    goto LABEL_9;
  }
  uint64_t v2 = *(void *)(a1 + 120);
  if (*(_DWORD *)(*(void *)(*(void *)(a1 + 256) + 64) + 160)) {
    goto LABEL_6;
  }
LABEL_9:
  uint64_t v5 = (sockaddr **)(a1 + 8);
  uint64_t v4 = (sockaddr **)a1;
LABEL_10:
  uint64_t v6 = *(void *)(v2 + 32);
  if (!v6) {
    return 0;
  }
  uint64_t v7 = *v5;
  uint64_t v8 = *v4;
  while (1)
  {
    uint64_t v9 = sub_10002F070(*(_DWORD *)v6);
    uint64_t v10 = v9;
    if (v9 != 9) {
      break;
    }
    unsigned int v12 = 0xFFFF;
    unsigned int v11 = 256;
LABEL_16:
    unsigned int v13 = sub_10002F160(*(_DWORD *)(v6 + 16));
    if (v13 == -1)
    {
      if (dword_10008FA20)
      {
        unsigned int v19 = ne_log_obj();
        if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR)) {
          sub_10006348C();
        }
      }
      return 0xFFFFFFFFLL;
    }
    unsigned int v14 = v13;
    if (dword_10008FA20)
    {
      int v15 = ne_log_obj();
      if (os_log_type_enabled(v15, OS_LOG_TYPE_DEBUG)) {
        sub_10006356C(&v23, v24, v15);
      }
    }
    if ((sub_10004093C(*(_DWORD *)(qword_10008F848 + 32), v10, v14, &v7->sa_len, &v8->sa_len, v11, v12, *(_DWORD *)(v6 + 52), 0, v22, 0, 0, *(_DWORD *)(a1 + 100), 0) & 0x80000000) != 0)
    {
      if (dword_10008FA20)
      {
        __int16 v20 = ne_log_obj();
        if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR)) {
          sub_1000634F4();
        }
      }
      return 0xFFFFFFFFLL;
    }
    if (dword_10008FA20)
    {
      unsigned int v16 = ne_log_obj();
      if (os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG))
      {
        int v17 = sub_10002FBD8(v7, v8, v10, 0, v14);
        *(_DWORD *)buf = 136315138;
        unsigned int v26 = v17;
        _os_log_debug_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEBUG, "pfkey GETSPI sent: %s\n", buf, 0xCu);
      }
    }
    uint64_t v6 = *(void *)(v6 + 72);
    if (!v6) {
      return 0;
    }
  }
  if (v9 != -1)
  {
    unsigned int v11 = 0;
    unsigned int v12 = 0;
    goto LABEL_16;
  }
  if (dword_10008FA20)
  {
    int v21 = ne_log_obj();
    if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR)) {
      sub_1000635AC();
    }
  }
  return 0xFFFFFFFFLL;
}

char *sub_10002FBD8(const sockaddr *a1, const sockaddr *a2, uint64_t a3, unsigned int a4, unsigned int a5)
{
  int v9 = sub_10002F0E4(a3);
  if (v9 == -1) {
    return 0;
  }
  int v10 = v9;
  if (a5)
  {
    int v11 = sub_10002F218(a5);
    if (v11 == -1) {
      return 0;
    }
    int v12 = v11;
    unsigned int v13 = sub_10003E344(v10);
    unsigned int v14 = sub_10003E71C(v12);
    int v15 = "/";
  }
  else
  {
    unsigned int v13 = sub_10003E344(v9);
    int v15 = (const char *)&unk_100081F6D;
    unsigned int v14 = (char *)&unk_100081F6D;
  }
  unsigned int v16 = snprintf(byte_10008CC11, 0xFFuLL, "%s%s%s ", v13, v15, v14);
  if (v16 > 0xFE) {
    return 0;
  }
  int v18 = &byte_10008CC11[v16];
  size_t v19 = 255 - v16;
  __int16 v20 = sub_10003CAE4(a1);
  int v21 = snprintf(v18, v19, "%s->", (const char *)v20);
  uint64_t result = 0;
  if ((v21 & 0x80000000) == 0)
  {
    int v22 = v19 - v21;
    if ((int)v19 > v21)
    {
      uint8_t v23 = &v18[v21];
      uint64_t v24 = sub_10003CAE4(a2);
      int v25 = snprintf(v23, v22, "%s ", (const char *)v24);
      uint64_t result = 0;
      if ((v25 & 0x80000000) == 0 && v22 > v25)
      {
        if (a4)
        {
          uint64_t v26 = bswap32(a4);
          snprintf(&v23[v25], v22 - v25, "spi=%lu(0x%lx)", v26, v26);
        }
        return byte_10008CC11;
      }
    }
  }
  return result;
}

uint64_t sub_10002FD58(uint64_t a1)
{
  int v35 = 0;
  int v33 = 0;
  int v31 = 0;
  if (*(void *)(a1 + 128)) {
    BOOL v2 = 1;
  }
  else {
    BOOL v2 = dword_10008FA20 == 0;
  }
  if (!v2)
  {
    uint64_t v3 = ne_log_obj();
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR)) {
      sub_10006375C();
    }
  }
  if (*(unsigned char *)(a1 + 60))
  {
    uint64_t v4 = *(void *)(a1 + 112);
    if (!v4 || !*(void *)(v4 + 40)) {
      goto LABEL_15;
    }
LABEL_12:
    uint64_t v5 = (unsigned __int8 **)(a1 + 32);
    if (*(void *)(a1 + 32))
    {
      uint64_t v6 = (unsigned __int8 **)(a1 + 40);
      if (*(void *)(a1 + 40))
      {
        if (sub_10000ED24(*(void *)(a1 + 128))) {
          goto LABEL_16;
        }
      }
    }
    goto LABEL_15;
  }
  if (*(_DWORD *)(*(void *)(*(void *)(a1 + 256) + 64) + 160)) {
    goto LABEL_12;
  }
LABEL_15:
  uint64_t v6 = (unsigned __int8 **)(a1 + 8);
  uint64_t v5 = (unsigned __int8 **)a1;
LABEL_16:
  uint64_t v7 = *(void *)(*(void *)(a1 + 128) + 32);
  if (!v7) {
    return 0;
  }
  uint64_t v8 = *v6;
  int v9 = *v5;
  char v10 = 4;
  while (1)
  {
    int v11 = sub_10002F070(*(_DWORD *)v7);
    int v12 = v11;
    if (v11 == 9)
    {
      char v10 = 0;
    }
    else if (v11 == -1)
    {
      if (dword_10008FA20)
      {
        unsigned int v29 = ne_log_obj();
        if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR)) {
          sub_1000636F4();
        }
      }
      return 0xFFFFFFFFLL;
    }
    uint64_t v13 = sub_10002F160(*(_DWORD *)(v7 + 16));
    if (v13 == -1) {
      break;
    }
    int v14 = v13;
    int v15 = *(unsigned int **)(v7 + 64);
    uint64_t v16 = v15[1];
    unsigned int v34 = v15[2];
    uint64_t v17 = v15[3];
    unsigned int v32 = 0;
    if ((sub_10002F288(v13, *(_DWORD *)v7, v16, v17, &v35, &v34, &v33, &v32, &v31) & 0x80000000) != 0) {
      return 0xFFFFFFFFLL;
    }
    if (dword_10008FA20)
    {
      int v18 = ne_log_obj();
      if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 67109888;
        int v37 = v35;
        __int16 v38 = 1024;
        unsigned int v39 = v34;
        __int16 v40 = 1024;
        int v41 = v33;
        __int16 v42 = 1024;
        unsigned int v43 = v32;
        _os_log_debug_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEBUG, "call pfkey_send_update: e_type %d, e_klen %d, a_type %d, a_klen %d\n", buf, 0x1Au);
      }
    }
    if (!*(_DWORD *)(v7 + 20))
    {
      __int16 v19 = 0;
      int v21 = v31;
      goto LABEL_41;
    }
    __int16 v19 = sub_10003D80C(*(void *)(*(void *)(a1 + 256) + 48));
    int v20 = v31;
    int v21 = v31 | 2;
    v31 |= 2u;
    uint64_t v22 = *(void *)(a1 + 256);
    uint64_t v23 = *(void *)(v22 + 64);
    if (v14 == 1 && *(_DWORD *)(v23 + 180) == 1 && v9[1] == 2)
    {
      int v21 = v20 | 0xA;
      int v31 = v20 | 0xA;
      if ((*(unsigned char *)(v22 + 96) & 4) == 0) {
        goto LABEL_41;
      }
      int v24 = 4106;
LABEL_36:
      int v21 = v20 | v24;
      goto LABEL_40;
    }
    int v25 = *(_DWORD *)(v22 + 96);
    if ((v25 & 2) == 0)
    {
      if ((v25 & 4) == 0) {
        goto LABEL_41;
      }
      int v24 = 4098;
      goto LABEL_36;
    }
    if (*(_DWORD *)(v23 + 184) != 1) {
      goto LABEL_41;
    }
    int v21 = v20 | 6;
LABEL_40:
    int v31 = v21;
LABEL_41:
    if ((sub_100040DF8(*(_DWORD *)(qword_10008F848 + 32), v12, v14, v8, v9, *(_DWORD *)(v7 + 24), *(_DWORD *)(v7 + 52), v10, *(char **)(*(void *)(v7 + 32) + 8), v35, v34, v33, v32, v21, 0, 0, 0, *(void *)(*(void *)(a1 + 128) + 8), HIDWORD(*(void *)(*(void *)(a1 + 128) + 8)),
            0,
            0,
            *(_DWORD *)(a1 + 100),
            v19,
            v30,
            0) & 0x80000000) != 0)
    {
      if (dword_10008FA20)
      {
        uint64_t v28 = ne_log_obj();
        if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR)) {
          sub_10006367C();
        }
      }
      return 0xFFFFFFFFLL;
    }
    uint64_t v7 = *(void *)(v7 + 72);
    if (!v7) {
      return 0;
    }
  }
  if (dword_10008FA20)
  {
    uint64_t v27 = ne_log_obj();
    if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR)) {
      sub_100063614();
    }
  }
  return 0xFFFFFFFFLL;
}

uint64_t sub_100030134(uint64_t a1)
{
  int v35 = 0;
  int v33 = 0;
  int v31 = 0;
  if (*(void *)(a1 + 128)) {
    BOOL v2 = 1;
  }
  else {
    BOOL v2 = dword_10008FA20 == 0;
  }
  if (!v2)
  {
    uint64_t v3 = ne_log_obj();
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR)) {
      sub_100063808();
    }
  }
  if (*(unsigned char *)(a1 + 60))
  {
    uint64_t v4 = *(void *)(a1 + 112);
    if (!v4 || !*(void *)(v4 + 40)) {
      goto LABEL_15;
    }
LABEL_12:
    uint64_t v5 = (unsigned __int8 **)(a1 + 32);
    if (*(void *)(a1 + 32))
    {
      uint64_t v6 = (unsigned __int8 **)(a1 + 40);
      if (*(void *)(a1 + 40))
      {
        if (sub_10000ED24(*(void *)(a1 + 128))) {
          goto LABEL_16;
        }
      }
    }
    goto LABEL_15;
  }
  if (*(_DWORD *)(*(void *)(*(void *)(a1 + 256) + 64) + 160)) {
    goto LABEL_12;
  }
LABEL_15:
  uint64_t v6 = (unsigned __int8 **)(a1 + 8);
  uint64_t v5 = (unsigned __int8 **)a1;
LABEL_16:
  uint64_t v7 = *(void *)(*(void *)(a1 + 128) + 32);
  if (!v7) {
    return 0;
  }
  uint64_t v8 = *v6;
  int v9 = *v5;
  char v10 = 4;
  while (1)
  {
    int v11 = sub_10002F070(*(_DWORD *)v7);
    int v12 = v11;
    if (v11 == 9)
    {
      char v10 = 0;
    }
    else if (v11 == -1)
    {
      if (dword_10008FA20)
      {
        unsigned int v29 = ne_log_obj();
        if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR)) {
          sub_1000635AC();
        }
      }
      return 0xFFFFFFFFLL;
    }
    uint64_t v13 = sub_10002F160(*(_DWORD *)(v7 + 16));
    if (v13 == -1) {
      break;
    }
    int v14 = v13;
    int v15 = *(unsigned int **)(v7 + 64);
    uint64_t v16 = v15[1];
    unsigned int v34 = v15[2];
    uint64_t v17 = v15[3];
    unsigned int v32 = 0;
    if ((sub_10002F288(v13, *(_DWORD *)v7, v16, v17, &v35, &v34, &v33, &v32, &v31) & 0x80000000) != 0) {
      return 0xFFFFFFFFLL;
    }
    if (dword_10008FA20)
    {
      int v18 = ne_log_obj();
      if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 67109888;
        int v37 = v35;
        __int16 v38 = 1024;
        unsigned int v39 = v34;
        __int16 v40 = 1024;
        int v41 = v33;
        __int16 v42 = 1024;
        unsigned int v43 = v32;
        _os_log_debug_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEBUG, "call pfkey_send_add: e_type %d, e_klen %d, a_type %d, a_klen %d\n", buf, 0x1Au);
      }
    }
    if (!*(_DWORD *)(v7 + 20))
    {
      __int16 v19 = 0;
      int v21 = v31;
      goto LABEL_41;
    }
    __int16 v19 = sub_10003D80C(*(void *)(*(void *)(a1 + 256) + 48));
    int v20 = v31;
    int v21 = v31 | 2;
    v31 |= 2u;
    uint64_t v22 = *(void *)(a1 + 256);
    uint64_t v23 = *(void *)(v22 + 64);
    if (v14 == 1 && *(_DWORD *)(v23 + 180) == 1 && v9[1] == 2)
    {
      int v21 = v20 | 0xA;
      int v31 = v20 | 0xA;
      if ((*(unsigned char *)(v22 + 96) & 4) == 0) {
        goto LABEL_41;
      }
      int v24 = 4106;
LABEL_36:
      int v21 = v20 | v24;
      goto LABEL_40;
    }
    int v25 = *(_DWORD *)(v22 + 96);
    if ((v25 & 2) == 0)
    {
      if ((v25 & 4) == 0) {
        goto LABEL_41;
      }
      int v24 = 4098;
      goto LABEL_36;
    }
    if (*(_DWORD *)(v23 + 184) != 1) {
      goto LABEL_41;
    }
    int v21 = v20 | 6;
LABEL_40:
    int v31 = v21;
LABEL_41:
    if ((sub_100041318(*(_DWORD *)(qword_10008F848 + 32), v12, v14, v9, v8, *(_DWORD *)(v7 + 28), *(_DWORD *)(v7 + 48), v10, *(char **)(*(void *)(v7 + 40) + 8), v35, v34, v33, v32, v21, 0, 0, 0, *(void *)(*(void *)(a1 + 128) + 8), HIDWORD(*(void *)(*(void *)(a1 + 128) + 8)),
            0,
            0,
            *(_DWORD *)(a1 + 100),
            v19,
            v30,
            0) & 0x80000000) != 0)
    {
      if (dword_10008FA20)
      {
        uint64_t v28 = ne_log_obj();
        if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR)) {
          sub_100063790();
        }
      }
      return 0xFFFFFFFFLL;
    }
    uint64_t v7 = *(void *)(v7 + 72);
    if (!v7) {
      return 0;
    }
  }
  if (dword_10008FA20)
  {
    uint64_t v27 = ne_log_obj();
    if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR)) {
      sub_10006348C();
    }
  }
  return 0xFFFFFFFFLL;
}

uint64_t sub_100030510(uint64_t a1)
{
  uint64_t v14 = 0;
  int v13 = 0;
  uint64_t v1 = *(void *)(a1 + 136);
  uint64_t v2 = *(void *)(*(void *)(a1 + 128) + 8);
  if (!sub_100030644(&v14, &v13, 13, (const void **)a1))
  {
    uint64_t v5 = (unsigned __int8 *)(v1 + 8);
    unsigned int v6 = *(unsigned __int8 *)(v1 + 264);
    uint64_t v7 = (unsigned __int8 *)(v1 + 136);
    unsigned int v8 = *(unsigned __int8 *)(v1 + 265);
    __int16 v9 = *(_WORD *)(v1 + 266);
    char v10 = (void *)v14;
    if ((sub_1000421BC(*(_DWORD *)(qword_10008F848 + 32), v5, v6, v7, v8, v9, v2, 0, (void *)v14, v13, 0) & 0x80000000) != 0)
    {
      if (dword_10008FA20)
      {
        int v12 = ne_log_obj();
        if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
        {
          sub_10006383C();
          if (!v10) {
            return 0;
          }
          goto LABEL_14;
        }
      }
    }
    else if (dword_10008FA20)
    {
      int v11 = ne_log_obj();
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
      {
        sub_1000638B4();
        if (!v10) {
          return 0;
        }
        goto LABEL_14;
      }
    }
    if (!v10) {
      return 0;
    }
LABEL_14:
    free(v10);
    return 0;
  }
  if (dword_10008FA20)
  {
    uint64_t v3 = ne_log_obj();
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR)) {
      sub_1000638E8();
    }
  }
  return 0xFFFFFFFFLL;
}

uint64_t sub_100030644(void *a1, int *a2, int a3, const void **a4)
{
  if (a3 == 15 || (uint64_t v8 = *((void *)a4[16] + 4)) == 0)
  {
    int v9 = 16;
  }
  else
  {
    int v9 = 16;
    do
    {
      if (*(_DWORD *)(v8 + 16) == 1) {
        int v10 = *(unsigned __int8 *)*a4 + *(unsigned __int8 *)a4[1] + 8;
      }
      else {
        int v10 = 8;
      }
      v9 += ((v10 - 1) | 7) + 1;
      uint64_t v8 = *(void *)(v8 + 72);
    }
    while (v8);
  }
  int v11 = (unsigned __int8 *)a4[17];
  int v12 = (char *)malloc_type_malloc(v9, 0xA05AC79BuLL);
  if (v12)
  {
    int v13 = v12;
    uint64_t v26 = a2;
    *(_WORD *)int v12 = v9 >> 3;
    *(_DWORD *)(v12 + 2) = 131090;
    v12[6] = *v11;
    *((_DWORD *)v12 + 2) = 0;
    if (a3 == 15 || (uint64_t v14 = *((void *)a4[16] + 4)) == 0)
    {
LABEL_20:
      uint64_t result = 0;
      *a1 = v13;
      *uint64_t v26 = v9;
      return result;
    }
    int v15 = v12 + 24;
    while (1)
    {
      int v16 = sub_10000F01C(*(_DWORD *)v14);
      if (v16 == -1) {
        break;
      }
      __int16 v17 = v16;
      int v18 = sub_10002F160(*(_DWORD *)(v14 + 16));
      if (v18 == -1)
      {
        if (dword_10008FA20)
        {
          int v25 = ne_log_obj();
          if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR)) {
            sub_10006348C();
          }
        }
        goto LABEL_30;
      }
      v13[9] = v17;
      *((unsigned char *)v13 + 20) = v18;
      *((unsigned char *)v13 + 21) = 2;
      v13[11] = 0;
      if (*(_DWORD *)(v14 + 16) == 1)
      {
        size_t v19 = *(unsigned __int8 *)*a4;
        size_t v20 = *(unsigned __int8 *)a4[1];
        __int16 v21 = v19 + v20 + 8;
        memcpy(v13 + 12, *a4, v19);
        memcpy(&v15[v19], a4[1], v20);
      }
      else
      {
        __int16 v21 = 8;
      }
      v13[8] = ((v21 - 1) | 7) + 1;
      uint64_t v14 = *(void *)(v14 + 72);
      if (!v14) {
        goto LABEL_20;
      }
    }
    if (dword_10008FA20)
    {
      int v24 = ne_log_obj();
      if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR)) {
        sub_1000635AC();
      }
    }
LABEL_30:
    free(v13);
  }
  else if (dword_10008FA20)
  {
    uint64_t v23 = ne_log_obj();
    if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR)) {
      sub_10005E14C();
    }
  }
  return 0xFFFFFFFFLL;
}

uint64_t sub_1000308A0(uint64_t a1)
{
  uint64_t v14 = 0;
  int v13 = 0;
  uint64_t v1 = *(void *)(a1 + 136);
  uint64_t v2 = *(void *)(*(void *)(a1 + 128) + 8);
  if (!sub_100030644(&v14, &v13, 14, (const void **)a1))
  {
    uint64_t v5 = (unsigned __int8 *)(v1 + 8);
    unsigned int v6 = *(unsigned __int8 *)(v1 + 264);
    uint64_t v7 = (unsigned __int8 *)(v1 + 136);
    unsigned int v8 = *(unsigned __int8 *)(v1 + 265);
    __int16 v9 = *(_WORD *)(v1 + 266);
    int v10 = (void *)v14;
    if ((sub_1000420EC(*(_DWORD *)(qword_10008F848 + 32), v5, v6, v7, v8, v9, v2, 0, (void *)v14, v13, 0) & 0x80000000) != 0)
    {
      if (dword_10008FA20)
      {
        int v12 = ne_log_obj();
        if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
        {
          sub_10006391C();
          if (!v10) {
            return 0;
          }
          goto LABEL_14;
        }
      }
    }
    else if (dword_10008FA20)
    {
      int v11 = ne_log_obj();
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
      {
        sub_100063994();
        if (!v10) {
          return 0;
        }
        goto LABEL_14;
      }
    }
    if (!v10) {
      return 0;
    }
LABEL_14:
    free(v10);
    return 0;
  }
  if (dword_10008FA20)
  {
    uint64_t v3 = ne_log_obj();
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR)) {
      sub_1000638E8();
    }
  }
  return 0xFFFFFFFFLL;
}

uint64_t sub_1000309D4(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 136);
  unsigned int __src = 0;
  int v12 = 0;
  if (!sub_100030644(&__src, &v12, 15, (const void **)a1))
  {
    uint64_t v4 = (unsigned __int8 *)(v1 + 8);
    unsigned int v5 = *(unsigned __int8 *)(v1 + 264);
    unsigned int v6 = (unsigned __int8 *)(v1 + 136);
    unsigned int v7 = *(unsigned __int8 *)(v1 + 265);
    __int16 v8 = *(_WORD *)(v1 + 266);
    __int16 v9 = __src;
    if ((sub_100042224(*(_DWORD *)(qword_10008F848 + 32), v4, v5, v6, v7, v8, __src, v12, 0) & 0x80000000) != 0)
    {
      if (dword_10008FA20)
      {
        int v11 = ne_log_obj();
        if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
        {
          sub_1000639C8();
          if (!v9) {
            return 0;
          }
          goto LABEL_14;
        }
      }
    }
    else if (dword_10008FA20)
    {
      int v10 = ne_log_obj();
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
      {
        sub_100063A40();
        if (!v9) {
          return 0;
        }
        goto LABEL_14;
      }
    }
    if (!v9) {
      return 0;
    }
LABEL_14:
    free(v9);
    return 0;
  }
  if (dword_10008FA20)
  {
    uint64_t v2 = ne_log_obj();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR)) {
      sub_1000638E8();
    }
  }
  return 0xFFFFFFFFLL;
}

uint64_t sub_100030AFC(uint64_t a1)
{
  int v5 = 0;
  if (a1)
  {
    *(_DWORD *)(a1 + 388) = 0;
    uint64_t v2 = (const void *)(a1 + 400);
    *(_OWORD *)(a1 + 400) = 0u;
    *(_OWORD *)(a1 + 416) = 0u;
    *(_OWORD *)(a1 + 432) = 0u;
    *(_OWORD *)(a1 + 448) = 0u;
    *(_OWORD *)(a1 + 464) = 0u;
    *(_OWORD *)(a1 + 480) = 0u;
    *(_OWORD *)(a1 + 496) = 0u;
    *(_OWORD *)(a1 + 512) = 0u;
    *(_OWORD *)(a1 + 528) = 0u;
    *(_OWORD *)(a1 + 544) = 0u;
    *(_OWORD *)(a1 + 560) = 0u;
    *(_OWORD *)(a1 + 576) = 0u;
    *(_OWORD *)(a1 + 592) = 0u;
    *(_OWORD *)(a1 + 608) = 0u;
    *(_OWORD *)(a1 + 624) = 0u;
    *(_OWORD *)(a1 + 640) = 0u;
    *(_OWORD *)(a1 + 656) = 0u;
    *(_OWORD *)(a1 + 672) = 0u;
    *(_OWORD *)(a1 + 688) = 0u;
    *(_OWORD *)(a1 + 704) = 0u;
    uint64_t result = sub_10004DE24(a1, 1, &v5, a1 + 400, 8);
    *(_DWORD *)(a1 + 388) = result;
    if (!result) {
      return result;
    }
    v6[0] = a1;
    v6[1] = 0;
    if ((sub_1000427D0(*(_DWORD *)(qword_10008F848 + 32), v5, v6, 1u, 1, v2, result) & 0x80000000) == 0) {
      return *(unsigned int *)(a1 + 388);
    }
  }
  else if (dword_10008FA20)
  {
    uint64_t v4 = ne_log_obj();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG)) {
      sub_100063A74(v4);
    }
  }
  return 0xFFFFFFFFLL;
}

uint64_t sub_100030C18(uint64_t a1)
{
  int v5 = 0;
  if (a1)
  {
    *(_DWORD *)(a1 + 1040) = 0;
    uint64_t v2 = (const void *)(a1 + 1048);
    *(_OWORD *)(a1 + 1048) = 0u;
    *(_OWORD *)(a1 + 1064) = 0u;
    *(_OWORD *)(a1 + 1080) = 0u;
    *(_OWORD *)(a1 + 1096) = 0u;
    *(_OWORD *)(a1 + 1112) = 0u;
    *(_OWORD *)(a1 + 1128) = 0u;
    *(_OWORD *)(a1 + 1144) = 0u;
    *(_OWORD *)(a1 + 1160) = 0u;
    *(_OWORD *)(a1 + 1176) = 0u;
    *(_OWORD *)(a1 + 1192) = 0u;
    *(_OWORD *)(a1 + 1208) = 0u;
    *(_OWORD *)(a1 + 1224) = 0u;
    *(_OWORD *)(a1 + 1240) = 0u;
    *(_OWORD *)(a1 + 1256) = 0u;
    *(_OWORD *)(a1 + 1272) = 0u;
    *(_OWORD *)(a1 + 1288) = 0u;
    *(_OWORD *)(a1 + 1304) = 0u;
    *(_OWORD *)(a1 + 1320) = 0u;
    *(_OWORD *)(a1 + 1336) = 0u;
    *(_OWORD *)(a1 + 1352) = 0u;
    uint64_t result = sub_10004DE24(a1, 2, &v5, a1 + 1048, 8);
    *(_DWORD *)(a1 + 1040) = result;
    if (!result) {
      return result;
    }
    v6[0] = a1;
    v6[1] = 0;
    if ((sub_1000427D0(*(_DWORD *)(qword_10008F848 + 32), v5, v6, 1u, 2, v2, result) & 0x80000000) == 0) {
      return *(unsigned int *)(a1 + 1040);
    }
  }
  else if (dword_10008FA20)
  {
    uint64_t v4 = ne_log_obj();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG)) {
      sub_100063AF8(v4);
    }
  }
  return 0xFFFFFFFFLL;
}

uint64_t sub_100030D34(unsigned int a1, int a2, unsigned int a3)
{
  uint64_t v18 = 0;
  int v6 = sub_100003B14(a1);
  switch(v6)
  {
    case 3:
      int v7 = 15;
      break;
    case 4:
      return 0;
    case 5:
      int v7 = 14;
      break;
    default:
      if (dword_10008FA20)
      {
        int v12 = ne_log_obj();
        if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR)) {
          sub_100063B7C();
        }
      }
      return 0xFFFFFFFFLL;
  }
  int v8 = sub_100003B14(a1);
  uint64_t v9 = sub_100003988(a1, a2);
  switch(v8)
  {
    case 3:
      int v10 = sub_10002F514(v9);
      break;
    case 4:
      int v10 = sub_10002F76C(v9);
      break;
    case 5:
      int v10 = sub_10002F628(v9);
      break;
    default:
      if (dword_10008FA20)
      {
        int v15 = ne_log_obj();
        if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR)) {
          sub_100063BB0();
        }
      }
      return 0xFFFFFFFFLL;
  }
  int v13 = v10;
  if (v10 == -1) {
    return 0xFFFFFFFFLL;
  }
  if (!a3)
  {
    if (!sub_100040798(v7, v10, &v18))
    {
      a3 = WORD1(v18);
      goto LABEL_18;
    }
    if (dword_10008FA20)
    {
      int v16 = ne_log_obj();
      if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR)) {
        sub_100063C18();
      }
    }
    return 0xFFFFFFFFLL;
  }
LABEL_18:
  uint64_t v11 = sub_100040638(v7, v13, a3);
  if (v11)
  {
    if (dword_10008FA20)
    {
      uint64_t v14 = ne_log_obj();
      if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR)) {
        sub_100063C18();
      }
    }
  }
  return v11;
}

uint64_t sub_100030F00(void *a1)
{
  uint64_t v1 = a1[5];
  if (!v1 || (v2 = a1[6]) == 0 || (uint64_t v3 = (unsigned __int16 *)a1[18]) == 0)
  {
    if (dword_10008FA20)
    {
      int v5 = ne_log_obj();
      if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR)) {
        sub_100063C90();
      }
    }
    return 0xFFFFFFFFLL;
  }
  if (*v3 <= 1u)
  {
    if (!dword_10008FA20) {
      return 0xFFFFFFFFLL;
    }
    uint64_t v4 = ne_log_obj();
    if (!os_log_type_enabled(v4, OS_LOG_TYPE_ERROR)) {
      return 0xFFFFFFFFLL;
    }
    goto LABEL_7;
  }
  int v7 = (char *)sub_100035140();
  if (!v7)
  {
    if (dword_10008FA20)
    {
      int v13 = ne_log_obj();
      if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR)) {
        sub_100063CF8();
      }
    }
    return 0xFFFFFFFFLL;
  }
  int v8 = v7;
  uint8_t v7[16] = *((unsigned char *)v3 + 6);
  uint64_t v9 = v7 + 16;
  *((_DWORD *)v7 + 72) = *((_DWORD *)v3 + 2);
  unsigned int v10 = v3[2];
  *((_DWORD *)v7 + 73) = v10;
  *((void *)v7 + 37) = 0;
  if (v10 > 5)
  {
    if (dword_10008FA20)
    {
      uint64_t v14 = ne_log_obj();
      if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR)) {
        sub_100063D2C();
      }
    }
    sub_10003515C(v8);
    return 0xFFFFFFFFLL;
  }
  if (v10 == 2)
  {
    unsigned int v15 = *v3;
    if (v15 >= 3)
    {
      int v16 = v7 + 296;
      int v17 = 8 * v15 - 16;
      uint64_t v18 = v3 + 8;
      while (1)
      {
        if (v17 < 8 || (unsigned int v19 = *v18, v17 < v19))
        {
          if (dword_10008FA20)
          {
            unsigned int v32 = ne_log_obj();
            if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR)) {
              sub_100063D60();
            }
          }
          return 0xFFFFFFFFLL;
        }
        if (v19 <= 7) {
          break;
        }
        size_t v20 = sub_10003553C();
        *(void *)int v16 = v20;
        if (!v20)
        {
          if (dword_10008FA20)
          {
            unsigned int v34 = ne_log_obj();
            if (os_log_type_enabled(v34, OS_LOG_TYPE_ERROR)) {
              sub_100063D94();
            }
          }
          return 0xFFFFFFFFLL;
        }
        *size_t v20 = 0;
        int v21 = v18[1];
        if ((v21 - 50) > 0x3A || ((1 << (v21 - 50)) & 0x400000000000003) == 0)
        {
          if (dword_10008FA20)
          {
            unsigned int v39 = ne_log_obj();
            if (os_log_type_enabled(v39, OS_LOG_TYPE_ERROR)) {
              sub_100063DC8();
            }
          }
          return 0xFFFFFFFFLL;
        }
        uint64_t v23 = *(void *)v16;
        *(_WORD *)(*(void *)v16 + 264) = v21;
        int v24 = *((unsigned __int8 *)v18 + 4);
        if ((v24 - 1) >= 2)
        {
          if (dword_10008FA20)
          {
            int v35 = ne_log_obj();
            if (os_log_type_enabled(v35, OS_LOG_TYPE_ERROR)) {
              sub_100063F44();
            }
          }
          return 0xFFFFFFFFLL;
        }
        *(unsigned char *)(v23 + 266) = v24;
        unsigned int v25 = *((unsigned __int8 *)v18 + 5);
        if (v25 >= 3)
        {
          if (v25 != 3)
          {
            if (dword_10008FA20)
            {
              __int16 v40 = ne_log_obj();
              if (os_log_type_enabled(v40, OS_LOG_TYPE_ERROR)) {
                sub_100063E34();
              }
            }
            return 0xFFFFFFFFLL;
          }
          *(_DWORD *)(v23 + 268) = v18[3];
        }
        *(_DWORD *)(v23 + 272) = v25;
        unsigned int v26 = *v18;
        if (v26 >= 9)
        {
          unsigned int v27 = v26 - 8;
          if (v26 - 8 < 0x10
            || (uint64_t v28 = (unsigned __int8 *)(v18 + 4), v29 = *((unsigned __int8 *)v18 + 8), v27 < v29))
          {
            if (dword_10008FA20)
            {
              unint64_t v36 = ne_log_obj();
              if (os_log_type_enabled(v36, OS_LOG_TYPE_ERROR)) {
                sub_100063E9C();
              }
            }
            return 0xFFFFFFFFLL;
          }
          memmove((void *)(v23 + 8), v18 + 4, v29);
          uint64_t v30 = *v28;
          if (v27 - v30 < 0x10 || (size_t v31 = v28[v30], (int)(v27 - v30) < (int)v31))
          {
            if (dword_10008FA20)
            {
              __int16 v38 = ne_log_obj();
              if (os_log_type_enabled(v38, OS_LOG_TYPE_ERROR)) {
                sub_100063ED0();
              }
            }
            return 0xFFFFFFFFLL;
          }
          memmove((void *)(*(void *)v16 + 136), &v28[v30], v31);
          uint64_t v23 = *(void *)v16;
          unsigned int v26 = *v18;
        }
        *(void *)(v23 + 280) = v8;
        v17 -= v26;
        if (v17 < 0 && dword_10008FA20)
        {
          int v37 = ne_log_obj();
          if (os_log_type_enabled(v37, OS_LOG_TYPE_ERROR)) {
            sub_100063F04(&buf, v42, v37);
          }
          goto LABEL_15;
        }
        int v16 = *(char **)v16;
        uint64_t v18 = (unsigned __int16 *)((char *)v18 + *v18);
        if (v17 < 1) {
          goto LABEL_15;
        }
      }
      if (!dword_10008FA20) {
        return 0xFFFFFFFFLL;
      }
      int v33 = ne_log_obj();
      if (!os_log_type_enabled(v33, OS_LOG_TYPE_ERROR)) {
        return 0xFFFFFFFFLL;
      }
LABEL_7:
      sub_100063CC4();
      return 0xFFFFFFFFLL;
    }
  }
LABEL_15:
  v9[15] = 0u;
  v9[16] = 0u;
  v9[13] = 0u;
  v9[14] = 0u;
  v9[11] = 0u;
  v9[12] = 0u;
  v9[9] = 0u;
  v9[10] = 0u;
  v9[7] = 0u;
  v9[8] = 0u;
  v9[5] = 0u;
  v9[6] = 0u;
  v9[3] = 0u;
  v9[4] = 0u;
  v9[1] = 0u;
  v9[2] = 0u;
  _OWORD *v9 = 0u;
  uint8_t v8[16] = *((unsigned char *)v3 + 6);
  unsigned int v12 = *(unsigned __int8 *)(v1 + 8);
  uint64_t v11 = (char *)(v1 + 8);
  v8[280] = *(v11 - 3);
  v8[281] = *(unsigned char *)(v2 + 5);
  *((_WORD *)v8 + 141) = *(v11 - 4);
  memcpy(v8 + 24, v11, v12);
  memcpy(v8 + 152, (const void *)(v2 + 8), *(unsigned __int8 *)(v2 + 8));
  sub_10003548C(v8);
  return 0;
}

uint64_t sub_1000313CC(uint64_t *a1)
{
  uint64_t v1 = a1[1];
  if (!v1 || !a1[6])
  {
    if (dword_10008FA20)
    {
      int v17 = ne_log_obj();
      if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR)) {
        sub_100063FAC();
      }
    }
    return 0xFFFFFFFFLL;
  }
  uint64_t v2 = *a1;
  int v3 = *(_DWORD *)(*a1 + 12);
  if (v3 != getpid())
  {
    if (dword_10008FA20)
    {
      uint64_t v18 = ne_log_obj();
      if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG)) {
        sub_1000642BC();
      }
    }
    return 0xFFFFFFFFLL;
  }
  uint64_t v4 = sub_100007F00(*(_DWORD *)(v2 + 8));
  if (!v4)
  {
    if (dword_10008FA20)
    {
      unsigned int v19 = ne_log_obj();
      if (os_log_type_enabled(v19, OS_LOG_TYPE_DEBUG)) {
        sub_100063FE0(v2 + 8, v2);
      }
    }
    return 0xFFFFFFFFLL;
  }
  uint64_t v5 = v4;
  if ((*(unsigned char *)(v4 + 264) & 2) != 0)
  {
    if (dword_10008FA20)
    {
      size_t v20 = ne_log_obj();
      if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR)) {
        sub_100064250();
      }
    }
    return 0xFFFFFFFFLL;
  }
  int v6 = (unsigned char *)(v4 + 61);
  if (*(unsigned char *)(v4 + 61) != 16)
  {
    if (dword_10008FA20)
    {
      int v21 = ne_log_obj();
      if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR)) {
        sub_1000641E8();
      }
    }
    return 0xFFFFFFFFLL;
  }
  if ((*(_DWORD *)(v4 + 56) | 0x100) != 0x19F0)
  {
    if (dword_10008FA20)
    {
      uint64_t v23 = ne_log_obj();
      if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR)) {
        sub_100064054();
      }
    }
    return 0xFFFFFFFFLL;
  }
  if (!*(void *)(v4 + 256) && !sub_10004C85C(v4))
  {
    if (dword_10008FA20)
    {
      unsigned int v25 = ne_log_obj();
      if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR)) {
        sub_1000640BC(v5);
      }
    }
    goto LABEL_43;
  }
  int v7 = sub_10002F0E4(*(unsigned __int8 *)(v2 + 3));
  uint64_t v8 = 128;
  if (!*(unsigned char *)(v5 + 60)) {
    uint64_t v8 = 120;
  }
  uint64_t v9 = *(void *)(*(void *)(v5 + v8) + 32);
  if (!v9) {
    goto LABEL_40;
  }
  int v10 = v7;
  int v11 = 1;
  int v12 = 1;
  do
  {
    if (*(_DWORD *)v9 == v10 && !*(_DWORD *)(v9 + 24))
    {
      *(_DWORD *)(v9 + 24) = *(_DWORD *)(v1 + 4);
      int v11 = dword_10008FA20;
      if (dword_10008FA20)
      {
        int v13 = ne_log_obj();
        if (os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG))
        {
          uint64_t v28 = *(const sockaddr **)v5;
          size_t v29 = *(const sockaddr **)(v5 + 8);
          uint64_t v14 = *(unsigned __int8 *)(v2 + 3);
          unsigned int v27 = *(_DWORD *)(v1 + 4);
          unsigned int v15 = sub_10002F160(*(_DWORD *)(v9 + 16));
          int v16 = sub_10002FBD8(v29, v28, v14, v27, v15);
          *(_DWORD *)uint8_t buf = 136315138;
          size_t v31 = v16;
          _os_log_debug_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEBUG, "pfkey GETSPI succeeded: %s\n", buf, 0xCu);
        }
        int v11 = 0;
      }
    }
    if (!*(_DWORD *)(v9 + 24)) {
      int v12 = 0;
    }
    uint64_t v9 = *(void *)(v9 + 72);
  }
  while (v9);
  if (v11)
  {
LABEL_40:
    if (dword_10008FA20)
    {
      uint64_t v22 = ne_log_obj();
      if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR)) {
        sub_100064138(v5);
      }
    }
LABEL_43:
    sub_10004B62C((void *)v5);
    return 0xFFFFFFFFLL;
  }
  if (v12 && *v6 == 16 && (sub_100025848(v5) & 0x80000000) != 0)
  {
    if (dword_10008FA20)
    {
      unsigned int v26 = ne_log_obj();
      if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR)) {
        sub_1000641B4();
      }
    }
    goto LABEL_43;
  }
  return 0;
}

uint64_t sub_1000317C8(uint64_t *a1)
{
  if (dword_10008F858) {
    return 0;
  }
  uint64_t v2 = *a1;
  if (!*a1 || (uint64_t v3 = a1[1]) == 0 || !a1[5] || !a1[6])
  {
    if (dword_10008FA20)
    {
      int v6 = ne_log_obj();
      if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR)) {
        sub_100064334();
      }
    }
    return 0xFFFFFFFFLL;
  }
  uint64_t v4 = a1[19];
  if (v4) {
    unsigned int v5 = *(unsigned __int8 *)(v4 + 4);
  }
  else {
    unsigned int v5 = 0;
  }
  int v7 = *(_DWORD *)(v2 + 12);
  if (v7 != getpid())
  {
    if (dword_10008FA20)
    {
      uint64_t v22 = ne_log_obj();
      if (os_log_type_enabled(v22, OS_LOG_TYPE_DEBUG)) {
        sub_1000642BC();
      }
    }
    return 0xFFFFFFFFLL;
  }
  uint64_t v8 = sub_100007F00(*(_DWORD *)(v2 + 8));
  if (!v8)
  {
    if (dword_10008FA20)
    {
      uint64_t v23 = ne_log_obj();
      if (os_log_type_enabled(v23, OS_LOG_TYPE_DEBUG)) {
        sub_100063FE0(v2 + 8, v2);
      }
    }
    return 0xFFFFFFFFLL;
  }
  uint64_t v9 = v8;
  if ((*(unsigned char *)(v8 + 264) & 2) != 0)
  {
    if (dword_10008FA20)
    {
      int v24 = ne_log_obj();
      if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR)) {
        sub_100064250();
      }
    }
    return 0xFFFFFFFFLL;
  }
  if ((*(_DWORD *)(v8 + 56) | 0x100) != 0x19C8)
  {
    if (dword_10008FA20)
    {
      unsigned int v25 = ne_log_obj();
      if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR)) {
        sub_100064054();
      }
    }
    return 0xFFFFFFFFLL;
  }
  uint64_t v10 = *(void *)(*(void *)(v8 + 128) + 32);
  if (v10)
  {
    int v11 = 0;
    int v12 = (unsigned __int8 *)(v2 + 3);
    do
    {
      int v13 = sub_10002F0E4(*v12);
      if (v13 == -1)
      {
        if (dword_10008FA20)
        {
          unsigned int v26 = ne_log_obj();
          if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR)) {
            sub_100064368();
          }
        }
        return 0xFFFFFFFFLL;
      }
      int v14 = v13;
      if (sub_10002F218(v5) == -1)
      {
        if (dword_10008FA20)
        {
          unsigned int v27 = ne_log_obj();
          if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR)) {
            sub_1000643D0();
          }
        }
        return 0xFFFFFFFFLL;
      }
      if (*(_DWORD *)v10 == v14 && *(_DWORD *)(v10 + 24) == *(_DWORD *)(v3 + 4))
      {
        *(_DWORD *)(v10 + 56) = 1;
        if (dword_10008FA20)
        {
          unsigned int v15 = ne_log_obj();
          if (os_log_type_enabled(v15, OS_LOG_TYPE_DEBUG))
          {
            size_t v20 = sub_10002FBD8(*(const sockaddr **)(v9 + 8), *(const sockaddr **)v9, *v12, *(_DWORD *)(v3 + 4), v5);
            *(_DWORD *)uint8_t buf = 136315138;
            *(void *)int v35 = v20;
            _os_log_debug_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEBUG, "pfkey UPDATE succeeded: %s\n", buf, 0xCu);
          }
          if (dword_10008FA20)
          {
            int v16 = ne_log_obj();
            if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
            {
              int v17 = *v12;
              unsigned int v18 = bswap32(*(_DWORD *)(v3 + 4));
              *(_DWORD *)uint8_t buf = 67109632;
              *(_DWORD *)int v35 = v17;
              *(_WORD *)&v35[4] = 1024;
              *(_DWORD *)&v35[6] = v18;
              __int16 v36 = 1024;
              unsigned int v37 = v5;
              _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "IPsec-SA established (update): satype=%u spi=%#x mode=%u\n", buf, 0x14u);
            }
            if (dword_10008FA20)
            {
              unsigned int v19 = ne_log_obj();
              if (os_log_type_enabled(v19, OS_LOG_TYPE_DEBUG))
              {
                int v21 = sub_10002FBD8(*(const sockaddr **)(v9 + 8), *(const sockaddr **)v9, *v12, *(_DWORD *)(v3 + 4), v5);
                *(_DWORD *)uint8_t buf = 136315138;
                *(void *)int v35 = v21;
                _os_log_debug_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEBUG, "IPsec-SA established (update): %s\n", buf, 0xCu);
              }
            }
          }
        }
      }
      if (!*(_DWORD *)(v10 + 56)) {
        int v11 = 1;
      }
      uint64_t v10 = *(void *)(v10 + 72);
    }
    while (v10);
    if (v11) {
      return 0;
    }
  }
  uint64_t v28 = *(unsigned int *)(v9 + 64);
  if (v28)
  {
    sub_10003AC14(v28);
    *(_DWORD *)(v9 + 64) = 0;
  }
  sub_100002728((int *)(v9 + 56), 10240);
  sub_10004CE94(v9);
  if (dword_10008FA20)
  {
    size_t v29 = ne_log_obj();
    if (os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
    {
      if (*(unsigned char *)(v9 + 60)) {
        uint64_t v30 = "peer";
      }
      else {
        uint64_t v30 = "me";
      }
      *(_DWORD *)uint8_t buf = 136315138;
      *(void *)int v35 = v30;
      _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEFAULT, "IPSec Phase 2 established (Initiated by %s).\n", buf, 0xCu);
    }
  }
  uint64_t v31 = *(void *)(v9 + 256);
  if (v31) {
    ++*(_DWORD *)(v31 + 400);
  }
  uint64_t v32 = *(unsigned int *)(v9 + 68);
  if (v32)
  {
    sub_10003AC14(v32);
    *(_DWORD *)(v9 + 68) = 0;
  }
  sub_10004C620((void *)v9);
  *(_DWORD *)(v9 + 64) = sub_10003AA24(*(void *)(*(void *)(v9 + 128) + 8), (uint64_t)sub_100024ECC, v9);
  if (!dword_10008FA20) {
    return 0;
  }
  int v33 = ne_log_obj();
  uint64_t result = os_log_type_enabled(v33, OS_LOG_TYPE_DEBUG);
  if (result)
  {
    sub_10005EEB4();
    return 0;
  }
  return result;
}

uint64_t sub_100031D0C(uint64_t *a1)
{
  if (dword_10008F858) {
    return 0;
  }
  uint64_t v2 = *a1;
  if (!*a1 || (uint64_t v3 = a1[1]) == 0 || !a1[5] || !a1[6])
  {
    if (dword_10008FA20)
    {
      int v6 = ne_log_obj();
      if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR)) {
        sub_100064438();
      }
    }
    return 0xFFFFFFFFLL;
  }
  uint64_t v4 = a1[19];
  if (v4) {
    unsigned int v5 = *(unsigned __int8 *)(v4 + 4);
  }
  else {
    unsigned int v5 = 0;
  }
  int v7 = *(_DWORD *)(v2 + 12);
  if (v7 != getpid())
  {
    if (dword_10008FA20)
    {
      unsigned int v15 = ne_log_obj();
      if (os_log_type_enabled(v15, OS_LOG_TYPE_DEBUG)) {
        sub_1000642BC();
      }
    }
    return 0xFFFFFFFFLL;
  }
  uint64_t v8 = sub_100007F00(*(_DWORD *)(v2 + 8));
  if (!v8)
  {
    if (dword_10008FA20)
    {
      int v16 = ne_log_obj();
      if (os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG)) {
        sub_10006446C(v2 + 8, v2);
      }
    }
    return 0xFFFFFFFFLL;
  }
  uint64_t v9 = v8;
  if (dword_10008FA20)
  {
    uint64_t v10 = ne_log_obj();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      int v11 = *(unsigned __int8 *)(v2 + 3);
      unsigned int v12 = bswap32(*(_DWORD *)(v3 + 4));
      int v18 = 67109632;
      *(_DWORD *)unsigned int v19 = v11;
      *(_WORD *)&v19[4] = 1024;
      *(_DWORD *)&v19[6] = v12;
      __int16 v20 = 1024;
      unsigned int v21 = v5;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "IPsec-SA established (add): satype=%u spi=%#x mode=%u\n", (uint8_t *)&v18, 0x14u);
    }
    if (dword_10008FA20)
    {
      int v13 = ne_log_obj();
      if (os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG))
      {
        int v17 = sub_10002FBD8(*(const sockaddr **)v9, *(const sockaddr **)(v9 + 8), *(unsigned __int8 *)(v2 + 3), *(_DWORD *)(v3 + 4), v5);
        int v18 = 136315138;
        *(void *)unsigned int v19 = v17;
        _os_log_debug_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEBUG, "IPsec-SA established (add): %s\n", (uint8_t *)&v18, 0xCu);
      }
    }
  }
  sub_10004D720(*(void *)(v9 + 272), v9);
  sub_1000496DC(0, 0, 0, v9);
  if (!dword_10008FA20) {
    return 0;
  }
  int v14 = ne_log_obj();
  uint64_t result = os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG);
  if (result)
  {
    sub_10005EEB4();
    return 0;
  }
  return result;
}

uint64_t sub_100031FA0(uint64_t *a1)
{
  if (dword_10008F858) {
    return 0;
  }
  uint64_t v2 = *a1;
  if (!*a1 || (v3 = a1[5]) == 0 || (uint64_t v4 = a1[6]) == 0)
  {
    if (dword_10008FA20)
    {
      uint64_t v8 = ne_log_obj();
      if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR)) {
        sub_1000644E0();
      }
    }
    return 0xFFFFFFFFLL;
  }
  uint64_t v5 = a1[1];
  int v6 = *(_DWORD *)(v2 + 12);
  if (v6 == getpid())
  {
    if (dword_10008FA20)
    {
      int v7 = ne_log_obj();
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG)) {
        sub_100064514(v2);
      }
    }
    return 0xFFFFFFFFLL;
  }
  unsigned int v10 = *(unsigned __int8 *)(v2 + 3);
  uint64_t v9 = (unsigned __int8 *)(v2 + 3);
  int v11 = sub_10002F0E4(v10);
  if (v11 == -1)
  {
    if (dword_10008FA20)
    {
      int v24 = ne_log_obj();
      if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR)) {
        sub_100064368();
      }
    }
    return 0xFFFFFFFFLL;
  }
  int v12 = v11;
  int v13 = (const sockaddr *)(v3 + 8);
  int v14 = (const sockaddr *)(v4 + 8);
  if (!dword_10008FA20) {
    goto LABEL_24;
  }
  unsigned int v15 = ne_log_obj();
  if (os_log_type_enabled(v15, OS_LOG_TYPE_DEBUG)) {
    sub_100064678();
  }
  if (!dword_10008FA20) {
    goto LABEL_24;
  }
  int v16 = ne_log_obj();
  if (os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG)) {
    sub_100064600(v13);
  }
  if (!dword_10008FA20 || (int v17 = ne_log_obj(), !os_log_type_enabled(v17, OS_LOG_TYPE_DEBUG)))
  {
LABEL_24:
    if (v5) {
      goto LABEL_25;
    }
LABEL_37:
    sub_100008820((uint64_t)v13, (unint64_t)v14, v12);
    sub_1000089A8((uint64_t)v13, (unint64_t)v14);
    return 0;
  }
  sub_100064588(v14);
  if (!v5) {
    goto LABEL_37;
  }
LABEL_25:
  int v18 = (const sockaddr **)sub_1000080D0((uint64_t)v13, (uint64_t)v14, v12, *(_DWORD *)(v5 + 4));
  if (v18)
  {
    if (dword_10008FA20)
    {
      unsigned int v19 = v18;
      __int16 v20 = ne_log_obj();
      uint64_t result = os_log_type_enabled(v20, OS_LOG_TYPE_ERROR);
      if (result)
      {
        unsigned int v21 = sub_10002FBD8(*v19, v19[1], *v9, *(_DWORD *)(v5 + 4), 0);
        int v27 = 136315138;
        uint64_t v28 = v21;
        uint64_t v22 = "pfkey DELETE received: %s\n";
        uint64_t v23 = v20;
LABEL_35:
        _os_log_error_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_ERROR, v22, (uint8_t *)&v27, 0xCu);
        return 0;
      }
      return result;
    }
    return 0;
  }
  if (!dword_10008FA20) {
    return 0;
  }
  unsigned int v25 = ne_log_obj();
  uint64_t result = os_log_type_enabled(v25, OS_LOG_TYPE_ERROR);
  if (result)
  {
    unsigned int v26 = sub_10002FBD8(v13, v14, *v9, *(_DWORD *)(v5 + 4), 0);
    int v27 = 136315138;
    uint64_t v28 = v26;
    uint64_t v22 = "no iph2 found: %s\n";
    uint64_t v23 = v25;
    goto LABEL_35;
  }
  return result;
}

uint64_t sub_100032288(uint64_t *a1)
{
  if (dword_10008F858) {
    return 0;
  }
  uint64_t v2 = *a1;
  if (!*a1 || (v3 = a1[5]) == 0 || (uint64_t v4 = a1[6]) == 0 || (v5 = a1[18]) == 0)
  {
    if (dword_10008FA20)
    {
      uint64_t v9 = ne_log_obj();
      if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR)) {
        sub_1000646EC();
      }
    }
    return 0xFFFFFFFFLL;
  }
  if (*(_WORD *)(v5 + 4) != 2)
  {
    if (!dword_10008FA20) {
      return 0;
    }
    unsigned int v10 = ne_log_obj();
    uint64_t result = os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG);
    if (result)
    {
      sub_100064C20();
      return 0;
    }
    return result;
  }
  int v6 = (const sockaddr *)(v4 + 8);
  int v7 = *(unsigned __int8 *)(v4 + 9);
  if (v7 == 30)
  {
    if (*(unsigned __int8 *)(v4 + 16) == 255) {
      goto LABEL_11;
    }
  }
  else if (v7 == 2 && (*(_DWORD *)(v4 + 12) & 0xF0) == 0xE0)
  {
LABEL_11:
    if (!dword_10008FA20) {
      return 0;
    }
    uint64_t v8 = ne_log_obj();
    uint64_t result = os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG);
    if (result)
    {
      sub_100064BA8(v6);
      return 0;
    }
    return result;
  }
  int v11 = (const sockaddr *)(v3 + 8);
  uint64_t v12 = qword_10008F848 + 120;
  do
  {
    uint64_t v12 = *(void *)v12;
    if (!v12)
    {
      if (!dword_10008FA20) {
        return 0;
      }
      int v16 = ne_log_obj();
      uint64_t result = os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG);
      if (result)
      {
        sub_100064720(v11);
        return 0;
      }
      return result;
    }
    int v13 = sub_10003CAE4(*(const sockaddr **)(v12 + 8));
    if (dword_10008FA20)
    {
      int v14 = v13;
      unsigned int v15 = ne_log_obj();
      if (os_log_type_enabled(v15, OS_LOG_TYPE_DEBUG))
      {
        LODWORD(buf[0]) = 136315138;
        *(void *)((char *)buf + 4) = v14;
        _os_log_debug_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEBUG, "checking listen addrs: %s", (uint8_t *)buf, 0xCu);
      }
    }
  }
  while (sub_10003B8E4(*(void *)(v12 + 8), (unint64_t)v11));
  int v18 = *(_DWORD *)(v5 + 8);
  int v17 = (int *)(v5 + 8);
  unsigned int v19 = (sockaddr *)v6;
  uint64_t v20 = sub_100007F98((unint64_t)v11, (unint64_t)v6, v18);
  if (v20)
  {
    if ((*(unsigned char *)(v20 + 57) & 0x20) == 0)
    {
      if (dword_10008FA20)
      {
        unsigned int v21 = ne_log_obj();
        if (os_log_type_enabled(v21, OS_LOG_TYPE_DEBUG)) {
          sub_100064B74();
        }
      }
      return 0xFFFFFFFFLL;
    }
    uint64_t v22 = *(void *)(v20 + 272);
  }
  else
  {
    uint64_t v22 = 0;
  }
  uint64_t v23 = sub_10003511C(*v17);
  if (!v23)
  {
    if (dword_10008FA20)
    {
      unsigned int v34 = ne_log_obj();
      if (os_log_type_enabled(v34, OS_LOG_TYPE_ERROR)) {
        sub_100064798();
      }
    }
    return 0xFFFFFFFFLL;
  }
  uint64_t v24 = (uint64_t)v23;
  if (dword_10008FA20)
  {
    unsigned int v25 = ne_log_obj();
    if (os_log_type_enabled(v25, OS_LOG_TYPE_DEBUG)) {
      sub_100064AF8(v24);
    }
  }
  memset(&buf[1], 0, 256);
  buf[0] = 0u;
  LOBYTE(buf[0]) = 1;
  *(_OWORD *)((char *)&buf[7] + 8) = *(_OWORD *)(v24 + 264);
  *(_OWORD *)((char *)&buf[6] + 8) = *(_OWORD *)(v24 + 248);
  *(_OWORD *)((char *)&buf[5] + 8) = *(_OWORD *)(v24 + 232);
  *(_OWORD *)((char *)&buf[3] + 8) = *(_OWORD *)(v24 + 200);
  *(_OWORD *)((char *)&buf[2] + 8) = *(_OWORD *)(v24 + 184);
  *(_OWORD *)((char *)&buf[1] + 8) = *(_OWORD *)(v24 + 168);
  *(_OWORD *)((char *)&buf[4] + 8) = *(_OWORD *)(v24 + 216);
  *(_OWORD *)((char *)buf + 8) = *(_OWORD *)(v24 + 152);
  long long v26 = *(_OWORD *)(v24 + 120);
  long long v27 = *(_OWORD *)(v24 + 104);
  long long v28 = *(_OWORD *)(v24 + 88);
  *(_OWORD *)((char *)&buf[15] + 8) = *(_OWORD *)(v24 + 136);
  *(_OWORD *)((char *)&buf[12] + 8) = v28;
  *(_OWORD *)((char *)&buf[13] + 8) = v27;
  *(_OWORD *)((char *)&buf[14] + 8) = v26;
  long long v29 = *(_OWORD *)(v24 + 24);
  long long v30 = *(_OWORD *)(v24 + 40);
  long long v31 = *(_OWORD *)(v24 + 56);
  *(_OWORD *)((char *)&buf[11] + 8) = *(_OWORD *)(v24 + 72);
  *(_OWORD *)((char *)&buf[10] + 8) = v31;
  *(_OWORD *)((char *)&buf[9] + 8) = v30;
  *(_OWORD *)((char *)&buf[8] + 8) = v29;
  BYTE8(buf[16]) = *(unsigned char *)(v24 + 281);
  BYTE9(buf[16]) = *(unsigned char *)(v24 + 280);
  WORD5(buf[16]) = *(_WORD *)(v24 + 282);
  uint64_t v32 = sub_100034900((unsigned __int8 *)buf);
  if (v32)
  {
    if (dword_10008FA20)
    {
      int v33 = ne_log_obj();
      if (os_log_type_enabled(v33, OS_LOG_TYPE_DEBUG)) {
        sub_100064A7C((uint64_t)v32);
      }
    }
  }
  else if (dword_10008FA20)
  {
    int v35 = ne_log_obj();
    if (os_log_type_enabled(v35, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)CFStringRef v57 = 136315138;
      char v58 = sub_100035558((unsigned __int8 *)buf);
      _os_log_impl((void *)&_mh_execute_header, v35, OS_LOG_TYPE_DEFAULT, "No in-bound policy found: %s\n", v57, 0xCu);
    }
  }
  __int16 v36 = sub_1000388FC(v19);
  if (!v36)
  {
    if (dword_10008FA20)
    {
      uint64_t v51 = ne_log_obj();
      if (os_log_type_enabled(v51, OS_LOG_TYPE_ERROR)) {
        sub_100064800(v19);
      }
    }
    return 0xFFFFFFFFLL;
  }
  unsigned int v37 = v36;
  __int16 v38 = sub_100008234(v36[73], 0);
  if (!v38)
  {
    if (dword_10008FA20)
    {
      SecCertificateRef v52 = ne_log_obj();
      if (os_log_type_enabled(v52, OS_LOG_TYPE_ERROR)) {
        sub_100064878();
      }
    }
    return 0xFFFFFFFFLL;
  }
  uint64_t v39 = (uint64_t)v38;
  if (dword_10008FA20)
  {
    __int16 v40 = ne_log_obj();
    if (os_log_type_enabled(v40, OS_LOG_TYPE_DEBUG)) {
      sub_100064A04();
    }
  }
  *(unsigned char *)(v39 + 61) = v37[73];
  *(unsigned char *)(v39 + 60) = 0;
  *(_DWORD *)(v39 + 52) = *v17;
  *(unsigned char *)(v39 + 104) = *(unsigned char *)(v2 + 3);
  *(_DWORD *)(v39 + 100) = *(_DWORD *)(v2 + 8);
  sub_1000490C4((_OWORD *)(v39 + 16));
  int v41 = sub_10003CC74();
  *(void *)uint64_t v39 = v41;
  if (!v41) {
    goto LABEL_99;
  }
  __int16 v42 = sub_10003CC74();
  *(void *)(v39 + 8) = v42;
  if (!v42) {
    goto LABEL_99;
  }
  if (*(unsigned char *)(v39 + 61) == 16) {
    sub_100002728((int *)(v39 + 56), 6336);
  }
  if (dword_10008FA20)
  {
    unsigned int v43 = ne_log_obj();
    if (os_log_type_enabled(v43, OS_LOG_TYPE_DEBUG)) {
      sub_10006498C((unsigned __int8 *)(v24 + 16));
    }
  }
  uint64_t v44 = sub_10001026C(v24 + 24, *(unsigned __int8 *)(v24 + 280), *(unsigned __int16 *)(v24 + 282));
  if (!v44)
  {
    if (dword_10008FA20)
    {
      CFArrayRef v53 = ne_log_obj();
      if (os_log_type_enabled(v53, OS_LOG_TYPE_ERROR)) {
        sub_1000648AC((unsigned __int8 *)(v24 + 16));
      }
    }
    goto LABEL_99;
  }
  uint64_t v45 = v44;
  uint64_t v46 = sub_10001026C(v24 + 152, *(unsigned __int8 *)(v24 + 281), *(unsigned __int16 *)(v24 + 282));
  if (!v46)
  {
    if (dword_10008FA20)
    {
      CFIndex v54 = ne_log_obj();
      if (os_log_type_enabled(v54, OS_LOG_TYPE_ERROR)) {
        sub_1000648AC((unsigned __int8 *)(v24 + 16));
      }
    }
    sub_10003FA78(v45);
    goto LABEL_99;
  }
  CFStringRef v47 = v46;
  *(void *)(v39 + 112) = sub_10003A168((uint64_t)v45, (uint64_t)v46, 0, 0);
  sub_10003FA78(v45);
  sub_10003FA78(v47);
  uint64_t v48 = *(void *)(v39 + 112);
  if (!v48)
  {
    if (dword_10008FA20)
    {
      CFStringRef v55 = ne_log_obj();
      if (os_log_type_enabled(v55, OS_LOG_TYPE_ERROR)) {
        sub_10005D838();
      }
    }
    goto LABEL_99;
  }
  sub_10003A7A8(v48);
  if ((sub_1000379F4(v39, v24, (uint64_t)v32) & 0x80000000) != 0)
  {
    if (dword_10008FA20)
    {
      int v56 = ne_log_obj();
      if (os_log_type_enabled(v56, OS_LOG_TYPE_ERROR)) {
        sub_100064924();
      }
    }
LABEL_99:
    sub_10000843C(v39);
    return 0xFFFFFFFFLL;
  }
  uint64_t v49 = v22;
  if (!v22)
  {
    uint64_t v49 = sub_10004B7EC(*(void *)v39, *(void *)(v39 + 8), 1, 0);
    if (!v49) {
      sub_10003B880();
    }
  }
  if (sub_10004C010(v49, v39)) {
    sub_10003B880();
  }
  if ((sub_100025240(v39) & 0x80000000) != 0)
  {
    if (dword_10008FA20)
    {
      uint64_t v50 = ne_log_obj();
      if (os_log_type_enabled(v50, OS_LOG_TYPE_ERROR)) {
        sub_100064958();
      }
    }
    sub_10004B62C((void *)v39);
    return 0xFFFFFFFFLL;
  }
  return 0;
}

uint64_t sub_1000329E4(uint64_t *a1)
{
  uint64_t v1 = *a1;
  if (!*a1 || (v2 = a1[1]) == 0 || (v3 = a1[5]) == 0 || (uint64_t v4 = a1[6]) == 0 || a1[3] && a1[4])
  {
    if (dword_10008FA20)
    {
      uint64_t v5 = ne_log_obj();
      if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR)) {
        sub_100064C54();
      }
    }
    return 0xFFFFFFFFLL;
  }
  uint64_t v7 = a1[19];
  if (v7) {
    unsigned int v8 = *(unsigned __int8 *)(v7 + 4);
  }
  else {
    unsigned int v8 = 0;
  }
  unsigned int v10 = *(unsigned __int8 *)(v1 + 3);
  uint64_t v9 = (unsigned __int8 *)(v1 + 3);
  int v11 = sub_10002F0E4(v10);
  if (v11 == -1)
  {
    if (dword_10008FA20)
    {
      unsigned int v25 = ne_log_obj();
      if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR)) {
        sub_100064368();
      }
    }
    return 0xFFFFFFFFLL;
  }
  int v12 = v11;
  int v13 = (const sockaddr *)(v3 + 8);
  int v14 = (const sockaddr *)(v4 + 8);
  if (dword_10008FA20)
  {
    unsigned int v15 = ne_log_obj();
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
    {
      int v16 = *v9;
      unsigned int v17 = bswap32(*(_DWORD *)(v2 + 4));
      int v31 = 67109632;
      *(_DWORD *)uint64_t v32 = v16;
      *(_WORD *)&v32[4] = 1024;
      *(_DWORD *)&v32[6] = v17;
      LOWORD(v33[0]) = 1024;
      *(_DWORD *)((char *)v33 + 2) = v8;
      _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "IPsec-SA expired: satype=%u spi=%#x mode=%u\n", (uint8_t *)&v31, 0x14u);
    }
    if (dword_10008FA20)
    {
      int v18 = ne_log_obj();
      if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
      {
        long long v29 = sub_10002FBD8(v13, v14, *v9, *(_DWORD *)(v2 + 4), v8);
        int v31 = 136315138;
        *(void *)uint64_t v32 = v29;
        _os_log_debug_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEBUG, "IPsec-SA expired: %s\n", (uint8_t *)&v31, 0xCu);
      }
    }
  }
  unsigned int v19 = sub_1000080D0((uint64_t)v13, (uint64_t)v14, v12, *(_DWORD *)(v2 + 4));
  if (!v19)
  {
    if (dword_10008FA20)
    {
      long long v26 = ne_log_obj();
      uint64_t result = os_log_type_enabled(v26, OS_LOG_TYPE_DEBUG);
      if (!result) {
        return result;
      }
      long long v27 = sub_10002FBD8(v13, v14, *v9, *(_DWORD *)(v2 + 4), v8);
      int v31 = 136315138;
      *(void *)uint64_t v32 = v27;
      _os_log_debug_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEBUG, "no such a SA found: %s\n", (uint8_t *)&v31, 0xCu);
    }
    return 0;
  }
  uint64_t v20 = (uint64_t)v19;
  if ((v19[33] & 2) == 0 && (*((unsigned char *)v19 + 57) & 0x20) != 0)
  {
    uint64_t v28 = *((unsigned int *)v19 + 16);
    if (v28)
    {
      sub_10003AC14(v28);
      *(_DWORD *)(v20 + 64) = 0;
    }
    sub_100002728((int *)(v20 + 56), 18432);
    if (*(unsigned char *)(v20 + 60)
      || sub_10004CB34(*(void *)(v20 + 272), v20)
      || sub_10004F234(*(void *)(v20 + 272), 2))
    {
      sub_10004B62C((void *)v20);
    }
    else
    {
      sub_1000082F0(v20);
      if ((sub_100025240(v20) & 0x80000000) != 0)
      {
        if (dword_10008FA20)
        {
          long long v30 = ne_log_obj();
          if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR)) {
            sub_100064C88();
          }
        }
        sub_10004B62C((void *)v20);
        return 0xFFFFFFFFLL;
      }
    }
    return 0;
  }
  if (!dword_10008FA20) {
    return 0;
  }
  unsigned int v21 = ne_log_obj();
  BOOL v22 = os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT);
  uint64_t result = 0;
  if (v22)
  {
    int v23 = *(_DWORD *)(v20 + 56);
    if ((*(unsigned char *)(v20 + 264) & 2) != 0) {
      uint64_t v24 = "is dying";
    }
    else {
      uint64_t v24 = "has not been established";
    }
    int v31 = 136315394;
    *(void *)uint64_t v32 = v24;
    *(_WORD *)&v32[8] = 1024;
    v33[0] = v23;
    _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "The expire message is received but the handler %s (status = 0x%x).\n", (uint8_t *)&v31, 0x12u);
    return 0;
  }
  return result;
}

uint64_t sub_100032DAC(void *a1)
{
  if (*a1)
  {
    sub_100008750(0);
    sub_100007DF0(0);
    return 0;
  }
  else
  {
    if (dword_10008FA20)
    {
      uint64_t v2 = ne_log_obj();
      if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR)) {
        sub_100064CBC();
      }
    }
    return 0xFFFFFFFFLL;
  }
}

uint64_t sub_100032E1C(void *a1)
{
  if (*a1 && (v2 = a1[5]) != 0 && (v3 = a1[6]) != 0 && (uint64_t v4 = a1[18]) != 0)
  {
    long long v12 = 0u;
    memset(v11, 0, sizeof(v11));
    LOBYTE(v11[0]) = *(unsigned char *)(v4 + 6);
    uint64_t v5 = v2 + 8;
    BYTE8(v12) = *(unsigned char *)(v5 - 3);
    BYTE9(v12) = *(unsigned char *)(v3 + 5);
    WORD5(v12) = *(unsigned __int8 *)(v5 - 4);
    __memcpy_chk();
    __memcpy_chk();
    int v6 = sub_100034900((unsigned __int8 *)v11);
    if (v6)
    {
      uint64_t v7 = v6;
      sub_100035468(v6);
      sub_10003515C(v7);
    }
    else if (dword_10008FA20)
    {
      unsigned int v10 = ne_log_obj();
      if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR)) {
        sub_100064D24((unsigned __int8 *)v11);
      }
    }
    return ((int)sub_100030F00(a1) >> 31);
  }
  else
  {
    if (dword_10008FA20)
    {
      unsigned int v8 = ne_log_obj();
      if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR)) {
        sub_100064CF0();
      }
    }
    return 0xFFFFFFFFLL;
  }
}

uint64_t sub_100032FA0(void *a1)
{
  if (*a1 && (v2 = a1[5]) != 0 && (v3 = a1[6]) != 0 && (uint64_t v4 = a1[18]) != 0)
  {
    long long v12 = 0u;
    memset(v11, 0, sizeof(v11));
    LOBYTE(v11[0]) = *(unsigned char *)(v4 + 6);
    uint64_t v5 = v2 + 8;
    BYTE8(v12) = *(unsigned char *)(v5 - 3);
    BYTE9(v12) = *(unsigned char *)(v3 + 5);
    WORD5(v12) = *(unsigned __int8 *)(v5 - 4);
    __memcpy_chk();
    __memcpy_chk();
    int v6 = sub_100034900((unsigned __int8 *)v11);
    if (v6)
    {
      uint64_t v7 = v6;
      if (dword_10008FA20)
      {
        unsigned int v8 = ne_log_obj();
        if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR)) {
          sub_100064DD0((unsigned __int8 *)v11);
        }
      }
      sub_100035468(v7);
      sub_10003515C(v7);
    }
    return ((int)sub_100030F00(a1) >> 31);
  }
  else
  {
    if (dword_10008FA20)
    {
      unsigned int v10 = ne_log_obj();
      if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR)) {
        sub_100064D9C();
      }
    }
    return 0xFFFFFFFFLL;
  }
}

uint64_t sub_100033124(void *a1)
{
  if (*a1 && (v1 = a1[5]) != 0 && (v2 = a1[6]) != 0 && (uint64_t v3 = a1[18]) != 0)
  {
    long long v11 = 0u;
    memset(v10, 0, sizeof(v10));
    LOBYTE(v10[0]) = *(unsigned char *)(v3 + 6);
    uint64_t v4 = v1 + 8;
    BYTE8(v11) = *(unsigned char *)(v4 - 3);
    BYTE9(v11) = *(unsigned char *)(v2 + 5);
    WORD5(v11) = *(unsigned __int8 *)(v4 - 4);
    __memcpy_chk();
    __memcpy_chk();
    uint64_t v5 = sub_100034900((unsigned __int8 *)v10);
    if (v5)
    {
      int v6 = v5;
      sub_100009758((void *)*(unsigned int *)(v3 + 8), 1);
      sub_100035468(v6);
      sub_10003515C(v6);
      return 0;
    }
    if (dword_10008FA20)
    {
      uint64_t v9 = ne_log_obj();
      if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR)) {
        sub_10005E0D4((unsigned __int8 *)v10);
      }
    }
  }
  else if (dword_10008FA20)
  {
    unsigned int v8 = ne_log_obj();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR)) {
      sub_100064E48();
    }
  }
  return 0xFFFFFFFFLL;
}

uint64_t sub_1000332A8(void *a1)
{
  if (*a1) {
    return 0;
  }
  if (dword_10008FA20)
  {
    uint64_t v2 = ne_log_obj();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR)) {
      sub_100064E7C();
    }
  }
  return 0xFFFFFFFFLL;
}

uint64_t sub_100033308(void *a1)
{
  if (!*a1)
  {
    if (!dword_10008FA20) {
      return 0xFFFFFFFFLL;
    }
    unsigned int v8 = ne_log_obj();
    if (!os_log_type_enabled(v8, OS_LOG_TYPE_ERROR)) {
      return 0xFFFFFFFFLL;
    }
LABEL_15:
    sub_100064EB0();
    return 0xFFFFFFFFLL;
  }
  uint64_t v2 = a1[5];
  uint64_t v3 = a1[6];
  uint64_t v4 = a1[18];
  if (v2) {
    BOOL v5 = v3 == 0;
  }
  else {
    BOOL v5 = 1;
  }
  if (v5 || v4 == 0)
  {
    if (!dword_10008FA20) {
      return 0xFFFFFFFFLL;
    }
    uint64_t v7 = ne_log_obj();
    if (!os_log_type_enabled(v7, OS_LOG_TYPE_ERROR)) {
      return 0xFFFFFFFFLL;
    }
    goto LABEL_15;
  }
  long long v15 = 0u;
  memset(v14, 0, sizeof(v14));
  LOBYTE(v14[0]) = *(unsigned char *)(v4 + 6);
  uint64_t v10 = v2 + 8;
  BYTE8(v15) = *(unsigned char *)(v10 - 3);
  BYTE9(v15) = *(unsigned char *)(v3 + 5);
  WORD5(v15) = *(unsigned __int8 *)(v10 - 4);
  __memcpy_chk();
  __memcpy_chk();
  long long v11 = sub_100034900((unsigned __int8 *)v14);
  if (v11)
  {
    long long v12 = v11;
    if (dword_10008FA20)
    {
      int v13 = ne_log_obj();
      if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR)) {
        sub_100064DD0((unsigned __int8 *)v14);
      }
    }
    sub_100035468(v12);
    sub_10003515C(v12);
  }
  return ((int)sub_100030F00(a1) >> 31);
}

uint64_t sub_1000334BC(void *a1)
{
  if (*a1)
  {
    sub_100008750(0);
    sub_100007DF0(0);
    sub_1000354B4();
    return 0;
  }
  else
  {
    if (dword_10008FA20)
    {
      uint64_t v2 = ne_log_obj();
      if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR)) {
        sub_100064EE4();
      }
    }
    return 0xFFFFFFFFLL;
  }
}

uint64_t sub_100033530(void *a1)
{
  if (*a1 && (v1 = a1[5]) != 0 && (v2 = a1[6]) != 0 && (uint64_t v3 = a1[18]) != 0)
  {
    long long v11 = 0u;
    memset(v10, 0, sizeof(v10));
    LOBYTE(v10[0]) = *(unsigned char *)(v3 + 6);
    uint64_t v4 = v1 + 8;
    BYTE8(v11) = *(unsigned char *)(v4 - 3);
    BYTE9(v11) = *(unsigned char *)(v2 + 5);
    WORD5(v11) = *(unsigned __int8 *)(v4 - 4);
    __memcpy_chk();
    __memcpy_chk();
    BOOL v5 = sub_100034900((unsigned __int8 *)v10);
    if (v5)
    {
      int v6 = v5;
      sub_100009758((void *)*(unsigned int *)(v3 + 8), 0);
      sub_100035468(v6);
      sub_10003515C(v6);
      return 0;
    }
    if (dword_10008FA20)
    {
      uint64_t v9 = ne_log_obj();
      if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR)) {
        sub_10005E0D4((unsigned __int8 *)v10);
      }
    }
  }
  else if (dword_10008FA20)
  {
    unsigned int v8 = ne_log_obj();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR)) {
      sub_100064F18();
    }
  }
  return 0xFFFFFFFFLL;
}

uint64_t sub_1000336B4(uint64_t *a1)
{
  uint64_t v1 = *a1;
  if (*a1 && (v2 = a1[20]) != 0 && (uint64_t v3 = a1[21]) != 0)
  {
    int v4 = *(_DWORD *)(v1 + 12);
    if (v4 == getpid())
    {
      uint64_t v5 = *(void *)(v2 + 8);
      if (v5)
      {
        unsigned int v6 = *(_DWORD *)(v3 + 12);
        if (v6)
        {
          sub_10004DF1C(v5, *(_DWORD *)(v3 + 4), (void *)(v3 + 16), v6);
          return 0;
        }
        if (dword_10008FA20)
        {
          long long v11 = ne_log_obj();
          if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG)) {
            sub_100064FF4(v1);
          }
        }
      }
      else if (dword_10008FA20)
      {
        uint64_t v10 = ne_log_obj();
        if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG)) {
          sub_100064F80(v1);
        }
      }
    }
    else if (dword_10008FA20)
    {
      uint64_t v9 = ne_log_obj();
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG)) {
        sub_1000642BC();
      }
    }
  }
  else if (dword_10008FA20)
  {
    unsigned int v8 = ne_log_obj();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR)) {
      sub_100064F4C();
    }
  }
  return 0xFFFFFFFFLL;
}

void sub_100033804(void *a1, uint64_t a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_debug_impl(a1, v9, OS_LOG_TYPE_DEBUG, a4, &a9, 0x12u);
}

char *sub_10003383C(uint64_t a1)
{
  int v2 = *(unsigned __int8 *)(a1 + 1);
  return sub_10003EEB4(v2);
}

char *sub_100033854(uint64_t a1, uint64_t a2)
{
  int v3 = *(unsigned __int8 *)(a2 + 1);
  return sub_10003EEB4(v3);
}

void sub_10003387C(__asl_object_s *a1, int a2, const char *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  if ((a2 - 3) <= 4)
  {
    asl_set(a1, "Level", off_1000890A0[a2 - 3]);
    uint64_t v10 = (char *)malloc_type_malloc(0x200uLL, 0x75F7A39CuLL);
    if (v10)
    {
      long long v11 = v10;
      char *v10 = 0;
      vsnprintf(v10, 0x200uLL, a3, &a9);
      free(v11);
    }
  }
}

void sub_100033908(int a1, uint64_t a2, unint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  size_t v13 = (a3 >> 2) + 2 * a3 + (a3 >> 5) + 3;
  int v14 = malloc_type_malloc(v13, 0xDE4BBEF8uLL);
  if (a3)
  {
    uint64_t v15 = 0;
    int v16 = 0;
    while ((v15 & 0x1F) != 0)
    {
      if ((v15 & 3) == 0)
      {
        char v17 = 32;
LABEL_7:
        v14[v16++] = v17;
      }
      snprintf(&v14[v16], v13 - v16, "%02x", *(unsigned __int8 *)(a2 + v15));
      v16 += 2;
      if (a3 == ++v15) {
        goto LABEL_11;
      }
    }
    char v17 = 10;
    goto LABEL_7;
  }
  int v16 = 0;
LABEL_11:
  if (v13 - v16 >= 2) {
    *(_WORD *)&v14[v16] = 10;
  }
  __str[0] = 10;
  vsnprintf(__str, 0x200uLL, a4, &a9);
  if (dword_10008FA20)
  {
    if (a1 <= 2)
    {
      int v18 = ne_log_obj();
      if (os_log_type_enabled(v18, OS_LOG_TYPE_FAULT)) {
        sub_100065068();
      }
      goto LABEL_29;
    }
    if (a1 == 3)
    {
      unsigned int v19 = ne_log_obj();
      if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR)) {
        sub_1000650E0();
      }
      goto LABEL_29;
    }
    if (a1 <= 5)
    {
      uint64_t v20 = ne_log_obj();
      if (!os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_29;
      }
      *(_DWORD *)uint8_t buf = 136315394;
      long long v26 = __str;
      __int16 v27 = 2080;
      uint64_t v28 = v14;
      unsigned int v21 = v20;
      os_log_type_t v22 = OS_LOG_TYPE_DEFAULT;
LABEL_26:
      _os_log_impl((void *)&_mh_execute_header, v21, v22, "%s %s", buf, 0x16u);
      goto LABEL_29;
    }
    int v23 = ne_log_obj();
    uint64_t v24 = v23;
    if (a1 == 6)
    {
      if (!os_log_type_enabled(v23, OS_LOG_TYPE_INFO)) {
        goto LABEL_29;
      }
      *(_DWORD *)uint8_t buf = 136315394;
      long long v26 = __str;
      __int16 v27 = 2080;
      uint64_t v28 = v14;
      unsigned int v21 = v24;
      os_log_type_t v22 = OS_LOG_TYPE_INFO;
      goto LABEL_26;
    }
    if (os_log_type_enabled(v23, OS_LOG_TYPE_DEBUG)) {
      sub_100065158();
    }
  }
LABEL_29:
  free(v14);
}

void sub_100033BAC(uint64_t a1, int a2, int a3, uint64_t a4, uint64_t a5, const char *a6, uint64_t a7, uint64_t a8, char a9)
{
  if (a1)
  {
    uint64_t v15 = malloc_type_calloc(1uLL, 0x58uLL, 0x10F0040C24C227BuLL);
    if (v15)
    {
      int v16 = v15;
      *(_DWORD *)a1 = a3;
      v37[1] = &a9;
      char v17 = (const char **)(a1 + 24);
      *(_DWORD *)(a1 + 32) = vasprintf((char **)(a1 + 24), a6, &a9);
      *(void *)(a1 + 40) = a4;
      *(void *)(a1 + 48) = a5;
      uint64_t v18 = *(void *)(a1 + 56);
      while (v18)
      {
        uint64_t v19 = v18;
        uint64_t v18 = *(void *)(v18 + 72);
        if (!v18)
        {
          *(void *)(v19 + 72) = v16;
          v16[10] = v19 + 72;
          break;
        }
      }
      if (a2 == 2)
      {
        v37[0] = 0;
        uint64_t v20 = *(void *)(a1 + 56);
        if (v20)
        {
          do
          {
            if (*v17)
            {
              unsigned int v21 = v37[0];
              if (v37[0])
              {
                __int16 v36 = *v17;
                v37[0] = 0;
                asprintf(v37, "%s\n\t\t-> %s", v21, v36);
                free(v21);
              }
              else
              {
                asprintf(v37, "%s", *v17);
              }
            }
            uint64_t v20 = *(void *)(v20 + 72);
          }
          while (v20);
          if (v37[0] && dword_10008FA20 != 0)
          {
            if (a3 <= 2)
            {
              int v23 = ne_log_obj();
              if (os_log_type_enabled(v23, OS_LOG_TYPE_FAULT)) {
                sub_1000651D0((uint64_t *)v37, v23);
              }
              return;
            }
            if (a3 == 3)
            {
              uint64_t v24 = ne_log_obj();
              if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR)) {
                sub_10006524C((uint64_t)v37, v24, v25, v26, v27, v28, v29, v30);
              }
              return;
            }
            if (a3 <= 5)
            {
              int v31 = ne_log_obj();
              if (!os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT)) {
                return;
              }
              *(_DWORD *)uint8_t buf = 136315138;
              uint64_t v39 = v37[0];
              uint64_t v32 = v31;
              os_log_type_t v33 = OS_LOG_TYPE_DEFAULT;
LABEL_30:
              _os_log_impl((void *)&_mh_execute_header, v32, v33, "%s", buf, 0xCu);
              return;
            }
            unsigned int v34 = ne_log_obj();
            int v35 = v34;
            if (a3 == 6)
            {
              if (!os_log_type_enabled(v34, OS_LOG_TYPE_INFO)) {
                return;
              }
              *(_DWORD *)uint8_t buf = 136315138;
              uint64_t v39 = v37[0];
              uint64_t v32 = v35;
              os_log_type_t v33 = OS_LOG_TYPE_INFO;
              goto LABEL_30;
            }
            if (os_log_type_enabled(v34, OS_LOG_TYPE_DEBUG)) {
              sub_1000652BC((uint64_t *)v37, v35);
            }
          }
        }
      }
    }
  }
}

void sub_100033E38(const char *a1)
{
  if (a1) {
    uint64_t v2 = a1;
  }
  else {
    uint64_t v2 = "bad file path";
  }
  syslog(5, "%s: about to add racoon log file: %s\n", "plogsetfile", v2);
  if (qword_10008F9F8)
  {
    free((void *)qword_10008F9F8);
    if (dword_10008C2CC != -1)
    {
      asl_remove_log_file((asl_object_t)qword_10008FA18, dword_10008C2CC);
      asl_close_auxiliary_file(dword_10008C2CC);
      dword_10008C2CC = -1;
    }
  }
  int v3 = strdup(a1);
  qword_10008F9F8 = (uint64_t)v3;
  if (!v3)
  {
    if (dword_10008FA20)
    {
      unsigned int v8 = ne_log_obj();
      if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR)) {
        sub_100065338(v8);
      }
    }
    exit(1);
  }
  int v4 = open(v3, 777, 420);
  dword_10008C2CC = v4;
  if (v4 < 0)
  {
    uint64_t v7 = __error();
    syslog(5, "%s: failed to add racoon log file: %s. error %d\n", "plogsetfile", v2, *v7);
  }
  else
  {
    int v5 = v4;
    unsigned int v6 = (__asl_object_s *)qword_10008FA18;
    asl_add_log_file(v6, v5);
  }
}

void sub_100033F80(char *__s2)
{
  uint64_t v1 = (void *)qword_10008F9F8;
  if (!((unint64_t)__s2 | qword_10008F9F8)) {
    return;
  }
  if (!__s2 || !qword_10008F9F8)
  {
LABEL_7:
    if (!v1) {
      goto LABEL_9;
    }
    goto LABEL_8;
  }
  if (!strcmp((const char *)qword_10008F9F8, __s2)) {
    return;
  }
  if (dword_10008C2CC != -1)
  {
    asl_remove_log_file((asl_object_t)qword_10008FA18, dword_10008C2CC);
    close(dword_10008C2CC);
    dword_10008C2CC = -1;
    uint64_t v1 = (void *)qword_10008F9F8;
    goto LABEL_7;
  }
LABEL_8:
  free(v1);
  qword_10008F9F8 = 0;
LABEL_9:
  if (__s2)
  {
    sub_100033E38(__s2);
  }
}

uint64_t sub_100034038()
{
  return dword_10008C2C8;
}

uint64_t sub_100034044(int a1)
{
  if ((a1 - 1) >= 7)
  {
    unsigned int v1 = dword_10008C2C8;
  }
  else
  {
    dword_10008C2C8 = a1;
    unsigned int v1 = a1;
  }
  int v2 = ~(-1 << (v1 + 1)) | ((v1 > 5) << 8);
  syslog(7, "%s: about to set racoon's log level %d, mask %x\n", "plogsetlevel", a1, v2);

  return asl_set_filter(0, v2);
}

uint64_t sub_1000340E0(uint64_t result)
{
  if (!result) {
    return result;
  }
  unsigned int v1 = (const char *)result;
  int v2 = strncmp((const char *)result, "Emergency", 9uLL);
  if (!v2) {
    goto LABEL_21;
  }
  if (!strncmp(v1, "Alert", 5uLL))
  {
    dword_10008C2C8 = 1;
    syslog(7, "%s: about to set racoon's log level %d, mask %x\n", "plogsetlevel", 1, 3);
    int v3 = 3;
  }
  else if (!strncmp(v1, "Critical", 8uLL))
  {
    dword_10008C2C8 = 2;
    syslog(7, "%s: about to set racoon's log level %d, mask %x\n", "plogsetlevel", 2, 7);
    int v3 = 7;
  }
  else if (!strncmp(v1, "Error", 5uLL))
  {
    dword_10008C2C8 = 3;
    syslog(7, "%s: about to set racoon's log level %d, mask %x\n", "plogsetlevel", 3, 15);
    int v3 = 15;
  }
  else if (!strncmp(v1, "Warning", 6uLL))
  {
    dword_10008C2C8 = 4;
    syslog(7, "%s: about to set racoon's log level %d, mask %x\n", "plogsetlevel", 4, 31);
    int v3 = 31;
  }
  else
  {
    if (strncmp(v1, "Notice", 6uLL))
    {
      if (!strncmp(v1, "Info", 4uLL))
      {
        int v2 = 6;
      }
      else
      {
        uint64_t result = strncmp(v1, "Debug", 5uLL);
        if (result) {
          return result;
        }
        int v2 = 7;
      }
LABEL_21:
      return sub_100034044(v2);
    }
    dword_10008C2C8 = 5;
    syslog(7, "%s: about to set racoon's log level %d, mask %x\n", "plogsetlevel", 5, 63);
    int v3 = 63;
  }

  return asl_set_filter(0, v3);
}

void sub_10003433C(const char *a1)
{
  if (a1)
  {
    int v2 = strlen(a1);
    if (v2 >= 3 && *a1 == 34 && (uint64_t v3 = (v2 - 1), a1[v3] == 34))
    {
      a1[v3] = 0;
      sub_1000340E0((uint64_t)(a1 + 1));
    }
    else if (dword_10008FA20)
    {
      int v4 = ne_log_obj();
      if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR)) {
        sub_1000653C0();
      }
    }
  }
  else if (dword_10008FA20)
  {
    int v5 = ne_log_obj();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR)) {
      sub_10006537C(v5);
    }
  }
}

void sub_100034408()
{
  int valuePtr = 0;
  buffer[0] = 0;
  SCPreferencesSynchronize((SCPreferencesRef)qword_100090710);
  CFDictionaryRef Value = (const __CFDictionary *)SCPreferencesGetValue((SCPreferencesRef)qword_100090710, @"Global");
  if (Value)
  {
    CFDictionaryRef v1 = Value;
    CFTypeID v2 = CFGetTypeID(Value);
    if (v2 == CFDictionaryGetTypeID())
    {
      CFNumberRef v3 = (const __CFNumber *)CFDictionaryGetValue(v1, @"DebugLevel");
      if (v3 && (CFNumberRef v4 = v3, v5 = CFGetTypeID(v3), v5 == CFNumberGetTypeID()))
      {
        CFNumberGetValue(v4, kCFNumberSInt32Type, &valuePtr);
        sub_100034044(valuePtr);
      }
      else
      {
        CFStringRef v6 = (const __CFString *)CFDictionaryGetValue(v1, @"DebugLevelString");
        if (v6)
        {
          CFStringRef v7 = v6;
          CFTypeID v8 = CFGetTypeID(v6);
          if (v8 == CFStringGetTypeID())
          {
            CFStringGetCString(v7, buffer, 16, 0);
            sub_1000340E0((uint64_t)buffer);
          }
        }
      }
      CFStringRef v9 = (const __CFString *)CFDictionaryGetValue(v1, @"DebugLogfile");
      if (v9)
      {
        CFStringRef v10 = v9;
        CFTypeID v11 = CFGetTypeID(v9);
        if (v11 == CFStringGetTypeID())
        {
          CFStringGetCString(v10, &byte_10008FA24, 1024, 0);
          sub_100033E38(&byte_10008FA24);
        }
      }
    }
  }
}

void sub_100034584()
{
  byte_10008FA24 = 0;
  qword_10008FA18 = 0;
  dword_10008C2C8 = 5;
  syslog(7, "%s: about to set racoon's log level %d, mask %x\n", "plogsetlevel", 5, 63);
  asl_set_filter(0, 63);

  sub_100034408();
}

char *sub_1000345FC(char *__s1, uint64_t a2, const char *a3)
{
  if (qword_10008FA00) {
    free((void *)qword_10008FA00);
  }
  if (__s1)
  {
    CFStringRef v6 = strdup(__s1);
    qword_10008FA00 = (uint64_t)v6;
    if (v6) {
      free(v6);
    }
    if (a2) {
      goto LABEL_7;
    }
  }
  else
  {
    qword_10008FA00 = 0;
    if (a2)
    {
LABEL_7:
      CFStringRef v7 = strdup(__s1);
      goto LABEL_10;
    }
  }
  CFStringRef v7 = 0;
LABEL_10:
  qword_10008FA08 = (uint64_t)v7;
  if (qword_10008FA10) {
    free((void *)qword_10008FA10);
  }
  if (a3) {
    uint64_t result = strdup(a3);
  }
  else {
    uint64_t result = 0;
  }
  qword_10008FA10 = (uint64_t)result;
  return result;
}

char *sub_1000346A0(const __CFAllocator *a1, CFStringRef theString)
{
  CFIndex Length = CFStringGetLength(theString);
  CFIndex v5 = CFStringGetMaximumSizeForEncoding(Length, 0x8000100u) + 1;
  CFStringRef v6 = (char *)CFAllocatorAllocate(a1, v5, 0);
  CFStringGetCString(theString, v6, v5, 0x8000100u);
  return v6;
}

void sub_100034714(int a1, CFStringRef format, ...)
{
  va_start(va, format);
  CFStringRef v3 = CFStringCreateWithFormatAndArguments(kCFAllocatorDefault, 0, format, va);
  CFNumberRef v4 = sub_1000346A0(kCFAllocatorDefault, v3);
  if (!dword_10008FA20) {
    goto LABEL_17;
  }
  if (a1 <= 2)
  {
    CFIndex v5 = ne_log_obj();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_FAULT)) {
      sub_100065428();
    }
    goto LABEL_17;
  }
  if (a1 == 3)
  {
    CFStringRef v6 = ne_log_obj();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR)) {
      sub_10006549C();
    }
    goto LABEL_17;
  }
  if (a1 <= 5)
  {
    CFStringRef v7 = ne_log_obj();
    if (!os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_17;
    }
    *(_DWORD *)uint8_t buf = 136315138;
    size_t v13 = v4;
    CFTypeID v8 = v7;
    os_log_type_t v9 = OS_LOG_TYPE_DEFAULT;
LABEL_14:
    _os_log_impl((void *)&_mh_execute_header, v8, v9, "%s", buf, 0xCu);
    goto LABEL_17;
  }
  CFStringRef v10 = ne_log_obj();
  CFTypeID v11 = v10;
  if (a1 == 6)
  {
    if (!os_log_type_enabled(v10, OS_LOG_TYPE_INFO)) {
      goto LABEL_17;
    }
    *(_DWORD *)uint8_t buf = 136315138;
    size_t v13 = v4;
    CFTypeID v8 = v11;
    os_log_type_t v9 = OS_LOG_TYPE_INFO;
    goto LABEL_14;
  }
  if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG)) {
    sub_100065504();
  }
LABEL_17:
  CFAllocatorDeallocate(kCFAllocatorDefault, v4);
  CFRelease(v3);
}

uint64_t *sub_100034900(unsigned __int8 *a1)
{
  CFTypeID v2 = &qword_10008CD18;
  do
    CFTypeID v2 = (uint64_t *)*v2;
  while (v2 && sub_100034944(a1, (unsigned __int8 *)v2 + 16));
  return v2;
}

BOOL sub_100034944(unsigned __int8 *a1, unsigned __int8 *a2)
{
  return *a1 != *a2
      || a1[264] != a2[264]
      || a1[265] != a2[265]
      || *((unsigned __int16 *)a1 + 133) != *((unsigned __int16 *)a2 + 133)
      || sub_10003BB04((unint64_t)(a1 + 8), (unint64_t)(a2 + 8))
      || sub_10003BB04((unint64_t)(a1 + 136), (unint64_t)(a2 + 136)) != 0;
}

uint64_t sub_1000349D4(unsigned __int8 *a1, unint64_t *a2)
{
  uint64_t v2 = qword_10008CD18;
  if (!qword_10008CD18) {
    return v2;
  }
  int v5 = 0;
  CFStringRef v6 = a2 + 1;
  while (1)
  {
    if (sub_100034D4C(a1, (unsigned __int8 *)(v2 + 16))) {
      goto LABEL_36;
    }
    if (*a1)
    {
      uint64_t v7 = *(void *)(v2 + 296);
      if (v7) {
        break;
      }
    }
LABEL_34:
    if (!v5) {
      return v2;
    }
    int v5 = 1;
LABEL_36:
    uint64_t v2 = *(void *)v2;
    if (!v2) {
      return v2;
    }
  }
  while (1)
  {
    if (*(unsigned char *)(v7 + 266) != 2)
    {
      if (dword_10008FA20)
      {
        os_log_type_t v9 = ne_log_obj();
        if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
        {
          int v10 = *a1;
          int v11 = *(unsigned __int8 *)(v7 + 266);
          *(_DWORD *)uint8_t buf = 136315650;
          uint64_t v26 = "getsp_r";
          __int16 v27 = 1024;
          int v28 = v10;
          __int16 v29 = 1024;
          int v30 = v11;
          _os_log_debug_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEBUG, "%s, skipping policy. dir %d, mode %d\n", buf, 0x18u);
        }
      }
      goto LABEL_33;
    }
    int v8 = *a1;
    if (v8 == 2) {
      break;
    }
    if (v8 == 1 && !sub_10003B8E4(*v6, v7 + 8) && !sub_10003B8E4(*a2, v7 + 136))
    {
      if (dword_10008FA20)
      {
        uint64_t v19 = ne_log_obj();
        if (os_log_type_enabled(v19, OS_LOG_TYPE_DEBUG)) {
          sub_1000656B8(v19);
        }
      }
      return v2;
    }
LABEL_17:
    if (dword_10008FA20)
    {
      long long v12 = ne_log_obj();
      if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG))
      {
        int v17 = *a1;
        *(_DWORD *)uint8_t buf = 136315394;
        uint64_t v26 = "getsp_r";
        __int16 v27 = 1024;
        int v28 = v17;
        _os_log_debug_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEBUG, "%s, policy outer addresses matched Phase 2 addresses: dir %d\n", buf, 0x12u);
      }
      if (dword_10008FA20)
      {
        size_t v13 = ne_log_obj();
        if (os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG)) {
          sub_100065670((uint64_t)v24, (const sockaddr **)a2);
        }
        if (dword_10008FA20)
        {
          int v14 = ne_log_obj();
          if (os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG)) {
            sub_100065618((uint64_t)v23, (const sockaddr *)(v7 + 8));
          }
          if (dword_10008FA20)
          {
            uint64_t v15 = ne_log_obj();
            if (os_log_type_enabled(v15, OS_LOG_TYPE_DEBUG)) {
              sub_1000655D0((uint64_t)v22, (const sockaddr **)v6);
            }
            if (dword_10008FA20)
            {
              int v16 = ne_log_obj();
              if (os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG)) {
                sub_100065578((uint64_t)v21, v7);
              }
            }
          }
        }
      }
    }
    int v5 = 1;
LABEL_33:
    uint64_t v7 = *(void *)v7;
    if (!v7) {
      goto LABEL_34;
    }
  }
  if (sub_10003B8E4(*a2, v7 + 8) || sub_10003B8E4(*v6, v7 + 136)) {
    goto LABEL_17;
  }
  if (dword_10008FA20)
  {
    uint64_t v20 = ne_log_obj();
    if (os_log_type_enabled(v20, OS_LOG_TYPE_DEBUG)) {
      sub_10006573C(v20);
    }
  }
  return v2;
}

BOOL sub_100034D4C(unsigned __int8 *a1, unsigned __int8 *a2)
{
  if (*a2 && *a1 != *a2) {
    return 1;
  }
  int v4 = *((unsigned __int16 *)a1 + 133);
  if (v4 != 255)
  {
    int v5 = *((unsigned __int16 *)a2 + 133);
    if (v5 != 255 && v4 != v5) {
      return 1;
    }
  }
  if (a1[9] != a2[9] || a1[137] != a2[137]) {
    return 1;
  }
  uint64_t v7 = a2 + 8;
  memset(v29, 0, sizeof(v29));
  memset(v28, 0, sizeof(v28));
  if (a1[8] > 0x80u || *v7 >= 0x81u)
  {
    if (dword_10008FA20)
    {
      int v8 = ne_log_obj();
      if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR)) {
        sub_1000657C0(a1 + 8, v7, v8);
      }
    }
    return 1;
  }
  sub_10003D410((char *)v29, a1 + 8, a2[264]);
  sub_10003D410((char *)v28, a2 + 8, a2[264]);
  if (dword_10008FA20)
  {
    os_log_type_t v9 = ne_log_obj();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
    {
      int v14 = a2[264];
      int v22 = 134218498;
      int v23 = a1;
      __int16 v24 = 1024;
      int v25 = v14;
      __int16 v26 = 2080;
      __int16 v27 = sub_10003CAE4(v29);
      _os_log_debug_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEBUG, "%p masked with /%d: %s\n", (uint8_t *)&v22, 0x1Cu);
    }
    if (dword_10008FA20)
    {
      int v10 = ne_log_obj();
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
      {
        int v15 = a2[264];
        int v16 = sub_10003CAE4(v28);
        int v22 = 134218498;
        int v23 = a2;
        __int16 v24 = 1024;
        int v25 = v15;
        __int16 v26 = 2080;
        __int16 v27 = v16;
        _os_log_debug_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEBUG, "%p masked with /%d: %s\n", (uint8_t *)&v22, 0x1Cu);
      }
    }
  }
  if (sub_10003BA4C((unint64_t)v29, (unint64_t)v28)) {
    return 1;
  }
  if (a1[136] > 0x80u || a2[136] >= 0x81u)
  {
    if (dword_10008FA20)
    {
      unsigned int v21 = ne_log_obj();
      if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR)) {
        sub_100065850(v21);
      }
    }
    exit(1);
  }
  sub_10003D410((char *)v29, a1 + 136, a2[265]);
  sub_10003D410((char *)v28, a2 + 136, a2[265]);
  if (dword_10008FA20)
  {
    long long v12 = ne_log_obj();
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG))
    {
      int v17 = a2[265];
      uint64_t v18 = sub_10003CAE4(v29);
      int v22 = 134218498;
      int v23 = a1;
      __int16 v24 = 1024;
      int v25 = v17;
      __int16 v26 = 2080;
      __int16 v27 = v18;
      _os_log_debug_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEBUG, "%p masked with /%d: %s\n", (uint8_t *)&v22, 0x1Cu);
    }
    if (dword_10008FA20)
    {
      size_t v13 = ne_log_obj();
      if (os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG))
      {
        int v19 = a2[265];
        uint64_t v20 = sub_10003CAE4(v28);
        int v22 = 134218498;
        int v23 = a2;
        __int16 v24 = 1024;
        int v25 = v19;
        __int16 v26 = 2080;
        __int16 v27 = v20;
        _os_log_debug_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEBUG, "%p masked with /%d: %s\n", (uint8_t *)&v22, 0x1Cu);
      }
    }
  }
  return sub_10003BA4C((unint64_t)v29, (unint64_t)v28) != 0;
}

uint64_t *sub_10003511C(int a1)
{
  uint64_t result = &qword_10008CD18;
  do
    uint64_t result = (uint64_t *)*result;
  while (result && *((_DWORD *)result + 72) != a1);
  return result;
}

void *sub_100035140()
{
  return malloc_type_calloc(1uLL, 0x130uLL, 0x10A004034AE4055uLL);
}

void sub_10003515C(void *a1)
{
  uint64_t v2 = (void *)a1[37];
  if (v2)
  {
    do
    {
      CFStringRef v3 = (void *)*v2;
      free(v2);
      uint64_t v2 = v3;
    }
    while (v3);
  }

  free(a1);
}

void sub_1000351A8(void *__src)
{
  memcpy(__dst, __src, sizeof(__dst));
  if (LOBYTE(__dst[0]) == 2)
  {
    long long v21 = *(_OWORD *)&__dst[25];
    long long v22 = *(_OWORD *)&__dst[27];
    long long v23 = *(_OWORD *)&__dst[29];
    long long v24 = *(_OWORD *)&__dst[31];
    long long v17 = *(_OWORD *)&__dst[17];
    long long v18 = *(_OWORD *)&__dst[19];
    long long v19 = *(_OWORD *)&__dst[21];
    long long v20 = *(_OWORD *)&__dst[23];
    long long v11 = *(_OWORD *)&__dst[5];
    long long v12 = *(_OWORD *)&__dst[7];
    long long v9 = *(_OWORD *)&__dst[1];
    long long v10 = *(_OWORD *)&__dst[3];
    long long v15 = *(_OWORD *)&__dst[13];
    long long v16 = *(_OWORD *)&__dst[15];
    long long v13 = *(_OWORD *)&__dst[9];
    long long v14 = *(_OWORD *)&__dst[11];
    char v1 = BYTE1(__dst[33]);
    char v2 = __dst[33];
  }
  else
  {
    if (LOBYTE(__dst[0]) != 1) {
      return;
    }
    long long v21 = *(_OWORD *)&__dst[9];
    long long v22 = *(_OWORD *)&__dst[11];
    long long v23 = *(_OWORD *)&__dst[13];
    long long v24 = *(_OWORD *)&__dst[15];
    long long v17 = *(_OWORD *)&__dst[1];
    long long v18 = *(_OWORD *)&__dst[3];
    long long v19 = *(_OWORD *)&__dst[5];
    long long v20 = *(_OWORD *)&__dst[7];
    long long v11 = *(_OWORD *)&__dst[21];
    long long v12 = *(_OWORD *)&__dst[23];
    long long v9 = *(_OWORD *)&__dst[17];
    long long v10 = *(_OWORD *)&__dst[19];
    long long v15 = *(_OWORD *)&__dst[29];
    long long v16 = *(_OWORD *)&__dst[31];
    long long v13 = *(_OWORD *)&__dst[25];
    long long v14 = *(_OWORD *)&__dst[27];
    char v1 = __dst[33];
    char v2 = BYTE1(__dst[33]);
  }
  *(_OWORD *)&__dst[9] = v21;
  *(_OWORD *)&__dst[11] = v22;
  *(_OWORD *)&__dst[13] = v23;
  *(_OWORD *)&__dst[15] = v24;
  *(_OWORD *)&__dst[1] = v17;
  *(_OWORD *)&__dst[3] = v18;
  *(_OWORD *)&__dst[5] = v19;
  *(_OWORD *)&__dst[7] = v20;
  *(_OWORD *)&__dst[23] = v12;
  *(_OWORD *)&__dst[21] = v11;
  *(_OWORD *)&__dst[19] = v10;
  *(_OWORD *)&__dst[17] = v9;
  *(_OWORD *)&__dst[31] = v16;
  *(_OWORD *)&__dst[29] = v15;
  *(_OWORD *)&__dst[27] = v14;
  *(_OWORD *)&__dst[25] = v13;
  LOBYTE(__dst[33]) = v1;
  LOBYTE(__dst[0]) = 1;
  CFStringRef v3 = &qword_10008CD18;
  BYTE1(__dst[33]) = v2;
  while (1)
  {
    CFStringRef v3 = (uint64_t *)*v3;
    if (!v3) {
      break;
    }
    if (!sub_100034944((unsigned __int8 *)__dst, (unsigned __int8 *)v3 + 16))
    {
      uint64_t v4 = *v3;
      int v5 = (uint64_t *)v3[1];
      if (*v3)
      {
        *(void *)(v4 + 8) = v5;
        int v5 = (uint64_t *)v3[1];
      }
      else
      {
        qword_10008CD20 = v3[1];
      }
      *int v5 = v4;
      sub_10003B3DC();
      sub_10003515C(v3);
      break;
    }
  }
  *(_OWORD *)&__dst[9] = v13;
  *(_OWORD *)&__dst[11] = v14;
  *(_OWORD *)&__dst[13] = v15;
  *(_OWORD *)&__dst[15] = v16;
  *(_OWORD *)&__dst[1] = v9;
  *(_OWORD *)&__dst[3] = v10;
  *(_OWORD *)&__dst[5] = v11;
  *(_OWORD *)&__dst[7] = v12;
  *(_OWORD *)&__dst[21] = v19;
  *(_OWORD *)&__dst[23] = v20;
  *(_OWORD *)&__dst[17] = v17;
  *(_OWORD *)&__dst[19] = v18;
  *(_OWORD *)&__dst[29] = v23;
  *(_OWORD *)&__dst[31] = v24;
  *(_OWORD *)&__dst[25] = v21;
  *(_OWORD *)&__dst[27] = v22;
  LOBYTE(__dst[33]) = v2;
  BYTE1(__dst[33]) = v1;
  CFStringRef v6 = &qword_10008CD18;
  LOBYTE(__dst[0]) = 2;
  while (1)
  {
    CFStringRef v6 = (uint64_t *)*v6;
    if (!v6) {
      break;
    }
    if (!sub_100034944((unsigned __int8 *)__dst, (unsigned __int8 *)v6 + 16))
    {
      uint64_t v7 = *v6;
      int v8 = (uint64_t *)v6[1];
      if (*v6)
      {
        *(void *)(v7 + 8) = v8;
        int v8 = (uint64_t *)v6[1];
      }
      else
      {
        qword_10008CD20 = v6[1];
      }
      *int v8 = v7;
      sub_10003B3DC();
      sub_10003515C(v6);
      return;
    }
  }
}

void sub_100035468(uint64_t *a1)
{
  uint64_t v1 = *a1;
  char v2 = (void *)a1[1];
  if (*a1)
  {
    *(void *)(v1 + 8) = v2;
    char v2 = (void *)a1[1];
  }
  else
  {
    qword_10008CD20 = a1[1];
  }
  *char v2 = v1;
  sub_10003B3DC();
}

void sub_10003548C(void *a1)
{
  uint64_t v1 = (uint64_t *)qword_10008CD18;
  *a1 = qword_10008CD18;
  if (!v1) {
    uint64_t v1 = &qword_10008CD18;
  }
  v1[1] = (uint64_t)a1;
  qword_10008CD18 = (uint64_t)a1;
  a1[1] = &qword_10008CD18;
  sub_10003B3DC();
}

void sub_1000354B4()
{
  int v0 = (void *)qword_10008CD18;
  if (qword_10008CD18)
  {
    do
    {
      char v2 = (void *)*v0;
      uint64_t v1 = (void *)v0[1];
      if (*v0)
      {
        v2[1] = v1;
        uint64_t v1 = (void *)v0[1];
      }
      else
      {
        qword_10008CD20 = v0[1];
      }
      *uint64_t v1 = v2;
      sub_10003B3DC();
      sub_10003515C(v0);
      int v0 = v2;
    }
    while (v2);
  }
}

BOOL sub_100035518()
{
  return qword_10008CD18 != 0;
}

void sub_10003552C()
{
  qword_10008CD18 = 0;
  qword_10008CD20 = (uint64_t)&qword_10008CD18;
}

void *sub_10003553C()
{
  return malloc_type_calloc(1uLL, 0x120uLL, 0x102004020B6CA89uLL);
}

char *sub_100035558(unsigned __int8 *a1)
{
  char v2 = sub_10003CAE4((const sockaddr *)(a1 + 8));
  for (CFIndex i = (const char *)v2; *i; ++i)
  {
    if (*i == 91)
    {
      *i++ = 0;
      break;
    }
  }
  unsigned int v4 = snprintf(byte_10008CD28, 0xFFuLL, "%s/%d[%s ", (const char *)v2, a1[264], i);
  if (v4 > 0xFE) {
    return 0;
  }
  CFStringRef v6 = &byte_10008CD28[v4];
  size_t v7 = 255 - v4;
  int v8 = sub_10003CAE4((const sockaddr *)(a1 + 136));
  for (CFIndex j = (const char *)v8; *j; ++j)
  {
    if (*j == 91)
    {
      *j++ = 0;
      break;
    }
  }
  int v10 = snprintf(v6, v7, "%s/%d[%s ", (const char *)v8, a1[265], j);
  uint64_t result = 0;
  if ((v10 & 0x80000000) == 0 && (int)v7 > v10)
  {
    size_t v11 = (int)v7 - v10;
    long long v12 = &v6[v10];
    long long v13 = sub_10003F030(*((unsigned __int16 *)a1 + 133));
    long long v14 = sub_10003EFA4(*a1);
    snprintf(v12, v11, "proto=%s dir=%s", v13, v14);
    return byte_10008CD28;
  }
  return result;
}

uint64_t *sub_10003568C(uint64_t a1, const sockaddr **a2)
{
  CFStringRef v3 = *a2;
  return sub_10003CAE4(v3);
}

void *sub_1000356AC()
{
  return malloc_type_calloc(1uLL, 0x30uLL, 0x10200401AD049D5uLL);
}

void *sub_1000356C8()
{
  return malloc_type_calloc(1uLL, 0x50uLL, 0x1020040BE967AE7uLL);
}

uint64_t *sub_1000356E4(uint64_t *result, uint64_t a2)
{
  uint64_t v2 = *result;
  if (*result)
  {
    do
    {
      uint64_t v3 = v2;
      uint64_t v2 = *(void *)(v2 + 40);
    }
    while (v2);
    uint64_t result = (uint64_t *)(v3 + 40);
  }
  *uint64_t result = a2;
  return result;
}

void *sub_100035704(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a1 + 32);
  uint64_t result = (void *)(a1 + 32);
  uint64_t v3 = v4;
  while (v3)
  {
    uint64_t v5 = v3;
    uint64_t v3 = *(void *)(v3 + 72);
    if (!v3)
    {
      uint64_t result = (void *)(v5 + 72);
      break;
    }
  }
  *uint64_t result = a2;
  return result;
}

uint64_t sub_100035724(uint64_t result, uint64_t a2)
{
  *(void *)(a2 + 72) = *(void *)(result + 32);
  *(void *)(result + 32) = a2;
  return result;
}

void *sub_100035734()
{
  return malloc_type_calloc(1uLL, 0x18uLL, 0x10200403ED2C137uLL);
}

void *sub_100035750(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a1 + 64);
  uint64_t result = (void *)(a1 + 64);
  uint64_t v3 = v4;
  while (v3)
  {
    uint64_t v5 = v3;
    uint64_t v3 = *(void *)(v3 + 16);
    if (!v3)
    {
      uint64_t result = (void *)(v5 + 16);
      break;
    }
  }
  *uint64_t result = a2;
  return result;
}

uint64_t sub_100035770(void *a1, uint64_t a2)
{
  if (a1)
  {
    uint64_t v2 = a1;
    uint64_t v3 = *a1;
    if (*a1)
    {
      if (v3 == a2)
      {
LABEL_7:
        uint64_t result = 0;
        *uint64_t v2 = *(void *)(a2 + 16);
        *(void *)(a2 + 16) = 0;
        return result;
      }
      while (1)
      {
        uint64_t v4 = v3;
        uint64_t v3 = *(void *)(v3 + 16);
        if (!v3) {
          break;
        }
        if (v3 == a2)
        {
          uint64_t v2 = (void *)(v4 + 16);
          goto LABEL_7;
        }
      }
    }
  }
  return 0xFFFFFFFFLL;
}

void *sub_1000357BC(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  int v8 = malloc_type_calloc(1uLL, 0x30uLL, 0x10200401AD049D5uLL);
  if (!v8)
  {
    if (dword_10008FA20)
    {
      size_t v11 = ne_log_obj();
      if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR)) {
        sub_100065894();
      }
    }
    return 0;
  }
  long long v9 = v8;
  *(_DWORD *)int v8 = *(_DWORD *)a2;
  switch(*(_DWORD *)(*(void *)(a1 + 64) + 172))
  {
    case 1:
      v8[1] = *(void *)(a2 + 8);
      *((_DWORD *)v8 + 4) = *(_DWORD *)(a2 + 16);
      int v10 = *(_DWORD *)(a2 + 20);
      goto LABEL_45;
    case 2:
      uint64_t v12 = *(void *)(a2 + 8);
      if (v12 <= *(void *)(a3 + 8))
      {
        int v22 = *(_DWORD *)(a2 + 16);
        if (v22 <= *(_DWORD *)(a3 + 16))
        {
          v8[1] = v12;
LABEL_39:
          *((_DWORD *)v9 + 4) = v22;
          int v10 = *(_DWORD *)(a3 + 20);
          if (!v10)
          {
            int v10 = *(_DWORD *)(a2 + 20);
            goto LABEL_45;
          }
          if (*(_DWORD *)(a2 + 20) == v10) {
            goto LABEL_45;
          }
          if (dword_10008FA20)
          {
            int v30 = ne_log_obj();
            if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR)) {
              sub_100065C04();
            }
          }
        }
        else if (dword_10008FA20)
        {
          long long v23 = ne_log_obj();
          if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR)) {
            sub_100065B9C();
          }
        }
      }
      else if (dword_10008FA20)
      {
        long long v13 = ne_log_obj();
        if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR)) {
          sub_100065B34();
        }
      }
      goto LABEL_141;
    case 3:
      uint64_t v14 = *(void *)(a2 + 8);
      uint64_t v15 = *(void *)(a3 + 8);
      if (v14 <= v15)
      {
        v8[1] = v14;
      }
      else
      {
        v8[1] = v15;
        *((_DWORD *)v8 + 6) |= 1u;
        if (dword_10008FA20)
        {
          long long v16 = ne_log_obj();
          if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v17 = *(void *)(a3 + 8);
            uint64_t v18 = *(void *)(a2 + 8);
            *(_DWORD *)uint8_t buf = 67109376;
            *(_DWORD *)long long v80 = v17;
            *(_WORD *)&v80[4] = 1024;
            *(_DWORD *)&v80[6] = v18;
            _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "use own lifetime: my:%d peer:%d\n", buf, 0xEu);
          }
        }
      }
      int v24 = *(_DWORD *)(a3 + 16);
      if (*(_DWORD *)(a2 + 16) > v24)
      {
        *((_DWORD *)v9 + 4) = v24;
        *((_DWORD *)v9 + 6) |= 1u;
        if (dword_10008FA20)
        {
          int v25 = ne_log_obj();
          if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
          {
            int v26 = *(_DWORD *)(a3 + 16);
            int v27 = *(_DWORD *)(a2 + 16);
            *(_DWORD *)uint8_t buf = 67109376;
            *(_DWORD *)long long v80 = v26;
            *(_WORD *)&v80[4] = 1024;
            *(_DWORD *)&v80[6] = v27;
            _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "use own lifebyte: my:%d peer:%d\n", buf, 0xEu);
          }
        }
      }
      int v22 = *(_DWORD *)(a2 + 16);
      goto LABEL_39;
    case 4:
      uint64_t v19 = *(void *)(a2 + 8);
      if (v19 != *(void *)(a3 + 8))
      {
        if (dword_10008FA20)
        {
          int v28 = ne_log_obj();
          if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR)) {
            sub_100065CD4();
          }
        }
        goto LABEL_141;
      }
      int v20 = *(_DWORD *)(a2 + 16);
      if (v20 != *(_DWORD *)(a3 + 16))
      {
        if (dword_10008FA20)
        {
          __int16 v29 = ne_log_obj();
          if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR)) {
            sub_100065C6C();
          }
        }
        goto LABEL_141;
      }
      int v10 = *(_DWORD *)(a2 + 20);
      if (v10 != *(_DWORD *)(a3 + 20))
      {
        if (dword_10008FA20)
        {
          int v69 = ne_log_obj();
          if (os_log_type_enabled(v69, OS_LOG_TYPE_ERROR)) {
            sub_100065C04();
          }
        }
        goto LABEL_141;
      }
      v8[1] = v19;
      *((_DWORD *)v8 + 4) = v20;
LABEL_45:
      *((_DWORD *)v9 + 5) = v10;
      uint64_t i = *(void *)(a2 + 32);
      if (i)
      {
        int v32 = 0;
        uint64_t v33 = *(void *)(a2 + 32);
        do
        {
          ++v32;
          uint64_t v33 = *(void *)(v33 + 72);
        }
        while (v33);
      }
      else
      {
        int v32 = 0;
      }
      uint64_t v34 = *(void *)(a3 + 32);
      if (v34)
      {
        int v35 = 0;
        uint64_t v36 = *(void *)(a3 + 32);
        do
        {
          ++v35;
          uint64_t v36 = *(void *)(v36 + 72);
        }
        while (v36);
      }
      else
      {
        int v35 = 0;
      }
      if (v32 != v35) {
        goto LABEL_141;
      }
      unsigned int v37 = v78;
      if (!a4) {
        goto LABEL_63;
      }
LABEL_57:
      if (a4 != 1)
      {
        while (1)
        {
LABEL_68:
          BOOL v38 = i != 0;
          BOOL v39 = v34 != 0;
          if (!i || !v34) {
            goto LABEL_129;
          }
          if (*(_DWORD *)i != *(_DWORD *)v34)
          {
            if (dword_10008FA20)
            {
              uint64_t v70 = ne_log_obj();
              if (os_log_type_enabled(v70, OS_LOG_TYPE_ERROR)) {
                sub_100065AA0((int *)v34, (int *)i);
              }
            }
            goto LABEL_141;
          }
          uint64_t v40 = *(void *)(i + 8);
          uint64_t v41 = *(void *)(v34 + 8);
          if (v40 != v41)
          {
            if (*(_DWORD *)i != 4) {
              goto LABEL_153;
            }
            if (v40 == 2 && v41 == 4)
            {
              if (!dword_10008FA20) {
                goto LABEL_83;
              }
LABEL_80:
              __int16 v42 = ne_log_obj();
              if (os_log_type_enabled(v42, OS_LOG_TYPE_ERROR)) {
                sub_1000659F8(&v77, v37, v42);
              }
              goto LABEL_83;
            }
            if (v41 != 2) {
              goto LABEL_153;
            }
            if (v40 == 4 && dword_10008FA20) {
              goto LABEL_80;
            }
            if (v40 != 4)
            {
LABEL_153:
              if (dword_10008FA20)
              {
                long long v72 = ne_log_obj();
                if (os_log_type_enabled(v72, OS_LOG_TYPE_ERROR)) {
                  sub_100065A38();
                }
              }
              goto LABEL_141;
            }
          }
LABEL_83:
          if ((*(unsigned char *)(a1 + 96) & 6) == 0) {
            goto LABEL_108;
          }
          if (sub_10003FE74(*(_DWORD *)(v34 + 16)))
          {
            int v43 = *(_DWORD *)(v34 + 16);
            int v44 = 1;
            if (v43 > 61442)
            {
              if (v43 == 61443) {
                goto LABEL_92;
              }
              if (v43 == 61444) {
                goto LABEL_91;
              }
            }
            else
            {
              if (v43 != 3)
              {
                if (v43 != 4) {
                  goto LABEL_93;
                }
LABEL_91:
                int v44 = 2;
              }
LABEL_92:
              *(_DWORD *)(v34 + 16) = v44;
              *(_DWORD *)(v34 + 20) = 1;
            }
LABEL_93:
            if (dword_10008FA20)
            {
              uint64_t v45 = ne_log_obj();
              if (os_log_type_enabled(v45, OS_LOG_TYPE_DEFAULT))
              {
                long long v75 = v37;
                uint64_t v46 = sub_10003E71C(v43);
                CFStringRef v47 = sub_10003E71C(*(_DWORD *)(v34 + 16));
                int v48 = *(_DWORD *)(v34 + 16);
                *(_DWORD *)uint8_t buf = 136315906;
                *(void *)long long v80 = v46;
                unsigned int v37 = v75;
                *(_WORD *)&v80[8] = 1024;
                int v81 = v43;
                __int16 v82 = 2080;
                long long v83 = v47;
                __int16 v84 = 1024;
                int v85 = v48;
                _os_log_impl((void *)&_mh_execute_header, v45, OS_LOG_TYPE_DEFAULT, "Adjusting my encmode %s(%d)->%s(%d)\n", buf, 0x22u);
              }
            }
          }
          if (!sub_10003FE74(*(_DWORD *)(i + 16))) {
            goto LABEL_108;
          }
          int v49 = *(_DWORD *)(i + 16);
          int v50 = 1;
          if (v49 <= 61442)
          {
            if (v49 != 3)
            {
              if (v49 != 4) {
                goto LABEL_105;
              }
LABEL_103:
              int v50 = 2;
            }
LABEL_104:
            *(_DWORD *)(i + 16) = v50;
            *(_DWORD *)(i + 20) = 1;
            goto LABEL_105;
          }
          if (v49 == 61443) {
            goto LABEL_104;
          }
          if (v49 == 61444) {
            goto LABEL_103;
          }
LABEL_105:
          if (dword_10008FA20)
          {
            uint64_t v51 = ne_log_obj();
            if (os_log_type_enabled(v51, OS_LOG_TYPE_DEFAULT))
            {
              long long v76 = v37;
              SecCertificateRef v52 = sub_10003E71C(v49);
              CFArrayRef v53 = sub_10003E71C(*(_DWORD *)(i + 16));
              int v54 = *(_DWORD *)(i + 16);
              *(_DWORD *)uint8_t buf = 136315906;
              *(void *)long long v80 = v52;
              unsigned int v37 = v76;
              *(_WORD *)&v80[8] = 1024;
              int v81 = v49;
              __int16 v82 = 2080;
              long long v83 = v53;
              __int16 v84 = 1024;
              int v85 = v54;
              _os_log_impl((void *)&_mh_execute_header, v51, OS_LOG_TYPE_DEFAULT, "Adjusting peer's encmode %s(%d)->%s(%d)\n", buf, 0x22u);
            }
          }
LABEL_108:
          if (*(_DWORD *)(i + 16) != *(_DWORD *)(v34 + 16))
          {
            if (dword_10008FA20)
            {
              long long v71 = ne_log_obj();
              if (os_log_type_enabled(v71, OS_LOG_TYPE_ERROR)) {
                sub_100065964((int *)(v34 + 16), (int *)(i + 16));
              }
            }
            goto LABEL_141;
          }
          uint64_t v55 = *(void *)(i + 64);
          if (!v55) {
            goto LABEL_141;
          }
          while (1)
          {
            uint64_t v56 = *(void *)(v34 + 64);
            if (v56) {
              break;
            }
LABEL_113:
            uint64_t v55 = *(void *)(v55 + 16);
            if (!v55) {
              goto LABEL_141;
            }
          }
          while (sub_100036248(*(_DWORD *)i, (unsigned int *)v55, (unsigned int *)v56))
          {
            uint64_t v56 = *(void *)(v56 + 16);
            if (!v56) {
              goto LABEL_113;
            }
          }
          CFStringRef v57 = malloc_type_calloc(1uLL, 0x50uLL, 0x1020040BE967AE7uLL);
          if (!v57)
          {
            if (dword_10008FA20)
            {
              long long v73 = ne_log_obj();
              if (os_log_type_enabled(v73, OS_LOG_TYPE_ERROR)) {
                sub_1000658FC();
              }
            }
            goto LABEL_141;
          }
          char v58 = v57;
          *(_DWORD *)CFStringRef v57 = *(_DWORD *)i;
          v57[1] = *(void *)(i + 8);
          *((_DWORD *)v57 + 4) = *(_DWORD *)(i + 16);
          *((_DWORD *)v57 + 6) = *(_DWORD *)(v34 + 24);
          *((_DWORD *)v57 + 7) = *(_DWORD *)(i + 24);
          v57[6] = *(void *)(v34 + 48);
          *((_DWORD *)v57 + 5) = *(_DWORD *)(v34 + 20) | *(_DWORD *)(i + 20);
          int v59 = malloc_type_calloc(1uLL, 0x18uLL, 0x10200403ED2C137uLL);
          if (!v59)
          {
            if (dword_10008FA20)
            {
              long long v74 = ne_log_obj();
              if (os_log_type_enabled(v74, OS_LOG_TYPE_ERROR)) {
                sub_100065930();
              }
            }
            free(v58);
            goto LABEL_141;
          }
          *int v59 = *(_OWORD *)v55;
          uint64_t v60 = v58 + 8;
          uint64_t v61 = v58[8];
          while (v61)
          {
            uint64_t v62 = v61;
            uint64_t v61 = *(void *)(v61 + 16);
            if (!v61)
            {
              uint64_t v60 = (void *)(v62 + 16);
              break;
            }
          }
          *uint64_t v60 = v59;
          uint64_t v63 = v9[4];
          while (v63)
          {
            uint64_t v64 = v63;
            uint64_t v63 = *(void *)(v63 + 72);
            if (!v63)
            {
              uint64_t v65 = (void *)(v64 + 72);
              goto LABEL_126;
            }
          }
          uint64_t v65 = v9 + 4;
LABEL_126:
          void *v65 = v58;
          uint64_t v34 = *(void *)(v34 + 72);
          uint64_t i = *(void *)(i + 72);
          if (a4) {
            goto LABEL_57;
          }
LABEL_63:
          if (!i) {
            goto LABEL_128;
          }
          uint64_t v34 = *(void *)(a3 + 32);
          if (!v34) {
            goto LABEL_128;
          }
          while (*(_DWORD *)v34 != *(_DWORD *)i)
          {
            uint64_t v34 = *(void *)(v34 + 72);
            if (!v34) {
              goto LABEL_128;
            }
          }
        }
      }
      if (v34)
      {
        for (uint64_t i = *(void *)(a2 + 32); i; uint64_t i = *(void *)(i + 72))
        {
          if (*(_DWORD *)i == *(_DWORD *)v34) {
            goto LABEL_68;
          }
        }
      }
LABEL_128:
      BOOL v38 = i != 0;
      BOOL v39 = v34 != 0;
LABEL_129:
      if (v38) {
        uint64_t v66 = v34;
      }
      else {
        uint64_t v66 = 0;
      }
      if (v39) {
        uint64_t v67 = i;
      }
      else {
        uint64_t v67 = 0;
      }
      if (a4 != 1) {
        uint64_t v67 = i;
      }
      if (a4) {
        uint64_t v66 = v34;
      }
      else {
        uint64_t v67 = i;
      }
      if (v67 | v66)
      {
LABEL_141:
        sub_100036420(v9);
        return 0;
      }
      return v9;
    default:
      if (dword_10008FA20)
      {
        long long v21 = ne_log_obj();
        if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR)) {
          sub_1000658C8();
        }
      }
      goto LABEL_141;
  }
}

uint64_t sub_100036248(int a1, unsigned int *a2, unsigned int *a3)
{
  if (a2[1] != a3[1])
  {
    if (dword_10008FA20)
    {
      long long v13 = ne_log_obj();
      if (os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v14 = sub_10003E580(a1, a3[1]);
        uint64_t v15 = sub_10003E580(a1, a2[1]);
        int v17 = 136315394;
        *(void *)uint64_t v18 = v14;
        *(_WORD *)&v18[8] = 2080;
        uint64_t v19 = v15;
        _os_log_debug_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEBUG, "trns_id mismatched: my:%s peer:%s\n", (uint8_t *)&v17, 0x16u);
      }
    }
    return 1;
  }
  uint64_t v5 = a2 + 3;
  if (a2[3] != a3[3])
  {
    if (dword_10008FA20)
    {
      long long v16 = ne_log_obj();
      if (os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG)) {
        sub_100065D3C(a3 + 3, v5);
      }
    }
    return 1;
  }
  if ((int)a2[2] > (int)a3[2] && dword_10008FA20 != 0)
  {
    size_t v7 = ne_log_obj();
    BOOL v8 = os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT);
    uint64_t result = 0;
    if (!v8) {
      return result;
    }
    unsigned int v10 = a3[2];
    unsigned int v11 = a2[2];
    int v17 = 67109376;
    *(_DWORD *)uint64_t v18 = v10;
    *(_WORD *)&v18[4] = 1024;
    *(_DWORD *)&v18[6] = v11;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "less key length proposed, mine:%d peer:%d.  Use initiaotr's one.\n", (uint8_t *)&v17, 0xEu);
  }
  return 0;
}

void sub_100036420(uint64_t *a1)
{
  if (a1)
  {
    uint64_t v1 = a1;
    do
    {
      uint64_t v2 = (uint64_t *)v1[5];
      sub_100036D80(v1[4]);
      free(v1);
      uint64_t v1 = v2;
    }
    while (v2);
  }
}

uint64_t sub_100036460(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a1 + 20) != *(_DWORD *)(a2 + 20) && dword_10008FA20 != 0)
  {
    uint64_t v5 = ne_log_obj();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      int v6 = *(_DWORD *)(a1 + 20);
      int v7 = *(_DWORD *)(a2 + 20);
      int v16 = 67109376;
      int v17 = v6;
      __int16 v18 = 1024;
      int v19 = v7;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "pfs_group mismatch. mine:%d peer:%d\n", (uint8_t *)&v16, 0xEu);
    }
  }
  if (*(void *)(a1 + 8) > *(void *)(a2 + 8) && dword_10008FA20 != 0)
  {
    long long v9 = ne_log_obj();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v10 = *(void *)(a1 + 8);
      uint64_t v11 = *(void *)(a2 + 8);
      int v16 = 67109376;
      int v17 = v10;
      __int16 v18 = 1024;
      int v19 = v11;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "less lifetime proposed. mine:%d peer:%d\n", (uint8_t *)&v16, 0xEu);
    }
  }
  if (*(_DWORD *)(a1 + 16) > *(_DWORD *)(a2 + 16))
  {
    if (dword_10008FA20)
    {
      uint64_t v12 = ne_log_obj();
      if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
      {
        int v13 = *(_DWORD *)(a1 + 16);
        int v14 = *(_DWORD *)(a2 + 16);
        int v16 = 67109376;
        int v17 = v13;
        __int16 v18 = 1024;
        int v19 = v14;
        _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "less lifebyte proposed. mine:%d peer:%d\n", (uint8_t *)&v16, 0xEu);
      }
    }
  }
  return 0;
}

uint64_t sub_100036628(uint64_t a1, void *a2, int a3)
{
  int v5 = *(_DWORD *)a1;
  if (*(_DWORD *)a1 == 4)
  {
    int v14 = (int *)a2[8];
    if (!v14)
    {
      if (dword_10008FA20)
      {
        uint64_t v41 = ne_log_obj();
        if (os_log_type_enabled(v41, OS_LOG_TYPE_ERROR)) {
          sub_100065EE4();
        }
      }
      goto LABEL_66;
    }
    uint64_t v15 = (uint64_t *)(a1 + 64);
    int v16 = 1;
    while (1)
    {
      int v17 = malloc_type_calloc(1uLL, 0x18uLL, 0x10200403ED2C137uLL);
      if (!v17) {
        break;
      }
      int v18 = *v14;
      *int v17 = v16;
      v17[1] = v18;
      v17[3] = 254;
      uint64_t v19 = *v15;
      while (v19)
      {
        uint64_t v20 = v19;
        uint64_t v19 = *(void *)(v19 + 16);
        if (!v19)
        {
          long long v21 = (void *)(v20 + 16);
          goto LABEL_24;
        }
      }
      long long v21 = (void *)(a1 + 64);
LABEL_24:
      *long long v21 = v17;
      int v14 = (int *)*((void *)v14 + 1);
      ++v16;
      if (!v14) {
        goto LABEL_40;
      }
    }
    if (!dword_10008FA20) {
      goto LABEL_66;
    }
    int v43 = ne_log_obj();
    if (!os_log_type_enabled(v43, OS_LOG_TYPE_ERROR)) {
      goto LABEL_66;
    }
LABEL_65:
    sub_100065930();
    goto LABEL_66;
  }
  if (v5 != 3)
  {
    if (v5 != 2)
    {
      if (dword_10008FA20)
      {
        int v32 = ne_log_obj();
        if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR)) {
          sub_100065DD8(a1, v32, v33, v34, v35, v36, v37, v38);
        }
      }
      goto LABEL_66;
    }
    uint64_t v6 = a2[7];
    if (!v6)
    {
      if (dword_10008FA20)
      {
        uint64_t v40 = ne_log_obj();
        if (os_log_type_enabled(v40, OS_LOG_TYPE_ERROR)) {
          sub_100065E48();
        }
      }
      goto LABEL_66;
    }
    int v7 = (uint64_t *)(a1 + 64);
    int v8 = 1;
    while (1)
    {
      if (*(_DWORD *)v6 != 254)
      {
        long long v9 = malloc_type_calloc(1uLL, 0x18uLL, 0x10200403ED2C137uLL);
        if (!v9)
        {
          if (dword_10008FA20)
          {
            uint64_t v45 = ne_log_obj();
            if (os_log_type_enabled(v45, OS_LOG_TYPE_ERROR)) {
              goto LABEL_65;
            }
          }
LABEL_66:
          uint64_t v46 = *(void **)(a1 + 64);
          if (v46)
          {
            do
            {
              CFStringRef v47 = (void *)v46[2];
              free(v46);
              uint64_t v46 = v47;
            }
            while (v47);
          }
          return 0xFFFFFFFFLL;
        }
        uint64_t v10 = v9;
        _DWORD *v9 = v8;
        v9[1] = sub_100011410(*(_DWORD *)v6);
        v10[3] = *(_DWORD *)v6;
        uint64_t v11 = *v7;
        while (v11)
        {
          uint64_t v12 = v11;
          uint64_t v11 = *(void *)(v11 + 16);
          if (!v11)
          {
            int v13 = (void *)(v12 + 16);
            goto LABEL_13;
          }
        }
        int v13 = (void *)(a1 + 64);
LABEL_13:
        *int v13 = v10;
        ++v8;
      }
      uint64_t v6 = *(void *)(v6 + 8);
      if (!v6) {
        goto LABEL_40;
      }
    }
  }
  int v22 = (void *)a2[6];
  if (!v22)
  {
    if (dword_10008FA20)
    {
      __int16 v42 = ne_log_obj();
      if (os_log_type_enabled(v42, OS_LOG_TYPE_ERROR)) {
        sub_100065EB0();
      }
    }
    goto LABEL_66;
  }
  if (a3 == 16)
  {
    long long v23 = (uint64_t *)(a1 + 64);
    uint64_t v24 = 1;
    while (1)
    {
      uint64_t v25 = a2[7];
      if (v25) {
        break;
      }
      uint64_t v27 = v24;
LABEL_39:
      int v22 = (void *)v22[1];
      uint64_t v24 = v27;
      if (!v22) {
        goto LABEL_40;
      }
    }
    while (1)
    {
      int v26 = (char *)malloc_type_calloc(1uLL, 0x18uLL, 0x10200403ED2C137uLL);
      if (!v26) {
        break;
      }
      uint64_t v27 = (v24 + 1);
      *(_DWORD *)int v26 = v24;
      *(void *)(v26 + 4) = *v22;
      *((_DWORD *)v26 + 3) = *(_DWORD *)v25;
      uint64_t v28 = *v23;
      while (v28)
      {
        uint64_t v29 = v28;
        uint64_t v28 = *(void *)(v28 + 16);
        if (!v28)
        {
          int v30 = (void *)(v29 + 16);
          goto LABEL_36;
        }
      }
      int v30 = (void *)(a1 + 64);
LABEL_36:
      *int v30 = v26;
      uint64_t v25 = *(void *)(v25 + 8);
      LODWORD(v24) = v24 + 1;
      if (!v25) {
        goto LABEL_39;
      }
    }
    if (!dword_10008FA20) {
      goto LABEL_66;
    }
    int v44 = ne_log_obj();
    if (!os_log_type_enabled(v44, OS_LOG_TYPE_ERROR)) {
      goto LABEL_66;
    }
    goto LABEL_65;
  }
LABEL_40:
  if (!*(void *)(a1 + 64))
  {
    if (dword_10008FA20)
    {
      BOOL v39 = ne_log_obj();
      if (os_log_type_enabled(v39, OS_LOG_TYPE_ERROR)) {
        sub_100065E7C();
      }
    }
    return 0xFFFFFFFFLL;
  }
  return 0;
}

void *sub_1000369CC(void *result)
{
  if (result)
  {
    do
    {
      uint64_t v1 = (void *)result[2];
      free(result);
      uint64_t result = v1;
    }
    while (v1);
  }
  return result;
}

uint64_t *sub_100036A00(uint64_t *a1)
{
  if (a1)
  {
    uint64_t v1 = a1;
    uint64_t v2 = (uint64_t *)malloc_type_calloc(1uLL, 0x30uLL, 0x10200401AD049D5uLL);
    if (v2)
    {
      uint64_t v3 = v2;
      *(_DWORD *)uint64_t v2 = *(unsigned __int8 *)(*v1 + 4);
      uint64_t v4 = v2 + 4;
      while (1)
      {
        int v5 = malloc_type_calloc(1uLL, 0x50uLL, 0x1020040BE967AE7uLL);
        if (!v5)
        {
          if (dword_10008FA20)
          {
            uint64_t v24 = ne_log_obj();
            if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR)) {
              sub_1000658FC();
            }
          }
          goto LABEL_34;
        }
        uint64_t v6 = v5;
        unint64_t v7 = *(unsigned __int8 *)(*v1 + 6);
        if (v7 >= 5) {
          break;
        }
        *(_DWORD *)int v5 = *(unsigned __int8 *)(*v1 + 5);
        v5[1] = v7;
        *((_DWORD *)v5 + 6) = 0;
        memcpy((char *)v5 - *(unsigned __int8 *)(*v1 + 6) + 28, (const void *)(*v1 + 8), *(unsigned __int8 *)(*v1 + 6));
        v6[6] = 0;
        int v8 = v1;
        do
        {
          if (dword_10008FA20)
          {
            long long v9 = ne_log_obj();
            if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
            {
              int v35 = *(unsigned __int8 *)(*v8 + 4);
              uint64_t v33 = sub_10003E344(*(unsigned __int8 *)(*v8 + 5));
              uint64_t v15 = v8[1];
              int v16 = *(unsigned __int8 *)(*v8 + 6);
              int v32 = *(unsigned __int8 *)(*v8 + 7);
              int v34 = *(unsigned __int8 *)(v15 + 4);
              int v17 = sub_10003E580(*(unsigned __int8 *)(*v8 + 5), *(unsigned __int8 *)(v15 + 5));
              *(_DWORD *)uint8_t buf = 67110402;
              int v37 = v35;
              __int16 v38 = 2080;
              BOOL v39 = v33;
              __int16 v40 = 1024;
              int v41 = v16;
              __int16 v42 = 1024;
              int v43 = v32;
              __int16 v44 = 1024;
              int v45 = v34;
              __int16 v46 = 2080;
              CFStringRef v47 = v17;
              _os_log_debug_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEBUG, "prop#=%d prot-id=%s spi-size=%d #trns=%d trns#=%d trns-id=%s\n", buf, 0x2Eu);
            }
          }
          uint64_t v10 = malloc_type_calloc(1uLL, 0x18uLL, 0x10200403ED2C137uLL);
          if (!v10)
          {
            if (dword_10008FA20)
            {
              int v22 = ne_log_obj();
              if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR)) {
                sub_100065930();
              }
            }
            goto LABEL_33;
          }
          uint64_t v11 = v10;
          if ((sub_100010C74(v8[1], (uint64_t)v3, v6, v10) & 0x80000000) != 0)
          {
            sub_100036420(v3);
            free(v11);
            free(v6);
            return 0;
          }
          uint64_t v12 = v6[8];
          while (v12)
          {
            uint64_t v13 = v12;
            uint64_t v12 = *(void *)(v12 + 16);
            if (!v12)
            {
              int v14 = (void *)(v13 + 16);
              goto LABEL_17;
            }
          }
          int v14 = v6 + 8;
LABEL_17:
          void *v14 = v11;
          int v8 = (uint64_t *)v8[3];
        }
        while (v8);
        if (!*((_DWORD *)v6 + 4)) {
          *((_DWORD *)v6 + 4) = 2;
        }
        uint64_t v18 = *v4;
        while (v18)
        {
          uint64_t v19 = v18;
          uint64_t v18 = *(void *)(v18 + 72);
          if (!v18)
          {
            uint64_t v20 = (void *)(v19 + 72);
            goto LABEL_25;
          }
        }
        uint64_t v20 = v4;
LABEL_25:
        *uint64_t v20 = v6;
        uint64_t v1 = (uint64_t *)v1[2];
        if (!v1) {
          return v3;
        }
      }
      if (dword_10008FA20)
      {
        uint64_t v25 = ne_log_obj();
        if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR)) {
          sub_100065F18((uint64_t)v1, v25, v26, v27, v28, v29, v30, v31);
        }
      }
LABEL_33:
      free(v6);
LABEL_34:
      sub_100036420(v3);
    }
    else if (dword_10008FA20)
    {
      long long v21 = ne_log_obj();
      if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR)) {
        sub_100065894();
      }
    }
  }
  return 0;
}

void sub_100036D80(uint64_t a1)
{
  if (a1)
  {
    uint64_t v1 = a1;
    do
    {
      uint64_t v2 = *(void **)(v1 + 64);
      uint64_t v3 = *(void *)(v1 + 72);
      if (v2)
      {
        do
        {
          uint64_t v4 = (void *)v2[2];
          free(v2);
          uint64_t v2 = v4;
        }
        while (v4);
      }
      sub_10003FA78(*(void **)(v1 + 32));
      sub_10003FA78(*(void **)(v1 + 40));
      free((void *)v1);
      uint64_t v1 = v3;
    }
    while (v3);
  }
}

void sub_100036DE8(int a1, uint64_t a2)
{
  if (a2)
  {
    uint64_t v3 = a2;
    do
    {
      for (uint64_t i = *(void *)(v3 + 32); i; uint64_t i = *(void *)(i + 72))
        sub_100036F88(a1, (int *)i);
      uint64_t v3 = *(void *)(v3 + 40);
    }
    while (v3);
    return;
  }
  if (!dword_10008FA20) {
    return;
  }
  if (a1 <= 2)
  {
    int v5 = ne_log_obj();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_FAULT)) {
      sub_100065F8C();
    }
    return;
  }
  if (a1 == 3)
  {
    uint64_t v6 = ne_log_obj();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR)) {
      sub_100065FCC();
    }
    return;
  }
  if (a1 <= 5)
  {
    unint64_t v7 = ne_log_obj();
    if (!os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT)) {
      return;
    }
    __int16 v14 = 0;
    int v8 = (uint8_t *)&v14;
    long long v9 = v7;
    os_log_type_t v10 = OS_LOG_TYPE_DEFAULT;
    goto LABEL_20;
  }
  uint64_t v11 = ne_log_obj();
  uint64_t v12 = v11;
  if (a1 == 6)
  {
    if (!os_log_type_enabled(v11, OS_LOG_TYPE_INFO)) {
      return;
    }
    __int16 v13 = 0;
    int v8 = (uint8_t *)&v13;
    long long v9 = v12;
    os_log_type_t v10 = OS_LOG_TYPE_INFO;
LABEL_20:
    _os_log_impl((void *)&_mh_execute_header, v9, v10, "(null)", v8, 2u);
    return;
  }
  if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG)) {
    sub_100066000();
  }
}

void sub_100036F44(int a1, uint64_t a2)
{
  if (a2)
  {
    for (uint64_t i = *(void *)(a2 + 32); i; uint64_t i = *(void *)(i + 72))
      sub_100036F88(a1, (int *)i);
  }
}

void sub_100036F88(int a1, int *a2)
{
  if (!a2) {
    return;
  }
  if (dword_10008FA20)
  {
    if (a1 <= 2)
    {
      uint64_t v4 = ne_log_obj();
      if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
        sub_100066040();
      }
      goto LABEL_18;
    }
    if (a1 == 3)
    {
      int v5 = ne_log_obj();
      if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR)) {
        sub_1000660DC();
      }
      goto LABEL_18;
    }
    if (a1 <= 5)
    {
      uint64_t v6 = ne_log_obj();
      if (!os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_18;
      }
      unint64_t v7 = sub_10003E344(*a2);
      uint64_t v8 = *((void *)a2 + 1);
      uint64_t v9 = bswap32(a2[6]);
      uint64_t v10 = bswap32(a2[7]);
      uint64_t v11 = sub_10003E80C(4, a2[4]);
      unsigned int v13 = a2[12];
      unsigned int v12 = a2[13];
      int v26 = 136316674;
      uint64_t v27 = v7;
      __int16 v28 = 1024;
      int v29 = v8;
      __int16 v30 = 2048;
      uint64_t v31 = v9;
      __int16 v32 = 2048;
      uint64_t v33 = v10;
      __int16 v34 = 2080;
      int v35 = v11;
      __int16 v36 = 1024;
      unsigned int v37 = v12;
      __int16 v38 = 1024;
      unsigned int v39 = v13;
      __int16 v14 = v6;
      os_log_type_t v15 = OS_LOG_TYPE_DEFAULT;
      goto LABEL_15;
    }
    int v16 = ne_log_obj();
    int v17 = v16;
    if (a1 != 6)
    {
      if (os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG)) {
        sub_100066178();
      }
      goto LABEL_18;
    }
    if (os_log_type_enabled(v16, OS_LOG_TYPE_INFO))
    {
      uint64_t v18 = sub_10003E344(*a2);
      uint64_t v19 = *((void *)a2 + 1);
      uint64_t v20 = bswap32(a2[6]);
      uint64_t v21 = bswap32(a2[7]);
      int v22 = sub_10003E80C(4, a2[4]);
      unsigned int v24 = a2[12];
      unsigned int v23 = a2[13];
      int v26 = 136316674;
      uint64_t v27 = v18;
      __int16 v28 = 1024;
      int v29 = v19;
      __int16 v30 = 2048;
      uint64_t v31 = v20;
      __int16 v32 = 2048;
      uint64_t v33 = v21;
      __int16 v34 = 2080;
      int v35 = v22;
      __int16 v36 = 1024;
      unsigned int v37 = v23;
      __int16 v38 = 1024;
      unsigned int v39 = v24;
      __int16 v14 = v17;
      os_log_type_t v15 = OS_LOG_TYPE_INFO;
LABEL_15:
      _os_log_impl((void *)&_mh_execute_header, v14, v15, " (proto_id=%s spisize=%d spi=%08lx spi_p=%08lx encmode=%s reqid=%d:%d)\n", (uint8_t *)&v26, 0x3Cu);
    }
  }
LABEL_18:
  for (uint64_t i = *((void *)a2 + 8); i; uint64_t i = *(void *)(i + 16))
    sub_100037210(a1, *a2, (unsigned int *)i);
}

void sub_100037210(int a1, uint64_t a2, unsigned int *a3)
{
  if (!a3) {
    return;
  }
  if (a2 == 4)
  {
    if (!dword_10008FA20) {
      return;
    }
    if (a1 <= 2)
    {
      unint64_t v7 = ne_log_obj();
      if (os_log_type_enabled(v7, OS_LOG_TYPE_FAULT)) {
        sub_100066690((uint64_t)a3);
      }
      return;
    }
    if (a1 == 3)
    {
      uint64_t v10 = ne_log_obj();
      if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR)) {
        sub_100066710((uint64_t)a3);
      }
      return;
    }
    if (a1 > 5)
    {
      uint64_t v33 = ne_log_obj();
      __int16 v34 = v33;
      if (a1 != 6)
      {
        if (os_log_type_enabled(v33, OS_LOG_TYPE_DEBUG)) {
          sub_100066790((uint64_t)a3);
        }
        return;
      }
      if (!os_log_type_enabled(v33, OS_LOG_TYPE_INFO)) {
        return;
      }
      int v35 = sub_10003E580(4, a3[1]);
      int v48 = 136315138;
      int v49 = v35;
      int v22 = "  (trns_id=%s)\n";
      unsigned int v23 = v34;
      os_log_type_t v24 = OS_LOG_TYPE_INFO;
    }
    else
    {
      uint64_t v20 = ne_log_obj();
      if (!os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT)) {
        return;
      }
      uint64_t v21 = sub_10003E580(4, a3[1]);
      int v48 = 136315138;
      int v49 = v21;
      int v22 = "  (trns_id=%s)\n";
      unsigned int v23 = v20;
      os_log_type_t v24 = OS_LOG_TYPE_DEFAULT;
    }
    uint32_t v36 = 12;
LABEL_61:
    _os_log_impl((void *)&_mh_execute_header, v23, v24, v22, (uint8_t *)&v48, v36);
    return;
  }
  if (a2 == 3)
  {
    if (!dword_10008FA20) {
      return;
    }
    if (a1 <= 2)
    {
      uint64_t v8 = ne_log_obj();
      if (os_log_type_enabled(v8, OS_LOG_TYPE_FAULT)) {
        sub_1000664F8();
      }
      return;
    }
    if (a1 == 3)
    {
      uint64_t v11 = ne_log_obj();
      if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR)) {
        sub_100066580();
      }
      return;
    }
    if (a1 > 5)
    {
      unsigned int v37 = ne_log_obj();
      __int16 v38 = v37;
      if (a1 != 6)
      {
        if (os_log_type_enabled(v37, OS_LOG_TYPE_DEBUG)) {
          sub_100066608();
        }
        return;
      }
      if (!os_log_type_enabled(v37, OS_LOG_TYPE_INFO)) {
        return;
      }
      unsigned int v39 = sub_10003E580(3, a3[1]);
      unsigned int v40 = a3[2];
      int v41 = sub_10003E80C(5, a3[3]);
      int v48 = 136315650;
      int v49 = v39;
      __int16 v50 = 1024;
      LODWORD(v51[0]) = v40;
      WORD2(v51[0]) = 2080;
      *(void *)((char *)v51 + 6) = v41;
      int v22 = "  (trns_id=%s encklen=%d authtype=%s)\n";
      unsigned int v23 = v38;
      os_log_type_t v24 = OS_LOG_TYPE_INFO;
    }
    else
    {
      uint64_t v25 = ne_log_obj();
      if (!os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT)) {
        return;
      }
      int v26 = sub_10003E580(3, a3[1]);
      unsigned int v27 = a3[2];
      __int16 v28 = sub_10003E80C(5, a3[3]);
      int v48 = 136315650;
      int v49 = v26;
      __int16 v50 = 1024;
      LODWORD(v51[0]) = v27;
      WORD2(v51[0]) = 2080;
      *(void *)((char *)v51 + 6) = v28;
      int v22 = "  (trns_id=%s encklen=%d authtype=%s)\n";
      unsigned int v23 = v25;
      os_log_type_t v24 = OS_LOG_TYPE_DEFAULT;
    }
    uint32_t v36 = 28;
    goto LABEL_61;
  }
  if (a2 != 2)
  {
    if (!dword_10008FA20) {
      return;
    }
    if (a1 <= 2)
    {
      uint64_t v9 = ne_log_obj();
      if (os_log_type_enabled(v9, OS_LOG_TYPE_FAULT)) {
        sub_100066214(a2, v9);
      }
      return;
    }
    if (a1 == 3)
    {
      unsigned int v13 = ne_log_obj();
      if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR)) {
        sub_10006628C(a2, v13, v14, v15, v16, v17, v18, v19);
      }
      return;
    }
    if (a1 > 5)
    {
      __int16 v46 = ne_log_obj();
      CFStringRef v47 = v46;
      if (a1 != 6)
      {
        if (os_log_type_enabled(v46, OS_LOG_TYPE_DEBUG)) {
          sub_1000662F8(a2, v47);
        }
        return;
      }
      if (!os_log_type_enabled(v46, OS_LOG_TYPE_INFO)) {
        return;
      }
      int v48 = 67109120;
      LODWORD(v49) = a2;
      int v22 = "(unknown proto_id %d)\n";
      unsigned int v23 = v47;
      os_log_type_t v24 = OS_LOG_TYPE_INFO;
    }
    else
    {
      __int16 v32 = ne_log_obj();
      if (!os_log_type_enabled(v32, OS_LOG_TYPE_DEFAULT)) {
        return;
      }
      int v48 = 67109120;
      LODWORD(v49) = a2;
      int v22 = "(unknown proto_id %d)\n";
      unsigned int v23 = v32;
      os_log_type_t v24 = OS_LOG_TYPE_DEFAULT;
    }
    uint32_t v36 = 8;
    goto LABEL_61;
  }
  if (!dword_10008FA20) {
    return;
  }
  if (a1 <= 2)
  {
    uint64_t v6 = ne_log_obj();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_FAULT)) {
      sub_100066370();
    }
    return;
  }
  if (a1 == 3)
  {
    unsigned int v12 = ne_log_obj();
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR)) {
      sub_1000663F8();
    }
    return;
  }
  if (a1 <= 5)
  {
    int v29 = ne_log_obj();
    if (!os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT)) {
      return;
    }
    __int16 v30 = sub_10003E580(2, a3[1]);
    uint64_t v31 = sub_10003E80C(5, a3[3]);
    int v48 = 136315394;
    int v49 = v30;
    __int16 v50 = 2080;
    v51[0] = v31;
    int v22 = "  (trns_id=%s authtype=%s)\n";
    unsigned int v23 = v29;
    os_log_type_t v24 = OS_LOG_TYPE_DEFAULT;
LABEL_56:
    uint32_t v36 = 22;
    goto LABEL_61;
  }
  __int16 v42 = ne_log_obj();
  int v43 = v42;
  if (a1 == 6)
  {
    if (!os_log_type_enabled(v42, OS_LOG_TYPE_INFO)) {
      return;
    }
    __int16 v44 = sub_10003E580(2, a3[1]);
    int v45 = sub_10003E80C(5, a3[3]);
    int v48 = 136315394;
    int v49 = v44;
    __int16 v50 = 2080;
    v51[0] = v45;
    int v22 = "  (trns_id=%s authtype=%s)\n";
    unsigned int v23 = v43;
    os_log_type_t v24 = OS_LOG_TYPE_INFO;
    goto LABEL_56;
  }
  if (os_log_type_enabled(v42, OS_LOG_TYPE_DEBUG)) {
    sub_100066478();
  }
}

void sub_1000377C8(uint64_t a1, uint64_t a2, int a3)
{
  memset(v27, 32, 20);
  if (a3 <= 19) {
    *((unsigned char *)v27 + a3) = 0;
  }
  if (dword_10008FA20)
  {
    if ((int)a1 <= 2)
    {
      uint64_t v6 = ne_log_obj();
      if (os_log_type_enabled(v6, OS_LOG_TYPE_FAULT)) {
        sub_100066810();
      }
      goto LABEL_19;
    }
    if (a1 == 3)
    {
      unint64_t v7 = ne_log_obj();
      if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR)) {
        sub_10006688C();
      }
      goto LABEL_19;
    }
    if (a1 <= 5)
    {
      uint64_t v8 = ne_log_obj();
      if (!os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_19;
      }
      uint64_t v9 = *(void *)(a2 + 16);
      uint64_t v10 = *(void *)(a2 + 24);
      int v19 = 136315906;
      uint64_t v20 = v27;
      __int16 v21 = 2048;
      uint64_t v22 = a2;
      __int16 v23 = 2048;
      uint64_t v24 = v9;
      __int16 v25 = 2048;
      uint64_t v26 = v10;
      uint64_t v11 = v8;
      os_log_type_t v12 = OS_LOG_TYPE_DEFAULT;
LABEL_16:
      _os_log_impl((void *)&_mh_execute_header, v11, v12, "%s%p: next=%p tnext=%p\n", (uint8_t *)&v19, 0x2Au);
      goto LABEL_19;
    }
    unsigned int v13 = ne_log_obj();
    uint64_t v14 = v13;
    if (a1 == 6)
    {
      if (!os_log_type_enabled(v13, OS_LOG_TYPE_INFO)) {
        goto LABEL_19;
      }
      uint64_t v15 = *(void *)(a2 + 16);
      uint64_t v16 = *(void *)(a2 + 24);
      int v19 = 136315906;
      uint64_t v20 = v27;
      __int16 v21 = 2048;
      uint64_t v22 = a2;
      __int16 v23 = 2048;
      uint64_t v24 = v15;
      __int16 v25 = 2048;
      uint64_t v26 = v16;
      uint64_t v11 = v14;
      os_log_type_t v12 = OS_LOG_TYPE_INFO;
      goto LABEL_16;
    }
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG)) {
      sub_100066908();
    }
  }
LABEL_19:
  uint64_t v17 = *(void *)(a2 + 16);
  if (v17) {
    sub_1000377C8(a1, v17, (a3 + 1));
  }
  uint64_t v18 = *(void *)(a2 + 24);
  if (v18) {
    sub_1000377C8(a1, v18, (a3 + 1));
  }
}

void sub_1000379EC(uint64_t a1, uint64_t a2)
{
}

uint64_t sub_1000379F4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v6 = 1;
  unint64_t v7 = (uint64_t *)malloc_type_calloc(1uLL, 0x30uLL, 0x10200401AD049D5uLL);
  if (!v7)
  {
    if (dword_10008FA20)
    {
      unsigned int v13 = ne_log_obj();
      if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR)) {
        sub_100065894();
      }
    }
    return 0xFFFFFFFFLL;
  }
  uint64_t v8 = v7;
  *(_DWORD *)unint64_t v7 = 1;
  uint64_t v9 = *(void *)(a1 + 112);
  v7[1] = *(void *)(v9 + 24);
  v7[2] = *(void *)(v9 + 32);
  if (!*(_DWORD *)(qword_10008F848 + 312))
  {
    uint64_t v10 = (uint64_t *)(a2 + 296);
    do
    {
      uint64_t v10 = (uint64_t *)*v10;
      if (!v10)
      {
        int v6 = 1;
        goto LABEL_13;
      }
    }
    while (*((unsigned char *)v10 + 266) != 2);
    int v11 = sub_10002F218(2u);
    int v6 = v11;
    uint64_t v12 = *(void *)(a1 + 256);
    if (v12 && (*(unsigned char *)(v12 + 96) & 6) != 0) {
      int v6 = v11 + *(unsigned __int16 *)(*(void *)(v12 + 88) + 12);
    }
  }
LABEL_13:
  uint64_t v14 = *(uint64_t **)(a2 + 296);
  if (v14)
  {
    while (1)
    {
      uint64_t v15 = malloc_type_calloc(1uLL, 0x50uLL, 0x1020040BE967AE7uLL);
      if (!v15) {
        break;
      }
      uint64_t v16 = v15;
      int v17 = sub_10000EFF0(*((unsigned __int16 *)v14 + 132));
      *(_DWORD *)uint64_t v16 = v17;
      if (v17 == 4) {
        uint64_t v18 = 2;
      }
      else {
        uint64_t v18 = 4;
      }
      v16[1] = v18;
      if (*(_DWORD *)(qword_10008F848 + 312))
      {
        int v19 = sub_10002F218(*((unsigned __int8 *)v14 + 266));
        int v6 = v19;
        *((_DWORD *)v16 + 4) = v19;
        uint64_t v20 = *(void *)(a1 + 256);
        if (v20 && (*(unsigned char *)(v20 + 96) & 6) != 0) {
          *((_DWORD *)v16 + 4) = v19 + *(unsigned __int16 *)(*(void *)(v20 + 88) + 12);
        }
      }
      else
      {
        *((_DWORD *)v16 + 4) = v6;
      }
      int v21 = *((_DWORD *)v14 + 67);
      if (*(unsigned char *)(a1 + 60)) {
        *((_DWORD *)v16 + 13) = v21;
      }
      else {
        *((_DWORD *)v16 + 12) = v21;
      }
      if ((sub_100036628((uint64_t)v16, *(void **)(a1 + 112), *(unsigned __int8 *)(a1 + 61)) & 0x80000000) != 0)
      {
        if (dword_10008FA20)
        {
          __int16 v34 = ne_log_obj();
          if (os_log_type_enabled(v34, OS_LOG_TYPE_ERROR)) {
            sub_100066984();
          }
        }
        free(v16);
        goto LABEL_56;
      }
      v16[9] = v8[4];
      v8[4] = (uint64_t)v16;
      uint64_t v14 = (uint64_t *)*v14;
      if (!v14) {
        goto LABEL_28;
      }
    }
    if (dword_10008FA20)
    {
      uint64_t v33 = ne_log_obj();
      if (os_log_type_enabled(v33, OS_LOG_TYPE_ERROR)) {
        sub_1000658FC();
      }
    }
LABEL_56:
    sub_100036420(v8);
    return 0xFFFFFFFFLL;
  }
LABEL_28:
  if (a3)
  {
    uint64_t v22 = v8[4];
    __int16 v23 = *(uint64_t **)(a3 + 296);
    BOOL v24 = v23 != 0;
    BOOL v25 = v22 != 0;
    if (v23 && v22)
    {
      int v26 = *(unsigned __int8 *)(a1 + 60);
      do
      {
        int v27 = *((_DWORD *)v23 + 67);
        if (v26) {
          *(_DWORD *)(v22 + 48) = v27;
        }
        else {
          *(_DWORD *)(v22 + 52) = v27;
        }
        uint64_t v22 = *(void *)(v22 + 72);
        __int16 v23 = (uint64_t *)*v23;
        BOOL v24 = v23 != 0;
        BOOL v25 = v22 != 0;
        if (v23) {
          BOOL v28 = v22 == 0;
        }
        else {
          BOOL v28 = 1;
        }
      }
      while (!v28);
    }
    if ((v25 || v24) && dword_10008FA20 != 0)
    {
      __int16 v30 = ne_log_obj();
      if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)int v35 = 0;
        _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_DEFAULT, "There is a difference between the in/out bound policies in SPD.\n", v35, 2u);
      }
    }
  }
  *(void *)(a1 + 120) = v8;
  sub_10004BE1C(a1);
  for (uint64_t i = v8[4]; i; uint64_t i = *(void *)(i + 72))
    sub_100036F88(7, (int *)i);
  return 0;
}

uint64_t sub_100037D44(uint64_t a1)
{
  int v29 = 0;
  if (*(unsigned char *)(a1 + 61) != 16) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v2 = sub_10000A3A8(*(unint64_t **)(a1 + 224), 1u);
  if (v2)
  {
    uint64_t v3 = 0;
    uint64_t v4 = 0;
    while (1)
    {
      int v5 = (uint64_t *)v2[v3];
      if (v5)
      {
        if (v4)
        {
          sub_100036420(v4);
          int v5 = (uint64_t *)v2[v3];
        }
        uint64_t v4 = sub_100036A00(v5);
        if (!v4) {
          goto LABEL_41;
        }
        int v6 = malloc_type_calloc(1uLL, 0x30uLL, 0x10200401AD049D5uLL);
        if (!v6)
        {
          if (dword_10008FA20)
          {
            int v26 = ne_log_obj();
            if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR)) {
              sub_100065894();
            }
          }
          goto LABEL_41;
        }
        unint64_t v7 = v6;
        *(_DWORD *)int v6 = 1;
        uint64_t v8 = *(void *)(a1 + 112);
        v6[1] = *(void *)(v8 + 24);
        void v6[2] = *(void *)(v8 + 32);
        if (v4[5]) {
          BOOL v9 = dword_10008FA20 == 0;
        }
        else {
          BOOL v9 = 1;
        }
        if (!v9)
        {
          uint64_t v10 = ne_log_obj();
          if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR)) {
            sub_1000669F8(&buf, v28, v10);
          }
        }
        uint64_t v11 = v4[4];
        if (v11)
        {
          while (1)
          {
            uint64_t v12 = malloc_type_calloc(1uLL, 0x50uLL, 0x1020040BE967AE7uLL);
            if (!v12) {
              break;
            }
            unsigned int v13 = v12;
            _DWORD *v12 = *(_DWORD *)v11;
            *((void *)v12 + 1) = *(void *)(v11 + 8);
            v12[4] = *(_DWORD *)(v11 + 16);
            v12[6] = 0;
            v12[7] = *(_DWORD *)(v11 + 24);
            *((void *)v12 + 6) = 0;
            if ((sub_100036628((uint64_t)v12, *(void **)(a1 + 112), *(unsigned __int8 *)(a1 + 61)) & 0x80000000) != 0)
            {
              if (dword_10008FA20)
              {
                int v21 = ne_log_obj();
                if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR)) {
                  sub_100066984();
                }
              }
              free(v13);
              goto LABEL_40;
            }
            uint64_t v14 = v7[4];
            while (v14)
            {
              uint64_t v15 = v14;
              uint64_t v14 = *(void *)(v14 + 72);
              if (!v14)
              {
                uint64_t v16 = (void *)(v15 + 72);
                goto LABEL_23;
              }
            }
            uint64_t v16 = v7 + 4;
LABEL_23:
            void *v16 = v13;
            uint64_t v11 = *(void *)(v11 + 72);
            if (!v11) {
              goto LABEL_24;
            }
          }
          if (dword_10008FA20)
          {
            uint64_t v20 = ne_log_obj();
            if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR)) {
              sub_1000658FC();
            }
          }
LABEL_40:
          free(v7);
          goto LABEL_41;
        }
LABEL_24:
        int v17 = v29;
        if (v29)
        {
          do
          {
            uint64_t v18 = v17;
            int v17 = (uint64_t *)v17[5];
          }
          while (v17);
          int v19 = (uint64_t **)(v18 + 5);
        }
        else
        {
          int v19 = &v29;
        }
        *int v19 = v7;
      }
      if (++v3 == 256)
      {
        if (dword_10008FA20)
        {
          __int16 v23 = ne_log_obj();
          if (os_log_type_enabled(v23, OS_LOG_TYPE_DEBUG)) {
            sub_1000669B8();
          }
        }
        BOOL v24 = v29;
        if (v29)
        {
          for (uint64_t i = v29[4]; i; uint64_t i = *(void *)(i + 72))
            sub_100036F88(7, (int *)i);
        }
        *(void *)(a1 + 120) = v24;
        sub_10004BE1C(a1);
        if (v4)
        {
          sub_100036420(v4);
          uint64_t v4 = 0;
        }
        goto LABEL_46;
      }
    }
  }
  uint64_t v4 = 0;
LABEL_41:
  if (v29) {
    sub_100036420(v29);
  }
  if (v4) {
    sub_100036420(v4);
  }
  uint64_t v4 = (uint64_t *)0xFFFFFFFFLL;
  if (v2) {
LABEL_46:
  }
    sub_10000AC28(v2);
  return (uint64_t)v4;
}

uint64_t sub_100038064(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  if (!v1) {
    return 0;
  }
  while (*(_DWORD *)(v1 + 16) != 1)
  {
    uint64_t v1 = *(void *)(v1 + 72);
    if (!v1) {
      return 0;
    }
  }
  return 1;
}

__n128 sub_100038090(__n128 *a1)
{
  uint64_t v2 = malloc_type_calloc(1uLL, 0x18uLL, 0x10200403ED2C137uLL);
  if (v2)
  {
    __n128 result = *a1;
    *uint64_t v2 = *a1;
  }
  return result;
}

_OWORD *sub_1000380D8(_OWORD *result, uint64_t a2)
{
  if (a2)
  {
    uint64_t v2 = a2;
    uint64_t v3 = result + 4;
    do
    {
      __n128 result = malloc_type_calloc(1uLL, 0x18uLL, 0x10200403ED2C137uLL);
      if (!result) {
        break;
      }
      *__n128 result = *(_OWORD *)v2;
      uint64_t v4 = *v3;
      while (v4)
      {
        uint64_t v5 = v4;
        uint64_t v4 = *(void *)(v4 + 16);
        if (!v4)
        {
          int v6 = (void *)(v5 + 16);
          goto LABEL_9;
        }
      }
      int v6 = v3;
LABEL_9:
      *int v6 = result;
      uint64_t v2 = *(void *)(v2 + 16);
    }
    while (v2);
  }
  return result;
}

void *sub_100038158(void *result, uint64_t a2, int a3)
{
  if (a2)
  {
    uint64_t v4 = a2;
    uint64_t v5 = result + 4;
    do
    {
      __n128 result = malloc_type_calloc(1uLL, 0x50uLL, 0x1020040BE967AE7uLL);
      if (!result) {
        break;
      }
      int v6 = result;
      *(_DWORD *)__n128 result = *(_DWORD *)v4;
      result[1] = *(void *)(v4 + 8);
      result[2] = *(void *)(v4 + 16);
      if (!a3)
      {
        result[3] = *(void *)(v4 + 24);
        result[6] = *(void *)(v4 + 48);
      }
      __n128 result = sub_1000380D8(result, *(void *)(v4 + 64));
      uint64_t v7 = *v5;
      while (v7)
      {
        uint64_t v8 = v7;
        uint64_t v7 = *(void *)(v7 + 72);
        if (!v7)
        {
          BOOL v9 = (void *)(v8 + 72);
          goto LABEL_11;
        }
      }
      BOOL v9 = v5;
LABEL_11:
      void *v9 = v6;
      uint64_t v4 = *(void *)(v4 + 72);
    }
    while (v4);
  }
  return result;
}

uint64_t sub_100038218(uint64_t result, int a2)
{
  uint64_t v9 = 0;
  if (result)
  {
    uint64_t v3 = result;
    do
    {
      uint64_t v4 = malloc_type_calloc(1uLL, 0x30uLL, 0x10200401AD049D5uLL);
      if (!v4) {
        break;
      }
      uint64_t v5 = v4;
      *(_DWORD *)uint64_t v4 = *(_DWORD *)v3;
      v4[1] = *(void *)(v3 + 8);
      v4[2] = *(void *)(v3 + 16);
      *((_DWORD *)v4 + 6) = *(_DWORD *)(v3 + 24);
      sub_100038158(v4, *(void *)(v3 + 32), a2);
      uint64_t v6 = v9;
      if (v9)
      {
        do
        {
          uint64_t v7 = v6;
          uint64_t v6 = *(void *)(v6 + 40);
        }
        while (v6);
        uint64_t v8 = (uint64_t *)(v7 + 40);
      }
      else
      {
        uint64_t v8 = &v9;
      }
      *uint64_t v8 = (uint64_t)v5;
      uint64_t v3 = *(void *)(v3 + 40);
    }
    while (v3);
    return v9;
  }
  return result;
}

char *sub_100038380()
{
  uint64_t v2 = *(unsigned int *)(v0 + 16);
  return sub_10003E80C(4, v2);
}

void sub_1000383AC(uint64_t a1@<X8>)
{
  *(void *)(v1 - 8) = a1;
}

void sub_1000383CC(void *a1, uint64_t a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_error_impl(a1, v9, OS_LOG_TYPE_ERROR, a4, &a9, 0x16u);
}

char *sub_1000383EC()
{
  uint64_t v2 = *(unsigned int *)(v0 + 12);
  return sub_10003E80C(5, v2);
}

char *sub_100038408()
{
  uint64_t v2 = *(unsigned int *)(v0 + 12);
  return sub_10003E80C(5, v2);
}

char *sub_100038424(uint64_t a1)
{
  uint64_t v2 = *(unsigned int *)(a1 + 4);
  return sub_10003E580(2, v2);
}

char *sub_100038440(uint64_t a1)
{
  uint64_t v2 = *(unsigned int *)(a1 + 4);
  return sub_10003E580(4, v2);
}

void sub_10003845C(uint64_t a1@<X8>)
{
  *(void *)(v1 - 8) = a1;
}

char *sub_10003846C(uint64_t a1)
{
  uint64_t v2 = *(unsigned int *)(a1 + 4);
  return sub_10003E580(3, v2);
}

void sub_100038498(void *a1, uint64_t a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_debug_impl(a1, v9, OS_LOG_TYPE_DEBUG, a4, &a9, 0x16u);
}

_DWORD *sub_1000384B8(sockaddr *a1, int a2)
{
  p_int sa_family = &a1->sa_family;
  int sa_family = a1->sa_family;
  if (a1->sa_family)
  {
    if (sa_family != 30 && sa_family != 2)
    {
      if (dword_10008FA20)
      {
        __int16 v23 = ne_log_obj();
        if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR)) {
          sub_100066A38(p_sa_family, v23);
        }
      }
      return 0;
    }
    int v7 = *(unsigned __int16 *)a1->sa_data;
    BOOL v8 = *(_WORD *)a1->sa_data == 0;
    if (getnameinfo(a1, a1->sa_len, v32, 0x401u, v31, 0x20u, 10))
    {
      __strlcpy_chk();
      __strlcpy_chk();
    }
    uint64_t v9 = "[";
    uint64_t v10 = (const char *)&unk_100081F6D;
    if (v7)
    {
      uint64_t v11 = v31;
    }
    else
    {
      uint64_t v9 = (const char *)&unk_100081F6D;
      uint64_t v11 = (char *)&unk_100081F6D;
    }
    if (v7) {
      uint64_t v10 = "]";
    }
    snprintf(__str, 0x42BuLL, "%s%s%s%s", v32, v9, v11, v10);
  }
  else
  {
    strcpy(__str, "anonymous");
    BOOL v8 = 1;
  }
  uint64_t v12 = (_DWORD *)qword_10008CE28;
  if (!qword_10008CE28)
  {
LABEL_73:
    if (dword_10008FA20)
    {
      int v29 = ne_log_obj();
      if (os_log_type_enabled(v29, OS_LOG_TYPE_DEBUG)) {
        sub_100066AB4(v29);
      }
    }
    return 0;
  }
  unsigned int v13 = 0;
  int v14 = 0;
  uint64_t v15 = 0;
  uint64_t v16 = 0;
  int v17 = 0;
  do
  {
    if (!*p_sa_family && !*(unsigned char *)(*(void *)v12 + 1))
    {
      if (!dword_10008FA20) {
        return v12;
      }
      BOOL v24 = ne_log_obj();
      if (!os_log_type_enabled(v24, OS_LOG_TYPE_DEBUG)) {
        return v12;
      }
      goto LABEL_53;
    }
    int v18 = v12[2];
    unint64_t v19 = *(void *)v12;
    if (v18)
    {
      if (v8)
      {
        if (sub_10003B96C((unint64_t)a1, v19, v18)) {
          goto LABEL_40;
        }
      }
      else if (sub_10003BBAC((unint64_t)a1, v19, v18))
      {
        if (sub_10003B96C((unint64_t)a1, *(void *)v12, v12[2])) {
          goto LABEL_40;
        }
        int v20 = v12[2];
        BOOL v21 = v20 <= v14;
        if (v20 >= v14) {
          uint64_t v15 = v12;
        }
        goto LABEL_34;
      }
      int v20 = v12[2];
      BOOL v21 = v20 <= v14;
      if (v20 >= v14) {
        uint64_t v16 = v12;
      }
LABEL_34:
      if (!v21) {
        int v14 = v20;
      }
      goto LABEL_40;
    }
    if (!v8)
    {
      if (sub_10003BB04((unint64_t)a1, v19))
      {
        if (!sub_10003B8E4((unint64_t)a1, *(void *)v12)) {
          int v17 = v12;
        }
        goto LABEL_40;
      }
LABEL_54:
      if (!dword_10008FA20) {
        return v12;
      }
      BOOL v25 = ne_log_obj();
      if (!os_log_type_enabled(v25, OS_LOG_TYPE_DEBUG)) {
        return v12;
      }
LABEL_53:
      sub_100066AF8();
      return v12;
    }
    if (!sub_10003B8E4((unint64_t)a1, v19)) {
      goto LABEL_54;
    }
LABEL_40:
    if (!*(unsigned char *)(*(void *)v12 + 1)) {
      unsigned int v13 = v12;
    }
    uint64_t v12 = (_DWORD *)*((void *)v12 + 38);
  }
  while (v12);
  if (v17)
  {
    if (dword_10008FA20)
    {
      uint64_t v22 = ne_log_obj();
      if (os_log_type_enabled(v22, OS_LOG_TYPE_DEBUG)) {
        sub_100066AF8();
      }
    }
    return v17;
  }
  if (v16)
  {
    if (dword_10008FA20)
    {
      int v26 = ne_log_obj();
      if (os_log_type_enabled(v26, OS_LOG_TYPE_DEBUG)) {
        sub_100066AF8();
      }
    }
    return v16;
  }
  if (v15)
  {
    if (dword_10008FA20)
    {
      int v27 = ne_log_obj();
      if (os_log_type_enabled(v27, OS_LOG_TYPE_DEBUG)) {
        sub_100066AF8();
      }
    }
    return v15;
  }
  if (!a2 || !v13) {
    goto LABEL_73;
  }
  if (dword_10008FA20)
  {
    BOOL v28 = ne_log_obj();
    if (os_log_type_enabled(v28, OS_LOG_TYPE_DEBUG)) {
      sub_100066B60();
    }
  }
  return v13;
}

uint64_t sub_1000388C8(uint64_t result)
{
  uint64_t v1 = (void *)qword_10008CE28;
  if (!qword_10008CE28) {
    return 1;
  }
  if (result)
  {
    while (!*(unsigned char *)(*v1 + 1))
    {
      uint64_t v1 = (void *)v1[38];
      if (!v1) {
        return 1;
      }
    }
    return 0;
  }
  return result;
}

_DWORD *sub_1000388FC(sockaddr *a1)
{
  __n128 result = sub_1000384B8(a1, 1);
  if (!result)
  {
    if (a1->sa_family != 30) {
      return 0;
    }
    int v6 = 0;
    uint64_t v5 = 0;
    int v4 = 528;
    long long v3 = 0uLL;
    if (!sub_1000490C4(&v3)) {
      return 0;
    }
    nw_nat64_extract_v4();
    __n128 result = (_DWORD *)sub_1000388FC(&v4);
    if (!result) {
      return 0;
    }
  }
  return result;
}

_DWORD *sub_1000389AC()
{
  uint64_t v0 = malloc_type_calloc(1uLL, 0x140uLL, 0x10A004000D84CD7uLL);
  uint64_t v1 = v0;
  if (v0)
  {
    v0[71] = 0;
    *((void *)v0 + 31) = 0;
    *((void *)v0 + 3) = 0x100000001;
    *((void *)v0 + 36) = 0x1000000001;
    v0[8] = 0;
    *((void *)v0 + 7) = sub_1000060AC();
    *(_OWORD *)(v1 + 34) = xmmword_10006E6B0;
    *(_OWORD *)(v1 + 26) = xmmword_10006E6C0;
    *((void *)v1 + 15) = 0x100000001;
    *(_OWORD *)(v1 + 38) = xmmword_10006E6D0;
    *((void *)v1 + 25) = *(void *)(qword_10008F848 + 268);
    *(_OWORD *)(v1 + 42) = xmmword_10006E6E0;
    v1[46] = 1;
    *((void *)v1 + 5) = 0;
    *((void *)v1 + 6) = 0;
    *((_OWORD *)v1 + 13) = xmmword_10006E6F0;
    *((void *)v1 + 28) = 1;
    v1[60] = 0;
    *((void *)v1 + 34) = 0;
    v1[70] = 1;
  }
  return v1;
}

void *sub_100038A9C(sockaddr *a1)
{
  uint64_t v2 = sub_1000384B8(a1, 0);
  if (v2)
  {
    return sub_100038B1C((void **)v2);
  }
  else
  {
    if (dword_10008FA20)
    {
      int v4 = ne_log_obj();
      if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR)) {
        sub_100066BC8(a1, v4);
      }
    }
    return 0;
  }
}

void *sub_100038B1C(void **a1)
{
  uint64_t v2 = malloc_type_calloc(1uLL, 0x140uLL, 0x10A004000D84CD7uLL);
  long long v3 = v2;
  if (v2)
  {
    memcpy(v2, a1, 0x140uLL);
    *long long v3 = 0;
    v3[37] = 0;
    v3[9] = 0;
    v3[31] = 0;
    *(void *)((char *)v3 + 284) = &_mh_execute_header;
    v3[11] = 0;
    v3[12] = 0;
    v3[34] = 0;
    v3[5] = 0;
    v3[6] = 0;
    uint64_t v4 = v3[2];
    if (v4) {
      v3[2] = sub_100038C9C(v4);
    }
    uint64_t v5 = sub_1000060AC();
    v3[7] = v5;
    sub_100006190(a1[7], sub_100038BD0, (uint64_t)v5);
  }
  return v3;
}

uint64_t sub_100038BD0(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = malloc_type_calloc(1uLL, 0x10uLL, 0x1020040D5A9D86FuLL);
  if (!v4) {
    return -1;
  }
  uint64_t v5 = v4;
  *(_DWORD *)uint64_t v4 = 4;
  if (sub_10000FBF0((void ***)v4 + 1, *(_DWORD *)a1, *(void *)(a1 + 8)))
  {
    free(v5);
    return -1;
  }
  *uint64_t v5 = *(_DWORD *)a1;
  sub_10000613C(a2, (uint64_t)v5);
  return 0;
}

_DWORD *sub_100038C60()
{
  __n128 result = malloc_type_calloc(1uLL, 0x10uLL, 0x1020040D5A9D86FuLL);
  if (result) {
    *__n128 result = 4;
  }
  return result;
}

void *sub_100038C9C(uint64_t a1)
{
  if (!a1) {
    return 0;
  }
  uint64_t v2 = malloc_type_malloc(0x10uLL, 0x1020040D5A9D86FuLL);
  long long v3 = v2;
  if (v2)
  {
    *(_DWORD *)uint64_t v2 = *(_DWORD *)a1;
    v2[1] = 0;
    if (*(void *)(a1 + 8)) {
      v2[1] = sub_100038C9C();
    }
  }
  return v3;
}

void sub_100038D08(void *a1)
{
  uint64_t v2 = (void **)*a1;
  if (v2) {
    free(v2);
  }
  long long v3 = (void *)a1[37];
  if (v3) {
    free(v3);
  }
  if (a1[34]) {
    sub_100047DE4((void ***)a1 + 34);
  }
  uint64_t v4 = (void *)a1[2];
  if (v4)
  {
    sub_100038E34(v4);
    a1[2] = 0;
  }
  uint64_t v5 = (void *)a1[5];
  if (v5) {
    sub_10003FA78(v5);
  }
  int v6 = (void *)a1[7];
  if (v6) {
    sub_10000621C(v6, (void (*)(void))sub_100038E74);
  }
  int v7 = (void *)a1[24];
  if (v7) {
    sub_1000294BC(v7);
  }
  BOOL v8 = (void *)a1[31];
  if (v8) {
    sub_100038EB0(v8);
  }
  uint64_t v9 = (void *)a1[33];
  if (v9)
  {
    do
    {
      uint64_t v10 = (void *)v9[2];
      uint64_t v11 = (void *)v9[3];
      if (v10)
      {
        do
        {
          uint64_t v12 = (void *)v10[12];
          unsigned int v13 = (void *)v10[6];
          if (v13) {
            free(v13);
          }
          int v14 = (void *)v10[7];
          if (v14) {
            free(v14);
          }
          free(v10);
          uint64_t v10 = v12;
        }
        while (v12);
      }
      free(v9);
      uint64_t v9 = v11;
    }
    while (v11);
  }
  uint64_t v15 = (void *)a1[11];
  if (v15) {
    sub_10003FA78(v15);
  }
  uint64_t v16 = (void *)a1[9];
  if (v16) {
    sub_10003FA78(v16);
  }
  int v17 = (void *)a1[12];
  if (v17) {
    sub_10003FA78(v17);
  }

  free(a1);
}

void sub_100038E34(void *a1)
{
  if (a1[1]) {
    sub_100038E34();
  }

  free(a1);
}

void sub_100038E74(void **a1)
{
  sub_10003FA78(a1[1]);

  free(a1);
}

void sub_100038EB0(void *a1)
{
  uint64_t v2 = (void *)a1[8];
  if (v2) {
    sub_1000294BC(v2);
  }
  if (a1[10]) {
    sub_100038EB0();
  }

  free(a1);
}

uint64_t sub_100038EFC(uint64_t result)
{
  uint64_t v1 = qword_10008CE28;
  *(void *)(result + 304) = qword_10008CE28;
  qword_10008CE28 = result;
  if (v1) {
    uint64_t v2 = (uint64_t *)(v1 + 312);
  }
  else {
    uint64_t v2 = &qword_10008CE30;
  }
  *uint64_t v2 = result + 304;
  *(void *)(result + 312) = &qword_10008CE28;
  *(_DWORD *)(result + 284) = 1;
  return result;
}

uint64_t sub_100038F38(uint64_t result)
{
  if (*(_DWORD *)(result + 284))
  {
    uint64_t v1 = *(void *)(result + 304);
    uint64_t v2 = *(void **)(result + 312);
    if (v1)
    {
      *(void *)(v1 + 312) = v2;
      uint64_t v2 = *(void **)(result + 312);
    }
    else
    {
      qword_10008CE30 = *(void *)(result + 312);
    }
    *uint64_t v2 = v1;
  }
  *(_DWORD *)(result + 284) = 0;
  return result;
}

uint64_t sub_100038F68(uint64_t result)
{
  return result;
}

void sub_100038F78(void *a1)
{
  int v1 = *((_DWORD *)a1 + 72);
  BOOL v2 = __OFSUB__(v1--, 1);
  *((_DWORD *)a1 + 72) = v1;
  if ((v1 < 0) ^ v2 | (v1 == 0))
  {
    if (*((_DWORD *)a1 + 71))
    {
      uint64_t v3 = a1[38];
      uint64_t v4 = (void *)a1[39];
      if (v3)
      {
        *(void *)(v3 + 312) = v4;
        uint64_t v4 = (void *)a1[39];
      }
      else
      {
        qword_10008CE30 = a1[39];
      }
      *uint64_t v4 = v3;
    }
    *((_DWORD *)a1 + 71) = 0;
    sub_100038D08(a1);
  }
}

uint64_t sub_100038FBC()
{
  uint64_t result = qword_10008CE28;
  if (qword_10008CE28)
  {
    do
    {
      uint64_t v1 = *(void *)(result + 304);
      if (*(_DWORD *)(result + 284))
      {
        BOOL v2 = *(uint64_t **)(result + 312);
        if (v1)
        {
          *(void *)(v1 + 312) = v2;
          BOOL v2 = *(uint64_t **)(result + 312);
        }
        else
        {
          qword_10008CE30 = *(void *)(result + 312);
        }
        *BOOL v2 = v1;
      }
      *(_DWORD *)(result + 284) = 0;
      int v3 = *(_DWORD *)(result + 288);
      BOOL v4 = __OFSUB__(v3--, 1);
      *(_DWORD *)(result + ++*(_DWORD *)(result + 288) = v3;
      if ((v3 < 0) ^ v4 | (v3 == 0)) {
        sub_100038D08((void *)result);
      }
      uint64_t result = v1;
    }
    while (v1);
  }
  return result;
}

void sub_100039030()
{
  qword_10008CE28 = 0;
  qword_10008CE30 = (uint64_t)&qword_10008CE28;
}

uint64_t sub_100039040(uint64_t a1, int a2)
{
  for (uint64_t result = *(void *)(a1 + 16); result; uint64_t result = *(void *)(result + 8))
  {
    if (*(_DWORD *)result == a2) {
      break;
    }
  }
  return result;
}

_DWORD *sub_100039060()
{
  uint64_t result = malloc_type_calloc(1uLL, 0x60uLL, 0x1020040CE8B1C45uLL);
  if (result)
  {
    result[14] = -1;
    *((void *)result + 10) = 0;
    *((void *)result + 11) = 0;
  }
  return result;
}

uint64_t sub_1000390A0(uint64_t result, uint64_t a2)
{
  *(void *)(result + 88) = a2;
  uint64_t v4 = *(void *)(a2 + 248);
  BOOL v2 = (void *)(a2 + 248);
  uint64_t v3 = v4;
  if (v4)
  {
    do
    {
      uint64_t v5 = v3;
      uint64_t v3 = *(void *)(v3 + 80);
    }
    while (v3);
    BOOL v2 = (void *)(v5 + 80);
  }
  *BOOL v2 = result;
  return result;
}

uint64_t sub_1000390C4(uint64_t (*a1)(uint64_t, uint64_t), uint64_t a2)
{
  uint64_t v2 = **(void **)(qword_10008CE30 + 8);
  if (!v2) {
    return 0;
  }
  while (1)
  {
    uint64_t result = a1(v2, a2);
    if (result) {
      break;
    }
    uint64_t v2 = **(void **)(*(void *)(v2 + 312) + 8);
    if (!v2) {
      return 0;
    }
  }
  return result;
}

void sub_100039128()
{
  for (uint64_t i = qword_10008CE30; ; uint64_t i = *(void *)(v2 + 312))
  {
    uint64_t v1 = *(uint64_t **)(i + 8);
    uint64_t v2 = *v1;
    if (!*v1 || sub_10003916C(*v1)) {
      break;
    }
  }
}

uint64_t sub_10003916C(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 16);
  uint64_t v3 = *(void *)(a1 + 248);
  int v4 = *(_DWORD *)(a1 + 8);
  uint64_t v5 = *(const sockaddr **)a1;
  if (v4) {
    int v6 = sub_10003CD04(v5, v4);
  }
  else {
    int v6 = sub_10003CAE4(v5);
  }
  int v7 = snprintf(__str, 0x400uLL, "remote %s", (const char *)v6);
  BOOL v8 = *(const sockaddr ***)(a1 + 256);
  if (v8)
  {
    uint64_t v9 = &__str[v7];
    size_t v10 = 1024 - v7;
    uint64_t v11 = sub_10003CAE4(*v8);
    snprintf(v9, v10, " inherit %s", (const char *)v11);
  }
  if (dword_10008FA20)
  {
    uint64_t v12 = ne_log_obj();
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)uint8_t buf = 136315138;
      *(void *)__int16 v84 = __str;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "%s {\n", buf, 0xCu);
    }
  }
  strcpy(__str, "\texchange_type ");
  if (v2)
  {
    unsigned int v13 = (char *)((unint64_t)__str | 0xF);
    do
    {
      int v14 = sub_10003F140(*(_DWORD *)v2);
      if (*(void *)(v2 + 8)) {
        uint64_t v15 = ", ";
      }
      else {
        uint64_t v15 = ";\n";
      }
      v13 += snprintf(v13, (char *)&v88 - v13, "%s%s", v14, v15);
      uint64_t v2 = *(void *)(v2 + 8);
    }
    while (v2);
  }
  if (dword_10008FA20)
  {
    uint64_t v16 = ne_log_obj();
    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)uint8_t buf = 136315138;
      *(void *)__int16 v84 = __str;
      _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "%s", buf, 0xCu);
    }
    if (dword_10008FA20)
    {
      int v17 = ne_log_obj();
      if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
      {
        int v18 = sub_10003F0E4(*(_DWORD *)(a1 + 24));
        *(_DWORD *)uint8_t buf = 136315138;
        *(void *)__int16 v84 = v18;
        _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "\tdoi %s;\n", buf, 0xCu);
      }
    }
  }
  unint64_t v19 = sub_10003F254(*(_DWORD *)(a1 + 32));
  int v20 = snprintf(__str, 0x400uLL, "\tmy_identifier %s", v19);
  if (*(_DWORD *)(a1 + 32) != 5)
  {
    uint64_t v27 = *(void *)(a1 + 40);
    if (v27) {
      snprintf(&__str[v20], 1024 - v20, " \"%s\"", *(const char **)(v27 + 8));
    }
    if (dword_10008FA20)
    {
      BOOL v28 = ne_log_obj();
      if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)uint8_t buf = 136315138;
        *(void *)__int16 v84 = __str;
        _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, "%s;\n", buf, 0xCu);
      }
    }
    sub_100006190(*(void **)(a1 + 56), (uint64_t (*)(void, uint64_t))sub_100039EE4, 0);
    goto LABEL_36;
  }
  if (dword_10008FA20)
  {
    BOOL v21 = ne_log_obj();
    if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)uint8_t buf = 136315138;
      *(void *)__int16 v84 = __str;
      _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "%s;\n", buf, 0xCu);
    }
  }
  int v22 = *(_DWORD *)(a1 + 108);
  if (v22)
  {
    if (v22 == 1)
    {
      if (!dword_10008FA20) {
        goto LABEL_85;
      }
      __int16 v23 = ne_log_obj();
      if (!os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_36;
      }
      *(_WORD *)uint8_t buf = 0;
      BOOL v24 = "\t/* peers certificate from payload */\n";
      BOOL v25 = v23;
      uint32_t v26 = 2;
      goto LABEL_55;
    }
    if (!dword_10008FA20) {
      goto LABEL_85;
    }
    unsigned int v40 = ne_log_obj();
    if (os_log_type_enabled(v40, OS_LOG_TYPE_DEFAULT))
    {
      int v41 = *(_DWORD *)(a1 + 108);
      *(_DWORD *)uint8_t buf = 67109120;
      *(_DWORD *)__int16 v84 = v41;
      BOOL v24 = "\tpeers_certfile *UNKNOWN* (%d)\n";
      BOOL v25 = v40;
      uint32_t v26 = 8;
LABEL_55:
      _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, v24, buf, v26);
    }
  }
LABEL_36:
  if (dword_10008FA20)
  {
    int v29 = ne_log_obj();
    if (os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
    {
      __int16 v30 = sub_10003F2B8(*(_DWORD *)(a1 + 116));
      *(_DWORD *)uint8_t buf = 136315138;
      *(void *)__int16 v84 = v30;
      _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEFAULT, "\tsend_cert %s;\n", buf, 0xCu);
    }
    if (dword_10008FA20)
    {
      uint64_t v31 = ne_log_obj();
      if (os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT))
      {
        __int16 v32 = sub_10003F2B8(*(_DWORD *)(a1 + 120));
        *(_DWORD *)uint8_t buf = 136315138;
        *(void *)__int16 v84 = v32;
        _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_DEFAULT, "\tsend_cr %s;\n", buf, 0xCu);
      }
      if (dword_10008FA20)
      {
        uint64_t v33 = ne_log_obj();
        if (os_log_type_enabled(v33, OS_LOG_TYPE_DEFAULT))
        {
          __int16 v34 = sub_10003F2B8(*(_DWORD *)(a1 + 124));
          *(_DWORD *)uint8_t buf = 136315138;
          *(void *)__int16 v84 = v34;
          _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_DEFAULT, "\tverify_cert %s;\n", buf, 0xCu);
        }
        if (dword_10008FA20)
        {
          int v35 = ne_log_obj();
          if (os_log_type_enabled(v35, OS_LOG_TYPE_DEFAULT))
          {
            uint32_t v36 = sub_10003F2B8(*(_DWORD *)(a1 + 136));
            *(_DWORD *)uint8_t buf = 136315138;
            *(void *)__int16 v84 = v36;
            _os_log_impl((void *)&_mh_execute_header, v35, OS_LOG_TYPE_DEFAULT, "\tverify_identifier %s;\n", buf, 0xCu);
          }
          if (dword_10008FA20)
          {
            unsigned int v37 = ne_log_obj();
            if (os_log_type_enabled(v37, OS_LOG_TYPE_DEFAULT))
            {
              int v38 = *(_DWORD *)(a1 + 176);
              if (v38 == 2) {
                unsigned int v39 = "force";
              }
              else {
                unsigned int v39 = sub_10003F2B8(v38);
              }
              *(_DWORD *)uint8_t buf = 136315138;
              *(void *)__int16 v84 = v39;
              _os_log_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_DEFAULT, "\tnat_traversal %s;\n", buf, 0xCu);
            }
            if (dword_10008FA20)
            {
              __int16 v42 = ne_log_obj();
              if (os_log_type_enabled(v42, OS_LOG_TYPE_DEFAULT))
              {
                int v43 = sub_10003F2B8(*(_DWORD *)(a1 + 180));
                *(_DWORD *)uint8_t buf = 136315138;
                *(void *)__int16 v84 = v43;
                _os_log_impl((void *)&_mh_execute_header, v42, OS_LOG_TYPE_DEFAULT, "\tnatt_multiple_user %s;\n",
                  buf,
                  0xCu);
              }
              if (dword_10008FA20)
              {
                __int16 v44 = ne_log_obj();
                if (os_log_type_enabled(v44, OS_LOG_TYPE_DEFAULT))
                {
                  int v45 = *(_DWORD *)(a1 + 140);
                  *(_DWORD *)uint8_t buf = 67109120;
                  *(_DWORD *)__int16 v84 = v45;
                  _os_log_impl((void *)&_mh_execute_header, v44, OS_LOG_TYPE_DEFAULT, "\tnonce_size %d;\n", buf, 8u);
                }
                if (dword_10008FA20)
                {
                  __int16 v46 = ne_log_obj();
                  if (os_log_type_enabled(v46, OS_LOG_TYPE_DEFAULT))
                  {
                    CFStringRef v47 = sub_10003F2B8(*(_DWORD *)(a1 + 144));
                    *(_DWORD *)uint8_t buf = 136315138;
                    *(void *)__int16 v84 = v47;
                    _os_log_impl((void *)&_mh_execute_header, v46, OS_LOG_TYPE_DEFAULT, "\tpassive %s;\n", buf, 0xCu);
                  }
                  if (dword_10008FA20)
                  {
                    int v48 = ne_log_obj();
                    if (os_log_type_enabled(v48, OS_LOG_TYPE_DEFAULT))
                    {
                      int v49 = *(_DWORD *)(a1 + 148);
                      if (v49 == 2) {
                        __int16 v50 = "force";
                      }
                      else {
                        __int16 v50 = sub_10003F2B8(v49);
                      }
                      *(_DWORD *)uint8_t buf = 136315138;
                      *(void *)__int16 v84 = v50;
                      _os_log_impl((void *)&_mh_execute_header, v48, OS_LOG_TYPE_DEFAULT, "\tike_frag %s;\n", buf, 0xCu);
                    }
                    if (dword_10008FA20)
                    {
                      uint64_t v51 = ne_log_obj();
                      if (os_log_type_enabled(v51, OS_LOG_TYPE_DEFAULT))
                      {
                        int v52 = *(_DWORD *)(a1 + 152);
                        *(_DWORD *)uint8_t buf = 67109120;
                        *(_DWORD *)__int16 v84 = v52;
                        _os_log_impl((void *)&_mh_execute_header, v51, OS_LOG_TYPE_DEFAULT, "\tesp_frag %d;\n", buf, 8u);
                      }
                      if (dword_10008FA20)
                      {
                        CFArrayRef v53 = ne_log_obj();
                        if (os_log_type_enabled(v53, OS_LOG_TYPE_DEFAULT))
                        {
                          int v54 = sub_10003F2B8(*(_DWORD *)(a1 + 168));
                          *(_DWORD *)uint8_t buf = 136315138;
                          *(void *)__int16 v84 = v54;
                          _os_log_impl((void *)&_mh_execute_header, v53, OS_LOG_TYPE_DEFAULT, "\tinitial_contact %s;\n",
                            buf,
                            0xCu);
                        }
                        if (dword_10008FA20)
                        {
                          uint64_t v55 = ne_log_obj();
                          if (os_log_type_enabled(v55, OS_LOG_TYPE_DEFAULT))
                          {
                            uint64_t v56 = sub_10003F2B8(*(_DWORD *)(a1 + 164));
                            *(_DWORD *)uint8_t buf = 136315138;
                            *(void *)__int16 v84 = v56;
                            _os_log_impl((void *)&_mh_execute_header, v55, OS_LOG_TYPE_DEFAULT, "\tgenerate_policy %s;\n",
                              buf,
                              0xCu);
                          }
                          if (dword_10008FA20)
                          {
                            CFStringRef v57 = ne_log_obj();
                            if (os_log_type_enabled(v57, OS_LOG_TYPE_DEFAULT))
                            {
                              char v58 = sub_10003F2B8(*(_DWORD *)(a1 + 160));
                              *(_DWORD *)uint8_t buf = 136315138;
                              *(void *)__int16 v84 = v58;
                              _os_log_impl((void *)&_mh_execute_header, v57, OS_LOG_TYPE_DEFAULT, "\tsupport_proxy %s;\n",
                                buf,
                                0xCu);
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
LABEL_85:
  while (v3)
  {
    if (dword_10008FA20)
    {
      int v59 = ne_log_obj();
      if (os_log_type_enabled(v59, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)uint8_t buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v59, OS_LOG_TYPE_DEFAULT, "\n", buf, 2u);
      }
      if (dword_10008FA20)
      {
        uint64_t v60 = ne_log_obj();
        if (os_log_type_enabled(v60, OS_LOG_TYPE_DEFAULT))
        {
          int v62 = *(_DWORD *)(v3 + 4);
          int v61 = *(_DWORD *)(v3 + 8);
          uint64_t v63 = sub_10003CAE4(**(const sockaddr ***)(v3 + 88));
          *(_DWORD *)uint8_t buf = 67109634;
          *(_DWORD *)__int16 v84 = v62;
          *(_WORD *)&v84[4] = 1024;
          *(_DWORD *)&v84[6] = v61;
          __int16 v85 = 2080;
          uint64_t v86 = v63;
          _os_log_impl((void *)&_mh_execute_header, v60, OS_LOG_TYPE_DEFAULT, "\t/* prop_no=%d, trns_no=%d, rmconf=%s */\n", buf, 0x18u);
        }
        if (dword_10008FA20)
        {
          uint64_t v64 = ne_log_obj();
          if (os_log_type_enabled(v64, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)uint8_t buf = 0;
            _os_log_impl((void *)&_mh_execute_header, v64, OS_LOG_TYPE_DEFAULT, "\tproposal {\n", buf, 2u);
          }
          if (dword_10008FA20)
          {
            uint64_t v65 = ne_log_obj();
            if (os_log_type_enabled(v65, OS_LOG_TYPE_DEFAULT))
            {
              uint64_t v66 = *(void *)(v3 + 16);
              *(_DWORD *)uint8_t buf = 134217984;
              *(void *)__int16 v84 = v66;
              _os_log_impl((void *)&_mh_execute_header, v65, OS_LOG_TYPE_DEFAULT, "\t\tlifetime time %lu sec;\n",
                buf,
                0xCu);
            }
            if (dword_10008FA20)
            {
              uint64_t v67 = ne_log_obj();
              if (os_log_type_enabled(v67, OS_LOG_TYPE_DEFAULT))
              {
                uint64_t v68 = *(void *)(v3 + 32);
                *(_DWORD *)uint8_t buf = 134217984;
                *(void *)__int16 v84 = v68;
                _os_log_impl((void *)&_mh_execute_header, v67, OS_LOG_TYPE_DEFAULT, "\t\tlifetime bytes %zd;\n",
                  buf,
                  0xCu);
              }
              if (dword_10008FA20)
              {
                int v69 = ne_log_obj();
                if (os_log_type_enabled(v69, OS_LOG_TYPE_DEFAULT))
                {
                  uint64_t v70 = sub_1000036D8(*(_DWORD *)(v3 + 60));
                  *(_DWORD *)uint8_t buf = 136315138;
                  *(void *)__int16 v84 = v70;
                  _os_log_impl((void *)&_mh_execute_header, v69, OS_LOG_TYPE_DEFAULT, "\t\tdh_group %s;\n", buf, 0xCu);
                }
                if (dword_10008FA20)
                {
                  long long v71 = ne_log_obj();
                  if (os_log_type_enabled(v71, OS_LOG_TYPE_DEFAULT))
                  {
                    long long v72 = sub_1000032F0(*(_DWORD *)(v3 + 40));
                    *(_DWORD *)uint8_t buf = 136315138;
                    *(void *)__int16 v84 = v72;
                    _os_log_impl((void *)&_mh_execute_header, v71, OS_LOG_TYPE_DEFAULT, "\t\tencryption_algorithm %s;\n",
                      buf,
                      0xCu);
                  }
                  if (dword_10008FA20)
                  {
                    long long v73 = ne_log_obj();
                    if (os_log_type_enabled(v73, OS_LOG_TYPE_DEFAULT))
                    {
                      long long v74 = sub_100003030(*(_DWORD *)(v3 + 52));
                      *(_DWORD *)uint8_t buf = 136315138;
                      *(void *)__int16 v84 = v74;
                      _os_log_impl((void *)&_mh_execute_header, v73, OS_LOG_TYPE_DEFAULT, "\t\thash_algorithm %s;\n",
                        buf,
                        0xCu);
                    }
                    if (dword_10008FA20)
                    {
                      long long v75 = ne_log_obj();
                      if (os_log_type_enabled(v75, OS_LOG_TYPE_DEFAULT))
                      {
                        long long v76 = sub_100003030(*(_DWORD *)(v3 + 72));
                        *(_DWORD *)uint8_t buf = 136315138;
                        *(void *)__int16 v84 = v76;
                        _os_log_impl((void *)&_mh_execute_header, v75, OS_LOG_TYPE_DEFAULT, "\t\tprf_algorithm %s;\n",
                          buf,
                          0xCu);
                      }
                      if (dword_10008FA20)
                      {
                        uint8_t v77 = ne_log_obj();
                        if (os_log_type_enabled(v77, OS_LOG_TYPE_DEFAULT))
                        {
                          long long v78 = sub_10000373C(*(_DWORD *)(v3 + 48));
                          *(_DWORD *)uint8_t buf = 136315138;
                          *(void *)__int16 v84 = v78;
                          _os_log_impl((void *)&_mh_execute_header, v77, OS_LOG_TYPE_DEFAULT, "\t\tauthentication_method %s;\n",
                            buf,
                            0xCu);
                        }
                        if (dword_10008FA20)
                        {
                          long long v79 = ne_log_obj();
                          if (os_log_type_enabled(v79, OS_LOG_TYPE_DEFAULT))
                          {
                            *(_WORD *)uint8_t buf = 0;
                            _os_log_impl((void *)&_mh_execute_header, v79, OS_LOG_TYPE_DEFAULT, "\t}\n", buf, 2u);
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    uint64_t v3 = *(void *)(v3 + 80);
  }
  if (dword_10008FA20)
  {
    long long v80 = ne_log_obj();
    if (os_log_type_enabled(v80, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint8_t buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v80, OS_LOG_TYPE_DEFAULT, "}\n", buf, 2u);
    }
    if (dword_10008FA20)
    {
      int v81 = ne_log_obj();
      if (os_log_type_enabled(v81, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)uint8_t buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v81, OS_LOG_TYPE_DEFAULT, "\n", buf, 2u);
      }
    }
  }
  return 0;
}

_DWORD *sub_100039E50(uint64_t a1)
{
  if (!a1) {
    return 0;
  }
  uint64_t v2 = malloc_type_calloc(1uLL, 0x60uLL, 0x1020040CE8B1C45uLL);
  uint64_t v3 = v2;
  if (v2)
  {
    v2[14] = -1;
    *((void *)v2 + 10) = 0;
    *((void *)v2 + 11) = 0;
    long long v4 = *(_OWORD *)(a1 + 32);
    long long v5 = *(_OWORD *)(a1 + 48);
    long long v6 = *(_OWORD *)(a1 + 64);
    *((_OWORD *)v2 + 5) = *(_OWORD *)(a1 + 80);
    long long v7 = *(_OWORD *)(a1 + 16);
    *(_OWORD *)uint64_t v2 = *(_OWORD *)a1;
    *((_OWORD *)v2 + 1) = v7;
    *((_OWORD *)v2 + 3) = v5;
    *((_OWORD *)v2 + 4) = v6;
    *((_OWORD *)v2 + 2) = v4;
    *((void *)v2 + 10) = 0;
    if (*(void *)(a1 + 64)) {
      sub_100029A30(*(_DWORD *)(a1 + 60), (uint64_t)(v2 + 16));
    }
  }
  return v3;
}

uint64_t sub_100039EE4(uint64_t a1)
{
  uint64_t v2 = sub_10003F254(*(_DWORD *)a1);
  int v3 = snprintf(__str, 0x400uLL, "\tpeers_identifier %s", v2);
  uint64_t v4 = *(void *)(a1 + 8);
  if (v4) {
    snprintf(&__str[v3], 1024 - v3, " \"%s\"", *(const char **)(v4 + 8));
  }
  if (dword_10008FA20)
  {
    long long v5 = ne_log_obj();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)uint8_t buf = 136315138;
      BOOL v8 = __str;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "%s;\n", buf, 0xCu);
    }
  }
  return 0;
}

uint64_t sub_100039FF0(const char *a1, int a2)
{
  memset(&v10, 0, sizeof(v10));
  uid_t v4 = getuid();
  if (v4 != geteuid())
  {
    if (dword_10008FA20)
    {
      long long v7 = ne_log_obj();
      if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR)) {
        sub_100066DD0(v7);
      }
    }
    return 0xFFFFFFFFLL;
  }
  if (stat(a1, &v10)) {
    return 0xFFFFFFFFLL;
  }
  if (v10.st_uid != getuid())
  {
    if (dword_10008FA20)
    {
      BOOL v8 = ne_log_obj();
      if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR)) {
        sub_100066D58((uint64_t)a1, v8);
      }
    }
    return 0xFFFFFFFFLL;
  }
  if ((v10.st_mode & 0xF000) != 0x8000)
  {
    if (dword_10008FA20)
    {
      uint64_t v9 = ne_log_obj();
      if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR)) {
        sub_100066CC8((uint64_t)a1, &v10.st_mode, v9);
      }
    }
    return 0xFFFFFFFFLL;
  }
  uint64_t result = 0;
  if (a2 && (v10.st_mode & 0x3F) != 0)
  {
    if (dword_10008FA20)
    {
      long long v6 = ne_log_obj();
      if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR)) {
        sub_100066C50((uint64_t)a1, v6);
      }
    }
    return 0xFFFFFFFFLL;
  }
  return result;
}

uint64_t sub_10003A168(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t v7 = qword_10008F848;
  if (a4 && !*(void *)(qword_10008F848 + 296)) {
    return 0;
  }
  if (a3) {
    int v8 = 1;
  }
  else {
    int v8 = 2;
  }
  uint64_t v9 = qword_10008CE38;
  while (!v9)
  {
LABEL_30:
    BOOL v24 = v8 == 1;
    int v8 = 2;
    if (!v24) {
      return 0;
    }
  }
  uint64_t v10 = 0;
  uint64_t v11 = v9;
  while (1)
  {
    uint64_t v12 = v10;
    uint64_t v13 = *(void *)(v11 + 40);
    if (v13)
    {
      if (v8 == 2 || memcmp(*(const void **)(a3 + 8), *(const void **)(v13 + 8), *(void *)v13)) {
        goto LABEL_18;
      }
    }
    else if (v8 == 1)
    {
      goto LABEL_18;
    }
    uint64_t v14 = *(void *)v11;
    uint64_t v10 = v11;
    if (*(void *)v11) {
      break;
    }
LABEL_19:
    uint64_t v11 = *(void *)(v11 + 120);
    if (!v11)
    {
      uint64_t v12 = v10;
      if (!v10) {
        goto LABEL_30;
      }
LABEL_32:
      if (dword_10008FA20)
      {
        BOOL v25 = ne_log_obj();
        if (os_log_type_enabled(v25, OS_LOG_TYPE_DEBUG)) {
          sub_100066E14(v25, v26, v27, v28, v29, v30, v31, v32);
        }
      }
      return v12;
    }
  }
  if (!a1)
  {
    if (v12) {
      goto LABEL_32;
    }
    uint64_t v10 = 0;
    goto LABEL_19;
  }
  if (*(void *)a1 != *(void *)v14 || memcmp(*(const void **)(a1 + 8), *(const void **)(v14 + 8), *(void *)a1))
  {
LABEL_18:
    uint64_t v10 = v12;
    goto LABEL_19;
  }
  if (!a4)
  {
    uint64_t v22 = *(void *)(v11 + 8);
    if (*(void *)a2 == *(void *)v22)
    {
      int v23 = memcmp(*(const void **)(a2 + 8), *(const void **)(v22 + 8), *(void *)a2);
      uint64_t v10 = v12;
      if (!v23) {
        return v11;
      }
      goto LABEL_19;
    }
    goto LABEL_18;
  }
  uint64_t v15 = *(unint64_t **)(v7 + 296);
  uint64_t v16 = (const void *)v15[1];
  int v17 = memcmp(v16, *(const void **)(*(void *)(v11 + 8) + 8), **(void **)(v11 + 8));
  uint64_t v10 = v12;
  if (v17) {
    goto LABEL_19;
  }
  if (dword_10008C2C8 >= 7) {
    sub_100033908(7, (uint64_t)v16, *v15, "matched external nat address.\n", v18, v19, v20, v21, v34);
  }
  return v11;
}

uint64_t sub_10003A34C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!dword_10008FA20 || (uint64_t v10 = ne_log_obj(), !os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG)))
  {
    if (a1) {
      goto LABEL_4;
    }
    return 0;
  }
  sub_100066E8C(v10, v11, v12, v13, a5, a6, a7, a8);
  if (!a1) {
    return 0;
  }
LABEL_4:
  if (dword_10008C2C8 >= 7) {
    sub_100033908(7, *(void *)(a1 + 8), *(void *)a1, "getsainfo_by_dst_id - dst id:\n", a5, a6, a7, a8, v28);
  }
  uint64_t v14 = qword_10008CE38;
  if (!qword_10008CE38) {
    return 0;
  }
  uint64_t v15 = 0;
  do
  {
    uint64_t v16 = v15;
    if (*(void *)v14)
    {
      if (dword_10008C2C8 >= 7)
      {
        sub_100033908(7, *(void *)(*(void *)v14 + 8), **(void **)v14, "getsainfo_by_dst_id - sainfo id - src:\n", a5, a6, a7, a8, v28);
        if (dword_10008C2C8 >= 7) {
          sub_100033908(7, *(void *)(*(void *)(v14 + 8) + 8), **(void **)(v14 + 8), "getsainfo_by_dst_id - sainfo id - dst:\n", a5, a6, a7, a8, v28);
        }
      }
    }
    else if (dword_10008FA20)
    {
      int v17 = ne_log_obj();
      if (os_log_type_enabled(v17, OS_LOG_TYPE_DEBUG)) {
        sub_100066E4C(&buf, v30, v17);
      }
    }
    uint64_t v18 = *(void *)(v14 + 40);
    if (!v18) {
      goto LABEL_21;
    }
    if (dword_10008C2C8 >= 7) {
      sub_100033908(7, *(void *)(v18 + 8), *(void *)v18, "getsainfo_by_dst_id - sainfo id_i:\n", a5, a6, a7, a8, v28);
    }
    if (a2 && !memcmp(*(const void **)(a2 + 8), *(const void **)(*(void *)(v14 + 40) + 8), **(void **)(v14 + 40)))
    {
LABEL_21:
      uint64_t v15 = v14;
      if (*(void *)v14)
      {
        uint64_t v15 = v16;
        if (!memcmp(*(const void **)(a1 + 8), *(const void **)(*(void *)(v14 + 8) + 8), **(void **)(v14 + 8))) {
          return v14;
        }
      }
    }
    else
    {
      uint64_t v15 = v16;
    }
    uint64_t v14 = *(void *)(v14 + 120);
  }
  while (v14);
  if (v15)
  {
    if (dword_10008FA20)
    {
      uint64_t v19 = ne_log_obj();
      if (os_log_type_enabled(v19, OS_LOG_TYPE_DEBUG)) {
        sub_100066E14(v19, v20, v21, v22, v23, v24, v25, v26);
      }
    }
  }
  return v15;
}

double sub_10003A554()
{
  uint64_t v0 = malloc_type_calloc(1uLL, 0x88uLL, 0x10A004085B85051uLL);
  if (v0)
  {
    v0[3] = 28800;
    *((_DWORD *)v0 + 8) = 0x7FFFFFFF;
    double result = COERCE_DOUBLE(&_mh_execute_header);
    *(void *)((char *)v0 + 108) = &_mh_execute_header;
  }
  return result;
}

void sub_10003A5A4(void *a1)
{
  for (uint64_t i = 0; i != 7; ++i)
  {
    int v3 = (void *)a1[i + 6];
    if (v3)
    {
      do
      {
        uid_t v4 = (void *)v3[1];
        free(v3);
        int v3 = v4;
      }
      while (v4);
    }
  }
  if (*a1) {
    sub_10003FA78((void *)*a1);
  }
  long long v5 = (void *)a1[1];
  if (v5) {
    sub_10003FA78(v5);
  }
  long long v6 = (void *)a1[2];
  if (v6) {
    sub_10003FA78(v6);
  }

  free(a1);
}

void *sub_10003A630(void *result)
{
  if (result)
  {
    do
    {
      uint64_t v1 = (void *)result[1];
      free(result);
      double result = v1;
    }
    while (v1);
  }
  return result;
}

uint64_t sub_10003A664(uint64_t result)
{
  uint64_t v1 = qword_10008CE38;
  *(void *)(result + 120) = qword_10008CE38;
  if (v1) {
    *(void *)(v1 + 128) = result + 120;
  }
  qword_10008CE38 = result;
  *(void *)(result + 128) = &qword_10008CE38;
  *(_DWORD *)(result + 108) = 1;
  return result;
}

uint64_t sub_10003A698(uint64_t result)
{
  if (*(_DWORD *)(result + 108))
  {
    uint64_t v1 = *(void *)(result + 120);
    if (v1) {
      *(void *)(v1 + 128) = *(void *)(result + 128);
    }
    **(void **)(result + 128) = v1;
    *(_DWORD *)(result + 108) = 0;
  }
  return result;
}

void sub_10003A6C0()
{
  uint64_t v0 = qword_10008CE38;
  while (v0)
  {
    uint64_t v1 = v0;
    uint64_t v0 = *(void *)(v0 + 120);
    if (!*(_DWORD *)(v1 + 104))
    {
      if (*(_DWORD *)(v1 + 108))
      {
        if (v0) {
          *(void *)(v0 + 128) = *(void *)(v1 + 128);
        }
        **(void **)(v1 + 128) = v0;
        *(_DWORD *)(v1 + 108) = 0;
      }
      int v2 = *(_DWORD *)(v1 + 112);
      BOOL v3 = __OFSUB__(v2--, 1);
      *(_DWORD *)(v1 + 112) = v2;
      if ((v2 < 0) ^ v3 | (v2 == 0)) {
        sub_10003A5A4((void *)v1);
      }
    }
  }
}

void sub_10003A730(int a1)
{
  uint64_t v1 = qword_10008CE38;
  while (v1)
  {
    uint64_t v3 = v1;
    uint64_t v1 = *(void *)(v1 + 120);
    if (*(_DWORD *)(v3 + 104) == a1)
    {
      if (*(_DWORD *)(v3 + 108))
      {
        if (v1) {
          *(void *)(v1 + 128) = *(void *)(v3 + 128);
        }
        **(void **)(v3 + 128) = v1;
        *(_DWORD *)(v3 + 108) = 0;
      }
      int v4 = *(_DWORD *)(v3 + 112);
      BOOL v5 = __OFSUB__(v4--, 1);
      *(_DWORD *)(v3 + 112) = v4;
      if ((v4 < 0) ^ v5 | (v4 == 0)) {
        sub_10003A5A4((void *)v3);
      }
    }
  }
}

uint64_t sub_10003A7A8(uint64_t result)
{
  return result;
}

void sub_10003A7B8(void *a1)
{
  int v1 = *((_DWORD *)a1 + 28);
  BOOL v2 = __OFSUB__(v1--, 1);
  *((_DWORD *)a1 + 28) = v1;
  if ((v1 < 0) ^ v2 | (v1 == 0))
  {
    if (*((_DWORD *)a1 + 27))
    {
      uint64_t v3 = a1[15];
      if (v3) {
        *(void *)(v3 + 128) = a1[16];
      }
      *(void *)a1[16] = v3;
      *((_DWORD *)a1 + 27) = 0;
    }
    sub_10003A5A4(a1);
  }
}

void sub_10003A7F4()
{
  qword_10008CE38 = 0;
}

void *sub_10003A800()
{
  return malloc_type_calloc(1uLL, 0x10uLL, 0x10200405730B0C9uLL);
}

uint64_t *sub_10003A81C(uint64_t *result, uint64_t a2)
{
  uint64_t v2 = *result;
  while (v2)
  {
    uint64_t v3 = v2;
    uint64_t v2 = *(void *)(v2 + 8);
    if (!v2)
    {
      double result = (uint64_t *)(v3 + 8);
      break;
    }
  }
  *double result = a2;
  return result;
}

uint64_t *sub_10003A83C(uint64_t *a1)
{
  uint64_t v2 = *a1;
  if (v2)
  {
    uint64_t v3 = sub_1000107E8(v2);
    if (v3)
    {
      int v4 = (char *)v3;
      snprintf((char *)&qword_10008CE40, 0x100uLL, "%s", v3);
      free(v4);
    }
    uint64_t v5 = a1[1];
    if (v5)
    {
      long long v6 = sub_1000107E8(v5);
      if (v6)
      {
        uint64_t v7 = v6;
        size_t v8 = strlen((const char *)&qword_10008CE40);
        snprintf((char *)&qword_10008CE40 + v8, 256 - v8, " %s", v7);
        free(v7);
      }
    }
    else
    {
      size_t v9 = strlen((const char *)&qword_10008CE40);
      snprintf((char *)&qword_10008CE40 + v9, 256 - v9, " anonymous");
    }
  }
  else
  {
    strcpy((char *)&qword_10008CE40, "anonymous");
  }
  uint64_t v10 = a1[5];
  if (v10)
  {
    uint64_t v11 = sub_1000107E8(v10);
    if (v11)
    {
      uint64_t v12 = v11;
      size_t v13 = strlen((const char *)&qword_10008CE40);
      snprintf((char *)&qword_10008CE40 + v13, 256 - v13, " from %s", v12);
      free(v12);
    }
  }
  return &qword_10008CE40;
}

void sub_10003A980(_DWORD *a1)
{
  if (xmmword_1000906E0 != 0) {
    a1[8] = 1;
  }
  uint64_t v2 = *((void *)a1 + 5);
  uint64_t v3 = (void *)*((void *)a1 + 6);
  if (v2)
  {
    *(void *)(v2 + 48) = v3;
    uint64_t v3 = (void *)*((void *)a1 + 6);
  }
  else
  {
    qword_10008CF48 = *((void *)a1 + 6);
  }
  *uint64_t v3 = v2;
  if (!a1[8])
  {
    int v4 = (void (*)(void))*((void *)a1 + 2);
    if (v4)
    {
      if (!dword_10008FE28) {
        v4(*((void *)a1 + 3));
      }
    }
  }

  free(a1);
}

void *sub_10003AA24(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (!dword_10008C2D0) {
    dword_10008C2D0 = 1;
  }
  double result = malloc_type_malloc(0x38uLL, 0x10A0040F0AD93B6uLL);
  if (result)
  {
    uint64_t v7 = result;
    int v8 = dword_10008C2D0++;
    *(_DWORD *)double result = v8;
    *((_DWORD *)result + 8) = 0;
    result[2] = a2;
    result[3] = a3;
    time_t v12 = 0;
    result[1] = time(&v12) + a1;
    v7[5] = 0;
    size_t v9 = (void *)qword_10008CF48;
    v7[6] = qword_10008CF48;
    void *v9 = v7;
    qword_10008CF48 = (uint64_t)(v7 + 5);
    dispatch_time_t v10 = dispatch_time(0, 1000000000 * a1);
    v11[0] = _NSConcreteStackBlock;
    v11[1] = 0x40000000;
    v11[2] = sub_10003AB78;
    v11[3] = &unk_1000890C8;
    v11[4] = v7;
    dispatch_after(v10, (dispatch_queue_t)&_dispatch_main_q, v11);
    return (void *)*(unsigned int *)v7;
  }
  return result;
}

time_t sub_10003AB50()
{
  time_t v1 = 0;
  return time(&v1);
}

void sub_10003AB78(uint64_t a1)
{
}

BOOL sub_10003AB80(int a1)
{
  uint64_t v1 = 1;
  if (a1)
  {
    uint64_t v2 = qword_10008CF40;
    if (qword_10008CF40)
    {
      while (*(_DWORD *)v2 != a1)
      {
        uint64_t v2 = *(void *)(v2 + 40);
        if (!v2) {
          return 1;
        }
      }
      return *(_DWORD *)(v2 + 32) != 0;
    }
  }
  return v1;
}

uint64_t sub_10003ABC4(int a1, void *a2)
{
  uint64_t v2 = 0;
  if (a1)
  {
    uint64_t v3 = qword_10008CF40;
    if (qword_10008CF40)
    {
      while (*(_DWORD *)v3 != a1)
      {
        uint64_t v3 = *(void *)(v3 + 40);
        if (!v3) {
          return 0;
        }
      }
      if (*(_DWORD *)(v3 + 32)) {
        return 0;
      }
      *a2 = *(void *)(v3 + 8);
      return 1;
    }
  }
  return v2;
}

uint64_t sub_10003AC14(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = qword_10008CF40;
    if (qword_10008CF40)
    {
      while (*(_DWORD *)v1 != result)
      {
        uint64_t v1 = *(void *)(v1 + 40);
        if (!v1) {
          return result;
        }
      }
      *(_DWORD *)(v1 + 32) = 1;
    }
  }
  return result;
}

void sub_10003AC48()
{
  for (uint64_t i = qword_10008CF40; i; uint64_t i = *(void *)(i + 40))
    *(_DWORD *)(i + 32) = 1;
}

uint64_t sub_10003AC68(uint64_t result)
{
  for (uint64_t i = qword_10008CF40; i; uint64_t i = *(void *)(i + 40))
  {
    if (*(void *)(i + 24) == result) {
      *(_DWORD *)(i + 32) = 1;
    }
  }
  return result;
}

void sub_10003AC94()
{
  qword_10008CF40 = 0;
  qword_10008CF48 = (uint64_t)&qword_10008CF40;
}

uint64_t sub_10003ACA4(unsigned __int8 a1)
{
  if (dword_10008F860)
  {
    if (vproc_swap_integer())
    {
      if (dword_10008FA20)
      {
        uint64_t v2 = ne_log_obj();
        if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR)) {
          sub_100066EC4(a1, v2);
        }
      }
    }
  }
  return qword_10008C2D8;
}

void sub_10003AD3C()
{
  qword_10008FE30 = (uint64_t)&_dispatch_main_q;
  sub_10003AC94();
  if ((sub_10004FEE0() & 0x80000000) != 0)
  {
    if (!dword_10008FA20) {
      goto LABEL_59;
    }
    uint64_t v24 = ne_log_obj();
    if (!os_log_type_enabled(v24, OS_LOG_TYPE_ERROR)) {
      goto LABEL_59;
    }
    LOWORD(buffer.__sigaction_u.__sa_handler) = 0;
    uint64_t v25 = "failed to initialize power-mgmt.";
    goto LABEL_58;
  }
  if (*(_DWORD *)(qword_10008F848 + 112) == 1 && sub_1000070E4())
  {
    if (!dword_10008FA20) {
      goto LABEL_59;
    }
    uint64_t v24 = ne_log_obj();
    if (!os_log_type_enabled(v24, OS_LOG_TYPE_ERROR)) {
      goto LABEL_59;
    }
    LOWORD(buffer.__sigaction_u.__sa_handler) = 0;
    uint64_t v25 = "failed to initialize route socket.\n";
    goto LABEL_58;
  }
  qword_10008CFE0 = NEPolicyCreateSession();
  if (!qword_10008CFE0) {
    goto LABEL_23;
  }
  uint64_t v34 = 0;
  memset(&buffer, 0, 48);
  pid_t v0 = getpid();
  if (proc_pidinfo(v0, 17, 1uLL, &buffer, 56) != 56) {
    goto LABEL_23;
  }
  CFUUIDRef v1 = CFUUIDCreateFromUUIDBytes(kCFAllocatorDefault, (CFUUIDBytes)buffer);
  if (!v1) {
    goto LABEL_23;
  }
  CFUUIDRef v2 = v1;
  Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
  if (!Mutable) {
    goto LABEL_11;
  }
  int v4 = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  BOOL v5 = v4 != 0;
  if (v4)
  {
    long long v6 = v4;
    CFDictionarySetValue(v4, @"ConditionType", @"Application");
    CFDictionarySetValue(v6, @"ApplicationUUID", v2);
    CFArrayAppendValue(Mutable, v6);
    CFRelease(v6);
  }
  uint64_t v7 = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (v7)
  {
    int v8 = v7;
    CFDictionarySetValue(v7, @"ConditionType", @"AllInterfaces");
    CFArrayAppendValue(Mutable, v8);
    CFRelease(v8);
  }
  else
  {
LABEL_11:
    BOOL v5 = 0;
  }
  size_t v9 = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (v9)
  {
    uint64_t v11 = v9;
    CFDictionaryAddValue(v9, @"Result", @"Pass");
    BOOL v10 = v5 && NEPolicyAdd() != 0;
    CFRelease(v11);
    if (!Mutable)
    {
LABEL_21:
      CFRelease(v2);
      if (v10)
      {
        BOOL v12 = NEPolicyApply() != 0;
LABEL_24:
        if (!v12)
        {
          if (dword_10008FA20)
          {
            size_t v13 = ne_log_obj();
            if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
            {
              LOWORD(buffer.__sigaction_u.__sa_handler) = 0;
              _os_log_error_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, "failed to initialize NEPolicy session.\n", (uint8_t *)&buffer, 2u);
            }
          }
        }
        if (sub_100006E18())
        {
          if (!dword_10008FA20) {
            goto LABEL_59;
          }
          uint64_t v24 = ne_log_obj();
          if (!os_log_type_enabled(v24, OS_LOG_TYPE_ERROR)) {
            goto LABEL_59;
          }
          LOWORD(buffer.__sigaction_u.__sa_handler) = 0;
          uint64_t v25 = "failed to initialize listening addresses.\n";
        }
        else if (sub_100022FC4())
        {
          if (!dword_10008FA20) {
            goto LABEL_59;
          }
          uint64_t v24 = ne_log_obj();
          if (!os_log_type_enabled(v24, OS_LOG_TYPE_ERROR)) {
            goto LABEL_59;
          }
          LOWORD(buffer.__sigaction_u.__sa_handler) = 0;
          uint64_t v25 = "failed to initialize isakmp";
        }
        else
        {
          if (sub_100049CD0())
          {
            if (dword_10008FA20)
            {
              uint64_t v14 = ne_log_obj();
              if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
              {
                LOWORD(buffer.__sigaction_u.__sa_handler) = 0;
                _os_log_error_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, "failed to initialize vpn control port", (uint8_t *)&buffer, 2u);
              }
            }
          }
          uint64_t v15 = 0;
          while (1)
          {
            int v16 = dword_10006E710[v15];
            buffer.__sigaction_u.__sa_handler = (void (__cdecl *)(int))sub_10003B808;
            *(void *)&buffer.sa_mask = 0x4200000000;
            if (sigaction(v16, &buffer, 0) < 0) {
              break;
            }
            if (++v15 == 6)
            {
              for (uint64_t i = 0; i != 33; ++i)
                dword_10008CF50[i] = 0;
              if (dword_10008F9F0) {
                goto LABEL_48;
              }
              dword_10008F85C = getpid();
              uint64_t v18 = *(unsigned char **)(qword_10008F848 + 160);
              if (v18 && *v18 != 47)
              {
                __strlcat_chk();
                __strlcat_chk();
              }
              else
              {
                __strlcpy_chk();
              }
              uint64_t v19 = fopen((const char *)&buffer, "w");
              if (v19)
              {
                uint64_t v26 = v19;
                int v27 = fileno(v19);
                if (fchmod(v27, 0x1A4u) != -1)
                {
                  fprintf(v26, "%ld\n", dword_10008F85C);
                  fclose(v26);
                  goto LABEL_48;
                }
                if (dword_10008FA20)
                {
                  char v28 = ne_log_obj();
                  if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR))
                  {
                    uint64_t v29 = __error();
                    uint64_t v30 = strerror(*v29);
                    *(_DWORD *)uint8_t buf = 136315138;
                    p_sigaction buffer = (sigaction *)v30;
                    _os_log_error_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_ERROR, "%s", buf, 0xCu);
                  }
                }
                fclose(v26);
              }
              else
              {
                if (dword_10008FA20)
                {
                  uint64_t v20 = ne_log_obj();
                  if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
                  {
                    *(_DWORD *)uint8_t buf = 136315138;
                    p_sigaction buffer = &buffer;
                    _os_log_error_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_ERROR, "cannot open %s", buf, 0xCu);
                  }
                }
LABEL_48:
                if (!qword_10008CFD8) {
                  qword_10008CFD8 = os_transaction_create();
                }
                if (!dword_10008FE28) {
                  dispatch_main();
                }
              }
LABEL_59:
              exit(1);
            }
          }
          if (!dword_10008FA20) {
            goto LABEL_59;
          }
          uint64_t v21 = ne_log_obj();
          if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
          {
            uint64_t v22 = __error();
            uint64_t v23 = strerror(*v22);
            LODWORD(buffer.__sigaction_u.__sa_handler) = 136315138;
            *(void (__cdecl **)(int, __siginfo *, void *))((char *)&buffer.__sigaction_u.__sa_sigaction + 4) = (void (__cdecl *)(int, __siginfo *, void *))v23;
            _os_log_error_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_ERROR, "failed to set_signal (%s)\n", (uint8_t *)&buffer, 0xCu);
          }
          if (!dword_10008FA20) {
            goto LABEL_59;
          }
          uint64_t v24 = ne_log_obj();
          if (!os_log_type_enabled(v24, OS_LOG_TYPE_ERROR)) {
            goto LABEL_59;
          }
          LOWORD(buffer.__sigaction_u.__sa_handler) = 0;
          uint64_t v25 = "failed to initialize signals.\n";
        }
LABEL_58:
        _os_log_error_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_ERROR, v25, (uint8_t *)&buffer, 2u);
        goto LABEL_59;
      }
LABEL_23:
      BOOL v12 = 0;
      goto LABEL_24;
    }
  }
  else
  {
    BOOL v10 = 0;
    if (!Mutable) {
      goto LABEL_21;
    }
  }
  CFRelease(Mutable);
  goto LABEL_21;
}

void sub_10003B3DC()
{
  int v0 = *(_DWORD *)(qword_10008F848 + 80);
  if (*(_DWORD *)(qword_10008F848 + 88))
  {
    if (v0 != 17
      || sub_10004A1A4()
      || sub_100050570()
      || (BOOL v1 = sub_100035518())
      || !sub_1000388C8(v1))
    {
      uint64_t v2 = *(unsigned int *)(qword_10008F848 + 88);
      if (v2)
      {
        sub_10003AC14(v2);
        unsigned int v3 = 0;
LABEL_8:
        *(_DWORD *)(qword_10008F848 + 88) = v3;
      }
    }
  }
  else if (v0 == 17 && !sub_10004A1A4() && !sub_100050570())
  {
    BOOL v4 = sub_100035518();
    if (!v4)
    {
      if (sub_1000388C8(v4))
      {
        uint64_t v5 = *(int *)(qword_10008F848 + 84);
        if (!v5) {
          sub_10003B4A8();
        }
        unsigned int v3 = sub_10003AA24(v5, (uint64_t)sub_10003B4A8, 0);
        goto LABEL_8;
      }
    }
  }
}

void sub_10003B4A8()
{
  if (dword_10008FA20)
  {
    int v0 = ne_log_obj();
    if (os_log_type_enabled(v0, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)BOOL v1 = 0;
      _os_log_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_DEFAULT, "performing auto exit\n", v1, 2u);
    }
  }
  sub_10003B758();
}

void sub_10003B50C()
{
  uint64_t v0 = 0;
  while (1)
  {
    if (!dword_10008CF50[v0]) {
      goto LABEL_23;
    }
    --dword_10008CF50[v0];
    if ((int)v0 > 1)
    {
      if (v0 != 30)
      {
        if (v0 == 2 || v0 == 15)
        {
          if (dword_10008FA20)
          {
            unsigned int v3 = ne_log_obj();
            if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)uint8_t buf = 67109120;
              int v6 = v0;
              _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "caught signal %d\n", buf, 8u);
            }
          }
LABEL_31:
          sub_10003B758();
        }
        goto LABEL_20;
      }
    }
    else if (v0 != 1)
    {
      if (!v0) {
        return;
      }
LABEL_20:
      if (dword_10008FA20)
      {
        BOOL v1 = ne_log_obj();
        if (os_log_type_enabled(v1, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)uint8_t buf = 67109120;
          int v6 = v0;
          _os_log_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_DEFAULT, "caught signal %d\n", buf, 8u);
        }
      }
      goto LABEL_23;
    }
    if (sub_10004572C(0)) {
      break;
    }
    if (!dword_10008FE28)
    {
      if (v0 == 1)
      {
        sub_100008750(1);
        sub_100007DF0(1);
      }
      if (sub_100053A88(v0))
      {
        if (dword_10008FA20)
        {
          BOOL v4 = ne_log_obj();
          if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR)) {
            sub_100066F40(v4);
          }
        }
        exit(1);
      }
      if (!*(void *)(qword_10008F848 + 128) && !byte_10008FA24) {
        sub_100033F80(*(char **)(qword_10008F848 + 168));
      }
      if (sub_1000388C8(1)) {
        goto LABEL_31;
      }
    }
LABEL_23:
    if (++v0 == 33) {
      return;
    }
  }
  if (dword_10008FA20)
  {
    uint64_t v2 = ne_log_obj();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR)) {
      sub_100066F84(v2);
    }
  }
}

void sub_10003B758()
{
  sub_10003AC48();
  sub_1000501DC();
  if (dword_10008FE28) {
    sub_100008750(0);
  }
  sub_100007DF0(0);
  sub_1000070AC();
  sub_100023B9C();
  sub_10002F038();
  sub_10004A0F8();
  if (qword_10008CFD8)
  {
    os_release((void *)qword_10008CFD8);
    qword_10008CFD8 = 0;
  }
  if (dword_10008FA20)
  {
    uint64_t v0 = ne_log_obj();
    if (os_log_type_enabled(v0, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)BOOL v1 = 0;
      _os_log_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_DEFAULT, "racoon shutdown\n", v1, 2u);
    }
  }
  exit(0);
}

void sub_10003B808(int a1)
{
  if (a1 == 15) {
    dword_10008FE28 = 1;
  }
  dword_10008FE2C = 1;
  dispatch_async((dispatch_queue_t)qword_10008FE30, &stru_100089108);
}

void sub_10003B850(id a1)
{
  if (dword_10008FE2C)
  {
    sub_10003B50C();
    dword_10008FE2C = 0;
  }
}

void sub_10003B880()
{
}

void sub_10003B890()
{
  uint64_t v0 = qword_10008F848;
  BOOL v1 = *(NSObject **)(qword_10008F848 + 56);
  if (v1)
  {
    dispatch_suspend(v1);
    uint64_t v0 = qword_10008F848;
  }
  uint64_t v2 = *(NSObject **)(v0 + 40);
  if (v2) {
    dispatch_suspend(v2);
  }

  sub_100023D18();
}

uint64_t sub_10003B8E4(unint64_t a1, unint64_t a2)
{
  uint64_t v2 = a1 | a2;
  if (a1 | a2)
  {
    uint64_t v2 = 1;
    if (a1)
    {
      if (a2)
      {
        if (*(unsigned __int8 *)a1 == *(unsigned __int8 *)a2)
        {
          int v3 = *(unsigned __int8 *)(a1 + 1);
          if (v3 == *(unsigned __int8 *)(a2 + 1))
          {
            if (v3 == 30)
            {
              if (*(void *)(a1 + 8) == *(void *)(a2 + 8) && *(void *)(a1 + 16) == *(void *)(a2 + 16))
              {
                int v4 = *(_DWORD *)(a1 + 24);
                int v5 = *(_DWORD *)(a2 + 24);
LABEL_15:
                if (v4 == v5) {
                  return 0;
                }
              }
            }
            else if (v3 == 2)
            {
              int v4 = *(_DWORD *)(a1 + 4);
              int v5 = *(_DWORD *)(a2 + 4);
              goto LABEL_15;
            }
          }
        }
        return 1;
      }
    }
  }
  return v2;
}

BOOL sub_10003B96C(unint64_t a1, unint64_t a2, int a3)
{
  uint64_t v3 = a1 | a2;
  if (a1 | a2)
  {
    uint64_t v3 = 1;
    if (a1)
    {
      if (a2)
      {
        if (*(unsigned __int8 *)a1 != *(unsigned __int8 *)a2) {
          return 1;
        }
        int v4 = *(unsigned __int8 *)(a1 + 1);
        if (v4 != *(unsigned __int8 *)(a2 + 1)) {
          return 1;
        }
        if (v4 != 2)
        {
          if (v4 == 30)
          {
            uint64_t v5 = 0;
            while (1)
            {
              unsigned int v6 = -1 << -(char)a3;
              if (!a3) {
                unsigned int v6 = 0;
              }
              BOOL v7 = a3 < 32;
              if (a3 >= 32) {
                a3 -= 32;
              }
              else {
                a3 = 0;
              }
              if (!v7) {
                unsigned int v6 = -1;
              }
              if (((*(_DWORD *)(a1 + 8 + v5) ^ *(_DWORD *)(a2 + 8 + v5)) & bswap32(v6)) != 0) {
                break;
              }
              v5 += 4;
              if (v5 == 16) {
                return *(_DWORD *)(a1 + 24) != *(_DWORD *)(a2 + 24);
              }
            }
          }
          return 1;
        }
        return ((*(_DWORD *)(a1 + 4) ^ *(_DWORD *)(a2 + 4)) & bswap32(-1 << -(char)a3)) != 0;
      }
    }
  }
  return v3;
}

uint64_t sub_10003BA4C(unint64_t a1, unint64_t a2)
{
  uint64_t v2 = a1 | a2;
  if (a1 | a2)
  {
    uint64_t v2 = 1;
    if (a1)
    {
      if (a2)
      {
        if (*(unsigned __int8 *)a1 == *(unsigned __int8 *)a2)
        {
          int v3 = *(unsigned __int8 *)(a1 + 1);
          if (v3 == *(unsigned __int8 *)(a2 + 1))
          {
            if (v3 == 30)
            {
              if ((!*(_WORD *)(a1 + 2)
                 || !*(_WORD *)(a2 + 2)
                 || *(unsigned __int16 *)(a1 + 2) == *(unsigned __int16 *)(a2 + 2))
                && *(void *)(a1 + 8) == *(void *)(a2 + 8)
                && *(void *)(a1 + 16) == *(void *)(a2 + 16))
              {
                int v4 = *(_DWORD *)(a1 + 24);
                int v5 = *(_DWORD *)(a2 + 24);
LABEL_21:
                if (v4 == v5) {
                  return 0;
                }
              }
            }
            else if (v3 == 2 {
                   && (!*(_WORD *)(a1 + 2)
            }
                    || !*(_WORD *)(a2 + 2)
                    || *(unsigned __int16 *)(a1 + 2) == *(unsigned __int16 *)(a2 + 2)))
            {
              int v4 = *(_DWORD *)(a1 + 4);
              int v5 = *(_DWORD *)(a2 + 4);
              goto LABEL_21;
            }
          }
        }
        return 1;
      }
    }
  }
  return v2;
}

uint64_t sub_10003BB04(unint64_t a1, unint64_t a2)
{
  uint64_t v2 = a1 | a2;
  if (a1 | a2)
  {
    uint64_t v2 = 1;
    if (a1)
    {
      if (a2)
      {
        if (*(unsigned __int8 *)a1 == *(unsigned __int8 *)a2)
        {
          int v3 = *(unsigned __int8 *)(a1 + 1);
          if (v3 == *(unsigned __int8 *)(a2 + 1))
          {
            if (v3 == 30)
            {
              if (*(unsigned __int16 *)(a1 + 2) == *(unsigned __int16 *)(a2 + 2)
                && *(void *)(a1 + 8) == *(void *)(a2 + 8)
                && *(void *)(a1 + 16) == *(void *)(a2 + 16))
              {
                int v4 = *(_DWORD *)(a1 + 24);
                int v5 = *(_DWORD *)(a2 + 24);
LABEL_17:
                if (v4 == v5) {
                  return 0;
                }
              }
            }
            else if (v3 == 2 && *(unsigned __int16 *)(a1 + 2) == *(unsigned __int16 *)(a2 + 2))
            {
              int v4 = *(_DWORD *)(a1 + 4);
              int v5 = *(_DWORD *)(a2 + 4);
              goto LABEL_17;
            }
          }
        }
        return 1;
      }
    }
  }
  return v2;
}

BOOL sub_10003BBAC(unint64_t a1, unint64_t a2, int a3)
{
  uint64_t v3 = a1 | a2;
  if (a1 | a2)
  {
    uint64_t v3 = 1;
    if (a1)
    {
      if (a2)
      {
        if (*(unsigned __int8 *)a1 == *(unsigned __int8 *)a2)
        {
          int v4 = *(unsigned __int8 *)(a1 + 1);
          if (v4 == *(unsigned __int8 *)(a2 + 1))
          {
            if (v4 == 30)
            {
              if (*(unsigned __int16 *)(a1 + 2) == *(unsigned __int16 *)(a2 + 2))
              {
                uint64_t v5 = 0;
                while (1)
                {
                  unsigned int v6 = -1 << -(char)a3;
                  if (!a3) {
                    unsigned int v6 = 0;
                  }
                  BOOL v7 = a3 < 32;
                  if (a3 >= 32) {
                    a3 -= 32;
                  }
                  else {
                    a3 = 0;
                  }
                  if (!v7) {
                    unsigned int v6 = -1;
                  }
                  if (((*(_DWORD *)(a1 + 8 + v5) ^ *(_DWORD *)(a2 + 8 + v5)) & bswap32(v6)) != 0) {
                    break;
                  }
                  v5 += 4;
                  if (v5 == 16) {
                    return *(_DWORD *)(a1 + 24) != *(_DWORD *)(a2 + 24);
                  }
                }
              }
            }
            else if (v4 == 2 {
                   && *(unsigned __int16 *)(a1 + 2) == *(unsigned __int16 *)(a2 + 2)
            }
                   && ((*(_DWORD *)(a1 + 4) ^ *(_DWORD *)(a2 + 4)) & bswap32(-1 << -(char)a3)) == 0)
            {
              return 0;
            }
          }
        }
        return 1;
      }
    }
  }
  return v3;
}

sockaddr *sub_10003BCB0(const sockaddr *a1)
{
  socklen_t v13 = 128;
  uint64_t v2 = (sockaddr *)malloc_type_calloc(1uLL, 0x80uLL, 0x4F296885uLL);
  if (!v2)
  {
    if (dword_10008FA20)
    {
      int v8 = ne_log_obj();
      if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR)) {
        sub_100066FC8();
      }
    }
    return 0;
  }
  uint64_t v3 = v2;
  int v4 = socket(a1->sa_family, 2, 0);
  if (v4 < 0)
  {
    if (dword_10008FA20)
    {
      size_t v9 = ne_log_obj();
      if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR)) {
        sub_100066FFC();
      }
    }
    goto LABEL_22;
  }
  int v5 = v4;
  if (fcntl(v4, 4, 4) == -1 && dword_10008FA20 != 0)
  {
    BOOL v7 = ne_log_obj();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR)) {
      sub_10006717C();
    }
  }
  sub_10003BE80(v5, a1->sa_family);
  if (connect(v5, a1, a1->sa_len) < 0)
  {
    if (dword_10008FA20)
    {
      BOOL v10 = ne_log_obj();
      if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR)) {
        sub_10006707C();
      }
    }
    close(v5);
LABEL_22:
    free(v3);
    return 0;
  }
  if (getsockname(v5, v3, &v13) < 0)
  {
    if (dword_10008FA20)
    {
      BOOL v12 = ne_log_obj();
      if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR)) {
        sub_1000670FC();
      }
    }
    close(v5);
    return 0;
  }
  close(v5);
  return v3;
}

uint64_t sub_10003BE80(int a1, uint64_t a2)
{
  if (a2 == 2)
  {
    int v4 = 0;
    int v5 = 21;
  }
  else
  {
    if (a2 != 30)
    {
      if (dword_10008FA20)
      {
        socklen_t v13 = ne_log_obj();
        if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR)) {
          sub_1000671B0(a2, v13, v14, v15, v16, v17, v18, v19);
        }
      }
      return 0xFFFFFFFFLL;
    }
    int v4 = 41;
    int v5 = 28;
  }
  unsigned int v6 = ipsec_set_policy("in bypass", 9);
  if (!v6)
  {
    if (!dword_10008FA20) {
      return 0xFFFFFFFFLL;
    }
    uint64_t v20 = ne_log_obj();
    if (!os_log_type_enabled(v20, OS_LOG_TYPE_ERROR)) {
      return 0xFFFFFFFFLL;
    }
LABEL_15:
    sub_10006721C();
    return 0xFFFFFFFFLL;
  }
  BOOL v7 = v6;
  socklen_t policylen = ipsec_get_policylen(v6);
  if (setsockopt(a1, v4, v5, v7, policylen) < 0)
  {
    if (!dword_10008FA20) {
      return 0xFFFFFFFFLL;
    }
    uint64_t v21 = ne_log_obj();
    if (!os_log_type_enabled(v21, OS_LOG_TYPE_ERROR)) {
      return 0xFFFFFFFFLL;
    }
    goto LABEL_24;
  }
  free(v7);
  size_t v9 = ipsec_set_policy("out bypass", 10);
  if (!v9)
  {
    if (!dword_10008FA20) {
      return 0xFFFFFFFFLL;
    }
    uint64_t v22 = ne_log_obj();
    if (!os_log_type_enabled(v22, OS_LOG_TYPE_ERROR)) {
      return 0xFFFFFFFFLL;
    }
    goto LABEL_15;
  }
  BOOL v10 = v9;
  socklen_t v11 = ipsec_get_policylen(v9);
  if ((setsockopt(a1, v4, v5, v10, v11) & 0x80000000) == 0)
  {
    free(v10);
    return 0;
  }
  if (dword_10008FA20)
  {
    uint64_t v23 = ne_log_obj();
    if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR)) {
LABEL_24:
    }
      sub_100067294();
  }
  return 0xFFFFFFFFLL;
}

ssize_t sub_10003C050(int a1, uint64_t a2, unint64_t a3, int a4, void *a5, socklen_t *a6, uint64_t a7, unsigned int *a8)
{
  long long v45 = 0u;
  long long v46 = 0u;
  long long v43 = 0u;
  long long v44 = 0u;
  long long v41 = 0u;
  long long v42 = 0u;
  sockaddr v39 = (sockaddr)0;
  long long v40 = 0u;
  memset(&v35.msg_namelen, 0, 24);
  *(void *)uint32_t v36 = 128;
  if (getsockname(a1, &v39, v36) < 0)
  {
    if (dword_10008FA20)
    {
      uint64_t v22 = ne_log_obj();
      if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR)) {
        sub_1000670FC();
      }
    }
    return 0xFFFFFFFFLL;
  }
  else
  {
    v35.msg_name = a5;
    v35.msg_namelen = *a6;
    v38[0] = a2;
    v38[1] = a3;
    v35.msg_iov = (iovec *)v38;
    v35.msg_iovlen = 1;
    memset(v37, 0, sizeof(v37));
    v35.msg_control = v37;
    *(void *)&v35.msg_controllen = 256;
    while (1)
    {
      ssize_t result = recvmsg(a1, &v35, a4);
      *(void *)uint32_t v36 = result;
      if ((result & 0x8000000000000000) == 0) {
        break;
      }
      if (*__error() != 4)
      {
        if (dword_10008FA20)
        {
          uint64_t v21 = ne_log_obj();
          if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR)) {
            sub_100067314();
          }
        }
        return 0xFFFFFFFFLL;
      }
    }
    if (result)
    {
      *a6 = v35.msg_namelen;
      unsigned int v23 = *a8;
      *a8 = 0;
      msg_control = (unsigned int *)v35.msg_control;
      if (v35.msg_controllen >= 0xC && v35.msg_control != 0)
      {
        int sa_family = v39.sa_family;
        int v27 = (unsigned int *)((char *)v35.msg_control + v35.msg_controllen);
        __int16 v28 = *(_WORD *)v39.sa_data;
        do
        {
          if (sa_family == 2)
          {
            if (msg_control[1]) {
              goto LABEL_40;
            }
            if (msg_control[2] != 7 || v23 < 0x10) {
              goto LABEL_40;
            }
            *a8 = 16;
            *(void *)a7 = 0;
            *(void *)(a7 + 8) = 0;
            *(_WORD *)a7 = 528;
            *(_DWORD *)(a7 + 4) = msg_control[3];
          }
          else
          {
            if (sa_family != 30 || msg_control[1] != 41) {
              goto LABEL_40;
            }
            if (msg_control[2] != 46 || v23 < 0x1C) {
              goto LABEL_40;
            }
            unsigned int v30 = 0;
            *a8 = 28;
            *(void *)a7 = 0;
            *(void *)(a7 + 8) = 0;
            *(_DWORD *)(a7 + 24) = 0;
            *(void *)(a7 + 16) = 0;
            *(_WORD *)a7 = 7708;
            *(_OWORD *)(a7 + 8) = *(_OWORD *)(msg_control + 3);
            if (*(unsigned __int8 *)(a7 + 8) == 254)
            {
              if ((*(unsigned char *)(a7 + 9) & 0xC0) == 0x80) {
                unsigned int v30 = msg_control[7];
              }
              else {
                unsigned int v30 = 0;
              }
            }
            *(_DWORD *)(a7 + 24) = v30;
          }
          *(_WORD *)(a7 + 2) = v28;
          unsigned int v23 = -1;
LABEL_40:
          uint64_t v32 = (unsigned int *)((char *)msg_control + ((*msg_control + 3) & 0x1FFFFFFFCLL));
          if (v32 + 3 <= v27)
          {
            BOOL v33 = v32 == msg_control;
          }
          else
          {
            uint64_t v32 = 0;
            BOOL v33 = 1;
          }
          msg_control = v32;
        }
        while (!v33);
      }
      if (dword_10008C2C8 >= 7)
      {
        sub_100033908(7, a2, a3, "@@@@@@ data from readmsg:\n", v17, v18, v19, v20, v34);
        return *(void *)v36;
      }
    }
  }
  return result;
}

uint64_t sub_10003C350(int a1, const void *a2, unint64_t a3, unsigned __int8 *a4, unsigned __int8 *a5, int a6)
{
  long long v81 = 0u;
  long long v82 = 0u;
  long long v79 = 0u;
  long long v80 = 0u;
  long long v77 = 0u;
  long long v78 = 0u;
  sockaddr __s1 = (sockaddr)0;
  long long v76 = 0u;
  socklen_t v49 = 0;
  if (a4[1] != a5[1])
  {
    if (dword_10008FA20)
    {
      uint64_t v17 = ne_log_obj();
      if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR)) {
        sub_1000676DC();
      }
    }
    return 0xFFFFFFFFLL;
  }
  int v11 = a1;
  socklen_t v49 = 128;
  if (getsockname(a1, &__s1, &v49) < 0)
  {
    if (dword_10008FA20)
    {
      uint64_t v18 = ne_log_obj();
      if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR)) {
        sub_1000670FC();
      }
    }
    return 0xFFFFFFFFLL;
  }
  if (dword_10008FA20)
  {
    BOOL v12 = ne_log_obj();
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG)) {
      sub_100067818(&__s1);
    }
    if (dword_10008FA20)
    {
      socklen_t v13 = ne_log_obj();
      if (os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG)) {
        sub_100067794((const sockaddr *)a4);
      }
      if (dword_10008FA20)
      {
        uint64_t v14 = ne_log_obj();
        if (os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG)) {
          sub_100067710((const sockaddr *)a5);
        }
      }
    }
  }
  int v15 = a4[1];
  if (v15 != __s1.sa_family)
  {
    if (dword_10008FA20)
    {
      uint64_t v19 = ne_log_obj();
      if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR)) {
        sub_1000676DC();
      }
    }
    return 0xFFFFFFFFLL;
  }
  if (v15 == 30)
  {
    *(_OWORD *)int v48 = *(_OWORD *)a4;
    *(_OWORD *)&v48[12] = *(_OWORD *)(a4 + 12);
    *(_OWORD *)CFStringRef v47 = *(_OWORD *)a5;
    *(_OWORD *)&v47[12] = *(_OWORD *)(a5 + 12);
    if (v48[8] == 255 || v48[8] == 254 && (v48[9] & 0xC0) == 0x80) {
      int v16 = *(_DWORD *)&v48[24];
    }
    else {
      int v16 = 0;
    }
    *(_DWORD *)&v47[4] = 0;
    *(_DWORD *)&v48[4] = 0;
    *(void *)&v74.msg_namelen = 28;
    *(void *)&v74.msg_iovlen = 1;
    v74.msg_name = v47;
    v73[0] = a2;
    v73[1] = a3;
    v74.msg_iov = (iovec *)v73;
    long long v59 = 0u;
    long long v60 = 0u;
    long long v61 = 0u;
    long long v62 = 0u;
    long long v63 = 0u;
    long long v64 = 0u;
    long long v65 = 0u;
    long long v66 = 0u;
    long long v67 = 0u;
    long long v68 = 0u;
    long long v69 = 0u;
    long long v70 = 0u;
    long long v71 = 0u;
    long long v72 = 0u;
    v74.msg_control = buf;
    v74.msg_flags = 0;
    v74.msg_controllen = 32;
    *(void *)uint8_t buf = 0x2900000020;
    *(_DWORD *)CFStringRef v57 = 46;
    *(_OWORD *)&uint8_t v57[4] = *(_OWORD *)&v48[8];
    int v58 = v16;
    if (dword_10008FA20)
    {
      char v34 = ne_log_obj();
      if (os_log_type_enabled(v34, OS_LOG_TYPE_DEBUG)) {
        sub_100067474((const sockaddr *)v48);
      }
      if (dword_10008FA20)
      {
        msghdr v35 = ne_log_obj();
        if (os_log_type_enabled(v35, OS_LOG_TYPE_DEBUG)) {
          sub_1000673E8((const sockaddr *)v47);
        }
      }
    }
    if (a6 >= 1)
    {
      int v36 = 0;
      while (1)
      {
        socklen_t v49 = sendmsg(v11, &v74, 0);
        if ((v49 & 0x80000000) != 0)
        {
          if (dword_10008FA20)
          {
            unsigned int v37 = ne_log_obj();
            if (os_log_type_enabled(v37, OS_LOG_TYPE_ERROR)) {
              sub_100067394();
            }
          }
          if (*__error() != 65 && *__error() != 50 && *__error() != 51) {
            return 0xFFFFFFFFLL;
          }
          socklen_t v49 = 0;
        }
        if (dword_10008FA20)
        {
          int v38 = ne_log_obj();
          if (os_log_type_enabled(v38, OS_LOG_TYPE_DEBUG))
          {
            socklen_t v39 = v49;
            sub_10003CAE4((const sockaddr *)a5);
            *(_DWORD *)__int16 v50 = 67109634;
            int v51 = v36 + 1;
            __int16 v52 = 1024;
            socklen_t v53 = v39;
            __int16 v54 = 2080;
            uint64_t v55 = &qword_10008CFE8;
            _os_log_debug_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_DEBUG, "%d times of %d bytes message will be sent to %s\n", v50, 0x18u);
          }
        }
        if (a6 == ++v36) {
          return v49;
        }
      }
    }
    return v49;
  }
  int v24 = memcmp(&__s1, a4, *a4);
  if (!v24) {
    goto LABEL_39;
  }
  *(_DWORD *)uint8_t buf = 1;
  int v25 = socket(v15, 2, 0);
  if (v25 < 0)
  {
    if (dword_10008FA20)
    {
      long long v41 = ne_log_obj();
      if (os_log_type_enabled(v41, OS_LOG_TYPE_ERROR)) {
        sub_100066FFC();
      }
    }
    return 0xFFFFFFFFLL;
  }
  int v11 = v25;
  char v45 = 4;
  if (fcntl(v25, 4) == -1)
  {
    if (dword_10008FA20)
    {
      uint64_t v26 = ne_log_obj();
      if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR)) {
        sub_1000676A8();
      }
    }
  }
  if (setsockopt(v11, 0xFFFF, 512, buf, 4u) < 0)
  {
    if (dword_10008FA20)
    {
      long long v42 = ne_log_obj();
      if (os_log_type_enabled(v42, OS_LOG_TYPE_ERROR)) {
        sub_1000675A8();
      }
    }
    goto LABEL_97;
  }
  uint64_t v27 = a4[1];
  if (v27 == 30)
  {
    if (setsockopt(v11, 41, 42, buf, 4u) < 0)
    {
      if (dword_10008FA20)
      {
        long long v44 = ne_log_obj();
        if (os_log_type_enabled(v44, OS_LOG_TYPE_ERROR)) {
          sub_10005F164();
        }
      }
      goto LABEL_97;
    }
    uint64_t v27 = a4[1];
  }
  if ((sub_10003BE80(v11, v27) & 0x80000000) != 0) {
    goto LABEL_97;
  }
  if (bind(v11, (const sockaddr *)a4, *a4) < 0)
  {
    if (dword_10008FA20)
    {
      long long v43 = ne_log_obj();
      if (os_log_type_enabled(v43, OS_LOG_TYPE_ERROR)) {
        sub_100067628();
      }
    }
LABEL_97:
    close(v11);
    return 0xFFFFFFFFLL;
  }
LABEL_39:
  if (dword_10008C2C8 >= 7) {
    sub_100033908(7, (uint64_t)a2, a3, "@@@@@@ data being sent:\n", v20, v21, v22, v23, v45);
  }
  if (a6 < 1)
  {
LABEL_81:
    if (v24) {
      close(v11);
    }
    return v49;
  }
  int v28 = 0;
  int v46 = v24;
  while (1)
  {
    socklen_t v49 = sendto(v11, a2, a3, 0, (const sockaddr *)a5, *a5);
    int v29 = dword_10008FA20;
    if ((v49 & 0x80000000) != 0) {
      break;
    }
LABEL_54:
    if (v29)
    {
      uint64_t v32 = ne_log_obj();
      if (os_log_type_enabled(v32, OS_LOG_TYPE_DEBUG))
      {
        socklen_t v33 = v49;
        sub_10003CAE4((const sockaddr *)a5);
        *(_DWORD *)uint8_t buf = 67109634;
        *(_DWORD *)&uint8_t buf[4] = v28 + 1;
        *(_WORD *)CFStringRef v57 = 1024;
        *(_DWORD *)&v57[2] = v33;
        int v24 = v46;
        *(_WORD *)&v57[6] = 2080;
        *(void *)&v57[8] = &qword_10008CFE8;
        _os_log_debug_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_DEBUG, "%d times of %d bytes message will be sent to %s\n", buf, 0x18u);
      }
    }
    if (a6 == ++v28) {
      goto LABEL_81;
    }
  }
  if (dword_10008FA20)
  {
    unsigned int v30 = ne_log_obj();
    if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR)) {
      sub_100067554();
    }
  }
  if (*__error() == 65 || *__error() == 50 || *__error() == 51)
  {
    if (dword_10008FA20)
    {
      uint64_t v31 = ne_log_obj();
      if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR)) {
        sub_100067500();
      }
    }
    socklen_t v49 = 0;
    int v29 = dword_10008FA20;
    goto LABEL_54;
  }
  if (v24) {
    goto LABEL_97;
  }
  return 0xFFFFFFFFLL;
}

uint64_t *sub_10003CAE4(const sockaddr *a1)
{
  if (a1)
  {
    if (a1->sa_family)
    {
      if (getnameinfo(a1, a1->sa_len, v3, 0x401u, v2, 0x20u, 10))
      {
        __strlcpy_chk();
        __strlcpy_chk();
      }
      snprintf((char *)&qword_10008CFE8, 0x42BuLL, "%s[%s]", v3, v2);
    }
    else
    {
      strcpy((char *)&qword_10008CFE8, "anonymous");
    }
  }
  else
  {
    LOBYTE(qword_10008CFE8) = 0;
  }
  return &qword_10008CFE8;
}

unsigned char *sub_10003CBF4(char a1)
{
  uint64_t v2 = malloc_type_calloc(1uLL, 0x80uLL, 0x1000040AE2C30F4uLL);
  uint64_t v3 = v2;
  if (v2)
  {
    *uint64_t v2 = a1;
  }
  else if (dword_10008FA20)
  {
    int v4 = ne_log_obj();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR)) {
      sub_10006789C();
    }
  }
  return v3;
}

void *sub_10003CC74()
{
  uint64_t v0 = malloc_type_calloc(1uLL, 0x80uLL, 0x1000040AE2C30F4uLL);
  if (v0)
  {
    __memcpy_chk();
  }
  else if (dword_10008FA20)
  {
    BOOL v1 = ne_log_obj();
    if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR)) {
      sub_10006789C();
    }
  }
  return v0;
}

uint64_t *sub_10003CD04(const sockaddr *a1, int a2)
{
  if (a1)
  {
    if (a1->sa_family)
    {
      if (getnameinfo(a1, a1->sa_len, v5, 0x401u, v4, 0x20u, 10))
      {
        __strlcpy_chk();
        __strlcpy_chk();
      }
      snprintf((char *)&qword_10008D413, 0x42BuLL, "%s/%d[%s]", v5, a2, v4);
    }
    else
    {
      strcpy((char *)&qword_10008D413, "anonymous");
    }
  }
  else
  {
    LOBYTE(qword_10008D413) = 0;
  }
  return &qword_10008D413;
}

char *sub_10003CE24(const sockaddr *a1)
{
  if (a1)
  {
    if (getnameinfo(a1, a1->sa_len, v2, 0x401u, 0, 0, 10)) {
      __strlcpy_chk();
    }
    snprintf(&byte_10008D83E, 0x42BuLL, "%s", v2);
  }
  else
  {
    byte_10008D83E = 0;
  }
  return &byte_10008D83E;
}

int *sub_10003CEE4(uint64_t a1)
{
  if (a1)
  {
    if (*(_OWORD *)a1 == 0)
    {
      dword_10008DC6C = 7958113;
    }
    else
    {
      sub_10003CE24((const sockaddr *)a1);
      snprintf((char *)&dword_10008DC6C, 0x40BuLL, "%s", &byte_10008D83E);
      size_t v2 = strlen((const char *)&dword_10008DC6C);
      snprintf((char *)&dword_10008DC6C + v2, 1035 - v2, "/%ld", *(void *)(a1 + 128));
    }
  }
  else
  {
    LOBYTE(dword_10008DC6C) = 0;
  }
  return &dword_10008DC6C;
}

char *sub_10003CFA8(const char *a1, uint64_t a2, uint64_t a3)
{
  sub_10003CEE4(a2);
  int v5 = strdup((const char *)dword_10008DC6C);
  sub_10003CEE4(a3);
  unsigned int v6 = strdup((const char *)dword_10008DC6C);
  if (!v5)
  {
    if (dword_10008FA20)
    {
      size_t v9 = ne_log_obj();
      if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR)) {
        goto LABEL_9;
      }
    }
    goto LABEL_10;
  }
  BOOL v7 = v6;
  if (!v6)
  {
    if (dword_10008FA20)
    {
      BOOL v10 = ne_log_obj();
      if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR)) {
LABEL_9:
      }
        sub_10005ED40();
    }
LABEL_10:
    exit(1);
  }
  snprintf(byte_10008E077, 0x8BAuLL, a1, v5, v6);
  free(v5);
  free(v7);
  return byte_10008E077;
}

char *sub_10003D0A8(const char *a1, const sockaddr *a2, sockaddr *a3)
{
  uint64_t v3 = a3;
  if (!a2)
  {
    int v5 = 0;
    if (!a3) {
      goto LABEL_7;
    }
    goto LABEL_6;
  }
  sub_10003CAE4(a2);
  int v5 = strdup((const char *)&qword_10008CFE8);
  if (!v5)
  {
    if (dword_10008FA20)
    {
      size_t v9 = ne_log_obj();
      if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR)) {
LABEL_22:
      }
        sub_10005ED40();
    }
LABEL_23:
    exit(1);
  }
  if (v3)
  {
LABEL_6:
    sub_10003CAE4(v3);
    uint64_t v3 = (sockaddr *)strdup((const char *)&qword_10008CFE8);
    if (v3) {
      goto LABEL_7;
    }
    if (dword_10008FA20)
    {
      BOOL v10 = ne_log_obj();
      if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR)) {
        goto LABEL_22;
      }
    }
    goto LABEL_23;
  }
LABEL_7:
  unsigned int v6 = "[null]";
  if (v5) {
    BOOL v7 = v5;
  }
  else {
    BOOL v7 = "[null]";
  }
  if (v3) {
    unsigned int v6 = (const char *)v3;
  }
  snprintf(byte_10008E931, 0x8BAuLL, a1, v7, v6);
  if (v5) {
    free(v5);
  }
  if (v3) {
    free(v3);
  }
  return byte_10008E931;
}

unsigned char *sub_10003D1DC(const char *a1, const char *a2)
{
  size_t v2 = a2;
  uint64_t v17 = 0;
  memset(&v18, 0, sizeof(v18));
  v18.ai_socktype = 2;
  v18.ai_flags = 4;
  int v4 = getaddrinfo(a1, a2, &v18, &v17);
  if (v4)
  {
    if (dword_10008FA20)
    {
      int v5 = v4;
      unsigned int v6 = ne_log_obj();
      if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
      {
        if (v2) {
          BOOL v7 = ",";
        }
        else {
          BOOL v7 = (const char *)&unk_100081F6D;
        }
        if (!v2) {
          size_t v2 = (const char *)&unk_100081F6D;
        }
        int v8 = gai_strerror(v5);
        *(_DWORD *)uint8_t buf = 136315906;
        uint64_t v20 = a1;
        __int16 v21 = 2080;
        uint64_t v22 = v7;
        __int16 v23 = 2080;
        int v24 = v2;
        __int16 v25 = 2080;
        uint64_t v26 = v8;
        _os_log_error_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, "getaddrinfo(%s%s%s): %s\n", buf, 0x2Au);
      }
    }
    return 0;
  }
  if (v17->ai_next) {
    BOOL v9 = dword_10008FA20 == 0;
  }
  else {
    BOOL v9 = 1;
  }
  if (!v9)
  {
    BOOL v10 = ne_log_obj();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      int v11 = ",";
      BOOL v12 = (const char *)&unk_100081F6D;
      *(_DWORD *)uint8_t buf = 136315650;
      uint64_t v20 = a1;
      if (!v2) {
        int v11 = (const char *)&unk_100081F6D;
      }
      __int16 v21 = 2080;
      if (v2) {
        BOOL v12 = v2;
      }
      uint64_t v22 = v11;
      __int16 v23 = 2080;
      int v24 = v12;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "getaddrinfo(%s%s%s): resolved to multiple address, taking the first one\n", buf, 0x20u);
    }
  }
  socklen_t v13 = sub_10003CBF4(128);
  if (!v13)
  {
    if (dword_10008FA20)
    {
      int v15 = ne_log_obj();
      if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR)) {
        sub_100057CE8();
      }
    }
    freeaddrinfo(v17);
    return 0;
  }
  uint64_t v14 = v13;
  memcpy(v13, v17->ai_addr, v17->ai_addrlen);
  freeaddrinfo(v17);
  return v14;
}

void sub_10003D410(char *a1, unsigned __int8 *a2, unint64_t a3)
{
  int v4 = a2[1];
  if (v4 == 30)
  {
    int v5 = a1 + 8;
    unsigned int v6 = 16;
  }
  else
  {
    if (v4 != 2)
    {
      if (dword_10008FA20)
      {
        BOOL v9 = ne_log_obj();
        if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR)) {
          sub_10006791C();
        }
      }
LABEL_17:
      exit(1);
    }
    int v5 = a1 + 4;
    unsigned int v6 = 4;
  }
  if (8 * v6 < a3)
  {
    if (dword_10008FA20)
    {
      int v8 = ne_log_obj();
      if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR)) {
        sub_100067988();
      }
    }
    goto LABEL_17;
  }
  memcpy(a1, a2, *a2);
  v5[a3 >> 3] &= 0xFF00u >> (a3 & 7);
  unint64_t v7 = (a3 >> 3) + 1;
  if (v7 < v6)
  {
    bzero(&v5[v7], ~(a3 >> 3) + v6);
  }
}

uint64_t sub_10003D554(unint64_t *__s1, sockaddr *a2)
{
  memset(v23, 0, sizeof(v23));
  if (__s1 && a2)
  {
    uint64_t result = memcmp(__s1, &unk_10006E758, 0x88uLL);
    if (!result) {
      return result;
    }
    if (*((unsigned __int8 *)__s1 + 1) == a2->sa_family)
    {
      int v5 = sub_10003D80C((uint64_t)__s1);
      int v6 = sub_10003D80C((uint64_t)a2);
      int v7 = 0;
      if (!v5 || !v6)
      {
LABEL_9:
        sub_10003D410((char *)v23, &a2->sa_len, __s1[16]);
        if (dword_10008C2C8 < 7) {
          goto LABEL_17;
        }
        sub_10003CEE4((uint64_t)__s1);
        int v8 = strdup((const char *)dword_10008DC6C);
        sub_10003CE24(a2);
        BOOL v9 = strdup(&byte_10008D83E);
        sub_10003CE24(v23);
        BOOL v10 = strdup(&byte_10008D83E);
        if (v8)
        {
          if (v9)
          {
            int v11 = v10;
            if (v10)
            {
              if (dword_10008FA20)
              {
                BOOL v12 = ne_log_obj();
                if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG))
                {
                  int v17 = 136315650;
                  addrinfo v18 = v8;
                  __int16 v19 = 2080;
                  uint64_t v20 = v9;
                  __int16 v21 = 2080;
                  uint64_t v22 = v11;
                  _os_log_debug_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEBUG, "naddr=%s, saddr=%s (masked=%s)\n", (uint8_t *)&v17, 0x20u);
                }
              }
              free(v8);
              free(v9);
              free(v11);
LABEL_17:
              if (!sub_10003B8E4((unint64_t)v23, (unint64_t)__s1)) {
                return (*((_DWORD *)__s1 + 32) + v7);
              }
              return 0xFFFFFFFFLL;
            }
            if (dword_10008FA20)
            {
              int v16 = ne_log_obj();
              if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR)) {
                goto LABEL_32;
              }
            }
LABEL_33:
            exit(1);
          }
          if (!dword_10008FA20) {
            goto LABEL_33;
          }
          int v15 = ne_log_obj();
          if (!os_log_type_enabled(v15, OS_LOG_TYPE_ERROR)) {
            goto LABEL_33;
          }
        }
        else
        {
          if (!dword_10008FA20) {
            goto LABEL_33;
          }
          uint64_t v14 = ne_log_obj();
          if (!os_log_type_enabled(v14, OS_LOG_TYPE_ERROR)) {
            goto LABEL_33;
          }
        }
LABEL_32:
        sub_10005ED40();
        goto LABEL_33;
      }
      if (v5 == v6)
      {
        int v7 = 1;
        goto LABEL_9;
      }
    }
  }
  else if (dword_10008FA20)
  {
    socklen_t v13 = ne_log_obj();
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR)) {
      sub_100067A10();
    }
  }
  return 0xFFFFFFFFLL;
}

uint64_t sub_10003D80C(uint64_t a1)
{
  if (!a1) {
    return 0xFFFFLL;
  }
  int v1 = *(unsigned __int8 *)(a1 + 1);
  if (v1 == 30 || v1 == 2)
  {
    unsigned int v2 = *(unsigned __int16 *)(a1 + 2);
  }
  else
  {
    if (dword_10008FA20)
    {
      int v4 = ne_log_obj();
      if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR)) {
        sub_100067A94();
      }
    }
    unsigned int v2 = 0xFFFF;
  }
  return __rev16(v2);
}

uint64_t sub_10003D894(uint64_t result)
{
  if (result)
  {
    int v1 = *(unsigned __int8 *)(result + 1);
    if (v1 == 30 || v1 == 2)
    {
      result += 2;
    }
    else
    {
      if (dword_10008FA20)
      {
        unsigned int v2 = ne_log_obj();
        if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR)) {
          sub_100067A94();
        }
      }
      return 0;
    }
  }
  return result;
}

_WORD *sub_10003D910(uint64_t a1, unsigned int a2)
{
  uint64_t result = (_WORD *)sub_10003D894(a1);
  if (result) {
    *uint64_t result = __rev16(a2);
  }
  return result;
}

char *sub_10003D954(uint64_t a1, unint64_t a2)
{
  size_t v4 = (a2 >> 3) + 2 * a2 + 10;
  int v5 = (char *)malloc_type_malloc(v4, 0xEB1664DCuLL);
  if (v5)
  {
    if (a2)
    {
      uint64_t v6 = 0;
      uint64_t v7 = 0;
      do
      {
        snprintf(&v5[v6], v4 - v6, "%02x", *(unsigned __int8 *)(a1 + v7));
        uint64_t v8 = v6 + 2;
        if ((~(_BYTE)v7 & 7) == 0)
        {
          v5[v8] = 32;
          uint64_t v8 = v6 + 3;
          v5[v6 + 3] = 0;
        }
        ++v7;
        uint64_t v6 = v8;
      }
      while (a2 != v7);
    }
    else
    {
      uint64_t v8 = 0;
    }
    v5[v8] = 0;
  }
  return v5;
}

unsigned char *sub_10003DA30(unsigned char *a1, int a2, void *a3)
{
  LOBYTE(v3) = *a1;
  if (!*a1) {
    return 0;
  }
  unint64_t v7 = 0;
  uint64_t v8 = 1;
  do
  {
    if ((v3 & 0x80) != 0)
    {
      if (!__maskrune((char)v3, 0x4000uLL)) {
        return 0;
      }
    }
    else
    {
      __uint32_t v9 = _DefaultRuneLocale.__runetype[(char)v3];
      if ((v9 & 0x10000) != 0)
      {
        ++v7;
      }
      else if ((v9 & 0x4000) == 0)
      {
        return 0;
      }
    }
    int v3 = a1[v8++];
  }
  while (v3);
  BOOL v10 = 0;
  if (v7)
  {
    if ((v7 & 1) == 0)
    {
      int v11 = malloc_type_malloc(v7 >> 1, 0x66E920C4uLL);
      BOOL v10 = v11;
      if (v11)
      {
        int v12 = *a1;
        if (*a1)
        {
          uint64_t v13 = 0;
          int v14 = 0;
          int v15 = a1 + 1;
          int v16 = v11;
          do
          {
            if ((v12 & 0x80) == 0 && (_DefaultRuneLocale.__runetype[v12] & 0x10000) != 0)
            {
              if (v14)
              {
                __str[1] = v12;
                __str[2] = 0;
                char v17 = strtol(__str, 0, a2);
                int v14 = 0;
                *v16++ = v17;
                ++v13;
              }
              else
              {
                __str[0] = v12;
                int v14 = 1;
              }
            }
            int v18 = *v15++;
            int v12 = v18;
          }
          while (v18);
        }
        else
        {
          uint64_t v13 = 0;
        }
        *a3 = v13;
      }
    }
  }
  return v10;
}

char *sub_10003DB70(int a1)
{
  return byte_10008F1EB;
}

const char *sub_10003DBB8(uint64_t a1, uint64_t a2, int a3)
{
  if (a3 > 5506)
  {
    if (a3 <= 6591)
    {
      if (a3 <= 6343)
      {
        if (a3 > 6335)
        {
          if (a3 == 6336) {
            return "IKEv1 quick I start";
          }
          if (a3 == 6338) {
            return "IKEv1 quick I msg2 rcvd";
          }
        }
        else
        {
          if (a3 == 5507) {
            return "IKEv1 agg R msg3 rcvd";
          }
          if (a3 == 5538) {
            return "IKEv1 agg R msg2 sent";
          }
        }
      }
      else if (a3 <= 6368)
      {
        if (a3 == 6344) {
          return "IKEv1 quick I addsa";
        }
        if (a3 == 6352) {
          return "IKEv1 quick I getspi done";
        }
      }
      else
      {
        switch(a3)
        {
          case 6369:
            return "IKEv1 quick I msg1 sent";
          case 6371:
            return "IKEv1 quick I msg3 sent";
          case 6384:
            return "IKEv1 quick I getspi sent";
        }
      }
    }
    else
    {
      if (a3 <= 6625)
      {
        switch(a3)
        {
          case 6592:
            uint64_t result = "IKEv1 quick R start";
            break;
          case 6593:
            uint64_t result = "IKEv1 quick R msg1 rcvd";
            break;
          case 6594:
          case 6597:
          case 6598:
          case 6599:
            return "???";
          case 6595:
            uint64_t result = "IKEv1 quick R msg3 rcvd";
            break;
          case 6596:
            uint64_t result = "IKEv1 quick R commit";
            break;
          case 6600:
            uint64_t result = "IKEv1 quick R addsa";
            break;
          default:
            if (a3 != 6608) {
              return "???";
            }
            uint64_t result = "IKEv1 quick R getspi done";
            break;
        }
        return result;
      }
      if (a3 > 10239)
      {
        switch(a3)
        {
          case 18432:
            return "Phase 2 expired";
          case 17408:
            return "Phase 1 expired";
          case 10240:
            return "Phase 2 established";
        }
      }
      else
      {
        switch(a3)
        {
          case 6626:
            return "IKEv1 quick R msg2 sent";
          case 6640:
            return "IKEv1 quick R getspi sent";
          case 9216:
            return "Phase 1 Established";
        }
      }
    }
    return "???";
  }
  if (a3 > 5280)
  {
    if (a3 > 5473)
    {
      if (a3 > 5503)
      {
        if (a3 == 5504) {
          return "IKEv1 agg R start";
        }
        if (a3 == 5505) {
          return "IKEv1 agg R msg1 rcvd";
        }
      }
      else
      {
        if (a3 == 5474) {
          return "IKEv1 ident R msg2 sent";
        }
        if (a3 == 5476) {
          return "IKEv1 ident R msg4 sent";
        }
      }
      return "???";
    }
    switch(a3)
    {
      case 5440:
        return "IKEv1 ident R start";
      case 5441:
        return "IKEv1 ident R msg1 rcvd";
      case 5442:
      case 5444:
        return "???";
      case 5443:
        return "IKEv1 ident R msg3 rcvd";
      case 5445:
        return "IKEv1 ident R msg5 rcvd";
      default:
        if (a3 == 5281)
        {
          uint64_t result = "IKEv1 agg I msg1 sent";
        }
        else
        {
          if (a3 != 5283) {
            return "???";
          }
          uint64_t result = "IKEv1 agg I msg3 sent";
        }
        break;
    }
  }
  else
  {
    if (a3 > 5216)
    {
      if (a3 <= 5220)
      {
        if (a3 == 5217) {
          return "IKEv1 ident I msg1 sent";
        }
        if (a3 == 5219) {
          return "IKEv1 ident I msg3 sent";
        }
      }
      else
      {
        switch(a3)
        {
          case 5221:
            return "IKEv1 ident I msg5 sent";
          case 5248:
            return "IKEv1 agg I start";
          case 5250:
            return "IKEv1 agg I msg2 rcvd";
        }
      }
      return "???";
    }
    switch(a3)
    {
      case 5184:
        uint64_t result = "IKEv1 ident I start";
        break;
      case 5185:
      case 5187:
      case 5189:
        return "???";
      case 5186:
        uint64_t result = "IKEv1 ident I msg2 rcvd";
        break;
      case 5188:
        uint64_t result = "IKEv1 ident I msg4 rcvd";
        break;
      case 5190:
        uint64_t result = "IKEv1 ident I msg6 rcvd";
        break;
      default:
        if (a3 != 63) {
          return "???";
        }
        uint64_t result = "IKEv1 info";
        break;
    }
  }
  return result;
}

char *sub_10003E074(int a1)
{
  uint64_t v1 = 0;
  while (dword_100089128[v1] != a1)
  {
    v1 += 6;
    if (v1 == 66)
    {
      unsigned int v2 = byte_10008F1EB;
      snprintf(byte_10008F1EB, 0x14uLL, "%d", a1);
      return v2;
    }
  }
  return *(char **)&dword_100089128[v1 + 2];
}

char *sub_10003E0EC(int a1)
{
  uint64_t v1 = 0;
  while (dword_100089230[v1] != a1)
  {
    v1 += 6;
    if (v1 == 60)
    {
      unsigned int v2 = byte_10008F1EB;
      snprintf(byte_10008F1EB, 0x14uLL, "%d", a1);
      return v2;
    }
  }
  return *(char **)&dword_100089230[v1 + 2];
}

char *sub_10003E164(int a1)
{
  uint64_t v1 = 0;
  while (dword_100089320[v1] != a1)
  {
    v1 += 6;
    if (v1 == 216)
    {
      unsigned int v2 = byte_10008F1EB;
      snprintf(byte_10008F1EB, 0x14uLL, "%d", a1);
      return v2;
    }
  }
  return *(char **)&dword_100089320[v1 + 2];
}

char *sub_10003E1DC(int a1)
{
  uint64_t v1 = 0;
  while (dword_100089680[v1] != a1)
  {
    v1 += 6;
    if (v1 == 126)
    {
      unsigned int v2 = byte_10008F1EB;
      snprintf(byte_10008F1EB, 0x14uLL, "%d", a1);
      return v2;
    }
  }
  return *(char **)&dword_100089680[v1 + 2];
}

char *sub_10003E254(int a1)
{
  uint64_t v1 = 0;
  while (dword_100089878[v1] != a1)
  {
    v1 += 6;
    if (v1 == 216)
    {
      unsigned int v2 = byte_10008F1EB;
      snprintf(byte_10008F1EB, 0x14uLL, "%d", a1);
      return v2;
    }
  }
  return *(char **)&dword_100089878[v1 + 2];
}

char *sub_10003E2CC(int a1)
{
  uint64_t v1 = 0;
  while (dword_100089BD8[v1] != a1)
  {
    v1 += 6;
    if (v1 == 24)
    {
      unsigned int v2 = byte_10008F1EB;
      snprintf(byte_10008F1EB, 0x14uLL, "%d", a1);
      return v2;
    }
  }
  return *(char **)&dword_100089BD8[v1 + 2];
}

char *sub_10003E344(int a1)
{
  uint64_t v1 = 0;
  while (dword_100089C38[v1] != a1)
  {
    v1 += 6;
    if (v1 == 24)
    {
      unsigned int v2 = byte_10008F1EB;
      snprintf(byte_10008F1EB, 0x14uLL, "%d", a1);
      return v2;
    }
  }
  return *(char **)&dword_100089C38[v1 + 2];
}

const char *sub_10003E3BC(int a1)
{
  if (a1 == 1) {
    return "IKE";
  }
  uint64_t v1 = byte_10008F1EB;
  snprintf(byte_10008F1EB, 0x14uLL, "%d", a1);
  return v1;
}

char *sub_10003E418(int a1)
{
  uint64_t v1 = 0;
  while (dword_100089C98[v1] != a1)
  {
    v1 += 6;
    if (v1 == 36)
    {
      unsigned int v2 = byte_10008F1EB;
      snprintf(byte_10008F1EB, 0x14uLL, "%d", a1);
      return v2;
    }
  }
  return *(char **)&dword_100089C98[v1 + 2];
}

char *sub_10003E490(int a1)
{
  uint64_t v1 = 0;
  while (dword_100089D28[v1] != a1)
  {
    v1 += 6;
    if (v1 == 78)
    {
      unsigned int v2 = byte_10008F1EB;
      snprintf(byte_10008F1EB, 0x14uLL, "%d", a1);
      return v2;
    }
  }
  return *(char **)&dword_100089D28[v1 + 2];
}

char *sub_10003E508(int a1)
{
  uint64_t v1 = 0;
  while (dword_100089E60[v1] != a1)
  {
    v1 += 6;
    if (v1 == 18)
    {
      unsigned int v2 = byte_10008F1EB;
      snprintf(byte_10008F1EB, 0x14uLL, "%d", a1);
      return v2;
    }
  }
  return *(char **)&dword_100089E60[v1 + 2];
}

char *sub_10003E580(int a1, uint64_t a2)
{
  uint64_t v2 = 0;
  while (dword_100089C38[v2] != a1)
  {
    v2 += 6;
    if (v2 == 24)
    {
      snprintf(byte_10008F1EB, 0x14uLL, "%d", a2);
      return byte_10008F1EB;
    }
  }
  size_t v4 = *(uint64_t (**)(uint64_t))&dword_100089C38[v2 + 4];

  return (char *)v4(a2);
}

char *sub_10003E618(int a1)
{
  uint64_t v1 = 0;
  while (dword_100089EA8[v1] != a1)
  {
    v1 += 6;
    if (v1 == 54)
    {
      uint64_t v2 = byte_10008F1EB;
      snprintf(byte_10008F1EB, 0x14uLL, "%d", a1);
      return v2;
    }
  }
  return *(char **)&dword_100089EA8[v1 + 2];
}

char *sub_10003E690(int a1)
{
  uint64_t v1 = 0;
  for (char i = 1; ; char i = 0)
  {
    char v3 = i;
    if (*((_DWORD *)&unk_10008A790 + 6 * v1) == a1) {
      break;
    }
    uint64_t v1 = 1;
    if ((v3 & 1) == 0)
    {
      size_t v4 = byte_10008F1EB;
      snprintf(byte_10008F1EB, 0x14uLL, "%d", a1);
      return v4;
    }
  }
  return (char *)*((void *)&unk_10008A790 + 3 * v1 + 1);
}

char *sub_10003E71C(int a1)
{
  uint64_t v1 = 0;
  while (dword_100089F80[v1] != a1)
  {
    v1 += 6;
    if (v1 == 42)
    {
      uint64_t v2 = byte_10008F1EB;
      snprintf(byte_10008F1EB, 0x14uLL, "%d", a1);
      return v2;
    }
  }
  return *(char **)&dword_100089F80[v1 + 2];
}

char *sub_10003E794(int a1)
{
  uint64_t v1 = 0;
  while (dword_10008A028[v1] != a1)
  {
    v1 += 6;
    if (v1 == 42)
    {
      uint64_t v2 = byte_10008F1EB;
      snprintf(byte_10008F1EB, 0x14uLL, "%d", a1);
      return v2;
    }
  }
  return *(char **)&dword_10008A028[v1 + 2];
}

char *sub_10003E80C(int a1, uint64_t a2)
{
  uint64_t v2 = 0;
  for (char i = &off_100089EB8; *((_DWORD *)i - 4) != a1 || ((0x1E6uLL >> v2) & 1) != 0; i += 3)
  {
    if (++v2 == 9)
    {
      snprintf(byte_10008F1EB, 0x14uLL, "%d", a2);
      return byte_10008F1EB;
    }
  }
  int v5 = *i;

  return (char *)((uint64_t (*)(uint64_t))v5)(a2);
}

char *sub_10003E8B0(int a1)
{
  uint64_t v1 = 0;
  while (dword_10008A0D0[v1] != a1)
  {
    v1 += 6;
    if (v1 == 66)
    {
      uint64_t v2 = byte_10008F1EB;
      snprintf(byte_10008F1EB, 0x14uLL, "%d", a1);
      return v2;
    }
  }
  return *(char **)&dword_10008A0D0[v1 + 2];
}

char *sub_10003E928(int a1)
{
  uint64_t v1 = 0;
  while (dword_10008A1D8[v1] != a1)
  {
    v1 += 6;
    if (v1 == 108)
    {
      uint64_t v2 = byte_10008F1EB;
      snprintf(byte_10008F1EB, 0x14uLL, "%d", a1);
      return v2;
    }
  }
  return *(char **)&dword_10008A1D8[v1 + 2];
}

char *sub_10003E9A0(int a1)
{
  uint64_t v1 = 0;
  while (dword_10008A388[v1] != a1)
  {
    v1 += 6;
    if (v1 == 42)
    {
      uint64_t v2 = byte_10008F1EB;
      snprintf(byte_10008F1EB, 0x14uLL, "%d", a1);
      return v2;
    }
  }
  return *(char **)&dword_10008A388[v1 + 2];
}

char *sub_10003EA18(int a1)
{
  uint64_t v1 = 0;
  while (dword_10008A430[v1] != a1)
  {
    v1 += 6;
    if (v1 == 48)
    {
      uint64_t v2 = byte_10008F1EB;
      snprintf(byte_10008F1EB, 0x14uLL, "%d", a1);
      return v2;
    }
  }
  return *(char **)&dword_10008A430[v1 + 2];
}

char *sub_10003EA90(int a1)
{
  uint64_t v1 = 0;
  while (dword_10008A4F0[v1] != a1)
  {
    v1 += 6;
    if (v1 == 90)
    {
      uint64_t v2 = byte_10008F1EB;
      snprintf(byte_10008F1EB, 0x14uLL, "%d", a1);
      return v2;
    }
  }
  return *(char **)&dword_10008A4F0[v1 + 2];
}

char *sub_10003EB08(int a1)
{
  uint64_t v1 = 0;
  while (dword_10008A658[v1] != a1)
  {
    v1 += 6;
    if (v1 == 60)
    {
      uint64_t v2 = byte_10008F1EB;
      snprintf(byte_10008F1EB, 0x14uLL, "%d", a1);
      return v2;
    }
  }
  return *(char **)&dword_10008A658[v1 + 2];
}

char *sub_10003EB80(int a1)
{
  uint64_t v1 = 0;
  while (dword_10008A748[v1] != a1)
  {
    v1 += 6;
    if (v1 == 18)
    {
      uint64_t v2 = byte_10008F1EB;
      snprintf(byte_10008F1EB, 0x14uLL, "%d", a1);
      return v2;
    }
  }
  return *(char **)&dword_10008A748[v1 + 2];
}

char *sub_10003EBF8(int a1)
{
  uint64_t v1 = 0;
  for (char i = 1; ; char i = 0)
  {
    char v3 = i;
    if (*((_DWORD *)&unk_10008A790 + 6 * v1) == a1) {
      break;
    }
    uint64_t v1 = 1;
    if ((v3 & 1) == 0)
    {
      size_t v4 = byte_10008F1EB;
      snprintf(byte_10008F1EB, 0x14uLL, "%d", a1);
      return v4;
    }
  }
  return (char *)*((void *)&unk_10008A790 + 3 * v1 + 1);
}

char *sub_10003EC84(int a1, uint64_t a2)
{
  uint64_t v2 = 0;
  for (char i = &off_10008A1E8; *((_DWORD *)i - 4) != a1 || ((0x3FBE0uLL >> v2) & 1) != 0; i += 3)
  {
    if (++v2 == 18)
    {
      snprintf(byte_10008F1EB, 0x14uLL, "%d", a2);
      return byte_10008F1EB;
    }
  }
  int v5 = *i;

  return (char *)((uint64_t (*)(uint64_t))v5)(a2);
}

char *sub_10003ED2C(int a1)
{
  uint64_t v1 = 0;
  while (dword_10008A7C0[v1] != a1)
  {
    v1 += 6;
    if (v1 == 18)
    {
      uint64_t v2 = byte_10008F1EB;
      snprintf(byte_10008F1EB, 0x14uLL, "%d", a1);
      return v2;
    }
  }
  return *(char **)&dword_10008A7C0[v1 + 2];
}

char *sub_10003EDA4(int a1)
{
  uint64_t v1 = 0;
  while (dword_10008A808[v1] != a1)
  {
    v1 += 6;
    if (v1 == 42)
    {
      uint64_t v2 = byte_10008F1EB;
      snprintf(byte_10008F1EB, 0x14uLL, "%d", a1);
      return v2;
    }
  }
  return *(char **)&dword_10008A808[v1 + 2];
}

char *sub_10003EE1C(int a1, uint64_t a2)
{
  uint64_t v2 = 0;
  while (dword_10008A808[v2] != a1)
  {
    v2 += 6;
    if (v2 == 42)
    {
      snprintf(byte_10008F1EB, 0x14uLL, "%d", a2);
      return byte_10008F1EB;
    }
  }
  size_t v4 = *(uint64_t (**)(uint64_t))&dword_10008A808[v2 + 4];

  return (char *)v4(a2);
}

char *sub_10003EEB4(int a1)
{
  uint64_t v1 = 0;
  while (dword_10008A8B0[v1] != a1)
  {
    v1 += 6;
    if (v1 == 138)
    {
      uint64_t v2 = byte_10008F1EB;
      snprintf(byte_10008F1EB, 0x14uLL, "%d", a1);
      return v2;
    }
  }
  return *(char **)&dword_10008A8B0[v1 + 2];
}

char *sub_10003EF2C(int a1)
{
  uint64_t v1 = 0;
  while (dword_10008AAD8[v1] != a1)
  {
    v1 += 6;
    if (v1 == 48)
    {
      uint64_t v2 = byte_10008F1EB;
      snprintf(byte_10008F1EB, 0x14uLL, "%d", a1);
      return v2;
    }
  }
  return *(char **)&dword_10008AAD8[v1 + 2];
}

char *sub_10003EFA4(int a1)
{
  uint64_t v1 = 0;
  for (char i = 1; ; char i = 0)
  {
    char v3 = i;
    if (*((_DWORD *)&unk_10008AB98 + 6 * v1) == a1) {
      break;
    }
    uint64_t v1 = 1;
    if ((v3 & 1) == 0)
    {
      size_t v4 = byte_10008F1EB;
      snprintf(byte_10008F1EB, 0x14uLL, "%d", a1);
      return v4;
    }
  }
  return (char *)*((void *)&unk_10008AB98 + 3 * v1 + 1);
}

const char *sub_10003F030(int a1)
{
  if (a1 <= 16)
  {
    if (a1 == 1) {
      return "icmp";
    }
    if (a1 == 6) {
      return "tcp";
    }
LABEL_12:
    uint64_t v1 = byte_10008F1EB;
    snprintf(byte_10008F1EB, 0x14uLL, "%d", a1);
    return v1;
  }
  if (a1 == 17) {
    return "udp";
  }
  if (a1 == 58) {
    return "icmpv6";
  }
  if (a1 != 255) {
    goto LABEL_12;
  }
  return "any";
}

const char *sub_10003F0E4(int a1)
{
  if (a1 == 1) {
    return "ipsec_doi";
  }
  uint64_t v1 = byte_10008F1EB;
  snprintf(byte_10008F1EB, 0x14uLL, "%d", a1);
  return v1;
}

const char *sub_10003F140(int a1)
{
  if (a1 > 31)
  {
    switch(a1)
    {
      case ' ':
        return "_quick";
      case '!':
        return "_newgrp";
      case '""':
        return "_ackinfo";
      default:
LABEL_14:
        uint64_t v1 = byte_10008F1EB;
        snprintf(byte_10008F1EB, 0x14uLL, "%d", a1);
        break;
    }
  }
  else
  {
    uint64_t v1 = "_none";
    switch(a1)
    {
      case 0:
        return v1;
      case 1:
        uint64_t v1 = "base";
        break;
      case 2:
        uint64_t v1 = "main";
        break;
      case 3:
        uint64_t v1 = "_auth";
        break;
      case 4:
        uint64_t v1 = "aggressive";
        break;
      case 5:
        uint64_t v1 = "_info";
        break;
      default:
        goto LABEL_14;
    }
  }
  return v1;
}

char *sub_10003F254(int a1)
{
  if ((a1 - 1) < 5) {
    return off_10008ABC8[a1 - 1];
  }
  uint64_t v1 = byte_10008F1EB;
  snprintf(byte_10008F1EB, 0x14uLL, "%d", a1);
  return v1;
}

const char *sub_10003F2B8(int a1)
{
  if (!a1) {
    return "off";
  }
  if (a1 == 1) {
    return "on";
  }
  uint64_t v1 = byte_10008F1EB;
  snprintf(byte_10008F1EB, 0x14uLL, "%d", a1);
  return v1;
}

void *sub_10003F324(unsigned __int8 *a1)
{
  uint64_t v2 = malloc_type_malloc(*a1 + 24, 0xC6948EEEuLL);
  if (v2)
  {
    *(_DWORD *)uint64_t v2 = dword_10008FE98 + time(0);
    memcpy(v2 + 3, a1, *a1);
    char v3 = (char *)off_10008C2E0;
    v2[1] = off_10008C2E0;
    size_t v4 = v3 + 16;
    BOOL v5 = v3 == 0;
    off_10008C2E0 = v2;
    uint64_t v6 = &off_10008C2E8;
    if (!v5) {
      uint64_t v6 = v4;
    }
    *uint64_t v6 = v2 + 1;
    v2[2] = &off_10008C2E0;
  }
  return v2;
}

uint64_t sub_10003F3C0(unsigned __int8 *a1, int a2)
{
  if (!dword_10008FE98) {
    return 0;
  }
  time_t v4 = time(0);
  BOOL v5 = *(void **)off_10008C2E8[1];
  if (!v5)
  {
LABEL_12:
    if (a2 && !sub_10003F324(a1))
    {
      if (dword_10008FA20)
      {
        int v12 = ne_log_obj();
        if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR)) {
          sub_100067B00(v12);
        }
      }
      return dword_10008FE98 + time(0);
    }
    return 0;
  }
  time_t v6 = v4;
  while (1)
  {
    if (v6 > *(int *)v5)
    {
      uint64_t v7 = v5[1];
      uint64_t v8 = (void *)v5[2];
      if (v7)
      {
        *(void *)(v7 + 16) = v8;
        uint64_t v8 = (void *)v5[2];
      }
      else
      {
        off_10008C2E8 = (_UNKNOWN **)v5[2];
      }
      *uint64_t v8 = v7;
      free(v5);
      __uint32_t v9 = off_10008C2E8;
      goto LABEL_11;
    }
    if (!sub_10003B8E4((unint64_t)a1, (unint64_t)(v5 + 3))) {
      break;
    }
    __uint32_t v9 = (_UNKNOWN **)v5[2];
LABEL_11:
    BOOL v5 = *(void **)v9[1];
    if (!v5) {
      goto LABEL_12;
    }
  }
  uint64_t result = *(unsigned int *)v5;
  if (a2)
  {
    uint64_t v11 = (int)result - v6 + dword_10008FE98;
    if (v11 >= 10) {
      LODWORD(v11) = 10;
    }
    uint64_t result = (v11 + v6);
    *(_DWORD *)BOOL v5 = result;
  }
  return result;
}

long long *sub_10003F504(int a1)
{
  if (a1 == 19) {
    return &xmmword_10006E7E0;
  }
  uint64_t v2 = 0;
  while (dword_10008C2F0[v2] != a1)
  {
    v2 += 6;
    if (v2 == 120) {
      return 0;
    }
  }
  return *(long long **)&dword_10008C2F0[v2 + 2];
}

double sub_10003F550()
{
  uint64_t v0 = 0;
  size_t v13 = 0;
  int v14 = 0;
  do
  {
    uint64_t v1 = &dword_10008C2F0[v0];
    int v14 = *(const char **)&dword_10008C2F0[v0 + 2];
    size_t v13 = strlen(v14);
    uint64_t v2 = sub_100005FB0((uint64_t)&v13);
    *(void *)&dword_10008C2F0[v0 + 4] = v2;
    if (!v2)
    {
      if (dword_10008FA20)
      {
        char v3 = ne_log_obj();
        if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR)) {
          sub_100067B88(&v11, v12, v3);
        }
      }
    }
    time_t v4 = (void *)*((void *)v1 + 2);
    if (*v1 == 17)
    {
      *(unsigned char *)(v4[1] + 14) = 1;
      *(unsigned char *)(v4[1] + 15) = 0;
    }
    else if (*v1 == 16)
    {
      BOOL v5 = sub_10003F940(8uLL);
      if (v5)
      {
        time_t v6 = v5;
        *(void *)v5[1] = *(void *)v4[1];
        sub_10003FA78(v4);
        time_t v4 = v6;
      }
      else
      {
        if (dword_10008FA20)
        {
          uint64_t v7 = ne_log_obj();
          if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR)) {
            sub_100067B88(&buf, v16, v7);
          }
        }
        time_t v4 = 0;
      }
    }
    *((void *)v1 + 2) = v4;
    v0 += 6;
  }
  while (v0 != 114);
  uint64_t v8 = sub_10003F940(0x10uLL);
  qword_10008C4C8 = (uint64_t)v8;
  if (!v8)
  {
    if (dword_10008FA20)
    {
      BOOL v10 = ne_log_obj();
      if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR)) {
        sub_100067B44(v10);
      }
    }
    exit(1);
  }
  double result = -1.61043727e48;
  *(_OWORD *)v8[1] = xmmword_10006E7E0;
  return result;
}

void *sub_10003F70C(int a1)
{
  uint64_t v1 = 0;
  if (a1 == -1) {
    int v2 = 0;
  }
  else {
    int v2 = a1;
  }
  while (dword_10008C2F0[v1] != v2)
  {
    v1 += 6;
    if (v1 == 120)
    {
      if (dword_10008FA20)
      {
        char v3 = ne_log_obj();
        if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR)) {
          sub_100067BC8(v2, v3);
        }
      }
      return 0;
    }
  }
  uint64_t v5 = *(void *)&dword_10008C2F0[v1 + 4];

  return sub_10003FAC0(v5);
}

uint64_t sub_10003F7B0(uint64_t a1)
{
  if (!a1) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v1 = 0;
  signed int v2 = (bswap32(*(unsigned __int16 *)(a1 + 2)) >> 16) - 4;
  char v3 = (const char *)(a1 + 4);
  do
  {
    uint64_t v4 = *(void *)&dword_10008C2F0[v1 + 4];
    unint64_t v5 = *(void *)v4;
    if (!strncmp(*(const char **)(v4 + 8), v3, *(void *)v4))
    {
      if (v5 >= v2)
      {
        if (!dword_10008FA20) {
          return dword_10008C2F0[v1];
        }
        uint8_t v11 = ne_log_obj();
        if (!os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT)) {
          return dword_10008C2F0[v1];
        }
        uint64_t v14 = *(void *)&dword_10008C2F0[v1 + 2];
        int v15 = 136315138;
        uint64_t v16 = v14;
        size_t v13 = "received Vendor ID: %s\n";
      }
      else
      {
        if (!dword_10008FA20) {
          return dword_10008C2F0[v1];
        }
        uint8_t v11 = ne_log_obj();
        if (!os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT)) {
          return dword_10008C2F0[v1];
        }
        uint64_t v12 = *(void *)&dword_10008C2F0[v1 + 2];
        int v15 = 136315138;
        uint64_t v16 = v12;
        size_t v13 = "received broken Microsoft ID: %s\n";
      }
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, v13, (uint8_t *)&v15, 0xCu);
      return dword_10008C2F0[v1];
    }
    v1 += 6;
  }
  while (v1 != 120);
  if (dword_10008C2C8 >= 7) {
    sub_100033908(7, (uint64_t)v3, v2, "received unknown Vendor ID:\n", v6, v7, v8, v9, v15);
  }
  return 0xFFFFFFFFLL;
}

void *sub_10003F940(size_t a1)
{
  signed int v2 = malloc_type_malloc(0x10uLL, 0x1010040466105CCuLL);
  char v3 = v2;
  if (v2)
  {
    *signed int v2 = a1;
    if (a1)
    {
      uint64_t v4 = malloc_type_calloc(1uLL, a1, 0x68A898BBuLL);
      v3[1] = v4;
      if (!v4)
      {
        free(v3);
        return 0;
      }
    }
    else
    {
      v2[1] = 0;
    }
  }
  return v3;
}

void **sub_10003F9BC(void **a1, size_t size)
{
  if (!a1) {
    return (void **)sub_10003F940(size);
  }
  char v3 = a1;
  if (*a1)
  {
    uint64_t v4 = (char *)malloc_type_realloc(a1[1], size, 0xE23CD46AuLL);
    if (v4)
    {
      unint64_t v5 = v4;
      if (size > (unint64_t)*v3) {
        bzero((char *)*v3 + (void)v4, size - (void)*v3);
      }
      *char v3 = (void *)size;
      v3[1] = v5;
    }
    else
    {
      sub_10003FA78(v3);
      return 0;
    }
    return v3;
  }
  sub_10003FA78(a1);

  return (void **)sub_10003F940(size);
}

void sub_10003FA78(void *a1)
{
  if (a1)
  {
    signed int v2 = (void *)a1[1];
    if (v2) {
      free(v2);
    }
    free(a1);
  }
}

void *sub_10003FAC0(uint64_t a1)
{
  if (a1)
  {
    signed int v2 = sub_10003F940(*(void *)a1);
    char v3 = v2;
    if (v2) {
      memcpy((void *)v2[1], *(const void **)(a1 + 8), *(void *)a1);
    }
  }
  else
  {
    if (dword_10008FA20)
    {
      uint64_t v4 = ne_log_obj();
      if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR)) {
        sub_100067C40(v4);
      }
    }
    return 0;
  }
  return v3;
}

void *sub_10003FB3C(const void *a1, size_t a2)
{
  if (!a1) {
    return 0;
  }
  uint64_t v4 = sub_10003F940(a2);
  unint64_t v5 = v4;
  if (v4) {
    memcpy((void *)v4[1], a1, a2);
  }
  return v5;
}

BOOL sub_10003FB98(int a1)
{
  return (a1 - 6) < 0xA;
}

uint64_t sub_10003FBA8(void *a1, uint64_t a2)
{
  if (a1[9]) {
    BOOL v4 = dword_10008FA20 == 0;
  }
  else {
    BOOL v4 = 1;
  }
  if (!v4)
  {
    unint64_t v5 = ne_log_obj();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v6 = sub_10003CAE4((const sockaddr *)a2);
      int v7 = *(_DWORD *)(a1[9] + 52);
      if (*(_DWORD *)(a1[8] + 176) == 2) {
        uint64_t v8 = "(NAT-T forced)";
      }
      else {
        uint64_t v8 = (const char *)&unk_100081F6D;
      }
      int v20 = 136315650;
      __int16 v21 = v6;
      __int16 v22 = 1024;
      int v23 = v7;
      __int16 v24 = 2080;
      __int16 v25 = v8;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "Hashing %s with algo #%d %s\n", (uint8_t *)&v20, 0x1Cu);
    }
  }
  int v9 = *(unsigned __int8 *)(a2 + 1);
  if (v9 == 30)
  {
    BOOL v10 = (const void *)(a2 + 8);
    size_t v11 = 16;
  }
  else
  {
    if (v9 != 2)
    {
      if (dword_10008FA20)
      {
        char v17 = ne_log_obj();
        if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR)) {
          sub_100067C84();
        }
      }
      return 0;
    }
    BOOL v10 = (const void *)(a2 + 4);
    size_t v11 = 4;
  }
  uint64_t v12 = sub_10003F940(v11 + 18);
  if (!v12) {
    return 0;
  }
  size_t v13 = v12;
  uint64_t v14 = (void *)v12[1];
  void *v14 = *a1;
  v14[1] = a1[1];
  int v15 = v14 + 2;
  uint64_t v16 = v14 + 2;
  if (*(_DWORD *)(a1[8] + 176) == 2) {
    bzero(v16, v11);
  }
  else {
    memcpy(v16, v10, v11);
  }
  *(_WORD *)((char *)v15 + v11) = *(_WORD *)(a2 + 2);
  uint64_t v18 = sub_100029C00((uint64_t)v13, (uint64_t)a1);
  sub_10003FA78(v13);
  return v18;
}

uint64_t sub_10003FD90(uint64_t a1, uint64_t a2, int a3)
{
  if (*(_DWORD *)(*(void *)(a1 + 64) + 176) == 2) {
    return 0;
  }
  int v6 = **(_DWORD **)(a1 + 88);
  int v7 = (uint64_t *)(a1 + 48);
  if (a3) {
    uint64_t v8 = (uint64_t *)(a1 + 48);
  }
  else {
    uint64_t v8 = (uint64_t *)(a1 + 56);
  }
  if (a3) {
    int v9 = -5;
  }
  else {
    int v9 = -3;
  }
  if (a3)
  {
    int v7 = (uint64_t *)(a1 + 56);
    int v10 = -3;
  }
  else
  {
    int v10 = -5;
  }
  BOOL v11 = v6 == 14;
  if (v6 == 14) {
    uint64_t v12 = v7;
  }
  else {
    uint64_t v12 = v8;
  }
  if (v11) {
    int v13 = v10;
  }
  else {
    int v13 = v9;
  }
  uint64_t v14 = sub_10003FBA8((void *)a1, *v12);
  if (*(void *)a2 == *(void *)v14 && !memcmp(*(const void **)(a2 + 8), *(const void **)(v14 + 8), *(void *)a2))
  {
    *(_DWORD *)(a1 + 96) &= v13;
    uint64_t v3 = 1;
  }
  else
  {
    uint64_t v3 = 0;
  }
  uint64_t v15 = *(void *)(a1 + 440);
  if (v15) {
    *(_DWORD *)(v15 + 284) = *(_DWORD *)(a1 + 96);
  }
  sub_10003FA78((void *)v14);
  return v3;
}

uint64_t sub_10003FE74(int a1)
{
  BOOL v1 = a1 == 61443 || a1 == 61444;
  return (a1 - 3) < 2 || v1;
}

uint64_t sub_10003FEA0(uint64_t a1, int a2)
{
  if (!a1) {
    return 0xFFFFFFFFLL;
  }
  *(_DWORD *)a1 = a2;
  int v4 = a2 - 6;
  if ((a2 - 6) >= 0xA)
  {
    if (dword_10008FA20)
    {
      BOOL v11 = ne_log_obj();
      if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR)) {
        sub_100067CEC(a2, v11);
      }
    }
    return 0xFFFFFFFFLL;
  }
  else
  {
    uint64_t result = 0;
    __int16 v6 = word_10006E7F0[v4];
    __int16 v7 = word_10006E804[v4];
    __int16 v8 = word_10006E818[v4];
    __int16 v9 = word_10006E82C[v4];
    __int16 v10 = word_10006E840[v4];
    *(_WORD *)(a1 + 4) = *(_WORD *)(qword_10008F848 + 18);
    *(_WORD *)(a1 + 14) = v6;
    *(_WORD *)(a1 + 16) = v7;
    *(_WORD *)(a1 + 6) = v8;
    *(_WORD *)(a1 + 8) = v9;
    *(_WORD *)(a1 + 10) = 2;
    *(_WORD *)(a1 + 12) = v10;
  }
  return result;
}

uint64_t sub_10003FF90(uint64_t a1, void *a2, void *a3)
{
  *a3 = 0;
  *a2 = 0;
  uint64_t v3 = *(void *)(*(void *)(a1 + 256) + 88);
  if (!v3) {
    return 0;
  }
  uint64_t v4 = *(unsigned __int16 *)(v3 + 16);
  if (*(_WORD *)(v3 + 16))
  {
    __int16 v7 = *(unsigned __int8 **)(a1 + 8 * (*(unsigned char *)(a1 + 60) == 0));
    __int16 v8 = *(unsigned __int8 **)(a1 + 8 * (*(unsigned char *)(a1 + 60) != 0));
    int v9 = v8[1];
    if (v9 == 2)
    {
      size_t v10 = 4;
    }
    else
    {
      if (v9 != 30)
      {
        if (!dword_10008FA20) {
          return 0xFFFFFFFFLL;
        }
        int v13 = ne_log_obj();
        if (!os_log_type_enabled(v13, OS_LOG_TYPE_ERROR)) {
          return 0xFFFFFFFFLL;
        }
        goto LABEL_13;
      }
      size_t v10 = 16;
    }
    int v11 = v7[1];
    if (v11 == 2)
    {
      uint64_t v12 = 4;
      goto LABEL_15;
    }
    if (v11 == 30)
    {
      uint64_t v12 = 16;
LABEL_15:
      uint64_t v14 = sub_10003F940(v10 + 4);
      if (v14)
      {
        uint64_t v15 = v14;
        size_t __len = v12;
        uint64_t v16 = sub_10003F940(v12 + 4);
        if (v16)
        {
          char v17 = v16;
          uint64_t v18 = (unsigned char *)v15[1];
          int v19 = v8[1];
          if (v19 == 30)
          {
            unsigned char *v18 = 5;
            int v20 = v18 + 4;
            __int16 v21 = v8 + 8;
          }
          else
          {
            if (v19 != 2) {
              goto LABEL_33;
            }
            unsigned char *v18 = 1;
            int v20 = v18 + 4;
            __int16 v21 = v8 + 4;
          }
          memmove(v20, v21, v10);
LABEL_33:
          uint64_t v26 = (unsigned char *)v17[1];
          int v27 = v7[1];
          if (v27 == 30)
          {
            *uint64_t v26 = 5;
            int v28 = v26 + 4;
            int v29 = v7 + 8;
          }
          else
          {
            if (v27 != 2)
            {
LABEL_38:
              *a2 = v15;
              *a3 = v17;
              return v4;
            }
            *uint64_t v26 = 1;
            int v28 = v26 + 4;
            int v29 = v7 + 4;
          }
          memmove(v28, v29, __len);
          goto LABEL_38;
        }
        sub_10003FA78(v15);
        if (!dword_10008FA20) {
          return 0xFFFFFFFFLL;
        }
        __int16 v24 = ne_log_obj();
        if (!os_log_type_enabled(v24, OS_LOG_TYPE_ERROR)) {
          return 0xFFFFFFFFLL;
        }
      }
      else
      {
        if (!dword_10008FA20) {
          return 0xFFFFFFFFLL;
        }
        int v23 = ne_log_obj();
        if (!os_log_type_enabled(v23, OS_LOG_TYPE_ERROR)) {
          return 0xFFFFFFFFLL;
        }
      }
      sub_100067DE0();
      return 0xFFFFFFFFLL;
    }
    if (!dword_10008FA20) {
      return 0xFFFFFFFFLL;
    }
    __int16 v22 = ne_log_obj();
    if (!os_log_type_enabled(v22, OS_LOG_TYPE_ERROR)) {
      return 0xFFFFFFFFLL;
    }
LABEL_13:
    sub_100067D78();
    return 0xFFFFFFFFLL;
  }
  return v4;
}

char *sub_1000401E0(uint64_t a1)
{
  int v2 = **(unsigned __int8 **)(a1 + 8);
  if (v2 != 5)
  {
    if (v2 != 1)
    {
      if (dword_10008FA20)
      {
        uint64_t v4 = ne_log_obj();
        if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR)) {
          sub_100067E14();
        }
      }
      return 0;
    }
    uint64_t result = (char *)malloc_type_malloc(0x10uLL, 0x1000040451B5BE8uLL);
    if (result)
    {
      *(_DWORD *)uint64_t result = 528;
      *((_DWORD *)result + 1) = *(_DWORD *)(*(void *)(a1 + 8) + 4);
      return result;
    }
    if (!dword_10008FA20) {
      return 0;
    }
    unint64_t v5 = ne_log_obj();
    if (!os_log_type_enabled(v5, OS_LOG_TYPE_ERROR)) {
      return 0;
    }
    goto LABEL_15;
  }
  uint64_t result = (char *)malloc_type_malloc(0x1CuLL, 0x100004027586B93uLL);
  if (result)
  {
    *(_DWORD *)uint64_t result = 7708;
    *(_OWORD *)(result + 8) = *(_OWORD *)(*(void *)(a1 + 8) + 4);
    return result;
  }
  if (dword_10008FA20)
  {
    __int16 v6 = ne_log_obj();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR)) {
LABEL_15:
    }
      sub_100067E7C();
  }
  return 0;
}

void sub_100040318(uint64_t a1)
{
  if ((*(unsigned char *)(a1 + 96) & 6) != 0 && *(_WORD *)(*(void *)(a1 + 88) + 4))
  {
    if (*(unsigned __int16 *)sub_10003D894(*(void *)(a1 + 56)) == bswap32(*(unsigned __int16 *)(qword_10008F848 + 16)) >> 16) {
      sub_10003D910(*(void *)(a1 + 56), *(unsigned __int16 *)(*(void *)(a1 + 88) + 4));
    }
    if (*(unsigned __int16 *)sub_10003D894(*(void *)(a1 + 48)) == bswap32(*(unsigned __int16 *)(qword_10008F848 + 16)) >> 16) {
      sub_10003D910(*(void *)(a1 + 48), *(unsigned __int16 *)(*(void *)(a1 + 88) + 4));
    }
    *(_DWORD *)(a1 + 96) |= 0x28u;
    if (*(unsigned char *)(a1 + 80) == 16)
    {
      sub_10004CD4C((uint64_t *)a1);
    }
  }
}

void sub_1000403F4(uint64_t a1, int a2)
{
  if (*(void *)(a1 + 88)
    || (uint64_t v4 = malloc_type_calloc(1uLL, 0x14uLL, 0x1000040EF768F96uLL), (*(void *)(a1 + 88) = v4) != 0))
  {
    int v5 = sub_10004F21C(a1);
    if (v5) {
      int v6 = v5;
    }
    else {
      int v6 = a2;
    }
    __int16 v7 = *(int **)(a1 + 88);
    if (*v7 < v6 && !sub_10003FEA0((uint64_t)v7, v6)) {
      *(_DWORD *)(a1 + 96) |= 1u;
    }
  }
  else if (dword_10008FA20)
  {
    __int16 v8 = ne_log_obj();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR)) {
      sub_100067EB0();
    }
  }
}

BOOL sub_1000404AC()
{
  return sub_1000390C4((uint64_t (*)(uint64_t, uint64_t))sub_1000404E0, 0) != 0;
}

uint64_t sub_1000404E0(uint64_t result)
{
  if (!*(_DWORD *)(result + 176)) {
    return 0;
  }
  return result;
}

void *sub_1000404F0(void *a1, _OWORD *a2)
{
  if (!a2) {
    return 0;
  }
  a2[4] = 0u;
  a2[5] = 0u;
  a2[2] = 0u;
  a2[3] = 0u;
  *a2 = 0u;
  a2[1] = 0u;
  unint64_t v4 = (unint64_t)sub_10003F70C(15);
  *(void *)a2 = v4;
  int v5 = sub_10003F70C(14);
  *((void *)a2 + (v4 != 0)) = v5;
  if (v4) {
    int v6 = 2;
  }
  else {
    int v6 = 1;
  }
  if (v5) {
    LODWORD(v4) = v6;
  }
  else {
    LODWORD(v4) = v4 != 0;
  }
  __int16 v7 = sub_10003F70C(13);
  *((void *)a2 + v4) = v7;
  if (v7) {
    LODWORD(v4) = v4 + 1;
  }
  __int16 v8 = sub_10003F70C(12);
  *((void *)a2 + v4) = v8;
  if (v8) {
    LODWORD(v4) = v4 + 1;
  }
  int v9 = sub_10003F70C(11);
  *((void *)a2 + v4) = v9;
  if (v9) {
    LODWORD(v4) = v4 + 1;
  }
  size_t v10 = sub_10003F70C(10);
  *((void *)a2 + v4) = v10;
  if (v10) {
    LODWORD(v4) = v4 + 1;
  }
  int v11 = sub_10003F70C(9);
  *((void *)a2 + v4) = v11;
  if (v11) {
    LODWORD(v4) = v4 + 1;
  }
  uint64_t v12 = sub_10003F70C(8);
  *((void *)a2 + v4) = v12;
  if (v12) {
    LODWORD(v4) = v4 + 1;
  }
  int v13 = sub_10003F70C(6);
  *((void *)a2 + v4) = v13;
  if (v13) {
    LODWORD(v4) = v4 + 1;
  }
  uint64_t v14 = sub_10003F70C(7);
  *((void *)a2 + v4) = v14;
  if (v14) {
    unint64_t v4 = (v4 + 1);
  }
  else {
    unint64_t v4 = v4;
  }
  if (v4)
  {
    for (unint64_t i = 0; i < v4; ++i)
      a1 = sub_100026474(a1, *((void *)a2 + i), 13);
  }
  return a1;
}

uint64_t sub_100040638(int a1, int a2, unsigned int a3)
{
  if (a1 == 14)
  {
    int v3 = 2;
    return sub_100040670(v3, a2, a3);
  }
  if (a1 == 15)
  {
    int v3 = 3;
    return sub_100040670(v3, a2, a3);
  }
  __ipsec_errcode = 2;
  return 0xFFFFFFFFLL;
}

uint64_t sub_100040670(int a1, int a2, unsigned int a3)
{
  unint64_t v4 = sub_1000406FC(a1, a2);
  if (!v4) {
    return 0xFFFFFFFFLL;
  }
  unsigned int v5 = *((unsigned __int16 *)v4 + 1);
  unsigned int v6 = *((unsigned __int16 *)v4 + 2);
  if (v5 <= a3 && v6 >= a3)
  {
    int v9 = 0;
    uint64_t result = 0;
  }
  else
  {
    fprintf(__stderrp, "%d %d %d\n", a3, v5, v6);
    uint64_t result = 0xFFFFFFFFLL;
    int v9 = 14;
  }
  __ipsec_errcode = v9;
  return result;
}

unsigned __int8 *sub_1000406FC(int a1, int a2)
{
  uint64_t v2 = 0;
  while (dword_10006E860[v2] != a1)
  {
    if (++v2 == 3) {
      goto LABEL_6;
    }
  }
  if (v2 == 0xFFFFFFFFLL)
  {
LABEL_6:
    int v3 = 2;
LABEL_7:
    uint64_t result = 0;
    __ipsec_errcode = v3;
    return result;
  }
  unsigned int v5 = (unsigned __int16 *)qword_10008F200[v2];
  if (!v5)
  {
    int v3 = 22;
    goto LABEL_7;
  }
  unsigned int v6 = *v5;
  if (v6 < 0x10)
  {
LABEL_14:
    int v3 = 1;
    goto LABEL_7;
  }
  uint64_t result = (unsigned __int8 *)(v5 + 4);
  int v7 = v6 + 8;
  while (*result != a2)
  {
    result += 8;
    v7 -= 8;
    if (v7 <= 23) {
      goto LABEL_14;
    }
  }
  return result;
}

uint64_t sub_100040798(int a1, int a2, void *a3)
{
  if (a3)
  {
    int v5 = 2;
    if (a1 != 14)
    {
      if (a1 != 15)
      {
        uint64_t v8 = 0xFFFFFFFFLL;
        goto LABEL_9;
      }
      int v5 = 3;
    }
    unsigned int v6 = sub_1000406FC(v5, a2);
    if (!v6) {
      return 0xFFFFFFFFLL;
    }
    int v7 = v6;
    int v5 = 0;
    uint64_t v8 = 0;
    *a3 = *(void *)v7;
  }
  else
  {
    uint64_t v8 = 0xFFFFFFFFLL;
    int v5 = 2;
  }
LABEL_9:
  __ipsec_errcode = v5;
  return v8;
}

uint64_t sub_100040820(int a1, int a2)
{
  __ipsec_errcode = 0;
  if ((a2 - 101) >= 0xFFFFFF9C) {
    int v2 = a2;
  }
  else {
    int v2 = 100;
  }
  switch(a1)
  {
    case 0:
      uint64_t result = 0;
      dword_10008C4D0 = v2;
      break;
    case 1:
      uint64_t result = 0;
      dword_10008C4D4 = v2;
      break;
    case 2:
      uint64_t result = 0;
      dword_10008C4D8 = v2;
      break;
    case 3:
      uint64_t result = 0;
      dword_10008C4DC = v2;
      break;
    default:
      __ipsec_errcode = 2;
      uint64_t result = 1;
      break;
  }
  return result;
}

uint64_t sub_1000408C8(int a1)
{
  switch(a1)
  {
    case 0:
      uint64_t result = dword_10008C4D0;
      break;
    case 1:
      uint64_t result = dword_10008C4D4;
      break;
    case 2:
      uint64_t result = dword_10008C4D8;
      break;
    case 3:
      uint64_t result = dword_10008C4DC;
      break;
    default:
      uint64_t result = 0xFFFFFFFFLL;
      break;
  }
  return result;
}

uint64_t sub_10004093C(int a1, char a2, char a3, unsigned __int8 *a4, unsigned __int8 *a5, unsigned int a6, unsigned int a7, int a8, int a9, int a10, unsigned int a11, int a12, int a13, char a14)
{
  if (!a4 || !a5)
  {
    int v24 = 2;
    goto LABEL_38;
  }
  int v16 = a4[1];
  if (v16 != a5[1])
  {
    int v24 = 24;
    goto LABEL_38;
  }
  if (a6 > a7 || a6 - 1 <= 0xFE)
  {
    int v24 = 18;
    goto LABEL_38;
  }
  if (v16 != 2)
  {
    if (v16 == 30)
    {
      char v23 = 0x80;
      goto LABEL_13;
    }
    int v24 = 15;
LABEL_38:
    __ipsec_errcode = v24;
    return 0xFFFFFFFFLL;
  }
  char v23 = 32;
LABEL_13:
  char v40 = v23;
  if (a9) {
    int v25 = 82;
  }
  else {
    int v25 = 50;
  }
  int v26 = v25 + ((*a4 - 1) | 7) + ((*a5 - 1) | 7);
  BOOL v27 = a6 < 0x100 || a7 == -1;
  char v28 = v27;
  char v39 = v28;
  if (!v27) {
    v26 += 16;
  }
  uint64_t v29 = v26;
  unsigned int v30 = malloc_type_calloc(1uLL, v26, 0x87EE41D3uLL);
  if (!v30)
  {
    int v38 = __error();
    strerror(*v38);
    __ipsec_set_strerror();
    return 0xFFFFFFFFLL;
  }
  uint64_t v31 = v30;
  pid_t v32 = getpid();
  if ((int)v29 <= 15) {
    goto LABEL_36;
  }
  *uint64_t v31 = 0;
  v31[1] = 0;
  *(_WORD *)uint64_t v31 = 258;
  *((unsigned char *)v31 + 2) = 0;
  *((unsigned char *)v31 + 3) = a2;
  *((_DWORD *)v31 + 1) = (unsigned __int16)(v29 >> 3);
  *((_DWORD *)v31 + 2) = a13;
  *((_DWORD *)v31 + 3) = v32;
  if (v29 <= 0x1F) {
    goto LABEL_36;
  }
  unint64_t v33 = (unint64_t)v31 + v29;
  v31[2] = 0;
  v31[3] = 0;
  *((_DWORD *)v31 + 4) = 1245186;
  *((unsigned char *)v31 + 20) = a3;
  *((_DWORD *)v31 + 7) = a8;
  *((unsigned char *)v31 + 21) = a14;
  *((_WORD *)v31 + 11) |= 1u;
  char v34 = sub_100040C50((_WORD *)v31 + 16, (unint64_t)v31 + v29, 5, a4, v40, 255);
  if (!v34) {
    goto LABEL_36;
  }
  msghdr v35 = sub_100040C50(v34, (unint64_t)v31 + v29, 6, a5, v40, 255);
  if (!v35) {
    goto LABEL_36;
  }
  if (a9)
  {
    if ((unint64_t)(v35 + 32) > v33) {
      goto LABEL_36;
    }
    *(_OWORD *)msghdr v35 = 0u;
    *((_OWORD *)v35 + 1) = 0u;
    *(void *)msghdr v35 = 196612;
    *((void *)v35 + 1) = 0;
    *((void *)v35 + 2) = a11;
    *((void *)v35 + 3) = 0;
    v35 += 32;
  }
  if (v39) {
    goto LABEL_35;
  }
  if ((unint64_t)(v35 + 16) > v33)
  {
LABEL_36:
    free(v31);
    return 0xFFFFFFFFLL;
  }
  *(_DWORD *)msghdr v35 = 1048578;
  *((_DWORD *)v35 + 1) = a6;
  *((_DWORD *)v35 + 2) = a7;
  *((_DWORD *)v35 + 3) = 0;
  v35 += 16;
LABEL_35:
  if (v35 != (char *)v33) {
    goto LABEL_36;
  }
  ssize_t v36 = sub_100040DB0(a1, v31, v29);
  free(v31);
  if ((v36 & 0x80000000) == 0)
  {
    __ipsec_errcode = 0;
    return v36;
  }
  return 0xFFFFFFFFLL;
}

unint64_t sub_100040C0C(uint64_t a1, unint64_t a2, char a3, int a4, char a5)
{
  unint64_t result = a1 + 16;
  if (result > a2) {
    return 0;
  }
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(_DWORD *)a1 = 1245186;
  *(unsigned char *)(a1 + 4) = a3;
  *(_DWORD *)(a1 + 12) = a4;
  *(unsigned char *)(a1 + 5) = a5;
  *(_WORD *)(a1 + 6) = 1;
  return result;
}

char *sub_100040C50(_WORD *a1, unint64_t a2, __int16 a3, unsigned __int8 *a4, char a5, char a6)
{
  int v6 = (*a4 - 1) | 7;
  uint64_t v7 = (v6 + 9);
  uint64_t v8 = (char *)a1 + v7;
  if ((unint64_t)a1 + v7 > a2) {
    return 0;
  }
  bzero(a1, (v6 + 9));
  *a1 = v7 >> 3;
  a1[1] = a3;
  *((unsigned char *)a1 + 4) = a6;
  *((unsigned char *)a1 + 5) = a5;
  a1[3] = 0;
  memcpy(a1 + 4, a4, *a4);
  return v8;
}

unint64_t sub_100040CF0(uint64_t a1, unint64_t a2, int a3, int a4, unsigned int a5, unsigned int a6, unsigned int a7)
{
  unint64_t result = a1 + 32;
  if (result > a2) {
    return 0;
  }
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_WORD *)a1 = 4;
  *(_WORD *)(a1 + 2) = a3;
  if (a3 == 3)
  {
    *(_DWORD *)(a1 + 4) = a4;
    *(void *)(a1 + 8) = a5;
    *(void *)(a1 + 16) = a6;
    goto LABEL_8;
  }
  if (a3 == 4)
  {
    *(_DWORD *)(a1 + 4) = dword_10008C4D0 * a4 / 0x64u;
    unint64_t v9 = dword_10008C4D8 * a6 / 0x64uLL;
    *(void *)(a1 + 8) = dword_10008C4D4 * a5 / 0x64uLL;
    *(void *)(a1 + 16) = v9;
    a7 = dword_10008C4DC * a7 / 0x64;
LABEL_8:
    *(void *)(a1 + 24) = a7;
  }
  return result;
}

ssize_t sub_100040DB0(int a1, const void *a2, unsigned int a3)
{
  ssize_t result = send(a1, a2, a3, 0);
  if ((result & 0x80000000) != 0)
  {
    unint64_t v4 = __error();
    strerror(*v4);
    __ipsec_set_strerror();
    return 0xFFFFFFFFLL;
  }
  else
  {
    __ipsec_errcode = 0;
  }
  return result;
}

uint64_t sub_100040DF8(int a1, int a2, char a3, unsigned __int8 *a4, unsigned __int8 *a5, int a6, int a7, char a8, char *a9, int a10, unsigned int a11, int a12, unsigned int a13, int a14, int a15, unsigned int a16, int a17, unsigned int a18, int a19, unsigned int a20,int a21,int a22,__int16 a23,__int16 a24,char a25)
{
  return sub_100040E78(a1, 2, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a18, a20,
           a22,
           a23,
           SHIWORD(a22),
           a25);
}

uint64_t sub_100040E78(int a1, char a2, int a3, char a4, unsigned __int8 *a5, unsigned __int8 *a6, int a7, int a8, char a9, char *a10, int a11, unsigned int a12, int a13, unsigned int a14, int a15, int a16, unsigned int a17, unsigned int a18, unsigned int a19, int a20,__int16 a21,__int16 a22,char a23)
{
  long long v61 = 0;
  if (!a5 || !a6)
  {
    int v33 = 2;
    goto LABEL_37;
  }
  int v25 = a5[1];
  if (v25 != a6[1])
  {
    int v33 = 24;
    goto LABEL_37;
  }
  if (v25 != 2)
  {
    if (v25 == 30)
    {
      char v32 = 0x80;
      goto LABEL_10;
    }
    int v33 = 15;
LABEL_37:
    __ipsec_errcode = v33;
    return 0xFFFFFFFFLL;
  }
  char v32 = 32;
LABEL_10:
  if (a3 == 2)
  {
    if (!a11)
    {
      if (a13) {
        goto LABEL_14;
      }
      goto LABEL_34;
    }
LABEL_36:
    int v33 = 13;
    goto LABEL_37;
  }
  if (a3 == 9)
  {
    if (a11)
    {
      if (!a13) {
        goto LABEL_14;
      }
LABEL_34:
      int v33 = 20;
      goto LABEL_37;
    }
    goto LABEL_36;
  }
  if (a3 != 3)
  {
    int v33 = 10;
    goto LABEL_37;
  }
  if (!a11) {
    goto LABEL_34;
  }
LABEL_14:
  char v59 = v32;
  if (getifaddrs(&v61) < 0) {
    return 0xFFFFFFFFLL;
  }
  char v34 = v61;
  if (!v61)
  {
LABEL_27:
    int v40 = 0;
    char v58 = 1;
    goto LABEL_43;
  }
  while (1)
  {
    ifa_addr = v34->ifa_addr;
    if (!ifa_addr) {
      goto LABEL_26;
    }
    int sa_family = ifa_addr->sa_family;
    if (sa_family != a5[1]) {
      goto LABEL_26;
    }
    if (sa_family == 30) {
      break;
    }
    if (sa_family != 2 || *(_DWORD *)&ifa_addr->sa_data[2] == *((_DWORD *)a5 + 1)) {
      goto LABEL_40;
    }
LABEL_26:
    char v34 = v34->ifa_next;
    if (!v34) {
      goto LABEL_27;
    }
  }
  uint64_t v38 = *(void *)&ifa_addr->sa_data[6];
  uint64_t v37 = *(void *)&ifa_addr[1].sa_len;
  if (v38 != *((void *)a5 + 1) || v37 != *((void *)a5 + 2)) {
    goto LABEL_26;
  }
LABEL_40:
  char v58 = 0;
  if (v34->ifa_name) {
    int v40 = 80;
  }
  else {
    int v40 = 0;
  }
LABEL_43:
  int v43 = ((a14 - 1) | 7) + 9;
  if (!a13) {
    int v43 = 0;
  }
  BOOL v57 = a3 != 9 && a11 != 0;
  int v44 = ((a12 - 1) | 7) + 147;
  if (!v57) {
    int v44 = 138;
  }
  size_t v45 = v44 + v43 + ((*a5 - 1) | 7) + ((*a6 - 1) | 7) + v40;
  long long v60 = malloc_type_calloc(1uLL, v45, 0xE0EAEB3DuLL);
  if (!v60)
  {
    CFStringRef v47 = __error();
    strerror(*v47);
    __ipsec_set_strerror();
    uint64_t v41 = 0xFFFFFFFFLL;
    int v48 = 0;
LABEL_66:
    if (v61) {
      freeifaddrs(v61);
    }
    if (v48) {
      free(v48);
    }
    return v41;
  }
  pid_t v46 = getpid();
  if ((int)v45 > 15)
  {
    *long long v60 = 0;
    v60[1] = 0;
    *(unsigned char *)long long v60 = 2;
    *((unsigned char *)v60 + 1) = a2;
    *((unsigned char *)v60 + 2) = 0;
    *((unsigned char *)v60 + 3) = a3;
    int v48 = v60;
    *((_DWORD *)v60 + 1) = (unsigned __int16)(v45 >> 3);
    *((_DWORD *)v60 + 2) = a20;
    *((_DWORD *)v60 + 3) = v46;
    if (v45 < 0x28) {
      goto LABEL_65;
    }
    unint64_t v49 = (unint64_t)v60 + v45;
    v60[2] = 0;
    v60[3] = 0;
    v60[4] = 0;
    *((_DWORD *)v60 + 4) = 65539;
    *((_DWORD *)v60 + 5) = a7;
    *((unsigned char *)v60 + 24) = a9;
    *((unsigned char *)v60 + 25) = 0;
    *((unsigned char *)v60 + 26) = a13;
    *((unsigned char *)v60 + 27) = a11;
    *((_DWORD *)v60 + 7) = a15;
    *((_WORD *)v60 + 16) = a21;
    __int16 v50 = (_WORD *)sub_100040C0C((uint64_t)(v60 + 5), (unint64_t)v60 + v45, a4, a8, a23);
    if (!v50) {
      goto LABEL_65;
    }
    int v51 = sub_100040C50(v50, (unint64_t)v60 + v45, 5, a5, v59, 255);
    if (!v51) {
      goto LABEL_65;
    }
    uint64_t v52 = (uint64_t)sub_100040C50(v51, (unint64_t)v60 + v45, 6, a6, v59, 255);
    if (!v52) {
      goto LABEL_65;
    }
    if ((v58 & 1) != 0 || (ifa_name = v34->ifa_name) == 0)
    {
      int v54 = a13;
    }
    else
    {
      uint64_t v52 = sub_100042968(v52, (unint64_t)v60 + v45, 0, ifa_name, 0, 0);
      int v54 = a13;
      if (!v52)
      {
LABEL_65:
        uint64_t v41 = 0xFFFFFFFFLL;
        goto LABEL_66;
      }
    }
    if ((!v57 || (uint64_t v52 = (uint64_t)sub_100042A18((_WORD *)v52, (unint64_t)v60 + v45, 9, a10, a12)) != 0)
      && (!v54 || (uint64_t v52 = (uint64_t)sub_100042A18((_WORD *)v52, (unint64_t)v60 + v45, 8, &a10[a12], a14)) != 0)
      && v52 + 32 <= v49)
    {
      *(_OWORD *)uint64_t v52 = 0u;
      *(_OWORD *)(v52 + 16) = 0u;
      *(_DWORD *)uint64_t v52 = 196612;
      *(_DWORD *)(v52 + 4) = a16;
      *(void *)(v52 + 8) = a17;
      *(void *)(v52 + 16) = a18;
      *(void *)(v52 + 24) = a19;
      unint64_t v55 = sub_100040CF0(v52 + 32, (unint64_t)v60 + v45, 4, a16, a17, a18, a19);
      uint64_t v41 = 0xFFFFFFFFLL;
      if (v55)
      {
        if (v55 == v49)
        {
          ssize_t v56 = sub_100040DB0(a1, v60, v45);
          if ((v56 & 0x80000000) == 0)
          {
            uint64_t v41 = v56;
            __ipsec_errcode = 0;
          }
        }
      }
      goto LABEL_66;
    }
    goto LABEL_65;
  }
  free(v60);
  freeifaddrs(v61);
  return 0xFFFFFFFFLL;
}

uint64_t sub_100041318(int a1, int a2, char a3, unsigned __int8 *a4, unsigned __int8 *a5, int a6, int a7, char a8, char *a9, int a10, unsigned int a11, int a12, unsigned int a13, int a14, int a15, unsigned int a16, int a17, unsigned int a18, int a19, unsigned int a20,int a21,int a22,__int16 a23,__int16 a24,char a25)
{
  return sub_100040E78(a1, 3, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a18, a20,
           a22,
           a23,
           SHIWORD(a22),
           a25);
}

uint64_t sub_100041398(int a1, char a2, uint64_t a3, unsigned __int8 *a4, unsigned __int8 *a5, int a6)
{
  return sub_1000413A4(a1, 4, a2, a4, a5, a6);
}

uint64_t sub_1000413A4(int a1, char a2, char a3, unsigned __int8 *a4, unsigned __int8 *a5, int a6)
{
  if (!a4 || !a5)
  {
    int v14 = 2;
    goto LABEL_20;
  }
  int v8 = a4[1];
  if (v8 != a5[1])
  {
    int v14 = 24;
    goto LABEL_20;
  }
  if (v8 != 2)
  {
    if (v8 == 30)
    {
      char v13 = 0x80;
      goto LABEL_10;
    }
    int v14 = 15;
LABEL_20:
    __ipsec_errcode = v14;
    return 0xFFFFFFFFLL;
  }
  char v13 = 32;
LABEL_10:
  uint64_t v15 = ((*a5 - 1) | 7) + ((*a4 - 1) | 7);
  uint64_t v16 = v15 + 58;
  char v17 = malloc_type_calloc(1uLL, v15 + 58, 0x9B366433uLL);
  if (v17)
  {
    uint64_t v18 = v17;
    pid_t v19 = getpid();
    if ((int)v15 <= -43) {
      goto LABEL_18;
    }
    void *v18 = 0;
    v18[1] = 0;
    *(unsigned char *)uint64_t v18 = 2;
    *((unsigned char *)v18 + 1) = a2;
    *((unsigned char *)v18 + 2) = 0;
    *((unsigned char *)v18 + 3) = a3;
    *((_DWORD *)v18 + 1) = (unsigned __int16)(v16 >> 3);
    *((_DWORD *)v18 + 2) = 0;
    *((_DWORD *)v18 + 3) = v19;
    if ((int)v15 <= -19) {
      goto LABEL_18;
    }
    v18[2] = 0;
    v18[3] = 0;
    v18[4] = 0;
    *((_DWORD *)v18 + 4) = 65539;
    *((_DWORD *)v18 + 5) = a6;
    v18[3] = 0;
    *((_WORD *)v18 + 16) = 0;
    int v20 = sub_100040C50((_WORD *)v18 + 20, (unint64_t)v18 + v16, 5, a4, v13, 255);
    if (!v20) {
      goto LABEL_18;
    }
    __int16 v21 = sub_100040C50(v20, (unint64_t)v18 + v16, 6, a5, v13, 255);
    if (v21 && v21 == (char *)v18 + v16)
    {
      ssize_t v23 = sub_100040DB0(a1, v18, v16);
      free(v18);
      if ((v23 & 0x80000000) == 0)
      {
        __ipsec_errcode = 0;
        return v23;
      }
    }
    else
    {
LABEL_18:
      free(v18);
    }
  }
  else
  {
    uint64_t v25 = __error();
    strerror(*v25);
    __ipsec_set_strerror();
  }
  return 0xFFFFFFFFLL;
}

uint64_t sub_100041594(int a1, char a2, uint64_t a3, unsigned __int8 *a4, unsigned __int8 *a5)
{
  if (!a4 || !a5)
  {
    int v11 = 2;
    goto LABEL_19;
  }
  int v7 = a4[1];
  if (v7 != a5[1])
  {
    int v11 = 24;
    goto LABEL_19;
  }
  if (v7 != 2)
  {
    if (v7 == 30)
    {
      char v10 = 0x80;
      goto LABEL_10;
    }
    int v11 = 15;
LABEL_19:
    __ipsec_errcode = v11;
    return 0xFFFFFFFFLL;
  }
  char v10 = 32;
LABEL_10:
  uint64_t v12 = ((*a5 - 1) | 7) + ((*a4 - 1) | 7);
  uint64_t v13 = v12 + 34;
  int v14 = malloc_type_calloc(1uLL, v12 + 34, 0x1C648503uLL);
  if (v14)
  {
    uint64_t v15 = v14;
    pid_t v16 = getpid();
    if ((int)v12 <= -19) {
      goto LABEL_17;
    }
    void *v15 = 0;
    v15[1] = 0;
    *(_WORD *)uint64_t v15 = 1026;
    *((unsigned char *)v15 + 2) = 0;
    *((unsigned char *)v15 + 3) = a2;
    *((_DWORD *)v15 + 1) = (unsigned __int16)(v13 >> 3);
    *((_DWORD *)v15 + 2) = 0;
    *((_DWORD *)v15 + 3) = v16;
    char v17 = sub_100040C50((_WORD *)v15 + 8, (unint64_t)v15 + v13, 5, a4, v10, 255);
    if (!v17) {
      goto LABEL_17;
    }
    uint64_t v18 = sub_100040C50(v17, (unint64_t)v15 + v13, 6, a5, v10, 255);
    if (v18 && v18 == (char *)v15 + v13)
    {
      ssize_t v20 = sub_100040DB0(a1, v15, v13);
      free(v15);
      if ((v20 & 0x80000000) == 0)
      {
        __ipsec_errcode = 0;
        return v20;
      }
    }
    else
    {
LABEL_17:
      free(v15);
    }
  }
  else
  {
    __int16 v22 = __error();
    strerror(*v22);
    __ipsec_set_strerror();
  }
  return 0xFFFFFFFFLL;
}

uint64_t sub_10004174C(int a1, char a2, uint64_t a3, unsigned __int8 *a4, unsigned __int8 *a5, int a6)
{
  return sub_1000413A4(a1, 5, a2, a4, a5, a6);
}

uint64_t sub_100041758(int a1, unsigned int a2)
{
  uint64_t v4 = 0;
  if (a2)
  {
    while (dword_10006E860[v4] != a2)
    {
      if (++v4 == 3) {
        goto LABEL_12;
      }
    }
    if (v4 == 0xFFFFFFFFLL)
    {
LABEL_12:
      __ipsec_errcode = 2;
      return 0xFFFFFFFFLL;
    }
    int v7 = (void *)qword_10008F200[v4];
    if (v7)
    {
      free(v7);
      qword_10008F200[v4] = 0;
    }
  }
  else
  {
    do
    {
      int v5 = *(void **)((char *)qword_10008F200 + v4);
      if (v5)
      {
        free(v5);
        *(uint64_t *)((char *)qword_10008F200 + v4) = 0;
      }
      v4 += 8;
    }
    while (v4 != 24);
  }

  return sub_10004183C(a1, 7, a2);
}

uint64_t sub_10004183C(int a1, int a2, unsigned int a3)
{
  char v3 = a3;
  char v4 = a2;
  if (a2 == 11)
  {
    if (a3 >= 2)
    {
LABEL_3:
      __ipsec_errcode = 10;
      return 0xFFFFFFFFLL;
    }
  }
  else if (a3 > 9 || ((1 << a3) & 0x20D) == 0)
  {
    goto LABEL_3;
  }
  int v6 = (char *)malloc_type_calloc(1uLL, 0x10uLL, 0x862A560uLL);
  if (!v6)
  {
    char v10 = __error();
    strerror(*v10);
    __ipsec_set_strerror();
    return 0xFFFFFFFFLL;
  }
  int v7 = v6;
  pid_t v8 = getpid();
  char *v7 = 2;
  v7[1] = v4;
  v7[2] = 0;
  v7[3] = v3;
  *(void *)(v7 + 4) = 2;
  *((_DWORD *)v7 + 3) = v8;
  ssize_t v9 = sub_100040DB0(a1, v7, 0x10u);
  free(v7);
  if ((v9 & 0x80000000) != 0) {
    return 0xFFFFFFFFLL;
  }
  __ipsec_errcode = 0;
  return v9;
}

uint64_t sub_100041930(int a1)
{
  pid_t v2 = getpid();
  char v3 = sub_1000419E4(a1);
  if (!v3) {
    return 0xFFFFFFFFLL;
  }
  char v4 = v3;
  while (*((unsigned char *)v4 + 1) != 7 || *((_DWORD *)v4 + 3) != v2)
  {
    free(v4);
    char v4 = sub_1000419E4(a1);
    if (!v4) {
      return 0xFFFFFFFFLL;
    }
  }
  unsigned __int16 v5 = 8 * v4[2];
  v4[2] = v5;
  int v6 = sub_100041B40((uint64_t)v4, v5 & 0xFFF8);
  free(v4);
  if (v6) {
    return 0xFFFFFFFFLL;
  }
  uint64_t result = 0;
  __ipsec_errcode = 0;
  return result;
}

unsigned __int16 *sub_1000419E4(int a1)
{
  v10[0] = 0;
  v10[1] = 0;
  while (1)
  {
    unint64_t v2 = recv(a1, v10, 0x10uLL, 2);
    if ((v2 & 0x8000000000000000) == 0) {
      break;
    }
    if (*__error() != 4)
    {
      char v3 = __error();
      strerror(*v3);
      __ipsec_set_strerror();
      return 0;
    }
  }
  if (v2 <= 0xF)
  {
    recv(a1, v10, 0x10uLL, 0);
    char v4 = 0;
    __ipsec_errcode = 30;
    return v4;
  }
  size_t v5 = 8 * WORD2(v10[0]);
  char v4 = (unsigned __int16 *)malloc_type_calloc(1uLL, v5, 0x87DF477uLL);
  if (!v4)
  {
    pid_t v8 = __error();
    strerror(*v8);
    __ipsec_set_strerror();
    return v4;
  }
  while (1)
  {
    ssize_t v6 = recv(a1, v4, v5, 0);
    if ((v6 & 0x8000000000000000) == 0) {
      break;
    }
    if (*__error() != 4)
    {
      int v7 = __error();
      strerror(*v7);
      __ipsec_set_strerror();
      goto LABEL_16;
    }
  }
  if (v6 == v5 && v5 == 8 * v4[2])
  {
    __ipsec_errcode = 0;
    return v4;
  }
  __ipsec_errcode = 26;
LABEL_16:
  free(v4);
  return 0;
}

uint64_t sub_100041B40(uint64_t a1, unsigned int a2)
{
  if (*(unsigned __int16 *)(a1 + 4) == a2)
  {
    unint64_t v2 = a1 + a2;
    char v3 = (unsigned __int16 *)(a1 + 16);
    if (a2 >= 0x18)
    {
      do
      {
        uint64_t v6 = *v3;
        if (!*v3 || v2 < (unint64_t)v3 + v6) {
          break;
        }
        int v8 = v3[1];
        if ((v8 & 0xFFFE) != 0xE) {
          goto LABEL_4;
        }
        unsigned __int16 v9 = 8 * v6;
        *char v3 = v9;
        if (v8 == 14)
        {
          uint64_t v10 = 0;
        }
        else
        {
          if (v8 != 15) {
            goto LABEL_4;
          }
          uint64_t v10 = 1;
        }
        int v11 = (void *)qword_10008F200[v10];
        if (v11)
        {
          free(v11);
          unsigned __int16 v9 = *v3;
        }
        uint64_t v12 = malloc_type_malloc(v9, 0xD3A308D4uLL);
        qword_10008F200[v10] = (uint64_t)v12;
        if (!v12)
        {
          uint64_t v13 = __error();
          strerror(*v13);
          __ipsec_set_strerror();
          return 0xFFFFFFFFLL;
        }
        memcpy(v12, v3, *v3);
        char v3 = (unsigned __int16 *)((char *)v3 + *v3);
      }
      while ((unint64_t)v3 < v2 && v2 >= (unint64_t)(v3 + 4));
    }
    if (v3 == (unsigned __int16 *)v2)
    {
      uint64_t result = 0;
      __ipsec_errcode = 0;
      return result;
    }
LABEL_4:
    int v4 = 10;
  }
  else
  {
    int v4 = 2;
  }
  __ipsec_errcode = v4;
  return 0xFFFFFFFFLL;
}

uint64_t sub_100041C78(int a1, unsigned int a2)
{
  return sub_10004183C(a1, 9, a2);
}

uint64_t sub_100041C84(int a1, unsigned int a2)
{
  return sub_10004183C(a1, 10, a2);
}

uint64_t sub_100041C90(int a1, int a2)
{
  return sub_10004183C(a1, 11, a2 != 0);
}

ssize_t sub_100041CA0(int a1, unsigned __int8 *a2, unsigned int a3, unsigned __int8 *a4, unsigned int a5, char a6, void *__src, int a8, int a9)
{
  return sub_100041D08(a1, 14, a2, 0, a3, a4, 0, a5, a6, 0, 0, __src, a8, a9, 0, 0, 0, 0);
}

ssize_t sub_100041D08(int a1, char a2, unsigned __int8 *a3, unsigned __int8 *a4, unsigned int a5, unsigned __int8 *a6, unsigned __int8 *a7, unsigned int a8, char a9, uint64_t a10, uint64_t a11, void *__src, int a13, int a14, uint64_t a15, uint64_t a16, uint64_t a17, int a18)
{
  if (!a3 || !a6)
  {
    int v28 = 2;
LABEL_22:
    __ipsec_errcode = v28;
    return 0xFFFFFFFFLL;
  }
  int v20 = a3[1];
  if (v20 != a6[1])
  {
    int v28 = 24;
    goto LABEL_22;
  }
  char v21 = a8;
  char v23 = a5;
  if (v20 == 2)
  {
    unsigned int v27 = 32;
    goto LABEL_10;
  }
  if (v20 != 30)
  {
    int v28 = 15;
    goto LABEL_22;
  }
  unsigned int v27 = 128;
LABEL_10:
  if (v27 < a5 || v27 < a8)
  {
    int v28 = 16;
    goto LABEL_22;
  }
  if (a15 | a16 | a17) {
    BOOL v29 = 0;
  }
  else {
    BOOL v29 = a18 == 0;
  }
  int v30 = !v29;
  if (a4) {
    int v31 = ((*a4 - 1) | 7) + 9;
  }
  else {
    int v31 = 0;
  }
  if (a7) {
    int v34 = ((*a7 - 1) | 7) + 9;
  }
  else {
    int v34 = 0;
  }
  int v55 = v30;
  if (v30) {
    int v35 = 80;
  }
  else {
    int v35 = 0;
  }
  size_t v36 = a13 + ((2 * *a3 - 2) | 0xE) + v31 + v34 + v35 + 66;
  uint64_t v37 = (char *)malloc_type_calloc(1uLL, v36, 0x4451789CuLL);
  if (!v37)
  {
    unint64_t v49 = __error();
    strerror(*v49);
    __ipsec_set_strerror();
    return 0xFFFFFFFFLL;
  }
  uint64_t v38 = v37;
  pid_t v39 = getpid();
  if ((int)v36 <= 15) {
    goto LABEL_49;
  }
  unsigned int v40 = v36;
  unint64_t v41 = (unint64_t)&v38[v36];
  *(void *)uint64_t v38 = 0;
  *((void *)v38 + 1) = 0;
  char *v38 = 2;
  v38[1] = a2;
  *((_WORD *)v38 + 1) = 0;
  unsigned int v54 = v40;
  *((_DWORD *)v38 + 1) = (unsigned __int16)(v40 >> 3);
  *((_DWORD *)v38 + 2) = a14;
  *((_DWORD *)v38 + 3) = v39;
  long long v42 = v38 + 16;
  unint64_t v43 = v41;
  if (a4)
  {
    char v44 = a9;
    long long v42 = sub_100040C50(v42, v41, 23, a3, v23, a9);
    if (!v42) {
      goto LABEL_49;
    }
    unint64_t v43 = v41;
    __int16 v45 = 24;
    pid_t v46 = a4;
    char v47 = v23;
    char v48 = a9;
  }
  else
  {
    __int16 v45 = 5;
    pid_t v46 = a3;
    char v47 = v23;
    char v44 = a9;
    char v48 = a9;
  }
  __int16 v50 = sub_100040C50(v42, v43, v45, v46, v47, v48);
  if (!v50) {
    goto LABEL_49;
  }
  if (a7)
  {
    int v51 = sub_100040C50(v50, v41, 25, a6, v21, v44);
    unsigned int v52 = v54;
    if (!v51) {
      goto LABEL_49;
    }
    uint64_t v53 = (uint64_t)sub_100040C50(v51, v41, 26, a7, v21, v44);
    if (!v53) {
      goto LABEL_49;
    }
    goto LABEL_45;
  }
  uint64_t v53 = (uint64_t)sub_100040C50(v50, v41, 6, a6, v21, v44);
  unsigned int v52 = v54;
  if (!v53)
  {
LABEL_49:
    free(v38);
    return 0xFFFFFFFFLL;
  }
LABEL_45:
  if (v55)
  {
    uint64_t v53 = sub_100042968(v53, v41, (char *)a16, (char *)a17, (char *)a15, a18);
    if (!v53) {
      goto LABEL_49;
    }
  }
  if (v53 + 32 > v41) {
    goto LABEL_49;
  }
  *(_OWORD *)uint64_t v53 = 0u;
  *(_OWORD *)(v53 + 16) = 0u;
  *(void *)uint64_t v53 = 196612;
  *(void *)(v53 + 8) = 0;
  *(void *)(v53 + 16) = a10;
  *(void *)(v53 + 24) = a11;
  if (v53 + 32 + a13 != v41) {
    goto LABEL_49;
  }
  memcpy((void *)(v53 + 32), __src, a13);
  ssize_t v32 = sub_100040DB0(a1, v38, v52);
  free(v38);
  if ((v32 & 0x80000000) == 0)
  {
    __ipsec_errcode = 0;
    return v32;
  }
  return 0xFFFFFFFFLL;
}

ssize_t sub_10004207C(int a1, unsigned __int8 *a2, unsigned __int8 *a3, unsigned int a4, unsigned __int8 *a5, unsigned __int8 *a6, unsigned int a7, char a8, void *__src, int a10, int a11, long long a12, uint64_t a13, int a14)
{
  return sub_100041D08(a1, 14, a2, a3, a4, a5, a6, a7, a8, 0, 0, __src, a10, a11, a12, *((uint64_t *)&a12 + 1), a13, a14);
}

ssize_t sub_1000420EC(int a1, unsigned __int8 *a2, unsigned int a3, unsigned __int8 *a4, unsigned int a5, char a6, uint64_t a7, uint64_t a8, void *a9, int a10, int a11)
{
  return sub_100041D08(a1, 14, a2, 0, a3, a4, 0, a5, a6, a7, a8, a9, a10, a11, 0, 0, 0, 0);
}

ssize_t sub_100042154(int a1, unsigned __int8 *a2, unsigned int a3, unsigned __int8 *a4, unsigned int a5, char a6, void *__src, int a8, int a9)
{
  return sub_100041D08(a1, 13, a2, 0, a3, a4, 0, a5, a6, 0, 0, __src, a8, a9, 0, 0, 0, 0);
}

ssize_t sub_1000421BC(int a1, unsigned __int8 *a2, unsigned int a3, unsigned __int8 *a4, unsigned int a5, char a6, uint64_t a7, uint64_t a8, void *a9, int a10, int a11)
{
  return sub_100041D08(a1, 13, a2, 0, a3, a4, 0, a5, a6, a7, a8, a9, a10, a11, 0, 0, 0, 0);
}

ssize_t sub_100042224(int a1, unsigned __int8 *a2, unsigned int a3, unsigned __int8 *a4, unsigned int a5, char a6, void *__src, int a8, int a9)
{
  if (a8 == 16) {
    return sub_100041D08(a1, 15, a2, 0, a3, a4, 0, a5, a6, 0, 0, __src, 16, a9, 0, 0, 0, 0);
  }
  __ipsec_errcode = 2;
  return 0xFFFFFFFFLL;
}

uint64_t sub_1000422B0(int a1, int a2)
{
  return sub_1000422BC(a1, 22, a2);
}

uint64_t sub_1000422BC(int a1, char a2, int a3)
{
  uint64_t v6 = (char *)malloc_type_calloc(1uLL, 0x20uLL, 0x227B07EuLL);
  if (!v6)
  {
    uint64_t v10 = __error();
    strerror(*v10);
    __ipsec_set_strerror();
    return 0xFFFFFFFFLL;
  }
  int v7 = v6;
  pid_t v8 = getpid();
  char *v7 = 2;
  v7[1] = a2;
  *((_WORD *)v7 + 1) = 0;
  *(void *)(v7 + 4) = 4;
  *((_DWORD *)v7 + 3) = v8;
  *((void *)v7 + 2) = 1179650;
  *((_DWORD *)v7 + 6) = a3;
  *((_DWORD *)v7 + 7) = 0;
  ssize_t v9 = sub_100040DB0(a1, v7, 0x20u);
  free(v7);
  if ((v9 & 0x80000000) != 0) {
    return 0xFFFFFFFFLL;
  }
  __ipsec_errcode = 0;
  return v9;
}

uint64_t sub_100042380(int a1, int a2)
{
  return sub_1000422BC(a1, 24, a2);
}

uint64_t sub_10004238C(int a1, int a2)
{
  return sub_1000422BC(a1, 25, a2);
}

uint64_t sub_100042398(int a1, int a2)
{
  return sub_1000422BC(a1, 16, a2);
}

ssize_t sub_1000423A4(int a1, unsigned __int8 *a2, unsigned int a3, unsigned __int8 *a4, unsigned int a5, char a6, void *__src, int a8, int a9)
{
  if (a8 == 16) {
    return sub_100041D08(a1, 20, a2, 0, a3, a4, 0, a5, a6, 0, 0, __src, 16, a9, 0, 0, 0, 0);
  }
  __ipsec_errcode = 2;
  return 0xFFFFFFFFLL;
}

uint64_t sub_100042430(int a1)
{
  return sub_10004183C(a1, 19, 0);
}

uint64_t sub_10004243C(int a1)
{
  return sub_10004183C(a1, 18, 0);
}

uint64_t sub_100042448()
{
  size_t v6 = 8;
  uint64_t v7 = 0;
  uint64_t v5 = 2506752;
  uint64_t v0 = socket(29, 3, 2);
  if ((v0 & 0x80000000) != 0)
  {
    char v3 = __error();
    strerror(*v3);
    __ipsec_set_strerror();
    return 0xFFFFFFFFLL;
  }
  else
  {
    uint64_t v1 = v0;
    if (sysctlbyname("kern.ipc.maxsockbuf", &v7, &v6, &v5, 8uLL)) {
      int v2 = 233016;
    }
    else {
      int v2 = 2228224;
    }
    int v8 = v2;
    setsockopt(v1, 0xFFFF, 4097, &v8, 4u);
    setsockopt(v1, 0xFFFF, 4098, &v8, 4u);
    if (v8 == 2228224) {
      sysctlbyname("kern.ipc.maxsockbuf", 0, 0, &v7, v6);
    }
    __ipsec_errcode = 0;
  }
  return v1;
}

uint64_t sub_10004254C(int a1)
{
  uint64_t result = close(a1);
  __ipsec_errcode = 0;
  return result;
}

uint64_t sub_100042570(uint64_t a1, uint64_t a2)
{
  uint64_t result = 0xFFFFFFFFLL;
  int v4 = 2;
  if (a1 && a2)
  {
    *(void *)(a2 + 232) = 0;
    *(_OWORD *)(a2 + 216) = 0u;
    *(_OWORD *)(a2 + 200) = 0u;
    *(_OWORD *)(a2 + 184) = 0u;
    *(_OWORD *)(a2 + 168) = 0u;
    *(_OWORD *)(a2 + 152) = 0u;
    *(_OWORD *)(a2 + 136) = 0u;
    *(_OWORD *)(a2 + 120) = 0u;
    *(_OWORD *)(a2 + 104) = 0u;
    *(_OWORD *)(a2 + 88) = 0u;
    *(_OWORD *)(a2 + 72) = 0u;
    *(_OWORD *)(a2 + 56) = 0u;
    *(_OWORD *)(a2 + 40) = 0u;
    *(_OWORD *)(a2 + 24) = 0u;
    *(_OWORD *)(a2 + 8) = 0u;
    unint64_t v5 = *(unsigned __int16 *)(a1 + 4);
    unint64_t v6 = a1 + 8 * v5;
    *(void *)a2 = a1;
    uint64_t v7 = (unsigned __int16 *)(a1 + 16);
    if (v5 >= 3)
    {
      while (1)
      {
        int v8 = &v7[4 * *v7];
        if (!*v7 || v6 < (unint64_t)v8) {
          break;
        }
        uint64_t v10 = v7[1];
        if (*(void *)(a2 + 8 * v10))
        {
          uint64_t result = 0xFFFFFFFFLL;
          int v4 = 12;
          goto LABEL_11;
        }
        int v4 = 12;
        if (v10 > 0x1A || ((1 << v10) & 0x7FDFFFE) == 0) {
          goto LABEL_11;
        }
        *(void *)(a2 + 8 * v10) = v7;
        if ((unint64_t)v8 < v6)
        {
          uint64_t v7 = v8;
          if (v6 >= (unint64_t)(v8 + 2)) {
            continue;
          }
        }
        goto LABEL_5;
      }
    }
    int v8 = v7;
LABEL_5:
    if (v8 == (unsigned __int16 *)v6) {
      int v4 = 0;
    }
    else {
      int v4 = 3;
    }
    if (v8 == (unsigned __int16 *)v6) {
      uint64_t result = 0;
    }
    else {
      uint64_t result = 0xFFFFFFFFLL;
    }
  }
LABEL_11:
  __ipsec_errcode = v4;
  return result;
}

uint64_t sub_100042670(uint64_t a1)
{
  if (a1 && (int v2 = *(unsigned char **)a1) != 0)
  {
    if (*v2 == 2)
    {
      unsigned int v3 = v2[1];
      if (v3 <= 0x1A)
      {
        int v6 = v2[3];
        uint64_t result = 0xFFFFFFFFLL;
        int v5 = 1;
        switch(v6)
        {
          case 0:
            char v7 = v3 - 1;
            if ((v3 - 1) >= 8u) {
              goto LABEL_17;
            }
            unsigned int v8 = 191;
            goto LABEL_14;
          case 1:
            if (v3 == 11) {
              goto LABEL_17;
            }
            goto LABEL_24;
          case 2:
          case 3:
          case 9:
            char v7 = v3 - 14;
            if (v3 - 14 < 6)
            {
              unsigned int v8 = 55;
LABEL_14:
              if ((v8 >> v7)) {
                goto LABEL_25;
              }
            }
LABEL_17:
            uint64_t v9 = *(void *)(a1 + 40);
            if (!v9) {
              goto LABEL_23;
            }
            uint64_t v10 = *(void *)(a1 + 48);
            if (!v10) {
              goto LABEL_23;
            }
            if (*(unsigned __int8 *)(v9 + 4) == *(unsigned __int8 *)(v10 + 4))
            {
              int v11 = *(unsigned __int8 *)(v9 + 9);
              if (v11 == *(unsigned __int8 *)(v10 + 9))
              {
                if (v11 == 30 || v11 == 2)
                {
LABEL_23:
                  int v5 = 0;
                  uint64_t result = 0;
                }
                else
                {
                  int v5 = 15;
                }
              }
              else
              {
                int v5 = 24;
              }
            }
            else
            {
              int v5 = 23;
            }
            break;
          case 5:
          case 6:
          case 7:
          case 8:
            break;
          default:
LABEL_24:
            uint64_t result = 0xFFFFFFFFLL;
LABEL_25:
            int v5 = 10;
            break;
        }
      }
      else
      {
        uint64_t result = 0xFFFFFFFFLL;
        int v5 = 11;
      }
    }
    else
    {
      uint64_t result = 0xFFFFFFFFLL;
      int v5 = 4;
    }
  }
  else
  {
    uint64_t result = 0xFFFFFFFFLL;
    int v5 = 2;
  }
  __ipsec_errcode = v5;
  return result;
}

uint64_t sub_1000427D0(int a1, int a2, void *a3, unsigned int a4, int a5, const void *a6, int a7)
{
  ssize_t v7 = 0xFFFFFFFFLL;
  if (a3 && a6 && a7)
  {
    int v15 = 40 * a7;
    size_t v16 = 40 * a7 + 56;
    char v17 = malloc_type_calloc(1uLL, v16, 0x951258BBuLL);
    if (v17)
    {
      uint64_t v18 = v17;
      pid_t v19 = getpid();
      if ((int)v16 <= 15) {
        goto LABEL_11;
      }
      void *v18 = 0;
      v18[1] = 0;
      *(_DWORD *)uint64_t v18 = 5890;
      *((_DWORD *)v18 + 1) = (unsigned __int16)(v16 >> 3);
      *((_DWORD *)v18 + 2) = a2;
      *((_DWORD *)v18 + 3) = v19;
      if (!a4 || v16 < 0x28) {
        goto LABEL_11;
      }
      int v20 = (char *)(v18 + 5);
      v18[2] = 0;
      v18[3] = 0;
      v18[4] = 0;
      *((_DWORD *)v18 + 4) = 1310723;
      v18[3] = *a3;
      if (a4 >= 2) {
        v18[4] = a3[1];
      }
      uint64_t v21 = (v15 + 16);
      if (&v20[v21] <= (char *)v18 + v16)
      {
        bzero(v20, (v15 + 16));
        *((_WORD *)v18 + 20) = v21 >> 3;
        *((_WORD *)v18 + 21) = 21;
        *((_DWORD *)v18 + 11) = a5;
        *((_DWORD *)v18 + 13) = a7;
        memmove(v18 + 7, a6, (40 * a7));
        ssize_t v7 = sub_100040DB0(a1, v18, v16);
        free(v18);
        if ((v7 & 0x80000000) == 0)
        {
          __ipsec_errcode = 0;
          return v7;
        }
      }
      else
      {
LABEL_11:
        free(v18);
      }
    }
    else
    {
      __int16 v22 = __error();
      strerror(*v22);
      __ipsec_set_strerror();
    }
    return 0xFFFFFFFFLL;
  }
  return v7;
}

uint64_t sub_100042968(uint64_t a1, unint64_t a2, char *__src, char *a4, char *a5, __int16 a6)
{
  uint64_t v6 = a1 + 80;
  if (a1 + 80 > a2) {
    return 0;
  }
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)a1 = 0u;
  *(_DWORD *)a1 = 1441802;
  if (__src) {
    strncpy((char *)(a1 + 4), __src, 0x17uLL);
  }
  if (a4) {
    strncpy((char *)(a1 + 28), a4, 0x17uLL);
  }
  if (a5) {
    strncpy((char *)(a1 + 52), a5, 0x17uLL);
  }
  *(_WORD *)(a1 + 76) = a6;
  return v6;
}

char *sub_100042A18(_WORD *a1, unint64_t a2, __int16 a3, const void *a4, unsigned int a5)
{
  int v5 = (a5 - 1) | 7;
  uint64_t v6 = (v5 + 9);
  ssize_t v7 = (char *)a1 + v6;
  if ((unint64_t)a1 + v6 > a2) {
    return 0;
  }
  bzero(a1, (v5 + 9));
  *a1 = v6 >> 3;
  a1[1] = a3;
  a1[2] = 8 * a5;
  a1[3] = 0;
  memcpy(a1 + 4, a4, a5);
  return v7;
}

void sub_100042AA8(uint64_t a1, void *a2)
{
  if (*a2 <= 0x1BuLL)
  {
    if (dword_10008FA20)
    {
      int v2 = ne_log_obj();
      if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR)) {
        sub_100067EE4();
      }
    }
    return;
  }
  uint64_t v4 = a2[1];
  if ((*(unsigned char *)(v4 + 19) & 1) == 0)
  {
    if (dword_10008FA20)
    {
      int v5 = ne_log_obj();
      if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR)) {
        sub_100067F18();
      }
    }
    return;
  }
  uint64_t v7 = *(void *)(a1 + 408);
  unsigned int v8 = *(uint64_t **)(v7 + 1176);
  if (v8)
  {
    int v9 = *(_DWORD *)(v4 + 20);
    if (*(_DWORD *)(v7 + 1184) == v9) {
      goto LABEL_14;
    }
  }
  else
  {
    int v9 = *(_DWORD *)(v4 + 20);
  }
  unsigned int v8 = sub_100042FA8(a1, v9);
  *(void *)(*(void *)(a1 + 408) + 1176) = v8;
LABEL_14:
  uint64_t v10 = sub_10002E028(a1, a2, *v8, v8[1]);
  if (!v10)
  {
    if (dword_10008FA20)
    {
      int v20 = ne_log_obj();
      if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR)) {
        sub_100067F4C();
      }
    }
    return;
  }
  int v11 = v10;
  if (dword_10008FA20)
  {
    uint64_t v12 = ne_log_obj();
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint8_t buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "MODE_CFG packet\n", buf, 2u);
    }
  }
  uint64_t v13 = v11[1];
  signed int v14 = *(_DWORD *)v11 - 28;
  unsigned int v15 = *(unsigned __int8 *)(v13 + 16);
  if (v14 < 1 || v15 == 0)
  {
LABEL_23:
    uint64_t v17 = sub_100007F40(a1, *(_DWORD *)(v13 + 20));
    if (v17)
    {
      uint64_t v18 = v17;
      uint64_t v19 = *(unsigned int *)(v17 + 68);
      if (v19)
      {
        sub_10003AC14(v19);
        *(_DWORD *)(v18 + 68) = 0;
      }
      sub_10004B62C((void *)v18);
    }
    goto LABEL_27;
  }
  uint64_t v21 = (unsigned __int8 *)(v13 + 28);
  while (1)
  {
    if (v14 <= 3)
    {
      if (!dword_10008FA20) {
        goto LABEL_27;
      }
      size_t v36 = ne_log_obj();
      if (!os_log_type_enabled(v36, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_27;
      }
      *(_WORD *)uint8_t buf = 0;
      uint64_t v37 = "Short payload header\n";
      goto LABEL_60;
    }
    size_t v22 = v14;
    if (v14 < bswap32(*((unsigned __int16 *)v21 + 1)) >> 16)
    {
      if (!dword_10008FA20) {
        goto LABEL_27;
      }
      size_t v36 = ne_log_obj();
      if (!os_log_type_enabled(v36, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_27;
      }
      *(_WORD *)uint8_t buf = 0;
      uint64_t v37 = "Short payload\n";
LABEL_60:
      uint64_t v38 = v36;
      uint32_t v39 = 2;
      goto LABEL_61;
    }
    if (dword_10008FA20)
    {
      char v23 = ne_log_obj();
      if (os_log_type_enabled(v23, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)uint8_t buf = 67109120;
        unsigned int v47 = v15;
        _os_log_debug_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEBUG, "Seen payload %d\n", buf, 8u);
      }
    }
    if (v15 == 14)
    {
      sub_100043034(a1, *(_DWORD *)(v13 + 20), (uint64_t)v21, (uint64_t)a2);
      goto LABEL_48;
    }
    if (v15 != 8)
    {
      if (dword_10008FA20)
      {
        ssize_t v32 = ne_log_obj();
        if (os_log_type_enabled(v32, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)uint8_t buf = 67109120;
          unsigned int v47 = v15;
          _os_log_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_DEFAULT, "Unexpected next payload %d\n", buf, 8u);
        }
      }
      goto LABEL_48;
    }
    uint64_t v24 = bswap32(*((unsigned __int16 *)v21 + 1)) >> 16;
    uint64_t v25 = (unsigned __int16 *)&v21[v24];
    unsigned int v26 = bswap32(*(unsigned __int16 *)&v21[v24 + 2]);
    size_t v27 = HIWORD(v26);
    if (v24 + v27 > v22)
    {
      if (!dword_10008FA20) {
        goto LABEL_27;
      }
      unsigned int v40 = ne_log_obj();
      if (!os_log_type_enabled(v40, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_27;
      }
      unsigned int v41 = bswap32(v25[1]);
      *(_DWORD *)uint8_t buf = 67109376;
      unsigned int v47 = HIWORD(v41);
      __int16 v48 = 1024;
      int v49 = v27;
      uint64_t v37 = "Invalid Hash payload. len %d, overall-len %d\n";
      uint64_t v38 = v40;
      uint32_t v39 = 14;
LABEL_61:
      _os_log_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_DEFAULT, v37, buf, v39);
      goto LABEL_27;
    }
    int v28 = sub_10003F940(HIWORD(v26));
    if (!v28)
    {
      if (dword_10008FA20)
      {
        long long v42 = ne_log_obj();
        if (os_log_type_enabled(v42, OS_LOG_TYPE_ERROR)) {
          sub_10005BA50();
        }
      }
      goto LABEL_27;
    }
    BOOL v29 = v28;
    memcpy((void *)v28[1], v25, v27);
    uint64_t v30 = sub_10002A314(a1, *(_DWORD *)(v13 + 20), (uint64_t)v29);
    if (!v30) {
      break;
    }
    uint64_t v31 = v30;
    if (timingsafe_bcmp(v21 + 4, *(const void **)(v31 + 8), *(void *)v31))
    {
      if (dword_10008FA20)
      {
        __int16 v45 = ne_log_obj();
        if (os_log_type_enabled(v45, OS_LOG_TYPE_ERROR)) {
          sub_100067FB4();
        }
      }
      sub_10003FA78(v29);
      char v44 = (void *)v31;
      goto LABEL_76;
    }
    sub_10003FA78(v29);
    sub_10003FA78((void *)v31);
LABEL_48:
    unsigned int v33 = bswap32(*((unsigned __int16 *)v21 + 1));
    uint64_t v34 = HIWORD(v33);
    signed int v14 = v22 - HIWORD(v33);
    unsigned int v15 = *v21;
    v21 += v34;
    if (v14 < 1 || v15 == 0) {
      goto LABEL_23;
    }
  }
  if (dword_10008FA20)
  {
    unint64_t v43 = ne_log_obj();
    if (os_log_type_enabled(v43, OS_LOG_TYPE_ERROR)) {
      sub_100067F80();
    }
  }
  char v44 = v29;
LABEL_76:
  sub_10003FA78(v44);
LABEL_27:
  sub_10003FA78(v11);
}

uint64_t *sub_100042FA8(uint64_t a1, int a2)
{
  uint64_t v2 = *(void *)(a1 + 408);
  if (v2)
  {
    int v5 = *(void **)(v2 + 1176);
    if (v5) {
      sub_10002DA30(v5);
    }
    uint64_t result = sub_10002DAA8(a1, a2);
    *(void *)(v2 + 1176) = result;
    *(_DWORD *)(v2 + 1184) = a2;
  }
  else
  {
    if (dword_10008FA20)
    {
      uint64_t v7 = ne_log_obj();
      if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR)) {
        sub_100067FE8();
      }
    }
    return 0;
  }
  return result;
}

uint64_t sub_100043034(uint64_t a1, int a2, uint64_t a3, uint64_t a4)
{
  int v8 = *(unsigned __int8 *)(a3 + 4);
  if (dword_10008FA20)
  {
    int v9 = ne_log_obj();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      int v12 = 136315138;
      uint64_t v13 = sub_10003E2CC(v8);
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "Configuration exchange type %s\n", (uint8_t *)&v12, 0xCu);
    }
  }
  switch(v8)
  {
    case 1:
      *(_DWORD *)(a1 + 84) = a2;
      uint64_t result = sub_10004383C(a1, (unsigned __int16 *)a3, a4);
      break;
    case 2:
      uint64_t result = sub_1000431FC(a1, (unsigned __int16 *)a3);
      break;
    case 3:
      *(_DWORD *)(a1 + 84) = a2;
      uint64_t result = sub_100044064(a1, (unsigned __int16 *)a3, a4);
      break;
    case 4:
      sub_10002DA30(*(void **)(*(void *)(a1 + 408) + 1176));
      uint64_t result = 0;
      *(void *)(*(void *)(a1 + 408) + 1176) = 0;
      break;
    default:
      if (dword_10008FA20)
      {
        int v11 = ne_log_obj();
        if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
        {
          int v12 = 67109120;
          LODWORD(v13) = v8;
          _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "Unepected configuration exchange type %d\n", (uint8_t *)&v12, 8u);
        }
      }
      uint64_t result = 0xFFFFFFFFLL;
      break;
  }
  return result;
}

uint64_t sub_1000431FC(uint64_t a1, unsigned __int16 *a2)
{
  uint64_t v2 = *(int **)(a1 + 408);
  int v3 = *v2;
  if ((*v2 & 0x8000) != 0) {
    return 0;
  }
  uint64_t v6 = a2 + 1;
  unsigned int v7 = bswap32(a2[1]) >> 16;
  int v8 = a2 + 4;
  if (v7 < 9)
  {
LABEL_54:
    *uint64_t v2 = v3 | 0x8000;
    if (*(_DWORD *)(a1 + 24)
      || (*(unsigned char *)(a1 + 432) & 1) != 0 && (uint64_t v44 = *(void *)(a1 + 440)) != 0 && (*(_WORD *)(v44 + 264) & 0x400) != 0)
    {
      int v35 = (void *)*((void *)v2 + 149);
      if (v35) {
        sub_10003FA78(v35);
      }
      uint64_t v36 = bswap32(*v6) >> 16;
      if (v36 <= 7)
      {
        if (dword_10008FA20)
        {
          uint64_t v37 = ne_log_obj();
          if (os_log_type_enabled(v37, OS_LOG_TYPE_ERROR)) {
            sub_100068100((uint64_t)v6, v37, v38, v39, v40, v41, v42, v43);
          }
        }
        return 0xFFFFFFFFLL;
      }
      size_t v45 = v36 - 8;
      pid_t v46 = sub_10003F940(v36 - 8);
      *(void *)(*(void *)(a1 + 408) + 1192) = v46;
      if (!v46)
      {
        if (dword_10008FA20)
        {
          __int16 v48 = ne_log_obj();
          if (os_log_type_enabled(v48, OS_LOG_TYPE_ERROR)) {
            sub_100068178();
          }
        }
        return 0xFFFFFFFFLL;
      }
      memcpy((void *)v46[1], v8, v45);
    }
    if ((*(unsigned char *)(a1 + 17) & 0x20) != 0) {
      sub_1000496DC(0, 0, a1, 0);
    }
    return 0;
  }
  int v9 = v7 - 8;
  int v49 = a2 + 4;
  while (1)
  {
    int v10 = v9;
    if (v9 <= 3) {
      break;
    }
    int v11 = (int)bswap32(*v8) >> 16;
    if (v11 < 0)
    {
      int v15 = v11 & 0x7FFF;
      if (dword_10008FA20)
      {
        size_t v16 = ne_log_obj();
        if (os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG))
        {
          ssize_t v32 = sub_10003E254(v11 & 0x7FFF);
          unsigned int v33 = bswap32(v8[1]) >> 16;
          *(_DWORD *)uint8_t buf = 136315394;
          int v51 = v32;
          __int16 v52 = 1024;
          LODWORD(v53) = v33;
          _os_log_debug_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEBUG, "Short attribute %s = %d\n", buf, 0x12u);
        }
      }
      if (v15 == 28679)
      {
        sub_100046070(a1, v8);
      }
      else if (v15 == 16520)
      {
        uint64_t result = sub_100046680(a1, v8, bswap32(a2[3]) >> 16);
        if (result) {
          return result;
        }
      }
      else if (dword_10008FA20)
      {
        uint64_t v19 = ne_log_obj();
        if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
        {
          int v20 = sub_10003E254(v11 & 0x7FFF);
          *(_DWORD *)uint8_t buf = 136315138;
          int v51 = v20;
          _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "Ignored short attribute %s\n", buf, 0xCu);
        }
      }
      int v9 = v10 - 4;
      v8 += 2;
      goto LABEL_34;
    }
    uint64_t v12 = bswap32(v8[1]) >> 16;
    if (v12 + 4 > (unint64_t)v9)
    {
      if (dword_10008FA20)
      {
        unsigned int v47 = ne_log_obj();
        if (os_log_type_enabled(v47, OS_LOG_TYPE_ERROR)) {
          sub_100068084((unsigned __int16)v11);
        }
      }
      return 0xFFFFFFFFLL;
    }
    if (dword_10008FA20)
    {
      uint64_t v13 = ne_log_obj();
      if (os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG))
      {
        size_t v27 = sub_10003E254((unsigned __int16)v11);
        *(_DWORD *)uint8_t buf = 136315394;
        int v51 = v27;
        __int16 v52 = 2048;
        uint64_t v53 = v12;
        _os_log_debug_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEBUG, "Attribute %s, len %zu\n", buf, 0x16u);
      }
    }
    if ((unsigned __int16)v11 - 28672 > 0xB)
    {
LABEL_11:
      if ((unsigned __int16)v11 - 16520 >= 0xA)
      {
        switch((__int16)v11)
        {
          case 1:
            uint64_t v28 = *(void *)(a1 + 408);
            if ((*(unsigned char *)v28 & 0x80) != 0) {
              goto LABEL_23;
            }
            sub_1000443F0((uint64_t)v8, (_DWORD *)(v28 + 40));
            uint64_t v25 = *(int **)(a1 + 408);
            int v26 = *v25 | 0x80;
            goto LABEL_50;
          case 2:
            uint64_t v29 = *(void *)(a1 + 408);
            if (*(unsigned char *)(v29 + 1)) {
              goto LABEL_23;
            }
            sub_1000443F0((uint64_t)v8, (_DWORD *)(v29 + 44));
            uint64_t v25 = *(int **)(a1 + 408);
            int v26 = *v25 | 0x100;
            goto LABEL_50;
          case 3:
            uint64_t v30 = *(void *)(a1 + 408);
            if ((*(unsigned char *)(v30 + 1) & 2) != 0) {
              goto LABEL_23;
            }
            sub_100044454((uint64_t)v8, (_DWORD *)(v30 + 4 * *(int *)(v30 + 60) + 48), (_DWORD *)(v30 + 60));
            uint64_t v25 = *(int **)(a1 + 408);
            int v26 = *v25 | 0x200;
            goto LABEL_50;
          case 4:
            uint64_t v31 = *(void *)(a1 + 408);
            if ((*(unsigned char *)(v31 + 1) & 4) != 0) {
              goto LABEL_23;
            }
            sub_100044454((uint64_t)v8, (_DWORD *)(v31 + 4 * *(int *)(v31 + 80) + 64), (_DWORD *)(v31 + 80));
            uint64_t v25 = *(int **)(a1 + 408);
            int v26 = *v25 | 0x400;
            goto LABEL_50;
          case 5:
          case 13:
            if (!*(_DWORD *)(a1 + 24)) {
              goto LABEL_26;
            }
            goto LABEL_23;
          case 7:
            goto LABEL_22;
          default:
LABEL_26:
            if (dword_10008FA20)
            {
              uint64_t v17 = ne_log_obj();
              if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
              {
                uint64_t v18 = sub_10003E254((unsigned __int16)v11);
                *(_DWORD *)uint8_t buf = 136315138;
                int v51 = v18;
                _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "Ignored attribute %s\n", buf, 0xCu);
              }
            }
            goto LABEL_23;
        }
      }
      uint64_t result = sub_100046680(a1, v8, bswap32(a2[3]) >> 16);
      if (result) {
        return result;
      }
      goto LABEL_23;
    }
    if (((1 << v11) & 0xF7B) != 0)
    {
LABEL_22:
      sub_100046070(a1, v8);
    }
    else
    {
      if ((unsigned __int16)v11 != 28674) {
        goto LABEL_11;
      }
      uint64_t v21 = *(void *)(a1 + 408);
      if ((*(unsigned char *)(v21 + 1) & 0x10) == 0)
      {
        size_t v22 = (void *)(v21 + 84);
        unsigned int v23 = bswap32(v8[1]) >> 16;
        if (v23 >= 0x400) {
          size_t v24 = 1024;
        }
        else {
          size_t v24 = v23;
        }
        memcpy(v22, v8 + 2, v24);
        uint64_t v25 = *(int **)(a1 + 408);
        int v26 = *v25 | 0x1000;
LABEL_50:
        *uint64_t v25 = v26;
      }
    }
LABEL_23:
    int v8 = (unsigned __int16 *)((char *)v8 + v12 + 4);
    int v9 = v10 - (v12 + 4);
LABEL_34:
    if (v9 <= 0)
    {
      uint64_t v2 = *(int **)(a1 + 408);
      int v3 = *v2;
      int v8 = v49;
      goto LABEL_54;
    }
  }
  if (dword_10008FA20)
  {
    uint64_t v34 = ne_log_obj();
    if (os_log_type_enabled(v34, OS_LOG_TYPE_ERROR)) {
      sub_10006801C();
    }
  }
  return 0xFFFFFFFFLL;
}

uint64_t sub_10004383C(uint64_t a1, unsigned __int16 *a2, uint64_t a3)
{
  unsigned int v6 = bswap32(a2[1]) >> 16;
  unsigned int v7 = a2 + 4;
  int v8 = v6 - 8;
  if (!*(_DWORD *)(a1 + 24) && !sub_10004E7DC(a1))
  {
    uint64_t v11 = (uint64_t)sub_10003F940(8uLL);
    if (!v11)
    {
      if (dword_10008FA20)
      {
        uint64_t v44 = ne_log_obj();
        if (os_log_type_enabled(v44, OS_LOG_TYPE_ERROR)) {
          sub_10005BA50();
        }
      }
      return 0xFFFFFFFFLL;
    }
    int v10 = (size_t *)v11;
    uint64_t v47 = a3;
    **(void **)(v11 + 8) = 0;
    if (v6 < 9)
    {
LABEL_78:
      size_t v41 = v10[1];
      *(_WORD *)(v41 + 2) = bswap32(*(unsigned __int16 *)v10) >> 16;
      *(unsigned char *)(v41 + 4) = 2;
      *(_WORD *)(v41 + 6) = a2[3];
      if (dword_10008FA20)
      {
        uint64_t v42 = ne_log_obj();
        if (os_log_type_enabled(v42, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)uint8_t buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v42, OS_LOG_TYPE_DEFAULT, "Sending MODE_CFG REPLY\n", buf, 2u);
        }
      }
      uint64_t v9 = sub_1000445EC(a1, (uint64_t)v10, 14, 1, 0, 0, v47);
      goto LABEL_82;
    }
    while (1)
    {
      int v12 = v8;
      if (v8 <= 3)
      {
        if (dword_10008FA20)
        {
          size_t v45 = ne_log_obj();
          if (os_log_type_enabled(v45, OS_LOG_TYPE_ERROR)) {
            sub_1000681AC();
          }
        }
LABEL_7:
        uint64_t v9 = 0xFFFFFFFFLL;
LABEL_82:
        sub_10003FA78(v10);
        return v9;
      }
      int v13 = (int)bswap32(*v7) >> 16;
      if (v13 < 0)
      {
        if (dword_10008FA20)
        {
          size_t v16 = ne_log_obj();
          uint64_t v11 = os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG);
          if (v11)
          {
            uint64_t v28 = sub_10003E254(v13 & 0x7FFF);
            unsigned int v29 = bswap32(v7[1]) >> 16;
            *(_DWORD *)uint8_t buf = 136315394;
            BOOL v57 = v28;
            __int16 v58 = 1024;
            LODWORD(v59) = v29;
            _os_log_debug_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEBUG, "Short attribute %s = %d\n", buf, 0x12u);
          }
        }
        if ((v13 & 0x7FFF) == 0x4088)
        {
          uint64_t v11 = (uint64_t)sub_1000472A8(a1, v7);
          if (v11)
          {
            uint64_t v17 = (void *)v11;
            int v10 = sub_1000444FC(v10, v11);
            sub_10003FA78(v17);
          }
        }
        else if (dword_10008FA20)
        {
          uint64_t v19 = ne_log_obj();
          uint64_t v11 = os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT);
          if (v11)
          {
            int v20 = sub_10003E254(v13 & 0x7FFF);
            *(_DWORD *)uint8_t buf = 136315138;
            BOOL v57 = v20;
            _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "Ignored short attribute %s\n", buf, 0xCu);
          }
        }
        int v8 = v12 - 4;
        v7 += 2;
        goto LABEL_35;
      }
      uint64_t v14 = bswap32(v7[1]) >> 16;
      if (v14 + 4 > (unint64_t)v8)
      {
        if (dword_10008FA20)
        {
          pid_t v46 = ne_log_obj();
          if (os_log_type_enabled(v46, OS_LOG_TYPE_ERROR)) {
            sub_100068084((unsigned __int16)v13);
          }
        }
        goto LABEL_7;
      }
      if (dword_10008FA20)
      {
        int v15 = ne_log_obj();
        uint64_t v11 = os_log_type_enabled(v15, OS_LOG_TYPE_DEBUG);
        if (v11)
        {
          size_t v27 = sub_10003E254((unsigned __int16)v13);
          *(_DWORD *)uint8_t buf = 136315394;
          BOOL v57 = v27;
          __int16 v58 = 2048;
          uint64_t v59 = v14;
          _os_log_debug_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEBUG, "Attribute %s, len %zu\n", buf, 0x16u);
        }
      }
      if ((unsigned __int16)v13 >= 0x7000u)
      {
        if ((unsigned __int16)v13 - 28672 >= 0xB) {
          goto LABEL_44;
        }
        uint64_t v11 = (uint64_t)sub_100045A38();
      }
      else if ((unsigned __int16)v13 <= 0x4087u)
      {
        if ((unsigned __int16)v13 - 1 < 4) {
          goto LABEL_38;
        }
        if ((unsigned __int16)v13 != 7)
        {
          if ((unsigned __int16)v13 != 13)
          {
LABEL_44:
            if (dword_10008FA20)
            {
              unsigned int v23 = ne_log_obj();
              uint64_t v11 = os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT);
              if (v11)
              {
                size_t v24 = sub_10003E254((unsigned __int16)v13);
                *(_DWORD *)uint8_t buf = 136315138;
                BOOL v57 = v24;
                _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "Ignored attribute %s\n", buf, 0xCu);
              }
            }
            goto LABEL_30;
          }
LABEL_38:
          unsigned int v21 = *v7;
          uint64_t v11 = sub_1000471C0((void *)a1);
          if (v11)
          {
            if (dword_10008FA20)
            {
              size_t v22 = ne_log_obj();
              uint64_t v11 = os_log_type_enabled(v22, OS_LOG_TYPE_ERROR);
              if (v11) {
                sub_100068274(&v54, v55);
              }
            }
            goto LABEL_30;
          }
          unsigned int v25 = bswap32(v21) >> 16;
          switch(v25)
          {
            case 1u:
              if (dword_10008FE84)
              {
                if (dword_10008FA20)
                {
                  int v26 = ne_log_obj();
                  if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR)) {
                    sub_100068244(&v50, v51);
                  }
                }
              }
              else if (sub_1000452A4(a1) == -1)
              {
                if (dword_10008FA20)
                {
                  uint64_t v39 = ne_log_obj();
                  if (os_log_type_enabled(v39, OS_LOG_TYPE_ERROR)) {
                    sub_100068214(&v52, v53);
                  }
                }
              }
              else
              {
                uint64_t v36 = *(int **)(a1 + 408);
                int v37 = *v36;
                v36[10] = bswap32(v36[1] + bswap32(xmmword_10008FE38));
                *uint64_t v36 = v37 | 0x20;
              }
              uint64_t v31 = (long long *)(*(void *)(a1 + 408) + 40);
              goto LABEL_73;
            case 2u:
              if (dword_10008FE84)
              {
                if (dword_10008FA20)
                {
                  ssize_t v32 = ne_log_obj();
                  if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR)) {
                    sub_100068244(&v48, v49);
                  }
                }
              }
              else
              {
                uint64_t v38 = *(_DWORD **)(a1 + 408);
                v38[11] = DWORD1(xmmword_10008FE38);
                *v38 |= 0x40u;
              }
              uint64_t v31 = (long long *)(*(void *)(a1 + 408) + 44);
LABEL_73:
              uint64_t v30 = v7;
              goto LABEL_74;
            case 3u:
              unsigned int v33 = (int *)&xmmword_10008FE38 + 2;
              int v34 = dword_10008FE4C;
              goto LABEL_61;
            case 4u:
              unsigned int v33 = (int *)&unk_10008FE50;
              int v34 = dword_10008FE60;
LABEL_61:
              uint64_t v11 = (uint64_t)sub_100045904(v7, v33, v34);
              goto LABEL_28;
            default:
              if (v25 != 13)
              {
                if (dword_10008FA20)
                {
                  int v35 = ne_log_obj();
                  uint64_t v11 = os_log_type_enabled(v35, OS_LOG_TYPE_ERROR);
                  if (v11)
                  {
                    *(_DWORD *)uint8_t buf = 67109120;
                    LODWORD(v57) = v25;
                    _os_log_error_impl((void *)&_mh_execute_header, v35, OS_LOG_TYPE_ERROR, "Unexpected type %d\n", buf, 8u);
                  }
                }
                goto LABEL_30;
              }
              uint64_t v30 = v7;
              uint64_t v31 = &xmmword_10008FE38;
LABEL_74:
              uint64_t v11 = (uint64_t)sub_100045874(v30, v31);
              break;
          }
          goto LABEL_28;
        }
        uint64_t v11 = (uint64_t)sub_100044F8C(v11, v7, "racoon / IPsec-tools", 0x14uLL);
      }
      else
      {
        if ((unsigned __int16)v13 - 16520 >= 0xA) {
          goto LABEL_44;
        }
        uint64_t v11 = (uint64_t)sub_1000472A8(a1, v7);
      }
LABEL_28:
      uint64_t v18 = (void *)v11;
      if (v11)
      {
        int v10 = sub_1000444FC(v10, v11);
        sub_10003FA78(v18);
      }
LABEL_30:
      unsigned int v7 = (unsigned __int16 *)((char *)v7 + v14 + 4);
      int v8 = v12 - (v14 + 4);
LABEL_35:
      if (v8 <= 0) {
        goto LABEL_78;
      }
    }
  }
  if (!*(unsigned char *)(a1 + 417))
  {
    *(unsigned char *)(a1 + 416) = *((unsigned char *)a2 + 6);
    if (sub_100049110(a1, v7, v8))
    {
      int v10 = 0;
      goto LABEL_7;
    }
    *(unsigned char *)(a1 + 417) = 1;
    *(void *)(a1 + 424) = sub_10003FAC0(a3);
    sub_10004E848((void *)a1);
    if (dword_10008FA20)
    {
      uint64_t v40 = ne_log_obj();
      uint64_t v9 = 0;
      if (!os_log_type_enabled(v40, OS_LOG_TYPE_DEFAULT)) {
        return v9;
      }
      *(_WORD *)uint8_t buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v40, OS_LOG_TYPE_DEFAULT, "IPSec Extended Authentication requested.\n", buf, 2u);
    }
  }
  return 0;
}

uint64_t sub_100044064(uint64_t a1, unsigned __int16 *a2, uint64_t a3)
{
  unsigned int v6 = sub_10003F940(8uLL);
  if (!v6)
  {
    if (dword_10008FA20)
    {
      unsigned int v21 = ne_log_obj();
      if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR)) {
        sub_10005BA50();
      }
    }
    return 0xFFFFFFFFLL;
  }
  unsigned int v7 = v6;
  *(void *)v6[1] = 0;
  unsigned int v8 = bswap32(a2[1]) >> 16;
  if (v8 < 9)
  {
LABEL_20:
    size_t v18 = v7[1];
    *(_WORD *)(v18 + 2) = bswap32(*(unsigned __int16 *)v7) >> 16;
    *(unsigned char *)(v18 + 4) = 4;
    *(_WORD *)(v18 + 6) = a2[3];
    if (dword_10008FA20)
    {
      uint64_t v19 = ne_log_obj();
      if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)uint8_t buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "Sending MODE_CFG ACK\n", buf, 2u);
      }
    }
    uint64_t v20 = sub_1000445EC(a1, (uint64_t)v7, 14, 1, 0, 0, a3);
    if ((*(unsigned char *)(*(void *)(a1 + 408) + 1) & 8) != 0)
    {
      if ((*(unsigned char *)(a1 + 17) & 0x20) != 0) {
        sub_10001A098(a1);
      }
      sub_100022854(a1);
      sub_10003FA78(v7);
    }
    else
    {
      sub_10003FA78(v7);
      if ((*(unsigned char *)(a1 + 432) & 1) == 0 && *(_DWORD *)(*(void *)(a1 + 64) + 156) && !v20) {
        return sub_100044C04(a1);
      }
    }
    return v20;
  }
  int v9 = v8 - 8;
  int v10 = a2 + 4;
  while (1)
  {
    unint64_t v11 = v9;
    if (v9 <= 3) {
      break;
    }
    unsigned int v12 = bswap32(*v10) >> 16;
    if (dword_10008FA20)
    {
      int v13 = ne_log_obj();
      if (os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG)) {
        sub_100068368(&v33, v12, &v34);
      }
    }
    if ((v12 & 0x7FFF) == 0x408F)
    {
      uint64_t v14 = sub_100047794(a1, v10);
      if (v14)
      {
        int v15 = v14;
        unsigned int v7 = sub_1000444FC(v7, (uint64_t)v14);
        sub_10003FA78(v15);
        if ((v12 & 0x8000) != 0) {
          goto LABEL_18;
        }
        goto LABEL_15;
      }
LABEL_14:
      if ((v12 & 0x8000) != 0) {
        goto LABEL_18;
      }
      goto LABEL_15;
    }
    if (!dword_10008FA20) {
      goto LABEL_14;
    }
    size_t v16 = ne_log_obj();
    if (!os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG)) {
      goto LABEL_14;
    }
    sub_10006830C(&v31, v12 & 0x7FFF, &v32);
    if ((v12 & 0x8000) != 0)
    {
LABEL_18:
      int v9 = v11 - 4;
      v10 += 2;
      goto LABEL_19;
    }
LABEL_15:
    uint64_t v17 = bswap32(v10[1]) >> 16;
    if (v17 + 4 > v11)
    {
      if (dword_10008FA20)
      {
        unsigned int v23 = ne_log_obj();
        if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)uint8_t buf = 67109632;
          unsigned int v26 = v12;
          __int16 v27 = 2048;
          uint64_t v28 = v17;
          __int16 v29 = 2048;
          unint64_t v30 = v11 - 4;
          _os_log_error_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_ERROR, "isakmp_cfg_set packet too short for type %d, expected %zu actual %zu\n", buf, 0x1Cu);
        }
      }
      goto LABEL_40;
    }
    int v9 = v11 - (v17 + 4);
    int v10 = (unsigned __int16 *)((char *)v10 + v17 + 4);
LABEL_19:
    if (v9 <= 0) {
      goto LABEL_20;
    }
  }
  if (dword_10008FA20)
  {
    size_t v22 = ne_log_obj();
    if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR)) {
      sub_1000682A4();
    }
  }
LABEL_40:
  sub_10003FA78(v7);
  return 0xFFFFFFFFLL;
}

void sub_1000443F0(uint64_t a1, _DWORD *a2)
{
  if (*(_WORD *)(a1 + 2) == 1024)
  {
    *a2 = *(_DWORD *)(a1 + 4);
  }
  else if (dword_10008FA20)
  {
    uint64_t v2 = ne_log_obj();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR)) {
      sub_1000683C4();
    }
  }
}

void sub_100044454(uint64_t a1, _DWORD *a2, _DWORD *a3)
{
  if (*(_WORD *)(a1 + 2) == 1024)
  {
    if (*a3 == 3)
    {
      if (dword_10008FA20)
      {
        int v3 = ne_log_obj();
        if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR)) {
          sub_1000683F8();
        }
      }
    }
    else
    {
      *a2 = *(_DWORD *)(a1 + 4);
      ++*a3;
    }
  }
  else if (dword_10008FA20)
  {
    uint64_t v4 = ne_log_obj();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR)) {
      sub_1000683C4();
    }
  }
}

size_t *sub_1000444FC(size_t *a1, uint64_t a2)
{
  int v3 = a1;
  uint64_t v4 = sub_10003F940(*(void *)a2 + *a1);
  if (v4)
  {
    int v5 = v4;
    memcpy((void *)v4[1], (const void *)v3[1], *v3);
    memcpy((void *)(v5[1] + *v3), *(const void **)(a2 + 8), *(void *)a2);
    sub_10003FA78(v3);
    return v5;
  }
  else if (dword_10008FA20)
  {
    unsigned int v6 = ne_log_obj();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR)) {
      sub_10005BA50();
    }
  }
  return v3;
}

void *sub_1000445A4(int a1, _WORD *a2, char *__s)
{
  size_t v5 = strlen(__s);

  return sub_100044F8C(v5, a2, __s, v5);
}

uint64_t sub_1000445EC(uint64_t a1, uint64_t a2, int a3, char a4, int a5, int a6, uint64_t a7)
{
  if ((*(unsigned char *)(a1 + 17) & 0x20) == 0 || !*(void *)(a1 + 56) || (uint64_t v8 = a1 + 48, !*(void *)(a1 + 48)))
  {
    if (dword_10008FA20)
    {
      size_t v24 = ne_log_obj();
      if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR)) {
        sub_10006842C();
      }
    }
    return 0xFFFFFFFFLL;
  }
  uint64_t v15 = *(void *)(a1 + 408);
  size_t v16 = sub_100008234(16, 2);
  if (!v16)
  {
    if (dword_10008FA20)
    {
      __int16 v27 = ne_log_obj();
      if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR)) {
        sub_100068460();
      }
    }
    return 0xFFFFFFFFLL;
  }
  uint64_t v17 = (uint64_t)v16;
  size_t v18 = sub_10003CC74();
  *(void *)(v17 + 8) = v18;
  if (!v18)
  {
    if (dword_10008FA20)
    {
      uint64_t v28 = ne_log_obj();
      if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR)) {
        sub_100068494();
      }
    }
    goto LABEL_66;
  }
  uint64_t v19 = sub_10003CC74();
  *(void *)uint64_t v17 = v19;
  if (!v19)
  {
    if (dword_10008FA20)
    {
      __int16 v29 = ne_log_obj();
      if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR)) {
        sub_1000684C8();
      }
    }
    goto LABEL_66;
  }
  int v20 = *(unsigned __int8 *)(*(void *)v8 + 1);
  if (v20 != 2 && v20 != 30)
  {
    if (dword_10008FA20)
    {
      unint64_t v30 = ne_log_obj();
      if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR)) {
        sub_1000684FC(a1 + 48, v30, v31, v32, v33, v34, v35, v36);
      }
    }
LABEL_66:
    sub_10000843C(v17);
    return 0xFFFFFFFFLL;
  }
  *(unsigned char *)(v17 + 60) = 0;
  sub_100002728((int *)(v17 + 56), 63);
  if (a5)
  {
    int v22 = sub_100026328(a1);
    *(_DWORD *)(v17 + 108) = v22;
    if (*(void *)(a1 + 208))
    {
      if (!sub_100042FA8(a1, v22))
      {
        if (dword_10008FA20)
        {
          char v52 = ne_log_obj();
          if (os_log_type_enabled(v52, OS_LOG_TYPE_ERROR)) {
            sub_10005B14C();
          }
        }
        goto LABEL_66;
      }
      int v23 = *(_DWORD *)(v17 + 108);
      goto LABEL_34;
    }
LABEL_36:
    uint64_t v38 = 0;
    int v39 = 0;
    goto LABEL_37;
  }
  int v23 = *(_DWORD *)(a1 + 84);
  *(_DWORD *)(v17 + 108) = v23;
  if (!*(void *)(a1 + 208)) {
    goto LABEL_36;
  }
LABEL_34:
  int v37 = (const void **)sub_10002A314(a1, v23, a2);
  if (!v37)
  {
    if (dword_10008FA20)
    {
      char v48 = ne_log_obj();
      if (os_log_type_enabled(v48, OS_LOG_TYPE_ERROR)) {
        sub_10005C100();
      }
    }
    goto LABEL_66;
  }
  uint64_t v38 = v37;
  int v39 = *(_DWORD *)v37 + 4;
LABEL_37:
  char v40 = v38 != 0;
  if ((a4 & 4) != 0) {
    char v40 = 4 * (v38 != 0);
  }
  *(unsigned char *)(v17 + 105) = v40;
  sub_10004C148(a1, (void *)v17);
  signed int v41 = v39 + *(_DWORD *)a2 + 28;
  uint64_t v42 = sub_10003F940(v41);
  *(void *)(v17 + 80) = v42;
  if (!v42)
  {
    if (dword_10008FA20)
    {
      uint64_t v47 = ne_log_obj();
      if (os_log_type_enabled(v47, OS_LOG_TYPE_ERROR)) {
        sub_10005CB90();
      }
    }
    goto LABEL_83;
  }
  uint64_t v43 = v42[1];
  *(void *)uint64_t v43 = *(void *)a1;
  *(void *)(v43 + 8) = *(void *)(a1 + 8);
  if (v38) {
    char v44 = 8;
  }
  else {
    char v44 = a3;
  }
  *(unsigned char *)(v43 + 16) = v44;
  *(unsigned char *)(v43 + 17) = *(unsigned char *)(a1 + 80);
  *(unsigned char *)(v43 + 18) = 6;
  *(unsigned char *)(v43 + 19) = *(unsigned char *)(v17 + 105);
  *(_DWORD *)(v43 + 20) = *(_DWORD *)(v17 + 108);
  *(_DWORD *)(v43 + 24) = bswap32(v41);
  if (v38)
  {
    *(unsigned char *)(v43 + 28) = a3;
    size_t v45 = (size_t)*v38;
    *(_WORD *)(v43 + 30) = bswap32(*v38 + 4) >> 16;
    memcpy((void *)(v43 + 32), v38[1], v45);
    pid_t v46 = (char *)*v38 + v43 + 32;
  }
  else
  {
    pid_t v46 = (char *)(v43 + 28);
  }
  memcpy(v46, *(const void **)(a2 + 8), *(void *)a2);
  if (dword_10008FA20)
  {
    int v49 = ne_log_obj();
    if (os_log_type_enabled(v49, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v66) = 0;
      _os_log_impl((void *)&_mh_execute_header, v49, OS_LOG_TYPE_DEFAULT, "MODE_CFG packet to send\n", (uint8_t *)&v66, 2u);
    }
  }
  if (*(unsigned char *)(v43 + 19))
  {
    char v50 = sub_10002E41C(a1, *(void *)(v17 + 80), *(void *)(*(void *)(v15 + 1176) + 8), **(void **)(v15 + 1176));
    int v51 = *(void **)(v17 + 80);
    if (v51)
    {
      sub_10003FA78(v51);
      *(void *)(v17 + 80) = 0;
    }
    if (!v50)
    {
      if (dword_10008FA20)
      {
        BOOL v57 = ne_log_obj();
        if (os_log_type_enabled(v57, OS_LOG_TYPE_ERROR)) {
          sub_10005CBC4();
        }
      }
      goto LABEL_83;
    }
    *(void *)(v17 + 80) = v50;
  }
  if (a6 >= 1)
  {
    *(_DWORD *)(v17 + 72) = a6;
    if ((sub_1000246C0(v17) & 0x80000000) == 0)
    {
      uint64_t v25 = 0;
      goto LABEL_85;
    }
    if (dword_10008FA20)
    {
      ssize_t v56 = ne_log_obj();
      if (os_log_type_enabled(v56, OS_LOG_TYPE_ERROR)) {
        sub_100068570();
      }
    }
    goto LABEL_81;
  }
  if ((sub_100023E30(*(void *)(v17 + 256), *(size_t **)(v17 + 80)) & 0x80000000) == 0)
  {
    if (a7)
    {
      uint64_t v53 = *(void **)(v17 + 80);
      uint64_t v54 = *(void *)(v17 + 256);
      if (*(_DWORD *)(v54 + 100) && *v53 > 0x500uLL) {
        unint64_t v55 = 0;
      }
      else {
        unint64_t v55 = ((unint64_t)*(unsigned int *)(v54 + 96) >> 3) & 4;
      }
      int v60 = sub_100009070(*(void *)(a1 + 48), *(void *)(a1 + 56), (uint64_t)v53, a7, v55, (*(_DWORD *)(a1 + 96) >> 5) & 1);
      int v61 = dword_10008FA20;
      if (v60 != -1 || !dword_10008FA20) {
        goto LABEL_93;
      }
      long long v62 = ne_log_obj();
      if (os_log_type_enabled(v62, OS_LOG_TYPE_ERROR)) {
        sub_10005B794();
      }
    }
    int v61 = dword_10008FA20;
LABEL_93:
    if (v61)
    {
      long long v63 = ne_log_obj();
      if (os_log_type_enabled(v63, OS_LOG_TYPE_DEFAULT))
      {
        long long v64 = sub_10003E1DC(a3);
        int v66 = 136315138;
        long long v67 = v64;
        _os_log_impl((void *)&_mh_execute_header, v63, OS_LOG_TYPE_DEFAULT, "sendto mode config %s.\n", (uint8_t *)&v66, 0xCu);
      }
    }
    long long v65 = *(void **)(v17 + 80);
    if (v65)
    {
      sub_10003FA78(v65);
      uint64_t v25 = 0;
      *(void *)(v17 + 80) = 0;
    }
    else
    {
      uint64_t v25 = 0;
    }
    goto LABEL_84;
  }
  if (dword_10008FA20)
  {
    __int16 v58 = ne_log_obj();
    if (os_log_type_enabled(v58, OS_LOG_TYPE_ERROR)) {
      sub_10005AD0C();
    }
  }
LABEL_81:
  uint64_t v59 = *(void **)(v17 + 80);
  if (v59)
  {
    sub_10003FA78(v59);
    *(void *)(v17 + 80) = 0;
  }
LABEL_83:
  uint64_t v25 = 0xFFFFFFFFLL;
LABEL_84:
  sub_10004B62C((void *)v17);
LABEL_85:
  if (v38) {
    sub_10003FA78(v38);
  }
  return v25;
}

uint64_t sub_100044C04(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 24)
    && (uint64_t v2 = *(void *)(a1 + 48), *(unsigned char *)(v2 + 1) == 2)
    && (int v3 = *(void **)(qword_10008F848 + 64)) != 0)
  {
    uint64_t v4 = 0;
    int v5 = *(_DWORD *)(v2 + 4);
    size_t v6 = 72;
    do
    {
      unsigned int v7 = v3 + 6;
      while (1)
      {
        unsigned int v7 = (void *)*v7;
        if (!v7) {
          break;
        }
        if (*((_DWORD *)v7 + 4) == v5)
        {
          uint64_t v4 = (size_t *)v7[7];
          if (v4) {
            v6 += *v4;
          }
          break;
        }
      }
      int v3 = (void *)*v3;
    }
    while (v3);
  }
  else
  {
    uint64_t v4 = 0;
    size_t v6 = 72;
  }
  uint64_t v8 = sub_10003F940(v6);
  if (v8)
  {
    int v9 = v8;
    uint64_t v10 = v8[1];
    *(_WORD *)(v10 + 2) = bswap32(v6) >> 16;
    *(unsigned char *)(v10 + 4) = 1;
    uint64_t v11 = 0;
    *(_WORD *)(v10 + 6) = bswap32(sub_100006078()) >> 16;
    unsigned int v12 = (_WORD *)(v10 + 8);
    do
    {
      if (v11 == 10 && v4)
      {
        _WORD *v12 = 1792;
        size_t v14 = *v4;
        int v13 = (const void *)v4[1];
        v12[1] = bswap32(*v4) >> 16;
        uint64_t v15 = v12 + 2;
        memcpy(v12 + 2, v13, v14);
        unsigned int v12 = (_WORD *)((char *)v15 + *v4);
      }
      else
      {
        *(_DWORD *)unsigned int v12 = bswap32((unsigned __int16)word_10006E878[v11]) >> 16;
        v12 += 2;
      }
      v11 += 2;
    }
    while (v11 != 32);
    if (dword_10008FA20)
    {
      size_t v16 = ne_log_obj();
      if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)uint8_t buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "Sending MODE_CFG REQUEST\n", buf, 2u);
      }
    }
    uint64_t v17 = sub_1000445EC(a1, (uint64_t)v9, 14, 1, 1, *(_DWORD *)(*(void *)(a1 + 64) + 200), 0);
    sub_10003FA78(v9);
    if (dword_10008FA20)
    {
      size_t v18 = ne_log_obj();
      if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
      {
        v21[0] = 0;
        _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "IPSec Network Configuration requested.\n", (uint8_t *)v21, 2u);
      }
    }
  }
  else
  {
    if (dword_10008FA20)
    {
      uint64_t v19 = ne_log_obj();
      if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR)) {
        sub_10005BA50();
      }
    }
    return 0xFFFFFFFFLL;
  }
  return v17;
}

void *sub_100044E5C(uint64_t a1, unsigned __int16 *a2)
{
  if ((*a2 & 0x80) != 0) {
    size_t v3 = 4;
  }
  else {
    size_t v3 = (bswap32(a2[1]) >> 16) + 4;
  }
  uint64_t v4 = sub_10003F940(v3);
  int v5 = v4;
  if (v4)
  {
    memcpy((void *)v4[1], a2, (bswap32(a2[1]) >> 16) + 4);
  }
  else if (dword_10008FA20)
  {
    size_t v6 = ne_log_obj();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR)) {
      sub_10005BA50();
    }
  }
  return v5;
}

void *sub_100044EFC(uint64_t a1, _WORD *a2, unsigned int a3)
{
  int v5 = sub_10003F940(4uLL);
  size_t v6 = v5;
  if (v5)
  {
    unsigned int v7 = (_WORD *)v5[1];
    _WORD *v7 = *a2 | 0x80;
    v7[1] = bswap32(a3) >> 16;
  }
  else if (dword_10008FA20)
  {
    uint64_t v8 = ne_log_obj();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR)) {
      sub_10005BA50();
    }
  }
  return v6;
}

void *sub_100044F8C(uint64_t a1, _WORD *a2, const void *a3, size_t a4)
{
  unsigned int v7 = sub_10003F940(a4 + 4);
  uint64_t v8 = v7;
  if (v7)
  {
    int v9 = (_WORD *)v7[1];
    _WORD *v9 = *a2;
    v9[1] = bswap32(a4) >> 16;
    memcpy(v9 + 2, a3, a4);
  }
  else if (dword_10008FA20)
  {
    uint64_t v10 = ne_log_obj();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR)) {
      sub_10005BA50();
    }
  }
  return v8;
}

void sub_10004502C(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 408);
  if (v1)
  {
    if ((*(unsigned char *)v1 & 4) != 0)
    {
      sub_1000450D4(a1, *(unsigned int *)(v1 + 4));
      uint64_t v1 = *(void *)(a1 + 408);
    }
    size_t v3 = *(void **)(v1 + 1176);
    if (v3)
    {
      sub_10002DA30(v3);
      *(void *)(*(void *)(a1 + 408) + 1176) = 0;
      uint64_t v1 = *(void *)(a1 + 408);
    }
    uint64_t v4 = *(void **)(v1 + 1112);
    if (v4)
    {
      sub_100046350(v4, (_DWORD *)(v1 + 1120));
      uint64_t v1 = *(void *)(a1 + 408);
    }
    int v5 = *(void **)(v1 + 1128);
    if (v5)
    {
      sub_100046350(v5, (_DWORD *)(v1 + 1136));
      uint64_t v1 = *(void *)(a1 + 408);
    }
    sub_100047BB4(v1 + 1144);
    size_t v6 = *(void ***)(a1 + 408);
    if (v6[149])
    {
      sub_10003FA78(v6[149]);
      size_t v6 = *(void ***)(a1 + 408);
    }
    free(v6);
    *(void *)(a1 + 408) = 0;
  }
}

uint64_t sub_1000450D4(uint64_t a1, uint64_t a2)
{
  if (!qword_10008FE68)
  {
    if (dword_10008FA20)
    {
      size_t v6 = ne_log_obj();
      if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR)) {
        sub_1000685A4();
      }
    }
    return 0xFFFFFFFFLL;
  }
  if (!*(unsigned char *)(qword_10008FE68 + a2))
  {
    if (dword_10008FA20)
    {
      unsigned int v7 = ne_log_obj();
      if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR)) {
        sub_1000685D8(a2, v7, v8, v9, v10, v11, v12, v13);
      }
    }
    return 0xFFFFFFFFLL;
  }
  *(unsigned char *)(qword_10008FE68 + a2) = 0;
  **(_DWORD **)(a1 + 408) &= 4u;
  if (dword_10008FA20)
  {
    size_t v3 = ne_log_obj();
    BOOL v4 = os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT);
    uint64_t result = 0;
    if (!v4) {
      return result;
    }
    v14[0] = 67109120;
    v14[1] = a2;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Released port %d\n", (uint8_t *)v14, 8u);
  }
  return 0;
}

void *sub_100045224()
{
  uint64_t v0 = malloc_type_malloc(0x4B0uLL, 0x1030040F12D1F44uLL);
  uint64_t v1 = v0;
  if (v0)
  {
    bzero(v0, 0x4B0uLL);
  }
  else if (dword_10008FA20)
  {
    uint64_t v2 = ne_log_obj();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR)) {
      sub_100068644();
    }
  }
  return v1;
}

uint64_t sub_1000452A4(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 408);
  if ((*(unsigned char *)v1 & 4) != 0) {
    return *(unsigned int *)(v1 + 4);
  }
  if (!qword_10008FE68)
  {
    if (dword_10008FA20)
    {
      size_t v6 = ne_log_obj();
      if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR)) {
        sub_1000685A4();
      }
    }
    return 0xFFFFFFFFLL;
  }
  if (!qword_10008FE90) {
    goto LABEL_25;
  }
  unint64_t v3 = 0;
  unint64_t v4 = 0;
  while (*(unsigned char *)(qword_10008FE68 + v3))
  {
    unint64_t v3 = (v4 + 1);
    unint64_t v4 = v3;
    unint64_t v5 = v3;
    if (qword_10008FE90 <= v3) {
      goto LABEL_13;
    }
  }
  unint64_t v5 = v4;
LABEL_13:
  if (qword_10008FE90 == v3)
  {
LABEL_25:
    if (dword_10008FA20)
    {
      unsigned int v7 = ne_log_obj();
      if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR)) {
        sub_100068678();
      }
    }
    return 0xFFFFFFFFLL;
  }
  *(unsigned char *)(qword_10008FE68 + v3) = 1;
  if (dword_10008FA20)
  {
    uint64_t v9 = ne_log_obj();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      v11[0] = 67109120;
      v11[1] = v5;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "Using port %d\n", (uint8_t *)v11, 8u);
    }
  }
  uint64_t v10 = *(_DWORD **)(a1 + 408);
  *v10 |= 4u;
  v10[1] = v5;
  return v5;
}

size_t sub_10004543C(size_t result, int a2, uint64_t a3, int a4)
{
  unint64_t v4 = (unsigned char *)result;
  if (a4 == 1) {
    uint64_t v5 = 14;
  }
  else {
    uint64_t v5 = 4;
  }
  if (a2 >= 1)
  {
    int v8 = a2;
    int v9 = 0;
    memset(v12, 0, 14);
    do
    {
      uint64_t result = __memcpy_chk();
      if (!v12[0]) {
        break;
      }
      inet_ntop(2, v12, &v4[v9], 0x28u);
      uint64_t result = strlen(&v4[v9]);
      int v10 = v9 + result;
      if (a4 == 1)
      {
        v4[v10] = 47;
        uint64_t v11 = v10 + 1;
        inet_ntop(2, &v12[1], &v4[v11], 0x28u);
        uint64_t result = strlen(&v4[v11]);
        int v10 = v11 + result;
      }
      a3 += v5;
      v4[v10] = 32;
      int v9 = v10 + 1;
      --v8;
    }
    while (v8);
    if (v9 >= 1) {
      v4 += (v9 - 1);
    }
  }
  *unint64_t v4 = 0;
  return result;
}

uint64_t sub_100045560(int a1)
{
  if (qword_10008FE90 == a1) {
    return 0;
  }
  size_t v3 = a1;
  if (dword_10008FA20)
  {
    unint64_t v4 = ne_log_obj();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      int v10 = 134218240;
      uint64_t v11 = qword_10008FE90;
      __int16 v12 = 1024;
      int v13 = a1;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Resize address pool from %zu to %d\n", (uint8_t *)&v10, 0x12u);
    }
  }
  if (qword_10008FE68)
  {
    int v5 = qword_10008FE90;
    if (qword_10008FE90 > v3)
    {
      while (--v5 >= a1)
      {
        if (*(unsigned char *)(qword_10008FE68 + v5))
        {
          size_t v3 = v5;
          if (dword_10008FA20)
          {
            size_t v6 = ne_log_obj();
            if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR)) {
              sub_10006876C(a1, v5, v6);
            }
          }
          goto LABEL_14;
        }
      }
    }
  }
  int v5 = a1;
LABEL_14:
  unsigned int v7 = (char *)malloc_type_realloc((void *)qword_10008FE68, v3, 0x119301F2uLL);
  if (v7)
  {
    uint64_t v8 = (uint64_t)v7;
    if (v3 > qword_10008FE90) {
      bzero(&v7[qword_10008FE90], v3 - qword_10008FE90);
    }
    uint64_t result = 0;
    qword_10008FE68 = v8;
    qword_10008FE90 = v3;
  }
  else
  {
    if (dword_10008FA20)
    {
      int v9 = ne_log_obj();
      if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR)) {
        sub_1000686AC(v5, v9);
      }
    }
    return 0xFFFFFFFFLL;
  }
  return result;
}

uint64_t sub_10004572C(int a1)
{
  unk_10008FE54 = 0u;
  xmmword_10008FE38 = 0u;
  unk_10008FE48 = 0u;
  if (a1 != 1 && qword_10008FE68) {
    free((void *)qword_10008FE68);
  }
  qword_10008FE90 = 0;
  qword_10008FE68 = 0;
  *(void *)&dword_10008FE70 = 0;
  if (a1 != 1)
  {
    uint64_t v2 = (void *)qword_10008FE78;
    if (qword_10008FE78)
    {
      if (dword_10008FE80 >= 1)
      {
        uint64_t v3 = 0;
        do
          free(*(void **)(qword_10008FE78 + 8 * v3++));
        while (v3 < dword_10008FE80);
        uint64_t v2 = (void *)qword_10008FE78;
      }
      free(v2);
    }
  }
  qword_10008FE78 = 0;
  *(void *)&dword_10008FE80 = 0;
  dword_10008FE88 = 0;
  dword_10008FE98 = 1;
  __strlcpy_chk();
  __strlcpy_chk();
  if (a1 != 1 && qword_1000906A0) {
    sub_100046350((void *)qword_1000906A0, &dword_1000906A8);
  }
  dword_1000906BC = 0;
  dword_1000906C0 = 0;
  qword_1000906A0 = 0;
  *(void *)&dword_1000906A8 = 0;
  if (a1 != 1 && qword_1000906B0) {
    free((void *)qword_1000906B0);
  }
  qword_1000906B0 = 0;
  dword_1000906B8 = 0;
  return 0;
}

void *sub_100045874(_WORD *a1, _DWORD *a2)
{
  unint64_t v4 = sub_10003F940(8uLL);
  int v5 = v4;
  if (v4)
  {
    uint64_t v6 = v4[1];
    *(_WORD *)uint64_t v6 = *a1;
    *(_WORD *)(v6 + 2) = 1024;
    *(_DWORD *)(v6 + 4) = *a2;
  }
  else if (dword_10008FA20)
  {
    unsigned int v7 = ne_log_obj();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR)) {
      sub_10005BA50();
    }
  }
  return v5;
}

size_t *sub_100045904(_WORD *a1, int *a2, int a3)
{
  uint64_t v6 = sub_10003F940(0);
  if (!v6)
  {
    if (dword_10008FA20)
    {
      int v13 = ne_log_obj();
      if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR)) {
        sub_10005BA50();
      }
    }
    return 0;
  }
  unsigned int v7 = v6;
  if (a3 >= 1)
  {
    uint64_t v8 = a3;
    while (1)
    {
      int v9 = sub_10003F940(8uLL);
      if (!v9) {
        break;
      }
      int v10 = v9;
      uint64_t v11 = v9[1];
      *(_WORD *)uint64_t v11 = *a1;
      *(_WORD *)(v11 + 2) = 1024;
      int v12 = *a2++;
      *(_DWORD *)(v11 + 4) = v12;
      unsigned int v7 = sub_1000444FC(v7, (uint64_t)v9);
      sub_10003FA78(v10);
      if (!--v8) {
        return v7;
      }
    }
    if (dword_10008FA20)
    {
      size_t v14 = ne_log_obj();
      if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
      {
        sub_10005BA50();
        if (!v7) {
          return v7;
        }
        goto LABEL_13;
      }
    }
    if (v7)
    {
LABEL_13:
      sub_10003FA78(v7);
      return 0;
    }
  }
  return v7;
}

void *sub_100045A38()
{
  uint64_t v0 = __chkstk_darwin();
  if ((**(unsigned char **)(v0 + 408) & 2) != 0)
  {
    unint64_t v4 = v1;
    unsigned int v5 = bswap32((unsigned __int16)*v1);
    int v6 = HIWORD(v5);
    if ((v5 & 0x80000000) != 0)
    {
      if (dword_10008FA20)
      {
        int v12 = HIWORD(v5) & 0x7FFF;
        int v13 = ne_log_obj();
        if (os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG)) {
          sub_100068A50(v12, (uint64_t)v4, v13);
        }
        if (dword_10008FA20)
        {
          size_t v14 = ne_log_obj();
          if (os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG)) {
            sub_1000689D4(v12);
          }
        }
      }
    }
    else
    {
      int v7 = v0;
      switch(v6)
      {
        case 28672:
          int v8 = open(byte_10009029D, 0, 0);
          if (v8 == -1)
          {
            if (dword_10008FA20)
            {
              int v23 = ne_log_obj();
              if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR)) {
                sub_1000688C4(v23);
              }
            }
          }
          else
          {
            int v9 = v8;
            int v10 = read(v8, __s, 0x10000uLL);
            if (v10 != -1)
            {
              close(v9);
              __s[v10] = 0;
              return sub_1000445A4(v7, v4, __s);
            }
            if (dword_10008FA20)
            {
              uint64_t v11 = ne_log_obj();
              if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR)) {
                sub_10006894C(v11);
              }
            }
            close(v9);
          }
          break;
        case 28673:
          unsigned int v15 = dword_1000906C0;
          goto LABEL_37;
        case 28674:
          return sub_1000445A4(v0, v1, byte_10008FE9C);
        case 28675:
          size_t v16 = (const void *)qword_1000906B0;
          size_t v17 = dword_1000906B8;
          return sub_100044F8C(v0, v1, v16, v17);
        case 28676:
          int v18 = dword_1000906AC;
          int v19 = 28676;
          goto LABEL_32;
        case 28678:
          int v18 = dword_1000906AC;
          int v19 = 28678;
LABEL_32:
          if (v18 != v19) {
            return 0;
          }
          unsigned int v21 = (uint64_t *)qword_1000906A0;
          int v22 = dword_1000906A8;
          return sub_100045EB4(v4, v21, v22);
        case 28679:
          unsigned int v15 = dword_1000906BC;
LABEL_37:
          return sub_100044EFC(v0, v1, v15);
        case 28682:
          return sub_100044E5C(v0, v1);
        default:
          if (dword_10008FA20)
          {
            int v20 = ne_log_obj();
            if (os_log_type_enabled(v20, OS_LOG_TYPE_DEBUG)) {
              sub_100068848(v6);
            }
          }
          return 0;
      }
    }
  }
  else if (dword_10008FA20)
  {
    uint64_t v2 = ne_log_obj();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR)) {
      sub_100068804(v2);
    }
  }
  return 0;
}

void *sub_100045EB4(_WORD *a1, uint64_t *a2, int a3)
{
  uint64_t v6 = 14 * a3;
  int v7 = sub_10003F940(v6 + 4);
  int v8 = v7;
  if (v7)
  {
    int v9 = (_WORD *)v7[1];
    _WORD *v9 = *a1;
    v9[1] = bswap32(v6) >> 16;
    if (a3 >= 1)
    {
      int v10 = v9 + 2;
      uint64_t v11 = a3;
      do
      {
        uint64_t v12 = *a2;
        *(void *)((char *)v10 + 6) = *(uint64_t *)((char *)a2 + 6);
        void *v10 = v12;
        inet_ntop(2, a2, v21, 0x28u);
        inet_ntop(2, (char *)a2 + 4, v20, 0x28u);
        if (dword_10008FA20)
        {
          int v13 = ne_log_obj();
          if (os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)uint8_t buf = 136315394;
            size_t v17 = v21;
            __int16 v18 = 2080;
            int v19 = v20;
            _os_log_debug_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEBUG, "splitnet: %s/%s\n", buf, 0x16u);
          }
        }
        a2 = (uint64_t *)a2[2];
        int v10 = (void *)((char *)v10 + 14);
        --v11;
      }
      while (v11);
    }
  }
  else if (dword_10008FA20)
  {
    size_t v14 = ne_log_obj();
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR)) {
      sub_100068AF8(v14);
    }
  }
  return v8;
}

void sub_100046070(uint64_t a1, _WORD *a2)
{
  uint64_t v2 = (uint64_t *)(a2 + 2);
  unsigned int v3 = bswap32(*a2 & 0xFF7F) >> 16;
  unsigned int v5 = a2 + 1;
  unsigned int v6 = __rev16((unsigned __int16)a2[1]);
  switch(v3)
  {
    case 0x7000u:
    case 0x7001u:
    case 0x7003u:
    case 0x7005u:
    case 0x7008u:
    case 0x7009u:
    case 0x700Au:
      if (*(_DWORD *)(a1 + 24)) {
        BOOL v7 = 1;
      }
      else {
        BOOL v7 = dword_10008FA20 == 0;
      }
      if (!v7) {
        goto LABEL_6;
      }
      break;
    case 0x7004u:
      int v9 = *(int **)(a1 + 408);
      int v10 = *v9;
      if ((*v9 & 0x2000) == 0)
      {
        if (a2[1] && v6 >= 0xE)
        {
          uint64_t v11 = (18725 * (v6 >> 1)) >> 17;
          do
          {
            sub_1000462B8((uint64_t *)(*(void *)(a1 + 408) + 1112), v2, (_DWORD *)(*(void *)(a1 + 408) + 1120));
            uint64_t v2 = (uint64_t *)((char *)v2 + 14);
            --v11;
          }
          while (v11);
          int v9 = *(int **)(a1 + 408);
          int v10 = *v9;
        }
        int v12 = v10 | 0x2000;
        goto LABEL_24;
      }
      break;
    case 0x7006u:
      int v9 = *(int **)(a1 + 408);
      int v13 = *v9;
      if ((*v9 & 0x4000) == 0)
      {
        if (a2[1] && v6 >= 0xE)
        {
          uint64_t v14 = (18725 * (v6 >> 1)) >> 17;
          do
          {
            sub_1000462B8((uint64_t *)(*(void *)(a1 + 408) + 1128), v2, (_DWORD *)(*(void *)(a1 + 408) + 1136));
            uint64_t v2 = (uint64_t *)((char *)v2 + 14);
            --v14;
          }
          while (v14);
          int v9 = *(int **)(a1 + 408);
          int v13 = *v9;
        }
        int v12 = v13 | 0x4000;
LABEL_24:
        int *v9 = v12;
      }
      break;
    case 0x7007u:
      *(_DWORD *)(*(void *)(a1 + 408) + 1140) = v6;
      if (dword_10008FA20)
      {
        unsigned int v15 = ne_log_obj();
        if (os_log_type_enabled(v15, OS_LOG_TYPE_DEBUG)) {
          sub_100068B3C(v5, v15);
        }
      }
      break;
    default:
      if (dword_10008FA20)
      {
LABEL_6:
        int v8 = ne_log_obj();
        if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
        {
          int v16 = 136315138;
          size_t v17 = sub_10003E254(v3);
          _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "Ignored attribute %s\n", (uint8_t *)&v16, 0xCu);
        }
      }
      break;
  }
}

uint64_t sub_1000462B8(uint64_t *a1, uint64_t *a2, _DWORD *a3)
{
  unsigned int v6 = malloc_type_malloc(0x18uLL, 0x10200403A35BBDDuLL);
  if (!v6) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v7 = *a2;
  *(void *)((char *)v6 + 6) = *(uint64_t *)((char *)a2 + 6);
  *unsigned int v6 = v7;
  void v6[2] = 0;
  uint64_t v8 = *a1;
  if (*a1)
  {
    do
    {
      uint64_t v9 = v8;
      uint64_t v8 = *(void *)(v8 + 16);
    }
    while (v8);
    a1 = (uint64_t *)(v9 + 16);
  }
  uint64_t v10 = 0;
  *a1 = (uint64_t)v6;
  ++*a3;
  return v10;
}

void *sub_100046350(void *result, _DWORD *a2)
{
  *a2 = 0;
  if (result)
  {
    do
    {
      uint64_t v2 = (void *)result[2];
      free(result);
      uint64_t result = v2;
    }
    while (v2);
  }
  return result;
}

unsigned char *sub_100046384(void *a1)
{
  uint64_t v1 = a1;
  int v2 = 0;
  if (a1)
  {
    unsigned int v3 = a1;
    do
    {
      inet_ntop(2, v3, __s, 0x28u);
      inet_ntop(2, (char *)v3 + 4, v10, 0x28u);
      int v4 = strlen(__s);
      v2 += v4 + strlen(v10) + 2;
      unsigned int v3 = (void *)v3[2];
    }
    while (v3);
  }
  unsigned int v5 = malloc_type_malloc(v2, 0x1470EAEAuLL);
  unsigned int v6 = v5;
  if (v5)
  {
    *unsigned int v5 = 0;
    if (v1)
    {
      if (v2 >= 1)
      {
        for (int i = 0; i < v2; i += v8)
        {
          inet_ntop(2, v1, __s, 0x28u);
          inet_ntop(2, (char *)v1 + 4, v10, 0x28u);
          int v8 = snprintf(&v6[i], v2 - i, "%s/%s ", __s, v10);
          if (v8 < 0) {
            break;
          }
          uint64_t v1 = (void *)v1[2];
          if (!v1) {
            break;
          }
        }
      }
    }
  }
  return v6;
}

void sub_1000464E4(uint64_t a1)
{
  if ((*(unsigned char *)(a1 + 17) & 0x20) != 0)
  {
    unsigned int v3 = (_DWORD *)(*(void *)(a1 + 408) + 1144);
    if (*v3)
    {
      if (dword_10008FA20)
      {
        int v4 = ne_log_obj();
        if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR)) {
          sub_100068C28((uint64_t)v3, v4, v5, v6, v7, v8, v9, v10);
        }
      }
    }
    else
    {
      if (dword_10008FA20)
      {
        uint64_t v11 = ne_log_obj();
        if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)int v16 = 0;
          _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "Sending Xauth request\n", v16, 2u);
        }
      }
      int v12 = sub_10003F940(0x14uLL);
      if (v12)
      {
        int v13 = v12;
        uint64_t v14 = v12[1];
        *(void *)uint64_t v14 = 0;
        *(void *)(v14 + 8) = 0;
        *(_DWORD *)(v14 + 16) = 0;
        *(_WORD *)(v14 + 2) = 5120;
        *(unsigned char *)(v14 + 4) = 1;
        *(_WORD *)(v14 + 6) = bswap32(sub_100006078()) >> 16;
        *(void *)(v14 + 8) = 0x8940000088C0;
        *(_DWORD *)(v14 + 16) = 35392;
        sub_1000445EC(a1, (uint64_t)v13, 14, 1, 1, 0, 0);
        sub_10003FA78(v13);
        *unsigned int v3 = 1;
      }
      else if (dword_10008FA20)
      {
        unsigned int v15 = ne_log_obj();
        if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR)) {
          sub_100068BF4();
        }
      }
    }
  }
  else if (dword_10008FA20)
  {
    uint64_t v1 = ne_log_obj();
    if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR)) {
      sub_100068BC0();
    }
  }
}

uint64_t sub_100046680(uint64_t a1, _WORD *a2, unsigned int a3)
{
  uint64_t v3 = *(void *)(a1 + 408);
  if ((*(unsigned char *)v3 & 1) == 0)
  {
    if (dword_10008FA20)
    {
      int v4 = ne_log_obj();
      if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR)) {
        sub_100068C98();
      }
    }
    return 0xFFFFFFFFLL;
  }
  if (*(_DWORD *)(v3 + 1144) != 1)
  {
    if (dword_10008FA20)
    {
      uint64_t v10 = ne_log_obj();
      if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR)) {
        sub_100068E24(v3 + 1144, v10, v11, v12, v13, v14, v15, v16);
      }
    }
    return 0xFFFFFFFFLL;
  }
  unsigned int v8 = bswap32(*a2 & 0xFF7F) >> 16;
  switch(v8)
  {
    case 0x408Au:
      __int16 v18 = (void **)(v3 + 1168);
LABEL_19:
      size_t v19 = bswap32((unsigned __int16)a2[1]) >> 16;
      int v20 = malloc_type_realloc(*v18, v19 + 1, 0xD8D5CB64uLL);
      NSObject *v18 = v20;
      if (!v20)
      {
        if (dword_10008FA20)
        {
          int v22 = ne_log_obj();
          if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR)) {
            sub_100068DF0();
          }
        }
        return 0xFFFFFFFFLL;
      }
      memcpy(v20, a2 + 2, v19);
      *((unsigned char *)*v18 + v19) = 0;
      break;
    case 0x4089u:
      __int16 v18 = (void **)(v3 + 1160);
      goto LABEL_19;
    case 0x4088u:
      if (a2[1])
      {
        if (dword_10008FA20)
        {
          uint64_t v9 = ne_log_obj();
          if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
          {
            int v40 = 67109120;
            int v41 = 34880;
            _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "Unexpected authentication type %d\n", (uint8_t *)&v40, 8u);
          }
        }
        return 0xFFFFFFFFLL;
      }
      *(_DWORD *)(v3 + 1152) = 0;
      break;
    default:
      if (dword_10008FA20)
      {
        unsigned int v21 = ne_log_obj();
        if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
        {
          int v40 = 67109120;
          int v41 = v8;
          _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "ignored Xauth attribute %d\n", (uint8_t *)&v40, 8u);
        }
      }
      break;
  }
  int v23 = *(const char **)(v3 + 1160);
  if (!v23) {
    return 0;
  }
  size_t v24 = *(const char **)(v3 + 1168);
  if (!v24) {
    return 0;
  }
  __strlcpy_chk();
  uint64_t v25 = sub_1000452A4(a1);
  if (v25 == -1)
  {
    if (dword_10008FA20)
    {
      uint64_t v28 = ne_log_obj();
      if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR)) {
        sub_100068CCC();
      }
    }
    int v27 = -1;
    goto LABEL_50;
  }
  if (dword_10008FE70)
  {
    if (dword_10008FA20)
    {
      unsigned int v26 = ne_log_obj();
      if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR)) {
        sub_100068DBC();
      }
    }
    int v27 = -1;
  }
  else
  {
    int v27 = sub_100046AE8(v23, v24);
    if (!v27 && dword_10008FE80) {
      int v27 = sub_100046B44(a1, (char **)qword_10008FE78, dword_10008FE80);
    }
  }
  uint64_t v29 = (int)sub_10003F3C0(*(unsigned __int8 **)(a1 + 48), v27);
  uint64_t v30 = v29 - time(0);
  if (v30 < 1)
  {
LABEL_50:
    uint64_t v35 = a1;
    uint64_t v36 = v25;
    unsigned int v37 = a3;
    int v38 = v27;
    return sub_100046D88(v35, v36, v37, v38);
  }
  uint64_t v31 = sub_10003CE24(*(const sockaddr **)(a1 + 48));
  if (dword_10008FA20)
  {
    uint64_t v32 = (uint64_t)v31;
    uint64_t v33 = ne_log_obj();
    if (os_log_type_enabled(v33, OS_LOG_TYPE_ERROR)) {
      sub_100068D34(v32, v30, v33);
    }
  }
  uint64_t v34 = malloc_type_malloc(0x1CuLL, 0x100004027586B93uLL);
  if (v34)
  {
    *(_OWORD *)uint64_t v34 = *(_OWORD *)a1;
    v34[4] = v25;
    v34[5] = a3;
    v34[6] = -1;
    sub_10003AA24(v30, (uint64_t)sub_100046F70, (uint64_t)v34);
    return 0;
  }
  if (dword_10008FA20)
  {
    int v39 = ne_log_obj();
    if (os_log_type_enabled(v39, OS_LOG_TYPE_ERROR)) {
      sub_100068D00();
    }
  }
  uint64_t v35 = a1;
  uint64_t v36 = v25;
  unsigned int v37 = a3;
  int v38 = -1;
  return sub_100046D88(v35, v36, v37, v38);
}

uint64_t sub_100046AE8(const char *a1, const char *a2)
{
  uint64_t v3 = getpwnam(a1);
  if (!v3) {
    return 0xFFFFFFFFLL;
  }
  if (!v3->pw_uid) {
    return 0xFFFFFFFFLL;
  }
  pw_passwd = v3->pw_passwd;
  uint64_t v5 = crypt(a2, pw_passwd);
  if (!v5) {
    return 0xFFFFFFFFLL;
  }
  if (!strcmp(v5, pw_passwd)) {
    return 0;
  }
  return 0xFFFFFFFFLL;
}

uint64_t sub_100046B44(uint64_t a1, char **a2, int a3)
{
  if (!*(void *)(a1 + 408))
  {
    if (dword_10008FA20)
    {
      uint64_t v10 = ne_log_obj();
      if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR)) {
        sub_100068E94();
      }
    }
    return 0xFFFFFFFFLL;
  }
  if (a3 < 1) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v5 = a3;
  while (1)
  {
    uint64_t v6 = *(const char **)(*(void *)(a1 + 408) + 1160);
    if (!v6)
    {
      if (dword_10008FA20)
      {
        uint64_t v11 = ne_log_obj();
        if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR)) {
          sub_100068EC8();
        }
      }
      return 0xFFFFFFFFLL;
    }
    if (!dword_10008FE74) {
      break;
    }
    if (dword_10008FA20)
    {
      uint64_t v7 = ne_log_obj();
      if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR)) {
        sub_100068EFC(&v16, v17, v7);
      }
      goto LABEL_10;
    }
LABEL_13:
    ++a2;
    if (!--v5) {
      return 0xFFFFFFFFLL;
    }
  }
  if (sub_1000470D8(v6, *a2))
  {
LABEL_10:
    if (dword_10008FA20)
    {
      unsigned int v8 = ne_log_obj();
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v9 = *a2;
        *(_DWORD *)uint8_t buf = 136315394;
        size_t v19 = v6;
        __int16 v20 = 2080;
        unsigned int v21 = v9;
        _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "user \"%s\" is not a member of group \"%s\"\n", buf, 0x16u);
      }
    }
    goto LABEL_13;
  }
  if (dword_10008FA20)
  {
    uint64_t v13 = ne_log_obj();
    BOOL v14 = os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT);
    uint64_t result = 0;
    if (!v14) {
      return result;
    }
    uint64_t v15 = *a2;
    *(_DWORD *)uint8_t buf = 136315394;
    size_t v19 = v6;
    __int16 v20 = 2080;
    unsigned int v21 = v15;
    _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "user \"%s\" is a member of group \"%s\"\n", buf, 0x16u);
  }
  return 0;
}

uint64_t sub_100046D88(uint64_t a1, uint64_t a2, unsigned int a3, int a4)
{
  uint64_t v4 = *(void *)(a1 + 408);
  uint64_t v5 = *(void *)(v4 + 1160);
  if ((*(unsigned char *)(a1 + 432) & 2) != 0)
  {
    if (dword_10008FA20)
    {
      uint64_t v9 = ne_log_obj();
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
      {
        int v12 = 136315138;
        uint64_t v13 = v5;
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "dropped login for user \"%s\"\n", (uint8_t *)&v12, 0xCu);
      }
    }
    return 0xFFFFFFFFLL;
  }
  if (a4)
  {
    if (a2 != -1) {
      sub_1000450D4(a1, a2);
    }
    if (dword_10008FA20)
    {
      unsigned int v8 = ne_log_obj();
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
      {
        int v12 = 136315138;
        uint64_t v13 = v5;
        _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "login failed for user \"%s\"\n", (uint8_t *)&v12, 0xCu);
      }
    }
    sub_100046FE8(a1, 0, a3);
    *(_DWORD *)(v4 + 1144) = 0;
    if ((*(unsigned char *)(a1 + 17) & 0x20) != 0) {
      sub_10001A098(a1);
    }
    sub_100022854(a1);
    return 0xFFFFFFFFLL;
  }
  *(_DWORD *)(v4 + 1144) = 2;
  if (dword_10008FA20)
  {
    uint64_t v11 = ne_log_obj();
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      int v12 = 136315138;
      uint64_t v13 = v5;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "login succeeded for user \"%s\"\n", (uint8_t *)&v12, 0xCu);
    }
  }
  sub_100046FE8(a1, 1u, a3);
  return 0;
}

void sub_100046F70(uint64_t a1)
{
  uint64_t v2 = sub_1000072D0(0, (void *)a1);
  if (v2)
  {
    sub_100046D88(v2, *(unsigned int *)(a1 + 16), *(_DWORD *)(a1 + 20), *(_DWORD *)(a1 + 24));
  }
  else if (dword_10008FA20)
  {
    uint64_t v3 = ne_log_obj();
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR)) {
      sub_100068F3C();
    }
  }
  free((void *)a1);
}

void sub_100046FE8(uint64_t a1, unsigned int a2, unsigned int a3)
{
  uint64_t v6 = sub_10003F940(0xCuLL);
  if (v6)
  {
    uint64_t v7 = v6;
    uint64_t v8 = v6[1];
    *(void *)uint64_t v8 = 0;
    *(_DWORD *)(v8 + 8) = 0;
    *(_WORD *)(v8 + 2) = 3072;
    *(unsigned char *)(v8 + 4) = 3;
    *(_WORD *)(v8 + 6) = bswap32(a3) >> 16;
    *(_WORD *)(v8 + 8) = -28736;
    *(_WORD *)(v8 + 10) = bswap32(a2) >> 16;
    sub_1000445EC(a1, (uint64_t)v6, 14, 1, 1, 0, 0);
    sub_10003FA78(v7);
  }
  else if (dword_10008FA20)
  {
    uint64_t v9 = ne_log_obj();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR)) {
      sub_100068BF4();
    }
  }
}

uint64_t sub_1000470D8(const char *a1, char *a2)
{
  uint64_t v4 = getgrnam(a2);
  if (v4)
  {
    for (int i = (const char **)v4->gr_mem; ; ++i)
    {
      uint64_t v6 = *i;
      if (!*i) {
        break;
      }
      if (!strcmp(v6, a1))
      {
        if (dword_10008FA20)
        {
          uint64_t v7 = ne_log_obj();
          BOOL v8 = os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT);
          uint64_t result = 0;
          if (!v8) {
            return result;
          }
          *(_WORD *)uint64_t v11 = 0;
          _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "membership validated\n", v11, 2u);
        }
        return 0;
      }
    }
  }
  else if (dword_10008FA20)
  {
    uint64_t v10 = ne_log_obj();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR)) {
      sub_100068F70((uint64_t)a2, v10);
    }
  }
  return 0xFFFFFFFFLL;
}

uint64_t sub_1000471C0(void *a1)
{
  int v1 = *(_DWORD *)(a1[9] + 48);
  if (*(void *)(a1[8] + 272)) {
    BOOL v2 = v1 == 65001;
  }
  else {
    BOOL v2 = 0;
  }
  if (v2) {
    return 0;
  }
  BOOL v3 = (v1 - 65002) > 8 || ((1 << (v1 + 22)) & 0x151) == 0;
  if (v3 && v1 != 64222) {
    return 0;
  }
  uint64_t v5 = a1[51];
  if (*(unsigned char *)v5)
  {
    if (*(_DWORD *)(v5 + 1144) == 2) {
      return 0;
    }
    if (dword_10008FA20)
    {
      BOOL v8 = ne_log_obj();
      if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR)) {
        sub_10006901C();
      }
    }
  }
  else if (dword_10008FA20)
  {
    uint64_t v6 = ne_log_obj();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR)) {
      sub_100068FE8();
    }
  }
  return 0xFFFFFFFFLL;
}

void *sub_1000472A8(uint64_t a1, unsigned __int16 *a2)
{
  if ((**(unsigned char **)(a1 + 408) & 1) == 0)
  {
    if (dword_10008FA20)
    {
      BOOL v2 = ne_log_obj();
      if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR)) {
        sub_100069050();
      }
    }
    return 0;
  }
  int v6 = *a2;
  __int16 v7 = v6 & 0xFF7F;
  unsigned int v8 = bswap32(v6 & 0xFFFFFF7F) >> 16;
  switch(v8)
  {
    case 0x4088u:
      if ((v6 & 0x80) != 0)
      {
        uint64_t v27 = (uint64_t)(a2 + 1);
        if (!a2[1])
        {
          uint64_t v20 = 0;
          char v36 = 0;
          uint64_t v15 = 0;
          int v16 = 0;
          goto LABEL_45;
        }
        if (dword_10008FA20)
        {
          uint64_t v28 = ne_log_obj();
          if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR)) {
            sub_1000690B8(v27, v28, v29, v30, v31, v32, v33, v34);
          }
        }
      }
      else if (dword_10008FA20)
      {
        __int16 v18 = ne_log_obj();
        if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR)) {
          sub_100069084();
        }
      }
      return 0;
    case 0x4089u:
      uint64_t v19 = *(void *)(*(void *)(a1 + 64) + 272);
      if (v19 && *(void *)v19)
      {
        uint64_t v15 = 0;
        int v16 = 0;
        uint64_t v20 = **(void **)v19 - 1;
        *(_DWORD *)(v19 + 16) |= 1u;
        goto LABEL_44;
      }
      if (dword_10008FA20)
      {
        unsigned int v26 = ne_log_obj();
        if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR)) {
          sub_100069130();
        }
      }
      return 0;
    case 0x408Au:
    case 0x408Bu:
      uint64_t v10 = a1 + 64;
      uint64_t v11 = *(void ***)(*(void *)(a1 + 64) + 272);
      if (!v11) {
        return 0;
      }
      int v12 = *v11;
      if (!v12) {
        return 0;
      }
      uint64_t v13 = sub_10003F940(*v12 + 3);
      if (v13)
      {
        BOOL v14 = v13;
        *(_DWORD *)v13[1] = 0;
        memcpy((void *)(v13[1] + 4), *(const void **)(**(void **)(*(void *)v10 + 272) + 8), ***(void ***)(*(void *)v10 + 272) - 1);
        uint64_t v15 = *(size_t **)(*(void *)(*(void *)v10 + 272) + 8);
        if (v15)
        {
          int v16 = 0;
LABEL_43:
          sub_10003FA78(v14);
          *(_DWORD *)(*(void *)(*(void *)v10 + 272) + 16) |= 2u;
          uint64_t v20 = *v15 - 1;
LABEL_44:
          char v36 = 1;
LABEL_45:
          int v38 = sub_10003F940(v20 + 4);
          BOOL v3 = v38;
          if (!v38)
          {
            if (dword_10008FA20)
            {
              int v41 = ne_log_obj();
              if (os_log_type_enabled(v41, OS_LOG_TYPE_ERROR)) {
                sub_10005BA50();
              }
            }
            goto LABEL_56;
          }
          uint64_t v39 = v38[1];
          if ((v36 & 1) == 0)
          {
            *(_DWORD *)uint64_t v39 = (unsigned __int16)__rev16(v8 | 0x8000);
            goto LABEL_56;
          }
          *(_WORD *)uint64_t v39 = v7;
          *(_WORD *)(v39 + 2) = bswap32(v20) >> 16;
          if (v8 - 16522 >= 2)
          {
            if (v8 != 16521) {
              goto LABEL_56;
            }
            int v40 = *(const void **)(**(void **)(*(void *)(a1 + 64) + 272) + 8);
          }
          else
          {
            int v40 = (const void *)v15[1];
          }
          memcpy((void *)(v39 + 4), v40, v20);
LABEL_56:
          if (v16) {
            sub_10003FA78(v15);
          }
          return v3;
        }
        unsigned int v37 = sub_100027F70(v14);
        if (v37)
        {
          uint64_t v15 = v37;
          int v16 = 1;
          goto LABEL_43;
        }
        if (dword_10008FA20)
        {
          uint64_t v43 = ne_log_obj();
          if (os_log_type_enabled(v43, OS_LOG_TYPE_ERROR)) {
            sub_100069164(a1 + 64, v43);
          }
        }
        uint64_t v25 = v14;
LABEL_65:
        sub_10003FA78(v25);
      }
      else
      {
        if (!dword_10008FA20) {
          return 0;
        }
        uint64_t v35 = ne_log_obj();
        if (!os_log_type_enabled(v35, OS_LOG_TYPE_ERROR)) {
          return 0;
        }
LABEL_39:
        sub_10005BA50();
      }
      return 0;
    case 0x408Cu:
      if ((v6 & 0x80) != 0 || !a2[1]) {
        return 0;
      }
      unsigned int v21 = sub_10003F940(__rev16(a2[1]));
      if (v21)
      {
        int v22 = v21;
        memcpy((void *)v21[1], a2 + 2, *v21);
        if (dword_10008FA20)
        {
          int v23 = ne_log_obj();
          if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
          {
            size_t v24 = sub_10002911C((char *)v22[1], *v22);
            int v44 = 136315138;
            size_t v45 = v24;
            _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "XAUTH Message: '%s'.\n", (uint8_t *)&v44, 0xCu);
          }
        }
        uint64_t v25 = v22;
        goto LABEL_65;
      }
      if (!dword_10008FA20) {
        return 0;
      }
      uint64_t v42 = ne_log_obj();
      if (!os_log_type_enabled(v42, OS_LOG_TYPE_ERROR)) {
        return 0;
      }
      goto LABEL_39;
    default:
      if (dword_10008FA20)
      {
        size_t v17 = ne_log_obj();
        if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
        {
          int v44 = 136315138;
          size_t v45 = sub_10003E254(v8);
          _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "Ignored attribute %s\n", (uint8_t *)&v44, 0xCu);
        }
      }
      return 0;
  }
}

void *sub_100047794(uint64_t a1, unsigned __int16 *a2)
{
  uint64_t v2 = *(void *)(a1 + 408);
  if ((*(unsigned char *)v2 & 1) == 0)
  {
    if (dword_10008FA20)
    {
      BOOL v3 = ne_log_obj();
      if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR)) {
        sub_1000691EC();
      }
    }
    return 0;
  }
  int v5 = *a2;
  unsigned int v6 = bswap32(v5 & 0xFFFFFF7F) >> 16;
  if (v6 == 16524)
  {
    if ((v5 & 0x80) == 0 && a2[1])
    {
      uint64_t v11 = sub_10003F940(__rev16(a2[1]));
      if (!v11)
      {
        if (dword_10008FA20)
        {
          size_t v24 = ne_log_obj();
          if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR)) {
            sub_10005BA50();
          }
        }
        return 0;
      }
      int v12 = v11;
      memcpy((void *)v11[1], a2 + 2, *v11);
      if (dword_10008FA20)
      {
        uint64_t v13 = ne_log_obj();
        if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
        {
          BOOL v14 = sub_10002911C((char *)v12[1], *v12);
          int v26 = 136315138;
          uint64_t v27 = v14;
          _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "XAUTH Message: '%s'.\n", (uint8_t *)&v26, 0xCu);
        }
      }
      sub_10003FA78(v12);
    }
    goto LABEL_23;
  }
  if (v6 != 16527)
  {
LABEL_23:
    if (dword_10008FA20)
    {
      uint64_t v15 = ne_log_obj();
      if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
      {
        int v16 = sub_10003E254(v6);
        int v26 = 136315138;
        uint64_t v27 = v16;
        _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "Ignored attribute %s\n", (uint8_t *)&v26, 0xCu);
      }
    }
    return 0;
  }
  int v8 = *(_DWORD *)(*(void *)(a1 + 72) + 48);
  if (*(void *)(*(void *)(a1 + 64) + 272)) {
    BOOL v9 = v8 == 65001;
  }
  else {
    BOOL v9 = 0;
  }
  if (!v9)
  {
    switch(v8)
    {
      case 65002:
        if (*(unsigned char *)(a1 + 432)) {
          goto LABEL_31;
        }
        if (dword_10008FA20)
        {
          uint64_t v10 = ne_log_obj();
          if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR)) {
            sub_100069288();
          }
        }
        return 0;
      case 65003:
      case 65004:
      case 65006:
      case 65008:
        goto LABEL_52;
      case 65005:
      case 65007:
      case 65009:
        goto LABEL_31;
      default:
        if (v8 == 64221 || v8 == 65500) {
          goto LABEL_31;
        }
LABEL_52:
        if (dword_10008FA20)
        {
          uint64_t v25 = ne_log_obj();
          if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR)) {
            sub_100069254();
          }
        }
        break;
    }
    return 0;
  }
LABEL_31:
  if (a2[1] == 256)
  {
    if (*(unsigned char *)(a1 + 432)) {
      *(_DWORD *)(v2 + 1144) = 2;
    }
    if (!dword_10008FA20) {
      goto LABEL_44;
    }
    __int16 v18 = ne_log_obj();
    if (!os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_44;
    }
    LOWORD(v26) = 0;
    uint64_t v19 = "IPSec Extended Authentication Passed.\n";
  }
  else
  {
    if (dword_10008FA20)
    {
      uint64_t v20 = ne_log_obj();
      if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR)) {
        sub_100069220();
      }
    }
    int v21 = sub_100009F24(a1);
    sub_100049388(0x18u, 0, v21, 0, 0);
    **(_DWORD **)(a1 + 408) |= 0x800u;
    if (!dword_10008FA20) {
      goto LABEL_44;
    }
    __int16 v18 = ne_log_obj();
    if (!os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_44;
    }
    LOWORD(v26) = 0;
    uint64_t v19 = "IPSec Extended Authentication Failed.\n";
  }
  _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, v19, (uint8_t *)&v26, 2u);
LABEL_44:
  uint64_t result = sub_10003F940(4uLL);
  if (result)
  {
    *(_DWORD *)result[1] = 36800;
    return result;
  }
  if (dword_10008FA20)
  {
    int v23 = ne_log_obj();
    if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR)) {
      sub_10005BA50();
    }
  }
  return 0;
}

void sub_100047BB4(uint64_t a1)
{
  int v2 = *(_DWORD *)(a1 + 8);
  if ((v2 - 1) >= 3)
  {
    if (v2)
    {
      if (dword_10008FA20)
      {
        BOOL v3 = ne_log_obj();
        if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
        {
          int v8 = *(_DWORD *)(a1 + 8);
          int v9 = 67109120;
          int v10 = v8;
          int v5 = "Unexpected authtype %d\n";
          goto LABEL_15;
        }
      }
    }
    else
    {
      unsigned int v6 = *(void **)(a1 + 16);
      if (v6) {
        free(v6);
      }
      __int16 v7 = *(void **)(a1 + 24);
      if (v7)
      {
        free(v7);
      }
    }
  }
  else if (dword_10008FA20)
  {
    BOOL v3 = ne_log_obj();
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      int v4 = *(_DWORD *)(a1 + 8);
      int v9 = 67109120;
      int v10 = v4;
      int v5 = "Unsupported authtype %d\n";
LABEL_15:
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, v5, (uint8_t *)&v9, 8u);
    }
  }
}

uint64_t sub_100047D10(uint64_t a1)
{
  int v2 = *(void **)a1;
  if (*(void *)a1)
  {
    if (*v2)
    {
      sub_10003FA78((void *)*v2);
      **(void **)a1 = 0;
      int v2 = *(void **)a1;
    }
    BOOL v3 = (void *)v2[1];
    if (v3)
    {
      sub_10003FA78(v3);
      *(void *)(*(void *)a1 + 8) = 0;
      int v2 = *(void **)a1;
    }
    uint64_t result = 0;
    goto LABEL_9;
  }
  int v5 = malloc_type_malloc(0x18uLL, 0x1020040EDCEB4C7uLL);
  *(void *)a1 = v5;
  if (v5)
  {
    unsigned int v6 = v5;
    uint64_t result = 0;
    *unsigned int v6 = 0;
    *(void *)(*(void *)a1 + 8) = 0;
    int v2 = *(void **)a1;
LABEL_9:
    *((_DWORD *)v2 + 4) = 0;
    return result;
  }
  if (dword_10008FA20)
  {
    __int16 v7 = ne_log_obj();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR)) {
      sub_1000692BC();
    }
  }
  return 0xFFFFFFFFLL;
}

void sub_100047DE4(void ***a1)
{
  int v2 = *a1;
  if (v2)
  {
    if (*v2)
    {
      sub_10003FA78(*v2);
      int v2 = *a1;
    }
    if (v2[1])
    {
      sub_10003FA78(v2[1]);
      int v2 = *a1;
    }
    free(v2);
    *a1 = 0;
  }
}

void sub_100047E3C()
{
  long long v23 = 0u;
  long long v24 = 0u;
  long long v21 = 0u;
  long long v22 = 0u;
  long long v19 = 0u;
  long long v20 = 0u;
  sockaddr v17 = (sockaddr)0;
  long long v18 = 0u;
  socklen_t v16 = 128;
  dword_10008FA20 = 1;
  uint64_t v0 = malloc_type_calloc(1uLL, 0x38uLL, 0x10B0040FCE79EF2uLL);
  if (v0)
  {
    int v1 = v0;
    *((void *)v0 + 6) = 0;
    unsigned int v2 = accept(*(_DWORD *)(qword_10008F848 + 28), &v17, &v16);
    *((_DWORD *)v1 + 4) = v2;
    if ((v2 & 0x80000000) != 0)
    {
      if (dword_10008FA20)
      {
        int v10 = ne_log_obj();
        if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR)) {
          sub_100069370();
        }
      }
    }
    else
    {
      uint64_t v3 = *(void *)(qword_10008F848 + 64);
      *(void *)int v1 = v3;
      uint64_t v4 = qword_10008F848;
      if (v3) {
        *(void *)(*(void *)(qword_10008F848 + 64) + 8) = v1;
      }
      *(void *)(v4 + 64) = v1;
      *((void *)v1 + 1) = v4 + 64;
      int v5 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_read, v2, 0, (dispatch_queue_t)&_dispatch_main_q);
      *((void *)v1 + 3) = v5;
      if (v5)
      {
        handler[0] = _NSConcreteStackBlock;
        handler[1] = 0x40000000;
        handler[2] = sub_1000480D4;
        handler[3] = &unk_10008ABF0;
        void handler[4] = v1;
        dispatch_source_set_event_handler(v5, handler);
        int v6 = *((_DWORD *)v1 + 4);
        __int16 v7 = *((void *)v1 + 3);
        v13[0] = _NSConcreteStackBlock;
        v13[1] = 0x40000000;
        _DWORD v13[2] = sub_100048EBC;
        v13[3] = &unk_10008AC10;
        int v14 = v6;
        v13[4] = v7;
        dispatch_source_set_cancel_handler(v7, v13);
        dispatch_resume(*((dispatch_object_t *)v1 + 3));
        if (dword_10008FA20)
        {
          int v8 = ne_log_obj();
          if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)int v12 = 0;
            _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "accepted connection on vpn control socket.\n", v12, 2u);
          }
        }
        sub_10003B3DC();
        return;
      }
      if (dword_10008FA20)
      {
        uint64_t v11 = ne_log_obj();
        if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR)) {
          sub_1000693F0();
        }
      }
    }
    free(v1);
    return;
  }
  if (dword_10008FA20)
  {
    int v9 = ne_log_obj();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR)) {
      sub_1000692F0();
    }
  }
}

void sub_1000480D4(uint64_t a1)
{
}

void sub_1000480DC(uint64_t a1)
{
  uint64_t v80 = 0;
  uint64_t v81 = 0;
  if (*(void *)(a1 + 40))
  {
LABEL_2:
    while (1)
    {
      unint64_t v2 = recv(*(_DWORD *)(a1 + 16), (void *)(*(void *)(a1 + 40) + *(unsigned int *)(a1 + 32)), *(unsigned int *)(a1 + 36), 0);
      if ((v2 & 0x8000000000000000) == 0) {
        break;
      }
      if (*__error() != 4)
      {
        if (dword_10008FA20)
        {
          __int16 v7 = ne_log_obj();
          if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR)) {
            goto LABEL_6;
          }
        }
        return;
      }
    }
    unint64_t v10 = v2;
    if (v2)
    {
      unint64_t v11 = *(unsigned int *)(a1 + 36);
      unint64_t v12 = (*(_DWORD *)(a1 + 32) + v2);
      *(_DWORD *)(a1 + 32) = v12;
      if (v2 < v11)
      {
        if (dword_10008FA20)
        {
          uint64_t v13 = ne_log_obj();
          BOOL v14 = os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT);
          LODWORD(v11) = *(_DWORD *)(a1 + 36);
          if (v14)
          {
            *(_DWORD *)uint8_t buf = 134218240;
            *(void *)__int16 v85 = v10;
            *(_WORD *)&v85[8] = 1024;
            *(_DWORD *)&v85[10] = v11;
            _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "received partial vpn_control command - len=%ld - expected %u\n", buf, 0x12u);
            LODWORD(v11) = *(_DWORD *)(a1 + 36);
          }
        }
        *(_DWORD *)(a1 + 36) = v11 - v10;
        return;
      }
      long long v18 = *(unsigned __int16 **)(a1 + 40);
      LODWORD(v19) = 0;
      switch(bswap32(*v18) >> 16)
      {
        case 1u:
          if (v12 <= 0x17)
          {
            if (dword_10008FA20)
            {
              long long v20 = ne_log_obj();
              if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR)) {
                sub_10006964C();
              }
            }
            goto LABEL_197;
          }
          uint64_t v35 = v18 + 10;
          if ((unint64_t)(bswap32(v18[10]) >> 16) + 24 > v12)
          {
            if (dword_10008FA20)
            {
              char v36 = ne_log_obj();
              if (os_log_type_enabled(v36, OS_LOG_TYPE_ERROR)) {
                sub_1000696B4();
              }
            }
            goto LABEL_197;
          }
          if (dword_10008FA20)
          {
            long long v67 = ne_log_obj();
            if (os_log_type_enabled(v67, OS_LOG_TYPE_DEFAULT))
            {
              *(_WORD *)uint8_t buf = 0;
              _os_log_impl((void *)&_mh_execute_header, v67, OS_LOG_TYPE_DEFAULT, "received bind command on vpn control socket.\n", buf, 2u);
            }
          }
          long long v68 = malloc_type_calloc(1uLL, 0x40uLL, 0x10A0040D5FA6E92uLL);
          if (!v68)
          {
            if (dword_10008FA20)
            {
              long long v77 = ne_log_obj();
              if (os_log_type_enabled(v77, OS_LOG_TYPE_ERROR)) {
                sub_1000692F0();
              }
            }
            goto LABEL_197;
          }
          long long v69 = v68;
          if (*v35)
          {
            long long v70 = sub_10003F940(__rev16((unsigned __int16)*v35));
            v69[7] = v70;
            if (!v70)
            {
              if (dword_10008FA20)
              {
                long long v78 = ne_log_obj();
                if (os_log_type_enabled(v78, OS_LOG_TYPE_ERROR)) {
                  sub_1000692F0();
                }
              }
              free(v69);
              goto LABEL_197;
            }
            memcpy((void *)v70[1], v18 + 12, bswap32(v18[10]) >> 16);
          }
          *((_DWORD *)v69 + 4) = *((_DWORD *)v18 + 4);
          long long v71 = (void *)(a1 + 48);
          uint64_t v72 = *(void *)(a1 + 48);
          *long long v69 = v72;
          if (v72) {
            *(void *)(v72 + 8) = v69;
          }
          LODWORD(v19) = 0;
          void *v71 = v69;
          v69[1] = v71;
          *(_DWORD *)(qword_10008F848 + 80) |= 0x10u;
          goto LABEL_198;
        case 2u:
          if (v12 <= 0x13)
          {
            if (dword_10008FA20)
            {
              long long v24 = ne_log_obj();
              if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR)) {
                sub_100069734();
              }
            }
            goto LABEL_197;
          }
          if (dword_10008FA20)
          {
            unsigned int v37 = ne_log_obj();
            if (os_log_type_enabled(v37, OS_LOG_TYPE_DEFAULT))
            {
              *(_WORD *)uint8_t buf = 0;
              _os_log_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_DEFAULT, "received unbind command on vpn control socket.\n", buf, 2u);
            }
          }
          int v38 = *(_DWORD **)(a1 + 48);
          if (!v38) {
            goto LABEL_192;
          }
          break;
        case 3u:
          if (v12 <= 0x1B)
          {
            if (dword_10008FA20)
            {
              uint64_t v25 = ne_log_obj();
              if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR)) {
                sub_10006979C();
              }
            }
            goto LABEL_197;
          }
          if (dword_10008FA20)
          {
            uint64_t v43 = ne_log_obj();
            if (os_log_type_enabled(v43, OS_LOG_TYPE_DEFAULT))
            {
              unsigned int v44 = bswap32(*((_DWORD *)v18 + 5));
              *(_DWORD *)uint8_t buf = 67109120;
              *(_DWORD *)__int16 v85 = v44;
              _os_log_impl((void *)&_mh_execute_header, v43, OS_LOG_TYPE_DEFAULT, "received redirect command on vpn control socket - address = %x.\n", buf, 8u);
            }
          }
          size_t v45 = *(void **)(qword_10008F848 + 72);
          while (v45)
          {
            pid_t v46 = v45;
            size_t v45 = (void *)*v45;
            if (*((_DWORD *)v46 + 4) == *((_DWORD *)v18 + 4))
            {
              int v47 = *((_DWORD *)v18 + 5);
              if (!v47)
              {
                if (v45) {
                  v45[1] = v46[1];
                }
                *(void *)v46[1] = v45;
                free(v46);
                goto LABEL_192;
              }
              LODWORD(v19) = 0;
              *((_DWORD *)v46 + 5) = v47;
              *((_WORD *)v46 + 12) = bswap32(v18[12]) >> 16;
              goto LABEL_198;
            }
          }
          long long v63 = malloc_type_malloc(0x20uLL, 0x10A00401099AC32uLL);
          if (!v63)
          {
            if (dword_10008FA20)
            {
              long long v76 = ne_log_obj();
              if (os_log_type_enabled(v76, OS_LOG_TYPE_ERROR)) {
                sub_10006980C();
              }
            }
            goto LABEL_197;
          }
          long long v64 = v63;
          v63[2] = *((void *)v18 + 2);
          *((_WORD *)v63 + 12) = bswap32(v18[12]) >> 16;
          uint64_t v65 = *(void *)(qword_10008F848 + 72);
          void *v63 = v65;
          uint64_t v66 = qword_10008F848;
          if (v65) {
            *(void *)(*(void *)(qword_10008F848 + 72) + 8) = v63;
          }
          LODWORD(v19) = 0;
          *(void *)(v66 + 72) = v64;
          v64[1] = v66 + 72;
          goto LABEL_198;
        case 4u:
          goto LABEL_198;
        case 0x11u:
          if (v12 <= 0x13)
          {
            if (dword_10008FA20)
            {
              uint64_t v27 = ne_log_obj();
              if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR)) {
                sub_100069990();
              }
            }
            goto LABEL_197;
          }
          if (dword_10008FE2C)
          {
            sub_10003B50C();
            dword_10008FE2C = 0;
          }
          if (dword_10008FA20)
          {
            char v48 = ne_log_obj();
            if (os_log_type_enabled(v48, OS_LOG_TYPE_DEFAULT))
            {
              *(_WORD *)uint8_t buf = 0;
              _os_log_impl((void *)&_mh_execute_header, v48, OS_LOG_TYPE_DEFAULT, "received connect command on vpn control socket.\n", buf, 2u);
            }
          }
          uint64_t v19 = a1 + 48;
          while (1)
          {
            uint64_t v19 = *(void *)v19;
            if (!v19) {
              goto LABEL_198;
            }
            if (*((_DWORD *)v18 + 4) == *(_DWORD *)(v19 + 16))
            {
              int v49 = 1;
              goto LABEL_154;
            }
          }
        case 0x12u:
          if (v12 <= 0x13)
          {
            if (dword_10008FA20)
            {
              uint64_t v28 = ne_log_obj();
              if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR)) {
                sub_1000699F8();
              }
            }
            goto LABEL_197;
          }
          if (dword_10008FA20)
          {
            char v50 = ne_log_obj();
            if (os_log_type_enabled(v50, OS_LOG_TYPE_DEFAULT))
            {
              *(_WORD *)uint8_t buf = 0;
              _os_log_impl((void *)&_mh_execute_header, v50, OS_LOG_TYPE_DEFAULT, "received disconnect command on vpn control socket.\n", buf, 2u);
            }
          }
          uint64_t v19 = a1 + 48;
          while (1)
          {
            uint64_t v19 = *(void *)v19;
            if (!v19) {
              goto LABEL_198;
            }
            if (*((_DWORD *)v18 + 4) == *(_DWORD *)(v19 + 16))
            {
              LODWORD(v19) = sub_10004A618(v19, (uint64_t)off_10008C4F0[0]);
              goto LABEL_198;
            }
          }
        case 0x13u:
          if (v12 <= 0x1F)
          {
            if (dword_10008FA20)
            {
              uint64_t v29 = ne_log_obj();
              if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR)) {
                sub_100069A60();
              }
            }
            goto LABEL_197;
          }
          if (dword_10008FA20)
          {
            int v51 = ne_log_obj();
            if (os_log_type_enabled(v51, OS_LOG_TYPE_DEFAULT))
            {
              *(_WORD *)uint8_t buf = 0;
              _os_log_impl((void *)&_mh_execute_header, v51, OS_LOG_TYPE_DEFAULT, "received start_ph2 command on vpn control socket.\n", buf, 2u);
            }
          }
          uint64_t v19 = a1 + 48;
          while (1)
          {
            uint64_t v19 = *(void *)v19;
            if (!v19) {
              goto LABEL_198;
            }
            if (*((_DWORD *)v18 + 4) == *(_DWORD *)(v19 + 16))
            {
              LODWORD(v19) = sub_10004A710(v19, (uint64_t)v18, v12);
              goto LABEL_198;
            }
          }
        case 0x14u:
          if (v12 <= 0x13)
          {
            if (dword_10008FA20)
            {
              uint64_t v30 = ne_log_obj();
              if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR)) {
                sub_100069840();
              }
            }
            goto LABEL_197;
          }
          if ((unint64_t)(bswap32(v18[7]) >> 16) + 16 > v12)
          {
            if (dword_10008FA20)
            {
              char v52 = ne_log_obj();
              if (os_log_type_enabled(v52, OS_LOG_TYPE_ERROR)) {
                sub_1000698A8();
              }
            }
            goto LABEL_197;
          }
          if (dword_10008FA20)
          {
            long long v73 = ne_log_obj();
            if (os_log_type_enabled(v73, OS_LOG_TYPE_DEFAULT))
            {
              *(_WORD *)uint8_t buf = 0;
              _os_log_impl((void *)&_mh_execute_header, v73, OS_LOG_TYPE_DEFAULT, "received xauth info command vpn control socket.\n", buf, 2u);
            }
          }
          uint64_t v74 = a1 + 48;
          do
          {
            uint64_t v74 = *(void *)v74;
            if (!v74) {
              goto LABEL_192;
            }
            int v75 = *((_DWORD *)v18 + 4);
          }
          while (v75 != *(_DWORD *)(v74 + 16));
          LODWORD(v19) = sub_10004B0A8(v75, v18 + 10, (bswap32(v18[7]) >> 16) - 4);
          goto LABEL_198;
        case 0x15u:
          if (v12 <= 0x13)
          {
            if (dword_10008FA20)
            {
              uint64_t v31 = ne_log_obj();
              if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR)) {
                sub_100069AC8();
              }
            }
            goto LABEL_197;
          }
          if (dword_10008FA20)
          {
            uint64_t v53 = ne_log_obj();
            if (os_log_type_enabled(v53, OS_LOG_TYPE_DEFAULT))
            {
              *(_WORD *)uint8_t buf = 0;
              _os_log_impl((void *)&_mh_execute_header, v53, OS_LOG_TYPE_DEFAULT, "received start_dpd command on vpn control socket.\n", buf, 2u);
            }
          }
          uint64_t v54 = a1 + 48;
          do
          {
            uint64_t v54 = *(void *)v54;
            if (!v54) {
              goto LABEL_192;
            }
            int v55 = *((_DWORD *)v18 + 4);
          }
          while (v55 != *(_DWORD *)(v54 + 16));
          uint64_t v92 = 0;
          long long v91 = 0u;
          long long v90 = 0u;
          long long v89 = 0u;
          long long v88 = 0u;
          long long v87 = 0u;
          long long v86 = 0u;
          *(_OWORD *)&v85[4] = 0u;
          *(_DWORD *)uint8_t buf = 528;
          *(_DWORD *)__int16 v85 = v55;
          LODWORD(v19) = sub_10000986C((unint64_t)buf);
          goto LABEL_198;
        case 0x16u:
          if (v12 <= 0x17)
          {
            if (dword_10008FA20)
            {
              uint64_t v32 = ne_log_obj();
              if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR)) {
                sub_100069B30();
              }
            }
            goto LABEL_197;
          }
          if (dword_10008C2C8 >= 5) {
            sub_100033908(5, *(void *)(a1 + 40), (bswap32(v18[7]) >> 16) + 16, "received assert command on vpn control socket.\n", v3, v4, v5, v6, v80);
          }
          *(void *)&v85[4] = 0;
          int v56 = *((_DWORD *)v18 + 4);
          int v57 = *((_DWORD *)v18 + 5);
          *(_DWORD *)uint8_t buf = 528;
          *(_DWORD *)__int16 v85 = v56;
          uint64_t v83 = 0;
          v82[0] = 528;
          v82[1] = v57;
          LODWORD(v19) = sub_10004B34C((uint64_t)buf, (uint64_t)v82);
          goto LABEL_198;
        case 0x17u:
          if (v12 <= 0x13)
          {
            if (dword_10008FA20)
            {
              uint64_t v33 = ne_log_obj();
              if (os_log_type_enabled(v33, OS_LOG_TYPE_ERROR)) {
                sub_100069B98();
              }
            }
            goto LABEL_197;
          }
          if (dword_10008FA20)
          {
            __int16 v58 = ne_log_obj();
            if (os_log_type_enabled(v58, OS_LOG_TYPE_DEFAULT))
            {
              *(_WORD *)uint8_t buf = 0;
              _os_log_impl((void *)&_mh_execute_header, v58, OS_LOG_TYPE_DEFAULT, "received reconnect command on vpn control socket.\n", buf, 2u);
            }
          }
          uint64_t v19 = a1 + 48;
          while (1)
          {
            uint64_t v19 = *(void *)v19;
            if (!v19) {
              break;
            }
            if (*((_DWORD *)v18 + 4) == *(_DWORD *)(v19 + 16))
            {
              int v49 = 3;
LABEL_154:
              LODWORD(v19) = sub_10004A29C(v19, v49);
              break;
            }
          }
LABEL_198:
          v18[7] = 0;
          v18[6] = bswap32(v19) >> 16;
          if (send(*(_DWORD *)(a1 + 16), v18, 0x10uLL, 0) < 0)
          {
            if (dword_10008FA20)
            {
              long long v79 = ne_log_obj();
              if (os_log_type_enabled(v79, OS_LOG_TYPE_ERROR)) {
                sub_100069548();
              }
            }
          }
          free(*(void **)(a1 + 40));
          *(void *)(a1 + 32) = 0;
          *(void *)(a1 + 40) = 0;
          return;
        case 0x18u:
          if (v12 <= 0x1F)
          {
            if (dword_10008FA20)
            {
              uint64_t v34 = ne_log_obj();
              if (os_log_type_enabled(v34, OS_LOG_TYPE_ERROR)) {
                sub_100069928();
              }
            }
            goto LABEL_197;
          }
          if (dword_10008FA20)
          {
            uint64_t v59 = ne_log_obj();
            if (os_log_type_enabled(v59, OS_LOG_TYPE_DEFAULT))
            {
              int v60 = *((_DWORD *)v18 + 4);
              *(_DWORD *)uint8_t buf = 67109120;
              *(_DWORD *)__int16 v85 = v60;
              _os_log_impl((void *)&_mh_execute_header, v59, OS_LOG_TYPE_DEFAULT, "received set v6 prefix of len %u command on vpn control socket, adding to all addresses.\n", buf, 8u);
            }
          }
          int v61 = *(uint64_t **)(a1 + 48);
          if (v61)
          {
            LODWORD(v19) = 0;
            do
            {
              long long v62 = (uint64_t *)*v61;
              *(_OWORD *)((char *)v61 + 20) = *((_OWORD *)v18 + 1);
              int v61 = v62;
            }
            while (v62);
          }
          else
          {
LABEL_192:
            LODWORD(v19) = 0;
          }
          goto LABEL_198;
        default:
          if (dword_10008FA20)
          {
            int v26 = ne_log_obj();
            if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR)) {
              sub_1000695C8(v18, v26);
            }
          }
LABEL_197:
          LODWORD(v19) = 0xFFFF;
          goto LABEL_198;
      }
      while (1)
      {
        uint64_t v39 = *(_DWORD **)v38;
        int v40 = *((_DWORD *)v18 + 4);
        if (v40 == -1) {
          break;
        }
        if (v40 == v38[4]) {
          goto LABEL_95;
        }
LABEL_100:
        LODWORD(v19) = 0;
        int v38 = v39;
        if (!v39) {
          goto LABEL_198;
        }
      }
      int v40 = v38[4];
LABEL_95:
      sub_10003A730(v40);
      uint64_t v41 = *(void *)v38;
      if (*(void *)v38) {
        *(void *)(v41 + 8) = *((void *)v38 + 1);
      }
      **((void **)v38 + 1) = v41;
      uint64_t v42 = (void *)*((void *)v38 + 7);
      if (v42) {
        sub_10003FA78(v42);
      }
      free(v38);
      goto LABEL_100;
    }
    if (dword_10008FA20)
    {
      socklen_t v16 = ne_log_obj();
      if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)uint8_t buf = 0;
        sockaddr v17 = "vpn_control socket closed by peer while reading packet\n";
LABEL_34:
        _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, v17, buf, 2u);
        goto LABEL_35;
      }
    }
    goto LABEL_35;
  }
  do
  {
    unint64_t v8 = recv(*(_DWORD *)(a1 + 16), &v80, 0x10uLL, 2);
    if ((v8 & 0x8000000000000000) == 0)
    {
      if (v8)
      {
        if (v8 > 0xF)
        {
          size_t v21 = (bswap32(HIWORD(v81)) >> 16) + 16;
          *(_DWORD *)(a1 + 32) = 0;
          *(_DWORD *)(a1 + 36) = v21;
          long long v22 = malloc_type_malloc(v21, 0x9525C829uLL);
          *(void *)(a1 + 40) = v22;
          if (v22) {
            goto LABEL_2;
          }
          if (dword_10008FA20)
          {
            long long v23 = ne_log_obj();
            if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR)) {
              sub_100069514();
            }
          }
        }
        else if (dword_10008FA20)
        {
          int v9 = ne_log_obj();
          if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR)) {
            sub_1000694A4();
          }
        }
        return;
      }
      if (dword_10008FA20)
      {
        socklen_t v16 = ne_log_obj();
        if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)uint8_t buf = 0;
          sockaddr v17 = "vpn_control socket closed by peer.\n";
          goto LABEL_34;
        }
      }
LABEL_35:
      sub_100048EF8(a1, (uint64_t)off_10008C4F8[0]);
      sub_100048F94((uint64_t *)a1);
      return;
    }
  }
  while (*__error() == 4);
  if (dword_10008FA20)
  {
    uint64_t v15 = ne_log_obj();
    if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR)) {
LABEL_6:
    }
      sub_100069424();
  }
}

void sub_100048EBC(uint64_t a1)
{
  close(*(_DWORD *)(a1 + 40));
  unint64_t v2 = *(NSObject **)(a1 + 32);

  dispatch_release(v2);
}

void *sub_100048EF8(uint64_t a1, uint64_t a2)
{
  if (dword_10008FA20)
  {
    uint64_t v4 = ne_log_obj();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)__int16 v7 = 0;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "received disconnect all command.\n", v7, 2u);
    }
  }
  uint64_t result = *(void **)(a1 + 48);
  if (result)
  {
    do
    {
      uint64_t v6 = (void *)*result;
      sub_10004A618((uint64_t)result, a2);
      uint64_t result = v6;
    }
    while (v6);
  }
  return result;
}

uint64_t sub_100048F94(uint64_t *a1)
{
  if (dword_10008FA20)
  {
    unint64_t v2 = ne_log_obj();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      v10[0] = 0;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "vpncontrol_close_comm.\n", (uint8_t *)v10, 2u);
    }
  }
  uint64_t v3 = *a1;
  if (*a1) {
    *(void *)(v3 + 8) = a1[1];
  }
  *(void *)a1[1] = v3;
  if (*((_DWORD *)a1 + 4) != -1)
  {
    dispatch_source_cancel((dispatch_source_t)a1[3]);
    *((_DWORD *)a1 + 4) = -1;
  }
  uint64_t v4 = (void *)a1[5];
  if (v4)
  {
    free(v4);
    a1[4] = 0;
    a1[5] = 0;
  }
  uint64_t v5 = (_DWORD *)a1[6];
  if (v5)
  {
    do
    {
      uint64_t v6 = *(_DWORD **)v5;
      sub_10003A730(v5[4]);
      uint64_t v7 = *(void *)v5;
      if (*(void *)v5) {
        *(void *)(v7 + 8) = *((void *)v5 + 1);
      }
      **((void **)v5 + 1) = v7;
      unint64_t v8 = (void *)*((void *)v5 + 7);
      if (v8) {
        sub_10003FA78(v8);
      }
      free(v5);
      uint64_t v5 = v6;
    }
    while (v6);
  }
  free(a1);
  uint64_t result = sub_10003B3DC();
  dword_10008FA20 = *(void *)(qword_10008F848 + 64) != 0;
  return result;
}

uint64_t sub_1000490C4(_OWORD *a1)
{
  for (int i = *(void **)(qword_10008F848 + 64); i; int i = (void *)*i)
  {
    unint64_t v2 = i + 6;
    while (1)
    {
      unint64_t v2 = (void *)*v2;
      if (!v2) {
        break;
      }
      if (*((_DWORD *)v2 + 5))
      {
        *a1 = *(_OWORD *)((char *)v2 + 20);
        return 1;
      }
    }
  }
  return 0;
}

uint64_t sub_100049110(uint64_t result, const void *a2, size_t a3)
{
  if (result)
  {
    uint64_t v5 = result;
    if (dword_10008FA20)
    {
      uint64_t v6 = ne_log_obj();
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)uint8_t buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "sending vpn_control xauth need info status\n", buf, 2u);
      }
    }
    uint64_t v7 = (__int16 *)malloc_type_malloc(a3 + 20, 0x2DD99451uLL);
    if (v7)
    {
      unint64_t v8 = v7;
      v7[1] = 0;
      int v9 = sub_100009F24(v5);
      if (v9)
      {
        int v10 = v9;
        v8[6] = 0;
        *((_DWORD *)v8 + 1) = 0;
        *((_DWORD *)v8 + 2) = 0;
        v8[7] = bswap32(a3 + 4) >> 16;
        __int16 v11 = sub_10004E7DC(v5) ? 641 : 385;
        *unint64_t v8 = v11;
        *((_DWORD *)v8 + 4) = sub_100009F24(v5);
        memcpy(v8 + 10, a2, a3);
        for (int i = *(uint64_t **)(qword_10008F848 + 64); i; int i = (uint64_t *)*i)
        {
          uint64_t v13 = i + 6;
          while (1)
          {
            uint64_t v13 = (uint64_t *)*v13;
            if (!v13) {
              break;
            }
            int v14 = *((_DWORD *)v13 + 4);
            if (v14 == -1 || v14 == v10)
            {
              if (dword_10008FA20)
              {
                socklen_t v16 = ne_log_obj();
                if (os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG))
                {
                  *(_DWORD *)uint8_t buf = 134217984;
                  size_t v20 = a3 + 20;
                  _os_log_debug_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEBUG, "vpn control writing %zu bytes\n", buf, 0xCu);
                }
              }
              if (send(*((_DWORD *)i + 4), v8, a3 + 20, 0) < 0 && dword_10008FA20)
              {
                sockaddr v17 = ne_log_obj();
                if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR)) {
                  sub_100069C34();
                }
              }
              break;
            }
          }
        }
      }
      free(v8);
      return 0;
    }
    else
    {
      if (dword_10008FA20)
      {
        long long v18 = ne_log_obj();
        if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR)) {
          sub_100069C00();
        }
      }
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

uint64_t sub_100049388(unsigned int a1, unsigned int a2, int a3, unsigned int a4, const void *a5)
{
  size_t v10 = a4;
  size_t v11 = a4 + 24;
  unint64_t v12 = (char *)malloc_type_malloc(v11, 0xFAE13350uLL);
  if (v12)
  {
    uint64_t v13 = v12;
    *(_WORD *)unint64_t v12 = 384;
    *(void *)(v12 + 2) = 0;
    *(_DWORD *)(v12 + 10) = 0;
    *((_WORD *)v12 + 7) = bswap32(a4 + 8) >> 16;
    *((_DWORD *)v12 + 4) = a3;
    *((_WORD *)v12 + 10) = __rev16(a1);
    *((_WORD *)v12 + 11) = __rev16(a2);
    if (a4) {
      memcpy(v12 + 24, a5, v10);
    }
    if (dword_10008FA20)
    {
      int v14 = ne_log_obj();
      if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR)) {
        sub_100069D08(a1, a2, v14);
      }
    }
    for (int i = *(uint64_t **)(qword_10008F848 + 64); i; int i = (uint64_t *)*i)
    {
      socklen_t v16 = i + 6;
      while (1)
      {
        socklen_t v16 = (uint64_t *)*v16;
        if (!v16) {
          break;
        }
        int v17 = *((_DWORD *)v16 + 4);
        if (v17 == -1 || v17 == a3)
        {
          ssize_t v19 = send(*((_DWORD *)i + 4), v13, v11, 0);
          if (v19 < 0)
          {
            if (dword_10008FA20)
            {
              long long v22 = ne_log_obj();
              if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR)) {
                sub_100069CB8();
              }
            }
          }
          else if (dword_10008FA20)
          {
            ssize_t v20 = v19;
            size_t v21 = ne_log_obj();
            if (os_log_type_enabled(v21, OS_LOG_TYPE_DEBUG))
            {
              *(_DWORD *)uint8_t buf = 134218240;
              ssize_t v26 = v20;
              __int16 v27 = 2048;
              size_t v28 = v11;
              _os_log_debug_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEBUG, "Sent %zd/%zu bytes\n", buf, 0x16u);
            }
          }
          break;
        }
      }
    }
    free(v13);
    return 0;
  }
  else
  {
    if (dword_10008FA20)
    {
      long long v24 = ne_log_obj();
      if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR)) {
        sub_100069C84();
      }
    }
    return 0xFFFFFFFFLL;
  }
}

const char *sub_1000495EC(int a1)
{
  if (a1 > 32800)
  {
    if (a1 > 33024)
    {
      if (a1 == 33025) {
        return "Need authentication info";
      }
      if (a1 == 33026) {
        return "Need re-authentication info";
      }
    }
    else
    {
      if (a1 == 32801) {
        return "Phase 2 started";
      }
      if (a1 == 32802) {
        return "Phase 2 established";
      }
    }
  }
  else if (a1 > 32785)
  {
    if (a1 == 32786) {
      return "Phase 1 started by peer";
    }
    if (a1 == 32787) {
      return "Phase 1 established";
    }
  }
  else
  {
    if (a1 == 32769) {
      return "IKE failed";
    }
    if (a1 == 32785) {
      return "Phase 1 started by us";
    }
  }
  return (const char *)&unk_100081F6D;
}

uint64_t sub_1000496DC(int a1, int a2, uint64_t a3, uint64_t a4)
{
  size_t v30 = 0;
  uint64_t v31 = 0;
  if (a1 || !a3 || (uint64_t v8 = *(void *)(a3 + 408)) == 0 || *(_DWORD *)(v8 + 1144) == 2)
  {
    size_t v30 = 20;
    int v9 = malloc_type_malloc(0x14uLL, 0x361CAED1uLL);
    uint64_t v31 = v9;
    v9[1] = 0;
    if (!a3)
    {
      int v14 = v9;
      int v15 = sub_10000A008(a4);
      if (v15)
      {
        int v11 = v15;
        if (a1) {
          unsigned int v16 = -32735;
        }
        else {
          unsigned int v16 = -32734;
        }
        unsigned int v13 = bswap32(v16) >> 16;
        goto LABEL_18;
      }
      if (dword_10008FA20)
      {
        uint64_t v29 = ne_log_obj();
        if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR)) {
          sub_100069DAC();
        }
      }
LABEL_50:
      uint64_t result = (uint64_t)v31;
      if (!v31) {
        return result;
      }
      free(v31);
      return 0;
    }
LABEL_6:
    int v10 = sub_100009F24(a3);
    if (v10)
    {
      int v11 = v10;
      if (a2) {
        unsigned int v12 = -32750;
      }
      else {
        unsigned int v12 = -32751;
      }
      if (!a1) {
        unsigned int v12 = -32749;
      }
      unsigned int v13 = bswap32(v12) >> 16;
      int v14 = v31;
LABEL_18:
      _WORD *v14 = v13;
      if (dword_10008FA20)
      {
        int v17 = ne_log_obj();
        BOOL v18 = os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT);
        int v14 = v31;
        if (v18)
        {
          ssize_t v19 = sub_1000495EC(bswap32(*(unsigned __int16 *)v31) >> 16);
          *(_DWORD *)uint8_t buf = 136315138;
          size_t v33 = (size_t)v19;
          _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, ">>>>> phase change status = %s\n", buf, 0xCu);
          int v14 = v31;
        }
      }
      v14[6] = 0;
      *((_DWORD *)v14 + 1) = 0;
      *((_DWORD *)v14 + 2) = 0;
      v14[7] = bswap32((unsigned __int16)v30 - 16) >> 16;
      *((_DWORD *)v14 + 4) = v11;
      for (int i = *(uint64_t **)(qword_10008F848 + 64); i; int i = (uint64_t *)*i)
      {
        size_t v21 = i + 6;
        while (1)
        {
          size_t v21 = (uint64_t *)*v21;
          if (!v21) {
            break;
          }
          int v22 = *((_DWORD *)v21 + 4);
          if (v22 == -1 || v22 == v11)
          {
            if (dword_10008FA20)
            {
              long long v24 = ne_log_obj();
              if (os_log_type_enabled(v24, OS_LOG_TYPE_DEBUG))
              {
                *(_DWORD *)uint8_t buf = 134217984;
                size_t v33 = v30;
                _os_log_debug_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEBUG, "vpn control writing %zu bytes\n", buf, 0xCu);
              }
            }
            if (send(*((_DWORD *)i + 4), v31, v30, 0) < 0 && dword_10008FA20)
            {
              uint64_t v25 = ne_log_obj();
              if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR)) {
                sub_100069DE0();
              }
            }
            break;
          }
        }
      }
      goto LABEL_50;
    }
    if (dword_10008FA20)
    {
      ssize_t v26 = ne_log_obj();
      if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR)) {
        sub_100069E30();
      }
    }
    goto LABEL_50;
  }
  if (sub_10004AEE0(a3, &v31, &v30) == 1) {
    return 0;
  }
  if (v31) {
    goto LABEL_6;
  }
  if (dword_10008FA20)
  {
    __int16 v27 = ne_log_obj();
    if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR)) {
      sub_100069C00();
    }
  }
  return 0xFFFFFFFFLL;
}

uint64_t sub_100049A44(int a1, uint64_t a2)
{
  if (!a2) {
    return 0;
  }
  uint64_t v3 = *(void *)(a2 + 440);
  if (!v3 || (*(unsigned char *)(v3 + 280) & 1) == 0) {
    return 0;
  }
  int v6 = sub_100009F24(a2);
  uint64_t result = sub_100049AC0(a1, v6);
  if (result) {
    return 0xFFFFFFFFLL;
  }
  *(unsigned char *)(*(void *)(a2 + 440) + 280) &= ~1u;
  return result;
}

uint64_t sub_100049AC0(int a1, int a2)
{
  v13[1] = 0x800000000000000;
  v13[0] = 897;
  int v14 = a2;
  int v15 = (unsigned __int16)a1;
  if (dword_10008FA20)
  {
    uint64_t v4 = ne_log_obj();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)uint8_t buf = 67109376;
      int v17 = a1;
      __int16 v18 = 1024;
      int v19 = a2;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "sending vpn_control status (peer response) message - code=%d  addr=%x.\n", buf, 0xEu);
    }
  }
  uint64_t v5 = *(uint64_t **)(qword_10008F848 + 64);
  if (!v5) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v6 = 0xFFFFFFFFLL;
  do
  {
    uint64_t v7 = v5 + 6;
    while (1)
    {
      uint64_t v7 = (uint64_t *)*v7;
      if (!v7) {
        break;
      }
      int v8 = *((_DWORD *)v7 + 4);
      if (v8 == -1 || v8 == a2)
      {
        ssize_t v10 = send(*((_DWORD *)v5 + 4), v13, 0x18uLL, 0);
        uint64_t result = 0;
        if ((v10 & 0x8000000000000000) == 0) {
          goto LABEL_18;
        }
        if (dword_10008FA20)
        {
          unsigned int v12 = ne_log_obj();
          if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR)) {
            sub_100069E64();
          }
        }
        break;
      }
    }
    uint64_t result = v6;
LABEL_18:
    uint64_t v5 = (uint64_t *)*v5;
    uint64_t v6 = result;
  }
  while (v5);
  return result;
}

uint64_t sub_100049C54(int a1, uint64_t a2)
{
  if (!a2) {
    return 0;
  }
  uint64_t v3 = *(void *)(a2 + 272);
  if (!v3 || (*(unsigned char *)(v3 + 280) & 1) == 0) {
    return 0;
  }
  int v6 = sub_10000A008(a2);
  uint64_t result = sub_100049AC0(a1, v6);
  if (result) {
    return 0xFFFFFFFFLL;
  }
  *(unsigned char *)(*(void *)(a2 + 272) + 280) &= ~1u;
  return result;
}

uint64_t sub_100049CD0()
{
  if (!off_10008C4E0)
  {
    uint64_t result = 0;
    *(_DWORD *)(qword_10008F848 + 28) = -1;
    return result;
  }
  size_t cnt = 0;
  *(void *)fds = 0;
  int v0 = launch_activate_socket("Listeners", (int **)fds, &cnt);
  if (v0)
  {
    if (dword_10008FA20)
    {
      int v1 = v0;
      unint64_t v2 = ne_log_obj();
      if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR)) {
        sub_10006A23C(v1);
      }
    }
  }
  else if (*(void *)fds)
  {
    if (cnt) {
      int v4 = **(_DWORD **)fds;
    }
    else {
      int v4 = 0;
    }
    free(*(void **)fds);
    *(_DWORD *)(qword_10008F848 + 28) = v4;
    if (v4) {
      goto LABEL_29;
    }
    goto LABEL_11;
  }
  *(_DWORD *)(qword_10008F848 + 28) = 0;
LABEL_11:
  unk_10008F272 = 0u;
  xmmword_10008F258 = 0u;
  unk_10008F268 = 0u;
  xmmword_10008F238 = 0u;
  unk_10008F248 = 0u;
  xmmword_10008F218 = 0u;
  unk_10008F228 = 0u;
  BYTE1(xmmword_10008F218) = 1;
  snprintf((char *)&xmmword_10008F218 + 2, 0x68uLL, "%s", off_10008C4E0);
  int v5 = socket(1, 1, 0);
  *(_DWORD *)(qword_10008F848 + 28) = v5;
  if (v5 == -1)
  {
    if (dword_10008FA20)
    {
      int v8 = ne_log_obj();
      if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR)) {
        sub_100069EB4();
      }
    }
    return 0xFFFFFFFFLL;
  }
  if (fcntl(v5, 4, 4) == -1)
  {
    if (dword_10008FA20)
    {
      int v6 = ne_log_obj();
      if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR)) {
        sub_10006A208();
      }
    }
  }
  unlink((const char *)&xmmword_10008F218 + 2);
  if (bind(*(_DWORD *)(qword_10008F848 + 28), (const sockaddr *)&xmmword_10008F218, 0x6Au))
  {
    if (dword_10008FA20)
    {
      uint64_t v7 = ne_log_obj();
      if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR)) {
        sub_10006A174(v7);
      }
    }
LABEL_42:
    close(*(_DWORD *)(qword_10008F848 + 28));
    return 0xFFFFFFFFLL;
  }
  if (chown((const char *)&xmmword_10008F218 + 2, dword_1000906C8, dword_1000906CC))
  {
    if (dword_10008FA20)
    {
      int v9 = ne_log_obj();
      if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR)) {
        sub_10006A0AC(v9);
      }
    }
    goto LABEL_42;
  }
  if (chmod((const char *)&xmmword_10008F218 + 2, word_10008C4E8))
  {
    if (dword_10008FA20)
    {
      unsigned int v13 = ne_log_obj();
      if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR)) {
        sub_100069FFC(v13);
      }
    }
    goto LABEL_42;
  }
  if (listen(*(_DWORD *)(qword_10008F848 + 28), 5))
  {
    if (dword_10008FA20)
    {
      int v15 = ne_log_obj();
      if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR)) {
        sub_100069F68(v15);
      }
    }
    goto LABEL_42;
  }
  if (dword_10008FA20)
  {
    unsigned int v16 = ne_log_obj();
    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)fds = 136315138;
      *(void *)&fds[4] = (char *)&xmmword_10008F218 + 2;
      _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "opened %s as racoon management.\n", fds, 0xCu);
    }
  }
LABEL_29:
  ssize_t v10 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_read, *(int *)(qword_10008F848 + 28), 0, (dispatch_queue_t)&_dispatch_main_q);
  *(void *)(qword_10008F848 + 40) = v10;
  if (v10)
  {
    dispatch_source_set_event_handler_f(v10, (dispatch_function_t)sub_100047E3C);
    int v11 = *(_DWORD *)(qword_10008F848 + 28);
    unsigned int v12 = *(NSObject **)(qword_10008F848 + 40);
    handler[0] = _NSConcreteStackBlock;
    handler[1] = 0x40000000;
    handler[2] = sub_10004A0F0;
    handler[3] = &unk_10008AC30;
    int v18 = v11;
    dispatch_source_set_cancel_handler(v12, handler);
    dispatch_resume(*(dispatch_object_t *)(qword_10008F848 + 40));
    return 0;
  }
  if (dword_10008FA20)
  {
    int v14 = ne_log_obj();
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR)) {
      sub_100069F34();
    }
  }
  return 0xFFFFFFFFLL;
}

uint64_t sub_10004A0F0(uint64_t a1)
{
  return close(*(_DWORD *)(a1 + 32));
}

uint64_t *sub_10004A0F8()
{
  if (dword_10008FA20)
  {
    int v0 = ne_log_obj();
    if (os_log_type_enabled(v0, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)int v4 = 0;
      _os_log_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_DEFAULT, "vpncontrol_close.\n", v4, 2u);
    }
  }
  dispatch_source_cancel(*(dispatch_source_t *)(qword_10008F848 + 40));
  uint64_t v1 = qword_10008F848;
  *(void *)(qword_10008F848 + 40) = 0;
  *(_DWORD *)(v1 + 28) = -1;
  uint64_t result = *(uint64_t **)(v1 + 64);
  if (result)
  {
    do
    {
      uint64_t v3 = *result;
      sub_100048F94(result);
      uint64_t result = (uint64_t *)v3;
    }
    while (v3);
  }
  return result;
}

BOOL sub_10004A1A4()
{
  return *(void *)(qword_10008F848 + 64) != 0;
}

void sub_10004A1DC(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_error_impl(a1, a2, OS_LOG_TYPE_ERROR, a4, &a9, 0x16u);
}

void sub_10004A1F8(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint8_t *a5)
{
  _os_log_error_impl(a1, a2, OS_LOG_TYPE_ERROR, a4, a5, 0x16u);
}

uint64_t sub_10004A29C(uint64_t a1, int a2)
{
  int v4 = malloc_type_calloc(1uLL, 0x80uLL, 0x1000040AE2C30F4uLL);
  if (!v4) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v5 = v4;
  *int v4 = 32768528;
  v4[1] = *(_DWORD *)(a1 + 16);
  int v6 = sub_1000388FC((sockaddr *)v4);
  if (!v6)
  {
    if (dword_10008FA20)
    {
      int v11 = ne_log_obj();
      if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR)) {
        sub_10006A2B4((const sockaddr *)v5);
      }
    }
    goto LABEL_12;
  }
  uint64_t v7 = (uint64_t)v6;
  if (*((void *)v6 + 37))
  {
    int v8 = sub_10003CC74();
    if (!v8)
    {
      if (dword_10008FA20)
      {
        uint64_t v9 = ne_log_obj();
        if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR)) {
          sub_10006A410();
        }
      }
LABEL_12:
      uint64_t v10 = 0xFFFFFFFFLL;
      unsigned int v12 = (sockaddr *)v5;
LABEL_38:
      free(v12);
      return v10;
    }
  }
  else
  {
    int v8 = sub_10003BCB0((const sockaddr *)v5);
    if (!v8)
    {
      if (dword_10008FA20)
      {
        int v22 = ne_log_obj();
        if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR)) {
          sub_10006A32C();
        }
      }
      goto LABEL_12;
    }
  }
  int v14 = *(_DWORD *)(a1 + 20);
  unsigned int v13 = (_OWORD *)(a1 + 20);
  if (v14)
  {
    *((_OWORD *)v5 + 7) = 0u;
    *(_OWORD *)(v5 + 25) = 0u;
    *(_OWORD *)(v5 + 21) = 0u;
    *(_OWORD *)(v5 + 17) = 0u;
    *(_OWORD *)(v5 + 13) = 0u;
    *(_OWORD *)(v5 + 9) = 0u;
    *(_OWORD *)(v5 + 5) = 0u;
    *(_OWORD *)(v5 + 1) = 0u;
    *uint64_t v5 = 32775708;
    nw_nat64_synthesize_v6();
  }
  int v15 = (sockaddr *)sub_10003CC74();
  unsigned int v12 = v15;
  if (!v15)
  {
    if (dword_10008FA20)
    {
      size_t v21 = ne_log_obj();
      if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR)) {
        sub_10006A360();
      }
    }
    goto LABEL_36;
  }
  int sa_family = v15->sa_family;
  if (sa_family != 30 && sa_family != 2)
  {
    if (dword_10008FA20)
    {
      long long v23 = ne_log_obj();
      if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR)) {
        sub_10006A394(&v12->sa_family, v23);
      }
    }
    goto LABEL_36;
  }
  *(_WORD *)v15->sa_data = *(_WORD *)(*(void *)v7 + 2);
  unsigned int v17 = sub_100006CB0((unint64_t)v8);
  if (!sub_10003D910((uint64_t)v8, __rev16(v17)))
  {
LABEL_36:
    uint64_t v10 = 0xFFFFFFFFLL;
    goto LABEL_37;
  }
  if (dword_10008FA20)
  {
    int v18 = ne_log_obj();
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
    {
      int v25 = 136315138;
      ssize_t v26 = sub_10003CE24(v12);
      _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "accept a request to establish IKE-SA: %s\n", (uint8_t *)&v25, 0xCu);
    }
    if (dword_10008FA20)
    {
      int v19 = ne_log_obj();
      if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
      {
        ssize_t v20 = sub_10003CE24(v12);
        int v25 = 136315138;
        ssize_t v26 = v20;
        _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "IPSec connecting to server %s\n", (uint8_t *)&v25, 0xCu);
      }
    }
  }
  uint64_t v10 = ((int)sub_100021EA8(0, v7, (uint64_t)v12, (uint64_t)v8, a2, v13) >> 31);
LABEL_37:
  free(v5);
  free(v8);
  if (v12) {
    goto LABEL_38;
  }
  return v10;
}

uint64_t sub_10004A618(uint64_t a1, uint64_t a2)
{
  uint64_t v16 = 0;
  long long v14 = 0u;
  long long v15 = 0u;
  long long v12 = 0u;
  long long v13 = 0u;
  long long v10 = 0u;
  long long v11 = 0u;
  long long v9 = 0u;
  int v3 = *(_DWORD *)(a1 + 16);
  v8[0] = 528;
  v8[1] = v3;
  if (dword_10008FA20)
  {
    int v4 = ne_log_obj();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      int v6 = 136315138;
      uint64_t v7 = sub_10003CE24((const sockaddr *)v8);
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "IPSec disconnecting from server %s\n", (uint8_t *)&v6, 0xCu);
    }
  }
  sub_10004DA1C((unint64_t)v8, 0, a2);
  if ((int)sub_100009560((unint64_t)v8) >= 1) {
    return 0;
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

uint64_t sub_10004A710(uint64_t a1, uint64_t a2, unint64_t a3)
{
  uint64_t v5 = a1;
  uint64_t v74 = 0;
  int v6 = *(_DWORD *)(a1 + 16);
  v73[0] = 528;
  v73[1] = v6;
  uint64_t v7 = sub_100007798(0, (unint64_t)v73);
  if (v7)
  {
    uint64_t v8 = v7;
    if ((*(unsigned char *)(v7 + 17) & 0x20) != 0)
    {
      unsigned int v11 = __rev16(*(unsigned __int16 *)(a2 + 26));
      unint64_t v12 = 24 * v11 + 32;
      if (v12 <= a3)
      {
        if (v12 + 8 * (bswap32(*(unsigned __int16 *)(a2 + 28)) >> 16) <= a3)
        {
          if (!*(_WORD *)(a2 + 26)) {
            return 0;
          }
          int v15 = 0;
          uint64_t v16 = a2 + 32;
          uint64_t v67 = v7;
          uint64_t v68 = a2 + 32 + 24 * v11;
          uint64_t v65 = (void *)(v7 + 64);
          uint64_t v66 = (void *)(v7 + 72);
          uint64_t v71 = v5;
          while (1)
          {
            sub_10003A554();
            if (!v17) {
              break;
            }
            uint64_t v18 = v17;
            if (*(_DWORD *)(v16 + 4) == -1) {
              size_t v19 = 8;
            }
            else {
              size_t v19 = 12;
            }
            ssize_t v20 = sub_10003F940(v19);
            *(void *)uint64_t v18 = v20;
            if (!v20)
            {
              if (dword_10008FA20)
              {
                __int16 v58 = ne_log_obj();
                if (os_log_type_enabled(v58, OS_LOG_TYPE_ERROR)) {
LABEL_99:
                }
                  sub_10006A5B0();
              }
LABEL_91:
              sub_10003A7B8((void *)v18);
              goto LABEL_92;
            }
            if (*(_DWORD *)(v16 + 12) == -1) {
              size_t v21 = 8;
            }
            else {
              size_t v21 = 12;
            }
            int v22 = sub_10003F940(v21);
            *(void *)(v18 + 8) = v22;
            if (!v22)
            {
              if (dword_10008FA20)
              {
                uint64_t v59 = ne_log_obj();
                if (os_log_type_enabled(v59, OS_LOG_TYPE_ERROR)) {
                  goto LABEL_99;
                }
              }
              goto LABEL_91;
            }
            uint64_t v23 = *(void *)(*(void *)v18 + 8);
            int v24 = *(_DWORD *)(v16 + 4);
            if (v24 == -1)
            {
              char v25 = 1;
            }
            else
            {
              *(_DWORD *)(v23 + 8) = v24;
              char v25 = 4;
            }
            *(unsigned char *)uint64_t v23 = v25;
            *(_DWORD *)(v23 + 4) = *(_DWORD *)v16;
            *(_WORD *)(v23 + 2) = *(_WORD *)(v16 + 16);
            __int16 v26 = *(_WORD *)(v16 + 20);
            *(unsigned char *)(v23 + 1) = v26;
            uint64_t v27 = v22[1];
            int v28 = *(_DWORD *)(v16 + 12);
            if (v28 == -1)
            {
              char v29 = 1;
            }
            else
            {
              *(_DWORD *)(v27 + 8) = v28;
              char v29 = 4;
            }
            *(unsigned char *)uint64_t v27 = v29;
            *(_DWORD *)(v27 + 4) = *(_DWORD *)(v16 + 8);
            *(_WORD *)(v27 + 2) = *(_WORD *)(v16 + 18);
            *(unsigned char *)(v27 + 1) = v26;
            *(_DWORD *)(v18 + 104) = *(_DWORD *)(v5 + 16);
            *(void *)(v18 + 24) = bswap32(*(_DWORD *)(a2 + 20));
            int v70 = v15;
            if (*(_WORD *)(a2 + 24))
            {
              int v30 = sub_100003988(5, __rev16(*(unsigned __int16 *)(a2 + 24)));
              *(_DWORD *)(v18 + 36) = v30;
              if (v30 == -1)
              {
                if (dword_10008FA20)
                {
                  int v60 = ne_log_obj();
                  if (os_log_type_enabled(v60, OS_LOG_TYPE_ERROR)) {
                    sub_10006A9F8();
                  }
                }
                goto LABEL_91;
              }
            }
            else
            {
              int v31 = *(_DWORD *)(*(void *)(v8 + 408) + 1140);
              if (v31)
              {
                if (*(unsigned char *)(v8 + 81) == 4)
                {
                  if (dword_10008FA20)
                  {
                    uint64_t v32 = ne_log_obj();
                    if (os_log_type_enabled(v32, OS_LOG_TYPE_DEBUG)) {
                      sub_10006A950(buf, (uint64_t)v65, &v78, v32);
                    }
                  }
                  size_t v33 = (int *)(*v65 + 188);
                }
                else
                {
                  if (dword_10008FA20)
                  {
                    uint64_t v34 = ne_log_obj();
                    if (os_log_type_enabled(v34, OS_LOG_TYPE_DEBUG)) {
                      sub_10006A9A4(v75, (uint64_t)v66, v76, v34);
                    }
                  }
                  size_t v33 = (int *)(*v66 + 60);
                }
                int v31 = *v33;
              }
              *(_DWORD *)(v18 + 36) = v31;
            }
            uint64_t v69 = v16;
            if (*(_WORD *)(a2 + 28))
            {
              unsigned int v35 = 0;
              char v36 = (unsigned __int16 *)v68;
              uint64_t v72 = v18;
              while (1)
              {
                unsigned int v37 = sub_10003A800();
                if (!v37) {
                  break;
                }
                int v38 = v37;
                uint64_t v39 = a2;
                unsigned int v40 = *v36;
                unsigned int v41 = __rev16(v40);
                unsigned int v42 = v36[1];
                unsigned int v43 = __rev16(v42);
                unsigned int v44 = v36[2];
                int v45 = sub_100003988(v41, v43);
                _DWORD *v38 = v45;
                if (v45 == -1)
                {
                  if (dword_10008FA20)
                  {
                    char v50 = ne_log_obj();
                    if (os_log_type_enabled(v50, OS_LOG_TYPE_ERROR)) {
                      sub_10006A7F8();
                    }
                  }
                  free(v38);
                  uint64_t v5 = v71;
                  goto LABEL_91;
                }
                unsigned int v46 = sub_10000377C(v41, v43);
                if (v46)
                {
                  if (v44)
                  {
                    unsigned int v46 = __rev16(v44);
                    if ((sub_1000037AC(v41, v43, v46) & 0x80000000) != 0)
                    {
                      if (dword_10008FA20)
                      {
                        int v55 = ne_log_obj();
                        if (os_log_type_enabled(v55, OS_LOG_TYPE_ERROR)) {
                          sub_10006A8D8(v46, v55);
                        }
                      }
LABEL_90:
                      free(v38);
                      uint64_t v5 = v71;
                      uint64_t v18 = v72;
                      goto LABEL_91;
                    }
                  }
                }
                else if (v44)
                {
                  if (dword_10008FA20)
                  {
                    int v56 = ne_log_obj();
                    if (os_log_type_enabled(v56, OS_LOG_TYPE_ERROR)) {
                      sub_10006A8A4();
                    }
                  }
                  goto LABEL_90;
                }
                v38[1] = v46;
                if ((v40 != 256 || v42 != 4608) && sub_100030D34(v41, v43, v46))
                {
                  int v51 = sub_100003B14(v41);
                  if (v51 == 5) {
                    int v52 = 2;
                  }
                  else {
                    int v52 = v51;
                  }
                  if (dword_10008FA20)
                  {
                    uint64_t v53 = *v38;
                    uint64_t v54 = ne_log_obj();
                    if (os_log_type_enabled(v54, OS_LOG_TYPE_ERROR)) {
                      sub_10006A82C(v52, v53);
                    }
                  }
                  goto LABEL_90;
                }
                uint64_t v18 = v72;
                sub_10003A81C((uint64_t *)(v72 + 8 * v41 + 48), (uint64_t)v38);
                ++v35;
                a2 = v39;
                v36 += 4;
                if (v35 >= bswap32(*(unsigned __int16 *)(v39 + 28)) >> 16) {
                  goto LABEL_62;
                }
              }
              uint64_t v5 = v71;
              if (dword_10008FA20)
              {
                int v49 = ne_log_obj();
                if (os_log_type_enabled(v49, OS_LOG_TYPE_ERROR)) {
                  sub_10006A7C4();
                }
              }
              goto LABEL_91;
            }
LABEL_62:
            if (!*(void *)(v18 + 48))
            {
              uint64_t v5 = v71;
              if (dword_10008FA20)
              {
                int v61 = ne_log_obj();
                if (os_log_type_enabled(v61, OS_LOG_TYPE_ERROR)) {
                  sub_10006A5E4((uint64_t *)v18);
                }
              }
              goto LABEL_91;
            }
            uint64_t v5 = v71;
            if (!*(void *)(v18 + 56))
            {
              if (dword_10008FA20)
              {
                long long v62 = ne_log_obj();
                if (os_log_type_enabled(v62, OS_LOG_TYPE_ERROR)) {
                  sub_10006A65C((uint64_t *)v18);
                }
              }
              goto LABEL_91;
            }
            if (!*(void *)(v18 + 64))
            {
              if (dword_10008FA20)
              {
                long long v63 = ne_log_obj();
                if (os_log_type_enabled(v63, OS_LOG_TYPE_ERROR)) {
                  sub_10006A6D4((uint64_t *)v18);
                }
              }
              goto LABEL_91;
            }
            int v47 = (void *)sub_10003A168(*(void *)v18, *(void *)(v18 + 8), *(void *)(v18 + 40), 0);
            if (v47 && !*v47 && !*(void *)v18)
            {
              if (dword_10008FA20)
              {
                long long v64 = ne_log_obj();
                if (os_log_type_enabled(v64, OS_LOG_TYPE_ERROR)) {
                  sub_10006A74C((uint64_t *)v18);
                }
              }
              goto LABEL_91;
            }
            sub_10003A664(v18);
            uint64_t result = 0;
            int v15 = v70 + 1;
            uint64_t v16 = v69 + 24;
            uint64_t v8 = v67;
            if (v70 + 1 >= bswap32(*(unsigned __int16 *)(a2 + 26)) >> 16) {
              return result;
            }
          }
          if (dword_10008FA20)
          {
            int v57 = ne_log_obj();
            if (os_log_type_enabled(v57, OS_LOG_TYPE_ERROR)) {
              sub_10006A57C();
            }
          }
LABEL_92:
          sub_10003A730(*(_DWORD *)(v5 + 16));
        }
        else if (dword_10008FA20)
        {
          long long v14 = ne_log_obj();
          if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR)) {
            sub_10006A514();
          }
        }
      }
      else if (dword_10008FA20)
      {
        long long v13 = ne_log_obj();
        if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR)) {
          sub_10006A4AC();
        }
      }
    }
    else if (dword_10008FA20)
    {
      long long v9 = ne_log_obj();
      if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR)) {
        sub_10006A478();
      }
    }
  }
  else if (dword_10008FA20)
  {
    long long v10 = ne_log_obj();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR)) {
      sub_10006A444();
    }
  }
  return 0xFFFFFFFFLL;
}

uint64_t sub_10004AEE0(uint64_t a1, void *a2, size_t *a3)
{
  *a2 = 0;
  if (!*(void *)(*(void *)(a1 + 408) + 1192)) {
    return 1;
  }
  int v6 = sub_100006340(*(const sockaddr **)(a1 + 56), 0);
  if (!v6)
  {
    if (dword_10008FA20)
    {
      uint64_t v18 = ne_log_obj();
      if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR)) {
        sub_10006AA2C();
      }
    }
    return 0xFFFFFFFFLL;
  }
  uint64_t v7 = v6;
  size_t v8 = (unsigned __int16)(**(_WORD **)(*(void *)(a1 + 408) + 1192) + 44);
  long long v9 = malloc_type_calloc(1uLL, v8, 0x464777ADuLL);
  *a2 = v9;
  if (!v9)
  {
    if (dword_10008FA20)
    {
      size_t v19 = ne_log_obj();
      if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR)) {
        sub_10006AA60();
      }
    }
    return 0xFFFFFFFFLL;
  }
  long long v10 = v9;
  v9[1] = 256;
  uint64_t v11 = *(void *)(a1 + 56);
  if (*(unsigned char *)(v11 + 1) == 2) {
    *((_DWORD *)v9 + 5) = *(_DWORD *)(v11 + 4);
  }
  *((_DWORD *)v9 + 6) = 0;
  unsigned __int16 v12 = strlen((const char *)v7[5]);
  *(void *)(v10 + 14) = 0;
  long long v13 = v10 + 14;
  v13[1] = 0;
  if (v12 >= 0xFu) {
    size_t v14 = 15;
  }
  else {
    size_t v14 = v12;
  }
  memcpy(v13, (const void *)v7[5], v14);
  memcpy(v13 + 2, *(const void **)(*(void *)(*(void *)(a1 + 408) + 1192) + 8), **(void **)(*(void *)(a1 + 408) + 1192));
  *a3 = v8;
  if (dword_10008FA20)
  {
    int v15 = ne_log_obj();
    BOOL v16 = os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT);
    uint64_t result = 0;
    if (!v16) {
      return result;
    }
    *(_WORD *)ssize_t v20 = 0;
    _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "IPSec Network Configuration established.\n", v20, 2u);
  }
  return 0;
}

uint64_t sub_10004B0A8(int a1, _WORD *a2, size_t a3)
{
  uint64_t v24 = 0;
  v23[0] = 528;
  v23[1] = a1;
  uint64_t v5 = sub_100007798(0, (unint64_t)v23);
  if (!v5)
  {
    if (dword_10008FA20)
    {
      uint64_t v11 = ne_log_obj();
      if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR)) {
        sub_10006AA94();
      }
    }
    return 0xFFFFFFFFLL;
  }
  uint64_t v6 = v5;
  if (!*(unsigned char *)(v5 + 417))
  {
    if (dword_10008FA20)
    {
      unsigned __int16 v12 = ne_log_obj();
      if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR)) {
        sub_10006AAC8();
      }
    }
    return 0xFFFFFFFFLL;
  }
  int i = a3;
  if ((int)a3 >= 1)
  {
    size_t v8 = a2;
    for (int i = a3; i > 0; i -= 4)
    {
      if ((*v8 & 0x80) == 0)
      {
        uint64_t v9 = bswap32((unsigned __int16)v8[1]) >> 16;
        i -= v9;
        size_t v8 = (_WORD *)((char *)v8 + v9);
      }
      v8 += 2;
    }
  }
  if (i)
  {
    if (dword_10008FA20)
    {
      long long v10 = ne_log_obj();
      if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR)) {
        sub_10006AB70();
      }
    }
    return 0xFFFFFFFFLL;
  }
  int v15 = sub_10003F940(a3 + 8);
  if (!v15)
  {
    if (dword_10008FA20)
    {
      size_t v21 = ne_log_obj();
      if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR)) {
        sub_10006AAFC();
      }
    }
    return 0xFFFFFFFFLL;
  }
  BOOL v16 = v15;
  *(void *)v15[1] = 0;
  uint64_t v17 = v15[1];
  *(_WORD *)(v17 + 2) = bswap32(*(unsigned __int16 *)v15) >> 16;
  *(unsigned char *)(v17 + 4) = 2;
  *(_WORD *)(v17 + 6) = *(unsigned __int8 *)(v6 + 416);
  *(unsigned char *)(v6 + 417) = 0;
  memcpy((void *)(v17 + 8), a2, a3);
  if (dword_10008FA20)
  {
    uint64_t v18 = ne_log_obj();
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG)) {
      sub_10006AB30();
    }
  }
  uint64_t v13 = sub_1000445EC(v6, (uint64_t)v16, 14, 1, 0, 0, *(void *)(v6 + 424));
  size_t v19 = *(void **)(v6 + 424);
  if (v19)
  {
    sub_10003FA78(v19);
    *(void *)(v6 + 424) = 0;
  }
  sub_10004E92C(v6);
  if (dword_10008FA20)
  {
    ssize_t v20 = ne_log_obj();
    if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)int v22 = 0;
      _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "IPSec Extended Authentication sent.\n", v22, 2u);
    }
  }
  sub_10003FA78(v16);
  return v13;
}

uint64_t sub_10004B34C(uint64_t a1, uint64_t a2)
{
  uint64_t result = sub_10004FBE8(a1, a2);
  if (result)
  {
    if (dword_10008FA20)
    {
      int v3 = ne_log_obj();
      if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR)) {
        sub_10006ABA4();
      }
    }
    return 0xFFFFFFFFLL;
  }
  return result;
}

void sub_10004B3BC()
{
  qword_1000906D0 = 0;
}

uint64_t sub_10004B3C8(int a1, unsigned int a2)
{
  unsigned int v2 = a2 / 0xA;
  if (a1) {
    int v3 = -1;
  }
  else {
    int v3 = -2;
  }
  BOOL v4 = __CFADD__(v3, a2);
  unsigned int v5 = v3 + a2;
  if (!v4) {
    unsigned int v5 = 0;
  }
  int v6 = 8 * v2;
  unsigned int v7 = 9 * v2;
  if (!a1) {
    unsigned int v7 = v6;
  }
  if (a2 >= 0xA) {
    return v7;
  }
  else {
    return v5;
  }
}

uint64_t sub_10004B408(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = result;
    if (dword_10008FA20)
    {
      unsigned int v2 = ne_log_obj();
      if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
      {
        int v3 = 136315138;
        BOOL v4 = sub_10003CAE4((const sockaddr *)(v1 + 128));
        _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "New IKE Session to %s.\n", (uint8_t *)&v3, 0xCu);
      }
    }
    return sub_10004B4C8((long long *)v1);
  }
  return result;
}

uint64_t sub_10004B4C8(long long *a1)
{
  if (a1)
  {
    unsigned int v2 = malloc_type_calloc(1uLL, 0x6C0uLL, 0x10B00402B0E598BuLL);
    uint64_t v3 = (uint64_t)v2;
    if (v2)
    {
      bzero(v2, 0x6C0uLL);
      long long v4 = *a1;
      long long v5 = a1[1];
      long long v6 = a1[2];
      *(_OWORD *)(v3 + 56) = a1[3];
      *(_OWORD *)(v3 + 40) = v6;
      *(_OWORD *)(v3 + 24) = v5;
      *(_OWORD *)(v3 + 8) = v4;
      long long v7 = a1[4];
      long long v8 = a1[5];
      long long v9 = a1[6];
      *(_OWORD *)(v3 + 120) = a1[7];
      *(_OWORD *)(v3 + 104) = v9;
      *(_OWORD *)(v3 + 88) = v8;
      *(_OWORD *)(v3 + 72) = v7;
      long long v10 = a1[8];
      long long v11 = a1[9];
      long long v12 = a1[10];
      *(_OWORD *)(v3 + 184) = a1[11];
      *(_OWORD *)(v3 + 168) = v12;
      *(_OWORD *)(v3 + 152) = v11;
      *(_OWORD *)(v3 + 136) = v10;
      long long v13 = a1[12];
      long long v14 = a1[13];
      long long v15 = a1[14];
      *(_OWORD *)(v3 + 248) = a1[15];
      *(_OWORD *)(v3 + 232) = v15;
      *(_OWORD *)(v3 + 216) = v14;
      *(_OWORD *)(v3 + 200) = v13;
      *(_OWORD *)(v3 + 1696) = 0u;
      uint64_t v16 = qword_1000906D0;
      *(void *)(v3 + 1712) = qword_1000906D0;
      if (v16) {
        *(void *)(v16 + 1720) = v3 + 1712;
      }
      qword_1000906D0 = v3;
      *(void *)(v3 + 1720) = &qword_1000906D0;
    }
  }
  else
  {
    if (dword_10008FA20)
    {
      uint64_t v17 = ne_log_obj();
      if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR)) {
        sub_10006ABD8(v17, v18, v19, v20, v21, v22, v23, v24);
      }
    }
    return 0;
  }
  return v3;
}

uint64_t sub_10004B5E8(uint64_t a1)
{
  for (int i = *(void **)(a1 + 1704); i; int i = *(void **)(a1 + 1704))
    sub_10004B62C(i);
  while (1)
  {
    uint64_t result = *(void *)(a1 + 1696);
    if (!result) {
      break;
    }
    sub_10004B710(result);
  }
  return result;
}

uint64_t sub_10004B62C(void *a1)
{
  if (a1 && a1[34])
  {
    sub_10003AC68((uint64_t)a1);
    if (a1[32])
    {
      a1[32] = 0;
      uint64_t v2 = a1[39];
      if (v2) {
        *(void *)(v2 + 320) = a1[40];
      }
      *(void *)a1[40] = v2;
    }
    uint64_t v3 = a1[37];
    if (v3) {
      *(void *)(v3 + 304) = a1[38];
    }
    *(void *)a1[38] = v3;
    uint64_t v4 = a1[34];
    a1[34] = 0;
    int v5 = *(_DWORD *)(v4 + 360) - 1;
    *(_DWORD *)(v4 + 360) = v5;
    if (!(*(_DWORD *)(v4 + 352) | v5))
    {
      *(unsigned char *)(v4 + 280) |= 2u;
      sub_10004C4EC((unsigned int *)v4);
    }
    sub_10000843C(a1);
    return 0;
  }
  else
  {
    if (dword_10008FA20)
    {
      long long v7 = ne_log_obj();
      if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR)) {
        sub_10006AC50(v7, v8, v9, v10, v11, v12, v13, v14);
      }
    }
    return 0xFFFFFFFFLL;
  }
}

uint64_t sub_10004B710(uint64_t a1)
{
  if (a1 && *(void *)(a1 + 440))
  {
    if (*(unsigned char *)(a1 + 80) == 16 && *(void *)(a1 + 448)) {
      sub_10004C2B0(a1);
    }
    sub_10003AC68(a1);
    uint64_t v2 = *(void *)(a1 + 440);
    uint64_t v3 = *(void *)(a1 + 456);
    if (v3) {
      *(void *)(v3 + 464) = *(void *)(a1 + 464);
    }
    **(void **)(a1 + 464) = v3;
    *(void *)(a1 + 440) = 0;
    int v4 = *(_DWORD *)(v2 + 352) - 1;
    *(_DWORD *)(v2 + 352) = v4;
    if (!v4 && !*(_DWORD *)(v2 + 360))
    {
      *(unsigned char *)(v2 + 280) |= 2u;
      sub_10004C4EC((unsigned int *)v2);
    }
    sub_100007920(a1);
    return 0;
  }
  else
  {
    if (dword_10008FA20)
    {
      long long v6 = ne_log_obj();
      if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR)) {
        sub_10006ACC8(v6, v7, v8, v9, v10, v11, v12, v13);
      }
    }
    return 0xFFFFFFFFLL;
  }
}

uint64_t sub_10004B7EC(uint64_t a1, uint64_t a2, int a3, void *a4)
{
  if (!a1 || !a2)
  {
    if (dword_10008FA20)
    {
      uint64_t v10 = ne_log_obj();
      if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR)) {
        sub_10006B084(v10, v11, v12, v13, v14, v15, v16, v17);
      }
    }
    return 0;
  }
  int v8 = sub_10003D80C(a2);
  memset(__s2, 0, sizeof(__s2));
  memset(v48, 0, sizeof(v48));
  memset(v49, 0, sizeof(v49));
  memset(v47, 0, sizeof(v47));
  memset(v46, 0, sizeof(v46));
  memset(v44, 0, sizeof(v44));
  memset(v45, 0, sizeof(v45));
  int v9 = *(unsigned __int8 *)(a1 + 1);
  if (v9 == 30)
  {
    __s2[0] = *(sockaddr *)a1;
    sockaddr v18 = __s2[0];
    *(sockaddr *)&__s2[0].sa_data[10] = *(sockaddr *)(a1 + 12);
    v48[0] = v18;
    *(sockaddr *)((char *)v48 + 12) = *(sockaddr *)&__s2[0].sa_data[10];
    v46[0] = v18;
    *(sockaddr *)((char *)v46 + 12) = *(sockaddr *)&__s2[0].sa_data[10];
    v44[0] = v18;
    *(sockaddr *)((char *)v44 + 12) = *(sockaddr *)&__s2[0].sa_data[10];
  }
  else if (v9 == 2)
  {
    __s2[0] = *(sockaddr *)a1;
    v48[0] = __s2[0];
    v46[0] = __s2[0];
    v44[0] = __s2[0];
  }
  sub_10003D910((uint64_t)v48, 0x1F4u);
  sub_10003D910((uint64_t)v46, 0x1194u);
  sub_10003D910((uint64_t)v44, 0);
  int v19 = *(unsigned __int8 *)(a2 + 1);
  if (v19 == 30)
  {
    __s2[8] = *(sockaddr *)a2;
    sockaddr v20 = __s2[8];
    *(sockaddr *)&__s2[8].sa_data[10] = *(sockaddr *)(a2 + 12);
    v49[0] = v20;
    *(sockaddr *)((char *)v49 + 12) = *(sockaddr *)&__s2[8].sa_data[10];
    v47[0] = v20;
    *(sockaddr *)((char *)v47 + 12) = *(sockaddr *)&__s2[8].sa_data[10];
    v45[0] = v20;
    *(sockaddr *)((char *)v45 + 12) = *(sockaddr *)&__s2[8].sa_data[10];
  }
  else if (v19 == 2)
  {
    __s2[8] = *(sockaddr *)a2;
    v49[0] = __s2[8];
    v47[0] = __s2[8];
    v45[0] = __s2[8];
  }
  sub_10003D910((uint64_t)v49, 0x1F4u);
  sub_10003D910((uint64_t)v47, 0x1194u);
  sub_10003D910((uint64_t)v45, 0);
  if (dword_10008FA20)
  {
    uint64_t v21 = ne_log_obj();
    if (os_log_type_enabled(v21, OS_LOG_TYPE_DEBUG)) {
      sub_10006B00C((const sockaddr *)a2);
    }
  }
  uint64_t v22 = qword_1000906D0;
  if (!qword_1000906D0)
  {
LABEL_50:
    if (a3)
    {
      if (dword_10008FA20)
      {
        int v31 = ne_log_obj();
        if (os_log_type_enabled(v31, OS_LOG_TYPE_DEBUG)) {
          sub_10006AD40(__s2);
        }
      }
      return sub_10004B4C8((long long *)__s2);
    }
    return 0;
  }
  uint64_t v23 = 0;
  do
  {
    uint64_t v24 = v23;
    if (dword_10008FA20)
    {
      char v25 = ne_log_obj();
      if (os_log_type_enabled(v25, OS_LOG_TYPE_DEBUG)) {
        sub_10006AFA0(v42, v22, &v43, v25);
      }
    }
    if ((*(unsigned char *)(v22 + 280) & 2) != 0
      || (*(_WORD *)(v22 + 264) & 0x20) != 0
      || *(void *)(v22 + 336)
      || *(_DWORD *)(v22 + 344))
    {
      if (dword_10008FA20)
      {
        __int16 v26 = ne_log_obj();
        if (os_log_type_enabled(v26, OS_LOG_TYPE_DEBUG))
        {
          uint64_t v27 = sub_10003CAE4((const sockaddr *)(v22 + 136));
          int v28 = *(_DWORD *)(v22 + 352);
          int v29 = *(_DWORD *)(v22 + 360);
          *(_DWORD *)uint8_t buf = 136315650;
          unsigned int v37 = v27;
          __int16 v38 = 1024;
          int v39 = v28;
          __int16 v40 = 1024;
          int v41 = v29;
          _os_log_debug_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEBUG, "still searching. skipping... session to %s is already stopped, active ph1 %d ph2 %d.\n", buf, 0x18u);
        }
      }
LABEL_29:
      uint64_t v23 = v24;
      goto LABEL_30;
    }
    if (a4 && !sub_1000072D0(v22, a4)) {
      goto LABEL_29;
    }
    if (!memcmp((const void *)(v22 + 8), __s2, 0x100uLL))
    {
      if (dword_10008FA20)
      {
        size_t v33 = ne_log_obj();
        if (os_log_type_enabled(v33, OS_LOG_TYPE_DEBUG)) {
          sub_10006ADBC((const sockaddr *)a2);
        }
      }
      return v22;
    }
    if (v8 && v8 != 4500 && v8 != 500) {
      goto LABEL_42;
    }
    if (!memcmp((const void *)(v22 + 8), v48, 0x100uLL))
    {
      if (dword_10008FA20)
      {
        uint64_t v34 = ne_log_obj();
        if (os_log_type_enabled(v34, OS_LOG_TYPE_DEBUG)) {
          sub_10006AEB0((const sockaddr *)a2);
        }
      }
      return v22;
    }
    if ((*(_WORD *)(v22 + 264) & 2) != 0 && !memcmp((const void *)(v22 + 8), v46, 0x100uLL))
    {
      if (dword_10008FA20)
      {
        unsigned int v35 = ne_log_obj();
        if (os_log_type_enabled(v35, OS_LOG_TYPE_DEBUG)) {
          sub_10006AF28((const sockaddr *)a2);
        }
      }
      return v22;
    }
    uint64_t v23 = v22;
    if (memcmp((const void *)(v22 + 8), v44, 0x100uLL))
    {
LABEL_42:
      if (a4) {
        uint64_t v23 = v22;
      }
      else {
        uint64_t v23 = v24;
      }
    }
LABEL_30:
    uint64_t v22 = *(void *)(v22 + 1712);
  }
  while (v22);
  if (!v23) {
    goto LABEL_50;
  }
  if (dword_10008FA20)
  {
    int v30 = ne_log_obj();
    if (os_log_type_enabled(v30, OS_LOG_TYPE_DEBUG)) {
      sub_10006AE34(v23);
    }
  }
  return v23;
}

uint64_t sub_10004BD44(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = *(_DWORD **)(result + 64);
    if (v1)
    {
      int v2 = v1[57];
      if (v2 || v1[54])
      {
        uint64_t v3 = *(_DWORD **)(result + 440);
        if (!v3[93]) {
          v3[93] = v2;
        }
        if (!v3[94]) {
          v3[94] = v1[58];
        }
        if (!v3[92])
        {
          int v4 = v1[54];
          if (v4 && (v1[56] - 1) <= 1)
          {
            if (v4 <= v2) {
              int v5 = v2;
            }
            else {
              int v5 = v1[54];
            }
            if (v4 >= v2) {
              int v6 = v2;
            }
            else {
              int v6 = v4;
            }
            if (v2)
            {
              int v2 = v6;
            }
            else
            {
              int v2 = v6;
              if ((v4 & 0x80000000) == 0)
              {
                unsigned int v7 = v5 / 0x14u;
                if (v5 < 6) {
                  int v8 = 1;
                }
                else {
                  int v8 = 3;
                }
                if (v5 <= 59) {
                  unsigned int v7 = v8;
                }
LABEL_33:
                v3[92] = v7;
                return result;
              }
            }
          }
          else if (!v2)
          {
            return result;
          }
          if (v2 < 6) {
            int v9 = 1;
          }
          else {
            int v9 = 3;
          }
          if (v2 <= 59) {
            unsigned int v7 = v9;
          }
          else {
            unsigned int v7 = v2 / 0x14u;
          }
          goto LABEL_33;
        }
      }
    }
  }
  return result;
}

uint64_t sub_10004BE1C(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = (void *)result;
    uint64_t v2 = *(void *)(result + 272);
    if (v2)
    {
      if (!*(_DWORD *)(result + 48) && (*(_WORD *)(v2 + 264) & 4) == 0)
      {
        uint64_t v3 = *(void *)(result + 128);
        if (v3)
        {
          uint64_t result = sub_10000ECE4(v3);
          if (result)
          {
            uint64_t v4 = v1[16];
LABEL_11:
            uint64_t result = sub_10000ED24(v4);
            if (!result) {
              return result;
            }
            *(_WORD *)(v1[34] + 264) &= ~4u;
            *(_WORD *)(v1[34] + 264) |= 8u;
            uint64_t v5 = v1[34];
            __int16 v6 = *(_WORD *)(v5 + 264) & 0xFFEF;
            goto LABEL_14;
          }
        }
        else
        {
          uint64_t result = v1[15];
          if (!result) {
            return result;
          }
          uint64_t result = sub_10000ECE4(result);
          if (result)
          {
            uint64_t v4 = v1[15];
            goto LABEL_11;
          }
        }
        *(_WORD *)(v1[34] + 264) &= ~4u;
        *(_WORD *)(v1[34] + 264) &= ~8u;
        uint64_t v5 = v1[34];
        __int16 v6 = *(_WORD *)(v5 + 264) | 0x10;
LABEL_14:
        *(_WORD *)(v5 + 264) = v6;
      }
    }
  }
  return result;
}

uint64_t sub_10004BEF0(uint64_t a1, uint64_t a2)
{
  if (a1 && a2)
  {
    gettimeofday((timeval *)(a1 + 304), 0);
    if (*(_DWORD *)(a2 + 24)) {
      *(_WORD *)(a1 + 264) = *(_WORD *)(a1 + 264) & 0xFFE3 | 4;
    }
    *(void *)(a2 + 440) = a1;
    uint64_t v4 = *(void *)(a1 + 1696);
    *(void *)(a2 + 456) = v4;
    if (v4) {
      *(void *)(v4 + 464) = a2 + 456;
    }
    *(void *)(a1 + 1696) = a2;
    *(void *)(a2 + 464) = a1 + 1696;
    ++*(_DWORD *)(a1 + 352);
    int v5 = *(_DWORD *)(a1 + 356);
    if ((v5 || *(_DWORD *)(a2 + 20)) && !*(_DWORD *)(a2 + 24))
    {
      __int16 v6 = *(_WORD *)(a1 + 264);
      if (!v5)
      {
LABEL_20:
        *(_DWORD *)(a1 + 356) = v5 + 1;
        sub_10004BD44(a2);
        return 0;
      }
    }
    else
    {
      __int16 v6 = *(_WORD *)(a1 + 264) | 0x400;
      *(_WORD *)(a1 + 264) = v6;
      if (!v5) {
        goto LABEL_20;
      }
    }
    if ((v6 & 1) != 0 && *(unsigned char *)(a2 + 80) == 16)
    {
      *(unsigned char *)(a2 + 432) |= 1u;
      int v5 = *(_DWORD *)(a1 + 356);
    }
    goto LABEL_20;
  }
  if (dword_10008FA20)
  {
    unsigned int v7 = ne_log_obj();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR)) {
      sub_10006B0FC(v7, v8, v9, v10, v11, v12, v13, v14);
    }
  }
  return 0xFFFFFFFFLL;
}

uint64_t sub_10004C010(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    if (*(void *)(a2 + 272)) {
      BOOL v4 = dword_10008FA20 == 0;
    }
    else {
      BOOL v4 = 1;
    }
    if (!v4)
    {
      int v5 = ne_log_obj();
      if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR)) {
        sub_10006B1EC(v5, v6, v7, v8, v9, v10, v11, v12);
      }
    }
    *(void *)(a2 + 272) = a1;
    uint64_t v13 = *(void *)(a1 + 1704);
    *(void *)(a2 + 296) = v13;
    if (v13) {
      *(void *)(v13 + 304) = a2 + 296;
    }
    *(void *)(a1 + 1704) = a2;
    *(void *)(a2 + 304) = a1 + 1704;
    ++*(_DWORD *)(a1 + 360);
    int v14 = *(_DWORD *)(a1 + 364);
    if (!v14 && !*(unsigned char *)(a2 + 60)) {
      *(_WORD *)(a1 + 264) |= 0x400u;
    }
    if (!*(_DWORD *)(a2 + 48) && v14 && (*(_WORD *)(a1 + 264) & 1) != 0 && *(unsigned char *)(a2 + 61) == 16)
    {
      *(unsigned char *)(a2 + 264) |= 1u;
      int v14 = *(_DWORD *)(a1 + 364);
    }
    *(_DWORD *)(a1 + 364) = v14 + 1;
    sub_10004BE1C(a2);
    return 0;
  }
  else
  {
    if (dword_10008FA20)
    {
      uint64_t v16 = ne_log_obj();
      if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR)) {
        sub_10006B174(v16, v17, v18, v19, v20, v21, v22, v23);
      }
    }
    return 0xFFFFFFFFLL;
  }
}

uint64_t sub_10004C148(uint64_t a1, void *a2)
{
  if (!a2)
  {
    if (dword_10008FA20)
    {
      uint64_t v13 = ne_log_obj();
      if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR)) {
        sub_10006B264(v13, v14, v15, v16, v17, v18, v19, v20);
      }
    }
    return 0xFFFFFFFFLL;
  }
  if (!a2[32])
  {
    if (a2[34] || !sub_10004C010(*(void *)(a1 + 440), (uint64_t)a2))
    {
      sub_10004C224(a1, a2);
      return 0;
    }
    return 0xFFFFFFFFLL;
  }
  if (dword_10008FA20)
  {
    BOOL v4 = ne_log_obj();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR)) {
      sub_10006B2DC(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  if (a2[32] == a1) {
    return 0;
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

void sub_10004C224(uint64_t a1, void *a2)
{
  if (a2[32]) {
    BOOL v4 = dword_10008FA20 == 0;
  }
  else {
    BOOL v4 = 1;
  }
  if (!v4)
  {
    uint64_t v5 = ne_log_obj();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR)) {
      sub_10006B354(v5, v6, v7, v8, v9, v10, v11, v12);
    }
  }
  a2[32] = a1;
  uint64_t v13 = (void *)(a1 + 448);
  uint64_t v14 = *(void *)(a1 + 448);
  a2[39] = v14;
  if (v14) {
    *(void *)(v14 + 320) = a2 + 39;
  }
  *uint64_t v13 = a2;
  a2[40] = v13;
}

uint64_t sub_10004C2B0(uint64_t a1)
{
  if (!a1)
  {
    if (dword_10008FA20)
    {
      uint64_t v7 = ne_log_obj();
      if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR)) {
        sub_10006B3CC(v7, v8, v9, v10, v11, v12, v13, v14);
      }
    }
    return 0;
  }
  uint64_t v2 = *(void *)(a1 + 440);
  if (!v2)
  {
    if (dword_10008FA20)
    {
      uint64_t v15 = ne_log_obj();
      if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
      {
        int v20 = 136315138;
        uint64_t v21 = "ike_session_update_ph1_ph2tree";
        _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "invalid parent session in %s.\n", (uint8_t *)&v20, 0xCu);
      }
    }
    return 0;
  }
  uint64_t v3 = *(void *)(v2 + 1696);
  if (!v3)
  {
LABEL_7:
    if (dword_10008FA20)
    {
      BOOL v4 = ne_log_obj();
      if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(v20) = 0;
        _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "no ph1bind replacement found. NULL ph1.\n", (uint8_t *)&v20, 2u);
      }
    }
    uint64_t v5 = *(void **)(a1 + 448);
    if (v5)
    {
      do
      {
        uint64_t v6 = (void *)v5[39];
        if (v5[32])
        {
          char v5[32] = 0;
          if (v6) {
            v6[40] = v5[40];
          }
          *(void *)v5[40] = v6;
        }
        uint64_t v5 = v6;
      }
      while (v6);
    }
    return 0;
  }
  while ((*(unsigned char *)(v3 + 432) & 2) != 0 || (*(unsigned char *)(v3 + 17) & 0x20) == 0)
  {
    uint64_t v3 = *(void *)(v3 + 456);
    if (!v3) {
      goto LABEL_7;
    }
  }
  if (v3 == a1)
  {
    if (dword_10008FA20)
    {
      uint64_t v17 = ne_log_obj();
      if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(v20) = 0;
        _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "no ph1bind replacement found. same ph1.\n", (uint8_t *)&v20, 2u);
      }
    }
    uint64_t v18 = *(void **)(a1 + 448);
    if (v18)
    {
      do
      {
        uint64_t v19 = (void *)v18[39];
        if (v18[32])
        {
          v18[32] = 0;
          if (v19) {
            v19[40] = v18[40];
          }
          *(void *)v18[40] = v19;
        }
        uint64_t v18 = v19;
      }
      while (v19);
    }
    return a1;
  }
  else
  {
    sub_10004C6C0(a1, v3);
  }
  return v3;
}

void sub_10004C4EC(unsigned int *a1)
{
  if (a1)
  {
    uint64_t v2 = a1[95];
    if (v2)
    {
      sub_10003AC14(v2);
      a1[95] = 0;
    }
    uint64_t v3 = a1[96];
    if (v3)
    {
      sub_10003AC14(v3);
      a1[96] = 0;
    }
    uint64_t v4 = a1[423];
    if (v4)
    {
      sub_10003AC14(v4);
      a1[423] = 0;
    }
    if ((*((void *)a1 + 38) || a1[78]) && !*((void *)a1 + 42) && !a1[86]) {
      gettimeofday((timeval *)a1 + 21, 0);
    }
    if (dword_10008FA20)
    {
      uint64_t v5 = ne_log_obj();
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
      {
        int v7 = 136315138;
        uint64_t v8 = sub_10003CAE4((const sockaddr *)(a1 + 34));
        _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "Freeing IKE-Session to %s.\n", (uint8_t *)&v7, 0xCu);
      }
    }
    uint64_t v6 = *((void *)a1 + 214);
    if (v6) {
      *(void *)(v6 + 1720) = *((void *)a1 + 215);
    }
    **((void **)a1 + 215) = v6;
    free(a1);
  }
}

void *sub_10004C620(void *result)
{
  if (result[32])
  {
    result[32] = 0;
    uint64_t v1 = result[39];
    if (v1) {
      *(void *)(v1 + 320) = result[40];
    }
    *(void *)result[40] = v1;
  }
  return result;
}

uint64_t sub_10004C648(uint64_t a1)
{
  if (a1)
  {
    for (uint64_t result = *(void *)(a1 + 1696); result; uint64_t result = *(void *)(result + 456))
    {
      if ((*(unsigned char *)(result + 432) & 2) == 0 && (*(unsigned char *)(result + 17) & 0x20) != 0) {
        break;
      }
    }
  }
  else
  {
    if (dword_10008FA20)
    {
      uint64_t v2 = ne_log_obj();
      if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR)) {
        sub_10006B444(v2, v3, v4, v5, v6, v7, v8, v9);
      }
    }
    return 0;
  }
  return result;
}

void sub_10004C6C0(uint64_t a1, uint64_t a2)
{
  if (a1 == a2)
  {
    if (dword_10008FA20)
    {
      uint64_t v11 = ne_log_obj();
      if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR)) {
        sub_10006B4BC(v11, v12, v13, v14, v15, v16, v17, v18);
      }
    }
  }
  else if (*(void *)(a1 + 440) == *(void *)(a2 + 440))
  {
    uint64_t v19 = *(void *)(a1 + 448);
    while (v19)
    {
      uint64_t v20 = v19;
      uint64_t v19 = *(void *)(v19 + 312);
      if (*(void *)(v20 + 272) != *(void *)(a2 + 440) && dword_10008FA20 != 0)
      {
        uint64_t v22 = ne_log_obj();
        if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR)) {
          sub_10006B584(&v25, v26, v22);
        }
      }
      if (*(void *)(v20 + 256) == a2 && dword_10008FA20 != 0)
      {
        uint64_t v24 = ne_log_obj();
        if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR)) {
          sub_10006B534(buf, &v28, v24);
        }
      }
      sub_10004C904(a2, v20);
    }
  }
  else if (dword_10008FA20)
  {
    uint64_t v3 = ne_log_obj();
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR)) {
      sub_10006B5C4(v3, v4, v5, v6, v7, v8, v9, v10);
    }
  }
}

uint64_t sub_10004C85C(uint64_t a1)
{
  if (a1 && !*(_DWORD *)(a1 + 48))
  {
    uint64_t v12 = sub_10004C648(*(void *)(a1 + 272));
    uint64_t v10 = v12;
    if (v12)
    {
      uint64_t v13 = *(void *)(a1 + 256);
      if (!v13 || v12 == v13)
      {
        if (!v13) {
          sub_10004C224(v12, (void *)a1);
        }
      }
      else
      {
        sub_10004C904(v12, a1);
      }
    }
  }
  else
  {
    if (dword_10008FA20)
    {
      uint64_t v2 = ne_log_obj();
      if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR)) {
        sub_10006B63C(v2, v3, v4, v5, v6, v7, v8, v9);
      }
    }
    return 0;
  }
  return v10;
}

void sub_10004C904(uint64_t a1, uint64_t a2)
{
  if (*(void *)(a2 + 256))
  {
    *(void *)(a2 + 256) = 0;
    uint64_t v4 = *(void *)(a2 + 312);
    if (v4) {
      *(void *)(v4 + 320) = *(void *)(a2 + 320);
    }
    **(void **)(a2 + 320) = v4;
  }
  sub_10004C224(a1, (void *)a2);
  uint64_t v5 = *(void **)(a2 + 240);
  if (v5)
  {
    sub_10002DA30(v5);
    if ((*(unsigned char *)(a1 + 17) & 0x20) != 0)
    {
      *(void *)(a2 + 240) = sub_10002DAA8(a1, *(_DWORD *)(a2 + 108));
      if (dword_10008FA20)
      {
        uint64_t v6 = ne_log_obj();
        if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)uint64_t v7 = 0;
          _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "Phase 1-2 binding changed... recalculated ivm.\n", v7, 2u);
        }
      }
    }
    else
    {
      *(void *)(a2 + 240) = 0;
    }
  }
}

uint64_t sub_10004C9D8(uint64_t a1)
{
  if (!a1)
  {
    if (dword_10008FA20)
    {
      uint64_t v4 = ne_log_obj();
      if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR)) {
        sub_10006B6B4(v4, v5, v6, v7, v8, v9, v10, v11);
      }
    }
    return 0;
  }
  uint64_t v1 = *(void *)(a1 + 1696);
  if (!v1) {
    return 0;
  }
  uint64_t result = 0;
  do
  {
    if ((*(unsigned char *)(v1 + 432) & 2) == 0)
    {
      int v3 = *(_DWORD *)(v1 + 16);
      if ((v3 & 0x3000) != 0 && (!result || v3 > *(_DWORD *)(result + 16))) {
        uint64_t result = v1;
      }
    }
    uint64_t v1 = *(void *)(v1 + 456);
  }
  while (v1);
  return result;
}

uint64_t sub_10004CA6C(uint64_t result, uint64_t a2)
{
  if (result)
  {
    uint64_t v2 = *(void *)(result + 1696);
    if (v2)
    {
      while (v2 == a2 || (*(unsigned char *)(v2 + 432) & 2) != 0 || (*(unsigned char *)(v2 + 17) & 0x20) == 0 || !*(_DWORD *)(v2 + 116))
      {
        uint64_t v2 = *(void *)(v2 + 456);
        if (!v2) {
          return 0;
        }
      }
      return 1;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

BOOL sub_10004CAB0(uint64_t a1, uint64_t a2)
{
  if (!a1)
  {
    if (dword_10008FA20)
    {
      int v3 = ne_log_obj();
      BOOL result = os_log_type_enabled(v3, OS_LOG_TYPE_ERROR);
      if (!result) {
        return result;
      }
      sub_10006B72C(v3, v5, v6, v7, v8, v9, v10, v11);
    }
    return 0;
  }
  uint64_t v2 = *(void *)(a1 + 1696);
  if (!v2) {
    return 0;
  }
  while (v2 == a2 || (*(unsigned char *)(v2 + 432) & 2) != 0 || (*(unsigned char *)(v2 + 17) & 0x10) == 0)
  {
    uint64_t v2 = *(void *)(v2 + 456);
    if (!v2) {
      return 0;
    }
  }
  return 1;
}

BOOL sub_10004CB34(uint64_t a1, uint64_t a2)
{
  if (!a1)
  {
    if (dword_10008FA20)
    {
      int v3 = ne_log_obj();
      BOOL result = os_log_type_enabled(v3, OS_LOG_TYPE_ERROR);
      if (!result) {
        return result;
      }
      sub_10006B7A4(v3, v5, v6, v7, v8, v9, v10, v11);
    }
    return 0;
  }
  uint64_t v2 = *(void *)(a1 + 1704);
  if (!v2) {
    return 0;
  }
  while (v2 == a2
       || *(_DWORD *)(v2 + 48)
       || (*(unsigned char *)(v2 + 264) & 2) != 0
       || *(_DWORD *)(a2 + 52) != *(_DWORD *)(v2 + 52)
       || (*(unsigned char *)(v2 + 57) & 0x20) == 0)
  {
    uint64_t v2 = *(void *)(v2 + 296);
    if (!v2) {
      return 0;
    }
  }
  return 1;
}

BOOL sub_10004CBD0(uint64_t a1, uint64_t a2)
{
  if (!a1)
  {
    if (dword_10008FA20)
    {
      uint64_t v7 = ne_log_obj();
      BOOL result = os_log_type_enabled(v7, OS_LOG_TYPE_ERROR);
      if (!result) {
        return result;
      }
      sub_10006B81C(v7, v9, v10, v11, v12, v13, v14, v15);
    }
    return 0;
  }
  uint64_t v2 = *(void *)(a1 + 1704);
  if (!v2) {
    return 0;
  }
  while (1)
  {
    if (dword_10008FA20)
    {
      uint64_t v4 = ne_log_obj();
      if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
      {
        int v5 = *(_DWORD *)(a2 + 52);
        int v6 = *(_DWORD *)(v2 + 52);
        *(_DWORD *)uint8_t buf = 136315650;
        uint64_t v17 = "ike_session_has_other_negoing_ph2";
        __int16 v18 = 1024;
        int v19 = v5;
        __int16 v20 = 1024;
        int v21 = v6;
        _os_log_debug_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEBUG, "%s: ph2 sub spid %d, db spid %d\n", buf, 0x18u);
      }
    }
    if (v2 != a2
      && !*(_DWORD *)(v2 + 48)
      && (*(unsigned char *)(v2 + 264) & 2) == 0
      && *(_DWORD *)(a2 + 52) == *(_DWORD *)(v2 + 52)
      && (*(unsigned char *)(v2 + 57) & 0x10) != 0)
    {
      break;
    }
    uint64_t v2 = *(void *)(v2 + 296);
    if (!v2) {
      return 0;
    }
  }
  return 1;
}

void sub_10004CD4C(uint64_t *a1)
{
  uint64_t v1 = a1[55];
  if (v1)
  {
    uint64_t v3 = v1 + 8;
    uint64_t v4 = v1 + 136;
    unsigned int v5 = sub_10003D80C(a1[7]);
    sub_10003D910(v3, v5);
    unsigned int v6 = sub_10003D80C(a1[6]);
    sub_10003D910(v4, v6);
    *(_WORD *)(a1[55] + 264) |= 2u;
    for (int i = *(uint64_t **)(a1[55] + 1704); i; int i = (uint64_t *)i[37])
    {
      uint64_t v8 = *i;
      uint64_t v9 = i[1];
      unsigned int v10 = sub_10003D80C(a1[7]);
      sub_10003D910(v8, v10);
      unsigned int v11 = sub_10003D80C(a1[6]);
      sub_10003D910(v9, v11);
    }
  }
  else if (dword_10008FA20)
  {
    uint64_t v12 = ne_log_obj();
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      int v13 = 136315138;
      uint64_t v14 = "ike_session_ikev1_float_ports";
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "invalid parent session in %s.\n", (uint8_t *)&v13, 0xCu);
    }
  }
}

void sub_10004CE94(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 272);
  if (!v2 || *(_DWORD *)(a1 + 48))
  {
    if (dword_10008FA20)
    {
      uint64_t v3 = ne_log_obj();
      if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR)) {
        sub_10006B894(v3, v4, v5, v6, v7, v8, v9, v10);
      }
    }
    return;
  }
  if (*(_DWORD *)(v2 + 1692))
  {
    sub_10003AC14(*(unsigned int *)(v2 + 1692));
    uint64_t v2 = *(void *)(a1 + 272);
    *(_DWORD *)(v2 + 1692) = 0;
  }
  if (*(_WORD *)(v2 + 264))
  {
    if ((*(unsigned char *)(v2 + 280) & 4) == 0) {
      goto LABEL_13;
    }
  }
  else
  {
    gettimeofday((timeval *)(v2 + 320), 0);
    *(_WORD *)(*(void *)(a1 + 272) + 264) |= 1u;
    uint64_t v2 = *(void *)(a1 + 272);
  }
  sub_10004D048((int *)v2);
LABEL_13:
  *(unsigned char *)(*(void *)(a1 + 272) + 280) &= ~4u;
  *(void *)(*(void *)(a1 + 272) + 296) = 0;
  sub_10004BE1C(a1);
  if (*(unsigned char *)(a1 + 61) == 16 && *(void *)(a1 + 256))
  {
    *(void *)(a1 + 256) = 0;
    uint64_t v11 = *(void *)(a1 + 312);
    if (v11) {
      *(void *)(v11 + 320) = *(void *)(a1 + 320);
    }
    **(void **)(a1 + 320) = v11;
  }
  sub_100049C54(1, a1);
  if (dword_10008FA20)
  {
    uint64_t v12 = ne_log_obj();
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      int v13 = *(_DWORD *)(a1 + 52);
      int v14 = 136315394;
      uint64_t v15 = "ike_session_ph2_established";
      __int16 v16 = 1024;
      int v17 = v13;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "%s: ph2 established, spid %d\n", (uint8_t *)&v14, 0x12u);
    }
  }
}

uint64_t sub_10004D048(int *a1)
{
  uint64_t v2 = a1[92];
  if (v2) {
    a1[95] = sub_10003AA24(v2, (uint64_t)sub_10004F6D4, (uint64_t)a1);
  }
  uint64_t result = a1[93];
  if (result)
  {
    uint64_t result = (uint64_t)sub_10003AA24(result, (uint64_t)sub_10004F88C, (uint64_t)a1);
    a1[96] = result;
  }
  return result;
}

void *sub_10004D0B0(uint64_t a1)
{
  int v2 = *(_DWORD *)(a1 + 16);
  if ((v2 & 0x4000) != 0)
  {
    uint64_t result = sub_10003AA24(1, (uint64_t)sub_1000248EC, a1);
    *(_DWORD *)(a1 + ++*(_DWORD *)(result + 112) = result;
  }
  else
  {
    if ((v2 & 0x2000) != 0) {
      sub_10001A098(a1);
    }
    return sub_100022854(a1);
  }
  return result;
}

void sub_10004D128(uint64_t a1, uint64_t a2)
{
  if (a1)
  {
    if (a2)
    {
      uint64_t v4 = *(void *)(a1 + 440);
      if (v4)
      {
        if (a1 != a2 && v4 == *(void *)(a2 + 440))
        {
          if ((*(_WORD *)(v4 + 264) & 0x400) != 0 && *(_DWORD *)(a1 + 20) == 1) {
            return;
          }
          uint64_t v5 = *(unsigned int *)(a2 + 112);
          if (v5)
          {
            sub_10003AC14(v5);
            *(_DWORD *)(a2 + ++*(_DWORD *)(result + 112) = 0;
          }
          uint64_t v6 = *(unsigned int *)(a2 + 116);
          if (v6)
          {
            sub_10003AC14(v6);
            *(_DWORD *)(a2 + 116) = 0;
          }
          *(unsigned char *)(a2 + 432) |= 2u;
          uint64_t v7 = sub_10003CAE4(*(const sockaddr **)(a2 + 56));
          uint64_t v8 = strdup((const char *)v7);
          uint64_t v9 = sub_10003CAE4(*(const sockaddr **)(a2 + 48));
          uint64_t v10 = strdup((const char *)v9);
          uint64_t v11 = sub_100023BEC(a2, 0);
          uint64_t v12 = strdup((const char *)v11);
          if (v8)
          {
            if (v10)
            {
              int v13 = v12;
              if (v12)
              {
                if (dword_10008FA20)
                {
                  int v14 = ne_log_obj();
                  if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
                  {
                    int v27 = 136315906;
                    uint64_t v28 = v8;
                    __int16 v29 = 2080;
                    int v30 = v10;
                    __int16 v31 = 2080;
                    uint64_t v32 = v13;
                    __int16 v33 = 2080;
                    uint64_t v34 = sub_100023BEC(a1, 0);
                    _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "ISAKMP-SA %s-%s (spi:%s) needs to be deleted, replaced by (spi:%s)\n", (uint8_t *)&v27, 0x2Au);
                  }
                }
                free(v8);
                free(v10);
                free(v13);
                sub_10004C6C0(a2, a1);
                if (*(_DWORD *)(a2 + 20)) {
                  uint64_t v15 = 7;
                }
                else {
                  uint64_t v15 = 5;
                }
                *(_DWORD *)(a2 + ++*(_DWORD *)(result + 112) = sub_10003AA24(v15, (uint64_t)sub_10004D124, a2);
                return;
              }
              if (dword_10008FA20)
              {
                __int16 v26 = ne_log_obj();
                if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR)) {
                  goto LABEL_34;
                }
              }
LABEL_35:
              exit(1);
            }
            if (!dword_10008FA20) {
              goto LABEL_35;
            }
            uint8_t v25 = ne_log_obj();
            if (!os_log_type_enabled(v25, OS_LOG_TYPE_ERROR)) {
              goto LABEL_35;
            }
          }
          else
          {
            if (!dword_10008FA20) {
              goto LABEL_35;
            }
            uint64_t v24 = ne_log_obj();
            if (!os_log_type_enabled(v24, OS_LOG_TYPE_ERROR)) {
              goto LABEL_35;
            }
          }
LABEL_34:
          sub_10005ED40();
          goto LABEL_35;
        }
      }
    }
  }
  if (dword_10008FA20)
  {
    __int16 v16 = ne_log_obj();
    if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR)) {
      sub_10006B90C(v16, v17, v18, v19, v20, v21, v22, v23);
    }
  }
}

void sub_10004D3C4(uint64_t a1, uint64_t a2)
{
  if (a1 && a2 && *(void *)(a2 + 440) == a1)
  {
    if ((*(_WORD *)(a1 + 264) & 0x400) == 0 || *(_DWORD *)(a2 + 20) != 1)
    {
      uint64_t v11 = *(void *)(a1 + 1696);
      while (v11)
      {
        uint64_t v12 = v11;
        uint64_t v11 = *(void *)(v11 + 456);
        if (v12 != a2 && (*(unsigned char *)(v12 + 432) & 2) == 0)
        {
          uint64_t v13 = *(unsigned int *)(v12 + 112);
          if (v13)
          {
            sub_10003AC14(v13);
            *(_DWORD *)(v12 + ++*(_DWORD *)(result + 112) = 0;
          }
          uint64_t v14 = *(unsigned int *)(v12 + 116);
          if (v14)
          {
            sub_10003AC14(v14);
            *(_DWORD *)(v12 + 116) = 0;
          }
          *(unsigned char *)(v12 + 432) |= 2u;
          uint64_t v15 = sub_10003CAE4(*(const sockaddr **)(v12 + 56));
          __int16 v16 = strdup((const char *)v15);
          uint64_t v17 = sub_10003CAE4(*(const sockaddr **)(v12 + 48));
          uint64_t v18 = strdup((const char *)v17);
          if (!v16)
          {
            if (dword_10008FA20)
            {
              uint64_t v23 = ne_log_obj();
              if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR)) {
LABEL_33:
              }
                sub_10005ED40();
            }
LABEL_34:
            exit(1);
          }
          uint64_t v19 = v18;
          if (!v18)
          {
            if (dword_10008FA20)
            {
              uint64_t v24 = ne_log_obj();
              if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR)) {
                goto LABEL_33;
              }
            }
            goto LABEL_34;
          }
          if (dword_10008FA20)
          {
            uint64_t v20 = ne_log_obj();
            if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
            {
              uint64_t v21 = sub_100023BEC(v12, 0);
              *(_DWORD *)uint8_t buf = 136315650;
              __int16 v26 = v16;
              __int16 v27 = 2080;
              uint64_t v28 = v19;
              __int16 v29 = 2080;
              int v30 = v21;
              _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "ISAKMP-SA needs to be deleted %s-%s spi:%s\n", buf, 0x20u);
            }
          }
          free(v16);
          free(v19);
          sub_10004C6C0(v12, a2);
          if (*(_DWORD *)(v12 + 20)) {
            uint64_t v22 = 7;
          }
          else {
            uint64_t v22 = 5;
          }
          *(_DWORD *)(v12 + ++*(_DWORD *)(result + 112) = sub_10003AA24(v22, (uint64_t)sub_10004D124, v12);
        }
      }
    }
  }
  else if (dword_10008FA20)
  {
    uint64_t v3 = ne_log_obj();
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR)) {
      sub_10006B984(v3, v4, v5, v6, v7, v8, v9, v10);
    }
  }
}

uint64_t sub_10004D628(uint64_t result)
{
  if (!*(_DWORD *)(result + 48))
  {
    uint64_t v1 = result;
    if ((*(unsigned char *)(result + 57) & 0x40) == 0)
    {
      uint64_t v2 = *(unsigned int *)(result + 64);
      if (v2)
      {
        sub_10003AC14(v2);
        *(_DWORD *)(v1 + 64) = 0;
      }
      if (dword_10008FA20)
      {
        uint64_t v3 = ne_log_obj();
        if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR)) {
          sub_10006B9FC((int *)(v1 + 56), v1, v3);
        }
      }
      if ((*(unsigned char *)(v1 + 57) & 0x20) != 0)
      {
        sub_10001A600(v1);
        uint64_t v4 = *(void *)(v1 + 128);
        if (v4)
        {
          for (uint64_t i = *(void *)(v4 + 32); i; uint64_t i = *(void *)(i + 72))
          {
            if (*(_DWORD *)(i + 56))
            {
              int v6 = *(_DWORD *)(qword_10008F848 + 32);
              char v7 = sub_10002F070(*(_DWORD *)i);
              sub_100041398(v6, v7, 0, *(unsigned __int8 **)v1, *(unsigned __int8 **)(v1 + 8), *(_DWORD *)(i + 28));
            }
          }
        }
      }
      sub_100026AB8(v1);
      return sub_10004B62C((void *)v1);
    }
  }
  return result;
}

void sub_10004D720(uint64_t a1, uint64_t a2)
{
  if (a1 && a2 && *(void *)(a2 + 272) == a1 && !*(_DWORD *)(a2 + 48))
  {
    if ((*(_WORD *)(a1 + 264) & 0x400) == 0 || *(unsigned char *)(a2 + 60) != 1)
    {
      uint64_t v11 = *(void *)(a1 + 1704);
      while (v11)
      {
        uint64_t v12 = v11;
        uint64_t v11 = *(void *)(v11 + 296);
        if (v12 != a2 && *(_DWORD *)(v12 + 52) == *(_DWORD *)(a2 + 52))
        {
          char v13 = *(unsigned char *)(v12 + 264);
          if ((v13 & 2) == 0)
          {
            uint64_t v14 = *(unsigned int *)(v12 + 64);
            if (v14)
            {
              sub_10003AC14(v14);
              *(_DWORD *)(v12 + 64) = 0;
              char v13 = *(unsigned char *)(v12 + 264);
            }
            *(unsigned char *)(v12 + 264) = v13 | 2;
            if (dword_10008FA20)
            {
              uint64_t v15 = ne_log_obj();
              if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
              {
                __int16 v16 = sub_10002FBD8(*(const sockaddr **)v12, *(const sockaddr **)(v12 + 8), *(unsigned __int8 *)(v12 + 104), *(_DWORD *)(v12 + 52), 0);
                *(_DWORD *)uint8_t buf = 136315138;
                uint64_t v19 = v16;
                _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "IPsec-SA needs to be deleted: %s\n", buf, 0xCu);
              }
            }
            if (*(unsigned char *)(v12 + 60)) {
              uint64_t v17 = 5;
            }
            else {
              uint64_t v17 = 3;
            }
            *(_DWORD *)(v12 + 64) = sub_10003AA24(v17, (uint64_t)sub_10004D71C, v12);
          }
        }
      }
    }
  }
  else if (dword_10008FA20)
  {
    uint64_t v3 = ne_log_obj();
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR)) {
      sub_10006BAA0(v3, v4, v5, v6, v7, v8, v9, v10);
    }
  }
}

void sub_10004D8F4(uint64_t a1, uint64_t a2)
{
  if (a1)
  {
    if (*(void *)(a1 + 336) || *(_DWORD *)(a1 + 344))
    {
      if (dword_10008FA20)
      {
        uint64_t v3 = ne_log_obj();
        if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
        {
          int v13 = 136315138;
          uint64_t v14 = "ike_session_stopped_by_controller";
          _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "already stopped %s.\n", (uint8_t *)&v13, 0xCu);
        }
      }
    }
    else
    {
      *(_WORD *)(a1 + 264) |= 0x20u;
      gettimeofday((timeval *)(a1 + 336), 0);
      if (!*(void *)(a1 + 296)) {
        *(void *)(a1 + 296) = a2;
      }
    }
  }
  else if (dword_10008FA20)
  {
    uint64_t v4 = ne_log_obj();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR)) {
      sub_10006BB18(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
}

void sub_10004DA1C(unint64_t a1, int a2, uint64_t a3)
{
  if (a1)
  {
    uint64_t v3 = qword_1000906D0;
    while (v3)
    {
      while (1)
      {
        uint64_t v7 = v3;
        uint64_t v3 = *(void *)(v3 + 1712);
        unint64_t v8 = v7 + 136;
        if (a2) {
          break;
        }
        if (sub_10003B8E4(v8, a1)) {
          goto LABEL_5;
        }
LABEL_8:
        sub_10004D8F4(v7, a3);
        if (!v3) {
          return;
        }
      }
      if (!sub_10003BB04(v8, a1)) {
        goto LABEL_8;
      }
LABEL_5:
      ;
    }
  }
  else if (dword_10008FA20)
  {
    uint64_t v9 = ne_log_obj();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR)) {
      sub_10006BB90(v9, v10, v11, v12, v13, v14, v15, v16);
    }
  }
}

uint64_t sub_10004DAD4(uint64_t result)
{
  for (i = *(void *)(result + 1696); i; uint64_t result = sub_10004B710(v2))
  {
    uint64_t v2 = i;
    uint64_t i = *(void *)(i + 456);
    if (dword_10008FA20)
    {
      uint64_t v3 = ne_log_obj();
      if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)uint64_t v5 = 0;
        _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "deleteallph1 of given session: got a ph1 handler...\n", v5, 2u);
      }
    }
    int v4 = sub_100009F24(v2);
    sub_100049388(0xEu, 1u, v4, 0, 0);
  }
  return result;
}

void sub_10004DB98(uint64_t a1)
{
  if (a1 && (uint64_t v1 = *(void *)(a1 + 440)) != 0)
  {
    uint64_t v2 = *(void *)(v1 + 1704);
    if (v2)
    {
      do
      {
        uint64_t v3 = *(void *)(v2 + 296);
        char v4 = *(unsigned char *)(v2 + 264);
        if ((v4 & 2) == 0)
        {
          uint64_t v5 = *(unsigned int *)(v2 + 64);
          if (v5)
          {
            sub_10003AC14(v5);
            *(_DWORD *)(v2 + 64) = 0;
            char v4 = *(unsigned char *)(v2 + 264);
          }
          *(unsigned char *)(v2 + 264) = v4 | 2;
          if (dword_10008FA20)
          {
            uint64_t v6 = ne_log_obj();
            if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
            {
              uint64_t v7 = sub_10002FBD8(*(const sockaddr **)v2, *(const sockaddr **)(v2 + 8), *(unsigned __int8 *)(v2 + 104), *(_DWORD *)(v2 + 52), 0);
              *(_DWORD *)uint8_t buf = 136315138;
              uint64_t v17 = v7;
              _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "IPsec-SA needs to be purged: %s\n", buf, 0xCu);
            }
          }
          sub_10004D628(v2);
        }
        uint64_t v2 = v3;
      }
      while (v3);
    }
  }
  else if (dword_10008FA20)
  {
    unint64_t v8 = ne_log_obj();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR)) {
      sub_10006BC08(v8, v9, v10, v11, v12, v13, v14, v15);
    }
  }
}

void sub_10004DCF4(uint64_t *a1)
{
  uint64_t v1 = a1[34];
  if (v1)
  {
    uint64_t v3 = v1 + 136;
    uint64_t v4 = *a1;
    unsigned int v5 = sub_10003D80C(v1 + 8);
    sub_10003D910(v4, v5);
    uint64_t v6 = a1[1];
    unsigned int v7 = sub_10003D80C(v3);
    sub_10003D910(v6, v7);
  }
  else if (dword_10008FA20)
  {
    unint64_t v8 = ne_log_obj();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      int v9 = 136315138;
      uint64_t v10 = "ike_session_update_ph2_ports";
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "invalid parent session in %s.\n", (uint8_t *)&v9, 0xCu);
    }
  }
}

uint64_t sub_10004DE24(uint64_t a1, int a2, _DWORD *a3, uint64_t a4, uint64_t a5)
{
  if ((a2 - 1) > 1 || a1 == 0 || a3 == 0 || a4 == 0 || a5 == 0)
  {
    if (dword_10008FA20)
    {
      int v9 = ne_log_obj();
      uint64_t result = os_log_type_enabled(v9, OS_LOG_TYPE_ERROR);
      if (!result) {
        return result;
      }
      sub_10006BC80(v9, v11, v12, v13, v14, v15, v16, v17);
    }
    return 0;
  }
  *a3 = 0;
  uint64_t v18 = *(void *)(a1 + 1704);
  if (!v18) {
    return 0;
  }
  uint64_t result = 0;
  while (1)
  {
    uint64_t v19 = *(void *)(v18 + 128);
    if (v19)
    {
      uint64_t v20 = *(void *)(v19 + 32);
      if (v20) {
        break;
      }
    }
LABEL_31:
    uint64_t v18 = *(void *)(v18 + 296);
    if (!v18) {
      return result;
    }
  }
  while (1)
  {
    if (*(_DWORD *)(v20 + 56) && *(_DWORD *)v20 == 3)
    {
      if (!*a3) {
        *a3 = *(_DWORD *)(v18 + 100);
      }
      uint64_t v21 = a2 == 1 ? 24 : 28;
      *(_DWORD *)(a4 + 40 * (int)result) = *(_DWORD *)(v20 + v21);
      uint64_t result = (result + 1);
      if (result == a5) {
        return a5;
      }
    }
    uint64_t v20 = *(void *)(v20 + 72);
    if (!v20) {
      goto LABEL_31;
    }
  }
}

void sub_10004DF1C(uint64_t a1, int a2, void *__src, unsigned int a4)
{
  if ((a2 - 3) >= 0xFFFFFFFE && a1 != 0 && __src != 0)
  {
    if ((*(_WORD *)(a1 + 264) & 0x21) != 1 || *(void *)(a1 + 336) || *(_DWORD *)(a1 + 344))
    {
      if (dword_10008FA20)
      {
        uint64_t v15 = ne_log_obj();
        if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)uint8_t buf = 136315138;
          int v49 = "ike_session_update_traffic_idle_status";
          _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "dropping update on invalid session in %s.\n", buf, 0xCu);
        }
      }
      return;
    }
    if (a4)
    {
      uint64_t v19 = 0;
      int v20 = 0;
      unsigned int v46 = (void *)(a1 + 736);
      int v47 = (void *)(a1 + 1384);
      int v21 = 1;
      while (1)
      {
        if (a2 == 1)
        {
          uint64_t v22 = *(unsigned int *)(a1 + 392);
          if (v22)
          {
            uint64_t v23 = &__src[5 * v19];
            int v26 = *v23;
            uint64_t v24 = v23 + 4;
            int v25 = v26;
            __int16 v27 = v46;
            do
            {
              if (v25 == *((_DWORD *)v27 - 4))
              {
                if (*v24 != *v27) {
                  int v21 = 0;
                }
                int v20 = 1;
              }
              v27 += 5;
              --v22;
            }
            while (v22);
          }
        }
        else
        {
          uint64_t v28 = *(unsigned int *)(a1 + 1044);
          if (v28)
          {
            __int16 v29 = &__src[5 * v19];
            int v32 = *v29;
            int v30 = v29 + 4;
            int v31 = v32;
            __int16 v33 = v47;
            do
            {
              if (v31 == *((_DWORD *)v33 - 4))
              {
                if (*v30 != *v33) {
                  int v21 = 0;
                }
                int v20 = 1;
              }
              v33 += 5;
              --v28;
            }
            while (v28);
          }
        }
        if (v20 || !__src[5 * v19 + 2]) {
          goto LABEL_43;
        }
        if (!dword_10008FA20) {
          goto LABEL_42;
        }
        uint64_t v34 = ne_log_obj();
        int v21 = 0;
        if (os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT)) {
          break;
        }
LABEL_43:
        if (++v19 == a4) {
          goto LABEL_46;
        }
      }
      *(_DWORD *)uint8_t buf = 67109120;
      LODWORD(v49) = a2;
      _os_log_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_DEFAULT, "new SA: dir %d....\n", buf, 8u);
LABEL_42:
      int v21 = 0;
      goto LABEL_43;
    }
    int v21 = 1;
LABEL_46:
    size_t v35 = 40 * a4;
    if (a2 == 1)
    {
      *(_OWORD *)(a1 + 1008) = 0u;
      *(_OWORD *)(a1 + 1024) = 0u;
      *(_OWORD *)(a1 + 976) = 0u;
      *(_OWORD *)(a1 + 992) = 0u;
      *(_OWORD *)(a1 + 944) = 0u;
      *(_OWORD *)(a1 + 960) = 0u;
      *(_OWORD *)(a1 + 912) = 0u;
      *(_OWORD *)(a1 + 928) = 0u;
      *(_OWORD *)(a1 + 880) = 0u;
      *(_OWORD *)(a1 + 896) = 0u;
      *(_OWORD *)(a1 + 848) = 0u;
      *(_OWORD *)(a1 + 864) = 0u;
      *(_OWORD *)(a1 + 816) = 0u;
      *(_OWORD *)(a1 + 832) = 0u;
      *(_OWORD *)(a1 + 784) = 0u;
      *(_OWORD *)(a1 + 800) = 0u;
      *(_OWORD *)(a1 + 752) = 0u;
      *(_OWORD *)(a1 + 768) = 0u;
      *(_OWORD *)(a1 + 720) = 0u;
      *(_OWORD *)(a1 + 736) = 0u;
      memmove((void *)(a1 + 720), __src, v35);
      *(_DWORD *)(a1 + 392) = a4;
      if (!v21)
      {
        __int16 v36 = 192;
LABEL_51:
        *(_WORD *)(a1 + 264) |= v36;
        *(void *)(a1 + 272) = time(0);
      }
    }
    else
    {
      *(_OWORD *)(a1 + 1656) = 0u;
      *(_OWORD *)(a1 + 1672) = 0u;
      *(_OWORD *)(a1 + 1624) = 0u;
      *(_OWORD *)(a1 + 1640) = 0u;
      *(_OWORD *)(a1 + 1592) = 0u;
      *(_OWORD *)(a1 + 1608) = 0u;
      *(_OWORD *)(a1 + 1560) = 0u;
      *(_OWORD *)(a1 + 1576) = 0u;
      *(_OWORD *)(a1 + 1528) = 0u;
      *(_OWORD *)(a1 + 1544) = 0u;
      *(_OWORD *)(a1 + 1496) = 0u;
      *(_OWORD *)(a1 + 1512) = 0u;
      *(_OWORD *)(a1 + 1464) = 0u;
      *(_OWORD *)(a1 + 1480) = 0u;
      *(_OWORD *)(a1 + 1432) = 0u;
      *(_OWORD *)(a1 + 1448) = 0u;
      *(_OWORD *)(a1 + 1400) = 0u;
      *(_OWORD *)(a1 + 1416) = 0u;
      *(_OWORD *)(a1 + 1368) = 0u;
      *(_OWORD *)(a1 + 1384) = 0u;
      memmove((void *)(a1 + 1368), __src, v35);
      *(_DWORD *)(a1 + 1044) = a4;
      if (!v21)
      {
        __int16 v36 = 768;
        goto LABEL_51;
      }
    }
    unsigned int v37 = *(_DWORD *)(a1 + 376);
    if (v37 <= 1 && (*(_WORD *)(a1 + 264) & 0x80) != 0)
    {
      if (!dword_10008FA20) {
        goto LABEL_63;
      }
      __int16 v38 = ne_log_obj();
      if (!os_log_type_enabled(v38, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_63;
      }
      int v42 = *(_DWORD *)(a1 + 376);
      int v43 = *(_DWORD *)(a1 + 372);
      *(_DWORD *)uint8_t buf = 136315650;
      int v49 = "ike_session_monitor_idle";
      __int16 v50 = 1024;
      int v51 = v42;
      __int16 v52 = 1024;
      int v53 = v43;
      int v41 = "%s: restart idle-timeout because peer sent data. monitoring dir %d. idle timer %d s\n";
    }
    else
    {
      if ((v37 | 2) != 2 || (*(_WORD *)(a1 + 264) & 0x200) == 0) {
        return;
      }
      if (!dword_10008FA20) {
        goto LABEL_63;
      }
      __int16 v38 = ne_log_obj();
      if (!os_log_type_enabled(v38, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_63;
      }
      int v39 = *(_DWORD *)(a1 + 376);
      int v40 = *(_DWORD *)(a1 + 372);
      *(_DWORD *)uint8_t buf = 136315650;
      int v49 = "ike_session_monitor_idle";
      __int16 v50 = 1024;
      int v51 = v39;
      __int16 v52 = 1024;
      int v53 = v40;
      int v41 = "%s: restart idle-timeout because i sent data. monitoring dir %d. idle times %d s\n";
    }
    _os_log_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_DEFAULT, v41, buf, 0x18u);
LABEL_63:
    uint64_t v44 = *(unsigned int *)(a1 + 384);
    if (v44)
    {
      sub_10003AC14(v44);
      *(_DWORD *)(a1 + 384) = 0;
    }
    int v45 = *(_DWORD *)(a1 + 372);
    if (v45) {
      *(_DWORD *)(a1 + 384) = sub_10003AA24(v45, (uint64_t)sub_10004F88C, a1);
    }
    *(_WORD *)(a1 + 264) &= 0xFD7Fu;
    return;
  }
  if (dword_10008FA20)
  {
    uint64_t v6 = ne_log_obj();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR)) {
      sub_10006BCF8(v6, v7, v8, v9, v10, v11, v12, v13);
    }
  }
}

uint64_t sub_10004E3B0(uint64_t result, char *a2)
{
  if (result)
  {
    uint64_t v3 = result;
    LODWORD(v10) = 0;
    *(unsigned char *)(result + 280) |= 2u;
    sub_10004D8F4(result, (uint64_t)a2);
    uint64_t result = *(unsigned int *)(v3 + 384);
    if (result)
    {
      uint64_t result = sub_10003AC14(result);
      *(_DWORD *)(v3 + 384) = 0;
    }
    uint64_t v4 = *(void *)(v3 + 1704);
    if (v4)
    {
      do
      {
        uint64_t v5 = *(void *)(v4 + 296);
        if ((*(unsigned char *)(v4 + 57) & 0x20) != 0) {
          sub_10001A600(v4);
        }
        uint64_t result = (uint64_t)sub_100024ED0((void *)v4);
        uint64_t v4 = v5;
      }
      while (v5);
    }
    uint64_t v6 = *(void *)(v3 + 1696);
    if (v6)
    {
      do
      {
        if (*(_DWORD *)(v6 + 28)) {
          long long v10 = *(_OWORD *)(v6 + 28);
        }
        uint64_t v7 = *(void *)(v6 + 456);
        if ((*(unsigned char *)(v6 + 17) & 0x20) != 0) {
          sub_10001A098(v6);
        }
        uint64_t result = (uint64_t)sub_100022854(v6);
        uint64_t v6 = v7;
      }
      while (v7);
    }
    if (a2 && (*(_WORD *)(v3 + 264) & 4) != 0 && off_10008C4F0[0] != a2 && off_10008C4F8[0] != a2)
    {
      if (*(unsigned char *)(v3 + 137) == 2)
      {
        int v8 = *(_DWORD *)(v3 + 140);
      }
      else
      {
        if (v10) {
          nw_nat64_extract_v4();
        }
        int v8 = 0;
      }
      if (off_10008C508[0] == a2) {
        unsigned int v9 = 50003;
      }
      else {
        unsigned int v9 = 0xFFFF;
      }
      return sub_100049388(v9, 0, v8, 0, 0);
    }
  }
  return result;
}

BOOL sub_10004E538(uint64_t a1)
{
  if (!a1)
  {
    if (dword_10008FA20)
    {
      uint64_t v2 = ne_log_obj();
      BOOL result = os_log_type_enabled(v2, OS_LOG_TYPE_ERROR);
      if (!result) {
        return result;
      }
      sub_10006BD70(v2, v4, v5, v6, v7, v8, v9, v10);
    }
    return 0;
  }
  uint64_t v1 = *(void *)(a1 + 1696);
  if (!v1) {
    return 0;
  }
  while ((*(unsigned char *)(v1 + 432) & 2) != 0 || (*(unsigned char *)(v1 + 17) & 0x10) == 0)
  {
    uint64_t v1 = *(void *)(v1 + 456);
    if (!v1) {
      return 0;
    }
  }
  return 1;
}

BOOL sub_10004E5B4(uint64_t a1)
{
  if (!a1)
  {
    if (dword_10008FA20)
    {
      uint64_t v2 = ne_log_obj();
      BOOL result = os_log_type_enabled(v2, OS_LOG_TYPE_ERROR);
      if (!result) {
        return result;
      }
      sub_10006BDE8(v2, v4, v5, v6, v7, v8, v9, v10);
    }
    return 0;
  }
  uint64_t v1 = *(void *)(a1 + 1696);
  if (!v1) {
    return 0;
  }
  while ((*(unsigned char *)(v1 + 432) & 2) != 0 || (*(unsigned char *)(v1 + 17) & 0x20) == 0)
  {
    uint64_t v1 = *(void *)(v1 + 456);
    if (!v1) {
      return 0;
    }
  }
  return 1;
}

BOOL sub_10004E630(uint64_t a1)
{
  if (!a1)
  {
    if (dword_10008FA20)
    {
      uint64_t v2 = ne_log_obj();
      BOOL result = os_log_type_enabled(v2, OS_LOG_TYPE_ERROR);
      if (!result) {
        return result;
      }
      sub_10006BE60(v2, v4, v5, v6, v7, v8, v9, v10);
    }
    return 0;
  }
  uint64_t v1 = *(void *)(a1 + 1704);
  if (!v1) {
    return 0;
  }
  while ((*(unsigned char *)(v1 + 264) & 2) != 0 || (*(unsigned char *)(v1 + 57) & 0x10) == 0)
  {
    uint64_t v1 = *(void *)(v1 + 296);
    if (!v1) {
      return 0;
    }
  }
  return 1;
}

BOOL sub_10004E6AC(uint64_t a1)
{
  if (!a1)
  {
    if (dword_10008FA20)
    {
      uint64_t v2 = ne_log_obj();
      BOOL result = os_log_type_enabled(v2, OS_LOG_TYPE_ERROR);
      if (!result) {
        return result;
      }
      sub_10006BED8(v2, v4, v5, v6, v7, v8, v9, v10);
    }
    return 0;
  }
  uint64_t v1 = *(void *)(a1 + 1704);
  if (!v1) {
    return 0;
  }
  while ((*(unsigned char *)(v1 + 264) & 2) != 0 || (*(unsigned char *)(v1 + 57) & 0x20) == 0)
  {
    uint64_t v1 = *(void *)(v1 + 296);
    if (!v1) {
      return 0;
    }
  }
  return 1;
}

void sub_10004E728(uint64_t a1)
{
  if (a1 && (uint64_t v1 = *(void *)(a1 + 272)) != 0)
  {
    uint64_t v2 = *(void *)(v1 + 1696);
    if (v2)
    {
      do
      {
        uint64_t v3 = *(void *)(v2 + 456);
        if ((*(unsigned char *)(v2 + 17) & 0x20) != 0) {
          sub_10001A098(v2);
        }
        sub_100022854(v2);
        uint64_t v2 = v3;
      }
      while (v3);
    }
  }
  else if (dword_10008FA20)
  {
    uint64_t v4 = ne_log_obj();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR)) {
      sub_10006BF50(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
}

BOOL sub_10004E7B0(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 272);
  BOOL result = 0;
  if (v1)
  {
    __int16 v2 = *(_WORD *)(v1 + 264);
    if (v2 & 0x400) != 0 && (v2 & 4) != 0 && (*(unsigned char *)(a1 + 264)) {
      return 1;
    }
  }
  return result;
}

BOOL sub_10004E7DC(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 440);
  BOOL result = 0;
  if (v1)
  {
    __int16 v2 = *(_WORD *)(v1 + 264);
    if (v2 & 0x400) != 0 && (v2 & 4) != 0 && (*(unsigned char *)(a1 + 432)) {
      return 1;
    }
  }
  return result;
}

BOOL sub_10004E808(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 440);
  return v1 && (*(_WORD *)(v1 + 264) & 0x400) != 0;
}

BOOL sub_10004E828(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 272);
  return v1 && (*(_WORD *)(v1 + 264) & 0x400) != 0;
}

void *sub_10004E848(void *result)
{
  uint64_t v1 = result[55];
  if (v1 && (~*(unsigned __int16 *)(v1 + 264) & 0x404) == 0 && !*(_DWORD *)(v1 + 1692))
  {
    __int16 v2 = result;
    BOOL result = sub_10003AA24(300, (uint64_t)sub_10004E8A8, v1);
    *(_DWORD *)(v2[55] + 1692) = result;
  }
  return result;
}

void *sub_10004E8A8(uint64_t a1)
{
  uint64_t v2 = *(unsigned int *)(a1 + 1692);
  if (v2)
  {
    sub_10003AC14(v2);
    *(_DWORD *)(a1 + 1692) = 0;
  }
  if (sub_10004E6AC(a1))
  {
    BOOL result = sub_10003AA24(300, (uint64_t)sub_10004E8A8, a1);
    *(_DWORD *)(a1 + 1692) = result;
  }
  else
  {
    uint64_t v4 = off_10008C510[0];
    return (void *)sub_10004E3B0(a1, v4);
  }
  return result;
}

uint64_t sub_10004E92C(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 440);
  if (v1)
  {
    uint64_t v2 = result;
    BOOL result = *(unsigned int *)(v1 + 1692);
    if (result)
    {
      BOOL result = sub_10003AC14(result);
      *(_DWORD *)(*(void *)(v2 + 440) + 1692) = 0;
    }
  }
  return result;
}

uint64_t sub_10004E968(void *a1, void *a2)
{
  uint64_t v4 = a1[24];
  if (v4)
  {
    uint64_t v5 = a2[24];
    if (v5)
    {
      if (*(void *)v4 == *(void *)v5 && !memcmp(*(const void **)(v4 + 8), *(const void **)(v5 + 8), *(void *)v4))
      {
        uint64_t v29 = a1[25];
        if (v29)
        {
          uint64_t v30 = a2[25];
          if (v30)
          {
            if (*(void *)v29 == *(void *)v30
              && !memcmp(*(const void **)(v29 + 8), *(const void **)(v30 + 8), *(void *)v29))
            {
              return 0;
            }
          }
        }
      }
    }
  }
  uint64_t v6 = a1[35];
  if (v6)
  {
    uint64_t v7 = a2[35];
    if (v7)
    {
      if (*(void *)v6 == *(void *)v7 && !memcmp(*(const void **)(v6 + 8), *(const void **)(v7 + 8), *(void *)v6))
      {
        uint64_t v31 = a1[36];
        if (v31)
        {
          uint64_t v32 = a2[36];
          if (v32)
          {
            if (*(void *)v31 == *(void *)v32
              && !memcmp(*(const void **)(v31 + 8), *(const void **)(v32 + 8), *(void *)v31))
            {
              return 0;
            }
          }
        }
      }
    }
  }
  uint64_t v8 = a2[35];
  if (v4)
  {
    if (v8)
    {
      if (*(void *)v4 == *(void *)v8 && !memcmp(*(const void **)(v4 + 8), *(const void **)(v8 + 8), *(void *)v4))
      {
        uint64_t v33 = a1[25];
        if (v33)
        {
          uint64_t v34 = a2[36];
          if (v34)
          {
            if (*(void *)v33 == *(void *)v34
              && !memcmp(*(const void **)(v33 + 8), *(const void **)(v34 + 8), *(void *)v33))
            {
              return 0;
            }
          }
        }
      }
      if (*(void *)v4 == *(void *)v8 && !memcmp(*(const void **)(v4 + 8), *(const void **)(v8 + 8), *(void *)v4))
      {
        uint64_t v35 = a1[25];
        if (v35)
        {
          uint64_t v36 = a2[25];
          if (v36)
          {
            if (*(void *)v35 == *(void *)v36
              && !memcmp(*(const void **)(v35 + 8), *(const void **)(v36 + 8), *(void *)v35))
            {
              return 0;
            }
          }
        }
      }
    }
    uint64_t v9 = a2[24];
    if (v9)
    {
      if (*(void *)v4 == *(void *)v9 && !memcmp(*(const void **)(v4 + 8), *(const void **)(v9 + 8), *(void *)v4))
      {
        uint64_t v37 = a1[25];
        if (v37)
        {
          uint64_t v38 = a2[36];
          if (v38)
          {
            if (*(void *)v37 == *(void *)v38
              && !memcmp(*(const void **)(v37 + 8), *(const void **)(v38 + 8), *(void *)v37))
            {
              return 0;
            }
          }
        }
      }
    }
  }
  if (!v8 || !sub_10004ED6C(v8))
  {
    uint64_t v10 = a2[36];
    if (!v10 || !sub_10004ED6C(v10)) {
      return 0xFFFFFFFFLL;
    }
  }
  uint64_t v11 = a1[24];
  if (v11)
  {
    uint64_t v12 = sub_10003FAC0(v11);
    uint64_t v13 = v12;
    if (v12)
    {
      size_t v14 = v12[1];
      if (*(unsigned char *)v14 == 1) {
        *(_WORD *)(v14 + 2) = 0;
      }
    }
  }
  else
  {
    uint64_t v13 = 0;
  }
  uint64_t v16 = a1[25];
  if (v16)
  {
    uint64_t v17 = sub_10003FAC0(v16);
    uint64_t v18 = v17;
    if (v17)
    {
      size_t v19 = v17[1];
      if (*(unsigned char *)v19 == 1) {
        *(_WORD *)(v19 + 2) = 0;
      }
    }
    if (!v13) {
      goto LABEL_45;
    }
LABEL_35:
    int v20 = (uint64_t *)a2[35];
    if (v20)
    {
      size_t v21 = *v13;
      uint64_t v22 = *v20;
      if (*v13 == *v20)
      {
        int v23 = memcmp((const void *)v13[1], (const void *)v20[1], *v13);
        if (v18)
        {
          if (!v23)
          {
            uint64_t v24 = a2[36];
            if (v24)
            {
              if (*v18 == *(void *)v24 && !memcmp((const void *)v18[1], *(const void **)(v24 + 8), *v18)) {
                goto LABEL_85;
              }
            }
          }
        }
      }
      int v25 = (void *)a1[24];
      if (v25)
      {
        if (*v25 == v22 && !memcmp((const void *)v13[1], (const void *)v20[1], v21))
        {
          uint64_t v41 = a1[25];
          if (v41)
          {
            uint64_t v42 = a2[25];
            if (v42)
            {
              if (*(void *)v41 == *(void *)v42
                && !memcmp(*(const void **)(v41 + 8), *(const void **)(v42 + 8), *(void *)v41))
              {
                sub_10003FA78(v13);
                uint64_t v15 = 0;
                if (!v18) {
                  return v15;
                }
                goto LABEL_53;
              }
            }
          }
        }
      }
    }
    goto LABEL_45;
  }
  uint64_t v18 = 0;
  if (v13) {
    goto LABEL_35;
  }
LABEL_45:
  if (v18)
  {
    uint64_t v26 = a1[24];
    if (v26)
    {
      uint64_t v27 = a2[24];
      if (v27)
      {
        if (*(void *)v26 == *(void *)v27
          && !memcmp(*(const void **)(v26 + 8), *(const void **)(v27 + 8), *(void *)v26))
        {
          int v39 = (void *)a1[25];
          if (v39)
          {
            uint64_t v40 = a2[36];
            if (v40)
            {
              if (*v39 == *(void *)v40 && !memcmp((const void *)v18[1], *(const void **)(v40 + 8), *v18))
              {
                if (!v13)
                {
LABEL_86:
                  uint64_t v15 = 0;
LABEL_53:
                  sub_10003FA78(v18);
                  return v15;
                }
LABEL_85:
                sub_10003FA78(v13);
                goto LABEL_86;
              }
            }
          }
        }
      }
    }
  }
  if (v13) {
    sub_10003FA78(v13);
  }
  uint64_t v15 = 0xFFFFFFFFLL;
  if (v18) {
    goto LABEL_53;
  }
  return v15;
}

BOOL sub_10004ED6C(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 8);
  if (*(unsigned char *)v1 == 1 && !*(_WORD *)(v1 + 2)) {
    return 1;
  }
  if (dword_10008FA20)
  {
    uint64_t v2 = ne_log_obj();
    BOOL result = os_log_type_enabled(v2, OS_LOG_TYPE_DEBUG);
    if (!result) {
      return result;
    }
    sub_10006BFC8((unsigned __int8 *)v1, v2);
  }
  return 0;
}

uint64_t sub_10004EDDC(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 272);
  if (!v1) {
    return 0xFFFFFFFFLL;
  }
  if ((*(_WORD *)(v1 + 264) & 0x400) == 0) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v3 = *(void *)(a1 + 192);
  if (!v3) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v4 = *(void *)(a1 + 200);
  if (!v4) {
    return 0xFFFFFFFFLL;
  }
  BOOL v5 = sub_10004EFF4(v3, v4);
  if (dword_10008FA20)
  {
    uint64_t v6 = ne_log_obj();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG)) {
      sub_10006C1A0();
    }
  }
  uint64_t v7 = *(void *)(*(void *)(a1 + 272) + 1704);
  if (!v7) {
    return 0xFFFFFFFFLL;
  }
  while (1)
  {
    if (v7 == a1 || (*(unsigned char *)(v7 + 264) & 2) != 0 || (*(unsigned char *)(v7 + 57) & 0x60) == 0 || !*(void *)(v7 + 112)) {
      goto LABEL_17;
    }
    if (dword_10008FA20)
    {
      uint64_t v8 = ne_log_obj();
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG)) {
        break;
      }
    }
    if (v5) {
      goto LABEL_20;
    }
LABEL_16:
    if (!sub_10004E968((void *)a1, (void *)v7)) {
      goto LABEL_20;
    }
LABEL_17:
    uint64_t v7 = *(void *)(v7 + 296);
    if (!v7) {
      return 0xFFFFFFFFLL;
    }
  }
  sub_10006C158(v17, &v18, v8);
  if (!v5) {
    goto LABEL_16;
  }
LABEL_20:
  if (dword_10008FA20)
  {
    uint64_t v9 = ne_log_obj();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG)) {
      sub_10006C0DC(v9, v10, v11);
    }
  }
  uint64_t v12 = *(void *)(v7 + 112);
  *(void *)(a1 + ++*(_DWORD *)(result + 112) = v12;
  if (v12) {
    sub_10003A7A8(v12);
  }
  if (*(_DWORD *)(a1 + 52))
  {
    if (dword_10008FA20)
    {
      uint64_t v13 = ne_log_obj();
      if (os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG)) {
        sub_10006C064();
      }
    }
  }
  else
  {
    *(_DWORD *)(a1 + 52) = *(_DWORD *)(v7 + 52);
  }
  uint64_t v15 = *(void *)(v7 + 280);
  if (v15)
  {
    if (*(void *)(a1 + 280))
    {
      sub_10003FA78(*(void **)(a1 + 280));
      uint64_t v15 = *(void *)(v7 + 280);
    }
    *(void *)(a1 + 280) = sub_10003FAC0(v15);
  }
  uint64_t result = *(void *)(v7 + 288);
  if (result)
  {
    if (*(void *)(a1 + 288))
    {
      sub_10003FA78(*(void **)(a1 + 288));
      uint64_t result = *(void *)(v7 + 288);
    }
    uint64_t v16 = sub_10003FAC0(result);
    uint64_t result = 0;
    *(void *)(a1 + ++*(_DWORD *)(result + 288) = v16;
  }
  return result;
}

BOOL sub_10004EFF4(uint64_t a1, uint64_t a2)
{
  return sub_10004FE30(a1) && sub_10004FE30(a2);
}

uint64_t sub_10004F034(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 272);
  if (!v1) {
    return 0xFFFFFFFFLL;
  }
  if ((*(_WORD *)(v1 + 264) & 0x400) == 0) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v3 = *(void *)(a1 + 192);
  if (!v3) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v4 = *(void *)(a1 + 200);
  if (!v4) {
    return 0xFFFFFFFFLL;
  }
  BOOL v5 = sub_10004EFF4(v3, v4);
  if (dword_10008FA20)
  {
    uint64_t v6 = ne_log_obj();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG)) {
      sub_10006C350();
    }
  }
  uint64_t v7 = *(void *)(*(void *)(a1 + 272) + 1704);
  if (!v7) {
    return 0xFFFFFFFFLL;
  }
  while (1)
  {
    if (v7 == a1 || (*(unsigned char *)(v7 + 264) & 2) != 0 || (*(unsigned char *)(v7 + 57) & 0x60) == 0 || !*(void *)(v7 + 128)) {
      goto LABEL_17;
    }
    if (dword_10008FA20)
    {
      uint64_t v8 = ne_log_obj();
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG)) {
        break;
      }
    }
    if (v5) {
      goto LABEL_20;
    }
LABEL_16:
    if (!sub_10004E968((void *)a1, (void *)v7)) {
      goto LABEL_20;
    }
LABEL_17:
    uint64_t v7 = *(void *)(v7 + 296);
    if (!v7) {
      return 0xFFFFFFFFLL;
    }
  }
  sub_10006C308(v17, &v18, v8);
  if (!v5) {
    goto LABEL_16;
  }
LABEL_20:
  if (dword_10008FA20)
  {
    uint64_t v9 = ne_log_obj();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG)) {
      sub_10006C28C(v9, v10, v11);
    }
  }
  uint64_t v12 = sub_100038218(*(void *)(v7 + 128), 1);
  int v14 = *(_DWORD *)(a1 + 52);
  uint64_t v13 = a1 + 52;
  *(void *)(v13 + 68) = v12;
  if (v14)
  {
    if (!dword_10008FA20) {
      return 0;
    }
    uint64_t v15 = ne_log_obj();
    uint64_t result = os_log_type_enabled(v15, OS_LOG_TYPE_DEBUG);
    if (result)
    {
      sub_10006C214();
      return 0;
    }
  }
  else
  {
    uint64_t result = 0;
    *(_DWORD *)uint64_t v13 = *(_DWORD *)(v7 + 52);
  }
  return result;
}

uint64_t sub_10004F200(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 440);
  if (v1)
  {
    uint64_t v2 = *(_DWORD **)(result + 88);
    if (v2) {
      LODWORD(v2) = *v2;
    }
    *(_DWORD *)(v1 + ++*(_DWORD *)(result + 288) = v2;
  }
  return result;
}

uint64_t sub_10004F21C(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 440);
  if (v1) {
    return *(unsigned int *)(v1 + 288);
  }
  else {
    return 0;
  }
}

uint64_t sub_10004F234(uint64_t a1, int a2)
{
  if (a1)
  {
    if ((*(_WORD *)(a1 + 264) & 0x10) != 0)
    {
      if (*(void *)(a1 + 272) && *(_DWORD *)(a1 + 368) && *(_DWORD *)(a1 + 372))
      {
        time_t v7 = time(0) - *(void *)(a1 + 272);
        time_t v8 = 2 * *(_DWORD *)(a1 + 368);
        if (v7 > v8)
        {
          if (dword_10008FA20)
          {
            uint64_t v9 = ne_log_obj();
            if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
            {
              v11[0] = 67109120;
              v11[1] = a2;
              _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "btmm session is idle: drop ph%drekey.\n", (uint8_t *)v11, 8u);
            }
          }
        }
        if (v7 > v8) {
          return 1;
        }
      }
    }
    else if (a2 == 1)
    {
      uint64_t v4 = *(void *)(a1 + 1704);
      if (v4)
      {
        uint64_t v5 = *(void *)(a1 + 1704);
        while ((*(unsigned char *)(v5 + 264) & 2) != 0 || (*(unsigned char *)(v5 + 57) & 0x10) == 0)
        {
          uint64_t v5 = *(void *)(v5 + 296);
          if (!v5)
          {
            while ((*(unsigned char *)(v4 + 264) & 2) != 0 || (*(unsigned char *)(v4 + 57) & 0x20) == 0)
            {
              uint64_t v4 = *(void *)(v4 + 296);
              if (!v4) {
                goto LABEL_12;
              }
            }
            return 0;
          }
        }
        return 0;
      }
LABEL_12:
      if (dword_10008FA20)
      {
        uint64_t v6 = ne_log_obj();
        if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
        {
          LOWORD(v11[0]) = 0;
          _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "vpn session is idle: drop ph1 rekey.\n", (uint8_t *)v11, 2u);
        }
      }
      return 1;
    }
  }
  return 0;
}

void sub_10004F3E0()
{
  uint64_t v0 = qword_1000906D0;
  while (v0)
  {
    uint64_t v1 = v0;
    uint64_t v0 = *(void *)(v0 + 1712);
    char v2 = *(unsigned char *)(v1 + 280);
    if ((v2 & 2) != 0)
    {
      if (!dword_10008FA20) {
        continue;
      }
      time_t v7 = ne_log_obj();
      if (!os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT)) {
        continue;
      }
      *(_WORD *)uint64_t v22 = 0;
      time_t v8 = v7;
      uint64_t v9 = "skipping sweep of dying session.\n";
      goto LABEL_24;
    }
    uint64_t v3 = *(unsigned int *)(v1 + 1692);
    if (v3)
    {
      sub_10003AC14(v3);
      *(_DWORD *)(v1 + 1692) = 0;
      char v2 = *(unsigned char *)(v1 + 280);
    }
    if ((v2 & 4) != 0)
    {
      uint64_t v10 = *(unsigned int *)(v1 + 380);
      if (v10)
      {
        sub_10003AC14(v10);
        *(_DWORD *)(v1 + 380) = 0;
      }
      uint64_t v11 = *(unsigned int *)(v1 + 384);
      if (v11)
      {
        sub_10003AC14(v11);
        *(_DWORD *)(v1 + 384) = 0;
      }
      if (!dword_10008FA20) {
        continue;
      }
      uint64_t v12 = ne_log_obj();
      if (!os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT)) {
        continue;
      }
      *(_WORD *)uint64_t v22 = 0;
      time_t v8 = v12;
      uint64_t v9 = "skipping sweep of asserted session.\n";
LABEL_24:
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, v9, v22, 2u);
      continue;
    }
    if ((*(_WORD *)(v1 + 264) & 0x20) != 0 || *(void *)(v1 + 336) || *(_DWORD *)(v1 + 344))
    {
      if (!dword_10008FA20) {
        goto LABEL_13;
      }
      uint64_t v4 = ne_log_obj();
      if (!os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_13;
      }
      *(_WORD *)uint64_t v22 = 0;
      uint64_t v5 = v4;
      uint64_t v6 = "sweeping stopped session.\n";
    }
    else
    {
      uint64_t v13 = *(void *)(v1 + 1696);
      if (v13)
      {
        while ((*(unsigned char *)(v13 + 432) & 2) != 0 || (*(unsigned char *)(v13 + 17) & 0x20) == 0)
        {
          uint64_t v13 = *(void *)(v13 + 456);
          if (!v13) {
            goto LABEL_31;
          }
        }
        goto LABEL_38;
      }
LABEL_31:
      uint64_t v14 = *(void *)(v1 + 1704);
      if (v14)
      {
        while ((*(unsigned char *)(v14 + 264) & 2) != 0 || (*(unsigned char *)(v14 + 57) & 0x20) == 0)
        {
          uint64_t v14 = *(void *)(v14 + 296);
          if (!v14) {
            goto LABEL_35;
          }
        }
LABEL_38:
        int v16 = *(_DWORD *)(v1 + 380);
        if (v16)
        {
          *(void *)uint64_t v22 = 0;
          if (sub_10003ABC4(v16, v22))
          {
            if (*(uint64_t *)v22 <= qword_1000906F0)
            {
              uint64_t v17 = *(unsigned int *)(v1 + 380);
              if (v17)
              {
                sub_10003AC14(v17);
                *(_DWORD *)(v1 + 380) = 0;
              }
              if ((*(unsigned char *)(v1 + 280) & 2) == 0)
              {
                uint64_t v18 = *(int *)(v1 + 368);
                if (v18) {
                  *(_DWORD *)(v1 + 380) = sub_10003AA24(v18, (uint64_t)sub_10004F6D4, v1);
                }
              }
            }
          }
        }
        int v19 = *(_DWORD *)(v1 + 384);
        if (v19)
        {
          *(void *)uint64_t v22 = 0;
          if (sub_10003ABC4(v19, v22))
          {
            if (*(uint64_t *)v22 <= qword_1000906F0)
            {
              uint64_t v20 = *(unsigned int *)(v1 + 384);
              if (v20)
              {
                sub_10003AC14(v20);
                *(_DWORD *)(v1 + 384) = 0;
              }
              if ((*(unsigned char *)(v1 + 280) & 2) == 0)
              {
                uint64_t v21 = *(int *)(v1 + 372);
                if (v21) {
                  *(_DWORD *)(v1 + 384) = sub_10003AA24(v21, (uint64_t)sub_10004F88C, v1);
                }
              }
            }
          }
        }
        continue;
      }
LABEL_35:
      if (!dword_10008FA20) {
        goto LABEL_13;
      }
      uint64_t v15 = ne_log_obj();
      if (!os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_13;
      }
      *(_WORD *)uint64_t v22 = 0;
      uint64_t v5 = v15;
      uint64_t v6 = "session died while sleeping.\n";
    }
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, v6, v22, 2u);
LABEL_13:
    sub_10004E3B0(v1, off_10008C518[0]);
  }
}

void sub_10004F6D4(uint64_t a1)
{
  if (a1 && (*(_WORD *)(a1 + 264) & 0x21) == 1 && !*(void *)(a1 + 336) && !*(_DWORD *)(a1 + 344))
  {
    uint64_t v10 = *(unsigned int *)(a1 + 380);
    if (v10)
    {
      sub_10003AC14(v10);
      *(_DWORD *)(a1 + 380) = 0;
    }
    if ((sub_100030AFC(a1) & 0x80000000) != 0)
    {
      if (dword_10008FA20)
      {
        uint64_t v11 = ne_log_obj();
        if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
        {
          int v13 = 136315138;
          uint64_t v14 = "ike_session_traffic_cop";
          _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "pk_sendget_inbound_sastats failed in %s.\n", (uint8_t *)&v13, 0xCu);
        }
      }
    }
    if ((sub_100030C18(a1) & 0x80000000) != 0)
    {
      if (dword_10008FA20)
      {
        uint64_t v12 = ne_log_obj();
        if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
        {
          int v13 = 136315138;
          uint64_t v14 = "ike_session_traffic_cop";
          _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "pk_sendget_outbound_sastats failed in %s.\n", (uint8_t *)&v13, 0xCu);
        }
      }
    }
    *(_DWORD *)(a1 + 380) = sub_10003AA24(*(int *)(a1 + 368), (uint64_t)sub_10004F6D4, a1);
  }
  else if (dword_10008FA20)
  {
    char v2 = ne_log_obj();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR)) {
      sub_10006C3C4(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
}

uint64_t sub_10004F88C(uint64_t a1)
{
  return sub_10004E3B0(a1, off_10008C508[0]);
}

uint64_t sub_10004F898(uint64_t a1)
{
  uint64_t v1 = &dword_10008FA20;
  if (!a1 || (*(unsigned char *)(a1 + 280) & 2) != 0)
  {
    if (dword_10008FA20)
    {
      uint64_t v30 = ne_log_obj();
      if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR)) {
        sub_10006C43C(v30, v31, v32, v33, v34, v35, v36, v37);
      }
    }
    return 0xFFFFFFFFLL;
  }
  else
  {
    uint64_t v2 = *(void *)(a1 + 1704);
    while (v2)
    {
      uint64_t v3 = v2;
      uint64_t v2 = *(void *)(v2 + 296);
      char v4 = *(unsigned char *)(v3 + 264);
      if ((v4 & 2) == 0)
      {
        int v5 = *(_DWORD *)(v3 + 56);
        if ((v5 & 0x4000) == 0)
        {
          uint64_t v6 = *(unsigned int *)(v3 + 64);
          if (v6)
          {
            sub_10003AC14(v6);
            *(_DWORD *)(v3 + 64) = 0;
            char v4 = *(unsigned char *)(v3 + 264);
            int v5 = *(_DWORD *)(v3 + 56);
          }
          *(unsigned char *)(v3 + 264) = v4 | 2;
          if ((v5 & 0x2000) != 0)
          {
            uint64_t v7 = *(void *)(v3 + 128);
            if (v7)
            {
              for (uint64_t i = *(void *)(v7 + 32); i; uint64_t i = *(void *)(i + 72))
              {
                if (*(_DWORD *)(i + 56))
                {
                  if (*v1)
                  {
                    uint64_t v9 = ne_log_obj();
                    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
                    {
                      uint64_t v10 = v1;
                      uint64_t v11 = *(const sockaddr **)v3;
                      uint64_t v12 = *(const sockaddr **)(v3 + 8);
                      uint64_t v13 = *(unsigned __int8 *)(v3 + 104);
                      unsigned int v14 = *(_DWORD *)(v3 + 52);
                      unsigned int v15 = sub_10002F160(*(_DWORD *)(i + 16));
                      int v16 = v12;
                      uint64_t v1 = v10;
                      uint64_t v17 = sub_10002FBD8(v11, v16, v13, v14, v15);
                      *(_DWORD *)uint8_t buf = 136315138;
                      uint64_t v40 = v17;
                      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "Assert: Phase 2 %s deleted\n", buf, 0xCu);
                    }
                  }
                  int v18 = *(_DWORD *)(qword_10008F848 + 32);
                  char v19 = sub_10002F070(*(_DWORD *)i);
                  uint64_t v20 = sub_10002F160(*(_DWORD *)(i + 16));
                  sub_100041398(v18, v19, v20, *(unsigned __int8 **)v3, *(unsigned __int8 **)(v3 + 8), *(_DWORD *)(i + 28));
                }
              }
            }
          }
          sub_100002728((int *)(v3 + 56), 18432);
          *(_DWORD *)(v3 + 64) = sub_10003AA24(3, (uint64_t)sub_10004D71C, v3);
        }
      }
    }
    uint64_t v21 = *(void *)(a1 + 1696);
    while (v21)
    {
      uint64_t v22 = v21;
      uint64_t v21 = *(void *)(v21 + 456);
      if ((*(unsigned char *)(v22 + 432) & 2) == 0 && (*(unsigned char *)(v22 + 17) & 0x40) == 0)
      {
        uint64_t v23 = *(unsigned int *)(v22 + 112);
        if (v23)
        {
          sub_10003AC14(v23);
          *(_DWORD *)(v22 + ++*(_DWORD *)(result + 112) = 0;
        }
        uint64_t v24 = *(unsigned int *)(v22 + 116);
        if (v24)
        {
          sub_10003AC14(v24);
          *(_DWORD *)(v22 + 116) = 0;
        }
        *(unsigned char *)(v22 + 432) |= 2u;
        if (*v1)
        {
          int v25 = ne_log_obj();
          if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v26 = sub_100023BEC(v22, 0);
            *(_DWORD *)uint8_t buf = 136315138;
            uint64_t v40 = v26;
            _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "Assert: Phase 1 %s deleted\n", buf, 0xCu);
          }
        }
        uint64_t v27 = *(void **)(v22 + 448);
        if (v27)
        {
          do
          {
            uint64_t v28 = (void *)v27[39];
            if (v27[32])
            {
              v27[32] = 0;
              if (v28) {
                v28[40] = v27[40];
              }
              *(void *)v27[40] = v28;
            }
            uint64_t v27 = v28;
          }
          while (v28);
        }
        sub_100002728((int *)(v22 + 16), 17408);
        *(_DWORD *)(v22 + ++*(_DWORD *)(result + 112) = sub_10003AA24(5, (uint64_t)sub_10004D124, v22);
      }
    }
    uint64_t result = 0;
    *(unsigned char *)(a1 + 280) |= 4u;
  }
  return result;
}

uint64_t sub_10004FBE8(uint64_t a1, uint64_t a2)
{
  if (!a1 || !a2)
  {
    if (dword_10008FA20)
    {
      char v4 = ne_log_obj();
      if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR)) {
        sub_10006C4B4(v4, v5, v6, v7, v8, v9, v10, v11);
      }
    }
    return 0xFFFFFFFFLL;
  }
  uint64_t v2 = sub_10004B7EC(a1, a2, 0, 0);
  if (!v2) {
    return 0xFFFFFFFFLL;
  }

  return sub_10004F898(v2);
}

void sub_10004FC6C(uint64_t a1)
{
  if ((*(unsigned char *)(a1 + 264) & 3) == 1)
  {
    uint64_t v2 = *(void *)(a1 + 256);
    if (v2)
    {
      int v3 = *(_DWORD *)(v2 + 116);
      if (v3)
      {
        if (!sub_10003AB80(v3) && !*(unsigned char *)(a1 + 60))
        {
          uint64_t v4 = *(void *)(a1 + 272);
          if (v4)
          {
            if ((*(_WORD *)(v4 + 264) & 0x404) == 0x400
              && *(_DWORD *)(*(void *)(*(void *)(a1 + 256) + 64) + 200) - *(_DWORD *)(a1 + 72) == 3)
            {
              if (dword_10008FA20)
              {
                uint64_t v5 = ne_log_obj();
                if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
                {
                  *(_WORD *)uint64_t v6 = 0;
                  _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "Many Phase 2 retransmits: try Phase 1 rekey and this Phase 2 to quit earlier.\n", v6, 2u);
                }
              }
              sub_1000248F0(*(void *)(a1 + 256), 1);
              *(_DWORD *)(a1 + 72) = 0;
            }
          }
        }
      }
    }
  }
}

void sub_10004FD58(uint64_t a1)
{
  if ((*(unsigned char *)(a1 + 432) & 3) == 1
    && !*(_DWORD *)(a1 + 116)
    && (*(unsigned char *)(a1 + 17) & 0x10) != 0
    && !*(_DWORD *)(a1 + 20))
  {
    uint64_t v2 = *(void *)(a1 + 440);
    if (v2)
    {
      if ((*(_WORD *)(v2 + 264) & 0x400) != 0
        && !sub_10004CAB0(v2, a1)
        && *(_DWORD *)(*(void *)(a1 + 64) + 200) - *(_DWORD *)(a1 + 124) == 3)
      {
        if (dword_10008FA20)
        {
          int v3 = ne_log_obj();
          if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)uint64_t v4 = 0;
            _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Many Phase 1 retransmits: try quit earlier.\n", v4, 2u);
          }
        }
        *(_DWORD *)(a1 + 124) = 0;
      }
    }
  }
}

BOOL sub_10004FE30(uint64_t a1)
{
  uint64_t v1 = *(unsigned __int8 **)(a1 + 8);
  int v2 = *v1;
  if (v2 == 4)
  {
    if (*((_DWORD *)v1 + 2)) {
      goto LABEL_6;
    }
  }
  else if (v2 != 1)
  {
    goto LABEL_6;
  }
  if (!*((_DWORD *)v1 + 1)) {
    return 1;
  }
LABEL_6:
  if (dword_10008FA20)
  {
    int v3 = ne_log_obj();
    BOOL result = os_log_type_enabled(v3, OS_LOG_TYPE_DEBUG);
    if (!result) {
      return result;
    }
    sub_10006C52C(v1, v3);
  }
  return 0;
}

void sub_10004FEB4(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint8_t *a5)
{
  _os_log_debug_impl(a1, a2, OS_LOG_TYPE_DEBUG, a4, a5, 0xCu);
}

uint64_t sub_10004FEE0()
{
  dword_1000906FC = IORegisterForSystemPower(0, (IONotificationPortRef *)&qword_100090708, (IOServiceInterestCallback)sub_10004FF80, dword_100090700);
  if (dword_1000906FC)
  {
    IONotificationPortSetDispatchQueue((IONotificationPortRef)qword_100090708, (dispatch_queue_t)&_dispatch_main_q);
    return 0;
  }
  else
  {
    if (dword_10008FA20)
    {
      uint64_t v1 = ne_log_obj();
      if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR)) {
        sub_10006C5D0();
      }
    }
    return 0xFFFFFFFFLL;
  }
}

void sub_10004FF80(int a1, int a2, int a3, intptr_t notificationID)
{
  HIDWORD(v5) = a3;
  LODWORD(v5) = a3 + 536870288;
  switch((v5 >> 4))
  {
    case 0u:
      goto LABEL_5;
    case 1u:
      byte_10008F284 = 1;
      *(void *)&xmmword_1000906E0 = sub_10003AB50();
      if (dword_10008FA20)
      {
        uint64_t v7 = ne_log_obj();
        if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG)) {
          sub_10006C688();
        }
      }
LABEL_5:
      IOAllowPowerChange(dword_1000906FC, notificationID);
      break;
    case 2u:
      if (dword_10008FA20)
      {
        uint64_t v8 = ne_log_obj();
        if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG)) {
          sub_10006C6BC();
        }
      }
      byte_10008F284 = 0;
      *(void *)&xmmword_1000906E0 = 0;
      break;
    case 9u:
      *((void *)&xmmword_1000906E0 + 1) = sub_10003AB50();
      if ((void)xmmword_1000906E0)
      {
        if (dword_10008FA20)
        {
          uint64_t v10 = ne_log_obj();
          if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG)) {
            sub_10006C78C();
          }
        }
      }
      else if (dword_10008FA20)
      {
        uint64_t v13 = ne_log_obj();
        if (os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG)) {
          sub_10006C758();
        }
      }
      break;
    case 0xBu:
      if (byte_10008F284 == 1)
      {
        if (dword_10008FA20)
        {
          uint64_t v11 = ne_log_obj();
          if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG)) {
            sub_10006C6F0();
          }
        }
        byte_10008F284 = 0;
      }
      else if (dword_10008FA20)
      {
        uint64_t v12 = ne_log_obj();
        if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG)) {
          sub_10006C724();
        }
      }
      break;
    default:
      if (dword_10008FA20)
      {
        uint64_t v9 = ne_log_obj();
        if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG)) {
          sub_10006C610(a3, v9);
        }
      }
      break;
  }
  dispatch_async_f((dispatch_queue_t)&_dispatch_main_q, &unk_1000906F8, (dispatch_function_t)sub_100050214);
}

void sub_1000501DC()
{
  IODeregisterForSystemPower(dword_100090700);
  uint64_t v0 = (IONotificationPort *)qword_100090708;

  IONotificationPortDestroy(v0);
}

void sub_100050214()
{
  if ((void)xmmword_1000906E0) {
    BOOL v0 = *((void *)&xmmword_1000906E0 + 1) == 0;
  }
  else {
    BOOL v0 = 1;
  }
  if (v0)
  {
    if (!*((void *)&xmmword_1000906E0 + 1)) {
      return;
    }
    if (dword_10008FA20)
    {
      uint64_t v1 = ne_log_obj();
      if (os_log_type_enabled(v1, OS_LOG_TYPE_DEBUG)) {
        sub_10006C7F4();
      }
    }
  }
  else
  {
    if (dword_10008FA20)
    {
      int v2 = ne_log_obj();
      if (os_log_type_enabled(v2, OS_LOG_TYPE_DEBUG)) {
        sub_10006C7C0();
      }
    }
    qword_1000906F0 = sub_10003AB50();
    sub_100009A5C();
    *(void *)&xmmword_1000906E0 = 0;
  }
  *((void *)&xmmword_1000906E0 + 1) = 0;
}

void sub_1000502D0()
{
  if (!qword_100090710)
  {
    BOOL v0 = SCPreferencesCreate(0, @"racoon", @"com.apple.ipsec.plist");
    qword_100090710 = (uint64_t)v0;
    if (v0)
    {
      if (SCPreferencesSetCallback(v0, (SCPreferencesCallBack)sub_100050350, &stru_10008F288))
      {
        if (!SCPreferencesSetDispatchQueue((SCPreferencesRef)qword_100090710, (dispatch_queue_t)&_dispatch_main_q)) {
          sub_10006C828();
        }
      }
    }
  }
}

void sub_100050350(uint64_t a1, char a2)
{
  if ((a2 & 2) != 0) {
    sub_100034408();
  }
}

CFDictionaryRef sub_10005035C(const __CFDictionary *result)
{
  if (result)
  {
    CFDictionaryRef v1 = result;
    int valuePtr = 0;
    BOOL result = (const __CFDictionary *)CFDictionaryGetValue(result, @"IKEVersion");
    if (result)
    {
      CFNumberGetValue(result, kCFNumberIntType, &valuePtr);
      if (valuePtr != 1) {
        return 0;
      }
      BOOL result = (const __CFDictionary *)CFDictionaryContainsKey(v1, @"ReparseConfFile");
      if (result)
      {
        BOOL result = (const __CFDictionary *)CFDictionaryGetValue(v1, @"ReparseConfFile");
        if (result)
        {
          BOOL result = (const __CFDictionary *)CFBooleanGetValue(result);
          if (result)
          {
            sub_100053A88(0x1Eu);
            *(void *)(qword_10008F848 + 80) = 17;
            if (!qword_10008F2B0) {
              qword_10008F2B0 = (uint64_t)CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
            }
            int v2 = dword_10008C530;
            int v3 = (dword_10008C530 + 1) > 1 ? dword_10008C530 + 1 : 1;
            dword_10008C530 = v3;
            unsigned int v8 = v2;
            BOOL result = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, &v8);
            if (result)
            {
              uint64_t v4 = result;
              CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, 0);
              if (Mutable)
              {
                CFMutableDictionaryRef v6 = Mutable;
                CFDictionaryAddValue((CFMutableDictionaryRef)qword_10008F2B0, v4, Mutable);
                CFRelease(v6);
                CFRelease(v4);
                return (const __CFDictionary *)v8;
              }
              CFRelease(v4);
              return 0;
            }
          }
        }
      }
    }
  }
  return result;
}

CFNumberRef sub_1000504D4(int a1)
{
  CFNumberRef result = 0;
  int valuePtr = a1;
  if (a1)
  {
    if (qword_10008F2B0)
    {
      CFNumberRef result = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, &valuePtr);
      if (result)
      {
        int v3 = result;
        if (CFDictionaryContainsKey((CFDictionaryRef)qword_10008F2B0, result)) {
          CFDictionaryRemoveValue((CFMutableDictionaryRef)qword_10008F2B0, v3);
        }
        CFRelease(v3);
        if (!qword_10008F2B0 || !CFDictionaryGetCount((CFDictionaryRef)qword_10008F2B0)) {
          sub_10003B3DC();
        }
        return (CFNumberRef)1;
      }
    }
  }
  return result;
}

uint64_t sub_100050570()
{
  uint64_t result = qword_10008F2B0;
  if (qword_10008F2B0) {
    return CFDictionaryGetCount((CFDictionaryRef)qword_10008F2B0) != 0;
  }
  return result;
}

void sub_10005059C()
{
  qword_100090718 = 0;
  qword_100090720 = (uint64_t)&qword_100090718;
  if (qword_10008F2B8 != -1) {
    dispatch_once(&qword_10008F2B8, &stru_10008AC90);
  }
  mach_service = xpc_connection_create_mach_service("com.apple.SecureNetworking.IPSec", (dispatch_queue_t)qword_10008F2C0, 1uLL);
  handler[0] = _NSConcreteStackBlock;
  handler[1] = 0x40000000;
  handler[2] = sub_100050668;
  handler[3] = &unk_10008AC50;
  void handler[4] = mach_service;
  xpc_connection_set_event_handler(mach_service, handler);
  xpc_connection_resume(mach_service);
}

void sub_100050668(uint64_t a1, xpc_object_t object)
{
  xpc_type_t type = xpc_get_type(object);
  if (type == (xpc_type_t)&_xpc_type_connection)
  {
    if (qword_10008F2B8 != -1) {
      dispatch_once(&qword_10008F2B8, &stru_10008AC90);
    }
    xpc_connection_set_target_queue((xpc_connection_t)object, (dispatch_queue_t)qword_10008F2C0);
    handler[0] = _NSConcreteStackBlock;
    handler[1] = 0x40000000;
    handler[2] = sub_100050930;
    handler[3] = &unk_10008ACB0;
    void handler[4] = object;
    xpc_connection_set_event_handler((xpc_connection_t)object, handler);
    xpc_connection_resume((xpc_connection_t)object);
  }
  else
  {
    int v5 = (int)type;
    if (type == (xpc_type_t)&_xpc_type_error)
    {
      if (dword_10008FA20)
      {
        uint64_t v7 = ne_log_obj();
        if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR)) {
          sub_10006C99C();
        }
      }
      string = xpc_dictionary_get_string(object, _xpc_error_key_description);
      if (object == &_xpc_error_connection_invalid)
      {
        if (dword_10008FA20)
        {
          uint64_t v10 = ne_log_obj();
          if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR)) {
            sub_10006C844();
          }
        }
        uint64_t v11 = &qword_100090718;
        do
          uint64_t v11 = (uint64_t *)*v11;
        while (v11 && v11[2] != *(void *)(a1 + 32));
        sub_1000508A0((xpc_object_t *)v11);
        xpc_release(*(xpc_object_t *)(a1 + 32));
      }
      else if (object == &_xpc_error_connection_interrupted)
      {
        if (dword_10008FA20)
        {
          uint64_t v12 = ne_log_obj();
          if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR)) {
            sub_10006C8AC();
          }
        }
      }
      else if (dword_10008FA20)
      {
        uint64_t v9 = ne_log_obj();
        if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR)) {
          sub_10006C914((int)object, (uint64_t)string, v9);
        }
      }
    }
    else if (dword_10008FA20)
    {
      CFMutableDictionaryRef v6 = ne_log_obj();
      if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR)) {
        sub_10006C9D0(v5, v6);
      }
    }
  }
}

void sub_1000508A0(xpc_object_t *a1)
{
  if (a1)
  {
    xpc_release(a1[2]);
    xpc_object_t v2 = *a1;
    int v3 = &qword_100090718;
    if (*a1) {
      int v3 = (uint64_t *)*a1;
    }
    v3[1] = (uint64_t)a1[1];
    *(void *)a1[1] = v2;
    free(a1);
  }
}

void sub_100050904(id a1)
{
  qword_10008F2C0 = (uint64_t)dispatch_queue_create("com.apple.SecureNetworking.IPSec.server", 0);
}

void sub_100050930(uint64_t a1, xpc_object_t object)
{
  xpc_type_t type = xpc_get_type(object);
  if (type != (xpc_type_t)&_xpc_type_dictionary)
  {
    if (type == (xpc_type_t)&_xpc_type_error)
    {
      xpc_dictionary_get_string(object, _xpc_error_key_description);
      if (dword_10008FA20)
      {
        unsigned int v14 = ne_log_obj();
        if (os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG)) {
          sub_10006CCB8();
        }
      }
      unsigned int v15 = &qword_100090718;
      do
        unsigned int v15 = (uint64_t *)*v15;
      while (v15 && v15[2] != *(void *)(a1 + 32));
      sub_1000508A0((xpc_object_t *)v15);
    }
    else if (dword_10008FA20)
    {
      int v5 = ne_log_obj();
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG)) {
        sub_10006CD2C();
      }
    }
    return;
  }
  int64_t int64 = xpc_dictionary_get_int64(object, "ipsecopcode");
  int64_t v7 = xpc_dictionary_get_int64(object, "ipsecobjectref");
  if (int64 == 5)
  {
    *(void *)token.val = 0;
    *(void *)&token.val[2] = &token;
    *(void *)&token.val[4] = 0x2000000000;
    LOBYTE(token.val[6]) = 0;
    uint64_t v52 = 0;
    int v53 = &v52;
    uint64_t v54 = 0x2000000000;
    LOBYTE(v55) = 0;
    int v16 = xpc_dictionary_get_int64(object, "ipsecikeid");
    int v17 = v16;
    if (v16)
    {
      *(void *)&long long v47 = _NSConcreteStackBlock;
      *((void *)&v47 + 1) = 0x40000000;
      *(void *)&long long v48 = sub_100051074;
      *((void *)&v48 + 1) = &unk_10008AD00;
      LODWORD(v51) = v16;
      p_audit_token_t token = &token;
      __int16 v50 = &v52;
      dispatch_sync((dispatch_queue_t)&_dispatch_main_q, &v47);
      int v18 = &qword_100090718;
      do
        int v18 = (uint64_t *)*v18;
      while (v18 && *((_DWORD *)v18 + 8) != v17);
      sub_1000508A0((xpc_object_t *)v18);
    }
    else if (dword_10008FA20)
    {
      uint64_t v21 = ne_log_obj();
      if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR)) {
        sub_10006CC84();
      }
    }
    int v22 = *(unsigned __int8 *)(*(void *)&token.val[2] + 24);
    xpc_connection_t remote_connection = xpc_dictionary_get_remote_connection(object);
    if (remote_connection)
    {
      uint64_t v24 = remote_connection;
      xpc_object_t reply = xpc_dictionary_create_reply(object);
      if (reply)
      {
        uint64_t v26 = reply;
        xpc_dictionary_set_int64(reply, "ipsecobjectref", v7);
        xpc_dictionary_set_int64(v26, "ipsecopcode", 4101);
        xpc_dictionary_set_BOOL(v26, "reply", v22 != 0);
        xpc_connection_send_message(v24, v26);
        xpc_release(v26);
      }
      else if (dword_10008FA20)
      {
        uint64_t v28 = ne_log_obj();
        if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR)) {
          sub_10006CC50();
        }
      }
    }
    else if (dword_10008FA20)
    {
      uint64_t v27 = ne_log_obj();
      if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR)) {
        sub_10006CC1C();
      }
    }
    _Block_object_dispose(&v52, 8);
    _Block_object_dispose(&token, 8);
  }
  else
  {
    if (int64 == 1)
    {
      uint64_t v52 = 0;
      int v53 = &v52;
      uint64_t v54 = 0x2000000000;
      int v55 = 0;
      long long v47 = 0u;
      long long v48 = 0u;
      xpc_dictionary_get_audit_token();
      memset(&token, 0, sizeof(token));
      unsigned int v8 = SecTaskCreateWithAuditToken(0, &token);
      if (!v8)
      {
        if (dword_10008FA20)
        {
          uint64_t v20 = ne_log_obj();
          if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR)) {
            sub_10006CAE4();
          }
        }
        goto LABEL_53;
      }
      uint64_t v9 = v8;
      CFBooleanRef v10 = (const __CFBoolean *)SecTaskCopyValueForEntitlement(v8, @"com.apple.private.SecureNetworking.ipsec_ike", 0);
      if (v10)
      {
        CFBooleanRef v11 = v10;
        CFTypeID v12 = CFGetTypeID(v10);
        if (v12 == CFBooleanGetTypeID())
        {
          BOOL v13 = CFBooleanGetValue(v11) != 0;
        }
        else
        {
          if (dword_10008FA20)
          {
            uint64_t v29 = ne_log_obj();
            if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR)) {
              sub_10006CBE8();
            }
          }
          BOOL v13 = 0;
        }
        CFRelease(v11);
      }
      else
      {
        BOOL v13 = 0;
      }
      CFRelease(v9);
      int v30 = dword_10008FA20;
      if (!v13 && dword_10008FA20)
      {
        uint64_t v31 = ne_log_obj();
        if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR)) {
          sub_10006CB18();
        }
LABEL_53:
        int v30 = dword_10008FA20;
LABEL_54:
        if (v30)
        {
          uint64_t v32 = ne_log_obj();
          if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR)) {
            sub_10006CAB0();
          }
        }
        goto LABEL_57;
      }
      if (!v13) {
        goto LABEL_54;
      }
      if (!xpc_dictionary_get_value(object, "ipsecikedict"))
      {
        if (!dword_10008FA20)
        {
LABEL_57:
          int64_t v33 = *((int *)v53 + 6);
          _Block_object_dispose(&v52, 8);
          xpc_connection_t v34 = xpc_dictionary_get_remote_connection(object);
          if (v34)
          {
            uint64_t v35 = v34;
            xpc_object_t v36 = xpc_dictionary_create_reply(object);
            if (v36)
            {
              uint64_t v37 = v36;
              xpc_dictionary_set_int64(v36, "ipsecikeid", v33);
              xpc_dictionary_set_int64(v37, "ipsecobjectref", v7);
              xpc_dictionary_set_int64(v37, "ipsecopcode", 4097);
              xpc_dictionary_set_BOOL(v37, "reply", v33 != 0);
              xpc_connection_send_message(v35, v37);
              xpc_release(v37);
            }
          }
          return;
        }
        unsigned int v46 = ne_log_obj();
        if (os_log_type_enabled(v46, OS_LOG_TYPE_ERROR)) {
          sub_10006CB4C();
        }
        goto LABEL_53;
      }
      uint64_t v38 = (uint64_t *)_CFXPCCreateCFObjectFromXPCObject();
      if (!v38)
      {
        if (dword_10008FA20)
        {
          int v39 = ne_log_obj();
          if (os_log_type_enabled(v39, OS_LOG_TYPE_ERROR)) {
            sub_10006CBB4();
          }
        }
      }
      if (xpc_dictionary_get_value(object, "ipsecchilddict"))
      {
        uint64_t v40 = (const void *)_CFXPCCreateCFObjectFromXPCObject();
        if (v40 || !dword_10008FA20) {
          goto LABEL_73;
        }
        uint64_t v41 = ne_log_obj();
        if (os_log_type_enabled(v41, OS_LOG_TYPE_ERROR)) {
          sub_10006CB80();
        }
      }
      uint64_t v40 = 0;
LABEL_73:
      *(void *)&long long v47 = _NSConcreteStackBlock;
      *((void *)&v47 + 1) = 0x40000000;
      *(void *)&long long v48 = sub_10005103C;
      *((void *)&v48 + 1) = &unk_10008ACD8;
      p_audit_token_t token = (audit_token_t *)&v52;
      __int16 v50 = v38;
      int v51 = v40;
      dispatch_sync((dispatch_queue_t)&_dispatch_main_q, &v47);
      if (*((_DWORD *)v53 + 6))
      {
        xpc_connection_t v42 = xpc_dictionary_get_remote_connection(object);
        if (v42)
        {
          xpc_connection_t v43 = v42;
          int v44 = *((_DWORD *)v53 + 6);
          int v45 = malloc_type_malloc(0x28uLL, 0x10A0040954427F6uLL);
          _OWORD v45[8] = v44;
          *((void *)v45 + 2) = v43;
          *((void *)v45 + 3) = v7;
          xpc_retain(v43);
          *(void *)int v45 = 0;
          *((void *)v45 + 1) = qword_100090720;
          *(void *)qword_100090720 = v45;
          qword_100090720 = (uint64_t)v45;
        }
      }
      if (v38) {
        CFRelease(v38);
      }
      if (v40) {
        CFRelease(v40);
      }
      goto LABEL_57;
    }
    if (dword_10008FA20)
    {
      char v19 = ne_log_obj();
      if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR)) {
        sub_10006CA48();
      }
    }
  }
}

CFDictionaryRef sub_10005103C(uint64_t a1)
{
  CFDictionaryRef result = sub_10005035C(*(const __CFDictionary **)(a1 + 40));
  *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  return result;
}

CFNumberRef sub_100051074(uint64_t a1)
{
  CFNumberRef result = sub_1000504D4(*(_DWORD *)(a1 + 48));
  *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = (_BYTE)result;
  return result;
}

uint64_t sub_1000510B4()
{
  int v0 = 0;
  CFDictionaryRef v1 = &byte_10008FE9C[356];
  dword_100090738 = 0;
  unsigned int __src = v193;
  dword_100090728 = -2;
  uint64_t v2 = 200;
  int v3 = v194;
  uint64_t v4 = v194;
  int v5 = (int *)v193;
  while (1)
  {
    *(_WORD *)uint64_t v4 = v0;
    if (&v3[2 * v2 - 2] <= v4)
    {
      if ((unint64_t)v2 >> 4 > 0x270
        || ((unint64_t)(2 * v2) >= 0x2710 ? (uint64_t v2 = 10000) : (v2 *= 2),
            (CFMutableDictionaryRef v6 = (char *)malloc_type_malloc(10 * v2 + 7, 0xE0D4DFE4uLL)) == 0))
      {
        uint64_t v157 = 2;
        goto LABEL_410;
      }
      int64_t v7 = v6;
      unsigned int v8 = v1;
      uint64_t v9 = (v4 - v3) >> 1;
      uint64_t v10 = v9 + 1;
      memcpy(v6, v3, 2 * (v9 + 1));
      memcpy(&v7[(2 * v2 + 7) & 0xFFFFFFFFFFFFFFF8], __src, 8 * (v9 + 1));
      if (v3 != v194) {
        free(v3);
      }
      if (v2 <= v10)
      {
        uint64_t v157 = 1;
LABEL_412:
        if (v7 != v194) {
          free(v7);
        }
        return v157;
      }
      uint64_t v4 = &v7[2 * v9];
      int v5 = (int *)&v7[8 * v10 - 8 + ((2 * v2 + 7) & 0xFFFFFFFFFFFFFFF8)];
      int v3 = v7;
      unsigned int __src = &v7[(2 * v2 + 7) & 0xFFFFFFFFFFFFFFF8];
      CFDictionaryRef v1 = v8;
    }
    int v11 = word_10006E8D0[v0];
    if (v11 == -454) {
      goto LABEL_27;
    }
    int v12 = *((_DWORD *)v1 + 458);
    if (v12 == -2)
    {
      int v12 = sub_100053B78();
      *((_DWORD *)v1 + 458) = v12;
    }
    if (v12 <= 0)
    {
      int v13 = 0;
      *((_DWORD *)v1 + 458) = 0;
    }
    else
    {
      int v13 = v12 > 0x1A6 ? 2 : byte_10006ED70[v12];
    }
    uint64_t v14 = (v13 + v11);
    if (v14 > 0x1DD || v13 != (__int16)word_10006EF18[v14])
    {
LABEL_27:
      unsigned int v15 = word_10006F690[v0];
      if (!word_10006F690[v0]) {
        goto LABEL_409;
      }
      goto LABEL_28;
    }
    int v0 = word_10006F2D4[v14];
    if (v0 <= 0) {
      break;
    }
    if (v14 == 46)
    {
      uint64_t v157 = 0;
      goto LABEL_411;
    }
    if (v12 >= 1) {
      *((_DWORD *)v1 + 458) = -2;
    }
    *((void *)v5 + 1) = qword_100090730;
    v5 += 2;
LABEL_293:
    v4 += 2;
  }
  if (!word_10006F2D4[v14])
  {
LABEL_409:
    ++dword_100090738;
    uint64_t v157 = 1;
LABEL_410:
    sub_10005668C();
LABEL_411:
    int64_t v7 = v3;
    goto LABEL_412;
  }
  unsigned int v15 = -v0;
LABEL_28:
  uint64_t v16 = byte_10006FB30[v15];
  uint64_t v17 = *(void *)&v5[2 * (1 - v16)];
  switch(v15)
  {
    case 0xFu:
      unint64_t v18 = *((void *)v5 - 1);
      if (v18 >= 5)
      {
        sub_100055C70("invalid path type %d");
        return 0xFFFFFFFFLL;
      }
      uint64_t v19 = qword_10008F848;
      uint64_t v20 = *(void **)(qword_10008F848 + 8 * v18 + 136);
      if (v20)
      {
        free(v20);
        uint64_t v19 = qword_10008F848;
        unint64_t v18 = *((void *)v5 - 1);
      }
      *(void *)(v19 + 8 * v18 + 136) = strdup(*(const char **)(*(void *)v5 + 8));
      if (*(void *)(qword_10008F848 + 8 * *((void *)v5 - 1) + 136))
      {
LABEL_108:
        sub_10003FA78(*(void **)v5);
        CFDictionaryRef v1 = byte_10008FE9C + 356;
        goto LABEL_289;
      }
      if (dword_10008FA20)
      {
        v169 = ne_log_obj();
        if (os_log_type_enabled(v169, OS_LOG_TYPE_ERROR)) {
          goto LABEL_501;
        }
      }
      goto LABEL_502;
    case 0x11u:
      *(_DWORD *)(qword_10008F848 + 312) = *(void *)v5;
      goto LABEL_289;
    case 0x13u:
      sub_100028424(__str, 1024, 0, *(const char **)(*((void *)v5 - 1) + 8));
      sub_10003FA78(*((void **)v5 - 1));
      if (sub_100056744(__str)) {
        return 0xFFFFFFFFLL;
      }
      goto LABEL_289;
    case 0x17u:
      --**(void **)v5;
      *(void *)(qword_10008F848 + 8 * *((void *)v5 - 1) + 176) = *(void *)v5;
      if (*(void *)(qword_10008F848 + 8 * *((void *)v5 - 1) + 176)) {
        goto LABEL_289;
      }
      int v159 = __error();
      strerror(*v159);
      sub_100055C70("failed to set my ident: %s");
      return 0xFFFFFFFFLL;
    case 0x1Au:
      sub_10003433C(*(const char **)(*(void *)v5 + 8));
      goto LABEL_287;
    case 0x1Bu:
      sub_100034044(*v5);
      goto LABEL_289;
    case 0x1Fu:
      *(_DWORD *)(qword_10008F848 + 248) = *(void *)v5;
      goto LABEL_289;
    case 0x21u:
      *(_DWORD *)(qword_10008F848 + 252) = *(void *)v5;
      goto LABEL_289;
    case 0x23u:
      *(_DWORD *)(qword_10008F848 + 256) = *(void *)v5;
      goto LABEL_289;
    case 0x25u:
      *(_DWORD *)(qword_10008F848 + 260) = *(void *)v5;
      goto LABEL_289;
    case 0x27u:
      *(_DWORD *)(qword_10008F848 + 264) = *(void *)v5;
      goto LABEL_289;
    case 0x2Cu:
      uint64_t v21 = *(void *)v5;
      int v22 = 0;
      goto LABEL_62;
    case 0x2Eu:
      uint64_t v21 = *(void *)v5;
      int v22 = 1;
LABEL_62:
      sub_100053810(v21, v22);
      goto LABEL_289;
    case 0x30u:
      sub_100055C70("admin directive is obsoleted.");
      goto LABEL_289;
    case 0x32u:
    case 0x34u:
    case 0x36u:
      sub_100055BF8("admin port support not compiled in");
      goto LABEL_289;
    case 0x38u:
      *(_DWORD *)(qword_10008F848 + 308) = 1;
      goto LABEL_289;
    case 0x3Au:
      snprintf(__str, 0xAuLL, "%ld", *(void *)v5);
      uint64_t v17 = (uint64_t)sub_10003D1DC(*(const char **)(*((void *)v5 - 1) + 8), __str);
      sub_10003FA78(*((void **)v5 - 1));
      if (!v17) {
        return 0xFFFFFFFFLL;
      }
      goto LABEL_289;
    case 0x3Bu:
      uint64_t v23 = malloc_type_calloc(1uLL, 0x10uLL, 0x1020040D5A9D86FuLL);
      if (!v23)
      {
        sub_100055C70("failed to allocate remote index struct");
        char v160 = (void *)*((void *)v5 - 2);
        goto LABEL_461;
      }
      uint64_t v17 = (uint64_t)v23;
      snprintf(__str, 0xAuLL, "%ld", *(void *)v5);
      *(void *)(v17 + 8) = sub_10003D1DC(*(const char **)(*((void *)v5 - 2) + 8), __str);
      sub_10003FA78(*((void **)v5 - 2));
      if (*(void *)(v17 + 8))
      {
        *(_DWORD *)uint64_t v17 = *((void *)v5 - 1);
        goto LABEL_289;
      }
      sub_100055C70("failed to allocate sockaddr storage", v171);
      return 0xFFFFFFFFLL;
    case 0x3Cu:
      uint64_t v17 = 500;
      goto LABEL_289;
    case 0x3Du:
    case 0xB5u:
    case 0xB7u:
    case 0xB9u:
    case 0xBAu:
    case 0xBDu:
    case 0x12Bu:
    case 0x12Cu:
      uint64_t v17 = *(void *)v5;
      goto LABEL_289;
    case 0x41u:
      if (inet_pton(2, *(const char **)(*(void *)v5 + 8), &xmmword_10008FE38) != 1) {
        sub_100055C70("bad IPv4 network address.");
      }
      goto LABEL_287;
    case 0x43u:
      if (inet_pton(2, *(const char **)(*(void *)v5 + 8), (char *)&xmmword_10008FE38 + 4) != 1) {
        sub_100055C70("bad IPv4 netmask address.");
      }
      goto LABEL_287;
    case 0x47u:
      int v24 = 28678;
      goto LABEL_77;
    case 0x49u:
      int v24 = 28676;
LABEL_77:
      dword_1000906AC = v24;
      goto LABEL_289;
    case 0x4Du:
    case 0x73u:
      __strlcpy_chk();
      goto LABEL_287;
    case 0x4Fu:
      dword_10008FE70 = 0;
      goto LABEL_289;
    case 0x51u:
    case 0x61u:
    case 0x6Fu:
      sub_100055C70("racoon not configured with --with-libradius");
      goto LABEL_289;
    case 0x53u:
    case 0x63u:
      sub_100055C70("racoon not configured with --with-libpam");
      goto LABEL_289;
    case 0x55u:
    case 0x5Bu:
    case 0x71u:
      sub_100055C70("racoon not configured with --with-libldap");
      goto LABEL_289;
    case 0x59u:
      dword_10008FE74 = 0;
      goto LABEL_289;
    case 0x5Du:
      dword_10008FE88 = 0;
      goto LABEL_289;
    case 0x5Fu:
      int v25 = &xmmword_10008FE38;
      int v26 = 4;
      goto LABEL_221;
    case 0x65u:
      if (sub_100045560(*v5)) {
        sub_100055C70("cannot allocate memory for pool");
      }
      goto LABEL_289;
    case 0x67u:
      unsigned int v27 = *v5;
      dword_1000906BC = *v5;
      goto LABEL_151;
    case 0x69u:
      dword_1000906C0 = *(void *)v5;
      goto LABEL_289;
    case 0x6Bu:
      dword_10008FE98 = *(void *)v5;
      goto LABEL_289;
    case 0x6Du:
      dword_10008FE84 = 0;
      goto LABEL_289;
    case 0x77u:
      uint64_t v28 = dword_10008FE4C;
      if (dword_10008FE4C > 2)
      {
        sub_100055C70("No more than %d DNS");
        return 0xFFFFFFFFLL;
      }
      uint64_t v29 = *(const char **)(*(void *)v5 + 8);
      ++dword_10008FE4C;
      if (inet_pton(2, v29, (char *)&xmmword_10008FE38 + 4 * v28 + 8) != 1) {
        sub_100055C70("bad IPv4 DNS address.");
      }
      goto LABEL_287;
    case 0x7Au:
      uint64_t v30 = dword_10008FE60;
      if (dword_10008FE60 > 3)
      {
        sub_100055C70("No more than %d WINS");
        return 0xFFFFFFFFLL;
      }
      uint64_t v31 = *(const char **)(*(void *)v5 + 8);
      ++dword_10008FE60;
      if (inet_pton(2, v31, (char *)&xmmword_10008FE38 + 4 * v30 + 24) != 1) {
        sub_100055C70("bad IPv4 WINS address.");
      }
      goto LABEL_287;
    case 0x7Du:
      memset(__str, 0, sizeof(__str));
      if (inet_pton(2, *(const char **)(*((void *)v5 - 1) + 8), __str) != 1) {
        sub_100055C70("bad IPv4 SPLIT address.");
      }
      unsigned int v32 = bswap32(-1 << -(char)*(void *)v5);
      if (*(void *)v5) {
        unsigned int v33 = v32;
      }
      else {
        unsigned int v33 = 0;
      }
      *(_DWORD *)&__str[4] = v33;
      if (sub_1000462B8(&qword_1000906A0, (uint64_t *)__str, &dword_1000906A8)) {
        sub_100055C70("Unable to allocate split network");
      }
      xpc_connection_t v34 = (void *)*((void *)v5 - 1);
      goto LABEL_288;
    case 0x80u:
      uint64_t v35 = malloc_type_realloc((void *)qword_10008FE78, 8 * dword_10008FE80 + 8, 0x80040B8603338uLL);
      if (!v35) {
        sub_100055C70("unable to allocate auth group list");
      }
      xpc_object_t v36 = malloc_type_malloc(**(void **)v5 + 1, 0x2556D787uLL);
      if (!v36) {
        sub_100055C70("unable to allocate auth group name");
      }
      memcpy(v36, *(const void **)(*(void *)v5 + 8), **(void **)v5);
      *((unsigned char *)v36 + **(void **)v5) = 0;
      int v37 = dword_10008FE80 + 1;
      v35[dword_10008FE80] = v36;
      qword_10008FE78 = (uint64_t)v35;
      dword_10008FE80 = v37;
      goto LABEL_108;
    case 0x83u:
      size_t v38 = **(void **)v5;
      if (dword_1000906B8)
      {
        int v39 = dword_1000906B8 + v38 + 1;
        uint64_t v40 = malloc_type_realloc((void *)qword_1000906B0, v39, 0x7D912066uLL);
        qword_1000906B0 = (uint64_t)v40;
        if (!v40)
        {
          sub_100055C70("error allocating splitdns list buffer");
          uint64_t v40 = (unsigned char *)qword_1000906B0;
        }
        v40[dword_1000906B8] = 44;
        memcpy((void *)(qword_1000906B0 + dword_1000906B8 + 1), *(const void **)(*(void *)v5 + 8), **(void **)v5);
      }
      else
      {
        int v114 = malloc_type_malloc(v38, 0xED941381uLL);
        qword_1000906B0 = (uint64_t)v114;
        if (!v114)
        {
          sub_100055C70("error allocating splitdns list buffer");
          int v114 = (void *)qword_1000906B0;
        }
        memcpy(v114, *(const void **)(*(void *)v5 + 8), **(void **)v5);
        int v39 = **(_DWORD **)v5;
      }
      dword_1000906B8 = v39;
      goto LABEL_287;
    case 0x87u:
      *(_DWORD *)(qword_10008F848 + 268) = *(void *)v5;
      goto LABEL_289;
    case 0x89u:
      *(_DWORD *)(qword_10008F848 + 272) = *v5 * *(v5 - 2);
      goto LABEL_289;
    case 0x8Bu:
      *(_DWORD *)(qword_10008F848 + 276) = *(void *)v5;
      goto LABEL_289;
    case 0x8Du:
      *(_DWORD *)(qword_10008F848 + 280) = *v5 * *(v5 - 2);
      goto LABEL_289;
    case 0x8Fu:
      *(_DWORD *)(qword_10008F848 + 284) = *v5 * *(v5 - 2);
      goto LABEL_289;
    case 0x91u:
      int v41 = *v5 * *(v5 - 2);
      uint64_t v42 = qword_10008F848;
      *(_DWORD *)(qword_10008F848 + 80) |= 1u;
      *(_DWORD *)(v42 + 84) = v41;
      goto LABEL_289;
    case 0x93u:
      *(_DWORD *)(qword_10008F848 + ++*(_DWORD *)(result + 288) = *v5 * *(v5 - 2);
      goto LABEL_289;
    case 0x95u:
      sub_10003A554();
      qword_10008F2C8 = v43;
      if (v43) {
        goto LABEL_289;
      }
      sub_100055C70("failed to allocate sainfo", v171);
      return 0xFFFFFFFFLL;
    case 0x96u:
      if (*(void *)(qword_10008F2C8 + 48))
      {
        if (*(void *)(qword_10008F2C8 + 56))
        {
          if (*(void *)(qword_10008F2C8 + 64))
          {
            int v44 = (uint64_t *)sub_10003A168(*(void *)qword_10008F2C8, *(void *)(qword_10008F2C8 + 8), *(void *)(qword_10008F2C8 + 40), 0);
            if (v44)
            {
              uint64_t v45 = *v44;
              uint64_t v46 = qword_10008F2C8;
              if (!v45 && !*(void *)qword_10008F2C8)
              {
                sub_10003A83C((uint64_t *)qword_10008F2C8);
                sub_100055C70("duplicated sainfo: %s");
                return 0xFFFFFFFFLL;
              }
            }
            else
            {
              uint64_t v46 = qword_10008F2C8;
            }
            sub_10003A664(v46);
            goto LABEL_289;
          }
          sub_10003A83C((uint64_t *)qword_10008F2C8);
          sub_100055C70("no compression algorithm at %s");
        }
        else
        {
          sub_10003A83C((uint64_t *)qword_10008F2C8);
          sub_100055C70("no authentication algorithm at %s");
        }
      }
      else
      {
        sub_10003A83C((uint64_t *)qword_10008F2C8);
        sub_100055C70("no encryption algorithm at %s");
      }
      return 0xFFFFFFFFLL;
    case 0x98u:
      uint64_t v47 = qword_10008F2C8;
      *(void *)qword_10008F2C8 = 0;
      *(void *)(v47 + 8) = 0;
      goto LABEL_289;
    case 0x99u:
      uint64_t v48 = qword_10008F2C8;
      *(void *)qword_10008F2C8 = 0;
      *(void *)(v48 + 8) = *(void *)v5;
      goto LABEL_289;
    case 0x9Au:
      uint64_t v49 = qword_10008F2C8;
      *(void *)qword_10008F2C8 = *((void *)v5 - 1);
      *(void *)(v49 + 8) = 0;
      goto LABEL_289;
    case 0x9Bu:
      uint64_t v50 = qword_10008F2C8;
      *(void *)qword_10008F2C8 = *((void *)v5 - 1);
      *(void *)(v50 + 8) = *(void *)v5;
      goto LABEL_289;
    case 0x9Cu:
      if (*(void *)v5 == 1 || *(void *)v5 == 58)
      {
        uint64_t v51 = *((void *)v5 - 1);
        if (v51)
        {
LABEL_431:
          sub_100055C70("port number must be \"any\".", v171);
          return 0xFFFFFFFFLL;
        }
      }
      else
      {
        uint64_t v51 = *((void *)v5 - 1);
      }
      snprintf(__str, 0xAuLL, "%lu", v51);
      long long v86 = sub_10003D1DC(*(const char **)(*((void *)v5 - 3) + 8), __str);
      sub_10003FA78(*((void **)v5 - 3));
      if (!v86) {
        return 0xFFFFFFFFLL;
      }
      int v119 = v86[1];
      if (v119 == 30)
      {
        uint64_t v120 = *(void *)v5;
        if (*(void *)v5 == 1)
        {
LABEL_468:
          sub_100055C70("upper layer protocol mismatched.\n");
          goto LABEL_473;
        }
        int v121 = 128;
      }
      else
      {
        if (v119 != 2)
        {
          sub_100055C70("invalid family: %d");
LABEL_473:
          char v162 = v86;
LABEL_481:
          free(v162);
          return 0xFFFFFFFFLL;
        }
        uint64_t v120 = *(void *)v5;
        if (*(void *)v5 == 58) {
          goto LABEL_468;
        }
        int v121 = 32;
      }
      if (*((void *)v5 - 2) == -1) {
        unsigned int v122 = v121;
      }
      else {
        unsigned int v122 = *((void *)v5 - 2);
      }
      uint64_t v17 = (uint64_t)sub_10001026C((uint64_t)v86, v122, v120);
      free(v86);
      if (!v17) {
        return 0xFFFFFFFFLL;
      }
      goto LABEL_289;
    case 0x9Du:
      if (*(void *)v5 == 1 || *(void *)v5 == 58)
      {
        uint64_t v52 = *((void *)v5 - 1);
        if (v52) {
          goto LABEL_431;
        }
        int v53 = v1;
      }
      else
      {
        int v53 = v1;
        uint64_t v52 = *((void *)v5 - 1);
      }
      snprintf(__str, 0xAuLL, "%lu", v52);
      int v123 = sub_10003D1DC(*(const char **)(*((void *)v5 - 4) + 8), __str);
      if (!v123) {
        return 0xFFFFFFFFLL;
      }
      int v124 = v123;
      sub_10003FA78(*((void **)v5 - 4));
      uint64_t v125 = sub_10003D1DC(*(const char **)(*((void *)v5 - 3) + 8), __str);
      if (!v125)
      {
        char v162 = v124;
        goto LABEL_481;
      }
      long long v86 = v125;
      sub_10003FA78(*((void **)v5 - 3));
      int v126 = v124[1];
      if (v126 == 30)
      {
        uint64_t v127 = *(void *)v5;
        if (*(void *)v5 == 1)
        {
LABEL_470:
          sub_100055C70("upper layer protocol mismatched.\n");
          free(v124);
          goto LABEL_473;
        }
      }
      else
      {
        if (v126 != 2)
        {
          sub_100055C70("invalid family: %d", v124[1]);
          uint64_t v17 = 0;
LABEL_332:
          free(v124);
          free(v86);
          CFDictionaryRef v1 = v53;
          if (v17) {
            goto LABEL_289;
          }
          return 0xFFFFFFFFLL;
        }
        uint64_t v127 = *(void *)v5;
        if (*(void *)v5 == 58) {
          goto LABEL_470;
        }
      }
      uint64_t v17 = (uint64_t)sub_100010490((uint64_t)v124, (uint64_t)v86, v127);
      goto LABEL_332;
    case 0x9Eu:
      if (*((void *)v5 - 1) == 5)
      {
        sub_100055C70("id type forbidden: %d");
      }
      else
      {
        uint64_t v54 = sub_10003F940(--**(void **)v5 + 4);
        if (v54)
        {
          uint64_t v17 = (uint64_t)v54;
          uint64_t v55 = v54[1];
          *(unsigned char *)uint64_t v55 = sub_100011484(*(v5 - 2));
          *(unsigned char *)(v55 + 1) = 0;
          *(_WORD *)(v55 + 2) = 0;
          memcpy((void *)(*(void *)(v17 + 8) + 4), *(const void **)(*(void *)v5 + 8), **(void **)v5);
          goto LABEL_289;
        }
LABEL_425:
        sub_100055C70("failed to allocate identifier", v171);
      }
      return 0xFFFFFFFFLL;
    case 0x9Fu:
      *(void *)(qword_10008F2C8 + 40) = 0;
      goto LABEL_289;
    case 0xA0u:
      *(void *)__str = 0;
      if (sub_10000FBF0((void ***)__str, *(v5 - 2), *(void *)v5)) {
        goto LABEL_421;
      }
      int v56 = sub_10003F940(**(void **)__str + 4);
      *(void *)(qword_10008F2C8 + 40) = v56;
      if (!v56) {
        goto LABEL_425;
      }
      uint64_t v57 = v56[1];
      *(unsigned char *)uint64_t v57 = sub_100011484(*(v5 - 2));
      *(unsigned char *)(v57 + 1) = 0;
      *(_WORD *)(v57 + 2) = 0;
      memcpy((void *)(*(void *)(*(void *)(qword_10008F2C8 + 40) + 8) + 4), *(const void **)(*(void *)__str + 8), **(void **)__str);
      xpc_connection_t v34 = *(void **)__str;
      goto LABEL_288;
    case 0xA1u:
      __int16 v58 = sub_10003FAC0(*(void *)v5);
      *(void *)(qword_10008F2C8 + 16) = v58;
      if (v58) {
        goto LABEL_289;
      }
      sub_100055C70("failed to set sainfo xauth group.\n", v171);
      return 0xFFFFFFFFLL;
    case 0xA4u:
      unsigned int v27 = *v5;
      *(_DWORD *)(qword_10008F2C8 + 36) = *v5;
LABEL_151:
      if (v27 <= 0x12 && ((1 << v27) & 0x7C026) != 0) {
        goto LABEL_289;
      }
      sub_100055C70("Invalid PFS group specified", v171);
      return 0xFFFFFFFFLL;
    case 0xA6u:
      *(void *)(qword_10008F2C8 + 24) = *(void *)v5 * *((void *)v5 - 1);
      goto LABEL_289;
    case 0xA8u:
    case 0x133u:
      sub_100055C70("byte lifetime support is deprecated", v171);
      return 0xFFFFFFFFLL;
    case 0xAAu:
      dword_10008F2D0 = *(void *)v5;
      goto LABEL_289;
    case 0xACu:
    case 0xAEu:
      sub_100055C70("it's deprecated to specify a identifier in phase 2");
      goto LABEL_289;
    case 0xB0u:
    case 0xB1u:
      sub_10003A81C((uint64_t *)(qword_10008F2C8 + 8 * dword_10008F2D0 + 48), *(void *)v5);
      goto LABEL_289;
    case 0xB3u:
      uint64_t v59 = sub_10003A800();
      if (!v59)
      {
        sub_100055C70("failed to get algorithm allocation", v171);
        return 0xFFFFFFFFLL;
      }
      uint64_t v17 = (uint64_t)v59;
      int v60 = sub_100003988(dword_10008F2D0, *(v5 - 2));
      *(_DWORD *)uint64_t v17 = v60;
      if (v60 == -1)
      {
        sub_100055C70("algorithm mismatched", v171);
        goto LABEL_480;
      }
      unsigned int v61 = sub_10000377C(dword_10008F2D0, *(v5 - 2));
      uint64_t v62 = *(void *)v5;
      if (v61)
      {
        if (v62)
        {
          if ((sub_1000037AC(dword_10008F2D0, *(v5 - 2), v62) & 0x80000000) != 0)
          {
            sub_100055C70("invalid keylen %d");
            goto LABEL_480;
          }
          if (*(void *)v5) {
            unsigned int v61 = *(void *)v5;
          }
        }
      }
      else if (v62)
      {
        sub_100055C70("keylen not allowed");
        goto LABEL_480;
      }
      *(_DWORD *)(v17 + 4) = v61;
      uint64_t v118 = *((void *)v5 - 1);
      if (dword_10008F2D0 == 1 && v118 == 18 || !sub_100030D34(dword_10008F2D0, v118, v61)) {
        goto LABEL_289;
      }
      int v164 = sub_100003B14(dword_10008F2D0);
      uint64_t v165 = sub_100003988(dword_10008F2D0, *(v5 - 2));
      if (v164 == 5) {
        int v166 = 2;
      }
      else {
        int v166 = v164;
      }
      sub_10003E580(v166, v165);
      sub_100055C70("algorithm %s not supported by the kernel (missing module?)");
LABEL_480:
      char v162 = (void *)v17;
      goto LABEL_481;
    case 0xB4u:
      uint64_t v17 = -1;
      goto LABEL_289;
    case 0xB6u:
    case 0xB8u:
    case 0xBCu:
    case 0x12Au:
    case 0x142u:
    case 0x145u:
      uint64_t v17 = 0;
      goto LABEL_289;
    case 0xBBu:
      uint64_t v17 = 255;
      goto LABEL_289;
    case 0xBEu:
      long long v63 = sub_100038A9C(*(sockaddr **)(*(void *)v5 + 8));
      if (!v63)
      {
        v161 = sub_10003CAE4(*(const sockaddr **)v5);
        sub_100055C70("failed to get remoteconf for %s.", (const char *)v161);
        free(*(void **)(*((void *)v5 - 2) + 8));
        free(*((void **)v5 - 2));
LABEL_444:
        free(*(void **)(*(void *)v5 + 8));
        char v162 = *(void **)v5;
        goto LABEL_481;
      }
      long long v64 = v63;
      void *v63 = *(void *)(*((void *)v5 - 2) + 8);
      int v65 = **((_DWORD **)v5 - 2);
      if (v65 == -1) {
        int v65 = 0;
      }
      *((_DWORD *)v63 + 2) = v65;
      uint64_t v66 = sub_1000384B8(*(sockaddr **)(*(void *)v5 + 8), 1);
      v64[31] = 0;
      v64[32] = v66;
      v64[33] = 0;
      qword_10008F2D8 = (uint64_t)v64;
      free(*((void **)v5 - 2));
      free(*(void **)(*(void *)v5 + 8));
      free(*(void **)v5);
      uint64_t v67 = sub_1000538D8();
      if (!v67) {
        return 0xFFFFFFFFLL;
      }
      uint64_t v68 = qword_10008F2D8;
      uint64_t v69 = *(void *)(qword_10008F2D8 + 256);
      if (!v69) {
        return 0xFFFFFFFFLL;
      }
      uint64_t v70 = *(void *)(v69 + 248);
      if (!v70) {
        return 0xFFFFFFFFLL;
      }
      *(void *)uint64_t v67 = *(void *)(v70 + 16);
      v67[2] = *(void *)(v70 + 32);
      uint64_t v71 = *(void *)(v68 + 264);
      if (v71)
      {
        *(void *)(v71 + 32) = v67;
        uint64_t v71 = *(void *)(v68 + 264);
      }
      *((void *)v67 + 3) = v71;
      *(void *)(v68 + 264) = v67;
      goto LABEL_289;
    case 0xC0u:
      uint64_t v72 = sub_1000389AC();
      if (!v72)
      {
        sub_100055C70("failed to get new remoteconf.");
        goto LABEL_444;
      }
      *(void *)uint64_t v72 = *(void *)(*(void *)v5 + 8);
      int v73 = **(_DWORD **)v5;
      if (v73 == -1) {
        int v73 = 0;
      }
      v72[2] = v73;
      qword_10008F2D8 = (uint64_t)v72;
      free(*(void **)v5);
      uint64_t v74 = sub_1000538D8();
      if (!v74) {
        return 0xFFFFFFFFLL;
      }
      int v75 = v74;
      *uint64_t v74 = (int)sub_10000ED5C();
      uint64_t v76 = qword_10008F2D8;
      uint64_t v77 = *(void *)(qword_10008F2D8 + 264);
      if (v77)
      {
        *(void *)(v77 + 32) = v75;
        uint64_t v77 = *(void *)(v76 + 264);
      }
      v75[3] = v77;
      *(void *)(v76 + 264) = v75;
LABEL_289:
      uint64_t v115 = &v5[-2 * v16];
      v4 -= 2 * v16;
      *((void *)v115 + 1) = v17;
      int v5 = v115 + 2;
      uint64_t v116 = word_10006FCC4[v15] - 168;
      uint64_t v117 = (*(__int16 *)v4 + word_10006FF54[v116]);
      if (v117 <= 0x1DD && word_10006EF18[v117] == *(unsigned __int16 *)v4) {
        int v0 = word_10006F2D4[v117];
      }
      else {
        int v0 = word_1000700B0[v116];
      }
      goto LABEL_293;
    case 0xC2u:
      uint64_t v78 = qword_10008F2D8;
      if (!*(void *)(qword_10008F2D8 + 16))
      {
        sub_100055C70("no exchange mode specified.\n", v171);
        return 0xFFFFFFFFLL;
      }
      int v79 = *(_DWORD *)(qword_10008F2D8 + 32);
      if (v79 == 5)
      {
        uint64_t v128 = *(void *)(qword_10008F2D8 + 40);
        if (*(_DWORD *)(qword_10008F2D8 + 64))
        {
          if (v128)
          {
            sub_100055BF8("Both CERT and ASN1 ID are set. Hope this is OK.\n");
            uint64_t v78 = qword_10008F2D8;
          }
        }
        else if (!v128)
        {
          sub_100055C70("ASN1 ID not specified and no CERT defined!\n", v171);
          return 0xFFFFFFFFLL;
        }
      }
      else if (!v79)
      {
        *(_DWORD *)(qword_10008F2D8 + 32) = 4;
      }
      if (*(_DWORD *)(v78 + 132) == 1)
      {
        *(void *)__str = 0;
        if (!sub_1000061E0(*(void **)(v78 + 56), __str))
        {
          sub_100055C70("peers_identifier required for specified certificate verification option.\n", v171);
          return 0xFFFFFFFFLL;
        }
        uint64_t v78 = qword_10008F2D8;
      }
      v130 = *(uint64_t **)(v78 + 264);
      int v131 = (void *)v130[2];
      if (!v131)
      {
        int v131 = *(void **)(v78 + 256);
        if (v131)
        {
          int v131 = (void *)v131[33];
          if (v131)
          {
            int v131 = (void *)v131[2];
            v130[2] = (uint64_t)v131;
          }
        }
      }
      if (v130[3])
      {
        if (dword_10008FA20)
        {
          v163 = ne_log_obj();
          if (os_log_type_enabled(v163, OS_LOG_TYPE_ERROR)) {
            sub_10006CE14();
          }
        }
        return 0xFFFFFFFFLL;
      }
      v132 = v131;
      if (!v131)
      {
        sub_10003CAE4(*(const sockaddr **)v78);
        sub_100055C70("no remote specification found: %s.\n");
        return 0xFFFFFFFFLL;
      }
      do
      {
        if (!*((_DWORD *)v132 + 19))
        {
          sub_100055C70("encryption algorithm required.", v171);
          return 0xFFFFFFFFLL;
        }
        if (!*((_DWORD *)v132 + 20))
        {
          sub_100055C70("hash algorithm required.", v171);
          return 0xFFFFFFFFLL;
        }
        if (!*((_DWORD *)v132 + 21))
        {
          sub_100055C70("DH group required.", v171);
          return 0xFFFFFFFFLL;
        }
        if (!*((_DWORD *)v132 + 22))
        {
          sub_100055C70("authentication method required.", v171);
          return 0xFFFFFFFFLL;
        }
        v132 = (void *)v132[12];
      }
      while (v132);
      uint64_t v172 = v78;
      do
      {
        v133 = v131;
        int v131 = (void *)v131[12];
      }
      while (v131);
      v182 = v133;
      int v179 = 1;
      v173 = v130;
      break;
    case 0xC3u:
      uint64_t v80 = malloc_type_calloc(1uLL, 0x10uLL, 0x1020040D5A9D86FuLL);
      if (!v80)
      {
        sub_100055C70("failed to allocate remote index struct", v171);
        return 0xFFFFFFFFLL;
      }
      uint64_t v17 = (uint64_t)v80;
      uint64_t v81 = sub_10003CBF4(128);
      *(void *)(v17 + 8) = v81;
      if (v81)
      {
        v81[1] = 0;
        *((_WORD *)v81 + 1) = bswap32(*(unsigned __int16 *)v5) >> 16;
        *(_DWORD *)uint64_t v17 = -1;
        goto LABEL_289;
      }
      sub_100055C70("failed to allocate sockaddr storage", v171);
      goto LABEL_480;
    case 0xC4u:
      uint64_t v17 = *(void *)v5;
      if (*(void *)v5) {
        goto LABEL_289;
      }
      sub_100055C70("failed to allocate sockaddr_storage", v171);
      return 0xFFFFFFFFLL;
    case 0xC7u:
      *(void *)(qword_10008F2D8 + 16) = 0;
      goto LABEL_289;
    case 0xC9u:
      *(_DWORD *)(qword_10008F2D8 + 24) = *(void *)v5;
      goto LABEL_289;
    case 0xCBu:
      *(_DWORD *)(qword_10008F2D8 + 28) = *(void *)v5;
      goto LABEL_289;
    case 0xCDu:
      if (*(void *)v5 == 1)
      {
        *(_DWORD *)(qword_10008F2D8 + 292) = 16;
        goto LABEL_289;
      }
      sub_100055C70("invalid IKE version specified.\n", v171);
      return 0xFFFFFFFFLL;
    case 0xD0u:
      *(_DWORD *)(qword_10008F2D8 + 124) = *(void *)v5;
      goto LABEL_289;
    case 0xD2u:
      *(_DWORD *)(qword_10008F2D8 + 116) = *(void *)v5;
      goto LABEL_289;
    case 0xD4u:
      *(_DWORD *)(qword_10008F2D8 + 120) = *(void *)v5;
      goto LABEL_289;
    case 0xD6u:
      *(_DWORD *)(qword_10008F2D8 + 128) = *(void *)v5;
      goto LABEL_289;
    case 0xD8u:
      uint64_t v82 = qword_10008F2D8;
      *(_DWORD *)(qword_10008F2D8 + 128) = *((void *)v5 - 1);
      *(_DWORD *)(v82 + 132) = *(void *)v5;
      goto LABEL_289;
    case 0xDAu:
      sub_100055C70("Apple specific features not compiled in.", v171);
      return 0xFFFFFFFFLL;
    case 0xDCu:
      if (sub_10000FBF0((void ***)(qword_10008F2D8 + 40), *(v5 - 2), *(void *)v5))
      {
        sub_100055C70("failed to set identifer.\n");
LABEL_460:
        char v160 = *(void **)v5;
LABEL_461:
        sub_10003FA78(v160);
        return 0xFFFFFFFFLL;
      }
      sub_10003FA78(*(void **)v5);
      uint64_t v83 = *((void *)v5 - 1);
LABEL_204:
      *(_DWORD *)(qword_10008F2D8 + 32) = v83;
      goto LABEL_289;
    case 0xDEu:
      if (sub_10000FBF8((void ***)(qword_10008F2D8 + 40), *(v5 - 4), *(void *)v5, *(v5 - 2))) {
        goto LABEL_421;
      }
      uint64_t v83 = *((void *)v5 - 2);
      goto LABEL_204;
    case 0xE0u:
      if (sub_100047D10(qword_10008F2D8 + 272) == -1)
      {
        sub_100055C70("failed to allocate xauth state\n", v171);
        return 0xFFFFFFFFLL;
      }
      __int16 v84 = sub_10003FAC0(*(void *)v5);
      **(void **)(qword_10008F2D8 + 272) = v84;
      if (!v84)
      {
LABEL_421:
        sub_100055C70("failed to set identifer.\n", v171);
        return 0xFFFFFFFFLL;
      }
LABEL_287:
      xpc_connection_t v34 = *(void **)v5;
LABEL_288:
      sub_10003FA78(v34);
      goto LABEL_289;
    case 0xE2u:
      __int16 v85 = sub_100038C60();
      if (!v85) {
        goto LABEL_424;
      }
      long long v86 = (unsigned __int8 *)v85;
      if (!sub_10000FBF0((void ***)v85 + 1, *(v5 - 2), *(void *)v5))
      {
        sub_10003FA78(*(void **)v5);
        uint64_t v87 = *((void *)v5 - 1);
LABEL_214:
        *(_DWORD *)long long v86 = v87;
        sub_10000613C(*(void *)(qword_10008F2D8 + 56), (uint64_t)v86);
        goto LABEL_289;
      }
      sub_100055C70("failed to set identifer.\n");
      free(v86);
      goto LABEL_460;
    case 0xE4u:
      long long v88 = sub_100038C60();
      if (!v88)
      {
LABEL_424:
        sub_100055C70("failed to allocate idspec", v171);
        return 0xFFFFFFFFLL;
      }
      long long v86 = (unsigned __int8 *)v88;
      if (sub_10000FBF8((void ***)v88 + 1, *(v5 - 4), *(void *)v5, *(v5 - 2)))
      {
        sub_100055C70("failed to set identifer.\n", v171);
        goto LABEL_473;
      }
      uint64_t v87 = *((void *)v5 - 2);
      goto LABEL_214;
    case 0xE6u:
      *(_DWORD *)(qword_10008F2D8 + 136) = *(void *)v5;
      goto LABEL_289;
    case 0xE8u:
      long long v89 = sub_10003D1DC(*(const char **)(*(void *)v5 + 8), 0);
      sub_10003FA78(*(void **)v5);
      if (!v89) {
        return 0xFFFFFFFFLL;
      }
      *(void *)(qword_10008F2D8 + 296) = v89;
      goto LABEL_289;
    case 0xEAu:
      uint64_t v90 = qword_10008F2D8;
      *(_DWORD *)(qword_10008F2D8 + 80) = *((void *)v5 - 1);
      *(void *)(v90 + 88) = *(void *)v5;
      goto LABEL_289;
    case 0xECu:
      if (*(void *)v5 != 3)
      {
        sub_100055C70("shared secret value missing.\n", v171);
        return 0xFFFFFFFFLL;
      }
      int v25 = (long long *)qword_10008F2D8;
      int v26 = 3;
LABEL_221:
      *((_DWORD *)v25 + 20) = v26;
      goto LABEL_289;
    case 0xEEu:
      *(_DWORD *)(qword_10008F2D8 + 140) = *(void *)v5;
      goto LABEL_289;
    case 0xF0u:
      sub_100055C70("dh_group cannot be defined here.", v171);
      return 0xFFFFFFFFLL;
    case 0xF2u:
      *(_DWORD *)(qword_10008F2D8 + 144) = *(void *)v5;
      goto LABEL_289;
    case 0xF4u:
      *(_DWORD *)(qword_10008F2D8 + 148) = *(void *)v5;
      goto LABEL_289;
    case 0xF6u:
      *(_DWORD *)(qword_10008F2D8 + 148) = 2;
      goto LABEL_289;
    case 0xF8u:
      sub_100055BF8("Your kernel does not support esp_frag");
      goto LABEL_289;
    case 0xFAu:
      *(_DWORD *)(qword_10008F2D8 + 156) = *(void *)v5;
      goto LABEL_289;
    case 0xFCu:
      *(_DWORD *)(qword_10008F2D8 + 240) = *(void *)v5;
      goto LABEL_289;
    case 0xFEu:
    case 0x100u:
      *(_DWORD *)(qword_10008F2D8 + 164) = *(void *)v5;
      goto LABEL_289;
    case 0x102u:
      *(_DWORD *)(qword_10008F2D8 + 160) = *(void *)v5;
      goto LABEL_289;
    case 0x104u:
      *(_DWORD *)(qword_10008F2D8 + 168) = *(void *)v5;
      goto LABEL_289;
    case 0x106u:
    case 0x108u:
      *(_DWORD *)(qword_10008F2D8 + 176) = *(void *)v5;
      goto LABEL_289;
    case 0x10Au:
      *(_DWORD *)(qword_10008F2D8 + 180) = *(void *)v5;
      goto LABEL_289;
    case 0x10Cu:
      *(_DWORD *)(qword_10008F2D8 + 184) = *(void *)v5;
      goto LABEL_289;
    case 0x10Eu:
      *(_DWORD *)(qword_10008F2D8 + 208) = *(void *)v5;
      goto LABEL_289;
    case 0x110u:
      *(_DWORD *)(qword_10008F2D8 + 216) = *(void *)v5;
      goto LABEL_289;
    case 0x112u:
      *(_DWORD *)(qword_10008F2D8 + 212) = *(void *)v5;
      goto LABEL_289;
    case 0x114u:
      *(_DWORD *)(qword_10008F2D8 + 220) = *(void *)v5;
      goto LABEL_289;
    case 0x116u:
      *(_DWORD *)(qword_10008F2D8 + 224) = *(void *)v5;
      goto LABEL_289;
    case 0x118u:
      uint64_t v91 = qword_10008F2D8;
      *(_DWORD *)(qword_10008F2D8 + 228) = *((void *)v5 - 2);
      *(_DWORD *)(v91 + 232) = *(void *)v5;
      goto LABEL_289;
    case 0x11Au:
      **(void **)(qword_10008F2D8 + 264) = *(void *)v5 * *((void *)v5 - 1);
      goto LABEL_289;
    case 0x11Cu:
      *(_DWORD *)(qword_10008F2D8 + 172) = *(void *)v5;
      goto LABEL_289;
    case 0x11Eu:
      sub_100055C70("byte lifetime support is deprecated in Phase 1", v171);
      return 0xFFFFFFFFLL;
    case 0x120u:
      uint64_t v92 = malloc_type_calloc(1uLL, 0x78uLL, 0x1030040E6A3F341uLL);
      if (!v92)
      {
        sub_100055C70("failed to allocate spproto", v171);
        return 0xFFFFFFFFLL;
      }
      v92[3] = 0;
      v92[10] = -1;
      uint64_t v93 = qword_10008F2D8;
      *((void *)v92 + 14) = *(void *)(qword_10008F2D8 + 264);
      uint64_t v94 = *(void *)(*(void *)(v93 + 264) + 16);
      if (v94)
      {
        *(void *)(v94 + 104) = v92;
        uint64_t v94 = *(void *)(*(void *)(v93 + 264) + 16);
      }
      *((void *)v92 + 12) = v94;
      *(void *)(*(void *)(v93 + 264) + 16) = v92;
      goto LABEL_289;
    case 0x123u:
      int v95 = malloc_type_malloc(0x10uLL, 0x1020040D5A9D86FuLL);
      if (!v95)
      {
        sub_100055C70("failed to allocate etypes", v171);
        return 0xFFFFFFFFLL;
      }
      *(_DWORD *)int v95 = *(void *)v5;
      v95[1] = 0;
      uint64_t v96 = *(void *)(qword_10008F2D8 + 16);
      if (v96)
      {
        do
        {
          uint64_t v97 = v96;
          uint64_t v96 = *(void *)(v96 + 8);
        }
        while (v96);
        *(void *)(v97 + 8) = v95;
      }
      else
      {
        *(void *)(qword_10008F2D8 + 16) = v95;
      }
      goto LABEL_289;
    case 0x124u:
      uint64_t v98 = qword_10008F2D8;
      *(_DWORD *)(qword_10008F2D8 + 104) = *((void *)v5 - 1);
      *(_DWORD *)(v98 + 64) = 1;
      *(void *)(v98 + 72) = 0;
      goto LABEL_289;
    case 0x126u:
      uint64_t v99 = qword_10008F2D8;
      *(_DWORD *)(qword_10008F2D8 + 104) = *((void *)v5 - 2);
      *(_DWORD *)(v99 + 64) = 1;
      *(void *)(v99 + 72) = *(void *)v5;
      goto LABEL_289;
    case 0x128u:
      int v100 = sub_100003988(5, *v5);
      if (v100 == -1) {
        goto LABEL_422;
      }
      uint64_t v101 = v100;
      goto LABEL_257;
    case 0x129u:
      uint64_t v102 = *(void *)v5;
      if (*(void *)v5 > 0x12uLL || ((0x3FC1uLL >> v102) & 1) != 0)
      {
LABEL_422:
        sub_100055C70("must be DH group", v171);
      }
      else
      {
        uint64_t v101 = dword_10006FC78[v102];
LABEL_257:
        unint64_t v103 = v101 - 1;
        if (v103 < 0x12 && ((0x3E013u >> v103) & 1) != 0)
        {
          uint64_t v17 = qword_100070210[v103];
          goto LABEL_289;
        }
        sub_100055C70("Invalid DH group specified", v171);
      }
      return 0xFFFFFFFFLL;
    case 0x12Fu:
      sub_100055C70("strength directive is obsoleted.");
      goto LABEL_289;
    case 0x131u:
      *(void *)(*(void *)(*(void *)(qword_10008F2D8 + 264) + 16) + 16) = *(void *)v5 * *((void *)v5 - 1);
      goto LABEL_289;
    case 0x135u:
      *(_DWORD *)(*(void *)(*(void *)(qword_10008F2D8 + 264) + 16) + 84) = *(void *)v5;
      goto LABEL_289;
    case 0x137u:
      uint64_t v104 = qword_10008F2D8;
      uint64_t v105 = *(void *)(*(void *)(qword_10008F2D8 + 264) + 16);
      if (*(_DWORD *)(v105 + 40) != 2)
      {
        sub_100055C70("wrong Vendor ID for gssapi_id", v171);
        return 0xFFFFFFFFLL;
      }
      int v106 = *(void **)(v105 + 48);
      if (v106)
      {
        free(v106);
        uint64_t v105 = *(void *)(*(void *)(v104 + 264) + 16);
      }
      v107 = strdup(*(const char **)(*(void *)v5 + 8));
      *(void *)(v105 + 48) = v107;
      if (!v107)
      {
        if (dword_10008FA20)
        {
          int v170 = ne_log_obj();
          if (os_log_type_enabled(v170, OS_LOG_TYPE_ERROR)) {
LABEL_501:
          }
            sub_10005ED40();
        }
LABEL_502:
        exit(1);
      }
      goto LABEL_289;
    case 0x139u:
      int v108 = sub_100003988(*(v5 - 4), *(v5 - 2));
      if (v108 == -1)
      {
        sub_100055C70("algorithm mismatched 1", v171);
        return 0xFFFFFFFFLL;
      }
      uint64_t v109 = *((void *)v5 - 2);
      if (v109 != 6)
      {
        if (v109 == 4)
        {
          *(_DWORD *)(*(void *)(*(void *)(qword_10008F2D8 + 264) + 16) + 80) = v108;
          goto LABEL_289;
        }
        if (v109 != 3)
        {
          sub_100055C70("algorithm mismatched 2", v171);
          return 0xFFFFFFFFLL;
        }
        *(_DWORD *)(*(void *)(*(void *)(qword_10008F2D8 + 264) + 16) + 76) = v108;
        int v110 = sub_10000377C(*(v5 - 4), *(v5 - 2));
        uint64_t v111 = *(void *)v5;
        if (v110)
        {
          if (v111)
          {
            int v112 = sub_1000037AC(*(v5 - 4), *(v5 - 2), v111);
            uint64_t v113 = *(void *)v5;
            if (v112 < 0)
            {
              sub_100055C70("invalid keylen %d");
              return 0xFFFFFFFFLL;
            }
            if (v113)
            {
              *(_DWORD *)(*(void *)(*(void *)(qword_10008F2D8 + 264) + 16) + 12) = v113;
              goto LABEL_289;
            }
          }
        }
        else if (v111)
        {
          sub_100055C70("keylen not allowed", v171);
          return 0xFFFFFFFFLL;
        }
        *(_DWORD *)(*(void *)(*(void *)(qword_10008F2D8 + 264) + 16) + 12) = v110;
        goto LABEL_289;
      }
      uint64_t v129 = *(void *)(*(void *)(qword_10008F2D8 + 264) + 16);
      *(_DWORD *)(v129 + 88) = v108;
      if (*((void *)v5 - 1) != 48) {
        goto LABEL_289;
      }
      if (*(_DWORD *)(v129 + 40) == -1)
      {
        *(_DWORD *)(v129 + 40) = 2;
        goto LABEL_289;
      }
      sub_100055C70("Vendor ID mismatch for auth method", v171);
      return 0xFFFFFFFFLL;
    case 0x13Bu:
    case 0x13Eu:
    case 0x143u:
    case 0x146u:
      uint64_t v17 = 1;
      goto LABEL_289;
    case 0x13Cu:
      uint64_t v17 = 60;
      goto LABEL_289;
    case 0x13Du:
      uint64_t v17 = 3600;
      goto LABEL_289;
    case 0x13Fu:
      uint64_t v17 = 1024;
      goto LABEL_289;
    case 0x140u:
      uint64_t v17 = 0x100000;
      goto LABEL_289;
    case 0x141u:
      uint64_t v17 = 0x40000000;
      goto LABEL_289;
    case 0x144u:
    case 0x147u:
      uint64_t v17 = 2;
      goto LABEL_289;
    default:
      goto LABEL_289;
  }
  do
  {
    if (dword_10008FA20)
    {
      uint64_t v134 = ne_log_obj();
      if (os_log_type_enabled(v134, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v151 = v182[2];
        if (!v151) {
          uint64_t v151 = *v130;
        }
        *(_DWORD *)__str = 134217984;
        *(void *)&__str[4] = v151;
        _os_log_debug_impl((void *)&_mh_execute_header, v134, OS_LOG_TYPE_DEBUG, "lifetime = %ld\n", (uint8_t *)__str, 0xCu);
      }
      if (dword_10008FA20)
      {
        v135 = ne_log_obj();
        if (os_log_type_enabled(v135, OS_LOG_TYPE_DEBUG))
        {
          int v152 = *((_DWORD *)v182 + 6);
          if (!v152) {
            int v152 = *((_DWORD *)v130 + 2);
          }
          *(_DWORD *)__str = 67109120;
          *(_DWORD *)&__str[4] = v152;
          _os_log_debug_impl((void *)&_mh_execute_header, v135, OS_LOG_TYPE_DEBUG, "lifebyte = %d\n", (uint8_t *)__str, 8u);
        }
        if (dword_10008FA20)
        {
          v136 = ne_log_obj();
          if (os_log_type_enabled(v136, OS_LOG_TYPE_DEBUG))
          {
            int v153 = *((_DWORD *)v182 + 3);
            *(_DWORD *)__str = 67109120;
            *(_DWORD *)&__str[4] = v153;
            _os_log_debug_impl((void *)&_mh_execute_header, v136, OS_LOG_TYPE_DEBUG, "encklen=%d\n", (uint8_t *)__str, 8u);
          }
        }
      }
    }
    *(_DWORD *)((char *)v195 + 3) = 0;
    unsigned int v137 = *((_DWORD *)v182 + 19);
    unsigned int v138 = *((_DWORD *)v182 + 20);
    v195[0] = 0;
    unsigned int v183 = v137;
    v195[3] = v137;
    v195[4] = v138;
    unsigned int v178 = v138;
    unsigned int v180 = *((_DWORD *)v182 + 21);
    unsigned int v181 = *((_DWORD *)v182 + 22);
    v195[5] = v180;
    v195[6] = v181;
    uint64_t v139 = v182[2];
    if (!v139) {
      uint64_t v139 = *v130;
    }
    uint64_t v177 = v139;
    int v140 = *((_DWORD *)v182 + 6);
    if (!v140) {
      int v140 = *((_DWORD *)v130 + 2);
    }
    int v176 = v140;
    int v174 = *((_DWORD *)v182 + 3);
    int v175 = *((_DWORD *)v182 + 10);
    if (dword_10008FA20)
    {
      v141 = ne_log_obj();
      if (os_log_type_enabled(v141, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)__str = 67109376;
        *(_DWORD *)&__str[4] = 1;
        *(_WORD *)&__str[8] = 1024;
        *(_DWORD *)&__str[10] = v179;
        _os_log_debug_impl((void *)&_mh_execute_header, v141, OS_LOG_TYPE_DEBUG, "p:%d t:%d\n", (uint8_t *)__str, 0xEu);
      }
    }
    for (uint64_t i = 3; i != 7; ++i)
    {
      uint64_t v143 = v195[i];
      snprintf(v196, 0xAuLL, "%d", v195[i]);
      if (dword_10008FA20)
      {
        v144 = ne_log_obj();
        if (os_log_type_enabled(v144, OS_LOG_TYPE_DEBUG))
        {
          v145 = sub_10003EE1C(i, v143);
          uint64_t v146 = "(";
          v147 = v196;
          if (v196[0] == 48) {
            v147 = (char *)&unk_100081F6D;
          }
          if (!v143) {
            uint64_t v146 = (const char *)&unk_100081F6D;
          }
          *(_DWORD *)__str = 136315906;
          *(void *)&__str[4] = v145;
          *(_WORD *)&__str[12] = 2080;
          v188 = v146;
          __int16 v189 = 2080;
          if (v143) {
            size_t v148 = ")";
          }
          else {
            size_t v148 = (const char *)&unk_100081F6D;
          }
          v190 = v147;
          __int16 v191 = 2080;
          v192 = v148;
          _os_log_debug_impl((void *)&_mh_execute_header, v144, OS_LOG_TYPE_DEBUG, "%s%s%s%s\n", (uint8_t *)__str, 0x2Au);
        }
      }
    }
    if (dword_10008FA20)
    {
      v149 = ne_log_obj();
      if (os_log_type_enabled(v149, OS_LOG_TYPE_DEBUG)) {
        sub_10006CDD4(&buf, v186, v149);
      }
    }
    CFDictionaryRef v1 = byte_10008FE9C + 356;
    if (!v183 || !v181 || !v180)
    {
      sub_10003EE1C(3, v183);
      sub_10003EE1C(6, v181);
      sub_10003EE1C(4, v178);
      sub_10003EE1C(5, v180);
      sub_100055C70("few definition of algorithm enc=%s ameth=%s hash=%s dhgroup=%s.\n");
LABEL_428:
      if (dword_10008FA20)
      {
        v158 = ne_log_obj();
        if (os_log_type_enabled(v158, OS_LOG_TYPE_ERROR)) {
          sub_10006CD6C();
        }
      }
      return 0xFFFFFFFFLL;
    }
    v150 = sub_100039060();
    v130 = v173;
    if (!v150)
    {
      sub_100055C70("failed to allocate isakmp sa");
      goto LABEL_428;
    }
    v150[1] = 1;
    v150[2] = v179;
    *((void *)v150 + 2) = v177;
    *((void *)v150 + 4) = v176;
    v150[10] = v183;
    v150[11] = v174;
    v150[12] = v181;
    v150[13] = v178;
    v150[18] = v178;
    v150[14] = v175;
    v150[15] = v180;
    sub_1000390A0((uint64_t)v150, v172);
    ++v179;
    v182 = (void *)v182[13];
  }
  while (v182);
  if (!*(void *)(v172 + 248))
  {
    if (dword_10008FA20)
    {
      v167 = ne_log_obj();
      if (os_log_type_enabled(v167, OS_LOG_TYPE_ERROR)) {
        sub_10006CDA0();
      }
    }
    return 0xFFFFFFFFLL;
  }
  if (!sub_100039040(qword_10008F2D8, 4)) {
    goto LABEL_407;
  }
  uint64_t v154 = qword_10008F2D8;
  uint64_t v155 = *(void *)(qword_10008F2D8 + 248);
  if (!v155)
  {
    *(_DWORD *)(qword_10008F2D8 + 188) = 0;
LABEL_492:
    sub_100055C70("DH group must be set in the proposal.\n", v171);
    return 0xFFFFFFFFLL;
  }
  int v156 = 0;
  do
  {
    if (v156)
    {
      if (v156 != *(_DWORD *)(v155 + 60))
      {
        sub_100055C70("DH group must be equal in all proposals when aggressive mode is used.\n", v171);
        return 0xFFFFFFFFLL;
      }
    }
    else
    {
      int v156 = *(_DWORD *)(v155 + 60);
    }
    uint64_t v155 = *(void *)(v155 + 80);
  }
  while (v155);
  *(_DWORD *)(qword_10008F2D8 + 188) = v156;
  if (!v156) {
    goto LABEL_492;
  }
  if ((sub_100029A30(v156, v154 + 192) & 0x80000000) == 0)
  {
LABEL_407:
    sub_100038EFC(qword_10008F2D8);
    goto LABEL_289;
  }
  sub_100055C70("failed to set DH value.\n", v171);
  return 0xFFFFFFFFLL;
}

void sub_100053810(uint64_t a1, int a2)
{
  uint64_t v4 = sub_100006B4C();
  if (v4)
  {
    int v5 = v4;
    v4[1] = a1;
    if (a1)
    {
      *((_DWORD *)v4 + 4) = -1;
      *((_DWORD *)v4 + 8) = a2;
      *((_DWORD *)v4 + 9) = 1;
      sub_100006DD8(v4, (void *)(qword_10008F848 + 120));
      *(_DWORD *)(qword_10008F848 + ++*(_DWORD *)(result + 112) = 0;
    }
    else
    {
      sub_100055C70("failed to copy sockaddr_storage ");
      sub_1000062F4(v5);
    }
  }
  else
  {
    sub_100055C70("failed to allocate myaddrs");
  }
}

void *sub_1000538D8()
{
  int v0 = malloc_type_calloc(1uLL, 0x28uLL, 0x102004081634310uLL);
  if (!v0) {
    sub_100055C70("failed to allocate proposal");
  }
  return v0;
}

uint64_t sub_100053928()
{
  if (dword_10008FA20)
  {
    int v0 = ne_log_obj();
    if (os_log_type_enabled(v0, OS_LOG_TYPE_DEBUG)) {
      sub_10006D058();
    }
  }
  sub_100056914();
  if (sub_100056744(*(const char **)qword_10008F848))
  {
    if (dword_10008FA20)
    {
      CFDictionaryRef v1 = ne_log_obj();
      if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR)) {
        sub_10006CFCC(v1);
      }
    }
  }
  else
  {
    if (!sub_1000510B4())
    {
      if (dword_100090754)
      {
        if (dword_10008FA20)
        {
          CFMutableDictionaryRef v6 = ne_log_obj();
          if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR)) {
            sub_10006CE88(v6);
          }
        }
        sub_100056950();
        exit(1);
      }
      sub_100056950();
      if (dword_10008FA20)
      {
        int v3 = ne_log_obj();
        uint64_t result = os_log_type_enabled(v3, OS_LOG_TYPE_DEBUG);
        if (!result) {
          return result;
        }
        sub_10006CE48();
      }
      return 0;
    }
    if (dword_100090754)
    {
      if (dword_10008FA20)
      {
        uint64_t v2 = ne_log_obj();
        if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR)) {
          sub_10006CF44(v2);
        }
      }
    }
    else if (dword_10008FA20)
    {
      int v5 = ne_log_obj();
      if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR)) {
        sub_10006CF10();
      }
    }
    sub_100056950();
  }
  return 0xFFFFFFFFLL;
}

uint64_t sub_100053A88(unsigned int a1)
{
  if (a1 > 0x1F)
  {
    if (!dword_10008FA20) {
      goto LABEL_11;
    }
    int v3 = ne_log_obj();
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR)) {
      sub_10006D1AC();
    }
  }
  else
  {
    if (!dword_10008FA20) {
      goto LABEL_11;
    }
    uint64_t v2 = ne_log_obj();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEBUG)) {
      sub_10006D128(a1, v2);
    }
  }
  if (dword_10008FA20)
  {
    uint64_t v4 = ne_log_obj();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG)) {
      sub_10006D098(a1 == 30, v4);
    }
  }
LABEL_11:
  BOOL v5 = a1 == 30;
  sub_100008750(v5);
  sub_100007DF0(v5);
  sub_100038FBC();
  sub_10003A6C0();
  sub_10003B3DC();
  sub_100027F1C();
  uint64_t v6 = sub_100053928();
  sub_100027F34();
  return v6;
}

uint64_t sub_100053B78()
{
  int v0 = &byte_10008E931[1743];
  CFDictionaryRef v1 = &byte_10008E931[1743];
  uint64_t v2 = &byte_10008FE9C[356];
  int v3 = &byte_10008E931[1743];
  if ((byte_10008F2E0 & 1) == 0)
  {
    byte_10008F2E0 = 1;
    if (!dword_10008F2E4) {
      dword_10008F2E4 = 1;
    }
    if (!qword_100090740) {
      qword_100090740 = (uint64_t)__stdinp;
    }
    if (!qword_100090748) {
      qword_100090748 = (uint64_t)__stdoutp;
    }
    uint64_t v4 = qword_10008F2E8;
    if (!qword_10008F2E8 || (uint64_t v5 = qword_10008F2F0, (v6 = *(void *)(qword_10008F2E8 + 8 * qword_10008F2F0)) == 0))
    {
      sub_100055AB0();
      uint64_t v6 = sub_100055B70((FILE *)qword_100090740, 0x4000);
      CFDictionaryRef v1 = &byte_10008E931[1743];
      int v0 = &byte_10008E931[1743];
      uint64_t v4 = qword_10008F2E8;
      uint64_t v5 = qword_10008F2F0;
      *(void *)(qword_10008F2E8 + 8 * qword_10008F2F0) = v6;
    }
    qword_10008F320 = *(void *)(v6 + 32);
    qword_10008F308 = *(void *)(v6 + 16);
    qword_100090760 = qword_10008F308;
    qword_100090740 = **(void **)(v4 + 8 * v5);
    byte_10008F310 = *(unsigned char *)qword_10008F308;
  }
  if ((byte_10008F2F8 & 1) == 0)
  {
    dword_10008F2E4 = 3;
    byte_10008F2F8 = 1;
  }
  int64_t v7 = &byte_10008E931[1743];
  unsigned int v8 = byte_1000702A0;
  uint64_t v9 = &byte_10008E931[1743];
  uint64_t v10 = word_10007433A;
  int v11 = &byte_10008E931[1743];
  int v12 = &byte_10008E931[1743];
  int v13 = &byte_10008FE9C[356];
LABEL_15:
  *((_DWORD *)v7 + 191) = 0;
  uint64_t v14 = *((void *)v1 + 97);
  if (v9[768] == 1)
  {
    *((_DWORD *)v7 + 191) = v14 - *((_DWORD *)v2 + 472);
    v9[768] = 0;
  }
  *(unsigned char *)uint64_t v14 = v3[784];
  LODWORD(v15) = *((_DWORD *)v0 + 185);
  uint64_t v16 = v14;
  do
  {
LABEL_18:
    uint64_t v17 = v8[*(unsigned __int8 *)v14];
    if (word_1000703A0[(int)v15])
    {
      *((_DWORD *)v12 + 197) = v15;
      *((void *)v11 + 99) = v14;
    }
    uint64_t v18 = (int)v15;
    uint64_t v19 = word_1000724B2[(int)v15] + v17;
    if (v15 != (__int16)word_1000712AE[v19])
    {
      do
      {
        uint64_t v18 = word_1000733D8[v18];
        if (v18 >= 1927) {
          uint64_t v17 = *((unsigned __int8 *)&unk_1000742FE + v17);
        }
        uint64_t v19 = word_1000724B2[v18] + v17;
      }
      while (word_1000712AE[v19] != (unsigned __int16)v18);
    }
    uint64_t v15 = v10[v19];
    ++v14;
  }
  while (word_1000724B2[v15] != 2246);
  while (2)
  {
    LOWORD(v20) = word_1000703A0[(int)v15];
    if (!(_WORD)v20)
    {
      uint64_t v14 = *((void *)v11 + 99);
      LOWORD(v20) = word_1000703A0[*((int *)v12 + 197)];
    }
    int v20 = (__int16)v20;
    uint64_t v21 = v16 - *((int *)v7 + 191);
    *((void *)v2 + 236) = v21;
    *((void *)v13 + 235) = v14 - v21;
    v3[784] = *(unsigned char *)v14;
    *(unsigned char *)uint64_t v14 = 0;
    *((void *)v1 + 97) = v14;
LABEL_28:
    switch(v20)
    {
      case 0:
        *(unsigned char *)uint64_t v14 = v3[784];
        uint64_t v14 = *((void *)v11 + 99);
        LODWORD(v15) = *((_DWORD *)v12 + 197);
        continue;
      case 1:
        *((_DWORD *)v0 + 185) = 7;
        return 258;
      case 2:
        qword_100090730 = 0;
        return 259;
      case 3:
        uint64_t v107 = 1;
        goto LABEL_147;
      case 4:
        uint64_t v107 = 2;
        goto LABEL_147;
      case 5:
        uint64_t v107 = 3;
        goto LABEL_147;
      case 6:
        uint64_t v107 = 4;
LABEL_147:
        qword_100090730 = v107;
        return 259;
      case 7:
      case 10:
      case 21:
      case 84:
        *((_DWORD *)v0 + 185) = 3;
        return 412;
      case 8:
        return 260;
      case 9:
        *((_DWORD *)v0 + 185) = 9;
        sub_100055BF8("it is obsoleted.  use \"my_identifier\" in each remote directives.", v10, v9, v11, v12, __nitems);
        return 261;
      case 11:
        return 373;
      case 12:
        *((_DWORD *)v0 + 185) = 11;
        return 263;
      case 13:
        uint64_t v105 = 3;
        goto LABEL_126;
      case 14:
        uint64_t v105 = 4;
        goto LABEL_126;
      case 15:
        uint64_t v105 = 5;
        goto LABEL_126;
      case 16:
        uint64_t v105 = 6;
        goto LABEL_126;
      case 17:
      case 18:
        goto LABEL_125;
      case 19:
      case 20:
        sub_100055BF8("it is obsoleted.  use \"debug2\"", v10, v9, v11, v12);
LABEL_125:
        uint64_t v105 = 7;
LABEL_126:
        qword_100090730 = v105;
        return 264;
      case 22:
        *((_DWORD *)v0 + 185) = 13;
        return 265;
      case 23:
      case 31:
      case 40:
      case 68:
      case 165:
        return 413;
      case 24:
        return 266;
      case 25:
        return 267;
      case 26:
        return 268;
      case 27:
        return 269;
      case 28:
        return 270;
      case 29:
      case 38:
      case 66:
      case 76:
      case 85:
      case 101:
        int v103 = 3;
        goto LABEL_119;
      case 30:
        *((_DWORD *)v0 + 185) = 15;
        return 271;
      case 32:
        return 272;
      case 33:
        return 273;
      case 34:
        return 274;
      case 35:
        return 276;
      case 36:
        return 277;
      case 37:
        return 275;
      case 39:
        *((_DWORD *)v0 + 185) = 19;
        return 278;
      case 41:
        return 279;
      case 42:
        return 280;
      case 43:
        return 281;
      case 44:
        return 282;
      case 45:
        return 283;
      case 46:
        return 284;
      case 47:
        return 285;
      case 48:
        return 292;
      case 49:
        return 294;
      case 50:
        return 293;
      case 51:
        return 286;
      case 52:
        return 290;
      case 53:
        return 291;
      case 54:
        return 287;
      case 55:
        return 288;
      case 56:
        return 296;
      case 57:
        return 295;
      case 58:
        return 297;
      case 59:
        return 298;
      case 60:
        return 299;
      case 61:
        return 300;
      case 62:
        return 301;
      case 63:
        return 302;
      case 64:
        return 303;
      case 65:
      case 96:
        return 415;
      case 67:
        *((_DWORD *)v0 + 185) = 17;
        return 304;
      case 69:
        return 305;
      case 70:
        return 306;
      case 71:
        return 307;
      case 72:
        return 308;
      case 73:
        return 309;
      case 74:
        return 310;
      case 75:
        return 311;
      case 77:
        *((_DWORD *)v0 + 185) = 25;
        return 315;
      case 78:
      case 98:
        return 319;
      case 79:
        return 386;
      case 80:
        return 388;
      case 81:
        return 316;
      case 82:
        return 317;
      case 83:
        int v108 = 27;
        goto LABEL_218;
      case 86:
        return 392;
      case 87:
        return 397;
      case 88:
      case 113:
        sub_100055BF8("it is obsoleted.  use \"my_identifier\".", v10, v9, v11, v12, __nitems);
        return 261;
      case 89:
      case 114:
        return 336;
      case 90:
      case 149:
      case 167:
        return 393;
      case 91:
      case 150:
      case 168:
        return 394;
      case 92:
      case 151:
      case 169:
        return 395;
      case 93:
        qword_100090730 = 0;
        return 312;
      case 94:
        uint64_t v109 = 1;
        goto LABEL_281;
      case 95:
        uint64_t v109 = 2;
        goto LABEL_281;
      case 97:
        *((_DWORD *)v0 + 185) = 29;
        return 318;
      case 99:
        return 320;
      case 100:
        int v108 = 31;
LABEL_218:
        *((_DWORD *)v0 + 185) = v108;
        return 413;
      case 102:
        return 321;
      case 103:
      case 296:
      case 298:
        goto LABEL_15;
      case 104:
        uint64_t v110 = 2;
        goto LABEL_223;
      case 105:
        uint64_t v110 = 4;
LABEL_223:
        qword_100090730 = v110;
        return 322;
      case 106:
        return 323;
      case 107:
        qword_100090730 = 1;
        return 324;
      case 108:
        return 325;
      case 109:
        return 422;
      case 110:
        uint64_t v111 = 1;
        goto LABEL_231;
      case 111:
        uint64_t v111 = 2;
        goto LABEL_231;
      case 112:
        uint64_t v111 = 4;
LABEL_231:
        qword_100090730 = v111;
        return 326;
      case 115:
        return 382;
      case 116:
        return 337;
      case 117:
        return 338;
      case 118:
        return 339;
      case 119:
        return 327;
      case 120:
        return 330;
      case 121:
        qword_100090730 = 4;
        return 348;
      case 122:
        uint64_t v93 = "plainrsa not supported.";
        goto LABEL_114;
      case 123:
      case 269:
        uint64_t v93 = "Apple specific features not compiled in.";
LABEL_114:
        uint64_t v94 = v1;
        int v95 = v10;
        uint64_t v96 = v9;
        uint64_t v97 = v11;
        sub_100055C70(v93, __nitems);
        int v12 = byte_10008E931 + 1743;
        int v11 = v97;
        uint64_t v9 = v96;
        uint64_t v10 = v95;
        int64_t v7 = byte_10008E931 + 1743;
        unsigned int v8 = byte_1000702A0;
        CFDictionaryRef v1 = v94;
        int v0 = byte_10008E931 + 1743;
        int v13 = byte_10008FE9C + 356;
        goto LABEL_15;
      case 124:
        return 340;
      case 125:
        return 343;
      case 126:
        return 344;
      case 127:
        return 329;
      case 128:
        return 347;
      case 129:
        return 331;
      case 130:
        return 332;
      case 131:
        return 333;
      case 132:
      case 173:
        return 351;
      case 133:
        return 350;
      case 134:
        return 362;
      case 135:
        sub_100055BF8("it is obsoleted.  use \"support_proxy\".", v10, v9, v11, v12);
        return 364;
      case 136:
        return 364;
      case 137:
        return 354;
      case 138:
        return 355;
      case 139:
        qword_100090730 = 2;
        return 357;
      case 140:
        return 358;
      case 141:
        return 359;
      case 142:
        return 360;
      case 143:
        uint64_t v112 = 1;
        goto LABEL_261;
      case 144:
        uint64_t v112 = 2;
        goto LABEL_261;
      case 145:
        uint64_t v112 = 4;
        goto LABEL_261;
      case 146:
        uint64_t v112 = 3;
LABEL_261:
        qword_100090730 = v112;
        return 361;
      case 147:
        return 352;
      case 148:
        return 353;
      case 152:
        return 374;
      case 153:
        return 375;
      case 154:
        return 376;
      case 155:
        return 377;
      case 156:
        return 378;
      case 157:
        return 379;
      case 158:
        return 380;
      case 159:
        return 381;
      case 160:
        return 389;
      case 161:
        return 390;
      case 162:
        return 391;
      case 163:
        return 383;
      case 164:
        *((_DWORD *)v0 + 185) = 33;
        return 365;
      case 166:
        int v103 = 31;
LABEL_119:
        *((_DWORD *)v0 + 185) = v103;
        return 414;
      case 170:
        uint64_t v109 = 3;
        goto LABEL_281;
      case 171:
        uint64_t v109 = 6;
        goto LABEL_281;
      case 172:
        uint64_t v109 = 4;
LABEL_281:
        qword_100090730 = v109;
        return 312;
      case 174:
      case 175:
        return 370;
      case 176:
        *((_DWORD *)v0 + 185) = 37;
        return 371;
      case 177:
        qword_100090730 = 1;
        return 372;
      case 178:
        qword_100090730 = 0;
        return 372;
      case 179:
        *((_DWORD *)v0 + 185) = 3;
        return 412;
      case 180:
        qword_100090730 = 1;
        return 399;
      case 181:
        qword_100090730 = 0;
        return 399;
      case 182:
        uint64_t v113 = (const char *)(*((void *)v2 + 236) + 1);
        *((void *)v2 + 236) = v113;
        qword_100090730 = atoi(v113);
        return 384;
      case 183:
        int v114 = (unsigned __int8 *)(*((void *)v2 + 236) + 1);
        do
          int v115 = *v114++;
        while (v115 != 93);
        *(v114 - 1) = 0;
        uint64_t v116 = (const char *)(*((void *)v2 + 236) + 1);
        *((void *)v2 + 236) = v116;
        qword_100090730 = atoi(v116);
        return 385;
      case 184:
        ++*((void *)v2 + 236);
        uint64_t v117 = sub_10003F940(*((void *)v13 + 235) + 1);
        qword_100090730 = (uint64_t)v117;
        if (!v117) {
          goto LABEL_407;
        }
        memcpy((void *)v117[1], *((const void **)v2 + 236), *v117);
        return 404;
      case 185:
        uint64_t v118 = 50;
        goto LABEL_304;
      case 186:
        uint64_t v118 = 51;
        goto LABEL_304;
      case 187:
        uint64_t v118 = 108;
        goto LABEL_304;
      case 188:
        uint64_t v118 = 1;
        goto LABEL_304;
      case 189:
        uint64_t v118 = 58;
        goto LABEL_304;
      case 190:
        uint64_t v118 = 6;
        goto LABEL_304;
      case 191:
        uint64_t v118 = 17;
LABEL_304:
        qword_100090730 = v118;
        return 387;
      case 192:
        uint64_t v106 = 1;
        goto LABEL_355;
      case 193:
        uint64_t v106 = 2;
        goto LABEL_355;
      case 194:
        uint64_t v106 = 3;
        goto LABEL_355;
      case 195:
        uint64_t v106 = 4;
        goto LABEL_355;
      case 196:
        uint64_t v106 = 5;
        goto LABEL_355;
      case 197:
        uint64_t v106 = 6;
        goto LABEL_355;
      case 198:
        uint64_t v106 = 7;
        goto LABEL_355;
      case 199:
        uint64_t v106 = 8;
        goto LABEL_355;
      case 200:
        uint64_t v106 = 9;
        goto LABEL_355;
      case 201:
        uint64_t v106 = 10;
        goto LABEL_355;
      case 202:
      case 203:
        uint64_t v106 = 11;
        goto LABEL_355;
      case 204:
      case 205:
        uint64_t v106 = 12;
        goto LABEL_355;
      case 206:
        uint64_t v106 = 13;
        goto LABEL_355;
      case 207:
        uint64_t v106 = 18;
        goto LABEL_355;
      case 208:
        uint64_t v106 = 14;
        goto LABEL_355;
      case 209:
        uint64_t v106 = 15;
        goto LABEL_355;
      case 210:
      case 211:
        uint64_t v106 = 19;
        goto LABEL_355;
      case 212:
      case 213:
        uint64_t v106 = 20;
        goto LABEL_355;
      case 214:
      case 215:
        uint64_t v106 = 21;
        goto LABEL_355;
      case 216:
        uint64_t v106 = 22;
        goto LABEL_355;
      case 217:
        uint64_t v106 = 23;
        goto LABEL_355;
      case 218:
        uint64_t v106 = 16;
        goto LABEL_355;
      case 219:
        uint64_t v106 = 17;
        goto LABEL_355;
      case 220:
        uint64_t v106 = 27;
        goto LABEL_355;
      case 221:
        uint64_t v106 = 28;
        goto LABEL_355;
      case 222:
        uint64_t v106 = 29;
        goto LABEL_355;
      case 223:
      case 224:
        uint64_t v106 = 30;
        goto LABEL_355;
      case 225:
      case 226:
        uint64_t v106 = 31;
        goto LABEL_355;
      case 227:
      case 228:
        uint64_t v106 = 32;
        goto LABEL_355;
      case 229:
        uint64_t v106 = 24;
        goto LABEL_355;
      case 230:
        uint64_t v106 = 25;
        goto LABEL_355;
      case 231:
        uint64_t v106 = 26;
        goto LABEL_355;
      case 232:
        uint64_t v106 = 33;
        goto LABEL_355;
      case 233:
        uint64_t v106 = 34;
        goto LABEL_355;
      case 234:
        uint64_t v106 = 37;
        goto LABEL_355;
      case 235:
        uint64_t v106 = 35;
        goto LABEL_355;
      case 236:
        uint64_t v106 = 36;
        goto LABEL_355;
      case 237:
        uint64_t v106 = 38;
        goto LABEL_355;
      case 238:
        uint64_t v106 = 39;
        goto LABEL_355;
      case 239:
        uint64_t v106 = 40;
        goto LABEL_355;
      case 240:
        uint64_t v106 = 41;
        goto LABEL_355;
      case 241:
        uint64_t v106 = 42;
        goto LABEL_355;
      case 242:
        uint64_t v106 = 43;
        goto LABEL_355;
      case 243:
        uint64_t v106 = 45;
        goto LABEL_355;
      case 244:
        uint64_t v106 = 44;
        goto LABEL_355;
      case 245:
        uint64_t v106 = 46;
        goto LABEL_355;
      case 246:
        uint64_t v106 = 47;
        goto LABEL_355;
      case 247:
        uint64_t v106 = 48;
        goto LABEL_355;
      case 248:
        uint64_t v106 = 49;
        goto LABEL_355;
      case 249:
        uint64_t v106 = 50;
        goto LABEL_355;
      case 250:
        uint64_t v106 = 51;
        goto LABEL_355;
      case 251:
        uint64_t v106 = 52;
        goto LABEL_355;
      case 252:
        uint64_t v106 = 53;
        goto LABEL_355;
      case 253:
        uint64_t v106 = 54;
        goto LABEL_355;
      case 254:
        uint64_t v106 = 55;
        goto LABEL_355;
      case 255:
        uint64_t v106 = 56;
        goto LABEL_355;
      case 256:
        uint64_t v106 = 57;
        goto LABEL_355;
      case 257:
        uint64_t v106 = 58;
LABEL_355:
        qword_100090730 = v106;
        return 313;
      case 258:
        sub_100055BF8("it is obsoleted.", v10, v9, v11, v12);
        return 262;
      case 259:
        uint64_t v119 = 2;
        goto LABEL_366;
      case 260:
        uint64_t v119 = 1;
        goto LABEL_366;
      case 261:
        uint64_t v119 = 3;
        goto LABEL_366;
      case 262:
        uint64_t v119 = 8;
        goto LABEL_366;
      case 263:
        uint64_t v119 = 4;
        goto LABEL_366;
      case 264:
        uint64_t v119 = 7;
        goto LABEL_366;
      case 265:
        goto LABEL_365;
      case 266:
        sub_100055BF8("certname will be obsoleted in near future.", v10, v9, v11, v12);
LABEL_365:
        uint64_t v119 = 5;
LABEL_366:
        qword_100090730 = v119;
        return 334;
      case 267:
        qword_100090730 = 0;
        return 341;
      case 268:
        uint64_t v120 = 1;
        goto LABEL_370;
      case 270:
        uint64_t v120 = 3;
LABEL_370:
        qword_100090730 = v120;
        return 341;
      case 271:
        qword_100090730 = 0;
        return 345;
      case 272:
        qword_100090730 = 1;
        return 345;
      case 273:
        uint64_t v121 = 2;
        goto LABEL_376;
      case 274:
        uint64_t v121 = 1;
LABEL_376:
        qword_100090730 = v121;
        return 346;
      case 275:
        uint64_t v122 = 2;
        goto LABEL_379;
      case 276:
        uint64_t v122 = 1;
LABEL_379:
        qword_100090730 = v122;
        return 335;
      case 277:
        return 405;
      case 278:
        return 406;
      case 279:
        return 407;
      case 280:
        return 408;
      case 281:
        return 409;
      case 282:
        return 410;
      case 283:
        return 411;
      case 284:
        return 416;
      case 285:
        return 417;
      case 286:
        return 418;
      case 287:
        return 421;
      case 288:
        return 419;
      case 289:
        return 420;
      case 290:
        qword_100090730 = 1;
        return 400;
      case 291:
        qword_100090730 = 0;
        return 400;
      case 292:
        __endptr = 0;
        qword_100090730 = strtol(*((const char **)v2 + 236), &__endptr, 10);
        return 398;
      case 293:
        int v123 = sub_10003F940(*((void *)v13 + 235) + (*((void *)v13 + 235) & 1) + 1);
        qword_100090730 = (uint64_t)v123;
        if (!v123) {
          goto LABEL_407;
        }
        int v124 = (_WORD *)v123[1];
        *int v124 = 30768;
        uint64_t v125 = v124 + 1;
        uint64_t v126 = *((void *)v13 + 235);
        if (v126)
        {
          uint64_t v125 = (char *)v124 + 3;
          *((unsigned char *)v124 + 2) = 48;
          uint64_t v126 = *((void *)v13 + 235);
        }
        memcpy(v125, (const void *)(*((void *)v2 + 236) + 2), v126 - 1);
        return 401;
      case 294:
        uint64_t v127 = (unsigned __int8 *)(*((void *)v2 + 236) + 1);
        do
          int v128 = *v127++;
        while (v128 != 34);
        *(v127 - 1) = 0;
        uint64_t v129 = sub_10003F940(*((void *)v13 + 235) - 1);
        qword_100090730 = (uint64_t)v129;
        if (!v129) {
          goto LABEL_407;
        }
        memcpy((void *)v129[1], (const void *)(*((void *)v2 + 236) + 1), *v129);
        return 402;
      case 295:
        v130 = sub_10003F940(*((void *)v13 + 235) + 1);
        qword_100090730 = (uint64_t)v130;
        if (v130)
        {
          memcpy((void *)v130[1], *((const void **)v2 + 236), *v130);
          return 403;
        }
        else
        {
LABEL_407:
          sub_100055C70("vmalloc failed", __nitems);
          return 0xFFFFFFFFLL;
        }
      case 297:
        ++dword_10008F330[32 * (uint64_t)dword_10008F330[0] + 8];
        goto LABEL_15;
      case 299:
        return 412;
      case 300:
        v9[768] = 1;
        goto LABEL_15;
      case 301:
        size_t v98 = *((void *)v13 + 235);
        uint64_t v99 = v0;
        int v100 = v1;
        uint64_t v101 = v7;
        uint64_t v102 = v12;
        fwrite(*((const void **)v2 + 236), v98, 1uLL, (FILE *)qword_100090748);
        int v12 = v102;
        int v11 = byte_10008E931 + 1743;
        uint64_t v9 = byte_10008E931 + 1743;
        uint64_t v10 = word_10007433A;
        int64_t v7 = v101;
        unsigned int v8 = byte_1000702A0;
        CFDictionaryRef v1 = v100;
        int v0 = v99;
        int v13 = byte_10008FE9C + 356;
        goto LABEL_15;
      case 302:
        uint64_t v136 = v16;
        uint64_t v22 = *((void *)v2 + 236);
        *(unsigned char *)uint64_t v14 = v3[784];
        uint64_t v23 = qword_10008F2E8;
        uint64_t v24 = qword_10008F2F0;
        uint64_t v25 = *(void *)(qword_10008F2E8 + 8 * qword_10008F2F0);
        if (*(_DWORD *)(v25 + 64))
        {
          uint64_t v26 = qword_10008F320;
        }
        else
        {
          uint64_t v26 = *(void *)(v25 + 32);
          qword_10008F320 = v26;
          *(void *)uint64_t v25 = qword_100090740;
          uint64_t v25 = *(void *)(v23 + 8 * v24);
          *(_DWORD *)(v25 + 64) = 1;
        }
        unint64_t v27 = *((void *)v1 + 97);
        uint64_t v28 = *(unsigned char **)(v25 + 8);
        if (v27 <= (unint64_t)&v28[v26])
        {
          uint64_t v2 = &byte_10008FE9C[356];
          uint64_t v14 = qword_100090760 + ~v22 + (int)v14;
          uint64_t v68 = v1;
          *((void *)v1 + 97) = v14;
          uint64_t v69 = v11;
          uint64_t v70 = v12;
          LODWORD(v15) = sub_100055FA4();
          int v12 = v70;
          int v11 = v69;
          if (word_1000703A0[(int)v15])
          {
            *((_DWORD *)v70 + 197) = v15;
            *((void *)v69 + 99) = v14;
          }
          uint64_t v71 = (int)v15;
          uint64_t v72 = word_1000724B2[(int)v15] + 1;
          int v0 = byte_10008E931 + 1743;
          CFDictionaryRef v1 = v68;
          int v3 = byte_10008E931 + 1743;
          int v13 = byte_10008FE9C + 356;
          int64_t v7 = &byte_10008E931[1743];
          unsigned int v8 = byte_1000702A0;
          uint64_t v10 = word_10007433A;
          uint64_t v9 = byte_10008E931 + 1743;
          if (v15 != (__int16)word_1000712AE[v72])
          {
            do
            {
              int v73 = (unsigned __int16)word_1000733D8[v71];
              uint64_t v71 = (__int16)v73;
              uint64_t v72 = word_1000724B2[(__int16)v73] + 1;
            }
            while (v73 != word_1000712AE[v72]);
          }
          int v74 = (unsigned __int16)word_10007433A[v72];
          uint64_t v16 = qword_100090760 + dword_10008F2FC;
          if (word_10007433A[v72] && v74 != 1926)
          {
            LODWORD(v15) = (__int16)v74;
            *((void *)v1 + 97) = ++v14;
            goto LABEL_18;
          }
          continue;
        }
        int v132 = v22;
        if (v27 > (unint64_t)&v28[v26 + 1]) {
          sub_100056084("fatal flex scanner internal error--end of buffer missed");
        }
        uint64_t v29 = (char *)qword_100090760;
        if (!*(_DWORD *)(v25 + 60))
        {
          uint64_t v33 = *((int *)v7 + 191);
          uint64_t v2 = byte_10008FE9C + 356;
          int v0 = byte_10008E931 + 1743;
          if (v27 - (qword_100090760 + v33) != 1) {
            goto LABEL_90;
          }
          goto LABEL_84;
        }
        int v30 = ~qword_100090760 + v27;
        if (v30 >= 1)
        {
          int v31 = ~qword_100090760 + v27;
          do
          {
            char v32 = *v29++;
            *v28++ = v32;
            --v31;
          }
          while (v31);
          uint64_t v25 = *(void *)(v23 + 8 * v24);
        }
        uint64_t v137 = v30;
        if (*(_DWORD *)(v25 + 64) == 2)
        {
          qword_10008F320 = 0;
          goto LABEL_41;
        }
        uint64_t v34 = ~v30;
        int v35 = *(_DWORD *)(v25 + 24);
        unsigned int v36 = v35 + v34;
        int v133 = v30;
        if (!(v35 + v34))
        {
          do
          {
            if (!*(_DWORD *)(v25 + 40))
            {
              *(void *)(v25 + 8) = 0;
LABEL_410:
              sub_100056084("fatal error - scanner input buffer overflow");
            }
            uint64_t v37 = v34;
            int v38 = v27;
            int v39 = v1;
            uint64_t v40 = *(void **)(v25 + 8);
            int v41 = 2 * v35;
            *(_DWORD *)(v25 + 24) = v41;
            uint64_t v42 = v25;
            uint64_t v43 = malloc_type_realloc(v40, v41 + 2, 0xCDB0C269uLL);
            *(void *)(v42 + 8) = v43;
            if (!v43) {
              goto LABEL_410;
            }
            unint64_t v27 = (unint64_t)v43 + v38 - (int)v40;
            CFDictionaryRef v1 = v39;
            *((void *)v39 + 97) = v27;
            uint64_t v25 = *(void *)(qword_10008F2E8 + 8 * qword_10008F2F0);
            int v35 = *(_DWORD *)(v25 + 24);
            uint64_t v34 = v37;
            unsigned int v36 = v35 + v37;
          }
          while (!(v35 + v37));
          unsigned int v8 = byte_1000702A0;
          int v30 = v133;
        }
        if (v36 >= 0x2000) {
          size_t v44 = 0x2000;
        }
        else {
          size_t v44 = v36;
        }
        if (*(_DWORD *)(v25 + 44))
        {
          size_t v45 = v44;
          unint64_t v46 = 0;
          while (1)
          {
            int v47 = getc((FILE *)qword_100090740);
            if (v47 == -1 || v47 == 10) {
              break;
            }
            *(unsigned char *)(*(void *)(*(void *)(qword_10008F2E8 + 8 * qword_10008F2F0) + 8) + v137 + v46++) = v47;
            if (v45 == v46)
            {
              unint64_t v46 = v45;
              break;
            }
          }
          if (v47 == -1)
          {
            int v52 = ferror((FILE *)qword_100090740);
            int64_t v7 = &byte_10008E931[1743];
            uint64_t v9 = byte_10008E931 + 1743;
            int v11 = byte_10008E931 + 1743;
            int v12 = byte_10008E931 + 1743;
            if (v52) {
LABEL_413:
            }
              sub_100056084("input in flex scanner failed");
          }
          else
          {
            if (v47 == 10) {
              *(unsigned char *)(*(void *)(*(void *)(qword_10008F2E8 + 8 * qword_10008F2F0) + 8) + v137 + v46++) = 10;
            }
            int64_t v7 = byte_10008E931 + 1743;
            uint64_t v9 = byte_10008E931 + 1743;
            int v11 = byte_10008E931 + 1743;
            int v12 = byte_10008E931 + 1743;
          }
          qword_10008F320 = v46;
LABEL_72:
          uint64_t v23 = qword_10008F2E8;
          uint64_t v24 = qword_10008F2F0;
          uint64_t v25 = *(void *)(qword_10008F2E8 + 8 * qword_10008F2F0);
          *(void *)(v25 + 32) = v46;
          if (v46)
          {
            int v53 = 0;
            int v30 = v133;
            int v3 = byte_10008E931 + 1743;
            goto LABEL_78;
          }
          int v30 = v133;
          int v3 = byte_10008E931 + 1743;
        }
        else
        {
          *__error() = 0;
          size_t v49 = fread((void *)(*(void *)(*(void *)(qword_10008F2E8 + 8 * qword_10008F2F0) + 8) + v30), 1uLL, v44, (FILE *)qword_100090740);
          size_t v50 = v44;
          unint64_t v46 = (int)v49;
          qword_10008F320 = (int)v49;
          int64_t v7 = byte_10008E931 + 1743;
          uint64_t v9 = byte_10008E931 + 1743;
          int v11 = byte_10008E931 + 1743;
          int v12 = byte_10008E931 + 1743;
          if (v49 << 32) {
            goto LABEL_72;
          }
          size_t __nitems = v50;
          while (ferror((FILE *)qword_100090740))
          {
            if (*__error() != 4) {
              goto LABEL_413;
            }
            *__error() = 0;
            clearerr((FILE *)qword_100090740);
            size_t v51 = fread((void *)(*(void *)(*(void *)(qword_10008F2E8 + 8 * qword_10008F2F0) + 8) + v137), 1uLL, __nitems, (FILE *)qword_100090740);
            unint64_t v46 = (int)v51;
            qword_10008F320 = (int)v51;
            if (v51 << 32)
            {
              int64_t v7 = byte_10008E931 + 1743;
              uint64_t v9 = byte_10008E931 + 1743;
              int v11 = byte_10008E931 + 1743;
              int v12 = byte_10008E931 + 1743;
              goto LABEL_72;
            }
          }
          uint64_t v23 = qword_10008F2E8;
          uint64_t v24 = qword_10008F2F0;
          uint64_t v25 = *(void *)(qword_10008F2E8 + 8 * qword_10008F2F0);
          int64_t v7 = byte_10008E931 + 1743;
          uint64_t v9 = byte_10008E931 + 1743;
          int v11 = byte_10008E931 + 1743;
          int v12 = byte_10008E931 + 1743;
          int v30 = v133;
          int v3 = byte_10008E931 + 1743;
LABEL_41:
          *(void *)(v25 + 32) = 0;
        }
        if (*((_DWORD *)v7 + 191) == v30)
        {
          uint64_t v54 = v7;
          int v134 = v30;
          uint64_t v55 = v11;
          sub_1000560BC((FILE *)qword_100090740);
          int v12 = byte_10008E931 + 1743;
          int v11 = v55;
          int v30 = v134;
          uint64_t v9 = byte_10008E931 + 1743;
          int64_t v7 = v54;
          unint64_t v46 = qword_10008F320;
          uint64_t v23 = qword_10008F2E8;
          uint64_t v24 = qword_10008F2F0;
          uint64_t v25 = *(void *)(qword_10008F2E8 + 8 * qword_10008F2F0);
          int v53 = 1;
        }
        else
        {
          unint64_t v46 = 0;
          int v53 = 2;
          *(_DWORD *)(v25 + 64) = 2;
        }
LABEL_78:
        unint64_t v56 = v46 + v30;
        if (v56 <= *(int *)(v25 + 24))
        {
          uint64_t v63 = *(void *)(v25 + 8);
          int v0 = &byte_10008E931[1743];
          CFDictionaryRef v1 = &byte_10008E931[1743];
        }
        else
        {
          int v135 = v53;
          uint64_t v57 = v9;
          __int16 v58 = v8;
          uint64_t v59 = v7;
          size_t v60 = v56 + (v46 >> 1);
          unsigned int v61 = malloc_type_realloc(*(void **)(v25 + 8), v60, 0xCDB0C269uLL);
          uint64_t v23 = qword_10008F2E8;
          uint64_t v24 = qword_10008F2F0;
          *(void *)(*(void *)(qword_10008F2E8 + 8 * qword_10008F2F0) + 8) = v61;
          uint64_t v62 = *(void *)(v23 + 8 * v24);
          uint64_t v63 = *(void *)(v62 + 8);
          if (!v63) {
            sub_100056084("out of dynamic memory in yy_get_next_buffer()");
          }
          *(_DWORD *)(v62 + 24) = v60 - 2;
          unint64_t v56 = qword_10008F320 + v137;
          int v0 = byte_10008E931 + 1743;
          CFDictionaryRef v1 = byte_10008E931 + 1743;
          int64_t v7 = v59;
          unsigned int v8 = v58;
          uint64_t v9 = v57;
          int v11 = byte_10008E931 + 1743;
          int v12 = byte_10008E931 + 1743;
          int v53 = v135;
        }
        qword_10008F320 = v56;
        *(unsigned char *)(v63 + v56) = 0;
        *(unsigned char *)(v56 + *(void *)(*(void *)(v23 + 8 * v24) + 8) + 1) = 0;
        uint64_t v29 = *(char **)(*(void *)(v23 + 8 * v24) + 8);
        qword_100090760 = (uint64_t)v29;
        if (v53 == 1)
        {
          uint64_t v33 = *((int *)v7 + 191);
          uint64_t v2 = byte_10008FE9C + 356;
          uint64_t v10 = word_10007433A;
LABEL_84:
          *((void *)v1 + 97) = &v29[v33];
          int v64 = *((_DWORD *)v0 + 185);
          if (v64 >= 1) {
            --v64;
          }
          int v20 = (v64 >> 1) + 303;
          int v13 = byte_10008FE9C + 356;
          uint64_t v16 = v136;
          goto LABEL_28;
        }
        if (v53)
        {
          uint64_t v2 = &byte_10008FE9C[356];
          uint64_t v10 = word_10007433A;
          uint64_t v28 = *(unsigned char **)(*(void *)(qword_10008F2E8 + 8 * qword_10008F2F0) + 8);
          uint64_t v26 = qword_10008F320;
          uint64_t v33 = *((int *)v7 + 191);
LABEL_90:
          uint64_t v14 = (uint64_t)&v28[v26];
          *((void *)v1 + 97) = &v28[v26];
          int v65 = v7;
          uint64_t v66 = v10;
          uint64_t v67 = v11;
          LODWORD(v15) = sub_100055FA4();
          int v12 = byte_10008E931 + 1743;
          int v11 = v67;
          uint64_t v9 = byte_10008E931 + 1743;
          uint64_t v10 = v66;
          int64_t v7 = v65;
          unsigned int v8 = byte_1000702A0;
          CFDictionaryRef v1 = byte_10008E931 + 1743;
          int v3 = byte_10008E931 + 1743;
          int v0 = byte_10008E931 + 1743;
          uint64_t v16 = *((void *)v2 + 236) + v33;
          int v13 = byte_10008FE9C + 356;
          continue;
        }
        uint64_t v14 = (uint64_t)&v29[~v132 + (int)v14];
        *((void *)v1 + 97) = v14;
        int v75 = v1;
        uint64_t v76 = v7;
        uint64_t v77 = v9;
        uint64_t v78 = v11;
        LODWORD(v15) = sub_100055FA4();
        int v12 = byte_10008E931 + 1743;
        int v11 = v78;
        uint64_t v9 = v77;
        int64_t v7 = v76;
        unsigned int v8 = byte_1000702A0;
        CFDictionaryRef v1 = v75;
        int v0 = byte_10008E931 + 1743;
        uint64_t v2 = &byte_10008FE9C[356];
        uint64_t v16 = qword_100090760 + *((int *)v7 + 191);
        int v13 = byte_10008FE9C + 356;
        uint64_t v10 = word_10007433A;
        goto LABEL_18;
      case 303:
      case 304:
      case 305:
      case 306:
      case 307:
      case 308:
      case 309:
      case 310:
      case 311:
      case 312:
      case 313:
      case 314:
      case 315:
      case 316:
      case 317:
      case 318:
      case 319:
      case 320:
      case 321:
        if (qword_10008F2E8) {
          int v79 = *(void ***)(qword_10008F2E8 + 8 * qword_10008F2F0);
        }
        else {
          int v79 = 0;
        }
        sub_100055CE8(v79);
        while (1)
        {
          int v80 = dword_10008F330[0];
          uint64_t v81 = --dword_10008F330[0];
          uint64_t v82 = &dword_10008F330[32 * v81];
          unint64_t v85 = *((void *)v82 + 5);
          uint64_t v83 = (glob_t *)(v82 + 10);
          unint64_t v84 = v85;
          if (!v85) {
            break;
          }
          uint64_t v86 = *(void *)&dword_10008F330[32 * v81 + 18];
          if (!v86) {
            break;
          }
          uint64_t v87 = &dword_10008F330[32 * v81];
          unint64_t v90 = v87[32];
          long long v88 = v87 + 32;
          unint64_t v89 = v90;
          if (v84 <= v90) {
            break;
          }
          uint64_t v91 = *(const char **)(v86 + 8 * v89);
          _DWORD *v88 = v89 + 1;
          dword_10008F330[0] = v80;
          if (!sub_100055D64(v91))
          {
            uint64_t v92 = sub_100055B70((FILE *)qword_100090740, 0x4000);
            sub_100055EE0(v92);
            int v0 = &byte_10008E931[1743];
            dword_10008F2E4 = 3;
            goto LABEL_111;
          }
        }
        globfree(v83);
        if (dword_10008F330[0])
        {
          sub_100055EE0(*(void *)&dword_10008F330[32 * (uint64_t)dword_10008F330[0] + 6]);
          int v0 = byte_10008E931 + 1743;
LABEL_111:
          CFDictionaryRef v1 = byte_10008E931 + 1743;
          int v13 = byte_10008FE9C + 356;
          int64_t v7 = byte_10008E931 + 1743;
          uint64_t v10 = word_10007433A;
          uint64_t v9 = byte_10008E931 + 1743;
          int v11 = byte_10008E931 + 1743;
          int v12 = byte_10008E931 + 1743;
          goto LABEL_15;
        }
        return 0;
      default:
        sub_100056084("fatal flex scanner internal error--no action found");
    }
  }
}

void *sub_100055AB0()
{
  uint64_t result = (void *)qword_10008F2E8;
  if (qword_10008F2E8)
  {
    if (qword_10008F2F0 >= (unint64_t)(qword_10008F328 - 1))
    {
      uint64_t v1 = qword_10008F328 + 8;
      uint64_t result = malloc_type_realloc((void *)qword_10008F2E8, 8 * (qword_10008F328 + 8), 0xCDB0C269uLL);
      qword_10008F2E8 = (uint64_t)result;
      if (result)
      {
        uint64_t v2 = &result[qword_10008F328];
        *uint64_t v2 = 0u;
        v2[1] = 0u;
        v2[2] = 0u;
        v2[3] = 0u;
        qword_10008F328 = v1;
        return result;
      }
LABEL_8:
      sub_100056084("out of dynamic memory in yyensure_buffer_stack()");
    }
  }
  else
  {
    uint64_t result = malloc_type_malloc(8uLL, 0xFA1A264CuLL);
    qword_10008F2E8 = (uint64_t)result;
    if (!result) {
      goto LABEL_8;
    }
    *uint64_t result = 0;
    qword_10008F328 = 1;
    qword_10008F2F0 = 0;
  }
  return result;
}

uint64_t sub_100055B70(FILE *a1, int a2)
{
  uint64_t v4 = malloc_type_malloc(0x48uLL, 0xFA1A264CuLL);
  if (!v4
    || (uint64_t v5 = (uint64_t)v4, v4[6] = a2, v6 = malloc_type_malloc(a2 + 2, 0xFA1A264CuLL), (*(void *)(v5 + 8) = v6) == 0))
  {
    sub_100056084("out of dynamic memory in yy_create_buffer()");
  }
  *(_DWORD *)(v5 + 40) = 1;
  sub_10005616C(v5, a1);
  return v5;
}

void sub_100055BF8(char *__format, ...)
{
  va_start(va, __format);
  vsnprintf(__str, 0x200uLL, __format, va);
  sub_1000566F0();
}

void sub_100055C70(char *__format, ...)
{
  va_start(va, __format);
  vsnprintf(__str, 0x200uLL, __format, va);
  sub_10005668C();
}

void sub_100055CE8(void **a1)
{
  if (a1)
  {
    if (qword_10008F2E8) {
      uint64_t v2 = *(void ***)(qword_10008F2E8 + 8 * qword_10008F2F0);
    }
    else {
      uint64_t v2 = 0;
    }
    if (v2 == a1) {
      *(void *)(qword_10008F2E8 + 8 * qword_10008F2F0) = 0;
    }
    if (*((_DWORD *)a1 + 10)) {
      free(a1[1]);
    }
    free(a1);
  }
}

uint64_t sub_100055D64(const char *a1)
{
  uint64_t v2 = fopen(a1, "r");
  qword_100090740 = (uint64_t)v2;
  if (v2)
  {
    uint64_t v3 = dword_10008F330[0];
    if (*(void *)&dword_10008F330[32 * (uint64_t)dword_10008F330[0] + 2])
    {
      fclose(*((FILE **)&unk_10008F338 + 16 * (uint64_t)dword_10008F330[0] + 1));
      uint64_t v3 = dword_10008F330[0];
      free(*((void **)&unk_10008F338 + 16 * (uint64_t)dword_10008F330[0]));
      uint64_t v2 = (FILE *)qword_100090740;
    }
    uint64_t v4 = &dword_10008F330[32 * v3];
    *((void *)v4 + 2) = v2;
    uint64_t v5 = strdup(a1);
    *((void *)v4 + 1) = v5;
    if (!v5)
    {
      if (dword_10008FA20)
      {
        int v12 = ne_log_obj();
        if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR)) {
          sub_100065338(v12);
        }
      }
      exit(1);
    }
    uint8_t v4[8] = 1;
    if (!dword_10008FA20) {
      return 0;
    }
    uint64_t v6 = ne_log_obj();
    uint64_t result = os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG);
    if (result)
    {
      sub_10006D284((uint64_t)a1, v6);
      return 0;
    }
  }
  else
  {
    unsigned int v8 = __stderrp;
    uint64_t v9 = __error();
    uint64_t v10 = strerror(*v9);
    fprintf(v8, "failed to open file %s (%s)\n", a1, v10);
    if (dword_10008FA20)
    {
      int v11 = ne_log_obj();
      if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR)) {
        sub_10006D1E0((uint64_t)a1, v11);
      }
    }
    return 0xFFFFFFFFLL;
  }
  return result;
}

void *sub_100055EE0(uint64_t a1)
{
  uint64_t result = sub_100055AB0();
  uint64_t v3 = qword_10008F2E8;
  if (qword_10008F2E8)
  {
    uint64_t v4 = qword_10008F2F0;
    uint64_t v5 = *(void *)(qword_10008F2E8 + 8 * qword_10008F2F0);
    if (v5 == a1) {
      return result;
    }
    if (v5)
    {
      uint64_t v6 = qword_10008F308;
      *(unsigned char *)qword_10008F308 = byte_10008F310;
      *(void *)(*(void *)(v3 + 8 * v4) + 16) = v6;
      *(void *)(*(void *)(v3 + 8 * v4) + 32) = qword_10008F320;
    }
  }
  else
  {
    if (!a1) {
      return result;
    }
    uint64_t v4 = qword_10008F2F0;
  }
  *(void *)(v3 + 8 * v4) = a1;
  qword_10008F320 = *(void *)(a1 + 32);
  qword_10008F308 = *(void *)(a1 + 16);
  qword_100090760 = qword_10008F308;
  qword_100090740 = **(void **)(v3 + 8 * v4);
  byte_10008F310 = *(unsigned char *)qword_10008F308;
  return result;
}

uint64_t sub_100055FA4()
{
  uint64_t result = dword_10008F2E4;
  for (uint64_t i = (unsigned char *)(qword_100090760 + dword_10008F2FC); (unint64_t)i < qword_10008F308; ++i)
  {
    if (*i) {
      uint64_t v2 = byte_1000702A0[*i];
    }
    else {
      uint64_t v2 = &_mh_execute_header.magic + 1;
    }
    if (word_1000703A0[(int)result])
    {
      dword_10008F314 = result;
      qword_10008F318 = (uint64_t)i;
    }
    uint64_t v3 = (int)result;
    uint64_t v4 = word_1000724B2[(int)result] + v2;
    if (result != (__int16)word_1000712AE[v4])
    {
      do
      {
        uint64_t v3 = word_1000733D8[v3];
        if (v3 >= 1927) {
          uint64_t v2 = *((unsigned __int8 *)&unk_1000742FE + v2);
        }
        uint64_t v4 = word_1000724B2[v3] + v2;
      }
      while (word_1000712AE[v4] != (unsigned __int16)v3);
    }
    uint64_t result = word_10007433A[v4];
  }
  return result;
}

void sub_100056084(const char *a1)
{
}

int *sub_1000560BC(FILE *a1)
{
  if (!qword_10008F2E8 || (uint64_t v2 = *(void *)(qword_10008F2E8 + 8 * qword_10008F2F0)) == 0)
  {
    sub_100055AB0();
    uint64_t v2 = sub_100055B70((FILE *)qword_100090740, 0x4000);
    *(void *)(qword_10008F2E8 + 8 * qword_10008F2F0) = v2;
  }
  uint64_t result = sub_10005616C(v2, a1);
  uint64_t v4 = *(void *)(qword_10008F2E8 + 8 * qword_10008F2F0);
  uint64_t v5 = *(void *)(v4 + 32);
  qword_10008F308 = *(void *)(v4 + 16);
  qword_100090760 = qword_10008F308;
  uint64_t v6 = *(uint64_t **)(qword_10008F2E8 + 8 * qword_10008F2F0);
  qword_10008F320 = v5;
  qword_100090740 = *v6;
  byte_10008F310 = *(unsigned char *)qword_10008F308;
  return result;
}

int *sub_10005616C(uint64_t a1, FILE *a2)
{
  int v4 = *__error();
  sub_10005621C(a1);
  *(void *)a1 = a2;
  *(_DWORD *)(a1 + 60) = 1;
  uint64_t v5 = qword_10008F2E8;
  if (qword_10008F2E8) {
    uint64_t v5 = *(void *)(qword_10008F2E8 + 8 * qword_10008F2F0);
  }
  if (v5 != a1) {
    *(void *)(a1 + 52) = 1;
  }
  if (a2)
  {
    int v6 = fileno(a2);
    BOOL v7 = isatty(v6) > 0;
  }
  else
  {
    BOOL v7 = 0;
  }
  *(_DWORD *)(a1 + 44) = v7;
  uint64_t result = __error();
  *uint64_t result = v4;
  return result;
}

void *sub_10005620C(size_t a1)
{
  return malloc_type_malloc(a1, 0xFA1A264CuLL);
}

uint64_t sub_10005621C(uint64_t result)
{
  if (result)
  {
    *(void *)(result + 32) = 0;
    **(unsigned char **)(result + 8) = 0;
    *(unsigned char *)(*(void *)(result + 8) + 1) = 0;
    *(void *)(result + 16) = *(void *)(result + 8);
    *(_DWORD *)(result + 48) = 1;
    *(_DWORD *)(result + 64) = 0;
    if (qword_10008F2E8) {
      uint64_t v1 = *(void *)(qword_10008F2E8 + 8 * qword_10008F2F0);
    }
    else {
      uint64_t v1 = 0;
    }
    if (v1 == result)
    {
      uint64_t v2 = *(void *)(qword_10008F2E8 + 8 * qword_10008F2F0);
      qword_10008F320 = *(void *)(v2 + 32);
      qword_10008F308 = *(void *)(v2 + 16);
      qword_100090760 = qword_10008F308;
      qword_100090740 = **(void **)(qword_10008F2E8 + 8 * qword_10008F2F0);
      byte_10008F310 = *(unsigned char *)qword_10008F308;
    }
  }
  return result;
}

void *sub_1000562BC(void *result)
{
  if (result)
  {
    uint64_t v1 = result;
    uint64_t result = sub_100055AB0();
    uint64_t v2 = qword_10008F2E8;
    uint64_t v3 = qword_10008F2F0;
    if (qword_10008F2E8)
    {
      if (*(void *)(qword_10008F2E8 + 8 * qword_10008F2F0))
      {
        uint64_t v4 = qword_10008F308;
        *(unsigned char *)qword_10008F308 = byte_10008F310;
        *(void *)(*(void *)(v2 + 8 * v3) + 16) = v4;
        *(void *)(*(void *)(v2 + 8 * v3++) + 32) = qword_10008F320;
        qword_10008F2F0 = v3;
      }
    }
    *(void *)(v2 + 8 * v3) = v1;
    uint64_t v5 = v1[4];
    qword_10008F308 = v1[2];
    qword_100090760 = qword_10008F308;
    int v6 = *(uint64_t **)(v2 + 8 * v3);
    qword_10008F320 = v5;
    qword_100090740 = *v6;
    byte_10008F310 = *(unsigned char *)qword_10008F308;
  }
  return result;
}

void sub_10005636C()
{
  if (qword_10008F2E8)
  {
    int v0 = *(void ***)(qword_10008F2E8 + 8 * qword_10008F2F0);
    if (v0)
    {
      sub_100055CE8(v0);
      uint64_t v1 = qword_10008F2E8;
      uint64_t v2 = qword_10008F2F0;
      *(void *)(qword_10008F2E8 + 8 * qword_10008F2F0) = 0;
      if (v2)
      {
        uint64_t v3 = v2 - 1;
        qword_10008F2F0 = v3;
        uint64_t v4 = *(void *)(v1 + 8 * v3);
        if (v4)
        {
          qword_10008F320 = *(void *)(v4 + 32);
          qword_10008F308 = *(void *)(v4 + 16);
          qword_100090760 = qword_10008F308;
          qword_100090740 = **(void **)(v1 + 8 * v3);
          byte_10008F310 = *(unsigned char *)qword_10008F308;
        }
      }
    }
  }
}

char *sub_100056404(uint64_t a1, unint64_t a2)
{
  unint64_t v2 = a2 - 2;
  if (a2 < 2 || *(unsigned char *)(a1 + v2) || *(unsigned char *)(a2 + a1 - 1)) {
    return 0;
  }
  int v6 = (char *)malloc_type_malloc(0x48uLL, 0xFA1A264CuLL);
  if (!v6) {
    sub_100056084("out of dynamic memory in yy_scan_buffer()");
  }
  uint64_t v4 = v6;
  *((_DWORD *)v6 + 6) = v2;
  *((void *)v6 + 1) = a1;
  *((void *)v6 + 2) = a1;
  *(void *)int v6 = 0;
  *((void *)v6 + 4) = (int)v2;
  *((void *)v6 + 5) = 0;
  *((_DWORD *)v6 + 12) = 1;
  *(void *)(v6 + 60) = 0;
  sub_100055EE0((uint64_t)v6);
  return v4;
}

char *sub_1000564A4(char *a1)
{
  uint64_t v2 = (int)strlen(a1);

  return sub_1000564E0(a1, v2);
}

char *sub_1000564E0(char *a1, uint64_t a2)
{
  unint64_t v4 = a2 + 2;
  uint64_t v5 = malloc_type_malloc(a2 + 2, 0xFA1A264CuLL);
  if (!v5) {
    sub_100056084("out of dynamic memory in yy_scan_bytes()");
  }
  if (a2)
  {
    int v6 = v5;
    uint64_t v7 = a2;
    do
    {
      char v8 = *a1++;
      *v6++ = v8;
      --v7;
    }
    while (v7);
  }
  *(_WORD *)&v5[a2] = 0;
  uint64_t result = sub_100056404((uint64_t)v5, v4);
  if (!result) {
    sub_100056084("bad buffer in yy_scan_bytes()");
  }
  *((_DWORD *)result + 10) = 1;
  return result;
}

uint64_t sub_100056570()
{
  return dword_10008C534;
}

uint64_t sub_10005657C()
{
  return qword_100090740;
}

uint64_t sub_100056588()
{
  return qword_100090748;
}

uint64_t sub_100056594()
{
  return qword_100090758;
}

uint64_t sub_1000565A0()
{
  return qword_100090760;
}

uint64_t sub_1000565AC(uint64_t result)
{
  dword_10008C534 = result;
  return result;
}

uint64_t sub_1000565B8(uint64_t result)
{
  qword_100090740 = result;
  return result;
}

uint64_t sub_1000565C4(uint64_t result)
{
  qword_100090748 = result;
  return result;
}

uint64_t sub_1000565D0()
{
  return dword_100090750;
}

uint64_t sub_1000565DC(uint64_t result)
{
  dword_100090750 = result;
  return result;
}

uint64_t sub_1000565E8()
{
  for (uint64_t i = (void *)qword_10008F2E8; qword_10008F2E8; uint64_t i = (void *)qword_10008F2E8)
  {
    if (!i[qword_10008F2F0]) {
      break;
    }
    sub_100055CE8((void **)i[qword_10008F2F0]);
    *(void *)(qword_10008F2E8 + 8 * qword_10008F2F0) = 0;
    sub_10005636C();
  }
  free(i);
  qword_10008F2E8 = 0;
  qword_10008F2F0 = 0;
  qword_10008F328 = 0;
  qword_10008F308 = 0;
  byte_10008F2E0 = 0;
  dword_10008F2E4 = 0;
  qword_100090740 = 0;
  qword_100090748 = 0;
  return 0;
}

void *sub_100056680(void *a1, size_t a2)
{
  return malloc_type_realloc(a1, a2, 0xCDB0C269uLL);
}

void sub_10005668C()
{
  if (dword_10008FA20)
  {
    int v0 = ne_log_obj();
    if (os_log_type_enabled(v0, OS_LOG_TYPE_ERROR)) {
      sub_10006D2FC();
    }
  }
  ++dword_100090754;
}

void sub_1000566F0()
{
  if (dword_10008FA20)
  {
    int v0 = ne_log_obj();
    if (os_log_type_enabled(v0, OS_LOG_TYPE_ERROR)) {
      sub_10006D2FC();
    }
  }
}

uint64_t sub_100056744(const char *a1)
{
  if (dword_10008F330[0] < 10)
  {
    if (glob(a1, 2048, 0, (glob_t *)&dword_10008F330[32 * (uint64_t)dword_10008F330[0] + 10])
      || (uint64_t v6 = dword_10008F330[0], v7 = &dword_10008F330[32 * (uint64_t)dword_10008F330[0]], !*((void *)v7 + 5)))
    {
      if (dword_10008FA20)
      {
        unint64_t v4 = ne_log_obj();
        BOOL v5 = os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT);
        uint64_t result = 0;
        if (!v5) {
          return result;
        }
        int v16 = 136315138;
        uint64_t v17 = a1;
        _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "glob found no matches for path \"%s\"\n", (uint8_t *)&v16, 0xCu);
      }
      return 0;
    }
    else
    {
      v7[32] = 0;
      char v8 = v7 + 32;
      uint64_t v9 = qword_10008F2E8;
      if (qword_10008F2E8) {
        uint64_t v9 = *(void *)(qword_10008F2E8 + 8 * qword_10008F2F0);
      }
      uint64_t v10 = 0;
      int v11 = 0;
      *(void *)&dword_10008F330[32 * v6 + 6] = v9;
      LODWORD(v9) = v6 + 1;
      while (1)
      {
        int v12 = *(const char **)(*(void *)&dword_10008F330[32 * v6 + 18] + 8 * v10);
        *char v8 = v11 + 1;
        dword_10008F330[0] = v9;
        if (!sub_100055D64(v12)) {
          break;
        }
        uint64_t v9 = dword_10008F330[0];
        uint64_t v6 = --dword_10008F330[0];
        int v13 = &dword_10008F330[32 * v9 - 32];
        int v14 = v13[32];
        char v8 = v13 + 32;
        int v11 = v14;
        uint64_t v10 = v14;
        if (*((void *)v8 - 11) <= (unint64_t)v14) {
          return 0xFFFFFFFFLL;
        }
      }
      uint64_t v15 = sub_100055B70((FILE *)qword_100090740, 0x4000);
      sub_100055EE0(v15);
      uint64_t result = 0;
      dword_10008F2E4 = 3;
    }
  }
  else
  {
    if (dword_10008FA20)
    {
      uint64_t v1 = ne_log_obj();
      if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR)) {
        sub_10006D37C(v1);
      }
    }
    return 0xFFFFFFFFLL;
  }
  return result;
}

void sub_100056914()
{
  uint64_t v0 = &dword_100000008;
  do
  {
    uint64_t v1 = (_OWORD *)((char *)&dword_10008F330 + v0);
    v1[6] = 0uLL;
    v1[7] = 0uLL;
    v1[4] = 0uLL;
    v1[5] = 0uLL;
    v1[2] = 0uLL;
    v1[3] = 0uLL;
    v0 += 128;
    *uint64_t v1 = 0uLL;
    v1[1] = 0uLL;
  }
  while (v0 != 1288);
  dword_10008F330 = 0;
}

void sub_100056950()
{
  for (uint64_t i = 0; i != 320; i += 32)
  {
    uint64_t v1 = &dword_10008F330[i];
    if (*(void *)&dword_10008F330[i + 2])
    {
      fclose(*((FILE **)v1 + 2));
      free(*((void **)v1 + 1));
      *((void *)v1 + 1) = 0;
    }
  }
}

void sub_1000569E4()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "Phase 1 negotiation failed.\n", v2, v3, v4, v5, v6);
}

void sub_100056A18()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "failed to process packet.\n", v2, v3, v4, v5, v6);
}

void sub_100056A4C()
{
  sub_100002F08();
  _os_log_debug_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_DEBUG, "===\n", v1, 2u);
}

void sub_100056A8C()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "failed to pre-process packet.\n", v2, v3, v4, v5, v6);
}

void sub_100056AC0()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "Phase 2 negotiation failed.\n", v2, v3, v4, v5, v6);
}

void sub_100056AF4()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "no buffer found as sendbuf\n", v2, v3, v4, v5, v6);
}

void sub_100056B28()
{
  sub_100003B50(__stack_chk_guard);
  sub_100003B5C();
  sub_100003B34((void *)&_mh_execute_header, v0, v1, "hash(%s)\n", v2, v3, v4, v5, v6);
}

void sub_100056B90()
{
  sub_100003B50(__stack_chk_guard);
  sub_100003B5C();
  sub_100003B34((void *)&_mh_execute_header, v0, v1, "hmac(%s)\n", v2, v3, v4, v5, v6);
}

void sub_100056BF8()
{
  sub_100003B50(__stack_chk_guard);
  sub_100003B5C();
  sub_100003B34((void *)&_mh_execute_header, v0, v1, "encryption(%s)\n", v2, v3, v4, v5, v6);
}

void sub_100056C60(int a1, NSObject *a2)
{
  v2[0] = 67109120;
  v2[1] = a1;
  _os_log_error_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_ERROR, "unknown algorithm class %d\n", (uint8_t *)v2, 8u);
}

void sub_100056CD8(os_log_t log)
{
  *(_WORD *)uint64_t v1 = 0;
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "key length is not allowed", v1, 2u);
}

void sub_100056D1C(os_log_t log)
{
  *(_WORD *)uint64_t v1 = 0;
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "key length out of range\n", v1, 2u);
}

void sub_100056D60(int a1, NSObject *a2)
{
  v2[0] = 67109120;
  v2[1] = a1;
  _os_log_error_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_ERROR, "key length %d is not multiple of 8\n", (uint8_t *)v2, 8u);
}

void sub_100056DD8()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "unable to get a certifcate reference.\n", v2, v3, v4, v5, v6);
}

void sub_100056E0C()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "current time after valid time\n", v2, v3, v4, v5, v6);
}

void sub_100056E40()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "current time before valid time\n", v2, v3, v4, v5, v6);
}

void sub_100056E74()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "CFAbsoluteTimeGetCurrent() failed", v2, v3, v4, v5, v6);
}

void sub_100056EA8()
{
  sub_100004FB8();
  sub_100004868(v0);
  sub_100004F64();
  sub_100004F98((void *)&_mh_execute_header, v1, v2, "check_x509cert error %d %s.\n", v3, v4, v5, v6, v7);
}

void sub_100056F20()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "unable to create CFArray.\n", v2, v3, v4, v5, v6);
}

void sub_100056F54()
{
  sub_100004FB8();
  sub_100004868(v0);
  sub_100004F64();
  sub_100004F98((void *)&_mh_execute_header, v1, v2, "EvaluateCert error %d %s.\n", v3, v4, v5, v6, v7);
}

void sub_100056FCC()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "-----------------------------------------------------.\n", v2, v3, v4, v5, v6);
}

void sub_100057000()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "---------------Returned error strings: ---------------.\n", v2, v3, v4, v5, v6);
}

void sub_100057034(int *a1, NSObject *a2)
{
  int v2 = *a1;
  v3[0] = 67109120;
  v3[1] = v2;
  _os_log_debug_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_DEBUG, "eval result unknown: value = %d.\n", (uint8_t *)v3, 8u);
}

void sub_1000570B0()
{
  sub_100002F08();
  sub_100004F7C((void *)&_mh_execute_header, v0, v1, "eval uint64_t result = kSecTrustResultInvalid.\n", v2, v3, v4, v5, v6);
}

void sub_1000570E4()
{
  sub_100002F08();
  sub_100004F7C((void *)&_mh_execute_header, v0, v1, "eval uint64_t result = kSecTrustResultProceed.\n", v2, v3, v4, v5, v6);
}

void sub_100057118()
{
  sub_100002F08();
  sub_100004F7C((void *)&_mh_execute_header, v0, v1, "eval uint64_t result = kSecTrustResultDeny.\n", v2, v3, v4, v5, v6);
}

void sub_10005714C()
{
  sub_100002F08();
  sub_100004F7C((void *)&_mh_execute_header, v0, v1, "eval uint64_t result = kSecTrustResultUnspecified.\n", v2, v3, v4, v5, v6);
}

void sub_100057180()
{
  sub_100002F08();
  sub_100004F7C((void *)&_mh_execute_header, v0, v1, "eval uint64_t result = kSecTrustResultRecoverableTrustFailure.\n", v2, v3, v4, v5, v6);
}

void sub_1000571B4()
{
  sub_100002F08();
  sub_100004F7C((void *)&_mh_execute_header, v0, v1, "eval uint64_t result = kSecTrustResultFatalTrustFailure.\n", v2, v3, v4, v5, v6);
}

void sub_1000571E8()
{
  sub_100002F08();
  sub_100004F7C((void *)&_mh_execute_header, v0, v1, "eval uint64_t result = kSecTrustResultOtherError.\n", v2, v3, v4, v5, v6);
}

void sub_10005721C()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "Error evaluating certificate.\n", v2, v3, v4, v5, v6);
}

void sub_100057250(int a1, NSObject *a2)
{
  int v2 = 136315394;
  uint64_t v3 = "crypto_cssm_check_x509cert";
  __int16 v4 = 1024;
  int v5 = a1;
  _os_log_debug_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_DEBUG, "%s: checking chain of %d certificates.\n", (uint8_t *)&v2, 0x12u);
}

void sub_1000572DC()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "unable to create dictionary for policy properties.\n", v2, v3, v4, v5, v6);
}

void sub_100057310()
{
  sub_100004FB8();
  sub_100004868(v0);
  sub_100004F64();
  sub_100004F98((void *)&_mh_execute_header, v1, v2, "getsign error %d %s.\n", v3, v4, v5, v6, v7);
}

void sub_100057388()
{
  sub_100004FB8();
  sub_100004868(v0);
  sub_100004F64();
  sub_100004F98((void *)&_mh_execute_header, v1, v2, "get_x509cert error %d %s.\n", v3, v4, v5, v6, v7);
}

void sub_100057400()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "unable to allocate space for addr.\n", v2, v3, v4, v5, v6);
}

void sub_100057434()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "unable to duplicate addr.\n", v2, v3, v4, v5, v6);
}

void sub_100057468()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "unable to duplicate ifname.\n", v2, v3, v4, v5, v6);
}

void sub_10005749C()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "unable to allocate space for natt addr.\n", v2, v3, v4, v5, v6);
}

void sub_1000574D0(_DWORD *a1, char **a2)
{
  uint64_t v4 = __error();
  uint64_t v5 = strerror(*v4);
  *a1 = 136315138;
  *a2 = v5;
  sub_100007290((void *)&_mh_execute_header, v6, v7, "socket(SOCK_DGRAM) failed:%s\n");
}

void sub_100057530(_DWORD *a1, char **a2)
{
  uint64_t v4 = __error();
  uint64_t v5 = strerror(*v4);
  *a1 = 136315138;
  *a2 = v5;
  sub_100007290((void *)&_mh_execute_header, v6, v7, "ioctl(SIOCGIFAFLAG_IN6) failed:%s\n");
}

void sub_100057590(uint8_t *buf, unsigned char *a2, os_log_t log)
{
  *uint8_t buf = 0;
  *a2 = 0;
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "failed to put IPv6 socket in non-blocking mode\n", buf, 2u);
}

void sub_1000575D0(NSObject *a1)
{
  uint64_t v2 = __error();
  uint64_t v3 = strerror(*v2);
  int v4 = 136315138;
  uint64_t v5 = v3;
  _os_log_error_impl((void *)&_mh_execute_header, a1, OS_LOG_TYPE_ERROR, "getifaddrs failed: %s\n", (uint8_t *)&v4, 0xCu);
}

void sub_100057664()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "failed to allocate buffer for myaddrs.\n", v2, v3, v4, v5, v6);
}

void sub_100057698()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "failed to allocate buffer for duplicate addr.\n", v2, v3, v4, v5, v6);
}

void sub_1000576CC()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "failed to allocate buffer for duplicate ifname.\n", v2, v3, v4, v5, v6);
}

void sub_100057700(int a1, NSObject *a2)
{
  v2[0] = 67109120;
  v2[1] = a1;
  _os_log_debug_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_DEBUG, "%d addrs are configured successfully\n", (uint8_t *)v2, 8u);
}

void sub_100057778()
{
  sub_100002F08();
  sub_100004F7C((void *)&_mh_execute_header, v0, v1, "configuring default isakmp port.\n", v2, v3, v4, v5, v6);
}

void sub_1000577AC(uint8_t *buf, uint64_t a2, _DWORD *a3, os_log_t log)
{
  int v4 = *(unsigned __int8 *)(*(void *)a2 + 1);
  *(_DWORD *)uint8_t buf = 67109120;
  *a3 = v4;
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "unsupported AF %d\n", buf, 8u);
}

void sub_100057800(uint64_t a1, NSObject *a2)
{
  int v2 = *(unsigned __int8 *)(a1 + 1);
  v3[0] = 67109120;
  v3[1] = v2;
  _os_log_error_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_ERROR, "no socket matches address family %d\n", (uint8_t *)v3, 8u);
}

void sub_10005787C()
{
  int v0 = __error();
  strerror(*v0);
  sub_1000072B0((void *)&_mh_execute_header, v1, v2, "read(PF_ROUTE) failed: %s\n", v3, v4, v5, v6, 2u);
}

void sub_100057900()
{
  sub_100002F08();
  sub_100004F7C((void *)&_mh_execute_header, v0, v1, "read(PF_ROUTE) short read\n", v2, v3, v4, v5, v6);
}

void sub_100057934(unsigned __int8 *a1, NSObject *a2)
{
  int v2 = *a1;
  v3[0] = 67109120;
  v3[1] = v2;
  _os_log_debug_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_DEBUG, "caught rtm:%d, need update interface address list\n", (uint8_t *)v3, 8u);
}

void sub_1000579B0()
{
  int v0 = __error();
  strerror(*v0);
  sub_1000072B0((void *)&_mh_execute_header, v1, v2, "socket(PF_ROUTE) failed: %s", v3, v4, v5, v6, 2u);
}

void sub_100057A34()
{
  sub_100002F08();
  sub_100004F7C((void *)&_mh_execute_header, v0, v1, "could not create pfroute socket source.", v2, v3, v4, v5, v6);
}

void sub_100057A68()
{
  sub_100002F08();
  sub_100004F7C((void *)&_mh_execute_header, v0, v1, "failed to put PF_ROUTE socket in non-blocking mode\n", v2, v3, v4, v5, v6);
}

void sub_100057A9C()
{
  sub_100002F08();
  sub_100004F7C((void *)&_mh_execute_header, v0, v1, "no match\n", v2, v3, v4, v5, v6);
}

void sub_100057AD0()
{
  sub_100002F08();
  sub_100004F7C((void *)&_mh_execute_header, v0, v1, "matched\n", v2, v3, v4, v5, v6);
}

void sub_100057B04(_DWORD *a1, uint64_t a2, uint64_t **a3)
{
  uint64_t v5 = sub_10003CAE4(*(const sockaddr **)(a2 + 48));
  *a1 = 136315138;
  *a3 = v5;
  sub_10000A104((void *)&_mh_execute_header, v6, v7, "p->remote: %s\n");
}

void sub_100057B60(_DWORD *a1, uint64_t a2, uint64_t **a3)
{
  uint64_t v5 = sub_10003CAE4(*(const sockaddr **)(a2 + 56));
  *a1 = 136315138;
  *a3 = v5;
  sub_10000A104((void *)&_mh_execute_header, v6, v7, "p->local: %s\n");
}

void sub_100057BBC(const sockaddr *a1)
{
  sub_10003CAE4(a1);
  sub_1000072B0((void *)&_mh_execute_header, v1, v2, "remote: %s\n", v3, v4, v5, v6, 2u);
}

void sub_100057C38(const sockaddr *a1)
{
  sub_10003CAE4(a1);
  sub_1000072B0((void *)&_mh_execute_header, v1, v2, "local: %s\n", v3, v4, v5, v6, 2u);
}

void sub_100057CB4()
{
  sub_100002F08();
  sub_100004F7C((void *)&_mh_execute_header, v0, v1, "getph1byaddr: start\n", v2, v3, v4, v5, v6);
}

void sub_100057CE8()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "failed to allocate buffer.\n", v2, v3, v4, v5, v6);
}

void sub_100057D1C(uint64_t a1, NSObject *a2)
{
  int v2 = 134217984;
  uint64_t v3 = a1;
  _os_log_error_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_ERROR, "already responded within the past %ld secs\n", (uint8_t *)&v2, 0xCu);
}

void sub_100057D94()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "sendfromto failed\n", v2, v3, v4, v5, v6);
}

void sub_100057DC8(int *a1, uint64_t a2, os_log_t log)
{
  int v3 = *a1;
  uint64_t v4 = **(void **)(a2 + 24);
  v5[0] = 67109632;
  v5[1] = v3;
  __int16 v6 = 2048;
  uint64_t v7 = v4;
  __int16 v8 = 1024;
  int v9 = 1280;
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "!!! skipped retransmitting frags: frag_flags %x, r->sendbuf->l %zu, max %d\n", (uint8_t *)v5, 0x18u);
}

void sub_100057E6C()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "!!! retransmitting frags\n", v2, v3, v4, v5, v6);
}

void sub_100057EA0()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "failed to allocate extra buf for non-esp\n", v2, v3, v4, v5, v6);
}

void sub_100057ED4()
{
  sub_100002F08();
  sub_100004F7C((void *)&_mh_execute_header, v0, v1, "Adding NON-ESP marker\n", v2, v3, v4, v5, v6);
}

void sub_100057F08()
{
  sub_10000A0EC();
  sub_10000A124((void *)&_mh_execute_header, v0, v1, "Failed to get IPv4 address for Phase 1 (family=%u, NAT64Prefix=%u)\n", v2, v3);
}

void sub_100057F7C()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "Failed to extract IPv4 from Phase 1 IPv6 address.\n", v2, v3, v4, v5, v6);
}

void sub_100057FB0()
{
  sub_10000A0EC();
  sub_10000A124((void *)&_mh_execute_header, v0, v1, "Failed to get IPv4 address for Phase 2 (family=%u, NAT64Prefix=%u)\n", v2, v3);
}

void sub_100058024()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "Failed to extract IPv4 from Phase 2 IPv6 address.\n", v2, v3, v4, v5, v6);
}

void sub_100058058()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "no suitable proposal found.\n", v2, v3, v4, v5, v6);
}

void sub_10005808C(uint64_t a1)
{
  sub_10003EA90(*(_DWORD *)(*(void *)a1 + 48));
  sub_100011970();
  sub_10001197C();
  _os_log_debug_impl(v1, v2, v3, v4, v5, 0xCu);
}

void sub_100058114()
{
  sub_100002F08();
  sub_10001188C((void *)&_mh_execute_header, v0, v1, "an acceptable proposal found.\n", v2);
}

void sub_10005814C()
{
  sub_100003B50(__stack_chk_guard);
  sub_100003B5C();
  sub_100011870((void *)&_mh_execute_header, v0, v1, "Invalid SA length = %zu.\n", v2, v3, v4, v5, v6);
}

void sub_1000581B4()
{
  sub_10001181C();
  sub_1000117E8((void *)&_mh_execute_header, v0, v1, "invalid situation 0x%08x.\n", v2, v3, v4, v5, v6);
}

void sub_10005821C()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "failed to get buffer.\n", v2, v3, v4, v5, v6);
}

void sub_100058250()
{
  sub_100011964();
  sub_1000118D8();
  sub_1000117E8((void *)&_mh_execute_header, v0, v1, "Invalid payload type=%u\n", v2, v3, v4, v5, v6);
}

void sub_1000582B8()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "no Proposal found.\n", v2, v3, v4, v5, v6);
}

void sub_1000582EC(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_10005836C()
{
  sub_1000118D8();
  __int16 v3 = 2048;
  uint64_t v4 = v0;
  sub_1000118FC((void *)&_mh_execute_header, v1, (uint64_t)v1, "get_proppair invalid length of proposal spi size, expected %u actual %zu\n", v2);
}

void sub_1000583F4()
{
  sub_10001181C();
  sub_1000117E8((void *)&_mh_execute_header, v0, v1, "situation 0x%08x unsupported yet.\n", v2, v3, v4, v5, v6);
}

void sub_10005845C()
{
  sub_10001181C();
  sub_1000117E8((void *)&_mh_execute_header, v0, v1, "invalid value of DOI 0x%08x.\n", v2, v3, v4, v5, v6);
}

void sub_1000584C4(unsigned char *a1, unsigned char *a2)
{
  sub_100011828(a1, a2);
  sub_100011804((void *)&_mh_execute_header, v2, (uint64_t)v2, "Unexpected proposal_check value\n", v3);
}

void sub_1000584F4(unsigned char *a1, unsigned char *a2)
{
  sub_100011828(a1, a2);
  sub_100011854((void *)&_mh_execute_header, v2, v3, "Compared: DB:Peer\n", v4);
}

void sub_100058520(uint64_t a1, uint64_t a2)
{
  sub_10003E580(*(unsigned __int8 *)(a2 + 5), *(unsigned __int8 *)(a1 + 5));
  sub_10001197C();
  _os_log_debug_impl(v2, v3, v4, v5, v6, 0x12u);
}

void sub_1000585C0(uint64_t a1)
{
  sub_10003E344(*(unsigned __int8 *)(a1 + 5));
  sub_10001197C();
  _os_log_debug_impl(v1, v2, v3, v4, v5, 0x1Eu);
}

void sub_100058680()
{
  sub_100011838();
  sub_1000118BC((void *)&_mh_execute_header, v0, v1, "t2isakmpsa invalid length of isakmp data, expected %zu actual %d\n", v2, v3, v4, v5, v6);
}

void sub_1000586E8()
{
  sub_100011914();
  sub_10000A124((void *)&_mh_execute_header, v0, v1, "t2isakmpsa: packet too short - attr length %u for type %d\n", v2, v3);
}

void sub_10005875C()
{
  sub_1000118D8();
  sub_1000117E8((void *)&_mh_execute_header, v0, v1, "keylen must not be specified for encryption algorithm %d\n", v2, v3, v4, v5, v6);
}

void sub_1000587C8()
{
  sub_10001192C();
  sub_1000118FC((void *)&_mh_execute_header, v0, (uint64_t)v0, "invalid ISAKMP-SA attr - OAKLEY_ATTR_GRP_GEN_ONE, attr-len %d, overall-len %lu\n", v1);
}

void sub_100058838()
{
  sub_10001192C();
  sub_1000118FC((void *)&_mh_execute_header, v0, (uint64_t)v0, "invalid ISAKMP-SA attr - OAKLEY_ATTR_GRP_GEN_TWO, attr-len %d, overall-len %lu\n", v1);
}

void sub_1000588A8(unsigned char *a1, unsigned char *a2)
{
  sub_100011828(a1, a2);
  sub_100011804((void *)&_mh_execute_header, v2, (uint64_t)v2, "life duration must follow ltype\n", v3);
}

void sub_1000588D8()
{
  sub_10001181C();
  sub_1000117E8((void *)&_mh_execute_header, v0, v1, "invalid life type: %d\n", v2, v3, v4, v5, v6);
}

void sub_100058940()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "invalid life duration.\n", v2, v3, v4, v5, v6);
}

void sub_100058974()
{
  sub_10001181C();
  sub_1000117E8((void *)&_mh_execute_header, v0, v1, "keylen %d: not multiple of 8\n", v2, v3, v4, v5, v6);
}

void sub_1000589DC()
{
  sub_100003B50(__stack_chk_guard);
  sub_100003B5C();
  sub_100011870((void *)&_mh_execute_header, v0, v1, "length %zu of life duration isn't supported.\n", v2, v3, v4, v5, v6);
}

void sub_100058A44()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "no suitable policy found.\n", v2, v3, v4, v5, v6);
}

void sub_100058A78(unsigned char *a1, unsigned char *a2)
{
  sub_100011828(a1, a2);
  sub_100011804((void *)&_mh_execute_header, v2, (uint64_t)v2, "not matched\n", v3);
}

void sub_100058AA8(unsigned char *a1, unsigned char *a2)
{
  sub_100011828(a1, a2);
  sub_100011804((void *)&_mh_execute_header, v2, (uint64_t)v2, "failed to get buffer.\n", v3);
}

void sub_100058AD8(unsigned char *a1, unsigned char *a2)
{
  sub_100011828(a1, a2);
  sub_100011854((void *)&_mh_execute_header, v2, v3, "matched\n", v4);
}

void sub_100058B04(unsigned char *a1, unsigned char *a2)
{
  sub_100011828(a1, a2);
  sub_100011854((void *)&_mh_execute_header, v2, v3, "my single bundle:\n", v4);
}

void sub_100058B30(unsigned char *a1, unsigned char *a2)
{
  sub_100011828(a1, a2);
  sub_100011854((void *)&_mh_execute_header, v2, v3, "peer's single bundle:\n", v4);
}

void sub_100058B5C()
{
  sub_100002F08();
  sub_10001188C((void *)&_mh_execute_header, v0, v1, "begin compare proposals.\n", v2);
}

void sub_100058B94()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "failed to get newsa.\n", v2, v3, v4, v5, v6);
}

void sub_100058BC8()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "failed to get prop pair.\n", v2, v3, v4, v5, v6);
}

void sub_100058BFC()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "some proposals received.\n", v2, v3, v4, v5, v6);
}

void sub_100058C30()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "no proposal received.\n", v2, v3, v4, v5, v6);
}

void sub_100058C64()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "proposal mismathed.\n", v2, v3, v4, v5, v6);
}

void sub_100058C98()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "#of protocols mismatched.\n", v2, v3, v4, v5, v6);
}

void sub_100058CCC()
{
  sub_100003B50(__stack_chk_guard);
  LOWORD(v2) = 1024;
  HIWORD(v2) = *(unsigned __int8 *)(*(void *)v0 + 5);
  sub_10000A124((void *)&_mh_execute_header, v0, v1, "proto_id mismathed: my:%d peer:%d\n", 67109376, v2);
}

void sub_100058D50()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "no suitable transform found.\n", v2, v3, v4, v5, v6);
}

void sub_100058D84()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "multi transforms replyed.\n", v2, v3, v4, v5, v6);
}

void sub_100058DB8()
{
  sub_10001181C();
  sub_1000117E8((void *)&_mh_execute_header, v0, v1, "invalid SPI size=%d for IPSEC proposal.\n", v2, v3, v4, v5, v6);
}

void sub_100058E20()
{
  sub_10001181C();
  sub_1000117E8((void *)&_mh_execute_header, v0, v1, "invalid SPI size=%d for IPCOMP proposal.\n", v2, v3, v4, v5, v6);
}

void sub_100058E88()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "failed to get newsa.\n", v2, v3, v4, v5, v6);
}

void sub_100058EBC()
{
  sub_100011838();
  sub_1000118BC((void *)&_mh_execute_header, v0, v1, "check_attr_isakmp invalid length of isakmp data, expected %zu actual %d\n", v2, v3, v4, v5, v6);
}

void sub_100058F24(int a1, NSObject *a2, uint64_t a3)
{
  v3[0] = 67109376;
  v3[1] = 0;
  __int16 v4 = 1024;
  int v5 = a1;
  sub_1000118E4((void *)&_mh_execute_header, a2, a3, "invalid length %d for TLV attribute %d.\n", (uint8_t *)v3);
}

void sub_100058FA0()
{
  sub_10001181C();
  sub_1000117E8((void *)&_mh_execute_header, v0, v1, "invalid attribute type %d.\n", v2, v3, v4, v5, v6);
}

void sub_100059008()
{
  sub_10001181C();
  sub_1000117E8((void *)&_mh_execute_header, v0, v1, "invalied encryption algorithm=%d.\n", v2, v3, v4, v5, v6);
}

void sub_100059070()
{
  sub_10001198C();
  HIWORD(v3) = v0;
  sub_10000A124((void *)&_mh_execute_header, v0, v1, "check_attr_isakmp: packet too short - attr length %u for type %d\n", v2, v3);
}

void sub_1000590DC()
{
  sub_10001181C();
  sub_1000117E8((void *)&_mh_execute_header, v0, v1, "invalied hash algorithm=%d.\n", v2, v3, v4, v5, v6);
}

void sub_100059144()
{
  sub_10001181C();
  sub_1000117E8((void *)&_mh_execute_header, v0, v1, "invalid auth method %d.\n", v2, v3, v4, v5, v6);
}

void sub_1000591AC(int a1, NSObject *a2)
{
  sub_10003EA90(a1);
  sub_100011970();
  sub_1000118A4((void *)&_mh_execute_header, a2, v3, "auth method %s isn't supported.\n", v4);
}

void sub_10005922C()
{
  sub_10001181C();
  sub_1000117E8((void *)&_mh_execute_header, v0, v1, "invalid DH group %d.\n", v2, v3, v4, v5, v6);
}

void sub_100059294()
{
  sub_10001181C();
  sub_1000117E8((void *)&_mh_execute_header, v0, v1, "unsupported DH group type %d.\n", v2, v3, v4, v5, v6);
}

void sub_1000592FC()
{
  sub_10001181C();
  sub_1000117E8((void *)&_mh_execute_header, v0, v1, "attr type=%u isn't supported.\n", v2, v3, v4, v5, v6);
}

void sub_100059364()
{
  sub_10001181C();
  sub_1000117E8((void *)&_mh_execute_header, v0, v1, "invalid life type %d.\n", v2, v3, v4, v5, v6);
}

void sub_1000593CC(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_1000117E8((void *)&_mh_execute_header, a1, a3, "attr type=%u isn't supported.\n", a5, a6, a7, a8, 0);
}

void sub_100059440()
{
  sub_10001181C();
  sub_1000117E8((void *)&_mh_execute_header, v0, v1, "oakley attribute %d must be TV.\n", v2, v3, v4, v5, v6);
}

void sub_1000594A8()
{
  sub_100011838();
  sub_1000118BC((void *)&_mh_execute_header, v0, v1, "check_attr_ipsec invalid length of isakmp data, expected %zu actual %d\n", v2, v3, v4, v5, v6);
}

void sub_100059510()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "must be TV when ENC_MODE.\n", v2, v3, v4, v5, v6);
}

void sub_100059544()
{
  sub_10001181C();
  sub_1000117E8((void *)&_mh_execute_header, v0, v1, "invalid encryption mode=%u.\n", v2, v3, v4, v5, v6);
}

void sub_1000595AC()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "attr AUTH must be present for ESP NULL encryption.\n", v2, v3, v4, v5, v6);
}

void sub_1000595E0()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "attr AUTH must be present for AH.\n", v2, v3, v4, v5, v6);
}

void sub_100059614(unsigned char *a1, unsigned char *a2)
{
  sub_100011828(a1, a2);
  sub_100011854((void *)&_mh_execute_header, v2, v3, "UDP encapsulation requested\n", v4);
}

void sub_100059640()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "must be TV when AUTH.\n", v2, v3, v4, v5, v6);
}

void sub_100059674()
{
  sub_10001181C();
  sub_1000117E8((void *)&_mh_execute_header, v0, v1, "invalid auth algorithm=%u.\n", v2, v3, v4, v5, v6);
}

void sub_1000596DC(unsigned __int8 *a1, uint64_t a2, NSObject *a3)
{
  LOWORD(v3) = 1024;
  HIWORD(v3) = *a1;
  sub_10000A124((void *)&_mh_execute_header, a2, a3, "auth algorithm %u conflicts with transform %u.\n", 67109376, v3);
}

void sub_100059758()
{
  sub_10001181C();
  sub_1000117E8((void *)&_mh_execute_header, v0, v1, "auth algorithm %u isn't supported.\n", v2, v3, v4, v5, v6);
}

void sub_1000597C0()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "must be TV when LD_TYPE.\n", v2, v3, v4, v5, v6);
}

void sub_1000597F4()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "invalid length of LD\n", v2, v3, v4, v5, v6);
}

void sub_100059828()
{
  sub_100011948();
  sub_1000118E4((void *)&_mh_execute_header, v0, v1, "check_attr_ipsec: packet too short - attr length %u for type %d\n", v2);
}

void sub_100059894(unsigned char *a1, unsigned char *a2)
{
  sub_100011828(a1, a2);
  sub_100011854((void *)&_mh_execute_header, v2, v3, "life duration was in TLV.\n", v4);
}

void sub_1000598C0()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "must be TV when GRP_DESC.\n", v2, v3, v4, v5, v6);
}

void sub_1000598F4()
{
  sub_10001181C();
  sub_1000117E8((void *)&_mh_execute_header, v0, v1, "invalid group description=%u.\n", v2, v3, v4, v5, v6);
}

void sub_10005995C()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "must be TV when KEY_LENGTH.\n", v2, v3, v4, v5, v6);
}

void sub_100059990()
{
  sub_100011838();
  sub_1000118BC((void *)&_mh_execute_header, v0, v1, "check_attr_ipcomp: invalid length of isakmp data, expected %zu actual %d\n", v2, v3, v4, v5, v6);
}

void sub_1000599F8()
{
  sub_100011948();
  sub_1000118E4((void *)&_mh_execute_header, v0, v1, "check_attr_ipcomp: packet too short - attr length %u for type %d\n", v2);
}

void sub_100059A64(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_1000117E8((void *)&_mh_execute_header, a1, a3, "invalid attr type=%u.\n", a5, a6, a7, a8, 0);
}

void sub_100059AD8()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "failed to allocate my sa buffer\n", v2, v3, v4, v5, v6);
}

void sub_100059B0C()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "no suitable proposal was created.\n", v2, v3, v4, v5, v6);
}

void sub_100059B40()
{
  sub_1000118D8();
  sub_1000117E8((void *)&_mh_execute_header, v0, v1, "invalid protocol: %d\n", v2, v3, v4, v5, v6);
}

void sub_100059BAC()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "no authentication algorithm found but protocol is AH.\n", v2, v3, v4, v5, v6);
}

void sub_100059BE0()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "Invalid IKE version detected\n", v2, v3, v4, v5, v6);
}

void sub_100059C14()
{
  sub_10001181C();
  sub_1000117E8((void *)&_mh_execute_header, v0, v1, "invalid ipsec protocol %d\n", v2, v3, v4, v5, v6);
}

void sub_100059C7C()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "invalid iph1 passed id_p == NULL\n", v2, v3, v4, v5, v6);
}

void sub_100059CB0()
{
  sub_100003B50(__stack_chk_guard);
  sub_100003B5C();
  sub_100011870((void *)&_mh_execute_header, v0, v1, "invalid value passed as \"ident\" (len=%lu)\n", v2, v3, v4, v5, v6);
}

void sub_100059D1C(unsigned __int8 *a1, NSObject *a2)
{
  sub_10003E8B0(*a1);
  sub_100011970();
  sub_1000118A4((void *)&_mh_execute_header, a2, v3, "Expecting IP address type in main mode, but %s.\n", v4);
}

void sub_100059DA0()
{
  sub_100002F08();
  sub_10001188C((void *)&_mh_execute_header, v0, v1, "No ID match.\n", v2);
}

void sub_100059DD8()
{
  sub_1000118D8();
  sub_1000117E8((void *)&_mh_execute_header, v0, v1, "invalid family: %d\n", v2, v3, v4, v5, v6);
}

void sub_100059E48()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "failed get my ID\n", v2, v3, v4, v5, v6);
}

void sub_100059E7C()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "invalid address family.\n", v2, v3, v4, v5, v6);
}

void sub_100059EB0()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "failed to get ID buffer.\n", v2, v3, v4, v5, v6);
}

void sub_100059EE4()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "failed to get own CERT.\n", v2, v3, v4, v5, v6);
}

void sub_100059F18()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "failed to get SecCertificateRef\n", v2, v3, v4, v5, v6);
}

void sub_100059F4C()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "failed to get subjectName\n", v2, v3, v4, v5, v6);
}

void sub_100059F80()
{
  sub_100003B5C();
  sub_100011870((void *)&_mh_execute_header, v0, v1, "No %s\n", v2, v3, v4, v5, v6);
}

void sub_10005A000()
{
  sub_100003B5C();
  sub_100011870((void *)&_mh_execute_header, v0, v1, "Empty %s\n", v2, v3, v4, v5, v6);
}

void sub_10005A080()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "unknown qualifier", v2, v3, v4, v5, v6);
}

void sub_10005A0B4()
{
  sub_100003B50(__stack_chk_guard);
  sub_100003B5C();
  sub_100011870((void *)&_mh_execute_header, v0, v1, "can not open %s\n", v2, v3, v4, v5, v6);
}

void sub_10005A11C()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "can not allocate memory", v2, v3, v4, v5, v6);
}

void sub_10005A150()
{
  sub_100003B50(__stack_chk_guard);
  sub_100003B5C();
  sub_100011870((void *)&_mh_execute_header, v0, v1, "invalid ip address %s\n", v2, v3, v4, v5, v6);
}

void sub_10005A1B8()
{
  sub_100002F08();
  sub_10001188C((void *)&_mh_execute_header, v0, v1, "Setting ID type ASN1DN from string not supported\n", v2);
}

void sub_10005A1F0()
{
  sub_1000118D8();
  sub_1000117E8((void *)&_mh_execute_header, v0, v1, "no policy found for spid:%u.\n", v2, v3, v4, v5, v6);
}

void sub_10005A25C(unsigned __int8 *a1, NSObject *a2)
{
  sub_100035558(a1);
  sub_100011970();
  sub_1000118A4((void *)&_mh_execute_header, a2, v3, "failed to get ID for %s\n", v4);
}

void sub_10005A2DC()
{
  sub_100011964();
  sub_1000118D8();
  sub_1000117E8((void *)&_mh_execute_header, v0, v1, "invalid family: %d.\n", v2, v3, v4, v5, v6);
}

void sub_10005A344()
{
  sub_10001181C();
  sub_1000117E8((void *)&_mh_execute_header, v0, v1, "invalid prefix length: %d.\n", v2, v3, v4, v5, v6);
}

void sub_10005A3AC()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "Address family mismatch\n", v2, v3, v4, v5, v6);
}

void sub_10005A3E0()
{
  sub_100011964();
  sub_1000118D8();
  sub_1000117E8((void *)&_mh_execute_header, v0, v1, "unsupported ID type %d\n", v2, v3, v4, v5, v6);
}

void sub_10005A448()
{
  sub_100011964();
  sub_1000118D8();
  sub_1000117E8((void *)&_mh_execute_header, v0, v1, "unknown ID type %d\n", v2, v3, v4, v5, v6);
}

void sub_10005A4B0()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "unable to extract asn1dn from id\n", v2, v3, v4, v5, v6);
}

void sub_10005A4E4()
{
  sub_100011838();
  sub_1000118BC((void *)&_mh_execute_header, v0, v1, "ipsecdoi_t2satrns invalid length of isakmp data, expected %zu actual %d\n", v2, v3, v4, v5, v6);
}

void sub_10005A54C()
{
  sub_100011914();
  sub_10000A124((void *)&_mh_execute_header, v0, v1, "ipsecdoi_t2satrns: packet too short - attr length %u for type %d\n", v2, v3);
}

void sub_10005A5C0(uint64_t a1, int a2, os_log_t log)
{
  v3[0] = 67109632;
  v3[1] = 2;
  __int16 v4 = 1024;
  int v5 = a2;
  __int16 v6 = 2048;
  uint64_t v7 = a1 - 4;
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "invalid IPsec attr(%d), attr-len %d, overall-len %lu\n", (uint8_t *)v3, 0x18u);
}

void sub_10005A65C()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "failed to get LD buffer.\n", v2, v3, v4, v5, v6);
}

void sub_10005A690()
{
  sub_100003B50(__stack_chk_guard);
  sub_100003B5C();
  __int16 v3 = 1024;
  int v4 = v0;
  sub_1000118FC((void *)&_mh_execute_header, v1, (uint64_t)v1, "lifetime mismatched in a proposal, prev:%ld curr:%u.\n", v2);
}

void sub_10005A70C()
{
  sub_100011914();
  sub_10000A124((void *)&_mh_execute_header, v0, v1, "lifebyte mismatched in a proposal, prev:%d curr:%u.\n", v2, v3);
}

void sub_10005A778()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "pfs_group mismatched in a proposal.\n", v2, v3, v4, v5, v6);
}

void sub_10005A7AC()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "multiple encmode exist in a transform.\n", v2, v3, v4, v5, v6);
}

void sub_10005A7E0()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "multiple authtype exist in a transform.\n", v2, v3, v4, v5, v6);
}

void sub_10005A814()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "key length defined but not ESP", v2, v3, v4, v5, v6);
}

void sub_10005A848()
{
  sub_10001181C();
  sub_1000117E8((void *)&_mh_execute_header, v0, v1, "invalid authentication algorithm:%d\n", v2, v3, v4, v5, v6);
}

void sub_10005A8B0()
{
  sub_10001181C();
  sub_1000117E8((void *)&_mh_execute_header, v0, v1, "Illegal protocol id=%u.\n", v2, v3, v4, v5, v6);
}

void sub_10005A918()
{
  sub_10001181C();
  sub_1000117E8((void *)&_mh_execute_header, v0, v1, "invalid protocol id %d.\n", v2, v3, v4, v5, v6);
}

void sub_10005A980()
{
  sub_10001198C();
  int v3 = 1;
  sub_1000118E4((void *)&_mh_execute_header, v0, v1, "invalid transform-id=%u in proto_id=%u.\n", v2);
}

void sub_10005A9F4()
{
  sub_10001181C();
  sub_1000117E8((void *)&_mh_execute_header, v0, v1, "invalid transform-id=%u in AH.\n", v2, v3, v4, v5, v6);
}

void sub_10005AA5C(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_1000117E8((void *)&_mh_execute_header, a1, a3, "not support transform-id=%u in AH.\n", a5, a6, a7, a8, 0);
}

void sub_10005AAD0()
{
  sub_10001181C();
  sub_1000117E8((void *)&_mh_execute_header, v0, v1, "invalid transform-id=%u in ESP.\n", v2, v3, v4, v5, v6);
}

void sub_10005AB38()
{
  sub_10001181C();
  sub_1000117E8((void *)&_mh_execute_header, v0, v1, "not support transform-id=%u in ESP.\n", v2, v3, v4, v5, v6);
}

void sub_10005ABA0()
{
  sub_10001181C();
  sub_1000117E8((void *)&_mh_execute_header, v0, v1, "invalid transform-id=%u in IPCOMP.\n", v2, v3, v4, v5, v6);
}

void sub_10005AC08()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "failed to set ID", v2, v3, v4, v5, v6);
}

void sub_10005AC3C()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "failed to set proposal", v2, v3, v4, v5, v6);
}

void sub_10005AC70()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "configuration failure about DH group.\n", v2, v3, v4, v5, v6);
}

void sub_10005ACA4()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "failed to generate DH", v2, v3, v4, v5, v6);
}

void sub_10005ACD8()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "failed to generate NONCE", v2, v3, v4, v5, v6);
}

void sub_10005AD0C()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "failed to send packet", v2, v3, v4, v5, v6);
}

void sub_10005AD40(uint64_t a1, NSObject *a2)
{
  sub_10003EA90(*(_DWORD *)(*(void *)(*(void *)a1 + 248) + 48));
  sub_100011970();
  _os_log_debug_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_DEBUG, "authmethod is %s\n", v3, 0xCu);
}

void sub_10005ADD4()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "failed to get CR", v2, v3, v4, v5, v6);
}

void sub_10005AE08()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "Frag vendorID construction failed\n", v2, v3, v4, v5, v6);
}

void sub_10005AE3C()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "Unity vendor ID generation failed\n", v2, v3, v4, v5, v6);
}

void sub_10005AE70()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "Xauth vendor ID generation failed\n", v2, v3, v4, v5, v6);
}

void sub_10005AEA4()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "msg has to be NULL in this function.\n", v2, v3, v4, v5, v6);
}

void sub_10005AED8()
{
  sub_100014974();
  sub_1000118D8();
  sub_1000117E8((void *)&_mh_execute_header, v0, v1, "status mismatched %d.\n", v2, v3, v4, v5, v6);
}

void sub_10005AF40()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "failed to parse msg", v2, v3, v4, v5, v6);
}

void sub_10005AF74()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "failed to process SA payload", v2, v3, v4, v5, v6);
}

void sub_10005AFA8()
{
  sub_1000118D8();
  sub_1000117E8((void *)&_mh_execute_header, v0, v1, "ignore the packet, received unexpecting payload type %d.\n", v2, v3, v4, v5, v6);
}

void sub_10005B014()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "few isakmp message received.\n", v2, v3, v4, v5, v6);
}

void sub_10005B048()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "failed to get valid proposal.\n", v2, v3, v4, v5, v6);
}

void sub_10005B07C()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "failed to compute DH", v2, v3, v4, v5, v6);
}

void sub_10005B0B0()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "failed to generate SKEYID", v2, v3, v4, v5, v6);
}

void sub_10005B0E4()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "failed to generate SKEYID-DAE", v2, v3, v4, v5, v6);
}

void sub_10005B118()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "failed to generate ENCKEY", v2, v3, v4, v5, v6);
}

void sub_10005B14C()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "failed to generate IV", v2, v3, v4, v5, v6);
}

void sub_10005B180()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "invalid ID payload.\n", v2, v3, v4, v5, v6);
}

void sub_10005B1B4()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "failed to process KE payload", v2, v3, v4, v5, v6);
}

void sub_10005B1E8()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "failed to process NONCE payload", v2, v3, v4, v5, v6);
}

void sub_10005B21C()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "failed to process ID payload", v2, v3, v4, v5, v6);
}

void sub_10005B250()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "failed to process CR payload", v2, v3, v4, v5, v6);
}

void sub_10005B284()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "failed to process CERT payload", v2, v3, v4, v5, v6);
}

void sub_10005B2B8()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "failed to process SIG payload", v2, v3, v4, v5, v6);
}

void sub_10005B2EC(unsigned char *a1, unsigned char *a2)
{
  sub_100011828(a1, a2);
  sub_100011854((void *)&_mh_execute_header, v2, v3, "remote supports DPD\n", v4);
}

void sub_10005B318(unsigned char *a1, unsigned char *a2)
{
  sub_100011828(a1, a2);
  sub_100011854((void *)&_mh_execute_header, v2, v3, "remote supports FRAGMENTATION\n", v4);
}

void sub_10005B344()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "failed to pre-process NATD payload", v2, v3, v4, v5, v6);
}

void sub_10005B378()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "failed to process NATD payload", v2, v3, v4, v5, v6);
}

void sub_10005B3AC()
{
  sub_100014980();
  _os_log_error_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_ERROR, "received invalid next payload type %d, expecting %d.\n", v1, 0xEu);
}

void sub_10005B424()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "failed to generate HASH", v2, v3, v4, v5, v6);
}

void sub_10005B458(uint64_t a1)
{
  sub_10003CE24(*(const sockaddr **)(a1 + 48));
  sub_100011970();
  sub_100014954((void *)&_mh_execute_header, v1, v2, "couldn't find the Hybrid pskey for %s.\n", v3, v4, v5, v6, v7);
}

void sub_10005B4D4()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "failed to create hash.\n", v2, v3, v4, v5, v6);
}

void sub_10005B508()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "failed to allocate notification payload.\n", v2, v3, v4, v5, v6);
}

void sub_10005B53C()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "failed to encrypt packet", v2, v3, v4, v5, v6);
}

void sub_10005B570()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "failed to add a response packet to the tree.\n", v2, v3, v4, v5, v6);
}

void sub_10005B5A4()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "failed to add contacted list.\n", v2, v3, v4, v5, v6);
}

void sub_10005B5D8(const sockaddr **a1)
{
  sub_10001499C(a1);
  sub_100011970();
  sub_100014954((void *)&_mh_execute_header, v1, v2, "NAT-D hashing failed for %s\n", v3, v4, v5, v6, v7);
}

void sub_10005B64C()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "failed to get mycert", v2, v3, v4, v5, v6);
}

void sub_10005B680()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "failed to get sign", v2, v3, v4, v5, v6);
}

void sub_10005B6B4()
{
  sub_100002F08();
  _os_log_debug_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_DEBUG, "generate HASH_I\n", v1, 2u);
}

void sub_10005B6F4(uint8_t *a1, unsigned __int8 *a2, char **a3, NSObject *a4)
{
  uint8_t v7 = sub_10003E1DC(*a2);
  *(_DWORD *)a1 = 136315138;
  *a3 = v7;
  _os_log_debug_impl((void *)&_mh_execute_header, a4, OS_LOG_TYPE_DEBUG, "received payload of type %s\n", a1, 0xCu);
}

void sub_10005B760()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "failed to generate GSS HASH", v2, v3, v4, v5, v6);
}

void sub_10005B794()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "failed to add a response packet to the tree.\n", v2, v3, v4, v5, v6);
}

void sub_10005B7C8()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "Cannot create Unity vendor ID\n", v2, v3, v4, v5, v6);
}

void sub_10005B7FC()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "Cannot create Xauth vendor ID\n", v2, v3, v4, v5, v6);
}

void sub_10005B830()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "failed to get mycert", v2, v3, v4, v5, v6);
}

void sub_10005B864()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "Frag vendorID construction failed\n", v2, v3, v4, v5, v6);
}

void sub_10005B898()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "failed to get CR.\n", v2, v3, v4, v5, v6);
}

void sub_10005B8CC()
{
  sub_100002F08();
  _os_log_debug_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_DEBUG, "generate HASH_R\n", v1, 2u);
}

void sub_10005B90C()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "failed to process CERT payload", v2, v3, v4, v5, v6);
}

void sub_10005B940()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "failed to process SIG payload", v2, v3, v4, v5, v6);
}

void sub_10005B974()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "failed to process NATD payload", v2, v3, v4, v5, v6);
}

void sub_10005B9A8()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "failed to decrypt msg", v2, v3, v4, v5, v6);
}

void sub_10005B9DC()
{
  sub_100015494();
  sub_100015478((void *)&_mh_execute_header, v0, v1, "%s: processed %d fragments\n", v2, v3, v4, v5, 2u);
}

void sub_10005BA50()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "Cannot allocate memory\n", v2, v3, v4, v5, v6);
}

void sub_10005BA84(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_10005BAFC(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_10005BB74()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "Message too short\n", v2, v3, v4, v5, v6);
}

void sub_10005BBA8()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "Fragment too short\n", v2, v3, v4, v5, v6);
}

void sub_10005BBDC(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_10005BC60()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "No fragment to reassemble\n", v2, v3, v4, v5, v6);
}

void sub_10005BC94()
{
  sub_100015494();
  sub_100015478((void *)&_mh_execute_header, v0, v1, "%s: processed %d fragments\n", v2, v3, v4, v5, 2u);
}

void sub_10005BD08(int a1, NSObject *a2)
{
  v2[0] = 67109120;
  v2[1] = a1;
  _os_log_error_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_ERROR, "Missing fragment #%d\n", (uint8_t *)v2, 8u);
}

void sub_10005BD80()
{
  sub_100015494();
  sub_100015478((void *)&_mh_execute_header, v0, v1, "%s: processed %d fragments\n", v2, v3, v4, v5, 2u);
}

void sub_10005BDF4()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "sendfromto failed\n", v2, v3, v4, v5, v6);
}

void sub_10005BE28(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_10005BEA0()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "failed to set proposal", v2, v3, v4, v5, v6);
}

void sub_10005BED4()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "Unity vendor ID generation failed\n", v2, v3, v4, v5, v6);
}

void sub_10005BF08()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "Xauth vendor ID generation failed\n", v2, v3, v4, v5, v6);
}

void sub_10005BF3C()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "msg has to be NULL in this function.\n", v2, v3, v4, v5, v6);
}

void sub_10005BF70()
{
  sub_100011964();
  sub_1000118D8();
  sub_1000117E8((void *)&_mh_execute_header, v0, v1, "ignore the packet, received unexpecting payload type %d.\n", v2, v3, v4, v5, v6);
}

void sub_10005BFD8(uint8_t *buf, unsigned char *a2, os_log_t log)
{
  *uint8_t buf = 0;
  *a2 = 0;
  _os_log_debug_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_DEBUG, "remote supports FRAGMENTATION\n", buf, 2u);
}

void sub_10005C018()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "failed to create send buffer", v2, v3, v4, v5, v6);
}

void sub_10005C04C(const sockaddr **a1)
{
  sub_10003CAE4(*a1);
  sub_100014954((void *)&_mh_execute_header, v1, v2, "NAT-D hashing failed for %s\n", v3, v4, v5, v6, 2u);
}

void sub_10005C0CC()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "failed to get cr buffer.\n", v2, v3, v4, v5, v6);
}

void sub_10005C100()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "failed to generate HASH", v2, v3, v4, v5, v6);
}

void sub_10005C134()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "failed to allocate send buffer", v2, v3, v4, v5, v6);
}

void sub_10005C168()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "failed to encrypt", v2, v3, v4, v5, v6);
}

void sub_10005C19C()
{
  sub_100018A18();
  sub_1000118D8();
  sub_1000117E8((void *)&_mh_execute_header, v0, v1, "invalid authentication type %d\n", v2, v3, v4, v5, v6);
}

void sub_10005C204()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "failed to get CR", v2, v3, v4, v5, v6);
}

void sub_10005C238()
{
  sub_100018A18();
  sub_1000118D8();
  sub_1000117E8((void *)&_mh_execute_header, v0, v1, "not supported authentication type %d\n", v2, v3, v4, v5, v6);
}

void sub_10005C2A0()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "ignore the packet, expecting the packet encrypted.\n", v2, v3, v4, v5, v6);
}

void sub_10005C2D4()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "failed to decrypt", v2, v3, v4, v5, v6);
}

void sub_10005C308()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "reject the packet, expecting the packet encrypted.\n", v2, v3, v4, v5, v6);
}

void sub_10005C33C()
{
  sub_100018A18();
  sub_1000118D8();
  sub_1000117E8((void *)&_mh_execute_header, v0, v1, "invalid authmethod %d why ?\n", v2, v3, v4, v5, v6);
}

void sub_10005C3A4()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "ignore information because the message is way too short\n", v2, v3, v4, v5, v6);
}

void sub_10005C3D8(int a1, uint64_t a2, NSObject *a3)
{
  uint64_t v5 = sub_10003E1DC(a1);
  int v6 = *(_DWORD *)(a2 + 16);
  int v7 = *(_DWORD *)(a2 + 20);
  int v8 = 136315650;
  int v9 = v5;
  __int16 v10 = 1024;
  int v11 = v6;
  __int16 v12 = 1024;
  int v13 = v7;
  _os_log_error_impl((void *)&_mh_execute_header, a3, OS_LOG_TYPE_ERROR, "%s message must be encrypted, status 0x%x, side %d\n", (uint8_t *)&v8, 0x18u);
}

void sub_10005C480(uint64_t a1, unsigned __int8 *a2)
{
  uint64_t v2 = sub_10003E1DC(*a2);
  sub_10001C4CC((uint64_t)v2, 4.8149e-34);
  sub_100007290((void *)&_mh_execute_header, v3, v4, "reject the packet, received unexpected payload type %s.\n");
}

void sub_10005C4D8()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "Delete Phase 1 handle.\n", v2, v3, v4, v5, v6);
}

void sub_10005C50C(unsigned char *a1, unsigned char *a2)
{
  sub_100011828(a1, a2);
  sub_100011804((void *)&_mh_execute_header, v2, (uint64_t)v2, "Cannot allocate memory\n", v3);
}

void sub_10005C53C()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "Invalid spi_size in notification payload.\n", v2, v3, v4, v5, v6);
}

void sub_10005C570(uint64_t a1, int a2)
{
  uint64_t v2 = sub_10001C4AC(a1, a2);
  sub_10001C4CC((uint64_t)v2, 4.8149e-34);
  sub_100007290((void *)&_mh_execute_header, v3, v4, "Fatal %s notify messsage, Phase 1 should be deleted.\n");
}

void sub_10005C5B8(uint64_t a1, int a2)
{
  uint64_t v2 = sub_10001C4AC(a1, a2);
  sub_10001C4CC((uint64_t)v2, 4.8149e-34);
  sub_100007290((void *)&_mh_execute_header, v3, v4, "Fatal %s notify messsage, Phase 2 should be deleted.\n");
}

void sub_10005C600(uint64_t a1, int a2)
{
  uint64_t v2 = sub_10001C4AC(a1, a2);
  sub_10001C4CC((uint64_t)v2, 4.8149e-34);
  sub_100007290((void *)&_mh_execute_header, v3, v4, "Unhandled notify message %s, no Phase 2 handle found.\n");
}

void sub_10005C648()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "invalid spi_size in notification payload.\n", v2, v3, v4, v5, v6);
}

void sub_10005C67C(unsigned char *a1, unsigned char *a2)
{
  sub_100011828(a1, a2);
  sub_100011804((void *)&_mh_execute_header, v2, (uint64_t)v2, "failed to get buffer to send.\n", v3);
}

void sub_10005C6AC(unsigned char *a1, unsigned char *a2)
{
  sub_100011828(a1, a2);
  sub_100011804((void *)&_mh_execute_header, v2, (uint64_t)v2, "Cookie mismatch in DPD ACK!.\n", v3);
}

void sub_10005C6DC(unsigned char *a1, unsigned char *a2)
{
  sub_100011828(a1, a2);
  sub_100011804((void *)&_mh_execute_header, v2, (uint64_t)v2, "deletion payload with invalid length.\n", v3);
}

void sub_10005C70C(uint8_t *buf, unsigned int *a2, unsigned int *a3, os_log_t log)
{
  unsigned int v4 = bswap32(*a2);
  *(_DWORD *)uint8_t buf = 67109120;
  *a3 = v4;
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "delete payload with invalid doi:%d.\n", buf, 8u);
}

void sub_10005C760(unsigned char *a1, unsigned char *a2)
{
  sub_100011828(a1, a2);
  sub_100011804((void *)&_mh_execute_header, v2, (uint64_t)v2, "ignore Acknowledged Informational\n", v3);
}

void sub_10005C790()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "iph1->ivm == NULL\n", v2, v3, v4, v5, v6);
}

void sub_10005C7C4()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "failed to compute IV\n", v2, v3, v4, v5, v6);
}

void sub_10005C7F8()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "failed to decrypt packet\n", v2, v3, v4, v5, v6);
}

void sub_10005C82C()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "ignore information because ISAKMP-SA has not been established yet.\n", v2, v3, v4, v5, v6);
}

void sub_10005C860()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "ignore information because the message is too short\n", v2, v3, v4, v5, v6);
}

void sub_10005C894()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "too long payload length (broken message?)\n", v2, v3, v4, v5, v6);
}

void sub_10005C8C8()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "too short payload length (broken message?)\n", v2, v3, v4, v5, v6);
}

void sub_10005C8FC()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "cannot allocate memory\n", v2, v3, v4, v5, v6);
}

void sub_10005C930()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "cannot compute hash\n", v2, v3, v4, v5, v6);
}

void sub_10005C964()
{
  sub_100002F08();
  _os_log_debug_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_DEBUG, "hash validated.\n", v1, 2u);
}

void sub_10005C9A4()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "ignore information due to hash mismatch\n", v2, v3, v4, v5, v6);
}

void sub_10005C9D8()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "ignore information due to hash length mismatch\n", v2, v3, v4, v5, v6);
}

void sub_10005CA0C()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "ignore information because the message has no hash payload.\n", v2, v3, v4, v5, v6);
}

void sub_10005CA40()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "failed to get buffer for payload.\n", v2, v3, v4, v5, v6);
}

void sub_10005CA74()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "failed to allocate ph2", v2, v3, v4, v5, v6);
}

void sub_10005CAA8()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "failed to duplicate remote address", v2, v3, v4, v5, v6);
}

void sub_10005CADC()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "failed to duplicate local address", v2, v3, v4, v5, v6);
}

void sub_10005CB10(uint64_t a1, NSObject *a2)
{
  int v2 = *(unsigned __int8 *)(*(void *)a1 + 1);
  v3[0] = 67109120;
  v3[1] = v2;
  _os_log_error_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_ERROR, "invalid family: %d\n", (uint8_t *)v3, 8u);
}

void sub_10005CB90()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "failed to get buffer to send.\n", v2, v3, v4, v5, v6);
}

void sub_10005CBC4()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "failed to encrypt packet", v2, v3, v4, v5, v6);
}

void sub_10005CBF8()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "no configuration found for peer address.\n", v2, v3, v4, v5, v6);
}

void sub_10005CC2C()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "failed to allocate ph1", v2, v3, v4, v5, v6);
}

void sub_10005CC60()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "failed to copy ph1 addresses", v2, v3, v4, v5, v6);
}

void sub_10005CC94()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "failed to get a payload buffer.\n", v2, v3, v4, v5, v6);
}

void sub_10005CCC8()
{
  os_log_t v0 = ipsec_strerror();
  sub_10001C4CC((uint64_t)v0, 4.8149e-34);
  sub_100007290((void *)&_mh_execute_header, v1, v2, "pfkey_check (%s)\n");
}

void sub_10005CD1C(unsigned __int16 *a1)
{
  sub_10001C4D8(a1);
  sub_100014954((void *)&_mh_execute_header, v1, v2, "Received unknown notification type %s.\n", v3, v4, v5, v6, 2u);
}

void sub_10005CD94()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "invalid spi_size in notification payload.\n", v2, v3, v4, v5, v6);
}

void sub_10005CDC8()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "failed to send getspi message", v2, v3, v4, v5, v6);
}

void sub_10005CDFC()
{
  sub_100002F08();
  sub_100004F7C((void *)&_mh_execute_header, v0, v1, "pfkey getspi sent.\n", v2, v3, v4, v5, v6);
}

void sub_10005CE30()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "failed to set proposal", v2, v3, v4, v5, v6);
}

void sub_10005CE64()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "failed to get ID.\n", v2, v3, v4, v5, v6);
}

void sub_10005CE98()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "failed to compute HASH", v2, v3, v4, v5, v6);
}

void sub_10005CECC()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "failed to get send buffer", v2, v3, v4, v5, v6);
}

void sub_10005CF00()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "failed to generate NAT-OA payload.\n", v2, v3, v4, v5, v6);
}

void sub_10005CF34()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "failed to set DH value.\n", v2, v3, v4, v5, v6);
}

void sub_10005CF68()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "msg has to be NULL in this function.\n", v2, v3, v4, v5, v6);
}

void sub_10005CF9C()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "failed to set ISAKMP header", v2, v3, v4, v5, v6);
}

void sub_10005CFD0()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "Packet wasn't encrypted.\n", v2, v3, v4, v5, v6);
}

void sub_10005D004(uint64_t **a1, unsigned int *a2, os_log_t log)
{
  uint64_t v3 = **a1;
  unsigned int v4 = bswap32(*a2);
  int v5 = 134218240;
  uint64_t v6 = v3;
  __int16 v7 = 1024;
  unsigned int v8 = v4;
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "invalid length (%lu,%d) while getting hash buffer.\n", (uint8_t *)&v5, 0x12u);
}

void sub_10005D09C()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "failed to get hash buffer.\n", v2, v3, v4, v5, v6);
}

void sub_10005D0D0()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "failed to validate SA proposal", v2, v3, v4, v5, v6);
}

void sub_10005D104()
{
  sub_100002F08();
  sub_100004F7C((void *)&_mh_execute_header, v0, v1, "HASH(2) mismatch.\n", v2, v3, v4, v5, v6);
}

void sub_10005D138(uint8_t *buf, unsigned char *a2, os_log_t log)
{
  *uint8_t buf = 0;
  *a2 = 0;
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "Ignored, multiple SA isn't supported.\n", buf, 2u);
}

void sub_10005D178()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "mismatched ID was returned.\n", v2, v3, v4, v5, v6);
}

void sub_10005D1AC()
{
  sub_1000118D8();
  sub_1000117E8((void *)&_mh_execute_header, v0, v1, "invalid length (%d) while allocating external nat id.\n", v2, v3, v4, v5, v6);
}

void sub_10005D218()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "memory error while allocating external nat id.\n", v2, v3, v4, v5, v6);
}

void sub_10005D24C()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "memory error while allocating ph2's external nat id.\n", v2, v3, v4, v5, v6);
}

void sub_10005D280()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "memory error while allocating peers ph2's external nat id.\n", v2, v3, v4, v5, v6);
}

void sub_10005D2B4(uint64_t a1, const sockaddr *a2)
{
  uint64_t v2 = sub_100020D74(a1, a2);
  sub_10001C4CC((uint64_t)v2, 4.8149e-34);
  sub_10000A104((void *)&_mh_execute_header, v3, v4, "initiaor rcvd NAT-OA i: %s\n");
}

void sub_10005D2FC(uint64_t a1, const sockaddr *a2)
{
  uint64_t v2 = sub_100020D74(a1, a2);
  sub_10001C4CC((uint64_t)v2, 4.8149e-34);
  sub_10000A104((void *)&_mh_execute_header, v3, v4, "initiator rcvd NAT-OA r: %s\n");
}

void sub_10005D344()
{
  sub_100020DB4();
  _os_log_error_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_ERROR, "received invalid next payload type %d, expecting %d.\n", v1, 0xEu);
}

void sub_10005D3BC()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "failed to create ISAKMP header", v2, v3, v4, v5, v6);
}

void sub_10005D3F0()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "failed to compute KEYMAT", v2, v3, v4, v5, v6);
}

void sub_10005D424()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "pfkey update failed.\n", v2, v3, v4, v5, v6);
}

void sub_10005D458()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "pfkey add failed.\n", v2, v3, v4, v5, v6);
}

void sub_10005D48C()
{
  sub_100002F08();
  sub_100004F7C((void *)&_mh_execute_header, v0, v1, "pfkey add sent.\n", v2, v3, v4, v5, v6);
}

void sub_10005D4C0()
{
  sub_100002F08();
  sub_100004F7C((void *)&_mh_execute_header, v0, v1, "pfkey update sent.\n", v2, v3, v4, v5, v6);
}

void sub_10005D4F4()
{
  sub_100002F08();
  sub_100004F7C((void *)&_mh_execute_header, v0, v1, "call pk_sendupdate\n", v2, v3, v4, v5, v6);
}

void sub_10005D528()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "failed to send packet, commit-bit", v2, v3, v4, v5, v6);
}

void sub_10005D55C()
{
  sub_100002F08();
  sub_100004F7C((void *)&_mh_execute_header, v0, v1, "HASH(3) generate\n", v2, v3, v4, v5, v6);
}

void sub_10005D590()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "failed to decrypt packet\n", v2, v3, v4, v5, v6);
}

void sub_10005D5C4()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "failed to parse msg\n", v2, v3, v4, v5, v6);
}

void sub_10005D5F8()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "failed to compute HASH\n", v2, v3, v4, v5, v6);
}

void sub_10005D62C()
{
  sub_100002F08();
  sub_100004F7C((void *)&_mh_execute_header, v0, v1, "HASH(4) mismatch.\n", v2, v3, v4, v5, v6);
}

void sub_10005D660()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "failed to get notify buffer.\n", v2, v3, v4, v5, v6);
}

void sub_10005D694()
{
  sub_100014974();
  sub_1000118D8();
  sub_1000117E8((void *)&_mh_execute_header, v0, v1, "invalid length (%d) while extracting hash.\n", v2, v3, v4, v5, v6);
}

void sub_10005D700()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "expected isakmp payloads missing.\n", v2, v3, v4, v5, v6);
}

void sub_10005D734()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "failed to get proposal for responder.\n", v2, v3, v4, v5, v6);
}

void sub_10005D768()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "failed to select proposal.\n", v2, v3, v4, v5, v6);
}

void sub_10005D79C()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "PFS is specified, but peer doesn't sends KE.\n", v2, v3, v4, v5, v6);
}

void sub_10005D7D0()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "no PFS is specified, but peer sends KE.\n", v2, v3, v4, v5, v6);
}

void sub_10005D804()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "failed to generate a proposal template from client's proposal.\n", v2, v3, v4, v5, v6);
}

void sub_10005D838()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "failed to get sainfo.\n", v2, v3, v4, v5, v6);
}

void sub_10005D86C()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "HASH(1) mismatch.\n", v2, v3, v4, v5, v6);
}

void sub_10005D8A0()
{
  sub_100011964();
  sub_1000118D8();
  sub_1000117E8((void *)&_mh_execute_header, v0, v1, "ignore the packet, received unexpected payload type %d.\n", v2, v3, v4, v5, v6);
}

void sub_10005D908()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "failed to process SA payload\n", v2, v3, v4, v5, v6);
}

void sub_10005D93C()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "Multi SAs isn't supported.\n", v2, v3, v4, v5, v6);
}

void sub_10005D970()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "failed to process NONCE payload\n", v2, v3, v4, v5, v6);
}

void sub_10005D9A4()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "failed to process KE payload\n", v2, v3, v4, v5, v6);
}

void sub_10005D9D8()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "failed to process IDci2 payload\n", v2, v3, v4, v5, v6);
}

void sub_10005DA0C()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "failed to process IDcr2 payload\n", v2, v3, v4, v5, v6);
}

void sub_10005DA40(uint8_t *buf, unsigned char *a2, os_log_t log)
{
  *uint8_t buf = 0;
  *a2 = 0;
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "IDr2 payload is not immediatelly followed by IDi2. We allowed.\n", buf, 2u);
}

void sub_10005DA80(uint64_t a1, const sockaddr *a2)
{
  uint64_t v2 = sub_100020D74(a1, a2);
  sub_10001C4CC((uint64_t)v2, 4.8149e-34);
  sub_10000A104((void *)&_mh_execute_header, v3, v4, "responder rcvd NAT-OA i: %s\n");
}

void sub_10005DAC8(uint64_t a1, const sockaddr *a2)
{
  uint64_t v2 = sub_100020D74(a1, a2);
  sub_10001C4CC((uint64_t)v2, 4.8149e-34);
  sub_10000A104((void *)&_mh_execute_header, v3, v4, "responder rcvd NAT-OA r: %s\n");
}

void sub_10005DB10()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "failed to set ID for source.\n", v2, v3, v4, v5, v6);
}

void sub_10005DB44()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "failed to set ID for destination.\n", v2, v3, v4, v5, v6);
}

void sub_10005DB78(uint64_t **a1)
{
  sub_10003A83C(*a1);
  sub_100011970();
  sub_1000072B0((void *)&_mh_execute_header, v1, v2, "selected sainfo: %s\n", v3, v4, v5, v6, v7);
}

void sub_10005DBF4()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "failed to group check", v2, v3, v4, v5, v6);
}

void sub_10005DC28()
{
  sub_100002F08();
  sub_100004F7C((void *)&_mh_execute_header, v0, v1, "get_sainfo_r case 3.\n", v2, v3, v4, v5, v6);
}

void sub_10005DC5C()
{
  sub_100002F08();
  sub_100004F7C((void *)&_mh_execute_header, v0, v1, "get_sainfo_r about to try dst id only.\n", v2, v3, v4, v5, v6);
}

void sub_10005DC90()
{
  sub_100002F08();
  sub_100004F7C((void *)&_mh_execute_header, v0, v1, "get_sainfo_r case 2.\n", v2, v3, v4, v5, v6);
}

void sub_10005DCC4()
{
  sub_100002F08();
  sub_100004F7C((void *)&_mh_execute_header, v0, v1, "get_sainfo_r case 1.\n", v2, v3, v4, v5, v6);
}

void sub_10005DCF8()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "failed to send getspi", v2, v3, v4, v5, v6);
}

void sub_10005DD2C()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "failed to update spi.\n", v2, v3, v4, v5, v6);
}

void sub_10005DD60()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "failed to set DH value.\n", v2, v3, v4, v5, v6);
}

void sub_10005DD94()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "failed to generate DH public", v2, v3, v4, v5, v6);
}

void sub_10005DDC8()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "failed to get send buffer", v2, v3, v4, v5, v6);
}

void sub_10005DDFC()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "failed to add RESPONDER-LIFETIME notify (type) payload", v2, v3, v4, v5, v6);
}

void sub_10005DE30()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "failed to add RESPONDER-LIFETIME notify (value) payload", v2, v3, v4, v5, v6);
}

void sub_10005DE64()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "invalid RESPONDER-LIFETIME payload", v2, v3, v4, v5, v6);
}

void sub_10005DE98()
{
  sub_100002F08();
  sub_100004F7C((void *)&_mh_execute_header, v0, v1, "Approved SA\n", v2, v3, v4, v5, v6);
}

void sub_10005DECC()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "failed to create NATOA payloads", v2, v3, v4, v5, v6);
}

void sub_10005DF00()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "msg has to be NULL in this function.\n", v2, v3, v4, v5, v6);
}

void sub_10005DF34()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "HASH(3) mismatch.\n", v2, v3, v4, v5, v6);
}

void sub_10005DF68()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "failed to set ISAKMP header", v2, v3, v4, v5, v6);
}

void sub_10005DF9C()
{
  sub_100002F08();
  sub_100004F7C((void *)&_mh_execute_header, v0, v1, "HASH(4) generate\n", v2, v3, v4, v5, v6);
}

void sub_10005DFD0()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "failed to compute KEYMAT", v2, v3, v4, v5, v6);
}

void sub_10005E004()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "pfkey spdupdate2(inbound) failed.\n", v2, v3, v4, v5, v6);
}

void sub_10005E038()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "pfkey spdupdate2(outbound) failed.\n", v2, v3, v4, v5, v6);
}

void sub_10005E06C()
{
  sub_100002F08();
  sub_100004F7C((void *)&_mh_execute_header, v0, v1, "pfkey spdupdate2(outbound) sent.\n", v2, v3, v4, v5, v6);
}

void sub_10005E0A0()
{
  sub_100002F08();
  sub_100004F7C((void *)&_mh_execute_header, v0, v1, "pfkey spdupdate2(inbound) sent.\n", v2, v3, v4, v5, v6);
}

void sub_10005E0D4(unsigned __int8 *a1)
{
  sub_100035558(a1);
  sub_100011970();
  sub_100014954((void *)&_mh_execute_header, v1, v2, "no policy found: %s\n", v3, v4, v5, v6, v7);
}

void sub_10005E14C()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "buffer allocation failed.\n", v2, v3, v4, v5, v6);
}

void sub_10005E180()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "failed to create saprop.\n", v2, v3, v4, v5, v6);
}

void sub_10005E1B4(unsigned __int8 *a1)
{
  sub_100035558(a1);
  sub_100011970();
  sub_100014954((void *)&_mh_execute_header, v1, v2, "policy found, but no IPsec required: %s\n", v3, v4, v5, v6, v7);
}

void sub_10005E22C(unsigned __int8 *a1)
{
  sub_100035558(a1);
  sub_100011970();
  sub_1000072B0((void *)&_mh_execute_header, v1, v2, "suitable SP found:%s\n", v3, v4, v5, v6, v7);
}

void sub_10005E2A4(uint64_t a1)
{
  sub_10003CAE4((const sockaddr *)(a1 + 136));
  sub_100020D94();
  sub_100020DD0((void *)&_mh_execute_header, v1, v2, "get dst address from ID payload %s prefixlen=%u ul_proto=%u\n", v3, v4, v5, v6, v7);
}

void sub_10005E338(uint64_t a1)
{
  sub_10003CAE4((const sockaddr *)(a1 + 8));
  sub_100020D94();
  sub_100020DD0((void *)&_mh_execute_header, v1, v2, "get a src address from ID payload %s prefixlen=%u ul_proto=%u\n", v3, v4, v5, v6, v7);
}

void sub_10005E3CC()
{
  sub_100002F08();
  sub_100004F7C((void *)&_mh_execute_header, v0, v1, "Get a source address of SP index from Phase 1 address due to no ID payloads found OR because ID type is not address.\n", v2, v3, v4, v5, v6);
}

void sub_10005E400()
{
  sub_100002F08();
  sub_100004F7C((void *)&_mh_execute_header, v0, v1, "Get a destination address of SP index from Phase 1 address due to no ID payloads found OR because ID type is not address.\n", v2, v3, v4, v5, v6);
}

void sub_10005E434(int a1, NSObject *a2)
{
  int v2 = 136315394;
  uint64_t v3 = "get_proposal_r_remote";
  __int16 v4 = 1024;
  int v5 = a1;
  _os_log_debug_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_DEBUG, "%s: ignore_id %x.\n", (uint8_t *)&v2, 0x12u);
}

void sub_10005E4C0()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "Why do ID[src,dst] exist already.\n", v2, v3, v4, v5, v6);
}

void sub_10005E4F4()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "Both IDs wasn't found in payload.\n", v2, v3, v4, v5, v6);
}

void sub_10005E528()
{
  sub_100002F08();
  sub_100004F7C((void *)&_mh_execute_header, v0, v1, "ignoring isakmp port until power-mgmt event is handled.\n", v2, v3, v4, v5, v6);
}

void sub_10005E55C()
{
  os_log_t v0 = __error();
  strerror(*v0);
  sub_100011970();
  sub_100014954((void *)&_mh_execute_header, v1, v2, "failed to receive isakmp packet: %s\n", v3, v4, v5, v6, v7);
}

void sub_10005E5DC()
{
  os_log_t v0 = __error();
  strerror(*v0);
  sub_100011970();
  sub_100014954((void *)&_mh_execute_header, v1, v2, "failed to receive keep alive packet: %s\n", v3, v4, v5, v6, v7);
}

void sub_10005E65C()
{
  sub_100011970();
  __int16 v2 = 2048;
  uint64_t v3 = 28;
  _os_log_error_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_ERROR, "packet shorter than isakmp header size (size: %zu, minimum expected: %zu)\n", v1, 0x16u);
}

void sub_10005E6E0()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "the length in the isakmp header is too big.\n", v2, v3, v4, v5, v6);
}

void sub_10005E714()
{
  sub_1000118D8();
  sub_100027D68();
  _os_log_error_impl(v0, v1, v2, v3, v4, 8u);
}

void sub_10005E790()
{
  sub_100011970();
  sub_100027D68();
  _os_log_error_impl(v0, v1, v2, v3, v4, 0x12u);
}

void sub_10005E80C()
{
  sub_100011970();
  _os_log_error_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_ERROR, "failed to allocate reading buffer (%lu Bytes)\n", v1, 0xCu);
}

void sub_10005E880()
{
  sub_1000118D8();
  sub_1000117E8((void *)&_mh_execute_header, v0, v1, "invalid family: %d\n", v2, v3, v4, v5, v6);
}

void sub_10005E8EC()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "src port == 0 (valid as UDP but not with IKE)\n", v2, v3, v4, v5, v6);
}

void sub_10005E920()
{
  sub_100027D68();
  _os_log_error_impl(v0, v1, v2, v3, v4, 0x16u);
}

void sub_10005E9A4()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "malformed cookie received.\n", v2, v3, v4, v5, v6);
}

void sub_10005E9D8(uint64_t a1, const sockaddr *a2)
{
  sub_10003CAE4(a2);
  sub_100004F64();
  sub_100004F98((void *)&_mh_execute_header, v2, v3, "Invalid exchange type %d from %s.\n", v4, v5, v6, v7, v8);
}

void sub_10005EA58(unsigned __int8 *a1, unsigned __int8 *a2, NSObject *a3)
{
  uint64_t v5 = sub_10003E0EC(*a1);
  uint64_t v6 = sub_10003E0EC(*a2);
  int v7 = 136315394;
  uint8_t v8 = v5;
  __int16 v9 = 2080;
  __int16 v10 = v6;
  _os_log_error_impl((void *)&_mh_execute_header, a3, OS_LOG_TYPE_ERROR, "Exchange type is mismatched: db=%s packet=%s, ignore it.\n", (uint8_t *)&v7, 0x16u);
}

void sub_10005EB0C()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "Message id should be zero in Phase 1.\n", v2, v3, v4, v5, v6);
}

void sub_10005EB40()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "Unknown Informational exchange received.\n", v2, v3, v4, v5, v6);
}

void sub_10005EB74(unsigned int *a1, uint64_t a2)
{
  sub_100023BEC(a2, *a1);
  sub_100014954((void *)&_mh_execute_header, v2, v3, "Can't start the quick mode, there is no ISAKMP-SA, %s\n", v4, v5, v6, v7, 2u);
}

void sub_10005EC04(uint64_t a1)
{
  sub_100023BEC(a1, *(_DWORD *)(a1 + 84));
  sub_100014954((void *)&_mh_execute_header, v1, v2, "can't start the quick mode, there is no valid ISAKMP-SA, %s\n", v3, v4, v5, v6, 2u);
}

void sub_10005EC8C()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "can't start the quick mode, invalid linked ISAKMP-SA\n", v2, v3, v4, v5, v6);
}

void sub_10005ECC0(uint64_t a1, const sockaddr *a2)
{
  sub_10003CAE4(a2);
  sub_100004F64();
  sub_100004F98((void *)&_mh_execute_header, v2, v3, "mode config %d from %s, but we have no ISAKMP-SA.\n", v4, v5, v6, v7, v8);
}

void sub_10005ED40()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "strdup failed\n", v2, v3, v4, v5, v6);
}

void sub_10005ED74()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "Phase 1 failed: dupsaddr failed.\n", v2, v3, v4, v5, v6);
}

void sub_10005EDA8()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "Commit bit on Phase 1 forbidden.\n", v2, v3, v4, v5, v6);
}

void sub_10005EDDC()
{
  sub_1000118D8();
  sub_1000117E8((void *)&_mh_execute_header, v0, v1, "invalid flag 0x%02x.\n", v2, v3, v4, v5, v6);
}

void sub_10005EE48(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_10005EEB4()
{
  sub_100002F08();
  sub_100004F7C((void *)&_mh_execute_header, v0, v1, "===\n", v2, v3, v4, v5, v6);
}

void sub_10005EEE8()
{
  sub_100027D58();
  sub_1000118D8();
  sub_1000117E8((void *)&_mh_execute_header, v0, v1, "invalid family: %d\n", v2, v3, v4, v5, v6);
}

void sub_10005EF50()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "failed to add contacted list.\n", v2, v3, v4, v5, v6);
}

void sub_10005EF84()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "failed to get rekey timer - lifetime is too small... probably.\n", v2, v3, v4, v5, v6);
}

void sub_10005EFB8()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "failed to send redirect message - memory error.\n", v2, v3, v4, v5, v6);
}

void sub_10005EFEC()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "isakmp_parsewoh invalid length of payload (1)\n", v2, v3, v4, v5, v6);
}

void sub_10005F020()
{
  sub_100002F08();
  sub_100004F7C((void *)&_mh_execute_header, v0, v1, "succeed.\n", v2, v3, v4, v5, v6);
}

void sub_10005F054()
{
  sub_100002F08();
  sub_100004F7C((void *)&_mh_execute_header, v0, v1, "begin.\n", v2, v3, v4, v5, v6);
}

void sub_10005F088()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "no address could be bound.\n", v2, v3, v4, v5, v6);
}

void sub_10005F0BC(uint8_t *buf, _DWORD *a2, os_log_t log)
{
  int v3 = *(_DWORD *)(qword_10008F848 + 24);
  *(_DWORD *)uint8_t buf = 67109120;
  *a2 = v3;
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "unsupported address family %d\n", buf, 8u);
}

void sub_10005F114()
{
  os_log_t v0 = sub_100027D3C();
  uint64_t v1 = strerror(*v0);
  sub_10001C4CC((uint64_t)v1, 4.8149e-34);
  sub_100007290((void *)&_mh_execute_header, v2, v3, "socket (%s)\n");
}

void sub_10005F164()
{
  os_log_t v0 = __error();
  strerror(*v0);
  sub_100011970();
  sub_100014954((void *)&_mh_execute_header, v1, v2, "setsockopt IPV6_USE_MIN_MTU (%s)\n", v3, v4, v5, v6, v7);
}

void sub_10005F1E4()
{
  os_log_t v0 = sub_100027D3C();
  uint64_t v1 = strerror(*v0);
  sub_10001C4CC((uint64_t)v1, 4.8149e-34);
  sub_100007290((void *)&_mh_execute_header, v2, v3, "setsockopt SO_REUSEADDR (%s)\n");
}

void sub_10005F234()
{
  os_log_t v0 = sub_100027D3C();
  uint64_t v1 = strerror(*v0);
  sub_10001C4CC((uint64_t)v1, 4.8149e-34);
  sub_100007290((void *)&_mh_execute_header, v2, v3, "setsockopt SO_REUSEPORT (%s)\n");
}

void sub_10005F284()
{
  os_log_t v0 = sub_100027D3C();
  uint64_t v1 = strerror(*v0);
  sub_10001C4CC((uint64_t)v1, 4.8149e-34);
  sub_100007290((void *)&_mh_execute_header, v2, v3, "setsockopt (%s)\n");
}

void sub_10005F2D4(uint64_t a1, const sockaddr **a2)
{
  uint64_t v2 = sub_10003CAE4(*a2);
  sub_10001C4CC((uint64_t)v2, 4.8149e-34);
  sub_100007290((void *)&_mh_execute_header, v3, v4, "failed to bind to address %s: can't read interface address flags.\n");
}

void sub_10005F32C()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "could not create isakmp socket source.", v2, v3, v4, v5, v6);
}

void sub_10005F360()
{
  os_log_t v0 = sub_100027D3C();
  uint64_t v1 = strerror(*v0);
  sub_10001C4CC((uint64_t)v1, 4.8149e-34);
  sub_100007290((void *)&_mh_execute_header, v2, v3, "setsockopt IP_RECVDSTADDR (%s)\n");
}

void sub_10005F3B0()
{
  os_log_t v0 = sub_100027D3C();
  uint64_t v1 = strerror(*v0);
  sub_10001C4CC((uint64_t)v1, 4.8149e-34);
  sub_100007290((void *)&_mh_execute_header, v2, v3, "setsockopt IP_BOUND_IF (%s)\n");
}

void sub_10005F400()
{
  os_log_t v0 = sub_100027D3C();
  uint64_t v1 = strerror(*v0);
  sub_10001C4CC((uint64_t)v1, 4.8149e-34);
  sub_100007290((void *)&_mh_execute_header, v2, v3, "setsockopt IPV6_BOUND_IF (%s)\n");
}

void sub_10005F450(uint8_t *buf, unsigned char *a2, os_log_t log)
{
  *uint8_t buf = 0;
  *a2 = 0;
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "failed to put socket in non-blocking mode\n", buf, 2u);
}

void sub_10005F490()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "vbuf allocation failed\n", v2, v3, v4, v5, v6);
}

void sub_10005F4C4()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "isakmp_sendfrags failed\n", v2, v3, v4, v5, v6);
}

void sub_10005F4F8()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "sendfromto failed\n", v2, v3, v4, v5, v6);
}

void sub_10005F52C()
{
  sub_100002F08();
  sub_100004F7C((void *)&_mh_execute_header, v0, v1, "Adding NON-ESP marker\n", v2, v3, v4, v5, v6);
}

void sub_10005F560(uint64_t a1)
{
  sub_100023BEC(a1, *(_DWORD *)(a1 + 84));
  sub_100014954((void *)&_mh_execute_header, v1, v2, "Phase 1 negotiation failed due to time up. %s\n", v3, v4, v5, v6, 2u);
}

void sub_10005F5E8(uint64_t a1)
{
  sub_100023BEC(a1, *(_DWORD *)(a1 + 84));
  sub_100014954((void *)&_mh_execute_header, v1, v2, "Phase 1 negotiation failed due to send error. %s\n", v3, v4, v5, v6, 2u);
}

void sub_10005F670(const sockaddr **a1)
{
  sub_10003CE24(*a1);
  sub_100011970();
  sub_100014954((void *)&_mh_execute_header, v1, v2, "Phase 1 rekey retry failed: no configuration found for %s.\n", v3, v4, v5, v6, v7);
}

void sub_10005F6EC()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "Internal error - attempt to re-send Phase 2 with no Phase 1 bound.\n", v2, v3, v4, v5, v6);
}

void sub_10005F720(uint64_t *a1, uint64_t a2)
{
  sub_100027D78(a1, a2);
  sub_100014954((void *)&_mh_execute_header, v2, v3, "Phase 2 negotiation failed due to time up. %s\n", v4, v5, v6, v7, 2u);
}

void sub_10005F7A0(uint64_t *a1, uint64_t a2)
{
  sub_100027D78(a1, a2);
  sub_100014954((void *)&_mh_execute_header, v2, v3, "Phase 2 negotiation failed due to send error. %s\n", v4, v5, v6, v7, 2u);
}

void sub_10005F820(uint64_t *a1, uint64_t a2)
{
  sub_100027D78(a1, a2);
  sub_100014954((void *)&_mh_execute_header, v2, v3, "Phase 2 negotiation failed due to Phase 1 expired. %s\n", v4, v5, v6, v7, 2u);
}

void sub_10005F8A0(const sockaddr **a1)
{
  sub_10003CE24(*a1);
  sub_100011970();
  sub_100014954((void *)&_mh_execute_header, v1, v2, "Phase1 rekey failed: no configuration found for %s.\n", v3, v4, v5, v6, v7);
}

void sub_10005F91C()
{
  sub_100002F08();
  sub_100004F7C((void *)&_mh_execute_header, v0, v1, "Reschedule Phase 1 rekey.\n", v2, v3, v4, v5, v6);
}

void sub_10005F950(const sockaddr **a1)
{
  sub_10003CE24(*a1);
  sub_100011970();
  sub_100014954((void *)&_mh_execute_header, v1, v2, "No configuration found for %s.\n", v3, v4, v5, v6, v7);
}

void sub_10005F9CC()
{
  sub_100002F08();
  sub_100004F7C((void *)&_mh_execute_header, v0, v1, "In post_acquire\n", v2, v3, v4, v5, v6);
}

void sub_10005FA00()
{
  sub_100002F08();
  sub_100004F7C((void *)&_mh_execute_header, v0, v1, "begin QUICK mode.\n", v2, v3, v4, v5, v6);
}

void sub_10005FA34()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "Attempt to start phase 2 whereas Xauth failed\n", v2, v3, v4, v5, v6);
}

void sub_10005FA68()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "the negotiation is stopped, because there is no suitable ISAKMP-SA.\n", v2, v3, v4, v5, v6);
}

void sub_10005FA9C(uint64_t a1)
{
  sub_10002FBD8(*(const sockaddr **)(a1 + 8), *(const sockaddr **)a1, *(unsigned __int8 *)(a1 + 104), 0, 0);
  sub_100011970();
  sub_100014954((void *)&_mh_execute_header, v1, v2, "Phase 2 negotiation failed due to time up waiting for Phase 1. %s\n", v3, v4, v5, v6, v7);
}

void sub_10005FB28(const sockaddr **a1)
{
  sub_10003CAE4(*a1);
  sub_100011970();
  sub_1000072B0((void *)&_mh_execute_header, v1, v2, "dst: %s\n", v3, v4, v5, v6, v7);
}

void sub_10005FBA4(const sockaddr **a1)
{
  sub_10003CAE4(*a1);
  sub_100011970();
  sub_1000072B0((void *)&_mh_execute_header, v1, v2, "src: %s\n", v3, v4, v5, v6, v7);
}

void sub_10005FC20()
{
  sub_100002F08();
  sub_100004F7C((void *)&_mh_execute_header, v0, v1, "After:\n", v2, v3, v4, v5, v6);
}

void sub_10005FC54(uint64_t a1)
{
  sub_10003CAE4(*(const sockaddr **)(a1 + 8));
  sub_100011970();
  sub_1000072B0((void *)&_mh_execute_header, v1, v2, "dst: %s\n", v3, v4, v5, v6, v7);
}

void sub_10005FCD0()
{
  sub_100002F08();
  sub_100004F7C((void *)&_mh_execute_header, v0, v1, "before:\n", v2, v3, v4, v5, v6);
}

void sub_10005FD04(uint64_t a1)
{
  sub_10003CAE4(*(const sockaddr **)(a1 + 48));
  sub_100011970();
  sub_1000072B0((void *)&_mh_execute_header, v1, v2, "iph1->remote: %s\n", v3, v4, v5, v6, v7);
}

void sub_10005FD80(uint64_t a1)
{
  sub_10003CAE4(*(const sockaddr **)(a1 + 56));
  sub_100011970();
  sub_1000072B0((void *)&_mh_execute_header, v1, v2, "iph1->local: %s\n", v3, v4, v5, v6, v7);
}

void sub_10005FDFC()
{
  sub_100002F08();
  sub_100004F7C((void *)&_mh_execute_header, v0, v1, "CHKPH1THERE: got a ph1 handler, setting ports.\n", v2, v3, v4, v5, v6);
}

void sub_10005FE30()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "failed to get a attribute buffer.\n", v2, v3, v4, v5, v6);
}

void sub_10005FE64()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "failed to get a cookie.\n", v2, v3, v4, v5, v6);
}

void sub_10005FE98()
{
  sub_100011970();
  _os_log_debug_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_DEBUG, "new cookie:\n%s\n", v1, 0xCu);
}

void sub_10005FF0C()
{
  sub_1000118D8();
  sub_100027D68();
  _os_log_error_impl(v0, v1, v2, v3, v4, 0xEu);
}

void sub_10005FF90()
{
  sub_1000118D8();
  sub_1000117E8((void *)&_mh_execute_header, v0, v1, "ignore this payload, invalid payload len %d.\n", v2, v3, v4, v5, v6);
}

void sub_100060004(uint64_t *a1, int a2, os_log_t log)
{
  uint64_t v3 = *a1;
  int v4 = 134218240;
  uint64_t v5 = v3;
  __int16 v6 = 1024;
  int v7 = a2;
  _os_log_debug_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_DEBUG, "add payload of len %zu, next type %d\n", (uint8_t *)&v4, 0x12u);
}

void sub_100060090()
{
  sub_100027D94();
  os_log_t v0 = ipsec_strerror();
  sub_10001C4CC((uint64_t)v0, 4.8149e-34);
  sub_100007290((void *)&_mh_execute_header, v1, v2, "pfkey_check (%s)\n");
}

void sub_1000600DC()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "pfkey spddelete(outbound) failed.\n", v2, v3, v4, v5, v6);
}

void sub_100060110()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "pfkey spddelete(inbound) failed.\n", v2, v3, v4, v5, v6);
}

void sub_100060144()
{
  sub_100027D94();
  sub_10003CAE4((const sockaddr *)(v0 + 136));
  sub_100020D94();
  sub_100020DD0((void *)&_mh_execute_header, v1, v2, "get dst address from ID payload %s prefixlen=%u ul_proto=%u\n", v3, v4, v5, v6, v7);
}

void sub_1000601D0()
{
  sub_100027D94();
  sub_10003CAE4((const sockaddr *)(v0 + 8));
  sub_100020D94();
  sub_100020DD0((void *)&_mh_execute_header, v1, v2, "get a src address from ID payload %s prefixlen=%u ul_proto=%u\n", v3, v4, v5, v6, v7);
}

void sub_10006025C()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "scope ID is not supported except of lladdr.\n", v2, v3, v4, v5, v6);
}

void sub_100060290()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "can't get scope ID: family mismatch\n", v2, v3, v4, v5, v6);
}

void sub_1000602C4()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "couldn't find configuration.\n", v2, v3, v4, v5, v6);
}

void sub_1000602F8(unsigned __int8 a1)
{
  sub_10003E0EC(a1);
  sub_100011970();
  sub_100014954((void *)&_mh_execute_header, v1, v2, "not acceptable %s mode\n", v3, v4, v5, v6, v7);
}

void sub_100060374()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "Packet reassembly failed\n", v2, v3, v4, v5, v6);
}

void sub_1000603A8()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "failed to allocate Phase 2 entry.\n", v2, v3, v4, v5, v6);
}

void sub_1000603DC()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "Attempt to start Phase 2 whereas Xauth failed\n", v2, v3, v4, v5, v6);
}

void sub_100060410()
{
}

void sub_10006042C()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "failed to get psk buffer.\n", v2, v3, v4, v5, v6);
}

void sub_100060460()
{
  sub_100002F08();
  sub_100004F7C((void *)&_mh_execute_header, v0, v1, "Getting pre-shared key by name.\n", v2, v3, v4, v5, v6);
}

void sub_100060494(os_log_t log)
{
  uint64_t v1 = *(void *)(qword_10008F848 + 144);
  int v2 = 136315138;
  uint64_t v3 = v1;
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "failed to open pre_share_key file %s\n", (uint8_t *)&v2, 0xCu);
}

void sub_10006051C()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "failed to allocate key buffer.\n", v2, v3, v4, v5, v6);
}

void sub_100060550()
{
  sub_100002F08();
  sub_100004F7C((void *)&_mh_execute_header, v0, v1, "Getting pre-shared key from file.\n", v2, v3, v4, v5, v6);
}

void sub_100060584()
{
  sub_100002F08();
  sub_100004F7C((void *)&_mh_execute_header, v0, v1, "Getting pre-shared key by addr.\n", v2, v3, v4, v5, v6);
}

void sub_1000605B8(uint64_t a1, NSObject *a2)
{
  int v2 = 136315138;
  uint64_t v3 = a1;
  _os_log_debug_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_DEBUG, "filename: %s\n", (uint8_t *)&v2, 0xCu);
}

void sub_100060630()
{
}

void sub_10006064C()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "cannot register pidfile cleanup", v2, v3, v4, v5, v6);
}

void sub_100060680()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "too many arguments.\n", v2, v3, v4, v5, v6);
}

void sub_1000606B4()
{
  uint64_t v0 = __error();
  uint64_t v1 = strerror(*v0);
  errx(1, "failed to be daemon. (%s)", v1);
}

void sub_1000606E4(NSObject *a1)
{
  uint64_t v2 = __error();
  uint64_t v3 = strerror(*v2);
  int v4 = 136315138;
  uint64_t v5 = v3;
  _os_log_error_impl((void *)&_mh_execute_header, a1, OS_LOG_TYPE_ERROR, "failed to exec racoon. (%s)", (uint8_t *)&v4, 0xCu);
}

void sub_100060778()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "cannot set gid.\n", v2, v3, v4, v5, v6);
}

void sub_1000607AC()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "cannot set uid.\n", v2, v3, v4, v5, v6);
}

void sub_1000607E0(int *a1)
{
  int v1 = *a1;
  uint64_t v2 = __error();
  uint64_t v3 = strerror(*v2);
  errx(1, "couldn't set net.inet.ipsec.esp_port to %d. (%s)", v1, v3);
}

void sub_100060818()
{
}

void sub_100060834()
{
}

void sub_100060850()
{
}

void sub_10006086C()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "memory error.\n", v2, v3, v4, v5, v6);
}

void sub_1000608A0()
{
  sub_100002F08();
  sub_100004F7C((void *)&_mh_execute_header, v0, v1, "compute DH's shared.\n", v2, v3, v4, v5, v6);
}

void sub_1000608D4()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "failed to compute dh value.\n", v2, v3, v4, v5, v6);
}

void sub_100060908()
{
  sub_10002E4A4();
  sub_10002E4D8((void *)&_mh_execute_header, v0, v1, "remote public key length (%zu) != prime length (%zu)\n", v2, v3);
}

void sub_10006097C()
{
  sub_100002F08();
  sub_100004F7C((void *)&_mh_execute_header, v0, v1, "compute DH result.\n", v2, v3, v4, v5, v6);
}

void sub_1000609B0()
{
  sub_1000118D8();
  sub_1000117E8((void *)&_mh_execute_header, v0, v1, "invalid dh type %d.\n", v2, v3, v4, v5, v6);
}

void sub_100060A1C()
{
  sub_100002F08();
  sub_100004F7C((void *)&_mh_execute_header, v0, v1, "failed DH public key size check.\n", v2, v3, v4, v5, v6);
}

void sub_100060A50()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "invalid public information was generated.\n", v2, v3, v4, v5, v6);
}

void sub_100060A84()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "failed to get DH buffer.\n", v2, v3, v4, v5, v6);
}

void sub_100060AB8()
{
  sub_100002F08();
  sub_100004F7C((void *)&_mh_execute_header, v0, v1, "got DH key pair.\n", v2, v3, v4, v5, v6);
}

void sub_100060AEC()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "failed to generate dh key pair.\n", v2, v3, v4, v5, v6);
}

void sub_100060B20()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "failed to create dh context.\n", v2, v3, v4, v5, v6);
}

void sub_100060B54()
{
  sub_1000118D8();
  sub_1000117E8((void *)&_mh_execute_header, v0, v1, "dh type %d isn't supported.\n", v2, v3, v4, v5, v6);
}

void sub_100060BC0()
{
  sub_100002F08();
  sub_100004F7C((void *)&_mh_execute_header, v0, v1, "generate DH key pair.\n", v2, v3, v4, v5, v6);
}

void sub_100060BF4()
{
  sub_10001181C();
  sub_1000117E8((void *)&_mh_execute_header, v0, v1, "invalid DH parameter grp=%d.\n", v2, v3, v4, v5, v6);
}

void sub_100060C5C()
{
  sub_10001181C();
  sub_1000117E8((void *)&_mh_execute_header, v0, v1, "unsupported DH parameters grp=%d.\n", v2, v3, v4, v5, v6);
}

void sub_100060CC4()
{
  sub_10001181C();
  sub_1000117E8((void *)&_mh_execute_header, v0, v1, "invalid hmac algorithm %d.\n", v2, v3, v4, v5, v6);
}

void sub_100060D2C()
{
  sub_10001181C();
  sub_1000117E8((void *)&_mh_execute_header, v0, v1, "invalid hash algorithm %d.\n", v2, v3, v4, v5, v6);
}

void sub_100060D94()
{
  sub_100002F08();
  sub_100004F7C((void *)&_mh_execute_header, v0, v1, "KEYMAT computed.\n", v2, v3, v4, v5, v6);
}

void sub_100060DC8()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "failed to get keymat buffer.\n", v2, v3, v4, v5, v6);
}

void sub_100060DFC()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "oakley_prf memory overflow\n", v2, v3, v4, v5, v6);
}

void sub_100060E30()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "failed to get hash buffer\n", v2, v3, v4, v5, v6);
}

void sub_100060E64()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "no SKEYID found.\n", v2, v3, v4, v5, v6);
}

void sub_100060E98()
{
  sub_100018A18();
  sub_1000118D8();
  sub_1000117E8((void *)&_mh_execute_header, v0, v1, "not supported authentication method %d\n", v2, v3, v4, v5, v6);
}

void sub_100060F00()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "invalid etype for this hash function\n", v2, v3, v4, v5, v6);
}

void sub_100060F34()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "No SIG was passed, hybrid auth is enabled, but peer is no Xauth compliant\n", v2, v3, v4, v5, v6);
}

void sub_100060F68()
{
  sub_1000118D8();
  sub_1000117E8((void *)&_mh_execute_header, v0, v1, "invalid etype %d\n", v2, v3, v4, v5, v6);
}

void sub_100060FD4()
{
  sub_100002F08();
  sub_100004F7C((void *)&_mh_execute_header, v0, v1, "HASH for PSK validated.\n", v2, v3, v4, v5, v6);
}

void sub_100061008()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "HASH mismatched\n", v2, v3, v4, v5, v6);
}

void sub_10006103C()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "no ID payload was passed.\n", v2, v3, v4, v5, v6);
}

void sub_100061070()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "no SIG payload was passed.\n", v2, v3, v4, v5, v6);
}

void sub_1000610A4()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "no peer's CERT payload found.\n", v2, v3, v4, v5, v6);
}

void sub_1000610D8()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "Invalid SIG.\n", v2, v3, v4, v5, v6);
}

void sub_10006110C()
{
  sub_100002F08();
  sub_100004F7C((void *)&_mh_execute_header, v0, v1, "SIG authenticated\n", v2, v3, v4, v5, v6);
}

void sub_100061140(int a1)
{
  sub_100004868(a1);
  sub_100011970();
  sub_100014954((void *)&_mh_execute_header, v1, v2, "error verifying signature %s\n", v3, v4, v5, v6, v7);
}

void sub_1000611B8()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "@@@@@@ publicKeyRef is NULL\n", v2, v3, v4, v5, v6);
}

void sub_1000611EC()
{
  sub_10001181C();
  sub_1000117E8((void *)&_mh_execute_header, v0, v1, "no supported certtype %d\n", v2, v3, v4, v5, v6);
}

void sub_100061254()
{
  sub_100002F08();
  sub_100004F7C((void *)&_mh_execute_header, v0, v1, "CERT validated\n", v2, v3, v4, v5, v6);
}

void sub_100061288()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "unknown address type for peers identifier.\n", v2, v3, v4, v5, v6);
}

void sub_1000612BC()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "missing hostname for peers identifier.\n", v2, v3, v4, v5, v6);
}

void sub_1000612F0()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "the peer's certificate is not verified.\n", v2, v3, v4, v5, v6);
}

void sub_100061324()
{
  sub_1000118D8();
  sub_1000117E8((void *)&_mh_execute_header, v0, v1, "invalid getcert_mothod: %d\n", v2, v3, v4, v5, v6);
}

void sub_100061394()
{
  sub_100002F08();
  sub_100004F7C((void *)&_mh_execute_header, v0, v1, "SIGN passed\n", v2, v3, v4, v5, v6);
}

void sub_1000613C8(uint64_t a1)
{
  sub_10003EA90(*(_DWORD *)(*(void *)a1 + 48));
  sub_100011970();
  sub_100014954((void *)&_mh_execute_header, v1, v2, "not supported authmethod type %s\n", v3, v4, v5, v6, v7);
}

void sub_100061448()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "no ID nor CERT found.\n", v2, v3, v4, v5, v6);
}

void sub_10006147C()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "no CERT defined.\n", v2, v3, v4, v5, v6);
}

void sub_1000614B0(os_log_t log)
{
  int v1 = 136315138;
  uint64_t v2 = "my";
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "failed to get %s CERT.\n", (uint8_t *)&v1, 0xCu);
}

void sub_100061534()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "failed to get cert buffer.\n", v2, v3, v4, v5, v6);
}

void sub_100061568()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "failed to get cert buffer\n", v2, v3, v4, v5, v6);
}

void sub_10006159C()
{
  sub_100002F08();
  sub_100004F7C((void *)&_mh_execute_header, v0, v1, "created CERT payload\n", v2, v3, v4, v5, v6);
}

void sub_1000615D0()
{
  sub_1000118D8();
  sub_10002E4BC((void *)&_mh_execute_header, v0, v1, "done with chking cert status %d\n", v2, v3, v4, v5, v6);
}

void sub_10006163C()
{
  sub_1000118D8();
  sub_1000117E8((void *)&_mh_execute_header, v0, v1, "Unknown certtype #%d\n", v2, v3, v4, v5, v6);
}

void sub_1000616AC()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "failed to sign.\n", v2, v3, v4, v5, v6);
}

void sub_1000616E0()
{
  sub_100002F08();
  sub_100004F7C((void *)&_mh_execute_header, v0, v1, "Discarding CERT: does not match ID:\n", v2, v3, v4, v5, v6);
}

void sub_100061714(int a1)
{
  sub_10003E8B0(a1);
  sub_100011970();
  sub_100014954((void *)&_mh_execute_header, v1, v2, "Impropper ID type passed: %s.\n", v3, v4, v5, v6, v7);
}

void sub_10006178C()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "failed to get SecCertificateRef\n", v2, v3, v4, v5, v6);
}

void sub_1000617C0()
{
  sub_10003E8B0(9);
  sub_100011970();
  sub_100014954((void *)&_mh_execute_header, v0, v1, "subjectName (type %s):\n", v2, v3, v4, v5, v6);
}

void sub_10006183C()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "ID mismatched with certificate subjectName\n", v2, v3, v4, v5, v6);
}

void sub_100061870()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "failed to get certificate subjectName\n", v2, v3, v4, v5, v6);
}

void sub_1000618A4()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "no certificate subjectName found\n", v2, v3, v4, v5, v6);
}

void sub_1000618D8(int a1)
{
  sub_10003E8B0(a1);
  sub_100011970();
  sub_100014954((void *)&_mh_execute_header, v1, v2, "subjectAltName (expected type %s):\n", v3, v4, v5, v6, v7);
}

void sub_100061950()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "ID mismatched with subjectAltName.\n", v2, v3, v4, v5, v6);
}

void sub_100061984()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "out of memory\n", v2, v3, v4, v5, v6);
}

void sub_1000619B8()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "memory error\n", v2, v3, v4, v5, v6);
}

void sub_1000619EC()
{
  sub_10003E8B0(2);
  sub_100011970();
  sub_100014954((void *)&_mh_execute_header, v0, v1, "subjectAltName (expected type %s):\n", v2, v3, v4, v5, v6);
}

void sub_100061A68()
{
  sub_10003E8B0(3);
  sub_100011970();
  sub_100014954((void *)&_mh_execute_header, v0, v1, "subjectAltName (expected type %s):\n", v2, v3, v4, v5, v6);
}

void sub_100061AE4()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "Failed to get CERT buffer.\n", v2, v3, v4, v5, v6);
}

void sub_100061B18()
{
  sub_100002F08();
  sub_100004F7C((void *)&_mh_execute_header, v0, v1, "CERT saved:\n", v2, v3, v4, v5, v6);
}

void sub_100061B4C()
{
  sub_10001181C();
  sub_1000117E8((void *)&_mh_execute_header, v0, v1, "Invalid CERT type %d\n", v2, v3, v4, v5, v6);
}

void sub_100061BB4()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "Len is too small !!.\n", v2, v3, v4, v5, v6);
}

void sub_100061BE8()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "Failed to copy CERT from packet.\n", v2, v3, v4, v5, v6);
}

void sub_100061C1C()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "Failed to get CR buffer.\n", v2, v3, v4, v5, v6);
}

void sub_100061C50()
{
  sub_100002F08();
  sub_100004F7C((void *)&_mh_execute_header, v0, v1, "CR saved\n", v2, v3, v4, v5, v6);
}

void sub_100061C84()
{
  sub_10001181C();
  sub_1000117E8((void *)&_mh_execute_header, v0, v1, "Invalid CR type %d\n", v2, v3, v4, v5, v6);
}

void sub_100061CEC()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "failed to get cr buffer\n", v2, v3, v4, v5, v6);
}

void sub_100061D20(uint64_t a1)
{
  sub_10003E074(*(_DWORD *)(*(void *)a1 + 112));
  sub_100011970();
  sub_1000072B0((void *)&_mh_execute_header, v1, v2, "create my CR: NONE, using %s instead\n", v3, v4, v5, v6, v7);
}

void sub_100061DA0(uint64_t a1)
{
  sub_10003E074(*(_DWORD *)(*(void *)a1 + 104));
  sub_100011970();
  sub_1000072B0((void *)&_mh_execute_header, v1, v2, "create my CR: %s\n", v3, v4, v5, v6, v7);
}

void sub_100061E20()
{
  sub_1000118D8();
  sub_1000117E8((void *)&_mh_execute_header, v0, v1, "such a cert type isn't supported: %d\n", v2, v3, v4, v5, v6);
}

void sub_100061E90(const sockaddr **a1)
{
  sub_10003CE24(*a1);
  sub_100011970();
  sub_100014954((void *)&_mh_execute_header, v1, v2, "couldn't find the pskey by address %s.\n", v3, v4, v5, v6, v7);
}

void sub_100061F0C()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "couldn't find pskey by peer's ID.\n", v2, v3, v4, v5, v6);
}

void sub_100061F40(uint64_t a1)
{
  sub_10003CE24(*(const sockaddr **)(a1 + 48));
  sub_100011970();
  sub_100014954((void *)&_mh_execute_header, v1, v2, "couldn't find the pskey for %s.\n", v3, v4, v5, v6, v7);
}

void sub_100061FBC()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "failed to get skeyid buffer\n", v2, v3, v4, v5, v6);
}

void sub_100061FF0()
{
  sub_100002F08();
  sub_100004F7C((void *)&_mh_execute_header, v0, v1, "the psk found.\n", v2, v3, v4, v5, v6);
}

void sub_100062024()
{
  sub_100018A18();
  sub_1000118D8();
  sub_1000117E8((void *)&_mh_execute_header, v0, v1, "invalid authentication method %d\n", v2, v3, v4, v5, v6);
}

void sub_10006208C()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "failed to get nonce buffer\n", v2, v3, v4, v5, v6);
}

void sub_1000620C0()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "no SKEYID found.\n", v2, v3, v4, v5, v6);
}

void sub_1000620F4(uint64_t a1, NSObject *a2)
{
  int v3 = *(_DWORD *)(*(void *)a1 + 40);
  int v2 = *(_DWORD *)(*(void *)a1 + 44);
  v4[0] = 67109376;
  v4[1] = v3;
  __int16 v5 = 1024;
  int v6 = v2;
  _os_log_error_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_ERROR, "invalid encryption algoritym %d, or invalid key length %d.\n", (uint8_t *)v4, 0xEu);
}

void sub_100062180()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "failed to get key buffer\n", v2, v3, v4, v5, v6);
}

void sub_1000621B4()
{
  sub_1000118D8();
  sub_1000117E8((void *)&_mh_execute_header, v0, v1, "invalid hash type %d.\n", v2, v3, v4, v5, v6);
}

void sub_100062224()
{
  sub_10002E4A4();
  sub_10002E4D8((void *)&_mh_execute_header, v0, v1, "internal error: res->l=%zu buf->l=%zu\n", v2, v3);
}

void sub_100062294()
{
  sub_10002E4A4();
  _os_log_debug_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_DEBUG, "len(SKEYID_e) < len(Ka) (%zu < %zu), generating long key (Ka = K1 | K2 | ...)\n", v1, 0x16u);
}

void sub_10006231C()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "failed to get cert's buffer\n", v2, v3, v4, v5, v6);
}

void sub_100062350()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "Failed to get IV buffer\n", v2, v3, v4, v5, v6);
}

void sub_100062384()
{
  sub_10002E494();
  sub_1000118D8();
  sub_1000117E8((void *)&_mh_execute_header, v0, v1, "Invalid encryption algorithm %d.\n", v2, v3, v4, v5, v6);
}

void sub_1000623EC()
{
  os_log_t v0 = __error();
  strerror(*v0);
  sub_100011970();
  sub_100014954((void *)&_mh_execute_header, v1, v2, "vdup (%s)\n", v3, v4, v5, v6, v7);
}

void sub_10006246C()
{
  sub_100002F08();
  sub_100004F7C((void *)&_mh_execute_header, v0, v1, "IV freed\n", v2, v3, v4, v5, v6);
}

void sub_1000624A0()
{
  sub_100002F08();
  sub_100004F7C((void *)&_mh_execute_header, v0, v1, "Compute IV for Phase 2\n", v2, v3, v4, v5, v6);
}

void sub_1000624D4()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "Failed to get buffer to decrypt.\n", v2, v3, v4, v5, v6);
}

void sub_100062508()
{
  sub_10002E494();
  sub_1000118D8();
  sub_1000117E8((void *)&_mh_execute_header, v0, v1, "Decryption %d failed.\n", v2, v3, v4, v5, v6);
}

void sub_100062570()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "failed to get buffer to decrypt.\n", v2, v3, v4, v5, v6);
}

void sub_1000625A4()
{
  sub_100002F08();
  sub_100004F7C((void *)&_mh_execute_header, v0, v1, "decrypted.\n", v2, v3, v4, v5, v6);
}

void sub_1000625D8()
{
  sub_100002F08();
  sub_100004F7C((void *)&_mh_execute_header, v0, v1, "skip to trim padding.\n", v2, v3, v4, v5, v6);
}

void sub_10006260C(unsigned __int8 a1, uint64_t *a2, os_log_t log)
{
  uint64_t v3 = *a2;
  v4[0] = 67109376;
  v4[1] = a1;
  __int16 v5 = 2048;
  uint64_t v6 = v3;
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "invalid padding len=%u, buflen=%zu.\n", (uint8_t *)v4, 0x12u);
}

void sub_10006269C()
{
  sub_100002F08();
  sub_100004F7C((void *)&_mh_execute_header, v0, v1, "trimmed padding\n", v2, v3, v4, v5, v6);
}

void sub_1000626D0()
{
  sub_1000118D8();
  sub_10002E4BC((void *)&_mh_execute_header, v0, v1, "padding len=%u\n", v2, v3, v4, v5, v6);
}

void sub_10006273C()
{
  sub_100002F08();
  sub_100004F7C((void *)&_mh_execute_header, v0, v1, "decrypted payload by IV:\n", v2, v3, v4, v5, v6);
}

void sub_100062770()
{
  sub_100002F08();
  sub_100004F7C((void *)&_mh_execute_header, v0, v1, "Begin decryption.\n", v2, v3, v4, v5, v6);
}

void sub_1000627A4()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "Failed to decrypt invalid IKE version", v2, v3, v4, v5, v6);
}

void sub_1000627D8()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "Failed to get buffer to encrypt.\n", v2, v3, v4, v5, v6);
}

void sub_10006280C()
{
  sub_10002E494();
  sub_1000118D8();
  sub_1000117E8((void *)&_mh_execute_header, v0, v1, "Encryption %d failed.\n", v2, v3, v4, v5, v6);
}

void sub_100062874()
{
  sub_100002F08();
  sub_100004F7C((void *)&_mh_execute_header, v0, v1, "Encrypted.\n", v2, v3, v4, v5, v6);
}

void sub_1000628A8()
{
  sub_10001181C();
  sub_10002E4BC((void *)&_mh_execute_header, v0, v1, "pad length = %u\n", v2, v3, v4, v5, v6);
}

void sub_100062910()
{
  sub_100002F08();
  sub_100004F7C((void *)&_mh_execute_header, v0, v1, "Begin encryption.\n", v2, v3, v4, v5, v6);
}

void sub_100062944()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "Failed to encrypt invalid IKE version", v2, v3, v4, v5, v6);
}

void sub_100062978()
{
  sub_100011964();
  sub_1000118D8();
  sub_1000117E8((void *)&_mh_execute_header, v0, v1, "unknown PF_KEY message type=%u\n", v2, v3, v4, v5, v6);
}

void sub_1000629E0()
{
  sub_100033870();
  uint64_t v3 = sub_10003EEB4(*v2);
  uint64_t v4 = strerror(*v1);
  int v5 = 136315394;
  uint8_t v6 = v3;
  __int16 v7 = 2080;
  uint8_t v8 = v4;
  _os_log_error_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_ERROR, "pfkey %s failed: %s\n", (uint8_t *)&v5, 0x16u);
}

void sub_100062A90()
{
  ipsec_strerror();
  sub_100011970();
  sub_100014954((void *)&_mh_execute_header, v0, v1, "libipsec failed pfkey check (%s)\n", v2, v3, v4, v5, v6);
}

void sub_100062B08()
{
  ipsec_strerror();
  sub_100011970();
  sub_100014954((void *)&_mh_execute_header, v0, v1, "libipsec failed pfkey align (%s)\n", v2, v3, v4, v5, v6);
}

void sub_100062B80()
{
  sub_100002F08();
  sub_100004F7C((void *)&_mh_execute_header, v0, v1, "ignoring pfkey port until power-mgmt event is handled.\n", v2, v3, v4, v5, v6);
}

void sub_100062BB4()
{
  uint64_t v0 = __error();
  strerror(*v0);
  sub_100011970();
  sub_100014954((void *)&_mh_execute_header, v1, v2, "failed to recv from pfkey (%s)\n", v3, v4, v5, v6, v7);
}

void sub_100062C34()
{
  uint64_t v0 = __error();
  strerror(*v0);
  sub_100011970();
  sub_100014954((void *)&_mh_execute_header, v1, v2, "failed to recv pfkey message: %s\n", v3, v4, v5, v6, v7);
}

void sub_100062CB4()
{
  ipsec_strerror();
  sub_100011970();
  sub_100014954((void *)&_mh_execute_header, v0, v1, "libipsec failed pfkey open: %s\n", v2, v3, v4, v5, v6);
}

void sub_100062D2C()
{
  ipsec_strerror();
  sub_100011970();
  sub_100014954((void *)&_mh_execute_header, v0, v1, "libipsec failed dump: %s\n", v2, v3, v4, v5, v6);
}

void sub_100062DA4()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "failed to reallocate buffer to dump.\n", v2, v3, v4, v5, v6);
}

void sub_100062DD8()
{
  sub_100002F08();
  sub_100004F7C((void *)&_mh_execute_header, v0, v1, "call pfkey_send_dump\n", v2, v3, v4, v5, v6);
}

void sub_100062E0C()
{
  ipsec_strerror();
  sub_100011970();
  sub_100014954((void *)&_mh_execute_header, v0, v1, "libipsec failed pfkey open (%s)\n", v2, v3, v4, v5, v6);
}

void sub_100062E84()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "failed to regist any protocol.\n", v2, v3, v4, v5, v6);
}

void sub_100062EB8()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "could not create pfkey socket source.", v2, v3, v4, v5, v6);
}

void sub_100062EEC()
{
  ipsec_strerror();
  sub_100011970();
  sub_100014954((void *)&_mh_execute_header, v0, v1, "libipsec sending spddump failed: %s\n", v2, v3, v4, v5, v6);
}

void sub_100062F64(uint8_t *buf, uint64_t a2, void *a3, os_log_t log)
{
  uint64_t v4 = *(void *)&byte_100089050[16 * a2 + 8];
  *(_DWORD *)uint8_t buf = 136315138;
  *a3 = v4;
  _os_log_debug_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_DEBUG, "call pfkey_send_register for %s\n", buf, 0xCu);
}

void sub_100062FC0()
{
  sub_10001181C();
  sub_1000117E8((void *)&_mh_execute_header, v0, v1, "Invalid ipsec_doi proto: %u\n", v2, v3, v4, v5, v6);
}

void sub_100063028()
{
  sub_10001181C();
  sub_1000117E8((void *)&_mh_execute_header, v0, v1, "Invalid pfkey proto: %u\n", v2, v3, v4, v5, v6);
}

void sub_100063090()
{
  sub_10001181C();
  sub_1000117E8((void *)&_mh_execute_header, v0, v1, "Invalid mode type: %u\n", v2, v3, v4, v5, v6);
}

void sub_1000630F8()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "unknown IPsec protocol.\n", v2, v3, v4, v5, v6);
}

void sub_10006312C()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "no ESP algorithm.\n", v2, v3, v4, v5, v6);
}

void sub_100063160()
{
  sub_10001181C();
  sub_1000117E8((void *)&_mh_execute_header, v0, v1, "invalid encryption algorithm %u.\n", v2, v3, v4, v5, v6);
}

void sub_1000631C8()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "no AH algorithm.\n", v2, v3, v4, v5, v6);
}

void sub_1000631FC()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "no IPCOMP algorithm.\n", v2, v3, v4, v5, v6);
}

void sub_100063230()
{
  sub_10001181C();
  sub_1000117E8((void *)&_mh_execute_header, v0, v1, "Invalid transform id: %u\n", v2, v3, v4, v5, v6);
}

void sub_100063298()
{
  sub_10001181C();
  sub_1000117E8((void *)&_mh_execute_header, v0, v1, "Not supported transform: %u\n", v2, v3, v4, v5, v6);
}

void sub_100063300(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_100063374()
{
  sub_10001181C();
  sub_1000117E8((void *)&_mh_execute_header, v0, v1, "invalid hmac algorithm %u.\n", v2, v3, v4, v5, v6);
}

void sub_1000633DC(uint64_t a1)
{
  sub_10003CE24(*(const sockaddr **)(a1 + 8));
  sub_100011970();
  sub_100014954((void *)&_mh_execute_header, v1, v2, "%s give up to get IPsec-SA due to time up to wait.\n", v3, v4, v5, v6, v7);
}

void sub_100063458()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "failed to get buffer to send acquire.\n", v2, v3, v4, v5, v6);
}

void sub_10006348C()
{
  sub_100014974();
  sub_1000118D8();
  sub_1000117E8((void *)&_mh_execute_header, v0, v1, "invalid encmode %d\n", v2, v3, v4, v5, v6);
}

void sub_1000634F4()
{
  ipsec_strerror();
  sub_100011970();
  sub_100014954((void *)&_mh_execute_header, v0, v1, "ipseclib failed send getspi (%s)\n", v2, v3, v4, v5, v6);
}

void sub_10006356C(uint8_t *buf, unsigned char *a2, os_log_t log)
{
  *uint8_t buf = 0;
  *a2 = 0;
  _os_log_debug_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_DEBUG, "call pfkey_send_getspi\n", buf, 2u);
}

void sub_1000635AC()
{
  sub_100014974();
  sub_1000118D8();
  sub_1000117E8((void *)&_mh_execute_header, v0, v1, "invalid proto_id %d\n", v2, v3, v4, v5, v6);
}

void sub_100063614()
{
  sub_100014974();
  sub_1000118D8();
  sub_1000117E8((void *)&_mh_execute_header, v0, v1, "Invalid encmode %d\n", v2, v3, v4, v5, v6);
}

void sub_10006367C()
{
  ipsec_strerror();
  sub_100011970();
  sub_100014954((void *)&_mh_execute_header, v0, v1, "libipsec failed send update (%s)\n", v2, v3, v4, v5, v6);
}

void sub_1000636F4()
{
  sub_100014974();
  sub_1000118D8();
  sub_1000117E8((void *)&_mh_execute_header, v0, v1, "Invalid proto_id %d\n", v2, v3, v4, v5, v6);
}

void sub_10006375C()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "No approved SAs found.\n", v2, v3, v4, v5, v6);
}

void sub_100063790()
{
  ipsec_strerror();
  sub_100011970();
  sub_100014954((void *)&_mh_execute_header, v0, v1, "libipsec failed send add (%s)\n", v2, v3, v4, v5, v6);
}

void sub_100063808()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "no approvaled SAs found.\n", v2, v3, v4, v5, v6);
}

void sub_10006383C()
{
  ipsec_strerror();
  sub_100011970();
  sub_100014954((void *)&_mh_execute_header, v0, v1, "libipsec failed send spdupdate2 (%s)\n", v2, v3, v4, v5, v6);
}

void sub_1000638B4()
{
  sub_100002F08();
  sub_100004F7C((void *)&_mh_execute_header, v0, v1, "call pfkey_send_spdupdate2\n", v2, v3, v4, v5, v6);
}

void sub_1000638E8()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "getting sadb policy failed.\n", v2, v3, v4, v5, v6);
}

void sub_10006391C()
{
  ipsec_strerror();
  sub_100011970();
  sub_100014954((void *)&_mh_execute_header, v0, v1, "libipsec failed send spdadd2 (%s)\n", v2, v3, v4, v5, v6);
}

void sub_100063994()
{
  sub_100002F08();
  sub_100004F7C((void *)&_mh_execute_header, v0, v1, "call pfkey_send_spdadd2\n", v2, v3, v4, v5, v6);
}

void sub_1000639C8()
{
  ipsec_strerror();
  sub_100011970();
  sub_100014954((void *)&_mh_execute_header, v0, v1, "libipsec failed send spddelete (%s)\n", v2, v3, v4, v5, v6);
}

void sub_100063A40()
{
  sub_100002F08();
  sub_100004F7C((void *)&_mh_execute_header, v0, v1, "call pfkey_send_spddelete\n", v2, v3, v4, v5, v6);
}

void sub_100063A74(os_log_t log)
{
  int v1 = 136315138;
  uint64_t v2 = "pk_sendget_inbound_sastats";
  _os_log_debug_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_DEBUG, "invalid args in %s \n", (uint8_t *)&v1, 0xCu);
}

void sub_100063AF8(os_log_t log)
{
  int v1 = 136315138;
  uint64_t v2 = "pk_sendget_outbound_sastats";
  _os_log_debug_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_DEBUG, "invalid args in %s \n", (uint8_t *)&v1, 0xCu);
}

void sub_100063B7C()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "invalid algorithm class.\n", v2, v3, v4, v5, v6);
}

void sub_100063BB0()
{
  sub_10001181C();
  sub_1000117E8((void *)&_mh_execute_header, v0, v1, "Invalid ipsec_doi algclass: %u\n", v2, v3, v4, v5, v6);
}

void sub_100063C18()
{
  ipsec_strerror();
  sub_100011970();
  sub_100014954((void *)&_mh_execute_header, v0, v1, "%s.\n", v2, v3, v4, v5, v6);
}

void sub_100063C90()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "inappropriate sadb spd management message passed.\n", v2, v3, v4, v5, v6);
}

void sub_100063CC4()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "invalid msg length.\n", v2, v3, v4, v5, v6);
}

void sub_100063CF8()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "failed to allocate buffer\n", v2, v3, v4, v5, v6);
}

void sub_100063D2C()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "invalid policy type.\n", v2, v3, v4, v5, v6);
}

void sub_100063D60()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "invalid msg length for ipsec request.\n", v2, v3, v4, v5, v6);
}

void sub_100063D94()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "failed to get new ipsecreq.\n", v2, v3, v4, v5, v6);
}

void sub_100063DC8()
{
  sub_1000118D8();
  sub_1000117E8((void *)&_mh_execute_header, v0, v1, "invalid proto type: %u\n", v2, v3, v4, v5, v6);
}

void sub_100063E34()
{
  sub_100011964();
  sub_1000118D8();
  sub_1000117E8((void *)&_mh_execute_header, v0, v1, "invalid level: %u\n", v2, v3, v4, v5, v6);
}

void sub_100063E9C()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "invalid msg length for src ip address.\n", v2, v3, v4, v5, v6);
}

void sub_100063ED0()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "invalid msg length for dst ip address.\n", v2, v3, v4, v5, v6);
}

void sub_100063F04(uint8_t *buf, unsigned char *a2, os_log_t log)
{
  *uint8_t buf = 0;
  *a2 = 0;
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "becoming tlen < 0\n", buf, 2u);
}

void sub_100063F44()
{
  sub_100011964();
  sub_1000118D8();
  sub_1000117E8((void *)&_mh_execute_header, v0, v1, "invalid mode: %u\n", v2, v3, v4, v5, v6);
}

void sub_100063FAC()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "Inappropriate sadb getspi message passed.\n", v2, v3, v4, v5, v6);
}

void sub_100063FE0(uint64_t a1, uint64_t a2)
{
  sub_100033854(a1, a2);
  sub_100004F64();
  sub_100033804((void *)&_mh_execute_header, v2, v3, "Seq %d of %s message not interesting.\n", v4, v5, v6, v7, v8);
}

void sub_100064054()
{
  sub_100014974();
  sub_1000118D8();
  sub_1000117E8((void *)&_mh_execute_header, v0, v1, "Status mismatch (db:%d)\n", v2, v3, v4, v5, v6);
}

void sub_1000640BC(uint64_t a1)
{
  sub_10003CE24(*(const sockaddr **)(a1 + 8));
  sub_100011970();
  sub_100014954((void *)&_mh_execute_header, v1, v2, "Can't proceed with getspi for  %s. no suitable ISAKMP-SA found \n", v3, v4, v5, v6, v7);
}

void sub_100064138(uint64_t a1)
{
  sub_10003CE24(*(const sockaddr **)(a1 + 8));
  sub_100011970();
  sub_100014954((void *)&_mh_execute_header, v1, v2, "Get spi for unknown address %s\n", v3, v4, v5, v6, v7);
}

void sub_1000641B4()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "IKEv1 post getspi failed.\n", v2, v3, v4, v5, v6);
}

void sub_1000641E8()
{
  sub_100011964();
  sub_1000118D8();
  sub_1000117E8((void *)&_mh_execute_header, v0, v1, "Internal error: invalid IKE major version %d\n", v2, v3, v4, v5, v6);
}

void sub_100064250()
{
  sub_1000118D8();
  sub_1000117E8((void *)&_mh_execute_header, v0, v1, "Status mismatch Phase 2 dying (db:%d)\n", v2, v3, v4, v5, v6);
}

void sub_1000642BC()
{
  sub_100033870();
  sub_10003383C(v0);
  sub_100033824();
  sub_100033804((void *)&_mh_execute_header, v1, v2, "%s message is not interesting because pid %d is not mine.\n", v3, v4, v5, v6, v7);
}

void sub_100064334()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "inappropriate sadb update message passed.\n", v2, v3, v4, v5, v6);
}

void sub_100064368()
{
  sub_100011964();
  sub_1000118D8();
  sub_1000117E8((void *)&_mh_execute_header, v0, v1, "invalid proto_id %d\n", v2, v3, v4, v5, v6);
}

void sub_1000643D0()
{
  sub_10001181C();
  sub_1000117E8((void *)&_mh_execute_header, v0, v1, "invalid encmode %d\n", v2, v3, v4, v5, v6);
}

void sub_100064438()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "inappropriate sadb add message passed.\n", v2, v3, v4, v5, v6);
}

void sub_10006446C(uint64_t a1, uint64_t a2)
{
  sub_100033854(a1, a2);
  sub_100004F64();
  sub_100033804((void *)&_mh_execute_header, v2, v3, "seq %d of %s message not interesting.\n", v4, v5, v6, v7, v8);
}

void sub_1000644E0()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "inappropriate sadb delete message passed.\n", v2, v3, v4, v5, v6);
}

void sub_100064514(uint64_t a1)
{
  sub_10003383C(a1);
  sub_100011970();
  sub_1000072B0((void *)&_mh_execute_header, v1, v2, "%s message is not interesting because the message was originated by me.\n", v3, v4, v5, v6, v7);
}

void sub_100064588(const sockaddr *a1)
{
  sub_10003CAE4(a1);
  sub_100011970();
  sub_1000072B0((void *)&_mh_execute_header, v1, v2, "dst: %s\n", v3, v4, v5, v6, v7);
}

void sub_100064600(const sockaddr *a1)
{
  sub_10003CAE4(a1);
  sub_100011970();
  sub_1000072B0((void *)&_mh_execute_header, v1, v2, "src: %s\n", v3, v4, v5, v6, v7);
}

void sub_100064678()
{
  sub_10001181C();
  _os_log_debug_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_DEBUG, "SADB delete message: proto-id %d\n", v1, 8u);
}

void sub_1000646EC()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "inappropriate sadb acquire message passed.\n", v2, v3, v4, v5, v6);
}

void sub_100064720(const sockaddr *a1)
{
  sub_10003CE24(a1);
  sub_100011970();
  sub_1000072B0((void *)&_mh_execute_header, v1, v2, "ignore because do not listen on source address : %s.\n", v3, v4, v5, v6, v7);
}

void sub_100064798()
{
  sub_100014974();
  sub_1000118D8();
  sub_1000117E8((void *)&_mh_execute_header, v0, v1, "no policy found: id:%d.\n", v2, v3, v4, v5, v6);
}

void sub_100064800(const sockaddr *a1)
{
  sub_10003CE24(a1);
  sub_100011970();
  sub_100014954((void *)&_mh_execute_header, v1, v2, "No configuration found for %s.\n", v3, v4, v5, v6, v7);
}

void sub_100064878()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "Failed to allocate Phase 2 entry.\n", v2, v3, v4, v5, v6);
}

void sub_1000648AC(unsigned __int8 *a1)
{
  sub_100035558(a1);
  sub_100011970();
  sub_100014954((void *)&_mh_execute_header, v1, v2, "failed to get ID for %s\n", v3, v4, v5, v6, v7);
}

void sub_100064924()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "failed to create saprop.\n", v2, v3, v4, v5, v6);
}

void sub_100064958()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "failed to begin ipsec sa negotiation.\n", v2, v3, v4, v5, v6);
}

void sub_10006498C(unsigned __int8 *a1)
{
  sub_100035558(a1);
  sub_100011970();
  sub_1000072B0((void *)&_mh_execute_header, v1, v2, "new acquire %s\n", v3, v4, v5, v6, v7);
}

void sub_100064A04()
{
  sub_1000118D8();
  _os_log_debug_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_DEBUG, "Got new Phase 2 version %d\n", v1, 8u);
}

void sub_100064A7C(uint64_t a1)
{
  sub_100035558((unsigned __int8 *)(a1 + 16));
  sub_100011970();
  sub_1000072B0((void *)&_mh_execute_header, v1, v2, "Suitable inbound SP found: %s.\n", v3, v4, v5, v6, v7);
}

void sub_100064AF8(uint64_t a1)
{
  sub_100035558((unsigned __int8 *)(a1 + 16));
  sub_100011970();
  sub_1000072B0((void *)&_mh_execute_header, v1, v2, "suitable outbound SP found: %s.\n", v3, v4, v5, v6, v7);
}

void sub_100064B74()
{
  sub_100002F08();
  sub_100004F7C((void *)&_mh_execute_header, v0, v1, "ignore the acquire because ph2 found\n", v2, v3, v4, v5, v6);
}

void sub_100064BA8(const sockaddr *a1)
{
  sub_10003CE24(a1);
  sub_100011970();
  sub_1000072B0((void *)&_mh_execute_header, v1, v2, "ignore due to multicast address: %s.\n", v3, v4, v5, v6, v7);
}

void sub_100064C20()
{
  sub_100002F08();
  sub_100004F7C((void *)&_mh_execute_header, v0, v1, "ignore ACQUIRE message. type is not IPsec.\n", v2, v3, v4, v5, v6);
}

void sub_100064C54()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "inappropriate sadb expire message passed.\n", v2, v3, v4, v5, v6);
}

void sub_100064C88()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "failed to begin ipsec sa re-negotiation.\n", v2, v3, v4, v5, v6);
}

void sub_100064CBC()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "inappropriate sadb flush message passed.\n", v2, v3, v4, v5, v6);
}

void sub_100064CF0()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "inappropriate sadb spdupdate message passed.\n", v2, v3, v4, v5, v6);
}

void sub_100064D24(unsigned __int8 *a1)
{
  sub_100035558(a1);
  sub_100011970();
  sub_100014954((void *)&_mh_execute_header, v1, v2, "such policy does not already exist: \"%s\"\n", v3, v4, v5, v6, v7);
}

void sub_100064D9C()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "inappropriate sadb spdadd message passed.\n", v2, v3, v4, v5, v6);
}

void sub_100064DD0(unsigned __int8 *a1)
{
  sub_100035558(a1);
  sub_100011970();
  sub_100014954((void *)&_mh_execute_header, v1, v2, "such policy already exists. anyway replace it: %s\n", v3, v4, v5, v6, v7);
}

void sub_100064E48()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "inappropriate sadb spddelete message passed.\n", v2, v3, v4, v5, v6);
}

void sub_100064E7C()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "inappropriate sadb spdget message passed.\n", v2, v3, v4, v5, v6);
}

void sub_100064EB0()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "inappropriate sadb spddump message passed.\n", v2, v3, v4, v5, v6);
}

void sub_100064EE4()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "inappropriate sadb spdflush message passed.\n", v2, v3, v4, v5, v6);
}

void sub_100064F18()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "inappropriate sadb spdexpire message passed.\n", v2, v3, v4, v5, v6);
}

void sub_100064F4C()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "inappropriate sadb getsastat response.\n", v2, v3, v4, v5, v6);
}

void sub_100064F80(uint64_t a1)
{
  sub_10003383C(a1);
  sub_100011970();
  sub_1000072B0((void *)&_mh_execute_header, v1, v2, "%s message is bad because session-id[0] is invalid.\n", v3, v4, v5, v6, v7);
}

void sub_100064FF4(uint64_t a1)
{
  sub_10003383C(a1);
  sub_100011970();
  sub_1000072B0((void *)&_mh_execute_header, v1, v2, "%s message is bad because it has no sastats.\n", v3, v4, v5, v6, v7);
}

void sub_100065068()
{
  sub_1000348E8();
  _os_log_fault_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_FAULT, "%s %s", v1, 0x16u);
}

void sub_1000650E0()
{
  sub_1000348E8();
  _os_log_error_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_ERROR, "%s %s", v1, 0x16u);
}

void sub_100065158()
{
  sub_1000348E8();
  _os_log_debug_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_DEBUG, "%s %s", v1, 0x16u);
}

void sub_1000651D0(uint64_t *a1, NSObject *a2)
{
  uint64_t v2 = *a1;
  int v3 = 136315138;
  uint64_t v4 = v2;
  _os_log_fault_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_FAULT, "%s", (uint8_t *)&v3, 0xCu);
}

void sub_10006524C(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_1000652BC(uint64_t *a1, NSObject *a2)
{
  uint64_t v2 = *a1;
  int v3 = 136315138;
  uint64_t v4 = v2;
  _os_log_debug_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_DEBUG, "%s", (uint8_t *)&v3, 0xCu);
}

void sub_100065338(os_log_t log)
{
  *(_WORD *)uint64_t v1 = 0;
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "strdup failed\n", v1, 2u);
}

void sub_10006537C(os_log_t log)
{
  *(_WORD *)uint64_t v1 = 0;
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "Null log level (quoted string)", v1, 2u);
}

void sub_1000653C0()
{
  sub_100011970();
  sub_100011870((void *)&_mh_execute_header, v0, v1, "Invalid log level (quoted string): %s", v2, v3, v4, v5, v6);
}

void sub_100065428()
{
  sub_100011970();
  _os_log_fault_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_FAULT, "%s", v1, 0xCu);
}

void sub_10006549C()
{
  sub_100011970();
  sub_100011870((void *)&_mh_execute_header, v0, v1, "%s", v2, v3, v4, v5, v6);
}

void sub_100065504()
{
  sub_100011970();
  _os_log_debug_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_DEBUG, "%s", v1, 0xCu);
}

void sub_100065578(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = sub_10003CAE4((const sockaddr *)(a2 + 136));
  sub_10001C4CC((uint64_t)v2, 4.8149e-34);
  sub_10000A104((void *)&_mh_execute_header, v3, v4, "dst2: %s\n");
}

void sub_1000655D0(uint64_t a1, const sockaddr **a2)
{
  uint64_t v2 = sub_10003568C(a1, a2);
  sub_10001C4CC((uint64_t)v2, 4.8149e-34);
  sub_10000A104((void *)&_mh_execute_header, v3, v4, "dst1: %s\n");
}

void sub_100065618(uint64_t a1, const sockaddr *a2)
{
  uint64_t v2 = sub_10003CAE4(a2);
  sub_10001C4CC((uint64_t)v2, 4.8149e-34);
  sub_10000A104((void *)&_mh_execute_header, v3, v4, "src2: %s\n");
}

void sub_100065670(uint64_t a1, const sockaddr **a2)
{
  uint64_t v2 = sub_10003568C(a1, a2);
  sub_10001C4CC((uint64_t)v2, 4.8149e-34);
  sub_10000A104((void *)&_mh_execute_header, v3, v4, "src1: %s\n");
}

void sub_1000656B8(os_log_t log)
{
  int v1 = 136315138;
  uint64_t v2 = "getsp_r";
  _os_log_debug_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_DEBUG, "%s, inbound policy outer addresses matched Phase 2 addresses\n", (uint8_t *)&v1, 0xCu);
}

void sub_10006573C(os_log_t log)
{
  int v1 = 136315138;
  uint64_t v2 = "getsp_r";
  _os_log_debug_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_DEBUG, "%s, outbound policy outer addresses matched Phase 2 addresses\n", (uint8_t *)&v1, 0xCu);
}

void sub_1000657C0(unsigned __int8 *a1, unsigned __int8 *a2, os_log_t log)
{
  int v3 = *a1;
  int v4 = *a2;
  v5[0] = 67109376;
  v5[1] = v3;
  __int16 v6 = 1024;
  int v7 = v4;
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "unexpected error: src.ss_len:%d dst.ss_len:%d\n", (uint8_t *)v5, 0xEu);
}

void sub_100065850(os_log_t log)
{
  *(_WORD *)int v1 = 0;
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "unexpected error\n", v1, 2u);
}

void sub_100065894()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "failed to allocate saprop.\n", v2, v3, v4, v5, v6);
}

void sub_1000658C8()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "invalid pcheck_level why?.\n", v2, v3, v4, v5, v6);
}

void sub_1000658FC()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "failed to allocate saproto.\n", v2, v3, v4, v5, v6);
}

void sub_100065930()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "failed to allocate satrns.\n", v2, v3, v4, v5, v6);
}

void sub_100065964(int *a1, int *a2)
{
  sub_10003E71C(*a1);
  sub_10003E71C(*a2);
  sub_10003831C();
  sub_1000383CC((void *)&_mh_execute_header, v3, v4, "encmode mismatched: my:%s peer:%s\n", v5, v6, v7, v8, v9);
}

void sub_1000659F8(uint8_t *buf, unsigned char *a2, os_log_t log)
{
  *uint8_t buf = 0;
  *a2 = 0;
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "IPComp SPI size promoted from 16bit to 32bit\n", buf, 2u);
}

void sub_100065A38()
{
  sub_10003845C(__stack_chk_guard);
  sub_10000A0EC();
  sub_10000A124((void *)&_mh_execute_header, v0, v1, "spisize mismatched: my:%d peer:%d\n", v2, v3);
}

void sub_100065AA0(int *a1, int *a2)
{
  sub_10003E344(*a1);
  sub_10003E344(*a2);
  sub_10003831C();
  sub_1000383CC((void *)&_mh_execute_header, v3, v4, "proto_id mismatched: my:%s peer:%s\n", v5, v6, v7, v8, v9);
}

void sub_100065B34()
{
  sub_10003845C(__stack_chk_guard);
  sub_10000A0EC();
  sub_10000A124((void *)&_mh_execute_header, v0, v1, "long lifetime proposed: my:%d peer:%d\n", v2, v3);
}

void sub_100065B9C()
{
  sub_1000383AC(__stack_chk_guard);
  sub_10000A0EC();
  sub_10000A124((void *)&_mh_execute_header, v0, v1, "long lifebyte proposed: my:%d peer:%d\n", v2, v3);
}

void sub_100065C04()
{
  sub_1000383AC(__stack_chk_guard);
  sub_10000A0EC();
  sub_10000A124((void *)&_mh_execute_header, v0, v1, "pfs group mismatched: my:%d peer:%d\n", v2, v3);
}

void sub_100065C6C()
{
  sub_1000383AC(__stack_chk_guard);
  sub_10000A0EC();
  sub_10000A124((void *)&_mh_execute_header, v0, v1, "lifebyte mismatched: my:%d peer:%d\n", v2, v3);
}

void sub_100065CD4()
{
  sub_10003845C(__stack_chk_guard);
  sub_10000A0EC();
  sub_10000A124((void *)&_mh_execute_header, v0, v1, "lifetime mismatched: my:%d peer:%d\n", v2, v3);
}

void sub_100065D3C(unsigned int *a1, unsigned int *a2)
{
  sub_10003E80C(5, *a1);
  sub_10003E80C(5, *a2);
  sub_10003831C();
  sub_100038498((void *)&_mh_execute_header, v3, v4, "authtype mismatched: my:%s peer:%s\n", v5, v6, v7, v8, v9);
}

void sub_100065DD8(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_100065E48()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "no auth algorithm found\n", v2, v3, v4, v5, v6);
}

void sub_100065E7C()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "no algorithms found.\n", v2, v3, v4, v5, v6);
}

void sub_100065EB0()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "no encryption algorithm found\n", v2, v3, v4, v5, v6);
}

void sub_100065EE4()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "no ipcomp algorithm found\n", v2, v3, v4, v5, v6);
}

void sub_100065F18(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_100065F8C()
{
  sub_100002F08();
  _os_log_fault_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_FAULT, "(null)", v1, 2u);
}

void sub_100065FCC()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "(null)", v2, v3, v4, v5, v6);
}

void sub_100066000()
{
  sub_100002F08();
  _os_log_debug_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_DEBUG, "(null)", v1, 2u);
}

void sub_100066040()
{
  sub_100004FB8();
  sub_10003E344(*v0);
  sub_100038380();
  sub_1000382D4();
  sub_1000383BC();
  _os_log_fault_impl(v1, v2, v3, v4, v5, 0x3Cu);
}

void sub_1000660DC()
{
  sub_100004FB8();
  sub_10003E344(*v0);
  sub_100038380();
  sub_1000382D4();
  sub_100038488();
  _os_log_error_impl(v1, v2, v3, v4, v5, 0x3Cu);
}

void sub_100066178()
{
  sub_100004FB8();
  sub_10003E344(*v0);
  sub_100038380();
  sub_1000382D4();
  sub_10001197C();
  _os_log_debug_impl(v1, v2, v3, v4, v5, 0x3Cu);
}

void sub_100066214(int a1, NSObject *a2)
{
  v2[0] = 67109120;
  v2[1] = a1;
  _os_log_fault_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_FAULT, "(unknown proto_id %d)\n", (uint8_t *)v2, 8u);
}

void sub_10006628C(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_1000662F8(int a1, NSObject *a2)
{
  v2[0] = 67109120;
  v2[1] = a1;
  _os_log_debug_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_DEBUG, "(unknown proto_id %d)\n", (uint8_t *)v2, 8u);
}

void sub_100066370()
{
  sub_100004FB8();
  sub_100038424(v0);
  sub_100038408();
  sub_10003831C();
  sub_1000383BC();
  _os_log_fault_impl(v1, v2, v3, v4, v5, 0x16u);
}

void sub_1000663F8()
{
  sub_100004FB8();
  sub_100038424(v0);
  sub_100038408();
  sub_10003831C();
  sub_1000383CC((void *)&_mh_execute_header, v1, v2, "  (trns_id=%s authtype=%s)\n", v3, v4, v5, v6, v7);
}

void sub_100066478()
{
  sub_100004FB8();
  sub_100038424(v0);
  sub_100038408();
  sub_10003831C();
  sub_100038498((void *)&_mh_execute_header, v1, v2, "  (trns_id=%s authtype=%s)\n", v3, v4, v5, v6, v7);
}

void sub_1000664F8()
{
  sub_100004FB8();
  sub_10003846C(v0);
  sub_1000383EC();
  sub_10003835C();
  sub_1000383BC();
  _os_log_fault_impl(v1, v2, v3, v4, v5, 0x1Cu);
}

void sub_100066580()
{
  sub_100004FB8();
  sub_10003846C(v0);
  sub_1000383EC();
  sub_10003835C();
  sub_100038488();
  _os_log_error_impl(v1, v2, v3, v4, v5, 0x1Cu);
}

void sub_100066608()
{
  sub_100004FB8();
  sub_10003846C(v0);
  sub_1000383EC();
  sub_10003835C();
  sub_10001197C();
  _os_log_debug_impl(v1, v2, v3, v4, v5, 0x1Cu);
}

void sub_100066690(uint64_t a1)
{
  sub_100038440(a1);
  sub_1000383BC();
  _os_log_fault_impl(v1, v2, v3, v4, v5, 0xCu);
}

void sub_100066710(uint64_t a1)
{
  sub_100038440(a1);
  sub_100038488();
  _os_log_error_impl(v1, v2, v3, v4, v5, 0xCu);
}

void sub_100066790(uint64_t a1)
{
  sub_100038440(a1);
  sub_10001197C();
  _os_log_debug_impl(v1, v2, v3, v4, v5, 0xCu);
}

void sub_100066810()
{
  sub_100038334();
  _os_log_fault_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_FAULT, "%s%p: next=%p tnext=%p\n", v1, 0x2Au);
}

void sub_10006688C()
{
  sub_100038334();
  _os_log_error_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_ERROR, "%s%p: next=%p tnext=%p\n", v1, 0x2Au);
}

void sub_100066908()
{
  sub_100038334();
  _os_log_debug_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_DEBUG, "%s%p: next=%p tnext=%p\n", v1, 0x2Au);
}

void sub_100066984()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "failed to get algorithms.\n", v2, v3, v4, v5, v6);
}

void sub_1000669B8()
{
  sub_100002F08();
  _os_log_debug_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_DEBUG, "make a proposal from peer's:\n", v1, 2u);
}

void sub_1000669F8(uint8_t *buf, unsigned char *a2, os_log_t log)
{
  *uint8_t buf = 0;
  *a2 = 0;
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "pp_peer is inconsistency, ignore it.\n", buf, 2u);
}

void sub_100066A38(unsigned __int8 *a1, NSObject *a2)
{
  int v2 = *a1;
  v3[0] = 67109120;
  v3[1] = v2;
  _os_log_error_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_ERROR, "invalid ip address family: %d\n", (uint8_t *)v3, 8u);
}

void sub_100066AB4(os_log_t log)
{
  *(_WORD *)uint64_t v1 = 0;
  _os_log_debug_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_DEBUG, "no remote configuration found.\n", v1, 2u);
}

void sub_100066AF8()
{
  sub_100011970();
  sub_100003B34((void *)&_mh_execute_header, v0, v1, "configuration found for %s.\n", v2, v3, v4, v5, v6);
}

void sub_100066B60()
{
  sub_100011970();
  sub_100003B34((void *)&_mh_execute_header, v0, v1, "anonymous configuration selected for %s.\n", v2, v3, v4, v5, v6);
}

void sub_100066BC8(const sockaddr *a1, NSObject *a2)
{
  sub_10003CAE4(a1);
  sub_100011970();
  _os_log_error_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_ERROR, "Remote configuration for '%s' not found!\n", v3, 0xCu);
}

void sub_100066C50(uint64_t a1, NSObject *a2)
{
  int v2 = 136315138;
  uint64_t v3 = a1;
  _os_log_error_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_ERROR, "%s has weak file permission\n", (uint8_t *)&v2, 0xCu);
}

void sub_100066CC8(uint64_t a1, _WORD *a2, os_log_t log)
{
  int v3 = *a2 & 0xF000;
  int v4 = 136315394;
  uint64_t v5 = a1;
  __int16 v6 = 1024;
  int v7 = v3;
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "%s is an invalid file type 0x%x\n", (uint8_t *)&v4, 0x12u);
}

void sub_100066D58(uint64_t a1, NSObject *a2)
{
  int v2 = 136315138;
  uint64_t v3 = a1;
  _os_log_error_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_ERROR, "%s has invalid owner uid\n", (uint8_t *)&v2, 0xCu);
}

void sub_100066DD0(os_log_t log)
{
  *(_WORD *)uint64_t v1 = 0;
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "setuid'ed execution not allowed\n", v1, 2u);
}

void sub_100066E14(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_100066E4C(uint8_t *buf, unsigned char *a2, os_log_t log)
{
  *uint8_t buf = 0;
  *a2 = 0;
  _os_log_debug_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_DEBUG, "getsainfo_by_dst_id - sainfo id = anonymous\n", buf, 2u);
}

void sub_100066E8C(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_100066EC4(unsigned __int8 a1, NSObject *a2)
{
  v2[0] = 67109120;
  v2[1] = a1;
  _os_log_error_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_ERROR, "failed to swap launchd keepalive integer %d\n", (uint8_t *)v2, 8u);
}

void sub_100066F40(os_log_t log)
{
  *(_WORD *)uint64_t v1 = 0;
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "configuration read failed\n", v1, 2u);
}

void sub_100066F84(os_log_t log)
{
  *(_WORD *)uint64_t v1 = 0;
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "ISAKMP mode config structure reset failed, not reloading\n", v1, 2u);
}

void sub_100066FC8()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "failed to get address buffer.\n", v2, v3, v4, v5, v6);
}

void sub_100066FFC()
{
  os_log_t v0 = __error();
  strerror(*v0);
  sub_100011970();
  sub_100014954((void *)&_mh_execute_header, v1, v2, "socket (%s)\n", v3, v4, v5, v6, v7);
}

void sub_10006707C()
{
  os_log_t v0 = __error();
  strerror(*v0);
  sub_100011970();
  sub_100014954((void *)&_mh_execute_header, v1, v2, "connect (%s)\n", v3, v4, v5, v6, v7);
}

void sub_1000670FC()
{
  os_log_t v0 = __error();
  strerror(*v0);
  sub_100011970();
  sub_100014954((void *)&_mh_execute_header, v1, v2, "getsockname (%s)\n", v3, v4, v5, v6, v7);
}

void sub_10006717C()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "failed to put localaddr socket in non-blocking mode\n", v2, v3, v4, v5, v6);
}

void sub_1000671B0(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_10006721C()
{
  ipsec_strerror();
  sub_100011970();
  sub_100014954((void *)&_mh_execute_header, v0, v1, "ipsec_set_policy (%s)\n", v2, v3, v4, v5, v6);
}

void sub_100067294()
{
  uint64_t v0 = __error();
  strerror(*v0);
  sub_100011970();
  sub_100014954((void *)&_mh_execute_header, v1, v2, "setsockopt IP_IPSEC_POLICY (%s)\n", v3, v4, v5, v6, v7);
}

void sub_100067314()
{
  uint64_t v0 = __error();
  strerror(*v0);
  sub_100011970();
  sub_100014954((void *)&_mh_execute_header, v1, v2, "recvmsg (%s)\n", v3, v4, v5, v6, v7);
}

void sub_100067394()
{
  uint64_t v2 = sub_100027D3C();
  uint64_t v3 = strerror(*v2);
  *uint64_t v1 = 136315138;
  int *v0 = v3;
  sub_100007290((void *)&_mh_execute_header, v4, v5, "sendmsg (%s)\n");
}

void sub_1000673E8(const sockaddr *a1)
{
  sub_10003CAE4(a1);
  sub_10003D940();
  sub_100033804((void *)&_mh_execute_header, v1, v2, "dst6 %s %d\n", v3, v4, v5, v6, 2u);
}

void sub_100067474(const sockaddr *a1)
{
  sub_10003CAE4(a1);
  sub_10003D940();
  sub_100033804((void *)&_mh_execute_header, v1, v2, "src6 %s %d\n", v3, v4, v5, v6, 2u);
}

void sub_100067500()
{
  uint64_t v2 = sub_100027D3C();
  uint64_t v3 = strerror(*v2);
  *uint64_t v1 = 136315138;
  int *v0 = v3;
  sub_100007290((void *)&_mh_execute_header, v4, v5, "treating socket error (%s) like packet loss\n");
}

void sub_100067554()
{
  uint64_t v2 = sub_100027D3C();
  uint64_t v3 = strerror(*v2);
  *uint64_t v1 = 136315138;
  int *v0 = v3;
  sub_100007290((void *)&_mh_execute_header, v4, v5, "sendto (%s)\n");
}

void sub_1000675A8()
{
  uint64_t v0 = __error();
  strerror(*v0);
  sub_100011970();
  sub_100014954((void *)&_mh_execute_header, v1, v2, "setsockopt SO_REUSEPORT (%s)\n", v3, v4, v5, v6, v7);
}

void sub_100067628()
{
  uint64_t v0 = __error();
  strerror(*v0);
  sub_100011970();
  sub_100014954((void *)&_mh_execute_header, v1, v2, "bind 1 (%s)\n", v3, v4, v5, v6, v7);
}

void sub_1000676A8()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "failed to put sendsock socket in non-blocking mode\n", v2, v3, v4, v5, v6);
}

void sub_1000676DC()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "address family mismatch\n", v2, v3, v4, v5, v6);
}

void sub_100067710(const sockaddr *a1)
{
  sub_10003CAE4(a1);
  sub_1000072B0((void *)&_mh_execute_header, v1, v2, "send packet to %s\n", v3, v4, v5, v6, 2u);
}

void sub_100067794(const sockaddr *a1)
{
  sub_10003CAE4(a1);
  sub_1000072B0((void *)&_mh_execute_header, v1, v2, "send packet from %s\n", v3, v4, v5, v6, 2u);
}

void sub_100067818(const sockaddr *a1)
{
  sub_10003CAE4(a1);
  sub_1000072B0((void *)&_mh_execute_header, v1, v2, "sockname %s\n", v3, v4, v5, v6, 2u);
}

void sub_10006789C()
{
  uint64_t v0 = __error();
  strerror(*v0);
  sub_100011970();
  sub_100014954((void *)&_mh_execute_header, v1, v2, "%s\n", v3, v4, v5, v6, v7);
}

void sub_10006791C()
{
  sub_1000118D8();
  sub_1000117E8((void *)&_mh_execute_header, v0, v1, "invalid address family: %d\n", v2, v3, v4, v5, v6);
}

void sub_100067988()
{
  sub_1000118D8();
  __int16 v3 = 2048;
  uint64_t v4 = v0;
  _os_log_error_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_ERROR, "unexpected inconsistency: %d %zu\n", v2, 0x12u);
}

void sub_100067A10()
{
  sub_100011970();
  __int16 v3 = 2048;
  uint64_t v4 = v0;
  _os_log_error_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_ERROR, "Call with null args: naddr=%p, saddr=%p\n", v2, 0x16u);
}

void sub_100067A94()
{
  sub_1000118D8();
  sub_1000117E8((void *)&_mh_execute_header, v0, v1, "unknown AF: %u\n", v2, v3, v4, v5, v6);
}

void sub_100067B00(os_log_t log)
{
  *(_WORD *)uint64_t v1 = 0;
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "Throttle insertion failed\n", v1, 2u);
}

void sub_100067B44(os_log_t log)
{
  *(_WORD *)uint64_t v1 = 0;
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "unable to get memory for VID hash\n", v1, 2u);
}

void sub_100067B88(uint8_t *buf, unsigned char *a2, os_log_t log)
{
  *uint8_t buf = 0;
  *a2 = 0;
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "unable to hash vendor ID string\n", buf, 2u);
}

void sub_100067BC8(int a1, NSObject *a2)
{
  v2[0] = 67109120;
  v2[1] = a1;
  _os_log_error_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_ERROR, "invalid vendor ID index: %d\n", (uint8_t *)v2, 8u);
}

void sub_100067C40(os_log_t log)
{
  *(_WORD *)uint64_t v1 = 0;
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "vdup(NULL) called\n", v1, 2u);
}

void sub_100067C84()
{
  sub_100011964();
  sub_1000118D8();
  sub_1000117E8((void *)&_mh_execute_header, v0, v1, "Unsupported address family #0x%x\n", v2, v3, v4, v5, v6);
}

void sub_100067CEC(int a1, NSObject *a2)
{
  int v3 = 136315138;
  uint64_t v4 = sub_10003F504(a1);
  _os_log_error_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_ERROR, "unsupported NAT-T version: %s\n", (uint8_t *)&v3, 0xCu);
}

void sub_100067D78()
{
  sub_100011964();
  sub_1000118D8();
  sub_1000117E8((void *)&_mh_execute_header, v0, v1, "invalid address family: %d\n", v2, v3, v4, v5, v6);
}

void sub_100067DE0()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "failed to get buffer for natoa payload.\n", v2, v3, v4, v5, v6);
}

void sub_100067E14()
{
  sub_100011964();
  sub_1000118D8();
  sub_1000117E8((void *)&_mh_execute_header, v0, v1, "invalid NAT-OA payload %d\n", v2, v3, v4, v5, v6);
}

void sub_100067E7C()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "error allocating addr for NAT-OA payload\n", v2, v3, v4, v5, v6);
}

void sub_100067EB0()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "Allocating memory for natt_options failed!\n", v2, v3, v4, v5, v6);
}

void sub_100067EE4()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "Unexpected short packet\n", v2, v3, v4, v5, v6);
}

void sub_100067F18()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "User credentials sent in cleartext!\n", v2, v3, v4, v5, v6);
}

void sub_100067F4C()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "failed to decrypt message\n", v2, v3, v4, v5, v6);
}

void sub_100067F80()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "Cannot compute hash\n", v2, v3, v4, v5, v6);
}

void sub_100067FB4()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "Hash verification failed\n", v2, v3, v4, v5, v6);
}

void sub_100067FE8()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "isakmp_cfg_newiv called without mode config state\n", v2, v3, v4, v5, v6);
}

void sub_10006801C()
{
  sub_100011838();
  sub_1000118BC((void *)&_mh_execute_header, v0, v1, "isakmp_cfg_reply invalid length of isakmp data, expected %zu actual %d\n", v2, v3, v4, v5, v6);
}

void sub_100068084(int a1)
{
  sub_10003E254(a1);
  sub_100045A20();
  sub_1000383CC((void *)&_mh_execute_header, v1, v2, "Short attribute %s len %zu\n", v3, v4, v5, v6, v7);
}

void sub_100068100(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_100068178()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "Cannot allocate memory for mode-cfg attribute list\n", v2, v3, v4, v5, v6);
}

void sub_1000681AC()
{
  sub_100011838();
  sub_1000118BC((void *)&_mh_execute_header, v0, v1, "isakmp_cfg_request invalid length of isakmp data, expected %zu actual %d\n", v2, v3, v4, v5, v6);
}

void sub_100068214(unsigned char *a1, unsigned char *a2)
{
  sub_100011828(a1, a2);
  sub_100011804((void *)&_mh_execute_header, v2, (uint64_t)v2, "Port pool depleted\n", v3);
}

void sub_100068244(unsigned char *a1, unsigned char *a2)
{
  sub_100011828(a1, a2);
  sub_100011804((void *)&_mh_execute_header, v2, (uint64_t)v2, "Unexpected confsource\n", v3);
}

void sub_100068274(unsigned char *a1, unsigned char *a2)
{
  sub_100011828(a1, a2);
  sub_100011804((void *)&_mh_execute_header, v2, (uint64_t)v2, "Attempt to start phase config whereas Xauth failed\n", v3);
}

void sub_1000682A4()
{
  sub_100011838();
  sub_1000118BC((void *)&_mh_execute_header, v0, v1, "isakmp_cfg_set invalid length of isakmp data, expected %zu actual %d\n", v2, v3, v4, v5, v6);
}

void sub_10006830C(_DWORD *a1, int a2, char **a3)
{
  uint64_t v5 = sub_10003E254(a2);
  *a1 = 136315138;
  *a3 = v5;
  sub_10000A104((void *)&_mh_execute_header, v6, v7, "Unexpected SET attribute %s\n");
}

void sub_100068368(_DWORD *a1, __int16 a2, char **a3)
{
  uint64_t v5 = sub_10003E254(a2 & 0x7FFF);
  *a1 = 136315138;
  *a3 = v5;
  sub_10000A104((void *)&_mh_execute_header, v6, v7, "Attribute %s\n");
}

void sub_1000683C4()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "Bad IPv4 address len\n", v2, v3, v4, v5, v6);
}

void sub_1000683F8()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "Too many addresses given\n", v2, v3, v4, v5, v6);
}

void sub_10006842C()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "ISAKMP mode config exchange with immature phase 1\n", v2, v3, v4, v5, v6);
}

void sub_100068460()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "failed to allocate ph2", v2, v3, v4, v5, v6);
}

void sub_100068494()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "failed to duplicate remote address", v2, v3, v4, v5, v6);
}

void sub_1000684C8()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "failed to duplicate local address", v2, v3, v4, v5, v6);
}

void sub_1000684FC(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_100068570()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "failed to resend packet", v2, v3, v4, v5, v6);
}

void sub_1000685A4()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "isakmp_cfg_config.port_pool == NULL\n", v2, v3, v4, v5, v6);
}

void sub_1000685D8(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_100068644()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "Cannot allocate memory for mode config state\n", v2, v3, v4, v5, v6);
}

void sub_100068678()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "No more addresses available\n", v2, v3, v4, v5, v6);
}

void sub_1000686AC(int a1, NSObject *a2)
{
  uint64_t v4 = qword_10008FE90;
  uint64_t v5 = __error();
  uint8_t v6 = strerror(*v5);
  int v7 = 134218498;
  uint64_t v8 = v4;
  __int16 v9 = 1024;
  int v10 = a1;
  __int16 v11 = 2080;
  __int16 v12 = v6;
  _os_log_error_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_ERROR, "resize pool from %zu to %d impossible: %s", (uint8_t *)&v7, 0x1Cu);
}

void sub_10006876C(int a1, int a2, os_log_t log)
{
  int v3 = 134218496;
  uint64_t v4 = qword_10008FE90;
  __int16 v5 = 1024;
  int v6 = a1;
  __int16 v7 = 1024;
  int v8 = a2;
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "resize pool from %zu to %d impossible port %d is in use\n", (uint8_t *)&v3, 0x18u);
}

void sub_100068804(os_log_t log)
{
  *(_WORD *)uint64_t v1 = 0;
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "Unity mode config request but the peer did not declare itself as  unity compliant\n", v1, 2u);
}

void sub_100068848(int a1)
{
  sub_10003E254(a1);
  sub_1000072B0((void *)&_mh_execute_header, v1, v2, "Ignored attribute %s\n", v3, v4, v5, v6, 2u);
}

void sub_1000688C4(os_log_t log)
{
  int v1 = 136315138;
  uint64_t v2 = &unk_10009029D;
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "Cannot open \"%s\"\n", (uint8_t *)&v1, 0xCu);
}

void sub_10006894C(os_log_t log)
{
  int v1 = 136315138;
  uint64_t v2 = &unk_10009029D;
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "Cannot read \"%s\"\n", (uint8_t *)&v1, 0xCu);
}

void sub_1000689D4(int a1)
{
  sub_10003E254(a1);
  sub_1000072B0((void *)&_mh_execute_header, v1, v2, "Ignored short attribute %s\n", v3, v4, v5, v6, 2u);
}

void sub_100068A50(int a1, uint64_t a2, NSObject *a3)
{
  uint64_t v5 = sub_10003E254(a1);
  unsigned int v6 = bswap32(*(unsigned __int16 *)(a2 + 2)) >> 16;
  int v7 = 136315394;
  int v8 = v5;
  __int16 v9 = 1024;
  unsigned int v10 = v6;
  _os_log_debug_impl((void *)&_mh_execute_header, a3, OS_LOG_TYPE_DEBUG, "Short attribute %s = %d\n", (uint8_t *)&v7, 0x12u);
}

void sub_100068AF8(os_log_t log)
{
  *(_WORD *)uint64_t v1 = 0;
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "Cannot allocate memory\n", v1, 2u);
}

void sub_100068B3C(unsigned __int16 *a1, NSObject *a2)
{
  unsigned int v2 = bswap32(*a1) >> 16;
  v3[0] = 67109120;
  v3[1] = v2;
  _os_log_debug_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_DEBUG, "unity_pfs = %x\n", (uint8_t *)v3, 8u);
}

void sub_100068BC0()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "Xauth request while phase 1 is not completed\n", v2, v3, v4, v5, v6);
}

void sub_100068BF4()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "Cannot allocate buffer\n", v2, v3, v4, v5, v6);
}

void sub_100068C28(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_100068C98()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "Xauth reply but peer did not declare itself as Xauth capable\n", v2, v3, v4, v5, v6);
}

void sub_100068CCC()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "Port pool depleted\n", v2, v3, v4, v5, v6);
}

void sub_100068D00()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "malloc failed, bypass throttling\n", v2, v3, v4, v5, v6);
}

void sub_100068D34(uint64_t a1, uint64_t a2, os_log_t log)
{
  int v3 = 136315394;
  uint64_t v4 = a1;
  __int16 v5 = 2048;
  uint64_t v6 = a2;
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "Throttling in action for %s: delay %lds\n", (uint8_t *)&v3, 0x16u);
}

void sub_100068DBC()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "Unexpected authentication source\n", v2, v3, v4, v5, v6);
}

void sub_100068DF0()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "Cannot allocate memory for Xauth Data\n", v2, v3, v4, v5, v6);
}

void sub_100068E24(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_100068E94()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "xauth group specified but modecfg not found\n", v2, v3, v4, v5, v6);
}

void sub_100068EC8()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "xauth group specified but xauth not found\n", v2, v3, v4, v5, v6);
}

void sub_100068EFC(uint8_t *buf, unsigned char *a2, os_log_t log)
{
  *uint8_t buf = 0;
  *a2 = 0;
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "Unknown group auth source\n", buf, 2u);
}

void sub_100068F3C()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "Delayed Xauth reply: phase 1 no longer exists.\n", v2, v3, v4, v5, v6);
}

void sub_100068F70(uint64_t a1, NSObject *a2)
{
  int v2 = 136315138;
  uint64_t v3 = a1;
  _os_log_error_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_ERROR, "the system group name '%s' is unknown\n", (uint8_t *)&v2, 0xCu);
}

void sub_100068FE8()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "Hybrid auth negotiated but peer did not announced as Xauth capable\n", v2, v3, v4, v5, v6);
}

void sub_10006901C()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "Hybrid auth negotiated but peer did not succeed Xauth exchange\n", v2, v3, v4, v5, v6);
}

void sub_100069050()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "Xauth mode config request but peer did not declare itself as Xauth capable\n", v2, v3, v4, v5, v6);
}

void sub_100069084()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "Unexpected long XAUTH_TYPE attribute\n", v2, v3, v4, v5, v6);
}

void sub_1000690B8(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_100069130()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "Xauth performed with no login supplied\n", v2, v3, v4, v5, v6);
}

void sub_100069164(uint64_t a1, NSObject *a2)
{
  uint64_t v2 = *(void *)(**(void **)(*(void *)a1 + 272) + 8);
  int v3 = 136315138;
  uint64_t v4 = v2;
  _os_log_error_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_ERROR, "No password was found for login %s\n", (uint8_t *)&v3, 0xCu);
}

void sub_1000691EC()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "Xauth mode config set but peer did not declare itself as Xauth capable\n", v2, v3, v4, v5, v6);
}

void sub_100069220()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "Xauth authentication failed\n", v2, v3, v4, v5, v6);
}

void sub_100069254()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "Unexpected XAUTH_STATUS_OK\n", v2, v3, v4, v5, v6);
}

void sub_100069288()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "Unexpected XAUTH_STATUS_OK... not a Phase 1 rekey\n", v2, v3, v4, v5, v6);
}

void sub_1000692BC()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "xauth_rmconf_used: malloc failed\n", v2, v3, v4, v5, v6);
}

void sub_1000692F0()
{
  uint64_t v0 = __error();
  strerror(*v0);
  sub_100011970();
  sub_100014954((void *)&_mh_execute_header, v1, v2, "memory error: %s\n", v3, v4, v5, v6, v7);
}

void sub_100069370()
{
  uint64_t v0 = __error();
  strerror(*v0);
  sub_100011970();
  sub_100014954((void *)&_mh_execute_header, v1, v2, "failed to accept vpn_control command: %s\n", v3, v4, v5, v6, v7);
}

void sub_1000693F0()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "could not create comm socket source.", v2, v3, v4, v5, v6);
}

void sub_100069424()
{
  uint64_t v0 = __error();
  strerror(*v0);
  sub_100011970();
  sub_100014954((void *)&_mh_execute_header, v1, v2, "failed to recv vpn_control command: %s\n", v3, v4, v5, v6, v7);
}

void sub_1000694A4()
{
  sub_10004A288();
  sub_10004A1DC((void *)&_mh_execute_header, v0, v1, "invalid header length of vpn_control command - len=%ld - expected %ld\n", v2, v3, v4, v5, v6);
}

void sub_100069514()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "failed to alloc buffer for vpn_control command\n", v2, v3, v4, v5, v6);
}

void sub_100069548()
{
  uint64_t v0 = __error();
  strerror(*v0);
  sub_100011970();
  sub_100014954((void *)&_mh_execute_header, v1, v2, "failed to send vpn_control message: %s\n", v3, v4, v5, v6, v7);
}

void sub_1000695C8(unsigned __int16 *a1, NSObject *a2)
{
  unsigned int v2 = bswap32(*a1) >> 16;
  v3[0] = 67109120;
  v3[1] = v2;
  _os_log_error_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_ERROR, "invalid command: %d\n", (uint8_t *)v3, 8u);
}

void sub_10006964C()
{
  sub_10004A210();
  sub_10004A1DC((void *)&_mh_execute_header, v0, v1, "invalid header length for vpnctl bind cmd - len=%ld - expected %ld\n", v2, v3, v4, v5, v6);
}

void sub_1000696B4()
{
  sub_10004A248();
  sub_10004A1F8((void *)&_mh_execute_header, v0, (uint64_t)v0, "invalid length for vpnctl bind cmd - len=%ld - expected %ld\n", v1);
}

void sub_100069734()
{
  sub_10004A1C0();
  sub_10004A1DC((void *)&_mh_execute_header, v0, v1, "invalid header length for vpnctl unbind cmd - len=%ld - expected %ld\n", v2, v3, v4, v5, v6);
}

void sub_10006979C()
{
  sub_10004A288();
  sub_10004A1DC((void *)&_mh_execute_header, v0, v1, "invalid header length for vpnctl redirect cmd - len=%ld - expected %ld\n", v2, v3, v4, v5, v6);
}

void sub_10006980C()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "cannot allcoate memory for redirect address.\n", v2, v3, v4, v5, v6);
}

void sub_100069840()
{
  sub_10004A1C0();
  sub_10004A1DC((void *)&_mh_execute_header, v0, v1, "invalid header length for vpnctl xauth info cmd - len=%ld - expected %ld\n", v2, v3, v4, v5, v6);
}

void sub_1000698A8()
{
  sub_10004A248();
  sub_10004A1F8((void *)&_mh_execute_header, v0, (uint64_t)v0, "invalid length for vpnctl xauth info cmd - len=%ld - expected %ld\n", v1);
}

void sub_100069928()
{
  sub_10004A22C();
  sub_10004A1DC((void *)&_mh_execute_header, v0, v1, "invalid header length for vpnctl nat64 prefix cmd - len=%ld - expected %ld\n", v2, v3, v4, v5, v6);
}

void sub_100069990()
{
  sub_10004A1C0();
  sub_10004A1DC((void *)&_mh_execute_header, v0, v1, "invalid header length for vpnctl connect cmd - len=%ld - expected %ld\n", v2, v3, v4, v5, v6);
}

void sub_1000699F8()
{
  sub_10004A1C0();
  sub_10004A1DC((void *)&_mh_execute_header, v0, v1, "invalid header length for vpnctl disconnect cmd - len=%ld - expected %ld\n", v2, v3, v4, v5, v6);
}

void sub_100069A60()
{
  sub_10004A22C();
  sub_10004A1DC((void *)&_mh_execute_header, v0, v1, "invalid header length for vpnctl start ph2 cmd - len=%ld - expected %ld\n", v2, v3, v4, v5, v6);
}

void sub_100069AC8()
{
  sub_10004A1C0();
  sub_10004A1DC((void *)&_mh_execute_header, v0, v1, "invalid header length for vpnctl start dpd cmd - len=%ld - expected %ld\n", v2, v3, v4, v5, v6);
}

void sub_100069B30()
{
  sub_10004A210();
  sub_10004A1DC((void *)&_mh_execute_header, v0, v1, "invalid header length for vpnctl assert cmd - len=%ld - expected %ld\n", v2, v3, v4, v5, v6);
}

void sub_100069B98()
{
  sub_10004A1C0();
  sub_10004A1DC((void *)&_mh_execute_header, v0, v1, "invalid header length for vpnctl reconnect cmd - len=%ld - expected %ld\n", v2, v3, v4, v5, v6);
}

void sub_100069C00()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "unable to allocate space for vpn control message.\n", v2, v3, v4, v5, v6);
}

void sub_100069C34()
{
  uint64_t v0 = sub_100027D3C();
  uint64_t v1 = strerror(*v0);
  sub_10001C4CC((uint64_t)v1, 4.8149e-34);
  sub_100007290((void *)&_mh_execute_header, v2, v3, "failed to send vpn_control need authinfo status: %s\n");
}

void sub_100069C84()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "unable to allcate memory for vpn control status message.\n", v2, v3, v4, v5, v6);
}

void sub_100069CB8()
{
  uint64_t v0 = sub_100027D3C();
  uint64_t v1 = strerror(*v0);
  sub_10001C4CC((uint64_t)v1, 4.8149e-34);
  sub_100007290((void *)&_mh_execute_header, v2, v3, "Unable to send vpn_control ike notify failed: %s\n");
}

void sub_100069D08(unsigned __int16 a1, __int16 a2, os_log_t log)
{
  uint64_t v3 = "remote";
  if (!a2) {
    uint64_t v3 = "local";
  }
  v4[0] = 67109378;
  v4[1] = a1;
  __int16 v5 = 2080;
  uint8_t v6 = v3;
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "sending vpn_control ike failed message - code=%d  from=%s.\n", (uint8_t *)v4, 0x12u);
}

void sub_100069DAC()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "bad address for ph2 status change.\n", v2, v3, v4, v5, v6);
}

void sub_100069DE0()
{
  uint64_t v0 = sub_100027D3C();
  uint64_t v1 = strerror(*v0);
  sub_10001C4CC((uint64_t)v1, 4.8149e-34);
  sub_100007290((void *)&_mh_execute_header, v2, v3, "failed to send vpn_control phase change status: %s\n");
}

void sub_100069E30()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "bad address for ph1 status change.\n", v2, v3, v4, v5, v6);
}

void sub_100069E64()
{
  uint64_t v0 = sub_100027D3C();
  uint64_t v1 = strerror(*v0);
  sub_10001C4CC((uint64_t)v1, 4.8149e-34);
  sub_100007290((void *)&_mh_execute_header, v2, v3, "unable to send vpn_control status (peer response): %s\n");
}

void sub_100069EB4()
{
  uint64_t v0 = __error();
  strerror(*v0);
  sub_100011970();
  sub_100014954((void *)&_mh_execute_header, v1, v2, "socket: %s\n", v3, v4, v5, v6, v7);
}

void sub_100069F34()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "could not create vpncontrol socket source.", v2, v3, v4, v5, v6);
}

void sub_100069F68(NSObject *a1)
{
  uint64_t v2 = __error();
  strerror(*v2);
  v4[0] = 136315394;
  sub_10004A274();
  sub_10004A1F8((void *)&_mh_execute_header, a1, v3, "listen(sockname:%s): %s\n", (uint8_t *)v4);
}

void sub_100069FFC(NSObject *a1)
{
  uint64_t v2 = __error();
  strerror(*v2);
  v4[0] = 136315650;
  sub_10004A260();
  __int16 v5 = 2080;
  uint64_t v6 = v3;
  _os_log_error_impl((void *)&_mh_execute_header, a1, OS_LOG_TYPE_ERROR, "chmod(%s, 0%03o): %s\n", (uint8_t *)v4, 0x1Cu);
}

void sub_10006A0AC(NSObject *a1)
{
  int v2 = dword_1000906CC;
  uint64_t v3 = __error();
  strerror(*v3);
  v6[0] = 136315906;
  sub_10004A260();
  __int16 v7 = v4;
  int v8 = v2;
  __int16 v9 = 2080;
  uint64_t v10 = v5;
  _os_log_error_impl((void *)&_mh_execute_header, a1, OS_LOG_TYPE_ERROR, "chown(%s, %d, %d): %s\n", (uint8_t *)v6, 0x22u);
}

void sub_10006A174(NSObject *a1)
{
  int v2 = __error();
  strerror(*v2);
  v4[0] = 136315394;
  sub_10004A274();
  sub_10004A1F8((void *)&_mh_execute_header, a1, v3, "bind(sockname:%s): %s\n", (uint8_t *)v4);
}

void sub_10006A208()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "failed to put VPN-Control socket in non-blocking mode\n", v2, v3, v4, v5, v6);
}

void sub_10006A23C(int a1)
{
  strerror(a1);
  sub_100011970();
  sub_100014954((void *)&_mh_execute_header, v1, v2, "failed to launch_activate_socket with error %s.\n", v3, v4, v5, v6, v7);
}

void sub_10006A2B4(const sockaddr *a1)
{
  sub_10003CE24(a1);
  sub_100011970();
  sub_100014954((void *)&_mh_execute_header, v1, v2, "no configuration found for %s\n", v3, v4, v5, v6, v7);
}

void sub_10006A32C()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "cannot get local address\n", v2, v3, v4, v5, v6);
}

void sub_10006A360()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "failed to duplicate address\n", v2, v3, v4, v5, v6);
}

void sub_10006A394(unsigned __int8 *a1, NSObject *a2)
{
  int v2 = *a1;
  v3[0] = 67109120;
  v3[1] = v2;
  _os_log_error_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_ERROR, "invalid family: %d\n", (uint8_t *)v3, 8u);
}

void sub_10006A410()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "failed to duplicate local address\n", v2, v3, v4, v5, v6);
}

void sub_10006A444()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "Cannot start Phase 2 - no Phase 1 found.\n", v2, v3, v4, v5, v6);
}

void sub_10006A478()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "Cannot start Phase 2 - Phase 1 not established.\n", v2, v3, v4, v5, v6);
}

void sub_10006A4AC()
{
  sub_10004B3A4();
  sub_10002E4D8((void *)&_mh_execute_header, v0, v1, "invalid length for vpn ph2 selector - len=%ld - expected %ld\n", v2, v3);
}

void sub_10006A514()
{
  sub_10004B3A4();
  sub_10002E4D8((void *)&_mh_execute_header, v0, v1, "invalid length for vpn ph2 algo - len=%ld - expected %ld\n", v2, v3);
}

void sub_10006A57C()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "Unable to allocate sainfo struct.\n", v2, v3, v4, v5, v6);
}

void sub_10006A5B0()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "Unable to allocate id struct.\n", v2, v3, v4, v5, v6);
}

void sub_10006A5E4(uint64_t *a1)
{
  sub_10003A83C(a1);
  sub_100011970();
  sub_100014954((void *)&_mh_execute_header, v1, v2, "No encryption algorithm at %s\n", v3, v4, v5, v6, v7);
}

void sub_10006A65C(uint64_t *a1)
{
  sub_10003A83C(a1);
  sub_100011970();
  sub_100014954((void *)&_mh_execute_header, v1, v2, "No authentication algorithm at %s\n", v3, v4, v5, v6, v7);
}

void sub_10006A6D4(uint64_t *a1)
{
  sub_10003A83C(a1);
  sub_100011970();
  sub_100014954((void *)&_mh_execute_header, v1, v2, "No compression algorithm at %s\n", v3, v4, v5, v6, v7);
}

void sub_10006A74C(uint64_t *a1)
{
  sub_10003A83C(a1);
  sub_100011970();
  sub_100014954((void *)&_mh_execute_header, v1, v2, "Duplicated sainfo: %s\n", v3, v4, v5, v6, v7);
}

void sub_10006A7C4()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "Failed to allocate algorithm structure\n", v2, v3, v4, v5, v6);
}

void sub_10006A7F8()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "Algorithm mismatched\n", v2, v3, v4, v5, v6);
}

void sub_10006A82C(int a1, uint64_t a2)
{
  sub_10003E580(a1, a2);
  sub_100011970();
  sub_100014954((void *)&_mh_execute_header, v2, v3, "Algorithm %s not supported by the kernel (missing module?)\n", v4, v5, v6, v7, v8);
}

void sub_10006A8A4()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "keylen not allowed\n", v2, v3, v4, v5, v6);
}

void sub_10006A8D8(int a1, NSObject *a2)
{
  v2[0] = 67109120;
  v2[1] = a1;
  _os_log_error_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_ERROR, "invalid keylen %d\n", (uint8_t *)v2, 8u);
}

void sub_10006A950(uint8_t *buf, uint64_t a2, _DWORD *a3, os_log_t log)
{
  int v4 = *(_DWORD *)(*(void *)a2 + 188);
  *(_DWORD *)uint8_t buf = 67109120;
  *a3 = v4;
  _os_log_debug_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_DEBUG, "Using dh group %d for aggressive mode\n", buf, 8u);
}

void sub_10006A9A4(uint8_t *buf, uint64_t a2, _DWORD *a3, os_log_t log)
{
  int v4 = *(_DWORD *)(*(void *)a2 + 60);
  *(_DWORD *)uint8_t buf = 67109120;
  *a3 = v4;
  _os_log_debug_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_DEBUG, "Using dh group %d for main mode\n", buf, 8u);
}

void sub_10006A9F8()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "Invalid dh group specified\n", v2, v3, v4, v5, v6);
}

void sub_10006AA2C()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "Unable to find address structure.\n", v2, v3, v4, v5, v6);
}

void sub_10006AA60()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "Failed to allocate space for message.\n", v2, v3, v4, v5, v6);
}

void sub_10006AA94()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "Cannot reply to xauth request - no ph1 found.\n", v2, v3, v4, v5, v6);
}

void sub_10006AAC8()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "Received xauth reply data with no xauth reply pending \n", v2, v3, v4, v5, v6);
}

void sub_10006AAFC()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "Cannot allocate memory for xauth reply\n", v2, v3, v4, v5, v6);
}

void sub_10006AB30()
{
  sub_100002F08();
  _os_log_debug_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_DEBUG, "Sending MODE_CFG REPLY\n", v1, 2u);
}

void sub_10006AB70()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "Invalid auth info received from VPN Control socket.\n", v2, v3, v4, v5, v6);
}

void sub_10006ABA4()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "Cannot assert - no matching session.\n", v2, v3, v4, v5, v6);
}

void sub_10006ABD8(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_10006AC50(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_10006ACC8(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_10006AD40(const sockaddr *a1)
{
  sub_10003CAE4(a1 + 8);
  sub_100011970();
  sub_1000072B0((void *)&_mh_execute_header, v1, v2, "New IKE-Session to %s.\n", v3, v4, v5, v6, v7);
}

void sub_10006ADBC(const sockaddr *a1)
{
  sub_10003CAE4(a1);
  sub_100011970();
  sub_1000072B0((void *)&_mh_execute_header, v1, v2, "Pre-existing IKE-Session to %s. case 1.\n", v3, v4, v5, v6, v7);
}

void sub_10006AE34(uint64_t a1)
{
  sub_10003CAE4((const sockaddr *)(a1 + 136));
  sub_100011970();
  sub_1000072B0((void *)&_mh_execute_header, v1, v2, "Best-match IKE-Session to %s.\n", v3, v4, v5, v6, v7);
}

void sub_10006AEB0(const sockaddr *a1)
{
  sub_10003CAE4(a1);
  sub_100011970();
  sub_1000072B0((void *)&_mh_execute_header, v1, v2, "Pre-existing IKE-Session to %s. case 2.\n", v3, v4, v5, v6, v7);
}

void sub_10006AF28(const sockaddr *a1)
{
  sub_10003CAE4(a1);
  sub_100011970();
  sub_1000072B0((void *)&_mh_execute_header, v1, v2, "Pre-existing IKE-Session to %s. case 3.\n", v3, v4, v5, v6, v7);
}

void sub_10006AFA0(uint8_t *a1, uint64_t a2, uint64_t **a3, NSObject *a4)
{
  uint8_t v7 = sub_10003CAE4((const sockaddr *)(a2 + 136));
  *(_DWORD *)a1 = 136315138;
  *a3 = v7;
  _os_log_debug_impl((void *)&_mh_execute_header, a4, OS_LOG_TYPE_DEBUG, "still search for IKE-Session. this %s.\n", a1, 0xCu);
}

void sub_10006B00C(const sockaddr *a1)
{
  sub_10003CAE4(a1);
  sub_100011970();
  sub_1000072B0((void *)&_mh_execute_header, v1, v2, "start search for IKE-Session. target %s.\n", v3, v4, v5, v6, v7);
}

void sub_10006B084(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_10006B0FC(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_10006B174(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_10006B1EC(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_10006B264(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_10006B2DC(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_10006B354(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_10006B3CC(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_10006B444(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_10006B4BC(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_10006B534(uint8_t *buf, void *a2, os_log_t log)
{
  *(_DWORD *)uint8_t buf = 136315138;
  *a2 = "ike_session_rebind_all_ph12_to_new_ph1";
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "Same Phase 2 in ph1bind replacement in %s.\n", buf, 0xCu);
}

void sub_10006B584(uint8_t *buf, unsigned char *a2, os_log_t log)
{
  *uint8_t buf = 0;
  *a2 = 0;
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "Mismatched parent session in ph1bind replacement.\n", buf, 2u);
}

void sub_10006B5C4(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_10006B63C(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_10006B6B4(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_10006B72C(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_10006B7A4(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_10006B81C(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_10006B894(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_10006B90C(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_10006B984(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_10006B9FC(int *a1, uint64_t a2, os_log_t log)
{
  int v3 = *a1;
  int v4 = *(_DWORD *)(a2 + 100);
  int v5 = *(unsigned __int8 *)(a2 + 264) << 30 >> 31;
  v6[0] = 67109632;
  v6[1] = v3;
  __int16 v7 = 1024;
  int v8 = v4;
  __int16 v9 = 1024;
  int v10 = v5;
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "about to cleanup ph2: status %d, seq %d dying %d\n", (uint8_t *)v6, 0x14u);
}

void sub_10006BAA0(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_10006BB18(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_10006BB90(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_10006BC08(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_10006BC80(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_10006BCF8(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_10006BD70(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_10006BDE8(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_10006BE60(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_10006BED8(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_10006BF50(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_10006BFC8(unsigned __int8 *a1, NSObject *a2)
{
  int v2 = *a1;
  int v3 = *((unsigned __int16 *)a1 + 1);
  int v4 = 136315650;
  int v5 = "ike_session_is_id_portany";
  __int16 v6 = 1024;
  int v7 = v2;
  __int16 v8 = 1024;
  int v9 = v3;
  _os_log_debug_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_DEBUG, "not portany_ids in %s: type %d, port %x.\n", (uint8_t *)&v4, 0x18u);
}

void sub_10006C064()
{
  sub_10003D940();
  sub_100015478((void *)&_mh_execute_header, v0, v1, "%s: pre-assigned spid %d.\n", v2, v3, v4, v5, 2u);
}

void sub_10006C0DC(NSObject *a1, uint64_t a2, uint64_t a3)
{
  int v3 = 136315138;
  uint64_t v4 = "ike_session_get_sainfo_r";
  sub_10004FEB4((void *)&_mh_execute_header, a1, a3, "candidate ph2 matched in %s.\n", (uint8_t *)&v3);
}

void sub_10006C158(uint8_t *a1, void *a2, NSObject *a3)
{
  *(_DWORD *)a1 = 136315138;
  *a2 = "ike_session_get_sainfo_r";
  sub_10004FEB4((void *)&_mh_execute_header, a3, (uint64_t)a3, "candidate ph2 found in %s.\n", a1);
}

void sub_10006C1A0()
{
  sub_10004FECC();
  sub_100015478((void *)&_mh_execute_header, v0, v1, "ipany_ids %d in %s.\n", v2, v3, v4, v5, v6);
}

void sub_10006C214()
{
  sub_10003D940();
  sub_100015478((void *)&_mh_execute_header, v0, v1, "%s: pre-assigned spid %d.\n", v2, v3, v4, v5, 2u);
}

void sub_10006C28C(NSObject *a1, uint64_t a2, uint64_t a3)
{
  int v3 = 136315138;
  uint64_t v4 = "ike_session_get_proposal_r";
  sub_10004FEB4((void *)&_mh_execute_header, a1, a3, "candidate ph2 matched in %s.\n", (uint8_t *)&v3);
}

void sub_10006C308(uint8_t *a1, void *a2, NSObject *a3)
{
  *(_DWORD *)a1 = 136315138;
  *a2 = "ike_session_get_proposal_r";
  sub_10004FEB4((void *)&_mh_execute_header, a3, (uint64_t)a3, "candidate ph2 found in %s.\n", a1);
}

void sub_10006C350()
{
  sub_10004FECC();
  sub_100015478((void *)&_mh_execute_header, v0, v1, "ipany_ids %d in %s.\n", v2, v3, v4, v5, v6);
}

void sub_10006C3C4(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_10006C43C(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_10006C4B4(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_10006C52C(unsigned __int8 *a1, NSObject *a2)
{
  int v2 = *a1;
  int v3 = *((_DWORD *)a1 + 1);
  int v4 = *((_DWORD *)a1 + 2);
  int v5 = 136315906;
  uint8_t v6 = "ike_session_is_id_ipany";
  __int16 v7 = 1024;
  int v8 = v2;
  __int16 v9 = 1024;
  int v10 = v3;
  __int16 v11 = 1024;
  int v12 = v4;
  _os_log_debug_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_DEBUG, "not ipany_ids in %s: type %d, addr %x, mask %x.\n", (uint8_t *)&v5, 0x1Eu);
}

void sub_10006C5D0()
{
  sub_100002F08();
  _os_log_error_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_ERROR, "IORegisterForSystemPower failed for power-mgmt thread\n", v1, 2u);
}

void sub_10006C610(int a1, NSObject *a2)
{
  v2[0] = 67109120;
  v2[1] = a1;
  _os_log_debug_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_DEBUG, "received power-mgmt event: %x\n", (uint8_t *)v2, 8u);
}

void sub_10006C688()
{
  sub_100002F08();
  sub_100004F7C((void *)&_mh_execute_header, v0, v1, "received power-mgmt event: will sleep\n", v2, v3, v4, v5, v6);
}

void sub_10006C6BC()
{
  sub_100002F08();
  sub_100004F7C((void *)&_mh_execute_header, v0, v1, "received power-mgmt event: will not sleep\n", v2, v3, v4, v5, v6);
}

void sub_10006C6F0()
{
  sub_100002F08();
  sub_100004F7C((void *)&_mh_execute_header, v0, v1, "received power-mgmt event: will wake\n", v2, v3, v4, v5, v6);
}

void sub_10006C724()
{
  sub_100002F08();
  sub_100004F7C((void *)&_mh_execute_header, v0, v1, "received power-mgmt event: will power-on\n", v2, v3, v4, v5, v6);
}

void sub_10006C758()
{
  sub_100002F08();
  sub_100004F7C((void *)&_mh_execute_header, v0, v1, "received power-mgmt event: has powered-on\n", v2, v3, v4, v5, v6);
}

void sub_10006C78C()
{
  sub_100002F08();
  sub_100004F7C((void *)&_mh_execute_header, v0, v1, "received power-mgmt event: has woken\n", v2, v3, v4, v5, v6);
}

void sub_10006C7C0()
{
  sub_100002F08();
  sub_100004F7C((void *)&_mh_execute_header, v0, v1, "handling power-mgmt event: sleep-wake\n", v2, v3, v4, v5, v6);
}

void sub_10006C7F4()
{
  sub_100002F08();
  sub_100004F7C((void *)&_mh_execute_header, v0, v1, "handling power-mgmt event: power-on\n", v2, v3, v4, v5, v6);
}

void sub_10006C828()
{
}

void sub_10006C844()
{
  sub_100011970();
  sub_100011870((void *)&_mh_execute_header, v0, v1, "xpc connection invalid %s.\n", v2, v3, v4, v5, v6);
}

void sub_10006C8AC()
{
  sub_100011970();
  sub_100011870((void *)&_mh_execute_header, v0, v1, "xpc connection interrupted %s.\n", v2, v3, v4, v5, v6);
}

void sub_10006C914(int a1, uint64_t a2, os_log_t log)
{
  v3[0] = 67109378;
  v3[1] = a1;
  __int16 v4 = 2080;
  uint64_t v5 = a2;
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "xpc connection error %d:%s.\n", (uint8_t *)v3, 0x12u);
}

void sub_10006C99C()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "load_XPC_Service received type == XPC_TYPE_ERROR\n", v2, v3, v4, v5, v6);
}

void sub_10006C9D0(int a1, NSObject *a2)
{
  v2[0] = 67109120;
  v2[1] = a1;
  _os_log_error_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_ERROR, "xpc connection unknown type %x.\n", (uint8_t *)v2, 8u);
}

void sub_10006CA48()
{
  sub_100011970();
  sub_100011870((void *)&_mh_execute_header, v0, v1, "xpc connection unknown client opcode %lld\n", v2, v3, v4, v5, v6);
}

void sub_10006CAB0()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "do_ipsecike_create error\n", v2, v3, v4, v5, v6);
}

void sub_10006CAE4()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "SecTaskCreateWithAuditToken() failed\n", v2, v3, v4, v5, v6);
}

void sub_10006CB18()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "Entitlement not valid\n", v2, v3, v4, v5, v6);
}

void sub_10006CB4C()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "xpc_ike_dict == NULL\n", v2, v3, v4, v5, v6);
}

void sub_10006CB80()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "do_ipsecike_create child_dict == NULL\n", v2, v3, v4, v5, v6);
}

void sub_10006CBB4()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "do_ipsecike_create ike_dict == NULL\n", v2, v3, v4, v5, v6);
}

void sub_10006CBE8()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "Entitlement type not valid\n", v2, v3, v4, v5, v6);
}

void sub_10006CC1C()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "send_xpc_reply xpc_dictionary_get_remote_connection failed\n", v2, v3, v4, v5, v6);
}

void sub_10006CC50()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "create_reply failed\n", v2, v3, v4, v5, v6);
}

void sub_10006CC84()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "do_ipsecike_stop: ikeid == kInternalIKESARefInvalid\n", v2, v3, v4, v5, v6);
}

void sub_10006CCB8()
{
  sub_100011970();
  _os_log_debug_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_DEBUG, "xpc connection wrong XPC type %s.\n", v1, 0xCu);
}

void sub_10006CD2C()
{
  sub_100002F08();
  _os_log_debug_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_DEBUG, "xpc connection unknown XPC type\n", v1, 2u);
}

void sub_10006CD6C()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "failed to expand isakmp proposal.\n", v2, v3, v4, v5, v6);
}

void sub_10006CDA0()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "no proposal found.\n", v2, v3, v4, v5, v6);
}

void sub_10006CDD4(uint8_t *buf, unsigned char *a2, os_log_t log)
{
  *uint8_t buf = 0;
  *a2 = 0;
  _os_log_debug_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_DEBUG, "\n", buf, 2u);
}

void sub_10006CE14()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "multiple proposal definition.\n", v2, v3, v4, v5, v6);
}

void sub_10006CE48()
{
  sub_100002F08();
  _os_log_debug_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_DEBUG, "parse succeeded.\n", v1, 2u);
}

void sub_10006CE88(os_log_t log)
{
  v1[0] = 67109120;
  v1[1] = dword_100090754;
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "parse error is nothing, but yyerrorcount is %d.\n", (uint8_t *)v1, 8u);
}

void sub_10006CF10()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "fatal parse failure.\n", v2, v3, v4, v5, v6);
}

void sub_10006CF44(os_log_t log)
{
  v1[0] = 67109120;
  v1[1] = dword_100090754;
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "fatal parse failure (%d errors)\n", (uint8_t *)v1, 8u);
}

void sub_10006CFCC(os_log_t log)
{
  uint64_t v1 = *(void *)qword_10008F848;
  int v2 = 136315138;
  uint64_t v3 = v1;
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "could not read configuration file \"%s\"\n", (uint8_t *)&v2, 0xCu);
}

void sub_10006D058()
{
  sub_100002F08();
  _os_log_debug_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_DEBUG, "===== parsing configuration\n", v1, 2u);
}

void sub_10006D098(char a1, NSObject *a2)
{
  int v2 = "flush all";
  if (a1) {
    int v2 = "flush negotiating";
  }
  int v3 = 136315138;
  uint64_t v4 = v2;
  _os_log_debug_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_DEBUG, "==== %s sessions.\n", (uint8_t *)&v3, 0xCu);
}

void sub_10006D128(int a1, NSObject *a2)
{
  int v2 = sys_signame[a1];
  int v3 = 136315138;
  uint64_t v4 = v2;
  _os_log_debug_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_DEBUG, "==== Got %s signal - re-parsing configuration.\n", (uint8_t *)&v3, 0xCu);
}

void sub_10006D1AC()
{
  sub_100002F08();
  sub_100002EEC((void *)&_mh_execute_header, v0, v1, "==== Got Unknown signal - re-parsing configuration.\n", v2, v3, v4, v5, v6);
}

void sub_10006D1E0(uint64_t a1, NSObject *a2)
{
  uint64_t v4 = __error();
  uint64_t v5 = strerror(*v4);
  int v6 = 136315394;
  uint64_t v7 = a1;
  __int16 v8 = 2080;
  __int16 v9 = v5;
  _os_log_error_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_ERROR, "failed to open file %s (%s)\n", (uint8_t *)&v6, 0x16u);
}

void sub_10006D284(uint64_t a1, NSObject *a2)
{
  int v2 = 136315138;
  uint64_t v3 = a1;
  _os_log_debug_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_DEBUG, "reading configuration file %s\n", (uint8_t *)&v2, 0xCu);
}

void sub_10006D2FC()
{
  sub_1000569D0();
  sub_1000569AC();
  _os_log_error_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_ERROR, "%s:%d: %s\n", v1, 0x1Cu);
}

void sub_10006D37C(os_log_t log)
{
  *(_WORD *)uint64_t v1 = 0;
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "Includes nested too deeply", v1, 2u);
}

CCCryptorStatus CCCrypt(CCOperation op, CCAlgorithm alg, CCOptions options, const void *key, size_t keyLength, const void *iv, const void *dataIn, size_t dataInLength, void *dataOut, size_t dataOutAvailable, size_t *dataOutMoved)
{
  return _CCCrypt(op, alg, options, key, keyLength, iv, dataIn, dataInLength, dataOut, dataOutAvailable, dataOutMoved);
}

void CCHmacFinal(CCHmacContext *ctx, void *macOut)
{
}

void CCHmacInit(CCHmacContext *ctx, CCHmacAlgorithm algorithm, const void *key, size_t keyLength)
{
}

void CCHmacUpdate(CCHmacContext *ctx, const void *data, size_t dataLength)
{
}

int CC_MD5_Final(unsigned __int8 *md, CC_MD5_CTX *c)
{
  return _CC_MD5_Final(md, c);
}

int CC_MD5_Init(CC_MD5_CTX *c)
{
  return _CC_MD5_Init(c);
}

int CC_MD5_Update(CC_MD5_CTX *c, const void *data, CC_LONG len)
{
  return _CC_MD5_Update(c, data, len);
}

int CC_SHA1_Final(unsigned __int8 *md, CC_SHA1_CTX *c)
{
  return _CC_SHA1_Final(md, c);
}

int CC_SHA1_Init(CC_SHA1_CTX *c)
{
  return _CC_SHA1_Init(c);
}

int CC_SHA1_Update(CC_SHA1_CTX *c, const void *data, CC_LONG len)
{
  return _CC_SHA1_Update(c, data, len);
}

int CC_SHA256_Final(unsigned __int8 *md, CC_SHA256_CTX *c)
{
  return _CC_SHA256_Final(md, c);
}

int CC_SHA256_Init(CC_SHA256_CTX *c)
{
  return _CC_SHA256_Init(c);
}

int CC_SHA256_Update(CC_SHA256_CTX *c, const void *data, CC_LONG len)
{
  return _CC_SHA256_Update(c, data, len);
}

int CC_SHA384_Final(unsigned __int8 *md, CC_SHA512_CTX *c)
{
  return _CC_SHA384_Final(md, c);
}

int CC_SHA384_Init(CC_SHA512_CTX *c)
{
  return _CC_SHA384_Init(c);
}

int CC_SHA384_Update(CC_SHA512_CTX *c, const void *data, CC_LONG len)
{
  return _CC_SHA384_Update(c, data, len);
}

int CC_SHA512_Final(unsigned __int8 *md, CC_SHA512_CTX *c)
{
  return _CC_SHA512_Final(md, c);
}

int CC_SHA512_Init(CC_SHA512_CTX *c)
{
  return _CC_SHA512_Init(c);
}

int CC_SHA512_Update(CC_SHA512_CTX *c, const void *data, CC_LONG len)
{
  return _CC_SHA512_Update(c, data, len);
}

CFAbsoluteTime CFAbsoluteTimeGetCurrent(void)
{
  return _CFAbsoluteTimeGetCurrent();
}

void *__cdecl CFAllocatorAllocate(CFAllocatorRef allocator, CFIndex size, CFOptionFlags hint)
{
  return _CFAllocatorAllocate(allocator, size, hint);
}

void CFAllocatorDeallocate(CFAllocatorRef allocator, void *ptr)
{
}

void CFArrayAppendValue(CFMutableArrayRef theArray, const void *value)
{
}

CFArrayRef CFArrayCreate(CFAllocatorRef allocator, const void **values, CFIndex numValues, const CFArrayCallBacks *callBacks)
{
  return _CFArrayCreate(allocator, values, numValues, callBacks);
}

CFMutableArrayRef CFArrayCreateMutable(CFAllocatorRef allocator, CFIndex capacity, const CFArrayCallBacks *callBacks)
{
  return _CFArrayCreateMutable(allocator, capacity, callBacks);
}

CFIndex CFArrayGetCount(CFArrayRef theArray)
{
  return _CFArrayGetCount(theArray);
}

const void *__cdecl CFArrayGetValueAtIndex(CFArrayRef theArray, CFIndex idx)
{
  return _CFArrayGetValueAtIndex(theArray, idx);
}

CFTypeID CFBooleanGetTypeID(void)
{
  return _CFBooleanGetTypeID();
}

Boolean CFBooleanGetValue(CFBooleanRef BOOLean)
{
  return _CFBooleanGetValue(BOOLean);
}

CFCalendarRef CFCalendarCreateWithIdentifier(CFAllocatorRef allocator, CFCalendarIdentifier identifier)
{
  return _CFCalendarCreateWithIdentifier(allocator, identifier);
}

Boolean CFCalendarDecomposeAbsoluteTime(CFCalendarRef calendar, CFAbsoluteTime at, const char *componentDesc, ...)
{
  va_start(va, componentDesc);
  uint64_t v3 = va_arg(va, const char *);
  return _CFCalendarDecomposeAbsoluteTime(calendar, at, v3);
}

CFDataRef CFDataCreate(CFAllocatorRef allocator, const UInt8 *bytes, CFIndex length)
{
  return _CFDataCreate(allocator, bytes, length);
}

CFDataRef CFDataCreateWithBytesNoCopy(CFAllocatorRef allocator, const UInt8 *bytes, CFIndex length, CFAllocatorRef bytesDeallocator)
{
  return _CFDataCreateWithBytesNoCopy(allocator, bytes, length, bytesDeallocator);
}

const UInt8 *__cdecl CFDataGetBytePtr(CFDataRef theData)
{
  return _CFDataGetBytePtr(theData);
}

void CFDataGetBytes(CFDataRef theData, CFRange range, UInt8 *buffer)
{
}

CFIndex CFDataGetLength(CFDataRef theData)
{
  return _CFDataGetLength(theData);
}

CFComparisonResult CFDateCompare(CFDateRef theDate, CFDateRef otherDate, void *context)
{
  return _CFDateCompare(theDate, otherDate, context);
}

CFDateRef CFDateCreate(CFAllocatorRef allocator, CFAbsoluteTime at)
{
  return _CFDateCreate(allocator, at);
}

void CFDictionaryAddValue(CFMutableDictionaryRef theDict, const void *key, const void *value)
{
}

Boolean CFDictionaryContainsKey(CFDictionaryRef theDict, const void *key)
{
  return _CFDictionaryContainsKey(theDict, key);
}

CFDictionaryRef CFDictionaryCreate(CFAllocatorRef allocator, const void **keys, const void **values, CFIndex numValues, const CFDictionaryKeyCallBacks *keyCallBacks, const CFDictionaryValueCallBacks *valueCallBacks)
{
  return _CFDictionaryCreate(allocator, keys, values, numValues, keyCallBacks, valueCallBacks);
}

CFMutableDictionaryRef CFDictionaryCreateMutable(CFAllocatorRef allocator, CFIndex capacity, const CFDictionaryKeyCallBacks *keyCallBacks, const CFDictionaryValueCallBacks *valueCallBacks)
{
  return _CFDictionaryCreateMutable(allocator, capacity, keyCallBacks, valueCallBacks);
}

CFIndex CFDictionaryGetCount(CFDictionaryRef theDict)
{
  return _CFDictionaryGetCount(theDict);
}

CFTypeID CFDictionaryGetTypeID(void)
{
  return _CFDictionaryGetTypeID();
}

const void *__cdecl CFDictionaryGetValue(CFDictionaryRef theDict, const void *key)
{
  return _CFDictionaryGetValue(theDict, key);
}

void CFDictionaryRemoveValue(CFMutableDictionaryRef theDict, const void *key)
{
}

void CFDictionarySetValue(CFMutableDictionaryRef theDict, const void *key, const void *value)
{
}

CFTypeID CFGetTypeID(CFTypeRef cf)
{
  return _CFGetTypeID(cf);
}

CFNumberRef CFNumberCreate(CFAllocatorRef allocator, CFNumberType theType, const void *valuePtr)
{
  return _CFNumberCreate(allocator, theType, valuePtr);
}

CFTypeID CFNumberGetTypeID(void)
{
  return _CFNumberGetTypeID();
}

Boolean CFNumberGetValue(CFNumberRef number, CFNumberType theType, void *valuePtr)
{
  return _CFNumberGetValue(number, theType, valuePtr);
}

void CFRelease(CFTypeRef cf)
{
}

CFComparisonResult CFStringCompare(CFStringRef theString1, CFStringRef theString2, CFStringCompareFlags compareOptions)
{
  return _CFStringCompare(theString1, theString2, compareOptions);
}

CFStringRef CFStringCreateWithBytes(CFAllocatorRef alloc, const UInt8 *bytes, CFIndex numBytes, CFStringEncoding encoding, Boolean isExternalRepresentation)
{
  return _CFStringCreateWithBytes(alloc, bytes, numBytes, encoding, isExternalRepresentation);
}

CFStringRef CFStringCreateWithCString(CFAllocatorRef alloc, const char *cStr, CFStringEncoding encoding)
{
  return _CFStringCreateWithCString(alloc, cStr, encoding);
}

CFStringRef CFStringCreateWithFormatAndArguments(CFAllocatorRef alloc, CFDictionaryRef formatOptions, CFStringRef format, va_list arguments)
{
  return _CFStringCreateWithFormatAndArguments(alloc, formatOptions, format, arguments);
}

Boolean CFStringGetCString(CFStringRef theString, char *buffer, CFIndex bufferSize, CFStringEncoding encoding)
{
  return _CFStringGetCString(theString, buffer, bufferSize, encoding);
}

const char *__cdecl CFStringGetCStringPtr(CFStringRef theString, CFStringEncoding encoding)
{
  return _CFStringGetCStringPtr(theString, encoding);
}

CFIndex CFStringGetLength(CFStringRef theString)
{
  return _CFStringGetLength(theString);
}

CFIndex CFStringGetMaximumSizeForEncoding(CFIndex length, CFStringEncoding encoding)
{
  return _CFStringGetMaximumSizeForEncoding(length, encoding);
}

CFTypeID CFStringGetTypeID(void)
{
  return _CFStringGetTypeID();
}

CFUUIDRef CFUUIDCreateFromUUIDBytes(CFAllocatorRef alloc, CFUUIDBytes bytes)
{
  return _CFUUIDCreateFromUUIDBytes(alloc, bytes);
}

IOReturn IOAllowPowerChange(io_connect_t kernelPort, intptr_t notificationID)
{
  return _IOAllowPowerChange(kernelPort, notificationID);
}

IOReturn IODeregisterForSystemPower(io_object_t *notifier)
{
  return _IODeregisterForSystemPower(notifier);
}

void IONotificationPortDestroy(IONotificationPortRef notify)
{
}

void IONotificationPortSetDispatchQueue(IONotificationPortRef notify, dispatch_queue_t queue)
{
}

io_connect_t IORegisterForSystemPower(void *refcon, IONotificationPortRef *thePortRef, IOServiceInterestCallback callback, io_object_t *notifier)
{
  return _IORegisterForSystemPower(refcon, thePortRef, callback, notifier);
}

uint64_t NEPolicyAdd()
{
  return _NEPolicyAdd();
}

uint64_t NEPolicyApply()
{
  return _NEPolicyApply();
}

uint64_t NEPolicyCreateSession()
{
  return _NEPolicyCreateSession();
}

SCPreferencesRef SCPreferencesCreate(CFAllocatorRef allocator, CFStringRef name, CFStringRef prefsID)
{
  return _SCPreferencesCreate(allocator, name, prefsID);
}

CFPropertyListRef SCPreferencesGetValue(SCPreferencesRef prefs, CFStringRef key)
{
  return _SCPreferencesGetValue(prefs, key);
}

Boolean SCPreferencesSetCallback(SCPreferencesRef prefs, SCPreferencesCallBack callout, SCPreferencesContext *context)
{
  return _SCPreferencesSetCallback(prefs, callout, context);
}

Boolean SCPreferencesSetDispatchQueue(SCPreferencesRef prefs, dispatch_queue_t queue)
{
  return _SCPreferencesSetDispatchQueue(prefs, queue);
}

void SCPreferencesSynchronize(SCPreferencesRef prefs)
{
}

uint64_t SecCertificateCopyDNSNames()
{
  return _SecCertificateCopyDNSNames();
}

CFDataRef SecCertificateCopyData(SecCertificateRef certificate)
{
  return _SecCertificateCopyData(certificate);
}

uint64_t SecCertificateCopyIPAddresses()
{
  return _SecCertificateCopyIPAddresses();
}

uint64_t SecCertificateCopyRFC822Names()
{
  return _SecCertificateCopyRFC822Names();
}

uint64_t SecCertificateCopySubjectSequence()
{
  return _SecCertificateCopySubjectSequence();
}

SecCertificateRef SecCertificateCreateWithData(CFAllocatorRef allocator, CFDataRef data)
{
  return _SecCertificateCreateWithData(allocator, data);
}

uint64_t SecCertificateIsValid()
{
  return _SecCertificateIsValid();
}

uint64_t SecCertificateNotValidAfter()
{
  return _SecCertificateNotValidAfter();
}

uint64_t SecCertificateNotValidBefore()
{
  return _SecCertificateNotValidBefore();
}

uint64_t SecDHComputeKey()
{
  return _SecDHComputeKey();
}

uint64_t SecDHCreate()
{
  return _SecDHCreate();
}

uint64_t SecDHDestroy()
{
  return _SecDHDestroy();
}

uint64_t SecDHGenerateKeypair()
{
  return _SecDHGenerateKeypair();
}

uint64_t SecDHGetMaxKeyLength()
{
  return _SecDHGetMaxKeyLength();
}

OSStatus SecIdentityCopyCertificate(SecIdentityRef identityRef, SecCertificateRef *certificateRef)
{
  return _SecIdentityCopyCertificate(identityRef, certificateRef);
}

OSStatus SecIdentityCopyPrivateKey(SecIdentityRef identityRef, SecKeyRef *privateKeyRef)
{
  return _SecIdentityCopyPrivateKey(identityRef, privateKeyRef);
}

OSStatus SecItemCopyMatching(CFDictionaryRef query, CFTypeRef *result)
{
  return _SecItemCopyMatching(query, result);
}

OSStatus SecKeyRawSign(SecKeyRef key, SecPadding padding, const uint8_t *dataToSign, size_t dataToSignLen, uint8_t *sig, size_t *sigLen)
{
  return _SecKeyRawSign(key, padding, dataToSign, dataToSignLen, sig, sigLen);
}

OSStatus SecKeyRawVerify(SecKeyRef key, SecPadding padding, const uint8_t *signedData, size_t signedDataLen, const uint8_t *sig, size_t sigLen)
{
  return _SecKeyRawVerify(key, padding, signedData, signedDataLen, sig, sigLen);
}

SecPolicyRef SecPolicyCreateWithProperties(CFTypeRef policyIdentifier, CFDictionaryRef properties)
{
  return _SecPolicyCreateWithProperties(policyIdentifier, properties);
}

int SecRandomCopyBytes(SecRandomRef rnd, size_t count, void *bytes)
{
  return _SecRandomCopyBytes(rnd, count, bytes);
}

CFTypeRef SecTaskCopyValueForEntitlement(SecTaskRef task, CFStringRef entitlement, CFErrorRef *error)
{
  return _SecTaskCopyValueForEntitlement(task, entitlement, error);
}

SecTaskRef SecTaskCreateWithAuditToken(CFAllocatorRef allocator, audit_token_t *token)
{
  return _SecTaskCreateWithAuditToken(allocator, token);
}

CFArrayRef SecTrustCopyProperties(SecTrustRef trust)
{
  return _SecTrustCopyProperties(trust);
}

SecKeyRef SecTrustCopyPublicKey(SecTrustRef trust)
{
  return _SecTrustCopyPublicKey(trust);
}

OSStatus SecTrustCreateWithCertificates(CFTypeRef certificates, CFTypeRef policies, SecTrustRef *trust)
{
  return _SecTrustCreateWithCertificates(certificates, policies, trust);
}

OSStatus SecTrustEvaluate(SecTrustRef trust, SecTrustResultType *result)
{
  return _SecTrustEvaluate(trust, result);
}

void _Block_object_dispose(const void *a1, const int a2)
{
}

uint64_t _CFXPCCreateCFObjectFromXPCObject()
{
  return __CFXPCCreateCFObjectFromXPCObject();
}

int *__error(void)
{
  return ___error();
}

uint64_t __ipsec_set_strerror()
{
  return ___ipsec_set_strerror();
}

int __maskrune(__darwin_ct_rune_t a1, unint64_t a2)
{
  return ___maskrune(a1, a2);
}

uint64_t __memcpy_chk()
{
  return ___memcpy_chk();
}

uint64_t __memset_chk()
{
  return ___memset_chk();
}

uint64_t __strlcat_chk()
{
  return ___strlcat_chk();
}

uint64_t __strlcpy_chk()
{
  return ___strlcpy_chk();
}

void _os_log_debug_impl(void *dso, os_log_t log, os_log_type_t type, const char *format, uint8_t *buf, uint32_t size)
{
}

void _os_log_error_impl(void *dso, os_log_t log, os_log_type_t type, const char *format, uint8_t *buf, uint32_t size)
{
}

void _os_log_fault_impl(void *dso, os_log_t log, os_log_type_t type, const char *format, uint8_t *buf, uint32_t size)
{
}

void _os_log_impl(void *dso, os_log_t log, os_log_type_t type, const char *format, uint8_t *buf, uint32_t size)
{
}

int accept(int a1, sockaddr *a2, socklen_t *a3)
{
  return _accept(a1, a2, a3);
}

int asl_add_log_file(asl_object_t client, int descriptor)
{
  return _asl_add_log_file(client, descriptor);
}

int asl_close_auxiliary_file(int descriptor)
{
  return _asl_close_auxiliary_file(descriptor);
}

int asl_remove_log_file(asl_object_t client, int descriptor)
{
  return _asl_remove_log_file(client, descriptor);
}

int asl_set(asl_object_t obj, const char *key, const char *value)
{
  return _asl_set(obj, key, value);
}

int asl_set_filter(asl_object_t client, int f)
{
  return _asl_set_filter(client, f);
}

int asprintf(char **a1, const char *a2, ...)
{
  return _asprintf(a1, a2);
}

int atexit(void (*a1)(void))
{
  return _atexit(a1);
}

int atoi(const char *a1)
{
  return _atoi(a1);
}

int bind(int a1, const sockaddr *a2, socklen_t a3)
{
  return _bind(a1, a2, a3);
}

void bzero(void *a1, size_t a2)
{
}

int chmod(const char *a1, mode_t a2)
{
  return _chmod(a1, a2);
}

int chown(const char *a1, uid_t a2, gid_t a3)
{
  return _chown(a1, a2, a3);
}

void clearerr(FILE *a1)
{
}

int close(int a1)
{
  return _close(a1);
}

int connect(int a1, const sockaddr *a2, socklen_t a3)
{
  return _connect(a1, a2, a3);
}

char *__cdecl crypt(const char *a1, const char *a2)
{
  return _crypt(a1, a2);
}

int daemon(int a1, int a2)
{
  return _daemon(a1, a2);
}

void dispatch_after(dispatch_time_t when, dispatch_queue_t queue, dispatch_block_t block)
{
}

void dispatch_async(dispatch_queue_t queue, dispatch_block_t block)
{
}

void dispatch_async_f(dispatch_queue_t queue, void *context, dispatch_function_t work)
{
}

void dispatch_main(void)
{
}

void dispatch_once(dispatch_once_t *predicate, dispatch_block_t block)
{
}

dispatch_queue_t dispatch_queue_create(const char *label, dispatch_queue_attr_t attr)
{
  return _dispatch_queue_create(label, attr);
}

void dispatch_release(dispatch_object_t object)
{
}

void dispatch_resume(dispatch_object_t object)
{
}

void dispatch_source_cancel(dispatch_source_t source)
{
}

dispatch_source_t dispatch_source_create(dispatch_source_type_t type, uintptr_t handle, uintptr_t mask, dispatch_queue_t queue)
{
  return _dispatch_source_create(type, handle, mask, queue);
}

void dispatch_source_set_cancel_handler(dispatch_source_t source, dispatch_block_t handler)
{
}

void dispatch_source_set_event_handler(dispatch_source_t source, dispatch_block_t handler)
{
}

void dispatch_source_set_event_handler_f(dispatch_source_t source, dispatch_function_t handler)
{
}

void dispatch_suspend(dispatch_object_t object)
{
}

void dispatch_sync(dispatch_queue_t queue, dispatch_block_t block)
{
}

dispatch_time_t dispatch_time(dispatch_time_t when, int64_t delta)
{
  return _dispatch_time(when, delta);
}

void errx(int a1, const char *a2, ...)
{
}

int execve(const char *__file, char *const *__argv, char *const *__envp)
{
  return _execve(__file, __argv, __envp);
}

void exit(int a1)
{
}

int fchmod(int a1, mode_t a2)
{
  return _fchmod(a1, a2);
}

int fclose(FILE *a1)
{
  return _fclose(a1);
}

int fcntl(int a1, int a2, ...)
{
  return _fcntl(a1, a2);
}

int ferror(FILE *a1)
{
  return _ferror(a1);
}

char *__cdecl fgets(char *a1, int a2, FILE *a3)
{
  return _fgets(a1, a2, a3);
}

int fileno(FILE *a1)
{
  return _fileno(a1);
}

FILE *__cdecl fopen(const char *__filename, const char *__mode)
{
  return _fopen(__filename, __mode);
}

int fprintf(FILE *a1, const char *a2, ...)
{
  return _fprintf(a1, a2);
}

size_t fread(void *__ptr, size_t __size, size_t __nitems, FILE *__stream)
{
  return _fread(__ptr, __size, __nitems, __stream);
}

void free(void *a1)
{
}

void freeaddrinfo(addrinfo *a1)
{
}

void freeifaddrs(ifaddrs *a1)
{
}

size_t fwrite(const void *__ptr, size_t __size, size_t __nitems, FILE *__stream)
{
  return _fwrite(__ptr, __size, __nitems, __stream);
}

const char *__cdecl gai_strerror(int a1)
{
  return _gai_strerror(a1);
}

int getaddrinfo(const char *a1, const char *a2, const addrinfo *a3, addrinfo **a4)
{
  return _getaddrinfo(a1, a2, a3, a4);
}

int getc(FILE *a1)
{
  return _getc(a1);
}

uid_t geteuid(void)
{
  return _geteuid();
}

group *__cdecl getgrnam(const char *a1)
{
  return _getgrnam(a1);
}

int getifaddrs(ifaddrs **a1)
{
  return _getifaddrs(a1);
}

int getnameinfo(const sockaddr *a1, socklen_t a2, char *a3, socklen_t a4, char *a5, socklen_t a6, int a7)
{
  return _getnameinfo(a1, a2, a3, a4, a5, a6, a7);
}

int getopt(int a1, char *const a2[], const char *a3)
{
  return _getopt(a1, a2, a3);
}

pid_t getpid(void)
{
  return _getpid();
}

pid_t getppid(void)
{
  return _getppid();
}

passwd *__cdecl getpwnam(const char *a1)
{
  return _getpwnam(a1);
}

int getsockname(int a1, sockaddr *a2, socklen_t *a3)
{
  return _getsockname(a1, a2, a3);
}

int getsockopt(int a1, int a2, int a3, void *a4, socklen_t *a5)
{
  return _getsockopt(a1, a2, a3, a4, a5);
}

int gettimeofday(timeval *a1, void *a2)
{
  return _gettimeofday(a1, a2);
}

uid_t getuid(void)
{
  return _getuid();
}

int glob(const char *a1, int a2, int (__cdecl *a3)(const char *, int), glob_t *a4)
{
  return _glob(a1, a2, a3, a4);
}

void globfree(glob_t *a1)
{
}

unsigned int if_nametoindex(const char *a1)
{
  return _if_nametoindex(a1);
}

char *__cdecl inet_ntoa(in_addr a1)
{
  return _inet_ntoa(a1);
}

const char *__cdecl inet_ntop(int a1, const void *a2, char *a3, socklen_t a4)
{
  return _inet_ntop(a1, a2, a3, a4);
}

int inet_pton(int a1, const char *a2, void *a3)
{
  return _inet_pton(a1, a2, a3);
}

int ioctl(int a1, unint64_t a2, ...)
{
  return _ioctl(a1, a2);
}

int ipsec_get_policylen(caddr_t a1)
{
  return _ipsec_get_policylen(a1);
}

caddr_t ipsec_set_policy(char *a1, int a2)
{
  return _ipsec_set_policy(a1, a2);
}

const char *ipsec_strerror(void)
{
  return _ipsec_strerror();
}

int isatty(int a1)
{
  return _isatty(a1);
}

int launch_activate_socket(const char *name, int **fds, size_t *cnt)
{
  return _launch_activate_socket(name, fds, cnt);
}

int listen(int a1, int a2)
{
  return _listen(a1, a2);
}

void *__cdecl malloc_type_calloc(size_t count, size_t size, malloc_type_id_t type_id)
{
  return _malloc_type_calloc(count, size, type_id);
}

void *__cdecl malloc_type_malloc(size_t size, malloc_type_id_t type_id)
{
  return _malloc_type_malloc(size, type_id);
}

void *__cdecl malloc_type_realloc(void *ptr, size_t size, malloc_type_id_t type_id)
{
  return _malloc_type_realloc(ptr, size, type_id);
}

int memcmp(const void *__s1, const void *__s2, size_t __n)
{
  return _memcmp(__s1, __s2, __n);
}

void *__cdecl memcpy(void *__dst, const void *__src, size_t __n)
{
  return _memcpy(__dst, __src, __n);
}

void *__cdecl memmove(void *__dst, const void *__src, size_t __len)
{
  return _memmove(__dst, __src, __len);
}

void *__cdecl memset(void *__b, int __c, size_t __len)
{
  return _memset(__b, __c, __len);
}

uint64_t ne_log_obj()
{
  return _ne_log_obj();
}

uint64_t nw_nat64_extract_v4()
{
  return _nw_nat64_extract_v4();
}

uint64_t nw_nat64_synthesize_v6()
{
  return _nw_nat64_synthesize_v6();
}

int open(const char *a1, int a2, ...)
{
  return _open(a1, a2);
}

BOOL os_log_type_enabled(os_log_t oslog, os_log_type_t type)
{
  return _os_log_type_enabled(oslog, type);
}

void os_release(void *object)
{
}

uint64_t os_transaction_create()
{
  return _os_transaction_create();
}

int printf(const char *a1, ...)
{
  return _printf(a1);
}

int proc_pidinfo(int pid, int flavor, uint64_t arg, void *buffer, int buffersize)
{
  return _proc_pidinfo(pid, flavor, arg, buffer, buffersize);
}

int putchar(int a1)
{
  return _putchar(a1);
}

int puts(const char *a1)
{
  return _puts(a1);
}

int rand(void)
{
  return _rand();
}

ssize_t read(int a1, void *a2, size_t a3)
{
  return _read(a1, a2, a3);
}

ssize_t recv(int a1, void *a2, size_t a3, int a4)
{
  return _recv(a1, a2, a3, a4);
}

ssize_t recvfrom(int a1, void *a2, size_t a3, int a4, sockaddr *a5, socklen_t *a6)
{
  return _recvfrom(a1, a2, a3, a4, a5, a6);
}

ssize_t recvmsg(int a1, msghdr *a2, int a3)
{
  return _recvmsg(a1, a2, a3);
}

ssize_t send(int a1, const void *a2, size_t a3, int a4)
{
  return _send(a1, a2, a3, a4);
}

ssize_t sendmsg(int a1, const msghdr *a2, int a3)
{
  return _sendmsg(a1, a2, a3);
}

ssize_t sendto(int a1, const void *a2, size_t a3, int a4, const sockaddr *a5, socklen_t a6)
{
  return _sendto(a1, a2, a3, a4, a5, a6);
}

int setgid(gid_t a1)
{
  return _setgid(a1);
}

int setsockopt(int a1, int a2, int a3, const void *a4, socklen_t a5)
{
  return _setsockopt(a1, a2, a3, a4, a5);
}

int setuid(uid_t a1)
{
  return _setuid(a1);
}

int sigaction(int a1, const sigaction *a2, sigaction *a3)
{
  return _sigaction(a1, a2, a3);
}

int snprintf(char *__str, size_t __size, const char *__format, ...)
{
  return _snprintf(__str, __size, __format);
}

int socket(int a1, int a2, int a3)
{
  return _socket(a1, a2, a3);
}

void srand(unsigned int a1)
{
}

int stat(const char *a1, stat *a2)
{
  return _stat(a1, a2);
}

int strcmp(const char *__s1, const char *__s2)
{
  return _strcmp(__s1, __s2);
}

char *__cdecl strdup(const char *__s1)
{
  return _strdup(__s1);
}

char *__cdecl strerror(int __errnum)
{
  return _strerror(__errnum);
}

size_t strlen(const char *__s)
{
  return _strlen(__s);
}

int strncmp(const char *__s1, const char *__s2, size_t __n)
{
  return _strncmp(__s1, __s2, __n);
}

char *__cdecl strncpy(char *__dst, const char *__src, size_t __n)
{
  return _strncpy(__dst, __src, __n);
}

char *__cdecl strnstr(const char *__big, const char *__little, size_t __len)
{
  return _strnstr(__big, __little, __len);
}

char *__cdecl strrchr(char *__s, int __c)
{
  return _strrchr(__s, __c);
}

uint64_t strtol(const char *__str, char **__endptr, int __base)
{
  return _strtol(__str, __endptr, __base);
}

int sysctlbyname(const char *a1, void *a2, size_t *a3, void *a4, size_t a5)
{
  return _sysctlbyname(a1, a2, a3, a4, a5);
}

void syslog(int a1, const char *a2, ...)
{
}

time_t time(time_t *a1)
{
  return _time(a1);
}

int timingsafe_bcmp(const void *__b1, const void *__b2, size_t __len)
{
  return _timingsafe_bcmp(__b1, __b2, __len);
}

mode_t umask(mode_t a1)
{
  return _umask(a1);
}

int unlink(const char *a1)
{
  return _unlink(a1);
}

int vasprintf(char **a1, const char *a2, va_list a3)
{
  return _vasprintf(a1, a2, a3);
}

uint64_t vproc_swap_integer()
{
  return _vproc_swap_integer();
}

int vsnprintf(char *__str, size_t __size, const char *__format, va_list a4)
{
  return _vsnprintf(__str, __size, __format, a4);
}

xpc_connection_t xpc_connection_create_mach_service(const char *name, dispatch_queue_t targetq, uint64_t flags)
{
  return _xpc_connection_create_mach_service(name, targetq, flags);
}

void xpc_connection_resume(xpc_connection_t connection)
{
}

void xpc_connection_send_message(xpc_connection_t connection, xpc_object_t message)
{
}

void xpc_connection_set_event_handler(xpc_connection_t connection, xpc_handler_t handler)
{
}

void xpc_connection_set_target_queue(xpc_connection_t connection, dispatch_queue_t targetq)
{
}

xpc_object_t xpc_dictionary_create_reply(xpc_object_t original)
{
  return _xpc_dictionary_create_reply(original);
}

uint64_t xpc_dictionary_get_audit_token()
{
  return _xpc_dictionary_get_audit_token();
}

int64_t xpc_dictionary_get_int64(xpc_object_t xdict, const char *key)
{
  return _xpc_dictionary_get_int64(xdict, key);
}

xpc_connection_t xpc_dictionary_get_remote_connection(xpc_object_t xdict)
{
  return _xpc_dictionary_get_remote_connection(xdict);
}

const char *__cdecl xpc_dictionary_get_string(xpc_object_t xdict, const char *key)
{
  return _xpc_dictionary_get_string(xdict, key);
}

xpc_object_t xpc_dictionary_get_value(xpc_object_t xdict, const char *key)
{
  return _xpc_dictionary_get_value(xdict, key);
}

void xpc_dictionary_set_BOOL(xpc_object_t xdict, const char *key, BOOL value)
{
}

void xpc_dictionary_set_int64(xpc_object_t xdict, const char *key, int64_t value)
{
}

xpc_type_t xpc_get_type(xpc_object_t object)
{
  return _xpc_get_type(object);
}

void xpc_release(xpc_object_t object)
{
}

xpc_object_t xpc_retain(xpc_object_t object)
{
  return _xpc_retain(object);
}