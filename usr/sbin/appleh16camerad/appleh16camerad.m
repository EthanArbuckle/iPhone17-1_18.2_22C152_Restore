void sub_100001F84(_OWORD *a1, int a2, int a3)
{
  uint64_t v5;
  int v6;
  int v7;

  sub_10003B060(a1);
  *(unsigned char *)(v5 + 48) = a3;
  if (a3) {
    v6 = 4;
  }
  else {
    v6 = 3;
  }
  v7 = v6 + 3 * a2;
  *(_DWORD *)(v5 + 40) = 4 * a2;
  *(_DWORD *)(v5 + 44) = 1;
  *(_DWORD *)(v5 + 32) = v7 + (2 * v6 + 10) * a2;
  *(_DWORD *)(v5 + 36) = v7;
  sub_10003AF9C();
}

void sub_1000020D4(_Unwind_Exception *a1)
{
  sub_10003B108(v1);
  _Unwind_Resume(a1);
}

void sub_1000020E8(uint64_t a1@<X0>, void *a2@<X8>)
{
  uint64_t v4 = 0;
  uint64_t v5 = *(unsigned __int8 *)(a1 + 48) + 3;
  do
  {
    v6 = &v11[v4];
    *((void *)v6 + 2) = 1;
    v6[24] = 0;
    *(void *)v6 = &off_100095AB0;
    *((void *)v6 + 1) = 0;
    v4 += 32;
  }
  while (v4 != 128);
  uint64_t v7 = 0;
  v8 = v11;
  do
  {
    sub_10003B3FC((uint64_t *)a1, v7, (uint64_t)v10);
    sub_10000316C((uint64_t)v8, (uint64_t)v10);
    sub_100003224((uint64_t)v10);
    ++v7;
    v8 += 32;
  }
  while (v5 != v7);
  int v9 = sub_10003B1DC(a1);
  sub_1000032CC((uint64_t)a2, 1, v9);
  *a2 = &off_100095AB0;
  sub_10003B1DC(a1);
  operator new[]();
}

void sub_100003028(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,char a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,char a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,char a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,char a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  sub_10003B704(&a35);
  sub_10003B704(&a42);
  sub_10003B704(&a49);
  sub_10003B704(&a56);
  for (uint64_t i = 96; i != -32; i -= 32)
    sub_100003224((uint64_t)&STACK[0x240] + i);
  sub_10003B108(&a63);
  sub_100003224(v63);
  for (uint64_t j = 96; j != -32; j -= 32)
    sub_100003224((uint64_t)&STACK[0x2C0] + j);
  _Unwind_Resume(a1);
}

double sub_10000316C(uint64_t a1, uint64_t a2)
{
  if (*(unsigned char *)(a1 + 24) && *(void *)(a1 + 8)) {
    operator delete[]();
  }
  double result = *(double *)(a2 + 16);
  *(double *)(a1 + 16) = result;
  *(void *)(a1 + 8) = *(void *)(a2 + 8);
  *(unsigned char *)(a1 + 24) = *(unsigned char *)(a2 + 24);
  *(unsigned char *)(a2 + 24) = 0;
  return result;
}

double sub_1000031D0(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(unsigned int *)(a1 + 20);
  if (v2 != *(_DWORD *)(a2 + 20)) {
    sub_1000737C0();
  }
  if (!v2) {
    return 0.0;
  }
  v3 = *(double **)(a1 + 8);
  uint64_t v4 = *(double **)(a2 + 8);
  double result = 0.0;
  do
  {
    double v6 = *v3++;
    double v7 = v6;
    double v8 = *v4++;
    double result = result + v7 * v8;
    --v2;
  }
  while (v2);
  return result;
}

uint64_t sub_100003224(uint64_t result)
{
  *(void *)double result = off_100095A80;
  if (*(void *)(result + 8) && *(unsigned char *)(result + 24)) {
    operator delete[]();
  }
  *(void *)(result + 16) = 0;
  return result;
}

void sub_100003294(uint64_t a1)
{
  sub_100003224(a1);

  operator delete();
}

uint64_t sub_1000032CC(uint64_t result, int a2, int a3)
{
  *(void *)double result = off_100095A80;
  if (a3 * a2) {
    operator new[]();
  }
  *(void *)(result + 8) = 0;
  *(_DWORD *)(result + 16) = a2;
  *(_DWORD *)(result + 20) = a3;
  *(unsigned char *)(result + 24) = 0;
  return result;
}

void sub_100003358(uint64_t a1)
{
  sub_100003224(a1);

  operator delete();
}

__n128 sub_100003390(uint64_t a1, int a2, int a3, uint64_t a4, int a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, int a10, char a11)
{
  *(void *)a1 = 0;
  *(_DWORD *)(a1 + 8) = 0;
  *(unsigned char *)(a1 + 12) = 0;
  if (a2 <= 2130)
  {
    if (a2 <= 1555)
    {
      if (a2 <= 1367)
      {
        if (a2 == 1029)
        {
          if ((a5 & 0xFFFFFFFE) == 0x1E)
          {
            *(void *)a1 = &unk_100244000;
            *(_DWORD *)(a1 + 8) = 38436;
            v11 = "/usr/local/share/firmware/isp/9724_01XX.dat";
          }
          else
          {
            *(void *)a1 = &unk_10024E000;
            *(_DWORD *)(a1 + 8) = 37576;
            v11 = "/usr/local/share/firmware/isp/9723_01XX.dat";
          }
        }
        else
        {
          if (a2 != 1300) {
            return result;
          }
          *(void *)a1 = &unk_1000B4000;
          *(_DWORD *)(a1 + 8) = 41368;
          v11 = "/usr/local/share/firmware/isp/2820_01XX.dat";
        }
      }
      else
      {
        switch(a2)
        {
          case 1368:
            if (a5 == 16 || a5 == 9)
            {
              *(void *)a1 = &unk_10025F000;
              *(_DWORD *)(a1 + 8) = 44352;
              v11 = "/usr/local/share/firmware/isp/1922_02XX.dat";
            }
            else
            {
              *(void *)a1 = &unk_10026A000;
              *(_DWORD *)(a1 + 8) = 44352;
              v11 = "/usr/local/share/firmware/isp/1921_01XX.dat";
            }
            break;
          case 1394:
            *(void *)a1 = &unk_1000BF000;
            *(_DWORD *)(a1 + 8) = 24392;
            v11 = "/usr/local/share/firmware/isp/1020_03XX.dat";
            break;
          case 1395:
            *(void *)a1 = &unk_1000C5000;
            *(_DWORD *)(a1 + 8) = 14260;
            v11 = "/usr/local/share/firmware/isp/0019_02XX.dat";
            break;
          default:
            return result;
        }
      }
      goto LABEL_70;
    }
    if (a2 <= 1811)
    {
      switch(a2)
      {
        case 1556:
          if ((a5 & 0xFFFFFFFE) == 0x1E)
          {
            *(void *)a1 = &unk_100275000;
            *(_DWORD *)(a1 + 8) = 60780;
            v11 = "/usr/local/share/firmware/isp/2924_01XX.dat";
          }
          else
          {
            *(void *)a1 = &unk_100284000;
            *(_DWORD *)(a1 + 8) = 60780;
            v11 = "/usr/local/share/firmware/isp/2921_02XX.dat";
          }
          break;
        case 1587:
          if ((a5 - 69) > 1)
          {
            if ((a5 - 71) > 1)
            {
              *(void *)a1 = &unk_100191000;
              *(_DWORD *)(a1 + 8) = 65748;
              v11 = "/usr/local/share/firmware/isp/3623_01XX.dat";
            }
            else
            {
              *(void *)a1 = &unk_100180000;
              *(_DWORD *)(a1 + 8) = 65748;
              v11 = "/usr/local/share/firmware/isp/3624_01XX.dat";
            }
          }
          else
          {
            *(void *)a1 = &unk_10016F000;
            *(_DWORD *)(a1 + 8) = 65748;
            v11 = "/usr/local/share/firmware/isp/3624_02XX.dat";
          }
          break;
        case 1811:
          *(void *)a1 = &unk_1001F0000;
          *(_DWORD *)(a1 + 8) = 37400;
          v11 = "/usr/local/share/firmware/isp/4723_01XX.dat";
          break;
        default:
          return result;
      }
      goto LABEL_70;
    }
    if (a2 == 1812)
    {
      *(void *)a1 = &unk_100164000;
      *(_DWORD *)(a1 + 8) = 41368;
      v11 = "/usr/local/share/firmware/isp/2022_01XX.dat";
      goto LABEL_70;
    }
    if (a2 != 2051)
    {
      if (a2 != 2068) {
        return result;
      }
      *(void *)a1 = &unk_100144000;
      *(_DWORD *)(a1 + 8) = 127884;
      v11 = "/usr/local/share/firmware/isp/2123_01XX.dat";
      goto LABEL_70;
    }
    goto LABEL_40;
  }
  if (a2 <= 2391)
  {
    if (a2 > 2322)
    {
      switch(a2)
      {
        case 2323:
          if (a5 != 67 || a11)
          {
            if ((a5 - 69) > 1)
            {
              *(void *)a1 = &unk_1001CE000;
              *(_DWORD *)(a1 + 8) = 138436;
              v11 = "/usr/local/share/firmware/isp/4523_02XX.dat";
            }
            else
            {
              *(void *)a1 = &unk_1001AC000;
              *(_DWORD *)(a1 + 8) = 138436;
              v11 = "/usr/local/share/firmware/isp/4524_01XX.dat";
            }
          }
          else
          {
            *(void *)a1 = &unk_1001A2000;
            *(_DWORD *)(a1 + 8) = 37420;
            v11 = "/usr/local/share/firmware/isp/4523_01XX.dat";
          }
          break;
        case 2324:
          *(void *)a1 = &unk_1000A5000;
          *(_DWORD *)(a1 + 8) = 58560;
          v11 = "/usr/local/share/firmware/isp/2325_01XX.dat";
          break;
        case 2339:
          *(void *)a1 = &unk_10013B000;
          *(_DWORD *)(a1 + 8) = 36168;
          v11 = "/usr/local/share/firmware/isp/8824_01XX.dat";
          break;
        default:
          return result;
      }
      goto LABEL_70;
    }
    if (a2 != 2131)
    {
      if (a2 == 2307)
      {
        *(void *)a1 = &unk_100115000;
        *(_DWORD *)(a1 + 8) = 152192;
        v11 = "/usr/local/share/firmware/isp/7424_01XX.dat";
      }
      else
      {
        if (a2 != 2308) {
          return result;
        }
        *(void *)a1 = &unk_10021F000;
        *(_DWORD *)(a1 + 8) = 149496;
        v11 = "/usr/local/share/firmware/isp/7524_01XX.dat";
      }
      goto LABEL_70;
    }
LABEL_40:
    *(void *)a1 = &unk_1001FA000;
    *(_DWORD *)(a1 + 8) = 149496;
    v11 = "/usr/local/share/firmware/isp/7623_01XX.dat";
LABEL_70:
    long long v12 = *((_OWORD *)v11 + 1);
    *(_OWORD *)(a1 + 12) = *(_OWORD *)v11;
    *(_OWORD *)(a1 + 28) = v12;
    __n128 result = *(__n128 *)(v11 + 28);
    *(__n128 *)(a1 + 40) = result;
    return result;
  }
  if (a2 <= 2433)
  {
    switch(a2)
    {
      case 2392:
        *(void *)a1 = &unk_100258000;
        *(_DWORD *)(a1 + 8) = 28660;
        v11 = "/usr/local/share/firmware/isp/2224_01XX.dat";
        break;
      case 2418:
        *(void *)a1 = &unk_1000EA000;
        *(_DWORD *)(a1 + 8) = 172804;
        v11 = "/usr/local/share/firmware/isp/3524_01XX.dat";
        break;
      case 2419:
        *(void *)a1 = &unk_1000C9000;
        *(_DWORD *)(a1 + 8) = 132136;
        v11 = "/usr/local/share/firmware/isp/4425_01XX.dat";
        break;
      default:
        return result;
    }
    goto LABEL_70;
  }
  if (a2 == 2434)
  {
    *(void *)a1 = &unk_100293000;
    *(_DWORD *)(a1 + 8) = 149364;
    v11 = "/usr/local/share/firmware/isp/7324_01XX.dat";
    goto LABEL_70;
  }
  if (a2 == 3414 || a2 == 20584)
  {
    if (a3 == 2)
    {
      *(void *)a1 = &unk_1002BA000;
      *(_DWORD *)(a1 + 8) = 7040;
      v11 = "/usr/local/share/firmware/isp/6222_01XX.dat";
    }
    else
    {
      *(void *)a1 = &unk_1002B8000;
      *(_DWORD *)(a1 + 8) = 7040;
      v11 = "/usr/local/share/firmware/isp/6221_01XX.dat";
    }
    goto LABEL_70;
  }
  return result;
}

double sub_1000038CC(uint64_t a1, int a2, int a3, uint64_t a4, int a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, int a10, char a11)
{
  *(void *)&double result = sub_100003390(a1, a2, a3, a4, a5, a6, a7, a8, a9, 0, a11).n128_u64[0];
  return result;
}

uint64_t sub_1000038DC(int a1)
{
  uint64_t v2 = +[NSFileManager defaultManager];
  v3 = +[NSString stringWithUTF8String:off_100095AD8[a1]];
  if ([(NSFileManager *)v2 fileExistsAtPath:v3]
    && (id v5 = 0, ![(NSFileManager *)v2 removeItemAtPath:v3 error:&v5]))
  {
    NSLog(@"Failed to remove %s token: %@", off_100095AE8[a1], [v5 description]);
    return 0;
  }
  else
  {
    sub_1000039A0("token was removed");
    return 1;
  }
}

void sub_1000039A0(char *a1, ...)
{
  va_start(va, a1);
  int v9 = 0;
  uint64_t v1 = vasprintf(&v9, a1, va);
  if (v9)
  {
    id v2 = objc_alloc_init((Class)NSDateFormatter);
    [v2 setDateFormat:@"yyyy-MM-dd HH:mm:ss"];
    id v3 = [v2 stringFromDate:[NSDate date]];
    uint64_t v4 = +[NSString stringWithFormat:@"%@ %s\n", v3, v9, va];

    free(v9);
    int v9 = 0;
    id v5 = fopen("/var/mobile/Documents/Tokens.log", "a");
    if (v5)
    {
      double v6 = v5;
      fwrite([(NSString *)v4 UTF8String], [(NSString *)v4 length], 1uLL, v5);
      fclose(v6);
    }
    else
    {
      NSLog(@"Failed to open token log file.", v7, v8);
    }
  }
  else
  {
    NSLog(@"Failed to create log message string with code: %d (0x%X)", v1, v1);
  }
}

BOOL sub_100003AC0(char *a1)
{
  CFNumberRef v2 = (const __CFNumber *)MGCopyAnswer();
  CFNumberRef v3 = v2;
  if (v2)
  {
    uint64_t valuePtr = 0;
    CFNumberGetValue(v2, kCFNumberSInt64Type, &valuePtr);
    snprintf(a1, 0x20uLL, "%lld", valuePtr);
    CFRelease(v3);
  }
  else
  {
    NSLog(@"Failed to read unique chip identifier");
  }
  return v3 != 0;
}

uint64_t sub_100003B50(int a1, int a2, time_t *a3)
{
  double v6 = +[NSFileManager defaultManager];
  uint64_t v7 = off_100095AD8[a2];
  if (![(NSFileManager *)v6 fileExistsAtPath:+[NSString stringWithUTF8String:v7]])
  {
    sub_1000039A0("Can't activate %s projector: no projector token found");
    return 0;
  }
  nullsub_10(__s2);
  if ((sub_100004024((uint64_t)__s2, v7) & 1) == 0)
  {
    sub_1000039A0("Failed to read %s projector token file. Token will be removed.");
    goto LABEL_23;
  }
  time_t v8 = time(0);
  time_t v9 = v18;
  if (v8 > v18)
  {
    sub_1000039A0("%s token timeout was reached (current time %ld). Token will be removed.");
LABEL_23:
    sub_1000038DC(a2);
    return 0;
  }
  if (v8 > v17 + 43200)
  {
    sub_1000039A0("%s token has exceeded max allowed timeout. Token will be removed.");
    goto LABEL_23;
  }
  if (!sub_100003AC0(__s1))
  {
    sub_1000039A0("Failed to read unique chip ID");
    return 0;
  }
  if (strcmp(__s1, (const char *)__s2))
  {
    sub_1000039A0("%s token does not match device. Token will be removed.");
    goto LABEL_23;
  }
  unint64_t v10 = 0;
  while (v10 >= __s2[16] || __s2[v10 + 17] != a1 || a1 == 0)
  {
    if (++v10 == 8)
    {
      sub_1000039A0("%s token doesn't match platform. Token will be removed.");
      goto LABEL_23;
    }
  }
  if (v20)
  {
    uint64_t v13 = sub_100003E40();
    if (v13 == -1 || v13 > v17)
    {
      sub_1000039A0("System performed boot since %s token creation (boot time: %ld). Token will be removed.");
      goto LABEL_23;
    }
  }
  if (!v19)
  {
    sub_1000039A0("Number of allowed activations has reached zero. %s token will be removed.");
    goto LABEL_23;
  }
  int v14 = v19 - 1;
  if (v19 >= 1)
  {
    --v19;
    if (v14)
    {
      if (!sub_100003EF8((uint64_t)__s2, v7))
      {
        sub_1000039A0("Failed to update %s token file. Will return false so someone looks at that...");
        return 0;
      }
      sub_1000039A0("%s token activation count updated to %d", off_100095AE8[a2], v19);
    }
    else
    {
      sub_1000039A0("Using last allowed activation. %s token will be removed.", off_100095AE8[a2]);
      sub_1000038DC(a2);
    }
  }
  if (a3) {
    *a3 = v9;
  }
  return 1;
}

uint64_t sub_100003E40()
{
  *(void *)uint64_t v4 = 0x1500000001;
  size_t v2 = 16;
  if (sysctl(v4, 2u, &v3, &v2, 0, 0) || (uint64_t result = v3) == 0)
  {
    uint64_t v1 = __error();
    NSLog(@"Failed to read boot time. errno %d", *v1);
    return -1;
  }
  return result;
}

void sub_100003EE0(void *a1)
{
}

BOOL sub_100003EF8(uint64_t a1, const char *a2)
{
  int __ptr = 3;
  strncpy(v10, (const char *)(a1 + 32), 0x20uLL);
  strncpy(v11, (const char *)a1, 0x20uLL);
  bzero(v12, 0x20uLL);
  long long v4 = *(_OWORD *)(a1 + 84);
  v12[0] = *(_OWORD *)(a1 + 68);
  v12[1] = v4;
  v12[2] = *(_OWORD *)(a1 + 104);
  int v5 = *(unsigned __int8 *)(a1 + 124);
  int v13 = *(_DWORD *)(a1 + 120);
  int v14 = v5;
  uint64_t v6 = qword_1002BBB80;
  if ((unint64_t)qword_1002BBB80 <= 0x7B)
  {
    do
    {
      v10[v6 - 4] ^= byte_10008021D[v6 & 7];
      ++v6;
    }
    while (v6 != 124);
  }
  uint64_t v7 = fopen(a2, "w");
  if (v7)
  {
    fwrite(&__ptr, 1uLL, 0x7CuLL, v7);
    fclose(v7);
  }
  return v7 != 0;
}

uint64_t sub_100004024(uint64_t a1, char *__filename)
{
  uint64_t result = (uint64_t)fopen(__filename, "r");
  if (result)
  {
    long long v4 = (FILE *)result;
    BOOL v5 = fread(&__ptr, 1uLL, 0x24uLL, (FILE *)result) == 36 && __ptr == 3;
    if (v5 && fread(&v11[qword_1002BBB80 - 4], 1uLL, 0x58uLL, v4) == 88)
    {
      uint64_t v6 = qword_1002BBB80;
      if ((unint64_t)qword_1002BBB80 <= 0x7B)
      {
        do
        {
          v11[v6 - 4] ^= byte_10008021D[v6 & 7];
          ++v6;
        }
        while (v6 != 124);
      }
      strncpy((char *)a1, v12, 0x20uLL);
      *(_OWORD *)(a1 + 104) = v13;
      int v7 = v15;
      *(_DWORD *)(a1 + 120) = v14;
      *(unsigned char *)(a1 + 124) = v7 != 0;
      strncpy((char *)(a1 + 32), v11, 0x20uLL);
      *(unsigned char *)(a1 + 63) = 0;
      bzero((void *)(a1 + 68), 0x20uLL);
      uint64_t v8 = 0;
      *(_DWORD *)(a1 + 64) = 8;
      while (1)
      {
        int v9 = *(_DWORD *)&v12[4 * v8 + 32];
        *(_DWORD *)(a1 + 68 + 4 * v8) = v9;
        if (!v9) {
          break;
        }
        if (++v8 == 8) {
          return 1;
        }
      }
      *(_DWORD *)(a1 + 64) = v8;
      return 1;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t sub_1000041B0(uint64_t a1)
{
  *(void *)a1 = 0xFFFFFFFF00000000;
  *(_DWORD *)(a1 + 8) = -1;
  *(void *)(a1 + 40) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = 0;
  *(void *)(a1 + 80) = 0x4FFFF00000001;
  *(void *)(a1 + 96) = 0;
  *(void *)(a1 + 104) = 0;
  *(void *)(a1 + 112) = 0;
  *(_DWORD *)(a1 + 120) = -1;
  sub_10000425C(a1, 0);
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  id v2 = objc_alloc_init((Class)NSMutableDictionary);
  *(void *)(a1 + 88) = v2;
  [v2 setValue:&off_1000A0B38 forKey:@"Version"];
  return a1;
}

void sub_10000423C(_Unwind_Exception *exception_object)
{
  uint64_t v3 = v2;
  BOOL v5 = *v3;
  if (*v3)
  {
    *(void *)(v1 + 104) = v5;
    operator delete(v5);
  }
  _Unwind_Resume(exception_object);
}

void sub_10000425C(uint64_t a1, void *a2)
{
  long long v4 = (__CFString *)[a2 lastPathComponent];
  BOOL v5 = (__CFString *)[a2 stringByDeletingLastPathComponent];
  uint64_t v6 = *(void **)(a1 + 16);
  if (v6)
  {

    *(void *)(a1 + 16) = 0;
  }
  int v7 = *(void **)(a1 + 24);
  if (v7)
  {

    *(void *)(a1 + 24) = 0;
  }
  *(unsigned char *)(a1 + 32) = 1;
  if (!v4 || (id v8 = [(__CFString *)v4 length], !a2) || !v8) {
    long long v4 = @"JasperFrameModes.plist";
  }
  *(void *)(a1 + 16) = [(__CFString *)v4 copy];
  if (!v5 || (id v9 = [(__CFString *)v5 length], !a2) || !v9) {
    BOOL v5 = @"/var/mobile/Documents/JasperL";
  }
  id v10 = [(__CFString *)v5 copy];
  *(void *)(a1 + 24) = v10;
  id v11 = [v10 stringByAppendingPathComponent:*(void *)(a1 + 16)];
  unsigned __int8 v12 = [+[NSFileManager defaultManager] fileExistsAtPath:v11];
  if (a2)
  {
    NSLog(@"Jasper Frame Config: using file %@ as config plist", v11);
  }
  else if ((v12 & 1) == 0)
  {
    *(unsigned char *)(a1 + 32) = 0;
  }
}

uint64_t sub_100004360(uint64_t a1)
{
  id v2 = *(void **)(a1 + 16);
  if (v2) {

  }
  uint64_t v3 = *(void **)(a1 + 24);
  if (v3) {

  }
  long long v4 = *(void **)(a1 + 40);
  if (v4)
  {
    free(v4);
    *(void *)(a1 + 40) = 0;
  }

  BOOL v5 = *(void **)(a1 + 96);
  if (v5)
  {
    *(void *)(a1 + 104) = v5;
    operator delete(v5);
  }
  return a1;
}

uint64_t sub_1000043CC()
{
  return qword_1002BBDC0;
}

uint64_t sub_1000043D8(uint64_t a1, uint64_t a2, void *__src)
{
  __int16 v8 = 14092;
  int v9 = a2;
  memcpy(v10, __src, sizeof(v10));
  NSLog(@"%s: [ch:%d] Sending Peridot online config command", "onlineUpdate", a2);
  uint64_t v5 = sub_10004C658(a1, (uint64_t)v7, 0x3D0u, 0, 0xFFFFFFFF);
  if (!v5) {
    return v11;
  }
  NSLog(@"%s: Sending Peridot online config failed: 0x%08X", "onlineUpdate", v5);
  return 0;
}

uint64_t sub_1000044A8()
{
  sub_1000041B0((uint64_t)&unk_1002BBD68);

  return __cxa_atexit((void (*)(void *))sub_1000043C8, &unk_1002BBD68, (void *)&_mh_execute_header);
}

uint64_t sub_100004500(uint64_t result, int a2, int a3)
{
  if (*(_DWORD *)(result + 16) != a2 || *(_DWORD *)(result + 20) != a3)
  {
    if (*(void *)(result + 8))
    {
      if (*(unsigned char *)(result + 24)) {
        operator delete[]();
      }
    }
    *(_DWORD *)(result + 16) = a2;
    *(_DWORD *)(result + 20) = a3;
    operator new[]();
  }
  return result;
}

uint64_t sub_1000045A0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a1 == a3) {
    sub_1000737EC();
  }
  sub_100004758(a3, *(_DWORD *)(a1 + 16), *(_DWORD *)(a1 + 20));
  uint64_t v6 = *(void *)(a1 + 8);
  unsigned int v7 = *(_DWORD *)(a1 + 16);
  unsigned int v8 = *(_DWORD *)(a1 + 20);
  uint64_t v9 = *(void *)(a2 + 8);
  id v10 = *(float **)(a3 + 8);
  unsigned int v11 = *(_DWORD *)(a2 + 16);
  unsigned int v12 = *(_DWORD *)(a2 + 20);

  return sub_1000047F4(v6, v7, v8, v9, v10, v11, v12);
}

void sub_100004610(uint64_t a1)
{
  sub_100004648(a1);

  operator delete();
}

uint64_t sub_100004648(uint64_t result)
{
  *(void *)uint64_t result = off_100095B08;
  if (*(void *)(result + 8) && *(unsigned char *)(result + 24)) {
    operator delete[]();
  }
  *(void *)(result + 16) = 0;
  return result;
}

void sub_1000046B4(uint64_t a1)
{
  sub_1000046EC(a1);

  operator delete();
}

uint64_t sub_1000046EC(uint64_t result)
{
  *(void *)uint64_t result = off_100095B38;
  if (*(void *)(result + 8) && *(unsigned char *)(result + 24)) {
    operator delete[]();
  }
  *(void *)(result + 16) = 0;
  return result;
}

uint64_t sub_100004758(uint64_t result, int a2, int a3)
{
  if (*(_DWORD *)(result + 16) != a2 || *(_DWORD *)(result + 20) != a3)
  {
    if (*(void *)(result + 8))
    {
      if (*(unsigned char *)(result + 24)) {
        operator delete[]();
      }
    }
    *(_DWORD *)(result + 16) = a2;
    *(_DWORD *)(result + 20) = a3;
    operator new[]();
  }
  return result;
}

uint64_t sub_1000047F4(uint64_t result, unsigned int a2, unsigned int a3, uint64_t a4, float *a5, unsigned int a6, unsigned int a7)
{
  if ((a7 & 1) == 0) {
    sub_100073818();
  }
  if ((a6 & 1) == 0) {
    sub_100073844();
  }
  unsigned int v7 = a7 - 1;
  unsigned int v8 = (a7 - 1) >> 1;
  unsigned int v9 = (a6 - 1) >> 1;
  if (a6 - 1 >= 2)
  {
    int v10 = 0;
    unsigned int v11 = a3 - v8;
    uint64_t v12 = v8 + a3;
    if (v8 <= 1) {
      unsigned int v13 = 1;
    }
    else {
      unsigned int v13 = (a7 - 1) >> 1;
    }
    if (v9 <= 1) {
      unsigned int v14 = 1;
    }
    else {
      unsigned int v14 = (a6 - 1) >> 1;
    }
    unsigned int v110 = v14;
    int v15 = a7 * v9;
    unsigned int v16 = v8 + a7 * v9;
    unsigned int v17 = (a6 - 1) >> 1;
    do
    {
      if (v7 >= 2)
      {
        int v18 = 0;
        unsigned int v19 = v9 - v10;
        unsigned int v20 = v16;
        unsigned int v21 = v7 >> 1;
        do
        {
          *a5 = 0.0;
          if (v19 < a6)
          {
            unsigned int v22 = 0;
            float v23 = 0.0;
            unsigned int v24 = v20;
            unsigned int v25 = v19;
            do
            {
              if (v8 - v18 < a7)
              {
                unsigned int v26 = v24;
                unsigned int v27 = v22;
                unint64_t v28 = v21;
                do
                {
                  float v23 = v23 + (float)(*(float *)(a4 + 4 * v26) * *(float *)(result + 4 * v27));
                  *a5 = v23;
                  ++v28;
                  ++v27;
                  ++v26;
                }
                while (v28 < a7);
              }
              ++v25;
              v22 += a3;
              v24 += a7;
            }
            while (v25 < a6);
          }
          ++v18;
          ++a5;
          --v21;
          --v20;
        }
        while (v18 != v13);
      }
      if (v8 >= v11)
      {
        unsigned int v9 = (a6 - 1) >> 1;
      }
      else
      {
        unsigned int v29 = 0;
        unsigned int v9 = (a6 - 1) >> 1;
        unsigned int v30 = v7 >> 1;
        do
        {
          *a5 = 0.0;
          if (v17 - v10 < a6)
          {
            float v31 = 0.0;
            int v32 = v15;
            unsigned int v33 = v29;
            unsigned int v34 = v17 - v10;
            do
            {
              uint64_t v35 = a7;
              unsigned int v36 = v32;
              unsigned int v37 = v33;
              do
              {
                float v31 = v31 + (float)(*(float *)(a4 + 4 * v36) * *(float *)(result + 4 * v37));
                *a5 = v31;
                ++v37;
                ++v36;
                --v35;
              }
              while (v35);
              ++v34;
              v33 += a3;
              v32 += a7;
            }
            while (v34 < a6);
          }
          ++v30;
          ++a5;
          ++v29;
        }
        while (v30 != v11);
      }
      if (v11 < a3)
      {
        int v38 = a3 - 2 * v8;
        uint64_t v39 = a3 - v8;
        do
        {
          *a5 = 0.0;
          if (v9 - v10 < a6)
          {
            float v40 = 0.0;
            int v41 = v15;
            int v42 = v38;
            unsigned int v43 = v9 - v10;
            do
            {
              if (v39 != v12)
              {
                unint64_t v44 = 0;
                do
                {
                  float v40 = v40
                      + (float)(*(float *)(a4 + 4 * (v41 + v44))
                              * *(float *)(result + 4 * (v42 + v44)));
                  *a5 = v40;
                  ++v44;
                }
                while (v44 < (v12 - v39));
              }
              ++v43;
              v42 += a3;
              v41 += a7;
            }
            while (v43 < a6);
          }
          ++v39;
          ++a5;
          ++v38;
        }
        while (v39 != a3);
      }
      ++v10;
      v16 -= a7;
      v15 -= a7;
    }
    while (v10 != v110);
  }
  unsigned int v45 = a2 - v9;
  if (v9 < a2 - v9)
  {
    unsigned int v46 = 0;
    unsigned int v47 = a3 - v8;
    uint64_t v48 = v8 + a3;
    if (v8 <= 1) {
      unsigned int v49 = 1;
    }
    else {
      unsigned int v49 = (a7 - 1) >> 1;
    }
    unsigned int v50 = v9;
    int v51 = a3 - 2 * v8;
    do
    {
      if (v7 >= 2)
      {
        int v52 = 0;
        unsigned int v53 = v7 >> 1;
        do
        {
          *a5 = 0.0;
          if (a6)
          {
            int v54 = 0;
            float v55 = 0.0;
            unsigned int v56 = v53;
            unsigned int v57 = v46;
            do
            {
              if (v8 - v52 < a7)
              {
                unsigned int v58 = v56;
                unsigned int v59 = v57;
                unint64_t v60 = v53;
                do
                {
                  float v55 = v55 + (float)(*(float *)(a4 + 4 * v58) * *(float *)(result + 4 * v59));
                  *a5 = v55;
                  ++v60;
                  ++v59;
                  ++v58;
                }
                while (v60 < a7);
              }
              ++v54;
              v57 += a3;
              v56 += a7;
            }
            while (v54 != a6);
          }
          ++v52;
          ++a5;
          --v53;
        }
        while (v52 != v49);
      }
      unsigned int v61 = v46;
      unsigned int v62 = v7 >> 1;
      if (v8 < v47)
      {
        do
        {
          *a5 = 0.0;
          if (a6)
          {
            unsigned int v63 = 0;
            int v64 = 0;
            float v65 = 0.0;
            unsigned int v66 = v61;
            do
            {
              if (a7)
              {
                uint64_t v67 = a7;
                unsigned int v68 = v63;
                unsigned int v69 = v66;
                do
                {
                  float v65 = v65 + (float)(*(float *)(a4 + 4 * v68) * *(float *)(result + 4 * v69));
                  *a5 = v65;
                  ++v69;
                  ++v68;
                  --v67;
                }
                while (v67);
              }
              ++v64;
              v66 += a3;
              v63 += a7;
            }
            while (v64 != a6);
          }
          ++v62;
          ++a5;
          ++v61;
        }
        while (v62 != v47);
      }
      int v70 = v51;
      uint64_t v71 = a3 - v8;
      if (v47 < a3)
      {
        do
        {
          *a5 = 0.0;
          if (a6)
          {
            int v72 = 0;
            int v73 = 0;
            float v74 = 0.0;
            int v75 = v70;
            do
            {
              if (v71 != v48)
              {
                unint64_t v76 = 0;
                do
                {
                  float v74 = v74
                      + (float)(*(float *)(a4 + 4 * (v72 + v76))
                              * *(float *)(result + 4 * (v75 + v76)));
                  *a5 = v74;
                  ++v76;
                }
                while (v76 < (v48 - v71));
              }
              ++v73;
              v75 += a3;
              v72 += a7;
            }
            while (v73 != a6);
          }
          ++v71;
          ++a5;
          ++v70;
        }
        while (v71 != a3);
      }
      ++v50;
      v46 += a3;
      v51 += a3;
    }
    while (v50 != v45);
  }
  if (v45 < a2)
  {
    unsigned int v77 = v9 + a2;
    unsigned int v78 = a3 - v8;
    uint64_t v79 = v8 + a3;
    unsigned int v80 = (a6 - 1) & 0xFFFFFFFE;
    if (v8 <= 1) {
      unsigned int v81 = 1;
    }
    else {
      unsigned int v81 = (a7 - 1) >> 1;
    }
    int v82 = a3 * (a2 - v80);
    int v83 = a3 + v82 - 2 * v8;
    do
    {
      unsigned int v84 = v80 - 1;
      if (v80 <= 1) {
        unsigned int v80 = 1;
      }
      if (v7 >= 2)
      {
        int v85 = 0;
        unsigned int v86 = v7 >> 1;
        do
        {
          *a5 = 0.0;
          if (v77 != v45)
          {
            int v87 = 0;
            float v88 = 0.0;
            unsigned int v89 = v86;
            int v90 = v82;
            do
            {
              if (v8 - v85 < a7)
              {
                unsigned int v91 = v89;
                unsigned int v92 = v90;
                unint64_t v93 = v86;
                do
                {
                  float v88 = v88 + (float)(*(float *)(a4 + 4 * v91) * *(float *)(result + 4 * v92));
                  *a5 = v88;
                  ++v93;
                  ++v92;
                  ++v91;
                }
                while (v93 < a7);
              }
              ++v87;
              v90 += a3;
              v89 += a7;
            }
            while (v87 != v80);
          }
          ++v85;
          ++a5;
          --v86;
        }
        while (v85 != v81);
      }
      int v94 = v82;
      unsigned int v95 = v7 >> 1;
      if (v8 < v78)
      {
        do
        {
          *a5 = 0.0;
          if (v77 != v45)
          {
            unsigned int v96 = 0;
            int v97 = 0;
            float v98 = 0.0;
            int v99 = v94;
            do
            {
              if (a7)
              {
                uint64_t v100 = a7;
                unsigned int v101 = v96;
                unsigned int v102 = v99;
                do
                {
                  float v98 = v98 + (float)(*(float *)(a4 + 4 * v101) * *(float *)(result + 4 * v102));
                  *a5 = v98;
                  ++v102;
                  ++v101;
                  --v100;
                }
                while (v100);
              }
              ++v97;
              v99 += a3;
              v96 += a7;
            }
            while (v97 != v80);
          }
          ++v95;
          ++a5;
          ++v94;
        }
        while (v95 != v78);
      }
      int v103 = v83;
      uint64_t v104 = a3 - v8;
      if (v78 < a3)
      {
        do
        {
          *a5 = 0.0;
          if (v77 != v45)
          {
            int v105 = 0;
            int v106 = 0;
            float v107 = 0.0;
            int v108 = v103;
            do
            {
              if (v104 != v79)
              {
                unint64_t v109 = 0;
                do
                {
                  float v107 = v107
                       + (float)(*(float *)(a4 + 4 * (v105 + v109))
                               * *(float *)(result + 4 * (v108 + v109)));
                  *a5 = v107;
                  ++v109;
                }
                while (v109 < (v79 - v104));
              }
              ++v106;
              v108 += a3;
              v105 += a7;
            }
            while (v106 != v80);
          }
          ++v104;
          ++a5;
          ++v103;
        }
        while (v104 != a3);
      }
      ++v45;
      v82 += a3;
      v83 += a3;
      unsigned int v80 = v84;
    }
    while (v45 != a2);
  }
  return result;
}

uint64_t sub_100004E60(double *a1, double *a2, uint64_t a3)
{
  double v3 = a2[3];
  double v49 = a2[2] / v3;
  double v4 = a2[1];
  *(double *)&v50[1] = *a2 / v3;
  *(double *)&v51[1] = v49;
  *(double *)&v51[2] = v4 / v3;
  double v5 = a2[9];
  double v6 = a2[10];
  double v7 = a2[8];
  v48[2] = a2[7] / v6;
  v50[0] = 0;
  v51[0] = 0;
  v51[3] = 0;
  v51[4] = 0;
  v51[5] = 0x3FF0000000000000;
  v48[0] = v5 / v6;
  v48[1] = 0.0;
  v48[3] = 0.0;
  v48[4] = v5 / v6;
  v48[5] = v7 / v6;
  unsigned int v8 = v50;
  unsigned int v9 = v51;
  v48[6] = 0.0;
  v48[7] = 0.0;
  v48[8] = 1.0;
  for (uint64_t i = 1; i != 3; ++i)
  {
    uint64_t v11 = 0;
    uint64_t v12 = v8;
    do
    {
      uint64_t v13 = v9[v11];
      v9[v11] = *v12;
      *uint64_t v12 = v13;
      v12 += 3;
      ++v11;
    }
    while (i != v11);
    ++v8;
    v9 += 3;
  }
  uint64_t v14 = 0;
  uint64_t v42 = 0;
  memset(v41, 0, sizeof(v41));
  int v15 = &v49;
  do
  {
    uint64_t v16 = 0;
    unsigned int v17 = a1;
    do
    {
      uint64_t v18 = 0;
      double v19 = 0.0;
      unsigned int v20 = v17;
      do
      {
        double v21 = *v20;
        v20 += 3;
        double v19 = v19 + v15[v18++] * v21;
      }
      while (v18 != 3);
      *((double *)v41 + 3 * v14 + v16++) = v19;
      ++v17;
    }
    while (v16 != 3);
    ++v14;
    v15 += 3;
  }
  while (v14 != 3);
  uint64_t v22 = 0;
  uint64_t v47 = 0;
  long long v45 = 0u;
  long long v46 = 0u;
  long long v43 = 0u;
  long long v44 = 0u;
  float v23 = v41;
  do
  {
    uint64_t v24 = 0;
    unsigned int v25 = v48;
    do
    {
      uint64_t v26 = 0;
      double v27 = 0.0;
      unint64_t v28 = v25;
      do
      {
        double v29 = *v28;
        v28 += 3;
        double v27 = v27 + *(double *)((char *)v23 + v26) * v29;
        v26 += 8;
      }
      while (v26 != 24);
      *((double *)&v43 + 3 * v22 + v24++) = v27;
      ++v25;
    }
    while (v24 != 3);
    ++v22;
    float v23 = (_OWORD *)((char *)v23 + 24);
  }
  while (v22 != 3);
  long long v30 = v46;
  *(_OWORD *)(a3 + 32) = v45;
  *(_OWORD *)(a3 + 48) = v30;
  *(void *)(a3 + 64) = v47;
  long long v31 = v44;
  *(_OWORD *)a3 = v43;
  *(_OWORD *)(a3 + 16) = v31;
  int v32 = (void *)(a3 + 8);
  uint64_t v33 = a3 + 24;
  for (uint64_t j = 1; j != 3; ++j)
  {
    uint64_t v35 = 0;
    unsigned int v36 = v32;
    do
    {
      uint64_t v37 = *(void *)(v33 + 8 * v35);
      *(void *)(v33 + 8 * v35) = *v36;
      *unsigned int v36 = v37;
      v36 += 3;
      ++v35;
    }
    while (j != v35);
    ++v32;
    v33 += 24;
  }
  for (uint64_t k = 0; k != 3; ++k)
  {
    for (uint64_t m = 0; m != 24; m += 8)
      *(double *)(a3 + m) = -*(double *)(a3 + m);
    a3 += 24;
  }
  return 0;
}

void sub_100005098(uint64_t a1)
{
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = 0;
  *(void *)(a1 + 88) = 0x7FF8000000000000;
  *(_OWORD *)(a1 + 72) = xmmword_1000802D0;
  *(_WORD *)(a1 + 160) = 0;
  *(unsigned char *)(a1 + 162) = 0;
  *(_DWORD *)(a1 + 164) = 0;
  *(void *)a1 = off_100095B78;
  *(_OWORD *)(a1 + 120) = xmmword_100080250;
  *(_DWORD *)(a1 + 136) = 1;
  *(void *)(a1 + 148) = 4;
  *(_DWORD *)(a1 + 156) = 2;
  operator new[]();
}

void sub_1000051A0(_Unwind_Exception *a1)
{
  sub_10001183C(v1);
  _Unwind_Resume(a1);
}

void *sub_1000051BC(void *a1)
{
  *a1 = off_100095B78;
  if (a1[12]) {
    operator delete[]();
  }
  if (a1[13]) {
    operator delete[]();
  }

  return sub_10001183C(a1);
}

void sub_100005248(void *a1)
{
  sub_1000051BC(a1);

  operator delete();
}

uint64_t sub_100005280(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = sub_100012894(a1, a2);
  if (!v5)
  {
    uint64_t v15 = 0;
    long long v13 = 0u;
    long long v14 = 0u;
    long long v11 = 0u;
    long long v12 = 0u;
    long long v9 = *(_OWORD *)(a1 + 72);
    uint64_t v10 = *(void *)(a1 + 88);
    sub_100005308((double *)&v9, (uint64_t)&v11);
    long long v6 = v14;
    *(_OWORD *)(a3 + 32) = v13;
    *(_OWORD *)(a3 + 48) = v6;
    *(void *)(a3 + 64) = v15;
    long long v7 = v12;
    *(_OWORD *)a3 = v11;
    *(_OWORD *)(a3 + 16) = v7;
  }
  return v5;
}

uint64_t sub_100005308(double *a1, uint64_t a2)
{
  v4[0] = off_100095A80;
  v4[1] = a2;
  int v4[2] = 0x300000003;
  char v5 = 0;
  uint64_t v2 = sub_1000053A8((uint64_t)v4, *a1 / 1000.0, a1[1] / 1000.0, a1[2] / 1000.0);
  sub_100003224((uint64_t)v4);
  return v2;
}

void sub_10000538C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_1000053A0()
{
  return 256;
}

uint64_t sub_1000053A8(uint64_t a1, double a2, long double a3, long double a4)
{
  double v8 = cos(a3);
  double v9 = cos(a4);
  unsigned int v10 = *(_DWORD *)(a1 + 16);
  if (!v10 || (uint64_t v11 = *(unsigned int *)(a1 + 20), !v11)) {
    sub_100073870();
  }
  double v12 = v9;
  **(double **)(a1 + 8) = v8 * v9;
  __double2 v13 = __sincos_stret(a2);
  double v14 = sin(a3);
  double v15 = sin(a4);
  if (v11 == 1) {
    sub_100073870();
  }
  *(double *)(*(void *)(a1 + 8) + 8) = v13.__sinval * v12 * v14 - v13.__cosval * v15;
  if (v11 <= 2) {
    sub_100073870();
  }
  *(double *)(*(void *)(a1 + 8) + 16) = v13.__cosval * v14 * v12 + v13.__sinval * v15;
  if (v10 <= 1) {
    sub_100073870();
  }
  *(double *)(*(void *)(a1 + 8) + 8 * v11) = v8 * v15;
  *(double *)(*(void *)(a1 + 8) + 8 * v11 + 8) = v13.__sinval * v14 * v15 + v13.__cosval * v12;
  *(double *)(*(void *)(a1 + 8) + 8 * v11 + 16) = v13.__cosval * v14 * v15 - v13.__sinval * v12;
  if (v10 == 2) {
    sub_100073870();
  }
  unsigned int v16 = 2 * v11;
  *(double *)(*(void *)(a1 + 8) + 8 * v16) = -v14;
  *(double *)(*(void *)(a1 + 8) + 8 * v16 + 8) = v13.__sinval * v8;
  *(double *)(*(void *)(a1 + 8) + 8 * v16 + 16) = v13.__cosval * v8;
  return 0;
}

uint64_t sub_100005514(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_DWORD *)(a1 + 20) != *(_DWORD *)(a2 + 20)) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v4 = 0;
  double v5 = *(double *)(a3 + 16);
  double v6 = *(double *)(a3 + 24);
  double v7 = *(double *)(a3 + 8);
  v66[2] = *(double *)a3 / v6;
  v66[0] = v5 / v6;
  v66[1] = 0.0;
  v66[3] = 0.0;
  v66[4] = v5 / v6;
  v66[5] = v7 / v6;
  v66[6] = 0.0;
  v66[7] = 0.0;
  v66[8] = 1.0;
  long long v8 = *(_OWORD *)(a3 + 336);
  v64[2] = *(_OWORD *)(a3 + 320);
  v64[3] = v8;
  uint64_t v65 = *(void *)(a3 + 352);
  long long v9 = *(_OWORD *)(a3 + 304);
  v64[0] = *(_OWORD *)(a3 + 288);
  v64[1] = v9;
  memset(v63, 0, sizeof(v63));
  do
  {
    *(double *)&v63[v4] = *(double *)(a3 + v4 * 8 + 360) - *(double *)(a3 + v4 * 8 + 32);
    ++v4;
  }
  while (v4 != 3);
  uint64_t v10 = 0;
  uint64_t v62 = *(void *)(a3 + 504);
  long long v61 = *(_OWORD *)(a3 + 488);
  double v11 = *(double *)(a3 + 480);
  uint64_t v58 = 0;
  long long v56 = 0u;
  long long v57 = 0u;
  long long v54 = 0u;
  long long v55 = 0u;
  double v12 = &v54;
  __double2 v13 = v64;
  do
  {
    uint64_t v14 = 0;
    double v15 = v12;
    do
    {
      *(void *)double v15 = *(void *)((char *)v13 + v14);
      double v15 = (long long *)((char *)v15 + 24);
      v14 += 8;
    }
    while (v14 != 24);
    ++v10;
    double v12 = (long long *)((char *)v12 + 8);
    __double2 v13 = (_OWORD *)((char *)v13 + 24);
  }
  while (v10 != 3);
  uint64_t v16 = 0;
  uint64_t v48 = 0;
  memset(v47, 0, sizeof(v47));
  unsigned int v17 = v47;
  do
  {
    uint64_t v18 = 0;
    double v19 = *(double *)&v63[v16];
    do
    {
      *(double *)((char *)v17 + v18) = v19 * *(double *)((char *)&v61 + v18) + 0.0;
      v18 += 8;
    }
    while (v18 != 24);
    ++v16;
    unsigned int v17 = (_OWORD *)((char *)v17 + 24);
  }
  while (v16 != 3);
  uint64_t v20 = 0;
  uint64_t v21 = 0;
  uint64_t v53 = 0;
  long long v51 = 0u;
  long long v52 = 0u;
  *(_OWORD *)__src = 0u;
  long long v50 = 0u;
  do
  {
    for (uint64_t i = 0; i != 24; i += 8)
      *(double *)((char *)&__src[v20] + i) = *(double *)((char *)v47 + v20 * 8 + i) / v11;
    ++v21;
    v20 += 3;
  }
  while (v21 != 3);
  uint64_t v23 = 0;
  uint64_t v24 = 0;
  uint64_t v60 = 0;
  memset(v59, 0, sizeof(v59));
  do
  {
    for (uint64_t j = 0; j != 24; j += 8)
      *(double *)((char *)v59 + v23 * 8 + j) = *(double *)((char *)&v54 + v23 * 8 + j)
                                             - *(double *)((char *)&__src[v23] + j);
    ++v24;
    v23 += 3;
  }
  while (v24 != 3);
  uint64_t v26 = 0;
  uint64_t v53 = 0;
  long long v51 = 0u;
  long long v52 = 0u;
  *(_OWORD *)__src = 0u;
  long long v50 = 0u;
  double v27 = v66;
  do
  {
    uint64_t v28 = 0;
    double v29 = v59;
    do
    {
      uint64_t v30 = 0;
      double v31 = 0.0;
      int v32 = (double *)v29;
      do
      {
        double v33 = *v32;
        v32 += 3;
        double v31 = v31 + v27[v30++] * v33;
      }
      while (v30 != 3);
      *((double *)&__src[3 * v26] + v28++) = v31;
      double v29 = (_OWORD *)((char *)v29 + 8);
    }
    while (v28 != 3);
    ++v26;
    v27 += 3;
  }
  while (v26 != 3);
  sub_1000058FC((uint64_t)v66, (uint64_t)v47);
  uint64_t v34 = 0;
  uint64_t v58 = 0;
  long long v56 = 0u;
  long long v57 = 0u;
  long long v54 = 0u;
  long long v55 = 0u;
  uint64_t v35 = __src;
  do
  {
    uint64_t v36 = 0;
    uint64_t v37 = v47;
    do
    {
      uint64_t v38 = 0;
      double v39 = 0.0;
      float v40 = (double *)v37;
      do
      {
        double v41 = *v40;
        v40 += 3;
        double v39 = v39 + *(double *)&v35[v38++] * v41;
      }
      while (v38 != 3);
      *((double *)&v54 + 3 * v34 + v36++) = v39;
      uint64_t v37 = (_OWORD *)((char *)v37 + 8);
    }
    while (v36 != 3);
    ++v34;
    v35 += 3;
  }
  while (v34 != 3);
  sub_100005A18((uint64_t)&v54, a2, (uint64_t)__src);
  sub_100004500(a2, v50, SDWORD1(v50));
  memcpy(*(void **)(a2 + 8), __src[1], 8 * *(unsigned int *)(a2 + 16) * (unint64_t)*(unsigned int *)(a2 + 20));
  sub_100003224((uint64_t)__src);
  uint64_t v42 = *(unsigned int *)(a2 + 20);
  if (v42)
  {
    if (*(_DWORD *)(a2 + 16) < 3u) {
      sub_100073870();
    }
    uint64_t v43 = 0;
    uint64_t v44 = 8 * (2 * v42);
    uint64_t v45 = 8 * v42;
    do
    {
      *(double *)(*(void *)(a2 + 8) + v43) = *(double *)(*(void *)(a2 + 8) + v43)
                                             / *(double *)(*(void *)(a2 + 8) + v43 + v44);
      *(double *)(*(void *)(a2 + 8) + v45 + v43) = *(double *)(*(void *)(a2 + 8) + v45 + v43)
                                                   / *(double *)(*(void *)(a2 + 8) + v44 + v43);
      *(void *)(*(void *)(a2 + 8) + v44 + v43) = 0x3FF0000000000000;
      v43 += 8;
    }
    while (v45 != v43);
  }
  return 0;
}

void sub_1000058E8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  sub_100003224((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1000058FC@<X0>(uint64_t result@<X0>, uint64_t a2@<X8>)
{
  uint64_t v2 = 0;
  *(void *)(a2 + 64) = 0;
  *(_OWORD *)(a2 + 32) = 0u;
  *(_OWORD *)(a2 + 48) = 0u;
  *(_OWORD *)a2 = 0u;
  *(_OWORD *)(a2 + 16) = 0u;
  double v3 = 0.0;
  uint64_t v4 = 0xFFFFFFFF00000000;
  do
  {
    if (v2 == 2) {
      uint64_t v5 = 0;
    }
    else {
      uint64_t v5 = v2 + 1;
    }
    uint64_t v6 = v4 >> 32;
    if (!v2) {
      uint64_t v6 = 2;
    }
    double v3 = v3
       + *(double *)(result + 8 * v2)
       * (*(double *)(result + 24 + 8 * v5) * *(double *)(result + 48 + 8 * v6)
        - *(double *)(result + 24 + 8 * v6) * *(double *)(result + 48 + 8 * v5));
    v4 += (uint64_t)&_mh_execute_header;
    ++v2;
  }
  while (v2 != 3);
  unint64_t v7 = 0;
  do
  {
    uint64_t v8 = 0;
    if (v7 > 1) {
      int v9 = -2;
    }
    else {
      int v9 = 1;
    }
    unsigned int v10 = v7 + v9;
    unsigned int v11 = v7 - 1;
    if (v7++ == 0) {
      unsigned int v11 = 2;
    }
    uint64_t v13 = 0xFFFFFFFF00000000;
    uint64_t v14 = (double *)a2;
    do
    {
      if (v8 == 2) {
        uint64_t v15 = 0;
      }
      else {
        uint64_t v15 = v8 + 1;
      }
      uint64_t v16 = v8 + 1;
      uint64_t v17 = v13 >> 32;
      if (!v8) {
        uint64_t v17 = 2;
      }
      *uint64_t v14 = (*(double *)(result + 24 * v10 + 8 * v15) * *(double *)(result + 24 * v11 + 8 * v17)
            - *(double *)(result + 24 * v10 + 8 * v17) * *(double *)(result + 24 * v11 + 8 * v15))
           / v3;
      v14 += 3;
      v13 += (uint64_t)&_mh_execute_header;
      ++v8;
    }
    while (v16 != 3);
    a2 += 8;
  }
  while (v7 != 3);
  return result;
}

uint64_t sub_100005A18@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  sub_100005A90(a1, a2, (uint64_t)&v7);
  uint64_t v4 = v8;
  int v5 = v9;
  *(unsigned char *)(a3 + 24) = v10;
  uint64_t v8 = 0;
  char v10 = 0;
  *(void *)a3 = &off_100095BC8;
  *(void *)(a3 + 8) = v4;
  *(_DWORD *)(a3 + 16) = 3;
  *(_DWORD *)(a3 + 20) = v5;
  return sub_100003224((uint64_t)&v7);
}

uint64_t sub_100005A90@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t result = a3;
  if (*(_DWORD *)(a2 + 16) == 3)
  {
    uint64_t result = sub_1000032CC(a3, 3, *(_DWORD *)(a2 + 20));
    uint64_t v6 = 0;
    uint64_t v7 = *(void *)(a2 + 8);
    uint64_t v8 = *(void *)(result + 8);
    uint64_t v9 = *(unsigned int *)(a2 + 20);
    int v10 = *(_DWORD *)(a2 + 20);
    do
    {
      if (v10 >= 1)
      {
        uint64_t v11 = 0;
        uint64_t v12 = v7;
        do
        {
          uint64_t v13 = 0;
          double v14 = 0.0;
          uint64_t result = v12;
          do
          {
            double v14 = v14 + *(double *)(a1 + v13) * *(double *)result;
            v13 += 8;
            result += 8 * (int)v9;
          }
          while (v13 != 24);
          *(double *)(v8 + 8 * v6 * (int)v9 + 8 * v11++) = v14;
          v12 += 8;
        }
        while (v11 != v9);
      }
      ++v6;
      a1 += 24;
    }
    while (v6 != 3);
  }
  else
  {
    *(void *)a3 = off_100095A80;
    *(void *)(a3 + 8) = 0;
    *(void *)(a3 + 16) = 0;
    *(unsigned char *)(a3 + 24) = 0;
  }
  return result;
}

void sub_100005B78(uint64_t a1)
{
  sub_100003224(a1);

  operator delete();
}

void sub_100005BB0(uint64_t a1)
{
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = 0;
  *(void *)(a1 + 88) = 0x7FF8000000000000;
  *(_OWORD *)(a1 + 72) = xmmword_100080360;
  *(_WORD *)(a1 + 160) = 0;
  *(unsigned char *)(a1 + 162) = 0;
  *(_DWORD *)(a1 + 164) = 0;
  *(void *)a1 = off_100095C00;
  *(_OWORD *)(a1 + 120) = xmmword_100080310;
  *(_OWORD *)(a1 + 136) = xmmword_100080320;
  *(void *)(a1 + 152) = 0xF00000007;
  operator new[]();
}

void sub_100005C98(_Unwind_Exception *a1)
{
  sub_10001183C(v1);
  _Unwind_Resume(a1);
}

void *sub_100005CB4(void *a1)
{
  *a1 = off_100095C00;
  if (a1[12]) {
    operator delete[]();
  }
  if (a1[13]) {
    operator delete[]();
  }

  return sub_10001183C(a1);
}

void sub_100005D40(void *a1)
{
  sub_100005CB4(a1);

  operator delete();
}

uint64_t sub_100005D78(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = sub_100012894(a1, a2);
  if (!v5)
  {
    uint64_t v15 = 0;
    long long v13 = 0u;
    long long v14 = 0u;
    long long v11 = 0u;
    long long v12 = 0u;
    long long v9 = *(_OWORD *)(a1 + 72);
    uint64_t v10 = *(void *)(a1 + 88);
    sub_100005308((double *)&v9, (uint64_t)&v11);
    long long v6 = v14;
    *(_OWORD *)(a3 + 32) = v13;
    *(_OWORD *)(a3 + 48) = v6;
    *(void *)(a3 + 64) = v15;
    long long v7 = v12;
    *(_OWORD *)a3 = v11;
    *(_OWORD *)(a3 + 16) = v7;
  }
  return v5;
}

uint64_t sub_100005E50(uint64_t a1, long double *a2)
{
  *a2 = atan2(*(long double *)(a1 + 56), *(long double *)(a1 + 64)) * 1000.0;
  a2[1] = atan2(-*(double *)(a1 + 48), sqrt(*(double *)(a1 + 64) * *(double *)(a1 + 64) + *(double *)(a1 + 56) * *(double *)(a1 + 56)))* 1000.0;
  a2[2] = atan2(*(long double *)(a1 + 24), *(long double *)a1) * 1000.0;
  return 0;
}

uint64_t sub_100005ED0()
{
  return 256;
}

void sub_100005ED8()
{
  exception = (std::bad_array_new_length *)__cxa_allocate_exception(8uLL);
  uint64_t v1 = std::bad_array_new_length::bad_array_new_length(exception);
}

void sub_100005F0C(void *a1)
{
  *a1 = off_100095C40;
  operator new();
}

void sub_100005F70()
{
}

void *sub_100005F98(void *a1)
{
  *a1 = off_100095C40;
  uint64_t v2 = a1[1];
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  return a1;
}

void sub_100006004(void *a1)
{
  *a1 = off_100095C40;
  uint64_t v1 = a1[1];
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  }

  operator delete();
}

uint64_t sub_100006090(uint64_t a1, _DWORD *a2, int64x2_t *a3, double a4, double a5, double a6)
{
  return sub_100023EA8(a4, a5, a6, NAN, a1, *(void **)(a1 + 8), a2, 2, a3);
}

uint64_t sub_1000060AC(uint64_t a1, _DWORD *a2, int64x2_t *a3, double a4, double a5, double a6)
{
  return sub_100023EA8(a4, a5, a6, NAN, a1, *(void **)(a1 + 8), a2, 0, a3);
}

uint64_t sub_1000060C8(uint64_t a1, _DWORD *a2, int64x2_t *a3, double a4, double a5, double a6, double a7)
{
  return sub_100023EA8(a4, a5, a6, a7, a1, *(void **)(a1 + 8), a2, 1, a3);
}

uint64_t sub_1000060DC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return sub_100005D78(*(void *)(a1 + 8), a2, a3 + 8552);
}

void *sub_1000060EC(void *result, uint64_t a2)
{
  *uint64_t result = "com.apple.tof.clocking";
  result[1] = a2;
  return result;
}

uint64_t sub_1000060FC(uint64_t result)
{
  if (*(void *)(result + 8)) {
    *(void *)(result + 8) = 0;
  }
  return result;
}

uint64_t sub_10000610C(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  if (!v2) {
    return 3758097088;
  }
  uint64_t v3 = sub_100054EC8(v2, 1u, outputStruct);
  if (!v3)
  {
    uint64_t v4 = sub_100054EC8(*(void *)(a1 + 8), 0, __src);
    uint64_t v3 = v4;
    if (!v4)
    {
      uint32_t v5 = 0;
      for (uint64_t i = 28; i != 53; ++i)
      {
        LODWORD(v4) = v4 + LODWORD(__src[i]);
        v5 += LODWORD(outputStruct[i]);
      }
      signed int v7 = arc4random_uniform(v4);
      signed int v8 = arc4random_uniform(v5);
      uint64_t v9 = 0;
      while (1)
      {
        v7 -= LODWORD(__src[v9 + 28]);
        if (v7 < 1) {
          break;
        }
        if (++v9 == 25)
        {
          LODWORD(v9) = 0;
          break;
        }
      }
      uint64_t v10 = 0;
      while (1)
      {
        v8 -= LODWORD(outputStruct[v10 + 28]);
        if (v8 < 1) {
          break;
        }
        if (++v10 == 25)
        {
          LODWORD(v10) = 0;
          break;
        }
      }
      uint32_t v11 = arc4random_uniform(3u);
      uint64_t v3 = 0;
      if (__src[3] && __src[53])
      {
        uint64_t v18 = _NSConcreteStackBlock;
        uint64_t v19 = 0x40000000;
        uint64_t v20 = sub_1000063F0;
        uint64_t v21 = &unk_100095C68;
        memcpy(v22, __src, sizeof(v22));
        uint32_t v23 = v11;
        int v24 = v9;
        if (analytics_send_event_lazy())
        {
          uint64_t v3 = 0;
        }
        else
        {
          os_log_t v13 = (os_log_t)off_1002BBB88;
          if (off_1002BBB88 == &_os_log_default)
          {
            os_log_t v13 = os_log_create("com.apple.isp", "general");
            off_1002BBB88 = v13;
          }
          uint64_t v3 = 3758097084;
          if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR)) {
            sub_10007389C();
          }
        }
      }
      if (outputStruct[3])
      {
        if (outputStruct[53])
        {
          memcpy(v15, outputStruct, sizeof(v15));
          uint32_t v16 = v11;
          int v17 = v10;
          if ((analytics_send_event_lazy() & 1) == 0)
          {
            os_log_t v14 = (os_log_t)off_1002BBB88;
            if (off_1002BBB88 == &_os_log_default)
            {
              os_log_t v14 = os_log_create("com.apple.isp", "general");
              off_1002BBB88 = v14;
            }
            if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR)) {
              sub_10007389C();
            }
            return 3758097084;
          }
        }
      }
    }
  }
  return v3;
}

void *sub_1000063F0(uint64_t a1)
{
  xpc_object_t v2 = xpc_dictionary_create(0, 0, 0);
  uint64_t v3 = v2;
  if (v2)
  {
    xpc_dictionary_set_double(v2, "nDefaultCaseCountJasper", (double)*(unint64_t *)(a1 + 32) / (double)*(unint64_t *)(a1 + 56));
    xpc_dictionary_set_uint64(v3, "nDefaultCaseZeroScoreJasper", *(void *)(a1 + 40));
    xpc_dictionary_set_double(v3, "nPLLSwitchCountJasper", (double)*(unint64_t *)(a1 + 48) / (double)*(unint64_t *)(a1 + 56));
    xpc_dictionary_set_double(v3, "nPLLSwitchPerSecCountJasper", (double)*(unint64_t *)(a1 + 48) / (double)*(unint64_t *)(a1 + 456));
    xpc_dictionary_set_uint64(v3, "nBankNumberJasper", *(int *)(a1 + 616));
    xpc_dictionary_set_uint64(v3, "nBankOpModeJasper", *(unsigned int *)(a1 + 64 + 48 * *(int *)(a1 + 616)));
    xpc_dictionary_set_uint64(v3, "nBankMaxPriJasper", *(void *)(a1 + 64 + 48 * *(int *)(a1 + 616) + 16));
    xpc_dictionary_set_uint64(v3, "nBankMinPriJasper", *(void *)(a1 + 64 + 48 * *(int *)(a1 + 616) + 8));
    xpc_dictionary_set_double(v3, "nBankSamplePriJasper", (double)*(unint64_t *)(a1 + 64 + 48 * *(int *)(a1 + 616) + 24));
    xpc_dictionary_set_double(v3, "nBankAverage2ValPriJasper", *(double *)(a1 + 64 + 48 * *(int *)(a1 + 616) + 40));
    xpc_dictionary_set_uint64(v3, "nBankMaxDiffPriJasper", *(void *)(a1 + 64 + 48 * *(int *)(a1 + 616) + 32));
    xpc_dictionary_set_double(v3, "nPriSwitchCountJasper", (double)*(unint64_t *)(a1 + 464) / (double)*(unint64_t *)(a1 + 56));
    xpc_dictionary_set_uint64(v3, "nSelectionAlgoCallsJasper", *(void *)(a1 + 56));
    xpc_dictionary_set_uint64(v3, "nSelectionAlgoResults0", *(void *)(a1 + 480));
    xpc_dictionary_set_uint64(v3, "nSelectionAlgoResults1", *(void *)(a1 + 488));
    xpc_dictionary_set_uint64(v3, "nSelectionAlgoResults2", *(void *)(a1 + 496));
    xpc_dictionary_set_uint64(v3, "nSelectionAlgoResults3", *(void *)(a1 + 504));
    xpc_dictionary_set_uint64(v3, "nSelectionAlgoResults4", *(void *)(a1 + 512));
    xpc_dictionary_set_uint64(v3, "nSelectionAlgoResults5", *(void *)(a1 + 520));
    xpc_dictionary_set_uint64(v3, "nSelectionAlgoResults6", *(void *)(a1 + 528));
    xpc_dictionary_set_uint64(v3, "nSelectionAlgoResults7", *(void *)(a1 + 536));
    xpc_dictionary_set_uint64(v3, "nSelectionAlgoResults8", *(void *)(a1 + 544));
    xpc_dictionary_set_uint64(v3, "nSelectionAlgoResults9", *(void *)(a1 + 552));
    xpc_dictionary_set_uint64(v3, "nSelectionAlgoResults10", *(void *)(a1 + 560));
    xpc_dictionary_set_uint64(v3, "kSelectionAlgoFrequent1", *(unsigned int *)(a1 + 568));
    xpc_dictionary_set_uint64(v3, "kSelectionAlgoFrequent2", *(unsigned int *)(a1 + 572));
    xpc_dictionary_set_uint64(v3, "kSelectionAlgoFrequent3", *(unsigned int *)(a1 + 576));
    xpc_dictionary_set_uint64(v3, "kSelectionAlgoFrequent4", *(unsigned int *)(a1 + 580));
    xpc_dictionary_set_uint64(v3, "kSelectionAlgoFrequent5", *(unsigned int *)(a1 + 584));
    xpc_dictionary_set_uint64(v3, "kSelectionAlgoFrequent6", *(unsigned int *)(a1 + 588));
    xpc_dictionary_set_uint64(v3, "kSelectionAlgoFrequent7", *(unsigned int *)(a1 + 592));
    xpc_dictionary_set_uint64(v3, "kSelectionAlgoFrequent8", *(unsigned int *)(a1 + 596));
    xpc_dictionary_set_uint64(v3, "kSelectionAlgoFrequent9", *(unsigned int *)(a1 + 600));
    xpc_dictionary_set_uint64(v3, "kSelectionAlgoFrequent10", *(unsigned int *)(a1 + 604));
    xpc_dictionary_set_double(v3, "nSelectionAlgoCallsPerSecJasper", (double)*(unint64_t *)(a1 + 56) / (double)*(unint64_t *)(a1 + 456));
    xpc_dictionary_set_double(v3, "nUniquePriPairBanksJasper", (double)*(unint64_t *)(a1 + 472));
    xpc_dictionary_set_uint64(v3, "nPllHistJasper", *(unsigned int *)(a1 + 620));
    xpc_dictionary_set_uint64(v3, "nTotalRunTimeSecJasper", *(void *)(a1 + 456));
    xpc_dictionary_set_BOOL(v3, "nJasperOnJasper", *(unsigned char *)(a1 + 608));
  }
  return v3;
}

void *sub_1000067CC(uint64_t a1)
{
  xpc_object_t v2 = xpc_dictionary_create(0, 0, 0);
  uint64_t v3 = v2;
  if (v2)
  {
    xpc_dictionary_set_double(v2, "nDefaultCaseCountJasper", (double)*(unint64_t *)(a1 + 32) / (double)*(unint64_t *)(a1 + 56));
    xpc_dictionary_set_uint64(v3, "nDefaultCaseZeroScoreJasper", *(void *)(a1 + 40));
    xpc_dictionary_set_double(v3, "nPLLSwitchCountJasper", (double)*(unint64_t *)(a1 + 48) / (double)*(unint64_t *)(a1 + 56));
    xpc_dictionary_set_double(v3, "nPLLSwitchPerSecCountJasper", (double)*(unint64_t *)(a1 + 48) / (double)*(unint64_t *)(a1 + 456));
    xpc_dictionary_set_uint64(v3, "nBankNumberJasper", *(int *)(a1 + 616));
    xpc_dictionary_set_uint64(v3, "nBankOpModeJasper", *(unsigned int *)(a1 + 64 + 48 * *(int *)(a1 + 616)));
    xpc_dictionary_set_uint64(v3, "nBankMaxPriJasper", *(void *)(a1 + 64 + 48 * *(int *)(a1 + 616) + 16));
    xpc_dictionary_set_uint64(v3, "nBankMinPriJasper", *(void *)(a1 + 64 + 48 * *(int *)(a1 + 616) + 8));
    xpc_dictionary_set_double(v3, "nBankSamplePriJasper", (double)*(unint64_t *)(a1 + 64 + 48 * *(int *)(a1 + 616) + 24));
    xpc_dictionary_set_double(v3, "nBankAverage2ValPriJasper", *(double *)(a1 + 64 + 48 * *(int *)(a1 + 616) + 40));
    xpc_dictionary_set_uint64(v3, "nBankMaxDiffPriJasper", *(void *)(a1 + 64 + 48 * *(int *)(a1 + 616) + 32));
    xpc_dictionary_set_double(v3, "nPriSwitchCountJasper", (double)*(unint64_t *)(a1 + 464) / (double)*(unint64_t *)(a1 + 56));
    xpc_dictionary_set_uint64(v3, "nSelectionAlgoCallsJasper", *(void *)(a1 + 56));
    xpc_dictionary_set_uint64(v3, "nSelectionAlgoResults0", *(void *)(a1 + 480));
    xpc_dictionary_set_uint64(v3, "nSelectionAlgoResults1", *(void *)(a1 + 488));
    xpc_dictionary_set_uint64(v3, "nSelectionAlgoResults2", *(void *)(a1 + 496));
    xpc_dictionary_set_uint64(v3, "nSelectionAlgoResults3", *(void *)(a1 + 504));
    xpc_dictionary_set_uint64(v3, "nSelectionAlgoResults4", *(void *)(a1 + 512));
    xpc_dictionary_set_uint64(v3, "nSelectionAlgoResults5", *(void *)(a1 + 520));
    xpc_dictionary_set_uint64(v3, "nSelectionAlgoResults6", *(void *)(a1 + 528));
    xpc_dictionary_set_uint64(v3, "nSelectionAlgoResults7", *(void *)(a1 + 536));
    xpc_dictionary_set_uint64(v3, "nSelectionAlgoResults8", *(void *)(a1 + 544));
    xpc_dictionary_set_uint64(v3, "nSelectionAlgoResults9", *(void *)(a1 + 552));
    xpc_dictionary_set_uint64(v3, "nSelectionAlgoResults10", *(void *)(a1 + 560));
    xpc_dictionary_set_uint64(v3, "kSelectionAlgoFrequent1", *(unsigned int *)(a1 + 568));
    xpc_dictionary_set_uint64(v3, "kSelectionAlgoFrequent2", *(unsigned int *)(a1 + 572));
    xpc_dictionary_set_uint64(v3, "kSelectionAlgoFrequent3", *(unsigned int *)(a1 + 576));
    xpc_dictionary_set_uint64(v3, "kSelectionAlgoFrequent4", *(unsigned int *)(a1 + 580));
    xpc_dictionary_set_uint64(v3, "kSelectionAlgoFrequent5", *(unsigned int *)(a1 + 584));
    xpc_dictionary_set_uint64(v3, "kSelectionAlgoFrequent6", *(unsigned int *)(a1 + 588));
    xpc_dictionary_set_uint64(v3, "kSelectionAlgoFrequent7", *(unsigned int *)(a1 + 592));
    xpc_dictionary_set_uint64(v3, "kSelectionAlgoFrequent8", *(unsigned int *)(a1 + 596));
    xpc_dictionary_set_uint64(v3, "kSelectionAlgoFrequent9", *(unsigned int *)(a1 + 600));
    xpc_dictionary_set_uint64(v3, "kSelectionAlgoFrequent10", *(unsigned int *)(a1 + 604));
    xpc_dictionary_set_double(v3, "nSelectionAlgoCallsPerSecJasper", (double)*(unint64_t *)(a1 + 56) / (double)*(unint64_t *)(a1 + 456));
    xpc_dictionary_set_double(v3, "nUniquePriPairBanksJasper", (double)*(unint64_t *)(a1 + 472));
    xpc_dictionary_set_uint64(v3, "nPllHistJasper", *(unsigned int *)(a1 + 620));
    xpc_dictionary_set_uint64(v3, "nTotalRunTimeSecJasper", *(void *)(a1 + 456));
    xpc_dictionary_set_BOOL(v3, "nJasperOnJasper", *(unsigned char *)(a1 + 608));
  }
  return v3;
}

uint64_t sub_100006BC0(uint64_t a1, double *a2, void *a3, double *a4, double *a5, int8x16_t a6, int8x16_t a7, int8x16_t a8)
{
  if ((unint64_t)(a1 - 10) < 0xFFFFFFFFFFFFFFF7) {
    return 4294967197;
  }
  long long v12 = a2;
  uint64_t v14 = a1 - 1;
  if (a1 == 1)
  {
    a6.i64[0] = *(uint64_t *)a2;
    a7.i64[0] = 1.0;
    v15.f64[0] = NAN;
    v15.f64[1] = NAN;
    *a3 = vbslq_s8((int8x16_t)vnegq_f64(v15), a7, a6).u64[0];
    *a4 = fabs(*a2);
    *a5 = 1.0;
    if ((*(void *)a2 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL) {
      return 0;
    }
    else {
      return 0xFFFFFFFFLL;
    }
  }
  else
  {
    sub_1000070BC(a1, a2, 1, a6, *(double *)a7.i64, a8);
    *(void *)a4 = v16;
    if ((v16 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
    {
      return 0;
    }
    else
    {
      int v75 = a5;
      unint64_t v76 = a3;
      uint64_t v17 = 0;
      uint64_t v8 = 0;
      int v72 = a4;
      uint64_t v73 = a1 - 2;
      unsigned int v77 = v12;
      uint64_t v18 = a1;
      uint64_t v71 = v14;
      int v70 = &v82[v14];
      while (1)
      {
        sub_10000715C(1, a1 + v8, a1 + v8 - 1, v12, 1, (uint64_t)&v12[v18], a1);
        if (a1 + v8 == 2) {
          break;
        }
        sub_1000070BC(a1 + v8 - 1, &v12[v18], a1, v19, *(double *)v20.i64, v21);
        v82[v17] = v27;
        if ((*(void *)&v27 & 0x7FFFFFFFFFFFFFFFuLL) >= 0x7FF0000000000000) {
          return -(int)v8;
        }
        sub_10000715C(0, a1 + v8 - 1, a1 + v8 - 1, &v12[v18], a1, (uint64_t)&v12[v18 + 1], a1);
        sub_1000070BC(--v8 + a1, &v12[v18 + 1], 1, v28, v29, v30);
        a4[++v17] = v31;
        v12 += a1 + 1;
        if ((*(void *)&v31 & 0x7FFFFFFFFFFFFFFFuLL) >= 0x7FF0000000000000) {
          return v8;
        }
      }
      int v32 = a4;
      v82[v73] = v12[a1];
      double v33 = v12[v18 + 1];
      uint64_t v34 = v14;
      v72[v14] = v33;
      uint64_t v35 = v34 + v34 * a1;
      uint64_t v36 = (uint64_t)v76;
      v76[v35] = 0x3FF0000000000000;
      if (a1 < 2)
      {
        unsigned int v63 = v75;
        v75[v35] = 1.0;
        *int v75 = 1.0;
        int v64 = &v82[v14];
      }
      else
      {
        uint64_t v69 = a1 * a1;
        uint64_t v37 = (uint64_t)&v76[a1 * a1 - 2];
        unint64_t v74 = (v18 * 8) ^ 0xFFFFFFFFFFFFFFF8;
        uint64_t v38 = 8 * a1 * v14 - 8;
        double v39 = (char *)v76 + v38;
        float v40 = (char *)v77 + v38;
        uint64_t v41 = 1;
        uint64_t v42 = a1 - 2;
        do
        {
          uint64_t v43 = v34;
          uint64_t v34 = v42;
          uint64_t v78 = v37;
          uint64_t v44 = (void *)v37;
          uint64_t v45 = v41;
          if (v43 < a1)
          {
            do
            {
              *uint64_t v44 = 0;
              uint64_t v44 = (void *)((char *)v44 + v18 * 8);
              --v45;
            }
            while (v45);
          }
          uint64_t v46 = v34 + v34 * a1;
          sub_10000715C(1, a1 - v34, a1 - v34 - 1, &v77[v46], 1, (uint64_t)&v76[v34 + v43 * a1], a1);
          double v33 = v77[v46];
          *(double *)v20.i64 = 1.0 - v33;
          *(double *)&v76[v46] = 1.0 - v33;
          if (v43 < a1)
          {
            uint64_t v47 = 0;
            double v33 = -v33;
            do
            {
              *(double *)v20.i64 = *(double *)&v40[8 * v47] * v33;
              *(void *)&v39[8 * v47++] = v20.i64[0];
            }
            while (v41 != v47);
          }
          ++v41;
          uint64_t v37 = v78 + v74;
          v39 += v74;
          v40 += v74;
          uint64_t v42 = v34 - 1;
        }
        while (v34 >= 1);
        v75[v71 + v71 * a1] = 1.0;
        uint64_t v48 = v71;
        if (a1 > 2)
        {
          uint64_t v49 = 0;
          unint64_t v79 = (v18 * 8) ^ 0xFFFFFFFFFFFFFFF8;
          uint64_t v50 = (uint64_t)&v75[v69 - 2];
          uint64_t v51 = (uint64_t)&v77[v69 - 3];
          uint64_t v52 = 1;
          uint64_t v53 = a1 - 2;
          do
          {
            uint64_t v54 = v48;
            uint64_t v55 = v53;
            if (v48 < a1) {
              bzero((char *)&v75[v71 * a1 - 1] + v79 * v49, 8 * v49 + 8);
            }
            uint64_t v56 = a1 - v55;
            uint64_t v57 = v55 * a1;
            uint64_t v58 = v55;
            unsigned int v59 = &v77[v48 + v55 * a1];
            uint64_t v48 = v58;
            uint64_t v60 = &v75[v57 + v58];
            sub_10000715C(0, v56, v56, v59 - 2, a1, (uint64_t)v60, a1);
            double v33 = *(v59 - 2);
            *(double *)v20.i64 = 1.0 - v33;
            *uint64_t v60 = 1.0 - v33;
            if (v54 < a1)
            {
              uint64_t v61 = 0;
              double v33 = -v33;
              uint64_t v62 = v52;
              do
              {
                *(double *)v20.i64 = *(double *)(v51 + v61) * v33;
                *(void *)(v50 + v61) = v20.i64[0];
                v61 += v18 * 8;
                --v62;
              }
              while (v62);
            }
            uint64_t v53 = v48 - 1;
            ++v49;
            ++v52;
            v50 += v79;
            v51 += v79;
          }
          while (v49 != v73);
        }
        unsigned int v63 = v75;
        uint64_t v36 = (uint64_t)v76;
        *int v75 = 1.0;
        int v32 = v72;
        int v64 = v70;
        uint64_t v65 = 1;
        uint64_t v66 = a1;
        do
        {
          v75[v66] = 0.0;
          v75[v65++] = 0.0;
          v66 += a1;
        }
        while (a1 != v65);
      }
      uint64_t v80 = a1;
      uint64_t v81 = 0;
      int v67 = sub_1000072D0(&v80, &v80, &v80, v32, v82, v63, &v80, v36, v33, v20, v21, v22, v23, v24, v25, v26, &v80, (uint64_t)v64, &v81);
      return (v67 | v81) != 0;
    }
  }
}

uint64_t sub_1000070BC(uint64_t result, double *a2, uint64_t a3, int8x16_t a4, double a5, int8x16_t a6)
{
  if (result < 2) {
    goto LABEL_5;
  }
  uint64_t v6 = result - 1;
  uint64_t v7 = 8 * a3;
  a4.i64[0] = 0;
  uint64_t v8 = 8 * a3;
  uint64_t v9 = result - 1;
  do
  {
    *(double *)a4.i64 = *(double *)a4.i64 + *(double *)((char *)a2 + v8) * *(double *)((char *)a2 + v8);
    v8 += v7;
    --v9;
  }
  while (v9);
  if (*(double *)a4.i64 == 0.0)
  {
LABEL_5:
    *a2 = 0.0;
  }
  else
  {
    double v10 = *a2;
    *(double *)a4.i64 = sqrt(*(double *)a4.i64 + v10 * v10);
    *(double *)a6.i64 = -*a2;
    v11.f64[0] = NAN;
    v11.f64[1] = NAN;
    double v12 = *(double *)vbslq_s8((int8x16_t)vnegq_f64(v11), a4, a6).i64;
    *a2 = (v12 - *a2) / v12;
    os_log_t v13 = &a2[a3];
    double v14 = 1.0 / (v10 - v12);
    do
    {
      *os_log_t v13 = v14 * *v13;
      os_log_t v13 = (double *)((char *)v13 + v7);
      --v6;
    }
    while (v6);
  }
  return result;
}

uint64_t sub_10000715C(uint64_t result, uint64_t a2, uint64_t a3, double *a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  if (a2 >= 2 && a3 >= 1 && *a4 != 0.0)
  {
    if (result)
    {
      uint64_t v7 = 0;
      uint64_t v8 = 8 * a5;
      uint64_t v9 = a6;
      do
      {
        uint64_t v10 = 8 * a5;
        uint64_t v11 = 1;
        double v12 = *(double *)(a6 + 8 * v7 * a7);
        do
        {
          double v12 = v12 + *(double *)((char *)a4 + v10) * *(double *)(v9 + 8 * v11++);
          v10 += v8;
        }
        while (a2 != v11);
        double v13 = v12 * *a4;
        *(double *)(a6 + 8 * v7 * a7) = *(double *)(a6 + 8 * v7 * a7) - v13;
        double v14 = &a4[a5];
        for (uint64_t i = 1; i != a2; ++i)
        {
          *(double *)(v9 + 8 * i) = *(double *)(v9 + 8 * i) + -v13 * *v14;
          double v14 = (double *)((char *)v14 + v8);
        }
        ++v7;
        v9 += 8 * a7;
      }
      while (v7 != a3);
    }
    else
    {
      uint64_t v16 = 0;
      uint64_t v17 = 8 * a7;
      uint64_t v18 = (double *)(a6 + 8 * a7);
      uint64_t v19 = 8 * a5;
      do
      {
        double v20 = *(double *)(a6 + 8 * v16);
        if ((unint64_t)a3 < 2)
        {
          *(double *)(a6 + 8 * v16) = v20 - v20 * *a4;
        }
        else
        {
          uint64_t v21 = 8 * a5;
          int8x16_t v22 = v18;
          uint64_t v23 = 1;
          double v24 = *(double *)(a6 + 8 * v16);
          do
          {
            double v24 = v24 + *(double *)((char *)a4 + v21) * *v22;
            ++v23;
            int8x16_t v22 = (double *)((char *)v22 + v17);
            v21 += v19;
          }
          while (a3 != v23);
          double v25 = v24 * *a4;
          *(double *)(a6 + 8 * v16) = v20 - v25;
          uint64_t v26 = 0;
          double v27 = &a4[a5];
          uint64_t v28 = a3 - 1;
          do
          {
            *(double *)((char *)v18 + v26) = *(double *)((char *)v18 + v26) + -v25 * *v27;
            v26 += v17;
            double v27 = (double *)((char *)v27 + v19);
            --v28;
          }
          while (v28);
        }
        ++v16;
        ++v18;
      }
      while (v16 != a2);
    }
  }
  return result;
}

uint64_t sub_1000072D0(uint64_t *a1, uint64_t *a2, uint64_t *a3, double *a4, double *a5, double *a6, uint64_t *a7, uint64_t a8, double a9, int8x16_t a10, int8x16_t a11, int8x16_t a12, int8x16_t a13, __n128 a14, __n128 a15, int8x16_t a16, uint64_t *a17, uint64_t a18, void *a19)
{
  double v266 = 0.0;
  v267[0] = 0;
  uint64_t v21 = *a7;
  uint64_t v22 = *a17;
  double v264 = 0.0;
  double v265 = 0.0;
  unint64_t v262 = 0;
  uint64_t v263 = 0;
  double v260 = 0.0;
  *(double *)&uint64_t v261 = 0.0;
  double v258 = 0.0;
  uint64_t v259 = 0;
  uint64_t v257 = 0;
  *a19 = 0;
  uint64_t v23 = *a1;
  if (!*a1) {
    return 0;
  }
  double v24 = a7;
  double v27 = a4 - 1;
  uint64_t v28 = v23 - 1;
  if (v23 == 1) {
    goto LABEL_18;
  }
  double v29 = a5;
  double v30 = fabs(*a4);
  if (*a4 != 0.0)
  {
    uint64_t v31 = v23 - 2;
    if (v23 >= 2)
    {
      int v32 = a4 + 1;
      double v33 = a5;
      double v34 = v30;
      do
      {
        double v35 = *v32++;
        double v36 = fabs(v35);
        double v37 = *v33++;
        *(double *)a12.i64 = v34 + fabs(v37);
        double v34 = v36 * (v34 / *(double *)a12.i64);
        if (v30 >= v34) {
          double v30 = v34;
        }
        BOOL v38 = v30 == 0.0 || v31-- == 0;
      }
      while (!v38);
    }
  }
  double v39 = v30 / sqrt((double)v23) * 9.99200722e-15;
  uint64_t v237 = 6 * v23 * v23;
  a11.i64[0] = 0x8000000000000;
  if (v39 <= (double)v237 * COERCE_DOUBLE(0x8000000000000)) {
    double v40 = (double)v237 * COERCE_DOUBLE(0x8000000000000);
  }
  else {
    double v40 = v39;
  }
  if (v23 <= 1) {
    goto LABEL_17;
  }
  uint64_t v69 = 0;
  uint64_t v70 = 0;
  v204 = &a6[~v21];
  uint64_t v223 = a8 + 8 * ~v22;
  v238 = a5 - 1;
  uint64_t v219 = a18 - 8 + ((16 * v28) | 8);
  uint64_t v220 = a18 - 8;
  v222 = a5 - 2;
  uint64_t v71 = a4 + 1;
  uint64_t v211 = a18 + 24 * v23 - 40;
  uint64_t v210 = a18 + 16 * v23 - 32;
  uint64_t v251 = a18 + 8 * v23 - 8;
  uint64_t v216 = 8 * v23;
  v203 = a5 + 1;
  uint64_t v72 = -1;
  uint64_t v218 = a18 + 24 * v28;
  v73.f64[0] = NAN;
  v73.f64[1] = NAN;
  float64x2_t v74 = vnegq_f64(v73);
  int8x16_t v206 = (int8x16_t)v74;
  uint64_t v208 = a18 - 16;
  uint64_t v209 = a18 - 24;
  double v217 = 0.0;
  uint64_t v249 = a18 - 16 + 16 * v23;
  uint64_t v250 = a18 - 24 + 24 * v23;
  double v75 = 0.0;
  double v76 = 0.0;
  double v77 = 0.0;
  double v78 = 0.0;
  a15.n128_u64[0] = 0;
  a14.n128_u64[0] = 0;
  uint64_t v79 = -1;
  uint64_t v221 = v22;
  v229 = a4 - 1;
  v207 = a3;
  v214 = a2;
  v239 = a1;
  uint64_t v205 = v21;
  while (2)
  {
    BOOL v80 = v69 > v237;
    if (v69 <= v237)
    {
      uint64_t v81 = v23 - 1;
      int v82 = &v229[v23];
      int v83 = &v238[v23 - 1];
      v215 = &v229[v23 - 1];
      uint64_t v213 = v23;
      unsigned int v84 = &v222[v23];
      uint64_t v85 = (uint64_t)&a4[v23 - 2];
      v231 = v82;
      uint64_t v232 = v23 - 2;
      uint64_t v86 = v72;
      uint64_t v252 = v216 + 8 * v23;
      uint64_t v254 = v23;
      v233 = v83;
      uint64_t v224 = v85;
      v225 = v84;
LABEL_47:
      uint64_t v72 = v86;
      while (2)
      {
        uint64_t v87 = 0;
        v74.f64[0] = fabs(*v82);
        while (1)
        {
          *(double *)a10.i64 = fabs(v84[v87]);
          if (*(double *)a10.i64 <= v40) {
            break;
          }
          *(double *)a11.i64 = fabs(*(double *)(v85 + 8 * v87));
          if (v74.f64[0] <= *(double *)a11.i64) {
            v74.f64[0] = *(double *)a11.i64;
          }
          if (v74.f64[0] <= *(double *)a10.i64) {
            v74.f64[0] = *(double *)a10.i64;
          }
          --v87;
          if (!(v81 + v87))
          {
            uint64_t v88 = 0;
            goto LABEL_58;
          }
        }
        v84[v87] = 0.0;
        if (v87)
        {
          uint64_t v88 = v81 + v87;
LABEL_58:
          uint64_t v86 = v88 + 1;
          if (v88 + 1 != v81)
          {
            if (v88 >= v79 || v23 < v72)
            {
              *(double *)a16.i64 = a4[v88];
              double v90 = fabs(*(double *)a16.i64);
              v19.i64[0] = *(uint64_t *)v82;
              double v89 = fabs(*v82);
              if (v90 >= v89) {
                goto LABEL_65;
              }
              uint64_t v70 = 2;
            }
            else
            {
              if (v70 == 1)
              {
                v19.i64[0] = *(uint64_t *)v82;
                double v89 = fabs(*v82);
LABEL_65:
                *(double *)a11.i64 = v89 * 9.99200722e-15;
                if (fabs(*v83) > *(double *)a11.i64)
                {
                  *(double *)a16.i64 = a4[v88];
                  double v91 = fabs(*(double *)a16.i64);
                  if (v23 > v86)
                  {
                    uint64_t v92 = v88;
                    *(double *)a11.i64 = v91;
                    while (1)
                    {
                      *(double *)a12.i64 = fabs(v29[v92]);
                      *(double *)a13.i64 = *(double *)a11.i64 * 9.99200722e-15;
                      if (*(double *)a12.i64 <= *(double *)a11.i64 * 9.99200722e-15) {
                        break;
                      }
                      *(double *)a11.i64 = *(double *)a11.i64
                                         / (*(double *)a11.i64 + *(double *)a12.i64)
                                         * fabs(v71[v92]);
                      if (v91 >= *(double *)a11.i64) {
                        double v91 = *(double *)a11.i64;
                      }
                      if (v81 == ++v92)
                      {
                        v267[0] = v81;
                        uint64_t v70 = 1;
                        int v97 = 1;
                        goto LABEL_91;
                      }
                    }
                    uint64_t v96 = v92 + 1;
                    uint64_t v70 = 1;
                    goto LABEL_88;
                  }
                  v267[0] = v81;
                  int v97 = 1;
                  uint64_t v70 = 1;
                  goto LABEL_91;
                }
                unint64_t v93 = v83;
                uint64_t v70 = 1;
                goto LABEL_84;
              }
              *(double *)a16.i64 = a4[v88];
              double v90 = fabs(*(double *)a16.i64);
            }
            unint64_t v93 = &v29[v88];
            *(double *)a11.i64 = fabs(*v93);
            if (*(double *)a11.i64 > v90 * 9.99200722e-15)
            {
              v19.i64[0] = *(uint64_t *)v82;
              double v91 = fabs(*v82);
              if (v81 > v88)
              {
                uint64_t v94 = v232;
                *(double *)a11.i64 = v91;
                while (1)
                {
                  *(double *)a12.i64 = fabs(v29[v94]);
                  *(double *)a13.i64 = *(double *)a11.i64 * 9.99200722e-15;
                  if (*(double *)a12.i64 <= *(double *)a11.i64 * 9.99200722e-15) {
                    break;
                  }
                  *(double *)a11.i64 = *(double *)a11.i64 / (*(double *)a11.i64 + *(double *)a12.i64) * fabs(a4[v94]);
                  if (v91 >= *(double *)a11.i64) {
                    double v91 = *(double *)a11.i64;
                  }
                  if (v94-- <= v88) {
                    goto LABEL_90;
                  }
                }
                uint64_t v96 = v94 + 1;
LABEL_88:
                v238[v96] = 0.0;
                if (!v80) {
                  continue;
                }
                goto LABEL_242;
              }
LABEL_90:
              int v97 = 0;
              v267[0] = v88 + 1;
LABEL_91:
              uint64_t v98 = *v239;
              uint64_t v99 = ~v88;
              __n128 v241 = a15;
              __n128 v243 = a14;
              uint64_t v240 = v88 + 1;
              uint64_t v245 = v88;
              if (v91 / v74.f64[0] * ((double)*v239 * 9.99200722e-15) <= 1.11022302e-16) {
                goto LABEL_97;
              }
              int8x16_t v226 = a16;
              int8x16_t v246 = v19;
              if (v97)
              {
                double v100 = fabs(*(double *)a16.i64);
                unsigned int v101 = a3;
                uint64_t v102 = v69;
                uint64_t v103 = *v239;
                sub_1000088E4(&v260, &v266, *v215, *v83, *(double *)v19.i64);
                int8x16_t v19 = v246;
                a16 = v226;
                uint64_t v98 = v103;
                int v105 = a4 + 1;
                int v83 = v233;
                __n128 v107 = v241;
                __n128 v106 = v243;
                uint64_t v69 = v102;
                uint64_t v86 = v240;
                int v82 = v231;
                a3 = v101;
                double v24 = a7;
              }
              else
              {
                double v100 = fabs(*(double *)v19.i64);
                int v108 = v24;
                unint64_t v109 = a3;
                uint64_t v110 = v69;
                uint64_t v111 = *v239;
                sub_1000088E4(&v260, &v266, *(double *)a16.i64, a5[v88], v229[v88 + 2]);
                int8x16_t v19 = v246;
                a16 = v226;
                uint64_t v98 = v111;
                int v105 = a4 + 1;
                int v83 = v233;
                __n128 v107 = v241;
                __n128 v106 = v243;
                uint64_t v69 = v110;
                uint64_t v86 = v240;
                int v82 = v231;
                a3 = v109;
                double v24 = v108;
                a2 = v214;
              }
              uint64_t v23 = v254;
              if (v100 <= 0.0 || v260 / v100 * (v260 / v100) >= 1.11022302e-16)
              {
                uint64_t v112 = v69 + v254 + v99;
                if (v260 != 0.0)
                {
                  double v147 = v266;
                  if (v97)
                  {
                    v104.i64[0] = 1.0;
                    double v148 = (fabs(*(double *)a16.i64) - v260)
                         * (*(double *)vbslq_s8(v206, v104, a16).i64 + v260 / *(double *)a16.i64);
                    uint64_t v149 = v254 - v86;
                    double v29 = a5;
                    if (v254 > v86)
                    {
                      unint64_t v150 = 0;
                      double v151 = a5[v245];
                      v152 = &v203[v245];
                      uint64_t v153 = v86;
                      v154 = &v105[v245];
                      do
                      {
                        if (v151 == 0.0)
                        {
                          v106.n128_u64[0] = 1.0;
                          v107.n128_u64[0] = 0;
                        }
                        else if (v148 == 0.0)
                        {
                          v106.n128_u64[0] = 0;
                          v107.n128_u64[0] = 1.0;
                          double v148 = v151;
                        }
                        else
                        {
                          double v155 = sqrt(v151 * v151 + v148 * v148);
                          BOOL v156 = fabs(v148) > fabs(v151);
                          BOOL v157 = v148 / v155 < 0.0;
                          if (v156 && v157) {
                            v107.n128_f64[0] = -(v151 / v155);
                          }
                          else {
                            v107.n128_f64[0] = v151 / v155;
                          }
                          if (v156 && v157) {
                            v106.n128_f64[0] = -(v148 / v155);
                          }
                          else {
                            v106.n128_f64[0] = v148 / v155;
                          }
                          if (v156 && v157) {
                            double v148 = -v155;
                          }
                          else {
                            double v148 = v155;
                          }
                          if ((*(void *)&v148 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL) {
                            return 0xFFFFFFFFLL;
                          }
                        }
                        if (v153 > v86) {
                          v152[v150 - 2] = v148;
                        }
                        double v158 = v154[v150 - 1];
                        double v159 = v152[v150 - 1];
                        double v147 = v107.n128_f64[0] * v159 + v106.n128_f64[0] * v158;
                        v152[v150 - 1] = v106.n128_f64[0] * v159 - v107.n128_f64[0] * v158;
                        double v160 = v154[v150];
                        double v151 = v107.n128_f64[0] * v160;
                        double v161 = v106.n128_f64[0] * v160;
                        v154[v150] = v161;
                        if (v151 == 0.0)
                        {
                          double v78 = 1.0;
                          double v77 = 0.0;
                        }
                        else if (v147 == 0.0)
                        {
                          double v78 = 0.0;
                          double v77 = 1.0;
                          double v147 = v151;
                        }
                        else
                        {
                          double v162 = sqrt(v151 * v151 + v147 * v147);
                          BOOL v163 = fabs(v147) > fabs(v151);
                          BOOL v164 = v147 / v162 < 0.0;
                          if (v163 && v164) {
                            double v77 = -(v151 / v162);
                          }
                          else {
                            double v77 = v151 / v162;
                          }
                          if (v163 && v164) {
                            double v78 = -(v147 / v162);
                          }
                          else {
                            double v78 = v147 / v162;
                          }
                          if (v163 && v164) {
                            double v147 = -v162;
                          }
                          else {
                            double v147 = v162;
                          }
                          if ((*(void *)&v147 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL) {
                            return 0xFFFFFFFFLL;
                          }
                        }
                        v154[v150 - 1] = v147;
                        double v165 = v152[v150 - 1];
                        v154[v150] = v78 * v161 - v77 * v165;
                        if (v153 < v81)
                        {
                          double v166 = v152[v150];
                          double v151 = v77 * v166;
                          v152[v150] = v78 * v166;
                        }
                        ++v153;
                        double v148 = v161 * v77 + v78 * v165;
                        *(void *)(a18 + v150 * 8) = v106.n128_u64[0];
                        *(void *)(v251 + v150 * 8) = v107.n128_u64[0];
                        *(double *)(v249 + v150 * 8) = v78;
                        *(double *)(v250 + v150 * 8) = v77;
                        ++v150;
                      }
                      while (v254 != v153);
                    }
                    __n128 v241 = v107;
                    __n128 v243 = v106;
                    uint64_t v227 = v70;
                    uint64_t v234 = v112;
                    double v266 = v147;
                    *int v83 = v148;
                    uint64_t v167 = v149 + 1;
                    v267[0] = v149 + 1;
                    sub_100008A7C("L", "F", v267, a2, a18, v220 + 8 * v98, &a6[v245], v24);
                    v267[0] = v167;
                    uint64_t v22 = v221;
                    sub_100008A7C("R", "F", a3, v267, v219, v218, (double *)(v223 + 8 * v86 * v221 + 8), a17);
                    int v83 = v233;
                    if (fabs(*v233) <= v40) {
                      double *v233 = 0.0;
                    }
LABEL_127:
                    uint64_t v23 = v254;
                    uint64_t v69 = v234;
                    uint64_t v71 = a4 + 1;
                    unsigned int v84 = v225;
                    uint64_t v70 = v227;
                    a15 = v241;
                    a14 = v243;
                    uint64_t v85 = v224;
                    uint64_t v86 = v240;
                    goto LABEL_152;
                  }
                  v104.i64[0] = 1.0;
                  double v168 = (fabs(*(double *)v19.i64) - v260)
                       * (*(double *)vbslq_s8(v206, v104, v19).i64 + v260 / *(double *)v19.i64);
                  uint64_t v169 = v245 + 2;
                  double v29 = a5;
                  if (v254 >= v245 + 2)
                  {
                    double v170 = *v83;
                    uint64_t v171 = v211 - 8 * v245;
                    uint64_t v172 = v210 - 8 * v245;
                    uint64_t v173 = v209 - 8 * v245;
                    v174 = v222;
                    v175 = a4 - 2;
                    uint64_t v176 = v254;
                    uint64_t v177 = v208 - 8 * v245;
                    do
                    {
                      if (v170 == 0.0)
                      {
                        v106.n128_u64[0] = 1.0;
                        v107.n128_u64[0] = 0;
                      }
                      else if (v168 == 0.0)
                      {
                        v106.n128_u64[0] = 0;
                        v107.n128_u64[0] = 1.0;
                        double v168 = v170;
                      }
                      else
                      {
                        double v178 = sqrt(v170 * v170 + v168 * v168);
                        BOOL v179 = fabs(v168) > fabs(v170);
                        BOOL v180 = v168 / v178 < 0.0;
                        if (v179 && v180) {
                          v107.n128_f64[0] = -(v170 / v178);
                        }
                        else {
                          v107.n128_f64[0] = v170 / v178;
                        }
                        if (v179 && v180) {
                          v106.n128_f64[0] = -(v168 / v178);
                        }
                        else {
                          v106.n128_f64[0] = v168 / v178;
                        }
                        if (v179 && v180) {
                          double v168 = -v178;
                        }
                        else {
                          double v168 = v178;
                        }
                        if ((*(void *)&v168 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL) {
                          return 0xFFFFFFFFLL;
                        }
                      }
                      if (v176 < v254) {
                        v174[v213 + 1] = v168;
                      }
                      double v181 = v174[v213];
                      double v182 = v175[v213 + 1];
                      v174[v213] = v106.n128_f64[0] * v181 - v107.n128_f64[0] * v182;
                      double v147 = v107.n128_f64[0] * v181 + v106.n128_f64[0] * v182;
                      double v183 = v175[v213];
                      double v170 = v107.n128_f64[0] * v183;
                      double v184 = v106.n128_f64[0] * v183;
                      v175[v213] = v184;
                      if (v170 == 0.0)
                      {
                        double v78 = 1.0;
                        double v77 = 0.0;
                      }
                      else if (v147 == 0.0)
                      {
                        double v78 = 0.0;
                        double v77 = 1.0;
                        double v147 = v170;
                      }
                      else
                      {
                        double v185 = sqrt(v170 * v170 + v147 * v147);
                        BOOL v186 = fabs(v147) > fabs(v170);
                        BOOL v187 = v147 / v185 < 0.0;
                        if (v186 && v187) {
                          double v77 = -(v170 / v185);
                        }
                        else {
                          double v77 = v170 / v185;
                        }
                        if (v186 && v187) {
                          double v78 = -(v147 / v185);
                        }
                        else {
                          double v78 = v147 / v185;
                        }
                        if (v186 && v187) {
                          double v147 = -v185;
                        }
                        else {
                          double v147 = v185;
                        }
                        if ((*(void *)&v147 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL) {
                          return 0xFFFFFFFFLL;
                        }
                      }
                      v175[v213 + 1] = v147;
                      double v188 = v174[v213];
                      v175[v213] = v78 * v184 - v77 * v188;
                      if (v176 > v169)
                      {
                        double v189 = v174[v213 - 1];
                        double v170 = v77 * v189;
                        v174[v213 - 1] = v78 * v189;
                      }
                      --v176;
                      *(void *)(v177 + v213 * 8) = v106.n128_u64[0];
                      *(double *)(v173 + v252) = -v107.n128_f64[0];
                      *(double *)(v172 + v213 * 8) = v78;
                      *(double *)(v171 + v213 * 8) = -v77;
                      double v168 = v184 * v77 + v78 * v188;
                      v171 -= 8;
                      v172 -= 8;
                      v173 -= 8;
                      v177 -= 8;
                      --v175;
                      --v174;
                    }
                    while (v176 + 1 > v169);
                  }
                  __n128 v242 = v107;
                  __n128 v244 = v106;
                  double v266 = v147;
                  double v190 = 0.0;
                  if (fabs(v168) > v40) {
                    double v190 = v168;
                  }
                  a5[v245] = v190;
                  v267[0] = v254 - v86 + 1;
                  uint64_t v235 = v112;
                  sub_100008A7C("L", "B", v267, a2, v219, v218, &a6[v245], v24);
                  v267[0] = v254 - v86 + 1;
                  uint64_t v22 = v221;
                  int v82 = v231;
                  sub_100008A7C("R", "B", a3, v267, a18, v220 + 8 * *v239, (double *)(v223 + 8 * v86 * v221 + 8), a17);
                  uint64_t v71 = a4 + 1;
                  int v83 = v233;
                  a15 = v242;
                  a14 = v244;
                  uint64_t v69 = v235;
                  uint64_t v23 = v254;
LABEL_151:
                  uint64_t v85 = v224;
                  unsigned int v84 = v225;
LABEL_152:
                  uint64_t v79 = v23;
                  BOOL v80 = v69 > v237;
                  if (v69 <= v237) {
                    goto LABEL_47;
                  }
                  goto LABEL_242;
                }
              }
              else
              {
LABEL_97:
                double v260 = 0.0;
                uint64_t v112 = v69 + v23 + v99;
              }
              *(double *)&uint64_t v261 = 1.0;
              uint64_t v234 = v112;
              if (v97)
              {
                uint64_t v113 = v23 - v86;
                if (v23 > v86)
                {
                  uint64_t v247 = v23 - v86;
                  unint64_t v114 = 0;
                  v115 = &v238[v245];
                  double v116 = 1.0;
                  uint64_t v117 = v86;
                  double v118 = 1.0;
                  v119 = &a4[v245];
                  while (1)
                  {
                    double v120 = v118 * v119[v114];
                    double v121 = v115[v114 + 1];
                    double v122 = 0.0;
                    if (v121 == 0.0)
                    {
                      double v121 = v118 * v119[v114];
                      double v118 = 1.0;
                    }
                    else if (v120 == 0.0)
                    {
                      double v118 = 0.0;
                      double v122 = 1.0;
                    }
                    else
                    {
                      double v123 = sqrt(v121 * v121 + v120 * v120);
                      double v124 = v121 / v123;
                      BOOL v125 = fabs(v120) > fabs(v121);
                      BOOL v126 = v120 / v123 < 0.0;
                      if (v125 && v126) {
                        double v121 = -v123;
                      }
                      else {
                        double v121 = v123;
                      }
                      if (v125 && v126) {
                        double v118 = -(v120 / v123);
                      }
                      else {
                        double v118 = v120 / v123;
                      }
                      if (v125 && v126) {
                        double v122 = -v124;
                      }
                      else {
                        double v122 = v124;
                      }
                      if ((*(void *)&v121 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL) {
                        return 0xFFFFFFFFLL;
                      }
                    }
                    if (v117 > v86) {
                      v115[v114] = v75 * v121;
                    }
                    if (sub_1000089C0((double *)&v261, &v258, &v119[v114], v116 * v121, v122 * v119[v114 + 1])) {
                      return 0xFFFFFFFFLL;
                    }
                    *(double *)(a18 + v114 * 8) = v118;
                    *(double *)(v251 + v114 * 8) = v122;
                    double v116 = *(double *)&v261;
                    *(double *)(v249 + v114 * 8) = *(double *)&v261;
                    ++v117;
                    double v75 = v258;
                    *(double *)(v250 + v114 * 8) = v258;
                    ++v114;
                    if (v254 == v117)
                    {
                      uint64_t v227 = v70;
                      v19.i64[0] = *(uint64_t *)v82;
                      uint64_t v98 = *v239;
                      double v76 = v75;
                      a3 = v207;
                      a2 = v214;
                      double v29 = a5;
                      int v83 = v233;
                      uint64_t v127 = v245;
                      uint64_t v113 = v247;
                      goto LABEL_124;
                    }
                  }
                }
                uint64_t v227 = v70;
                double v121 = v266;
                double v116 = 1.0;
                double v118 = 1.0;
                double v29 = a5;
                double v76 = v217;
                uint64_t v127 = v245;
LABEL_124:
                double v266 = v121;
                *int v82 = v118 * *(double *)v19.i64 * v116;
                *int v83 = v118 * *(double *)v19.i64 * v76;
                uint64_t v132 = v113 + 1;
                v267[0] = v113 + 1;
                sub_100008A7C("L", "F", v267, a2, a18, v220 + 8 * v98, &a6[v127], v24);
                v267[0] = v132;
                uint64_t v22 = v221;
                sub_100008A7C("R", "F", a3, v267, v219, v218, (double *)(v223 + 8 * v240 * v221 + 8), a17);
                int v83 = v233;
                double v217 = v76;
                if (fabs(*v233) <= v40) {
                  double *v233 = 0.0;
                }
                double v75 = v76;
                goto LABEL_127;
              }
              uint64_t v128 = v245;
              if (v23 >= v245 + 2)
              {
                uint64_t v133 = v211 - 8 * v245;
                uint64_t v134 = v210 - 8 * v245;
                double v130 = 1.0;
                uint64_t v135 = v209 - 8 * v245;
                v136 = v222;
                v137 = a4;
                uint64_t v138 = v23;
                double v131 = 1.0;
                uint64_t v139 = v208 - 8 * v245;
                while (1)
                {
                  double v140 = v131 * v137[v213 - 1];
                  double v129 = v136[v23];
                  double v141 = 0.0;
                  if (v129 == 0.0)
                  {
                    double v129 = v131 * v137[v213 - 1];
                    double v131 = 1.0;
                  }
                  else if (v140 == 0.0)
                  {
                    double v131 = 0.0;
                    double v141 = 1.0;
                  }
                  else
                  {
                    double v142 = sqrt(v129 * v129 + v140 * v140);
                    double v143 = v129 / v142;
                    BOOL v144 = fabs(v140) > fabs(v129);
                    BOOL v145 = v140 / v142 < 0.0;
                    if (v144 && v145) {
                      double v129 = -v142;
                    }
                    else {
                      double v129 = v142;
                    }
                    if (v144 && v145) {
                      double v131 = -(v140 / v142);
                    }
                    else {
                      double v131 = v140 / v142;
                    }
                    if (v144 && v145) {
                      double v141 = -v143;
                    }
                    else {
                      double v141 = v143;
                    }
                    if ((*(void *)&v129 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL) {
                      return 0xFFFFFFFFLL;
                    }
                  }
                  if (v138 < v23) {
                    v136[v213 + 1] = v76 * v129;
                  }
                  if (sub_1000089C0((double *)&v261, &v258, &v137[v213 - 1], v130 * v129, v141 * v137[v213 - 2])) {
                    return 0xFFFFFFFFLL;
                  }
                  --v138;
                  *(double *)(v139 + v213 * 8) = v131;
                  *(double *)(v135 + v252) = -v141;
                  double v130 = *(double *)&v261;
                  *(double *)(v134 + v213 * 8) = *(double *)&v261;
                  double v76 = v258;
                  *(double *)(v133 + v213 * 8) = -v258;
                  v133 -= 8;
                  v134 -= 8;
                  v135 -= 8;
                  v139 -= 8;
                  --v137;
                  --v136;
                  uint64_t v23 = v254;
                  if (v138 + 1 <= v245 + 2)
                  {
                    uint64_t v128 = v245;
                    *(double *)a16.i64 = a4[v245];
                    double v217 = v76;
                    double v75 = v76;
                    double v24 = a7;
                    a3 = v207;
                    a2 = v214;
                    double v29 = a5;
                    uint64_t v86 = v240;
                    goto LABEL_148;
                  }
                }
              }
              double v129 = v266;
              double v130 = 1.0;
              double v131 = 1.0;
              double v29 = a5;
LABEL_148:
              double v266 = v129;
              a4[v128] = v131 * *(double *)a16.i64 * v130;
              v29[v128] = v131 * *(double *)a16.i64 * v75;
              uint64_t v146 = v23 - v86 + 1;
              v267[0] = v146;
              sub_100008A7C("L", "B", v267, a2, v219, v218, &a6[v128], v24);
              v267[0] = v146;
              uint64_t v22 = v221;
              sub_100008A7C("R", "B", a3, v267, a18, v220 + 8 * *v239, (double *)(v223 + 8 * v86 * v221 + 8), a17);
              if (fabs(v29[v245]) <= v40) {
                v29[v245] = 0.0;
              }
              double v76 = v75;
              uint64_t v23 = v254;
              int v83 = v233;
              uint64_t v69 = v234;
              uint64_t v71 = a4 + 1;
              a15 = v241;
              a14 = v243;
              int v82 = v231;
              goto LABEL_151;
            }
LABEL_84:
            *unint64_t v93 = 0.0;
            if (!v80) {
              continue;
            }
            goto LABEL_242;
          }
          uint64_t v248 = v79;
          uint64_t v253 = v72;
          uint64_t v228 = v70;
          uint64_t v236 = v69;
          unint64_t v262 = a15.n128_u64[0];
          uint64_t v263 = a14.n128_u64[0];
          double v264 = v77;
          double v265 = v78;
          v267[0] = v81;
          v191 = v83;
          sub_10000868C(v215, (unint64_t *)v83, v82, (double *)&v259, (double *)&v257, &v262, (double *)&v263, &v264, (int8x16_t)v74, a10, a11, a12, a13, a14.n128_f64[0], a15.n128_f64[0], a16, (unint64_t *)&v265);
          *(void *)v215 = v257;
          double *v191 = 0.0;
          *(void *)int v82 = v259;
          uint64_t v192 = *a2;
          a15.n128_u64[0] = v262;
          a14.n128_u64[0] = v263;
          if (*a2 >= 1)
          {
            v193 = (int8x16_t *)&v204[v81 + v205];
            float64x2_t v74 = (float64x2_t)vdupq_lane_s64(v263, 0);
            uint64_t v194 = 8 * *v24;
            do
            {
              a10 = *v193;
              a12.i64[1] = v193->i64[1];
              *(double *)a12.i64 = -*(double *)v193->i64;
              int8x16_t v195 = (int8x16_t)vmulq_n_f64((float64x2_t)a12, a15.n128_f64[0]);
              a11 = (int8x16_t)vmlaq_f64((float64x2_t)vextq_s8(v195, v195, 8uLL), *(float64x2_t *)v193, v74);
              int8x16_t *v193 = a11;
              v193 = (int8x16_t *)((char *)v193 + v194);
              --v192;
            }
            while (v192);
          }
          uint64_t v196 = *a3;
          double v77 = v264;
          double v78 = v265;
          double v27 = a4 - 1;
          a1 = v239;
          uint64_t v69 = v236;
          uint64_t v71 = a4 + 1;
          if (*a3 >= 1)
          {
            v197 = (double *)(v223 + 8 * v81 * v22 + 8);
            v198 = (double *)(v223 + 8 * v254 * v22 + 8);
            do
            {
              double v199 = *v197;
              double v200 = *v198;
              *(double *)a11.i64 = v77 * *v198 + v78 * *v197;
              *v197++ = *(double *)a11.i64;
              *v198++ = v78 * v200 - v199 * v77;
              --v196;
            }
            while (v196);
          }
          uint64_t v81 = v232;
          uint64_t v70 = v228;
          uint64_t v72 = v253;
          uint64_t v79 = v248;
        }
        else
        {
          unint64_t v262 = a15.n128_u64[0];
          uint64_t v263 = a14.n128_u64[0];
          double v264 = v77;
          double v265 = v78;
          v267[0] = v81;
          double v27 = a4 - 1;
          a1 = v239;
        }
        break;
      }
      uint64_t v23 = v81;
      if (v81 > 1) {
        continue;
      }
LABEL_17:
      uint64_t v23 = *a1;
      if (*a1 >= 1)
      {
LABEL_18:
        uint64_t v41 = 1;
        uint64_t v42 = a6;
        do
        {
          double v43 = v27[v41];
          if (v43 < 0.0)
          {
            v27[v41] = -v43;
            uint64_t v44 = *a2;
            if (*a2 >= 1)
            {
              uint64_t v45 = 8 * *v24;
              uint64_t v46 = v42;
              do
              {
                *uint64_t v46 = -*v46;
                uint64_t v46 = (double *)((char *)v46 + v45);
                --v44;
              }
              while (v44);
            }
          }
          ++v42;
          BOOL v38 = v41++ == v23;
        }
        while (!v38);
        if (v23 >= 2)
        {
          uint64_t v47 = v23 + 1;
          uint64_t v48 = 8 * v23 - 8;
          uint64_t v49 = (uint64_t *)(a8 + v22 * v48);
          uint64_t v50 = 1;
          uint64_t v51 = v23;
          do
          {
            double v52 = *a4;
            uint64_t v53 = v47 - v50;
            if (v47 - v50 >= 2)
            {
              uint64_t v55 = 1;
              uint64_t v54 = 1;
              do
              {
                double v56 = a4[v55];
                if (v56 <= v52) {
                  uint64_t v54 = v55 + 1;
                }
                uint64_t v57 = v55 + 1;
                if (v56 <= v52) {
                  double v52 = a4[v55];
                }
                ++v55;
              }
              while (v51 != v57);
            }
            else
            {
              uint64_t v54 = 1;
            }
            if (v54 != v53)
            {
              v27[v54] = v27[v53];
              v27[v53] = v52;
              uint64_t v58 = *a2;
              uint64_t v59 = 8 * v54;
              if (*a2 >= 1)
              {
                uint64_t v60 = 8 * *v24;
                uint64_t v61 = v59 - 8;
                uint64_t v62 = a6;
                do
                {
                  uint64_t v63 = *(void *)((char *)v62 + v61);
                  *(double *)((char *)v62 + v61) = *(double *)((char *)v62 + v48);
                  *(void *)((char *)v62 + v48) = v63;
                  uint64_t v62 = (double *)((char *)v62 + v60);
                  --v58;
                }
                while (v58);
              }
              uint64_t v64 = *a3;
              if (*a3 >= 1)
              {
                uint64_t v65 = (uint64_t *)(a8 + v22 * (v59 - 8));
                uint64_t v66 = v49;
                do
                {
                  uint64_t v67 = *v65;
                  *v65++ = *v66;
                  *v66++ = v67;
                  --v64;
                }
                while (v64);
              }
            }
            ++v50;
            --v51;
            v48 -= 8;
            v49 -= v22;
          }
          while (v50 != v23);
        }
      }
      return 0;
    }
    break;
  }
LABEL_242:
  *a19 = 0;
  if (*v239 < 2) {
    return 0;
  }
  uint64_t v201 = 0;
  uint64_t v202 = *v239 - 1;
  uint64_t result = 0;
  do
  {
    if (*v29 != 0.0) {
      *a19 = ++v201;
    }
    ++v29;
    --v202;
  }
  while (v202);
  return result;
}

uint64_t sub_10000868C(double *a1, unint64_t *a2, double *a3, double *a4, double *a5, void *a6, double *a7, double *a8, int8x16_t a9, int8x16_t a10, int8x16_t a11, int8x16_t a12, int8x16_t a13, double a14, double a15, int8x16_t a16, unint64_t *a17)
{
  int8x16_t v19 = a17;
  double v20 = *a1;
  double v21 = fabs(*a1);
  double v22 = fabs(*a3);
  uint64_t v23 = 1;
  if (v22 > v21) {
    double v24 = v22;
  }
  else {
    double v24 = v21;
  }
  if (v22 > v21) {
    double v25 = v21;
  }
  else {
    double v25 = v22;
  }
  if (v22 > v21) {
    a11.i64[0] = *(uint64_t *)a3;
  }
  else {
    a11.i64[0] = *(uint64_t *)a1;
  }
  if (v22 > v21) {
    uint64_t v23 = 3;
  }
  else {
    double v20 = *a3;
  }
  a13.i64[0] = *a2;
  if (*(double *)a2 == 0.0)
  {
    *a4 = v25;
    *a5 = v24;
    double v26 = 0.0;
    double v27 = 1.0;
    double v28 = 1.0;
    double v29 = 0.0;
  }
  else
  {
    double v30 = fabs(*(double *)a13.i64);
    if (v30 > v24)
    {
      if (v24 / v30 < 1.11022302e-16)
      {
        *a5 = v30;
        if (v25 <= 1.0) {
          double v31 = v25 * (v24 / v30);
        }
        else {
          double v31 = v24 / (v30 / v25);
        }
        *a4 = v31;
        double v47 = v20 / *(double *)a13.i64;
        double v48 = *(double *)a11.i64 / *(double *)a13.i64;
        BOOL v49 = v22 <= v21;
        if (v22 <= v21) {
          double v50 = v47;
        }
        else {
          double v50 = v48;
        }
        if (v49) {
          double v51 = v48;
        }
        else {
          double v51 = v47;
        }
        *a17 = 0x3FF0000000000000;
        *a8 = v50;
        *a7 = v51;
        *a6 = 0x3FF0000000000000;
        a9.i64[0] = 1.0;
        goto LABEL_53;
      }
      uint64_t v23 = 2;
    }
    *(double *)a16.i64 = v24 - v25;
    double v32 = (v24 - v25) / v24;
    v17.i64[0] = 1.0;
    if (v24 - v25 == v24) {
      double v32 = 1.0;
    }
    double v33 = *(double *)a13.i64 / *(double *)a11.i64;
    v18.i64[0] = 2.0;
    double v34 = 2.0 - v32;
    double v35 = sqrt(v34 * v34 + v33 * v33);
    double v36 = fabs(*(double *)a13.i64 / *(double *)a11.i64);
    double v37 = sqrt(v33 * v33 + v32 * v32);
    if (v32 != 0.0) {
      double v36 = v37;
    }
    double v38 = (v35 + v36) * 0.5;
    *a4 = v25 / v38;
    *a5 = v24 * v38;
    v39.f64[0] = NAN;
    v39.f64[1] = NAN;
    int8x16_t v40 = (int8x16_t)vnegq_f64(v39);
    double v41 = *(double *)a13.i64 / *(double *)vbslq_s8(v40, a16, a11).i64 + v33 / v34;
    double v42 = *(double *)vbslq_s8(v40, v18, a11).i64 * *(double *)vbslq_s8(v40, v17, a13).i64;
    if (v32 != 0.0) {
      double v42 = v41;
    }
    if (v33 * v33 != 0.0) {
      double v42 = (v33 / (v34 + v35) + v33 / (v32 + v36)) * (v38 + 1.0);
    }
    double v43 = sqrt(v42 * v42 + 4.0);
    double v28 = 2.0 / v43;
    double v29 = v42 / v43;
    double v27 = (v28 + v29 * v33) / v38;
    double v26 = v20 / *(double *)a11.i64 * v29 / v38;
  }
  BOOL v44 = v22 <= v21;
  if (v22 <= v21) {
    double v45 = v27;
  }
  else {
    double v45 = v29;
  }
  if (v44) {
    double v46 = v26;
  }
  else {
    double v46 = v28;
  }
  if (v44) {
    double v26 = v28;
  }
  *(double *)a17 = v45;
  *a8 = v46;
  if (v44) {
    *(double *)a9.i64 = v29;
  }
  else {
    *(double *)a9.i64 = v27;
  }
  *a7 = v26;
  *a6 = a9.i64[0];
  if (v23 != 2)
  {
    if (v23 == 1)
    {
      a9.i64[0] = *(uint64_t *)a7;
      a2 = (unint64_t *)a1;
    }
    else
    {
      int8x16_t v19 = (unint64_t *)a8;
      a2 = (unint64_t *)a3;
    }
  }
LABEL_53:
  a10.i64[0] = 1.0;
  v52.f64[0] = NAN;
  v52.f64[1] = NAN;
  int8x16_t v53 = (int8x16_t)vnegq_f64(v52);
  int8x16_t v54 = vbslq_s8(v53, a10, a9);
  a12.i64[0] = *v19;
  int8x16_t v55 = vbslq_s8(v53, a10, a12);
  *(double *)v54.i64 = *(double *)v54.i64 * *(double *)v55.i64;
  v55.i64[0] = *a2;
  int8x16_t v56 = vbslq_s8(v53, a10, v55);
  *(double *)v54.i64 = *(double *)v54.i64 * *(double *)v56.i64;
  v56.i64[0] = *(uint64_t *)a5;
  int8x16_t v57 = vbslq_s8(v53, v56, v54);
  *a5 = *(double *)v57.i64;
  v57.i64[0] = *(uint64_t *)a1;
  int8x16_t v58 = vbslq_s8(v53, a10, v57);
  *(double *)v54.i64 = *(double *)v54.i64 * *(double *)v58.i64;
  v58.i64[0] = *(uint64_t *)a3;
  int8x16_t v59 = vbslq_s8(v53, a10, v58);
  *(double *)v54.i64 = *(double *)v54.i64 * *(double *)v59.i64;
  v59.i64[0] = *(uint64_t *)a4;
  *(void *)a4 = vbslq_s8(v53, v59, v54).u64[0];
  return 0;
}

double *sub_1000088E4(double *result, double *a2, double a3, double a4, double a5)
{
  double v5 = fabs(a3);
  double v6 = fabs(a4);
  double v7 = fabs(a5);
  if (v5 >= v7) {
    double v8 = v7;
  }
  else {
    double v8 = v5;
  }
  if (v5 > v7) {
    double v7 = v5;
  }
  if (v8 == 0.0)
  {
    *uint64_t result = 0.0;
    if (v7 != 0.0)
    {
      if (v7 >= v6) {
        double v9 = v6;
      }
      else {
        double v9 = v7;
      }
      if (v7 > v6) {
        double v6 = v7;
      }
      double v6 = v6 * sqrt(v6 + v9 / v6 * (v9 / v6));
    }
  }
  else
  {
    double v10 = v8 / v7 + 1.0;
    double v11 = (v7 - v8) / v7;
    if (v6 >= v7)
    {
      double v13 = v7 / v6;
      double v14 = 2.0 / (sqrt(v13 * v10 * (v13 * v10) + 1.0) + sqrt(v13 * v11 * (v13 * v11) + 1.0));
      *uint64_t result = v13 * (v8 * v14);
      double v6 = v6 / v14;
    }
    else
    {
      double v12 = 2.0 / (sqrt(v6 / v7 * (v6 / v7) + v10 * v10) + sqrt(v6 / v7 * (v6 / v7) + v11 * v11));
      *uint64_t result = v8 * v12;
      double v6 = v7 / v12;
    }
  }
  *a2 = v6;
  return result;
}

BOOL sub_1000089C0(double *a1, double *a2, double *a3, double a4, double a5)
{
  if (a5 == 0.0)
  {
    uint64_t v5 = 0;
    *a1 = 1.0;
    *a2 = 0.0;
    *a3 = a4;
  }
  else if (a4 == 0.0)
  {
    uint64_t v5 = 0;
    *a1 = 0.0;
    *a2 = 1.0;
    *a3 = a5;
  }
  else
  {
    double v6 = sqrt(a5 * a5 + a4 * a4);
    *a3 = v6;
    *a1 = a4 / v6;
    *a2 = a5 / *a3;
    if (fabs(a4) > fabs(a5) && *a1 < 0.0)
    {
      *a1 = -*a1;
      *a2 = -*a2;
      *a3 = -*a3;
    }
    return (*(void *)a3 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL;
  }
  return v5;
}

uint64_t sub_100008A7C(unsigned char *a1, unsigned __int8 *a2, uint64_t *a3, uint64_t *a4, uint64_t a5, uint64_t a6, double *a7, uint64_t *a8)
{
  uint64_t v8 = *a3;
  if (*a3)
  {
    uint64_t v9 = *a4;
    if (*a4)
    {
      uint64_t v10 = a5 - 8;
      uint64_t v11 = a6 - 8;
      uint64_t v12 = *a8;
      int v13 = *a2;
      if (*a1 == 76)
      {
        if (v13 == 70)
        {
          if (v8 >= 2)
          {
            double v14 = a7 + 1;
            uint64_t v15 = 8 * v12;
            for (uint64_t i = 1; i != v8; ++i)
            {
              double v17 = *(double *)(v10 + 8 * i);
              double v18 = *(double *)(v11 + 8 * i);
              BOOL v20 = v18 == 0.0 && v17 == 1.0 || v9 < 1;
              if (!v20)
              {
                double v21 = v14;
                uint64_t v22 = v9;
                do
                {
                  double v23 = *(v21 - 1);
                  double v24 = v23 * -v18 + v17 * *v21;
                  *(v21 - 1) = v17 * v23 + v18 * *v21;
                  *double v21 = v24;
                  double v21 = (double *)((char *)v21 + v15);
                  --v22;
                }
                while (v22);
              }
              ++v14;
            }
          }
        }
        else if (v8 >= 2)
        {
          uint64_t v34 = (uint64_t)&a7[v8 - 1];
          do
          {
            double v35 = *(double *)(v10 + 8 * (v8 - 1));
            double v36 = *(double *)(v11 + 8 * (v8 - 1));
            if ((v36 != 0.0 || v35 != 1.0) && v9 >= 1)
            {
              float64x2_t v39 = (double *)v34;
              uint64_t v40 = v9;
              do
              {
                double v41 = *(v39 - 1);
                double v42 = v41 * -v36 + v35 * *v39;
                *(v39 - 1) = v35 * v41 + v36 * *v39;
                *float64x2_t v39 = v42;
                v39 += v12;
                --v40;
              }
              while (v40);
            }
            v34 -= 8;
            BOOL v20 = v8-- <= 2;
          }
          while (!v20);
        }
      }
      else if (v13 == 70)
      {
        if (v9 >= 2)
        {
          uint64_t v25 = v12;
          for (uint64_t j = 1; j != v9; ++j)
          {
            double v27 = *(double *)(v10 + 8 * j);
            double v28 = *(double *)(v11 + 8 * j);
            if ((v28 != 0.0 || v27 != 1.0) && v8 >= 1)
            {
              double v31 = a7;
              uint64_t v32 = v8;
              do
              {
                double v33 = v31[v25];
                v31[v25] = *v31 * -v28 + v27 * v33;
                *double v31 = v27 * *v31 + v28 * v33;
                ++v31;
                --v32;
              }
              while (v32);
            }
            a7 = (double *)((char *)a7 + v25 * 8);
          }
        }
      }
      else if (v9 >= 2)
      {
        double v43 = (double *)((char *)a7 + v12 * (8 * v9 - 16));
        uint64_t v44 = -8 * v12;
        double v45 = (double *)((char *)a7 + v12 * (8 * v9 - 8));
        do
        {
          double v46 = *(double *)(v10 + 8 * (v9 - 1));
          double v47 = *(double *)(v11 + 8 * (v9 - 1));
          if ((v47 != 0.0 || v46 != 1.0) && v8 >= 1)
          {
            double v50 = v45;
            double v51 = v43;
            uint64_t v52 = v8;
            do
            {
              double v53 = *v50;
              *double v50 = *v51 * -v47 + v46 * *v50;
              ++v50;
              *double v51 = v46 * *v51 + v47 * v53;
              ++v51;
              --v52;
            }
            while (v52);
          }
          double v43 = (double *)((char *)v43 + v44);
          double v45 = (double *)((char *)v45 + v44);
          BOOL v20 = v9-- <= 2;
        }
        while (!v20);
      }
    }
  }
  return 0;
}

uint64_t sub_100008CB4()
{
  uint64_t v0 = __chkstk_darwin();
  uint64_t result = qword_1002BBE70;
  if (qword_1002BBE70)
  {
    sub_10004C35C(qword_1002BBE70);
    int v2 = sub_100056558(qword_1002BBE70, 1785950322);
    if (v2 == -1)
    {
      NSLog(@"\tDefault calibration from NVM: deice is not ready or no ToF channel found");
    }
    else
    {
      uint64_t v3 = (unsigned __int16)v2;
      CFDataRef v4 = sub_10000B9E0(v0, qword_1002BBE70, (unsigned __int16)v2, v8, 0xA000u);
      if (v4)
      {
        CFDataRef v5 = v4;
        CFDataRef v6 = sub_10000BA94(v0, qword_1002BBE70, v3, 13, v8, 0xA000u);
        if (v6)
        {
          CFDataRef v7 = v6;
          *(void *)(v0 + 32) = PDPeridotCalibCalibrationBlobsFromNVM();
          CFRelease(v5);
          CFRelease(v7);
          if (*(void *)(v0 + 32))
          {
            NSLog(@"\tDefault calibration from NVM: created pseudo-FDR from NVM");
            return 1;
          }
          NSLog(@"\tDefault calibration from NVM: failed to create calibration from NVM");
        }
        else
        {
          NSLog(@"\tDefault calibration from NVM: failed to read device NVM");
          CFRelease(v5);
        }
      }
      else
      {
        NSLog(@"\tDefault calibration from NVM: failed to read sensor NVM");
      }
    }
    return 0;
  }
  return result;
}

uint64_t sub_100008E24(uint64_t a1)
{
  *(void *)a1 = off_100096000;
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 24) = 0;
  *(void *)(a1 + 8) = off_100096020;
  *(void *)(a1 + 16) = a1 + 24;
  *(unsigned char *)(a1 + 56) = 0;
  *(unsigned char *)(a1 + 40) = 0;
  *(void *)(a1 + 64) = 0;
  *(void *)(a1 + 48) = 0;
  *(unsigned char *)(a1 + 72) = 0;
  *(unsigned char *)(a1 + 72) = sub_10000D798(a1 + 8);
  return a1;
}

void sub_100008EB0(_Unwind_Exception *a1)
{
  sub_10000DEFC(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100008EC4(uint64_t a1)
{
  int v2 = (void *)sub_100008E24(a1);
  *int v2 = off_100095CD8;
  sub_100008F4C((uint64_t)v2);
  if (*(unsigned char *)(a1 + 72)) {
    *(unsigned char *)(a1 + 72) = *(unsigned char *)(a1 + 57);
  }
  return a1;
}

void sub_100008F1C(_Unwind_Exception *a1)
{
  void *v1 = off_100096000;
  sub_10000DEFC(v1 + 1);
  _Unwind_Resume(a1);
}

void sub_100008F4C(uint64_t a1)
{
  *(unsigned char *)(a1 + 73) = 0;
  uint64_t v1 = (char *)(a1 + 73);
  CFDictionaryRef v2 = IOServiceNameMatching("AppleH16CamIn");
  io_service_t MatchingService = IOServiceGetMatchingService(kIOMainPortDefault, v2);
  CFDataRef v4 = (const __CFData *)IORegistryEntrySearchCFProperty(MatchingService, "IOService", @"JasperSNUM", kCFAllocatorDefault, 3u);
  if (!v4) {
    return;
  }
  CFDataRef v5 = v4;
  CFTypeID v6 = CFGetTypeID(v4);
  if (v6 == CFDataGetTypeID())
  {
    BytePtr = (const char *)CFDataGetBytePtr(v5);
    goto LABEL_7;
  }
  CFTypeID v8 = CFGetTypeID(v5);
  if (v8 == CFStringGetTypeID())
  {
    BytePtr = CFStringGetCStringPtr((CFStringRef)v5, 0x8000100u);
LABEL_7:
    if (BytePtr) {
      strncpy(v1, BytePtr, 0x20uLL);
    }
  }

  CFRelease(v5);
}

uint64_t sub_100009048()
{
  if (!byte_1002BBE7D)
  {
    NSLog(@"Testing if aFDR may be used");
    byte_1002BBE7D = 1;
    byte_1002BBE7E = 0;
    if ((dword_1002BBDEC & 2) != 0)
    {
      byte_1002BBE7E = 1;
      NSLog(@"\taFDR may be used");
    }
    else
    {
      __int16 v11 = 0;
      uint64_t v1 = MGCopyAnswer();
      if (!v1)
      {
        NSLog(@"\tCouldn't get boot manifest hash");
        return 0;
      }
      CFDictionaryRef v2 = (void *)v1;
      uint64_t v3 = (void *)MGCopyAnswer();
      if (!v3)
      {
        NSLog(@"\tCouldn't get crypto hash method");
        return 0;
      }
      CFDataRef v4 = v3;
      if (([v3 isEqualToString:@"sha2-384"] & 1) == 0)
      {
        NSLog(@"\tCrypto hash method is %@. Only %s is supported", v4, "sha2-384");
        return 0;
      }
      id v5 = [[+[MSUDataAccessor sharedDataAccessor](MSUDataAccessor, "sharedDataAccessor") copyPathForPersonalizedData:2 error:0];
      CFTypeID v6 = +[NSData dataWithContentsOfFile:v5];
      if (!v6)
      {
        NSLog(@"\tCouldn't find AP ticket file at path %@", v5);

        return 0;
      }
      CFDataRef v7 = v6;

      [(NSData *)v7 bytes];
      [(NSData *)v7 length];
      if (AMSupportDigestSha384())
      {
        NSLog(@"\tFailed to digest AP ticket");
        return 0;
      }
      if (memcmp(__s1, [v2 bytes], 0x30uLL))
      {
        NSLog(@"\tAP ticket digest doesn't match boot manifest hash");
        return 0;
      }
      if (Img4DecodeInitManifest((uint64_t)[(NSData *)v7 bytes], [(NSData *)v7 length], (uint64_t)v12))
      {
        NSLog(@"\tFailed to initialize Manifest from ticket");
        return 1;
      }
      if (Img4DecodeGetBooleanFromSection((uint64_t)v12, 0, 1717660003, (BOOL *)&v11)) {
        LOBYTE(v11) = 0;
      }
      if (Img4DecodeGetBooleanFromSection((uint64_t)v12, 0, 1717663091, (BOOL *)&v11 + 1))
      {
        uint64_t v9 = 0;
        HIBYTE(v11) = 0;
      }
      else
      {
        uint64_t v9 = HIBYTE(v11);
      }
      byte_1002BBE7E = v11 | v9;
      if (v11 | v9) {
        uint64_t v10 = "";
      }
      else {
        uint64_t v10 = " not";
      }
      NSLog(@"\taFDR may%s be used (%d, %d)", v10, v11, v9);
    }
    int v0 = byte_1002BBE7E;
    return v0 != 0;
  }
  int v0 = byte_1002BBE7E;
  return v0 != 0;
}

uint64_t sub_1000092F0(uint64_t result)
{
  dword_1002BBDEC = result;
  return result;
}

uint64_t sub_1000092FC(_WORD *a1)
{
  sub_10000DF68((uint64_t)&v9);
  uint64_t v9 = off_1000960C8;
  v10[73] = 1;
  if (v10[72] && (sub_10000E064((uint64_t)&v9, a1) & 1) != 0)
  {
    uint64_t v2 = 1;
  }
  else
  {
    sub_100008E24((uint64_t)&v4);
    CFDataRef v4 = off_100095CB8;
    char v8 = 1;
    if (v7 && (char v7 = v6) != 0) {
      uint64_t v2 = sub_10000E064((uint64_t)&v4, a1);
    }
    else {
      uint64_t v2 = 0;
    }
    CFDataRef v4 = off_100096000;
    sub_10000DEFC(v5);
  }
  uint64_t v9 = off_100095E90;
  sub_10000C134((uint64_t)v10);
  return v2;
}

void sub_100009428(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_start(va, a13);
  sub_10000DEFC((void *)(v13 + 8));
  sub_10000C134((uint64_t)va);
  _Unwind_Resume(a1);
}

void *sub_10000948C(void *a1)
{
  *a1 = off_100096000;
  sub_10000DEFC(a1 + 1);
  return a1;
}

void *sub_1000094D0(void *a1)
{
  *a1 = off_100095E90;
  sub_10000C134((uint64_t)(a1 + 1));
  return a1;
}

const void *sub_100009514(off_t *a1)
{
  uint64_t v2 = fopen("/var/mobile/Library/ISP/Pearl/NVM.bin", "rb");
  if (v2)
  {
    uint64_t v3 = v2;
    fseeko(v2, 0, 2);
    *a1 = ftello(v3);
    fseeko(v3, 0, 0);
    if ((unint64_t)*a1 > 0xC7) {
      operator new[]();
    }
    fclose(v3);
  }
  sub_10000DF68((uint64_t)&v13);
  uint64_t v13 = off_1000960C8;
  v14[73] = 1;
  if (v14[72])
  {
    CFDataRef v4 = (const void *)sub_10000E1E0((uint64_t)&v13, a1);
    if (v4) {
      goto LABEL_12;
    }
  }
  sub_100008E24((uint64_t)&v8);
  char v8 = off_100095CB8;
  char v12 = 1;
  if (v11 && (char v11 = v10) != 0) {
    CFDataRef v4 = (const void *)sub_10000E1E0((uint64_t)&v8, a1);
  }
  else {
    CFDataRef v4 = 0;
  }
  char v8 = off_100096000;
  sub_10000DEFC(v9);
  if (v4)
  {
LABEL_12:
    int v5 = open_dprotected_np("/var/mobile/Library/ISP/Pearl/NVM.bin", 513, 4, 0, 511);
    char v6 = fdopen(v5, "wb");
    if (v6)
    {
      fwrite(v4, 1uLL, *a1, v6);
      fclose(v6);
    }
  }
  uint64_t v13 = off_100095E90;
  sub_10000C134((uint64_t)v14);
  return v4;
}

void sub_100009724(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_start(va, a13);
  sub_10000DEFC((void *)(v13 + 8));
  sub_10000C134((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_100009788(uint64_t a1)
{
  sub_10000DF68((uint64_t)&v11);
  char v11 = off_1000960C8;
  v12[73] = 1;
  if sub_100009940((uint64_t)&v11, a1) && (sub_100009A24((uint64_t)&v11), (v2))
  {
    uint64_t v3 = 1;
  }
  else
  {
    sub_100008E24((uint64_t)&v6);
    char v6 = off_100095CB8;
    char v10 = 1;
    if (v9) {
      char v9 = v8;
    }
    if (sub_100009940((uint64_t)&v6, a1))
    {
      sub_100009A24((uint64_t)&v6);
      uint64_t v3 = v4;
    }
    else
    {
      uint64_t v3 = 0;
    }
    char v6 = off_100096000;
    sub_10000DEFC(v7);
  }
  char v11 = off_100095E90;
  sub_10000C134((uint64_t)v12);
  return v3;
}

void sub_1000098DC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_start(va, a13);
  sub_10000C134((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_100009940(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = sub_10000D07C((uint64_t **)(a1 + 8), 4);
  uint64_t result = (*(uint64_t (**)(uint64_t *))(*v3 + 16))(v3);
  if (result)
  {
    (*(void (**)(uint64_t *, int *, uint64_t))(*v3 + 24))(v3, &v11, 4);
    if (v11 == 1)
    {
      uint64_t result = sub_10000E34C((const char *)v3, (uint64_t)v7);
      if (result)
      {
        long long v5 = v7[3];
        *(_OWORD *)(a2 + 32) = v7[2];
        *(_OWORD *)(a2 + 48) = v5;
        *(void *)(a2 + 64) = v8;
        long long v6 = v7[1];
        *(_OWORD *)a2 = v7[0];
        *(_OWORD *)(a2 + 16) = v6;
        *(_OWORD *)(a2 + 72) = v9;
        *(void *)(a2 + 88) = v10;
      }
    }
    else
    {
      return 0;
    }
  }
  return result;
}

void sub_100009A24(uint64_t a1)
{
  uint64_t v1 = sub_10000D07C((uint64_t **)(a1 + 8), 3);
  if ((*(unsigned int (**)(uint64_t *))(*v1 + 16))(v1))
  {
    (*(void (**)(uint64_t *, int *, uint64_t))(*v1 + 24))(v1, &v2, 4);
    switch(v2)
    {
      case 3:
        sub_10000E5B8();
        break;
      case 2:
        sub_10000E4E0();
        break;
      case 1:
        sub_10000E408();
        break;
    }
  }
}

void sub_100009B1C()
{
  byte_1002BBE78 = 0;
}

BOOL sub_100009B2C()
{
  CFDataRef BinaryRepresentation = (const __CFData *)PDPeridotCalibCreateBinaryRepresentation();
  if (!BinaryRepresentation) {
    return 0;
  }
  CFDataRef v1 = BinaryRepresentation;
  BytePtr = CFDataGetBytePtr(BinaryRepresentation);
  size_t Length = CFDataGetLength(v1);
  int v4 = open_dprotected_np("/var/mobile/Library/ISP/JasperL/JasperLCalib.bin", 513, 4, 0, 511);
  long long v5 = fdopen(v4, "wb");
  BOOL v6 = v5 != 0;
  if (v5)
  {
    char v7 = v5;
    fwrite(BytePtr, 1uLL, Length, v5);
    fclose(v7);
  }
  CFRelease(v1);
  return v6;
}

BOOL sub_100009BF0(const void *a1)
{
  int v2 = open_dprotected_np("/var/mobile/Library/ISP/Pearl/PCECalib.bin", 513, 4, 0, 511);
  uint64_t v3 = fdopen(v2, "wb");
  if (v3)
  {
    fwrite(a1, 1uLL, 0x3370uLL, v3);
    fclose(v3);
  }
  return v3 != 0;
}

BOOL sub_100009C70()
{
  sub_10000C514((uint64_t)&v2, "/var/mobile/Documents/Pearl", 9u);
  int v0 = v3;
  int v2 = off_100095F18;
  if (v3) {
    fclose(v3);
  }
  return v0 != 0;
}

BOOL sub_100009D18(uint64_t a1)
{
  return *(void *)(a1 + 264) != 0;
}

void *sub_100009D28(void *a1)
{
  *a1 = off_100095F18;
  int v2 = (FILE *)a1[33];
  if (v2) {
    fclose(v2);
  }
  return a1;
}

uint64_t sub_100009D78()
{
  __chkstk_darwin();
  int v1 = v0;
  uint64_t v3 = v2;
  NSLog(@"Pearl calibration\n");
  umask(0);
  if ((sub_10000A2EC("/var/mobile/Library/ISP/Pearl") & 1) == 0)
  {
    NSLog(@"\tCouldn't validate directories\n");
    return 0;
  }
  NSLog(@"\tLooking for local cache\n");
  int v4 = fopen("/var/mobile/Library/ISP/Pearl/PCECalib.bin", "rb");
  if (!v4) {
    goto LABEL_27;
  }
  long long v5 = v4;
  fread(v3, 1uLL, 0x3370uLL, v4);
  if (!v1) {
    goto LABEL_20;
  }
  NSLog(@"\tValidating Calibration UUID");
  sub_10000DF68((uint64_t)&v22);
  uint64_t v22 = off_1000960C8;
  char v27 = 0;
  if ((sub_10000C718((uint64_t)&v22, (uint64_t)&v28) & 1) == 0)
  {
    sub_100008E24((uint64_t)&v17);
    double v17 = off_100095CB8;
    if (v20) {
      char v20 = v19;
    }
    char v21 = 0;
    if ((sub_10000C974((uint64_t)&v17, (uint64_t)&v28) & 1) == 0)
    {
      NSLog(@"\tFailed to read UUID. Marking as invalid");
      double v17 = off_100096000;
      sub_10000DEFC(v18);
      uint64_t v22 = off_100095E90;
      sub_10000C134((uint64_t)v23);
      goto LABEL_25;
    }
    double v17 = off_100096000;
    sub_10000DEFC(v18);
  }
  uint64_t v6 = 0;
  BOOL v8 = *((void *)v3 + 1) != v29[0] || *((void *)v3 + 2) != v29[1];
  long long v9 = @"Cached UUID: 0x";
  do
    long long v9 = (__CFString *)[(__CFString *)v9 stringByAppendingFormat:@"%02X", *((unsigned __int8 *)v3 + v6++ + 8)];
  while (v6 != 16);
  id v10 = [(__CFString *)v9 stringByAppendingString:@", calibration: 0x"];
  for (uint64_t i = 8; i != 24; ++i)
    id v10 = [[v10 stringByAppendingFormat:@"%02X", *((unsigned __int8 *)&v29[-1] + i)];
  NSLog(@"\t%@", v10);
  uint64_t v22 = off_100095E90;
  sub_10000C134((uint64_t)v23);
  if (!v8)
  {
LABEL_20:
    if (*v3 == 6)
    {
      NSLog(@"\tFound\n");
      fclose(v5);
      return 1;
    }
    NSLog(@"\tIgnoring unexpected cached version (%d != %d)\n", *v3, 6);
    goto LABEL_26;
  }
LABEL_25:
  sub_10000A3F8((uint64_t)"/var/mobile/Library/ISP/Pearl");
  NSLog(@"\tCalibration UUID mismatch, removing contents of directory\n");
LABEL_26:
  fclose(v5);
LABEL_27:
  NSLog(@"\tLooking for local override files\n");
  sub_10000DF68((uint64_t)&v28);
  double v28 = off_1000960C8;
  char v30 = 1;
  sub_10000A54C((uint64_t)&v28, v3);
  if (v13) {
    goto LABEL_31;
  }
  NSLog(@"\tLooking for FDR data\n");
  NSLog(@"\tReading from FDR\n");
  sub_100008E24((uint64_t)&v22);
  uint64_t v22 = off_100095CB8;
  if (v25) {
    char v25 = v24;
  }
  BOOL v26 = (dword_1002BBDEC & 1) == 0;
  sub_10000A688((uint64_t)&v22, v3);
  char v15 = v14;
  uint64_t v22 = off_100096000;
  sub_10000DEFC(v23);
  if (v15)
  {
LABEL_31:
    NSLog(@"Creating local cache\n");
    unsigned int *v3 = 6;
    kdebug_trace();
    BOOL v12 = sub_100009BF0(v3);
  }
  else
  {
    NSLog(@"\tDidn't find calibration\n");
    BOOL v12 = 0;
  }
  double v28 = off_100095E90;
  sub_10000C134((uint64_t)v29);
  return v12;
}

void sub_10000A21C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, ...)
{
  va_start(va, a14);
  sub_10000C134((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_10000A2EC(const char *a1)
{
  int v2 = mkdir("/var/mobile/Library/ISP", 0x1FFu);
  if (v2)
  {
    int v3 = v2;
    if (*__error() != 17)
    {
      printf("\tCan't create %s! (%d)\n", "/var/mobile/Library/ISP", v3);
      return 0;
    }
  }
  int v4 = open_dprotected_np("/var/mobile/Library/ISP", 0, 0, 1);
  fcntl(v4, 64, 4);
  close(v4);
  int v5 = mkdir(a1, 0x1FFu);
  if (v5)
  {
    int v6 = v5;
    if (*__error() != 17)
    {
      printf("\tCan't create %s! (%d)\n", a1, v6);
      return 0;
    }
  }
  uint64_t v7 = 1;
  int v8 = open_dprotected_np(a1, 0, 0, 1);
  fcntl(v8, 64, 4);
  close(v8);
  return v7;
}

id sub_10000A3F8(uint64_t a1)
{
  int v2 = [+[NSFileManager defaultManager](NSFileManager, "defaultManager") contentsOfDirectoryAtPath:+[NSString stringWithUTF8String:a1] error:0];
  long long v7 = 0u;
  long long v8 = 0u;
  long long v9 = 0u;
  long long v10 = 0u;
  id result = [(NSArray *)v2 countByEnumeratingWithState:&v7 objects:v11 count:16];
  if (result)
  {
    id v4 = result;
    uint64_t v5 = *(void *)v8;
    do
    {
      int v6 = 0;
      do
      {
        if (*(void *)v8 != v5) {
          objc_enumerationMutation(v2);
        }
        [+[NSFileManager defaultManager](NSFileManager, "defaultManager") removeItemAtPath:+[NSString stringWithFormat:@"%s/%@", a1, *(void *)(*((void *)&v7 + 1) + 8 * (void)v6)] error:0];
        int v6 = (char *)v6 + 1;
      }
      while (v4 != v6);
      id result = [(NSArray *)v2 countByEnumeratingWithState:&v7 objects:v11 count:16];
      id v4 = result;
    }
    while (result);
  }
  return result;
}

void sub_10000A54C(uint64_t a1, void *a2)
{
  if (*(unsigned char *)(a1 + 80))
  {
    bzero(a2, 0x3370uLL);
    sub_10000EA0C(a1, (uint64_t)a2);
    if (v4)
    {
      sub_10000EB54(a1);
      if (v5)
      {
        if ((dword_1002BBDEC & 4) != 0
          || (sub_10000EC4C(a1, (uint64_t)a2), v6)
          && (sub_100009A24(a1), v7)
          && (sub_100009940(a1, (uint64_t)a2 + 8552) & 1) != 0
          || (dword_1002BBDEC & 0x10) != 0)
        {
          if (sub_10000ED68(a1, (uint64_t)a2 + 8648)
            && sub_10000EE2C(a1, (uint64_t)a2 + 8672)
            && sub_10000EEF8(a1, (uint64_t)a2))
          {
            if (sub_10000C718(a1, (uint64_t)a2))
            {
              sub_10000EFB0(a1);
              (*(void (**)(uint64_t, void *))(*(void *)(a1 + 8) + 32))(a1 + 8, a2);
            }
          }
        }
      }
    }
  }
}

void sub_10000A688(uint64_t a1, void *a2)
{
  if (*(unsigned char *)(a1 + 72))
  {
    bzero(a2, 0x3370uLL);
    sub_10000F6C0(a1, (uint64_t)a2);
    if (v4)
    {
      sub_10000EB54(a1);
      if (v5)
      {
        if ((dword_1002BBDEC & 4) != 0
          || (sub_10000EC4C(a1, (uint64_t)a2), v6)
          && (sub_100009A24(a1), v7)
          && (sub_100009940(a1, (uint64_t)a2 + 8552) & 1) != 0
          || (dword_1002BBDEC & 0x10) != 0)
        {
          if (sub_10000ED68(a1, (uint64_t)a2 + 8648)
            && sub_10000EE2C(a1, (uint64_t)a2 + 8672)
            && sub_10000EEF8(a1, (uint64_t)a2))
          {
            if (sub_10000C974(a1, (uint64_t)a2))
            {
              sub_10000EFB0(a1);
              (*(void (**)(uint64_t, void *))(*(void *)(a1 + 8) + 32))(a1 + 8, a2);
            }
          }
        }
      }
    }
  }
}

const void *sub_10000A7C4(uint64_t a1, int a2)
{
  qword_1002BBE70 = a1;
  NSLog(@"Jasper calibration\n");
  umask(0);
  if ((sub_10000A2EC("/var/mobile/Library/ISP/JasperL") & 1) == 0)
  {
    NSLog(@"\tCouldn't validate directories\n");
    return 0;
  }
  NSLog(@"\tLooking for local cache\n");
  if (+[NSData dataWithContentsOfFile:@"/var/mobile/Library/ISP/JasperL/JasperLCalib.bin"])
  {
    uint64_t v4 = PDPeridotCalibCreateWithBinaryRepresentation();
    if (v4)
    {
      int v5 = (const void *)v4;
      if (sub_10000AF08(&dword_1002BBDF0, a1, v4)) {
        sub_100009B2C();
      }
      if (!a2) {
        goto LABEL_21;
      }
      NSLog(@"\tValidating Calibration UUID (FDR vs cache)");
      sub_10000E834((uint64_t)&v33);
      int v6 = sub_10000D5B0((uint64_t)&v33, 18);
      if (!v6)
      {
        if (!byte_1002BBDE8
          || (sub_100008EC4((uint64_t)&v31),
              int v6 = sub_10000D5B0((uint64_t)&v31, 18),
              double v31 = off_100096000,
              sub_10000DEFC(v32),
              !v6))
        {
          NSLog(@"\tValidting SN (registry vs cache)");
          char v14 = (void *)PDPeridotCalibCopySerialNumber();
          char v15 = v14;
          if (v14)
          {
            uint64_t v16 = (const char *)[v14 UTF8String];
            size_t v17 = strlen(v35);
            if (v17 == strlen(v16))
            {
              int v9 = strncmp(v35, v16, v17);
              NSLog(@"\tCached Serial Number: %s, calibration: %s", v16, v35);
              CFRelease(v15);
              goto LABEL_20;
            }
            NSLog(@"\tSerial nubmers size mismatch");
            CFRelease(v15);
          }
          else
          {
            NSLog(@"\tCan't read serial number from cache");
          }
          double v33 = off_100095E90;
          sub_10000C134((uint64_t)v34);
LABEL_30:
          sub_10000A3F8((uint64_t)"/var/mobile/Library/ISP/JasperL");
          NSLog(@"\tCalibration UUID mismatch, removing contents of directory\n");
          CFRelease(v5);
          goto LABEL_31;
        }
      }
      double v31 = 0;
      v32[0] = 0;
      uint64_t v29 = 0;
      unint64_t v30 = 0;
      PDPeridotCalibGetMpcUUID();
      PDPeridotCalibGetMpcUUIDFromCalibrationBlob();
      unint64_t v7 = bswap64((unint64_t)v31);
      unint64_t v8 = bswap64(0);
      if (v7 == v8 && (unint64_t v7 = bswap64(v32[0]), v8 = bswap64(v30), v7 == v8))
      {
        int v9 = 0;
      }
      else if (v7 < v8)
      {
        int v9 = -1;
      }
      else
      {
        int v9 = 1;
      }
      uint64_t v10 = 0;
      int v11 = @"Cached UUID: 0x";
      do
        int v11 = (__CFString *)[(__CFString *)v11 stringByAppendingFormat:@"%02X", *((unsigned __int8 *)&v32[-1] + v10++)];
      while (v10 != 16);
      id v12 = [(__CFString *)v11 stringByAppendingString:@", calibration: 0x"];
      for (uint64_t i = 0; i != 16; ++i)
        id v12 = [[v12 stringByAppendingFormat:@"%02X", *((unsigned __int8 *)&v29 + i)];
      NSLog(@"\t%@", v12);
      CFRelease(v6);
LABEL_20:
      double v33 = off_100095E90;
      sub_10000C134((uint64_t)v34);
      if (!v9)
      {
LABEL_21:
        NSLog(@"\tFound\n");
        return v5;
      }
      goto LABEL_30;
    }
  }
LABEL_31:
  NSLog(@"\tLooking for local override files\n");
  sub_10000E834((uint64_t)&v33);
  int v5 = (const void *)sub_10000B0A0((uint64_t)&v33, 0);
  if (v5) {
    goto LABEL_32;
  }
  if (byte_1002BBDE8)
  {
    NSLog(@"\tLooking for FDR data\n");
    CFDictionaryRef v19 = IOServiceNameMatching("isp");
    io_service_t MatchingService = IOServiceGetMatchingService(kIOMainPortDefault, v19);
    CFDataRef v21 = (const __CFData *)IORegistryEntrySearchCFProperty(MatchingService, "IOService", @"pearl-calibration-data", kCFAllocatorDefault, 3u);
    CFDataRef v22 = v21;
    if (v21)
    {
      int Length = CFDataGetLength(v21);
      BytePtr = CFDataGetBytePtr(v22);
      char v25 = fopen("/var/mobile/Library/ISP/JasperL/JasperRecalibration.bin", "rb");
      BOOL v26 = v25;
      if (v25)
      {
        fseeko(v25, 0, 2);
        off_t v27 = ftello(v26);
        fseeko(v26, 0, 0);
        if (v27 == Length) {
          operator new[]();
        }
        fclose(v26);
      }
      [+[NSFileManager defaultManager] removeItemAtPath:@"/var/mobile/Library/ISP/JasperL/JasperLCalib.bin" error:0];
      double v28 = fopen("/var/mobile/Library/ISP/JasperL/JasperRecalibration.bin", "wb");
      if (v28)
      {
        fwrite(BytePtr, Length, 1uLL, v28);
        fclose(v28);
      }
    }
    NSLog(@"\tReading from FDR\n");
    sub_100008EC4((uint64_t)&v31);
    int v5 = (const void *)sub_10000B230((uint64_t)&v31, v22);
    if (v22) {
      CFRelease(v22);
    }
    double v31 = off_100096000;
    sub_10000DEFC(v32);
    if (v5) {
      goto LABEL_32;
    }
  }
  NSLog(@"\tLooking for calibration in NVM\n");
  sub_10000F8A8((uint64_t)&v31);
  int v5 = (const void *)sub_10000B404((uint64_t)&v31, 0);
  double v31 = off_100095FD0;
  sub_10000BB20(v32);
  if (v5)
  {
LABEL_32:
    sub_10000AF08(&dword_1002BBDF0, a1, (uint64_t)v5);
    NSLog(@"Creating local cache\n");
    kdebug_trace();
    sub_100009B2C();
  }
  else
  {
    NSLog(@"\tDidn't find calibration\n");
    int v5 = 0;
  }
  double v33 = off_100095E90;
  sub_10000C134((uint64_t)v34);
  return v5;
}

void sub_10000AE40(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28)
{
}

uint64_t sub_10000AF08(int *a1, uint64_t a2, uint64_t a3)
{
  if (a3)
  {
    int v4 = *a1;
    if ((*a1 - 1) >= 2 && v4 != 4)
    {
      if (v4 == 3)
      {
        NSLog(@"Component Validation: At least one component replaced. Resetting stray");
        PDPeridotCalibResetStray();
        *a1 = 4;
        return 1;
      }
      v11[0] = 0;
      v11[1] = v11;
      v11[2] = 0x3052000000;
      v11[3] = sub_10000D414;
      unint64_t v7 = &__NSArray0__struct;
      v11[4] = sub_10000D424;
      id v12 = &__NSArray0__struct;
      unsigned int v8 = **(_DWORD **)(a2 + 4384) - 66;
      if (v8 < 5 && ((0x1Bu >> v8) & 1) != 0)
      {
        unint64_t v7 = off_100096160[v8];
        id v12 = v7;
      }
      if ([v7 count])
      {
        int v9 = *((void *)a1 + 1);
        if (!v9)
        {
          int v9 = dispatch_queue_create("com.apple.component-replacement.test", 0);
          *((void *)a1 + 1) = v9;
        }
        *a1 = 2;
        v10[0] = _NSConcreteStackBlock;
        v10[1] = 3221225472;
        v10[2] = sub_10000D430;
        v10[3] = &unk_100095FA0;
        v10[4] = v11;
        v10[5] = a1;
        dispatch_async(v9, v10);
      }
      else
      {
        *a1 = 4;
      }
      _Block_object_dispose(v11, 8);
    }
  }
  return 0;
}

void sub_10000B088(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_10000B0A0(uint64_t a1, const void *a2)
{
  if (!*(unsigned char *)(a1 + 80)) {
    return 0;
  }
  Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  uint64_t v5 = 0;
  if (sub_10000F808(a1, 0x13u, Mutable))
  {
    if (sub_10000F808(a1, 0x14u, Mutable)
      && sub_10000F808(a1, 0x15u, Mutable)
      && sub_10000F808(a1, 0x16u, Mutable)
      && sub_10000F808(a1, 0x17u, Mutable)
      && sub_10000F808(a1, 0x11u, Mutable)
      && sub_10000F808(a1, 0x12u, Mutable))
    {
      sub_10000F808(a1, 0x18u, Mutable);
      if (a2) {
        CFDictionarySetValue(Mutable, +[NSString stringWithUTF8String:"PrCL"], a2);
      }
      else {
        sub_10000F808(a1, 0x1Au, Mutable);
      }
      uint64_t v5 = PDPeridotCalibCreateWithCalibrationDictionary();
      if (v5) {
        (*(void (**)(uint64_t, uint64_t))(*(void *)(a1 + 8) + 24))(a1 + 8, v5);
      }
    }
    else
    {
      uint64_t v5 = 0;
    }
  }
  CFRelease(Mutable);
  return v5;
}

uint64_t sub_10000B230(uint64_t a1, const void *a2)
{
  if (!*(unsigned char *)(a1 + 72)) {
    return 0;
  }
  Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  uint64_t v5 = 0;
  if (sub_10000F808(a1, 0x13u, Mutable))
  {
    if (sub_10000F808(a1, 0x14u, Mutable)
      && sub_10000F808(a1, 0x15u, Mutable)
      && sub_10000F808(a1, 0x16u, Mutable)
      && sub_10000F808(a1, 0x17u, Mutable)
      && sub_10000F808(a1, 0x11u, Mutable)
      && sub_10000F808(a1, 0x12u, Mutable))
    {
      sub_10000F808(a1, 0x18u, Mutable);
      if (a2) {
        CFDictionarySetValue(Mutable, +[NSString stringWithUTF8String:"PrCL"], a2);
      }
      else {
        sub_10000F808(a1, 0x1Au, Mutable);
      }
      uint64_t v5 = PDPeridotCalibCreateWithCalibrationDictionary();
      if (v5) {
        (*(void (**)(uint64_t, uint64_t))(*(void *)(a1 + 8) + 24))(a1 + 8, v5);
      }
    }
    else
    {
      uint64_t v5 = 0;
    }
  }
  CFRelease(Mutable);
  return v5;
}

void *sub_10000B3C0(void *a1)
{
  *a1 = off_100096000;
  sub_10000DEFC(a1 + 1);
  return a1;
}

uint64_t sub_10000B404(uint64_t a1, const void *a2)
{
  if (!*(unsigned char *)(a1 + 48)) {
    return 0;
  }
  Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  uint64_t v5 = 0;
  if (sub_10000F808(a1, 0x13u, Mutable))
  {
    if (sub_10000F808(a1, 0x14u, Mutable)
      && sub_10000F808(a1, 0x15u, Mutable)
      && sub_10000F808(a1, 0x16u, Mutable)
      && sub_10000F808(a1, 0x17u, Mutable)
      && sub_10000F808(a1, 0x11u, Mutable)
      && sub_10000F808(a1, 0x12u, Mutable))
    {
      sub_10000F808(a1, 0x18u, Mutable);
      if (a2) {
        CFDictionarySetValue(Mutable, +[NSString stringWithUTF8String:"PrCL"], a2);
      }
      else {
        sub_10000F808(a1, 0x1Au, Mutable);
      }
      uint64_t v5 = PDPeridotCalibCreateWithCalibrationDictionary();
      if (v5) {
        (*(void (**)(uint64_t, uint64_t))(*(void *)(a1 + 8) + 24))(a1 + 8, v5);
      }
    }
    else
    {
      uint64_t v5 = 0;
    }
  }
  CFRelease(Mutable);
  return v5;
}

void *sub_10000B594(void *a1)
{
  *a1 = off_100095FD0;
  sub_10000BB20(a1 + 1);
  return a1;
}

void *sub_10000B5D8(void *a1)
{
  *a1 = off_100095E90;
  sub_10000C134((uint64_t)(a1 + 1));
  return a1;
}

void sub_10000B61C(void *a1)
{
  *a1 = off_100096000;
  sub_10000DEFC(a1 + 1);

  operator delete();
}

void sub_10000B680(void *a1)
{
  *a1 = off_100096000;
  sub_10000DEFC(a1 + 1);

  operator delete();
}

void sub_10000B6E4(void *a1)
{
  sub_10000BB20(a1);

  operator delete();
}

uint64_t sub_10000B71C()
{
  return PDPeridotCalibResetStray();
}

void sub_10000B728()
{
}

void sub_10000B780()
{
}

uint64_t sub_10000B7A8(uint64_t a1, const __CFDictionary *a2, unsigned int a3)
{
  *(void *)(a1 + 264) = 0;
  *(void *)(a1 + 272) = 0;
  *(_DWORD *)(a1 + 288) = 0;
  *(void *)(a1 + 280) = 0;
  *(void *)a1 = off_100095DE0;
  CFStringRef v5 = CFStringCreateWithCString(kCFAllocatorDefault, &aPcic[256 * (unint64_t)a3], 0x8000100u);
  Value = CFDictionaryGetValue(a2, v5);
  CFRelease(v5);
  if (Value)
  {
    CFTypeID v7 = CFGetTypeID(Value);
    if (v7 == CFDataGetTypeID())
    {
      *(void *)(a1 + 264) = Value;
      CFRetain(Value);
      BytePtr = CFDataGetBytePtr(*(CFDataRef *)(a1 + 264));
      *(void *)(a1 + 272) = BytePtr;
      *(void *)(a1 + 280) = BytePtr;
      *(_DWORD *)(a1 + 288) = CFDataGetLength(*(CFDataRef *)(a1 + 264));
    }
    else
    {
      CFRelease(Value);
    }
  }
  return a1;
}

void sub_10000B894(_Unwind_Exception *a1)
{
  sub_10000B8AC(v1);
  _Unwind_Resume(a1);
}

void *sub_10000B8AC(void *a1)
{
  *a1 = off_100095E58;
  int v2 = (const void *)a1[33];
  if (v2) {
    CFRelease(v2);
  }
  return a1;
}

void sub_10000B900(void *a1)
{
  sub_10000B8AC(a1);

  operator delete();
}

BOOL sub_10000B938(uint64_t a1)
{
  return *(void *)(a1 + 264) != 0;
}

void *sub_10000B948(uint64_t a1, void *__dst, int a3)
{
  id result = memcpy(__dst, *(const void **)(a1 + 280), a3);
  *(void *)(a1 + 280) += a3;
  return result;
}

uint64_t sub_10000B98C(_DWORD *a1)
{
  return (a1[72] + a1[68] - a1[70]);
}

void sub_10000B9A8(void *a1)
{
  sub_10000B8AC(a1);

  operator delete();
}

CFDataRef sub_10000B9E0(int a1, uint64_t a2, unsigned int a3, void *a4, unsigned int a5)
{
  LODWORD(length) = a5;
  bzero(a4, a5);
  int v8 = sub_10004C7E4(a2, a3, (uint64_t)a4, 0, (unsigned int *)&length);
  if (v8 == -536870184)
  {
    sub_10004CCA4();
    int v8 = sub_10004C7E4(a2, a3, (uint64_t)a4, 0, (unsigned int *)&length);
  }
  if (v8) {
    return 0;
  }
  else {
    return CFDataCreate(kCFAllocatorDefault, (const UInt8 *)a4, length);
  }
}

CFDataRef sub_10000BA94(int a1, uint64_t a2, uint64_t a3, uint64_t a4, void *a5, unsigned int a6)
{
  LODWORD(length) = a6;
  bzero(a5, a6);
  if (sub_10004CBB0(a2, a3, a4, (uint64_t)a5, 0, &length)) {
    return 0;
  }
  else {
    return CFDataCreate(kCFAllocatorDefault, (const UInt8 *)a5, length);
  }
}

uint64_t sub_10000BB20(void *a1)
{
  *a1 = off_100095D38;
  int v2 = (const void *)a1[4];
  if (v2) {
    CFRelease(v2);
  }

  return sub_10000BB80((uint64_t)a1);
}

uint64_t sub_10000BB80(uint64_t a1)
{
  *(void *)a1 = off_100095DA0;
  int v2 = (uint64_t **)(a1 + 8);
  int v3 = *(uint64_t **)(a1 + 8);
  int v4 = (uint64_t *)(a1 + 16);
  while (v3 != v4)
  {
    uint64_t v5 = v3[5];
    sub_10000BC3C(v2, v3);
    operator delete(v3);
    if (v5) {
      (*(void (**)(uint64_t))(*(void *)v5 + 8))(v5);
    }
    int v3 = *v2;
  }
  sub_10000C034((uint64_t)v2, *(void **)(a1 + 16));
  return a1;
}

uint64_t *sub_10000BC3C(uint64_t **a1, uint64_t *a2)
{
  int v2 = (uint64_t *)a2[1];
  if (v2)
  {
    do
    {
      int v3 = v2;
      int v2 = (uint64_t *)*v2;
    }
    while (v2);
  }
  else
  {
    int v4 = a2;
    do
    {
      int v3 = (uint64_t *)v4[2];
      BOOL v5 = *v3 == (void)v4;
      int v4 = v3;
    }
    while (!v5);
  }
  if (*a1 == a2) {
    *a1 = v3;
  }
  int v6 = a1[1];
  a1[2] = (uint64_t *)((char *)a1[2] - 1);
  sub_10000BCB0(v6, a2);
  return v3;
}

uint64_t *sub_10000BCB0(uint64_t *result, uint64_t *a2)
{
  uint64_t v2 = *a2;
  int v3 = a2;
  if (*a2)
  {
    int v4 = (uint64_t *)a2[1];
    if (!v4)
    {
      int v3 = a2;
      goto LABEL_7;
    }
    do
    {
      int v3 = v4;
      int v4 = (uint64_t *)*v4;
    }
    while (v4);
  }
  uint64_t v2 = v3[1];
  if (v2)
  {
LABEL_7:
    int v5 = 0;
    *(void *)(v2 + 16) = v3[2];
    goto LABEL_8;
  }
  int v5 = 1;
LABEL_8:
  int v6 = (uint64_t **)v3[2];
  CFTypeID v7 = *v6;
  if (*v6 == v3)
  {
    uint64_t *v6 = (uint64_t *)v2;
    if (v3 == result)
    {
      CFTypeID v7 = 0;
      id result = (uint64_t *)v2;
    }
    else
    {
      CFTypeID v7 = v6[1];
    }
  }
  else
  {
    v6[1] = (uint64_t *)v2;
  }
  int v8 = *((unsigned __int8 *)v3 + 24);
  if (v3 != a2)
  {
    uint64_t v9 = a2[2];
    v3[2] = v9;
    *(void *)(v9 + 8 * (*(void *)a2[2] != (void)a2)) = v3;
    uint64_t v11 = *a2;
    uint64_t v10 = a2[1];
    *(void *)(v11 + 16) = v3;
    uint64_t *v3 = v11;
    v3[1] = v10;
    if (v10) {
      *(void *)(v10 + 16) = v3;
    }
    *((unsigned char *)v3 + 24) = *((unsigned char *)a2 + 24);
    if (result == a2) {
      id result = v3;
    }
  }
  if (!v8 || !result) {
    return result;
  }
  if (!v5)
  {
    *(unsigned char *)(v2 + 24) = 1;
    return result;
  }
  while (1)
  {
    uint64_t v12 = v7[2];
    if (*(uint64_t **)v12 == v7) {
      break;
    }
    if (!*((unsigned char *)v7 + 24))
    {
      *((unsigned char *)v7 + 24) = 1;
      *(unsigned char *)(v12 + 24) = 0;
      char v13 = *(uint64_t **)(v12 + 8);
      uint64_t v14 = *v13;
      *(void *)(v12 + 8) = *v13;
      if (v14) {
        *(void *)(v14 + 16) = v12;
      }
      v13[2] = *(void *)(v12 + 16);
      *(void *)(*(void *)(v12 + 16) + 8 * (**(void **)(v12 + 16) != v12)) = v13;
      *char v13 = v12;
      *(void *)(v12 + 16) = v13;
      if (result == (uint64_t *)*v7) {
        id result = v7;
      }
      CFTypeID v7 = *(uint64_t **)(*v7 + 8);
    }
    char v15 = (void *)*v7;
    if (*v7 && !*((unsigned char *)v15 + 24))
    {
      uint64_t v16 = (uint64_t *)v7[1];
      if (!v16) {
        goto LABEL_56;
      }
LABEL_55:
      if (*((unsigned char *)v16 + 24))
      {
LABEL_56:
        *((unsigned char *)v15 + 24) = 1;
        *((unsigned char *)v7 + 24) = 0;
        uint64_t v22 = v15[1];
        *CFTypeID v7 = v22;
        if (v22) {
          *(void *)(v22 + 16) = v7;
        }
        v15[2] = v7[2];
        *(void *)(v7[2] + 8 * (*(void *)v7[2] != (void)v7)) = v15;
        v15[1] = v7;
        v7[2] = (uint64_t)v15;
        uint64_t v16 = v7;
      }
      else
      {
        char v15 = v7;
      }
      uint64_t v23 = v15[2];
      *((unsigned char *)v15 + 24) = *(unsigned char *)(v23 + 24);
      *(unsigned char *)(v23 + 24) = 1;
      *((unsigned char *)v16 + 24) = 1;
      char v24 = *(uint64_t **)(v23 + 8);
      uint64_t v25 = *v24;
      *(void *)(v23 + 8) = *v24;
      if (v25) {
        *(void *)(v25 + 16) = v23;
      }
      v24[2] = *(void *)(v23 + 16);
      *(void *)(*(void *)(v23 + 16) + 8 * (**(void **)(v23 + 16) != v23)) = v24;
      *char v24 = v23;
      goto LABEL_72;
    }
    uint64_t v16 = (uint64_t *)v7[1];
    if (v16 && !*((unsigned char *)v16 + 24)) {
      goto LABEL_55;
    }
    *((unsigned char *)v7 + 24) = 0;
    size_t v17 = (uint64_t *)v7[2];
    if (v17 == result)
    {
      size_t v17 = result;
LABEL_53:
      *((unsigned char *)v17 + 24) = 1;
      return result;
    }
    if (!*((unsigned char *)v17 + 24)) {
      goto LABEL_53;
    }
LABEL_49:
    CFTypeID v7 = *(uint64_t **)(v17[2] + 8 * (*(void *)v17[2] == (void)v17));
  }
  if (!*((unsigned char *)v7 + 24))
  {
    *((unsigned char *)v7 + 24) = 1;
    *(unsigned char *)(v12 + 24) = 0;
    uint64_t v18 = v7[1];
    *(void *)uint64_t v12 = v18;
    if (v18) {
      *(void *)(v18 + 16) = v12;
    }
    v7[2] = *(void *)(v12 + 16);
    *(void *)(*(void *)(v12 + 16) + 8 * (**(void **)(v12 + 16) != v12)) = v7;
    v7[1] = v12;
    *(void *)(v12 + 16) = v7;
    if (result == (uint64_t *)v12) {
      id result = v7;
    }
    CFTypeID v7 = *(uint64_t **)v12;
  }
  CFDictionaryRef v19 = (void *)*v7;
  if (*v7 && !*((unsigned char *)v19 + 24)) {
    goto LABEL_68;
  }
  char v20 = (uint64_t *)v7[1];
  if (!v20 || *((unsigned char *)v20 + 24))
  {
    *((unsigned char *)v7 + 24) = 0;
    size_t v17 = (uint64_t *)v7[2];
    if (*((unsigned char *)v17 + 24)) {
      BOOL v21 = v17 == result;
    }
    else {
      BOOL v21 = 1;
    }
    if (v21) {
      goto LABEL_53;
    }
    goto LABEL_49;
  }
  if (v19 && !*((unsigned char *)v19 + 24))
  {
LABEL_68:
    char v20 = v7;
  }
  else
  {
    *((unsigned char *)v20 + 24) = 1;
    *((unsigned char *)v7 + 24) = 0;
    uint64_t v26 = *v20;
    v7[1] = *v20;
    if (v26) {
      *(void *)(v26 + 16) = v7;
    }
    v20[2] = v7[2];
    *(void *)(v7[2] + 8 * (*(void *)v7[2] != (void)v7)) = v20;
    *char v20 = (uint64_t)v7;
    v7[2] = (uint64_t)v20;
    CFDictionaryRef v19 = v7;
  }
  uint64_t v23 = v20[2];
  *((unsigned char *)v20 + 24) = *(unsigned char *)(v23 + 24);
  *(unsigned char *)(v23 + 24) = 1;
  *((unsigned char *)v19 + 24) = 1;
  char v24 = *(uint64_t **)v23;
  uint64_t v27 = *(void *)(*(void *)v23 + 8);
  *(void *)uint64_t v23 = v27;
  if (v27) {
    *(void *)(v27 + 16) = v23;
  }
  v24[2] = *(void *)(v23 + 16);
  *(void *)(*(void *)(v23 + 16) + 8 * (**(void **)(v23 + 16) != v23)) = v24;
  v24[1] = v23;
LABEL_72:
  *(void *)(v23 + 16) = v24;
  return result;
}

void sub_10000C034(uint64_t a1, void *a2)
{
  if (a2)
  {
    sub_10000C034(a1, *a2);
    sub_10000C034(a1, a2[1]);
    operator delete(a2);
  }
}

void *sub_10000C08C(void *a1)
{
  *a1 = off_100095E90;
  sub_10000C134((uint64_t)(a1 + 1));
  return a1;
}

void sub_10000C0D0(void *a1)
{
  *a1 = off_100095E90;
  sub_10000C134((uint64_t)(a1 + 1));

  operator delete();
}

uint64_t sub_10000C134(uint64_t a1)
{
  *(void *)a1 = off_100095EC0;
  if (*(unsigned char *)(a1 + 40)) {
    CFRelease(*(CFTypeRef *)(a1 + 48));
  }
  if (*(unsigned char *)(a1 + 56)) {
    CFRelease(*(CFTypeRef *)(a1 + 64));
  }

  return sub_10000BB80(a1);
}

void sub_10000C1A8(uint64_t a1)
{
  sub_10000C134(a1);

  operator delete();
}

uint64_t sub_10000C1E0(uint64_t a1)
{
  uint64_t v2 = *(const char **)(a1 + 32);
  if (!v2)
  {
    uint64_t result = sub_100009048();
    if (!result) {
      return result;
    }
    uint64_t v2 = *(const char **)(a1 + 32);
  }
  if (!v2) {
    uint64_t v2 = "/var/mobile/Documents/Pearl";
  }
  id v4 = [objc_alloc((Class)NSDictionary) initWithContentsOfFile:+[NSString stringWithFormat:](NSString, "stringWithFormat:", @"%s/%s.bin", v2, "PlCl")];
  if (v4)
  {
    *(unsigned char *)(a1 + 40) = 1;
    *(void *)(a1 + 48) = v4;
  }
  int v5 = *(const char **)(a1 + 32);
  if (!v5) {
    int v5 = "/var/mobile/Documents/JasperL";
  }
  id v6 = [objc_alloc((Class)NSDictionary) initWithContentsOfFile:+[NSString stringWithFormat:](NSString, "stringWithFormat:", @"%s/%s.bin", v5, "JpCl")];
  uint64_t result = 1;
  if (v6)
  {
    *(unsigned char *)(a1 + 56) = 1;
    *(void *)(a1 + 64) = v6;
  }
  return result;
}

uint64_t sub_10000C2D4(uint64_t a1, unsigned int a2)
{
  if (a2 <= 0x10)
  {
    if (*(unsigned char *)(a1 + 40)) {
      operator new();
    }
    operator new();
  }
  if (a2 - 17 <= 0xA)
  {
    if (*(unsigned char *)(a1 + 56)) {
      operator new();
    }
    operator new();
  }
  return 0;
}

void sub_10000C4C4()
{
}

uint64_t sub_10000C514(uint64_t a1, const char *a2, unsigned int a3)
{
  *(void *)a1 = off_100095F18;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_OWORD *)(a1 + 88) = 0u;
  *(_OWORD *)(a1 + 104) = 0u;
  *(_OWORD *)(a1 + 120) = 0u;
  *(_OWORD *)(a1 + 136) = 0u;
  *(_OWORD *)(a1 + 152) = 0u;
  *(_OWORD *)(a1 + 168) = 0u;
  *(_OWORD *)(a1 + 184) = 0u;
  *(_OWORD *)(a1 + 200) = 0u;
  *(_OWORD *)(a1 + 216) = 0u;
  *(_OWORD *)(a1 + 232) = 0u;
  *(_OWORD *)(a1 + 248) = 0u;
  *(void *)(a1 + 264) = 0;
  *(_OWORD *)(a1 + 8) = 0u;
  id v4 = (const char *)(a1 + 8);
  snprintf((char *)(a1 + 8), 0x100uLL, "%s/%s.bin", a2, &aPcic[256 * (unint64_t)a3]);
  *(void *)(a1 + 264) = fopen(v4, "rb");
  return a1;
}

void sub_10000C5E4(void *a1)
{
  *a1 = off_100095F18;
  int v1 = (FILE *)a1[33];
  if (v1) {
    fclose(v1);
  }

  operator delete();
}

size_t sub_10000C650(uint64_t a1, void *__ptr, int a3)
{
  return fread(__ptr, 1uLL, a3, *(FILE **)(a1 + 264));
}

uint64_t sub_10000C664(uint64_t a1)
{
  off_t v2 = ftello(*(FILE **)(a1 + 264));
  fseeko(*(FILE **)(a1 + 264), 0, 2);
  int v3 = ftello(*(FILE **)(a1 + 264));
  fseeko(*(FILE **)(a1 + 264), v2, 0);
  return (v3 - v2);
}

uint64_t sub_10000C6C8(uint64_t a1)
{
  off_t v2 = *(NSObject **)(a1 + 8);
  if (v2)
  {
    *(_DWORD *)a1 = 1;
    dispatch_sync(v2, &stru_100095F78);
    dispatch_release(*(dispatch_object_t *)(a1 + 8));
    *(void *)(a1 + 8) = 0;
  }
  return a1;
}

uint64_t sub_10000C718(uint64_t a1, uint64_t a2)
{
  id v4 = sub_10000D07C((uint64_t **)(a1 + 8), 9);
  uint64_t result = (*(uint64_t (**)(uint64_t *))(*v4 + 16))(v4);
  if (result)
  {
    id v6 = (_WORD *)(a2 + 8704);
    (*(void (**)(uint64_t *, int *, uint64_t))(*v4 + 24))(v4, &v9, 4);
    if (v9 == 3)
    {
      (*(void (**)(uint64_t *, long long *, uint64_t))(*v4 + 24))(v4, &v10, 19);
      unsigned int v7 = v13;
      _WORD *v6 = v11;
      *(_WORD *)(a2 + 8706) = v12;
      *(_OWORD *)(a2 + 8) = v10;
    }
    else
    {
      if (v9 == 2)
      {
        (*(void (**)(uint64_t *, long long *, uint64_t))(*v4 + 24))(v4, &v10, 3);
        unsigned int v7 = BYTE2(v10);
        _WORD *v6 = v10;
        *(_WORD *)(a2 + 8706) = BYTE1(v10);
      }
      else
      {
        if (v9 != 1) {
          return 0;
        }
        (*(void (**)(uint64_t *, long long *, uint64_t))(*v4 + 24))(v4, &v10, 1);
        unsigned int v7 = v10;
        *(_DWORD *)id v6 = 0;
      }
      bzero((void *)(a2 + 8), 0x10uLL);
    }
    uint64_t result = 1;
    if (*(unsigned char *)(a1 + 81) && v7)
    {
      unsigned int v8 = 1;
      do
      {
        (*(void (**)(uint64_t *, long long *, uint64_t))(*v4 + 24))(v4, &v10, 22);
        if (v10 > 3) {
          uint64_t result = 1;
        }
        else {
          uint64_t result = sub_10000CBD0(a1, (uint64_t)v4, (uint64_t)&v10);
        }
        if (v8 >= v7) {
          break;
        }
        ++v8;
      }
      while ((result & 1) != 0);
    }
  }
  return result;
}

uint64_t sub_10000C974(uint64_t a1, uint64_t a2)
{
  id v4 = sub_10000D07C((uint64_t **)(a1 + 8), 9);
  uint64_t result = (*(uint64_t (**)(uint64_t *))(*v4 + 16))(v4);
  if (result)
  {
    id v6 = (_WORD *)(a2 + 8704);
    (*(void (**)(uint64_t *, int *, uint64_t))(*v4 + 24))(v4, &v9, 4);
    if (v9 == 3)
    {
      (*(void (**)(uint64_t *, long long *, uint64_t))(*v4 + 24))(v4, &v10, 19);
      unsigned int v7 = v13;
      _WORD *v6 = v11;
      *(_WORD *)(a2 + 8706) = v12;
      *(_OWORD *)(a2 + 8) = v10;
    }
    else
    {
      if (v9 == 2)
      {
        (*(void (**)(uint64_t *, long long *, uint64_t))(*v4 + 24))(v4, &v10, 3);
        unsigned int v7 = BYTE2(v10);
        _WORD *v6 = v10;
        *(_WORD *)(a2 + 8706) = BYTE1(v10);
      }
      else
      {
        if (v9 != 1) {
          return 0;
        }
        (*(void (**)(uint64_t *, long long *, uint64_t))(*v4 + 24))(v4, &v10, 1);
        unsigned int v7 = v10;
        *(_DWORD *)id v6 = 0;
      }
      bzero((void *)(a2 + 8), 0x10uLL);
    }
    uint64_t result = 1;
    if (*(unsigned char *)(a1 + 73) && v7)
    {
      unsigned int v8 = 1;
      do
      {
        (*(void (**)(uint64_t *, long long *, uint64_t))(*v4 + 24))(v4, &v10, 22);
        if (v10 > 3) {
          uint64_t result = 1;
        }
        else {
          uint64_t result = sub_10000CBD0(a1, (uint64_t)v4, (uint64_t)&v10);
        }
        if (v8 >= v7) {
          break;
        }
        ++v8;
      }
      while ((result & 1) != 0);
    }
  }
  return result;
}

uint64_t sub_10000CBD0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_DWORD *)(a3 + 4) <= 3u) {
    operator new[]();
  }
  return 0;
}

uint64_t *sub_10000D07C(uint64_t **a1, int a2)
{
  int v10 = a2;
  off_t v2 = a1[2];
  int v3 = a1 + 1;
  if (!v2) {
    goto LABEL_11;
  }
  id v4 = a1 + 2;
  do
  {
    int v5 = *((_DWORD *)v2 + 8);
    BOOL v6 = v5 < a2;
    if (v5 >= a2) {
      unsigned int v7 = (uint64_t **)v2;
    }
    else {
      unsigned int v7 = (uint64_t **)(v2 + 1);
    }
    if (!v6) {
      id v4 = (uint64_t **)v2;
    }
    off_t v2 = *v7;
  }
  while (*v7);
  if (v4 == a1 + 2 || *((_DWORD *)v4 + 8) > a2)
  {
LABEL_11:
    unsigned int v8 = (uint64_t *)((uint64_t (*)(uint64_t **))(*a1)[5])(a1);
    unsigned __int8 v11 = &v10;
    sub_10000D160(v3, &v10, (uint64_t)&unk_100082BC0, &v11)[5] = v8;
  }
  unsigned __int8 v11 = &v10;
  return sub_10000D160(v3, &v10, (uint64_t)&unk_100082BC0, &v11)[5];
}

uint64_t **sub_10000D160(uint64_t **a1, int *a2, uint64_t a3, _DWORD **a4)
{
  unsigned int v7 = a1 + 1;
  BOOL v6 = a1[1];
  if (v6)
  {
    int v8 = *a2;
    while (1)
    {
      while (1)
      {
        int v9 = (uint64_t **)v6;
        int v10 = *((_DWORD *)v6 + 8);
        if (v8 >= v10) {
          break;
        }
        BOOL v6 = *v9;
        unsigned int v7 = v9;
        if (!*v9) {
          goto LABEL_10;
        }
      }
      if (v10 >= v8) {
        break;
      }
      BOOL v6 = v9[1];
      if (!v6)
      {
        unsigned int v7 = v9 + 1;
        goto LABEL_10;
      }
    }
  }
  else
  {
    int v9 = a1 + 1;
LABEL_10:
    unsigned __int8 v11 = operator new(0x30uLL);
    unsigned char v11[8] = **a4;
    *((void *)v11 + 5) = 0;
    sub_10000D224(a1, (uint64_t)v9, v7, (uint64_t *)v11);
    return (uint64_t **)v11;
  }
  return v9;
}

uint64_t *sub_10000D224(uint64_t **a1, uint64_t a2, uint64_t **a3, uint64_t *a4)
{
  *a4 = 0;
  a4[1] = 0;
  a4[2] = a2;
  *a3 = a4;
  int v5 = (uint64_t *)**a1;
  if (v5)
  {
    *a1 = v5;
    a4 = *a3;
  }
  uint64_t result = sub_10000D27C(a1[1], a4);
  a1[2] = (uint64_t *)((char *)a1[2] + 1);
  return result;
}

uint64_t *sub_10000D27C(uint64_t *result, uint64_t *a2)
{
  *((unsigned char *)a2 + 24) = a2 == result;
  if (a2 != result)
  {
    do
    {
      off_t v2 = (uint64_t *)a2[2];
      if (*((unsigned char *)v2 + 24)) {
        return result;
      }
      int v3 = (uint64_t *)v2[2];
      id v4 = (uint64_t *)*v3;
      if ((uint64_t *)*v3 == v2)
      {
        uint64_t v7 = v3[1];
        if (!v7 || (v8 = *(unsigned __int8 *)(v7 + 24), int v5 = (unsigned char *)(v7 + 24), v8))
        {
          if ((uint64_t *)*v2 == a2)
          {
            int v9 = (uint64_t **)a2[2];
          }
          else
          {
            int v9 = (uint64_t **)v2[1];
            int v10 = *v9;
            v2[1] = (uint64_t)*v9;
            if (v10)
            {
              v10[2] = (uint64_t)v2;
              int v3 = (uint64_t *)v2[2];
            }
            v9[2] = v3;
            *(void *)(v2[2] + 8 * (*(void *)v2[2] != (void)v2)) = v9;
            *int v9 = v2;
            v2[2] = (uint64_t)v9;
            int v3 = v9[2];
            off_t v2 = (uint64_t *)*v3;
          }
          *((unsigned char *)v9 + 24) = 1;
          *((unsigned char *)v3 + 24) = 0;
          uint64_t v13 = v2[1];
          uint64_t *v3 = v13;
          if (v13) {
            *(void *)(v13 + 16) = v3;
          }
          v2[2] = v3[2];
          *(void *)(v3[2] + 8 * (*(void *)v3[2] != (void)v3)) = v2;
          v2[1] = (uint64_t)v3;
          goto LABEL_27;
        }
      }
      else if (!v4 || (v6 = *((unsigned __int8 *)v4 + 24), int v5 = v4 + 3, v6))
      {
        if ((uint64_t *)*v2 == a2)
        {
          uint64_t v11 = a2[1];
          *off_t v2 = v11;
          if (v11)
          {
            *(void *)(v11 + 16) = v2;
            int v3 = (uint64_t *)v2[2];
          }
          a2[2] = (uint64_t)v3;
          *(void *)(v2[2] + 8 * (*(void *)v2[2] != (void)v2)) = a2;
          a2[1] = (uint64_t)v2;
          v2[2] = (uint64_t)a2;
          int v3 = (uint64_t *)a2[2];
        }
        else
        {
          a2 = (uint64_t *)a2[2];
        }
        *((unsigned char *)a2 + 24) = 1;
        *((unsigned char *)v3 + 24) = 0;
        off_t v2 = (uint64_t *)v3[1];
        uint64_t v12 = *v2;
        v3[1] = *v2;
        if (v12) {
          *(void *)(v12 + 16) = v3;
        }
        v2[2] = v3[2];
        *(void *)(v3[2] + 8 * (*(void *)v3[2] != (void)v3)) = v2;
        *off_t v2 = (uint64_t)v3;
LABEL_27:
        v3[2] = (uint64_t)v2;
        return result;
      }
      *((unsigned char *)v2 + 24) = 1;
      a2 = v3;
      *((unsigned char *)v3 + 24) = v3 == result;
      *int v5 = 1;
    }
    while (v3 != result);
  }
  return result;
}

void sub_10000D414(uint64_t a1, uint64_t a2)
{
}

void sub_10000D424(uint64_t a1)
{
}

void sub_10000D430(uint64_t a1)
{
  off_t v2 = *(int **)(a1 + 40);
  NSLog(@"Component Validation");
  long long v13 = 0u;
  long long v14 = 0u;
  long long v11 = 0u;
  long long v12 = 0u;
  int v3 = *(void **)(*(void *)(*(void *)(a1 + 32) + 8) + 40);
  id v4 = [v3 countByEnumeratingWithState:&v11 objects:v15 count:16];
  if (v4)
  {
    id v5 = v4;
    uint64_t v6 = *(void *)v12;
    while (2)
    {
      for (uint64_t i = 0; i != v5; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v12 != v6) {
          objc_enumerationMutation(v3);
        }
        if (*v2 == 1)
        {
          int v10 = 0;
          goto LABEL_13;
        }
        id v8 = [*(id *)(*((void *)&v11 + 1) + 8 * i) integerValue];
        uint64_t v9 = CRGetComponentState();
        if ((v9 - 2) <= 2)
        {
          NSLog(@"Component Validation: component %d replacement detected (state %d)", v8, v9);
          int v10 = 3;
          goto LABEL_13;
        }
      }
      id v5 = [v3 countByEnumeratingWithState:&v11 objects:v15 count:16];
      if (v5) {
        continue;
      }
      break;
    }
  }
  int v10 = 4;
LABEL_13:
  *off_t v2 = v10;
}

__CFData *sub_10000D5B0(uint64_t a1, int a2)
{
  off_t v2 = sub_10000D07C((uint64_t **)(a1 + 8), a2);
  if (!(*(unsigned int (**)(uint64_t *))(*v2 + 16))(v2)) {
    return 0;
  }
  int v3 = (*(uint64_t (**)(uint64_t *))(*v2 + 32))(v2);
  Mutable = CFDataCreateMutable(kCFAllocatorDefault, v3);
  int v5 = (*(uint64_t (**)(uint64_t *))(*v2 + 32))(v2);
  CFDataSetLength(Mutable, v5);
  MutableBytePtr = CFDataGetMutableBytePtr(Mutable);
  uint64_t v7 = (*(uint64_t (**)(uint64_t *))(*v2 + 32))(v2);
  (*(void (**)(uint64_t *, UInt8 *, uint64_t))(*v2 + 24))(v2, MutableBytePtr, v7);
  return Mutable;
}

void *sub_10000D6F0(void *a1)
{
  *a1 = off_100095FD0;
  sub_10000BB20(a1 + 1);
  return a1;
}

void sub_10000D734(void *a1)
{
  *a1 = off_100095FD0;
  sub_10000BB20(a1 + 1);

  operator delete();
}

CFStringRef sub_10000D798(uint64_t a1)
{
  if ((dword_1002BBDEC & 8) != 0) {
    return 0;
  }
  sub_10000DCBC(a1);
  if (*(unsigned char *)(a1 + 33) && *(unsigned char *)(a1 + 32))
  {
    CFStringRef result = CFStringCreateWithCString(kCFAllocatorDefault, "PlCl", 0x8000100u);
    if (!result) {
      return result;
    }
    int v3 = result;
    *(void *)(a1 + 40) = AMFDRSealingMapCopyLocalDictForClass();
    CFRelease(v3);
  }
  if (*(unsigned char *)(a1 + 49) && *(unsigned char *)(a1 + 48))
  {
    CFStringRef result = CFStringCreateWithCString(kCFAllocatorDefault, "JpCl", 0x8000100u);
    if (!result) {
      return result;
    }
    id v4 = result;
    *(void *)(a1 + 56) = AMFDRSealingMapCopyLocalDictForClass();
    CFRelease(v4);
  }
  return (CFStringRef)1;
}

void *sub_10000D928(void *a1)
{
  *a1 = off_100096000;
  sub_10000DEFC(a1 + 1);
  return a1;
}

void sub_10000D96C(void *a1)
{
  *a1 = off_100096000;
  sub_10000DEFC(a1 + 1);

  operator delete();
}

void sub_10000D9D0(void *a1)
{
  sub_10000DEFC(a1);

  operator delete();
}

void sub_10000DA08(uint64_t a1, unsigned int a2)
{
  if (a2 <= 0x10 && *(unsigned char *)(a1 + 32)) {
    operator new();
  }
  if (a2 - 17 <= 0xA)
  {
    if (*(unsigned char *)(a1 + 48)) {
      operator new();
    }
  }
  operator new();
}

void sub_10000DB28()
{
}

uint64_t sub_10000DB54(uint64_t a1, unsigned int a2)
{
  *(void *)(a1 + 264) = 0;
  *(void *)(a1 + 272) = 0;
  *(_DWORD *)(a1 + 288) = 0;
  *(void *)(a1 + 280) = 0;
  *(void *)a1 = &off_100096078;
  int v3 = (const char *)(a1 + 8);
  strcpy((char *)(a1 + 8), &aPcic[256 * (unint64_t)a2]);
  CFStringRef v4 = CFStringCreateWithCString(kCFAllocatorDefault, v3, 0x8000100u);
  *(void *)(a1 + 264) = AMFDRSealingMapCopyLocalDataForClass();
  CFRelease(v4);
  if (*(void *)(a1 + 264))
  {
    BytePtr = CFDataGetBytePtr(*(CFDataRef *)(a1 + 264));
    *(void *)(a1 + 272) = BytePtr;
    *(void *)(a1 + 280) = BytePtr;
    *(_DWORD *)(a1 + 288) = CFDataGetLength(*(CFDataRef *)(a1 + 264));
  }
  return a1;
}

void sub_10000DC68(_Unwind_Exception *a1)
{
  sub_10000B8AC(v1);
  _Unwind_Resume(a1);
}

void sub_10000DC84(void *a1)
{
  sub_10000B8AC(a1);

  operator delete();
}

void sub_10000DCBC(uint64_t a1)
{
  if (!byte_1002BBE78)
  {
    byte_1002BBE78 = 1;
    byte_1002BBE7A = 0;
    byte_1002BBE79 = 0;
    byte_1002BBE7C = 0;
    byte_1002BBE7B = 0;
    id v8 = *(const void **)(a1 + 56);
    if (v8)
    {
      CFRelease(v8);
      *(void *)(a1 + 56) = 0;
    }
    uint64_t v9 = *(const void **)(a1 + 40);
    if (v9)
    {
      CFRelease(v9);
      *(void *)(a1 + 40) = 0;
    }
    CFDictionaryRef v10 = IOServiceNameMatching("AppleH16CamIn");
    io_service_t MatchingService = IOServiceGetMatchingService(kIOMainPortDefault, v10);
    CFTypeRef v12 = IORegistryEntrySearchCFProperty(MatchingService, "IOService", @"JasperSNUM", kCFAllocatorDefault, 3u);
    if (v12)
    {
      byte_1002BBE7C = 1;
      CFRelease(v12);
    }
    CFTypeRef v13 = IORegistryEntrySearchCFProperty(MatchingService, "IOService", @"SavageSNUM", kCFAllocatorDefault, 3u);
    if (v13)
    {
      byte_1002BBE7B = 1;
      CFRelease(v13);
    }
    if (byte_1002BBE7B)
    {
      CFStringRef v14 = CFStringCreateWithCString(kCFAllocatorDefault, "PlCl", 0x8000100u);
      if (v14)
      {
        CFStringRef v15 = v14;
        uint64_t v16 = (const void *)AMFDRSealingMapCopyLocalDictForClass();
        CFRelease(v15);
        byte_1002BBE79 = v16 != 0;
        if (v16) {
          CFRelease(v16);
        }
      }
    }
    if (byte_1002BBE7C)
    {
      CFStringRef v17 = CFStringCreateWithCString(kCFAllocatorDefault, "JpCl", 0x8000100u);
      if (v17)
      {
        CFStringRef v18 = v17;
        CFDictionaryRef v19 = (const void *)AMFDRSealingMapCopyLocalDictForClass();
        CFRelease(v18);
        byte_1002BBE7A = v19 != 0;
        if (v19) {
          CFRelease(v19);
        }
      }
    }
  }
  int v2 = byte_1002BBE79;
  *(unsigned char *)(a1 + 32) = byte_1002BBE79;
  int v3 = byte_1002BBE7A;
  *(unsigned char *)(a1 + 48) = byte_1002BBE7A;
  int v4 = byte_1002BBE7B;
  *(unsigned char *)(a1 + 33) = byte_1002BBE7B;
  int v5 = byte_1002BBE7C;
  *(unsigned char *)(a1 + 49) = byte_1002BBE7C;
  if (v2) {
    uint64_t v6 = "unified";
  }
  else {
    uint64_t v6 = "not unified";
  }
  if (!v4) {
    uint64_t v6 = "unavailable";
  }
  if (v3) {
    uint64_t v7 = "unified";
  }
  else {
    uint64_t v7 = "not unified";
  }
  if (!v5) {
    uint64_t v7 = "unavailable";
  }
  NSLog(@"Pearl FDR is %s, ToF FDR is %s", v6, v7);
}

uint64_t sub_10000DEFC(void *a1)
{
  *a1 = off_100096020;
  int v2 = (const void *)a1[5];
  if (v2) {
    CFRelease(v2);
  }
  int v3 = (const void *)a1[7];
  if (v3) {
    CFRelease(v3);
  }

  return sub_10000BB80((uint64_t)a1);
}

uint64_t sub_10000DF68(uint64_t a1)
{
  *(void *)a1 = off_100095E90;
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 40) = 0;
  *(void *)(a1 + 24) = 0;
  *(void *)(a1 + 8) = off_100095EC0;
  *(void *)(a1 + 16) = a1 + 24;
  *(unsigned char *)(a1 + 48) = 0;
  *(unsigned char *)(a1 + 64) = 0;
  *(unsigned char *)(a1 + 80) = 0;
  *(unsigned char *)(a1 + 80) = sub_10000C1E0(a1 + 8);
  return a1;
}

void sub_10000DFEC(_Unwind_Exception *a1)
{
  sub_10000C134(v1);
  _Unwind_Resume(a1);
}

void sub_10000E000(void *a1)
{
  *a1 = off_100095E90;
  sub_10000C134((uint64_t)(a1 + 1));

  operator delete();
}

uint64_t sub_10000E064(uint64_t a1, _WORD *a2)
{
  int v3 = sub_10000D07C((uint64_t **)(a1 + 8), 14);
  uint64_t result = (*(uint64_t (**)(uint64_t *))(*v3 + 16))(v3);
  if (result)
  {
    (*(void (**)(uint64_t *, int *, uint64_t))(*v3 + 24))(v3, &v6, 4);
    if (v6 == 0x1000000)
    {
      uint64_t result = sub_10000E124((const char *)v3, (uint64_t)v5);
      if (result) {
        *a2 = v5[3];
      }
    }
    else
    {
      return 0;
    }
  }
  return result;
}

BOOL sub_10000E124(const char *a1, uint64_t a2)
{
  int v4 = (*(uint64_t (**)(const char *))(*(void *)a1 + 32))(a1);
  int v5 = v4;
  if (v4 == 8) {
    (*(void (**)(const char *, uint64_t, uint64_t))(*(void *)a1 + 24))(a1, a2, 8);
  }
  else {
    printf("Expected file %s to be of size %ld. Actual size: %d\n", a1 + 8, 8, v4);
  }
  return v5 == 8;
}

uint64_t sub_10000E1E0(uint64_t a1, void *a2)
{
  int v3 = sub_10000D07C((uint64_t **)(a1 + 8), 13);
  if ((*(unsigned int (**)(uint64_t *))(*v3 + 16))(v3))
  {
    (*(void (**)(uint64_t *, int *, uint64_t))(*v3 + 24))(v3, &v5, 4);
    if (v5 == 50331648)
    {
      (*(void (**)(uint64_t *, unsigned char *, uint64_t))(*v3 + 24))(v3, v6, 125);
      *a2 = bswap32(v7) >> 16;
      operator new[]();
    }
  }
  return 0;
}

BOOL sub_10000E34C(const char *a1, uint64_t a2)
{
  int v4 = (*(uint64_t (**)(const char *))(*(void *)a1 + 32))(a1);
  int v5 = v4;
  if (v4 == 96) {
    (*(void (**)(const char *, uint64_t, uint64_t))(*(void *)a1 + 24))(a1, a2, 96);
  }
  else {
    printf("Expected file %s to be of size %ld. Actual size: %d\n", a1 + 8, 96, v4);
  }
  return v5 == 96;
}

BOOL sub_10000E408()
{
  __chkstk_darwin();
  uint64_t v1 = v0;
  BOOL v3 = sub_10000E6AC(v2, (uint64_t)&v9);
  if (v3)
  {
    uint64_t v4 = 0;
    double v5 = *(double *)v1;
    *(float64x2_t *)(v1 + 8) = vmulq_n_f64(v9, *(double *)v1);
    *(double *)(v1 + 24) = v5 * v10;
    int v6 = (float64x2_t *)v1;
    do
    {
      unsigned __int16 v7 = (const double *)&v11[v4];
      float64x2x2_t v12 = vld2q_f64(v7);
      v6[2] = vmulq_n_f64(v12.val[0], v5);
      v6[130] = vmulq_n_f64(v12.val[1], v5);
      v4 += 32;
      ++v6;
    }
    while (v4 != 4096);
    bzero((void *)(v1 + 4128), 0x40uLL);
    bzero((void *)(v1 + 4192), 0x40uLL);
  }
  return v3;
}

BOOL sub_10000E4E0()
{
  __chkstk_darwin();
  uint64_t v1 = v0;
  BOOL v3 = sub_10000E6AC(v2, (uint64_t)&v8);
  if (v3)
  {
    uint64_t v4 = 0;
    double v5 = *(double *)v1;
    *(float64x2_t *)(v1 + 8) = vmulq_n_f64(v8, *(double *)v1);
    *(double *)(v1 + 24) = v5 * v9;
    do
    {
      int v6 = (float64x2_t *)(v1 + v4);
      v6[2] = vmulq_n_f64(*(float64x2_t *)&v10[v4], v5);
      v6[130] = vmulq_n_f64(*(float64x2_t *)&v10[v4 + 2048], v5);
      v4 += 16;
    }
    while (v4 != 2048);
    bzero((void *)(v1 + 4128), 0x40uLL);
    bzero((void *)(v1 + 4192), 0x40uLL);
  }
  return v3;
}

double sub_10000E5B8()
{
  __chkstk_darwin();
  uint64_t v1 = v0;
  if (sub_10000E770(v2, (uint64_t)&v11))
  {
    uint64_t v4 = 0;
    double v5 = *(double *)v1;
    *(float64x2_t *)(v1 + 8) = vmulq_n_f64(v11, *(double *)v1);
    *(double *)(v1 + 24) = v5 * v12;
    do
    {
      int v6 = (float64x2_t *)(v1 + v4);
      v6[2] = vmulq_n_f64(*(float64x2_t *)&v13[v4], v5);
      v6[130] = vmulq_n_f64(*(float64x2_t *)&v13[v4 + 2048], v5);
      v4 += 16;
    }
    while (v4 != 2048);
    long long v7 = v15;
    *(_OWORD *)(v1 + 4128) = v14;
    *(_OWORD *)(v1 + 4144) = v7;
    long long v8 = v17;
    *(_OWORD *)(v1 + 4160) = v16;
    *(_OWORD *)(v1 + 4176) = v8;
    long long v9 = v19;
    *(_OWORD *)(v1 + 4192) = v18;
    *(_OWORD *)(v1 + 4208) = v9;
    double result = *(double *)&v20;
    long long v10 = v21;
    *(_OWORD *)(v1 + 4224) = v20;
    *(_OWORD *)(v1 + 4240) = v10;
  }
  return result;
}

BOOL sub_10000E6AC(const char *a1, uint64_t a2)
{
  int v4 = (*(uint64_t (**)(const char *))(*(void *)a1 + 32))(a1);
  int v5 = v4;
  if (v4 == 4144) {
    (*(void (**)(const char *, uint64_t, uint64_t))(*(void *)a1 + 24))(a1, a2, 4144);
  }
  else {
    printf("Expected file %s to be of size %ld. Actual size: %d\n", a1 + 8, 4144, v4);
  }
  return v5 == 4144;
}

BOOL sub_10000E770(const char *a1, uint64_t a2)
{
  int v4 = (*(uint64_t (**)(const char *))(*(void *)a1 + 32))(a1);
  int v5 = v4;
  if (v4 == 4248) {
    (*(void (**)(const char *, uint64_t, uint64_t))(*(void *)a1 + 24))(a1, a2, 4248);
  }
  else {
    printf("Expected file %s to be of size %ld. Actual size: %d\n", a1 + 8, 4248, v4);
  }
  return v5 == 4248;
}

uint64_t sub_10000E834(uint64_t a1)
{
  int v2 = (void *)sub_10000DF68(a1);
  *int v2 = off_100096100;
  sub_10000E8AC((uint64_t)v2);
  return a1;
}

void sub_10000E87C(_Unwind_Exception *a1)
{
  void *v1 = off_100095E90;
  sub_10000C134((uint64_t)(v1 + 1));
  _Unwind_Resume(a1);
}

void sub_10000E8AC(uint64_t a1)
{
  *(unsigned char *)(a1 + 81) = 0;
  uint64_t v1 = (char *)(a1 + 81);
  CFDictionaryRef v2 = IOServiceNameMatching("AppleH16CamIn");
  io_service_t MatchingService = IOServiceGetMatchingService(kIOMainPortDefault, v2);
  CFDataRef v4 = (const __CFData *)IORegistryEntrySearchCFProperty(MatchingService, "IOService", @"JasperSNUM", kCFAllocatorDefault, 3u);
  if (!v4) {
    return;
  }
  CFDataRef v5 = v4;
  CFTypeID v6 = CFGetTypeID(v4);
  if (v6 == CFDataGetTypeID())
  {
    BytePtr = (const char *)CFDataGetBytePtr(v5);
    goto LABEL_7;
  }
  CFTypeID v8 = CFGetTypeID(v5);
  if (v8 == CFStringGetTypeID())
  {
    BytePtr = CFStringGetCStringPtr((CFStringRef)v5, 0x8000100u);
LABEL_7:
    if (BytePtr) {
      strncpy(v1, BytePtr, 0x20uLL);
    }
  }

  CFRelease(v5);
}

void sub_10000E9A8(void *a1)
{
  *a1 = off_100095E90;
  sub_10000C134((uint64_t)(a1 + 1));

  operator delete();
}

double sub_10000EA0C(uint64_t a1, uint64_t a2)
{
  CFDataRef v4 = sub_10000D07C((uint64_t **)(a1 + 8), 0);
  if ((*(unsigned int (**)(uint64_t *))(*v4 + 16))(v4))
  {
    (*(void (**)(uint64_t *, int *, uint64_t))(*v4 + 24))(v4, &v6, 4);
    switch(v6)
    {
      case 1:
        if (sub_10000F18C((const char *)v4, (uint64_t)&v7)) {
          goto LABEL_8;
        }
        break;
      case 2:
        if (sub_10000F248((const char *)v4, (uint64_t)&v7)) {
          goto LABEL_8;
        }
        break;
      case 3:
        if (sub_10000F304((const char *)v4, (uint64_t)&v7))
        {
LABEL_8:
          *(_DWORD *)(a2 + 4280) = v7;
          double result = v8;
          *(double *)(a2 + 24) = v8;
        }
        break;
      case 4:
        double result = sub_10000F108(a1, (const char *)v4, a2);
        break;
      default:
        return result;
    }
  }
  return result;
}

void sub_10000EB54(uint64_t a1)
{
  uint64_t v1 = sub_10000D07C((uint64_t **)(a1 + 8), 2);
  if ((*(unsigned int (**)(uint64_t *))(*v1 + 16))(v1))
  {
    (*(void (**)(uint64_t *, int *, uint64_t))(*v1 + 24))(v1, &v2, 4);
    switch(v2)
    {
      case 3:
        sub_10000E5B8();
        break;
      case 2:
        sub_10000E4E0();
        break;
      case 1:
        sub_10000E408();
        break;
    }
  }
}

void sub_10000EC4C(uint64_t a1, uint64_t a2)
{
  CFDataRef v4 = sub_10000D07C((uint64_t **)(a1 + 8), 1);
  if ((*(unsigned int (**)(uint64_t *))(*v4 + 16))(v4))
  {
    (*(void (**)(uint64_t *, int *, uint64_t))(*v4 + 24))(v4, &v5, 4);
    if (v5 == 3)
    {
      sub_10000F4DC(a1, (const char *)v4, a2);
    }
    else if (v5 == 2)
    {
      sub_10000F47C(a1, (const char *)v4, a2);
    }
    else if (v5 == 1 && sub_10000F18C((const char *)v4, (uint64_t)&v6))
    {
      *(_DWORD *)(a2 + 8544) = v6;
      *(void *)(a2 + 4288) = v7;
      *(void *)(a2 + 8760) = 0;
      *(void *)(a2 + 8776) = 0;
      *(void *)(a2 + 8768) = 0;
    }
  }
}

uint64_t sub_10000ED68(uint64_t a1, uint64_t a2)
{
  BOOL v3 = sub_10000D07C((uint64_t **)(a1 + 8), 5);
  uint64_t result = (*(uint64_t (**)(uint64_t *))(*v3 + 16))(v3);
  if (result)
  {
    (*(void (**)(uint64_t *, int *, uint64_t))(*v3 + 24))(v3, &v7, 4);
    if (v7 == 1)
    {
      uint64_t result = sub_10000F548((const char *)v3, (uint64_t)&v5);
      if (result)
      {
        *(_OWORD *)a2 = v5;
        *(void *)(a2 + 16) = v6;
      }
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t sub_10000EE2C(uint64_t a1, uint64_t a2)
{
  BOOL v3 = sub_10000D07C((uint64_t **)(a1 + 8), 6);
  uint64_t result = (*(uint64_t (**)(uint64_t *))(*v3 + 16))(v3);
  if (result)
  {
    (*(void (**)(uint64_t *, int *, uint64_t))(*v3 + 24))(v3, &v8, 4);
    if (v8 == 1)
    {
      uint64_t result = sub_10000F604((const char *)v3, (uint64_t)&v5);
      if (result)
      {
        *(void *)a2 = v5;
        *(_OWORD *)(a2 + 8) = v6;
        *(void *)(a2 + 24) = v7;
      }
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t sub_10000EEF8(uint64_t a1, uint64_t a2)
{
  memcpy((void *)(a2 + 8784), (const void *)(a2 + 24), 0x10A8uLL);
  uint64_t v3 = 0;
  CFDataRef v4 = (double *)(a2 + 13048);
  do
  {
    uint64_t v5 = 0;
    long long v6 = v4;
    do
    {
      if (v3 == v5) {
        double v7 = 1.0;
      }
      else {
        double v7 = 0.0;
      }
      double *v6 = v7;
      v6 += 3;
      ++v5;
    }
    while (v5 != 3);
    ++v3;
    ++v4;
  }
  while (v3 != 3);
  *(_OWORD *)(a2 + 13120) = *(_OWORD *)(a2 + 8648);
  *(void *)(a2 + 13136) = *(void *)(a2 + 8664);
  if (*(double *)(a2 + 8768) == 0.0 && *(double *)(a2 + 8776) == 0.0)
  {
    double v8 = *(double *)(a2 + 4296);
    if (v8 != 0.0) {
      *(double *)(a2 + 8768) = v8;
    }
  }
  return 1;
}

uint64_t sub_10000EFB0(uint64_t a1)
{
  uint64_t v1 = sub_10000D07C((uint64_t **)(a1 + 8), 12);
  if ((*(unsigned int (**)(uint64_t *))(*v1 + 16))(v1))
  {
    (*(void (**)(uint64_t *))(*v1 + 32))(v1);
    operator new[]();
  }
  return 0;
}

double sub_10000F108(uint64_t a1, const char *a2, uint64_t a3)
{
  if (sub_10000F3C0(a2, (uint64_t)&v6))
  {
    *(_DWORD *)(a3 + 4280) = v6;
    double v5 = v7;
    *(double *)(a3 + 24) = v7;
    *(void *)(a3 + 8712) = v10;
    *(double *)(a3 + 8720) = v5 * v8;
    *(double *)(a3 + 8728) = v5 * v9;
    *(double *)(a3 + 8736) = v5 * v12;
    double result = v5 * v11;
    *(double *)(a3 + 8744) = result;
    *(double *)(a3 + 8752) = result;
  }
  return result;
}

BOOL sub_10000F18C(const char *a1, uint64_t a2)
{
  int v4 = (*(uint64_t (**)(const char *))(*(void *)a1 + 32))(a1);
  int v5 = v4;
  if (v4 == 12) {
    (*(void (**)(const char *, uint64_t, uint64_t))(*(void *)a1 + 24))(a1, a2, 12);
  }
  else {
    printf("Expected file %s to be of size %ld. Actual size: %d\n", a1 + 8, 12, v4);
  }
  return v5 == 12;
}

BOOL sub_10000F248(const char *a1, uint64_t a2)
{
  int v4 = (*(uint64_t (**)(const char *))(*(void *)a1 + 32))(a1);
  int v5 = v4;
  if (v4 == 20) {
    (*(void (**)(const char *, uint64_t, uint64_t))(*(void *)a1 + 24))(a1, a2, 20);
  }
  else {
    printf("Expected file %s to be of size %ld. Actual size: %d\n", a1 + 8, 20, v4);
  }
  return v5 == 20;
}

BOOL sub_10000F304(const char *a1, uint64_t a2)
{
  int v4 = (*(uint64_t (**)(const char *))(*(void *)a1 + 32))(a1);
  int v5 = v4;
  if (v4 == 36) {
    (*(void (**)(const char *, uint64_t, uint64_t))(*(void *)a1 + 24))(a1, a2, 36);
  }
  else {
    printf("Expected file %s to be of size %ld. Actual size: %d\n", a1 + 8, 36, v4);
  }
  return v5 == 36;
}

BOOL sub_10000F3C0(const char *a1, uint64_t a2)
{
  int v4 = (*(uint64_t (**)(const char *))(*(void *)a1 + 32))(a1);
  int v5 = v4;
  if (v4 == 84) {
    (*(void (**)(const char *, uint64_t, uint64_t))(*(void *)a1 + 24))(a1, a2, 84);
  }
  else {
    printf("Expected file %s to be of size %ld. Actual size: %d\n", a1 + 8, 84, v4);
  }
  return v5 == 84;
}

double sub_10000F47C(uint64_t a1, const char *a2, uint64_t a3)
{
  if (sub_10000F248(a2, (uint64_t)&v5))
  {
    *(_DWORD *)(a3 + 8544) = v5;
    *(void *)(a3 + 4288) = v6;
    *(void *)(a3 + 8760) = v7;
    double result = 0.0;
    *(_OWORD *)(a3 + 8768) = 0u;
  }
  return result;
}

double sub_10000F4DC(uint64_t a1, const char *a2, uint64_t a3)
{
  if (sub_10000F304(a2, (uint64_t)&v7))
  {
    *(_DWORD *)(a3 + 8544) = v7;
    double v5 = v8;
    uint64_t v6 = v9;
    *(double *)(a3 + 4288) = v8;
    *(void *)(a3 + 8760) = v6;
    *(double *)(a3 + 8768) = v5 * v10;
    double result = v5 * v11;
    *(double *)(a3 + 8776) = result;
  }
  return result;
}

BOOL sub_10000F548(const char *a1, uint64_t a2)
{
  int v4 = (*(uint64_t (**)(const char *))(*(void *)a1 + 32))(a1);
  int v5 = v4;
  if (v4 == 24) {
    (*(void (**)(const char *, uint64_t, uint64_t))(*(void *)a1 + 24))(a1, a2, 24);
  }
  else {
    printf("Expected file %s to be of size %ld. Actual size: %d\n", a1 + 8, 24, v4);
  }
  return v5 == 24;
}

BOOL sub_10000F604(const char *a1, uint64_t a2)
{
  int v4 = (*(uint64_t (**)(const char *))(*(void *)a1 + 32))(a1);
  int v5 = v4;
  if (v4 == 32) {
    (*(void (**)(const char *, uint64_t, uint64_t))(*(void *)a1 + 24))(a1, a2, 32);
  }
  else {
    printf("Expected file %s to be of size %ld. Actual size: %d\n", a1 + 8, 32, v4);
  }
  return v5 == 32;
}

double sub_10000F6C0(uint64_t a1, uint64_t a2)
{
  int v4 = sub_10000D07C((uint64_t **)(a1 + 8), 0);
  if ((*(unsigned int (**)(uint64_t *))(*v4 + 16))(v4))
  {
    (*(void (**)(uint64_t *, int *, uint64_t))(*v4 + 24))(v4, &v6, 4);
    switch(v6)
    {
      case 1:
        if (sub_10000F18C((const char *)v4, (uint64_t)&v7)) {
          goto LABEL_8;
        }
        break;
      case 2:
        if (sub_10000F248((const char *)v4, (uint64_t)&v7)) {
          goto LABEL_8;
        }
        break;
      case 3:
        if (sub_10000F304((const char *)v4, (uint64_t)&v7))
        {
LABEL_8:
          *(_DWORD *)(a2 + 4280) = v7;
          double result = v8;
          *(double *)(a2 + 24) = v8;
        }
        break;
      case 4:
        double result = sub_10000F108(a1, (const char *)v4, a2);
        break;
      default:
        return result;
    }
  }
  return result;
}

BOOL sub_10000F808(uint64_t a1, unsigned int a2, __CFDictionary *a3)
{
  int v5 = sub_10000D5B0(a1, a2);
  if (v5)
  {
    CFDictionarySetValue(a3, +[NSString stringWithUTF8String:&aPcic[256 * (unint64_t)a2]], v5);
    CFRelease(v5);
  }
  else
  {
    NSLog(@"%s: couldn't open input", &aPcic[256 * (unint64_t)a2]);
  }
  return v5 != 0;
}

uint64_t sub_10000F8A8(uint64_t a1)
{
  int v2 = (void *)sub_10000F920(a1);
  *int v2 = off_100096138;
  sub_10000F9B0((uint64_t)v2);
  return a1;
}

void sub_10000F8F0(_Unwind_Exception *a1)
{
  void *v1 = off_100095FD0;
  sub_10000BB20(v1 + 1);
  _Unwind_Resume(a1);
}

uint64_t sub_10000F920(uint64_t a1)
{
  *(void *)a1 = off_100095FD0;
  *(void *)(a1 + 24) = 0;
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 40) = 0;
  *(void *)(a1 + 8) = off_100095D38;
  *(void *)(a1 + 16) = a1 + 24;
  *(unsigned char *)(a1 + 48) = 0;
  *(unsigned char *)(a1 + 48) = sub_100008CB4();
  return a1;
}

void sub_10000F99C(_Unwind_Exception *a1)
{
  sub_10000BB20(v1);
  _Unwind_Resume(a1);
}

void sub_10000F9B0(uint64_t a1)
{
  *(unsigned char *)(a1 + 49) = 0;
  uint64_t v1 = (char *)(a1 + 49);
  CFDictionaryRef v2 = IOServiceNameMatching("AppleH16CamIn");
  io_service_t MatchingService = IOServiceGetMatchingService(kIOMainPortDefault, v2);
  CFDataRef v4 = (const __CFData *)IORegistryEntrySearchCFProperty(MatchingService, "IOService", @"JasperSNUM", kCFAllocatorDefault, 3u);
  if (!v4) {
    return;
  }
  CFDataRef v5 = v4;
  CFTypeID v6 = CFGetTypeID(v4);
  if (v6 == CFDataGetTypeID())
  {
    BytePtr = (const char *)CFDataGetBytePtr(v5);
    goto LABEL_7;
  }
  CFTypeID v8 = CFGetTypeID(v5);
  if (v8 == CFStringGetTypeID())
  {
    BytePtr = CFStringGetCStringPtr((CFStringRef)v5, 0x8000100u);
LABEL_7:
    if (BytePtr) {
      strncpy(v1, BytePtr, 0x20uLL);
    }
  }

  CFRelease(v5);
}

void sub_10000FAAC(void *a1)
{
  *a1 = off_100095FD0;
  sub_10000BB20(a1 + 1);

  operator delete();
}

uint64_t sub_10000FB10()
{
  byte_1002BBDE8 = sub_100022CF0(@"FdrForTof", @"com.apple.coremedia", 1) != 0;
  dword_1002BBDF0 = 0;
  qword_1002BBDF8 = 0;

  return __cxa_atexit((void (*)(void *))sub_100009D74, &dword_1002BBDF0, (void *)&_mh_execute_header);
}

BOOL sub_10000FB84()
{
  sub_100010914(__p, "JYKY");
  CFDictionaryRef v0 = IOServiceNameMatching("product");
  io_service_t MatchingService = IOServiceGetMatchingService(kIOMainPortDefault, v0);
  io_object_t v2 = MatchingService;
  if (!MatchingService)
  {
    BOOL v15 = 1;
    goto LABEL_44;
  }
  CFDataRef v3 = (const __CFData *)IORegistryEntrySearchCFProperty(MatchingService, "IOService", @"rosaline-serial-num", kCFAllocatorDefault, 3u);
  CFDataRef v4 = v3;
  if (v3)
  {
    BytePtr = CFDataGetBytePtr(v3);
    int Length = CFDataGetLength(v4);
    sub_100010914(&v23, "");
    if (Length)
    {
      for (int i = 0; i != Length; ++i)
      {
        int v9 = *BytePtr++;
        std::string::value_type v8 = v9;
        if (!v9) {
          break;
        }
        if ((i - 11) <= 3) {
          std::string::push_back(&v23, v8);
        }
      }
    }
    uint64_t v10 = HIBYTE(v23.__r_.__value_.__r.__words[2]);
    if ((v23.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      std::string::size_type size = HIBYTE(v23.__r_.__value_.__r.__words[2]);
    }
    else {
      std::string::size_type size = v23.__r_.__value_.__l.__size_;
    }
    unint64_t v12 = v25;
    if ((v25 & 0x80u) != 0) {
      unint64_t v12 = (unint64_t)__p[1];
    }
    if (size == v12)
    {
      if ((v25 & 0x80u) == 0) {
        CFTypeRef v13 = __p;
      }
      else {
        CFTypeRef v13 = (void **)__p[0];
      }
      if ((*((unsigned char *)&v23.__r_.__value_.__s + 23) & 0x80) == 0)
      {
        if (*((unsigned char *)&v23.__r_.__value_.__s + 23))
        {
          long long v14 = &v23;
          while (v14->__r_.__value_.__s.__data_[0] == *(unsigned __int8 *)v13)
          {
            long long v14 = (std::string *)((char *)v14 + 1);
            CFTypeRef v13 = (void **)((char *)v13 + 1);
            if (!--v10) {
              goto LABEL_28;
            }
          }
          goto LABEL_27;
        }
LABEL_28:
        CFDictionaryRef v18 = IOServiceNameMatching("AppleProxHIDEventDriver");
        io_service_t v19 = IOServiceGetMatchingService(kIOMainPortDefault, v18);
        io_object_t v16 = v19;
        if (v19)
        {
          CFNumberRef v20 = (const __CFNumber *)IORegistryEntrySearchCFProperty(v19, "IOService", @"floodComplianceRevision", kCFAllocatorDefault, 3u);
          CFNumberRef v17 = v20;
          if (v20)
          {
            int valuePtr = 0;
            if (CFNumberGetValue(v20, kCFNumberSInt32Type, &valuePtr))
            {
              BOOL v15 = (valuePtr & 0xC0) != 0;
              goto LABEL_36;
            }
            NSLog(@"Error converting vader compliance value\n");
          }
          else
          {
            NSLog(@"Couldn't read vader compliance\n");
            CFNumberRef v17 = 0;
          }
        }
        else
        {
          NSLog(@"Unable to find prox service");
          CFNumberRef v17 = 0;
          io_object_t v16 = 0;
        }
        BOOL v15 = 0;
LABEL_36:
        if (SHIBYTE(v23.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v23.__r_.__value_.__l.__data_);
        }
        goto LABEL_38;
      }
      if (!memcmp(v23.__r_.__value_.__l.__data_, v13, v23.__r_.__value_.__l.__size_)) {
        goto LABEL_28;
      }
    }
LABEL_27:
    CFNumberRef v17 = 0;
    io_object_t v16 = 0;
    BOOL v15 = 1;
    goto LABEL_36;
  }
  io_object_t v16 = 0;
  CFNumberRef v17 = 0;
  BOOL v15 = 1;
LABEL_38:
  IOObjectRelease(v2);
  if (v4) {
    CFRelease(v4);
  }
  if (v16) {
    IOObjectRelease(v16);
  }
  if (v17) {
    CFRelease(v17);
  }
LABEL_44:
  if ((char)v25 < 0) {
    operator delete(__p[0]);
  }
  return v15;
}

void sub_10000FE2C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, void *a17, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  if (a22 < 0) {
    operator delete(a17);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10000FE78()
{
  uint64_t v0 = __chkstk_darwin();
  uint64_t v1 = 0;
  io_object_t v2 = (_DWORD *)(*(void *)(v0 + 4384) + 8);
  int v3 = -1;
  int v4 = -1;
  do
  {
    int v5 = v2[2];
    if (v5 == 1785950322)
    {
      if (*v2) {
        int v4 = v1;
      }
    }
    else if (v5 == 1718186595 && *v2)
    {
      int v3 = v1;
    }
    ++v1;
    v2 += 24;
  }
  while (v1 != 6);
  if (v3 == -1)
  {
    NSLog(@"Found no IR sensor\n");
    goto LABEL_67;
  }
  CFDictionaryRef v6 = IOServiceNameMatching("AppleH16CamIn");
  io_service_t MatchingService = IOServiceGetMatchingService(kIOMainPortDefault, v6);
  CFTypeRef v8 = IORegistryEntrySearchCFProperty(MatchingService, "IOService", @"SavageSNUM", kCFAllocatorDefault, 3u);
  if (v8)
  {
    CFRelease(v8);
    int v9 = 0;
  }
  else
  {
    NSLog(@"LoadPDEFiles: No Savage found. Never mind");
    int v9 = 8;
  }
  BOOL v10 = sub_100009C70();
  BOOL v11 = v10;
  NSLog(@"LoadPDEFiles: isOverridden %d", v10);
  id v50 = 0;
  sub_100010914(&v49, "");
  id v12 = [[+[MSUDataAccessor sharedDataAccessor](MSUDataAccessor, "sharedDataAccessor") copyPathForPersistentData:101 error:&v50];
  if (v50)
  {

    if (!v11) {
      NSLog(@"Could not find SEP reference location. Will use ISP references");
    }
  }
  else
  {
    CFTypeRef v13 = v12;
    sub_100010B30(&v49, (char *)[v12 UTF8String]);
    std::string::append(&v49, "/", 1uLL);

    if (!v11)
    {
      sub_1000105F4((const void **)&v49.__r_.__value_.__l.__data_, 5, __p);
      if ((__p[0].__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        long long v14 = __p;
      }
      else {
        long long v14 = (std::string *)__p[0].__r_.__value_.__r.__words[0];
      }
      BOOL v15 = fopen((const char *)v14, "r");
      int v16 = SHIBYTE(__p[0].__r_.__value_.__r.__words[2]);
      if (v15)
      {
        CFNumberRef v17 = (std::string *)__p[0].__r_.__value_.__r.__words[0];
        if ((__p[0].__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          CFNumberRef v17 = __p;
        }
        NSLog(@"Found reference plist at %s. Will use SEP references", v17);
        v9 |= 1u;
        fclose(v15);
      }
      else
      {
        std::string::size_type v18 = __p[0].__r_.__value_.__r.__words[0];
        io_service_t v19 = __error();
        CFNumberRef v20 = __p;
        if (v16 < 0) {
          CFNumberRef v20 = (std::string *)v18;
        }
        NSLog(@"Could not find reference plist at %s (errno: %d). Will use ISP references", v20, *v19);
      }
      if (SHIBYTE(__p[0].__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p[0].__r_.__value_.__l.__data_);
      }
    }
  }
  sub_10004E454(v0, outputStruct);
  int v21 = outputStruct[11];
  int v22 = sub_1000564EC(v0);
  if (v21) {
    int v23 = v9 | 2;
  }
  else {
    int v23 = v9;
  }
  if (v22) {
    int v24 = 4;
  }
  else {
    int v24 = 16;
  }
  sub_1000092F0(v23 | v24);
  sub_100009B1C();
  __p[0].__r_.__value_.__r.__words[0] = 0;
  if (sub_100009514((off_t *)__p)) {
    operator new[]();
  }
  NSLog(@"Error: Couldn't send NVM\n");
  bzero(__p, 0x14uLL);
  NSLog(@"Reading rosaline serial number from sysconfig\n");
  CFDictionaryRef v25 = IOServiceNameMatching("product");
  io_service_t v26 = IOServiceGetMatchingService(kIOMainPortDefault, v25);
  CFDataRef v27 = (const __CFData *)IORegistryEntrySearchCFProperty(v26, "IOService", @"rosaline-serial-num", kCFAllocatorDefault, 3u);
  CFDataRef v28 = v27;
  if (!v27)
  {
    NSLog(@"Couldn't read serial number\n");
    goto LABEL_54;
  }
  BytePtr = CFDataGetBytePtr(v27);
  unsigned int Length = CFDataGetLength(v28);
  memcpy(&__p[0].__r_.__value_.__s.__data_[2], BytePtr, Length);
  NSLog(@"Reading rosaline power from FDR\n");
  LOBYTE(BytePtr) = sub_1000092FC(__p);
  CFRelease(v28);
  if ((BytePtr & 1) == 0)
  {
    NSLog(@"Reading rosaline power from IOReg\n");
    CFDictionaryRef v31 = IOServiceNameMatching("AppleProxHIDEventDriver");
    io_service_t v32 = IOServiceGetMatchingService(kIOMainPortDefault, v31);
    CFNumberRef v33 = (const __CFNumber *)IORegistryEntrySearchCFProperty(v32, "IOService", @"floodCalibrationCurrent", kCFAllocatorDefault, 3u);
    CFNumberRef v34 = v33;
    if (v33)
    {
      unsigned int valuePtr = 0;
      if (CFNumberGetValue(v33, kCFNumberSInt32Type, &valuePtr))
      {
        LOWORD(__p[0].__r_.__value_.__l.__data_) = valuePtr;
        if (valuePtr < 0x10000)
        {
          CFRelease(v34);
          goto LABEL_51;
        }
        NSLog(@"Error converting calibrated power value:  could not fit 32-bit value into 16-bit destination \n");
      }
      else
      {
        NSLog(@"Error converting calibrated power value\n");
      }
      CFRelease(v34);
    }
    else
    {
      NSLog(@"Could not read calibrated power from IOReg\n");
    }
    NSLog(@"Reading rosaline power from sysconfig\n");
    CFDictionaryRef v35 = IOServiceNameMatching("isp");
    io_service_t v36 = IOServiceGetMatchingService(kIOMainPortDefault, v35);
    CFDataRef v37 = (const __CFData *)IORegistryEntrySearchCFProperty(v36, "IOService", @"rosaline-calibration-current", kCFAllocatorDefault, 3u);
    CFDataRef v38 = v37;
    if (!v37)
    {
      NSLog(@"Could not read calibrated power from sysconfig\n");
      goto LABEL_54;
    }
    LOWORD(__p[0].__r_.__value_.__l.__data_) = *((_WORD *)CFDataGetBytePtr(v37) + 1);
    CFRelease(v38);
  }
LABEL_51:
  NSLog(@"Sending rosaline configuration: SN: %s; Power: %d\n",
    &__p[0].__r_.__value_.__s.__data_[2],
    LOWORD(__p[0].__r_.__value_.__l.__data_));
  uint64_t v39 = sub_1000558E0(v0, v3, (uint64_t)__p, 0x14u, 6u);
  if (!v39) {
    goto LABEL_55;
  }
  NSLog(@"Failed to send rosaline data file: 0x%08X\n", v39);
LABEL_54:
  NSLog(@"Error: Couldn't send rosaline configuration\n");
LABEL_55:
  bzero(__p, 0x3370uLL);
  if ((sub_100009D78() & 1) == 0)
  {
    NSLog(@"Failed to read PCE Calibration (FDR data)\n");
    goto LABEL_64;
  }
  if (v23) {
    uint64_t v40 = &v49;
  }
  else {
    uint64_t v40 = (std::string *)qword_1002BBE00;
  }
  if (sub_100010740(v0, (const void **)&v40->__r_.__value_.__l.__data_, v3))
  {
    NSLog(@"Failed to send references to FW\n");
LABEL_64:
    if (SHIBYTE(v49.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v49.__r_.__value_.__l.__data_);
    }
    NSLog(@"Failed to load PDE files\n");
    goto LABEL_67;
  }
  if (sub_1000558E0(v0, v3, (uint64_t)__p, 0x3370u, 0xFFu))
  {
    NSLog(@"Failed to send PCE calibration to FW\n");
    goto LABEL_64;
  }
  if (SHIBYTE(v49.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v49.__r_.__value_.__l.__data_);
  }
LABEL_67:
  if (v4 != -1)
  {
    sub_10004E454(v0, __p);
    int v41 = __p[0].__r_.__value_.__s.__data_[11];
    CFDictionaryRef v42 = IOServiceNameMatching("AppleH16CamIn");
    io_service_t v43 = IOServiceGetMatchingService(kIOMasterPortDefault, v42);
    CFTypeRef v44 = IORegistryEntrySearchCFProperty(v43, "IOService", @"JasperSNUM", kCFAllocatorDefault, 3u);
    uint64_t v45 = (2 * v41);
    if (v44)
    {
      CFRelease(v44);
    }
    else
    {
      NSLog(@"LoadPDEFiles: No JasperSNUM found. skipping FDR");
      uint64_t v45 = v45 | 8;
    }
    sub_1000092F0(v45);
    double v46 = sub_10000A7C4(v0, 1);
    if (v46)
    {
      CFRelease(v46);
    }
    else
    {
      NSLog(@"Failed to create JasperLCalib.bin");
      NSLog(@"Failed to load Jasper files\n");
    }
  }
  return 1;
}

void sub_1000105A4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19, uint64_t a20,uint64_t a21,void *a22,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a19 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1000105F4(const void **a1@<X0>, int a2@<W1>, std::string *a3@<X8>)
{
  sub_100010B78(a1, (const void **)"reference", (uint64_t)&v13);
  if ((a2 - 4) > 0xA) {
    int v5 = "";
  }
  else {
    int v5 = off_1000961D0[a2 - 4];
  }
  sub_100010914(__p, v5);
  if ((v12 & 0x80u) == 0) {
    CFDictionaryRef v6 = __p;
  }
  else {
    CFDictionaryRef v6 = (void **)__p[0];
  }
  if ((v12 & 0x80u) == 0) {
    std::string::size_type v7 = v12;
  }
  else {
    std::string::size_type v7 = (std::string::size_type)__p[1];
  }
  CFTypeRef v8 = std::string::append(&v13, (const std::string::value_type *)v6, v7);
  long long v9 = *(_OWORD *)&v8->__r_.__value_.__l.__data_;
  v14.__r_.__value_.__r.__words[2] = v8->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v14.__r_.__value_.__l.__data_ = v9;
  v8->__r_.__value_.__l.__size_ = 0;
  v8->__r_.__value_.__r.__words[2] = 0;
  v8->__r_.__value_.__r.__words[0] = 0;
  BOOL v10 = std::string::append(&v14, ".plist", 6uLL);
  *a3 = *v10;
  v10->__r_.__value_.__l.__size_ = 0;
  v10->__r_.__value_.__r.__words[2] = 0;
  v10->__r_.__value_.__r.__words[0] = 0;
  if (SHIBYTE(v14.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v14.__r_.__value_.__l.__data_);
  }
  if ((char)v12 < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v13.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v13.__r_.__value_.__l.__data_);
  }
}

void sub_1000106F4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *__p,uint64_t a22,int a23,__int16 a24,char a25,char a26)
{
  if (a26 < 0) {
    operator delete(__p);
  }
  if (a14 < 0) {
    operator delete(a9);
  }
  if (a20 < 0) {
    operator delete(a15);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100010740(uint64_t a1, const void **a2, int a3)
{
  int v13 = 256;
  sub_1000105F4(a2, 4, &__p);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    p_p = &__p;
  }
  else {
    p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
  }
  sub_100010CCC(a1, a3, +[NSDictionary dictionaryWithContentsOfFile:](NSDictionary, "dictionaryWithContentsOfFile:", +[NSString stringWithUTF8String:p_p]), (uint64_t)a2, 2, (uint64_t)&v13);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  sub_1000105F4(a2, 5, &__p);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type v7 = &__p;
  }
  else {
    std::string::size_type v7 = (std::string *)__p.__r_.__value_.__r.__words[0];
  }
  uint64_t v8 = sub_100010CCC(a1, a3, +[NSDictionary dictionaryWithContentsOfFile:](NSDictionary, "dictionaryWithContentsOfFile:", +[NSString stringWithUTF8String:v7]), (uint64_t)a2, 1, (uint64_t)&v13);
  uint64_t v9 = v8;
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p.__r_.__value_.__l.__data_);
    if (v9) {
      return v9;
    }
  }
  else if (v8)
  {
    return v9;
  }
  sub_1000105F4(a2, 12, &__p);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    BOOL v10 = &__p;
  }
  else {
    BOOL v10 = (std::string *)__p.__r_.__value_.__r.__words[0];
  }
  sub_100010CCC(a1, a3, +[NSDictionary dictionaryWithContentsOfFile:](NSDictionary, "dictionaryWithContentsOfFile:", +[NSString stringWithUTF8String:v10]), (uint64_t)a2, 3, (uint64_t)&v13);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  return v9;
}

void sub_1000108F0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void *sub_100010914(void *a1, char *__s)
{
  size_t v4 = strlen(__s);
  if (v4 >= 0x7FFFFFFFFFFFFFF8) {
    sub_1000109C8();
  }
  size_t v5 = v4;
  if (v4 >= 0x17)
  {
    uint64_t v7 = (v4 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v4 | 7) != 0x17) {
      uint64_t v7 = v4 | 7;
    }
    uint64_t v8 = v7 + 1;
    CFDictionaryRef v6 = operator new(v7 + 1);
    a1[1] = v5;
    a1[2] = v8 | 0x8000000000000000;
    *a1 = v6;
  }
  else
  {
    *((unsigned char *)a1 + 23) = v4;
    CFDictionaryRef v6 = a1;
    if (!v4) {
      goto LABEL_9;
    }
  }
  memmove(v6, __s, v5);
LABEL_9:
  *((unsigned char *)v6 + v5) = 0;
  return a1;
}

void sub_1000109C8()
{
}

void sub_1000109E0(const char *a1)
{
  exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
  sub_100010A3C(exception, a1);
}

void sub_100010A28(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

std::logic_error *sub_100010A3C(std::logic_error *a1, const char *a2)
{
  double result = std::logic_error::logic_error(a1, a2);
  return result;
}

std::string *sub_100010A70(std::string *__dst, const std::string::value_type *__src, size_t __len)
{
  LODWORD(v6) = SHIBYTE(__dst->__r_.__value_.__r.__words[2]);
  if ((v6 & 0x80000000) != 0)
  {
    unint64_t v10 = __dst->__r_.__value_.__r.__words[2];
    std::string::size_type v9 = (v10 & 0x7FFFFFFFFFFFFFFFLL) - 1;
    if (v9 < __len)
    {
      std::string::size_type size = __dst->__r_.__value_.__l.__size_;
      goto LABEL_6;
    }
    unint64_t v6 = HIBYTE(v10);
    uint64_t v7 = (std::string *)__dst->__r_.__value_.__r.__words[0];
  }
  else
  {
    uint64_t v7 = __dst;
    if (__len > 0x16)
    {
      std::string::size_type size = HIBYTE(__dst->__r_.__value_.__r.__words[2]);
      std::string::size_type v9 = 22;
LABEL_6:
      std::string::__grow_by_and_replace(__dst, v9, __len - v9, size, 0, size, __len, __src);
      return __dst;
    }
  }
  if (__len)
  {
    memmove(v7, __src, __len);
    LOBYTE(v6) = *((unsigned char *)&__dst->__r_.__value_.__s + 23);
  }
  if ((v6 & 0x80) != 0) {
    __dst->__r_.__value_.__l.__size_ = __len;
  }
  else {
    *((unsigned char *)&__dst->__r_.__value_.__s + 23) = __len & 0x7F;
  }
  v7->__r_.__value_.__s.__data_[__len] = 0;
  return __dst;
}

std::string *sub_100010B30(std::string *a1, char *__s)
{
  size_t v4 = strlen(__s);

  return sub_100010A70(a1, __s, v4);
}

uint64_t sub_100010B78@<X0>(const void **a1@<X0>, const void **a2@<X1>, uint64_t a3@<X8>)
{
  if (*((char *)a1 + 23) >= 0) {
    size_t v5 = *((unsigned __int8 *)a1 + 23);
  }
  else {
    size_t v5 = (size_t)a1[1];
  }
  if (*((char *)a2 + 23) >= 0) {
    size_t v6 = *((unsigned __int8 *)a2 + 23);
  }
  else {
    size_t v6 = (size_t)a2[1];
  }
  uint64_t result = sub_100010C44(a3, v6 + v5);
  if (*(char *)(result + 23) >= 0) {
    uint64_t v8 = (char *)result;
  }
  else {
    uint64_t v8 = *(char **)result;
  }
  if (v5)
  {
    if (*((char *)a1 + 23) >= 0) {
      std::string::size_type v9 = a1;
    }
    else {
      std::string::size_type v9 = *a1;
    }
    uint64_t result = (uint64_t)memmove(v8, v9, v5);
  }
  unint64_t v10 = &v8[v5];
  if (v6)
  {
    if (*((char *)a2 + 23) >= 0) {
      BOOL v11 = a2;
    }
    else {
      BOOL v11 = *a2;
    }
    uint64_t result = (uint64_t)memmove(v10, v11, v6);
  }
  v10[v6] = 0;
  return result;
}

uint64_t sub_100010C44(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x7FFFFFFFFFFFFFF8) {
    sub_1000109C8();
  }
  if (a2 > 0x16)
  {
    uint64_t v4 = (a2 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((a2 | 7) != 0x17) {
      uint64_t v4 = a2 | 7;
    }
    uint64_t v5 = v4 + 1;
    size_t v6 = operator new(v4 + 1);
    *(void *)(a1 + 8) = a2;
    *(void *)(a1 + 16) = v5 | 0x8000000000000000;
    *(void *)a1 = v6;
  }
  else
  {
    *(void *)(a1 + 8) = 0;
    *(void *)(a1 + 16) = 0;
    *(void *)a1 = 0;
    *(unsigned char *)(a1 + 23) = a2;
  }
  return a1;
}

uint64_t sub_100010CCC(uint64_t a1, int a2, void *a3, uint64_t a4, int a5, uint64_t a6)
{
  uint64_t v6 = 3758097084;
  if (a3)
  {
    v30[0] = 0;
    v30[1] = v30;
    v30[2] = 0x2020000000;
    int v31 = 0;
    id v13 = [a3 allKeys];
    io_service_t v32 = +[NSSortDescriptor sortDescriptorWithKey:@"doubleValue" ascending:1];
    id v14 = [v13 sortedArrayUsingDescriptors:[NSArray arrayWithObjects:count:](NSArray, "arrayWithObjects:count:", &v32, 1)];
    uint64_t v26 = 0;
    CFDataRef v27 = &v26;
    uint64_t v28 = 0x2020000000;
    int v29 = 1;
    id v15 = [a3 objectForKey:@"FormatDR"];
    if (v15)
    {
      unsigned int v16 = [v15 intValue];
      *((_DWORD *)v27 + 6) = v16;
    }
    v25[0] = 0;
    v25[1] = v25;
    v25[2] = 0x3052000000;
    v25[3] = sub_100010F54;
    v25[4] = sub_100010F64;
    v25[5] = &off_1000A0CC0;
    uint64_t v21 = 0;
    int v22 = &v21;
    uint64_t v23 = 0x2020000000;
    char v24 = 1;
    v18[0] = _NSConcreteStackBlock;
    v18[1] = 3221225472;
    v18[2] = sub_100010F70;
    v18[3] = &unk_1000961B0;
    void v18[4] = a3;
    v18[5] = v25;
    int v19 = a2;
    int v20 = a5;
    v18[10] = a1;
    v18[11] = a6;
    v18[6] = v30;
    v18[7] = &v26;
    v18[8] = &v21;
    v18[9] = a4;
    [v14 enumerateObjectsUsingBlock:v18];
    if (*((unsigned char *)v22 + 24)) {
      uint64_t v6 = 0;
    }
    else {
      uint64_t v6 = 3758097084;
    }
    _Block_object_dispose(&v21, 8);
    _Block_object_dispose(v25, 8);
    _Block_object_dispose(&v26, 8);
    _Block_object_dispose(v30, 8);
  }
  return v6;
}

void sub_100010F08(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,char a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27)
{
  _Block_object_dispose(&a23, 8);
  _Block_object_dispose(&a27, 8);
  _Block_object_dispose((const void *)(v27 - 176), 8);
  _Block_object_dispose((const void *)(v27 - 144), 8);
  _Unwind_Resume(a1);
}

void sub_100010F54(uint64_t a1, uint64_t a2)
{
}

void sub_100010F64(uint64_t a1)
{
}

void sub_100010F70(uint64_t a1, void *a2, uint64_t a3, unsigned char *a4)
{
  if (([*(id *)(*(void *)(*(void *)(a1 + 40) + 8) + 40) containsObject:a2] & 1) == 0)
  {
    id v7 = [*(id *)(a1 + 32) objectForKey:a2];
    if (v7)
    {
      uint64_t v8 = *(const void ***)(a1 + 72);
      std::string::size_type v9 = (const char *)[v7 UTF8String];
      unint64_t v10 = v9;
      if (*((char *)v8 + 23) >= 0) {
        size_t v11 = *((unsigned __int8 *)v8 + 23);
      }
      else {
        size_t v11 = (size_t)v8[1];
      }
      size_t v12 = strlen(v9);
      id v13 = __p;
      sub_100010C44((uint64_t)__p, v11 + v12);
      if (v25 < 0) {
        id v13 = (void **)__p[0];
      }
      if (v11)
      {
        if (*((char *)v8 + 23) >= 0) {
          id v14 = v8;
        }
        else {
          id v14 = *v8;
        }
        memmove(v13, v14, v11);
      }
      id v15 = (char *)v13 + v11;
      if (v12) {
        memmove(v15, v10, v12);
      }
      v15[v12] = 0;
      if (v25 >= 0) {
        unsigned int v16 = __p;
      }
      else {
        unsigned int v16 = (void **)__p[0];
      }
      CFNumberRef v17 = *(_DWORD **)(a1 + 88);
      uint64_t v18 = *v17;
      *CFNumberRef v17 = v18 + 1;
      uint64_t v19 = *(unsigned int *)(*(void *)(*(void *)(a1 + 48) + 8) + 24);
      [a2 doubleValue];
      uint64_t v21 = v20;
      NSLog(@"Sending reference file %s, type: %d\n", v16, v18);
      NSLog(@"Trying to load reference file %s (type: %d, index: %d, temperature: %lf)\n", v16, v18, v19, v21);
      int v22 = fopen((const char *)v16, "rb");
      uint64_t v23 = v22;
      if (v22)
      {
        fseeko(v22, 0, 2);
        ftello(v23);
        fseeko(v23, 0, 0);
        operator new[]();
      }
      NSLog(@"Could not open input file: %s\n", v16);
      *(unsigned char *)(*(void *)(*(void *)(a1 + 64) + 8) + 24) = 0;
      *a4 = 1;
      if (v25 < 0) {
        operator delete(__p[0]);
      }
    }
  }
}

void sub_100011230(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a20 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10001124C()
{
  sub_100010914(qword_1002BBE00, "/var/mobile/Library/ISP/Pearl/");

  return __cxa_atexit((void (*)(void *))&std::string::~string, qword_1002BBE00, (void *)&_mh_execute_header);
}

uint64_t sub_1000112AC(uint64_t a1, int a2)
{
  *(_DWORD *)a1 = a2;
  *(_DWORD *)(a1 + 4) = 0;
  pthread_mutexattr_init(&v4);
  pthread_mutexattr_settype(&v4, 2);
  pthread_mutex_init((pthread_mutex_t *)(a1 + 8), &v4);
  pthread_mutexattr_destroy(&v4);
  return a1;
}

uint64_t sub_100011334(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 4)) {
    sub_100011378(a1);
  }
  pthread_mutex_destroy((pthread_mutex_t *)(a1 + 8));
  *(_DWORD *)a1 = 0;
  return a1;
}

uint64_t sub_100011378(uint64_t a1)
{
  io_object_t v2 = (pthread_mutex_t *)(a1 + 8);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 8));
  mach_port_t v3 = *(_DWORD *)(a1 + 4);
  if (v3)
  {
    IOConnectCallScalarMethod(v3, 1u, 0, 0, 0, 0);
    IOServiceClose(*(_DWORD *)(a1 + 4));
    uint64_t v4 = 0;
    *(_DWORD *)(a1 + 4) = 0;
  }
  else
  {
    uint64_t v4 = 3758097101;
  }
  pthread_mutex_unlock(v2);
  return v4;
}

uint64_t sub_1000113F8(uint64_t a1)
{
  io_object_t v2 = (pthread_mutex_t *)(a1 + 8);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 8));
  if (*(_DWORD *)(a1 + 4))
  {
    uint64_t v3 = 3758097093;
  }
  else
  {
    unsigned int v4 = IOServiceOpen(*(_DWORD *)a1, mach_task_self_, 0x63u, (io_connect_t *)(a1 + 4));
    mach_port_t v5 = *(_DWORD *)(a1 + 4);
    if (v5) {
      uint64_t v3 = v4;
    }
    else {
      uint64_t v3 = 3758097088;
    }
    if (!v3) {
      uint64_t v3 = IOConnectCallScalarMethod(v5, 0, 0, 0, 0, 0);
    }
  }
  pthread_mutex_unlock(v2);
  return v3;
}

uint64_t sub_1000114A0(uint64_t a1)
{
  mach_port_t v1 = *(_DWORD *)(a1 + 4);
  if (v1) {
    return IOConnectCallScalarMethod(v1, 2u, 0, 0, 0, 0);
  }
  else {
    return 3758097101;
  }
}

uint64_t sub_1000114CC(uint64_t a1)
{
  mach_port_t v1 = *(_DWORD *)(a1 + 4);
  if (v1) {
    return IOConnectCallScalarMethod(v1, 3u, 0, 0, 0, 0);
  }
  else {
    return 3758097101;
  }
}

uint64_t sub_1000114F8(uint64_t a1, unsigned char *a2, unsigned char *a3)
{
  __int16 outputStruct = 0;
  size_t v7 = 2;
  mach_port_t v3 = *(_DWORD *)(a1 + 4);
  if (!v3) {
    return 3758097101;
  }
  uint64_t result = IOConnectCallStructMethod(v3, 4u, 0, 0, &outputStruct, &v7);
  if (!result)
  {
    *a2 = outputStruct;
    *a3 = HIBYTE(outputStruct);
  }
  return result;
}

void sub_100011570(uint64_t a1, void *a2, void *a3)
{
  if (a2 && a3)
  {
    CFDictionaryRef v5 = IOServiceNameMatching("AppleH16CamIn");
    io_service_t MatchingService = IOServiceGetMatchingService(kIOMainPortDefault, v5);
    CFDataRef v7 = (const __CFData *)IORegistryEntrySearchCFProperty(MatchingService, "IOService", @"photon-detector-cal-data", kCFAllocatorDefault, 3u);
    if (v7)
    {
      CFDataRef v8 = v7;
      size_t Length = CFDataGetLength(v7);
      BytePtr = CFDataGetBytePtr(v8);
      memmove(a2, BytePtr, Length);
      CFRelease(v8);
    }
    CFDataRef v11 = (const __CFData *)IORegistryEntrySearchCFProperty(MatchingService, "IOService", @"photon-detector-cal-data-offset", kCFAllocatorDefault, 3u);
    if (v11)
    {
      CFDataRef v12 = v11;
      size_t v13 = CFDataGetLength(v11);
      id v14 = CFDataGetBytePtr(v12);
      memmove(a3, v14, v13);
      CFRelease(v12);
    }
  }
  else
  {
    os_log_t v15 = (os_log_t)off_1002BBB90;
    if (off_1002BBB90 == &_os_log_default)
    {
      os_log_t v15 = os_log_create("com.apple.isp", "photon");
      off_1002BBB90 = v15;
    }
    if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR)) {
      sub_10007391C(v15);
    }
  }
}

void sub_1000116EC(uint64_t a1@<X0>, long double *a2@<X8>)
{
  long double v4 = *(double *)(a1 + 56);
  long double v5 = *(double *)(a1 + 64);
  *a2 = atan2(v4, v5);
  a2[1] = atan2(-*(double *)(a1 + 48), sqrt(v5 * v5 + v4 * v4));
  a2[2] = atan2(*(long double *)(a1 + 24), *(long double *)a1);
}

BOOL sub_100011758(uint64_t a1, double *a2, double *a3)
{
  long long v5 = *(_OWORD *)(a1 + 48);
  v9[2] = *(_OWORD *)(a1 + 32);
  v9[3] = v5;
  uint64_t v10 = *(void *)(a1 + 64);
  long long v6 = *(_OWORD *)(a1 + 16);
  v9[0] = *(_OWORD *)a1;
  v9[1] = v6;
  sub_1000116EC((uint64_t)v9, v11);
  uint64_t v7 = 0;
  long long v12 = 0uLL;
  uint64_t v13 = 0;
  do
  {
    *(long double *)((char *)&v12 + v7 * 8) = v11[v7] * 1000.0;
    ++v7;
  }
  while (v7 != 3);
  *(_OWORD *)a3 = v12;
  *((void *)a3 + 2) = v13;
  return fabs(*a3) <= a2[85] && fabs(a3[1]) <= a2[86] && fabs(a3[2]) <= a2[87];
}

void *sub_10001183C(void *a1)
{
  *a1 = &off_100096238;
  io_object_t v2 = (void *)a1[1];
  if (v2)
  {
    a1[2] = v2;
    operator delete(v2);
  }
  return a1;
}

uint64_t sub_10001188C(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = a1 + 8;
  *(void *)(a1 + 16) = *(void *)(a1 + 8);
  if (*(_DWORD *)a2 != *(_DWORD *)(a1 + 120)) {
    return 259;
  }
  if (*(unsigned char *)(a2 + 4) || (unsigned int v6 = *(_DWORD *)(a2 + 8), v6 == -1))
  {
    uint64_t result = 0;
    *(void *)(a1 + 32) = 0xFFFFFFFFLL;
    *(_DWORD *)(a1 + 64) = 0;
    *(void *)(a1 + 40) = -1;
    *(void *)(a1 + 48) = -1;
    *(void *)(a1 + 56) = -1;
    return result;
  }
  if ((v6 & 0x80000000) != 0 || (unsigned int v7 = *(_DWORD *)(a1 + 124), v6 >= v7))
  {
    NSLog(@"ISF: history.oldestIdx is out of range: %d", *(unsigned int *)(a2 + 8));
    return 257;
  }
  unsigned int v8 = *(_DWORD *)(a2 + 12);
  if ((v8 & 0x80000000) != 0 || v8 >= v7)
  {
    NSLog(@"ISF: history.nextIdx is out of range: %d", *(unsigned int *)(a2 + 12));
    return 257;
  }
  BOOL v9 = __OFSUB__(v8, v6);
  int v10 = v8 - v6;
  if (!((v10 < 0) ^ v9 | (v10 == 0))) {
    unsigned int v7 = 0;
  }
  unsigned int v11 = v10 + v7;
  *(_DWORD *)(a1 + 64) = v11;
  sub_100011AEC((void **)(a1 + 8), (int)(v11 + 1));
  sub_100012A88(v2, *(void *)(a1 + 16), (char *)(a2 + 40), (char *)(a2 + 40 + 72 * *(int *)(a1 + 64)), *(int *)(a1 + 64));
  uint64_t v12 = *(void *)(a1 + 8);
  if (v12 != *(void *)(a1 + 16))
  {
    uint64_t v13 = (unsigned int *)(v12 + 48);
    do
    {
      uint64_t v14 = 0;
      os_log_t v15 = v13;
      do
      {
        uint64_t v16 = v15[3];
        if ((v16 & 0x80000000) != 0)
        {
          if (v16 != -1)
          {
LABEL_39:
            NSLog(@"ISF: element.prevInSorted[%d] points to an index out of range: %d", v14, v16);
            return 257;
          }
        }
        else if ((int)v16 >= *(_DWORD *)(a1 + 64))
        {
          goto LABEL_39;
        }
        uint64_t v17 = *v15;
        if ((v17 & 0x80000000) != 0)
        {
          if (v17 != -1)
          {
LABEL_40:
            NSLog(@"ISF: element.nextInSorted[%d] points to an index out of range: %d", v14, v17);
            return 257;
          }
        }
        else if ((int)v17 >= *(_DWORD *)(a1 + 64))
        {
          goto LABEL_40;
        }
        *(unsigned char *)(v12 + v14++ + 45) = 1;
        ++v15;
      }
      while (v14 != 3);
      *(unsigned char *)(v12 + 44) = 1;
      *(double *)(v12 + 32) = sub_100011C04(a1, v12);
      v12 += 72;
      v13 += 18;
    }
    while (v12 != *(void *)(a1 + 16));
  }
  uint64_t v18 = 0;
  *(void *)(a1 + 32) = *(void *)(a2 + 8);
  uint64_t v19 = (unsigned int *)(a2 + 28);
  for (int i = (_DWORD *)(a1 + 52); ; ++i)
  {
    unsigned int v21 = *(v19 - 3);
    if ((v21 & 0x80000000) != 0)
    {
      if (v21 != -1)
      {
LABEL_41:
        uint64_t v24 = *(v19 - 3);
        goto LABEL_43;
      }
    }
    else if (v21 >= *(_DWORD *)(a1 + 124))
    {
      goto LABEL_41;
    }
    unsigned int v22 = *v19;
    if ((*v19 & 0x80000000) != 0) {
      break;
    }
    if (v22 >= *(_DWORD *)(a1 + 124)) {
      goto LABEL_42;
    }
LABEL_34:
    uint64_t result = 0;
    *(i - 3) = v21;
    int v23 = *v19++;
    *int i = v23;
    if (++v18 == 3) {
      return result;
    }
  }
  if (v22 == -1) {
    goto LABEL_34;
  }
LABEL_42:
  uint64_t v24 = *v19;
LABEL_43:
  NSLog(@"ISF: history.head[%d] is out of range: %d", v18, v24);
  return 257;
}

void sub_100011AEC(void **a1, unint64_t a2)
{
  long double v4 = a1[2];
  uint64_t v3 = (uint64_t)(a1 + 2);
  if (0x8E38E38E38E38E39 * ((v4 - (unsigned char *)*a1) >> 3) < a2)
  {
    if (a2 >= 0x38E38E38E38E38FLL) {
      sub_100012A24();
    }
    uint64_t v5 = ((unsigned char *)a1[1] - (unsigned char *)*a1) / 72;
    unsigned int v6 = (char *)sub_100012A3C(v3, a2);
    unsigned int v7 = &v6[72 * v5];
    BOOL v9 = &v6[72 * v8];
    unsigned int v11 = (char *)*a1;
    int v10 = (char *)a1[1];
    uint64_t v12 = v7;
    if (v10 != *a1)
    {
      do
      {
        *(_OWORD *)(v12 - 72) = *(_OWORD *)(v10 - 72);
        long long v13 = *(_OWORD *)(v10 - 56);
        long long v14 = *(_OWORD *)(v10 - 40);
        long long v15 = *(_OWORD *)(v10 - 24);
        *((void *)v12 - 1) = *((void *)v10 - 1);
        *(_OWORD *)(v12 - 24) = v15;
        *(_OWORD *)(v12 - 40) = v14;
        *(_OWORD *)(v12 - 56) = v13;
        v12 -= 72;
        v10 -= 72;
      }
      while (v10 != v11);
      int v10 = (char *)*a1;
    }
    *a1 = v12;
    a1[1] = v7;
    a1[2] = v9;
    if (v10)
    {
      operator delete(v10);
    }
  }
}

double sub_100011C04(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(unsigned int *)(a1 + 148);
  if (v2)
  {
    uint64_t v3 = 0;
    while (*(double *)(a2 + 24) >= *(double *)(*(void *)(a1 + 96) + 8 * v3))
    {
      if (v2 == ++v3)
      {
        uint64_t v3 = *(unsigned int *)(a1 + 148);
        return *(double *)(*(void *)(a1 + 104) + 8 * v3);
      }
    }
  }
  else
  {
    uint64_t v3 = 0;
  }
  return *(double *)(*(void *)(a1 + 104) + 8 * v3);
}

uint64_t sub_100011C64(uint64_t a1)
{
  unsigned int v1 = *(_DWORD *)(a1 + 32);
  if ((v1 & 0x80000000) != 0 || v1 >= *(_DWORD *)(a1 + 124))
  {
    NSLog(@"ISF: %s", "Error: oldest index record is out of range.");
    return 257;
  }
  else
  {
    uint64_t v2 = 0;
    uint64_t v3 = 0;
    uint64_t v4 = *(void *)(a1 + 8);
    unint64_t v5 = 0x8E38E38E38E38E39 * ((*(void *)(a1 + 16) - v4) >> 3);
    uint64_t v6 = a1 + 52;
    do
    {
      unint64_t v7 = *(int *)(a1 + 32);
      if (v5 <= v7) {
LABEL_21:
      }
        sub_100012E7C();
      uint64_t v8 = v4 + 72 * (int)v7 + v2;
      int v9 = *(_DWORD *)(v8 + 60);
      int v10 = *(_DWORD *)(v8 + 48);
      if (v10 == -1)
      {
        if (*(_DWORD *)(v6 + v2) != v7) {
          sub_1000739F8();
        }
        unsigned int v11 = (_DWORD *)(a1 + 4 * v3 + 52);
      }
      else
      {
        if (v5 <= v10) {
          goto LABEL_21;
        }
        unsigned int v11 = (_DWORD *)(v4 + v2 + 72 * v10 + 60);
      }
      _DWORD *v11 = v9;
      if (v9 == -1)
      {
        if (*(_DWORD *)(v6 + v2 - 12) != *(_DWORD *)(a1 + 32)) {
          sub_1000739CC();
        }
        uint64_t v12 = (_DWORD *)(a1 + 4 * v3 + 40);
      }
      else
      {
        if (v5 <= v9) {
          goto LABEL_21;
        }
        uint64_t v12 = (_DWORD *)(v4 + v2 + 72 * v9 + 48);
      }
      *uint64_t v12 = v10;
      ++v3;
      v2 += 4;
    }
    while (v2 != 12);
    uint64_t v13 = 0;
    *(_DWORD *)(a1 + 32) = (*(_DWORD *)(a1 + 32) + 1) % *(_DWORD *)(a1 + 124);
    --*(_DWORD *)(a1 + 64);
  }
  return v13;
}

uint64_t sub_100011DD0(uint64_t a1, int a2, int a3)
{
  unsigned int v3 = *(_DWORD *)(a1 + 64);
  if (v3 >= *(_DWORD *)(a1 + 124)) {
    sub_100073AA8();
  }
  uint64_t v4 = *(void *)(a1 + 8);
  unint64_t v5 = 0x8E38E38E38E38E39 * ((*(void *)(a1 + 16) - v4) >> 3);
  if (v5 <= a3) {
    goto LABEL_11;
  }
  uint64_t v6 = a2;
  unint64_t v7 = (int *)(a1 + 4 * a2 + 40);
  if (!v3)
  {
    *unint64_t v7 = a3;
    *(_DWORD *)(a1 + 4 * a2 + 52) = a3;
    uint64_t v18 = v4 + 72 * a3 + 4 * a2;
    *(_DWORD *)(v18 + 48) = -1;
    *(_DWORD *)(v18 + 60) = -1;
    return 0;
  }
  int v8 = *v7;
  if (*v7 == -1) {
    sub_100073A24();
  }
  uint64_t v9 = a1 + 4 * a2;
  int v11 = *(_DWORD *)(v9 + 52);
  int v10 = (int *)(v9 + 52);
  if (v11 == -1) {
    sub_100073A50();
  }
  uint64_t v12 = v8;
  if (v5 <= v8) {
LABEL_11:
  }
    sub_100012E7C();
  double v13 = *(double *)(v4 + 72 * a3 + 8 * a2);
  while (1)
  {
    if (*(double *)(v4 + 8 * v6 + 72 * v12) >= v13)
    {
      uint64_t v19 = v4 + 72 * v12 + 4 * v6;
      uint64_t v20 = v4 + 72 * a3 + 4 * v6;
      *(_DWORD *)(v20 + 60) = *(_DWORD *)(v19 + 60);
      unsigned int v21 = (int *)(v20 + 60);
      *(_DWORD *)(v19 + 60) = a3;
      *(v21 - 3) = v8;
      if (*v7 == v8)
      {
        *unint64_t v7 = a3;
        return 0;
      }
      unint64_t v22 = *v21;
      if (v5 > v22)
      {
        *(_DWORD *)(v4 + 72 * (int)v22 + 4 * v6 + 48) = a3;
        return 0;
      }
      goto LABEL_11;
    }
    uint64_t v14 = v4 + 72 * v12 + 4 * v6;
    int v17 = *(_DWORD *)(v14 + 48);
    uint64_t v16 = (int *)(v14 + 48);
    int v15 = v17;
    if (v17 == -1) {
      break;
    }
    uint64_t v12 = v15;
    int v8 = v15;
    if (v5 <= v15) {
      goto LABEL_11;
    }
  }
  *uint64_t v16 = a3;
  *(_DWORD *)(v4 + 72 * a3 + 4 * v6 + 60) = v8;
  if (*v10 != v8) {
    sub_100073A7C();
  }
  *(_DWORD *)(v4 + 72 * a3 + 4 * v6 + 48) = -1;
  *int v10 = a3;
  return 0;
}

uint64_t sub_100011F74(uint64_t a1, int a2, double a3, double a4, double a5, double a6)
{
  if (*(_DWORD *)(a1 + 64) == *(_DWORD *)(a1 + 124))
  {
    if (sub_100011C64(a1)) {
      return 256;
    }
    int v25 = *(_DWORD *)(a1 + 36);
    uint64_t v26 = *(void *)(a1 + 8);
    unint64_t v27 = v25;
    unint64_t v28 = 0x8E38E38E38E38E39 * ((*(void *)(a1 + 16) - v26) >> 3);
  }
  else
  {
    unint64_t v15 = *(void *)(a1 + 24);
    uint64_t v13 = a1 + 24;
    unint64_t v14 = v15;
    unint64_t v16 = *(void *)(v13 - 8);
    if (v16 >= v15)
    {
      uint64_t v18 = (void **)(v13 - 16);
      uint64_t v19 = *(void *)(v13 - 16);
      unint64_t v20 = 0x8E38E38E38E38E39 * ((uint64_t)(v16 - v19) >> 3);
      unint64_t v21 = v20 + 1;
      if (v20 + 1 > 0x38E38E38E38E38ELL) {
        sub_100012A24();
      }
      unint64_t v22 = 0x8E38E38E38E38E39 * ((uint64_t)(v14 - v19) >> 3);
      if (2 * v22 > v21) {
        unint64_t v21 = 2 * v22;
      }
      if (v22 >= 0x1C71C71C71C71C7) {
        unint64_t v23 = 0x38E38E38E38E38ELL;
      }
      else {
        unint64_t v23 = v21;
      }
      if (v23) {
        uint64_t v24 = (char *)sub_100012A3C(v13, v23);
      }
      else {
        uint64_t v24 = 0;
      }
      int v29 = &v24[72 * v20];
      unint64_t v30 = &v24[72 * v23];
      int v17 = v29 + 72;
      io_service_t v32 = *(char **)(a1 + 8);
      int v31 = *(char **)(a1 + 16);
      if (v31 != v32)
      {
        do
        {
          *(_OWORD *)(v29 - 72) = *(_OWORD *)(v31 - 72);
          long long v33 = *(_OWORD *)(v31 - 56);
          long long v34 = *(_OWORD *)(v31 - 40);
          long long v35 = *(_OWORD *)(v31 - 24);
          *((void *)v29 - 1) = *((void *)v31 - 1);
          *(_OWORD *)(v29 - 24) = v35;
          *(_OWORD *)(v29 - 40) = v34;
          *(_OWORD *)(v29 - 56) = v33;
          v29 -= 72;
          v31 -= 72;
        }
        while (v31 != v32);
        int v31 = (char *)*v18;
      }
      *(void *)(a1 + 8) = v29;
      *(void *)(a1 + 16) = v17;
      *(void *)(a1 + 24) = v30;
      if (v31) {
        operator delete(v31);
      }
    }
    else
    {
      int v17 = (char *)(v16 + 72);
    }
    *(void *)(a1 + 16) = v17;
    uint64_t v26 = *(void *)(a1 + 8);
    unint64_t v28 = 0x8E38E38E38E38E39 * ((uint64_t)&v17[-v26] >> 3);
    int v25 = *(_DWORD *)(a1 + 36);
    unint64_t v27 = v25;
    if (v28 != v25 + 1) {
      sub_100073B00();
    }
  }
  if (v28 <= v27) {
    sub_100012E7C();
  }
  if (*(_DWORD *)(a1 + 32) == v25) {
    sub_100073AD4();
  }
  io_service_t v36 = (double *)(v26 + 72 * (int)v27);
  if (!*(_DWORD *)(a1 + 64)) {
    *(_DWORD *)(a1 + 32) = v25;
  }
  *io_service_t v36 = a3;
  v36[1] = a4;
  v36[2] = a5;
  uint64_t v37 = v26 + 72 * (int)v27;
  *(_DWORD *)(v37 + 40) = a2;
  *(double *)(v37 + 24) = a6;
  NSLog(@"ISF: New calibration result receives confidence %.5f", *(void *)&a6);
  int v38 = 0;
  *(double *)(v37 + 32) = sub_100011C04(a1, (uint64_t)v36);
  do
    sub_100011DD0(a1, v38++, *(_DWORD *)(a1 + 36));
  while (v38 != 3);
  uint64_t result = 0;
  *(_DWORD *)(a1 + 36) = (*(_DWORD *)(a1 + 36) + 1) % *(_DWORD *)(a1 + 124);
  ++*(_DWORD *)(a1 + 64);
  return result;
}

uint64_t sub_100012238(uint64_t a1)
{
  unsigned int v1 = *(_DWORD *)(a1 + 124);
  int v2 = *(_DWORD *)(a1 + 128);
  if (v1 == v2)
  {
    signed int v3 = *(_DWORD *)(a1 + 156);
    if (*(unsigned char *)(a1 + 162)) {
      signed int v3 = vcvtps_s32_f32((float)((float)v3 * (float)(v1 - *(_DWORD *)(a1 + 164))) / (float)v1);
    }
  }
  else
  {
    signed int v3 = (*(_DWORD *)(a1 + 64) - v2) * (*(_DWORD *)(a1 + 156) - *(_DWORD *)(a1 + 152)) / (v1 - v2)
       + *(_DWORD *)(a1 + 152);
  }
  uint64_t v4 = *(void *)(a1 + 8);
  unint64_t v5 = *(int *)(a1 + 40);
  uint64_t v6 = *(void *)(a1 + 16);
  unint64_t v7 = 0x8E38E38E38E38E39 * ((v6 - v4) >> 3);
  if (v7 <= v5) {
    goto LABEL_33;
  }
  unint64_t v8 = 0;
  while (1)
  {
    unint64_t v9 = *(_DWORD *)(v4 + 72 * v5 + 40) == 4 ? 3 : 2;
    if (v8 >= v9) {
      return 0;
    }
    uint64_t v10 = a1 + 4 * v8;
    unint64_t v13 = *(int *)(v10 + 40);
    uint64_t v12 = (int *)(v10 + 40);
    int v11 = v13;
    if (v7 <= v13) {
      goto LABEL_33;
    }
    if (v3 >= 1)
    {
      signed int v14 = 0;
      uint64_t v15 = v4 + 72 * v11;
      unint64_t v16 = (int *)(a1 + 4 * v8 + 52);
      do
      {
        unint64_t v17 = *v16;
        if (0x8E38E38E38E38E39 * ((v6 - v4) >> 3) <= v17) {
          goto LABEL_33;
        }
        if (v15 == v4 + 72 * (int)v17) {
          break;
        }
        if (*(unsigned char *)(v15 + 44))
        {
          *(unsigned char *)(v15 + v8 + 45) = 0;
          *(void *)(v15 + 32) = *(void *)(a1 + 112);
          ++v14;
        }
        unint64_t v18 = *(int *)(v15 + 4 * v8 + 48);
        if (v18 == -1) {
          sub_100073B58();
        }
        uint64_t v4 = *(void *)(a1 + 8);
        uint64_t v6 = *(void *)(a1 + 16);
        if (0x8E38E38E38E38E39 * ((v6 - v4) >> 3) <= v18) {
          goto LABEL_33;
        }
        uint64_t v15 = v4 + 72 * (int)v18;
      }
      while (v14 < v3);
      unint64_t v19 = *v16;
      if (0x8E38E38E38E38E39 * ((v6 - v4) >> 3) > v19)
      {
        signed int v20 = 0;
        uint64_t v21 = v4 + 72 * (int)v19;
        while (1)
        {
          unint64_t v22 = *v12;
          unint64_t v7 = 0x8E38E38E38E38E39 * ((v6 - v4) >> 3);
          if (v7 <= v22) {
            break;
          }
          if (v21 == v4 + 72 * (int)v22) {
            goto LABEL_32;
          }
          if (*(unsigned char *)(v21 + 44))
          {
            *(unsigned char *)(v21 + v8 + 45) = 0;
            *(void *)(v21 + 32) = *(void *)(a1 + 112);
            ++v20;
          }
          unint64_t v23 = *(int *)(v21 + 4 * v8 + 60);
          if (v23 == -1) {
            sub_100073B2C();
          }
          uint64_t v4 = *(void *)(a1 + 8);
          uint64_t v6 = *(void *)(a1 + 16);
          unint64_t v7 = 0x8E38E38E38E38E39 * ((v6 - v4) >> 3);
          if (v7 <= v23) {
            break;
          }
          uint64_t v21 = v4 + 72 * (int)v23;
          if (v20 >= v3) {
            goto LABEL_32;
          }
        }
      }
LABEL_33:
      sub_100012E7C();
    }
    unint64_t v7 = 0x8E38E38E38E38E39 * ((v6 - v4) >> 3);
    if (v7 <= *(int *)(a1 + 4 * v8 + 52)) {
      goto LABEL_33;
    }
LABEL_32:
    ++v8;
    unint64_t v5 = *(int *)(a1 + 40);
    if (v7 <= v5) {
      goto LABEL_33;
    }
  }
}

double sub_100012470(uint64_t a1, uint64_t a2)
{
  signed int v3 = *(unsigned char **)(a1 + 8);
  uint64_t v4 = *(unsigned char **)(a1 + 16);
  if (0x8E38E38E38E38E39 * ((v4 - v3) >> 3) <= *(unsigned int *)(a1 + 124))
  {
    if (*(int *)(a1 + 64) >= 1) {
      *(unsigned char *)(a2 + 4) = 0;
    }
    if (v4 != v3) {
      memmove((void *)(a2 + 40), v3, v4 - v3);
    }
    double result = *(double *)(a1 + 32);
    *(double *)(a2 + 8) = result;
    uint64_t v7 = *(void *)(a1 + 40);
    *(_DWORD *)(a2 + 24) = *(_DWORD *)(a1 + 48);
    *(void *)(a2 + 16) = v7;
    uint64_t v8 = *(void *)(a1 + 52);
    *(_DWORD *)(a2 + 36) = *(_DWORD *)(a1 + 60);
    *(void *)(a2 + 28) = v8;
  }
  else
  {
    NSLog(@"ISF: Error: Existing history is too large (contains %zu records).", 0x8E38E38E38E38E39 * ((v4 - v3) >> 3));
  }
  return result;
}

uint64_t sub_10001252C(uint64_t a1, uint64_t a2)
{
  memset(v11, 0, sizeof(v11));
  memset(v10, 0, sizeof(v10));
  uint64_t v2 = *(void *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 16);
  if (v2 == v3) {
    goto LABEL_10;
  }
  do
  {
    for (uint64_t i = 0; i != 3; ++i)
    {
      if (!*(unsigned char *)(v2 + i + 45) || !*(unsigned char *)(v2 + 44)) {
        continue;
      }
      if (i == 2 && (*(_DWORD *)(v2 + 40) - 2) > 2) {
        break;
      }
      double v5 = *(double *)(v2 + 32);
      *(double *)&v10[i] = v5 + *(double *)&v10[i];
      *(double *)&v11[i] = *(double *)&v11[i] + v5 * *(double *)(v2 + 8 * i);
    }
    v2 += 72;
  }
  while (v2 != v3);
LABEL_10:
  for (uint64_t j = 0; j != 3; ++j)
  {
    double v7 = *(double *)&v10[j];
    if (v7 == 0.0) {
      double v8 = NAN;
    }
    else {
      double v8 = *(double *)&v11[j] / v7;
    }
    *(double *)(a2 + j * 8) = v8;
  }
  return 0;
}

uint64_t sub_100012640(uint64_t a1, _DWORD *a2, uint64_t a3, double a4, double a5, double a6, double a7)
{
  *(unsigned char *)(a1 + 160) = 0;
  if (a3 != 2)
  {
    double v9 = a7;
    *(int64x2_t *)(a1 + 72) = vdupq_n_s64(0x7FF8000000000000uLL);
    *(void *)(a1 + 88) = 0x7FF8000000000000;
    NSLog(@"ISF: v%d.%d.%d. New calibration result: x=%.5f, y=%.5f, z=%.5f, confidence=%.5f from:%d (0:LMV,1:MI,2:GMC_GB,3:GMC_IR,4:RGBJ)", 1, 3, 1, *(void *)&a4, *(void *)&a5, *(void *)&a6, *(void *)&a7, a3);
    if (sub_10001188C(a1, (uint64_t)a2))
    {
      bzero(a2, 0xE38uLL);
      *a2 = *(_DWORD *)(a1 + 120);
      *((unsigned char *)a2 + 4) = 1;
      a2[2] = -1;
      *((void *)a2 + 2) = -1;
      *((void *)a2 + 3) = -1;
      *((void *)a2 + 4) = -1;
      return 257;
    }
    switch((int)a3)
    {
      case 0:
        LODWORD(v15) = *(_DWORD *)(a1 + 144);
        double v9 = (double)v15;
        break;
      case 1:
      case 3:
      case 4:
        break;
      default:
        NSLog(@"ISF: Error: Calibration result originated from unknown origin (%d).", a3);
        return 258;
    }
    uint64_t v16 = *(unsigned int *)(a1 + 136);
    if (v9 < (double)*(unsigned int *)(a1 + 132) || v9 > (double)v16)
    {
      NSLog(@"ISF: Confidence is out of bounds (%.5f should be between %d..%d). This result will be ignored", *(void *)&v9, *(unsigned int *)(a1 + 132), v16);
      return 260;
    }
    bzero(a2, 0xE38uLL);
    *a2 = *(_DWORD *)(a1 + 120);
    *((unsigned char *)a2 + 4) = 1;
    a2[2] = -1;
    *((void *)a2 + 2) = -1;
    *((void *)a2 + 3) = -1;
    *((void *)a2 + 4) = -1;
    if (!sub_100011F74(a1, a3, a4, a5, a6, v9))
    {
      uint64_t v18 = *(unsigned int *)(a1 + 128);
      if (*(_DWORD *)(a1 + 64) < (int)v18)
      {
        NSLog(@"ISF: History does not contain enough records (%d < %d) to give a reliable result.", *(unsigned int *)(a1 + 64), v18);
        sub_100012470(a1, (uint64_t)a2);
        if (v19) {
          return 256;
        }
        else {
          return 1;
        }
      }
      sub_100012470(a1, (uint64_t)a2);
      if (!v20)
      {
        sub_100012894(a1, (uint64_t)a2);
        return 0;
      }
    }
    return 256;
  }
  NSLog(@"ISF: %s", "Error: Calibration result cannot be originated from GMC-RGB-IR.");
  return 258;
}

uint64_t sub_100012894(uint64_t a1, uint64_t a2)
{
  if (*(unsigned char *)(a1 + 160)) {
    return 0;
  }
  if (sub_10001188C(a1, a2)) {
    return 257;
  }
  uint64_t v4 = *(unsigned int *)(a1 + 128);
  if (*(_DWORD *)(a1 + 64) < (int)v4)
  {
    NSLog(@"ISF: History does not contain enough records (%d < %d) to give a reliable result.", *(unsigned int *)(a1 + 64), v4);
    return 1;
  }
  if (*(unsigned char *)(a1 + 161))
  {
    *(unsigned char *)(a1 + 162) = 0;
    *(_DWORD *)(a1 + 164) = 0;
    if ((*(unsigned int (**)(uint64_t))(*(void *)a1 + 16))(a1) == 261)
    {
      uint64_t v5 = *(void *)(a1 + 8);
      *(unsigned char *)(a1 + 162) = 1;
      unint64_t v6 = *(int *)(a1 + 32);
      unint64_t v7 = 0x8E38E38E38E38E39 * ((*(void *)(a1 + 16) - v5) >> 3);
      if (v7 <= v6) {
        goto LABEL_18;
      }
      uint64_t v8 = *(unsigned int *)(a1 + 164);
      if (v8)
      {
        int v9 = 0;
        unsigned int v10 = *(_DWORD *)(a1 + 124);
        while (1)
        {
          unint64_t v11 = ((int)v6 + v9) % v10;
          if (v7 <= v11) {
            break;
          }
          *(unsigned char *)(v5 + 72 * v11 + 44) = 0;
          if (v8 == ++v9) {
            goto LABEL_14;
          }
        }
LABEL_18:
        sub_100012E7C();
      }
LABEL_14:
      uint64_t v12 = 1;
    }
    else
    {
      uint64_t v12 = *(unsigned __int8 *)(a1 + 162);
      uint64_t v8 = *(unsigned int *)(a1 + 164);
    }
    NSLog(@"ISF: ISF Step Detection result: isStepDetected:%d, stepIndex:%d", v12, v8);
  }
  sub_100012238(a1);
  sub_10001252C(a1, a1 + 72);
  NSLog(@"ISF: New calculated rotation angle: x=%.5f, y=%.5f, z=%.5f", *(void *)(a1 + 72), *(void *)(a1 + 80), *(void *)(a1 + 88));
  uint64_t result = 0;
  *(unsigned char *)(a1 + 160) = 1;
  return result;
}

uint64_t sub_100012A1C(uint64_t result, char a2)
{
  *(unsigned char *)(result + 161) = a2;
  return result;
}

void sub_100012A24()
{
}

void *sub_100012A3C(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x38E38E38E38E38FLL) {
    sub_100005ED8();
  }
  return operator new(72 * a2);
}

char *sub_100012A88(uint64_t a1, uint64_t __dst, char *__src, char *a4, uint64_t a5)
{
  uint64_t v5 = (char *)__dst;
  if (a5 < 1) {
    return v5;
  }
  unint64_t v7 = __src;
  uint64_t v11 = *(void *)(a1 + 16);
  uint64_t v9 = a1 + 16;
  uint64_t v10 = v11;
  unint64_t v12 = *(void *)(v9 - 8);
  if ((uint64_t)(0x8E38E38E38E38E39 * ((uint64_t)(v11 - v12) >> 3)) < a5)
  {
    unint64_t v13 = *(void **)a1;
    unint64_t v14 = a5 - 0x71C71C71C71C71C7 * ((uint64_t)(v12 - *(void *)a1) >> 3);
    if (v14 > 0x38E38E38E38E38ELL) {
      sub_100012A24();
    }
    unint64_t v15 = 0x8E38E38E38E38E39 * ((__dst - (uint64_t)v13) >> 3);
    unint64_t v16 = 0x8E38E38E38E38E39 * ((v10 - (uint64_t)v13) >> 3);
    uint64_t v17 = 2 * v16;
    if (2 * v16 <= v14) {
      uint64_t v17 = v14;
    }
    if (v16 >= 0x1C71C71C71C71C7) {
      unint64_t v18 = 0x38E38E38E38E38ELL;
    }
    else {
      unint64_t v18 = v17;
    }
    uint64_t v41 = v9;
    if (v18) {
      int v19 = (char *)sub_100012A3C(v9, v18);
    }
    else {
      int v19 = 0;
    }
    unint64_t v30 = &v19[72 * v15];
    std::string __p = v19;
    int v38 = v30;
    uint64_t v40 = &v19[72 * v18];
    int v31 = &v30[72 * a5];
    uint64_t v32 = 72 * a5;
    do
    {
      *(_OWORD *)unint64_t v30 = *(_OWORD *)v7;
      long long v33 = *((_OWORD *)v7 + 1);
      long long v34 = *((_OWORD *)v7 + 2);
      long long v35 = *((_OWORD *)v7 + 3);
      *((void *)v30 + 8) = *((void *)v7 + 8);
      *((_OWORD *)v30 + 2) = v34;
      *((_OWORD *)v30 + 3) = v35;
      *((_OWORD *)v30 + 1) = v33;
      v30 += 72;
      v7 += 72;
      v32 -= 72;
    }
    while (v32);
    uint64_t v39 = v31;
    uint64_t v5 = (char *)sub_100012D84((void **)a1, (uint64_t)&__p, v5);
    if (v39 != v38) {
      uint64_t v39 = &v38[(v39 - v38 - 72) % 0x48uLL];
    }
    if (__p) {
      operator delete(__p);
    }
    return v5;
  }
  uint64_t v20 = v12 - __dst;
  if ((uint64_t)(0x8E38E38E38E38E39 * ((uint64_t)(v12 - __dst) >> 3)) >= a5)
  {
    uint64_t v21 = &__src[72 * a5];
    unint64_t v23 = *(char **)(v9 - 8);
LABEL_17:
    uint64_t v24 = &v5[72 * a5];
    int v25 = &v23[-72 * a5];
    uint64_t v26 = v23;
    if ((unint64_t)v25 < v12)
    {
      uint64_t v26 = v23;
      do
      {
        *(_OWORD *)uint64_t v26 = *(_OWORD *)v25;
        long long v27 = *((_OWORD *)v25 + 1);
        long long v28 = *((_OWORD *)v25 + 2);
        long long v29 = *((_OWORD *)v25 + 3);
        *((void *)v26 + 8) = *((void *)v25 + 8);
        *((_OWORD *)v26 + 2) = v28;
        *((_OWORD *)v26 + 3) = v29;
        *((_OWORD *)v26 + 1) = v27;
        v25 += 72;
        v26 += 72;
      }
      while ((unint64_t)v25 < v12);
    }
    *(void *)(a1 + 8) = v26;
    if (v23 != v24) {
      memmove(&v5[72 * a5], v5, v23 - v24);
    }
    if (v21 != v7) {
      memmove(v5, v7, v21 - v7);
    }
    return v5;
  }
  uint64_t v21 = &__src[8 * ((uint64_t)(v12 - __dst) >> 3)];
  int64_t v22 = a4 - v21;
  if (a4 != v21) {
    memmove(*(void **)(v9 - 8), &__src[8 * ((uint64_t)(v12 - __dst) >> 3)], a4 - v21);
  }
  unint64_t v23 = (char *)(v12 + v22);
  *(void *)(a1 + 8) = v12 + v22;
  if (v20 >= 1) {
    goto LABEL_17;
  }
  return v5;
}

void sub_100012D30(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void *sub_100012D84(void **a1, uint64_t a2, char *__src)
{
  uint64_t v5 = *(void **)(a2 + 8);
  unint64_t v6 = (char *)*a1;
  unint64_t v7 = v5;
  if (*a1 != __src)
  {
    uint64_t v8 = __src;
    uint64_t v9 = *(void *)(a2 + 8);
    do
    {
      *(_OWORD *)(v9 - 72) = *(_OWORD *)(v8 - 72);
      long long v10 = *(_OWORD *)(v8 - 56);
      long long v11 = *(_OWORD *)(v8 - 40);
      long long v12 = *(_OWORD *)(v8 - 24);
      unint64_t v7 = (void *)(v9 - 72);
      *(void *)(v9 - 8) = *((void *)v8 - 1);
      *(_OWORD *)(v9 - 24) = v12;
      *(_OWORD *)(v9 - 40) = v11;
      *(_OWORD *)(v9 - 56) = v10;
      v8 -= 72;
      v9 -= 72;
    }
    while (v8 != v6);
  }
  *(void *)(a2 + 8) = v7;
  unint64_t v13 = a1[1];
  uint64_t v14 = *(void *)(a2 + 16);
  int64_t v15 = v13 - __src;
  if (v13 != __src)
  {
    memmove(*(void **)(a2 + 16), __src, v13 - __src);
    unint64_t v7 = *(void **)(a2 + 8);
  }
  *(void *)(a2 + 16) = v14 + v15;
  unint64_t v16 = (char *)*a1;
  *a1 = v7;
  *(void *)(a2 + 8) = v16;
  uint64_t v17 = a1[1];
  a1[1] = *(void **)(a2 + 16);
  *(void *)(a2 + 16) = v17;
  unint64_t v18 = a1[2];
  a1[2] = *(void **)(a2 + 24);
  *(void *)(a2 + 24) = v18;
  *(void *)a2 = *(void *)(a2 + 8);
  return v5;
}

void sub_100012E7C()
{
}

void sub_100012E94(const char *a1)
{
  exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
  sub_100012EF0(exception, a1);
}

void sub_100012EDC(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

std::logic_error *sub_100012EF0(std::logic_error *a1, const char *a2)
{
  uint64_t result = std::logic_error::logic_error(a1, a2);
  return result;
}

BOOL sub_100012F24(uint64_t a1, uint64_t a2, double *a3)
{
  sub_100013148((uint64_t)&v21, *(_DWORD *)(a2 + 116) / 32, *(_DWORD *)(a2 + 112) / 32);
  unint64_t v6 = *(unsigned int *)(a1 + 20);
  if (v6)
  {
    for (unint64_t i = 0; i < v6; ++i)
    {
      int v8 = *(_DWORD *)(a1 + 16);
      if (!v8) {
        __assert_rtn("operator()", "Matrix.hpp", 125, "row < m_rows && col < m_cols");
      }
      if (v8 == 1) {
        __assert_rtn("operator()", "Matrix.hpp", 125, "row < m_rows && col < m_cols");
      }
      int v9 = *(_DWORD *)(a2 + 112);
      int v10 = v9 + 31;
      if (v9 >= 0) {
        int v10 = *(_DWORD *)(a2 + 112);
      }
      long long v11 = (double *)(*(void *)(a1 + 8) + 8 * i);
      unsigned int v12 = fmin((double)(*(_DWORD *)(a2 + 116) / 32 - 1), fmax((double)(v11[v6] * 0.03125), 0.0));
      if (v23 <= v12
        || (unsigned int v13 = fmin((double)((v10 >> 5) - 1), fmax((double)(*v11 * 0.03125), 0.0)), v24 <= v13))
      {
        __assert_rtn("operator()", "Matrix.hpp", 119, "row < m_rows && col < m_cols");
      }
      v22[v13 + v24 * v12] = 1;
      unint64_t v6 = *(unsigned int *)(a1 + 20);
    }
  }
  if (v24 * v23)
  {
    uint64_t v14 = v22;
    double v15 = 0.0;
    uint64_t v16 = v24 * v23;
    do
    {
      unsigned int v17 = *v14++;
      double v15 = v15 + (double)v17;
      --v16;
    }
    while (v16);
  }
  else
  {
    double v15 = 0.0;
  }
  double v18 = v15 / (double)(v24 * v23);
  BOOL v19 = v18 > *(double *)(a2 + 536);
  *a3 = v18;
  sub_100013234((uint64_t)&v21);
  return v19;
}

void sub_100013128(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_100013148(uint64_t result, int a2, int a3)
{
  *(void *)uint64_t result = off_100096260;
  if (a3 * a2) {
    operator new[]();
  }
  *(void *)(result + 8) = 0;
  *(_DWORD *)(result + 16) = a2;
  *(_DWORD *)(result + 20) = a3;
  *(unsigned char *)(result + 24) = 0;
  return result;
}

void sub_1000131FC(uint64_t a1)
{
  sub_100013234(a1);

  operator delete();
}

uint64_t sub_100013234(uint64_t result)
{
  *(void *)uint64_t result = off_100096260;
  if (*(void *)(result + 8) && *(unsigned char *)(result + 24)) {
    operator delete[]();
  }
  *(void *)(result + 16) = 0;
  return result;
}

uint64_t sub_1000132A0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(_DWORD *)(a1 + 56) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = 0;
  pthread_mutex_init((pthread_mutex_t *)(a1 + 80), 0);
  pthread_cond_init((pthread_cond_t *)(a1 + 144), 0);
  *(unsigned char *)(a1 + 192) = 0;
  *(void *)(a1 + 32) = a2;
  *(void *)(a1 + 40) = a3;
  *(void *)(a1 + 64) = pthread_self();
  CFRunLoopRef Current = CFRunLoopGetCurrent();
  *(void *)(a1 + 48) = CFRetain(Current);
  *(void *)(a1 + 72) = 0;
  return a1;
}

uint64_t sub_100013318(uint64_t a1)
{
  for (unint64_t i = 0; i < CFArrayGetCount(*(CFArrayRef *)a1); ++i)
  {
    ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)a1, i);
    sub_10004ED64((uint64_t)ValueAtIndex);
  }
  io_object_t v4 = *(_DWORD *)(a1 + 56);
  if (v4) {
    IOObjectRelease(v4);
  }
  if (*(void *)a1) {
    CFRelease(*(CFTypeRef *)a1);
  }
  uint64_t v5 = *(IONotificationPort **)(a1 + 16);
  if (v5)
  {
    unint64_t v6 = *(__CFRunLoopSource **)(a1 + 24);
    if (v6)
    {
      CFRunLoopRemoveSource(*(CFRunLoopRef *)(a1 + 48), v6, kCFRunLoopDefaultMode);
      *(void *)(a1 + 24) = 0;
      uint64_t v5 = *(IONotificationPort **)(a1 + 16);
    }
    IONotificationPortDestroy(v5);
  }
  unint64_t v7 = *(NSObject **)(a1 + 72);
  if (v7)
  {
    dispatch_sync(v7, &stru_1000962A0);
    dispatch_release(*(dispatch_object_t *)(a1 + 72));
    *(void *)(a1 + 72) = 0;
  }
  pthread_cond_destroy((pthread_cond_t *)(a1 + 144));
  pthread_mutex_destroy((pthread_mutex_t *)(a1 + 80));
  int v8 = *(const void **)(a1 + 48);
  if (v8) {
    CFRelease(v8);
  }
  return a1;
}

uint64_t sub_1000133FC(uint64_t a1)
{
  callBacks.version = 0;
  callBacks.retain = 0;
  callBacks.copyDescription = 0;
  callBacks.equal = 0;
  callBacks.release = (CFArrayReleaseCallBack)sub_10001368C;
  CFMutableArrayRef v2 = CFArrayCreateMutable(0, 0, &callBacks);
  *(void *)a1 = v2;
  if (!v2) {
    return 3758097085;
  }
  uint64_t v3 = IOMasterPort(bootstrap_port, (mach_port_t *)(a1 + 8));
  if (!v3)
  {
    CFDictionaryRef v4 = IOServiceMatching("AppleH16CamIn");
    uint64_t v5 = IONotificationPortCreate(*(_DWORD *)(a1 + 8));
    *(void *)(a1 + 16) = v5;
    if (v5)
    {
      RunLoopSource = IONotificationPortGetRunLoopSource(v5);
      *(void *)(a1 + 24) = RunLoopSource;
      if (RunLoopSource)
      {
        CFRunLoopAddSource(*(CFRunLoopRef *)(a1 + 48), RunLoopSource, kCFRunLoopDefaultMode);
        uint64_t v3 = IOServiceAddMatchingNotification(*(IONotificationPortRef *)(a1 + 16), "IOServiceFirstPublish", v4, (IOServiceMatchingCallback)sub_1000136D0, (void *)a1, (io_iterator_t *)(a1 + 56));
        if (!v3)
        {
          *(void *)(a1 + 72) = dispatch_queue_create("com.apple.h16ispdevicecontroller.notifications.queue", 0);
          sub_1000136D0(a1, *(_DWORD *)(a1 + 56));
          pthread_mutex_lock((pthread_mutex_t *)(a1 + 80));
          unint64_t v7 = (unsigned __int8 *)(a1 + 192);
          if (*(unsigned char *)(a1 + 192))
          {
            uint64_t v3 = 0;
          }
          else
          {
            clock_gettime(_CLOCK_REALTIME, &__tp);
            __tp.tv_sec += 2;
            uint64_t v3 = pthread_cond_timedwait((pthread_cond_t *)(a1 + 144), (pthread_mutex_t *)(a1 + 80), &__tp);
            if (v3 && !*v7)
            {
              if (off_1002BBB98 == &_os_log_default) {
                off_1002BBB98 = os_log_create("com.apple.isp", "device");
              }
              uint64_t v3 = 3758097110;
              if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR)) {
                sub_100073C94(v7);
              }
            }
          }
          pthread_mutex_unlock((pthread_mutex_t *)(a1 + 80));
        }
        return v3;
      }
      if (off_1002BBB98 == &_os_log_default) {
        off_1002BBB98 = os_log_create("com.apple.isp", "device");
      }
      if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR)) {
        sub_100073C0C();
      }
      IONotificationPortDestroy(*(IONotificationPortRef *)(a1 + 16));
      *(void *)(a1 + 16) = 0;
    }
    else
    {
      if (off_1002BBB98 == &_os_log_default) {
        off_1002BBB98 = os_log_create("com.apple.isp", "device");
      }
      if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR)) {
        sub_100073B84();
      }
    }
    return 3758097086;
  }
  return v3;
}

void sub_10001368C(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    sub_10004EEB4(a2);
    operator delete();
  }
}

uint64_t sub_1000136D0(uint64_t a1, io_iterator_t iterator)
{
  CFMutableDictionaryRef properties = 0;
  CFDictionaryRef v4 = (pthread_mutex_t *)(a1 + 80);
  uint64_t v5 = (pthread_cond_t *)(a1 + 144);
  while (1)
  {
    uint64_t result = IOIteratorNext(iterator);
    if (!result) {
      break;
    }
    if (!IORegistryEntryCreateCFProperties(result, &properties, kCFAllocatorDefault, 0))
    {
      if (!CFArrayGetCount(*(CFArrayRef *)a1)) {
        operator new();
      }
      CFRelease(properties);
      pthread_mutex_lock(v4);
      *(unsigned char *)(a1 + 192) = 1;
      pthread_cond_broadcast(v5);
      pthread_mutex_unlock(v4);
    }
  }
  return result;
}

void sub_1000137DC()
{
}

double sub_100013800()
{
  uint64_t v0 = __chkstk_darwin();
  if (!sub_1000138A8("/var/mobile/Library/ISP/Pearl/IsfThresholds.bin", (void *)v0, 0x20u))
  {
    if (sub_100009788((uint64_t)v6))
    {
      int v4[2] = v6[2];
      void v4[3] = v6[3];
      uint64_t v5 = v7;
      v4[0] = v6[0];
      v4[1] = v6[1];
      long long v2 = 0uLL;
      double v3 = 0.0;
      sub_100005E50((uint64_t)v4, (long double *)&v2);
      *(_OWORD *)(v0 + 8) = v2;
      double result = v3;
      *(double *)(v0 + 24) = v3;
    }
  }
  return result;
}

BOOL sub_1000138A8(const char *a1, void *a2, unsigned int a3)
{
  uint64_t v5 = fopen(a1, "rb");
  if (v5)
  {
    unint64_t v6 = v5;
    int v7 = fread(a2, 1uLL, a3, v5);
    fclose(v6);
    return v7 == a3;
  }
  else
  {
    bzero(a2, a3);
    return 0;
  }
}

FILE *sub_100013924(const void *a1)
{
  return sub_100013938("/var/mobile/Library/ISP/Pearl/IsfThresholds.bin", a1, 0x20u);
}

FILE *sub_100013938(const char *a1, const void *a2, unsigned int a3)
{
  double result = fopen(a1, "wb");
  if (result)
  {
    unint64_t v6 = result;
    fwrite(a2, a3, 1uLL, result);
    return (FILE *)fclose(v6);
  }
  return result;
}

void sub_1000139B0(int a1, double *a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  if (a3 == 2)
  {
    if ((analytics_send_event_lazy() & 1) == 0)
    {
      os_log_t v9 = (os_log_t)off_1002BBBA0;
      if (off_1002BBBA0 == &_os_log_default)
      {
        os_log_t v9 = os_log_create("com.apple.isp", "general");
        off_1002BBBA0 = v9;
      }
      if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR)) {
        sub_100073D2C();
      }
    }
    sub_100013B90(a2, a6);
    if (!a1) {
      goto LABEL_14;
    }
  }
  else
  {
    if (analytics_send_event_lazy()) {
      goto LABEL_13;
    }
    os_log_t v10 = (os_log_t)off_1002BBBA0;
    if (off_1002BBBA0 == &_os_log_default)
    {
      os_log_t v10 = os_log_create("com.apple.isp", "general");
      off_1002BBBA0 = v10;
    }
    if (!os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
LABEL_13:
      if (a1) {
        return;
      }
      goto LABEL_14;
    }
    sub_100073D2C();
    if (!a1) {
LABEL_14:
    }
      sub_100013B90(a2, a6);
  }
}

void sub_100013B90(double *a1, uint64_t a2)
{
  sub_100014A5C(*a1 - *(double *)(a2 + 8), (uint64_t)"X", (char *)a2);
  sub_100014A5C(a1[1] - *(double *)(a2 + 16), (uint64_t)"Y", (char *)(a2 + 2));
  double v4 = a1[2] - *(double *)(a2 + 24);

  sub_100014A5C(v4, (uint64_t)"Z", (char *)(a2 + 4));
}

void sub_100013C10(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void *a5)
{
  v20[0].i32[0] = 2;
  uint64_t v21 = -1;
  uint64_t v22 = -1;
  int64x2_t v23 = vdupq_n_s64(0x7FF8000000000000uLL);
  uint64_t v24 = 0x7FF8000000000000;
  sub_100013F70(v20);
  uint64_t v8 = a5[1];
  uint64_t v22 = a5[2];
  uint64_t v21 = v8;
  uint64_t v9 = a5[6];
  v23.i64[0] = a5[5];
  v23.i64[1] = v9;
  uint64_t v24 = a5[7];
  sub_100013938("/var/mobile/Library/ISP/Pearl/GmcThresholds.bin", v20, 0x1B0u);
  if ((analytics_send_event_lazy() & 1) == 0)
  {
    os_log_t v10 = (os_log_t)off_1002BBBA0;
    if (off_1002BBBA0 == &_os_log_default)
    {
      os_log_t v10 = os_log_create("com.apple.isp", "general");
      off_1002BBBA0 = v10;
    }
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR)) {
      sub_100073DA0();
    }
  }
  if (*(double *)(a2 + 376) >= 0.0)
  {
    v25[0].i32[0] = 2;
    v29[5] = -1;
    v29[6] = -1;
    v29[7] = 0x7FF8000000000000;
    int64x2_t v30 = vdupq_n_s64(0x7FF8000000000000uLL);
    sub_100013F70(v25);
    long long v11 = *(_OWORD *)(a1 + 13096);
    v34[2] = *(_OWORD *)(a1 + 13080);
    v34[3] = v11;
    uint64_t v35 = *(void *)(a1 + 13112);
    long long v12 = *(_OWORD *)(a1 + 13064);
    v34[0] = *(_OWORD *)(a1 + 13048);
    v34[1] = v12;
    double v31 = 0.0;
    double v32 = 0.0;
    double v33 = 0.0;
    sub_100005E50((uint64_t)v34, &v31);
    double v13 = v32;
    double v14 = v33;
    ++v25[0].i32[1];
    sub_100014C5C(v31, (uint64_t)"X", (double *)&v25[0].i64[1]);
    sub_100014C5C(v13, (uint64_t)"Y", &v26);
    sub_100014C5C(v14, (uint64_t)"Z", &v27);
    uint64_t v15 = 0;
    double v28 = v28 * 0.99
        + (double)(int)llround((*(double *)(a2 + 88) * *(double *)(a1 + 24) / *(double *)(a1 + 32) + -1.0) * 10000.0)
        * 0.01;
    double v16 = 0.05;
    do
    {
      double v17 = v28;
      if (v28 > v16)
      {
        int v18 = (*((unsigned char *)v29 + v15))++ + 1;
        if (v18 == 10)
        {
          sub_100014E88();
          double v17 = v28;
        }
      }
      if (v17 < -v16)
      {
        int v19 = (*((unsigned char *)v29 + v15 + 1))++ + 1;
        if (v19 == 10) {
          sub_100014E88();
        }
      }
      double v16 = v16 + 0.05;
      v15 += 2;
    }
    while (v15 != 40);
    sub_100013938("/var/mobile/Library/ISP/Pearl/GmcThresholds.bin", v25, 0x1B0u);
  }
}

FILE *sub_100013F70(int64x2_t *a1)
{
  double result = (FILE *)sub_1000138A8("/var/mobile/Library/ISP/Pearl/GmcThresholds.bin", a1, 0x1B0u);
  if (result) {
    BOOL v3 = a1->i32[0] == 2;
  }
  else {
    BOOL v3 = 0;
  }
  if (!v3)
  {
    *(void *)&__src[97] = -1;
    *(void *)&__src[99] = -1;
    a1->i32[0] = 2;
    memcpy((char *)a1->i64 + 4, __src, 0x194uLL);
    a1[25].i64[1] = 0x7FF8000000000000;
    a1[26] = vdupq_n_s64(0x7FF8000000000000uLL);
    return sub_100013938("/var/mobile/Library/ISP/Pearl/GmcThresholds.bin", a1, 0x1B0u);
  }
  return result;
}

void *sub_100014068(uint64_t a1)
{
  xpc_object_t v2 = xpc_dictionary_create(0, 0, 0);
  BOOL v3 = v2;
  if (v2)
  {
    xpc_dictionary_set_uint64(v2, "Duration", *(void *)(*(void *)(a1 + 32) + 32));
    xpc_dictionary_set_int64(v3, "Status", (uint64_t)*(double *)(*(void *)(a1 + 40) + 376));
    double v4 = *(double **)(a1 + 40);
    if (v4[47] >= 0.0)
    {
      xpc_dictionary_set_double(v3, "SpatialCoverage", *v4);
      xpc_dictionary_set_double(v3, "RotationX", *(double *)(*(void *)(a1 + 32) + 40));
      xpc_dictionary_set_double(v3, "RotationY", *(double *)(*(void *)(a1 + 32) + 48));
      xpc_dictionary_set_double(v3, "RotationZ", *(double *)(*(void *)(a1 + 32) + 56));
      double v5 = (*(double *)(*(void *)(a1 + 40) + 88)
          * *(double *)(*(void *)(a1 + 48) + 24)
          / *(double *)(*(void *)(a1 + 48) + 32)
          + -1.0)
         * 100.0;
      xpc_dictionary_set_double(v3, "EflPctDiffFromAssembly", v5);
      xpc_dictionary_set_double(v3, "EflPctDiffFromPrev", v5- (*(double *)(*(void *)(a1 + 40) + 88)* *(double *)(*(void *)(a1 + 56) + 24)/ *(double *)(*(void *)(a1 + 56) + 32)+ -1.0)* 100.0);
      xpc_dictionary_set_double(v3, "TimeSincePrevSuccessfulRun", (double)*(unint64_t *)(a1 + 64));
    }
    xpc_dictionary_set_double(v3, "TimeSincePrevRun", (double)*(unint64_t *)(a1 + 72));
    xpc_dictionary_set_double(v3, "RotationXDiffFromPrev", *(double *)(a1 + 80));
    xpc_dictionary_set_double(v3, "RotationYDiffFromPrev", *(double *)(a1 + 88));
    xpc_dictionary_set_double(v3, "RotationZDiffFromPrev", *(double *)(a1 + 96));
    uint64_t v6 = *(void *)(a1 + 32);
    if (*(unsigned char *)(v6 + 64))
    {
      xpc_dictionary_set_double(v3, "ISFConfidence", *(double *)(v6 + 24));
      xpc_dictionary_set_double(v3, "ISFDuration", **(double **)(a1 + 32));
      double v23 = 0.0;
      double v24 = 0.0;
      double v25 = 0.0;
      uint64_t v7 = *(void *)(a1 + 48);
      uint64_t v22 = *(void *)(v7 + 13112);
      long long v8 = *(_OWORD *)(v7 + 13096);
      long long v20 = *(_OWORD *)(v7 + 13080);
      long long v21 = v8;
      long long v9 = *(_OWORD *)(v7 + 13064);
      long long v18 = *(_OWORD *)(v7 + 13048);
      long long v19 = v9;
      sub_100005E50((uint64_t)&v18, &v23);
      double v15 = 0.0;
      double v16 = 0.0;
      double v17 = 0.0;
      uint64_t v10 = *(void *)(a1 + 56);
      uint64_t v22 = *(void *)(v10 + 13112);
      long long v11 = *(_OWORD *)(v10 + 13096);
      long long v20 = *(_OWORD *)(v10 + 13080);
      long long v21 = v11;
      long long v12 = *(_OWORD *)(v10 + 13064);
      long long v18 = *(_OWORD *)(v10 + 13048);
      long long v19 = v12;
      sub_100005E50((uint64_t)&v18, &v15);
      xpc_dictionary_set_double(v3, "FilteredRotationX", v23);
      xpc_dictionary_set_double(v3, "FilteredRotationY", v24);
      xpc_dictionary_set_double(v3, "FilteredRotationZ", v25);
      xpc_dictionary_set_double(v3, "FilteredRotationXDiffFromPrev", v23 - v15);
      xpc_dictionary_set_double(v3, "FilteredRotationYDiffFromPrev", v24 - v16);
      xpc_dictionary_set_double(v3, "FilteredRotationZDiffFromPrev", v25 - v17);
    }
    uint64_t v13 = *(unsigned int *)(a1 + 104);
    if ((int)v13 >= 1) {
      xpc_dictionary_set_uint64(v3, "ScanModeStep", v13);
    }
  }
  return v3;
}

void sub_100014390()
{
  if ((analytics_send_event_lazy() & 1) == 0)
  {
    os_log_t v0 = (os_log_t)off_1002BBBA0;
    if (off_1002BBBA0 == &_os_log_default)
    {
      os_log_t v0 = os_log_create("com.apple.isp", "general");
      off_1002BBBA0 = v0;
    }
    if (os_log_type_enabled(v0, OS_LOG_TYPE_ERROR)) {
      sub_100073E14();
    }
  }
}

void *sub_100014474(void *a1)
{
  xpc_object_t v2 = xpc_dictionary_create(0, 0, 0);
  BOOL v3 = v2;
  if (v2)
  {
    xpc_dictionary_set_int64(v2, "Status", (uint64_t)*(double *)(a1[4] + 376));
    xpc_dictionary_set_uint64(v3, "Duration", a1[5]);
    double v4 = (double *)a1[4];
    if (v4[47] >= 0.0)
    {
      uint64_t v5 = a1[6];
      double v6 = v4[31];
      double v7 = v4[32];
      double v8 = v4[33];
      long long v9 = *(_OWORD *)(v5 + 8600);
      v18[2] = *(_OWORD *)(v5 + 8584);
      v18[3] = v9;
      uint64_t v19 = *(void *)(v5 + 8616);
      long long v10 = *(_OWORD *)(v5 + 8568);
      v18[0] = *(_OWORD *)(v5 + 8552);
      v18[1] = v10;
      double v15 = 0.0;
      double v16 = 0.0;
      double v17 = 0.0;
      sub_100005E50((uint64_t)v18, &v15);
      double v11 = v6 - v15;
      double v12 = v7 - v16;
      double v13 = v8 - v17;
      xpc_dictionary_set_double(v3, "RotationX", v11);
      xpc_dictionary_set_double(v3, "RotationY", v12);
      xpc_dictionary_set_double(v3, "RotationZ", v13);
    }
  }
  return v3;
}

void sub_100014594()
{
  if ((analytics_send_event_lazy() & 1) == 0)
  {
    os_log_t v0 = (os_log_t)off_1002BBBA0;
    if (off_1002BBBA0 == &_os_log_default)
    {
      os_log_t v0 = os_log_create("com.apple.isp", "general");
      off_1002BBBA0 = v0;
    }
    if (os_log_type_enabled(v0, OS_LOG_TYPE_ERROR)) {
      sub_100073E88();
    }
  }
}

void *sub_100014678(uint64_t a1)
{
  xpc_object_t v2 = xpc_dictionary_create(0, 0, 0);
  BOOL v3 = v2;
  if (v2)
  {
    xpc_dictionary_set_uint64(v2, "Duration", *(void *)(a1 + 32));
    xpc_dictionary_set_uint64(v3, "Status", *(int *)(a1 + 48));
    if (!*(_DWORD *)(a1 + 48))
    {
      uint64_t v4 = *(int *)(*(void *)(a1 + 40) + 20);
      if (v4 <= 2) {
        xpc_dictionary_set_string(v3, "SelectedMode", off_100096380[v4]);
      }
      int v5 = *(_DWORD *)(a1 + 52);
      if (v5)
      {
        if (v5 != 1)
        {
LABEL_10:
          xpc_dictionary_set_double(v3, "RotationX", *(float *)(*(void *)(a1 + 40) + 8));
          xpc_dictionary_set_double(v3, "RotationY", *(float *)(*(void *)(a1 + 40) + 12));
          xpc_dictionary_set_double(v3, "RotationZ", *(float *)(*(void *)(a1 + 40) + 16));
          xpc_dictionary_set_double(v3, "Confidence", **(double **)(a1 + 40));
          return v3;
        }
        double v6 = "FullGrid";
      }
      else
      {
        double v6 = "LMV";
      }
      xpc_dictionary_set_string(v3, "CalculationMode", v6);
      goto LABEL_10;
    }
  }
  return v3;
}

void *sub_1000147B8(uint64_t a1)
{
  xpc_object_t v2 = xpc_dictionary_create(0, 0, 0);
  BOOL v3 = v2;
  if (v2)
  {
    xpc_dictionary_set_uint64(v2, "Status", *(unsigned int *)(a1 + 48));
    xpc_dictionary_set_string(v3, "Mode", "StereoGmc");
    xpc_dictionary_set_int64(v3, "StereoGmcStatus", 0);
    if (!*(_DWORD *)(a1 + 48))
    {
      uint64_t v4 = *(void *)(a1 + 32);
      int v5 = *(double **)(a1 + 40);
      double v6 = *v5;
      double v7 = v5[1];
      double v8 = v5[2];
      long long v9 = *(_OWORD *)(v4 + 8600);
      v18[2] = *(_OWORD *)(v4 + 8584);
      v18[3] = v9;
      uint64_t v19 = *(void *)(v4 + 8616);
      long long v10 = *(_OWORD *)(v4 + 8568);
      v18[0] = *(_OWORD *)(v4 + 8552);
      v18[1] = v10;
      double v15 = 0.0;
      double v16 = 0.0;
      double v17 = 0.0;
      sub_100005E50((uint64_t)v18, &v15);
      double v11 = v6 - v15;
      double v12 = v7 - v16;
      double v13 = v8 - v17;
      xpc_dictionary_set_double(v3, "RotationX", v11);
      xpc_dictionary_set_double(v3, "RotationY", v12);
      xpc_dictionary_set_double(v3, "RotationZ", v13);
    }
  }
  return v3;
}

void *sub_1000148E0(uint64_t a1)
{
  xpc_object_t v2 = xpc_dictionary_create(0, 0, 0);
  BOOL v3 = v2;
  if (v2)
  {
    xpc_dictionary_set_uint64(v2, "Status", *(unsigned int *)(a1 + 64));
    double v4 = *(double *)(a1 + 32);
    if (v4 != 4025479150.0) {
      xpc_dictionary_set_int64(v3, "StereoGmcStatus", (uint64_t)v4);
    }
    int v5 = *(_DWORD *)(a1 + 68);
    if (v5 == 1)
    {
      xpc_dictionary_set_string(v3, "Mode", "FullGrid");
      xpc_dictionary_set_double(v3, "MIConfidence", *(double *)(a1 + 40));
    }
    else if (!v5)
    {
      xpc_dictionary_set_string(v3, "Mode", "LMV");
    }
    if (!*(_DWORD *)(a1 + 64))
    {
      uint64_t v6 = *(void *)(a1 + 48);
      double v7 = *(double **)(a1 + 56);
      double v8 = *v7;
      double v9 = v7[1];
      double v10 = v7[2];
      long long v11 = *(_OWORD *)(v6 + 8600);
      v20[2] = *(_OWORD *)(v6 + 8584);
      v20[3] = v11;
      uint64_t v21 = *(void *)(v6 + 8616);
      long long v12 = *(_OWORD *)(v6 + 8568);
      v20[0] = *(_OWORD *)(v6 + 8552);
      v20[1] = v12;
      double v17 = 0.0;
      double v18 = 0.0;
      double v19 = 0.0;
      sub_100005E50((uint64_t)v20, &v17);
      double v13 = v8 - v17;
      double v14 = v9 - v18;
      double v15 = v10 - v19;
      xpc_dictionary_set_double(v3, "RotationX", v13);
      xpc_dictionary_set_double(v3, "RotationY", v14);
      xpc_dictionary_set_double(v3, "RotationZ", v15);
    }
  }
  return v3;
}

void sub_100014A5C(double a1, uint64_t a2, char *a3)
{
  int v5 = *a3;
  if ((double)(v5 + 1) < a1)
  {
    do
    {
      *a3 = v5 + 1;
      sub_100014B14();
      LOBYTE(v5) = *a3;
    }
    while ((double)(*a3 + 1) < a1);
  }
  int v6 = a3[1];
  if ((double)(v6 - 1) > a1)
  {
    do
    {
      a3[1] = v6 - 1;
      sub_100014B14();
      LOBYTE(v6) = a3[1];
    }
    while ((double)((char)v6 - 1) > a1);
  }
}

void sub_100014B14()
{
  if ((analytics_send_event_lazy() & 1) == 0)
  {
    os_log_t v0 = (os_log_t)off_1002BBBA0;
    if (off_1002BBBA0 == &_os_log_default)
    {
      os_log_t v0 = os_log_create("com.apple.isp", "general");
      off_1002BBBA0 = v0;
    }
    if (os_log_type_enabled(v0, OS_LOG_TYPE_ERROR)) {
      sub_100073EFC();
    }
  }
}

void *sub_100014BF8(uint64_t a1)
{
  xpc_object_t v2 = xpc_dictionary_create(0, 0, 0);
  BOOL v3 = v2;
  if (v2)
  {
    xpc_dictionary_set_int64(v2, "ThresholdPassed", *(char *)(a1 + 40));
    xpc_dictionary_set_string(v3, "Axis", *(const char **)(a1 + 32));
  }
  return v3;
}

void sub_100014C5C(double a1, uint64_t a2, double *a3)
{
  *a3 = *a3 * 0.99 + a1 * 0.01;
  double v4 = (char *)a3 + 9;
  uint64_t v5 = -50;
  int v6 = -1;
  double v7 = 1.0;
  do
  {
    double v8 = *a3;
    if (*a3 > v7)
    {
      int v9 = (*(v4 - 1))++ + 1;
      if (v9 == 10)
      {
        sub_100014D40();
        double v8 = *a3;
      }
    }
    if (v8 < (double)v6)
    {
      int v10 = (*v4)++ + 1;
      if (v10 == 10) {
        sub_100014D40();
      }
    }
    double v7 = v7 + 1.0;
    v4 += 2;
    --v6;
  }
  while (!__CFADD__(v5++, 1));
}

void sub_100014D40()
{
  if ((analytics_send_event_lazy() & 1) == 0)
  {
    os_log_t v0 = (os_log_t)off_1002BBBA0;
    if (off_1002BBBA0 == &_os_log_default)
    {
      os_log_t v0 = os_log_create("com.apple.isp", "general");
      off_1002BBBA0 = v0;
    }
    if (os_log_type_enabled(v0, OS_LOG_TYPE_ERROR)) {
      sub_100073F70();
    }
  }
}

void *sub_100014E24(uint64_t a1)
{
  xpc_object_t v2 = xpc_dictionary_create(0, 0, 0);
  BOOL v3 = v2;
  if (v2)
  {
    xpc_dictionary_set_int64(v2, "ThresholdPassed", *(char *)(a1 + 40));
    xpc_dictionary_set_string(v3, "Axis", *(const char **)(a1 + 32));
  }
  return v3;
}

void sub_100014E88()
{
  if ((analytics_send_event_lazy() & 1) == 0)
  {
    os_log_t v0 = (os_log_t)off_1002BBBA0;
    if (off_1002BBBA0 == &_os_log_default)
    {
      os_log_t v0 = os_log_create("com.apple.isp", "general");
      off_1002BBBA0 = v0;
    }
    if (os_log_type_enabled(v0, OS_LOG_TYPE_ERROR)) {
      sub_100073FE4();
    }
  }
}

xpc_object_t sub_100014F68(uint64_t a1)
{
  xpc_object_t v2 = xpc_dictionary_create(0, 0, 0);
  xpc_object_t v3 = v2;
  if (v2) {
    xpc_dictionary_set_double(v2, "ThresholdPassed", *(double *)(a1 + 32));
  }
  return v3;
}

void sub_100014FCC(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_error_impl(a1, a2, OS_LOG_TYPE_ERROR, a4, &a9, 0x12u);
}

uint64_t sub_100014FE8(int a1, io_iterator_t iterator)
{
  uint64_t result = IOIteratorNext(iterator);
  if (result) {
    operator new();
  }
  return result;
}

void sub_100015064()
{
}

uint64_t sub_100015088(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = 0;
  *(void *)(a1 + 32) = a2;
  *(void *)(a1 + 40) = 0;
  *(_DWORD *)(a1 + 48) = 0;
  CFRunLoopRef Current = CFRunLoopGetCurrent();
  *(void *)(a1 + 56) = CFRetain(Current);
  if (a2) {
    *(void *)(a2 + 592) = a1;
  }
  return a1;
}

uint64_t sub_1000150D8(uint64_t a1)
{
  io_object_t v2 = *(_DWORD *)(a1 + 16);
  if (v2)
  {
    IOObjectRelease(v2);
    *(_DWORD *)(a1 + 16) = 0;
  }
  xpc_object_t v3 = *(IONotificationPort **)a1;
  if (*(void *)a1)
  {
    double v4 = *(__CFRunLoopSource **)(a1 + 8);
    if (v4)
    {
      CFRunLoopRemoveSource(*(CFRunLoopRef *)(a1 + 56), v4, kCFRunLoopDefaultMode);
      *(void *)(a1 + 8) = 0;
      xpc_object_t v3 = *(IONotificationPort **)a1;
    }
    IONotificationPortDestroy(v3);
    *(void *)a1 = 0;
  }
  uint64_t v5 = *(void *)(a1 + 24);
  if (v5)
  {
    sub_1000113F4(v5);
    operator delete();
  }
  *(void *)(a1 + 32) = 0;
  int v6 = *(const void **)(a1 + 40);
  if (v6) {
    CFRelease(v6);
  }
  double v7 = *(const void **)(a1 + 56);
  if (v7) {
    CFRelease(v7);
  }
  return a1;
}

uint64_t sub_100015188(uint64_t a1)
{
  CFDictionaryRef v2 = IOServiceMatching("AppleH16PhotonDetector");
  CFMutableArrayRef Mutable = CFArrayCreateMutable(0, 0, 0);
  *(void *)(a1 + 40) = Mutable;
  if (Mutable)
  {
    uint64_t v4 = IOMasterPort(bootstrap_port, (mach_port_t *)(a1 + 48));
    if (!v4)
    {
      uint64_t v5 = IONotificationPortCreate(*(_DWORD *)(a1 + 48));
      *(void *)a1 = v5;
      if (v5)
      {
        RunLoopSource = IONotificationPortGetRunLoopSource(v5);
        *(void *)(a1 + 8) = RunLoopSource;
        if (RunLoopSource)
        {
          CFRunLoopAddSource(*(CFRunLoopRef *)(a1 + 56), RunLoopSource, kCFRunLoopDefaultMode);
          uint64_t v4 = IOServiceAddMatchingNotification(*(IONotificationPortRef *)a1, "IOServiceMatched", v2, (IOServiceMatchingCallback)sub_100014FE8, (void *)a1, (io_iterator_t *)(a1 + 16));
          if (!v4) {
            sub_100014FE8(a1, *(_DWORD *)(a1 + 16));
          }
        }
        else
        {
          os_log_t v24 = (os_log_t)off_1002BBBA8;
          if (off_1002BBBA8 == &_os_log_default)
          {
            os_log_t v24 = os_log_create("com.apple.isp", "photon");
            off_1002BBBA8 = v24;
          }
          if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR)) {
            sub_100074148(v24, v25, v26, v27, v28, v29, v30, v31);
          }
          uint64_t v4 = 3758097086;
          IONotificationPortDestroy(*(IONotificationPortRef *)a1);
          *(void *)a1 = 0;
        }
      }
      else
      {
        os_log_t v16 = (os_log_t)off_1002BBBA8;
        if (off_1002BBBA8 == &_os_log_default)
        {
          os_log_t v16 = os_log_create("com.apple.isp", "photon");
          off_1002BBBA8 = v16;
        }
        uint64_t v4 = 3758097086;
        if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR)) {
          sub_1000740D0(v16, v17, v18, v19, v20, v21, v22, v23);
        }
      }
    }
  }
  else
  {
    os_log_t v7 = (os_log_t)off_1002BBBA8;
    if (off_1002BBBA8 == &_os_log_default)
    {
      os_log_t v7 = os_log_create("com.apple.isp", "photon");
      off_1002BBBA8 = v7;
    }
    uint64_t v4 = 3758097085;
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR)) {
      sub_100074058(v7, v8, v9, v10, v11, v12, v13, v14);
    }
  }
  return v4;
}

uint64_t sub_10001538C(uint64_t a1)
{
  if (CFArrayGetCount(*(CFArrayRef *)(a1 + 40)) != 1) {
    return 3758097088;
  }
  ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 40), 0);
  *(void *)(a1 + 24) = ValueAtIndex;
  if (!ValueAtIndex) {
    return 3758097088;
  }

  return sub_1000113F8((uint64_t)ValueAtIndex);
}

uint64_t sub_1000153F8(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 24);
  if (v1) {
    return sub_100011378(v1);
  }
  else {
    return 3758097088;
  }
}

uint64_t sub_100015410(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 24);
  if (v1) {
    return sub_1000114A0(v1);
  }
  else {
    return 3758097088;
  }
}

uint64_t sub_100015428(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 24);
  if (v1) {
    return sub_1000114CC(v1);
  }
  else {
    return 3758097088;
  }
}

uint64_t sub_100015440(uint64_t a1, unsigned char *a2, unsigned char *a3)
{
  uint64_t v3 = *(void *)(a1 + 24);
  if (v3) {
    return sub_1000114F8(v3, a2, a3);
  }
  else {
    return 3758097088;
  }
}

void sub_100015458(uint64_t a1, void *a2, void *a3)
{
  uint64_t v3 = *(void *)(a1 + 24);
  if (v3) {
    sub_100011570(v3, a2, a3);
  }
}

void sub_100015468(uint64_t a1)
{
}

void sub_100015524()
{
}

uint64_t sub_100015548(void *a1, uint64_t a2)
{
  sub_100015648((uint64_t)&v9);
  pthread_t v6 = 0;
  v7[0] = 0;
  v7[1] = a2;
  v7[2] = &v9;
  uint64_t v5 = 49;
  pthread_attr_init(&v8);
  pthread_attr_setschedparam(&v8, (const sched_param *)&v5);
  pthread_attr_setdetachstate(&v8, 1);
  pthread_create(&v6, &v8, (void *(__cdecl *)(void *))sub_100015468, v7);
  pthread_attr_destroy(&v8);
  pthread_cond_wait(&v10, &v9);
  *a1 = v7[0];
  return sub_100015688((uint64_t)&v9);
}

void sub_10001562C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,char a22)
{
}

uint64_t sub_100015648(uint64_t a1)
{
  return a1;
}

uint64_t sub_100015688(uint64_t a1)
{
  return a1;
}

void sub_1000156C0(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_error_impl(a1, a2, OS_LOG_TYPE_ERROR, a4, &a9, 0xCu);
}

uint64_t sub_1000156DC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, BOOL *a5, double *a6, double a7)
{
  int v9 = *(_DWORD *)(a1 + 20);
  if (v9)
  {
    sub_1000032CC((uint64_t)v20, 1, v9);
    v20[0] = &off_100095AB0;
    sub_100015804(a2, a1, a3, (uint64_t)v20);
    double v15 = sub_100015990((uint64_t)v20);
    LODWORD(v15) = v21;
    double v16 = round(a7 * (double)*(unint64_t *)&v15 + -1.0);
    if (v16 >= 0.0)
    {
      uint64_t v17 = 0;
      double v18 = *(double *)(v20[1] + 8 * v16);
      *a6 = v18;
      *a5 = v18 < *(double *)(a4 + 632);
    }
    else
    {
      uint64_t v17 = 4294967291;
    }
    sub_100003224((uint64_t)v20);
  }
  else
  {
    uint64_t v17 = 0;
    *a5 = 1;
  }
  return v17;
}

void sub_1000157F0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_100015804(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7 = 0;
  uint64_t v29 = 0;
  memset(v28, 0, sizeof(v28));
  pthread_attr_t v8 = v28;
  do
  {
    uint64_t v9 = 0;
    pthread_cond_t v10 = v8;
    do
    {
      *pthread_cond_t v10 = *(void *)(a3 + v9);
      v10 += 3;
      v9 += 8;
    }
    while (v9 != 24);
    ++v7;
    pthread_attr_t v8 = (_OWORD *)((char *)v8 + 8);
    a3 += 24;
  }
  while (v7 != 3);
  if (*(_DWORD *)(a1 + 20))
  {
    unint64_t v11 = 0;
    do
    {
      sub_100015A0C(a1, v11, v27);
      uint64_t v12 = 0;
      long long v25 = 0uLL;
      uint64_t v13 = v28;
      uint64_t v26 = 0;
      do
      {
        uint64_t v14 = 0;
        double v15 = 0.0;
        do
        {
          double v15 = v15 + *(double *)((char *)v13 + v14 * 8) * *(double *)&v27[v14];
          ++v14;
        }
        while (v14 != 3);
        *((double *)&v25 + v12++) = v15;
        uint64_t v13 = (_OWORD *)((char *)v13 + 24);
      }
      while (v12 != 3);
      sub_100015A0C(a2, v11, &v23);
      uint64_t v16 = 0;
      long long v21 = v25;
      uint64_t v22 = v26;
      long long v19 = v23;
      uint64_t v20 = v24;
      double v17 = 0.0;
      do
      {
        double v17 = v17 + *(double *)((char *)&v21 + v16) * *(double *)((char *)&v19 + v16);
        v16 += 8;
      }
      while (v16 != 24);
      *(double *)(*(void *)(a4 + 8) + 8 * v11++) = fabs(v17)
                                                   / sqrt(*((double *)&v25 + 1) * *((double *)&v25 + 1)+ *(double *)&v25 * *(double *)&v25);
    }
    while (v11 < *(unsigned int *)(a1 + 20));
  }
  return 0;
}

double sub_100015990(uint64_t a1)
{
  unint64_t v1 = *(unsigned int *)(a1 + 20);
  if ((int)v1 >= 2)
  {
    uint64_t v2 = 0;
    uint64_t v3 = 1;
    do
    {
      uint64_t v4 = v2 + 1;
      uint64_t v5 = *(void *)(a1 + 8);
      if (v2 + 1 >= v1)
      {
        unsigned int v7 = v2;
      }
      else
      {
        uint64_t v6 = v3;
        unsigned int v7 = v2;
        do
        {
          if (*(double *)(v5 + 8 * v6) < *(double *)(v5 + 8 * v7)) {
            unsigned int v7 = v6;
          }
          ++v6;
        }
        while (v1 != v6);
      }
      double result = *(double *)(v5 + 8 * v7);
      *(void *)(v5 + 8 * v7) = *(void *)(v5 + 8 * v2);
      *(double *)(*(void *)(a1 + 8) + 8 * v2) = result;
      ++v3;
      ++v2;
    }
    while (v4 != v1 - 1);
  }
  return result;
}

double sub_100015A0C@<D0>(uint64_t a1@<X0>, unsigned int a2@<W1>, void *a3@<X8>)
{
  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  if (!*(_DWORD *)(a1 + 16) || (uint64_t v3 = *(int *)(a1 + 20), v3 <= a2)) {
    sub_1000741C0();
  }
  uint64_t v4 = 0;
  uint64_t v5 = (double *)(*(void *)(a1 + 8) + 8 * a2);
  uint64_t v6 = 8 * v3;
  do
  {
    double result = *v5;
    a3[v4++] = *(void *)v5;
    uint64_t v5 = (double *)((char *)v5 + v6);
  }
  while ((v4 * 8) != 24);
  return result;
}

void sub_100016E24(uint64_t a1)
{
  if (a1)
  {
    uint64_t v2 = (pthread_mutex_t *)(a1 + 336);
    pthread_mutex_lock((pthread_mutex_t *)(a1 + 336));
    uint64_t v3 = *(OpaqueAudioComponentInstance **)(a1 + 16);
    if (v3)
    {
      if (AudioOutputUnitStop(v3))
      {
        os_log_t v4 = (os_log_t)off_1002BBC70;
        if (off_1002BBC70 == &_os_log_default)
        {
          os_log_t v4 = os_log_create("com.apple.isp", "general");
          off_1002BBC70 = v4;
        }
        if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR)) {
          sub_100074DC0();
        }
      }
      sub_1000174F0(a1);
    }
    pthread_mutex_unlock(v2);
  }
  else
  {
    os_log_t v5 = (os_log_t)off_1002BBC70;
    if (off_1002BBC70 == &_os_log_default)
    {
      os_log_t v5 = os_log_create("com.apple.isp", "general");
      off_1002BBC70 = v5;
    }
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR)) {
      sub_100074D8C();
    }
  }
}

char *sub_100016F48(int a1)
{
  if (a1)
  {
    uint64_t v2 = (char *)malloc_type_calloc(1uLL, 0x2C8uLL, 0x10A00403CF60310uLL);
    uint64_t v3 = v2;
    if (v2)
    {
      pthread_mutex_init((pthread_mutex_t *)(v2 + 336), 0);
      pthread_mutex_init((pthread_mutex_t *)(v3 + 424), 0);
      pthread_cond_init((pthread_cond_t *)(v3 + 488), 0);
      uint64_t v4 = 0;
      v3[328] = 0;
      v3[8] = 1;
      *((_DWORD *)v3 + 16) = 4096;
      *((void *)v3 + 36) = 0;
      *((_DWORD *)v3 + 102) = 0;
      do
      {
        if (*(_DWORD *)((char *)&unk_100096398 + v4) == a1) {
          *(void *)uint64_t v3 = (char *)&unk_100096398 + v4;
        }
        v4 += 16;
      }
      while (v4 != 160);
      *((void *)v3 + 39) = 0;
      *((void *)v3 + 40) = 0;
      *((_DWORD *)v3 + 76) = 1065353216;
      os_log_t v5 = objc_alloc_init(FlickerResourceArbiterClientDelegate);
      *((void *)v3 + 50) = v5;
      [(FlickerResourceArbiterClientDelegate *)v5 setFlickerContext:v3];
    }
  }
  else
  {
    uint64_t v3 = 0;
  }
  os_log_t v6 = (os_log_t)off_1002BBC70;
  if (off_1002BBC70 == &_os_log_default)
  {
    os_log_t v6 = os_log_create("com.apple.isp", "general");
    off_1002BBC70 = v6;
  }
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    int v8 = 136315650;
    uint64_t v9 = "H16ISPFlickerDetectorCreate";
    __int16 v10 = 1024;
    int v11 = a1;
    __int16 v12 = 2048;
    uint64_t v13 = v3;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "%s - HWType = %d; pContext = %p \n\n",
      (uint8_t *)&v8,
      0x1Cu);
  }
  return v3;
}

uint64_t sub_100017100(uint64_t a1)
{
  if (!a1) {
    return 3758097090;
  }
  [*(id *)(a1 + 400) cleanup];

  pthread_mutex_lock((pthread_mutex_t *)(a1 + 424));
  pthread_cond_broadcast((pthread_cond_t *)(a1 + 488));
  pthread_mutex_unlock((pthread_mutex_t *)(a1 + 424));
  pthread_cond_destroy((pthread_cond_t *)(a1 + 488));
  pthread_mutex_destroy((pthread_mutex_t *)(a1 + 424));
  pthread_mutex_destroy((pthread_mutex_t *)(a1 + 336));
  free((void *)a1);
  os_log_t v2 = (os_log_t)off_1002BBC70;
  if (off_1002BBC70 == &_os_log_default)
  {
    os_log_t v2 = os_log_create("com.apple.isp", "general");
    off_1002BBC70 = v2;
  }
  BOOL v3 = os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT);
  uint64_t result = 0;
  if (v3)
  {
    int v5 = 136315138;
    os_log_t v6 = "H16ISPFlickerDetectorDispose";
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "%s - Success\n", (uint8_t *)&v5, 0xCu);
    return 0;
  }
  return result;
}

uint64_t sub_100017248(uint64_t a1)
{
  if (!a1) {
    return 3758097090;
  }
  os_log_t v2 = (pthread_mutex_t *)(a1 + 336);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 336));
  *(unsigned char *)(a1 + 328) = 0;
  pthread_mutex_unlock(v2);
  [*(id *)(a1 + 400) requestResourceAccess];
  os_log_t v3 = (os_log_t)off_1002BBC70;
  if (off_1002BBC70 == &_os_log_default)
  {
    os_log_t v3 = os_log_create("com.apple.isp", "general");
    off_1002BBC70 = v3;
  }
  uint64_t result = os_log_type_enabled(v3, OS_LOG_TYPE_DEBUG);
  if (result)
  {
    sub_100074E28(v3);
    return 0;
  }
  return result;
}

uint64_t sub_1000172F0(uint64_t a1)
{
  if (!a1) {
    return 3758097090;
  }
  os_log_t v2 = (pthread_mutex_t *)(a1 + 336);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 336));
  *(unsigned char *)(a1 + 328) = 1;
  pthread_mutex_unlock(v2);
  sub_100016E24(a1);
  os_log_t v3 = (os_log_t)off_1002BBC70;
  if (off_1002BBC70 == &_os_log_default)
  {
    os_log_t v3 = os_log_create("com.apple.isp", "general");
    off_1002BBC70 = v3;
  }
  uint64_t result = os_log_type_enabled(v3, OS_LOG_TYPE_DEBUG);
  if (result)
  {
    sub_100074EAC(v3);
    return 0;
  }
  return result;
}

uint64_t sub_10001739C(uint64_t a1, float a2)
{
  uint64_t v2 = 3758097097;
  float inData = a2;
  if (!a1) {
    return 3758097090;
  }
  *(float *)(a1 + 304) = a2;
  uint64_t v4 = (pthread_mutex_t *)(a1 + 336);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 336));
  int v5 = *(OpaqueAudioComponentInstance **)(a1 + 16);
  if (v5 && AudioUnitSetProperty(v5, 0x7E6u, 1u, 1u, &inData, 4u))
  {
    os_log_t v6 = (os_log_t)off_1002BBC70;
    if (off_1002BBC70 == &_os_log_default)
    {
      os_log_t v6 = os_log_create("com.apple.isp", "general");
      off_1002BBC70 = v6;
    }
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR)) {
      sub_100074F30();
    }
  }
  else
  {
    uint64_t v2 = 0;
  }
  pthread_mutex_unlock(v4);
  return v2;
}

uint64_t sub_100017488(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (!a1) {
    return 3758097090;
  }
  uint64_t result = 0;
  *(void *)(a1 + 312) = a3;
  *(void *)(a1 + 320) = a2;
  return result;
}

uint64_t sub_1000174A8(uint64_t a1, char a2)
{
  uint64_t result = 3758097090;
  if (a1)
  {
    uint64_t v4 = *(unsigned char **)(a1 + 416);
    if (v4)
    {
      uint64_t result = 0;
      *uint64_t v4 = a2;
    }
  }
  return result;
}

uint64_t sub_1000174CC(uint64_t a1, char a2)
{
  uint64_t result = 3758097090;
  if (a1)
  {
    uint64_t v4 = *(void *)(a1 + 416);
    if (v4)
    {
      uint64_t result = 0;
      *(unsigned char *)(v4 + 1) = a2;
    }
  }
  return result;
}

void sub_1000174F0(uint64_t a1)
{
  uint64_t v2 = *(OpaqueAudioComponentInstance **)(a1 + 16);
  if (v2)
  {
    AudioComponentInstanceDispose(v2);
    *(void *)(a1 + 16) = 0;
  }
  if (**(_DWORD **)a1 != 1)
  {
    os_log_t v3 = *(void **)(a1 + 120);
    if (v3)
    {
      free(v3);
      *(void *)(a1 + 120) = 0;
    }
    uint64_t v4 = *(void **)(a1 + 136);
    if (v4)
    {
      free(v4);
      *(void *)(a1 + 136) = 0;
    }
  }
  int v5 = *(void **)(a1 + 80);
  if (v5)
  {
    free(v5);
    *(void *)(a1 + 80) = 0;
  }
  os_log_t v6 = *(void **)(a1 + 96);
  if (v6)
  {
    free(v6);
    *(void *)(a1 + 96) = 0;
  }
  unsigned int v7 = *(void **)(a1 + 152);
  if (v7)
  {
    free(v7);
    *(void *)(a1 + 152) = 0;
  }
  int v8 = *(void **)(a1 + 168);
  if (v8)
  {
    free(v8);
    *(void *)(a1 + 168) = 0;
  }
  uint64_t v9 = *(OpaqueFFTSetup **)(a1 + 240);
  if (v9)
  {
    vDSP_destroy_fftsetup(v9);
    *(void *)(a1 + 240) = 0;
  }
  __int16 v10 = *(void **)(a1 + 184);
  if (v10)
  {
    free(v10);
    *(void *)(a1 + 184) = 0;
  }
  int v11 = *(void **)(a1 + 200);
  if (v11)
  {
    free(v11);
    *(void *)(a1 + 200) = 0;
  }
  __int16 v12 = *(void **)(a1 + 224);
  if (v12)
  {
    free(v12);
    *(void *)(a1 + 224) = 0;
  }
  uint64_t v13 = *(void **)(a1 + 296);
  if (v13)
  {
    free(v13);
    *(void *)(a1 + 296) = 0;
  }
  if (**(_DWORD **)a1 != 1)
  {
    uint64_t v14 = *(void **)(a1 + 216);
    if (v14)
    {
      free(v14);
      *(void *)(a1 + 216) = 0;
    }
    double v15 = *(void **)(a1 + 416);
    if (v15)
    {
      free(v15);
      *(void *)(a1 + 416) = 0;
    }
  }
}

uint64_t sub_100017610(uint64_t a1, AudioUnitRenderActionFlags *ioActionFlags, AudioTimeStamp *inTimeStamp, int a4, UInt32 inNumberFrames)
{
  if (a1)
  {
    uint64_t v9 = *(void **)(a1 + 288);
    if (v9) {
      sub_100028F08(v9);
    }
    uint64_t v10 = *(void *)(a1 + 80);
    if (!v10)
    {
      uint64_t v16 = 0;
      goto LABEL_54;
    }
    uint64_t v11 = *(_DWORD *)(a1 + 48) * inNumberFrames;
    uint64_t v13 = (void *)(a1 + 104);
    uint64_t v12 = *(void *)(a1 + 104);
    ioData.mBuffers[0].mData = (void *)(v10 + v12);
    ioData.mNumberBuffers = 1;
    ioData.mBuffers[0].mDataByteSize = v11;
    if (v12 + v11 <= (unint64_t)*(unsigned int *)(a1 + 76))
    {
      uint64_t v16 = AudioUnitRender(*(AudioUnit *)(a1 + 16), ioActionFlags, inTimeStamp, 1u, inNumberFrames, &ioData);
      if (v16)
      {
        os_log_t v25 = (os_log_t)off_1002BBC70;
        if (off_1002BBC70 == &_os_log_default)
        {
          os_log_t v25 = os_log_create("com.apple.isp", "general");
          off_1002BBC70 = v25;
        }
        if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR)) {
          sub_100075118();
        }
      }
      uint64_t v26 = *(FILE **)(a1 + 248);
      if (v26)
      {
        fwrite(ioData.mBuffers[0].mData, 1uLL, ioData.mBuffers[0].mDataByteSize, v26);
        fflush(*(FILE **)(a1 + 248));
      }
      size_t v15 = *v13 + ioData.mBuffers[0].mDataByteSize;
    }
    else
    {
      os_log_t v14 = (os_log_t)off_1002BBC70;
      if (off_1002BBC70 == &_os_log_default)
      {
        os_log_t v14 = os_log_create("com.apple.isp", "general");
        off_1002BBC70 = v14;
      }
      if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR)) {
        sub_1000750A4();
      }
      size_t v15 = 0;
      uint64_t v16 = 0;
    }
    *(void *)(a1 + 104) = v15;
    if (v15 != *(_DWORD *)(a1 + 76)) {
      goto LABEL_54;
    }
    memcpy(*(void **)(a1 + 96), (const void *)(*(void *)(a1 + 96) + v15), v15);
    memcpy((void *)(*(void *)(a1 + 96) + *(unsigned int *)(a1 + 76)), *(const void **)(a1 + 80), *(unsigned int *)(a1 + 76));
    uint64_t v27 = *(FILE **)(a1 + 256);
    if (v27)
    {
      fwrite(*(const void **)(a1 + 96), 1uLL, *(unsigned int *)(a1 + 92), v27);
      fflush(*(FILE **)(a1 + 256));
    }
    uint64_t v28 = (char *)malloc_type_calloc(1uLL, 0x110uLL, 0x1000040368141FCuLL);
    if (!v28)
    {
LABEL_53:
      *uint64_t v13 = 0;
LABEL_54:
      int8x16_t v58 = *(uint64_t **)(a1 + 288);
      if (v58) {
        sub_100028F40(v58);
      }
      return v16;
    }
    uint64_t v29 = v28;
    float v71 = NAN;
    uint64_t v70 = 0x7FC000007FC00000;
    int v69 = 2143289344;
    uint64_t v68 = 0x7FC000007FC00000;
    float v60 = NAN;
    int v67 = 0;
    uint64_t v66 = 0;
    uint64_t v30 = *(double **)(*(void *)a1 + 8);
    double v32 = *v30;
    double v31 = v30[1];
    double v33 = v30[2];
    *(void *)(a1 + 120) = *(void *)(a1 + 96);
    *(_DWORD *)(a1 + 116) = *(_DWORD *)(a1 + 92);
    vDSP_Length v34 = (unint64_t)*(unsigned int *)(a1 + 148) >> 2;
    uint64_t v35 = (uint64_t)(v32 / v33);
    if (v35 > 16 || v35 == 0)
    {
      os_log_t v37 = (os_log_t)off_1002BBC70;
      if (off_1002BBC70 == &_os_log_default)
      {
        os_log_t v37 = os_log_create("com.apple.isp", "general");
        off_1002BBC70 = v37;
      }
      if (os_log_type_enabled(v37, OS_LOG_TYPE_ERROR)) {
        sub_10007502C();
      }
      long long v64 = 0u;
      long long v65 = 0u;
      long long __F = 0u;
      long long v63 = 0u;
      uint64_t v35 = 16;
    }
    else
    {
      long long v64 = 0u;
      long long v65 = 0u;
      long long __F = 0u;
      long long v63 = 0u;
      if (v35 < 1)
      {
LABEL_42:
        vDSP_desamp(*(const float **)(a1 + 120), v35, (const float *)&__F, *(float **)(a1 + 152), v34, v35);
        float v39 = v33;
        sub_100033678(*(DSPComplex **)(a1 + 152), *(_DWORD *)(a1 + 232), (uint64_t)&v70, (uint64_t)&v68, *(float **)(a1 + 200), (FFTSetup *)(a1 + 240), v39);
        vDSP_Length v40 = (unint64_t)*(unsigned int *)(a1 + 180) >> 2;
        long long __F = xmmword_1000824B0;
        vDSP_desamp(*(const float **)(a1 + 120), (uint64_t)(v32 / v31), (const float *)&__F, *(float **)(a1 + 184), v40, (uint64_t)(v32 / v31));
        float v41 = v31;
        sub_1000347D4(*(float32x4_t **)(a1 + 184), v40, (uint64_t)&v70, (uint64_t)&v66, 3u, v41);
        int v42 = sub_100033B58(&v60, *(_DWORD **)(a1 + 224), *(float *)&v70, *(float *)&v68, *(float *)&v66, -1.0);
        *(_DWORD *)uint64_t v29 = v42;
        float v43 = *(float *)(*(void *)(a1 + 224)
                       + 4
                       * ((*(_DWORD *)(*(void *)(a1 + 224) + 8) + **(_DWORD **)(a1 + 224) - 1)
                        % **(_DWORD **)(a1 + 224))
                       + 140);
        *(float *)&uint64_t v66 = v43;
        if (v42 == 1)
        {
          if (v43 > 0.4) {
            int v44 = 1;
          }
          else {
            int v44 = 2;
          }
        }
        else
        {
          int v44 = v42;
          if (v42 != 3) {
            int v44 = 2;
          }
        }
        uint64_t v45 = 0;
        *((double *)v29 + 1) = v60 * 0.5;
        v46.i32[0] = v68;
        *((void *)v29 + 2) = 0xBFF0000000000000;
        v46.i32[1] = sqrtf(v71);
        *(float64x2_t *)(v29 + 24) = vcvtq_f64_f32(vminnm_f32(v46, (float32x2_t)vdup_n_s32(0x477FFF00u)));
        double v47 = fminf(*((float *)&v66 + 1), 65535.0);
        *((double *)v29 + 5) = fminf(v43, 65535.0);
        *((double *)v29 + 6) = v47;
        *((_DWORD *)v29 + 1) = v44;
        __asm { FMOV            V0.2D, #-1.0 }
        *(_OWORD *)(v29 + 56) = _Q0;
        *((void *)v29 + 9) = 0xBFF0000000000000;
        *((void *)v29 + 13) = 0x200000000;
        uint64_t v52 = *(void *)(a1 + 296);
        char v53 = 1;
        do
        {
          char v54 = v53;
          int8x16_t v55 = &v29[8 * v45];
          int8x16_t v56 = (void *)(v52 + 8 * v45);
          v56[1] = *((void *)v55 + 1);
          v56[3] = *((void *)v55 + 3);
          v56[5] = *((void *)v55 + 5);
          uint64_t v45 = 1;
          char v53 = 0;
        }
        while ((v54 & 1) != 0);
        *(void *)(v52 + 56) = *((void *)v29 + 7);
        *(void *)(v52 + 64) = *((void *)v29 + 8);
        *(_DWORD *)uint64_t v52 = v42;
        *(_DWORD *)(v52 + 4) = v44;
        *(void *)(v52 + 72) = *((void *)v29 + 9);
        *(_DWORD *)(v52 + 104) = 0;
        pthread_mutex_lock((pthread_mutex_t *)(a1 + 424));
        pthread_cond_broadcast((pthread_cond_t *)(a1 + 488));
        pthread_mutex_unlock((pthread_mutex_t *)(a1 + 424));
        int8x16_t v57 = *(void (**)(uint64_t, void, char *))(a1 + 312);
        if (v57) {
          v57(a1, *(void *)(a1 + 320), v29);
        }
        else {
          free(v29);
        }
        goto LABEL_53;
      }
    }
    uint64_t v38 = 0;
    do
      *((float *)&__F + v38++) = 1.0 / (float)v35;
    while (v35 > v38);
    goto LABEL_42;
  }
  os_log_t v17 = (os_log_t)off_1002BBC70;
  if (off_1002BBC70 == &_os_log_default)
  {
    os_log_t v17 = os_log_create("com.apple.isp", "general");
    off_1002BBC70 = v17;
  }
  if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR)) {
    sub_100074FB4(v17, v18, v19, v20, v21, v22, v23, v24);
  }
  return 0xFFFFFFFFLL;
}

uint64_t sub_100017C04(uint64_t a1, AudioUnitRenderActionFlags *ioActionFlags, AudioTimeStamp *inTimeStamp, int a4, UInt32 inNumberFrames)
{
  if (a1)
  {
    uint64_t v9 = *(void **)(a1 + 288);
    if (v9) {
      sub_100028F08(v9);
    }
    uint64_t v10 = *(void *)(a1 + 80);
    if (!v10)
    {
      uint64_t v16 = 0;
      goto LABEL_70;
    }
    uint64_t v11 = *(_DWORD *)(a1 + 48) * inNumberFrames;
    uint64_t v13 = (void *)(a1 + 104);
    uint64_t v12 = *(void *)(a1 + 104);
    ioData.mBuffers[0].mData = (void *)(v10 + v12);
    ioData.mNumberBuffers = 1;
    ioData.mBuffers[0].mDataByteSize = v11;
    if (v12 + v11 <= (unint64_t)*(unsigned int *)(a1 + 76))
    {
      uint64_t v16 = AudioUnitRender(*(AudioUnit *)(a1 + 16), ioActionFlags, inTimeStamp, 1u, inNumberFrames, &ioData);
      if (v16)
      {
        os_log_t v25 = (os_log_t)off_1002BBC70;
        if (off_1002BBC70 == &_os_log_default)
        {
          os_log_t v25 = os_log_create("com.apple.isp", "general");
          off_1002BBC70 = v25;
        }
        if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR)) {
          sub_1000752F4();
        }
      }
      uint64_t v26 = *(FILE **)(a1 + 248);
      if (v26)
      {
        fwrite(ioData.mBuffers[0].mData, 1uLL, ioData.mBuffers[0].mDataByteSize, v26);
        fflush(*(FILE **)(a1 + 248));
      }
      size_t v15 = *v13 + ioData.mBuffers[0].mDataByteSize;
    }
    else
    {
      os_log_t v14 = (os_log_t)off_1002BBC70;
      if (off_1002BBC70 == &_os_log_default)
      {
        os_log_t v14 = os_log_create("com.apple.isp", "general");
        off_1002BBC70 = v14;
      }
      if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR)) {
        sub_100075280();
      }
      size_t v15 = 0;
      uint64_t v16 = 0;
    }
    *(void *)(a1 + 104) = v15;
    if (v15 != *(_DWORD *)(a1 + 76)) {
      goto LABEL_70;
    }
    memcpy(*(void **)(a1 + 96), (const void *)(*(void *)(a1 + 96) + v15), v15);
    memcpy((void *)(*(void *)(a1 + 96) + *(unsigned int *)(a1 + 76)), *(const void **)(a1 + 80), *(unsigned int *)(a1 + 76));
    uint64_t v27 = *(FILE **)(a1 + 256);
    if (v27)
    {
      fwrite(*(const void **)(a1 + 96), 1uLL, *(unsigned int *)(a1 + 92), v27);
      fflush(*(FILE **)(a1 + 256));
    }
    uint64_t v28 = (char *)malloc_type_calloc(1uLL, 0x110uLL, 0x1000040368141FCuLL);
    if (!v28)
    {
LABEL_69:
      *uint64_t v13 = 0;
LABEL_70:
      int v67 = *(uint64_t **)(a1 + 288);
      if (v67) {
        sub_100028F40(v67);
      }
      return v16;
    }
    uint64_t v29 = v28;
    float v81 = NAN;
    uint64_t v80 = 0x7FC000007FC00000;
    int v79 = 2143289344;
    uint64_t v78 = 0x7FC000007FC00000;
    float v69 = NAN;
    int v77 = 0;
    uint64_t v76 = 0;
    uint64_t v30 = *(double **)(*(void *)a1 + 8);
    double v32 = *v30;
    double v31 = v30[1];
    double v33 = v30[2];
    vDSP_Length v34 = (unint64_t)*(unsigned int *)(a1 + 116) >> 2;
    vDSP_Length v35 = (unint64_t)*(unsigned int *)(a1 + 132) >> 2;
    *(void *)&long long __F = 1065353216;
    vDSP_desamp(*(const float **)(a1 + 96), 2, (const float *)&__F, *(float **)(a1 + 136), v35, 2uLL);
    uint64_t v75 = 0x3F80000000000000;
    vDSP_desamp(*(const float **)(a1 + 96), 2, (const float *)&v75, *(float **)(a1 + 120), v34, 2uLL);
    float v36 = sub_1000347A0(*(const float **)(a1 + 120), v34);
    float v37 = sub_1000347A0(*(const float **)(a1 + 136), v35);
    if (*(unsigned char *)(a1 + 8))
    {
      float v36 = sub_1000347A0((const float *)(*(void *)(a1 + 120) + 38400), v34 - 9600);
      float v38 = sub_1000347A0((const float *)(*(void *)(a1 + 136) + 38400), v35 - 9600);
      *(unsigned char *)(a1 + 8) = 0;
    }
    else
    {
      float v38 = v37;
    }
    float v39 = v36 + 0.4945;
    float v40 = v38 + 0.4945;
    BOOL v42 = (float)(v36 + 0.4945) <= (float)(v38 + 0.4945) || v39 <= 0.033 || v40 <= 0.033;
    float v43 = v40 / v39;
    if (v42) {
      float v44 = 0.0;
    }
    else {
      float v44 = v43;
    }
    uint64_t v45 = *(FILE **)(a1 + 272);
    if (v45)
    {
      fwrite(*(const void **)(a1 + 136), 1uLL, *(unsigned int *)(a1 + 132), v45);
      fflush(*(FILE **)(a1 + 272));
    }
    float32x2_t v46 = *(FILE **)(a1 + 264);
    if (v46)
    {
      fwrite(*(const void **)(a1 + 120), 1uLL, *(unsigned int *)(a1 + 116), v46);
      fflush(*(FILE **)(a1 + 264));
    }
    vDSP_Length v47 = (unint64_t)*(unsigned int *)(a1 + 148) >> 2;
    uint64_t v48 = (uint64_t)(v32 / v33);
    if (v48 > 16 || v48 == 0)
    {
      os_log_t v50 = (os_log_t)off_1002BBC70;
      if (off_1002BBC70 == &_os_log_default)
      {
        os_log_t v50 = os_log_create("com.apple.isp", "general");
        off_1002BBC70 = v50;
      }
      if (os_log_type_enabled(v50, OS_LOG_TYPE_ERROR)) {
        sub_100075208();
      }
      long long v73 = 0u;
      long long v74 = 0u;
      long long __F = 0u;
      long long v72 = 0u;
      uint64_t v48 = 16;
    }
    else
    {
      long long v73 = 0u;
      long long v74 = 0u;
      long long __F = 0u;
      long long v72 = 0u;
      if (v48 < 1)
      {
LABEL_58:
        vDSP_desamp(*(const float **)(a1 + 120), v48, (const float *)&__F, *(float **)(a1 + 152), v47, v48);
        float v52 = v33;
        sub_100033E40(*(DSPComplex **)(a1 + 152), *(_DWORD *)(a1 + 232), (float *)&v80, (uint64_t)&v78, *(float **)(a1 + 200), (FFTSetup *)(a1 + 240), v52);
        vDSP_Length v53 = (unint64_t)*(unsigned int *)(a1 + 180) >> 2;
        long long __F = xmmword_1000824B0;
        vDSP_desamp(*(const float **)(a1 + 120), (uint64_t)(v32 / v31), (const float *)&__F, *(float **)(a1 + 184), v53, (uint64_t)(v32 / v31));
        float v54 = v31;
        sub_1000347D4(*(float32x4_t **)(a1 + 184), v53, (uint64_t)&v80, (uint64_t)&v76, 3u, v54);
        LODWORD(__F) = 0;
        int v55 = sub_100034488(&v69, (float *)&__F, *(void *)(a1 + 224), *(float *)&v80, *(float *)&v78, *(float *)&v76, v44, v81, v33);
        *(_DWORD *)uint64_t v29 = v55;
        v56.i32[0] = __F;
        LODWORD(v78) = __F;
        float v57 = *(float *)(*(void *)(a1 + 224)
                       + 4
                       * ((*(_DWORD *)(*(void *)(a1 + 224) + 8) + **(_DWORD **)(a1 + 224) - 1)
                        % **(_DWORD **)(a1 + 224))
                       + 140);
        *(float *)&uint64_t v76 = v57;
        if (v55 == 1)
        {
          if (v57 > 0.4) {
            int v58 = 1;
          }
          else {
            int v58 = 2;
          }
        }
        else
        {
          int v58 = v55;
          if (v55 != 3) {
            int v58 = 2;
          }
        }
        uint64_t v59 = 0;
        v56.i32[1] = sqrtf(v81);
        *((double *)v29 + 1) = v69 * 0.5;
        *((double *)v29 + 2) = v44;
        *(float64x2_t *)(v29 + 24) = vcvtq_f64_f32(vminnm_f32(v56, (float32x2_t)vdup_n_s32(0x477FFF00u)));
        float v60 = fminf(*((float *)&v76 + 1), 65535.0);
        *((double *)v29 + 5) = fminf(v57, 65535.0);
        *((double *)v29 + 6) = v60;
        *((_DWORD *)v29 + 1) = v58;
        *((double *)v29 + 7) = v36;
        *((double *)v29 + 8) = v38;
        *((double *)v29 + 9) = v44;
        *((void *)v29 + 13) = 0x200000000;
        uint64_t v61 = *(void *)(a1 + 296);
        char v62 = 1;
        do
        {
          char v63 = v62;
          long long v64 = &v29[8 * v59];
          long long v65 = (void *)(v61 + 8 * v59);
          v65[1] = *((void *)v64 + 1);
          v65[3] = *((void *)v64 + 3);
          v65[5] = *((void *)v64 + 5);
          uint64_t v59 = 1;
          char v62 = 0;
        }
        while ((v63 & 1) != 0);
        *(void *)(v61 + 56) = *((void *)v29 + 7);
        *(void *)(v61 + 64) = *((void *)v29 + 8);
        *(_DWORD *)uint64_t v61 = v55;
        *(_DWORD *)(v61 + 4) = v58;
        *(void *)(v61 + 72) = *((void *)v29 + 9);
        *(_DWORD *)(v61 + 104) = 0;
        pthread_mutex_lock((pthread_mutex_t *)(a1 + 424));
        pthread_cond_broadcast((pthread_cond_t *)(a1 + 488));
        pthread_mutex_unlock((pthread_mutex_t *)(a1 + 424));
        uint64_t v66 = *(void (**)(uint64_t, void, char *))(a1 + 312);
        if (v66) {
          v66(a1, *(void *)(a1 + 320), v29);
        }
        else {
          free(v29);
        }
        goto LABEL_69;
      }
    }
    uint64_t v51 = 0;
    do
      *((float *)&__F + v51++) = 1.0 / (float)v48;
    while (v48 > v51);
    goto LABEL_58;
  }
  os_log_t v17 = (os_log_t)off_1002BBC70;
  if (off_1002BBC70 == &_os_log_default)
  {
    os_log_t v17 = os_log_create("com.apple.isp", "general");
    off_1002BBC70 = v17;
  }
  if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR)) {
    sub_100075190(v17, v18, v19, v20, v21, v22, v23, v24);
  }
  return 0xFFFFFFFFLL;
}

uint64_t sub_10001832C(uint64_t a1, AudioUnitRenderActionFlags *ioActionFlags, AudioTimeStamp *inTimeStamp, int a4, UInt32 inNumberFrames)
{
  if (a1)
  {
    uint64_t v9 = *(void **)(a1 + 288);
    if (v9) {
      sub_100028F08(v9);
    }
    uint64_t v10 = *(void *)(a1 + 80);
    if (v10)
    {
      uint64_t v11 = *(_DWORD *)(a1 + 48) * inNumberFrames;
      uint64_t v13 = (void *)(a1 + 104);
      uint64_t v12 = *(void *)(a1 + 104);
      ioData.mBuffers[0].mData = (void *)(v10 + v12);
      ioData.mNumberBuffers = 1;
      ioData.mBuffers[0].mDataByteSize = v11;
      if (v12 + v11 <= (unint64_t)*(unsigned int *)(a1 + 76))
      {
        uint64_t v16 = AudioUnitRender(*(AudioUnit *)(a1 + 16), ioActionFlags, inTimeStamp, 1u, inNumberFrames, &ioData);
        if (v16)
        {
          os_log_t v25 = (os_log_t)off_1002BBC70;
          if (off_1002BBC70 == &_os_log_default)
          {
            os_log_t v25 = os_log_create("com.apple.isp", "general");
            off_1002BBC70 = v25;
          }
          if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR)) {
            sub_100075458();
          }
        }
        uint64_t v26 = *(FILE **)(a1 + 248);
        if (v26)
        {
          fwrite(ioData.mBuffers[0].mData, 1uLL, ioData.mBuffers[0].mDataByteSize, v26);
          fflush(*(FILE **)(a1 + 248));
        }
        size_t v15 = *v13 + ioData.mBuffers[0].mDataByteSize;
      }
      else
      {
        os_log_t v14 = (os_log_t)off_1002BBC70;
        if (off_1002BBC70 == &_os_log_default)
        {
          os_log_t v14 = os_log_create("com.apple.isp", "general");
          off_1002BBC70 = v14;
        }
        if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR)) {
          sub_1000753E4();
        }
        size_t v15 = 0;
        uint64_t v16 = 0;
      }
      *(void *)(a1 + 104) = v15;
      if (v15 == *(_DWORD *)(a1 + 76))
      {
        memcpy(*(void **)(a1 + 96), (const void *)(*(void *)(a1 + 96) + v15), v15);
        memcpy((void *)(*(void *)(a1 + 96) + *(unsigned int *)(a1 + 76)), *(const void **)(a1 + 80), *(unsigned int *)(a1 + 76));
        uint64_t v27 = *(FILE **)(a1 + 256);
        if (v27)
        {
          fwrite(*(const void **)(a1 + 96), 1uLL, *(unsigned int *)(a1 + 92), v27);
          fflush(*(FILE **)(a1 + 256));
        }
        uint64_t v28 = (char *)malloc_type_calloc(1uLL, 0x110uLL, 0x1000040368141FCuLL);
        if (v28)
        {
          uint64_t v29 = v28;
          int v99 = 2143289344;
          uint64_t v98 = 0x7FC000007FC00000;
          int v97 = 0;
          uint64_t v96 = 0;
          uint64_t v30 = *(_DWORD **)a1;
          double v31 = *(double **)(*(void *)a1 + 8);
          double v33 = *v31;
          double v32 = v31[1];
          vDSP_Length v34 = (unint64_t)*(unsigned int *)(a1 + 116) >> 2;
          vDSP_Length v35 = (unint64_t)*(unsigned int *)(a1 + 132) >> 2;
          *(void *)&long long __F = 1065353216;
          uint64_t v100 = 0x3F80000000000000;
          if (*v30 == 5) {
            p_F = (const float *)&v100;
          }
          else {
            p_F = (const float *)&__F;
          }
          if (*v30 == 5) {
            float v37 = (const float *)&__F;
          }
          else {
            float v37 = (const float *)&v100;
          }
          vDSP_desamp(*(const float **)(a1 + 96), 2, p_F, *(float **)(a1 + 136), v35, 2uLL);
          vDSP_desamp(*(const float **)(a1 + 96), 2, v37, *(float **)(a1 + 120), v34, 2uLL);
          float v38 = sub_1000347A0(*(const float **)(a1 + 120), v34);
          float v39 = sub_1000347A0(*(const float **)(a1 + 136), v35);
          if (*(unsigned char *)(a1 + 8))
          {
            float v38 = sub_1000347A0((const float *)(*(void *)(a1 + 120) + 38400), v34 - 9600);
            float v40 = sub_1000347A0((const float *)(*(void *)(a1 + 136) + 38400), v35 - 9600);
            *(unsigned char *)(a1 + 8) = 0;
          }
          else
          {
            float v40 = v39;
          }
          float v41 = -1.0;
          switch(**(_DWORD **)a1)
          {
            case 3:
              *(void *)(*(void *)(a1 + 416) + 708) = 0x3EE666663E99999ALL;
              float v42 = v40 + 0.389;
              float v41 = 0.0;
              if ((float)(v40 + 0.389) > 0.024)
              {
                float v43 = v38 + 0.3895;
                if ((float)(v38 + 0.3895) > 0.024)
                {
                  BOOL v44 = v43 <= v42;
                  float v45 = v42 / v43;
                  if (!v44) {
                    float v41 = v45;
                  }
                }
              }
              break;
            case 4:
              *(void *)(*(void *)(a1 + 416) + 708) = 0x4110000040C00000;
              float v46 = v40 + 19.021;
              float v41 = 0.0;
              if ((float)(v40 + 19.021) > 1.4576)
              {
                float v47 = v38 + 18.175;
                float v48 = 1.6311;
                goto LABEL_53;
              }
              break;
            case 5:
              *(void *)(*(void *)(a1 + 416) + 708) = 0x4110000040C00000;
              float v46 = v40 + 24.91;
              float v41 = 0.0;
              if ((float)(v40 + 24.91) > 1.011)
              {
                float v47 = v38 + 25.06;
                if ((float)(v38 + 25.06) > 1.011) {
                  goto LABEL_54;
                }
              }
              break;
            case 7:
              *(void *)(*(void *)(a1 + 416) + 708) = 0x3EE666663E99999ALL;
              float v46 = v40 + 0.6268;
              float v41 = 0.0;
              float v48 = 0.01758;
              if ((float)(v40 + 0.6268) > 0.01758)
              {
                float v47 = v38 + 0.6268;
                goto LABEL_53;
              }
              break;
            case 8:
              *(void *)(*(void *)(a1 + 416) + 708) = 0x4110000040C00000;
              float v46 = v40 + 24.876;
              float v41 = 0.0;
              if ((float)(v40 + 24.876) > 0.714)
              {
                float v47 = v38 + 25.042;
                float v48 = 2.0352;
LABEL_53:
                if (v47 > v48)
                {
LABEL_54:
                  if (v47 > v46) {
                    float v41 = v46 / v47;
                  }
                }
              }
              break;
            default:
              break;
          }
          std::string v49 = *(FILE **)(a1 + 272);
          if (v49)
          {
            fwrite(*(const void **)(a1 + 136), 1uLL, *(unsigned int *)(a1 + 132), v49);
            fflush(*(FILE **)(a1 + 272));
          }
          os_log_t v50 = *(FILE **)(a1 + 264);
          if (v50)
          {
            fwrite(*(const void **)(a1 + 120), 1uLL, *(unsigned int *)(a1 + 116), v50);
            fflush(*(FILE **)(a1 + 264));
          }
          if ((**(_DWORD **)a1 | 2) == 7)
          {
            uint64_t v51 = *(double **)(*(void *)a1 + 8);
            double v52 = *v51;
            double v53 = v51[2];
            unint64_t v54 = *(unsigned int *)(a1 + 148);
            uint64_t v55 = (uint64_t)(v52 / v53);
            long long v94 = 0u;
            long long v95 = 0u;
            vDSP_Length v56 = v54 >> 2;
            long long __F = 0u;
            long long v93 = 0u;
            if (v55 >= 1)
            {
              uint64_t v57 = 0;
              do
                *((float *)&__F + v57++) = 1.0 / (float)v55;
              while (v55 > v57);
            }
            vDSP_desamp(*(const float **)(a1 + 120), v55, (const float *)&__F, *(float **)(a1 + 152), v56, v55);
            vDSP_desamp(*(const float **)(a1 + 136), v55, (const float *)&__F, *(float **)(a1 + 168), v56, v55);
          }
          else
          {
            memcpy(*(void **)(a1 + 152), *(const void **)(a1 + 120), *(unsigned int *)(a1 + 148));
            memcpy(*(void **)(a1 + 168), *(const void **)(a1 + 136), *(unsigned int *)(a1 + 148));
          }
          int v58 = sub_100035A90(*(void *)(a1 + 416), (FFTSetup *)(a1 + 240), *(const float **)(a1 + 152), *(const float **)(a1 + 168), (uint64_t)&v100, *(float *)(a1 + 408));
          uint64_t v98 = 1119092736;
          int v99 = 0;
          float v59 = 0.0;
          if (!v58)
          {
            LODWORD(v98) = HIDWORD(v100);
            int v99 = v103;
            float v59 = v101 * 65535.0;
          }
          float v89 = v59;
          unint64_t v60 = *(unsigned int *)(a1 + 148);
          uint64_t v61 = (float *)(*(void *)(a1 + 152) + (v60 >> 1));
          char v62 = (float *)(*(void *)(a1 + 168) + (v60 >> 1));
          unsigned int v63 = v60 >> 3;
          uint64_t v64 = *(void *)(a1 + 416);
          float v65 = *(float *)(v64 + 24);
          float v66 = *(float *)(v64 + 28);
          uint64_t v67 = *(void *)(v64 + 816);
          if (*(unsigned char *)(v64 + 828))
          {
            sub_100037F18(v61, v62, v63, 1, v67, (uint64_t)&__F, 0, 1.0, 1.0, v65, v66);
          }
          else
          {
            sub_100037F18(v61, v62, v63, 0, v67, (uint64_t)&__F, 0, 1.0, 1.0, v65, v66);
            *(unsigned char *)(*(void *)(a1 + 416) + 828) = 1;
          }
          long long v68 = v93;
          *(_OWORD *)(v29 + 116) = __F;
          *(_OWORD *)(v29 + 132) = v68;
          *(_OWORD *)(v29 + 148) = v94;
          *(void *)(v29 + 164) = v95;
          vDSP_Length v69 = (unint64_t)*(unsigned int *)(a1 + 180) >> 2;
          long long v91 = xmmword_1000824B0;
          vDSP_desamp(*(const float **)(a1 + 120), (uint64_t)(v33 / v32), (const float *)&v91, *(float **)(a1 + 184), v69, (uint64_t)(v33 / v32));
          float v70 = v32;
          sub_1000347D4(*(float32x4_t **)(a1 + 184), v69, (uint64_t)&v98, (uint64_t)&v96, 3u, v70);
          int v71 = v104;
          *(_DWORD *)uint64_t v29 = v104;
          float v72 = *(float *)(*(void *)(a1 + 224)
                         + 4
                         * ((*(_DWORD *)(*(void *)(a1 + 224) + 8) + **(_DWORD **)(a1 + 224) - 1)
                          % **(_DWORD **)(a1 + 224))
                         + 140);
          *(float *)&uint64_t v96 = v72;
          int v73 = v71;
          if (v71 != 3)
          {
            if (v71 == 1)
            {
              if (v72 > 0.4) {
                int v73 = 1;
              }
              else {
                int v73 = 2;
              }
            }
            else
            {
              int v73 = 2;
            }
          }
          uint64_t v74 = 0;
          *((double *)v29 + 1) = *((float *)&v100 + 1) * 0.5;
          *((double *)v29 + 2) = v41;
          int v75 = v102;
          int v76 = v105;
          *((_DWORD *)v29 + 20) = v102;
          *((_DWORD *)v29 + 23) = v76;
          *(void *)(v29 + 84) = 0x3F80000000000000;
          *(float64x2_t *)(v29 + 24) = vcvtq_f64_f32(vminnm_f32((float32x2_t)__PAIR64__(v99, LODWORD(v89)), (float32x2_t)vdup_n_s32(0x477FFF00u)));
          float v77 = fminf(*((float *)&v96 + 1), 65535.0);
          *((double *)v29 + 5) = fminf(v72, 65535.0);
          *((double *)v29 + 6) = v77;
          *((_DWORD *)v29 + 1) = v73;
          *((void *)v29 + 13) = 0x200000000;
          *((double *)v29 + 7) = v38;
          *((double *)v29 + 8) = v40;
          *((double *)v29 + 9) = v41;
          uint64_t v78 = *(void *)(a1 + 296);
          char v79 = 1;
          do
          {
            char v80 = v79;
            float v81 = &v29[8 * v74];
            int v82 = (void *)(v78 + 8 * v74);
            v82[1] = *((void *)v81 + 1);
            v82[3] = *((void *)v81 + 3);
            v82[5] = *((void *)v81 + 5);
            uint64_t v74 = 1;
            char v79 = 0;
          }
          while ((v80 & 1) != 0);
          *(void *)(v78 + 56) = *((void *)v29 + 7);
          *(void *)(v78 + 64) = *((void *)v29 + 8);
          *(_DWORD *)uint64_t v78 = v71;
          *(_DWORD *)(v78 + 4) = v73;
          *(void *)(v78 + 72) = *((void *)v29 + 9);
          *(_DWORD *)(v78 + 80) = v75;
          *(_DWORD *)(v78 + 92) = v76;
          *(void *)(v78 + 84) = 0x3F80000000000000;
          *(_DWORD *)(v78 + 104) = 0;
          long long v83 = *(_OWORD *)(v29 + 116);
          long long v84 = *(_OWORD *)(v29 + 132);
          long long v85 = *(_OWORD *)(v29 + 148);
          *(void *)(v78 + 164) = *(void *)(v29 + 164);
          *(_OWORD *)(v78 + 148) = v85;
          *(_OWORD *)(v78 + 132) = v84;
          *(_OWORD *)(v78 + 116) = v83;
          pthread_mutex_lock((pthread_mutex_t *)(a1 + 424));
          pthread_cond_broadcast((pthread_cond_t *)(a1 + 488));
          pthread_mutex_unlock((pthread_mutex_t *)(a1 + 424));
          uint64_t v86 = *(void (**)(uint64_t, void, char *))(a1 + 312);
          if (v86) {
            v86(a1, *(void *)(a1 + 320), v29);
          }
          else {
            free(v29);
          }
        }
        *uint64_t v13 = 0;
      }
    }
    else
    {
      uint64_t v16 = 0;
    }
    uint64_t v87 = *(uint64_t **)(a1 + 288);
    if (v87) {
      sub_100028F40(v87);
    }
  }
  else
  {
    os_log_t v17 = (os_log_t)off_1002BBC70;
    if (off_1002BBC70 == &_os_log_default)
    {
      os_log_t v17 = os_log_create("com.apple.isp", "general");
      off_1002BBC70 = v17;
    }
    if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR)) {
      sub_10007536C(v17, v18, v19, v20, v21, v22, v23, v24);
    }
    return 0xFFFFFFFFLL;
  }
  return v16;
}

uint64_t sub_100018CCC(uint64_t a1, AudioUnitRenderActionFlags *ioActionFlags, AudioTimeStamp *inTimeStamp, int a4, UInt32 inNumberFrames)
{
  if (a1)
  {
    uint64_t v9 = *(void **)(a1 + 288);
    if (v9) {
      sub_100028F08(v9);
    }
    uint64_t v10 = *(void *)(a1 + 80);
    if (v10)
    {
      uint64_t v11 = *(_DWORD *)(a1 + 48) * inNumberFrames;
      uint64_t v13 = (void *)(a1 + 104);
      uint64_t v12 = *(void *)(a1 + 104);
      ioData.mBuffers[0].mData = (void *)(v10 + v12);
      ioData.mNumberBuffers = 1;
      ioData.mBuffers[0].mDataByteSize = v11;
      if (v12 + v11 <= (unint64_t)*(unsigned int *)(a1 + 76))
      {
        uint64_t v16 = AudioUnitRender(*(AudioUnit *)(a1 + 16), ioActionFlags, inTimeStamp, 1u, inNumberFrames, &ioData);
        if (v16)
        {
          os_log_t v25 = (os_log_t)off_1002BBC70;
          if (off_1002BBC70 == &_os_log_default)
          {
            os_log_t v25 = os_log_create("com.apple.isp", "general");
            off_1002BBC70 = v25;
          }
          if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR)) {
            sub_1000755BC();
          }
        }
        uint64_t v26 = *(FILE **)(a1 + 248);
        if (v26)
        {
          fwrite(ioData.mBuffers[0].mData, 1uLL, ioData.mBuffers[0].mDataByteSize, v26);
          fflush(*(FILE **)(a1 + 248));
        }
        uint64_t v15 = *v13 + ioData.mBuffers[0].mDataByteSize;
      }
      else
      {
        os_log_t v14 = (os_log_t)off_1002BBC70;
        if (off_1002BBC70 == &_os_log_default)
        {
          os_log_t v14 = os_log_create("com.apple.isp", "general");
          off_1002BBC70 = v14;
        }
        if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR)) {
          sub_100075548();
        }
        uint64_t v15 = 0;
        uint64_t v16 = 0;
      }
      *(void *)(a1 + 104) = v15;
      if (v15 == *(_DWORD *)(a1 + 76))
      {
        unsigned __int8 __ptr = 0;
        *(unsigned char *)(a1 + 536) = 0;
        uint64_t v27 = *(void *)(a1 + 544);
        if (v27) {
          sub_100015440(v27, &__ptr, (unsigned char *)(a1 + 536));
        }
        uint64_t v28 = *(FILE **)(a1 + 280);
        if (v28)
        {
          fwrite(&__ptr, 1uLL, 1uLL, v28);
          fflush(*(FILE **)(a1 + 280));
        }
        if (*(unsigned char *)(a1 + 536) && !*(unsigned char *)(a1 + 8))
        {
          *(void *)(a1 + 104) = 0;
          *(unsigned char *)(*(void *)(a1 + 416) + 828) = 0;
          pthread_mutex_lock((pthread_mutex_t *)(a1 + 424));
          uint64_t v47 = mach_absolute_time();
          uint64_t v48 = *(void *)(a1 + 296);
          *(void *)(v48 + 96) = v47;
          LOBYTE(v49) = __ptr;
          *(float *)(v48 + 88) = (float)v49;
          *(_DWORD *)(v48 + 84) = 0;
          *(unsigned char *)(v48 + 112) = 1;
          pthread_cond_broadcast((pthread_cond_t *)(a1 + 488));
          pthread_mutex_unlock((pthread_mutex_t *)(a1 + 424));
          return 0;
        }
        memcpy(*(void **)(a1 + 96), (const void *)(*(void *)(a1 + 96) + *(unsigned int *)(a1 + 76)), *(unsigned int *)(a1 + 76));
        memcpy((void *)(*(void *)(a1 + 96) + *(unsigned int *)(a1 + 76)), *(const void **)(a1 + 80), *(unsigned int *)(a1 + 76));
        uint64_t v29 = *(FILE **)(a1 + 256);
        if (v29)
        {
          fwrite(*(const void **)(a1 + 96), 1uLL, *(unsigned int *)(a1 + 92), v29);
          fflush(*(FILE **)(a1 + 256));
        }
        uint64_t v30 = (float *)malloc_type_calloc(1uLL, 0x110uLL, 0x1000040368141FCuLL);
        if (v30)
        {
          double v32 = v30;
          LOBYTE(v31) = __ptr;
          v30[22] = (float)v31;
          int v109 = 2143289344;
          uint64_t v108 = 0x7FC000007FC00000;
          int v107 = 0;
          uint64_t v106 = 0;
          double v33 = *(double **)(*(void *)a1 + 8);
          double v35 = *v33;
          double v34 = v33[1];
          vDSP_Length v36 = (unint64_t)*(unsigned int *)(a1 + 116) >> 2;
          vDSP_Length v37 = (unint64_t)*(unsigned int *)(a1 + 132) >> 2;
          uint64_t __F = 1065353216;
          info[0] = (mach_timebase_info)0x3F80000000000000;
          vDSP_desamp(*(const float **)(a1 + 96), 2, (const float *)&__F, *(float **)(a1 + 136), v37, 2uLL);
          vDSP_desamp(*(const float **)(a1 + 96), 2, (const float *)info, *(float **)(a1 + 120), v36, 2uLL);
          unint64_t v38 = (unint64_t)*(unsigned int *)(a1 + 76) >> 3;
          float v39 = sub_1000347A0(*(const float **)(a1 + 120), v36);
          float v40 = sub_1000347A0(*(const float **)(a1 + 136), v37);
          vDSP_Length v41 = v36 - v38;
          float v42 = sub_1000347A0((const float *)(*(void *)(a1 + 120) + 4 * v38), v41);
          vDSP_Length v43 = v37 - v38;
          float v44 = sub_1000347A0((const float *)(*(void *)(a1 + 136) + 4 * v38), v43);
          if (*(unsigned char *)(a1 + 8))
          {
            os_log_t v45 = (os_log_t)off_1002BBC70;
            if (off_1002BBC70 == &_os_log_default)
            {
              os_log_t v45 = os_log_create("com.apple.isp", "general");
              off_1002BBC70 = v45;
            }
            if (os_log_type_enabled(v45, OS_LOG_TYPE_DEFAULT))
            {
              int v46 = *(_DWORD *)(a1 + 76);
              *(_DWORD *)buf = 67109376;
              *(_DWORD *)&buf[4] = v38;
              *(_WORD *)&buf[8] = 1024;
              *(_DWORD *)&buf[10] = v46;
              _os_log_impl((void *)&_mh_execute_header, v45, OS_LOG_TYPE_DEFAULT, "skip buffer size in (float)%d, acc size %d\n\n", buf, 0xEu);
            }
            float v39 = sub_1000347A0((const float *)(*(void *)(a1 + 120) + 4 * v38), v41);
            float v40 = sub_1000347A0((const float *)(*(void *)(a1 + 136) + 4 * v38), v43);
            *(unsigned char *)(a1 + 8) = 0;
            *(_DWORD *)(a1 + 540) = 0;
          }
          else
          {
            *(_DWORD *)(a1 + 540) ^= 1u;
          }
          uint64_t v50 = *(void *)(a1 + 416);
          *(void *)(v50 + 708) = 0x3EE666663E99999ALL;
          switch(__ptr)
          {
            case 0u:
              float v51 = *(float *)(v50 + 748) * 0.00000011921;
              float v52 = *(float *)(v50 + 744);
              goto LABEL_51;
            case 1u:
              float v51 = *(float *)(v50 + 756) * 0.00000011921;
              float v52 = *(float *)(v50 + 752);
              goto LABEL_51;
            case 2u:
            case 4u:
            case 5u:
            case 6u:
              goto LABEL_47;
            case 3u:
              float v51 = *(float *)(v50 + 764) * 0.00000011921;
              float v52 = *(float *)(v50 + 760);
              goto LABEL_51;
            case 7u:
              float v51 = *(float *)(v50 + 772) * 0.00000011921;
              float v52 = *(float *)(v50 + 768);
              goto LABEL_51;
            default:
              if (__ptr == 15)
              {
                float v51 = *(float *)(v50 + 780) * 0.00000011921;
                float v52 = *(float *)(v50 + 776);
LABEL_51:
                float v53 = v52 * 0.00000011921;
                *(float *)(v50 + 24) = v51;
                *(float *)(v50 + 28) = v52 * 0.00000011921;
              }
              else
              {
LABEL_47:
                float v51 = *(float *)(v50 + 24);
                float v53 = *(float *)(v50 + 28);
              }
              float v54 = v39 - v51;
              float v55 = v40 - v53;
              BOOL v56 = (float)(v40 - v53) > 0.01;
              if ((float)(v39 - v51) <= 0.01) {
                BOOL v56 = 0;
              }
              BOOL v57 = v54 > v55 && v56;
              int v58 = *(FILE **)(a1 + 272);
              if (v58)
              {
                fwrite(*(const void **)(a1 + 136), 1uLL, *(unsigned int *)(a1 + 132), v58);
                fflush(*(FILE **)(a1 + 272));
              }
              float v59 = *(FILE **)(a1 + 264);
              if (v59)
              {
                fwrite(*(const void **)(a1 + 120), 1uLL, *(unsigned int *)(a1 + 116), v59);
                fflush(*(FILE **)(a1 + 264));
              }
              float v102 = 0.0;
              uint64_t v101 = 0;
              float v100 = 0.0;
              memcpy(*(void **)(a1 + 152), *(const void **)(a1 + 120), *(unsigned int *)(a1 + 148));
              memcpy(*(void **)(a1 + 168), *(const void **)(a1 + 136), *(unsigned int *)(a1 + 148));
              sub_100037D54(*(void *)(a1 + 416) + 716, __ptr, &v102, (float *)&v101 + 1, &v101, &v100);
              float v60 = sub_100037EA8((float *)(*(void *)(a1 + 416) + 716), 1, v42, v44, v102, *((float *)&v101 + 1), *(float *)&v101, v100);
              if (v60 < 0.0) {
                float v60 = 0.0;
              }
              v32[21] = v60;
              int v61 = sub_100035A90(*(void *)(a1 + 416), (FFTSetup *)(a1 + 240), *(const float **)(a1 + 152), *(const float **)(a1 + 168), (uint64_t)&__F, *(float *)(a1 + 408));
              uint64_t v62 = *(void *)(a1 + 416);
              if (*(unsigned char *)(v62 + 1))
              {
                if (*(float *)(a1 + 408) != 8.0) {
                  *(unsigned char *)(v62 + 828) = 0;
                }
                if (*(_DWORD *)(a1 + 540) == 1) {
                  sub_10003858C(*(void *)(a1 + 152), *(void *)(a1 + 168), *(_DWORD *)(a1 + 148) >> 2, 0xFA0u, *(float **)(v62 + 816), *(_DWORD *)(v62 + 824), (uint64_t)buf);
                }
              }
              else
              {
                *(unsigned char *)(v62 + 828) = 0;
              }
              mach_timebase_info(info);
              if (info[0].denom) {
                uint64_t v63 = info[0].numer / info[0].denom;
              }
              else {
                uint64_t v63 = 1;
              }
              *(void *)&v114[1] = v63 * inTimeStamp->mHostTime;
              *(_OWORD *)(v32 + 51) = v112;
              long long v64 = v114[0];
              *(_OWORD *)(v32 + 55) = v113;
              *(_OWORD *)(v32 + 59) = v64;
              long long v65 = v111;
              *(_OWORD *)(v32 + 43) = *(_OWORD *)buf;
              *(_OWORD *)(v32 + 47) = v65;
              *(_OWORD *)((char *)v32 + 250) = *(_OWORD *)((char *)v114 + 14);
              int v66 = HIDWORD(__F);
              BOOL v67 = 1;
              if ((float)(*((float *)&__F + 1) * 0.5) >= 59.0 && (float)(*((float *)&__F + 1) * 0.5) <= 61.0) {
                BOOL v67 = v116 < 0.95;
              }
              BOOL v68 = v117 <= 13.66;
              if (v120 < 0.66) {
                BOOL v68 = 0;
              }
              *((_DWORD *)v32 + 67) = v68 && v67;
              uint64_t v108 = 1119092736;
              int v109 = 0;
              float v69 = 0.0;
              if (!v61)
              {
                LODWORD(v108) = v66;
                int v109 = v118;
                float v69 = v116 * 65535.0;
              }
              float v99 = v69;
              vDSP_Length v70 = (unint64_t)*(unsigned int *)(a1 + 180) >> 2;
              *(_OWORD *)&info[0].numer = xmmword_1000824B0;
              vDSP_desamp(*(const float **)(a1 + 120), (uint64_t)(v35 / v34), (const float *)info, *(float **)(a1 + 184), v70, (uint64_t)(v35 / v34));
              float v71 = v34;
              sub_1000347D4(*(float32x4_t **)(a1 + 184), v70, (uint64_t)&v108, (uint64_t)&v106, 3u, v71);
              int v72 = v119;
              *(_DWORD *)double v32 = v119;
              float v73 = *(float *)(*(void *)(a1 + 224)
                             + 4
                             * ((*(_DWORD *)(*(void *)(a1 + 224) + 8) + **(_DWORD **)(a1 + 224) - 1)
                              % **(_DWORD **)(a1 + 224))
                             + 140);
              *(float *)&uint64_t v106 = v73;
              int v74 = v72;
              if (v72 != 3)
              {
                if (v72 == 1)
                {
                  if (v73 > 0.4) {
                    int v74 = 1;
                  }
                  else {
                    int v74 = 2;
                  }
                }
                else
                {
                  int v74 = 2;
                }
              }
              uint64_t v75 = 0;
              if (v57) {
                double v76 = (float)(v55 / v54);
              }
              else {
                double v76 = 0.0;
              }
              *((double *)v32 + 1) = *((float *)&__F + 1) * 0.5;
              *((double *)v32 + 2) = v76;
              float v77 = v117;
              float v78 = v120;
              v32[20] = v117;
              v32[23] = v78;
              *(float64x2_t *)(v32 + 6) = vcvtq_f64_f32(vminnm_f32((float32x2_t)__PAIR64__(v109, LODWORD(v99)), (float32x2_t)vdup_n_s32(0x477FFF00u)));
              float v79 = fminf(*((float *)&v106 + 1), 65535.0);
              *((double *)v32 + 5) = fminf(v73, 65535.0);
              *((double *)v32 + 6) = v79;
              *((_DWORD *)v32 + 1) = v74;
              *((void *)v32 + 13) = 0x200000001;
              *((double *)v32 + 7) = v39;
              *((double *)v32 + 8) = v40;
              *((double *)v32 + 9) = v76;
              uint64_t v80 = *(void *)(a1 + 296);
              char v81 = 1;
              do
              {
                char v82 = v81;
                long long v83 = (char *)&v32[2 * v75];
                long long v84 = (void *)(v80 + 8 * v75);
                v84[1] = *((void *)v83 + 1);
                v84[3] = *((void *)v83 + 3);
                v84[5] = *((void *)v83 + 5);
                uint64_t v75 = 1;
                char v81 = 0;
              }
              while ((v82 & 1) != 0);
              *(void *)(v80 + 56) = *((void *)v32 + 7);
              *(void *)(v80 + 64) = *((void *)v32 + 8);
              *(_DWORD *)uint64_t v80 = v72;
              *(_DWORD *)(v80 + 4) = v74;
              *(void *)(v80 + 72) = *((void *)v32 + 9);
              *(float *)(v80 + 80) = v77;
              *(float *)(v80 + 92) = v78;
              *(_DWORD *)(v80 + 104) = 1;
              pthread_mutex_lock((pthread_mutex_t *)(a1 + 424));
              *(float *)(*(void *)(a1 + 296) + 84) = v32[21];
              uint64_t v85 = mach_absolute_time();
              uint64_t v86 = *(void *)(a1 + 296);
              *(void *)(v86 + 96) = v85;
              *(float *)(v86 + 88) = v32[22];
              *(unsigned char *)(v86 + 112) = *(unsigned char *)(a1 + 536);
              pthread_cond_broadcast((pthread_cond_t *)(a1 + 488));
              pthread_mutex_unlock((pthread_mutex_t *)(a1 + 424));
              uint64_t v87 = *(void *)(a1 + 296);
              uint64_t v88 = *(void *)(v32 + 41);
              long long v89 = *(_OWORD *)(v32 + 37);
              long long v90 = *(_OWORD *)(v32 + 33);
              *(_OWORD *)(v87 + 116) = *(_OWORD *)(v32 + 29);
              *(_OWORD *)(v87 + 132) = v90;
              *(_OWORD *)(v87 + 148) = v89;
              *(void *)(v87 + 164) = v88;
              uint64_t v91 = *(void *)(a1 + 296);
              long long v93 = *(_OWORD *)(v32 + 55);
              long long v92 = *(_OWORD *)(v32 + 59);
              long long v94 = *(_OWORD *)(v32 + 51);
              *(_OWORD *)(v91 + 250) = *(_OWORD *)((char *)v32 + 250);
              *(_OWORD *)(v91 + 204) = v94;
              *(_OWORD *)(v91 + 220) = v93;
              *(_OWORD *)(v91 + 236) = v92;
              long long v95 = *(_OWORD *)(v32 + 47);
              *(_OWORD *)(v91 + 172) = *(_OWORD *)(v32 + 43);
              *(_OWORD *)(v91 + 188) = v95;
              uint64_t v96 = *(void (**)(void, void, void))(a1 + 312);
              if (v96) {
                v96(a1, *(void *)(a1 + 320), v32);
              }
              else {
                free(v32);
              }
              break;
          }
        }
        *uint64_t v13 = 0;
      }
    }
    else
    {
      uint64_t v16 = 0;
    }
    int v97 = *(uint64_t **)(a1 + 288);
    if (v97) {
      sub_100028F40(v97);
    }
  }
  else
  {
    os_log_t v17 = (os_log_t)off_1002BBC70;
    if (off_1002BBC70 == &_os_log_default)
    {
      os_log_t v17 = os_log_create("com.apple.isp", "general");
      off_1002BBC70 = v17;
    }
    if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR)) {
      sub_1000754D0(v17, v18, v19, v20, v21, v22, v23, v24);
    }
    return 0xFFFFFFFFLL;
  }
  return v16;
}

uint64_t sub_1000197B8(uint64_t a1, AudioUnitRenderActionFlags *ioActionFlags, AudioTimeStamp *inTimeStamp, int a4, UInt32 inNumberFrames)
{
  if (a1)
  {
    uint64_t v9 = *(void **)(a1 + 288);
    if (v9) {
      sub_100028F08(v9);
    }
    uint64_t v10 = *(void *)(a1 + 80);
    if (v10)
    {
      uint64_t v11 = *(_DWORD *)(a1 + 48) * inNumberFrames;
      uint64_t v13 = (void *)(a1 + 104);
      uint64_t v12 = *(void *)(a1 + 104);
      ioData.mBuffers[0].mData = (void *)(v10 + v12);
      ioData.mNumberBuffers = 1;
      ioData.mBuffers[0].mDataByteSize = v11;
      if (v12 + v11 <= (unint64_t)*(unsigned int *)(a1 + 76))
      {
        uint64_t v16 = AudioUnitRender(*(AudioUnit *)(a1 + 16), ioActionFlags, inTimeStamp, 1u, inNumberFrames, &ioData);
        if (v16)
        {
          os_log_t v25 = (os_log_t)off_1002BBC70;
          if (off_1002BBC70 == &_os_log_default)
          {
            os_log_t v25 = os_log_create("com.apple.isp", "general");
            off_1002BBC70 = v25;
          }
          if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR)) {
            sub_100075720();
          }
        }
        uint64_t v26 = *(FILE **)(a1 + 248);
        if (v26)
        {
          fwrite(ioData.mBuffers[0].mData, 1uLL, ioData.mBuffers[0].mDataByteSize, v26);
          fflush(*(FILE **)(a1 + 248));
        }
        uint64_t v15 = *v13 + ioData.mBuffers[0].mDataByteSize;
      }
      else
      {
        os_log_t v14 = (os_log_t)off_1002BBC70;
        if (off_1002BBC70 == &_os_log_default)
        {
          os_log_t v14 = os_log_create("com.apple.isp", "general");
          off_1002BBC70 = v14;
        }
        if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR)) {
          sub_1000756AC();
        }
        uint64_t v15 = 0;
        uint64_t v16 = 0;
      }
      *(void *)(a1 + 104) = v15;
      size_t v27 = *(unsigned int *)(a1 + 76);
      if (v15 == v27)
      {
        char v93 = 0;
        *(unsigned char *)(a1 + 536) = 0;
        uint64_t v28 = *(void *)(a1 + 544);
        if (v28)
        {
          sub_100015440(v28, &v93, (unsigned char *)(a1 + 536));
          size_t v27 = *(unsigned int *)(a1 + 76);
        }
        memcpy(*(void **)(a1 + 96), (const void *)(*(void *)(a1 + 96) + v27), v27);
        memcpy((void *)(*(void *)(a1 + 96) + *(unsigned int *)(a1 + 76)), *(const void **)(a1 + 80), *(unsigned int *)(a1 + 76));
        uint64_t v29 = *(FILE **)(a1 + 256);
        if (v29)
        {
          fwrite(*(const void **)(a1 + 96), 1uLL, *(unsigned int *)(a1 + 92), v29);
          fflush(*(FILE **)(a1 + 256));
        }
        uint64_t v30 = (char *)malloc_type_calloc(1uLL, 0x110uLL, 0x1000040368141FCuLL);
        if (v30)
        {
          unsigned int v31 = v30;
          int v99 = 2143289344;
          uint64_t v98 = 0x7FC000007FC00000;
          int v97 = 0;
          uint64_t v96 = 0;
          double v32 = *(double **)(*(void *)a1 + 8);
          double v34 = *v32;
          double v33 = v32[1];
          vDSP_Length v35 = (unint64_t)*(unsigned int *)(a1 + 116) >> 2;
          vDSP_Length v36 = (unint64_t)*(unsigned int *)(a1 + 132) >> 2;
          uint64_t __F = 1065353216;
          info[0] = (mach_timebase_info)0x3F80000000000000;
          vDSP_desamp(*(const float **)(a1 + 96), 2, (const float *)&__F, *(float **)(a1 + 136), v36, 2uLL);
          vDSP_desamp(*(const float **)(a1 + 96), 2, (const float *)info, *(float **)(a1 + 120), v35, 2uLL);
          unint64_t v37 = *(unsigned int *)(a1 + 76);
          float v38 = sub_1000347A0(*(const float **)(a1 + 120), v35);
          float v39 = sub_1000347A0(*(const float **)(a1 + 136), v36);
          if (*(unsigned char *)(a1 + 8))
          {
            os_log_t v40 = (os_log_t)off_1002BBC70;
            if (off_1002BBC70 == &_os_log_default)
            {
              os_log_t v40 = os_log_create("com.apple.isp", "general");
              off_1002BBC70 = v40;
            }
            unint64_t v41 = v37 >> 3;
            if (os_log_type_enabled(v40, OS_LOG_TYPE_DEFAULT))
            {
              int v42 = *(_DWORD *)(a1 + 76);
              *(_DWORD *)buf = 67109376;
              *(_DWORD *)&buf[4] = v41;
              *(_WORD *)&buf[8] = 1024;
              *(_DWORD *)&buf[10] = v42;
              _os_log_impl((void *)&_mh_execute_header, v40, OS_LOG_TYPE_DEFAULT, "skip buffer size in (float)%d, acc size %d\n\n", buf, 0xEu);
            }
            float v38 = sub_1000347A0((const float *)(*(void *)(a1 + 120) + 4 * v41), v35 - v41);
            float v43 = sub_1000347A0((const float *)(*(void *)(a1 + 136) + 4 * v41), v36 - v41);
            *(unsigned char *)(a1 + 8) = 0;
            *(_DWORD *)(a1 + 540) = 0;
          }
          else
          {
            float v43 = v39;
            *(_DWORD *)(a1 + 540) ^= 1u;
          }
          uint64_t v44 = *(void *)(a1 + 416);
          *(void *)(v44 + 708) = 0x3EE666663E99999ALL;
          switch(v93)
          {
            case 0:
              float v45 = *(float *)(v44 + 748) * 0.00000011921;
              float v46 = *(float *)(v44 + 744);
              goto LABEL_46;
            case 1:
              float v45 = *(float *)(v44 + 756) * 0.00000011921;
              float v46 = *(float *)(v44 + 752);
              goto LABEL_46;
            case 2:
            case 4:
            case 5:
            case 6:
              goto LABEL_42;
            case 3:
              float v45 = *(float *)(v44 + 764) * 0.00000011921;
              float v46 = *(float *)(v44 + 760);
              goto LABEL_46;
            case 7:
              float v45 = *(float *)(v44 + 772) * 0.00000011921;
              float v46 = *(float *)(v44 + 768);
              goto LABEL_46;
            default:
              if (v93 == 15)
              {
                float v45 = *(float *)(v44 + 780) * 0.00000011921;
                float v46 = *(float *)(v44 + 776);
LABEL_46:
                *(float *)(v44 + 24) = v45;
                *(float *)(v44 + 28) = v46 * 0.00000011921;
              }
              else
              {
LABEL_42:
                float v45 = *(float *)(v44 + 24);
              }
              if (v45 < -0.6446 || v45 > -0.6138)
              {
                *(_DWORD *)(v44 + 24) = -1088351424;
                float v45 = -0.6292;
              }
              float v47 = *(float *)(v44 + 28);
              if (v47 < -0.6437 || v47 > -0.6051)
              {
                *(_DWORD *)(v44 + 28) = -1088431954;
                float v47 = -0.6244;
              }
              float v48 = v38 - v45;
              float v49 = v43 - v47;
              BOOL v50 = (float)(v43 - v47) > 0.0193;
              if ((float)(v38 - v45) <= 0.0154) {
                BOOL v50 = 0;
              }
              BOOL v51 = v48 > v49 && v50;
              float v52 = *(FILE **)(a1 + 272);
              if (v52)
              {
                fwrite(*(const void **)(a1 + 136), 1uLL, *(unsigned int *)(a1 + 132), v52);
                fflush(*(FILE **)(a1 + 272));
              }
              float v53 = *(FILE **)(a1 + 264);
              if (v53)
              {
                fwrite(*(const void **)(a1 + 120), 1uLL, *(unsigned int *)(a1 + 116), v53);
                fflush(*(FILE **)(a1 + 264));
              }
              memcpy(*(void **)(a1 + 152), *(const void **)(a1 + 120), *(unsigned int *)(a1 + 148));
              memcpy(*(void **)(a1 + 168), *(const void **)(a1 + 136), *(unsigned int *)(a1 + 148));
              int v54 = sub_100035A90(*(void *)(a1 + 416), (FFTSetup *)(a1 + 240), *(const float **)(a1 + 152), *(const float **)(a1 + 168), (uint64_t)&__F, *(float *)(a1 + 408));
              uint64_t v55 = *(void *)(a1 + 416);
              if (*(unsigned char *)(v55 + 1))
              {
                if (*(float *)(a1 + 408) != 8.0) {
                  *(unsigned char *)(v55 + 828) = 0;
                }
                if (*(_DWORD *)(a1 + 540) == 1) {
                  sub_10003858C(*(void *)(a1 + 152), *(void *)(a1 + 168), *(_DWORD *)(a1 + 148) >> 2, 0xFA0u, *(float **)(v55 + 816), *(_DWORD *)(v55 + 824), (uint64_t)buf);
                }
              }
              else
              {
                *(unsigned char *)(v55 + 828) = 0;
              }
              mach_timebase_info(info);
              if (info[0].denom) {
                uint64_t v56 = info[0].numer / info[0].denom;
              }
              else {
                uint64_t v56 = 1;
              }
              *(void *)&v104[1] = v56 * inTimeStamp->mHostTime;
              long long v57 = v103;
              *(_OWORD *)(v31 + 204) = v102;
              *(_OWORD *)(v31 + 220) = v57;
              *(_OWORD *)(v31 + 236) = v104[0];
              long long v58 = v101;
              *(_OWORD *)(v31 + 172) = *(_OWORD *)buf;
              *(_OWORD *)(v31 + 188) = v58;
              *(_OWORD *)(v31 + 250) = *(_OWORD *)((char *)v104 + 14);
              int v59 = HIDWORD(__F);
              BOOL v60 = 1;
              if ((float)(*((float *)&__F + 1) * 0.5) >= 59.0 && (float)(*((float *)&__F + 1) * 0.5) <= 61.0) {
                BOOL v60 = v106 < 0.95;
              }
              BOOL v61 = v107 <= 13.66;
              if (v110 < 0.66) {
                BOOL v61 = 0;
              }
              *((_DWORD *)v31 + 67) = v61 && v60;
              uint64_t v98 = 1119092736;
              int v99 = 0;
              float v62 = 0.0;
              if (!v54)
              {
                LODWORD(v98) = v59;
                int v99 = v108;
                float v62 = v106 * 65535.0;
              }
              float v92 = v62;
              double v63 = (float)(v49 / v48);
              vDSP_Length v64 = (unint64_t)*(unsigned int *)(a1 + 180) >> 2;
              *(_OWORD *)&info[0].numer = xmmword_1000824B0;
              vDSP_desamp(*(const float **)(a1 + 120), (uint64_t)(v34 / v33), (const float *)info, *(float **)(a1 + 184), v64, (uint64_t)(v34 / v33));
              float v65 = v33;
              sub_1000347D4(*(float32x4_t **)(a1 + 184), v64, (uint64_t)&v98, (uint64_t)&v96, 3u, v65);
              int v66 = v109;
              *(_DWORD *)unsigned int v31 = v109;
              float v67 = *(float *)(*(void *)(a1 + 224)
                             + 4
                             * ((*(_DWORD *)(*(void *)(a1 + 224) + 8) + **(_DWORD **)(a1 + 224) - 1)
                              % **(_DWORD **)(a1 + 224))
                             + 140);
              *(float *)&uint64_t v96 = v67;
              int v68 = v66;
              if (v66 != 3)
              {
                if (v66 == 1)
                {
                  if (v67 > 0.4) {
                    int v68 = 1;
                  }
                  else {
                    int v68 = 2;
                  }
                }
                else
                {
                  int v68 = 2;
                }
              }
              uint64_t v69 = 0;
              if (v51) {
                double v70 = v63;
              }
              else {
                double v70 = 0.0;
              }
              *((double *)v31 + 1) = *((float *)&__F + 1) * 0.5;
              *((double *)v31 + 2) = v70;
              float v71 = v107;
              *((float *)v31 + 20) = v107;
              float v72 = v110;
              *((float *)v31 + 23) = v110;
              *(float64x2_t *)(v31 + 24) = vcvtq_f64_f32(vminnm_f32((float32x2_t)__PAIR64__(v99, LODWORD(v92)), (float32x2_t)vdup_n_s32(0x477FFF00u)));
              float v73 = fminf(*((float *)&v96 + 1), 65535.0);
              *((double *)v31 + 5) = fminf(v67, 65535.0);
              *((double *)v31 + 6) = v73;
              *((_DWORD *)v31 + 1) = v68;
              *((_DWORD *)v31 + 27) = 2;
              *((double *)v31 + 7) = v38;
              *((double *)v31 + 8) = v43;
              *((double *)v31 + 9) = v70;
              uint64_t v74 = *(void *)(a1 + 296);
              char v75 = 1;
              do
              {
                char v76 = v75;
                float v77 = &v31[8 * v69];
                float v78 = (void *)(v74 + 8 * v69);
                v78[1] = *((void *)v77 + 1);
                v78[3] = *((void *)v77 + 3);
                v78[5] = *((void *)v77 + 5);
                uint64_t v69 = 1;
                char v75 = 0;
              }
              while ((v76 & 1) != 0);
              *(void *)(v74 + 56) = *((void *)v31 + 7);
              *(void *)(v74 + 64) = *((void *)v31 + 8);
              *(_DWORD *)uint64_t v74 = v66;
              *(_DWORD *)(v74 + 4) = v68;
              *(void *)(v74 + 72) = *((void *)v31 + 9);
              *(float *)(v74 + 80) = v71;
              *(float *)(v74 + 92) = v72;
              uint64_t v79 = mach_absolute_time();
              uint64_t v80 = *(void *)(a1 + 296);
              *(void *)(v80 + 96) = v79;
              long long v81 = *(_OWORD *)(v31 + 116);
              long long v82 = *(_OWORD *)(v31 + 132);
              long long v83 = *(_OWORD *)(v31 + 148);
              *(void *)(v80 + 164) = *(void *)(v31 + 164);
              *(_OWORD *)(v80 + 148) = v83;
              *(_OWORD *)(v80 + 132) = v82;
              *(_OWORD *)(v80 + 116) = v81;
              uint64_t v84 = *(void *)(a1 + 296);
              long long v85 = *(_OWORD *)(v31 + 188);
              *(_OWORD *)(v84 + 172) = *(_OWORD *)(v31 + 172);
              *(_OWORD *)(v84 + 188) = v85;
              long long v86 = *(_OWORD *)(v31 + 204);
              long long v87 = *(_OWORD *)(v31 + 220);
              long long v88 = *(_OWORD *)(v31 + 236);
              *(_OWORD *)(v84 + 250) = *(_OWORD *)(v31 + 250);
              *(_OWORD *)(v84 + 236) = v88;
              *(_OWORD *)(v84 + 220) = v87;
              *(_OWORD *)(v84 + 204) = v86;
              long long v89 = *(void (**)(uint64_t, void, char *))(a1 + 312);
              if (v89) {
                v89(a1, *(void *)(a1 + 320), v31);
              }
              else {
                free(v31);
              }
              break;
          }
        }
        *uint64_t v13 = 0;
      }
    }
    else
    {
      uint64_t v16 = 0;
    }
    long long v90 = *(uint64_t **)(a1 + 288);
    if (v90) {
      sub_100028F40(v90);
    }
  }
  else
  {
    os_log_t v17 = (os_log_t)off_1002BBC70;
    if (off_1002BBC70 == &_os_log_default)
    {
      os_log_t v17 = os_log_create("com.apple.isp", "general");
      off_1002BBC70 = v17;
    }
    if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR)) {
      sub_100075634(v17, v18, v19, v20, v21, v22, v23, v24);
    }
    return 0xFFFFFFFFLL;
  }
  return v16;
}

uint64_t sub_10001A1A8(uint64_t a1, AudioUnitRenderActionFlags *ioActionFlags, AudioTimeStamp *inTimeStamp, int a4, UInt32 inNumberFrames)
{
  if (a1)
  {
    uint64_t v9 = *(void **)(a1 + 288);
    if (v9) {
      sub_100028F08(v9);
    }
    uint64_t v10 = *(void *)(a1 + 80);
    if (v10)
    {
      uint64_t v12 = (void *)(a1 + 104);
      uint64_t v11 = *(void *)(a1 + 104);
      uint64_t v13 = *(_DWORD *)(a1 + 48) * inNumberFrames;
      ioData.mBuffers[0].mData = (void *)(v10 + v11);
      ioData.mNumberBuffers = 1;
      ioData.mBuffers[0].mDataByteSize = v13;
      if (v11 + v13 <= (unint64_t)*(unsigned int *)(a1 + 76))
      {
        uint64_t v16 = AudioUnitRender(*(AudioUnit *)(a1 + 16), ioActionFlags, inTimeStamp, 1u, inNumberFrames, &ioData);
        if (v16)
        {
          os_log_t v25 = (os_log_t)off_1002BBC70;
          if (off_1002BBC70 == &_os_log_default)
          {
            os_log_t v25 = os_log_create("com.apple.isp", "general");
            off_1002BBC70 = v25;
          }
          if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR)) {
            sub_100075884();
          }
        }
        uint64_t v26 = *(FILE **)(a1 + 248);
        if (v26)
        {
          fwrite(ioData.mBuffers[0].mData, 1uLL, ioData.mBuffers[0].mDataByteSize, v26);
          fflush(*(FILE **)(a1 + 248));
        }
        uint64_t v15 = *v12 + ioData.mBuffers[0].mDataByteSize;
      }
      else
      {
        os_log_t v14 = (os_log_t)off_1002BBC70;
        if (off_1002BBC70 == &_os_log_default)
        {
          os_log_t v14 = os_log_create("com.apple.isp", "general");
          off_1002BBC70 = v14;
        }
        if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR)) {
          sub_100075810();
        }
        uint64_t v15 = 0;
        uint64_t v16 = 0;
      }
      *(void *)(a1 + 104) = v15;
      if (v15 == *(_DWORD *)(a1 + 76))
      {
        unsigned __int8 __ptr = 0;
        *(unsigned char *)(a1 + 536) = 0;
        uint64_t v27 = *(void *)(a1 + 544);
        if (v27) {
          sub_100015440(v27, &__ptr, (unsigned char *)(a1 + 536));
        }
        uint64_t v28 = *(FILE **)(a1 + 280);
        if (v28)
        {
          fwrite(&__ptr, 1uLL, 1uLL, v28);
          fflush(*(FILE **)(a1 + 280));
        }
        if (*(unsigned char *)(a1 + 536) && !*(unsigned char *)(a1 + 8))
        {
          *(void *)(a1 + 104) = 0;
          *(unsigned char *)(*(void *)(a1 + 416) + 828) = 0;
          pthread_mutex_lock((pthread_mutex_t *)(a1 + 424));
          uint64_t v48 = mach_absolute_time();
          uint64_t v49 = *(void *)(a1 + 296);
          *(void *)(v49 + 96) = v48;
          LOBYTE(v50) = __ptr;
          *(float *)(v49 + 88) = (float)v50;
          *(_DWORD *)(v49 + 84) = 0;
          *(unsigned char *)(v49 + 112) = 1;
          pthread_cond_broadcast((pthread_cond_t *)(a1 + 488));
          pthread_mutex_unlock((pthread_mutex_t *)(a1 + 424));
          return 0;
        }
        memcpy(*(void **)(a1 + 96), (const void *)(*(void *)(a1 + 96) + *(unsigned int *)(a1 + 76)), *(unsigned int *)(a1 + 76));
        memcpy((void *)(*(void *)(a1 + 96) + *(unsigned int *)(a1 + 76)), *(const void **)(a1 + 80), *(unsigned int *)(a1 + 76));
        uint64_t v29 = *(FILE **)(a1 + 256);
        if (v29)
        {
          fwrite(*(const void **)(a1 + 96), 1uLL, *(unsigned int *)(a1 + 92), v29);
          fflush(*(FILE **)(a1 + 256));
        }
        uint64_t v30 = (float *)malloc_type_calloc(1uLL, 0x110uLL, 0x1000040368141FCuLL);
        if (v30)
        {
          double v32 = v30;
          LOBYTE(v31) = __ptr;
          v30[22] = (float)v31;
          int v116 = 2143289344;
          uint64_t v115 = 0x7FC000007FC00000;
          int v114 = 0;
          uint64_t v113 = 0;
          double v33 = *(double **)(*(void *)a1 + 8);
          double v35 = *v33;
          double v34 = v33[1];
          double v36 = v33[2];
          vDSP_Length v37 = (unint64_t)*(unsigned int *)(a1 + 116) >> 2;
          vDSP_Length v38 = (unint64_t)*(unsigned int *)(a1 + 132) >> 2;
          uint64_t __F = 1065353216;
          info[0] = (mach_timebase_info)0x3F80000000000000;
          vDSP_desamp(*(const float **)(a1 + 96), 2, (const float *)&__F, *(float **)(a1 + 136), v38, 2uLL);
          vDSP_desamp(*(const float **)(a1 + 96), 2, (const float *)info, *(float **)(a1 + 120), v37, 2uLL);
          unint64_t v39 = (unint64_t)*(unsigned int *)(a1 + 76) >> 3;
          float v40 = sub_1000347A0(*(const float **)(a1 + 120), v37);
          float v41 = sub_1000347A0(*(const float **)(a1 + 136), v38);
          vDSP_Length v42 = v37 - v39;
          vDSP_Length v43 = v38 - v39;
          float v44 = sub_1000347A0((const float *)(*(void *)(a1 + 120) + 4 * v39 + 4 * (v42 - 3 * v42 / 5)), 3 * v42 / 5);
          float v45 = sub_1000347A0((const float *)(*(void *)(a1 + 136) + 4 * v39 + 4 * (v43 - 3 * v43 / 5)), 3 * v43 / 5);
          if (*(unsigned char *)(a1 + 8))
          {
            os_log_t v46 = (os_log_t)off_1002BBC70;
            if (off_1002BBC70 == &_os_log_default)
            {
              os_log_t v46 = os_log_create("com.apple.isp", "general");
              off_1002BBC70 = v46;
            }
            if (os_log_type_enabled(v46, OS_LOG_TYPE_DEFAULT))
            {
              int v47 = *(_DWORD *)(a1 + 76);
              *(_DWORD *)buf = 67109376;
              *(_DWORD *)&buf[4] = v39;
              *(_WORD *)&buf[8] = 1024;
              *(_DWORD *)&buf[10] = v47;
              _os_log_impl((void *)&_mh_execute_header, v46, OS_LOG_TYPE_DEFAULT, "skip buffer size in (float)%d, acc size %d\n\n", buf, 0xEu);
            }
            float v40 = sub_1000347A0((const float *)(*(void *)(a1 + 120) + 4 * v39), v42);
            float v41 = sub_1000347A0((const float *)(*(void *)(a1 + 136) + 4 * v39), v43);
            *(unsigned char *)(a1 + 8) = 0;
            *(_DWORD *)(a1 + 540) = 0;
          }
          else
          {
            *(_DWORD *)(a1 + 540) ^= 1u;
          }
          uint64_t v51 = *(void *)(a1 + 416);
          *(void *)(v51 + 708) = 0x3EE666663E99999ALL;
          double v106 = v34;
          switch(__ptr)
          {
            case 0u:
              float32x2_t v52 = *(float32x2_t *)(v51 + 744);
              goto LABEL_54;
            case 1u:
              float32x2_t v52 = *(float32x2_t *)(v51 + 752);
              goto LABEL_54;
            case 2u:
            case 4u:
            case 5u:
            case 6u:
              goto LABEL_47;
            case 3u:
              float32x2_t v52 = *(float32x2_t *)(v51 + 760);
              goto LABEL_54;
            case 7u:
              float32x2_t v52 = *(float32x2_t *)(v51 + 768);
              goto LABEL_54;
            default:
              if (__ptr == 15)
              {
                float32x2_t v52 = *(float32x2_t *)(v51 + 776);
LABEL_54:
                *(int32x2_t *)(v51 + 24) = vrev64_s32((int32x2_t)vmul_f32(v52, (float32x2_t)0x3400000034000000));
              }
              else
              {
LABEL_47:
                os_log_t v53 = (os_log_t)off_1002BBC70;
                if (off_1002BBC70 == &_os_log_default)
                {
                  os_log_t v53 = os_log_create("com.apple.isp", "general");
                  off_1002BBC70 = v53;
                }
                if (os_log_type_enabled(v53, OS_LOG_TYPE_INFO))
                {
                  *(_DWORD *)buf = 136315394;
                  *(void *)&buf[4] = "inputCallbackForGrimaldiHighFreq";
                  *(_WORD *)&buf[12] = 1024;
                  *(_DWORD *)&buf[14] = __ptr;
                  _os_log_impl((void *)&_mh_execute_header, v53, OS_LOG_TYPE_INFO, "%s - Unexpected gain value %d\n", buf, 0x12u);
                }
              }
              uint64_t v54 = *(void *)(a1 + 416);
              float v55 = v40 - *(float *)(v54 + 24);
              float v56 = v41 - *(float *)(v54 + 28);
              BOOL v57 = v56 > 0.01;
              if (v55 <= 0.01) {
                BOOL v57 = 0;
              }
              BOOL v58 = v55 > v56 && v57;
              int v59 = *(FILE **)(a1 + 272);
              if (v59)
              {
                fwrite(*(const void **)(a1 + 136), 1uLL, *(unsigned int *)(a1 + 132), v59);
                fflush(*(FILE **)(a1 + 272));
              }
              BOOL v60 = *(FILE **)(a1 + 264);
              if (v60)
              {
                fwrite(*(const void **)(a1 + 120), 1uLL, *(unsigned int *)(a1 + 116), v60);
                fflush(*(FILE **)(a1 + 264));
              }
              float v109 = 0.0;
              uint64_t v108 = 0;
              float v107 = 0.0;
              if (v35 == v36)
              {
                memcpy(*(void **)(a1 + 152), *(const void **)(a1 + 120), *(unsigned int *)(a1 + 148));
                memcpy(*(void **)(a1 + 168), *(const void **)(a1 + 136), *(unsigned int *)(a1 + 148));
              }
              else
              {
                vDSP_Length v61 = (unint64_t)*(unsigned int *)(a1 + 148) >> 2;
                uint64_t v62 = (uint64_t)(v35 / v36);
                if (v62 >= 16) {
                  uint64_t v63 = 16;
                }
                else {
                  uint64_t v63 = (uint64_t)(v35 / v36);
                }
                if (v62 >= 1)
                {
                  if (v63 <= 1) {
                    uint64_t v64 = 1;
                  }
                  else {
                    uint64_t v64 = v63;
                  }
                  float v65 = (float *)buf;
                  do
                  {
                    *v65++ = 1.0 / (float)v63;
                    --v64;
                  }
                  while (v64);
                }
                vDSP_desamp(*(const float **)(a1 + 120), v63, (const float *)buf, *(float **)(a1 + 152), v61, v63);
                vDSP_desamp(*(const float **)(a1 + 136), v63, (const float *)buf, *(float **)(a1 + 168), v61, v63);
              }
              sub_100037D54(*(void *)(a1 + 416) + 716, __ptr, &v109, (float *)&v108 + 1, &v108, &v107);
              float v66 = sub_100037EA8((float *)(*(void *)(a1 + 416) + 716), 1, v44, v45, v109, *((float *)&v108 + 1), *(float *)&v108, v107);
              if (v66 < 0.0) {
                float v66 = 0.0;
              }
              v32[21] = v66;
              int v67 = sub_100035A90(*(void *)(a1 + 416), (FFTSetup *)(a1 + 240), *(const float **)(a1 + 152), *(const float **)(a1 + 168), (uint64_t)&__F, *(float *)(a1 + 408));
              uint64_t v68 = *(void *)(a1 + 416);
              if (*(unsigned char *)(v68 + 1))
              {
                if (*(float *)(a1 + 408) != 8.0) {
                  *(unsigned char *)(v68 + 828) = 0;
                }
                if (*(_DWORD *)(a1 + 540) == 1) {
                  sub_10003858C(*(void *)(a1 + 152), *(void *)(a1 + 168), *(_DWORD *)(a1 + 148) >> 2, 0xFA0u, *(float **)(v68 + 816), *(_DWORD *)(v68 + 824), (uint64_t)buf);
                }
              }
              else
              {
                *(unsigned char *)(v68 + 828) = 0;
              }
              mach_timebase_info(info);
              if (info[0].denom) {
                uint64_t v69 = info[0].numer / info[0].denom;
              }
              else {
                uint64_t v69 = 1;
              }
              *(void *)&v120[1] = v69 * inTimeStamp->mHostTime;
              *(_OWORD *)(v32 + 51) = v118;
              long long v70 = v120[0];
              *(_OWORD *)(v32 + 55) = v119;
              *(_OWORD *)(v32 + 59) = v70;
              long long v71 = *(_OWORD *)&buf[16];
              *(_OWORD *)(v32 + 43) = *(_OWORD *)buf;
              *(_OWORD *)(v32 + 47) = v71;
              *(_OWORD *)((char *)v32 + 250) = *(_OWORD *)((char *)v120 + 14);
              int v72 = HIDWORD(__F);
              BOOL v73 = 1;
              if ((float)(*((float *)&__F + 1) * 0.5) >= 59.0 && (float)(*((float *)&__F + 1) * 0.5) <= 61.0) {
                BOOL v73 = v122 < 0.95;
              }
              BOOL v74 = v123 <= 13.66;
              if (v126 < 0.66) {
                BOOL v74 = 0;
              }
              *((_DWORD *)v32 + 67) = v74 && v73;
              uint64_t v115 = 1119092736;
              int v116 = 0;
              float v75 = 0.0;
              if (!v67)
              {
                LODWORD(v115) = v72;
                int v116 = v124;
                float v75 = v122 * 65535.0;
              }
              float v105 = v75;
              vDSP_Length v76 = (unint64_t)*(unsigned int *)(a1 + 180) >> 2;
              *(_OWORD *)&info[0].numer = xmmword_1000824B0;
              vDSP_desamp(*(const float **)(a1 + 120), (uint64_t)(v35 / v106), (const float *)info, *(float **)(a1 + 184), v76, (uint64_t)(v35 / v106));
              float v77 = v106;
              sub_1000347D4(*(float32x4_t **)(a1 + 184), v76, (uint64_t)&v115, (uint64_t)&v113, 3u, v77);
              int v78 = v125;
              *(_DWORD *)double v32 = v125;
              float v79 = *(float *)(*(void *)(a1 + 224)
                             + 4
                             * ((*(_DWORD *)(*(void *)(a1 + 224) + 8) + **(_DWORD **)(a1 + 224) - 1)
                              % **(_DWORD **)(a1 + 224))
                             + 140);
              *(float *)&uint64_t v113 = v79;
              int v80 = v78;
              if (v78 != 3)
              {
                if (v78 == 1)
                {
                  if (v79 > 0.4) {
                    int v80 = 1;
                  }
                  else {
                    int v80 = 2;
                  }
                }
                else
                {
                  int v80 = 2;
                }
              }
              uint64_t v81 = 0;
              if (v58) {
                double v82 = (float)(v56 / v55);
              }
              else {
                double v82 = 0.0;
              }
              *((double *)v32 + 1) = *((float *)&__F + 1) * 0.5;
              *((double *)v32 + 2) = v82;
              float v83 = v123;
              float v84 = v126;
              v32[20] = v123;
              v32[23] = v84;
              *(float64x2_t *)(v32 + 6) = vcvtq_f64_f32(vminnm_f32((float32x2_t)__PAIR64__(v116, LODWORD(v105)), (float32x2_t)vdup_n_s32(0x477FFF00u)));
              float v85 = fminf(*((float *)&v113 + 1), 65535.0);
              *((double *)v32 + 5) = fminf(v79, 65535.0);
              *((double *)v32 + 6) = v85;
              *((_DWORD *)v32 + 1) = v80;
              *((void *)v32 + 13) = 0x200000001;
              *((double *)v32 + 7) = v40;
              *((double *)v32 + 8) = v41;
              *((double *)v32 + 9) = v82;
              uint64_t v86 = *(void *)(a1 + 296);
              char v87 = 1;
              do
              {
                char v88 = v87;
                long long v89 = (char *)&v32[2 * v81];
                long long v90 = (void *)(v86 + 8 * v81);
                v90[1] = *((void *)v89 + 1);
                v90[3] = *((void *)v89 + 3);
                v90[5] = *((void *)v89 + 5);
                uint64_t v81 = 1;
                char v87 = 0;
              }
              while ((v88 & 1) != 0);
              *(void *)(v86 + 56) = *((void *)v32 + 7);
              *(void *)(v86 + 64) = *((void *)v32 + 8);
              *(_DWORD *)uint64_t v86 = v78;
              *(_DWORD *)(v86 + 4) = v80;
              *(void *)(v86 + 72) = *((void *)v32 + 9);
              *(float *)(v86 + 80) = v83;
              *(float *)(v86 + 92) = v84;
              *(_DWORD *)(v86 + 104) = 1;
              pthread_mutex_lock((pthread_mutex_t *)(a1 + 424));
              *(float *)(*(void *)(a1 + 296) + 84) = v32[21];
              uint64_t v91 = mach_absolute_time();
              uint64_t v92 = *(void *)(a1 + 296);
              *(void *)(v92 + 96) = v91;
              *(float *)(v92 + 88) = v32[22];
              *(unsigned char *)(v92 + 112) = *(unsigned char *)(a1 + 536);
              pthread_cond_broadcast((pthread_cond_t *)(a1 + 488));
              pthread_mutex_unlock((pthread_mutex_t *)(a1 + 424));
              uint64_t v93 = *(void *)(a1 + 296);
              uint64_t v94 = *(void *)(v32 + 41);
              long long v95 = *(_OWORD *)(v32 + 37);
              long long v96 = *(_OWORD *)(v32 + 33);
              *(_OWORD *)(v93 + 116) = *(_OWORD *)(v32 + 29);
              *(_OWORD *)(v93 + 132) = v96;
              *(_OWORD *)(v93 + 148) = v95;
              *(void *)(v93 + 164) = v94;
              uint64_t v97 = *(void *)(a1 + 296);
              long long v99 = *(_OWORD *)(v32 + 55);
              long long v98 = *(_OWORD *)(v32 + 59);
              long long v100 = *(_OWORD *)(v32 + 51);
              *(_OWORD *)(v97 + 250) = *(_OWORD *)((char *)v32 + 250);
              *(_OWORD *)(v97 + 204) = v100;
              *(_OWORD *)(v97 + 220) = v99;
              *(_OWORD *)(v97 + 236) = v98;
              long long v101 = *(_OWORD *)(v32 + 47);
              *(_OWORD *)(v97 + 172) = *(_OWORD *)(v32 + 43);
              *(_OWORD *)(v97 + 188) = v101;
              long long v102 = *(void (**)(void, void, void))(a1 + 312);
              if (v102) {
                v102(a1, *(void *)(a1 + 320), v32);
              }
              else {
                free(v32);
              }
              break;
          }
        }
        *uint64_t v12 = 0;
      }
    }
    else
    {
      uint64_t v16 = 0;
    }
    long long v103 = *(uint64_t **)(a1 + 288);
    if (v103) {
      sub_100028F40(v103);
    }
  }
  else
  {
    os_log_t v17 = (os_log_t)off_1002BBC70;
    if (off_1002BBC70 == &_os_log_default)
    {
      os_log_t v17 = os_log_create("com.apple.isp", "general");
      off_1002BBC70 = v17;
    }
    if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR)) {
      sub_100075798(v17, v18, v19, v20, v21, v22, v23, v24);
    }
    return 0xFFFFFFFFLL;
  }
  return v16;
}

void sub_10001ADF0(void *a1, uint64_t a2, os_log_t log, const char *a4, ...)
{
  va_start(va, a4);
  _os_log_error_impl(a1, log, OS_LOG_TYPE_ERROR, a4, (uint8_t *)va, 0x12u);
}

void sub_10001AE20(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint8_t *a5)
{
  _os_log_error_impl(a1, a2, OS_LOG_TYPE_ERROR, a4, a5, 0x12u);
}

void sub_10001AE38(void *a1, uint64_t a2, os_log_t log, const char *a4, ...)
{
  va_start(va, a4);
  _os_log_error_impl(a1, log, OS_LOG_TYPE_ERROR, a4, (uint8_t *)va, 0x1Cu);
}

void sub_10001AE58(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_error_impl(a1, a2, OS_LOG_TYPE_ERROR, a4, &a9, 2u);
}

void sub_10001AE80(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_error_impl(a1, a2, OS_LOG_TYPE_ERROR, a4, &a9, 8u);
}

void sub_10001AE9C(uint64_t a1@<X8>)
{
  *(void *)(v1 - 8) = a1;
}

void sub_10001AEA8(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_debug_impl(a1, a2, OS_LOG_TYPE_DEBUG, a4, &a9, 2u);
}

int64_t sub_10001AED8(xpc_connection_t *a1, void *a2)
{
  xpc_object_t v4 = xpc_connection_send_message_with_reply_sync(*a1, a2);
  if (v4)
  {
    uint64_t v5 = v4;
    xpc_type_t type = xpc_get_type(v4);
    if (type == (xpc_type_t)&_xpc_type_dictionary)
    {
      size_t length = 3680;
      os_log_t v19 = (os_log_t)off_1002BBC78;
      if (off_1002BBC78 == &_os_log_default)
      {
        os_log_t v19 = os_log_create("com.apple.isp", "services");
        off_1002BBC78 = v19;
      }
      if (os_log_type_enabled(v19, OS_LOG_TYPE_DEBUG)) {
        sub_100075974(v19);
      }
      int64_t int64 = xpc_dictionary_get_int64(v5, "H16ISPServicesRemoteReturnKey");
      data = xpc_dictionary_get_data(v5, "H16ISPServicesRemoteDataKey", &length);
      xpc_dictionary_set_data(a2, "H16ISPServicesRemoteDataKey", data, length);
      xpc_object_t value = xpc_dictionary_get_value(v5, "H16ISPServicesRemoteJasperCalibObjectKey");
      xpc_dictionary_set_value(a2, "H16ISPServicesRemoteJasperCalibObjectKey", value);
      xpc_object_t v22 = xpc_dictionary_get_value(v5, "H16ISPServicesRemoteRGBIRReportKey");
      xpc_dictionary_set_value(a2, "H16ISPServicesRemoteRGBIRReportKey", v22);
      xpc_object_t v23 = xpc_dictionary_get_value(v5, "H16ISPServicesRemoteRGBIRFinalOutputPCEConfigKey");
      xpc_dictionary_set_value(a2, "H16ISPServicesRemoteRGBIRFinalOutputPCEConfigKey", v23);
      xpc_object_t v24 = xpc_dictionary_get_value(v5, "H16ISPServicesRemoteCFTypeNameKey");
      xpc_dictionary_set_value(a2, "H16ISPServicesRemoteCFTypeNameKey", v24);
      xpc_object_t v25 = xpc_dictionary_get_value(v5, "H16ISPServicesRemoteCFTypeDataKey");
      xpc_dictionary_set_value(a2, "H16ISPServicesRemoteCFTypeDataKey", v25);
    }
    else
    {
      int64_t int64 = 3758097084;
      if (type == (xpc_type_t)&_xpc_type_error)
      {
        int v8 = xpc_copy_description(v5);
        if (v8)
        {
          uint64_t v9 = v8;
          os_log_t v10 = (os_log_t)off_1002BBC78;
          if (off_1002BBC78 == &_os_log_default)
          {
            os_log_t v10 = os_log_create("com.apple.isp", "services");
            off_1002BBC78 = v10;
          }
          if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR)) {
            sub_1000759F8();
          }
          free(v9);
        }
        int64_t int64 = 3758097111;
        if (v5 != &_xpc_error_connection_invalid) {
          xpc_connection_cancel(*a1);
        }
      }
    }
    xpc_release(v5);
  }
  else
  {
    os_log_t v11 = (os_log_t)off_1002BBC78;
    if (off_1002BBC78 == &_os_log_default)
    {
      os_log_t v11 = os_log_create("com.apple.isp", "services");
      off_1002BBC78 = v11;
    }
    int64_t int64 = 3758097084;
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR)) {
      sub_1000758FC(v11, v12, v13, v14, v15, v16, v17, v18);
    }
  }
  return int64;
}

void sub_10001B18C(uint64_t a1, xpc_object_t object)
{
  xpc_object_t v4 = *(xpc_connection_t **)(a1 + 32);
  xpc_type_t type = xpc_get_type(object);
  if (type == (xpc_type_t)&_xpc_type_dictionary)
  {
    int int64 = xpc_dictionary_get_int64(object, "H16ISPServicesRemoteReturnKey");
    os_log_t v10 = (os_log_t)off_1002BBC78;
    if (off_1002BBC78 == &_os_log_default)
    {
      os_log_t v10 = os_log_create("com.apple.isp", "services");
      off_1002BBC78 = v10;
    }
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      int v11 = *(_DWORD *)(a1 + 40);
      v12[0] = 67109376;
      v12[1] = v11;
      __int16 v13 = 1024;
      int v14 = int64;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "H16ISPServicesRemote: SetProperty (async) %d (reply=0x%08X)\n", (uint8_t *)v12, 0xEu);
    }
  }
  else if (type == (xpc_type_t)&_xpc_type_error)
  {
    os_log_t v6 = xpc_copy_description(object);
    if (v6)
    {
      unsigned int v7 = v6;
      os_log_t v8 = (os_log_t)off_1002BBC78;
      if (off_1002BBC78 == &_os_log_default)
      {
        os_log_t v8 = os_log_create("com.apple.isp", "services");
        off_1002BBC78 = v8;
      }
      if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR)) {
        sub_100075A78();
      }
      free(v7);
    }
    if (object != &_xpc_error_connection_invalid) {
      xpc_connection_cancel(*v4);
    }
  }
}

uint64_t sub_10001B344(uint64_t a1, xpc_object_t *a2, int a3)
{
  int64_t v3 = 3758097085;
  if (!*(void *)a1) {
    return 3758097111;
  }
  xpc_object_t v7 = xpc_dictionary_create(0, 0, 0);
  if (v7)
  {
    os_log_t v8 = v7;
    xpc_dictionary_set_uint64(v7, "H16ISPServicesRemoteTypeKey", 1uLL);
    xpc_dictionary_set_data(v8, "H16ISPServicesRemoteDataKey", a2, 0x3378uLL);
    switch(*(_DWORD *)a2)
    {
      case 7:
        uint64_t v9 = a2 + 1;
        os_log_t v10 = "H16ISPServicesRemoteJasperCalibObjectKey";
        goto LABEL_10;
      case 8:
        xpc_dictionary_set_value(v8, "H16ISPServicesRemoteRGBJBufferKey", a2[1]);
        uint64_t v9 = a2 + 2;
        xpc_dictionary_set_value(v8, "H16ISPServicesRemoteRGBJOriginalCloudBanksKey", a2[3]);
        xpc_dictionary_set_value(v8, "H16ISPServicesRemoteRGBJJasperCalibrationKey", a2[5]);
        xpc_dictionary_set_value(v8, "H16ISPServicesRemoteRGBJColorCalibrationKey", a2[4]);
        os_log_t v10 = "H16ISPServicesRemoteRGBJMetadataKey";
        goto LABEL_10;
      case 9:
      case 0xA:
        xpc_dictionary_set_value(v8, "H16ISPServicesRemoteCFTypeNameKey", a2[1]);
        uint64_t v9 = a2 + 2;
        os_log_t v10 = "H16ISPServicesRemoteCFTypeDataKey";
        goto LABEL_10;
      case 0x11:
        xpc_dictionary_set_value(v8, "H16ISPServicesRemoteRGBIRBufferColorKey", a2[1]);
        xpc_dictionary_set_value(v8, "H16ISPServicesRemoteRGBIRBufferIRKey", a2[2]);
        xpc_dictionary_set_value(v8, "H16ISPServicesRemoteRGBIRBufferDepthKey", a2[3]);
        xpc_dictionary_set_value(v8, "H16ISPServicesRemoteRGBIRMetadataColorKey", a2[4]);
        xpc_dictionary_set_value(v8, "H16ISPServicesRemoteRGBIRMetadataIRKey", a2[5]);
        uint64_t v9 = a2 + 6;
        os_log_t v10 = "H16ISPServicesRemoteRGBIRPCEConfigKey";
        goto LABEL_10;
      case 0x14:
        uint64_t v9 = a2 + 1;
        os_log_t v10 = "H16ISPServicesRemoteDeviceID";
LABEL_10:
        xpc_dictionary_set_value(v8, v10, *v9);
        break;
      default:
        break;
    }
    if (a3)
    {
      int64_t v3 = sub_10001AED8((xpc_connection_t *)a1, v8);
    }
    else
    {
      int v11 = *(_DWORD *)a2;
      uint64_t v12 = *(_xpc_connection_s **)a1;
      __int16 v13 = *(NSObject **)(a1 + 8);
      v15[0] = _NSConcreteStackBlock;
      v15[1] = 0x40000000;
      v15[2] = sub_10001B18C;
      v15[3] = &unk_100096438;
      v15[4] = a1;
      int v16 = v11;
      xpc_connection_send_message_with_reply(v12, v8, v13, v15);
      int64_t v3 = 0;
    }
    xpc_release(v8);
  }
  return v3;
}

uint64_t sub_10001B5EC(xpc_connection_t *a1, xpc_object_t *a2)
{
  uint64_t v2 = 3758097084;
  if (!*a1) {
    return 3758097111;
  }
  xpc_object_t v5 = xpc_dictionary_create(0, 0, 0);
  if (!v5) {
    return 3758097085;
  }
  os_log_t v6 = v5;
  xpc_dictionary_set_uint64(v5, "H16ISPServicesRemoteTypeKey", 2uLL);
  xpc_dictionary_set_data(v6, "H16ISPServicesRemoteDataKey", a2, 0xE60uLL);
  if ((*(_DWORD *)a2 - 9) >= 2)
  {
    if (*(_DWORD *)a2 != 19) {
      goto LABEL_10;
    }
    xpc_object_t v7 = "H16ISPServicesRemoteRGBIRFinalInputPCEConfigKey";
  }
  else
  {
    xpc_object_t v7 = "H16ISPServicesRemoteCFTypeNameKey";
  }
  xpc_dictionary_set_value(v6, v7, a2[1]);
LABEL_10:
  int64_t v8 = sub_10001AED8(a1, v6);
  size_t length = 0;
  data = xpc_dictionary_get_data(v6, "H16ISPServicesRemoteDataKey", &length);
  if (length == 3680)
  {
    uint64_t v2 = v8;
    memcpy(a2, data, 0xE60uLL);
    int v10 = *(_DWORD *)a2;
    if (*(int *)a2 > 17)
    {
      if (v10 == 19)
      {
        if (!v8)
        {
          int v11 = "H16ISPServicesRemoteRGBIRFinalOutputPCEConfigKey";
          goto LABEL_27;
        }
        goto LABEL_23;
      }
      if (v10 == 18)
      {
        if (v8)
        {
LABEL_21:
          a2[1] = 0;
          goto LABEL_29;
        }
        uint64_t v12 = "H16ISPServicesRemoteRGBIRReportKey";
LABEL_25:
        xpc_object_t value = xpc_dictionary_get_value(v6, v12);
        a2[1] = value;
LABEL_28:
        xpc_retain(value);
      }
    }
    else
    {
      if ((v10 - 9) < 2)
      {
        if (!v8)
        {
          int v11 = "H16ISPServicesRemoteCFTypeDataKey";
LABEL_27:
          xpc_object_t value = xpc_dictionary_get_value(v6, v11);
          a2[2] = value;
          goto LABEL_28;
        }
LABEL_23:
        a2[2] = 0;
        goto LABEL_29;
      }
      if (v10 == 7)
      {
        if (v8) {
          goto LABEL_21;
        }
        uint64_t v12 = "H16ISPServicesRemoteJasperCalibObjectKey";
        goto LABEL_25;
      }
    }
LABEL_29:
    xpc_release(v6);
  }
  return v2;
}

uint64_t sub_10001B7A4(uint64_t a1, xpc_object_t *a2)
{
  os_log_t v4 = (os_log_t)off_1002BBC78;
  if (off_1002BBC78 == &_os_log_default)
  {
    os_log_t v4 = os_log_create("com.apple.isp", "services");
    off_1002BBC78 = v4;
  }
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    int v5 = *(_DWORD *)a2;
    int v10 = 67109120;
    int v11 = v5;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "H16ISPServicesRemote: SetProperty %d (sent)\n", (uint8_t *)&v10, 8u);
  }
  uint64_t v6 = sub_10001B344(a1, a2, 1);
  os_log_t v7 = (os_log_t)off_1002BBC78;
  if (off_1002BBC78 == &_os_log_default)
  {
    os_log_t v7 = os_log_create("com.apple.isp", "services");
    off_1002BBC78 = v7;
  }
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    int v8 = *(_DWORD *)a2;
    int v10 = 67109376;
    int v11 = v8;
    __int16 v12 = 1024;
    int v13 = v6;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "H16ISPServicesRemote: SetProperty %d (reply=0x%08X)\n", (uint8_t *)&v10, 0xEu);
  }
  return v6;
}

uint64_t sub_10001B91C(xpc_connection_t *a1, xpc_object_t *a2)
{
  os_log_t v4 = (os_log_t)off_1002BBC78;
  if (off_1002BBC78 == &_os_log_default)
  {
    os_log_t v4 = os_log_create("com.apple.isp", "services");
    off_1002BBC78 = v4;
  }
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    int v5 = *(_DWORD *)a2;
    int v10 = 67109120;
    int v11 = v5;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "H16ISPServicesRemote: GetProperty (%d) (sent)\n", (uint8_t *)&v10, 8u);
  }
  uint64_t v6 = sub_10001B5EC(a1, a2);
  os_log_t v7 = (os_log_t)off_1002BBC78;
  if (off_1002BBC78 == &_os_log_default)
  {
    os_log_t v7 = os_log_create("com.apple.isp", "services");
    off_1002BBC78 = v7;
  }
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    int v8 = *(_DWORD *)a2;
    int v10 = 67109376;
    int v11 = v8;
    __int16 v12 = 1024;
    int v13 = v6;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "H16ISPServicesRemote: GetProperty (%d) (reply=0x%08X)\n", (uint8_t *)&v10, 0xEu);
  }
  return v6;
}

uint64_t sub_10001BA90()
{
  uint64_t v0 = __chkstk_darwin();
  LODWORD(v5[0]) = 7;
  xpc_object_t v2 = sub_100023054(v1);
  v5[1] = v2;
  uint64_t v3 = sub_10001B7A4(v0, v5);
  xpc_release(v2);
  return v3;
}

uint64_t sub_10001BB50(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  if (*(unsigned char *)(a3 + 528))
  {
    sub_1000032CC((uint64_t)&v97, 2, *(_DWORD *)(a1 + 20));
    uint64_t v97 = &off_100096468;
    sub_10001CB34(a2, 0, (uint64_t)&v92);
    int v102 = 1;
    int v103 = v99;
    LODWORD(v90) = 1;
    HIDWORD(v90) = v99;
    char v91 = 0;
    long long v100 = off_100095A80;
    long long v101 = 0;
    char v104 = 0;
    char v88 = &off_100095AB0;
    __dst = v98;
    sub_100003224((uint64_t)&v100);
    sub_100004500((uint64_t)&v88, v94, v95);
    memcpy(__dst, __src, 8 * v90 * (unint64_t)HIDWORD(v90));
    sub_100003224((uint64_t)&v88);
    sub_100003224((uint64_t)&v92);
    double v10 = *(double *)(a3 + 24);
    int v102 = 1;
    int v103 = v99;
    int v94 = 1;
    int v95 = v99;
    char v96 = 0;
    long long v100 = off_100095A80;
    long long v101 = 0;
    char v104 = 0;
    uint64_t v92 = &off_100095AB0;
    __src = v98;
    sub_100003224((uint64_t)&v100);
    if (v95 * v94 >= 1)
    {
      int v11 = (double *)__src;
      __int16 v12 = (double *)((char *)__src + 8 * v95 * v94);
      do
      {
        double *v11 = v10 * *v11;
        ++v11;
      }
      while (v11 < v12);
    }
    sub_100003224((uint64_t)&v92);
    double v13 = *(double *)a3;
    int v102 = 1;
    int v103 = v99;
    int v94 = 1;
    int v95 = v99;
    char v96 = 0;
    long long v100 = off_100095A80;
    long long v101 = 0;
    char v104 = 0;
    uint64_t v92 = &off_100095AB0;
    __src = v98;
    sub_100003224((uint64_t)&v100);
    if (v95 * v94 >= 1)
    {
      int v14 = (double *)__src;
      uint64_t v15 = (double *)((char *)__src + 8 * v95 * v94);
      do
      {
        *int v14 = *v14 - v13;
        ++v14;
      }
      while (v14 < v15);
    }
    sub_100003224((uint64_t)&v92);
    sub_10001CB34(a2, 1, (uint64_t)&v92);
    int v102 = 1;
    int v103 = v99;
    LODWORD(v90) = 1;
    HIDWORD(v90) = v99;
    char v91 = 0;
    long long v100 = off_100095A80;
    long long v101 = 0;
    char v104 = 0;
    char v88 = &off_100095AB0;
    __dst = &v98[8 * v99];
    sub_100003224((uint64_t)&v100);
    sub_100004500((uint64_t)&v88, v94, v95);
    memcpy(__dst, __src, 8 * v90 * (unint64_t)HIDWORD(v90));
    sub_100003224((uint64_t)&v88);
    sub_100003224((uint64_t)&v92);
    double v16 = *(double *)(a3 + 24);
    int v102 = 1;
    int v103 = v99;
    int v94 = 1;
    int v95 = v99;
    char v96 = 0;
    long long v100 = off_100095A80;
    long long v101 = 0;
    char v104 = 0;
    uint64_t v92 = &off_100095AB0;
    __src = &v98[8 * v99];
    sub_100003224((uint64_t)&v100);
    if (v95 * v94 >= 1)
    {
      uint64_t v17 = (double *)__src;
      uint64_t v18 = (double *)((char *)__src + 8 * v95 * v94);
      do
      {
        *uint64_t v17 = v16 * *v17;
        ++v17;
      }
      while (v17 < v18);
    }
    sub_100003224((uint64_t)&v92);
    double v19 = *(double *)(a3 + 8);
    int v102 = 1;
    int v103 = v99;
    int v94 = 1;
    int v95 = v99;
    char v96 = 0;
    long long v100 = off_100095A80;
    long long v101 = 0;
    char v104 = 0;
    uint64_t v92 = &off_100095AB0;
    __src = &v98[8 * v99];
    sub_100003224((uint64_t)&v100);
    if (v95 * v94 >= 1)
    {
      uint64_t v20 = (double *)__src;
      uint64_t v21 = (double *)((char *)__src + 8 * v95 * v94);
      do
      {
        *uint64_t v20 = *v20 - v19;
        ++v20;
      }
      while (v20 < v21);
    }
    sub_100003224((uint64_t)&v92);
    xpc_object_t v22 = *(void **)(a5 + 8);
    int v23 = *(_DWORD *)(a5 + 20);
    int v102 = 2;
    int v103 = v23;
    int v94 = 2;
    int v95 = v23;
    char v96 = 0;
    long long v100 = off_100095A80;
    long long v101 = 0;
    char v104 = 0;
    uint64_t v92 = &off_100096468;
    __src = v22;
    sub_100003224((uint64_t)&v100);
    uint64_t v90 = 1;
    char v91 = 0;
    char v88 = &off_100095AB0;
    __dst = 0;
    uint64_t v86 = 1;
    char v87 = 0;
    float v84 = &off_100095AB0;
    float v85 = 0;
    if (*(unsigned char *)(a3 + 529))
    {
      sub_10001CA74(a3 + 128, 0, (uint64_t)&v100);
      sub_100004500((uint64_t)&v88, v102, v103);
      memcpy(__dst, v101, 8 * v90 * (unint64_t)HIDWORD(v90));
      sub_100003224((uint64_t)&v100);
      sub_10001CA74(a3 + 128, 1, (uint64_t)&v100);
    }
    else
    {
      sub_10001CA74(a3 + 744, 0, (uint64_t)&v100);
      sub_100004500((uint64_t)&v88, v102, v103);
      memcpy(__dst, v101, 8 * v90 * (unint64_t)HIDWORD(v90));
      sub_100003224((uint64_t)&v100);
      sub_10001CA74(a3 + 744, 1, (uint64_t)&v100);
    }
    sub_100004500((uint64_t)&v84, v102, v103);
    memcpy(v85, v101, 8 * v86 * (unint64_t)HIDWORD(v86));
    sub_100003224((uint64_t)&v100);
    sub_10001CBB8((uint64_t)&v97, (uint64_t)v85, (uint64_t)__dst, *(_DWORD *)(a3 + 148), (uint64_t)&v92, 0, 1, 0, 0.0, 0);
    double v35 = *(double *)a3;
    sub_10001CB34(a5, 0, (uint64_t)&v100);
    if (v103 * v102 >= 1)
    {
      double v36 = (double *)v101;
      vDSP_Length v37 = (double *)&v101[8 * v103 * v102];
      do
      {
        *double v36 = v35 + *v36;
        ++v36;
      }
      while (v36 < v37);
    }
    sub_100003224((uint64_t)&v100);
    double v38 = *(double *)(a3 + 24);
    sub_10001CB34(a5, 0, (uint64_t)&v100);
    if (v103 * v102 >= 1)
    {
      unint64_t v39 = (double *)v101;
      float v40 = (double *)&v101[8 * v103 * v102];
      do
      {
        *unint64_t v39 = *v39 / v38;
        ++v39;
      }
      while (v39 < v40);
    }
    sub_100003224((uint64_t)&v100);
    double v41 = *(double *)(a3 + 8);
    sub_10001CB34(a5, 1, (uint64_t)&v100);
    if (v103 * v102 >= 1)
    {
      vDSP_Length v42 = (double *)v101;
      vDSP_Length v43 = (double *)&v101[8 * v103 * v102];
      do
      {
        *vDSP_Length v42 = v41 + *v42;
        ++v42;
      }
      while (v42 < v43);
    }
    sub_100003224((uint64_t)&v100);
    double v44 = *(double *)(a3 + 24);
    sub_10001CB34(a5, 1, (uint64_t)&v100);
    if (v103 * v102 >= 1)
    {
      float v45 = (double *)v101;
      os_log_t v46 = (double *)&v101[8 * v103 * v102];
      do
      {
        *float v45 = *v45 / v44;
        ++v45;
      }
      while (v45 < v46);
    }
    sub_100003224((uint64_t)&v100);
    sub_10001CB34(a1, 0, (uint64_t)&v79);
    int v102 = 1;
    int v103 = v99;
    unsigned int v76 = 1;
    unsigned int v77 = v99;
    char v78 = 0;
    long long v100 = off_100095A80;
    long long v101 = 0;
    char v104 = 0;
    BOOL v74 = &off_100095AB0;
    float v75 = v98;
    sub_100003224((uint64_t)&v100);
    sub_100004500((uint64_t)&v74, v81, v82);
    memcpy(v75, v80, 8 * v76 * (unint64_t)v77);
    sub_100003224((uint64_t)&v74);
    sub_100003224((uint64_t)&v79);
    double v47 = *(double *)(a3 + 80);
    int v102 = 1;
    int v103 = v99;
    int v81 = 1;
    int v82 = v99;
    char v83 = 0;
    long long v100 = off_100095A80;
    long long v101 = 0;
    char v104 = 0;
    float v79 = (uint64_t (**)())&off_100095AB0;
    int v80 = v98;
    sub_100003224((uint64_t)&v100);
    if (v82 * v81 >= 1)
    {
      uint64_t v48 = (double *)v80;
      uint64_t v49 = (double *)((char *)v80 + 8 * v82 * v81);
      do
      {
        *uint64_t v48 = v47 * *v48;
        ++v48;
      }
      while (v48 < v49);
    }
    sub_100003224((uint64_t)&v79);
    double v50 = *(double *)(a3 + 56);
    int v102 = 1;
    int v103 = v99;
    int v81 = 1;
    int v82 = v99;
    char v83 = 0;
    long long v100 = off_100095A80;
    long long v101 = 0;
    char v104 = 0;
    float v79 = (uint64_t (**)())&off_100095AB0;
    int v80 = v98;
    sub_100003224((uint64_t)&v100);
    if (v82 * v81 >= 1)
    {
      uint64_t v51 = (double *)v80;
      float32x2_t v52 = (double *)((char *)v80 + 8 * v82 * v81);
      do
      {
        *uint64_t v51 = *v51 - v50;
        ++v51;
      }
      while (v51 < v52);
    }
    sub_100003224((uint64_t)&v79);
    sub_10001CB34(a1, 1, (uint64_t)&v79);
    int v102 = 1;
    int v103 = v99;
    unsigned int v76 = 1;
    unsigned int v77 = v99;
    char v78 = 0;
    long long v100 = off_100095A80;
    long long v101 = 0;
    char v104 = 0;
    BOOL v74 = &off_100095AB0;
    float v75 = &v98[8 * v99];
    sub_100003224((uint64_t)&v100);
    sub_100004500((uint64_t)&v74, v81, v82);
    memcpy(v75, v80, 8 * v76 * (unint64_t)v77);
    sub_100003224((uint64_t)&v74);
    sub_100003224((uint64_t)&v79);
    double v53 = *(double *)(a3 + 80);
    int v102 = 1;
    int v103 = v99;
    int v81 = 1;
    int v82 = v99;
    char v83 = 0;
    long long v100 = off_100095A80;
    long long v101 = 0;
    char v104 = 0;
    float v79 = (uint64_t (**)())&off_100095AB0;
    int v80 = &v98[8 * v99];
    sub_100003224((uint64_t)&v100);
    if (v82 * v81 >= 1)
    {
      uint64_t v54 = (double *)v80;
      float v55 = (double *)((char *)v80 + 8 * v82 * v81);
      do
      {
        *uint64_t v54 = v53 * *v54;
        ++v54;
      }
      while (v54 < v55);
    }
    sub_100003224((uint64_t)&v79);
    double v56 = *(double *)(a3 + 64);
    int v102 = 1;
    int v103 = v99;
    int v81 = 1;
    int v82 = v99;
    char v83 = 0;
    long long v100 = off_100095A80;
    long long v101 = 0;
    char v104 = 0;
    float v79 = (uint64_t (**)())&off_100095AB0;
    int v80 = &v98[8 * v99];
    sub_100003224((uint64_t)&v100);
    if (v82 * v81 >= 1)
    {
      BOOL v57 = (double *)v80;
      BOOL v58 = (double *)((char *)v80 + 8 * v82 * v81);
      do
      {
        *BOOL v57 = *v57 - v56;
        ++v57;
      }
      while (v57 < v58);
    }
    sub_100003224((uint64_t)&v79);
    int v59 = *(char **)(a4 + 8);
    int v60 = *(_DWORD *)(a4 + 20);
    int v81 = 2;
    int v82 = v60;
    int v102 = 2;
    int v103 = v60;
    char v104 = 0;
    float v79 = off_100095A80;
    int v80 = 0;
    char v83 = 0;
    long long v100 = (uint64_t (**)())&off_100096468;
    long long v101 = v59;
    sub_100003224((uint64_t)&v79);
    if (!*(unsigned char *)(a3 + 529))
    {
      sub_10001CA74(a3 + 128, 0, (uint64_t)&v79);
      sub_100004500((uint64_t)&v88, v81, v82);
      memcpy(__dst, v80, 8 * v90 * (unint64_t)HIDWORD(v90));
      sub_100003224((uint64_t)&v79);
      sub_10001CA74(a3 + 128, 1, (uint64_t)&v79);
      sub_100004500((uint64_t)&v84, v81, v82);
      memcpy(v85, v80, 8 * v86 * (unint64_t)HIDWORD(v86));
      sub_100003224((uint64_t)&v79);
    }
    sub_10001CBB8((uint64_t)&v97, (uint64_t)v85, (uint64_t)__dst, *(_DWORD *)(a3 + 148), (uint64_t)&v100, 0, 1, 0, 0.0, 0);
    double v61 = *(double *)(a3 + 56);
    sub_10001CB34(a4, 0, (uint64_t)&v79);
    if (v82 * v81 >= 1)
    {
      uint64_t v62 = (double *)v80;
      uint64_t v63 = (double *)((char *)v80 + 8 * v82 * v81);
      do
      {
        *uint64_t v62 = v61 + *v62;
        ++v62;
      }
      while (v62 < v63);
    }
    sub_100003224((uint64_t)&v79);
    double v64 = *(double *)(a3 + 80);
    sub_10001CB34(a4, 0, (uint64_t)&v79);
    if (v82 * v81 >= 1)
    {
      float v65 = (double *)v80;
      float v66 = (double *)((char *)v80 + 8 * v82 * v81);
      do
      {
        *float v65 = *v65 / v64;
        ++v65;
      }
      while (v65 < v66);
    }
    sub_100003224((uint64_t)&v79);
    double v67 = *(double *)(a3 + 64);
    sub_10001CB34(a4, 1, (uint64_t)&v79);
    if (v82 * v81 >= 1)
    {
      uint64_t v68 = (double *)v80;
      uint64_t v69 = (double *)((char *)v80 + 8 * v82 * v81);
      do
      {
        *uint64_t v68 = v67 + *v68;
        ++v68;
      }
      while (v68 < v69);
    }
    sub_100003224((uint64_t)&v79);
    double v70 = *(double *)(a3 + 80);
    sub_10001CB34(a4, 1, (uint64_t)&v79);
    if (v82 * v81 >= 1)
    {
      long long v71 = (double *)v80;
      int v72 = (double *)((char *)v80 + 8 * v82 * v81);
      do
      {
        *long long v71 = *v71 / v70;
        ++v71;
      }
      while (v71 < v72);
    }
    sub_100003224((uint64_t)&v79);
    sub_100003224((uint64_t)&v100);
    sub_100003224((uint64_t)&v84);
    sub_100003224((uint64_t)&v88);
    sub_100003224((uint64_t)&v92);
    sub_100003224((uint64_t)&v97);
  }
  else
  {
    uint64_t v24 = *(unsigned int *)(a1 + 20);
    if (v24)
    {
      unsigned int v25 = *(_DWORD *)(a1 + 16);
      if (!v25) {
        sub_100073870();
      }
      unsigned int v26 = *(_DWORD *)(a4 + 16);
      if (v26)
      {
        uint64_t v27 = 0;
        unint64_t v28 = 0;
        uint64_t v29 = 8 * *(unsigned int *)(a4 + 20);
        unsigned int v30 = *(_DWORD *)(a2 + 16);
        unint64_t v31 = *(unsigned int *)(a2 + 20);
        uint64_t v32 = 8 * v24;
        while (v29 + v27)
        {
          *(void *)(*(void *)(a4 + 8) + 8 * v28) = *(void *)(*(void *)(a1 + 8) + 8 * v28);
          if (v25 <= 1) {
            sub_100073870();
          }
          if (v26 <= 1) {
            sub_100073870();
          }
          *(void *)(*(void *)(a4 + 8) + v29 + 8 * v28) = *(void *)(*(void *)(a1 + 8) + v32 + 8 * v28);
          if (!v30 || v28 >= v31) {
            sub_100073870();
          }
          unsigned int v33 = *(_DWORD *)(a5 + 16);
          if (!v33 || (unint64_t v34 = *(unsigned int *)(a5 + 20), v28 >= v34)) {
            sub_100073870();
          }
          *(void *)(*(void *)(a5 + 8) + 8 * v28) = *(void *)(*(void *)(a2 + 8) + 8 * v28);
          if (v30 <= 1) {
            sub_100073870();
          }
          if (v33 <= 1) {
            sub_100073870();
          }
          *(void *)(*(void *)(a5 + 8) + 8 * v34 + 8 * v28) = *(void *)(*(void *)(a2 + 8) + 8 * v31 + 8 * v28);
          ++v28;
          v27 -= 8;
          if (!(v32 + v27)) {
            return 0;
          }
        }
      }
      sub_100073870();
    }
  }
  return 0;
}

void sub_10001C9A4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19, uint64_t a20,uint64_t a21,uint64_t a22,char a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27)
{
  sub_100003224((uint64_t)&a15);
  sub_100003224(v27 - 128);
  sub_100003224((uint64_t)&a19);
  sub_100003224((uint64_t)&a23);
  sub_100003224((uint64_t)&a27);
  sub_100003224(v27 - 160);
  _Unwind_Resume(a1);
}

void sub_10001CA5C()
{
}

uint64_t sub_10001CA74@<X0>(uint64_t a1@<X0>, int a2@<W1>, uint64_t a3@<X8>)
{
  int v3 = *(_DWORD *)(a1 + 20);
  uint64_t v4 = *(void *)(a1 + 8) + 8 * (v3 * a2);
  v6[0] = off_100095A80;
  v6[1] = v4;
  int v7 = 1;
  int v8 = v3;
  char v9 = 0;
  *(_DWORD *)(a3 + 16) = 1;
  *(_DWORD *)(a3 + 20) = v3;
  *(unsigned char *)(a3 + 24) = 0;
  *(void *)a3 = &off_100095AB0;
  *(void *)(a3 + 8) = v4;
  return sub_100003224((uint64_t)v6);
}

void sub_10001CAFC(uint64_t a1)
{
  sub_100003224(a1);

  operator delete();
}

uint64_t sub_10001CB34@<X0>(uint64_t a1@<X0>, int a2@<W1>, uint64_t a3@<X8>)
{
  int v3 = *(_DWORD *)(a1 + 20);
  uint64_t v4 = *(void *)(a1 + 8) + 8 * (v3 * a2);
  int v7 = 1;
  int v8 = v3;
  *(_DWORD *)(a3 + 16) = 1;
  *(_DWORD *)(a3 + 20) = v3;
  *(unsigned char *)(a3 + 24) = 0;
  v6[0] = off_100095A80;
  v6[1] = 0;
  char v9 = 0;
  *(void *)a3 = &off_100095AB0;
  *(void *)(a3 + 8) = v4;
  return sub_100003224((uint64_t)v6);
}

uint64_t sub_10001CBB8(uint64_t a1, uint64_t a2, uint64_t a3, int a4, uint64_t a5, char a6, int a7, int a8, double a9, char a10)
{
  if (*(_DWORD *)(a1 + 16) != 2) {
    sub_100075AF8();
  }
  if (a7) {
    uint64_t v15 = a2;
  }
  else {
    uint64_t v15 = a3;
  }
  if (a7) {
    uint64_t v16 = a3;
  }
  else {
    uint64_t v16 = a2;
  }
  int v63 = 1;
  int v64 = a4;
  char v65 = 0;
  v62[0] = &off_100095AB0;
  v62[1] = v15;
  int v59 = 1;
  int v60 = a4;
  char v61 = 0;
  v58[0] = &off_100095AB0;
  v58[1] = v16;
  sub_1000032CC((uint64_t)&v54, 1, *(_DWORD *)(a1 + 20));
  uint64_t v54 = &off_100095AB0;
  sub_1000032CC((uint64_t)v53, 1, *(_DWORD *)(a1 + 20));
  v53[0] = &off_100095AB0;
  uint64_t v17 = v57;
  sub_10001D090(a1, a1, (uint64_t)v49);
  if (a6)
  {
    if ((int)v17 >= 1)
    {
      unsigned int v18 = v51;
      if (v51)
      {
        unint64_t v19 = 0;
        uint64_t v20 = v52;
        int v21 = v56;
        uint64_t v22 = 8 * v52;
        while (v20 != v19 && v18 >= 2 && v21 && v19 < v57)
        {
          double v23 = sqrt(*(double *)(v50 + 8 * v19) + *(double *)(v50 + 8 * v19 + v22));
          if (v23 >= a9) {
            double v23 = a9;
          }
          *(double *)(v55 + 8 * v19++) = v23;
          if (v17 == v19) {
            goto LABEL_28;
          }
        }
      }
      goto LABEL_50;
    }
  }
  else if ((int)v17 >= 1)
  {
    unsigned int v24 = v51;
    if (v51)
    {
      unint64_t v25 = 0;
      uint64_t v26 = v52;
      int v27 = v56;
      uint64_t v28 = 8 * v52;
      while (v26 != v25 && v24 >= 2 && v27 && v25 < v57)
      {
        *(double *)(v55 + 8 * v25) = sqrt(*(double *)(v50 + 8 * v25) + *(double *)(v50 + v28 + 8 * v25));
        if (v17 == ++v25) {
          goto LABEL_28;
        }
      }
    }
LABEL_50:
    __assert_rtn("operator()", "Matrix.hpp", 119, "row < m_rows && col < m_cols");
  }
LABEL_28:
  if (a8) {
    sub_10001D23C((uint64_t)v62, (uint64_t)v58, (uint64_t)&v54, (uint64_t)v53);
  }
  else {
    sub_10001D118((uint64_t)v62, (uint64_t)v58, (uint64_t)&v54, 1, (uint64_t)v53, a10);
  }
  sub_10001D1C8((uint64_t)v53, (uint64_t)&v54, (uint64_t)&v41);
  float v45 = off_100095A80;
  uint64_t v46 = v42;
  uint64_t v47 = v43;
  char v48 = v44;
  uint64_t v42 = 0;
  char v44 = 0;
  sub_100003224((uint64_t)&v41);
  uint64_t v29 = v57;
  if ((int)v57 >= 1)
  {
    if (v56)
    {
      unint64_t v30 = 0;
      int v31 = v47;
      while (1)
      {
        if (*(double *)(v55 + 8 * v30) == 0.0)
        {
          if (!v31 || v30 >= HIDWORD(v47)) {
            break;
          }
          *(void *)(v46 + 8 * v30) = 0x3FF0000000000000;
        }
        if (v29 == ++v30)
        {
          unsigned int v32 = *(_DWORD *)(a1 + 16);
          if (v32)
          {
            unint64_t v33 = 0;
            uint64_t v34 = *(unsigned int *)(a1 + 20);
            int v35 = v47;
            int v36 = 119;
            while (1)
            {
              if (v34 == v33) {
                goto LABEL_53;
              }
              if (!v35 || v33 >= HIDWORD(v47)) {
                goto LABEL_54;
              }
              unsigned int v37 = *(_DWORD *)(a5 + 16);
              if (!v37) {
                break;
              }
              unint64_t v38 = *(unsigned int *)(a5 + 20);
              if (v33 >= v38) {
                break;
              }
              *(double *)(*(void *)(a5 + 8) + 8 * v33) = *(double *)(*(void *)(a1 + 8) + 8 * v33)
                                                         * *(double *)(v46 + 8 * v33);
              if (v32 < 2)
              {
                int v40 = 125;
                goto LABEL_57;
              }
              if (v37 <= 1)
              {
                int v40 = 119;
LABEL_57:
                __assert_rtn("operator()", "Matrix.hpp", v40, "row < m_rows && col < m_cols");
              }
              *(double *)(*(void *)(a5 + 8) + 8 * v38 + 8 * v33) = *(double *)(v46 + 8 * v33)
                                                                   * *(double *)(*(void *)(a1 + 8) + 8 * v34 + 8 * v33);
              if (v29 == ++v33) {
                goto LABEL_49;
              }
            }
            int v36 = 119;
          }
          else
          {
LABEL_53:
            int v36 = 125;
          }
LABEL_54:
          __assert_rtn("operator()", "Matrix.hpp", v36, "row < m_rows && col < m_cols");
        }
      }
    }
    __assert_rtn("operator()", "Matrix.hpp", 119, "row < m_rows && col < m_cols");
  }
LABEL_49:
  sub_100003224((uint64_t)&v45);
  sub_100003224((uint64_t)v49);
  sub_100003224((uint64_t)v53);
  sub_100003224((uint64_t)&v54);
  sub_100003224((uint64_t)v58);
  sub_100003224((uint64_t)v62);
  return 0;
}

void sub_10001D028(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va2, a9);
  va_start(va1, a9);
  va_start(va, a9);
  uint64_t v11 = va_arg(va1, void);
  uint64_t v13 = va_arg(va1, void);
  uint64_t v14 = va_arg(va1, void);
  uint64_t v15 = va_arg(va1, void);
  va_copy(va2, va1);
  uint64_t v16 = va_arg(va2, void);
  uint64_t v18 = va_arg(va2, void);
  uint64_t v19 = va_arg(va2, void);
  uint64_t v20 = va_arg(va2, void);
  sub_100003224((uint64_t)va);
  sub_100003224((uint64_t)va1);
  sub_100003224((uint64_t)va2);
  sub_100003224(v9 - 128);
  sub_100003224(v9 - 96);
  _Unwind_Resume(a1);
}

double sub_10001D090@<D0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  int v4 = *(_DWORD *)(a2 + 20);
  if (v4 != *(_DWORD *)(a1 + 20) || (int v6 = *(_DWORD *)(a2 + 16), v6 != *(_DWORD *)(a1 + 16))) {
    sub_100075B24();
  }
  uint64_t v7 = sub_1000032CC(a3, v6, v4);
  int v9 = *(_DWORD *)(a1 + 20) * *(_DWORD *)(a1 + 16);
  if (v9 >= 1)
  {
    double v10 = *(double **)(a1 + 8);
    uint64_t v11 = &v10[v9];
    __int16 v12 = *(double **)(v7 + 8);
    uint64_t v13 = *(double **)(a2 + 8);
    do
    {
      double v14 = *v10++;
      double v15 = v14;
      double v16 = *v13++;
      double result = v15 * v16;
      *v12++ = result;
    }
    while (v10 < v11);
  }
  return result;
}

uint64_t sub_10001D118(uint64_t a1, uint64_t a2, uint64_t a3, int a4, uint64_t a5, char a6)
{
  if (a4)
  {
    if (a4 == 2)
    {
      if (*(_DWORD *)(a3 + 20) <= 1u) {
        sub_100075BA8();
      }
      return sub_10001D5CC(a1, a2, a3, a5, a6);
    }
    else
    {
      if (a4 != 1) {
        sub_100075B50();
      }
      if (!*(_DWORD *)(a3 + 20)) {
        sub_100075B7C();
      }
      return sub_10001D410(a1, a2, a3, a5, a6);
    }
  }
  else
  {
    if (*(_DWORD *)(a3 + 20) <= 1u) {
      sub_100075BD4();
    }
    return sub_10001D964(a1, a2, a3, a5, a6);
  }
}

uint64_t sub_10001D1C8@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  sub_10001DB20(a1, a2, (uint64_t)&v7);
  uint64_t v4 = v8;
  int v5 = v9;
  *(unsigned char *)(a3 + 24) = v10;
  uint64_t v8 = 0;
  char v10 = 0;
  *(void *)a3 = &off_100095AB0;
  *(void *)(a3 + 8) = v4;
  *(_DWORD *)(a3 + 16) = 1;
  *(_DWORD *)(a3 + 20) = v5;
  return sub_100003224((uint64_t)&v7);
}

uint64_t sub_10001D23C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (*(_DWORD *)(a1 + 20) != *(_DWORD *)(a2 + 20)) {
    sub_100075C2C();
  }
  unsigned int v5 = *(_DWORD *)(a3 + 20);
  if (v5 <= 1) {
    sub_100075C00();
  }
  sub_100004500(a4, 1, v5);
  unint64_t v9 = *(unsigned int *)(a3 + 20);
  if (v9)
  {
    unint64_t v10 = 0;
    unsigned int v11 = 0;
    int v12 = *(_DWORD *)(a1 + 20);
    double v13 = *(double *)(*(void *)(a1 + 8) + 8 * (v12 - 1));
    do
    {
      double v14 = *(double *)(*(void *)(a3 + 8) + 8 * v10);
      unsigned int v18 = 0;
      if (v14 >= v13)
      {
        unsigned int v15 = v12 - 2;
        unsigned int v11 = v12 - 2;
      }
      else
      {
        sub_10001D36C(a1, v11, (int *)&v18, v14);
        int v12 = *(_DWORD *)(a1 + 20);
        unsigned int v11 = v18;
        unint64_t v9 = *(unsigned int *)(a3 + 20);
        unsigned int v15 = v12 - 2;
      }
      if (v12 - 1 > v11) {
        unsigned int v15 = v11;
      }
      uint64_t v16 = *(void *)(a2 + 8);
      *(double *)(*(void *)(a4 + 8) + 8 * v10++) = *(double *)(v16 + 8 * v15)
                                                   + (*(double *)(v16 + 8 * (v15 + 1)) - *(double *)(v16 + 8 * v15))
                                                   * ((v14 - *(double *)(*(void *)(a1 + 8) + 8 * v15))
                                                    / (*(double *)(*(void *)(a1 + 8) + 8 * (v15 + 1))
                                                     - *(double *)(*(void *)(a1 + 8) + 8 * v15)));
    }
    while (v10 < v9);
  }
  return 0;
}

uint64_t sub_10001D36C(uint64_t a1, int a2, int *a3, double a4)
{
  uint64_t v4 = *(unsigned int *)(a1 + 20);
  int v5 = v4 - 1;
  if ((int)v4 - 1 >= 100)
  {
    if (v5 >= a2)
    {
      while (1)
      {
        int v9 = (a2 + v5) >> 1;
        double v10 = *(double *)(*(void *)(a1 + 8) + 8 * v9);
        if (v10 == a4) {
          break;
        }
        if (v10 <= a4) {
          a2 = v9 + 1;
        }
        else {
          int v5 = v9 - 1;
        }
        if (a2 > v5) {
          goto LABEL_18;
        }
      }
      a2 = (a2 + v5) >> 1;
    }
LABEL_18:
    if (v5 >= a2) {
      int v5 = a2;
    }
    int v8 = v5 & ~(v5 >> 31);
  }
  else
  {
    *a3 = 0;
    if ((int)v4 < 1)
    {
LABEL_6:
      LODWORD(v6) = 0;
    }
    else
    {
      uint64_t v6 = 0;
      while (*(double *)(*(void *)(a1 + 8) + 8 * v6) <= a4)
      {
        if (v4 == ++v6) {
          goto LABEL_6;
        }
      }
    }
    BOOL v7 = v6 != 0;
    int v8 = v6 - 1;
    if (!v7) {
      int v8 = 0;
    }
  }
  *a3 = v8;
  return 0;
}

uint64_t sub_10001D410(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, char a5)
{
  if (*(_DWORD *)(a1 + 20) != *(_DWORD *)(a2 + 20)) {
    sub_100075C58();
  }
  uint64_t v10 = *(unsigned int *)(a3 + 20);
  sub_100004500(a4, 1, *(_DWORD *)(a3 + 20));
  uint64_t v11 = *(int *)(a1 + 20);
  unsigned int v26 = 0;
  int v12 = *(double **)(a3 + 8);
  double v13 = *(double **)(a4 + 8);
  uint64_t v14 = *(void *)(a2 + 8);
  unsigned int v15 = *(double **)(a1 + 8);
  double v16 = v15[v11 - 1];
  if (a5)
  {
    if ((int)v10 >= 1)
    {
      double v17 = *v15;
      double v18 = v15[1] - *v15;
      do
      {
        double v19 = *v12;
        unsigned int v20 = v11 - 2;
        if (*v12 < v16)
        {
          unsigned int v20 = ((v19 - v17) / v18);
          if (v20 + 1 < v11 && *(double *)(*(void *)(a1 + 8) + 8 * (v20 + 1)) <= v19) {
            ++v20;
          }
        }
        if ((int)v11 - 1 <= v20) {
          unsigned int v20 = v11 - 2;
        }
        *v13++ = *(double *)(v14 + 8 * v20)
               + (*(double *)(v14 + 8 * (v20 + 1)) - *(double *)(v14 + 8 * v20))
               * ((v19 - v15[v20])
                / (v15[v20 + 1] - v15[v20]));
        ++v12;
        --v10;
      }
      while (v10);
    }
  }
  else if ((int)v10 >= 1)
  {
    int v21 = v11 - 2;
    unsigned int v22 = v11 - 1;
    do
    {
      double v23 = *v12;
      if (*v12 >= v16)
      {
        unsigned int v26 = v21;
        unsigned int v24 = v21;
      }
      else
      {
        sub_10001D36C(a1, 0, (int *)&v26, *v12);
        unsigned int v24 = v26;
      }
      if (v22 <= v24) {
        unsigned int v24 = v21;
      }
      *v13++ = *(double *)(v14 + 8 * v24)
             + (*(double *)(v14 + 8 * (v24 + 1)) - *(double *)(v14 + 8 * v24))
             * ((v23 - v15[v24])
              / (v15[v24 + 1] - v15[v24]));
      ++v12;
      --v10;
    }
    while (v10);
  }
  return 0;
}

uint64_t sub_10001D5CC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, char a5)
{
  if (*(_DWORD *)(a1 + 20) != *(_DWORD *)(a2 + 20)) {
    sub_100075C58();
  }
  uint64_t v10 = *(unsigned int *)(a3 + 20);
  sub_100004500(a4, 1, *(_DWORD *)(a3 + 20));
  uint64_t v11 = *(int *)(a1 + 20);
  unsigned int v44 = 0;
  int v12 = *(double **)(a3 + 8);
  double v13 = *(double **)(a4 + 8);
  uint64_t v14 = *(double **)(a2 + 8);
  unsigned int v15 = *(double **)(a1 + 8);
  double v16 = v15[v11 - 1];
  if ((a5 & 1) == 0)
  {
    if ((int)v10 < 1) {
      return 0;
    }
    uint64_t v31 = (v11 - 2);
    uint64_t v32 = (v11 - 1);
    while (1)
    {
      double v33 = *v12;
      if (*v12 >= v16)
      {
        unsigned int v44 = v11 - 2;
        unsigned int v34 = v11 - 2;
      }
      else
      {
        sub_10001D36C(a1, 0, (int *)&v44, *v12);
        unsigned int v34 = v44;
      }
      if (v11 >= 4) {
        break;
      }
      if (v11 != 3)
      {
        double v36 = *v14;
        double v37 = v14[1];
        double v35 = -(v37 - *v14 * 2.0);
        double v38 = -(*v14 - v37 * 2.0);
        goto LABEL_40;
      }
      double v36 = *v14;
      double v37 = v14[1];
      if (!v34) {
        goto LABEL_39;
      }
      double v38 = -(v37 - v14[2] * 2.0);
      double v39 = *v15;
      double v40 = v15[1];
      double v41 = v40;
      double v35 = *v14;
      double v36 = v14[1];
      double v37 = v14[2];
LABEL_42:
      double v42 = (v33 - v41) / (v40 - v39);
      *v13++ = v36
             + v42 * (v42 * (v35 + v36 * -2.5 + v37 * 2.0 + v38 * -0.5))
             + v42 * (v42 * ((v36 - v37) * 1.5 + (v38 - v35) * 0.5)) * v42
             + (v37 - v35) * 0.5 * v42;
      ++v12;
      if (!--v10) {
        return 0;
      }
    }
    if (v31 <= v34)
    {
      double v35 = v14[(v11 - 3)];
      double v36 = v14[v31];
      double v37 = v14[v32];
      double v38 = -(v36 - v37 * 2.0);
      double v39 = v15[v31];
      double v40 = v15[v32];
    }
    else if (v34)
    {
      double v35 = v14[v34 - 1];
      double v36 = v14[v34];
      double v37 = v14[v34 + 1];
      double v38 = v14[v34 + 2];
      double v39 = v15[v34];
      double v40 = v15[v34 + 1];
    }
    else
    {
      double v36 = *v14;
      double v37 = v14[1];
LABEL_39:
      double v35 = -(v37 - v36 * 2.0);
      double v38 = v14[2];
LABEL_40:
      double v39 = *v15;
      double v40 = v15[1];
    }
    double v41 = v39;
    goto LABEL_42;
  }
  if ((int)v10 >= 1)
  {
    double v17 = *v15;
    double v18 = v15[1] - *v15;
    uint64_t v19 = (v11 - 2);
    uint64_t v20 = (v11 - 1);
    while (1)
    {
      double v21 = *v12;
      unsigned int v22 = v11 - 2;
      if (*v12 < v16)
      {
        unsigned int v22 = ((v21 - v17) / v18);
        if (v22 + 1 < v11 && *(double *)(*(void *)(a1 + 8) + 8 * (v22 + 1)) <= v21) {
          ++v22;
        }
      }
      if (v11 >= 4) {
        break;
      }
      if (v11 != 3)
      {
        double v24 = *v14;
        double v25 = v14[1];
        double v23 = -(v25 - *v14 * 2.0);
        double v26 = -(*v14 - v25 * 2.0);
        goto LABEL_20;
      }
      double v24 = *v14;
      double v25 = v14[1];
      if (!v22) {
        goto LABEL_19;
      }
      double v26 = -(v25 - v14[2] * 2.0);
      double v27 = *v15;
      double v28 = v15[1];
      double v29 = v28;
      double v23 = *v14;
      double v24 = v14[1];
      double v25 = v14[2];
LABEL_22:
      double v30 = (v21 - v29) / (v28 - v27);
      *v13++ = v24
             + v30 * (v30 * (v23 + v24 * -2.5 + v25 * 2.0 + v26 * -0.5))
             + v30 * (v30 * ((v24 - v25) * 1.5 + (v26 - v23) * 0.5)) * v30
             + (v25 - v23) * 0.5 * v30;
      ++v12;
      if (!--v10) {
        return 0;
      }
    }
    if (v19 <= v22)
    {
      double v23 = v14[(v11 - 3)];
      double v24 = v14[v19];
      double v25 = v14[v20];
      double v26 = -(v24 - v25 * 2.0);
      double v27 = v15[v19];
      double v28 = v15[v20];
    }
    else if (v22)
    {
      double v23 = v14[v22 - 1];
      double v24 = v14[v22];
      double v25 = v14[v22 + 1];
      double v26 = v14[v22 + 2];
      double v27 = v15[v22];
      double v28 = v15[v22 + 1];
    }
    else
    {
      double v24 = *v14;
      double v25 = v14[1];
LABEL_19:
      double v23 = -(v25 - v24 * 2.0);
      double v26 = v14[2];
LABEL_20:
      double v27 = *v15;
      double v28 = v15[1];
    }
    double v29 = v27;
    goto LABEL_22;
  }
  return 0;
}

uint64_t sub_10001D964(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, char a5)
{
  if (*(_DWORD *)(a1 + 20) != *(_DWORD *)(a2 + 20)) {
    sub_100075C58();
  }
  uint64_t v10 = *(unsigned int *)(a3 + 20);
  sub_100004500(a4, 1, *(_DWORD *)(a3 + 20));
  uint64_t v11 = *(int *)(a1 + 20);
  unsigned int v28 = 0;
  int v12 = *(double **)(a3 + 8);
  double v13 = *(void **)(a4 + 8);
  uint64_t v14 = *(void *)(a2 + 8);
  unsigned int v15 = *(double **)(a1 + 8);
  double v16 = v15[v11 - 1];
  if (a5)
  {
    if ((int)v10 >= 1)
    {
      double v17 = *v15;
      double v18 = v15[1] - *v15;
      do
      {
        double v19 = *v12;
        unsigned int v20 = v11 - 2;
        if (*v12 < v16)
        {
          unsigned int v20 = ((v19 - v17) / v18);
          if (v20 + 1 < v11 && *(double *)(*(void *)(a1 + 8) + 8 * (v20 + 1)) <= v19) {
            ++v20;
          }
        }
        uint64_t v21 = (v11 - 1);
        if ((int)v11 - 1 > v20)
        {
          uint64_t v21 = v20 + 1;
          if (v19 - v15[v20] < v15[v21] - v19) {
            uint64_t v21 = v20;
          }
        }
        *v13++ = *(void *)(v14 + 8 * v21);
        ++v12;
        --v10;
      }
      while (v10);
    }
  }
  else if ((int)v10 >= 1)
  {
    int v22 = v11 - 2;
    uint64_t v23 = (v11 - 1);
    do
    {
      double v24 = *v12;
      if (*v12 >= v16)
      {
        unsigned int v28 = v22;
        unsigned int v25 = v22;
      }
      else
      {
        sub_10001D36C(a1, 0, (int *)&v28, *v12);
        unsigned int v25 = v28;
      }
      uint64_t v26 = v23;
      if (v23 > v25)
      {
        uint64_t v26 = v25 + 1;
        if (v24 - v15[v25] < v15[v26] - v24) {
          uint64_t v26 = v25;
        }
      }
      *v13++ = *(void *)(v14 + 8 * v26);
      ++v12;
      --v10;
    }
    while (v10);
  }
  return 0;
}

double sub_10001DB20@<D0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  int v4 = *(_DWORD *)(a2 + 20);
  if (v4 != *(_DWORD *)(a1 + 20) || (int v6 = *(_DWORD *)(a2 + 16), v6 != *(_DWORD *)(a1 + 16))) {
    sub_100075C84();
  }
  uint64_t v7 = sub_1000032CC(a3, v6, v4);
  int v9 = *(_DWORD *)(a1 + 20) * *(_DWORD *)(a1 + 16);
  if (v9 >= 1)
  {
    uint64_t v10 = *(double **)(a1 + 8);
    uint64_t v11 = &v10[v9];
    int v12 = *(double **)(v7 + 8);
    double v13 = *(double **)(a2 + 8);
    do
    {
      double v14 = *v10++;
      double v15 = v14;
      double v16 = *v13++;
      double result = v15 / v16;
      *v12++ = result;
    }
    while (v10 < v11);
  }
  return result;
}

uint64_t sub_10001DBA8(uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)a1 = a2;
  *(unsigned char *)(a1 + 24) = 0;
  *(void *)(a1 + 32) = 0xBFF0000000000000;
  if (a2)
  {
    int v3 = malloc_type_calloc(1uLL, 8uLL, 0x80040B8603338uLL);
    *(void *)(a1 + 16) = v3;
    if (v3) {
      **(void **)(a1 + 16) = objc_alloc_init((Class)BrightnessSystemClient);
    }
  }
  return a1;
}

void *sub_10001DC20(void *a1)
{
  if (a1[1])
  {
    sub_100063D5C();
    operator delete();
  }
  xpc_object_t v2 = (id *)a1[2];
  if (v2)
  {
    if (*v2)
    {
      [*v2 dealloc];
      xpc_object_t v2 = (id *)a1[2];
      *xpc_object_t v2 = 0;
    }
    free(v2);
    a1[2] = 0;
  }
  *a1 = 0;
  return a1;
}

uint64_t sub_10001DC9C(uint64_t a1)
{
  if (!*(void *)(a1 + 8)) {
    operator new();
  }
  return 3758097106;
}

void sub_10001DD28()
{
}

uint64_t sub_10001DD4C(uint64_t result)
{
  if (result)
  {
    CFStringRef v1 = (void *)result;
    if (!*(unsigned char *)(result + 24))
    {
      double result = *(void *)result;
      if (*v1)
      {
        double result = sub_10004C600(result);
        if (result)
        {
          double v2 = 0.0;
          double result = sub_10001DE48((uint64_t)v1, &v2);
          if (!result) {
            return sub_10001DDB8((uint64_t)v1, v2);
          }
        }
      }
    }
  }
  return result;
}

uint64_t sub_10001DDB8(uint64_t a1, double a2)
{
  uint64_t v3 = *(void *)a1;
  if (!v3) {
    return 3758097090;
  }
  if (*(double *)(a1 + 32) == a2) {
    return 0;
  }
  uint64_t result = sub_10004E4A4(v3, a2);
  if (result)
  {
    uint64_t v6 = *(void *)a1;
    return sub_10004E4A4(v6, a2);
  }
  else
  {
    *(double *)(a1 + 32) = a2;
  }
  return result;
}

uint64_t sub_10001DE48(uint64_t a1, double *a2)
{
  uint64_t v2 = 3758097088;
  if (*(void *)a1)
  {
    uint64_t v3 = **(void ***)(a1 + 16);
    if (v3)
    {
      if (a2)
      {
        id v5 = [v3 copyPropertyForKey:@"DisplayBrightness"];
        if (v5)
        {
          uint64_t v6 = v5;
          objc_opt_class();
          if (objc_opt_isKindOfClass())
          {
            [objc_msgSend(v6, "objectForKeyedSubscript:", @"NitsPhysical") floatValue];
            uint64_t v2 = 0;
            *a2 = v7;
          }
          else
          {
            uint64_t v2 = 3758097126;
          }
        }
        else
        {
          return 3758097102;
        }
      }
      else
      {
        return 3758097090;
      }
    }
    else
    {
      return 3758097112;
    }
  }
  return v2;
}

void sub_10001DF08(uint64_t a1, int a2)
{
  uint64_t v3 = *(void *)(a1 + 8);
  if (v3)
  {
    char v4 = a2;
    if (a2)
    {
      if (*(unsigned char *)(a1 + 24)) {
        return;
      }
    }
    else
    {
      if (!*(unsigned char *)(a1 + 24)) {
        return;
      }
      *(void *)(a1 + 32) = 0xBFF0000000000000;
    }
    sub_100063D6C(v3, a2);
    *(unsigned char *)(a1 + 24) = v4;
  }
}

void sub_10001DF5C(uint64_t a1, int a2, int a3, int a4, int a5, int a6)
{
  uint64_t v32 = a2;
  float v7 = (__int16 *)(a1 + 2 * a6 * a3 + 2 * a2);
  uint64_t v31 = a4;
  uint64_t v8 = a6;
  uint64_t v9 = 2 * a6;
  uint64_t v10 = 2 * a4 - 4;
  uint64_t v11 = 4;
  do
  {
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
    {
      int v12 = *v7;
      int v13 = v7[1];
      int v14 = v7[2];
      int v15 = v7[3];
      int v16 = *(__int16 *)((char *)v7 + v10 - 4);
      int v17 = *(__int16 *)((char *)v7 + v10 - 2);
      int v18 = *(__int16 *)((char *)v7 + v10);
      int v19 = *(__int16 *)((char *)v7 + v10 + 2);
      *(_DWORD *)buf = 67110912;
      int v36 = v12;
      __int16 v37 = 1024;
      int v38 = v13;
      __int16 v39 = 1024;
      int v40 = v14;
      __int16 v41 = 1024;
      int v42 = v15;
      __int16 v43 = 1024;
      int v44 = v16;
      __int16 v45 = 1024;
      int v46 = v17;
      __int16 v47 = 1024;
      int v48 = v18;
      __int16 v49 = 1024;
      int v50 = v19;
      _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "BlurM: [%6d %6d %6d %6d ... %6d %6d %6d %6d]\n", buf, 0x32u);
    }
    float v7 = (__int16 *)((char *)v7 + v9);
    --v11;
  }
  while (v11);
  if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "BlurM: [...... ...... ...... ...... ... ...... ...... ...... ......]\n", buf, 2u);
  }
  unsigned int v20 = (__int16 *)(a1 + 2 * (a3 + (uint64_t)a5 - 4) * v8 + 2 * v32);
  uint64_t v21 = 2 * v31 - 4;
  uint64_t v22 = 4;
  do
  {
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
    {
      int v23 = *v20;
      int v24 = v20[1];
      int v25 = v20[2];
      int v26 = v20[3];
      int v27 = *(__int16 *)((char *)v20 + v21 - 4);
      int v28 = *(__int16 *)((char *)v20 + v21 - 2);
      int v29 = *(__int16 *)((char *)v20 + v21);
      int v30 = *(__int16 *)((char *)v20 + v21 + 2);
      *(_DWORD *)buf = 67110912;
      int v36 = v23;
      __int16 v37 = 1024;
      int v38 = v24;
      __int16 v39 = 1024;
      int v40 = v25;
      __int16 v41 = 1024;
      int v42 = v26;
      __int16 v43 = 1024;
      int v44 = v27;
      __int16 v45 = 1024;
      int v46 = v28;
      __int16 v47 = 1024;
      int v48 = v29;
      __int16 v49 = 1024;
      int v50 = v30;
      _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "BlurM: [%6d %6d %6d %6d ... %6d %6d %6d %6d]\n", buf, 0x32u);
    }
    v20 += v8;
    --v22;
  }
  while (v22);
}

void sub_10001E200(uint64_t a1, int a2, int a3, int a4, int a5, int a6)
{
  uint64_t v8 = a6;
  uint64_t v30 = a2;
  uint64_t v9 = (unsigned __int8 *)(a1 + a6 * (uint64_t)a3 + a2);
  uint64_t v10 = a4 - 2;
  uint64_t v11 = 4;
  do
  {
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
    {
      int v12 = *v9;
      int v13 = v9[1];
      int v14 = v9[2];
      int v15 = v9[3];
      int v16 = v9[v10 - 2];
      int v17 = v9[v10 - 1];
      int v18 = v9[v10];
      int v19 = v9[v10 + 1];
      *(_DWORD *)buf = 67110912;
      int v33 = v12;
      __int16 v34 = 1024;
      int v35 = v13;
      __int16 v36 = 1024;
      int v37 = v14;
      __int16 v38 = 1024;
      int v39 = v15;
      __int16 v40 = 1024;
      int v41 = v16;
      __int16 v42 = 1024;
      int v43 = v17;
      __int16 v44 = 1024;
      int v45 = v18;
      __int16 v46 = 1024;
      int v47 = v19;
      _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "BlurM: [%3d %3d %3d %3d ... %3d %3d %3d %3d]\n", buf, 0x32u);
    }
    v9 += v8;
    --v11;
  }
  while (v11);
  if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "BlurM: [... ... ... ... ... ... ... ... ...]\n", buf, 2u);
  }
  unsigned int v20 = (unsigned __int8 *)(a1 + (a3 + (uint64_t)a5 - 4) * v8 + v30);
  uint64_t v21 = 4;
  do
  {
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
    {
      int v22 = *v20;
      int v23 = v20[1];
      int v24 = v20[2];
      int v25 = v20[3];
      int v26 = v20[v10 - 2];
      int v27 = v20[v10 - 1];
      int v28 = v20[v10];
      int v29 = v20[v10 + 1];
      *(_DWORD *)buf = 67110912;
      int v33 = v22;
      __int16 v34 = 1024;
      int v35 = v23;
      __int16 v36 = 1024;
      int v37 = v24;
      __int16 v38 = 1024;
      int v39 = v25;
      __int16 v40 = 1024;
      int v41 = v26;
      __int16 v42 = 1024;
      int v43 = v27;
      __int16 v44 = 1024;
      int v45 = v28;
      __int16 v46 = 1024;
      int v47 = v29;
      _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "BlurM: [%3d %3d %3d %3d ... %3d %3d %3d %3d]\n", buf, 0x32u);
    }
    v20 += v8;
    --v21;
  }
  while (v21);
}

void sub_10001E480(int16x8_t *a1, int a2, int a3, _WORD *a4, char a5)
{
  uint64_t v6 = a1;
  uint64_t v7 = (a3 * a2);
  if (a5)
  {
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
    {
      int v29 = 67109120;
      int v30 = v7;
      _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "BlurM: size_t length = %d\n", (uint8_t *)&v29, 8u);
    }
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v29) = 0;
      _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "BlurM: x = [\n", (uint8_t *)&v29, 2u);
    }
    sub_10001DF5C((uint64_t)v6, 0, 0, a2, a3, a2);
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v29) = 0;
      _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "BlurM: ];\n",
        (uint8_t *)&v29,
        2u);
    }
    unint64_t v15 = v7 & 0xFFFFFFF8;
    if ((int)v15 < 1)
    {
      int32x4_t v17 = 0uLL;
    }
    else
    {
      unint64_t v16 = 0;
      int32x4_t v17 = 0uLL;
      int v18 = v6;
      do
      {
        int16x8_t v19 = *v18++;
        int32x4_t v17 = vaddw_high_s16(vaddw_s16(v17, *(int16x4_t *)v19.i8), v19);
        v16 += 8;
      }
      while (v16 < v15);
    }
    float32x2_t v24 = vadd_f32(*(float32x2_t *)v17.i8, (float32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v17, (int8x16_t)v17, 8uLL));
    int v25 = (int)(float)(v24.f32[1] + (float)(int)v24.f32[0]);
    if ((int)v7 >= 1)
    {
      uint64_t v26 = v7;
      do
      {
        int v27 = v6->i16[0];
        uint64_t v6 = (int16x8_t *)((char *)v6 + 2);
        v25 += v27;
        --v26;
      }
      while (v26);
    }
    int v28 = v25 / (int)v7;
    *a4 = v25 / (int)v7;
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
    {
      int v29 = 67109120;
      int v30 = (__int16)v28;
      _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "BlurM: mean(x) = %d\n", (uint8_t *)&v29, 8u);
    }
  }
  else
  {
    unint64_t v8 = v7 & 0xFFFFFFF8;
    if ((int)v8 < 1)
    {
      int32x4_t v10 = 0uLL;
    }
    else
    {
      unint64_t v9 = 0;
      int32x4_t v10 = 0uLL;
      uint64_t v11 = a1;
      do
      {
        int16x8_t v12 = *v11++;
        int32x4_t v10 = vaddw_high_s16(vaddw_s16(v10, *(int16x4_t *)v12.i8), v12);
        v9 += 8;
      }
      while (v9 < v8);
    }
    float32x2_t v20 = vadd_f32(*(float32x2_t *)v10.i8, (float32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v10, (int8x16_t)v10, 8uLL));
    int v21 = (int)(float)(v20.f32[1] + (float)(int)v20.f32[0]);
    if ((int)v7 >= 1)
    {
      uint64_t v22 = (a3 * a2);
      do
      {
        int v23 = v6->i16[0];
        uint64_t v6 = (int16x8_t *)((char *)v6 + 2);
        v21 += v23;
        --v22;
      }
      while (v22);
    }
    *a4 = v21 / (int)v7;
  }
}

void sub_10001E720(void *__src, int a2, int a3, __int16 *a4, __int16 *a5, __int16 *a6, int16x8_t *__dst, char a8)
{
  uint64_t v16 = (a3 * a2);
  memcpy(__dst, __src, 2 * (int)v16);
  if (a8)
  {
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 67109120;
      int v39 = v16;
      _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "BlurM: size_t length = %d\n", buf, 8u);
    }
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
    {
      int v22 = *a4;
      *(_DWORD *)buf = 67109120;
      int v39 = v22;
      _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "BlurM: x_mean = %d\n", buf, 8u);
    }
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "BlurM: x = [\n", buf, 2u);
    }
    sub_10001DF5C((uint64_t)__src, 0, 0, a2, a3, a2);
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "BlurM: ];\n", buf, 2u);
    }
    unsigned int v23 = *a4;
    unint64_t v24 = v16 & 0xFFFFFFF8;
    if ((int)v24 < 1)
    {
      LODWORD(v25) = 0;
    }
    else
    {
      unint64_t v25 = 0;
      int16x8_t v26 = vdupq_n_s16(v23);
      int v27 = __dst;
      do
      {
        *int v27 = vabdq_s16(*v27, v26);
        ++v27;
        v25 += 8;
      }
      while (v25 < v24);
    }
    if ((int)v25 < (int)v16)
    {
      uint64_t v31 = v16 - v25;
      uint64_t v32 = &__dst->i16[v25];
      do
      {
        int v33 = *v32 - v23;
        if (v33 < 0) {
          LOWORD(v33) = v23 - *v32;
        }
        *v32++ = v33;
        --v31;
      }
      while (v31);
    }
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 67109120;
      int v39 = v16;
      _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "BlurM: size_t length = %d\n", buf, 8u);
    }
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "BlurM: abs(x-mean(x)) = [\n", buf, 2u);
    }
    sub_10001DF5C((uint64_t)__dst, 0, 0, a2, a3, a2);
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "BlurM: ];\n", buf, 2u);
    }
  }
  else
  {
    unsigned int v17 = *a4;
    unint64_t v18 = v16 & 0xFFFFFFF8;
    if ((int)v18 < 1)
    {
      LODWORD(v19) = 0;
    }
    else
    {
      unint64_t v19 = 0;
      int16x8_t v20 = vdupq_n_s16(v17);
      int v21 = __dst;
      do
      {
        *int v21 = vabdq_s16(*v21, v20);
        ++v21;
        v19 += 8;
      }
      while (v19 < v18);
    }
    if ((int)v19 < (int)v16)
    {
      uint64_t v28 = v16 - v19;
      int v29 = &__dst->i16[v19];
      do
      {
        int v30 = *v29 - v17;
        if (v30 < 0) {
          LOWORD(v30) = v17 - *v29;
        }
        *v29++ = v30;
        --v28;
      }
      while (v28);
    }
  }
  __int16 v37 = 0;
  sub_10001E480(__dst, a2, a3, &v37, a8);
  int v34 = v37;
  *a5 = v37;
  *a6 = (5 * v34) >> 2;
  if (a8)
  {
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 67109120;
      int v39 = v34;
      _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "BlurM: x_tmp_mean = %d\n", buf, 8u);
    }
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
    {
      int v35 = *a5;
      *(_DWORD *)buf = 67109120;
      int v39 = v35;
      _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "BlurM: x_mad_mean = %d\n", buf, 8u);
    }
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
    {
      int v36 = *a6;
      *(_DWORD *)buf = 67109120;
      int v39 = v36;
      _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "BlurM: x_mad_sigma = %d\n", buf, 8u);
    }
  }
}

void sub_10001EBCC(uint64_t a1, int a2, int a3, __int16 *a4, __int16 *a5, __int16 *a6, __int16 *a7, uint64_t a8, char a9)
{
  uint64_t v11 = (a3 * a2);
  __int16 v12 = *a4 + (*a7 >> *a5);
  *a6 = v12;
  if (a9)
  {
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
    {
      int v46 = 67109120;
      int v47 = v11;
      _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "BlurM: size_t length = %d\n", (uint8_t *)&v46, 8u);
    }
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
    {
      int v25 = *a4;
      int v46 = 67109120;
      int v47 = v25;
      _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "BlurM: x_median = %d\n", (uint8_t *)&v46, 8u);
    }
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
    {
      int v26 = *a5;
      int v46 = 67109120;
      int v47 = v26;
      _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "BlurM: noise_factor = %d\n", (uint8_t *)&v46, 8u);
    }
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
    {
      int v27 = *a7;
      int v46 = 67109120;
      int v47 = v27;
      _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "BlurM: x_sigma = %d\n", (uint8_t *)&v46, 8u);
    }
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
    {
      int v28 = *a6;
      int v46 = 67109120;
      int v47 = v28;
      _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "BlurM: sft_thr = %d\n", (uint8_t *)&v46, 8u);
    }
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v46) = 0;
      _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "BlurM: x = [\n", (uint8_t *)&v46, 2u);
    }
    sub_10001DF5C(a1, 0, 0, a2, a3, a2);
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v46) = 0;
      _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "BlurM: ];\n",
        (uint8_t *)&v46,
        2u);
    }
    signed int v29 = *a6;
    unint64_t v30 = v11 & 0xFFFFFFF8;
    if ((int)v30 < 1)
    {
      LODWORD(v31) = 0;
    }
    else
    {
      unint64_t v31 = 0;
      int16x8_t v32 = vdupq_n_s16(v29);
      int v33 = (int16x8_t *)a1;
      int v34 = (int8x16_t *)a8;
      do
      {
        int16x8_t v35 = *v33++;
        *v34++ = vandq_s8((int8x16_t)vsubq_s16(v35, v32), (int8x16_t)vcgtq_s16(v35, v32));
        v31 += 8;
      }
      while (v31 < v30);
    }
    if ((int)v31 < (int)v11)
    {
      uint64_t v41 = v11 - v31;
      __int16 v42 = (_WORD *)(a8 + 2 * v31);
      int v43 = (__int16 *)(a1 + 2 * v31);
      do
      {
        int v44 = *v43++;
        __int16 v45 = v44 - v29;
        if (v44 <= v29) {
          __int16 v45 = 0;
        }
        *v42++ = v45;
        --v41;
      }
      while (v41);
    }
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
    {
      int v46 = 67109120;
      int v47 = v11;
      _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "BlurM: size_t length = %d\n", (uint8_t *)&v46, 8u);
    }
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v46) = 0;
      _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "BlurM: x_th = [\n", (uint8_t *)&v46, 2u);
    }
    sub_10001DF5C(a8, 0, 0, a2, a3, a2);
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v46) = 0;
      _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "BlurM: ];\n",
        (uint8_t *)&v46,
        2u);
    }
  }
  else
  {
    unint64_t v13 = v11 & 0xFFFFFFF8;
    if ((int)v13 < 1)
    {
      LODWORD(v14) = 0;
    }
    else
    {
      unint64_t v14 = 0;
      int16x8_t v15 = vdupq_n_s16(v12);
      uint64_t v16 = (int16x8_t *)a1;
      unsigned int v17 = (int8x16_t *)a8;
      do
      {
        int16x8_t v18 = *v16++;
        *v17++ = vandq_s8((int8x16_t)vsubq_s16(v18, v15), (int8x16_t)vcgtq_s16(v18, v15));
        v14 += 8;
      }
      while (v14 < v13);
    }
    if ((int)v14 < (int)v11)
    {
      uint64_t v36 = v11 - v14;
      __int16 v37 = (_WORD *)(a8 + 2 * v14);
      __int16 v38 = (__int16 *)(a1 + 2 * v14);
      do
      {
        int v39 = *v38++;
        __int16 v40 = v39 - v12;
        if (v39 <= v12) {
          __int16 v40 = 0;
        }
        *v37++ = v40;
        --v36;
      }
      while (v36);
    }
  }
}

void sub_10001F068(uint64_t a1, int a2, int a3, int *a4, uint64_t a5, int a6, const __int16 *a7, char a8)
{
  uint64_t v11 = *a4;
  if (a3 - (int)v11 + 1 >= 0)
  {
    uint64_t v12 = 0;
    uint64_t v13 = 0;
    uint64_t v14 = (v11 * v11);
    unint64_t v15 = v14 & 0x7FFFFFF8;
    uint64_t v16 = a2 - (int)v11 + 1;
    uint64_t v17 = a6;
    uint64_t v18 = 2 * v11;
    do
    {
      uint64_t v19 = v13 + v11;
      if ((v16 & 0x80000000) == 0)
      {
        uint64_t v20 = 0;
        uint64_t v21 = 0;
        uint64_t v22 = a1;
        do
        {
          if ((int)v11 >= 1)
          {
            unsigned int v23 = a7;
            uint64_t v24 = v22;
            uint64_t v25 = v13;
            do
            {
              uint64_t v26 = 0;
              do
              {
                v23[v26] = *(_WORD *)(v24 + 2 * v26);
                ++v26;
              }
              while (v21 + v26 < v21 + v11);
              ++v25;
              v24 += 2 * a2;
              unsigned int v23 = (const __int16 *)((char *)v23 + v18);
            }
            while (v25 < v19);
          }
          int16x8_t v27 = vld1q_dup_s16(a7);
          if (v15)
          {
            unint64_t v28 = 0;
            signed int v29 = (int16x8_t *)a7;
            do
            {
              int16x8_t v30 = *v29++;
              int16x8_t v27 = vmaxq_s16(v30, v27);
              v28 += 8;
            }
            while (v28 < v15);
            unsigned int v31 = ((v15 - 1) & 0xFFFFFFF8) + 8;
          }
          else
          {
            unsigned int v31 = 0;
          }
          __int16 v32 = vmaxv_s16(vmax_s16(*(int16x4_t *)v27.i8, (int16x4_t)*(_OWORD *)&vextq_s8((int8x16_t)v27, (int8x16_t)v27, 8uLL)));
          if ((int)v31 < (int)v14)
          {
            uint64_t v33 = v14 - v31;
            int v34 = &a7[v31];
            do
            {
              int v36 = *v34++;
              __int16 v35 = v36;
              if (v32 <= v36) {
                __int16 v32 = v35;
              }
              --v33;
            }
            while (v33);
          }
          *(_WORD *)(a5 + 2 * (v20 + v12 * v17)) = v32;
          ++v20;
          v21 += v11;
          v22 += v18;
        }
        while (v21 <= v16);
      }
      ++v12;
      a1 += 2 * (int)v11 * (uint64_t)a2;
      v13 += v11;
    }
    while (v19 <= (a3 - v11 + 1));
  }
  if (a8)
  {
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "BlurM: xmax = [\n", buf, 2u);
    }
    if (a2 >= 0) {
      int v37 = a2;
    }
    else {
      int v37 = a2 + 1;
    }
    int v38 = v37 >> 1;
    if (a3 >= 0) {
      int v39 = a3;
    }
    else {
      int v39 = a3 + 1;
    }
    sub_10001DF5C(a5, 0, 0, v38, v39 >> 1, v38);
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
    {
      v40[0] = 0;
      _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "BlurM: ];\n",
        (uint8_t *)v40,
        2u);
    }
  }
}

void sub_10001F2AC(int16x8_t *a1, int a2, int a3, float *a4, char a5)
{
  uint64_t v5 = (a3 * a2);
  unint64_t v6 = v5 & 0xFFFFFFF8;
  if ((int)v6 < 1)
  {
    LODWORD(v7) = 0;
    int32x4_t v11 = 0uLL;
    int32x4_t v10 = 0uLL;
  }
  else
  {
    unint64_t v7 = 0;
    v8.i64[0] = 0x1000100010001;
    v8.i64[1] = 0x1000100010001;
    unint64_t v9 = a1;
    int32x4_t v10 = 0uLL;
    int32x4_t v11 = 0uLL;
    do
    {
      int16x8_t v12 = *v9++;
      uint16x8_t v13 = (uint16x8_t)vmaxq_s16(v12, (int16x8_t)0);
      uint16x8_t v14 = (uint16x8_t)vandq_s8((int8x16_t)vcgtzq_s16(v12), v8);
      int32x4_t v10 = (int32x4_t)vaddw_high_u16(vaddw_u16((uint32x4_t)v10, *(uint16x4_t *)v13.i8), v13);
      int32x4_t v11 = (int32x4_t)vaddw_high_u16(vaddw_u16((uint32x4_t)v11, *(uint16x4_t *)v14.i8), v14);
      v7 += 8;
    }
    while (v7 < v6);
  }
  int v15 = vaddvq_s32(v10);
  int v16 = vaddvq_s32(v11);
  if ((int)v7 < (int)v5)
  {
    uint64_t v17 = v5 - v7;
    uint64_t v18 = &a1->i16[v7];
    do
    {
      int v20 = *v18++;
      int v19 = v20;
      if (v20 > 0) {
        ++v16;
      }
      v15 += v19 & ~(v19 >> 31);
      --v17;
    }
    while (v17);
  }
  float v21 = (float)((float)v15 * 0.0625) / (float)v16;
  *a4 = v21;
  if ((a5 & 1) != 0 && os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
  {
    int v22 = 134217984;
    double v23 = v21;
    _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "BlurM: sharpness = %f\n", (uint8_t *)&v22, 0xCu);
  }
}

float32x2_t sub_10001F40C(int16x8_t *a1, int16x8_t *a2, int a3, int a4, float *a5, float *a6, float *a7, char a8)
{
  uint64_t v10 = (a4 * a3);
  signed int v11 = (int)*a5;
  unint64_t v12 = v10 & 0xFFFFFFF8;
  if ((int)v12 < 1)
  {
    LODWORD(v13) = 0;
    int16x8_t v21 = 0uLL;
    int16x8_t v20 = 0uLL;
    int16x8_t v19 = 0uLL;
    int16x8_t v15 = 0uLL;
  }
  else
  {
    unint64_t v13 = 0;
    int16x8_t v14 = vdupq_n_s16(v11);
    int16x8_t v15 = 0uLL;
    v16.i64[0] = 0x2000200020002;
    v16.i64[1] = 0x2000200020002;
    uint64_t v17 = a1;
    uint64_t v18 = a2;
    int16x8_t v19 = 0uLL;
    int16x8_t v20 = 0uLL;
    int16x8_t v21 = 0uLL;
    do
    {
      int16x8_t v22 = *v17++;
      int16x8_t v23 = v22;
      int16x8_t v24 = *v18++;
      int16x8_t v25 = vshrq_n_s16(v23, 4uLL);
      int16x8_t v26 = vshrq_n_s16(v24, 4uLL);
      int16x8_t v27 = vcgtq_s16(vmaxq_s16(v25, v26), v14);
      int16x8_t v15 = vsubq_s16(v15, v27);
      int16x8_t v19 = vsubq_s16(v19, (int16x8_t)vandq_s8((int8x16_t)v27, (int8x16_t)vcgtq_s16(v25, v26)));
      int16x8_t v28 = (int16x8_t)vandq_s8((int8x16_t)v27, vandq_s8((int8x16_t)vcgtq_s16(v26, v25), v16));
      int16x8_t v20 = vaddq_s16(v28, v20);
      int16x8_t v21 = vaddq_s16((int16x8_t)vandq_s8((int8x16_t)v28, (int8x16_t)vcgtq_s16(v14, v25)), v21);
      v13 += 8;
    }
    while (v13 < v12);
  }
  int8x16_t v29 = (int8x16_t)vmovl_u16((uint16x4_t)vadd_s16(*(int16x4_t *)v15.i8, (int16x4_t)*(_OWORD *)&vextq_s8((int8x16_t)v15, (int8x16_t)v15, 8uLL)));
  int8x16_t v30 = (int8x16_t)vmovl_u16((uint16x4_t)vadd_s16(*(int16x4_t *)v19.i8, (int16x4_t)*(_OWORD *)&vextq_s8((int8x16_t)v19, (int8x16_t)v19, 8uLL)));
  int32x2_t v31 = (int32x2_t)vand_s8((int8x8_t)vzip1_s32(*(int32x2_t *)v30.i8, *(int32x2_t *)v29.i8), (int8x8_t)0xFFFF0000FFFFLL);
  int32x2_t v32 = (int32x2_t)vand_s8((int8x8_t)vzip2_s32(*(int32x2_t *)v30.i8, *(int32x2_t *)v29.i8), (int8x8_t)0xFFFF0000FFFFLL);
  v29.i64[0] = vextq_s8(v29, v29, 8uLL).u64[0];
  v30.i64[0] = vextq_s8(v30, v30, 8uLL).u64[0];
  int32x2_t v33 = vadd_s32(vadd_s32(vadd_s32(v32, v31), (int32x2_t)vand_s8((int8x8_t)vzip1_s32(*(int32x2_t *)v30.i8, *(int32x2_t *)v29.i8), (int8x8_t)0xFFFF0000FFFFLL)), (int32x2_t)vand_s8((int8x8_t)vzip2_s32(*(int32x2_t *)v30.i8, *(int32x2_t *)v29.i8), (int8x8_t)0xFFFF0000FFFFLL));
  int v34 = vaddvq_s32((int32x4_t)vmovl_u16((uint16x4_t)vadd_s16(*(int16x4_t *)v20.i8, (int16x4_t)*(_OWORD *)&vextq_s8((int8x16_t)v20, (int8x16_t)v20, 8uLL))));
  int v35 = vaddvq_s32((int32x4_t)vmovl_u16((uint16x4_t)vadd_s16(*(int16x4_t *)v21.i8, (int16x4_t)*(_OWORD *)&vextq_s8((int8x16_t)v21, (int8x16_t)v21, 8uLL))));
  if ((int)v13 < (int)v10)
  {
    float v36 = (float)v11;
    uint64_t v37 = v10 - v13;
    int v38 = &a2->i16[v13];
    int v39 = &a1->i16[v13];
    do
    {
      int v40 = *v39++;
      float v41 = (float)(v40 >> 4);
      int v42 = *v38++;
      int v43 = v42 >> 4;
      float v44 = (float)(v42 >> 4);
      if (v44 <= v41) {
        float v45 = v41;
      }
      else {
        float v45 = (float)v43;
      }
      if (v45 > v36)
      {
        int32x2_t v33 = vadd_s32(v33, (int32x2_t)((v41 > v44) | 0x100000000));
        if (v44 > v41)
        {
          v34 += 2;
          if (v41 < v36) {
            v35 += 2;
          }
        }
      }
      --v37;
    }
    while (v37);
  }
  __int32 v46 = v33.i32[1];
  if (v33.i32[1])
  {
    float32x2_t v47 = vcvt_f32_s32(v33);
    float32x2_t result = vdiv_f32(v47, (float32x2_t)vdup_lane_s32((int32x2_t)v47, 1));
  }
  else
  {
    float32x2_t result = 0;
  }
  *a6 = result.f32[0];
  if (v34) {
    result.f32[0] = (float)v35 / (float)v34;
  }
  else {
    result.i32[0] = 1.0;
  }
  *a7 = result.f32[0];
  if (a8)
  {
    __int32 v52 = v33.i32[0];
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 67109120;
      *(_DWORD *)&uint8_t buf[4] = v46;
      _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "BlurM: Nedge      = %d\n", buf, 8u);
    }
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(v49) = 67109120;
      HIDWORD(v49) = v52;
      *(void *)buf = v49;
      _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "BlurM: Nda        = %d\n", buf, 8u);
    }
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 67109120;
      *(_DWORD *)&uint8_t buf[4] = v34;
      _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "BlurM: Nrg        = %d\n", buf, 8u);
    }
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 67109120;
      *(_DWORD *)&uint8_t buf[4] = v35;
      _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "BlurM: Nbrg       = %d\n", buf, 8u);
    }
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
    {
      double v50 = *a6;
      *(_DWORD *)buf = 134217984;
      *(double *)&uint8_t buf[4] = v50;
      _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "BlurM: blurConf   = %f\n", buf, 0xCu);
    }
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
    {
      double v51 = *a7;
      *(_DWORD *)buf = 134217984;
      *(double *)&uint8_t buf[4] = v51;
      _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "BlurM: blurExtent = %f\n", buf, 0xCu);
    }
  }
  return result;
}

void sub_10001F814(int16x8_t *a1, int16x8_t *a2, int16x8_t *a3, int a4, int a5, uint64_t a6, char a7)
{
  uint64_t v10 = (a5 * a4);
  unint64_t v11 = v10 & 0xFFFFFFF8;
  if ((int)v11 < 1)
  {
    LODWORD(v12) = 0;
  }
  else
  {
    unint64_t v12 = 0;
    unint64_t v13 = a1;
    int16x8_t v14 = a2;
    int16x8_t v15 = a3;
    int8x16_t v16 = (int16x8_t *)a6;
    do
    {
      int16x8_t v17 = *v13++;
      int16x8_t v18 = v17;
      int16x8_t v19 = *v14++;
      int16x8_t v20 = v19;
      int16x8_t v21 = *v15++;
      int16x8_t v22 = v21;
      int32x4_t v23 = vmull_s16(*(int16x4_t *)v20.i8, *(int16x4_t *)v20.i8);
      int32x4_t v24 = vmlal_high_s16(vmlal_high_s16(vmull_high_s16(v20, v20), v18, v18), v22, v22);
      float32x4_t v25 = vcvtq_f32_s32(vmlal_s16(vmlal_s16(v23, *(int16x4_t *)v18.i8, *(int16x4_t *)v18.i8), *(int16x4_t *)v22.i8, *(int16x4_t *)v22.i8));
      float32x4_t v26 = vrsqrteq_f32(v25);
      float32x4_t v27 = vcvtq_f32_s32(v24);
      float32x4_t v28 = vmulq_f32(vmulq_f32(v26, vrsqrtsq_f32(vmulq_f32(v26, v25), v26)), v25);
      float32x4_t v29 = vrsqrteq_f32(v27);
      *v16++ = vuzp1q_s16((int16x8_t)vcvtq_s32_f32(v28), (int16x8_t)vcvtq_s32_f32(vmulq_f32(vmulq_f32(v29, vrsqrtsq_f32(vmulq_f32(v29, v27), v29)), v27)));
      v12 += 8;
    }
    while (v12 < v11);
  }
  if ((int)v12 < (int)v10)
  {
    uint64_t v30 = v10 - v12;
    int32x2_t v31 = (_WORD *)(a6 + 2 * v12);
    int32x2_t v32 = &a3->i16[v12];
    int32x2_t v33 = &a2->i16[v12];
    int v34 = &a1->i16[v12];
    do
    {
      int v35 = *v34++;
      int v36 = v35 * v35;
      int v37 = *v33++;
      int v38 = v36 + v37 * v37;
      int v39 = *v32++;
      *v31++ = (int)sqrt((double)(v38 + v39 * v39));
      --v30;
    }
    while (v30);
  }
  if (a7)
  {
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v40) = 0;
      _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "BlurM: calcEmap\n", (uint8_t *)&v40, 2u);
    }
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
    {
      int v40 = 67109120;
      int v41 = a5;
      _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "BlurM: height=%d\n", (uint8_t *)&v40, 8u);
    }
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
    {
      int v40 = 67109120;
      int v41 = a4;
      _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "BlurM: width=%d\n", (uint8_t *)&v40, 8u);
    }
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v40) = 0;
      _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "BlurM: emap = [\n", (uint8_t *)&v40, 2u);
    }
    sub_10001DF5C(a6, 0, 0, a4, a5, a4);
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v40) = 0;
      _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "BlurM: ];\n",
        (uint8_t *)&v40,
        2u);
    }
  }
}

void sub_10001FAD4(uint64_t a1, int a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, int16x8_t *__src, int16x8_t *a9, char a10)
{
  uint64_t v10 = __src;
  int16x8_t v15 = a9;
  if (a10)
  {
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "BlurM: hlwt2\n", buf, 2u);
    }
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 67109120;
      int v128 = a3;
      _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "BlurM: height=%d\n", buf, 8u);
    }
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 67109120;
      int v128 = a2;
      _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "BlurM: width=%d\n", buf, 8u);
    }
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "BlurM: img_data = [\n", buf, 2u);
    }
    sub_10001DF5C(a1, 0, 0, a2, a3, a2);
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "BlurM: ];\n", buf, 2u);
    }
    if (a3 >= 1)
    {
      uint64_t v24 = 0;
      uint64_t v25 = (int)(a2 & 0xFFFFFFF8);
      uint64_t v26 = 2 * (a2 >> 1);
      float32x4_t v27 = v10;
      uint64_t v28 = (uint64_t)a9;
      do
      {
        if ((int)v25 < 1)
        {
          uint64_t v29 = 0;
        }
        else
        {
          uint64_t v29 = 0;
          uint64_t v30 = (const __int16 *)a1;
          do
          {
            int16x4x2_t v130 = vld2_s16(v30);
            v30 += 8;
            *(uint64_t *)((char *)v27->i64 + v29) = (uint64_t)v130.val[0];
            *(int16x4_t *)(v28 + v29) = v130.val[1];
            v29 += 8;
          }
          while (v29 < v25);
          uint64_t v29 = v29;
        }
        if ((int)v29 < a2)
        {
          do
          {
            if (v29) {
              uint64_t v31 = (uint64_t)a9;
            }
            else {
              uint64_t v31 = (uint64_t)v10;
            }
            *(_WORD *)(v31 + 2 * (int)((int)v24 * a2 / 2 + (v29 >> 1))) = *(_WORD *)(a1 + 2 * v29);
            ++v29;
          }
          while (a2 != v29);
        }
        ++v24;
        v28 += v26;
        float32x4_t v27 = (int16x8_t *)((char *)v27 + v26);
        a1 += 2 * a2;
      }
      while (v24 != a3);
    }
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "BlurM: Splitting\n", buf, 2u);
    }
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 67109120;
      int v128 = 0;
      _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "BlurM: h_cnt_split = %d\n", buf, 8u);
    }
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "BlurM: L = [\n", buf, 2u);
    }
    if (a2 >= 0) {
      int v32 = a2;
    }
    else {
      int v32 = a2 + 1;
    }
    sub_10001DF5C((uint64_t)v10, 0, 0, v32 >> 1, a3, v32 >> 1);
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "BlurM: ];\n", buf, 2u);
    }
  }
  else
  {
    if (a3 < 1) {
      goto LABEL_60;
    }
    uint64_t v16 = 0;
    uint64_t v17 = (int)(a2 & 0xFFFFFFF8);
    uint64_t v18 = 2 * (a2 >> 1);
    int16x8_t v19 = __src;
    uint64_t v20 = (uint64_t)a9;
    do
    {
      if ((int)v17 < 1)
      {
        uint64_t v21 = 0;
      }
      else
      {
        uint64_t v21 = 0;
        int16x8_t v22 = (const __int16 *)a1;
        do
        {
          int16x4x2_t v129 = vld2_s16(v22);
          v22 += 8;
          *(uint64_t *)((char *)v19->i64 + v21) = (uint64_t)v129.val[0];
          *(int16x4_t *)(v20 + v21) = v129.val[1];
          v21 += 8;
        }
        while (v21 < v17);
        uint64_t v21 = v21;
      }
      if ((int)v21 < a2)
      {
        do
        {
          if (v21) {
            int32x4_t v23 = a9;
          }
          else {
            int32x4_t v23 = __src;
          }
          v23->i16[(int)v16 * a2 / 2 + (v21 >> 1)] = *(_WORD *)(a1 + 2 * v21);
          ++v21;
        }
        while (a2 != v21);
      }
      ++v16;
      v20 += v18;
      int16x8_t v19 = (int16x8_t *)((char *)v19 + v18);
      a1 += 2 * a2;
    }
    while (v16 != a3);
  }
  if (a10)
  {
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 67109120;
      int v128 = 0;
      _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "BlurM: h_cnt_split = %d\n", buf, 8u);
    }
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "BlurM: H = [\n", buf, 2u);
    }
    if (a2 >= 0) {
      int v33 = a2;
    }
    else {
      int v33 = a2 + 1;
    }
    sub_10001DF5C((uint64_t)a9, 0, 0, v33 >> 1, a3, v33 >> 1);
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "BlurM: ];\n", buf, 2u);
    }
  }
LABEL_60:
  if (a2 >= 0) {
    int v34 = a2;
  }
  else {
    int v34 = a2 + 1;
  }
  int v35 = v34 >> 1;
  uint64_t v36 = ((v34 >> 1) * a3);
  unint64_t v37 = v36 & 0xFFFFFFF8;
  if ((int)v37 < 1)
  {
    LODWORD(v38) = 0;
  }
  else
  {
    unint64_t v38 = 0;
    int v39 = a9;
    int v40 = v10;
    do
    {
      int16x8_t v41 = *v40++;
      *int v39 = vsubq_s16(*v39, v41);
      ++v39;
      v38 += 8;
    }
    while (v38 < v37);
  }
  if ((int)v38 < (int)v36)
  {
    uint64_t v42 = v36 - v38;
    int v43 = &v10->i8[2 * v38];
    float v44 = &a9->i16[v38];
    do
    {
      __int16 v45 = *(_WORD *)v43;
      v43 += 2;
      *v44++ -= v45;
      --v42;
    }
    while (v42);
  }
  if (a10)
  {
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "BlurM: Lifting\n", buf, 2u);
    }
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 67109120;
      int v128 = 0;
      _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "BlurM: h_cnt_split = %d\n", buf, 8u);
    }
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "BlurM: H = [\n", buf, 2u);
    }
    sub_10001DF5C((uint64_t)a9, 0, 0, v35, a3, v35);
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "BlurM: ];\n", buf, 2u);
    }
    if ((int)v37 < 1)
    {
      LODWORD(v50) = 0;
    }
    else
    {
      unint64_t v50 = 0;
      double v51 = a9;
      __int32 v52 = v10;
      do
      {
        int16x8_t v53 = vshrq_n_s16(*v51, 1uLL);
        *__int32 v52 = vsraq_n_s16(*v52, *v51, 1uLL);
        ++v52;
        *v51++ = v53;
        v50 += 8;
      }
      while (v50 < v37);
    }
    if ((int)v50 < (int)v36)
    {
      uint64_t v58 = v36 - v50;
      int v59 = &v10->i8[2 * v50];
      int v60 = &a9->i16[v50];
      do
      {
        int v61 = *v60;
        *v60++ >>= 1;
        *(_WORD *)v59 += v61 >> 1;
        v59 += 2;
        --v58;
      }
      while (v58);
    }
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 67109120;
      int v128 = 0;
      _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "BlurM: h_cnt_split = %d\n", buf, 8u);
    }
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "BlurM: L = [\n", buf, 2u);
    }
    sub_10001DF5C((uint64_t)v10, 0, 0, v35, a3, v35);
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "BlurM: ];\n", buf, 2u);
    }
  }
  else
  {
    if ((int)v37 < 1)
    {
      LODWORD(v46) = 0;
    }
    else
    {
      unint64_t v46 = 0;
      float32x2_t v47 = a9;
      int v48 = v10;
      do
      {
        int16x8_t v49 = vshrq_n_s16(*v47, 1uLL);
        *int v48 = vsraq_n_s16(*v48, *v47, 1uLL);
        ++v48;
        *v47++ = v49;
        v46 += 8;
      }
      while (v46 < v37);
    }
    if ((int)v46 < (int)v36)
    {
      uint64_t v54 = v36 - v46;
      uint64_t v55 = &v10->i8[2 * v46];
      int v56 = &a9->i16[v46];
      do
      {
        int v57 = *v56;
        *v56++ >>= 1;
        *(_WORD *)v55 += v57 >> 1;
        v55 += 2;
        --v54;
      }
      while (v54);
    }
  }
  if (a3 < 1)
  {
    int v65 = a3;
    int v64 = 0;
    int v63 = 0;
  }
  else
  {
    uint64_t v62 = 0;
    int v63 = 0;
    int v64 = 0;
    int v65 = a3;
    do
    {
      if (v62)
      {
        memcpy((void *)(a5 + 2 * v63 * v35), v10, 2 * v35);
        ++v63;
      }
      else
      {
        memcpy((void *)(a4 + 2 * v64 * v35), v10, 2 * v35);
        ++v64;
      }
      ++v62;
      uint64_t v10 = (int16x8_t *)((char *)v10 + 2 * v35);
    }
    while (a3 != v62);
  }
  if (a10)
  {
    int v66 = v65;
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "BlurM: Splitting\n", buf, 2u);
    }
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 67109120;
      int v128 = v64;
      _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "BlurM: v_cnt_split = %d\n", buf, 8u);
    }
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "BlurM: a = [\n", buf, 2u);
    }
    if (v65 >= 0) {
      int v69 = v65;
    }
    else {
      int v69 = v65 + 1;
    }
    int v68 = v69 >> 1;
    sub_10001DF5C(a4, 0, 0, v35, v69 >> 1, v35);
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "BlurM: ];\n", buf, 2u);
    }
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 67109120;
      int v128 = v63;
      _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "BlurM: v_cnt_split = %d\n", buf, 8u);
    }
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "BlurM: h = [\n", buf, 2u);
    }
    sub_10001DF5C(a5, 0, 0, v35, v68, v35);
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "BlurM: ];\n", buf, 2u);
    }
  }
  else
  {
    int v63 = 0;
    int v66 = v65;
    if (v65 >= 0) {
      int v67 = v65;
    }
    else {
      int v67 = v65 + 1;
    }
    int v68 = v67 >> 1;
  }
  uint64_t v70 = (v68 * v35);
  unint64_t v71 = v70 & 0xFFFFFFF8;
  if ((int)v71 < 1)
  {
    LODWORD(v72) = 0;
  }
  else
  {
    unint64_t v72 = 0;
    BOOL v73 = (int16x8_t *)a5;
    BOOL v74 = (int16x8_t *)a4;
    do
    {
      int16x8_t v75 = *v74++;
      *BOOL v73 = vsubq_s16(*v73, v75);
      ++v73;
      v72 += 8;
    }
    while (v72 < v71);
  }
  if ((int)v72 < (int)v70)
  {
    uint64_t v76 = v70 - v72;
    unsigned int v77 = (__int16 *)(a4 + 2 * v72);
    char v78 = (_WORD *)(a5 + 2 * v72);
    do
    {
      __int16 v79 = *v77++;
      *v78++ -= v79;
      --v76;
    }
    while (v76);
  }
  if (a10)
  {
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "BlurM: Lifting\n", buf, 2u);
    }
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 67109120;
      int v128 = v63;
      _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "BlurM: v_cnt_split = %d\n", buf, 8u);
    }
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 67109120;
      int v128 = 0;
      _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "BlurM: h_cnt_split = %d\n", buf, 8u);
    }
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "BlurM: h = [\n", buf, 2u);
    }
    sub_10001DF5C(a5, 0, 0, v35, v68, v35);
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "BlurM: ];\n", buf, 2u);
    }
    if ((int)v71 < 1)
    {
      LODWORD(v84) = 0;
    }
    else
    {
      unint64_t v84 = 0;
      float v85 = (int16x8_t *)a4;
      uint64_t v86 = (int16x8_t *)a5;
      do
      {
        int16x8_t v87 = *v86++;
        *float v85 = vaddq_s16(vaddq_s16(*v85, *v85), v87);
        ++v85;
        v84 += 8;
      }
      while (v84 < v71);
    }
    if ((int)v84 < (int)v70)
    {
      uint64_t v92 = v70 - v84;
      uint64_t v93 = (__int16 *)(a5 + 2 * v84);
      int v94 = (_WORD *)(a4 + 2 * v84);
      do
      {
        __int16 v95 = *v93++;
        *int v94 = v95 + 2 * *v94;
        ++v94;
        --v92;
      }
      while (v92);
    }
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 67109120;
      int v128 = v63;
      _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "BlurM: v_cnt_split = %d\n", buf, 8u);
    }
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 67109120;
      int v128 = 0;
      _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "BlurM: h_cnt_split = %d\n", buf, 8u);
    }
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "BlurM: a = [\n", buf, 2u);
    }
    sub_10001DF5C(a4, 0, 0, v35, v68, v35);
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "BlurM: ];\n", buf, 2u);
    }
  }
  else
  {
    if ((int)v71 < 1)
    {
      LODWORD(v80) = 0;
    }
    else
    {
      unint64_t v80 = 0;
      int v81 = (int16x8_t *)a4;
      int v82 = (int16x8_t *)a5;
      do
      {
        int16x8_t v83 = *v82++;
        *int v81 = vaddq_s16(vaddq_s16(*v81, *v81), v83);
        ++v81;
        v80 += 8;
      }
      while (v80 < v71);
    }
    if ((int)v80 < (int)v70)
    {
      uint64_t v88 = v70 - v80;
      long long v89 = (__int16 *)(a5 + 2 * v80);
      uint64_t v90 = (_WORD *)(a4 + 2 * v80);
      do
      {
        __int16 v91 = *v89++;
        *uint64_t v90 = v91 + 2 * *v90;
        ++v90;
        --v88;
      }
      while (v88);
    }
  }
  uint64_t v124 = (v68 * v35);
  if (v66 < 1)
  {
    int v98 = 0;
    int v97 = 0;
  }
  else
  {
    uint64_t v96 = 0;
    int v97 = 0;
    int v98 = 0;
    do
    {
      if (v96)
      {
        memcpy((void *)(a7 + 2 * v97 * v35), v15, 2 * v35);
        ++v97;
      }
      else
      {
        memcpy((void *)(a6 + 2 * v98 * v35), v15, 2 * v35);
        ++v98;
      }
      ++v96;
      int16x8_t v15 = (int16x8_t *)((char *)v15 + 2 * v35);
    }
    while (v66 != v96);
  }
  if (a10)
  {
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "BlurM: Splitting\n", buf, 2u);
    }
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 67109120;
      int v128 = v98;
      _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "BlurM: v_cnt_split = %d\n", buf, 8u);
    }
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "BlurM: v = [\n", buf, 2u);
    }
    sub_10001DF5C(a6, 0, 0, v35, v68, v35);
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "BlurM: ];\n", buf, 2u);
    }
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 67109120;
      int v128 = v97;
      _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "BlurM: v_cnt_split = %d\n", buf, 8u);
    }
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "BlurM: d = [\n", buf, 2u);
    }
    sub_10001DF5C(a7, 0, 0, v35, v68, v35);
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "BlurM: ];\n", buf, 2u);
    }
    int v63 = v97;
  }
  if ((int)v71 < 1)
  {
    LODWORD(v99) = 0;
  }
  else
  {
    unint64_t v99 = 0;
    long long v101 = (int16x8_t *)a6;
    long long v100 = (int16x8_t *)a7;
    do
    {
      int16x8_t v102 = *v101++;
      *long long v100 = vsubq_s16(*v100, v102);
      ++v100;
      v99 += 8;
    }
    while (v99 < v71);
  }
  if ((int)v99 < (int)v124)
  {
    uint64_t v103 = v124 - v99;
    char v104 = (__int16 *)(a6 + 2 * v99);
    float v105 = (_WORD *)(a7 + 2 * v99);
    do
    {
      __int16 v106 = *v104++;
      *v105++ -= v106;
      --v103;
    }
    while (v103);
  }
  if (a10)
  {
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "BlurM: Lifting\n", buf, 2u);
    }
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 67109120;
      int v128 = v63;
      _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "BlurM: v_cnt_split = %d\n", buf, 8u);
    }
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 67109120;
      int v128 = 0;
      _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "BlurM: h_cnt_split = %d\n", buf, 8u);
    }
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "BlurM: d = [\n", buf, 2u);
    }
    sub_10001DF5C(a7, 0, 0, v35, v68, v35);
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "BlurM: ];\n", buf, 2u);
    }
    if ((int)v71 < 1)
    {
      LODWORD(v111) = 0;
    }
    else
    {
      unint64_t v111 = 0;
      uint64_t v113 = (int16x8_t *)a6;
      long long v112 = (int16x8_t *)a7;
      do
      {
        int16x8_t v114 = vshrq_n_s16(*v112, 1uLL);
        *uint64_t v113 = vsraq_n_s16(*v113, *v112, 1uLL);
        ++v113;
        *v112++ = v114;
        v111 += 8;
      }
      while (v111 < v71);
    }
    if ((int)v111 < (int)v124)
    {
      uint64_t v119 = v124 - v111;
      float v120 = (_WORD *)(a6 + 2 * v111);
      double v121 = (__int16 *)(a7 + 2 * v111);
      do
      {
        int v122 = *v121;
        *v121++ >>= 1;
        *v120++ += v122 >> 1;
        --v119;
      }
      while (v119);
    }
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 67109120;
      int v128 = v63;
      _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "BlurM: v_cnt_split = %d\n", buf, 8u);
    }
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 67109120;
      int v128 = 0;
      _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "BlurM: h_cnt_split = %d\n", buf, 8u);
    }
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "BlurM: v = [\n", buf, 2u);
    }
    sub_10001DF5C(a6, 0, 0, v35, v68, v35);
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "BlurM: ];\n", buf, 2u);
    }
  }
  else
  {
    if ((int)v71 < 1)
    {
      LODWORD(v107) = 0;
    }
    else
    {
      unint64_t v107 = 0;
      float v109 = (int16x8_t *)a6;
      uint64_t v108 = (int16x8_t *)a7;
      do
      {
        int16x8_t v110 = vshrq_n_s16(*v108, 1uLL);
        *float v109 = vsraq_n_s16(*v109, *v108, 1uLL);
        ++v109;
        *v108++ = v110;
        v107 += 8;
      }
      while (v107 < v71);
    }
    if ((int)v107 < (int)v124)
    {
      uint64_t v115 = v124 - v107;
      int v116 = (_WORD *)(a6 + 2 * v107);
      float v117 = (__int16 *)(a7 + 2 * v107);
      do
      {
        int v118 = *v117;
        *v117++ >>= 1;
        *v116++ += v118 >> 1;
        --v115;
      }
      while (v115);
    }
  }
  if (a10)
  {
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 67109120;
      int v128 = v63;
      _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "BlurM: v_cnt_split = %d\n", buf, 8u);
    }
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 67109120;
      int v128 = 0;
      _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "BlurM: h_cnt_split = %d\n", buf, 8u);
    }
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "BlurM: d = [\n", buf, 2u);
    }
    sub_10001DF5C(a7, 0, 0, v35, v68, v35);
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "BlurM: ];\n", buf, 2u);
    }
  }
}

void sub_100021274(int *a1, uint64_t a2)
{
  if (!a1) {
    sub_100075CB0();
  }
  uint64_t v2 = a1;
  int v3 = *a1;
  if (*a1 == 1)
  {
    v136 = (unsigned __int8 *)(a1 + 1144);
    long long v101 = (unsigned __int8 *)(a1 + 2531);
    char v104 = *((unsigned char *)a1 + 4608);
    if (v104)
    {
      if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
      {
        int v5 = v2[4];
        int v6 = v2[1169];
        int v7 = v2[1170];
        int v8 = v2[1153];
        *(_DWORD *)buf = 67109888;
        *(_DWORD *)BOOL v157 = v5;
        *(_WORD *)&v157[4] = 1024;
        *(_DWORD *)&v157[6] = v6;
        LOWORD(v158) = 1024;
        *(_DWORD *)((char *)&v158 + 2) = v7;
        HIWORD(v158) = 1024;
        *(_DWORD *)double v159 = v8;
        _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "BlurM: #%08d (%4d x %4d) inputCount = %d\n", buf, 0x1Au);
      }
      if (v2[1153])
      {
        unint64_t v9 = 0;
        do
        {
          if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
          {
            double v10 = *(double *)(a2 + 8 * v9);
            unint64_t v11 = &v2[5 * v9];
            int v12 = *((unsigned __int8 *)v11 + 4616);
            int v13 = v11[1155];
            int v14 = v11[1156];
            int v15 = v11[1158];
            LODWORD(v11) = v11[1157];
            *(_DWORD *)buf = 134219520;
            *(void *)BOOL v157 = v9;
            *(_WORD *)&v157[8] = 2048;
            double v158 = v10;
            *(_WORD *)double v159 = 1024;
            *(_DWORD *)&v159[2] = v12;
            *(_WORD *)double v160 = 1024;
            *(_DWORD *)&v160[2] = v13;
            *(_WORD *)double v161 = 1024;
            *(_DWORD *)&v161[2] = v14;
            *(_WORD *)double v162 = 1024;
            *(_DWORD *)&v162[2] = v15;
            LOWORD(v163[0]) = 1024;
            *(_DWORD *)((char *)v163 + 2) = v11;
            _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "BlurM: input[%zu] = %p (level = %d) %d x %d, stride = %d, std::string::size_type size = %d\n", buf, 0x34u);
          }
          uint64_t v16 = *(unsigned __int8 **)(a2 + 8 * v9);
          if (v16)
          {
            uint64_t v17 = &v2[5 * v9];
            uint64_t v18 = v17[1155];
            if (v18)
            {
              int16x8_t v19 = &v2[5 * v9];
              if (v19[1156])
              {
                double v140 = v17 + 1155;
                uint64_t v138 = v19 + 1156;
                uint64_t v20 = &v16[v18 - 1];
                uint64_t v21 = &v2[5 * v9 + 1158];
                uint64_t v22 = 4;
                do
                {
                  if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
                  {
                    int v23 = *v16;
                    int v24 = v16[1];
                    int v25 = v16[2];
                    int v26 = v16[3];
                    int v27 = *(v20 - 3);
                    int v28 = *(v20 - 2);
                    int v29 = *(v20 - 1);
                    int v30 = *v20;
                    *(_DWORD *)buf = 67110912;
                    *(_DWORD *)BOOL v157 = v23;
                    *(_WORD *)&v157[4] = 1024;
                    *(_DWORD *)&v157[6] = v24;
                    LOWORD(v158) = 1024;
                    *(_DWORD *)((char *)&v158 + 2) = v25;
                    HIWORD(v158) = 1024;
                    *(_DWORD *)double v159 = v26;
                    *(_WORD *)&v159[4] = 1024;
                    *(_DWORD *)double v160 = v27;
                    *(_WORD *)&v160[4] = 1024;
                    *(_DWORD *)double v161 = v28;
                    *(_WORD *)&v161[4] = 1024;
                    *(_DWORD *)double v162 = v29;
                    *(_WORD *)&v162[4] = 1024;
                    v163[0] = v30;
                    _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "BlurM: %3d %3d %3d %3d ... %3d %3d %3d %3d\n", buf, 0x32u);
                  }
                  uint64_t v31 = *v21;
                  v16 += v31;
                  v20 += v31;
                  --v22;
                }
                while (v22);
                if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
                {
                  *(_WORD *)buf = 0;
                  _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "BlurM: ... ... ... ... ... ... ... ... ...\n", buf, 2u);
                  uint64_t v31 = *v21;
                }
                int v32 = (unsigned __int8 *)(*(void *)(a2 + 8 * v9) + (*v138 - 4) * v31);
                int v33 = &v32[*v140 - 1];
                uint64_t v34 = 4;
                do
                {
                  if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
                  {
                    int v35 = *v32;
                    int v36 = v32[1];
                    int v37 = v32[2];
                    int v38 = v32[3];
                    int v39 = *(v33 - 3);
                    int v40 = *(v33 - 2);
                    int v41 = *(v33 - 1);
                    int v42 = *v33;
                    *(_DWORD *)buf = 67110912;
                    *(_DWORD *)BOOL v157 = v35;
                    *(_WORD *)&v157[4] = 1024;
                    *(_DWORD *)&v157[6] = v36;
                    LOWORD(v158) = 1024;
                    *(_DWORD *)((char *)&v158 + 2) = v37;
                    HIWORD(v158) = 1024;
                    *(_DWORD *)double v159 = v38;
                    *(_WORD *)&v159[4] = 1024;
                    *(_DWORD *)double v160 = v39;
                    *(_WORD *)&v160[4] = 1024;
                    *(_DWORD *)double v161 = v40;
                    *(_WORD *)&v161[4] = 1024;
                    *(_DWORD *)double v162 = v41;
                    *(_WORD *)&v162[4] = 1024;
                    v163[0] = v42;
                    _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "BlurM: %3d %3d %3d %3d ... %3d %3d %3d %3d\n", buf, 0x32u);
                    uint64_t v31 = *v21;
                  }
                  v32 += v31;
                  v33 += v31;
                  --v34;
                }
                while (v34);
              }
            }
          }
          ++v9;
        }
        while (v9 < v2[1153]);
      }
    }
    uint64_t v114 = a2;
    int v43 = v2 + 40;
    float v44 = v136;
    int v45 = *v136;
    unint64_t v111 = (float *)(v2 + 1171);
    bzero(v2 + 1171, 0x400uLL);
    long long v100 = v2 + 1427;
    memcpy(v2 + 1427, v2 + 40, 0x1160uLL);
    unint64_t v46 = 0;
    __dst = (char *)(v2 + 35309);
    uint64_t v47 = (uint64_t)(v2 + 51693);
    uint64_t v134 = (uint64_t)(v2 + 84461);
    int16x4x2_t v129 = (int16x8_t *)(v2 + 100845);
    int16x4x2_t v130 = (int16x8_t *)(v2 + 92653);
    uint64_t v127 = (int16x8_t *)(v2 + 27117);
    int v128 = (int16x8_t *)(v2 + 18925);
    float v126 = (int16x8_t *)(v2 + 10731);
    int v125 = (int16x8_t *)(v2 + 133613);
    unint64_t v107 = (const __int16 *)(v2 + 18923);
    uint64_t v108 = (uint64_t)(v2 + 125421);
    uint64_t v118 = (uint64_t)(v2 + 135661);
    uint64_t v119 = (int16x8_t *)(v2 + 117229);
    int v116 = (int16x8_t *)(v2 + 139757);
    float v117 = (int16x8_t *)(v2 + 137709);
    uint64_t v115 = (int16x8_t *)(v2 + 141805);
    unint64_t v99 = v2;
    float v105 = (int16x8_t *)(v2 + 145901);
    __int16 v106 = (int16x8_t *)(v2 + 143853);
    char v48 = v104;
    float v109 = v2 + 40;
    uint64_t v113 = &v2[5 * v45 + 1158];
    double v121 = v2 + 51693;
    __src = (int16x8_t *)(v2 + 109037);
    do
    {
      if (v43[368 * *v44 + 360 + (void)v46] == 1)
      {
        int16x8_t v49 = &v43[368 * *v44];
        uint64_t v102 = v49[(void)v46 + 84];
        if ((int)v102 >= 1)
        {
          uint64_t v120 = 0;
          int v50 = 0;
          double v51 = (double *)&v49[2 * (void)v46];
          uint64_t v52 = (int)v51[48];
          uint64_t v53 = (int)v51[44];
          uint64_t v112 = v43[368 * *v44 + 80 + (void)v46];
          int16x8_t v110 = &v111[(void)v46];
          if ((int)v53 >= 0) {
            int v54 = (int)v51[44];
          }
          else {
            int v54 = v53 + 1;
          }
          int v55 = v53 + 3;
          if ((int)v53 >= 0) {
            int v55 = v53;
          }
          if ((int)v52 >= 0) {
            int v56 = v52;
          }
          else {
            int v56 = v52 + 1;
          }
          int v141 = v56 >> 1;
          int v57 = v54 >> 1;
          int v139 = v55 >> 2;
          int v137 = (int)v52 / 4;
          uint64_t v122 = v52;
          int v142 = v54 >> 1;
          float v123 = v46;
          do
          {
            if ((int)v112 >= 1)
            {
              uint64_t v58 = 0;
              uint64_t v59 = v50;
              do
              {
                uint64_t v124 = v59;
                uint64_t v60 = (uint64_t)&v43[368 * *v44 + 104 + 64 * (void)v46];
                int v132 = (int)*(double *)(v60 + 8 * v120 + 128);
                uint64_t v133 = v58;
                int v131 = (int)*(double *)(v60 + 8 * v58);
                if ((int)v52 >= 1)
                {
                  uint64_t v61 = v52;
                  uint64_t v62 = __dst;
                  unint64_t v46 = v44;
                  int v63 = (int)*(double *)(v60 + 8 * v120 + 128);
                  do
                  {
                    memcpy(v62, (const void *)(*(void *)(v114 + 8 * *v46) + v131 + (*v113 * v63++)), (int)v53);
                    v62 += (int)v53;
                    --v61;
                  }
                  while (v61);
                  uint64_t v64 = 0;
                  uint64_t v47 = (uint64_t)v121;
                  LODWORD(v52) = v122;
                  int v65 = v121;
                  int v66 = (unsigned __int8 *)__dst;
                  float v44 = v46;
                  char v48 = v104;
                  LODWORD(v46) = v123;
                  int v57 = v142;
                  do
                  {
                    if ((int)v53 >= 1)
                    {
                      uint64_t v67 = v53;
                      int v68 = v65;
                      int v69 = v66;
                      do
                      {
                        __int16 v70 = *v69++;
                        *v68++ = 16 * v70;
                        --v67;
                      }
                      while (v67);
                    }
                    ++v64;
                    v66 += (int)v53;
                    v65 += (int)v53;
                  }
                  while (v64 != v122);
                }
                if (v48)
                {
                  if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
                  {
                    *(_DWORD *)buf = 67110144;
                    *(_DWORD *)BOOL v157 = v53;
                    *(_WORD *)&v157[4] = 1024;
                    *(_DWORD *)&v157[6] = v52;
                    LOWORD(v158) = 1024;
                    *(_DWORD *)((char *)&v158 + 2) = v46;
                    HIWORD(v158) = 1024;
                    *(_DWORD *)double v159 = v120;
                    *(_WORD *)&v159[4] = 1024;
                    *(_DWORD *)double v160 = v133;
                    _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "BlurM: PYRYU8[%dx%df][OBJ=%d][Y=%d][X=%d]=[\n", buf, 0x20u);
                  }
                  sub_10001E200(*(void *)(v114 + 8 * *v44), v131, v132, v53, v52, *v113);
                  if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
                  {
                    *(_WORD *)buf = 0;
                    _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "BlurM: ];\n",
                      buf,
                      2u);
                  }
                  if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
                  {
                    *(_DWORD *)buf = 67110144;
                    *(_DWORD *)BOOL v157 = v53;
                    *(_WORD *)&v157[4] = 1024;
                    *(_DWORD *)&v157[6] = v52;
                    LOWORD(v158) = 1024;
                    *(_DWORD *)((char *)&v158 + 2) = v46;
                    HIWORD(v158) = 1024;
                    *(_DWORD *)double v159 = v120;
                    *(_WORD *)&v159[4] = 1024;
                    *(_DWORD *)double v160 = v133;
                    _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "BlurM: ROIS16[%dx%df][OBJ=%d][Y=%d][X=%d]=[\n", buf, 0x20u);
                  }
                  sub_10001DF5C(v47, 0, 0, v53, v52, v53);
                  if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
                  {
                    *(_WORD *)buf = 0;
                    _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "BlurM: ];\n",
                      buf,
                      2u);
                  }
                  sub_10001FAD4(v47, v53, v52, v134, (uint64_t)v130, (uint64_t)v129, (uint64_t)__src, v128, v127, v48);
                  if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
                  {
                    *(_DWORD *)buf = 67109120;
                    *(_DWORD *)BOOL v157 = v141;
                    _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "BlurM: height_l1 = %d\n", buf, 8u);
                  }
                  if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
                  {
                    *(_DWORD *)buf = 67109120;
                    *(_DWORD *)BOOL v157 = v57;
                    _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "BlurM: width_l1 = %d\n", buf, 8u);
                  }
                  unint64_t v71 = v44;
                  if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
                  {
                    *(_WORD *)buf = 0;
                    _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "BlurM: a1 = [\n", buf, 2u);
                  }
                  sub_10001DF5C(v134, 0, 0, v142, v141, v142);
                  if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
                  {
                    *(_WORD *)buf = 0;
                    _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "BlurM: ];\n",
                      buf,
                      2u);
                  }
                }
                else
                {
                  unint64_t v71 = v44;
                  sub_10001FAD4(v47, v53, v52, v134, (uint64_t)v130, (uint64_t)v129, (uint64_t)__src, v128, v127, v48);
                }
                int v72 = v142;
                int v73 = v141;
                sub_10001F814(v130, v129, __src, v142, v141, (uint64_t)v119, v48);
                __int16 v155 = 0;
                sub_10001E480(__src, v142, v141, &v155, v48);
                if (v48)
                {
                  if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
                  {
                    *(_DWORD *)buf = 67109120;
                    *(_DWORD *)BOOL v157 = v155;
                    _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "BlurM: d1_median = %d\n", buf, 8u);
                  }
                  uint64_t v75 = (uint64_t)v119;
                  int v76 = v137;
                  if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
                  {
                    *(_DWORD *)buf = 67109120;
                    *(_DWORD *)BOOL v157 = v141;
                    _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "BlurM: height_d1 = %d\n", buf, 8u);
                  }
                  int v72 = v142;
                  if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
                  {
                    *(_DWORD *)buf = 67109120;
                    *(_DWORD *)BOOL v157 = v142;
                    _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "BlurM: width_d1 = %d\n", buf, 8u);
                  }
                  if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
                  {
                    *(_WORD *)buf = 0;
                    _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "BlurM: d1 = [\n", buf, 2u);
                  }
                  sub_10001DF5C((uint64_t)__src, 0, 0, v142, v141, v142);
                  if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
                  {
                    *(_WORD *)buf = 0;
                    _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "BlurM: ];\n",
                      buf,
                      2u);
                  }
                  int v154 = 0;
                  sub_10001E720(__src, v142, v141, &v155, (__int16 *)&v154 + 1, (__int16 *)&v154, v126, v48);
                  if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
                  {
                    *(_DWORD *)buf = 67109120;
                    *(_DWORD *)BOOL v157 = SHIWORD(v154);
                    _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "BlurM: d1_mad_median = %d\n", buf, 8u);
                  }
                  if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
                  {
                    *(_DWORD *)buf = 67109120;
                    *(_DWORD *)BOOL v157 = (__int16)v154;
                    _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "BlurM: d1_mad_sigma = %d\n", buf, 8u);
                  }
                  BOOL v74 = v71;
                  __int16 v153 = 0;
                  int v73 = v141;
                  sub_10001E480(v119, v142, v141, &v153, v48);
                  if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
                  {
                    *(_DWORD *)buf = 67109120;
                    *(_DWORD *)BOOL v157 = v153;
                    _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "BlurM: emap1_median = %d\n", buf, 8u);
                  }
                }
                else
                {
                  BOOL v74 = v71;
                  int v154 = 0;
                  sub_10001E720(__src, v142, v141, &v155, (__int16 *)&v154 + 1, (__int16 *)&v154, v126, v48);
                  __int16 v153 = 0;
                  sub_10001E480(v119, v142, v141, &v153, v48);
                  uint64_t v75 = (uint64_t)v119;
                  int v76 = v137;
                }
                __int16 v152 = 1;
                __int16 v151 = 0;
                sub_10001EBCC(v75, v72, v73, &v153, &v152, &v151, (__int16 *)&v154, v108, v48);
                int v150 = 2;
                sub_10001F068(v108, v72, v73, &v150, (uint64_t)v125, v139, v107, v48);
                float v149 = 0.0;
                sub_10001F2AC(v125, v139, v76, &v149, v48);
                sub_10001FAD4(v134, v72, v73, v118, (uint64_t)v117, (uint64_t)v116, (uint64_t)v115, v128, v127, v48);
                if (v48)
                {
                  uint64_t v47 = (uint64_t)v121;
                  if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
                  {
                    *(_DWORD *)buf = 67109120;
                    *(_DWORD *)BOOL v157 = v76;
                    _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "BlurM: height_l2 = %d\n", buf, 8u);
                  }
                  float v44 = v74;
                  uint64_t v77 = (uint64_t)v106;
                  if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
                  {
                    *(_DWORD *)buf = 67109120;
                    *(_DWORD *)BOOL v157 = v139;
                    _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "BlurM: width_l2 = %d\n", buf, 8u);
                  }
                  if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
                  {
                    *(_WORD *)buf = 0;
                    _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "BlurM: a2 = [\n", buf, 2u);
                  }
                  sub_10001DF5C(v118, 0, 0, v139, v76, v139);
                  if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
                  {
                    *(_WORD *)buf = 0;
                    _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "BlurM: ];\n",
                      buf,
                      2u);
                  }
                  int v76 = v137;
                  sub_10001F814(v117, v116, v115, v139, v137, (uint64_t)v106, v48);
                  __int16 v148 = 0;
                  sub_10001E480(v115, v139, v137, &v148, v48);
                  if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
                  {
                    *(_DWORD *)buf = 67109120;
                    *(_DWORD *)BOOL v157 = v148;
                    _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "BlurM: d2_median = %d\n", buf, 8u);
                  }
                  uint64_t v79 = v124;
                  if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
                  {
                    *(_DWORD *)buf = 67109120;
                    *(_DWORD *)BOOL v157 = v137;
                    _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "BlurM: height_d2 = %d\n", buf, 8u);
                  }
                  if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
                  {
                    *(_DWORD *)buf = 67109120;
                    *(_DWORD *)BOOL v157 = v139;
                    _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "BlurM: width_d2 = %d\n", buf, 8u);
                  }
                  if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
                  {
                    *(_WORD *)buf = 0;
                    _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "BlurM: d2 = [\n", buf, 2u);
                  }
                  sub_10001DF5C((uint64_t)v115, 0, 0, v139, v137, v139);
                  if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
                  {
                    *(_WORD *)buf = 0;
                    _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "BlurM: ];\n",
                      buf,
                      2u);
                  }
                  int v147 = 0;
                  int v78 = v139;
                  sub_10001E720(v115, v139, v137, &v148, (__int16 *)&v147 + 1, (__int16 *)&v147, v126, v48);
                  if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
                  {
                    *(_DWORD *)buf = 67109120;
                    *(_DWORD *)BOOL v157 = SHIWORD(v147);
                    _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "BlurM: d2_mad_median = %d\n", buf, 8u);
                  }
                  if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
                  {
                    *(_DWORD *)buf = 67109120;
                    *(_DWORD *)BOOL v157 = (__int16)v147;
                    _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "BlurM: d2_mad_sigma = %d\n", buf, 8u);
                  }
                  __int16 v146 = 0;
                  sub_10001E480(v106, v139, v137, &v146, v48);
                  if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
                  {
                    *(_DWORD *)buf = 67109120;
                    *(_DWORD *)BOOL v157 = v146;
                    _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "BlurM: emap2_median = %d\n", buf, 8u);
                  }
                }
                else
                {
                  uint64_t v77 = (uint64_t)v106;
                  sub_10001F814(v117, v116, v115, v139, v76, (uint64_t)v106, v48);
                  __int16 v148 = 0;
                  sub_10001E480(v115, v139, v76, &v148, v48);
                  int v147 = 0;
                  sub_10001E720(v115, v139, v76, &v148, (__int16 *)&v147 + 1, (__int16 *)&v147, v126, v48);
                  __int16 v146 = 0;
                  sub_10001E480(v106, v139, v76, &v146, v48);
                  uint64_t v47 = (uint64_t)v121;
                  float v44 = v74;
                  int v78 = v139;
                  uint64_t v79 = v124;
                }
                __int16 v145 = 0;
                sub_10001EBCC(v77, v78, v76, &v146, &v152, &v145, (__int16 *)&v147, (uint64_t)v105, v48);
                *(_DWORD *)buf = 0;
                sub_10001F2AC(v105, v78, v137, (float *)buf, v48);
                int v43 = v109;
                float v144 = *(float *)&v109[368 * *v44 + 364 + (void)v123];
                uint64_t v143 = 0;
                unint64_t v46 = v123;
                sub_10001F40C(v125, v105, v78, v137, &v144, (float *)&v143 + 1, (float *)&v143, v48);
                v110[16 * v79] = v149;
                unint64_t v80 = &v111[16 * v79 + (void)v123];
                v80[4] = *(float *)buf;
                v80[8] = *((float *)&v143 + 1);
                *((_DWORD *)v80 + 12) = v143;
                uint64_t v59 = v79 + 1;
                uint64_t v58 = v133 + 1;
                uint64_t v52 = v122;
                int v57 = v142;
              }
              while (v133 + 1 != v112);
              int v50 = v59;
            }
            ++v120;
          }
          while (v120 != v102);
        }
      }
      ++v46;
    }
    while (v46 != (unsigned __int8 *)4);
    if (v44[32])
    {
      uint64_t v81 = 0;
      int v82 = (float *)(v99 + 1175);
      int16x8_t v83 = (float *)(v99 + 1179);
      unint64_t v84 = (float *)(v99 + 1183);
      do
      {
        if (v100[368 * *v101 + 360 + v81] == 1)
        {
          if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
          {
            float v85 = "OTHER";
            if ((unsigned __int16)v81 <= 2u) {
              float v85 = off_100096490[(__int16)v81];
            }
            *(_DWORD *)buf = 136315138;
            *(void *)BOOL v157 = v85;
            _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "BlurM: Output[OBJ=%s]:\n", buf, 0xCu);
          }
          if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)buf = 0;
            _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "BlurM: sharpnessL1 = [\n", buf, 2u);
          }
          uint64_t v86 = 0;
          int16x8_t v87 = v111;
          do
          {
            if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
            {
              double v88 = *v87;
              *(_DWORD *)buf = 134218240;
              *(void *)BOOL v157 = v86;
              *(_WORD *)&v157[8] = 2048;
              double v158 = v88;
              _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "BlurM: [%2zu %010.6f];\n",
                buf,
                0x16u);
            }
            ++v86;
            v87 += 16;
          }
          while (v86 != 16);
          if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)buf = 0;
            _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "BlurM: ];\n",
              buf,
              2u);
          }
          if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)buf = 0;
            _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "BlurM: sharpnessL2 = [\n", buf, 2u);
          }
          uint64_t v89 = 0;
          uint64_t v90 = v82;
          do
          {
            if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
            {
              double v91 = *v90;
              *(_DWORD *)buf = 134218240;
              *(void *)BOOL v157 = v89;
              *(_WORD *)&v157[8] = 2048;
              double v158 = v91;
              _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "BlurM: [%2zu %010.6f];\n",
                buf,
                0x16u);
            }
            ++v89;
            v90 += 16;
          }
          while (v89 != 16);
          if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)buf = 0;
            _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "BlurM: ];\n",
              buf,
              2u);
          }
          if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)buf = 0;
            _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "BlurM: blurConf = [\n", buf, 2u);
          }
          uint64_t v92 = 0;
          uint64_t v93 = v83;
          do
          {
            if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
            {
              double v94 = *v93;
              *(_DWORD *)buf = 134218240;
              *(void *)BOOL v157 = v92;
              *(_WORD *)&v157[8] = 2048;
              double v158 = v94;
              _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "BlurM: [%2zu %010.6f];\n",
                buf,
                0x16u);
            }
            ++v92;
            v93 += 16;
          }
          while (v92 != 16);
          if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)buf = 0;
            _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "BlurM: ];\n",
              buf,
              2u);
          }
          if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)buf = 0;
            _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "BlurM: blurExtent = [\n", buf, 2u);
          }
          uint64_t v95 = 0;
          uint64_t v96 = v84;
          do
          {
            if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
            {
              double v97 = *v96;
              *(_DWORD *)buf = 134218240;
              *(void *)BOOL v157 = v95;
              *(_WORD *)&v157[8] = 2048;
              double v158 = v97;
              _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "BlurM: [%2zu %010.6f];\n",
                buf,
                0x16u);
            }
            ++v95;
            v96 += 16;
          }
          while (v95 != 16);
          if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)buf = 0;
            _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "BlurM: ];\n",
              buf,
              2u);
          }
        }
        ++v81;
        ++v111;
        ++v82;
        ++v83;
        ++v84;
      }
      while (v81 != 4);
    }
    int v98 = 0;
    uint64_t v2 = v99;
  }
  else if (a1[1152])
  {
    int v98 = 1;
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 67109376;
      *(_DWORD *)BOOL v157 = 1;
      *(_WORD *)&v157[4] = 1024;
      *(_DWORD *)&v157[6] = v3;
      _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "BlurM: incompatible context version (expected %d, got %d)\n", buf, 0xEu);
    }
  }
  else
  {
    int v98 = 1;
  }
  v2[2] = v98;
}

uint64_t sub_100022AAC(void *a1, uint64_t a2, uint64_t a3)
{
  pthread_t v8 = 0;
  sub_100028DDC(&v10);
  v9[0] = 0;
  v9[1] = a2;
  v9[2] = a3;
  v9[3] = &v10;
  sched_param v7 = (sched_param)48;
  pthread_attr_init(&v11);
  pthread_attr_setschedparam(&v11, &v7);
  pthread_attr_setdetachstate(&v11, 1);
  pthread_create(&v8, &v11, (void *(__cdecl *)(void *))sub_100022BB8, v9);
  pthread_attr_destroy(&v11);
  sub_100028E20(&v10);
  *a1 = v9[0];
  sub_100028E18((uint64_t)&v10);
  return 0;
}

void sub_100022B9C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, char a16)
{
}

void sub_100022BB8(uint64_t a1)
{
}

void sub_100022C5C()
{
}

void sub_100022C80(uint64_t a1)
{
  uint64_t v2 = (__CFRunLoop *)CFRetain(*(CFTypeRef *)(a1 + 48));
  CFRunLoopStop(v2);
  int v3 = 0;
  pthread_join(*(pthread_t *)(a1 + 64), &v3);
  sub_1000133F8(a1);
  operator delete();
}

uint64_t sub_100022CF0(const __CFString *a1, const __CFString *a2, uint64_t a3)
{
  CFStringRef v4 = (const __CFString *)CFPreferencesCopyValue(a1, a2, kCFPreferencesCurrentUser, kCFPreferencesAnyHost);
  if (v4)
  {
    CFStringRef v5 = v4;
    CFTypeID v6 = CFGetTypeID(v4);
    if (v6 == CFStringGetTypeID())
    {
      uint64_t IntValue = CFStringGetIntValue(v5);
      if (!IntValue)
      {
        CFStringEncoding SystemEncoding = CFStringGetSystemEncoding();
        CStringPtr = CFStringGetCStringPtr(v5, SystemEncoding);
        if (!CStringPtr || (uint64_t IntValue = strtol(CStringPtr, 0, 0), !IntValue))
        {
          uint64_t IntValue = 1;
          if (CFStringCompare(v5, @"true", 1uLL))
          {
            uint64_t IntValue = 1;
            if (CFStringCompare(v5, @"yes", 1uLL))
            {
              if (CFStringCompare(v5, @"false", 1uLL) == kCFCompareEqualTo
                || CFStringCompare(v5, @"no", 1uLL) == kCFCompareEqualTo
                || (uint64_t IntValue = a3, CFStringCompare(v5, @"0", 1uLL) == kCFCompareEqualTo))
              {
                uint64_t IntValue = 0;
              }
            }
          }
        }
      }
    }
    else
    {
      CFTypeID v10 = CFGetTypeID(v5);
      if (v10 == CFNumberGetTypeID())
      {
        unsigned int valuePtr = 0;
        if (CFNumberGetValue((CFNumberRef)v5, kCFNumberIntType, &valuePtr)) {
          uint64_t IntValue = valuePtr;
        }
        else {
          uint64_t IntValue = a3;
        }
      }
      else
      {
        CFTypeID v11 = CFGetTypeID(v5);
        uint64_t IntValue = a3;
        if (v11 == CFBooleanGetTypeID()) {
          uint64_t IntValue = CFEqual(v5, kCFBooleanTrue);
        }
      }
    }
    CFRelease(v5);
    return IntValue;
  }
  return a3;
}

unsigned int *sub_100022EA0(uint64_t a1, uint64_t a2, int a3)
{
  int v3 = *(_DWORD *)(a1 + 16);
  if (v3)
  {
    CFStringRef v4 = (unsigned int *)(a1 + 20);
    do
    {
      uint64_t v5 = *v4;
      if ((unint64_t)v4 + v5 > a1 + a2) {
        break;
      }
      if (*((unsigned __int16 *)v4 + 4) == a3) {
        return v4 + 1;
      }
      CFStringRef v4 = (unsigned int *)((char *)v4 + (v5 + 4));
      --v3;
    }
    while (v3);
  }
  return 0;
}

CFRunLoopSourceRef sub_100022EEC(uint64_t a1)
{
  CFRunLoopSourceRef result = *(CFRunLoopSourceRef *)(a1 + 16);
  if (!result)
  {
    CFRunLoopSourceRef result = CFMessagePortCreateRunLoopSource(0, *(CFMessagePortRef *)(a1 + 8), 0);
    *(void *)(a1 + 16) = result;
  }
  return result;
}

uint64_t sub_100022F24(thread_act_t a1, int a2)
{
  integer_t v8 = 0;
  pid_t v4 = getpid();
  if (proc_pidinfo(v4, 2, 0, buffer, 232) <= 0)
  {
    fwrite("H16ISPSetMachThreadPriority - proc_pidinfo() failed\n", 0x34uLL, 1uLL, __stderrp);
    return 0xFFFFFFFFLL;
  }
  else
  {
    integer_t policy_info = a2 - v11;
    uint64_t v5 = thread_policy_set(a1, 3u, &policy_info, 1u);
    if (v5)
    {
      uint64_t v6 = v5;
      fprintf(__stderrp, "H16ISPSetMachThreadPriority - thread_policy_set(...,THREAD_PRECEDENCE_POLICY,...) failed, err=%d\n", v5);
    }
    else
    {
      uint64_t v6 = thread_policy_set(a1, 1u, &v8, 1u);
      if (v6) {
        fprintf(__stderrp, "H16ISPSetMachThreadPriority - thread_policy_set(...,THREAD_EXTENDED_POLICY,...) failed, err=%d\n", v6);
      }
    }
  }
  return v6;
}

xpc_object_t sub_100023054(const __CFString *a1)
{
  CFTypeID v2 = CFGetTypeID(a1);
  if (v2 == CFDictionaryGetTypeID())
  {
    xpc_object_t v3 = xpc_dictionary_create(0, 0, 0);
    CFDictionaryApplyFunction((CFDictionaryRef)a1, (CFDictionaryApplierFunction)sub_10002356C, v3);
    return v3;
  }
  if (v2 == CFArrayGetTypeID())
  {
    xpc_object_t v3 = xpc_array_create(0, 0);
    v13.size_t length = CFArrayGetCount((CFArrayRef)a1);
    v13.location = 0;
    CFArrayApplyFunction((CFArrayRef)a1, v13, (CFArrayApplierFunction)sub_100023654, v3);
    return v3;
  }
  if (v2 == CFNumberGetTypeID())
  {
    CFNumberType Type = CFNumberGetType((CFNumberRef)a1);
    if ((unint64_t)Type <= kCFNumberDoubleType && ((1 << Type) & 0x3060) != 0)
    {
      value[0] = 0;
      CFNumberGetValue((CFNumberRef)a1, kCFNumberDoubleType, value);
      return xpc_double_create(*(double *)value);
    }
    else
    {
      value[0] = 0;
      CFNumberGetValue((CFNumberRef)a1, kCFNumberSInt64Type, value);
      return xpc_int64_create(value[0]);
    }
  }
  if (v2 == CFStringGetTypeID())
  {
    CStringPtr = CFStringGetCStringPtr(a1, 0x8000100u);
    if (!CStringPtr)
    {
      if (CFStringGetCString(a1, (char *)value, 100, 0x8000100u)) {
        CStringPtr = (const char *)value;
      }
      else {
        CStringPtr = 0;
      }
    }
    return xpc_string_create(CStringPtr);
  }
  if (v2 == CFDataGetTypeID())
  {
    BytePtr = CFDataGetBytePtr((CFDataRef)a1);
    size_t Length = CFDataGetLength((CFDataRef)a1);
    return xpc_data_create(BytePtr, Length);
  }
  else
  {
    if (v2 != CFBooleanGetTypeID()) {
      return 0;
    }
    BOOL v10 = CFBooleanGetValue((CFBooleanRef)a1) != 0;
    return xpc_BOOL_create(v10);
  }
}

CFDataRef sub_1000232B8(void *a1)
{
  xpc_type_t type = xpc_get_type(a1);
  if (type == (xpc_type_t)&_xpc_type_dictionary)
  {
    CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    double applier = COERCE_DOUBLE(_NSConcreteStackBlock);
    uint64_t v13 = 0x40000000;
    int v14 = sub_10002369C;
    int v15 = &unk_1000964A8;
    CFMutableDictionaryRef v16 = Mutable;
    xpc_dictionary_apply(a1, &applier);
    return Mutable;
  }
  if (type == (xpc_type_t)&_xpc_type_array)
  {
    CFMutableDictionaryRef Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
    double applier = COERCE_DOUBLE(_NSConcreteStackBlock);
    uint64_t v13 = 0x40000000;
    int v14 = sub_10002371C;
    int v15 = &unk_1000964C8;
    CFMutableDictionaryRef v16 = Mutable;
    xpc_array_apply(a1, &applier);
    return Mutable;
  }
  if (type == (xpc_type_t)&_xpc_type_int64)
  {
    double applier = COERCE_DOUBLE(xpc_int64_get_value(a1));
    CFAllocatorRef v4 = kCFAllocatorDefault;
    CFNumberType v5 = kCFNumberSInt64Type;
    return CFNumberCreate(v4, v5, &applier);
  }
  if (type == (xpc_type_t)&_xpc_type_double)
  {
    double applier = xpc_double_get_value(a1);
    CFAllocatorRef v4 = kCFAllocatorDefault;
    CFNumberType v5 = kCFNumberDoubleType;
    return CFNumberCreate(v4, v5, &applier);
  }
  if (type == (xpc_type_t)&_xpc_type_string)
  {
    string_ptr = xpc_string_get_string_ptr(a1);
    return (CFDataRef)CFStringCreateWithCString(kCFAllocatorDefault, string_ptr, 0x8000100u);
  }
  else
  {
    if (type != (xpc_type_t)&_xpc_type_data)
    {
      if (type != (xpc_type_t)&_xpc_type_BOOL) {
        return 0;
      }
      BOOL value = xpc_BOOL_get_value(a1);
      int v11 = &kCFBooleanTrue;
      if (!value) {
        int v11 = &kCFBooleanFalse;
      }
      return *v11;
    }
    bytes_ptr = (const UInt8 *)xpc_data_get_bytes_ptr(a1);
    size_t length = xpc_data_get_length(a1);
    return CFDataCreate(kCFAllocatorDefault, bytes_ptr, length);
  }
}

void sub_10002356C(const __CFString *a1, uint64_t a2, void *a3)
{
  CStringPtr = CFStringGetCStringPtr(a1, 0x8000100u);
  if (CStringPtr || (CStringPtr = buffer, CFStringGetCString(a1, buffer, 100, 0x8000100u)))
  {
    if (a2)
    {
      sched_param v7 = (void *)sub_100023054(a2);
      if (v7)
      {
        integer_t v8 = v7;
        xpc_dictionary_set_value(a3, CStringPtr, v7);
        xpc_release(v8);
      }
    }
    else if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR))
    {
      sub_100075CDC((uint64_t)CStringPtr);
    }
  }
}

void sub_100023654(uint64_t a1, void *a2)
{
  xpc_object_t v3 = (void *)sub_100023054(a1);
  xpc_array_append_value(a2, v3);

  xpc_release(v3);
}

uint64_t sub_10002369C(uint64_t a1, const char *a2, uint64_t a3)
{
  uint64_t v5 = sub_1000232B8(a3);
  if (v5)
  {
    uint64_t v6 = (const void *)v5;
    CFStringRef v7 = CFStringCreateWithCString(kCFAllocatorDefault, a2, 0x8000100u);
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 32), v7, v6);
    CFRelease(v7);
    CFRelease(v6);
  }
  return 1;
}

uint64_t sub_10002371C(uint64_t a1, CFIndex a2, uint64_t a3)
{
  uint64_t v5 = (const void *)sub_1000232B8(a3);
  CFArraySetValueAtIndex(*(CFMutableArrayRef *)(a1 + 32), a2, v5);
  CFRelease(v5);
  return 1;
}

void *sub_100023770(unsigned char *__dst, void *__src, unint64_t a3)
{
  uint64_t v5 = __dst;
  if (a3 > 0x16)
  {
    if (a3 >= 0x7FFFFFFFFFFFFFF8) {
      sub_1000109C8();
    }
    uint64_t v6 = (a3 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((a3 | 7) != 0x17) {
      uint64_t v6 = a3 | 7;
    }
    uint64_t v7 = v6 + 1;
    integer_t v8 = operator new(v6 + 1);
    v5[1] = a3;
    v5[2] = v7 | 0x8000000000000000;
    *uint64_t v5 = v8;
    uint64_t v5 = v8;
  }
  else
  {
    __dst[23] = a3;
  }

  return memmove(v5, __src, a3 + 1);
}

void sub_100023810(uint64_t a1@<X0>, float64x2_t *a2@<X1>, void *a3@<X8>)
{
  sub_1000032CC((uint64_t)a3, 3, *(_DWORD *)(a1 + 20));
  *a3 = &off_100095BC8;
  if (*(_DWORD *)(a1 + 20))
  {
    unsigned int v6 = 0;
    double v7 = a2->f64[0];
    float64x2_t v8 = a2[1];
    v8.f64[1] = a2[2].f64[1];
    float64x2_t v9 = v8;
    do
    {
      sub_100015A0C(a1, v6, &v12);
      float64x2_t v10 = vmulq_n_f64(vsubq_f64(v12, v9), 1.0 / (v7 * v13));
      uint64_t v11 = 0x3FF0000000000000;
      sub_100023910((uint64_t)a3, v6++, (uint64_t)&v10);
    }
    while (v6 < *(_DWORD *)(a1 + 20));
  }
}

void sub_1000238F8(_Unwind_Exception *a1)
{
  sub_100003224(v1);
  _Unwind_Resume(a1);
}

double sub_100023910(uint64_t a1, unsigned int a2, uint64_t a3)
{
  if (!*(_DWORD *)(a1 + 16) || (uint64_t v3 = *(unsigned int *)(a1 + 20), v3 <= a2)) {
    sub_100073870();
  }
  uint64_t v4 = 0;
  uint64_t v5 = (double *)(*(void *)(a1 + 8) + 8 * a2);
  uint64_t v6 = 8 * v3;
  do
  {
    double result = *(double *)(a3 + v4);
    *uint64_t v5 = result;
    v4 += 8;
    uint64_t v5 = (double *)((char *)v5 + v6);
  }
  while (v4 != 24);
  return result;
}

uint64_t sub_100023964@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, float64x2_t *a3@<X2>, float64x2_t *a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, int a7@<W6>, uint64_t a8@<X8>)
{
  int v42 = (void *)sub_1000032CC(a8, 3, *(_DWORD *)(a1 + 20));
  *int v42 = &off_100095BC8;
  uint64_t v65 = 3;
  char v66 = 0;
  int v63 = &off_100095BC8;
  uint64_t v64 = 0;
  uint64_t v61 = 3;
  char v62 = 0;
  uint64_t v59 = &off_100095BC8;
  uint64_t v60 = 0;
  if (a7)
  {
    sub_100023810(a1, a3, &v56);
    if (v66 && v64) {
      operator delete[]();
    }
    uint64_t v65 = v57;
    uint64_t v64 = *((void *)&v56 + 1);
    char v66 = v58;
    char v58 = 0;
    sub_100003224((uint64_t)&v56);
    sub_100023810(a2, a4, &v54);
    sub_100005A18(a5, (uint64_t)&v54, (uint64_t)&v56);
    if (v62 && v60) {
      operator delete[]();
    }
    uint64_t v61 = v57;
    uint64_t v60 = *((void *)&v56 + 1);
    char v62 = v58;
    char v58 = 0;
    sub_100003224((uint64_t)&v56);
    int v15 = &v54;
  }
  else
  {
    uint64_t v65 = *(void *)(a1 + 16);
    uint64_t v64 = *(void *)(a1 + 8);
    char v66 = 0;
    sub_100005A18(a5, a2, (uint64_t)&v56);
    if (v62 && v60) {
      operator delete[]();
    }
    uint64_t v61 = v57;
    uint64_t v60 = *((void *)&v56 + 1);
    char v62 = v58;
    char v58 = 0;
    int v15 = &v56;
  }
  sub_100003224((uint64_t)v15);
  if (HIDWORD(v65))
  {
    unsigned int v16 = 0;
    do
    {
      sub_100015A0C((uint64_t)&v63, v16, v51);
      unsigned int v43 = v16;
      sub_100015A0C((uint64_t)&v59, v16, v50);
      uint64_t v17 = 0;
      long long v48 = 0uLL;
      uint64_t v49 = 0;
      do
      {
        *(double *)((char *)&v48 + v17 * 8) = -*(double *)&v50[v17];
        ++v17;
      }
      while (v17 != 3);
      uint64_t v18 = 0;
      long long v54 = v48;
      uint64_t v55 = v49;
      long long v56 = v48;
      uint64_t v57 = v49;
      double v19 = 0.0;
      do
      {
        double v19 = v19 + *(double *)((char *)&v56 + v18) * *(double *)((char *)&v56 + v18);
        v18 += 8;
      }
      while (v18 != 24);
      uint64_t v20 = 0;
      double v21 = sqrt(v19);
      do
      {
        *(double *)((char *)&v56 + v20) = *(double *)((char *)&v56 + v20) / v21;
        v20 += 8;
      }
      while (v20 != 24);
      uint64_t v22 = 0;
      double v23 = 0.0;
      do
      {
        double v23 = v23 + *(double *)((char *)&v56 + v22 * 8) * *(double *)&v51[v22];
        ++v22;
      }
      while (v22 != 3);
      uint64_t v24 = 0;
      long long v48 = 0uLL;
      uint64_t v49 = 0;
      do
      {
        *(double *)((char *)&v48 + v24) = *(double *)((char *)&v56 + v24) * -v23;
        v24 += 8;
      }
      while (v24 != 24);
      uint64_t v25 = 0;
      long long v52 = v48;
      uint64_t v53 = v49;
      do
      {
        *(double *)((char *)&v52 + v25 * 8) = *(double *)&v51[v25] + *(double *)((char *)&v52 + v25 * 8);
        ++v25;
      }
      while (v25 != 3);
      uint64_t v26 = 0;
      double v27 = 0.0;
      do
      {
        double v27 = v27 + *(double *)((char *)&v52 + v26) * *(double *)(a6 + v26);
        v26 += 8;
      }
      while (v26 != 24);
      uint64_t v28 = 0;
      double v29 = 0.0;
      do
      {
        double v29 = v29 + *(double *)((char *)&v52 + v28 * 8) * *(double *)&v51[v28];
        ++v28;
      }
      while (v28 != 3);
      uint64_t v30 = 0;
      double v31 = 0.0;
      do
      {
        double v31 = v31 + *(double *)((char *)&v56 + v30) * *(double *)(a6 + v30);
        v30 += 8;
      }
      while (v30 != 24);
      uint64_t v32 = 0;
      double v33 = 0.0;
      do
      {
        double v33 = v33 + *(double *)((char *)&v56 + v32) * *(double *)((char *)&v54 + v32);
        v32 += 8;
      }
      while (v32 != 24);
      uint64_t v34 = 0;
      memset(v45, 0, sizeof(v45));
      double v35 = v27 / v29;
      do
      {
        *(double *)&v45[v34] = v35 * *(double *)&v51[v34];
        ++v34;
      }
      while (v34 != 3);
      uint64_t v36 = 0;
      double v37 = (v31 - v35 * v23) / v33;
      memset(v44, 0, sizeof(v44));
      do
      {
        *(double *)&v44[v36] = v37 * *(double *)&v50[v36];
        ++v36;
      }
      while (v36 != 3);
      uint64_t v38 = 0;
      memset(v46, 0, sizeof(v46));
      do
      {
        *(double *)&v46[v38] = *(double *)&v45[v38] + *(double *)&v44[v38];
        ++v38;
      }
      while (v38 != 3);
      uint64_t v39 = 0;
      memset(v47, 0, sizeof(v47));
      do
      {
        *(double *)&v47[v39] = *(double *)&v46[v39] + *(double *)(a6 + v39 * 8);
        ++v39;
      }
      while (v39 != 3);
      uint64_t v40 = 0;
      long long v48 = 0uLL;
      uint64_t v49 = 0;
      do
      {
        *(double *)((char *)&v48 + v40 * 8) = *(double *)&v47[v40] * 0.5;
        ++v40;
      }
      while (v40 != 3);
      sub_100023910((uint64_t)v42, v16++, (uint64_t)&v48);
    }
    while (v43 + 1 < HIDWORD(v65));
  }
  sub_100003224((uint64_t)&v59);
  return sub_100003224((uint64_t)&v63);
}

void sub_100023E60(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  sub_100003224(v10 - 176);
  sub_100003224(v10 - 144);
  sub_100003224(a10);
  _Unwind_Resume(a1);
}

uint64_t sub_100023EA8(double a1, double a2, double a3, double a4, uint64_t a5, void *a6, _DWORD *a7, uint64_t a8, int64x2_t *a9)
{
  uint64_t result = sub_100012640((uint64_t)a6, a7, a8, a1, a2, a3, a4);
  if (result)
  {
    *a9 = vdupq_n_s64(0x7FF8000000000000uLL);
    uint64_t v12 = 0x7FF8000000000000;
  }
  else
  {
    a9->i64[0] = a6[9];
    a9->i64[1] = a6[10];
    uint64_t v12 = a6[11];
  }
  a9[1].i64[0] = v12;
  return result;
}

uint64_t sub_100023F0C(uint64_t a1, char a2)
{
  return sub_100012A1C(*(void *)(a1 + 8), a2);
}

uint64_t sub_100023F14(uint64_t a1, uint64_t a2, unsigned int a3, int a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  unsigned int v15 = *(_DWORD *)(a1 + 20);
  double v16 = (double)v15 / (double)a3;
  if (v16 <= 1.0)
  {
    sub_100004500(a6, *(_DWORD *)(a1 + 16), v15);
    memcpy(*(void **)(a6 + 8), *(const void **)(a1 + 8), 8 * *(unsigned int *)(a6 + 16) * (unint64_t)*(unsigned int *)(a6 + 20));
    sub_100004500(a7, *(_DWORD *)(a2 + 16), *(_DWORD *)(a2 + 20));
    memcpy(*(void **)(a7 + 8), *(const void **)(a2 + 8), 8 * *(unsigned int *)(a7 + 16) * (unint64_t)*(unsigned int *)(a7 + 20));
    puts("Bad configuration");
  }
  else
  {
    sub_100015A0C(a1, 0, v29);
    sub_100023910(a8, 0, (uint64_t)v29);
    sub_100015A0C(a2, 0, v29);
    sub_100023910(a9, 0, (uint64_t)v29);
    if (a3)
    {
      uint64_t v25 = a8;
      unsigned int v20 = 0;
      unsigned int v27 = 0;
      unsigned int v21 = 1;
      unsigned int v26 = a3;
      do
      {
        unsigned int v28 = v21;
        signed int v22 = llround(v16 * (double)v21);
        unsigned int v23 = llround(v16 * (double)(v21 - 1)) + 1;
        if ((int)v23 < v22)
        {
          do
          {
            sub_100015A0C(a1, v23, v29);
            sub_100023910(a6, v20, (uint64_t)v29);
            sub_100015A0C(a2, v23, v29);
            sub_100023910(a7, v20, (uint64_t)v29);
            if (a4)
            {
              if (*(_DWORD *)(a5 + 20) * *(_DWORD *)(a5 + 16) <= v23) {
                sub_100075DE0();
              }
              if (*(_DWORD *)(a10 + 20) * *(_DWORD *)(a10 + 16) <= v20) {
                sub_100075DB4();
              }
              *(unsigned char *)(*(void *)(a10 + 8) + v20) = *(unsigned char *)(*(void *)(a5 + 8) + v23);
            }
            ++v20;
            ++v23;
          }
          while (v22 != v23);
        }
        a3 = v26;
        if (v28 == v26) {
          break;
        }
        sub_100015A0C(a1, v22, v29);
        sub_100023910(v25, v27 + 1, (uint64_t)v29);
        sub_100015A0C(a2, v22, v29);
        ++v27;
        a3 = v26;
        sub_100023910(a9, v27, (uint64_t)v29);
        unsigned int v21 = v28 + 1;
      }
      while (v28 + 1 <= v26);
    }
    else
    {
      unsigned int v27 = 0;
    }
    if (v27 + 1 != a3) {
      sub_100075D88();
    }
    if (*(_DWORD *)(a1 + 20) - a3 != *(_DWORD *)(a6 + 20)) {
      sub_100075D5C();
    }
  }
  return 0;
}

void sub_1000241B8(int *a1, uint64_t a2)
{
  if (!a1) {
    sub_100075E0C();
  }
  if (!a2) {
    sub_100075E38();
  }
  int v4 = *a1;
  if (*a1 == 1)
  {
    if (a1[12])
    {
      if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
      {
        int v5 = a1[3];
        int v6 = a1[5];
        int v7 = a1[6];
        int v8 = a1[7];
        int v9 = a1[8];
        int v11 = a1[9];
        int v10 = a1[10];
        *(_DWORD *)buf = 67110656;
        LODWORD(v116) = v5;
        WORD2(v116) = 1024;
        *(_DWORD *)((char *)&v116 + 6) = v6;
        WORD5(v116) = 1024;
        HIDWORD(v116) = v7;
        LOWORD(v117) = 1024;
        *(_DWORD *)((char *)&v117 + 2) = v10;
        HIWORD(v117) = 1024;
        *(_DWORD *)uint64_t v118 = v8;
        *(_WORD *)&v118[4] = 1024;
        *(_DWORD *)&v118[6] = v9;
        __int16 v119 = 1024;
        LODWORD(v120) = v11;
        _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "SPD:#%08d inp: (%4d x %4d) stride = %d, scale = %d x %d, total = %d\n", buf, 0x2Cu);
      }
      for (uint64_t i = 0; i != 16; ++i)
      {
        int v13 = a1[i + 19];
        if (v13 != -1 && (a1[12] & 1) != 0 && os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 134218240;
          *(void *)&long long v116 = i;
          WORD4(v116) = 1024;
          *(_DWORD *)((char *)&v116 + 10) = v13;
          _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "SPD:tuning[%2zu] = %d\n", buf, 0x12u);
        }
      }
    }
    unint64_t v14 = a1[5];
    if (v14)
    {
      a1[2] = 2;
      if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "SPD:ERR: CSPD::SPD pContext->meta.geom.sizeX is not expected as an odd number!!!\n", buf, 2u);
      }
      if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
      {
        int v106 = a1[3];
        int v107 = a1[5];
        int v108 = a1[6];
        int v109 = a1[7];
        int v110 = a1[8];
        int v112 = a1[9];
        int v111 = a1[10];
        *(_DWORD *)buf = 67110656;
        LODWORD(v116) = v106;
        WORD2(v116) = 1024;
        *(_DWORD *)((char *)&v116 + 6) = v107;
        WORD5(v116) = 1024;
        HIDWORD(v116) = v108;
        LOWORD(v117) = 1024;
        *(_DWORD *)((char *)&v117 + 2) = v111;
        HIWORD(v117) = 1024;
        *(_DWORD *)uint64_t v118 = v109;
        *(_WORD *)&v118[4] = 1024;
        *(_DWORD *)&v118[6] = v110;
        __int16 v119 = 1024;
        LODWORD(v120) = v112;
        _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "SPD:ERR: #%d SPD(%d,%d) stride=%d scaleXY(%d,%d) totSize=%d\n", buf, 0x2Cu);
      }
    }
    else
    {
      uint64_t v15 = a1[6];
      uint64_t v16 = (32 * v15);
      uint64_t v17 = a1[10];
      uint64_t v18 = a1[11];
      if ((a1[12] & 1) != 0 && os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 67110400;
        LODWORD(v116) = (2 * v18) | 1;
        WORD2(v116) = 2048;
        *(void *)((char *)&v116 + 6) = 0;
        HIWORD(v116) = 2048;
        uint64_t v117 = 0;
        *(_WORD *)uint64_t v118 = 2048;
        *(void *)&v118[2] = v14;
        __int16 v119 = 2048;
        uint64_t v120 = v15;
        __int16 v121 = 2048;
        uint64_t v122 = v17;
        _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "SPD:SPD: k=%d, (x y)=(%zu %zu), (w h)=(%zu %zu), strideIn=%zu\n", buf, 0x3Au);
      }
      uint64_t v19 = (uint64_t)&a1[v16 + 36];
      uint64_t v114 = (32 * v15);
      uint64_t v113 = v15;
      unint64_t v20 = 0;
      if (v14 >= 0x11)
      {
        uint64_t v21 = 2 * v17;
        unint64_t v22 = (v18 + 1);
        uint64_t v23 = 4 * v16;
        unint64_t v24 = v15 - 1;
        unint64_t v25 = ~v18 + v15;
        uint64_t v26 = v15 - 2;
        uint64_t v27 = (v18 + v22) << 6;
        uint64_t v28 = (v22 << 6) - (v18 << 6) + 128;
        uint64_t v29 = v27 + 4 * v16 + 144;
        uint64_t v30 = 16;
        uint64_t v31 = (v22 << 6) + 4 * v16 - (v18 << 6);
        do
        {
          int v32 = 3 * (v20 >> 1);
          double v33 = (const char *)(a2 + v32);
          int8x8x3_t v123 = vld3_s8(v33);
          uint64_t v34 = (const char *)(a2 + v17 + v32);
          int8x8x3_t v125 = vld3_s8(v34);
          unint64_t v20 = v30;
          int16x8_t v35 = (int16x8_t)vmovl_u8((uint8x8_t)v123.val[1]);
          *(uint16x8_t *)v123.val[1].i8 = vmovl_u8((uint8x8_t)v123.val[2]);
          int16x8_t v36 = (int16x8_t)vshrq_n_u16(*(uint16x8_t *)v123.val[1].i8, 4uLL);
          *(int16x8_t *)v123.val[1].i8 = vsliq_n_s16(*(int16x8_t *)v123.val[1].i8, (int16x8_t)vmovl_u8((uint8x8_t)v123.val[0]), 4uLL);
          uint16x8_t v37 = (uint16x8_t)vsliq_n_s16(v36, v35, 4uLL);
          uint32x4_t v38 = vmovl_u16((uint16x4_t)v123.val[1]);
          uint32x4_t v39 = vmovl_high_u16(*(uint16x8_t *)v123.val[1].i8);
          uint32x4_t v40 = vmovl_u16(*(uint16x4_t *)v37.i8);
          uint32x4_t v41 = vmovl_high_u16(v37);
          *((uint32x4_t *)a1 + 9) = v38;
          *((uint32x4_t *)a1 + 10) = v39;
          *((uint32x4_t *)a1 + 11) = v40;
          *((uint32x4_t *)a1 + 12) = v41;
          int16x8_t v42 = (int16x8_t)vmovl_u8((uint8x8_t)v125.val[1]);
          *(uint16x8_t *)v125.val[1].i8 = vmovl_u8((uint8x8_t)v125.val[2]);
          int16x8_t v43 = (int16x8_t)vshrq_n_u16(*(uint16x8_t *)v125.val[1].i8, 4uLL);
          *(int16x8_t *)v125.val[1].i8 = vsliq_n_s16(*(int16x8_t *)v125.val[1].i8, (int16x8_t)vmovl_u8((uint8x8_t)v125.val[0]), 4uLL);
          uint16x8_t v44 = (uint16x8_t)vsliq_n_s16(v43, v42, 4uLL);
          uint32x4_t v45 = vmovl_u16((uint16x4_t)v125.val[1]);
          uint32x4_t v46 = vmovl_high_u16(*(uint16x8_t *)v125.val[1].i8);
          uint32x4_t v47 = vmovl_u16(*(uint16x4_t *)v44.i8);
          uint32x4_t v48 = vmovl_high_u16(v44);
          *(uint32x4_t *)uint64_t v19 = v45;
          *(uint32x4_t *)(v19 + 16) = v46;
          *(uint32x4_t *)(v19 + 32) = v47;
          *(uint32x4_t *)(v19 + 48) = v48;
          uint64_t v49 = (uint32x4_t *)(a1 + 52);
          int v50 = v33;
          uint64_t v51 = v26;
          if (v24 >= 2)
          {
            do
            {
              long long v52 = &v50[v21];
              int8x8x3_t v126 = vld3_s8(v52);
              uint64_t v53 = &v50[3 * v17];
              int8x8x3_t v127 = vld3_s8(v53);
              int16x8_t v54 = (int16x8_t)vmovl_u8((uint8x8_t)v126.val[0]);
              int16x8_t v55 = (int16x8_t)vmovl_u8((uint8x8_t)v126.val[1]);
              *(uint16x8_t *)v126.val[0].i8 = vmovl_u8((uint8x8_t)v126.val[2]);
              *(uint16x8_t *)v126.val[1].i8 = vshrq_n_u16(*(uint16x8_t *)v126.val[0].i8, 4uLL);
              *(int16x8_t *)v126.val[0].i8 = vsliq_n_s16(*(int16x8_t *)v126.val[0].i8, v54, 4uLL);
              *(int16x8_t *)v126.val[1].i8 = vsliq_n_s16(*(int16x8_t *)v126.val[1].i8, v55, 4uLL);
              uint32x4_t v38 = vaddw_u16(v38, (uint16x4_t)v126.val[0]);
              uint32x4_t v39 = vaddw_high_u16(v39, *(uint16x8_t *)v126.val[0].i8);
              uint32x4_t v40 = vaddw_u16(v40, (uint16x4_t)v126.val[1]);
              uint32x4_t v41 = vaddw_high_u16(v41, *(uint16x8_t *)v126.val[1].i8);
              *uint64_t v49 = v38;
              v49[1] = v39;
              v49[2] = v40;
              v49[3] = v41;
              *(uint16x8_t *)v126.val[0].i8 = vmovl_u8((uint8x8_t)v127.val[0]);
              *(uint16x8_t *)v126.val[2].i8 = vmovl_u8((uint8x8_t)v127.val[2]);
              *(uint16x8_t *)v127.val[0].i8 = vshrq_n_u16(*(uint16x8_t *)v126.val[2].i8, 4uLL);
              *(int16x8_t *)v126.val[2].i8 = vsliq_n_s16(*(int16x8_t *)v126.val[2].i8, *(int16x8_t *)v126.val[0].i8, 4uLL);
              *(int16x8_t *)v127.val[0].i8 = vsliq_n_s16(*(int16x8_t *)v127.val[0].i8, (int16x8_t)vmovl_u8((uint8x8_t)v127.val[1]), 4uLL);
              uint32x4_t v45 = vaddw_u16(v45, (uint16x4_t)v126.val[2]);
              uint32x4_t v46 = vaddw_high_u16(v46, *(uint16x8_t *)v126.val[2].i8);
              uint32x4_t v47 = vaddw_u16(v47, (uint16x4_t)v127.val[0]);
              long long v56 = (uint32x4_t *)((char *)v49 + v23);
              *long long v56 = v45;
              v56[1] = v46;
              uint32x4_t v48 = vaddw_high_u16(v48, *(uint16x8_t *)v127.val[0].i8);
              v56[2] = v47;
              v56[3] = v48;
              v49 += 4;
              int v50 = v52;
              --v51;
            }
            while (v51);
          }
          uint64_t v57 = a1;
          unint64_t v58 = (v18 + 1);
          if (v25 > v22)
          {
            do
            {
              int16x8_t v59 = vshrn_high_n_s32(vshrn_n_s32(vsubq_s32(*(int32x4_t *)((char *)v57 + v27 + 144), *(int32x4_t *)((char *)v57 + v28 - 48)), 3uLL), vsubq_s32(*(int32x4_t *)((char *)v57 + v27 + 160), *(int32x4_t *)((char *)v57 + v28 - 32)), 3uLL);
              int16x8_t v60 = vshrn_high_n_s32(vshrn_n_s32(vsubq_s32(*(int32x4_t *)((char *)v57 + v27 + 176), *(int32x4_t *)((char *)v57 + v28 - 16)), 3uLL), vsubq_s32(*(int32x4_t *)((char *)v57 + v27 + 192), *(int32x4_t *)((char *)v57 + v28)), 3uLL);
              v124.val[0] = vshrn_n_s16(v59, 4uLL);
              v124.val[1] = vshrn_n_s16(v60, 4uLL);
              v124.val[2] = vsli_n_s8(vmovn_s16(v59), vmovn_s16(v60), 4uLL);
              uint64_t v61 = (char *)&v33[2 * v17 * (unint64_t)v22];
              vst3_s8(v61, v124);
              int16x8_t v62 = vshrn_high_n_s32(vshrn_n_s32(vsubq_s32(*(int32x4_t *)((char *)v57 + v29), *(int32x4_t *)((char *)v57 + v31 + 80)), 3uLL), vsubq_s32(*(int32x4_t *)((char *)v57 + v29 + 16), *(int32x4_t *)((char *)v57 + v31 + 96)), 3uLL);
              int16x8_t v63 = vshrn_high_n_s32(vshrn_n_s32(vsubq_s32(*(int32x4_t *)((char *)v57 + v29 + 32), *(int32x4_t *)((char *)v57 + v31 + 112)), 3uLL), vsubq_s32(*(int32x4_t *)((char *)v57 + v29 + 48), *(int32x4_t *)((char *)v57 + v31 + 128)), 3uLL);
              v124.val[0] = vshrn_n_s16(v62, 4uLL);
              v124.val[1] = vshrn_n_s16(v63, 4uLL);
              v124.val[2] = vsli_n_s8(vmovn_s16(v62), vmovn_s16(v63), 4uLL);
              uint64_t v64 = (char *)&v33[((2 * v22) | 1) * v17];
              vst3_s8(v64, v124);
              ++v58;
              v33 += v21;
              v57 += 16;
            }
            while (v58 < v25);
          }
          uint64_t v30 = v20 + 16;
        }
        while (v20 + 16 < v14);
      }
      if (v20 < v14)
      {
        uint64_t v65 = (unsigned __int8 *)(a2 + v20 + (v20 >> 1));
        uint64_t v66 = 2 * v17;
        unint64_t v67 = (v18 + 1);
        unint64_t v68 = ~v18 + v113;
        uint64_t v69 = 4 * v114 + 8 * v67 - 8 * v18 + 140;
        uint64_t v70 = 8 * (v18 + v67) + 148;
        uint64_t v71 = 8 * v67 - 8 * v18 + 136;
        do
        {
          unsigned int v72 = v65[2];
          int v73 = v65[1];
          a1[36] = v72 & 0xF | (16 * *v65);
          a1[37] = (v72 >> 4) | (16 * v73);
          unsigned int v74 = v65[v17 + 2];
          int v75 = v74 & 0xF | (16 * v65[v17]);
          int v76 = (v74 >> 4) | (16 * v65[v17 + 1]);
          *(_DWORD *)uint64_t v19 = v75;
          *(_DWORD *)(v19 + 4) = v76;
          uint64_t v77 = a1 + 36;
          uint64_t v78 = 2 * v17;
          uint64_t v79 = v113 - 2;
          if ((unint64_t)(v113 - 1) >= 2)
          {
            do
            {
              unsigned int v80 = v65[v78 + 2];
              int v81 = (v80 & 0xF | (16 * v65[v78])) + *v77;
              v77[3] = ((v80 >> 4) | (16 * v65[v78 + 1])) + v77[1];
              v77[2] = v81;
              int v82 = v77 + 2;
              int16x8_t v83 = &v77[v114];
              unint64_t v84 = &v65[v78 + v17];
              unsigned int v85 = v84[2];
              int v86 = v85 & 0xF | (16 * *v84);
              LODWORD(v84) = ((v85 >> 4) | (16 * v84[1])) + v83[1];
              v83[2] = v86 + *v83;
              v83[3] = v84;
              v78 += v66;
              uint64_t v77 = v82;
              --v79;
            }
            while (v79);
          }
          uint64_t v87 = v70 + 4 * v114;
          uint64_t v88 = v71;
          uint64_t v89 = v70;
          uint64_t v90 = v69;
          unint64_t v91 = v17 * (unint64_t)(2 * v67);
          for (unint64_t j = v67; j < v68; v87 += 8)
          {
            uint64_t v93 = &v65[v91];
            unsigned int v94 = *(int *)((char *)a1 + v89 - 4) - *(int *)((char *)a1 + v88);
            unsigned int v95 = *(int *)((char *)a1 + v89) - *(int *)((char *)a1 + v88 + 4);
            *uint64_t v93 = v94 >> 7;
            v93[1] = v95 >> 7;
            v93[2] = (2 * v95) & 0xF0 | (v94 >> 3) & 0xF;
            unsigned int v96 = *(int *)((char *)a1 + v87 - 4) - *(int *)((char *)a1 + v90 - 4);
            unsigned int v97 = *(int *)((char *)a1 + v87) - *(int *)((char *)a1 + v90);
            int v98 = &v65[v91 + v17];
            *int v98 = v96 >> 7;
            ++j;
            v91 += v66;
            v90 += 8;
            v98[1] = v97 >> 7;
            v98[2] = (2 * v97) & 0xF0 | (v96 >> 3) & 0xF;
            v89 += 8;
            v88 += 8;
          }
          v65 += 3;
          v20 += 2;
        }
        while (v20 < v14);
      }
      *(_OWORD *)(a1 + 13) = *(_OWORD *)(a1 + 5);
      *(void *)(a1 + 17) = *(void *)(a1 + 9);
      if ((a1[12] & 1) != 0 && os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
      {
        int v99 = a1[3];
        int v100 = a1[13];
        int v101 = a1[14];
        int v102 = a1[15];
        int v103 = a1[16];
        int v105 = a1[17];
        int v104 = a1[18];
        *(_DWORD *)buf = 67110656;
        LODWORD(v116) = v99;
        WORD2(v116) = 1024;
        *(_DWORD *)((char *)&v116 + 6) = v100;
        WORD5(v116) = 1024;
        HIDWORD(v116) = v101;
        LOWORD(v117) = 1024;
        *(_DWORD *)((char *)&v117 + 2) = v104;
        HIWORD(v117) = 1024;
        *(_DWORD *)uint64_t v118 = v102;
        *(_WORD *)&v118[4] = 1024;
        *(_DWORD *)&v118[6] = v103;
        __int16 v119 = 1024;
        LODWORD(v120) = v105;
        _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "SPD:#%08d out: (%4d x %4d) stride = %d, scale = %d x %d, total = %d\n", buf, 0x2Cu);
      }
      a1[2] = 0;
    }
  }
  else
  {
    if ((a1[12] & 1) != 0 && os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 67109376;
      LODWORD(v116) = 1;
      WORD2(v116) = 1024;
      *(_DWORD *)((char *)&v116 + 6) = v4;
      _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "SPD:incompatible context version (expected %d, got %d)\n", buf, 0xEu);
    }
    a1[2] = 1;
  }
}

void sub_100024A70(uint64_t a1)
{
  sub_1000288D0((uint64_t)v1, a1);
}

void sub_100024C94(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,char a32)
{
}

void sub_100024CCC(uint64_t a1, uint64_t a2, long long *a3, uint64_t a4, long long *a5)
{
  if (a5 != (long long *)a1)
  {
    long long v7 = *a5;
    *(void *)(a1 + 16) = *((void *)a5 + 2);
    *(_OWORD *)a1 = v7;
  }
  sub_100025C20(a4, (double *)&v10);
  long long v8 = a3[3];
  long long v14 = a3[2];
  long long v15 = v8;
  uint64_t v16 = *((void *)a3 + 8);
  long long v9 = a3[1];
  long long v12 = *a3;
  long long v13 = v9;
  sub_100028AD0((uint64_t)&v11, a2, 0, -1);
}

void sub_100025AB0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,char a46,uint64_t a47,uint64_t a48,uint64_t a49,char a50,uint64_t a51,uint64_t a52,uint64_t a53,char a54,uint64_t a55,uint64_t a56,uint64_t a57,char a58,uint64_t a59,uint64_t a60,uint64_t a61,char a62,uint64_t a63)
{
  sub_100003224((uint64_t)&a46);
  sub_100003224((uint64_t)&a50);
  sub_100003224((uint64_t)&a54);
  sub_100003224((uint64_t)&a58);
  sub_100003224((uint64_t)&a62);
  sub_100003224((uint64_t)&STACK[0x200]);
  sub_10003B108(&a66);
  sub_100003224(v66);
  _Unwind_Resume(a1);
}

uint64_t sub_100025BDC(uint64_t a1)
{
  return a1;
}

void sub_100025C20(uint64_t a1@<X0>, double *a2@<X8>)
{
  uint64_t v4 = 0;
  *a2 = 0.0;
  a2[1] = 0.0;
  a2[2] = 0.0;
  double v5 = 0.0;
  do
  {
    double v5 = v5 + *(double *)(a1 + v4);
    v4 += 32;
  }
  while (v4 != 96);
  double v6 = (v5 + -1.0) * 0.5;
  long double v7 = 1.0;
  if (v6 <= 1.0)
  {
    long double v7 = v6;
    if (v6 < -1.0) {
      long double v7 = -1.0;
    }
  }
  long double v8 = acos(v7);
  long double v9 = sin(v8);
  double v11 = v9 + v9;
  uint64_t v12 = 0;
  if (v11 <= 0.0000001)
  {
    uint64_t v36 = 0;
    memset(v35, 0, sizeof(v35));
    double v34 = 0.0;
    long long v32 = 0u;
    long long v33 = 0u;
    long long v30 = 0u;
    long long v31 = 0u;
    memset(v29, 0, sizeof(v29));
    uint64_t v17 = v25;
    memset(v25, 0, sizeof(v25));
    uint64_t v26 = 0;
    do
    {
      for (uint64_t i = 0; i != 3; ++i)
      {
        if (v12 == i) {
          *(double *)v10.i64 = 1.0;
        }
        else {
          *(double *)v10.i64 = 0.0;
        }
        *((void *)v17 + i) = v10.i64[0];
      }
      ++v12;
      uint64_t v17 = (_OWORD *)((char *)v17 + 24);
    }
    while (v12 != 3);
    uint64_t v19 = 0;
    uint64_t v20 = 0;
    uint64_t v28 = 0;
    memset(v27, 0, sizeof(v27));
    do
    {
      for (uint64_t j = 0; j != 24; j += 8)
      {
        double v22 = *(double *)((char *)v25 + v19 + j);
        double v23 = *(double *)(a1 + v19 + j) - v22;
        *(double *)((char *)v27 + v19 + j) = v23;
      }
      ++v20;
      v19 += 24;
    }
    while (v20 != 3);
    sub_1000287E8((uint64_t)v27, v35, v29, (double *)&v30, v23, v22, v10);
    long double v24 = v8 * *((double *)&v32 + 1);
    *a2 = v8 * *(double *)&v31;
    a2[1] = v24;
    a2[2] = v8 * v34;
  }
  else
  {
    float64x2_t v13 = *(float64x2_t *)(a1 + 56);
    v13.f64[1] = *(float64_t *)(a1 + 16);
    *(float64x2_t *)a2 = vdivq_f64(vsubq_f64(v13, *(float64x2_t *)(a1 + 40)), (float64x2_t)vdupq_lane_s64(*(uint64_t *)&v11, 0));
    a2[2] = (*(double *)(a1 + 24) - *(double *)(a1 + 8)) / v11;
    double v14 = 0.0;
    do
    {
      double v14 = v14 + *(double *)((char *)a2 + v12) * *(double *)((char *)a2 + v12);
      v12 += 8;
    }
    while (v12 != 24);
    uint64_t v15 = 0;
    double v16 = v8 / sqrt(v14);
    do
    {
      a2[v15] = v16 * a2[v15];
      ++v15;
    }
    while (v15 != 3);
  }
}

uint64_t sub_100025E3C@<X0>(uint64_t a1@<X0>, long long *a2@<X1>, void *a3@<X8>)
{
  uint64_t v6 = 1;
  sub_1000032CC((uint64_t)a3, 1, 4 * *((_DWORD *)a2 + 29));
  *a3 = &off_100095AB0;
  long long v71 = *a2;
  uint64_t v72 = *((void *)a2 + 2);
  sub_100028384((double *)&v71, (uint64_t)&v73);
  long double v7 = (char *)&v73 + 8;
  long double v8 = (char *)v74 + 8;
  do
  {
    uint64_t v9 = 0;
    int8x16_t v10 = v7;
    do
    {
      uint64_t v11 = *(void *)&v8[8 * v9];
      *(void *)&v8[8 * v9] = *v10;
      *int8x16_t v10 = v11;
      v10 += 3;
      ++v9;
    }
    while (v6 != v9);
    ++v6;
    v7 += 8;
    v8 += 24;
  }
  while (v6 != 3);
  v76[2] = v74[1];
  v76[3] = v74[2];
  uint64_t v77 = v75;
  v76[0] = v73;
  v76[1] = v74[0];
  sub_100005A18((uint64_t)a2 + 24, (uint64_t)(a2 + 6), (uint64_t)v68);
  if (v70)
  {
    for (unsigned int i = 0; i < v70; ++i)
    {
      sub_100015A0C((uint64_t)v68, i, &v73);
      uint64_t v13 = 0;
      double v14 = *(double *)v74;
      do
      {
        *(double *)((char *)&v74[-1] + v13) = *(double *)((char *)&v74[-1] + v13) / v14;
        v13 += 8;
      }
      while (v13 != 24);
      sub_100023910((uint64_t)v68, i, (uint64_t)&v73);
    }
  }
  sub_100005A18((uint64_t)v76, (uint64_t)(a2 + 6), (uint64_t)v65);
  uint64_t v15 = 0;
  double v62 = 0.0;
  double v63 = 0.0;
  double v16 = v76;
  double v64 = 0.0;
  do
  {
    uint64_t v17 = 0;
    double v18 = 0.0;
    do
    {
      double v18 = v18 + *(double *)((char *)v16 + v17) * *(double *)(a1 + v17);
      v17 += 8;
    }
    while (v17 != 24);
    *(&v62 + v15++) = v18;
    double v16 = (_OWORD *)((char *)v16 + 24);
  }
  while (v15 != 3);
  double v19 = v62;
  LODWORD(v74[0]) = 1;
  DWORD1(v74[0]) = v67;
  int v59 = 1;
  int v60 = v67;
  char v61 = 0;
  *(void *)&long long v73 = off_100095A80;
  *((void *)&v73 + 1) = 0;
  BYTE8(v74[0]) = 0;
  uint64_t v57 = &off_100095AB0;
  unint64_t v58 = v66;
  sub_100003224((uint64_t)&v73);
  if (v60 >= 1)
  {
    uint64_t v20 = v58;
    unint64_t v21 = (unint64_t)&v58[v60];
    do
    {
      *uint64_t v20 = *v20 - v19;
      ++v20;
    }
    while ((unint64_t)v20 < v21);
  }
  sub_100003224((uint64_t)&v57);
  double v22 = v63;
  LODWORD(v74[0]) = 1;
  DWORD1(v74[0]) = v67;
  int v59 = 1;
  int v60 = v67;
  char v61 = 0;
  *(void *)&long long v73 = off_100095A80;
  *((void *)&v73 + 1) = 0;
  BYTE8(v74[0]) = 0;
  uint64_t v57 = &off_100095AB0;
  unint64_t v58 = &v66[v67];
  sub_100003224((uint64_t)&v73);
  if (v60 * v59 >= 1)
  {
    double v23 = v58;
    unint64_t v24 = (unint64_t)&v58[v60 * v59];
    do
    {
      *double v23 = *v23 - v22;
      ++v23;
    }
    while ((unint64_t)v23 < v24);
  }
  sub_100003224((uint64_t)&v57);
  double v25 = v64;
  LODWORD(v74[0]) = 1;
  DWORD1(v74[0]) = v67;
  int v59 = 1;
  int v60 = v67;
  char v61 = 0;
  *(void *)&long long v73 = off_100095A80;
  *((void *)&v73 + 1) = 0;
  BYTE8(v74[0]) = 0;
  uint64_t v57 = &off_100095AB0;
  unint64_t v58 = &v66[2 * v67];
  sub_100003224((uint64_t)&v73);
  if (v60 * v59 >= 1)
  {
    uint64_t v26 = v58;
    unint64_t v27 = (unint64_t)&v58[v60 * v59];
    do
    {
      *uint64_t v26 = *v26 - v25;
      ++v26;
    }
    while ((unint64_t)v26 < v27);
  }
  sub_100003224((uint64_t)&v57);
  if (v67)
  {
    for (unsigned int j = 0; j < v67; ++j)
    {
      sub_100015A0C((uint64_t)v65, j, &v73);
      uint64_t v29 = 0;
      double v30 = *(double *)v74;
      do
      {
        *(double *)((char *)&v74[-1] + v29) = *(double *)((char *)&v74[-1] + v29) / v30;
        v29 += 8;
      }
      while (v29 != 24);
      sub_100023910((uint64_t)v65, j, (uint64_t)&v73);
    }
  }
  sub_10001CB34(a1 + 88, 0, (uint64_t)v55);
  LODWORD(v74[0]) = 1;
  DWORD1(v74[0]) = v70;
  int v52 = 1;
  unsigned int v53 = v70;
  char v54 = 0;
  *(void *)&long long v73 = off_100095A80;
  *((void *)&v73 + 1) = 0;
  BYTE8(v74[0]) = 0;
  int v50 = &off_100095AB0;
  uint64_t v51 = v69;
  sub_100003224((uint64_t)&v73);
  sub_100028774((uint64_t)v55, (uint64_t)&v50, (uint64_t)&v57);
  sub_100003224((uint64_t)&v50);
  sub_100003224((uint64_t)v55);
  sub_10001CB34(a1 + 88, 1, (uint64_t)&v50);
  LODWORD(v74[0]) = 1;
  DWORD1(v74[0]) = v70;
  int v47 = 1;
  unsigned int v48 = v70;
  char v49 = 0;
  *(void *)&long long v73 = off_100095A80;
  *((void *)&v73 + 1) = 0;
  BYTE8(v74[0]) = 0;
  uint32x4_t v45 = &off_100095AB0;
  uint64_t v46 = v69 + 8 * v70;
  sub_100003224((uint64_t)&v73);
  sub_100028774((uint64_t)&v50, (uint64_t)&v45, (uint64_t)v55);
  sub_100003224((uint64_t)&v45);
  sub_100003224((uint64_t)&v50);
  uint64_t v31 = a1 + 120;
  sub_10001CB34(v31, 0, (uint64_t)&v45);
  LODWORD(v74[0]) = 1;
  DWORD1(v74[0]) = v67;
  int v42 = 1;
  unsigned int v43 = v67;
  char v44 = 0;
  *(void *)&long long v73 = off_100095A80;
  *((void *)&v73 + 1) = 0;
  BYTE8(v74[0]) = 0;
  v41[0] = &off_100095AB0;
  v41[1] = v66;
  sub_100003224((uint64_t)&v73);
  sub_100028774((uint64_t)&v45, (uint64_t)v41, (uint64_t)&v50);
  sub_100003224((uint64_t)v41);
  sub_100003224((uint64_t)&v45);
  sub_10001CB34(v31, 1, (uint64_t)v41);
  LODWORD(v74[0]) = 1;
  DWORD1(v74[0]) = v67;
  int v38 = 1;
  unsigned int v39 = v67;
  char v40 = 0;
  *(void *)&long long v73 = off_100095A80;
  *((void *)&v73 + 1) = 0;
  BYTE8(v74[0]) = 0;
  v37[0] = &off_100095AB0;
  v37[1] = &v66[v67];
  sub_100003224((uint64_t)&v73);
  sub_100028774((uint64_t)v41, (uint64_t)v37, (uint64_t)&v45);
  sub_100003224((uint64_t)v37);
  sub_100003224((uint64_t)v41);
  uint64_t v32 = *((unsigned int *)a2 + 29);
  if (v32)
  {
    unint64_t v33 = 0;
    uint64_t v34 = 8 * v32;
    unsigned int v35 = 1;
    do
    {
      *(double *)(a3[1] + 8 * (v35 - 1)) = v58[v33 / 8];
      *(void *)(a3[1] + 8 * v35) = *(void *)(v56 + v33);
      *(void *)(a3[1] + 8 * (v35 + 1)) = *(void *)(v51 + v33);
      *(void *)(a3[1] + 8 * (v35 + 2)) = *(void *)(v46 + v33);
      v33 += 8;
      v35 += 4;
    }
    while (v34 != v33);
  }
  sub_100003224((uint64_t)&v45);
  sub_100003224((uint64_t)&v50);
  sub_100003224((uint64_t)v55);
  sub_100003224((uint64_t)&v57);
  sub_100003224((uint64_t)v65);
  return sub_100003224((uint64_t)v68);
}

void sub_100026548(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,char a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26,uint64_t a27,uint64_t a28,uint64_t a29,char a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,char a37,uint64_t a38,uint64_t a39,uint64_t a40,char a41)
{
  sub_100003224((uint64_t)&a10);
  sub_100003224((uint64_t)&a14);
  sub_100003224((uint64_t)&a22);
  sub_100003224((uint64_t)&a26);
  sub_100003224((uint64_t)&a30);
  sub_100003224((uint64_t)&a37);
  sub_100003224((uint64_t)&a41);
  sub_100003224(v41);
  _Unwind_Resume(a1);
}

uint64_t sub_100026608(double *a1, long long *a2, void *a3, uint64_t a4)
{
  long long v262 = *a2;
  uint64_t v263 = *((void *)a2 + 2);
  sub_100028384((double *)&v262, (uint64_t)&v264);
  double v8 = *(double *)a2;
  double v200 = *((double *)a2 + 2);
  double v202 = *((double *)a2 + 1);
  double v198 = *((double *)a2 + 3);
  sub_10001CA74((uint64_t)(a2 + 6), 0, (uint64_t)v258);
  sub_10001CA74((uint64_t)(a2 + 6), 1, (uint64_t)v254);
  sub_10001CA74((uint64_t)(a2 + 6), 2, (uint64_t)v250);
  sub_10001CB34((uint64_t)(a1 + 11), 0, (uint64_t)v249);
  sub_10001CB34((uint64_t)(a1 + 11), 1, (uint64_t)v248);
  sub_10001CB34((uint64_t)(a1 + 15), 0, (uint64_t)v247);
  sub_10001CB34((uint64_t)(a1 + 15), 1, (uint64_t)v246);
  double v9 = v264;
  sub_1000032CC((uint64_t)&v219, v260, v261);
  if (v261 * v260 >= 1)
  {
    int8x16_t v10 = v259;
    unint64_t v11 = (unint64_t)&v259[v261 * v260];
    uint64_t v12 = v220;
    do
    {
      double v13 = *v10++;
      *v12++ = v9 * v13;
    }
    while ((unint64_t)v10 < v11);
  }
  double v14 = v267;
  sub_1000032CC((uint64_t)v215, v256, v257);
  if (v257 * v256 >= 1)
  {
    uint64_t v15 = v255;
    unint64_t v16 = (unint64_t)&v255[v257 * v256];
    uint64_t v17 = v216;
    do
    {
      double v18 = *v15++;
      *v17++ = v14 * v18;
    }
    while ((unint64_t)v15 < v16);
  }
  sub_1000280C4((uint64_t)&v219, (uint64_t)v215, (uint64_t)&v223);
  double v19 = v270;
  sub_1000032CC((uint64_t)&v211, v252, v253);
  if (v253 * v252 >= 1)
  {
    uint64_t v20 = v251;
    unint64_t v21 = (unint64_t)&v251[v253 * v252];
    double v22 = v212;
    do
    {
      double v23 = *v20++;
      *v22++ = v19 * v23;
    }
    while ((unint64_t)v20 < v21);
  }
  sub_1000280C4((uint64_t)&v223, (uint64_t)&v211, (uint64_t)v227);
  double v24 = *a1;
  sub_1000032CC((uint64_t)&v231, v229, v230);
  if (v230 * v229 >= 1)
  {
    double v25 = v228;
    unint64_t v26 = (unint64_t)&v228[v230 * v229];
    unint64_t v27 = v232;
    do
    {
      double v28 = *v25++;
      *v27++ = v28 - v9 * v24;
    }
    while ((unint64_t)v25 < v26);
  }
  double v29 = a1[1];
  sub_1000032CC((uint64_t)&v236, v233, v234);
  if (v234 * v233 >= 1)
  {
    double v30 = v232;
    unint64_t v31 = (unint64_t)&v232[v234 * v233];
    uint64_t v32 = v237;
    do
    {
      double v33 = *v30++;
      *v32++ = v33 - v14 * v29;
    }
    while ((unint64_t)v30 < v31);
  }
  double v34 = a1[2];
  sub_1000032CC((uint64_t)&v273, v238, v239);
  if (v239 * v238 >= 1)
  {
    unsigned int v35 = v237;
    unint64_t v36 = (unint64_t)&v237[v239 * v238];
    uint16x8_t v37 = v274;
    do
    {
      double v38 = *v35++;
      *v37++ = v38 - v19 * v34;
    }
    while ((unint64_t)v35 < v36);
  }
  unsigned int v39 = v274;
  int v244 = v276;
  char v245 = v277;
  v274 = 0;
  char v277 = 0;
  __n128 v241 = &off_100095AB0;
  __n128 v242 = v39;
  int v243 = 1;
  sub_100003224((uint64_t)&v273);
  sub_100003224((uint64_t)&v236);
  sub_100003224((uint64_t)&v231);
  sub_100003224((uint64_t)v227);
  sub_100003224((uint64_t)&v211);
  sub_100003224((uint64_t)&v223);
  sub_100003224((uint64_t)v215);
  sub_100003224((uint64_t)&v219);
  double v40 = v265;
  sub_1000032CC((uint64_t)v215, v260, v261);
  if (v261 * v260 >= 1)
  {
    uint64_t v41 = v259;
    unint64_t v42 = (unint64_t)&v259[v261 * v260];
    unsigned int v43 = v216;
    do
    {
      double v44 = *v41++;
      *v43++ = v40 * v44;
    }
    while ((unint64_t)v41 < v42);
  }
  double v45 = v268;
  sub_1000032CC((uint64_t)&v211, v256, v257);
  if (v257 * v256 >= 1)
  {
    uint64_t v46 = v255;
    unint64_t v47 = (unint64_t)&v255[v257 * v256];
    unsigned int v48 = v212;
    do
    {
      double v49 = *v46++;
      *v48++ = v45 * v49;
    }
    while ((unint64_t)v46 < v47);
  }
  sub_1000280C4((uint64_t)v215, (uint64_t)&v211, (uint64_t)&v219);
  double v50 = v271;
  sub_1000032CC((uint64_t)v209, v252, v253);
  if (v253 * v252 >= 1)
  {
    uint64_t v51 = v251;
    unint64_t v52 = (unint64_t)&v251[v253 * v252];
    unsigned int v53 = v210;
    do
    {
      double v54 = *v51++;
      *v53++ = v50 * v54;
    }
    while ((unint64_t)v51 < v52);
  }
  sub_1000280C4((uint64_t)&v219, (uint64_t)v209, (uint64_t)&v223);
  double v55 = *a1;
  sub_1000032CC((uint64_t)v227, v225, SHIDWORD(v225));
  if (HIDWORD(v225) * (int)v225 >= 1)
  {
    uint64_t v56 = v224;
    unint64_t v57 = (unint64_t)&v224[HIDWORD(v225) * (int)v225];
    unint64_t v58 = v228;
    do
    {
      double v59 = *v56++;
      *v58++ = v59 - v40 * v55;
    }
    while ((unint64_t)v56 < v57);
  }
  double v60 = a1[1];
  sub_1000032CC((uint64_t)&v231, v229, v230);
  if (v230 * v229 >= 1)
  {
    char v61 = v228;
    unint64_t v62 = (unint64_t)&v228[v230 * v229];
    double v63 = v232;
    do
    {
      double v64 = *v61++;
      *v63++ = v64 - v45 * v60;
    }
    while ((unint64_t)v61 < v62);
  }
  double v65 = a1[2];
  sub_1000032CC((uint64_t)&v273, v233, v234);
  if (v234 * v233 >= 1)
  {
    uint64_t v66 = v232;
    unint64_t v67 = (unint64_t)&v232[v234 * v233];
    unint64_t v68 = v274;
    do
    {
      double v69 = *v66++;
      *v68++ = v69 - v50 * v65;
    }
    while ((unint64_t)v66 < v67);
  }
  unsigned int v70 = v274;
  int v239 = v276;
  char v240 = v277;
  v274 = 0;
  char v277 = 0;
  uint64_t v236 = &off_100095AB0;
  uint64_t v237 = v70;
  int v238 = 1;
  sub_100003224((uint64_t)&v273);
  sub_100003224((uint64_t)&v231);
  sub_100003224((uint64_t)v227);
  sub_100003224((uint64_t)&v223);
  sub_100003224((uint64_t)v209);
  sub_100003224((uint64_t)&v219);
  sub_100003224((uint64_t)&v211);
  sub_100003224((uint64_t)v215);
  double v71 = v266;
  sub_1000032CC((uint64_t)&v211, v260, v261);
  if (v261 * v260 >= 1)
  {
    uint64_t v72 = v259;
    unint64_t v73 = (unint64_t)&v259[v261 * v260];
    unsigned int v74 = v212;
    do
    {
      double v75 = *v72++;
      *v74++ = v71 * v75;
    }
    while ((unint64_t)v72 < v73);
  }
  double v76 = v269;
  sub_1000032CC((uint64_t)v209, v256, v257);
  if (v257 * v256 >= 1)
  {
    uint64_t v77 = v255;
    unint64_t v78 = (unint64_t)&v255[v257 * v256];
    uint64_t v79 = v210;
    do
    {
      double v80 = *v77++;
      *v79++ = v76 * v80;
    }
    while ((unint64_t)v77 < v78);
  }
  sub_1000280C4((uint64_t)&v211, (uint64_t)v209, (uint64_t)v215);
  double v81 = v272;
  sub_1000032CC((uint64_t)v207, v252, v253);
  if (v253 * v252 >= 1)
  {
    int v82 = v251;
    unint64_t v83 = (unint64_t)&v251[v253 * v252];
    unint64_t v84 = v208;
    do
    {
      double v85 = *v82++;
      *v84++ = v81 * v85;
    }
    while ((unint64_t)v82 < v83);
  }
  sub_1000280C4((uint64_t)v215, (uint64_t)v207, (uint64_t)&v219);
  double v86 = *a1;
  sub_1000032CC((uint64_t)&v223, v221, SHIDWORD(v221));
  if (HIDWORD(v221) * (int)v221 >= 1)
  {
    uint64_t v87 = v220;
    unint64_t v88 = (unint64_t)&v220[HIDWORD(v221) * (int)v221];
    uint64_t v89 = v224;
    do
    {
      double v90 = *v87++;
      *v89++ = v90 - v71 * v86;
    }
    while ((unint64_t)v87 < v88);
  }
  double v91 = a1[1];
  sub_1000032CC((uint64_t)v227, v225, SHIDWORD(v225));
  if (HIDWORD(v225) * (int)v225 >= 1)
  {
    uint64_t v92 = v224;
    unint64_t v93 = (unint64_t)&v224[HIDWORD(v225) * (int)v225];
    unsigned int v94 = v228;
    do
    {
      double v95 = *v92++;
      *v94++ = v95 - v76 * v91;
    }
    while ((unint64_t)v92 < v93);
  }
  double v96 = a1[2];
  sub_1000032CC((uint64_t)&v273, v229, v230);
  if (v230 * v229 >= 1)
  {
    unsigned int v97 = v228;
    unint64_t v98 = (unint64_t)&v228[v230 * v229];
    int v99 = v274;
    do
    {
      double v100 = *v97++;
      *v99++ = v100 - v81 * v96;
    }
    while ((unint64_t)v97 < v98);
  }
  int v101 = v274;
  int v234 = v276;
  char v235 = v277;
  v274 = 0;
  char v277 = 0;
  v231 = &off_100095AB0;
  uint64_t v232 = v101;
  int v233 = 1;
  sub_100003224((uint64_t)&v273);
  sub_100003224((uint64_t)v227);
  sub_100003224((uint64_t)&v223);
  sub_100003224((uint64_t)&v219);
  sub_100003224((uint64_t)v207);
  sub_100003224((uint64_t)v215);
  sub_100003224((uint64_t)v209);
  sub_100003224((uint64_t)&v211);
  sub_10002868C((uint64_t)&v231, (uint64_t)&v231, (uint64_t)v227);
  uint64_t v102 = 0;
  double v103 = 0.0;
  do
  {
    double v103 = v103 + *(double *)((char *)a2 + v102) * *(double *)((char *)a2 + v102);
    v102 += 8;
  }
  while (v102 != 24);
  double v104 = sqrt(v103);
  if (v104 == 0.0)
  {
    double v105 = 1.0;
    double v107 = 0.5;
  }
  else
  {
    double v105 = sin(v104) / v104;
    long double v106 = sin(v104 * 0.5);
    double v107 = v106 / v104 * (v106 / v104 + v106 / v104);
  }
  uint64_t v108 = *((unsigned int *)a2 + 29);
  uint64_t v225 = 1;
  char v226 = 0;
  uint64_t v223 = &off_100095AB0;
  uint64_t v224 = 0;
  uint64_t v221 = 1;
  char v222 = 0;
  uint64_t v219 = &off_100095AB0;
  uint64_t v220 = 0;
  sub_1000032CC((uint64_t)v215, 2, v108);
  uint64_t v109 = 8 * v108;
  if (*((unsigned char *)a2 + 128))
  {
    int v275 = 1;
    int v276 = v218;
    LODWORD(v213) = 1;
    HIDWORD(v213) = v218;
    char v214 = 0;
    v273 = off_100095A80;
    v274 = 0;
    char v277 = 0;
    uint64_t v211 = &off_100095AB0;
    v212 = v216;
    sub_100003224((uint64_t)&v273);
    if (v226 && v224) {
      operator delete[]();
    }
    uint64_t v225 = v213;
    uint64_t v224 = v212;
    char v226 = v214;
    char v214 = 0;
    sub_100003224((uint64_t)&v211);
    int v275 = 1;
    int v276 = v218;
    LODWORD(v213) = 1;
    HIDWORD(v213) = v218;
    char v214 = 0;
    v273 = off_100095A80;
    v274 = 0;
    char v277 = 0;
    uint64_t v211 = &off_100095AB0;
    v212 = &v216[v218];
    sub_100003224((uint64_t)&v273);
    if (v222 && v220) {
      operator delete[]();
    }
    uint64_t v221 = v213;
    uint64_t v220 = v212;
    char v222 = v214;
    char v214 = 0;
    sub_100003224((uint64_t)&v211);
    if (v108)
    {
      unint64_t v110 = 0;
      do
      {
        v224[v110 / 8] = -v259[v110 / 8] / v251[v110 / 8];
        v220[v110 / 8] = -v255[v110 / 8] / v251[v110 / 8];
        v110 += 8;
      }
      while (v109 != v110);
    }
  }
  if (v104 == 0.0)
  {
    double v115 = v8;
    double v116 = 1.0;
    double v112 = 0.0;
    double v114 = 0.0;
    double v117 = 1.0;
    double v118 = 1.0;
  }
  else
  {
    __double2 v111 = __sincos_stret(v104);
    double v112 = -(v111.__sinval - v104 * v111.__cosval) / (v104 * v104);
    long double v113 = sin(v104 * 0.5);
    double v114 = (v104 * -4.0 * (v113 * v113) + v104 * v104 * v111.__sinval) / pow(v104, 4.0);
    double v115 = v8;
    double v116 = v8 / v104;
    double v117 = v202 / v104;
    double v118 = v200 / v104;
  }
  sub_100028700((uint64_t)v258, (uint64_t)&v211, *a1);
  sub_100028700((uint64_t)v254, (uint64_t)v209, a1[1]);
  sub_100028700((uint64_t)v250, (uint64_t)v207, a1[2]);
  double v120 = v200;
  double v119 = v202;
  double v121 = v120 * v120 + v119 * v119;
  double v122 = v120 * v120 + v115 * v115;
  double v123 = v105 + v115 * (v112 * v116);
  double v124 = v119 * v119 + v115 * v115;
  v288[0] = -(v121 * (v114 * v116));
  v288[1] = -(v121 * (v114 * v117) + (v119 + v119) * v107);
  v287[0] = v202 * v107 + v200 * (v112 * v116) + v115 * v202 * (v114 * v116);
  v287[1] = v115 * v107 + v200 * (v112 * v117) + v115 * v202 * (v114 * v117);
  double v125 = v105 + v202 * (v112 * v117);
  v286[0] = v200 * v107 - v202 * (v112 * v116) + v115 * v200 * (v114 * v116);
  v286[1] = -(v125 - v115 * v200 * (v114 * v117));
  v285[0] = v202 * v107 - v200 * (v112 * v116) + v115 * v202 * (v114 * v116);
  v285[1] = v115 * v107 - v200 * (v112 * v117) + v115 * v202 * (v114 * v117);
  v284[0] = -(v122 * (v114 * v116) + (v115 + v115) * v107);
  v284[1] = -(v122 * (v114 * v117));
  v283[0] = v123 + v202 * v200 * (v114 * v116);
  v283[1] = v200 * v107 + v115 * (v112 * v117) + v202 * v200 * (v114 * v117);
  v282[0] = v200 * v107 + v202 * (v112 * v116) + v115 * v200 * (v114 * v116);
  v282[1] = v125 + v115 * v200 * (v114 * v117);
  v281[0] = -(v123 - v202 * v200 * (v114 * v116));
  v281[1] = v200 * v107 - v115 * (v112 * v117) + v202 * v200 * (v114 * v117);
  v280[0] = -(v124 * (v114 * v116) + (v115 + v115) * v107);
  v280[1] = -(v124 * (v114 * v117) + (v119 + v119) * v107);
  v288[2] = -(v121 * (v114 * v118) + (v120 + v120) * v107);
  double v126 = v105 + v200 * (v112 * v118);
  v287[2] = v126 + v115 * v202 * (v114 * v118);
  v286[2] = v115 * v107 - v202 * (v112 * v118) + v115 * v200 * (v114 * v118);
  v285[2] = -(v126 - v115 * v202 * (v114 * v118));
  v284[2] = -(v122 * (v114 * v118) + (v120 + v120) * v107);
  v283[2] = v202 * v107 + v115 * (v112 * v118) + v202 * v200 * (v114 * v118);
  v282[2] = v115 * v107 + v202 * (v112 * v118) + v115 * v200 * (v114 * v118);
  v281[2] = v202 * v107 - v115 * (v112 * v118) + v202 * v200 * (v114 * v118);
  v280[2] = -(v124 * (v114 * v118));
  sub_1000032CC((uint64_t)&v273, 2, v108);
  sub_1000032CC((uint64_t)&v278, 2, v108);
  sub_1000032CC((uint64_t)&v279, 2, v108);
  for (uint64_t i = 0; i != 3; ++i)
  {
    sub_10001CB34((uint64_t)&(&v273)[4 * i], 0, (uint64_t)&v203);
    if (v226 && v224) {
      operator delete[]();
    }
    uint64_t v225 = v205;
    uint64_t v224 = v204;
    char v226 = v206;
    char v206 = 0;
    sub_100003224((uint64_t)&v203);
    sub_10001CB34((uint64_t)&(&v273)[4 * i], 1, (uint64_t)&v203);
    if (v222 && v220) {
      operator delete[]();
    }
    uint64_t v221 = v205;
    uint64_t v220 = v204;
    char v222 = v206;
    char v206 = 0;
    sub_100003224((uint64_t)&v203);
    if (v108)
    {
      unint64_t v128 = 0;
      double v129 = v288[i];
      double v130 = v287[i];
      double v131 = v286[i];
      double v132 = v285[i];
      double v133 = v284[i];
      double v134 = v283[i];
      double v135 = v282[i];
      double v136 = v281[i];
      double v137 = v280[i];
      do
      {
        double v138 = v212[v128 / 8];
        double v139 = v210[v128 / 8];
        double v140 = v208[v128 / 8];
        double v141 = v139 * v130 + v138 * v129 + v140 * v131;
        double v142 = v139 * v133 + v138 * v132;
        double v143 = v139 * v136 + v138 * v135 + v140 * v137;
        v224[v128 / 8] = -(v141 * v232[v128 / 8] - v143 * v242[v128 / 8]) / v228[v128 / 8];
        v220[v128 / 8] = -((v142 + v140 * v134) * v232[v128 / 8] - v143 * v237[v128 / 8]) / v228[v128 / 8];
        v128 += 8;
      }
      while (v109 != v128);
    }
  }
  sub_10003B57C((uint64_t)a3);
  int v144 = sub_10003B1DC((uint64_t)a3);
  sub_1000032CC((uint64_t)&v203, 1, v144);
  v203 = &off_100095AB0;
  sub_10000316C(a4, (uint64_t)&v203);
  sub_100003224((uint64_t)&v203);
  bzero(*(void **)(a4 + 8), 8 * (*(_DWORD *)(a4 + 20) * *(_DWORD *)(a4 + 16)));
  if (v108)
  {
    for (unint64_t j = 0; j != v108; ++j)
    {
      int v146 = 4 * j;
      if (*((unsigned char *)a2 + 128))
      {
        if (!v217 || j >= v218) {
          __assert_rtn("operator()", "Matrix.hpp", 119, "row < m_rows && col < m_cols");
        }
        if (v217 <= 1) {
          __assert_rtn("operator()", "Matrix.hpp", 119, "row < m_rows && col < m_cols");
        }
        int v147 = &v216[j];
        double v148 = *v147;
        double v149 = v147[v218];
        sub_10003B130(a3, 4 * j, 3, *v147);
        sub_10003B130(a3, v146 | 1, 3, v149);
        *(double *)(*(void *)(a4 + 8) + 24) = *(double *)(*(void *)(a4 + 8) + 24) + v148 * v148;
        *(double *)(*(void *)(a4 + 8) + 24) = *(double *)(*(void *)(a4 + 8) + 24) + v149 * v149;
      }
      uint64_t v150 = 0;
      int v151 = v146 | 2;
      int v152 = v146 | 3;
      __int16 v153 = &v276;
      do
      {
        unsigned int v154 = *(v153 - 1);
        if (!v154 || (unint64_t v155 = *v153, j >= v155)) {
          __assert_rtn("operator()", "Matrix.hpp", 119, "row < m_rows && col < m_cols");
        }
        if (v154 <= 1) {
          __assert_rtn("operator()", "Matrix.hpp", 119, "row < m_rows && col < m_cols");
        }
        BOOL v156 = (double *)(*(void *)(v153 - 3) + 8 * j);
        double v157 = *v156;
        double v158 = v156[v155];
        sub_10003B130(a3, v151, v150, *v156);
        sub_10003B130(a3, v152, v150, v158);
        *(double *)(*(void *)(a4 + 8) + 8 * v150) = *(double *)(*(void *)(a4 + 8) + 8 * v150) + v157 * v157;
        *(double *)(*(void *)(a4 + 8) + 8 * v150) = *(double *)(*(void *)(a4 + 8) + 8 * v150) + v158 * v158;
        ++v150;
        v153 += 8;
      }
      while (v150 != 3);
    }
    unint64_t v159 = 0;
    double v197 = v264;
    double v195 = v267;
    double v196 = v265;
    double v160 = -v269;
    double v199 = -v272;
    double v201 = -v266;
    double v193 = v270;
    double v194 = v268;
    double v192 = v271;
    int v161 = 3;
    int v162 = 1;
    do
    {
      int v163 = *((unsigned __int8 *)a2 + 128);
      double v164 = -v198 / v251[v159 / 8];
      double v165 = v232[v159 / 8];
      double v166 = v242[v159 / 8];
      double v167 = v228[v159 / 8];
      double v168 = v237[v159 / 8];
      sub_10003B130(a3, v162 - 1, v161 + v163, v164);
      double v169 = -(v166 * v201 + v197 * v165) / v167;
      sub_10003B130(a3, v162 + 1, v161 + v163, v169);
      double v170 = -(v168 * v201 + v196 * v165) / v167;
      sub_10003B130(a3, v162 + 2, v161 + v163, v170);
      *(double *)(*(void *)(a4 + 8) + 8 * (v161 + v163)) = v169 * v169 + v164 * v164 + v170 * v170;
      double v171 = v232[v159 / 8];
      double v172 = v242[v159 / 8];
      double v173 = v228[v159 / 8];
      double v174 = v237[v159 / 8];
      sub_10003B130(a3, v162, v161 + v163 + 1, v164);
      double v175 = -(v172 * v160 + v195 * v171) / v173;
      sub_10003B130(a3, v162 + 1, v161 + v163 + 1, v175);
      double v176 = -(v174 * v160 + v194 * v171) / v173;
      sub_10003B130(a3, v162 + 2, v161 + v163 + 1, v176);
      *(double *)(*(void *)(a4 + 8) + 8 * (v161 + v163 + 1)) = v175 * v175 + v164 * v164 + v176 * v176;
      double v177 = v198 / (v251[v159 / 8] * v251[v159 / 8]);
      double v178 = v177 * v259[v159 / 8];
      double v179 = v255[v159 / 8];
      double v180 = v232[v159 / 8];
      double v181 = v242[v159 / 8];
      double v182 = v228[v159 / 8];
      double v183 = v237[v159 / 8];
      sub_10003B130(a3, v162 - 1, v161 + v163 + 2, v178);
      double v184 = v177 * v179;
      sub_10003B130(a3, v162, v161 + v163 + 2, v184);
      double v185 = -(v181 * v199 + v193 * v180) / v182;
      sub_10003B130(a3, v162 + 1, v161 + v163 + 2, v185);
      double v186 = -(v183 * v199 + v192 * v180) / v182;
      sub_10003B130(a3, v162 + 2, v161 + v163 + 2, v186);
      *(double *)(*(void *)(a4 + 8) + 8 * (v161 + v163 + 2)) = v184 * v184
                                                                               + v178 * v178
                                                                               + v185 * v185
                                                                               + v186 * v186;
      v161 += 3;
      v162 += 4;
      v159 += 8;
    }
    while (v109 != v159);
  }
  uint64_t v187 = *(unsigned int *)(a4 + 20);
  if (v187)
  {
    uint64_t v188 = 0;
    uint64_t v189 = 8 * v187;
    do
    {
      *(double *)(*(void *)(a4 + 8) + v188) = sqrt(*(double *)(*(void *)(a4 + 8) + v188));
      v188 += 8;
    }
    while (v189 != v188);
  }
  for (uint64_t k = 8; k != -4; k -= 4)
    sub_100003224((uint64_t)&(&v273)[k]);
  sub_100003224((uint64_t)v207);
  sub_100003224((uint64_t)v209);
  sub_100003224((uint64_t)&v211);
  sub_100003224((uint64_t)v215);
  sub_100003224((uint64_t)&v219);
  sub_100003224((uint64_t)&v223);
  sub_100003224((uint64_t)v227);
  sub_100003224((uint64_t)&v231);
  sub_100003224((uint64_t)&v236);
  sub_100003224((uint64_t)&v241);
  sub_100003224((uint64_t)v246);
  sub_100003224((uint64_t)v247);
  sub_100003224((uint64_t)v248);
  sub_100003224((uint64_t)v249);
  sub_100003224((uint64_t)v250);
  sub_100003224((uint64_t)v254);
  return sub_100003224((uint64_t)v258);
}

void sub_100027AD0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,char a25,uint64_t a26,uint64_t a27,uint64_t a28,char a29,uint64_t a30,uint64_t a31,uint64_t a32,char a33,uint64_t a34,uint64_t a35,uint64_t a36,char a37,uint64_t a38,uint64_t a39,uint64_t a40,char a41,uint64_t a42,uint64_t a43,uint64_t a44,char a45,uint64_t a46,uint64_t a47,uint64_t a48,char a49,uint64_t a50,uint64_t a51,uint64_t a52,char a53,uint64_t a54,uint64_t a55,uint64_t a56,char a57,uint64_t a58,uint64_t a59,uint64_t a60,char a61,uint64_t a62,uint64_t a63)
{
  for (uint64_t i = 64; i != -32; i -= 32)
    sub_100003224((uint64_t)&STACK[0x308] + i);
  sub_100003224((uint64_t)&a25);
  sub_100003224((uint64_t)&a29);
  sub_100003224((uint64_t)&a33);
  sub_100003224((uint64_t)&a37);
  sub_100003224((uint64_t)&a41);
  sub_100003224((uint64_t)&a45);
  sub_100003224((uint64_t)&a49);
  sub_100003224((uint64_t)&a53);
  sub_100003224((uint64_t)&a57);
  sub_100003224((uint64_t)&a61);
  sub_100003224((uint64_t)&a65);
  sub_100003224((uint64_t)&a69);
  sub_100003224((uint64_t)&STACK[0x200]);
  sub_100003224((uint64_t)&STACK[0x220]);
  sub_100003224((uint64_t)&STACK[0x240]);
  sub_100003224((uint64_t)&STACK[0x260]);
  sub_100003224((uint64_t)&STACK[0x280]);
  _Unwind_Resume(a1);
}

void sub_100027D94(double a1, uint64_t a2, void *a3, uint64_t a4, uint64_t a5, int a6)
{
  int v11 = sub_10003B1D4((uint64_t)a3);
  sub_10003B15C((uint64_t)a3, a6, 1uLL);
  if (a6 >= 1)
  {
    uint64_t v12 = 0;
    double v13 = sqrt(a1);
    do
    {
      sub_10003B130(a3, v11 + v12, v12, v13 * *(double *)(*(void *)(a5 + 8) + 8 * v12));
      ++v12;
    }
    while (a6 != v12);
  }
  sub_1000032CC((uint64_t)&v15, 1, *(_DWORD *)(a4 + 20) + a6);
  uint64_t v15 = &off_100095AB0;
  bzero(__dst, 8 * (v18 * v17));
  memcpy(__dst, *(const void **)(a4 + 8), 8 * *(unsigned int *)(a4 + 20));
  sub_1000020E8((uint64_t)a3, v14);
}

void sub_100027F34(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  sub_100003224(v9);
  sub_100003224((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_100027F74@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>, double a3@<D0>)
{
  sub_100028C20(a1, (uint64_t)&v7, a3);
  uint64_t v4 = v8;
  int v5 = v9;
  *(unsigned char *)(a2 + 24) = v10;
  uint64_t v8 = 0;
  char v10 = 0;
  *(void *)a2 = &off_100095AB0;
  *(void *)(a2 + 8) = v4;
  *(_DWORD *)(a2 + 16) = 1;
  *(_DWORD *)(a2 + 20) = v5;
  return sub_100003224((uint64_t)&v7);
}

uint64_t sub_100027FE8@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>, double a3@<D0>)
{
  sub_100028C88(a1, (uint64_t)&v7, a3);
  uint64_t v4 = v8;
  int v5 = v9;
  *(unsigned char *)(a2 + 24) = v10;
  uint64_t v8 = 0;
  char v10 = 0;
  *(void *)a2 = &off_100095AB0;
  *(void *)(a2 + 8) = v4;
  *(_DWORD *)(a2 + 16) = 1;
  *(_DWORD *)(a2 + 20) = v5;
  return sub_100003224((uint64_t)&v7);
}

uint64_t sub_10002805C@<X0>(uint64_t result@<X0>, uint64_t a2@<X1>, double *a3@<X8>)
{
  *a3 = 0.0;
  if (*(_DWORD *)(a2 + 16)) {
    BOOL v3 = *(_DWORD *)(a2 + 20) == 0;
  }
  else {
    BOOL v3 = 1;
  }
  char v4 = v3;
  if (!*(_DWORD *)(result + 16) || (int v5 = *(_DWORD *)(result + 20)) == 0) {
    sub_1000741C0();
  }
  if (v4) {
    sub_1000741C0();
  }
  uint64_t v6 = *(double **)(a2 + 8);
  uint64_t v7 = *(double **)(result + 8);
  double v8 = 0.0;
  do
  {
    double v9 = *v7++;
    double v10 = v9;
    double v11 = *v6++;
    double v8 = v8 + v10 * v11;
    --v5;
  }
  while (v5);
  *a3 = v8;
  return result;
}

double sub_1000280C4@<D0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  int v4 = *(_DWORD *)(a2 + 20);
  if (v4 != *(_DWORD *)(a1 + 20) || (int v6 = *(_DWORD *)(a2 + 16), v6 != *(_DWORD *)(a1 + 16))) {
    sub_100075C84();
  }
  uint64_t v7 = sub_1000032CC(a3, v6, v4);
  int v9 = *(_DWORD *)(a1 + 20) * *(_DWORD *)(a1 + 16);
  if (v9 >= 1)
  {
    double v10 = *(double **)(a1 + 8);
    double v11 = &v10[v9];
    uint64_t v12 = *(double **)(v7 + 8);
    double v13 = *(double **)(a2 + 8);
    do
    {
      double v14 = *v10++;
      double v15 = v14;
      double v16 = *v13++;
      double result = v15 + v16;
      *v12++ = result;
    }
    while (v10 < v11);
  }
  return result;
}

uint64_t sub_10002814C@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  sub_1000280C4(a1, a2, (uint64_t)&v7);
  uint64_t v4 = v8;
  int v5 = v9;
  *(unsigned char *)(a3 + 24) = v10;
  uint64_t v8 = 0;
  char v10 = 0;
  *(void *)a3 = &off_100095AB0;
  *(void *)(a3 + 8) = v4;
  *(_DWORD *)(a3 + 16) = 1;
  *(_DWORD *)(a3 + 20) = v5;
  return sub_100003224((uint64_t)&v7);
}

double sub_1000281C0(uint64_t a1, uint64_t a2)
{
  double v4 = *(double *)(a1 + 8);
  *(double *)a1 = **(double **)(a2 + 8) + *(double *)a1;
  *(double *)(a1 + 8) = *(double *)(*(void *)(a2 + 8) + 8) + v4;
  *(double *)(a1 + 16) = *(double *)(*(void *)(a2 + 8) + 16) + *(double *)(a1 + 16);
  if (*(unsigned char *)(a1 + 128))
  {
    *(double *)(a1 + 24) = *(double *)(*(void *)(a2 + 8) + 24) + *(double *)(a1 + 24);
    *(double *)(a1 + 56) = *(double *)(*(void *)(a2 + 8) + 24) + *(double *)(a1 + 56);
  }
  sub_10001CB34(a1 + 96, 0, (uint64_t)&v11);
  int v5 = v12;
  sub_100003224((uint64_t)&v11);
  sub_10001CB34(a1 + 96, 1, (uint64_t)&v11);
  int v6 = v12;
  sub_100003224((uint64_t)&v11);
  sub_10001CB34(a1 + 96, 2, (uint64_t)&v11);
  uint64_t v7 = v12;
  sub_100003224((uint64_t)&v11);
  unsigned int v9 = *(unsigned __int8 *)(a1 + 128) + 3;
  for (unsigned int i = *(_DWORD *)(a2 + 20); v9 < i; v9 += 3)
  {
    *int v5 = *(double *)(*(void *)(a2 + 8) + 8 * v9) + *v5;
    ++v5;
    double *v6 = *(double *)(*(void *)(a2 + 8) + 8 * (v9 + 1)) + *v6;
    ++v6;
    double result = *(double *)(*(void *)(a2 + 8) + 8 * (v9 + 2)) + *v7;
    *v7++ = result;
  }
  return result;
}

BOOL sub_100028320(double a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  double v4 = *(double **)(a3 + 8);
  double v5 = sqrt(v4[1] * v4[1] + *v4 * *v4 + v4[2] * v4[2]);
  if (v5 < *(double *)(a4 + 600))
  {
    double v5 = fabs(v4[3]);
    if (v5 < *(double *)(a4 + 608)) {
      return 1;
    }
  }
  LODWORD(v5) = *(_DWORD *)(a4 + 524);
  return fabs(a1) / (double)*(unint64_t *)&v5 < *(double *)(a4 + 592);
}

void sub_100028384(double *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v3 = 0;
  double v4 = 0.0;
  do
  {
    double v4 = v4 + a1[v3] * a1[v3];
    ++v3;
  }
  while (v3 != 3);
  double v5 = sqrt(v4);
  if (v5 != 0.0)
  {
    for (uint64_t i = 0; i != 3; ++i)
      a1[i] = a1[i] / v5;
  }
  uint64_t v7 = 0;
  v43[0] = 0;
  double v9 = a1[1];
  double v8 = a1[2];
  double v10 = *a1;
  *(double *)&v43[1] = -v8;
  *(double *)&v43[2] = v9;
  *(double *)&v43[3] = v8;
  v43[4] = 0;
  *(double *)&v43[5] = -v10;
  *(double *)&v43[6] = -v9;
  *(double *)&v43[7] = v10;
  v43[8] = 0;
  uint64_t v40 = 0;
  uint64_t v11 = v39;
  memset(v39, 0, sizeof(v39));
  do
  {
    for (uint64_t j = 0; j != 3; ++j)
    {
      if (v7 == j) {
        double v13 = 1.0;
      }
      else {
        double v13 = 0.0;
      }
      *((double *)v11 + j) = v13;
    }
    ++v7;
    uint64_t v11 = (_OWORD *)((char *)v11 + 24);
  }
  while (v7 != 3);
  double v14 = sin(v5);
  uint64_t v15 = 0;
  uint64_t v38 = 0;
  memset(v37, 0, sizeof(v37));
  do
  {
    *(double *)((char *)v37 + v15 * 8) = v14 * *(double *)&v43[v15];
    ++v15;
  }
  while (v15 != 9);
  uint64_t v16 = 0;
  uint64_t v17 = 0;
  uint64_t v42 = 0;
  memset(v41, 0, sizeof(v41));
  do
  {
    for (uint64_t k = 0; k != 24; k += 8)
      *(double *)((char *)v41 + v16 + k) = *(double *)((char *)v39 + v16 + k) + *(double *)((char *)v37 + v16 + k);
    ++v17;
    v16 += 24;
  }
  while (v17 != 3);
  uint64_t v19 = 0;
  uint64_t v34 = 0;
  memset(v33, 0, sizeof(v33));
  uint64_t v20 = v43;
  do
  {
    uint64_t v21 = 0;
    double v22 = (double *)v43;
    do
    {
      uint64_t v23 = 0;
      double v24 = 0.0;
      double v25 = v22;
      do
      {
        double v26 = *v25;
        v25 += 3;
        double v24 = v24 + *(double *)&v20[v23++] * v26;
      }
      while (v23 != 3);
      *((double *)v33 + 3 * v19 + v21++) = v24;
      ++v22;
    }
    while (v21 != 3);
    ++v19;
    v20 += 3;
  }
  while (v19 != 3);
  long double v27 = cos(v5);
  uint64_t v28 = 0;
  double v29 = 1.0 - v27;
  uint64_t v36 = 0;
  memset(v35, 0, sizeof(v35));
  do
  {
    *(double *)((char *)v35 + v28) = v29 * *(double *)((char *)v33 + v28);
    v28 += 8;
  }
  while (v28 != 72);
  uint64_t v30 = 0;
  uint64_t v31 = 0;
  *(void *)(a2 + 64) = 0;
  *(_OWORD *)(a2 + 32) = 0u;
  *(_OWORD *)(a2 + 48) = 0u;
  *(_OWORD *)a2 = 0u;
  *(_OWORD *)(a2 + 16) = 0u;
  do
  {
    for (uint64_t m = 0; m != 24; m += 8)
      *(double *)(a2 + m) = *(double *)((char *)v41 + v30 + m) + *(double *)((char *)v35 + v30 + m);
    ++v31;
    a2 += 24;
    v30 += 24;
  }
  while (v31 != 3);
}

uint64_t sub_100028624@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>, double a3@<D0>)
{
  uint64_t result = sub_1000032CC(a2, *(_DWORD *)(a1 + 16), *(_DWORD *)(a1 + 20));
  int v6 = *(_DWORD *)(a1 + 20) * *(_DWORD *)(a1 + 16);
  if (v6 >= 1)
  {
    uint64_t v7 = *(double **)(a1 + 8);
    double v8 = &v7[v6];
    double v9 = *(double **)(result + 8);
    do
    {
      double v10 = *v7++;
      *v9++ = v10 - a3;
    }
    while (v7 < v8);
  }
  return result;
}

uint64_t sub_10002868C@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  sub_10001D090(a1, a2, (uint64_t)&v7);
  uint64_t v4 = v8;
  int v5 = v9;
  *(unsigned char *)(a3 + 24) = v10;
  uint64_t v8 = 0;
  char v10 = 0;
  *(void *)a3 = &off_100095AB0;
  *(void *)(a3 + 8) = v4;
  *(_DWORD *)(a3 + 16) = 1;
  *(_DWORD *)(a3 + 20) = v5;
  return sub_100003224((uint64_t)&v7);
}

uint64_t sub_100028700@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>, double a3@<D0>)
{
  sub_100028624(a1, (uint64_t)&v7, a3);
  uint64_t v4 = v8;
  int v5 = v9;
  *(unsigned char *)(a2 + 24) = v10;
  uint64_t v8 = 0;
  char v10 = 0;
  *(void *)a2 = &off_100095AB0;
  *(void *)(a2 + 8) = v4;
  *(_DWORD *)(a2 + 16) = 1;
  *(_DWORD *)(a2 + 20) = v5;
  return sub_100003224((uint64_t)&v7);
}

uint64_t sub_100028774@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  sub_100028D54(a1, a2, (uint64_t)&v7);
  uint64_t v4 = v8;
  int v5 = v9;
  *(unsigned char *)(a3 + 24) = v10;
  uint64_t v8 = 0;
  char v10 = 0;
  *(void *)a3 = &off_100095AB0;
  *(void *)(a3 + 8) = v4;
  *(_DWORD *)(a3 + 16) = 1;
  *(_DWORD *)(a3 + 20) = v5;
  return sub_100003224((uint64_t)&v7);
}

uint64_t sub_1000287E8(uint64_t a1, void *a2, double *a3, double *a4, double a5, double a6, int8x16_t a7)
{
  long long v8 = *(_OWORD *)(a1 + 48);
  v24[1] = *(_OWORD *)(a1 + 32);
  v24[2] = v8;
  uint64_t v25 = *(void *)(a1 + 64);
  int8x16_t v10 = *(int8x16_t *)a1;
  int8x16_t v9 = *(int8x16_t *)(a1 + 16);
  int8x16_t v23 = *(int8x16_t *)a1;
  v24[0] = v9;
  uint64_t v11 = &v23.i64[1];
  uint64_t v12 = (char *)v24 + 8;
  for (uint64_t i = 1; i != 3; ++i)
  {
    uint64_t v14 = 0;
    uint64_t v15 = v11;
    do
    {
      v9.i64[0] = *(void *)&v12[8 * v14];
      v10.i64[0] = *v15;
      *(void *)&v12[8 * v14] = *v15;
      *uint64_t v15 = v9.i64[0];
      v15 += 3;
      ++v14;
    }
    while (i != v14);
    ++v11;
    v12 += 24;
  }
  sub_100006BC0(3, (double *)v23.i64, a2, a3, a4, v9, v10, a7);
  uint64_t v16 = a2 + 1;
  uint64_t v17 = a2 + 3;
  for (uint64_t j = 1; j != 3; ++j)
  {
    uint64_t v19 = 0;
    uint64_t v20 = v16;
    do
    {
      uint64_t v21 = v17[v19];
      v17[v19] = *v20;
      *uint64_t v20 = v21;
      v20 += 3;
      ++v19;
    }
    while (j != v19);
    ++v16;
    v17 += 3;
  }
  return 0;
}

void sub_1000288D0(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 40) = 3;
  *(unsigned char *)(a1 + 48) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = &off_100095BC8;
  *(void *)(a1 + 72) = 3;
  *(unsigned char *)(a1 + 80) = 0;
  *(void *)(a1 + 56) = &off_100095BC8;
  *(void *)(a1 + 64) = 0;
  *(void *)(a1 + 104) = 2;
  *(unsigned char *)(a1 + 112) = 0;
  *(void *)(a1 + 88) = &off_100096468;
  *(void *)(a1 + 96) = 0;
  *(void *)(a1 + 136) = 2;
  *(unsigned char *)(a1 + 144) = 0;
  *(void *)(a1 + 120) = &off_100096468;
  *(void *)(a1 + 128) = 0;
  *(_DWORD *)(a1 + 152) = 0;
  sub_100028AD0((uint64_t)&v2, a2, 0, -1);
}

void sub_100028AA0(_Unwind_Exception *a1)
{
  sub_100003224(v1);
  sub_100003224(v3);
  sub_100003224(v4);
  sub_100003224(v2);
  _Unwind_Resume(a1);
}

void sub_100028AD0(uint64_t a1, uint64_t a2, int a3, int a4)
{
  *(void *)a1 = off_100095A80;
  int v4 = *(_DWORD *)(a2 + 20);
  int v5 = *(_DWORD *)(a2 + 16) - a3;
  if (a4 != -1) {
    int v5 = a4;
  }
  uint64_t v6 = *(void *)(a2 + 8) + 8 * (v4 * a3);
  uint64_t v7 = off_100095A80;
  uint64_t v8 = v6;
  int v9 = v5;
  int v10 = v4;
  char v11 = 0;
  *(_DWORD *)(a1 + 16) = v5;
  *(_DWORD *)(a1 + 20) = v4;
  operator new[]();
}

void sub_100028BA8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

double sub_100028BBC(uint64_t a1, uint64_t a2)
{
  int v2 = *(_DWORD *)(a2 + 20);
  if (v2 != *(_DWORD *)(a1 + 20) || (int v3 = *(_DWORD *)(a2 + 16), v3 != *(_DWORD *)(a1 + 16))) {
    sub_100075C84();
  }
  unsigned int v4 = v3 * v2;
  if (v4)
  {
    int v5 = *(double **)(a1 + 8);
    uint64_t v6 = &v5[v4];
    uint64_t v7 = *(double **)(a2 + 8);
    do
    {
      double v8 = *v7++;
      double result = *v5 / v8;
      *v5++ = result;
    }
    while (v5 < v6);
  }
  return result;
}

uint64_t sub_100028C20@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>, double a3@<D0>)
{
  uint64_t result = sub_1000032CC(a2, *(_DWORD *)(a1 + 16), *(_DWORD *)(a1 + 20));
  int v6 = *(_DWORD *)(a1 + 20) * *(_DWORD *)(a1 + 16);
  if (v6 >= 1)
  {
    uint64_t v7 = *(double **)(a1 + 8);
    double v8 = &v7[v6];
    int v9 = *(double **)(result + 8);
    do
    {
      double v10 = *v7++;
      *v9++ = v10 / a3;
    }
    while (v7 < v8);
  }
  return result;
}

uint64_t sub_100028C88@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>, double a3@<D0>)
{
  uint64_t result = sub_1000032CC(a2, *(_DWORD *)(a1 + 16), *(_DWORD *)(a1 + 20));
  int v6 = *(_DWORD *)(a1 + 20) * *(_DWORD *)(a1 + 16);
  if (v6 >= 1)
  {
    uint64_t v7 = *(double **)(a1 + 8);
    double v8 = &v7[v6];
    int v9 = *(double **)(result + 8);
    do
    {
      double v10 = *v7++;
      *v9++ = v10 * a3;
    }
    while (v7 < v8);
  }
  return result;
}

double sub_100028CF0(uint64_t a1, uint64_t a2)
{
  int v2 = *(_DWORD *)(a2 + 20);
  if (v2 != *(_DWORD *)(a1 + 20) || (int v3 = *(_DWORD *)(a2 + 16), v3 != *(_DWORD *)(a1 + 16))) {
    sub_100075C84();
  }
  unsigned int v4 = v3 * v2;
  if (v4)
  {
    int v5 = *(double **)(a1 + 8);
    int v6 = &v5[v4];
    uint64_t v7 = *(double **)(a2 + 8);
    do
    {
      double v8 = *v7++;
      double result = v8 * *v5;
      *v5++ = result;
    }
    while (v5 < v6);
  }
  return result;
}

double sub_100028D54@<D0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  int v4 = *(_DWORD *)(a2 + 20);
  if (v4 != *(_DWORD *)(a1 + 20) || (int v6 = *(_DWORD *)(a2 + 16), v6 != *(_DWORD *)(a1 + 16))) {
    sub_100075C84();
  }
  uint64_t v7 = sub_1000032CC(a3, v6, v4);
  int v9 = *(_DWORD *)(a1 + 20) * *(_DWORD *)(a1 + 16);
  if (v9 >= 1)
  {
    double v10 = *(double **)(a1 + 8);
    char v11 = &v10[v9];
    uint64_t v12 = *(double **)(v7 + 8);
    double v13 = *(double **)(a2 + 8);
    do
    {
      double v14 = *v10++;
      double v15 = v14;
      double v16 = *v13++;
      double result = v15 - v16;
      *v12++ = result;
    }
    while (v10 < v11);
  }
  return result;
}

uint64_t sub_100028DE0(uint64_t a1)
{
  return a1;
}

uint64_t sub_100028E20(pthread_mutex_t *a1)
{
  return pthread_cond_wait((pthread_cond_t *)&a1[1], a1);
}

uint64_t sub_100028E2C(uint64_t a1)
{
  pthread_cond_signal((pthread_cond_t *)(a1 + 64));

  return pthread_mutex_unlock((pthread_mutex_t *)a1);
}

const void **sub_100028E68(const void **a1)
{
  int v2 = *a1;
  if (v2) {
    CFRelease(v2);
  }
  return a1;
}

double sub_100028EA0(uint64_t *a1, uint64_t a2, unint64_t a3)
{
  uint64_t v3 = *a1;
  double result = 0.0;
  if (a2 - 1 < a3 && v3 != 0)
  {
    uint64_t v6 = *((unsigned int *)a1 + 4);
    *(void *)(v3 + 8 * v6) = a3 - a2;
    unsigned int v8 = *((_DWORD *)a1 + 2);
    unsigned int v7 = *((_DWORD *)a1 + 3);
    *((_DWORD *)a1 + 4) = ((int)v6 + 1) % v8;
    if (v7 < v8) {
      *((_DWORD *)a1 + 3) = v7 + 1;
    }
    return (double)((a3 - a2) * *((unsigned int *)a1 + 8) / *((unsigned int *)a1 + 9)) / 1000000.0;
  }
  return result;
}

void *sub_100028F08(void *result)
{
  if (*result)
  {
    uint64_t v1 = result;
    if (!result[3])
    {
      double result = (void *)mach_absolute_time();
      v1[3] = result;
    }
  }
  return result;
}

double sub_100028F40(uint64_t *a1)
{
  uint64_t v1 = a1[3];
  if (!v1) {
    return 0.0;
  }
  uint64_t v3 = mach_absolute_time();
  double result = sub_100028EA0(a1, v1, v3);
  a1[3] = 0;
  return result;
}

void sub_100028F88(_DWORD *a1, _DWORD *a2)
{
  if (a2)
  {
    bzero(a2, 0x38uLL);
    int v5 = a1[2];
    int v4 = a1[3];
    *a2 = v4;
    a2[1] = v5;
    a2[2] = a1[4];
    if (v4) {
      operator new[]();
    }
  }
}

void sub_10002913C(_DWORD *a1)
{
  sub_100028F88(a1, v2);
  os_log_t v1 = (os_log_t)off_1002BBC80;
  if (off_1002BBC80 == &_os_log_default)
  {
    os_log_t v1 = os_log_create("com.apple.isp", "general");
    off_1002BBC80 = v1;
  }
  if (os_log_type_enabled(v1, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 67109120;
    LODWORD(v9) = v2[0];
    _os_log_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_DEFAULT, " Number of samples: %d\n", buf, 8u);
    os_log_t v1 = (os_log_t)off_1002BBC80;
  }
  if (v1 == (os_log_t)&_os_log_default)
  {
    os_log_t v1 = os_log_create("com.apple.isp", "general");
    off_1002BBC80 = v1;
  }
  if (os_log_type_enabled(v1, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 67109120;
    LODWORD(v9) = v2[1];
    _os_log_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_DEFAULT, " Maximum samples:   %d\n", buf, 8u);
    os_log_t v1 = (os_log_t)off_1002BBC80;
  }
  if (v1 == (os_log_t)&_os_log_default)
  {
    os_log_t v1 = os_log_create("com.apple.isp", "general");
    off_1002BBC80 = v1;
  }
  if (os_log_type_enabled(v1, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 134217984;
    uint64_t v9 = v3;
    _os_log_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_DEFAULT, " Minimum time (ms): %.3f\n", buf, 0xCu);
    os_log_t v1 = (os_log_t)off_1002BBC80;
  }
  if (v1 == (os_log_t)&_os_log_default)
  {
    os_log_t v1 = os_log_create("com.apple.isp", "general");
    off_1002BBC80 = v1;
  }
  if (os_log_type_enabled(v1, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 134217984;
    uint64_t v9 = v4;
    _os_log_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_DEFAULT, " Maximum time (ms): %.3f\n", buf, 0xCu);
    os_log_t v1 = (os_log_t)off_1002BBC80;
  }
  if (v1 == (os_log_t)&_os_log_default)
  {
    os_log_t v1 = os_log_create("com.apple.isp", "general");
    off_1002BBC80 = v1;
  }
  if (os_log_type_enabled(v1, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 134217984;
    uint64_t v9 = v5;
    _os_log_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_DEFAULT, " Average time (ms): %.3f\n", buf, 0xCu);
    os_log_t v1 = (os_log_t)off_1002BBC80;
  }
  if (v1 == (os_log_t)&_os_log_default)
  {
    os_log_t v1 = os_log_create("com.apple.isp", "general");
    off_1002BBC80 = v1;
  }
  if (os_log_type_enabled(v1, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 134217984;
    uint64_t v9 = v6;
    _os_log_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_DEFAULT, " Median time (ms): %.3f\n", buf, 0xCu);
    os_log_t v1 = (os_log_t)off_1002BBC80;
  }
  if (v1 == (os_log_t)&_os_log_default)
  {
    os_log_t v1 = os_log_create("com.apple.isp", "general");
    off_1002BBC80 = v1;
  }
  if (os_log_type_enabled(v1, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 134217984;
    uint64_t v9 = v7;
    _os_log_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_DEFAULT, " Standard deviation (ms): %.3f\n", buf, 0xCu);
  }
}

void sub_1000294A4(uint64_t a1, int a2)
{
  *(_DWORD *)(a1 + 12) = 0;
  *(_DWORD *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 8) = a2;
  *(void *)(a1 + 24) = 0;
  operator new[]();
}

void *sub_1000294F8(void *result)
{
  if (*result) {
    operator delete[]();
  }
  return result;
}

void sub_100029538(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)a1 = 0;
  *(void *)(a1 + 216) = 0;
  *(_DWORD *)(a1 + 224) = 0;
  *(void *)(a1 + 232) = 0;
  *(void *)(a1 + 240) = a2;
  uint64_t v3 = (uint64_t *)(a1 + 240);
  *(void *)(a1 + 272) = 0;
  *(void *)(a1 + 280) = 0x4000000000000000;
  pthread_mutex_init((pthread_mutex_t *)(a1 + 16), 0);
  pthread_mutex_init((pthread_mutex_t *)(a1 + 144), 0);
  *(void *)(a1 + 208) = 0;
  pthread_mutexattr_init(&v5);
  pthread_mutexattr_settype(&v5, 2);
  pthread_mutex_init((pthread_mutex_t *)(a1 + 80), &v5);
  pthread_mutexattr_destroy(&v5);
  int v4 = 0;
  sub_10004C9B4(*v3, &v4, (double *)(a1 + 256));
  mach_timebase_info((mach_timebase_info_t)(a1 + 264));
  operator new();
}

void sub_100029640()
{
}

uint64_t sub_10002966C(uint64_t a1)
{
  if (*(_DWORD *)a1) {
    sub_100029744(a1);
  }
  if (*(void *)(a1 + 232)) {
    sub_1000297D4(a1);
  }
  uint64_t v2 = *(void *)(a1 + 272);
  if (v2)
  {
    uint64_t v3 = *(__CFRunLoop **)(a1 + 8);
    int v4 = sub_100022EEC(v2);
    CFRunLoopRemoveSource(v3, v4, kCFRunLoopDefaultMode);
    uint64_t v5 = *(void *)(a1 + 272);
    if (v5) {
      (*(void (**)(uint64_t))(*(void *)v5 + 8))(v5);
    }
    *(void *)(a1 + 272) = 0;
  }
  uint64_t v6 = *(void *)(a1 + 288);
  if (v6)
  {
    sub_1000499D0(v6);
    operator delete();
  }
  pthread_mutex_destroy((pthread_mutex_t *)(a1 + 16));
  pthread_mutex_destroy((pthread_mutex_t *)(a1 + 80));
  pthread_mutex_destroy((pthread_mutex_t *)(a1 + 144));
  return a1;
}

uint64_t sub_100029744(uint64_t a1)
{
  uint64_t v2 = (pthread_mutex_t *)(a1 + 16);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 16));
  if (*(_DWORD *)a1)
  {
    sub_100029AA8(a1);
    pthread_mutex_lock((pthread_mutex_t *)(a1 + 80));
    *(unsigned char *)(a1 + 248) = 1;
    pthread_mutex_unlock((pthread_mutex_t *)(a1 + 80));
    uint64_t v3 = sub_100054AE4(*(void *)(a1 + 240), *(_DWORD *)(a1 + 224));
    *(unsigned char *)(a1 + 248) = 0;
    *(_DWORD *)a1 = 0;
  }
  else
  {
    uint64_t v3 = 3758097122;
  }
  pthread_mutex_unlock(v2);
  return v3;
}

void sub_1000297D4(uint64_t a1)
{
  uint64_t v2 = *(__CFRunLoopSource **)(a1 + 232);
  if (v2)
  {
    CFRunLoopRemoveSource(*(CFRunLoopRef *)(a1 + 8), v2, kCFRunLoopDefaultMode);
    CFRelease(*(CFTypeRef *)(a1 + 232));
    *(void *)(a1 + 232) = 0;
  }
  uint64_t v3 = *(__CFMachPort **)(a1 + 216);
  if (v3)
  {
    CFMachPortInvalidate(v3);
    CFRelease(*(CFTypeRef *)(a1 + 216));
    *(void *)(a1 + 216) = 0;
  }
  mach_port_name_t v4 = *(_DWORD *)(a1 + 224);
  if (v4)
  {
    mach_port_mod_refs(mach_task_self_, v4, 1u, -1);
    *(_DWORD *)(a1 + 224) = 0;
  }
}

uint64_t sub_100029858(uint64_t a1)
{
  uint64_t v2 = IOCreateReceivePort(0x39u, (mach_port_t *)(a1 + 224));
  if (!v2)
  {
    uint64_t v2 = 3758097085;
    Boolean shouldFreeInfo = 0;
    context.version = 1;
    context.info = (void *)a1;
    memset(&context.retain, 0, 24);
    uint64_t v3 = CFMachPortCreateWithPort(kCFAllocatorDefault, *(_DWORD *)(a1 + 224), (CFMachPortCallBack)&IODispatchCalloutFromMessage, &context, &shouldFreeInfo);
    *(void *)(a1 + 216) = v3;
    if (v3)
    {
      RunLoopSource = CFMachPortCreateRunLoopSource(kCFAllocatorDefault, v3, 0);
      *(void *)(a1 + 232) = RunLoopSource;
      if (RunLoopSource)
      {
        CFRunLoopAddSource(*(CFRunLoopRef *)(a1 + 8), RunLoopSource, kCFRunLoopDefaultMode);
        return 0;
      }
    }
  }
  return v2;
}

uint64_t sub_100029928(uint64_t a1)
{
  uint64_t v2 = (pthread_mutex_t *)(a1 + 16);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 16));
  if (*(_DWORD *)a1 == 1)
  {
    pthread_mutex_unlock(v2);
    return 3758097122;
  }
  else
  {
    *(unsigned char *)(a1 + 248) = 0;
    *(_DWORD *)a1 = 1;
    inputStruct[0] = sub_1000299BC;
    inputStruct[1] = a1;
    int v6 = *(_DWORD *)(a1 + 224);
    uint64_t v3 = sub_100054A50(*(void *)(a1 + 240), inputStruct);
    pthread_mutex_unlock(v2);
  }
  return v3;
}

void sub_1000299BC()
{
}

uint64_t sub_100029AA8(uint64_t a1)
{
  uint64_t v2 = (pthread_mutex_t *)(a1 + 144);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 144));
  uint64_t v3 = *(__CFRunLoopTimer **)(a1 + 208);
  if (v3)
  {
    CFRunLoopTimerInvalidate(v3);
    CFRelease(*(CFTypeRef *)(a1 + 208));
    *(void *)(a1 + 208) = 0;
  }

  return pthread_mutex_unlock(v2);
}

uint64_t sub_100029B00(uint64_t a1)
{
  uint64_t v2 = (pthread_mutex_t *)(a1 + 144);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 144));
  uint64_t v3 = *(__CFRunLoopTimer **)(a1 + 208);
  if (v3)
  {
    CFAbsoluteTime Current = CFAbsoluteTimeGetCurrent();
    CFRunLoopTimerSetNextFireDate(v3, Current + *(double *)(a1 + 280));
  }

  return pthread_mutex_unlock(v2);
}

uint64_t sub_100029B64(uint64_t a1)
{
  uint64_t v2 = (pthread_mutex_t *)(a1 + 16);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 16));
  sub_100054CA0(*(void *)(a1 + 240), *(_DWORD *)(a1 + 224));
  pthread_mutex_unlock(v2);
  return 0;
}

uint64_t sub_100029BA8(uint64_t a1)
{
  pthread_t v5 = 0;
  sub_100028DDC(&v7);
  uint64_t v2 = *(void *)(a1 + 8);
  v6[0] = 0;
  v6[1] = v2;
  void v6[2] = &v7;
  pthread_attr_init(&v8);
  pthread_attr_setdetachstate(&v8, 2);
  pthread_create(&v5, &v8, (void *(__cdecl *)(void *))sub_100029CAC, v6);
  pthread_attr_destroy(&v8);
  sub_100028E20(&v7);
  **(void **)a1 = v6[0];
  if (v6[0]) {
    uint64_t v3 = 0;
  }
  else {
    uint64_t v3 = 3758097084;
  }
  sub_100028E18((uint64_t)&v7);
  return v3;
}

void sub_100029C90(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, char a14)
{
}

void sub_100029CAC(uint64_t a1)
{
}

void sub_100029D70()
{
}

void sub_100029D94(uint64_t a1)
{
}

void sub_100029DF0(uint64_t a1, uint64_t a2, uint64_t a3, char a4, uint64_t a5)
{
  sub_1000032CC((uint64_t)v20, 3, *(_DWORD *)(a1 + 20));
  v20[0] = &off_100095BC8;
  sub_1000032CC((uint64_t)v19, 3, *(_DWORD *)(a2 + 20));
  uint64_t v18 = 0;
  v19[0] = &off_100095BC8;
  memset(v17, 0, sizeof(v17));
  uint64_t v16 = 0;
  memset(v15, 0, sizeof(v15));
  sub_100039FBC(a1, (uint64_t)v20, (uint64_t)v17);
  sub_100039FBC(a2, (uint64_t)v19, (uint64_t)v15);
  sub_10002A7E4((uint64_t)&v14, 1, *(_DWORD *)(a1 + 20));
  double v14 = &off_1000964F8;
  int v13 = 0;
  if ((a4 & 1) == 0)
  {
    int v9 = *(_DWORD *)(a5 + 20) * *(_DWORD *)(a5 + 16);
    if (v9 >= 1)
    {
      double v10 = *(void **)(a5 + 8);
      unint64_t v11 = (unint64_t)v10 + v9;
      if (v11 <= (unint64_t)v10 + 1) {
        unint64_t v11 = (unint64_t)v10 + 1;
      }
      memset(v10, 1, v11 - (void)v10);
    }
  }
  sub_10002A8A8((uint64_t)v12, a5, 0, -1);
}

void sub_10002A490(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,char a49,uint64_t a50,uint64_t a51,uint64_t a52,char a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,char a62,uint64_t a63)
{
  sub_100003224((uint64_t)&a49);
  sub_100013234((uint64_t)&a53);
  sub_100013234((uint64_t)&a62);
  sub_100013234((uint64_t)&a71);
  sub_100003224(v71 - 168);
  sub_100003224(v71 - 136);
  _Unwind_Resume(a1);
}

uint64_t sub_10002A564(uint64_t result, uint64_t a2, int a3, uint64_t a4)
{
  uint64_t v4 = *(unsigned int *)(result + 16);
  if (v4)
  {
    unint64_t v5 = 0;
    unsigned int v6 = *(_DWORD *)(result + 20);
    do
    {
      if (a3)
      {
        for (unint64_t i = 0;
              i != a3;
              *(void *)(*(void *)(a4 + 8) + 8 * (v5 * v9) + 8 * i++) = *(void *)(*(void *)(result + 8) + 8 * v8 + 8 * v6 * v5))
        {
          uint64_t v8 = *(unsigned int *)(*(void *)(a2 + 8) + 4 * i);
          if (v8 >= v6) {
            sub_1000741C0();
          }
          if (v5 < *(unsigned int *)(a4 + 16))
          {
            unint64_t v9 = *(unsigned int *)(a4 + 20);
            if (i < v9) {
              continue;
            }
          }
          sub_100073870();
        }
      }
      ++v5;
    }
    while (v5 != v4);
  }
  return result;
}

uint64_t sub_10002A5FC(uint64_t result, uint64_t a2, int a3, uint64_t a4)
{
  uint64_t v4 = *(unsigned int *)(result + 16);
  if (v4)
  {
    unint64_t v5 = 0;
    unsigned int v6 = *(_DWORD *)(result + 20);
    do
    {
      if (a3)
      {
        for (unint64_t i = 0;
              i != a3;
              *(unsigned char *)(*(void *)(a4 + 8) + (v5 * v9) + i++) = *(unsigned char *)(*(void *)(result + 8)
                                                                                         + v8
                                                                                         + v6 * v5))
        {
          uint64_t v8 = *(unsigned int *)(*(void *)(a2 + 8) + 4 * i);
          if (v8 >= v6) {
            sub_1000741C0();
          }
          if (v5 < *(unsigned int *)(a4 + 16))
          {
            unint64_t v9 = *(unsigned int *)(a4 + 20);
            if (i < v9) {
              continue;
            }
          }
          sub_100073870();
        }
      }
      ++v5;
    }
    while (v5 != v4);
  }
  return result;
}

uint64_t sub_10002A694(uint64_t result, uint64_t a2, int a3, uint64_t a4)
{
  unsigned int v4 = *(_DWORD *)(result + 16);
  if (v4)
  {
    for (unsigned int i = 0; i < v4; ++i)
    {
      if (a3)
      {
        for (unint64_t j = 0;
              j != a3;
              *(_DWORD *)(*(void *)(a4 + 8) + 4 * i * v9 + 4 * j++) = *(_DWORD *)(*(void *)(result + 8)
                                                                                                  + 4 * v7
                                                                                                  + 4 * v8 * i))
        {
          if (i >= *(_DWORD *)(result + 16)
            || (uint64_t v7 = *(unsigned int *)(*(void *)(a2 + 8) + 4 * j),
                unsigned int v8 = *(_DWORD *)(result + 20),
                v7 >= v8))
          {
            sub_1000741C0();
          }
          if (*(_DWORD *)(a4 + 16) > i)
          {
            unint64_t v9 = *(unsigned int *)(a4 + 20);
            if (j < v9) {
              continue;
            }
          }
          sub_100073870();
        }
        unsigned int v4 = *(_DWORD *)(result + 16);
      }
    }
  }
  return result;
}

uint64_t sub_10002A73C(uint64_t result, uint64_t a2, uint64_t a3)
{
  unsigned int v3 = *(_DWORD *)(result + 20);
  uint64_t v4 = *(unsigned int *)(a3 + 20);
  if (v3 >= v4)
  {
    unsigned int v5 = 0;
    unint64_t v6 = 0;
    unint64_t v7 = *(unsigned int *)(a2 + 16);
    do
    {
      if (v4)
      {
        if (v6 < v7)
        {
          uint64_t v8 = 0;
          unsigned int v9 = *(_DWORD *)(a2 + 20);
          while (1)
          {
            uint64_t v10 = *(unsigned int *)(*(void *)(a3 + 8) + 4 * v8);
            if (v10 >= v9) {
              break;
            }
            if (v6 >= *(unsigned int *)(result + 16)) {
              sub_100073870();
            }
            *(void *)(*(void *)(result + 8) + 8 * v5 + 8 * v8++) = *(void *)(*(void *)(a2 + 8)
                                                                                   + 8 * v10
                                                                                   + 8 * v9 * v6);
            if (v4 == v8) {
              goto LABEL_9;
            }
          }
        }
        sub_1000741C0();
      }
LABEL_9:
      ++v6;
      v5 += v3;
    }
    while (v6 != 3);
  }
  return result;
}

uint64_t sub_10002A7E4(uint64_t result, int a2, int a3)
{
  *(void *)double result = off_100096260;
  if (a3 * a2) {
    operator new[]();
  }
  *(void *)(result + 8) = 0;
  *(_DWORD *)(result + 16) = a2;
  *(_DWORD *)(result + 20) = a3;
  *(unsigned char *)(result + 24) = 0;
  return result;
}

void sub_10002A870(uint64_t a1)
{
  sub_100013234(a1);

  operator delete();
}

void sub_10002A8A8(uint64_t a1, uint64_t a2, int a3, int a4)
{
  *(void *)a1 = off_100095B08;
  int v4 = *(_DWORD *)(a2 + 20);
  int v5 = *(_DWORD *)(a2 + 16) - a3;
  if (a4 != -1) {
    int v5 = a4;
  }
  uint64_t v6 = *(void *)(a2 + 8) + (v4 * a3);
  unint64_t v7 = off_100095B08;
  uint64_t v8 = v6;
  int v9 = v5;
  int v10 = v4;
  char v11 = 0;
  *(_DWORD *)(a1 + 16) = v5;
  *(_DWORD *)(a1 + 20) = v4;
  operator new[]();
}

void sub_10002A978(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_10002A98C(uint64_t a1)
{
  sub_100004648(a1);

  operator delete();
}

uint64_t sub_10002A9C4(uint64_t result, int a2, int a3)
{
  *(void *)double result = off_100095B08;
  if (a3 * a2) {
    operator new[]();
  }
  *(void *)(result + 8) = 0;
  *(_DWORD *)(result + 16) = a2;
  *(_DWORD *)(result + 20) = a3;
  *(unsigned char *)(result + 24) = 0;
  return result;
}

uint64_t sub_10002AA50(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6, uint64_t a7, uint64_t a8)
{
  uint64_t v14 = 0;
  double v15 = *(double *)(a5 + 72) / *(double *)(a5 + 80);
  *(double *)(a7 + 96) = v15;
  uint64_t v88 = 0;
  long long v86 = 0u;
  long long v87 = 0u;
  long long v84 = 0u;
  long long v85 = 0u;
  uint64_t v16 = &v84;
  do
  {
    for (uint64_t i = 0; i != 3; ++i)
    {
      if (v14 == i) {
        double v18 = 1.0;
      }
      else {
        double v18 = 0.0;
      }
      *((double *)v16 + i) = v18;
    }
    ++v14;
    uint64_t v16 = (long long *)((char *)v16 + 24);
  }
  while (v14 != 3);
  uint64_t v19 = 0;
  *(void *)(a7 + 64) = v88;
  long long v20 = v87;
  *(_OWORD *)(a7 + 32) = v86;
  *(_OWORD *)(a7 + 48) = v20;
  long long v21 = v85;
  *(_OWORD *)a7 = v84;
  *(_OWORD *)(a7 + 16) = v21;
  *(void *)&long long v21 = *(void *)(a5 + 16);
  *(double *)(a8 + 88) = v15;
  *(void *)(a8 + 96) = v21;
  *(void *)(a8 + 256) = 0;
  *(void *)(a8 + 264) = 0;
  *(void *)(a8 + 248) = 0;
  do
  {
    *(void *)(a8 + v19 + 104) = *(void *)(a7 + v19);
    v19 += 8;
  }
  while (v19 != 72);
  if (byte_1002BBC88)
  {
    printf("Num of points: %d\n", *(_DWORD *)(a1 + 20));
    int v22 = byte_1002BBC88;
  }
  else
  {
    int v22 = 0;
  }
  unsigned int v23 = *(_DWORD *)(a1 + 20);
  *(double *)(a8 + 40) = (double)v23;
  unsigned int v24 = *(_DWORD *)(a5 + 544);
  double v25 = 0.0;
  if (v23 >= v24) {
    double v25 = 1.0;
  }
  *(double *)(a8 + 400) = v25;
  if (v22)
  {
    printf("outStats->tests.isEnoughInPoints = %lf\n", v25);
    unsigned int v23 = *(_DWORD *)(a1 + 20);
    unsigned int v24 = *(_DWORD *)(a5 + 544);
  }
  if (v23 < v24 && a6 == 0) {
    return 4294967294;
  }
  int v27 = *(_DWORD *)(a5 + 520);
  unsigned int v28 = *(_DWORD *)(a5 + 532) + v27;
  if (v28 > v23)
  {
    if (byte_1002BBC88)
    {
      printf("Required points: %d+%d, available points: %d. Only these will be used.\n", v27, *(_DWORD *)(a5 + 532), v23);
      unsigned int v28 = *(_DWORD *)(a1 + 20);
    }
    else
    {
      unsigned int v28 = v23;
    }
  }
  sub_1000032CC((uint64_t)&v80, 2, v28);
  double v80 = &off_100096468;
  sub_1000032CC((uint64_t)&v76, 2, v28);
  uint64_t v30 = *(unsigned int *)(a1 + 20);
  double v76 = &off_100096468;
  double v31 = (double)v30 / (double)v28;
  if (v31 <= 1.0)
  {
    sub_100004500((uint64_t)&v80, *(_DWORD *)(a1 + 16), v30);
    memcpy(v81, *(const void **)(a1 + 8), 8 * v82 * (unint64_t)v83);
    sub_100004500((uint64_t)&v76, *(_DWORD *)(a2 + 16), *(_DWORD *)(a2 + 20));
    memcpy(v77, *(const void **)(a2 + 8), 8 * v78 * (unint64_t)v79);
  }
  else if (v28)
  {
    unsigned int v32 = *(_DWORD *)(a1 + 16);
    if (v32)
    {
      unint64_t v33 = 0;
      unsigned int v34 = *(_DWORD *)(a2 + 16);
      uint64_t v35 = *(unsigned int *)(a2 + 20);
      BOOL v38 = v32 >= 2;
      unsigned int v36 = v82;
      unint64_t v37 = v83;
      BOOL v38 = v38 && v82 >= 2;
      char v39 = !v38;
      unsigned int v40 = v78;
      unint64_t v41 = v79;
      BOOL v43 = v34 < 2 || v78 < 2;
      while (1)
      {
        uint64_t v44 = (int)(v31 * (double)v33);
        BOOL v45 = v30 <= v44 || v36 == 0;
        if (v45 || v33 >= v37) {
          break;
        }
        *((void *)v81 + v33) = *(void *)(*(void *)(a1 + 8) + 8 * v44);
        if (v39) {
          break;
        }
        *((void *)v81 + v37 + v33) = *(void *)(*(void *)(a1 + 8) + 8 * v44 + 8 * v30);
        if (!v34) {
          break;
        }
        BOOL v47 = v35 <= v44 || v40 == 0;
        if (v47 || v33 >= v41) {
          break;
        }
        *((void *)v77 + v33) = *(void *)(*(void *)(a2 + 8) + 8 * v44);
        if (v43) {
          break;
        }
        *((void *)v77 + v41 + v33++) = *(void *)(*(void *)(a2 + 8) + 8 * v44 + 8 * v35);
        if (v28 == v33) {
          goto LABEL_61;
        }
      }
    }
    __assert_rtn("operator()", "Matrix.hpp", 119, "row < m_rows && col < m_cols");
  }
LABEL_61:
  sub_1000032CC((uint64_t)v73, 3, v83);
  v73[0] = &off_100095BC8;
  sub_1000032CC((uint64_t)v70, 3, v83);
  v70[0] = &off_100095BC8;
  if (sub_10001BB50((uint64_t)&v80, (uint64_t)&v76, a5, (uint64_t)v73, (uint64_t)v70))
  {
    int v59 = 166;
    goto LABEL_89;
  }
  uint64_t v49 = v75;
  if (v75)
  {
    if (v74 >= 3)
    {
      unint64_t v50 = 0;
      unsigned int v51 = v71;
      unint64_t v52 = v72;
      uint64_t v53 = 16 * v72;
      while (1)
      {
        *(void *)(v73[1] + 8 * (2 * v49) + 8 * v50) = 0x3FF0000000000000;
        if (v51 < 3 || v50 >= v52) {
          break;
        }
        *(void *)(v70[1] + v53 + 8 * v50++) = 0x3FF0000000000000;
        if (v49 == v50) {
          goto LABEL_68;
        }
      }
    }
    __assert_rtn("operator()", "Matrix.hpp", 119, "row < m_rows && col < m_cols");
  }
LABEL_68:
  if (*(unsigned char *)(a5 + 529) && sub_100005514((uint64_t)v73, (uint64_t)v70, a5))
  {
    int v59 = 182;
LABEL_89:
    __assert_rtn("GMC_Controller", "GMC_Controller.cpp", v59, "status == 0");
  }
  double v69 = 0.0;
  BOOL v54 = sub_100012F24((uint64_t)v73, a5, &v69);
  double v55 = v69;
  *(double *)a8 = v69;
  if (byte_1002BBC88) {
    printf("GMC_SpatialCoverageTest, coverage: %lf\n", v55);
  }
  *(double *)(a8 + 384) = (double)v54;
  if ((v54 | a6) == 1)
  {
    if (!(*(_DWORD *)(a4 + 20) * *(_DWORD *)(a4 + 16))) {
      __assert_rtn("operator()", "Matrix.hpp", 131, "index < m_rows * m_cols");
    }
    double v56 = **(double **)(a4 + 8);
    *(double *)&unint64_t v68 = -1.0;
    sub_10002A9C4((uint64_t)v67, 1, v75);
    v67[0] = &off_100096530;
    int v66 = 0;
    if (v56 >= 0.0) {
      sub_100028AD0((uint64_t)v65, a4, 0, -1);
    }
    double v57 = *(double *)&v68;
    *(double *)(a8 + 16) = *(double *)&v68;
    if (byte_1002BBC88) {
      printf("GMC_FaceCoverageTest, coverage: %lf, num points: %d\n", v57, v66);
    }
    *(double *)(a8 + 392) = (double)1u;
    if ((a6 | 1) == 1)
    {
      sub_1000032CC((uint64_t)v64, 3, *(_DWORD *)(a5 + 532));
      v64[0] = &off_100095BC8;
      sub_1000032CC((uint64_t)v63, 3, *(_DWORD *)(a5 + 532));
      v63[0] = &off_100095BC8;
      sub_1000032CC((uint64_t)v62, 3, v75 - *(_DWORD *)(a5 + 532));
      v62[0] = &off_100095BC8;
      sub_1000032CC((uint64_t)v61, 3, v72 - *(_DWORD *)(a5 + 532));
      v61[0] = &off_100095BC8;
      sub_10002A9C4((uint64_t)v60, 1, v75 - *(_DWORD *)(a5 + 532));
      v60[0] = &off_100096530;
      if (!sub_100023F14((uint64_t)v73, (uint64_t)v70, *(_DWORD *)(a5 + 532), v56 >= 0.0, (uint64_t)v67, (uint64_t)v62, (uint64_t)v61, (uint64_t)v64, (uint64_t)v63, (uint64_t)v60))sub_10002C6DC((uint64_t)v64, (uint64_t)v63, (long long *)a5); {
      __assert_rtn("GMC_Controller", "GMC_Controller.cpp", 250, "status == 0");
      }
    }
    uint64_t v29 = 4294967284;
    sub_100004648((uint64_t)v67);
  }
  else
  {
    uint64_t v29 = 0xFFFFFFFFLL;
  }
  sub_100003224((uint64_t)v70);
  sub_100003224((uint64_t)v73);
  sub_100003224((uint64_t)&v76);
  sub_100003224((uint64_t)&v80);
  return v29;
}

void sub_10002C4F0(_Unwind_Exception *a1)
{
  sub_100003224((uint64_t)&STACK[0x340]);
  sub_100013234((uint64_t)&STACK[0x360]);
  sub_100003224((uint64_t)&STACK[0x380]);
  sub_100003224((uint64_t)&STACK[0x3A0]);
  sub_100003224((uint64_t)&STACK[0x3C0]);
  sub_100013234((uint64_t)&STACK[0x440]);
  sub_100003224((uint64_t)&STACK[0x460]);
  sub_100004648((uint64_t)&STACK[0x4A8]);
  sub_100003224((uint64_t)&STACK[0x4C8]);
  sub_100003224((uint64_t)&STACK[0x4E8]);
  sub_100003224((uint64_t)&STACK[0x508]);
  sub_100003224((uint64_t)&STACK[0x528]);
  sub_100004648((uint64_t)&STACK[0x570]);
  sub_100003224((uint64_t)&STACK[0x5A0]);
  sub_100003224((uint64_t)&STACK[0x5C0]);
  sub_100003224(v1 - 256);
  sub_100003224(v1 - 224);
  _Unwind_Resume(a1);
}

void sub_10002C6DC(uint64_t a1, uint64_t a2, long long *a3)
{
  long long v5 = *(long long *)((char *)a3 + 72);
  long long v185 = *(long long *)((char *)a3 + 56);
  long long v186 = v5;
  long long v187 = *(long long *)((char *)a3 + 88);
  uint64_t v188 = *((void *)a3 + 13);
  long long v6 = a3[1];
  long long v181 = *a3;
  long long v182 = v6;
  long long v183 = a3[2];
  uint64_t v184 = *((void *)a3 + 6);
  long long v7 = a3[27];
  long long v176 = a3[26];
  long long v177 = v7;
  uint64_t v8 = *((void *)a3 + 56);
  long long v9 = a3[24];
  long long v175 = a3[25];
  long long v174 = v9;
  long long v179 = *(long long *)((char *)a3 + 456);
  uint64_t v10 = *((void *)a3 + 59);
  uint64_t v178 = v8;
  uint64_t v180 = v10;
  long long v11 = a3[21];
  long long v169 = a3[20];
  long long v170 = v11;
  uint64_t v12 = *((void *)a3 + 44);
  long long v13 = a3[18];
  long long v168 = a3[19];
  long long v167 = v13;
  long long v172 = *(long long *)((char *)a3 + 360);
  uint64_t v14 = *((void *)a3 + 47);
  uint64_t v171 = v12;
  uint64_t v173 = v14;
  sub_10002D784(a1, (uint64_t)v163);
  sub_10002D784(a2, (uint64_t)v159);
  uint64_t v15 = 0;
  uint64_t v16 = 0;
  long long v155 = (unint64_t)v185;
  double v17 = *((double *)&v186 + 1);
  float64x2_t v154 = (float64x2_t)(unint64_t)v186;
  long long v157 = 0uLL;
  *(void *)&long long v156 = v186;
  *((void *)&v156 + 1) = *((void *)&v185 + 1);
  uint64_t v158 = *((void *)&v186 + 1);
  memset(v136, 0, sizeof(v136));
  do
  {
    for (uint64_t i = 0; i != 3; ++i)
      *(double *)&v136[v15 * 8 + i * 8] = v154.f64[v15 + i] / v17;
    ++v16;
    v15 += 3;
  }
  while (v16 != 3);
  uint64_t v19 = 0;
  uint64_t v20 = 0;
  long long v157 = *(_OWORD *)&v136[48];
  uint64_t v158 = *(void *)&v136[64];
  long long v155 = *(_OWORD *)&v136[16];
  long long v156 = *(_OWORD *)&v136[32];
  float64x2_t v154 = *(float64x2_t *)v136;
  long long v150 = (unint64_t)v181;
  double v21 = *((double *)&v182 + 1);
  float64x2_t v149 = (float64x2_t)(unint64_t)v182;
  long long v152 = 0uLL;
  *(void *)&long long v151 = v182;
  *((void *)&v151 + 1) = *((void *)&v181 + 1);
  uint64_t v153 = *((void *)&v182 + 1);
  memset(v136, 0, sizeof(v136));
  do
  {
    for (uint64_t j = 0; j != 3; ++j)
      *(double *)&v136[v19 * 8 + j * 8] = v149.f64[v19 + j] / v21;
    ++v20;
    v19 += 3;
  }
  while (v20 != 3);
  uint64_t v23 = 0;
  long long v151 = *(_OWORD *)&v136[32];
  long long v152 = *(_OWORD *)&v136[48];
  uint64_t v153 = *(void *)&v136[64];
  float64x2_t v149 = *(float64x2_t *)v136;
  long long v150 = *(_OWORD *)&v136[16];
  v147[2] = v176;
  v147[3] = v177;
  uint64_t v148 = v178;
  v147[0] = v174;
  v147[1] = v175;
  long long v145 = 0uLL;
  double v146 = 0.0;
  do
  {
    *(double *)((char *)&v145 + v23) = *(double *)((char *)&v172 + v23) - *(double *)((char *)&v183 + v23);
    v23 += 8;
  }
  while (v23 != 24);
  if (!*((unsigned char *)a3 + 529))
  {
    uint64_t v24 = 0;
    memset(v136, 0, 24);
    do
    {
      *(double *)&v136[v24] = *(double *)((char *)&v183 + v24) - *(double *)((char *)&v187 + v24);
      v24 += 8;
    }
    while (v24 != 24);
    long long v145 = *(_OWORD *)v136;
    double v146 = *(double *)&v136[16];
  }
  sub_10002D8A8((uint64_t)v163, (uint64_t)v141);
  sub_10002D8A8((uint64_t)v159, (uint64_t)v140);
  sub_100023964((uint64_t)v141, (uint64_t)v140, &v154, &v149, (uint64_t)v147, (uint64_t)&v145, 1, (uint64_t)v142);
  sub_100003224((uint64_t)v140);
  sub_100003224((uint64_t)v141);
  uint64_t v25 = 0;
  memset(&v136[40], 0, 32);
  uint64_t v137 = 0;
  memset(&v136[8], 0, 32);
  *(void *)double v136 = 0x3FF0000000000000;
  *(void *)&v136[40] = 0x3FF0000000000000;
  double v139 = 0.0;
  uint64_t v138 = 0x3FF0000000000000;
  long long v132 = 0u;
  long long v133 = 0u;
  double v26 = &v130;
  long long v130 = 0u;
  long long v131 = 0u;
  uint64_t v134 = 0;
  do
  {
    for (uint64_t k = 0; k != 3; ++k)
    {
      if (v25 == k) {
        double v28 = 1.0;
      }
      else {
        double v28 = 0.0;
      }
      *((double *)v26 + k) = v28;
    }
    ++v25;
    double v26 = (long long *)((char *)v26 + 24);
  }
  while (v25 != 3);
  uint64_t v29 = 0;
  *(void *)&long long v128 = 0;
  long long v126 = 0u;
  long long v127 = 0u;
  long long v124 = 0u;
  long long v125 = 0u;
  uint64_t v30 = &v154;
  do
  {
    uint64_t v31 = 0;
    unsigned int v32 = &v130;
    do
    {
      uint64_t v33 = 0;
      double v34 = 0.0;
      uint64_t v35 = (double *)v32;
      do
      {
        double v36 = *v35;
        v35 += 3;
        double v34 = v34 + v30->f64[v33++] * v36;
      }
      while (v33 != 3);
      *((double *)&v124 + 3 * v29 + v31++) = v34;
      unsigned int v32 = (long long *)((char *)v32 + 8);
    }
    while (v31 != 3);
    ++v29;
    uint64_t v30 = (float64x2_t *)((char *)v30 + 24);
  }
  while (v29 != 3);
  uint64_t v37 = 0;
  memset(v135, 0, sizeof(v135));
  BOOL v38 = &v124;
  do
  {
    uint64_t v39 = 0;
    unsigned int v40 = (double *)v136;
    do
    {
      uint64_t v41 = 0;
      double v42 = 0.0;
      BOOL v43 = v40;
      do
      {
        double v44 = *v43;
        v43 += 4;
        double v42 = v42 + *(double *)((char *)v38 + v41) * v44;
        v41 += 8;
      }
      while (v41 != 24);
      *((double *)&v135[2 * v37] + v39++) = v42;
      ++v40;
    }
    while (v39 != 4);
    ++v37;
    BOOL v38 = (long long *)((char *)v38 + 24);
  }
  while (v37 != 3);
  uint64_t v45 = 0;
  *(double *)&v136[24] = -*(double *)&v145;
  *(double *)&v136[56] = -*((double *)&v145 + 1);
  double v139 = -v146;
  uint64_t v123 = 0;
  long long v121 = 0u;
  long long v122 = 0u;
  long long v119 = 0u;
  long long v120 = 0u;
  uint64_t v46 = &v119;
  BOOL v47 = v147;
  do
  {
    uint64_t v48 = 0;
    uint64_t v49 = v46;
    do
    {
      *(void *)uint64_t v49 = *(void *)((char *)v47 + v48);
      uint64_t v49 = (long long *)((char *)v49 + 24);
      v48 += 8;
    }
    while (v48 != 24);
    ++v45;
    uint64_t v46 = (long long *)((char *)v46 + 8);
    BOOL v47 = (_OWORD *)((char *)v47 + 24);
  }
  while (v45 != 3);
  uint64_t v50 = 0;
  uint64_t v134 = 0;
  long long v132 = 0u;
  long long v133 = 0u;
  long long v130 = 0u;
  long long v131 = 0u;
  unsigned int v51 = &v149;
  do
  {
    uint64_t v52 = 0;
    uint64_t v53 = &v119;
    do
    {
      uint64_t v54 = 0;
      double v55 = 0.0;
      double v56 = (double *)v53;
      do
      {
        double v57 = *v56;
        v56 += 3;
        double v55 = v55 + v51->f64[v54++] * v57;
      }
      while (v54 != 3);
      *((double *)&v130 + 3 * v50 + v52++) = v55;
      uint64_t v53 = (long long *)((char *)v53 + 8);
    }
    while (v52 != 3);
    ++v50;
    unsigned int v51 = (float64x2_t *)((char *)v51 + 24);
  }
  while (v50 != 3);
  uint64_t v58 = 0;
  long long v128 = 0u;
  long long v129 = 0u;
  long long v126 = 0u;
  long long v127 = 0u;
  long long v124 = 0u;
  long long v125 = 0u;
  int v59 = &v130;
  do
  {
    uint64_t v60 = 0;
    char v61 = (double *)v136;
    do
    {
      uint64_t v62 = 0;
      double v63 = 0.0;
      double v64 = v61;
      do
      {
        double v65 = *v64;
        v64 += 4;
        double v63 = v63 + *(double *)((char *)v59 + v62) * v65;
        v62 += 8;
      }
      while (v62 != 24);
      *((double *)&v124 + 4 * v58 + v60++) = v63;
      ++v61;
    }
    while (v60 != 4);
    ++v58;
    int v59 = (long long *)((char *)v59 + 24);
  }
  while (v58 != 3);
  sub_1000032CC((uint64_t)&v119, 4, v144);
  *(void *)&long long v119 = &off_100096568;
  LODWORD(v131) = 1;
  DWORD1(v131) = v144;
  unsigned int v116 = 1;
  unsigned int v117 = v144;
  char v118 = 0;
  *(void *)&long long v130 = off_100095A80;
  *((void *)&v130 + 1) = 0;
  BYTE8(v131) = 0;
  double v114 = &off_100095AB0;
  __src = v143;
  sub_100003224((uint64_t)&v130);
  LODWORD(v131) = 1;
  DWORD1(v131) = DWORD1(v120);
  unsigned int v111 = 1;
  unsigned int v112 = DWORD1(v120);
  char v113 = 0;
  *(void *)&long long v130 = off_100095A80;
  *((void *)&v130 + 1) = 0;
  BYTE8(v131) = 0;
  uint64_t v109 = &off_100095AB0;
  __dst = (void *)*((void *)&v119 + 1);
  sub_100003224((uint64_t)&v130);
  sub_100004500((uint64_t)&v109, 1, v117);
  memcpy(__dst, __src, 8 * v111 * (unint64_t)v112);
  sub_100003224((uint64_t)&v109);
  sub_100003224((uint64_t)&v114);
  LODWORD(v131) = 1;
  DWORD1(v131) = v144;
  unsigned int v116 = 1;
  unsigned int v117 = v144;
  char v118 = 0;
  *(void *)&long long v130 = off_100095A80;
  *((void *)&v130 + 1) = 0;
  BYTE8(v131) = 0;
  double v114 = &off_100095AB0;
  __src = &v143[8 * v144];
  sub_100003224((uint64_t)&v130);
  LODWORD(v131) = 1;
  DWORD1(v131) = DWORD1(v120);
  unsigned int v111 = 1;
  unsigned int v112 = DWORD1(v120);
  char v113 = 0;
  *(void *)&long long v130 = off_100095A80;
  *((void *)&v130 + 1) = 0;
  BYTE8(v131) = 0;
  uint64_t v109 = &off_100095AB0;
  __dst = (void *)(*((void *)&v119 + 1) + 8 * DWORD1(v120));
  sub_100003224((uint64_t)&v130);
  sub_100004500((uint64_t)&v109, v116, v117);
  memcpy(__dst, __src, 8 * v111 * (unint64_t)v112);
  sub_100003224((uint64_t)&v109);
  sub_100003224((uint64_t)&v114);
  LODWORD(v131) = 1;
  DWORD1(v131) = v144;
  unsigned int v116 = 1;
  unsigned int v117 = v144;
  char v118 = 0;
  *(void *)&long long v130 = off_100095A80;
  *((void *)&v130 + 1) = 0;
  BYTE8(v131) = 0;
  double v114 = &off_100095AB0;
  __src = &v143[16 * v144];
  sub_100003224((uint64_t)&v130);
  LODWORD(v131) = 1;
  DWORD1(v131) = DWORD1(v120);
  unsigned int v111 = 1;
  unsigned int v112 = DWORD1(v120);
  char v113 = 0;
  *(void *)&long long v130 = off_100095A80;
  *((void *)&v130 + 1) = 0;
  BYTE8(v131) = 0;
  uint64_t v109 = &off_100095AB0;
  __dst = (void *)(*((void *)&v119 + 1) + 8 * (2 * DWORD1(v120)));
  sub_100003224((uint64_t)&v130);
  sub_100004500((uint64_t)&v109, v116, v117);
  memcpy(__dst, __src, 8 * v111 * (unint64_t)v112);
  sub_100003224((uint64_t)&v109);
  sub_100003224((uint64_t)&v114);
  uint64_t v66 = DWORD1(v120);
  if (DWORD1(v120))
  {
    if (v120 < 4) {
      __assert_rtn("operator()", "Matrix.hpp", 119, "row < m_rows && col < m_cols");
    }
    uint64_t v67 = 8 * (3 * DWORD1(v120));
    do
    {
      *(void *)(*((void *)&v119 + 1) + v67) = 0x3FF0000000000000;
      v67 += 8;
      --v66;
    }
    while (v66);
  }
  sub_10002DA34((uint64_t)v135, (uint64_t)&v119, (uint64_t)&v130);
  sub_10002D784((uint64_t)&v130, (uint64_t)&v114);
  sub_10002DA34((uint64_t)&v124, (uint64_t)&v119, (uint64_t)&v109);
  sub_10002D784((uint64_t)&v109, (uint64_t)v105);
  sub_1000032CC((uint64_t)v102, 1, v117);
  v102[0] = &off_100095AB0;
  sub_1000032CC((uint64_t)v99, 1, v117);
  v99[0] = &off_100095AB0;
  uint64_t v68 = v104;
  if (v104)
  {
    if (v116)
    {
      unint64_t v69 = 0;
      uint64_t v70 = v117;
      unsigned int v71 = v165;
      unint64_t v72 = v166;
      unsigned int v73 = v107;
      unint64_t v74 = v108;
      unsigned int v75 = v161;
      unint64_t v76 = v162;
      int v77 = v100;
      BOOL v80 = v116 < 2 || v165 < 2 || v103 == 0;
      uint64_t v81 = 8 * v108;
      uint64_t v82 = 8 * v162;
      while (v70 != v69)
      {
        BOOL v83 = !v71 || v69 >= v72;
        char v84 = v83 || v80;
        if (v84) {
          break;
        }
        long long v85 = (double *)((char *)__src + 8 * v69);
        long long v86 = (double *)(v164 + 8 * v69);
        *(double *)(v102[1] + 8 * v69) = (*v85 - *v86) * v17 * ((*v85 - *v86) * v17)
                                       + v17 * (v85[v70] - v86[v72]) * (v17 * (v85[v70] - v86[v72]));
        if (!v73 || v69 >= v74 || !v75 || v69 >= v76 || v73 < 2 || v75 < 2 || !v77 || v69 >= v101) {
          break;
        }
        double v87 = (*(double *)(v106 + 8 * v69) - *(double *)(v160 + 8 * v69)) * v21;
        double v88 = v21 * (*(double *)(v106 + v81 + 8 * v69) - *(double *)(v160 + v82 + 8 * v69));
        *(double *)(v99[1] + 8 * v69++) = v87 * v87 + v88 * v88;
        if (v68 == v69) {
          goto LABEL_83;
        }
      }
    }
    __assert_rtn("operator()", "Matrix.hpp", 119, "row < m_rows && col < m_cols");
  }
LABEL_83:
  sub_10002DAA8((uint64_t)v102, (uint64_t)v99, (uint64_t)v90);
  sub_10002DB50((uint64_t)v90, (uint64_t)v91);
  uint64_t v89 = v92;
  char v98 = v94;
  uint64_t v92 = 0;
  char v94 = 0;
  v95[0] = &off_100095AB0;
  v95[1] = v89;
  int v96 = 1;
  int v97 = v93;
  sub_100003224((uint64_t)v91);
  sub_100003224((uint64_t)v90);
  sub_10002DBA4((uint64_t)v95);
}

void sub_10002D3DC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,char a25,uint64_t a26,uint64_t a27,uint64_t a28,char a29,uint64_t a30,uint64_t a31,uint64_t a32,char a33,uint64_t a34,uint64_t a35,uint64_t a36,char a37,uint64_t a38,uint64_t a39,uint64_t a40,char a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,char a63)
{
}

_DWORD *sub_10002D4EC(_DWORD *result, unsigned int a2, unsigned int a3, uint64_t a4)
{
  long long v5 = result;
  double v6 = (double)a2 / (double)a3;
  if (v6 <= 1.0)
  {
    if (result[5] == *(_DWORD *)(a4 + 20))
    {
      sub_100004758(a4, result[4], result[5]);
      long long v9 = *(void **)(a4 + 8);
      uint64_t v10 = (const void *)*((void *)v5 + 1);
      size_t v11 = 4 * *(unsigned int *)(a4 + 16) * (unint64_t)*(unsigned int *)(a4 + 20);
      return memcpy(v9, v10, v11);
    }
    else if (a3)
    {
      for (unint64_t i = 0; i != a3; ++i)
      {
        if (i >= (result[5] * result[4])) {
          sub_100075DE0();
        }
        if (i >= (*(_DWORD *)(a4 + 20) * *(_DWORD *)(a4 + 16))) {
          sub_100075DB4();
        }
        *(_DWORD *)(*(void *)(a4 + 8) + 4 * i) = *(_DWORD *)(*((void *)result + 1) + 4 * i);
      }
    }
  }
  else if (a3)
  {
    for (unint64_t j = 0; j != a3; *(_DWORD *)(*(void *)(a4 + 8) + 4 * j++) = *(_DWORD *)(*((void *)result + 1) + 4 * v8))
    {
      unsigned int v8 = (int)(v6 * (double)j);
      if (result[5] * result[4] <= v8) {
        sub_100075DE0();
      }
      if (j >= (*(_DWORD *)(a4 + 20) * *(_DWORD *)(a4 + 16))) {
        sub_100075DB4();
      }
    }
  }
  return result;
}

uint64_t sub_10002D628(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  if (*(unsigned char *)(a4 + 560))
  {
    uint64_t v6 = 0;
    long long v12 = 0uLL;
    uint64_t v13 = 0;
    do
    {
      *(double *)((char *)&v12 + v6) = *(double *)(a4 + v6 + 360) - *(double *)(a4 + v6 + 32);
      v6 += 8;
    }
    while (v6 != 24);
    *(_OWORD *)(a6 + 72) = v12;
    *(void *)(a6 + 88) = v13;
    if (!*(unsigned char *)(a4 + 529))
    {
      uint64_t v7 = 0;
      long long v12 = 0uLL;
      uint64_t v13 = 0;
      do
      {
        *(double *)((char *)&v12 + v7) = *(double *)(a4 + v7 + 32) - *(double *)(a4 + v7 + 88);
        v7 += 8;
      }
      while (v7 != 24);
      *(_OWORD *)(a6 + 72) = v12;
      *(void *)(a6 + 88) = v13;
    }
    LODWORD(v12) = 0;
    sub_100024A70(a1);
  }
  *(double *)(a6 + 96) = *(double *)(a4 + 72) / *(double *)(a4 + 80);
  if (a5 != a6)
  {
    *(_OWORD *)a6 = *(_OWORD *)a5;
    long long v8 = *(_OWORD *)(a5 + 16);
    long long v9 = *(_OWORD *)(a5 + 32);
    long long v10 = *(_OWORD *)(a5 + 48);
    *(void *)(a6 + 64) = *(void *)(a5 + 64);
    *(_OWORD *)(a6 + 32) = v9;
    *(_OWORD *)(a6 + 48) = v10;
    *(_OWORD *)(a6 + 16) = v8;
  }
  return 0xFFFFFFFFLL;
}

uint64_t sub_10002D784@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4 = *(unsigned int *)(a1 + 20);
  uint64_t result = sub_1000032CC(a2, 2, v4);
  *(void *)a2 = &off_100096468;
  if (v4)
  {
    unint64_t v6 = 0;
    unsigned int v7 = *(_DWORD *)(a1 + 16);
    int v8 = 119;
    do
    {
      unint64_t v9 = 0;
      unint64_t v10 = *(unsigned int *)(a1 + 20);
      unint64_t v11 = *(unsigned int *)(a2 + 16);
      unint64_t v12 = *(unsigned int *)(a2 + 20);
      if (v7) {
        BOOL v13 = v6 >= v10;
      }
      else {
        BOOL v13 = 1;
      }
      char v14 = v13;
      char v15 = 1;
      do
      {
        if ((v14 & 1) != 0 || v7 < 3)
        {
          int v8 = 125;
LABEL_18:
          __assert_rtn("operator()", "Matrix.hpp", v8, "row < m_rows && col < m_cols");
        }
        if (v9 >= v11 || v6 >= v12) {
          goto LABEL_18;
        }
        char v16 = v15;
        char v15 = 0;
        uint64_t v17 = *(void *)(a1 + 8) + 8 * v6;
        double v18 = *(double *)(v17 + 8 * v9 * v10);
        double v19 = *(double *)(v17 + 8 * (2 * v10));
        uint64_t result = *(void *)(a2 + 8) + 8 * v6;
        *(double *)(result + 8 * v9 * v12) = v18 / v19;
        unint64_t v9 = 1;
      }
      while ((v16 & 1) != 0);
      ++v6;
    }
    while (v6 != v4);
  }
  return result;
}

void sub_10002D894(_Unwind_Exception *a1)
{
  sub_100003224(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_10002D8A8@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4 = *(unsigned int *)(a1 + 20);
  uint64_t result = sub_1000032CC(a2, 3, v4);
  *(void *)a2 = &off_100095BC8;
  if (v4)
  {
    unsigned int v6 = *(_DWORD *)(a1 + 16);
    if (v6)
    {
      unint64_t v7 = 0;
      uint64_t v8 = *(unsigned int *)(a1 + 20);
      unsigned int v9 = *(_DWORD *)(a2 + 16);
      unint64_t v10 = *(unsigned int *)(a2 + 20);
      BOOL v12 = v6 < 2 || v9 < 2;
      int v13 = 119;
      while (v8 != v7)
      {
        if (!v9 || v7 >= v10) {
          goto LABEL_22;
        }
        *(void *)(*(void *)(a2 + 8) + 8 * v7) = *(void *)(*(void *)(a1 + 8) + 8 * v7);
        if (v12)
        {
          if (v6 >= 2) {
            int v14 = 119;
          }
          else {
            int v14 = 125;
          }
          __assert_rtn("operator()", "Matrix.hpp", v14, "row < m_rows && col < m_cols");
        }
        *(void *)(*(void *)(a2 + 8) + 8 * v10 + 8 * v7) = *(void *)(*(void *)(a1 + 8) + 8 * v8 + 8 * v7);
        if (v9 == 2) {
          __assert_rtn("operator()", "Matrix.hpp", 119, "row < m_rows && col < m_cols");
        }
        uint64_t result = *(void *)(a2 + 8) + 8 * (2 * v10);
        *(void *)(result + 8 * v7++) = 0x3FF0000000000000;
        if (v4 == v7) {
          return result;
        }
      }
    }
    int v13 = 125;
LABEL_22:
    __assert_rtn("operator()", "Matrix.hpp", v13, "row < m_rows && col < m_cols");
  }
  return result;
}

void sub_10002DA18(_Unwind_Exception *a1)
{
  sub_100003224(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_10002DA34@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  sub_10002DC90(a1, a2, (uint64_t)&v7);
  uint64_t v4 = v8;
  int v5 = v9;
  *(unsigned char *)(a3 + 24) = v10;
  uint64_t v8 = 0;
  char v10 = 0;
  *(void *)a3 = &off_100095BC8;
  *(void *)(a3 + 8) = v4;
  *(_DWORD *)(a3 + 16) = 3;
  *(_DWORD *)(a3 + 20) = v5;
  return sub_100003224((uint64_t)&v7);
}

uint64_t sub_10002DAA8@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  int v5 = *(_DWORD *)(a1 + 16);
  if (v5 != *(_DWORD *)(a2 + 16)) {
    sub_100075E64();
  }
  uint64_t result = sub_1000032CC(a3, v5, *(_DWORD *)(a2 + 20) + *(_DWORD *)(a1 + 20));
  int v7 = *(_DWORD *)(a1 + 16);
  if (v7)
  {
    int v8 = 0;
    int v9 = *(uint64_t **)(a2 + 8);
    char v10 = *(uint64_t **)(a1 + 8);
    unint64_t v11 = *(void **)(result + 8);
    int v12 = *(_DWORD *)(a1 + 20);
    int v13 = *(_DWORD *)(a2 + 20);
    do
    {
      for (int i = v12; i; --i)
      {
        uint64_t v15 = *v10++;
        *v11++ = v15;
      }
      for (int j = v13; j; --j)
      {
        uint64_t v17 = *v9++;
        *v11++ = v17;
      }
      ++v8;
    }
    while (v8 != v7);
  }
  return result;
}

double sub_10002DB50@<D0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v3 = sub_1000032CC(a2, *(_DWORD *)(a1 + 16), *(_DWORD *)(a1 + 20));
  int v5 = *(_DWORD *)(a1 + 20) * *(_DWORD *)(a1 + 16);
  if (v5)
  {
    unsigned int v6 = *(double **)(a1 + 8);
    int v7 = *(double **)(v3 + 8);
    do
    {
      double v8 = *v6++;
      double result = sqrt(v8);
      *v7++ = result;
      --v5;
    }
    while (v5);
  }
  return result;
}

void sub_10002DBA4(uint64_t a1)
{
  sub_100028AD0((uint64_t)v1, a1, 0, -1);
}

void sub_10002DC40(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_10002DC58(uint64_t a1)
{
  sub_100003224(a1);

  operator delete();
}

uint64_t sub_10002DC90@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t result = a3;
  if (*(_DWORD *)(a2 + 16) == 4)
  {
    uint64_t result = sub_1000032CC(a3, 3, *(_DWORD *)(a2 + 20));
    uint64_t v6 = 0;
    uint64_t v7 = *(void *)(a2 + 8);
    uint64_t v8 = *(void *)(result + 8);
    uint64_t v9 = *(unsigned int *)(a2 + 20);
    int v10 = *(_DWORD *)(a2 + 20);
    do
    {
      if (v10 >= 1)
      {
        uint64_t v11 = 0;
        uint64_t v12 = v7;
        do
        {
          uint64_t v13 = 0;
          double v14 = 0.0;
          uint64_t result = v12;
          do
          {
            double v14 = v14 + *(double *)(a1 + v13) * *(double *)result;
            v13 += 8;
            result += 8 * (int)v9;
          }
          while (v13 != 32);
          *(double *)(v8 + 8 * v6 * (int)v9 + 8 * v11++) = v14;
          v12 += 8;
        }
        while (v11 != v9);
      }
      ++v6;
      a1 += 32;
    }
    while (v6 != 3);
  }
  else
  {
    *(void *)a3 = off_100095A80;
    *(void *)(a3 + 8) = 0;
    *(void *)(a3 + 16) = 0;
    *(unsigned char *)(a3 + 24) = 0;
  }
  return result;
}

void sub_10002DD78(uint64_t a1, uint64_t a2)
{
  *(_WORD *)(a1 + 8) = 0;
  *(void *)(a1 + 12) = &_mh_execute_header;
  *(_DWORD *)(a1 + 20) = 0;
  *(unsigned char *)(a1 + 24) = 0;
  *(void *)(a1 + 32) = a2;
  *(void *)(a1 + 40) = 0;
  *(void *)a1 = off_1000965A0;
  *(_DWORD *)(a1 + 48) = 0;
  *(void *)(a1 + 56) = 0;
  operator new();
}

void sub_10002DE38()
{
}

uint64_t sub_10002DE60(uint64_t a1)
{
  *(void *)a1 = off_1000965A0;
  uint64_t v2 = *(NSObject **)(a1 + 56);
  if (v2)
  {
    dispatch_sync(v2, &stru_1000965D0);
    dispatch_release(*(dispatch_object_t *)(a1 + 56));
    *(void *)(a1 + 56) = 0;
  }
  uint64_t v3 = *(void *)(a1 + 40);
  if (v3)
  {
    if (*(void *)v3)
    {
      RgbIrCalibration::~RgbIrCalibration(*(RgbIrCalibration **)v3);
      operator delete();
    }
    uint64_t v4 = *(void **)(v3 + 8);
    if (!v4 || (v4, *(void *)(a1 + 40))) {
      operator delete();
    }
    *(void *)(a1 + 40) = 0;
  }
  return a1;
}

void sub_10002DF28(uint64_t a1)
{
  sub_10002DE60(a1);

  operator delete();
}

uint64_t sub_10002DF60(uint64_t result, char a2)
{
  *(unsigned char *)(result + 8) = a2;
  return result;
}

uint64_t sub_10002DF68(uint64_t result, int a2)
{
  *(_DWORD *)(result + 48) = a2;
  return result;
}

uint64_t sub_10002DF70(uint64_t result, char a2)
{
  *(unsigned char *)(result + 22) = a2;
  return result;
}

uint64_t sub_10002DF78(uint64_t result, char a2)
{
  *(unsigned char *)(result + 23) = a2;
  return result;
}

uint64_t sub_10002DF80(uint64_t result)
{
  *(unsigned char *)(result + 24) = 1;
  return result;
}

uint64_t sub_10002DF8C(uint64_t result)
{
  *(unsigned char *)(result + 24) = 1;
  uint64_t v1 = *(uint64_t **)(result + 40);
  if (v1)
  {
    uint64_t result = *v1;
    if (*v1) {
      return RgbIrCalibration::abort((RgbIrCalibration *)result);
    }
  }
  return result;
}

uint64_t sub_10002DFAC(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 24);
}

__n128 sub_10002DFB4(uint64_t a1, uint64_t a2)
{
  __n128 result = *(__n128 *)a2;
  long long v3 = *(_OWORD *)(a2 + 16);
  *(void *)(a1 + 96) = *(void *)(a2 + 32);
  *(__n128 *)(a1 + 64) = result;
  *(_OWORD *)(a1 + 80) = v3;
  return result;
}

uint64_t sub_10002DFC8(uint64_t result, __int16 a2)
{
  *(_WORD *)(result + 104) = a2;
  return result;
}

uint64_t sub_10002DFD0()
{
  uint64_t v0 = __chkstk_darwin();
  if (!*(unsigned char *)(v0 + 9))
  {
    uint64_t v4 = v0;
    if (*(unsigned char *)(v0 + 20))
    {
      if (*(unsigned char *)(v0 + 8))
      {
        os_log_t v5 = (os_log_t)off_1002BBC90;
        if (off_1002BBC90 == &_os_log_default)
        {
          os_log_t v5 = os_log_create("com.apple.isp", "general");
          off_1002BBC90 = v5;
        }
        if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
        {
          LOWORD(v9[0]) = 0;
          _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "Pearl Calibration (MI): Already ran algorithm\n", (uint8_t *)v9, 2u);
        }
      }
    }
    else if (*(_DWORD *)(v0 + 12) < *(_DWORD *)(v0 + 16))
    {
      uint64_t v6 = v2;
      uint64_t v7 = v1;
      v9[5] = 0;
      v9[6] = 0;
      CFRetain(v2);
      CFRetain(v7);
      CVPixelBufferCreateFromCVImageBufferRef();
      if (v6) {
        CFRelease(v6);
      }
      if (v7) {
        CFRelease(v7);
      }
      if (*(unsigned char *)(v4 + 8))
      {
        os_log_t v8 = (os_log_t)off_1002BBC90;
        if (off_1002BBC90 == &_os_log_default)
        {
          os_log_t v8 = os_log_create("com.apple.isp", "general");
          off_1002BBC90 = v8;
        }
        if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR)) {
          sub_100075E90();
        }
      }
    }
  }
  return 3758097084;
}

void sub_10002E364(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 40);
  if ((CVPixelBufferGetPixelFormatType(*(CVPixelBufferRef *)(*(void *)(*(void *)(a1 + 32) + 8) + 24)) | 0x10) == 0x34323076)
  {
    CVReturn v3 = 0;
    BOOL v4 = 1;
  }
  else
  {
    uint64_t v5 = *(void *)(*(void *)(a1 + 32) + 8);
    uint64_t v6 = *(__CVBuffer **)(v5 + 24);
    *(void *)(v5 + 24) = 0;
    size_t Width = CVPixelBufferGetWidth(v6);
    size_t Height = CVPixelBufferGetHeight(v6);
    unint64_t v9 = Width >> 2;
    if (Width <= 0xA03) {
      unint64_t v9 = 640;
    }
    if (v9 >= Width) {
      unint64_t v9 = Width;
    }
    size_t v10 = (int)(2 * llroundf((float)v9 * 0.5));
    size_t v11 = (int)(2 * llroundf((float)(Height * v10 / Width) * 0.5));
    keys = (void *)kCVPixelBufferIOSurfacePropertiesKey;
    values = CFDictionaryCreate(kCFAllocatorDefault, 0, 0, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    CFDictionaryRef v12 = CFDictionaryCreate(kCFAllocatorDefault, (const void **)&keys, (const void **)&values, 1, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    CVReturn v3 = CVPixelBufferCreate(kCFAllocatorDefault, v10, v11, 0x34323076u, v12, (CVPixelBufferRef *)(*(void *)(*(void *)(a1 + 32) + 8) + 24));
    CFRelease(values);
    CFRelease(v12);
    if (v3)
    {
      BOOL v4 = 0;
    }
    else
    {
      BOOL v4 = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) != 0;
      VTPixelTransferSessionRef pixelTransferSessionOut = 0;
      OSStatus v13 = VTPixelTransferSessionCreate(kCFAllocatorDefault, &pixelTransferSessionOut);
      if (v13)
      {
        CVReturn v3 = v13;
        double v14 = 0;
        VTPixelTransferSessionRef pixelTransferSessionOut = 0;
      }
      else
      {
        CVReturn v3 = VTPixelTransferSessionTransferImage(pixelTransferSessionOut, v6, *(CVPixelBufferRef *)(*(void *)(*(void *)(a1 + 32) + 8) + 24));
        double v14 = pixelTransferSessionOut;
      }
      VTPixelTransferSessionInvalidate(v14);
      CFRelease(pixelTransferSessionOut);
    }
    CVBufferRelease(v6);
  }
  if (*(unsigned char *)(v2 + 23)) {
    sub_10002E778(*(__CVBuffer **)(*(void *)(*(void *)(a1 + 32) + 8) + 24), *(const void **)(a1 + 48), *(FILE **)(a1 + 56), *(const void **)(a1 + 64), *(FILE **)(a1 + 72));
  }
  keys = 0;
  if (v3) {
    BOOL v15 = 0;
  }
  else {
    BOOL v15 = v4;
  }
  if (v15)
  {
    size_t WidthOfPlane = CVPixelBufferGetWidthOfPlane(*(CVPixelBufferRef *)(*(void *)(*(void *)(a1 + 32) + 8) + 24), 0);
    size_t HeightOfPlane = CVPixelBufferGetHeightOfPlane(*(CVPixelBufferRef *)(*(void *)(*(void *)(a1 + 32) + 8) + 24), 0);
    if (!CVPixelBufferCreate(kCFAllocatorDefault, WidthOfPlane, HeightOfPlane, 0x4C303038u, *(CFDictionaryRef *)(a1 + 48), (CVPixelBufferRef *)&keys))
    {
      CVPixelBufferLockBaseAddress(*(CVPixelBufferRef *)(*(void *)(*(void *)(a1 + 32) + 8) + 24), 1uLL);
      BaseAddressOfPlane = (char *)CVPixelBufferGetBaseAddressOfPlane(*(CVPixelBufferRef *)(*(void *)(*(void *)(a1 + 32) + 8) + 24), 0);
      CVPixelBufferLockBaseAddress((CVPixelBufferRef)keys, 0);
      BaseAddress = (char *)CVPixelBufferGetBaseAddress((CVPixelBufferRef)keys);
      if (BaseAddressOfPlane) {
        BOOL v20 = BaseAddress == 0;
      }
      else {
        BOOL v20 = 1;
      }
      if (!v20)
      {
        double v21 = BaseAddress;
        size_t v22 = CVPixelBufferGetHeight((CVPixelBufferRef)keys);
        size_t v23 = CVPixelBufferGetWidth((CVPixelBufferRef)keys);
        size_t BytesPerRowOfPlane = CVPixelBufferGetBytesPerRowOfPlane(*(CVPixelBufferRef *)(*(void *)(*(void *)(a1 + 32) + 8) + 24), 0);
        size_t BytesPerRow = CVPixelBufferGetBytesPerRow((CVPixelBufferRef)keys);
        if (v22)
        {
          size_t v26 = BytesPerRow;
          do
          {
            memcpy(v21, BaseAddressOfPlane, v23);
            BaseAddressOfPlane += BytesPerRowOfPlane;
            v21 += v26;
            --v22;
          }
          while (v22);
        }
      }
      CVPixelBufferUnlockBaseAddress((CVPixelBufferRef)keys, 0);
      CVPixelBufferUnlockBaseAddress(*(CVPixelBufferRef *)(*(void *)(*(void *)(a1 + 32) + 8) + 24), 1uLL);
    }
  }
  int v27 = *(__CVBuffer **)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  if (v27) {
    CVPixelBufferRelease(v27);
  }
  if (keys) {
    *(unsigned char *)(v2 + 20) = sub_10002EA20(v2, *(void *)(a1 + 56), *(const __CFDictionary **)(a1 + 64), (int)keys, *(CFDictionaryRef *)(a1 + 48), *(void *)(a1 + 72), *(unsigned __int8 *)(a1 + 13248), (double *)(a1 + 80), v2 + 64, *(_WORD *)(v2 + 104));
  }
  CFRelease(*(CFTypeRef *)(a1 + 72));
  CFRelease(*(CFTypeRef *)(a1 + 56));
  if (keys) {
    CFRelease(keys);
  }
  CFRelease(*(CFTypeRef *)(a1 + 48));
  CFRelease(*(CFTypeRef *)(a1 + 64));
  ++*(_DWORD *)(v2 + 12);
  *(unsigned char *)(v2 + 9) = 0;
}

FILE *sub_10002E778(__CVBuffer *a1, const void *a2, FILE *a3, const void *a4, FILE *a5)
{
  time_t v29 = 0;
  setlocale(0, "");
  time(&v29);
  size_t v10 = localtime(&v29);
  strftime(v32, 0x14uLL, "%m%d%g_%H%M%S", v10);
  snprintf(__str, 0x400uLL, "/var/mobile/Media/DCIM/%s-RGBIR-", v32);
  sub_100030190(a2, __str, "Color");
  sub_100030190(a4, __str, "IR");
  if (a1)
  {
    PixelFormatCFNumberType Type = CVPixelBufferGetPixelFormatType(a1);
    v30[0] = HIBYTE(PixelFormatType);
    v30[1] = BYTE2(PixelFormatType);
    v30[2] = BYTE1(PixelFormatType);
    void v30[3] = PixelFormatType;
    v30[4] = 0;
    size_t BytesPerRowOfPlane = CVPixelBufferGetBytesPerRowOfPlane(a1, 0);
    size_t WidthOfPlane = CVPixelBufferGetWidthOfPlane(a1, 0);
    size_t HeightOfPlane = CVPixelBufferGetHeightOfPlane(a1, 0);
    snprintf(__filename, 0x400uLL, "%s%s.%lux%lu.%lu.%s.bin", __str, "Color", WidthOfPlane, HeightOfPlane, BytesPerRowOfPlane, v30);
    if (HeightOfPlane * BytesPerRowOfPlane <= CVPixelBufferGetDataSize(a1))
    {
      BOOL v15 = fopen(__filename, "wb");
      if (v15)
      {
        char v16 = v15;
        CVPixelBufferLockBaseAddress(a1, 0);
        BaseAddressOfPlane = (char *)CVPixelBufferGetBaseAddressOfPlane(a1, 0);
        if (HeightOfPlane)
        {
          double v18 = BaseAddressOfPlane;
          uint64_t v19 = 0;
          unsigned int v20 = 1;
          do
          {
            fwrite(&v18[v19 * BytesPerRowOfPlane], WidthOfPlane, 1uLL, v16);
            uint64_t v19 = v20;
            BOOL v21 = HeightOfPlane > v20++;
          }
          while (v21);
        }
        size_t v22 = CVPixelBufferGetBytesPerRowOfPlane(a1, 1uLL);
        size_t v23 = CVPixelBufferGetHeightOfPlane(a1, 1uLL);
        uint64_t v24 = (char *)CVPixelBufferGetBaseAddressOfPlane(a1, 1uLL);
        if (v23)
        {
          uint64_t v25 = v24;
          uint64_t v26 = 0;
          unsigned int v27 = 1;
          do
          {
            fwrite(&v25[v26 * v22], WidthOfPlane, 1uLL, v16);
            uint64_t v26 = v27;
            BOOL v21 = v23 > v27++;
          }
          while (v21);
        }
        CVPixelBufferUnlockBaseAddress(a1, 0);
        fclose(v16);
      }
    }
  }
  sub_100030298(a3, __str, "IR");
  return sub_100030298(a5, __str, "Depth");
}

uint64_t sub_10002EA20(uint64_t a1, int a2, const __CFDictionary *a3, int a4, CFDictionaryRef theDict, int a6, int a7, double *a8, uint64_t a9, __int16 a10)
{
  int v13 = (int)theDict;
  if (theDict) {
    CFArrayRef Value = (const __CFArray *)CFDictionaryGetValue(theDict, kFigCaptureStreamMetadata_DetectedFacesArray);
  }
  else {
    CFArrayRef Value = 0;
  }
  int valuePtr = -269488145;
  CFNumberRef v19 = (const __CFNumber *)CFDictionaryGetValue(a3, @"StereoGMC-Result");
  if (v19) {
    CFNumberGetValue(v19, kCFNumberIntType, &valuePtr);
  }
  int v31 = 0;
  unsigned int v32 = 0;
  mach_timebase_info(&info);
  int v25 = a6;
  uint64_t v28 = mach_absolute_time();
  os_log_t v20 = (os_log_t)off_1002BBC90;
  if (off_1002BBC90 == &_os_log_default)
  {
    os_log_t v20 = os_log_create("com.apple.isp", "general");
    off_1002BBC90 = v20;
  }
  if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "Pearl Calibration (MI): Starting\n", buf, 2u);
  }
  int v21 = RgbIrCalibration::Calibrate(**(void **)(a1 + 40), a2, a3, a4, v13, v25, a7 ^ 1u, kCFBooleanTrue, a8, Value, a10, a9, &v32, (uint64_t)&v29, (uint64_t)&v31, (uint64_t)&v30);
  uint64_t v22 = (mach_absolute_time() - v28) * info.numer / info.denom / 0xF4240;
  sub_100014594();
  os_log_t v23 = (os_log_t)off_1002BBC90;
  if (off_1002BBC90 == &_os_log_default)
  {
    os_log_t v23 = os_log_create("com.apple.isp", "general");
    off_1002BBC90 = v23;
  }
  if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 67109376;
    int v35 = v21;
    __int16 v36 = 1024;
    int v37 = v22;
    _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "Pearl Calibration (MI): status 0x%08X (%d msec)\n", buf, 0xEu);
  }
  if (!v21) {
    sub_100005F94(&v26);
  }
  return 0;
}

void sub_10002EF94(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, ...)
{
  va_start(va, a15);
  sub_100005F98((uint64_t *)va);
  _Unwind_Resume(a1);
}

FILE *sub_10002EFB8(unsigned char *a1)
{
  sub_100013800();
  __n128 result = fopen("/var/mobile/Library/ISP/Pearl/IsfHistory.bin", "rb");
  if (result)
  {
    CVReturn v3 = result;
    fread(a1, 0xE38uLL, 1uLL, result);
    return (FILE *)fclose(v3);
  }
  else
  {
    *(_DWORD *)a1 = 3;
    a1[4] = 1;
  }
  return result;
}

uint64_t sub_10002F040(uint64_t result, int a2)
{
  *(_DWORD *)(result + 16) = a2;
  return result;
}

uint64_t sub_10002F048()
{
  uint64_t v0 = __chkstk_darwin();
  if (*(unsigned char *)(v0 + 20) && !*(unsigned char *)(v0 + 21))
  {
    uint64_t v2 = v1;
    sub_10002EFB8(v5);
    memcpy(__dst, v2, sizeof(__dst));
    sub_100005F94(&v4);
  }
  if (*(unsigned char *)(v0 + 22))
  {
    *(_WORD *)(v0 + 20) = 0;
    *(_DWORD *)(v0 + 12) = 0;
  }
  return 0;
}

void sub_10002F2B4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100005F98((uint64_t *)va);
  _Unwind_Resume(a1);
}

long double sub_10002F2D4(uint64_t a1, long double *a2)
{
  *a2 = atan2(*(long double *)(a1 + 56), *(long double *)(a1 + 64)) * 1000.0;
  a2[1] = atan2(-*(double *)(a1 + 48), sqrt(*(double *)(a1 + 64) * *(double *)(a1 + 64) + *(double *)(a1 + 56) * *(double *)(a1 + 56)))* 1000.0;
  long double result = atan2(*(long double *)(a1 + 24), *(long double *)a1) * 1000.0;
  a2[2] = result;
  return result;
}

BOOL sub_10002F350(uint64_t a1, uint64_t a2)
{
  return *(void *)(a1 + 32) == a2;
}

CFDictionaryRef sub_10002F360(uint64_t a1)
{
  CFDictionaryRef v1 = *(const __CFDictionary **)(*(void *)(a1 + 40) + 8);
  if (!v1) {
    return 0;
  }
  CFDictionaryRef Copy = CFDictionaryCreateCopy(kCFAllocatorDefault, v1);

  *(void *)(*(void *)(a1 + 40) + 8) = 0;
  return Copy;
}

void sub_10002F3C0(uint64_t a1, uint64_t a2)
{
  *(_WORD *)(a1 + 8) = 0;
  *(void *)(a1 + 12) = &_mh_execute_header;
  *(_DWORD *)(a1 + 20) = 0;
  *(unsigned char *)(a1 + 24) = 0;
  *(void *)(a1 + 32) = a2;
  *(void *)a1 = off_100096628;
  *(_DWORD *)(a1 + 48) = 0;
  *(void *)(a1 + 96) = 0;
  *(void *)(a1 + 56) = 0x3FF0000000000000;
  *(void *)(a1 + 64) = 0;
  *(void *)(a1 + 72) = 0;
  *(void *)(a1 + 80) = 0;
  operator new();
}

uint64_t sub_10002F490(uint64_t a1)
{
  *(void *)a1 = off_100096628;
  uint64_t v2 = *(NSObject **)(a1 + 96);
  if (v2)
  {
    dispatch_sync(v2, &stru_100096658);
    dispatch_release(*(dispatch_object_t *)(a1 + 96));
    *(void *)(a1 + 96) = 0;
  }
  CVReturn v3 = *(const void **)(a1 + 72);
  if (v3)
  {
    CFRelease(v3);
    *(void *)(a1 + 72) = 0;
  }
  uint64_t v4 = *(void *)(a1 + 40);
  if (v4)
  {
    sub_1000303CC(v4);
    operator delete();
  }
  return a1;
}

void sub_10002F530(uint64_t a1)
{
  sub_10002F490(a1);

  operator delete();
}

uint64_t sub_10002F568(uint64_t result, double a2, double a3)
{
  *(double *)(result + 56) = a2;
  *(double *)(result + 64) = a3;
  return result;
}

CFDictionaryRef sub_10002F570(uint64_t a1, CFDictionaryRef theDict)
{
  uint64_t v4 = *(const void **)(a1 + 72);
  if (v4)
  {
    CFRelease(v4);
    *(void *)(a1 + 72) = 0;
  }
  CFDictionaryRef result = CFDictionaryCreateCopy(kCFAllocatorDefault, theDict);
  *(void *)(a1 + 72) = result;
  return result;
}

uint64_t sub_10002F5BC(uint64_t result, double a2)
{
  *(double *)(result + 80) = a2;
  return result;
}

uint64_t sub_10002F5C4(uint64_t a1, __CVBuffer *a2, __CVBuffer *a3, __CVBuffer *a4, const void *a5, const __CFDictionary *a6, int a7, double *a8, unsigned __int16 a9)
{
  if (*(unsigned char *)(a1 + 9))
  {
    uint64_t v10 = 3758097084;
    if (*(unsigned char *)(a1 + 8))
    {
      os_log_t v11 = (os_log_t)off_1002BBC90;
      if (off_1002BBC90 == &_os_log_default)
      {
        os_log_t v11 = os_log_create("com.apple.isp", "general");
        off_1002BBC90 = v11;
      }
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        CFDictionaryRef v12 = "Pearl Calibration (MI): Already running algorithm\n";
LABEL_7:
        _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, v12, buf, 2u);
        return v10;
      }
    }
    return v10;
  }
  uint64_t v19 = 0;
  int32x4_t v78 = 0u;
  long long v79 = 0u;
  *(_OWORD *)buf = 0u;
  int32x4_t v77 = 0u;
  os_log_t v20 = a8 + 1069;
  do
  {
    uint64_t v21 = 0;
    uint64_t v22 = v20;
    do
    {
      double v23 = *v22++;
      float v24 = v23;
      *(float *)&buf[4 * v19 + v21] = v24;
      v21 += 16;
    }
    while (v21 != 48);
    ++v19;
    v20 += 3;
  }
  while (v19 != 3);
  float v25 = a8[1078];
  float v26 = a8[1079];
  float v27 = a8[1080];
  int32x4_t v28 = vzip1q_s32(*(int32x4_t *)buf, v78);
  float32x4_t v29 = (float32x4_t)vtrn2q_s32(*(int32x4_t *)buf, v77);
  v29.i32[2] = v78.i32[1];
  float32x4_t v72 = (float32x4_t)vzip1q_s32(vzip2q_s32(*(int32x4_t *)buf, v78), vdupq_laneq_s32(v77, 2));
  float32x4_t v73 = (float32x4_t)vzip1q_s32(v28, v77);
  float32x4_t v70 = vnegq_f32(vmlaq_n_f32(vmlaq_n_f32(vmulq_n_f32(v73, v25), v29, v26), v72, v27));
  int32x4_t v71 = vzip2q_s32(v28, vdupq_lane_s32(*(int32x2_t *)v77.i8, 1));
  uint64_t v30 = *(void **)(*(void *)(a1 + 40) + 16);
  if (!v30)
  {
    sub_10002FCE8(*(void *)(a1 + 40));
    uint64_t v48 = *(void *)(a1 + 40);
    *(unsigned char *)(v48 + 48) = 0;
    *(void *)uint64_t v48 = 4;
    id v49 = objc_alloc_init((Class)ADPearlColorInFieldCalibrationExecutorParameters);
    [v49 setReportTelemetry:1];
    *(void *)(*(void *)(a1 + 40) + 16) = [objc_alloc((Class)ADPearlColorInFieldCalibrationExecutor) initForEngineType:**(void **)(a1 + 40) andExecutorParameters:v49];

    if ([*(id *)(*(void *)(a1 + 40) + 16) prepare]) {
      goto LABEL_48;
    }
    id v50 = objc_alloc((Class)ADFigCameraCalibrationSource);
    double v51 = *(double *)(a1 + 80);
    *(float *)&double v51 = v51;
    id v52 = [v50 initWithPixelSize:*(void *)(a1 + 72) gdcModel:v51 cameraToPlatformTransform:*(double *)matrix_identity_float4x4.columns[0].i64, *(double *)matrix_identity_float4x4.columns[1].i64, *(double *)matrix_identity_float4x4.columns[2].i64, *(double *)matrix_identity_float4x4.columns[3].i64];
    *(void *)(*(void *)(a1 + 40) + 8) = v52;
    id v53 = [v52 cameraCalibration];
    id v54 = [v53 mutableCopy];
    double Width = (double)CVPixelBufferGetWidth(a4);
    double Height = (double)CVPixelBufferGetHeight(a4);
    [v54 referenceDimensions];
    double v59 = v58 / (Height / Width);
    if (v57 < v59) {
      double v59 = v57;
    }
    [v54 crop:(v57 - v59) * 0.5, (v58 - Height / Width * v59) * 0.5];
    [v54 scale:Width Height];
    id v60 = [objc_msgSend(*(id *)(*(void *)(a1 + 40) + 16), "pipeline") createInterSessionDataWithDictionaryRepresentation:+[NSDictionary dictionaryWithContentsOfFile:](NSDictionary, "dictionaryWithContentsOfFile:", @"/var/mobile/Library/ISP/Pearl/rgbpInterSession.plist")];
    uint64_t v61 = *(void *)(a1 + 40);
    *(void *)(v61 + 24) = v60;
    if (!v60)
    {
      id v60 = [objc_msgSend(*(id *)(v61 + 16), "pipeline") createInterSessionDataWithFactoryPearlToColorTransform:currentPearlToColorTransform:v73.i64, v71.i64, v72.i64, v70.i64, v73.i64, v71.i64, v72.i64, v70.i64];
      *(void *)(*(void *)(a1 + 40) + 24) = v60;
    }
    id v62 = v60;
    id v63 = [v53 copy];
    [*(id *)(*(void *)(a1 + 40) + 16) setColorCameraCalibration:v63];
    [*(id *)(*(void *)(a1 + 40) + 16) setPearlCameraCalibration:v54];

    uint64_t v30 = *(void **)(*(void *)(a1 + 40) + 16);
  }
  if (objc_msgSend(objc_msgSend(v30, "pipeline"), "isColorFrameValid:withMetadata:", a2, a5))
  {
    if ((objc_msgSend(objc_msgSend(*(id *)(*(void *)(a1 + 40) + 16), "pipeline"), "isPearlFrameValid:withMetadata:", a4, a6) & 1) == 0)
    {
      uint64_t v10 = 3758097084;
      if (*(unsigned char *)(a1 + 8))
      {
        os_log_t v11 = (os_log_t)off_1002BBC90;
        if (off_1002BBC90 == &_os_log_default)
        {
          os_log_t v11 = os_log_create("com.apple.isp", "general");
          off_1002BBC90 = v11;
        }
        if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)buf = 0;
          CFDictionaryRef v12 = "Pearl Calibration (MI): pearl frame not valid for algorithm\n";
          goto LABEL_7;
        }
      }
      return v10;
    }
    int v31 = *(void **)(*(void *)(a1 + 40) + 8);
    double WidthOfPlane = (double)CVPixelBufferGetWidthOfPlane(a2, 0);
    [v31 updateForFrameWithDimensions:a5 metadataDictionary:WidthOfPlane heightOfPlane:CVPixelBufferGetHeightOfPlane(a2, 0)];
    id v33 = [*(id *)(*(void *)(a1 + 40) + 8) cameraCalibration];
    id v34 = [v33 mutableCopy];
    double v35 = (double)CVPixelBufferGetWidth(a4);
    double v36 = (double)CVPixelBufferGetHeight(a4);
    [v34 referenceDimensions];
    double v39 = v38 / (v36 / v35);
    if (v37 < v39) {
      double v39 = v37;
    }
    [v34 crop:(v37 - v39) * 0.5, (v38 - v36 / v35 * v39) * 0.5];
    [v34 scale:v35, v36];
    memset(buf, 0, sizeof(buf));
    v77.i64[0] = 0;
    CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(a6, kFigCaptureSampleBufferAttachmentKey_OriginalPresentationTimeStamp);
    CMTimeMakeFromDictionary((CMTime *)buf, Value);
    *(_OWORD *)&time.BOOL value = *(_OWORD *)buf;
    time.epoch = v77.i64[0];
    Float64 Seconds = CMTimeGetSeconds(&time);
    double v42 = *(void **)(*(void *)(a1 + 40) + 16);
    simd_float4 v43 = matrix_identity_float4x4.columns[0];
    simd_float4 v44 = matrix_identity_float4x4.columns[1];
    simd_float4 v45 = matrix_identity_float4x4.columns[2];
    simd_float4 v46 = matrix_identity_float4x4.columns[3];
    if (a7) {
      id v47 = [v42 preprocessInputColorFrame:a2 pearlDepth:a4 pearlPoses:v34 pceCameraCalibration:v33 colorCameraCalibration:*(double *)v43.i64 pearlCameraCalibrationTransform:*(double *)v44.i64 timestamp:*(double *)v45.i64 *(double *)v46.i64 *(double *)v73.i64 *(double *)v71.i64 *(double *)v72.i64 *(double *)v70.i64 *(void *)&Seconds];
    }
    else {
      id v47 = [v42 preprocessInputColorFrame:a2 pearlNormalizedDX:a4 pearlPoses:v34 disparityNormalizationMultiplier:v33 disparityNormalizationOffset:*(double *)v43.i64 disparityNormalizationOffset:*(double *)v44.i64 pceCameraCalibration:*(double *)v45.i64 pceCameraCalibrationTransform:*(double *)v46.i64 colorCameraCalibration:*(double *)(a1 + 56) colorCameraCalibration:*(double *)(a1 + 64) timestamp:*(void *)&Seconds];
    }
    id v64 = v47;

    if (!v64)
    {
      if (a2)
      {
        CVPixelBufferLockBaseAddress(a2, 1uLL);
        CVPixelBufferGetBaseAddressOfPlane(a2, 0);
        CVPixelBufferUnlockBaseAddress(a2, 1uLL);
        int v65 = 0xFFFF;
      }
      else
      {
        int v65 = 0;
      }
      if (a3)
      {
        CVPixelBufferLockBaseAddress(a3, 1uLL);
        CVPixelBufferGetBaseAddress(a3);
        v65 ^= 0xFFFFu;
        CVPixelBufferUnlockBaseAddress(a3, 1uLL);
      }
      if (a4)
      {
        CVPixelBufferLockBaseAddress(a4, 1uLL);
        CVPixelBufferGetBaseAddress(a4);
        v65 ^= 0xFFFFu;
        CVPixelBufferUnlockBaseAddress(a4, 1uLL);
      }
      if (v65 == a9)
      {
        if (*(unsigned char *)(a1 + 23)) {
          sub_10002E778(a2, a5, (FILE *)a3, a6, (FILE *)a4);
        }
        *(unsigned char *)(a1 + 9) = 1;
        id v66 = *(id *)(*(void *)(a1 + 40) + 16);
        id v67 = *(id *)(*(void *)(a1 + 40) + 24);
        uint64_t v68 = *(NSObject **)(a1 + 96);
        block[0] = _NSConcreteStackBlock;
        block[1] = 3221225472;
        block[2] = sub_10002FD48;
        block[3] = &unk_100096678;
        block[4] = a1;
        dispatch_async(v68, block);
        return 0;
      }
    }
LABEL_48:
    uint64_t v10 = 3758097084;
    ++*(_DWORD *)(a1 + 12);
    return v10;
  }
  uint64_t v10 = 3758097084;
  if (*(unsigned char *)(a1 + 8))
  {
    os_log_t v11 = (os_log_t)off_1002BBC90;
    if (off_1002BBC90 == &_os_log_default)
    {
      os_log_t v11 = os_log_create("com.apple.isp", "general");
      off_1002BBC90 = v11;
    }
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      CFDictionaryRef v12 = "Pearl Calibration (MI): color frame not valid for algorithm\n";
      goto LABEL_7;
    }
  }
  return v10;
}

double sub_10002FCE8(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 16);
  if (v2) {

  }
  CVReturn v3 = *(void **)(a1 + 8);
  if (v3) {

  }
  uint64_t v4 = *(void **)(a1 + 32);
  if (v4) {

  }
  uint64_t v5 = *(void **)(a1 + 24);
  if (v5) {

  }
  *(unsigned char *)(a1 + 48) = 0;
  double result = 0.0;
  *(_OWORD *)(a1 + 8) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  return result;
}

void sub_10002FD48(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  uint64_t v2 = *(void **)(*(void *)(v1 + 40) + 32);
  if (v2) {

  }
  uint64_t v3 = objc_opt_new();
  uint64_t v4 = *(void *)(v1 + 40);
  *(void *)(v4 + 32) = v3;
  id v5 = [*(id *)(v4 + 16) executePreprocessedInputsWithInterSessionData:*(void *)(v4 + 24) outResult:v3];
  *(unsigned char *)(v1 + 20) = v5 == 0;
  uint64_t v6 = *(void *)(v1 + 40);
  *(unsigned char *)(v6 + 48) = 0;
  *(unsigned char *)(v1 + 9) = 0;
  ++*(_DWORD *)(v1 + 12);
  if (!v5)
  {
    unsigned int v7 = [*(id *)(v6 + 32) executed];
    uint64_t v6 = *(void *)(v1 + 40);
    if (v7)
    {
      os_log_t v8 = *(void **)(v6 + 40);
      if (v8)
      {

        uint64_t v6 = *(void *)(v1 + 40);
      }
      unint64_t v9 = *(void **)(v6 + 32);
      *(void *)(v6 + 40) = v9;
      id v10 = v9;
      uint64_t v6 = *(void *)(v1 + 40);
    }
  }
  [objc_msgSend(*(id *)(v6 + 24), "persistenceData") writeToFile:@"/var/mobile/Library/ISP/Pearl/rgbpInterSession.plist" atomically:1];

  os_log_t v11 = *(void **)(*(void *)(v1 + 40) + 24);
}

uint64_t sub_10002FE2C(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a1 + 88)) {
    return 0;
  }
  uint64_t v4 = *(void *)(a1 + 40);
  if (!*(void *)(v4 + 40))
  {
    uint64_t v2 = 0;
    goto LABEL_30;
  }
  [*(id *)(v4 + 40) pearlToColorExtrinsics];
  uint64_t v6 = 0;
  LOBYTE(v2) = 0;
  int32x4_t v9 = vzip1q_s32(v7, v8);
  int32x4_t v10 = vzip2q_s32(v7, v8);
  int32x4_t v12 = vdupq_laneq_s32(v11, 2);
  float32x4_t v13 = (float32x4_t)vtrn2q_s32(v7, v11);
  v13.i32[2] = v8.i32[1];
  float32x4_t v14 = (float32x4_t)vzip1q_s32(v9, v11);
  float32x4_t v15 = (float32x4_t)vzip1q_s32(v10, v12);
  __int32 v25 = v8.i32[0];
  uint64_t v24 = v14.i64[0];
  float32x4_t v17 = vnegq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v14, v16.f32[0]), v13, *(float32x2_t *)v16.f32, 1), v15, v16, 2));
  __int32 v27 = v8.i32[1];
  __int32 v29 = v8.i32[2];
  uint64_t v26 = v13.i64[0];
  uint64_t v28 = v15.i64[0];
  __int32 v31 = v17.i32[2];
  uint64_t v30 = v17.i64[0];
  uint64_t v18 = a2 + 8552;
  do
  {
    for (uint64_t i = 0; i != 3; ++i)
    {
      if (v2)
      {
        double v20 = *(float *)((unint64_t)(&v24 + 2 * i) & 0xFFFFFFFFFFFFFFF3 | (4 * (v6 & 3)));
LABEL_9:
        uint64_t v2 = 1;
        goto LABEL_10;
      }
      double v20 = *(float *)((unint64_t)(&v24 + 2 * i) & 0xFFFFFFFFFFFFFFF3 | (4 * (v6 & 3)));
      if (*(double *)(v18 + 8 * i) != v20) {
        goto LABEL_9;
      }
      uint64_t v2 = 0;
LABEL_10:
      *(double *)(v18 + 8 * i) = v20;
    }
    ++v6;
    v18 += 24;
  }
  while (v6 != 3);
  uint64_t v38 = 0;
  uint64_t v39 = 0;
  uint64_t v40 = 0;
  sub_10002F2D4(a2 + 8552, (long double *)&v38);
  os_log_t v21 = (os_log_t)off_1002BBC90;
  if (off_1002BBC90 == &_os_log_default)
  {
    os_log_t v21 = os_log_create("com.apple.isp", "general");
    off_1002BBC90 = v21;
  }
  if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 134218496;
    uint64_t v33 = v38;
    __int16 v34 = 2048;
    uint64_t v35 = v39;
    __int16 v36 = 2048;
    uint64_t v37 = v40;
    _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "Pearl Calibration (MI) finalization: final rotation: (%lf, %f, %f)\n", buf, 0x20u);
  }
  os_log_t v22 = (os_log_t)off_1002BBC90;
  if (v2)
  {
    if (off_1002BBC90 == &_os_log_default)
    {
      os_log_t v22 = os_log_create("com.apple.isp", "general");
      off_1002BBC90 = v22;
    }
    if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "Pearl Calibration (MI) finalization: Updating PCECalib on disk\n", buf, 2u);
    }
    sub_100009BEC(a2);
  }
  else
  {
    if (off_1002BBC90 == &_os_log_default)
    {
      os_log_t v22 = os_log_create("com.apple.isp", "general");
      off_1002BBC90 = v22;
    }
    if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "Pearl Calibration (MI) finalization: No changes to PCECalib\n", buf, 2u);
    }
  }
  *(unsigned char *)(a1 + 21) = 1;

  uint64_t v4 = *(void *)(a1 + 40);
  *(void *)(v4 + 40) = 0;
LABEL_30:
  sub_10002FCE8(v4);
  if (*(unsigned char *)(a1 + 22))
  {
    *(_WORD *)(a1 + 20) = 0;
    *(_DWORD *)(a1 + 12) = 0;
  }
  return v2;
}

id sub_100030140(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 40);
  uint64_t v3 = *(void **)(v2 + 32);
  if (!v3 || *(unsigned char *)(v2 + 48)) {
    return 0;
  }
  id result = [[[v3 dictionaryRepresentation] copy];
  *(unsigned char *)(*(void *)(a1 + 40) + 48) = 1;
  return result;
}

void sub_100030190(const void *a1, const char *a2, const char *a3)
{
  if (a1)
  {
    snprintf(__str, 0x400uLL, "%s%s-metadata.plist", a2, a3);
    CFStringEncoding SystemEncoding = CFStringGetSystemEncoding();
    CFStringRef v5 = CFStringCreateWithCString(kCFAllocatorDefault, __str, SystemEncoding);
    CFURLRef v6 = CFURLCreateWithFileSystemPath(kCFAllocatorDefault, v5, kCFURLPOSIXPathStyle, 0);
    int32x4_t v7 = CFWriteStreamCreateWithFile(kCFAllocatorDefault, v6);
    CFWriteStreamOpen(v7);
    CFPropertyListWrite(a1, v7, kCFPropertyListXMLFormat_v1_0, 0, 0);
    CFWriteStreamClose(v7);
    CFRelease(v7);
    CFRelease(v6);
    CFRelease(v5);
  }
}

FILE *sub_100030298(FILE *result, const char *a2, const char *a3)
{
  if (result)
  {
    CFStringRef v5 = (__CVBuffer *)result;
    PixelFormatCFNumberType Type = CVPixelBufferGetPixelFormatType((CVPixelBufferRef)result);
    v12[0] = HIBYTE(PixelFormatType);
    v12[1] = BYTE2(PixelFormatType);
    _DWORD v12[2] = BYTE1(PixelFormatType);
    _OWORD v12[3] = PixelFormatType;
    void v12[4] = 0;
    size_t BytesPerRow = CVPixelBufferGetBytesPerRow(v5);
    size_t Width = CVPixelBufferGetWidth(v5);
    size_t Height = CVPixelBufferGetHeight(v5);
    snprintf(__str, 0x400uLL, "%s%s.%lux%lu.%lu.%s.bin", a2, a3, Width, Height, BytesPerRow, v12);
    id result = fopen(__str, "wb");
    if (result)
    {
      int32x4_t v10 = result;
      CVPixelBufferLockBaseAddress(v5, 0);
      BaseAddress = CVPixelBufferGetBaseAddress(v5);
      fwrite(BaseAddress, Height * BytesPerRow, 1uLL, v10);
      fclose(v10);
      return (FILE *)CVPixelBufferUnlockBaseAddress(v5, 0);
    }
  }
  return result;
}

uint64_t sub_1000303CC(uint64_t a1)
{
  sub_10002FCE8(a1);
  uint64_t v2 = *(void **)(a1 + 40);
  if (v2) {

  }
  return a1;
}

uint64_t sub_100030404@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  return sub_100030BF4(a1, a2, a3);
}

void sub_100030454(_Unwind_Exception *a1)
{
  sub_100003224(v1);
  _Unwind_Resume(a1);
}

void sub_100030468(uint64_t a1)
{
  sub_100028AD0((uint64_t)&v1, a1, 0, -1);
}

void sub_100030530(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_100030544(uint64_t a1, uint64_t a2, uint64_t a3, double a4, double a5, int8x16_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  uint64_t v118 = 0;
  uint64_t v119 = 0;
  long long v120 = xmmword_100082730;
  uint64_t v121 = 0x3FF0000000000000;
  long long v122 = 0u;
  long long v123 = 0u;
  uint64_t v124 = 0x3FF0000000000000;
  long long v116 = 0u;
  memset(v117, 0, sizeof(v117));
  memset(v115, 0, 72);
  memset(v114, 0, sizeof(v114));
  float32x4_t v13 = &v116;
  sub_1000287E8(a1, &v116, v114, v115, 0.0, a5, a6);
  uint64_t v15 = 0;
  uint64_t v109 = 0;
  long long v107 = 0u;
  long long v108 = 0u;
  long long v105 = 0u;
  long long v106 = 0u;
  do
  {
    uint64_t v16 = 0;
    float32x4_t v17 = (double *)&v119;
    do
    {
      uint64_t v18 = 0;
      double v19 = 0.0;
      double v20 = v17;
      do
      {
        double v21 = *v20;
        v20 += 3;
        double v19 = v19 + *(double *)((char *)v13 + v18) * v21;
        v18 += 8;
      }
      while (v18 != 24);
      *((double *)&v105 + 3 * v15 + v16++) = v19;
      ++v17;
    }
    while (v16 != 3);
    ++v15;
    float32x4_t v13 = (long long *)((char *)v13 + 24);
  }
  while (v15 != 3);
  uint64_t v22 = 0;
  uint64_t v104 = 0;
  long long v102 = 0u;
  long long v103 = 0u;
  long long v100 = 0u;
  long long v101 = 0u;
  double v23 = &v100;
  uint64_t v24 = v115;
  do
  {
    uint64_t v25 = 0;
    uint64_t v26 = v23;
    do
    {
      *(double *)uint64_t v26 = v24[v25];
      uint64_t v26 = (long long *)((char *)v26 + 24);
      ++v25;
    }
    while (v25 != 3);
    ++v22;
    double v23 = (long long *)((char *)v23 + 8);
    v24 += 3;
  }
  while (v22 != 3);
  uint64_t v27 = 0;
  uint64_t v113 = 0;
  long long v111 = 0u;
  long long v112 = 0u;
  memset(v110, 0, sizeof(v110));
  uint64_t v28 = &v105;
  do
  {
    uint64_t v29 = 0;
    uint64_t v30 = &v100;
    do
    {
      uint64_t v31 = 0;
      double v32 = 0.0;
      uint64_t v33 = (double *)v30;
      do
      {
        double v34 = *v33;
        v33 += 3;
        double v32 = v32 + *(double *)((char *)v28 + v31) * v34;
        v31 += 8;
      }
      while (v31 != 24);
      *(double *)&v110[3 * v27 + v29++] = v32;
      uint64_t v30 = (long long *)((char *)v30 + 8);
    }
    while (v29 != 3);
    ++v27;
    uint64_t v28 = (long long *)((char *)v28 + 24);
  }
  while (v27 != 3);
  uint64_t v35 = 0;
  uint64_t v99 = 0;
  long long v97 = 0u;
  long long v98 = 0u;
  long long v95 = 0u;
  long long v96 = 0u;
  __int16 v36 = &v95;
  uint64_t v37 = &v119;
  do
  {
    uint64_t v38 = 0;
    uint64_t v39 = v36;
    do
    {
      *(void *)uint64_t v39 = v37[v38];
      uint64_t v39 = (long long *)((char *)v39 + 24);
      ++v38;
    }
    while (v38 != 3);
    ++v35;
    __int16 v36 = (long long *)((char *)v36 + 8);
    v37 += 3;
  }
  while (v35 != 3);
  uint64_t v40 = 0;
  uint64_t v104 = 0;
  long long v102 = 0u;
  long long v103 = 0u;
  long long v100 = 0u;
  long long v101 = 0u;
  uint64_t v41 = &v116;
  do
  {
    uint64_t v42 = 0;
    simd_float4 v43 = &v95;
    do
    {
      uint64_t v44 = 0;
      double v45 = 0.0;
      simd_float4 v46 = (double *)v43;
      do
      {
        double v47 = *v46;
        v46 += 3;
        double v45 = v45 + *(double *)((char *)v41 + v44) * v47;
        v44 += 8;
      }
      while (v44 != 24);
      *((double *)&v100 + 3 * v40 + v42++) = v45;
      simd_float4 v43 = (long long *)((char *)v43 + 8);
    }
    while (v42 != 3);
    ++v40;
    uint64_t v41 = (long long *)((char *)v41 + 24);
  }
  while (v40 != 3);
  uint64_t v48 = 0;
  uint64_t v94 = 0;
  long long v92 = 0u;
  long long v93 = 0u;
  long long v90 = 0u;
  long long v91 = 0u;
  id v49 = &v90;
  id v50 = v115;
  do
  {
    uint64_t v51 = 0;
    id v52 = v49;
    do
    {
      *(double *)id v52 = v50[v51];
      id v52 = (long long *)((char *)v52 + 24);
      ++v51;
    }
    while (v51 != 3);
    ++v48;
    id v49 = (long long *)((char *)v49 + 8);
    v50 += 3;
  }
  while (v48 != 3);
  uint64_t v53 = 0;
  uint64_t v109 = 0;
  v54.i64[1] = 0;
  long long v107 = 0u;
  long long v108 = 0u;
  long long v105 = 0u;
  long long v106 = 0u;
  double v55 = &v100;
  do
  {
    uint64_t v56 = 0;
    double v57 = &v90;
    do
    {
      uint64_t v58 = 0;
      double v59 = 0.0;
      id v60 = (double *)v57;
      do
      {
        double v61 = *v60;
        v60 += 3;
        double v59 = v59 + *(double *)((char *)v55 + v58) * v61;
        v58 += 8;
      }
      while (v58 != 24);
      *((double *)&v105 + 3 * v53 + v56++) = v59;
      double v57 = (long long *)((char *)v57 + 8);
    }
    while (v56 != 3);
    ++v53;
    double v55 = (long long *)((char *)v55 + 24);
  }
  while (v53 != 3);
  uint64_t v62 = 0;
  long long v95 = 0uLL;
  *(void *)&long long v96 = 0;
  id v63 = (uint64_t *)v117;
  do
  {
    uint64_t v64 = *v63;
    v63 += 3;
    *(void *)((char *)&v95 + v62) = v64;
    v62 += 8;
  }
  while (v62 != 24);
  v54.i64[0] = v110[0];
  if ((((unint64_t)v111 ^ v110[0]) & 0x8000000000000000) != 0 || (v113 ^ v110[0]) < 0)
  {
    uint64_t v68 = 0;
    v54.i64[0] = v105;
    v14.i64[0] = 1.0;
    v69.f64[0] = NAN;
    v69.f64[1] = NAN;
    long long v100 = 0u;
    long long v101 = 0u;
    v54.i64[0] = vbslq_s8((int8x16_t)vnegq_f64(v69), v14, v54).u64[0];
    long long v102 = 0u;
    long long v103 = 0u;
    uint64_t v104 = 0;
    do
    {
      *(double *)((char *)&v100 + v68) = *(double *)v54.i64 * *(double *)((char *)&v105 + v68);
      v68 += 8;
    }
    while (v68 != 72);
  }
  else
  {
    uint64_t v65 = 0;
    v14.i64[0] = 1.0;
    v66.f64[0] = NAN;
    v66.f64[1] = NAN;
    uint64_t v104 = 0;
    long long v102 = 0u;
    long long v103 = 0u;
    *(void *)&double v67 = vbslq_s8((int8x16_t)vnegq_f64(v66), v14, v54).u64[0];
    long long v100 = 0u;
    long long v101 = 0u;
    do
    {
      *(double *)((char *)&v100 + v65 * 8) = v67 * *(double *)&v110[v65];
      ++v65;
    }
    while (v65 != 9);
  }
  long long v70 = v103;
  *(_OWORD *)(a8 + 32) = v102;
  *(_OWORD *)(a8 + 48) = v70;
  *(void *)(a8 + 64) = v104;
  long long v71 = v101;
  *(_OWORD *)a8 = v100;
  *(_OWORD *)(a8 + 16) = v71;
  uint64_t v72 = 0;
  long long v90 = 0uLL;
  *(void *)&long long v91 = 0;
  do
  {
    *(double *)((char *)&v90 + v72) = *(double *)(a3 + v72) - *(double *)(a2 + v72);
    v72 += 8;
  }
  while (v72 != 24);
  uint64_t v73 = 0;
  uint64_t v87 = 0;
  uint64_t v88 = 0;
  uint64_t v89 = 0;
  do
  {
    *(double *)((char *)&v87 + v73) = *(double *)(a3 + v73) - *(double *)(a2 + v73);
    v73 += 8;
  }
  while (v73 != 24);
  uint64_t v74 = 0;
  double v75 = 0.0;
  do
  {
    double v75 = v75 + *(double *)((char *)&v87 + v74) * *(double *)((char *)&v87 + v74);
    v74 += 8;
  }
  while (v74 != 24);
  uint64_t v76 = 0;
  long long v100 = 0uLL;
  *(void *)&long long v101 = 0;
  double v77 = sqrt(v75);
  do
  {
    *(double *)((char *)&v100 + v76) = *(double *)((char *)&v90 + v76) / v77;
    v76 += 8;
  }
  while (v76 != 24);
  uint64_t v78 = 0;
  double v79 = 0.0;
  do
  {
    double v79 = v79 + *(double *)((char *)&v100 + v78) * *(double *)((char *)&v95 + v78);
    v78 += 8;
  }
  while (v78 != 24);
  if (v79 < 0.0)
  {
    uint64_t v80 = 0;
    long long v90 = 0uLL;
    *(void *)&long long v91 = 0;
    do
    {
      *(double *)((char *)&v90 + v80) = -*(double *)((char *)&v95 + v80);
      v80 += 8;
    }
    while (v80 != 24);
    long long v95 = v90;
    *(void *)&long long v96 = v91;
  }
  uint64_t v81 = 0;
  uint64_t v87 = 0;
  uint64_t v88 = 0;
  uint64_t v89 = 0;
  do
  {
    *(double *)((char *)&v87 + v81) = *(double *)(a3 + v81) - *(double *)(a2 + v81);
    v81 += 8;
  }
  while (v81 != 24);
  uint64_t v82 = 0;
  double v83 = 0.0;
  do
  {
    double v83 = v83 + *(double *)((char *)&v87 + v82) * *(double *)((char *)&v87 + v82);
    v82 += 8;
  }
  while (v82 != 24);
  uint64_t v84 = 0;
  long long v90 = 0uLL;
  *(void *)&long long v91 = 0;
  double v85 = sqrt(v83);
  do
  {
    *(double *)((char *)&v90 + v84) = v85 * *(double *)((char *)&v95 + v84);
    v84 += 8;
  }
  while (v84 != 24);
  *(_OWORD *)a9 = v90;
  *(void *)(a9 + 16) = v91;
  return 0;
}

float32x2_t sub_100030B34(float64x2_t *a1)
{
  float64x2_t v1 = *a1;
  v1.f64[1] = a1[1].f64[1];
  return vcvt_f32_f64(v1);
}

double sub_100030B9C(float64x2_t *a1, float64x2_t *a2, int8x16_t a3, int8x16_t a4, __n128 a5, __n128 a6)
{
  a1->f64[0] = *(float *)a3.i32;
  a1->f64[1] = *(float *)a4.i32;
  float64x2_t v6 = vcvtq_f64_f32((float32x2_t)vzip1_s32((int32x2_t)*(_OWORD *)&vextq_s8(a3, a3, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8(a4, a4, 8uLL)));
  float32x2_t v7 = (float32x2_t)vzip2_s32(*(int32x2_t *)a4.i8, (int32x2_t)a5.n128_u64[0]);
  a5.n128_u32[1] = a3.u32[1];
  a1[1] = vcvtq_f64_f32((float32x2_t)a5.n128_u64[0]);
  a1[2] = vcvtq_f64_f32(v7);
  a1[3] = v6;
  a1[4].f64[0] = a5.n128_f32[2];
  *a2 = vcvtq_f64_f32((float32x2_t)a6.n128_u64[0]);
  double result = a6.n128_f32[2];
  a2[1].f64[0] = a6.n128_f32[2];
  return result;
}

uint64_t sub_100030BF4(uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = result;
  int v6 = *(_DWORD *)(result + 16);
  int v7 = *(_DWORD *)(result + 20);
  if (v6 == 1 && v7 == 1)
  {
    sub_100030D88(a2, *(double **)(result + 8), (uint64_t)&v26);
    sub_100004500(a3, v28, v29);
LABEL_15:
    memcpy(*(void **)(a3 + 8), __src, 8 * *(unsigned int *)(a3 + 16) * (unint64_t)*(unsigned int *)(a3 + 20));
    double result = sub_100003224((uint64_t)&v26);
    goto LABEL_16;
  }
  int v10 = *(_DWORD *)(a2 + 16);
  int v9 = *(_DWORD *)(a2 + 20);
  if (v9 == 1 && v10 == 1)
  {
    sub_100030D88(result, *(double **)(a2 + 8), (uint64_t)&v26);
    sub_100004500(a3, v28, v29);
    goto LABEL_15;
  }
  if (v7 != v10) {
    sub_100075EF0();
  }
  if (v6 != *(_DWORD *)(a3 + 16) || v9 != *(_DWORD *)(a3 + 20)) {
    sub_100075EC4();
  }
LABEL_16:
  uint64_t v12 = *(unsigned int *)(v5 + 16);
  if ((int)v12 >= 1)
  {
    uint64_t v13 = 0;
    int8x16_t v14 = *(double **)(v5 + 8);
    uint64_t v15 = *(double **)(a2 + 8);
    uint64_t v16 = *(unsigned int *)(v5 + 20);
    uint64_t v17 = *(unsigned int *)(a3 + 20);
    int v18 = *(_DWORD *)(a3 + 20);
    uint64_t v19 = *(void *)(a3 + 8);
    do
    {
      if (v18 >= 1)
      {
        double result = 0;
        double v20 = v15;
        do
        {
          double v21 = 0.0;
          if ((int)v16 >= 1)
          {
            uint64_t v22 = v14;
            double v23 = v20;
            uint64_t v24 = v16;
            do
            {
              double v25 = *v22++;
              double v21 = v21 + v25 * *v23;
              v23 += (int)v17;
              --v24;
            }
            while (v24);
          }
          *(double *)(v19 + 8 * v13 * (int)v17 + 8 * result++) = v21;
          ++v20;
        }
        while (result != v17);
      }
      ++v13;
      v14 += (int)v16;
    }
    while (v13 != v12);
  }
  return result;
}

void sub_100030D70(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

double sub_100030D88@<D0>(uint64_t a1@<X0>, double *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v5 = sub_1000032CC(a3, *(_DWORD *)(a1 + 16), *(_DWORD *)(a1 + 20));
  int v7 = *(_DWORD *)(a1 + 20) * *(_DWORD *)(a1 + 16);
  if (v7 >= 1)
  {
    int32x4_t v8 = *(double **)(a1 + 8);
    int v9 = &v8[v7];
    int v10 = *(double **)(v5 + 8);
    do
    {
      double v11 = *v8++;
      double result = v11 * *a2;
      *v10++ = result;
    }
    while (v8 < v9);
  }
  return result;
}

uint64_t sub_1000310A8(uint64_t result, int a2)
{
  signed int v2 = 48271 * (a2 % 0xADC8u) - 3399 * (a2 / 0xADC8u);
  unsigned int v3 = v2 - (v2 < 1);
  if (a2 <= 3399) {
    unsigned int v3 = 48271 * a2;
  }
  *(unsigned char *)(result + 1012) = 0;
  for (uint64_t i = 12; i != 1012; i += 4)
  {
    signed int v5 = 48271 * (v3 % 0xADC8) - 3399 * (v3 / 0xADC8);
    unsigned int v6 = v5 - (v5 < 1);
    if ((int)v3 <= 3399) {
      v3 *= 48271;
    }
    else {
      unsigned int v3 = v6;
    }
    *(_DWORD *)(result + i) = v3;
  }
  for (uint64_t j = 12; j != 1012; j += 4)
  {
    signed int v8 = 48271 * (v3 % 0xADC8) - 3399 * (v3 / 0xADC8);
    unsigned int v9 = v8 - (v8 < 1);
    if ((int)v3 <= 3399) {
      v3 *= 48271;
    }
    else {
      unsigned int v3 = v9;
    }
    if (v3 >= 0x40000001) {
      *(_DWORD *)(result + j) |= 0x80000000;
    }
  }
  *(_DWORD *)(result + 8) = v3;
  unsigned int v10 = -1;
  unsigned int v11 = 0x80000000;
  for (uint64_t k = 24; k != 920; k += 28)
  {
    *(_DWORD *)(result + k) = *(_DWORD *)(result + k) & v10 | v11;
    v10 >>= 1;
    v11 >>= 1;
  }
  *(unsigned char *)(result + 1013) = 0;
  return result;
}

void *sub_1000311D4(void *a1, int a2)
{
  *a1 = off_1000966E8;
  sub_1000310A8((uint64_t)a1, a2);
  return a1;
}

void sub_10003121C()
{
}

float sub_100031230(uint64_t a1)
{
  unsigned int v1 = *(unsigned __int8 *)(a1 + 1012);
  if (v1 <= 0x92) {
    int v2 = 103;
  }
  else {
    int v2 = -147;
  }
  unsigned int v3 = *(_DWORD *)(a1 + 12 + 4 * (v2 + *(unsigned __int8 *)(a1 + 1012))) ^ *(_DWORD *)(a1 + 12 + 4 * *(unsigned __int8 *)(a1 + 1012));
  *(_DWORD *)(a1 + 12 + 4 * *(unsigned __int8 *)(a1 + 1012)) = v3;
  if (v1 <= 0xF8) {
    char v4 = v1 + 1;
  }
  else {
    char v4 = 0;
  }
  *(unsigned char *)(a1 + 1012) = v4;
  return (float)v3 * 2.3283e-10;
}

void sub_10003127C(int a1, uint64_t a2, IOHIDServiceClientRef service)
{
  int valuePtr = 0;
  if (service)
  {
    CFNumberRef v4 = (const __CFNumber *)IOHIDServiceClientCopyProperty(service, @"Placement");
    CFNumberGetValue(v4, kCFNumberSInt32Type, &valuePtr);
    if (IOHIDEventGetType() == 12 && valuePtr == 2)
    {
      IOHIDEventGetFloatValue();
      if (a2)
      {
        if (*(unsigned char *)(a2 + 24))
        {
          uint64_t v6 = *(void *)(a2 + 8);
          if (v6)
          {
            uint64_t v7 = *(void *)(v6 + 296);
            if (v7)
            {
              float v8 = v5;
              *(float *)(v7 + 84) = v8;
              *(_DWORD *)(v7 + 104) = 1;
              *(void *)(*(void *)(v6 + 296) + 96) = mach_absolute_time();
              pthread_mutex_lock((pthread_mutex_t *)(v6 + 424));
              pthread_cond_broadcast((pthread_cond_t *)(v6 + 488));
              pthread_mutex_unlock((pthread_mutex_t *)(v6 + 424));
            }
          }
        }
      }
    }
  }
  else
  {
    os_log_t v9 = (os_log_t)off_1002BBC98;
    if (off_1002BBC98 == &_os_log_default)
    {
      os_log_t v9 = os_log_create("com.apple.isp", "photon");
      off_1002BBC98 = v9;
    }
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR)) {
      sub_100075F1C(v9, v10, v11, v12, v13, v14, v15, v16);
    }
  }
}

uint64_t sub_10003139C(uint64_t a1, uint64_t a2, uint64_t a3, CFArrayRef *a4, const void *a5)
{
  ValueAtIndex = a5;
  uint64_t v6 = a4;
  uint64_t v17 = a4;
  *(void *)a1 = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 32) = a2;
  *(void *)(a1 + 40) = a3;
  *(unsigned char *)(a1 + 56) = 0;
  *(void *)(a1 + 64) = 0;
  *(void *)(a1 + 72) = 0xBFF0000000000000;
  *(void *)(a1 + 80) = 2;
  *(void *)(a1 + 96) = a4;
  *(void *)(a1 + 104) = a5;
  *(_WORD *)(a1 + 224) = 0;
  mach_timebase_info((mach_timebase_info_t)(a1 + 48));
  int v16 = 0;
  if (!v6)
  {
    sub_100022AAC(&v17, 0, 0);
    uint64_t v6 = v17;
  }
  BOOL v9 = 1;
  if (!ValueAtIndex && v6)
  {
    if (CFArrayGetCount(*v6) < 1) {
      goto LABEL_14;
    }
    ValueAtIndex = CFArrayGetValueAtIndex(*v17, 0);
    int v10 = sub_10005680C((uint64_t)ValueAtIndex, 0, 0);
    os_log_t v11 = (os_log_t)off_1002BBC98;
    if (off_1002BBC98 == &_os_log_default)
    {
      os_log_t v11 = os_log_create("com.apple.isp", "photon");
      off_1002BBC98 = v11;
    }
    if (os_log_type_enabled(v11, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 67109120;
      int v19 = v10;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_INFO, "H16ISPDeviceOpen returned 0x%08x\n", buf, 8u);
    }
    *(unsigned char *)(a1 + 224) = 1;
    BOOL v9 = v10 == 0;
  }
  if (ValueAtIndex && v9) {
    sub_100056544((uint64_t)ValueAtIndex, &v16);
  }
LABEL_14:
  uint64_t v12 = dispatch_queue_create("com.apple.video.PhotometerManager.CommandQueue", 0);
  *(void *)(a1 + 16) = v12;
  v14[0] = _NSConcreteStackBlock;
  v14[1] = 3221225472;
  v14[2] = sub_1000315AC;
  v14[3] = &unk_100096708;
  int v15 = v16;
  void v14[4] = a1;
  v14[5] = a3;
  dispatch_async(v12, v14);
  return a1;
}

void sub_1000315AC(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  unsigned int v3 = sub_100016F48(*(_DWORD *)(a1 + 48));
  *(void *)(v2 + 8) = v3;
  if (v3)
  {
    uint64_t v4 = *(void *)(*(void *)(a1 + 40) + 592);
    *((void *)v3 + 68) = v4;
    if (v4)
    {
      sub_100015458(v4, v3 + 552, v3 + 684);
      unsigned int v3 = *(char **)(v2 + 8);
    }
    sub_100017488((uint64_t)v3, v2, (uint64_t)sub_100031710);
    bzero((void *)(v2 + 112), 0x68uLL);
    sub_100017248(*(void *)(v2 + 8));
    if (*(void *)(*(void *)(v2 + 8) + 16))
    {
      if (*(_DWORD *)(a1 + 48) == 9) {
        sub_10003179C((uint64_t *)v2);
      }
      *(_DWORD *)(v2 + 88) = 1065353216;
      sub_10001739C(*(void *)(v2 + 8), *(float *)(v2 + 88));
      *(unsigned char *)(v2 + 24) = 1;
    }
    else
    {
      os_log_t v13 = (os_log_t)off_1002BBC98;
      if (off_1002BBC98 == &_os_log_default)
      {
        os_log_t v13 = os_log_create("com.apple.isp", "photon");
        off_1002BBC98 = v13;
      }
      if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR)) {
        sub_10007600C(v13, v14, v15, v16, v17, v18, v19, v20);
      }
    }
  }
  else
  {
    os_log_t v5 = (os_log_t)off_1002BBC98;
    if (off_1002BBC98 == &_os_log_default)
    {
      os_log_t v5 = os_log_create("com.apple.isp", "photon");
      off_1002BBC98 = v5;
    }
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR)) {
      sub_100075F94(v5, v6, v7, v8, v9, v10, v11, v12);
    }
  }
}

uint64_t sub_100031710(uint64_t a1, uint64_t a2, void *a3)
{
  if (a2)
  {
    unsigned int v3 = *(NSObject **)(a2 + 16);
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472;
    block[2] = sub_100031D84;
    block[3] = &unk_100096748;
    block[4] = a2;
    void block[5] = a3;
    block[6] = a1;
    dispatch_async(v3, block);
  }
  else
  {
    free(a3);
  }
  return 0;
}

void sub_10003179C(uint64_t *a1)
{
  uint64_t v2 = IOHIDEventSystemClientCreateWithType();
  *a1 = v2;
  if (v2)
  {
    int v68 = 4;
    int valuePtr = 65280;
    CFNumberRef v3 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt32Type, &valuePtr);
    CFNumberRef v4 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt32Type, &v68);
    if (v4) {
      BOOL v5 = v3 == 0;
    }
    else {
      BOOL v5 = 1;
    }
    if (v5)
    {
      os_log_t v6 = (os_log_t)off_1002BBC98;
      if (off_1002BBC98 == &_os_log_default)
      {
        os_log_t v6 = os_log_create("com.apple.isp", "photon");
        off_1002BBC98 = v6;
      }
      if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR)) {
        sub_1000762DC(v6, v7, v8, v9, v10, v11, v12, v13);
      }
    }
    else
    {
      CFNumberRef v22 = v4;
      *(_OWORD *)keys = *(_OWORD *)off_1000967D0;
      values[0] = v3;
      values[1] = v4;
      CFDictionaryRef v23 = CFDictionaryCreate(kCFAllocatorDefault, (const void **)keys, (const void **)values, 2, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
      if (v23)
      {
        CFDictionaryRef v24 = v23;
        int v66 = 65;
        int v67 = 32;
        int v65 = 2;
        CFNumberRef v25 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt32Type, &v67);
        CFNumberRef v26 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt32Type, &v66);
        CFNumberRef v27 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt32Type, &v65);
        if (v25 && v26 && (CFNumberRef v28 = v27) != 0)
        {
          *(_OWORD *)long long v71 = *(_OWORD *)off_1000967E0;
          CFStringRef v72 = @"Placement";
          v70[0] = v25;
          v70[1] = v26;
          void v70[2] = v27;
          CFDictionaryRef v29 = CFDictionaryCreate(kCFAllocatorDefault, (const void **)v71, (const void **)v70, 3, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
          if (v29)
          {
            CFDictionaryRef v30 = v29;
            CFMutableDictionaryRef Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 2, &kCFTypeArrayCallBacks);
            if (Mutable)
            {
              double v32 = Mutable;
              CFArrayAppendValue(Mutable, v30);
              CFArrayAppendValue(v32, v24);
              IOHIDEventSystemClientSetMatchingMultiple();
              IOHIDEventSystemClientRegisterEventCallback();
              IOHIDEventSystemClientSetCancelHandler();
              IOHIDEventSystemClientSetDispatchQueue();
              IOHIDEventSystemClientActivate();
              CFRelease(v24);
              CFRelease(v30);
              CFRelease(v3);
              CFRelease(v25);
              CFRelease(v22);
              CFRelease(v26);
              CFRelease(v28);
              CFRelease(v32);
            }
            else
            {
              os_log_t v57 = (os_log_t)off_1002BBC98;
              if (off_1002BBC98 == &_os_log_default)
              {
                os_log_t v57 = os_log_create("com.apple.isp", "photon");
                off_1002BBC98 = v57;
              }
              if (os_log_type_enabled(v57, OS_LOG_TYPE_ERROR)) {
                sub_1000761EC(v57, v58, v59, v60, v61, v62, v63, v64);
              }
            }
          }
          else
          {
            os_log_t v49 = (os_log_t)off_1002BBC98;
            if (off_1002BBC98 == &_os_log_default)
            {
              os_log_t v49 = os_log_create("com.apple.isp", "photon");
              off_1002BBC98 = v49;
            }
            if (os_log_type_enabled(v49, OS_LOG_TYPE_ERROR)) {
              sub_100076174(v49, v50, v51, v52, v53, v54, v55, v56);
            }
          }
        }
        else
        {
          os_log_t v41 = (os_log_t)off_1002BBC98;
          if (off_1002BBC98 == &_os_log_default)
          {
            os_log_t v41 = os_log_create("com.apple.isp", "photon");
            off_1002BBC98 = v41;
          }
          if (os_log_type_enabled(v41, OS_LOG_TYPE_ERROR)) {
            sub_100076264(v41, v42, v43, v44, v45, v46, v47, v48);
          }
        }
      }
      else
      {
        os_log_t v33 = (os_log_t)off_1002BBC98;
        if (off_1002BBC98 == &_os_log_default)
        {
          os_log_t v33 = os_log_create("com.apple.isp", "photon");
          off_1002BBC98 = v33;
        }
        if (os_log_type_enabled(v33, OS_LOG_TYPE_ERROR)) {
          sub_1000760FC(v33, v34, v35, v36, v37, v38, v39, v40);
        }
      }
    }
  }
  else
  {
    os_log_t v14 = (os_log_t)off_1002BBC98;
    if (off_1002BBC98 == &_os_log_default)
    {
      os_log_t v14 = os_log_create("com.apple.isp", "photon");
      off_1002BBC98 = v14;
    }
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR)) {
      sub_100076084(v14, v15, v16, v17, v18, v19, v20, v21);
    }
  }
}

uint64_t sub_100031C48(uint64_t a1)
{
  uint64_t v2 = *(NSObject **)(a1 + 16);
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_100031D0C;
  block[3] = &unk_100096678;
  block[4] = a1;
  dispatch_sync(v2, block);
  dispatch_sync(*(dispatch_queue_t *)(a1 + 16), &stru_100096728);
  dispatch_release(*(dispatch_object_t *)(a1 + 16));
  *(void *)(a1 + 16) = 0;
  if (*(unsigned char *)(a1 + 224))
  {
    uint64_t v3 = *(void *)(a1 + 104);
    if (v3)
    {
      sub_10004ECE0(v3);
      *(void *)(a1 + 104) = 0;
    }
    uint64_t v4 = *(void *)(a1 + 96);
    if (v4) {
      sub_100022C80(v4);
    }
  }
  return a1;
}

uint64_t sub_100031D0C(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  *(unsigned char *)(v1 + 24) = 0;
  sub_100017488(*(void *)(v1 + 8), 0, 0);
  *(void *)(v1 + 32) = 0;
  bzero((void *)(v1 + 112), 0x68uLL);
  *(_DWORD *)(v1 + 88) = 1065353216;
  if (*(void *)v1) {
    IOHIDEventSystemClientCancel();
  }
  uint64_t result = *(void *)(v1 + 8);
  if (result)
  {
    sub_1000172F0(result);
    uint64_t result = sub_100017100(*(void *)(v1 + 8));
    *(void *)(v1 + 8) = 0;
  }
  return result;
}

void sub_100031D84(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (!*(unsigned char *)(v2 + 24)) {
    goto LABEL_36;
  }
  uint64_t v3 = *(int ***)(a1 + 48);
  if (v3 && *v3)
  {
    int v4 = **v3;
    if (v4 == 10 || v4 == 6)
    {
      unsigned int v6 = *(_DWORD *)(v2 + 208);
      uint64_t v7 = v3[37];
      uint64_t v8 = (void *)(v2 + 112 + 24 * v6);
      void *v8 = *(void *)(v7 + 21);
      v8[1] = *((void *)v7 + 12);
      char v9 = *(unsigned char *)(v2 + 56);
      if (v9) {
        char v10 = 1;
      }
      else {
        char v10 = *(unsigned char *)(v2 + 225);
      }
      *(unsigned char *)(v2 + 112 + 24 * v6 + 16) = v10 | (4 * *((unsigned char *)v7 + 112));
      *(unsigned char *)(v2 + 225) = v9;
      int v11 = ((_BYTE)v6 + 1) & 3;
      if (v11) {
        BOOL v12 = 0;
      }
      else {
        BOOL v12 = *(unsigned char *)(v2 + 212) == 0;
      }
      if (v12) {
        *(unsigned char *)(v2 + 212) = 1;
      }
      *(_DWORD *)(v2 + 208) = v11;
    }
  }
  uint64_t v13 = mach_absolute_time();
  if (*(unsigned char *)(v2 + 56)
    || (HIDWORD(v15) = 1041313291,
        LODWORD(v15) = *(_DWORD *)(v2 + 48),
        LODWORD(v14) = *(_DWORD *)(v2 + 52),
        (double)(v13 - *(void *)(v2 + 64)) * 0.000000001 * (double)v15 / (double)v14 < 1.5))
  {
LABEL_36:
    CFNumberRef v25 = *(void **)(a1 + 40);
    if (v25)
    {
      free(v25);
    }
  }
  else
  {
    if (*(float *)(v2 + 88) != 1.0)
    {
      *(_DWORD *)(v2 + 88) = 1065353216;
      sub_10001739C(*(void *)(v2 + 8), *(float *)(v2 + 88));
    }
    uint64_t v16 = *(void *)(a1 + 40);
    if (v16)
    {
      uint64_t v17 = *(void *)(a1 + 48);
      if (v17)
      {
        uint64_t v18 = *(void *)(v17 + 296);
        if (v18)
        {
          *(_DWORD *)(v16 + 84) = *(_DWORD *)(v18 + 84);
          *(_DWORD *)(v16 + 104) = *(_DWORD *)(v18 + 104);
          uint64_t v19 = *(void (**)(void, void))(v2 + 32);
          if (v19) {
            v19(0, *(void *)(v2 + 40));
          }
          uint64_t v20 = *(void *)(v2 + 104);
          if (v20)
          {
            if (sub_10004C600(v20))
            {
              uint64_t v21 = *(void *)(v2 + 104);
              memcpy(v26, *(const void **)(a1 + 40), sizeof(v26));
              if (!sub_10004D8D4(v21, (uint64_t)v26))
              {
                uint64_t v22 = *(void *)(a1 + 40);
                *(void *)(v2 + 72) = *(void *)(v22 + 8);
                *(_DWORD *)(v2 + 80) = *(_DWORD *)(v22 + 4);
                os_log_t v23 = (os_log_t)off_1002BBC98;
                if (off_1002BBC98 == &_os_log_default)
                {
                  os_log_t v23 = os_log_create("com.apple.isp", "photon");
                  off_1002BBC98 = v23;
                }
                if (os_log_type_enabled(v23, OS_LOG_TYPE_INFO))
                {
                  uint64_t v24 = *(void *)(*(void *)(a1 + 40) + 8);
                  *(_DWORD *)buf = 134218240;
                  uint64_t v28 = v24;
                  __int16 v29 = 1024;
                  int v30 = 0;
                  _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_INFO, "SetFlickerFrequency: %6.2f Hz, deviceStatus 0x%08x \n", buf, 0x12u);
                }
              }
            }
          }
        }
      }
    }
    free(*(void **)(a1 + 40));
  }
}

uint64_t sub_10003204C(uint64_t a1, int a2)
{
  uint64_t v2 = 3758097097;
  switch(a2)
  {
    case 0:
      uint64_t v3 = *(NSObject **)(a1 + 16);
      v13[0] = _NSConcreteStackBlock;
      v13[1] = 3221225472;
      v13[2] = sub_1000322D0;
      v13[3] = &unk_100096678;
      v13[4] = a1;
      int v4 = v13;
      goto LABEL_7;
    case 1:
      uint64_t v3 = *(NSObject **)(a1 + 16);
      v12[0] = _NSConcreteStackBlock;
      v12[1] = 3221225472;
      _DWORD v12[2] = sub_10003232C;
      _OWORD v12[3] = &unk_100096678;
      void v12[4] = a1;
      int v4 = v12;
      goto LABEL_7;
    case 2:
      uint64_t v3 = *(NSObject **)(a1 + 16);
      v11[0] = _NSConcreteStackBlock;
      v11[1] = 3221225472;
      v11[2] = sub_100032388;
      void v11[3] = &unk_100096678;
      v11[4] = a1;
      int v4 = v11;
      goto LABEL_7;
    case 3:
      uint64_t v3 = *(NSObject **)(a1 + 16);
      block[0] = _NSConcreteStackBlock;
      block[1] = 3221225472;
      block[2] = sub_100032398;
      block[3] = &unk_100096678;
      block[4] = a1;
      int v4 = block;
LABEL_7:
      dispatch_async(v3, v4);
      return 0;
    case 4:
      BOOL v5 = *(NSObject **)(a1 + 16);
      v9[0] = _NSConcreteStackBlock;
      v9[1] = 3221225472;
      v9[2] = sub_1000323A8;
      v9[3] = &unk_100096678;
      void v9[4] = a1;
      unsigned int v6 = v9;
      goto LABEL_10;
    case 5:
      BOOL v5 = *(NSObject **)(a1 + 16);
      v8[0] = _NSConcreteStackBlock;
      v8[1] = 3221225472;
      v8[2] = sub_1000323FC;
      v8[3] = &unk_100096678;
      v8[4] = a1;
      unsigned int v6 = v8;
LABEL_10:
      dispatch_async(v5, v6);
      break;
    default:
      uint64_t v2 = 3758097090;
      break;
  }
  return v2;
}

uint64_t sub_1000322D0(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  *(unsigned char *)(v1 + 56) = 1;
  *(void *)(v1 + 64) = mach_absolute_time();
  *(unsigned char *)(v1 + 225) = 1;
  uint64_t v2 = *(void *)(v1 + 104);
  if (v2) {
    sub_100056CC4(v2, 1uLL);
  }
  uint64_t v3 = *(void *)(v1 + 8);
  float v4 = *(float *)(v1 + 88);

  return sub_10001739C(v3, v4);
}

uint64_t sub_10003232C(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 32);
  if (*(unsigned char *)(v1 + 56))
  {
    *(unsigned char *)(v1 + 56) = 0;
    *(void *)(v1 + 64) = mach_absolute_time();
    uint64_t result = *(void *)(v1 + 104);
    if (result)
    {
      return sub_100056CC4(result, 0);
    }
  }
  return result;
}

uint64_t sub_100032388(uint64_t a1)
{
  return sub_1000174A8(*(void *)(*(void *)(a1 + 32) + 8), 1);
}

uint64_t sub_100032398(uint64_t a1)
{
  return sub_1000174A8(*(void *)(*(void *)(a1 + 32) + 8), 0);
}

uint64_t sub_1000323A8(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  sub_1000174CC(*(void *)(v1 + 8), 1);
  uint64_t result = *(void *)(v1 + 104);
  if (result)
  {
    return sub_100056D3C(result, 1uLL);
  }
  return result;
}

uint64_t sub_1000323FC(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  sub_1000174CC(*(void *)(v1 + 8), 0);
  uint64_t result = *(void *)(v1 + 104);
  if (result)
  {
    return sub_100056D3C(result, 0);
  }
  return result;
}

uint64_t sub_100032450(uint64_t a1, float a2)
{
  uint64_t v2 = *(NSObject **)(a1 + 16);
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 3221225472;
  int v4[2] = sub_1000324CC;
  void v4[3] = &unk_100096768;
  _OWORD v4[4] = a1;
  float v5 = a2;
  dispatch_async(v2, v4);
  return 0;
}

float sub_1000324CC(uint64_t a1)
{
  uint64_t v1 = *(void *)(*(void *)(a1 + 32) + 8);
  if (v1)
  {
    float result = *(float *)(a1 + 40);
    *(float *)(v1 + 408) = result;
  }
  return result;
}

uint64_t sub_1000324E4(uint64_t a1, uint64_t a2)
{
  uint64_t v10 = 0;
  v11[0] = &v10;
  v11[1] = 0x2020000000;
  int v12 = 0;
  os_log_t v4 = (os_log_t)off_1002BBC98;
  if (off_1002BBC98 == &_os_log_default)
  {
    os_log_t v4 = os_log_create("com.apple.isp", "photon");
    off_1002BBC98 = v4;
  }
  if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR)) {
    sub_1000763F4();
  }
  float v5 = *(NSObject **)(a1 + 16);
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_100032644;
  block[3] = &unk_100096790;
  block[4] = &v10;
  void block[5] = a1;
  block[6] = a2;
  dispatch_sync(v5, block);
  os_log_t v6 = (os_log_t)off_1002BBC98;
  if (off_1002BBC98 == &_os_log_default)
  {
    os_log_t v6 = os_log_create("com.apple.isp", "photon");
    off_1002BBC98 = v6;
  }
  if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR)) {
    sub_100076354((uint64_t)v11, v6);
  }
  uint64_t v7 = *(unsigned int *)(v11[0] + 24);
  _Block_object_dispose(&v10, 8);
  return v7;
}

uint64_t sub_100032644(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 40);
  if (*(void *)(v1 + 8))
  {
    uint64_t v2 = result;
    bzero(&v13, 0x10uLL);
    v13.tv_nsec = 175000000;
    os_log_t v3 = (os_log_t)off_1002BBC98;
    if (off_1002BBC98 == &_os_log_default)
    {
      os_log_t v3 = os_log_create("com.apple.isp", "photon");
      off_1002BBC98 = v3;
    }
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR)) {
      sub_100076478();
    }
    pthread_mutex_lock((pthread_mutex_t *)(*(void *)(v1 + 8) + 424));
    *(_DWORD *)(*(void *)(*(void *)(v2 + 32) + 8) + 24) = pthread_cond_timedwait_relative_np((pthread_cond_t *)(*(void *)(v1 + 8) + 488), (pthread_mutex_t *)(*(void *)(v1 + 8) + 424), &v13);
    uint64_t v4 = *(void *)(v2 + 32);
    if (*(_DWORD *)(*(void *)(v4 + 8) + 24))
    {
      os_log_t v5 = (os_log_t)off_1002BBC98;
      if (off_1002BBC98 == &_os_log_default)
      {
        os_log_t v5 = os_log_create("com.apple.isp", "photon");
        off_1002BBC98 = v5;
        uint64_t v4 = *(void *)(v2 + 32);
      }
      if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
      {
        int v12 = *(_DWORD *)(*(void *)(v4 + 8) + 24);
        *(_DWORD *)buf = 136315394;
        unint64_t v15 = "GetLuxInfo_block_invoke";
        __int16 v16 = 1024;
        int v17 = v12;
        _os_log_error_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "%s - timed wait on a condition returned %d\n", buf, 0x12u);
        uint64_t v4 = *(void *)(v2 + 32);
      }
      *(_DWORD *)(*(void *)(v4 + 8) + 24) = -536870186;
      uint64_t v6 = *(void *)(v1 + 8);
    }
    else
    {
      uint64_t v6 = *(void *)(v1 + 8);
      if (v6 && (uint64_t v7 = *(void *)(v6 + 296)) != 0)
      {
        uint64_t v8 = *(void *)(v2 + 48);
        *(void *)(v8 + 8) = *(void *)(v7 + 96);
        *(void *)uint64_t v8 = *(void *)(v7 + 84);
        char v9 = *(unsigned char *)(v1 + 56);
        if (v9) {
          char v10 = 1;
        }
        else {
          char v10 = *(unsigned char *)(v1 + 225);
        }
        *(unsigned char *)(v8 + 16) = v10 | (2 * *(unsigned char *)(*(void *)(v6 + 416) + 1)) | (4 * *(unsigned char *)(v7 + 112));
        *(unsigned char *)(v1 + 225) = v9;
      }
      else
      {
        uint64_t v11 = *(void *)(v2 + 48);
        *(void *)uint64_t v11 = 0;
        *(void *)(v11 + 8) = 0;
        *(unsigned char *)(v11 + 16) = 0;
        *(_DWORD *)(*(void *)(*(void *)(v2 + 32) + 8) + 24) = -536870212;
      }
    }
    return pthread_mutex_unlock((pthread_mutex_t *)(v6 + 424));
  }
  return result;
}

uint64_t sub_100032888(uint64_t a1, uint64_t a2)
{
  uint64_t v6 = 0;
  uint64_t v7 = &v6;
  uint64_t v8 = 0x2020000000;
  int v9 = -536870212;
  uint64_t v2 = *(NSObject **)(a1 + 16);
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_100032940;
  block[3] = &unk_100096790;
  void block[5] = a1;
  block[6] = a2;
  block[4] = &v6;
  dispatch_sync(v2, block);
  uint64_t v3 = *((unsigned int *)v7 + 6);
  _Block_object_dispose(&v6, 8);
  return v3;
}

double sub_100032940(uint64_t a1, double a2)
{
  LOWORD(a2) = *(_WORD *)(*(void *)(*(void *)(a1 + 40) + 8) + 564);
  double result = (double)*(unint64_t *)&a2 * 0.0000305175781;
  **(double **)(a1 + 48) = result;
  *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = 0;
  return result;
}

uint64_t sub_100032970(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(NSObject **)(a1 + 16);
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 3221225472;
  int v4[2] = sub_1000329E8;
  void v4[3] = &unk_1000967B0;
  _OWORD v4[4] = a1;
  void v4[5] = a2;
  dispatch_sync(v2, v4);
  return 0;
}

void *sub_1000329E8(uint64_t a1)
{
  return memmove(*(void **)(a1 + 40), (const void *)(*(void *)(a1 + 32) + 112), 0x68uLL);
}

void sub_1000329F8(uint64_t a1)
{
  uint64_t v1 = *(CFTypeRef **)(a1 + 32);
  IOHIDEventSystemClientUnregisterEventCallback();
  IOHIDEventSystemClientUnscheduleFromDispatchQueue();
  CFRelease(*v1);
  CFTypeRef *v1 = 0;
}

void sub_100032A64(uint64_t a1)
{
  int v27 = 255;
  CFDictionaryRef v2 = IOServiceNameMatching("AppleH16CamIn");
  io_service_t MatchingService = IOServiceGetMatchingService(kIOMainPortDefault, v2);
  uint64_t v26 = 0;
  id v4 = [[+[MSUDataAccessor sharedDataAccessor](MSUDataAccessor, "sharedDataAccessor") copyPathForPersonalizedData:0 error:&v26];
  os_log_t v5 = v4;
  if (a1)
  {
    if (!v4)
    {
      NSLog(@"Personalized firmware root path accessor not found");
      return;
    }
    if (sub_10005648C(a1, &v27))
    {
      uint64_t v6 = +[NSData dataWithContentsOfFile:@"/private/var/tmp/usr/standalone/firmware/Savage/SavagePatch.DAT"];
      if (v6)
      {
        uint64_t v21 = v6;
        NSLog(@"Found Savage override DAT file, which takes precedence over all others - %@", @"/private/var/tmp/usr/standalone/firmware/Savage/SavagePatch.DAT");
        int v9 = 0;
        CFTypeRef v7 = 0;
        uint64_t v22 = 3722248192;
      }
      else
      {
        CFTypeRef v7 = IORegistryEntrySearchCFProperty(MatchingService, "IOService", @"SavageDeviceRev", kCFAllocatorDefault, 0);
        CFTypeRef v8 = IORegistryEntrySearchCFProperty(MatchingService, "IOService", @"SavageMNS", kCFAllocatorDefault, 0);
        int v9 = v8;
        if (v7) {
          BOOL v10 = v8 == 0;
        }
        else {
          BOOL v10 = 1;
        }
        if (v10)
        {
          NSLog(@"IR sensor not detected");
          uint64_t v24 = 0;
          id v23 = 0;
          uint64_t v22 = 3149594624;
          goto LABEL_22;
        }
        CFTypeID v11 = CFGetTypeID(v7);
        if (v11 != CFDataGetTypeID() || (CFTypeID v12 = CFGetTypeID(v9), v12 != CFDataGetTypeID()))
        {
          uint64_t v24 = 0;
          goto LABEL_24;
        }
        BytePtr = CFDataGetBytePtr((CFDataRef)v7);
        unint64_t v14 = "B3";
        if (BytePtr && (*BytePtr & 0xF0) == 0xA0) {
          unint64_t v14 = "BA";
        }
        unint64_t v15 = CFDataGetBytePtr((CFDataRef)v9);
        __int16 v16 = "Dev";
        if (v15 && *v15 == 10) {
          __int16 v16 = "Prod";
        }
        snprintf(__str, 0x400uLL, "Savage/SavagePatch%s%s.DAT", v14, v16);
        id v17 = [[v5 stringByAppendingPathComponent:+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", __str)];
        NSLog(@"DAT file for unprovisioned Savage - %@", v17);
        id v18 = [v5 stringByAppendingPathComponent:@"/Savage/SavagePatch.DAT"];
        NSLog(@"DAT file for provisioned Savage - %@", v18);
        uint64_t v19 = +[NSData dataWithContentsOfFile:v17];
        if (v19)
        {
          uint64_t v21 = v19;
          uint64_t v22 = 2863267840;
          NSLog(@"Loading DAT file for unprovisioned Savage");
        }
        else
        {
          uint64_t v20 = +[NSData dataWithContentsOfFile:v18];
          if (!v20)
          {
            NSLog(@"No DAT file for Savage found");
            uint64_t v24 = 0;
            id v23 = 0;
            uint64_t v22 = 3435921408;
            goto LABEL_22;
          }
          uint64_t v21 = v20;
          uint64_t v22 = 2863267840;
        }
      }
      id v23 = [(NSData *)v21 length];
      uint64_t v24 = malloc_type_calloc((size_t)v23, 1uLL, 0xD78BBC9FuLL);
      if (!v24) {
        goto LABEL_23;
      }
      [(NSData *)v21 getBytes:v24 length:v23];
    }
    else
    {
      uint64_t v24 = 0;
      id v23 = 0;
      int v9 = 0;
      CFTypeRef v7 = 0;
      uint64_t v22 = 4008574976;
    }
LABEL_22:
    uint64_t v25 = sub_1000558E0(a1, v27 | 0x80000000, (uint64_t)v24, v23, v22 | 5);
    NSLog(@"Load Savage DAT File: Size = %ld; SendStatus = %08x, FileStatus = 0x%08X", v23, v25, v22);
LABEL_23:
    if (!v9)
    {
LABEL_25:
      if (v7) {
        CFRelease(v7);
      }
      CFRelease(v5);
      if (v24) {
        free(v24);
      }
      return;
    }
LABEL_24:
    CFRelease(v9);
    goto LABEL_25;
  }
  NSLog(@"pDevice is NULL");
  if (v5) {
    CFRelease(v5);
  }
}

void sub_100032E28(uint64_t a1)
{
  int v31 = 255;
  CFDictionaryRef v2 = IOServiceNameMatching("AppleH16CamIn");
  io_service_t MatchingService = IOServiceGetMatchingService(kIOMainPortDefault, v2);
  uint64_t v30 = 0;
  id v4 = [[+[MSUDataAccessor sharedDataAccessor](MSUDataAccessor, "sharedDataAccessor") copyPathForPersonalizedData:0 error:&v30];
  os_log_t v5 = +[NSData dataWithContentsOfFile:@"/private/var/tmp/usr/standalone/firmware/Yonkers/YonkersPatch.DAT"];
  if (!a1)
  {
    NSLog(@"pDevice is NULL");
    if (!v4) {
      return;
    }
LABEL_40:
    CFRelease(v4);
    return;
  }
  if (!v4)
  {
    NSLog(@"Personalized firmware root path accessor not found");
    return;
  }
  uint64_t v6 = v5;
  if (!sub_100056430(a1, &v31)) {
    goto LABEL_40;
  }
  if (v6)
  {
    NSLog(@"Found Yonkers override DAT file, which takes precedence over all others - %@", @"/private/var/tmp/usr/standalone/firmware/Yonkers/YonkersPatch.DAT");
    CFDataRef v9 = 0;
    CFTypeRef v7 = 0;
    uint64_t v21 = 3722248192;
  }
  else
  {
    CFTypeRef v7 = IORegistryEntrySearchCFProperty(MatchingService, "IOService", @"YonkersFabRevision", kCFAllocatorDefault, 0);
    CFDataRef v8 = (const __CFData *)IORegistryEntrySearchCFProperty(MatchingService, "IOService", @"YonkersMNS", kCFAllocatorDefault, 0);
    CFDataRef v9 = v8;
    if (v8) {
      BOOL v10 = v7 == 0;
    }
    else {
      BOOL v10 = 1;
    }
    if (v10)
    {
      NSLog(@"Secure RGB sensor not detected");
      uint64_t v28 = 0;
      id v27 = 0;
      uint64_t v21 = 3149594624;
      goto LABEL_30;
    }
    CFTypeID v11 = CFGetTypeID(v8);
    if (v11 != CFDataGetTypeID() || (CFTypeID v12 = CFGetTypeID(v7), v12 != CFDataGetTypeID()))
    {
      uint64_t v28 = 0;
      goto LABEL_32;
    }
    BytePtr = CFDataGetBytePtr((CFDataRef)v7);
    if (!BytePtr
      || ((int v14 = __rev16(*(unsigned __int16 *)BytePtr), v15 = 1, v14 > 59904)
        ? (v16 = v14 == 59905, int v17 = 61953)
        : (v16 = v14 == 54529, int v17 = 56577),
          !v16 ? (BOOL v18 = v14 == v17) : (BOOL v18 = 1),
          !v18))
    {
      int v15 = 0;
    }
    uint64_t v19 = CFDataGetBytePtr(v9);
    uint64_t v20 = "Dev";
    if (v19 && *v19 == 8) {
      uint64_t v20 = "Prod";
    }
    uint64_t v21 = 2863267840;
    uint64_t v22 = "Ymgt";
    if (!v15) {
      uint64_t v22 = "Ngsk";
    }
    snprintf(__str, 0x400uLL, "Yonkers/YonkersPatch%s%s.DAT", v22, v20);
    id v23 = [[v4 stringByAppendingPathComponent:+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", __str)];
    NSLog(@"DAT file for unprovisioned Yonkers - %@", v23);
    id v24 = [v4 stringByAppendingPathComponent:@"/Yonkers/YonkersPatch.DAT"];
    NSLog(@"DAT file for provisioned Yonkers - %@", v24);
    uint64_t v25 = +[NSData dataWithContentsOfFile:v23];
    if (v25)
    {
      uint64_t v6 = v25;
      NSLog(@"Loading DAT file for unprovisioned Yonkers");
    }
    else
    {
      uint64_t v26 = +[NSData dataWithContentsOfFile:v24];
      if (!v26)
      {
        NSLog(@"No DAT file for Yonkers found");
        uint64_t v28 = 0;
        id v27 = 0;
        uint64_t v21 = 3435921408;
        goto LABEL_30;
      }
      uint64_t v6 = v26;
    }
  }
  id v27 = [(NSData *)v6 length];
  uint64_t v28 = malloc_type_calloc((size_t)v27, 1uLL, 0x4664D063uLL);
  if (!v28) {
    goto LABEL_31;
  }
  [(NSData *)v6 getBytes:v28 length:v27];
LABEL_30:
  uint64_t v29 = sub_1000558E0(a1, v31 | 0x80000000, (uint64_t)v28, v27, v21 | 5);
  NSLog(@"Load Yonkers DAT File: Size = %ld; SendStatus = %08x, 0x%08X", v27, v29, v21);
LABEL_31:
  if (v9) {
LABEL_32:
  }
    CFRelease(v9);
  if (v7) {
    CFRelease(v7);
  }
  CFRelease(v4);
  if (v28) {
    free(v28);
  }
}

void sub_100033208(uint64_t a1)
{
  unsigned int v25 = 255;
  if (!a1) {
    return;
  }
  if (!sub_10005648C(a1, &v25)) {
    goto LABEL_42;
  }
  CFDictionaryRef v2 = IOServiceNameMatching("AppleH16CamIn");
  io_service_t MatchingService = IOServiceGetMatchingService(kIOMainPortDefault, v2);
  CFTypeRef v4 = IORegistryEntrySearchCFProperty(MatchingService, "IOService", @"LoadHPR", kCFAllocatorDefault, 0);
  os_log_t v5 = v4;
  if (v4)
  {
    CFTypeID v6 = CFGetTypeID(v4);
    if (v6 == CFBooleanGetTypeID() && !CFBooleanGetValue((CFBooleanRef)v5))
    {
      CFRelease(v5);
      os_log_t v24 = (os_log_t)off_1002BBCA0;
      if (off_1002BBCA0 == &_os_log_default)
      {
        os_log_t v24 = os_log_create("com.apple.isp", "general");
        off_1002BBCA0 = v24;
      }
      if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR)) {
        sub_1000765A0(v24);
      }
LABEL_42:
      CFStringRef v15 = 0;
      goto LABEL_43;
    }
  }
  CFTypeRef v7 = IORegistryEntrySearchCFProperty(MatchingService, "IOService", @"SavageChipID", kCFAllocatorDefault, 3u);
  if (v7)
  {
    CFDataRef v8 = v7;
    uint64_t v9 = AMFDRCreateInstanceString();
    if (v9)
    {
      BOOL v10 = (const void *)v9;
      CFTypeRef v11 = IORegistryEntrySearchCFProperty(MatchingService, "IOService", @"SavageUID", kCFAllocatorDefault, 3u);
      if (v11)
      {
        CFTypeID v12 = v11;
        uint64_t v13 = AMFDRCreateInstanceString();
        if (v13)
        {
          int v14 = (const void *)v13;
          CFStringRef v15 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%@-%@", v10, v13);
          CFRelease(v12);
          CFRelease(v14);
          goto LABEL_11;
        }
        NSLog(@"Couldn't create SavageUID string ref");
        CFRelease(v12);
      }
      else
      {
        NSLog(@"Couldn't read SavageUID");
      }
      CFStringRef v15 = 0;
LABEL_11:
      CFRelease(v8);
      CFRelease(v10);
      if (!v5) {
        goto LABEL_13;
      }
      goto LABEL_12;
    }
    NSLog(@"Couldn't create SavageChipID string ref");
    CFRelease(v8);
  }
  else
  {
    NSLog(@"Couldn't read SavageChipID");
  }
  CFStringRef v15 = 0;
  if (v5) {
LABEL_12:
  }
    CFRelease(v5);
LABEL_13:
  if (!v15)
  {
    NSLog(@"Couldn't combine frontIR chipIDStr and uidStr");
LABEL_43:
    CFDataRef v17 = 0;
    goto LABEL_44;
  }
  BOOL v16 = +[NSData dataWithContentsOfFile:@"/usr/local/share/firmware/isp/Savage/FrontIRHPR.DER"];
  if (v16)
  {
    CFDataRef v17 = (const __CFData *)v16;
    NSLog(@"Found FrontIR override (has highest precedence) HPR file - camChannel = %d", v25);
    goto LABEL_16;
  }
  CFDataRef v17 = (const __CFData *)AMFDRSealingMapCopyLocalMinimalManifestForInstance();
  if (v17)
  {
LABEL_16:
    BytePtr = CFDataGetBytePtr(v17);
    unsigned int Length = CFDataGetLength(v17);
    int v20 = sub_1000558E0(a1, v25 | 0x80000000, (uint64_t)BytePtr, Length, 0x501u);
    CFStringRef v21 = CFCopyDescription(v17);
    os_log_t v22 = (os_log_t)off_1002BBCA0;
    if (off_1002BBCA0 == &_os_log_default)
    {
      os_log_t v22 = os_log_create("com.apple.isp", "general");
      off_1002BBCA0 = v22;
    }
    if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
    {
      CStringPtr = CFStringGetCStringPtr(v21, 0);
      *(_DWORD *)buf = 136315650;
      id v27 = "LoadFrontIRHPRFile";
      __int16 v28 = 1024;
      int v29 = v20;
      __int16 v30 = 2080;
      int v31 = CStringPtr;
      _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "%s - Status = %08x; HPR - %s\n", buf, 0x1Cu);
    }
    goto LABEL_20;
  }
  NSLog(@"No HPR file for frontIR found");
LABEL_44:
  CFStringRef v21 = 0;
LABEL_20:
  if (v15) {
    CFRelease(v15);
  }
  if (v17) {
    CFRelease(v17);
  }
  if (v21) {
    CFRelease(v21);
  }
}

void sub_100033678(DSPComplex *a1, int a2, uint64_t a3, uint64_t a4, float *a5, FFTSetup *a6, float a7)
{
  int v13 = (1 << a2) / 2;
  int v14 = v13 + 1;
  vDSP_Length v15 = (uint64_t)((1 << a2) + (1 << a2 < 0)) >> 1;
  __Z.realp = a5;
  __Z.imagp = &a5[v13 + 1];
  vDSP_ctoz(a1, 2, &__Z, 1, v15);
  vDSP_fft_zrip(*a6, &__Z, 1, a2, 1);
  imagp = __Z.imagp;
  __Z.realp[v13] = *__Z.imagp;
  imagp[v13] = 0.0;
  float *imagp = 0.0;
  vDSP_Length v17 = v13 + 1;
  vDSP_zvabs(&__Z, 1, (float *)a1, 1, v17);
  double v18 = a7 * 0.5;
  double v19 = (double)v13;
  vDSP_vclr((float *)a1, 1, (int)fmin((double)(int)((float)((float)(v13 + 1) * 90.0) / v18), (double)v13));
  int v79 = 0;
  v77[1] = 0;
  uint64_t __C = 0;
  vDSP_Length __I = 0;
  v77[0] = 0;
  vDSP_maxvi((const float *)a1, 1, (float *)&__C, &__I, v15);
  uint64_t v20 = 0;
  int v21 = (int)fmin((double)v13, fmax((double)__I, 1.0));
  float v22 = *(&a1->real + v21);
  uint64_t v23 = v21;
  float v24 = (float)v21;
  uint64_t v25 = v21 - 1;
  float v26 = *(&a1->real + v25);
  uint64_t v27 = v23 + 1;
  float v28 = v22 * v24;
  if (v26 <= *(&a1->real + v27))
  {
    LODWORD(v25) = v27;
    float v26 = *(&a1->real + v27);
  }
  float v29 = (float)(v22 + v26) + 0.0000001;
  float v30 = (float)(v28 + (float)(v26 * (float)(int)v25)) / v29;
  while (1)
  {
    float v73 = 0.0;
    vDSP_Length v72 = 0;
    float v31 = *(float *)&dword_100082860[v20];
    float v32 = (float)(v30 * v31) + -1.0;
    if (v32 < 0.0) {
      float v32 = 0.0;
    }
    uint64_t v33 = v32;
    vDSP_maxvi((const float *)a1 + v33, 1, &v73, &v72, 3uLL);
    vDSP_Length v34 = v72 + v33;
    v72 += v33;
    if (*(float *)&__C > 0.0 && (float)(v73 / *(float *)&__C) > 0.1) {
      break;
    }
    if (++v20 == 4) {
      goto LABEL_11;
    }
  }
  float v30 = v30 * v31;
  vDSP_Length __I = v34;
LABEL_11:
  uint64_t v35 = 0;
  memset(v75, 0, 60);
  float v36 = (float)v13;
  float v37 = *(float *)&__C * 0.08;
  do
  {
    if (v35 == 15) {
      break;
    }
    float v38 = v30 * (float)(v35 + 1);
    if (v38 >= v36) {
      break;
    }
    int v39 = (int)fmax((float)(v38 + -7.0), 0.0);
    double v40 = fmin(v19, (float)(v38 + 7.0));
    float v41 = *((float *)v75 + v35);
    if (v40 > (double)v39)
    {
      uint64_t v42 = (float *)a1 + v39;
      int v43 = v39 + 1;
      do
      {
        float v44 = *v42++;
        float v45 = v44;
        if (v41 < v44) {
          float v41 = v45;
        }
        double v46 = (double)v43++;
      }
      while (v40 > v46);
      *((float *)v75 + v35) = v41;
    }
    ++v35;
  }
  while (v41 >= v37);
  int v47 = 0;
  do
  {
    float v48 = v30 * (float)++v47;
    if (v48 >= v36) {
      break;
    }
    int v49 = (int)fmax((float)(v48 + -7.0), 0.0);
    double v50 = fmin(v19, (float)(v48 + 7.0));
    if (v50 > (double)v49)
    {
      uint64_t v51 = (_DWORD *)a1 + v49;
      int v52 = v49 + 1;
      do
      {
        *v51++ = 0;
        --v14;
        double v53 = (double)v52++;
      }
      while (v50 > v53);
    }
  }
  while (v47 != 15);
  vDSP_maxvi((const float *)a1, 1, (float *)&__C + 1, v77, v17);
  float v71 = 0.0;
  vDSP_meanv((const float *)a1, 1, &v71, v17);
  int v54 = (int)fmin(v19, fmax((double)v77[0], 1.0));
  float v55 = *((float *)a1 + v54 - 1);
  uint64_t v56 = v54 + 1;
  float v57 = *(&a1->real + v56);
  float v58 = *(&a1->real + v54);
  float v59 = v58 * (float)v54;
  if (v55 <= v57) {
    int v60 = v54 + 1;
  }
  else {
    int v60 = v54 - 1;
  }
  if (v55 <= v57) {
    float v55 = *(&a1->real + v56);
  }
  float v61 = v59 + (float)(v55 * (float)v60);
  float v62 = (float)(v58 + v55) + 0.0000001;
  float v63 = v61 / v62;
  float v64 = fmax((double)v14, 1.0);
  float v65 = (float)((float)(v13 + 1) / v64) * v71;
  float v66 = v18 * v30 / v19;
  *(float *)a3 = v66;
  if (v65 == 0.0)
  {
    *(_DWORD *)a4 = 0;
    float v70 = v18 * v63 / v19;
    *(float *)(a3 + 4) = v70;
    float v69 = 0.0;
  }
  else
  {
    float v67 = *((float *)&__C + 1);
    *(float *)a4 = *(float *)&__C / v65;
    float v68 = v18 * v63 / v19;
    *(float *)(a3 + 4) = v68;
    float v69 = v67 / v65;
  }
  *(float *)(a4 + 4) = v69;
  *(_DWORD *)(a3 + 8) = *(_DWORD *)(a3 + 4);
  *(_DWORD *)(a4 + 8) = *(_DWORD *)(a4 + 4);
}

uint64_t sub_100033B58(float *a1, _DWORD *a2, float a3, float a4, float a5, float a6)
{
  int v10 = a2[1];
  if ((*a2 & 0xFFFFFFFD) == 5 || *a2 == 3) {
    int v12 = *a2;
  }
  else {
    int v12 = 5;
  }
  int v13 = (float *)(a2 + 3);
  uint64_t v14 = (int)a2[2];
  *(float *)&a2[v14 + 3] = a3;
  *(float *)&a2[v14 + 19] = a4;
  int v15 = (int)fmin((double)(v10 + 1), (double)v12);
  a2[1] = v15;
  if (v15 <= 0)
  {
    *a1 = 0.0;
LABEL_22:
    *a1 = sub_100033CEC(v13, v15);
    int v15 = a2[1];
    uint64_t result = 1;
    goto LABEL_23;
  }
  int v16 = 0;
  int v17 = v12 + v14;
  LOBYTE(v18) = 1;
  LOBYTE(v19) = 1;
  do
  {
    int v20 = (v17 + v16) % v12;
    int v21 = (float *)&a2[v20];
    BOOL v19 = v19 && vabds_f32(a3, v21[3]) < 2.0 && *(float *)&a2[v20 + 19] > 15.0;
    BOOL v18 = v18 && v21[19] < 6.0;
    --v16;
  }
  while (v15 + v16);
  *a1 = 0.0;
  if (v19) {
    goto LABEL_22;
  }
  if (v18) {
    uint64_t result = 3;
  }
  else {
    uint64_t result = 0;
  }
LABEL_23:
  uint64_t v23 = (int)a2[2];
  if (v15 >= 2) {
    a5 = (float)(*(float *)&a2[(v12 + (int)v23 - 1) % v12 + 35] * 0.382) + (float)(a5 * 0.618);
  }
  float v24 = (float *)&a2[v23];
  v24[35] = a5;
  v24[51] = a6;
  a2[2] = ((int)v23 + 1) % v12;
  return result;
}

float sub_100033CEC(float *a1, int a2)
{
  if (a2 == 2) {
    return (float)(*a1 + a1[1]) * 0.5;
  }
  if (a2 == 1) {
    return *a1;
  }
  if ((a2 - 3) > 1)
  {
    if ((a2 - 5) > 1)
    {
      float result = 0.0;
      if (a2 == 7)
      {
        float v23 = a1[1];
        float v25 = a1[4];
        float v24 = a1[5];
        float v26 = fminf(*a1, v24);
        float v27 = fmaxf(*a1, v24);
        float v29 = a1[2];
        float v28 = a1[3];
        float v30 = fminf(v26, v28);
        float v31 = fmaxf(v26, v28);
        float v32 = a1[6];
        float v33 = fminf(v23, v32);
        float v34 = fmaxf(v23, v32);
        float v35 = fminf(v29, v25);
        float v36 = fmaxf(v29, v25);
        float v37 = fminf(v30, v33);
        float v38 = fmaxf(v30, v33);
        float v39 = fminf(v31, v27);
        float v40 = fmaxf(v31, v27);
        float v41 = fminf(v35, v34);
        float v42 = fmaxf(v35, v34);
        float v43 = fminf(v41, v39);
        float v44 = fmaxf(v41, v39);
        float v45 = fminf(v44, v42);
        a1[6] = fmaxf(v44, v42);
        float v46 = fminf(v36, v40);
        float v47 = fmaxf(v36, v40);
        float v48 = fminf(v38, v46);
        float v49 = fmaxf(v38, v46);
        *a1 = v37;
        a1[1] = fminf(v48, v45);
        float v50 = fmaxf(v48, v45);
        float result = fminf(v50, v49);
        a1[2] = v43;
        a1[3] = result;
        a1[4] = fmaxf(v50, v49);
        a1[5] = v47;
      }
    }
    else
    {
      float v8 = a1[1];
      float v9 = fminf(*a1, v8);
      float v10 = fmaxf(*a1, v8);
      float v12 = a1[3];
      float v11 = a1[4];
      float v13 = a1[2];
      float v14 = fminf(v12, v11);
      float v15 = fmaxf(v12, v11);
      float v16 = fminf(v9, v14);
      float v17 = fmaxf(v9, v14);
      float v18 = fminf(v10, v15);
      float v19 = fmaxf(v10, v15);
      float v20 = fminf(v18, v13);
      *a1 = v16;
      a1[1] = v20;
      float v21 = fmaxf(v18, v13);
      float v22 = fminf(v21, v17);
      a1[2] = v22;
      a1[3] = fmaxf(v21, v17);
      a1[4] = v19;
      return fmaxf(v20, v22);
    }
  }
  else
  {
    float v3 = a1[1];
    float v4 = fminf(*a1, v3);
    float v5 = fmaxf(*a1, v3);
    float v6 = a1[2];
    float v7 = fminf(v5, v6);
    *a1 = v4;
    a1[1] = v7;
    a1[2] = fmaxf(v5, v6);
    return fmaxf(v4, v7);
  }
  return result;
}

void sub_100033E40(DSPComplex *__C, int a2, float *a3, uint64_t a4, float *a5, FFTSetup *a6, float a7)
{
  int v13 = 1 << a2;
  if (1 << a2 >= 0) {
    int v14 = 1 << a2;
  }
  else {
    int v14 = v13 + 1;
  }
  int v15 = v14 >> 1;
  int v16 = (v14 >> 1) + 1;
  vDSP_Length v17 = (uint64_t)v14 >> 1;
  __Z.realp = a5;
  __Z.imagp = &a5[(v14 >> 1) + 1];
  float __B = 0.4945;
  vDSP_vsadd((const float *)__C, 1, &__B, (float *)__C, 1, v13);
  vDSP_ctoz(__C, 2, &__Z, 1, v17);
  vDSP_fft_zrip(*a6, &__Z, 1, a2, 1);
  imagp = __Z.imagp;
  __Z.realp[v15] = *__Z.imagp;
  imagp[v15] = 0.0;
  float *imagp = 0.0;
  vDSP_Length v19 = v16;
  vDSP_zvabs(&__Z, 1, (float *)__C, 1, v16);
  float v20 = (float)v16;
  double v21 = a7 * 0.5;
  double v22 = (double)v15;
  int v23 = (int)fmin((double)(int)((float)((float)v16 * 90.0) / v21), (double)v15);
  float real = __C->real;
  vDSP_vclr((float *)__C, 1, v23);
  int v96 = 0;
  v94[1] = 0;
  uint64_t __Ca = 0;
  vDSP_Length __I = 0;
  v94[0] = 0;
  vDSP_maxvi((const float *)__C, 1, (float *)&__Ca, &__I, v17);
  int v25 = (int)fmin((double)v15, fmax((double)__I, 1.0));
  float v26 = *((float *)__C + v25 - 1);
  uint64_t v27 = v25 + 1;
  float v28 = *(&__C->real + v27);
  float v29 = *(&__C->real + v25);
  float v30 = v29 * (float)v25;
  if (v26 <= v28) {
    int v31 = v25 + 1;
  }
  else {
    int v31 = v25 - 1;
  }
  if (v26 <= v28) {
    float v26 = *(&__C->real + v27);
  }
  float v32 = v30 + (float)(v26 * (float)v31);
  float v33 = (float)(v29 + v26) + 0.0000001;
  float v34 = v32 / v33;
  float v89 = 0.0;
  vDSP_Length v88 = 0;
  float v35 = *(float *)&__Ca;
  float v36 = (float)(*(float *)&__Ca * 1024.0) / (float)v13;
  if (v36 <= 0.1)
  {
    float v41 = 0.06;
  }
  else if (v36 >= 100.0)
  {
    float v41 = 0.03;
  }
  else
  {
    char v37 = 1;
    unsigned int v38 = 1;
    do
    {
      unsigned int v39 = v38;
      float v40 = flt_100082870[v38];
      if ((v37 & 1) == 0) {
        break;
      }
      char v37 = 0;
      unsigned int v38 = 2;
    }
    while (v40 < v36);
    float v41 = flt_10008287C[v39 - 1]
        + (float)((float)((float)(flt_10008287C[v39] - flt_10008287C[v39 - 1]) * (float)(v36 - flt_100082870[v39 - 1]))
                / (float)(v40 - flt_100082870[v39 - 1]));
  }
  unsigned int v42 = vcvtms_u32_f32(v34 / (float)v23);
  if (v42 <= 1) {
    unsigned int v42 = 1;
  }
  unsigned int v43 = v42 - 1;
  if (v42 != 1)
  {
    double v86 = v21;
    unsigned int v44 = 0;
    float v45 = (float)v42;
    while (1)
    {
      float v46 = 1.0 / (float)(v45 - (float)v44);
      float v89 = 0.0;
      vDSP_Length v88 = 0;
      float v47 = (float)(v34 * v46) + -1.0;
      float v48 = 0.0;
      if (v47 < 0.0) {
        float v47 = 0.0;
      }
      uint64_t v49 = v47;
      vDSP_maxvi((const float *)__C + v49, 1, &v89, &v88, 3uLL);
      vDSP_Length v50 = v88 + v49;
      v88 += v49;
      float v35 = *(float *)&__Ca;
      float v51 = 0.0;
      if (*(float *)&__Ca > 0.0) {
        float v51 = v89 / *(float *)&__Ca;
      }
      uint64_t v52 = 0;
      float v53 = (float)(v34 * v46) + -3.0;
      if (v53 < 0.0) {
        float v53 = 0.0;
      }
      unsigned int v54 = v53;
      float v55 = 0.0;
      do
      {
        uint64_t v56 = v54 + v52;
        if (v50 != v56)
        {
          float v55 = v55 + *(&__C->real + v56);
          float v48 = v48 + 1.0;
        }
        ++v52;
      }
      while (v52 != 6);
      if (v48 >= 1.0) {
        float v57 = v48;
      }
      else {
        float v57 = 1.0;
      }
      float v58 = v55 / v57;
      if (v58 <= 0.0) {
        float v58 = 1.0;
      }
      if (v51 > v41 && (float)(v89 / v58) > 1.5) {
        break;
      }
      if (++v44 == v43) {
        goto LABEL_41;
      }
    }
    float v34 = v34 * v46;
    vDSP_Length __I = v50;
LABEL_41:
    double v21 = v86;
    float v20 = (float)v16;
  }
  uint64_t v59 = 0;
  memset(v92, 0, 60);
  float v60 = (float)v15;
  float v61 = v35 * 0.08;
  do
  {
    if (v59 == 15) {
      break;
    }
    float v62 = v34 * (float)(v59 + 1);
    if (v62 >= v60) {
      break;
    }
    unsigned int v63 = fmax((float)(v62 + -7.0), 0.0);
    double v64 = fmin(v22, (float)(v62 + 7.0));
    float v65 = *((float *)v92 + v59);
    if (v64 > (double)v63)
    {
      do
      {
        if (v65 < *(&__C->real + v63)) {
          float v65 = *(&__C->real + v63);
        }
        ++v63;
      }
      while (v64 > (double)v63);
      *((float *)v92 + v59) = v65;
    }
    ++v59;
  }
  while (v65 >= v61);
  int v66 = 0;
  do
  {
    float v67 = v34 * (float)++v66;
    if (v67 >= v60) {
      break;
    }
    unsigned int v68 = fmax((float)(v67 + -7.0), 0.0);
    double v69 = fmin(v22, (float)(v67 + 7.0));
    while (v69 > (double)v68)
    {
      *((_DWORD *)&__C->real + v68) = 0;
      --v16;
      ++v68;
    }
  }
  while (v66 != 15);
  vDSP_maxvi((const float *)__C, 1, (float *)&__Ca + 1, v94, v19);
  float v87 = 0.0;
  vDSP_meanv((const float *)__C, 1, &v87, v19);
  double v70 = 1.0;
  int v71 = (int)fmin(v22, fmax((double)v94[0], 1.0));
  uint64_t v72 = v71 - 1;
  float v73 = *(&__C->real + v72);
  float v74 = *(&__C->imag + v71);
  float v75 = *(&__C->real + v71);
  float v76 = fmax((double)v16, 1.0);
  float v77 = (float)(v20 / v76) * v87;
  float v78 = v21 * v34 / v22;
  *a3 = v78;
  float v79 = *(float *)&__Ca;
  if (v77 == 0.0)
  {
    float v80 = 0.0;
    float v81 = 0.0;
  }
  else
  {
    float v80 = *(float *)&__Ca / v77;
    float v81 = *((float *)&__Ca + 1) / v77;
  }
  if (v73 <= v74)
  {
    float v73 = v74;
    LODWORD(v72) = v71 + 1;
  }
  float v82 = (float)(v75 * (float)v71) + (float)(v73 * (float)(int)v72);
  float v83 = (float)(v75 + v73) + 0.0000001;
  float v84 = v21 * (float)(v82 / v83) / v22;
  *(float *)a4 = v80;
  a3[1] = v84;
  *(float *)(a4 + 4) = v81;
  if (v79 > 0.0) {
    double v70 = v79;
  }
  float v85 = real / v70;
  a3[2] = v85;
  *(_DWORD *)(a4 + 8) = *(_DWORD *)(a4 + 4);
}

uint64_t sub_100034488(float *a1, float *a2, uint64_t a3, float a4, float a5, float a6, float a7, float a8, double a9)
{
  float v13 = a9;
  float v14 = 1.0;
  if (v13 > 3000.0)
  {
    float v14 = 0.625;
    if (v13 < 12000.0) {
      float v14 = (float)((float)((float)(v13 + -3000.0) * -0.375) / 9000.0) + 1.0;
    }
  }
  float v15 = v14 * a5;
  int v16 = *(_DWORD *)(a3 + 4);
  if ((*(_DWORD *)a3 & 0xFFFFFFFD) == 5 || *(_DWORD *)a3 == 3) {
    int v18 = *(_DWORD *)a3;
  }
  else {
    int v18 = 5;
  }
  uint64_t v19 = *(int *)(a3 + 8);
  float v20 = (float *)(a3 + 12 + 4 * v19);
  *float v20 = a4;
  *(float *)(a3 + 76 + 4 * v19) = v15;
  *(float *)(a3 + 4 * v19 + 268) = a8;
  if (v16 + 1 < v18) {
    int v21 = v16 + 1;
  }
  else {
    int v21 = v18;
  }
  *(_DWORD *)(a3 + 4) = v21;
  int v22 = v21 - 1;
  if (v21 > 1)
  {
    int v23 = v18 + v19 - 1;
    while (1)
    {
      uint64_t v24 = a3 + 4 * (v23 % v18);
      float v26 = *(float *)(v24 + 12);
      int v25 = (float *)(v24 + 12);
      float v27 = v26;
      if (v26 < a4 && v27 > 0.0)
      {
        float v28 = fabsf(a4 / v27);
        if (v28 > 1.9 && vabds_f32(a4 / v27, v28) < 0.05) {
          break;
        }
      }
      --v23;
      if (!--v22) {
        goto LABEL_20;
      }
    }
    if (v15 >= (float)(*(float *)(a3 + 4 * (v23 % v18) + 76) * 1.25))
    {
      a4 = v27;
    }
    else
    {
      *float v20 = v27;
      a4 = *v25;
    }
  }
LABEL_20:
  if (v21 < 1)
  {
    *a1 = 0.0;
LABEL_38:
    float v37 = *v20;
    *float v20 = a4;
    *a1 = sub_100033CEC((float *)(a3 + 12), v21);
    int v21 = *(_DWORD *)(a3 + 4);
    *(float *)(a3 + 4 * *(int *)(a3 + 8) + 12) = v37;
    uint64_t v36 = 1;
    goto LABEL_39;
  }
  int v29 = v18 + v19;
  LOBYTE(v30) = 1;
  int v31 = v21;
  LOBYTE(v32) = 1;
  do
  {
    int v33 = v29 % v18;
    uint64_t v34 = a3 + 4 * (v29 % v18);
    BOOL v32 = v32
       && vabds_f32(a4, *(float *)(v34 + 12)) < 2.0
       && (uint64_t v35 = a3 + 4 * v33, *(float *)(v35 + 76) > 15.0)
       && *(float *)(v35 + 268) < 300.0;
    if (v30) {
      BOOL v30 = *(float *)(v34 + 76) < 6.0 || *(float *)(a3 + 4 * v33 + 268) > 400.0;
    }
    else {
      BOOL v30 = 0;
    }
    --v29;
    --v31;
  }
  while (v31);
  *a1 = 0.0;
  if (v32) {
    goto LABEL_38;
  }
  if (v30) {
    uint64_t v36 = 3;
  }
  else {
    uint64_t v36 = 0;
  }
LABEL_39:
  float __C = 0.0;
  vDSP_meanv((const float *)(a3 + 76), 1, &__C, v21);
  *a2 = __C;
  uint64_t v38 = *(int *)(a3 + 8);
  if (*(int *)(a3 + 4) >= 2) {
    a6 = (float)(*(float *)(a3 + 4 * ((v18 + (int)v38 - 1) % v18) + 140) * 0.382) + (float)(a6 * 0.618);
  }
  uint64_t v39 = a3 + 4 * v38;
  *(float *)(v39 + 140) = a6;
  *(float *)(v39 + 204) = a7;
  *(_DWORD *)(a3 + 8) = ((int)v38 + 1) % v18;
  return v36;
}

float sub_1000347A0(const float *a1, vDSP_Length __N)
{
  float __C = 0.0;
  vDSP_meanv(a1, 1, &__C, __N);
  return __C;
}

float32x4_t *sub_1000347D4(float32x4_t *result, unint64_t a2, uint64_t a3, uint64_t a4, unsigned int a5, float a6)
{
  if (a5)
  {
    uint64_t v6 = 0;
    uint64_t v7 = a5;
    uint64_t v8 = 1;
    do
    {
      *(_DWORD *)(a4 + 4 * v6) = 0;
      float v9 = *(float *)(a3 + 4 * v6);
      if (v9 <= 0.0)
      {
        unint64_t v18 = v8;
      }
      else
      {
        unint64_t v10 = (float)((float)((float)(a6 / v9)
                                          * (float)(float)((float)((float)a2 / (float)(a6 / v9)) / 5.0))
                                  + 0.5);
        if (v10 >= a2) {
          uint64_t v11 = a2;
        }
        else {
          uint64_t v11 = v10;
        }
        unint64_t v12 = v11 & 0xFFFFFFFC;
        if ((int)v12 < 1)
        {
          uint64_t v17 = 0;
          float32x4_t v14 = 0uLL;
        }
        else
        {
          unint64_t v13 = 0;
          float32x4_t v14 = 0uLL;
          float v15 = result;
          do
          {
            float32x4_t v16 = *v15++;
            float32x4_t v14 = vmlaq_f32(v14, v16, v16);
            v13 += 4;
          }
          while (v13 < v12);
          uint64_t v17 = v13;
        }
        unsigned __int32 v19 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v14, 3), vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v14, 2), vaddq_f32(v14, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v14.f32, 1)))).u32[0];
        if ((int)v17 < (int)v11)
        {
          uint64_t v20 = v11 - v17;
          int v21 = &result->f32[v17];
          do
          {
            float v22 = *v21++;
            *(float *)&unsigned __int32 v19 = *(float *)&v19 + (float)(v22 * v22);
            --v20;
          }
          while (v20);
        }
        unint64_t v18 = v8 + 4;
        float v23 = 0.0;
        uint64_t v24 = v8;
        unsigned int v25 = v10;
        float v26 = result;
        do
        {
          float v27 = *(float *)&v19;
          float v28 = (float32x4_t *)((char *)result + 4 * v25);
          unint64_t v29 = ~(unint64_t)v25 + a2;
          if (v29 <= v10) {
            unint64_t v29 = v29;
          }
          else {
            unint64_t v29 = v10;
          }
          unint64_t v30 = v29 & 0xFFFFFFFC;
          if ((int)v30 < 1)
          {
            uint64_t v38 = 0;
            float32x4_t v32 = 0uLL;
          }
          else
          {
            unint64_t v31 = 0;
            float32x4_t v32 = 0uLL;
            int v33 = v26;
            uint64_t v34 = (float32x4_t *)((char *)result + 4 * v25);
            do
            {
              float32x4_t v35 = *v33++;
              float32x4_t v36 = v35;
              float32x4_t v37 = *v34++;
              float32x4_t v32 = vmlaq_f32(v32, v37, v36);
              v31 += 4;
            }
            while (v31 < v30);
            uint64_t v38 = v31;
          }
          uint64_t v39 = v25;
          LODWORD(v40) = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v32, 3), vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v32, 2), vaddq_f32(v32, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v32.f32, 1)))).u32[0];
          if ((int)v38 < (int)v29)
          {
            uint64_t v41 = v29 - v38;
            unsigned int v42 = &result->f32[v38 + v39];
            unsigned int v43 = &v26->f32[v38];
            do
            {
              float v44 = *v43++;
              float v45 = v44;
              float v46 = *v42++;
              float v40 = v40 + (float)(v45 * v46);
              --v41;
            }
            while (v41);
          }
          if ((int)v30 < 1)
          {
            uint64_t v51 = 0;
            float32x4_t v48 = 0uLL;
          }
          else
          {
            unint64_t v47 = 0;
            float32x4_t v48 = 0uLL;
            uint64_t v49 = (float32x4_t *)((char *)result + 4 * v25);
            do
            {
              float32x4_t v50 = *v49++;
              float32x4_t v48 = vmlaq_f32(v48, v50, v50);
              v47 += 4;
            }
            while (v47 < v30);
            uint64_t v51 = v47;
          }
          unsigned __int32 v19 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v48, 3), vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v48, 2), vaddq_f32(v48, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v48.f32, 1)))).u32[0];
          if ((int)v51 < (int)v29)
          {
            uint64_t v52 = v29 - v51;
            float v53 = &result->f32[v51 + v39];
            do
            {
              float v54 = *v53++;
              *(float *)&unsigned __int32 v19 = *(float *)&v19 + (float)(v54 * v54);
              --v52;
            }
            while (v52);
          }
          float v55 = 0.0;
          if (fabsf(v27) > 0.001 && fabsf(*(float *)&v19) > 0.001) {
            float v55 = (float)(fabsf(v40) / sqrtf(v27)) / sqrtf(*(float *)&v19);
          }
          v25 += v10;
          float v23 = v23 + v55;
          ++v24;
          float v26 = v28;
        }
        while (v24 != v18);
        if (v18 > 1) {
          *(float *)(a4 + 4 * v6) = v23 / (float)(unint64_t)(v8 + 3);
        }
      }
      ++v6;
      uint64_t v8 = v18;
    }
    while (v6 != v7);
  }
  return result;
}

void sub_100034A54(const float *a1, int a2, int a3, uint64_t a4, uint64_t a5)
{
  float v9 = a1;
  uint64_t __C = 0;
  vDSP_Length v10 = a2;
  vDSP_maxv(a1, 1, (float *)&__C + 1, a2);
  vDSP_minv(v9, 1, (float *)&__C, v10);
  float v11 = *(float *)&__C;
  float v12 = (float)(*((float *)&__C + 1) - *(float *)&__C) / (float)a3;
  if (v12 == 0.0) {
    float v12 = 0.0000001;
  }
  if (a3 >= 1)
  {
    uint64_t v13 = 0;
    do
    {
      *(float *)(a5 + 4 * v13) = v11 + (float)((float)(int)v13 * v12);
      *(_DWORD *)(a4 + 4 * v13++) = 0;
    }
    while (a3 != v13);
  }
  if (a2 >= 1)
  {
    uint64_t v14 = a2;
    do
    {
      float v15 = *v9++;
      signed int v16 = vcvtms_s32_f32((float)(v15 - v11) / v12);
      if (v16 >= a3) {
        signed int v16 = a3 - 1;
      }
      ++*(_DWORD *)(a4 + 4 * v16);
      --v14;
    }
    while (v14);
  }
}

float sub_100034B4C(int a1, uint64_t a2, int a3, int a4, float *a5, float a6, float a7)
{
  float v8 = (float)(a4 >> 1);
  float v9 = (float)a3;
  double v10 = (float)((float)(a6 / v8) * (float)a3) + 0.5;
  float v11 = (float)(int)v10;
  BOOL v12 = v10 <= 1.0;
  float v13 = 1.0;
  if (!v12) {
    float v13 = v11;
  }
  int v14 = (int)((float)(v9 / v13) + 0.5);
  if (v14 < 1)
  {
    float v16 = 0.0;
  }
  else
  {
    int v15 = 0;
    float v16 = 0.0;
    do
    {
      double v17 = (float)((float)((float)((float)++v15 * a6) / v8) * v9) + 0.5;
      unsigned int v18 = ((int)v17 - a1) & ~(((int)v17 - a1) >> 31);
      int v19 = (int)v17 + a1;
      if (v19 >= a3 - 1) {
        int v19 = a3 - 1;
      }
      if ((int)v18 <= v19)
      {
        uint64_t v20 = (v19 + 1);
        int v21 = (float *)(a2 + 4 * v18);
        uint64_t v22 = v20 - v18;
        do
        {
          float v23 = *v21++;
          float v16 = v16 + (float)(v23 * v23);
          --v22;
        }
        while (v22);
      }
    }
    while (v15 != v14);
  }
  float result = log10f(v16 / a7) * 10.0;
  *a5 = result;
  return result;
}

float sub_100034C44(int a1, uint64_t a2, int a3, int a4, float *a5, float a6, float a7, float a8)
{
  float v9 = (float)(a4 >> 1);
  float v10 = (float)a3;
  double v11 = (float)((float)(a6 / v9) * (float)a3) + 0.5;
  float v12 = (float)(int)v11;
  BOOL v13 = v11 <= 1.0;
  float v14 = 1.0;
  if (!v13) {
    float v14 = v12;
  }
  int v15 = (int)((float)(v10 / v14) + 0.5);
  if (v15 < 1)
  {
    float v18 = 0.0;
  }
  else
  {
    int v16 = 0;
    signed int v17 = vcvtmd_s64_f64((float)((float)(a8 / v9) * v10) + 0.5);
    float v18 = 0.0;
    do
    {
      int v19 = (int)((float)((float)((float)((float)++v16 * a6) / v9) * v10) + 0.5);
      signed int v20 = v19 - a1;
      if (v19 - a1 <= v17) {
        signed int v20 = v17;
      }
      int v21 = v19 + a1;
      if (v21 >= a3 - 1) {
        int v22 = a3 - 1;
      }
      else {
        int v22 = v21;
      }
      if (v20 <= v22)
      {
        float v23 = (float *)(a2 + 4 * v20);
        int v24 = v22 - v20 + 1;
        do
        {
          float v25 = *v23++;
          float v18 = v18 + (float)(v25 * v25);
          --v24;
        }
        while (v24);
      }
    }
    while (v16 != v15);
  }
  float result = log10f(a7 / v18) * 10.0;
  *a5 = result;
  return result;
}

uint64_t sub_100034D54(uint64_t result, float *a2, int a3, int a4, float *a5, float a6)
{
  float v6 = (float)(a4 >> 1);
  float v7 = (float)a3;
  int v8 = (int)fmax((float)((float)(a6 / v6) * (float)a3) + 0.5, 1.0);
  int v9 = (v8 - 4) >> 1;
  if (v9 <= 1) {
    int v9 = 1;
  }
  int v10 = (int)((float)(v7 / (float)v8) + 0.5);
  float v11 = 0.0;
  float v12 = 0.0;
  int v13 = a3 - 1;
  if (a3 >= 1)
  {
    uint64_t v14 = a3;
    int v15 = a2;
    do
    {
      float v16 = *v15++;
      float v12 = v12 + (float)(v16 * v16);
      --v14;
    }
    while (v14);
  }
  if (v10 >= 1)
  {
    int v17 = 0;
    float v11 = 0.0;
    do
    {
      int v18 = (int)((float)((float)((float)((float)++v17 * a6) / v6) * v7) + 0.5);
      int v19 = (v18 - result) & ~((v18 - (int)result) >> 31);
      if (v19 >= v13) {
        int v19 = a3 - 1;
      }
      int v20 = v18 + result;
      if (v18 + (int)result >= v13) {
        int v20 = a3 - 1;
      }
      if (v19 > v20) {
        int v20 = v19;
      }
      int v21 = (v18 - v9) & ~((v18 - v9) >> 31);
      if (v21 >= v13) {
        int v21 = a3 - 1;
      }
      int v22 = v9 + v18;
      if (v22 >= v13) {
        int v22 = a3 - 1;
      }
      if (v22 <= v21) {
        int v23 = v21;
      }
      else {
        int v23 = v22;
      }
      int v24 = &a2[v21];
      float v25 = *v24;
      int v26 = v23 - v21;
      if (v26 >= 0)
      {
        uint64_t v27 = -(uint64_t)(v26 + 1);
        do
        {
          float v28 = *v24++;
          float v29 = v28;
          if (v25 < v28) {
            float v25 = v29;
          }
          BOOL v30 = __CFADD__(v27++, 1);
        }
        while (!v30);
      }
      unint64_t v31 = &a2[v19];
      float v32 = *v31;
      if (v20 - v19 >= 0)
      {
        uint64_t v33 = -(uint64_t)(v20 - v19 + 1);
        uint64_t v34 = &a2[v19];
        do
        {
          float v35 = *v34++;
          float v36 = v35;
          if (v32 < v35) {
            float v32 = v36;
          }
          BOOL v30 = __CFADD__(v33++, 1);
        }
        while (!v30);
      }
      if (v25 * 0.999 < v32)
      {
        int v37 = ~v20 + v19;
        do
        {
          float v38 = *v31++;
          float v11 = v11 + (float)(v38 * v38);
          BOOL v30 = __CFADD__(v37++, 1);
        }
        while (!v30);
      }
    }
    while (v17 != v10);
  }
  float v39 = v11 / v12;
  if ((float)(v11 / v12) > 1.0) {
    float v39 = 1.0;
  }
  *a5 = v39;
  return result;
}

uint64_t sub_100034EFC(uint64_t result, float *a2, int a3, int a4, float *a5, float a6)
{
  float v6 = (float)(a4 >> 1);
  float v7 = (float)a3;
  double v8 = (float)((float)(a6 / v6) * (float)a3) + 0.5;
  int v9 = (int)v8;
  BOOL v10 = v8 <= 1.0;
  float v11 = 1.0;
  if (!v10) {
    float v11 = (float)v9;
  }
  int v12 = (int)((float)(v7 / v11) + 0.5);
  float v13 = 0.0;
  float v14 = 0.0;
  if (a3 >= 1)
  {
    uint64_t v15 = a3;
    float v16 = a2;
    do
    {
      float v17 = *v16++;
      float v14 = v14 + (float)(v17 * v17);
      --v15;
    }
    while (v15);
  }
  if (v12 >= 1)
  {
    int v18 = 0;
    float v13 = 0.0;
    do
    {
      double v19 = (float)((float)((float)((float)++v18 * a6) / v6) * v7) + 0.5;
      int v20 = ((int)v19 - result) & ~(((int)v19 - (int)result) >> 31);
      int v21 = (int)v19 + result;
      if (v21 >= a3 - 1) {
        int v21 = a3 - 1;
      }
      if (v20 <= v21)
      {
        uint64_t v22 = (v21 + 1);
        int v23 = &a2[v20];
        uint64_t v24 = v22 - v20;
        do
        {
          float v25 = *v23++;
          float v13 = v13 + (float)(v25 * v25);
          --v24;
        }
        while (v24);
      }
    }
    while (v18 != v12);
  }
  float v26 = v13 / v14;
  if ((float)(v13 / v14) > 1.0) {
    float v26 = 1.0;
  }
  *a5 = v26;
  return result;
}

uint64_t sub_100034FF8()
{
  uint64_t v0 = __chkstk_darwin();
  v26[0] = 0;
  v25[0] = v2;
  if (v2 >= 1)
  {
    for (uint64_t i = 0; i != v2; ++i)
      *(_DWORD *)(v1 + 4 * i) = i;
  }
  LODWORD(v4) = 0;
  uint64_t v5 = v1 + 4;
  while (1)
  {
    while (1)
    {
      uint64_t v6 = v4;
      int v7 = v26[v4];
      int v8 = v25[v4];
      int v9 = v8 - 1;
      if (v7 < v8 - 1) {
        break;
      }
      LODWORD(v4) = v4 - 1;
      if (v6 - 1 < 0) {
        return 0;
      }
    }
    if (v4 == 999) {
      break;
    }
    float v10 = *(float *)(v0 + 4 * v7);
    int v11 = *(_DWORD *)(v1 + 4 * v7);
    do
    {
      uint64_t v12 = v9;
      uint64_t v13 = v7;
      uint64_t v14 = (uint64_t)&_mh_execute_header + ((uint64_t)v9 << 32);
      uint64_t v15 = (float *)(v0 + 4 + 4 * v9);
      do
      {
        uint64_t v16 = v12;
        float v17 = *--v15;
        float v18 = v17;
        --v12;
        v14 -= 0x100000000;
      }
      while (v16 > v13 && v18 >= v10);
      if (v16 > v13)
      {
        *(float *)(v0 + 4 * v13) = v18;
        *(_DWORD *)(v1 + 4 * v13) = *(_DWORD *)(v5 + 4 * v12);
        uint64_t v13 = (int)v13 + 1;
      }
      int v9 = v12 + 1;
      uint64_t v19 = v14 >> 32;
      uint64_t v20 = (v13 << 32) - 0x100000000;
      do
      {
        uint64_t v21 = v13;
        float v22 = *(float *)(v0 + 4 * v13++);
        v20 += (uint64_t)&_mh_execute_header;
      }
      while (v21 < v19 && v22 <= v10);
      if (v21 < v19)
      {
        *uint64_t v15 = v22;
        *(_DWORD *)(v5 + 4 * v12) = *(_DWORD *)(v1 - 4 + 4 * v13);
        int v9 = v12;
      }
      int v7 = v13 - 1;
    }
    while (v9 > (int)v13 - 1);
    uint64_t v23 = v20 >> 30;
    *(float *)(v0 + v23) = v10;
    *(_DWORD *)(v1 + v23) = v11;
    uint64_t v4 = (int)v6 + 1;
    v26[v4] = v13;
    v25[v4] = v8;
    v25[v6] = v7;
    if ((v4 & 0x80000000) != 0) {
      return 0;
    }
  }
  return 0xFFFFFFFFLL;
}

float sub_1000351B0(uint64_t a1, int a2)
{
  uint64_t v4 = malloc_type_malloc(4 * a2, 0x100004052888210uLL);
  if (v4)
  {
    uint64_t v5 = v4;
    if (a2 >= 1)
    {
      uint64_t v6 = 0;
      do
      {
        *((_DWORD *)v4 + v6) = v6;
        ++v6;
      }
      while (a2 != v6);
    }
    sub_100034FF8();
    free(v5);
    int v7 = (a2 & 1) + (a2 >> 1) - 1;
  }
  else
  {
    int v7 = a2 - 1;
  }
  return *(float *)(a1 + 4 * v7);
}

uint64_t sub_10003524C(uint64_t result, int a2, int a3, float *a4, float a5)
{
  if (a3 >= 0) {
    int v5 = a3;
  }
  else {
    int v5 = a3 + 1;
  }
  int v6 = (int)(float)((float)(a5 / (float)(v5 >> 1)) * (float)a2);
  if (v6 <= 2) {
    int v7 = 2;
  }
  else {
    int v7 = v6;
  }
  int v8 = v7 - 2;
  if (v8 >= a2 - 1) {
    int v8 = a2 - 1;
  }
  int v9 = v6 + 2;
  if (v9 >= a2 - 1) {
    int v9 = a2 - 1;
  }
  int v10 = v9 & ~(v9 >> 31);
  int v11 = (float *)(result + 4 * v8);
  float v12 = *v11;
  int v13 = v10 - v8;
  if (v13 >= 0)
  {
    uint64_t v14 = -(uint64_t)(v13 + 1);
    do
    {
      float v15 = *v11++;
      float v16 = v15;
      if (v12 < v15) {
        float v12 = v16;
      }
    }
    while (!__CFADD__(v14++, 1));
  }
  *a4 = v12;
  return result;
}

uint64_t sub_1000352CC(uint64_t a1, int a2, int a3)
{
  int v3 = 0;
  int v4 = a3 + 2;
  float v5 = 1.0 / *(float *)(a1 + 4 * a3);
  do
  {
    int v6 = v4 + v3;
    if (v4 + v3 >= a2 - 1) {
      int v6 = a2 - 1;
    }
    float v7 = v5 + (float)(-1.0 / *(float *)(a1 + 4 * v6));
    int v8 = v3 + 1;
  }
  while (v7 < 30.0 && v3++ != 8);
  int v10 = 0;
  unsigned int v11 = v8 + 1;
  do
  {
    int v12 = v10 - 1;
    BOOL v13 = (float)((float)(1.0 / *(float *)(a1 + 4 * ((a3 - 2 + v10) & ~((a3 - 2 + v10) >> 31)))) - v5) >= 30.0
       || v10 == -8;
    --v10;
  }
  while (!v13);
  if (v11 >= 1 - v12) {
    return (1 - v12);
  }
  else {
    return v11;
  }
}

float32_t sub_100035368(float32x4_t *a1, float32x4_t *a2, float32x4_t *a3, int a4)
{
  unint64_t v4 = a4 & 0xFFFFFFFC;
  if ((int)v4 < 1)
  {
    LODWORD(v5) = 0;
  }
  else
  {
    unint64_t v5 = 0;
    int v6 = a1;
    float v7 = a2;
    int v8 = a3;
    do
    {
      float32x4_t v9 = *v6++;
      float32x4_t v10 = v9;
      float32x4_t v11 = *v7++;
      float32x4_t v12 = vmulq_f32(v10, v11);
      *v8++ = v12;
      v5 += 4;
    }
    while (v5 < v4);
  }
  if ((int)v5 < a4)
  {
    BOOL v13 = &a3->i32[v5];
    uint64_t v14 = &a2->f32[v5];
    float v15 = &a1->f32[v5];
    unint64_t v16 = a4 - (unint64_t)v5;
    do
    {
      float v17 = *v15++;
      float v18 = v17;
      float v19 = *v14++;
      v12.f32[0] = v18 * v19;
      *v13++ = v12.i32[0];
      --v16;
    }
    while (v16);
  }
  return v12.f32[0];
}

float sub_1000353E0(float *a1, float *a2, int a3, int a4)
{
  float result = 0.0;
  if (a4 && a1 && a2)
  {
    float v5 = 0.0;
    float v6 = 0.0;
    if (a4 >= 1)
    {
      uint64_t v7 = a4;
      int v8 = a1;
      do
      {
        float v9 = *v8++;
        float v6 = v6 + v9;
        --v7;
      }
      while (v7);
    }
    float v10 = (float)a4;
    if (fabsf(v6) <= (float)a4) {
      float v5 = v6;
    }
    *a2 = v5;
    if (a3 > a4)
    {
      float32x4_t v11 = a2 + 1;
      uint64_t v12 = (a3 - a4 + 1) - 1;
      int v13 = a4;
      uint64_t v14 = a1;
      do
      {
        float v15 = *v14++;
        float v5 = (float)(v5 - v15) + a1[v13];
        if (fabsf(v5) <= v10) {
          float v16 = v5;
        }
        else {
          float v16 = 0.0;
        }
        *v11++ = v16;
        ++v13;
        --v12;
      }
      while (v12);
    }
    float v17 = 0.0;
    if (2 * a4 <= a3)
    {
      uint64_t v18 = (a3 - 2 * a4 + 1);
      do
      {
        float v19 = a2[a4];
        float v20 = *a2++;
        float v21 = vabds_f32(v19, v20);
        if (v21 > v17) {
          float v17 = v21;
        }
        --v18;
      }
      while (v18);
    }
    return v17 / v10;
  }
  return result;
}

void sub_1000354B8(uint64_t a1, int a2, int a3, int a4, int a5, uint64_t a6, float a7, float a8)
{
  *(_DWORD *)(a1 + 4) = a2;
  *(_DWORD *)(a1 + 8) = a3;
  *(_DWORD *)(a1 + 12) = a4;
  *(_DWORD *)(a1 + 20) = a5;
  *(float *)(a1 + 24) = a7;
  *(float *)(a1 + 28) = a8;
  *(void *)(a1 + 32) = 0x100000008;
  *(_DWORD *)(a1 + 40) = 0;
  *(void *)(a1 + 44) = 0x3F7333333F666666;
  v10.i32[1] = 90;
  *(void *)(a1 + 52) = 0x5A00000001;
  *(_DWORD *)(a1 + 336) = 64;
  int v11 = a2 / a3;
  if (a2 / a3 >= 0) {
    int v12 = a2 / a3;
  }
  else {
    int v12 = v11 + 1;
  }
  int v13 = v12 >> 1;
  *(_DWORD *)(a1 + 60) = v11;
  if (a4 >= 0) {
    int v14 = a4;
  }
  else {
    int v14 = a4 + 1;
  }
  *(float *)v10.i32 = (float)v13;
  int32x2_t v15 = vcvt_s32_f32(vmul_n_f32(vdiv_f32((float32x2_t)0x4580200042B40000, (float32x2_t)vdup_lane_s32(v10, 0)), (float)(v14 >> 1)));
  *(int32x2_t *)(a1 + 64) = v15;
  *(void *)(a1 + 72) = a6;
  float v16 = (char *)(a6 + 4 * a4);
  if (a4 >= 1)
  {
    uint64_t v17 = 0;
    *(float *)v15.i32 = (float)(a4 - 1);
    float32x2_t v18 = (float32x2_t)vdup_n_s32(0x40C90FDAu);
    int64x2_t v85 = vdupq_n_s64(2uLL);
    uint64x2_t v86 = (uint64x2_t)vdupq_n_s64((unint64_t)a4 - 1);
    uint64_t v19 = (a4 + 1) & 0x1FFFFFFFELL;
    float32x2_t v20 = (float32x2_t)vdup_lane_s32(v15, 0);
    uint64x2_t v21 = (uint64x2_t)xmmword_100082850;
    __asm
    {
      FMOV            V2.2D, #-0.5
      FMOV            V0.2D, #0.5
    }
    float64x2_t v83 = _Q0;
    float64x2_t v84 = _Q2;
    do
    {
      int64x2_t v90 = (int64x2_t)v21;
      int32x2_t v89 = vmovn_s64((int64x2_t)vcgeq_u64(v86, v21));
      v28.i32[0] = v17;
      v28.i32[1] = v17 + 1;
      float32x2_t v29 = vmul_f32(vdiv_f32(vcvt_f32_s32(v28), v20), v18);
      float v87 = v29.f32[0];
      float v88 = cosf(v29.f32[1]);
      v30.f32[0] = cosf(v87);
      v30.f32[1] = v88;
      float64x2_t v31 = vmlaq_f64(v83, v84, vcvtq_f64_f32(v30));
      if (v89.i8[0])
      {
        float v32 = v31.f64[0];
        *(float *)(a6 + 4 * v17) = v32;
      }
      if (v89.i8[4])
      {
        float v33 = v31.f64[1];
        *(float *)(a6 + 4 * v17 + 4) = v33;
      }
      v17 += 2;
      uint64x2_t v21 = (uint64x2_t)vaddq_s64(v90, v85);
    }
    while (v19 != v17);
  }
  for (uint64_t i = 0; i != 64; i += 8)
  {
    float v35 = v16;
    *(void *)(a1 + 80 + i) = v16;
    size_t v36 = 4 * (*(_DWORD *)(a1 + 12) / 2 + 1);
    v16 += v36;
    bzero(v35, v36);
  }
  *(void *)(a1 + 216) = v16;
  size_t v37 = 4 * (*(_DWORD *)(a1 + 12) / 2 + 1);
  float v38 = &v16[v37];
  bzero(v16, v37);
  for (uint64_t j = 0; j != 64; j += 8)
  {
    float v40 = v38;
    *(void *)(a1 + 144 + j) = v38;
    int v41 = *(_DWORD *)(a1 + 12) / 2;
    size_t v42 = 4 * (v41 + 1);
    v38 += v42;
    bzero(v40, v42);
  }
  *(void *)(a1 + 224) = v38;
  int v43 = *(_DWORD *)(a1 + 12) / 2;
  size_t v44 = 4 * (v43 + 1);
  float v45 = &v38[v44];
  bzero(v38, v44);
  int v46 = 0;
  *(_DWORD *)(a1 + 208) = 0;
  int v47 = *(_DWORD *)(a1 + 12);
  int v48 = v47;
  uint64_t v49 = &v45[4 * v47];
  *(void *)(a1 + 232) = v45;
  *(void *)(a1 + 240) = v49;
  float32x4_t v50 = &v49[4 * v47];
  uint64_t v51 = v47 + 2;
  if (v47 >= 0) {
    int v52 = v47;
  }
  else {
    int v52 = v47 + 1;
  }
  int v53 = v52 >> 1;
  *(void *)(a1 + 264) = v50;
  *(void *)(a1 + 272) = &v50[4 * v53];
  float v54 = &v50[4 * v51];
  *(void *)(a1 + 248) = v50;
  *(void *)(a1 + 256) = v54;
  float v55 = &v54[4 * v51];
  if (v47 >= 2)
  {
    int v46 = 0;
    int v56 = v47;
    do
    {
      ++v46;
      BOOL v57 = v56 > 3;
      v56 >>= 1;
    }
    while (v57);
  }
  *(_DWORD *)(a1 + 16) = v46;
  uint64_t v58 = (v53 + 1);
  uint64_t v59 = &v55[4 * (int)v58];
  *(void *)(a1 + 280) = v55;
  *(void *)(a1 + 288) = v59;
  float v60 = &v59[4 * v47];
  *(_DWORD *)(a1 + 336) = 64;
  *(void *)(a1 + 344) = v60 + 256;
  *(void *)(a1 + 352) = v60;
  v60 += 512;
  float v61 = &v60[4 * (int)v58];
  *(void *)(a1 + 296) = v60;
  *(void *)(a1 + 304) = v61;
  float v62 = &v61[4 * (int)v58];
  unsigned int v63 = &v62[(int)v58];
  *(void *)(a1 + 312) = v62;
  *(void *)(a1 + 320) = v63;
  double v64 = &v63[(int)v58];
  *(void *)(a1 + 816) = v64;
  *(_DWORD *)(a1 + 824) = v64 - a6;
  *(unsigned char *)(a1 + 828) = 0;
  if (v47 > -2)
  {
    uint64_t v67 = 0;
    uint64x2_t v68 = (uint64x2_t)vdupq_n_s64(v58 - 1);
    float v69 = (float)v47;
    float v70 = (float)*(int *)(a1 + 60);
    uint64_t v71 = (v58 + 1) & 0x1FFFFFFFELL;
    uint64_t v72 = (float *)&v40[12 * v47 + 528 + 8 * v51 + 4 * v43 + 4 * (uint64_t)v53 + 4 * v41];
    int64x2_t v73 = (int64x2_t)xmmword_100082850;
    int64x2_t v74 = vdupq_n_s64(2uLL);
    do
    {
      int32x2_t v75 = vmovn_s64((int64x2_t)vcgeq_u64(v68, (uint64x2_t)v73));
      if (v75.i8[0]) {
        *(v72 - 1) = (float)((float)(int)v67 / v69) * v70;
      }
      if (v75.i8[4]) {
        *uint64_t v72 = (float)((float)(v67 + 1) / v69) * v70;
      }
      v67 += 2;
      int64x2_t v73 = vaddq_s64(v73, v74);
      v72 += 2;
    }
    while (v71 != v67);
    *(_DWORD *)(a1 + 328) = 0;
    int v66 = v53 - 1;
    *(_DWORD *)(a1 + 332) = v53 - 1;
    *(_DWORD *)float v61 = 925353388;
    if (v47 < 4)
    {
      int v65 = 0;
    }
    else
    {
      int v65 = 0;
      float v76 = (float)*(int *)(a1 + 60);
      if (v53 <= 2) {
        uint64_t v77 = 2;
      }
      else {
        uint64_t v77 = v53;
      }
      uint64_t v78 = 1;
      while (1)
      {
        float v79 = (float)(int)v78 / v76;
        *((float *)v61 + 1) = v79;
        if (v79 >= 0.0002 && *(float *)v61 < 0.0002)
        {
          *(_DWORD *)(a1 + 328) = v78;
          int v65 = v78;
        }
        if (v79 >= 0.011111 && *(float *)v61 < 0.011111) {
          break;
        }
        ++v78;
        v61 += 4;
        if (v77 == v78) {
          goto LABEL_46;
        }
      }
      *(_DWORD *)(a1 + 332) = v78;
      int v66 = v78;
    }
  }
  else
  {
    int v65 = 0;
    *(_DWORD *)(a1 + 328) = 0;
    int v66 = v53 - 1;
    *(_DWORD *)(a1 + 332) = v53 - 1;
    *(_DWORD *)float v61 = 925353388;
  }
LABEL_46:
  if (v65 <= v66)
  {
    uint64_t v80 = (v66 - v65 + 1);
    float v81 = &v40[12 * v48 + 528 + 8 * v51 + 8 * v53 + 4 * v65 + 4 * v43 + 4 * (uint64_t)v41];
    do
    {
      int v82 = *(_DWORD *)v81;
      v81 += 4;
      *v62++ = v82;
      --v80;
    }
    while (v80);
  }
}

void sub_1000359C8(float32x4_t *a1, float32x4_t *a2, float32x4_t *a3, int a4, int a5, float *a6, FFTSetup *a7, const DSPSplitComplex *a8)
{
  sub_100035368(a1, a3, a2, a4);
  if (a4 >= 0) {
    int v14 = a4;
  }
  else {
    int v14 = a4 + 1;
  }
  int v15 = v14 >> 1;
  vDSP_ctoz((const DSPComplex *)a2, 2, a8, 1, (uint64_t)v14 >> 1);
  vDSP_fft_zrip(*a7, a8, 1, a5, 1);
  imagp = a8->imagp;
  a8->realp[v15] = *imagp;
  imagp[v15] = 0.0;
  float *imagp = 0.0;

  vDSP_zvabs(a8, 1, a6, 1, v15 + 1);
}

uint64_t sub_100035A90(uint64_t a1, FFTSetup *a2, const float *__A, const float *__B, uint64_t a5, float a6)
{
  float v362 = 0.0;
  uint64_t v360 = 0;
  uint64_t v361 = 0;
  uint64_t v359 = 0;
  float v358 = 0.0;
  float v354 = 0.0;
  unint64_t v353 = 0;
  unint64_t v351 = 0;
  if (*(void *)(a1 + 72))
  {
    if (*(void *)(a1 + 232))
    {
      int v8 = *(float **)(a1 + 240);
      if (v8)
      {
        if (*(void *)(a1 + 248)
          && *(void *)(a1 + 256)
          && *(void *)(a1 + 280)
          && *(void *)(a1 + 288)
          && *(void *)(a1 + 216)
          && *(void *)(a1 + 224)
          && *(void *)(a1 + 344)
          && *(void *)(a1 + 352)
          && *(void *)(a1 + 296)
          && *(void *)(a1 + 304)
          && *(void *)(a1 + 320)
          && *(void *)(a1 + 312))
        {
          uint64_t v12 = 0;
          int v13 = *a2;
          float v14 = *(float *)(a1 + 708);
          float v15 = *(float *)(a1 + 712);
          do
          {
            if (!*(void *)(a1 + v12 + 80) || !*(void *)(a1 + v12 + 144)) {
              return 1;
            }
            v12 += 8;
          }
          while (v12 != 64);
          uint64_t __C = 0;
          vDSP_Length __N = 0;
          vDSP_Length v365 = 0;
          vDSP_Length __I = 0;
          unint64_t v364 = 0;
          float v363 = 0.0;
          float v357 = 0.0;
          uint64_t v356 = 0;
          float v355 = 0.0;
          float __Ba = 0.0;
          if (__A && __B && a5 && *(_DWORD *)(a1 + 12) == 4096)
          {
            float v338 = v15;
            float v343 = v14;
            float v16 = (float)*(int *)(a1 + 60);
            float __Ba = -*(float *)(a1 + 24);
            float v17 = 16000.0 / v16;
            if (*(_WORD *)a1)
            {
              int v268 = 1;
              vDSP_vsub(__B, 1, __A, 1, v8, 1, 0x1000uLL);
              vDSP_vsadd(__A, 1, &__Ba, *(float **)(a1 + 256), 1, *(int *)(a1 + 12));
            }
            else
            {
              vDSP_vsadd(__A, 1, &__Ba, v8, 1, 0x1000uLL);
              int v268 = 0;
            }
            float v18 = sub_1000353E0(*(float **)(a1 + 240), *(float **)(a1 + 232), *(_DWORD *)(a1 + 12), 10);
            sub_1000359C8(*(float32x4_t **)(a1 + 240), *(float32x4_t **)(a1 + 232), *(float32x4_t **)(a1 + 72), *(_DWORD *)(a1 + 12), *(_DWORD *)(a1 + 16), *(float **)(a1 + 280), a2, (const DSPSplitComplex *)(a1 + 264));
            int v19 = *(_DWORD *)(a1 + 12);
            if (v19 >= 0) {
              int v20 = *(_DWORD *)(a1 + 12);
            }
            else {
              int v20 = v19 + 1;
            }
            uint64x2_t v21 = *(const float **)(a1 + 280);
            uint64_t v22 = ((v20 >> 1) + 1);
            if (v19 >= -1)
            {
              uint64_t v23 = v22;
              uint64_t v24 = *(float **)(a1 + 280);
              do
              {
                float v25 = *v24;
                if (*v24 < 0.00001) {
                  float v25 = 0.00001;
                }
                *v24++ = v25;
                --v23;
              }
              while (v23);
            }
            HIDWORD(__N) = v22;
            vvlogf(*(float **)(a1 + 288), v21, (const int *)&__N + 1);
            int v26 = *(_DWORD *)(a1 + 12);
            if (v26 >= 0) {
              int v27 = *(_DWORD *)(a1 + 12);
            }
            else {
              int v27 = v26 + 1;
            }
            int v28 = v27 >> 1;
            if (v26 >= -1)
            {
              float v33 = *(float **)(a1 + 216);
              uint64_t v34 = *(float **)(a1 + 8 * *(int *)(a1 + 208) + 80);
              float v35 = *(float **)(a1 + 280);
              unsigned int v30 = v28 + 1;
              uint64_t v36 = v30;
              uint64_t v37 = v30;
              do
              {
                float v38 = *v34++;
                float v39 = *v33 - v38;
                float v40 = *v35++;
                *v33++ = v39 + v40;
                --v37;
              }
              while (v37);
              int v41 = *(float **)(a1 + 224);
              uint64_t v29 = *(int *)(a1 + 208);
              size_t v42 = *(float **)(a1 + 8 * v29 + 144);
              int v43 = *(float **)(a1 + 288);
              do
              {
                float v44 = *v42++;
                float v45 = *v41 - v44;
                float v46 = *v43++;
                *v41++ = v45 + v46;
                --v36;
              }
              while (v36);
            }
            else
            {
              uint64_t v29 = *(int *)(a1 + 208);
              unsigned int v30 = v28 + 1;
            }
            double v47 = (float)(v17 * 5.0) + 0.5;
            memcpy(*(void **)(a1 + 8 * v29 + 80), *(const void **)(a1 + 280), 4 * (int)v30);
            memcpy(*(void **)(a1 + 8 * *(int *)(a1 + 208) + 144), *(const void **)(a1 + 288), 4 * (*(_DWORD *)(a1 + 12) / 2 + 1));
            unint64_t v48 = *(int *)(a1 + 32);
            *(_DWORD *)(a1 + 208) = (*(_DWORD *)(a1 + 208) + 1) % (int)v48;
            if (*(void *)(a1 + 696) >= v48)
            {
              int v49 = *(_DWORD *)(a1 + 12);
              if (v49 >= -1)
              {
                int v50 = v49 / 2;
                uint64_t v51 = *(float **)(a1 + 216);
                float v52 = (float)(int)v48;
                int v53 = *(float **)(a1 + 280);
                uint64_t v54 = (v50 + 1);
                uint64_t v55 = v54;
                do
                {
                  float v56 = *v51++;
                  *v53++ = v56 / v52;
                  --v55;
                }
                while (v55);
                BOOL v57 = *(float **)(a1 + 224);
                uint64_t v58 = *(float **)(a1 + 288);
                do
                {
                  float v59 = *v57++;
                  *v58++ = v59 / v52;
                  --v54;
                }
                while (v54);
              }
            }
            uint64_t v60 = (int)v47;
            if (v268)
            {
              sub_1000359C8(*(float32x4_t **)(a1 + 256), *(float32x4_t **)(a1 + 232), *(float32x4_t **)(a1 + 72), *(_DWORD *)(a1 + 12), *(_DWORD *)(a1 + 16), *(float **)(a1 + 240), a2, (const DSPSplitComplex *)(a1 + 264));
              int v61 = *(_DWORD *)(a1 + 12);
              float v62 = *(float **)(a1 + 240);
              if (v61 >= -1)
              {
                if (v61 >= 0) {
                  int v63 = *(_DWORD *)(a1 + 12);
                }
                else {
                  int v63 = v61 + 1;
                }
                uint64_t v64 = ((v63 >> 1) + 1);
                int v65 = *(float **)(a1 + 240);
                do
                {
                  float v66 = *v65;
                  if (*v65 < 0.00001) {
                    float v66 = 0.00001;
                  }
                  *v65++ = v66;
                  --v64;
                }
                while (v64);
              }
              float v341 = (float)((float)((float)((float)(v62[1] * v62[1]) + (float)(*v62 * *v62)) + (float)(v62[2] * v62[2]))
                           + (float)(v62[3] * v62[3]))
                   + (float)(v62[4] * v62[4]);
            }
            else
            {
              uint64_t v67 = *(float **)(a1 + 280);
              float v341 = (float)((float)((float)((float)(v67[1] * v67[1]) + (float)(*v67 * *v67)) + (float)(v67[2] * v67[2]))
                           + (float)(v67[3] * v67[3]))
                   + (float)(v67[4] * v67[4]);
              float v62 = *(float **)(a1 + 240);
              int v61 = *(_DWORD *)(a1 + 12);
            }
            float __Ba = -*(float *)(a1 + 28);
            vDSP_vsadd(__B, 1, &__Ba, v62, 1, v61);
            sub_1000359C8(*(float32x4_t **)(a1 + 240), *(float32x4_t **)(a1 + 232), *(float32x4_t **)(a1 + 72), *(_DWORD *)(a1 + 12), *(_DWORD *)(a1 + 16), *(float **)(a1 + 248), a2, (const DSPSplitComplex *)(a1 + 264));
            if (a6 == 0.0)
            {
              *(_DWORD *)(a5 + 20) = 1120403456;
              *(_DWORD *)(a5 + 32) = 0;
              int v73 = HIDWORD(__N);
            }
            else
            {
              if (a6 == 30.0 || a6 == 15.0) {
                int v70 = 1;
              }
              else {
                int v70 = 2;
              }
              if (a6 == 8.0 || a6 == 1.0) {
                int v72 = 0;
              }
              else {
                int v72 = v70;
              }
              int v73 = HIDWORD(__N);
              uint64x2_t v68 = *(float **)(a1 + 248);
              sub_100034C44(v72, (uint64_t)v68, SHIDWORD(__N), *(_DWORD *)(a1 + 60), (float *)(a5 + 20), a6, (float)((float)((float)((float)(v68[1] * v68[1]) + (float)(*v68 * *v68)) + (float)(v68[2] * v68[2]))+ (float)(v68[3] * v68[3]))+ (float)(v68[4] * v68[4]), (float)*(int *)(a1 + 56));
              LODWORD(v369[0]) = 0;
              int v74 = *(_DWORD *)(a1 + 64);
              int32x2_t v75 = *(float **)(a1 + 248);
              if (v74 >= -1) {
                bzero(*(void **)(a1 + 248), 4 * (v74 + 1) + 4);
              }
              sub_100034EFC((int)v47, v75, v73, *(_DWORD *)(a1 + 60), (float *)v369, 120.0);
              *(_DWORD *)(a5 + 32) = v369[0];
            }
            sub_100034A54(*(const float **)(a1 + 288), v73, *(_DWORD *)(a1 + 336), *(void *)(a1 + 352), *(void *)(a1 + 344));
            uint64_t v76 = *(unsigned int *)(a1 + 336);
            if ((int)v76 >= 1)
            {
              int v77 = 0;
              float v79 = *(_DWORD **)(a1 + 344);
              uint64_t v78 = *(int **)(a1 + 352);
              uint64_t v80 = v78;
              uint64_t v81 = *(unsigned int *)(a1 + 336);
              do
              {
                int v82 = *v80++;
                v77 += v82;
                --v81;
              }
              while (v81);
              int v83 = 0;
              while (1)
              {
                int v84 = *v78++;
                v83 += v84;
                if ((float)(*(float *)(a1 + 44) * (float)v77) <= (float)v83) {
                  break;
                }
                ++v79;
                if (!--v76) {
                  goto LABEL_91;
                }
              }
              LODWORD(__N) = *v79;
            }
LABEL_91:
            int v85 = HIDWORD(__N);
            uint64_t v86 = SHIDWORD(__N);
            float v87 = *(char **)(a1 + 288);
            if (SHIDWORD(__N) < 1)
            {
              int v89 = 0;
              float v91 = 0.0;
            }
            else
            {
              uint64_t v88 = 0;
              int v89 = 0;
              uint64_t v90 = 4 * HIDWORD(__N);
              float v91 = 0.0;
              do
              {
                if (*(float *)&v87[v88] < *(float *)&__N)
                {
                  float v91 = v91 + (float)(*(float *)(*(void *)(a1 + 280) + v88) * *(float *)(*(void *)(a1 + 280) + v88));
                  ++v89;
                  *(_DWORD *)&v87[v88] = __N;
                }
                v88 += 4;
              }
              while (v90 != v88);
            }
            int __Ab = v89;
            memcpy(*(void **)(a1 + 248), v87, 4 * v86);
            if (*(_DWORD *)(a1 + 52) && SHIDWORD(__N) >= 3)
            {
              uint64_t v92 = 0;
              uint64_t v93 = *(void *)(a1 + 248);
              uint64_t v94 = 4 * (HIDWORD(__N) - 1) - 4;
              do
              {
                if (*(float *)(v93 + v92) == *(float *)&__N && *(float *)(v93 + v92 + 8) == *(float *)&__N) {
                  *(_DWORD *)(*(void *)(a1 + 288) + v92 + 4) = __N;
                }
                v92 += 4;
              }
              while (v94 != v92);
            }
            int v95 = *(_DWORD *)(a1 + 64);
            int v96 = *(const void **)(a1 + 288);
            if (v95 >= -1)
            {
              long long v97 = *(_DWORD **)(a1 + 280);
              uint64_t v98 = (v95 + 2);
              uint64_t v99 = *(_DWORD **)(a1 + 288);
              do
              {
                *v97++ = 0;
                *v99++ = __N;
                --v98;
              }
              while (v98);
            }
            *(float *)&vDSP_Length __N = -*(float *)&__N;
            memcpy(*(void **)(a1 + 248), v96, 4 * SHIDWORD(__N));
            vDSP_vsadd(*(const float **)(a1 + 248), 1, (const float *)&__N, *(float **)(a1 + 288), 1, SHIDWORD(__N));
            vDSP_maxvi(*(const float **)(a1 + 280), 1, (float *)&__C + 1, &__I, SHIDWORD(__N));
            long long v100 = *(const void **)(a1 + 280);
            BOOL v340 = 0;
            if (__I >= 2)
            {
              vDSP_Length v101 = (vDSP_Length)v100 + 4 * __I;
              if (*(float *)(v101 - 4) == 0.0 && *(float *)(v101 - 8) == 0.0) {
                BOOL v340 = 1;
              }
            }
            int v102 = (int)(float)((float)(4100.0 / (float)(*(_DWORD *)(a1 + 60) / 2)) * (float)(*(_DWORD *)(a1 + 12) / 2));
            memcpy(*(void **)(a1 + 248), v100, 4 * SHIDWORD(__N));
            vDSP_Length v103 = SHIDWORD(__N);
            uint64_t v104 = *(const float **)(a1 + 248);
            if (SHIDWORD(__N) >= v102) {
              bzero((void *)&v104[v102 - 1], 4 * (HIDWORD(__N) - v102) + 4);
            }
            vDSP_maxvi(v104, 1, (float *)&__C + 1, &__I, v103);
            int v105 = *(_DWORD *)(a1 + 12);
            if (__I) {
              float v106 = (float)__I;
            }
            else {
              float v106 = 1.0;
            }
            if ((float)__I <= (float)(v105 >> 1)) {
              float v107 = v106;
            }
            else {
              float v107 = (float)(v105 >> 1);
            }
            unint64_t v108 = (unint64_t)v107;
            vDSP_Length __I = (unint64_t)v107;
            uint64_t v109 = (float *)(*(void *)(a1 + 280) + 4 * (unint64_t)v107);
            float v110 = sub_100037BF4(v109 - 1);
            float v111 = *v109 + (float)(v110 * (float)(*(v109 - 1) - v109[1])) * -0.25;
            *((float *)&__C + 1) = v111;
            float v112 = (float)v105;
            float v113 = (float)(v110 + (float)v108) * (float)*(unsigned int *)(a1 + 60);
            if ((int)v108 <= 5) {
              unsigned int v114 = 5;
            }
            else {
              unsigned int v114 = v108;
            }
            int v115 = v108 + 5;
            vDSP_Length v116 = SHIDWORD(__N);
            if ((int)v108 + 5 >= HIDWORD(__N) - 1) {
              int v115 = HIDWORD(__N) - 1;
            }
            unsigned int v117 = *(const float **)(a1 + 248);
            if ((int)(v114 - 5) <= v115) {
              bzero((void *)&v117[v114 - 5], 4 * (v115 - v114 + 5) + 4);
            }
            float v118 = v113 / v112;
            vDSP_maxvi(v117, 1, (float *)&__C, &v365, v116);
            uint64_t v119 = *(int *)(a1 + 12);
            if (v365) {
              float v120 = (float)v365;
            }
            else {
              float v120 = 1.0;
            }
            if ((float)v365 <= (float)((int)v119 >> 1)) {
              float v121 = v120;
            }
            else {
              float v121 = (float)((int)v119 >> 1);
            }
            unint64_t v122 = (unint64_t)v121;
            vDSP_Length v365 = (unint64_t)v121;
            long long v123 = (float *)(*(void *)(a1 + 280) + 4 * (unint64_t)v121);
            float v124 = sub_100037BF4(v123 - 1);
            float v125 = *v123 + (float)(v124 * (float)(*(v123 - 1) - v123[1])) * -0.25;
            *(float *)&uint64_t __C = v125;
            float v126 = (float)((float)(v124 + (float)v122) * (float)*(unsigned int *)(a1 + 60)) / (float)v119;
            if (vabds_f32(*(float *)(a1 + 680), v126) < 3.0 && *((float *)&__C + 1) * 0.95 < v125) {
              float v118 = v126;
            }
            long long v127 = *(const DSPComplex **)(a1 + 288);
            if (SHIDWORD(__N) < (int)v119)
            {
              uint64_t v128 = 4 * SHIDWORD(__N);
              uint64_t v129 = v119 - SHIDWORD(__N);
              do
              {
                *(float *)((char *)&v127->real + v128) = *(&v127->real + v129);
                v128 += 4;
                --v129;
              }
              while (v129);
            }
            if ((int)v119 >= 0) {
              int v130 = v119;
            }
            else {
              int v130 = v119 + 1;
            }
            vDSP_ctoz(v127, 2, (const DSPSplitComplex *)(a1 + 264), 1, (uint64_t)v130 >> 1);
            vDSP_fft_zrip(v13, (const DSPSplitComplex *)(a1 + 264), 1, *(int *)(a1 + 16), 1);
            long long v131 = *(const float **)(a1 + 264);
            long long v132 = *(const float **)(a1 + 272);
            int v133 = *(_DWORD *)(a1 + 12) / 2;
            v131[v133] = *v132;
            v132[v133] = 0.0;
            *long long v132 = 0.0;
            vDSP_vabs(v131, 1, *(float **)(a1 + 288), 1, v133 + 1);
            uint64_t v134 = *(int *)(a1 + 328);
            int v135 = *(_DWORD *)(a1 + 332);
            double v136 = *(float **)(a1 + 320);
            if ((int)v134 <= v135)
            {
              uint64_t v140 = 0;
              uint64_t v137 = (v135 - v134 + 1);
              uint64_t v141 = *(void *)(a1 + 288) + 4 * v134;
              do
              {
                v136[v140] = *(float *)(v141 + 4 * v140);
                ++v140;
              }
              while (v137 != v140);
              float v139 = *v136;
              if (v137)
              {
                uint64_t v142 = 0;
                int v138 = 0;
                do
                {
                  if (v139 < v136[v142])
                  {
                    int v138 = v142;
                    float v139 = v136[v142];
                  }
                  ++v142;
                }
                while (v137 != v142);
                char v143 = 0;
                goto LABEL_155;
              }
              int v138 = 0;
            }
            else
            {
              LODWORD(v137) = 0;
              int v138 = 0;
              float v139 = *v136;
            }
            char v143 = 1;
LABEL_155:
            float v144 = v17 * 7.0;
            *((float *)&__C + 1) = v139;
            uint64_t v145 = *(void *)(a1 + 312);
            float v146 = 1.0 / *(float *)(v145 + 4 * v138);
            if (v146 < 90.0) {
              float v146 = 90.0;
            }
            int v147 = *(_DWORD *)(a1 + 60);
            if (v147 >= 0) {
              int v148 = *(_DWORD *)(a1 + 60);
            }
            else {
              int v148 = v147 + 1;
            }
            int v149 = v148 >> 1;
            float v150 = (float)v149;
            if (v146 >= (float)v149) {
              float v146 = (float)v149;
            }
            *((float *)&v364 + 1) = v146;
            int v151 = sub_1000352CC(v145, v137, v138);
            unsigned int v152 = (v138 - v151) & ~((v138 - v151) >> 31);
            int v153 = v151 + v138;
            if (v151 + v138 >= (int)v137) {
              int v153 = v137;
            }
            BOOL v154 = __OFSUB__(v153, v152);
            int v155 = v153 - v152;
            if (v155 < 0 == v154) {
              bzero(&v136[v152], 4 * v155 + 4);
            }
            float v156 = *v136;
            if (v143)
            {
              int v157 = 0;
            }
            else
            {
              uint64_t v158 = 0;
              int v157 = 0;
              do
              {
                if (v156 < v136[v158])
                {
                  int v157 = v158;
                  float v156 = v136[v158];
                }
                ++v158;
              }
              while (v137 != v158);
            }
            double v159 = v144 + 0.5;
            *((float *)&__C + 1) = v156;
            float v160 = (float)(v139 - v156) / v139;
            BOOL v161 = v160 > 0.5 || v160 <= 0.0;
            float v162 = v160 + v160;
            if (v161) {
              float v162 = 1.0;
            }
            if (v160 >= 0.0) {
              float v163 = v162;
            }
            else {
              float v163 = 0.0;
            }
            if (v139 == 0.0) {
              float v163 = 1.0;
            }
            float v339 = v163;
            float v164 = 1.0 / *(float *)(v145 + 4 * v157);
            if (v164 < 90.0) {
              float v164 = 90.0;
            }
            if (v164 >= v150) {
              float v164 = v150;
            }
            *(float *)&unint64_t v364 = v164;
            int v165 = sub_1000352CC(v145, v137, v157);
            unsigned int v166 = (v157 - v165) & ~((v157 - v165) >> 31);
            int v167 = v165 + v157;
            if (v165 + v157 >= (int)v137) {
              int v167 = v137;
            }
            BOOL v154 = __OFSUB__(v167, v166);
            int v168 = v167 - v166;
            if (v168 < 0 == v154) {
              bzero(&v136[v166], 4 * v168 + 4);
            }
            int v342 = (int)v159;
            float v169 = *v136;
            if (v143)
            {
              int v170 = 0;
            }
            else
            {
              uint64_t v171 = 0;
              int v170 = 0;
              do
              {
                if (v169 < v136[v171])
                {
                  int v170 = v171;
                  float v169 = v136[v171];
                }
                ++v171;
              }
              while (v137 != v171);
            }
            uint64_t v172 = 0;
            float v346 = (float)(v91 * (float)v85) / (float)__Ab;
            *((float *)&__C + 1) = v169;
            float v173 = 1.0 / *(float *)(v145 + 4 * v170);
            if (v173 < 90.0) {
              float v173 = 90.0;
            }
            if (v173 >= v150) {
              float v173 = v150;
            }
            float v363 = v173;
            v369[0] = (char *)&v364 + 4;
            v369[1] = &v364;
            int v174 = *(_DWORD *)(a1 + 12);
            float v175 = (float)v174;
            float v176 = (float)v147;
            v369[2] = &v363;
            long long v177 = *(float **)(a1 + 280);
            do
            {
              uint64_t v178 = (float *)v369[v172];
              float v179 = (float)(*v178 * v175) / v176;
              double v180 = (float)(v179 + 2.0) + 0.5;
              uint64_t v181 = v180;
              uint64_t v182 = (float)(v179 + -2.0);
              if (v182 >= v181)
              {
                unsigned int v184 = v180;
              }
              else
              {
                float v183 = v177[v181];
                unsigned int v184 = v180;
                do
                {
                  if (v177[v182] > v183)
                  {
                    float v183 = v177[v182];
                    unsigned int v184 = v182;
                  }
                  ++v182;
                }
                while (v181 != v182);
              }
              *uint64_t v178 = (float)((float)(sub_100037BF4(&v177[v184 - 1]) + (float)v184) * v176) / v175;
              ++v172;
            }
            while (v172 != 3);
            for (int i = 1; i != 30; ++i)
            {
              float v186 = v118 / (float)i;
              float v187 = vabds_f32(*((float *)&v364 + 1), v186);
              BOOL v188 = v187 < 20.0;
              if (*((float *)&v364 + 1) <= 1000.0) {
                BOOL v188 = 0;
              }
              if (v187 < 6.0 || v188)
              {
                *((float *)&v364 + 1) = v118 / (float)i;
                goto LABEL_219;
              }
            }
            float v186 = *((float *)&v364 + 1);
LABEL_219:
            for (int j = 1; j != 30; ++j)
            {
              float v191 = v118 / (float)j;
              float v192 = vabds_f32(*(float *)&v364, v191);
              BOOL v193 = v192 < 20.0;
              if (*(float *)&v364 <= 1000.0) {
                BOOL v193 = 0;
              }
              if (v192 < 6.0 || v193)
              {
                *(float *)&unint64_t v364 = v118 / (float)j;
                goto LABEL_229;
              }
            }
            float v191 = *(float *)&v364;
LABEL_229:
            for (int k = 1; k != 30; ++k)
            {
              float v196 = v118 / (float)k;
              float v197 = vabds_f32(v363, v196);
              BOOL v198 = v197 < 20.0;
              if (v363 <= 1000.0) {
                BOOL v198 = 0;
              }
              if (v197 < 6.0 || v198)
              {
                float v363 = v118 / (float)k;
                goto LABEL_239;
              }
            }
            float v196 = v363;
LABEL_239:
            int v200 = HIDWORD(__N);
            sub_100034B4C(v60, (uint64_t)v177, SHIDWORD(__N), v147, &v362, v186, v346);
            sub_100034B4C(v60, (uint64_t)v177, v200, v147, (float *)&v361 + 1, v191, v346);
            sub_100034B4C(v60, (uint64_t)v177, v200, v147, (float *)&v361, v196, v346);
            sub_100034B4C(v60, (uint64_t)v177, v200, v147, (float *)&v360 + 1, v118, v346);
            sub_100034EFC(v60, v177, v200, v147, (float *)&v360, v186);
            sub_100034EFC(v60, v177, v200, v147, (float *)&v359 + 1, v191);
            sub_100034EFC(v60, v177, v200, v147, (float *)&v359, v196);
            sub_100034EFC(v60, v177, v200, v147, &v358, v118);
            uint64_t v201 = 0;
            *(float *)v370 = v118;
            *(float *)&v370[1] = v186;
            v369[0] = &v355;
            v369[1] = &v357;
            v369[2] = (char *)&v356 + 4;
            v369[3] = &v356;
            *(float *)&v370[2] = v191;
            *(float *)&v370[3] = v196;
            do
            {
              *(float *)v369[v201] = sub_100037C58(&v177[((float)((float)(*(float *)&v370[v201] * v175)
                                                                              / v176)
                                                                      + 0.5)
                                                       - 1]);
              ++v201;
            }
            while (v201 != 4);
            if (v174 >= -1)
            {
              if (v174 >= 0) {
                int v202 = v174;
              }
              else {
                int v202 = v174 + 1;
              }
              uint64_t v203 = ((v202 >> 1) + 1);
              v204 = v177;
              do
              {
                float v205 = *v204;
                if (*v204 < 0.00001) {
                  float v205 = 0.00001;
                }
                *v204++ = v205;
                --v203;
              }
              while (v203);
            }
            vvlogf(*(float **)(a1 + 288), v177, (const int *)&__N + 1);
            sub_100034A54(*(const float **)(a1 + 288), SHIDWORD(__N), *(_DWORD *)(a1 + 336), *(void *)(a1 + 352), *(void *)(a1 + 344));
            uint64_t v206 = *(unsigned int *)(a1 + 336);
            float v207 = 0.0;
            float v347 = 0.0;
            if ((int)v206 >= 1)
            {
              int v208 = 0;
              uint64_t v210 = *(float **)(a1 + 344);
              uint64_t v209 = *(int **)(a1 + 352);
              uint64_t v211 = v209;
              uint64_t v212 = *(unsigned int *)(a1 + 336);
              do
              {
                int v213 = *v211++;
                v208 += v213;
                --v212;
              }
              while (v212);
              int v214 = 0;
              while (1)
              {
                int v215 = *v209++;
                v214 += v215;
                if ((float)(*(float *)(a1 + 48) * (float)v208) <= (float)v214) {
                  break;
                }
                ++v210;
                if (!--v206)
                {
                  float v216 = 0.0;
                  goto LABEL_257;
                }
              }
              float v216 = *v210;
LABEL_257:
              float v347 = v216;
            }
            float v217 = *(float *)(a1 + 572);
            float v218 = *((float *)&v364 + 1);
            if (vabds_f32(v217, *((float *)&v364 + 1)) < 3.0) {
              float v207 = 0.2;
            }
            float v344 = v362;
            float v348 = *((float *)&v360 + 1);
            if ((float)(v362 + v207) < *((float *)&v360 + 1)) {
              goto LABEL_264;
            }
            float v219 = v357;
            float v220 = expf(v347);
            if (v220 <= (float)(v355 * 0.02)) {
              float v220 = v355 * 0.02;
            }
            if (v219 >= v220) {
              BOOL v221 = (float)(fabsf(v118 - (float)(roundf(v118 / v218) * v218)) / v218) >= 0.02;
            }
            else {
LABEL_264:
            }
              BOOL v221 = 1;
            float v222 = *(float *)&v364;
            float v223 = 0.2;
            if (vabds_f32(v217, *(float *)&v364) >= 3.0) {
              float v223 = 0.0;
            }
            float v345 = *((float *)&v361 + 1);
            if ((float)(*((float *)&v361 + 1) + v223) < v348) {
              goto LABEL_272;
            }
            float v224 = *((float *)&v356 + 1);
            float v225 = expf(v347);
            if (v225 <= (float)(v355 * 0.02)) {
              float v225 = v355 * 0.02;
            }
            if (v224 >= v225) {
              BOOL v226 = (float)(fabsf(v118 - (float)(roundf(v118 / v222) * v222)) / v222) >= 0.02;
            }
            else {
LABEL_272:
            }
              BOOL v226 = 1;
            LODWORD(v227) = v361;
            float v228 = v363;
            float v229 = 0.2;
            if (vabds_f32(v217, v363) >= 3.0) {
              float v229 = 0.0;
            }
            if ((float)(*(float *)&v361 + v229) < v348) {
              goto LABEL_280;
            }
            float v230 = *(float *)&v356;
            float v231 = expf(v347);
            if (v231 <= (float)(v355 * 0.02)) {
              float v231 = v355 * 0.02;
            }
            if (v230 >= v231)
            {
              double v267 = (float)(fabsf(v118 - (float)(roundf(v118 / v228) * v228)) / v228);
              float v232 = 0.0;
              if (v221) {
                float v233 = 0.0;
              }
              else {
                float v233 = v218;
              }
              if (!v226) {
                float v232 = v222;
              }
              if (v267 < 0.02)
              {
LABEL_286:
                float v234 = 0.0;
                if (fabs(v233 + -111.1) <= 1.0) {
                  float v233 = 0.0;
                }
                double v235 = fabs(v233 + -111.1);
                if (v235 > 1.0) {
                  float v236 = v232;
                }
                else {
                  float v236 = 0.0;
                }
                unint64_t v364 = __PAIR64__(LODWORD(v233), LODWORD(v236));
                if (v235 > 1.0) {
                  float v237 = v228;
                }
                else {
                  float v237 = 0.0;
                }
                float v363 = v237;
                if (v236 <= v237) {
                  float v238 = v237;
                }
                else {
                  float v238 = v236;
                }
                if (v233 <= v238)
                {
                  BOOL v240 = 0;
                }
                else
                {
                  float v239 = v345;
                  if (v345 <= v227) {
                    float v239 = v227;
                  }
                  if (vabds_f32(v217, v233) >= 3.0) {
                    float v234 = 0.2;
                  }
                  BOOL v240 = v344 > (float)(v239 + v234);
                }
                if (v233 <= v237) {
                  float v241 = v237;
                }
                else {
                  float v241 = v233;
                }
                if (v236 <= v241)
                {
                  BOOL v244 = 0;
                }
                else
                {
                  float v242 = v344;
                  if (v344 <= v227) {
                    float v242 = v227;
                  }
                  float v243 = 0.0;
                  if (vabds_f32(v217, v236) >= 3.0) {
                    float v243 = 0.2;
                  }
                  BOOL v244 = v345 > (float)(v242 + v243);
                }
                if (v233 <= v236) {
                  float v245 = v236;
                }
                else {
                  float v245 = v233;
                }
                if (v237 <= v245)
                {
                  BOOL v248 = 0;
                }
                else
                {
                  float v246 = v344;
                  if (v344 <= v345) {
                    float v246 = v345;
                  }
                  float v247 = 0.0;
                  if (vabds_f32(v217, v237) >= 3.0) {
                    float v247 = 0.2;
                  }
                  BOOL v248 = v227 > (float)(v246 + v247);
                }
                if (v233 >= v236
                  || (float v249 = vabds_f32(v217, v236), v339 >= flt_1000827B0[v249 < 3.0])
                  || *((float *)&v356 + 1) <= (float)(flt_1000827B8[v249 < 3.0] * v357))
                {
                  BOOL v251 = 0;
                }
                else
                {
                  BOOL v264 = v249 < 3.0;
                  float v250 = 0.0;
                  if (v264) {
                    float v250 = 0.5;
                  }
                  BOOL v251 = (float)(v345 + v250) > v344;
                }
                if (v236 >= v237
                  || (float v252 = vabds_f32(v217, v237), v339 >= flt_1000827B0[v252 < 3.0])
                  || *(float *)&v356 <= (float)(flt_1000827B8[v252 < 3.0] * *((float *)&v356 + 1)))
                {
                  BOOL v254 = 0;
                }
                else
                {
                  BOOL v264 = v252 < 3.0;
                  float v253 = 0.0;
                  if (v264) {
                    float v253 = 0.5;
                  }
                  BOOL v254 = (float)(v227 + v253) > v345;
                }
                if (v237 == 0.0 && v233 == 0.0 && v236 == 0.0)
                {
                  unint64_t v353 = __PAIR64__(LODWORD(v358), LODWORD(v348));
                  int v255 = HIDWORD(__N);
                  float v256 = v355;
                  double v257 = (float)(v355 * 0.3);
                  float v258 = expf(v347);
                  if (v258 * 1.2 >= v257) {
                    double v257 = v258 * 1.2;
                  }
                  if ((float)(v256 * 0.2) <= v258) {
                    float v259 = v258;
                  }
                  else {
                    float v259 = v256 * 0.2;
                  }
                  int v260 = 31;
                  while (1)
                  {
                    float v236 = v118 / (float)--v260;
                    if (v236 >= 90.0)
                    {
                      int v261 = *(float **)(a1 + 280);
                      int v262 = *(_DWORD *)(a1 + 60);
                      sub_10003524C((uint64_t)v261, v255, v262, &v354, v118 / (float)v260);
                      float v263 = vabds_f32(v236, v217);
                      BOOL v264 = v263 > 3.0 && v257 < v354;
                      if (v264) {
                        break;
                      }
                      if (v263 <= 3.0 && v354 > v259) {
                        break;
                      }
                    }
                    if (v260 <= 2)
                    {
                      float v236 = v118;
                      goto LABEL_383;
                    }
                  }
                  sub_100034B4C(v60, (uint64_t)v261, v255, v262, (float *)&v353, v118 / (float)v260, v346);
                  sub_100034EFC(v60, v261, v255, v262, (float *)&v353 + 1, v118 / (float)v260);
LABEL_383:
                  int v270 = 1;
                  while (1)
                  {
                    float v271 = v118 / (float)v270;
                    if (vabds_f32(v236, v271) < 5.0) {
                      break;
                    }
                    if (++v270 == 31)
                    {
                      float v271 = v236;
                      break;
                    }
                  }
                  float v272 = fabsf(v271 + -100.0);
                  float v273 = fabsf(v271 + -120.0);
                  float v274 = *((float *)&v353 + 1);
                  if (v271 < 140.0 && v272 > 1.5 && v273 > 1.5 && *((float *)&v353 + 1) < 0.75)
                  {
                    if (v118 >= 140.0)
                    {
                      float v274 = v358;
                      unint64_t v353 = __PAIR64__(LODWORD(v358), LODWORD(v348));
                      float v271 = v118;
                    }
                    else
                    {
                      float v278 = 0.0;
                      if (*(float *)&v353 >= 0.5)
                      {
                        float v278 = 1.0;
                        if (*(float *)&v353 > 0.5 && *(float *)&v353 <= 0.75) {
                          float v278 = (float)(*(float *)&v353 + -0.5) * 4.0;
                        }
                      }
                      float v274 = *((float *)&v353 + 1) * v278;
                      *(float *)&unint64_t v353 = *(float *)&v353 * v278;
                      *((float *)&v353 + 1) = *((float *)&v353 + 1) * v278;
                    }
                  }
                  uint64_t v279 = *(float **)(a1 + 280);
                  int v280 = HIDWORD(__N);
                  int v281 = *(_DWORD *)(a1 + 60);
                  sub_100034EFC(v60, v279, SHIDWORD(__N), v281, (float *)&v351 + 1, v217);
                  sub_100034B4C(v60, (uint64_t)v279, v280, v281, (float *)&v351, v217, v346);
                  if (*(float *)(a1 + 688) > 0.0
                    && vabds_f32(v217, *(float *)(a1 + 684)) < 2.0
                    && *((float *)&v351 + 1) > (float)(v274 * 5.0)
                    && *(int *)(a1 + 564) >= 19)
                  {
                    unint64_t v353 = v351;
                    float v274 = *((float *)&v351 + 1);
                    float v271 = v217;
                  }
                  if ((float)(fabsf(v217 - (float)(roundf(v217 / v271) * v271)) / v271) < 0.02)
                  {
                    BOOL v282 = 0;
                    if (v217 <= (float)(v271 + 10.0) || *((float *)&v351 + 1) <= 0.4)
                    {
LABEL_416:
                      BOOL v283 = (float)(fabsf(v271 - (float)(roundf(v271 / v217) * v217)) / v217) < 0.02
                          && v271 * 0.9 > v217
                          && *((float *)&v351 + 1) > 0.4
                          && *((float *)&v351 + 1) * 0.7 > v274
                          && *(_DWORD *)(a1 + 564) > 9;
                      int v284 = 1;
                      while (2)
                      {
                        float v285 = (float)v284;
                        for (int m = 1; m != 20; ++m)
                        {
                          if (fabsf((float)(v271 * v285) - (float)((float)m * v217)) < 0.1)
                          {
                            float v287 = v271 * v285;
                            goto LABEL_429;
                          }
                        }
                        if (++v284 != 20) {
                          continue;
                        }
                        break;
                      }
                      float v287 = 0.0;
LABEL_429:
                      BOOL v288 = vabds_f32(v287, v118) < 0.01
                          && *((float *)&v351 + 1) > 0.4
                          && vabds_f32(*((float *)&v351 + 1), v274) < 0.05
                          && *(_DWORD *)(a1 + 564) > 9;
                      if (v282 || v283 || v288)
                      {
                        uint64_t v290 = 0;
                        while (vabds_f32(v271, *(float *)(a1 + 576 + v290)) <= 3.0)
                        {
                          v290 += 4;
                          if (v290 == 32)
                          {
                            float v289 = v271;
                            if (!v288) {
                              goto LABEL_442;
                            }
                            break;
                          }
                        }
                        float v274 = *((float *)&v351 + 1);
                        HIDWORD(v353) = HIDWORD(v351);
                        float v289 = v217;
                      }
                      else
                      {
                        float v289 = v271;
                      }
LABEL_442:
                      *(_OWORD *)(a1 + 576) = *(_OWORD *)(a1 + 580);
                      *(void *)(a1 + 592) = *(void *)(a1 + 596);
                      *(_DWORD *)(a1 + 600) = *(_DWORD *)(a1 + 604);
                      *(float *)(a1 + 604) = v271;
                      memmove((void *)(a1 + 608), (const void *)(a1 + 612), 0x44uLL);
                      *(float *)(a1 + 676) = v271;
                      if (v289 <= 90.0 || fabsf(v289 + -5333.0) <= 4.0)
                      {
                        if (v217 <= 90.0 || fabsf(v217 + -5333.0) <= 4.0)
                        {
                          unint64_t v353 = 0;
                          float v274 = 0.0;
                          float v289 = 120.0;
                        }
                        else
                        {
                          float v274 = *((float *)&v351 + 1);
                          unint64_t v353 = v351;
                          float v289 = v217;
                        }
                      }
                      BOOL v291 = *(_DWORD *)(a5 + 28) != 1 && v340;
                      if (v291)
                      {
                        HIDWORD(v353) = 0;
                        float v274 = 0.0;
                      }
                      *(float *)(a5 + 8) = v274;
                      *(float *)a5 = v289;
                      v292 = (_DWORD *)(a5 + 16);
                      sub_100034C44(v342, (uint64_t)v279, v280, v281, (float *)(a5 + 16), v289, v341, (float)*(int *)(a1 + 56));
                      float v293 = *(float *)a5;
                      sub_100034D54(v60, *(float **)(a1 + 280), v280, *(_DWORD *)(a1 + 60), (float *)&v353 + 1, *(float *)a5);
                      float v294 = *(float *)(a5 + 16);
                      float v295 = 0.0;
                      if (v294 >= 65.0)
                      {
                        float v295 = 1.0;
                        if (v294 > 65.0 && v294 <= 70.0) {
                          float v295 = (float)(v294 + -65.0) / 5.0;
                        }
                      }
                      *(float *)(a5 + 8) = (float)(v295 * *((float *)&v353 + 1))
                                         + (float)((float)(1.0 - v295) * *(float *)(a5 + 8));
                      uint64_t v296 = *(int *)(a1 + 360);
                      *(float *)(a1 + 368 + 4 * v296) = v293;
                      v297 = (float *)(a1 + 440);
                      *(float *)(a1 + 440 + 4 * v296) = v18;
                      v298 = (float *)(a1 + 476);
                      uint64_t v299 = *(int *)(a1 + 364);
                      v300 = (_DWORD *)(a1 + 476 + 4 * v299);
                      _DWORD *v300 = 0;
                      if (*(void *)(a1 + 696)) {
                        _DWORD *v300 = *v292;
                      }
                      long long v301 = *(_OWORD *)(a1 + 420);
                      *(_OWORD *)v369 = *(_OWORD *)(a1 + 404);
                      *(_OWORD *)&v369[2] = v301;
                      LODWORD(v369[4]) = *(_DWORD *)(a1 + 436);
                      long long v302 = *(_OWORD *)((char *)&v369[2] + 4);
                      *(_OWORD *)(a1 + 404) = *(_OWORD *)((char *)v369 + 4);
                      *(_OWORD *)(a1 + 420) = v302;
                      *(_DWORD *)(a1 + 436) = *(_DWORD *)(a5 + 8);
                      *(_DWORD *)(a1 + 360) = ((int)v296 + 1) % 9;
                      *(_DWORD *)(a1 + 364) = ((int)v299 + 1) % 22;
                      int v303 = (*(_DWORD *)(a1 + 564) + 1) % 0xFFFFFFF;
                      *(_DWORD *)(a1 + 564) = v303;
                      if (v303 > 8)
                      {
                        long long v306 = *(_OWORD *)(a1 + 384);
                        *(_OWORD *)v369 = *(_OWORD *)(a1 + 368);
                        *(_OWORD *)&v369[2] = v306;
                        LODWORD(v369[4]) = *(_DWORD *)(a1 + 400);
                        *(float *)(a5 + 4) = sub_1000351B0((uint64_t)v369, 9);
                        long long v307 = *(_OWORD *)(a1 + 420);
                        *(_OWORD *)v369 = *(_OWORD *)(a1 + 404);
                        *(_OWORD *)&v369[2] = v307;
                        LODWORD(v369[4]) = *(_DWORD *)(a1 + 436);
                        *(_DWORD *)(a5 + 12) = 0;
                        float v305 = 0.0;
                        if (!v291)
                        {
                          float v305 = sub_1000351B0((uint64_t)v369, 9);
                          *(float *)(a5 + 12) = v305;
                        }
                        float v308 = *(float *)(a1 + 572);
                        if (v308 <= *(float *)a5) {
                          float v309 = *(float *)a5;
                        }
                        else {
                          float v309 = *(float *)(a1 + 572);
                        }
                        if (v308 >= *(float *)a5) {
                          float v308 = *(float *)a5;
                        }
                        if ((float)(fabsf(v309 - (float)(roundf(v309 / v308) * v308)) / v308) >= 0.02
                          && *(float *)(a5 + 8) > 0.7)
                        {
                          *(_DWORD *)(a5 + 4) = *(_DWORD *)a5;
                          *(_DWORD *)(a1 + 564) = 0;
                          *(_DWORD *)(a1 + 688) = 0;
                        }
                        uint64_t v310 = 0;
                        LOBYTE(v304) = 1;
                        do
                        {
                          BOOL v304 = v304 && *(float *)(a1 + v310 + 408) > *(float *)(a1 + v310 + 404);
                          v310 += 4;
                        }
                        while (v310 != 32);
                        uint64_t v311 = 0;
                        float v18 = *v297;
                        do
                        {
                          if (v18 < v297[v311]) {
                            float v18 = v297[v311];
                          }
                          ++v311;
                        }
                        while (v311 != 9);
                        int v303 = *(_DWORD *)(a1 + 564);
                        if (v303 > 21)
                        {
                          uint64_t v313 = 0;
                          float v312 = *v298;
                          do
                          {
                            if (v312 < v298[v313]) {
                              float v312 = v298[v313];
                            }
                            ++v313;
                          }
                          while (v313 != 22);
LABEL_486:
                          *(float *)(a5 + 24) = v312;
                          float v314 = 0.0;
                          if (v18 >= v343)
                          {
                            BOOL v315 = v343 >= v18 || v18 > v338;
                            float v314 = (float)(v18 - v343) / (float)(v338 - v343);
                            if (v315) {
                              float v314 = 1.0;
                            }
                          }
                          float v316 = *(float *)(a5 + 8);
                          if (v316 < 0.8 && *(_DWORD *)(a5 + 28) != 1)
                          {
                            float v317 = 1.0 - v314;
                            float v316 = v316 * v317;
                            float v305 = v317 * v305;
                            *(float *)(a5 + 8) = v316;
                            *(float *)(a5 + 12) = v305;
                          }
                          *(float *)(a1 + 680) = v118;
                          float v318 = *(float *)(a5 + 4);
                          *(float *)(a1 + 572) = v318;
                          *(float *)(a1 + 704) = v305;
                          if (v312 >= 30.0)
                          {
                            if (v312 <= 70.0) {
                              float v319 = (float)(v312 * 0.0067) + 0.1333;
                            }
                            else {
                              float v319 = 0.6;
                            }
                          }
                          else
                          {
                            float v319 = 0.3333;
                          }
                          float v320 = v319 * 0.6;
                          if (!v304) {
                            float v320 = v319;
                          }
                          float v321 = (float)(v305 + -0.5) * 10.0;
                          if (v321 >= 0.0) {
                            float v322 = v321 + 65.0;
                          }
                          else {
                            float v322 = 65.0;
                          }
                          int v323 = *(_DWORD *)(a5 + 28);
                          *(_DWORD *)(a1 + 692) = v323;
                          if (v323 != 3)
                          {
                            if (v323 == 1)
                            {
                              float v326 = v320 + -0.2;
                              float v327 = 0.3333;
                              if (v326 >= 0.3333) {
                                float v327 = v326;
                              }
                              if (v305 < 0.1533 || (v305 < v327 ? (BOOL v328 = v312 < v322) : (BOOL v328 = 0), !v328))
                              {
                                int v324 = 0;
                                int v325 = 3;
                                if (v312 < v322 && v305 >= 0.1533)
                                {
                                  int v324 = 1;
                                  goto LABEL_529;
                                }
LABEL_528:
                                *(_DWORD *)(a5 + 28) = v325;
LABEL_529:
                                if (vabds_f32(*(float *)(a1 + 608), v271) <= 0.5)
                                {
                                  unint64_t v330 = 0;
                                  do
                                  {
                                    unint64_t v331 = v330;
                                    if (v330 == 16) {
                                      break;
                                    }
                                    float v332 = vabds_f32(*(float *)(a1 + 612 + 4 * v330++), v271);
                                  }
                                  while (v332 <= 0.5);
                                  BOOL v329 = v331 > 0xF;
                                }
                                else
                                {
                                  BOOL v329 = 0;
                                }
                                BOOL v333 = v305 <= 0.8 || v303 <= 8;
                                int v334 = v324 & v329;
                                if (!v333) {
                                  int v334 = 1;
                                }
                                if (v334 == 1 && v323 == 1)
                                {
                                  *(float *)(a1 + 684) = v318;
                                  *(float *)(a1 + 688) = v305;
                                }
                                if (!*(_DWORD *)(a1 + 568)) {
                                  *(_DWORD *)(a1 + 568) = 1;
                                }
                                unint64_t v336 = *(void *)(a1 + 696);
                                if (v336 >= 4) {
                                  LOBYTE(v324) = 0;
                                }
                                BOOL v337 = v318 == 120.0;
                                if (v305 != 0.0) {
                                  BOOL v337 = 0;
                                }
                                if ((v324 & 1) != 0 || v337) {
                                  *(_DWORD *)(a5 + 28) = 0;
                                }
                                uint64_t result = 0;
                                *(void *)(a1 + 696) = v336 + 1;
                                return result;
                              }
                            }
                            else if (!v323)
                            {
                              if (v305 <= v320 && (v305 <= 0.5 || v316 <= 0.5) || v312 >= v322)
                              {
                                int v324 = 0;
                                int v325 = 3;
                                if (v312 < v322 && v305 >= 0.1533) {
                                  goto LABEL_529;
                                }
                                goto LABEL_528;
                              }
LABEL_518:
                              int v325 = 1;
                              int v324 = 1;
                              goto LABEL_528;
                            }
                            int v325 = 0;
                            int v324 = 0;
                            goto LABEL_528;
                          }
                          int v324 = 0;
                          if (v312 >= (float)(v322 + -6.0) || v305 <= 0.2433) {
                            goto LABEL_529;
                          }
                          if (v305 <= v320)
                          {
                            int v325 = v316 > 0.5 && v305 > 0.8;
                            int v324 = v325;
                            goto LABEL_528;
                          }
                          goto LABEL_518;
                        }
                      }
                      else
                      {
                        BOOL v304 = 0;
                        *(_DWORD *)(a5 + 4) = *(_DWORD *)a5;
                        float v305 = *(float *)(a5 + 8);
                        *(float *)(a5 + 12) = v305;
                      }
                      float v312 = *(float *)v292;
                      goto LABEL_486;
                    }
                    if ((float)(*(float *)&v351 + 1.5) > *(float *)&v353)
                    {
                      BOOL v282 = *(_DWORD *)(a1 + 564) > 9;
                      goto LABEL_416;
                    }
                  }
                  BOOL v282 = 0;
                  goto LABEL_416;
                }
                if (v233 <= 0.0 || v236 <= 0.0 || v237 <= 0.0)
                {
                  if (v233 <= 0.0)
                  {
                    char v269 = v236 <= 0.0 || v254;
                    if (v269) {
                      goto LABEL_381;
                    }
                    goto LABEL_382;
                  }
                }
                else
                {
                  int v266 = v240 || v244;
                  if ((v266 | v248))
                  {
                    if (!v240)
                    {
                      if (!v266)
                      {
LABEL_381:
                        unint64_t v353 = __PAIR64__(v359, LODWORD(v227));
                        float v236 = v237;
                        goto LABEL_383;
                      }
LABEL_382:
                      unint64_t v353 = __PAIR64__(HIDWORD(v359), LODWORD(v345));
                      goto LABEL_383;
                    }
LABEL_376:
                    unint64_t v353 = __PAIR64__(v360, LODWORD(v344));
                    float v236 = v233;
                    goto LABEL_383;
                  }
                }
                if (v251) {
                  goto LABEL_382;
                }
                goto LABEL_376;
              }
            }
            else
            {
LABEL_280:
              float v232 = 0.0;
              if (v221) {
                float v233 = 0.0;
              }
              else {
                float v233 = v218;
              }
              if (!v226) {
                float v232 = v222;
              }
            }
            float v228 = 0.0;
            goto LABEL_286;
          }
          os_log_t v31 = (os_log_t)off_1002BBCA8;
          if (off_1002BBCA8 == &_os_log_default)
          {
            os_log_t v31 = os_log_create("com.apple.isp", "general");
            off_1002BBCA8 = v31;
          }
          if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR)) {
            sub_100076624(a1, v31);
          }
        }
      }
    }
  }
  return 1;
}

float sub_100037BF4(float *a1)
{
  float v1 = a1[2];
  float v2 = (float)(*a1 + (float)(a1[1] * -2.0)) + v1;
  float result = 0.0;
  if (v2 != 0.0)
  {
    float v4 = (float)(*a1 - v1) * 0.5 / v2;
    float result = 0.5;
    if (v4 <= 0.5)
    {
      float result = (float)(*a1 - v1) * 0.5 / v2;
      if (v4 < -0.5) {
        return -0.5;
      }
    }
  }
  return result;
}

float sub_100037C58(float *a1)
{
  return a1[1] + (float)(sub_100037BF4(a1) * (float)(*a1 - a1[2])) * -0.25;
}

float32x4_t sub_100037CA4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a2 && a1)
  {
    if (a3)
    {
      float32x4_t v3 = (float32x4_t)vdupq_n_s32(0x2F800000u);
      *(float32x4_t *)a3 = vmulq_f32(vcvtq_f32_u32(*(uint32x4_t *)(a1 + 16)), v3);
      *(float *)(a3 + 24) = (float)*(unsigned int *)(a1 + 40) * 2.3283e-10;
      *(float32x2_t *)(a3 + 16) = vmul_f32(vcvt_f32_u32(*(uint32x2_t *)(a1 + 32)), *(float32x2_t *)v3.f32);
      v4.i64[0] = *(void *)(a2 + 12);
      *(int32x2_t *)v3.f32 = vadd_s32(*(int32x2_t *)(a1 + 76), *(int32x2_t *)v4.i8);
      v4.i64[1] = v4.i64[0];
      *(float32x4_t *)(a3 + 28) = vcvtq_f32_s32(vaddq_s32(*(int32x4_t *)(a1 + 44), v4));
      *(float32x4_t *)(a3 + 44) = vcvtq_f32_s32(vaddq_s32(*(int32x4_t *)(a1 + 60), v4));
      *(float32x2_t *)(a3 + 60) = vcvt_f32_s32(*(int32x2_t *)v3.f32);
      v3.i64[0] = 0x3A0000003A000000;
      v3.i64[1] = 0x3A0000003A000000;
      *(float32x4_t *)(a3 + 68) = vmulq_f32(vcvtq_f32_u32(vmovl_u16(*(uint16x4_t *)(a1 + 86))), v3);
      float32x4_t result = vmulq_f32(vcvtq_f32_u32(vmovl_u16(*(uint16x4_t *)(a1 + 94))), v3);
      *(float32x4_t *)(a3 + 84) = result;
    }
  }
  return result;
}

float sub_100037D54(uint64_t a1, int a2, float *a3, float *a4, _DWORD *a5, _DWORD *a6)
{
  if (a1)
  {
    switch(a2)
    {
      case 0:
        *a4 = 1.0;
        *a3 = 1.0;
        *a5 = *(_DWORD *)(a1 + 28);
        float v6 = (float *)(a1 + 32);
        break;
      case 1:
        *a4 = *(float *)(a1 + 72);
        *a3 = *(float *)(a1 + 68);
        *a5 = *(_DWORD *)(a1 + 36);
        float v6 = (float *)(a1 + 40);
        break;
      case 3:
        *a4 = *(float *)(a1 + 72) * *(float *)(a1 + 80);
        *a3 = *(float *)(a1 + 68) * *(float *)(a1 + 76);
        *a5 = *(_DWORD *)(a1 + 44);
        float v6 = (float *)(a1 + 48);
        break;
      case 7:
        *a4 = (float)(*(float *)(a1 + 72) * *(float *)(a1 + 80)) * *(float *)(a1 + 88);
        *a3 = (float)(*(float *)(a1 + 68) * *(float *)(a1 + 76)) * *(float *)(a1 + 84);
        *a5 = *(_DWORD *)(a1 + 52);
        float v6 = (float *)(a1 + 56);
        break;
      default:
        *a4 = (float)((float)(*(float *)(a1 + 72) * *(float *)(a1 + 80)) * *(float *)(a1 + 88)) * *(float *)(a1 + 96);
        *a3 = (float)((float)(*(float *)(a1 + 68) * *(float *)(a1 + 76)) * *(float *)(a1 + 84)) * *(float *)(a1 + 92);
        *a5 = *(_DWORD *)(a1 + 60);
        float v6 = (float *)(a1 + 64);
        break;
    }
    float result = *v6;
    *a6 = *(_DWORD *)v6;
  }
  return result;
}

float sub_100037EA8(float *a1, int a2, float a3, float a4, float a5, float a6, float a7, float a8)
{
  if (!a1) {
    return 0.0;
  }
  float v8 = -(float)(a8 - (float)(a3 * 8388600.0));
  float v9 = -(float)(a7 - (float)(a4 * 8388600.0));
  if (a2 == 1)
  {
    int32x2_t v10 = a1 + 1;
  }
  else if (v8 == 0.0 || (float)(v9 / v8) >= a1[4])
  {
    int32x2_t v10 = a1 + 6;
    a1 += 5;
  }
  else
  {
    int32x2_t v10 = a1 + 3;
    a1 += 2;
  }
  return (float)((float)-(float)(*v10 * v9) * a5) + (float)((float)(v8 * *a1) * a6);
}

uint64_t sub_100037F18(float *a1, float *a2, unsigned int a3, char a4, uint64_t a5, uint64_t a6, BOOL a7, float a8, float a9, float a10, float a11)
{
  uint64_t v21 = 0xFFFFFFFFLL;
  int v22 = sub_100022CF0(@"FlickerDetectorAlphaNumerator", @"com.apple.coremedia", 0xFFFFFFFFLL);
  int v23 = sub_100022CF0(@"FlickerDetectorAlphaDenominator", @"com.apple.coremedia", 0xFFFFFFFFLL);
  int v24 = sub_100022CF0(@"FlickerDetectorIsGrimaldi", @"com.apple.coremedia", 2);
  float v26 = 0.8;
  if (v22 != -1 && v23 != -1) {
    float v26 = (float)v22 / (float)v23;
  }
  *(_DWORD *)(a6 + 40) = -1;
  BOOL v27 = v24 != 0;
  if (v24 == 2) {
    BOOL v27 = a7;
  }
  if (a3 >= 0x7D0 && a1 && a2 && a5 && a6)
  {
    uint64_t v28 = a5 + 8000;
    float v29 = a11 * 1.05;
    float v30 = a10 * 1.1;
    if (a4)
    {
      LODWORD(v31) = *(_DWORD *)(a5 + 16000);
    }
    else
    {
      uint64_t v31 = 2000;
      float v32 = (float *)a5;
      do
      {
        float v33 = *a2++;
        *float v32 = (float)(v33 - v29) * a9;
        float v34 = *a1++;
        v32[2000] = (float)(v34 - v30) * a8;
        ++v32;
        --v31;
      }
      while (v31);
      a3 -= 2000;
      if (!a3) {
        goto LABEL_19;
      }
    }
    float v35 = 1.0 - v26;
    unsigned int v36 = v31;
    unsigned int v37 = a3;
    do
    {
      unsigned int v38 = v36 % 0x7D0;
      float v39 = *a2++;
      *(float *)(a5 + 4 * v38) = (float)((float)(v26 * (float)(v39 - v29)) * a9)
                                 + (float)(*(float *)(a5 + 4 * v38) * v35);
      float v40 = *a1++;
      *(float *)(v28 + 4 * v38) = (float)((float)(v26 * (float)(v40 - v30)) * a8)
                                  + (float)(*(float *)(v28 + 4 * v38) * v35);
      ++v36;
      --v37;
    }
    while (v37);
    LODWORD(v31) = (a3 + v31) % 0x7D0;
LABEL_19:
    uint64_t v41 = 0;
    *(_DWORD *)(a5 + 16000) = v31;
    float v42 = 0.0;
    float v43 = 0.0;
    float v44 = 0.0;
    float v45 = 0.0;
    do
    {
      float v43 = v43 + *(float *)(a5 + v41);
      float v42 = v42 + *(float *)(a5 + v41 + 4268);
      float v45 = v45 + *(float *)(a5 + v41 + 8000);
      float v44 = v44 + *(float *)(a5 + v41 + 12268);
      v41 += 4;
    }
    while (v41 != 2128);
    uint64_t v46 = 0;
    float v47 = 0.0;
    float v48 = 0.0;
    float v49 = 0.0;
    float v50 = 0.0;
    float v51 = 0.0;
    float v52 = 0.0;
    do
    {
      float v53 = *(float *)(a5 + v46 + 2132);
      float v51 = v51 + v53;
      float v47 = v47 + (float)(v53 * v53);
      float v54 = *(float *)(a5 + v46 + 3200);
      float v49 = v49 + v54;
      float v48 = v48 + (float)(v54 * v54);
      float v52 = v52 + *(float *)(a5 + v46 + 10132);
      float v50 = v50 + *(float *)(a5 + v46 + 11200);
      v46 += 4;
    }
    while (v46 != 532);
    uint64_t v55 = 0;
    float v56 = v47;
    float v57 = v48;
    float v58 = v49;
    float v59 = v51;
    do
    {
      float v60 = *(float *)(a5 + v55 + 2664);
      float v59 = v59 + v60;
      float v56 = v56 + (float)(v60 * v60);
      float v61 = *(float *)(a5 + v55 + 3732);
      float v58 = v58 + v61;
      float v57 = v57 + (float)(v61 * v61);
      float v52 = v52 + *(float *)(a5 + v55 + 10664);
      float v50 = v50 + *(float *)(a5 + v55 + 11732);
      v55 += 4;
    }
    while (v55 != 532);
    unint64_t v62 = 0;
    int v63 = 266;
    float v64 = 0.0;
    int v65 = 133;
    float v66 = (float *)a5;
    float v67 = 0.0;
    for (int i = 532; ; ++i)
    {
      *(float *)v25.i32 = v43 + v42;
      float v69 = v45 + v44;
      if (v27)
      {
        float v70 = v45 - v44;
        if ((float)(v45 - v44) < 0.0) {
          float v70 = -(float)(v45 - v44);
        }
        float v71 = v43 - v42;
        if ((float)(v43 - v42) < 0.0) {
          float v71 = -(float)(v43 - v42);
        }
        if (v43 < 0.0
          || v42 < 0.0
          || v45 < 0.0
          || v44 < 0.0
          || (float)((float)(v70 / v69) + (float)(v71 / *(float *)v25.i32)) > 0.125)
        {
          goto LABEL_55;
        }
      }
      float v72 = -(float)(*(float *)v25.i32 - (float)((float)(v59 + v58) * 2.0));
      float v73 = -(float)(v69 - (float)((float)(v52 + v50) * 2.0));
      if (v27)
      {
        float v64 = (float)(v73 / sqrtf(v69)) + (float)(v72 / sqrtf(*(float *)v25.i32));
        if (v64 > v67) {
          goto LABEL_43;
        }
      }
      else if ((float)(v73 - (float)(*(float *)v25.i32 - (float)((float)(v59 + v58) * 2.0))) > v67 || v72 > v67)
      {
LABEL_43:
        *(_DWORD *)a6 = v25.i32[0];
        *(float *)(a6 + 4) = v59;
        *(float *)(a6 + 24) = v52;
        *(float *)(a6 + 28) = v50;
        *(float *)(a6 + 16) = v51;
        *(float *)(a6 + 20) = v69;
        *(float *)(a6 + 8) = v58;
        *(float *)(a6 + 12) = v49;
        v75.f32[0] = v59 - v51;
        *(float *)v25.i32 = *(float *)v25.i32 * 0.125;
        v75.f32[1] = v51;
        v76.f32[0] = v56 - v47;
        float32x2_t v77 = (float32x2_t)vdup_lane_s32(v25, 0);
        float32x2_t v78 = vsub_f32(v75, v77);
        v76.f32[1] = v47;
        float32x2_t v79 = (float32x2_t)vdup_n_s32(0x43050000u);
        float32x2_t v80 = vmla_f32(vmul_f32(v75, vneg_f32(v75)), v79, v76);
        float32x2_t v81 = (float32x2_t)vdup_n_s32(0x3C23D70Au);
        float32x2_t v82 = vdiv_f32(vmul_f32(v78, v78), vmaxnm_f32(v80, v81));
        v78.f32[0] = v58 - v49;
        v83.f32[0] = v57 - v48;
        v78.f32[1] = v49;
        float32x2_t v84 = vsub_f32(v78, v77);
        v83.f32[1] = v48;
        int32x2_t v25 = (int32x2_t)vdiv_f32(vmul_f32(v84, v84), vmaxnm_f32(vmla_f32(vmul_f32(v78, vneg_f32(v78)), v79, v83), v81));
        float v85 = v82.f32[1];
        if (v82.f32[0] < v82.f32[1]) {
          float v85 = v82.f32[0];
        }
        if (*(float *)v25.i32 >= *(float *)&v25.i32[1]) {
          float v86 = *(float *)&v25.i32[1];
        }
        else {
          float v86 = *(float *)v25.i32;
        }
        if (v85 >= v86) {
          float v85 = v86;
        }
        *(float *)(a6 + 32) = *(float *)&v25.i32[1] + (float)(*(float *)v25.i32 + vaddv_f32(v82));
        *(float *)(a6 + 36) = v85;
        *(_DWORD *)(a6 + 40) = v62;
        if (v73 <= 0.0) {
          float v87 = -0.0;
        }
        else {
          float v87 = v73;
        }
        float v67 = v72 + v87;
        if (v27) {
          float v67 = v64;
        }
      }
LABEL_55:
      if (v62 >= 0x5BC) {
        int v88 = -1468;
      }
      else {
        int v88 = 532;
      }
      unsigned int v89 = v88 + v62;
      if (v62 >= 0x3A5) {
        int v90 = -933;
      }
      else {
        int v90 = 1067;
      }
      if (v62 >= 0x3A5) {
        int v91 = -933;
      }
      else {
        int v91 = 1067;
      }
      unsigned int v92 = v62 + v91;
      int v93 = v62 + v90 - 2000 * ((v90 + i) / 0x7D0u);
      if (v62 >= 0x5BB) {
        int v94 = -1467;
      }
      else {
        int v94 = 533;
      }
      if (v62 >= 0x5BB) {
        int v95 = -1467;
      }
      else {
        int v95 = 533;
      }
      unsigned int v96 = v62 + v95;
      int v97 = v62 + v94 - 2000 * ((v94 + v63) / 0x7D0u);
      int v98 = v62 + v94 - 2000 * ((v94 + v65) / 0x7D0u);
      if (v62 >= 0x4B0) {
        int v99 = -1200;
      }
      else {
        int v99 = 800;
      }
      if (v62 >= 0x4B0) {
        int v100 = -1200;
      }
      else {
        int v100 = 800;
      }
      unsigned int v101 = v62 + v100;
      unsigned int v102 = v97 + 266;
      unsigned int v103 = v62 + v99 - 2000 * ((v99 + v63) / 0x7D0u) + 266;
      float v43 = v43 + (float)(*(float *)(a5 + 4 * v89) - *v66);
      float v42 = v42 + (float)(*(float *)(a5 + 4 * (v93 + 532)) - *(float *)(a5 + 4 * v92));
      float v45 = v45 + (float)(*(float *)(v28 + 4 * v89) - v66[2000]);
      float v104 = *(float *)(a5 + 4 * v102);
      float v44 = v44 + (float)(*(float *)(v28 + 4 * (v93 + 532)) - *(float *)(v28 + 4 * v92));
      float v105 = *(float *)(a5 + 4 * v96);
      float v59 = v59 + (float)(v104 - v105);
      float v56 = v56 + (float)((float)(v104 * v104) - (float)(v105 * v105));
      float v52 = v52 + (float)(*(float *)(v28 + 4 * v102) - *(float *)(v28 + 4 * v96));
      float v106 = *(float *)(a5 + 4 * (v98 + 133));
      float v51 = v51 + (float)(v106 - v105);
      float v107 = (float)(v106 * v106) - (float)(v105 * v105);
      float v108 = *(float *)(a5 + 4 * v103);
      float v109 = *(float *)(a5 + 4 * v101);
      float v47 = v47 + v107;
      float v58 = v58 + (float)(v108 - v109);
      float v57 = v57 + (float)((float)(v108 * v108) - (float)(v109 * v109));
      float v50 = v50 + (float)(*(float *)(v28 + 4 * v103) - *(float *)(v28 + 4 * v101));
      float v110 = *(float *)(a5 + 4 * (v62 + v99 - 2000 * ((v99 + v65) / 0x7D0u) + 133));
      float v49 = v49 + (float)(v110 - v109);
      ++v63;
      ++v65;
      float v48 = v48 + (float)((float)(v110 * v110) - (float)(v109 * v109));
      ++v66;
      if (++v62 == 2000)
      {
        uint64_t v21 = 0;
        *(unsigned char *)(a6 + 44) = a4;
        *(unsigned char *)(a6 + 45) = v27;
        return v21;
      }
    }
  }
  return v21;
}

uint64_t sub_10003858C(uint64_t a1, uint64_t a2, unsigned int a3, unsigned int a4, float *__dst, unsigned int a6, uint64_t a7)
{
  if (a3 < 0x506) {
    return 0xFFFFFFFFLL;
  }
  uint64_t result = 0xFFFFFFFFLL;
  if (a2)
  {
    if (a1)
    {
      if (__dst)
      {
        if (a6 >> 3 >= 0x295)
        {
          uint64_t v10 = a7;
          if (a7)
          {
            uint64_t v11 = 0;
            uint64_t v12 = 0;
            int v170 = 0;
            char v171 = 0;
            uint64_t v13 = 0;
            char v14 = 0;
            *(_DWORD *)(a7 + 76) = -1;
            float v15 = __dst[1286];
            float v16 = __dst[1287];
            float v17 = __dst[1288];
            float v18 = __dst[1289];
            float v19 = __dst[1290];
            float v20 = __dst[1291];
            unsigned int v21 = __dst[1293];
            float v22 = __dst[1292];
            float v23 = __dst[1294];
            float v24 = __dst[1295];
            float v25 = __dst[1296];
            float v26 = __dst[1297];
            float v27 = __dst[1298];
            float v28 = __dst[1299];
            float v136 = __dst[1300];
            unsigned int v29 = __dst[1301];
            float v30 = __dst[1302];
            unsigned int v172 = __dst[1303];
            float v31 = __dst[1304];
            float v32 = __dst[1305];
            float v33 = __dst[1306];
            float v34 = __dst[1307];
            float v35 = __dst[1308];
            float v36 = __dst[1309];
            float v109 = __dst[1310];
            float v37 = __dst[1311];
            unsigned int v38 = __dst[1312];
            float v39 = __dst[1313];
            float v40 = __dst[1314];
            float v41 = __dst[1315];
            int v42 = (a4 >> 1) - 1;
            unsigned int v43 = a4 - 1;
            float v44 = __dst[1316];
            float v45 = __dst[1317];
            unsigned int v46 = a4 >> 2;
            unsigned int v47 = (a4 >> 1) + (a4 >> 2);
            float v48 = __dst[1318];
            float v49 = -0.25;
            float v50 = (float *)a1;
            float v51 = __dst[1319];
            unsigned int v135 = a3;
            int v115 = v42;
            unsigned int v117 = a4;
            unsigned int v111 = v47;
            unsigned int v113 = a4 - 1;
            unsigned int v110 = a4 >> 2;
            while (1)
            {
              float v52 = (float *)(a1 + 4 * (v11 - 1286));
              if ((int)v11 < 1286) {
                float v52 = &__dst[(int)v11];
              }
              float v53 = *v52;
              float v54 = &__dst[(int)v11 + 368];
              if ((int)v11 - 918 >= 0) {
                float v54 = (float *)(a1 + 4 * (v11 - 918));
              }
              float v15 = v15 + (float)(*v54 - v53);
              uint64_t v55 = &__dst[(int)v11 + 918];
              if ((int)v11 - 368 >= 0) {
                uint64_t v55 = (float *)(a1 + 4 * (v11 - 368));
              }
              float v56 = *v55;
              float v57 = &__dst[(int)v11 + 1286];
              if ((int)v11 >= 0) {
                float v57 = v50;
              }
              float v16 = v16 + (float)(*v57 - v56);
              float v58 = &__dst[(int)v11 + 427];
              if ((int)v11 - 859 >= 0) {
                float v58 = (float *)(a1 + 4 * (v11 - 859));
              }
              float v59 = *v58;
              float v60 = &__dst[(int)v11 + 473];
              if ((int)v11 - 813 >= 0) {
                float v60 = (float *)(a1 + 4 * (v11 - 813));
              }
              float v17 = v17 + (float)(*v60 - v59);
              float v61 = &__dst[(int)v11 + 533];
              if ((int)v11 - 753 >= 0) {
                float v61 = (float *)(a1 + 4 * (v11 - 753));
              }
              float v62 = *v61;
              int v63 = &__dst[(int)v11 + 579];
              if ((int)v11 - 707 >= 0) {
                int v63 = (float *)(a1 + 4 * (v11 - 707));
              }
              float v18 = v18 + (float)(*v63 - v62);
              float v64 = &__dst[(int)v11 + 647];
              if ((int)v11 - 639 >= 0) {
                float v64 = (float *)(a1 + 4 * (v11 - 639));
              }
              float v65 = *v64;
              float v66 = &__dst[(int)v11 + 693];
              if ((int)v11 - 593 >= 0) {
                float v66 = (float *)(a1 + 4 * (v11 - 593));
              }
              float v19 = v19 + (float)(*v66 - v65);
              float v67 = &__dst[(int)v11 + 754];
              if ((int)v11 - 532 >= 0) {
                float v67 = (float *)(a1 + 4 * (v11 - 532));
              }
              float v68 = *v67;
              float v69 = &__dst[(int)v11 + 800];
              if ((int)v11 - 486 >= 0) {
                float v69 = (float *)(a1 + 4 * (v11 - 486));
              }
              float v20 = v20 + (float)(*v69 - v68);
              float v70 = (float)(v15 + v16) * v49;
              float v71 = (float)((float)((float)(v17 + v18) + v19) + v20) + v70;
              if (v71 > v22)
              {
                char v14 = 1;
                uint64_t v12 = v11;
                float v22 = (float)((float)((float)(v17 + v18) + v19) + v20) + v70;
                unsigned int v21 = v29;
                float v23 = v15;
                float v24 = v16;
                float v25 = v17;
                float v26 = v18;
                float v27 = v19;
                float v28 = v20;
              }
              if (v71 > v30)
              {
                int v170 = v11;
                char v171 = 1;
                float v30 = (float)((float)((float)(v17 + v18) + v19) + v20) + v70;
                unsigned int v172 = v29;
                float v31 = v15;
                float v32 = v16;
                float v33 = v17;
                float v34 = v18;
                float v35 = v19;
                float v36 = v20;
              }
              float v72 = v30;
              if (v29 == v42)
              {
                if (v172 < v46 || v172 >= v47)
                {
                  if (v171)
                  {
                    float v152 = v25;
                    float v155 = v15;
                    float v73 = v23;
                    float v146 = v19;
                    float v149 = v20;
                    float v140 = v17;
                    float v143 = v18;
                    float v137 = v16;
                    float v74 = v24;
                    float v75 = v31;
                    float v164 = v33;
                    float v167 = v32;
                    float v76 = v26;
                    float v77 = v27;
                    float v158 = v35;
                    float v161 = v34;
                    float v78 = v28;
                    float v79 = v36;
                    float v119 = v22;
                    uint64_t v80 = v13;
                    uint64_t v81 = v12;
                    float v82 = sub_100038E3C(a1, (uint64_t)__dst, v170 + 1, v170 + 919, (float)(v31 + v32) / 368.0 * 0.5);
                    float v49 = -0.25;
                    unsigned int v46 = v110;
                    unsigned int v47 = v111;
                    unsigned int v43 = v113;
                    int v42 = v115;
                    uint64_t v12 = v81;
                    uint64_t v13 = v80;
                    a4 = v117;
                    float v22 = v119;
                    float v36 = v79;
                    float v35 = v158;
                    float v34 = v161;
                    float v28 = v78;
                    float v27 = v77;
                    float v33 = v164;
                    float v32 = v167;
                    float v26 = v76;
                    float v31 = v75;
                    float v24 = v74;
                    float v16 = v137;
                    float v17 = v140;
                    float v18 = v143;
                    float v19 = v146;
                    float v15 = v155;
                    float v23 = v73;
                    float v20 = v149;
                    float v25 = v152;
                    a3 = v135;
                    float v51 = v82;
                    float v30 = -3.4028e38;
                    float v37 = v72;
                    unsigned int v38 = v172;
                    float v39 = v31;
                    float v40 = v167;
                    float v41 = v164;
                    float v44 = v161;
                    float v45 = v158;
                    float v48 = v36;
                  }
                  else
                  {
                    float v30 = -3.4028e38;
                    float v37 = v72;
                    unsigned int v38 = v172;
                    float v39 = v31;
                    float v40 = v32;
                    float v41 = v33;
                    float v44 = v34;
                    float v45 = v35;
                    float v48 = v36;
                    float v51 = v109;
                  }
                }
                else
                {
                  float v30 = -3.4028e38;
                }
              }
              if (v29 != v43) {
                goto LABEL_54;
              }
              if (v21 >= v46 && v21 < v47 && v22 >= v37) {
                break;
              }
              float v22 = -3.4028e38;
              BOOL v93 = v37 <= -3.4028e38;
              float v37 = -3.4028e38;
              if (!v93)
              {
                *(float *)(v10 + 4) = v41;
                *(float *)(v10 + 8) = v44;
                *(float *)(v10 + 12) = v45;
                *(float *)(v10 + 16) = v48;
                *(float *)(v10 + 20) = v40;
                *(float *)(v10 + 24) = v39;
                float v83 = v51;
                *(_DWORD *)(v10 + 76) = v38;
LABEL_53:
                *(float *)uint64_t v10 = v83;
                uint64_t v13 = 1;
                float v22 = -3.4028e38;
                float v37 = -3.4028e38;
              }
LABEL_54:
              uint64_t v11 = (v11 + 1);
              unsigned int v29 = (v29 + 1) % a4;
              ++v50;
              if (a3 == v11)
              {
                float v112 = v37;
                float v114 = v30;
                float v120 = v22;
                float v122 = v48;
                float v124 = v45;
                float v126 = v44;
                float v128 = v51;
                float v130 = v40;
                float v116 = v41;
                float v118 = v39;
                float v139 = v36;
                float v142 = v28;
                float v160 = v35;
                float v163 = v34;
                float v145 = v27;
                float v148 = v26;
                float v166 = v33;
                if (v14)
                {
                  float v94 = v23;
                  float v154 = v25;
                  float v157 = v15;
                  float v151 = v20;
                  float v95 = v19;
                  float v96 = v18;
                  float v97 = v17;
                  float v98 = v16;
                  float v99 = v24;
                  float v100 = v31;
                  float v101 = v32;
                  char v102 = v13;
                  float v103 = sub_100038E3C(a1, (uint64_t)__dst, v12 + 1, v12 + 919, (float)(v23 + v24) / 368.0 * 0.5);
                  LOBYTE(v13) = v102;
                  float v32 = v101;
                  float v31 = v100;
                  float v24 = v99;
                  float v16 = v98;
                  float v17 = v97;
                  float v18 = v96;
                  float v19 = v95;
                  float v20 = v151;
                  float v25 = v154;
                  float v15 = v157;
                  float v23 = v94;
                  a3 = v135;
                  float v136 = v103;
                }
                float v132 = v23;
                float v134 = v24;
                float v169 = v32;
                if (v171)
                {
                  float v104 = v31;
                  char v105 = v13;
                  float v106 = sub_100038E3C(a1, (uint64_t)__dst, v170 + 1, v170 + 919, (float)(v31 + v32) / 368.0 * 0.5);
                  LOBYTE(v13) = v105;
                  float v31 = v104;
                  a3 = v135;
                  float v109 = v106;
                }
                float v107 = v31;
                if ((v13 & 1) == 0)
                {
                  *(void *)uint64_t v10 = 0;
                  *(void *)(v10 + 8) = 0;
                  *(_DWORD *)(v10 + 24) = 0;
                  *(void *)(v10 + 16) = 0;
                  *(_DWORD *)(v10 + 76) = -1;
                }
                *(_OWORD *)(v10 + 60) = 0u;
                *(_OWORD *)(v10 + 44) = 0u;
                *(_OWORD *)(v10 + 28) = 0u;
                *(void *)(v10 + 80) = 0;
                *(void *)(v10 + 86) = 0;
                memcpy(__dst, (const void *)(a1 + 4 * a3 - 5144), 0x1418uLL);
                uint64_t result = 0;
                __dst[1286] = v15;
                __dst[1287] = v16;
                __dst[1288] = v17;
                __dst[1289] = v18;
                __dst[1290] = v19;
                __dst[1291] = v20;
                __dst[1292] = v120;
                __dst[1293] = (float)v21;
                __dst[1294] = v132;
                __dst[1295] = v134;
                __dst[1296] = v25;
                __dst[1297] = v148;
                __dst[1298] = v145;
                __dst[1299] = v142;
                __dst[1300] = v136;
                __dst[1301] = (float)v29;
                __dst[1302] = v114;
                __dst[1303] = (float)v172;
                __dst[1304] = v107;
                __dst[1305] = v169;
                __dst[1306] = v166;
                __dst[1307] = v163;
                __dst[1308] = v160;
                __dst[1309] = v139;
                __dst[1310] = v109;
                __dst[1311] = v112;
                __dst[1312] = (float)v38;
                __dst[1313] = v118;
                __dst[1314] = v130;
                __dst[1315] = v116;
                __dst[1316] = v126;
                __dst[1317] = v124;
                __dst[1318] = v122;
                __dst[1319] = v128;
                return result;
              }
            }
            *(float *)(v10 + 4) = v25;
            *(float *)(v10 + 8) = v26;
            *(float *)(v10 + 12) = v27;
            *(float *)(v10 + 16) = v28;
            *(float *)(v10 + 20) = v24;
            *(float *)(v10 + 24) = v23;
            float v83 = v136;
            *(_DWORD *)(v10 + 76) = v21;
            if (v14)
            {
              float v131 = v23;
              float v133 = v24;
              float v153 = v25;
              float v156 = v15;
              float v147 = v19;
              float v150 = v20;
              float v141 = v17;
              float v144 = v18;
              float v138 = v16;
              float v84 = v31;
              float v165 = v33;
              float v168 = v32;
              float v85 = v26;
              float v86 = v27;
              float v159 = v35;
              float v162 = v34;
              float v87 = v28;
              float v88 = v36;
              float v89 = v39;
              float v127 = v51;
              float v129 = v40;
              float v90 = v41;
              float v91 = v30;
              float v123 = v45;
              float v125 = v44;
              float v121 = v48;
              uint64_t v92 = v12;
              float v83 = sub_100038E3C(a1, (uint64_t)__dst, v12 + 1, v12 + 919, (float)(v23 + v24) / 368.0 * 0.5);
              float v49 = -0.25;
              unsigned int v46 = v110;
              unsigned int v47 = v111;
              unsigned int v43 = v113;
              int v42 = v115;
              uint64_t v12 = v92;
              a4 = v117;
              float v48 = v121;
              float v45 = v123;
              float v44 = v125;
              float v51 = v127;
              float v30 = v91;
              float v41 = v90;
              float v40 = v129;
              float v23 = v131;
              float v39 = v89;
              uint64_t v10 = a7;
              float v36 = v88;
              float v35 = v159;
              float v34 = v162;
              float v28 = v87;
              float v27 = v86;
              float v33 = v165;
              float v32 = v168;
              float v26 = v85;
              float v31 = v84;
              float v24 = v133;
              float v16 = v138;
              float v17 = v141;
              float v18 = v144;
              float v19 = v147;
              float v20 = v150;
              float v25 = v153;
              float v15 = v156;
              a3 = v135;
            }
            goto LABEL_53;
          }
        }
      }
    }
  }
  return result;
}

float sub_100038E3C(uint64_t a1, uint64_t a2, int a3, int a4, double a5)
{
  double v5 = 0.0;
  int v6 = -368;
  do
  {
    int v7 = a3 + v6 + 368;
    int v8 = a4 + v6 + 368;
    float v9 = (float *)(a1 + 4 * (a4 + v6 - 918));
    if (v8 < 1286) {
      float v9 = (float *)(a2 + 4 * v8);
    }
    double v10 = v5 + (*v9 - a5) * (*v9 - a5);
    uint64_t v11 = (float *)(a1 + 4 * (a3 + v6 - 918));
    if (v7 < 1286) {
      uint64_t v11 = (float *)(a2 + 4 * v7);
    }
    double v5 = v10 + (*v11 - a5) * (*v11 - a5);
  }
  while (!__CFADD__(v6++, 1));
  return sqrt(v5 / 368.0 * 0.5);
}

void start()
{
  uint64_t v0 = 0;
  operator new();
}

void sub_100039094()
{
}

uint64_t sub_1000390B8(uint64_t a1, uint64_t a2, uint64_t a3, BOOL *a4, double *a5, double a6)
{
  sub_1000032CC((uint64_t)&v130, 9, *(_DWORD *)(a1 + 20));
  float v130 = &off_100096808;
  int v115 = 3;
  unsigned int v116 = v132;
  int v127 = 3;
  unsigned int v128 = v132;
  char v129 = 0;
  unsigned int v113 = off_100095A80;
  uint64_t v114 = 0;
  char v117 = 0;
  float v125 = &off_100095BC8;
  float v126 = &v131[48 * v132];
  sub_100003224((uint64_t)&v113);
  sub_1000032CC((uint64_t)&v122, 3, *(_DWORD *)(a2 + 20));
  float v122 = &off_100095BC8;
  uint64_t v121 = 0;
  memset(v120, 0, sizeof(v120));
  uint64_t v119 = 0;
  memset(v118, 0, sizeof(v118));
  sub_100039FBC(a1, (uint64_t)&v125, (uint64_t)v120);
  sub_100039FBC(a2, (uint64_t)&v122, (uint64_t)v118);
  int v115 = 1;
  unsigned int v116 = v124;
  unsigned int v106 = v124;
  char v107 = 0;
  unsigned int v113 = off_100095A80;
  uint64_t v114 = 0;
  char v117 = 0;
  float v103 = &off_100095AB0;
  float v104 = v123;
  unsigned int v105 = 1;
  sub_100003224((uint64_t)&v113);
  int v115 = 1;
  unsigned int v116 = v128;
  LODWORD(v134) = 1;
  DWORD1(v134) = v128;
  BYTE8(v134) = 0;
  unsigned int v113 = off_100095A80;
  uint64_t v114 = 0;
  char v117 = 0;
  *(void *)&long long v133 = &off_100095AB0;
  *((void *)&v133 + 1) = v126;
  sub_100003224((uint64_t)&v113);
  sub_10002868C((uint64_t)&v103, (uint64_t)&v133, (uint64_t)&v108);
  int v115 = 1;
  unsigned int v116 = v132;
  DWORD1(v99) = v132;
  BYTE8(v99) = 0;
  unsigned int v113 = off_100095A80;
  uint64_t v114 = 0;
  char v117 = 0;
  __dst[0] = &off_100095AB0;
  __dst[1] = v131;
  LODWORD(v99) = 1;
  sub_100003224((uint64_t)&v113);
  sub_100004500((uint64_t)__dst, v110, v111);
  memcpy(__dst[1], __src, 8 * v99 * (unint64_t)DWORD1(v99));
  sub_100003224((uint64_t)__dst);
  sub_100003224((uint64_t)&v108);
  sub_100003224((uint64_t)&v133);
  sub_100003224((uint64_t)&v103);
  int v115 = 1;
  unsigned int v116 = v124;
  unsigned int v106 = v124;
  char v107 = 0;
  unsigned int v113 = off_100095A80;
  uint64_t v114 = 0;
  char v117 = 0;
  float v103 = &off_100095AB0;
  float v104 = v123;
  unsigned int v105 = 1;
  sub_100003224((uint64_t)&v113);
  int v115 = 1;
  unsigned int v116 = v128;
  LODWORD(v134) = 1;
  DWORD1(v134) = v128;
  BYTE8(v134) = 0;
  unsigned int v113 = off_100095A80;
  uint64_t v114 = 0;
  char v117 = 0;
  *(void *)&long long v133 = &off_100095AB0;
  *((void *)&v133 + 1) = &v126[8 * v128];
  sub_100003224((uint64_t)&v113);
  sub_10002868C((uint64_t)&v103, (uint64_t)&v133, (uint64_t)&v108);
  int v115 = 1;
  unsigned int v116 = v132;
  DWORD1(v99) = v132;
  BYTE8(v99) = 0;
  unsigned int v113 = off_100095A80;
  uint64_t v114 = 0;
  char v117 = 0;
  __dst[0] = &off_100095AB0;
  __dst[1] = &v131[8 * v132];
  LODWORD(v99) = 1;
  sub_100003224((uint64_t)&v113);
  sub_100004500((uint64_t)__dst, v110, v111);
  memcpy(__dst[1], __src, 8 * v99 * (unint64_t)DWORD1(v99));
  sub_100003224((uint64_t)__dst);
  sub_100003224((uint64_t)&v108);
  sub_100003224((uint64_t)&v133);
  sub_100003224((uint64_t)&v103);
  int v115 = 1;
  unsigned int v116 = v124;
  __src = v123;
  unsigned int v111 = v124;
  char v112 = 0;
  unsigned int v113 = off_100095A80;
  uint64_t v114 = 0;
  char v117 = 0;
  float v108 = &off_100095AB0;
  int v110 = 1;
  sub_100003224((uint64_t)&v113);
  int v115 = 1;
  unsigned int v116 = v132;
  unsigned int v106 = v132;
  char v107 = 0;
  unsigned int v113 = off_100095A80;
  uint64_t v114 = 0;
  char v117 = 0;
  float v103 = &off_100095AB0;
  float v104 = &v131[16 * v132];
  unsigned int v105 = 1;
  sub_100003224((uint64_t)&v113);
  sub_100004500((uint64_t)&v103, v110, v111);
  memcpy(v104, __src, 8 * v105 * (unint64_t)v106);
  sub_100003224((uint64_t)&v103);
  sub_100003224((uint64_t)&v108);
  int v115 = 1;
  unsigned int v116 = v124;
  unsigned int v106 = v124;
  char v107 = 0;
  unsigned int v113 = off_100095A80;
  uint64_t v114 = 0;
  char v117 = 0;
  float v103 = &off_100095AB0;
  float v104 = &v123[8 * v124];
  unsigned int v105 = 1;
  sub_100003224((uint64_t)&v113);
  int v115 = 1;
  unsigned int v116 = v128;
  LODWORD(v134) = 1;
  DWORD1(v134) = v128;
  BYTE8(v134) = 0;
  unsigned int v113 = off_100095A80;
  uint64_t v114 = 0;
  char v117 = 0;
  *(void *)&long long v133 = &off_100095AB0;
  *((void *)&v133 + 1) = v126;
  sub_100003224((uint64_t)&v113);
  sub_10002868C((uint64_t)&v103, (uint64_t)&v133, (uint64_t)&v108);
  int v115 = 1;
  unsigned int v116 = v132;
  DWORD1(v99) = v132;
  BYTE8(v99) = 0;
  unsigned int v113 = off_100095A80;
  uint64_t v114 = 0;
  char v117 = 0;
  __dst[0] = &off_100095AB0;
  __dst[1] = &v131[24 * v132];
  LODWORD(v99) = 1;
  sub_100003224((uint64_t)&v113);
  sub_100004500((uint64_t)__dst, v110, v111);
  memcpy(__dst[1], __src, 8 * v99 * (unint64_t)DWORD1(v99));
  sub_100003224((uint64_t)__dst);
  sub_100003224((uint64_t)&v108);
  sub_100003224((uint64_t)&v133);
  sub_100003224((uint64_t)&v103);
  int v115 = 1;
  unsigned int v116 = v124;
  unsigned int v106 = v124;
  char v107 = 0;
  unsigned int v113 = off_100095A80;
  uint64_t v114 = 0;
  char v117 = 0;
  float v103 = &off_100095AB0;
  float v104 = &v123[8 * v124];
  unsigned int v105 = 1;
  sub_100003224((uint64_t)&v113);
  int v115 = 1;
  unsigned int v116 = v128;
  LODWORD(v134) = 1;
  DWORD1(v134) = v128;
  BYTE8(v134) = 0;
  unsigned int v113 = off_100095A80;
  uint64_t v114 = 0;
  char v117 = 0;
  *(void *)&long long v133 = &off_100095AB0;
  *((void *)&v133 + 1) = &v126[8 * v128];
  sub_100003224((uint64_t)&v113);
  sub_10002868C((uint64_t)&v103, (uint64_t)&v133, (uint64_t)&v108);
  int v115 = 1;
  unsigned int v116 = v132;
  DWORD1(v99) = v132;
  BYTE8(v99) = 0;
  unsigned int v113 = off_100095A80;
  uint64_t v114 = 0;
  char v117 = 0;
  __dst[0] = &off_100095AB0;
  __dst[1] = &v131[32 * v132];
  LODWORD(v99) = 1;
  sub_100003224((uint64_t)&v113);
  sub_100004500((uint64_t)__dst, v110, v111);
  memcpy(__dst[1], __src, 8 * v99 * (unint64_t)DWORD1(v99));
  sub_100003224((uint64_t)__dst);
  sub_100003224((uint64_t)&v108);
  sub_100003224((uint64_t)&v133);
  sub_100003224((uint64_t)&v103);
  int v115 = 1;
  unsigned int v116 = v124;
  __src = &v123[8 * v124];
  unsigned int v111 = v124;
  char v112 = 0;
  unsigned int v113 = off_100095A80;
  uint64_t v114 = 0;
  char v117 = 0;
  float v108 = &off_100095AB0;
  int v110 = 1;
  sub_100003224((uint64_t)&v113);
  int v115 = 1;
  unsigned int v116 = v132;
  unsigned int v106 = v132;
  char v107 = 0;
  unsigned int v113 = off_100095A80;
  uint64_t v114 = 0;
  char v117 = 0;
  float v103 = &off_100095AB0;
  float v104 = &v131[40 * v132];
  unsigned int v105 = 1;
  sub_100003224((uint64_t)&v113);
  sub_100004500((uint64_t)&v103, v110, v111);
  memcpy(v104, __src, 8 * v105 * (unint64_t)v106);
  sub_100003224((uint64_t)&v103);
  sub_100003224((uint64_t)&v108);
  sub_10003A2B8((uint64_t)&v130, (uint64_t)&v130, &v113);
  bzero(&v108, 0x288uLL);
  bzero(&v103, 0x288uLL);
  double v102 = 0.0;
  long long v100 = 0u;
  long long v101 = 0u;
  *(_OWORD *)__dst = 0u;
  long long v99 = 0u;
  sub_10003A384(&v113, &v108, (double *)__dst, (double *)&v103);
  if (a4)
  {
    uint64_t v14 = 0;
    long long v135 = v100;
    long long v136 = v101;
    double v137 = v102;
    long long v133 = *(_OWORD *)__dst;
    long long v134 = v99;
    uint64_t v15 = 1;
    do
    {
      uint64_t v16 = v15;
      unsigned int v17 = v14;
      do
      {
        if (*((double *)&v133 + v16) < *((double *)&v133 + v17)) {
          unsigned int v17 = v16;
        }
        ++v16;
      }
      while (v16 != 9);
      uint64_t v18 = *((void *)&v133 + v17);
      *((void *)&v133 + v17) = *((void *)&v133 + v14);
      *((void *)&v133 + v14) = v18;
      ++v15;
      ++v14;
    }
    while (v14 != 8);
    double v12 = *((double *)&v133 + 1);
    double v19 = v137 / *((double *)&v133 + 1);
    if (a5) {
      *a5 = v19;
    }
    *a4 = v19 < a6;
  }
  uint64_t v20 = 0;
  uint64_t v21 = 64;
  uint64_t v22 = a3;
  do
  {
    uint64_t v23 = 0;
    uint64_t v24 = v21;
    do
    {
      *(void *)(v22 + v23) = *(uint64_t (***)(uint64_t))((char *)&v103 + v24);
      v24 += 72;
      v23 += 8;
    }
    while (v23 != 24);
    ++v20;
    v21 += 216;
    v22 += 24;
  }
  while (v20 != 3);
  double v137 = 0.0;
  long long v135 = 0u;
  long long v136 = 0u;
  long long v133 = 0u;
  long long v134 = 0u;
  uint64_t v97 = 0;
  memset(v96, 0, sizeof(v96));
  uint64_t v93 = 0;
  uint64_t v94 = 0;
  uint64_t v95 = 0;
  sub_1000287E8(a3, &v133, (double *)&v93, (double *)v96, 0.0, v12, v13);
  uint64_t v25 = 0;
  uint64_t v89 = 0;
  long long v92 = 0u;
  long long v91 = 0u;
  long long v88 = 0u;
  uint64_t v87 = v93;
  uint64_t v90 = v94;
  uint64_t v81 = 0;
  long long v79 = 0u;
  long long v80 = 0u;
  float v26 = &v133;
  long long v77 = 0u;
  long long v78 = 0u;
  do
  {
    uint64_t v27 = 0;
    float v28 = (double *)&v87;
    do
    {
      uint64_t v29 = 0;
      double v30 = 0.0;
      float v31 = v28;
      do
      {
        double v32 = *v31;
        v31 += 3;
        double v30 = v30 + *(double *)((char *)v26 + v29) * v32;
        v29 += 8;
      }
      while (v29 != 24);
      *((double *)&v77 + 3 * v25 + v27++) = v30;
      ++v28;
    }
    while (v27 != 3);
    ++v25;
    float v26 = (long long *)((char *)v26 + 24);
  }
  while (v25 != 3);
  uint64_t v33 = 0;
  uint64_t v76 = 0;
  long long v74 = 0u;
  long long v75 = 0u;
  long long v72 = 0u;
  long long v73 = 0u;
  float v34 = &v72;
  float v35 = v96;
  do
  {
    uint64_t v36 = 0;
    float v37 = v34;
    do
    {
      *(void *)float v37 = *(void *)((char *)v35 + v36);
      float v37 = (long long *)((char *)v37 + 24);
      v36 += 8;
    }
    while (v36 != 24);
    ++v33;
    float v34 = (long long *)((char *)v34 + 8);
    float v35 = (_OWORD *)((char *)v35 + 24);
  }
  while (v33 != 3);
  uint64_t v38 = 0;
  uint64_t v86 = 0;
  long long v84 = 0u;
  long long v85 = 0u;
  long long v82 = 0u;
  long long v83 = 0u;
  float v39 = &v77;
  do
  {
    uint64_t v40 = 0;
    float v41 = &v72;
    do
    {
      uint64_t v42 = 0;
      double v43 = 0.0;
      float v44 = (double *)v41;
      do
      {
        double v45 = *v44;
        v44 += 3;
        double v43 = v43 + *(double *)((char *)v39 + v42) * v45;
        v42 += 8;
      }
      while (v42 != 24);
      *((double *)&v82 + 3 * v38 + v40++) = v43;
      float v41 = (long long *)((char *)v41 + 8);
    }
    while (v40 != 3);
    ++v38;
    float v39 = (long long *)((char *)v39 + 24);
  }
  while (v38 != 3);
  uint64_t v46 = 0;
  long long v47 = v85;
  *(_OWORD *)(a3 + 32) = v84;
  *(_OWORD *)(a3 + 48) = v47;
  *(void *)(a3 + 64) = v86;
  long long v48 = v83;
  *(_OWORD *)a3 = v82;
  *(_OWORD *)(a3 + 16) = v48;
  uint64_t v76 = 0;
  long long v74 = 0u;
  long long v75 = 0u;
  float v49 = &v72;
  float v50 = v118;
  long long v72 = 0u;
  long long v73 = 0u;
  do
  {
    uint64_t v51 = 0;
    float v52 = v49;
    do
    {
      *(void *)float v52 = *(void *)((char *)v50 + v51);
      float v52 = (long long *)((char *)v52 + 24);
      v51 += 8;
    }
    while (v51 != 24);
    ++v46;
    float v49 = (long long *)((char *)v49 + 8);
    float v50 = (_OWORD *)((char *)v50 + 24);
  }
  while (v46 != 3);
  uint64_t v53 = 0;
  uint64_t v81 = 0;
  long long v79 = 0u;
  long long v80 = 0u;
  long long v77 = 0u;
  long long v78 = 0u;
  float v54 = &v72;
  do
  {
    uint64_t v55 = 0;
    float v56 = (double *)a3;
    do
    {
      uint64_t v57 = 0;
      double v58 = 0.0;
      float v59 = v56;
      do
      {
        double v60 = *v59;
        v59 += 3;
        double v58 = v58 + *(double *)((char *)v54 + v57) * v60;
        v57 += 8;
      }
      while (v57 != 24);
      *((double *)&v77 + 3 * v53 + v55++) = v58;
      ++v56;
    }
    while (v55 != 3);
    ++v53;
    float v54 = (long long *)((char *)v54 + 24);
  }
  while (v53 != 3);
  uint64_t v61 = 0;
  uint64_t v86 = 0;
  long long v84 = 0u;
  long long v85 = 0u;
  long long v82 = 0u;
  long long v83 = 0u;
  float v62 = &v77;
  do
  {
    uint64_t v63 = 0;
    float v64 = v120;
    do
    {
      uint64_t v65 = 0;
      double v66 = 0.0;
      float v67 = (double *)v64;
      do
      {
        double v68 = *v67;
        v67 += 3;
        double v66 = v66 + *(double *)((char *)v62 + v65) * v68;
        v65 += 8;
      }
      while (v65 != 24);
      *((double *)&v82 + 3 * v61 + v63++) = v66;
      float v64 = (_OWORD *)((char *)v64 + 8);
    }
    while (v63 != 3);
    ++v61;
    float v62 = (long long *)((char *)v62 + 24);
  }
  while (v61 != 3);
  long long v69 = v85;
  *(_OWORD *)(a3 + 32) = v84;
  *(_OWORD *)(a3 + 48) = v69;
  *(void *)(a3 + 64) = v86;
  long long v70 = v83;
  *(_OWORD *)a3 = v82;
  *(_OWORD *)(a3 + 16) = v70;
  sub_100003224((uint64_t)&v122);
  sub_100003224((uint64_t)&v125);
  sub_100003224((uint64_t)&v130);
  return 0;
}

void sub_100039F24(_Unwind_Exception *a1)
{
  sub_100003224((uint64_t)&STACK[0xA20]);
  sub_100003224(v1 - 240);
  sub_100003224(v1 - 208);
  _Unwind_Resume(a1);
}

uint64_t sub_100039FBC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  sub_10003ADCC((uint64_t)&v30, *(void *)(a1 + 8), 3, *(_DWORD *)(a1 + 20), 1);
  double v30 = &off_100095BC8;
  uint64_t v5 = v33;
  if (v32) {
    BOOL v6 = v33 == 0;
  }
  else {
    BOOL v6 = 1;
  }
  if (v6) {
    __assert_rtn("operator()", "Matrix.hpp", 119, "row < m_rows && col < m_cols");
  }
  if (v32 <= 1) {
    __assert_rtn("operator()", "Matrix.hpp", 119, "row < m_rows && col < m_cols");
  }
  if (v32 == 2) {
    __assert_rtn("operator()", "Matrix.hpp", 119, "row < m_rows && col < m_cols");
  }
  uint64_t v7 = 0;
  int v8 = v31;
  float v9 = &v31[v33];
  double v10 = &v31[2 * v33];
  double v11 = 0.0;
  double v12 = 0.0;
  do
  {
    v8[v7] = v8[v7] / v10[v7];
    v9[v7] = v9[v7] / v10[v7];
    v10[v7] = 1.0;
    double v11 = v11 + v8[v7];
    double v12 = v12 + v9[v7++];
  }
  while (v5 != v7);
  unsigned int v13 = *(_DWORD *)(a2 + 16);
  if (!v13 || (uint64_t v14 = *(unsigned int *)(a2 + 20), !v14)) {
    __assert_rtn("operator()", "Matrix.hpp", 119, "row < m_rows && col < m_cols");
  }
  if (v13 <= 1) {
    __assert_rtn("operator()", "Matrix.hpp", 119, "row < m_rows && col < m_cols");
  }
  if (v13 == 2) {
    __assert_rtn("operator()", "Matrix.hpp", 119, "row < m_rows && col < m_cols");
  }
  double v15 = v11 / (double)v5;
  uint64_t v16 = *(double **)(a2 + 8);
  double v17 = 0.0;
  uint64_t v18 = v31;
  int v19 = v5;
  double v20 = v12 / (double)v5;
  do
  {
    double v21 = *v18 - v15;
    *uint64_t v16 = v21;
    double v22 = v18[v5] - v20;
    v16[v14] = v22;
    double v23 = sqrt(v22 * v22 + v21 * v21);
    v16[(2 * v14)] = v23;
    double v17 = v17 + v23;
    ++v16;
    ++v18;
    --v19;
  }
  while (v19);
  double v24 = 1.41421356 / (v17 / (double)v5);
  *(double *)a3 = v24;
  *(void *)(a3 + 8) = 0;
  *(double *)(a3 + 16) = -(v24 * v15);
  *(void *)(a3 + 24) = 0;
  *(double *)(a3 + 32) = v24;
  *(double *)(a3 + 40) = -(v24 * v20);
  *(void *)(a3 + 48) = 0;
  *(void *)(a3 + 56) = 0;
  *(void *)(a3 + 64) = 0x3FF0000000000000;
  sub_100005A18(a3, (uint64_t)&v30, (uint64_t)&v26);
  sub_100004500(a2, v28, v29);
  memcpy(*(void **)(a2 + 8), __src, 8 * *(unsigned int *)(a2 + 16) * (unint64_t)*(unsigned int *)(a2 + 20));
  sub_100003224((uint64_t)&v26);
  sub_100003224((uint64_t)&v30);
  return 0;
}

void sub_10003A27C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13)
{
}

uint64_t sub_10003A2B8@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  bzero(a3, 0x288uLL);
  uint64_t v6 = 0;
  uint64_t v7 = *(unsigned int *)(a1 + 16);
  unint64_t v8 = *(unsigned int *)(a2 + 16);
  int v9 = *(_DWORD *)(a2 + 20);
  uint64_t v10 = *(void *)(a2 + 8);
  do
  {
    if (v6 == v7 || (int v11 = *(_DWORD *)(a1 + 20)) == 0) {
      sub_1000741C0();
    }
    unint64_t v12 = 0;
    uint64_t v13 = *(void *)(a1 + 8) + 8 * (v11 * v6);
    do
    {
      if (v12 >= v8 || !v9) {
        sub_1000741C0();
      }
      uint64_t v14 = (double *)(v10 + 8 * (v9 * v12));
      double v15 = 0.0;
      LODWORD(result) = v11;
      double v17 = (double *)v13;
      do
      {
        double v18 = *v17++;
        double v19 = v18;
        double v20 = *v14++;
        double v15 = v15 + v19 * v20;
        uint64_t result = (result - 1);
      }
      while (result);
      *((double *)a3 + 9 * v6 + v12++) = v15;
    }
    while (v12 != 9);
    ++v6;
  }
  while (v6 != 9);
  return result;
}

uint64_t sub_10003A384(void *__src, void *a2, double *a3, double *a4)
{
  memcpy(__dst, __src, sizeof(__dst));
  uint64_t v10 = &__dst[1];
  int v11 = &__dst[9];
  for (uint64_t i = 1; i != 9; ++i)
  {
    uint64_t v13 = 0;
    uint64_t v14 = v10;
    do
    {
      *(double *)v7.i64 = v11[v13];
      v8.i64[0] = *(uint64_t *)v14;
      v11[v13] = *v14;
      *uint64_t v14 = *(double *)v7.i64;
      v14 += 9;
      ++v13;
    }
    while (i != v13);
    ++v10;
    v11 += 9;
  }
  sub_100006BC0(9, __dst, a2, a3, a4, v7, v8, v9);
  double v15 = a2 + 1;
  uint64_t v16 = a2 + 9;
  for (uint64_t j = 1; j != 9; ++j)
  {
    uint64_t v18 = 0;
    double v19 = v15;
    do
    {
      uint64_t v20 = v16[v18];
      v16[v18] = *v19;
      *double v19 = v20;
      v19 += 9;
      ++v18;
    }
    while (j != v18);
    ++v15;
    v16 += 9;
  }
  return 0;
}

uint64_t sub_10003A480(unsigned int a1, uint64_t a2, uint64_t a3)
{
  unsigned int v3 = *(_DWORD *)(a3 + 20);
  if (v3)
  {
    unsigned int v6 = 0;
    float v7 = (float)a1;
    do
    {
      unsigned int v8 = (float)(sub_100031230(a2) * v7);
      if (v6)
      {
        uint64_t v9 = 0;
        while (*(_DWORD *)(*(void *)(a3 + 8) + 4 * v9) != v8)
        {
          if (v6 == ++v9) {
            goto LABEL_10;
          }
        }
      }
      else
      {
        LODWORD(v9) = 0;
      }
      if (v9 == v6) {
LABEL_10:
      }
        *(_DWORD *)(*(void *)(a3 + 8) + 4 * v6++) = v8;
    }
    while (v6 < v3);
  }
  return 0;
}

uint64_t sub_10003A524(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unsigned int *a5, double a6)
{
  sub_1000032CC((uint64_t)v52, 1, *(_DWORD *)(a2 + 20));
  v52[0] = &off_100095AB0;
  if (*(_DWORD *)(a2 + 20))
  {
    unint64_t v12 = 0;
    do
    {
      sub_100015A0C(a2, v12, &v41);
      sub_100015A0C(a3, v12, &v49);
      uint64_t v13 = 0;
      uint64_t v46 = 0;
      uint64_t v47 = 0;
      uint64_t v14 = (double *)a1;
      uint64_t v48 = 0;
      do
      {
        uint64_t v15 = 0;
        double v16 = 0.0;
        double v17 = v14;
        do
        {
          double v18 = *v17;
          v17 += 3;
          double v16 = v16 + *(double *)((char *)&v49 + v15) * v18;
          v15 += 8;
        }
        while (v15 != 24);
        *((double *)&v46 + v13++) = v16;
        ++v14;
      }
      while (v13 != 3);
      uint64_t v19 = 0;
      double v20 = 0.0;
      do
      {
        double v20 = v20 + *(double *)((char *)&v46 + v19) * *(double *)((char *)&v41 + v19);
        v19 += 8;
      }
      while (v19 != 24);
      *(double *)(v52[1] + 8 * v12++) = v20;
    }
    while (v12 < *(unsigned int *)(a2 + 20));
  }
  sub_100005A18(a1, a2, (uint64_t)&v49);
  uint64_t v21 = 0;
  uint64_t v45 = 0;
  long long v43 = 0u;
  long long v44 = 0u;
  long long v41 = 0u;
  long long v42 = 0u;
  double v22 = &v41;
  do
  {
    uint64_t v23 = 0;
    double v24 = v22;
    do
    {
      *(void *)double v24 = *(void *)(a1 + v23);
      double v24 = (long long *)((char *)v24 + 24);
      v23 += 8;
    }
    while (v23 != 24);
    ++v21;
    double v22 = (long long *)((char *)v22 + 8);
    a1 += 24;
  }
  while (v21 != 3);
  sub_100005A18((uint64_t)&v41, a3, (uint64_t)&v46);
  sub_100028CF0((uint64_t)&v49, (uint64_t)&v49);
  sub_100028CF0((uint64_t)&v46, (uint64_t)&v46);
  sub_10002868C((uint64_t)v52, (uint64_t)v52, (uint64_t)v38);
  LODWORD(v42) = 1;
  DWORD1(v42) = v51;
  int v35 = 1;
  unsigned int v36 = v51;
  char v37 = 0;
  *(void *)&long long v41 = off_100095A80;
  *((void *)&v41 + 1) = 0;
  BYTE8(v42) = 0;
  v34[0] = &off_100095AB0;
  v34[1] = v50;
  sub_100003224((uint64_t)&v41);
  LODWORD(v42) = 1;
  DWORD1(v42) = v51;
  int v31 = 1;
  unsigned int v32 = v51;
  char v33 = 0;
  *(void *)&long long v41 = off_100095A80;
  *((void *)&v41 + 1) = 0;
  BYTE8(v42) = 0;
  int v29 = &off_100095AB0;
  uint64_t v30 = v50 + 8 * v51;
  sub_100003224((uint64_t)&v41);
  sub_10003AEA0((uint64_t)v34, (uint64_t)&v29);
  sub_100003224((uint64_t)&v29);
  LODWORD(v42) = 1;
  DWORD1(v42) = HIDWORD(v48);
  int v31 = 1;
  unsigned int v32 = HIDWORD(v48);
  char v33 = 0;
  *(void *)&long long v41 = off_100095A80;
  *((void *)&v41 + 1) = 0;
  BYTE8(v42) = 0;
  int v29 = &off_100095AB0;
  uint64_t v30 = v47;
  sub_100003224((uint64_t)&v41);
  sub_10003AEA0((uint64_t)v34, (uint64_t)&v29);
  sub_100003224((uint64_t)&v29);
  LODWORD(v42) = 1;
  DWORD1(v42) = HIDWORD(v48);
  int v31 = 1;
  unsigned int v32 = HIDWORD(v48);
  char v33 = 0;
  *(void *)&long long v41 = off_100095A80;
  *((void *)&v41 + 1) = 0;
  BYTE8(v42) = 0;
  int v29 = &off_100095AB0;
  uint64_t v30 = v47 + 8 * HIDWORD(v48);
  sub_100003224((uint64_t)&v41);
  sub_10003AEA0((uint64_t)v34, (uint64_t)&v29);
  sub_100003224((uint64_t)&v29);
  sub_100028BBC((uint64_t)v38, (uint64_t)v34);
  *a5 = 0;
  unint64_t v25 = v40;
  if (v40)
  {
    unsigned int v26 = 0;
    unint64_t v27 = 0;
    do
    {
      if (fabs(*(double *)(v39 + 8 * v27)) < a6)
      {
        *(_DWORD *)(*(void *)(a4 + 8) + 4 * v26) = v27;
        unsigned int v26 = *a5 + 1;
        *a5 = v26;
        unint64_t v25 = v40;
      }
      ++v27;
    }
    while (v27 < v25);
  }
  sub_100003224((uint64_t)v34);
  sub_100003224((uint64_t)v38);
  sub_100003224((uint64_t)&v46);
  sub_100003224((uint64_t)&v49);
  sub_100003224((uint64_t)v52);
  return 0;
}

void sub_10003A948(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,char a31)
{
  sub_100003224((uint64_t)&a13);
  sub_100003224((uint64_t)&a17);
  sub_100003224((uint64_t)&a31);
  sub_100003224(v31 - 160);
  sub_100003224(v31 - 128);
  _Unwind_Resume(a1);
}

uint64_t sub_10003A9B8(uint64_t a1, uint64_t a2, unsigned int a3, unsigned int a4, unsigned int a5, int a6, int a7, uint64_t a8, double a9, double a10, uint64_t a11, unsigned int *a12)
{
  unsigned int v20 = *(_DWORD *)(a1 + 20);
  sub_1000311D4(v45, a6);
  unsigned int v21 = 0;
  char v32 = 0;
  *a12 = 0;
  uint64_t v44 = 0;
  BOOL v43 = 0;
  double v22 = 1.0;
  do
  {
    if (v22 <= (double)v21) {
      break;
    }
    unsigned int v34 = v21;
    uint64_t v42 = 0;
    int v23 = 1;
    unsigned int v24 = 1;
    memset(v41, 0, sizeof(v41));
    while (v23)
    {
      sub_10002A7E4((uint64_t)&v37, 1, a3);
      char v37 = &off_1000964F8;
      sub_10003A480(v20, (uint64_t)v45, (uint64_t)&v37);
      if (!a7) {
        goto LABEL_13;
      }
      if (a3)
      {
        uint64_t v25 = (v40 * v39);
        unsigned int v26 = (unsigned int *)__src;
        uint64_t v27 = a3;
        while (1)
        {
          if (!v25 || (uint64_t v28 = *v26, *(_DWORD *)(a8 + 20) * *(_DWORD *)(a8 + 16) <= v28)) {
            __assert_rtn("operator()", "Matrix.hpp", 131, "index < m_rows * m_cols");
          }
          if (*(unsigned char *)(*(void *)(a8 + 8) + v28)) {
            break;
          }
          --v25;
          ++v26;
          if (!--v27) {
            goto LABEL_12;
          }
        }
LABEL_13:
        sub_1000032CC((uint64_t)v36, 3, a3);
        *(void *)unsigned int v36 = &off_100095BC8;
        sub_1000032CC((uint64_t)v35, 3, a3);
        v35[0] = &off_100095BC8;
        sub_10002A73C((uint64_t)v36, a1, (uint64_t)&v37);
        sub_10002A73C((uint64_t)v35, a2, (uint64_t)&v37);
        sub_1000390B8((uint64_t)v36, (uint64_t)v35, (uint64_t)v41, &v43, (double *)&v44, a10);
        if (v43) {
          int v23 = 0;
        }
        else {
          int v23 = a7;
        }
        sub_100003224((uint64_t)v35);
        sub_100003224((uint64_t)v36);
        goto LABEL_17;
      }
LABEL_12:
      int v23 = 1;
LABEL_17:
      ++v24;
      sub_100013234((uint64_t)&v37);
      if (v24 > a4) {
        break;
      }
    }
    sub_10002A7E4((uint64_t)&v37, 1, *(_DWORD *)(a1 + 20));
    char v37 = &off_1000964F8;
    v36[0] = 0;
    sub_10003A524((uint64_t)v41, a1, a2, (uint64_t)&v37, v36, a9);
    unsigned int v29 = v36[0];
    if (v36[0] > *a12)
    {
      sub_100004758(a11, v39, v40);
      memcpy(*(void **)(a11 + 8), __src, 4 * *(unsigned int *)(a11 + 16) * (unint64_t)*(unsigned int *)(a11 + 20));
      *a12 = v29;
      long double v30 = pow((double)v29 / (double)v20, (double)a3);
      char v32 = 1;
      double v22 = -6.90775528 / log(fmin(fmax(1.0 - v30, 2.22e-16), 1.0));
    }
    unsigned int v21 = v34 + 1;
    sub_100013234((uint64_t)&v37);
  }
  while (v34 + 1 <= a5);
  nullsub_13(v45);
  return (v32 & 1u) - 1;
}

void sub_10003AD40(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,char a38)
{
}

void sub_10003AD94(uint64_t a1)
{
  sub_100003224(a1);

  operator delete();
}

uint64_t sub_10003ADCC(uint64_t result, uint64_t a2, int a3, int a4, char a5)
{
  *(void *)uint64_t result = off_100095A80;
  if (a5) {
    operator new[]();
  }
  *(void *)(result + 8) = a2;
  *(_DWORD *)(result + 16) = a3;
  *(_DWORD *)(result + 20) = a4;
  *(unsigned char *)(result + 24) = a5;
  return result;
}

double sub_10003AEA0(uint64_t a1, uint64_t a2)
{
  int v2 = *(_DWORD *)(a2 + 20);
  if (v2 != *(_DWORD *)(a1 + 20) || (int v3 = *(_DWORD *)(a2 + 16), v3 != *(_DWORD *)(a1 + 16))) {
    sub_100075C84();
  }
  unsigned int v4 = v3 * v2;
  if (v4)
  {
    uint64_t v5 = *(double **)(a1 + 8);
    unsigned int v6 = &v5[v4];
    float v7 = *(double **)(a2 + 8);
    do
    {
      double v8 = *v7++;
      double result = *v5 + v8;
      *v5++ = result;
    }
    while (v5 < v6);
  }
  return result;
}

void sub_10003AF04(_DWORD *a1, int a2, int a3, uint64_t a4, int a5, int a6)
{
  a1[10] = a2;
  a1[11] = a6;
  a1[8] = a5 + a3 * a6;
  a1[9] = a3;
  sub_10003AF9C();
}

void sub_10003AF9C()
{
}

double sub_10003B060(_OWORD *a1)
{
  double result = 0.0;
  a1[1] = 0u;
  a1[2] = 0u;
  *a1 = 0u;
  return result;
}

double sub_10003B070(void *a1)
{
  if (*a1) {
    operator delete[]();
  }
  if (a1[1]) {
    operator delete[]();
  }
  if (a1[2]) {
    operator delete[]();
  }
  if (a1[3]) {
    operator delete[]();
  }
  double result = 0.0;
  *(_OWORD *)a1 = 0u;
  *((_OWORD *)a1 + 1) = 0u;
  return result;
}

void *sub_10003B108(void *a1)
{
  return a1;
}

void *sub_10003B130(void *result, int a2, int a3, double a4)
{
  uint64_t v4 = result[3];
  int v5 = *(_DWORD *)(v4 + 4 * a3) + *(_DWORD *)(result[2] + 4 * a3);
  uint64_t v6 = result[1];
  *(double *)(*result + 8 * v5) = a4;
  *(_DWORD *)(v6 + 4 * v5) = a2;
  ++*(_DWORD *)(v4 + 4 * a3);
  return result;
}

uint64_t sub_10003B15C(uint64_t result, int a2, unint64_t a3)
{
  unint64_t v3 = *(int *)(result + 44);
  if (v3 < a3) {
    sub_100076748();
  }
  *(_DWORD *)(result + 40) += a2;
  *(_DWORD *)(result + 44) = v3 - a3;
  return result;
}

uint64_t sub_10003B190(uint64_t result, int a2, int a3)
{
  int v3 = *(_DWORD *)(result + 36);
  int v4 = *(_DWORD *)(result + 44) + a3;
  *(_DWORD *)(result + 40) -= a2;
  *(_DWORD *)(result + 44) = v4;
  if (v3 >= 1)
  {
    uint64_t v5 = 0;
    uint64_t v6 = *(void *)(result + 24);
    do
      *(_DWORD *)(v6 + 4 * v5++) -= a3;
    while (v5 < *(int *)(result + 36));
  }
  return result;
}

uint64_t sub_10003B1D4(uint64_t a1)
{
  return *(int *)(a1 + 40);
}

uint64_t sub_10003B1DC(uint64_t a1)
{
  return *(int *)(a1 + 36);
}

void *sub_10003B1E4@<X0>(uint64_t *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  double result = (void *)sub_1000032CC(a3, 1, *((_DWORD *)a1 + 9));
  *double result = &off_100095AB0;
  uint64_t v6 = *((unsigned int *)a1 + 9);
  if ((int)v6 >= 1)
  {
    uint64_t v7 = 0;
    uint64_t v8 = a1[2];
    uint64_t v9 = a1[3];
    do
    {
      *(void *)(result[1] + 8 * v7) = 0;
      uint64_t v10 = *(int *)(v9 + 4 * v7);
      if ((int)v10 >= 1)
      {
        uint64_t v11 = *(int *)(v8 + 4 * v7);
        uint64_t v12 = v10 + v11;
        uint64_t v13 = *a1;
        uint64_t v14 = a1[1];
        do
        {
          *(double *)(result[1] + 8 * v7) = *(double *)(result[1] + 8 * v7)
                                          + *(double *)(v13 + 8 * v11)
                                          * *(double *)(*(void *)(a2 + 8) + 8 * *(unsigned int *)(v14 + 4 * v11));
          ++v11;
        }
        while (v11 < v12);
      }
      ++v7;
    }
    while (v7 != v6);
  }
  return result;
}

void sub_10003B2A0(uint64_t *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  sub_1000032CC(a3, 1, *((_DWORD *)a1 + 10));
  *(void *)a3 = &off_100095AB0;
  bzero(*(void **)(a3 + 8), 8 * (*(_DWORD *)(a3 + 20) * *(_DWORD *)(a3 + 16)));
  uint64_t v6 = *((unsigned int *)a1 + 9);
  if ((int)v6 >= 1)
  {
    uint64_t v7 = 0;
    uint64_t v8 = a1[2];
    uint64_t v9 = a1[3];
    do
    {
      uint64_t v10 = *(int *)(v9 + 4 * v7);
      if ((int)v10 >= 1)
      {
        uint64_t v11 = *(int *)(v8 + 4 * v7);
        uint64_t v12 = v10 + v11;
        uint64_t v13 = *a1;
        uint64_t v14 = a1[1];
        do
        {
          *(double *)(*(void *)(a3 + 8) + 8 * *(unsigned int *)(v14 + 4 * v11)) = *(double *)(*(void *)(a3 + 8)
                                                                                                + 8
                                                                                                * *(unsigned int *)(v14 + 4 * v11))
                                                                                    + *(double *)(v13 + 8 * v11)
                                                                                    * *(double *)(*(void *)(a2 + 8)
                                                                                                + 8 * v7);
          ++v11;
        }
        while (v11 < v12);
      }
      ++v7;
    }
    while (v7 != v6);
  }
}

void *sub_10003B374(void *result, int a2)
{
  uint64_t v2 = *(int *)(result[3] + 4 * a2);
  if (v2)
  {
    uint64_t v3 = *(int *)(result[2] + 4 * a2);
    int v4 = (uint64_t *)(*result + 8 * v3);
    uint64_t v5 = (uint64_t *)(8 * v2 + 8 * v3 + *result - 8);
    do
    {
      if (v5 == v4) {
        break;
      }
      uint64_t v6 = *v4;
      *v4++ = *v5;
      BOOL v7 = v5 == v4;
      *v5-- = v6;
    }
    while (!v7);
    uint64_t v8 = result[1];
    uint64_t v9 = (int *)(v8 + 4 * v3);
    uint64_t v10 = (int *)(4 * v2 + 4 * v3 + v8 - 4);
    do
    {
      if (v10 == v9) {
        break;
      }
      int v11 = *v9;
      *v9++ = *v10;
      BOOL v7 = v10 == v9;
      *v10-- = v11;
    }
    while (!v7);
  }
  return result;
}

double sub_10003B3FC@<D0>(uint64_t *a1@<X0>, int a2@<W1>, uint64_t a3@<X8>)
{
  sub_1000032CC(a3, 1, *((_DWORD *)a1 + 10));
  *(void *)a3 = &off_100095AB0;
  bzero(*(void **)(a3 + 8), 8 * (*(_DWORD *)(a3 + 20) * *(_DWORD *)(a3 + 16)));
  uint64_t v7 = *(int *)(a1[3] + 4 * a2);
  if ((int)v7 >= 1)
  {
    uint64_t v8 = a1[1];
    uint64_t v9 = *(int *)(a1[2] + 4 * a2);
    uint64_t v10 = v7 + v9;
    uint64_t v11 = *a1;
    do
    {
      double result = *(double *)(v11 + 8 * v9);
      *(double *)(*(void *)(a3 + 8) + 8 * *(unsigned int *)(v8 + 4 * v9++)) = result;
    }
    while (v9 < v10);
  }
  return result;
}

uint64_t sub_10003B4AC@<X0>(uint64_t result@<X0>, int a2@<W1>, uint64_t a3@<X8>)
{
  int v3 = *(_DWORD *)(result + 40);
  int v4 = *(_DWORD *)(*(void *)(result + 24) + 4 * a2);
  uint64_t v5 = *(int *)(*(void *)(result + 16) + 4 * a2);
  uint64_t v6 = *(void *)(result + 8) + 4 * v5;
  uint64_t v7 = *(void *)result + 8 * v5;
  *(_DWORD *)(a3 + 16) = v4;
  *(_DWORD *)(a3 + 20) = v4;
  *(_DWORD *)(a3 + 24) = v3;
  *(unsigned char *)(a3 + 28) = 0;
  *(_DWORD *)(a3 + 32) = 0;
  *(void *)a3 = v7;
  *(void *)(a3 + 8) = v6;
  *(void *)(a3 + 40) = 0;
  *(void *)(a3 + 48) = 0;
  return result;
}

uint64_t sub_10003B4E4(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(unsigned int *)(result + 36);
  if (v2 != *(_DWORD *)(result + 40)) {
    sub_100076774();
  }
  if ((int)v2 >= 1)
  {
    uint64_t v3 = 0;
    uint64_t v4 = *(void *)(a2 + 8);
    double v5 = *(double *)result;
    uint64_t v6 = *(void *)(result + 16);
    uint64_t v7 = *(void *)(result + 24);
    uint64_t v8 = v4 + 8;
    uint64_t v9 = *(void *)result + 8;
    do
    {
      uint64_t v10 = *(int *)(v6 + 4 * v3);
      double v11 = *(double *)(v4 + 8 * v3) / *(double *)(*(void *)&v5 + 8 * v10);
      *(double *)(v4 + 8 * v3) = v11;
      uint64_t v12 = *(unsigned int *)(v7 + 4 * v3);
      if ((int)v12 >= 2)
      {
        uint64_t v13 = (double *)(v9 + 8 * v10);
        uint64_t v14 = v12 - 1;
        double result = v8;
        do
        {
          double v15 = *v13++;
          *(double *)double result = *(double *)result - v15 * v11;
          result += 8;
          --v14;
        }
        while (v14);
      }
      ++v3;
      v8 += 8;
    }
    while (v3 != v2);
  }
  return result;
}

void sub_10003B57C(uint64_t a1)
{
}

void sub_10003B590(uint64_t a1, int a2, int a3)
{
  *(_DWORD *)(a1 + 16) = a3;
  *(_DWORD *)(a1 + 20) = 0;
  *(_DWORD *)(a1 + 24) = a2;
  *(unsigned char *)(a1 + 28) = 1;
  *(_DWORD *)(a1 + 32) = 0;
  operator new[]();
}

uint64_t sub_10003B668(uint64_t result)
{
  if (*(unsigned char *)(result + 28))
  {
    if (*(void *)(result + 8)) {
      operator delete[]();
    }
    if (*(void *)result) {
      operator delete[]();
    }
  }
  if (*(void *)(result + 48)) {
    operator delete[]();
  }
  if (*(void *)(result + 40)) {
    operator delete[]();
  }
  return result;
}

uint64_t sub_10003B708(uint64_t a1, uint64_t a2)
{
  if (!*(unsigned char *)(a1 + 28)) {
    sub_1000767A0();
  }
  if (*(_DWORD *)(a1 + 16) < *(_DWORD *)(a2 + 16))
  {
    if (*(void *)(a1 + 8)) {
      operator delete[]();
    }
    if (*(void *)a1) {
      operator delete[]();
    }
    if (*(void *)(a1 + 48)) {
      operator delete[]();
    }
    if (*(void *)(a1 + 40)) {
      operator delete[]();
    }
    *(_DWORD *)(a1 + 16) = *(_DWORD *)(a2 + 16);
    *(_DWORD *)(a1 + 24) = *(_DWORD *)(a2 + 24);
    operator new[]();
  }
  memcpy(*(void **)(a1 + 8), *(const void **)(a2 + 8), 4 * *(int *)(a2 + 20));
  memcpy(*(void **)a1, *(const void **)a2, 8 * *(int *)(a2 + 20));
  *(void *)(a1 + 20) = *(void *)(a2 + 20);
  return a1;
}

uint64_t sub_10003B898(uint64_t result, uint64_t a2)
{
  int v2 = 0;
  LODWORD(i) = 0;
  uint64_t v4 = *(int **)(result + 8);
  int v5 = *(_DWORD *)(result + 20);
  double v6 = 0.0;
  uint64_t v7 = *(int **)(a2 + 8);
  while (2)
  {
    int v8 = *v7;
LABEL_3:
    int v9 = *v4;
    ++v7;
    for (uint64_t i = (int)i; ; ++i)
    {
      if (v9 < v8)
      {
        if (++v2 >= v5) {
          return result;
        }
        --v7;
        ++v4;
        goto LABEL_3;
      }
      if (v8 >= v9) {
        break;
      }
      if ((int)i + 1 >= v5) {
        return result;
      }
      int v10 = *v7++;
      int v8 = v10;
    }
    double v6 = v6 + *(double *)(*(void *)result + 8 * v2++) * *(double *)(*(void *)a2 + 8 * i);
    if (v2 < v5)
    {
      LODWORD(i) = i + 1;
      if ((int)i < *(_DWORD *)(a2 + 20))
      {
        ++v4;
        continue;
      }
    }
    return result;
  }
}

uint64_t sub_10003B938(uint64_t result, uint64_t a2, double a3)
{
  if (!*(unsigned char *)(result + 28)) {
    sub_1000767CC();
  }
  *(_DWORD *)(result + 32) = 0;
  uint64_t v3 = *(int *)(a2 + 20);
  uint64_t v4 = *(double **)result;
  int v5 = *(int **)(result + 8);
  uint64_t v6 = *(int *)(result + 20);
  unint64_t v7 = *(void *)result + 8 * v6;
  int v8 = *(double **)a2;
  int v9 = *(int **)(a2 + 8);
  unint64_t v10 = *(void *)a2 + 8 * v3;
  int v11 = 0;
  if ((int)v6 >= 1 && (int)v3 >= 1)
  {
    int v13 = *v9;
    int v14 = *v5;
    double v15 = *(double **)result;
    double v16 = *(_DWORD **)(result + 8);
    while (1)
    {
      if (v14 == v13)
      {
        if (*(_DWORD *)(result + 24) <= v13 || v11 >= *(_DWORD *)(result + 16)) {
          sub_1000767F8();
        }
        double v17 = *v15++;
        double v18 = *v8;
        uint64_t v19 = *(void *)(result + 40);
        *(_DWORD *)(*(void *)(result + 48) + 4 * v11) = v13;
        uint64_t v20 = *(int *)(result + 32);
        *(double *)(v19 + 8 * v20) = v17 + a3 * v18;
        int v11 = v20 + 1;
        *(_DWORD *)(result + 32) = v11;
        LODWORD(v17) = v16[1];
        ++v16;
        int v14 = LODWORD(v17);
      }
      else
      {
        if (v14 < v13)
        {
          if (*(_DWORD *)(result + 24) <= v14 || v11 >= *(_DWORD *)(result + 16)) {
            sub_1000767F8();
          }
          double v21 = *v15++;
          uint64_t v22 = *(void *)(result + 40);
          *(_DWORD *)(*(void *)(result + 48) + 4 * v11) = v14;
          uint64_t v23 = *(int *)(result + 32);
          *(double *)(v22 + 8 * v23) = v21;
          int v11 = v23 + 1;
          *(_DWORD *)(result + 32) = v11;
          LODWORD(v21) = v16[1];
          ++v16;
          int v14 = LODWORD(v21);
          goto LABEL_20;
        }
        if (*(_DWORD *)(result + 24) <= v13 || v11 >= *(_DWORD *)(result + 16)) {
          sub_1000767F8();
        }
        double v24 = *v8 * a3;
        uint64_t v25 = *(void *)(result + 40);
        *(_DWORD *)(*(void *)(result + 48) + 4 * v11) = v13;
        uint64_t v26 = *(int *)(result + 32);
        *(double *)(v25 + 8 * v26) = v24;
        int v11 = v26 + 1;
        *(_DWORD *)(result + 32) = v11;
      }
      ++v8;
      int v27 = v9[1];
      ++v9;
      int v13 = v27;
LABEL_20:
      if ((unint64_t)v15 >= v7 || (unint64_t)v8 >= v10) {
        goto LABEL_26;
      }
    }
  }
  double v16 = *(_DWORD **)(result + 8);
  double v15 = *(double **)result;
LABEL_26:
  while ((unint64_t)v15 < v7)
  {
    if (*(_DWORD *)(result + 24) <= *v16 || v11 >= *(_DWORD *)(result + 16)) {
      sub_1000767F8();
    }
    double v28 = *v15++;
    uint64_t v29 = *(void *)(result + 40);
    *(_DWORD *)(*(void *)(result + 48) + 4 * v11) = *v16;
    uint64_t v30 = *(int *)(result + 32);
    *(double *)(v29 + 8 * v30) = v28;
    int v11 = v30 + 1;
    *(_DWORD *)(result + 32) = v11;
    ++v16;
  }
  if ((unint64_t)v8 >= v10)
  {
    uint64_t v33 = *(void *)(result + 40);
    uint64_t v32 = *(void *)(result + 48);
  }
  else
  {
    do
    {
      if (*(_DWORD *)(result + 24) <= *v9 || v11 >= *(_DWORD *)(result + 16)) {
        sub_1000767F8();
      }
      double v31 = *v8++;
      uint64_t v33 = *(void *)(result + 40);
      uint64_t v32 = *(void *)(result + 48);
      *(_DWORD *)(v32 + 4 * v11) = *v9;
      uint64_t v34 = *(int *)(result + 32);
      *(double *)(v33 + 8 * v34) = v31 * a3;
      int v11 = v34 + 1;
      *(_DWORD *)(result + 32) = v11;
      ++v9;
    }
    while ((unint64_t)v8 < v10);
  }
  *(void *)double result = v33;
  *(void *)(result + 8) = v32;
  *(void *)(result + 40) = v4;
  *(void *)(result + 48) = v5;
  *(_DWORD *)(result + 20) = v11;
  return result;
}

double sub_10003BB3C(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(unsigned int *)(a2 + 20);
  if ((int)v2 >= 1)
  {
    uint64_t v3 = *(double **)a2;
    uint64_t v4 = *(_DWORD **)(a2 + 8);
    do
    {
      double v5 = *v3++;
      double v6 = v5;
      LODWORD(v5) = *v4++;
      uint64_t v7 = *(void *)(a1 + 8);
      double result = v6 + *(double *)(v7 + 8 * LODWORD(v5));
      *(double *)(v7 + 8 * LODWORD(v5)) = result;
      --v2;
    }
    while (v2);
  }
  return result;
}

void *sub_10003BB70(void *a1, uint64_t a2, uint64_t a3)
{
  std::ostream::sentry::sentry();
  if (v13)
  {
    uint64_t v6 = (uint64_t)a1 + *(void *)(*a1 - 24);
    uint64_t v7 = *(void *)(v6 + 40);
    int v8 = *(_DWORD *)(v6 + 8);
    int v9 = *(_DWORD *)(v6 + 144);
    if (v9 == -1)
    {
      std::ios_base::getloc((const std::ios_base *)((char *)a1 + *(void *)(*a1 - 24)));
      unint64_t v10 = std::locale::use_facet(&v14, &std::ctype<char>::id);
      int v9 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v10->__vftable[2].~facet_0)(v10, 32);
      std::locale::~locale(&v14);
      *(_DWORD *)(v6 + 144) = v9;
    }
    if ((v8 & 0xB0) == 0x20) {
      uint64_t v11 = a2 + a3;
    }
    else {
      uint64_t v11 = a2;
    }
    if (!sub_10003BD14(v7, a2, v11, a2 + a3, v6, (char)v9)) {
      std::ios_base::clear((std::ios_base *)((char *)a1 + *(void *)(*a1 - 24)), *(_DWORD *)((char *)a1 + *(void *)(*a1 - 24) + 32) | 5);
    }
  }
  std::ostream::sentry::~sentry();
  return a1;
}

void sub_10003BCAC(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, std::locale a12)
{
  std::ostream::sentry::~sentry();
  __cxa_begin_catch(a1);
  std::ios_base::__set_badbit_and_consider_rethrow((std::ios_base *)((char *)v12 + *(void *)(*v12 - 24)));
  __cxa_end_catch();
  JUMPOUT(0x10003BC8CLL);
}

void sub_10003BD00(_Unwind_Exception *a1)
{
}

uint64_t sub_10003BD14(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int __c)
{
  uint64_t v6 = a1;
  if (a1)
  {
    uint64_t v11 = *(void *)(a5 + 24);
    if (v11 <= a4 - a2) {
      int64_t v12 = 0;
    }
    else {
      int64_t v12 = v11 - (a4 - a2);
    }
    if (a3 - a2 >= 1 && (*(uint64_t (**)(uint64_t))(*(void *)a1 + 96))(a1) != a3 - a2) {
      return 0;
    }
    if (v12 >= 1)
    {
      sub_10003BE9C(__p, v12, __c);
      char v13 = v18 >= 0 ? __p : (void **)__p[0];
      uint64_t v14 = (*(uint64_t (**)(uint64_t, void **, int64_t))(*(void *)v6 + 96))(v6, v13, v12);
      if (v18 < 0) {
        operator delete(__p[0]);
      }
      if (v14 != v12) {
        return 0;
      }
    }
    uint64_t v15 = a4 - a3;
    if (v15 < 1 || (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v6 + 96))(v6, a3, v15) == v15) {
      *(void *)(a5 + 24) = 0;
    }
    else {
      return 0;
    }
  }
  return v6;
}

void sub_10003BE80(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void *sub_10003BE9C(void *__b, size_t __len, int __c)
{
  if (__len >= 0x7FFFFFFFFFFFFFF8) {
    sub_1000109C8();
  }
  if (__len >= 0x17)
  {
    size_t v7 = (__len & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((__len | 7) != 0x17) {
      size_t v7 = __len | 7;
    }
    size_t v8 = v7 + 1;
    uint64_t v6 = operator new(v7 + 1);
    __b[1] = __len;
    __b[2] = v8 | 0x8000000000000000;
    *__b = v6;
  }
  else
  {
    *((unsigned char *)__b + 23) = __len;
    uint64_t v6 = __b;
    if (!__len) {
      goto LABEL_9;
    }
  }
  memset(v6, __c, __len);
LABEL_9:
  *((unsigned char *)v6 + __len) = 0;
  return __b;
}

void sub_10003BF48(uint64_t a1, uint64_t a2)
{
  if (!a1) {
    sub_100076824();
  }
  if (!a2) {
    sub_100076850();
  }
  bzero((void *)(a2 + 469808), 0x4424uLL);
  *(_DWORD *)(a2 + 469804) = *(_DWORD *)(a2 + 288);
  int v4 = *(_DWORD *)(a2 + 4);
  switch(v4)
  {
    case 2:
      uint64_t v62 = a1;
      uint64_t v63 = 0;
      sub_10003C40C((uint64_t)&v62, a2);
      break;
    case 4:
      if (*(_DWORD *)(a2 + 696))
      {
        uint64_t v57 = *(unsigned __int16 *)(a2 + 32);
        uint64_t v55 = *(unsigned __int16 *)(a2 + 34);
        if ((v55 * v57) >= 0x81) {
          sub_1000768D4();
        }
        uint64_t v5 = *(unsigned int *)(a2 + 256);
        bzero((void *)(a2 + 427308), 0x3800uLL);
        int v7 = *(unsigned __int16 *)(a2 + 250) - *(unsigned __int16 *)(a2 + 246);
        if (v7)
        {
          int v8 = 0;
          int v9 = *(unsigned __int16 *)(a2 + 260);
          int v10 = *(unsigned __int16 *)(a2 + 262);
          uint64_t v11 = *(unsigned __int16 *)(a2 + 252);
          int v12 = *(unsigned __int16 *)(a2 + 248) - *(unsigned __int16 *)(a2 + 244);
          uint64_t v13 = a1 + v5 + *(unsigned __int16 *)(a2 + 246) * v11 + 2 * *(unsigned __int16 *)(a2 + 244);
          uint64_t v14 = a2 + 427308 + 112 * -(int)v57;
          int v15 = *(__int16 *)(a2 + 712);
          do
          {
            BOOL v16 = v8 == 0;
            if (!v8) {
              int v8 = v10;
            }
            unsigned int v17 = v57;
            if (!v16) {
              unsigned int v17 = 0;
            }
            v14 += 112 * v17;
            if (v12 >= 1)
            {
              uint64_t v18 = 0;
              int v19 = 0;
              uint64_t v20 = v14 - 112;
              int v21 = v12 + 1;
              do
              {
                BOOL v22 = v19 == 0;
                if (!v19) {
                  int v19 = v9;
                }
                v20 += 112 * v22;
                int v23 = *(unsigned __int16 *)(v13 + v18);
                if (v23 != 0x3FFF)
                {
                  int v24 = v23 + v15;
                  unsigned int v25 = v24 ^ (v24 >> 31);
                  unsigned int v26 = 32 - __clz(v25);
                  if (v25) {
                    unsigned int v27 = v26;
                  }
                  else {
                    unsigned int v27 = 0;
                  }
                  int v28 = v27 ^ (v24 >> 31);
                  if (v28 >= 6) {
                    int v29 = 6;
                  }
                  else {
                    int v29 = v28;
                  }
                  int v30 = v29 + 7;
                  if (v28 >= -7) {
                    unsigned int v31 = v30;
                  }
                  else {
                    unsigned int v31 = 0;
                  }
                  int32x2_t v6 = vadd_s32(*(int32x2_t *)(v20 + 8 * v31), (int32x2_t)(*(unsigned __int16 *)(v13 + v18) | 0x100000000));
                  *(int32x2_t *)(v20 + 8 * v31) = v6;
                }
                --v19;
                --v21;
                v18 += 2;
              }
              while (v21 > 1);
            }
            v13 += v11;
            --v8;
            --v7;
          }
          while (v7);
        }
        if (v55)
        {
          for (uint64_t i = 0; i != v55; ++i)
          {
            if (v57)
            {
              uint64_t v33 = 0;
              float v34 = *(float *)(a2 + 292);
              float v35 = *(float *)(a2 + 296);
              float v36 = *(float *)(a2 + 300);
              unsigned int v37 = *(_DWORD *)(a2 + 704);
              do
              {
                uint64_t v38 = 0;
                do
                {
                  uint64_t v61 = 0;
                  uint64_t v58 = v38;
                  if (v38 == 1)
                  {
                    int v39 = 0;
                    BOOL v40 = 0;
                    int v41 = 0;
                    char v42 = 1;
                    float v43 = -255.0;
                    do
                    {
                      int v44 = 0;
                      char v59 = v42;
                      char v45 = 1;
                      do
                      {
                        char v46 = v45;
                        sub_1000464E4(a2, v33, i, v44 - 1, v39 - 1, v44, v39, (float *)&v61 + 1, *(float *)v6.i32, (unsigned int *)&v61);
                        char v45 = 0;
                        *(float *)v6.i32 = v36 * (float)(v35 * (float)(*((float *)&v61 + 1) - v34));
                        if (v43 < *(float *)v6.i32 && v61 >= v37)
                        {
                          float v43 = v36 * (float)(v35 * (float)(*((float *)&v61 + 1) - v34));
                          int v41 = v61;
                          BOOL v40 = v61 >= v37;
                        }
                        int v44 = 1;
                      }
                      while ((v46 & 1) != 0);
                      char v42 = 0;
                      int v39 = 1;
                    }
                    while ((v59 & 1) != 0);
                  }
                  else
                  {
                    if (v38) {
                      int v47 = -1;
                    }
                    else {
                      int v47 = 0;
                    }
                    sub_1000464E4(a2, v33, i, v47, v47, v38 != 0, v38 != 0, (float *)&v61 + 1, *(float *)v6.i32, (unsigned int *)&v61);
                    *(float *)v6.i32 = v35 * (float)(*((float *)&v61 + 1) - v34);
                    float v43 = v36 * *(float *)v6.i32;
                    int v41 = v61;
                    BOOL v40 = v61 >= v37;
                  }
                  *((float *)&v62 + v58) = v43;
                  v64[v58] = v41;
                  v60[v58] = v40;
                  uint64_t v38 = v58 + 1;
                }
                while (v58 != 2);
                v6.i32[0] = v63;
                int v48 = v64[2];
                int v49 = v60[2];
                if (*(unsigned char *)(a2 + 718))
                {
                  uint64_t v50 = 0;
                  char v51 = 2;
                  char v52 = 1;
                  do
                  {
                    char v53 = v52;
                    if (v60[v50] && *(float *)v6.i32 < *((float *)&v62 + v50))
                    {
                      int v48 = v64[v50];
                      LOBYTE(v49) = 1;
                      char v51 = v50;
                      v6.i32[0] = *((_DWORD *)&v62 + v50);
                    }
                    char v52 = 0;
                    uint64_t v50 = 1;
                  }
                  while ((v53 & 1) != 0);
                  v49 &= 1u;
                }
                else
                {
                  char v51 = 2;
                }
                uint64_t v56 = i * v57;
                if (v49) {
                  int v54 = 0xFFFF;
                }
                else {
                  int v54 = 0;
                }
                *(_DWORD *)(a2 + 52 * (v33 + i * v57) + 480048) = v48;
                *(_DWORD *)(a2 + 52 * (v33 + v56) + 480052) = v54;
                *(_DWORD *)(a2 + 52 * (v33 + v56) + 480056) = v6.i32[0];
                *(_DWORD *)(a2 + 52 * (v33 + v56) + 480060) = 0;
                *(_DWORD *)(a2 + 52 * (v33 + v56) + 480064) = 0;
                *(unsigned char *)(a2 + 52 * (v33 + v56) + 480068) = ((40 * v49) | (v51 << 6)) ^ 8;
                ++v33;
              }
              while (v33 != v57);
            }
          }
        }
        sub_10003E8C8(a2);
      }
      break;
    case 3:
      sub_1000768A8();
    default:
      sub_10007687C();
  }
}

uint64_t sub_10003C40C(uint64_t a1, uint64_t a2)
{
  if (*(unsigned __int16 *)(a2 + 34) * *(unsigned __int16 *)(a2 + 32) >= 0x81) {
    sub_100076900();
  }
  unsigned int v500 = *(_DWORD *)(a2 + 8);
  if (v500 >= 2) {
    sub_100076B94();
  }
  int v3 = *(_DWORD *)(a2 + 4);
  if ((v3 - 2) >= 2)
  {
    if (v3 == 4) {
      sub_100076B68();
    }
    sub_10007692C();
  }
  uint64_t v5 = (_DWORD *)(a2 + 12);
  sub_10003EDAC((unsigned int *)(a2 + 12), a1, (uint64_t)&v507);
  sub_10003F2D0(v500, a2, (uint64_t)&v507, v6, v7, v8, v9);
  v421 = (unsigned int *)(a2 + 12);
  v422 = (_DWORD *)(a2 + 616);
  if (!*(_DWORD *)(a2 + 616)) {
    goto LABEL_250;
  }
  sub_10003EDAC((unsigned int *)(a2 + 12), a1, (uint64_t)&v507);
  int v10 = (unsigned int *)(a2 + 487252);
  switch(*v5)
  {
    case 0:
      if (*(_DWORD *)(a2 + 16) != *(_DWORD *)(a2 + 160)) {
        sub_100076B10();
      }
      if (*(_DWORD *)(a2 + 156))
      {
        unsigned int v11 = 0;
        int v12 = (unsigned __int16 *)(a2 + 487316 + *v10);
        uint64_t v13 = (unsigned __int16 *)(a2 + 487316 + *(unsigned int *)(a2 + 487264));
        __dst = (char *)(a2 + 487316 + *(unsigned int *)(a2 + 487288));
        v463 = (_WORD *)(a2 + 487316 + *(unsigned int *)(a2 + 487300));
        v451 = (_WORD *)(a2 + 487316 + *(unsigned int *)(a2 + 487276));
        int v14 = *(_DWORD *)(a2 + 20);
        do
        {
          unsigned int v15 = *(unsigned __int16 *)(a2 + 132 + 4 * (unsigned __int16)(v11 % *(_DWORD *)(a2 + 132)) + 8);
          BOOL v16 = (unsigned int *)(a2 + 487256);
          uint64_t v17 = 5;
          do
          {
            bzero((void *)(a2 + 487316 + *(v16 - 1)), *v16);
            v16 += 3;
            --v17;
          }
          while (v17);
          if ((unsigned __int16)v14 >= v15) {
            unint64_t v18 = v15;
          }
          else {
            unint64_t v18 = (unsigned __int16)v14;
          }
          sub_1000449B8((unsigned int *)a2, v18, 1, (uint64_t)&v507, v12, v13, v451);
          sub_100044C7C(v500, (unsigned int *)(a2 + 132), (uint64_t)v422, v12, v13, __dst, v463, a2 + 58668 + 360 * *(_DWORD *)(a2 + 184) * v11);
          LOWORD(v14) = v14 - v15;
          ++v11;
        }
        while (v11 < *(_DWORD *)(a2 + 156));
      }
      break;
    case 1:
      if (*(_DWORD *)(a2 + 16) != *(_DWORD *)(a2 + 160)) {
        sub_100076B10();
      }
      uint64_t v19 = a2 + 487316;
      uint64_t v20 = *v10;
      uint64_t v21 = *(unsigned int *)(a2 + 487264);
      uint64_t v22 = *(unsigned int *)(a2 + 487288);
      uint64_t v23 = *(unsigned int *)(a2 + 487300);
      uint64_t v24 = *(unsigned int *)(a2 + 487276);
      if (*(_DWORD *)(a2 + 156))
      {
        unsigned int v25 = 0;
        unsigned int v26 = (unsigned __int16 *)(v19 + v20);
        unsigned int v27 = (unsigned __int16 *)(v19 + v21);
        v464 = (_WORD *)(v19 + v23);
        __dsta = (char *)(v19 + v22);
        v452 = (_WORD *)(v19 + v24);
        int v28 = *(_DWORD *)(a2 + 20);
        do
        {
          unsigned int v29 = *(unsigned __int16 *)(a2 + 132 + 4 * (unsigned __int16)(v25 % *(_DWORD *)(a2 + 132)) + 8);
          int v30 = (unsigned int *)(a2 + 487256);
          uint64_t v31 = 5;
          do
          {
            bzero((void *)(v19 + *(v30 - 1)), *v30);
            v30 += 3;
            --v31;
          }
          while (v31);
          if ((unsigned __int16)v28 >= v29) {
            unint64_t v32 = v29;
          }
          else {
            unint64_t v32 = (unsigned __int16)v28;
          }
          sub_1000449B8((unsigned int *)a2, v32, 1, (uint64_t)&v507, v26, v27, v452);
          sub_100044C7C(v500, (unsigned int *)(a2 + 132), (uint64_t)v422, v26, v27, __dsta, v464, a2 + 58668 + 360 * *(_DWORD *)(a2 + 184) * v25);
          LOWORD(v28) = v28 - v29;
          ++v25;
        }
        while (v25 < *(_DWORD *)(a2 + 156));
        int v10 = (unsigned int *)(a2 + 487252);
        uint64_t v20 = *(unsigned int *)(a2 + 487252);
        uint64_t v21 = *(unsigned int *)(a2 + 487264);
        uint64_t v22 = *(unsigned int *)(a2 + 487288);
        uint64_t v23 = *(unsigned int *)(a2 + 487300);
        uint64_t v24 = *(unsigned int *)(a2 + 487276);
      }
      if (*(_DWORD *)(a2 + 20) != *(_DWORD *)(a2 + 216)) {
        sub_100076B3C();
      }
      if (*(_DWORD *)(a2 + 212))
      {
        unsigned int v33 = 0;
        int v34 = 0;
        float v35 = (unsigned __int16 *)(v19 + v20);
        float v36 = (unsigned __int16 *)(v19 + v21);
        v465 = (_WORD *)(v19 + v23);
        __dstb = (char *)(v19 + v22);
        v453 = (_WORD *)(v19 + v24);
        int v37 = *(_DWORD *)(a2 + 16);
        v439 = v10 + 1;
        do
        {
          unsigned int v38 = *(unsigned __int16 *)(a2 + 188 + 4 * (unsigned __int16)(v33 % *(_DWORD *)(a2 + 188)) + 8);
          int v39 = v439;
          uint64_t v40 = 5;
          do
          {
            bzero((void *)(v19 + *(v39 - 1)), *v39);
            v39 += 3;
            --v40;
          }
          while (v40);
          if ((unsigned __int16)v37 >= v38) {
            unint64_t v41 = v38;
          }
          else {
            unint64_t v41 = (unsigned __int16)v37;
          }
          sub_10004555C((unsigned int *)a2, v34, v41, (int *)&v507, v35, v36, v453);
          sub_100044C7C(v500, (unsigned int *)(a2 + 188), (uint64_t)v422, v35, v36, __dstb, v465, a2 + 360 * *(_DWORD *)(a2 + 240) * v33 + 242988);
          v34 += v38;
          LOWORD(v37) = v37 - v38;
          ++v33;
        }
        while (v33 < *(_DWORD *)(a2 + 212));
      }
      break;
    case 2:
      if (*(_DWORD *)(a2 + 16) != *(_DWORD *)(a2 + 160)) {
        sub_100076B10();
      }
      if (*(_DWORD *)(a2 + 156))
      {
        unsigned int v42 = 0;
        float v43 = (unsigned __int16 *)(a2 + 487316 + *v10);
        int v44 = (unsigned __int16 *)(a2 + 487316 + *(unsigned int *)(a2 + 487264));
        __dstc = (char *)(a2 + 487316 + *(unsigned int *)(a2 + 487288));
        v466 = (_WORD *)(a2 + 487316 + *(unsigned int *)(a2 + 487300));
        int v45 = *(_DWORD *)(a2 + 20);
        do
        {
          unsigned int v46 = *(unsigned __int16 *)(a2 + 132 + 4 * (unsigned __int16)(v42 % *(_DWORD *)(a2 + 132)) + 8);
          int v47 = (unsigned int *)(a2 + 487256);
          uint64_t v48 = 5;
          do
          {
            bzero((void *)(a2 + 487316 + *(v47 - 1)), *v47);
            v47 += 3;
            --v48;
          }
          while (v48);
          if ((unsigned __int16)v45 >= v46) {
            unsigned int v49 = v46;
          }
          else {
            unsigned int v49 = (unsigned __int16)v45;
          }
          sub_10004582C((uint64_t)v421, v49, (uint64_t)&v507, v43, v44);
          sub_100044C7C(v500, (unsigned int *)(a2 + 132), (uint64_t)v422, v43, v44, __dstc, v466, a2 + 58668 + 360 * *(_DWORD *)(a2 + 184) * v42);
          LOWORD(v45) = v45 - v46;
          ++v42;
        }
        while (v42 < *(_DWORD *)(a2 + 156));
      }
      break;
    case 3:
      if (*(_DWORD *)(a2 + 16) != *(_DWORD *)(a2 + 160)) {
        sub_100076B10();
      }
      uint64_t v50 = a2 + 487316;
      uint64_t v51 = *v10;
      uint64_t v52 = *(unsigned int *)(a2 + 487264);
      uint64_t v53 = *(unsigned int *)(a2 + 487288);
      uint64_t v54 = *(unsigned int *)(a2 + 487300);
      uint64_t v55 = *(unsigned int *)(a2 + 487276);
      if (*(_DWORD *)(a2 + 156))
      {
        unsigned int v56 = 0;
        uint64_t v57 = (unsigned __int16 *)(v50 + v51);
        uint64_t v58 = (unsigned __int16 *)(v50 + v52);
        v467 = (_WORD *)(v50 + v54);
        __dstd = (char *)(v50 + v53);
        v454 = (_WORD *)(v50 + v55);
        int v59 = *(_DWORD *)(a2 + 20);
        do
        {
          unsigned int v60 = *(unsigned __int16 *)(a2 + 132 + 4 * (unsigned __int16)(v56 % *(_DWORD *)(a2 + 132)) + 8);
          uint64_t v61 = (unsigned int *)(a2 + 487256);
          uint64_t v62 = 5;
          do
          {
            bzero((void *)(v50 + *(v61 - 1)), *v61);
            v61 += 3;
            --v62;
          }
          while (v62);
          if ((unsigned __int16)v59 >= v60) {
            unint64_t v63 = v60;
          }
          else {
            unint64_t v63 = (unsigned __int16)v59;
          }
          sub_1000449B8((unsigned int *)a2, v63, 1, (uint64_t)&v507, v57, v58, v454);
          sub_100044C7C(v500, (unsigned int *)(a2 + 132), (uint64_t)v422, v57, v58, __dstd, v467, a2 + 58668 + 360 * *(_DWORD *)(a2 + 184) * v56);
          LOWORD(v59) = v59 - v60;
          ++v56;
        }
        while (v56 < *(_DWORD *)(a2 + 156));
        int v10 = (unsigned int *)(a2 + 487252);
        uint64_t v51 = *(unsigned int *)(a2 + 487252);
        uint64_t v52 = *(unsigned int *)(a2 + 487264);
        uint64_t v53 = *(unsigned int *)(a2 + 487288);
        uint64_t v54 = *(unsigned int *)(a2 + 487300);
        uint64_t v55 = *(unsigned int *)(a2 + 487276);
      }
      if (*(_DWORD *)(a2 + 20) != *(_DWORD *)(a2 + 216)) {
        sub_100076B3C();
      }
      if (*(_DWORD *)(a2 + 212))
      {
        unsigned int v64 = 0;
        int v65 = 0;
        double v66 = (unsigned __int16 *)(v50 + v51);
        float v67 = (unsigned __int16 *)(v50 + v52);
        v468 = (_WORD *)(v50 + v54);
        __dste = (char *)(v50 + v53);
        v455 = (_WORD *)(v50 + v55);
        int v68 = *(_DWORD *)(a2 + 16);
        v440 = v10 + 1;
        do
        {
          unsigned int v69 = *(unsigned __int16 *)(a2 + 188 + 4 * (unsigned __int16)(v64 % *(_DWORD *)(a2 + 188)) + 8);
          long long v70 = v440;
          uint64_t v71 = 5;
          do
          {
            bzero((void *)(v50 + *(v70 - 1)), *v70);
            v70 += 3;
            --v71;
          }
          while (v71);
          if ((unsigned __int16)v68 >= v69) {
            unint64_t v72 = v69;
          }
          else {
            unint64_t v72 = (unsigned __int16)v68;
          }
          sub_10004555C((unsigned int *)a2, v65, v72, (int *)&v507, v66, v67, v455);
          sub_100044C7C(v500, (unsigned int *)(a2 + 188), (uint64_t)v422, v66, v67, __dste, v468, a2 + 360 * *(_DWORD *)(a2 + 240) * v64 + 242988);
          v65 += v69;
          LOWORD(v68) = v68 - v69;
          ++v64;
        }
        while (v64 < *(_DWORD *)(a2 + 212));
      }
      break;
    case 4:
      if (*(_DWORD *)(a2 + 16) != *(_DWORD *)(a2 + 160)) {
        sub_100076B10();
      }
      uint64_t v73 = a2 + 487316;
      uint64_t v74 = *v10;
      uint64_t v75 = *(unsigned int *)(a2 + 487264);
      uint64_t v76 = *(unsigned int *)(a2 + 487288);
      uint64_t v77 = *(unsigned int *)(a2 + 487300);
      uint64_t v78 = *(unsigned int *)(a2 + 487276);
      if (*(_DWORD *)(a2 + 156))
      {
        unsigned int v79 = 0;
        long long v80 = (unsigned __int16 *)(v73 + v74);
        uint64_t v81 = (unsigned __int16 *)(v73 + v75);
        v469 = (_WORD *)(v73 + v77);
        __dstf = (char *)(v73 + v76);
        v456 = (_WORD *)(v73 + v78);
        int v82 = *(_DWORD *)(a2 + 20);
        do
        {
          unsigned int v83 = *(unsigned __int16 *)(a2 + 132 + 4 * (unsigned __int16)(v79 % *(_DWORD *)(a2 + 132)) + 8);
          long long v84 = (unsigned int *)(a2 + 487256);
          uint64_t v85 = 5;
          do
          {
            bzero((void *)(v73 + *(v84 - 1)), *v84);
            v84 += 3;
            --v85;
          }
          while (v85);
          if ((unsigned __int16)v82 >= v83) {
            unint64_t v86 = v83;
          }
          else {
            unint64_t v86 = (unsigned __int16)v82;
          }
          sub_1000449B8((unsigned int *)a2, v86, 1, (uint64_t)&v507, v80, v81, v456);
          sub_100044C7C(v500, (unsigned int *)(a2 + 132), (uint64_t)v422, v80, v81, __dstf, v469, a2 + 58668 + 360 * *(_DWORD *)(a2 + 184) * v79);
          LOWORD(v82) = v82 - v83;
          ++v79;
        }
        while (v79 < *(_DWORD *)(a2 + 156));
        int v10 = (unsigned int *)(a2 + 487252);
        uint64_t v74 = *(unsigned int *)(a2 + 487252);
        uint64_t v75 = *(unsigned int *)(a2 + 487264);
        uint64_t v76 = *(unsigned int *)(a2 + 487288);
        uint64_t v77 = *(unsigned int *)(a2 + 487300);
        uint64_t v78 = *(unsigned int *)(a2 + 487276);
      }
      if (*(_DWORD *)(a2 + 20) != *(_DWORD *)(a2 + 216)) {
        sub_100076B3C();
      }
      if (*(_DWORD *)(a2 + 212))
      {
        unsigned int v87 = 0;
        int v88 = 0;
        uint64_t v89 = (unsigned __int16 *)(v73 + v74);
        uint64_t v90 = (unsigned __int16 *)(v73 + v75);
        v470 = (_WORD *)(v73 + v77);
        __dstg = (char *)(v73 + v76);
        v457 = (_WORD *)(v73 + v78);
        int v91 = *(_DWORD *)(a2 + 16);
        v441 = v10 + 1;
        do
        {
          unsigned int v92 = *(unsigned __int16 *)(a2 + 188 + 4 * (unsigned __int16)(v87 % *(_DWORD *)(a2 + 188)) + 8);
          uint64_t v93 = v441;
          uint64_t v94 = 5;
          do
          {
            bzero((void *)(v73 + *(v93 - 1)), *v93);
            v93 += 3;
            --v94;
          }
          while (v94);
          if ((unsigned __int16)v91 >= v92) {
            unint64_t v95 = v92;
          }
          else {
            unint64_t v95 = (unsigned __int16)v91;
          }
          sub_10004555C((unsigned int *)a2, v88, v95, (int *)&v507, v89, v90, v457);
          sub_100044C7C(v500, (unsigned int *)(a2 + 188), (uint64_t)v422, v89, v90, __dstg, v470, a2 + 360 * *(_DWORD *)(a2 + 240) * v87 + 242988);
          v88 += v92;
          LOWORD(v91) = v91 - v92;
          ++v87;
        }
        while (v87 < *(_DWORD *)(a2 + 212));
      }
      break;
    case 5:
      if (*(_DWORD *)(a2 + 16) != *(_DWORD *)(a2 + 160)) {
        sub_100076B10();
      }
      uint64_t v96 = a2 + 487316;
      uint64_t v97 = *v10;
      uint64_t v98 = *(unsigned int *)(a2 + 487264);
      uint64_t v99 = *(unsigned int *)(a2 + 487288);
      uint64_t v100 = *(unsigned int *)(a2 + 487300);
      if (*(_DWORD *)(a2 + 156))
      {
        unsigned int v101 = 0;
        double v102 = (unsigned __int16 *)(v96 + v97);
        float v103 = (unsigned __int16 *)(v96 + v98);
        v471 = (_WORD *)(v96 + v100);
        __dsth = (char *)(v96 + v99);
        int v104 = *(_DWORD *)(a2 + 20);
        do
        {
          unsigned int v105 = *(unsigned __int16 *)(a2 + 132 + 4 * (unsigned __int16)(v101 % *(_DWORD *)(a2 + 132)) + 8);
          unsigned int v106 = (unsigned int *)(a2 + 487256);
          uint64_t v107 = 5;
          do
          {
            bzero((void *)(v96 + *(v106 - 1)), *v106);
            v106 += 3;
            --v107;
          }
          while (v107);
          if ((unsigned __int16)v104 >= v105) {
            unsigned int v108 = v105;
          }
          else {
            unsigned int v108 = (unsigned __int16)v104;
          }
          sub_10004582C((uint64_t)v421, v108, (uint64_t)&v507, v102, v103);
          sub_100044C7C(v500, (unsigned int *)(a2 + 132), (uint64_t)v422, v102, v103, __dsth, v471, a2 + 58668 + 360 * *(_DWORD *)(a2 + 184) * v101);
          LOWORD(v104) = v104 - v105;
          ++v101;
        }
        while (v101 < *(_DWORD *)(a2 + 156));
        int v10 = (unsigned int *)(a2 + 487252);
        uint64_t v97 = *(unsigned int *)(a2 + 487252);
        uint64_t v98 = *(unsigned int *)(a2 + 487264);
        uint64_t v99 = *(unsigned int *)(a2 + 487288);
        uint64_t v100 = *(unsigned int *)(a2 + 487300);
      }
      if (*(_DWORD *)(a2 + 20) != *(_DWORD *)(a2 + 216)) {
        sub_100076B3C();
      }
      if (*(_DWORD *)(a2 + 212))
      {
        unsigned int v109 = 0;
        int v110 = 0;
        unsigned int v111 = (unsigned __int16 *)(v96 + v97);
        char v112 = (unsigned __int16 *)(v96 + v98);
        v472 = (_WORD *)(v96 + v100);
        __dstuint64_t i = (char *)(v96 + v99);
        int v113 = *(_DWORD *)(a2 + 16);
        *(void *)v447 = v10 + 1;
        do
        {
          unsigned int v114 = *(unsigned __int16 *)(a2 + 188 + 4 * (unsigned __int16)(v109 % *(_DWORD *)(a2 + 188)) + 8);
          int v115 = *(unsigned int **)v447;
          uint64_t v116 = 5;
          do
          {
            bzero((void *)(v96 + *(v115 - 1)), *v115);
            v115 += 3;
            --v116;
          }
          while (v116);
          if ((unsigned __int16)v113 >= v114) {
            unint64_t v117 = v114;
          }
          else {
            unint64_t v117 = (unsigned __int16)v113;
          }
          sub_100045A44(a2, v110, v117, (int *)&v507, v111, v112);
          sub_100044C7C(v500, (unsigned int *)(a2 + 188), (uint64_t)v422, v111, v112, __dsti, v472, a2 + 360 * *(_DWORD *)(a2 + 240) * v109 + 242988);
          v110 += v114;
          LOWORD(v113) = v113 - v114;
          ++v109;
        }
        while (v109 < *(_DWORD *)(a2 + 212));
      }
      break;
    case 6:
      if (*(_DWORD *)(a2 + 16) != *(_DWORD *)(a2 + 160)) {
        sub_100076B10();
      }
      uint64_t v118 = a2 + 487316;
      uint64_t v119 = *v10;
      uint64_t v120 = *(unsigned int *)(a2 + 487264);
      uint64_t v121 = *(unsigned int *)(a2 + 487288);
      uint64_t v122 = *(unsigned int *)(a2 + 487300);
      if (*(_DWORD *)(a2 + 156))
      {
        unsigned int v123 = 0;
        unsigned int v124 = (unsigned __int16 *)(v118 + v119);
        float v125 = (unsigned __int16 *)(v118 + v120);
        v473 = (_WORD *)(v118 + v122);
        __dstuint64_t j = (char *)(v118 + v121);
        int v126 = *(_DWORD *)(a2 + 20);
        do
        {
          unsigned int v127 = *(unsigned __int16 *)(a2 + 132 + 4 * (unsigned __int16)(v123 % *(_DWORD *)(a2 + 132)) + 8);
          unsigned int v128 = (unsigned int *)(a2 + 487256);
          uint64_t v129 = 5;
          do
          {
            bzero((void *)(v118 + *(v128 - 1)), *v128);
            v128 += 3;
            --v129;
          }
          while (v129);
          if ((unsigned __int16)v126 >= v127) {
            unsigned int v130 = v127;
          }
          else {
            unsigned int v130 = (unsigned __int16)v126;
          }
          sub_10004582C((uint64_t)v421, v130, (uint64_t)&v507, v124, v125);
          sub_100044C7C(v500, (unsigned int *)(a2 + 132), (uint64_t)v422, v124, v125, __dstj, v473, a2 + 58668 + 360 * *(_DWORD *)(a2 + 184) * v123);
          LOWORD(v126) = v126 - v127;
          ++v123;
        }
        while (v123 < *(_DWORD *)(a2 + 156));
        int v10 = (unsigned int *)(a2 + 487252);
        uint64_t v119 = *(unsigned int *)(a2 + 487252);
        uint64_t v120 = *(unsigned int *)(a2 + 487264);
        uint64_t v121 = *(unsigned int *)(a2 + 487288);
        uint64_t v122 = *(unsigned int *)(a2 + 487300);
      }
      if (*(_DWORD *)(a2 + 20) != *(_DWORD *)(a2 + 216)) {
        sub_100076B3C();
      }
      if (*(_DWORD *)(a2 + 212))
      {
        unsigned int v131 = 0;
        int v132 = 0;
        long long v133 = (unsigned __int16 *)(v118 + v119);
        long long v134 = (unsigned __int16 *)(v118 + v120);
        v474 = (_WORD *)(v118 + v122);
        __dstuint64_t k = (char *)(v118 + v121);
        int v135 = *(_DWORD *)(a2 + 16);
        *(void *)v448 = v10 + 1;
        do
        {
          unsigned int v136 = *(unsigned __int16 *)(a2 + 188 + 4 * (unsigned __int16)(v131 % *(_DWORD *)(a2 + 188)) + 8);
          double v137 = *(unsigned int **)v448;
          uint64_t v138 = 5;
          do
          {
            bzero((void *)(v118 + *(v137 - 1)), *v137);
            v137 += 3;
            --v138;
          }
          while (v138);
          if ((unsigned __int16)v135 >= v136) {
            unint64_t v139 = v136;
          }
          else {
            unint64_t v139 = (unsigned __int16)v135;
          }
          sub_100045A44(a2, v132, v139, (int *)&v507, v133, v134);
          sub_100044C7C(v500, (unsigned int *)(a2 + 188), (uint64_t)v422, v133, v134, __dstk, v474, a2 + 360 * *(_DWORD *)(a2 + 240) * v131 + 242988);
          v132 += v136;
          LOWORD(v135) = v135 - v136;
          ++v131;
        }
        while (v131 < *(_DWORD *)(a2 + 212));
      }
      break;
    case 7:
      if (*(_DWORD *)(a2 + 16) != *(_DWORD *)(a2 + 160)) {
        sub_100076B10();
      }
      uint64_t v140 = a2 + 487316;
      uint64_t v141 = *v10;
      uint64_t v142 = *(unsigned int *)(a2 + 487264);
      uint64_t v143 = *(unsigned int *)(a2 + 487288);
      uint64_t v144 = *(unsigned int *)(a2 + 487300);
      uint64_t v145 = *(unsigned int *)(a2 + 487276);
      if (*(_DWORD *)(a2 + 156))
      {
        unsigned int v146 = 0;
        float v147 = (unsigned __int16 *)(v140 + v141);
        float v148 = (unsigned __int16 *)(v140 + v142);
        v475 = (_WORD *)(v140 + v144);
        __dstl = (char *)(v140 + v143);
        v458 = (_WORD *)(v140 + v145);
        int v149 = *(_DWORD *)(a2 + 20);
        do
        {
          unsigned int v150 = *(unsigned __int16 *)(a2 + 132 + 4 * (unsigned __int16)(v146 % *(_DWORD *)(a2 + 132)) + 8);
          float v151 = (unsigned int *)(a2 + 487256);
          uint64_t v152 = 5;
          do
          {
            bzero((void *)(v140 + *(v151 - 1)), *v151);
            v151 += 3;
            --v152;
          }
          while (v152);
          if ((unsigned __int16)v149 >= v150) {
            unint64_t v153 = v150;
          }
          else {
            unint64_t v153 = (unsigned __int16)v149;
          }
          sub_1000449B8((unsigned int *)a2, v153, 1, (uint64_t)&v507, v147, v148, v458);
          sub_100044C7C(v500, (unsigned int *)(a2 + 132), (uint64_t)v422, v147, v148, __dstl, v475, a2 + 58668 + 360 * *(_DWORD *)(a2 + 184) * v146);
          LOWORD(v149) = v149 - v150;
          ++v146;
        }
        while (v146 < *(_DWORD *)(a2 + 156));
        int v10 = (unsigned int *)(a2 + 487252);
        uint64_t v141 = *(unsigned int *)(a2 + 487252);
        uint64_t v142 = *(unsigned int *)(a2 + 487264);
        uint64_t v143 = *(unsigned int *)(a2 + 487288);
        uint64_t v144 = *(unsigned int *)(a2 + 487300);
        uint64_t v145 = *(unsigned int *)(a2 + 487276);
      }
      if (*(_DWORD *)(a2 + 20) != *(_DWORD *)(a2 + 216)) {
        sub_100076B3C();
      }
      if (*(_DWORD *)(a2 + 212))
      {
        unsigned int v154 = 0;
        int v155 = 0;
        float v156 = (unsigned __int16 *)(v140 + v141);
        float v157 = (unsigned __int16 *)(v140 + v142);
        v476 = (_WORD *)(v140 + v144);
        __dstuint64_t m = (char *)(v140 + v143);
        v459 = (_WORD *)(v140 + v145);
        int v158 = *(_DWORD *)(a2 + 16);
        v442 = v10 + 1;
        do
        {
          unsigned int v159 = *(unsigned __int16 *)(a2 + 188 + 4 * (unsigned __int16)(v154 % *(_DWORD *)(a2 + 188)) + 8);
          float v160 = v442;
          uint64_t v161 = 5;
          do
          {
            bzero((void *)(v140 + *(v160 - 1)), *v160);
            v160 += 3;
            --v161;
          }
          while (v161);
          if ((unsigned __int16)v158 >= v159) {
            unint64_t v162 = v159;
          }
          else {
            unint64_t v162 = (unsigned __int16)v158;
          }
          sub_10004555C((unsigned int *)a2, v155, v162, (int *)&v507, v156, v157, v459);
          sub_100044C7C(v500, (unsigned int *)(a2 + 188), (uint64_t)v422, v156, v157, __dstm, v476, a2 + 360 * *(_DWORD *)(a2 + 240) * v154 + 242988);
          v155 += v159;
          LOWORD(v158) = v158 - v159;
          ++v154;
        }
        while (v154 < *(_DWORD *)(a2 + 212));
      }
      break;
    case 8:
      if (*(_DWORD *)(a2 + 16) != *(_DWORD *)(a2 + 160)) {
        sub_100076B10();
      }
      if (*(_DWORD *)(a2 + 156))
      {
        unsigned int v163 = 0;
        float v164 = (unsigned __int16 *)(a2 + 487316 + *v10);
        float v165 = (unsigned __int16 *)(a2 + 487316 + *(unsigned int *)(a2 + 487264));
        __dstn = (char *)(a2 + 487316 + *(unsigned int *)(a2 + 487288));
        v477 = (_WORD *)(a2 + 487316 + *(unsigned int *)(a2 + 487300));
        v460 = (_WORD *)(a2 + 487316 + *(unsigned int *)(a2 + 487276));
        int v166 = *(_DWORD *)(a2 + 20);
        do
        {
          unsigned int v167 = *(unsigned __int16 *)(a2 + 132 + 4 * (unsigned __int16)(v163 % *(_DWORD *)(a2 + 132)) + 8);
          float v168 = (unsigned int *)(a2 + 487256);
          uint64_t v169 = 5;
          do
          {
            bzero((void *)(a2 + 487316 + *(v168 - 1)), *v168);
            v168 += 3;
            --v169;
          }
          while (v169);
          if ((unsigned __int16)v166 >= v167) {
            unint64_t v170 = v167;
          }
          else {
            unint64_t v170 = (unsigned __int16)v166;
          }
          sub_1000449B8((unsigned int *)a2, v170, 0, (uint64_t)&v507, v164, v165, v460);
          sub_100044C7C(v500, (unsigned int *)(a2 + 132), (uint64_t)v422, v164, v165, __dstn, v477, a2 + 58668 + 360 * *(_DWORD *)(a2 + 184) * v163);
          LOWORD(v166) = v166 - v167;
          ++v163;
        }
        while (v163 < *(_DWORD *)(a2 + 156));
      }
      break;
    default:
      sub_100076A60();
  }
  if (!*v422) {
    goto LABEL_250;
  }
  unsigned int v171 = *(_DWORD *)(a2 + 12);
  if (v171 >= 9) {
    sub_100076AE4();
  }
  int v425 = *(_DWORD *)(a2 + 684);
  float v172 = *(float *)(a2 + 692);
  float v173 = *(float *)(a2 + 292);
  float v174 = *(float *)(a2 + 296);
  float v175 = *(float *)(a2 + 300);
  unsigned int v176 = 8;
  int v177 = 1 << v171;
  int v443 = *(_DWORD *)(a2 + 688);
  unsigned int v434 = *(unsigned __int16 *)(a2 + 664);
  unsigned int v429 = 8u / *(_DWORD *)(a2 + 164);
  if ((v177 & 0x62) != 0) {
    goto LABEL_160;
  }
  if ((v177 & 0x98) != 0)
  {
    unsigned int v176 = 4;
LABEL_160:
    if (8u / *(_DWORD *)(a2 + 164) != v176 / *(_DWORD *)(a2 + 220)) {
      sub_100076AB8();
    }
    int v449 = 1;
    goto LABEL_163;
  }
  int v449 = 0;
LABEL_163:
  uint64_t v437 = a2 + 288;
  float v504 = 0.0;
  float v505 = 0.0;
  int v178 = *(unsigned __int8 *)(a2 + 672);
  if (*(unsigned char *)(a2 + 672))
  {
    uint64_t v179 = 0;
    unsigned int v180 = *(_DWORD *)(a2 + 676);
    float v181 = *(float *)(a2 + 680);
    do
    {
      uint64_t v478 = v179;
      uint64_t v182 = a2 + 56 * v179;
      *(void *)v501 = *(unsigned int *)(v182 + 156);
      if (v501[0])
      {
        uint64_t v183 = 0;
        uint64_t v184 = a2 + 184320 * v179 + 58668;
        unsigned int __dsto = *(_DWORD *)(v182 + 184);
        do
        {
          if (__dsto)
          {
            uint64_t v185 = 0;
            float v186 = (float)*(int *)(a2 + 628);
            do
            {
              float v187 = (_DWORD *)(v184 + v185);
              int v506 = 0;
              LODWORD(v507) = 0;
              unsigned int v188 = *(_DWORD *)(v184 + v185 + 340);
              float v189 = (float)v188;
              if (v188) {
                float v190 = (float)v188;
              }
              else {
                float v190 = 1.0;
              }
              float v191 = *(float *)(v184 + v185 + 160) / v190;
              float v192 = *(float *)(v184 + v185 + 168) / v190;
              float v193 = v191 * v189;
              float v194 = (float)(v191 * v189) * v186;
              float v195 = v192 * v189;
              float v196 = v195 * v186;
              float v197 = *(float *)(v184 + v185 + 164) - (float)(v193 * v191);
              if (v194 == 0.0) {
                float v198 = 1.0;
              }
              else {
                float v198 = v194;
              }
              float v199 = v197 / v198;
              float v200 = *(float *)(v184 + v185 + 176) - (float)(v195 * v192);
              if (v196 == 0.0) {
                float v201 = 1.0;
              }
              else {
                float v201 = v196;
              }
              v187[88] = fmaxf((float)(v199 + (float)(v200 / v201)) * 65536.0, 0.0);
              sub_100045C74(v437, v184 + v185, (float *)&v506, (float *)&v507);
              float v202 = *(float *)&v507;
              v187[86] = v507;
              v187[87] = v506;
              if (v202 >= v181 && v187[88] >= v180) {
                *(unsigned char *)(v184 + v185 + 356) = 1;
              }
              v185 += 360;
            }
            while (360 * __dsto != v185);
            v184 += v185;
          }
          ++v183;
        }
        while (v183 != *(void *)v501);
      }
      uint64_t v179 = v478 + 1;
    }
    while (v478 != v449);
  }
  *(unsigned char *)(a2 + 644) = 0;
  v461 = (void *)*(unsigned __int16 *)(a2 + 34);
  if (*(_WORD *)(a2 + 34))
  {
    v432 = 0;
    int v203 = (__int16)(v434 + (v434 >> 15));
    int v204 = -(v203 >> 1);
    float v423 = (float)(v425 - v443);
    if (v172 == 1.0) {
      float v205 = 1.0;
    }
    else {
      float v205 = 1.0 - v172;
    }
    float v206 = (float)(v429 >> 1);
    int v427 = v203 >> 1;
    if (v204 <= v203 >> 1) {
      int v207 = v203 >> 1;
    }
    else {
      int v207 = -(v203 >> 1);
    }
    int v502 = v207;
    v479 = (char *)*(unsigned __int16 *)(a2 + 32);
    int v435 = -(v203 >> 1);
    do
    {
      if (v479)
      {
        __dstp = 0;
        uint64_t v430 = (void)v432 * (void)v479;
        do
        {
          uint64_t v528 = 0;
          long long v526 = 0u;
          long long v527 = 0u;
          long long v524 = 0u;
          long long v525 = 0u;
          long long v522 = 0u;
          long long v523 = 0u;
          long long v520 = 0u;
          long long v521 = 0u;
          long long v518 = 0u;
          long long v519 = 0u;
          long long v517 = 0u;
          long long v515 = 0u;
          memset(v516, 0, sizeof(v516));
          long long v513 = 0u;
          long long v514 = 0u;
          long long v511 = 0u;
          long long v512 = 0u;
          long long v509 = 0u;
          long long v510 = 0u;
          long long v507 = 0u;
          long long v508 = 0u;
          if (v204 <= v427)
          {
            int v209 = 0;
            unsigned int v208 = 0;
            int v210 = v204;
            do
            {
              int v444 = v210;
              unsigned int v211 = v210 + v432;
              do
              {
                if (v204 + (int)__dstp < v479 && v211 < v461)
                {
                  uint64_t v213 = 0;
                  float v214 = (float)*(int *)(a2 + 668);
                  uint64_t v215 = a2 + 58684;
                  do
                  {
                    uint64_t v216 = a2 + 56 * v213;
                    if (v213) {
                      __int16 v217 = v204 + (_WORD)__dstp;
                    }
                    else {
                      __int16 v217 = v211;
                    }
                    __int16 v218 = *(_WORD *)(v216 + 132);
                    unsigned __int16 v219 = v217 * v218;
                    LODWORD(v220) = (unsigned __int16)(v218 + v217 * v218);
                    unsigned int v221 = *(unsigned __int16 *)(v216 + 156);
                    if (v220 >= v221) {
                      uint64_t v220 = v221;
                    }
                    else {
                      uint64_t v220 = v220;
                    }
                    if (v220 > v219)
                    {
                      if (v213) {
                        unsigned __int16 v222 = v211;
                      }
                      else {
                        unsigned __int16 v222 = v204 + (_WORD)__dstp;
                      }
                      unsigned int v223 = *(_DWORD *)(a2 + 56 * v213 + 184);
                      if ((unsigned __int16)(v222 + 1) >= (unsigned __int16)v223) {
                        uint64_t v224 = (unsigned __int16)v223;
                      }
                      else {
                        uint64_t v224 = (unsigned __int16)(v222 + 1);
                      }
                      uint64_t v225 = v219;
                      unsigned int v226 = v223 * v219 + v222;
                      uint64_t v227 = a2 + 184320 * v213 + 360 * v226 + 58668;
                      uint64_t v228 = v215 + 360 * v226;
                      do
                      {
                        uint64_t v229 = v228;
                        uint64_t v230 = v222;
                        uint64_t v231 = v227;
                        if (v222 < v224)
                        {
                          do
                          {
                            if (!v178 || *(unsigned char *)(v231 + 356) == 1)
                            {
                              uint64_t v232 = 0;
                              unsigned int v233 = *(_DWORD *)(v231 + 340);
                              do
                              {
                                float v234 = (float32x4_t *)((char *)&v507 + v232);
                                *float v234 = vaddq_f32(*(float32x4_t *)(v231 + v232), *(float32x4_t *)((char *)&v507 + v232));
                                v234[1].f32[0] = *(float *)(v229 + v232) + *(float *)((char *)&v507 + v232 + 16);
                                v232 += 20;
                              }
                              while (v232 != 340);
                              v209 += v233;
                              float v235 = (float)*(int *)(a2 + 628);
                              float v236 = (float)v233;
                              if (v233) {
                                float v237 = (float)v233;
                              }
                              else {
                                float v237 = 1.0;
                              }
                              float v238 = *(float *)(v231 + 160) / v237;
                              float v239 = *(float *)(v231 + 168) / v237;
                              float v240 = v238 * v236;
                              float v241 = (float)(v238 * v236) * v235;
                              float v242 = v239 * v236;
                              float v243 = v242 * v235;
                              float v244 = *(float *)(v231 + 164) - (float)(v240 * v238);
                              if (v241 == 0.0) {
                                float v245 = 1.0;
                              }
                              else {
                                float v245 = v241;
                              }
                              float v246 = v244 / v245;
                              float v247 = *(float *)(v231 + 176) - (float)(v242 * v239);
                              if (v243 == 0.0) {
                                float v243 = 1.0;
                              }
                              v208 += fmaxf((float)(v246 + (float)(v247 / v243)) * v214, 0.0);
                            }
                            v231 += 360;
                            ++v230;
                            v229 += 360;
                          }
                          while (v230 != v224);
                        }
                        v227 += 360 * v223;
                        ++v225;
                        v228 += 360 * v223;
                      }
                      while (v225 != v220);
                    }
                    ++v213;
                    v215 += 184320;
                  }
                  while (v213 != v449 + 1);
                }
                BOOL v251 = v204++ == v502;
              }
              while (!v251);
              int v210 = v444 + 1;
              int v204 = v435;
            }
            while (v444 != v502);
            DWORD1(v527) = v209;
          }
          else
          {
            unsigned int v208 = 0;
          }
          sub_100045C74(v437, (uint64_t)&v507, &v504, &v505);
          BOOL v248 = v505 <= v172 || v208 <= v425 - (float)((float)((float)(v505 - v172) * v423) / v205);
          int v204 = v435;
          float v249 = v174 * (float)((float)(v206 * v504) - v173);
          float v250 = __dstp;
          BOOL v251 = !v248;
          if (v248) {
            unsigned int v252 = 0;
          }
          else {
            unsigned int v252 = v208;
          }
          uint64_t v253 = a2 + 52 * (void)&__dstp[v430] + 480048;
          *(_DWORD *)(v253 + 24) = (float)(v505 * 1000.0);
          *(_DWORD *)(v253 + 28) = v252;
          if (v251) {
            char v254 = -96;
          }
          else {
            char v254 = -120;
          }
          *(float *)(a2 + 52 * (void)&__dstp[v430] + 480080) = v175 * v249;
          *(_DWORD *)(a2 + 52 * (void)&__dstp[v430] + 480084) = 0;
          *(_DWORD *)(a2 + 52 * (void)&__dstp[v430] + 480088) = 0;
          *(unsigned char *)(a2 + 52 * (void)&__dstp[v430] + 480092) = v254;
          ++__dstp;
        }
        while (v250 + 1 != v479);
      }
      v432 = (char *)v432 + 1;
    }
    while (v432 != v461);
  }
LABEL_250:
  unsigned int v255 = *(unsigned __int16 *)(a2 + 32);
  int v256 = *(unsigned __int16 *)(a2 + 34);
  int v257 = v256 * v255;
  if (v256 * v255)
  {
    uint64_t v258 = a2 + 6956;
    uint64_t v259 = a2 + 7100;
    unint64_t v260 = vcvts_n_s32_f32(*(float *)(a2 + 292), 0xCuLL);
    int v261 = (uint64_t *)(a2 + 6972);
    do
    {
      uint64_t v262 = 0;
      uint64_t v263 = v258;
      uint64_t v264 = v259;
      do
      {
        for (uint64_t i = 0; i != 24; i += 8)
        {
          uint64_t v266 = *(void *)(v263 + i);
          *(void *)(v263 + i) = *(void *)(v264 + i);
          *(void *)(v264 + i) = v266;
        }
        ++v262;
        v264 -= 24;
        v263 += 24;
      }
      while (v262 != 3);
      uint64_t v267 = 0;
      int v268 = v261;
      do
      {
        uint64_t v269 = *(v268 - 1);
        int v270 = dword_100082930[v267];
        uint64_t v271 = ((*v268 << dword_1000828C0[v267]) * dword_1000828F8[v267] - ((uint64_t)(v269 * v260 + 2048) >> 12)) << v270;
        *(v268 - 1) = v269 << v270;
        *int v268 = v271;
        ++v267;
        v268 += 3;
      }
      while (v267 != 14);
      v258 += 404;
      v259 += 404;
      int v261 = (uint64_t *)((char *)v261 + 404);
      --v257;
    }
    while (v257);
  }
  signed int v272 = a2 + 463660;
  bzero((void *)(a2 + 441644), 0x6E00uLL);
  if (v256)
  {
    float v273 = *(float *)(a2 + 296) * *(float *)(a2 + 300);
    float v274 = *(float *)(a2 + 312);
    uint64_t v275 = a2 + 6956;
    uint64_t v276 = a2 + 463676;
    uint64_t v277 = a2 + 441644;
    do
    {
      if (v255)
      {
        float v278 = (void *)(v275 + 16);
        uint64_t v279 = (_DWORD *)v276;
        unsigned int v280 = v255;
        uint64_t v281 = v277;
        do
        {
          uint64_t v282 = 0;
          unint64_t v283 = 0;
          uint64_t v284 = 0;
          float v285 = (void *)(v275 + 388);
          v286 = v278;
          do
          {
            uint64_t v287 = *(v286 - 1);
            unsigned int v288 = (float)((float)v287 / v274);
            if (v288)
            {
              float v289 = v273 * (float)((float)((*v286 << 8) / v287) * 0.0039062);
              if (v289 < 0.0) {
                float v290 = -0.5;
              }
              else {
                float v290 = 0.5;
              }
              int v291 = (int)(float)(v289 + v290);
              uint64_t v292 = *((unsigned int *)v286 - 4);
            }
            else
            {
              int v291 = 0;
              uint64_t v292 = 0;
            }
            float v293 = (_DWORD *)(v281 + v282 * 4);
            *float v293 = v292;
            v293[14] = v288;
            v293[28] = v291;
            v284 += dword_100082968[v282] * v288;
            v283 += v292;
            ++v282;
            v286 += 3;
          }
          while (v282 != 14);
          uint64_t v294 = *(unsigned int *)(v275 + 384);
          if (v294 && *v285)
          {
            unint64_t v295 = 0;
            uint64_t v296 = *v285 * *v285;
            unint64_t v297 = 16 * v284;
            if (v283 <= 1) {
              unint64_t v298 = 1;
            }
            else {
              unint64_t v298 = v283;
            }
            uint64_t v299 = (unsigned __int16 *)(a2 + 330);
            int64_t v300 = v297 / v298;
            do
            {
              int v302 = *v299;
              v299 += 2;
              int v301 = v302;
              if (v295 > 2) {
                break;
              }
              ++v295;
              BOOL v303 = v301 == 0xFFFF || v300 < (__int16)v301;
            }
            while (!v303);
            BOOL v304 = 10000 * (*(void *)(v275 + 396) * v294 - v296) / v296 > (__int16)*(v299 - 1);
          }
          else
          {
            BOOL v304 = 0;
          }
          *(unsigned char *)(v281 + 168) = v304;
          float v305 = v279;
          for (uint64_t j = 344; j != 392; j += 12)
          {
            *(v305 - 4) = *(_DWORD *)(v275 + j - 8);
            *float v305 = *(_DWORD *)(v275 + j - 4);
            v305[4] = *(_DWORD *)(v275 + j);
            ++v305;
          }
          v275 += 404;
          v281 += 172;
          float v278 = (void *)((char *)v278 + 404);
          v279 += 12;
          --v280;
        }
        while (v280);
      }
      v277 += 172 * v255;
      v276 += 48 * v255;
      --v256;
    }
    while (v256);
  }
  if (*(_DWORD *)(a2 + 316) != 1) {
    sub_100076A34();
  }
  uint64_t v307 = 0;
  v445 = (_WORD *)(a2 + 486704);
  char v308 = 1;
  do
  {
    char v480 = v308;
    int v309 = *(_DWORD *)(a2 + 4 * v307 + 316);
    if (v309 >= 1)
    {
      uint64_t v310 = a2 + (v307 << 11) + 469808;
      signed int v311 = *(unsigned __int16 *)(a2 + 32);
      int v312 = *(unsigned __int16 *)(a2 + 34);
      if (v309 == 1)
      {
        int v313 = v312 * v311;
        if (v312 * v311)
        {
          uint64_t v314 = a2 + 441644;
          do
          {
            sub_100045FB0(a2 + 288, v314, v310);
            v314 += 172;
            v310 += 16;
            --v313;
          }
          while (v313);
        }
      }
      else
      {
        int v315 = 0;
        if (v311 >= v309) {
          signed int v272 = v309;
        }
        else {
          signed int v272 = *(unsigned __int16 *)(a2 + 32);
        }
        if (v312 >= v309) {
          int v316 = v309;
        }
        else {
          int v316 = *(unsigned __int16 *)(a2 + 34);
        }
        do
        {
          if (v272 <= v311)
          {
            int v317 = 0;
            do
            {
              unsigned int v318 = v317 + v311 * v315;
              long long v515 = 0u;
              memset(v516, 0, 28);
              long long v513 = 0u;
              long long v514 = 0u;
              long long v511 = 0u;
              long long v512 = 0u;
              long long v509 = 0u;
              long long v510 = 0u;
              long long v507 = 0u;
              long long v508 = 0u;
              if (v316)
              {
                char v319 = 0;
                int v320 = 0;
                uint64_t v321 = a2 + 441644 + 172 * v318;
                unsigned int v322 = v311;
                uint64_t v323 = a2 + 441756 + 172 * (v317 + v315 * v311);
                uint64_t v324 = 172 * v311;
                int v325 = v316;
                do
                {
                  uint64_t v326 = v323;
                  signed int v327 = v272;
                  for (uint64_t k = v321; v327; --v327)
                  {
                    if (*(unsigned char *)(k + 168))
                    {
                      for (uint64_t m = 0; m != 56; m += 4)
                      {
                        *(_DWORD *)((char *)&v507 + m) += *(_DWORD *)(v326 + m - 112);
                        int v330 = *(_DWORD *)(v326 + m - 56);
                        unint64_t v331 = (_DWORD *)((char *)&v510 + m + 8);
                        *unint64_t v331 = *(_DWORD *)((char *)&v510 + m + 8) + v330;
                        v331[14] = *(_DWORD *)((char *)&v514 + m) + *(_DWORD *)(v326 + m) * v330;
                      }
                      char v319 = ++v320;
                    }
                    k += 172;
                    v326 += 172;
                  }
                  v321 += 172 * v322;
                  v323 += v324;
                  --v325;
                }
                while (v325);
                v516[24] = v319;
              }
              uint64_t v332 = 0;
              uint64_t v333 = v310 + 16 * v318;
              do
              {
                int v334 = (char *)&v507 + v332;
                int v335 = *(_DWORD *)((char *)&v510 + v332 + 8);
                if (v335)
                {
                  int v336 = *((_DWORD *)v334 + 28);
                  int v337 = v335 >> 1;
                  if (v336 < 0) {
                    int v337 = -v337;
                  }
                  *((_DWORD *)v334 + 28) = (v337 + v336) / v335;
                }
                v332 += 4;
              }
              while (v332 != 56);
              sub_100045FB0(a2 + 288, (uint64_t)&v507, v333);
              signed int v311 = *(unsigned __int16 *)(a2 + 32);
              BOOL v303 = v317++ < v311 - v272;
            }
            while (v303);
            int v312 = *(unsigned __int16 *)(a2 + 34);
          }
          BOOL v303 = v315++ < v312 - v316;
        }
        while (v303);
      }
    }
    char v308 = 0;
    uint64_t v307 = 1;
  }
  while ((v480 & 1) != 0);
  uint64_t v338 = *(int *)(a2 + 12);
  if (v338 >= 9) {
    sub_100076A08();
  }
  int v339 = *(unsigned __int16 *)(a2 + 34);
  int v340 = v339 * *(unsigned __int16 *)(a2 + 32);
  float v341 = (_DWORD *)(a2 + 463660);
  if (v340)
  {
    uint64_t v342 = qword_100082A10[v338];
    int v343 = v339 * *(unsigned __int16 *)(a2 + 32);
    do
    {
      float v344 = v341;
      uint64_t v345 = v342;
      do
      {
        v344[2561] = *v344;
        v344[2565] = v344[4];
        v344[2569] = v344[8];
        ++v344;
        --v345;
      }
      while (v345);
      v341 += 12;
      --v343;
    }
    while (v343);
  }
  *(_DWORD *)(a2 + 487240) = *(_DWORD *)(a2 + 6869);
  *(unsigned char *)(a2 + 487244) = *(unsigned char *)(a2 + 6873);
  if (*(unsigned char *)(a2 + 6868))
  {
    uint64_t v346 = (unsigned __int16)*v445;
    if (v340 && v346 <= 0x7F)
    {
      float v347 = (float *)(a2 + 486708 + 4 * v346);
      int v348 = v340 - 1;
      uint64_t v349 = a2 + 473904;
      do
      {
        sub_100046218(*v421, v349);
        LOWORD(v346) = *v445;
        if (v350 >= 0.0)
        {
          *v347++ = v350;
          LOWORD(v346) = v346 + 1;
          _WORD *v445 = v346;
        }
        if (!v348) {
          break;
        }
        v349 += 48;
        --v348;
      }
      while ((unsigned __int16)v346 < 0x80u);
    }
    if ((_WORD)v346)
    {
      qsort((void *)(a2 + 486708), (unsigned __int16)v346, 4uLL, (int (__cdecl *)(const void *, const void *))sub_100046430);
      uint64_t v351 = 0;
      unsigned int v352 = (unsigned __int16)*v445;
      do
      {
        unint64_t v353 = (42949673 * (unint64_t)(*(unsigned __int8 *)(a2 + 487240 + v351) * v352 + 50)) >> 32;
        if (v353 >= v352) {
          LODWORD(v353) = v352 - 1;
        }
        *(_DWORD *)(a2 + 487220 + 4 * v351++) = *(_DWORD *)&v445[2 * (int)v353 + 2];
      }
      while (v351 != 5);
    }
    uint64_t v354 = 0;
    uint64_t v355 = a2 + 6876;
    while (2)
    {
      unint64_t v356 = 0;
      do
      {
        float v357 = *(float *)(v355 + 4 * v356);
        if (v357 < 0.0) {
          goto LABEL_352;
        }
        float v358 = *(float *)(a2 + 487220 + 4 * v356);
        if (v356 > 3) {
          break;
        }
        ++v356;
      }
      while (v357 <= v358);
      if (v357 > v358)
      {
LABEL_352:
        if (*(unsigned __int8 *)(a2 + 487248) >= 5u) {
          sub_1000769DC();
        }
        break;
      }
      *(unsigned char *)(a2 + 487248) = ++v354;
      v355 += 20;
      if (v354 != 4) {
        continue;
      }
      break;
    }
  }
  if (*(unsigned char *)(a2 + 408))
  {
    float v359 = *(float *)(a2 + 412);
    if (*(unsigned char *)(a2 + 487248) && v359 > *(float *)(a2 + 416)) {
      float v359 = *(float *)(a2 + 416);
    }
  }
  else
  {
    float v359 = 0.0;
  }
  uint64_t v360 = 0;
  float v361 = (float)((float)(*(float *)(a2 + 296) * *(float *)(a2 + 292)) * *(float *)(a2 + 300)) * -0.5;
  char v362 = 1;
  do
  {
    char v503 = v362;
    int v363 = *(_DWORD *)(a2 + 4 * v360 + 316);
    if (v363 >= 1)
    {
      unsigned int v364 = *(unsigned __int16 *)(a2 + 34);
      unsigned int v365 = v364 - v363;
      if (v364 >= v363)
      {
        int v366 = 0;
        float v367 = (float)*(int *)(a2 + 469804);
        uint64_t v368 = a2 + (v360 << 11) + 469808;
        uint64_t v369 = a2 + 20 * v360;
        __dstq = (unsigned char *)(v369 + 368);
        unsigned int v370 = *(unsigned __int16 *)(a2 + 32);
        v450 = (unsigned int *)(v369 + 380);
        v462 = (_DWORD *)(v369 + 376);
        v438 = (unsigned int *)(v369 + 372);
        v446 = (unsigned int *)(v369 + 384);
        char v371 = (_BYTE)v360 << 6;
        unsigned int v481 = v370 - v363;
        uint64_t v372 = *(unsigned __int16 *)(a2 + 32);
        uint64_t v374 = a2 + 480048;
        uint64_t v373 = a2 + 473904;
        unsigned int v426 = v365;
        unsigned int v424 = v370;
        while (v370 < v363)
        {
LABEL_426:
          v373 += 48 * v372;
          v368 += 16 * v372;
          v374 += 52 * v372;
          BOOL v251 = v366++ == v365;
          if (v251) {
            goto LABEL_428;
          }
        }
        int v436 = v366;
        int v375 = 0;
        uint64_t v428 = v374;
        uint64_t v431 = v373;
        uint64_t v433 = v368;
        while (1)
        {
          sub_100046218(*(unsigned int *)(a2 + 12), v373);
          unsigned int v377 = *(unsigned char *)(a2 + 348) ? v272 & 0xFFFFFFFE | (*(unsigned char *)(v368 + 12) == 0) : v272 & 0xFFFFFFFE;
          if (*(unsigned char *)(a2 + 352))
          {
            int v378 = *(_DWORD *)(v368 + 8);
            float v379 = (float)((float)v378 * 0.0625) + v367;
            float v380 = (float)*(int *)(a2 + 364);
            BOOL v381 = v379 >= v380 || v378 < *(_DWORD *)(a2 + 356);
            unsigned int v382 = v381
                 ? v377 & 0xFFFFFFFB | (4 * (v379 >= v380))
                 : v377 & 0xFFFFFFFB | (4 * (v379 <= (float)*(int *)(a2 + 360)));
          }
          else
          {
            unsigned int v382 = v377 & 0xFFFFFFFB;
          }
          if (*__dstq)
          {
            unsigned int v383 = *v438;
            if (*v438 <= 1) {
              unsigned int v383 = 1;
            }
            unsigned int v384 = *(_DWORD *)(v368 + 4);
            unsigned int v385 = *(_DWORD *)v368 / v383;
            float v386 = (float)((float)*(int *)(v368 + 8) * 0.0625) - v361;
            if (v386 < 0.0) {
              float v386 = -v386;
            }
            float v387 = (float)((float)(1.0 - (float)((float)(v386 + -16.0) * 0.0625)) * 20.0)
                 + (float)((float)((float)(v386 + -16.0) * 0.0625) * 10.0);
            if (v386 > 32.0) {
              float v387 = 10.0;
            }
            if (v386 <= 16.0) {
              float v387 = (float)((float)(1.0 - (float)((float)(v386 + -8.0) * 0.125)) * 40.0)
            }
                   + (float)((float)((float)(v386 + -8.0) * 0.125) * 20.0);
            float v388 = v386 > 8.0 ? v387 : 40.0;
            unsigned int v389 = (*v462 * (float)((float)(fabsf(sqrtf((float)v385)) * v388) + 0.5)) >> 8;
            BOOL v390 = v385 >= *v446 || v384 >= *v450;
            BOOL v391 = v390 && v384 >= v389;
            int v392 = v391 ? 0 : 8;
            unsigned int v393 = v392 | v382 & 0xFFFFFFF7;
          }
          else
          {
            unsigned int v393 = v382 & 0xFFFFFFF7;
          }
          unsigned int v394 = *(unsigned char *)(a2 + 408) ? v393 & 0xFFFFFFEF | (16 * (v376 >= v359)) : v393 & 0xFFFFFFEF;
          signed int v272 = v394 & 0xFFFFFFDD;
          float v395 = (float)*(int *)(v368 + 8) * 0.0625;
          if (v363 != 1) {
            break;
          }
          if ((v503 & 1) == 0) {
            sub_100076958();
          }
          *(void *)uint64_t v374 = *(void *)v368;
          *(float *)(v374 + 8) = v395;
          *(float *)(v374 + 12) = v376;
          *(_DWORD *)(v374 + 16) = 0;
          *(_DWORD *)(v374 + 20) = v394 & 0xDD;
          *(unsigned char *)(v374 + 20) = v371 | (32 * ((v394 & 0x1D) == 0)) | v394 & 0x1D;
LABEL_423:
          v368 += 16;
          v373 += 48;
          v374 += 52;
          BOOL v251 = v375++ == v481;
          if (v251)
          {
            uint64_t v372 = *(unsigned __int16 *)(a2 + 32);
            unsigned int v365 = v426;
            int v366 = v436;
            uint64_t v373 = v431;
            uint64_t v368 = v433;
            unsigned int v370 = v424;
            uint64_t v374 = v428;
            goto LABEL_426;
          }
        }
        if (v503) {
          sub_100076984();
        }
        if ((v394 & 0xD) != 0) {
          goto LABEL_423;
        }
        unsigned int v396 = *(unsigned __int8 *)(v368 + 12);
        int v397 = v363;
        uint64_t v398 = v374;
LABEL_408:
        v399 = (float *)(v398 + 20);
        int v400 = v363;
        while (1)
        {
          char v401 = *(unsigned char *)v399;
          if (((*(unsigned char *)v399 & 0x10) != 0 || (*(unsigned char *)v399 & 1) != 0 && (v363 * v363) >> 1 >= v396)
            && !*(unsigned char *)(a2 + 328))
          {
            goto LABEL_421;
          }
          if (*(unsigned char *)(a2 + 346) == 1)
          {
            if ((*(unsigned char *)v399 & 0x20) != 0 && *(v399 - 3) <= v395) {
              goto LABEL_421;
            }
          }
          else
          {
            if (*(unsigned char *)(a2 + 346)) {
              sub_1000769B0();
            }
            if ((*(unsigned char *)v399 & 0x20) != 0 && *(v399 - 3) >= v395) {
              goto LABEL_421;
            }
          }
          *(void *)(v399 - 5) = *(void *)v368;
          *(v399 - 3) = v395;
          *(unsigned char *)v399 = v371 | v401 & 0x33 | 0x20;
LABEL_421:
          v399 += 13;
          if (!--v400)
          {
            v398 += 52 * *(unsigned __int16 *)(a2 + 32);
            if (!--v397) {
              goto LABEL_423;
            }
            goto LABEL_408;
          }
        }
      }
    }
LABEL_428:
    char v362 = 0;
    uint64_t v360 = 1;
  }
  while ((v503 & 1) != 0);
  if (*(unsigned char *)(a2 + 420))
  {
    if (*v422)
    {
      int v402 = *(unsigned __int16 *)(a2 + 34) * *(unsigned __int16 *)(a2 + 32);
      if (v402)
      {
        v403 = (float *)(a2 + 480092);
        do
        {
          if (*(unsigned char *)(a2 + 421) && (*(unsigned char *)v403 & 0x20) == 0) {
            *((unsigned char *)v403 - 24) = *(unsigned char *)(v403 - 6) & 0xDD | 2;
          }
          char v404 = *((unsigned char *)v403 - 24);
          if ((v404 & 0x20) != 0)
          {
            if (*(unsigned char *)(a2 + 422))
            {
              float v409 = *(v403 - 9);
              if ((v409 <= 0.0 || *(v403 - 3) >= 0.0) && (v409 >= 0.0 || *(v403 - 3) <= 0.0))
              {
                float v410 = -v409;
                if (v409 >= 0.0) {
                  float v410 = *(v403 - 9);
                }
                if (v410 > 1.0)
                {
                  float v411 = *(v403 - 3);
                  float v412 = -v411;
                  if (v411 >= 0.0) {
                    float v412 = *(v403 - 3);
                  }
                  if (v412 <= v410) {
                    uint64_t v413 = a2 + 456;
                  }
                  else {
                    uint64_t v413 = a2 + 512;
                  }
                  if (v412 <= v410) {
                    float v414 = v412;
                  }
                  else {
                    float v414 = v410;
                  }
                  if (v412 <= v410) {
                    float v415 = v410;
                  }
                  else {
                    float v415 = v412;
                  }
                  float v416 = sub_100046448(v413, 7uLL, v410);
                  if (v414 == 0.0) {
                    float v417 = 1.0;
                  }
                  else {
                    float v417 = v414;
                  }
                  float v418 = powf(v415 / v417, v416);
                  float v419 = sub_100046448(a2 + 424, 4uLL, (float)*((unsigned int *)v403 - 5)) * v418;
                  *(v403 - 9) = (float)(v411 * v419) + (float)(v409 * (float)(1.0 - v419));
                  *(v403 - 7) = v419;
                }
              }
            }
          }
          else if (*(unsigned char *)(a2 + 423) && (*(unsigned char *)v403 & 0x20) != 0)
          {
            unsigned int v405 = *((_DWORD *)v403 - 5);
            float v406 = sub_100046448(a2 + 568, 3uLL, (float)v405);
            float v407 = (float)*((unsigned int *)v403 - 4);
            unsigned int v408 = (float)((float)(v406 * sub_100046448(a2 + 592, 3uLL, v407)) * v407);
            *((_DWORD *)v403 - 11) = v405;
            *((_DWORD *)v403 - 10) = v408;
            *(v403 - 9) = *(v403 - 3);
            *(v403 - 7) = 1.0;
            *((unsigned char *)v403 - 24) = v404 & 0x1F | (32 * (v408 != 0)) | 0xC0;
          }
          v403 += 13;
          --v402;
        }
        while (v402);
      }
    }
  }
  return sub_10003E8C8(a2);
}

uint64_t sub_10003E8C8(uint64_t result)
{
  if (*(unsigned char *)(result + 720))
  {
    unsigned int v1 = *(unsigned __int8 *)(result + 721);
    int v2 = *(unsigned __int8 *)(result + 722) == v1 ? 1 : *(unsigned __int8 *)(result + 722) - v1;
    int v3 = *(unsigned __int16 *)(result + 34);
    if (*(_WORD *)(result + 34))
    {
      int v4 = 0;
      int v5 = *(_DWORD *)(result + 276);
      uint64_t v6 = result + 480048;
      int v7 = *(_DWORD *)(result + 284);
      unsigned int v8 = *(unsigned __int16 *)(result + 266);
      int v32 = *(_DWORD *)(result + 272);
      int v9 = *(unsigned __int16 *)(result + 32);
      int v10 = (((v2 + ((unsigned __int16)(v2 & 0x8000) >> 15)) >> 1) + 0x10000) / v2;
      do
      {
        int v11 = v7 + v5;
        unsigned int v12 = (v5 >> 8) & ~(v5 >> 31);
        if (v12 >= v8) {
          unsigned int v12 = v8;
        }
        unsigned int v13 = ((v11 + 255) >> 8) & ~((v11 + 255) >> 31);
        if (v13 >= v8) {
          unsigned int v13 = v8;
        }
        int v14 = v13 - v12;
        if (v13 < v12) {
          int v14 = 0;
        }
        if (v9)
        {
          int v15 = 0;
          int v16 = *(_DWORD *)(result + 280);
          unsigned int v17 = *(unsigned __int16 *)(result + 264);
          uint64_t v18 = *(unsigned __int16 *)(result + 268);
          int v19 = v32;
          do
          {
            int v20 = 0;
            unsigned int v21 = (v19 >> 8) & ~(v19 >> 31);
            v19 += v16;
            if (v21 >= v17) {
              unsigned int v21 = v17;
            }
            unsigned int v22 = ((v19 + 255) >> 8) & ~((v19 + 255) >> 31);
            if (v22 >= v17) {
              unsigned int v22 = v17;
            }
            unsigned int v23 = v22 - v21;
            if (v22 < v21) {
              unsigned int v23 = 0;
            }
            if (v13 > v12)
            {
              int v20 = 0;
              uint64_t v24 = result + 723 + v12 * v18 + v21;
              if (v23 <= 1) {
                uint64_t v25 = 1;
              }
              else {
                uint64_t v25 = v23;
              }
              int v26 = v14;
              do
              {
                if (v22 > v21)
                {
                  for (uint64_t i = 0; i != v25; ++i)
                  {
                    unsigned int v28 = *(unsigned __int8 *)(v24 + i);
                    if (v28 <= v1) {
                      unsigned int v28 = v1;
                    }
                    v20 += v28;
                  }
                }
                v24 += v18;
                BOOL v29 = __OFSUB__(v26--, 1);
              }
              while (!((v26 < 0) ^ v29 | (v26 == 0)));
              if (v22 > v21) {
                v20 /= (int)(v23 * v14);
              }
            }
            int v30 = (v20 - v1) * v10;
            if (v30 >= 0x10000) {
              char v31 = -1;
            }
            else {
              char v31 = BYTE1(v30) & ~(v30 >> 31);
            }
            *(unsigned char *)(v6 + 48) = v31;
            v6 += 52;
            ++v15;
          }
          while (v15 != v9);
        }
        ++v4;
        int v5 = v11;
      }
      while (v4 != v3);
    }
  }
  return result;
}

uint64_t sub_10003EA84(uint64_t a1, uint64_t a2, _DWORD *a3)
{
  if (!a1) {
    sub_100076BC0();
  }
  if (!a2) {
    sub_100076BEC();
  }
  if (!a3) {
    sub_100076C18();
  }
  bzero(a3 + 117452, 0x4424uLL);
  a3[117451] = a3[72];
  int v6 = a3[1];
  if (v6 != 3)
  {
    if (v6 != 4)
    {
      if (v6 == 2) {
        sub_100076C70();
      }
      sub_100076C44();
    }
    sub_100076C9C();
  }
  v8[0] = a1;
  v8[1] = a2;
  return sub_10003C40C((uint64_t)v8, (uint64_t)a3);
}

void sub_10003EB58(uint64_t a1, uint64_t a2, uint64_t a3, _DWORD *a4)
{
  if (a1)
  {
    if (a2)
    {
      if (a3)
      {
        if (a4)
        {
          bzero(a4 + 117452, 0x4424uLL);
          a4[117451] = a4[72];
          int v5 = a4[1];
          if (v5 != 4)
          {
            if (v5 != 3)
            {
              if (v5 == 2) {
                __assert_rtn("Process_x3", "PDAFPixelEngine.cpp", 4383, "false");
              }
              __assert_rtn("Process_x3", "PDAFPixelEngine.cpp", 4395, "false");
            }
            __assert_rtn("Process_x3", "PDAFPixelEngine.cpp", 4387, "false");
          }
          __assert_rtn("Process_x3", "PDAFPixelEngine.cpp", 4391, "false");
        }
        __assert_rtn("Process_x3", "PDAFPixelEngine.cpp", 4378, "pContext != nullptr");
      }
      __assert_rtn("Process_x3", "PDAFPixelEngine.cpp", 4377, "pIn2 != nullptr");
    }
    __assert_rtn("Process_x3", "PDAFPixelEngine.cpp", 4376, "pIn1 != nullptr");
  }
  __assert_rtn("Process_x3", "PDAFPixelEngine.cpp", 4375, "pIn0 != nullptr");
}

void sub_10003EC70(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, _DWORD *a5)
{
  if (a1)
  {
    if (a2)
    {
      if (a3)
      {
        if (a4)
        {
          if (a5)
          {
            bzero(a5 + 117452, 0x4424uLL);
            a5[117451] = a5[72];
            int v6 = a5[1];
            if (v6 != 4)
            {
              if (v6 != 3)
              {
                if (v6 == 2) {
                  __assert_rtn("Process_x4", "PDAFPixelEngine.cpp", 4418, "false");
                }
                __assert_rtn("Process_x4", "PDAFPixelEngine.cpp", 4430, "false");
              }
              __assert_rtn("Process_x4", "PDAFPixelEngine.cpp", 4422, "false");
            }
            __assert_rtn("Process_x4", "PDAFPixelEngine.cpp", 4426, "false");
          }
          __assert_rtn("Process_x4", "PDAFPixelEngine.cpp", 4413, "pContext != nullptr");
        }
        __assert_rtn("Process_x4", "PDAFPixelEngine.cpp", 4412, "pIn3 != nullptr");
      }
      __assert_rtn("Process_x4", "PDAFPixelEngine.cpp", 4411, "pIn2 != nullptr");
    }
    __assert_rtn("Process_x4", "PDAFPixelEngine.cpp", 4410, "pIn1 != nullptr");
  }
  __assert_rtn("Process_x4", "PDAFPixelEngine.cpp", 4409, "pIn0 != nullptr");
}

uint64_t sub_10003EDAC(unsigned int *a1, uint64_t a2, uint64_t a3)
{
  int v4 = 0;
  uint64_t v5 = 0;
  int v6 = 0;
  uint64_t v7 = 1;
  uint64_t v70 = a3;
  while (2)
  {
    uint64_t result = v7;
    uint64_t v9 = a3 + 80 * v5;
    *(_OWORD *)(v9 + 64) = 0u;
    *(_OWORD *)(v9 + 32) = 0u;
    *(_OWORD *)uint64_t v9 = 0u;
    *(_OWORD *)(v9 + 48) = 0u;
    int v10 = (unsigned int *)(v9 + 48);
    *(_OWORD *)(v9 + 16) = 0u;
    int v11 = (unsigned int *)(v9 + 16);
    unsigned int v12 = *a1;
    unsigned int v13 = &a1[12 * v5];
    *(_DWORD *)uint64_t v9 = *a1;
    *(void *)(v9 + 20) = -1;
    int v14 = (_DWORD *)(v9 + 20);
    *(void *)(v9 + 52) = -1;
    int v15 = (_DWORD *)(v9 + 52);
    unsigned int v18 = v13[9];
    unsigned int v17 = v13 + 9;
    unsigned int v16 = v18;
    int v20 = v17 - 1;
    unsigned int v19 = *(v17 - 1);
    unsigned int v22 = v17[1];
    unsigned int v21 = v17[2];
    BOOL v23 = v22 >= v19;
    unsigned int v24 = v22 - v19;
    if (v24 == 0 || !v23 || v21 <= v16) {
      goto LABEL_53;
    }
    uint64_t v26 = *(void *)(a2 + 8 * v5);
    if (!v26) {
      sub_100076CC8();
    }
    uint64_t v27 = a3 + 80 * v5;
    *(_DWORD *)(v27 + 4) = v21 - v16;
    unsigned int v28 = (_DWORD *)(v27 + 4);
    BOOL v29 = (unsigned int *)(v9 + 24);
    int v30 = (int *)(v9 + 56);
    unsigned int v75 = result;
    int v76 = v6;
    uint64_t v73 = v10;
    uint64_t v74 = v11;
    uint64_t v72 = v26;
    switch(v12)
    {
      case 0u:
      case 8u:
        unsigned int v31 = a1[12 * v5 + 12];
        if (v31 >= 2) {
          sub_100076D20();
        }
        int v32 = a1[12 * v5 + 13];
        if (v32 != -1) {
          sub_100076F04();
        }
        goto LABEL_18;
      case 1u:
      case 3u:
      case 4u:
      case 7u:
        unsigned int v31 = a1[12 * v5 + 12];
        if (v31 >= 2) {
          sub_100076F30();
        }
        int v32 = a1[12 * v5 + 13];
        if ((v32 - 4) <= 0xFFFFFFFD) {
          sub_100076F5C();
        }
        goto LABEL_18;
      case 2u:
        if (a1[12 * v5 + 12]) {
          sub_100076FB4();
        }
        if (a1[12 * v5 + 13] != -1) {
          sub_100076F88();
        }
        unsigned int v31 = 0;
        goto LABEL_26;
      case 5u:
      case 6u:
        if (a1[12 * v5 + 12]) {
          sub_10007700C();
        }
        if (a1[12 * v5 + 13] != 2) {
          sub_100076FE0();
        }
        unsigned int v31 = 0;
        int v32 = 2;
LABEL_18:
        if (v12 > 8) {
          sub_100076D4C();
        }
        if (((1 << v12) & 0xD2) != 0)
        {
          unsigned int *v11 = v24;
          *int v14 = 0;
          *BOOL v29 = v31;
          *int v10 = v24;
          *int v15 = 1;
          *int v30 = v32;
        }
        else if (((1 << v12) & 0x105) != 0)
        {
LABEL_26:
          unsigned int *v11 = v24;
          *int v14 = 0;
          *BOOL v29 = v31;
          *(void *)int v10 = 0xFFFFFFFF00000000;
          *int v30 = -1;
        }
        else
        {
          *int v10 = v24;
          *int v15 = 0;
          *int v30 = v32;
          unsigned int *v11 = v24;
          *int v14 = 1;
          *BOOL v29 = v31;
        }
        unsigned int v33 = &a1[12 * v5];
        int v35 = v33[14];
        int v34 = (int *)(v33 + 14);
        unint64_t v36 = sub_100043534(v12, v35);
        if (v12 > 8) {
          sub_100076D78();
        }
        int v37 = v17 - 3;
        int v38 = 1 << v12;
        int v71 = v4;
        if (((1 << v12) & 0xFA) != 0)
        {
          unint64_t v39 = a1[12 * v5 + 7];
          if (v36 >= v39) {
            sub_100076ED8();
          }
          unint64_t v40 = *v17;
          if (v40 >= v39) {
            sub_100076EAC();
          }
          signed int v41 = v12 - 1;
          if (v12 - 1 >= 7 || ((0x7Du >> v41) & 1) == 0) {
            sub_100076E80();
          }
          uint64_t v42 = qword_1000829D8[v41];
          unint64_t v43 = v42 * *v37;
          unint64_t v44 = 2 * v40 - v36;
          if (v36 > v40) {
            unint64_t v44 = *v17;
          }
          unint64_t v45 = (v39 + ~v40);
          uint64_t v46 = (2 * v39 - 1);
          uint64_t v47 = v36 + v46 - 2 * v45;
          uint64_t v48 = v46 - v45;
          if (v36 <= v45) {
            uint64_t v48 = v47;
          }
          uint64_t v49 = v42 * *v20;
          unint64_t v68 = v49 + v43 * v48;
          uint64_t v69 = v49 + v43 * v44;
        }
        else
        {
          if ((v38 & 0x101) == 0)
          {
            uint64_t v62 = *v37;
            unint64_t v63 = 16 * v62 * (unint64_t)*v17;
            unsigned int v64 = 2 * *v20;
            a3 = v70;
            uint64_t v65 = v70 + 80 * v5;
            *(void *)(v65 + 8) = 8 * v62;
            uint64_t v51 = (void *)(v65 + 8);
            uint64_t v61 = v63 + 8 * v64;
            void v51[3] = 0;
            v51[7] = 0;
            uint64_t result = v75;
            int v58 = v76;
            unsigned int v56 = v73;
            int v59 = v74;
            uint64_t v60 = v72;
            goto LABEL_49;
          }
          unint64_t v43 = 8 * *v37;
          unint64_t v68 = 0;
          uint64_t v69 = v43 * 2 * *v17 + 8 * *v20;
        }
        uint64_t v50 = v70 + 80 * v5;
        *(void *)(v50 + 8) = v43 >> 1;
        uint64_t v51 = (void *)(v50 + 8);
        void v51[3] = 0;
        v51[7] = 0;
        unint64_t v52 = sub_100043534(v12, *v34);
        a3 = v70;
        if ((v38 & 0xFA) == 0)
        {
          uint64_t result = v75;
          int v58 = v76;
          unsigned int v56 = v73;
          int v59 = v74;
          uint64_t v60 = v72;
          uint64_t v61 = v69;
LABEL_49:
          uint64_t v57 = 0;
          *(void *)(a3 + 80 * v5 + 40) = v60 + v61;
          goto LABEL_50;
        }
        unint64_t v53 = *v17;
        if (v52 > v53) {
          void v51[3] = v52 - v53;
        }
        unint64_t v54 = a1[12 * v5 + 7] + ~v52;
        BOOL v23 = v54 >= v53;
        uint64_t v55 = v54 - v53;
        if (v23) {
          v51[7] = v55;
        }
        unsigned int v56 = v73;
        *(void *)(v70 + 80 * v5 + 40) = v72 + v69;
        uint64_t v57 = v72 + v68;
        uint64_t result = v75;
        int v58 = v76;
        int v59 = v74;
LABEL_50:
        *(void *)(a3 + 80 * v5 + 72) = v57;
        if (!*v51) {
          sub_100076DD0();
        }
        if (*v28 != a1[2]) {
          sub_100076E54();
        }
        int v6 = *v56 + v58;
        int v4 = *v59 + v71;
LABEL_53:
        uint64_t v7 = 0;
        uint64_t v5 = 1;
        if (result) {
          continue;
        }
        unsigned int v66 = a1[1];
        if (v4 && v4 != v66) {
          sub_100076DFC();
        }
        if (v6)
        {
          if (v6 != v66) {
            sub_100076E28();
          }
        }
        return result;
      default:
        sub_100076CF4();
    }
  }
}

uint64_t sub_10003F2D0(uint64_t result, uint64_t a2, uint64_t a3, int32x4_t a4, int32x4_t a5, __n128 a6, __n128 a7)
{
  int v10 = (int16x8_t *)(a2 + 12);
  uint64_t v807 = *(unsigned __int16 *)(a2 + 32);
  if (result == 1)
  {
    uint64_t v69 = a2 + 6956;
    unsigned int v70 = *(_DWORD *)(a2 + 12);
    if (v70 - 3 < 6 || v70 < 2)
    {
      int v72 = *(_DWORD *)(a2 + 20);
      int v73 = *(_DWORD *)(a2 + 28);
      int v808 = 0;
      uint64_t v74 = a2 + 304;
      int v75 = 2 * v72;
      int v798 = 2 * v73;
      switch(v70)
      {
        case 0u:
          if (!v75) {
            return result;
          }
          int16x8_t v76 = vdupq_n_s16(*(char *)(a2 + 308));
          int v77 = *(_DWORD *)(a2 + 24);
          int v766 = *(_DWORD *)(a2 + 16);
          int v781 = *(_DWORD *)(a3 + 16);
          if (v781) {
            uint64_t v78 = a3 + 16;
          }
          else {
            uint64_t v78 = a3 + 96;
          }
          uint64_t v756 = v78;
          v79.i64[0] = 0x1000100010001;
          v79.i64[1] = 0x1000100010001;
          v80.i64[0] = -1;
          v80.i64[1] = -1;
          v81.i64[0] = 0x2000200020002;
          v81.i64[1] = 0x2000200020002;
          v82.i64[0] = 0x4000400040004;
          v82.i64[1] = 0x4000400040004;
          v83.i64[0] = 0x7000700070007;
          v83.i64[1] = 0x7000700070007;
          v84.i64[0] = 0xF000F000F000FLL;
          v84.i64[1] = 0xF000F000F000FLL;
          v85.i64[0] = 0x5000500050005;
          v85.i64[1] = 0x5000500050005;
          int v86 = v798;
          while (1)
          {
            int v87 = v781;
            if (v766 < 1) {
              goto LABEL_105;
            }
            v7.i32[0] = 0;
            int v88 = 0;
            int v89 = *(_DWORD *)(v756 + 8);
            v8.i32[0] = v89 & 1;
            int8x8_t v90 = (int8x8_t)vdup_lane_s32(vceq_s32(*(int32x2_t *)v8.i8, v7), 0);
            int32x2_t v7 = (int32x2_t)vorr_s8((int8x8_t)(*(void *)&v90 & 0xFF00FF00FF00FF00), (int8x8_t)(*(void *)&vmvn_s8(v90) & 0xFF00FF00FF00FFLL));
            uint64_t v91 = v69 - 404;
            unsigned int v92 = *(const __int16 **)(a3 + 40);
            int v87 = v781;
            int v93 = v766;
LABEL_79:
            uint64_t v94 = *(const __int16 **)(a3 + 120);
            int v95 = *(_DWORD *)(a3 + 96);
            if (!v87)
            {
              int v87 = *(_DWORD *)(a3 + 96);
              unsigned int v92 = *(const __int16 **)(a3 + 120);
            }
            if (v87 > 7) {
              break;
            }
            int v96 = v93;
            if (v87 == v93) {
              goto LABEL_84;
            }
            if (v87 < 1) {
              sub_1000771F0();
            }
            unint64_t v97 = 0;
            uint64_t v98 = 2 * v87;
            do
            {
              v809.i16[v97 / 2] = *v92;
              v817.i16[v97 / 2] = v92[1];
              v816.i16[v97 / 2] = v92[2];
              v815.i16[v97 / 2] = v92[3];
              v97 += 2;
              v92 += 4;
            }
            while (v98 != v97);
            if (v93 >= 8) {
              int v99 = 8;
            }
            else {
              int v99 = v93;
            }
            if (v87 < v99)
            {
              uint64_t v100 = &v815.i16[(unint64_t)v98 / 2];
              unsigned int v101 = &v816.i16[(unint64_t)v98 / 2];
              double v102 = &v817.i16[(unint64_t)v98 / 2];
              float v103 = &v809.i16[(unint64_t)v98 / 2];
              int v104 = v87;
              do
              {
                *v103++ = *v94;
                *v102++ = v94[1];
                *v101++ = v94[2];
                *v100++ = v94[3];
                v94 += 4;
                ++v104;
              }
              while (v99 > v104);
            }
            int16x8_t v8 = (int16x8_t)v809;
            v818.val[1] = v817;
            v818.val[3] = v815;
            v818.val[2] = v816;
            v87 += v95 - v99;
            unsigned int v92 = v94;
LABEL_95:
            uint64_t v105 = 0;
            int8x16_t v106 = (int8x16_t)vceqzq_s16((int16x8_t)vandq_s8((int8x16_t)v8, v82));
            int16x8_t v107 = (int16x8_t)vandq_s8((int8x16_t)v818.val[1], v83);
            int16x8_t v108 = vshrq_n_s16(v8, 3uLL);
            int8x16_t v109 = (int8x16_t)vaddq_s16(v818.val[3], (int16x8_t)vbslq_s8((int8x16_t)vcltzq_s16(vshlq_n_s16((int16x8_t)vmovl_u8((uint8x8_t)v7), 0xFuLL)), (int8x16_t)vnegq_s16(v108), (int8x16_t)v108));
            int8x16_t v110 = (int8x16_t)vcgtq_u16((uint16x8_t)v107, v85);
            int8x16_t v111 = (int8x16_t)vqshlq_n_u16((uint16x8_t)vabsq_s16(vshrq_n_s16(v818.val[1], 3uLL)), 4uLL);
            int16x8_t v112 = (int16x8_t)vandq_s8((int8x16_t)vaddq_s16((int16x8_t)vandq_s8((int8x16_t)v818.val[2], v84), (int16x8_t)vbicq_s8(v79, (int8x16_t)v8)), vorrq_s8(v110, (int8x16_t)vceqzq_s16((int16x8_t)vandq_s8((int8x16_t)v8, v81))));
            int16x8_t v113 = vaddq_s16((int16x8_t)vbslq_s8(v110, (int8x16_t)vaddq_s16(v107, v80), (int8x16_t)v107), (int16x8_t)vandq_s8(veorq_s8((int8x16_t)vcltzq_s16(v8), (int8x16_t)vcgtq_s16(v818.val[1], v80)), v83));
            int16x8_t v114 = (int16x8_t)vshrq_n_u16((uint16x8_t)vbslq_s8(v110, (int8x16_t)vshrq_n_u16((uint16x8_t)v111, 1uLL), v111), 1uLL);
            int16x8_t v115 = vqshlq_s16(vqdmulhq_s16(v114, vmulq_s16((int16x8_t)vshrq_n_u16((uint16x8_t)v112, 1uLL), (int16x8_t)vshrq_n_u16((uint16x8_t)v818.val[2], 4uLL))), v76);
            int8x16_t v116 = (int8x16_t)vqdmulhq_s16(v115, v114);
            int8x16_t v117 = (int8x16_t)vqdmulhq_s16(v115, (int16x8_t)vshrq_n_u16(vqshlq_n_u16((uint16x8_t)vabsq_s16(v108), 4uLL), 1uLL));
            int8x16_t v118 = (int8x16_t)vceqzq_s16(v112);
            int8x16_t v809 = (int8x16_t)v113;
            int8x16_t v810 = vornq_s8(vandq_s8((int8x16_t)v112, v106), v106);
            int8x16_t v811 = vbslq_s8(v118, v109, v116);
            int8x16_t v812 = vbslq_s8(v118, (int8x16_t)v818.val[3], v117);
            int16x8_t v817 = (int16x8_t)v109;
            uint64_t v119 = &v811;
            while (1)
            {
              BOOL v120 = v88 == 0;
              if (!v88) {
                int v88 = v77;
              }
              uint64_t v121 = v91 + 404 * v120;
              unsigned int v122 = v119[-2].u16[0];
              uint64_t v123 = v119[-1].u16[0];
              uint64_t v124 = v119->u16[0];
              uint64_t v125 = v119[1].u16[0];
              ++*(_DWORD *)(v121 + 384);
              uint64_t v126 = v817.u16[v105];
              *(void *)(v121 + 388) += v126;
              uint64_t result = v121 + 396;
              *(void *)(v121 + 396) += v126 * (unint64_t)v126;
              if (v123)
              {
                if (v123 != 0xFFFF)
                {
                  unsigned int v127 = (void *)(v121 + 24 * v122);
                  uint64_t result = v127[1] + v124;
                  *v127 += v123;
                  v127[1] = result;
                  v127[2] += v125;
                }
              }
              else
              {
                unsigned int v128 = (_DWORD *)(v91 + 404 * v120 + 12 * v89);
                ++v128[84];
                v128[85] += v124;
                v128[86] += v125;
              }
              ++v808;
              if (v93 - 1 == v105) {
                break;
              }
              uint64_t v119 = (int8x16_t *)((char *)v119 + 2);
              v89 ^= 1u;
              --v88;
              ++v105;
              v91 += 404 * v120;
              if (v105 == 8)
              {
                v93 -= 8;
                uint64_t v91 = v121;
                if (v93 + 1 > 1) {
                  goto LABEL_79;
                }
                break;
              }
            }
LABEL_105:
            if (v87) {
              sub_1000771C4();
            }
            if (*(_DWORD *)a3 > 8u) {
              sub_1000770BC();
            }
            int v129 = 1 << *(_DWORD *)a3;
            if ((v129 & 0xFA) != 0)
            {
              uint64_t v130 = *(void *)(a3 + 32);
              if (v130)
              {
                *(void *)(a3 + 32) = v130 - 1;
                uint64_t v131 = *(void *)(a3 + 8);
              }
              else
              {
                uint64_t v131 = 2 * *(void *)(a3 + 8);
              }
              *(void *)(a3 + 40) += 2 * v131;
              int v133 = *(_DWORD *)(a3 + 20) + 2;
            }
            else
            {
              if ((v129 & 0x101) != 0)
              {
                *(void *)(a3 + 40) += 2 * *(void *)(a3 + 8);
                int32x2_t v132 = *(int32x2_t *)(a3 + 20);
                v8.i32[0] = vadd_s32(v132, (int32x2_t)0x100000001).u32[0];
                int32x2_t v7 = (int32x2_t)veor_s8((int8x8_t)v132, (int8x8_t)0x100000001);
                v8.i32[1] = v7.i32[1];
                *(void *)(a3 + 20) = v8.i64[0];
                goto LABEL_115;
              }
              *(void *)(a3 + 40) += 2 * *(void *)(a3 + 8);
              int v133 = *(_DWORD *)(a3 + 20) + 1;
            }
            *(_DWORD *)(a3 + 20) = v133;
LABEL_115:
            unsigned int v134 = *(_DWORD *)(a3 + 80);
            if (v134 > 8) {
              sub_1000770BC();
            }
            int v135 = 1 << v134;
            if ((v135 & 0xFA) != 0)
            {
              uint64_t v136 = *(void *)(a3 + 112);
              if (v136)
              {
                *(void *)(a3 + 112) = v136 - 1;
                uint64_t v137 = *(void *)(a3 + 88);
              }
              else
              {
                uint64_t v137 = 2 * *(void *)(a3 + 88);
              }
              *(void *)(a3 + 120) += 2 * v137;
              int v139 = *(_DWORD *)(a3 + 100) + 2;
              goto LABEL_123;
            }
            if ((v135 & 0x101) == 0)
            {
              *(void *)(a3 + 120) += 2 * *(void *)(a3 + 88);
              int v139 = *(_DWORD *)(a3 + 100) + 1;
LABEL_123:
              *(_DWORD *)(a3 + 100) = v139;
              goto LABEL_124;
            }
            *(void *)(a3 + 120) += 2 * *(void *)(a3 + 88);
            int32x2_t v138 = *(int32x2_t *)(a3 + 100);
            v8.i32[0] = vadd_s32(v138, (int32x2_t)0x100000001).u32[0];
            int32x2_t v7 = (int32x2_t)veor_s8((int8x8_t)v138, (int8x8_t)0x100000001);
            v8.i32[1] = v7.i32[1];
            *(void *)(a3 + 100) = v8.i64[0];
LABEL_124:
            unsigned int v140 = v807;
            if (v86 != 1) {
              unsigned int v140 = 0;
            }
            v69 += 404 * v140;
            if (v86 == 1) {
              int v86 = v798;
            }
            else {
              --v86;
            }
            if (!--v75) {
              return result;
            }
          }
          int v96 = 8;
LABEL_84:
          v87 -= v96;
          *(int16x8x4_t *)v8.i8 = vld4q_s16(v92);
          v92 += 32;
          goto LABEL_95;
        case 1u:
          if (!v75) {
            return result;
          }
          uint64_t v774 = a3 + 96;
          uint64_t v790 = a3 + 16;
          uint64_t v760 = a3 + 48;
          int v511 = 2 * v73;
          int v512 = -2 * v72;
          while (1)
          {
            sub_100043D28(v10, v74, 1, v790, v774, v69, &v808, a4, a5);
            if (*(_DWORD *)a3 > 8u) {
              sub_1000770BC();
            }
            int v515 = 1 << *(_DWORD *)a3;
            if ((v515 & 0xFA) != 0)
            {
              uint64_t v516 = *(void *)(a3 + 32);
              if (v516)
              {
                *(void *)(a3 + 32) = v516 - 1;
                uint64_t v517 = *(void *)(a3 + 8);
              }
              else
              {
                uint64_t v517 = 2 * *(void *)(a3 + 8);
              }
              *(void *)(a3 + 40) += 2 * v517;
              int v519 = *(_DWORD *)(a3 + 20) + 2;
            }
            else
            {
              if ((v515 & 0x101) != 0)
              {
                *(void *)(a3 + 40) += 2 * *(void *)(a3 + 8);
                int32x2_t v518 = *(int32x2_t *)(a3 + 20);
                v514.i32[0] = vadd_s32(v518, (int32x2_t)0x100000001).u32[0];
                *(int8x8_t *)v513.i8 = veor_s8((int8x8_t)v518, (int8x8_t)0x100000001);
                v514.i32[1] = v513.i32[1];
                *(void *)(a3 + 20) = v514.i64[0];
                goto LABEL_643;
              }
              *(void *)(a3 + 40) += 2 * *(void *)(a3 + 8);
              int v519 = *(_DWORD *)(a3 + 20) + 1;
            }
            *(_DWORD *)(a3 + 20) = v519;
LABEL_643:
            unsigned int v520 = *(_DWORD *)(a3 + 80);
            if (v520 > 8) {
              sub_1000770BC();
            }
            int v521 = 1 << v520;
            if ((v521 & 0xFA) != 0)
            {
              uint64_t v522 = *(void *)(a3 + 112);
              if (v522)
              {
                *(void *)(a3 + 112) = v522 - 1;
                uint64_t v523 = *(void *)(a3 + 88);
              }
              else
              {
                uint64_t v523 = 2 * *(void *)(a3 + 88);
              }
              *(void *)(a3 + 120) += 2 * v523;
              int v525 = *(_DWORD *)(a3 + 100) + 2;
              goto LABEL_651;
            }
            if ((v521 & 0x101) == 0)
            {
              *(void *)(a3 + 120) += 2 * *(void *)(a3 + 88);
              int v525 = *(_DWORD *)(a3 + 100) + 1;
LABEL_651:
              *(_DWORD *)(a3 + 100) = v525;
              goto LABEL_652;
            }
            *(void *)(a3 + 120) += 2 * *(void *)(a3 + 88);
            int32x2_t v524 = *(int32x2_t *)(a3 + 100);
            v514.i32[0] = vadd_s32(v524, (int32x2_t)0x100000001).u32[0];
            *(int8x8_t *)v513.i8 = veor_s8((int8x8_t)v524, (int8x8_t)0x100000001);
            v514.i32[1] = v513.i32[1];
            *(void *)(a3 + 100) = v514.i64[0];
LABEL_652:
            uint64_t result = (uint64_t)sub_100043D28(v10, v74, 0, v760, a3 + 128, v69, &v808, v513, v514);
            if (*(_DWORD *)a3 > 8u) {
              sub_100077114();
            }
            int v526 = 1 << *(_DWORD *)a3;
            if ((v526 & 0x9A) != 0)
            {
              uint64_t v527 = *(void *)(a3 + 64);
              if (v527)
              {
                *(void *)(a3 + 64) = v527 - 1;
                uint64_t v528 = 2 * *(void *)(a3 + 8);
              }
              else
              {
                uint64_t v528 = *(void *)(a3 + 8);
              }
              *(void *)(a3 + 72) += 2 * v528;
              int32x2_t v531 = *(int32x2_t *)(a3 + 52);
              a5.i32[0] = vadd_s32(v531, (int32x2_t)0x200000002).u32[0];
              *(int8x8_t *)a4.i8 = veor_s8((int8x8_t)v531, (int8x8_t)0x100000001);
              a5.i32[1] = a4.i32[1];
              *(void *)(a3 + 52) = a5.i64[0];
            }
            else
            {
              if ((v526 & 0x60) == 0) {
                sub_100077140();
              }
              uint64_t v529 = *(void *)(a3 + 64);
              if (v529)
              {
                *(void *)(a3 + 64) = v529 - 1;
                uint64_t v530 = 2 * *(void *)(a3 + 8);
              }
              else
              {
                uint64_t v530 = *(void *)(a3 + 8);
              }
              *(void *)(a3 + 72) += 2 * v530;
              *(_DWORD *)(a3 + 52) += 2;
            }
            unsigned int v532 = *(_DWORD *)(a3 + 80);
            if (v532 > 8) {
              sub_100077114();
            }
            int v533 = 1 << v532;
            if ((v533 & 0x9A) != 0)
            {
              uint64_t v534 = *(void *)(a3 + 144);
              if (v534)
              {
                *(void *)(a3 + 144) = v534 - 1;
                uint64_t v535 = 2 * *(void *)(a3 + 88);
              }
              else
              {
                uint64_t v535 = *(void *)(a3 + 88);
              }
              *(void *)(a3 + 152) += 2 * v535;
              int32x2_t v538 = *(int32x2_t *)(a3 + 132);
              a5.i32[0] = vadd_s32(v538, (int32x2_t)0x200000002).u32[0];
              *(int8x8_t *)a4.i8 = veor_s8((int8x8_t)v538, (int8x8_t)0x100000001);
              a5.i32[1] = a4.i32[1];
              *(void *)(a3 + 132) = a5.i64[0];
            }
            else
            {
              if ((v533 & 0x60) == 0) {
                sub_100077140();
              }
              uint64_t v536 = *(void *)(a3 + 144);
              if (v536)
              {
                *(void *)(a3 + 144) = v536 - 1;
                uint64_t v537 = 2 * *(void *)(a3 + 88);
              }
              else
              {
                uint64_t v537 = *(void *)(a3 + 88);
              }
              *(void *)(a3 + 152) += 2 * v537;
              *(_DWORD *)(a3 + 132) += 2;
            }
            unsigned int v539 = v807;
            if (v511 != 2) {
              unsigned int v539 = 0;
            }
            v69 += 404 * v539;
            if (v511 == 2) {
              int v511 = v798;
            }
            else {
              v511 -= 2;
            }
            v512 += 2;
            if (!v512) {
              return result;
            }
          }
        case 2u:
          goto LABEL_197;
        case 3u:
          if (!v75) {
            return result;
          }
          uint64_t v775 = a3 + 128;
          uint64_t v791 = a3 + 48;
          uint64_t v761 = a3 + 16;
          int v540 = 2 * v73;
          int v541 = -2 * v72;
          while (1)
          {
            sub_100043D28(v10, v74, 0, v791, v775, v69, &v808, a4, a5);
            if (*(_DWORD *)a3 > 8u) {
              sub_100077114();
            }
            int v544 = 1 << *(_DWORD *)a3;
            if ((v544 & 0x9A) != 0)
            {
              uint64_t v545 = *(void *)(a3 + 64);
              if (v545)
              {
                *(void *)(a3 + 64) = v545 - 1;
                uint64_t v546 = 2 * *(void *)(a3 + 8);
              }
              else
              {
                uint64_t v546 = *(void *)(a3 + 8);
              }
              *(void *)(a3 + 72) += 2 * v546;
              int32x2_t v549 = *(int32x2_t *)(a3 + 52);
              v543.i32[0] = vadd_s32(v549, (int32x2_t)0x200000002).u32[0];
              *(int8x8_t *)v542.i8 = veor_s8((int8x8_t)v549, (int8x8_t)0x100000001);
              v543.i32[1] = v542.i32[1];
              *(void *)(a3 + 52) = v543.i64[0];
            }
            else
            {
              if ((v544 & 0x60) == 0) {
                sub_100077140();
              }
              uint64_t v547 = *(void *)(a3 + 64);
              if (v547)
              {
                *(void *)(a3 + 64) = v547 - 1;
                uint64_t v548 = 2 * *(void *)(a3 + 8);
              }
              else
              {
                uint64_t v548 = *(void *)(a3 + 8);
              }
              *(void *)(a3 + 72) += 2 * v548;
              *(_DWORD *)(a3 + 52) += 2;
            }
            unsigned int v550 = *(_DWORD *)(a3 + 80);
            if (v550 > 8) {
              sub_100077114();
            }
            int v551 = 1 << v550;
            if ((v551 & 0x9A) != 0)
            {
              uint64_t v552 = *(void *)(a3 + 144);
              if (v552)
              {
                *(void *)(a3 + 144) = v552 - 1;
                uint64_t v553 = 2 * *(void *)(a3 + 88);
              }
              else
              {
                uint64_t v553 = *(void *)(a3 + 88);
              }
              *(void *)(a3 + 152) += 2 * v553;
              int32x2_t v556 = *(int32x2_t *)(a3 + 132);
              v543.i32[0] = vadd_s32(v556, (int32x2_t)0x200000002).u32[0];
              *(int8x8_t *)v542.i8 = veor_s8((int8x8_t)v556, (int8x8_t)0x100000001);
              v543.i32[1] = v542.i32[1];
              *(void *)(a3 + 132) = v543.i64[0];
            }
            else
            {
              if ((v551 & 0x60) == 0) {
                sub_100077140();
              }
              uint64_t v554 = *(void *)(a3 + 144);
              if (v554)
              {
                *(void *)(a3 + 144) = v554 - 1;
                uint64_t v555 = 2 * *(void *)(a3 + 88);
              }
              else
              {
                uint64_t v555 = *(void *)(a3 + 88);
              }
              *(void *)(a3 + 152) += 2 * v555;
              *(_DWORD *)(a3 + 132) += 2;
            }
            uint64_t result = (uint64_t)sub_100043D28(v10, v74, 1, v761, a3 + 96, v69, &v808, v542, v543);
            if (*(_DWORD *)a3 > 8u) {
              sub_1000770BC();
            }
            int v557 = 1 << *(_DWORD *)a3;
            if ((v557 & 0xFA) != 0)
            {
              uint64_t v558 = *(void *)(a3 + 32);
              if (v558)
              {
                *(void *)(a3 + 32) = v558 - 1;
                uint64_t v559 = *(void *)(a3 + 8);
              }
              else
              {
                uint64_t v559 = 2 * *(void *)(a3 + 8);
              }
              *(void *)(a3 + 40) += 2 * v559;
              int v561 = *(_DWORD *)(a3 + 20) + 2;
            }
            else
            {
              if ((v557 & 0x101) != 0)
              {
                *(void *)(a3 + 40) += 2 * *(void *)(a3 + 8);
                int32x2_t v560 = *(int32x2_t *)(a3 + 20);
                a5.i32[0] = vadd_s32(v560, (int32x2_t)0x100000001).u32[0];
                *(int8x8_t *)a4.i8 = veor_s8((int8x8_t)v560, (int8x8_t)0x100000001);
                a5.i32[1] = a4.i32[1];
                *(void *)(a3 + 20) = a5.i64[0];
                goto LABEL_716;
              }
              *(void *)(a3 + 40) += 2 * *(void *)(a3 + 8);
              int v561 = *(_DWORD *)(a3 + 20) + 1;
            }
            *(_DWORD *)(a3 + 20) = v561;
LABEL_716:
            unsigned int v562 = *(_DWORD *)(a3 + 80);
            if (v562 > 8) {
              sub_1000770BC();
            }
            int v563 = 1 << v562;
            if ((v563 & 0xFA) != 0)
            {
              uint64_t v564 = *(void *)(a3 + 112);
              if (v564)
              {
                *(void *)(a3 + 112) = v564 - 1;
                uint64_t v565 = *(void *)(a3 + 88);
              }
              else
              {
                uint64_t v565 = 2 * *(void *)(a3 + 88);
              }
              *(void *)(a3 + 120) += 2 * v565;
              int v567 = *(_DWORD *)(a3 + 100) + 2;
              goto LABEL_724;
            }
            if ((v563 & 0x101) == 0)
            {
              *(void *)(a3 + 120) += 2 * *(void *)(a3 + 88);
              int v567 = *(_DWORD *)(a3 + 100) + 1;
LABEL_724:
              *(_DWORD *)(a3 + 100) = v567;
              goto LABEL_725;
            }
            *(void *)(a3 + 120) += 2 * *(void *)(a3 + 88);
            int32x2_t v566 = *(int32x2_t *)(a3 + 100);
            a5.i32[0] = vadd_s32(v566, (int32x2_t)0x100000001).u32[0];
            *(int8x8_t *)a4.i8 = veor_s8((int8x8_t)v566, (int8x8_t)0x100000001);
            a5.i32[1] = a4.i32[1];
            *(void *)(a3 + 100) = a5.i64[0];
LABEL_725:
            unsigned int v568 = v807;
            if (v540 != 2) {
              unsigned int v568 = 0;
            }
            v69 += 404 * v568;
            if (v540 == 2) {
              int v540 = v798;
            }
            else {
              v540 -= 2;
            }
            v541 += 2;
            if (!v541) {
              return result;
            }
          }
        case 4u:
          if (!v75) {
            return result;
          }
          uint64_t v776 = a3 + 128;
          uint64_t v792 = a3 + 48;
          uint64_t v762 = a3 + 16;
          int v569 = 2 * v73;
          int v570 = -2 * v72;
          while (1)
          {
            sub_100043D28(v10, v74, 0, v792, v776, v69, &v808, a4, a5);
            if (*(_DWORD *)a3 > 8u) {
              sub_100077114();
            }
            int v573 = 1 << *(_DWORD *)a3;
            if ((v573 & 0x9A) != 0)
            {
              uint64_t v574 = *(void *)(a3 + 64);
              if (v574)
              {
                *(void *)(a3 + 64) = v574 - 1;
                uint64_t v575 = 2 * *(void *)(a3 + 8);
              }
              else
              {
                uint64_t v575 = *(void *)(a3 + 8);
              }
              *(void *)(a3 + 72) += 2 * v575;
              int32x2_t v578 = *(int32x2_t *)(a3 + 52);
              v572.i32[0] = vadd_s32(v578, (int32x2_t)0x200000002).u32[0];
              *(int8x8_t *)v571.i8 = veor_s8((int8x8_t)v578, (int8x8_t)0x100000001);
              v572.i32[1] = v571.i32[1];
              *(void *)(a3 + 52) = v572.i64[0];
            }
            else
            {
              if ((v573 & 0x60) == 0) {
                sub_100077140();
              }
              uint64_t v576 = *(void *)(a3 + 64);
              if (v576)
              {
                *(void *)(a3 + 64) = v576 - 1;
                uint64_t v577 = 2 * *(void *)(a3 + 8);
              }
              else
              {
                uint64_t v577 = *(void *)(a3 + 8);
              }
              *(void *)(a3 + 72) += 2 * v577;
              *(_DWORD *)(a3 + 52) += 2;
            }
            unsigned int v579 = *(_DWORD *)(a3 + 80);
            if (v579 > 8) {
              sub_100077114();
            }
            int v580 = 1 << v579;
            if ((v580 & 0x9A) != 0)
            {
              uint64_t v581 = *(void *)(a3 + 144);
              if (v581)
              {
                *(void *)(a3 + 144) = v581 - 1;
                uint64_t v582 = 2 * *(void *)(a3 + 88);
              }
              else
              {
                uint64_t v582 = *(void *)(a3 + 88);
              }
              *(void *)(a3 + 152) += 2 * v582;
              int32x2_t v585 = *(int32x2_t *)(a3 + 132);
              v572.i32[0] = vadd_s32(v585, (int32x2_t)0x200000002).u32[0];
              *(int8x8_t *)v571.i8 = veor_s8((int8x8_t)v585, (int8x8_t)0x100000001);
              v572.i32[1] = v571.i32[1];
              *(void *)(a3 + 132) = v572.i64[0];
            }
            else
            {
              if ((v580 & 0x60) == 0) {
                sub_100077140();
              }
              uint64_t v583 = *(void *)(a3 + 144);
              if (v583)
              {
                *(void *)(a3 + 144) = v583 - 1;
                uint64_t v584 = 2 * *(void *)(a3 + 88);
              }
              else
              {
                uint64_t v584 = *(void *)(a3 + 88);
              }
              *(void *)(a3 + 152) += 2 * v584;
              *(_DWORD *)(a3 + 132) += 2;
            }
            uint64_t result = (uint64_t)sub_100043D28(v10, v74, 1, v762, a3 + 96, v69, &v808, v571, v572);
            if (*(_DWORD *)a3 > 8u) {
              sub_1000770BC();
            }
            int v586 = 1 << *(_DWORD *)a3;
            if ((v586 & 0xFA) != 0)
            {
              uint64_t v587 = *(void *)(a3 + 32);
              if (v587)
              {
                *(void *)(a3 + 32) = v587 - 1;
                uint64_t v588 = *(void *)(a3 + 8);
              }
              else
              {
                uint64_t v588 = 2 * *(void *)(a3 + 8);
              }
              *(void *)(a3 + 40) += 2 * v588;
              int v590 = *(_DWORD *)(a3 + 20) + 2;
            }
            else
            {
              if ((v586 & 0x101) != 0)
              {
                *(void *)(a3 + 40) += 2 * *(void *)(a3 + 8);
                int32x2_t v589 = *(int32x2_t *)(a3 + 20);
                a5.i32[0] = vadd_s32(v589, (int32x2_t)0x100000001).u32[0];
                *(int8x8_t *)a4.i8 = veor_s8((int8x8_t)v589, (int8x8_t)0x100000001);
                a5.i32[1] = a4.i32[1];
                *(void *)(a3 + 20) = a5.i64[0];
                goto LABEL_767;
              }
              *(void *)(a3 + 40) += 2 * *(void *)(a3 + 8);
              int v590 = *(_DWORD *)(a3 + 20) + 1;
            }
            *(_DWORD *)(a3 + 20) = v590;
LABEL_767:
            unsigned int v591 = *(_DWORD *)(a3 + 80);
            if (v591 > 8) {
              sub_1000770BC();
            }
            int v592 = 1 << v591;
            if ((v592 & 0xFA) != 0)
            {
              uint64_t v593 = *(void *)(a3 + 112);
              if (v593)
              {
                *(void *)(a3 + 112) = v593 - 1;
                uint64_t v594 = *(void *)(a3 + 88);
              }
              else
              {
                uint64_t v594 = 2 * *(void *)(a3 + 88);
              }
              *(void *)(a3 + 120) += 2 * v594;
              int v596 = *(_DWORD *)(a3 + 100) + 2;
              goto LABEL_775;
            }
            if ((v592 & 0x101) == 0)
            {
              *(void *)(a3 + 120) += 2 * *(void *)(a3 + 88);
              int v596 = *(_DWORD *)(a3 + 100) + 1;
LABEL_775:
              *(_DWORD *)(a3 + 100) = v596;
              goto LABEL_776;
            }
            *(void *)(a3 + 120) += 2 * *(void *)(a3 + 88);
            int32x2_t v595 = *(int32x2_t *)(a3 + 100);
            a5.i32[0] = vadd_s32(v595, (int32x2_t)0x100000001).u32[0];
            *(int8x8_t *)a4.i8 = veor_s8((int8x8_t)v595, (int8x8_t)0x100000001);
            a5.i32[1] = a4.i32[1];
            *(void *)(a3 + 100) = a5.i64[0];
LABEL_776:
            unsigned int v597 = v807;
            if (v569 != 2) {
              unsigned int v597 = 0;
            }
            v69 += 404 * v597;
            if (v569 == 2) {
              int v569 = v798;
            }
            else {
              v569 -= 2;
            }
            v570 += 2;
            if (!v570) {
              return result;
            }
          }
        case 5u:
          if (!v75) {
            return result;
          }
          v777 = (int *)(a3 + 128);
          v793 = (int *)(a3 + 48);
          v763 = (int *)(a3 + 16);
          int v598 = 2 * v73;
          int v599 = -2 * v72;
          while (1)
          {
            sub_10004410C((uint64_t)v10, v74, v793, v777, v69, &v808);
            if (*(_DWORD *)a3 > 8u) {
              sub_100077114();
            }
            int v600 = 1 << *(_DWORD *)a3;
            if ((v600 & 0x9A) != 0)
            {
              uint64_t v601 = *(void *)(a3 + 64);
              if (v601)
              {
                *(void *)(a3 + 64) = v601 - 1;
                uint64_t v602 = 2 * *(void *)(a3 + 8);
              }
              else
              {
                uint64_t v602 = *(void *)(a3 + 8);
              }
              *(void *)(a3 + 72) += 2 * v602;
              int32x2_t v605 = *(int32x2_t *)(a3 + 52);
              LODWORD(v606) = vadd_s32(v605, (int32x2_t)0x200000002).u32[0];
              HIDWORD(v606) = veor_s8(*(int8x8_t *)&v605, (int8x8_t)0x100000001).i32[1];
              *(void *)(a3 + 52) = v606;
            }
            else
            {
              if ((v600 & 0x60) == 0) {
                sub_100077140();
              }
              uint64_t v603 = *(void *)(a3 + 64);
              if (v603)
              {
                *(void *)(a3 + 64) = v603 - 1;
                uint64_t v604 = 2 * *(void *)(a3 + 8);
              }
              else
              {
                uint64_t v604 = *(void *)(a3 + 8);
              }
              *(void *)(a3 + 72) += 2 * v604;
              *(_DWORD *)(a3 + 52) += 2;
            }
            unsigned int v607 = *(_DWORD *)(a3 + 80);
            if (v607 > 8) {
              sub_100077114();
            }
            int v608 = 1 << v607;
            if ((v608 & 0x9A) != 0)
            {
              uint64_t v609 = *(void *)(a3 + 144);
              if (v609)
              {
                *(void *)(a3 + 144) = v609 - 1;
                uint64_t v610 = 2 * *(void *)(a3 + 88);
              }
              else
              {
                uint64_t v610 = *(void *)(a3 + 88);
              }
              *(void *)(a3 + 152) += 2 * v610;
              int32x2_t v613 = *(int32x2_t *)(a3 + 132);
              LODWORD(v614) = vadd_s32(v613, (int32x2_t)0x200000002).u32[0];
              HIDWORD(v614) = veor_s8(*(int8x8_t *)&v613, (int8x8_t)0x100000001).i32[1];
              *(void *)(a3 + 132) = v614;
            }
            else
            {
              if ((v608 & 0x60) == 0) {
                sub_100077140();
              }
              uint64_t v611 = *(void *)(a3 + 144);
              if (v611)
              {
                *(void *)(a3 + 144) = v611 - 1;
                uint64_t v612 = 2 * *(void *)(a3 + 88);
              }
              else
              {
                uint64_t v612 = *(void *)(a3 + 88);
              }
              *(void *)(a3 + 152) += 2 * v612;
              *(_DWORD *)(a3 + 132) += 2;
            }
            uint64_t result = sub_10004410C((uint64_t)v10, v74, v763, (int *)(a3 + 96), v69, &v808);
            if (*(_DWORD *)a3 > 8u) {
              sub_1000770BC();
            }
            int v615 = 1 << *(_DWORD *)a3;
            if ((v615 & 0xFA) != 0)
            {
              uint64_t v616 = *(void *)(a3 + 32);
              if (v616)
              {
                *(void *)(a3 + 32) = v616 - 1;
                uint64_t v617 = *(void *)(a3 + 8);
              }
              else
              {
                uint64_t v617 = 2 * *(void *)(a3 + 8);
              }
              *(void *)(a3 + 40) += 2 * v617;
              int v620 = *(_DWORD *)(a3 + 20) + 2;
            }
            else
            {
              if ((v615 & 0x101) != 0)
              {
                *(void *)(a3 + 40) += 2 * *(void *)(a3 + 8);
                int32x2_t v618 = *(int32x2_t *)(a3 + 20);
                LODWORD(v619) = vadd_s32(v618, (int32x2_t)0x100000001).u32[0];
                HIDWORD(v619) = veor_s8(*(int8x8_t *)&v618, (int8x8_t)0x100000001).i32[1];
                *(void *)(a3 + 20) = v619;
                goto LABEL_818;
              }
              *(void *)(a3 + 40) += 2 * *(void *)(a3 + 8);
              int v620 = *(_DWORD *)(a3 + 20) + 1;
            }
            *(_DWORD *)(a3 + 20) = v620;
LABEL_818:
            unsigned int v621 = *(_DWORD *)(a3 + 80);
            if (v621 > 8) {
              sub_1000770BC();
            }
            int v622 = 1 << v621;
            if ((v622 & 0xFA) != 0)
            {
              uint64_t v623 = *(void *)(a3 + 112);
              if (v623)
              {
                *(void *)(a3 + 112) = v623 - 1;
                uint64_t v624 = *(void *)(a3 + 88);
              }
              else
              {
                uint64_t v624 = 2 * *(void *)(a3 + 88);
              }
              *(void *)(a3 + 120) += 2 * v624;
              int v627 = *(_DWORD *)(a3 + 100) + 2;
              goto LABEL_826;
            }
            if ((v622 & 0x101) == 0)
            {
              *(void *)(a3 + 120) += 2 * *(void *)(a3 + 88);
              int v627 = *(_DWORD *)(a3 + 100) + 1;
LABEL_826:
              *(_DWORD *)(a3 + 100) = v627;
              goto LABEL_827;
            }
            *(void *)(a3 + 120) += 2 * *(void *)(a3 + 88);
            int32x2_t v625 = *(int32x2_t *)(a3 + 100);
            LODWORD(v626) = vadd_s32(v625, (int32x2_t)0x100000001).u32[0];
            HIDWORD(v626) = veor_s8(*(int8x8_t *)&v625, (int8x8_t)0x100000001).i32[1];
            *(void *)(a3 + 100) = v626;
LABEL_827:
            unsigned int v628 = v807;
            if (v598 != 2) {
              unsigned int v628 = 0;
            }
            v69 += 404 * v628;
            if (v598 == 2) {
              int v598 = v798;
            }
            else {
              v598 -= 2;
            }
            v599 += 2;
            if (!v599) {
              return result;
            }
          }
        case 6u:
          if (!v75) {
            return result;
          }
          v778 = (int *)(a3 + 128);
          v794 = (int *)(a3 + 48);
          v764 = (int *)(a3 + 16);
          int v629 = 2 * v73;
          int v630 = -2 * v72;
          while (1)
          {
            sub_100044560((uint64_t)v10, v74, v794, v778, v69, &v808);
            if (*(_DWORD *)a3 > 8u) {
              sub_100077114();
            }
            int v631 = 1 << *(_DWORD *)a3;
            if ((v631 & 0x9A) != 0)
            {
              uint64_t v632 = *(void *)(a3 + 64);
              if (v632)
              {
                *(void *)(a3 + 64) = v632 - 1;
                uint64_t v633 = 2 * *(void *)(a3 + 8);
              }
              else
              {
                uint64_t v633 = *(void *)(a3 + 8);
              }
              *(void *)(a3 + 72) += 2 * v633;
              int32x2_t v636 = *(int32x2_t *)(a3 + 52);
              LODWORD(v637) = vadd_s32(v636, (int32x2_t)0x200000002).u32[0];
              HIDWORD(v637) = veor_s8(*(int8x8_t *)&v636, (int8x8_t)0x100000001).i32[1];
              *(void *)(a3 + 52) = v637;
            }
            else
            {
              if ((v631 & 0x60) == 0) {
                sub_100077140();
              }
              uint64_t v634 = *(void *)(a3 + 64);
              if (v634)
              {
                *(void *)(a3 + 64) = v634 - 1;
                uint64_t v635 = 2 * *(void *)(a3 + 8);
              }
              else
              {
                uint64_t v635 = *(void *)(a3 + 8);
              }
              *(void *)(a3 + 72) += 2 * v635;
              *(_DWORD *)(a3 + 52) += 2;
            }
            unsigned int v638 = *(_DWORD *)(a3 + 80);
            if (v638 > 8) {
              sub_100077114();
            }
            int v639 = 1 << v638;
            if ((v639 & 0x9A) != 0)
            {
              uint64_t v640 = *(void *)(a3 + 144);
              if (v640)
              {
                *(void *)(a3 + 144) = v640 - 1;
                uint64_t v641 = 2 * *(void *)(a3 + 88);
              }
              else
              {
                uint64_t v641 = *(void *)(a3 + 88);
              }
              *(void *)(a3 + 152) += 2 * v641;
              int32x2_t v644 = *(int32x2_t *)(a3 + 132);
              LODWORD(v645) = vadd_s32(v644, (int32x2_t)0x200000002).u32[0];
              HIDWORD(v645) = veor_s8(*(int8x8_t *)&v644, (int8x8_t)0x100000001).i32[1];
              *(void *)(a3 + 132) = v645;
            }
            else
            {
              if ((v639 & 0x60) == 0) {
                sub_100077140();
              }
              uint64_t v642 = *(void *)(a3 + 144);
              if (v642)
              {
                *(void *)(a3 + 144) = v642 - 1;
                uint64_t v643 = 2 * *(void *)(a3 + 88);
              }
              else
              {
                uint64_t v643 = *(void *)(a3 + 88);
              }
              *(void *)(a3 + 152) += 2 * v643;
              *(_DWORD *)(a3 + 132) += 2;
            }
            uint64_t result = sub_100044560((uint64_t)v10, v74, v764, (int *)(a3 + 96), v69, &v808);
            if (*(_DWORD *)a3 > 8u) {
              sub_1000770BC();
            }
            int v646 = 1 << *(_DWORD *)a3;
            if ((v646 & 0xFA) != 0)
            {
              uint64_t v647 = *(void *)(a3 + 32);
              if (v647)
              {
                *(void *)(a3 + 32) = v647 - 1;
                uint64_t v648 = *(void *)(a3 + 8);
              }
              else
              {
                uint64_t v648 = 2 * *(void *)(a3 + 8);
              }
              *(void *)(a3 + 40) += 2 * v648;
              int v651 = *(_DWORD *)(a3 + 20) + 2;
            }
            else
            {
              if ((v646 & 0x101) != 0)
              {
                *(void *)(a3 + 40) += 2 * *(void *)(a3 + 8);
                int32x2_t v649 = *(int32x2_t *)(a3 + 20);
                LODWORD(v650) = vadd_s32(v649, (int32x2_t)0x100000001).u32[0];
                HIDWORD(v650) = veor_s8(*(int8x8_t *)&v649, (int8x8_t)0x100000001).i32[1];
                *(void *)(a3 + 20) = v650;
                goto LABEL_869;
              }
              *(void *)(a3 + 40) += 2 * *(void *)(a3 + 8);
              int v651 = *(_DWORD *)(a3 + 20) + 1;
            }
            *(_DWORD *)(a3 + 20) = v651;
LABEL_869:
            unsigned int v652 = *(_DWORD *)(a3 + 80);
            if (v652 > 8) {
              sub_1000770BC();
            }
            int v653 = 1 << v652;
            if ((v653 & 0xFA) != 0)
            {
              uint64_t v654 = *(void *)(a3 + 112);
              if (v654)
              {
                *(void *)(a3 + 112) = v654 - 1;
                uint64_t v655 = *(void *)(a3 + 88);
              }
              else
              {
                uint64_t v655 = 2 * *(void *)(a3 + 88);
              }
              *(void *)(a3 + 120) += 2 * v655;
              int v658 = *(_DWORD *)(a3 + 100) + 2;
              goto LABEL_877;
            }
            if ((v653 & 0x101) == 0)
            {
              *(void *)(a3 + 120) += 2 * *(void *)(a3 + 88);
              int v658 = *(_DWORD *)(a3 + 100) + 1;
LABEL_877:
              *(_DWORD *)(a3 + 100) = v658;
              goto LABEL_878;
            }
            *(void *)(a3 + 120) += 2 * *(void *)(a3 + 88);
            int32x2_t v656 = *(int32x2_t *)(a3 + 100);
            LODWORD(v657) = vadd_s32(v656, (int32x2_t)0x100000001).u32[0];
            HIDWORD(v657) = veor_s8(*(int8x8_t *)&v656, (int8x8_t)0x100000001).i32[1];
            *(void *)(a3 + 100) = v657;
LABEL_878:
            unsigned int v659 = v807;
            if (v629 != 2) {
              unsigned int v659 = 0;
            }
            v69 += 404 * v659;
            if (v629 == 2) {
              int v629 = v798;
            }
            else {
              v629 -= 2;
            }
            v630 += 2;
            if (!v630) {
              return result;
            }
          }
        case 7u:
          if (!v75) {
            return result;
          }
          uint64_t v779 = a3 + 128;
          uint64_t v795 = a3 + 48;
          uint64_t v765 = a3 + 16;
          int v660 = 2 * v73;
          int v661 = -2 * v72;
          while (1)
          {
            sub_100043D28(v10, v74, 0, v795, v779, v69, &v808, a4, a5);
            if (*(_DWORD *)a3 > 8u) {
              sub_100077114();
            }
            int v664 = 1 << *(_DWORD *)a3;
            if ((v664 & 0x9A) != 0)
            {
              uint64_t v665 = *(void *)(a3 + 64);
              if (v665)
              {
                *(void *)(a3 + 64) = v665 - 1;
                uint64_t v666 = 2 * *(void *)(a3 + 8);
              }
              else
              {
                uint64_t v666 = *(void *)(a3 + 8);
              }
              *(void *)(a3 + 72) += 2 * v666;
              int32x2_t v669 = *(int32x2_t *)(a3 + 52);
              v663.i32[0] = vadd_s32(v669, (int32x2_t)0x200000002).u32[0];
              *(int8x8_t *)v662.i8 = veor_s8((int8x8_t)v669, (int8x8_t)0x100000001);
              v663.i32[1] = v662.i32[1];
              *(void *)(a3 + 52) = v663.i64[0];
            }
            else
            {
              if ((v664 & 0x60) == 0) {
                sub_100077140();
              }
              uint64_t v667 = *(void *)(a3 + 64);
              if (v667)
              {
                *(void *)(a3 + 64) = v667 - 1;
                uint64_t v668 = 2 * *(void *)(a3 + 8);
              }
              else
              {
                uint64_t v668 = *(void *)(a3 + 8);
              }
              *(void *)(a3 + 72) += 2 * v668;
              *(_DWORD *)(a3 + 52) += 2;
            }
            unsigned int v670 = *(_DWORD *)(a3 + 80);
            if (v670 > 8) {
              sub_100077114();
            }
            int v671 = 1 << v670;
            if ((v671 & 0x9A) != 0)
            {
              uint64_t v672 = *(void *)(a3 + 144);
              if (v672)
              {
                *(void *)(a3 + 144) = v672 - 1;
                uint64_t v673 = 2 * *(void *)(a3 + 88);
              }
              else
              {
                uint64_t v673 = *(void *)(a3 + 88);
              }
              *(void *)(a3 + 152) += 2 * v673;
              int32x2_t v676 = *(int32x2_t *)(a3 + 132);
              v663.i32[0] = vadd_s32(v676, (int32x2_t)0x200000002).u32[0];
              *(int8x8_t *)v662.i8 = veor_s8((int8x8_t)v676, (int8x8_t)0x100000001);
              v663.i32[1] = v662.i32[1];
              *(void *)(a3 + 132) = v663.i64[0];
            }
            else
            {
              if ((v671 & 0x60) == 0) {
                sub_100077140();
              }
              uint64_t v674 = *(void *)(a3 + 144);
              if (v674)
              {
                *(void *)(a3 + 144) = v674 - 1;
                uint64_t v675 = 2 * *(void *)(a3 + 88);
              }
              else
              {
                uint64_t v675 = *(void *)(a3 + 88);
              }
              *(void *)(a3 + 152) += 2 * v675;
              *(_DWORD *)(a3 + 132) += 2;
            }
            uint64_t result = (uint64_t)sub_100043D28(v10, v74, 1, v765, a3 + 96, v69, &v808, v662, v663);
            if (*(_DWORD *)a3 > 8u) {
              sub_1000770BC();
            }
            int v677 = 1 << *(_DWORD *)a3;
            if ((v677 & 0xFA) != 0)
            {
              uint64_t v678 = *(void *)(a3 + 32);
              if (v678)
              {
                *(void *)(a3 + 32) = v678 - 1;
                uint64_t v679 = *(void *)(a3 + 8);
              }
              else
              {
                uint64_t v679 = 2 * *(void *)(a3 + 8);
              }
              *(void *)(a3 + 40) += 2 * v679;
              int v681 = *(_DWORD *)(a3 + 20) + 2;
            }
            else
            {
              if ((v677 & 0x101) != 0)
              {
                *(void *)(a3 + 40) += 2 * *(void *)(a3 + 8);
                int32x2_t v680 = *(int32x2_t *)(a3 + 20);
                a5.i32[0] = vadd_s32(v680, (int32x2_t)0x100000001).u32[0];
                *(int8x8_t *)a4.i8 = veor_s8((int8x8_t)v680, (int8x8_t)0x100000001);
                a5.i32[1] = a4.i32[1];
                *(void *)(a3 + 20) = a5.i64[0];
                goto LABEL_920;
              }
              *(void *)(a3 + 40) += 2 * *(void *)(a3 + 8);
              int v681 = *(_DWORD *)(a3 + 20) + 1;
            }
            *(_DWORD *)(a3 + 20) = v681;
LABEL_920:
            unsigned int v682 = *(_DWORD *)(a3 + 80);
            if (v682 > 8) {
              sub_1000770BC();
            }
            int v683 = 1 << v682;
            if ((v683 & 0xFA) != 0)
            {
              uint64_t v684 = *(void *)(a3 + 112);
              if (v684)
              {
                *(void *)(a3 + 112) = v684 - 1;
                uint64_t v685 = *(void *)(a3 + 88);
              }
              else
              {
                uint64_t v685 = 2 * *(void *)(a3 + 88);
              }
              *(void *)(a3 + 120) += 2 * v685;
              int v687 = *(_DWORD *)(a3 + 100) + 2;
              goto LABEL_928;
            }
            if ((v683 & 0x101) == 0)
            {
              *(void *)(a3 + 120) += 2 * *(void *)(a3 + 88);
              int v687 = *(_DWORD *)(a3 + 100) + 1;
LABEL_928:
              *(_DWORD *)(a3 + 100) = v687;
              goto LABEL_929;
            }
            *(void *)(a3 + 120) += 2 * *(void *)(a3 + 88);
            int32x2_t v686 = *(int32x2_t *)(a3 + 100);
            a5.i32[0] = vadd_s32(v686, (int32x2_t)0x100000001).u32[0];
            *(int8x8_t *)a4.i8 = veor_s8((int8x8_t)v686, (int8x8_t)0x100000001);
            a5.i32[1] = a4.i32[1];
            *(void *)(a3 + 100) = a5.i64[0];
LABEL_929:
            unsigned int v688 = v807;
            if (v660 != 2) {
              unsigned int v688 = 0;
            }
            v69 += 404 * v688;
            if (v660 == 2) {
              int v660 = v798;
            }
            else {
              v660 -= 2;
            }
            v661 += 2;
            if (!v661) {
              return result;
            }
          }
        case 8u:
          if (!v75) {
            return result;
          }
          int16x8_t v689 = vdupq_n_s16(*(char *)(a2 + 308));
          int v690 = *(_DWORD *)(a2 + 24);
          int v796 = *(_DWORD *)(a3 + 16);
          if (v796) {
            uint64_t v691 = a3 + 16;
          }
          else {
            uint64_t v691 = a3 + 96;
          }
          int v780 = *(_DWORD *)(a2 + 16);
          uint64_t v758 = v691;
          v692.i64[0] = 0x1000100010001;
          v692.i64[1] = 0x1000100010001;
          v693.i64[0] = -1;
          v693.i64[1] = -1;
          v694.i64[0] = 0x2000200020002;
          v694.i64[1] = 0x2000200020002;
          v695.i64[0] = 0x4000400040004;
          v695.i64[1] = 0x4000400040004;
          v696.i64[0] = 0x7000700070007;
          v696.i64[1] = 0x7000700070007;
          v697.i64[0] = 0xF000F000F000FLL;
          v697.i64[1] = 0xF000F000F000FLL;
          v698.i64[0] = 0x5000500050005;
          v698.i64[1] = 0x5000500050005;
          int v699 = v798;
          break;
        default:
          sub_100077198();
      }
      while (1)
      {
        int v700 = v796;
        if (v780 < 1) {
          goto LABEL_971;
        }
        int v701 = 0;
        int v702 = *(_DWORD *)(v758 + 8);
        int8x16_t v703 = (int8x16_t)vdupq_n_s16(-(v702 & 1));
        uint64_t v704 = v69 - 404;
        v705 = *(const __int16 **)(a3 + 40);
        int v700 = v796;
        int v706 = v780;
LABEL_945:
        v707 = *(const __int16 **)(a3 + 120);
        int v708 = *(_DWORD *)(a3 + 96);
        if (!v700)
        {
          int v700 = *(_DWORD *)(a3 + 96);
          v705 = *(const __int16 **)(a3 + 120);
        }
        if (v700 > 7) {
          break;
        }
        int v709 = v706;
        if (v700 == v706) {
          goto LABEL_950;
        }
        if (v700 < 1) {
          sub_1000771F0();
        }
        unint64_t v710 = 0;
        uint64_t v711 = 2 * v700;
        do
        {
          v809.i16[v710 / 2] = *v705;
          v817.i16[v710 / 2] = v705[1];
          v816.i16[v710 / 2] = v705[2];
          v815.i16[v710 / 2] = v705[3];
          v710 += 2;
          v705 += 4;
        }
        while (v711 != v710);
        if (v706 >= 8) {
          int v712 = 8;
        }
        else {
          int v712 = v706;
        }
        if (v700 < v712)
        {
          v713 = &v815.i16[(unint64_t)v711 / 2];
          v714 = &v816.i16[(unint64_t)v711 / 2];
          v715 = &v817.i16[(unint64_t)v711 / 2];
          v716 = &v809.i16[(unint64_t)v711 / 2];
          int v717 = v700;
          do
          {
            *v716++ = *v707;
            *v715++ = v707[1];
            *v714++ = v707[2];
            *v713++ = v707[3];
            v707 += 4;
            ++v717;
          }
          while (v712 > v717);
        }
        v819.val[0] = (int16x8_t)v809;
        v819.val[1] = v817;
        v819.val[3] = v815;
        v819.val[2] = v816;
        v700 += v708 - v712;
        v705 = v707;
LABEL_961:
        uint64_t v718 = 0;
        int8x16_t v719 = (int8x16_t)vceqzq_s16((int16x8_t)vandq_s8((int8x16_t)v819.val[0], v695));
        int16x8_t v720 = (int16x8_t)vandq_s8((int8x16_t)v819.val[1], v696);
        int16x8_t v721 = vshrq_n_s16(v819.val[0], 3uLL);
        int8x16_t v722 = (int8x16_t)vaddq_s16(v819.val[3], (int16x8_t)vbslq_s8(v703, (int8x16_t)vnegq_s16(v721), (int8x16_t)v721));
        int8x16_t v723 = (int8x16_t)vcgtq_u16((uint16x8_t)v720, v698);
        int8x16_t v724 = (int8x16_t)vqshlq_n_u16((uint16x8_t)vabsq_s16(vshrq_n_s16(v819.val[1], 3uLL)), 4uLL);
        int16x8_t v725 = (int16x8_t)vandq_s8((int8x16_t)vaddq_s16((int16x8_t)vandq_s8((int8x16_t)v819.val[2], v697), (int16x8_t)vbicq_s8(v692, (int8x16_t)v819.val[0])), vorrq_s8(v723, (int8x16_t)vceqzq_s16((int16x8_t)vandq_s8((int8x16_t)v819.val[0], v694))));
        int16x8_t v726 = vaddq_s16((int16x8_t)vbslq_s8(v723, (int8x16_t)vaddq_s16(v720, v693), (int8x16_t)v720), (int16x8_t)vandq_s8(veorq_s8((int8x16_t)vcltzq_s16(v819.val[0]), (int8x16_t)vcgtq_s16(v819.val[1], v693)), v696));
        int16x8_t v727 = (int16x8_t)vshrq_n_u16((uint16x8_t)vbslq_s8(v723, (int8x16_t)vshrq_n_u16((uint16x8_t)v724, 1uLL), v724), 1uLL);
        int16x8_t v728 = vqshlq_s16(vqdmulhq_s16(v727, vmulq_s16((int16x8_t)vshrq_n_u16((uint16x8_t)v725, 1uLL), (int16x8_t)vshrq_n_u16((uint16x8_t)v819.val[2], 4uLL))), v689);
        int8x16_t v729 = (int8x16_t)vqdmulhq_s16(v728, v727);
        int8x16_t v730 = (int8x16_t)vqdmulhq_s16(v728, (int16x8_t)vshrq_n_u16(vqshlq_n_u16((uint16x8_t)vabsq_s16(v721), 4uLL), 1uLL));
        int8x16_t v731 = (int8x16_t)vceqzq_s16(v725);
        int8x16_t v809 = (int8x16_t)v726;
        int8x16_t v810 = vornq_s8(vandq_s8((int8x16_t)v725, v719), v719);
        int8x16_t v811 = vbslq_s8(v731, v722, v729);
        int8x16_t v812 = vbslq_s8(v731, (int8x16_t)v819.val[3], v730);
        int16x8_t v817 = (int16x8_t)v722;
        v732 = &v811;
        while (1)
        {
          BOOL v733 = v701 == 0;
          if (!v701) {
            int v701 = v690;
          }
          uint64_t v734 = v704 + 404 * v733;
          unsigned int v735 = v732[-2].u16[0];
          uint64_t v736 = v732[-1].u16[0];
          uint64_t v737 = v732->u16[0];
          uint64_t v738 = v732[1].u16[0];
          ++*(_DWORD *)(v734 + 384);
          uint64_t v739 = v817.u16[v718];
          *(void *)(v734 + 388) += v739;
          uint64_t result = v734 + 396;
          *(void *)(v734 + 396) += v739 * (unint64_t)v739;
          if (v736)
          {
            if (v736 != 0xFFFF)
            {
              v740 = (void *)(v734 + 24 * v735);
              uint64_t result = v740[1] + v737;
              *v740 += v736;
              v740[1] = result;
              v740[2] += v738;
            }
          }
          else
          {
            v741 = (_DWORD *)(v704 + 404 * v733 + 12 * v702);
            ++v741[84];
            v741[85] += v737;
            v741[86] += v738;
          }
          ++v808;
          if (v706 - 1 == v718) {
            break;
          }
          v732 = (int8x16_t *)((char *)v732 + 2);
          --v701;
          ++v718;
          v704 += 404 * v733;
          if (v718 == 8)
          {
            v706 -= 8;
            uint64_t v704 = v734;
            if (v706 + 1 > 1) {
              goto LABEL_945;
            }
            break;
          }
        }
LABEL_971:
        if (v700) {
          sub_1000771C4();
        }
        if (*(_DWORD *)a3 > 8u) {
          sub_1000770BC();
        }
        int v742 = 1 << *(_DWORD *)a3;
        if ((v742 & 0xFA) != 0)
        {
          uint64_t v743 = *(void *)(a3 + 32);
          if (v743)
          {
            *(void *)(a3 + 32) = v743 - 1;
            uint64_t v744 = *(void *)(a3 + 8);
          }
          else
          {
            uint64_t v744 = 2 * *(void *)(a3 + 8);
          }
          *(void *)(a3 + 40) += 2 * v744;
          int v747 = *(_DWORD *)(a3 + 20) + 2;
        }
        else
        {
          if ((v742 & 0x101) != 0)
          {
            *(void *)(a3 + 40) += 2 * *(void *)(a3 + 8);
            int32x2_t v745 = *(int32x2_t *)(a3 + 20);
            LODWORD(v746) = vadd_s32(v745, (int32x2_t)0x100000001).u32[0];
            HIDWORD(v746) = veor_s8(*(int8x8_t *)&v745, (int8x8_t)0x100000001).i32[1];
            *(void *)(a3 + 20) = v746;
            goto LABEL_981;
          }
          *(void *)(a3 + 40) += 2 * *(void *)(a3 + 8);
          int v747 = *(_DWORD *)(a3 + 20) + 1;
        }
        *(_DWORD *)(a3 + 20) = v747;
LABEL_981:
        unsigned int v748 = *(_DWORD *)(a3 + 80);
        if (v748 > 8) {
          sub_1000770BC();
        }
        int v749 = 1 << v748;
        if ((v749 & 0xFA) != 0)
        {
          uint64_t v750 = *(void *)(a3 + 112);
          if (v750)
          {
            *(void *)(a3 + 112) = v750 - 1;
            uint64_t v751 = *(void *)(a3 + 88);
          }
          else
          {
            uint64_t v751 = 2 * *(void *)(a3 + 88);
          }
          *(void *)(a3 + 120) += 2 * v751;
          int v754 = *(_DWORD *)(a3 + 100) + 2;
          goto LABEL_989;
        }
        if ((v749 & 0x101) == 0)
        {
          *(void *)(a3 + 120) += 2 * *(void *)(a3 + 88);
          int v754 = *(_DWORD *)(a3 + 100) + 1;
LABEL_989:
          *(_DWORD *)(a3 + 100) = v754;
          goto LABEL_990;
        }
        *(void *)(a3 + 120) += 2 * *(void *)(a3 + 88);
        int32x2_t v752 = *(int32x2_t *)(a3 + 100);
        LODWORD(v753) = vadd_s32(v752, (int32x2_t)0x100000001).u32[0];
        HIDWORD(v753) = veor_s8(*(int8x8_t *)&v752, (int8x8_t)0x100000001).i32[1];
        *(void *)(a3 + 100) = v753;
LABEL_990:
        unsigned int v755 = v807;
        if (v699 != 1) {
          unsigned int v755 = 0;
        }
        v69 += 404 * v755;
        if (v699 == 1) {
          int v699 = v798;
        }
        else {
          --v699;
        }
        if (!--v75) {
          return result;
        }
      }
      int v709 = 8;
LABEL_950:
      v700 -= v709;
      int16x8x4_t v819 = vld4q_s16(v705);
      v705 += 32;
      goto LABEL_961;
    }
    if (v70 != 2) {
      sub_100077064();
    }
    int v75 = *(_DWORD *)(a2 + 20);
    int v798 = *(_DWORD *)(a2 + 28);
    int v808 = 0;
LABEL_197:
    if (!v75) {
      return result;
    }
    uint64_t v199 = a3 + 96;
    int16x8_t v200 = vdupq_n_s16(*(char *)(a2 + 308));
    int v201 = 2 * *(_DWORD *)(a2 + 24);
    int v202 = 2 * *(_DWORD *)(a2 + 16);
    int v768 = v202 - 2;
    uint64_t v783 = a3 + 16;
    v203.i64[0] = 0x1000100010001;
    v203.i64[1] = 0x1000100010001;
    v204.i64[0] = -1;
    v204.i64[1] = -1;
    v205.i64[0] = 0x2000200020002;
    v205.i64[1] = 0x2000200020002;
    v206.i64[0] = 0x4000400040004;
    v206.i64[1] = 0x4000400040004;
    uint64_t result = 12;
    v207.i64[0] = 0x7000700070007;
    v207.i64[1] = 0x7000700070007;
    v208.i64[0] = 0xF000F000F000FLL;
    v208.i64[1] = 0xF000F000F000FLL;
    v209.i64[0] = 0x5000500050005;
    v209.i64[1] = 0x5000500050005;
    int v210 = v798;
    uint64_t v759 = a3 + 96;
    int v757 = v202;
    while (1)
    {
      if (v202 < 1) {
        goto LABEL_240;
      }
      int v211 = 0;
      int v212 = *(_DWORD *)(a3 + 16);
      int v214 = v768;
      uint64_t v213 = v783;
      if (!v212) {
        uint64_t v213 = v199;
      }
      uint64_t v215 = *(int *)(v213 + 8);
      int v216 = 2 * v212;
      uint64_t v217 = v69 - 404;
      __int16 v218 = *(__int16 **)(a3 + 40);
      int v219 = v202;
LABEL_203:
      uint64_t v220 = *(__int16 **)(a3 + 120);
      int v221 = *(_DWORD *)(a3 + 96);
      int v222 = v216 ? v216 : 2 * v221;
      unsigned int v223 = v216 ? v218 : *(__int16 **)(a3 + 120);
      if (v222 >= 16) {
        break;
      }
      int v224 = v219;
      if (v222 == v219) {
        goto LABEL_212;
      }
      if (v222 <= 0) {
        sub_10007721C();
      }
      uint64_t v232 = v222 >> 1;
      if (v222 != 1)
      {
        if (v232 <= 1) {
          uint64_t v233 = 1;
        }
        else {
          uint64_t v233 = v232;
        }
        float v234 = v223 + 4;
        float v235 = &v814;
        float v236 = &v813;
        float v237 = &v815;
        float v238 = &v816;
        float v239 = &v817;
        float v240 = &v809;
        do
        {
          v240->i16[0] = *v234;
          float v240 = (int8x16_t *)((char *)v240 + 2);
          v239->i16[0] = v234[1];
          float v239 = (int16x8_t *)((char *)v239 + 2);
          v238->i16[0] = v234[2];
          float v238 = (int16x8_t *)((char *)v238 + 2);
          v237->i16[0] = v234[3];
          float v237 = (int16x8_t *)((char *)v237 + 2);
          __int16 v241 = *(v234 - 1);
          v236->i16[0] = v241;
          float v236 = (int16x8_t *)((char *)v236 + 2);
          v235->i16[0] = v241 - (*(v234 - 4) >> 3);
          float v235 = (int8x16_t *)((char *)v235 + 2);
          v234 += 8;
          --v233;
        }
        while (v233);
      }
      LODWORD(v242) = v219 >> 1;
      if (v219 <= 15) {
        uint64_t v242 = v242;
      }
      else {
        uint64_t v242 = 8;
      }
      if (v232 >= v242)
      {
        uint64_t v199 = v759;
        int v202 = v757;
      }
      else
      {
        uint64_t v243 = v232;
        uint64_t v199 = v759;
        int v202 = v757;
        do
        {
          v809.i16[v243] = v220[4];
          v817.i16[v243] = v220[5];
          v816.i16[v243] = v220[6];
          v815.i16[v243] = v220[7];
          __int16 v244 = v220[3];
          v813.i16[v243] = v244;
          v814.i16[v243] = v244 - (*v220 >> 3);
          v220 += 8;
          ++v243;
        }
        while (v242 != v243);
      }
      int16x8_t v226 = (int16x8_t)v809;
      int16x8_t v227 = v817;
      int8x16_t v230 = (int8x16_t)v815;
      int8x16_t v228 = (int8x16_t)v816;
      int16x8_t v229 = v813;
      int8x16_t v231 = v814;
      int v216 = 2 * (v221 - v242 + v232);
      __int16 v218 = v220;
LABEL_229:
      uint64_t v245 = 0;
      int8x16_t v246 = (int8x16_t)vceqzq_s16((int16x8_t)vandq_s8((int8x16_t)v226, v206));
      int16x8_t v247 = (int16x8_t)vandq_s8((int8x16_t)v227, v207);
      int8x16_t v248 = (int8x16_t)vcgtq_u16((uint16x8_t)v247, v209);
      int8x16_t v249 = (int8x16_t)vqshlq_n_u16((uint16x8_t)vabsq_s16(vshrq_n_s16(v227, 3uLL)), 4uLL);
      uint16x8_t v250 = vqshlq_n_u16((uint16x8_t)vabsq_s16(vshrq_n_s16(v226, 3uLL)), 4uLL);
      int16x8_t v251 = (int16x8_t)vandq_s8((int8x16_t)vaddq_s16((int16x8_t)vandq_s8(v228, v208), (int16x8_t)vbicq_s8(v203, (int8x16_t)v226)), vorrq_s8(v248, (int8x16_t)vceqzq_s16((int16x8_t)vandq_s8((int8x16_t)v226, v205))));
      int8x16_t v252 = (int8x16_t)vaddq_s16((int16x8_t)vbslq_s8(v248, (int8x16_t)vaddq_s16(v247, v204), (int8x16_t)v247), (int16x8_t)vandq_s8(veorq_s8((int8x16_t)vcltzq_s16(v226), (int8x16_t)vcgtq_s16(v227, v204)), v207));
      int16x8_t v253 = vmulq_s16((int16x8_t)vshrq_n_u16((uint16x8_t)v251, 1uLL), (int16x8_t)vshrq_n_u16((uint16x8_t)v228, 4uLL));
      int16x8_t v254 = (int16x8_t)vshrq_n_u16((uint16x8_t)vbslq_s8(v248, (int8x16_t)vshrq_n_u16((uint16x8_t)v249, 1uLL), v249), 1uLL);
      int16x8_t v255 = vqshlq_s16(vqdmulhq_s16(v254, v253), v200);
      int8x16_t v256 = (int8x16_t)vceqzq_s16(v251);
      int16x8_t v817 = (int16x8_t)v231;
      int8x16_t v809 = vornq_s8(vandq_s8((int8x16_t)v251, v246), v246);
      int8x16_t v810 = vbslq_s8(v256, v231, (int8x16_t)vqdmulhq_s16(v255, v254));
      int8x16_t v811 = vbslq_s8(v256, (int8x16_t)v229, (int8x16_t)vqdmulhq_s16(v255, (int16x8_t)vshrq_n_u16(v250, 1uLL)));
      int8x16_t v812 = vbslq_s8(v256, v230, v252);
      while (1)
      {
        BOOL v257 = v211 == 0;
        if (!v211) {
          int v211 = v201;
        }
        uint64_t v258 = v217 + 404 * v257;
        uint64_t v259 = v809.u16[v245];
        ++*(_DWORD *)(v258 + 384);
        uint64_t v260 = v817.u16[v245];
        *(void *)(v258 + 388) += v260;
        *(void *)(v258 + 396) += v260 * (unint64_t)v260;
        if (v259)
        {
          if (v259 != 0xFFFF)
          {
            uint64_t v261 = v811.u16[v245];
            uint64_t v262 = (void *)(v258 + 24 * v812.u16[v245]);
            uint64_t v263 = v262[1] + *(unsigned __int16 *)((char *)&v809 + v245 * 2 + 16);
            *v262 += v259;
            v262[1] = v263;
            v262[2] += v261;
          }
        }
        else
        {
          int v264 = *(unsigned __int16 *)((char *)&v809 + v245 * 2 + 16);
          int v265 = v811.u16[v245];
          int v266 = v812.u16[v245];
          uint64_t v267 = v217 + 404 * v257 + 336;
          int v268 = (_DWORD *)(v267 + 12 * (int)v215);
          int v269 = v268[1] + v264;
          ++*v268;
          v268[1] = v269;
          v268[2] += v265;
          int v270 = (_DWORD *)(v267 + 12 * (v215 + 1));
          int v271 = v270[1];
          ++*v270;
          v270[1] = v271 + v264;
          v270[2] += v266;
        }
        ++v808;
        if (v214 == (v245 * 2)) {
          break;
        }
        v211 -= 2;
        ++v245;
        uint64_t v217 = v258;
        if (v245 == 8)
        {
          v214 -= 16;
          uint64_t v217 = v258;
          BOOL v272 = v219 <= 16;
          v219 -= 16;
          if (v272) {
            break;
          }
          goto LABEL_203;
        }
      }
LABEL_240:
      if (*(_DWORD *)a3 > 8u) {
        sub_1000770BC();
      }
      int v273 = 1 << *(_DWORD *)a3;
      if ((v273 & 0xFA) != 0)
      {
        uint64_t v274 = *(void *)(a3 + 32);
        if (v274)
        {
          *(void *)(a3 + 32) = v274 - 1;
          uint64_t v275 = *(void *)(a3 + 8);
        }
        else
        {
          uint64_t v275 = 2 * *(void *)(a3 + 8);
        }
        *(void *)(a3 + 40) += 2 * v275;
        int v278 = *(_DWORD *)(a3 + 20) + 2;
      }
      else
      {
        if ((v273 & 0x101) != 0)
        {
          *(void *)(a3 + 40) += 2 * *(void *)(a3 + 8);
          int32x2_t v276 = *(int32x2_t *)(a3 + 20);
          LODWORD(v277) = vadd_s32(v276, (int32x2_t)0x100000001).u32[0];
          HIDWORD(v277) = veor_s8(*(int8x8_t *)&v276, (int8x8_t)0x100000001).i32[1];
          *(void *)(a3 + 20) = v277;
          goto LABEL_249;
        }
        *(void *)(a3 + 40) += 2 * *(void *)(a3 + 8);
        int v278 = *(_DWORD *)(a3 + 20) + 1;
      }
      *(_DWORD *)(a3 + 20) = v278;
LABEL_249:
      unsigned int v279 = *(_DWORD *)(a3 + 80);
      if (v279 > 8) {
        sub_1000770BC();
      }
      int v280 = 1 << v279;
      if ((v280 & 0xFA) != 0)
      {
        uint64_t v281 = *(void *)(a3 + 112);
        if (v281)
        {
          *(void *)(a3 + 112) = v281 - 1;
          uint64_t v282 = *(void *)(a3 + 88);
        }
        else
        {
          uint64_t v282 = 2 * *(void *)(a3 + 88);
        }
        *(void *)(a3 + 120) += 2 * v282;
        int v285 = *(_DWORD *)(a3 + 100) + 2;
        goto LABEL_257;
      }
      if ((v280 & 0x101) == 0)
      {
        *(void *)(a3 + 120) += 2 * *(void *)(a3 + 88);
        int v285 = *(_DWORD *)(a3 + 100) + 1;
LABEL_257:
        *(_DWORD *)(a3 + 100) = v285;
        goto LABEL_258;
      }
      *(void *)(a3 + 120) += 2 * *(void *)(a3 + 88);
      int32x2_t v283 = *(int32x2_t *)(a3 + 100);
      LODWORD(v284) = vadd_s32(v283, (int32x2_t)0x100000001).u32[0];
      HIDWORD(v284) = veor_s8(*(int8x8_t *)&v283, (int8x8_t)0x100000001).i32[1];
      *(void *)(a3 + 100) = v284;
LABEL_258:
      unsigned int v286 = v807;
      if (v210 != 1) {
        unsigned int v286 = 0;
      }
      v69 += 404 * v286;
      if (v210 == 1) {
        int v210 = v798;
      }
      else {
        --v210;
      }
      if (!--v75) {
        return result;
      }
    }
    int v224 = 16;
LABEL_212:
    uint64_t v225 = v223;
    int16x8x4_t v820 = vld4q_s16(v225);
    v225 += 32;
    int16x8x4_t v821 = vld4q_s16(v225);
    int16x8_t v226 = vuzp2q_s16(v820.val[0], v821.val[0]);
    int16x8_t v227 = vuzp2q_s16(v820.val[1], v821.val[1]);
    int8x16_t v228 = (int8x16_t)vuzp2q_s16(v820.val[2], v821.val[2]);
    int16x8_t v229 = vuzp1q_s16(v820.val[3], v821.val[3]);
    int8x16_t v230 = (int8x16_t)vuzp2q_s16(v820.val[3], v821.val[3]);
    int8x16_t v231 = (int8x16_t)vsraq_n_s16(v229, vuzp1q_s16(v820.val[0], v821.val[0]), 3uLL);
    __int16 v218 = v223 + 64;
    int v216 = v222 - v224;
    goto LABEL_229;
  }
  if (result) {
    sub_100077038();
  }
  uint64_t v11 = a2 + 6956;
  unsigned int v12 = *(_DWORD *)(a2 + 12);
  if (v12 - 3 < 6 || v12 < 2)
  {
    int v14 = *(_DWORD *)(a2 + 20);
    int v15 = *(_DWORD *)(a2 + 28);
    v809.i32[0] = 0;
    uint64_t v16 = a2 + 304;
    int v17 = 2 * v14;
    uint64_t v18 = (2 * v15);
    int v19 = 2 * v15;
    switch(v12)
    {
      case 0u:
        if (!v17) {
          return result;
        }
        int v20 = *(_DWORD *)(a2 + 24);
        int v21 = *(_DWORD *)(a3 + 16);
        int v797 = *(_DWORD *)(a2 + 16);
        int8x8_t v22 = (int8x8_t)vdup_n_s32(0x7FF8u);
        int v23 = v18;
        while (1)
        {
          int v24 = v21;
          if (v797 >= 1)
          {
            int v25 = 0;
            uint64_t v26 = v11 - 404;
            int v27 = *(_DWORD *)(a3 + 24);
            unsigned int v28 = *(unsigned __int16 **)(a3 + 40);
            int v29 = v797 + 1;
            int v24 = v21;
            char v30 = *(unsigned char *)(a2 + 308);
            do
            {
              BOOL v31 = v24 == 0;
              if (v24)
              {
                int v32 = v27;
              }
              else
              {
                int v24 = *(_DWORD *)(a3 + 96);
                int v32 = *(_DWORD *)(a3 + 104);
              }
              if (v31) {
                unsigned int v28 = *(unsigned __int16 **)(a3 + 120);
              }
              BOOL v33 = v25 == 0;
              if (!v25) {
                int v25 = v20;
              }
              uint64_t v34 = v26 + 404 * v33;
              unsigned int v35 = *v28;
              int v36 = (__int16)v35 >> 3;
              int v37 = v28[3];
              if (v32) {
                int v38 = -v36;
              }
              else {
                LOWORD(v38) = (__int16)v35 >> 3;
              }
              unsigned __int16 v39 = v38 + v37;
              ++*(_DWORD *)(v34 + 384);
              *(void *)(v34 + 388) += (unsigned __int16)(v38 + v37);
              *(void *)(v34 + 396) += (unsigned __int16)(v38 + v37) * (unint64_t)(unsigned __int16)(v38 + v37);
              if ((v35 & 4) == 0)
              {
                int v40 = (__int16)v28[1];
                unsigned int v41 = v40 & 7;
                if ((v35 & 1) != 0 || (((v40 & 7u) < 6) & (v35 >> 1)) != 0)
                {
                  unint64_t v54 = (_DWORD *)(v26 + 404 * v33 + 12 * v32);
                  ++v54[84];
                  v54[85] += v39;
                  v54[86] += v37;
                }
                else
                {
                  __int16 v42 = v41 > 5;
                  unsigned int v43 = v28[2];
                  uint64_t v44 = (v43 & 0xF) + 1;
                  unsigned int v45 = v43 >> 4;
                  int v46 = v40 >> 3;
                  if (v40 < 0) {
                    int v46 = -v46;
                  }
                  if (v36 < 0) {
                    int v36 = -v36;
                  }
                  unsigned __int16 v47 = v41 - v42;
                  unsigned int v48 = (16 * (v46 & 0xFFFu)) >> v42;
                  unsigned int v49 = (v44 >> 1) * v45;
                  if (((v40 ^ v35) & 0x8000u) == 0) {
                    unsigned __int16 v50 = v47 + 7;
                  }
                  else {
                    unsigned __int16 v50 = v47;
                  }
                  uint64_t v51 = v34 + 24 * v50;
                  a6.n128_u32[0] = v48;
                  v52.i32[0] = vshr_n_u32((uint32x2_t)a6.n128_u64[0], 1uLL).u32[0];
                  a6.n128_u32[1] = 8 * v36;
                  v52.i32[1] = vand_s8(*(int8x8_t *)&a6, v22).i32[1];
                  signed int v53 = (v52.i32[0] * v49) >> 15 << v30;
                  if (v53 <= -32768) {
                    signed int v53 = -32768;
                  }
                  if (v53 >= 0x7FFF) {
                    signed int v53 = 0x7FFF;
                  }
                  *(void *)v51 += v44;
                  a6 = (__n128)vaddw_u32(*(uint64x2_t *)(v51 + 8), (uint32x2_t)vshr_n_s32(vmul_s32(vdup_n_s32(v53), v52), 0xFuLL));
                  *(__n128 *)(v51 + 8) = a6;
                }
              }
              v28 += 4;
              --v24;
              --v25;
              ++v809.i32[0];
              int v27 = v32 ^ 1;
              --v29;
              uint64_t v26 = v34;
            }
            while (v29 > 1);
          }
          if (v24) {
            sub_1000770E8();
          }
          if (*(_DWORD *)a3 > 8u) {
            sub_1000770BC();
          }
          int v55 = 1 << *(_DWORD *)a3;
          if ((v55 & 0xFA) != 0)
          {
            uint64_t v56 = *(void *)(a3 + 32);
            int v57 = v19;
            if (v56)
            {
              *(void *)(a3 + 32) = v56 - 1;
              uint64_t v58 = *(void *)(a3 + 8);
            }
            else
            {
              uint64_t v58 = 2 * *(void *)(a3 + 8);
            }
            *(void *)(a3 + 40) += 2 * v58;
            int v61 = *(_DWORD *)(a3 + 20) + 2;
          }
          else
          {
            int v57 = v19;
            if ((v55 & 0x101) != 0)
            {
              *(void *)(a3 + 40) += 2 * *(void *)(a3 + 8);
              int32x2_t v59 = *(int32x2_t *)(a3 + 20);
              LODWORD(v60) = vadd_s32(v59, (int32x2_t)0x100000001).u32[0];
              a6.n128_u64[0] = (unint64_t)veor_s8((int8x8_t)v59, (int8x8_t)0x100000001);
              HIDWORD(v60) = a6.n128_u32[1];
              *(void *)(a3 + 20) = v60;
              goto LABEL_49;
            }
            *(void *)(a3 + 40) += 2 * *(void *)(a3 + 8);
            int v61 = *(_DWORD *)(a3 + 20) + 1;
          }
          *(_DWORD *)(a3 + 20) = v61;
LABEL_49:
          unsigned int v62 = *(_DWORD *)(a3 + 80);
          if (v62 > 8) {
            sub_1000770BC();
          }
          int v63 = 1 << v62;
          if ((v63 & 0xFA) != 0)
          {
            uint64_t v64 = *(void *)(a3 + 112);
            if (v64)
            {
              *(void *)(a3 + 112) = v64 - 1;
              uint64_t v65 = *(void *)(a3 + 88);
            }
            else
            {
              uint64_t v65 = 2 * *(void *)(a3 + 88);
            }
            *(void *)(a3 + 120) += 2 * v65;
            int v68 = *(_DWORD *)(a3 + 100) + 2;
            goto LABEL_57;
          }
          if ((v63 & 0x101) == 0)
          {
            *(void *)(a3 + 120) += 2 * *(void *)(a3 + 88);
            int v68 = *(_DWORD *)(a3 + 100) + 1;
LABEL_57:
            *(_DWORD *)(a3 + 100) = v68;
            goto LABEL_58;
          }
          *(void *)(a3 + 120) += 2 * *(void *)(a3 + 88);
          int32x2_t v66 = *(int32x2_t *)(a3 + 100);
          LODWORD(v67) = vadd_s32(v66, (int32x2_t)0x100000001).u32[0];
          a6.n128_u64[0] = (unint64_t)veor_s8((int8x8_t)v66, (int8x8_t)0x100000001);
          HIDWORD(v67) = a6.n128_u32[1];
          *(void *)(a3 + 100) = v67;
LABEL_58:
          uint64_t result = v807;
          if (v23 != 1) {
            uint64_t result = 0;
          }
          v11 += 404 * result;
          if (v23 == 1) {
            int v23 = v57;
          }
          else {
            --v23;
          }
          if (!--v17) {
            return result;
          }
        }
      case 1u:
        if (!v17) {
          return result;
        }
        v784 = (int *)(a3 + 48);
        v800 = (int *)(a3 + 96);
        int v287 = 2 * v15;
        int v288 = -2 * v14;
        while (1)
        {
          sub_100043618((uint64_t)v10, v16, 1, (int *)(a3 + 16), v800, v11, &v809, *(double *)a4.i64, (__n128)a5);
          if (*(_DWORD *)a3 > 8u) {
            sub_1000770BC();
          }
          int v291 = 1 << *(_DWORD *)a3;
          if ((v291 & 0xFA) != 0)
          {
            uint64_t v292 = *(void *)(a3 + 32);
            if (v292)
            {
              *(void *)(a3 + 32) = v292 - 1;
              uint64_t v293 = *(void *)(a3 + 8);
            }
            else
            {
              uint64_t v293 = 2 * *(void *)(a3 + 8);
            }
            *(void *)(a3 + 40) += 2 * v293;
            int v295 = *(_DWORD *)(a3 + 20) + 2;
          }
          else
          {
            if ((v291 & 0x101) != 0)
            {
              *(void *)(a3 + 40) += 2 * *(void *)(a3 + 8);
              int32x2_t v294 = *(int32x2_t *)(a3 + 20);
              v290.n128_u32[0] = vadd_s32(v294, (int32x2_t)0x100000001).u32[0];
              int8x8_t v289 = veor_s8((int8x8_t)v294, (int8x8_t)0x100000001);
              v290.n128_u32[1] = v289.u32[1];
              *(void *)(a3 + 20) = v290.n128_u64[0];
              goto LABEL_278;
            }
            *(void *)(a3 + 40) += 2 * *(void *)(a3 + 8);
            int v295 = *(_DWORD *)(a3 + 20) + 1;
          }
          *(_DWORD *)(a3 + 20) = v295;
LABEL_278:
          unsigned int v296 = *(_DWORD *)(a3 + 80);
          if (v296 > 8) {
            sub_1000770BC();
          }
          int v297 = 1 << v296;
          if ((v297 & 0xFA) != 0)
          {
            uint64_t v298 = *(void *)(a3 + 112);
            if (v298)
            {
              *(void *)(a3 + 112) = v298 - 1;
              uint64_t v299 = *(void *)(a3 + 88);
            }
            else
            {
              uint64_t v299 = 2 * *(void *)(a3 + 88);
            }
            *(void *)(a3 + 120) += 2 * v299;
            int v301 = *(_DWORD *)(a3 + 100) + 2;
            goto LABEL_286;
          }
          if ((v297 & 0x101) == 0)
          {
            *(void *)(a3 + 120) += 2 * *(void *)(a3 + 88);
            int v301 = *(_DWORD *)(a3 + 100) + 1;
LABEL_286:
            *(_DWORD *)(a3 + 100) = v301;
            goto LABEL_287;
          }
          *(void *)(a3 + 120) += 2 * *(void *)(a3 + 88);
          int32x2_t v300 = *(int32x2_t *)(a3 + 100);
          v290.n128_u32[0] = vadd_s32(v300, (int32x2_t)0x100000001).u32[0];
          int8x8_t v289 = veor_s8((int8x8_t)v300, (int8x8_t)0x100000001);
          v290.n128_u32[1] = v289.u32[1];
          *(void *)(a3 + 100) = v290.n128_u64[0];
LABEL_287:
          uint64_t result = sub_100043618((uint64_t)v10, v16, 0, v784, (int *)(a3 + 128), v11, &v809, *(double *)&v289, v290);
          if (*(_DWORD *)a3 > 8u) {
            sub_100077114();
          }
          int v302 = 1 << *(_DWORD *)a3;
          if ((v302 & 0x9A) != 0)
          {
            uint64_t v303 = *(void *)(a3 + 64);
            if (v303)
            {
              *(void *)(a3 + 64) = v303 - 1;
              uint64_t v304 = 2 * *(void *)(a3 + 8);
            }
            else
            {
              uint64_t v304 = *(void *)(a3 + 8);
            }
            *(void *)(a3 + 72) += 2 * v304;
            int32x2_t v307 = *(int32x2_t *)(a3 + 52);
            a5.i32[0] = vadd_s32(v307, (int32x2_t)0x200000002).u32[0];
            *(int8x8_t *)a4.i8 = veor_s8((int8x8_t)v307, (int8x8_t)0x100000001);
            a5.i32[1] = a4.i32[1];
            *(void *)(a3 + 52) = a5.i64[0];
          }
          else
          {
            if ((v302 & 0x60) == 0) {
              sub_100077140();
            }
            uint64_t v305 = *(void *)(a3 + 64);
            if (v305)
            {
              *(void *)(a3 + 64) = v305 - 1;
              uint64_t v306 = 2 * *(void *)(a3 + 8);
            }
            else
            {
              uint64_t v306 = *(void *)(a3 + 8);
            }
            *(void *)(a3 + 72) += 2 * v306;
            *(_DWORD *)(a3 + 52) += 2;
          }
          unsigned int v308 = *(_DWORD *)(a3 + 80);
          if (v308 > 8) {
            sub_100077114();
          }
          int v309 = 1 << v308;
          if ((v309 & 0x9A) != 0)
          {
            uint64_t v310 = *(void *)(a3 + 144);
            if (v310)
            {
              *(void *)(a3 + 144) = v310 - 1;
              uint64_t v311 = 2 * *(void *)(a3 + 88);
            }
            else
            {
              uint64_t v311 = *(void *)(a3 + 88);
            }
            *(void *)(a3 + 152) += 2 * v311;
            int32x2_t v314 = *(int32x2_t *)(a3 + 132);
            a5.i32[0] = vadd_s32(v314, (int32x2_t)0x200000002).u32[0];
            *(int8x8_t *)a4.i8 = veor_s8((int8x8_t)v314, (int8x8_t)0x100000001);
            a5.i32[1] = a4.i32[1];
            *(void *)(a3 + 132) = a5.i64[0];
          }
          else
          {
            if ((v309 & 0x60) == 0) {
              sub_100077140();
            }
            uint64_t v312 = *(void *)(a3 + 144);
            if (v312)
            {
              *(void *)(a3 + 144) = v312 - 1;
              uint64_t v313 = 2 * *(void *)(a3 + 88);
            }
            else
            {
              uint64_t v313 = *(void *)(a3 + 88);
            }
            *(void *)(a3 + 152) += 2 * v313;
            *(_DWORD *)(a3 + 132) += 2;
          }
          unsigned int v315 = v807;
          if (v287 != 2) {
            unsigned int v315 = 0;
          }
          v11 += 404 * v315;
          if (v287 == 2) {
            int v287 = v18;
          }
          else {
            v287 -= 2;
          }
          v288 += 2;
          if (!v288) {
            return result;
          }
        }
      case 2u:
        goto LABEL_135;
      case 3u:
        if (!v17) {
          return result;
        }
        v785 = (int *)(a3 + 16);
        v801 = (int *)(a3 + 128);
        v769 = (int *)(a3 + 96);
        int v316 = 2 * v15;
        int v317 = -2 * v14;
        while (1)
        {
          sub_100043618((uint64_t)v10, v16, 0, (int *)(a3 + 48), v801, v11, &v809, *(double *)a4.i64, (__n128)a5);
          if (*(_DWORD *)a3 > 8u) {
            sub_100077114();
          }
          int v320 = 1 << *(_DWORD *)a3;
          if ((v320 & 0x9A) != 0)
          {
            uint64_t v321 = *(void *)(a3 + 64);
            if (v321)
            {
              *(void *)(a3 + 64) = v321 - 1;
              uint64_t v322 = 2 * *(void *)(a3 + 8);
            }
            else
            {
              uint64_t v322 = *(void *)(a3 + 8);
            }
            *(void *)(a3 + 72) += 2 * v322;
            int32x2_t v325 = *(int32x2_t *)(a3 + 52);
            v319.n128_u32[0] = vadd_s32(v325, (int32x2_t)0x200000002).u32[0];
            int8x8_t v318 = veor_s8((int8x8_t)v325, (int8x8_t)0x100000001);
            v319.n128_u32[1] = v318.u32[1];
            *(void *)(a3 + 52) = v319.n128_u64[0];
          }
          else
          {
            if ((v320 & 0x60) == 0) {
              sub_100077140();
            }
            uint64_t v323 = *(void *)(a3 + 64);
            if (v323)
            {
              *(void *)(a3 + 64) = v323 - 1;
              uint64_t v324 = 2 * *(void *)(a3 + 8);
            }
            else
            {
              uint64_t v324 = *(void *)(a3 + 8);
            }
            *(void *)(a3 + 72) += 2 * v324;
            *(_DWORD *)(a3 + 52) += 2;
          }
          unsigned int v326 = *(_DWORD *)(a3 + 80);
          if (v326 > 8) {
            sub_100077114();
          }
          int v327 = 1 << v326;
          if ((v327 & 0x9A) != 0)
          {
            uint64_t v328 = *(void *)(a3 + 144);
            if (v328)
            {
              *(void *)(a3 + 144) = v328 - 1;
              uint64_t v329 = 2 * *(void *)(a3 + 88);
            }
            else
            {
              uint64_t v329 = *(void *)(a3 + 88);
            }
            *(void *)(a3 + 152) += 2 * v329;
            int32x2_t v332 = *(int32x2_t *)(a3 + 132);
            v319.n128_u32[0] = vadd_s32(v332, (int32x2_t)0x200000002).u32[0];
            int8x8_t v318 = veor_s8((int8x8_t)v332, (int8x8_t)0x100000001);
            v319.n128_u32[1] = v318.u32[1];
            *(void *)(a3 + 132) = v319.n128_u64[0];
          }
          else
          {
            if ((v327 & 0x60) == 0) {
              sub_100077140();
            }
            uint64_t v330 = *(void *)(a3 + 144);
            if (v330)
            {
              *(void *)(a3 + 144) = v330 - 1;
              uint64_t v331 = 2 * *(void *)(a3 + 88);
            }
            else
            {
              uint64_t v331 = *(void *)(a3 + 88);
            }
            *(void *)(a3 + 152) += 2 * v331;
            *(_DWORD *)(a3 + 132) += 2;
          }
          uint64_t result = sub_100043618((uint64_t)v10, v16, 1, v785, v769, v11, &v809, *(double *)&v318, v319);
          if (*(_DWORD *)a3 > 8u) {
            sub_1000770BC();
          }
          int v333 = 1 << *(_DWORD *)a3;
          if ((v333 & 0xFA) != 0)
          {
            uint64_t v334 = *(void *)(a3 + 32);
            if (v334)
            {
              *(void *)(a3 + 32) = v334 - 1;
              uint64_t v335 = *(void *)(a3 + 8);
            }
            else
            {
              uint64_t v335 = 2 * *(void *)(a3 + 8);
            }
            *(void *)(a3 + 40) += 2 * v335;
            int v337 = *(_DWORD *)(a3 + 20) + 2;
          }
          else
          {
            if ((v333 & 0x101) != 0)
            {
              *(void *)(a3 + 40) += 2 * *(void *)(a3 + 8);
              int32x2_t v336 = *(int32x2_t *)(a3 + 20);
              a5.i32[0] = vadd_s32(v336, (int32x2_t)0x100000001).u32[0];
              *(int8x8_t *)a4.i8 = veor_s8((int8x8_t)v336, (int8x8_t)0x100000001);
              a5.i32[1] = a4.i32[1];
              *(void *)(a3 + 20) = a5.i64[0];
              goto LABEL_351;
            }
            *(void *)(a3 + 40) += 2 * *(void *)(a3 + 8);
            int v337 = *(_DWORD *)(a3 + 20) + 1;
          }
          *(_DWORD *)(a3 + 20) = v337;
LABEL_351:
          unsigned int v338 = *(_DWORD *)(a3 + 80);
          if (v338 > 8) {
            sub_1000770BC();
          }
          int v339 = 1 << v338;
          if ((v339 & 0xFA) != 0)
          {
            uint64_t v340 = *(void *)(a3 + 112);
            if (v340)
            {
              *(void *)(a3 + 112) = v340 - 1;
              uint64_t v341 = *(void *)(a3 + 88);
            }
            else
            {
              uint64_t v341 = 2 * *(void *)(a3 + 88);
            }
            *(void *)(a3 + 120) += 2 * v341;
            int v343 = *(_DWORD *)(a3 + 100) + 2;
            goto LABEL_359;
          }
          if ((v339 & 0x101) == 0)
          {
            *(void *)(a3 + 120) += 2 * *(void *)(a3 + 88);
            int v343 = *(_DWORD *)(a3 + 100) + 1;
LABEL_359:
            *(_DWORD *)(a3 + 100) = v343;
            goto LABEL_360;
          }
          *(void *)(a3 + 120) += 2 * *(void *)(a3 + 88);
          int32x2_t v342 = *(int32x2_t *)(a3 + 100);
          a5.i32[0] = vadd_s32(v342, (int32x2_t)0x100000001).u32[0];
          *(int8x8_t *)a4.i8 = veor_s8((int8x8_t)v342, (int8x8_t)0x100000001);
          a5.i32[1] = a4.i32[1];
          *(void *)(a3 + 100) = a5.i64[0];
LABEL_360:
          unsigned int v344 = v807;
          if (v316 != 2) {
            unsigned int v344 = 0;
          }
          v11 += 404 * v344;
          if (v316 == 2) {
            int v316 = v18;
          }
          else {
            v316 -= 2;
          }
          v317 += 2;
          if (!v317) {
            return result;
          }
        }
      case 4u:
        if (!v17) {
          return result;
        }
        v786 = (int *)(a3 + 128);
        v802 = (int *)(a3 + 48);
        v770 = (int *)(a3 + 16);
        int v345 = 2 * v15;
        int v346 = -2 * v14;
        while (1)
        {
          sub_100043618((uint64_t)v10, v16, 0, v802, v786, v11, &v809, *(double *)a4.i64, (__n128)a5);
          if (*(_DWORD *)a3 > 8u) {
            sub_100077114();
          }
          int v349 = 1 << *(_DWORD *)a3;
          if ((v349 & 0x9A) != 0)
          {
            uint64_t v350 = *(void *)(a3 + 64);
            if (v350)
            {
              *(void *)(a3 + 64) = v350 - 1;
              uint64_t v351 = 2 * *(void *)(a3 + 8);
            }
            else
            {
              uint64_t v351 = *(void *)(a3 + 8);
            }
            *(void *)(a3 + 72) += 2 * v351;
            int32x2_t v354 = *(int32x2_t *)(a3 + 52);
            v348.n128_u32[0] = vadd_s32(v354, (int32x2_t)0x200000002).u32[0];
            int8x8_t v347 = veor_s8((int8x8_t)v354, (int8x8_t)0x100000001);
            v348.n128_u32[1] = v347.u32[1];
            *(void *)(a3 + 52) = v348.n128_u64[0];
          }
          else
          {
            if ((v349 & 0x60) == 0) {
              sub_100077140();
            }
            uint64_t v352 = *(void *)(a3 + 64);
            if (v352)
            {
              *(void *)(a3 + 64) = v352 - 1;
              uint64_t v353 = 2 * *(void *)(a3 + 8);
            }
            else
            {
              uint64_t v353 = *(void *)(a3 + 8);
            }
            *(void *)(a3 + 72) += 2 * v353;
            *(_DWORD *)(a3 + 52) += 2;
          }
          unsigned int v355 = *(_DWORD *)(a3 + 80);
          if (v355 > 8) {
            sub_100077114();
          }
          int v356 = 1 << v355;
          if ((v356 & 0x9A) != 0)
          {
            uint64_t v357 = *(void *)(a3 + 144);
            if (v357)
            {
              *(void *)(a3 + 144) = v357 - 1;
              uint64_t v358 = 2 * *(void *)(a3 + 88);
            }
            else
            {
              uint64_t v358 = *(void *)(a3 + 88);
            }
            *(void *)(a3 + 152) += 2 * v358;
            int32x2_t v361 = *(int32x2_t *)(a3 + 132);
            v348.n128_u32[0] = vadd_s32(v361, (int32x2_t)0x200000002).u32[0];
            int8x8_t v347 = veor_s8((int8x8_t)v361, (int8x8_t)0x100000001);
            v348.n128_u32[1] = v347.u32[1];
            *(void *)(a3 + 132) = v348.n128_u64[0];
          }
          else
          {
            if ((v356 & 0x60) == 0) {
              sub_100077140();
            }
            uint64_t v359 = *(void *)(a3 + 144);
            if (v359)
            {
              *(void *)(a3 + 144) = v359 - 1;
              uint64_t v360 = 2 * *(void *)(a3 + 88);
            }
            else
            {
              uint64_t v360 = *(void *)(a3 + 88);
            }
            *(void *)(a3 + 152) += 2 * v360;
            *(_DWORD *)(a3 + 132) += 2;
          }
          uint64_t result = sub_100043618((uint64_t)v10, v16, 1, v770, (int *)(a3 + 96), v11, &v809, *(double *)&v347, v348);
          if (*(_DWORD *)a3 > 8u) {
            sub_1000770BC();
          }
          int v362 = 1 << *(_DWORD *)a3;
          if ((v362 & 0xFA) != 0)
          {
            uint64_t v363 = *(void *)(a3 + 32);
            if (v363)
            {
              *(void *)(a3 + 32) = v363 - 1;
              uint64_t v364 = *(void *)(a3 + 8);
            }
            else
            {
              uint64_t v364 = 2 * *(void *)(a3 + 8);
            }
            *(void *)(a3 + 40) += 2 * v364;
            int v366 = *(_DWORD *)(a3 + 20) + 2;
          }
          else
          {
            if ((v362 & 0x101) != 0)
            {
              *(void *)(a3 + 40) += 2 * *(void *)(a3 + 8);
              int32x2_t v365 = *(int32x2_t *)(a3 + 20);
              a5.i32[0] = vadd_s32(v365, (int32x2_t)0x100000001).u32[0];
              *(int8x8_t *)a4.i8 = veor_s8((int8x8_t)v365, (int8x8_t)0x100000001);
              a5.i32[1] = a4.i32[1];
              *(void *)(a3 + 20) = a5.i64[0];
              goto LABEL_402;
            }
            *(void *)(a3 + 40) += 2 * *(void *)(a3 + 8);
            int v366 = *(_DWORD *)(a3 + 20) + 1;
          }
          *(_DWORD *)(a3 + 20) = v366;
LABEL_402:
          unsigned int v367 = *(_DWORD *)(a3 + 80);
          if (v367 > 8) {
            sub_1000770BC();
          }
          int v368 = 1 << v367;
          if ((v368 & 0xFA) != 0)
          {
            uint64_t v369 = *(void *)(a3 + 112);
            if (v369)
            {
              *(void *)(a3 + 112) = v369 - 1;
              uint64_t v370 = *(void *)(a3 + 88);
            }
            else
            {
              uint64_t v370 = 2 * *(void *)(a3 + 88);
            }
            *(void *)(a3 + 120) += 2 * v370;
            int v372 = *(_DWORD *)(a3 + 100) + 2;
            goto LABEL_410;
          }
          if ((v368 & 0x101) == 0)
          {
            *(void *)(a3 + 120) += 2 * *(void *)(a3 + 88);
            int v372 = *(_DWORD *)(a3 + 100) + 1;
LABEL_410:
            *(_DWORD *)(a3 + 100) = v372;
            goto LABEL_411;
          }
          *(void *)(a3 + 120) += 2 * *(void *)(a3 + 88);
          int32x2_t v371 = *(int32x2_t *)(a3 + 100);
          a5.i32[0] = vadd_s32(v371, (int32x2_t)0x100000001).u32[0];
          *(int8x8_t *)a4.i8 = veor_s8((int8x8_t)v371, (int8x8_t)0x100000001);
          a5.i32[1] = a4.i32[1];
          *(void *)(a3 + 100) = a5.i64[0];
LABEL_411:
          unsigned int v373 = v807;
          if (v345 != 2) {
            unsigned int v373 = 0;
          }
          v11 += 404 * v373;
          if (v345 == 2) {
            int v345 = v18;
          }
          else {
            v345 -= 2;
          }
          v346 += 2;
          if (!v346) {
            return result;
          }
        }
      case 5u:
        if (!v17) {
          return result;
        }
        uint64_t v787 = a3 + 128;
        uint64_t v803 = a3 + 48;
        uint64_t v771 = a3 + 16;
        int v374 = 2 * v15;
        int v375 = -2 * v14;
        while (1)
        {
          sub_100043848((uint64_t)v10, v16, v803, v787, v11, &v809, *(double *)a4.i64, *(double *)a5.i64, a6);
          if (*(_DWORD *)a3 > 8u) {
            sub_100077114();
          }
          int v379 = 1 << *(_DWORD *)a3;
          if ((v379 & 0x9A) != 0)
          {
            uint64_t v380 = *(void *)(a3 + 64);
            if (v380)
            {
              *(void *)(a3 + 64) = v380 - 1;
              uint64_t v381 = 2 * *(void *)(a3 + 8);
            }
            else
            {
              uint64_t v381 = *(void *)(a3 + 8);
            }
            *(void *)(a3 + 72) += 2 * v381;
            int32x2_t v384 = *(int32x2_t *)(a3 + 52);
            LODWORD(v377) = vadd_s32(v384, (int32x2_t)0x200000002).u32[0];
            int8x8_t v376 = veor_s8((int8x8_t)v384, (int8x8_t)0x100000001);
            HIDWORD(v377) = v376.i32[1];
            *(double *)(a3 + 52) = v377;
          }
          else
          {
            if ((v379 & 0x60) == 0) {
              sub_100077140();
            }
            uint64_t v382 = *(void *)(a3 + 64);
            if (v382)
            {
              *(void *)(a3 + 64) = v382 - 1;
              uint64_t v383 = 2 * *(void *)(a3 + 8);
            }
            else
            {
              uint64_t v383 = *(void *)(a3 + 8);
            }
            *(void *)(a3 + 72) += 2 * v383;
            *(_DWORD *)(a3 + 52) += 2;
          }
          unsigned int v385 = *(_DWORD *)(a3 + 80);
          if (v385 > 8) {
            sub_100077114();
          }
          int v386 = 1 << v385;
          if ((v386 & 0x9A) != 0)
          {
            uint64_t v387 = *(void *)(a3 + 144);
            if (v387)
            {
              *(void *)(a3 + 144) = v387 - 1;
              uint64_t v388 = 2 * *(void *)(a3 + 88);
            }
            else
            {
              uint64_t v388 = *(void *)(a3 + 88);
            }
            *(void *)(a3 + 152) += 2 * v388;
            int32x2_t v391 = *(int32x2_t *)(a3 + 132);
            LODWORD(v377) = vadd_s32(v391, (int32x2_t)0x200000002).u32[0];
            int8x8_t v376 = veor_s8((int8x8_t)v391, (int8x8_t)0x100000001);
            HIDWORD(v377) = v376.i32[1];
            *(double *)(a3 + 132) = v377;
          }
          else
          {
            if ((v386 & 0x60) == 0) {
              sub_100077140();
            }
            uint64_t v389 = *(void *)(a3 + 144);
            if (v389)
            {
              *(void *)(a3 + 144) = v389 - 1;
              uint64_t v390 = 2 * *(void *)(a3 + 88);
            }
            else
            {
              uint64_t v390 = *(void *)(a3 + 88);
            }
            *(void *)(a3 + 152) += 2 * v390;
            *(_DWORD *)(a3 + 132) += 2;
          }
          uint64_t result = sub_100043848((uint64_t)v10, v16, v771, a3 + 96, v11, &v809, *(double *)&v376, v377, v378);
          if (*(_DWORD *)a3 > 8u) {
            sub_1000770BC();
          }
          int v392 = 1 << *(_DWORD *)a3;
          if ((v392 & 0xFA) != 0)
          {
            uint64_t v393 = *(void *)(a3 + 32);
            if (v393)
            {
              *(void *)(a3 + 32) = v393 - 1;
              uint64_t v394 = *(void *)(a3 + 8);
            }
            else
            {
              uint64_t v394 = 2 * *(void *)(a3 + 8);
            }
            *(void *)(a3 + 40) += 2 * v394;
            int v396 = *(_DWORD *)(a3 + 20) + 2;
          }
          else
          {
            if ((v392 & 0x101) != 0)
            {
              *(void *)(a3 + 40) += 2 * *(void *)(a3 + 8);
              int32x2_t v395 = *(int32x2_t *)(a3 + 20);
              a5.i32[0] = vadd_s32(v395, (int32x2_t)0x100000001).u32[0];
              *(int8x8_t *)a4.i8 = veor_s8((int8x8_t)v395, (int8x8_t)0x100000001);
              a5.i32[1] = a4.i32[1];
              *(void *)(a3 + 20) = a5.i64[0];
              goto LABEL_453;
            }
            *(void *)(a3 + 40) += 2 * *(void *)(a3 + 8);
            int v396 = *(_DWORD *)(a3 + 20) + 1;
          }
          *(_DWORD *)(a3 + 20) = v396;
LABEL_453:
          unsigned int v397 = *(_DWORD *)(a3 + 80);
          if (v397 > 8) {
            sub_1000770BC();
          }
          int v398 = 1 << v397;
          if ((v398 & 0xFA) != 0)
          {
            uint64_t v399 = *(void *)(a3 + 112);
            if (v399)
            {
              *(void *)(a3 + 112) = v399 - 1;
              uint64_t v400 = *(void *)(a3 + 88);
            }
            else
            {
              uint64_t v400 = 2 * *(void *)(a3 + 88);
            }
            *(void *)(a3 + 120) += 2 * v400;
            int v402 = *(_DWORD *)(a3 + 100) + 2;
            goto LABEL_461;
          }
          if ((v398 & 0x101) == 0)
          {
            *(void *)(a3 + 120) += 2 * *(void *)(a3 + 88);
            int v402 = *(_DWORD *)(a3 + 100) + 1;
LABEL_461:
            *(_DWORD *)(a3 + 100) = v402;
            goto LABEL_462;
          }
          *(void *)(a3 + 120) += 2 * *(void *)(a3 + 88);
          int32x2_t v401 = *(int32x2_t *)(a3 + 100);
          a5.i32[0] = vadd_s32(v401, (int32x2_t)0x100000001).u32[0];
          *(int8x8_t *)a4.i8 = veor_s8((int8x8_t)v401, (int8x8_t)0x100000001);
          a5.i32[1] = a4.i32[1];
          *(void *)(a3 + 100) = a5.i64[0];
LABEL_462:
          unsigned int v403 = v807;
          if (v374 != 2) {
            unsigned int v403 = 0;
          }
          v11 += 404 * v403;
          if (v374 == 2) {
            int v374 = v18;
          }
          else {
            v374 -= 2;
          }
          v375 += 2;
          if (!v375) {
            return result;
          }
        }
      case 6u:
        if (!v17) {
          return result;
        }
        uint64_t v788 = a3 + 128;
        uint64_t v804 = a3 + 48;
        uint64_t v772 = a3 + 16;
        int v404 = 2 * v15;
        int v405 = -2 * v14;
        while (1)
        {
          sub_100043AB4((uint64_t)v10, v16, v804, v788, v11, &v809, *(double *)a4.i64, *(double *)a5.i64, a6);
          if (*(_DWORD *)a3 > 8u) {
            sub_100077114();
          }
          int v409 = 1 << *(_DWORD *)a3;
          if ((v409 & 0x9A) != 0)
          {
            uint64_t v410 = *(void *)(a3 + 64);
            if (v410)
            {
              *(void *)(a3 + 64) = v410 - 1;
              uint64_t v411 = 2 * *(void *)(a3 + 8);
            }
            else
            {
              uint64_t v411 = *(void *)(a3 + 8);
            }
            *(void *)(a3 + 72) += 2 * v411;
            int32x2_t v414 = *(int32x2_t *)(a3 + 52);
            LODWORD(v407) = vadd_s32(v414, (int32x2_t)0x200000002).u32[0];
            int8x8_t v406 = veor_s8((int8x8_t)v414, (int8x8_t)0x100000001);
            HIDWORD(v407) = v406.i32[1];
            *(double *)(a3 + 52) = v407;
          }
          else
          {
            if ((v409 & 0x60) == 0) {
              sub_100077140();
            }
            uint64_t v412 = *(void *)(a3 + 64);
            if (v412)
            {
              *(void *)(a3 + 64) = v412 - 1;
              uint64_t v413 = 2 * *(void *)(a3 + 8);
            }
            else
            {
              uint64_t v413 = *(void *)(a3 + 8);
            }
            *(void *)(a3 + 72) += 2 * v413;
            *(_DWORD *)(a3 + 52) += 2;
          }
          unsigned int v415 = *(_DWORD *)(a3 + 80);
          if (v415 > 8) {
            sub_100077114();
          }
          int v416 = 1 << v415;
          if ((v416 & 0x9A) != 0)
          {
            uint64_t v417 = *(void *)(a3 + 144);
            if (v417)
            {
              *(void *)(a3 + 144) = v417 - 1;
              uint64_t v418 = 2 * *(void *)(a3 + 88);
            }
            else
            {
              uint64_t v418 = *(void *)(a3 + 88);
            }
            *(void *)(a3 + 152) += 2 * v418;
            int32x2_t v421 = *(int32x2_t *)(a3 + 132);
            LODWORD(v407) = vadd_s32(v421, (int32x2_t)0x200000002).u32[0];
            int8x8_t v406 = veor_s8((int8x8_t)v421, (int8x8_t)0x100000001);
            HIDWORD(v407) = v406.i32[1];
            *(double *)(a3 + 132) = v407;
          }
          else
          {
            if ((v416 & 0x60) == 0) {
              sub_100077140();
            }
            uint64_t v419 = *(void *)(a3 + 144);
            if (v419)
            {
              *(void *)(a3 + 144) = v419 - 1;
              uint64_t v420 = 2 * *(void *)(a3 + 88);
            }
            else
            {
              uint64_t v420 = *(void *)(a3 + 88);
            }
            *(void *)(a3 + 152) += 2 * v420;
            *(_DWORD *)(a3 + 132) += 2;
          }
          uint64_t result = sub_100043AB4((uint64_t)v10, v16, v772, a3 + 96, v11, &v809, *(double *)&v406, v407, v408);
          if (*(_DWORD *)a3 > 8u) {
            sub_1000770BC();
          }
          int v422 = 1 << *(_DWORD *)a3;
          if ((v422 & 0xFA) != 0)
          {
            uint64_t v423 = *(void *)(a3 + 32);
            if (v423)
            {
              *(void *)(a3 + 32) = v423 - 1;
              uint64_t v424 = *(void *)(a3 + 8);
            }
            else
            {
              uint64_t v424 = 2 * *(void *)(a3 + 8);
            }
            *(void *)(a3 + 40) += 2 * v424;
            int v426 = *(_DWORD *)(a3 + 20) + 2;
          }
          else
          {
            if ((v422 & 0x101) != 0)
            {
              *(void *)(a3 + 40) += 2 * *(void *)(a3 + 8);
              int32x2_t v425 = *(int32x2_t *)(a3 + 20);
              a5.i32[0] = vadd_s32(v425, (int32x2_t)0x100000001).u32[0];
              *(int8x8_t *)a4.i8 = veor_s8((int8x8_t)v425, (int8x8_t)0x100000001);
              a5.i32[1] = a4.i32[1];
              *(void *)(a3 + 20) = a5.i64[0];
              goto LABEL_504;
            }
            *(void *)(a3 + 40) += 2 * *(void *)(a3 + 8);
            int v426 = *(_DWORD *)(a3 + 20) + 1;
          }
          *(_DWORD *)(a3 + 20) = v426;
LABEL_504:
          unsigned int v427 = *(_DWORD *)(a3 + 80);
          if (v427 > 8) {
            sub_1000770BC();
          }
          int v428 = 1 << v427;
          if ((v428 & 0xFA) != 0)
          {
            uint64_t v429 = *(void *)(a3 + 112);
            if (v429)
            {
              *(void *)(a3 + 112) = v429 - 1;
              uint64_t v430 = *(void *)(a3 + 88);
            }
            else
            {
              uint64_t v430 = 2 * *(void *)(a3 + 88);
            }
            *(void *)(a3 + 120) += 2 * v430;
            int v432 = *(_DWORD *)(a3 + 100) + 2;
            goto LABEL_512;
          }
          if ((v428 & 0x101) == 0)
          {
            *(void *)(a3 + 120) += 2 * *(void *)(a3 + 88);
            int v432 = *(_DWORD *)(a3 + 100) + 1;
LABEL_512:
            *(_DWORD *)(a3 + 100) = v432;
            goto LABEL_513;
          }
          *(void *)(a3 + 120) += 2 * *(void *)(a3 + 88);
          int32x2_t v431 = *(int32x2_t *)(a3 + 100);
          a5.i32[0] = vadd_s32(v431, (int32x2_t)0x100000001).u32[0];
          *(int8x8_t *)a4.i8 = veor_s8((int8x8_t)v431, (int8x8_t)0x100000001);
          a5.i32[1] = a4.i32[1];
          *(void *)(a3 + 100) = a5.i64[0];
LABEL_513:
          unsigned int v433 = v807;
          if (v404 != 2) {
            unsigned int v433 = 0;
          }
          v11 += 404 * v433;
          if (v404 == 2) {
            int v404 = v18;
          }
          else {
            v404 -= 2;
          }
          v405 += 2;
          if (!v405) {
            return result;
          }
        }
      case 7u:
        if (!v17) {
          return result;
        }
        v789 = (int *)(a3 + 128);
        v805 = (int *)(a3 + 48);
        v773 = (int *)(a3 + 16);
        int v434 = 2 * v15;
        int v435 = -2 * v14;
        while (1)
        {
          sub_100043618((uint64_t)v10, v16, 0, v805, v789, v11, &v809, *(double *)a4.i64, (__n128)a5);
          if (*(_DWORD *)a3 > 8u) {
            sub_100077114();
          }
          int v438 = 1 << *(_DWORD *)a3;
          if ((v438 & 0x9A) != 0)
          {
            uint64_t v439 = *(void *)(a3 + 64);
            if (v439)
            {
              *(void *)(a3 + 64) = v439 - 1;
              uint64_t v440 = 2 * *(void *)(a3 + 8);
            }
            else
            {
              uint64_t v440 = *(void *)(a3 + 8);
            }
            *(void *)(a3 + 72) += 2 * v440;
            int32x2_t v443 = *(int32x2_t *)(a3 + 52);
            v437.n128_u32[0] = vadd_s32(v443, (int32x2_t)0x200000002).u32[0];
            int8x8_t v436 = veor_s8((int8x8_t)v443, (int8x8_t)0x100000001);
            v437.n128_u32[1] = v436.u32[1];
            *(void *)(a3 + 52) = v437.n128_u64[0];
          }
          else
          {
            if ((v438 & 0x60) == 0) {
              sub_100077140();
            }
            uint64_t v441 = *(void *)(a3 + 64);
            if (v441)
            {
              *(void *)(a3 + 64) = v441 - 1;
              uint64_t v442 = 2 * *(void *)(a3 + 8);
            }
            else
            {
              uint64_t v442 = *(void *)(a3 + 8);
            }
            *(void *)(a3 + 72) += 2 * v442;
            *(_DWORD *)(a3 + 52) += 2;
          }
          unsigned int v444 = *(_DWORD *)(a3 + 80);
          if (v444 > 8) {
            sub_100077114();
          }
          int v445 = 1 << v444;
          if ((v445 & 0x9A) != 0)
          {
            uint64_t v446 = *(void *)(a3 + 144);
            if (v446)
            {
              *(void *)(a3 + 144) = v446 - 1;
              uint64_t v447 = 2 * *(void *)(a3 + 88);
            }
            else
            {
              uint64_t v447 = *(void *)(a3 + 88);
            }
            *(void *)(a3 + 152) += 2 * v447;
            int32x2_t v450 = *(int32x2_t *)(a3 + 132);
            v437.n128_u32[0] = vadd_s32(v450, (int32x2_t)0x200000002).u32[0];
            int8x8_t v436 = veor_s8((int8x8_t)v450, (int8x8_t)0x100000001);
            v437.n128_u32[1] = v436.u32[1];
            *(void *)(a3 + 132) = v437.n128_u64[0];
          }
          else
          {
            if ((v445 & 0x60) == 0) {
              sub_100077140();
            }
            uint64_t v448 = *(void *)(a3 + 144);
            if (v448)
            {
              *(void *)(a3 + 144) = v448 - 1;
              uint64_t v449 = 2 * *(void *)(a3 + 88);
            }
            else
            {
              uint64_t v449 = *(void *)(a3 + 88);
            }
            *(void *)(a3 + 152) += 2 * v449;
            *(_DWORD *)(a3 + 132) += 2;
          }
          uint64_t result = sub_100043618((uint64_t)v10, v16, 1, v773, (int *)(a3 + 96), v11, &v809, *(double *)&v436, v437);
          if (*(_DWORD *)a3 > 8u) {
            sub_1000770BC();
          }
          int v451 = 1 << *(_DWORD *)a3;
          if ((v451 & 0xFA) != 0)
          {
            uint64_t v452 = *(void *)(a3 + 32);
            if (v452)
            {
              *(void *)(a3 + 32) = v452 - 1;
              uint64_t v453 = *(void *)(a3 + 8);
            }
            else
            {
              uint64_t v453 = 2 * *(void *)(a3 + 8);
            }
            *(void *)(a3 + 40) += 2 * v453;
            int v455 = *(_DWORD *)(a3 + 20) + 2;
          }
          else
          {
            if ((v451 & 0x101) != 0)
            {
              *(void *)(a3 + 40) += 2 * *(void *)(a3 + 8);
              int32x2_t v454 = *(int32x2_t *)(a3 + 20);
              a5.i32[0] = vadd_s32(v454, (int32x2_t)0x100000001).u32[0];
              *(int8x8_t *)a4.i8 = veor_s8((int8x8_t)v454, (int8x8_t)0x100000001);
              a5.i32[1] = a4.i32[1];
              *(void *)(a3 + 20) = a5.i64[0];
              goto LABEL_555;
            }
            *(void *)(a3 + 40) += 2 * *(void *)(a3 + 8);
            int v455 = *(_DWORD *)(a3 + 20) + 1;
          }
          *(_DWORD *)(a3 + 20) = v455;
LABEL_555:
          unsigned int v456 = *(_DWORD *)(a3 + 80);
          if (v456 > 8) {
            sub_1000770BC();
          }
          int v457 = 1 << v456;
          if ((v457 & 0xFA) != 0)
          {
            uint64_t v458 = *(void *)(a3 + 112);
            if (v458)
            {
              *(void *)(a3 + 112) = v458 - 1;
              uint64_t v459 = *(void *)(a3 + 88);
            }
            else
            {
              uint64_t v459 = 2 * *(void *)(a3 + 88);
            }
            *(void *)(a3 + 120) += 2 * v459;
            int v461 = *(_DWORD *)(a3 + 100) + 2;
            goto LABEL_563;
          }
          if ((v457 & 0x101) == 0)
          {
            *(void *)(a3 + 120) += 2 * *(void *)(a3 + 88);
            int v461 = *(_DWORD *)(a3 + 100) + 1;
LABEL_563:
            *(_DWORD *)(a3 + 100) = v461;
            goto LABEL_564;
          }
          *(void *)(a3 + 120) += 2 * *(void *)(a3 + 88);
          int32x2_t v460 = *(int32x2_t *)(a3 + 100);
          a5.i32[0] = vadd_s32(v460, (int32x2_t)0x100000001).u32[0];
          *(int8x8_t *)a4.i8 = veor_s8((int8x8_t)v460, (int8x8_t)0x100000001);
          a5.i32[1] = a4.i32[1];
          *(void *)(a3 + 100) = a5.i64[0];
LABEL_564:
          unsigned int v462 = v807;
          if (v434 != 2) {
            unsigned int v462 = 0;
          }
          v11 += 404 * v462;
          if (v434 == 2) {
            int v434 = v18;
          }
          else {
            v434 -= 2;
          }
          v435 += 2;
          if (!v435) {
            return result;
          }
        }
      case 8u:
        if (!v17) {
          return result;
        }
        int v463 = *(_DWORD *)(a2 + 24);
        int v464 = *(_DWORD *)(a3 + 16);
        int v806 = *(_DWORD *)(a2 + 16);
        int8x8_t v465 = (int8x8_t)vdup_n_s32(0x7FF8u);
        int v466 = v18;
        break;
      default:
        sub_100077090();
    }
    while (1)
    {
      int v467 = v464;
      if (v806 >= 1)
      {
        int v468 = 0;
        uint64_t v469 = v11 - 404;
        int v470 = *(_DWORD *)(a3 + 24);
        v471 = *(unsigned __int16 **)(a3 + 40);
        int v472 = v806 + 1;
        int v467 = v464;
        char v473 = *(unsigned char *)(a2 + 308);
        do
        {
          if (v467) {
            int v474 = v467;
          }
          else {
            int v474 = *(_DWORD *)(a3 + 96);
          }
          if (!v467)
          {
            int v470 = *(_DWORD *)(a3 + 104);
            v471 = *(unsigned __int16 **)(a3 + 120);
          }
          BOOL v475 = v468 == 0;
          if (!v468) {
            int v468 = v463;
          }
          uint64_t v476 = v469 + 404 * v475;
          unsigned int v477 = *v471;
          int v478 = (__int16)v477 >> 3;
          int v479 = v471[3];
          if (v470) {
            int v480 = -v478;
          }
          else {
            LOWORD(v480) = (__int16)v477 >> 3;
          }
          unsigned __int16 v481 = v480 + v479;
          ++*(_DWORD *)(v476 + 384);
          *(void *)(v476 + 388) += (unsigned __int16)(v480 + v479);
          *(void *)(v476 + 396) += (unsigned __int16)(v480 + v479) * (unint64_t)(unsigned __int16)(v480 + v479);
          if ((v477 & 4) == 0)
          {
            int v482 = (__int16)v471[1];
            unsigned int v483 = v482 & 7;
            if ((v477 & 1) != 0 || (((v482 & 7u) < 6) & (v477 >> 1)) != 0)
            {
              v496 = (_DWORD *)(v469 + 404 * v475 + 12 * v470);
              ++v496[84];
              v496[85] += v481;
              v496[86] += v479;
            }
            else
            {
              __int16 v484 = v483 > 5;
              unsigned int v485 = v471[2];
              uint64_t v486 = (v485 & 0xF) + 1;
              unsigned int v487 = v485 >> 4;
              int v488 = v482 >> 3;
              if (v482 < 0) {
                int v488 = -v488;
              }
              if (v478 < 0) {
                int v478 = -v478;
              }
              unsigned __int16 v489 = v483 - v484;
              unsigned int v490 = (16 * (v488 & 0xFFFu)) >> v484;
              unsigned int v491 = (v486 >> 1) * v487;
              if (((v482 ^ v477) & 0x8000u) == 0) {
                unsigned __int16 v492 = v489 + 7;
              }
              else {
                unsigned __int16 v492 = v489;
              }
              uint64_t v493 = v476 + 24 * v492;
              a6.n128_u32[0] = v490;
              v494.i32[0] = vshr_n_u32((uint32x2_t)a6.n128_u64[0], 1uLL).u32[0];
              a6.n128_u32[1] = 8 * v478;
              v494.i32[1] = vand_s8(*(int8x8_t *)&a6, v465).i32[1];
              signed int v495 = (v494.i32[0] * v491) >> 15 << v473;
              if (v495 <= -32768) {
                signed int v495 = -32768;
              }
              if (v495 >= 0x7FFF) {
                signed int v495 = 0x7FFF;
              }
              *(void *)v493 += v486;
              a6 = (__n128)vaddw_u32(*(uint64x2_t *)(v493 + 8), (uint32x2_t)vshr_n_s32(vmul_s32(vdup_n_s32(v495), v494), 0xFuLL));
              *(__n128 *)(v493 + 8) = a6;
            }
          }
          v471 += 4;
          int v467 = v474 - 1;
          --v468;
          ++v809.i32[0];
          --v472;
          uint64_t v469 = v476;
        }
        while (v472 > 1);
      }
      if (v467) {
        sub_1000770E8();
      }
      if (*(_DWORD *)a3 > 8u) {
        sub_1000770BC();
      }
      int v497 = 1 << *(_DWORD *)a3;
      if ((v497 & 0xFA) != 0)
      {
        uint64_t v498 = *(void *)(a3 + 32);
        int v499 = v19;
        if (v498)
        {
          *(void *)(a3 + 32) = v498 - 1;
          uint64_t v500 = *(void *)(a3 + 8);
        }
        else
        {
          uint64_t v500 = 2 * *(void *)(a3 + 8);
        }
        *(void *)(a3 + 40) += 2 * v500;
        int v503 = *(_DWORD *)(a3 + 20) + 2;
      }
      else
      {
        int v499 = v19;
        if ((v497 & 0x101) != 0)
        {
          *(void *)(a3 + 40) += 2 * *(void *)(a3 + 8);
          int32x2_t v501 = *(int32x2_t *)(a3 + 20);
          LODWORD(v502) = vadd_s32(v501, (int32x2_t)0x100000001).u32[0];
          a6.n128_u64[0] = (unint64_t)veor_s8((int8x8_t)v501, (int8x8_t)0x100000001);
          HIDWORD(v502) = a6.n128_u32[1];
          *(void *)(a3 + 20) = v502;
          goto LABEL_614;
        }
        *(void *)(a3 + 40) += 2 * *(void *)(a3 + 8);
        int v503 = *(_DWORD *)(a3 + 20) + 1;
      }
      *(_DWORD *)(a3 + 20) = v503;
LABEL_614:
      unsigned int v504 = *(_DWORD *)(a3 + 80);
      if (v504 > 8) {
        sub_1000770BC();
      }
      int v505 = 1 << v504;
      if ((v505 & 0xFA) != 0)
      {
        uint64_t v506 = *(void *)(a3 + 112);
        if (v506)
        {
          *(void *)(a3 + 112) = v506 - 1;
          uint64_t v507 = *(void *)(a3 + 88);
        }
        else
        {
          uint64_t v507 = 2 * *(void *)(a3 + 88);
        }
        *(void *)(a3 + 120) += 2 * v507;
        int v510 = *(_DWORD *)(a3 + 100) + 2;
        goto LABEL_622;
      }
      if ((v505 & 0x101) == 0)
      {
        *(void *)(a3 + 120) += 2 * *(void *)(a3 + 88);
        int v510 = *(_DWORD *)(a3 + 100) + 1;
LABEL_622:
        *(_DWORD *)(a3 + 100) = v510;
        goto LABEL_623;
      }
      *(void *)(a3 + 120) += 2 * *(void *)(a3 + 88);
      int32x2_t v508 = *(int32x2_t *)(a3 + 100);
      LODWORD(v509) = vadd_s32(v508, (int32x2_t)0x100000001).u32[0];
      a6.n128_u64[0] = (unint64_t)veor_s8((int8x8_t)v508, (int8x8_t)0x100000001);
      HIDWORD(v509) = a6.n128_u32[1];
      *(void *)(a3 + 100) = v509;
LABEL_623:
      uint64_t result = v807;
      if (v466 != 1) {
        uint64_t result = 0;
      }
      v11 += 404 * result;
      if (v466 == 1) {
        int v466 = v499;
      }
      else {
        --v466;
      }
      if (!--v17) {
        return result;
      }
    }
  }
  if (v12 != 2) {
    sub_100077064();
  }
  int v17 = *(_DWORD *)(a2 + 20);
  uint64_t v18 = *(unsigned int *)(a2 + 28);
  v809.i32[0] = 0;
LABEL_135:
  if (v17)
  {
    uint64_t v141 = a3 + 16;
    int v142 = *(_DWORD *)(a3 + 16);
    int v143 = 2 * *(_DWORD *)(a2 + 24);
    int v799 = 2 * v142;
    if (!v142) {
      uint64_t v141 = a3 + 96;
    }
    uint64_t v767 = v141;
    int v782 = 2 * *(_DWORD *)(a2 + 16);
    int8x8_t v144 = (int8x8_t)vdup_n_s32(0x7FF8u);
    uint64_t result = 0x7FFFLL;
    int v145 = v18;
    do
    {
      uint64_t v146 = v18;
      int v147 = v799;
      if (v782 >= 1)
      {
        int v148 = 0;
        uint64_t v149 = v11 - 404;
        uint64_t v150 = *(int *)(v767 + 8);
        uint64_t v151 = *(void *)(a3 + 40) + 8;
        char v152 = *(unsigned char *)(a2 + 308);
        int v153 = v782 + 2;
        int v147 = v799;
        do
        {
          if (v147) {
            int v154 = v147;
          }
          else {
            int v154 = 2 * *(_DWORD *)(a3 + 96);
          }
          if (v147) {
            int v155 = (unsigned __int16 *)v151;
          }
          else {
            int v155 = (unsigned __int16 *)(*(void *)(a3 + 120) + 8);
          }
          BOOL v156 = v148 == 0;
          if (v148) {
            int v157 = v148;
          }
          else {
            int v157 = v143;
          }
          uint64_t v158 = v149 + 404 * (v148 == 0);
          int v159 = *(v155 - 1);
          unsigned int v160 = v155[3];
          unsigned int v161 = v159 + ((__int16)*(v155 - 4) >> 3);
          unsigned int v162 = *v155;
          ++*(_DWORD *)(v158 + 384);
          *(void *)(v158 + 388) += (unsigned __int16)v161;
          *(void *)(v158 + 396) += (unsigned __int16)v161 * (unint64_t)(unsigned __int16)v161;
          if ((v162 & 4) == 0)
          {
            int v163 = (__int16)v155[1];
            unsigned int v164 = v163 & 7;
            if ((v162 & 1) != 0 || (((v163 & 7u) < 6) & (v162 >> 1)) != 0)
            {
              uint64_t v179 = v149 + 404 * v156 + 336;
              int8x8_t v180 = (int8x8_t)__PAIR64__(v160, v161);
              float v181 = (int32x2_t *)(v179 + 12 * (int)v150);
              int32x2_t v182 = (int32x2_t)vand_s8(v180, (int8x8_t)0xFFFF0000FFFFLL);
              v183.i32[0] = 1;
              v183.i32[1] = v182.i32[0];
              *float v181 = vadd_s32(*v181, v183);
              v181[1].i32[0] += v159;
              uint64_t v184 = v179 + 12 * (v150 + 1);
              ++*(_DWORD *)v184;
              a7.n128_u64[0] = (unint64_t)vadd_s32(*(int32x2_t *)(v184 + 4), v182);
              *(void *)(v184 + 4) = a7.n128_u64[0];
            }
            else
            {
              __int16 v165 = v164 > 5;
              unsigned int v166 = v155[2];
              uint64_t v167 = (v166 & 0xF) + 1;
              unsigned int v168 = v166 >> 4;
              int v169 = (__int16)v162 >> 3;
              int v170 = v163 >> 3;
              if (v163 < 0) {
                int v170 = -v170;
              }
              if (v169 < 0) {
                int v169 = -v169;
              }
              unsigned __int16 v171 = v164 - v165;
              unsigned int v172 = (16 * (v170 & 0xFFFu)) >> v165;
              unsigned int v173 = (v167 >> 1) * v168;
              int v174 = 8 * v169;
              if (((v163 ^ v162) & 0x8000u) == 0) {
                unsigned __int16 v175 = v171 + 7;
              }
              else {
                unsigned __int16 v175 = v171;
              }
              uint64_t v176 = v158 + 24 * v175;
              a7.n128_u32[0] = v172;
              v177.i32[0] = vshr_n_u32((uint32x2_t)a7.n128_u64[0], 1uLL).u32[0];
              a7.n128_u32[1] = v174;
              v177.i32[1] = vand_s8(*(int8x8_t *)&a7, v144).i32[1];
              signed int v178 = (v177.i32[0] * v173) >> 15 << v152;
              if (v178 <= -32768) {
                signed int v178 = -32768;
              }
              if (v178 >= 0x7FFF) {
                signed int v178 = 0x7FFF;
              }
              *(void *)v176 += v167;
              a7 = (__n128)vaddw_u32(*(uint64x2_t *)(v176 + 8), (uint32x2_t)vshr_n_s32(vmul_s32(vdup_n_s32(v178), v177), 0xFuLL));
              *(__n128 *)(v176 + 8) = a7;
            }
          }
          uint64_t v151 = (uint64_t)(v155 + 8);
          int v147 = v154 - 2;
          int v148 = v157 - 2;
          ++v809.i32[0];
          v153 -= 2;
          uint64_t v149 = v158;
        }
        while (v153 > 2);
      }
      if (v147) {
        sub_10007716C();
      }
      if (*(_DWORD *)a3 > 8u) {
        sub_1000770BC();
      }
      int v185 = 1 << *(_DWORD *)a3;
      if ((v185 & 0xFA) != 0)
      {
        uint64_t v186 = *(void *)(a3 + 32);
        uint64_t v18 = v146;
        if (v186)
        {
          *(void *)(a3 + 32) = v186 - 1;
          uint64_t v187 = *(void *)(a3 + 8);
        }
        else
        {
          uint64_t v187 = 2 * *(void *)(a3 + 8);
        }
        *(void *)(a3 + 40) += 2 * v187;
        int v190 = *(_DWORD *)(a3 + 20) + 2;
      }
      else
      {
        uint64_t v18 = v146;
        if ((v185 & 0x101) != 0)
        {
          *(void *)(a3 + 40) += 2 * *(void *)(a3 + 8);
          int32x2_t v188 = *(int32x2_t *)(a3 + 20);
          LODWORD(v189) = vadd_s32(v188, (int32x2_t)0x100000001).u32[0];
          a7.n128_u64[0] = (unint64_t)veor_s8((int8x8_t)v188, (int8x8_t)0x100000001);
          HIDWORD(v189) = a7.n128_u32[1];
          *(void *)(a3 + 20) = v189;
          goto LABEL_177;
        }
        *(void *)(a3 + 40) += 2 * *(void *)(a3 + 8);
        int v190 = *(_DWORD *)(a3 + 20) + 1;
      }
      *(_DWORD *)(a3 + 20) = v190;
LABEL_177:
      unsigned int v191 = *(_DWORD *)(a3 + 80);
      if (v191 > 8) {
        sub_1000770BC();
      }
      int v192 = 1 << v191;
      if ((v192 & 0xFA) != 0)
      {
        uint64_t v193 = *(void *)(a3 + 112);
        if (v193)
        {
          *(void *)(a3 + 112) = v193 - 1;
          uint64_t v194 = *(void *)(a3 + 88);
        }
        else
        {
          uint64_t v194 = 2 * *(void *)(a3 + 88);
        }
        *(void *)(a3 + 120) += 2 * v194;
        int v197 = *(_DWORD *)(a3 + 100) + 2;
        goto LABEL_185;
      }
      if ((v192 & 0x101) == 0)
      {
        *(void *)(a3 + 120) += 2 * *(void *)(a3 + 88);
        int v197 = *(_DWORD *)(a3 + 100) + 1;
LABEL_185:
        *(_DWORD *)(a3 + 100) = v197;
        goto LABEL_186;
      }
      *(void *)(a3 + 120) += 2 * *(void *)(a3 + 88);
      int32x2_t v195 = *(int32x2_t *)(a3 + 100);
      LODWORD(v196) = vadd_s32(v195, (int32x2_t)0x100000001).u32[0];
      a7.n128_u64[0] = (unint64_t)veor_s8((int8x8_t)v195, (int8x8_t)0x100000001);
      HIDWORD(v196) = a7.n128_u32[1];
      *(void *)(a3 + 100) = v196;
LABEL_186:
      unsigned int v198 = v807;
      if (v145 != 1) {
        unsigned int v198 = 0;
      }
      v11 += 404 * v198;
      if (v145 == 1) {
        int v145 = v18;
      }
      else {
        --v145;
      }
      --v17;
    }
    while (v17);
  }
  return result;
}

uint64_t sub_100043534(int a1, int a2)
{
  uint64_t result = 0;
  switch(a1)
  {
    case 0:
    case 2:
    case 8:
      return result;
    case 1:
      if (!a2) {
        return 2;
      }
      if (a2 != 1) {
        sub_100077274();
      }
      return 1;
    case 3:
      if (!a2) {
        return 3;
      }
      if (a2 != 1) {
        sub_1000772A0();
      }
      return 1;
    case 4:
    case 7:
      if (!a2) {
        return 4;
      }
      if (a2 != 1) {
        sub_1000772CC();
      }
      return 2;
    case 5:
      if (!a2) {
        return 1;
      }
      if (a2 != 1) {
        sub_1000772F8();
      }
      return 0;
    case 6:
      if (!a2) {
        return 2;
      }
      if (a2 != 1) {
        sub_100077324();
      }
      return 1;
    default:
      sub_100077248();
  }
}

uint64_t sub_100043618(uint64_t result, uint64_t a2, int a3, int *a4, int *a5, uint64_t a6, _DWORD *a7, double a8, __n128 a9)
{
  int v9 = *a4;
  int v10 = *(_DWORD *)(result + 4);
  if (v10 >= 1)
  {
    int v11 = 0;
    int v12 = *(_DWORD *)(result + 12);
    uint64_t v13 = a6 - 404;
    int v14 = a4[2];
    int v15 = v10 + 1;
    uint64_t v16 = (unsigned __int16 *)*((void *)a4 + 3);
    char v17 = *(unsigned char *)(a2 + 4);
    int8x8_t v18 = (int8x8_t)vdup_n_s32(0x7FF8u);
    do
    {
      int v19 = *a5;
      if (v9) {
        int v19 = v9;
      }
      else {
        int v14 = a5[2];
      }
      if (!v9) {
        uint64_t v16 = (unsigned __int16 *)*((void *)a5 + 3);
      }
      BOOL v20 = v11 == 0;
      if (v11) {
        int v21 = v11;
      }
      else {
        int v21 = v12;
      }
      uint64_t v22 = v13 + 404 * (v11 == 0);
      unsigned int v23 = *v16;
      int v24 = (__int16)v23 >> 3;
      int v25 = v16[3];
      if (v14) {
        int v26 = -v24;
      }
      else {
        int v26 = (__int16)v23 >> 3;
      }
      unsigned __int16 v27 = v26 + v25;
      ++*(_DWORD *)(v22 + 384);
      *(void *)(v22 + 388) += v27;
      *(void *)(v22 + 396) += v27 * (unint64_t)v27;
      if ((v23 & 4) == 0)
      {
        int v28 = (__int16)v16[1];
        unsigned int v29 = v28 & 7;
        if ((v23 & 1) != 0 || (((v28 & 7u) < 6) & (v23 >> 1)) != 0)
        {
          unsigned int v43 = (_DWORD *)(v13 + 404 * v20 + 12 * v14);
          ++v43[84];
          v43[85] += v27;
          v43[86] += v25;
        }
        else
        {
          __int16 v30 = v29 > 5;
          unsigned int v31 = v16[2];
          uint64_t v32 = (v31 & 0xF) + 1;
          unsigned int v33 = v31 >> 4;
          int v34 = v28 >> 3;
          if (v28 < 0) {
            int v34 = -v34;
          }
          if (v24 < 0) {
            int v24 = -v24;
          }
          unsigned __int16 v35 = v29 - v30;
          unsigned int v36 = (16 * (v34 & 0xFFFu)) >> v30;
          unsigned int v37 = (v32 >> 1) * v33;
          int v38 = 8 * v24;
          if (((v28 ^ v23) & 0x8000u) == 0) {
            unsigned __int16 v39 = v35 + 7;
          }
          else {
            unsigned __int16 v39 = v35;
          }
          uint64_t v40 = v22 + 24 * v39;
          a9.n128_u32[0] = v36;
          v41.i32[0] = vshr_n_u32((uint32x2_t)a9.n128_u64[0], 1uLL).u32[0];
          a9.n128_u32[1] = v38;
          v41.i32[1] = vand_s8(*(int8x8_t *)&a9, v18).i32[1];
          signed int v42 = (v41.i32[0] * v37) >> 15 << v17;
          if (v42 <= -32768) {
            signed int v42 = -32768;
          }
          if (v42 >= 0x7FFF) {
            signed int v42 = 0x7FFF;
          }
          *(void *)v40 += v32;
          a9 = (__n128)vaddw_u32(*(uint64x2_t *)(v40 + 8), (uint32x2_t)vshr_n_s32(vmul_s32(vdup_n_s32(v42), v41), 0xFuLL));
          *(__n128 *)(v40 + 8) = a9;
        }
      }
      v16 += 4;
      int v9 = v19 - 1;
      int v11 = v21 - 1;
      uint64_t result = (*a7 + 1);
      *a7 = result;
      v14 ^= a3;
      --v15;
      uint64_t v13 = v22;
    }
    while (v15 > 1);
  }
  if (v9) {
    sub_1000770E8();
  }
  return result;
}

uint64_t sub_100043848(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, _DWORD *a6, double a7, double a8, __n128 a9)
{
  int v9 = 2 * *(_DWORD *)a3;
  int v10 = 2 * *(_DWORD *)(result + 4);
  if (v10 >= 1)
  {
    int v11 = 0;
    int v12 = 2 * *(_DWORD *)(result + 12);
    uint64_t v13 = a5 - 404;
    if (*(_DWORD *)a3) {
      uint64_t v14 = a3;
    }
    else {
      uint64_t v14 = a4;
    }
    uint64_t v15 = *(int *)(v14 + 8);
    uint64_t v16 = *(unsigned __int16 **)(a3 + 24);
    char v17 = *(unsigned char *)(a2 + 4);
    int v18 = v10 + 2;
    int8x8_t v19 = (int8x8_t)vdup_n_s32(0x7FF8u);
    do
    {
      int v20 = 2 * *(_DWORD *)a4;
      if (v9) {
        int v20 = v9;
      }
      else {
        uint64_t v16 = *(unsigned __int16 **)(a4 + 24);
      }
      BOOL v21 = v11 == 0;
      if (v11) {
        int v22 = v11;
      }
      else {
        int v22 = v12;
      }
      uint64_t result = v13 + 404 * (v11 == 0);
      unsigned int v23 = v16[3];
      int v24 = v16[7];
      unsigned int v25 = v24 - ((__int16)v16[4] >> 3);
      unsigned int v26 = *v16;
      ++*(_DWORD *)(result + 384);
      *(void *)(result + 388) += (unsigned __int16)v25;
      *(void *)(result + 396) += (unsigned __int16)v25 * (unint64_t)(unsigned __int16)v25;
      if ((v26 & 4) == 0)
      {
        int v27 = (__int16)v16[1];
        unsigned int v28 = v27 & 7;
        if ((v26 & 1) != 0 || (((v27 & 7u) < 6) & (v26 >> 1)) != 0)
        {
          uint64_t v43 = v13 + 404 * v21 + 336;
          uint64_t v44 = v43 + 12 * (int)v15;
          ++*(_DWORD *)v44;
          a9.n128_u64[0] = (unint64_t)vand_s8((int8x8_t)__PAIR64__(v23, v25), (int8x8_t)0xFFFF0000FFFFLL);
          *(int32x2_t *)(v44 + 4) = vadd_s32(*(int32x2_t *)(v44 + 4), (int32x2_t)a9.n128_u64[0]);
          unsigned int v45 = (_DWORD *)(v43 + 12 * (v15 + 1));
          unsigned __int32 v46 = v45[1] + a9.n128_u32[0];
          ++*v45;
          v45[1] = v46;
          v45[2] += v24;
        }
        else
        {
          __int16 v29 = v28 > 5;
          unsigned int v30 = v16[2];
          uint64_t v31 = (v30 & 0xF) + 1;
          unsigned int v32 = v30 >> 4;
          int v33 = (__int16)v26 >> 3;
          int v34 = v27 >> 3;
          if (v27 < 0) {
            int v34 = -v34;
          }
          if (v33 < 0) {
            int v33 = -v33;
          }
          unsigned __int16 v35 = v28 - v29;
          unsigned int v36 = (16 * (v34 & 0xFFFu)) >> v29;
          unsigned int v37 = (v31 >> 1) * v32;
          int v38 = 8 * v33;
          if (((v27 ^ v26) & 0x8000u) == 0) {
            unsigned __int16 v39 = v35 + 7;
          }
          else {
            unsigned __int16 v39 = v35;
          }
          uint64_t v40 = result + 24 * v39;
          a9.n128_u32[0] = v36;
          v41.i32[0] = vshr_n_u32((uint32x2_t)a9.n128_u64[0], 1uLL).u32[0];
          a9.n128_u32[1] = v38;
          v41.i32[1] = vand_s8(*(int8x8_t *)&a9, v19).i32[1];
          signed int v42 = (v41.i32[0] * v37) >> 15 << v17;
          if (v42 <= -32768) {
            signed int v42 = -32768;
          }
          if (v42 >= 0x7FFF) {
            signed int v42 = 0x7FFF;
          }
          *(void *)v40 += v31;
          a9 = (__n128)vaddw_u32(*(uint64x2_t *)(v40 + 8), (uint32x2_t)vshr_n_s32(vmul_s32(vdup_n_s32(v42), v41), 0xFuLL));
          *(__n128 *)(v40 + 8) = a9;
        }
      }
      v16 += 8;
      int v9 = v20 - 2;
      int v11 = v22 - 2;
      ++*a6;
      v18 -= 2;
      uint64_t v13 = result;
    }
    while (v18 > 2);
  }
  if (v9) {
    sub_10007716C();
  }
  return result;
}

uint64_t sub_100043AB4(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, _DWORD *a6, double a7, double a8, __n128 a9)
{
  int v9 = 2 * *(_DWORD *)a3;
  int v10 = 2 * *(_DWORD *)(result + 4);
  if (v10 >= 1)
  {
    int v11 = 0;
    int v12 = 2 * *(_DWORD *)(result + 12);
    uint64_t v13 = a5 - 404;
    if (*(_DWORD *)a3) {
      uint64_t v14 = a3;
    }
    else {
      uint64_t v14 = a4;
    }
    uint64_t v15 = *(int *)(v14 + 8);
    uint64_t v16 = (unsigned __int16 *)(*(void *)(a3 + 24) + 8);
    char v17 = *(unsigned char *)(a2 + 4);
    int v18 = v10 + 2;
    int8x8_t v19 = (int8x8_t)vdup_n_s32(0x7FF8u);
    do
    {
      int v20 = 2 * *(_DWORD *)a4;
      if (v9) {
        int v20 = v9;
      }
      else {
        uint64_t v16 = (unsigned __int16 *)(*(void *)(a4 + 24) + 8);
      }
      BOOL v21 = v11 == 0;
      if (v11) {
        int v22 = v11;
      }
      else {
        int v22 = v12;
      }
      uint64_t result = v13 + 404 * (v11 == 0);
      int v23 = *(v16 - 1);
      unsigned int v24 = v16[3];
      unsigned int v25 = v23 + ((__int16)*(v16 - 4) >> 3);
      unsigned int v26 = *v16;
      ++*(_DWORD *)(result + 384);
      *(void *)(result + 388) += (unsigned __int16)v25;
      *(void *)(result + 396) += (unsigned __int16)v25 * (unint64_t)(unsigned __int16)v25;
      if ((v26 & 4) == 0)
      {
        int v27 = (__int16)v16[1];
        unsigned int v28 = v27 & 7;
        if ((v26 & 1) != 0 || (((v27 & 7u) < 6) & (v26 >> 1)) != 0)
        {
          uint64_t v43 = v13 + 404 * v21 + 336;
          uint64_t v44 = (int32x2_t *)(v43 + 12 * (int)v15);
          int32x2_t v45 = (int32x2_t)vand_s8((int8x8_t)__PAIR64__(v24, v25), (int8x8_t)0xFFFF0000FFFFLL);
          v46.i32[0] = 1;
          v46.i32[1] = v45.i32[0];
          *uint64_t v44 = vadd_s32(*v44, v46);
          v44[1].i32[0] += v23;
          uint64_t v47 = v43 + 12 * (v15 + 1);
          ++*(_DWORD *)v47;
          a9.n128_u64[0] = (unint64_t)vadd_s32(*(int32x2_t *)(v47 + 4), v45);
          *(void *)(v47 + 4) = a9.n128_u64[0];
        }
        else
        {
          __int16 v29 = v28 > 5;
          unsigned int v30 = v16[2];
          uint64_t v31 = (v30 & 0xF) + 1;
          unsigned int v32 = v30 >> 4;
          int v33 = (__int16)v26 >> 3;
          int v34 = v27 >> 3;
          if (v27 < 0) {
            int v34 = -v34;
          }
          if (v33 < 0) {
            int v33 = -v33;
          }
          unsigned __int16 v35 = v28 - v29;
          unsigned int v36 = (16 * (v34 & 0xFFFu)) >> v29;
          unsigned int v37 = (v31 >> 1) * v32;
          int v38 = 8 * v33;
          if (((v27 ^ v26) & 0x8000u) == 0) {
            unsigned __int16 v39 = v35 + 7;
          }
          else {
            unsigned __int16 v39 = v35;
          }
          uint64_t v40 = result + 24 * v39;
          a9.n128_u32[0] = v36;
          v41.i32[0] = vshr_n_u32((uint32x2_t)a9.n128_u64[0], 1uLL).u32[0];
          a9.n128_u32[1] = v38;
          v41.i32[1] = vand_s8(*(int8x8_t *)&a9, v19).i32[1];
          signed int v42 = (v41.i32[0] * v37) >> 15 << v17;
          if (v42 <= -32768) {
            signed int v42 = -32768;
          }
          if (v42 >= 0x7FFF) {
            signed int v42 = 0x7FFF;
          }
          *(void *)v40 += v31;
          a9 = (__n128)vaddw_u32(*(uint64x2_t *)(v40 + 8), (uint32x2_t)vshr_n_s32(vmul_s32(vdup_n_s32(v42), v41), 0xFuLL));
          *(__n128 *)(v40 + 8) = a9;
        }
      }
      v16 += 8;
      int v9 = v20 - 2;
      int v11 = v22 - 2;
      ++*a6;
      v18 -= 2;
      uint64_t v13 = result;
    }
    while (v18 > 2);
  }
  if (v9) {
    sub_10007716C();
  }
  return result;
}

int16x8_t *sub_100043D28(int16x8_t *result, uint64_t a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, _DWORD *a7, int32x4_t a8, int32x4_t a9)
{
  int v9 = *(_DWORD *)a4;
  if (*(_DWORD *)a4) {
    uint64_t v10 = a4;
  }
  else {
    uint64_t v10 = a5;
  }
  int v11 = *(_DWORD *)(v10 + 8);
  int v12 = result->i32[1];
  if (a3)
  {
    a8.i32[0] = 0;
    a9.i32[0] = v11 & 1;
    int8x16_t v13 = (int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vceqq_s32(a9, a8), 0);
    v14.i64[0] = 0xFFFF0000FFFFLL;
    v14.i64[1] = 0xFFFF0000FFFFLL;
    v15.i64[0] = 0xFFFF0000FFFF0000;
    v15.i64[1] = 0xFFFF0000FFFF0000;
    int8x16_t v16 = vbslq_s8(v13, v15, v14);
  }
  else
  {
    int8x16_t v16 = (int8x16_t)vdupq_n_s16(-(v11 & 1));
  }
  if (v12 < 1) {
    goto LABEL_35;
  }
  __int32 v17 = 0;
  int v18 = *(const __int16 **)(a4 + 24);
  uint64_t v19 = a6 - 404;
  int16x8_t v20 = vdupq_n_s16(*(char *)(a2 + 4));
  __int32 v21 = result->i32[3];
  int v22 = v68;
  v23.i64[0] = 0x1000100010001;
  v23.i64[1] = 0x1000100010001;
  v24.i64[0] = -1;
  v24.i64[1] = -1;
  v25.i64[0] = 0x2000200020002;
  v25.i64[1] = 0x2000200020002;
  v26.i64[0] = 0x4000400040004;
  v26.i64[1] = 0x4000400040004;
  v27.i64[0] = 0x7000700070007;
  v27.i64[1] = 0x7000700070007;
  v28.i64[0] = 0xF000F000F000FLL;
  v28.i64[1] = 0xF000F000F000FLL;
  v29.i64[0] = 0x5000500050005;
  v29.i64[1] = 0x5000500050005;
  uint64_t result = &v70;
LABEL_9:
  unsigned int v30 = *(const __int16 **)(a5 + 24);
  int v31 = *(_DWORD *)a5;
  if (!v9)
  {
    int v9 = *(_DWORD *)a5;
    int v18 = *(const __int16 **)(a5 + 24);
  }
  if (v9 > 7)
  {
    int v32 = 8;
LABEL_14:
    v9 -= v32;
    int16x8x4_t v72 = vld4q_s16(v18);
    v18 += 32;
    goto LABEL_25;
  }
  int v32 = v12;
  if (v9 == v12) {
    goto LABEL_14;
  }
  if (v9 < 1) {
    sub_1000771F0();
  }
  unint64_t v33 = 0;
  uint64_t v34 = 2 * v9;
  do
  {
    v67[0].i16[v33 / 2] = *v18;
    v71.i16[v33 / 2] = v18[1];
    v70.i16[v33 / 2] = v18[2];
    v69.i16[v33 / 2] = v18[3];
    v33 += 2;
    v18 += 4;
  }
  while (v34 != v33);
  if (v12 >= 8) {
    int v35 = 8;
  }
  else {
    int v35 = v12;
  }
  if (v9 < v35)
  {
    unsigned int v36 = &v69.i16[(unint64_t)v34 / 2];
    unsigned int v37 = &v70.i16[(unint64_t)v34 / 2];
    int v38 = &v71.i16[(unint64_t)v34 / 2];
    unsigned __int16 v39 = &v67[0].i16[(unint64_t)v34 / 2];
    int v40 = v9;
    do
    {
      *v39++ = *v30;
      *v38++ = v30[1];
      *v37++ = v30[2];
      *v36++ = v30[3];
      v30 += 4;
      ++v40;
    }
    while (v35 > v40);
  }
  v72.val[0] = v67[0];
  v72.val[2] = v70;
  v72.val[1] = v71;
  v72.val[3] = v69;
  v9 += v31 - v35;
  int v18 = v30;
LABEL_25:
  uint64_t v41 = 0;
  int8x16_t v42 = (int8x16_t)vceqzq_s16((int16x8_t)vandq_s8((int8x16_t)v72.val[0], v26));
  int16x8_t v43 = (int16x8_t)vandq_s8((int8x16_t)v72.val[1], v27);
  int16x8_t v44 = vshrq_n_s16(v72.val[0], 3uLL);
  int8x16_t v45 = (int8x16_t)vaddq_s16(v72.val[3], (int16x8_t)vbslq_s8(v16, (int8x16_t)vnegq_s16(v44), (int8x16_t)v44));
  int8x16_t v46 = (int8x16_t)vcgtq_u16((uint16x8_t)v43, v29);
  int8x16_t v47 = (int8x16_t)vqshlq_n_u16((uint16x8_t)vabsq_s16(vshrq_n_s16(v72.val[1], 3uLL)), 4uLL);
  int16x8_t v48 = (int16x8_t)vandq_s8((int8x16_t)vaddq_s16((int16x8_t)vandq_s8((int8x16_t)v72.val[2], v28), (int16x8_t)vbicq_s8(v23, (int8x16_t)v72.val[0])), vorrq_s8(v46, (int8x16_t)vceqzq_s16((int16x8_t)vandq_s8((int8x16_t)v72.val[0], v25))));
  int16x8_t v49 = vaddq_s16((int16x8_t)vbslq_s8(v46, (int8x16_t)vaddq_s16(v43, v24), (int8x16_t)v43), (int16x8_t)vandq_s8(veorq_s8((int8x16_t)vcltzq_s16(v72.val[0]), (int8x16_t)vcgtq_s16(v72.val[1], v24)), v27));
  int16x8_t v50 = (int16x8_t)vshrq_n_u16((uint16x8_t)vbslq_s8(v46, (int8x16_t)vshrq_n_u16((uint16x8_t)v47, 1uLL), v47), 1uLL);
  int16x8_t v51 = vqshlq_s16(vqdmulhq_s16(v50, vmulq_s16((int16x8_t)vshrq_n_u16((uint16x8_t)v48, 1uLL), (int16x8_t)vshrq_n_u16((uint16x8_t)v72.val[2], 4uLL))), v20);
  int8x16_t v52 = (int8x16_t)vqdmulhq_s16(v51, v50);
  int8x16_t v53 = (int8x16_t)vqdmulhq_s16(v51, (int16x8_t)vshrq_n_u16(vqshlq_n_u16((uint16x8_t)vabsq_s16(v44), 4uLL), 1uLL));
  int8x16_t v54 = (int8x16_t)vceqzq_s16(v48);
  v67[0] = v49;
  v67[1] = (int16x8_t)vornq_s8(vandq_s8((int8x16_t)v48, v42), v42);
  v68[0] = vbslq_s8(v54, v45, v52);
  v68[1] = vbslq_s8(v54, (int8x16_t)v72.val[3], v53);
  int16x8_t v71 = (int16x8_t)v45;
  int v55 = v22;
  uint64_t v56 = (unsigned __int16 *)v22;
  while (1)
  {
    BOOL v57 = v17 == 0;
    if (!v17) {
      __int32 v17 = v21;
    }
    uint64_t v58 = v19 + 404 * v57;
    unsigned int v59 = *(v56 - 16);
    uint64_t v60 = *(v56 - 8);
    uint64_t v61 = *v56;
    uint64_t v62 = v56[8];
    ++*(_DWORD *)(v58 + 384);
    uint64_t v63 = v71.u16[v41];
    *(void *)(v58 + 388) += v63;
    *(void *)(v58 + 396) += v63 * (unint64_t)v63;
    if (v60)
    {
      if (v60 != 0xFFFF)
      {
        uint64_t v64 = (void *)(v58 + 24 * v59);
        uint64_t v65 = v64[1] + v61;
        *v64 += v60;
        v64[1] = v65;
        v64[2] += v62;
      }
    }
    else
    {
      int32x2_t v66 = (_DWORD *)(v19 + 404 * v57 + 12 * v11);
      ++v66[84];
      v66[85] += v61;
      v66[86] += v62;
    }
    ++*a7;
    if (v12 - 1 == v41) {
      break;
    }
    ++v56;
    v11 ^= a3;
    --v17;
    ++v41;
    v19 += 404 * v57;
    if (v41 == 8)
    {
      v12 -= 8;
      uint64_t v19 = v58;
      int v22 = v55;
      if (v12 + 1 > 1) {
        goto LABEL_9;
      }
      break;
    }
  }
LABEL_35:
  if (v9) {
    sub_1000771C4();
  }
  return result;
}

uint64_t sub_10004410C(uint64_t result, uint64_t a2, int *a3, int *a4, uint64_t a5, _DWORD *a6)
{
  int v6 = 2 * *(_DWORD *)(result + 4);
  if (v6 < 1) {
    return result;
  }
  int v7 = 0;
  int16x8_t v8 = vdupq_n_s16(*(char *)(a2 + 4));
  int v9 = 2 * *(_DWORD *)(result + 12);
  if (*a3) {
    uint64_t v10 = a3;
  }
  else {
    uint64_t v10 = a4;
  }
  uint64_t v11 = v10[2];
  int v12 = 2 * *a3;
  uint64_t v13 = a5 - 404;
  int8x16_t v14 = (const __int16 *)*((void *)a3 + 3);
  int v15 = v6 - 2;
  v16.i64[0] = 0x1000100010001;
  v16.i64[1] = 0x1000100010001;
  v17.i64[0] = -1;
  v17.i64[1] = -1;
  v18.i64[0] = 0x2000200020002;
  v18.i64[1] = 0x2000200020002;
  v19.i64[0] = 0x4000400040004;
  v19.i64[1] = 0x4000400040004;
  v20.i64[0] = 0x7000700070007;
  v20.i64[1] = 0x7000700070007;
  v21.i64[0] = 0xF000F000F000FLL;
  v21.i64[1] = 0xF000F000F000FLL;
  uint64_t result = 24;
  v22.i64[0] = 0x5000500050005;
  v22.i64[1] = 0x5000500050005;
LABEL_6:
  int8x16_t v23 = (const __int16 *)*((void *)a4 + 3);
  int v24 = *a4;
  int v25 = 2 * *a4;
  if (v12) {
    int v25 = v12;
  }
  else {
    int8x16_t v14 = (const __int16 *)*((void *)a4 + 3);
  }
  if (v25 > 15)
  {
    int v26 = 16;
LABEL_12:
    int8x16_t v27 = v14;
    int16x8x4_t v78 = vld4q_s16(v27);
    v27 += 32;
    int16x8x4_t v79 = vld4q_s16(v27);
    int16x8_t v28 = vuzp1q_s16(v78.val[0], v79.val[0]);
    int16x8_t v29 = vuzp1q_s16(v78.val[1], v79.val[1]);
    int8x16_t v30 = (int8x16_t)vuzp1q_s16(v78.val[2], v79.val[2]);
    int8x16_t v31 = (int8x16_t)vuzp1q_s16(v78.val[3], v79.val[3]);
    int16x8_t v32 = vuzp2q_s16(v78.val[3], v79.val[3]);
    int8x16_t v33 = (int8x16_t)vsubq_s16(v32, vshrq_n_s16(vuzp2q_s16(v78.val[0], v79.val[0]), 3uLL));
    v14 += 64;
    int v12 = v25 - v26;
    goto LABEL_27;
  }
  int v26 = v6;
  if (v25 == v6) {
    goto LABEL_12;
  }
  if (v25 <= 0) {
    sub_10007721C();
  }
  unsigned int v34 = v25 >> 1;
  if (v25 != 1)
  {
    if (v34 <= 1) {
      uint64_t v35 = 1;
    }
    else {
      uint64_t v35 = v34;
    }
    unsigned int v36 = &v74;
    unsigned int v37 = &v73;
    int v38 = &v75;
    unsigned __int16 v39 = &v76;
    int v40 = &v77;
    uint64_t v41 = (__int16 *)v72;
    do
    {
      *v41++ = *v14;
      v40->i16[0] = v14[1];
      int v40 = (int16x8_t *)((char *)v40 + 2);
      v39->i16[0] = v14[2];
      unsigned __int16 v39 = (int8x16_t *)((char *)v39 + 2);
      v38->i16[0] = v14[3];
      int v38 = (int8x16_t *)((char *)v38 + 2);
      __int16 v42 = v14[7];
      v37->i16[0] = v42;
      unsigned int v37 = (int16x8_t *)((char *)v37 + 2);
      v36->i16[0] = v42 + (v14[4] >> 3);
      unsigned int v36 = (int8x16_t *)((char *)v36 + 2);
      v14 += 8;
      --v35;
    }
    while (v35);
  }
  if (v6 <= 15) {
    uint64_t v43 = v6 >> 1;
  }
  else {
    uint64_t v43 = 8;
  }
  if (v34 < v43)
  {
    uint64_t v44 = 0;
    do
    {
      *((_WORD *)v72 + v34 + v44) = *v23;
      v77.i16[v34 + v44] = v23[1];
      v76.i16[v34 + v44] = v23[2];
      v75.i16[v34 + v44] = v23[3];
      __int16 v45 = v23[7];
      v73.i16[v34 + v44] = v45;
      v74.i16[v34 + v44] = v45 + (v23[4] >> 3);
      v23 += 8;
      ++v44;
    }
    while (v43 - v34 != v44);
  }
  int16x8_t v28 = (int16x8_t)v72[0];
  int16x8_t v29 = v77;
  int8x16_t v31 = v75;
  int8x16_t v30 = v76;
  int16x8_t v32 = v73;
  int8x16_t v33 = v74;
  int v12 = 2 * (v24 - v43 + v34);
  int8x16_t v14 = v23;
LABEL_27:
  unint64_t v46 = 0;
  int8x16_t v47 = (int8x16_t)vceqzq_s16((int16x8_t)vandq_s8((int8x16_t)v28, v19));
  int16x8_t v48 = (int16x8_t)vandq_s8((int8x16_t)v29, v20);
  int8x16_t v49 = (int8x16_t)vcgtq_u16((uint16x8_t)v48, v22);
  int8x16_t v50 = (int8x16_t)vqshlq_n_u16((uint16x8_t)vabsq_s16(vshrq_n_s16(v29, 3uLL)), 4uLL);
  uint16x8_t v51 = vqshlq_n_u16((uint16x8_t)vabsq_s16(vshrq_n_s16(v28, 3uLL)), 4uLL);
  int16x8_t v52 = (int16x8_t)vandq_s8((int8x16_t)vaddq_s16((int16x8_t)vandq_s8(v30, v21), (int16x8_t)vbicq_s8(v16, (int8x16_t)v28)), vorrq_s8(v49, (int8x16_t)vceqzq_s16((int16x8_t)vandq_s8((int8x16_t)v28, v18))));
  int8x16_t v53 = (int8x16_t)vaddq_s16((int16x8_t)vbslq_s8(v49, (int8x16_t)vaddq_s16(v48, v17), (int8x16_t)v48), (int16x8_t)vandq_s8(veorq_s8((int8x16_t)vcltzq_s16(v28), (int8x16_t)vcgtq_s16(v29, v17)), v20));
  int16x8_t v54 = vmulq_s16((int16x8_t)vshrq_n_u16((uint16x8_t)v52, 1uLL), (int16x8_t)vshrq_n_u16((uint16x8_t)v30, 4uLL));
  int16x8_t v55 = (int16x8_t)vshrq_n_u16((uint16x8_t)vbslq_s8(v49, (int8x16_t)vshrq_n_u16((uint16x8_t)v50, 1uLL), v50), 1uLL);
  int16x8_t v56 = vqshlq_s16(vqdmulhq_s16(v55, v54), v8);
  int8x16_t v57 = (int8x16_t)vceqzq_s16(v52);
  int16x8_t v77 = (int16x8_t)v33;
  v72[0] = vornq_s8(vandq_s8((int8x16_t)v52, v47), v47);
  v72[1] = vbslq_s8(v57, v33, (int8x16_t)vqdmulhq_s16(v56, v55));
  v72[2] = vbslq_s8(v57, v31, (int8x16_t)vqdmulhq_s16(v56, (int16x8_t)vshrq_n_u16(v51, 1uLL)));
  v72[3] = vbslq_s8(v57, (int8x16_t)v32, v53);
  v6 -= 16;
  while (1)
  {
    BOOL v58 = v7 == 0;
    if (!v7) {
      int v7 = v9;
    }
    uint64_t v59 = v13 + 404 * v58;
    uint64_t v60 = *(unsigned __int16 *)((char *)v72 + v46);
    ++*(_DWORD *)(v59 + 384);
    uint64_t v61 = v77.u16[v46 / 2];
    *(void *)(v59 + 388) += v61;
    *(void *)(v59 + 396) += v61 * (unint64_t)v61;
    if (v60)
    {
      if (v60 != 0xFFFF)
      {
        uint64_t v62 = *(unsigned __int16 *)((char *)&v72[2] + v46);
        uint64_t v63 = (void *)(v59 + 24 * *(unsigned __int16 *)((char *)&v72[3] + v46));
        uint64_t v64 = v63[1] + *(unsigned __int16 *)((char *)&v72[1] + v46);
        *v63 += v60;
        v63[1] = v64;
        v63[2] += v62;
      }
    }
    else
    {
      int v65 = *(unsigned __int16 *)((char *)&v72[1] + v46);
      int v66 = *(unsigned __int16 *)((char *)&v72[2] + v46);
      int v67 = *(unsigned __int16 *)((char *)&v72[3] + v46);
      uint64_t v68 = v13 + 404 * v58 + 336;
      int16x8_t v69 = (_DWORD *)(v68 + 12 * (int)v11);
      int v70 = v69[1] + v65;
      ++*v69;
      v69[1] = v70;
      v69[2] += v66;
      int16x8_t v71 = (_DWORD *)(v68 + 12 * (v11 + 1));
      LODWORD(v69) = v71[1];
      ++*v71;
      v71[1] = v69 + v65;
      v71[2] += v67;
    }
    ++*a6;
    if (v15 == v46) {
      return result;
    }
    v7 -= 2;
    v46 += 2;
    uint64_t v13 = v59;
    if (v46 == 16)
    {
      v15 -= 16;
      uint64_t v13 = v59;
      if (v6 > 0) {
        goto LABEL_6;
      }
      return result;
    }
  }
}

uint64_t sub_100044560(uint64_t result, uint64_t a2, int *a3, int *a4, uint64_t a5, _DWORD *a6)
{
  int v6 = 2 * *(_DWORD *)(result + 4);
  if (v6 < 1) {
    return result;
  }
  int v7 = 0;
  int16x8_t v8 = vdupq_n_s16(*(char *)(a2 + 4));
  int v9 = 2 * *(_DWORD *)(result + 12);
  if (*a3) {
    uint64_t v10 = a3;
  }
  else {
    uint64_t v10 = a4;
  }
  uint64_t v11 = v10[2];
  int v12 = 2 * *a3;
  uint64_t v13 = a5 - 404;
  int8x16_t v14 = (__int16 *)*((void *)a3 + 3);
  int v15 = v6 - 2;
  v16.i64[0] = 0x1000100010001;
  v16.i64[1] = 0x1000100010001;
  v17.i64[0] = -1;
  v17.i64[1] = -1;
  v18.i64[0] = 0x2000200020002;
  v18.i64[1] = 0x2000200020002;
  v19.i64[0] = 0x4000400040004;
  v19.i64[1] = 0x4000400040004;
  v20.i64[0] = 0x7000700070007;
  v20.i64[1] = 0x7000700070007;
  v21.i64[0] = 0xF000F000F000FLL;
  v21.i64[1] = 0xF000F000F000FLL;
  uint64_t result = 24;
  v22.i64[0] = 0x5000500050005;
  v22.i64[1] = 0x5000500050005;
LABEL_6:
  int8x16_t v23 = (__int16 *)*((void *)a4 + 3);
  int v24 = *a4;
  if (v12) {
    int v25 = v12;
  }
  else {
    int v25 = 2 * *a4;
  }
  if (v12) {
    int v26 = v14;
  }
  else {
    int v26 = (__int16 *)*((void *)a4 + 3);
  }
  if (v25 > 15)
  {
    int v27 = 16;
LABEL_15:
    int16x8_t v28 = v26;
    int16x8x4_t v80 = vld4q_s16(v28);
    v28 += 32;
    int16x8x4_t v81 = vld4q_s16(v28);
    int16x8_t v29 = vuzp2q_s16(v80.val[0], v81.val[0]);
    int16x8_t v30 = vuzp2q_s16(v80.val[1], v81.val[1]);
    int8x16_t v31 = (int8x16_t)vuzp2q_s16(v80.val[2], v81.val[2]);
    int16x8_t v32 = vuzp1q_s16(v80.val[3], v81.val[3]);
    int8x16_t v33 = (int8x16_t)vuzp2q_s16(v80.val[3], v81.val[3]);
    int8x16_t v34 = (int8x16_t)vsraq_n_s16(v32, vuzp1q_s16(v80.val[0], v81.val[0]), 3uLL);
    int8x16_t v14 = v26 + 64;
    int v12 = v25 - v27;
    goto LABEL_30;
  }
  int v27 = v6;
  if (v25 == v6) {
    goto LABEL_15;
  }
  if (v25 <= 0) {
    sub_10007721C();
  }
  unsigned int v35 = v25 >> 1;
  if (v25 != 1)
  {
    if (v35 <= 1) {
      uint64_t v36 = 1;
    }
    else {
      uint64_t v36 = v35;
    }
    unsigned int v37 = v26 + 4;
    int v38 = &v76;
    unsigned __int16 v39 = &v75;
    int v40 = &v77;
    uint64_t v41 = &v78;
    __int16 v42 = &v79;
    uint64_t v43 = v74;
    do
    {
      *v43++ = *v37;
      v42->i16[0] = v37[1];
      __int16 v42 = (int16x8_t *)((char *)v42 + 2);
      v41->i16[0] = v37[2];
      uint64_t v41 = (int8x16_t *)((char *)v41 + 2);
      v40->i16[0] = v37[3];
      int v40 = (int8x16_t *)((char *)v40 + 2);
      __int16 v44 = *(v37 - 1);
      v39->i16[0] = v44;
      unsigned __int16 v39 = (int16x8_t *)((char *)v39 + 2);
      v38->i16[0] = v44 - ((__int16)*(v37 - 4) >> 3);
      int v38 = (int8x16_t *)((char *)v38 + 2);
      v37 += 8;
      --v36;
    }
    while (v36);
  }
  LODWORD(v45) = v6 >> 1;
  if (v6 <= 15) {
    uint64_t v45 = v45;
  }
  else {
    uint64_t v45 = 8;
  }
  if (v35 < v45)
  {
    uint64_t v46 = 0;
    do
    {
      *((_WORD *)v74 + v35 + v46) = v23[4];
      v79.i16[v35 + v46] = v23[5];
      v78.i16[v35 + v46] = v23[6];
      v77.i16[v35 + v46] = v23[7];
      __int16 v47 = v23[3];
      v75.i16[v35 + v46] = v47;
      v76.i16[v35 + v46] = v47 - (*v23 >> 3);
      v23 += 8;
      ++v46;
    }
    while (v45 - v35 != v46);
  }
  int16x8_t v29 = (int16x8_t)v74[0];
  int16x8_t v30 = v79;
  int8x16_t v33 = v77;
  int8x16_t v31 = v78;
  int16x8_t v32 = v75;
  int8x16_t v34 = v76;
  int v12 = 2 * (v24 - v45 + v35);
  int8x16_t v14 = v23;
LABEL_30:
  unint64_t v48 = 0;
  int8x16_t v49 = (int8x16_t)vceqzq_s16((int16x8_t)vandq_s8((int8x16_t)v29, v19));
  int16x8_t v50 = (int16x8_t)vandq_s8((int8x16_t)v30, v20);
  int8x16_t v51 = (int8x16_t)vcgtq_u16((uint16x8_t)v50, v22);
  int8x16_t v52 = (int8x16_t)vqshlq_n_u16((uint16x8_t)vabsq_s16(vshrq_n_s16(v30, 3uLL)), 4uLL);
  uint16x8_t v53 = vqshlq_n_u16((uint16x8_t)vabsq_s16(vshrq_n_s16(v29, 3uLL)), 4uLL);
  int16x8_t v54 = (int16x8_t)vandq_s8((int8x16_t)vaddq_s16((int16x8_t)vandq_s8(v31, v21), (int16x8_t)vbicq_s8(v16, (int8x16_t)v29)), vorrq_s8(v51, (int8x16_t)vceqzq_s16((int16x8_t)vandq_s8((int8x16_t)v29, v18))));
  int8x16_t v55 = (int8x16_t)vaddq_s16((int16x8_t)vbslq_s8(v51, (int8x16_t)vaddq_s16(v50, v17), (int8x16_t)v50), (int16x8_t)vandq_s8(veorq_s8((int8x16_t)vcltzq_s16(v29), (int8x16_t)vcgtq_s16(v30, v17)), v20));
  int16x8_t v56 = vmulq_s16((int16x8_t)vshrq_n_u16((uint16x8_t)v54, 1uLL), (int16x8_t)vshrq_n_u16((uint16x8_t)v31, 4uLL));
  int16x8_t v57 = (int16x8_t)vshrq_n_u16((uint16x8_t)vbslq_s8(v51, (int8x16_t)vshrq_n_u16((uint16x8_t)v52, 1uLL), v52), 1uLL);
  int16x8_t v58 = vqshlq_s16(vqdmulhq_s16(v57, v56), v8);
  int8x16_t v59 = (int8x16_t)vceqzq_s16(v54);
  int16x8_t v79 = (int16x8_t)v34;
  v74[0] = vornq_s8(vandq_s8((int8x16_t)v54, v49), v49);
  v74[1] = vbslq_s8(v59, v34, (int8x16_t)vqdmulhq_s16(v58, v57));
  v74[2] = vbslq_s8(v59, (int8x16_t)v32, (int8x16_t)vqdmulhq_s16(v58, (int16x8_t)vshrq_n_u16(v53, 1uLL)));
  _OWORD v74[3] = vbslq_s8(v59, v33, v55);
  v6 -= 16;
  while (1)
  {
    BOOL v60 = v7 == 0;
    if (!v7) {
      int v7 = v9;
    }
    uint64_t v61 = v13 + 404 * v60;
    uint64_t v62 = *(unsigned __int16 *)((char *)v74 + v48);
    ++*(_DWORD *)(v61 + 384);
    uint64_t v63 = v79.u16[v48 / 2];
    *(void *)(v61 + 388) += v63;
    *(void *)(v61 + 396) += v63 * (unint64_t)v63;
    if (v62)
    {
      if (v62 != 0xFFFF)
      {
        uint64_t v64 = *(unsigned __int16 *)((char *)&v74[2] + v48);
        int v65 = (void *)(v61 + 24 * *(unsigned __int16 *)((char *)&v74[3] + v48));
        uint64_t v66 = v65[1] + *(unsigned __int16 *)((char *)&v74[1] + v48);
        *v65 += v62;
        v65[1] = v66;
        v65[2] += v64;
      }
    }
    else
    {
      int v67 = *(unsigned __int16 *)((char *)&v74[1] + v48);
      int v68 = *(unsigned __int16 *)((char *)&v74[2] + v48);
      int v69 = *(unsigned __int16 *)((char *)&v74[3] + v48);
      uint64_t v70 = v13 + 404 * v60 + 336;
      int16x8_t v71 = (_DWORD *)(v70 + 12 * (int)v11);
      int v72 = v71[1] + v67;
      ++*v71;
      v71[1] = v72;
      v71[2] += v68;
      int16x8_t v73 = (_DWORD *)(v70 + 12 * (v11 + 1));
      LODWORD(v71) = v73[1];
      ++*v73;
      v73[1] = v71 + v67;
      v73[2] += v69;
    }
    ++*a6;
    if (v15 == v48) {
      return result;
    }
    v7 -= 2;
    v48 += 2;
    uint64_t v13 = v61;
    if (v48 == 16)
    {
      v15 -= 16;
      uint64_t v13 = v61;
      if (v6 > 0) {
        goto LABEL_6;
      }
      return result;
    }
  }
}

uint64_t sub_1000449B8(unsigned int *a1, unint64_t a2, char a3, uint64_t a4, _WORD *a5, _WORD *a6, _WORD *a7)
{
  uint64_t v14 = a1[4];
  unsigned int v15 = a1[159];
  bzero(a7, a1[121820]);
  if (!a2) {
    sub_100077350();
  }
  uint64_t v16 = 0;
  int v17 = *(_DWORD *)(a4 + 16);
  uint64_t v18 = 24;
  if (!v17) {
    uint64_t v18 = 104;
  }
  int v19 = *(_DWORD *)(a4 + v18);
  unsigned int v20 = *(_DWORD *)a4;
  int8x16_t v21 = *(__int16 **)(a4 + 40);
  int v22 = *(_DWORD *)(a4 + 24);
  unsigned int v23 = (unsigned __int16)(v15 >> 4);
  do
  {
    int v24 = v17;
    uint64_t v25 = v14;
    int v26 = a7;
    int v27 = a6;
    int16x8_t v28 = a5;
    LOBYTE(v29) = v22;
    int16x8_t v30 = v21;
    if (v14)
    {
      do
      {
        if (!v24)
        {
          int16x8_t v30 = *(__int16 **)(a4 + 120);
          int v24 = *(_DWORD *)(a4 + 96);
          int v29 = *(_DWORD *)(a4 + 104);
        }
        int v31 = *v30 >> 3;
        unsigned int v32 = (unsigned __int16)v30[3];
        if (v29) {
          int v31 = -v31;
        }
        unsigned int v33 = (unsigned __int16)(v31 + v32);
        *v28 += (unsigned __int16)v30[3] >> 2;
        *v27 += v33 >> 2;
        if (v23 < v32 || v23 < v33) {
          ++*v26;
        }
        ++v26;
        v30 += 4;
        ++v28;
        ++v27;
        --v24;
        LOBYTE(v29) = v29 ^ a3;
        --v25;
      }
      while (v25);
    }
    if (v20 > 8) {
      sub_1000770BC();
    }
    if (((1 << v20) & 0xFA) != 0)
    {
      uint64_t v35 = *(void *)(a4 + 32);
      if (v35)
      {
        *(void *)(a4 + 32) = v35 - 1;
        uint64_t v36 = *(void *)(a4 + 8);
      }
      else
      {
        uint64_t v36 = 2 * *(void *)(a4 + 8);
      }
      v21 += v36;
      *(void *)(a4 + 40) = v21;
      int v37 = *(_DWORD *)(a4 + 20) + 2;
    }
    else
    {
      if (((1 << v20) & 0x101) != 0)
      {
        v21 += *(void *)(a4 + 8);
        *(void *)(a4 + 40) = v21;
        v22 ^= 1u;
        ++*(_DWORD *)(a4 + 20);
        *(_DWORD *)(a4 + 24) = v22;
        goto LABEL_25;
      }
      v21 += *(void *)(a4 + 8);
      *(void *)(a4 + 40) = v21;
      int v37 = *(_DWORD *)(a4 + 20) + 1;
    }
    *(_DWORD *)(a4 + 20) = v37;
LABEL_25:
    unsigned int v38 = *(_DWORD *)(a4 + 80);
    if (v38 > 8) {
      sub_1000770BC();
    }
    int v39 = 1 << v38;
    if ((v39 & 0xFA) != 0)
    {
      uint64_t v40 = *(void *)(a4 + 112);
      if (v40)
      {
        *(void *)(a4 + 112) = v40 - 1;
        uint64_t v41 = *(void *)(a4 + 88);
      }
      else
      {
        uint64_t v41 = 2 * *(void *)(a4 + 88);
      }
      *(void *)(a4 + 120) += 2 * v41;
      int v44 = *(_DWORD *)(a4 + 100) + 2;
    }
    else
    {
      if ((v39 & 0x101) != 0)
      {
        *(void *)(a4 + 120) += 2 * *(void *)(a4 + 88);
        int32x2_t v42 = *(int32x2_t *)(a4 + 100);
        LODWORD(v43) = vadd_s32(v42, (int32x2_t)0x100000001).u32[0];
        HIDWORD(v43) = veor_s8(*(int8x8_t *)&v42, (int8x8_t)0x100000001).i32[1];
        *(void *)(a4 + 100) = v43;
        goto LABEL_34;
      }
      *(void *)(a4 + 120) += 2 * *(void *)(a4 + 88);
      int v44 = *(_DWORD *)(a4 + 100) + 1;
    }
    *(_DWORD *)(a4 + 100) = v44;
LABEL_34:
    if (v24) {
      sub_10007737C();
    }
    ++v16;
  }
  while (v16 != a2);

  return sub_100044F10((uint64_t)(a1 + 154), 0x80 / a2, v14, v19, a5, a6, a7);
}

void sub_100044C7C(int a1, unsigned int *a2, uint64_t a3, unsigned __int16 *__src, unsigned __int16 *a5, char *__dst, _WORD *a7, uint64_t a8)
{
  unsigned int v15 = a2[8];
  switch(v15)
  {
    case 4u:
      sub_100045004(a2[7], __src, (uint64_t)__dst);
      sub_100045004(a2[7], a5, (uint64_t)a7);
      break;
    case 2u:
      sub_100044FA4(a2[7], __src, __dst);
      sub_100044FA4(a2[7], a5, a7);
      break;
    case 1u:
      memcpy(__dst, __src, 2 * a2[7]);
      memcpy(a7, a5, 2 * a2[7]);
      break;
    default:
      sub_1000773A8();
  }
  if (a1 == 1)
  {
    if ((*(_DWORD *)(a3 + 4) & 0x80000000) == 0) {
      sub_100077458();
    }
    if (*(int *)(a3 + 8) <= 0) {
      sub_100077484();
    }
    if (a2[13])
    {
      unsigned int v38 = 0;
      unsigned int v39 = 0;
      unsigned int v40 = a2[10];
      do
      {
        if (a2[12] + v39 >= a2[11]) {
          unsigned int v39 = a2[11];
        }
        else {
          v39 += a2[12];
        }
        unsigned int v41 = (v39 - v40) & 0xFFFFFFF8;
        *(_DWORD *)(a8 + 340) = v41;
        int32x2_t v42 = (int16x8_t *)&__dst[2 * v40];
        uint64_t v43 = (int8x16_t *)&a7[v40];
        sub_100045090(v41, v42, v43, a8);
        sub_100045090(v41, v42, v43 + 1, a8 + 160);
        a8 += 360;
        ++v38;
        unsigned int v40 = v39;
      }
      while (v38 < a2[13]);
    }
  }
  else
  {
    if (a1) {
      sub_1000773D4();
    }
    uint64_t v16 = *(int *)(a3 + 4);
    if ((v16 & 0x80000000) == 0) {
      sub_100077400();
    }
    int v17 = *(_DWORD *)(a3 + 8);
    if (v17 <= 0) {
      sub_10007742C();
    }
    unsigned int v18 = a2[13];
    if (v18)
    {
      int v19 = 0;
      unsigned int v20 = 0;
      unsigned int v22 = a2[11];
      unsigned int v21 = a2[12];
      int v23 = v17 + 1;
      unsigned int v24 = a2[10];
      do
      {
        uint64_t v25 = &__dst[2 * v24];
        int v26 = &a7[v24];
        v20 += v21;
        if (v20 >= v22) {
          unsigned int v20 = v22;
        }
        unsigned int v27 = (v20 - v24) & 0xFFFFFFF8;
        *(_DWORD *)(a8 + 340) = v27;
        uint64_t v28 = v16;
        int v29 = (float32x4_t *)a8;
        do
        {
          unsigned int v30 = 0;
          int32x4_t v31 = 0uLL;
          if (v27)
          {
            unsigned int v32 = v27;
            unsigned int v33 = v25;
            int8x16_t v34 = &v26[v28];
            do
            {
              int v35 = *(unsigned __int16 *)v33;
              if (v35 != 0xFFFF)
              {
                unsigned int v36 = *v34;
                if (v36 != 0xFFFF)
                {
                  v30 += v36 * v36;
                  v37.i32[0] = *(unsigned __int16 *)v33;
                  v37.i32[1] = v35 * v35;
                  v37.i64[1] = __PAIR64__(v36 * v35, v36);
                  int32x4_t v31 = vaddq_s32(v31, v37);
                }
              }
              v33 += 2;
              ++v34;
              --v32;
            }
            while (v32);
          }
          v29[1].f32[0] = v29[1].f32[0] + (float)v30;
          *int v29 = vaddq_f32(*v29, vcvtq_f32_u32((uint32x4_t)v31));
          int v29 = (float32x4_t *)((char *)v29 + 20);
          ++v28;
        }
        while (v23 != v28);
        ++v19;
        a8 += 360;
        unsigned int v24 = v20;
      }
      while (v19 != v18);
    }
  }
}

uint64_t sub_100044F10(uint64_t result, int a2, uint64_t a3, char a4, _WORD *a5, _WORD *a6, _WORD *a7)
{
  unsigned int v7 = *(unsigned __int16 *)(result + 24);
  if (!*(unsigned char *)(result + 16)) {
    unsigned int v7 = 0xFFFF;
  }
  for (; a3; --a3)
  {
    *a5 = ((unsigned __int16)*a5 * a2) >> 5;
    unsigned int v8 = (unsigned __int16)*a6 * a2;
    *a6 = v8 >> 5;
    unsigned int v9 = (unsigned __int16)*a5;
    unsigned int v10 = (v8 >> 4) & 0xFFFE;
    BOOL v11 = v10 >= v9;
    __int16 v12 = v10 - v9;
    if (!v11) {
      __int16 v12 = 0;
    }
    if (a4)
    {
      *a5 = v12;
      __int16 v12 = v9;
    }
    *a6 = v12;
    if (v7 <= (unsigned __int16)*a7)
    {
      *a7 = 1;
      *a5 = -1;
      *a6 = -1;
    }
    ++a7;
    ++a5;
    ++a6;
    a4 ^= 1u;
  }
  return result;
}

uint64_t sub_100044FA4(uint64_t result, unsigned __int16 *a2, _WORD *a3)
{
  uint64_t v3 = result - 1;
  if (result != 1)
  {
    do
    {
      *a3 = *a2;
      int v4 = *a2;
      if (v4 == 0xFFFF)
      {
        LOWORD(v6) = -1;
      }
      else
      {
        int v5 = a2[1];
        unsigned int v6 = (v4 + v5 + 1) >> 1;
        if (v5 == 0xFFFF) {
          LOWORD(v6) = -1;
        }
      }
      a3[1] = v6;
      ++a2;
      a3 += 2;
      --v3;
    }
    while (v3);
  }
  *a3 = *a2;
  return result;
}

uint64_t sub_100045004(uint64_t result, unsigned __int16 *a2, uint64_t a3)
{
  uint64_t v3 = result - 1;
  if (result != 1)
  {
    do
    {
      int v4 = *a2;
      *(_WORD *)a3 = v4;
      int v5 = *a2;
      if (v5 == 0xFFFF || (int v6 = a2[1], v6 == 0xFFFF))
      {
        *(_DWORD *)(a3 + 2) = -1;
        LOWORD(v8) = -1;
      }
      else
      {
        unsigned int v7 = v5 + v6 + 1;
        *(_WORD *)(a3 + 4) = v7 >> 1;
        *(_WORD *)(a3 + 2) = (v4 + (v7 >> 1) + 1) >> 1;
        unsigned int v8 = (a2[1] + (v7 >> 1) + 1) >> 1;
      }
      *(_WORD *)(a3 + 6) = v8;
      ++a2;
      a3 += 8;
      --v3;
    }
    while (v3);
  }
  *(_WORD *)a3 = *a2;
  return result;
}

float sub_100045090(int a1, int16x8_t *a2, int8x16_t *a3, uint64_t a4)
{
  if (a1 < 1)
  {
    int32x4_t v21 = 0uLL;
    float v92 = 0.0;
    float v91 = 0.0;
    float v90 = 0.0;
    float v89 = 0.0;
    float v88 = 0.0;
    float v87 = 0.0;
    float v86 = 0.0;
    float v85 = 0.0;
    int32x4_t v20 = 0uLL;
    int32x4_t v19 = 0uLL;
    int32x4_t v18 = 0uLL;
    int32x4_t v17 = 0uLL;
    int32x4_t v16 = 0uLL;
    int32x4_t v14 = 0uLL;
    int32x4_t v12 = 0uLL;
  }
  else
  {
    unsigned int v4 = 0;
    unsigned int v5 = 0;
    unsigned int v6 = 0;
    unsigned int v7 = 0;
    unsigned int v8 = 0;
    unsigned int v9 = 0;
    unsigned int v10 = 0;
    unsigned int v11 = 0;
    int32x4_t v12 = 0uLL;
    v13.i64[0] = -1;
    v13.i64[1] = -1;
    int32x4_t v14 = 0uLL;
    unsigned int v15 = a1 + 8;
    int32x4_t v16 = 0uLL;
    int32x4_t v17 = 0uLL;
    int32x4_t v18 = 0uLL;
    int32x4_t v19 = 0uLL;
    int32x4_t v20 = 0uLL;
    int32x4_t v21 = 0uLL;
    do
    {
      int16x8_t v22 = (int16x8_t)a3[-1];
      int16x8_t v23 = (int16x8_t)vextq_s8((int8x16_t)v22, *a3, 2uLL);
      int16x8_t v24 = (int16x8_t)vextq_s8((int8x16_t)v22, *a3, 4uLL);
      int16x8_t v25 = (int16x8_t)vextq_s8((int8x16_t)v22, *a3, 6uLL);
      int16x8_t v26 = (int16x8_t)vextq_s8((int8x16_t)v22, *a3, 8uLL);
      int16x8_t v27 = *a2++;
      int16x8_t v28 = (int16x8_t)vextq_s8((int8x16_t)v22, *a3, 0xAuLL);
      int16x8_t v29 = (int16x8_t)vextq_s8((int8x16_t)v22, *a3, 0xCuLL);
      int16x8_t v30 = (int16x8_t)vextq_s8((int8x16_t)v22, *a3, 0xEuLL);
      uint16x8_t v31 = (uint16x8_t)vmvnq_s8((int8x16_t)vceqq_s16(v27, v13));
      int32x4_t v32 = (int32x4_t)vminq_u16(v31, (uint16x8_t)vmvnq_s8((int8x16_t)vceqq_s16(v22, v13)));
      int16x8_t v33 = (int16x8_t)vminq_u16((uint16x8_t)v27, (uint16x8_t)v32);
      int16x8_t v34 = (int16x8_t)vminq_u16((uint16x8_t)v22, (uint16x8_t)v32);
      int32x4_t v35 = (int32x4_t)vmlal_high_u16(vmull_u16(*(uint16x4_t *)v33.i8, *(uint16x4_t *)v33.i8), (uint16x8_t)v33, (uint16x8_t)v33);
      int32x4_t v36 = (int32x4_t)vmlal_high_u16(vmull_u16(*(uint16x4_t *)v34.i8, *(uint16x4_t *)v34.i8), (uint16x8_t)v34, (uint16x8_t)v34);
      int32x4_t v37 = (int32x4_t)vmlal_high_u16(vmull_u16(*(uint16x4_t *)v33.i8, *(uint16x4_t *)v34.i8), (uint16x8_t)v33, (uint16x8_t)v34);
      v32.i16[0] = vaddvq_s16(v33);
      v33.i16[0] = vaddvq_s16(v34);
      uint16x8_t v38 = vminq_u16(v31, (uint16x8_t)vmvnq_s8((int8x16_t)vceqq_s16(v23, v13)));
      int16x8_t v39 = (int16x8_t)vminq_u16((uint16x8_t)v27, v38);
      int16x8_t v40 = (int16x8_t)vminq_u16((uint16x8_t)v23, v38);
      v32.i32[1] = v33.i32[0];
      int32x4_t v41 = (int32x4_t)vmlal_high_u16(vmull_u16(*(uint16x4_t *)v39.i8, *(uint16x4_t *)v39.i8), (uint16x8_t)v39, (uint16x8_t)v39);
      int32x4_t v42 = (int32x4_t)vmlal_high_u16(vmull_u16(*(uint16x4_t *)v40.i8, *(uint16x4_t *)v40.i8), (uint16x8_t)v40, (uint16x8_t)v40);
      int v43 = vaddvq_s32(v37);
      int32x4_t v44 = (int32x4_t)vmlal_high_u16(vmull_u16(*(uint16x4_t *)v39.i8, *(uint16x4_t *)v40.i8), (uint16x8_t)v39, (uint16x8_t)v40);
      v37.i16[0] = vaddvq_s16(v39);
      v40.i16[0] = vaddvq_s16(v40);
      v37.i32[1] = v40.i32[0];
      v39.i32[0] = vaddvq_s32(v35);
      int32x4_t v45 = (int32x4_t)vminq_u16(v31, (uint16x8_t)vmvnq_s8((int8x16_t)vceqq_s16(v24, v13)));
      int16x8_t v46 = (int16x8_t)vminq_u16((uint16x8_t)v27, (uint16x8_t)v45);
      int v47 = vaddvq_s32(v44);
      int16x8_t v48 = (int16x8_t)vminq_u16((uint16x8_t)v24, (uint16x8_t)v45);
      int32x4_t v49 = (int32x4_t)vmlal_high_u16(vmull_u16(*(uint16x4_t *)v48.i8, *(uint16x4_t *)v48.i8), (uint16x8_t)v48, (uint16x8_t)v48);
      v45.i32[0] = vaddvq_s32(v41);
      int32x4_t v50 = (int32x4_t)vmlal_high_u16(vmull_u16(*(uint16x4_t *)v46.i8, *(uint16x4_t *)v48.i8), (uint16x8_t)v46, (uint16x8_t)v48);
      int v51 = vaddvq_s32(v50);
      v44.i16[0] = vaddvq_s16(v46);
      v50.i16[0] = vaddvq_s16(v48);
      int v52 = v43;
      v44.i32[1] = v50.i32[0];
      v46.i32[0] = vaddvq_s32((int32x4_t)vmlal_high_u16(vmull_u16(*(uint16x4_t *)v46.i8, *(uint16x4_t *)v46.i8), (uint16x8_t)v46, (uint16x8_t)v46));
      *(int8x8_t *)v32.i8 = vand_s8(*(int8x8_t *)v32.i8, (int8x8_t)0xFFFF0000FFFFLL);
      uint16x8_t v53 = vminq_u16(v31, (uint16x8_t)vmvnq_s8((int8x16_t)vceqq_s16(v25, v13)));
      int16x8_t v54 = (int16x8_t)vminq_u16((uint16x8_t)v27, v53);
      int16x8_t v55 = (int16x8_t)vminq_u16((uint16x8_t)v25, v53);
      v32.i64[1] = __PAIR64__(vaddvq_s32(v36), v39.u32[0]);
      int32x4_t v56 = (int32x4_t)vmlal_high_u16(vmull_u16(*(uint16x4_t *)v54.i8, *(uint16x4_t *)v54.i8), (uint16x8_t)v54, (uint16x8_t)v54);
      int32x4_t v57 = (int32x4_t)vmlal_high_u16(vmull_u16(*(uint16x4_t *)v55.i8, *(uint16x4_t *)v55.i8), (uint16x8_t)v55, (uint16x8_t)v55);
      int v58 = v47;
      int32x4_t v59 = (int32x4_t)vmlal_high_u16(vmull_u16(*(uint16x4_t *)v54.i8, *(uint16x4_t *)v55.i8), (uint16x8_t)v54, (uint16x8_t)v55);
      v60.i32[0] = vaddvq_s32(v59);
      v54.i16[0] = vaddvq_s16(v54);
      v59.i16[0] = vaddvq_s16(v55);
      *(int8x8_t *)v55.i8 = vand_s8(*(int8x8_t *)v37.i8, (int8x8_t)0xFFFF0000FFFFLL);
      v54.i32[1] = v59.i32[0];
      int v61 = v51;
      uint16x8_t v62 = vminq_u16(v31, (uint16x8_t)vmvnq_s8((int8x16_t)vceqq_s16(v26, v13)));
      int16x8_t v63 = (int16x8_t)vminq_u16((uint16x8_t)v27, v62);
      int16x8_t v64 = (int16x8_t)vminq_u16((uint16x8_t)v26, v62);
      int32x4_t v65 = (int32x4_t)vmlal_high_u16(vmull_u16(*(uint16x4_t *)v63.i8, *(uint16x4_t *)v63.i8), (uint16x8_t)v63, (uint16x8_t)v63);
      *(int8x8_t *)v26.i8 = vand_s8(*(int8x8_t *)v44.i8, (int8x8_t)0xFFFF0000FFFFLL);
      int32x4_t v66 = (int32x4_t)vmlal_high_u16(vmull_u16(*(uint16x4_t *)v64.i8, *(uint16x4_t *)v64.i8), (uint16x8_t)v64, (uint16x8_t)v64);
      int v67 = vaddvq_s32((int32x4_t)vmlal_high_u16(vmull_u16(*(uint16x4_t *)v63.i8, *(uint16x4_t *)v64.i8), (uint16x8_t)v63, (uint16x8_t)v64));
      __int32 v68 = v60.i32[0];
      v60.i16[0] = vaddvq_s16(v63);
      v64.i16[0] = vaddvq_s16(v64);
      v60.i32[1] = v64.i32[0];
      *(int8x8_t *)v64.i8 = vand_s8(*(int8x8_t *)v54.i8, (int8x8_t)0xFFFF0000FFFFLL);
      uint16x8_t v69 = vminq_u16(v31, (uint16x8_t)vmvnq_s8((int8x16_t)vceqq_s16(v28, v13)));
      int16x8_t v70 = (int16x8_t)vminq_u16((uint16x8_t)v27, v69);
      int16x8_t v71 = (int16x8_t)vminq_u16((uint16x8_t)v28, v69);
      int v72 = v67;
      v55.i64[1] = __PAIR64__(vaddvq_s32(v42), v45.u32[0]);
      int v73 = vaddvq_s32((int32x4_t)vmlal_high_u16(vmull_u16(*(uint16x4_t *)v70.i8, *(uint16x4_t *)v71.i8), (uint16x8_t)v70, (uint16x8_t)v71));
      int32x4_t v74 = (int32x4_t)vmlal_high_u16(vmull_u16(*(uint16x4_t *)v71.i8, *(uint16x4_t *)v71.i8), (uint16x8_t)v71, (uint16x8_t)v71);
      v26.i64[1] = __PAIR64__(vaddvq_s32(v49), v46.u32[0]);
      v46.i16[0] = vaddvq_s16(v70);
      v71.i16[0] = vaddvq_s16(v71);
      v46.i32[1] = v71.i32[0];
      v64.i64[1] = __PAIR64__(vaddvq_s32(v57), vaddvq_s32(v56));
      v4 += v52;
      *(int8x8_t *)v45.i8 = vand_s8(v60, (int8x8_t)0xFFFF0000FFFFLL);
      v45.i64[1] = __PAIR64__(vaddvq_s32(v66), vaddvq_s32(v65));
      v5 += v58;
      v6 += v61;
      *(int8x8_t *)v71.i8 = vand_s8(*(int8x8_t *)v46.i8, (int8x8_t)0xFFFF0000FFFFLL);
      v71.i64[1] = __PAIR64__(vaddvq_s32(v74), vaddvq_s32((int32x4_t)vmlal_high_u16(vmull_u16(*(uint16x4_t *)v70.i8, *(uint16x4_t *)v70.i8), (uint16x8_t)v70, (uint16x8_t)v70)));
      v7 += v68;
      v8 += v72;
      v9 += v73;
      uint16x8_t v75 = vminq_u16(v31, (uint16x8_t)vmvnq_s8((int8x16_t)vceqq_s16(v29, v13)));
      int16x8_t v76 = (int16x8_t)vminq_u16((uint16x8_t)v27, v75);
      int16x8_t v77 = (int16x8_t)vminq_u16((uint16x8_t)v29, v75);
      int32x4_t v78 = (int32x4_t)vmlal_high_u16(vmull_u16(*(uint16x4_t *)v76.i8, *(uint16x4_t *)v76.i8), (uint16x8_t)v76, (uint16x8_t)v76);
      int32x4_t v79 = (int32x4_t)vmlal_high_u16(vmull_u16(*(uint16x4_t *)v77.i8, *(uint16x4_t *)v77.i8), (uint16x8_t)v77, (uint16x8_t)v77);
      v10 += vaddvq_s32((int32x4_t)vmlal_high_u16(vmull_u16(*(uint16x4_t *)v76.i8, *(uint16x4_t *)v77.i8), (uint16x8_t)v76, (uint16x8_t)v77));
      v76.i16[0] = vaddvq_s16(v76);
      v77.i16[0] = vaddvq_s16(v77);
      v76.i32[1] = v77.i32[0];
      *(int8x8_t *)v76.i8 = vand_s8(*(int8x8_t *)v76.i8, (int8x8_t)0xFFFF0000FFFFLL);
      int32x4_t v12 = vaddq_s32(v32, v12);
      v76.i64[1] = __PAIR64__(vaddvq_s32(v79), vaddvq_s32(v78));
      int32x4_t v14 = vaddq_s32((int32x4_t)v55, v14);
      uint16x8_t v80 = vminq_u16(v31, (uint16x8_t)vmvnq_s8((int8x16_t)vceqq_s16(v30, v13)));
      int16x8_t v81 = (int16x8_t)vminq_u16((uint16x8_t)v27, v80);
      int32x4_t v16 = vaddq_s32((int32x4_t)v26, v16);
      int16x8_t v82 = (int16x8_t)vminq_u16((uint16x8_t)v30, v80);
      int32x4_t v83 = (int32x4_t)vmlal_high_u16(vmull_u16(*(uint16x4_t *)v81.i8, *(uint16x4_t *)v81.i8), (uint16x8_t)v81, (uint16x8_t)v81);
      int32x4_t v84 = (int32x4_t)vmlal_high_u16(vmull_u16(*(uint16x4_t *)v82.i8, *(uint16x4_t *)v82.i8), (uint16x8_t)v82, (uint16x8_t)v82);
      int32x4_t v17 = vaddq_s32((int32x4_t)v64, v17);
      v11 += vaddvq_s32((int32x4_t)vmlal_high_u16(vmull_u16(*(uint16x4_t *)v81.i8, *(uint16x4_t *)v82.i8), (uint16x8_t)v81, (uint16x8_t)v82));
      int32x4_t v18 = vaddq_s32(v45, v18);
      v81.i16[0] = vaddvq_s16(v81);
      v82.i16[0] = vaddvq_s16(v82);
      v81.i32[1] = v82.i32[0];
      int32x4_t v19 = vaddq_s32((int32x4_t)v71, v19);
      *(int8x8_t *)v81.i8 = vand_s8(*(int8x8_t *)v81.i8, (int8x8_t)0xFFFF0000FFFFLL);
      v81.i64[1] = __PAIR64__(vaddvq_s32(v84), vaddvq_s32(v83));
      int32x4_t v20 = vaddq_s32((int32x4_t)v76, v20);
      v15 -= 8;
      ++a3;
      int32x4_t v21 = vaddq_s32((int32x4_t)v81, v21);
    }
    while (v15 > 8);
    float v85 = (float)v4;
    float v86 = (float)v5;
    float v87 = (float)v6;
    float v88 = (float)v7;
    float v89 = (float)v8;
    float v90 = (float)v9;
    float v91 = (float)v10;
    float v92 = (float)v11;
  }
  *(float32x2_t *)a4 = vcvt_f32_u32((uint32x2_t)vzip1_s32(*(int32x2_t *)v12.i8, (int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v12, (int8x16_t)v12, 8uLL)));
  *(float *)(a4 + 8) = (float)v12.u32[1];
  *(float *)(a4 + 12) = v85;
  *(float32x4_t *)(a4 + 16) = vcvtq_f32_u32((uint32x4_t)vextq_s8((int8x16_t)v12, (int8x16_t)vuzp2q_s32(vtrn1q_s32(v12, v14), v14), 0xCuLL));
  *(float *)(a4 + 32) = v86;
  *(float32x4_t *)(a4 + 36) = vcvtq_f32_u32((uint32x4_t)vextq_s8((int8x16_t)v14, (int8x16_t)vuzp2q_s32(vtrn1q_s32(v14, v16), v16), 0xCuLL));
  *(float *)(a4 + 52) = v87;
  *(float32x4_t *)(a4 + 56) = vcvtq_f32_u32((uint32x4_t)vextq_s8((int8x16_t)v16, (int8x16_t)vuzp2q_s32(vtrn1q_s32(v16, v17), v17), 0xCuLL));
  *(float *)(a4 + 72) = v88;
  *(float32x4_t *)(a4 + 76) = vcvtq_f32_u32((uint32x4_t)vextq_s8((int8x16_t)v17, (int8x16_t)vuzp2q_s32(vtrn1q_s32(v17, v18), v18), 0xCuLL));
  *(float *)(a4 + 92) = v89;
  *(float32x4_t *)(a4 + 96) = vcvtq_f32_u32((uint32x4_t)vextq_s8((int8x16_t)v18, (int8x16_t)vuzp2q_s32(vtrn1q_s32(v18, v19), v19), 0xCuLL));
  *(float *)(a4 + 112) = v90;
  *(float32x4_t *)(a4 + 116) = vcvtq_f32_u32((uint32x4_t)vextq_s8((int8x16_t)v19, (int8x16_t)vuzp2q_s32(vtrn1q_s32(v19, v20), v20), 0xCuLL));
  *(float *)(a4 + 132) = v91;
  *(float32x4_t *)(a4 + 136) = vcvtq_f32_u32((uint32x4_t)vextq_s8((int8x16_t)v20, (int8x16_t)vuzp2q_s32(vtrn1q_s32(v20, v21), v21), 0xCuLL));
  *(float *)v21.i32 = (float)v21.u32[3];
  *(float *)(a4 + 152) = v92;
  *(float *)(a4 + 156) = (float)v21.u32[3];
  return *(float *)v21.i32;
}

uint64_t sub_10004555C(unsigned int *a1, int a2, unint64_t a3, int *a4, _WORD *a5, _WORD *a6, _WORD *a7)
{
  uint64_t v9 = a1[5];
  int v10 = *a4;
  int v37 = a4[12];
  uint64_t v11 = *((void *)a4 + 8);
  uint64_t v12 = *((void *)a4 + 9);
  int v13 = a4[20];
  uint64_t v43 = *((void *)a4 + 11);
  uint64_t v44 = *((void *)a4 + 1);
  int v14 = a4[32];
  uint64_t v16 = *((void *)a4 + 18);
  unsigned int v15 = (__int16 *)*((void *)a4 + 19);
  unsigned int v36 = a1[159];
  bzero(a7, a1[121820]);
  if (!a3) {
    sub_1000774B0();
  }
  uint64_t v17 = 14;
  if (!a4[12]) {
    uint64_t v17 = 34;
  }
  int v18 = a4[v17];
  if (v9)
  {
    uint64_t v19 = 0;
    int v20 = v37 - a2;
    if (v37 - a2 >= 1) {
      int v21 = 0;
    }
    else {
      int v21 = v14;
    }
    int v22 = v21 + v20;
    unsigned int v23 = (unsigned __int16)(v36 >> 4);
    int16x8_t v24 = a5;
    int16x8_t v25 = a6;
    char v26 = v18;
    int16x8_t v27 = a7;
    do
    {
      if (v20 >= 1) {
        int16x8_t v28 = (__int16 *)(v12 + 8 * a2);
      }
      else {
        int16x8_t v28 = &v15[-4 * v20];
      }
      unint64_t v29 = a3;
      int v30 = v22;
      do
      {
        if (!v30)
        {
          int16x8_t v28 = v15;
          int v30 = v14;
        }
        int v31 = *v28 >> 3;
        unsigned int v32 = (unsigned __int16)v28[3];
        if (v26) {
          int v31 = -v31;
        }
        *v24 += (unsigned __int16)v28[3] >> 2;
        *v25 += (unsigned __int16)(v31 + v32) >> 2;
        if (v23 < v32 || v23 < (unsigned __int16)(v31 + v32)) {
          ++*v27;
        }
        v28 += 4;
        --v30;
        --v29;
      }
      while (v29);
      if ((v10 - 3) >= 5)
      {
        switch(v10)
        {
          case 0:
          case 2:
          case 8:
            sub_100077140();
          case 1:
            break;
          default:
            sub_100077114();
        }
      }
      if ((v13 - 3) >= 5)
      {
        switch(v13)
        {
          case 0:
          case 2:
          case 8:
            sub_100077140();
          case 1:
            break;
          default:
            sub_100077114();
        }
      }
      v12 += 2 * (v44 << (v11 != 0));
      if (v11) {
        --v11;
      }
      else {
        uint64_t v11 = 0;
      }
      uint64_t v34 = v16 - 1;
      if (!v16) {
        uint64_t v34 = 0;
      }
      v15 += v43 << (v16 != 0);
      ++v24;
      ++v25;
      ++v27;
      v26 ^= 1u;
      ++v19;
      uint64_t v16 = v34;
    }
    while (v19 != v9);
  }

  return sub_100044F10((uint64_t)(a1 + 154), 0x80 / a3, v9, v18, a5, a6, a7);
}

uint64_t sub_10004582C(uint64_t a1, unsigned int a2, uint64_t a3, _WORD *a4, _WORD *a5)
{
  if (!a2) {
    sub_1000774DC();
  }
  int v5 = 0;
  uint64_t v6 = *(unsigned int *)(a1 + 4);
  int v7 = *(_DWORD *)(a3 + 16);
  unsigned int v8 = *(_DWORD *)a3;
  uint64_t v9 = *(void *)(a3 + 40);
  do
  {
    int v10 = v7;
    uint64_t v11 = v6;
    uint64_t v12 = a5;
    int v13 = a4;
    uint64_t v14 = v9;
    if (v6)
    {
      do
      {
        if (!v10)
        {
          uint64_t v14 = *(void *)(a3 + 120);
          int v10 = *(_DWORD *)(a3 + 96);
        }
        *v13++ += *(_WORD *)(v14 + 6) >> 2;
        *v12++ += *(_WORD *)(v14 + 14) >> 2;
        v14 += 16;
        --v10;
        --v11;
      }
      while (v11);
    }
    if (v8 > 8) {
      sub_1000770BC();
    }
    if (((1 << v8) & 0xFA) != 0)
    {
      uint64_t v15 = *(void *)(a3 + 32);
      if (v15)
      {
        *(void *)(a3 + 32) = v15 - 1;
        uint64_t v16 = *(void *)(a3 + 8);
      }
      else
      {
        uint64_t v16 = 2 * *(void *)(a3 + 8);
      }
      v9 += 2 * v16;
      *(void *)(a3 + 40) = v9;
      int v19 = *(_DWORD *)(a3 + 20) + 2;
    }
    else
    {
      if (((1 << v8) & 0x101) != 0)
      {
        v9 += 2 * *(void *)(a3 + 8);
        *(void *)(a3 + 40) = v9;
        int32x2_t v17 = *(int32x2_t *)(a3 + 20);
        LODWORD(v18) = vadd_s32(v17, (int32x2_t)0x100000001).u32[0];
        HIDWORD(v18) = veor_s8(*(int8x8_t *)&v17, (int8x8_t)0x100000001).i32[1];
        *(void *)(a3 + 20) = v18;
        goto LABEL_16;
      }
      v9 += 2 * *(void *)(a3 + 8);
      *(void *)(a3 + 40) = v9;
      int v19 = *(_DWORD *)(a3 + 20) + 1;
    }
    *(_DWORD *)(a3 + 20) = v19;
LABEL_16:
    unsigned int v20 = *(_DWORD *)(a3 + 80);
    if (v20 > 8) {
      sub_1000770BC();
    }
    int v21 = 1 << v20;
    if ((v21 & 0xFA) != 0)
    {
      uint64_t v22 = *(void *)(a3 + 112);
      if (v22)
      {
        *(void *)(a3 + 112) = v22 - 1;
        uint64_t v23 = *(void *)(a3 + 88);
      }
      else
      {
        uint64_t v23 = 2 * *(void *)(a3 + 88);
      }
      uint64_t result = *(void *)(a3 + 120);
      *(void *)(a3 + 120) = result + 2 * v23;
      int v27 = *(_DWORD *)(a3 + 100) + 2;
    }
    else
    {
      if ((v21 & 0x101) != 0)
      {
        uint64_t result = *(void *)(a3 + 120);
        *(void *)(a3 + 120) = result + 2 * *(void *)(a3 + 88);
        int32x2_t v25 = *(int32x2_t *)(a3 + 100);
        LODWORD(v26) = vadd_s32(v25, (int32x2_t)0x100000001).u32[0];
        HIDWORD(v26) = veor_s8(*(int8x8_t *)&v25, (int8x8_t)0x100000001).i32[1];
        *(void *)(a3 + 100) = v26;
        goto LABEL_25;
      }
      uint64_t result = *(void *)(a3 + 120);
      *(void *)(a3 + 120) = result + 2 * *(void *)(a3 + 88);
      int v27 = *(_DWORD *)(a3 + 100) + 1;
    }
    *(_DWORD *)(a3 + 100) = v27;
LABEL_25:
    if (v10) {
      sub_100077508();
    }
    ++v5;
  }
  while (v5 != a2);
  if (v6)
  {
    unsigned int v28 = 0x80 / a2;
    do
    {
      *a4 = (v28 * (unsigned __int16)*a4) >> 5;
      ++a4;
      *a5 = (v28 * (unsigned __int16)*a5) >> 5;
      ++a5;
      --v6;
    }
    while (v6);
  }
  return result;
}

uint64_t sub_100045A44(uint64_t result, int a2, unint64_t a3, int *a4, _WORD *a5, _WORD *a6)
{
  if (!a3) {
    sub_100077534();
  }
  uint64_t v6 = *(unsigned int *)(result + 20);
  if (v6)
  {
    uint64_t v7 = 0;
    int v8 = *a4;
    uint64_t v9 = *((void *)a4 + 1);
    uint64_t v11 = *((void *)a4 + 8);
    uint64_t v10 = *((void *)a4 + 9);
    int v12 = a4[20];
    uint64_t v13 = *((void *)a4 + 11);
    uint64_t result = a4[32];
    uint64_t v14 = 8 * a2;
    int v15 = a4[12] - a2;
    if (v15 >= 1) {
      int v16 = 0;
    }
    else {
      int v16 = a4[32];
    }
    int v17 = v16 + v15;
    uint64_t v19 = *((void *)a4 + 18);
    uint64_t v18 = *((void *)a4 + 19);
    unsigned int v20 = a6;
    int v21 = a5;
    do
    {
      uint64_t v22 = v18 + -16 * v15;
      if (v15 >= 1) {
        uint64_t v22 = v10 + 2 * v14;
      }
      unint64_t v23 = a3;
      int v24 = v17;
      do
      {
        if (!v24)
        {
          uint64_t v22 = v18;
          int v24 = result;
        }
        *v21 += *(_WORD *)(v22 + 6) >> 2;
        *v20 += *(_WORD *)(v22 + 14) >> 2;
        v22 += 16;
        --v24;
        --v23;
      }
      while (v23);
      if ((v8 - 3) >= 5)
      {
        switch(v8)
        {
          case 0:
          case 2:
          case 8:
            sub_100077140();
          case 1:
            break;
          default:
            sub_100077114();
        }
      }
      if ((v12 - 3) >= 5)
      {
        switch(v12)
        {
          case 0:
          case 2:
          case 8:
            sub_100077140();
          case 1:
            break;
          default:
            sub_100077114();
        }
      }
      v10 += 2 * (v9 << (v11 != 0));
      if (v11-- == 0) {
        uint64_t v11 = 0;
      }
      uint64_t v26 = v19 - 1;
      if (!v19) {
        uint64_t v26 = 0;
      }
      v18 += 2 * (v13 << (v19 != 0));
      ++v21;
      ++v20;
      ++v7;
      uint64_t v19 = v26;
    }
    while (v7 != v6);
    unint64_t v27 = 0x80 / a3;
    do
    {
      *a5 = ((unsigned __int16)*a5 * v27) >> 5;
      ++a5;
      *a6 = ((unsigned __int16)*a6 * v27) >> 5;
      ++a6;
      --v6;
    }
    while (v6);
  }
  return result;
}

uint64_t sub_100045C74(uint64_t result, uint64_t a2, float *a3, float *a4)
{
  uint64_t v4 = 0;
  float v5 = (float)*(unsigned int *)(a2 + 340);
  uint64_t v6 = (float *)(a2 + 8);
  do
  {
    float v7 = *(v6 - 2);
    float v8 = (float)(*(v6 - 1) * v5) - (float)(v7 * v7);
    float v9 = 0.0;
    if (v8 >= 0.0)
    {
      float v10 = *v6;
      float v11 = (float)(v6[2] * v5) - (float)(v10 * v10);
      if (v11 >= 0.0)
      {
        double v12 = (float)((float)(v10 * (float)-v7) + (float)(v6[1] * v5));
        double v13 = sqrt(v8) * sqrt(v11);
        if (v13 == 0.0) {
          double v13 = 1.0;
        }
        float v9 = v12 / v13;
      }
    }
    v49[v4++] = v9;
    v6 += 5;
  }
  while (v4 != 17);
  int v14 = *(_DWORD *)(result + 336) - *(_DWORD *)(result + 332);
  int v15 = v14 + 2;
  if (v14 >= -1) {
    int v15 = v14 + 1;
  }
  int v16 = v15 >> 1;
  if (v14 < 0)
  {
    float v19 = -1.0;
    float v18 = 1.0;
    int v20 = v16;
  }
  else
  {
    uint64_t v17 = 0;
    float v18 = 1.0;
    float v19 = -1.0;
    int v20 = v16;
    do
    {
      float v21 = v49[v17];
      if (v19 < v21)
      {
        int v20 = v17;
        float v19 = v49[v17];
      }
      if (v18 > v21) {
        float v18 = v49[v17];
      }
      ++v17;
    }
    while (v14 + 1 != v17);
  }
  char v22 = *(unsigned char *)(result + 356);
  if (!v22) {
    goto LABEL_46;
  }
  if (v20 > 0xF || ((1 << v20) & 0x8101) == 0)
  {
    float v24 = *(float *)(result + 360);
    if (v20 >= 8) {
      unint64_t v25 = 7;
    }
    else {
      unint64_t v25 = 14;
    }
    if (v20 >= 8) {
      unint64_t v26 = 1;
    }
    else {
      unint64_t v26 = 9;
    }
    unint64_t v27 = &v49[v26];
    BOOL v28 = v25 >= v26;
    unint64_t v29 = v25 - v26;
    if (!v28) {
      unint64_t v29 = 0;
    }
    unint64_t v30 = v29 + 1;
    float v31 = -1.0;
    do
    {
      float v32 = *v27;
      if (v31 < *v27 && *(v27 - 1) < (float)(v24 + v32) && v27[1] < (float)(v24 + v32)) {
        float v31 = *v27;
      }
      ++v27;
      --v30;
    }
    while (v30);
    char v22 = (float)(v19 - v31) < *(float *)(result + 364);
  }
  else
  {
    char v22 = 0;
  }
  BOOL v33 = 0;
  if (v20 < 2 || v20 >= v14 - 1) {
    goto LABEL_47;
  }
  float v34 = v49[v20];
  float v35 = *(float *)(result + 368);
  if (v34 >= (float)(v35 + v49[v20 - 1]) || v34 >= (float)(v35 + v49[v20 + 1]))
  {
LABEL_46:
    BOOL v33 = 0;
    goto LABEL_47;
  }
  if (v34 < (float)(v35 + v49[v20 - 2]))
  {
LABEL_59:
    *a4 = 0.0;
    float v38 = 0.0;
    goto LABEL_64;
  }
  BOOL v33 = v34 < (float)(v35 + v49[v20 + 2]);
LABEL_47:
  if ((float)(v19 - v18) < *(float *)(result + 372) || (v22 & 1) != 0 || v33) {
    goto LABEL_59;
  }
  if (v19 < 0.0) {
    float v19 = 0.0;
  }
  if (v19 > 1.0) {
    float v19 = 1.0;
  }
  *a4 = v19;
  if (v20) {
    BOOL v36 = v20 < v14;
  }
  else {
    BOOL v36 = 0;
  }
  if (v36)
  {
    uint64_t v39 = v20 - 1;
    float v40 = (float)v20;
    uint64_t v41 = v20 + 1;
    float v42 = v49[v39];
    float v43 = v49[v20];
    float v44 = v49[v41];
    float v45 = v43 - v42;
    float v46 = v42 - v44;
    float v47 = v44 - v43;
    float v48 = (float)((float)(v46 * (float)v20) + (float)((float)(int)v41 * v45)) + (float)((float)(int)v39 * v47);
    if (v48 != 0.0) {
      float v40 = (float)((float)((float)((float)(v40 * v40) * v46) + (float)((float)((float)(int)v41 * (float)(int)v41) * v45))
    }
                  + (float)((float)((float)(int)v39 * (float)(int)v39) * v47))
          / (float)(v48 + v48);
    float v37 = v40 - (float)v16;
  }
  else
  {
    float v37 = (float)(v20 - v16);
  }
  float v38 = v37 * -2.0;
LABEL_64:
  *a3 = v38;
  return result;
}

uint64_t sub_100045FB0(uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = 0;
  int32x2_t v4 = 0;
  float v5 = 0.0;
  do
  {
    float v6 = (float)*(unsigned int *)(a2 + v3 * 4);
    float v7 = *(float *)&dword_1000829A0[v3] * v6;
    *(float *)v4.i32 = *(float *)v4.i32 + (float)(v6 - v7);
    float v5 = v5 + v7;
    ++v3;
  }
  while (v3 != 14);
  if (v5 == 0.0) {
    float v8 = 1.0;
  }
  else {
    float v8 = v5;
  }
  float v9 = (float)(*(float *)v4.i32 / v8) + -1.0;
  if (*(float *)v4.i32 == 0.0) {
    float v10 = 1.0;
  }
  else {
    float v10 = *(float *)v4.i32;
  }
  if (v5 <= *(float *)v4.i32) {
    float v11 = 1.0 - (float)(v5 / v10);
  }
  else {
    float v11 = v9;
  }
  if (v11 >= 0.0) {
    float v12 = v11;
  }
  else {
    float v12 = -v11;
  }
  float v13 = 0.0;
  if (v12 > 0.2)
  {
    float v13 = 1.0;
    if (v12 < 0.6) {
      float v13 = (float)(v12 + -0.2) / 0.4;
    }
  }
  uint64_t v14 = 0;
  if (v11 >= 0.0) {
    *(float *)v4.i32 = v13 * *(float *)(result + 36);
  }
  else {
    *(float *)v4.i32 = -(float)(v13 * *(float *)(result + 36));
  }
  float v15 = (float)(*(float *)v4.i32 + 1.0) * 0.5;
  *(float *)v4.i32 = 1.0 - v15;
  float32x4_t v16 = (float32x4_t)vdupq_lane_s32(v4, 0);
  uint64_t v17 = a2 + 116;
  float32x4_t v18 = (float32x4_t)vdupq_n_s32(0x3A800000u);
  int32x4_t v19 = 0uLL;
  v20.i64[0] = 0x7F0000007FLL;
  v20.i64[1] = 0x7F0000007FLL;
  int8x16_t v21 = (int8x16_t)vdupq_n_s32(0x7F800000u);
  __asm { FMOV            V16.4S, #1.0 }
  int32x4_t v27 = 0uLL;
  int32x4_t v28 = 0uLL;
  int32x4_t v29 = 0uLL;
  int32x4_t v30 = 0uLL;
  do
  {
    int32x4_t v31 = *(int32x4_t *)(v17 + v14 * 4 - 112);
    float32x4_t v32 = vmulq_f32(vcvtq_f32_u32((uint32x4_t)v31), v18);
    float32x4_t v33 = (float32x4_t)vbslq_s8((int8x16_t)vceqq_f32(v32, v20), v21, (int8x16_t)vabsq_f32(vsqrtq_f32(v32)));
    float32x4_t v34 = vmulq_f32(vmulq_f32(vcvtq_f32_u32(*(uint32x4_t *)(v17 + v14 * 4 - 56)), vcvtq_f32_u32(*(uint32x4_t *)&dword_100082968[v14 + 1])), (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v33, _Q16), (int8x16_t)_Q16, (int8x16_t)v33));
    int32x4_t v35 = (int32x4_t)vcvtq_u32_f32(v34);
    int32x4_t v36 = (int32x4_t)vcvtq_u32_f32(vmulq_f32(vmlaq_f32(vmulq_n_f32(vsubq_f32(_Q16, *(float32x4_t *)&dword_1000829A0[v14 + 1]), v15), v16, *(float32x4_t *)&dword_1000829A0[v14 + 1]), v34));
    int32x4_t v29 = vaddq_s32(v29, v35);
    int32x4_t v28 = vaddq_s32(v28, v36);
    int32x4_t v30 = vaddq_s32(v31, v30);
    int32x4_t v37 = *(int32x4_t *)(v17 + v14 * 4);
    int32x4_t v27 = vmlaq_s32(v27, v37, v35);
    int32x4_t v19 = vmlaq_s32(v19, v37, v36);
    v14 += 4;
  }
  while (v14 != 12);
  int v38 = vaddvq_s32(v29);
  int v39 = vaddvq_s32(v28);
  int v40 = vaddvq_s32(v27);
  int v41 = vaddvq_s32(v19);
  if (v38) {
    int v40 = 16 * v40 / v38;
  }
  int v42 = v41;
  if (v39) {
    int v42 = 16 * v41 / v39;
  }
  *(unsigned char *)(a3 + 12) = *(unsigned char *)(a2 + 168);
  if (v38)
  {
    *(_DWORD *)a3 = (vaddvq_s32(v30) + 8) >> 4;
    *(_DWORD *)(a3 + 4) = v38;
    *(_DWORD *)(a3 + 8) = v40;
    if (v39)
    {
      if (v42 >= 0) {
        unsigned int v43 = v42;
      }
      else {
        unsigned int v43 = -v42;
      }
      if (v43 >= 0xA1)
      {
        if (v43 < 0x140) {
          *(_DWORD *)(a3 + 8) = (int)(((v43 << 10) - 163840) / 0xA0 * v42 + (1024 - ((v43 << 10) - 163840) / 0xA0) * v40) >> 10;
        }
        else {
          *(_DWORD *)(a3 + 8) = v42;
        }
      }
    }
  }
  else
  {
    *(_DWORD *)(a3 + 8) = 0;
    *(void *)a3 = 0;
  }
  return result;
}

uint64_t sub_100046218(uint64_t result, uint64_t a2)
{
  if (result >= 9) {
    sub_100076A08();
  }
  uint64_t v2 = qword_100082A10[(int)result];
  switch((int)result)
  {
    case 0:
    case 1:
    case 3:
    case 4:
    case 7:
    case 8:
      uint64_t v3 = (unsigned int *)(a2 + 32);
      float v4 = -1.0;
      do
      {
        unsigned int v5 = *(v3 - 4);
        if (v5 && *v3 && *(v3 - 8) >= 0x41)
        {
          float v6 = (float)((float)v5 / (float)*v3) + -1.0;
          if (v6 < 0.0) {
            float v6 = -v6;
          }
          if (v6 > v4 || v4 < 0.0) {
            float v4 = v6;
          }
        }
        ++v3;
        --v2;
      }
      while (v2);
      break;
    case 2:
      return result;
    case 5:
      uint64_t v8 = 0;
      float v9 = -1.0;
      do
      {
        if ((v8 & 0x7FFFFFFD) != 0)
        {
          uint64_t v10 = a2 + 4 * v8;
          unsigned int v11 = *(_DWORD *)(v10 + 16);
          if (v11)
          {
            unsigned int v12 = *(_DWORD *)(v10 + 32);
            if (v12)
            {
              if (*(_DWORD *)(a2 + 4 * v8) >= 0x41u)
              {
                float v13 = (float)((float)v11 / (float)v12) + -1.0;
                if (v13 < 0.0) {
                  float v13 = -v13;
                }
                if (v13 > v9 || v9 < 0.0) {
                  float v9 = v13;
                }
              }
            }
          }
        }
        ++v8;
      }
      while (v2 != v8);
      break;
    case 6:
      uint64_t v15 = 0;
      float v16 = -1.0;
      do
      {
        if ((v15 & 0x7FFFFFFD) != 1)
        {
          uint64_t v17 = a2 + 4 * v15;
          unsigned int v18 = *(_DWORD *)(v17 + 16);
          if (v18)
          {
            unsigned int v19 = *(_DWORD *)(v17 + 32);
            if (v19)
            {
              if (*(_DWORD *)(a2 + 4 * v15) >= 0x41u)
              {
                float v20 = (float)((float)v18 / (float)v19) + -1.0;
                if (v20 < 0.0) {
                  float v20 = -v20;
                }
                if (v20 > v16 || v16 < 0.0) {
                  float v16 = v20;
                }
              }
            }
          }
        }
        ++v15;
      }
      while (v2 != v15);
      break;
    default:
      sub_100077560();
  }
  return result;
}

uint64_t sub_100046430(float *a1, float *a2)
{
  if (*a1 >= *a2) {
    unsigned int v2 = 0;
  }
  else {
    unsigned int v2 = -1;
  }
  if (*a1 > *a2) {
    return 1;
  }
  else {
    return v2;
  }
}

float sub_100046448(uint64_t a1, unint64_t a2, float a3)
{
  if (a2 < 2)
  {
    unint64_t v4 = 1;
  }
  else
  {
    uint64_t v3 = (float *)(a1 + 8);
    unint64_t v4 = 1;
    while (*v3 <= a3)
    {
      ++v4;
      v3 += 2;
      if (a2 == v4)
      {
        unint64_t v4 = a2;
        break;
      }
    }
  }
  if (v4 >= a2 - 1) {
    unint64_t v4 = a2 - 1;
  }
  unsigned int v5 = (float *)(a1 + 8 * v4);
  float v6 = *(v5 - 2);
  if (*v5 == v6) {
    return *(v5 - 1);
  }
  float v8 = (float)(a3 - v6) / (float)(*v5 - v6);
  if (v8 <= 1.0) {
    float v9 = v8;
  }
  else {
    float v9 = 1.0;
  }
  BOOL v10 = v8 < 0.0;
  float v11 = 0.0;
  if (!v10) {
    float v11 = v9;
  }
  return (float)((float)(1.0 - v11) * *(v5 - 1)) + (float)(v11 * v5[1]);
}

uint64_t sub_1000464E4(uint64_t result, int a2, int a3, int a4, int a5, int a6, int a7, float *a8, float a9, unsigned int *a10)
{
  int v10 = *(__int16 *)(result + 712);
  LOWORD(a9) = *(_WORD *)(result + 714);
  float v11 = (float)LODWORD(a9);
  float v12 = (float)(100 - *(_DWORD *)(result + 708)) / 200.0;
  memset(v42, 0, sizeof(v42));
  float v13 = 0.0;
  if (a5 <= a7)
  {
    signed int v14 = a7 + a3;
    unsigned int v15 = a5 + a3;
    unsigned int v16 = a4 + a2;
    int v17 = a6 + a2;
    if (a6 + a2 <= a4 + a2) {
      int v17 = a4 + a2;
    }
    if (v14 <= (int)v15) {
      signed int v14 = a5 + a3;
    }
    do
    {
      if ((v15 & 0x80000000) == 0 && v15 < *(unsigned __int16 *)(result + 34) && a4 <= a6)
      {
        unsigned int v19 = v16;
        do
        {
          if ((v19 & 0x80000000) == 0)
          {
            unsigned int v20 = *(unsigned __int16 *)(result + 32);
            if (v19 < v20)
            {
              uint64_t v21 = 0;
              uint64_t v22 = result + 427308 + 112 * (int)(v19 + v15 * v20);
              do
              {
                *(int32x2_t *)((char *)v42 + v21) = vadd_s32(*(int32x2_t *)((char *)v42 + v21), *(int32x2_t *)(v22 + v21));
                v21 += 8;
              }
              while (v21 != 112);
            }
          }
          BOOL v23 = v19++ == v17;
        }
        while (!v23);
      }
      BOOL v23 = v15++ == v14;
    }
    while (!v23);
    float v13 = (float)DWORD1(v42[0]);
  }
  float v24 = (float)v10;
  float v25 = v11 * 0.000030518;
  float v26 = 1.0 - v12;
  v40[0] = v13;
  uint64_t v27 = 1;
  uint64_t v28 = 12;
  do
  {
    float v13 = v13 + (float)*(unsigned int *)((char *)v42 + v28);
    v40[v27++] = v13;
    v28 += 8;
  }
  while (v27 != 14);
  if (v41 != 0.0)
  {
    for (uint64_t i = 0; i != 14; ++i)
      v40[i] = v40[i] / v41;
  }
  uint64_t v30 = 0;
  __int16 v31 = 0;
  __int16 v32 = 13;
  do
  {
    float v33 = v40[v30];
    if (v33 <= v12 && v40[v30 + 1] > v12) {
      __int16 v31 = v30 + 1;
    }
    if (v33 < v26 && v40[v30 + 1] >= v26) {
      __int16 v32 = v30 + 1;
    }
    ++v30;
  }
  while (v30 != 13);
  if (v31 > v32)
  {
    unsigned int v34 = 0;
LABEL_41:
    float v39 = 0.0;
    goto LABEL_42;
  }
  unsigned int v34 = 0;
  uint64_t v35 = v32 - (uint64_t)v31 + 1;
  int32x4_t v36 = (int *)(((unint64_t)v42 + 8 * v31) | 4);
  float v37 = 0.0;
  do
  {
    float v37 = v37 + (float)*(v36 - 1);
    int v38 = *v36;
    v36 += 2;
    v34 += v38;
    --v35;
  }
  while (v35);
  if (!v34) {
    goto LABEL_41;
  }
  float v39 = -(float)((float)((float)(v37 / (float)v34) + v24) * v25);
LABEL_42:
  *a8 = v39;
  *a10 = v34;
  return result;
}

void sub_100046760(void *a1)
{
  *a1 = off_100096840;
  operator new();
}

void sub_1000467C4()
{
}

void *sub_1000467EC(void *a1)
{
  *a1 = off_100096840;
  uint64_t v2 = a1[1];
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  return a1;
}

void sub_100046858(void *a1)
{
  *a1 = off_100096840;
  uint64_t v1 = a1[1];
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  }

  operator delete();
}

uint64_t sub_1000468E4(uint64_t a1, _DWORD *a2, int64x2_t *a3, double a4, double a5, double a6, double a7)
{
  return sub_100023EA8(a4, a5, a6, a7, a1, *(void **)(a1 + 8), a2, 3, a3);
}

uint64_t sub_1000468F8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return sub_100005280(*(void *)(a1 + 8), a2, a3 + 13048);
}

void *sub_100046908(void *a1, uint64_t a2)
{
  if (objc_opt_class())
  {
    if (!qword_1002BBE18) {
      qword_1002BBE18 = (uint64_t)objc_alloc_init((Class)STMediaStatusDomainPublisher);
    }
    *a1 = a2;
  }
  return a1;
}

CFTypeRef *sub_100046968(CFTypeRef *a1)
{
  if (objc_opt_class())
  {
    [(id)qword_1002BBE18 invalidate];

    qword_1002BBE18 = 0;
    if (*a1)
    {
      CFRelease(*a1);
      *a1 = 0;
    }
  }
  return a1;
}

void *sub_1000469CC(void *result, uint64_t a2)
{
  *uint64_t result = a2;
  return result;
}

void *sub_1000469D4(void *result)
{
  if (*result) {
    *uint64_t result = 0;
  }
  return result;
}

uint64_t sub_1000469E4(uint64_t *a1)
{
  uint64_t v5 = 0;
  memset(outputStruct, 0, sizeof(outputStruct));
  uint64_t v1 = sub_100054E78(*a1, outputStruct);
  if (!v1)
  {
    if (analytics_send_event_lazy())
    {
      return 0;
    }
    else
    {
      os_log_t v2 = (os_log_t)off_1002BBCB8;
      if (off_1002BBCB8 == &_os_log_default)
      {
        os_log_t v2 = os_log_create("com.apple.isp", "general");
        off_1002BBCB8 = v2;
      }
      uint64_t v1 = 3758097084;
      if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR)) {
        sub_10007758C();
      }
    }
  }
  return v1;
}

void *sub_100046AF8(uint64_t *a1)
{
  xpc_object_t v2 = xpc_dictionary_create(0, 0, 0);
  uint64_t v3 = v2;
  if (v2)
  {
    xpc_dictionary_set_uint64(v2, "Successful_ISPStart", a1[4]);
    xpc_dictionary_set_uint64(v3, "Successful_ISPResumes", a1[5]);
    xpc_dictionary_set_uint64(v3, "Successful_ISPSuspends", a1[6]);
    xpc_dictionary_set_uint64(v3, "TotalISPPowerOn", a1[5] + a1[4]);
    xpc_dictionary_set_uint64(v3, "Failed_ISPResumes", a1[7]);
    xpc_dictionary_set_uint64(v3, "Failed_ISPSuspends", a1[8]);
  }
  return v3;
}

uint64_t sub_100046BB0()
{
  if (analytics_send_event_lazy()) {
    return 0;
  }
  os_log_t v1 = (os_log_t)off_1002BBCB8;
  if (off_1002BBCB8 == &_os_log_default)
  {
    os_log_t v1 = os_log_create("com.apple.isp", "general");
    off_1002BBCB8 = v1;
  }
  uint64_t v0 = 3758097084;
  if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR)) {
    sub_100077604();
  }
  return v0;
}

void *sub_100046C98(unsigned int *a1)
{
  xpc_object_t v2 = xpc_dictionary_create(0, 0, 0);
  uint64_t v3 = v2;
  if (v2)
  {
    xpc_dictionary_set_uint64(v2, "FlickerDC", a1[8]);
    xpc_dictionary_set_uint64(v3, "Flicker50Hz", a1[9]);
    xpc_dictionary_set_uint64(v3, "Flicker60Hz", a1[10]);
    xpc_dictionary_set_uint64(v3, "FlickerUnder100Hz", a1[11]);
    xpc_dictionary_set_uint64(v3, "FlickerUnder300Hz", a1[12]);
    xpc_dictionary_set_uint64(v3, "FlickerUnder500Hz", a1[13]);
    xpc_dictionary_set_uint64(v3, "FlickerOver500Hz", a1[14]);
    xpc_dictionary_set_uint64(v3, "FlickerInvalid", a1[15]);
  }
  return v3;
}

uint64_t sub_100046D74()
{
  uint64_t v0 = (uint64_t *)__chkstk_darwin();
  uint64_t v1 = *(void *)(*v0 + 4384);
  if (v1 && !*(unsigned char *)(v1 + 592)) {
    return 0;
  }
  uint64_t v2 = sub_100054E28(*v0, __src);
  if (!v2)
  {
    unint64_t v3 = 0;
    unint64_t v4 = v13;
    v13[0] = 0;
    v13[2] = 0;
    v13[4] = 0;
    v13[6] = 0;
    float v12 = sub_100046F60;
    v13[1] = sub_1000471E4;
    v13[3] = sub_1000472CC;
    void v13[5] = sub_1000474BC;
    v13[7] = sub_1000475C4;
    v13[8] = 0;
    do
    {
      uint64_t v5 = (uint64_t (*)(void *, unsigned char *))*(v4 - 1);
      float v6 = (uint64_t *)((char *)v0 + (*v4 >> 1));
      if (*v4) {
        uint64_t v5 = *(uint64_t (**)(void *, unsigned char *))(*v6 + v5);
      }
      memcpy(v10, __src, sizeof(v10));
      char v7 = v5(v6, v10);
      if (v3 > 3) {
        break;
      }
      v4 += 2;
      ++v3;
    }
    while ((v7 & 1) != 0);
    if (v7) {
      return 0;
    }
    os_log_t v8 = (os_log_t)off_1002BBCB8;
    if (off_1002BBCB8 == &_os_log_default)
    {
      os_log_t v8 = os_log_create("com.apple.isp", "general");
      off_1002BBCB8 = v8;
    }
    uint64_t v2 = 3758097084;
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR)) {
      sub_10007767C(v8);
    }
  }
  return v2;
}

uint64_t sub_100046F60()
{
  __chkstk_darwin();
  uint64_t v1 = v0;
  float v9 = _NSConcreteStackBlock;
  uint64_t v10 = 0x40000000;
  float v11 = sub_100047D64;
  float v12 = &unk_100096908;
  memcpy(v13, v0, sizeof(v13));
  uint64_t v2 = analytics_send_event_lazy();
  if ((v2 & 1) == 0)
  {
    os_log_t v3 = (os_log_t)off_1002BBCB8;
    if (off_1002BBCB8 == &_os_log_default)
    {
      os_log_t v3 = os_log_create("com.apple.isp", "general");
      off_1002BBCB8 = v3;
    }
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR)) {
      sub_1000776F8();
    }
  }
  if (v1[396])
  {
    unsigned int v4 = 0;
    do
    {
      memcpy(v7, v1, sizeof(v7));
      unsigned int v8 = v4;
      uint64_t v2 = analytics_send_event_lazy();
      if ((v2 & 1) == 0)
      {
        os_log_t v5 = (os_log_t)off_1002BBCB8;
        if (off_1002BBCB8 == &_os_log_default)
        {
          os_log_t v5 = os_log_create("com.apple.isp", "general");
          off_1002BBCB8 = v5;
        }
        if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136315650;
          unsigned int v15 = "com.apple.applecamerad.ProjectorUsage";
          __int16 v16 = 1024;
          unsigned int v17 = v4;
          __int16 v18 = 1024;
          int v19 = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "Failed to send the %s event number %d into the diagnostics system %08X\n\n", buf, 0x18u);
        }
      }
      ++v4;
    }
    while (v4 < v1[396]);
  }
  return v2;
}

uint64_t sub_1000471E4(uint64_t a1, const void *a2)
{
  memcpy(v5, a2, sizeof(v5));
  uint64_t v2 = analytics_send_event_lazy();
  if ((v2 & 1) == 0)
  {
    os_log_t v3 = (os_log_t)off_1002BBCB8;
    if (off_1002BBCB8 == &_os_log_default)
    {
      os_log_t v3 = os_log_create("com.apple.isp", "general");
      off_1002BBCB8 = v3;
    }
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR)) {
      sub_100077770();
    }
  }
  return v2;
}

uint64_t sub_1000472CC(uint64_t a1, uint64_t a2)
{
  unint64_t v3 = 0;
  BOOL v4 = 0;
  while (1)
  {
    uint64_t v5 = a2 + 4 * v3;
    if (*(_DWORD *)(v5 + 1520)) {
      break;
    }
LABEL_6:
    BOOL v4 = v3++ > 2;
    if (v3 == 4)
    {
      char v8 = 1;
      return v8 & 1;
    }
  }
  char v11 = v4;
  int v6 = 0;
  char v7 = (_DWORD *)(v5 + 1520);
  while ((analytics_send_event_lazy() & 1) != 0)
  {
    if (++v6 >= *v7) {
      goto LABEL_6;
    }
  }
  os_log_t v9 = (os_log_t)off_1002BBCB8;
  if (off_1002BBCB8 == &_os_log_default)
  {
    os_log_t v9 = os_log_create("com.apple.isp", "general");
    off_1002BBCB8 = v9;
  }
  if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR)) {
    sub_1000777E8();
  }
  char v8 = v11;
  return v8 & 1;
}

BOOL sub_1000474BC(uint64_t a1, _DWORD *a2)
{
  int v2 = a2[377] + a2[379] + a2[378];
  if (!v2) {
    return 1;
  }
  memcpy(v5, a2, sizeof(v5));
  int v6 = v2;
  if (analytics_send_event_lazy()) {
    return 1;
  }
  os_log_t v4 = (os_log_t)off_1002BBCB8;
  if (off_1002BBCB8 == &_os_log_default)
  {
    os_log_t v4 = os_log_create("com.apple.isp", "general");
    off_1002BBCB8 = v4;
  }
  BOOL result = os_log_type_enabled(v4, OS_LOG_TYPE_ERROR);
  if (result)
  {
    sub_100077860();
    return 0;
  }
  return result;
}

BOOL sub_1000475C4(int a1, _DWORD *__src)
{
  unsigned int v2 = __src[8];
  if (v2 > 0x78) {
    return 0;
  }
  if (!v2) {
    return 1;
  }
  int v5 = 0;
  while (1)
  {
    memcpy(v7, __src, sizeof(v7));
    int v8 = v5;
    if ((analytics_send_event_lazy() & 1) == 0) {
      break;
    }
    if (++v5 >= __src[8]) {
      return 1;
    }
  }
  os_log_t v6 = (os_log_t)off_1002BBCB8;
  if (off_1002BBCB8 == &_os_log_default)
  {
    os_log_t v6 = os_log_create("com.apple.isp", "general");
    off_1002BBCB8 = v6;
  }
  BOOL result = os_log_type_enabled(v6, OS_LOG_TYPE_ERROR);
  if (result)
  {
    sub_1000778D8();
    return 0;
  }
  return result;
}

uint64_t sub_10004770C(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = 0;
  for (uint64_t i = 8; !*(_DWORD *)(a2 + i) || (analytics_send_event_lazy() & 1) != 0; i += 12)
  {
    if (++v3 == 6) {
      return 0;
    }
  }
  os_log_t v6 = (os_log_t)off_1002BBCB8;
  if (off_1002BBCB8 == &_os_log_default)
  {
    os_log_t v6 = os_log_create("com.apple.isp", "general");
    off_1002BBCB8 = v6;
  }
  uint64_t v5 = 3758097084;
  if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR)) {
    sub_100077950();
  }
  return v5;
}

void *sub_10004783C(uint64_t a1)
{
  xpc_object_t v2 = xpc_dictionary_create(0, 0, 0);
  uint64_t v3 = v2;
  if (v2)
  {
    xpc_dictionary_set_uint64(v2, "ChannelNum", *(unsigned int *)(a1 + 40));
    xpc_dictionary_set_uint64(v3, "SIF_Errors", *(unsigned int *)(*(void *)(a1 + 32) + 12 * *(unsigned int *)(a1 + 40)));
    xpc_dictionary_set_uint64(v3, "Dropped_Frame_Count", *(unsigned int *)(*(void *)(a1 + 32) + 12 * *(unsigned int *)(a1 + 40) + 4));
    xpc_dictionary_set_uint64(v3, "Streamed_Frame_Count", *(unsigned int *)(*(void *)(a1 + 32) + 12 * *(unsigned int *)(a1 + 40) + 8));
  }
  return v3;
}

uint64_t sub_1000478F8()
{
  int v0 = 0;
  while ((analytics_send_event_lazy() & 1) != 0)
  {
    if (++v0 == 6) {
      return 0;
    }
  }
  os_log_t v1 = (os_log_t)off_1002BBCB8;
  if (off_1002BBCB8 == &_os_log_default)
  {
    os_log_t v1 = os_log_create("com.apple.isp", "general");
    off_1002BBCB8 = v1;
  }
  if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR)) {
    sub_1000779C8();
  }
  return 0;
}

void *sub_100047A0C(uint64_t a1)
{
  xpc_object_t v2 = xpc_dictionary_create(0, 0, 0);
  uint64_t v3 = v2;
  if (v2)
  {
    xpc_dictionary_set_uint64(v2, "ChannelNum", *(unsigned int *)(a1 + 40));
    xpc_dictionary_set_uint64(v3, "ChannelStreamingDurationinMS", *(void *)(*(void *)(a1 + 32) + 56 * *(unsigned int *)(a1 + 40) + 48));
    xpc_dictionary_set_uint64(v3, "MotionControlFaultStatus", *(unsigned int *)(*(void *)(a1 + 32) + 56 * *(unsigned int *)(a1 + 40)));
    xpc_dictionary_set_uint64(v3, "AFandOISControlFaultStatus", *(unsigned int *)(*(void *)(a1 + 32) + 56 * *(unsigned int *)(a1 + 40) + 4));
    uint64_t v4 = *(void *)(a1 + 32);
    unsigned int v5 = *(_DWORD *)(a1 + 40);
    if (*(unsigned char *)(v4 + 56 * v5 + 8))
    {
      xpc_dictionary_set_uint64(v3, "AFComplianceFlagCount", *(unsigned int *)(v4 + 56 * v5 + 12));
      xpc_dictionary_set_uint64(v3, "OISComplianceFlagCount", *(unsigned int *)(*(void *)(a1 + 32) + 56 * *(unsigned int *)(a1 + 40) + 16));
      xpc_dictionary_set_double(v3, "coilTempEstB1Max", *(float *)(*(void *)(a1 + 32) + 56 * *(unsigned int *)(a1 + 40) + 20));
      xpc_dictionary_set_double(v3, "coilTempEstB2Max", *(float *)(*(void *)(a1 + 32) + 56 * *(unsigned int *)(a1 + 40) + 24));
      xpc_dictionary_set_double(v3, "coilTempEstB3Max", *(float *)(*(void *)(a1 + 32) + 56 * *(unsigned int *)(a1 + 40) + 28));
      xpc_dictionary_set_double(v3, "coilTempEstB1Mean", *(float *)(*(void *)(a1 + 32) + 56 * *(unsigned int *)(a1 + 40) + 32));
      xpc_dictionary_set_double(v3, "coilTempEstB2Mean", *(float *)(*(void *)(a1 + 32) + 56 * *(unsigned int *)(a1 + 40) + 36));
      xpc_dictionary_set_double(v3, "coilTempEstB3Mean", *(float *)(*(void *)(a1 + 32) + 56 * *(unsigned int *)(a1 + 40) + 40));
    }
  }
  return v3;
}

uint64_t sub_100047BF0(uint64_t *a1)
{
  uint64_t v1 = sub_100055000(*a1, &outputStruct);
  if (!v1)
  {
    if (analytics_send_event_lazy())
    {
      return 0;
    }
    else
    {
      os_log_t v2 = (os_log_t)off_1002BBCB8;
      if (off_1002BBCB8 == &_os_log_default)
      {
        os_log_t v2 = os_log_create("com.apple.isp", "general");
        off_1002BBCB8 = v2;
      }
      uint64_t v1 = 3758097084;
      if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR)) {
        sub_100077A40(v2);
      }
    }
  }
  return v1;
}

void *sub_100047CEC(uint64_t a1)
{
  xpc_object_t v2 = xpc_dictionary_create(0, 0, 0);
  uint64_t v3 = v2;
  if (v2)
  {
    xpc_dictionary_set_uint64(v2, "SpmiInterface0ErrCount", *(unsigned int *)(a1 + 32));
    xpc_dictionary_set_uint64(v3, "SpmiInterface1ErrCount", *(unsigned int *)(a1 + 36));
    xpc_dictionary_set_uint64(v3, "CameraPowerOnDurationInMS", *(void *)(a1 + 40));
  }
  return v3;
}

void *sub_100047D64(_DWORD *a1)
{
  xpc_object_t v2 = xpc_dictionary_create(0, 0, 0);
  uint64_t v4 = v2;
  if (v2)
  {
    LODWORD(v3) = a1[8];
    xpc_dictionary_set_uint64(v2, "Dense_High_Power", (unint64_t)((double)v3 * 0.001));
    LODWORD(v5) = a1[9];
    xpc_dictionary_set_uint64(v4, "Dense_Low_Power", (unint64_t)((double)v5 * 0.001));
    LODWORD(v6) = a1[10];
    xpc_dictionary_set_uint64(v4, "Sparse_High_Power", (unint64_t)((double)v6 * 0.001));
    LODWORD(v7) = a1[11];
    xpc_dictionary_set_uint64(v4, "Sparse_Low_Power", (unint64_t)((double)v7 * 0.001));
    LODWORD(v8) = a1[12];
    xpc_dictionary_set_uint64(v4, "Flood_Output_Duration", (unint64_t)((double)v8 * 0.001));
    LODWORD(v9) = a1[13];
    xpc_dictionary_set_uint64(v4, "ProbeA", (unint64_t)((double)v9 * 0.001));
    LODWORD(v10) = a1[14];
    xpc_dictionary_set_uint64(v4, "ProbeB", (unint64_t)((double)v10 * 0.001));
    LODWORD(v11) = a1[15];
    xpc_dictionary_set_uint64(v4, "Standby_Time", (unint64_t)((double)v11 * 0.001));
  }
  return v4;
}

void *sub_100047EB0(uint64_t a1)
{
  xpc_object_t v2 = xpc_dictionary_create(0, 0, 0);
  uint64_t v4 = v2;
  if (v2)
  {
    LODWORD(v3) = *(_DWORD *)(a1 + 32 + 4 * *(unsigned int *)(a1 + 3060) + 1588);
    xpc_dictionary_set_uint64(v2, "Flood_Avg_Exposure", (unint64_t)((double)v3 * 0.001));
    xpc_dictionary_set_double(v4, "Flood_Avg_Temp", *(float *)(a1 + 32 + 4 * *(unsigned int *)(a1 + 3060) + 2068));
    xpc_dictionary_set_double(v4, "Flood_Min_Temp", *(float *)(a1 + 32 + 4 * *(unsigned int *)(a1 + 3060) + 2548));
  }
  return v4;
}

void *sub_100047F68(unsigned int *a1)
{
  xpc_object_t v2 = xpc_dictionary_create(0, 0, 0);
  unint64_t v3 = v2;
  if (v2)
  {
    xpc_dictionary_set_uint64(v2, "Rigel_Faults", a1[377]);
    xpc_dictionary_set_uint64(v3, "Rigel_LVT_Faults", a1[378]);
    xpc_dictionary_set_uint64(v3, "Rigel_UVLO_Faults", a1[379]);
    xpc_dictionary_set_uint64(v3, "Mama_Bear_Faults", a1[380]);
    xpc_dictionary_set_uint64(v3, "Yogi_Faults", a1[381]);
    xpc_dictionary_set_uint64(v3, "Bane_Faults", a1[394]);
    xpc_dictionary_set_uint64(v3, "Bane_Temperature_Low_Faults", a1[401]);
    xpc_dictionary_set_uint64(v3, "Bane_Temperature_High_Faults", a1[402]);
    xpc_dictionary_set_uint64(v3, "Bane_Trace_Resistance_Hard_Low_Faults", a1[395]);
    xpc_dictionary_set_uint64(v3, "Bane_Trace_Resistance_Hard_High_Faults", a1[396]);
    xpc_dictionary_set_uint64(v3, "Bane_Trace_Resistance_Intermediate_Low_Faults", a1[397]);
    xpc_dictionary_set_uint64(v3, "Bane_Trace_Resistance_Intermediate_High_Faults", a1[398]);
    xpc_dictionary_set_uint64(v3, "Bane_Trace_Resistance_OutOfRange_Low_Faults", a1[399]);
    xpc_dictionary_set_uint64(v3, "Bane_Trace_Resistance_OutOfRange_High_Faults", a1[400]);
    xpc_dictionary_set_uint64(v3, "Romeo_Fail_Status", a1[403]);
  }
  return v3;
}

void *sub_1000480D0(uint64_t a1)
{
  xpc_object_t v2 = xpc_dictionary_create(0, 0, 0);
  unint64_t v3 = v2;
  if (v2)
  {
    xpc_dictionary_set_string(v2, "Fault_Transition_Type", *(const char **)(a1 + 32));
    xpc_dictionary_set_uint64(v3, "MamaBear_Capacitance_Value", *(unsigned int *)(a1 + 40));
  }
  return v3;
}

void *sub_100048134(unsigned int *a1)
{
  xpc_object_t v2 = xpc_dictionary_create(0, 0, 0);
  unint64_t v3 = v2;
  if (v2)
  {
    xpc_dictionary_set_uint64(v2, "BufferInUseHighWaterMark", a1[383]);
    xpc_dictionary_set_uint64(v3, "TotalBuffersInPool", a1[384]);
    xpc_dictionary_set_uint64(v3, "TotalFaceIDAttempts", a1[765]);
  }
  return v3;
}

void *sub_1000481AC(uint64_t a1)
{
  xpc_object_t v2 = xpc_dictionary_create(0, 0, 0);
  unint64_t v3 = v2;
  if (v2)
  {
    xpc_dictionary_set_uint64(v2, "ROI_TopLeft", *(int *)(a1 + 64 + 4 * *(unsigned int *)(a1 + 3060) + 4));
    xpc_dictionary_set_uint64(v3, "ROI_BottomLeft", *(int *)(a1 + 64 + 4 * *(unsigned int *)(a1 + 3060) + 484));
    xpc_dictionary_set_uint64(v3, "ROI_TopMid", *(int *)(a1 + 64 + 4 * *(unsigned int *)(a1 + 3060) + 964));
  }
  return v3;
}

uint64_t sub_10004825C(int a1, char *__s, unsigned int a3, char *a4)
{
  size_t v7 = strlen(__s);
  if (v7 != a3) {
    return 0;
  }
  size_t v8 = v7;
  if (strstr(__s, "./")) {
    return 0;
  }
  unint64_t v10 = strstr(__s, "../");
  uint64_t result = 0;
  if (a3 <= 0xC0 && !v10)
  {
    if (!a4) {
      operator new[]();
    }
    strcpy(a4, "/private/var/mobile/Media/DCIM");
    if (*__s != 47) {
      *(_WORD *)&a4[strlen(a4)] = 47;
    }
    strncat(a4, __s, v8);
    return 1;
  }
  return result;
}

uint64_t sub_100048348(uint64_t a1, uint64_t a2, int a3)
{
  if (a3 == 1)
  {
    if (*(void *)(a2 + 8) == 208) {
      operator new[]();
    }
    os_log_t v4 = (os_log_t)off_1002BBCC0;
    if (off_1002BBCC0 == &_os_log_default)
    {
      os_log_t v4 = os_log_create("com.apple.isp", "general");
      off_1002BBCC0 = v4;
    }
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR)) {
      sub_100077BBC();
    }
  }
  else
  {
    os_log_t v3 = (os_log_t)off_1002BBCC0;
    if (off_1002BBCC0 == &_os_log_default)
    {
      os_log_t v3 = os_log_create("com.apple.isp", "general");
      off_1002BBCC0 = v3;
    }
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR)) {
      sub_100077C34();
    }
  }
  return 3;
}

uint64_t sub_100048578(uint64_t a1, uint64_t a2, int a3)
{
  if (a3 == 2)
  {
    if (*(void *)(a2 + 8) == 208) {
      operator new[]();
    }
    os_log_t v4 = (os_log_t)off_1002BBCC0;
    if (off_1002BBCC0 == &_os_log_default)
    {
      os_log_t v4 = os_log_create("com.apple.isp", "general");
      off_1002BBCC0 = v4;
    }
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR)) {
      sub_100077ED0();
    }
  }
  else
  {
    os_log_t v3 = (os_log_t)off_1002BBCC0;
    if (off_1002BBCC0 == &_os_log_default)
    {
      os_log_t v3 = os_log_create("com.apple.isp", "general");
      off_1002BBCC0 = v3;
    }
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR)) {
      sub_100077F48();
    }
  }
  return 3;
}

uint64_t sub_10004897C(uint64_t a1, uint64_t a2, int a3)
{
  if (a3 == 2)
  {
    if (*(void *)(a2 + 8) == 208) {
      operator new[]();
    }
    os_log_t v4 = (os_log_t)off_1002BBCC0;
    if (off_1002BBCC0 == &_os_log_default)
    {
      os_log_t v4 = os_log_create("com.apple.isp", "general");
      off_1002BBCC0 = v4;
    }
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR)) {
      sub_1000781D8();
    }
  }
  else
  {
    os_log_t v3 = (os_log_t)off_1002BBCC0;
    if (off_1002BBCC0 == &_os_log_default)
    {
      os_log_t v3 = os_log_create("com.apple.isp", "general");
      off_1002BBCC0 = v3;
    }
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR)) {
      sub_100078250();
    }
  }
  return 3;
}

uint64_t sub_100048D90(uint64_t a1, uint64_t *a2, int a3)
{
  if (a3 != 2)
  {
    os_log_t v4 = (os_log_t)off_1002BBCC0;
    if (off_1002BBCC0 == &_os_log_default)
    {
      os_log_t v4 = os_log_create("com.apple.isp", "general");
      off_1002BBCC0 = v4;
    }
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR)) {
      sub_100078338();
    }
    return 3;
  }
  if ((unint64_t)a2[4] <= 0x7EF93)
  {
    os_log_t v3 = (os_log_t)off_1002BBCC0;
    if (off_1002BBCC0 == &_os_log_default)
    {
      os_log_t v3 = os_log_create("com.apple.isp", "general");
      off_1002BBCC0 = v3;
    }
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR)) {
      sub_1000782C4();
    }
    return 3;
  }
  sub_10003BF48(*a2, a2[3]);
  return 0;
}

uint64_t sub_100048E9C(uint64_t a1, uint64_t a2, int a3)
{
  if (a3 != 3)
  {
    os_log_t v4 = (os_log_t)off_1002BBCC0;
    if (off_1002BBCC0 == &_os_log_default)
    {
      os_log_t v4 = os_log_create("com.apple.isp", "general");
      off_1002BBCC0 = v4;
    }
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR)) {
      sub_100078420();
    }
    return 3;
  }
  if (*(void *)(a2 + 56) <= 0x7EF93uLL)
  {
    os_log_t v3 = (os_log_t)off_1002BBCC0;
    if (off_1002BBCC0 == &_os_log_default)
    {
      os_log_t v3 = os_log_create("com.apple.isp", "general");
      off_1002BBCC0 = v3;
    }
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR)) {
      sub_1000783AC();
    }
    return 3;
  }
  sub_10003EA84(*(void *)a2, *(void *)(a2 + 24), *(_DWORD **)(a2 + 48));
  return 0;
}

uint64_t sub_100048FAC(uint64_t a1, uint64_t a2, int a3)
{
  if (a3 == 4)
  {
    if (*(void *)(a2 + 80) > 0x7EF93uLL) {
      sub_10003EB58(*(void *)a2, *(void *)(a2 + 24), *(void *)(a2 + 48), *(_DWORD **)(a2 + 72));
    }
    os_log_t v3 = (os_log_t)off_1002BBCC0;
    if (off_1002BBCC0 == &_os_log_default)
    {
      os_log_t v3 = os_log_create("com.apple.isp", "general");
      off_1002BBCC0 = v3;
    }
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR)) {
      sub_100078494();
    }
  }
  else
  {
    os_log_t v4 = (os_log_t)off_1002BBCC0;
    if (off_1002BBCC0 == &_os_log_default)
    {
      os_log_t v4 = os_log_create("com.apple.isp", "general");
      off_1002BBCC0 = v4;
    }
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR)) {
      sub_100078508();
    }
  }
  return 3;
}

uint64_t sub_1000490C0(uint64_t a1, uint64_t a2, int a3)
{
  if (a3 == 5)
  {
    if (*(void *)(a2 + 104) > 0x7EF93uLL) {
      sub_10003EC70(*(void *)a2, *(void *)(a2 + 24), *(void *)(a2 + 48), *(void *)(a2 + 72), *(_DWORD **)(a2 + 96));
    }
    os_log_t v3 = (os_log_t)off_1002BBCC0;
    if (off_1002BBCC0 == &_os_log_default)
    {
      os_log_t v3 = os_log_create("com.apple.isp", "general");
      off_1002BBCC0 = v3;
    }
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR)) {
      sub_10007857C();
    }
  }
  else
  {
    os_log_t v4 = (os_log_t)off_1002BBCC0;
    if (off_1002BBCC0 == &_os_log_default)
    {
      os_log_t v4 = os_log_create("com.apple.isp", "general");
      off_1002BBCC0 = v4;
    }
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR)) {
      sub_1000785F0();
    }
  }
  return 3;
}

uint64_t sub_1000491D8(uint64_t a1, uint64_t a2, int a3)
{
  memset(v11, 0, sizeof(v11));
  if (a3 == 4)
  {
    uint64_t v3 = 0;
    unint64_t v5 = (uint64_t *)(a2 + 24);
    os_log_t v4 = *(int **)a2;
    do
    {
      uint64_t v6 = *v5;
      v5 += 3;
      v11[v3++] = v6;
    }
    while (v3 != 3);
    if (*(void *)(a2 + 8) == 591796)
    {
      sub_100021274(v4, (uint64_t)v11);
      return 0;
    }
    os_log_t v10 = (os_log_t)off_1002BBCC0;
    if (off_1002BBCC0 == &_os_log_default)
    {
      os_log_t v10 = os_log_create("com.apple.isp", "general");
      off_1002BBCC0 = v10;
    }
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR)) {
      sub_100078664();
    }
  }
  else
  {
    os_log_t v9 = (os_log_t)off_1002BBCC0;
    if (off_1002BBCC0 == &_os_log_default)
    {
      os_log_t v9 = os_log_create("com.apple.isp", "general");
      off_1002BBCC0 = v9;
    }
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR)) {
      sub_1000786EC(a3, v9);
    }
  }
  return 3;
}

uint64_t sub_100049338(uint64_t a1, uint64_t a2, int a3)
{
  if (a3 != 2)
  {
    os_log_t v4 = (os_log_t)off_1002BBCC0;
    if (off_1002BBCC0 == &_os_log_default)
    {
      os_log_t v4 = os_log_create("com.apple.isp", "general");
      off_1002BBCC0 = v4;
    }
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR)) {
      sub_100078810();
    }
    return 3;
  }
  if (*(void *)(a2 + 8) <= 0x10008FuLL)
  {
    os_log_t v3 = (os_log_t)off_1002BBCC0;
    if (off_1002BBCC0 == &_os_log_default)
    {
      os_log_t v3 = os_log_create("com.apple.isp", "general");
      off_1002BBCC0 = v3;
    }
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR)) {
      sub_100078784();
    }
    return 3;
  }
  sub_1000241B8(*(int **)a2, *(void *)(a2 + 24));
  return 0;
}

uint64_t sub_100049440(uint64_t a1, uint64_t a2, unsigned char *a3)
{
  int v4 = byte_1002BBE20;
  if (*(_DWORD *)(a2 + 32))
  {
    unint64_t v7 = 0;
    size_t v8 = (uint64_t *)(a2 + 488);
    os_log_t v9 = (int *)(a2 + 48);
    do
    {
      int v10 = v9[10];
      if (v4)
      {
        unint64_t v11 = *(void **)(a1 + 8 * *(v9 - 3));
        if (v11) {
          sub_100028F08(v11);
        }
      }
      *a3 = 0;
      uint64_t v12 = kdebug_trace();
      int v13 = 5;
      switch(*(v9 - 3))
      {
        case 4:
          int v14 = sub_100048348(v12, (uint64_t)v8, v10);
          goto LABEL_10;
        case 5:
          int v14 = sub_100048578(v12, (uint64_t)v8, v10);
          goto LABEL_10;
        case 6:
          int v14 = sub_10004897C(v12, (uint64_t)v8, v10);
LABEL_10:
          int v13 = v14;
          *a3 = 1;
          break;
        case 13:
          if (!*(void *)(a1 + 168)) {
            operator new();
          }
          int v13 = sub_10004B098();
          *os_log_t v9 = v13;
          break;
        case 14:
          int v15 = sub_100048D90(v12, v8, v10);
          goto LABEL_20;
        case 15:
          int v15 = sub_100048E9C(v12, (uint64_t)v8, v10);
          goto LABEL_20;
        case 16:
          int v15 = sub_100048FAC(v12, (uint64_t)v8, v10);
          goto LABEL_20;
        case 17:
          int v15 = sub_1000490C0(v12, (uint64_t)v8, v10);
          goto LABEL_20;
        case 18:
          int v15 = sub_1000491D8(v12, (uint64_t)v8, v10);
          goto LABEL_20;
        case 19:
          int v15 = sub_100049338(v12, (uint64_t)v8, v10);
LABEL_20:
          int v13 = v15;
          break;
        default:
          break;
      }
      kdebug_trace();
      *os_log_t v9 = v13;
      int v4 = byte_1002BBE20;
      if (byte_1002BBE20)
      {
        __int16 v16 = *(uint64_t **)(a1 + 8 * *(v9 - 3));
        if (v16)
        {
          sub_100028F40(v16);
          int v4 = byte_1002BBE20;
        }
        else
        {
          int v4 = 1;
        }
      }
      ++*(_DWORD *)(a1 + 160);
      ++v7;
      v8 += 24;
      v9 += 14;
    }
    while (v7 < *(unsigned int *)(a2 + 32));
  }
  if (v4 && *(_DWORD *)(a1 + 160) >= 0x400u)
  {
    os_log_t v17 = (os_log_t)off_1002BBCC0;
    if (off_1002BBCC0 == &_os_log_default)
    {
      os_log_t v17 = os_log_create("com.apple.isp", "general");
      off_1002BBCC0 = v17;
    }
    if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "*** Metrics report for firmware work processor ***\n", buf, 2u);
    }
    for (uint64_t i = 0; i != 20; ++i)
    {
      if (*(void *)(a1 + 8 * i))
      {
        os_log_t v19 = (os_log_t)off_1002BBCC0;
        if (off_1002BBCC0 == &_os_log_default)
        {
          os_log_t v19 = os_log_create("com.apple.isp", "general");
          off_1002BBCC0 = v19;
        }
        if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 67109120;
          int v23 = i;
          _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "*** Metrics for command %d ***\n", buf, 8u);
        }
        sub_10002913C(*(_DWORD **)(a1 + 8 * i));
      }
    }
    os_log_t v20 = (os_log_t)off_1002BBCC0;
    if (off_1002BBCC0 == &_os_log_default)
    {
      os_log_t v20 = os_log_create("com.apple.isp", "general");
      off_1002BBCC0 = v20;
    }
    if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "*** End report ***\n", buf, 2u);
    }
    *(_DWORD *)(a1 + 160) = 0;
  }
  return 0;
}

void sub_100049820()
{
}

uint64_t sub_10004988C(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(a1 + 160) = 0;
  *(void *)(a1 + 168) = 0;
  *(void *)(a1 + 176) = a2;
  int v3 = sub_100022CF0(@"FirmwareWorkMetrics", @"com.apple.coremedia", 0);
  byte_1002BBE20 = v3 != 0;
  if (v3) {
    operator new();
  }
  return a1;
}

void sub_100049924()
{
}

uint64_t sub_10004994C(uint64_t a1)
{
  if (byte_1002BBE20)
  {
    for (uint64_t i = 0; i != 160; i += 8)
    {
      int v3 = *(void **)(a1 + i);
      if (v3)
      {
        sub_1000294F8(v3);
        operator delete();
      }
    }
  }
  if (*(void *)(a1 + 168))
  {
    sub_10004B094();
    operator delete();
  }
  return a1;
}

void sub_100049A30(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_error_impl(a1, a2, OS_LOG_TYPE_ERROR, a4, &a9, 0x1Cu);
}

void sub_100049A68(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint8_t *a5)
{
  _os_log_error_impl(a1, a2, OS_LOG_TYPE_ERROR, a4, a5, 0x20u);
}

void sub_100049A94(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  int v6 = *(_DWORD *)(a1 + 20);
  uint64_t v21 = 0;
  long long v19 = 0u;
  long long v20 = 0u;
  long long v17 = 0u;
  long long v18 = 0u;
  uint64_t v16 = 0;
  long long v14 = 0u;
  long long v15 = 0u;
  long long v12 = 0u;
  long long v13 = 0u;
  long long v10 = 0uLL;
  uint64_t v11 = 0;
  sub_1000032CC((uint64_t)&v9, 3, v6);
  uint64_t v9 = &off_100095BC8;
  sub_1000032CC((uint64_t)&v8, 3, v6);
  size_t v8 = &off_100095BC8;
  sub_10004A110((uint64_t)&v7, a5, 0, -1);
}

void sub_10004A078(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,char a45,uint64_t a46,uint64_t a47,uint64_t a48,char a49,uint64_t a50,uint64_t a51,uint64_t a52,char a53)
{
}

void sub_10004A110(uint64_t a1, uint64_t a2, int a3, int a4)
{
  *(void *)a1 = off_100096260;
  int v4 = *(_DWORD *)(a2 + 20);
  int v5 = *(_DWORD *)(a2 + 16) - a3;
  if (a4 != -1) {
    int v5 = a4;
  }
  uint64_t v6 = *(void *)(a2 + 8) + 4 * (v4 * a3);
  long long v7 = off_100096260;
  uint64_t v8 = v6;
  int v9 = v5;
  int v10 = v4;
  char v11 = 0;
  *(_DWORD *)(a1 + 16) = v5;
  *(_DWORD *)(a1 + 20) = v4;
  operator new[]();
}

void sub_10004A1E8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

char *sub_10004A1FC(char *a1, uint64_t a2)
{
  *((void *)a1 + 7) = 0;
  int v3 = (pthread_t *)(a1 + 56);
  *((void *)a1 + 2) = 0;
  *(void *)a1 = a2;
  *((void *)a1 + 1) = 0;
  *((_DWORD *)a1 + 6) = 0;
  *((void *)a1 + 4) = 0;
  *((void *)a1 + 5) = 0;
  a1[48] = 0;
  pthread_mutex_init((pthread_mutex_t *)a1 + 1, 0);
  pthread_attr_init(&v5);
  pthread_attr_setdetachstate(&v5, 1);
  pthread_create(v3, &v5, (void *(__cdecl *)(void *))sub_10004A2B8, a1);
  pthread_attr_destroy(&v5);
  return a1;
}

uint64_t sub_10004A2B8(uint64_t a1)
{
  pthread_setname_np("H16ISPMotionManagerInitializationThread");
  id v2 = objc_alloc_init((Class)CMMotionManager);
  if (v2)
  {
    int v3 = v2;
    if (objc_opt_respondsToSelector())
    {
      std::chrono::duration<long long, std::ratio<1, 1000000000>>::rep rep = std::chrono::steady_clock::now().__d_.__rep_;
      v7[0] = _NSConcreteStackBlock;
      v7[1] = 3221225472;
      v7[2] = sub_10004A464;
      void v7[3] = &unk_1000969C8;
      _OWORD v7[4] = a1;
      [v3 setSidebandTimeSyncHandler:v7];
      v5.__d_.__rep_ = std::chrono::steady_clock::now().__d_.__rep_ - rep;
      if (v5.__d_.__rep_ >= 501000000) {
        printf("H16ISPMotionManager: setSidebandTimeSyncHandler delayed, execution time %llu ms\n", (unint64_t)v5.__d_.__rep_ / 0xF4240);
      }
    }
    else
    {
      puts("H16ISPMotionManager::EnableMotionDataFeedToISPCPU - CMMotionManager doesn't support setSidebandTimeSyncHandler");
    }
    pthread_mutex_lock((pthread_mutex_t *)(a1 + 64));
    *(void *)(a1 + 8) = v3;
    pthread_mutex_unlock((pthread_mutex_t *)(a1 + 64));
  }
  return 0;
}

uint64_t sub_10004A3E4(uint64_t a1)
{
  int v4 = 0;
  id v2 = *(_opaque_pthread_t **)(a1 + 56);
  if (v2) {
    pthread_join(v2, &v4);
  }
  if (*(void *)(a1 + 8))
  {
    if (objc_opt_respondsToSelector()) {
      [*(id *)(a1 + 8) setSidebandTimeSyncHandler:0];
    }

    *(void *)(a1 + 8) = 0;
  }
  pthread_mutex_destroy((pthread_mutex_t *)(a1 + 64));
  return a1;
}

uint64_t sub_10004A464(uint64_t a1, uint64_t a2, uint64_t a3)
{
  mach_timebase_info(&info);
  uint64_t v6 = *(void *)(a1 + 32);
  *(void *)(v6 + 32) = a3;
  *(void *)(v6 + 40) = a2;
  *(unsigned char *)(v6 + 48) = 1;
  if (*(_DWORD *)(v6 + 24)
    || (uint64_t result = sub_10004C9B4(*(void *)v6, (_DWORD *)(v6 + 24), (double *)(v6 + 16)),
        uint64_t v6 = *(void *)(a1 + 32),
        *(_DWORD *)(v6 + 24)))
  {
    uint64_t result = sub_1000550A8(*(void *)v6, outputStruct);
    if (!result) {
      return sub_10004DC8C(**(void **)(a1 + 32), a3, (unint64_t)((double)outputStruct[1]+ -1.0 / *(double *)(*(void *)(a1 + 32) + 16) * (double)(outputStruct[0] - a2)));
    }
  }
  return result;
}

void sub_10004A520()
{
  v3[0] = 0;
  v3[1] = v3;
  v3[2] = 0xE6002000000;
  v3[3] = sub_10004A8EC;
  v3[4] = nullsub_14;
  int v0 = fopen("/var/mobile/Library/ISP/Pearl/IsfIRHistory.bin", "rb");
  if (v0)
  {
    fread(&v4, 0xE38uLL, 1uLL, v0);
    fclose(v0);
  }
  else
  {
    int v4 = 1;
    char v5 = 1;
  }
  os_log_t v1 = (os_log_t)off_1002BBCC8;
  if (off_1002BBCC8 == &_os_log_default)
  {
    os_log_t v1 = os_log_create("com.apple.isp", "general");
    off_1002BBCC8 = v1;
  }
  if (os_log_type_enabled(v1, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 136315138;
    long long v7 = "updatePCECalibWithISF";
    _os_log_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_DEFAULT, "%s - ISF\n", buf, 0xCu);
  }
  kdebug_trace();
  sub_1000467E8(&v2);
}

void sub_10004A8C0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void *sub_10004A8EC(uint64_t a1, uint64_t a2)
{
  return memcpy((void *)(a1 + 40), (const void *)(a2 + 40), 0xE38uLL);
}

void sub_10004A900(uint64_t a1)
{
  os_log_t v2 = (os_log_t)off_1002BBCC8;
  if (off_1002BBCC8 == &_os_log_default)
  {
    os_log_t v2 = os_log_create("com.apple.isp", "general");
    off_1002BBCC8 = v2;
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    int v8 = 136315138;
    int v9 = "updatePCECalibWithISF_block_invoke";
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "%s - Writing GMC ISF file\n", (uint8_t *)&v8, 0xCu);
  }
  uint64_t v3 = *(void *)(*(void *)(a1 + 32) + 8);
  int v4 = fopen("/var/mobile/Library/ISP/Pearl/IsfIRHistory.bin.bak", "wb");
  if (v4)
  {
    char v5 = v4;
    fwrite((const void *)(v3 + 40), 0xE38uLL, 1uLL, v4);
    fclose(v5);
    rename((const std::__fs::filesystem::path *)"/var/mobile/Library/ISP/Pearl/IsfIRHistory.bin.bak", (const std::__fs::filesystem::path *)"/var/mobile/Library/ISP/Pearl/IsfIRHistory.bin", v6);
  }
  os_log_t v7 = (os_log_t)off_1002BBCC8;
  if (off_1002BBCC8 == &_os_log_default)
  {
    os_log_t v7 = os_log_create("com.apple.isp", "general");
    off_1002BBCC8 = v7;
  }
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    int v8 = 136315138;
    int v9 = "updatePCECalibWithISF_block_invoke";
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "%s - OK\n", (uint8_t *)&v8, 0xCu);
  }
}

double sub_10004AAA0(int a1, uint64_t a2, double *a3, int a4, void *__src, char *__dst, uint64_t a7, int a8)
{
  memcpy(__dst, __src, 0x3370uLL);
  long long v26 = 0uLL;
  uint64_t v27 = 0;
  sub_100005E50(a2, (long double *)&v26);
  *(_OWORD *)(a7 + 40) = v26;
  *(void *)(a7 + 56) = v27;
  *(unsigned char *)(a7 + 64) = 0;
  os_log_t v14 = (os_log_t)off_1002BBCC8;
  if (off_1002BBCC8 == &_os_log_default)
  {
    os_log_t v14 = os_log_create("com.apple.isp", "general");
    off_1002BBCC8 = v14;
  }
  if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
  {
    double v15 = *a3;
    *(_DWORD *)buf = 136316162;
    int32x4_t v29 = "updatePCECalibWithGMCResults";
    __int16 v30 = 2048;
    uint64_t v31 = v26;
    __int16 v32 = 2048;
    uint64_t v33 = *((void *)&v26 + 1);
    __int16 v34 = 2048;
    uint64_t v35 = v27;
    __int16 v36 = 2048;
    double v37 = v15;
    _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "%s - GMC raw rotation angles, rotX: %.5lf, rotY: %.5lf, rotZ: %.5lf, spatial_coverage: %.3lf\n", buf, 0x34u);
  }
  os_log_t v16 = (os_log_t)off_1002BBCC8;
  if (a3[47] >= 0.0 && (a4 & 1) != 0)
  {
    if (off_1002BBCC8 == &_os_log_default)
    {
      os_log_t v16 = os_log_create("com.apple.isp", "general");
      off_1002BBCC8 = v16;
    }
    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136315138;
      int32x4_t v29 = "updatePCECalibWithGMCResults";
      _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "%s - GMC controller succeeded and front camera supports auto-focus, running ISF...\n", buf, 0xCu);
    }
    mach_timebase_info(&info);
    uint64_t v25 = mach_absolute_time();
    sub_10004A520();
  }
  if (off_1002BBCC8 == &_os_log_default)
  {
    os_log_t v16 = os_log_create("com.apple.isp", "general");
    off_1002BBCC8 = v16;
  }
  if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 136315394;
    int32x4_t v29 = "updatePCECalibWithGMCResults";
    __int16 v30 = 1024;
    LODWORD(v31) = a4;
    _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "%s - Front camera supports auto-focus: %d\n", buf, 0x12u);
  }
  long long v17 = *(_OWORD *)(a2 + 16);
  long long v18 = *(_OWORD *)(a2 + 32);
  long long v19 = *(_OWORD *)(a2 + 48);
  *((void *)__dst + 1639) = *(void *)(a2 + 64);
  long long v20 = *(_OWORD *)a2;
  *(_OWORD *)(__dst + 13080) = v18;
  *(_OWORD *)(__dst + 13096) = v19;
  *(_OWORD *)(__dst + 13048) = v20;
  *(_OWORD *)(__dst + 13064) = v17;
  if (a8 == 10)
  {
    *((void *)__dst + 1640) = *(void *)(a2 + 80);
    double v21 = -*(double *)(a2 + 72);
  }
  else
  {
    *((void *)__dst + 1640) = *(void *)(a2 + 72);
    double v21 = *(double *)(a2 + 80);
  }
  *((double *)__dst + 1641) = v21;
  *((void *)__dst + 1642) = *(void *)(a2 + 88);
  double result = *(double *)(a2 + 96) * *((double *)__src + 1098);
  *((double *)__dst + 1099) = result;
  return result;
}

void sub_10004AE90(uint64_t a1)
{
  *(void *)(a1 + 8) = 0xBFF0000000000000;
  *(void *)(a1 + 16) = -1;
  *(void *)(a1 + 24) = -1;
  *(void *)(a1 + 32) = 0xBFF0000000000000;
  *(void *)(a1 + 40) = -1;
  *(void *)(a1 + 48) = 0;
  *(void *)(a1 + 56) = 0;
  *(void *)(a1 + 64) = 0;
  *(unsigned char *)(a1 + 72) = 0;
  *(_DWORD *)(a1 + 80) = 0;
  *(unsigned char *)(a1 + 84) = 0;
  operator new();
}

dispatch_queue_t **sub_10004B034(dispatch_queue_t **result)
{
  os_log_t v1 = *result;
  if (*result)
  {
    dispatch_sync(*v1, &stru_100096A08);
    dispatch_release(*v1);
    dispatch_queue_t *v1 = 0;
    operator delete();
  }
  return result;
}

uint64_t sub_10004B098()
{
  __chkstk_darwin();
  unsigned int v2 = v1;
  uint64_t v3 = v0[6];
  if (v1 < 3 || *(_DWORD *)v3 == 4)
  {
    if (v1 == 6) {
      operator new[]();
    }
    if (v1 == 3)
    {
      int v4 = *v0;
      uint64_t v22 = (uint64_t)(*v0 + 32);
      byte_1002BBC88 = 0;
      uint64_t v10 = *(void *)(v3 + 26);
      v11.i64[0] = (int)v10;
      v11.i64[1] = SHIDWORD(v10);
      float64x2_t v12 = vcvtq_f64_s64(v11);
      uint64_t v13 = *(void *)(v3 + 30);
      v11.i64[0] = v13;
      v11.i64[1] = HIDWORD(v13);
      float64x2_t v25 = v12;
      float64x2_t v26 = vcvtq_f64_u64((uint64x2_t)v11);
      if (!*((unsigned char *)v3 + 48))
      {
        __asm { FMOV            V0.2D, #-1.0 }
        float64x2_t v26 = _Q0;
        float64x2_t v25 = _Q0;
      }
      mach_timebase_info(&info);
      uint64_t v24 = mach_absolute_time();
      if (!*((_DWORD *)v3 + 17)) {
        *((_DWORD *)v3 + 19) = *((_DWORD *)v3 + 10);
      }
      os_log_t v19 = (os_log_t)off_1002BBCC8;
      if (off_1002BBCC8 == &_os_log_default)
      {
        os_log_t v19 = os_log_create("com.apple.isp", "general");
        off_1002BBCC8 = v19;
      }
      if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
      {
        int v27 = 136315138;
        uint64_t v28 = "run";
        _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "%s - Running GMC\n", (uint8_t *)&v27, 0xCu);
      }
      kdebug_trace();
      sub_100064044(v22, *v4);
    }
    os_log_t v20 = (os_log_t)off_1002BBCC8;
    if (off_1002BBCC8 == &_os_log_default)
    {
      os_log_t v20 = os_log_create("com.apple.isp", "general");
      off_1002BBCC8 = v20;
    }
    if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
    {
      int v27 = 136315394;
      uint64_t v28 = "run";
      __int16 v29 = 1024;
      int v30 = v2;
      os_log_t v7 = "%s - Number of buffers is not 3 or 6 (%d)\n";
      int v8 = v20;
      uint32_t v9 = 18;
      goto LABEL_24;
    }
  }
  else
  {
    os_log_t v5 = (os_log_t)off_1002BBCC8;
    if (off_1002BBCC8 == &_os_log_default)
    {
      os_log_t v5 = os_log_create("com.apple.isp", "general");
      off_1002BBCC8 = v5;
    }
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      int v6 = *(_DWORD *)v3;
      int v27 = 136315650;
      uint64_t v28 = "run";
      __int16 v29 = 1024;
      int v30 = 4;
      __int16 v31 = 1024;
      int v32 = v6;
      os_log_t v7 = "%s - expected GMC parameters buffer v%d, got v%d\n";
      int v8 = v5;
      uint32_t v9 = 24;
LABEL_24:
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, v7, (uint8_t *)&v27, v9);
    }
  }
  return 3;
}

uint64_t sub_10004BB00(uint64_t a1, unint64_t *a2, int a3, int a4, int a5, uint64_t a6, int a7, uint64_t a8, int a9, uint64_t a10, int a11, int a12)
{
  uint64_t result = 0;
  if (a5 >= 1 && a3 >= 1)
  {
    uint64_t v13 = 0;
    uint64_t result = 0;
    if (a7 >= 0) {
      int v14 = a7;
    }
    else {
      int v14 = a7 + 1;
    }
    int v15 = v14 >> 1;
    unint64_t v16 = a5;
    uint64_t v18 = 2 * v15;
    do
    {
      if (a4 >= 1)
      {
        uint64_t v19 = 0;
        do
        {
          if (*(unsigned __int8 *)(a10 + v19) >= a12)
          {
            unint64_t v20 = *a2 & 0xFFFFFFFFF0000000 | (unsigned __int16)v19 | ((unsigned __int16)(v13 & 0xFFF) << 16);
            *a2 = v20;
            unint64_t v21 = v20 & 0xFFFFFC000FFFFFFFLL | ((unint64_t)(*(_WORD *)(a6 + 2 * v19) & 0x3FFF) << 28);
            *a2 = v21;
            unint64_t v22 = v21 & 0xFF0003FFFFFFFFFFLL | ((unint64_t)(*(_WORD *)(a8 + 2 * v19) & 0x3FFF) << 42);
            *a2 = v22;
            *a2++ = v22 & 0xFFFFFFFFFFFFFFLL | ((unint64_t)*(unsigned __int8 *)(a10 + v19) << 56);
            uint64_t result = (result + 1);
            if ((int)result >= a3) {
              break;
            }
          }
          ++v19;
        }
        while (a4 != v19);
      }
      if (++v13 >= v16) {
        break;
      }
      a10 += a11;
      a8 += 2 * (a9 / 2);
      a6 += v18;
    }
    while ((int)result < a3);
  }
  return result;
}

void sub_10004BBEC(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  os_log_t v3 = (os_log_t)off_1002BBCC8;
  if (off_1002BBCC8 == &_os_log_default)
  {
    os_log_t v3 = os_log_create("com.apple.isp", "general");
    off_1002BBCC8 = v3;
  }
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    int v7 = 136315138;
    int v8 = "postProcessProjectorGMC_block_invoke";
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "%s - projector GMC reporting analytics\n", (uint8_t *)&v7, 0xCu);
  }
  uint64_t v4 = a1 + 40;
  sub_100013C10(a1 + 40, a1 + 13208, *(unsigned int *)(a1 + 13800), a1 + 13804, (void *)(v2 + 8));
  if (*(unsigned char *)(a1 + 26972) && *(double *)(a1 + 13584) >= 0.0)
  {
    os_log_t v5 = (os_log_t)off_1002BBCC8;
    if (off_1002BBCC8 == &_os_log_default)
    {
      os_log_t v5 = os_log_create("com.apple.isp", "general");
      off_1002BBCC8 = v5;
    }
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      int v7 = 136315138;
      int v8 = "postProcessProjectorGMC_block_invoke";
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "%s - Updating PCECalib on disk\n", (uint8_t *)&v7, 0xCu);
    }
    kdebug_trace();
    sub_100009BEC(v4);
  }
  os_log_t v6 = (os_log_t)off_1002BBCC8;
  if (off_1002BBCC8 == &_os_log_default)
  {
    os_log_t v6 = os_log_create("com.apple.isp", "general");
    off_1002BBCC8 = v6;
  }
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    int v7 = 136315138;
    int v8 = "postProcessProjectorGMC_block_invoke";
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "%s - Projector-GMC post processing done\n", (uint8_t *)&v7, 0xCu);
  }
}

void sub_10004BE1C(uint64_t a1)
{
  os_log_t v2 = (os_log_t)off_1002BBCC8;
  if (off_1002BBCC8 == &_os_log_default)
  {
    os_log_t v2 = os_log_create("com.apple.isp", "general");
    off_1002BBCC8 = v2;
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 136315138;
    int v7 = "postProcessStereoGMC_block_invoke";
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "%s - Stereo GMC reporting analytics\n", buf, 0xCu);
  }
  sub_100014390();
  if (*(double *)(a1 + 520) >= 0.0)
  {
    sub_100013800();
    uint64_t v4 = fopen("/var/mobile/Library/ISP/Pearl/IsfHistory.bin", "rb");
    if (v4)
    {
      fread(buf, 0xE38uLL, 1uLL, v4);
      fclose(v4);
    }
    else
    {
      *(_DWORD *)buf = 3;
      LOBYTE(v7) = 1;
    }
    sub_100005F94(&v5);
  }
  os_log_t v3 = (os_log_t)off_1002BBCC8;
  if (off_1002BBCC8 == &_os_log_default)
  {
    os_log_t v3 = os_log_create("com.apple.isp", "general");
    off_1002BBCC8 = v3;
  }
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 136315138;
    int v7 = "postProcessStereoGMC_block_invoke";
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "%s - Stereo-GMC post processing done\n", buf, 0xCu);
  }
}

void sub_10004C2F4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  sub_100005F98((uint64_t *)va);
  _Unwind_Resume(a1);
}

double sub_10004C314(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)(a1 + 40) = *(_OWORD *)(a2 + 40);
  long long v2 = *(_OWORD *)(a2 + 56);
  long long v3 = *(_OWORD *)(a2 + 72);
  long long v4 = *(_OWORD *)(a2 + 88);
  *(void *)(a1 + 104) = *(void *)(a2 + 104);
  *(_OWORD *)(a1 + 88) = v4;
  *(_OWORD *)(a1 + 72) = v3;
  *(_OWORD *)(a1 + 56) = v2;
  long long v5 = *(_OWORD *)(a2 + 112);
  *(void *)(a1 + 128) = *(void *)(a2 + 128);
  *(_OWORD *)(a1 + 112) = v5;
  double result = *(double *)(a2 + 136);
  *(double *)(a1 + 136) = result;
  return result;
}

uint64_t sub_10004C35C(uint64_t a1)
{
  return sub_10004C368(a1, (_DWORD *)(a1 + 4748));
}

uint64_t sub_10004C368(uint64_t a1, _DWORD *a2)
{
  mach_port_t v2 = *(_DWORD *)(a1 + 4424);
  if (!v2) {
    return 3758097084;
  }
  uint64_t output = 0;
  uint32_t outputCnt = 1;
  uint64_t result = IOConnectCallScalarMethod(v2, 0x24u, 0, 0, &output, &outputCnt);
  if (!result) {
    *a2 = output;
  }
  return result;
}

uint64_t sub_10004C3D4(uint64_t a1, void *a2)
{
  uint64_t v2 = 3758097085;
  CFErrorRef err = 0;
  uint64_t result = 3758097090;
  if (a2 && !*a2)
  {
    if (byte_1002BBE5E)
    {
      return 0;
    }
    else
    {
      CFURLRef v5 = CFURLCreateWithFileSystemPath(kCFAllocatorDefault, @"/usr/local/share/firmware/isp/ISPUnitInfo.plist", kCFURLPOSIXPathStyle, 0);
      if (v5)
      {
        CFURLRef v6 = v5;
        CFPropertyListFormat format = 0;
        int v7 = CFReadStreamCreateWithFile(kCFAllocatorDefault, v5);
        if (v7)
        {
          int v8 = v7;
          if (CFReadStreamOpen(v7))
          {
            if (off_1002BBCD0 == &_os_log_default) {
              off_1002BBCD0 = os_log_create("com.apple.isp", "device");
            }
            if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_INFO))
            {
              *(_DWORD *)buf = 136315138;
              uint64_t v18 = "GetUnitInfoPropertyDict";
              _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_INFO, "%s - Parsing ISPUnitInfo.plist\n", buf, 0xCu);
            }
            CFPropertyListRef v9 = CFPropertyListCreateWithStream(kCFAllocatorDefault, v8, 0, 0, &format, &err);
            if (err)
            {
              if (off_1002BBCD0 == &_os_log_default) {
                off_1002BBCD0 = os_log_create("com.apple.isp", "device");
              }
              BOOL v10 = os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR);
              if (v10) {
                sub_100078884(v10, v11, v12);
              }
              CFStringRef v13 = CFErrorCopyDescription(err);
              if (v13)
              {
                CFStringRef v14 = v13;
                CFShow(v13);
                CFRelease(v14);
              }
            }
            else
            {
              uint64_t v2 = 0;
              *a2 = v9;
            }
          }
          else
          {
            uint64_t v2 = 3758097136;
          }
          CFReadStreamClose(v8);
          CFRelease(v8);
        }
        CFRelease(v6);
        return v2;
      }
      else
      {
        return 3758097085;
      }
    }
  }
  return result;
}

uint64_t sub_10004C600(uint64_t a1)
{
  uint64_t output = 0;
  uint32_t outputCnt = 1;
  uint64_t result = *(unsigned int *)(a1 + 4424);
  if (result) {
    return !IOConnectCallScalarMethod(result, 5u, 0, 0, &output, &outputCnt) && output == 1;
  }
  return result;
}

uint64_t sub_10004C658(uint64_t a1, uint64_t a2, unsigned int a3, unsigned int a4, unsigned int a5)
{
  kdebug_trace();
  mach_port_t v10 = *(_DWORD *)(a1 + 4424);
  if (v10)
  {
    input[0] = a2;
    input[1] = a3;
    input[2] = a4;
    input[3] = a5;
    uint64_t v11 = IOConnectCallScalarMethod(v10, 0xAu, input, 4u, 0, 0);
  }
  else
  {
    uint64_t v11 = 3758097084;
  }
  kdebug_trace();
  return v11;
}

uint64_t sub_10004C750(uint64_t a1, unsigned int a2, void *outputStruct)
{
  size_t v5 = 156;
  mach_port_t v3 = *(_DWORD *)(a1 + 4424);
  if (!v3) {
    return 3758097084;
  }
  uint64_t input = a2;
  return IOConnectCallMethod(v3, 0xEu, &input, 1u, 0, 0, 0, 0, outputStruct, &v5);
}

uint64_t sub_10004C7E4(uint64_t a1, unsigned int a2, uint64_t a3, unsigned int a4, unsigned int *a5)
{
  if (*(unsigned char *)(a1 + 4))
  {
    uint64_t v5 = 3758097090;
    if (*(_DWORD *)(a1 + 4748) > a2)
    {
      uint64_t v6 = *(void *)(a1 + 40);
      if (*(_DWORD *)(v6 + 432 * a2))
      {
        unsigned int v7 = *(_DWORD *)(v6 + 432 * a2 + 72);
        if (v7 > a4)
        {
          unsigned int v8 = *a5;
          if (*a5 >= v7) {
            unsigned int v8 = v7;
          }
          if (v8 + a4 <= v7) {
            unsigned int v9 = v8;
          }
          else {
            unsigned int v9 = v7 - a4;
          }
          if (v9) {
            operator new[]();
          }
        }
      }
      else
      {
        return 3758097088;
      }
    }
  }
  else
  {
    if (off_1002BBCD0 == &_os_log_default) {
      off_1002BBCD0 = os_log_create("com.apple.isp", "device");
    }
    uint64_t v5 = 3758097112;
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR)) {
      sub_1000788C4();
    }
  }
  return v5;
}

uint64_t sub_10004C9B4(uint64_t a1, _DWORD *a2, double *a3)
{
  if (*(unsigned char *)(a1 + 4))
  {
    mach_timebase_info(&info);
    uint64_t v6 = 0;
    *a2 = *(_DWORD *)(a1 + 16);
    LODWORD(v7) = *(_DWORD *)(a1 + 16);
    LODWORD(v8) = info.numer;
    *a3 = 1.0 / (double)v7 * 1000000000.0 * ((double)(info.denom | 0x41CDCD6500000000uLL) / (double)v8);
  }
  else
  {
    if (off_1002BBCD0 == &_os_log_default) {
      off_1002BBCD0 = os_log_create("com.apple.isp", "device");
    }
    uint64_t v6 = 3758097112;
    BOOL v9 = os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR);
    if (v9) {
      sub_100078940(v9, v10, v11, v12, v13, v14, v15, v16);
    }
  }
  return v6;
}

NSObject *sub_10004CA98(uint64_t a1, unsigned int a2, unsigned int a3, unsigned int a4)
{
  mach_port_t v5 = *(_DWORD *)(a1 + 4424);
  if (!v5) {
    return 3758097084;
  }
  uint64_t v7 = a2;
  uint64_t v8 = a3;
  input[0] = a2;
  input[1] = a3;
  input[2] = a4;
  uint64_t result = IOConnectCallScalarMethod(v5, 0x15u, input, 3u, 0, 0);
  if (result) {
    return result;
  }
  if (*(unsigned char *)(a1 + 16 * v7 + 4512))
  {
    uint64_t result = *(NSObject **)(*(void *)(a1 + 72) + 72);
    if (!result) {
      return result;
    }
    block[0] = _NSConcreteStackBlock;
    block[1] = 0x40000000;
    block[2] = sub_100052020;
    block[3] = &unk_100096BE0;
    unsigned int v11 = a2;
    block[4] = a1;
    void block[5] = v8;
    dispatch_async(result, block);
  }
  return 0;
}

uint64_t sub_10004CBB0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, _DWORD *a6)
{
  if (*a6) {
    operator new[]();
  }
  return 3758097090;
}

uint64_t sub_10004CCA4()
{
  uint64_t v0 = __chkstk_darwin();
  if (off_1002BBCD0 == &_os_log_default) {
    off_1002BBCD0 = os_log_create("com.apple.isp", "device");
  }
  if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 136315138;
    *(void *)&uint8_t buf[4] = "CacheDeviceConfigs";
    _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "%s - caching device configurations\n", buf, 0xCu);
  }
  if (*(_DWORD *)(v0 + 4748))
  {
    bzero(buf, 0x1CuLL);
    *(_WORD *)&uint8_t buf[4] = 3;
    uint64_t v1 = sub_10004C658(v0, (uint64_t)buf, 0x1Cu, 0, 0xFFFFFFFF);
    if (v1)
    {
      if (off_1002BBCD0 == &_os_log_default) {
        off_1002BBCD0 = os_log_create("com.apple.isp", "device");
      }
      if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR)) {
        sub_100078B38();
      }
LABEL_61:
      if (off_1002BBCD0 == &_os_log_default) {
        off_1002BBCD0 = os_log_create("com.apple.isp", "device");
      }
      if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR)) {
        sub_100078A38();
      }
      sub_10004DDF4(v0);
      return v1;
    }
    *(_OWORD *)(v0 + 8) = *(_OWORD *)buf;
    *(_OWORD *)(v0 + 20) = *(_OWORD *)&buf[12];
    if (off_1002BBCD0 == &_os_log_default) {
      off_1002BBCD0 = os_log_create("com.apple.isp", "device");
    }
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)unint64_t v21 = 136315650;
      unint64_t v22 = "CacheDeviceConfigs";
      __int16 v23 = 1024;
      int v24 = *(_DWORD *)&buf[12];
      __int16 v25 = 1024;
      int v26 = *(_DWORD *)&buf[8];
      _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_INFO, "%s - maxChannels=%d, timeStampFrequency=%d\n", v21, 0x18u);
    }
    if (!*(void *)(v0 + 48)) {
      operator new[]();
    }
    if (!*(void *)(v0 + 40)) {
      operator new[]();
    }
    LODWORD(v10) = *(_DWORD *)(v0 + 4748);
    if (v10)
    {
      unint64_t v11 = 0;
      do
      {
        bzero(buf, 0x190uLL);
        *(_WORD *)&uint8_t buf[4] = 269;
        *(_DWORD *)&buf[8] = v11;
        uint64_t v1 = sub_10004C658(v0, (uint64_t)buf, 0x190u, 0, 0xFFFFFFFF);
        if (v1)
        {
          if (off_1002BBCD0 == &_os_log_default) {
            off_1002BBCD0 = os_log_create("com.apple.isp", "device");
          }
          if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR)) {
            sub_100078AB4();
          }
          goto LABEL_61;
        }
        *(_DWORD *)(*(void *)(v0 + 40) + 432 * v11) = v29;
        if (off_1002BBCD0 == &_os_log_default) {
          off_1002BBCD0 = os_log_create("com.apple.isp", "device");
        }
        if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)unint64_t v21 = 136315650;
          unint64_t v22 = "CacheDeviceConfigs";
          __int16 v23 = 1024;
          int v24 = v29;
          __int16 v25 = 1024;
          int v26 = v11;
          _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "%s - %d configurations detected for channel %d\n", v21, 0x18u);
        }
        memmove((void *)(*(void *)(v0 + 40) + 432 * v11 + 32), buf, 0x190uLL);
        uint64_t v12 = *(void *)(v0 + 40);
        if (!*(_DWORD *)(v12 + 432 * v11))
        {
LABEL_40:
          uint64_t v1 = 0;
          goto LABEL_48;
        }
        if (!*(void *)(v12 + 432 * v11 + 8) && !*(void *)(v12 + 432 * v11 + 24)) {
          operator new[]();
        }
        uint64_t v13 = 0;
        uint64_t v14 = 0;
        uint64_t v15 = 0;
        unint64_t v16 = 0;
        while (1)
        {
          bzero(buf, 0x120uLL);
          *(_WORD *)&uint8_t buf[4] = 262;
          *(_DWORD *)&buf[8] = v11;
          *(_DWORD *)&buf[12] = v16;
          uint64_t v1 = sub_10004C658(v0, (uint64_t)buf, 0x120u, 0, 0xFFFFFFFF);
          if (v1) {
            break;
          }
          if ((v28 & 0x80) != 0) {
            unsigned int v28 = (v28 & 0xFFFFFF00) + 256;
          }
          memmove((void *)(*(void *)(*(void *)(v0 + 40) + 432 * v11 + 8) + v15), &buf[16], 0xD4uLL);
          memmove((void *)(*(void *)(*(void *)(v0 + 40) + 432 * v11 + 16) + v14), &v30, 0x3CuLL);
          uint64_t v1 = sub_10005667C(v0, v11, v16, (void *)(*(void *)(*(void *)(v0 + 40) + 432 * v11 + 24) + v13));
          if (v1)
          {
            if (off_1002BBCD0 == &_os_log_default) {
              off_1002BBCD0 = os_log_create("com.apple.isp", "device");
            }
            if (!os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR)) {
              goto LABEL_48;
            }
            *(_DWORD *)unint64_t v21 = 136315650;
            unint64_t v22 = "CacheDeviceConfigs";
            __int16 v23 = 1024;
            int v24 = v11;
            __int16 v25 = 1024;
            int v26 = v1;
            long long v17 = "%s - Error getting LSC polynomial - chan: %d, res: 0x%08X\n";
LABEL_53:
            _os_log_error_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR, v17, v21, 0x18u);
            goto LABEL_48;
          }
          ++v16;
          v15 += 212;
          v14 += 60;
          v13 += 72;
          if (v16 >= *(unsigned int *)(*(void *)(v0 + 40) + 432 * v11)) {
            goto LABEL_40;
          }
        }
        if (off_1002BBCD0 == &_os_log_default) {
          off_1002BBCD0 = os_log_create("com.apple.isp", "device");
        }
        if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)unint64_t v21 = 136315650;
          unint64_t v22 = "CacheDeviceConfigs";
          __int16 v23 = 1024;
          int v24 = v11;
          __int16 v25 = 1024;
          int v26 = v1;
          long long v17 = "%s - Error getting camera config - chan: %d, res: 0x%08X\n";
          goto LABEL_53;
        }
LABEL_48:
        uint64_t v18 = *(void *)(v0 + 48);
        if (v18) {
          sub_10004C750(v0, v11, (void *)(v18 + 156 * v11));
        }
        ++v11;
        unint64_t v10 = *(unsigned int *)(v0 + 4748);
      }
      while (v11 < v10);
      if (!v1) {
        goto LABEL_67;
      }
      goto LABEL_61;
    }
LABEL_67:
    *(_DWORD *)uint64_t v0 = v10;
    *(unsigned char *)(v0 + 4) = 1;
    if (off_1002BBCD0 == &_os_log_default) {
      off_1002BBCD0 = os_log_create("com.apple.isp", "device");
    }
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_INFO))
    {
      int v20 = *(_DWORD *)(v0 + 4748);
      *(_DWORD *)unint64_t v21 = 136315394;
      unint64_t v22 = "CacheDeviceConfigs";
      __int16 v23 = 1024;
      int v24 = v20;
      _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_INFO, "%s - Success: cached configs - numChannels: %d\n", v21, 0x12u);
    }
    return 0;
  }
  else
  {
    if (off_1002BBCD0 == &_os_log_default) {
      off_1002BBCD0 = os_log_create("com.apple.isp", "device");
    }
    uint64_t v1 = 3758097112;
    BOOL v2 = os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR);
    if (v2) {
      sub_1000789BC(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  return v1;
}

uint64_t sub_10004D520(uint64_t a1, int a2, int a3, int a4, unsigned int a5)
{
  bzero(v15, 0x14uLL);
  __int16 v16 = 290;
  int v17 = a2;
  int v18 = a3;
  int v19 = a4;
  uint64_t v10 = sub_10004C658(a1, (uint64_t)v15, 0x14u, 0, a5);
  uint64_t v11 = v10;
  if (a3 == 6914 && !v10)
  {
    if (*(_DWORD *)(a1 + 4748))
    {
      unsigned int v12 = 0;
      while (1)
      {
        uint64_t v13 = sub_10004D640(a1, v12);
        if (v13) {
          break;
        }
        if (++v12 >= *(_DWORD *)(a1 + 4748)) {
          return 0;
        }
      }
      uint64_t v11 = v13;
      if (off_1002BBCD0 == &_os_log_default) {
        off_1002BBCD0 = os_log_create("com.apple.isp", "device");
      }
      if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR)) {
        sub_100078BB4();
      }
    }
    else
    {
      return 0;
    }
  }
  return v11;
}

uint64_t sub_10004D640(uint64_t a1, unsigned int a2)
{
  bzero(__src, 0x190uLL);
  __int16 v7 = 269;
  unsigned int v8 = a2;
  uint64_t v4 = sub_10004C658(a1, (uint64_t)__src, 0x190u, 0, 0xFFFFFFFF);
  if (!v4) {
    memmove((void *)(*(void *)(a1 + 40) + 432 * a2 + 32), __src, 0x190uLL);
  }
  return v4;
}

uint64_t sub_10004D6F8(uint64_t a1, int a2, const char **a3)
{
  if (a2 != 6) {
    return 3758097090;
  }
  bzero(v19, 0x40uLL);
  __int16 v20 = 5;
  strncpy(v22, a3[1], 0x20uLL);
  uint64_t v5 = sub_10004C658(a1, (uint64_t)v19, 0x40u, 1u, 0xFFFFFFFF);
  if (v5)
  {
    uint64_t v6 = v5;
    if (off_1002BBCD0 == &_os_log_default) {
      off_1002BBCD0 = os_log_create("com.apple.isp", "device");
    }
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR)) {
      sub_100078C3C((uint64_t)(a3 + 1), v6, v7, v8, v9, v10, v11, v12);
    }
  }
  else
  {
    unint64_t v13 = v27;
    unint64_t v14 = strtoul(a3[2], 0, 0);
    unint64_t v15 = strtoul(a3[3], 0, 0);
    unint64_t v16 = strtoul(a3[4], 0, 0);
    unint64_t v17 = strtoul(a3[5], 0, 0);
    printf("Special function: name: %s, parameters %llu %llu %llu %llu\n", v22, v14, v15, v16, v17);
    bzero(v19, 0x38uLL);
    __int16 v20 = 28;
    int v21 = 1;
    unint64_t v23 = v13;
    unint64_t v24 = v14;
    unint64_t v25 = v15;
    unint64_t v26 = v16;
    unint64_t v27 = v17;
    return sub_10004C658(a1, (uint64_t)v19, 0x38u, 1u, 0xFFFFFFFF);
  }
  return v6;
}

uint64_t sub_10004D8D4(uint64_t a1, uint64_t a2)
{
  bzero(v25, 0xD8uLL);
  uint64_t v4 = 0;
  v25[2] = 20;
  unsigned int v26 = v26 & 0x7FFF0000 | 0x80000000;
  int v5 = *(_DWORD *)(a2 + 4);
  char v27 = *(_DWORD *)a2;
  char v28 = v5;
  unsigned int v6 = vcvtd_n_s64_f64(*(double *)(a2 + 72), 0x10uLL);
  int v7 = *(_DWORD *)(a2 + 104);
  __int16 v29 = *(_DWORD *)(a2 + 108);
  unsigned int v32 = v6;
  int v34 = v7;
  long long v33 = *(_OWORD *)(a2 + 80);
  char v8 = 1;
  do
  {
    char v9 = v8;
    uint64_t v10 = (double *)(a2 + 8 * v4);
    v30[v4] = vcvtd_n_u64_f64(v10[1], 0x10uLL);
    uint64_t v11 = &v25[v4];
    v11[12] = (int)v10[3];
    v11[14] = vcvtd_n_s64_f64(v10[5], 8uLL);
    uint64_t v4 = 1;
    char v8 = 0;
  }
  while ((v9 & 1) != 0);
  int32x2_t v31 = vmovn_s64(vcvtq_n_s64_f64(*(float64x2_t *)(a2 + 56), 0x10uLL));
  long long v12 = *(_OWORD *)(a2 + 132);
  long long v35 = *(_OWORD *)(a2 + 116);
  long long v36 = v12;
  long long v37 = *(_OWORD *)(a2 + 148);
  uint64_t v38 = *(void *)(a2 + 164);
  long long v41 = *(_OWORD *)(a2 + 204);
  long long v42 = *(_OWORD *)(a2 + 220);
  v43[0] = *(_OWORD *)(a2 + 236);
  *(_OWORD *)((char *)v43 + 14) = *(_OWORD *)(a2 + 250);
  long long v39 = *(_OWORD *)(a2 + 172);
  long long v40 = *(_OWORD *)(a2 + 188);
  sub_10004C658(a1, (uint64_t)v25, 0xD8u, 0, 0xFFFFFFFF);
  BOOL v24 = 0;
  uint64_t v13 = sub_10004DBC0(a1, &v24);
  if (v13) {
    return v13;
  }
  if (!v24) {
    return 0;
  }
  int v14 = *(_DWORD *)(a1 + 96);
  if (v14 == 2)
  {
    uint64_t v13 = 3758097084;
    if (!*(void *)(a1 + 184)) {
      return v13;
    }
    mach_absolute_time();
    FigHostTimeToNanoseconds();
    if (sub_100065988())
    {
      os_log_t v15 = (os_log_t)off_1002BBCD8;
      if (off_1002BBCD8 == &_os_log_default)
      {
        os_log_t v15 = os_log_create("com.apple.isp", "exclaves");
        off_1002BBCD8 = v15;
      }
      if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR)) {
        goto LABEL_12;
      }
      return v13;
    }
    return 0;
  }
  uint64_t v13 = 0;
  if (v14 != 3) {
    return v13;
  }
  uint64_t v13 = 3758097084;
  if (!*(void *)(a1 + 136)) {
    return v13;
  }
  mach_absolute_time();
  FigHostTimeToNanoseconds();
  if (!sub_100065820()) {
    return 0;
  }
  os_log_t v15 = (os_log_t)off_1002BBCD8;
  if (off_1002BBCD8 == &_os_log_default)
  {
    os_log_t v15 = os_log_create("com.apple.isp", "exclaves");
    off_1002BBCD8 = v15;
  }
  if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR)) {
LABEL_12:
  }
    sub_100078CC0(v15, v16, v17, v18, v19, v20, v21, v22);
  return v13;
}

uint64_t sub_10004DBC0(uint64_t a1, BOOL *a2)
{
  uint64_t output = 0;
  uint32_t outputCnt = 1;
  mach_port_t v2 = *(_DWORD *)(a1 + 4424);
  if (!v2) {
    return 3758097084;
  }
  uint64_t v4 = IOConnectCallScalarMethod(v2, 0x5Bu, 0, 0, &output, &outputCnt);
  if (v4)
  {
    if (off_1002BBCD0 == &_os_log_default) {
      off_1002BBCD0 = os_log_create("com.apple.isp", "device");
    }
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR)) {
      sub_100078D38();
    }
  }
  else
  {
    *a2 = output != 0;
  }
  return v4;
}

uint64_t sub_10004DC8C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  bzero(v7, 0x18uLL);
  __int16 v8 = 12;
  uint64_t v9 = a2;
  uint64_t v10 = a3;
  return sub_10004C658(a1, (uint64_t)v7, 0x18u, 0, 0xFFFFFFFF);
}

uint64_t sub_10004DCF4(uint64_t a1, unsigned int a2, unsigned int a3, uint64_t a4, uint64_t a5)
{
  unsigned int v6 = *(_DWORD *)(a1 + 4748);
  uint64_t result = 3758097090;
  if (v6 > a2 && a3 <= 0x40)
  {
    bzero(v13, 0xD0uLL);
    __int16 v14 = 1285;
    unsigned int v15 = a2;
    __int16 v16 = a3;
    if (a3)
    {
      uint64_t v12 = 0;
      do
      {
        v17[v12] = *(_WORD *)(a4 + 2 * v12);
        *((unsigned char *)&v17[64] + v12) = *(unsigned char *)(a5 + v12);
        ++v12;
      }
      while (a3 != v12);
    }
    return sub_10004C658(a1, (uint64_t)v13, 0xD0u, 0, 0xFFFFFFFF);
  }
  return result;
}

uint64_t sub_10004DDF4(uint64_t a1)
{
  if (off_1002BBCD0 == &_os_log_default) {
    off_1002BBCD0 = os_log_create("com.apple.isp", "device");
  }
  if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
  {
    int v7 = 136315138;
    __int16 v8 = "InitDeviceConfigsCache";
    _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "%s - Initializing device configuration cache\n", (uint8_t *)&v7, 0xCu);
  }
  if (*(unsigned char *)(a1 + 4))
  {
    *(unsigned char *)(a1 + 4) = 0;
    *(_DWORD *)a1 = 0;
    mach_port_t v2 = (uint64_t *)(a1 + 40);
    if (*(void *)(a1 + 40))
    {
      if (!*(_DWORD *)(a1 + 4748)) {
        goto LABEL_17;
      }
      uint64_t v3 = 0;
      unint64_t v4 = 0;
      do
      {
        uint64_t v5 = *v2;
        if (*(void *)(*v2 + v3 + 8)) {
          operator delete[]();
        }
        if (*(void *)(v5 + v3 + 16)) {
          operator delete[]();
        }
        if (*(void *)(v5 + v3 + 24)) {
          operator delete[]();
        }
        *(_DWORD *)(v5 + v3) = 0;
        bzero((void *)(v5 + v3 + 32), 0x190uLL);
        ++v4;
        v3 += 432;
      }
      while (v4 < *(unsigned int *)(a1 + 4748));
      if (*v2) {
LABEL_17:
      }
        operator delete[]();
      if (*(void *)(a1 + 48)) {
        operator delete[]();
      }
      *mach_port_t v2 = 0;
      *(void *)(a1 + 48) = 0;
    }
  }
  else
  {
    if (off_1002BBCD0 == &_os_log_default) {
      off_1002BBCD0 = os_log_create("com.apple.isp", "device");
    }
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_INFO))
    {
      int v7 = 136315138;
      __int16 v8 = "InitDeviceConfigsCache";
      _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_INFO, "%s - cache is already invalid - exiting\n", (uint8_t *)&v7, 0xCu);
    }
  }
  return 0;
}

uint64_t sub_10004E06C(unsigned int *a1)
{
  *(void *)outputStructCnt = 24;
  mach_port_t v2 = a1[1106];
  if (v2)
  {
    uint64_t v3 = IOConnectCallStructMethod(v2, 0xFu, 0, 0, outputStruct, (size_t *)outputStructCnt);
    if (!v3)
    {
      BOOL v27 = (v31 | v32) != 0;
      if (off_1002BBCD0 == &_os_log_default) {
        off_1002BBCD0 = os_log_create("com.apple.isp", "device");
      }
      if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_INFO))
      {
        unint64_t v4 = "";
        if (v32) {
          uint64_t v5 = "";
        }
        else {
          uint64_t v5 = "n't";
        }
        if (!v31) {
          unint64_t v4 = "n't";
        }
        *(_DWORD *)outputStructCnt = 136315394;
        *(void *)&outputStructCnt[4] = v5;
        *(_WORD *)&outputStructCnt[12] = 2080;
        *(void *)&outputStructCnt[14] = v4;
        _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_INFO, "This is%s an internal build, and FDR was%s validated\n", outputStructCnt, 0x16u);
      }
      uint64_t v6 = 0;
      unint64_t v7 = 0;
      uint64_t v26 = 0;
      uint64_t v3 = 0;
      uint64_t v8 = 282;
      BOOL v9 = sub_10000FB84();
      while (1)
      {
        uint64_t v10 = *((void *)a1 + 548) + v6;
        if (*(_DWORD *)(v10 + 8))
        {
          int v11 = *(_DWORD *)(v10 + 16);
          if (v11 == 1785950322 || v11 == 1718186595) {
            break;
          }
        }
LABEL_45:
        ++v7;
        v8 += 432;
        v6 += 96;
        if (v7 == 6) {
          return v3;
        }
      }
      unsigned __int8 v13 = *((unsigned char *)a1 + 4);
      if (v13) {
        unsigned __int8 v13 = v7 < *a1 && *(unsigned char *)(*((void *)a1 + 5) + v8) != 0;
      }
      if (((v11 == 1718186595) & v13) != 0) {
        unsigned __int8 v13 = v9;
      }
      if ((v13 & 1) == 0)
      {
        unsigned int v15 = (xpc_connection_t *)*((void *)a1 + 14);
        if (!v15) {
          goto LABEL_35;
        }
        if (v11 == 1718186595) {
          int v16 = 5;
        }
        else {
          int v16 = 6;
        }
        *(_DWORD *)outputStructCnt = v16;
        int v17 = sub_10001B91C(v15, (xpc_object_t *)outputStructCnt);
        int v14 = 0;
        if (v17 || !outputStructCnt[8]) {
          goto LABEL_36;
        }
        uint64_t v18 = time(0);
        uint64_t v19 = mach_continuous_time();
        if (*(uint64_t *)&outputStructCnt[16] <= v18)
        {
LABEL_35:
          int v14 = 0;
          goto LABEL_36;
        }
        double v20 = difftime(*(time_t *)&outputStructCnt[16], v18);
        mach_timebase_info(&info);
        LODWORD(v22) = info.numer;
        LODWORD(v21) = info.denom;
        uint64_t v26 = v19 + (unint64_t)(v20 * 1000000000.0 * (double)v21 / (double)v22);
      }
      int v14 = 1;
LABEL_36:
      if (((v11 == 1718186595) & v14) != 0) {
        int v14 = v27;
      }
      if (v14 == 1)
      {
        a1[1186] |= 1 << v7;
        bzero(&info, 0xCuLL);
        LOWORD(info.denom) = 1568;
        int v29 = v7;
        uint64_t v3 = sub_10004C658((uint64_t)a1, (uint64_t)&info, 0xCu, 0, 0xFFFFFFFF);
        if (v11 == 1718186595)
        {
          mach_port_t v23 = a1[1106];
          if (v23)
          {
            *(void *)outputStructCnt = 1;
            *(void *)&outputStructCnt[8] = v26;
            *(void *)&outputStructCnt[16] = v9;
            IOConnectCallScalarMethod(v23, 0x33u, (const uint64_t *)outputStructCnt, 3u, 0, 0);
          }
        }
      }
      else if (v11 == 1718186595)
      {
        mach_port_t v24 = a1[1106];
        if (v24)
        {
          *(void *)outputStructCnt = 0;
          *(void *)&outputStructCnt[8] = 0;
          *(void *)&outputStructCnt[16] = v9;
          IOConnectCallScalarMethod(v24, 0x33u, (const uint64_t *)outputStructCnt, 3u, 0, 0);
        }
      }
      goto LABEL_45;
    }
  }
  else
  {
    uint64_t v3 = 3758097084;
  }
  if (off_1002BBCD0 == &_os_log_default) {
    off_1002BBCD0 = os_log_create("com.apple.isp", "device");
  }
  if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR)) {
    sub_100078DB4();
  }
  return v3;
}

uint64_t sub_10004E454(uint64_t a1, void *outputStruct)
{
  size_t outputStructCnt = 24;
  mach_port_t v2 = *(_DWORD *)(a1 + 4424);
  if (v2) {
    return IOConnectCallStructMethod(v2, 0xFu, 0, 0, outputStruct, &outputStructCnt);
  }
  else {
    return 3758097084;
  }
}

uint64_t sub_10004E4A4(uint64_t a1, unsigned int a2)
{
  mach_port_t v2 = *(_DWORD *)(a1 + 4424);
  if (!v2) {
    return 3758097084;
  }
  uint64_t v4 = a2;
  return IOConnectCallScalarMethod(v2, 0x6Bu, &v4, 1u, 0, 0);
}

void sub_10004E520(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v4 = 0;
  *(unsigned char *)(a1 + 4) = 0;
  *(_DWORD *)a1 = 0;
  *(void *)(a1 + 40) = 0;
  *(void *)(a1 + 48) = 0;
  *(void *)(a1 + 72) = a2;
  *(void *)(a1 + 104) = 0;
  *(void *)(a1 + 112) = 0;
  do
  {
    uint64_t v5 = a1 + v4;
    *(unsigned char *)(v5 + 144) = 0;
    *(void *)(v5 + 136) = 0;
    *(_DWORD *)(v5 + 128) = -1;
    v4 += 48;
  }
  while (v4 != 96);
  *(_DWORD *)(a1 + 224) = 0;
  *(_OWORD *)(a1 + 4324) = 0u;
  *(_OWORD *)(a1 + 4340) = 0u;
  *(unsigned char *)(a1 + 4368) = 0;
  *(_DWORD *)(a1 + 4372) = 0;
  *(void *)(a1 + 4408) = 0;
  *(void *)(a1 + 4420) = 0;
  *(unsigned char *)(a1 + 4496) = 0;
  *(_DWORD *)(a1 + 4796) = 0;
  *(_OWORD *)(a1 + 4748) = 0u;
  *(_OWORD *)(a1 + 4764) = 0u;
  *(_OWORD *)(a1 + 4780) = 0u;
  *(_DWORD *)(a1 + 4416) = a3;
  *(void *)(a1 + 56) = 0;
  *(void *)(a1 + 64) = 0;
  uint64_t v6 = &byte_1002BBE29;
  byte_1002BBE54 = sub_100022CF0(@"LsInterpMode", @"com.apple.coremedia", 1);
  dword_1002BBE58 = sub_100022CF0(@"LsBypassVerify", @"com.apple.coremedia", 0);
  byte_1002BBE5C = sub_100022CF0(@"LsEnableGreenAvg", @"com.apple.coremedia", 0) != 0;
  byte_1002BBE5D = sub_100022CF0(@"RadialGainEnable", @"com.apple.coremedia", 1) != 0;
  byte_1002BBE5E = sub_100022CF0(@"IgnoreUnitInfoPlist", @"com.apple.coremedia", 0) != 0;
  dword_1002BBE60 = sub_100022CF0(@"UnitInfoNVMChannelMask", @"com.apple.coremedia", 0xFFFFFFFFLL);
  uint64_t v7 = 0;
  byte_1002BBE64 = sub_100022CF0(@"EnableExclaveDebug", @"com.apple.coremedia", 0) != 0;
  do
  {
    CFStringRef v8 = CFStringCreateWithFormat(0, 0, @"LsAdjustEnableCam%d", v7);
    *(_DWORD *)(v6 - 5) = sub_100022CF0(v8, @"com.apple.coremedia", 0xFFFFFFFFLL);
    CFRelease(v8);
    CFStringRef v9 = CFStringCreateWithFormat(0, 0, @"LsAdjustInvertCam%d", v7);
    *(v6 - 1) = sub_100022CF0(v9, @"com.apple.coremedia", 0) != 0;
    CFRelease(v9);
    CFStringRef v10 = CFStringCreateWithFormat(0, 0, @"LsIdealPctCam%d", v7);
    char *v6 = sub_100022CF0(v10, @"com.apple.coremedia", 0xFFFFFFFFLL);
    v6 += 8;
    CFRelease(v10);
    ++v7;
  }
  while (v7 != 6);
  *(void *)(a1 + 88) = 0;
  sub_10005EEB8((CFDictionaryRef *)(a1 + 88));
}

void sub_10004E98C()
{
}

uint64_t sub_10004E9B8(uint64_t refCon)
{
  if (!*(_DWORD *)(refCon + 4420)) {
    return IOServiceAddInterestNotification(*(IONotificationPortRef *)(*(void *)(refCon + 72) + 16), *(_DWORD *)(refCon + 4416), "IOGeneralInterest", (IOServiceInterestCallback)sub_100056714, (void *)refCon, (io_object_t *)(refCon + 4420));
  }
  return refCon;
}

uint64_t sub_10004E9FC(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 4424)) {
    sub_10004ECE0(a1);
  }
  io_object_t v2 = *(_DWORD *)(a1 + 4420);
  if (v2)
  {
    IOObjectRelease(v2);
    *(_DWORD *)(a1 + 4420) = 0;
  }
  uint64_t v3 = *(CFTypeRef **)(a1 + 216);
  if (v3)
  {
    sub_1000469C8(v3);
    operator delete();
  }
  uint64_t v4 = (unsigned __int8 *)(a1 + 4512);
  uint64_t v5 = *(void *)(a1 + 104);
  if (v5)
  {
    sub_10004A460(v5);
    operator delete();
  }
  sub_10004DDF4(a1);
  uint64_t v6 = 0;
  uint64_t v7 = (unsigned __int8 *)(a1 + 4512);
  do
  {
    int v8 = *v7;
    v7 += 16;
    if (v8)
    {
      CFStringRef v9 = *(NSObject **)(*(void *)(a1 + 72) + 72);
      if (v9)
      {
        block[0] = _NSConcreteStackBlock;
        block[1] = 0x40000000;
        block[2] = sub_10004ED94;
        block[3] = &unk_100096AA0;
        block[4] = a1;
        int v22 = v6;
        dispatch_sync(v9, block);
      }
    }
    if (v4[96])
    {
      CFStringRef v10 = *(NSObject **)(*(void *)(a1 + 72) + 72);
      if (v10)
      {
        v19[0] = _NSConcreteStackBlock;
        v19[1] = 0x40000000;
        v19[2] = sub_10004EDDC;
        v19[3] = &unk_100096AC0;
        unsigned char v19[4] = a1;
        int v20 = v6;
        dispatch_sync(v10, v19);
      }
    }
    ++v6;
    uint64_t v4 = v7;
  }
  while (v6 != 6);
  if (*(unsigned char *)(a1 + 4704))
  {
    int v11 = *(NSObject **)(*(void *)(a1 + 72) + 72);
    if (v11)
    {
      v18[0] = _NSConcreteStackBlock;
      v18[1] = 0x40000000;
      v18[2] = sub_10004EE24;
      v18[3] = &unk_100096AE0;
      _OWORD v18[4] = a1;
      dispatch_sync(v11, v18);
    }
  }
  if (*(unsigned char *)(a1 + 4720))
  {
    uint64_t v12 = *(NSObject **)(*(void *)(a1 + 72) + 72);
    if (v12)
    {
      v17[0] = _NSConcreteStackBlock;
      v17[1] = 0x40000000;
      v17[2] = sub_10004EE54;
      v17[3] = &unk_100096B00;
      _OWORD v17[4] = a1;
      dispatch_sync(v12, v17);
    }
  }
  if (*(unsigned char *)(a1 + 4736))
  {
    unsigned __int8 v13 = *(NSObject **)(*(void *)(a1 + 72) + 72);
    if (v13)
    {
      v16[0] = _NSConcreteStackBlock;
      v16[1] = 0x40000000;
      v16[2] = sub_10004EE84;
      v16[3] = &unk_100096B20;
      v16[4] = a1;
      dispatch_sync(v13, v16);
    }
  }
  int v14 = *(const void **)(a1 + 88);
  if (v14)
  {
    CFRelease(v14);
    *(void *)(a1 + 88) = 0;
  }
  pthread_mutex_destroy((pthread_mutex_t *)(a1 + 4432));
  return a1;
}

uint64_t sub_10004ECE0(uint64_t a1)
{
  io_object_t v2 = (pthread_mutex_t *)(a1 + 4432);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 4432));
  uint64_t v3 = IOConnectCallScalarMethod(*(_DWORD *)(a1 + 4424), 4u, 0, 0, 0, 0);
  io_connect_t v4 = *(_DWORD *)(a1 + 4424);
  if (v4)
  {
    IOServiceClose(v4);
    *(_DWORD *)(a1 + 4424) = 0;
    *(void *)(a1 + 56) = 0;
    *(void *)(a1 + 64) = 0;
  }
  else
  {
    uint64_t v3 = 3758097101;
  }
  pthread_mutex_unlock(v2);
  return v3;
}

uint64_t sub_10004ED64(uint64_t a1)
{
  uint64_t result = *(unsigned int *)(a1 + 4420);
  if (result)
  {
    uint64_t result = IOObjectRelease(result);
    *(_DWORD *)(a1 + 4420) = 0;
  }
  return result;
}

uint64_t sub_10004ED94(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32) + 4504;
  uint64_t result = notify_cancel(*(_DWORD *)(v2 + 16 * *(unsigned int *)(a1 + 40) + 12));
  *(unsigned char *)(v2 + 16 * *(unsigned int *)(a1 + 40) + 8) = 0;
  return result;
}

uint64_t sub_10004EDDC(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32) + 4600;
  uint64_t result = notify_cancel(*(_DWORD *)(v2 + 16 * *(unsigned int *)(a1 + 40) + 12));
  *(unsigned char *)(v2 + 16 * *(unsigned int *)(a1 + 40) + 8) = 0;
  return result;
}

uint64_t sub_10004EE24(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  uint64_t result = notify_cancel(*(_DWORD *)(v1 + 4708));
  *(unsigned char *)(v1 + 4704) = 0;
  return result;
}

uint64_t sub_10004EE54(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  uint64_t result = notify_cancel(*(_DWORD *)(v1 + 4724));
  *(unsigned char *)(v1 + 4720) = 0;
  return result;
}

uint64_t sub_10004EE84(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  uint64_t result = notify_cancel(*(_DWORD *)(v1 + 4740));
  *(unsigned char *)(v1 + 4736) = 0;
  return result;
}

uint64_t sub_10004EEB8()
{
  uint64_t v0 = __chkstk_darwin();
  if (off_1002BBCD0 == &_os_log_default) {
    off_1002BBCD0 = os_log_create("com.apple.isp", "device");
  }
  if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)__int32 v68 = 136315138;
    *(void *)&v68[4] = "ISP_PowerOnCamera";
    _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_INFO, "%s - powering on camera\n", v68, 0xCu);
  }
  kdebug_trace();
  uint64_t v1 = 3758097084;
  if (*(_DWORD *)(v0 + 4424))
  {
    if ((sub_10004C600(v0) & 1) == 0 && *(unsigned char *)(v0 + 4)) {
      sub_10004DDF4(v0);
    }
    unsigned int v41 = IOConnectCallScalarMethod(*(_DWORD *)(v0 + 4424), 0xBu, 0, 0, 0, 0);
    if (!v41)
    {
      mach_port_t v2 = *(_DWORD *)(v0 + 4424);
      if (!v2) {
        return v1;
      }
      *(void *)__int32 v68 = 63;
      uint64_t v1 = IOConnectCallScalarMethod(v2, 0x3Au, (const uint64_t *)v68, 1u, 0, 0);
      if (v1) {
        return v1;
      }
      uint64_t v3 = (_DWORD *)(v0 + 4748);
      if (*(_DWORD *)(v0 + 4748)) {
        goto LABEL_19;
      }
      if (sub_10004C368(v0, (_DWORD *)(v0 + 4748)))
      {
        if (off_1002BBCD0 == &_os_log_default) {
          off_1002BBCD0 = os_log_create("com.apple.isp", "device");
        }
        if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR)) {
          sub_1000790FC();
        }
      }
      if (*v3)
      {
LABEL_19:
        uint64_t v4 = 0;
        unsigned int v41 = 0;
        do
        {
          bzero(v71, 0x9CuLL);
          *(void *)long long v42 = v4;
          sub_10004C750(v0, v4, v71);
          bzero(v68, 0x211CuLL);
          sub_1000513A4(v0, v4, 0, v68);
          bzero(v67, 0x211CuLL);
          sub_1000513A4(v0, v4, 1u, v67);
          bzero(v66, 0x211CuLL);
          sub_1000513A4(v0, v4, 2u, v66);
          if ((_BYTE)v72 && !v73) {
            operator new();
          }
          ++v4;
        }
        while (*(void *)v42 + 1 < (unint64_t)*v3);
      }
      else
      {
        unsigned int v41 = 0;
      }
      if (!*(unsigned char *)(v0 + 4)) {
        sub_10004CCA4();
      }
      if (*(unsigned char *)(*(void *)(v0 + 4384) + 584) && !*(void *)(v0 + 104))
      {
        if (!*(unsigned char *)(v0 + 4496)) {
          operator new();
        }
        if (off_1002BBCD0 == &_os_log_default) {
          off_1002BBCD0 = os_log_create("com.apple.isp", "device");
        }
        unsigned int v41 = 0;
        if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)__int32 v68 = 136315138;
          *(void *)&v68[4] = "ISP_PowerOnCamera";
          _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "%s - bypassMotionManagerInitialization!\n", v68, 0xCu);
          unsigned int v41 = 0;
        }
      }
    }
  }
  else
  {
    unsigned int v41 = -536870212;
  }
  if (*(_DWORD *)(v0 + 4748))
  {
    unint64_t v5 = 0;
    uint64_t v6 = (unsigned char *)(v0 + 4608);
    uint64_t v7 = 16;
    do
    {
      int v8 = *(_DWORD *)(*(void *)(v0 + 4384) + v7);
      if (v8 <= 1785950321)
      {
        if (v8 == 1718186595)
        {
          CFStringRef v10 = 0;
          CFStringRef v9 = "com.apple.isp.frontirsensorpower";
          goto LABEL_47;
        }
        if (v8 == 1718775412 || v8 == 1718776695)
        {
          CFStringRef v9 = "com.apple.isp.frontcamerapower";
          CFStringRef v10 = "com.apple.isp.frontcamerasensorconfig";
          goto LABEL_47;
        }
      }
      else if (v8 > 1919251318)
      {
        if (v8 == 1919251319)
        {
          CFStringRef v9 = "com.apple.isp.backsuperwidecamerapower";
          CFStringRef v10 = "com.apple.isp.backsuperwidesensorconfig";
LABEL_47:
          *((void *)v6 - 13) = v9;
          *((void *)v6 - 1) = v10;
          if (!*(v6 - 96))
          {
            uint64_t v12 = *(NSObject **)(*(void *)(v0 + 72) + 72);
            if (v12)
            {
              block[0] = _NSConcreteStackBlock;
              block[1] = 0x40000000;
              block[2] = sub_10005144C;
              block[3] = &unk_100096B40;
              block[4] = v0;
              int v59 = v5;
              dispatch_sync(v12, block);
              CFStringRef v10 = (const char *)*((void *)v6 - 1);
            }
          }
          if (v10)
          {
            if (!*v6)
            {
              unsigned __int8 v13 = *(NSObject **)(*(void *)(v0 + 72) + 72);
              if (v13)
              {
                v56[0] = _NSConcreteStackBlock;
                v56[1] = 0x40000000;
                v56[2] = sub_10005149C;
                v56[3] = &unk_100096B60;
                v56[4] = v0;
                int v57 = v5;
                dispatch_sync(v13, v56);
              }
            }
          }
          goto LABEL_54;
        }
        if (v8 == 1919251564)
        {
          CFStringRef v9 = "com.apple.isp.backtelecamerapower";
          CFStringRef v10 = "com.apple.isp.backtelecamerasensorconfig";
          goto LABEL_47;
        }
      }
      else
      {
        if (v8 == 1785950322)
        {
          CFStringRef v10 = 0;
          CFStringRef v9 = "com.apple.isp.backtofsensorpower";
          goto LABEL_47;
        }
        if (v8 == 1919246706)
        {
          CFStringRef v9 = "com.apple.isp.backcamerapower";
          CFStringRef v10 = "com.apple.isp.backcamerasensorconfig";
          goto LABEL_47;
        }
      }
      *((void *)v6 - 13) = 0;
      *((void *)v6 - 1) = 0;
LABEL_54:
      ++v5;
      v6 += 16;
      v7 += 96;
    }
    while (v5 < *(unsigned int *)(v0 + 4748));
  }
  if (!*(unsigned char *)(v0 + 4704))
  {
    *(void *)(v0 + 4696) = "com.apple.isp.cameratorch";
    int v14 = *(NSObject **)(*(void *)(v0 + 72) + 72);
    if (v14)
    {
      v55[0] = _NSConcreteStackBlock;
      v55[1] = 0x40000000;
      v55[2] = sub_1000514EC;
      v55[3] = &unk_100096B80;
      v55[4] = v0;
      dispatch_sync(v14, v55);
    }
  }
  if (!*(unsigned char *)(v0 + 4720))
  {
    *(void *)(v0 + 4712) = "com.apple.isp.cameratorchcoolcurrent";
    unsigned int v15 = *(NSObject **)(*(void *)(v0 + 72) + 72);
    if (v15)
    {
      v54[0] = _NSConcreteStackBlock;
      v54[1] = 0x40000000;
      v54[2] = sub_100051530;
      v54[3] = &unk_100096BA0;
      v54[4] = v0;
      dispatch_sync(v15, v54);
    }
  }
  if (!*(unsigned char *)(v0 + 4736))
  {
    *(void *)(v0 + 4728) = "com.apple.isp.cameratorchwarmcurrent";
    int v16 = *(NSObject **)(*(void *)(v0 + 72) + 72);
    if (v16)
    {
      v53[0] = _NSConcreteStackBlock;
      v53[1] = 0x40000000;
      v53[2] = sub_100051574;
      v53[3] = &unk_100096BC0;
      void v53[4] = v0;
      dispatch_sync(v16, v53);
    }
  }
  int v17 = sub_10004C600(v0);
  unsigned int v18 = v41;
  if (v17 && *(unsigned char *)(v0 + 4) && !v41)
  {
    if (*(_DWORD *)(v0 + 4748))
    {
      unsigned int v19 = 0;
      unsigned int v20 = 0;
      do
      {
        sprintf(v67, "/usr/local/share/firmware/isp/cam%dclocks.txt", v19);
        unint64_t v21 = fopen(v67, "r");
        if (v21)
        {
          if (off_1002BBCD0 == &_os_log_default) {
            off_1002BBCD0 = os_log_create("com.apple.isp", "device");
          }
          if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
          {
            LODWORD(__dst[0]) = 67109120;
            DWORD1(__dst[0]) = v19;
            int v22 = "Found camera clock override information file for camera channel %d\n";
LABEL_74:
            _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, v22, (uint8_t *)__dst, 8u);
          }
          while (fgets(v68, 256, v21))
          {
            mach_port_t v23 = strtok(v68, "=");
            if (v23)
            {
              mach_port_t v24 = v23;
              if (!strncmp(v23, "clockdiv", 8uLL))
              {
                char v28 = strtok(0, " \n");
                if (v28)
                {
                  int v29 = strtoul(v28, 0, 0);
                  if (off_1002BBCD0 == &_os_log_default) {
                    off_1002BBCD0 = os_log_create("com.apple.isp", "device");
                  }
                  if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
                  {
                    LODWORD(__dst[0]) = 67109120;
                    DWORD1(__dst[0]) = v29;
                    int v22 = "Set clock divider reg to 0x%08X\n";
                    goto LABEL_74;
                  }
                }
                else
                {
                  if (off_1002BBCD0 == &_os_log_default) {
                    off_1002BBCD0 = os_log_create("com.apple.isp", "device");
                  }
                  if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR)) {
                    sub_100078EF0(&v51, v52);
                  }
                }
              }
              else if (!strncmp(v24, "property", 8uLL))
              {
                int v30 = strtok(0, " :");
                if (v30)
                {
                  int v31 = strtoul(v30, 0, 0);
                  unsigned __int8 v32 = strtok(0, " \n");
                  if (v32)
                  {
                    int v33 = strtoul(v32, 0, 0);
                    if (off_1002BBCD0 == &_os_log_default) {
                      off_1002BBCD0 = os_log_create("com.apple.isp", "device");
                    }
                    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_INFO))
                    {
                      LODWORD(__dst[0]) = 67109376;
                      DWORD1(__dst[0]) = v31;
                      WORD4(__dst[0]) = 1024;
                      *(_DWORD *)((char *)__dst + 10) = v33;
                      _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_INFO, "Setting FW property 0x%08x to 0x%08X\n", (uint8_t *)__dst, 0xEu);
                    }
                    int v34 = sub_10004D520(v0, v19, v31, v33, 0xFFFFFFFF);
                    if (v34)
                    {
                      if (off_1002BBCD0 == &_os_log_default) {
                        off_1002BBCD0 = os_log_create("com.apple.isp", "device");
                      }
                      if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR)) {
                        sub_100078F24(v64, v34, v65);
                      }
                    }
                  }
                  else
                  {
                    if (off_1002BBCD0 == &_os_log_default) {
                      off_1002BBCD0 = os_log_create("com.apple.isp", "device");
                    }
                    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR)) {
                      sub_100078EF0(&v47, v48);
                    }
                  }
                }
                else
                {
                  if (off_1002BBCD0 == &_os_log_default) {
                    off_1002BBCD0 = os_log_create("com.apple.isp", "device");
                  }
                  if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR)) {
                    sub_100078EF0(&v49, v50);
                  }
                }
              }
              else if (!strncmp(v24, "FWOBJECTSPECIALFUNC", 0x13uLL))
              {
                unint64_t v35 = 0;
                memset(__dst, 0, 48);
                do
                {
                  unint64_t v36 = v35;
                  *((void *)__dst + v35) = v24;
                  mach_port_t v24 = strtok(0, ":");
                  unint64_t v35 = v36 + 1;
                  if (v24) {
                    BOOL v37 = v36 >= 5;
                  }
                  else {
                    BOOL v37 = 1;
                  }
                }
                while (!v37);
                int v38 = sub_10004D6F8(v0, v35, (const char **)__dst);
                if (v38) {
                  printf("Sending special debug function to firmware object returned error : 0x%08x\n", v38);
                }
              }
              else
              {
                int v25 = strtoul(v24, 0, 0);
                uint64_t v26 = strtok(0, " \n");
                if (v26)
                {
                  if (v20 > 0x3F)
                  {
                    if (off_1002BBCD0 == &_os_log_default) {
                      off_1002BBCD0 = os_log_create("com.apple.isp", "device");
                    }
                    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR)) {
                      sub_100078F68(&v43, v44);
                    }
                  }
                  else
                  {
                    int v27 = strtoul(v26, 0, 0);
                    if (off_1002BBCD0 == &_os_log_default) {
                      off_1002BBCD0 = os_log_create("com.apple.isp", "device");
                    }
                    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_INFO))
                    {
                      LODWORD(__dst[0]) = 67109376;
                      DWORD1(__dst[0]) = v25;
                      WORD4(__dst[0]) = 1024;
                      *(_DWORD *)((char *)__dst + 10) = v27;
                      _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_INFO, "Set sensor reg 0x%08x to val 0x%08X\n", (uint8_t *)__dst, 0xEu);
                    }
                    v66[v20] = v25;
                    *((unsigned char *)v64 + v20++ + 0x2000) = v27;
                  }
                }
                else
                {
                  if (off_1002BBCD0 == &_os_log_default) {
                    off_1002BBCD0 = os_log_create("com.apple.isp", "device");
                  }
                  if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR)) {
                    sub_100078EF0(&v45, v46);
                  }
                }
              }
            }
            else
            {
              if (off_1002BBCD0 == &_os_log_default) {
                off_1002BBCD0 = os_log_create("com.apple.isp", "device");
              }
              if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR)) {
                sub_100078EF0(&v60, v61);
              }
            }
          }
          fclose(v21);
          if (v20)
          {
            int v39 = sub_10004DCF4(v0, v19, v20, (uint64_t)v66, (uint64_t)&v63);
            if (v39)
            {
              if (off_1002BBCD0 == &_os_log_default) {
                off_1002BBCD0 = os_log_create("com.apple.isp", "device");
              }
              if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR)) {
                sub_100078EAC(v71, v39, &v72);
              }
            }
            else
            {
              if (off_1002BBCD0 == &_os_log_default) {
                off_1002BBCD0 = os_log_create("com.apple.isp", "device");
              }
              if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
              {
                LODWORD(__dst[0]) = 67109376;
                DWORD1(__dst[0]) = v19;
                WORD4(__dst[0]) = 1024;
                *(_DWORD *)((char *)__dst + 10) = v20;
                _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "Successfully sent camera %d sensor register over-ride values for %d registers\n", (uint8_t *)__dst, 0xEu);
              }
            }
          }
        }
        ++v19;
      }
      while (v19 < *(_DWORD *)(v0 + 4748));
    }
    unsigned int v18 = v41;
  }
  if (!v18) {
    sub_10004E06C((unsigned int *)v0);
  }
  kdebug_trace();
  if (off_1002BBCD0 == &_os_log_default) {
    off_1002BBCD0 = os_log_create("com.apple.isp", "device");
  }
  uint64_t v1 = v41;
  if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)__int32 v68 = 136315394;
    *(void *)&v68[4] = "ISP_PowerOnCamera";
    __int16 v69 = 1024;
    unsigned int v70 = v41;
    _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_INFO, "%s - status: 0x%08X\n", v68, 0x12u);
  }
  return v1;
}

void sub_10005135C()
{
}

uint64_t sub_1000513A4(uint64_t a1, unsigned int a2, unsigned int a3, void *outputStruct)
{
  uint64_t result = 3758097084;
  if (!outputStruct) {
    return 3758097090;
  }
  mach_port_t v6 = *(_DWORD *)(a1 + 4424);
  if (v6)
  {
    size_t v7 = 8476;
    input[0] = a2;
    input[1] = a3;
    return IOConnectCallMethod(v6, 0x5Fu, input, 2u, 0, 0, 0, 0, outputStruct, &v7);
  }
  return result;
}

uint64_t sub_10005144C(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32) + 4504;
  uint64_t v3 = v2 + 16 * *(unsigned int *)(a1 + 40);
  uint64_t result = notify_register_check(*(const char **)v3, (int *)(v3 + 12));
  *(unsigned char *)(v2 + 16 * *(unsigned int *)(a1 + 40) + 8) = result == 0;
  return result;
}

uint64_t sub_10005149C(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32) + 4600;
  uint64_t v3 = v2 + 16 * *(unsigned int *)(a1 + 40);
  uint64_t result = notify_register_check(*(const char **)v3, (int *)(v3 + 12));
  *(unsigned char *)(v2 + 16 * *(unsigned int *)(a1 + 40) + 8) = result == 0;
  return result;
}

uint64_t sub_1000514EC(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  uint64_t v2 = v1 + 4696;
  uint64_t result = notify_register_check(*(const char **)(v1 + 4696), (int *)(v1 + 4708));
  *(unsigned char *)(v2 + 8) = result == 0;
  return result;
}

uint64_t sub_100051530(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  uint64_t v2 = v1 + 4712;
  uint64_t result = notify_register_check(*(const char **)(v1 + 4712), (int *)(v1 + 4724));
  *(unsigned char *)(v2 + 8) = result == 0;
  return result;
}

uint64_t sub_100051574(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  uint64_t v2 = v1 + 4728;
  uint64_t result = notify_register_check(*(const char **)(v1 + 4728), (int *)(v1 + 4740));
  *(unsigned char *)(v2 + 8) = result == 0;
  return result;
}

uint64_t sub_1000515B8(uint64_t a1)
{
  int v2 = -10;
  do
  {
    if (!sub_10004C600(a1)) {
      break;
    }
    usleep(0x186A0u);
    if (off_1002BBCD0 == &_os_log_default) {
      off_1002BBCD0 = os_log_create("com.apple.isp", "device");
    }
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136315138;
      uint64_t v12 = "ISP_ColdBootPowerCycle";
      _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "%s - Camera powered on...waiting\n", buf, 0xCu);
    }
    usleep(0x493E0u);
  }
  while (!__CFADD__(v2++, 1));
  uint64_t v4 = sub_100051890(a1);
  if (v4)
  {
    uint64_t v5 = v4;
    if (off_1002BBCD0 == &_os_log_default) {
      off_1002BBCD0 = os_log_create("com.apple.isp", "device");
    }
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR)) {
      sub_1000791F4();
    }
  }
  else
  {
    mach_port_t v6 = (void *)os_transaction_create();
    uint64_t v5 = sub_1000518EC(a1);
    os_release(v6);
    if (v5)
    {
      if (off_1002BBCD0 == &_os_log_default) {
        off_1002BBCD0 = os_log_create("com.apple.isp", "device");
      }
      if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR)) {
        sub_100079178();
      }
    }
    else
    {
      uint64_t v7 = sub_10004EEB8();
      if (v7)
      {
        uint64_t v5 = v7;
        int v8 = 0;
        BOOL v9 = 0;
      }
      else if (sub_10004C600(a1))
      {
        uint64_t v5 = sub_100051EE8(a1);
        BOOL v9 = v5 == 0;
        int v8 = 1;
      }
      else
      {
        int v8 = 0;
        BOOL v9 = 0;
        uint64_t v5 = 0;
      }
      if (off_1002BBCD0 == &_os_log_default) {
        off_1002BBCD0 = os_log_create("com.apple.isp", "device");
      }
      if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136315906;
        uint64_t v12 = "ISP_ColdBootPowerCycle";
        __int16 v13 = 1024;
        int v14 = v8;
        __int16 v15 = 1024;
        BOOL v16 = v9;
        __int16 v17 = 1024;
        int v18 = v5;
        _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "%s - poweredOn=%d, poweredOff=%d, res=0x%08X\n", buf, 0x1Eu);
      }
    }
  }
  return v5;
}

uint64_t sub_100051890(uint64_t a1)
{
  mach_port_t v2 = *(_DWORD *)(a1 + 4424);
  if (!v2) {
    return 3758097084;
  }
  uint64_t result = IOConnectCallScalarMethod(v2, 9u, 0, 0, 0, 0);
  if (!result)
  {
    sub_10004DDF4(a1);
    return 0;
  }
  return result;
}

uint64_t sub_1000518EC(uint64_t a1)
{
  uint64_t v2 = sub_10005237C(a1);
  if (!v2)
  {
    CFDictionaryRef theDict = 0;
    sub_10004C3D4(v2, &theDict);
    sub_100052078(a1);
    sub_100032A64(a1);
    sub_100033208(a1);
    sub_100032E28(a1);
    sub_10005264C(a1, "/System/Library/PrivateFrameworks/AppleCVHWA.framework/Firmware/lacc_VIO_ISP_IR.bin", 0, 0, 0, 8u, 0, 0);
    strcpy((char *)input, "/System/Library/PrivateFrameworks/AppleCVHWA.framework/Firmware/");
    *(void *)buf = 0;
    io_registry_entry_t v5 = IORegistryEntryFromPath(kIOMainPortDefault, "IODeviceTree:/arm-io");
    if (v5)
    {
      CFDataRef CFProperty = (const __CFData *)IORegistryEntryCreateCFProperty(v5, @"soc-generation", 0, 0);
      CFDataRef v7 = CFProperty;
      if (CFProperty)
      {
        CFTypeID v8 = CFGetTypeID(CFProperty);
        if (v8 == CFDataGetTypeID())
        {
          CFIndex Length = CFDataGetLength(v7);
          if ((unint64_t)(Length - 8) > 0xFFFFFFFFFFFFFFF8)
          {
            size_t v26 = Length;
            BytePtr = (const char *)CFDataGetBytePtr(v7);
            strncpy((char *)buf, BytePtr, v26);
          }
          else
          {
            if (off_1002BBCD0 == &_os_log_default) {
              off_1002BBCD0 = os_log_create("com.apple.isp", "device");
            }
            BOOL v10 = os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR);
            if (v10) {
              sub_1000792EC(v10, v11, v12, v13, v14, v15, v16, v17);
            }
          }
          goto LABEL_22;
        }
      }
    }
    else
    {
      CFDataRef v7 = 0;
    }
    if (off_1002BBCD0 == &_os_log_default) {
      off_1002BBCD0 = os_log_create("com.apple.isp", "device");
    }
    BOOL v18 = os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR);
    if (v18) {
      sub_100079270(v18, v19, v20, v21, v22, v23, v24, v25);
    }
    if (!v7) {
LABEL_23:
    }
      operator new[]();
LABEL_22:
    CFRelease(v7);
    goto LABEL_23;
  }
  uint64_t v3 = v2;
  if (off_1002BBCD0 == &_os_log_default) {
    off_1002BBCD0 = os_log_create("com.apple.isp", "device");
  }
  if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR)) {
    sub_100079368();
  }
  return v3;
}

uint64_t sub_100051EE8(uint64_t a1)
{
  kdebug_trace();
  mach_port_t v2 = *(_DWORD *)(a1 + 4424);
  if (v2) {
    uint64_t v3 = IOConnectCallScalarMethod(v2, 0xCu, 0, 0, 0, 0);
  }
  else {
    uint64_t v3 = 3758097084;
  }
  kdebug_trace();
  return v3;
}

uint64_t sub_100051F78(uint64_t a1, unsigned char *a2, uint64_t a3, uint64_t a4)
{
  mach_port_t v4 = *(_DWORD *)(a1 + 4424);
  if (!v4) {
    return 3758097084;
  }
  input[0] = (uint64_t)a2;
  if (*a2)
  {
    uint64_t v5 = 0;
    do
      uint64_t v6 = v5 + 1;
    while (a2[++v5]);
  }
  else
  {
    uint64_t v6 = 0;
  }
  input[1] = v6;
  uint64_t input[2] = a3;
  uint64_t input[3] = a4;
  return IOConnectCallScalarMethod(v4, 0x65u, input, 4u, 0, 0);
}

uint64_t sub_100052020(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32) + 4504;
  notify_set_state(*(_DWORD *)(v2 + 16 * *(unsigned int *)(a1 + 48) + 12), *(void *)(a1 + 40));
  uint64_t v3 = *(const char **)(v2 + 16 * *(unsigned int *)(a1 + 48));

  return notify_post(v3);
}

uint64_t sub_100052078(uint64_t a1)
{
  uint64_t v1 = 3758097136;
  uint64_t v16 = 0;
  uint64_t v17 = 0;
  int v23 = 0;
  uint64_t v22 = 0;
  if (*(_DWORD *)(a1 + 4424))
  {
    if (MGIsQuestionValid())
    {
      uint64_t v3 = (const void *)MGCopyAnswerWithError();
      if (v3)
      {
        mach_port_t v4 = v3;
        CFStringRef v5 = CFCopyDescription(v3);
        if (v5)
        {
          CFStringRef v6 = v5;
          if (off_1002BBCD0 == &_os_log_default) {
            off_1002BBCD0 = os_log_create("com.apple.isp", "device");
          }
          if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 136315394;
            uint64_t v19 = "ISP_SetFrontCameraOffsetFromDisplayCenter";
            __int16 v20 = 2080;
            CStringPtr = CFStringGetCStringPtr(v6, 0x8000100u);
            _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "%s - kMGQFrontCameraOffsetFromDisplayCenter Description=%s\n", buf, 0x16u);
          }
          CFRelease(v6);
        }
        CFTypeID v7 = CFGetTypeID(v4);
        if (v7 == CFArrayGetTypeID() && CFArrayGetCount((CFArrayRef)v4) == 3)
        {
          CFIndex v8 = 0;
          BOOL v9 = &v22;
          while (1)
          {
            CFNumberRef ValueAtIndex = (const __CFNumber *)CFArrayGetValueAtIndex((CFArrayRef)v4, v8);
            if (!ValueAtIndex) {
              break;
            }
            CFNumberRef v11 = ValueAtIndex;
            CFTypeID v12 = CFGetTypeID(ValueAtIndex);
            if (v12 != CFNumberGetTypeID() || !CFNumberIsFloatType(v11)) {
              goto LABEL_26;
            }
            int Value = CFNumberGetValue(v11, kCFNumberFloatType, v9);
            if (Value)
            {
              BOOL v9 = (uint64_t *)((char *)v9 + 4);
              if (v8++ != 2) {
                continue;
              }
            }
            if (Value) {
              uint64_t v1 = 0;
            }
            else {
              uint64_t v1 = 3758097102;
            }
            if (Value)
            {
              uint64_t v16 = v22;
              LODWORD(v17) = v23;
              uint64_t v1 = IOConnectCallStructMethod(*(_DWORD *)(a1 + 4424), 0x56u, &v16, 0xCuLL, 0, 0);
              goto LABEL_36;
            }
            break;
          }
        }
        else
        {
LABEL_26:
          uint64_t v1 = 3758096385;
        }
      }
      else
      {
        if (off_1002BBCD0 == &_os_log_default) {
          off_1002BBCD0 = os_log_create("com.apple.isp", "device");
        }
        if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR)) {
          sub_100079458();
        }
        mach_port_t v4 = 0;
      }
    }
    else
    {
      mach_port_t v4 = 0;
      uint64_t v1 = 3758097095;
    }
  }
  else
  {
    mach_port_t v4 = 0;
    uint64_t v1 = 3758097087;
  }
  if (off_1002BBCD0 == &_os_log_default) {
    off_1002BBCD0 = os_log_create("com.apple.isp", "device");
  }
  if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR))
  {
    sub_1000793DC();
    if (!v4) {
      return v1;
    }
    goto LABEL_36;
  }
  if (v4) {
LABEL_36:
  }
    CFRelease(v4);
  return v1;
}

uint64_t sub_10005237C(uint64_t a1)
{
  outputStructCnt[0] = 24;
  mach_port_t v2 = *(_DWORD *)(a1 + 4424);
  if (!v2 || (IOConnectCallStructMethod(v2, 0xFu, 0, 0, outputStruct, outputStructCnt), !outputStruct[20]))
  {
    uint64_t v3 = fopen("/usr/local/share/firmware/isp/isp_fw.bin", "rb");
    mach_port_t v4 = fopen(0, "rb");
    if (v4)
    {
      CFStringRef v5 = v4;
      if (v3) {
        fclose(v3);
      }
    }
    else
    {
      CFStringRef v5 = v3;
    }
    if (off_1002BBCD0 == &_os_log_default) {
      off_1002BBCD0 = os_log_create("com.apple.isp", "device");
    }
    BOOL v6 = os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR);
    if (v6)
    {
      sub_100079554(v6, v7, v8, v9, v10, v11, v12, v13);
      if (v5)
      {
LABEL_12:
        if (off_1002BBCD0 == &_os_log_default) {
          off_1002BBCD0 = os_log_create("com.apple.isp", "device");
        }
        BOOL v14 = os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR);
        if (v14) {
          sub_100079514(v14, v15, v16);
        }
        fseeko(v5, 0, 2);
        ftello(v5);
        fseeko(v5, 0, 0);
        operator new[]();
      }
    }
    else if (v5)
    {
      goto LABEL_12;
    }
    perror("error loading ISPCPU firmware ");
  }
  outputStructCnt[0] = 0;
  outputStructCnt[1] = 0;
  outputStructCnt[2] = *(unsigned int *)(a1 + 4376);
  return IOConnectCallScalarMethod(*(_DWORD *)(a1 + 4424), 7u, outputStructCnt, 3u, 0, 0);
}

uint64_t sub_10005264C(uint64_t a1, char *__filename, char *a3, uint64_t a4, uint64_t a5, unsigned int a6, unsigned int a7, int a8)
{
  if (a8) {
    unsigned int v11 = a7 | 0x80000000;
  }
  else {
    unsigned int v11 = a7;
  }
  if (a3)
  {
    uint64_t v12 = fopen(a3, "rb");
    if (v12)
    {
      uint64_t v13 = v12;
      goto LABEL_9;
    }
  }
  BOOL v14 = fopen(__filename, "rb");
  if (v14)
  {
    uint64_t v13 = v14;
LABEL_9:
    fseeko(v13, 0, 2);
    ftello(v13);
    rewind(v13);
    operator new[]();
  }
  if (a4) {
    operator new[]();
  }
  uint64_t v15 = sub_1000558E0(a1, v11, 0, 0, a6);
  if (off_1002BBCD0 == &_os_log_default) {
    off_1002BBCD0 = os_log_create("com.apple.isp", "device");
  }
  if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 136316418;
    uint64_t v21 = "SendDataFileToFirmware";
    __int16 v22 = 1024;
    unsigned int v23 = a6;
    __int16 v24 = 1024;
    int v25 = 0;
    __int16 v26 = 1024;
    *(_DWORD *)int v27 = 0;
    *(_WORD *)&_OWORD v27[4] = 1024;
    *(_DWORD *)&v27[6] = a8;
    *(_WORD *)char v28 = 1024;
    *(_DWORD *)&v28[2] = v15;
    _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "%s - type=0x%X, isOverride=%d, size=%u, isEarlyBoot=%d, status=%08x\n", buf, 0x2Au);
  }
  if (off_1002BBCD0 == &_os_log_default) {
    off_1002BBCD0 = os_log_create("com.apple.isp", "device");
  }
  if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 136316674;
    uint64_t v21 = "SendDataFileToFirmware";
    __int16 v22 = 1024;
    unsigned int v23 = a6;
    __int16 v24 = 1024;
    int v25 = 0;
    __int16 v26 = 2080;
    *(void *)int v27 = __filename;
    *(_WORD *)&v27[8] = 1024;
    *(_DWORD *)char v28 = 0;
    *(_WORD *)&_OWORD v28[4] = 1024;
    int v29 = a8;
    __int16 v30 = 1024;
    int v31 = v15;
    _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "%s - type=0x%X, isOverride=%d, file=%s, size=%u, isEarlyBoot=%d, status=%08x\n", buf, 0x34u);
  }
  return v15;
}

void sub_1000529E4(uint64_t a1)
{
  CFDictionaryRef v2 = IOServiceNameMatching("AppleH16CamIn");
  io_service_t MatchingService = IOServiceGetMatchingService(kIOMasterPortDefault, v2);
  CFTypeRef v4 = IORegistryEntrySearchCFProperty(MatchingService, "IOService", @"BackCameraModuleSerialNumString", kCFAllocatorDefault, 3u);
  if (v4)
  {
    CFStringRef v5 = v4;
    if (off_1002BBCD0 == &_os_log_default) {
      off_1002BBCD0 = os_log_create("com.apple.isp", "device");
    }
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "backCameraModuleSerialNumString exists - load FDR CmCl calibration data\n\n", buf, 2u);
    }
    CFRelease(v5);
    BOOL v6 = fopen("/usr/local/share/firmware/isp/CmCl-Override.DAT", "rb");
    if (v6)
    {
      uint64_t v7 = v6;
      fseeko(v6, 0, 2);
      ftello(v7);
      fseeko(v7, 0, 0);
      operator new[]();
    }
    CFStringRef v11 = CFStringCreateWithCString(kCFAllocatorDefault, "CmCl", 0x8000100u);
    CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    CFDictionaryAddValue(Mutable, @"CopyAllowUnsealed", kCFBooleanTrue);
    AMFDRLogSetHandler();
    uint64_t v13 = AMFDRSealingMapCopyLocalDataForClass();
    if (v13)
    {
      CFDataRef v14 = (const __CFData *)v13;
      int v15 = -1431699456;
    }
    else
    {
      uint64_t v22 = *(void *)(a1 + 4384);
      if (!v22 || !*(unsigned char *)(v22 + 623) || (uint64_t v23 = AMFDRSealingManifestCopyLocalDataForClass()) == 0)
      {
        sub_1000558E0(a1, 0x80000000, 0, 0, 0xCCCC0300);
LABEL_26:
        if (v11) {
          CFRelease(v11);
        }
        if (Mutable) {
          CFRelease(Mutable);
        }
        return;
      }
      CFDataRef v14 = (const __CFData *)v23;
      int v15 = -1145372672;
    }
    BytePtr = CFDataGetBytePtr(v14);
    unsigned int Length = CFDataGetLength(v14);
    int v18 = sub_1000558E0(a1, 0x80000000, (uint64_t)BytePtr, Length, v15 | 0x300u);
    CFStringRef v19 = CFCopyDescription(v14);
    if (v19)
    {
      CFStringRef v20 = v19;
      if (off_1002BBCD0 == &_os_log_default) {
        off_1002BBCD0 = os_log_create("com.apple.isp", "device");
      }
      if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
      {
        CStringPtr = CFStringGetCStringPtr(v20, 0);
        *(_DWORD *)buf = 136315650;
        int v25 = "LoadFDRCalDataFile";
        __int16 v26 = 1024;
        int v27 = v18;
        __int16 v28 = 2080;
        int v29 = CStringPtr;
        _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "%s - Status = %#08x; CmCl data - %s\n",
          buf,
          0x1Cu);
      }
      CFRelease(v20);
    }
    CFRelease(v14);
    goto LABEL_26;
  }
  if (off_1002BBCD0 == &_os_log_default) {
    off_1002BBCD0 = os_log_create("com.apple.isp", "device");
  }
  BOOL v8 = os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR);
  if (v8) {
    sub_1000795D0(v8, v9, v10);
  }
}

void sub_100052F34(uint64_t a1)
{
  CFDictionaryRef v2 = IOServiceNameMatching("AppleH16CamIn");
  io_service_t MatchingService = IOServiceGetMatchingService(kIOMasterPortDefault, v2);
  CFTypeRef v4 = IORegistryEntrySearchCFProperty(MatchingService, "IOService", @"FrontCameraModuleSerialNumString", kCFAllocatorDefault, 3u);
  if (v4)
  {
    CFStringRef v5 = v4;
    if (off_1002BBCD0 == &_os_log_default) {
      off_1002BBCD0 = os_log_create("com.apple.isp", "device");
    }
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "FrontCameraModuleSerialNumString exists - load FDR FCCl calibration data\n\n", buf, 2u);
    }
    CFRelease(v5);
    IOObjectRelease(MatchingService);
    uint64_t v6 = 0;
    uint64_t v7 = (_DWORD *)(*(void *)(a1 + 4384) + 16);
    while (!*(v7 - 2) || *v7 != 1718775412 && *v7 != 1718776695)
    {
      v7 += 24;
      if (++v6 == 6)
      {
        LODWORD(v6) = 0;
        break;
      }
    }
    BOOL v8 = fopen("/usr/local/share/firmware/isp/FCCl-Override.DAT", "rb");
    if (v8)
    {
      uint64_t v9 = v8;
      fseeko(v8, 0, 2);
      ftello(v9);
      fseeko(v9, 0, 0);
      operator new[]();
    }
    CFStringRef v18 = CFStringCreateWithCString(kCFAllocatorDefault, "FCCl", 0x8000100u);
    CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    CFDictionaryAddValue(Mutable, @"CopyAllowUnsealed", kCFBooleanTrue);
    AMFDRLogSetHandler();
    uint64_t v20 = AMFDRSealingMapCopyLocalDataForClass();
    if (v20)
    {
      CFDataRef v21 = (const __CFData *)v20;
      int v22 = -1431699456;
    }
    else
    {
      uint64_t v28 = *(void *)(a1 + 4384);
      if (!v28 || !*(unsigned char *)(v28 + 623) || (uint64_t v29 = AMFDRSealingManifestCopyLocalDataForClass()) == 0)
      {
        sub_1000558E0(a1, v6 | 0x80000000, 0, 0, 0xCCCC0300);
LABEL_31:
        if (v18) {
          CFRelease(v18);
        }
        if (Mutable) {
          CFRelease(Mutable);
        }
        return;
      }
      CFDataRef v21 = (const __CFData *)v29;
      int v22 = -1145372672;
    }
    BytePtr = CFDataGetBytePtr(v21);
    unsigned int Length = CFDataGetLength(v21);
    int v25 = sub_1000558E0(a1, v6 | 0x80000000, (uint64_t)BytePtr, Length, v22 | 0x300u);
    CFStringRef v26 = CFCopyDescription(v21);
    if (off_1002BBCD0 == &_os_log_default) {
      off_1002BBCD0 = os_log_create("com.apple.isp", "device");
    }
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
    {
      CStringPtr = CFStringGetCStringPtr(v26, 0);
      *(_DWORD *)buf = 136315650;
      int v31 = "LoadFDRFCClDataFile";
      __int16 v32 = 1024;
      int v33 = v25;
      __int16 v34 = 2080;
      unint64_t v35 = CStringPtr;
      _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "%s - Status = %#08x; FCCl data - %s\n",
        buf,
        0x1Cu);
    }
    CFRelease(v26);
    CFRelease(v21);
    goto LABEL_31;
  }
  if (off_1002BBCD0 == &_os_log_default) {
    off_1002BBCD0 = os_log_create("com.apple.isp", "device");
  }
  BOOL v10 = os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR);
  if (v10) {
    sub_100079694(v10, v11, v12, v13, v14, v15, v16, v17);
  }
  IOObjectRelease(MatchingService);
}

void sub_1000534E4(uint64_t a1)
{
  CFDictionaryRef v2 = fopen("/var/mobile/Library/ISP/CalData/DCNUMetadata_0", "rb");
  if (v2)
  {
    fclose(v2);
    remove((const std::__fs::filesystem::path *)"/var/mobile/Library/ISP/CalData/DCNUMetadata_0", v3);
  }
  CFTypeRef v4 = fopen("/var/mobile/Library/ISP/CalData/DCNUPixbuf_0", "rb");
  if (v4)
  {
    fclose(v4);
    remove((const std::__fs::filesystem::path *)"/var/mobile/Library/ISP/CalData/DCNUPixbuf_0", v5);
  }
  CFDictionaryRef v6 = IOServiceNameMatching("AppleH16CamIn");
  io_service_t MatchingService = IOServiceGetMatchingService(kIOMainPortDefault, v6);
  unint64_t v8 = (unint64_t)IORegistryEntrySearchCFProperty(MatchingService, "IOService", @"BackCameraSNUM", kCFAllocatorDefault, 3u);
  unint64_t v9 = (unint64_t)IORegistryEntrySearchCFProperty(MatchingService, "IOService", @"BackSuperWideCameraSNUM", kCFAllocatorDefault, 3u);
  if (!(v8 | v9))
  {
    if (off_1002BBCD0 == &_os_log_default) {
      off_1002BBCD0 = os_log_create("com.apple.isp", "device");
    }
    BOOL v10 = os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR);
    if (v10) {
      sub_100079794(v10, v11, v12);
    }
    return;
  }
  uint64_t v13 = (const void *)v9;
  if (off_1002BBCD0 == &_os_log_default) {
    off_1002BBCD0 = os_log_create("com.apple.isp", "device");
  }
  if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "BackCameraSNUM/BackSuperWideCameraSNUM exists - load FDR CmPM calibration data\n\n", buf, 2u);
  }
  if (!v13)
  {
    unsigned int v32 = 0;
    if (!v8) {
      goto LABEL_17;
    }
    goto LABEL_16;
  }
  CFRelease(v13);
  unsigned int v32 = 4;
  if (v8)
  {
LABEL_16:
    CFRelease((CFTypeRef)v8);
    unsigned int v32 = 0;
  }
LABEL_17:
  AMFDRLogSetHandler();
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  CFDictionaryAddValue(Mutable, @"CopyAllowUnsealed", kCFBooleanTrue);
  CFStringRef v30 = CFStringCreateWithCString(kCFAllocatorDefault, "CmPM", 0x8000100u);
  int v31 = Mutable;
  CFDictionaryRef v15 = (const __CFDictionary *)AMFDRSealingMapCopyLocalDictForClass();
  for (uint64_t i = 0; i != 6; ++i)
  {
    if (v15)
    {
      CFStringRef v17 = CFStringCreateWithCString(kCFAllocatorDefault, off_100096C90[3 * i + 1], 0x8000100u);
      CFDataRef Value = (const __CFData *)CFDictionaryGetValue(v15, v17);
      if (Value)
      {
        CFDataRef v19 = Value;
        BytePtr = CFDataGetBytePtr(Value);
        int v21 = -1431699456;
        CFIndex Length = CFDataGetLength(v19);
        goto LABEL_23;
      }
    }
    else
    {
      CFStringRef v17 = 0;
    }
    BytePtr = 0;
    CFIndex Length = 0;
    int v21 = -859045888;
LABEL_23:
    uint64_t v23 = &off_100096C90[3 * i];
    int v24 = *((_DWORD *)v23 + 4);
    if (v24 != 771)
    {
      sub_10005264C(a1, 0, *v23, (uint64_t)BytePtr, Length, v24 | v21, v32, 1);
      if (!v17) {
        continue;
      }
LABEL_27:
      CFRelease(v17);
      continue;
    }
    int v25 = fopen(*v23, "rb");
    if (v25)
    {
      CFStringRef v26 = v25;
      fseeko(v25, 0, 2);
      ftello(v26);
      rewind(v26);
      operator new[]();
    }
    if (BytePtr)
    {
      int correction_model_from_fdr = bfpn_create_correction_model_from_fdr();
      if (off_1002BBCD0 == &_os_log_default) {
        off_1002BBCD0 = os_log_create("com.apple.isp", "device");
      }
      if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136315650;
        int v38 = "LoadFDRDataFileCMPM";
        __int16 v39 = 1024;
        LODWORD(v40[0]) = correction_model_from_fdr;
        WORD2(v40[0]) = 2048;
        *(void *)((char *)v40 + 6) = 8;
        _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "%s - uint64_t result = %d, outputPixelBufferRef = %lu\n", buf, 0x1Cu);
      }
      if (!correction_model_from_fdr)
      {
        if (mkdir("/var/mobile/Library/ISP/", 0x1FFu) && *__error() != 17)
        {
          if (off_1002BBCD0 == &_os_log_default) {
            off_1002BBCD0 = os_log_create("com.apple.isp", "device");
          }
          if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR)) {
            sub_100079948(v35, &v36);
          }
        }
        else if (mkdir("/var/mobile/Library/ISP/CalData", 0x1FFu) && *__error() != 17)
        {
          if (off_1002BBCD0 == &_os_log_default) {
            off_1002BBCD0 = os_log_create("com.apple.isp", "device");
          }
          if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR)) {
            sub_1000798F4(v33, &v34);
          }
        }
        else
        {
          uint64_t v28 = fopen("/var/mobile/Library/ISP/CalData/DCNUMetadata_0", "wb");
          if (v28)
          {
            uint64_t v29 = v28;
            fwrite(0, 1uLL, MEMORY[2], v28);
            fclose(v29);
            sub_10005264C(a1, "/var/mobile/Library/ISP/CalData/DCNUMetadata_0", 0, 0, 0, v21 | 0x304, v32, 1);
            sub_10005264C(a1, "/var/mobile/Library/ISP/CalData/DCNUPixbuf_0", 0, 0, 0, v21 | 0x303, v32, 1);
          }
          else
          {
            if (off_1002BBCD0 == &_os_log_default) {
              off_1002BBCD0 = os_log_create("com.apple.isp", "device");
            }
            if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)buf = 136315394;
              int v38 = "LoadFDRDataFileCMPM";
              __int16 v39 = 2080;
              v40[0] = "/var/mobile/Library/ISP/CalData/DCNUMetadata_0";
              _os_log_error_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR, "%s - Could not open %s file\n", buf, 0x16u);
            }
          }
        }
      }
    }
    if (v17) {
      goto LABEL_27;
    }
  }
  if (v15) {
    CFRelease(v15);
  }
  if (v30) {
    CFRelease(v30);
  }
  if (v31) {
    CFRelease(v31);
  }
}

void sub_100053EE4(uint64_t a1)
{
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  CFDictionaryRef v3 = IOServiceNameMatching("AppleH16CamIn");
  io_service_t MatchingService = IOServiceGetMatchingService(kIOMainPortDefault, v3);
  CFTypeRef v5 = IORegistryEntrySearchCFProperty(MatchingService, "IOService", @"FrontCameraModuleSerialNumString", kCFAllocatorDefault, 3u);
  if (!v5)
  {
    if (off_1002BBCD0 == &_os_log_default) {
      off_1002BBCD0 = os_log_create("com.apple.isp", "device");
    }
    BOOL v25 = os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR);
    if (v25) {
      sub_10007999C(v25, v26, v27, v28, v29, v30, v31, v32);
    }
    goto LABEL_38;
  }
  CFDictionaryRef v6 = v5;
  if (off_1002BBCD0 == &_os_log_default) {
    off_1002BBCD0 = os_log_create("com.apple.isp", "device");
  }
  if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "FrontCameraModuleSerialNumString exists - load OCCl calibration data\n\n", buf, 2u);
  }
  CFRelease(v6);
  CFTypeRef v7 = IORegistryEntrySearchCFProperty(MatchingService, "IOService", @"BackTeleCameraModuleSerialNumString", kCFAllocatorDefault, 3u);
  if (!v7)
  {
    if (off_1002BBCD0 == &_os_log_default) {
      off_1002BBCD0 = os_log_create("com.apple.isp", "device");
    }
    BOOL v33 = os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR);
    if (v33) {
      sub_100079A18(v33, v34, v35);
    }
LABEL_38:
    IOObjectRelease(MatchingService);
    return;
  }
  unint64_t v8 = v7;
  if (off_1002BBCD0 == &_os_log_default) {
    off_1002BBCD0 = os_log_create("com.apple.isp", "device");
  }
  if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "backTeleCameraModuleSerialNumString exists - load OCCl calibration data\n\n", buf, 2u);
  }
  CFRelease(v8);
  IOObjectRelease(MatchingService);
  CFStringRef v9 = CFStringCreateWithCString(kCFAllocatorDefault, "OCCl", 0x8000100u);
  AMFDRLogSetHandler();
  CFDictionaryAddValue(Mutable, @"CopyAllowUnsealed", kCFBooleanTrue);
  CFDictionaryRef v10 = (const __CFDictionary *)AMFDRSealingMapCopyLocalDictForClass();
  uint64_t v36 = a1;
  uint64_t v11 = 0;
  do
  {
    while (1)
    {
      uint64_t v12 = v11;
      uint64_t v13 = fopen(off_100096C60[3 * v11], "rb");
      if (v13)
      {
        uint64_t v14 = v13;
        fseeko(v13, 0, 2);
        ftello(v14);
        fseeko(v14, 0, 0);
        operator new[]();
      }
      if (v10) {
        break;
      }
      uint64_t v11 = 1;
      if (v12) {
        goto LABEL_26;
      }
    }
    CFDictionaryRef v15 = off_100096C60[3 * v12 + 1];
    CFStringRef v16 = CFStringCreateWithCString(kCFAllocatorDefault, v15, 0x8000100u);
    CFDataRef Value = (const __CFData *)CFDictionaryGetValue(v10, v16);
    if (Value)
    {
      CFDataRef v18 = Value;
      BytePtr = CFDataGetBytePtr(Value);
      unsigned int Length = CFDataGetLength(v18);
      int v21 = sub_1000558E0(v36, 0x80000000, (uint64_t)BytePtr, Length, off_100096C60[3 * v12 + 2]);
      CFStringRef v22 = CFCopyDescription(v18);
      if (v22)
      {
        CFStringRef v23 = v22;
        if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
        {
          CStringPtr = CFStringGetCStringPtr(v23, 0);
          *(_DWORD *)buf = 136315906;
          int v38 = "LoadOCClCalDataFile";
          __int16 v39 = 1024;
          int v40 = v21;
          __int16 v41 = 2080;
          long long v42 = v15;
          __int16 v43 = 2080;
          float v44 = CStringPtr;
          _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "%s : Status = %08x; OCCl (%s) data - %s \n",
            buf,
            0x26u);
        }
        CFRelease(v23);
      }
    }
    if (v16) {
      CFRelease(v16);
    }
    uint64_t v11 = 1;
  }
  while (!v12);
  CFRelease(v10);
LABEL_26:
  if (v9) {
    CFRelease(v9);
  }
  if (Mutable) {
    CFRelease(Mutable);
  }
}

void sub_100054540()
{
  CFStringRef v0 = (const __CFString *)MGCopyAnswer();
  if (!v0)
  {
    if (off_1002BBCD0 == &_os_log_default) {
      off_1002BBCD0 = os_log_create("com.apple.isp", "device");
    }
    BOOL v4 = os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR);
    if (v4) {
      sub_100079A58(v4, v5, v6);
    }
    return;
  }
  CFStringRef v1 = v0;
  CFIndex Length = CFStringGetLength(v0);
  if (CFStringHasSuffix(v1, @"AP"))
  {
    v3.size_t length = Length - 2;
  }
  else
  {
    if (!CFStringHasSuffix(v1, @"DEV"))
    {
      CFAllocatorRef v7 = kCFAllocatorDefault;
      goto LABEL_13;
    }
    v3.size_t length = Length - 3;
  }
  CFAllocatorRef v7 = kCFAllocatorDefault;
  if (v3.length >= 1)
  {
    v3.location = 0;
    CFStringRef v8 = CFStringCreateWithSubstring(kCFAllocatorDefault, v1, v3);
    CFRelease(v1);
    CFStringRef v1 = v8;
  }
LABEL_13:
  MutableCFDictionaryRef Copy = CFStringCreateMutableCopy(v7, 0, v1);
  CFStringLowercase(MutableCopy, 0);
  CFShow(MutableCopy);
  CFRelease(v1);
  if (MutableCopy)
  {
    long long v32 = 0u;
    long long v33 = 0u;
    long long v30 = 0u;
    long long v31 = 0u;
    long long v28 = 0u;
    long long v29 = 0u;
    long long v26 = 0u;
    long long v27 = 0u;
    long long v24 = 0u;
    long long v25 = 0u;
    long long v22 = 0u;
    long long v23 = 0u;
    long long v20 = 0u;
    long long v21 = 0u;
    memset(__s, 0, sizeof(__s));
    strcat(__s, "/System/Library/Isp/afpp/");
    CStringPtr = CFStringGetCStringPtr(MutableCopy, 0x8000100u);
    strcat(__s, CStringPtr);
    strcat(__s, "/ispane.afpp");
    CFRelease(MutableCopy);
    uint64_t v11 = fopen(__s, "rb");
    if (off_1002BBCD0 == &_os_log_default) {
      off_1002BBCD0 = os_log_create("com.apple.isp", "device");
    }
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
    {
      int v17 = 136315138;
      CFDataRef v18 = __s;
      _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "Loading file for ISP-ANE networks - %s\n", (uint8_t *)&v17, 0xCu);
    }
    uint64_t v12 = fopen("/usr/local/share/firmware/isp/ispane.afpp", "rb");
    if (v12)
    {
      uint64_t v13 = v12;
      if (off_1002BBCD0 == &_os_log_default) {
        off_1002BBCD0 = os_log_create("com.apple.isp", "device");
      }
      if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(v17) = 0;
        _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "Using override ISP-ANE AFPP file\n", (uint8_t *)&v17, 2u);
      }
      if (v11) {
        fclose(v11);
      }
      uint64_t v11 = v13;
LABEL_27:
      fseeko(v11, 0, 2);
      ftello(v11);
      fseeko(v11, 0, 0);
      operator new[]();
    }
    if (v11) {
      goto LABEL_27;
    }
    if (off_1002BBCD0 == &_os_log_default) {
      off_1002BBCD0 = os_log_create("com.apple.isp", "device");
    }
    BOOL v14 = os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR);
    if (v14) {
      sub_100079A98(v14, v15, v16);
    }
  }
}

uint64_t sub_100054A50(uint64_t a1, _DWORD *inputStruct)
{
  mach_port_t v2 = *(_DWORD *)(a1 + 4424);
  if (!v2) {
    return 3758097084;
  }
  long long v5 = 0u;
  return IOConnectCallAsyncMethod(v2, 0x28u, inputStruct[4], &reference, 8u, 0, 0, inputStruct, 0x18uLL, 0, 0, 0, 0);
}

uint64_t sub_100054AE4(uint64_t a1, mach_port_t wake_port)
{
  mach_port_t v2 = *(_DWORD *)(a1 + 4424);
  if (!v2) {
    return 3758097084;
  }
  long long v5 = 0u;
  return IOConnectCallAsyncMethod(v2, 0x29u, wake_port, &reference, 8u, 0, 0, 0, 0, 0, 0, 0, 0);
}

uint64_t sub_100054B70(uint64_t a1, mach_port_t wake_port, uint64_t a3)
{
  mach_port_t v3 = *(_DWORD *)(a1 + 4424);
  if (!v3) {
    return 3758097084;
  }
  input[0] = a3;
  input[1] = 2024;
  long long v6 = 0u;
  return IOConnectCallAsyncMethod(v3, 0x2Au, wake_port, &reference, 8u, input, 2u, 0, 0, 0, 0, 0, 0);
}

uint64_t sub_100054C08(uint64_t a1, mach_port_t wake_port, uint64_t a3)
{
  mach_port_t v3 = *(_DWORD *)(a1 + 4424);
  if (!v3) {
    return 3758097084;
  }
  input[0] = a3;
  input[1] = 2024;
  long long v6 = 0u;
  return IOConnectCallAsyncMethod(v3, 0x2Bu, wake_port, &reference, 8u, input, 2u, 0, 0, 0, 0, 0, 0);
}

uint64_t sub_100054CA0(uint64_t a1, mach_port_t wake_port)
{
  mach_port_t v2 = *(_DWORD *)(a1 + 4424);
  if (!v2) {
    return 3758097084;
  }
  long long v5 = 0u;
  return IOConnectCallAsyncMethod(v2, 0x2Eu, wake_port, &reference, 8u, 0, 0, 0, 0, 0, 0, 0, 0);
}

uint64_t sub_100054D2C(uint64_t a1, unsigned int a2, unsigned int a3)
{
  mach_port_t v3 = *(_DWORD *)(a1 + 4424);
  if (!v3) {
    return 3758097084;
  }
  input[0] = a2;
  input[1] = a3;
  return IOConnectCallScalarMethod(v3, 0x30u, input, 2u, 0, 0);
}

uint64_t sub_100054DAC(uint64_t a1, unsigned int a2)
{
  mach_port_t v2 = *(_DWORD *)(a1 + 4424);
  if (!v2) {
    return 3758097084;
  }
  uint64_t v4 = a2;
  return IOConnectCallScalarMethod(v2, 0x31u, &v4, 1u, 0, 0);
}

uint64_t sub_100054E28(uint64_t a1, void *outputStruct)
{
  size_t outputStructCnt = 3028;
  mach_port_t v2 = *(_DWORD *)(a1 + 4424);
  if (v2) {
    return IOConnectCallStructMethod(v2, 0x3Du, 0, 0, outputStruct, &outputStructCnt);
  }
  else {
    return 3758097084;
  }
}

uint64_t sub_100054E78(uint64_t a1, void *outputStruct)
{
  size_t outputStructCnt = 40;
  mach_port_t v2 = *(_DWORD *)(a1 + 4424);
  if (v2) {
    return IOConnectCallStructMethod(v2, 0x4Cu, 0, 0, outputStruct, &outputStructCnt);
  }
  else {
    return 3758097084;
  }
}

uint64_t sub_100054EC8(uint64_t a1, unsigned int a2, void *outputStruct)
{
  uint64_t result = 3758097084;
  mach_port_t v5 = *(_DWORD *)(a1 + 4424);
  if (v5)
  {
    if (outputStruct)
    {
      size_t v6 = 584;
      uint64_t input = a2;
      return IOConnectCallMethod(v5, 0x4Du, &input, 1u, 0, 0, 0, 0, outputStruct, &v6);
    }
    else
    {
      return 3758097090;
    }
  }
  return result;
}

uint64_t sub_100054F6C(uint64_t a1, unsigned int a2, void *outputStruct)
{
  size_t v5 = 8;
  mach_port_t v3 = *(_DWORD *)(a1 + 4424);
  if (!v3) {
    return 3758097084;
  }
  uint64_t input = a2;
  return IOConnectCallMethod(v3, 0x63u, &input, 1u, 0, 0, 0, 0, outputStruct, &v5);
}

uint64_t sub_100055000(uint64_t a1, void *outputStruct)
{
  size_t outputStructCnt = 16;
  mach_port_t v2 = *(_DWORD *)(a1 + 4424);
  if (v2) {
    return IOConnectCallStructMethod(v2, 0x64u, 0, 0, outputStruct, &outputStructCnt);
  }
  else {
    return 3758097084;
  }
}

uint64_t sub_100055050(uint64_t a1)
{
  uint64_t output = 0;
  uint32_t outputCnt = 1;
  uint64_t result = *(unsigned int *)(a1 + 4424);
  if (result) {
    return !IOConnectCallScalarMethod(result, 0x39u, 0, 0, &output, &outputCnt) && output == 1;
  }
  return result;
}

uint64_t sub_1000550A8(uint64_t a1, void *outputStruct)
{
  size_t outputStructCnt = 16;
  mach_port_t v2 = *(_DWORD *)(a1 + 4424);
  if (v2) {
    return IOConnectCallStructMethod(v2, 0xDu, 0, 0, outputStruct, &outputStructCnt);
  }
  else {
    return 3758097084;
  }
}

uint64_t sub_1000550F8(uint64_t a1, unsigned int a2, uint64_t a3, unsigned int a4)
{
  uint64_t v4 = 3758097084;
  if (*(_DWORD *)(a1 + 4424))
  {
    CFStringRef v9 = fopen("/usr/local/share/firmware/isp/Yonkers/YonkersPatchOverride.DAT", "rb");
    if (v9)
    {
      CFDictionaryRef v10 = v9;
      if (off_1002BBCD0 == &_os_log_default) {
        off_1002BBCD0 = os_log_create("com.apple.isp", "device");
      }
      if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "Trying to use override YonkersPatchOverride.DAT file\n", buf, 2u);
      }
      fseeko(v10, 0, 2);
      ftello(v10);
      fseeko(v10, 0, 0);
      operator new[]();
    }
    uint64_t v16 = a2;
    if (a3 && a4)
    {
      *(void *)buf = a3;
      uint64_t v15 = a4;
      return IOConnectCallScalarMethod(*(_DWORD *)(a1 + 4424), 0x41u, (const uint64_t *)buf, 3u, 0, 0);
    }
    else
    {
      if (off_1002BBCD0 == &_os_log_default) {
        off_1002BBCD0 = os_log_create("com.apple.isp", "device");
      }
      if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR) && (sub_100079B64(0, v12, v13) & 1) != 0) {
        operator delete[]();
      }
    }
  }
  return v4;
}

uint64_t sub_100055444(uint64_t a1, uint64_t a2, unsigned int a3)
{
  mach_port_t v3 = *(_DWORD *)(a1 + 4424);
  if (v3)
  {
    *(void *)size_t v6 = a2;
    *(void *)&v6[8] = a3;
    uint64_t v4 = IOConnectCallScalarMethod(v3, 0x62u, (const uint64_t *)v6, 2u, 0, 0);
  }
  else
  {
    uint64_t v4 = 3758097084;
  }
  if (off_1002BBCD0 == &_os_log_default) {
    off_1002BBCD0 = os_log_create("com.apple.isp", "device");
  }
  if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)size_t v6 = 136315394;
    *(void *)&_OWORD v6[4] = "ISP_LoadIspAneAFPPFile";
    *(_WORD *)&v6[12] = 1024;
    *(_DWORD *)&v6[14] = v4;
    _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "%s - status: %08x\n", v6, 0x12u);
  }
  return v4;
}

uint64_t sub_100055560(uint64_t a1, unsigned int a2, uint64_t a3, unsigned int a4, unsigned int a5)
{
  uint64_t v5 = 3758097084;
  if (*(_DWORD *)(a1 + 4424))
  {
    uint64_t v11 = fopen("/usr/local/share/firmware/isp/Savage/SavagePatchOverride.DAT", "rb");
    if (v11)
    {
      uint64_t v12 = v11;
      if (off_1002BBCD0 == &_os_log_default) {
        off_1002BBCD0 = os_log_create("com.apple.isp", "device");
      }
      if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "Trying to use SavagePatchOverride.DAT file\n", buf, 2u);
      }
      fseeko(v12, 0, 2);
      ftello(v12);
      fseeko(v12, 0, 0);
      operator new[]();
    }
    uint64_t v18 = a2;
    if (a3 && a4)
    {
      *(void *)buf = a3;
      uint64_t v17 = a4;
      if (sub_1000558E0(a1, a2, a3, a4, a5) != -536870212) {
        return IOConnectCallScalarMethod(*(_DWORD *)(a1 + 4424), 2u, (const uint64_t *)buf, 3u, 0, 0);
      }
    }
    else
    {
      if (off_1002BBCD0 == &_os_log_default) {
        off_1002BBCD0 = os_log_create("com.apple.isp", "device");
      }
      if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR) && (sub_100079BF4(0, v13, v14) & 1) != 0) {
        operator delete[]();
      }
    }
  }
  return v5;
}

uint64_t sub_1000558E0(uint64_t a1, int a2, uint64_t a3, unsigned int a4, unsigned int a5)
{
  mach_port_t v7 = *(_DWORD *)(a1 + 4424);
  if (v7)
  {
    uint64_t v11 = a3;
    uint64_t v12 = a4;
    uint64_t v13 = (const char *)a2;
    uint64_t v14 = a5;
    uint64_t v8 = IOConnectCallScalarMethod(v7, 0x25u, &v11, 4u, 0, 0);
  }
  else
  {
    uint64_t v8 = 3758097084;
  }
  if (off_1002BBCD0 == &_os_log_default) {
    off_1002BBCD0 = os_log_create("com.apple.isp", "device");
  }
  if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
  {
    LODWORD(v11) = 67109890;
    HIDWORD(v11) = a2 & 0x7FFFFFFF;
    CFStringRef v9 = "false";
    LOWORD(v12) = 1024;
    if (a2 < 0) {
      CFStringRef v9 = "true";
    }
    *(_DWORD *)((char *)&v12 + 2) = a5;
    HIWORD(v12) = 2080;
    uint64_t v13 = v9;
    LOWORD(v14) = 1024;
    *(_DWORD *)((char *)&v14 + 2) = v8;
    _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "Load data file: channel: %d, type: %d, isEarlyBootDataFile: %s, status: %08x\n\n", (uint8_t *)&v11, 0x1Eu);
  }
  return v8;
}

uint64_t sub_100055A40(uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4, unsigned int a5)
{
  mach_port_t v6 = *(_DWORD *)(a1 + 4424);
  if (v6)
  {
    if (a3 && a4)
    {
      *(void *)&long long buf = a3;
      *((void *)&buf + 1) = a4;
      uint64_t v21 = a2;
      uint64_t v9 = IOConnectCallScalarMethod(v6, 0x6Du, &v21, 1u, 0, 0);
      if (v9)
      {
        uint64_t v10 = v9;
        if (off_1002BBCD0 == &_os_log_default) {
          off_1002BBCD0 = os_log_create("com.apple.isp", "device");
        }
        if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
        {
          int v16 = 136315394;
          uint64_t v17 = "ISP_SavageAuth";
          __int16 v18 = 1024;
          int v19 = v10;
          uint64_t v11 = "%s: Savage Pre Auth failed, status = 0x%x\n";
LABEL_28:
          p_long long buf = (uint8_t *)&v16;
          uint32_t v13 = 18;
          goto LABEL_29;
        }
      }
      else
      {
        uint64_t v14 = sub_1000558E0(a1, a2, buf, DWORD2(buf), a5);
        if (v14)
        {
          uint64_t v10 = v14;
          if (off_1002BBCD0 == &_os_log_default) {
            off_1002BBCD0 = os_log_create("com.apple.isp", "device");
          }
          if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
          {
            int v16 = 136315394;
            uint64_t v17 = "ISP_SavageAuth";
            __int16 v18 = 1024;
            int v19 = v10;
            uint64_t v11 = "%s: Data file load failed, status = 0x%x\n";
            goto LABEL_28;
          }
        }
        else
        {
          uint64_t v10 = IOConnectCallScalarMethod(*(_DWORD *)(a1 + 4424), 0x6Eu, &v21, 1u, 0, 0);
          if (v10)
          {
            if (off_1002BBCD0 == &_os_log_default) {
              off_1002BBCD0 = os_log_create("com.apple.isp", "device");
            }
            if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
            {
              int v16 = 136315394;
              uint64_t v17 = "ISP_SavageAuth";
              __int16 v18 = 1024;
              int v19 = v10;
              uint64_t v11 = "%s: Savage Auth failed, status = 0x%x\n";
              goto LABEL_28;
            }
          }
        }
      }
    }
    else
    {
      if (off_1002BBCD0 == &_os_log_default) {
        off_1002BBCD0 = os_log_create("com.apple.isp", "device");
      }
      if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
      {
        LODWORD(buf) = 136315138;
        *(void *)((char *)&buf + 4) = "ISP_SavageAuth";
        _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "%s: Invalid data file arguments\n", (uint8_t *)&buf, 0xCu);
      }
      return 3758096385;
    }
  }
  else
  {
    if (off_1002BBCD0 == &_os_log_default) {
      off_1002BBCD0 = os_log_create("com.apple.isp", "device");
    }
    uint64_t v10 = 3758097084;
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(buf) = 136315138;
      *(void *)((char *)&buf + 4) = "ISP_SavageAuth";
      uint64_t v11 = "%s: Invalid connection\n";
      p_long long buf = (uint8_t *)&buf;
      uint32_t v13 = 12;
LABEL_29:
      _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, v11, p_buf, v13);
    }
  }
  return v10;
}

uint64_t sub_100055DE8(int a1, char *__filename, void *a3, size_t *a4)
{
  uint64_t v4 = 3758097090;
  if (a3 && a4)
  {
    *a3 = 0;
    *a4 = 0;
    uint64_t v8 = fopen(__filename, "rb");
    if (v8)
    {
      uint64_t v9 = v8;
      fseeko(v8, 0, 2);
      size_t v10 = ftello(v9);
      fseeko(v9, 0, 0);
      uint64_t v11 = malloc_type_calloc(v10, 1uLL, 0xFCA9B5AFuLL);
      if (v11)
      {
        uint64_t v12 = v11;
        size_t v13 = fread(v11, 1uLL, v10, v9);
        if (v13 == v10)
        {
          *a3 = v12;
          *a4 = v10;
          size_t v14 = v10;
        }
        else
        {
          size_t v14 = v13;
          free(v12);
        }
      }
      else
      {
        size_t v14 = 0;
      }
      fclose(v9);
      if (off_1002BBCD0 == &_os_log_default) {
        off_1002BBCD0 = os_log_create("com.apple.isp", "device");
      }
      uint64_t v4 = 0;
      if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
      {
        int v16 = 136315906;
        uint64_t v17 = "CopyFileToBuffer";
        __int16 v18 = 2080;
        int v19 = __filename;
        __int16 v20 = 2048;
        size_t v21 = v10;
        __int16 v22 = 2048;
        size_t v23 = v14;
        _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "%s - Trying to use %s: Size = %lld (== %lld ?);\n",
          (uint8_t *)&v16,
          0x2Au);
        return 0;
      }
    }
    else
    {
      return 3758097136;
    }
  }
  return v4;
}

uint64_t sub_100055FCC(uint64_t a1, uint64_t a2, const __CFDictionary *a3)
{
  uint64_t v3 = 3758097090;
  BytePtr = 0;
  CFIndex Length = 0;
  if (a2)
  {
    uint64_t v5 = *(const char **)(a2 + 8);
    if (v5)
    {
      if (*(int *)(a2 + 4) >= 1024)
      {
        long long v24 = 0u;
        long long v25 = 0u;
        memset(__str, 0, sizeof(__str));
        int v8 = snprintf(__str, 0x40uLL, "%s%s.%s", "/usr/local/share/firmware/isp/", v5, "DAT");
        int v9 = sub_100055DE8(v8, __str, &BytePtr, (size_t *)&Length);
        if (v9)
        {
          if (!a3) {
            goto LABEL_34;
          }
          CFDataRef Value = CFDictionaryGetValue(a3, *(const void **)(a2 + 16));
          if (!Value) {
            goto LABEL_34;
          }
          CFDataRef v11 = (const __CFData *)CFRetain(Value);
          if (off_1002BBCD0 == &_os_log_default) {
            off_1002BBCD0 = os_log_create("com.apple.isp", "device");
          }
          if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v12 = *(void *)(a2 + 8);
            *(_DWORD *)long long buf = 136315394;
            __int16 v20 = "SendSysConfigCalibrationDataByKey";
            __int16 v21 = 2080;
            uint64_t v22 = v12;
            _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "%s - Using %s from unit info plist\n", buf, 0x16u);
          }
          if (!v11)
          {
LABEL_34:
            CFDictionaryRef v13 = IOServiceNameMatching("AppleH16CamIn");
            io_service_t MatchingService = IOServiceGetMatchingService(kIOMasterPortDefault, v13);
            CFDataRef v11 = (const __CFData *)IORegistryEntrySearchCFProperty(MatchingService, "IOService", *(CFStringRef *)(a2 + 24), kCFAllocatorDefault, 3u);
            if (!v11) {
              return 3758097084;
            }
          }
          CFIndex Length = CFDataGetLength(v11);
          BytePtr = (void *)CFDataGetBytePtr(v11);
        }
        else
        {
          if (off_1002BBCD0 == &_os_log_default) {
            off_1002BBCD0 = os_log_create("com.apple.isp", "device");
          }
          if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)long long buf = 136315138;
            __int16 v20 = __str;
            _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "Loaded calibration file from override path: %s\n", buf, 0xCu);
          }
          CFDataRef v11 = 0;
        }
        uint64_t v3 = 0;
        if (BytePtr && Length)
        {
          uint64_t v3 = sub_1000558E0(a1, *(_DWORD *)a2 | 0x80000000, (uint64_t)BytePtr, Length, *(_DWORD *)(a2 + 4));
          if (off_1002BBCD0 == &_os_log_default) {
            off_1002BBCD0 = os_log_create("com.apple.isp", "device");
          }
          if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v15 = *(void *)(a2 + 8);
            *(_DWORD *)__str = 136315906;
            *(void *)&__str[4] = "SendSysConfigCalibrationDataByKey";
            *(_WORD *)&__str[12] = 2080;
            *(void *)&__str[14] = v15;
            *(_WORD *)&__str[22] = 2048;
            *(void *)&__str[24] = Length;
            LOWORD(v24) = 1024;
            *(_DWORD *)((char *)&v24 + 2) = v3;
            _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "%s - %s - size_t length = %ld; status = %08x\n",
              (uint8_t *)__str,
              0x26u);
          }
        }
        if (!v9 && BytePtr) {
          free(BytePtr);
        }
        if (v11) {
          CFRelease(v11);
        }
      }
    }
  }
  return v3;
}

void sub_10005634C(uint64_t a1, uint64_t a2)
{
  if (off_1002BBCD0 == &_os_log_default) {
    off_1002BBCD0 = os_log_create("com.apple.isp", "device");
  }
  if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
  {
    int v3 = 136315394;
    uint64_t v4 = "fdrLogMessages";
    __int16 v5 = 2080;
    uint64_t v6 = a2;
    _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "%s - %s\n", (uint8_t *)&v3, 0x16u);
  }
}

BOOL sub_100056430(uint64_t a1, _DWORD *a2)
{
  uint64_t v2 = 0;
  uint64_t v3 = *(void *)(a1 + 4384);
  int v4 = *(unsigned __int8 *)(v3 + 600);
  for (uint64_t i = (_DWORD *)(v3 + 16); ; i += 24)
  {
    if (*(i - 2))
    {
      if (*i == 1718776695 || *i == 1718775412) {
        break;
      }
    }
    if (++v2 == 6) {
      return v4 != 0;
    }
  }
  *a2 = v2;
  return v4 != 0;
}

BOOL sub_10005648C(uint64_t a1, _DWORD *a2)
{
  unint64_t v2 = 0;
  uint64_t v3 = (_DWORD *)(*(void *)(a1 + 4384) + 16);
  BOOL v4 = 1;
  while (*v3 != 1718186595 || *(v3 - 2) != 1)
  {
    BOOL v4 = v2 < 5;
    v3 += 24;
    if (++v2 == 6) {
      return 0;
    }
  }
  *a2 = v2;
  return v4;
}

uint64_t sub_1000564EC(uint64_t a1)
{
  uint64_t output = 0;
  uint32_t outputCnt = 1;
  uint64_t result = *(unsigned int *)(a1 + 4424);
  if (result)
  {
    if (IOConnectCallScalarMethod(result, 0x53u, 0, 0, &output, &outputCnt)) {
      BOOL v2 = 1;
    }
    else {
      BOOL v2 = output == 0;
    }
    return !v2;
  }
  return result;
}

uint64_t sub_100056544(uint64_t result, _DWORD *a2)
{
  if (a2) {
    *a2 = *(_DWORD *)(*(void *)(result + 4384) + 616);
  }
  return result;
}

unint64_t sub_100056558(uint64_t a1, int a2)
{
  uint64_t v2 = *(unsigned int *)(a1 + 4748);
  if (!v2) {
    return 0xFFFFFFFFLL;
  }
  unint64_t result = 0;
  for (uint64_t i = 8; ; i += 96)
  {
    if (result <= 5 && (uint64_t v6 = *(void *)(a1 + 4384), *(_DWORD *)(v6 + i))) {
      int v7 = *(_DWORD *)(v6 + i + 8);
    }
    else {
      int v7 = -1;
    }
    if (v7 == a2) {
      break;
    }
    if (v2 == ++result) {
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

uint64_t sub_1000565B0(uint64_t a1, BOOL *a2)
{
  uint64_t output = 0;
  uint32_t outputCnt = 1;
  mach_port_t v2 = *(_DWORD *)(a1 + 4424);
  if (!v2) {
    return 3758097084;
  }
  uint64_t v4 = IOConnectCallScalarMethod(v2, 0x5Cu, 0, 0, &output, &outputCnt);
  if (v4)
  {
    if (off_1002BBCD0 == &_os_log_default) {
      off_1002BBCD0 = os_log_create("com.apple.isp", "device");
    }
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR)) {
      sub_100079C84();
    }
  }
  else
  {
    *a2 = output != 0;
  }
  return v4;
}

uint64_t sub_10005667C(uint64_t a1, unsigned int a2, unsigned int a3, void *outputStruct)
{
  mach_port_t v4 = *(_DWORD *)(a1 + 4424);
  if (!v4) {
    return 3758097084;
  }
  input[0] = a2;
  input[1] = a3;
  size_t v6 = 72;
  return IOConnectCallMethod(v4, 0x66u, input, 2u, 0, 0, 0, 0, outputStruct, &v6);
}

uint64_t sub_100056714(uint64_t result)
{
  CFStringRef v1 = *(uint64_t (**)(void))(result + 56);
  if (v1) {
    return v1();
  }
  return result;
}

uint64_t sub_100056734(uint64_t a1, _DWORD *a2)
{
  mach_port_t v2 = *(_DWORD *)(a1 + 4424);
  if (!v2) {
    return 3758097084;
  }
  uint64_t output = 0;
  uint32_t outputCnt = 1;
  uint64_t result = IOConnectCallScalarMethod(v2, 0x22u, 0, 0, &output, &outputCnt);
  if (!result) {
    *a2 = output;
  }
  return result;
}

uint64_t sub_1000567A0(uint64_t a1, _DWORD *a2)
{
  mach_port_t v2 = *(_DWORD *)(a1 + 4424);
  if (!v2) {
    return 3758097084;
  }
  uint64_t output = 0;
  uint32_t outputCnt = 1;
  uint64_t result = IOConnectCallScalarMethod(v2, 0x23u, 0, 0, &output, &outputCnt);
  if (!result) {
    *a2 = output;
  }
  return result;
}

uint64_t sub_10005680C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  size_t v6 = (pthread_mutex_t *)(a1 + 4432);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 4432));
  if (*(_DWORD *)(a1 + 4424))
  {
    pthread_mutex_unlock(v6);
    return 3758097093;
  }
  else
  {
    unsigned int v8 = IOServiceOpen(*(_DWORD *)(a1 + 4416), mach_task_self_, 0x2Au, (io_connect_t *)(a1 + 4424));
    mach_port_t v9 = *(_DWORD *)(a1 + 4424);
    if (v9) {
      uint64_t v7 = v8;
    }
    else {
      uint64_t v7 = 3758097084;
    }
    if (!v7)
    {
      uint64_t v12 = 0;
      uint64_t v7 = IOConnectCallScalarMethod(v9, 3u, &v12, 1u, 0, 0);
      if (!v7)
      {
        *(void *)(a1 + 56) = a2;
        *(void *)(a1 + 64) = a3;
        sub_100056734(a1, (_DWORD *)(a1 + 4392));
        sub_1000567A0(a1, (_DWORD *)(a1 + 80));
        uint64_t v10 = sub_1000565B0(a1, (BOOL *)(a1 + 4368));
        if (v10)
        {
          uint64_t v7 = v10;
          *(unsigned char *)(a1 + 4368) = 0;
        }
        else
        {
          uint64_t v7 = sub_100056964((_DWORD *)a1);
        }
      }
    }
    pthread_mutex_unlock(v6);
  }
  return v7;
}

uint64_t sub_100056964(_DWORD *a1)
{
  mach_msg_type_number_t task_info_outCnt = 8;
  pid_t v2 = getpid();
  if (proc_pidpath(v2, a1 + 57, 0x1000u) <= 0)
  {
    if (off_1002BBCD0 == &_os_log_default) {
      off_1002BBCD0 = os_log_create("com.apple.isp", "device");
    }
    uint64_t v3 = 3758097084;
    BOOL v12 = os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR);
    if (v12) {
      sub_100079D00(v12, v13, v14, v15, v16, v17, v18, v19);
    }
  }
  else if (task_info(mach_task_self_, 0xFu, a1 + 1081, &task_info_outCnt))
  {
    if (off_1002BBCD0 == &_os_log_default) {
      off_1002BBCD0 = os_log_create("com.apple.isp", "device");
    }
    uint64_t v3 = 3758097084;
    BOOL v4 = os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR);
    if (v4) {
      sub_100079E74(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  else
  {
    if (off_1002BBCD0 == &_os_log_default) {
      off_1002BBCD0 = os_log_create("com.apple.isp", "device");
    }
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEBUG)) {
      sub_100079D7C((uint64_t)(a1 + 57), a1 + 1081, a1);
    }
    return 0;
  }
  return v3;
}

uint64_t sub_100056AD4(uint64_t a1, unsigned int a2)
{
  mach_port_t v2 = *(_DWORD *)(a1 + 4424);
  if (!v2) {
    return 3758097084;
  }
  uint64_t v4 = a2;
  return IOConnectCallScalarMethod(v2, 0, &v4, 1u, 0, 0);
}

uint64_t sub_100056B50(uint64_t a1, unsigned int a2)
{
  mach_port_t v2 = *(_DWORD *)(a1 + 4424);
  if (!v2) {
    return 3758097084;
  }
  uint64_t v4 = a2;
  return IOConnectCallScalarMethod(v2, 1u, &v4, 1u, 0, 0);
}

uint64_t sub_100056BCC(uint64_t a1, unsigned int a2)
{
  mach_port_t v2 = *(_DWORD *)(a1 + 4424);
  if (!v2) {
    return 3758097084;
  }
  uint64_t v4 = a2;
  return IOConnectCallScalarMethod(v2, 0x3Fu, &v4, 1u, 0, 0);
}

uint64_t sub_100056C48(uint64_t a1, unsigned int a2)
{
  mach_port_t v2 = *(_DWORD *)(a1 + 4424);
  if (!v2) {
    return 3758097084;
  }
  uint64_t v4 = a2;
  return IOConnectCallScalarMethod(v2, 0x40u, &v4, 1u, 0, 0);
}

uint64_t sub_100056CC4(uint64_t a1, uint64_t a2)
{
  mach_port_t v2 = *(_DWORD *)(a1 + 4424);
  if (!v2) {
    return 3758097111;
  }
  uint64_t v4 = a2;
  return IOConnectCallScalarMethod(v2, 0x60u, &v4, 1u, 0, 0);
}

uint64_t sub_100056D3C(uint64_t a1, uint64_t a2)
{
  mach_port_t v2 = *(_DWORD *)(a1 + 4424);
  if (!v2) {
    return 3758097111;
  }
  uint64_t v4 = a2;
  return IOConnectCallScalarMethod(v2, 0x61u, &v4, 1u, 0, 0);
}

void sub_100056DB4(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint8_t *a5)
{
  _os_log_error_impl(a1, a2, OS_LOG_TYPE_ERROR, a4, a5, 2u);
}

unsigned char *sub_100056DCC(unsigned char *result, unsigned char *a2)
{
  *uint64_t result = 0;
  *a2 = 0;
  return result;
}

void sub_100056E04(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint8_t *a5)
{
  _os_log_error_impl(a1, a2, OS_LOG_TYPE_ERROR, a4, a5, 8u);
}

void sub_100056E1C(uint64_t a1@<X8>)
{
  *(void *)(v1 - 8) = a1;
}

void sub_100056E28(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_error_impl(a1, a2, OS_LOG_TYPE_ERROR, a4, &a9, 0x18u);
}

uint64_t sub_100056E50()
{
  return 0;
}

uint64_t sub_100056E58()
{
  return 0;
}

uint64_t sub_100056E60(uint64_t a1, _DWORD *a2, double *a3)
{
  return 0;
}

_DWORD *sub_100056E84(_DWORD *result, double *a2)
{
  int v2 = *(_DWORD *)a2;
  if (*(_DWORD *)a2)
  {
    if (v2 == 1)
    {
      double v3 = a2[1];
      if (v3 < 49.0 || v3 > 51.0)
      {
        if (v3 < 59.0 || v3 > 61.0)
        {
          if (v3 <= 100.0)
          {
            ++result[35];
          }
          else if (v3 <= 300.0)
          {
            ++result[36];
          }
          else if (v3 <= 500.0)
          {
            ++result[37];
          }
          else
          {
            ++result[38];
          }
        }
        else
        {
          ++result[34];
        }
      }
      else
      {
        ++result[33];
      }
    }
    else if (v2 == 3)
    {
      ++result[32];
    }
  }
  else
  {
    ++result[39];
  }
  return result;
}

void sub_100056F90(uint64_t a1)
{
  unint64_t v2 = 0;
  double v3 = v12;
  v12[0] = 0;
  _DWORD v12[2] = 0;
  uint64_t v11 = sub_1000469E4;
  v12[1] = sub_100046D74;
  _OWORD v12[3] = sub_100047BF0;
  void v12[4] = 0;
  do
  {
    uint64_t v4 = (uint64_t (*)(void *))*(v3 - 1);
    uint64_t v5 = (void *)(*(void *)(a1 + 80) + (*v3 >> 1));
    if (*v3) {
      uint64_t v4 = *(uint64_t (**)(void *))(*v5 + v4);
    }
    int v6 = v4(v5);
    if (v2 > 1) {
      break;
    }
    v3 += 2;
    ++v2;
  }
  while (!v6);
  if (v6)
  {
    os_log_t v7 = (os_log_t)off_1002BBCE0;
    if (off_1002BBCE0 == &_os_log_default)
    {
      os_log_t v7 = os_log_create("com.apple.isp", "daemon");
      off_1002BBCE0 = v7;
    }
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR)) {
      sub_10007A028();
    }
  }
  if (sub_10004770C(*(void *)(a1 + 80), a1 + 160))
  {
    os_log_t v8 = (os_log_t)off_1002BBCE0;
    if (off_1002BBCE0 == &_os_log_default)
    {
      os_log_t v8 = os_log_create("com.apple.isp", "daemon");
      off_1002BBCE0 = v8;
    }
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR)) {
      sub_100079FC0();
    }
  }
  if (sub_1000478F8())
  {
    os_log_t v9 = (os_log_t)off_1002BBCE0;
    if (off_1002BBCE0 == &_os_log_default)
    {
      os_log_t v9 = os_log_create("com.apple.isp", "daemon");
      off_1002BBCE0 = v9;
    }
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR)) {
      sub_100079F58();
    }
  }
  if (sub_100046BB0())
  {
    os_log_t v10 = (os_log_t)off_1002BBCE0;
    if (off_1002BBCE0 == &_os_log_default)
    {
      os_log_t v10 = os_log_create("com.apple.isp", "daemon");
      off_1002BBCE0 = v10;
    }
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR)) {
      sub_100079EF0();
    }
  }
}

void sub_1000571F8(uint64_t a1)
{
  uint64_t v1 = a1 + 8;
  uint64_t v2 = *(void *)(a1 + 16);
  if (v2 != a1 + 8)
  {
    do
    {
      uint64_t v3 = *(void *)(v2 + 16);
      if (*(_DWORD *)(v3 + 8) == 1)
      {
        os_log_t v4 = (os_log_t)off_1002BBCE0;
        if (off_1002BBCE0 == &_os_log_default)
        {
          os_log_t v4 = os_log_create("com.apple.isp", "daemon");
          off_1002BBCE0 = v4;
        }
        if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
        {
          pid_t pid = xpc_connection_get_pid(*(xpc_connection_t *)v3);
          int v6 = *(const char **)(v3 + 24);
          if (!v6) {
            int v6 = "<null>";
          }
          *(_DWORD *)long long buf = 67174915;
          pid_t v8 = pid;
          __int16 v9 = 2081;
          os_log_t v10 = v6;
          _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Active client pid %{private}d deviceID %{private}s\n", buf, 0x12u);
        }
      }
      uint64_t v2 = *(void *)(v2 + 8);
    }
    while (v2 != v1);
  }
}

uint64_t sub_100057348(uint64_t a1, uint64_t a2, xpc_object_t object)
{
  uint64_t v3 = 3758097090;
  if (*(void *)(a2 + 24))
  {
    os_log_t v4 = (os_log_t)off_1002BBCE0;
    if (off_1002BBCE0 == &_os_log_default)
    {
      os_log_t v4 = os_log_create("com.apple.isp", "daemon");
      off_1002BBCE0 = v4;
    }
    uint64_t v3 = 3758097131;
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR)) {
      sub_10007A090(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  else if (object && xpc_get_type(object) == (xpc_type_t)&_xpc_type_string)
  {
    size_t v16 = xpc_string_get_length(object) + 1;
    uint64_t v17 = malloc_type_malloc(v16, 0xAE92CD7AuLL);
    *(void *)(a2 + 24) = v17;
    if (v17)
    {
      uint64_t v18 = v17;
      string_ptr = xpc_string_get_string_ptr(object);
      memcpy(v18, string_ptr, v16);
      sub_1000571F8(a1);
      return 0;
    }
    else
    {
      return 3758097085;
    }
  }
  return v3;
}

void sub_10005745C(void *a1, uint64_t a2)
{
  if (a2)
  {
    os_log_t v4 = a1 + 1;
    if (!a1[3]) {
      a1[6] = os_transaction_create();
    }
    uint64_t v5 = operator new(0x18uLL);
    v5[1] = v4;
    v5[2] = a2;
    uint64_t v6 = a1[1];
    *uint64_t v5 = v6;
    *(void *)(v6 + 8) = v5;
    a1[1] = v5;
    uint64_t v7 = (void *)a1[2];
    ++a1[3];
    if (v7 == v4)
    {
      BOOL v9 = 0;
    }
    else
    {
      do
      {
        int v8 = *(_DWORD *)(v7[2] + 8);
        BOOL v9 = v8 == 1;
        if (v8 == 1) {
          break;
        }
        uint64_t v7 = (void *)v7[1];
      }
      while (v7 != v4);
    }
    uint64_t v10 = a1[86];
    if (v10) {
      sub_10001DF08(v10, !v9);
    }
    if (v9 && !a1[73] && byte_1002BBE68)
    {
      uint64_t v11 = a1[75];
      block[0] = _NSConcreteStackBlock;
      block[1] = 0x40000000;
      block[2] = sub_100057744;
      block[3] = &unk_10009D4D0;
      block[4] = a1;
      dispatch_sync(v11, block);
    }
    if (*(_DWORD *)(a2 + 8) == 1 && (pid_t pid = xpc_connection_get_pid(*(xpc_connection_t *)a2)) != 0)
    {
      os_log_t v13 = (os_log_t)off_1002BBCE0;
      if (off_1002BBCE0 == &_os_log_default)
      {
        os_log_t v13 = os_log_create("com.apple.isp", "daemon");
        off_1002BBCE0 = v13;
      }
      if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)long long buf = 67174657;
        LODWORD(v19) = pid;
        _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "New connection: pid %{private}d\n", buf, 8u);
      }
    }
    else
    {
      os_log_t v14 = (os_log_t)off_1002BBCE0;
      if (off_1002BBCE0 == &_os_log_default)
      {
        os_log_t v14 = os_log_create("com.apple.isp", "daemon");
        off_1002BBCE0 = v14;
      }
      if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "New connection: kernel\n", buf, 2u);
      }
    }
    kdebug_trace();
    os_log_t v15 = (os_log_t)off_1002BBCE0;
    if (off_1002BBCE0 == &_os_log_default)
    {
      os_log_t v15 = os_log_create("com.apple.isp", "daemon");
      off_1002BBCE0 = v15;
    }
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v16 = a1[3];
      *(_DWORD *)long long buf = 134217984;
      uint64_t v19 = v16;
      _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "Total number of connections: %lu\n", buf, 0xCu);
    }
  }
}

void sub_100057744(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  uint64_t v2 = *(void *)(v1 + 592);
  if (v2)
  {
    int v3 = sub_10001538C(v2);
    os_log_t v4 = (os_log_t)off_1002BBCE0;
    if (off_1002BBCE0 == &_os_log_default)
    {
      os_log_t v4 = os_log_create("com.apple.isp", "daemon");
      off_1002BBCE0 = v4;
    }
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      int v7 = 136315394;
      int v8 = "addClient_block_invoke";
      __int16 v9 = 1024;
      int v10 = v3;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "%s - Photon Detector device open returned %x\n\n", (uint8_t *)&v7, 0x12u);
    }
    int v5 = sub_100015410(*(void *)(v1 + 592));
    os_log_t v6 = (os_log_t)off_1002BBCE0;
    if (off_1002BBCE0 == &_os_log_default)
    {
      os_log_t v6 = os_log_create("com.apple.isp", "daemon");
      off_1002BBCE0 = v6;
    }
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      int v7 = 136315394;
      int v8 = "addClient_block_invoke";
      __int16 v9 = 1024;
      int v10 = v5;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "%s - Photon Detector power on device returned %x\n\n", (uint8_t *)&v7, 0x12u);
    }
    if (!v5) {
      *(unsigned char *)(v1 + 672) = 1;
    }
  }
  operator new();
}

void sub_100057918()
{
}

uint64_t sub_100057944(uint64_t result, void *a2)
{
  long long v33 = a2;
  if (!a2) {
    return result;
  }
  uint64_t v2 = result;
  uint64_t v3 = result + 8;
  sub_100057E50(result + 8, &v33);
  os_log_t v4 = *(H16ISPRgbJRunner **)(v2 + 568);
  if (v4 && H16ISPRgbJRunner::isContext(v4, v33))
  {
    H16ISPRgbJRunner::finalize(*(H16ISPRgbJRunner **)(v2 + 568));
    int v5 = *(H16ISPRgbJRunner **)(v2 + 568);
    if (v5)
    {
      H16ISPRgbJRunner::~H16ISPRgbJRunner(v5);
      operator delete();
    }
    *(void *)(v2 + 568) = 0;
  }
  uint64_t v6 = *(void *)(v2 + 576);
  if (v6)
  {
    BOOL v7 = sub_10002F350(v6, (uint64_t)v33);
    uint64_t v8 = *(void *)(v2 + 576);
    if (v7)
    {
      uint64_t v9 = *(void *)v8;
      if (*(unsigned char *)(v8 + 9))
      {
        (*(void (**)(void))(v9 + 16))();
        goto LABEL_16;
      }
      (*(void (**)(void))(v9 + 8))();
    }
    else
    {
      if (!sub_10002DFAC(v8)) {
        goto LABEL_16;
      }
      int v10 = *(unsigned char **)(v2 + 576);
      if (v10[9]) {
        goto LABEL_16;
      }
      (*(void (**)(unsigned char *))(*(void *)v10 + 8))(v10);
    }
    *(void *)(v2 + 576) = 0;
  }
LABEL_16:
  uint64_t v11 = *(void *)(v2 + 16);
  if (v11 == v3)
  {
    BOOL v13 = 0;
  }
  else
  {
    do
    {
      int v12 = *(_DWORD *)(*(void *)(v11 + 16) + 8);
      BOOL v13 = v12 == 1;
      if (v12 == 1) {
        break;
      }
      uint64_t v11 = *(void *)(v11 + 8);
    }
    while (v11 != v3);
  }
  uint64_t v14 = *(void *)(v2 + 688);
  if (v14) {
    sub_10001DF08(v14, !v13);
  }
  if (*(void *)(v2 + 584))
  {
    os_log_t v15 = (int *)(*(void *)(*(void *)(v2 + 72) + 4384) + 16);
    uint64_t v16 = 12;
    while (1)
    {
      int v18 = *v15;
      v15 += 24;
      int v17 = v18;
      if (v18 != 1785950322) {
        break;
      }
      if (*((unsigned char *)v33 + v16))
      {
        int v19 = 5;
LABEL_31:
        sub_10003204C(*(void *)(v2 + 584), v19);
      }
LABEL_32:
      if (++v16 == 18)
      {
        __int16 v20 = *(NSObject **)(v2 + 600);
        block[0] = _NSConcreteStackBlock;
        block[1] = 0x40000000;
        block[2] = sub_100057F30;
        block[3] = &unk_10009D4F0;
        block[4] = v2;
        BOOL v32 = v13;
        dispatch_sync(v20, block);
        goto LABEL_34;
      }
    }
    if (v17 != 1718186595 || !*((unsigned char *)v33 + v16)) {
      goto LABEL_32;
    }
    int v19 = 3;
    goto LABEL_31;
  }
LABEL_34:
  if (*((_DWORD *)v33 + 2) == 1 && (pid_t pid = xpc_connection_get_pid(*(xpc_connection_t *)v33)) != 0)
  {
    xpc_release(*(xpc_object_t *)v33);
    os_log_t v22 = (os_log_t)off_1002BBCE0;
    if (off_1002BBCE0 == &_os_log_default)
    {
      os_log_t v22 = os_log_create("com.apple.isp", "daemon");
      off_1002BBCE0 = v22;
    }
    if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 67174657;
      *(_DWORD *)&uint8_t buf[4] = pid;
      _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "Removing client: pid %{private}d\n", buf, 8u);
    }
  }
  else
  {
    os_log_t v23 = (os_log_t)off_1002BBCE0;
    if (off_1002BBCE0 == &_os_log_default)
    {
      os_log_t v23 = os_log_create("com.apple.isp", "daemon");
      off_1002BBCE0 = v23;
    }
    if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "Removing client: kernel\n", buf, 2u);
    }
  }
  os_log_t v24 = (os_log_t)off_1002BBCE0;
  if (off_1002BBCE0 == &_os_log_default)
  {
    os_log_t v24 = os_log_create("com.apple.isp", "daemon");
    off_1002BBCE0 = v24;
  }
  if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v25 = *(void *)(v2 + 24);
    *(_DWORD *)long long buf = 134217984;
    *(void *)&uint8_t buf[4] = v25;
    _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "Total number of connections: %lu\n", buf, 0xCu);
  }
  sub_1000571F8(v2);
  if (!*(void *)(v2 + 24))
  {
    if (*(void *)(v2 + 72))
    {
      uint64_t v26 = 0;
      uint64_t v27 = 0;
      uint64_t v28 = 280;
      do
      {
        if (sub_100054F6C(*(void *)(v2 + 72), v26, buf)) {
          break;
        }
        v27 += *(void *)buf;
        *(void *)(v2 + v28) = *(void *)buf;
        ++v26;
        v28 += 56;
      }
      while (v26 != 6);
      if (v27)
      {
        if (*(void *)(v2 + 80)) {
          sub_100056F90(v2);
        }
        uint64_t v29 = *(void *)(v2 + 112);
        if (v29) {
          sub_10000610C(v29);
        }
      }
    }
    *(void *)(v2 + 560) = 0;
    *(_OWORD *)(v2 + 528) = 0u;
    *(_OWORD *)(v2 + 544) = 0u;
    *(_OWORD *)(v2 + 496) = 0u;
    *(_OWORD *)(v2 + 512) = 0u;
    *(_OWORD *)(v2 + 464) = 0u;
    *(_OWORD *)(v2 + 480) = 0u;
    *(_OWORD *)(v2 + 432) = 0u;
    *(_OWORD *)(v2 + 448) = 0u;
    *(_OWORD *)(v2 + 400) = 0u;
    *(_OWORD *)(v2 + 416) = 0u;
    *(_OWORD *)(v2 + 368) = 0u;
    *(_OWORD *)(v2 + 384) = 0u;
    *(_OWORD *)(v2 + 336) = 0u;
    *(_OWORD *)(v2 + 352) = 0u;
    *(_OWORD *)(v2 + 304) = 0u;
    *(_OWORD *)(v2 + 320) = 0u;
    *(_OWORD *)(v2 + 272) = 0u;
    *(_OWORD *)(v2 + 288) = 0u;
    *(_OWORD *)(v2 + 240) = 0u;
    *(_OWORD *)(v2 + 256) = 0u;
    *(_OWORD *)(v2 + 208) = 0u;
    *(_OWORD *)(v2 + 224) = 0u;
    *(_OWORD *)(v2 + 176) = 0u;
    *(_OWORD *)(v2 + 192) = 0u;
    *(_OWORD *)(v2 + 144) = 0u;
    *(_OWORD *)(v2 + 160) = 0u;
    *(_OWORD *)(v2 + 128) = 0u;
    long long v30 = *(void **)(v2 + 48);
    if (v30)
    {
      os_release(v30);
      *(void *)(v2 + 48) = 0;
    }
  }
  uint64_t result = kdebug_trace();
  if (v33)
  {
    free(*((void **)v33 + 3));
    operator delete();
  }
  return result;
}

uint64_t sub_100057E50(uint64_t a1, void *a2)
{
  v11[0] = (uint64_t)v11;
  v11[1] = (uint64_t)v11;
  uint64_t v12 = 0;
  uint64_t v2 = *(void **)(a1 + 8);
  if (v2 == (void *)a1)
  {
    uint64_t v9 = 0;
  }
  else
  {
    do
    {
      uint64_t v6 = (void *)v2[1];
      uint64_t v5 = v2[2];
      if (v5 == *a2)
      {
        if (v6 == (void *)a1)
        {
          BOOL v8 = 1;
LABEL_8:
          uint64_t v6 = (void *)a1;
        }
        else
        {
          while (1)
          {
            uint64_t v7 = v6[2];
            BOOL v8 = v7 == v5;
            if (v7 != v5) {
              break;
            }
            uint64_t v6 = (void *)v6[1];
            if (v6 == (void *)a1) {
              goto LABEL_8;
            }
          }
        }
        sub_10005C06C((uint64_t)v11, v11, a1, v2, v6);
        if (!v8) {
          uint64_t v6 = (void *)v6[1];
        }
      }
      uint64_t v2 = v6;
    }
    while (v6 != (void *)a1);
    uint64_t v9 = v12;
  }
  sub_10005C008(v11);
  return v9;
}

void sub_100057F1C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_10005C008((uint64_t *)va);
  _Unwind_Resume(a1);
}

uint64_t sub_100057F30(uint64_t result)
{
  if (!*(unsigned char *)(result + 40))
  {
    uint64_t v1 = *(void *)(result + 32);
    uint64_t v2 = *(void *)(v1 + 592);
    if (v2)
    {
      *(unsigned char *)(v1 + 672) = 0;
      sub_100015428(v2);
      sub_1000153F8(*(void *)(v1 + 592));
    }
    uint64_t result = *(void *)(v1 + 584);
    if (result)
    {
      sub_100031D80(result);
      operator delete();
    }
  }
  return result;
}

void sub_100057F94(void *a1)
{
  uint64_t v2 = a1 + 1;
  for (uint64_t i = (void *)a1[2]; i != v2; uint64_t i = (void *)i[1])
  {
    uint64_t v4 = i[2];
    if (*(_DWORD *)(v4 + 8) == 1)
    {
      xpc_release(*(xpc_object_t *)v4);
      uint64_t v4 = i[2];
      if (!v4) {
        continue;
      }
    }
    free(*(void **)(v4 + 24));
    operator delete();
  }
  sub_10005C008(v2);
  uint64_t v5 = (void *)a1[6];
  if (v5)
  {
    os_release(v5);
    a1[6] = 0;
  }
}

uint64_t sub_10005802C()
{
  uint64_t v0 = __chkstk_darwin();
  uint64_t v2 = v1;
  uint64_t v4 = v3;
  uint64_t v5 = v0;
  os_log_t v6 = (os_log_t)off_1002BBCE0;
  if (off_1002BBCE0 == &_os_log_default)
  {
    os_log_t v6 = os_log_create("com.apple.isp", "daemon");
    off_1002BBCE0 = v6;
  }
  if (os_log_type_enabled(v6, OS_LOG_TYPE_INFO))
  {
    int v7 = *v2;
    LODWORD(v125[0]) = 136315394;
    *(CVPixelBufferRef *)((char *)v125 + 4) = (CVPixelBufferRef)"setProperty";
    WORD2(v125[1]) = 1024;
    *(_DWORD *)((char *)&v125[1] + 6) = v7;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_INFO, "%s - %d\n", (uint8_t *)v125, 0x12u);
  }
  kdebug_trace();
  int v8 = *v2;
  uint64_t v9 = 0;
  switch(*v2)
  {
    case 1:
      goto LABEL_90;
    case 2:
      uint64_t v10 = sub_100059120((void *)v5, (uint64_t)v4, v2[2], *((unsigned char *)v2 + 12));
      goto LABEL_66;
    case 3:
      if (sub_100009BEC(v2 + 2)) {
        uint64_t v9 = 0;
      }
      else {
        uint64_t v9 = 3758097084;
      }
      goto LABEL_90;
    case 4:
      sub_100013924(v2 + 912);
      uint64_t v12 = fopen("/var/mobile/Library/ISP/Pearl/IsfHistory.bin.bak", "wb");
      if (v12)
      {
        fwrite(v2 + 2, 0xE38uLL, 1uLL, v12);
        fclose(v12);
        rename((const std::__fs::filesystem::path *)"/var/mobile/Library/ISP/Pearl/IsfHistory.bin.bak", (const std::__fs::filesystem::path *)"/var/mobile/Library/ISP/Pearl/IsfHistory.bin", v13);
      }
      goto LABEL_89;
    case 5:
    case 6:
    case 11:
    case 18:
    case 19:
      goto LABEL_56;
    case 7:
      CFDataRef v14 = sub_1000232B8(*((void **)v2 + 1));
      os_log_t v15 = (const void *)PDPeridotCalibCreateWithBinaryRepresentation();
      CFRelease(v14);
      if (!v15) {
        goto LABEL_56;
      }
      uint64_t v9 = sub_100009B28(v15);
      CFRelease(v15);
      goto LABEL_90;
    case 8:
      uint64_t v16 = *(void *)(v5 + 568);
      if (!v16) {
        operator new();
      }
      H16ISPRgbJRunner::setVerbose(v16, *((unsigned char *)v2 + 48));
      uint64_t v9 = 3758097084;
      if (H16ISPRgbJRunner::isContext(*(H16ISPRgbJRunner **)(v5 + 568), v4))
      {
        int v17 = IOSurfaceLookupFromXPCObject(*((xpc_object_t *)v2 + 1));
        int v18 = v17;
        if (v17)
        {
          v125[0] = 0;
          IOSurfaceLock(v17, 0, 0);
          CVPixelBufferCreateWithIOSurface(kCFAllocatorDefault, v18, 0, v125);
          H16ISPRgbJRunner::setSensorVersion(*(void *)(v5 + 568), v2[17]);
          CFDataRef v19 = sub_1000232B8(*((void **)v2 + 3));
          CFDataRef v20 = sub_1000232B8(*((void **)v2 + 5));
          CFDataRef buffer = sub_1000232B8(*((void **)v2 + 4));
          CFDataRef v109 = sub_1000232B8(*((void **)v2 + 2));
          if (v19)
          {
            if (v20)
            {
              if (buffer)
              {
                int theDict = *((unsigned __int8 *)v2 + 72);
                int cf = H16ISPRgbJRunner::configureLowFrameIntervalMode(*(H16ISPRgbJRunner **)(v5 + 568), *((unsigned char *)v2 + 72), v2[22], v2[19], v2[20], v2[21]);
                uint64_t v9 = H16ISPRgbJRunner::runPipeline(*(void *)(v5 + 568), v125[0], v109, v19, buffer, v20, v2[14], *((_WORD *)v2 + 30), v2[16], v2[13]);
                if (!v9)
                {
                  if (H16ISPRgbJRunner::isRgbjDynamicFrameRate(*(H16ISPRgbJRunner **)(v5 + 568)))
                  {
                    if (((theDict != 0) & (cf ^ 1)) != 0) {
                      unsigned int v21 = 4;
                    }
                    else {
                      unsigned int v21 = 0;
                    }
                    if (cf) {
                      unsigned int v22 = 5;
                    }
                    else {
                      unsigned int v22 = 0;
                    }
                    if (theDict) {
                      uint64_t v9 = v21;
                    }
                    else {
                      uint64_t v9 = v22;
                    }
                  }
                  else
                  {
                    uint64_t v9 = 0;
                  }
                }
              }
            }
          }
          CFRelease(v19);
          CFRelease(v20);
          CFRelease(buffer);
          CFRelease(v109);
          CVPixelBufferRelease(v125[0]);
          IOSurfaceUnlock(v18, 0, 0);
          CFRelease(v18);
        }
      }
      else
      {
        os_log_t v58 = (os_log_t)off_1002BBCE0;
        if (off_1002BBCE0 == &_os_log_default)
        {
          os_log_t v58 = os_log_create("com.apple.isp", "daemon");
          off_1002BBCE0 = v58;
        }
        if (os_log_type_enabled(v58, OS_LOG_TYPE_ERROR)) {
          sub_10007A174((uint64_t)v4, v58, v59, v60, v61, v62, v63, v64);
        }
      }
      goto LABEL_90;
    case 9:
      CFDataRef v23 = sub_1000232B8(*((void **)v2 + 1));
      CFDataRef v24 = sub_1000232B8(*((void **)v2 + 2));
      uint64_t v9 = 3758097084;
      if (!v23) {
        goto LABEL_90;
      }
      if (!v24) {
        goto LABEL_98;
      }
      uint64_t v25 = *(NSObject **)(v5 + 56);
      v115[0] = _NSConcreteStackBlock;
      v115[1] = 0x40000000;
      v115[2] = sub_10005926C;
      v115[3] = &unk_10009D510;
      v115[4] = v24;
      v115[5] = v23;
      uint64_t v26 = v115;
      uint64_t v27 = v25;
      goto LABEL_43;
    case 10:
      CFDataRef v28 = sub_1000232B8(*((void **)v2 + 1));
      CFDataRef v29 = sub_1000232B8(*((void **)v2 + 2));
      CFDataRef v23 = v29;
      if (v28 && v29)
      {
        uint64_t v27 = *(NSObject **)(v5 + 56);
        v114[0] = _NSConcreteStackBlock;
        v114[1] = 0x40000000;
        _OWORD v114[2] = sub_1000592B4;
        double v114[3] = &unk_10009D530;
        v114[4] = v23;
        v114[5] = v28;
        uint64_t v26 = v114;
LABEL_43:
        dispatch_async(v27, v26);
LABEL_89:
        uint64_t v9 = 0;
      }
      else
      {
        if (v28) {
          CFRelease(v28);
        }
        uint64_t v9 = 3758097084;
        if (v23) {
LABEL_98:
        }
          CFRelease(v23);
      }
      goto LABEL_90;
    case 12:
      long long v30 = *(H16ISPRgbJRunner **)(v5 + 568);
      if (!v30) {
        goto LABEL_56;
      }
      H16ISPRgbJRunner::saveNow(v30);
      goto LABEL_89;
    case 13:
      long long v31 = *(H16ISPRgbJRunner **)(v5 + 568);
      if (!v31) {
        goto LABEL_50;
      }
      if (H16ISPRgbJRunner::isContext(v31, v4))
      {
        BOOL v32 = *(H16ISPRgbJRunner **)(v5 + 568);
        if (v32)
        {
          H16ISPRgbJRunner::~H16ISPRgbJRunner(v32);
          operator delete();
        }
LABEL_50:
        operator new();
      }
LABEL_56:
      uint64_t v9 = 3758097084;
      goto LABEL_90;
    case 14:
      uint64_t v33 = *(void *)(v5 + 584);
      if (v33) {
        sub_100032450(v33, *((float *)v2 + 2));
      }
      goto LABEL_89;
    case 15:
      unsigned int v34 = v2[2];
      if (v34 > 5) {
        goto LABEL_56;
      }
      uint64_t v9 = 0;
      int v35 = v2[5];
      uint64_t v36 = (int32x2_t *)(v5 + 12 * v34);
      v36[20] = vadd_s32(v36[20], *(int32x2_t *)(v2 + 3));
      v36[21].i32[0] += v35;
      goto LABEL_90;
    case 16:
      int v37 = v2[2];
      if (v37 > 5) {
        goto LABEL_56;
      }
      uint64_t v43 = v5 + 56 * v37;
      int v44 = *(_DWORD *)(v43 + 236);
      *(_DWORD *)(v43 + 232) |= v2[3];
      *(_DWORD *)(v43 + 236) = v44 | v2[4];
      if (!*((unsigned char *)v2 + 20)) {
        goto LABEL_89;
      }
      uint64_t v45 = 0;
      uint64_t v46 = v5 + 56 * v37;
      *(unsigned char *)(v46 + 240) = 1;
      int v47 = *(_DWORD *)(v46 + 248);
      *(_DWORD *)(v46 + 244) |= v2[6];
      *(_DWORD *)(v46 + 248) = v47 | v2[7];
      float v48 = v2 + 11;
      uint64_t v49 = v46 + 264;
      do
      {
        uint64_t v9 = 0;
        int32x4_t v50 = (float *)&v48[v45];
        float v51 = *(float *)&v48[v45 - 3];
        int v52 = (float *)(v49 + v45 * 4);
        if (v51 <= *(float *)(v49 + v45 * 4 - 12)) {
          float v51 = *(float *)(v49 + v45 * 4 - 12);
        }
        *(v52 - 3) = v51;
        float v53 = *v50;
        if (*v50 <= *v52) {
          float v53 = *v52;
        }
        *int v52 = v53;
        ++v45;
      }
      while (v45 != 3);
      goto LABEL_90;
    case 17:
      uint64_t v38 = *(void *)(v5 + 576);
      if (!v38)
      {
        if (*((_WORD *)v2 + 29) == 2) {
          operator new();
        }
        operator new();
      }
      BOOL v68 = sub_10002F350(v38, (uint64_t)v4);
      uint64_t v9 = 3758097084;
      if (v68)
      {
        CVPixelBufferRef texture = 0;
        CVPixelBufferRef pixelBufferOut = 0;
        CVPixelBufferRef v121 = 0;
        buffera = IOSurfaceLookupFromXPCObject(*((xpc_object_t *)v2 + 1));
        __int16 v69 = (void *)*((void *)v2 + 2);
        if (v69) {
          surface = IOSurfaceLookupFromXPCObject(v69);
        }
        else {
          surface = 0;
        }
        int8x16_t v110 = IOSurfaceLookupFromXPCObject(*((xpc_object_t *)v2 + 3));
        CFDataRef cfa = sub_1000232B8(*((void **)v2 + 4));
        CFDataRef v104 = sub_1000232B8(*((void **)v2 + 5));
        CFDictionaryRef theDicta = sub_1000232B8(*((void **)v2 + 6));
        CFDataRef Value = (const __CFData *)CFDictionaryGetValue(theDicta, @"PCECalib");
        CFDataRef v78 = Value;
        if (buffera) {
          BOOL v79 = v110 == 0;
        }
        else {
          BOOL v79 = 1;
        }
        BOOL v82 = v79 || cfa == 0 || v104 == 0 || Value == 0;
        int v83 = !v82;
        int v102 = v83;
        if (!v82)
        {
          IOSurfaceLock(buffera, 0, 0);
          if (surface)
          {
            IOSurfaceLock(surface, 0, 0);
            IOSurfaceLock(v110, 0, 0);
            CFAllocatorRef v84 = kCFAllocatorDefault;
            CVPixelBufferCreateWithIOSurface(kCFAllocatorDefault, buffera, 0, &pixelBufferOut);
            CVPixelBufferCreateWithIOSurface(kCFAllocatorDefault, surface, 0, &texture);
          }
          else
          {
            IOSurfaceLock(v110, 0, 0);
            CFAllocatorRef v84 = kCFAllocatorDefault;
            CVPixelBufferCreateWithIOSurface(kCFAllocatorDefault, buffera, 0, &pixelBufferOut);
          }
          CVPixelBufferCreateWithIOSurface(v84, v110, 0, &v121);
        }
        sub_10002DF60(*(void *)(v5 + 576), *((_WORD *)v2 + 31) != 0);
        sub_10002F040(*(void *)(v5 + 576), *((unsigned __int16 *)v2 + 32));
        sub_10002DF70(*(void *)(v5 + 576), *((_WORD *)v2 + 33) != 0);
        sub_10002DF78(*(void *)(v5 + 576), *((_WORD *)v2 + 34) != 0);
        BytePtr = CFDataGetBytePtr(v78);
        memcpy(v125, BytePtr, 0x3370uLL);
        float v86 = pixelBufferOut;
        if (pixelBufferOut && v121)
        {
          if (*((_WORD *)v2 + 29) == 2)
          {
            CFDictionaryRef v87 = (const __CFDictionary *)CFDictionaryGetValue(theDicta, @"ColorGdcCoeffs");
            CFNumberRef number = (const __CFNumber *)CFDictionaryGetValue(theDicta, @"ColorPixelSizeMm");
            CFNumberRef v88 = (const __CFNumber *)CFDictionaryGetValue(theDicta, @"Multiplier");
            CFNumberRef v89 = (const __CFNumber *)CFDictionaryGetValue(theDicta, @"Offset");
            CFNumberRef v90 = (const __CFNumber *)CFDictionaryGetValue(theDicta, @"PearlVersion");
            *(void *)&valuePtr[0] = 0;
            double v119 = 0.0;
            double v120 = 0.0;
            CFNumberGetValue(number, kCFNumberDoubleType, valuePtr);
            if (v88) {
              CFNumberGetValue(v88, kCFNumberDoubleType, &v120);
            }
            if (v89) {
              CFNumberGetValue(v89, kCFNumberDoubleType, &v119);
            }
            int v118 = 0;
            if (v90) {
              CFNumberGetValue(v90, kCFNumberIntType, &v118);
            }
            uint64_t v91 = *(void *)(v5 + 576);
            sub_10002F568(v91, v120, v119);
            sub_10002F570(v91, v87);
            sub_10002F5BC(v91, *(double *)valuePtr);
            sub_10002DF68(v91, v118);
          }
          else
          {
            CFDataRef v92 = (const __CFData *)CFDictionaryGetValue(theDicta, @"DepthConfig");
            CFNumberRef v93 = (const __CFNumber *)CFDictionaryGetValue(theDicta, @"DXOffset");
            LOWORD(v120) = 0;
            CFNumberGetValue(v93, kCFNumberSInt16Type, &v120);
            uint64_t v94 = *(void *)(v5 + 576);
            int v95 = CFDataGetBytePtr(v92);
            long long v96 = *(_OWORD *)v95;
            long long v97 = *((_OWORD *)v95 + 1);
            uint64_t v117 = *((void *)v95 + 4);
            valuePtr[0] = v96;
            valuePtr[1] = v97;
            sub_10002DF68(v94, v2[18]);
            sub_10002DFB4(v94, (uint64_t)valuePtr);
            sub_10002DFC8(v94, SLOWORD(v120));
          }
          uint64_t v98 = *(void *)(v5 + 576);
          BOOL v99 = *((_WORD *)v2 + 28) != 0;
          memcpy(__dst, v125, sizeof(__dst));
          uint64_t v9 = (*(uint64_t (**)(uint64_t, CVPixelBufferRef, CVPixelBufferRef, CVPixelBufferRef, CFDataRef, CFDataRef, BOOL, unsigned char *, _WORD))(*(void *)v98 + 40))(v98, pixelBufferOut, texture, v121, cfa, v104, v99, __dst, *((_WORD *)v2 + 30));
          float v86 = pixelBufferOut;
        }
        if (v86) {
          CVPixelBufferRelease(v86);
        }
        if (texture) {
          CVPixelBufferRelease(texture);
        }
        if (v121) {
          CVPixelBufferRelease(v121);
        }
        if (buffera)
        {
          if (v102) {
            IOSurfaceUnlock(buffera, 0, 0);
          }
          CFRelease(buffera);
        }
        uint64_t v100 = surface;
        if (surface)
        {
          if (v102)
          {
            IOSurfaceUnlock(surface, 0, 0);
            uint64_t v100 = surface;
          }
          CFRelease(v100);
        }
        if (v110)
        {
          if (v102) {
            IOSurfaceUnlock(v110, 0, 0);
          }
          CFRelease(v110);
        }
        if (cfa) {
          CFRelease(cfa);
        }
        if (v104) {
          CFRelease(v104);
        }
        if (theDicta) {
          CFRelease(theDicta);
        }
      }
      else
      {
        os_log_t v70 = (os_log_t)off_1002BBCE0;
        if (off_1002BBCE0 == &_os_log_default)
        {
          os_log_t v70 = os_log_create("com.apple.isp", "daemon");
          off_1002BBCE0 = v70;
        }
        if (os_log_type_enabled(v70, OS_LOG_TYPE_ERROR)) {
          sub_10007A108((uint64_t)v4, v70, v71, v72, v73, v74, v75, v76);
        }
      }
      goto LABEL_90;
    case 20:
      uint64_t v10 = sub_100057348(v5, (uint64_t)v4, *((xpc_object_t *)v2 + 1));
LABEL_66:
      uint64_t v9 = v10;
      goto LABEL_90;
    default:
      switch(v8)
      {
        case 204:
          uint64_t v10 = sub_100055560(*(void *)(v5 + 72), *(_DWORD *)(v5 + 676), *((void *)v2 + 1), v2[4], 5u);
          goto LABEL_66;
        case 205:
        case 206:
        case 209:
        case 210:
          goto LABEL_56;
        case 207:
          uint64_t v10 = sub_1000550F8(*(void *)(v5 + 72), *(_DWORD *)(v5 + 680), *((void *)v2 + 1), v2[4]);
          goto LABEL_66;
        case 208:
          uint64_t v9 = sub_100051EE8(*(void *)(v5 + 72));
          if (!v9)
          {
            uint64_t v9 = sub_10004ECE0(*(void *)(v5 + 72));
            if (!v9) {
              sub_100022C80(*(void *)(v5 + 64));
            }
          }
          goto LABEL_90;
        case 211:
          uint64_t v10 = sub_100051F78(*(void *)(v5 + 72), *((unsigned char **)v2 + 1), *((void *)v2 + 2), *((void *)v2 + 3));
          goto LABEL_66;
        case 212:
          int v39 = 10;
          break;
        default:
          if (v8 != 101) {
            goto LABEL_56;
          }
          uint64_t v11 = *(NSObject **)(v5 + 600);
          if (v11)
          {
            block[0] = _NSConcreteStackBlock;
            block[1] = 0x40000000;
            block[2] = sub_1000592FC;
            block[3] = &unk_10009D550;
            block[4] = v5;
            void block[5] = v2;
            dispatch_sync(v11, block);
          }
          goto LABEL_89;
      }
      break;
  }
  while (1)
  {
    uint64_t v9 = sub_10004EEB8();
    if (!v9) {
      break;
    }
    usleep(0x7A120u);
    if (!--v39)
    {
      os_log_t v40 = (os_log_t)off_1002BBCE0;
      if (off_1002BBCE0 == &_os_log_default)
      {
        os_log_t v40 = os_log_create("com.apple.isp", "daemon");
        off_1002BBCE0 = v40;
      }
      if (os_log_type_enabled(v40, OS_LOG_TYPE_ERROR)) {
        sub_10007A3B0();
      }
      goto LABEL_90;
    }
  }
  int v41 = 10;
  while (1)
  {
    uint64_t v9 = sub_100054D2C(*(void *)(v5 + 72), *(_DWORD *)(v5 + 676), 2u);
    if (!v9) {
      break;
    }
    usleep(0x30D40u);
    if (!--v41)
    {
      os_log_t v42 = (os_log_t)off_1002BBCE0;
      if (off_1002BBCE0 == &_os_log_default)
      {
        os_log_t v42 = os_log_create("com.apple.isp", "daemon");
        off_1002BBCE0 = v42;
      }
      if (os_log_type_enabled(v42, OS_LOG_TYPE_ERROR)) {
        sub_10007A33C();
      }
      goto LABEL_90;
    }
  }
  if (sub_100055A40(*(void *)(v5 + 72), *(_DWORD *)(v5 + 676), *((void *)v2 + 1), *((void *)v2 + 2), 0x500u))
  {
    os_log_t v65 = (os_log_t)off_1002BBCE0;
    if (off_1002BBCE0 == &_os_log_default)
    {
      os_log_t v65 = os_log_create("com.apple.isp", "daemon");
      off_1002BBCE0 = v65;
    }
    if (os_log_type_enabled(v65, OS_LOG_TYPE_ERROR)) {
      sub_10007A2C8();
    }
  }
  if (sub_100054DAC(*(void *)(v5 + 72), *(_DWORD *)(v5 + 676)))
  {
    os_log_t v66 = (os_log_t)off_1002BBCE0;
    if (off_1002BBCE0 == &_os_log_default)
    {
      os_log_t v66 = os_log_create("com.apple.isp", "daemon");
      off_1002BBCE0 = v66;
    }
    if (os_log_type_enabled(v66, OS_LOG_TYPE_ERROR)) {
      sub_10007A254();
    }
  }
  uint64_t v9 = sub_100051EE8(*(void *)(v5 + 72));
  if (v9)
  {
    os_log_t v67 = (os_log_t)off_1002BBCE0;
    if (off_1002BBCE0 == &_os_log_default)
    {
      os_log_t v67 = os_log_create("com.apple.isp", "daemon");
      off_1002BBCE0 = v67;
    }
    if (os_log_type_enabled(v67, OS_LOG_TYPE_ERROR)) {
      sub_10007A1E0();
    }
  }
LABEL_90:
  os_log_t v54 = (os_log_t)off_1002BBCE0;
  if (off_1002BBCE0 == &_os_log_default)
  {
    os_log_t v54 = os_log_create("com.apple.isp", "daemon");
    off_1002BBCE0 = v54;
  }
  BOOL v55 = os_log_type_enabled(v54, OS_LOG_TYPE_INFO);
  int v56 = *v2;
  if (v55)
  {
    LODWORD(v125[0]) = 136315650;
    *(CVPixelBufferRef *)((char *)v125 + 4) = (CVPixelBufferRef)"setProperty";
    WORD2(v125[1]) = 1024;
    *(_DWORD *)((char *)&v125[1] + 6) = v56;
    WORD1(v125[2]) = 1024;
    HIDWORD(v125[2]) = v9;
    _os_log_impl((void *)&_mh_execute_header, v54, OS_LOG_TYPE_INFO, "%s - %d complete (res=0x%08X)\n\n", (uint8_t *)v125, 0x18u);
  }
  kdebug_trace();
  return v9;
}

void sub_100059040()
{
}

uint64_t sub_100059120(void *a1, uint64_t a2, unsigned int a3, char a4)
{
  if (a3 > 5) {
    return 3758097084;
  }
  v17[10] = v4;
  v17[11] = v5;
  if (a1[73])
  {
    uint64_t v11 = a1[75];
    if (v11)
    {
      int v12 = *(_DWORD *)(*(void *)(a1[9] + 4384) + 96 * a3 + 16);
      if (v12 == 1785950322)
      {
        BOOL v13 = v16;
        v16[0] = _NSConcreteStackBlock;
        v16[1] = 0x40000000;
        CFDataRef v14 = &unk_10009D600;
        os_log_t v15 = sub_10005A198;
        goto LABEL_9;
      }
      if (v12 == 1718186595)
      {
        BOOL v13 = v17;
        v17[0] = _NSConcreteStackBlock;
        v17[1] = 0x40000000;
        CFDataRef v14 = &unk_10009D5E0;
        os_log_t v15 = sub_10005A17C;
LABEL_9:
        v13[2] = v15;
        v13[3] = v14;
        unsigned char v13[4] = a1;
        *((unsigned char *)v13 + 40) = a4;
        dispatch_async(v11, v13);
      }
    }
  }
  if ((a4 & 1) == 0)
  {
    sub_100029B64(a1[11]);
    sub_100029B64(a1[12]);
  }
  uint64_t result = 0;
  *(unsigned char *)(a2 + a3 + 12) = a4;
  return result;
}

void sub_10005926C(uint64_t a1, uint64_t a2, const __CFString *a3)
{
  H16ISPRgbJRunner::writeDictionary(*(H16ISPRgbJRunner **)(a1 + 32), *(const __CFDictionary **)(a1 + 40), a3);
  CFRelease(*(CFTypeRef *)(a1 + 40));
  uint64_t v4 = *(const void **)(a1 + 32);

  CFRelease(v4);
}

void sub_1000592B4(uint64_t a1, uint64_t a2, const __CFString *a3)
{
  H16ISPRgbJRunner::writeData(*(H16ISPRgbJRunner **)(a1 + 32), *(const __CFData **)(a1 + 40), a3);
  CFRelease(*(CFTypeRef *)(a1 + 40));
  uint64_t v4 = *(const void **)(a1 + 32);

  CFRelease(v4);
}

uint64_t sub_1000592FC(uint64_t a1)
{
  return sub_10003204C(*(void *)(*(void *)(a1 + 32) + 584), *(unsigned char *)(*(void *)(a1 + 40) + 8) == 0);
}

uint64_t sub_100059314()
{
  uint64_t v0 = __chkstk_darwin();
  uint64_t v2 = v1;
  uint64_t v4 = v3;
  os_log_t v6 = v5;
  uint64_t v7 = v0;
  os_log_t v8 = (os_log_t)off_1002BBCE0;
  if (off_1002BBCE0 == &_os_log_default)
  {
    os_log_t v8 = os_log_create("com.apple.isp", "daemon");
    off_1002BBCE0 = v8;
  }
  if (os_log_type_enabled(v8, OS_LOG_TYPE_INFO))
  {
    int v9 = *v4;
    *(_DWORD *)long long buf = 136315394;
    *(void *)&uint8_t buf[4] = "getProperty";
    *(_WORD *)&buf[12] = 1024;
    *(_DWORD *)&buf[14] = v9;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_INFO, "%s - %d\n", buf, 0x12u);
  }
  kdebug_trace();
  uint64_t v10 = 3758097084;
  int v11 = *v4;
  if (!v18 & v12)
  {
    switch(v11)
    {
      case 200:
        uint64_t v13 = *(void *)(*(void *)(v7 + 72) + 4384);
        if (!v13) {
          goto LABEL_98;
        }
        uint64_t v14 = 0;
        os_log_t v15 = (int *)(v13 + 16);
        do
        {
          int v17 = *v15;
          v15 += 24;
          int v16 = v17;
          BOOL v18 = v17 == 1718776695 || v16 == 1718775412;
          if (v18)
          {
            void v4[3] = v14;
            *(_DWORD *)(v7 + 680) = v14;
          }
          else if (v16 == 1718186595)
          {
            int v4[2] = v14;
            *(_DWORD *)(v7 + 676) = v14;
          }
          uint64_t v10 = 0;
          ++v14;
        }
        while (v14 != 6);
        goto LABEL_124;
      case 201:
        uint64_t v47 = *(void *)(*(void *)(v7 + 72) + 4384);
        if (v47)
        {
          *((unsigned char *)v4 + 8) = *(unsigned char *)(v47 + 625);
          *((unsigned char *)v4 + 10) = *(unsigned char *)(v47 + 600);
          char v48 = *(unsigned char *)(v47 + 601);
          if (v48)
          {
            *((unsigned char *)v4 + 9) = 0;
            char v48 = *(unsigned char *)(v47 + 592);
          }
          else
          {
            *((unsigned char *)v4 + 9) = *(unsigned char *)(v47 + 592);
          }
          *((unsigned char *)v4 + 11) = v48;
          if (*(_DWORD *)(v47 + 608) == 394)
          {
            uint64_t v10 = 0;
            *((unsigned char *)v4 + 11) = 0;
            *(_WORD *)((char *)v4 + 9) = 0;
          }
          else
          {
LABEL_107:
            uint64_t v10 = 0;
          }
        }
        else
        {
LABEL_98:
          uint64_t v10 = 3758097085;
        }
        goto LABEL_124;
      case 202:
        uint64_t v46 = sub_100056AD4(*(void *)(v7 + 72), *(_DWORD *)(v7 + 676));
        goto LABEL_76;
      case 203:
        uint64_t v10 = sub_10005237C(*(void *)(v7 + 72));
        if (v10) {
          goto LABEL_77;
        }
        uint64_t v46 = sub_100056B50(*(void *)(v7 + 72), *(_DWORD *)(v7 + 676));
        goto LABEL_76;
      case 204:
      case 207:
      case 208:
        goto LABEL_124;
      case 205:
        uint64_t v46 = sub_100056BCC(*(void *)(v7 + 72), *(_DWORD *)(v7 + 680));
        goto LABEL_76;
      case 206:
        uint64_t v10 = sub_10005237C(*(void *)(v7 + 72));
        if (v10) {
          goto LABEL_77;
        }
        uint64_t v46 = sub_100056C48(*(void *)(v7 + 72), *(_DWORD *)(v7 + 680));
LABEL_76:
        uint64_t v10 = v46;
LABEL_77:
        int v4[2] = v10;
        goto LABEL_124;
      case 209:
        uint64_t v46 = sub_100051890(*(void *)(v7 + 72));
        goto LABEL_76;
      case 210:
        uint64_t v46 = sub_1000515B8(*(void *)(v7 + 72));
        goto LABEL_76;
      default:
        switch(v11)
        {
          case 'd':
            uint64_t v19 = *(void *)(*(void *)(v7 + 72) + 4384);
            if (v19 && v2 && *(void *)(v7 + 600))
            {
              unsigned int v20 = *(_DWORD *)(v19 + 616);
              BOOL v21 = v20 > 0xA;
              int v22 = (1 << v20) & 0x640;
              BOOL v23 = v21 || v22 == 0;
              if (!v23 && *(unsigned char *)(v7 + 672))
              {
                *(void *)long long buf = 0;
                *(void *)&uint8_t buf[8] = buf;
                *(void *)&uint8_t buf[16] = 0xE8802000000;
                *(void *)&unsigned char buf[24] = sub_100059F7C;
                *(void *)&unsigned char buf[32] = nullsub_16;
                memcpy(&buf[40], v4, 0xE60uLL);
                uint64_t v71 = 0;
                uint64_t v72 = &v71;
                uint64_t v73 = 0x2000000000;
                xpc_object_t reply = 0;
                xpc_object_t reply = xpc_dictionary_create_reply(v2);
                if (v72[3])
                {
                  uint64_t v80 = 0;
                  int16x8_t v81 = &v80;
                  uint64_t v82 = 0x2000000000;
                  xpc_connection_t remote_connection = 0;
                  xpc_connection_t remote_connection = xpc_dictionary_get_remote_connection((xpc_object_t)v72[3]);
                  if (v81[3])
                  {
                    ++*(_DWORD *)(v7 + 684);
                    os_log_t v24 = (os_log_t)off_1002BBCE0;
                    if (off_1002BBCE0 == &_os_log_default)
                    {
                      os_log_t v24 = os_log_create("com.apple.isp", "daemon");
                      off_1002BBCE0 = v24;
                    }
                    uint64_t v25 = (int *)(v7 + 684);
                    if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
                    {
                      pid_t pid = xpc_connection_get_pid(*v6);
                      sub_10007A4C4((int *)(v7 + 684), v79, pid, v24);
                    }
                    if (*v25 < 0x10)
                    {
                      void block[7] = _NSConcreteStackBlock;
                      block[8] = 0x40000000;
                      block[9] = sub_100059F90;
                      block[10] = &unk_10009D578;
                      block[11] = buf;
                      block[12] = &v71;
                      block[13] = &v80;
                      block[14] = v7;
                      block[15] = 3680;
                      block[16] = v6;
                      xpc_dictionary_handoff_reply();
                    }
                    else
                    {
                      bzero((void *)(*(void *)&buf[8] + 40), 0xE60uLL);
                      *(_DWORD *)(*(void *)&buf[8] + 68) = -536870187;
                      xpc_dictionary_set_int64((xpc_object_t)v72[3], "H16ISPServicesRemoteReturnKey", -536870187);
                      xpc_dictionary_set_data((xpc_object_t)v72[3], "H16ISPServicesRemoteDataKey", (const void *)(*(void *)&buf[8] + 40), 0xE60uLL);
                      xpc_connection_send_message((xpc_connection_t)v81[3], (xpc_object_t)v72[3]);
                      --*v25;
                      os_log_t v27 = (os_log_t)off_1002BBCE0;
                      if (off_1002BBCE0 == &_os_log_default)
                      {
                        os_log_t v27 = os_log_create("com.apple.isp", "daemon");
                        off_1002BBCE0 = v27;
                      }
                      if (os_log_type_enabled(v27, OS_LOG_TYPE_INFO))
                      {
                        pid_t v28 = xpc_connection_get_pid(*v6);
                        int v29 = *v25;
                        *(_DWORD *)uint64_t v75 = 67174913;
                        pid_t v76 = v28;
                        __int16 v77 = 1024;
                        int v78 = v29;
                        _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_INFO, "Sent kIOReturnBusy reply to client: (pid %{private}d), num pending requests = %u\n", v75, 0xEu);
                      }
                      xpc_release((xpc_object_t)v72[3]);
                    }
                    uint64_t v10 = 0;
                  }
                  else
                  {
                    os_log_t v63 = (os_log_t)off_1002BBCE0;
                    if (off_1002BBCE0 == &_os_log_default)
                    {
                      os_log_t v63 = os_log_create("com.apple.isp", "daemon");
                      off_1002BBCE0 = v63;
                    }
                    if (os_log_type_enabled(v63, OS_LOG_TYPE_ERROR))
                    {
                      pid_t v64 = xpc_connection_get_pid(*v6);
                      sub_10007A474(v79, v64);
                    }
                    uint64_t v10 = 3758097111;
                  }
                  _Block_object_dispose(&v80, 8);
                }
                else
                {
                  os_log_t v61 = (os_log_t)off_1002BBCE0;
                  if (off_1002BBCE0 == &_os_log_default)
                  {
                    os_log_t v61 = os_log_create("com.apple.isp", "daemon");
                    off_1002BBCE0 = v61;
                  }
                  if (os_log_type_enabled(v61, OS_LOG_TYPE_ERROR))
                  {
                    pid_t v62 = xpc_connection_get_pid(*v6);
                    sub_10007A424(&v80, v62);
                  }
                  uint64_t v10 = 3758097085;
                }
                _Block_object_dispose(&v71, 8);
                goto LABEL_123;
              }
            }
            goto LABEL_124;
          case 'f':
            uint64_t v49 = *(void *)(*(void *)(v7 + 72) + 4384);
            *(void *)long long buf = 0;
            *(void *)&uint8_t buf[8] = buf;
            *(void *)&uint8_t buf[16] = 0x2000000000;
            *(_DWORD *)&unsigned char buf[24] = -536870212;
            if (v49)
            {
              int32x4_t v50 = *(NSObject **)(v7 + 600);
              if (v50)
              {
                unsigned int v51 = *(_DWORD *)(v49 + 616);
                BOOL v21 = v51 > 0xA;
                int v52 = (1 << v51) & 0x640;
                BOOL v53 = v21 || v52 == 0;
                if (!v53 && *(void *)(v7 + 584))
                {
                  block[0] = _NSConcreteStackBlock;
                  block[1] = 0x40000000;
                  block[2] = sub_10005A130;
                  block[3] = &unk_10009D5A0;
                  block[4] = buf;
                  void block[5] = v7;
                  void block[6] = v4;
                  dispatch_sync(v50, block);
                  uint64_t v10 = *(unsigned int *)(*(void *)&buf[8] + 24);
                }
              }
            }
LABEL_123:
            _Block_object_dispose(buf, 8);
            goto LABEL_124;
          case 'g':
            uint64_t v54 = *(void *)(v7 + 16);
            break;
          case 'h':
            uint64_t v55 = *(void *)(*(void *)(v7 + 72) + 4384);
            if (v55)
            {
              int v56 = *(NSObject **)(v7 + 600);
              if (v56)
              {
                unsigned int v57 = *(_DWORD *)(v55 + 616);
                BOOL v21 = v57 > 0xA;
                int v58 = (1 << v57) & 0x640;
                BOOL v59 = v21 || v58 == 0;
                if (!v59 && *(void *)(v7 + 584))
                {
                  v69[0] = _NSConcreteStackBlock;
                  v69[1] = 0x40000000;
                  v69[2] = sub_10005A16C;
                  v69[3] = &unk_10009D5C0;
                  v69[4] = v7;
                  v69[5] = v4;
                  dispatch_sync(v56, v69);
                  goto LABEL_107;
                }
              }
            }
            goto LABEL_124;
          default:
            goto LABEL_124;
        }
        break;
    }
    while (v54 != v7 + 8)
    {
      if (!*(_DWORD *)(*(void *)(v54 + 16) + 8)) {
        goto LABEL_101;
      }
      uint64_t v54 = *(void *)(v54 + 8);
    }
    uint64_t v60 = *(void *)(v7 + 72);
    if (v60)
    {
      uint64_t v10 = 0;
      *((unsigned char *)v4 + 8) = sub_10004C600(v60);
      goto LABEL_124;
    }
LABEL_101:
    uint64_t v10 = 0;
    *((unsigned char *)v4 + 8) = 0;
    goto LABEL_124;
  }
  switch(*v4)
  {
    case 4:
      sub_100013800();
      uint64_t v10 = (uint64_t)fopen("/var/mobile/Library/ISP/Pearl/IsfHistory.bin", "rb");
      if (v10)
      {
        fread(v4 + 2, 0xE38uLL, 1uLL, (FILE *)v10);
        fclose((FILE *)v10);
        goto LABEL_107;
      }
      int v4[2] = 3;
      *((unsigned char *)v4 + 12) = 1;
      break;
    case 5:
      char v36 = sub_100003B50(**(_DWORD **)(*(void *)(v7 + 72) + 4384), 0, (time_t *)v4 + 2);
      goto LABEL_51;
    case 6:
      char v36 = sub_100003B50(**(_DWORD **)(*(void *)(v7 + 72) + 4384), 1, (time_t *)v4 + 2);
LABEL_51:
      uint64_t v10 = 0;
      *((unsigned char *)v4 + 8) = v36;
      break;
    case 7:
      CFStringRef v30 = (const __CFString *)sub_10000A7C4(*(void *)(v7 + 72), 0);
      CFStringRef v31 = v30;
      if (v30) {
        goto LABEL_45;
      }
      break;
    case 8:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
      break;
    case 9:
      int v37 = sub_1000232B8(*((void **)v4 + 1));
      int v39 = v37;
      if (!v37) {
        break;
      }
      CFStringRef Dictionary = (const __CFString *)H16ISPRgbJRunner::readDictionary(v37, v38);
      CFRelease(v39);
      if (Dictionary) {
        goto LABEL_48;
      }
      goto LABEL_102;
    case 10:
      BOOL v32 = sub_1000232B8(*((void **)v4 + 1));
      unsigned int v34 = v32;
      if (!v32) {
        break;
      }
      CFStringRef Dictionary = (const __CFString *)H16ISPRgbJRunner::readData(v32, v33);
      CFRelease(v34);
      if (Dictionary)
      {
LABEL_48:
        *((void *)v4 + 2) = sub_100023054(Dictionary);
        CFRelease(Dictionary);
        goto LABEL_107;
      }
LABEL_102:
      *((void *)v4 + 2) = 0;
      break;
    case 11:
      uint64_t v40 = *(void *)(v7 + 568);
      if (!v40) {
        break;
      }
      H16ISPRgbJRunner::fillReport(v40, v4 + 2, v4 + 3, v4 + 4, v4 + 5);
      goto LABEL_107;
    case 18:
      *((void *)v4 + 1) = 0;
      int v41 = *(unsigned char **)(v7 + 576);
      if (!v41) {
        break;
      }
      if (v41[9]) {
        goto LABEL_107;
      }
      CFStringRef v30 = (const __CFString *)(*(uint64_t (**)(unsigned char *))(*(void *)v41 + 32))(v41);
      CFStringRef v31 = v30;
      if (v30)
      {
LABEL_45:
        *((void *)v4 + 1) = sub_100023054(v30);
        CFRelease(v31);
        goto LABEL_107;
      }
      *((void *)v4 + 1) = 0;
      break;
    case 19:
      if (!*(void *)(v7 + 576)) {
        break;
      }
      os_log_t v42 = (void *)*((void *)v4 + 1);
      if (!v42) {
        break;
      }
      CFDataRef v43 = sub_1000232B8(v42);
      *((void *)v4 + 2) = 0;
      BytePtr = CFDataGetBytePtr(v43);
      memcpy(buf, BytePtr, 0x3370uLL);
      CFRelease(v43);
      if (!(*(unsigned int (**)(void, uint8_t *))(**(void **)(v7 + 576) + 24))(*(void *)(v7 + 576), buf))break; {
      CFStringRef v45 = (const __CFString *)CFDataCreate(kCFAllocatorDefault, buf, 13168);
      }
      *((void *)v4 + 2) = sub_100023054(v45);
      CFRelease(v45);
      goto LABEL_107;
    default:
      JUMPOUT(0);
  }
LABEL_124:
  os_log_t v65 = (os_log_t)off_1002BBCE0;
  if (off_1002BBCE0 == &_os_log_default)
  {
    os_log_t v65 = os_log_create("com.apple.isp", "daemon");
    off_1002BBCE0 = v65;
  }
  BOOL v66 = os_log_type_enabled(v65, OS_LOG_TYPE_INFO);
  int v67 = *v4;
  if (v66)
  {
    *(_DWORD *)long long buf = 136315650;
    *(void *)&uint8_t buf[4] = "getProperty";
    *(_WORD *)&buf[12] = 1024;
    *(_DWORD *)&buf[14] = v67;
    *(_WORD *)&buf[18] = 1024;
    *(_DWORD *)&buf[20] = v10;
    _os_log_impl((void *)&_mh_execute_header, v65, OS_LOG_TYPE_INFO, "%s - %d complete (res=0x%08X)\n\n", buf, 0x18u);
  }
  kdebug_trace();
  return v10;
}

void sub_100059EA4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,char a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,char a43,uint64_t a44,uint64_t a45,uint64_t a46,char a47)
{
}

void *sub_100059F7C(uint64_t a1, uint64_t a2)
{
  return memcpy((void *)(a1 + 40), (const void *)(a2 + 40), 0xE60uLL);
}

void sub_100059F90(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 56);
  int v3 = sub_1000324E4(*(void *)(v2 + 584), *(void *)(*(void *)(a1 + 32) + 8) + 48);
  *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 68) = v3;
  xpc_dictionary_set_int64(*(xpc_object_t *)(*(void *)(*(void *)(a1 + 40) + 8) + 24), "H16ISPServicesRemoteReturnKey", v3);
  xpc_dictionary_set_data(*(xpc_object_t *)(*(void *)(*(void *)(a1 + 40) + 8) + 24), "H16ISPServicesRemoteDataKey", (const void *)(*(void *)(*(void *)(a1 + 32) + 8) + 40), *(void *)(a1 + 64));
  xpc_connection_send_message(*(xpc_connection_t *)(*(void *)(*(void *)(a1 + 48) + 8) + 24), *(xpc_object_t *)(*(void *)(*(void *)(a1 + 40) + 8) + 24));
  --*(_DWORD *)(v2 + 684);
  os_log_t v4 = (os_log_t)off_1002BBCE0;
  if (off_1002BBCE0 == &_os_log_default)
  {
    os_log_t v4 = os_log_create("com.apple.isp", "daemon");
    off_1002BBCE0 = v4;
  }
  if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
  {
    pid_t pid = xpc_connection_get_pid(**(xpc_connection_t **)(a1 + 72));
    int v6 = *(_DWORD *)(v2 + 684);
    v7[0] = 67109633;
    v7[1] = v3;
    __int16 v8 = 1025;
    pid_t v9 = pid;
    __int16 v10 = 1024;
    int v11 = v6;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_INFO, "Sent reply to client: rc %08X (pid %{private}d), num pending requests = %u\n", (uint8_t *)v7, 0x14u);
  }
  xpc_release(*(xpc_object_t *)(*(void *)(*(void *)(a1 + 40) + 8) + 24));
}

uint64_t sub_10005A130(void *a1)
{
  uint64_t result = sub_100032888(*(void *)(a1[5] + 584), a1[6] + 8);
  *(_DWORD *)(*(void *)(a1[4] + 8) + 24) = result;
  return result;
}

uint64_t sub_10005A16C(uint64_t a1)
{
  return sub_100032970(*(void *)(*(void *)(a1 + 32) + 584), *(void *)(a1 + 40) + 8);
}

uint64_t sub_10005A17C(uint64_t a1)
{
  int v1 = *(unsigned __int8 *)(a1 + 40);
  uint64_t v2 = *(void *)(*(void *)(a1 + 32) + 584);
  if (v1) {
    int v3 = 2;
  }
  else {
    int v3 = 3;
  }
  return sub_10003204C(v2, v3);
}

uint64_t sub_10005A198(uint64_t a1)
{
  int v1 = *(unsigned __int8 *)(a1 + 40);
  uint64_t v2 = *(void *)(*(void *)(a1 + 32) + 584);
  if (v1) {
    int v3 = 4;
  }
  else {
    int v3 = 5;
  }
  return sub_10003204C(v2, v3);
}

void sub_10005A1B4(int a1, xpc_connection_t *a2, xpc_object_t xdict)
{
  size_t length = 0;
  uint int64 = xpc_dictionary_get_uint64(xdict, "H16ISPServicesRemoteTypeKey");
  data = xpc_dictionary_get_data(xdict, "H16ISPServicesRemoteDataKey", &length);
  if (!uint64) {
    return;
  }
  uint64_t v7 = data;
  if (!data || !length) {
    return;
  }
  if (uint64 == 1 && length == 13176)
  {
    switch(*(_DWORD *)data)
    {
      case 7:
        xpc_object_t value = xpc_dictionary_get_value(xdict, "H16ISPServicesRemoteJasperCalibObjectKey");
        goto LABEL_29;
      case 8:
        data[1] = xpc_dictionary_get_value(xdict, "H16ISPServicesRemoteRGBJBufferKey");
        void v7[3] = xpc_dictionary_get_value(xdict, "H16ISPServicesRemoteRGBJOriginalCloudBanksKey");
        unsigned char v7[4] = xpc_dictionary_get_value(xdict, "H16ISPServicesRemoteRGBJColorCalibrationKey");
        void v7[5] = xpc_dictionary_get_value(xdict, "H16ISPServicesRemoteRGBJJasperCalibrationKey");
        xpc_object_t v8 = xpc_dictionary_get_value(xdict, "H16ISPServicesRemoteRGBJMetadataKey");
        goto LABEL_26;
      case 9:
      case 0xA:
        data[1] = xpc_dictionary_get_value(xdict, "H16ISPServicesRemoteCFTypeNameKey");
        xpc_object_t v8 = xpc_dictionary_get_value(xdict, "H16ISPServicesRemoteCFTypeDataKey");
LABEL_26:
        _DWORD v7[2] = v8;
        break;
      case 0xB:
      case 0xC:
      case 0xD:
      case 0xE:
      case 0xF:
      case 0x10:
      case 0x12:
      case 0x13:
        break;
      case 0x11:
        data[1] = xpc_dictionary_get_value(xdict, "H16ISPServicesRemoteRGBIRBufferColorKey");
        _DWORD v7[2] = xpc_dictionary_get_value(xdict, "H16ISPServicesRemoteRGBIRBufferIRKey");
        void v7[3] = xpc_dictionary_get_value(xdict, "H16ISPServicesRemoteRGBIRBufferDepthKey");
        unsigned char v7[4] = xpc_dictionary_get_value(xdict, "H16ISPServicesRemoteRGBIRMetadataColorKey");
        void v7[5] = xpc_dictionary_get_value(xdict, "H16ISPServicesRemoteRGBIRMetadataIRKey");
        v7[6] = xpc_dictionary_get_value(xdict, "H16ISPServicesRemoteRGBIRPCEConfigKey");
        break;
      case 0x14:
        xpc_object_t value = xpc_dictionary_get_value(xdict, "H16ISPServicesRemoteDeviceID");
LABEL_29:
        v7[1] = value;
        break;
      default:
        switch(*(_DWORD *)data)
        {
          case 0xCC:
          case 0xCF:
          case 0xD4:
            size_t v25 = 0;
            int v11 = xpc_dictionary_get_data(xdict, "H16ISPServicesRemoteFusingDataKey", &v25);
            size_t v12 = v25;
            v7[1] = v11;
            _DWORD v7[2] = v12;
            break;
          case 0xD3:
            *(void *)pid_t v28 = 0;
            data[1] = xpc_dictionary_get_string(xdict, "H16ISPServicesRemoteIORegPropertyNameKey");
            int v16 = xpc_dictionary_get_data(xdict, "H16ISPServicesRemoteIORegPropertyDataKey", (size_t *)v28);
            uint64_t v17 = *(void *)v28;
            _DWORD v7[2] = v16;
            void v7[3] = v17;
            break;
          default:
            goto LABEL_31;
        }
        break;
    }
LABEL_31:
    int v14 = sub_10005802C();
    goto LABEL_32;
  }
  if (uint64 != 2 || length != 3680)
  {
    os_log_t v9 = (os_log_t)off_1002BBCE0;
    if (off_1002BBCE0 == &_os_log_default)
    {
      os_log_t v9 = os_log_create("com.apple.isp", "daemon");
      off_1002BBCE0 = v9;
    }
    int v10 = -536870212;
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR)) {
      sub_10007A634(a2, uint64, v9);
    }
    goto LABEL_33;
  }
  memcpy(__dst, data, sizeof(__dst));
  if ((LODWORD(__dst[0]) - 9) < 2)
  {
    uint64_t v13 = "H16ISPServicesRemoteCFTypeNameKey";
  }
  else
  {
    if (LODWORD(__dst[0]) != 19)
    {
      if (LODWORD(__dst[0]) == 100)
      {
        sub_100059314();
        return;
      }
      goto LABEL_23;
    }
    uint64_t v13 = "H16ISPServicesRemoteRGBIRFinalInputPCEConfigKey";
  }
  __dst[1] = xpc_dictionary_get_value(xdict, v13);
LABEL_23:
  int v14 = sub_100059314();
LABEL_32:
  int v10 = v14;
LABEL_33:
  xpc_object_t reply = xpc_dictionary_create_reply(xdict);
  uint64_t v19 = reply;
  if (reply)
  {
    xpc_connection_t remote_connection = xpc_dictionary_get_remote_connection(reply);
    os_log_t v21 = (os_log_t)off_1002BBCE0;
    if (!remote_connection)
    {
      if (off_1002BBCE0 == &_os_log_default)
      {
        os_log_t v21 = os_log_create("com.apple.isp", "daemon");
        off_1002BBCE0 = v21;
      }
      if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR)) {
        sub_10007A5B4(a2);
      }
      goto LABEL_64;
    }
    if (off_1002BBCE0 == &_os_log_default)
    {
      os_log_t v21 = os_log_create("com.apple.isp", "daemon");
      off_1002BBCE0 = v21;
    }
    if (os_log_type_enabled(v21, OS_LOG_TYPE_INFO))
    {
      pid_t pid = xpc_connection_get_pid(*a2);
      *(_DWORD *)pid_t v28 = 136315907;
      *(void *)&_OWORD v28[4] = "xpcClientEventHandler";
      __int16 v29 = 1024;
      int v30 = 1588;
      __int16 v31 = 1024;
      int v32 = v10;
      __int16 v33 = 1025;
      pid_t v34 = pid;
      _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_INFO, "%s: %d: Sending reply to client: rc %08X (pid %{private}d)\n", v28, 0x1Eu);
    }
    xpc_dictionary_set_int64(v19, "H16ISPServicesRemoteReturnKey", v10);
    if (uint64 == 2)
    {
      xpc_dictionary_set_data(v19, "H16ISPServicesRemoteDataKey", __dst, length);
      if (SLODWORD(__dst[0]) <= 17)
      {
        if ((LODWORD(__dst[0]) - 9) >= 2)
        {
          if (LODWORD(__dst[0]) == 7 && !v10)
          {
            xpc_dictionary_set_value(v19, "H16ISPServicesRemoteJasperCalibObjectKey", __dst[1]);
            xpc_release(__dst[1]);
          }
        }
        else if (!v10)
        {
          xpc_dictionary_set_value(v19, "H16ISPServicesRemoteCFTypeDataKey", __dst[2]);
          xpc_release(__dst[2]);
        }
        goto LABEL_63;
      }
      if (LODWORD(__dst[0]) == 19)
      {
        if (v10) {
          goto LABEL_63;
        }
        xpc_dictionary_set_value(v19, "H16ISPServicesRemoteRGBIRFinalOutputPCEConfigKey", __dst[2]);
        xpc_object_t v24 = __dst[2];
        if (!__dst[2]) {
          goto LABEL_63;
        }
      }
      else
      {
        if (LODWORD(__dst[0]) != 18) {
          goto LABEL_63;
        }
        if (v10) {
          goto LABEL_63;
        }
        xpc_dictionary_set_value(v19, "H16ISPServicesRemoteRGBIRReportKey", __dst[1]);
        xpc_object_t v24 = __dst[1];
        if (!__dst[1]) {
          goto LABEL_63;
        }
      }
      xpc_release(v24);
    }
LABEL_63:
    xpc_connection_send_message(remote_connection, v19);
LABEL_64:
    xpc_release(v19);
    return;
  }
  os_log_t v23 = (os_log_t)off_1002BBCE0;
  if (off_1002BBCE0 == &_os_log_default)
  {
    os_log_t v23 = os_log_create("com.apple.isp", "daemon");
    off_1002BBCE0 = v23;
  }
  if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR)) {
    sub_10007A534(a2);
  }
}

uint64_t sub_10005A84C(uint64_t a1, xpc_connection_t *a2, void *a3)
{
  if (a3 == &_xpc_error_termination_imminent)
  {
    os_log_t v6 = (os_log_t)off_1002BBCE0;
    if (off_1002BBCE0 == &_os_log_default)
    {
      os_log_t v6 = os_log_create("com.apple.isp", "daemon");
      off_1002BBCE0 = v6;
    }
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR)) {
      sub_10007A6D8(a2);
    }
  }
  else if (a3 == &_xpc_error_connection_interrupted)
  {
    os_log_t v7 = (os_log_t)off_1002BBCE0;
    if (off_1002BBCE0 == &_os_log_default)
    {
      os_log_t v7 = os_log_create("com.apple.isp", "daemon");
      off_1002BBCE0 = v7;
    }
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR)) {
      sub_10007A754(a2);
    }
  }
  else
  {
    os_log_t v5 = (os_log_t)off_1002BBCE0;
    if (a3 == &_xpc_error_connection_invalid)
    {
      if (off_1002BBCE0 == &_os_log_default)
      {
        os_log_t v5 = os_log_create("com.apple.isp", "daemon");
        off_1002BBCE0 = v5;
      }
      if (os_log_type_enabled(v5, OS_LOG_TYPE_INFO))
      {
        pid_t pid = xpc_connection_get_pid(*a2);
        v10[0] = 67174657;
        v10[1] = pid;
        _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_INFO, "Client disconnecting (pid %{private}d)\n", (uint8_t *)v10, 8u);
      }
    }
    else
    {
      if (off_1002BBCE0 == &_os_log_default)
      {
        os_log_t v5 = os_log_create("com.apple.isp", "daemon");
        off_1002BBCE0 = v5;
      }
      if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR)) {
        sub_10007A7D0(a2);
      }
    }
  }
  return (*(uint64_t (**)(uint64_t, xpc_connection_t *))(*(void *)a1 + 48))(a1, a2);
}

void sub_10005AA7C()
{
}

void sub_10005AB78(uint64_t a1, xpc_object_t object)
{
  uint64_t v4 = *(void *)(a1 + 32);
  xpc_type_t type = xpc_get_type(object);
  if (type == (xpc_type_t)&_xpc_type_error)
  {
    os_log_t v7 = *(xpc_connection_t **)(a1 + 40);
    sub_10005A84C(v4, v7, object);
  }
  else if (type == (xpc_type_t)&_xpc_type_dictionary)
  {
    uint64_t v8 = *(void *)(a1 + 40);
    os_log_t v9 = *(void (**)(uint64_t, uint64_t, xpc_object_t))(*(void *)v4 + 64);
    v9(v4, v8, object);
  }
  else
  {
    os_log_t v6 = (os_log_t)off_1002BBCE0;
    if (off_1002BBCE0 == &_os_log_default)
    {
      os_log_t v6 = os_log_create("com.apple.isp", "daemon");
      off_1002BBCE0 = v6;
    }
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR)) {
      sub_10007A84C(a1);
    }
  }
}

void sub_10005AC9C(uint64_t a1, void *a2)
{
  if (a2 == &_xpc_error_termination_imminent)
  {
    os_log_t v3 = (os_log_t)off_1002BBCE0;
    if (off_1002BBCE0 == &_os_log_default)
    {
      os_log_t v3 = os_log_create("com.apple.isp", "daemon");
      off_1002BBCE0 = v3;
    }
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR)) {
      sub_10007A8CC();
    }
  }
  else if (a2 == &_xpc_error_connection_invalid)
  {
    os_log_t v4 = (os_log_t)off_1002BBCE0;
    if (off_1002BBCE0 == &_os_log_default)
    {
      os_log_t v4 = os_log_create("com.apple.isp", "daemon");
      off_1002BBCE0 = v4;
    }
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR)) {
      sub_10007A900();
    }
  }
  else if (a2 == &_xpc_error_connection_interrupted)
  {
    os_log_t v2 = (os_log_t)off_1002BBCE0;
    if (off_1002BBCE0 == &_os_log_default)
    {
      os_log_t v2 = os_log_create("com.apple.isp", "daemon");
      off_1002BBCE0 = v2;
    }
    if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR)) {
      sub_10007A934();
    }
  }
}

void sub_10005ADD8(uint64_t a1, xpc_object_t xdict)
{
  string = xpc_dictionary_get_string(xdict, _xpc_event_key_name);
  if (string)
  {
    os_log_t v4 = string;
    uint64_t v5 = *(void *)(a1 + 16);
    if (v5 == a1 + 8)
    {
      uint64_t v6 = 0;
    }
    else
    {
      uint64_t v6 = 0;
      do
      {
        uint64_t v8 = v5 + 8;
        uint64_t v5 = *(void *)(v5 + 8);
        uint64_t v7 = *(void *)(v8 + 8);
        if (!*(_DWORD *)(v7 + 8)) {
          uint64_t v6 = v7;
        }
      }
      while (v5 != a1 + 8);
    }
    size_t v9 = strlen(*(const char **)(a1 + 632));
    if (!strncmp(v4, *(const char **)(a1 + 632), v9))
    {
      if (!v6) {
        operator new();
      }
    }
    else
    {
      size_t v10 = strlen(*(const char **)(a1 + 640));
      if (!strncmp(v4, *(const char **)(a1 + 640), v10))
      {
        if (v6)
        {
          BOOL v18 = *(void (**)(uint64_t, uint64_t))(*(void *)a1 + 48);
          v18(a1, v6);
        }
      }
      else
      {
        os_log_t v11 = (os_log_t)off_1002BBCE0;
        if (off_1002BBCE0 == &_os_log_default)
        {
          os_log_t v11 = os_log_create("com.apple.isp", "daemon");
          off_1002BBCE0 = v11;
        }
        if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR)) {
          sub_10007A968((uint64_t)v4, v11, v12, v13, v14, v15, v16, v17);
        }
      }
    }
  }
}

uint64_t sub_10005AFA4(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 16) == 3)
  {
    os_log_t v2 = (os_log_t)off_1002BBCE0;
    if (off_1002BBCE0 == &_os_log_default)
    {
      os_log_t v2 = os_log_create("com.apple.isp", "daemon");
      off_1002BBCE0 = v2;
    }
    if (os_log_type_enabled(v2, OS_LOG_TYPE_INFO))
    {
      int v4 = 136315138;
      uint64_t v5 = "collectDiagState";
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_INFO, "%s - Collecting ISP Sysdiagnose State\n", (uint8_t *)&v4, 0xCu);
      os_log_t v2 = (os_log_t)off_1002BBCE0;
    }
    if (v2 == (os_log_t)&_os_log_default)
    {
      os_log_t v2 = os_log_create("com.apple.isp", "daemon");
      off_1002BBCE0 = v2;
    }
    if (os_log_type_enabled(v2, OS_LOG_TYPE_INFO))
    {
      int v4 = 136315650;
      uint64_t v5 = "collectDiagState";
      __int16 v6 = 2080;
      uint64_t v7 = "3.324";
      __int16 v8 = 2080;
      size_t v9 = "0";
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_INFO, "%s - Assistant Version %s.%s\n", (uint8_t *)&v4, 0x20u);
    }
  }
  return 0;
}

uint64_t sub_10005B11C(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 72);
  if (!v2) {
    return 3758097101;
  }
  if (sub_100055050(v2)) {
    return 0;
  }
  if (sub_10004C600(*(void *)(a1 + 72)))
  {
    do
    {
      usleep(0x186A0u);
      os_log_t v4 = (os_log_t)off_1002BBCE0;
      if (off_1002BBCE0 == &_os_log_default)
      {
        os_log_t v4 = os_log_create("com.apple.isp", "daemon");
        off_1002BBCE0 = v4;
      }
      if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
      {
        *(_WORD *)uint64_t v7 = 0;
        _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_INFO, "Camera powered on...waiting\n", v7, 2u);
      }
    }
    while ((sub_10004C600(*(void *)(a1 + 72)) & 1) != 0);
  }
  *(void *)(a1 + 48) = os_transaction_create();
  uint64_t v3 = sub_1000518EC(*(void *)(a1 + 72));
  os_release(*(void **)(a1 + 48));
  if (v3)
  {
    os_log_t v5 = (os_log_t)off_1002BBCE0;
    if (off_1002BBCE0 == &_os_log_default)
    {
      os_log_t v5 = os_log_create("com.apple.isp", "daemon");
      off_1002BBCE0 = v5;
    }
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR)) {
      sub_10007A9D4();
    }
  }
  return v3;
}

uint64_t sub_10005B290(uint64_t a1)
{
  kdebug_trace();
  uint64_t v2 = (CFArrayRef **)(a1 + 64);
  if (sub_100022AAC((void *)(a1 + 64), (uint64_t)sub_100056E50, 0) || !*v2)
  {
    os_log_t v3 = (os_log_t)off_1002BBCE0;
    if (off_1002BBCE0 == &_os_log_default)
    {
      os_log_t v3 = os_log_create("com.apple.isp", "daemon");
      off_1002BBCE0 = v3;
    }
    uint64_t v4 = 3758097088;
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR)) {
      sub_10007AA48();
    }
  }
  else
  {
    if (CFArrayGetCount(**v2))
    {
      unint64_t v6 = 0;
      do
      {
        CFNumberRef ValueAtIndex = CFArrayGetValueAtIndex(**(CFArrayRef **)(a1 + 64), v6);
        *(void *)(a1 + 72) = ValueAtIndex;
        if (!sub_10005680C((uint64_t)ValueAtIndex, (uint64_t)sub_100056E58, a1)) {
          break;
        }
        *(void *)(a1 + 72) = 0;
        ++v6;
      }
      while (v6 < CFArrayGetCount(**(CFArrayRef **)(a1 + 64)));
    }
    if (*(void *)(a1 + 72))
    {
      uint64_t v4 = sub_10005B11C(a1);
      if (!v4)
      {
        uint64_t v8 = 0;
        for (char i = 1; ; char i = 0)
        {
          char v10 = i;
          uint64_t v11 = *(void *)(a1 + 72);
          uint64_t v12 = (uint64_t *)(a1 + 8 * v8 + 88);
          v18[0] = v12;
          v18[1] = v11;
          uint64_t v13 = sub_100029BA8((uint64_t)v18);
          if (v13) {
            break;
          }
          uint64_t v14 = sub_100029928(*v12);
          if (v14)
          {
            uint64_t v4 = v14;
            os_log_t v17 = (os_log_t)off_1002BBCE0;
            if (off_1002BBCE0 == &_os_log_default)
            {
              os_log_t v17 = os_log_create("com.apple.isp", "daemon");
              off_1002BBCE0 = v17;
            }
            if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR)) {
              sub_10007AB20();
            }
            goto LABEL_6;
          }
          uint64_t v8 = 1;
          if ((v10 & 1) == 0) {
            operator new();
          }
        }
        uint64_t v4 = v13;
        os_log_t v16 = (os_log_t)off_1002BBCE0;
        if (off_1002BBCE0 == &_os_log_default)
        {
          os_log_t v16 = os_log_create("com.apple.isp", "daemon");
          off_1002BBCE0 = v16;
        }
        if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR)) {
          sub_10007AB88();
        }
      }
    }
    else
    {
      os_log_t v15 = (os_log_t)off_1002BBCE0;
      if (off_1002BBCE0 == &_os_log_default)
      {
        os_log_t v15 = os_log_create("com.apple.isp", "daemon");
        off_1002BBCE0 = v15;
      }
      uint64_t v4 = 3758097088;
      if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR)) {
        sub_10007AAB4();
      }
    }
  }
LABEL_6:
  (*(void (**)(uint64_t))(*(void *)a1 + 24))(a1);
  kdebug_trace();
  return v4;
}

void sub_10005B670()
{
}

uint64_t sub_10005B6CC(uint64_t a1, uint64_t a2)
{
  return 0;
}

uint64_t sub_10005B6E8(void *a1)
{
  uint64_t v2 = (const void **)a1[13];
  if (v2)
  {
    sub_100028E9C(v2);
    operator delete();
  }
  uint64_t v3 = 0;
  char v4 = 1;
  do
  {
    char v5 = v4;
    unint64_t v6 = &a1[v3];
    uint64_t v9 = v6[11];
    uint64_t v8 = v6 + 11;
    uint64_t v7 = v9;
    if (v9)
    {
      sub_100029744(v7);
      sub_100029D94(*v8);
    }
    char v4 = 0;
    uint64_t v3 = 1;
  }
  while ((v5 & 1) != 0);
  if (a1[73])
  {
    char v10 = a1[75];
    block[0] = _NSConcreteStackBlock;
    block[1] = 0x40000000;
    block[2] = sub_10005B86C;
    block[3] = &unk_10009D660;
    block[4] = a1;
    dispatch_sync(v10, block);
  }
  uint64_t v11 = a1[9];
  if (v11)
  {
    sub_10004ECE0(v11);
    a1[9] = 0;
  }
  uint64_t v12 = (void *)a1[10];
  if (v12)
  {
    sub_1000469D4(v12);
    operator delete();
  }
  uint64_t v13 = a1[14];
  if (v13)
  {
    sub_1000060FC(v13);
    operator delete();
  }
  if (a1[15])
  {
    os_state_remove_handler();
    a1[15] = 0;
  }
  uint64_t v14 = a1[8];
  if (v14) {
    sub_100022C80(v14);
  }
  os_log_t v15 = (void *)a1[86];
  if (v15)
  {
    sub_10001DC98(v15);
    operator delete();
  }
  return 0;
}

uint64_t sub_10005B86C(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  uint64_t v2 = *(void *)(v1 + 592);
  if (v2)
  {
    *(unsigned char *)(v1 + 672) = 0;
    sub_100015428(v2);
    sub_1000153F8(*(void *)(v1 + 592));
  }
  uint64_t result = *(void *)(v1 + 584);
  if (result)
  {
    sub_100031D80(result);
    operator delete();
  }
  *(void *)(v1 + 584) = 0;
  return result;
}

uint64_t sub_10005B8C8(uint64_t a1)
{
  uint64_t v2 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_signal, 0xFuLL, 0, (dispatch_queue_t)&_dispatch_main_q);
  *(void *)(a1 + 664) = v2;
  if (v2)
  {
    dispatch_source_set_event_handler(v2, &stru_10009D6A0);
    dispatch_resume(*(dispatch_object_t *)(a1 + 664));
    mach_service = xpc_connection_create_mach_service(*(const char **)(a1 + 608), *(dispatch_queue_t *)(a1 + 40), 1uLL);
    *(void *)(a1 + 32) = mach_service;
    handler[0] = _NSConcreteStackBlock;
    handler[1] = 0x40000000;
    handler[2] = sub_10005BAD4;
    handler[3] = &unk_10009D6C0;
    handler[4] = a1;
    xpc_connection_set_event_handler(mach_service, handler);
    xpc_connection_activate(*(xpc_connection_t *)(a1 + 32));
    unint64_t v6 = *(NSObject **)(a1 + 40);
    v7[0] = _NSConcreteStackBlock;
    v7[1] = 0x40000000;
    _DWORD v7[2] = sub_10005BBBC;
    void v7[3] = &unk_10009D6E0;
    unsigned char v7[4] = a1;
    xpc_set_event_stream_handler("com.apple.iokit.matching", v6, v7);
    dispatch_main();
  }
  os_log_t v3 = (os_log_t)off_1002BBCE0;
  if (off_1002BBCE0 == &_os_log_default)
  {
    os_log_t v3 = os_log_create("com.apple.isp", "daemon");
    off_1002BBCE0 = v3;
  }
  if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR)) {
    sub_10007ABF0();
  }
  return 3758097086;
}

void sub_10005BA4C(id a1)
{
  os_log_t v1 = (os_log_t)off_1002BBCE0;
  if (off_1002BBCE0 == &_os_log_default)
  {
    os_log_t v1 = os_log_create("com.apple.isp", "daemon");
    off_1002BBCE0 = v1;
  }
  if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)uint64_t v2 = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_ERROR, "Received SIGTERM - exiting\n", v2, 2u);
  }
  exit(0);
}

void sub_10005BAD4(uint64_t a1, xpc_object_t object)
{
  uint64_t v3 = *(void *)(a1 + 32);
  if (xpc_get_type(object) == (xpc_type_t)&_xpc_type_connection)
  {
    char v5 = *(void (**)(uint64_t, xpc_object_t))(*(void *)v3 + 32);
    v5(v3, object);
  }
  else if (xpc_get_type(object) == (xpc_type_t)&_xpc_type_error)
  {
    os_log_t v4 = (os_log_t)off_1002BBCE0;
    if (off_1002BBCE0 == &_os_log_default)
    {
      os_log_t v4 = os_log_create("com.apple.isp", "daemon");
      off_1002BBCE0 = v4;
    }
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR)) {
      sub_10007AC24();
    }
  }
}

void sub_10005BBBC(uint64_t a1, xpc_object_t object)
{
  uint64_t v3 = *(void *)(a1 + 32);
  if (xpc_get_type(object) == (xpc_type_t)&_xpc_type_dictionary)
  {
    char v5 = *(void (**)(uint64_t, xpc_object_t))(*(void *)v3 + 72);
    v5(v3, object);
  }
  else
  {
    xpc_type_t type = xpc_get_type(object);
    if (type == (xpc_type_t)&_xpc_type_error)
    {
      sub_10005AC9C((uint64_t)type, object);
    }
  }
}

uint64_t sub_10005BC74(uint64_t a1)
{
  *(void *)a1 = off_10009D710;
  *(void *)(a1 + 8) = a1 + 8;
  *(void *)(a1 + 16) = a1 + 8;
  *(void *)(a1 + 24) = 0;
  *(unsigned char *)(a1 + 672) = 0;
  *(void *)(a1 + 48) = 0;
  *(_DWORD *)(a1 + 684) = 0;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 584) = 0u;
  *(_OWORD *)(a1 + 608) = 0u;
  *(_OWORD *)(a1 + 624) = 0u;
  *(_OWORD *)(a1 + 640) = 0u;
  *(void *)(a1 + 656) = 0;
  *(void *)(a1 + 600) = dispatch_queue_create(0, 0);
  *(_OWORD *)(a1 + 128) = 0u;
  *(_OWORD *)(a1 + 144) = 0u;
  *(_OWORD *)(a1 + 160) = 0u;
  *(_OWORD *)(a1 + 176) = 0u;
  *(_OWORD *)(a1 + 192) = 0u;
  *(_OWORD *)(a1 + 208) = 0u;
  *(_OWORD *)(a1 + 224) = 0u;
  *(_OWORD *)(a1 + 240) = 0u;
  *(_OWORD *)(a1 + 256) = 0u;
  *(_OWORD *)(a1 + 272) = 0u;
  *(_OWORD *)(a1 + 288) = 0u;
  *(_OWORD *)(a1 + 304) = 0u;
  *(_OWORD *)(a1 + 320) = 0u;
  *(_OWORD *)(a1 + 336) = 0u;
  *(_OWORD *)(a1 + 352) = 0u;
  *(_OWORD *)(a1 + 368) = 0u;
  *(_OWORD *)(a1 + 384) = 0u;
  *(_OWORD *)(a1 + 400) = 0u;
  *(_OWORD *)(a1 + 416) = 0u;
  *(_OWORD *)(a1 + 432) = 0u;
  *(_OWORD *)(a1 + 448) = 0u;
  *(_OWORD *)(a1 + 464) = 0u;
  *(_OWORD *)(a1 + 480) = 0u;
  *(_OWORD *)(a1 + 496) = 0u;
  *(_OWORD *)(a1 + 512) = 0u;
  *(_OWORD *)(a1 + 528) = 0u;
  *(_OWORD *)(a1 + 544) = 0u;
  *(_OWORD *)(a1 + 560) = 0u;
  *(void *)(a1 + 576) = 0;
  *(void *)(a1 + 608) = "com.apple.appleh16camerad";
  *(void *)(a1 + 616) = "com.apple.appleh16camerad.writer";
  *(void *)(a1 + 624) = "com.apple.appleh16camerad.assistant_active";
  *(void *)(a1 + 632) = "com.apple.appleh16camerad.launch";
  *(void *)(a1 + 640) = "com.apple.appleh16camerad.destroy";
  *(void *)(a1 + 648) = "com.apple.appleh16camerad.firmware_loading";
  *(void *)(a1 + 656) = "com.apple.appleh16camerad.photometerManagerSyncQueue";
  *(void *)(a1 + 688) = 0;
  *(void *)(a1 + 664) = 0;
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 40) = dispatch_queue_create("com.apple.appleh16camerad", 0);
  *(void *)(a1 + 56) = dispatch_queue_create(*(const char **)(a1 + 616), 0);
  byte_1002BBE68 = sub_100022CF0(@"EnableHawking", @"com.apple.coremedia", 1) != 0;
  os_log_t v2 = (os_log_t)off_1002BBCE0;
  if (off_1002BBCE0 == &_os_log_default)
  {
    os_log_t v2 = os_log_create("com.apple.isp", "daemon");
    off_1002BBCE0 = v2;
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_INFO))
  {
    *(_WORD *)os_log_t v4 = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_INFO, "Creating H16ISP services assistant\n", v4, 2u);
  }
  return a1;
}

void sub_10005BE58(_Unwind_Exception *a1)
{
  sub_10005C008(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_10005BE70(uint64_t a1)
{
  *(void *)a1 = off_10009D710;
  os_log_t v2 = (os_log_t)off_1002BBCE0;
  if (off_1002BBCE0 == &_os_log_default)
  {
    os_log_t v2 = os_log_create("com.apple.isp", "daemon");
    off_1002BBCE0 = v2;
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_INFO))
  {
    *(_WORD *)uint64_t v7 = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_INFO, "Destroying H16ISP services assistant\n", v7, 2u);
  }
  uint64_t v3 = *(_xpc_connection_s **)(a1 + 32);
  if (v3)
  {
    xpc_connection_cancel(v3);
    xpc_release(*(xpc_object_t *)(a1 + 32));
  }
  os_log_t v4 = *(NSObject **)(a1 + 664);
  if (v4)
  {
    dispatch_source_cancel(v4);
    dispatch_release(*(dispatch_object_t *)(a1 + 664));
  }
  (*(void (**)(uint64_t))(*(void *)a1 + 24))(a1);
  dispatch_release(*(dispatch_object_t *)(a1 + 40));
  char v5 = *(NSObject **)(a1 + 600);
  if (v5)
  {
    dispatch_sync(v5, &stru_10009D780);
    dispatch_release(*(dispatch_object_t *)(a1 + 600));
  }
  dispatch_sync(*(dispatch_queue_t *)(a1 + 56), &stru_10009D7C0);
  dispatch_release(*(dispatch_object_t *)(a1 + 56));
  sub_10005C008((void *)(a1 + 8));
  return a1;
}

void sub_10005BFD0(uint64_t a1)
{
  sub_10005BE70(a1);

  operator delete();
}

void *sub_10005C008(void *result)
{
  if (result[2])
  {
    os_log_t v1 = result;
    uint64_t result = (void *)result[1];
    uint64_t v2 = *v1;
    uint64_t v3 = *result;
    *(void *)(v3 + 8) = *(void *)(*v1 + 8);
    **(void **)(v2 + 8) = v3;
    v1[2] = 0;
    if (result != v1)
    {
      do
      {
        os_log_t v4 = (void *)result[1];
        operator delete(result);
        uint64_t result = v4;
      }
      while (v4 != v1);
    }
  }
  return result;
}

uint64_t sub_10005C06C(uint64_t result, uint64_t *a2, uint64_t a3, void *a4, void *a5)
{
  if (a4 != a5)
  {
    char v5 = (void *)*a5;
    if (result != a3)
    {
      uint64_t v6 = 1;
      if (v5 != a4)
      {
        uint64_t v7 = a4;
        do
        {
          uint64_t v7 = (void *)v7[1];
          ++v6;
        }
        while (v7 != v5);
      }
      *(void *)(a3 + 16) -= v6;
      *(void *)(result + 16) += v6;
    }
    uint64_t v8 = *a4;
    *(void *)(v8 + 8) = v5[1];
    *(void *)v5[1] = v8;
    uint64_t v9 = *a2;
    *(void *)(v9 + 8) = a4;
    *a4 = v9;
    *a2 = (uint64_t)v5;
    v5[1] = a2;
  }
  return result;
}

void sub_10005C0E4(void *a1, uint64_t a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_error_impl(a1, v9, OS_LOG_TYPE_ERROR, a4, &a9, 8u);
}

uint64_t sub_10005C118@<X0>(uint64_t result@<X0>, int a2@<W1>, uint64_t a3@<X8>)
{
  *(void *)(result + 4) = a3;
  *(_WORD *)(result + 12) = 1025;
  *(_DWORD *)(result + 14) = a2;
  return result;
}

double sub_10005C12C(double *a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8)
{
  double v8 = (a3 - a2) / a6 - (a4 - a2) / (a6 + a7);
  double v9 = (a4 - a3) / a7;
  *(float *)&double v8 = v9 + v8;
  float v10 = (a5 - a4) / a8 + v9 - (a5 - a3) / (a7 + a8);
  *(float *)&double v8 = *(float *)&v8 * a7;
  float v11 = v10 * a7;
  double v12 = *(float *)&v8;
  double v13 = v11;
  *a1 = a3;
  a1[1] = v12;
  double v14 = a4 * 3.0 + a3 * -3.0 + v12 * -2.0 - v13;
  double result = a4 * -2.0 + a3 * 2.0 + v12 + v13;
  a1[2] = v14;
  a1[3] = result;
  return result;
}

double sub_10005C1D0(double *a1, double *a2, double a3)
{
  sub_10005C12C(v5, *a1, a1[1], a1[2], a1[3], a2[1] - *a2, a2[2] - a2[1], a2[3] - a2[2]);
  return v5[0] + a3 * (v5[1] + a3 * (v5[2] + v5[3] * a3));
}

void sub_10005C230(double *a1, double *a2, double *a3, double a4, double a5)
{
  v10[0] = sub_10005C1D0(a1, a3, a5);
  v10[1] = sub_10005C1D0(a1 + 4, a3, a5);
  _DWORD v10[2] = sub_10005C1D0(a1 + 8, a3, a5);
  void v10[3] = sub_10005C1D0(a1 + 12, a3, a5);
  sub_10005C1D0(v10, a2, a4);
}

void sub_10005C300(unsigned __int16 *a1, long double *a2, unsigned int a3)
{
  uint64_t v3 = a1[7];
  if (a1[7])
  {
    int v6 = 0;
    double v7 = (double)(*a1 + 1) * 0.5 + (double)(__int16)a1[8];
    uint64_t v8 = a1[6];
    double v9 = (double)(a1[1] + 1) * 0.5 + (double)(__int16)a1[9];
    double v10 = 0.0;
    do
    {
      if (a1[6])
      {
        unsigned int v11 = a1[4];
        double v12 = (double)(a1[5] + v6 * a1[3]) - v9;
        double v13 = v12 * v12;
        int v14 = a1[6];
        do
        {
          double v15 = sqrt(((double)v11 - v7) * ((double)v11 - v7) + v13);
          if (v15 > v10) {
            double v10 = v15;
          }
          v11 += a1[2];
          --v14;
        }
        while (v14);
      }
      ++v6;
    }
    while (v6 != v3);
    long double v16 = pow((double)a3 / 100.0, 0.25);
    uint64_t v17 = 0;
    do
    {
      if (v8)
      {
        unsigned int v18 = a1[4];
        int v19 = a1[2];
        unsigned int v20 = a1[5] + v17 * a1[3];
        double v21 = ((double)v20 - v9) * ((double)v20 - v9);
        long double v22 = acos(v16);
        uint64_t v23 = v8;
        xpc_object_t v24 = a2;
        double v25 = v10 / tan(v22);
        do
        {
          long double v26 = atan(sqrt(((double)v18 - v7) * ((double)v18 - v7) + v21) / v25);
          long double v27 = cos(v26);
          *v24++ = pow(v27, 4.0);
          v18 += v19;
          --v23;
        }
        while (v23);
      }
      ++v17;
      a2 += v8;
    }
    while (v17 != v3);
  }
}

uint64_t sub_10005C4B0(uint64_t result, uint64_t a2, unsigned __int16 *a3, unsigned __int16 *a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11, double a12)
{
  unsigned int v15 = a3[7];
  if (!a3[7]) {
    return result;
  }
  unsigned int v16 = 0;
  int v17 = a3[3];
  int v18 = a3[2];
  int v19 = a3[5];
  int v20 = a3[4];
  unsigned int v21 = a3[6];
  do
  {
    if (!v21) {
      goto LABEL_33;
    }
    unsigned int v22 = 0;
    double v23 = (double)(v19 + v16 * v17);
    do
    {
      double v24 = (double)(v20 + v22 * v18);
      uint64_t v25 = a4[20];
      if (a4[20])
      {
        uint64_t v26 = 0;
        LOWORD(a12) = *a4;
        *(float *)&a12 = (float)LODWORD(a12);
        while (v24 >= (float)(*(float *)&a4[2 * v26 + 28] * *(float *)&a12))
        {
          if (v25 == ++v26)
          {
            int v27 = a4[20];
            goto LABEL_12;
          }
        }
        int v27 = (unsigned __int16)v26;
      }
      else
      {
        int v27 = 0;
      }
LABEL_12:
      double v28 = (double)(v27 - 1);
      uint64_t v29 = a4[21];
      LOWORD(a12) = a4[1];
      *(float *)&a12 = (float)LODWORD(a12);
      if (a4[21])
      {
        uint64_t v30 = 0;
        while (v23 >= (float)(*(float *)&a4[2 * v30 + 170] * *(float *)&a12))
        {
          if (v29 == ++v30)
          {
            LOWORD(v30) = a4[21];
            break;
          }
        }
        if (!v27) {
          double v28 = 0.0;
        }
        if ((_WORD)v30)
        {
          double v31 = (double)((unsigned __int16)v30 - 1);
          goto LABEL_24;
        }
      }
      else if (!v27)
      {
        double v28 = 0.0;
      }
      double v31 = 0.0;
LABEL_24:
      if (v28 >= (double)((int)v25 - 2)) {
        double v28 = (double)((int)v25 - 2);
      }
      if (v31 >= (double)((int)v29 - 2)) {
        double v31 = (double)((int)v29 - 2);
      }
      unsigned int v32 = vcvtmd_u64_f64(v28);
      unsigned int v33 = vcvtmd_u64_f64(v31);
      unsigned int v34 = v32 + v33 * v25;
      LOBYTE(v28) = *(unsigned char *)(a2 + v34);
      LOBYTE(v12) = *(unsigned char *)(a2 + v34 + 1);
      double v12 = ((double)*(unint64_t *)&v12 + -128.0) * 0.125 * 0.0078125 + 1.0;
      unsigned int v35 = v32 + (v33 + 1) * v25;
      LOBYTE(v13) = *(unsigned char *)(a2 + v35);
      LOBYTE(v14) = *(unsigned char *)(a2 + v35 + 1);
      double v36 = ((double)*(unint64_t *)&v14 + -128.0) * 0.125 * 0.0078125 + 1.0;
      float v37 = (float)*a4;
      float v38 = roundf(*(float *)&a4[2 * v32 + 28] * v37);
      double v39 = roundf(*(float *)&a4[2 * v33 + 170] * *(float *)&a12);
      double v14 = roundf(*(float *)&a4[2 * v32 + 30] * v37);
      float v40 = roundf(*(float *)&a4[2 * v33 + 172] * *(float *)&a12);
      double v41 = v24 - v38;
      double v42 = v14 - v24;
      double v43 = (((double)*(unint64_t *)&v13 + -128.0) * 0.125 * 0.0078125 + 1.0) * v42 + v41 * v36;
      double v13 = v41 + v42;
      double v44 = fmin(((v40 - v23)* (((((double)*(unint64_t *)&v28 + -128.0) * 0.125 * 0.0078125 + 1.0) * v42 + v41 * v12)/ (v41 + v42))+ (v23 - v39) * (v43 / (v41 + v42)))/ (v23 - v39 + v40 - v23), 2.0);
      a12 = v44 * 4096.0;
      if (v44 <= 0.0) {
        double v45 = 0.0;
      }
      else {
        double v45 = v44 * 4096.0;
      }
      *(_WORD *)(result + 2 * (v22 + v21 * v16)) = llround(fmin(v45, 65535.0));
      ++v22;
      unsigned int v21 = a3[6];
    }
    while (v22 < v21);
    unsigned int v15 = a3[7];
LABEL_33:
    ++v16;
  }
  while (v16 < v15);
  return result;
}

uint64_t sub_10005C750(uint64_t result, unsigned __int16 *a2, uint64_t a3, uint64_t a4, uint64_t a5, char a6, unsigned int a7, int a8)
{
  unsigned int v8 = *(unsigned __int16 *)(a5 + 14);
  if (*(_WORD *)(a5 + 14))
  {
    unsigned __int16 v9 = 0;
    unsigned int v10 = 0;
    unsigned int v11 = *(unsigned __int16 *)(a5 + 12);
    do
    {
      if (v11)
      {
        for (unsigned int i = 0; i < v11; ++i)
        {
          uint64_t v13 = i + v10 * v11;
          int v14 = 1 << a6;
          if (a8 != 2) {
            LOWORD(v14) = llround(fmin(*(double *)(a3 + 8 * v13) / *(double *)(a4 + 8 * v13) * (double)(1 << a6), (double)a7));
          }
          *(_WORD *)(result + 2 * v13) = v14;
          if ((unsigned __int16)v14 > v9) {
            unsigned __int16 v9 = v14;
          }
          unsigned int v11 = *(unsigned __int16 *)(a5 + 12);
        }
        unsigned int v8 = *(unsigned __int16 *)(a5 + 14);
      }
      ++v10;
    }
    while (v10 < v8);
  }
  else
  {
    unsigned __int16 v9 = 0;
  }
  *a2 = v9;
  return result;
}

uint64_t sub_10005C7E8(uint64_t result, unsigned __int16 *a2, uint64_t a3, uint64_t a4, double a5, double a6)
{
  unsigned int v6 = *(unsigned __int16 *)(a4 + 14);
  if (*(_WORD *)(a4 + 14))
  {
    uint64_t v7 = 0;
    unsigned int v8 = 0;
    unsigned __int16 v9 = 0;
    unsigned int v10 = *(unsigned __int16 *)(a4 + 12);
    do
    {
      if (v10)
      {
        uint64_t v11 = 0;
        do
        {
          uint64_t v12 = v11 + v7 * v10;
          LOWORD(a6) = *(_WORD *)(result + 2 * v12);
          HIWORD(v13) = 17792;
          LOWORD(v13) = *(_WORD *)(a3 + 2 * v12);
          a6 = fmin((float)((float)((float)LODWORD(a6) * 4096.0) / (float)v13), 65535.0);
          unsigned int v14 = llround(a6);
          *(_WORD *)(result + 2 * v12) = v14;
          if (v9 <= v14) {
            unsigned __int16 v9 = v14;
          }
          unsigned int v10 = *(unsigned __int16 *)(a4 + 12);
          ++v11;
        }
        while (v11 < v10);
        unsigned int v6 = *(unsigned __int16 *)(a4 + 14);
      }
      ++v8;
      ++v7;
    }
    while (v8 < v6);
  }
  else
  {
    unsigned __int16 v9 = 0;
  }
  *a2 = v9;
  return result;
}

uint64_t sub_10005C888(uint64_t result, unsigned __int16 *a2, uint64_t a3, uint64_t a4, char a5)
{
  unsigned int v5 = *(unsigned __int16 *)(a4 + 14);
  if (*(_WORD *)(a4 + 14))
  {
    uint64_t v6 = 0;
    unsigned __int16 v7 = 0;
    unsigned int v8 = 0;
    unsigned int v9 = *(unsigned __int16 *)(a4 + 12);
    do
    {
      if (v9)
      {
        uint64_t v10 = 0;
        do
        {
          uint64_t v11 = v10 + v6 * v9;
          unsigned int v12 = llround(fmin(1.0 / *(double *)(a3 + 8 * v11) * (double)(1 << a5), 65535.0));
          *(_WORD *)(result + 2 * v11) = v12;
          if (v7 <= v12) {
            unsigned __int16 v7 = v12;
          }
          unsigned int v9 = *(unsigned __int16 *)(a4 + 12);
          ++v10;
        }
        while (v10 < v9);
        unsigned int v5 = *(unsigned __int16 *)(a4 + 14);
      }
      ++v8;
      ++v6;
    }
    while (v8 < v5);
  }
  else
  {
    unsigned __int16 v7 = 0;
  }
  *a2 = v7;
  return result;
}

uint64_t sub_10005C920(uint64_t a1, uint64_t a2, unsigned int a3, unsigned int a4, uint64_t a5, uint64_t a6, unsigned __int16 *a7, unsigned __int16 *a8, double a9, double a10, double a11, double a12, double a13, double a14, double a15, double a16, uint64_t a17)
{
  if (a3)
  {
    int v21 = 0;
    do
    {
      v61[v21] = *(_DWORD *)(a5 + 4 * v21);
      ++v21;
    }
    while (a3 > v21);
  }
  if (a4)
  {
    int v22 = 0;
    do
    {
      v61[v22 + 71] = *(_DWORD *)(a6 + 4 * v22);
      ++v22;
    }
    while (a4 > v22);
  }
  unsigned int v23 = a3 - 1;
  int64x2_t v55 = vdupq_n_s64(0x3F847AE147AE147BuLL);
  int v24 = a4 - 1;
  v65[0] = a1 + 18;
  v65[1] = a1 + 36;
  v65[2] = a1 + 54;
  v65[3] = a1 + 72;
  v54[0] = *(_WORD *)(a1 + 14) >> 1;
  int v25 = *(unsigned __int16 *)(a1 + 16) >> 1;
  v54[1] = *(_WORD *)(a1 + 16) >> 1;
  __int16 v58 = a3;
  __int16 v59 = a4;
  double v56 = 0.98 / (double)(int)(a3 - 1);
  double v57 = 0.98 / (double)(int)(a4 - 1);
  uint64_t v60 = 0x406F400000000000;
  v62[0] = v54[0];
  v62[1] = v25;
  int v63 = *(_DWORD *)(a1 + 20);
  LODWORD(v64) = *(_DWORD *)(a1 + 28);
  uint64_t v26 = *(unsigned __int16 *)(a1 + 32);
  HIDWORD(v64) = *(_DWORD *)(a1 + 32);
  uint64_t v27 = HIWORD(v64);
  sub_10005C4B0(a17, a2, v62, v54, 0.98 / (double)v24, v56, (double)v24, a12, a13, a14, a15, a16);
  if (v27)
  {
    unint64_t v29 = 0;
    uint64_t v30 = a4 >> 1;
    uint64_t v31 = a17;
    do
    {
      if (v26)
      {
        for (uint64_t i = 0; i != v26; ++i)
        {
          if (i < *a7 - 1 || i >= (unint64_t)a7[v23] || v29 > a8[v30 - 1] && v29 < a8[v30]) {
            *(_WORD *)(v31 + 2 * i) = 4096;
          }
        }
      }
      ++v29;
      v31 += 2 * v26;
    }
    while (v29 != v27);
  }
  unint64_t v33 = *a8;
  int v34 = v33 - 1;
  if (v33 > 1)
  {
    int64_t v35 = v33 - 2;
    double v36 = (_WORD *)(a17 + 2 * (int)v35 * (uint64_t)(int)v26);
    float v37 = (__int16 *)(a17 + 2 * v34 * (uint64_t)(int)v26);
    do
    {
      uint64_t v38 = v26;
      double v39 = v37;
      float v40 = v36;
      if (v26)
      {
        do
        {
          __int16 v41 = *v39++;
          *v40++ = v41;
          --v38;
        }
        while (v38);
      }
      v36 -= v26;
      v37 -= v26;
    }
    while (v35-- > 0);
  }
  uint64_t v43 = a8[v24];
  if (v43 < a4)
  {
    unint64_t v44 = a8[v24] * (unint64_t)v26;
    double v45 = (__int16 *)(a17 + 2 * ((int)v43 - 1) * (uint64_t)(int)v26);
    do
    {
      uint64_t v46 = v26;
      uint64_t v47 = v45;
      unint64_t v48 = v44;
      if (v26)
      {
        do
        {
          __int16 v49 = *v47++;
          *(_WORD *)(a17 + 2 * v48++) = v49;
          --v46;
        }
        while (v46);
      }
      ++v43;
      v44 += v26;
      v45 += v26;
    }
    while (v43 != a4);
  }
  uint64_t v50 = 0;
  uint64_t v51 = a1 + 92;
  do
  {
    uint64_t v52 = v65[v50];
    int v63 = *(_DWORD *)(v52 + 2);
    double v64 = *(double *)(v52 + 10);
    uint64_t result = sub_10005C7E8(v51 + 2 * *(unsigned __int16 *)(v52 + 6), (unsigned __int16 *)v52, a17, (uint64_t)v62, v64, v28);
    ++v50;
  }
  while (v50 != 4);
  return result;
}

uint64_t sub_10005CC30(uint64_t result)
{
  uint64_t v1 = 0;
  v9[0] = result + 18;
  v9[1] = result + 36;
  v9[2] = result + 54;
  v9[3] = result + 72;
  do
  {
    uint64_t v2 = (unsigned __int16 *)v9[v1];
    int64_t v3 = ((unint64_t)(v2[7] * v2[8]) << 32) - 0x100000000;
    if (v3 >= 1)
    {
      uint64_t v4 = v2[3];
      unsigned int v5 = (_WORD *)(result + 92 + 2 * v4);
      unint64_t v6 = result + 90 + (((unint64_t)v3 >> 31) & 0x1FFFFFFFELL) + 2 * v4;
      do
      {
        __int16 v7 = *(_WORD *)(v6 + 2);
        *(_WORD *)(v6 + 2) = *v5;
        *v5++ = v7;
        BOOL v8 = v6 > (unint64_t)v5;
        v6 -= 2;
      }
      while (v8);
    }
    ++v1;
  }
  while (v1 != 4);
  return result;
}

unint64_t sub_10005CD04(unsigned __int8 *a1, uint64_t a2)
{
  uint64_t v2 = 0;
  uint64_t v3 = 0;
  uint64_t v4 = a1[1] * *a1;
  uint64_t v5 = (v4 - 1);
  uint64_t v6 = a2 + v5;
  __int16 v7 = a1 + 264;
  BOOL v8 = &a1[v5 + 264];
  do
  {
    unsigned int v9 = v7;
    uint64_t v10 = v8;
    uint64_t v11 = a2;
    uint64_t v12 = v6;
    do
    {
      *(unsigned char *)(v11 + v2) = v10[v2];
      unint64_t result = v11 + v2 + 1;
      *(unsigned char *)(v12 + v2) = v9[v2];
      --v12;
      ++v11;
      --v10;
      ++v9;
    }
    while (v12 + v2 >= result);
    ++v3;
    v2 += v4;
  }
  while (v3 != 4);
  return result;
}

unsigned __int16 *sub_10005CD7C(unsigned __int16 *result)
{
  int v1 = result[16];
  if (v1 != result[43]) {
    sub_10007AC84();
  }
  int v2 = result[17];
  if (v2 != result[44]) {
    sub_10007AC58();
  }
  unsigned int v3 = v2 * v1;
  if (v3)
  {
    int v4 = 0;
    uint64_t v5 = &result[result[39] + 46];
    uint64_t v6 = &result[result[12] + 46];
    do
    {
      unsigned int v7 = (*v5 + *v6) >> 1;
      *v6++ = v7;
      *v5++ = v7;
      ++v4;
    }
    while (v3 > (unsigned __int16)v4);
  }
  return result;
}

unint64_t sub_10005CDFC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5, int a6)
{
  uint64_t v8 = 0;
  unsigned int v9 = *(unsigned __int16 *)(a3 + 14);
  unsigned int v10 = *(unsigned __int16 *)(a3 + 16);
  v88[0] = a3 + 18;
  v88[1] = a3 + 36;
  v88[2] = a3 + 54;
  v88[3] = a3 + 72;
  memset(v87, 0, 32);
  do
  {
    v87[v8] = a3 + 92 + 2 * *(unsigned __int16 *)(v88[v8] + 6);
    ++v8;
  }
  while (v8 != 4);
  uint64_t v11 = 0;
  float v12 = (double)v9 * 0.5;
  float v13 = (double)v10 * 0.5;
  v86[0] = 0;
  v86[1] = v9;
  float v14 = (float)a5 + v12;
  float v15 = (float)a6 + v13;
  v86[2] = 0;
  v86[3] = v9;
  uint64_t v83 = 0;
  unsigned int v84 = v10;
  unsigned int v85 = v10;
  v82[0] = 0;
  v82[1] = 0;
  float v16 = 0.0;
  do
  {
    double v17 = (float)(v14 - (float)(int)v86[v11]);
    double v18 = (float)(v15 - (float)*(int *)((char *)&v83 + v11 * 4));
    float v19 = sqrt(v17 * v17 + v18 * v18);
    *(float *)((char *)v82 + v11 * 4) = v19;
    if (v16 < v19) {
      float v16 = v19;
    }
    ++v11;
  }
  while (v11 != 4);
  bzero(v81, 0x808uLL);
  bzero(v80, 0x404uLL);
  float v20 = log2f(v16 * 0.0039062);
  uint64_t v24 = 0;
  unsigned int v25 = vcvtps_s32_f32(v20);
  *(_WORD *)(a1 + 12) = v25;
  int v26 = v25 * v25;
  int v27 = v26 << 8;
  do
  {
    uint64_t v28 = 0;
    unint64_t result = v88[v24];
    unsigned int v30 = *(unsigned __int16 *)(result + 2);
    unsigned int v31 = *(unsigned __int16 *)(result + 4);
    double v32 = (double)v31;
    do
    {
      unsigned int v33 = 0;
      uint64_t v34 = 0;
      float v35 = (float)(int)v86[v28] - v14;
      float v36 = *((float *)v82 + v28);
      float v37 = (float)*((int *)&v83 + v28) - v15;
      do
      {
        if ((float)((float)v33 * 0.0039062) >= v16) {
          float v38 = v16;
        }
        else {
          float v38 = (float)v33 * 0.0039062;
        }
        double v39 = (float)(v14 + (float)((float)(v38 * v35) / v36)) * 0.5;
        unsigned int v40 = (int)(v39 / (double)v30);
        if ((v40 & 0x80000000) != 0) {
          break;
        }
        double v41 = (float)(v15 + (float)((float)(v38 * v37) / v36)) * 0.5;
        double v42 = v41 / v32;
        int v43 = (int)(v41 / v32);
        if (v43 < 0) {
          break;
        }
        int v44 = *(unsigned __int16 *)(result + 14);
        if (v44 - 2 < (int)v40) {
          break;
        }
        if (*(unsigned __int16 *)(result + 16) - 2 < v43) {
          break;
        }
        uint64_t v45 = v87[v24];
        uint64_t v46 = (_WORD *)(v45 + 2 * v44 * v43 + 2 * v40);
        LOWORD(v42) = *v46;
        LOWORD(v21) = v46[1];
        double v21 = (float)((float)LODWORD(v21) * 0.00024414);
        uint64_t v47 = (_WORD *)(v45 + 2 * (v43 + 1) * v44 + 2 * v40);
        LOWORD(v22) = *v47;
        LOWORD(v23) = v47[1];
        double v48 = (float)((float)LODWORD(v23) * 0.00024414);
        int v49 = v40 * v30;
        double v23 = v39 - (double)v49;
        double v50 = (double)(int)(v30 + v49) - v39;
        double v51 = v50 * (float)((float)LODWORD(v22) * 0.00024414) + v23 * v48;
        double v22 = v23 + v50;
        v81[v34] = v81[v34]
                 + (((double)(int)((v43 + 1) * v31) - v41)
                  * ((v50 * (float)((float)LODWORD(v42) * 0.00024414) + v23 * v21)
                   / (v23 + v50))
                  + (v41 - (double)(int)(v43 * v31)) * (v51 / (v23 + v50)))
                 / (v41 - (double)(int)(v43 * v31) + (double)(int)((v43 + 1) * v31) - v41);
        ++v80[v34++];
        v33 += v27;
      }
      while (v34 != 257);
      ++v28;
    }
    while (v28 != 4);
    ++v24;
  }
  while (v24 != 4);
  for (uint64_t i = 0; i != 257; ++i)
  {
    int v53 = v80[i];
    double v54 = v81[i];
    if (v53 >= 1)
    {
      double v32 = (double)v53;
      double v54 = v54 / (double)v53;
      v81[i] = v54;
    }
    *(_WORD *)(a1 + 14 + 2 * i) = vcvtd_n_s64_f64(1.0 / v54, 0xCuLL);
  }
  if (a2)
  {
    uint64_t v55 = 0;
    double v56 = 0.0;
    double v57 = 0.0;
    do
    {
      uint64_t v58 = v88[v55];
      unint64_t v59 = *(unsigned __int16 *)(v58 + 14);
      uint64_t v60 = v87[v55];
      LOWORD(v32) = *(_WORD *)(v60 + 2 * (v59 >> 1));
      double v61 = (float)((float)LODWORD(v32) * 0.00024414);
      double v62 = v57 + v61;
      LODWORD(v58) = *(unsigned __int16 *)(v58 + 16);
      unint64_t result = (v58 - 1);
      LOWORD(v61) = *(_WORD *)(v60 + 2 * ((v59 >> 1) + result * v59));
      double v63 = (float)((float)LODWORD(v61) * 0.00024414);
      double v57 = v62 + v63;
      LODWORD(v58) = (v58 >> 1) * v59;
      LOWORD(v63) = *(_WORD *)(v60 + 2 * v58);
      double v64 = (float)((float)LODWORD(v63) * 0.00024414);
      double v65 = v56 + v64;
      LOWORD(v64) = *(_WORD *)(v60 + 2 * (v59 + v58 - 1));
      double v32 = (float)((float)LODWORD(v64) * 0.00024414);
      double v56 = v65 + v32;
      ++v55;
    }
    while (v55 != 4);
    int v66 = 0;
    uint64_t v67 = 0;
    double v68 = v57 * 0.125;
    double v69 = v56 * 0.125;
    while (v81[v67] <= v69)
    {
      ++v67;
      v66 -= v27;
      if (v67 == 257)
      {
        double v70 = v12;
        goto LABEL_35;
      }
    }
    double v70 = v12;
    if ((v67 - 1) <= 0xFF)
    {
      double v71 = v81[v67];
      double v72 = v81[(v67 - 1)];
      double v73 = 0.5;
      if (vabdd_f64(v71, v72) > 1.0e-10) {
        double v73 = (v69 - v72) / (v71 - v72);
      }
      double v70 = v73 * (float)((float)-v66 * 0.0039062)
          + (1.0 - v73) * (float)((float)-(v66 + (v26 << 8)) * 0.0039062);
    }
LABEL_35:
    int v74 = 0;
    uint64_t v75 = 0;
    while (v81[v75] <= v68)
    {
      ++v75;
      v74 -= v27;
      if (v75 == 257)
      {
        double v76 = v13;
        goto LABEL_43;
      }
    }
    double v76 = v13;
    if ((v75 - 1) <= 0xFF)
    {
      double v77 = v81[v75];
      double v78 = v81[(v75 - 1)];
      double v79 = 0.5;
      if (vabdd_f64(v77, v78) > 1.0e-10) {
        double v79 = (v68 - v78) / (v77 - v78);
      }
      double v76 = v79 * (float)((float)-v74 * 0.0039062)
          + (1.0 - v79) * (float)((float)-(v74 + (v26 << 8)) * 0.0039062);
    }
LABEL_43:
    *(_WORD *)(a2 + 12) = llround(fmin(v70 / v12 * 4096.0 + 0.5, 65535.0));
    *(_WORD *)(a2 + 14) = llround(fmin(v76 / v13 * 4096.0 + 0.5, 65535.0));
  }
  return result;
}

void sub_10005D424(uint64_t a1, uint64_t a2, unsigned int a3, unsigned int a4, char a5, uint64_t a6, uint64_t a7, int a8, int a9, uint64_t a10, uint64_t a11)
{
  int v11 = *(unsigned __int16 *)(a1 + 14) >> 1;
  __int16 v27 = *(_WORD *)(a1 + 14) >> 1;
  int v12 = *(unsigned __int16 *)(a1 + 16) >> 1;
  __int16 v28 = *(_WORD *)(a1 + 16) >> 1;
  if (a8 >= 0) {
    unsigned int v13 = a8;
  }
  else {
    unsigned int v13 = a8 + 1;
  }
  __int16 v33 = v13 >> 1;
  __int16 v34 = a9 / 2;
  if (a3)
  {
    int v14 = 0;
    do
    {
      v26[v14] = *(_DWORD *)(a10 + 4 * v14);
      ++v14;
    }
    while (a3 > v14);
  }
  if (a4)
  {
    int v15 = 0;
    do
    {
      v26[v15 + 27] = *(_DWORD *)(a11 + 4 * v15);
      ++v15;
    }
    while (a4 > v15);
  }
  uint64_t v35 = a1 + 18;
  uint64_t v36 = a1 + 36;
  uint64_t v37 = a1 + 54;
  uint64_t v38 = a1 + 72;
  __int16 v19 = v11;
  __int16 v20 = v12;
  __int16 v23 = a3;
  __int16 v24 = a4;
  int32x2_t v16 = vadd_s32((int32x2_t)__PAIR64__(a4, a3), (int32x2_t)-1);
  v17.i64[0] = v16.i32[0];
  v17.i64[1] = v16.i32[1];
  int64x2_t v21 = vdupq_n_s64(0x3F847AE147AE147BuLL);
  float64x2_t v22 = vdivq_f64((float64x2_t)vdupq_n_s64(0x3FEF5C28F5C28F5CuLL), vcvtq_f64_s64(v17));
  double v25 = (double)(1 << (a5 - 8)) * 250.0;
  int v18 = *(_DWORD *)(a1 + 28);
  int v29 = *(_DWORD *)(a1 + 20);
  int v30 = v18;
  __int16 v31 = *(_WORD *)(a1 + 32);
  __int16 v32 = *(_WORD *)(a1 + 34);
  operator new[]();
}

void sub_10005D724(uint64_t a1, uint64_t a2, unsigned __int16 *a3, uint64_t a4, int a5, double a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13)
{
  uint64_t v70 = a3[7];
  if (a3[7])
  {
    int v69 = a3[3];
    int v16 = a3[2];
    int v68 = a3[5];
    uint64_t v17 = a4 + 56;
    uint64_t v18 = a4 + 164;
    int v19 = a3[4];
    uint64_t v20 = a3[6];
    int v74 = v19;
    uint64_t v75 = a2 - 2;
    uint64_t v73 = v20;
    uint64_t v71 = 0;
    int v72 = v16;
    while (!v20)
    {
LABEL_50:
      if (++v71 == v70) {
        return;
      }
    }
    uint64_t v21 = 0;
    double v22 = (double)(v68 + v71 * v69);
    uint64_t v23 = *(unsigned __int16 *)(a4 + 40);
    uint64_t v24 = *(unsigned __int16 *)(a4 + 42);
    double v25 = -3.0;
    uint64_t v26 = v71 * v20;
    while (1)
    {
      double v27 = (double)(v19 + v21 * v16);
      if (v23)
      {
        uint64_t v28 = 0;
        LOWORD(v25) = *(_WORD *)a4;
        *(float *)&double v25 = (float)LODWORD(v25);
        while (v27 >= (float)(*(float *)(v17 + 4 * v28) * *(float *)&v25))
        {
          if (v23 == ++v28)
          {
            LOWORD(v28) = v23;
            if (v24) {
              goto LABEL_12;
            }
            goto LABEL_17;
          }
        }
        if (v24) {
          goto LABEL_12;
        }
      }
      else
      {
        LOWORD(v28) = 0;
        if (v24)
        {
LABEL_12:
          uint64_t v29 = 0;
          LOWORD(v25) = *(_WORD *)(a4 + 2);
          *(float *)&double v25 = (float)LODWORD(v25);
          while (v22 >= (float)(*(float *)(v18 + 4 * v29) * *(float *)&v25))
          {
            if (v24 == ++v29)
            {
              unsigned __int16 v30 = v24;
              goto LABEL_19;
            }
          }
          unsigned __int16 v30 = v29;
          goto LABEL_19;
        }
      }
LABEL_17:
      unsigned __int16 v30 = 0;
LABEL_19:
      uint64_t v31 = (unsigned __int16)v28;
      uint64_t v32 = (unsigned __int16)v28 - 1;
      double v33 = (double)(int)v32;
      unsigned int v34 = v30;
      uint64_t v35 = v30 - 1;
      double v36 = (double)(int)v35;
      if (v31 < 2
        || (signed int v37 = v34 - 2, v34 < 2)
        || ((double)v23 + -3.0 >= v33 ? (BOOL v38 = a5 == 0) : (BOOL v38 = 1),
            !v38 ? (BOOL v39 = (double)v24 + -3.0 < v36) : (BOOL v39 = 1),
            v39))
      {
        if (!v31) {
          double v33 = 0.0;
        }
        if (!v34) {
          double v36 = 0.0;
        }
        if (v33 >= (double)((int)v23 - 2)) {
          double v33 = (double)((int)v23 - 2);
        }
        if (v36 >= (double)((int)v24 - 2)) {
          double v36 = (double)((int)v24 - 2);
        }
        unsigned int v54 = vcvtmd_u64_f64(v33);
        unsigned int v55 = vcvtmd_u64_f64(v36);
        unsigned int v56 = v54 + v55 * v23;
        LOBYTE(v33) = *(unsigned char *)(a2 + v56);
        double v57 = *(double *)(a4 + 48);
        LOBYTE(a9) = *(unsigned char *)(a2 + v56 + 1);
        unsigned int v58 = v54 + (v55 + 1) * v23;
        LOBYTE(a10) = *(unsigned char *)(a2 + v58);
        LOBYTE(a11) = *(unsigned char *)(a2 + v58 + 1);
        LOWORD(a13) = *(_WORD *)a4;
        float v59 = (float)LODWORD(a13);
        float v60 = roundf(*(float *)(a4 + 56 + 4 * v54) * v59);
        LOWORD(v13) = *(_WORD *)(a4 + 2);
        float v61 = (float)LODWORD(v13);
        float v62 = roundf(*(float *)(a4 + 164 + 4 * v55) * v61);
        a13 = roundf(*(float *)(a4 + 56 + 4 * (v54 + 1)) * v59);
        double v13 = roundf(*(float *)(a4 + 164 + 4 * (v55 + 1)) * v61);
        double v63 = v27 - v60;
        double v64 = a13 - v27;
        double v65 = (double)*(unint64_t *)&a10 / v57 * v64 + v63 * ((double)*(unint64_t *)&a11 / v57);
        a11 = v63 + v64;
        a10 = v65 / (v63 + v64);
        double v66 = ((double)*(unint64_t *)&v33 / v57 * v64 + v63 * ((double)*(unint64_t *)&a9 / v57))
            / (v63 + v64);
        a9 = v13 - v22;
        double v67 = fmin(((v13 - v22) * v66 + (v22 - v62) * a10) / (v22 - v62 + v13 - v22), 1.0);
        double v25 = 1.0 / v57;
        if (v67 <= 1.0 / v57) {
          double v67 = 1.0 / v57;
        }
        *(double *)(a1 + 8 * (v26 + v21)) = v67;
      }
      else
      {
        uint64_t v40 = 0;
        double v41 = *(double *)(a4 + 48);
        uint64_t v42 = v37;
        int v43 = (unsigned char *)(v75 + v31 + (int)v23 * (uint64_t)v37);
        int v44 = v80;
        do
        {
          uint64_t v45 = 0;
          v79[v40] = *(float *)(a4 + 4 * (v40 + (int)v31 - 2) + 56);
          double v46 = *(float *)(a4 + 4 * (v40 + v42) + 164);
          v78[v40] = v46;
          uint64_t v47 = v43;
          do
          {
            LOBYTE(v46) = *v47;
            double v46 = (double)*(unint64_t *)&v46 / v41;
            v44[v45] = v46;
            v47 += v23;
            ++v45;
          }
          while (v45 != 4);
          ++v40;
          ++v43;
          v44 += 4;
        }
        while (v40 != 4);
        LOWORD(v46) = *(_WORD *)a4;
        double v48 = v27 / (double)*(unint64_t *)&v46;
        float v49 = *(float *)(a4 + 56 + 4 * v32);
        double v50 = v48 - v49;
        *(double *)&unint64_t v51 = (float)(*(float *)(a4 + 56 + 4 * v31) - v49);
        double v52 = v50 / *(double *)&v51;
        LOWORD(v51) = *(_WORD *)(a4 + 2);
        sub_10005C230(v80, v79, v78, v52, (v22 / (double)v51 - *(float *)(a4 + 164 + 4 * v35))/ (float)(*(float *)(a4 + 164 + 4 * v34) - *(float *)(a4 + 164 + 4 * v35)));
        double v25 = 1.0 / v41;
        if (v53 >= 1.0)
        {
          int v16 = v72;
          uint64_t v20 = v73;
          int v19 = v74;
          if (v25 < 1.0) {
            double v25 = 1.0;
          }
        }
        else
        {
          int v16 = v72;
          uint64_t v20 = v73;
          int v19 = v74;
          if (v53 > v25) {
            double v25 = v53;
          }
        }
        *(double *)(a1 + 8 * (v26 + v21)) = v25;
      }
      if (++v21 == v20) {
        goto LABEL_50;
      }
    }
  }
}

void sub_10005DBA8(uint64_t a1, uint64_t a2, unsigned int a3, unsigned int a4, char a5, uint64_t a6, uint64_t a7, int a8, int a9, uint64_t a10, uint64_t a11)
{
  int v11 = *(unsigned __int16 *)(a1 + 14) >> 1;
  __int16 v27 = *(_WORD *)(a1 + 14) >> 1;
  int v12 = *(unsigned __int16 *)(a1 + 16) >> 1;
  __int16 v28 = *(_WORD *)(a1 + 16) >> 1;
  if (a8 >= 0) {
    unsigned int v13 = a8;
  }
  else {
    unsigned int v13 = a8 + 1;
  }
  __int16 v33 = v13 >> 1;
  __int16 v34 = a9 / 2;
  if (a3)
  {
    int v14 = 0;
    do
    {
      v26[v14] = *(_DWORD *)(a10 + 4 * v14);
      ++v14;
    }
    while (a3 > v14);
  }
  if (a4)
  {
    int v15 = 0;
    do
    {
      v26[v15 + 27] = *(_DWORD *)(a11 + 4 * v15);
      ++v15;
    }
    while (a4 > v15);
  }
  uint64_t v35 = a1 + 18;
  uint64_t v36 = a1 + 36;
  uint64_t v37 = a1 + 54;
  uint64_t v38 = a1 + 72;
  __int16 v19 = v11;
  __int16 v20 = v12;
  __int16 v23 = a3;
  __int16 v24 = a4;
  int32x2_t v16 = vadd_s32((int32x2_t)__PAIR64__(a4, a3), (int32x2_t)-1);
  v17.i64[0] = v16.i32[0];
  v17.i64[1] = v16.i32[1];
  int64x2_t v21 = vdupq_n_s64(0x3F847AE147AE147BuLL);
  float64x2_t v22 = vdivq_f64((float64x2_t)vdupq_n_s64(0x3FEF5C28F5C28F5CuLL), vcvtq_f64_s64(v17));
  double v25 = (double)(1 << (a5 - 8)) * 250.0;
  int v18 = *(_DWORD *)(a1 + 28);
  int v29 = *(_DWORD *)(a1 + 20);
  int v30 = v18;
  __int16 v31 = *(_WORD *)(a1 + 32);
  __int16 v32 = *(_WORD *)(a1 + 34);
  operator new[]();
}

uint64_t sub_10005DEA8(uint64_t result, uint64_t a2, unsigned __int16 *a3, uint64_t a4, int a5, double a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13)
{
  uint64_t v70 = a3[7];
  if (a3[7])
  {
    uint64_t v71 = 0;
    uint64_t v72 = result;
    int v69 = a3[3];
    int v15 = a3[2];
    int v68 = a3[5];
    uint64_t v16 = a4 + 56;
    uint64_t v17 = a4 + 164;
    uint64_t v75 = a2 - 4;
    int v76 = v15;
    int v18 = a3[4];
    uint64_t v19 = a3[6];
    uint64_t v73 = v19;
    int v74 = v18;
    while (!v19)
    {
LABEL_50:
      if (++v71 == v70) {
        return result;
      }
    }
    uint64_t v20 = 0;
    double v21 = (double)(v68 + v71 * v69);
    uint64_t v22 = *(unsigned __int16 *)(a4 + 40);
    uint64_t v23 = *(unsigned __int16 *)(a4 + 42);
    double v24 = -3.0;
    uint64_t v25 = v71 * v19;
    uint64_t v26 = 2 * v22;
    while (1)
    {
      double v27 = (double)(v18 + v20 * v15);
      if (v22)
      {
        uint64_t v28 = 0;
        LOWORD(v24) = *(_WORD *)a4;
        *(float *)&double v24 = (float)LODWORD(v24);
        while (v27 >= (float)(*(float *)(v16 + 4 * v28) * *(float *)&v24))
        {
          if (v22 == ++v28)
          {
            LOWORD(v28) = v22;
            if (v23) {
              goto LABEL_12;
            }
            goto LABEL_17;
          }
        }
        if (v23) {
          goto LABEL_12;
        }
      }
      else
      {
        LOWORD(v28) = 0;
        if (v23)
        {
LABEL_12:
          uint64_t v29 = 0;
          LOWORD(v24) = *(_WORD *)(a4 + 2);
          *(float *)&double v24 = (float)LODWORD(v24);
          while (v21 >= (float)(*(float *)(v17 + 4 * v29) * *(float *)&v24))
          {
            if (v23 == ++v29)
            {
              unsigned __int16 v30 = v23;
              goto LABEL_19;
            }
          }
          unsigned __int16 v30 = v29;
          goto LABEL_19;
        }
      }
LABEL_17:
      unsigned __int16 v30 = 0;
LABEL_19:
      unsigned int v31 = (unsigned __int16)v28;
      uint64_t v32 = (unsigned __int16)v28 - 1;
      double v33 = (double)(int)v32;
      unsigned int v34 = v30;
      uint64_t v35 = v30 - 1;
      double v36 = (double)(int)v35;
      if (v31 < 2
        || (signed int v37 = v34 - 2, v34 < 2)
        || ((double)v22 + -3.0 >= v33 ? (BOOL v38 = a5 == 0) : (BOOL v38 = 1),
            !v38 ? (BOOL v39 = (double)v23 + -3.0 < v36) : (BOOL v39 = 1),
            v39))
      {
        if (!v31) {
          double v33 = 0.0;
        }
        if (!v34) {
          double v36 = 0.0;
        }
        if (v33 >= (double)((int)v22 - 2)) {
          double v33 = (double)((int)v22 - 2);
        }
        if (v36 >= (double)((int)v23 - 2)) {
          double v36 = (double)((int)v23 - 2);
        }
        unsigned int v54 = vcvtmd_u64_f64(v33);
        unsigned int v55 = vcvtmd_u64_f64(v36);
        unsigned int v56 = v54 + v55 * v22;
        LOWORD(v33) = *(_WORD *)(a2 + 2 * v56);
        double v57 = *(double *)(a4 + 48);
        LOWORD(a9) = *(_WORD *)(a2 + 2 * (v56 + 1));
        unsigned int v58 = v54 + (v55 + 1) * v22;
        LOWORD(a10) = *(_WORD *)(a2 + 2 * v58);
        LOWORD(a11) = *(_WORD *)(a2 + 2 * (v58 + 1));
        LOWORD(a13) = *(_WORD *)a4;
        float v59 = (float)LODWORD(a13);
        float v60 = roundf(*(float *)(a4 + 56 + 4 * v54) * v59);
        LOWORD(v13) = *(_WORD *)(a4 + 2);
        float v61 = (float)LODWORD(v13);
        float v62 = roundf(*(float *)(a4 + 164 + 4 * v55) * v61);
        a13 = roundf(*(float *)(a4 + 56 + 4 * (v54 + 1)) * v59);
        double v13 = roundf(*(float *)(a4 + 164 + 4 * (v55 + 1)) * v61);
        double v63 = v27 - v60;
        double v64 = a13 - v27;
        double v65 = (double)*(unint64_t *)&a10 / v57 * v64 + v63 * ((double)*(unint64_t *)&a11 / v57);
        a11 = v63 + v64;
        a10 = v65 / (v63 + v64);
        double v66 = ((double)*(unint64_t *)&v33 / v57 * v64 + v63 * ((double)*(unint64_t *)&a9 / v57))
            / (v63 + v64);
        a9 = v13 - v21;
        double v67 = fmin(((v13 - v21) * v66 + (v21 - v62) * a10) / (v21 - v62 + v13 - v21), 1.0);
        double v24 = 1.0 / v57;
        if (v67 <= 1.0 / v57) {
          double v67 = 1.0 / v57;
        }
        *(double *)(result + 8 * (v25 + v20)) = v67;
      }
      else
      {
        uint64_t v40 = 0;
        double v41 = *(double *)(a4 + 48);
        uint64_t v42 = v37;
        int v43 = (_WORD *)(v75 + 2 * v31 + (int)v26 * (uint64_t)v37);
        int v44 = v81;
        do
        {
          uint64_t v45 = 0;
          v80[v40] = *(float *)(a4 + 4 * (v40 + (int)(v31 - 2)) + 56);
          double v46 = *(float *)(a4 + 4 * (v40 + v42) + 164);
          v79[v40] = v46;
          uint64_t v47 = v43;
          do
          {
            LOWORD(v46) = *v47;
            double v46 = (double)*(unint64_t *)&v46 / v41;
            v44[v45] = v46;
            uint64_t v47 = (_WORD *)((char *)v47 + v26);
            ++v45;
          }
          while (v45 != 4);
          ++v40;
          ++v43;
          v44 += 4;
        }
        while (v40 != 4);
        LOWORD(v46) = *(_WORD *)a4;
        double v48 = v27 / (double)*(unint64_t *)&v46;
        float v49 = *(float *)(a4 + 56 + 4 * v32);
        double v50 = v48 - v49;
        *(double *)&unint64_t v51 = (float)(*(float *)(a4 + 56 + 4 * v31) - v49);
        double v52 = v50 / *(double *)&v51;
        LOWORD(v51) = *(_WORD *)(a4 + 2);
        sub_10005C230(v81, v80, v79, v52, (v21 / (double)v51 - *(float *)(a4 + 164 + 4 * v35))/ (float)(*(float *)(a4 + 164 + 4 * v34) - *(float *)(a4 + 164 + 4 * v35)));
        double v24 = 1.0 / v41;
        if (v53 >= 1.0)
        {
          unint64_t result = v72;
          uint64_t v19 = v73;
          int v15 = v76;
          int v18 = v74;
          if (v24 < 1.0) {
            double v24 = 1.0;
          }
        }
        else
        {
          unint64_t result = v72;
          uint64_t v19 = v73;
          int v15 = v76;
          int v18 = v74;
          if (v53 > v24) {
            double v24 = v53;
          }
        }
        *(double *)(result + 8 * (v25 + v20)) = v24;
      }
      if (++v20 == v19) {
        goto LABEL_50;
      }
    }
  }
  return result;
}

void sub_10005E338(uint64_t a1, int a2, unsigned int a3, unsigned int a4, uint64_t a5, uint64_t a6, int a7, int __e)
{
  int v8 = *(unsigned __int16 *)(a1 + 14) >> 1;
  __int16 v23 = *(_WORD *)(a1 + 14) >> 1;
  int v9 = *(unsigned __int16 *)(a1 + 16) >> 1;
  __int16 v24 = *(_WORD *)(a1 + 16) >> 1;
  if (a3)
  {
    int v10 = 0;
    do
    {
      v22[v10] = *(_DWORD *)(a5 + 4 * v10);
      ++v10;
    }
    while (a3 > v10);
  }
  if (a4)
  {
    int v11 = 0;
    do
    {
      v22[v11 + 17] = *(_DWORD *)(a6 + 4 * v11);
      ++v11;
    }
    while (a4 > v11);
  }
  uint64_t v29 = a1 + 18;
  uint64_t v30 = a1 + 36;
  uint64_t v31 = a1 + 54;
  uint64_t v32 = a1 + 72;
  uint64_t v33 = a1 + 90;
  uint64_t v34 = a1 + 108;
  uint64_t v35 = a1 + 126;
  uint64_t v36 = a1 + 144;
  uint64_t v37 = a1 + 162;
  uint64_t v38 = a1 + 180;
  uint64_t v39 = a1 + 198;
  uint64_t v40 = a1 + 216;
  uint64_t v41 = a1 + 234;
  uint64_t v42 = a1 + 252;
  uint64_t v43 = a1 + 270;
  uint64_t v44 = a1 + 288;
  __int16 v15 = v8;
  __int16 v16 = v9;
  int64x2_t v17 = vdupq_n_s64(0x3F847AE147AE147BuLL);
  __int16 v19 = a3;
  __int16 v20 = a4;
  int32x2_t v12 = vadd_s32((int32x2_t)__PAIR64__(a4, a3), (int32x2_t)-1);
  v13.i64[0] = v12.i32[0];
  v13.i64[1] = v12.i32[1];
  float64x2_t v18 = vdivq_f64((float64x2_t)vdupq_n_s64(0x3FEF5C28F5C28F5CuLL), vcvtq_f64_s64(v13));
  double v21 = ldexp(1.0, __e) * 128.0;
  int v14 = *(_DWORD *)(v29 + 10);
  int v25 = *(_DWORD *)(v29 + 2);
  int v26 = v14;
  __int16 v27 = *(_WORD *)(v29 + 14);
  __int16 v28 = *(_WORD *)(v29 + 16);
  operator new[]();
}

uint64_t sub_10005E6C0(uint64_t result, uint64_t a2, unsigned __int16 *a3, uint64_t a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11)
{
  uint64_t v71 = a3[7];
  if (a3[7])
  {
    uint64_t v72 = 0;
    int v70 = a3[3];
    int v13 = a3[2];
    uint64_t v14 = a4 + 56;
    uint64_t v15 = a4 + 124;
    uint64_t v76 = a2 - 4;
    int v77 = v13;
    int v69 = a3[5];
    int v16 = a3[4];
    uint64_t v17 = a3[6];
    uint64_t v74 = v17;
    int v75 = v16;
    uint64_t v73 = result;
    while (!v17)
    {
LABEL_44:
      if (++v72 == v71) {
        return result;
      }
    }
    uint64_t v18 = 0;
    double v19 = (double)(v69 + v72 * v70);
    uint64_t v20 = *(unsigned __int16 *)(a4 + 40);
    uint64_t v21 = *(unsigned __int16 *)(a4 + 42);
    double v22 = -3.0;
    uint64_t v23 = v72 * v17;
    uint64_t v24 = 2 * v20;
    while (1)
    {
      double v25 = (double)(v16 + v18 * v13);
      if (v20)
      {
        uint64_t v26 = 0;
        LOWORD(v22) = *(_WORD *)a4;
        *(float *)&double v22 = (float)LODWORD(v22);
        while (v25 >= (float)(*(float *)(v14 + 4 * v26) * *(float *)&v22))
        {
          if (v20 == ++v26)
          {
            LOWORD(v26) = v20;
            if (v21) {
              goto LABEL_12;
            }
            goto LABEL_17;
          }
        }
        if (v21) {
          goto LABEL_12;
        }
      }
      else
      {
        LOWORD(v26) = 0;
        if (v21)
        {
LABEL_12:
          uint64_t v27 = 0;
          LOWORD(v22) = *(_WORD *)(a4 + 2);
          *(float *)&double v22 = (float)LODWORD(v22);
          while (v19 >= (float)(*(float *)(v15 + 4 * v27) * *(float *)&v22))
          {
            if (v21 == ++v27)
            {
              unsigned __int16 v28 = v21;
              goto LABEL_19;
            }
          }
          unsigned __int16 v28 = v27;
          goto LABEL_19;
        }
      }
LABEL_17:
      unsigned __int16 v28 = 0;
LABEL_19:
      unsigned int v29 = (unsigned __int16)v26;
      uint64_t v30 = (unsigned __int16)v26 - 1;
      double v31 = (double)(int)v30;
      unsigned int v32 = v28;
      uint64_t v33 = v28 - 1;
      double v34 = (double)(int)v33;
      if (v29 < 2
        || (signed int v35 = v32 - 2, v32 < 2)
        || ((double)v20 + -3.0 >= v31 ? (BOOL v36 = (double)v21 + -3.0 < v34) : (BOOL v36 = 1), v36))
      {
        if (!v29) {
          double v31 = 0.0;
        }
        if (!v32) {
          double v34 = 0.0;
        }
        if (v31 >= (double)((int)v20 - 2)) {
          double v31 = (double)((int)v20 - 2);
        }
        unsigned int v51 = vcvtmd_u64_f64(v31);
        if (v34 >= (double)((int)v21 - 2)) {
          double v52 = (double)((int)v21 - 2);
        }
        else {
          double v52 = v34;
        }
        unsigned int v53 = vcvtmd_u64_f64(v52);
        unsigned int v54 = v51 + v53 * v20;
        LOWORD(v52) = *(_WORD *)(a2 + 2 * v54);
        double v55 = *(double *)(a4 + 48);
        double v56 = (double)*(unint64_t *)&v52 / v55;
        LOWORD(a8) = *(_WORD *)(a2 + 2 * (v54 + 1));
        double v57 = (double)*(unint64_t *)&a8 / v55;
        unsigned int v58 = v51 + (v53 + 1) * v20;
        LOWORD(a9) = *(_WORD *)(a2 + 2 * v58);
        double v59 = (double)*(unint64_t *)&a9 / v55;
        LOWORD(a10) = *(_WORD *)(a2 + 2 * (v58 + 1));
        double v60 = (double)*(unint64_t *)&a10 / v55;
        LOWORD(a11) = *(_WORD *)a4;
        float v61 = (float)LODWORD(a11);
        float v62 = roundf(*(float *)(a4 + 56 + 4 * v51) * v61);
        LOWORD(v11) = *(_WORD *)(a4 + 2);
        float v63 = (float)LODWORD(v11);
        double v64 = roundf(*(float *)(a4 + 124 + 4 * v53) * v63);
        a11 = roundf(*(float *)(a4 + 56 + 4 * (v51 + 1)) * v61);
        double v11 = roundf(*(float *)(a4 + 124 + 4 * (v53 + 1)) * v63);
        a10 = v25 - v62;
        double v65 = a11 - v25;
        double v66 = v59 * v65 + a10 * v60;
        a9 = a10 + v65;
        double v67 = v66 / (a10 + v65);
        double v68 = (v56 * v65 + a10 * v57) / (a10 + v65);
        a8 = v11 - v19;
        double v22 = v19 - v64 + v11 - v19;
        *(double *)(result + 8 * (v23 + v18)) = fmax(fmin(((v11 - v19) * v68 + (v19 - v64) * v67) / v22, 2.0), 0.5);
      }
      else
      {
        uint64_t v37 = 0;
        double v38 = *(double *)(a4 + 48);
        uint64_t v39 = v35;
        uint64_t v40 = (_WORD *)(v76 + 2 * v29 + (int)v24 * (uint64_t)v35);
        uint64_t v41 = v81;
        do
        {
          uint64_t v42 = 0;
          v80[v37] = *(float *)(a4 + 4 * (v37 + (int)(v29 - 2)) + 56);
          double v43 = *(float *)(a4 + 4 * (v37 + v39) + 124);
          v79[v37] = v43;
          uint64_t v44 = v40;
          do
          {
            LOWORD(v43) = *v44;
            double v43 = (double)*(unint64_t *)&v43 / v38;
            v41[v42] = v43;
            uint64_t v44 = (_WORD *)((char *)v44 + v24);
            ++v42;
          }
          while (v42 != 4);
          ++v37;
          ++v40;
          v41 += 4;
        }
        while (v37 != 4);
        LOWORD(v38) = *(_WORD *)a4;
        double v45 = v25 / (double)*(unint64_t *)&v38;
        float v46 = *(float *)(a4 + 56 + 4 * v30);
        double v47 = v45 - v46;
        *(double *)&unint64_t v48 = (float)(*(float *)(a4 + 56 + 4 * v29) - v46);
        double v49 = v47 / *(double *)&v48;
        LOWORD(v48) = *(_WORD *)(a4 + 2);
        sub_10005C230(v81, v80, v79, v49, (v19 / (double)v48 - *(float *)(a4 + 124 + 4 * v33))/ (float)(*(float *)(a4 + 124 + 4 * v32) - *(float *)(a4 + 124 + 4 * v33)));
        double v22 = 2.0;
        if (v50 < 2.0)
        {
          double v22 = 0.5;
          if (v50 > 0.5) {
            double v22 = v50;
          }
        }
        unint64_t result = v73;
        uint64_t v17 = v74;
        *(double *)(v73 + 8 * (v23 + v18)) = v22;
        int v13 = v77;
        int v16 = v75;
      }
      if (++v18 == v17) {
        goto LABEL_44;
      }
    }
  }
  return result;
}

void sub_10005EB2C(uint64_t a1, int a2, unsigned int a3, unsigned int a4, uint64_t a5, uint64_t a6, int a7, int __e)
{
  int v8 = *(unsigned __int16 *)(a1 + 14) >> 1;
  __int16 v23 = *(_WORD *)(a1 + 14) >> 1;
  int v9 = *(unsigned __int16 *)(a1 + 16) >> 1;
  __int16 v24 = *(_WORD *)(a1 + 16) >> 1;
  if (a3)
  {
    int v10 = 0;
    do
    {
      v22[v10] = *(_DWORD *)(a5 + 4 * v10);
      ++v10;
    }
    while (a3 > v10);
  }
  if (a4)
  {
    int v11 = 0;
    do
    {
      v22[v11 + 17] = *(_DWORD *)(a6 + 4 * v11);
      ++v11;
    }
    while (a4 > v11);
  }
  uint64_t v29 = a1 + 18;
  uint64_t v30 = a1 + 36;
  uint64_t v31 = a1 + 54;
  uint64_t v32 = a1 + 72;
  uint64_t v33 = a1 + 90;
  uint64_t v34 = a1 + 108;
  uint64_t v35 = a1 + 126;
  uint64_t v36 = a1 + 144;
  uint64_t v37 = a1 + 162;
  uint64_t v38 = a1 + 180;
  uint64_t v39 = a1 + 198;
  uint64_t v40 = a1 + 216;
  uint64_t v41 = a1 + 234;
  uint64_t v42 = a1 + 252;
  uint64_t v43 = a1 + 270;
  uint64_t v44 = a1 + 288;
  __int16 v15 = v8;
  __int16 v16 = v9;
  int64x2_t v17 = vdupq_n_s64(0x3F847AE147AE147BuLL);
  __int16 v19 = a3;
  __int16 v20 = a4;
  int32x2_t v12 = vadd_s32((int32x2_t)__PAIR64__(a4, a3), (int32x2_t)-1);
  v13.i64[0] = v12.i32[0];
  v13.i64[1] = v12.i32[1];
  float64x2_t v18 = vdivq_f64((float64x2_t)vdupq_n_s64(0x3FEF5C28F5C28F5CuLL), vcvtq_f64_s64(v13));
  double v21 = ldexp(1.0, __e) * 128.0;
  int v14 = *(_DWORD *)(v29 + 10);
  int v25 = *(_DWORD *)(v29 + 2);
  int v26 = v14;
  __int16 v27 = *(_WORD *)(v29 + 14);
  __int16 v28 = *(_WORD *)(v29 + 16);
  operator new[]();
}

void sub_10005EEB8(CFDictionaryRef *a1)
{
  if (*a1) {
    CFDictionaryGetCount(*a1);
  }
  malloc_type_malloc(0x10uLL, 0x20040A4A59CD2uLL);
  operator new();
}

void sub_1000633EC(void ***a1, uint64_t a2, uint64_t a3)
{
  if (a3)
  {
    uint64_t v6 = a1[1];
    unsigned int v7 = v6[1];
    unint64_t v8 = (unint64_t)v6[2];
    if ((unint64_t)v7 >= v8)
    {
      uint64_t v10 = ((char *)v7 - (unsigned char *)*v6) >> 3;
      if ((unint64_t)(v10 + 1) >> 61) {
        sub_100012A24();
      }
      uint64_t v11 = v8 - (void)*v6;
      uint64_t v12 = v11 >> 2;
      if (v11 >> 2 <= (unint64_t)(v10 + 1)) {
        uint64_t v12 = v10 + 1;
      }
      if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v13 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v13 = v12;
      }
      if (v13) {
        int v14 = (char *)sub_100063748((uint64_t)(v6 + 2), v13);
      }
      else {
        int v14 = 0;
      }
      __int16 v15 = &v14[8 * v10];
      __int16 v16 = &v14[8 * v13];
      *(void *)__int16 v15 = a2;
      int v9 = v15 + 8;
      float64x2_t v18 = (char *)*v6;
      int64x2_t v17 = (char *)v6[1];
      if (v17 != *v6)
      {
        do
        {
          uint64_t v19 = *((void *)v17 - 1);
          v17 -= 8;
          *((void *)v15 - 1) = v19;
          v15 -= 8;
        }
        while (v17 != v18);
        int64x2_t v17 = (char *)*v6;
      }
      unsigned __int16 *v6 = v15;
      v6[1] = v9;
      void v6[2] = v16;
      if (v17) {
        operator delete(v17);
      }
    }
    else
    {
      *unsigned int v7 = a2;
      int v9 = v7 + 1;
    }
    v6[1] = v9;
    __int16 v20 = *a1;
    double v21 = v20[1];
    unint64_t v22 = (unint64_t)v20[2];
    if ((unint64_t)v21 >= v22)
    {
      uint64_t v24 = ((char *)v21 - (unsigned char *)*v20) >> 3;
      if ((unint64_t)(v24 + 1) >> 61) {
        sub_100012A24();
      }
      uint64_t v25 = v22 - (void)*v20;
      uint64_t v26 = v25 >> 2;
      if (v25 >> 2 <= (unint64_t)(v24 + 1)) {
        uint64_t v26 = v24 + 1;
      }
      if ((unint64_t)v25 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v27 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v27 = v26;
      }
      if (v27) {
        __int16 v28 = (char *)sub_100063748((uint64_t)(v20 + 2), v27);
      }
      else {
        __int16 v28 = 0;
      }
      uint64_t v29 = &v28[8 * v24];
      uint64_t v30 = &v28[8 * v27];
      *(void *)uint64_t v29 = a3;
      __int16 v23 = v29 + 8;
      uint64_t v32 = (char *)*v20;
      uint64_t v31 = (char *)v20[1];
      if (v31 != *v20)
      {
        do
        {
          uint64_t v33 = *((void *)v31 - 1);
          v31 -= 8;
          *((void *)v29 - 1) = v33;
          v29 -= 8;
        }
        while (v31 != v32);
        uint64_t v31 = (char *)*v20;
      }
      *__int16 v20 = v29;
      v20[1] = v23;
      void v20[2] = v30;
      if (v31) {
        operator delete(v31);
      }
    }
    else
    {
      *double v21 = a3;
      __int16 v23 = v21 + 1;
    }
    v20[1] = v23;
  }
}

void sub_100063590(uint64_t *a1)
{
  if (a1)
  {
    uint64_t v2 = *a1;
    if (*a1)
    {
      unsigned int v3 = *(const void ***)v2;
      uint64_t v4 = *(void *)(v2 + 8) - *(void *)v2;
      if (v4 < 1) {
        goto LABEL_9;
      }
      uint64_t v5 = (unint64_t)v4 >> 3;
      uint64_t v6 = v5 <= 1 ? 1 : v5;
      do
      {
        unsigned int v7 = *v3++;
        CFRelease(v7);
        --v6;
      }
      while (v6);
      uint64_t v2 = *a1;
      if (*a1)
      {
LABEL_9:
        unint64_t v8 = *(const void ***)v2;
        if (*(void *)v2)
        {
          *(void *)(v2 + 8) = v8;
          operator delete(v8);
        }
        operator delete();
      }
      *a1 = 0;
    }
    uint64_t v9 = a1[1];
    if (v9)
    {
      uint64_t v10 = *(void **)v9;
      if (*(void *)v9)
      {
        *(void *)(v9 + 8) = v10;
        operator delete(v10);
      }
      operator delete();
    }
    free(a1);
  }
}

void sub_10006366C(uint64_t a1)
{
  sub_100063828((uint64_t)&v1, a1, 0, -1);
}

void sub_100063734(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void *sub_100063748(uint64_t a1, unint64_t a2)
{
  if (a2 >> 61) {
    sub_100005ED8();
  }
  return operator new(8 * a2);
}

void sub_100063780(void **a1, unint64_t a2)
{
  uint64_t v4 = a1[2];
  uint64_t v3 = (uint64_t)(a1 + 2);
  if (a2 > (v4 - (unsigned char *)*a1) >> 3)
  {
    if (a2 >> 61) {
      sub_100012A24();
    }
    int64_t v5 = (unsigned char *)a1[1] - (unsigned char *)*a1;
    uint64_t v6 = (char *)sub_100063748(v3, a2);
    unsigned int v7 = &v6[v5 & 0xFFFFFFFFFFFFFFF8];
    uint64_t v9 = &v6[8 * v8];
    uint64_t v11 = (char *)*a1;
    uint64_t v10 = (char *)a1[1];
    uint64_t v12 = v7;
    if (v10 != *a1)
    {
      do
      {
        uint64_t v13 = *((void *)v10 - 1);
        v10 -= 8;
        *((void *)v12 - 1) = v13;
        v12 -= 8;
      }
      while (v10 != v11);
      uint64_t v10 = (char *)*a1;
    }
    *a1 = v12;
    a1[1] = v7;
    a1[2] = v9;
    if (v10)
    {
      operator delete(v10);
    }
  }
}

void sub_100063828(uint64_t a1, uint64_t a2, int a3, int a4)
{
  *(void *)a1 = off_100095B38;
  int v4 = *(_DWORD *)(a2 + 20);
  int v5 = *(_DWORD *)(a2 + 16) - a3;
  if (a4 != -1) {
    int v5 = a4;
  }
  uint64_t v6 = *(void *)(a2 + 8) + 4 * (v4 * a3);
  unsigned int v7 = off_100095B38;
  uint64_t v8 = v6;
  int v9 = v5;
  int v10 = v4;
  char v11 = 0;
  *(_DWORD *)(a1 + 16) = v5;
  *(_DWORD *)(a1 + 20) = v4;
  operator new[]();
}

void sub_100063900(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_100063914(uint64_t result, int a2, int a3)
{
  *(void *)unint64_t result = off_100095B38;
  if (a3 * a2) {
    operator new[]();
  }
  *(void *)(result + 8) = 0;
  *(_DWORD *)(result + 16) = a2;
  *(_DWORD *)(result + 20) = a3;
  *(unsigned char *)(result + 24) = 0;
  return result;
}

uint64_t sub_1000639A0(uint64_t a1, char *label, uint64_t a3, uint64_t a4, uint64_t a5, int a6)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = a4;
  *(void *)(a1 + 24) = a5;
  *(void *)(a1 + 32) = a3;
  *(unsigned char *)(a1 + 40) = 1;
  if (!a3)
  {
    if (!os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT)) {
      return a1;
    }
    int v11 = 136315394;
    uint64_t v12 = "ISPTimer";
    __int16 v13 = 1024;
    int v14 = 71;
LABEL_15:
    _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "Assert: ISPTimer %s:%d ", (uint8_t *)&v11, 0x12u);
    return a1;
  }
  if (!a5)
  {
    if (!os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT)) {
      return a1;
    }
    int v11 = 136315394;
    uint64_t v12 = "ISPTimer";
    __int16 v13 = 1024;
    int v14 = 72;
    goto LABEL_15;
  }
  uint64_t v8 = dispatch_queue_create(label, 0);
  *(void *)(a1 + 8) = v8;
  if (!v8)
  {
    if (!os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT)) {
      return a1;
    }
    int v11 = 136315394;
    uint64_t v12 = "ISPTimer";
    __int16 v13 = 1024;
    int v14 = 75;
    goto LABEL_15;
  }
  dispatch_source_t v9 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_timer, 0, 0, v8);
  *(void *)a1 = v9;
  if (!v9)
  {
    if (!os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT)) {
      return a1;
    }
    int v11 = 136315394;
    uint64_t v12 = "ISPTimer";
    __int16 v13 = 1024;
    int v14 = 78;
    goto LABEL_15;
  }
  if (a6)
  {
    *(unsigned char *)(a1 + 40) = 0;
    sub_100063BCC(a1);
  }
  return a1;
}

void sub_100063BCC(uint64_t a1)
{
  uint64_t v2 = *(NSObject **)a1;
  if (v2)
  {
    dispatch_source_set_timer(v2, 0, 1000000 * *(void *)(a1 + 32), 0xF4240uLL);
    uint64_t v3 = *(NSObject **)a1;
    handler[0] = _NSConcreteStackBlock;
    handler[1] = 0x40000000;
    handler[2] = sub_100063D60;
    handler[3] = &unk_10009D7F0;
    handler[4] = a1;
    dispatch_source_set_event_handler(v3, handler);
    dispatch_resume(*(dispatch_object_t *)a1);
  }
  else if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 136315394;
    uint64_t v6 = "Start";
    __int16 v7 = 1024;
    int v8 = 104;
    _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "Assert: ISPTimer %s:%d ", buf, 0x12u);
  }
}

NSObject **sub_100063D10(NSObject **a1)
{
  uint64_t v2 = *a1;
  if (v2)
  {
    dispatch_source_cancel(v2);
    dispatch_release(*a1);
    *a1 = 0;
  }
  uint64_t v3 = a1[1];
  if (v3)
  {
    dispatch_release(v3);
    a1[1] = 0;
  }
  return a1;
}

uint64_t sub_100063D60(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 24))(*(void *)(*(void *)(a1 + 32) + 16));
}

void sub_100063D6C(uint64_t a1, int a2)
{
  uint64_t v3 = *(NSObject **)a1;
  if (v3)
  {
    if (a2)
    {
      if (!*(unsigned char *)(a1 + 40))
      {
        dispatch_suspend(v3);
        *(unsigned char *)(a1 + 40) = 1;
      }
    }
    else if (*(unsigned char *)(a1 + 40))
    {
      dispatch_resume(v3);
      *(unsigned char *)(a1 + 40) = 0;
    }
  }
  else if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
  {
    int v4 = 136315394;
    int v5 = "Pause";
    __int16 v6 = 1024;
    int v7 = 117;
    _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "Assert: ISPTimer %s:%d ", (uint8_t *)&v4, 0x12u);
  }
}

BOOL sub_100063E58(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, _DWORD *a5, double *a6)
{
  bzero(*(void **)(a4 + 8), (*(_DWORD *)(a4 + 20) * *(_DWORD *)(a4 + 16)));
  *a5 = 0;
  int v12 = *(_DWORD *)(a3 + 16);
  int v13 = *(_DWORD *)(a3 + 20);
  unsigned int v14 = v13 * v12;
  if (!(v13 * v12)) {
    sub_100075DE0();
  }
  if (v14 <= 2) {
    sub_100075DE0();
  }
  if (v14 == 3) {
    sub_100075DE0();
  }
  unint64_t v15 = *(unsigned int *)(a1 + 20);
  if (v15)
  {
    unsigned int v16 = 0;
    unint64_t v17 = 0;
    float64x2_t v18 = *(double **)(a3 + 8);
    double v19 = *v18 + v18[2];
    double v20 = v18[1] + v18[3];
    double v21 = 0.0;
    double v22 = 1.0e10;
    double v23 = 0.0;
    double v24 = 1.0e10;
    do
    {
      unsigned int v25 = *(_DWORD *)(a1 + 16);
      if (!v25) {
        sub_1000741C0();
      }
      unsigned int v26 = *(_DWORD *)(a3 + 20) * *(_DWORD *)(a3 + 16);
      if (!v26) {
        sub_100075DE0();
      }
      uint64_t v27 = *(void *)(a1 + 8);
      double v28 = *(double *)(v27 + 8 * v17);
      uint64_t v29 = *(double **)(a3 + 8);
      if (v28 > *v29 && v28 < v19)
      {
        if (v25 <= 1) {
          sub_1000741C0();
        }
        if (v26 <= 1) {
          sub_100075DE0();
        }
        double v31 = *(double *)(v27 + 8 * v15 + 8 * v17);
        if (v31 > v29[1] && v31 < v20)
        {
          if (v17 >= (*(_DWORD *)(a4 + 20) * *(_DWORD *)(a4 + 16))) {
            sub_100075DB4();
          }
          *(unsigned char *)(*(void *)(a4 + 8) + v17) = 1;
          uint64_t v33 = (double *)(*(void *)(a1 + 8) + 8 * v17);
          if (*v33 < v24) {
            double v24 = *v33;
          }
          if (*v33 > v23) {
            double v23 = *v33;
          }
          double v34 = v33[v15];
          if (v34 < v22) {
            double v22 = v33[v15];
          }
          if (v34 > v21) {
            double v21 = v33[v15];
          }
          *a5 = ++v16;
          unint64_t v15 = *(unsigned int *)(a1 + 20);
        }
      }
      ++v17;
    }
    while (v17 < v15);
    int v12 = *(_DWORD *)(a3 + 16);
    int v13 = *(_DWORD *)(a3 + 20);
    double v35 = (v23 - v24) * (v21 - v22);
  }
  else
  {
    unsigned int v16 = 0;
    double v35 = 1.0e20;
  }
  unsigned int v36 = v13 * v12;
  if (v36 <= 2) {
    sub_100075DE0();
  }
  if (v36 == 3) {
    sub_100075DE0();
  }
  double v37 = v35 / (*(double *)(*(void *)(a3 + 8) + 16) * *(double *)(*(void *)(a3 + 8) + 24));
  *a6 = v37;
  return v37 > *(double *)(a2 + 712) && v16 > *(_DWORD *)(a2 + 720);
}

void sub_100064044(uint64_t a1, int a2)
{
}

void sub_100064080(uint64_t a1, int a2)
{
}

void sub_1000656F4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,char a51,uint64_t a52,uint64_t a53,uint64_t a54,char a55,uint64_t a56,uint64_t a57,uint64_t a58,char a59,uint64_t a60,uint64_t a61,uint64_t a62,char a63)
{
  sub_100003224((uint64_t)&a51);
  sub_100003224((uint64_t)&a55);
  sub_100003224((uint64_t)&a59);
  sub_100003224((uint64_t)&a63);
  sub_1000657A4((uint64_t)&a67);
  _Unwind_Resume(a1);
}

uint64_t sub_1000657A4(uint64_t a1)
{
  uint64_t v2 = a1 + 776;
  sub_100003224(a1 + 872);
  sub_100003224(a1 + 840);
  sub_100003224(a1 + 808);
  sub_100003224(v2);
  sub_100003224(a1 + 744);
  sub_100003224(a1 + 256);
  sub_100003224(a1 + 224);
  sub_100003224(a1 + 192);
  sub_100003224(a1 + 160);
  sub_100003224(a1 + 128);
  return a1;
}

uint64_t sub_100065820()
{
  uint64_t v0 = tb_client_connection_message_construct();
  if (!v0)
  {
    tb_message_encode_u64();
    tb_message_encode_u64();
    tb_message_encode_u8();
    tb_message_encode_u32();
    tb_message_encode_u16();
    tb_message_encode_f32();
    tb_message_encode_u8();
    tb_message_complete();
    uint64_t v0 = tb_connection_send_query();
    if ((v0 & 0xFFFFFFF7) == 0) {
      uint64_t v0 = 4;
    }
    tb_client_connection_message_destruct();
  }
  return v0;
}

uint64_t sub_100065988()
{
  uint64_t v0 = tb_client_connection_message_construct();
  if (!v0)
  {
    tb_message_encode_u64();
    tb_message_encode_u64();
    tb_message_encode_u8();
    tb_message_encode_u32();
    tb_message_encode_u16();
    tb_message_encode_f32();
    tb_message_encode_u8();
    tb_message_complete();
    uint64_t v0 = tb_connection_send_query();
    if ((v0 & 0xFFFFFFF7) == 0) {
      uint64_t v0 = 4;
    }
    tb_client_connection_message_destruct();
  }
  return v0;
}

void GridArea::PrepareGrid(_DWORD *a1, float *a2, uint64_t a3, float *a4, int a5)
{
  unsigned int v5 = (float)((float)(a4[1] - *a4) / a4[2]);
  unsigned int v6 = (float)((float)((float)((float)(a2[1] - *a2) / a2[2]) + 1.0) + (float)(2 * a5));
  a1[2] = v6;
  a1[3] = v5;
  a1[4] = v6 * v6;
  a1[5] = v6 * v6 + v6 * v6 * v5;
  operator new[]();
}

void GridArea::~GridArea(GridArea *this)
{
  if (*(void *)this) {
    operator delete[]();
  }
}

uint64_t GridArea::GetMinimalCostEntryIdx(uint64_t this, int a2)
{
  uint64_t v2 = *(unsigned int *)(this + 20);
  if (!v2) {
    return 0;
  }
  uint64_t v3 = (void *)this;
  uint64_t v4 = 0;
  LODWORD(this) = 0;
  uint64_t v5 = *v3 + 16;
  double v6 = 1.79769313e308;
  do
  {
    int v7 = (double *)(v5 + 8);
    if (!a2) {
      int v7 = (double *)v5;
    }
    if (*v7 >= v6) {
      this = this;
    }
    else {
      this = v4;
    }
    if (*v7 < v6) {
      double v6 = *v7;
    }
    ++v4;
    v5 += 32;
  }
  while (v2 != v4);
  return this;
}

uint64_t *GridArea::NormalizeGrid(uint64_t *result, int a2, int a3, _DWORD *a4)
{
  unsigned int v4 = a4[4];
  unsigned int v5 = a4[5];
  if (v4 > v5) {
    return result;
  }
  unsigned int v6 = a4[3];
  double v7 = 2.22507386e-308;
  double v8 = 1.79769313e308;
  unsigned int v9 = a4[4];
  do
  {
    if (a4[2] <= v6)
    {
      uint64_t v10 = *result;
      unsigned int v11 = a4[2];
      double v12 = v8;
      do
      {
        uint64_t v13 = a2 + *((_DWORD *)result + 2) * v9 + v11;
        if (a3)
        {
          if (*(unsigned char *)(v10 + 32 * v13))
          {
            double v8 = *(double *)(v10 + 32 * v13 + 24);
            goto LABEL_10;
          }
        }
        else
        {
          uint64_t v14 = v10 + 32 * v13;
          if (*(unsigned char *)(v14 + 1))
          {
            double v8 = *(double *)(v14 + 16);
LABEL_10:
            if (v8 > v7) {
              double v7 = v8;
            }
            if (v8 < v12) {
              goto LABEL_14;
            }
          }
        }
        double v8 = v12;
LABEL_14:
        ++v11;
        double v12 = v8;
      }
      while (v11 <= v6);
    }
    ++v9;
  }
  while (v9 <= v5);
  double v15 = v7 - v8;
  unsigned int v16 = a4[2];
  unsigned int v17 = a4[3];
  do
  {
    if (v16 <= v17)
    {
      uint64_t v18 = *result;
      int v19 = a2 + *((_DWORD *)result + 2) * v4;
      unsigned int v20 = v16;
      do
      {
        if (a3) {
          uint64_t v21 = 24;
        }
        else {
          uint64_t v21 = 16;
        }
        *(double *)(v18 + 32 * (v19 + v20) + v21) = (*(double *)(v18 + 32 * (v19 + v20) + v21) - v8) / v15;
        ++v20;
      }
      while (v20 <= v17);
    }
    ++v4;
  }
  while (v4 <= v5);
  return result;
}

void GridArea::CalcNewConfidence(uint64_t a1, int a2, int a3, int *a4)
{
  uint64_t v4 = *(unsigned int *)(a1 + 20);
  int v5 = *(_DWORD *)(a1 + 16) * a2;
  if (v4)
  {
    uint64_t v6 = 0;
    unsigned int v7 = 0;
    uint64_t v8 = *(void *)a1 + 16;
    double v9 = 1.79769313e308;
    do
    {
      uint64_t v10 = (double *)(v8 + 8);
      if (!a3) {
        uint64_t v10 = (double *)v8;
      }
      if (*v10 < v9)
      {
        unsigned int v7 = v6;
        double v9 = *v10;
      }
      ++v6;
      v8 += 32;
    }
    while (v4 != v6);
  }
  else
  {
    unsigned int v7 = 0;
  }
  unsigned int v11 = *(_DWORD *)(a1 + 8);
  int v12 = v7 / v11;
  int v13 = v7 % v11;
  *a4 = v13;
  a4[1] = v12;
  unsigned int v14 = v11 - 1;
  int v15 = (v14 >> 1) - 1;
  int v16 = (v13 - v15) & ~((v13 - v15) >> 31);
  unsigned int v17 = v13 + v15;
  if (v17 >= v14) {
    unsigned int v17 = v14;
  }
  a4[2] = v16;
  a4[3] = v17;
  unsigned int v18 = v15 + v12;
  if (v15 + v12 >= v14) {
    unsigned int v18 = v14;
  }
  a4[4] = (v12 - v15) & ~((v12 - v15) >> 31);
  a4[5] = v18;
  GridArea::NormalizeGrid((uint64_t *)a1, v5, a3, a4);
  operator new[]();
}

void GridArea::FitParabolaModel(GridArea *this, double *a2, double *a3)
{
  int v3 = (int)a3;
  sub_1000032CC((uint64_t)v15, (int)a3, 3);
  if (v3)
  {
    unsigned int v6 = 0;
    unint64_t v7 = 0;
    unint64_t v8 = v17;
    unsigned int v9 = v18;
    do
    {
      if (v7 >= v8
        || !v9
        || (*(double *)(v16 + 8 * v6) = a2[v7] * a2[v7], v9 == 1)
        || (*(double *)(v16 + 8 * v6 + 8) = a2[v7], v9 <= 2))
      {
        __assert_rtn("operator()", "Matrix.hpp", 119, "row < m_rows && col < m_cols");
      }
      *(void *)(v16 + 8 * v6 + 16) = 0x3FF0000000000000;
      ++v7;
      v6 += v9;
    }
    while (v3 != v7);
  }
  uint64_t v10 = off_100095A80;
  unsigned int v11 = this;
  int v12 = v3;
  int v13 = 1;
  char v14 = 0;
  sub_100030468((uint64_t)v15);
}

void sub_1000663B0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,char a25)
{
  sub_100003224((uint64_t)&a25);
  sub_100003224((uint64_t)&a9);
  sub_100003224((uint64_t)&a21);
  sub_100003224((uint64_t)&a17);
  sub_100003224((uint64_t)&a13);
  sub_100003224(v25 - 112);
  sub_100003224(v25 - 80);
  _Unwind_Resume(a1);
}

void sub_100066430(uint64_t a1@<X0>, unsigned char *a2@<X1>, uint64_t a3@<X8>)
{
  int v6 = *(_DWORD *)(a1 + 16);
  if (v6 == 2)
  {
    if (*(_DWORD *)(a1 + 20) == 2) {
      goto LABEL_4;
    }
LABEL_8:
    sub_100066A90();
  }
  if (v6 != 3 || *(_DWORD *)(a1 + 20) != 3) {
    goto LABEL_8;
  }
LABEL_4:
  sub_1000032CC(a3, v6, v6);
  double v7 = sub_1000669F8(a1);
  if (v7 == 0.0)
  {
    if (a2) {
      *a2 = 0;
    }
  }
  else
  {
    if (a2) {
      *a2 = 1;
    }
    if (*(_DWORD *)(a1 + 16) == 2)
    {
      **(double **)(a3 + 8) = *(double *)(*(void *)(a1 + 8) + 24) / v7;
      *(double *)(*(void *)(a3 + 8) + 8) = -*(double *)(*(void *)(a1 + 8) + 8) / v7;
      *(double *)(*(void *)(a3 + 8) + 16) = -*(double *)(*(void *)(a1 + 8) + 16) / v7;
      *(double *)(*(void *)(a3 + 8) + 24) = **(double **)(a1 + 8) / v7;
    }
    else
    {
      uint64_t v8 = *(unsigned int *)(a1 + 20);
      if (v8)
      {
        unint64_t v9 = 0;
        unint64_t v10 = *(unsigned int *)(a3 + 16);
        int v11 = 5;
        unsigned int v12 = 1;
        int v13 = 8;
        unsigned int v14 = 2;
        int v15 = 7;
        int v16 = 4;
        do
        {
          unsigned int v17 = 0;
          unint64_t v18 = 0;
          unsigned int v19 = 9 * (v12 / 3);
          unsigned int v20 = 9 * (v14 / 3);
          unint64_t v21 = v9 + 1;
          unint64_t v22 = *(unsigned int *)(a3 + 20);
          unsigned int v23 = v11 - v19;
          unsigned int v24 = v13 - v20;
          unsigned int v25 = v15 - v20;
          unsigned int v26 = v16 - v19;
          unsigned int v27 = 2;
          unsigned int v28 = 1;
          do
          {
            if (v18 >= v10 || v9 >= v22) {
              __assert_rtn("operator()", "Matrix.hpp", 119, "row < m_rows && col < m_cols");
            }
            uint64_t v29 = *(void *)(a1 + 8);
            *(double *)(*(void *)(a3 + 8) + 8 * v9 + 8 * v17) = (*(double *)(v29
                                                                               + 8
                                                                               * (v18 + v26 - 3 * (v28 / 3)))
                                                                   * *(double *)(v29
                                                                               + 8
                                                                               * (v18 + v24 - 3 * (v27 / 3)))
                                                                   - *(double *)(v29
                                                                               + 8
                                                                               * (v18 + v23 - 3 * (v27 / 3)))
                                                                   * *(double *)(v29
                                                                               + 8
                                                                               * (v18 + v25 - 3 * (v28 / 3))))
                                                                  / v7;
            v17 += v22;
            ++v27;
            ++v28;
            ++v18;
          }
          while (v8 != v18);
          v11 += 3;
          ++v12;
          v13 += 3;
          ++v14;
          v15 += 3;
          v16 += 3;
          ++v9;
        }
        while (v21 != v8);
      }
    }
  }
}

void sub_100066690(_Unwind_Exception *a1)
{
  sub_100003224(v1);
  _Unwind_Resume(a1);
}

void GridArea::SaveToDictionary()
{
  if (gDbgLvl) {
    operator new[]();
  }
}

void sub_100066908(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if (v21 < 0) {
    operator delete(v20);
  }
  if (a20 < 0) {
    operator delete(a15);
  }
  _Unwind_Resume(exception_object);
}

BOOL GridArea::isMinimumOnBorder(float *a1, int a2, void *a3)
{
  uint64_t v3 = *(void *)a1;
  uint64_t v4 = *((unsigned int *)a1 + 5);
  if (v4)
  {
    uint64_t v5 = 0;
    LODWORD(v6) = 0;
    double v7 = (double *)(v3 + 16);
    double v8 = 1.79769313e308;
    do
    {
      unint64_t v9 = v7 + 1;
      if (!a2) {
        unint64_t v9 = v7;
      }
      if (*v9 >= v8) {
        uint64_t v6 = v6;
      }
      else {
        uint64_t v6 = v5;
      }
      if (*v9 < v8) {
        double v8 = *v9;
      }
      ++v5;
      v7 += 4;
    }
    while (v4 != v5);
  }
  else
  {
    uint64_t v6 = 0;
  }
  uint64_t v10 = v3 + 32 * v6;
  *a3 = v10;
  float v11 = *(float *)(v10 + 4);
  BOOL result = 1;
  if (v11 != a1[6] && v11 != a1[7])
  {
    float v12 = *(float *)(v3 + 32 * v6 + 8);
    if (v12 != a1[8] && v12 != a1[9]) {
      return 0;
    }
  }
  return result;
}

double sub_1000669F8(uint64_t a1)
{
  int v1 = *(_DWORD *)(a1 + 16);
  if (v1 != 2)
  {
    if (v1 == 3 && *(_DWORD *)(a1 + 20) == 3)
    {
      uint64_t v2 = *(double **)(a1 + 8);
      return *v2 * (v2[4] * v2[8] - v2[5] * v2[7])
           - v2[1] * (v2[3] * v2[8] - v2[5] * v2[6])
           + v2[2] * (v2[3] * v2[7] - v2[4] * v2[6]);
    }
LABEL_8:
    sub_100066ABC();
  }
  if (*(_DWORD *)(a1 + 20) != 2) {
    goto LABEL_8;
  }
  return **(double **)(a1 + 8) * *(double *)(*(void *)(a1 + 8) + 24)
       - *(double *)(*(void *)(a1 + 8) + 8) * *(double *)(*(void *)(a1 + 8) + 16);
}

void sub_100066A90()
{
  __assert_rtn("Inverse", "Matrix.hpp", 1209, "(m_rows == 3 && m_cols == 3) || (m_rows == 2 && m_cols == 2)");
}

void sub_100066ABC()
{
  __assert_rtn("Det", "Matrix.hpp", 1196, "(m_rows == 3 && m_cols == 3) || (m_rows == 2 && m_cols == 2)");
}

void MetalMgt::MetalMgt(MetalMgt *this)
{
  *((void *)this + 3) = 850045863;
  *(void *)this = 0;
  *((void *)this + 1) = 0;
  *((void *)this + 2) = 0;
  *((void *)this + 13) = 0;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *((_OWORD *)this + 4) = 0u;
  *((_OWORD *)this + 5) = 0u;
  id v2 = MTLCreateSystemDefaultDevice();
  uint64_t v3 = *(void **)this;
  *(void *)this = v2;

  id v4 = [*(id *)this newCommandQueue];
  uint64_t v5 = (void *)*((void *)this + 1);
  *((void *)this + 1) = v4;

  id v6 = [*(id *)this newDefaultLibrary];
  double v7 = (void *)*((void *)this + 2);
  *((void *)this + 2) = v6;

  *((void *)this + 12) = 0;
  double v8 = +[NSURL fileURLWithPath:@"/System/Library/PrivateFrameworks/H16ISPServices.framework/CalibrateRgbIr.metallib"];
  unint64_t v9 = *(void **)this;
  id v21 = 0;
  id v10 = [v9 newLibraryWithURL:v8 error:&v21];
  id v11 = v21;
  float v12 = (void *)*((void *)this + 2);
  *((void *)this + 2) = v10;

  id v13 = [*((id *)this + 2) newFunctionWithName:@"Algo_DistortRadialLiteInternal"];
  unsigned int v14 = (void *)*((void *)this + 11);
  *((void *)this + 11) = v13;

  uint64_t v15 = *((void *)this + 11);
  if (!v15) {
    __assert_rtn("MetalMgt", "MetalObjects.mm", 42, "m_algo_DistortRadialLiteInternal_func != 0");
  }
  int v16 = *(void **)this;
  id v20 = 0;
  id v17 = [v16 newComputePipelineStateWithFunction:v15 error:&v20];
  id v18 = v20;
  unsigned int v19 = (void *)*((void *)this + 13);
  *((void *)this + 13) = v17;
}

void sub_100066C58(_Unwind_Exception *a1)
{
  std::mutex::~mutex(v2);
  _Unwind_Resume(a1);
}

uint64_t MetalObjects::init(MetalObjects *this)
{
  *(void *)this = objc_opt_new();

  return _objc_release_x1();
}

void MetalObjects::createTextureMedian(void *a1, void *a2, int *a3, int a4, int a5, int a6, int a7)
{
  [(id)*a1 setTextureType:2];
  [(id)*a1 setHeight:a4];
  [(id)*a1 setWidth:a5];
  if (a7)
  {
    id v17 = 0;
    MetalObjects::createBuffer((uint64_t)a1, &v17, a4, a6);
    id v15 = v17;
    [(id)*a1 setPixelFormat:10];
    [(id)*a1 setUsage:3];
    id v14 = [v15 newTextureWithDescriptor:*a1 offset:0 bytesPerRow:a6];
  }
  else
  {
    id v16 = 0;
    MetalObjects::createBuffer((uint64_t)a1, &v16, a3, a6 * a4);
    id v15 = v16;
    [(id)*a1 setPixelFormat:10];
    [(id)*a1 setUsage:1];
    [(id)*a1 setResourceOptions:*(void *)(a1[2] + 96)];
    id v14 = [v15 newTextureWithDescriptor:*a1 offset:0 bytesPerRow:a6];
  }
  *a2 = v14;
}

void sub_100066E4C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void MetalObjects::createBuffer(uint64_t a1, void *a2, int a3, int a4)
{
  std::mutex::lock((std::mutex *)(*(void *)(a1 + 16) + 24));
  *a2 = [**(id **)(a1 + 16) newBufferWithLength:4 * a4 * a3 options:*(void *)(*(void *)(a1 + 16) + 96)];
  double v8 = (std::mutex *)(*(void *)(a1 + 16) + 24);

  std::mutex::unlock(v8);
}

void MetalObjects::createBuffer(uint64_t a1, void *a2, int *a3, unint64_t a4)
{
  std::mutex::lock((std::mutex *)(*(void *)(a1 + 16) + 24));
  uint64_t v8 = *(void *)(a1 + 16);
  unint64_t v9 = *(void **)v8;
  if (a4 < 0x14)
  {
    id v10 = [v9 newBufferWithLength:20 options:*(void *)(v8 + 96)];
    *a2 = v10;
    id v11 = [v10 contents];
    if (a4 >= 4)
    {
      unint64_t v12 = a4 >> 2;
      do
      {
        int v13 = *a3++;
        *v11++ = v13;
        --v12;
      }
      while (v12);
    }
  }
  else
  {
    *a2 = [v9 newBufferWithBytes:a3 length:a4 options:*(void *)(v8 + 96)];
  }
  id v14 = (std::mutex *)(*(void *)(a1 + 16) + 24);

  std::mutex::unlock(v14);
}

void MetalObjects::createTexture(id *a1, void *a2, int *a3, int a4, int a5)
{
  id v15 = 0;
  MetalObjects::createBuffer((uint64_t)a1, &v15, a3, 4 * a5 * a4);
  id v10 = v15;
  [*a1 setPixelFormat:55];
  [*a1 setTextureType:2];
  [*a1 setHeight:a4];
  [*a1 setWidth:a5];
  if (*a1 && [*a1 width] && (id v11 = objc_msgSend(*a1, "height"), a3) && v11)
  {
    *a2 = [v10 newTextureWithDescriptor:*a1 offset:0 bytesPerRow:4 * a5];
  }
  else
  {
    unint64_t v12 = off_1002BBCE8;
    if (off_1002BBCE8 == &_os_log_default)
    {
      os_log_t v13 = os_log_create("com.apple.isp", "general");
      id v14 = off_1002BBCE8;
      off_1002BBCE8 = v13;

      unint64_t v12 = off_1002BBCE8;
    }
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 136315906;
      id v17 = "createTexture";
      __int16 v18 = 1024;
      int v19 = a4;
      __int16 v20 = 1024;
      int v21 = a5;
      __int16 v22 = 2048;
      unsigned int v23 = a3;
      _os_log_error_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, "RGB-IR: %s: rdar://112006283 Aborting texture creation rows: %d, cols: %d, buffer: %p\n", buf, 0x22u);
    }
  }
}

void sub_10006715C(_Unwind_Exception *exception_object)
{
}

void MetalObjects::Algo_DistortRadialLiteInternal(uint64_t a1, void *a2, void *a3, void *a4, void *a5, void *a6, void *a7, void *a8, void *a9, void *a10, void *a11, void *a12, void *a13, void *a14, char a15)
{
  id v30 = a2;
  id v29 = a3;
  id v38 = a4;
  id v36 = a5;
  id v35 = a6;
  id v34 = a7;
  id v33 = a8;
  id v37 = a9;
  id v32 = a10;
  id v31 = a11;
  id v22 = a12;
  id v23 = a13;
  id v24 = a14;
  std::mutex::lock((std::mutex *)(*(void *)(a1 + 16) + 24));
  unsigned int v25 = [*(id *)(*(void *)(a1 + 16) + 8) commandBuffer];
  std::mutex::unlock((std::mutex *)(*(void *)(a1 + 16) + 24));
  unsigned int v26 = [v25 computeCommandEncoder];
  [v26 setComputePipelineState:*(void *)(*(void *)(a1 + 16) + 104)];
  [v26 setTexture:v30 atIndex:0];
  [v26 setTexture:v29 atIndex:1];
  [v26 setTexture:v38 atIndex:2];
  [v26 setTexture:v37 atIndex:3];
  [v26 setTexture:v24 atIndex:4];
  [v26 setBuffer:v36 offset:0 atIndex:0];
  [v26 setBuffer:v35 offset:0 atIndex:1];
  [v26 setBuffer:v34 offset:0 atIndex:2];
  [v26 setBuffer:v33 offset:0 atIndex:3];
  [v26 setBuffer:v32 offset:0 atIndex:4];
  [v26 setBuffer:v31 offset:0 atIndex:5];
  [v26 setBuffer:v22 offset:0 atIndex:6];
  [v26 setBuffer:v23 offset:0 atIndex:7];
  unint64_t v27 = (unint64_t)[*(id *)(*(void *)(a1 + 16) + 104) threadExecutionWidth];
  unint64_t v28 = (unint64_t)[*(id *)(*(void *)(a1 + 16) + 104) maxTotalThreadsPerThreadgroup];
  v40[0] = ((unint64_t)[v30 width] + v27 - 1) / v27;
  v40[1] = ((unint64_t)[v30 height] + v28 / v27 - 1) / (v28 / v27);
  void v40[2] = 1;
  v39[0] = v27;
  v39[1] = v28 / v27;
  v39[2] = 1;
  [v26 dispatchThreadgroups:v40 threadsPerThreadgroup:v39];
  [v26 endEncoding];
  [v25 commit];
  if (a15) {
    [v25 waitUntilCompleted];
  }
}

void sub_100067498(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, void *a13, void *a14, void *a15, void *a16, void *a17, void *a18, void *a19, void *a20,void *a21)
{
  _Unwind_Resume(a1);
}

void MetalObjects::medianFilter(uint64_t a1, void *a2, void *a3, unsigned int a4, int a5)
{
  id v12 = a2;
  id v9 = a3;
  std::mutex::lock((std::mutex *)(*(void *)(a1 + 16) + 24));
  id v10 = [objc_alloc((Class)MPSImageMedian) initWithDevice:**(void **)(a1 + 16) kernelDiameter:a4];
  id v11 = [*(id *)(*(void *)(a1 + 16) + 8) commandBuffer];
  std::mutex::unlock((std::mutex *)(*(void *)(a1 + 16) + 24));
  [v10 encodeToCommandBuffer:v11 sourceTexture:v12 destinationTexture:v9];
  [v11 commit];
  if (a5) {
    [v11 waitUntilCompleted];
  }
}

void sub_100067610(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void RgbIrCalibration::RgbIrCalibration(RgbIrCalibration *this, int a2)
{
  *(_WORD *)this = 0;
  gDbgLvl = a2;
  operator new();
}

void sub_10006769C()
{
}

void RgbIrCalibration::~RgbIrCalibration(RgbIrCalibration *this)
{
  if (*(unsigned char *)this)
  {
    *((unsigned char *)this + 1) = 1;
    CalibrateRgbIr::abort(*((void *)this + 1));
  }
  else
  {
    uint64_t v1 = *((void *)this + 1);
    if (v1)
    {
      sub_100067AF4(v1);
      operator delete();
    }
  }
}

uint64_t RgbIrCalibration::abort(RgbIrCalibration *this)
{
  *((unsigned char *)this + 1) = 1;
  return CalibrateRgbIr::abort(*((void *)this + 1));
}

uint64_t RgbIrCalibration::Calibrate(uint64_t a1, int a2, const __CFDictionary *a3, int a4, int a5, int a6, unsigned int a7, const __CFBoolean *a8, double *a9, const __CFArray *a10, __int16 a11, uint64_t a12, unsigned int *a13, uint64_t a14, uint64_t a15, uint64_t a16)
{
  *(unsigned char *)a1 = 1;
  uint64_t v20 = CalibrateRgbIr::Calibrate(*(void *)(a1 + 8), a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a14, a15);
  *(unsigned char *)a1 = 0;
  if (*(unsigned char *)(a1 + 1))
  {
    uint64_t v21 = 4102;
    id v22 = context;
  }
  else
  {
    uint64_t v21 = v20;
    uint64_t v23 = *(void *)(a1 + 8);
    *(void *)a16 = *(void *)(v23 + 984);
    *(_DWORD *)(a16 + 8) = *(_DWORD *)(v23 + 992);
    *(_DWORD *)(a16 + 12) = *(_DWORD *)(v23 + 996);
    *(_DWORD *)(a16 + 16) = *(_DWORD *)(v23 + 1000);
    unsigned int v24 = *(_DWORD *)(v23 + 1004);
    *a13 = v24;
    id v22 = context;
    if (v24 <= 2) {
      *(_DWORD *)(a16 + 20) = v24;
    }
  }
  return v21;
}

uint64_t RgbIrCalibration::GetDebugInfo(RgbIrCalibration *this)
{
  return *(void *)(*((void *)this + 1) + 1008);
}

uint64_t sub_100067860(uint64_t a1)
{
  *(_DWORD *)(a1 + 24) = 0;
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 40) = 0;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_OWORD *)(a1 + 88) = 0u;
  *(_OWORD *)(a1 + 104) = 0u;
  *(_OWORD *)(a1 + 120) = 0u;
  *(_OWORD *)(a1 + 136) = 0u;
  *(_OWORD *)(a1 + 152) = 0u;
  *(void *)(a1 + 168) = 0;
  *(_OWORD *)(a1 + 200) = 0u;
  *(_OWORD *)(a1 + 216) = 0u;
  *(_DWORD *)(a1 + 256) = 0;
  *(void *)(a1 + 264) = 0;
  *(void *)(a1 + 272) = 0;
  *(_OWORD *)(a1 + 288) = 0u;
  *(_OWORD *)(a1 + 304) = 0u;
  *(_OWORD *)(a1 + 320) = 0u;
  *(_OWORD *)(a1 + 336) = 0u;
  *(_OWORD *)(a1 + 352) = 0u;
  *(_OWORD *)(a1 + 368) = 0u;
  *(_OWORD *)(a1 + 384) = 0u;
  *(void *)(a1 + 400) = 0;
  *(_DWORD *)(a1 + 488) = 0;
  *(unsigned char *)(a1 + 492) = 0;
  *(_OWORD *)(a1 + 432) = 0u;
  *(_OWORD *)(a1 + 448) = 0u;
  *(unsigned char *)(a1 + 464) = 0;
  MetalMgt::MetalMgt((MetalMgt *)(a1 + 496));
  for (uint64_t i = 0; i != 144; i += 24)
    sub_100067AAC((MetalObjects *)(a1 + i + 608));
  *(_OWORD *)(a1 + 912) = 0u;
  *(_OWORD *)(a1 + 928) = 0u;
  *(_OWORD *)(a1 + 896) = 0u;
  *(_OWORD *)(a1 + 752) = 0u;
  *(_OWORD *)(a1 + 768) = 0u;
  *(_OWORD *)(a1 + 960) = 0u;
  *(unsigned char *)(a1 + 976) = 0;
  *(void *)(a1 + 984) = 0x7FF8000000000000;
  *(_OWORD *)(a1 + 992) = 0u;
  CalibrateRgbIr::Init((CalibrateRgbIr *)a1);
  return a1;
}

void sub_100067948(_Unwind_Exception *a1)
{
  sub_100067A04(v3);
  uint64_t v5 = 0;
  id v6 = v2 + 91;
  do
  {
    sub_1000679D0(&v6[v5]);
    v5 -= 3;
  }
  while (v5 != -18);
  sub_100067A58(v1);
  _Unwind_Resume(a1);
}

id *sub_1000679D0(id *a1)
{
  return a1;
}

id *sub_100067A04(id *a1)
{
  return a1;
}

uint64_t sub_100067A58(uint64_t a1)
{
  std::mutex::~mutex((std::mutex *)(a1 + 24));
  return a1;
}

MetalObjects *sub_100067AAC(MetalObjects *a1)
{
  *(void *)a1 = 0;
  *((void *)a1 + 1) = 0;
  MetalObjects::init(a1);
  return a1;
}

void sub_100067AD8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t sub_100067AF4(uint64_t a1)
{
  if (gDbgLvl) {
    CFRelease(*(CFTypeRef *)(a1 + 1008));
  }

  for (uint64_t i = 0; i != -144; i -= 24)
  {
  }
  std::mutex::~mutex((std::mutex *)(a1 + 520));

  return a1;
}

void sub_100067BF0()
{
  __cxa_atexit((void (*)(void *))&std::string::~string, &gOutputDirName, (void *)&_mh_execute_header);
  __cxa_atexit((void (*)(void *))&std::string::~string, &gCurrFrameId, (void *)&_mh_execute_header);
}

void *GrayScaleImage::save(int a1, CVPixelBufferRef pixelBuffer)
{
  size_t PlaneCount = CVPixelBufferGetPlaneCount(pixelBuffer);
  PixelFormatCFNumberType Type = CVPixelBufferGetPixelFormatType(pixelBuffer);
  if (PlaneCount)
  {
    CVPixelBufferGetWidthOfPlane(pixelBuffer, 0);
    CVPixelBufferGetHeightOfPlane(pixelBuffer, 0);
    if (PixelFormatType == 2037741158)
    {
      CVPixelBufferGetBytesPerRowOfPlane(pixelBuffer, 0);
LABEL_8:
      CVPixelBufferLockBaseAddress(pixelBuffer, 1uLL);
      CVPixelBufferGetBaseAddress(pixelBuffer);
      return (void *)CVPixelBufferUnlockBaseAddress(pixelBuffer, 1uLL);
    }
  }
  else
  {
    CVPixelBufferGetWidth(pixelBuffer);
    CVPixelBufferGetHeight(pixelBuffer);
    if (PixelFormatType == 825306677 || PixelFormatType == 1278226742 || PixelFormatType == 825437747)
    {
      CVPixelBufferGetBytesPerRow(pixelBuffer);
      goto LABEL_8;
    }
  }
  sub_10003BB70(&std::cout, (uint64_t)"Unsupported CVPixelBuffer pixel format: ", 40);
  id v6 = (void *)std::ostream::operator<<();

  return sub_10003BB70(v6, (uint64_t)" (see CVPixelBufferPrivate.h). Please contact PortableBuffer support.\n", 70);
}

void sub_100067DAC()
{
  __cxa_atexit((void (*)(void *))&std::string::~string, &PortableBuffer::m_outputDir, (void *)&_mh_execute_header);
}

uint64_t CalibrateRgbIr::Init(CalibrateRgbIr *this)
{
  if (gDbgLvl) {
    *((void *)this + 126) = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  }
  long long v2 = *((_OWORD *)this + 1);
  v37[0] = *(_OWORD *)this;
  v37[1] = v2;
  void v37[2] = *((_OWORD *)this + 2);
  uint64_t v3 = *((void *)this + 6);
  long long v39 = *(_OWORD *)((char *)this + 56);
  uint64_t v4 = *((void *)this + 9);
  uint64_t v38 = v3;
  uint64_t v40 = v4;
  long long v41 = *((_OWORD *)this + 5);
  uint64_t v5 = *((void *)this + 12);
  long long v43 = *(_OWORD *)((char *)this + 104);
  long long v6 = *(_OWORD *)((char *)this + 120);
  long long v7 = *(_OWORD *)((char *)this + 136);
  long long v8 = *(_OWORD *)((char *)this + 152);
  uint64_t v9 = *((void *)this + 21);
  uint64_t v42 = v5;
  uint64_t v47 = v9;
  long long v46 = v8;
  long long v45 = v7;
  long long v44 = v6;
  long long v10 = *((_OWORD *)this + 11);
  long long v11 = *((_OWORD *)this + 12);
  long long v12 = *((_OWORD *)this + 13);
  uint64_t v51 = *((void *)this + 28);
  long long v49 = v11;
  long long v50 = v12;
  long long v48 = v10;
  InitCamParams((uint64_t)v37);
  long long v13 = *(_OWORD *)((char *)this + 248);
  v22[0] = *(_OWORD *)((char *)this + 232);
  v22[1] = v13;
  v22[2] = *(_OWORD *)((char *)this + 264);
  uint64_t v23 = *((void *)this + 35);
  long long v24 = *((_OWORD *)this + 18);
  uint64_t v25 = *((void *)this + 38);
  long long v26 = *(_OWORD *)((char *)this + 312);
  uint64_t v27 = *((void *)this + 41);
  long long v14 = *((_OWORD *)this + 22);
  long long v28 = *((_OWORD *)this + 21);
  long long v15 = *((_OWORD *)this + 23);
  long long v16 = *((_OWORD *)this + 24);
  uint64_t v32 = *((void *)this + 50);
  long long v31 = v16;
  long long v30 = v15;
  long long v29 = v14;
  long long v17 = *(_OWORD *)((char *)this + 408);
  long long v18 = *(_OWORD *)((char *)this + 424);
  long long v19 = *(_OWORD *)((char *)this + 440);
  uint64_t v36 = *((void *)this + 57);
  long long v34 = v18;
  long long v35 = v19;
  long long v33 = v17;
  uint64_t result = InitCamParams((uint64_t)v22);
  for (uint64_t i = 0; i != 144; i += 24)
    *(void *)((char *)this + i + 624) = (char *)this + 496;
  return result;
}

void CalibrateRgbIr::CalcMutualInfoSamples()
{
  uint64_t v0 = off_100095B38;
  operator new[]();
}

void sub_100068248(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va1, a5);
  va_start(va, a5);
  uint64_t v6 = va_arg(va1, void);
  uint64_t v8 = va_arg(va1, void);
  uint64_t v9 = va_arg(va1, void);
  uint64_t v10 = va_arg(va1, void);
  sub_1000046EC((uint64_t)va);
  sub_1000046EC((uint64_t)va1);
  _Unwind_Resume(a1);
}

uint64_t OneDimensionHorizontalFilterWithPadding(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_DWORD *)(a2 + 16) != 1) {
    sub_10006EF54();
  }
  unint64_t v4 = *(unsigned int *)(a2 + 20);
  if ((v4 & 1) == 0) {
    sub_10006EF28();
  }
  uint64_t result = sub_1000045A0(a1, a2, a3);
  int v8 = *(_DWORD *)(a1 + 16);
  if (v8)
  {
    unsigned int v9 = 0;
    unint64_t v10 = v4 >> 1;
    do
    {
      if (v4 >= 2)
      {
        uint64_t v11 = 0;
        unint64_t v12 = 0;
        uint64_t v13 = *(unsigned int *)(a1 + 20);
        int v14 = *(_DWORD *)(a2 + 16);
        uint64_t v15 = *(int *)(a2 + 20);
        uint64_t result = *(unsigned int *)(a3 + 16);
        unsigned int v16 = v13 - 1;
        unsigned int v17 = ~(v4 >> 1) + v4;
        unint64_t v18 = v4 >> 1;
        do
        {
          if (result <= v9 || (unint64_t v19 = *(unsigned int *)(a3 + 20), v12 >= v19)) {
            sub_100073870();
          }
          unsigned int v20 = v13 + ~v12;
          if (v19 <= v20) {
            sub_100073870();
          }
          if (v12 == v13) {
            sub_100073870();
          }
          if (v13 <= v20) {
            sub_100073870();
          }
          uint64_t v21 = *(void *)(a3 + 8);
          uint64_t v22 = v21 + 4 * v12;
          uint64_t v23 = v19 * v9;
          uint64_t v24 = v21 + 4 * v20;
          uint64_t v25 = *(void *)(a1 + 8);
          *(_DWORD *)(v22 + 4 * v23) = 0;
          *(_DWORD *)(v24 + 4 * v23) = 0;
          if ((uint64_t)v12 > (uint64_t)(v10 - v15))
          {
            if (v14)
            {
              uint64_t v26 = 0;
              uint64_t v27 = v11 + 4 * v16;
              uint64_t v28 = v25 + 4 * v13 * v9;
              unsigned int v29 = v17;
              while (v15 > (int)v18 + (int)v26)
              {
                *(float *)(v22 + 4 * v23) = *(float *)(v22 + 4 * v23)
                                          + (float)(*(float *)(v28 + 4 * v26)
                                                  * *(float *)(*(void *)(a2 + 8) + 4 * v18 + 4 * v26));
                if (v15 <= v29) {
                  sub_100073870();
                }
                *(float *)(v24 + 4 * v23) = *(float *)(v24 + 4 * v23)
                                          + (float)(*(float *)(v28 + v27) * *(float *)(*(void *)(a2 + 8) + 4 * v29));
                v27 -= 4;
                ++v26;
                --v29;
                if ((uint64_t)(v18 + v26) >= v15) {
                  goto LABEL_18;
                }
              }
            }
            sub_100073870();
          }
LABEL_18:
          ++v12;
          --v18;
          v11 += 4;
          --v16;
          ++v17;
        }
        while (v12 != v10);
      }
      ++v9;
    }
    while (v9 != v8);
  }
  return result;
}

void OneDimensionVerticalFilterWithPadding(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 16) == 1)
  {
    if (*(_DWORD *)(a2 + 20)) {
      sub_10006366C(a2);
    }
    sub_10006EF80();
  }
  sub_10006EFAC();
}

void sub_10006864C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t CalibrateRgbIr::SampleWorldPointsOnCam(uint64_t a1, int *a2, void *a3, uint64_t a4)
{
  id v13 = 0;
  MetalObjects::createBuffer(a4, &v13, (int *)(a1 + 784), 0x6CuLL);
  id v8 = v13;
  id v12 = 0;
  MetalObjects::createBuffer(a4, &v12, a2, 0x6CuLL);
  id v9 = v12;
  id v10 = *(id *)(a4 + 8);
  *a3 = v10;
  MetalObjects::Algo_DistortRadialLiteInternal(a4, *(void **)(a1 + 752), *(void **)(a1 + 760), *(void **)(a1 + 768), *(void **)(a1 + 920), *(void **)(a1 + 912), *(void **)(a1 + 904), *(void **)(a1 + 896), *(void **)(a1 + 776), *(void **)(a1 + 928), v8, v9, *(void **)(a1 + 936), v10, 1);

  return 0;
}

void sub_10006874C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void CalibrateRgbIr::CostFmi(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  long long v8 = *(_OWORD *)(a1 + 16);
  float64x2_t v33 = *(float64x2_t *)a1;
  long long v34 = v8;
  long long v35 = *(_OWORD *)(a1 + 32);
  uint64_t v9 = *(void *)(a1 + 48);
  *(_OWORD *)&unsigned int v36[8] = *(_OWORD *)(a1 + 56);
  uint64_t v10 = *(void *)(a1 + 72);
  *(void *)uint64_t v36 = v9;
  *(void *)&v36[24] = v10;
  float64x2_t v37 = *(float64x2_t *)(a1 + 80);
  double v11 = *(double *)(a1 + 96);
  *(_OWORD *)&unsigned char v38[8] = *(_OWORD *)(a1 + 104);
  long long v12 = *(_OWORD *)(a1 + 120);
  long long v13 = *(_OWORD *)(a1 + 136);
  long long v14 = *(_OWORD *)(a1 + 152);
  uint64_t v15 = *(void *)(a1 + 168);
  *(double *)uint64_t v38 = v11;
  *(void *)&v38[72] = v15;
  *(_OWORD *)&v38[56] = v14;
  *(_OWORD *)&v38[40] = v13;
  *(_OWORD *)&v38[24] = v12;
  long long v16 = *(_OWORD *)(a1 + 192);
  v39[0] = *(_OWORD *)(a1 + 176);
  v39[1] = v16;
  v39[2] = *(_OWORD *)(a1 + 208);
  uint64_t v40 = *(void *)(a1 + 224);
  float64x2_t v37 = vaddq_f64(v37, vcvtq_f64_f32(*(float32x2_t *)(a2 + 4)));
  *(double *)uint64_t v38 = v11 + *(float *)(a2 + 12);
  sub_100005308(v37.f64, (uint64_t)&v38[8]);
  float32x2_t v22 = vcvt_f32_f64(v33);
  float v17 = *(double *)&v34;
  float v23 = v17;
  int v24 = DWORD2(v34);
  float32x4_t v25 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(*(float64x2_t *)v36), *(float64x2_t *)&v36[16]);
  float32x4_t v26 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v37), *(float64x2_t *)v38);
  float32x4_t v27 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(*(float64x2_t *)&v38[16]), *(float64x2_t *)&v38[32]);
  float32x4_t v28 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(*(float64x2_t *)&v38[48]), *(float64x2_t *)&v38[64]);
  float v18 = *(double *)v39;
  float v29 = v18;
  long long v30 = *(_OWORD *)((char *)v39 + 8);
  int v31 = 0;
  int v32 = 0;
  id v21 = 0;
  CalibrateRgbIr::SampleWorldPointsOnCam(a1, (int *)&v22, &v21, a4);
  id v19 = v21;
  [v19 width];
  [v19 height];
  id v20 = [v19 buffer];
  [v20 contents];

  operator new[]();
}

void sub_100068B18(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  sub_1000046EC((uint64_t)va);

  _Unwind_Resume(a1);
}

void CalibrateRgbIr::CalculateGrid(uint64_t a1, uint64_t a2, int a3, int a4)
{
  if (a3 <= a4)
  {
    int v5 = a3;
    unsigned int v6 = *(_DWORD *)(a2 + 8);
    unsigned int v7 = v6;
    do
    {
      if (v7)
      {
        unsigned int v8 = 0;
        do
        {
          if (v6)
          {
            for (unint64_t i = 0; i < v6; ++i)
            {
              if (*(unsigned char *)(a1 + 976)) {
                break;
              }
            }
          }
          ++v8;
          unsigned int v7 = *(_DWORD *)(a2 + 8);
        }
        while (v8 < v6);
      }
    }
    while (v5++ != a4);
  }
  for (uint64_t j = 0; j != 6; ++j)
  {
    long long v12 = [*(id *)(a1 + 968) objectAtIndexedSubscript:j];
    dispatch_group_wait(v12, 0xFFFFFFFFFFFFFFFFLL);
  }
}

void sub_100068D8C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15)
{
  _Unwind_Resume(a1);
}

void sub_100068DA0(uint64_t *a1)
{
}

uint64_t CalibrateRgbIr::PrepareGridCalculation(uint64_t a1, uint64_t a2, uint64_t a3, int a4, int a5)
{
  uint64_t v10 = (id *)(a1 + 608);
  v99[0] = 0;
  MetalObjects::createTexture((id *)(a1 + 608), v99, *(int **)(a2 + 8), a5, a4);
  id v11 = v99[0];
  id v12 = v99[0];
  objc_storeStrong((id *)(a1 + 752), v11);
  id v98 = 0;
  uint64_t v73 = v12;
  MetalObjects::createTexture(v10, &v98, (int *)(*(void *)(a2 + 8) + 4 * *(unsigned int *)(a2 + 20)), a5, a4);
  id v13 = v98;
  id v14 = v98;
  objc_storeStrong((id *)(a1 + 760), v13);
  id v97 = 0;
  MetalObjects::createTexture(v10, &v97, (int *)(*(void *)(a2 + 8) + 4 * (2 * *(_DWORD *)(a2 + 20))), a5, a4);
  id v15 = v97;
  id v16 = v97;
  objc_storeStrong((id *)(a1 + 768), v15);
  if (*(void *)(a1 + 752) && *(void *)(a1 + 760) && a4 && a5 && *(void *)(a1 + 768))
  {
    *(float32x2_t *)(a1 + 784) = vcvt_f32_f64(*(float64x2_t *)(a1 + 232));
    float v17 = *(double *)(a1 + 248);
    *(float *)(a1 + 792) = v17;
    float32x4_t v18 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(*(float64x2_t *)(a1 + 312)), *(float64x2_t *)(a1 + 328));
    *(float32x4_t *)(a1 + 800) = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(*(float64x2_t *)(a1 + 280)), *(float64x2_t *)(a1 + 296));
    *(float32x4_t *)(a1 + 816) = v18;
    float32x4_t v19 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(*(float64x2_t *)(a1 + 344)), *(float64x2_t *)(a1 + 360));
    float32x4_t v20 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(*(float64x2_t *)(a1 + 376)), *(float64x2_t *)(a1 + 392));
    *(_DWORD *)(a1 + 796) = *(_DWORD *)(a1 + 256);
    *(float32x4_t *)(a1 + 832) = v19;
    *(float32x4_t *)(a1 + 848) = v20;
    float v21 = *(double *)(a1 + 408);
    *(float *)(a1 + 864) = v21;
    *(_OWORD *)(a1 + 868) = *(_OWORD *)(a1 + 416);
    *(_DWORD *)(a1 + 884) = a4;
    *(_DWORD *)(a1 + 888) = a5;
    id v96 = 0;
    MetalObjects::createBuffer((uint64_t)v10, &v96, *(int **)(a1 + 272), 4 * *(unsigned int *)(a1 + 256));
    id v22 = v96;
    id v23 = v96;
    id v95 = 0;
    MetalObjects::createBuffer((uint64_t)v10, &v95, *(int **)(a1 + 264), 4 * *(unsigned int *)(a1 + 256));
    int v70 = v23;
    id v24 = v95;
    id v69 = v95;
    objc_storeStrong((id *)(a1 + 912), v22);
    objc_storeStrong((id *)(a1 + 920), v24);
    sub_100063914((uint64_t)v93, 1, *(_DWORD *)(a1 + 420));
    int v25 = *(_DWORD *)(a1 + 420);
    if (v25)
    {
      unint64_t v26 = 0;
      float32x4_t v27 = v94;
      if ((v25 + 1) > 2) {
        int v28 = v25 + 1;
      }
      else {
        int v28 = 2;
      }
      uint64_t v29 = (v28 - 1);
      uint64_t v30 = v28 & 0xFFFFFFFE;
      uint64x2_t v31 = (uint64x2_t)vdupq_n_s64(v29 - 1);
      do
      {
        int32x2_t v32 = vmovn_s64((int64x2_t)vcgeq_u64(v31, (uint64x2_t)vorrq_s8((int8x16_t)vdupq_n_s64(v26), (int8x16_t)xmmword_100082850)));
        if (v32.i8[0]) {
          *(float *)&v27[v26] = (float)(v26 + 1) + -0.5;
        }
        if (v32.i8[4]) {
          *(float *)&v27[v26 + 1] = (float)(v26 + 2) + -0.5;
        }
        v26 += 2;
      }
      while (v30 != v26);
    }
    sub_100063914((uint64_t)v91, 1, *(_DWORD *)(a1 + 416));
    int v33 = *(_DWORD *)(a1 + 416);
    if (v33)
    {
      unint64_t v34 = 0;
      long long v35 = v92;
      if ((v33 + 1) > 2) {
        int v36 = v33 + 1;
      }
      else {
        int v36 = 2;
      }
      uint64_t v37 = (v36 - 1);
      uint64_t v38 = v36 & 0xFFFFFFFE;
      uint64x2_t v39 = (uint64x2_t)vdupq_n_s64(v37 - 1);
      do
      {
        int32x2_t v40 = vmovn_s64((int64x2_t)vcgeq_u64(v39, (uint64x2_t)vorrq_s8((int8x16_t)vdupq_n_s64(v34), (int8x16_t)xmmword_100082850)));
        if (v40.i8[0]) {
          *(float *)&v35[v34] = (float)(v34 + 1) + -0.5;
        }
        if (v40.i8[4]) {
          *(float *)&v35[v34 + 1] = (float)(v34 + 2) + -0.5;
        }
        v34 += 2;
      }
      while (v38 != v34);
    }
    id v90 = 0;
    MetalObjects::createBuffer((uint64_t)v10, &v90, v94, 4 * *(unsigned int *)(a1 + 420));
    id v41 = v90;
    id v72 = v90;
    id v89 = 0;
    MetalObjects::createBuffer((uint64_t)v10, &v89, v92, 4 * *(unsigned int *)(a1 + 416));
    id v42 = v89;
    id v71 = v89;
    objc_storeStrong((id *)(a1 + 904), v42);
    objc_storeStrong((id *)(a1 + 896), v41);
    *(void *)(a1 + 944) = v91;
    *(void *)(a1 + 952) = v93;
    uint64_t v43 = -144;
    do
    {
      obuint64_t j = 0;
      sub_1000694DC((void *)(a1 + v43 + 752), &obj, a5, a4);
      objc_storeStrong((id *)(a1 + v43 + 760), obj);
      v43 += 24;
    }
    while (v43);
    id v44 = objc_alloc_init((Class)NSMutableArray);
    long long v45 = *(void **)(a1 + 960);
    *(void *)(a1 + 960) = v44;

    id v46 = objc_alloc_init((Class)NSMutableArray);
    uint64_t v47 = *(void **)(a1 + 968);
    *(void *)(a1 + 968) = v46;

    long long v48 = dispatch_queue_attr_make_with_qos_class(0, QOS_CLASS_BACKGROUND, 0);
    int v49 = 6;
    do
    {
      long long v50 = *(void **)(a1 + 960);
      dispatch_queue_t v51 = dispatch_queue_create("com.gmcRgbIr.CPU_GPU", v48);
      [v50 addObject:v51];

      double v52 = *(void **)(a1 + 968);
      dispatch_group_t v53 = dispatch_group_create();
      [v52 addObject:v53];

      --v49;
    }
    while (v49);
    int v87 = *(_DWORD *)(a1 + 256);
    unsigned int v54 = *(float **)(a1 + 264);
    float v86 = *v54;
    float v85 = v54[1] - v86;
    id v84 = 0;
    MetalObjects::createBuffer((uint64_t)v10, &v84, (int *)&v85, 0x1CuLL);
    id v55 = v84;
    id v56 = v84;
    int v57 = *(_DWORD *)(a1 + 420);
    int v81 = *(_DWORD *)(a1 + 416);
    int v82 = v57;
    int v83 = 2143289344;
    unsigned int v58 = *(float **)(*(void *)(a1 + 952) + 8);
    float v79 = *v58;
    float v80 = v58[v57 - 1];
    double v59 = *(float **)(*(void *)(a1 + 944) + 8);
    float v77 = *v59;
    float v78 = v59[v81 - 1];
    *(float *)&v76[1] = v77;
    float v60 = v59[1] - v77;
    *(float *)&v76[3] = v79;
    float v61 = v58[1];
    *(float *)uint64_t v76 = v60;
    *(float *)&v76[2] = v61 - v79;
    id v75 = 0;
    MetalObjects::createBuffer((uint64_t)v10, &v75, v76, 0x2CuLL);
    id v62 = v75;
    id v63 = v75;
    objc_storeStrong((id *)(a1 + 928), v55);
    objc_storeStrong((id *)(a1 + 936), v62);
    id v74 = 0;
    MetalObjects::createTexture(v10, &v74, *(int **)(a3 + 8), *(_DWORD *)(a3 + 16), *(_DWORD *)(a3 + 20));
    objc_storeStrong((id *)(a1 + 776), v74);

    sub_1000046EC((uint64_t)v91);
    sub_1000046EC((uint64_t)v93);

    uint64_t v64 = 1;
  }
  else
  {
    double v65 = off_1002BBCF0;
    if (off_1002BBCF0 == &_os_log_default)
    {
      os_log_t v66 = os_log_create("com.apple.isp", "general");
      double v67 = off_1002BBCF0;
      off_1002BBCF0 = v66;

      double v65 = off_1002BBCF0;
    }
    if (os_log_type_enabled(v65, OS_LOG_TYPE_ERROR)) {
      sub_10006EFD8(v65);
    }
    uint64_t v64 = 0;
  }

  return v64;
}

void sub_100069428(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, void *a11, void *a12, void *a13, void *a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,char a31)
{
  sub_1000046EC((uint64_t)&a31);
  sub_1000046EC(v36 - 160);

  _Unwind_Resume(a1);
}

void sub_1000694DC(void *a1, void *a2, int a3, int a4)
{
  std::mutex::lock((std::mutex *)(a1[2] + 24));
  id v8 = [*(id *)a1[2] newBufferWithLength:4 * a4 * a3 options:*(void *)(a1[2] + 96)];
  std::mutex::unlock((std::mutex *)(a1[2] + 24));
  [(id)*a1 setResourceOptions:*(void *)(a1[2] + 96)];
  [(id)*a1 setPixelFormat:55];
  [(id)*a1 setTextureType:2];
  [(id)*a1 setUsage:3];
  [(id)*a1 setHeight:a3];
  [(id)*a1 setWidth:a4];
  *a2 = [v8 newTextureWithDescriptor:*a1 offset:0 bytesPerRow:4 * a4];
}

void sub_1000695CC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

uint64_t CalibrateRgbIr::LocalValidationSelect(uint64_t a1, float *a2, uint64_t *a3)
{
  uint64_t v10 = 0;
  uint64_t v11 = 0;
  BOOL isMinimumOnBorder = GridArea::isMinimumOnBorder(a2, 1, &v11);
  BOOL v6 = GridArea::isMinimumOnBorder(a2, 0, &v10);
  if (!isMinimumOnBorder || (BOOL v7 = v6, result = 0, !v7))
  {
    if (isMinimumOnBorder) {
      uint64_t result = 2;
    }
    else {
      uint64_t result = 1;
    }
    if (isMinimumOnBorder) {
      uint64_t v9 = &v10;
    }
    else {
      uint64_t v9 = &v11;
    }
    *a3 = *v9;
  }
  return result;
}

void CalibrateRgbIr::ChooseResult2(CalibrateRgbIr *this, GridArea *a2, GridArea *a3, int a4)
{
  GridArea::CalcNewConfidence((uint64_t)a2, a4, 1, &v4);
}

void sub_100069BC4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12)
{
  _Unwind_Resume(a1);
}

void sub_100069CCC(__CFDictionary *a1, const void *a2, double a3)
{
  double valuePtr = a3;
  CFNumberRef v5 = CFNumberCreate(kCFAllocatorDefault, kCFNumberDoubleType, &valuePtr);
  CFDictionarySetValue(a1, a2, v5);
  CFRelease(v5);
}

uint64_t CalibrateRgbIr::ScanCostGrid(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  float v11 = sqrtf((float)*(unsigned int *)(a2 + 20));
  if (CalibrateRgbIr::PrepareGridCalculation(a1, a2, a3, v11 & 0xFFFFFFF0, v11 * v11 / (v11 & 0xFFFFFFF0)))
  {
    float v12 = *(float *)(a6 + 4);
    v24[1] = v12 + 6.0;
    v24[2] = 3.0;
    v23[0] = v12 + -6.0;
    v23[1] = v12 + 6.0;
    v23[2] = 3.0;
    v24[0] = -6.0;
    int v22 = 1065353216;
    uint64_t v21 = 0;
    v19[6] = -1061158912;
    *(float *)&v19[7] = v12 + 6.0;
    *(float *)&v19[8] = v12 + -6.0;
    *(float *)&v19[9] = v12 + 6.0;
    __asm { FMOV            V0.2S, #3.0 }
    uint64_t v20 = _D0;
    GridArea::PrepareGrid(v19, v24, (uint64_t)v23, (float *)&v21, 0);
  }
  NSLog(@"RGB-IR Calib: %s", "PrepareGridCalculation failed.");
  return 4097;
}

void sub_10006A774(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *__p, uint64_t a20,int a21,__int16 a22,char a23,char a24,uint64_t a25,char a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,void *a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,char a53)
{
  if (a24 < 0) {
    operator delete(__p);
  }
  GridArea::~GridArea((GridArea *)&a26);
  GridArea::~GridArea((GridArea *)&a53);
  GridArea::~GridArea((GridArea *)(v53 - 176));
  _Unwind_Resume(a1);
}

void sub_10006A858(uint64_t a1, uint64_t a2, uint64_t a3, float *a4, int a5)
{
  *(_OWORD *)(a1 + 24) = *(_OWORD *)a2;
  int v5 = *(_DWORD *)(a3 + 8);
  *(_DWORD *)(a1 + 40) = *(_DWORD *)(a2 + 8);
  *(_DWORD *)(a1 + 44) = v5;
  GridArea::PrepareGrid((_DWORD *)a1, (float *)a2, a3, a4, a5);
}

void sub_10006A89C(__CFDictionary *a1, const void *a2, float a3)
{
  float valuePtr = a3;
  CFNumberRef v5 = CFNumberCreate(kCFAllocatorDefault, kCFNumberFloatType, &valuePtr);
  CFDictionarySetValue(a1, a2, v5);
  CFRelease(v5);
}

uint64_t CalibrateRgbIr::CheckPceCalibValid(int a1, CFDictionaryRef theDict, uint64_t a3)
{
  if (theDict)
  {
    CFNumberRef Value = (const __CFNumber *)CFDictionaryGetValue(theDict, kFigCaptureStreamMetadata_PracticalFocalLength);
    if (Value)
    {
      float valuePtr = 0.0;
      CFNumberGetValue(Value, kCFNumberFloatType, &valuePtr);
      if (vabdd_f64(valuePtr, *(double *)(a3 + 8792)) < 0.00001)
      {
        CFDataRef v6 = (const __CFData *)CFDictionaryGetValue(theDict, kFigCaptureStreamMetadata_ExtrinsicMatrix);
        if (v6)
        {
          CFDataGetBytePtr(v6);
          operator new[]();
        }
      }
    }
  }
  return 0;
}

void CalibrateRgbIr::GetCommonCamParams(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = *(void *)(a1 + 8);
  *(void *)(a2 + 8) = *(void *)(a1 + 16);
  *(void *)(a2 + 16) = *(void *)(a1 + 24);
  int v2 = *(unsigned __int16 *)(a1 + 4258);
  *(_DWORD *)(a2 + 184) = *(unsigned __int16 *)(a1 + 4256);
  *(_DWORD *)(a2 + 188) = v2;
  operator new[]();
}

void CalibrateRgbIr::GetCamParams(uint64_t a1, uint64_t a2, uint64_t a3)
{
}

void CalibrateRgbIr::GetTargetCam(uint64_t a1, unsigned int a2, unsigned int a3, uint64_t a4, uint64_t a5, double a6, double a7, double a8, double a9, double a10, double a11, double a12)
{
  *(_DWORD *)(a5 + 184) = a2;
  *(_DWORD *)(a5 + 188) = a3;
  LOWORD(a6) = *(_WORD *)(a4 + 12);
  LOWORD(a7) = *(_WORD *)(a4 + 14);
  long long v19 = xmmword_100082C60;
  uint64_t v18 = 0;
  unint64_t v20 = 0xBFF0000000000000;
  long long v21 = 0u;
  long long v22 = 0u;
  uint64_t v23 = 0x3FF0000000000000;
  double v13 = *(double *)(a1 + 4288);
  double v14 = (double)*(unint64_t *)&a6;
  double v15 = v13 * v14 / (double)a3;
  *(double *)(a5 + 48) = v15;
  LOWORD(a12) = *(_WORD *)(a1 + 8544);
  LOWORD(v12) = *(_WORD *)(a1 + 8546);
  double v16 = *(double *)(a1 + 4304)
      + (double)*(unint64_t *)&a12 * -0.5 * v13
      + v14 * 0.5 * v13
      + (double)a3 * -0.5 * v15;
  double v17 = *(double *)(a1 + 4312)
      + (double)v12 * -0.5 * v13
      + (double)*(unint64_t *)&a7 * 0.5 * v13
      + (double)a2 * -0.5 * v15;
  *(double *)(a5 + 8) = (double)a2 * 0.5 * v15 - (v17 - v16 * 0.0);
  *(double *)(a5 + 16) = v16 + v17 * 0.0 + (double)a3 * 0.5 * v15;
  *(void *)a5 = *(void *)(a1 + 4296);
  *(_DWORD *)(a5 + 24) = 256;
  operator new[]();
}

void CalibrateRgbIr::PrepareColorImage(int a1, __CVBuffer *a2)
{
  memset(&src, 0, sizeof(src));
  PrepareVImgBuffersFromCVPixBuffer(a2, &src);
  operator new[]();
}

void sub_10006B3E0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, uint64_t a15, int a16, __int16 a17, char a18, char a19, uint64_t a20,void *__p,uint64_t a22,int a23,__int16 a24,char a25,char a26,char a27,uint64_t a28,uint64_t a29,uint64_t a30,char a31,uint64_t a32,uint64_t a33,uint64_t a34,void *a35,uint64_t a36,int a37,__int16 a38,char a39,char a40,uint64_t a41,uint64_t a42,uint64_t a43,int a44,__int16 a45,char a46,char a47)
{
}

void sub_10006B484(_DWORD *a1, unint64_t a2, unint64_t a3, unint64_t a4, uint64_t a5, int a6, int a7, unint64_t a8)
{
  if (byte_1002BBEAF >= 0) {
    size_t v15 = byte_1002BBEAF;
  }
  else {
    size_t v15 = *((void *)&gCurrFrameId + 1);
  }
  double v16 = &v24;
  sub_100010C44((uint64_t)&v24, v15 + 1);
  if ((v24.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
    double v16 = (std::string *)v24.__r_.__value_.__r.__words[0];
  }
  if (v15)
  {
    if (byte_1002BBEAF >= 0) {
      double v17 = &gCurrFrameId;
    }
    else {
      double v17 = (long long *)gCurrFrameId;
    }
    memmove(v16, v17, v15);
  }
  *(_WORD *)((char *)&v16->__r_.__value_.__l.__data_ + v15) = 95;
  int v18 = *(char *)(a5 + 23);
  if (v18 >= 0) {
    long long v19 = (const std::string::value_type *)a5;
  }
  else {
    long long v19 = *(const std::string::value_type **)a5;
  }
  if (v18 >= 0) {
    std::string::size_type v20 = *(unsigned __int8 *)(a5 + 23);
  }
  else {
    std::string::size_type v20 = *(void *)(a5 + 8);
  }
  long long v21 = std::string::append(&v24, v19, v20);
  long long v22 = *(_OWORD *)&v21->__r_.__value_.__l.__data_;
  std::string::size_type v26 = v21->__r_.__value_.__r.__words[2];
  *(_OWORD *)std::string __p = v22;
  v21->__r_.__value_.__l.__size_ = 0;
  v21->__r_.__value_.__r.__words[2] = 0;
  v21->__r_.__value_.__r.__words[0] = 0;
  sub_10006E4AC(a1, a2, a3, a4, (uint64_t)__p, a6, a7, a8);
  if (SHIBYTE(v26) < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v24.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v24.__r_.__value_.__l.__data_);
  }
}

void sub_10006B5CC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  if (a15 < 0) {
    operator delete(a10);
  }
  _Unwind_Resume(exception_object);
}

void sub_10006B600(float *a1, uint64_t a2, uint64_t a3, unsigned int a4, float *a5)
{
  id v8 = (float *)__chkstk_darwin();
  uint64_t v10 = (char *)&v20 - v9;
  uint64_t v13 = (v12 * v11);
  sub_10006EC9C(v8, (uint64_t *)((char *)&v20 - v9), v14, v13);
  if (v13)
  {
    double v15 = (double)v13;
    do
    {
      float v16 = *a1++;
      double v17 = v16 / (1.0 / (double)a4);
      unsigned int v18 = vcvtmd_u64_f64(v17);
      if (v18 >= a4) {
        unsigned int v18 = a4 - 1;
      }
      LODWORD(v17) = *(_DWORD *)&v10[4 * v18];
      float v19 = (double)*(unint64_t *)&v17 / v15;
      *a5++ = v19;
      --v13;
    }
    while (v13);
  }
}

uint64_t CalibrateRgbIr::ApplyGaussian2DFilter(uint64_t a1, uint64_t a2, uint64_t a3, unsigned int a4)
{
  unsigned int v4 = *(_DWORD *)(a2 + 20);
  if (v4 != *(_DWORD *)(a3 + 20) || (int v7 = *(_DWORD *)(a2 + 16), v7 != *(_DWORD *)(a3 + 16))) {
    sub_10006F088();
  }
  unsigned int v8 = a4;
  if (a4)
  {
    if (v4 < a4) {
      sub_10006F05C();
    }
  }
  else
  {
    unsigned int v8 = *(_DWORD *)(a2 + 20);
  }
  sub_10006ED44((uint64_t)v26, v7 + 4, v8 + 4);
  unsigned int v9 = v7 + 2;
  if ((v7 + 2) >= 3)
  {
    unsigned int v10 = 0;
    do
    {
      if (v28 <= v10 + 2 || v29 < 3 || (v11 = v10, *(_DWORD *)(a2 + 16) <= v10) || (int v12 = *(_DWORD *)(a2 + 20)) == 0) {
        __assert_rtn("operator()", "Matrix.hpp", 119, "row < m_rows && col < m_cols");
      }
      memcpy((void *)(v27 + 4 * v29 * (v10 + 2) + 8), (const void *)(*(void *)(a2 + 8) + 4 * v12 * v10), 4 * v8);
      ++v10;
    }
    while (v11 + 3 != v9);
  }
  sub_100063914((uint64_t)v22, v7 + 4, v8 + 4);
  int v31 = 1019113512;
  v30[2] = xmmword_100082D30;
  void v30[3] = unk_100082D40;
  _DWORD v30[4] = xmmword_100082D50;
  char v30[5] = unk_100082D60;
  v30[0] = xmmword_100082D10;
  v30[1] = unk_100082D20;
  v20[0] = off_100095B38;
  v20[1] = v30;
  void v20[2] = 0x500000005;
  char v21 = 0;
  sub_1000045A0((uint64_t)v26, (uint64_t)v20, (uint64_t)v22);
  int v13 = *(_DWORD *)(a3 + 20) * *(_DWORD *)(a3 + 16);
  if (v13 >= 1)
  {
    unint64_t v14 = *(void *)(a3 + 8);
    unint64_t v15 = v14 + 4 * v13;
    if (v15 <= v14 + 4) {
      unint64_t v15 = v14 + 4;
    }
    bzero((void *)v14, ((v15 + ~v14) & 0xFFFFFFFFFFFFFFFCLL) + 4);
  }
  if (v9 >= 3)
  {
    unsigned int v16 = 0;
    size_t v17 = 4 * v8;
    do
    {
      if (*(_DWORD *)(a3 + 16) <= v16 || (int v18 = *(_DWORD *)(a3 + 20)) == 0 || v24 <= v16 + 2 || v25 <= 2) {
        __assert_rtn("operator()", "Matrix.hpp", 119, "row < m_rows && col < m_cols");
      }
      memcpy((void *)(*(void *)(a3 + 8) + 4 * v18 * v16), (const void *)(v23 + 4 * v25 * (v16 + 2) + 8), v17);
      ++v16;
    }
    while (v7 != v16);
  }
  sub_1000046EC((uint64_t)v20);
  sub_1000046EC((uint64_t)v22);
  sub_1000046EC((uint64_t)v26);
  return 0;
}

void sub_10006B9D4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17)
{
}

uint64_t CalibrateRgbIr::InitDebugDictionary(CFMutableDictionaryRef *this)
{
  CFDictionaryRemoveAllValues(this[126]);
  CFDictionarySetValue(this[126], @"choice", @"None");
  CFDictionarySetValue(this[126], @"resultValid", kCFBooleanFalse);
  CFStringRef v2 = CFStringCreateWithFormat(0, 0, @"%d.%d.%d", 1, 12, 0);
  CFDictionarySetValue(this[126], @"AlgoVersion", v2);
  CFRelease(v2);
  return 0;
}

void CalibrateRgbIr::ScaleImage(uint64_t a1, void *a2, vImagePixelCount a3, vImagePixelCount a4, uint64_t a5, uint64_t a6, uint64_t a7, unint64_t *a8)
{
  src.data = a2;
  src.height = a4;
  src.width = a3;
  src.rowBytes = 4 * a3;
  unint64_t v8 = 4 * a5;
  if ((a5 & 0xF) != 0) {
    unint64_t v8 = ((4 * a5) & 0xFFFFFFFFFFFFFFC0) + 64;
  }
  *a8 = v8 >> 2;
  operator new[]();
}

uint64_t CalibrateRgbIr::MedianFilter(uint64_t a1, uint64_t a2, uint64_t a3, unsigned int a4, uint64_t a5)
{
  unint64_t v10 = (a3 + 63) & 0xFFFFFFFFFFFFFFC0;
  sub_10006EDF8((uint64_t)v36, *(_DWORD *)(a2 + 16), (a3 + 63) & 0xFFFFFFC0);
  sub_100004758(a5, *(_DWORD *)(a2 + 16), *(_DWORD *)(a2 + 20));
  if (*(_DWORD *)(a2 + 16))
  {
    unsigned int v11 = 0;
    do
    {
      LODWORD(v12) = *(_DWORD *)(a2 + 20);
      if (v12)
      {
        unint64_t v13 = 0;
        do
        {
          if (*(_DWORD *)(a2 + 16) <= v11 || v38 <= v11 || v13 >= v39) {
            __assert_rtn("operator()", "Matrix.hpp", 119, "row < m_rows && col < m_cols");
          }
          float v14 = *(float *)(*(void *)(a2 + 8) + 4 * v11 * v12 + 4 * v13);
          if (v14 <= 1.0) {
            float v15 = v14 * 255.0;
          }
          else {
            float v15 = 255.0;
          }
          *((unsigned char *)v37 + v11 * v39 + v13++) = llroundf(v15);
          unint64_t v12 = *(unsigned int *)(a2 + 20);
        }
        while (v13 < v12);
      }
      if (v38 <= v11 || v39 <= a3) {
        __assert_rtn("operator()", "Matrix.hpp", 119, "row < m_rows && col < m_cols");
      }
      bzero((char *)v37 + a3 + v39 * v11++, v10 - a3);
    }
    while (v11 < *(_DWORD *)(a2 + 16));
  }
  sub_100010914(v34, "irSamplesBeforeMedianU8.pb");
  sub_100010914(__p, "IR samples before Median Filter");
  if (v33 < 0) {
    operator delete(__p[0]);
  }
  if (v35 < 0) {
    operator delete(v34[0]);
  }
  unsigned int v16 = (void *)(a1 + 608);
  id v31 = 0;
  MetalObjects::createTextureMedian((void *)(a1 + 608), &v31, v37, v38, v39, v10, 0);
  id v17 = v31;
  id v30 = 0;
  MetalObjects::createTextureMedian(v16, &v30, 0, v38, v39, v10, 1);
  id v18 = v30;
  MetalObjects::medianFilter((uint64_t)v16, v17, v18, a4, 1);
  id v19 = [v18 buffer];
  uint64_t v20 = (unsigned __int8 *)[v19 contents];

  sub_100010914(v34, "irSamplesAfterMedianU8.pb");
  sub_100010914(__p, "IR samples after Median Filter (uint8)");
  if (v33 < 0) {
    operator delete(__p[0]);
  }
  if (v35 < 0) {
    operator delete(v34[0]);
  }
  int v21 = *(_DWORD *)(a5 + 16);
  if (v21)
  {
    int v22 = 0;
    unint64_t v23 = v10 - *(unsigned int *)(a2 + 20);
    unsigned int v24 = *(float **)(a5 + 8);
    int v25 = *(_DWORD *)(a5 + 20);
    do
    {
      for (int i = v25; i; --i)
      {
        unsigned int v27 = *v20++;
        float v28 = (double)v27 / 255.0;
        *v24++ = v28;
      }
      ++v22;
      v20 += v23;
    }
    while (v22 != v21);
  }

  sub_10006EEBC((uint64_t)v36);
  return 0;
}

void sub_10006BEC0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19, char a20)
{
  if (a19 < 0) {
    operator delete(__p);
  }

  sub_10006EEBC((uint64_t)&a20);
  _Unwind_Resume(a1);
}

uint64_t CalibrateRgbIr::PrepareIrImage(uint64_t a1, CVPixelBufferRef pixelBuffer, uint64_t a3, size_t *a4, size_t *a5)
{
  *a4 = CVPixelBufferGetWidth(pixelBuffer);
  size_t Height = CVPixelBufferGetHeight(pixelBuffer);
  *a5 = Height;
  if (gDbgLvl)
  {
    unint64_t v10 = *(__CFDictionary **)(a1 + 1008);
    v15.width = (double)*a4;
    v15.height = (double)Height;
    sub_10006C54C(v10, @"IrResolution", &v15);
  }
  sub_100010914(&v15, "OrigIrFromCVPixB.pb");
  sub_100010914(&__p, "Original IR frame from CVPixelBuffer");
  GrayScaleImage::save((int)&v15, pixelBuffer);
  if (v14 < 0) {
    operator delete(__p);
  }
  if (v16 < 0) {
    operator delete(*(void **)&v15.width);
  }
  if (CVPixelBufferGetPixelFormatType(pixelBuffer) == 1278226742)
  {
    CVPixelBufferGetBytesPerRow(pixelBuffer);
    if (!CVPixelBufferLockBaseAddress(pixelBuffer, 1uLL))
    {
      CVPixelBufferGetBaseAddress(pixelBuffer);
      if (*a5 == 1315) {
        *a5 = 1312;
      }
      operator new[]();
    }
    return 4098;
  }
  else
  {
    NSLog(@"RGB-IR Calib: %s", "IR buffer is not in a supported format.");
    return 12290;
  }
}

void sub_10006C428(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, uint64_t a15, int a16, __int16 a17, char a18, char a19, uint64_t a20,void *__p,uint64_t a22,int a23,__int16 a24,char a25,char a26,void *a27,uint64_t a28,int a29,__int16 a30,char a31,char a32,uint64_t a33,void *a34,uint64_t a35,int a36,__int16 a37,char a38,char a39)
{
  if (a26 < 0) {
    operator delete(__p);
  }
  sub_1000046EC((uint64_t)&a14);
  sub_1000046EC((uint64_t)&a27);
  sub_1000046EC((uint64_t)&a34);
  if (v39) {
    operator delete[]();
  }
  operator delete[]();
}

void sub_10006C54C(__CFDictionary *a1, const void *a2, CGSize *a3)
{
  CFDictionaryRef DictionaryRepresentation = CGSizeCreateDictionaryRepresentation(*a3);
  CFDictionarySetValue(a1, a2, DictionaryRepresentation);

  CFRelease(DictionaryRepresentation);
}

uint64_t CalibrateRgbIr::PrepareDepthImage(uint64_t a1, CVPixelBufferRef pixelBuffer)
{
  PixelFormatCFNumberType Type = CVPixelBufferGetPixelFormatType(pixelBuffer);
  if (*(unsigned char *)(a1 + 464)) {
    BOOL v5 = PixelFormatType == 825306677;
  }
  else {
    BOOL v5 = 1;
  }
  if (!v5)
  {
    unsigned int v9 = "Depth pixel buffer format should be kCVPixelFormatType_FixedPointUnsigned11_5 if it is normalized dx";
LABEL_18:
    NSLog(@"RGB-IR Calib: %s", v9);
    return 12291;
  }
  if (*(unsigned char *)(a1 + 464)) {
    BOOL v6 = 1;
  }
  else {
    BOOL v6 = PixelFormatType == 825437747;
  }
  if (!v6)
  {
    unsigned int v9 = "Depth pixel buffer format should be kCVPixelFormatType_FixedPointUnsigned13_3 if they are absolute values (not normalized dx)";
    goto LABEL_18;
  }
  if (gDbgLvl)
  {
    if (*(unsigned char *)(a1 + 464)) {
      int v7 = (const void **)&kCFBooleanTrue;
    }
    else {
      int v7 = (const void **)&kCFBooleanFalse;
    }
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 1008), @"isNormalizedDx", *v7);
  }
  CVPixelBufferGetBytesPerRow(pixelBuffer);
  if (!CVPixelBufferLockBaseAddress(pixelBuffer, 1uLL)) {
    operator new[]();
  }
  return 4099;
}

void sub_10006C830(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19)
{
  if (a19 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t CalibrateRgbIr::RetrieveRoiInfo(uint64_t a1, CFArrayRef theArray, unint64_t a3, unint64_t a4, CGRect *a5)
{
  if (theArray && CFArrayGetCount(theArray) >= 1)
  {
    CFDictionaryRef ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(theArray, 0);
    if (ValueAtIndex)
    {
      CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(ValueAtIndex, kFigCaptureStreamMetadata_Rect);
      if (Value)
      {
        if (CGRectMakeWithDictionaryRepresentation(Value, &rect))
        {
          CGFloat x = rect.origin.x;
          CGFloat y = rect.origin.y;
          a5->origin.CGFloat x = rect.origin.x;
          a5->origin.CGFloat y = y;
          CGFloat width = rect.size.width;
          CGFloat height = rect.size.height;
          a5->size.CGFloat width = rect.size.width;
          a5->size.CGFloat height = height;
          NSLog(@"RGB-IR Calib: ROI is: origin (x=%f, y=%f), size (h=%f, w=%f)", *(void *)&x, *(void *)&y, *(void *)&height, *(void *)&width);
          if (gDbgLvl)
          {
            char v16 = *(__CFDictionary **)(a1 + 1008);
            CFDictionaryRef DictionaryRepresentation = CGRectCreateDictionaryRepresentation(*a5);
            CFDictionarySetValue(v16, @"faceRoi", DictionaryRepresentation);
            CFRelease(DictionaryRepresentation);
          }
          uint64_t result = 0;
          double v20 = a5->size.width;
          double v19 = a5->size.height;
          CGFloat v21 = round(a5->origin.x * (double)a4);
          a5->origin.CGFloat x = round((1.0 - a5->origin.y - v19) * (double)a3);
          a5->origin.CGFloat y = v21;
          a5->size.CGFloat width = round(v19 * (double)a3);
          a5->size.CGFloat height = round(v20 * (double)a4);
          return result;
        }
        int v22 = "Could not retrieve ROI information from detected faces array.";
      }
      else
      {
        int v22 = "Could not find ROI element in detected faces array.";
      }
    }
    else
    {
      int v22 = "Could not retrieve any element from detected faces array.";
    }
    NSLog(@"RGB-IR Calib: %s", v22);
    if (gDbgLvl) {
      CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 1008), @"failureReason", @"Could not retrieve face ROI information. Check detectedFaces argument.");
    }
    return 8193;
  }
  else
  {
    if (gDbgLvl) {
      CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 1008), @"failureReason", @"No face ROI specified.");
    }
    NSLog(@"RGB-IR Calib: %s", "No detected faces provided. Calibration will not be performed.");
    return 16386;
  }
}

uint64_t CalibrateRgbIr::CalculateFinalResult(float64x2_t *a1, uint64_t a2, float32x2_t a3, float32_t a4, float a5)
{
  float64x2_t v28 = a1[5];
  double v6 = a1[6].f64[0];
  a3.f32[1] = a4;
  float64x2_t v28 = vaddq_f64(v28, vcvtq_f64_f32(a3));
  double v29 = v6 + a5;
  uint64_t v27 = 0;
  memset(v26, 0, sizeof(v26));
  int v7 = v26;
  sub_100005308(v28.f64, (uint64_t)v26);
  uint64_t v8 = 0;
  uint64_t v19 = 0;
  uint64_t v20 = 0;
  long long v21 = xmmword_100082730;
  long long v23 = 0u;
  long long v24 = 0u;
  uint64_t v22 = 0x3FF0000000000000;
  uint64_t v25 = 0x3FF0000000000000;
  memset(v18, 0, sizeof(v18));
  do
  {
    uint64_t v9 = 0;
    unint64_t v10 = (double *)&v20;
    do
    {
      uint64_t v11 = 0;
      double v12 = 0.0;
      unint64_t v13 = v10;
      do
      {
        double v14 = *v13;
        v13 += 3;
        double v12 = v12 + *(double *)((char *)v7 + v11) * v14;
        v11 += 8;
      }
      while (v11 != 24);
      *((double *)v18 + 3 * v8 + v9++) = v12;
      ++v10;
    }
    while (v9 != 3);
    ++v8;
    int v7 = (_OWORD *)((char *)v7 + 24);
  }
  while (v8 != 3);
  long long v16 = 0uLL;
  uint64_t v17 = 0;
  sub_100005E50((uint64_t)v18, (long double *)&v16);
  *(_OWORD *)a2 = v16;
  *(void *)(a2 + 16) = v17;
  return 0;
}

uint64_t CalibrateRgbIr::Calibrate(uint64_t a1, int a2, const __CFDictionary *a3, int a4, int a5, int a6, unsigned int a7, const __CFBoolean *a8, double *a9, CFArrayRef theArray, __int16 a11, uint64_t a12, uint64_t a13, uint64_t a14)
{
  *(unsigned char *)(a1 + 976) = 0;
  NSLog(@"RGB-IR Calib: Starting Mutual Information v%d.%d.%d. NormalizedDX: %d, perception corrected: %@, shift offset: %d", 1, 12, 0, a7, a8, a11);
  long long v16 = sub_100010914(&valuePtr, "PCECalib.bin");
  SaveToFileWithPrefix((uint64_t)v16);
  if (v42 < 0) {
    operator delete(valuePtr);
  }
  if (gDbgLvl)
  {
    CalibrateRgbIr::InitDebugDictionary((CFMutableDictionaryRef *)a1);
    uint64_t v39 = +[NSNumber numberWithDouble:a9[1069]];
    uint64_t v43 = v39;
    uint64_t v44 = +[NSNumber numberWithDouble:a9[1070]];
    uint64_t v37 = (void *)v44;
    uint64_t v36 = +[NSNumber numberWithDouble:a9[1071]];
    long long v45 = v36;
    uint64_t v17 = +[NSNumber numberWithDouble:a9[1072]];
    id v46 = v17;
    id v18 = +[NSNumber numberWithDouble:a9[1073]];
    uint64_t v47 = v18;
    uint64_t v19 = +[NSNumber numberWithDouble:a9[1074]];
    long long v48 = v19;
    uint64_t v20 = +[NSNumber numberWithDouble:a9[1075]];
    int v49 = v20;
    long long v21 = +[NSNumber numberWithDouble:a9[1076]];
    long long v50 = v21;
    uint64_t v22 = +[NSNumber numberWithDouble:a9[1077]];
    dispatch_queue_t v51 = v22;
    long long v23 = +[NSArray arrayWithObjects:&v43 count:9];

    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 1008), @"colorRotationMatrix", v23);
  }
  uint64_t Value = CFBooleanGetValue(a8);
  if (Value)
  {
    uint64_t v25 = a1;
    *(unsigned char *)(a1 + 464) = a7;
    if (a7)
    {
      double v26 = a9[1640];
      BOOL v27 = v26 > 0.0;
      double v28 = 10.0;
      if (v26 > 0.0) {
        double v28 = 0.0;
      }
      double v29 = a9[1098] / 0.8;
      double v30 = v26 * a9[1099];
      double v31 = 1.0 / a9[1084];
      double v32 = ceil(v30 / v29 * (dbl_100082CF0[v27] - v31));
      double v33 = -v29 / v30;
      *(double *)(a1 + 472) = v33 * 0.03125;
      *(double *)(a1 + 480) = v31 - v33 * (v28 + v32);
    }
    if (*(unsigned char *)(a1 + 492)
      || (Value = CalibrateRgbIr::CheckPceCalibValid(Value, a3, (uint64_t)a9), uint64_t v25 = a1, (Value & 1) != 0))
    {
      CalibrateRgbIr::GetCamParams(Value, (uint64_t)a9, v25 + 232);
    }
    NSLog(@"RGB-IR Calib: %s", "PCECalib and IR metadata do not match. PCECalib is probably not valid anymore");
    if (gDbgLvl) {
      CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 1008), @"failureReason", @"Calibration data not consistent.");
    }
    CalibrateRgbIr::SaveDebugPlist((id *)a1);
    return 16385;
  }
  else
  {
    NSLog(@"RGB-IR Calib: %s", "depthPerspectiveCorrected is false. Currently, only perspective corrected depth is supported");
    if (gDbgLvl) {
      CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 1008), @"failureReason", @"Depth perspective not corrected.");
    }
    CalibrateRgbIr::SaveDebugPlist((id *)a1);
    return 12289;
  }
}

void sub_10006D7DC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,void *a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,int a31,__int16 a32,char a33,char a34,uint64_t a35,uint64_t a36,void *__p,uint64_t a38,int a39,__int16 a40,char a41,char a42,char a43,uint64_t a44,uint64_t a45,uint64_t a46,char a47,uint64_t a48,uint64_t a49,uint64_t a50,char a51)
{
  sub_1000046EC((uint64_t)&a51);
  if (*(void *)(v53 - 256)) {
    operator delete[]();
  }
  sub_1000046EC(v53 - 248);
  _Unwind_Resume(a1);
}

void CalibrateRgbIr::SaveDebugPlist(id *this)
{
  if ((~gDbgLvl & 0x11) == 0)
  {
    id v1 = this[126];
    if (byte_1002BBE97 >= 0) {
      size_t v2 = byte_1002BBE97;
    }
    else {
      size_t v2 = qword_1002BBE88;
    }
    uint64_t v3 = &v16;
    sub_100010C44((uint64_t)&v16, v2 + 1);
    if ((v16.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
      uint64_t v3 = (std::string *)v16.__r_.__value_.__r.__words[0];
    }
    if (v2)
    {
      if (byte_1002BBE97 >= 0) {
        unsigned int v4 = &gOutputDirName;
      }
      else {
        unsigned int v4 = (uint64_t *)gOutputDirName;
      }
      memmove(v3, v4, v2);
    }
    *(_WORD *)((char *)&v3->__r_.__value_.__l.__data_ + v2) = 47;
    if (byte_1002BBEAF >= 0) {
      BOOL v5 = (const std::string::value_type *)&gCurrFrameId;
    }
    else {
      BOOL v5 = (const std::string::value_type *)gCurrFrameId;
    }
    if (byte_1002BBEAF >= 0) {
      std::string::size_type v6 = byte_1002BBEAF;
    }
    else {
      std::string::size_type v6 = *((void *)&gCurrFrameId + 1);
    }
    int v7 = std::string::append(&v16, v5, v6);
    long long v8 = *(_OWORD *)&v7->__r_.__value_.__l.__data_;
    v17.__r_.__value_.__r.__words[2] = v7->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v17.__r_.__value_.__l.__data_ = v8;
    v7->__r_.__value_.__l.__size_ = 0;
    v7->__r_.__value_.__r.__words[2] = 0;
    v7->__r_.__value_.__r.__words[0] = 0;
    uint64_t v9 = std::string::append(&v17, "_Debug.plist", 0xCuLL);
    long long v10 = *(_OWORD *)&v9->__r_.__value_.__l.__data_;
    std::string::size_type v19 = v9->__r_.__value_.__r.__words[2];
    *(_OWORD *)std::string __p = v10;
    v9->__r_.__value_.__l.__size_ = 0;
    v9->__r_.__value_.__r.__words[2] = 0;
    v9->__r_.__value_.__r.__words[0] = 0;
    if (SHIBYTE(v17.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v17.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v16.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v16.__r_.__value_.__l.__data_);
    }
    CreateDirForFile((uint64_t *)__p);
    int v11 = SHIBYTE(v19);
    double v12 = (void **)__p[0];
    NSStringEncoding v13 = +[NSString defaultCStringEncoding];
    if (v11 >= 0) {
      double v14 = __p;
    }
    else {
      double v14 = v12;
    }
    CGSize v15 = +[NSString stringWithCString:v14 encoding:v13];
    [v1 writeToFile:v15 atomically:1];

    if (SHIBYTE(v19) < 0) {
      operator delete(__p[0]);
    }
  }
}

void sub_10006DB54(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,void *__p,uint64_t a24,int a25,__int16 a26,char a27,char a28)
{
  double v30 = v29;

  if (a28 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

uint64_t CalibrateRgbIr::ReleaseLocalResources(CalibrateRgbIr *this)
{
  long long v2 = *(_OWORD *)((char *)this + 248);
  v36[0] = *(_OWORD *)((char *)this + 232);
  v36[1] = v2;
  uint64_t v3 = *((void *)this + 35);
  v36[2] = *(_OWORD *)((char *)this + 264);
  long long v38 = *((_OWORD *)this + 18);
  uint64_t v4 = *((void *)this + 38);
  uint64_t v37 = v3;
  uint64_t v39 = v4;
  uint64_t v5 = *((void *)this + 41);
  long long v40 = *(_OWORD *)((char *)this + 312);
  long long v6 = *((_OWORD *)this + 22);
  long long v42 = *((_OWORD *)this + 21);
  long long v7 = *((_OWORD *)this + 23);
  long long v8 = *((_OWORD *)this + 24);
  uint64_t v9 = *((void *)this + 50);
  uint64_t v41 = v5;
  uint64_t v46 = v9;
  long long v45 = v8;
  long long v44 = v7;
  long long v43 = v6;
  long long v10 = *(_OWORD *)((char *)this + 408);
  long long v11 = *(_OWORD *)((char *)this + 424);
  long long v12 = *(_OWORD *)((char *)this + 440);
  uint64_t v50 = *((void *)this + 57);
  long long v48 = v11;
  long long v49 = v12;
  long long v47 = v10;
  ReleaseCamParams((uint64_t)v36);
  long long v13 = *((_OWORD *)this + 1);
  v21[0] = *(_OWORD *)this;
  v21[1] = v13;
  v21[2] = *((_OWORD *)this + 2);
  uint64_t v22 = *((void *)this + 6);
  long long v23 = *(_OWORD *)((char *)this + 56);
  uint64_t v24 = *((void *)this + 9);
  long long v25 = *((_OWORD *)this + 5);
  uint64_t v26 = *((void *)this + 12);
  long long v27 = *(_OWORD *)((char *)this + 104);
  long long v14 = *(_OWORD *)((char *)this + 120);
  long long v15 = *(_OWORD *)((char *)this + 136);
  long long v16 = *(_OWORD *)((char *)this + 152);
  uint64_t v31 = *((void *)this + 21);
  long long v30 = v16;
  long long v29 = v15;
  long long v28 = v14;
  long long v17 = *((_OWORD *)this + 11);
  long long v18 = *((_OWORD *)this + 12);
  long long v19 = *((_OWORD *)this + 13);
  uint64_t v35 = *((void *)this + 28);
  long long v33 = v18;
  long long v34 = v19;
  long long v32 = v17;
  return ReleaseCamParams((uint64_t)v21);
}

void sub_10006DCF4(__CFDictionary *a1, const void *a2, int a3)
{
  int valuePtr = a3;
  CFNumberRef v5 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt32Type, &valuePtr);
  CFDictionarySetValue(a1, a2, v5);
  CFRelease(v5);
}

void CalibrateRgbIr::PrepareXyzWorld(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  if (a6)
  {
    if (a7)
    {
      int v8 = *(_DWORD *)(a2 + 188) * *(_DWORD *)(a2 + 184);
      sub_100063914((uint64_t)v44, 2, v8);
      if (v46 && v47)
      {
        if (v46 > 1)
        {
          int v9 = *(_DWORD *)(a2 + 184);
          if (v9)
          {
            unsigned int v10 = 0;
            long long v11 = (float *)__src;
            long long v12 = (float *)((char *)__src + 4 * v47);
            double v13 = *(double *)(a2 + 48);
            double v14 = *(double *)(a2 + 8) / v13;
            int v15 = *(_DWORD *)(a2 + 188);
            double v16 = *(double *)(a2 + 16) / v13;
            do
            {
              if (v15)
              {
                for (unsigned int i = 0; i != v15; ++i)
                {
                  float v18 = v13 * ((float)v10 + 0.5 - v14);
                  *v11++ = v18;
                  float v19 = v13 * ((float)i + 0.5 - v16);
                  *v12++ = v19;
                }
              }
              ++v10;
            }
            while (v10 != v9);
          }
          sub_100063914((uint64_t)&v40, 2, v8);
          long long v40 = &off_10009D8A8;
          memcpy(__dst, __src, 4 * v47 * (unint64_t)v46);
          sub_100063914((uint64_t)v36, *(_DWORD *)(a2 + 188), *(_DWORD *)(a2 + 184));
          sub_100063914((uint64_t)v32, *(_DWORD *)(a2 + 188), *(_DWORD *)(a2 + 184));
          if (v42 && v43)
          {
            if (v42 > 1)
            {
              uint64_t v20 = v39;
              if (v39)
              {
                unint64_t v21 = 0;
                uint64_t v22 = v38;
                long long v23 = (float *)__dst;
                uint64_t v24 = (float *)((char *)__dst + 4 * v43);
                float v25 = *(double *)(a2 + 48);
                unint64_t v26 = v34;
                do
                {
                  if (v22)
                  {
                    unsigned int v27 = 0;
                    unsigned int v28 = 0;
                    unint64_t v29 = 0;
                    unint64_t v30 = v35;
                    do
                    {
                      *(float *)(v37 + 4 * v21 + 4 * v27) = *v23 / v25;
                      if (v29 >= v26 || v21 >= v30) {
                        __assert_rtn("operator()", "Matrix.hpp", 119, "row < m_rows && col < m_cols");
                      }
                      float v31 = *v24++;
                      ++v23;
                      *(float *)(v33 + 4 * v21 + 4 * v28) = v31 / v25;
                      ++v29;
                      v28 += v30;
                      v27 += v20;
                    }
                    while (v22 != v29);
                  }
                  ++v21;
                }
                while (v21 != v20);
              }
              operator new[]();
            }
            __assert_rtn("operator()", "Matrix.hpp", 119, "row < m_rows && col < m_cols");
          }
          __assert_rtn("operator()", "Matrix.hpp", 119, "row < m_rows && col < m_cols");
        }
        __assert_rtn("operator()", "Matrix.hpp", 119, "row < m_rows && col < m_cols");
      }
      __assert_rtn("operator()", "Matrix.hpp", 119, "row < m_rows && col < m_cols");
    }
    sub_10006F0E0();
  }
  sub_10006F0B4();
}

void sub_10006E3EC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_start(va2, a8);
  va_start(va1, a8);
  va_start(va, a8);
  uint64_t v9 = va_arg(va1, void);
  uint64_t v11 = va_arg(va1, void);
  uint64_t v12 = va_arg(va1, void);
  uint64_t v13 = va_arg(va1, void);
  va_copy(va2, va1);
  uint64_t v14 = va_arg(va2, void);
  uint64_t v16 = va_arg(va2, void);
  uint64_t v17 = va_arg(va2, void);
  uint64_t v18 = va_arg(va2, void);
  sub_1000046EC((uint64_t)va);
  sub_1000046EC((uint64_t)va1);
  sub_1000046EC((uint64_t)va2);
  _Unwind_Resume(a1);
}

BOOL sub_10006E448(_DWORD *a1, double *a2, double a3)
{
  LODWORD(a3) = *a1;
  double v3 = (double)*(unint64_t *)&a3;
  BOOL result = 0;
  if (*a2 <= v3 && *a2 + a2[2] > v3)
  {
    LODWORD(v3) = a1[1];
    double v4 = (double)*(unint64_t *)&v3;
    double v5 = a2[1];
    if (v5 <= v4 && v5 + a2[3] > v4) {
      return 1;
    }
  }
  return result;
}

uint64_t CalibrateRgbIr::abort(uint64_t this)
{
  *(unsigned char *)(this + 976) = 1;
  return this;
}

void sub_10006E4AC(_DWORD *a1, unint64_t a2, unint64_t a3, unint64_t a4, uint64_t a5, int a6, int a7, unint64_t a8)
{
  if ((gDbgLvl & 4) != 0)
  {
    if (a8) {
      unint64_t v14 = a8;
    }
    else {
      unint64_t v14 = a3 * a2;
    }
    if (byte_1002BBE97 >= 0) {
      size_t v15 = byte_1002BBE97;
    }
    else {
      size_t v15 = qword_1002BBE88;
    }
    uint64_t v16 = &v46;
    sub_100010C44((uint64_t)&v46, v15 + 1);
    if ((v46.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
      uint64_t v16 = (std::string *)v46.__r_.__value_.__r.__words[0];
    }
    if (v15)
    {
      if (byte_1002BBE97 >= 0) {
        uint64_t v17 = &gOutputDirName;
      }
      else {
        uint64_t v17 = (uint64_t *)gOutputDirName;
      }
      memmove(v16, v17, v15);
    }
    *(_WORD *)((char *)&v16->__r_.__value_.__l.__data_ + v15) = 47;
    int v18 = *(char *)(a5 + 23);
    if (v18 >= 0) {
      float v19 = (const std::string::value_type *)a5;
    }
    else {
      float v19 = *(const std::string::value_type **)a5;
    }
    if (v18 >= 0) {
      std::string::size_type v20 = *(unsigned __int8 *)(a5 + 23);
    }
    else {
      std::string::size_type v20 = *(void *)(a5 + 8);
    }
    unint64_t v21 = std::string::append(&v46, v19, v20);
    long long v22 = *(_OWORD *)&v21->__r_.__value_.__l.__data_;
    std::string::size_type v44 = v21->__r_.__value_.__r.__words[2];
    *(_OWORD *)std::string __p = v22;
    v21->__r_.__value_.__l.__size_ = 0;
    v21->__r_.__value_.__r.__words[2] = 0;
    v21->__r_.__value_.__r.__words[0] = 0;
    if (SHIBYTE(v46.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v46.__r_.__value_.__l.__data_);
    }
    if (CreateDirForFile((uint64_t *)__p)) {
      goto LABEL_59;
    }
    *(std::string::size_type *)((char *)v46.__r_.__value_.__r.__words
                              + *(void *)(v46.__r_.__value_.__r.__words[0] - 24)) = v23;
    uint64_t v24 = (std::ios_base *)((char *)&v46 + *(void *)(v46.__r_.__value_.__r.__words[0] - 24));
    std::ios_base::init(v24, &v46.__r_.__value_.__r.__words[1]);
    v24[1].__vftable = 0;
    v24[1].__fmtflags_ = -1;
    std::filebuf::basic_filebuf();
    if (a6)
    {
      std::ofstream::open();
      if (!v47) {
        goto LABEL_58;
      }
      if (a2 && v14)
      {
        LODWORD(v25) = 0;
        unint64_t v26 = 0;
        do
        {
          if (a3)
          {
            unint64_t v27 = 1;
            do
            {
              LODWORD(v45.__locale_) = 0;
              LODWORD(v45.__locale_) = *a1;
              std::ostream::write();
              ++a1;
              unint64_t v28 = v27 + 1;
              if (v27 >= a3) {
                break;
              }
              unint64_t v29 = v26 + v27++;
            }
            while (v29 < v14);
            unint64_t v26 = v26 + v28 - 1;
          }
          unint64_t v25 = (v25 + 1);
          a1 += (a4 >> 2) - a3;
        }
        while (v25 < a2 && v26 < v14);
      }
    }
    else
    {
      std::ofstream::open();
      if (!v47) {
        goto LABEL_58;
      }
      *(std::ostream *)((char *)&std::cout + (unint64_t)std::cout.__vftable[-2].~basic_ostream_0 + 16) = (std::ostream)10;
      if (a2)
      {
        int v31 = 0;
        LODWORD(v32) = 0;
        unint64_t v40 = 0;
        unint64_t v42 = a4 >> 2;
        unint64_t v33 = a3 - 1;
        while (!v33)
        {
LABEL_53:
          uint64_t v37 = (void *)std::ostream::operator<<();
          std::ios_base::getloc((const std::ios_base *)((char *)v37 + *(void *)(*v37 - 24)));
          unsigned int v38 = std::locale::use_facet(&v45, &std::ctype<char>::id);
          ((void (*)(const std::locale::facet *, uint64_t))v38->__vftable[2].~facet_0)(v38, 10);
          std::locale::~locale(&v45);
          std::ostream::put();
          std::ostream::flush();
          ++v40;
          unint64_t v32 = (v32 + 1);
          v31 += v42;
          if (v32 >= a2) {
            goto LABEL_54;
          }
        }
        int v39 = v32;
        unint64_t v32 = 0;
        if (v14 >= v40) {
          uint64_t v34 = v14 - v40;
        }
        else {
          uint64_t v34 = 0;
        }
        while (v34 != v32)
        {
          unsigned int v35 = (void *)std::ostream::operator<<();
          if (a7)
          {
            std::ios_base::getloc((const std::ios_base *)((char *)v35 + *(void *)(*v35 - 24)));
            uint64_t v36 = std::locale::use_facet(&v45, &std::ctype<char>::id);
            ((void (*)(const std::locale::facet *, uint64_t))v36->__vftable[2].~facet_0)(v36, 10);
            std::locale::~locale(&v45);
            std::ostream::put();
            std::ostream::flush();
          }
          else
          {
            sub_10003BB70(v35, (uint64_t)",", 1);
          }
          if (v33 <= ++v32)
          {
            v40 += v32;
            LODWORD(v32) = v39;
            goto LABEL_53;
          }
        }
        if (std::filebuf::close()) {
          goto LABEL_58;
        }
        goto LABEL_57;
      }
    }
LABEL_54:
    if (!std::filebuf::close()) {
LABEL_57:
    }
      std::ios_base::clear((std::ios_base *)((char *)&v46 + *(void *)(v46.__r_.__value_.__r.__words[0] - 24)), *(_DWORD *)((char *)&v46 + *(void *)(v46.__r_.__value_.__r.__words[0] - 24) + 32) | 4);
LABEL_58:
    std::filebuf::~filebuf();
    std::ostream::~ostream();
    std::ios::~ios();
LABEL_59:
    if (SHIBYTE(v44) < 0) {
      operator delete(__p[0]);
    }
  }
}

void sub_10006EAF8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20,uint64_t a21,std::locale a22,uint64_t a23,uint64_t a24,int a25,__int16 a26,char a27,char a28)
{
  if (a20 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void *sub_10006EB98(void *a1)
{
  std::filebuf::~filebuf();
  std::ostream::~ostream();
  std::ios::~ios();
  return a1;
}

void sub_10006EC64(uint64_t a1)
{
  sub_1000046EC(a1);

  operator delete();
}

void sub_10006EC9C(float *a1, _DWORD *a2, unsigned int a3, unsigned int a4)
{
  long long v6 = a2;
  if (a3) {
    bzero(a2, 4 * a3);
  }
  if (a4)
  {
    uint64_t v8 = a4;
    do
    {
      float v9 = *a1++;
      unsigned int v10 = vcvtmd_u64_f64(v9 / (1.0 / (double)(a3 - 1)));
      if (v10 >= a3) {
        unsigned int v10 = a3 - 1;
      }
      ++v6[v10];
      --v8;
    }
    while (v8);
  }
  if (a3)
  {
    int v11 = 0;
    uint64_t v12 = a3;
    do
    {
      v11 += *v6;
      *v6++ = v11;
      --v12;
    }
    while (v12);
  }
}

uint64_t sub_10006ED44(uint64_t result, int a2, int a3)
{
  *(void *)BOOL result = off_100095B38;
  if (a3 * a2) {
    operator new[]();
  }
  *(void *)(result + 8) = 0;
  *(_DWORD *)(result + 16) = a2;
  *(_DWORD *)(result + 20) = a3;
  *(unsigned char *)(result + 24) = 0;
  return result;
}

uint64_t sub_10006EDF8(uint64_t result, int a2, int a3)
{
  *(void *)BOOL result = off_10009D878;
  if (a3 * a2) {
    operator new[]();
  }
  *(void *)(result + 8) = 0;
  *(_DWORD *)(result + 16) = a2;
  *(_DWORD *)(result + 20) = a3;
  *(unsigned char *)(result + 24) = 0;
  return result;
}

void sub_10006EE84(uint64_t a1)
{
  sub_10006EEBC(a1);

  operator delete();
}

uint64_t sub_10006EEBC(uint64_t result)
{
  *(void *)BOOL result = off_10009D878;
  if (*(void *)(result + 8) && *(unsigned char *)(result + 24)) {
    operator delete[]();
  }
  *(void *)(result + 16) = 0;
  return result;
}

void sub_10006EF28()
{
  __assert_rtn("OneDimensionHorizontalFilterWithPadding", "CalibrateRgbIr.mm", 2464, "(filterSize % 2) == 1");
}

void sub_10006EF54()
{
  __assert_rtn("OneDimensionHorizontalFilterWithPadding", "CalibrateRgbIr.mm", 2462, "filter.Rows() == 1");
}

void sub_10006EF80()
{
  __assert_rtn("OneDimensionVerticalFilterWithPadding", "CalibrateRgbIr.mm", 2489, "(filterSize % 2) == 1");
}

void sub_10006EFAC()
{
  __assert_rtn("OneDimensionVerticalFilterWithPadding", "CalibrateRgbIr.mm", 2487, "filter.Rows() == 1");
}

void sub_10006EFD8(os_log_t log)
{
  int v1 = 136315138;
  uint64_t v2 = "PrepareGridCalculation";
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "RGB-IR: %s: rdar://112006283 Error creating textures => Aborting Rgb-Ir run\n", (uint8_t *)&v1, 0xCu);
}

void sub_10006F05C()
{
  __assert_rtn("ApplyGaussian2DFilter", "CalibrateRgbIr.mm", 1202, "input.Cols() >= relevantWidth");
}

void sub_10006F088()
{
  __assert_rtn("ApplyGaussian2DFilter", "CalibrateRgbIr.mm", 1200, "input.Cols() == output.Cols() && input.Rows() == output.Rows()");
}

void sub_10006F0B4()
{
}

void sub_10006F0E0()
{
}

void sub_10006F10C(int a1, NSObject *a2)
{
  int v2 = 136315394;
  double v3 = "PrepareXyzWorld";
  __int16 v4 = 1024;
  int v5 = a1;
  _os_log_error_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_ERROR, "RGB-IR: %s: rdar://112006283 numOfGoodPts is %d < 256 => Aborting Rgb-Ir run\n", (uint8_t *)&v2, 0x12u);
}

uint64_t SaveToFile(uint64_t result)
{
  if ((gDbgLvl & 4) != 0)
  {
    uint64_t v1 = result;
    *(void *)((char *)&v20[-1] + (void)*(v19 - 3)) = v2;
    double v3 = (std::ios_base *)((char *)&v20[-1] + (void)*(v19 - 3));
    std::ios_base::init(v3, v20);
    v3[1].__vftable = 0;
    v3[1].__fmtflags_ = -1;
    std::filebuf::basic_filebuf();
    if (byte_1002BBE97 >= 0) {
      size_t v4 = byte_1002BBE97;
    }
    else {
      size_t v4 = qword_1002BBE88;
    }
    int v5 = &v16;
    sub_100010C44((uint64_t)&v16, v4 + 1);
    if ((v16.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
      int v5 = (std::string *)v16.__r_.__value_.__r.__words[0];
    }
    if (v4)
    {
      if (byte_1002BBE97 >= 0) {
        long long v6 = &gOutputDirName;
      }
      else {
        long long v6 = (uint64_t *)gOutputDirName;
      }
      memmove(v5, v6, v4);
    }
    *(_WORD *)((char *)&v5->__r_.__value_.__l.__data_ + v4) = 47;
    int v7 = *(char *)(v1 + 23);
    if (v7 >= 0) {
      uint64_t v8 = (const std::string::value_type *)v1;
    }
    else {
      uint64_t v8 = *(const std::string::value_type **)v1;
    }
    if (v7 >= 0) {
      std::string::size_type v9 = *(unsigned __int8 *)(v1 + 23);
    }
    else {
      std::string::size_type v9 = *(void *)(v1 + 8);
    }
    unsigned int v10 = std::string::append(&v16, v8, v9);
    long long v11 = *(_OWORD *)&v10->__r_.__value_.__l.__data_;
    int64_t v18 = v10->__r_.__value_.__r.__words[2];
    *(_OWORD *)std::string __p = v11;
    v10->__r_.__value_.__l.__size_ = 0;
    v10->__r_.__value_.__r.__words[2] = 0;
    v10->__r_.__value_.__r.__words[0] = 0;
    if (SHIBYTE(v16.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v16.__r_.__value_.__l.__data_);
    }
    if (!CreateDirForFile((uint64_t *)__p))
    {
      std::ofstream::open();
      if (v20[15])
      {
        std::ostream::write();
        if (!std::filebuf::close()) {
          std::ios_base::clear((std::ios_base *)((char *)&v20[-1] + (void)*(v19 - 3)), *(_DWORD *)((char *)&v20[3] + (void)*(v19 - 3)) | 4);
        }
      }
      else
      {
        uint64_t v12 = sub_10003BB70(&std::cout, (uint64_t)"Could not open file [", 21);
        if (v18 >= 0) {
          uint64_t v13 = __p;
        }
        else {
          uint64_t v13 = (void **)__p[0];
        }
        if (v18 >= 0) {
          uint64_t v14 = HIBYTE(v18);
        }
        else {
          uint64_t v14 = (uint64_t)__p[1];
        }
        size_t v15 = sub_10003BB70(v12, (uint64_t)v13, v14);
        sub_10003BB70(v15, (uint64_t)"] for writing.\n", 15);
      }
    }
    if (SHIBYTE(v18) < 0) {
      operator delete(__p[0]);
    }
    std::filebuf::~filebuf();
    std::ostream::~ostream();
    return std::ios::~ios();
  }
  return result;
}

void sub_10006F550(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,uint64_t a23)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  sub_10006EB98(&a23);
  _Unwind_Resume(a1);
}

uint64_t CreateDirForFile(uint64_t *a1)
{
  if (*((char *)a1 + 23) >= 0) {
    uint64_t v1 = a1;
  }
  else {
    uint64_t v1 = (uint64_t *)*a1;
  }
  uint64_t v2 = +[NSString stringWithCString:encoding:](NSString, "stringWithCString:encoding:", v1, +[NSString defaultCStringEncoding]);
  double v3 = +[NSFileManager defaultManager];
  char v11 = 0;
  if ([v3 fileExistsAtPath:v2 isDirectory:&v11]) {
    goto LABEL_13;
  }
  size_t v4 = [v2 pathExtension];
  unsigned __int8 v5 = [v4 isEqualToString:&stru_1000A0098];

  if (v5)
  {
LABEL_12:
    if (![v3 createDirectoryAtPath:v2 withIntermediateDirectories:1 attributes:0 error:0])
    {
      uint64_t v9 = 0xFFFFFFFFLL;
      goto LABEL_15;
    }
LABEL_13:
    uint64_t v9 = 0;
LABEL_15:
    long long v6 = v2;
    goto LABEL_16;
  }
  long long v6 = [v2 stringByDeletingLastPathComponent];

  unsigned __int8 v7 = [v3 fileExistsAtPath:v6 isDirectory:&v11];
  if (v11) {
    unsigned __int8 v8 = v7;
  }
  else {
    unsigned __int8 v8 = 0;
  }
  if ((v8 & 1) == 0)
  {
    uint64_t v2 = v6;
    goto LABEL_12;
  }
  uint64_t v9 = 0;
LABEL_16:

  return v9;
}

void sub_10006F6E4(_Unwind_Exception *a1)
{
  size_t v4 = v3;

  _Unwind_Resume(a1);
}

void SaveToFileWithPrefix(uint64_t a1)
{
  if (byte_1002BBEAF >= 0) {
    size_t v2 = byte_1002BBEAF;
  }
  else {
    size_t v2 = *((void *)&gCurrFrameId + 1);
  }
  double v3 = &v10;
  sub_100010C44((uint64_t)&v10, v2 + 1);
  if ((v10.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
    double v3 = (std::string *)v10.__r_.__value_.__r.__words[0];
  }
  if (v2)
  {
    if (byte_1002BBEAF >= 0) {
      size_t v4 = &gCurrFrameId;
    }
    else {
      size_t v4 = (long long *)gCurrFrameId;
    }
    memmove(v3, v4, v2);
  }
  *(_WORD *)((char *)&v3->__r_.__value_.__l.__data_ + v2) = 95;
  int v5 = *(char *)(a1 + 23);
  if (v5 >= 0) {
    long long v6 = (const std::string::value_type *)a1;
  }
  else {
    long long v6 = *(const std::string::value_type **)a1;
  }
  if (v5 >= 0) {
    std::string::size_type v7 = *(unsigned __int8 *)(a1 + 23);
  }
  else {
    std::string::size_type v7 = *(void *)(a1 + 8);
  }
  unsigned __int8 v8 = std::string::append(&v10, v6, v7);
  long long v9 = *(_OWORD *)&v8->__r_.__value_.__l.__data_;
  std::string::size_type v12 = v8->__r_.__value_.__r.__words[2];
  *(_OWORD *)std::string __p = v9;
  v8->__r_.__value_.__l.__size_ = 0;
  v8->__r_.__value_.__r.__words[2] = 0;
  v8->__r_.__value_.__r.__words[0] = 0;
  SaveToFile((uint64_t)__p);
  if (SHIBYTE(v12) < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v10.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v10.__r_.__value_.__l.__data_);
  }
}

void sub_10006F820(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  if (a15 < 0) {
    operator delete(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t InitCamParams(uint64_t result)
{
  *(void *)(result + 32) = 0;
  *(void *)(result + 40) = 0;
  return result;
}

uint64_t ReleaseCamParams(uint64_t a1)
{
  if (*(void *)(a1 + 40)) {
    operator delete();
  }
  uint64_t result = *(void *)(a1 + 32);
  if (result) {
    operator delete();
  }
  return result;
}

uint64_t PrepareVImgBuffersFromCVPixBuffer(__CVBuffer *a1, vImage_Buffer *a2)
{
  vImagePixelCount Width = CVPixelBufferGetWidth(a1);
  vImagePixelCount Height = CVPixelBufferGetHeight(a1);
  if (CVPixelBufferLockBaseAddress(a1, 1uLL)) {
    return 0xFFFFFFFFLL;
  }
  a2->data = CVPixelBufferGetBaseAddressOfPlane(a1, 0);
  a2->CGFloat height = Height;
  a2->CGFloat width = Width;
  size_t BytesPerRowOfPlane = CVPixelBufferGetBytesPerRowOfPlane(a1, 0);
  uint64_t result = 0;
  a2->rowBytes = BytesPerRowOfPlane;
  return result;
}

uint64_t H16ISP::savePeridotCalib(H16ISP *this, H16ISPDevice *a2, H16ISPServicesRemote *a3, uint64_t a4, const void *a5)
{
  int v6 = (int)a3;
  long long v9 = off_1002BBD58;
  if (off_1002BBD58 == &_os_log_default)
  {
    os_log_t v10 = os_log_create("com.apple.isp", "general");
    char v11 = off_1002BBD58;
    off_1002BBD58 = v10;

    long long v9 = off_1002BBD58;
  }
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
  {
    int v27 = 136315138;
    unint64_t v28 = "savePeridotCalib";
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "%s - saving calibration\n", (uint8_t *)&v27, 0xCu);
  }
  if (!a4) {
    return 0;
  }
  std::string::size_type v12 = off_1002BBD58;
  if (off_1002BBD58 == &_os_log_default)
  {
    os_log_t v13 = os_log_create("com.apple.isp", "general");
    uint64_t v14 = off_1002BBD58;
    off_1002BBD58 = v13;

    std::string::size_type v12 = off_1002BBD58;
  }
  if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
  {
    int v27 = 136315138;
    unint64_t v28 = "savePeridotCalib";
    _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "%s - updating firmware\n", (uint8_t *)&v27, 0xCu);
  }
  if (sub_10006FDF0((uint64_t)this, v6))
  {
    size_t v15 = off_1002BBD58;
    if (a2)
    {
      if (off_1002BBD58 == &_os_log_default)
      {
        os_log_t v16 = os_log_create("com.apple.isp", "general");
        uint64_t v17 = off_1002BBD58;
        off_1002BBD58 = v16;

        size_t v15 = off_1002BBD58;
      }
      if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
      {
        int v27 = 136315138;
        unint64_t v28 = "savePeridotCalib";
        _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "%s - sending to daemon to store\n", (uint8_t *)&v27, 0xCu);
      }
      uint64_t BinaryRepresentation = PDPeridotCalibCreateBinaryRepresentation();
      if (BinaryRepresentation)
      {
        float v19 = (const void *)BinaryRepresentation;
        sub_10001BA90();
        CFRelease(v19);
      }
    }
    else
    {
      if (off_1002BBD58 == &_os_log_default)
      {
        os_log_t v25 = os_log_create("com.apple.isp", "general");
        unint64_t v26 = off_1002BBD58;
        off_1002BBD58 = v25;

        size_t v15 = off_1002BBD58;
      }
      if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
      {
        int v27 = 136315138;
        unint64_t v28 = "savePeridotCalib";
        _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "%s - storing locally\n", (uint8_t *)&v27, 0xCu);
      }
      sub_100009B28(a4);
    }
    return 1;
  }
  std::string::size_type v20 = off_1002BBD58;
  if (off_1002BBD58 == &_os_log_default)
  {
    os_log_t v21 = os_log_create("com.apple.isp", "general");
    long long v22 = off_1002BBD58;
    off_1002BBD58 = v21;

    std::string::size_type v20 = off_1002BBD58;
  }
  BOOL v23 = os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT);
  uint64_t result = 0;
  if (v23)
  {
    int v27 = 136315138;
    unint64_t v28 = "savePeridotCalib";
    _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "%s - failed to update calibration in firmware\n", (uint8_t *)&v27, 0xCu);
    return 0;
  }
  return result;
}

void sub_10006FDC4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL sub_10006FDF0(uint64_t a1, int a2)
{
  sub_1000043CC();
  CFDataRef IspFirmwareCalibWithOptions = (const __CFData *)PDPeridotCalibCreateIspFirmwareCalibWithOptions();
  if (IspFirmwareCalibWithOptions)
  {
    CFDataRef v5 = IspFirmwareCalibWithOptions;
    if (CFDataGetLength(IspFirmwareCalibWithOptions) == 536)
    {
      bzero(buf, 0x228uLL);
      LOWORD(v24) = 14087;
      HIDWORD(v24) = a2;
      v29.location = 0;
      v29.size_t length = 536;
      CFDataGetBytes(v5, v29, (UInt8 *)&Length + 2);
      int v6 = sub_10004C658(a1, (uint64_t)buf, 0x228u, 0, 0xFFFFFFFF);
      std::string::size_type v7 = off_1002BBD58;
      if (off_1002BBD58 == &_os_log_default)
      {
        os_log_t v8 = os_log_create("com.apple.isp", "general");
        long long v9 = off_1002BBD58;
        off_1002BBD58 = v8;

        std::string::size_type v7 = off_1002BBD58;
      }
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
      {
        int v19 = 136315394;
        std::string::size_type v20 = "savePeridotCalibToFW";
        __int16 v21 = 1024;
        int v22 = v6;
        _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "%s - updating firmware: %d\n", (uint8_t *)&v19, 0x12u);
      }
      CFRelease(v5);
      return v6 == 0;
    }
    size_t v15 = off_1002BBD58;
    if (off_1002BBD58 == &_os_log_default)
    {
      os_log_t v16 = os_log_create("com.apple.isp", "general");
      uint64_t v17 = off_1002BBD58;
      off_1002BBD58 = v16;

      size_t v15 = off_1002BBD58;
    }
    int64_t v18 = v15;
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 136315650;
      uint64_t v24 = "savePeridotCalibToFW";
      __int16 v25 = 2048;
      CFIndex Length = CFDataGetLength(v5);
      __int16 v27 = 2048;
      uint64_t v28 = 536;
      _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "%s - updating firmware: unexpected size: %ld != %lu\n", buf, 0x20u);
    }

    CFRelease(v5);
    return 0;
  }
  char v11 = off_1002BBD58;
  if (off_1002BBD58 == &_os_log_default)
  {
    os_log_t v12 = os_log_create("com.apple.isp", "general");
    os_log_t v13 = off_1002BBD58;
    off_1002BBD58 = v12;

    char v11 = off_1002BBD58;
  }
  BOOL v14 = os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT);
  BOOL result = 0;
  if (v14)
  {
    *(_DWORD *)long long buf = 136315138;
    uint64_t v24 = "savePeridotCalibToFW";
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "%s - updating firmware: bad input\n", buf, 0xCu);
    return 0;
  }
  return result;
}

void sub_1000700C4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void H16ISPRgbJRunner::H16ISPRgbJRunner(H16ISPRgbJRunner *this, void *a2, H16ISPDevice *a3)
{
  *((void *)this + 5) = 0;
  H16ISPRgbJRunner::init(this, a2, a3, 1);
}

void sub_10007010C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void H16ISPRgbJRunner::init(H16ISPRgbJRunner *this, void *a2, H16ISPDevice *a3, char a4)
{
  *(void *)this = a2;
  *((void *)this + 1) = a3;
  *((void *)this + 2) = 0;
  *((unsigned char *)this + 24) = 0;
  *((_DWORD *)this + 7) = -1;
  *((unsigned char *)this + 32) = a4;
  *((unsigned char *)this + 33) = 0;
  sub_10000A7C4((uint64_t)a3, 0);
  operator new();
}

void sub_1000701E0()
{
}

void H16ISPRgbJRunner::H16ISPRgbJRunner(H16ISPRgbJRunner *this, void *a2, H16ISPDevice *a3, const double *a4, const double *a5)
{
  *((void *)this + 5) = 0;
  os_log_t v10 = +[NSFileManager defaultManager];
  char v11 = +[NSString stringWithCString:"/var/mobile/Library/ISP/JasperL/JasperColorInterSessionData.plist" encoding:4];
  [v10 removeItemAtPath:v11 error:0];

  os_log_t v12 = +[NSFileManager defaultManager];
  os_log_t v13 = +[NSString stringWithCString:"/var/mobile/Library/ISP/JasperL/rgbj-wide.plist" encoding:4];
  [v12 removeItemAtPath:v13 error:0];

  BOOL v14 = sub_10000A7C4((uint64_t)a3, 0);
  PDPeridotCalibGetOperationalWideToPeridotTransform();
  v15.i32[3] = 0;
  v16.i32[3] = 0;
  v17.n128_u32[3] = 0;
  v18.n128_u32[3] = 0;
  uint64_t v24 = 0;
  memset(v23, 0, sizeof(v23));
  float64x2_t v21 = 0uLL;
  uint64_t v22 = 0;
  sub_100030B9C(v23, &v21, v15, v16, v17, v18);
  long long v19 = *(_OWORD *)a4;
  uint64_t v20 = *((void *)a4 + 2);
  if (*a5 != 0.0 || a5[1] != 0.0 || a5[2] != 0.0)
  {
    float64x2_t v21 = *(float64x2_t *)a5;
    uint64_t v22 = *((void *)a5 + 2);
  }
  sub_100005308((double *)&v19, (uint64_t)v23);
  sub_100030B34(v23);
  PDPeridotCalibSetOperationalWideToPeridotTransform();
  sub_100009B28(v14);
  H16ISPRgbJRunner::init(this, a2, a3, 0);
}

void sub_1000703D0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t H16ISPRgbJRunner::isRgbjDynamicFrameRate(H16ISPRgbJRunner *this)
{
  return *(unsigned __int8 *)(*((void *)this + 2) + 293);
}

void H16ISPRgbJRunner::~H16ISPRgbJRunner(H16ISPRgbJRunner *this)
{
  size_t v2 = *((void *)this + 5);
  if (v2)
  {
    dispatch_sync(v2, &stru_10009D8D0);
    double v3 = (void *)*((void *)this + 5);
    *((void *)this + 5) = 0;
  }
  uint64_t v4 = *((void *)this + 2);
  if (v4)
  {
    sub_100071E78(v4);
    operator delete();
  }
}

uint64_t H16ISPRgbJRunner::setVerbose(uint64_t this, char a2)
{
  *(unsigned char *)(this + 24) = a2;
  *(unsigned char *)(*(void *)(this + 16) + 292) = a2;
  return this;
}

uint64_t H16ISPRgbJRunner::setSensorVersion(uint64_t this, int a2)
{
  *(_DWORD *)(this + 28) = a2;
  return this;
}

void *H16ISPRgbJRunner::readDictionary(H16ISPRgbJRunner *this, const __CFString *a2)
{
  size_t v2 = +[NSDictionary dictionaryWithContentsOfFile:this];
  double v3 = v2;
  if (v2) {
    id v4 = v2;
  }

  return v3;
}

id H16ISPRgbJRunner::writeDictionary(H16ISPRgbJRunner *this, const __CFDictionary *a2, const __CFString *a3)
{
  sub_100070540(a2);

  return [(H16ISPRgbJRunner *)this writeToFile:a2 atomically:1];
}

void sub_100070540(void *a1)
{
  size_t v2 = +[NSFileManager defaultManager];
  double v3 = [a1 stringByDeletingLastPathComponent];
  unsigned __int8 v4 = [v2 fileExistsAtPath:v3];

  if ((v4 & 1) == 0)
  {
    CFDataRef v5 = +[NSFileManager defaultManager];
    int v6 = [a1 stringByDeletingLastPathComponent];
    uint64_t v7 = 0;
    [v5 createDirectoryAtPath:v6 withIntermediateDirectories:1 attributes:0 error:&v7];
  }
}

void sub_1000705FC(_Unwind_Exception *a1)
{
  unsigned __int8 v4 = v3;

  _Unwind_Resume(a1);
}

void *H16ISPRgbJRunner::readData(H16ISPRgbJRunner *this, const __CFString *a2)
{
  size_t v2 = +[NSData dataWithContentsOfFile:this];
  double v3 = v2;
  if (v2) {
    id v4 = v2;
  }

  return v3;
}

id H16ISPRgbJRunner::writeData(H16ISPRgbJRunner *this, const __CFData *a2, const __CFString *a3)
{
  sub_100070540(a2);

  return [(H16ISPRgbJRunner *)this writeToFile:a2 atomically:1];
}

uint64_t H16ISPRgbJRunner::runPipeline(uint64_t a1, __CVBuffer *a2, void *a3, void *a4, void *a5, void *a6, int a7, __int16 a8, int a9, int a10)
{
  if (*(unsigned char *)(a1 + 24))
  {
    __n128 v18 = off_1002BBD60;
    if (off_1002BBD60 == &_os_log_default)
    {
      os_log_t v19 = os_log_create("com.apple.isp", "general");
      uint64_t v20 = off_1002BBD60;
      off_1002BBD60 = v19;

      __n128 v18 = off_1002BBD60;
    }
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "RGBJ-Demon-Verbose: reached runPipeline\n", buf, 2u);
    }
  }
  uint64_t v21 = *(void *)(a1 + 16);
  if (v21)
  {
    if (*(unsigned char *)(a1 + 33))
    {
      return 3;
    }
    else if (a7)
    {
      unint64_t v26 = off_1002BBD60;
      if (off_1002BBD60 == &_os_log_default)
      {
        os_log_t v27 = os_log_create("com.apple.isp", "general");
        uint64_t v28 = off_1002BBD60;
        off_1002BBD60 = v27;

        unint64_t v26 = off_1002BBD60;
      }
      if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR)) {
        sub_1000724BC();
      }
      return 2;
    }
    else
    {
      uint64_t v22 = *(unsigned int *)(v21 + 280);
      if (!v22)
      {
        uint64_t v22 = 2;
        if (a3)
        {
          if (a2 && a4)
          {
            id v40 = a4;
            *(void *)long long buf = 0;
            double v52 = buf;
            uint64_t v53 = 0x3032000000;
            unsigned int v54 = sub_100070C5C;
            id v55 = sub_100070C6C;
            unint64_t v29 = 0;
            id v56 = objc_alloc_init((Class)NSMutableArray);
            while (1)
            {
              if (v29 >= (unint64_t)[v40 count])
              {
                id v33 = a5;
                id v34 = a6;
                v49[0] = 0;
                v49[1] = v49;
                v49[2] = 0x3032000000;
                v49[3] = sub_100070C5C;
                v49[4] = sub_100070C6C;
                id v50 = [objc_alloc((Class)ADCameraCalibration) initWithDictionary:v33];
                v47[0] = 0;
                v47[1] = v47;
                v47[2] = 0x3032000000;
                void v47[3] = sub_100070C5C;
                _OWORD v47[4] = sub_100070C6C;
                id v48 = [objc_alloc((Class)ADCameraCalibration) initWithDictionary:v34];
                v45[0] = 0;
                v45[1] = v45;
                v45[2] = 0x3032000000;
                void v45[3] = sub_100070C5C;
                v45[4] = sub_100070C6C;
                id v46 = a3;
                v44[0] = 0;
                v44[1] = v44;
                v44[2] = 0x2020000000;
                void v44[3] = a2;
                CVPixelBufferRetain(a2);
                unsigned int v35 = *(NSObject **)(a1 + 40);
                block[0] = _NSConcreteStackBlock;
                block[1] = 3221225472;
                block[2] = sub_100070C74;
                block[3] = &unk_10009D8F8;
                int v42 = a10;
                block[4] = v44;
                void block[5] = v45;
                void block[6] = buf;
                void block[7] = v49;
                block[8] = v47;
                block[9] = a1;
                __int16 v43 = a8;
                dispatch_async(v35, block);
                _Block_object_dispose(v44, 8);
                _Block_object_dispose(v45, 8);

                _Block_object_dispose(v47, 8);
                _Block_object_dispose(v49, 8);

                uint64_t v22 = 0;
                goto LABEL_34;
              }
              id v30 = objc_alloc((Class)ADJasperPointCloud);
              int v31 = [v40 objectAtIndexedSubscript:v29];
              id v32 = [v30 initWithDictionaryRepresentation:v31];

              if (!v32) {
                break;
              }
              [*((id *)v52 + 5) addObject:v32];

              ++v29;
            }
            uint64_t v36 = off_1002BBD60;
            if (off_1002BBD60 == &_os_log_default)
            {
              os_log_t v37 = os_log_create("com.apple.isp", "general");
              unsigned int v38 = off_1002BBD60;
              off_1002BBD60 = v37;

              uint64_t v36 = off_1002BBD60;
            }
            if (os_log_type_enabled(v36, OS_LOG_TYPE_ERROR)) {
              sub_100072488();
            }
            uint64_t v22 = 2;
LABEL_34:
            _Block_object_dispose(buf, 8);
          }
        }
      }
    }
  }
  else
  {
    BOOL v23 = off_1002BBD60;
    if (off_1002BBD60 == &_os_log_default)
    {
      os_log_t v24 = os_log_create("com.apple.isp", "general");
      __int16 v25 = off_1002BBD60;
      off_1002BBD60 = v24;

      BOOL v23 = off_1002BBD60;
    }
    if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR)) {
      sub_100072454();
    }
    return 1;
  }
  return v22;
}

void sub_100070BA8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,char a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,id a32,char a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,id a38)
{
  _Block_object_dispose(&a23, 8);
  _Block_object_dispose(&a27, 8);

  _Block_object_dispose(&a33, 8);
  _Block_object_dispose((const void *)(v40 - 208), 8);

  _Block_object_dispose((const void *)(v40 - 160), 8);
  _Unwind_Resume(a1);
}

uint64_t sub_100070C5C(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void sub_100070C6C(uint64_t a1)
{
}

void sub_100070C74(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 72);
  *(unsigned char *)(v2 + 33) = 1;
  uint64_t v3 = *(void *)(v2 + 16);
  if (!*(void *)(v3 + 328))
  {
    if (sub_1000710F8(v3, *(_DWORD *)(a1 + 80)))
    {
      __n128 v17 = off_1002BBD60;
      if (off_1002BBD60 == &_os_log_default)
      {
        os_log_t v18 = os_log_create("com.apple.isp", "general");
        os_log_t v19 = off_1002BBD60;
        off_1002BBD60 = v18;

        __n128 v17 = off_1002BBD60;
      }
      if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR)) {
        sub_1000725C4();
      }
      *(_DWORD *)(*(void *)(v2 + 16) + 280) = 1;
      goto LABEL_47;
    }
    uint64_t v3 = *(void *)(v2 + 16);
  }
  uint64_t v4 = sub_1000713EC(v3, *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24), *(void **)(*(void *)(*(void *)(a1 + 40) + 8) + 40), *(void **)(*(void *)(*(void *)(a1 + 48) + 8) + 40), *(void **)(*(void *)(*(void *)(a1 + 56) + 8) + 40), *(void **)(*(void *)(*(void *)(a1 + 64) + 8) + 40));
  if (!v4)
  {
    if (*(unsigned char *)(v2 + 24))
    {
      uint64_t v20 = off_1002BBD60;
      if (off_1002BBD60 == &_os_log_default)
      {
        os_log_t v21 = os_log_create("com.apple.isp", "general");
        uint64_t v22 = off_1002BBD60;
        off_1002BBD60 = v21;

        uint64_t v20 = off_1002BBD60;
      }
      if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "RGBJ-Demon-Verbose: PreProcessInputColorFrame done\n", buf, 2u);
      }
    }
    CVPixelBufferLockBaseAddress(*(CVPixelBufferRef *)(*(void *)(*(void *)(a1 + 32) + 8) + 24), 1uLL);
    size_t BytesPerRowOfPlane = CVPixelBufferGetBytesPerRowOfPlane(*(CVPixelBufferRef *)(*(void *)(*(void *)(a1 + 32) + 8) + 24), 0);
    unint64_t v24 = (unint64_t)fmin((double)(CVPixelBufferGetHeightOfPlane(*(CVPixelBufferRef *)(*(void *)(*(void *)(a1 + 32) + 8) + 24), 0)* BytesPerRowOfPlane), 1000000.0);
    BaseAddressOfPlane = CVPixelBufferGetBaseAddressOfPlane(*(CVPixelBufferRef *)(*(void *)(*(void *)(a1 + 32) + 8) + 24), 0);
    unsigned int v26 = (unsigned __int16)v24;
    if ((_WORD)v24)
    {
      unsigned int v27 = 0;
      int v28 = 0xFFFF;
      do
      {
        unsigned int v29 = 128;
        do
        {
          if ((v29 & *BaseAddressOfPlane) != 0) {
            __int16 v30 = ~(_WORD)v28;
          }
          else {
            __int16 v30 = v28;
          }
          if (v30 < 0) {
            int v28 = (2 * v28) ^ 0x1021;
          }
          else {
            v28 *= 2;
          }
          BOOL v31 = v29 >= 2;
          v29 >>= 1;
        }
        while (v31);
        ++BaseAddressOfPlane;
        ++v27;
      }
      while (v27 < v26);
    }
    else
    {
      LOWORD(v28) = -1;
    }
    CVPixelBufferUnlockBaseAddress(*(CVPixelBufferRef *)(*(void *)(*(void *)(a1 + 32) + 8) + 24), 1uLL);
    CVPixelBufferRelease(*(CVPixelBufferRef *)(*(void *)(*(void *)(a1 + 32) + 8) + 24));
    *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = 0;
    if (*(unsigned __int16 *)(a1 + 84) == (unsigned __int16)v28)
    {
      if (!sub_100071730(*(void *)(v2 + 16), v2 + 48))
      {
        int v38 = *(unsigned __int8 *)(v2 + 24);
        if (*(unsigned char *)(v2 + 24))
        {
          int v39 = off_1002BBD60;
          if (off_1002BBD60 == &_os_log_default)
          {
            os_log_t v40 = os_log_create("com.apple.isp", "general");
            uint64_t v41 = off_1002BBD60;
            off_1002BBD60 = v40;

            int v39 = off_1002BBD60;
          }
          BOOL v42 = os_log_type_enabled(v39, OS_LOG_TYPE_DEFAULT);
          int v38 = 0;
          if (v42)
          {
            *(_WORD *)__int16 v43 = 0;
            _os_log_impl((void *)&_mh_execute_header, v39, OS_LOG_TYPE_DEFAULT, "RGBJ-Demon-Verbose: execution success\n", v43, 2u);
            int v38 = 0;
          }
        }
        goto LABEL_46;
      }
      id v32 = off_1002BBD60;
      if (off_1002BBD60 == &_os_log_default)
      {
        os_log_t v33 = os_log_create("com.apple.isp", "general");
        id v34 = off_1002BBD60;
        off_1002BBD60 = v33;

        id v32 = off_1002BBD60;
      }
      if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR)) {
        sub_10007255C();
      }
    }
    else
    {
      unsigned int v35 = off_1002BBD60;
      if (off_1002BBD60 == &_os_log_default)
      {
        os_log_t v36 = os_log_create("com.apple.isp", "general");
        os_log_t v37 = off_1002BBD60;
        off_1002BBD60 = v36;

        unsigned int v35 = off_1002BBD60;
      }
      if (os_log_type_enabled(v35, OS_LOG_TYPE_ERROR)) {
        sub_100072590();
      }
    }
    int v38 = 2;
LABEL_46:
    *(_DWORD *)(*(void *)(v2 + 16) + 280) = v38;
LABEL_47:
    *(unsigned char *)(v2 + 33) = 0;
    return;
  }
  uint64_t v5 = v4;
  if (v4 == -22966)
  {
    H16ISPRgbJRunner::saveNow((H16ISPRgbJRunner *)v2);
    uint64_t v6 = *(void *)(v2 + 16);
    uint64_t v7 = *(void **)(v6 + 328);
    *(void *)(v6 + 328) = 0;
  }
  os_log_t v8 = off_1002BBD60;
  if (off_1002BBD60 == &_os_log_default)
  {
    os_log_t v9 = os_log_create("com.apple.isp", "general");
    os_log_t v10 = off_1002BBD60;
    off_1002BBD60 = v9;

    os_log_t v8 = off_1002BBD60;
  }
  if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR)) {
    sub_1000724F0(v5, v8, v11, v12, v13, v14, v15, v16);
  }
  *(_DWORD *)(*(void *)(v2 + 16) + 280) = 0;
  *(unsigned char *)(v2 + 33) = 0;
  CVPixelBufferRelease(*(CVPixelBufferRef *)(*(void *)(*(void *)(a1 + 32) + 8) + 24));
}

uint64_t sub_1000710F8(uint64_t a1, int a2)
{
  *(_DWORD *)(a1 + 336) = a2;
  *(void *)(a1 + 344) = 0;
  *(void *)(a1 + 264) = 0;
  *(_DWORD *)(a1 + 276) = 0;
  *(void *)(a1 + 312) = 4;
  id v3 = [objc_alloc((Class)ADJasperColorInFieldCalibrationExecutor) initForEngineType:*(void *)(a1 + 312)];
  uint64_t v4 = *(void **)(a1 + 328);
  *(void *)(a1 + 328) = v3;

  uint64_t v5 = *(unsigned int *)(a1 + 336);
  uint64_t v6 = [*(id *)(a1 + 328) pipeline];
  uint64_t v7 = [v6 pipelineParameters];
  [v7 setFeaturesVectorAggregationSize:v5];

  uint64_t v8 = objc_opt_new();
  os_log_t v9 = *(void **)(a1 + 296);
  *(void *)(a1 + 296) = v8;

  if (!*(void *)(a1 + 296))
  {
    __n128 v17 = off_1002BBD60;
    if (off_1002BBD60 == &_os_log_default)
    {
      os_log_t v18 = os_log_create("com.apple.isp", "general");
      os_log_t v19 = off_1002BBD60;
      off_1002BBD60 = v18;

      __n128 v17 = off_1002BBD60;
    }
    if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR)) {
      sub_1000725F8();
    }
    return -22950;
  }
  os_log_t v10 = *(void **)(a1 + 328);
  if (!v10)
  {
    uint64_t v20 = off_1002BBD60;
    if (off_1002BBD60 == &_os_log_default)
    {
      os_log_t v21 = os_log_create("com.apple.isp", "general");
      uint64_t v22 = off_1002BBD60;
      off_1002BBD60 = v21;

      uint64_t v20 = off_1002BBD60;
    }
    if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR)) {
      sub_10007262C();
    }
    return -22950;
  }
  if (*(unsigned char *)(a1 + 292))
  {
    uint64_t v11 = off_1002BBD60;
    if (off_1002BBD60 == &_os_log_default)
    {
      os_log_t v12 = os_log_create("com.apple.isp", "general");
      uint64_t v13 = off_1002BBD60;
      off_1002BBD60 = v12;

      uint64_t v11 = off_1002BBD60;
    }
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "RGBJ-Demon-Verbose: executore prepare\n", buf, 2u);
    }
    os_log_t v10 = *(void **)(a1 + 328);
  }
  if ([v10 prepare])
  {
    uint64_t v14 = off_1002BBD60;
    if (off_1002BBD60 == &_os_log_default)
    {
      os_log_t v15 = os_log_create("com.apple.isp", "general");
      uint64_t v16 = off_1002BBD60;
      off_1002BBD60 = v15;

      uint64_t v14 = off_1002BBD60;
    }
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR)) {
      sub_100072660();
    }
    return -22950;
  }
  if (!sub_100071EC8(a1) || !sub_10007212C(a1)) {
    return -22950;
  }
  if (*(unsigned char *)(a1 + 292))
  {
    BOOL v23 = off_1002BBD60;
    if (off_1002BBD60 == &_os_log_default)
    {
      os_log_t v24 = os_log_create("com.apple.isp", "general");
      __int16 v25 = off_1002BBD60;
      off_1002BBD60 = v24;

      BOOL v23 = off_1002BBD60;
    }
    if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)unsigned int v27 = 0;
      _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "RGBJ-Demon-Verbose: loaded intersession data\n", v27, 2u);
    }
  }
  return 0;
}

void sub_1000713D0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t sub_1000713EC(uint64_t a1, uint64_t a2, void *a3, void *a4, void *a5, void *a6)
{
  id v11 = a3;
  id v12 = a4;
  id v13 = a5;
  id v14 = a6;
  if (*(unsigned char *)(a1 + 292))
  {
    os_log_t v15 = off_1002BBD60;
    if (off_1002BBD60 == &_os_log_default)
    {
      os_log_t v16 = os_log_create("com.apple.isp", "general");
      __n128 v17 = off_1002BBD60;
      off_1002BBD60 = v16;

      os_log_t v15 = off_1002BBD60;
    }
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v25[0]) = 0;
      _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "RGBJ-Demon-Verbose: reached PreProcess\n", (uint8_t *)v25, 2u);
    }
  }
  os_log_t v18 = *(void **)(a1 + 328);
  if (v18)
  {
    simd_float4 v19 = matrix_identity_float4x4.columns[1];
    v25[0] = matrix_identity_float4x4.columns[0];
    v25[1] = v19;
    long long v28 = v25[0];
    simd_float4 v29 = v19;
    long long v32 = v25[0];
    simd_float4 v33 = v19;
    long long v36 = v25[0];
    simd_float4 v37 = v19;
    simd_float4 v20 = matrix_identity_float4x4.columns[3];
    simd_float4 v21 = matrix_identity_float4x4.columns[0];
    simd_float4 v22 = matrix_identity_float4x4.columns[1];
    simd_float4 v26 = matrix_identity_float4x4.columns[2];
    simd_float4 v27 = v20;
    simd_float4 v30 = v26;
    simd_float4 v31 = v20;
    simd_float4 v34 = v26;
    simd_float4 v35 = v20;
    simd_float4 v38 = v26;
    simd_float4 v39 = v20;
    uint64_t v23 = (uint64_t)[v18 preprocessInputColorFrame:a2 colorPose:v12 jasperPointClouds:v25 jasperPoses:v14 jasperCameraCalibration:v13 colorCameraCalibration:v11 colorMetadata:*(double *)v21.i64 *(double *)v22.i64 *(double *)v26.i64 *(double *)matrix_identity_float4x4.columns[3].i64];
  }
  else
  {
    uint64_t v23 = -22970;
  }

  return v23;
}

void sub_10007158C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void H16ISPRgbJRunner::saveNow(H16ISPRgbJRunner *this)
{
  if (*(void *)(*((void *)this + 2) + 344))
  {
    uint64_t v2 = sub_10000A7C4(*((void *)this + 1), 0);
    PDPeridotCalibSetOperationalWideToPeridotTransform();
    if (sub_100009B28(v2))
    {
      id v3 = off_1002BBD60;
      if (off_1002BBD60 == &_os_log_default)
      {
        os_log_t v4 = os_log_create("com.apple.isp", "general");
        uint64_t v5 = off_1002BBD60;
        off_1002BBD60 = v4;

        id v3 = off_1002BBD60;
      }
      if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)os_log_t v9 = 0;
        _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "rgbj calibration: saved peridotCalib\n", v9, 2u);
      }
    }
    else
    {
      *(_DWORD *)(*((void *)this + 2) + 276) = 1;
      uint64_t v6 = off_1002BBD60;
      if (off_1002BBD60 == &_os_log_default)
      {
        os_log_t v7 = os_log_create("com.apple.isp", "general");
        uint64_t v8 = off_1002BBD60;
        off_1002BBD60 = v7;

        uint64_t v6 = off_1002BBD60;
      }
      if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR)) {
        sub_100072694();
      }
    }
    CFRelease(v2);
  }
}

uint64_t sub_100071730(uint64_t a1, uint64_t a2)
{
  ++*(_DWORD *)(a1 + 272);
  id v3 = *(void **)(a1 + 328);
  if (!v3) {
    return -22970;
  }
  id v5 = [v3 executePreprocessedInputsWithInterSessionData:*(void *)(a1 + 320) outResult:*(void *)(a1 + 296)];
  if (v5)
  {
    uint64_t v6 = (uint64_t)v5;
    os_log_t v7 = off_1002BBD60;
    if (off_1002BBD60 == &_os_log_default)
    {
      os_log_t v8 = os_log_create("com.apple.isp", "general");
      os_log_t v9 = off_1002BBD60;
      off_1002BBD60 = v8;

      os_log_t v7 = off_1002BBD60;
    }
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR)) {
      sub_100072738(v6, v7, v10, v11, v12, v13, v14, v15);
    }
  }
  else
  {
    unsigned int v16 = [*(id *)(a1 + 296) executed];
    __n128 v17 = *(void **)(a1 + 296);
    if (v16)
    {
      [v17 jasperToColorExtrinsics];
      *(_DWORD *)(a1 + 360) = v18;
      *(void *)(a1 + 352) = v19;
      *(_DWORD *)(a1 + 376) = v20;
      *(_DWORD *)(a1 + 392) = v21;
      *(void *)(a1 + 368) = v22;
      *(void *)(a1 + 384) = v23;
      *(_DWORD *)(a1 + 408) = v24;
      *(void *)(a1 + 400) = v25;
      ++*(void *)(a1 + 344);
      ++*(_DWORD *)(a1 + 264);
      if (a2 && *(unsigned char *)a2)
      {
        ++*(_DWORD *)(a2 + 4);
        [*(id *)(a1 + 296) deltaRotationX];
        *(double *)(a2 + 8) = *(double *)(a2 + 8) + v26;
        [*(id *)(a1 + 296) deltaRotationY];
        *(double *)(a2 + 16) = *(double *)(a2 + 16) + v27;
        [*(id *)(a1 + 296) deltaRotationZ];
        *(double *)(a2 + 24) = *(double *)(a2 + 24) + v28;
      }
    }
    else if ([v17 executionStatus] == (id)-22976)
    {
      ++*(_DWORD *)(a1 + 268);
      simd_float4 v29 = off_1002BBD60;
      if (off_1002BBD60 == &_os_log_default)
      {
        os_log_t v30 = os_log_create("com.apple.isp", "general");
        simd_float4 v31 = off_1002BBD60;
        off_1002BBD60 = v30;

        simd_float4 v29 = off_1002BBD60;
      }
      if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR)) {
        sub_1000726C8(a1 + 268, v29, v32, v33, v34, v35, v36, v37);
      }
    }
    sub_10007212C(a1);
    return 0;
  }
  return v6;
}

void H16ISPRgbJRunner::finalize(H16ISPRgbJRunner *this)
{
  if (!*((unsigned char *)this + 33))
  {
    if (*((unsigned char *)this + 24))
    {
      uint64_t v2 = off_1002BBD60;
      if (off_1002BBD60 == &_os_log_default)
      {
        os_log_t v3 = os_log_create("com.apple.isp", "general");
        os_log_t v4 = off_1002BBD60;
        off_1002BBD60 = v3;

        uint64_t v2 = off_1002BBD60;
      }
      if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)id v5 = 0;
        _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "RGBJ-Demon-Verbose: finalizing\n", v5, 2u);
      }
    }
    H16ISPRgbJRunner::saveNow(this);
  }
}

uint64_t H16ISPRgbJRunner::fillReport(uint64_t this, int *a2, int *a3, int *a4, int *a5)
{
  id v5 = *(_DWORD **)(this + 16);
  if (v5)
  {
    *a2 = v5[66];
    *a3 = v5[67];
    int v6 = v5[69];
  }
  else
  {
    int v6 = 0;
    *a4 = 0;
    *a3 = 0;
    *a2 = 0;
  }
  *a5 = v6;
  *a4 = v5[68];
  return this;
}

BOOL H16ISPRgbJRunner::isContext(H16ISPRgbJRunner *this, void *a2)
{
  return *(void *)this == (void)a2;
}

uint64_t H16ISPRgbJRunner::configureLowFrameIntervalMode(H16ISPRgbJRunner *this, char a2, unsigned int a3, unsigned int a4, unsigned int a5, unsigned int a6)
{
  if (a2)
  {
    if (*((unsigned char *)this + 48))
    {
      unsigned int v7 = *((_DWORD *)this + 13);
      if (v7 < a3) {
        return 1;
      }
      float v11 = *((double *)this + 7) / (double)v7;
      float v12 = fabsf(v11);
      float v13 = *((double *)this + 8) / (double)v7;
      float v14 = fabsf(v13);
      float v15 = *((double *)this + 9) / (double)v7;
      float v16 = fabsf(v15);
      if (*((unsigned char *)this + 24))
      {
        __n128 v17 = off_1002BBD60;
        if (off_1002BBD60 == &_os_log_default)
        {
          os_log_t v18 = os_log_create("com.apple.isp", "general");
          uint64_t v19 = off_1002BBD60;
          off_1002BBD60 = v18;

          __n128 v17 = off_1002BBD60;
        }
        if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
        {
          int v20 = *((_DWORD *)this + 13);
          int v34 = 134219520;
          double v35 = v12;
          __int16 v36 = 2048;
          double v37 = v14;
          __int16 v38 = 2048;
          double v39 = v16;
          __int16 v40 = 1024;
          unsigned int v41 = a4;
          __int16 v42 = 1024;
          unsigned int v43 = a5;
          __int16 v44 = 1024;
          unsigned int v45 = a6;
          __int16 v46 = 1024;
          int v47 = v20;
          _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "RGBJ-Demon-Verbose: configureLowFrameIntervalMode condX=%f, condY=%f, condZ=%f, X_th=%d, Y_th=%d, Z_th=%d, frames=%d\n", (uint8_t *)&v34, 0x38u);
        }
      }
      BOOL v21 = v12 <= (float)a4 && v14 <= (float)a5;
      if (!v21 || v16 > (float)a6) {
        return 1;
      }
      if (!*((unsigned char *)this + 24)) {
        return 0;
      }
      os_log_t v30 = off_1002BBD60;
      if (off_1002BBD60 == &_os_log_default)
      {
        os_log_t v31 = os_log_create("com.apple.isp", "general");
        uint64_t v32 = off_1002BBD60;
        off_1002BBD60 = v31;

        os_log_t v30 = off_1002BBD60;
      }
      BOOL v33 = os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT);
      uint64_t result = 0;
      if (v33)
      {
        LOWORD(v34) = 0;
        _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_DEFAULT, "RGBJ-Demon-Verbose: enough data, and no angle is above threhsold - done with low frame interval mode\n", (uint8_t *)&v34, 2u);
        return 0;
      }
    }
    else
    {
      if (*((unsigned char *)this + 24))
      {
        float v27 = off_1002BBD60;
        if (off_1002BBD60 == &_os_log_default)
        {
          os_log_t v28 = os_log_create("com.apple.isp", "general");
          simd_float4 v29 = off_1002BBD60;
          off_1002BBD60 = v28;

          float v27 = off_1002BBD60;
        }
        if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
        {
          LOWORD(v34) = 0;
          _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "RGBJ-Demon-Verbose: switched to low frame interval mode\n", (uint8_t *)&v34, 2u);
        }
      }
      uint64_t result = 1;
      *((unsigned char *)this + 48) = 1;
    }
  }
  else
  {
    if (*((unsigned char *)this + 24))
    {
      int v24 = off_1002BBD60;
      if (off_1002BBD60 == &_os_log_default)
      {
        os_log_t v25 = os_log_create("com.apple.isp", "general");
        float v26 = off_1002BBD60;
        off_1002BBD60 = v25;

        int v24 = off_1002BBD60;
      }
      if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(v34) = 0;
        _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "RGBJ-Demon-Verbose: low frame interval mode not active\n", (uint8_t *)&v34, 2u);
      }
    }
    uint64_t result = 0;
    *((unsigned char *)this + 48) = 0;
    *(void *)((char *)this + 52) = 0;
    *(void *)((char *)this + 68) = 0;
    *(void *)((char *)this + 60) = 0;
    *((_DWORD *)this + 19) = 0;
  }
  return result;
}

uint64_t sub_100071DA8(uint64_t a1, CFTypeRef cf)
{
  *(void *)(a1 + 256) = 0;
  *(void *)(a1 + 296) = 0;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 128) = 0u;
  *(void *)(a1 + 320) = 0;
  *(void *)(a1 + 328) = 0;
  *(void *)(a1 + 304) = CFRetain(cf);
  *(void *)(a1 + 344) = 0;
  os_log_t v3 = *(void **)(a1 + 328);
  *(void *)(a1 + 328) = 0;

  *(unsigned char *)(a1 + 240) = 0;
  *(_DWORD *)(a1 + 244) = 256;
  *(void *)(a1 + 272) = 0;
  *(void *)(a1 + 280) = 0;
  *(_DWORD *)(a1 + 336) = 10;
  *(void *)(a1 + 264) = 0;
  *(unsigned char *)(a1 + 293) = sub_100022CF0(@"rgbjDynamicFrameRate", @"com.apple.coremedia", 1) != 0;
  return a1;
}

void sub_100071E4C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t sub_100071E78(uint64_t a1)
{
  return a1;
}

BOOL sub_100071EC8(uint64_t a1)
{
  if (*(void *)(a1 + 320)) {
    return 1;
  }
  uint64_t v2 = +[NSDictionary dictionaryWithContentsOfFile:@"/var/mobile/Library/ISP/JasperL/JasperColorInterSessionData.plist"];
  os_log_t v3 = [*(id *)(a1 + 328) pipeline];
  uint64_t v4 = [v3 createInterSessionDataWithDictionaryRepresentation:v2];
  id v5 = *(void **)(a1 + 320);
  *(void *)(a1 + 320) = v4;

  if (!*(void *)(a1 + 320))
  {
    int v6 = off_1002BBD60;
    if (off_1002BBD60 == &_os_log_default)
    {
      os_log_t v7 = os_log_create("com.apple.isp", "general");
      os_log_t v8 = off_1002BBD60;
      off_1002BBD60 = v7;

      int v6 = off_1002BBD60;
    }
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "JasperColorInFieldCalibration could not initialize interSessionData from file, creating a new one\n", buf, 2u);
    }
    PDPeridotCalibGetOperationalWideToPeridotTransform();
    PDPeridotCalibGetFactoryWideToPeridotTransform();
    os_log_t v9 = [*(id *)(a1 + 328) pipeline];
    uint64_t v10 = [v9 createInterSessionDataWithFactoryJasperToColorTransform:currentJasperToColorTransform:];
    float v11 = *(void **)(a1 + 320);
    *(void *)(a1 + 320) = v10;
  }
  if (*(void *)(a1 + 320)) {
    return 1;
  }
  float v13 = off_1002BBD60;
  if (off_1002BBD60 == &_os_log_default)
  {
    os_log_t v14 = os_log_create("com.apple.isp", "general");
    float v15 = off_1002BBD60;
    off_1002BBD60 = v14;

    float v13 = off_1002BBD60;
  }
  BOOL result = os_log_type_enabled(v13, OS_LOG_TYPE_ERROR);
  if (result)
  {
    sub_1000727A4();
    return 0;
  }
  return result;
}

void sub_100072100(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id sub_10007212C(uint64_t a1)
{
  uint64_t v2 = [*(id *)(a1 + 320) persistenceData];
  os_log_t v3 = +[NSURL fileURLWithPath:@"/var/mobile/Library/ISP/JasperL/JasperColorInterSessionData.plist"];
  if (v3)
  {
    id v22 = 0;
    id v4 = [v2 writeToURL:v3 error:&v22];
    id v5 = v22;
    if (v4)
    {
      int v6 = off_1002BBD60;
      if (off_1002BBD60 == &_os_log_default)
      {
        os_log_t v7 = os_log_create("com.apple.isp", "general");
        os_log_t v8 = off_1002BBD60;
        off_1002BBD60 = v7;

        int v6 = off_1002BBD60;
      }
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)long long buf = 138412290;
        CFStringRef v24 = @"/var/mobile/Library/ISP/JasperL/JasperColorInterSessionData.plist";
        _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "Saving Intersession data to file has succeeded: %@\n", buf, 0xCu);
      }
    }
    else
    {
      *(_DWORD *)(a1 + 276) = 1;
      float v12 = off_1002BBD60;
      if (off_1002BBD60 == &_os_log_default)
      {
        os_log_t v13 = os_log_create("com.apple.isp", "general");
        os_log_t v14 = off_1002BBD60;
        off_1002BBD60 = v13;

        float v12 = off_1002BBD60;
      }
      float v15 = v12;
      if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
      {
        BOOL v21 = [v5 localizedDescription];
        id v17 = [v5 code];
        os_log_t v18 = [v5 domain];
        uint64_t v19 = [v5 userInfo];
        int v20 = [v19 descriptionInStringsFileFormat];
        *(_DWORD *)long long buf = 138413314;
        CFStringRef v24 = @"/var/mobile/Library/ISP/JasperL/JasperColorInterSessionData.plist";
        __int16 v25 = 2112;
        float v26 = v21;
        __int16 v27 = 2048;
        id v28 = v17;
        __int16 v29 = 2112;
        os_log_t v30 = v18;
        __int16 v31 = 2112;
        uint64_t v32 = v20;
        _os_log_error_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, "Jasper Calibration: Failed to save JPC intersession data using NSDictionary::writeToURL:withError.Path: %@ Error Description: %@ Error Code: %ldError Domain: %@Error UserInfo: %@\n", buf, 0x34u);
      }
    }
  }
  else
  {
    os_log_t v9 = off_1002BBD60;
    if (off_1002BBD60 == &_os_log_default)
    {
      os_log_t v10 = os_log_create("com.apple.isp", "general");
      float v11 = off_1002BBD60;
      off_1002BBD60 = v10;

      os_log_t v9 = off_1002BBD60;
    }
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR)) {
      sub_1000727D8(v9);
    }
    id v4 = 0;
  }

  return v4;
}

void sub_1000723F8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9)
{
  _Unwind_Resume(a1);
}

void sub_100072454()
{
  sub_10001AE74();
  sub_10001AE58((void *)&_mh_execute_header, v0, v1, "Jasper Calibration: nil runner detected\n", v2, v3, v4, v5, v6);
}

void sub_100072488()
{
  sub_10001AE74();
  sub_10001AE58((void *)&_mh_execute_header, v0, v1, "Jasper Calibration: failed to create adPoint cloud object as null object returned\n", v2, v3, v4, v5, v6);
}

void sub_1000724BC()
{
  sub_10001AE74();
  sub_10001AE58((void *)&_mh_execute_header, v0, v1, "Jasper Calibration: not a wide rgb type\n", v2, v3, v4, v5, v6);
}

void sub_1000724F0(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_10007255C()
{
  sub_10001AE74();
  sub_10001AE58((void *)&_mh_execute_header, v0, v1, "Jasper Calibration: failed\n", v2, v3, v4, v5, v6);
}

void sub_100072590()
{
  sub_10001AE74();
  sub_10001AE58((void *)&_mh_execute_header, v0, v1, "Jasper Calibration: crc mismatch\n", v2, v3, v4, v5, v6);
}

void sub_1000725C4()
{
  sub_10001AE74();
  sub_10001AE58((void *)&_mh_execute_header, v0, v1, "Jasper Calibration: failed to init executor\n", v2, v3, v4, v5, v6);
}

void sub_1000725F8()
{
  sub_10001AE74();
  sub_10001AE58((void *)&_mh_execute_header, v0, v1, "Jasper Calibration: algoExecutor results failed to initialized, nil returned\n", v2, v3, v4, v5, v6);
}

void sub_10007262C()
{
  sub_10001AE74();
  sub_10001AE58((void *)&_mh_execute_header, v0, v1, "Jasper Calibration: ad algoExecutor failed to initialized, nil returned\n", v2, v3, v4, v5, v6);
}

void sub_100072660()
{
  sub_10001AE74();
  sub_10001AE58((void *)&_mh_execute_header, v0, v1, "Jasper Calibration: failed to prepare rgbj algo executor\n", v2, v3, v4, v5, v6);
}

void sub_100072694()
{
  sub_10001AE74();
  sub_10001AE58((void *)&_mh_execute_header, v0, v1, "rgbj calibration: failed to save peridotCalib\n", v2, v3, v4, v5, v6);
}

void sub_1000726C8(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_100072738(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_1000727A4()
{
  sub_10001AE74();
  sub_10001AE58((void *)&_mh_execute_header, v0, v1, "Jasper Calibration: failed to create intersession data by any flow\n", v2, v3, v4, v5, v6);
}

void sub_1000727D8(os_log_t log)
{
  int v1 = 138412290;
  CFStringRef v2 = @"/var/mobile/Library/ISP/JasperL/JasperColorInterSessionData.plist";
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "Jasper Calibration: Failed to create Intersession data destination URL. Path = %@\n", (uint8_t *)&v1, 0xCu);
}

double DERImg4DecodeFindInSequence(unint64_t *a1, uint64_t a2, _OWORD *a3)
{
  unint64_t v7 = 0;
  long long v8 = 0uLL;
  while (!DERDecodeSeqNext(a1, &v7))
  {
    if (v7 == a2)
    {
      double result = *(double *)&v8;
      *a3 = v8;
      return result;
    }
  }
  return result;
}

uint64_t DERImg4DecodeTagCompare(uint64_t a1, unsigned int a2)
{
  unint64_t v2 = *(void *)(a1 + 8);
  if (v2 < 4) {
    return 0xFFFFFFFFLL;
  }
  if (v2 != 4) {
    return 1;
  }
  unsigned int v5 = 0;
  if (DERParseInteger((char **)a1, &v5)) {
    return 4294967294;
  }
  if (v5 < a2) {
    return 0xFFFFFFFFLL;
  }
  return v5 > a2;
}

uint64_t DERImg4DecodeManifest(void *a1, unint64_t a2)
{
  return sub_100072954(a1, 5uLL, (uint64_t)&DERImg4ManifestItemSpecs, a2, 0x494D344Du);
}

uint64_t sub_100072954(void *a1, unint64_t a2, uint64_t a3, unint64_t a4, unsigned int a5)
{
  uint64_t result = 6;
  if (a1 && a4)
  {
    if (!*a1 || !a1[1]) {
      return 0;
    }
    if (a2 >= 0x10000)
    {
      __break(0x5507u);
      return result;
    }
    uint64_t result = DERParseSequenceToObject((uint64_t)a1, (unsigned __int16)a2, a3, a4, 0xC0uLL, 0);
    if (!result)
    {
      if (DERImg4DecodeTagCompare(a4, a5)) {
        return 2;
      }
      unsigned int v9 = 0;
      uint64_t result = DERParseInteger((char **)(a4 + 16), &v9);
      if (result) {
        return result;
      }
      if (v9 > 2) {
        return 2;
      }
      return 0;
    }
  }
  return result;
}

uint64_t DERImg4DecodeUnsignedManifest(void *a1, unint64_t a2)
{
  return sub_100072954(a1, 3uLL, (uint64_t)&DERImg4UnsignedManifestItemSpecs, a2, 0x494D344Du);
}

uint64_t DERImg4DecodeCertificate(void *a1, unint64_t a2)
{
  return sub_100072954(a1, 4uLL, (uint64_t)&DERImg4CertificateItemSpecs, a2, 0x494D3443u);
}

uint64_t DERImg4DecodeUnsignedCertificate(void *a1, unint64_t a2)
{
  return sub_100072954(a1, 3uLL, (uint64_t)&DERImg4UnsignedManifestItemSpecs, a2, 0x494D3443u);
}

uint64_t DERImg4DecodePropertyWithItem(uint64_t a1, uint64_t a2, unint64_t a3, unint64_t a4)
{
  unsigned int v8 = 0;
  v9[0] = 0;
  v9[2] = 0;
  v9[1] = 22;
  v9[3] = 24;
  long long v10 = a3;
  uint64_t result = DERParseSequenceToObject(a1, 2u, (uint64_t)v9, a4, 0x30uLL, 0);
  if (!result)
  {
    uint64_t result = DERParseInteger((char **)a4, &v8);
    if (!result)
    {
      if ((v8 | 0xE000000000000000) == a2)
      {
        uint64_t result = 0;
        *(void *)(a4 + 16) = a2 | 0xE000000000000000;
        *(void *)(a4 + 40) = a3;
      }
      else
      {
        return 2;
      }
    }
  }
  return result;
}

void DERImg4DecodeFindPropertyInSequence(unint64_t *a1, uint64_t a2, unint64_t a3, unint64_t a4)
{
  long long v8 = 0uLL;
  DERImg4DecodeFindInSequence(a1, a2, &v8);
  if (!v7) {
    DERImg4DecodePropertyWithItem((uint64_t)&v8, a2, a3, a4);
  }
}

void DERImg4DecodeFindProperty(unint64_t *a1, uint64_t a2, unint64_t a3, unint64_t a4)
{
  v7[0] = 0;
  v7[1] = 0;
  if (!DERDecodeSeqContentInit(a1, v7)) {
    DERImg4DecodeFindPropertyInSequence(v7, a2, a3, a4);
  }
}

void DERImg4DecodeParseManifestProperties(uint64_t a1, unint64_t a2, unint64_t a3)
{
}

void sub_100072BF0(uint64_t a1, unint64_t a2, unint64_t a3, unsigned int a4)
{
  int v11 = 0;
  if (a1)
  {
    if (a2 | a3)
    {
      unint64_t v14 = 0;
      v15[0] = 0;
      v15[1] = 0;
      memset(v13, 0, sizeof(v13));
      memset(v12, 0, sizeof(v12));
      if (!DERDecodeItem(a1 + 264, &v14)
        && v14 == 0x2000000000000011
        && !DERParseInteger((char **)(a1 + 248), &v11))
      {
        unint64_t v8 = v11 == 2 ? 0x2000000000000010 : 0x2000000000000011;
        DERImg4DecodeFindProperty(v15, a4 | 0xE000000000000000, v8, (unint64_t)v13);
        if (!v9)
        {
          if (a2) {
            *(_OWORD *)a2 = *(_OWORD *)((char *)&v13[1] + 8);
          }
          DERImg4DecodeFindProperty((unint64_t *)&v13[1] + 1, 0xE00000004D414E50, 0x2000000000000011uLL, (unint64_t)v12);
          if (a3)
          {
            if (!v10) {
              *(_OWORD *)a3 = *(_OWORD *)((char *)&v12[1] + 8);
            }
          }
        }
      }
    }
  }
}

uint64_t Img4DecodeSectionExists(void *a1, unsigned int a2, char *a3)
{
  uint64_t v3 = 6;
  if (a2 <= 1 && a1 && a3)
  {
    if (a2 == 1)
    {
      if (!a1[55] || !a1[56]) {
        goto LABEL_11;
      }
    }
    else if (!a1[33] || !a1[34])
    {
LABEL_11:
      char v4 = 0;
      goto LABEL_12;
    }
    char v4 = 1;
LABEL_12:
    uint64_t v3 = 0;
    *a3 = v4;
  }
  return v3;
}

uint64_t Img4DecodeGetBooleanFromSection(uint64_t a1, unsigned int a2, uint64_t a3, BOOL *a4)
{
  memset(v8, 0, sizeof(v8));
  uint64_t v4 = 6;
  if (a1)
  {
    if (a4)
    {
      Img4DecodeGetPropertyFromSection(a1, a2, a3 | 0xE000000000000000, 1uLL, v8);
      uint64_t v4 = v6;
      if (!v6) {
        return DERParseBoolean((unsigned __int8 **)&v8[1] + 1, a4);
      }
    }
  }
  return v4;
}

double Img4DecodeGetPropertyFromSection(uint64_t a1, unsigned int a2, uint64_t a3, unint64_t a4, _OWORD *a5)
{
  *(_OWORD *)os_log_t v13 = 0uLL;
  if (a2 <= 1 && a1 && a5)
  {
    char v14 = 0;
    if (!Img4DecodeSectionExists((void *)a1, a2, &v14) && v14)
    {
      if (a2)
      {
        *(_OWORD *)os_log_t v13 = *(_OWORD *)(a1 + 440);
        goto LABEL_9;
      }
      DERImg4DecodeParseManifestProperties(a1, 0, (unint64_t)v13);
      if (!v10)
      {
LABEL_9:
        DERImg4DecodeFindProperty(v13, a3, a4, (unint64_t)a5);
        if (!v12) {
          return result;
        }
      }
    }
    double result = 0.0;
    a5[1] = 0u;
    a5[2] = 0u;
    *a5 = 0u;
  }
  return result;
}

uint64_t Img4DecodeInitManifest(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return sub_100072ED4(a1, a2, 1, a3, 1229796429);
}

uint64_t sub_100072ED4(uint64_t a1, uint64_t a2, int a3, uint64_t a4, int a5)
{
  uint64_t result = 6;
  if (a1 && a4)
  {
    uint64_t v15 = a1;
    uint64_t v16 = a2;
    *(_OWORD *)a4 = 0u;
    *(_OWORD *)(a4 + 16) = 0u;
    *(_OWORD *)(a4 + 32) = 0u;
    *(_OWORD *)(a4 + 48) = 0u;
    *(_OWORD *)(a4 + 64) = 0u;
    *(_OWORD *)(a4 + 80) = 0u;
    *(_OWORD *)(a4 + 96) = 0u;
    *(_OWORD *)(a4 + 112) = 0u;
    *(_OWORD *)(a4 + 128) = 0u;
    *(_OWORD *)(a4 + 144) = 0u;
    *(_OWORD *)(a4 + 160) = 0u;
    *(_OWORD *)(a4 + 176) = 0u;
    *(_OWORD *)(a4 + 192) = 0u;
    *(_OWORD *)(a4 + 208) = 0u;
    *(_OWORD *)(a4 + 224) = 0u;
    *(_OWORD *)(a4 + 240) = 0u;
    *(_OWORD *)(a4 + 256) = 0u;
    *(_OWORD *)(a4 + 272) = 0u;
    *(_OWORD *)(a4 + 288) = 0u;
    *(_OWORD *)(a4 + 304) = 0u;
    *(_OWORD *)(a4 + 320) = 0u;
    *(_OWORD *)(a4 + 336) = 0u;
    *(_OWORD *)(a4 + 352) = 0u;
    *(_OWORD *)(a4 + 368) = 0u;
    *(_OWORD *)(a4 + 384) = 0u;
    *(_OWORD *)(a4 + 400) = 0u;
    *(_OWORD *)(a4 + 416) = 0u;
    *(_OWORD *)(a4 + 432) = 0u;
    *(void *)(a4 + 448) = 0;
    if (a5 == 1229796419)
    {
      unint64_t v10 = a4 + 232;
      if (a3) {
        uint64_t result = DERImg4DecodeCertificate(&v15, v10);
      }
      else {
        uint64_t result = DERImg4DecodeUnsignedCertificate(&v15, v10);
      }
    }
    else
    {
      if (a5 != 1229796429) {
        return 2;
      }
      unint64_t v9 = a4 + 232;
      if (a3) {
        uint64_t result = DERImg4DecodeManifest(&v15, v9);
      }
      else {
        uint64_t result = DERImg4DecodeUnsignedManifest(&v15, v9);
      }
    }
    if (!result)
    {
      if (*(void *)(a4 + 264))
      {
        unint64_t v12 = 0;
        uint64_t v13 = 0;
        uint64_t v14 = 0;
        uint64_t v15 = a1;
        uint64_t v16 = a2;
        uint64_t result = DERDecodeItemPartialBufferGetLength((uint64_t)&v15, &v12, 0);
        if (!result)
        {
          *(void *)(a4 + 24) = a1;
          uint64_t v11 = v14 + v13 - a1;
          if (__CFADD__(v14, v13 - a1))
          {
            __break(0x5500u);
          }
          else
          {
            *(void *)(a4 + 32) = v11;
            if (v11 == a2) {
              return 0;
            }
            else {
              return 7;
            }
          }
        }
      }
      else
      {
        return 3;
      }
    }
  }
  return result;
}

uint64_t DERDecodeItem(uint64_t a1, unint64_t *a2)
{
  return DERDecodeItemPartialBufferGetLength(a1, a2, 0);
}

uint64_t DERDecodeItemPartialBufferGetLength(uint64_t result, unint64_t *a2, unint64_t *a3)
{
  unint64_t v3 = *(void *)(result + 8);
  if (v3 < 2) {
    return 3;
  }
  uint64_t v4 = *(unsigned char **)result;
  if (*(void *)result == -1) {
    goto LABEL_68;
  }
  unsigned int v5 = &v4[v3];
  uint64_t v6 = v4 + 1;
  unint64_t v7 = v3 - 1;
  unint64_t v8 = *v4 & 0x1F;
  if ((*v4 & 0x1F) != 0x1F)
  {
    unint64_t v12 = v4 + 1;
LABEL_20:
    *a2 = v8 | ((unint64_t)(*v4 & 0xE0) << 56);
    if (v12 != (char *)-1)
    {
      if (v12 >= v5 || v12 < v4) {
        goto LABEL_69;
      }
      uint64_t v14 = v12 + 1;
      unint64_t v15 = *v12;
      unint64_t v16 = v7 - 1;
      if ((*v12 & 0x80000000) == 0)
      {
        if (a3 || v16 >= v15)
        {
          if (v16 >= v15) {
            unint64_t v17 = *v12;
          }
          else {
            unint64_t v17 = v7 - 1;
          }
          BOOL v10 = v5 >= v14;
          unint64_t v18 = v5 - v14;
          if (v10 && v4 <= v14 && v17 <= v18)
          {
            a2[1] = (unint64_t)v14;
            a2[2] = v17;
            if (!a3) {
              return 0;
            }
LABEL_34:
            uint64_t result = 0;
            *a3 = v15;
            return result;
          }
LABEL_69:
          __break(0x5519u);
LABEL_70:
          __break(0x5515u);
          return result;
        }
        return 3;
      }
      unint64_t v19 = v15 & 0x7F;
      if ((v15 & 0x7F) > 8) {
        return 3;
      }
      if ((v15 & 0x7F) == 0 || v16 < v19) {
        return 3;
      }
      if (v14 >= v5 || v14 < v4) {
        goto LABEL_69;
      }
      if (!*v14) {
        return 3;
      }
      unint64_t v15 = 0;
      uint64_t v21 = (v19 - 1);
      unint64_t v22 = v7 - v21 - 2;
      unint64_t v23 = (unint64_t)&v12[v21 + 2];
      while (v14 != (unsigned char *)-1)
      {
        if (v14 >= v5) {
          goto LABEL_69;
        }
        BOOL v10 = v16-- != 0;
        if (!v10) {
          goto LABEL_70;
        }
        unsigned int v24 = *v14++;
        unint64_t v15 = (v15 << 8) | v24;
        LODWORD(v19) = v19 - 1;
        if (!v19)
        {
          if (a3) {
            BOOL v25 = 0;
          }
          else {
            BOOL v25 = v15 > v22;
          }
          char v26 = v25;
          uint64_t result = 3;
          if (v15 < 0x80 || (v26 & 1) != 0) {
            return result;
          }
          if (v15 >= v22) {
            unint64_t v27 = v22;
          }
          else {
            unint64_t v27 = v15;
          }
          BOOL v10 = (unint64_t)v5 >= v23;
          id v28 = &v5[-v23];
          if (!v10 || (unint64_t)v4 > v23 || v27 > (unint64_t)v28) {
            goto LABEL_69;
          }
          a2[1] = v23;
          a2[2] = v27;
          if (a3) {
            goto LABEL_34;
          }
          return 0;
        }
      }
    }
LABEL_68:
    __break(0x5513u);
    goto LABEL_69;
  }
  unsigned int v9 = *v6;
  BOOL v10 = v9 != 128 && v9 >= 0x1F;
  if (!v10) {
    return 3;
  }
  unint64_t v8 = 0;
  uint64_t result = 3;
  while (v7 >= 2)
  {
    unint64_t v11 = v8;
    if (v8 >> 57) {
      break;
    }
    if (v6 == (unsigned __int8 *)-1) {
      goto LABEL_68;
    }
    if (v6 >= v5 || v6 < v4) {
      goto LABEL_69;
    }
    unint64_t v12 = (char *)(v6 + 1);
    --v7;
    unsigned __int8 v13 = *v6;
    unint64_t v8 = *v6++ & 0x7F | (v8 << 7);
    if ((v13 & 0x80) == 0)
    {
      if (v11 >> 54) {
        return 3;
      }
      goto LABEL_20;
    }
  }
  return result;
}

uint64_t DERParseBoolean(unsigned __int8 **a1, BOOL *a2)
{
  if (a1[1] != (unsigned __int8 *)1) {
    return 3;
  }
  int v2 = **a1;
  if (v2 != 255 && v2 != 0) {
    return 3;
  }
  uint64_t result = 0;
  *a2 = v2 != 0;
  return result;
}

uint64_t DERParseInteger(char **a1, _DWORD *a2)
{
  unint64_t v4 = 0xAAAAAAAAAAAAAAAALL;
  uint64_t result = DERParseInteger64(a1, &v4);
  if (!result)
  {
    if (HIDWORD(v4))
    {
      return 7;
    }
    else
    {
      uint64_t result = 0;
      *a2 = v4;
    }
  }
  return result;
}

uint64_t DERParseInteger64(char **a1, unint64_t *a2)
{
  unint64_t v2 = (unint64_t)a1[1];
  if (!v2) {
    return 3;
  }
  unint64_t v3 = (unsigned __int8 *)*a1;
  if (**a1 < 0) {
    return 3;
  }
  if (**a1)
  {
    if (v2 > 8) {
      return 7;
    }
    goto LABEL_10;
  }
  if (v2 >= 2)
  {
    if (((char)v3[1] & 0x80000000) == 0) {
      return 3;
    }
    if (v2 > 9) {
      return 7;
    }
  }
LABEL_10:
  unint64_t v5 = 0;
  do
  {
    unsigned int v6 = *v3++;
    unint64_t v5 = v6 | (v5 << 8);
    --v2;
  }
  while (v2);
  uint64_t result = 0;
  *a2 = v5;
  return result;
}

unint64_t *DERDecodeSeqContentInit(unint64_t *result, unint64_t *a2)
{
  unint64_t v2 = *result;
  unint64_t v3 = result[1];
  if (__CFADD__(*result, v3))
  {
    __break(0x5513u);
  }
  else
  {
    unint64_t v4 = v2 + v3;
    if (v2 <= v4)
    {
      *a2 = v2;
      a2[1] = v4;
      return 0;
    }
  }
  __break(0x5519u);
  return result;
}

uint64_t DERDecodeSeqNext(unint64_t *a1, unint64_t *a2)
{
  v10[0] = 0;
  unint64_t v2 = *a1;
  unint64_t v3 = a1[1];
  if (*a1 >= v3) {
    return 1;
  }
  v10[0] = *a1;
  v10[1] = v3 - v2;
  uint64_t result = DERDecodeItemPartialBufferGetLength((uint64_t)v10, a2, 0);
  if (!result)
  {
    unint64_t v8 = a2[1];
    unint64_t v7 = a2[2];
    if (!__CFADD__(v8, v7))
    {
      unint64_t v9 = v8 + v7;
      if (v9 <= a1[1] && *a1 <= v9)
      {
        uint64_t result = 0;
        *a1 = v9;
        return result;
      }
      __break(0x5519u);
    }
    __break(0x5513u);
  }
  return result;
}

uint64_t DERParseSequenceToObject(uint64_t a1, unsigned int a2, uint64_t a3, unint64_t a4, unint64_t a5, size_t a6)
{
  memset(v12, 170, sizeof(v12));
  uint64_t result = DERDecodeItemPartialBufferGetLength(a1, v12, 0);
  if (!result)
  {
    if (v12[0] == 0x2000000000000010) {
      return DERParseSequenceContentToObject(&v12[1], a2, a3, a4, a5, a6);
    }
    else {
      return 2;
    }
  }
  return result;
}

uint64_t DERParseSequenceContentToObject(unint64_t *a1, unsigned int a2, uint64_t a3, unint64_t a4, unint64_t a5, size_t a6)
{
  unint64_t v32 = 0;
  if (a6)
  {
    if (a6 > a5) {
      goto LABEL_59;
    }
    bzero((void *)a4, a6);
  }
  unint64_t v10 = *a1;
  unint64_t v11 = a1[1];
  if (__CFADD__(*a1, v11)) {
    goto LABEL_58;
  }
  unint64_t v12 = v10 + v11;
  if (v10 > v12) {
LABEL_59:
  }
    __break(0x5519u);
  unint64_t v32 = *a1;
  unint64_t v33 = v12;
  if (a2)
  {
    unsigned __int16 v13 = 0;
    __int16 v29 = (char *)(a4 + a5);
    while (1)
    {
      memset(v31, 170, sizeof(v31));
      unint64_t v15 = v32;
      unint64_t v14 = v33;
      uint64_t result = DERDecodeSeqNext(&v32, v31);
      if (result) {
        break;
      }
      if (a2 <= v13) {
        return 2;
      }
      while (1)
      {
        if (24 * (__int16)v13 > (unint64_t)~a3) {
          goto LABEL_58;
        }
        unsigned __int16 v17 = v13;
        __int16 v18 = *(_WORD *)(a3 + 24 * v13 + 16);
        if ((v18 & 2) != 0 || v31[0] == *(void *)(a3 + 24 * v13 + 8)) {
          break;
        }
        uint64_t result = 2;
        if (v18)
        {
          ++v13;
          if (a2 > (unsigned __int16)(v17 + 1)) {
            continue;
          }
        }
        return result;
      }
      if ((v18 & 4) == 0)
      {
        unint64_t v19 = *(void *)(a3 + 24 * v13);
        if (v19 > 0xFFFFFFFFFFFFFFEFLL || v19 + 16 > a5) {
          return 7;
        }
        if (v19 > ~a4) {
          goto LABEL_58;
        }
        uint64_t v21 = (char *)(a4 + v19);
        if (v21 >= v29 || (unint64_t)v21 < a4) {
          goto LABEL_59;
        }
        *(_OWORD *)uint64_t v21 = *(_OWORD *)&v31[1];
        if ((v18 & 8) != 0)
        {
          if (v15 >= v31[1])
          {
            if (v21 + 16 <= v29 && v14 >= v15 && *((void *)v21 + 1) <= v14 - v15)
            {
              *(void *)uint64_t v21 = v15;
              return 3;
            }
            goto LABEL_59;
          }
          if (v21 + 16 > v29) {
            goto LABEL_59;
          }
          uint64_t v23 = *((void *)v21 + 1);
          unint64_t v24 = v23 + v31[1] - v15;
          if (__CFADD__(v23, v31[1] - v15))
          {
            __break(0x5500u);
            return result;
          }
          if (v14 < v15 || v24 > v14 - v15) {
            goto LABEL_59;
          }
          *(void *)uint64_t v21 = v15;
          *((void *)v21 + 1) = v24;
        }
      }
      ++v13;
      if (a2 == (unsigned __int16)(v17 + 1))
      {
        if (!__CFADD__(v31[1], v31[2]))
        {
          unint64_t v28 = a1[1];
          if (!__CFADD__(*a1, v28))
          {
            unint64_t v10 = v31[1] + v31[2];
            unint64_t v12 = *a1 + v28;
            goto LABEL_47;
          }
        }
LABEL_58:
        __break(0x5513u);
        goto LABEL_59;
      }
      if (a2 <= (unsigned __int16)(v17 + 1))
      {
        unint64_t v10 = v32;
        unint64_t v12 = v33;
        goto LABEL_47;
      }
    }
    if (result == 1)
    {
      if (a2 <= v13)
      {
        return 0;
      }
      else
      {
        BOOL v25 = (__int16 *)(a3 + 24 * v13 + 16);
        unint64_t v26 = a2 - (unint64_t)v13;
        uint64_t result = 0;
        while (1)
        {
          __int16 v27 = *v25;
          v25 += 12;
          if ((v27 & 1) == 0) {
            break;
          }
          if (!--v26) {
            return result;
          }
        }
        return 5;
      }
    }
  }
  else
  {
LABEL_47:
    if (v10 == v12) {
      return 0;
    }
    else {
      return 3;
    }
  }
  return result;
}

void sub_1000737C0()
{
  __assert_rtn("MultATagxB", "MatrixNxPts.hpp", 161, "GetNumOfPoints() == rhs.GetNumOfPoints()");
}

void sub_1000737EC()
{
  __assert_rtn("Filter2", "ImageUtils.hpp", 196, "&im1 != res");
}

void sub_100073818()
{
  __assert_rtn("vDSPImgfir", "VdspSpecialization.hpp", 542, "nCols2%2 == 1");
}

void sub_100073844()
{
  __assert_rtn("vDSPImgfir", "VdspSpecialization.hpp", 543, "nRows2%2 == 1");
}

void sub_100073870()
{
}

void sub_10007389C()
{
  sub_100006BA8();
  _os_log_error_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_ERROR, "Failed to send the %s event into the diagnostics system - %08X\n\n", v1, 0x12u);
}

void sub_10007391C(os_log_t log)
{
  int v1 = 136315138;
  unint64_t v2 = "ReadCalibrationData";
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "%s - Invalid buffer passed to read photon detector calibration data\n", (uint8_t *)&v1, 0xCu);
}

void sub_1000739A0()
{
}

void sub_1000739CC()
{
  __assert_rtn("RemoveOldestRecord", "IsfInternal.mm", 119, "m_head[i] == m_oldestIdx");
}

void sub_1000739F8()
{
  __assert_rtn("RemoveOldestRecord", "IsfInternal.mm", 109, "m_tail[i] == m_oldestIdx");
}

void sub_100073A24()
{
  __assert_rtn("InsertRecordInSortedList", "IsfInternal.mm", 169, "m_head[angleIdx] != -1");
}

void sub_100073A50()
{
  __assert_rtn("InsertRecordInSortedList", "IsfInternal.mm", 170, "m_tail[angleIdx] != -1");
}

void sub_100073A7C()
{
  __assert_rtn("InsertRecordInSortedList", "IsfInternal.mm", 187, "m_tail[angleIdx] == newRecord.prevInSorted[angleIdx]");
}

void sub_100073AA8()
{
}

void sub_100073AD4()
{
  __assert_rtn("InsertNewRecord", "IsfInternal.mm", 237, "m_oldestIdx != m_nextIdx");
}

void sub_100073B00()
{
  __assert_rtn("InsertNewRecord", "IsfInternal.mm", 233, "m_records.size() == (size_t)m_nextIdx + 1");
}

void sub_100073B2C()
{
  __assert_rtn("OutlierDetectAndWeight", "IsfInternal.mm", 310, "currentRecord->prevInSorted[angleIdx] != -1");
}

void sub_100073B58()
{
  __assert_rtn("OutlierDetectAndWeight", "IsfInternal.mm", 296, "currentRecord->nextInSorted[angleIdx] != -1");
}

void sub_100073B84()
{
  int v0 = 136315138;
  int v1 = "SetupDeviceController";
  _os_log_error_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR, "%s - IONotificationPortCreate returned NULL\n", (uint8_t *)&v0, 0xCu);
}

void sub_100073C0C()
{
  int v0 = 136315138;
  int v1 = "SetupDeviceController";
  _os_log_error_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR, "%s - IONotificationPortGetRunLoopSource returned NULL\n", (uint8_t *)&v0, 0xCu);
}

void sub_100073C94(unsigned __int8 *a1)
{
  int v1 = *a1;
  int v2 = 136315394;
  unint64_t v3 = "SetupDeviceController";
  __int16 v4 = 1024;
  int v5 = v1;
  _os_log_error_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR, "%s - Timed out waiting for the driver to register service, deviceArrived = %d\n", (uint8_t *)&v2, 0x12u);
}

void sub_100073D2C()
{
  sub_100014FB8();
  sub_100014FCC((void *)&_mh_execute_header, v0, v1, "Failed to send the %s event into the diagnostics system %08X\n\n", v2, v3, v4, v5, 2u);
}

void sub_100073DA0()
{
  sub_100014FB8();
  sub_100014FCC((void *)&_mh_execute_header, v0, v1, "Failed to send the %s event into the diagnostics system %08X\n\n", v2, v3, v4, v5, 2u);
}

void sub_100073E14()
{
  sub_100014FB8();
  sub_100014FCC((void *)&_mh_execute_header, v0, v1, "Failed to send the %s event into the diagnostics system %08X\n\n", v2, v3, v4, v5, 2u);
}

void sub_100073E88()
{
  sub_100014FB8();
  sub_100014FCC((void *)&_mh_execute_header, v0, v1, "Failed to send the %s event into the diagnostics system %08X\n\n", v2, v3, v4, v5, 2u);
}

void sub_100073EFC()
{
  sub_100014FB8();
  sub_100014FCC((void *)&_mh_execute_header, v0, v1, "Failed to send the %s event into the diagnostics system %08X\n\n", v2, v3, v4, v5, 2u);
}

void sub_100073F70()
{
  sub_100014FB8();
  sub_100014FCC((void *)&_mh_execute_header, v0, v1, "Failed to send the %s event into the diagnostics system %08X\n\n", v2, v3, v4, v5, 2u);
}

void sub_100073FE4()
{
  sub_100014FB8();
  sub_100014FCC((void *)&_mh_execute_header, v0, v1, "Failed to send the %s event into the diagnostics system %08X\n\n", v2, v3, v4, v5, 2u);
}

void sub_100074058(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_1000740D0(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_1000156C0((void *)&_mh_execute_header, a1, a3, "%s - IONotificationPortCreate returned NULL\n", a5, a6, a7, a8, 2u);
}

void sub_100074148(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_1000156C0((void *)&_mh_execute_header, a1, a3, "%s - IONotificationPortGetRunLoopSource returned NULL\n", a5, a6, a7, a8, 2u);
}

void sub_1000741C0()
{
}

void sub_1000741EC()
{
  sub_10001AE74();
  sub_10001AEA8((void *)&_mh_execute_header, v0, v1, "FlickerDetector: FlickerResourceArbiterClientDelegate cleanup at shutting down\n\n", v2, v3, v4, v5, v6);
}

void sub_100074220()
{
  sub_10001AE74();
  sub_10001AEA8((void *)&_mh_execute_header, v0, v1, "FlickerDetector: Requested resource access\n\n", v2, v3, v4, v5, v6);
}

void sub_100074254()
{
  sub_10001AE74();
  sub_10001AEA8((void *)&_mh_execute_header, v0, v1, "FlickerDetector: Released resource access\n\n", v2, v3, v4, v5, v6);
}

void sub_100074288()
{
  sub_10001AE74();
  sub_10001AE58((void *)&_mh_execute_header, v0, v1, "StartAudioCaptureSession: invalid context \n\n", v2, v3, v4, v5, v6);
}

void sub_1000742BC()
{
  sub_10001AE10();
  sub_1000156C0((void *)&_mh_execute_header, v0, v1, "AudioOutputUnitStart returned 0x%08lx\n\n", v2, v3, v4, v5, v6);
}

void sub_100074324(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_10001AE80((void *)&_mh_execute_header, a2, a3, "PrepareAudioCaptureSession returned 0x%08x\n\n", a5, a6, a7, a8, 0);
}

void sub_100074390()
{
  sub_10001AE74();
  sub_10001AE58((void *)&_mh_execute_header, v0, v1, "AudioComponentFindNext: no component found \n\n", v2, v3, v4, v5, v6);
}

void sub_1000743C4(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_10001AE80((void *)&_mh_execute_header, a2, a3, "AllocateFlickerDetectorBuffers returned 0x%08x\n\n", a5, a6, a7, a8, 0);
}

void sub_100074430()
{
  sub_10001ADD8();
  sub_10001ADF0((void *)&_mh_execute_header, v0, v1, "Unable to allocate accumulator buffer: nAccumulatedSamples==%d, frameSizeBytes==%zd \n\n", v2, v3);
}

void sub_100074498()
{
  sub_10001ADD8();
  sub_10001ADF0((void *)&_mh_execute_header, v0, v1, "Unable to allocate running buffer: nAccumulatedSamples==%d, frameSizeBytes==%zd \n\n", v2, v3);
}

void sub_100074500()
{
  sub_10001ADD8();
  sub_10001ADF0((void *)&_mh_execute_header, v0, v1, "Unable to allocate resampling buffer: nResampledSamples==%d, sampleSizeBytes==%zd \n\n", v2, v3);
}

void sub_100074568()
{
  sub_10001ADD8();
  sub_10001ADF0((void *)&_mh_execute_header, v0, v1, "Unable to allocate resampling IR buffer: nResampledSamples==%d, sampleSizeBytes==%zd \n\n", v2, v3);
}

void sub_1000745D0()
{
  sub_10001ADD8();
  sub_10001ADF0((void *)&_mh_execute_header, v0, v1, "Unable to allocate wave matching resampling buffer: nResampledSamples==%d, sampleSizeBytes==%zd \n\n", v2, v3);
}

void sub_100074638(uint64_t a1, uint64_t a2, os_log_t log)
{
  int v3 = 134218240;
  uint64_t v4 = a1;
  __int16 v5 = 2048;
  uint64_t v6 = a2;
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "Unable to allocate fftBuffer: nFFTBufferSamples==%zd, sampleSizeBytes==%zd \n\n", (uint8_t *)&v3, 0x16u);
}

void sub_1000746C0()
{
  sub_10001ADD8();
  sub_10001ADF0((void *)&_mh_execute_header, v0, v1, "Unable to allocate pAlgorithmHistory: nAccumulatedSamples==%d, sampleSizeBytes==%zd \n\n", v2, v3);
}

void sub_100074728(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_10001AE80((void *)&_mh_execute_header, a2, a3, "Unable to create fft setup : bins == %d \n\n", a5, a6, a7, a8, 0);
}

void sub_100074798(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_1000156C0((void *)&_mh_execute_header, a1, a3, "Unable to allocate pContext->pControl: size ==%zd\n\n", a5, a6, a7, a8, 0);
}

void sub_10007480C(uint64_t a1, uint64_t a2, NSObject *a3)
{
  LOWORD(v3) = 2048;
  *(void *)((char *)&v3 + 2) = a2;
  sub_10001ADF0((void *)&_mh_execute_header, a2, a3, "Unable to allocate scratchBuffer: scratchBuffer.mDataByteSize==%d, sampleSizeBytes==%zd \n\n", 67109376, (size_t)v3);
}

void sub_100074888()
{
  sub_10001ADD8();
  sub_10001ADF0((void *)&_mh_execute_header, v0, v1, "Unable to allocate visual buffer: nRunningBufferSamples==%d, sampleSizeBytes==%zd \n\n", v2, v3);
}

void sub_1000748F0()
{
  sub_10001ADD8();
  sub_10001ADF0((void *)&_mh_execute_header, v0, v1, "Unable to allocate IR buffer: nRunningBufferSamples==%d, sampleSizeBytes==%zd \n\n", v2, v3);
}

void sub_100074958(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_1000749C8()
{
  sub_10001AE74();
  sub_10001AE58((void *)&_mh_execute_header, v0, v1, "Retrieved format mismatches desired data format! \n\n", v2, v3, v4, v5, v6);
}

void sub_1000749FC()
{
  sub_10001AE10();
  sub_1000156C0((void *)&_mh_execute_header, v0, v1, "Get input stream format on AURemoteIO returned 0x%08lx \n\n", v2, v3, v4, v5, v6);
}

void sub_100074A64()
{
  v1[0] = 136315394;
  sub_10001AEC4();
  _os_log_error_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_ERROR, "%s - Set Volume Scalar returned 0x%08lx\n", (uint8_t *)v1, 0x16u);
}

void sub_100074AE8()
{
  sub_10001AE74();
  sub_10001AE58((void *)&_mh_execute_header, v0, v1, "AudioUnitInitialize :  kAudioServicesNoHardwareError \n\n", v2, v3, v4, v5, v6);
}

void sub_100074B1C()
{
  sub_10001AE10();
  sub_1000156C0((void *)&_mh_execute_header, v0, v1, "AudioUnitInitialize returned 0x%08lx\n\n", v2, v3, v4, v5, v6);
}

void sub_100074B84()
{
  sub_10001AE10();
  sub_1000156C0((void *)&_mh_execute_header, v0, v1, "Set Render Callback on AURemoteIO returned 0x%08lx \n\n", v2, v3, v4, v5, v6);
}

void sub_100074BEC()
{
  sub_10001AE10();
  sub_1000156C0((void *)&_mh_execute_header, v0, v1, "Get Maximum Frames Per Slice on AURemoteIO returned 0x%08lx \n\n", v2, v3, v4, v5, v6);
}

void sub_100074C54()
{
  sub_10001AE10();
  sub_1000156C0((void *)&_mh_execute_header, v0, v1, "Set Max Frames Per Slice on AURemoteIO returned 0x%08lx\n \n", v2, v3, v4, v5, v6);
}

void sub_100074CBC()
{
  sub_10001AE10();
  sub_1000156C0((void *)&_mh_execute_header, v0, v1, "Set Input IO Format on AURemoteIO returned 0x%08lx \n\n", v2, v3, v4, v5, v6);
}

void sub_100074D24()
{
  sub_10001AE10();
  sub_1000156C0((void *)&_mh_execute_header, v0, v1, "AudioComponentInstanceNew returned 0x%08lx\n\n", v2, v3, v4, v5, v6);
}

void sub_100074D8C()
{
  sub_10001AE74();
  sub_10001AE58((void *)&_mh_execute_header, v0, v1, "StopAudioCaptureSession: invalid context \n\n", v2, v3, v4, v5, v6);
}

void sub_100074DC0()
{
  sub_10001AE10();
  sub_1000156C0((void *)&_mh_execute_header, v0, v1, "AudioOutputUnitStop returned 0x%08lx\n\n", v2, v3, v4, v5, v6);
}

void sub_100074E28(os_log_t log)
{
  int v1 = 136315138;
  uint64_t v2 = "H16ISPFlickerDetectorStartDataCollection";
  _os_log_debug_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_DEBUG, "%s - Success\n", (uint8_t *)&v1, 0xCu);
}

void sub_100074EAC(os_log_t log)
{
  int v1 = 136315138;
  uint64_t v2 = "H16ISPFlickerDetectorStopDataCollection";
  _os_log_debug_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_DEBUG, "%s - Success\n", (uint8_t *)&v1, 0xCu);
}

void sub_100074F30()
{
  v1[0] = 136315394;
  sub_10001AEC4();
  _os_log_error_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_ERROR, "%s - Set Volume Scalar returned 0x%08lx\n \n", (uint8_t *)v1, 0x16u);
}

void sub_100074FB4(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_10007502C()
{
  v2[0] = 136315394;
  sub_100014FB8();
  sub_10001AE20((void *)&_mh_execute_header, v0, v1, "%s - wrong resampling factor: %d\n\n", (uint8_t *)v2);
}

void sub_1000750A4()
{
  sub_10001AE9C(__stack_chk_guard);
  int v2 = 136315650;
  sub_10001ADB8();
  sub_10001AE38((void *)&_mh_execute_header, v0, v1, "%s - AudioUnit Input Callback: accumulatedSize=%zd inputBufferByteSize=%d\n\n", v2, v3, v4);
}

void sub_100075118()
{
  v2[0] = 136315394;
  sub_100014FB8();
  sub_10001AE20((void *)&_mh_execute_header, v0, v1, "%s - AudioUnitRender - status 0x%08x \n\n", (uint8_t *)v2);
}

void sub_100075190(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_100075208()
{
  v2[0] = 136315394;
  sub_100014FB8();
  sub_10001AE20((void *)&_mh_execute_header, v0, v1, "%s - wrong resampling factor: %d\n\n", (uint8_t *)v2);
}

void sub_100075280()
{
  sub_10001AE9C(__stack_chk_guard);
  int v2 = 136315650;
  sub_10001ADB8();
  sub_10001AE38((void *)&_mh_execute_header, v0, v1, "%s - AudioUnit Input Callback: accumulatedSize=%zd inputBufferByteSize=%d\n\n", v2, v3, v4);
}

void sub_1000752F4()
{
  v2[0] = 136315394;
  sub_100014FB8();
  sub_10001AE20((void *)&_mh_execute_header, v0, v1, "%s - AudioUnitRender - status 0x%08x \n\n", (uint8_t *)v2);
}

void sub_10007536C(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_1000753E4()
{
  sub_10001AE9C(__stack_chk_guard);
  int v2 = 136315650;
  sub_10001ADB8();
  sub_10001AE38((void *)&_mh_execute_header, v0, v1, "%s - AudioUnit Input Callback: accumulatedSize=%zd inputBufferByteSize=%d\n\n", v2, v3, v4);
}

void sub_100075458()
{
  v2[0] = 136315394;
  sub_100014FB8();
  sub_10001AE20((void *)&_mh_execute_header, v0, v1, "%s - AudioUnitRender - status 0x%08x \n\n", (uint8_t *)v2);
}

void sub_1000754D0(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_100075548()
{
  sub_10001AE9C(__stack_chk_guard);
  int v2 = 136315650;
  sub_10001ADB8();
  sub_10001AE38((void *)&_mh_execute_header, v0, v1, "%s - AudioUnit Input Callback: accumulatedSize=%zd inputBufferByteSize=%d\n\n", v2, v3, v4);
}

void sub_1000755BC()
{
  v2[0] = 136315394;
  sub_100014FB8();
  sub_10001AE20((void *)&_mh_execute_header, v0, v1, "%s - AudioUnitRender - status 0x%08x \n\n", (uint8_t *)v2);
}

void sub_100075634(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_1000756AC()
{
  sub_10001AE9C(__stack_chk_guard);
  int v2 = 136315650;
  sub_10001ADB8();
  sub_10001AE38((void *)&_mh_execute_header, v0, v1, "%s - AudioUnit Input Callback: accumulatedSize=%zd inputBufferByteSize=%d\n", v2, v3, v4);
}

void sub_100075720()
{
  v2[0] = 136315394;
  sub_100014FB8();
  sub_10001AE20((void *)&_mh_execute_header, v0, v1, "%s - AudioUnitRender - status 0x%08x\n", (uint8_t *)v2);
}

void sub_100075798(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_100075810()
{
  sub_10001AE9C(__stack_chk_guard);
  int v2 = 136315650;
  sub_10001ADB8();
  sub_10001AE38((void *)&_mh_execute_header, v0, v1, "%s - AudioUnit Input Callback: accumulatedSize=%zd inputBufferByteSize=%d\n", v2, v3, v4);
}

void sub_100075884()
{
  v2[0] = 136315394;
  sub_100014FB8();
  sub_10001AE20((void *)&_mh_execute_header, v0, v1, "%s - AudioUnitRender - status 0x%08x\n", (uint8_t *)v2);
}

void sub_1000758FC(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_100075974(os_log_t log)
{
  int v1 = 136315138;
  int v2 = "sendMessageSync";
  _os_log_debug_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_DEBUG, "%s - received reply\n", (uint8_t *)&v1, 0xCu);
}

void sub_1000759F8()
{
  v1[0] = 136315394;
  sub_10001BB3C();
  _os_log_error_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_ERROR, "%s - received error reply: %s\n", (uint8_t *)v1, 0x16u);
}

void sub_100075A78()
{
  v1[0] = 136315394;
  sub_10001BB3C();
  _os_log_error_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_ERROR, "%s - received async error reply: %s\n", (uint8_t *)v1, 0x16u);
}

void sub_100075AF8()
{
  __assert_rtn("DistortRadialLiteInternal", "GeomUtils.hpp", 378, "pts.Rows() == 2");
}

void sub_100075B24()
{
  __assert_rtn("DotMult", "Matrix.hpp", 507, "rhs.Cols() == m_cols && rhs.Rows() == m_rows");
}

void sub_100075B50()
{
}

void sub_100075B7C()
{
}

void sub_100075BA8()
{
}

void sub_100075BD4()
{
}

void sub_100075C00()
{
}

void sub_100075C2C()
{
  __assert_rtn("Interp1SortedWithExtrap", "Algo.hpp", 1376, "x.GetNumOfPoints() == v.GetNumOfPoints()");
}

void sub_100075C58()
{
  __assert_rtn("Interp1WithExtrap", "Algo.hpp", 1192, "x.GetNumOfPoints() == v.GetNumOfPoints()");
}

void sub_100075C84()
{
}

void sub_100075CB0()
{
  __assert_rtn("Process", "BlurM.cpp", 1763, "pContext != 0");
}

void sub_100075CDC(uint64_t a1)
{
  int v1 = 136315138;
  uint64_t v2 = a1;
  _os_log_error_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR, "createXpcFromType got a dictionary with null value (for key %s)", (uint8_t *)&v1, 0xCu);
}

void sub_100075D5C()
{
  __assert_rtn("GMC_ExtractTestSamples", "GMC_ExtractTestSamples.cpp", 93, "pts1.GetNumOfPoints() - testSetSize == newPts1->GetNumOfPoints()");
}

void sub_100075D88()
{
  __assert_rtn("GMC_ExtractTestSamples", "GMC_ExtractTestSamples.cpp", 92, "testSetSize == tsPtsIdx+1");
}

void sub_100075DB4()
{
}

void sub_100075DE0()
{
}

void sub_100075E0C()
{
  __assert_rtn("Process", "SPD.cpp", 394, "pContext != nullptr");
}

void sub_100075E38()
{
  __assert_rtn("Process", "SPD.cpp", 395, "pSpd != nullptr");
}

void sub_100075E64()
{
  __assert_rtn("ConcatCols", "Matrix.hpp", 2379, "m_rows == mat.Rows()");
}

void sub_100075E90()
{
  sub_10001AE74();
  sub_10001AE58((void *)&_mh_execute_header, v0, v1, "Pearl Calibration (MI): Failed to allocate work buffers\n", v2, v3, v4, v5, v6);
}

void sub_100075EC4()
{
  __assert_rtn("MultAxBToC", "Matrix.hpp", 1562, "m_rows == C->Rows() && B.Cols() == C->Cols() && \"Output dimensions not legal\"");
}

void sub_100075EF0()
{
  __assert_rtn("MultAxBToC", "Matrix.hpp", 1561, "m_cols == B.Rows() && \"Input dimensions not legal\"");
}

void sub_100075F1C(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_100075F94(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_10007600C(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_100076084(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_1000760FC(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_100076174(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_1000761EC(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_100076264(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_1000762DC(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_100076354(uint64_t a1, NSObject *a2)
{
  int v2 = *(_DWORD *)(*(void *)a1 + 24);
  int v3 = 136315650;
  uint64_t v4 = "GetLuxInfo";
  __int16 v5 = 2080;
  uint8_t v6 = "GetLuxInfo";
  __int16 v7 = 1024;
  int v8 = v2;
  _os_log_error_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_ERROR, "%s - %s: Sending lux, ret = 0x%x\n", (uint8_t *)&v3, 0x1Cu);
}

void sub_1000763F4()
{
  v1[0] = 136315394;
  sub_100032A50();
  _os_log_error_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_ERROR, "%s - %s: Scheduling the lux query on the serial queue\n", (uint8_t *)v1, 0x16u);
}

void sub_100076478()
{
  v1[0] = 136315394;
  sub_100032A50();
  _os_log_error_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_ERROR, "%s - %s: Waiting for lux\n", (uint8_t *)v1, 0x16u);
}

void sub_1000764FC(const __CFString *a1, NSObject *a2)
{
  int v3 = 136315394;
  uint64_t v4 = "LoadFrontIRHPRFile";
  __int16 v5 = 2080;
  CStringPtr = CFStringGetCStringPtr(a1, 0);
  _os_log_error_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_ERROR, "%s - [error]: %s\n", (uint8_t *)&v3, 0x16u);
}

void sub_1000765A0(os_log_t log)
{
  int v1 = 136315138;
  int v2 = "LoadFrontIRHPRFile";
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "%s - noHPR boot-arg set\n", (uint8_t *)&v1, 0xCu);
}

void sub_100076624(uint64_t a1, NSObject *a2)
{
  int v2 = *(_DWORD *)(a1 + 12);
  v3[0] = 67109120;
  v3[1] = v2;
  _os_log_error_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_ERROR, "input/ouput buffer or parameter setting incorrect. win size %d \n\n", (uint8_t *)v3, 8u);
}

void sub_1000766A0(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_1000766D8(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_100076710(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_100076748()
{
  __assert_rtn("Expand", "SparseMatrix.cpp", 121, "newNZPerCol <= (size_t)m_extraSpacePerCol");
}

void sub_100076774()
{
  __assert_rtn("SolveLTInPlace", "SparseMatrix.cpp", 248, "m_width == m_height");
}

void sub_1000767A0()
{
  __assert_rtn("operator=", "SparseMatrix.cpp", 374, "m_ownsData");
}

void sub_1000767CC()
{
}

void sub_1000767F8()
{
}

void sub_100076824()
{
  __assert_rtn("Process_x1", "PDAFPixelEngine.cpp", 4312, "pIn0 != nullptr");
}

void sub_100076850()
{
  __assert_rtn("Process_x1", "PDAFPixelEngine.cpp", 4313, "pContext != nullptr");
}

void sub_10007687C()
{
}

void sub_1000768A8()
{
}

void sub_1000768D4()
{
  __assert_rtn("Process_x1", "PDAFPixelEngine.cpp", 4330, "pContext->geometry.tile.countX * pContext->geometry.tile.countY <= NTILES");
}

void sub_100076900()
{
  __assert_rtn("Process", "PDAFPixelEngine.cpp", 4248, "pContext->geometry.tile.countX * pContext->geometry.tile.countY <= NTILES");
}

void sub_10007692C()
{
}

void sub_100076958()
{
  __assert_rtn("FlowOutputLevel", "PDAFPixelEngine.cpp", 2455, "level == 0");
}

void sub_100076984()
{
}

void sub_1000769B0()
{
}

void sub_1000769DC()
{
  __assert_rtn("FlareEstimate", "PDAFPixelEngine.cpp", 2339, "flare.intensity <= Params::Flare::NINTENSITIES");
}

void sub_100076A08()
{
}

void sub_100076A34()
{
  __assert_rtn("FlowPostProcess", "PDAFPixelEngine.cpp", 2604, "pContext->params.flow.levels[0] == 1");
}

void sub_100076A60()
{
}

void sub_100076A8C()
{
}

void sub_100076AB8()
{
  __assert_rtn("CorrPostProcess", "PDAFPixelEngine.cpp", 3881, "SamplingH == SamplingV");
}

void sub_100076AE4()
{
}

void sub_100076B10()
{
  __assert_rtn("CorrProfile", "PDAFPixelEngine.cpp", 3450, "pContext->geometry.roi.cellCountX == geometryCorr.profileSize");
}

void sub_100076B3C()
{
  __assert_rtn("CorrProfile", "PDAFPixelEngine.cpp", 3455, "pContext->geometry.roi.cellCountY == geometryCorr.profileSize");
}

void sub_100076B68()
{
}

void sub_100076B94()
{
}

void sub_100076BC0()
{
  __assert_rtn("Process_x2", "PDAFPixelEngine.cpp", 4347, "pIn0 != nullptr");
}

void sub_100076BEC()
{
  __assert_rtn("Process_x2", "PDAFPixelEngine.cpp", 4348, "pIn1 != nullptr");
}

void sub_100076C18()
{
  __assert_rtn("Process_x2", "PDAFPixelEngine.cpp", 4349, "pContext != nullptr");
}

void sub_100076C44()
{
}

void sub_100076C70()
{
}

void sub_100076C9C()
{
}

void sub_100076CC8()
{
  __assert_rtn("GetInputAFE", "PDAFPixelEngine.cpp", 608, "afe != nullptr");
}

void sub_100076CF4()
{
}

void sub_100076D20()
{
  __assert_rtn("GetInputAFE", "PDAFPixelEngine.cpp", 614, "afeGeom.initH == 0 || afeGeom.initH == 1");
}

void sub_100076D4C()
{
}

void sub_100076D78()
{
}

void sub_100076DA4()
{
}

void sub_100076DD0()
{
}

void sub_100076DFC()
{
  __assert_rtn("AFEGetInputs", "PDAFPixelEngine.cpp", 747, "(cellCountXH == 0) || (cellCountXH == (signed)geometry.roi.cellCountX)");
}

void sub_100076E28()
{
  __assert_rtn("AFEGetInputs", "PDAFPixelEngine.cpp", 748, "(cellCountXV == 0) || (cellCountXV == (signed)geometry.roi.cellCountX)");
}

void sub_100076E54()
{
  __assert_rtn("AFEGetInputs", "PDAFPixelEngine.cpp", 745, "inputs[k].cellCountY == (signed)geometry.roi.cellCountY");
}

void sub_100076E80()
{
}

void sub_100076EAC()
{
}

void sub_100076ED8()
{
  __assert_rtn("GetAFEAddress", "PDAFPixelEngine.cpp", 444, "afeGeom.cellCountY >= delayV + 1");
}

void sub_100076F04()
{
  __assert_rtn("GetInputAFE", "PDAFPixelEngine.cpp", 615, "afeGeom.initV == -1");
}

void sub_100076F30()
{
  __assert_rtn("GetInputAFE", "PDAFPixelEngine.cpp", 622, "afeGeom.initH == 0 || afeGeom.initH == 1");
}

void sub_100076F5C()
{
  __assert_rtn("GetInputAFE", "PDAFPixelEngine.cpp", 623, "afeGeom.initV == 2 || afeGeom.initV == 3");
}

void sub_100076F88()
{
  __assert_rtn("GetInputAFE", "PDAFPixelEngine.cpp", 628, "afeGeom.initV == -1");
}

void sub_100076FB4()
{
  __assert_rtn("GetInputAFE", "PDAFPixelEngine.cpp", 627, "afeGeom.initH == 0");
}

void sub_100076FE0()
{
  __assert_rtn("GetInputAFE", "PDAFPixelEngine.cpp", 634, "afeGeom.initV == 2");
}

void sub_10007700C()
{
  __assert_rtn("GetInputAFE", "PDAFPixelEngine.cpp", 633, "afeGeom.initH == 0");
}

void sub_100077038()
{
}

void sub_100077064()
{
}

void sub_100077090()
{
}

void sub_1000770BC()
{
}

void sub_1000770E8()
{
  __assert_rtn("FlowAccumulateRow1x1Scalar", "PDAFPixelEngine.cpp", 845, "pixelInBuffer == 0");
}

void sub_100077114()
{
}

void sub_100077140()
{
}

void sub_10007716C()
{
  __assert_rtn("FlowAccumulateRow2x1Scalar", "PDAFPixelEngine.cpp", 1114, "pixelInBuffer == 0");
}

void sub_100077198()
{
}

void sub_1000771C4()
{
  __assert_rtn("FlowAccumulateRow1x1Neon64", "PDAFPixelEngine.cpp", 1012, "pixelInBuffer == 0");
}

void sub_1000771F0()
{
}

void sub_10007721C()
{
}

void sub_100077248()
{
}

void sub_100077274()
{
}

void sub_1000772A0()
{
}

void sub_1000772CC()
{
}

void sub_1000772F8()
{
}

void sub_100077324()
{
}

void sub_100077350()
{
  __assert_rtn("CorrProfileSumRows1x1H", "PDAFPixelEngine.cpp", 3214, "pixelInCol != 0");
}

void sub_10007737C()
{
  __assert_rtn("CorrProfileSumRows1x1H", "PDAFPixelEngine.cpp", 3246, "cellInBuffer == 0");
}

void sub_1000773A8()
{
}

void sub_1000773D4()
{
}

void sub_100077400()
{
}

void sub_10007742C()
{
}

void sub_100077458()
{
}

void sub_100077484()
{
}

void sub_1000774B0()
{
  __assert_rtn("CorrProfileSumCols1x1V", "PDAFPixelEngine.cpp", 3272, "pixelInRow != 0");
}

void sub_1000774DC()
{
  __assert_rtn("CorrProfileSumRows2x1H", "PDAFPixelEngine.cpp", 3317, "pixelInCol != 0");
}

void sub_100077508()
{
  __assert_rtn("CorrProfileSumRows2x1H", "PDAFPixelEngine.cpp", 3336, "cellInBuffer == 0");
}

void sub_100077534()
{
  __assert_rtn("CorrProfileSumCols2x1V", "PDAFPixelEngine.cpp", 3358, "pixelInRow != 0");
}

void sub_100077560()
{
}

void sub_10007758C()
{
  sub_100048248();
  sub_100014FCC((void *)&_mh_execute_header, v0, v1, "Failed to send the %s event into the diagnostics system %08X\n\n", v2, v3, v4, v5, 2u);
}

void sub_100077604()
{
  sub_100048248();
  sub_100014FCC((void *)&_mh_execute_header, v0, v1, "Failed to send the %s event into the diagnostics system %08X\n\n", v2, v3, v4, v5, 2u);
}

void sub_10007767C(os_log_t log)
{
  v1[0] = 67109120;
  v1[1] = 0;
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "Failed to send Pearl Statistics into the diagnostics system %08X\n\n", (uint8_t *)v1, 8u);
}

void sub_1000776F8()
{
  sub_100048248();
  sub_100014FCC((void *)&_mh_execute_header, v0, v1, "Failed to send the %s event into the diagnostics system %08X\n\n", v2, v3, v4, v5, 2u);
}

void sub_100077770()
{
  sub_100048248();
  sub_100014FCC((void *)&_mh_execute_header, v0, v1, "Failed to send the %s event into the diagnostics system %08X\n\n", v2, v3, v4, v5, 2u);
}

void sub_1000777E8()
{
  sub_100048248();
  sub_100014FCC((void *)&_mh_execute_header, v0, v1, "Failed to send the %s event into the diagnostics system %08X\n\n", v2, v3, v4, v5, 2u);
}

void sub_100077860()
{
  sub_100048248();
  sub_100014FCC((void *)&_mh_execute_header, v0, v1, "Failed to send the %s event into the diagnostics system %08X\n\n", v2, v3, v4, v5, 2u);
}

void sub_1000778D8()
{
  sub_100048248();
  sub_100014FCC((void *)&_mh_execute_header, v0, v1, "Failed to send the %s event into the diagnostics system %08X\n\n", v2, v3, v4, v5, 2u);
}

void sub_100077950()
{
  sub_100048248();
  sub_100014FCC((void *)&_mh_execute_header, v0, v1, "Failed to send the %s event into the diagnostics system %d\n\n", v2, v3, v4, v5, 2u);
}

void sub_1000779C8()
{
  sub_100048248();
  sub_100014FCC((void *)&_mh_execute_header, v0, v1, "Failed to send the %s event into the diagnostics system %d\n\n", v2, v3, v4, v5, 2u);
}

void sub_100077A40(os_log_t log)
{
  int v1 = 136315138;
  uint64_t v2 = "com.apple.applecamerad.SpmiFaultStatus";
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "Failed to send the %s event into the diagnostics system.\n\n", (uint8_t *)&v1, 0xCu);
}

void sub_100077AC4()
{
  v1[0] = 136315394;
  sub_10001BB3C();
  _os_log_error_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_ERROR, "%s - Failed to stat file: %s\n", (uint8_t *)v1, 0x16u);
}

void sub_100077B44(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_100077BBC()
{
  sub_10001AE9C(__stack_chk_guard);
  v2[0] = 136315650;
  sub_100049A10();
  sub_100049A68((void *)&_mh_execute_header, v0, v1, "%s - Buffer size does not match expected value (expected %ld, recv %lld)\n", (uint8_t *)v2);
}

void sub_100077C34()
{
  sub_100014FB8();
  sub_100014FCC((void *)&_mh_execute_header, v0, v1, "%s - Number of buffers is not 1 (%d)\n", v2, v3, v4, v5, 2u);
}

void sub_100077CA8()
{
  sub_100049A80();
  sub_100014FCC((void *)&_mh_execute_header, v0, v1, "%s - Invalid read length (%d)\n", v2, v3, v4, v5, 2u);
}

void sub_100077D20(uint64_t a1, NSObject *a2)
{
  uint64_t v3 = __error();
  strerror(*v3);
  v5[0] = 136315650;
  sub_100049A4C();
  sub_100049A68((void *)&_mh_execute_header, a2, v4, "%s - Failed to open file: %s %s\n", (uint8_t *)v5);
}

void sub_100077DB8(uint64_t a1, int *a2, os_log_t log)
{
  int v3 = *a2;
  int v4 = 136315650;
  uint64_t v5 = "RPCFileRead";
  __int16 v6 = 2080;
  uint64_t v7 = a1;
  __int16 v8 = 1024;
  int v9 = v3;
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "%s - Failed to seek file %s: offset %d\n", (uint8_t *)&v4, 0x1Cu);
}

void sub_100077E58(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_100077ED0()
{
  sub_10001AE9C(__stack_chk_guard);
  v2[0] = 136315650;
  sub_100049A10();
  sub_100049A68((void *)&_mh_execute_header, v0, v1, "%s - Buffer size does not match expected value (expected %ld, recv %lld)\n", (uint8_t *)v2);
}

void sub_100077F48()
{
  sub_100014FB8();
  sub_100014FCC((void *)&_mh_execute_header, v0, v1, "%s - Number of buffers is not 2 (%d)\n", v2, v3, v4, v5, 2u);
}

void sub_100077FBC()
{
  sub_100049A80();
  sub_100014FCC((void *)&_mh_execute_header, v0, v1, "%s - Invalid write length (%d)\n", v2, v3, v4, v5, 2u);
}

void sub_100078034(char *a1, NSObject *a2)
{
  dirname(a1);
  v3[0] = 136315394;
  sub_10001BB3C();
  _os_log_error_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_ERROR, "%s - Failed to create directory: %s\n", (uint8_t *)v3, 0x16u);
}

void sub_1000780C8(uint64_t a1, NSObject *a2)
{
  uint64_t v3 = __error();
  strerror(*v3);
  v5[0] = 136315650;
  sub_100049A4C();
  sub_100049A68((void *)&_mh_execute_header, a2, v4, "%s - Failed to open file: %s %s\n", (uint8_t *)v5);
}

void sub_100078160(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_1000781D8()
{
  sub_10001AE9C(__stack_chk_guard);
  v2[0] = 136315650;
  sub_100049A10();
  sub_100049A68((void *)&_mh_execute_header, v0, v1, "%s - Buffer size does not match expected value (expected %ld, recv %lld)\n", (uint8_t *)v2);
}

void sub_100078250()
{
  sub_100014FB8();
  sub_100014FCC((void *)&_mh_execute_header, v0, v1, "%s - Number of buffers is not 2 (%d)\n", v2, v3, v4, v5, 2u);
}

void sub_1000782C4()
{
  sub_10001AE9C(__stack_chk_guard);
  sub_1000499D4();
  sub_100049A30((void *)&_mh_execute_header, v0, v1, "%s - Buffer size does not match expected value (expected %d, recv %lld)\n", v2, v3, v4, v5, 2u);
}

void sub_100078338()
{
  sub_100014FB8();
  sub_100014FCC((void *)&_mh_execute_header, v0, v1, "%s - Number of buffers is not 2 (%d)\n", v2, v3, v4, v5, 2u);
}

void sub_1000783AC()
{
  sub_10001AE9C(__stack_chk_guard);
  sub_1000499D4();
  sub_100049A30((void *)&_mh_execute_header, v0, v1, "%s - Buffer size does not match expected value (expected %d, recv %lld)\n", v2, v3, v4, v5, 2u);
}

void sub_100078420()
{
  sub_100014FB8();
  sub_100014FCC((void *)&_mh_execute_header, v0, v1, "%s - Number of buffers is not 3 (%d)\n", v2, v3, v4, v5, 2u);
}

void sub_100078494()
{
  sub_10001AE9C(__stack_chk_guard);
  sub_1000499D4();
  sub_100049A30((void *)&_mh_execute_header, v0, v1, "%s - Buffer size does not match expected value (expected %d, recv %lld)\n", v2, v3, v4, v5, 2u);
}

void sub_100078508()
{
  sub_100014FB8();
  sub_100014FCC((void *)&_mh_execute_header, v0, v1, "%s - Number of buffers is not 4 (%d)\n", v2, v3, v4, v5, 2u);
}

void sub_10007857C()
{
  sub_10001AE9C(__stack_chk_guard);
  sub_1000499D4();
  sub_100049A30((void *)&_mh_execute_header, v0, v1, "%s - Buffer size does not match expected value (expected %d, recv %lld)\n", v2, v3, v4, v5, 2u);
}

void sub_1000785F0()
{
  sub_100014FB8();
  sub_100014FCC((void *)&_mh_execute_header, v0, v1, "%s - Number of buffers is not 5 (%d)\n", v2, v3, v4, v5, 2u);
}

void sub_100078664()
{
  sub_10001AE9C(__stack_chk_guard);
  sub_1000499FC();
  sub_100049A30((void *)&_mh_execute_header, v0, v1, "%s - Buffer size does not match expected value (expected %d, recv %lld)\n", v2, v3, v4, v5, 2u);
}

void sub_1000786EC(int a1, NSObject *a2)
{
  int v2 = 136315650;
  uint64_t v3 = "BlurMProcessWrapper";
  __int16 v4 = 1024;
  int v5 = 4;
  __int16 v6 = 1024;
  int v7 = a1;
  _os_log_error_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_ERROR, "%s - Number of buffers is not %d (%d)\n", (uint8_t *)&v2, 0x18u);
}

void sub_100078784()
{
  sub_1000499FC();
  sub_100049A30((void *)&_mh_execute_header, v0, v1, "%s - Buffer size does not match expected value (expected %d, recv %lld)\n", v2, v3, v4, v5, 2u);
}

void sub_100078810()
{
  sub_100014FB8();
  sub_100014FCC((void *)&_mh_execute_header, v0, v1, "%s - Number of buffers is not 2 (%d)\n", v2, v3, v4, v5, 2u);
}

void sub_100078884(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(_WORD *)uint64_t v3 = 0;
  sub_100056DB4((void *)&_mh_execute_header, &_os_log_default, a3, "Failure loading override ISPUnitInfo property list : CFPropertyListCreateWithStream failed\n", v3);
}

void sub_1000788C4()
{
  sub_100014FB8();
  sub_100014FCC((void *)&_mh_execute_header, &_os_log_default, v0, "%s - invalid cache - exiting, chan: %d\n", v1, v2, v3, v4, 2u);
}

void sub_100078940(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_1000789BC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_100078A38()
{
  sub_100014FB8();
  sub_100014FCC((void *)&_mh_execute_header, &_os_log_default, v0, "%s - Error: resetting device config cache - res: 0x%08X\n", v1, v2, v3, v4, 2u);
}

void sub_100078AB4()
{
  sub_100014FB8();
  sub_100056E28((void *)&_mh_execute_header, &_os_log_default, v0, "%s - Error getting channel info - chan: %d, res: 0x%08X\n", v1, v2, v3, v4, 2u);
}

void sub_100078B38()
{
  sub_100014FB8();
  sub_100014FCC((void *)&_mh_execute_header, &_os_log_default, v0, "%s - Error getting config - res: 0x%08X\n", v1, v2, v3, v4, 2u);
}

void sub_100078BB4()
{
  sub_100056E44();
  __int16 v2 = 1024;
  int v3 = v0;
  _os_log_error_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR, "UpdateChannelConfigCache channel %d error: 0x%08X\n", v1, 0xEu);
}

void sub_100078C3C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_100014FCC((void *)&_mh_execute_header, &_os_log_default, a3, "Failed to fetch handle for %s with return code = 0x%08x\n", a5, a6, a7, a8, 2u);
}

void sub_100078CC0(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_100078D38()
{
  sub_100014FB8();
  sub_100014FCC((void *)&_mh_execute_header, &_os_log_default, v0, "%s - IOConnect Failed, status = 0x%08x\n", v1, v2, v3, v4, 2u);
}

void sub_100078DB4()
{
  sub_100014FB8();
  sub_100014FCC((void *)&_mh_execute_header, &_os_log_default, v0, "%s - ISP_GetCameraStatus error (0x%08x)\n", v1, v2, v3, v4, 2u);
}

void sub_100078E30()
{
  sub_100056E1C(__stack_chk_guard);
  sub_100049A80();
  sub_100014FCC((void *)&_mh_execute_header, &_os_log_default, v0, "%s - Did not find platform-info for platform:%d. Defaulting to 0\n", v1, v2, v3, v4, 2u);
}

void sub_100078EAC(uint8_t *a1, int a2, _DWORD *a3)
{
  *(_DWORD *)a1 = 67109120;
  *a3 = a2;
  sub_100056E04((void *)&_mh_execute_header, &_os_log_default, (uint64_t)a3, "Error: SetSensorCustomSettings returned an error: 0x%08X\n", a1);
}

void sub_100078EF0(unsigned char *a1, unsigned char *a2)
{
  sub_100056DCC(a1, a2);
  sub_100056DB4((void *)&_mh_execute_header, &_os_log_default, v2, "Error parsing camera clock override file\n", v3);
}

void sub_100078F24(uint8_t *a1, int a2, _DWORD *a3)
{
  *(_DWORD *)a1 = 67109120;
  *a3 = a2;
  sub_100056E04((void *)&_mh_execute_header, &_os_log_default, (uint64_t)a3, "Error setting FW property: 0x%08x\n", a1);
}

void sub_100078F68(unsigned char *a1, unsigned char *a2)
{
  sub_100056DCC(a1, a2);
  sub_100056DB4((void *)&_mh_execute_header, &_os_log_default, v2, "Error: too many camera sensor register over-rides in file\n", v3);
}

void sub_100078F9C(uint8_t *a1, _DWORD *a2, uint64_t a3)
{
  *(_DWORD *)a1 = 67109120;
  *a2 = -536870165;
  sub_100056E04((void *)&_mh_execute_header, &_os_log_default, a3, "LoadSetFile returned 0x%08x - ignoring error\n", a1);
}

void sub_100078FE8(uint8_t *buf, void *a2)
{
  *(_DWORD *)long long buf = 136315138;
  *a2 = "ISP_PowerOnCamera";
  _os_log_error_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR, "%s - FTC gain buffer allocation failed\n", buf, 0xCu);
}

void sub_10007903C()
{
  __assert_rtn("ISP_PowerOnCamera", "H16ISPDevice.cpp", 10921, "kCICMaxPerModuleX >= numXCIC");
}

void sub_100079068()
{
  __assert_rtn("ISP_PowerOnCamera", "H16ISPDevice.cpp", 10922, "kCICMaxPerModuleY >= numYCIC");
}

void sub_100079094(unsigned char *a1, unsigned char *a2)
{
  sub_100056DCC(a1, a2);
  sub_100056DB4((void *)&_mh_execute_header, &_os_log_default, v2, "No ALS2 profile found in Setfile\n", v3);
}

void sub_1000790C8(unsigned char *a1, unsigned char *a2)
{
  sub_100056DCC(a1, a2);
  sub_100056DB4((void *)&_mh_execute_header, &_os_log_default, v2, "could not read sensor SetFile\n", v3);
}

void sub_1000790FC()
{
  sub_100014FB8();
  sub_100014FCC((void *)&_mh_execute_header, &_os_log_default, v0, "%s - ISP_GetNumChannels failed with 0x%08x\n", v1, v2, v3, v4, 2u);
}

void sub_100079178()
{
  sub_100014FB8();
  sub_100014FCC((void *)&_mh_execute_header, &_os_log_default, v0, "%s - Error %x loading FW\n", v1, v2, v3, v4, 2u);
}

void sub_1000791F4()
{
  sub_100014FB8();
  sub_100014FCC((void *)&_mh_execute_header, &_os_log_default, v0, "%s - Could not forget firmware, res = %x\n", v1, v2, v3, v4, 2u);
}

void sub_100079270(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_1000792EC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_100079368()
{
  sub_100056E44();
  sub_100056E04((void *)&_mh_execute_header, &_os_log_default, v0, "Failed to load Bin-format firmware binary: 0x%08x\n", v1);
}

void sub_1000793DC()
{
  sub_100014FB8();
  sub_100014FCC((void *)&_mh_execute_header, &_os_log_default, v0, "%s - ret=%#x\n", v1, v2, v3, v4, 2u);
}

void sub_100079458()
{
  sub_100056E1C(__stack_chk_guard);
  sub_100049A80();
  sub_100014FCC((void *)&_mh_execute_header, &_os_log_default, v0, "%s - Failed to copy kMGQFrontCameraOffsetFromDisplayCenter answer from MobileGestalt! err=%d\n", v1, v2, v3, v4, 2u);
}

void sub_1000794D4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(_WORD *)uint64_t v3 = 0;
  sub_100056DB4((void *)&_mh_execute_header, &_os_log_default, a3, "could not read ISPCPU Firmware file\n", v3);
}

void sub_100079514(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(_WORD *)uint64_t v3 = 0;
  sub_100056DB4((void *)&_mh_execute_header, &_os_log_default, a3, "(Bin) Using ISPCPU firmware override file\n", v3);
}

void sub_100079554(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_1000795D0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(_WORD *)uint64_t v3 = 0;
  sub_100056DB4((void *)&_mh_execute_header, &_os_log_default, a3, "Couldn't read back camera module serial number. Sensor is hosed/disconnected. Skip loading FDR CmCl calibration data\n", v3);
}

void sub_100079610()
{
  sub_100056DDC();
  sub_100049A30((void *)&_mh_execute_header, &_os_log_default, v0, "%s - No module or Unauthorized swap (cmclStatus = 0x%x) or No CmCL data (perhaps cuz the device does not support CmCL) [error]: %s\n", v1, v2, v3, v4, v5);
}

void sub_100079694(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_100079710()
{
  sub_100056DDC();
  sub_100049A30((void *)&_mh_execute_header, &_os_log_default, v0, "%s - No module or Unauthorized swap (fcclStatus = %#x) or No FCCL data (perhaps cuz the device does not support FCCL) [error]: %s\n", v1, v2, v3, v4, v5);
}

void sub_100079794(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(_WORD *)uint64_t v3 = 0;
  sub_100056DB4((void *)&_mh_execute_header, &_os_log_default, a3, "Couldn't read BackCameraSNUM and BackSuperWideCameraSNUM. Sensor is hosed/disconnected. Skip loading FDR CmPM calibration data\n", v3);
}

void sub_1000797D4()
{
  sub_100056DDC();
  sub_100049A30((void *)&_mh_execute_header, &_os_log_default, v0, "%s - No module or Unauthorized swap (cmpmStatus = 0x%x) or No CmPM data (perhaps cuz the device does not support CmPM) [error]: %s\n", v1, v2, v3, v4, v5);
}

void sub_100079858(unsigned char *a1, unsigned char *a2)
{
  sub_100056DCC(a1, a2);
  sub_100056DB4((void *)&_mh_execute_header, &_os_log_default, v2, "Pixel format mismatch\n", v3);
}

void sub_10007988C(unsigned char *a1, unsigned char *a2)
{
  sub_100056DCC(a1, a2);
  sub_100056DB4((void *)&_mh_execute_header, &_os_log_default, v2, "Pixel buffer has invalid size\n", v3);
}

void sub_1000798C0(unsigned char *a1, unsigned char *a2)
{
  sub_100056DCC(a1, a2);
  sub_100056DB4((void *)&_mh_execute_header, &_os_log_default, v2, "Failed to lock pixel buffer\n", v3);
}

void sub_1000798F4(uint8_t *buf, void *a2)
{
  *(_DWORD *)long long buf = 136315138;
  *a2 = "LoadFDRDataFileCMPM";
  _os_log_error_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR, "%s - Can't create /var/mobile/Library/ISP/CalData\n", buf, 0xCu);
}

void sub_100079948(uint8_t *buf, void *a2)
{
  *(_DWORD *)long long buf = 136315138;
  *a2 = "LoadFDRDataFileCMPM";
  _os_log_error_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR, "%s - Can't create /var/mobile/Library/ISP\n", buf, 0xCu);
}

void sub_10007999C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_100079A18(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(_WORD *)uint64_t v3 = 0;
  sub_100056DB4((void *)&_mh_execute_header, &_os_log_default, a3, "Couldn't read back camera module serial number. Sensor is hosed/disconnected. Skip loading OCCl calibration data\n", v3);
}

void sub_100079A58(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(_WORD *)uint64_t v3 = 0;
  sub_100056DB4((void *)&_mh_execute_header, &_os_log_default, a3, "Failed to copy model string from MobileGestalt\n", v3);
}

void sub_100079A98(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(_WORD *)uint64_t v3 = 0;
  sub_100056DB4((void *)&_mh_execute_header, &_os_log_default, a3, "Error opening ISP-ANE networks file\n", v3);
}

void sub_100079AD8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_100049A30((void *)&_mh_execute_header, &_os_log_default, a3, "Error sending ISP-ANE networks file to kernel: Size = %ld (== %ld ?); Status = %08x\n\n",
    a5,
    a6,
    a7,
    a8,
    0);
}

uint64_t sub_100079B64(char a1, uint64_t a2, uint64_t a3)
{
  *(_WORD *)uint8_t v5 = 0;
  sub_100056DB4((void *)&_mh_execute_header, &_os_log_default, a3, "No valid Yonkers key provisioning file to send\n", v5);
  return a1 & 1;
}

void sub_100079BB4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(_WORD *)uint64_t v3 = 0;
  sub_100056DB4((void *)&_mh_execute_header, &_os_log_default, a3, "could not read Yonkers key provisioning file entirely\n", v3);
}

uint64_t sub_100079BF4(char a1, uint64_t a2, uint64_t a3)
{
  *(_WORD *)uint8_t v5 = 0;
  sub_100056DB4((void *)&_mh_execute_header, &_os_log_default, a3, "No valid Savage firmware file to send\n", v5);
  return a1 & 1;
}

void sub_100079C44(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(_WORD *)uint64_t v3 = 0;
  sub_100056DB4((void *)&_mh_execute_header, &_os_log_default, a3, "could not read Savage firmware file entirely\n", v3);
}

void sub_100079C84()
{
  sub_100014FB8();
  sub_100014FCC((void *)&_mh_execute_header, &_os_log_default, v0, "%s - IOConnect Failed, status = 0x%08x\n", v1, v2, v3, v4, 2u);
}

void sub_100079D00(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_100079D7C(uint64_t a1, int *a2, _DWORD *a3)
{
  int v3 = *a2;
  int v4 = a3[1082];
  int v5 = a3[1083];
  int v6 = a3[1084];
  int v7 = a3[1085];
  int v8 = a3[1086];
  int v9 = a3[1087];
  int v10 = a3[1088];
  int v11 = 136317442;
  unint64_t v12 = "GetProcNameAndAuditToken";
  __int16 v13 = 2080;
  uint64_t v14 = a1;
  __int16 v15 = 1024;
  int v16 = v3;
  __int16 v17 = 1024;
  int v18 = v4;
  __int16 v19 = 1024;
  int v20 = v5;
  __int16 v21 = 1024;
  int v22 = v6;
  __int16 v23 = 1024;
  int v24 = v7;
  __int16 v25 = 1024;
  int v26 = v8;
  __int16 v27 = 1024;
  int v28 = v9;
  __int16 v29 = 1024;
  int v30 = v10;
  _os_log_debug_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEBUG, "%s - procNameForCIL:%s / audit_token:0x%08x/0x%08x/0x%08x/0x%08x/0x%08x/0x%08x/0x%08x/0x%08x\n", (uint8_t *)&v11, 0x46u);
}

void sub_100079E74(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_100079EF0()
{
  sub_100056E44();
  sub_10001AE80((void *)&_mh_execute_header, v0, v1, "Failed to report the ISP Flicker Detection to analyticsd: %08X\n\n", v2, v3, v4, v5, v6);
}

void sub_100079F58()
{
  sub_100056E44();
  sub_10001AE80((void *)&_mh_execute_header, v0, v1, "Failed to report the lens controller critical fault value to analyticsd: %08X\n\n", v2, v3, v4, v5, v6);
}

void sub_100079FC0()
{
  sub_100056E44();
  sub_10001AE80((void *)&_mh_execute_header, v0, v1, "Failed to report the Sensor Interface Error Statistics to analyticsd: %08X\n\n", v2, v3, v4, v5, v6);
}

void sub_10007A028()
{
  sub_100056E44();
  sub_10001AE80((void *)&_mh_execute_header, v0, v1, "Failed to send report to analyticsd: %08X\n\n", v2, v3, v4, v5, v6);
}

void sub_10007A090(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_10007A108(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_10007A174(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_10007A1E0()
{
  sub_100014FB8();
  sub_100014FCC((void *)&_mh_execute_header, v0, v1, "%s: Could not power off the ISP, res = 0x%x\n", v2, v3, v4, v5, 2u);
}

void sub_10007A254()
{
  sub_100014FB8();
  sub_100014FCC((void *)&_mh_execute_header, v0, v1, "%s: Could not release channel, res = 0x%x\n", v2, v3, v4, v5, 2u);
}

void sub_10007A2C8()
{
  sub_100014FB8();
  sub_100014FCC((void *)&_mh_execute_header, v0, v1, "%s: Savage Auth failed, res = 0x%x\n", v2, v3, v4, v5, 2u);
}

void sub_10007A33C()
{
  sub_100014FB8();
  sub_100014FCC((void *)&_mh_execute_header, v0, v1, "%s: Could not reserve channel, res = 0x%x\n", v2, v3, v4, v5, 2u);
}

void sub_10007A3B0()
{
  sub_100014FB8();
  sub_100014FCC((void *)&_mh_execute_header, v0, v1, "%s: Could not power on the ISP, res = 0x%x\n", v2, v3, v4, v5, 2u);
}

void sub_10007A424(_DWORD *a1, int a2)
{
  *a1 = 136315395;
  sub_10005C118((uint64_t)a1, a2, (uint64_t)"getProperty");
  _os_log_error_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_ERROR, "%s: Unable to create a reply dictionary (pid %{private}d)\n", v3, 0x12u);
}

void sub_10007A474(_DWORD *a1, int a2)
{
  *a1 = 136315395;
  sub_10005C118((uint64_t)a1, a2, (uint64_t)"getProperty");
  _os_log_error_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_ERROR, "%s: Unable to get the remote connection object (pid %{private}d)\n", v3, 0x12u);
}

void sub_10007A4C4(int *a1, uint8_t *buf, int a3, os_log_t log)
{
  int v4 = *a1;
  *(_DWORD *)long long buf = 136315651;
  *(void *)(buf + 4) = "getProperty";
  *((_WORD *)buf + 6) = 1025;
  *(_DWORD *)(buf + 14) = a3;
  *((_WORD *)buf + 9) = 1024;
  *((_DWORD *)buf + 5) = v4;
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "%s: Incoming query from client (pid %{private}d), num pending requests = %u\n\n", buf, 0x18u);
}

void sub_10007A534(xpc_connection_t *a1)
{
  xpc_connection_get_pid(*a1);
  sub_100056E44();
  sub_10005C0E4((void *)&_mh_execute_header, v1, v2, "Unable to create reply dictionary (pid %{private}d)\n", v3, v4, v5, v6, v7);
}

void sub_10007A5B4(xpc_connection_t *a1)
{
  xpc_connection_get_pid(*a1);
  sub_100056E44();
  sub_10005C0E4((void *)&_mh_execute_header, v1, v2, "Unable to look up remote connection (pid %{private}d)\n", v3, v4, v5, v6, v7);
}

void sub_10007A634(xpc_connection_t *a1, int a2, NSObject *a3)
{
  pid_t pid = xpc_connection_get_pid(*a1);
  v6[0] = 67109377;
  v6[1] = a2;
  __int16 v7 = 1025;
  pid_t v8 = pid;
  _os_log_error_impl((void *)&_mh_execute_header, a3, OS_LOG_TYPE_ERROR, "Unexpected client message=%d (pid %{private}d)\n", (uint8_t *)v6, 0xEu);
}

void sub_10007A6D8(xpc_connection_t *a1)
{
  xpc_connection_get_pid(*a1);
  sub_100056E44();
  sub_10005C0E4((void *)&_mh_execute_header, v1, v2, "Received XPC_ERROR_TERMINATION_IMMINENT error from client (pid %{private}d)\n", v3, v4, v5, v6, v7);
}

void sub_10007A754(xpc_connection_t *a1)
{
  xpc_connection_get_pid(*a1);
  sub_100056E44();
  sub_10005C0E4((void *)&_mh_execute_header, v1, v2, "Received XPC_ERROR_CONNECTION_INTERRUPTED error from client (pid %{private}d)\n", v3, v4, v5, v6, v7);
}

void sub_10007A7D0(xpc_connection_t *a1)
{
  xpc_connection_get_pid(*a1);
  sub_100056E44();
  sub_10005C0E4((void *)&_mh_execute_header, v1, v2, "Received unexpected error from client (pid %{private}d)\n", v3, v4, v5, v6, v7);
}

void sub_10007A84C(uint64_t a1)
{
  xpc_connection_get_pid(**(xpc_connection_t **)(a1 + 40));
  sub_100056E44();
  sub_10005C0E4((void *)&_mh_execute_header, v1, v2, "Received unknown event from client (pid %{private}d)\n", v3, v4, v5, v6, v7);
}

void sub_10007A8CC()
{
  sub_10001AE74();
  sub_10001AE58((void *)&_mh_execute_header, v0, v1, "Received XPC_ERROR_TERMINATION_IMMINENT, cleaning up assistant\n\n", v2, v3, v4, v5, v6);
}

void sub_10007A900()
{
  sub_10001AE74();
  sub_10001AE58((void *)&_mh_execute_header, v0, v1, "Received XPC_ERROR_CONNECTION_INVALID error on connection\n\n", v2, v3, v4, v5, v6);
}

void sub_10007A934()
{
  sub_10001AE74();
  sub_10001AE58((void *)&_mh_execute_header, v0, v1, "Received XPC_ERROR_CONNECTION_INTERRUPTED error on connection\n\n", v2, v3, v4, v5, v6);
}

void sub_10007A968(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_10007A9D4()
{
  sub_100014FB8();
  sub_100014FCC((void *)&_mh_execute_header, v0, v1, "%s - failed to load firmware ret=0x%08x\n", v2, v3, v4, v5, 2u);
}

void sub_10007AA48()
{
  sub_10005C104();
  sub_10001AE80((void *)&_mh_execute_header, v0, v1, "Error creating H16ISPDeviceController object: %08X\n", v2, v3, v4, v5, v6);
}

void sub_10007AAB4()
{
  sub_10005C104();
  sub_10001AE80((void *)&_mh_execute_header, v0, v1, "Error opening H16ISPDevice: %08X\n", v2, v3, v4, v5, v6);
}

void sub_10007AB20()
{
  sub_100056E44();
  sub_10001AE80((void *)&_mh_execute_header, v0, v1, "Failed to start work processor: %08X\n\n", v2, v3, v4, v5, v6);
}

void sub_10007AB88()
{
  sub_100056E44();
  sub_10001AE80((void *)&_mh_execute_header, v0, v1, "Failed to create work processor: %08X\n\n", v2, v3, v4, v5, v6);
}

void sub_10007ABF0()
{
  sub_10001AE74();
  sub_10001AE58((void *)&_mh_execute_header, v0, v1, "Failed to crate SIGTERM dispatch source\n", v2, v3, v4, v5, v6);
}

void sub_10007AC24()
{
  sub_10001AE74();
  sub_10001AE58((void *)&_mh_execute_header, v0, v1, "Unable to create mach service\n", v2, v3, v4, v5, v6);
}

void sub_10007AC58()
{
  __assert_rtn("LSCAverageGreenApple", "LSCComputeFromNVM.cpp", 1308, "pLSCConfig->channelGR.gridCountY == pLSCConfig->channelGB.gridCountY");
}

void sub_10007AC84()
{
  __assert_rtn("LSCAverageGreenApple", "LSCComputeFromNVM.cpp", 1307, "pLSCConfig->channelGR.gridCountX == pLSCConfig->channelGB.gridCountX");
}

uint64_t AMFDRCreateInstanceString()
{
  return _AMFDRCreateInstanceString();
}

uint64_t AMFDRLogSetHandler()
{
  return _AMFDRLogSetHandler();
}

uint64_t AMFDRSealingManifestCopyLocalDataForClass()
{
  return _AMFDRSealingManifestCopyLocalDataForClass();
}

uint64_t AMFDRSealingMapCopyLocalDataForClass()
{
  return _AMFDRSealingMapCopyLocalDataForClass();
}

uint64_t AMFDRSealingMapCopyLocalDictForClass()
{
  return _AMFDRSealingMapCopyLocalDictForClass();
}

uint64_t AMFDRSealingMapCopyLocalMinimalManifestForInstance()
{
  return _AMFDRSealingMapCopyLocalMinimalManifestForInstance();
}

uint64_t AMSupportDigestSha384()
{
  return _AMSupportDigestSha384();
}

AudioComponent AudioComponentFindNext(AudioComponent inComponent, const AudioComponentDescription *inDesc)
{
  return _AudioComponentFindNext(inComponent, inDesc);
}

OSStatus AudioComponentInstanceDispose(AudioComponentInstance inInstance)
{
  return _AudioComponentInstanceDispose(inInstance);
}

OSStatus AudioComponentInstanceNew(AudioComponent inComponent, AudioComponentInstance *outInstance)
{
  return _AudioComponentInstanceNew(inComponent, outInstance);
}

OSStatus AudioOutputUnitStart(AudioUnit ci)
{
  return _AudioOutputUnitStart(ci);
}

OSStatus AudioOutputUnitStop(AudioUnit ci)
{
  return _AudioOutputUnitStop(ci);
}

OSStatus AudioUnitGetProperty(AudioUnit inUnit, AudioUnitPropertyID inID, AudioUnitScope inScope, AudioUnitElement inElement, void *outData, UInt32 *ioDataSize)
{
  return _AudioUnitGetProperty(inUnit, inID, inScope, inElement, outData, ioDataSize);
}

OSStatus AudioUnitInitialize(AudioUnit inUnit)
{
  return _AudioUnitInitialize(inUnit);
}

OSStatus AudioUnitRender(AudioUnit inUnit, AudioUnitRenderActionFlags *ioActionFlags, const AudioTimeStamp *inTimeStamp, UInt32 inOutputBusNumber, UInt32 inNumberFrames, AudioBufferList *ioData)
{
  return _AudioUnitRender(inUnit, ioActionFlags, inTimeStamp, inOutputBusNumber, inNumberFrames, ioData);
}

OSStatus AudioUnitSetProperty(AudioUnit inUnit, AudioUnitPropertyID inID, AudioUnitScope inScope, AudioUnitElement inElement, const void *inData, UInt32 inDataSize)
{
  return _AudioUnitSetProperty(inUnit, inID, inScope, inElement, inData, inDataSize);
}

CFAbsoluteTime CFAbsoluteTimeGetCurrent(void)
{
  return _CFAbsoluteTimeGetCurrent();
}

void CFArrayAppendValue(CFMutableArrayRef theArray, const void *value)
{
}

void CFArrayApplyFunction(CFArrayRef theArray, CFRange range, CFArrayApplierFunction applier, void *context)
{
}

CFArrayRef CFArrayCreate(CFAllocatorRef allocator, const void **values, CFIndex numValues, const CFArrayCallBacks *callBacks)
{
  return _CFArrayCreate(allocator, values, numValues, callBacks);
}

CFMutableArrayRef CFArrayCreateMutable(CFAllocatorRef allocator, CFIndex capacity, const CFArrayCallBacks *callBacks)
{
  return _CFArrayCreateMutable(allocator, capacity, callBacks);
}

CFIndex CFArrayGetCount(CFArrayRef theArray)
{
  return _CFArrayGetCount(theArray);
}

CFTypeID CFArrayGetTypeID(void)
{
  return _CFArrayGetTypeID();
}

const void *__cdecl CFArrayGetValueAtIndex(CFArrayRef theArray, CFIndex idx)
{
  return _CFArrayGetValueAtIndex(theArray, idx);
}

void CFArraySetValueAtIndex(CFMutableArrayRef theArray, CFIndex idx, const void *value)
{
}

CFTypeID CFBooleanGetTypeID(void)
{
  return _CFBooleanGetTypeID();
}

Boolean CFBooleanGetValue(CFBooleanRef BOOLean)
{
  return _CFBooleanGetValue(BOOLean);
}

CFStringRef CFCopyDescription(CFTypeRef cf)
{
  return _CFCopyDescription(cf);
}

CFDataRef CFDataCreate(CFAllocatorRef allocator, const UInt8 *bytes, CFIndex length)
{
  return _CFDataCreate(allocator, bytes, length);
}

CFMutableDataRef CFDataCreateMutable(CFAllocatorRef allocator, CFIndex capacity)
{
  return _CFDataCreateMutable(allocator, capacity);
}

const UInt8 *__cdecl CFDataGetBytePtr(CFDataRef theData)
{
  return _CFDataGetBytePtr(theData);
}

void CFDataGetBytes(CFDataRef theData, CFRange range, UInt8 *buffer)
{
}

CFIndex CFDataGetLength(CFDataRef theData)
{
  return _CFDataGetLength(theData);
}

UInt8 *__cdecl CFDataGetMutableBytePtr(CFMutableDataRef theData)
{
  return _CFDataGetMutableBytePtr(theData);
}

CFTypeID CFDataGetTypeID(void)
{
  return _CFDataGetTypeID();
}

void CFDataSetLength(CFMutableDataRef theData, CFIndex length)
{
}

void CFDictionaryAddValue(CFMutableDictionaryRef theDict, const void *key, const void *value)
{
}

void CFDictionaryApplyFunction(CFDictionaryRef theDict, CFDictionaryApplierFunction applier, void *context)
{
}

CFDictionaryRef CFDictionaryCreate(CFAllocatorRef allocator, const void **keys, const void **values, CFIndex numValues, const CFDictionaryKeyCallBacks *keyCallBacks, const CFDictionaryValueCallBacks *valueCallBacks)
{
  return _CFDictionaryCreate(allocator, keys, values, numValues, keyCallBacks, valueCallBacks);
}

CFDictionaryRef CFDictionaryCreateCopy(CFAllocatorRef allocator, CFDictionaryRef theDict)
{
  return _CFDictionaryCreateCopy(allocator, theDict);
}

CFMutableDictionaryRef CFDictionaryCreateMutable(CFAllocatorRef allocator, CFIndex capacity, const CFDictionaryKeyCallBacks *keyCallBacks, const CFDictionaryValueCallBacks *valueCallBacks)
{
  return _CFDictionaryCreateMutable(allocator, capacity, keyCallBacks, valueCallBacks);
}

CFMutableDictionaryRef CFDictionaryCreateMutableCopy(CFAllocatorRef allocator, CFIndex capacity, CFDictionaryRef theDict)
{
  return _CFDictionaryCreateMutableCopy(allocator, capacity, theDict);
}

CFIndex CFDictionaryGetCount(CFDictionaryRef theDict)
{
  return _CFDictionaryGetCount(theDict);
}

void CFDictionaryGetKeysAndValues(CFDictionaryRef theDict, const void **keys, const void **values)
{
}

CFTypeID CFDictionaryGetTypeID(void)
{
  return _CFDictionaryGetTypeID();
}

const void *__cdecl CFDictionaryGetValue(CFDictionaryRef theDict, const void *key)
{
  return _CFDictionaryGetValue(theDict, key);
}

void CFDictionaryRemoveAllValues(CFMutableDictionaryRef theDict)
{
}

void CFDictionarySetValue(CFMutableDictionaryRef theDict, const void *key, const void *value)
{
}

Boolean CFEqual(CFTypeRef cf1, CFTypeRef cf2)
{
  return _CFEqual(cf1, cf2);
}

CFStringRef CFErrorCopyDescription(CFErrorRef err)
{
  return _CFErrorCopyDescription(err);
}

CFTypeID CFGetTypeID(CFTypeRef cf)
{
  return _CFGetTypeID(cf);
}

CFRunLoopSourceRef CFMachPortCreateRunLoopSource(CFAllocatorRef allocator, CFMachPortRef port, CFIndex order)
{
  return _CFMachPortCreateRunLoopSource(allocator, port, order);
}

CFMachPortRef CFMachPortCreateWithPort(CFAllocatorRef allocator, mach_port_t portNum, CFMachPortCallBack callout, CFMachPortContext *context, Boolean *shouldFreeInfo)
{
  return _CFMachPortCreateWithPort(allocator, portNum, callout, context, shouldFreeInfo);
}

void CFMachPortInvalidate(CFMachPortRef port)
{
}

CFRunLoopSourceRef CFMessagePortCreateRunLoopSource(CFAllocatorRef allocator, CFMessagePortRef local, CFIndex order)
{
  return _CFMessagePortCreateRunLoopSource(allocator, local, order);
}

CFNumberRef CFNumberCreate(CFAllocatorRef allocator, CFNumberType theType, const void *valuePtr)
{
  return _CFNumberCreate(allocator, theType, valuePtr);
}

CFNumberType CFNumberGetType(CFNumberRef number)
{
  return _CFNumberGetType(number);
}

CFTypeID CFNumberGetTypeID(void)
{
  return _CFNumberGetTypeID();
}

Boolean CFNumberGetValue(CFNumberRef number, CFNumberType theType, void *valuePtr)
{
  return _CFNumberGetValue(number, theType, valuePtr);
}

Boolean CFNumberIsFloatType(CFNumberRef number)
{
  return _CFNumberIsFloatType(number);
}

CFPropertyListRef CFPreferencesCopyValue(CFStringRef key, CFStringRef applicationID, CFStringRef userName, CFStringRef hostName)
{
  return _CFPreferencesCopyValue(key, applicationID, userName, hostName);
}

CFPropertyListRef CFPropertyListCreateWithStream(CFAllocatorRef allocator, CFReadStreamRef stream, CFIndex streamLength, CFOptionFlags options, CFPropertyListFormat *format, CFErrorRef *error)
{
  return _CFPropertyListCreateWithStream(allocator, stream, streamLength, options, format, error);
}

CFIndex CFPropertyListWrite(CFPropertyListRef propertyList, CFWriteStreamRef stream, CFPropertyListFormat format, CFOptionFlags options, CFErrorRef *error)
{
  return _CFPropertyListWrite(propertyList, stream, format, options, error);
}

void CFReadStreamClose(CFReadStreamRef stream)
{
}

CFReadStreamRef CFReadStreamCreateWithFile(CFAllocatorRef alloc, CFURLRef fileURL)
{
  return _CFReadStreamCreateWithFile(alloc, fileURL);
}

Boolean CFReadStreamOpen(CFReadStreamRef stream)
{
  return _CFReadStreamOpen(stream);
}

void CFRelease(CFTypeRef cf)
{
}

CFTypeRef CFRetain(CFTypeRef cf)
{
  return _CFRetain(cf);
}

void CFRunLoopAddSource(CFRunLoopRef rl, CFRunLoopSourceRef source, CFRunLoopMode mode)
{
}

CFRunLoopRef CFRunLoopGetCurrent(void)
{
  return _CFRunLoopGetCurrent();
}

void CFRunLoopRemoveSource(CFRunLoopRef rl, CFRunLoopSourceRef source, CFRunLoopMode mode)
{
}

void CFRunLoopRun(void)
{
}

void CFRunLoopStop(CFRunLoopRef rl)
{
}

void CFRunLoopTimerInvalidate(CFRunLoopTimerRef timer)
{
}

void CFRunLoopTimerSetNextFireDate(CFRunLoopTimerRef timer, CFAbsoluteTime fireDate)
{
}

void CFShow(CFTypeRef obj)
{
}

CFComparisonResult CFStringCompare(CFStringRef theString1, CFStringRef theString2, CFStringCompareFlags compareOptions)
{
  return _CFStringCompare(theString1, theString2, compareOptions);
}

CFMutableStringRef CFStringCreateMutableCopy(CFAllocatorRef alloc, CFIndex maxLength, CFStringRef theString)
{
  return _CFStringCreateMutableCopy(alloc, maxLength, theString);
}

CFStringRef CFStringCreateWithCString(CFAllocatorRef alloc, const char *cStr, CFStringEncoding encoding)
{
  return _CFStringCreateWithCString(alloc, cStr, encoding);
}

CFStringRef CFStringCreateWithFormat(CFAllocatorRef alloc, CFDictionaryRef formatOptions, CFStringRef format, ...)
{
  return _CFStringCreateWithFormat(alloc, formatOptions, format);
}

CFStringRef CFStringCreateWithSubstring(CFAllocatorRef alloc, CFStringRef str, CFRange range)
{
  return _CFStringCreateWithSubstring(alloc, str, range);
}

Boolean CFStringGetCString(CFStringRef theString, char *buffer, CFIndex bufferSize, CFStringEncoding encoding)
{
  return _CFStringGetCString(theString, buffer, bufferSize, encoding);
}

const char *__cdecl CFStringGetCStringPtr(CFStringRef theString, CFStringEncoding encoding)
{
  return _CFStringGetCStringPtr(theString, encoding);
}

SInt32 CFStringGetIntValue(CFStringRef str)
{
  return _CFStringGetIntValue(str);
}

CFIndex CFStringGetLength(CFStringRef theString)
{
  return _CFStringGetLength(theString);
}

CFStringEncoding CFStringGetSystemEncoding(void)
{
  return _CFStringGetSystemEncoding();
}

CFTypeID CFStringGetTypeID(void)
{
  return _CFStringGetTypeID();
}

Boolean CFStringHasSuffix(CFStringRef theString, CFStringRef suffix)
{
  return _CFStringHasSuffix(theString, suffix);
}

void CFStringLowercase(CFMutableStringRef theString, CFLocaleRef locale)
{
}

CFURLRef CFURLCreateWithFileSystemPath(CFAllocatorRef allocator, CFStringRef filePath, CFURLPathStyle pathStyle, Boolean isDirectory)
{
  return _CFURLCreateWithFileSystemPath(allocator, filePath, pathStyle, isDirectory);
}

void CFWriteStreamClose(CFWriteStreamRef stream)
{
}

CFWriteStreamRef CFWriteStreamCreateWithFile(CFAllocatorRef alloc, CFURLRef fileURL)
{
  return _CFWriteStreamCreateWithFile(alloc, fileURL);
}

Boolean CFWriteStreamOpen(CFWriteStreamRef stream)
{
  return _CFWriteStreamOpen(stream);
}

CFDictionaryRef CGRectCreateDictionaryRepresentation(CGRect a1)
{
  return _CGRectCreateDictionaryRepresentation(a1);
}

BOOL CGRectMakeWithDictionaryRepresentation(CFDictionaryRef dict, CGRect *rect)
{
  return _CGRectMakeWithDictionaryRepresentation(dict, rect);
}

CFDictionaryRef CGSizeCreateDictionaryRepresentation(CGSize size)
{
  return _CGSizeCreateDictionaryRepresentation(size);
}

CVImageBufferRef CMSampleBufferGetImageBuffer(CMSampleBufferRef sbuf)
{
  return _CMSampleBufferGetImageBuffer(sbuf);
}

CMTime *__cdecl CMSampleBufferGetPresentationTimeStamp(CMTime *__return_ptr retstr, CMSampleBufferRef sbuf)
{
  return _CMSampleBufferGetPresentationTimeStamp(retstr, sbuf);
}

Float64 CMTimeGetSeconds(CMTime *time)
{
  return _CMTimeGetSeconds(time);
}

CMTime *__cdecl CMTimeMakeFromDictionary(CMTime *__return_ptr retstr, CFDictionaryRef dictionaryRepresentation)
{
  return _CMTimeMakeFromDictionary(retstr, dictionaryRepresentation);
}

uint64_t CRGetComponentState()
{
  return _CRGetComponentState();
}

void CVBufferRelease(CVBufferRef buffer)
{
}

CVReturn CVPixelBufferCreate(CFAllocatorRef allocator, size_t width, size_t height, OSType pixelFormatType, CFDictionaryRef pixelBufferAttributes, CVPixelBufferRef *pixelBufferOut)
{
  return _CVPixelBufferCreate(allocator, width, height, pixelFormatType, pixelBufferAttributes, pixelBufferOut);
}

uint64_t CVPixelBufferCreateFromCVImageBufferRef()
{
  return _CVPixelBufferCreateFromCVImageBufferRef();
}

CVReturn CVPixelBufferCreateWithIOSurface(CFAllocatorRef allocator, IOSurfaceRef surface, CFDictionaryRef pixelBufferAttributes, CVPixelBufferRef *pixelBufferOut)
{
  return _CVPixelBufferCreateWithIOSurface(allocator, surface, pixelBufferAttributes, pixelBufferOut);
}

void *__cdecl CVPixelBufferGetBaseAddress(CVPixelBufferRef pixelBuffer)
{
  return _CVPixelBufferGetBaseAddress(pixelBuffer);
}

void *__cdecl CVPixelBufferGetBaseAddressOfPlane(CVPixelBufferRef pixelBuffer, size_t planeIndex)
{
  return _CVPixelBufferGetBaseAddressOfPlane(pixelBuffer, planeIndex);
}

size_t CVPixelBufferGetBytesPerRow(CVPixelBufferRef pixelBuffer)
{
  return _CVPixelBufferGetBytesPerRow(pixelBuffer);
}

size_t CVPixelBufferGetBytesPerRowOfPlane(CVPixelBufferRef pixelBuffer, size_t planeIndex)
{
  return _CVPixelBufferGetBytesPerRowOfPlane(pixelBuffer, planeIndex);
}

size_t CVPixelBufferGetDataSize(CVPixelBufferRef pixelBuffer)
{
  return _CVPixelBufferGetDataSize(pixelBuffer);
}

size_t CVPixelBufferGetHeight(CVPixelBufferRef pixelBuffer)
{
  return _CVPixelBufferGetHeight(pixelBuffer);
}

size_t CVPixelBufferGetHeightOfPlane(CVPixelBufferRef pixelBuffer, size_t planeIndex)
{
  return _CVPixelBufferGetHeightOfPlane(pixelBuffer, planeIndex);
}

OSType CVPixelBufferGetPixelFormatType(CVPixelBufferRef pixelBuffer)
{
  return _CVPixelBufferGetPixelFormatType(pixelBuffer);
}

size_t CVPixelBufferGetPlaneCount(CVPixelBufferRef pixelBuffer)
{
  return _CVPixelBufferGetPlaneCount(pixelBuffer);
}

size_t CVPixelBufferGetWidth(CVPixelBufferRef pixelBuffer)
{
  return _CVPixelBufferGetWidth(pixelBuffer);
}

size_t CVPixelBufferGetWidthOfPlane(CVPixelBufferRef pixelBuffer, size_t planeIndex)
{
  return _CVPixelBufferGetWidthOfPlane(pixelBuffer, planeIndex);
}

CVReturn CVPixelBufferLockBaseAddress(CVPixelBufferRef pixelBuffer, CVPixelBufferLockFlags lockFlags)
{
  return _CVPixelBufferLockBaseAddress(pixelBuffer, lockFlags);
}

void CVPixelBufferRelease(CVPixelBufferRef texture)
{
}

CVPixelBufferRef CVPixelBufferRetain(CVPixelBufferRef texture)
{
  return _CVPixelBufferRetain(texture);
}

CVReturn CVPixelBufferUnlockBaseAddress(CVPixelBufferRef pixelBuffer, CVPixelBufferLockFlags unlockFlags)
{
  return _CVPixelBufferUnlockBaseAddress(pixelBuffer, unlockFlags);
}

uint64_t FigHostTimeToNanoseconds()
{
  return _FigHostTimeToNanoseconds();
}

kern_return_t IOConnectCallAsyncMethod(mach_port_t connection, uint32_t selector, mach_port_t wake_port, uint64_t *reference, uint32_t referenceCnt, const uint64_t *input, uint32_t inputCnt, const void *inputStruct, size_t inputStructCnt, uint64_t *output, uint32_t *outputCnt, void *outputStruct, size_t *outputStructCnt)
{
  return _IOConnectCallAsyncMethod(connection, selector, wake_port, reference, referenceCnt, input, inputCnt, inputStruct, inputStructCnt, output, outputCnt, outputStruct, outputStructCnt);
}

kern_return_t IOConnectCallMethod(mach_port_t connection, uint32_t selector, const uint64_t *input, uint32_t inputCnt, const void *inputStruct, size_t inputStructCnt, uint64_t *output, uint32_t *outputCnt, void *outputStruct, size_t *outputStructCnt)
{
  return _IOConnectCallMethod(connection, selector, input, inputCnt, inputStruct, inputStructCnt, output, outputCnt, outputStruct, outputStructCnt);
}

kern_return_t IOConnectCallScalarMethod(mach_port_t connection, uint32_t selector, const uint64_t *input, uint32_t inputCnt, uint64_t *output, uint32_t *outputCnt)
{
  return _IOConnectCallScalarMethod(connection, selector, input, inputCnt, output, outputCnt);
}

kern_return_t IOConnectCallStructMethod(mach_port_t connection, uint32_t selector, const void *inputStruct, size_t inputStructCnt, void *outputStruct, size_t *outputStructCnt)
{
  return _IOConnectCallStructMethod(connection, selector, inputStruct, inputStructCnt, outputStruct, outputStructCnt);
}

kern_return_t IOCreateReceivePort(uint32_t msgType, mach_port_t *recvPort)
{
  return _IOCreateReceivePort(msgType, recvPort);
}

uint64_t IOHIDEventGetFloatValue()
{
  return _IOHIDEventGetFloatValue();
}

uint64_t IOHIDEventGetType()
{
  return _IOHIDEventGetType();
}

uint64_t IOHIDEventSystemClientActivate()
{
  return _IOHIDEventSystemClientActivate();
}

uint64_t IOHIDEventSystemClientCancel()
{
  return _IOHIDEventSystemClientCancel();
}

uint64_t IOHIDEventSystemClientCreateWithType()
{
  return _IOHIDEventSystemClientCreateWithType();
}

uint64_t IOHIDEventSystemClientRegisterEventCallback()
{
  return _IOHIDEventSystemClientRegisterEventCallback();
}

uint64_t IOHIDEventSystemClientSetCancelHandler()
{
  return _IOHIDEventSystemClientSetCancelHandler();
}

uint64_t IOHIDEventSystemClientSetDispatchQueue()
{
  return _IOHIDEventSystemClientSetDispatchQueue();
}

uint64_t IOHIDEventSystemClientSetMatchingMultiple()
{
  return _IOHIDEventSystemClientSetMatchingMultiple();
}

uint64_t IOHIDEventSystemClientUnregisterEventCallback()
{
  return _IOHIDEventSystemClientUnregisterEventCallback();
}

uint64_t IOHIDEventSystemClientUnscheduleFromDispatchQueue()
{
  return _IOHIDEventSystemClientUnscheduleFromDispatchQueue();
}

CFTypeRef IOHIDServiceClientCopyProperty(IOHIDServiceClientRef service, CFStringRef key)
{
  return _IOHIDServiceClientCopyProperty(service, key);
}

io_object_t IOIteratorNext(io_iterator_t iterator)
{
  return _IOIteratorNext(iterator);
}

kern_return_t IOMasterPort(mach_port_t bootstrapPort, mach_port_t *mainPort)
{
  return _IOMasterPort(bootstrapPort, mainPort);
}

IONotificationPortRef IONotificationPortCreate(mach_port_t mainPort)
{
  return _IONotificationPortCreate(mainPort);
}

void IONotificationPortDestroy(IONotificationPortRef notify)
{
}

CFRunLoopSourceRef IONotificationPortGetRunLoopSource(IONotificationPortRef notify)
{
  return _IONotificationPortGetRunLoopSource(notify);
}

kern_return_t IOObjectRelease(io_object_t object)
{
  return _IOObjectRelease(object);
}

kern_return_t IORegistryEntryCreateCFProperties(io_registry_entry_t entry, CFMutableDictionaryRef *properties, CFAllocatorRef allocator, IOOptionBits options)
{
  return _IORegistryEntryCreateCFProperties(entry, properties, allocator, options);
}

CFTypeRef IORegistryEntryCreateCFProperty(io_registry_entry_t entry, CFStringRef key, CFAllocatorRef allocator, IOOptionBits options)
{
  return _IORegistryEntryCreateCFProperty(entry, key, allocator, options);
}

io_registry_entry_t IORegistryEntryFromPath(mach_port_t mainPort, const io_string_t path)
{
  return _IORegistryEntryFromPath(mainPort, path);
}

CFTypeRef IORegistryEntrySearchCFProperty(io_registry_entry_t entry, const io_name_t plane, CFStringRef key, CFAllocatorRef allocator, IOOptionBits options)
{
  return _IORegistryEntrySearchCFProperty(entry, plane, key, allocator, options);
}

kern_return_t IOServiceAddInterestNotification(IONotificationPortRef notifyPort, io_service_t service, const io_name_t interestType, IOServiceInterestCallback callback, void *refCon, io_object_t *notification)
{
  return _IOServiceAddInterestNotification(notifyPort, service, interestType, callback, refCon, notification);
}

kern_return_t IOServiceAddMatchingNotification(IONotificationPortRef notifyPort, const io_name_t notificationType, CFDictionaryRef matching, IOServiceMatchingCallback callback, void *refCon, io_iterator_t *notification)
{
  return _IOServiceAddMatchingNotification(notifyPort, notificationType, matching, callback, refCon, notification);
}

kern_return_t IOServiceClose(io_connect_t connect)
{
  return _IOServiceClose(connect);
}

io_service_t IOServiceGetMatchingService(mach_port_t mainPort, CFDictionaryRef matching)
{
  return _IOServiceGetMatchingService(mainPort, matching);
}

CFMutableDictionaryRef IOServiceMatching(const char *name)
{
  return _IOServiceMatching(name);
}

CFMutableDictionaryRef IOServiceNameMatching(const char *name)
{
  return _IOServiceNameMatching(name);
}

kern_return_t IOServiceOpen(io_service_t service, task_port_t owningTask, uint32_t type, io_connect_t *connect)
{
  return _IOServiceOpen(service, owningTask, type, connect);
}

kern_return_t IOSurfaceLock(IOSurfaceRef buffer, IOSurfaceLockOptions options, uint32_t *seed)
{
  return _IOSurfaceLock(buffer, options, seed);
}

IOSurfaceRef IOSurfaceLookupFromXPCObject(xpc_object_t xobj)
{
  return _IOSurfaceLookupFromXPCObject(xobj);
}

kern_return_t IOSurfaceUnlock(IOSurfaceRef buffer, IOSurfaceLockOptions options, uint32_t *seed)
{
  return _IOSurfaceUnlock(buffer, options, seed);
}

uint64_t MGCopyAnswer()
{
  return _MGCopyAnswer();
}

uint64_t MGCopyAnswerWithError()
{
  return _MGCopyAnswerWithError();
}

uint64_t MGIsQuestionValid()
{
  return _MGIsQuestionValid();
}

id MTLCreateSystemDefaultDevice(void)
{
  return _MTLCreateSystemDefaultDevice();
}

void NSLog(NSString *format, ...)
{
}

uint64_t PDPeridotCalibCalibrationBlobsFromNVM()
{
  return _PDPeridotCalibCalibrationBlobsFromNVM();
}

uint64_t PDPeridotCalibCopySerialNumber()
{
  return _PDPeridotCalibCopySerialNumber();
}

uint64_t PDPeridotCalibCreateBinaryRepresentation()
{
  return _PDPeridotCalibCreateBinaryRepresentation();
}

uint64_t PDPeridotCalibCreateIspFirmwareCalibWithOptions()
{
  return _PDPeridotCalibCreateIspFirmwareCalibWithOptions();
}

uint64_t PDPeridotCalibCreateWithBinaryRepresentation()
{
  return _PDPeridotCalibCreateWithBinaryRepresentation();
}

uint64_t PDPeridotCalibCreateWithCalibrationDictionary()
{
  return _PDPeridotCalibCreateWithCalibrationDictionary();
}

uint64_t PDPeridotCalibGetFactoryWideToPeridotTransform()
{
  return _PDPeridotCalibGetFactoryWideToPeridotTransform();
}

uint64_t PDPeridotCalibGetMpcUUID()
{
  return _PDPeridotCalibGetMpcUUID();
}

uint64_t PDPeridotCalibGetMpcUUIDFromCalibrationBlob()
{
  return _PDPeridotCalibGetMpcUUIDFromCalibrationBlob();
}

uint64_t PDPeridotCalibGetOperationalWideToPeridotTransform()
{
  return _PDPeridotCalibGetOperationalWideToPeridotTransform();
}

uint64_t PDPeridotCalibResetStray()
{
  return _PDPeridotCalibResetStray();
}

uint64_t PDPeridotCalibSetOperationalWideToPeridotTransform()
{
  return _PDPeridotCalibSetOperationalWideToPeridotTransform();
}

OSStatus VTPixelTransferSessionCreate(CFAllocatorRef allocator, VTPixelTransferSessionRef *pixelTransferSessionOut)
{
  return _VTPixelTransferSessionCreate(allocator, pixelTransferSessionOut);
}

void VTPixelTransferSessionInvalidate(VTPixelTransferSessionRef session)
{
}

OSStatus VTPixelTransferSessionTransferImage(VTPixelTransferSessionRef session, CVPixelBufferRef sourceBuffer, CVPixelBufferRef destinationBuffer)
{
  return _VTPixelTransferSessionTransferImage(session, sourceBuffer, destinationBuffer);
}

void _Block_object_assign(void *a1, const void *a2, const int a3)
{
}

void _Block_object_dispose(const void *a1, const int a2)
{
}

void _Unwind_Resume(_Unwind_Exception *exception_object)
{
}

const std::locale::facet *__cdecl std::locale::use_facet(const std::locale *this, std::locale::id *a2)
{
  return std::locale::use_facet(this, a2);
}

std::locale std::ios_base::getloc(const std::ios_base *this)
{
  return std::ios_base::getloc(this);
}

std::logic_error *__cdecl std::logic_error::logic_error(std::logic_error *this, const char *a2)
{
  return std::logic_error::logic_error(this, a2);
}

std::bad_array_new_length *__cdecl std::bad_array_new_length::bad_array_new_length(std::bad_array_new_length *this)
{
  return std::bad_array_new_length::bad_array_new_length(this);
}

void std::string::__grow_by_and_replace(std::string *this, std::string::size_type __old_cap, std::string::size_type __delta_cap, std::string::size_type __old_sz, std::string::size_type __n_copy, std::string::size_type __n_del, std::string::size_type __n_add, const std::string::value_type *__p_new_stuff)
{
}

std::string *__cdecl std::string::append(std::string *this, const std::string::value_type *__s, std::string::size_type __n)
{
  return std::string::append(this, __s, __n);
}

void std::string::push_back(std::string *this, std::string::value_type __c)
{
}

uint64_t std::filebuf::close()
{
  return std::filebuf::close();
}

uint64_t std::filebuf::basic_filebuf()
{
  return std::filebuf::basic_filebuf();
}

uint64_t std::filebuf::~filebuf()
{
  return std::filebuf::~filebuf();
}

uint64_t std::ostream::put()
{
  return std::ostream::put();
}

uint64_t std::ostream::flush()
{
  return std::ostream::flush();
}

uint64_t std::ostream::write()
{
  return std::ostream::write();
}

uint64_t std::ostream::sentry::sentry()
{
  return std::ostream::sentry::sentry();
}

uint64_t std::ostream::sentry::~sentry()
{
  return std::ostream::sentry::~sentry();
}

uint64_t std::ostream::~ostream()
{
  return std::ostream::~ostream();
}

uint64_t std::ostream::operator<<()
{
  return std::ostream::operator<<();
}

{
  return std::ostream::operator<<();
}

uint64_t std::ofstream::open()
{
  return std::ofstream::open();
}

void std::mutex::lock(std::mutex *this)
{
}

void std::mutex::unlock(std::mutex *this)
{
}

void std::mutex::~mutex(std::mutex *this)
{
}

std::chrono::steady_clock::time_point std::chrono::steady_clock::now(void)
{
  return std::chrono::steady_clock::now();
}

std::chrono::system_clock::time_point std::chrono::system_clock::now(void)
{
  return std::chrono::system_clock::now();
}

void std::locale::~locale(std::locale *this)
{
}

void std::ios_base::__set_badbit_and_consider_rethrow(std::ios_base *this)
{
}

void std::ios_base::init(std::ios_base *this, void *__sb)
{
}

void std::ios_base::clear(std::ios_base *this, std::ios_base::iostate __state)
{
}

uint64_t std::ios::~ios()
{
  return std::ios::~ios();
}

void std::terminate(void)
{
}

void operator delete[]()
{
  while (1)
    ;
}

void operator delete(void *__p)
{
  while (1)
    ;
}

void operator delete()
{
  while (1)
    ;
}

void operator new[]()
{
  while (1)
    ;
}

void *__cdecl operator new(size_t __sz)
{
  while (1)
    ;
}

void operator new()
{
  while (1)
    ;
}

void __assert_rtn(const char *a1, const char *a2, int a3, const char *a4)
{
}

void *__cxa_allocate_exception(size_t thrown_size)
{
  return ___cxa_allocate_exception(thrown_size);
}

int __cxa_atexit(void (*lpfunc)(void *), void *obj, void *lpdso_handle)
{
  return ___cxa_atexit(lpfunc, obj, lpdso_handle);
}

void *__cxa_begin_catch(void *a1)
{
  return ___cxa_begin_catch(a1);
}

void __cxa_end_catch(void)
{
}

void __cxa_free_exception(void *a1)
{
}

void __cxa_throw(void *a1, struct type_info *lptinfo, void (*a3)(void *))
{
}

int *__error(void)
{
  return ___error();
}

__double2 __sincos_stret(double a1)
{
  __double2 v3 = ___sincos_stret(a1);
  double cosval = v3.__cosval;
  double sinval = v3.__sinval;
  result.__double cosval = cosval;
  result.__double sinval = sinval;
  return result;
}

void _os_log_debug_impl(void *dso, os_log_t log, os_log_type_t type, const char *format, uint8_t *buf, uint32_t size)
{
}

void _os_log_error_impl(void *dso, os_log_t log, os_log_type_t type, const char *format, uint8_t *buf, uint32_t size)
{
}

void _os_log_impl(void *dso, os_log_t log, os_log_type_t type, const char *format, uint8_t *buf, uint32_t size)
{
}

long double acos(long double __x)
{
  return _acos(__x);
}

uint64_t analytics_send_event_lazy()
{
  return _analytics_send_event_lazy();
}

uint32_t arc4random_uniform(uint32_t __upper_bound)
{
  return _arc4random_uniform(__upper_bound);
}

long double atan(long double __x)
{
  return _atan(__x);
}

long double atan2(long double __y, long double __x)
{
  return _atan2(__y, __x);
}

int bcmp(const void *a1, const void *a2, size_t a3)
{
  return _bcmp(a1, a2, a3);
}

uint64_t bfpn_create_correction_model_from_fdr()
{
  return _bfpn_create_correction_model_from_fdr();
}

void bzero(void *a1, size_t a2)
{
}

int clock_gettime(clockid_t __clock_id, timespec *__tp)
{
  return _clock_gettime(__clock_id, __tp);
}

int close(int a1)
{
  return _close(a1);
}

size_t compression_decode_buffer(uint8_t *dst_buffer, size_t dst_size, const uint8_t *src_buffer, size_t src_size, void *scratch_buffer, compression_algorithm algorithm)
{
  return _compression_decode_buffer(dst_buffer, dst_size, src_buffer, src_size, scratch_buffer, algorithm);
}

long double cos(long double __x)
{
  return _cos(__x);
}

float cosf(float a1)
{
  return _cosf(a1);
}

double difftime(time_t a1, time_t a2)
{
  return _difftime(a1, a2);
}

char *__cdecl dirname(char *a1)
{
  return _dirname(a1);
}

void dispatch_async(dispatch_queue_t queue, dispatch_block_t block)
{
}

void dispatch_group_async(dispatch_group_t group, dispatch_queue_t queue, dispatch_block_t block)
{
}

dispatch_group_t dispatch_group_create(void)
{
  return _dispatch_group_create();
}

intptr_t dispatch_group_wait(dispatch_group_t group, dispatch_time_t timeout)
{
  return _dispatch_group_wait(group, timeout);
}

void dispatch_main(void)
{
}

dispatch_queue_attr_t dispatch_queue_attr_make_with_qos_class(dispatch_queue_attr_t attr, dispatch_qos_class_t qos_class, int relative_priority)
{
  return _dispatch_queue_attr_make_with_qos_class(attr, qos_class, relative_priority);
}

dispatch_queue_t dispatch_queue_create(const char *label, dispatch_queue_attr_t attr)
{
  return _dispatch_queue_create(label, attr);
}

void dispatch_release(dispatch_object_t object)
{
}

void dispatch_resume(dispatch_object_t object)
{
}

void dispatch_source_cancel(dispatch_source_t source)
{
}

dispatch_source_t dispatch_source_create(dispatch_source_type_t type, uintptr_t handle, uintptr_t mask, dispatch_queue_t queue)
{
  return _dispatch_source_create(type, handle, mask, queue);
}

void dispatch_source_set_event_handler(dispatch_source_t source, dispatch_block_t handler)
{
}

void dispatch_source_set_timer(dispatch_source_t source, dispatch_time_t start, uint64_t interval, uint64_t leeway)
{
}

void dispatch_suspend(dispatch_object_t object)
{
}

void dispatch_sync(dispatch_queue_t queue, dispatch_block_t block)
{
}

void exit(int a1)
{
}

float expf(float a1)
{
  return _expf(a1);
}

int fclose(FILE *a1)
{
  return _fclose(a1);
}

int fcntl(int a1, int a2, ...)
{
  return _fcntl(a1, a2);
}

FILE *__cdecl fdopen(int a1, const char *a2)
{
  return _fdopen(a1, a2);
}

int fflush(FILE *a1)
{
  return _fflush(a1);
}

char *__cdecl fgets(char *a1, int a2, FILE *a3)
{
  return _fgets(a1, a2, a3);
}

FILE *__cdecl fopen(const char *__filename, const char *__mode)
{
  return _fopen(__filename, __mode);
}

int fprintf(FILE *a1, const char *a2, ...)
{
  return _fprintf(a1, a2);
}

size_t fread(void *__ptr, size_t __size, size_t __nitems, FILE *__stream)
{
  return _fread(__ptr, __size, __nitems, __stream);
}

void free(void *a1)
{
}

int fseeko(FILE *__stream, off_t a2, int __whence)
{
  return _fseeko(__stream, a2, __whence);
}

off_t ftello(FILE *__stream)
{
  return _ftello(__stream);
}

size_t fwrite(const void *__ptr, size_t __size, size_t __nitems, FILE *__stream)
{
  return _fwrite(__ptr, __size, __nitems, __stream);
}

pid_t getpid(void)
{
  return _getpid();
}

uint64_t kdebug_trace()
{
  return _kdebug_trace();
}

long double ldexp(long double __x, int __e)
{
  return _ldexp(__x, __e);
}

tm *__cdecl localtime(const time_t *a1)
{
  return _localtime(a1);
}

long double log(long double __x)
{
  return _log(__x);
}

float log10f(float a1)
{
  return _log10f(a1);
}

long double log2(long double __x)
{
  return _log2(__x);
}

float log2f(float a1)
{
  return _log2f(a1);
}

off_t lseek(int a1, off_t a2, int a3)
{
  return _lseek(a1, a2, a3);
}

uint64_t mach_absolute_time(void)
{
  return _mach_absolute_time();
}

uint64_t mach_continuous_time(void)
{
  return _mach_continuous_time();
}

kern_return_t mach_port_mod_refs(ipc_space_t task, mach_port_name_t name, mach_port_right_t right, mach_port_delta_t delta)
{
  return _mach_port_mod_refs(task, name, right, delta);
}

kern_return_t mach_timebase_info(mach_timebase_info_t info)
{
  return _mach_timebase_info(info);
}

void *__cdecl malloc_type_calloc(size_t count, size_t size, malloc_type_id_t type_id)
{
  return _malloc_type_calloc(count, size, type_id);
}

void *__cdecl malloc_type_malloc(size_t size, malloc_type_id_t type_id)
{
  return _malloc_type_malloc(size, type_id);
}

int memcmp(const void *__s1, const void *__s2, size_t __n)
{
  return _memcmp(__s1, __s2, __n);
}

void *__cdecl memcpy(void *__dst, const void *__src, size_t __n)
{
  return _memcpy(__dst, __src, __n);
}

void *__cdecl memmove(void *__dst, const void *__src, size_t __len)
{
  return _memmove(__dst, __src, __len);
}

void *__cdecl memset(void *__b, int __c, size_t __len)
{
  return _memset(__b, __c, __len);
}

int mkdir(const char *a1, mode_t a2)
{
  return _mkdir(a1, a2);
}

int mkpath_np(const char *path, mode_t omode)
{
  return _mkpath_np(path, omode);
}

uint32_t notify_cancel(int token)
{
  return _notify_cancel(token);
}

uint32_t notify_post(const char *name)
{
  return _notify_post(name);
}

uint32_t notify_register_check(const char *name, int *out_token)
{
  return _notify_register_check(name, out_token);
}

uint32_t notify_set_state(int token, uint64_t state64)
{
  return _notify_set_state(token, state64);
}

id objc_alloc(Class a1)
{
  return _[a1 alloc];
}

uint64_t objc_alloc_init()
{
  return _objc_alloc_init();
}

id objc_autorelease(id a1)
{
  return _objc_autorelease(a1);
}

{
}

{
}

uint64_t objc_claimAutoreleasedReturnValue()
{
  return _objc_claimAutoreleasedReturnValue();
}

void objc_enumerationMutation(id obj)
{
}

id objc_msgSendSuper2(objc_super *a1, SEL a2, ...)
{
  return [super a2];
}

uint64_t objc_opt_class()
{
  return _objc_opt_class();
}

uint64_t objc_opt_isKindOfClass()
{
  return _objc_opt_isKindOfClass();
}

uint64_t objc_opt_new()
{
  return _objc_opt_new();
}

uint64_t objc_opt_respondsToSelector()
{
  return _objc_opt_respondsToSelector();
}

void objc_release(id a1)
{
}

id objc_retain(id a1)
{
  return _objc_retain(a1);
}

id objc_retainAutorelease(id a1)
{
  return _a1;
}

void objc_storeStrong(id *location, id obj)
{
}

int open(const char *a1, int a2, ...)
{
  return _open(a1, a2);
}

int open_dprotected_np(const char *a1, int a2, int a3, int a4, ...)
{
  return _open_dprotected_np(a1, a2, a3, a4);
}

os_log_t os_log_create(const char *subsystem, const char *category)
{
  return _os_log_create(subsystem, category);
}

BOOL os_log_type_enabled(os_log_t oslog, os_log_type_t type)
{
  return _os_log_type_enabled(oslog, type);
}

void os_release(void *object)
{
}

uint64_t os_state_add_handler()
{
  return _os_state_add_handler();
}

uint64_t os_state_remove_handler()
{
  return _os_state_remove_handler();
}

uint64_t os_transaction_create()
{
  return _os_transaction_create();
}

void perror(const char *a1)
{
}

long double pow(long double __x, long double __y)
{
  return _pow(__x, __y);
}

float powf(float a1, float a2)
{
  return _powf(a1, a2);
}

int printf(const char *a1, ...)
{
  return _printf(a1);
}

int proc_pidinfo(int pid, int flavor, uint64_t arg, void *buffer, int buffersize)
{
  return _proc_pidinfo(pid, flavor, arg, buffer, buffersize);
}

int proc_pidpath(int pid, void *buffer, uint32_t buffersize)
{
  return _proc_pidpath(pid, buffer, buffersize);
}

int pthread_attr_destroy(pthread_attr_t *a1)
{
  return _pthread_attr_destroy(a1);
}

int pthread_attr_init(pthread_attr_t *a1)
{
  return _pthread_attr_init(a1);
}

int pthread_attr_setdetachstate(pthread_attr_t *a1, int a2)
{
  return _pthread_attr_setdetachstate(a1, a2);
}

int pthread_attr_setschedparam(pthread_attr_t *a1, const sched_param *a2)
{
  return _pthread_attr_setschedparam(a1, a2);
}

int pthread_cond_broadcast(pthread_cond_t *a1)
{
  return _pthread_cond_broadcast(a1);
}

int pthread_cond_destroy(pthread_cond_t *a1)
{
  return _pthread_cond_destroy(a1);
}

int pthread_cond_init(pthread_cond_t *a1, const pthread_condattr_t *a2)
{
  return _pthread_cond_init(a1, a2);
}

int pthread_cond_signal(pthread_cond_t *a1)
{
  return _pthread_cond_signal(a1);
}

int pthread_cond_timedwait(pthread_cond_t *a1, pthread_mutex_t *a2, const timespec *a3)
{
  return _pthread_cond_timedwait(a1, a2, a3);
}

int pthread_cond_timedwait_relative_np(pthread_cond_t *a1, pthread_mutex_t *a2, const timespec *a3)
{
  return _pthread_cond_timedwait_relative_np(a1, a2, a3);
}

int pthread_cond_wait(pthread_cond_t *a1, pthread_mutex_t *a2)
{
  return _pthread_cond_wait(a1, a2);
}

int pthread_create(pthread_t *a1, const pthread_attr_t *a2, void *(__cdecl *a3)(void *), void *a4)
{
  return _pthread_create(a1, a2, a3, a4);
}

int pthread_join(pthread_t a1, void **a2)
{
  return _pthread_join(a1, a2);
}

mach_port_t pthread_mach_thread_np(pthread_t a1)
{
  return _pthread_mach_thread_np(a1);
}

int pthread_mutex_destroy(pthread_mutex_t *a1)
{
  return _pthread_mutex_destroy(a1);
}

int pthread_mutex_init(pthread_mutex_t *a1, const pthread_mutexattr_t *a2)
{
  return _pthread_mutex_init(a1, a2);
}

int pthread_mutex_lock(pthread_mutex_t *a1)
{
  return _pthread_mutex_lock(a1);
}

int pthread_mutex_unlock(pthread_mutex_t *a1)
{
  return _pthread_mutex_unlock(a1);
}

int pthread_mutexattr_destroy(pthread_mutexattr_t *a1)
{
  return _pthread_mutexattr_destroy(a1);
}

int pthread_mutexattr_init(pthread_mutexattr_t *a1)
{
  return _pthread_mutexattr_init(a1);
}

int pthread_mutexattr_settype(pthread_mutexattr_t *a1, int a2)
{
  return _pthread_mutexattr_settype(a1, a2);
}

pthread_t pthread_self(void)
{
  return _pthread_self();
}

int pthread_setname_np(const char *a1)
{
  return _pthread_setname_np(a1);
}

int puts(const char *a1)
{
  return _puts(a1);
}

void qsort(void *__base, size_t __nel, size_t __width, int (__cdecl *__compar)(const void *, const void *))
{
}

ssize_t read(int a1, void *a2, size_t a3)
{
  return _read(a1, a2, a3);
}

BOOL remove(const std::__fs::filesystem::path *__p, std::error_code *__ec)
{
  return _remove(__p, __ec);
}

void rename(const std::__fs::filesystem::path *__from, const std::__fs::filesystem::path *__to, std::error_code *__ec)
{
}

void rewind(FILE *a1)
{
}

char *__cdecl setlocale(int a1, const char *a2)
{
  return _setlocale(a1, a2);
}

long double sin(long double __x)
{
  return _sin(__x);
}

int snprintf(char *__str, size_t __size, const char *__format, ...)
{
  return _snprintf(__str, __size, __format);
}

int sprintf(char *a1, const char *a2, ...)
{
  return _sprintf(a1, a2);
}

int stat(const char *a1, stat *a2)
{
  return _stat(a1, a2);
}

char *__cdecl strcat(char *__s1, const char *__s2)
{
  return _strcat(__s1, __s2);
}

int strcmp(const char *__s1, const char *__s2)
{
  return _strcmp(__s1, __s2);
}

char *__cdecl strcpy(char *__dst, const char *__src)
{
  return _strcpy(__dst, __src);
}

char *__cdecl strerror(int __errnum)
{
  return _strerror(__errnum);
}

size_t strftime(char *a1, size_t a2, const char *a3, const tm *a4)
{
  return _strftime(a1, a2, a3, a4);
}

size_t strlen(const char *__s)
{
  return _strlen(__s);
}

char *__cdecl strncat(char *__s1, const char *__s2, size_t __n)
{
  return _strncat(__s1, __s2, __n);
}

int strncmp(const char *__s1, const char *__s2, size_t __n)
{
  return _strncmp(__s1, __s2, __n);
}

char *__cdecl strncpy(char *__dst, const char *__src, size_t __n)
{
  return _strncpy(__dst, __src, __n);
}

char *__cdecl strstr(char *__s1, const char *__s2)
{
  return _strstr(__s1, __s2);
}

char *__cdecl strtok(char *__str, const char *__sep)
{
  return _strtok(__str, __sep);
}

uint64_t strtol(const char *__str, char **__endptr, int __base)
{
  return _strtol(__str, __endptr, __base);
}

unint64_t strtoul(const char *__str, char **__endptr, int __base)
{
  return _strtoul(__str, __endptr, __base);
}

int sysctl(int *a1, u_int a2, void *a3, size_t *a4, void *a5, size_t a6)
{
  return _sysctl(a1, a2, a3, a4, a5, a6);
}

long double tan(long double __x)
{
  return _tan(__x);
}

kern_return_t task_info(task_name_t target_task, task_flavor_t flavor, task_info_t task_info_out, mach_msg_type_number_t *task_info_outCnt)
{
  return _task_info(target_task, flavor, task_info_out, task_info_outCnt);
}

uint64_t tb_client_connection_message_construct()
{
  return _tb_client_connection_message_construct();
}

uint64_t tb_client_connection_message_destruct()
{
  return _tb_client_connection_message_destruct();
}

uint64_t tb_connection_send_query()
{
  return _tb_connection_send_query();
}

uint64_t tb_message_complete()
{
  return _tb_message_complete();
}

uint64_t tb_message_decode_BOOL()
{
  return _tb_message_decode_BOOL();
}

uint64_t tb_message_encode_f32()
{
  return _tb_message_encode_f32();
}

uint64_t tb_message_encode_u16()
{
  return _tb_message_encode_u16();
}

uint64_t tb_message_encode_u32()
{
  return _tb_message_encode_u32();
}

uint64_t tb_message_encode_u64()
{
  return _tb_message_encode_u64();
}

uint64_t tb_message_encode_u8()
{
  return _tb_message_encode_u8();
}

kern_return_t thread_policy_set(thread_act_t thread, thread_policy_flavor_t flavor, thread_policy_t policy_info, mach_msg_type_number_t policy_infoCnt)
{
  return _thread_policy_set(thread, flavor, policy_info, policy_infoCnt);
}

time_t time(time_t *a1)
{
  return _time(a1);
}

mode_t umask(mode_t a1)
{
  return _umask(a1);
}

int usleep(useconds_t a1)
{
  return _usleep(a1);
}

FFTSetup vDSP_create_fftsetup(vDSP_Length __Log2n, FFTRadix __Radix)
{
  return _vDSP_create_fftsetup(__Log2n, __Radix);
}

void vDSP_ctoz(const DSPComplex *__C, vDSP_Stride __IC, const DSPSplitComplex *__Z, vDSP_Stride __IZ, vDSP_Length __N)
{
}

void vDSP_desamp(const float *__A, vDSP_Stride __DF, const float *__F, float *__C, vDSP_Length __N, vDSP_Length __P)
{
}

void vDSP_destroy_fftsetup(FFTSetup __setup)
{
}

void vDSP_fft_zrip(FFTSetup __Setup, const DSPSplitComplex *__C, vDSP_Stride __IC, vDSP_Length __Log2N, FFTDirection __Direction)
{
}

void vDSP_maxv(const float *__A, vDSP_Stride __IA, float *__C, vDSP_Length __N)
{
}

void vDSP_maxvi(const float *__A, vDSP_Stride __IA, float *__C, vDSP_Length *__I, vDSP_Length __N)
{
}

void vDSP_meanv(const float *__A, vDSP_Stride __IA, float *__C, vDSP_Length __N)
{
}

void vDSP_minv(const float *__A, vDSP_Stride __IA, float *__C, vDSP_Length __N)
{
}

void vDSP_vabs(const float *__A, vDSP_Stride __IA, float *__C, vDSP_Stride __IC, vDSP_Length __N)
{
}

void vDSP_vclr(float *__C, vDSP_Stride __IC, vDSP_Length __N)
{
}

void vDSP_vsadd(const float *__A, vDSP_Stride __IA, const float *__B, float *__C, vDSP_Stride __IC, vDSP_Length __N)
{
}

void vDSP_vsub(const float *__B, vDSP_Stride __IB, const float *__A, vDSP_Stride __IA, float *__C, vDSP_Stride __IC, vDSP_Length __N)
{
}

void vDSP_zvabs(const DSPSplitComplex *__A, vDSP_Stride __IA, float *__C, vDSP_Stride __IC, vDSP_Length __N)
{
}

vImage_Error vImageConvert_Planar8toPlanarF(const vImage_Buffer *src, const vImage_Buffer *dest, Pixel_F maxFloat, Pixel_F minFloat, vImage_Flags flags)
{
  return _vImageConvert_Planar8toPlanarF(src, dest, maxFloat, minFloat, flags);
}

vImage_Error vImageRotate90_PlanarF(const vImage_Buffer *src, const vImage_Buffer *dest, uint8_t rotationConstant, Pixel_F backColor, vImage_Flags flags)
{
  return _vImageRotate90_PlanarF(src, dest, rotationConstant, backColor, flags);
}

vImage_Error vImageScale_PlanarF(const vImage_Buffer *src, const vImage_Buffer *dest, void *tempBuffer, vImage_Flags flags)
{
  return _vImageScale_PlanarF(src, dest, tempBuffer, flags);
}

int vasprintf(char **a1, const char *a2, va_list a3)
{
  return _vasprintf(a1, a2, a3);
}

void vvlogf(float *a1, const float *a2, const int *a3)
{
}

ssize_t write(int __fd, const void *__buf, size_t __nbyte)
{
  return _write(__fd, __buf, __nbyte);
}

void xpc_array_append_value(xpc_object_t xarray, xpc_object_t value)
{
}

BOOL xpc_array_apply(xpc_object_t xarray, xpc_array_applier_t applier)
{
  return _xpc_array_apply(xarray, applier);
}

xpc_object_t xpc_array_create(xpc_object_t *objects, size_t count)
{
  return _xpc_array_create(objects, count);
}

xpc_object_t xpc_BOOL_create(BOOL value)
{
  return _xpc_BOOL_create(value);
}

BOOL xpc_BOOL_get_value(xpc_object_t xBOOL)
{
  return _xpc_BOOL_get_value(xBOOL);
}

void xpc_connection_activate(xpc_connection_t connection)
{
}

void xpc_connection_cancel(xpc_connection_t connection)
{
}

xpc_connection_t xpc_connection_create_mach_service(const char *name, dispatch_queue_t targetq, uint64_t flags)
{
  return _xpc_connection_create_mach_service(name, targetq, flags);
}

pid_t xpc_connection_get_pid(xpc_connection_t connection)
{
  return _xpc_connection_get_pid(connection);
}

void xpc_connection_resume(xpc_connection_t connection)
{
}

void xpc_connection_send_message(xpc_connection_t connection, xpc_object_t message)
{
}

void xpc_connection_send_message_with_reply(xpc_connection_t connection, xpc_object_t message, dispatch_queue_t replyq, xpc_handler_t handler)
{
}

xpc_object_t xpc_connection_send_message_with_reply_sync(xpc_connection_t connection, xpc_object_t message)
{
  return _xpc_connection_send_message_with_reply_sync(connection, message);
}

void xpc_connection_set_event_handler(xpc_connection_t connection, xpc_handler_t handler)
{
}

void xpc_connection_set_target_queue(xpc_connection_t connection, dispatch_queue_t targetq)
{
}

char *__cdecl xpc_copy_description(xpc_object_t object)
{
  return _xpc_copy_description(object);
}

xpc_object_t xpc_data_create(const void *bytes, size_t length)
{
  return _xpc_data_create(bytes, length);
}

const void *__cdecl xpc_data_get_bytes_ptr(xpc_object_t xdata)
{
  return _xpc_data_get_bytes_ptr(xdata);
}

size_t xpc_data_get_length(xpc_object_t xdata)
{
  return _xpc_data_get_length(xdata);
}

BOOL xpc_dictionary_apply(xpc_object_t xdict, xpc_dictionary_applier_t applier)
{
  return _xpc_dictionary_apply(xdict, applier);
}

xpc_object_t xpc_dictionary_create(const char *const *keys, xpc_object_t *values, size_t count)
{
  return _xpc_dictionary_create(keys, values, count);
}

xpc_object_t xpc_dictionary_create_reply(xpc_object_t original)
{
  return _xpc_dictionary_create_reply(original);
}

const void *__cdecl xpc_dictionary_get_data(xpc_object_t xdict, const char *key, size_t *length)
{
  return _xpc_dictionary_get_data(xdict, key, length);
}

int64_t xpc_dictionary_get_int64(xpc_object_t xdict, const char *key)
{
  return _xpc_dictionary_get_int64(xdict, key);
}

xpc_connection_t xpc_dictionary_get_remote_connection(xpc_object_t xdict)
{
  return _xpc_dictionary_get_remote_connection(xdict);
}

const char *__cdecl xpc_dictionary_get_string(xpc_object_t xdict, const char *key)
{
  return _xpc_dictionary_get_string(xdict, key);
}

uint64_t xpc_dictionary_get_uint64(xpc_object_t xdict, const char *key)
{
  return _xpc_dictionary_get_uint64(xdict, key);
}

xpc_object_t xpc_dictionary_get_value(xpc_object_t xdict, const char *key)
{
  return _xpc_dictionary_get_value(xdict, key);
}

uint64_t xpc_dictionary_handoff_reply()
{
  return _xpc_dictionary_handoff_reply();
}

void xpc_dictionary_set_BOOL(xpc_object_t xdict, const char *key, BOOL value)
{
}

void xpc_dictionary_set_data(xpc_object_t xdict, const char *key, const void *bytes, size_t length)
{
}

void xpc_dictionary_set_double(xpc_object_t xdict, const char *key, double value)
{
}

void xpc_dictionary_set_int64(xpc_object_t xdict, const char *key, int64_t value)
{
}

void xpc_dictionary_set_string(xpc_object_t xdict, const char *key, const char *string)
{
}

void xpc_dictionary_set_uint64(xpc_object_t xdict, const char *key, uint64_t value)
{
}

void xpc_dictionary_set_value(xpc_object_t xdict, const char *key, xpc_object_t value)
{
}

xpc_object_t xpc_double_create(double value)
{
  return _xpc_double_create(value);
}

double xpc_double_get_value(xpc_object_t xdouble)
{
  return _xpc_double_get_value(xdouble);
}

xpc_type_t xpc_get_type(xpc_object_t object)
{
  return _xpc_get_type(object);
}

xpc_object_t xpc_int64_create(int64_t value)
{
  return _xpc_int64_create(value);
}

int64_t xpc_int64_get_value(xpc_object_t xint)
{
  return _xpc_int64_get_value(xint);
}

void xpc_release(xpc_object_t object)
{
}

xpc_object_t xpc_retain(xpc_object_t object)
{
  return _xpc_retain(object);
}

void xpc_set_event_stream_handler(const char *stream, dispatch_queue_t targetq, xpc_handler_t handler)
{
}

xpc_object_t xpc_string_create(const char *string)
{
  return _xpc_string_create(string);
}

size_t xpc_string_get_length(xpc_object_t xstring)
{
  return _xpc_string_get_length(xstring);
}

const char *__cdecl xpc_string_get_string_ptr(xpc_object_t xstring)
{
  return _xpc_string_get_string_ptr(xstring);
}

id objc_msgSend_UTF8String(void *a1, const char *a2, ...)
{
  return [a1 UTF8String];
}

id objc_msgSend_allKeys(void *a1, const char *a2, ...)
{
  return [a1 allKeys];
}

id objc_msgSend_buffer(void *a1, const char *a2, ...)
{
  return [a1 buffer];
}

id objc_msgSend_bytes(void *a1, const char *a2, ...)
{
  return [a1 bytes];
}

id objc_msgSend_cameraCalibration(void *a1, const char *a2, ...)
{
  return [a1 cameraCalibration];
}

id objc_msgSend_cleanup(void *a1, const char *a2, ...)
{
  return [a1 cleanup];
}

id objc_msgSend_code(void *a1, const char *a2, ...)
{
  return [a1 code];
}

id objc_msgSend_commandBuffer(void *a1, const char *a2, ...)
{
  return [a1 commandBuffer];
}

id objc_msgSend_commit(void *a1, const char *a2, ...)
{
  return [a1 commit];
}

id objc_msgSend_computeCommandEncoder(void *a1, const char *a2, ...)
{
  return [a1 computeCommandEncoder];
}

id objc_msgSend_contents(void *a1, const char *a2, ...)
{
  return [a1 contents];
}

id objc_msgSend_copy(void *a1, const char *a2, ...)
{
  return [a1 copy];
}

id objc_msgSend_copyNextSampleBuffer(void *a1, const char *a2, ...)
{
  return [a1 copyNextSampleBuffer];
}

id objc_msgSend_count(void *a1, const char *a2, ...)
{
  return [a1 count];
}

id objc_msgSend_date(void *a1, const char *a2, ...)
{
  return [a1 date];
}

id objc_msgSend_dealloc(void *a1, const char *a2, ...)
{
  return [a1 dealloc];
}

id objc_msgSend_defaultCStringEncoding(void *a1, const char *a2, ...)
{
  return [a1 defaultCStringEncoding];
}

id objc_msgSend_defaultManager(void *a1, const char *a2, ...)
{
  return [a1 defaultManager];
}

id objc_msgSend_deltaRotationX(void *a1, const char *a2, ...)
{
  return [a1 deltaRotationX];
}

id objc_msgSend_deltaRotationY(void *a1, const char *a2, ...)
{
  return [a1 deltaRotationY];
}

id objc_msgSend_deltaRotationZ(void *a1, const char *a2, ...)
{
  return [a1 deltaRotationZ];
}

id objc_msgSend_description(void *a1, const char *a2, ...)
{
  return [a1 description];
}

id objc_msgSend_descriptionInStringsFileFormat(void *a1, const char *a2, ...)
{
  return [a1 descriptionInStringsFileFormat];
}

id objc_msgSend_dictionaryRepresentation(void *a1, const char *a2, ...)
{
  return [a1 dictionaryRepresentation];
}

id objc_msgSend_domain(void *a1, const char *a2, ...)
{
  return [a1 domain];
}

id objc_msgSend_doubleValue(void *a1, const char *a2, ...)
{
  return [a1 doubleValue];
}

id objc_msgSend_endEncoding(void *a1, const char *a2, ...)
{
  return [a1 endEncoding];
}

id objc_msgSend_error(void *a1, const char *a2, ...)
{
  return [a1 error];
}

id objc_msgSend_executed(void *a1, const char *a2, ...)
{
  return [a1 executed];
}

id objc_msgSend_executionStatus(void *a1, const char *a2, ...)
{
  return [a1 executionStatus];
}

id objc_msgSend_floatValue(void *a1, const char *a2, ...)
{
  return [a1 floatValue];
}

id objc_msgSend_height(void *a1, const char *a2, ...)
{
  return [a1 height];
}

id objc_msgSend_intValue(void *a1, const char *a2, ...)
{
  return [a1 intValue];
}

id objc_msgSend_integerValue(void *a1, const char *a2, ...)
{
  return [a1 integerValue];
}

id objc_msgSend_invalidate(void *a1, const char *a2, ...)
{
  return [a1 invalidate];
}

id objc_msgSend_jasperToColorExtrinsics(void *a1, const char *a2, ...)
{
  return [a1 jasperToColorExtrinsics];
}

id objc_msgSend_lastPathComponent(void *a1, const char *a2, ...)
{
  return [a1 lastPathComponent];
}

id objc_msgSend_length(void *a1, const char *a2, ...)
{
  return [a1 length];
}

id objc_msgSend_localizedDescription(void *a1, const char *a2, ...)
{
  return [a1 localizedDescription];
}

id objc_msgSend_maxTotalThreadsPerThreadgroup(void *a1, const char *a2, ...)
{
  return [a1 maxTotalThreadsPerThreadgroup];
}

id objc_msgSend_mutableCopy(void *a1, const char *a2, ...)
{
  return [a1 mutableCopy];
}

id objc_msgSend_newCommandQueue(void *a1, const char *a2, ...)
{
  return [a1 newCommandQueue];
}

id objc_msgSend_newDefaultLibrary(void *a1, const char *a2, ...)
{
  return [a1 newDefaultLibrary];
}

id objc_msgSend_pathExtension(void *a1, const char *a2, ...)
{
  return [a1 pathExtension];
}

id objc_msgSend_pearlToColorExtrinsics(void *a1, const char *a2, ...)
{
  return [a1 pearlToColorExtrinsics];
}

id objc_msgSend_persistenceData(void *a1, const char *a2, ...)
{
  return [a1 persistenceData];
}

id objc_msgSend_pipeline(void *a1, const char *a2, ...)
{
  return [a1 pipeline];
}

id objc_msgSend_pipelineParameters(void *a1, const char *a2, ...)
{
  return [a1 pipelineParameters];
}

id objc_msgSend_prepare(void *a1, const char *a2, ...)
{
  return [a1 prepare];
}

id objc_msgSend_referenceDimensions(void *a1, const char *a2, ...)
{
  return [a1 referenceDimensions];
}

id objc_msgSend_releaseResourceAccess(void *a1, const char *a2, ...)
{
  return [a1 releaseResourceAccess];
}

id objc_msgSend_requestResourceAccess(void *a1, const char *a2, ...)
{
  return [a1 requestResourceAccess];
}

id objc_msgSend_sharedDataAccessor(void *a1, const char *a2, ...)
{
  return [a1 sharedDataAccessor];
}

id objc_msgSend_startReading(void *a1, const char *a2, ...)
{
  return [a1 startReading];
}

id objc_msgSend_status(void *a1, const char *a2, ...)
{
  return [a1 status];
}

id objc_msgSend_stringByDeletingLastPathComponent(void *a1, const char *a2, ...)
{
  return [a1 stringByDeletingLastPathComponent];
}

id objc_msgSend_threadExecutionWidth(void *a1, const char *a2, ...)
{
  return [a1 threadExecutionWidth];
}

id objc_msgSend_userInfo(void *a1, const char *a2, ...)
{
  return [a1 userInfo];
}

id objc_msgSend_waitUntilCompleted(void *a1, const char *a2, ...)
{
  return [a1 waitUntilCompleted];
}

id objc_msgSend_width(void *a1, const char *a2, ...)
{
  return [a1 width];
}

id objc_msgSend_writeToURL_error_(void *a1, const char *a2, ...)
{
  return [a1 writeToURL:error:];
}