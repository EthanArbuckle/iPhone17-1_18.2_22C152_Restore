uint64_t sub_100236B00(uint64_t (*a1)(void, void, void, void, void, void, void, void))
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  NSObject *v9;

  qword_100A10250 = 0;
  off_100A10258 = a1;
  v1 = sub_1001DEA28(5u, 2, 6, 3u, &qword_100A10250, (uint64_t)sub_100236BDC);
  if (v1 || !qword_100A10250)
  {
    if (sub_100058654())
    {
      sub_100056E24((uint64_t)"Could not register the LE signal channel : %!", v2, v3, v4, v5, v6, v7, v8, v1);
      v9 = sub_100050B4C(0x42u);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR)) {
        sub_100744F6C();
      }
    }
  }
  else
  {
    *(_WORD *)sub_1001E688C((unsigned int *)qword_100A10250) = 23;
    *(_WORD *)(sub_1001E688C((unsigned int *)qword_100A10250) + 2) = -1;
  }
  return v1;
}

void sub_100236BDC(uint64_t a1, unsigned __int16 *a2, unsigned int a3, uint64_t a4)
{
  if (sub_100197770(a1))
  {
    if (a2)
    {
      if (a3 > 3)
      {
        uint64_t v32 = a2[1];
        if (a3 - 4 == v32)
        {
          char v33 = *((unsigned char *)a2 + 1);
          uint64_t v34 = *(unsigned __int8 *)a2;
          switch(*(unsigned char *)a2)
          {
            case 6:
              char v35 = *((unsigned char *)a2 + 1);
              sub_100237768(a1, v35, a2 + 2, v32);
              break;
            case 7:
              uint64_t v52 = *((unsigned __int8 *)a2 + 1);
              sub_100237808(a1, v52, a2 + 2, v32);
              break;
            case 8:
            case 9:
            case 0xA:
            case 0xB:
            case 0xC:
            case 0xD:
            case 0xE:
            case 0xF:
            case 0x10:
            case 0x11:
              goto LABEL_22;
            case 0x12:
              uint64_t v53 = *((unsigned __int8 *)a2 + 1);
              sub_100236FE4(a1, v53, a2 + 2, v32, a4);
              break;
            case 0x13:
              return;
            case 0x14:
              uint64_t v54 = *((unsigned __int8 *)a2 + 1);
              sub_10023751C(a1, v54, a2 + 2, v32, a4);
              break;
            case 0x15:
              unsigned int v55 = *((unsigned __int8 *)a2 + 1);
              sub_1002375D0(a1, v55, (uint64_t)(a2 + 2), v32);
              break;
            case 0x16:
              uint64_t v56 = a2[1];
              sub_100237680(a1, a2 + 2, v56);
              break;
            default:
              if (v34 != 1)
              {
LABEL_22:
                if (sub_100058654())
                {
                  sub_100056E24((uint64_t)"LE Signaling channel error : invalid opcode %d", v44, v45, v46, v47, v48, v49, v50, v34);
                  v51 = sub_100050B4C(0x42u);
                  if (os_log_type_enabled(v51, OS_LOG_TYPE_ERROR)) {
                    sub_100744F6C();
                  }
                }
                sub_10023576C(a1, v33, 0);
              }
              break;
          }
        }
        else if (sub_100058654())
        {
          sub_100056E24((uint64_t)"LE Signaling channel error : corrupted packet size", v36, v37, v38, v39, v40, v41, v42, v57);
          v43 = sub_100050B4C(0x42u);
          if (os_log_type_enabled(v43, OS_LOG_TYPE_ERROR)) {
            goto LABEL_20;
          }
        }
      }
      else if (sub_100058654())
      {
        sub_100056E24((uint64_t)"LE Signaling channel error : invalid packet size", v8, v9, v10, v11, v12, v13, v14, v57);
        v15 = sub_100050B4C(0x42u);
        if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR)) {
LABEL_20:
        }
          sub_100744F6C();
      }
    }
    else if (sub_100058654())
    {
      sub_100056E24((uint64_t)"LE Signaling channel error : invalid data on", v24, v25, v26, v27, v28, v29, v30, v57);
      v31 = sub_100050B4C(0x42u);
      if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR)) {
        goto LABEL_20;
      }
    }
  }
  else if (sub_100058654())
  {
    sub_100056E24((uint64_t)"LE Signaling channel error : not a LE handle.", v16, v17, v18, v19, v20, v21, v22, v57);
    v23 = sub_100050B4C(0x42u);
    if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR)) {
      goto LABEL_20;
    }
  }
}

uint64_t sub_100236F58()
{
  uint64_t v0 = sub_1001DEC18(qword_100A10250);
  if (v0)
  {
    if (sub_100058654())
    {
      sub_100056E24((uint64_t)"Could not de-register the LE signal channel : %!", v1, v2, v3, v4, v5, v6, v7, v0);
      uint64_t v8 = sub_100050B4C(0x42u);
      if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR)) {
        sub_100744F6C();
      }
    }
  }
  qword_100A10250 = 0;
  return v0;
}

void sub_100236FE4(uint64_t a1, uint64_t a2, unsigned __int16 *a3, uint64_t a4, uint64_t a5)
{
  char v5 = a2;
  if (*(unsigned char *)(a1 + 70) == 1)
  {
    if (sub_100058654())
    {
      sub_100056E24((uint64_t)"This command should only be received if we are central.", v7, v8, v9, v10, v11, v12, v13, v118);
      uint64_t v14 = sub_100050B4C(0x42u);
      if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR)) {
        sub_100744F6C();
      }
    }
    sub_10023576C(a1, v5, 0);
    return;
  }
  if (a4 == 8)
  {
    uint64_t v16 = *a3;
    uint64_t v17 = a3[1];
    uint64_t v18 = a3[2];
    uint64_t v19 = a3[3];
    if (off_100A10258)
    {
      int v20 = off_100A10258(a1, a2, *a3, v17, v18, v19, 0, a5);
      if (!v20) {
        return;
      }
      if (v20 != 121) {
        goto LABEL_57;
      }
    }
    if ((unsigned __int16)(v16 - 3201) > 0xF384u)
    {
      if ((unsigned __int16)(v17 - 3201) > 0xF384u)
      {
        if (v16 <= v17)
        {
          if (v18 < 0x1F5)
          {
            if ((unsigned __int16)(v19 - 3201) > 0xF388u)
            {
              double v69 = (double)v17 * 1.25;
              if (v69 * (double)((int)v18 + 1) <= 2000.0)
              {
                if ((double)v16 * 1.25 >= 10.0)
                {
                  if ((double)((int)v17 - (int)v16) * 1.25 >= 10.0)
                  {
                    if (v18 < 5)
                    {
                      if (v19 < 0x259)
                      {
                        if (v69 * (double)(3 * ((int)v18 + 1)) <= (double)(10 * (int)v19))
                        {
                          sub_1002358D8(a1, v5, 0, v16, v17, v18, v19, 0, 0);
                          return;
                        }
                        if (!sub_100058654()) {
                          goto LABEL_57;
                        }
                        sub_100056E24((uint64_t)"Remote sides asks for a timeout(%dms) / latency(%d) / maxInterval(%dms) that would cause link timeouts under bad conditions. - refusing.", v110, v111, v112, v113, v114, v115, v116, (10 * v19));
                        v117 = sub_100050B4C(0x42u);
                        if (!os_log_type_enabled(v117, OS_LOG_TYPE_ERROR)) {
                          goto LABEL_57;
                        }
                      }
                      else
                      {
                        if (!sub_100058654()) {
                          goto LABEL_57;
                        }
                        sub_100056E24((uint64_t)"Remote sides asks for a timeout of more than 6 seconds, this is not very user friendly - refusing.", v102, v103, v104, v105, v106, v107, v108, v118);
                        v109 = sub_100050B4C(0x42u);
                        if (!os_log_type_enabled(v109, OS_LOG_TYPE_ERROR)) {
                          goto LABEL_57;
                        }
                      }
                    }
                    else
                    {
                      if (!sub_100058654()) {
                        goto LABEL_57;
                      }
                      sub_100056E24((uint64_t)"Remote side wants a peripheral latency more than 4 so we drain our battery and they don't - refusing.", v94, v95, v96, v97, v98, v99, v100, v118);
                      v101 = sub_100050B4C(0x42u);
                      if (!os_log_type_enabled(v101, OS_LOG_TYPE_ERROR)) {
                        goto LABEL_57;
                      }
                    }
                  }
                  else
                  {
                    if (!sub_100058654()) {
                      goto LABEL_57;
                    }
                    sub_100056E24((uint64_t)"Intervals should be %d ms apart - refusing.", v86, v87, v88, v89, v90, v91, v92, 10);
                    v93 = sub_100050B4C(0x42u);
                    if (!os_log_type_enabled(v93, OS_LOG_TYPE_ERROR)) {
                      goto LABEL_57;
                    }
                  }
                }
                else
                {
                  if (!sub_100058654()) {
                    goto LABEL_57;
                  }
                  sub_100056E24((uint64_t)"Remote side wants a min interval smaller than 20 ms. Let's refuse and not drain the battery...", v78, v79, v80, v81, v82, v83, v84, v118);
                  v85 = sub_100050B4C(0x42u);
                  if (!os_log_type_enabled(v85, OS_LOG_TYPE_ERROR)) {
                    goto LABEL_57;
                  }
                }
              }
              else
              {
                if (!sub_100058654()) {
                  goto LABEL_57;
                }
                sub_100056E24((uint64_t)"Remote side wants an interval / latency combination that would provide a poor user experience (more than 2seconds syncups.)", v70, v71, v72, v73, v74, v75, v76, v118);
                v77 = sub_100050B4C(0x42u);
                if (!os_log_type_enabled(v77, OS_LOG_TYPE_ERROR)) {
                  goto LABEL_57;
                }
              }
            }
            else
            {
              if (!sub_100058654()) {
                goto LABEL_57;
              }
              sub_100056E24((uint64_t)"Invalid timeout multiplier %d.", v61, v62, v63, v64, v65, v66, v67, v19);
              v68 = sub_100050B4C(0x42u);
              if (!os_log_type_enabled(v68, OS_LOG_TYPE_ERROR)) {
                goto LABEL_57;
              }
            }
          }
          else
          {
            if (!sub_100058654()) {
              goto LABEL_57;
            }
            sub_100056E24((uint64_t)"Invalid peripheral latency %d.", v53, v54, v55, v56, v57, v58, v59, v18);
            v60 = sub_100050B4C(0x42u);
            if (!os_log_type_enabled(v60, OS_LOG_TYPE_ERROR)) {
              goto LABEL_57;
            }
          }
        }
        else
        {
          if (!sub_100058654()) {
            goto LABEL_57;
          }
          sub_100056E24((uint64_t)"Maximum interval is smaller than minimum interval : %d > %d.", v45, v46, v47, v48, v49, v50, v51, v16);
          uint64_t v52 = sub_100050B4C(0x42u);
          if (!os_log_type_enabled(v52, OS_LOG_TYPE_ERROR)) {
            goto LABEL_57;
          }
        }
      }
      else
      {
        if (!sub_100058654()) {
          goto LABEL_57;
        }
        sub_100056E24((uint64_t)"Invalid maximum interval %d.", v37, v38, v39, v40, v41, v42, v43, v17);
        uint64_t v44 = sub_100050B4C(0x42u);
        if (!os_log_type_enabled(v44, OS_LOG_TYPE_ERROR)) {
          goto LABEL_57;
        }
      }
    }
    else
    {
      if (!sub_100058654()) {
        goto LABEL_57;
      }
      sub_100056E24((uint64_t)"Invalid minimum interval %d.", v21, v22, v23, v24, v25, v26, v27, v16);
      uint64_t v28 = sub_100050B4C(0x42u);
      if (!os_log_type_enabled(v28, OS_LOG_TYPE_ERROR)) {
        goto LABEL_57;
      }
    }
    sub_100744F6C();
LABEL_57:
    sub_1002358D8(a1, v5, 1, 0, 0, 0, 0, 0, 0);
    return;
  }
  if (sub_100058654())
  {
    sub_100056E24((uint64_t)"Invalid size in parameter update request : %d", v29, v30, v31, v32, v33, v34, v35, a4);
    uint64_t v36 = sub_100050B4C(0x42u);
    if (os_log_type_enabled(v36, OS_LOG_TYPE_ERROR)) {
      sub_100744F6C();
    }
  }
}

void sub_10023751C(uint64_t a1, uint64_t a2, unsigned __int16 *a3, uint64_t a4, uint64_t a5)
{
  if (a4 == 10)
  {
    int v7 = *a3;
    unsigned int v8 = a3[2];
    int v9 = a3[3];
    int v10 = a3[4];
    __int16 v11 = a3[1];
    sub_1001E4794(a1, v7, v11, v8, v9, v10, a2, a5);
  }
  else if (sub_100058654())
  {
    sub_100056E24((uint64_t)"Invalid size in LE Connection Oriented L2CAP Channel connection request : %d", v13, v14, v15, v16, v17, v18, v19, a4);
    int v20 = sub_100050B4C(0x42u);
    if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR)) {
      sub_100744F6C();
    }
  }
}

void sub_1002375D0(uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4)
{
  if (a4 == 10)
  {
    __int16 v5 = *(_WORD *)a3;
    int v6 = *(unsigned __int16 *)(a3 + 4);
    int v7 = *(unsigned __int16 *)(a3 + 6);
    int v8 = *(unsigned __int16 *)(a3 + 8);
    unsigned int v9 = *(unsigned __int16 *)(a3 + 2);
    sub_1001E4BE0(a1, v5, v9, v6, v7, v8, a2);
  }
  else if (sub_100058654())
  {
    sub_100056E24((uint64_t)"Invalid size in LE Connection Oriented L2CAP Channel connection response : %d", v11, v12, v13, v14, v15, v16, v17, a4);
    uint64_t v18 = sub_100050B4C(0x42u);
    if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR)) {
      sub_100744F6C();
    }
  }
}

void sub_100237680(uint64_t a1, unsigned __int16 *a2, uint64_t a3)
{
  uint64_t v23 = 0;
  if (a3 == 4)
  {
    int v3 = *((unsigned __int8 *)a2 + 2);
    int v4 = *((unsigned __int8 *)a2 + 3);
    sub_1001DD96C(*a2, a1, &v23);
    if (v23)
    {
      sub_1001D9E78(v23, v3 | (v4 << 8));
    }
    else if (sub_100058654())
    {
      sub_100056E24((uint64_t)"Credits for an invalid channel CID", v14, v15, v16, v17, v18, v19, v20, v22);
      uint64_t v21 = sub_100050B4C(0x42u);
      if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR)) {
        sub_100744F6C();
      }
    }
  }
  else if (sub_100058654())
  {
    sub_100056E24((uint64_t)"Invalid size in LEConnection Oriented L2CAP Channel connection Flow Credit : %d", v6, v7, v8, v9, v10, v11, v12, a3);
    uint64_t v13 = sub_100050B4C(0x42u);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR)) {
      sub_100744F6C();
    }
  }
}

void sub_100237768(uint64_t a1, char a2, unsigned __int16 *a3, uint64_t a4)
{
  if (a4 == 4)
  {
    unsigned int v6 = *a3;
    uint64_t v7 = a3[1];
    sub_1001E4310(a1, v6, v7, a2);
  }
  else if (sub_100058654())
  {
    sub_100056E24((uint64_t)"Invalid size in Disconnect request : %d", v8, v9, v10, v11, v12, v13, v14, a4);
    uint64_t v15 = sub_100050B4C(0x42u);
    if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR)) {
      sub_100744F6C();
    }
  }
}

void sub_100237808(uint64_t a1, uint64_t a2, unsigned __int16 *a3, uint64_t a4)
{
  if (a4 == 4)
  {
    unsigned int v5 = a3[1];
    int v6 = *a3;
    sub_1001E4664(a1, v5, v6);
  }
  else if (sub_100058654())
  {
    sub_100056E24((uint64_t)"Invalid size in Disconnect response : %d", v7, v8, v9, v10, v11, v12, v13, a4);
    uint64_t v14 = sub_100050B4C(0x42u);
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR)) {
      sub_100744F6C();
    }
  }
}

uint64_t sub_1002378AC(_DWORD *a1)
{
  uint64_t v1 = sub_100197B34(a1);
  if (!v1) {
    return 122;
  }
  uint64_t v2 = v1;
  if (!sub_100197770(v1))
  {
    if (sub_100058654())
    {
      sub_100056E24((uint64_t)"This command is only available to LE devices.", v7, v8, v9, v10, v11, v12, v13, v23);
      uint64_t v14 = sub_100050B4C(0x43u);
      if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR)) {
        sub_100744F6C();
      }
    }
    return 122;
  }
  uint64_t v3 = sub_1001F0BBC(v2);
  if (v3)
  {
    unint64_t v4 = *(unsigned int *)(v3 + 52);
    if (v4 >= 6) {
      char v5 = 8;
    }
    else {
      char v5 = 0x20C01010108uLL >> (8 * v4);
    }
    return sub_1002379C0(v2, v5 & 0xF, (char *)v3);
  }
  else
  {
    if (sub_100058654())
    {
      sub_100056E24((uint64_t)"This device is not in a pairing state.", v15, v16, v17, v18, v19, v20, v21, v23);
      uint64_t v22 = sub_100050B4C(0x43u);
      if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR)) {
        sub_100744F6C();
      }
    }
    return 4806;
  }
}

uint64_t sub_1002379C0(uint64_t a1, int a2, char *a3)
{
  char v4 = a2;
  __int16 v9 = 5;
  if (a2 == 240) {
    char v5 = 8;
  }
  else {
    char v5 = a2;
  }
  HIBYTE(v9) = v5;
  uint64_t v6 = sub_1001F0C08(a1, (char *)&v9, 2uLL, 0);
  if (a3)
  {
    uint64_t v7 = sub_1001F10BC(v4);
    sub_1001F0828(a3, v7, 1);
  }
  return v6;
}

uint64_t sub_100237A40(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = result;
    if (sub_100197770(result))
    {
      result = sub_1001F0BBC(v1);
      if (result) {
        return *(unsigned char *)(result + 8) != 0;
      }
    }
    else
    {
      result = sub_100058654();
      if (result)
      {
        sub_100056E24((uint64_t)"This command is only available to LE devices.", v2, v3, v4, v5, v6, v7, v8, v10);
        __int16 v9 = sub_100050B4C(0x43u);
        result = os_log_type_enabled(v9, OS_LOG_TYPE_ERROR);
        if (result)
        {
          sub_100744F6C();
          return 0;
        }
      }
    }
  }
  return result;
}

uint64_t sub_100237AD0(_DWORD *a1)
{
  uint64_t v1 = sub_100197B34(a1);

  return sub_100237A40(v1);
}

uint64_t sub_100237AF8(_DWORD *a1, unsigned int a2)
{
  HIDWORD(v3) = 0;
  *(void *)((char *)&v3 + 4) = 0;
  if (a2 > 0xF423F) {
    return 101;
  }
  LOWORD(v3) = a2;
  WORD1(v3) = BYTE2(a2);
  return sub_100237B80(a1, &v3);
}

uint64_t sub_100237B80(_DWORD *a1, _OWORD *a2)
{
  uint64_t v3 = sub_100197B34(a1);
  if (!v3) {
    return 122;
  }
  uint64_t v4 = (unsigned char *)v3;
  uint64_t v5 = sub_1001F0BBC(v3);
  if (!v5) {
    return 4806;
  }
  uint64_t v7 = v5;
  *(unsigned char *)(v5 + 490) = 1;
  if ((*(unsigned char *)(v5 + 72) & *(unsigned char *)(v5 + 80) & 8) != 0)
  {
    switch(*(unsigned char *)(v5 + 16))
    {
      case 1:
        if (*(unsigned char *)(*(void *)v5 + 70))
        {
          memset(__s1, 0, 64);
          if (!memcmp(__s1, (const void *)(v5 + 312), 0x40uLL)) {
            return 0;
          }
          uint64_t v42 = sub_100238328(v7);
          if (!v42) {
            return 0;
          }
          uint64_t v8 = v42;
          if (sub_100058654())
          {
            sub_100056E24((uint64_t)"recvdSMPDeferredJustWorksNumComparPublicKey failed %!", v43, v44, v45, v46, v47, v48, v49, v8);
            uint64_t v50 = sub_100050B4C(0x43u);
            if (os_log_type_enabled(v50, OS_LOG_TYPE_ERROR)) {
              sub_100745764();
            }
          }
          goto LABEL_37;
        }
        v68 = (_OWORD *)(v5 + 152);
        double v69 = (_OWORD *)(v5 + 216);
        uint64_t v70 = sub_1001818CC((_OWORD *)(v5 + 152), (_OWORD *)(v5 + 216));
        if (v70)
        {
          uint64_t v8 = v70;
          *(_OWORD *)(v7 + 184) = 0u;
          *(_OWORD *)(v7 + 200) = 0u;
          _OWORD *v68 = 0u;
          *(_OWORD *)(v7 + 168) = 0u;
          *double v69 = 0u;
          *(_OWORD *)(v7 + 232) = 0u;
          *(_OWORD *)(v7 + 248) = 0u;
          *(_OWORD *)(v7 + 264) = 0u;
          *(_OWORD *)(v7 + 280) = 0u;
          *(_OWORD *)(v7 + 296) = 0u;
        }
        else
        {
          sub_1001F10F4(v7, 33);
          __s1[0] = 12;
          long long v79 = *(_OWORD *)(v7 + 168);
          *(_OWORD *)&__s1[1] = *v68;
          *(_OWORD *)&__s1[17] = v79;
          long long v80 = *(_OWORD *)(v7 + 200);
          *(_OWORD *)&__s1[33] = *(_OWORD *)(v7 + 184);
          *(_OWORD *)&__s1[49] = v80;
          return sub_1001F0C08(*(void *)v7, __s1, 0x41uLL, 1);
        }
        return v8;
      case 2:
      case 3:
      case 4:
        *(_OWORD *)(v5 + 425) = *a2;
        *(_OWORD *)(v5 + 441) = *a2;
        uint64_t v8 = sub_100238568(v5);
        if (v8)
        {
          if (!sub_100058654()) {
            goto LABEL_37;
          }
          sub_100056E24((uint64_t)"smpDoOneLeSecuredConnectionPasskeyAuthItteration failed %!", v9, v10, v11, v12, v13, v14, v15, v8);
          uint64_t v16 = sub_100050B4C(0x43u);
          if (!os_log_type_enabled(v16, OS_LOG_TYPE_ERROR)) {
            goto LABEL_37;
          }
          break;
        }
        return v8;
      case 5:
        if (!sub_100058654()) {
          goto LABEL_36;
        }
        sub_100056E24((uint64_t)"Wrong API for OOB", v51, v52, v53, v54, v55, v56, v57, v81);
        uint64_t v58 = sub_100050B4C(0x43u);
        if (!os_log_type_enabled(v58, OS_LOG_TYPE_ERROR)) {
          goto LABEL_36;
        }
        goto LABEL_35;
      case 6:
        if (*(unsigned char *)(*(void *)v5 + 70))
        {
          if (!*(unsigned char *)(v5 + 491)) {
            return 0;
          }
          uint64_t v8 = sub_100238130(v4);
          if (!v8) {
            return v8;
          }
          if (!sub_100058654()) {
            goto LABEL_37;
          }
          sub_100056E24((uint64_t)"recvdSMPDeferredDHKeyCheck Failed %!", v60, v61, v62, v63, v64, v65, v66, v8);
          uint64_t v67 = sub_100050B4C(0x43u);
          if (!os_log_type_enabled(v67, OS_LOG_TYPE_ERROR)) {
            goto LABEL_37;
          }
        }
        else
        {
          uint64_t v8 = sub_100238054((unsigned char *)v5);
          if (!v8) {
            return v8;
          }
          if (!sub_100058654()) {
            goto LABEL_37;
          }
          sub_100056E24((uint64_t)"Failed to send DHKey value with status %!", v71, v72, v73, v74, v75, v76, v77, v8);
          uint64_t v78 = sub_100050B4C(0x43u);
          if (!os_log_type_enabled(v78, OS_LOG_TYPE_ERROR)) {
            goto LABEL_37;
          }
        }
        break;
      default:
        if (sub_100058654())
        {
          sub_100056E24((uint64_t)"wrong API for STKGENMethod=%d", v34, v35, v36, v37, v38, v39, v40, *(unsigned __int8 *)(v7 + 16));
          uint64_t v41 = sub_100050B4C(0x43u);
          if (os_log_type_enabled(v41, OS_LOG_TYPE_ERROR)) {
LABEL_35:
          }
            sub_100744F6C();
        }
LABEL_36:
        uint64_t v8 = 4800;
        goto LABEL_37;
    }
LABEL_52:
    sub_100745764();
LABEL_37:
    sub_1002379C0((uint64_t)v4, 8, (char *)v7);
    return v8;
  }
  if (*(unsigned char *)(v5 + 16) != 1 && *(_OWORD *)(v5 + 17) == 0)
  {
    long long v6 = *a2;
    *(_OWORD *)(v5 + 17) = *a2;
  }
  uint64_t v17 = sub_100238814(v5, 0, (void *)(v5 + 88), *(uint8x8_t *)&v6);
  if (v17)
  {
    uint64_t v8 = v17;
    if (!sub_100058654()) {
      goto LABEL_37;
    }
    sub_100056E24((uint64_t)"Could not generate confirmation value with status %!", v18, v19, v20, v21, v22, v23, v24, v8);
    uint64_t v25 = sub_100050B4C(0x43u);
    if (!os_log_type_enabled(v25, OS_LOG_TYPE_ERROR)) {
      goto LABEL_37;
    }
    goto LABEL_52;
  }
  if (v4[70] && *(_DWORD *)(v7 + 84) != 1)
  {
    uint64_t v8 = 0;
    *(_DWORD *)(v7 + 84) = 2;
    return v8;
  }
  uint64_t v8 = sub_1002389B4((uint64_t)v4, (void *)(v7 + 88));
  if (v8)
  {
    if (!sub_100058654()) {
      goto LABEL_37;
    }
    sub_100056E24((uint64_t)"Could not send pairing confirmation to handle 0x%x with status %!", v26, v27, v28, v29, v30, v31, v32, (uint64_t)v4);
    uint64_t v33 = sub_100050B4C(0x43u);
    if (!os_log_type_enabled(v33, OS_LOG_TYPE_ERROR)) {
      goto LABEL_37;
    }
    goto LABEL_52;
  }
  return v8;
}

uint64_t sub_100238054(unsigned char *a1)
{
  long long v13 = 0uLL;
  uint64_t v2 = sub_1002407BC(a1, &v13, 1);
  if (v2)
  {
    uint64_t v3 = v2;
    if (sub_100058654())
    {
      sub_100056E24((uint64_t)"smpAuthenticationStage2 failed %!", v4, v5, v6, v7, v8, v9, v10, v3);
      uint64_t v11 = sub_100050B4C(0x43u);
      if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR)) {
        sub_100745764();
      }
    }
  }
  else
  {
    char v14 = 13;
    long long v15 = v13;
    return sub_1001F0C08(*(void *)a1, &v14, 0x11uLL, 1);
  }
  return v3;
}

uint64_t sub_100238130(unsigned char *a1)
{
  uint64_t v37 = 0;
  uint64_t v38 = 0;
  uint64_t v2 = (unsigned char *)sub_1001F0BBC((uint64_t)a1);
  uint64_t v3 = (uint64_t)v2;
  if (!v2)
  {
    if (sub_100058654())
    {
      sub_100056E24((uint64_t)"Could not find associated pairing data.", v24, v25, v26, v27, v28, v29, v30, v35);
      uint64_t v31 = sub_100050B4C(0x43u);
      if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR)) {
        sub_100744F6C();
      }
    }
    uint64_t v23 = 0;
    goto LABEL_27;
  }
  uint64_t v4 = sub_1002407BC(v2, &v37, 0);
  if (v4)
  {
    uint64_t v5 = v4;
    if (sub_100058654())
    {
      sub_100056E24((uint64_t)"smpAuthenticationStage2 failed %!", v6, v7, v8, v9, v10, v11, v12, v5);
      long long v13 = sub_100050B4C(0x43u);
      if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR)) {
        sub_100745764();
      }
    }
  }
  if (v37 != *(void *)(v3 + 492) || v38 != *(void *)(v3 + 500))
  {
    if (sub_100058654())
    {
      sub_100056E24((uint64_t)"DHKey failed to match.", v15, v16, v17, v18, v19, v20, v21, v35);
      uint64_t v22 = sub_100050B4C(0x43u);
      if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR)) {
        sub_100744F6C();
      }
    }
    sub_1002379C0((uint64_t)a1, 11, (char *)v3);
    return 0;
  }
  if (*(unsigned char *)(v3 + 424)) {
    sub_1001F10F4(v3, 41);
  }
  if (*(unsigned char *)(*(void *)v3 + 70) == 1)
  {
    uint64_t v32 = sub_100238054((unsigned char *)v3);
  }
  else
  {
    uint64_t v36 = 0;
    if (*(unsigned char *)(v3 + 16) == 1) {
      char v33 = 2;
    }
    else {
      char v33 = 3;
    }
    uint64_t v32 = sub_10023436C(a1, (uint64_t)&v36, 0, v3 + 524, 16, v33);
  }
  uint64_t v23 = v32;
  if (v32) {
LABEL_27:
  }
    sub_1002379C0((uint64_t)a1, 8, (char *)v3);
  return v23;
}

uint64_t sub_100238328(uint64_t a1)
{
  sub_1001F0FFC((uint64_t *)a1);
  uint64_t v2 = *(void *)a1;
  if (*(unsigned char *)(*(void *)a1 + 70) == 1)
  {
    v36[0] = 12;
    *(_OWORD *)&v36[1] = *(_OWORD *)(a1 + 152);
    *(_OWORD *)&v36[17] = *(_OWORD *)(a1 + 168);
    long long v37 = *(_OWORD *)(a1 + 184);
    long long v38 = *(_OWORD *)(a1 + 200);
    uint64_t v3 = sub_1001F0C08(v2, v36, 0x41uLL, 1);
    if (v3)
    {
      uint64_t v4 = v3;
      if (sub_100058654())
      {
        sub_100056E24((uint64_t)"smpSendPairingPublicKey failed %!", v5, v6, v7, v8, v9, v10, v11, v4);
        uint64_t v12 = sub_100050B4C(0x43u);
        if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR)) {
          sub_100745764();
        }
      }
      return v4;
    }
    sub_1001F10F4(a1, 34);
    long long v13 = (void *)(a1 + 473);
  }
  else
  {
    long long v13 = (void *)(a1 + 457);
  }
  arc4random_buf(v13, 0x10uLL);
  *(void *)(a1 + 433) = 0;
  *(void *)(a1 + 425) = 0;
  *(void *)(a1 + 449) = 0;
  *(void *)(a1 + 441) = 0;
  if (*(unsigned char *)(*(void *)a1 + 70))
  {
    long long v14 = *(_OWORD *)(a1 + 328);
    *(_OWORD *)uint64_t v36 = *(_OWORD *)(a1 + 312);
    *(_OWORD *)&v36[16] = v14;
    long long v15 = *(_OWORD *)(a1 + 168);
    v35[0] = *(_OWORD *)(a1 + 152);
    v35[1] = v15;
    uint64_t v16 = sub_100180EA8(v35, v36, (long long *)(a1 + 473), 0, (void *)(a1 + 88));
    if (v16)
    {
      uint64_t v17 = v16;
      if (sub_100058654())
      {
        sub_100056E24((uint64_t)"Failed to generate confirmation value %!", v18, v19, v20, v21, v22, v23, v24, v17);
        uint64_t v25 = sub_100050B4C(0x43u);
        if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR)) {
          sub_100745764();
        }
      }
      return 4825;
    }
    else
    {
      sub_1001F0FFC((uint64_t *)a1);
      uint64_t v4 = sub_1002389B4(*(void *)a1, (void *)(a1 + 88));
      if (v4)
      {
        if (sub_100058654())
        {
          sub_100056E24((uint64_t)"Failed to send confirmation value %!", v27, v28, v29, v30, v31, v32, v33, v4);
          uint64_t v34 = sub_100050B4C(0x43u);
          if (os_log_type_enabled(v34, OS_LOG_TYPE_ERROR)) {
            sub_100745764();
          }
        }
      }
    }
  }
  else
  {
    sub_1001F10F4(a1, 35);
    return 0;
  }
  return v4;
}

uint64_t sub_100238568(uint64_t a1)
{
  uint64_t v2 = (void *)(a1 + 88);
  uint64_t v3 = (long long *)(a1 + 312);
  uint64_t v4 = (long long *)(a1 + 152);
  if (*(unsigned char *)(*(void *)a1 + 70))
  {
    unsigned int v5 = *(_DWORD *)(a1 + 441);
    arc4random_buf((void *)(a1 + 473), 0x10uLL);
    char v6 = *(unsigned char *)(a1 + 489);
    long long v7 = v3[1];
    long long v55 = *v3;
    long long v56 = v7;
    long long v8 = v4[1];
    long long v53 = *v4;
    long long v54 = v8;
    if ((v5 >> v6)) {
      char v9 = -127;
    }
    else {
      char v9 = 0x80;
    }
    uint64_t v10 = sub_100180EA8(&v53, &v55, (long long *)(a1 + 473), v9, v2);
    if (v10)
    {
      uint64_t v11 = v10;
      if (sub_100058654())
      {
        sub_100056E24((uint64_t)"Failed to generate confirmation value C %!", v12, v13, v14, v15, v16, v17, v18, v11);
        uint64_t v19 = sub_100050B4C(0x43u);
        if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR)) {
LABEL_29:
        }
          sub_100745764();
      }
    }
    else
    {
      sub_1001F10F4(a1, 34);
      if (*(unsigned char *)(a1 + 490)
        && (!*(void *)(a1 + 104) ? (BOOL v34 = *(void *)(a1 + 112) == 0) : (BOOL v34 = 0),
            !v34 && (uint64_t v35 = sub_100240578((uint64_t *)a1), v35)))
      {
        uint64_t v11 = v35;
        if (sub_100058654())
        {
          sub_100056E24((uint64_t)"recvdSMPDoSecuredConnectionPasskeySendCai failed %!", v36, v37, v38, v39, v40, v41, v42, v11);
          uint64_t v43 = sub_100050B4C(0x43u);
          if (os_log_type_enabled(v43, OS_LOG_TYPE_ERROR)) {
            goto LABEL_29;
          }
        }
      }
      else
      {
        return 0;
      }
    }
  }
  else
  {
    unsigned int v20 = *(_DWORD *)(a1 + 425);
    arc4random_buf((void *)(a1 + 457), 0x10uLL);
    char v21 = *(unsigned char *)(a1 + 489);
    long long v22 = v3[1];
    long long v53 = *v3;
    long long v54 = v22;
    long long v23 = v4[1];
    long long v55 = *v4;
    long long v56 = v23;
    if ((v20 >> v21)) {
      char v24 = -127;
    }
    else {
      char v24 = 0x80;
    }
    uint64_t v25 = sub_100180EA8(&v55, &v53, (long long *)(a1 + 457), v24, v2);
    if (v25)
    {
      uint64_t v11 = v25;
      if (sub_100058654())
      {
        sub_100056E24((uint64_t)"Failed to generate confirmation value C %!", v26, v27, v28, v29, v30, v31, v32, v11);
        uint64_t v33 = sub_100050B4C(0x43u);
        if (os_log_type_enabled(v33, OS_LOG_TYPE_ERROR)) {
          goto LABEL_29;
        }
      }
    }
    else
    {
      sub_1001F10F4(a1, 35);
      uint64_t v11 = sub_1002389B4(*(void *)a1, v2);
      if (v11)
      {
        if (sub_100058654())
        {
          sub_100056E24((uint64_t)"smpSendPairingConfirmation failed %!", v44, v45, v46, v47, v48, v49, v50, v11);
          uint64_t v51 = sub_100050B4C(0x43u);
          if (os_log_type_enabled(v51, OS_LOG_TYPE_ERROR)) {
            goto LABEL_29;
          }
        }
      }
    }
  }
  return v11;
}

uint64_t sub_100238814(uint64_t a1, int a2, void *a3, uint8x8_t a4)
{
  int8x16_t v18 = 0uLL;
  int8x16_t v17 = 0uLL;
  uint64_t v4 = *(__int8 **)a1;
  unsigned int v5 = (__int32 *)(a1 + 579);
  char v6 = (__int32 *)(a1 + 586);
  if (*(unsigned char *)(*(void *)a1 + 70))
  {
    v18.i8[0] = v4[48];
    v18.i8[1] = v4[63];
    *(__int32 *)((char *)v18.i32 + 2) = *v5;
    *(__int32 *)((char *)&v18.i32[1] + 1) = *(_DWORD *)(a1 + 582);
    *(__int32 *)((char *)&v18.i32[2] + 1) = *v6;
    v18.i32[3] = *(_DWORD *)(a1 + 589);
    a4.i32[0] = *(_DWORD *)(v4 + 66);
    int16x8_t v7 = (int16x8_t)vmovl_u8(a4);
    *(int16x4_t *)v7.i8 = vrev64_s16(*(int16x4_t *)v7.i8);
    v17.i32[0] = vmovn_s16(v7).u32[0];
    v17.i8[4] = v4[65];
    v17.i8[5] = v4[64];
    long long v8 = v4 + 49;
    v17.i8[6] = v4[54];
    v17.i8[7] = v4[53];
    char v9 = v4 + 52;
    uint64_t v10 = v4 + 51;
    uint64_t v11 = v4 + 50;
  }
  else
  {
    v18.i8[0] = v4[63];
    v18.i8[1] = v4[48];
    *(__int32 *)((char *)v18.i32 + 2) = *v5;
    *(__int32 *)((char *)&v18.i32[1] + 1) = *(_DWORD *)(a1 + 582);
    *(__int32 *)((char *)&v18.i32[2] + 1) = *v6;
    v18.i32[3] = *(_DWORD *)(a1 + 589);
    a4.i32[0] = *(_DWORD *)(v4 + 51);
    int16x8_t v12 = (int16x8_t)vmovl_u8(a4);
    *(int16x4_t *)v12.i8 = vrev64_s16(*(int16x4_t *)v12.i8);
    v17.i32[0] = vmovn_s16(v12).u32[0];
    v17.i8[4] = v4[50];
    v17.i8[5] = v4[49];
    long long v8 = v4 + 64;
    v17.i8[6] = v4[69];
    v17.i8[7] = v4[68];
    char v9 = v4 + 67;
    uint64_t v10 = v4 + 66;
    uint64_t v11 = v4 + 65;
  }
  __int8 v13 = *v8;
  __int8 v14 = *v11;
  __int8 v15 = *v10;
  v17.i8[8] = *v9;
  v17.i8[9] = v15;
  v17.i8[10] = v14;
  v17.i8[11] = v13;
  return sub_100180914((long long *)(a1 + 17), &v18, &v17, (int8x16_t *)(a1 + 136), (int8x16_t *)(a1 + 120), a2, a3);
}

uint64_t sub_1002389B4(uint64_t a1, void *a2)
{
  if (byte_100A102B1)
  {
    *a2 = 0;
    a2[1] = 0;
  }
  char v73 = 3;
  long long v74 = *(_OWORD *)a2;
  if (sub_100197770(a1))
  {
    uint64_t v3 = sub_1001F0BBC(a1);
    if (v3)
    {
      uint64_t v4 = v3;
      int v5 = *(unsigned __int8 *)(a1 + 70);
      if ((*(unsigned char *)(v3 + 72) & *(unsigned char *)(v3 + 80) & 8) != 0)
      {
        if (v5 != 1)
        {
LABEL_9:
          if (!v5 && !sub_1001F11E4(v4, 35))
          {
            if (!sub_100058654()) {
              return 4823;
            }
            char v6 = sub_1001F10E8();
            sub_100056E24((uint64_t)"Central connection should be in SMP_STATE_PAIRING_SCONFIRM to send this command, current state is %s.", v7, v8, v9, v10, v11, v12, v13, (uint64_t)v6);
            __int8 v14 = sub_100050B4C(0x43u);
            if (!os_log_type_enabled(v14, OS_LOG_TYPE_ERROR)) {
              return 4823;
            }
            goto LABEL_44;
          }
LABEL_26:
          uint64_t v32 = sub_1001F0C08(*(void *)v4, &v73, 0x11uLL, 1);
          if (v32)
          {
            uint64_t v23 = v32;
            sub_1001F0828((char *)v4, v32, 1);
            return v23;
          }
          if ((*(unsigned char *)(v4 + 72) & *(unsigned char *)(v4 + 80) & 8) != 0)
          {
            int v33 = *(unsigned __int8 *)(v4 + 16);
            switch(v33)
            {
              case 6:
                goto LABEL_32;
              case 5:
                if (sub_100058654())
                {
                  sub_100056E24((uint64_t)"Should not be here !", v64, v65, v66, v67, v68, v69, v70, v72);
                  uint64_t v71 = sub_100050B4C(0x43u);
                  if (os_log_type_enabled(v71, OS_LOG_TYPE_ERROR)) {
                    sub_100744F6C();
                  }
                }
                sub_1001F0828((char *)v4, 408, 1);
                return 0;
              case 1:
LABEL_32:
                uint64_t v34 = v4;
                char v35 = 36;
LABEL_55:
                sub_1001F10F4(v34, v35);
                return 0;
            }
            if (*(unsigned char *)(*(void *)v4 + 70) == 1) {
              char v35 = 36;
            }
            else {
              char v35 = 35;
            }
          }
          else if (*(unsigned char *)(a1 + 70))
          {
            char v35 = 35;
          }
          else
          {
            char v35 = 34;
          }
          uint64_t v34 = v4;
          goto LABEL_55;
        }
        if (sub_1001F11E4(v3, 34))
        {
          int v5 = *(unsigned __int8 *)(a1 + 70);
          goto LABEL_9;
        }
        if (!sub_100058654()) {
          return 4823;
        }
        uint64_t v36 = sub_1001F10E8();
        sub_100056E24((uint64_t)"Peripheral connection should be in SMP_STATE_PAIRING_MPUBLICK to send this command, current state is %s.", v37, v38, v39, v40, v41, v42, v43, (uint64_t)v36);
        uint64_t v44 = sub_100050B4C(0x43u);
        if (!os_log_type_enabled(v44, OS_LOG_TYPE_ERROR)) {
          return 4823;
        }
      }
      else
      {
        if (!*(unsigned char *)(a1 + 70))
        {
          if (!sub_1001F11E4(v3, 18))
          {
            if (!sub_100058654()) {
              return 4823;
            }
            long long v54 = sub_1001F10E8();
            sub_100056E24((uint64_t)"Central connection should be in SMP_STATE_PAIRING_RESP to send this command, current state is %s.", v55, v56, v57, v58, v59, v60, v61, (uint64_t)v54);
            uint64_t v62 = sub_100050B4C(0x43u);
            if (!os_log_type_enabled(v62, OS_LOG_TYPE_ERROR)) {
              return 4823;
            }
            goto LABEL_44;
          }
          int v5 = *(unsigned __int8 *)(a1 + 70);
        }
        if (v5 != 1 || sub_1001F11E4(v4, 34)) {
          goto LABEL_26;
        }
        if (!sub_100058654()) {
          return 4823;
        }
        uint64_t v45 = sub_1001F10E8();
        sub_100056E24((uint64_t)"Peripheral connection should be in SMP_STATE_PAIRING_MCONFIRM to send this command, current state is %s.", v46, v47, v48, v49, v50, v51, v52, (uint64_t)v45);
        long long v53 = sub_100050B4C(0x43u);
        if (!os_log_type_enabled(v53, OS_LOG_TYPE_ERROR)) {
          return 4823;
        }
      }
    }
    else
    {
      if (!sub_100058654()) {
        return 4823;
      }
      sub_100056E24((uint64_t)"This device is not in a pairing state.", v24, v25, v26, v27, v28, v29, v30, v72);
      uint64_t v31 = sub_100050B4C(0x43u);
      if (!os_log_type_enabled(v31, OS_LOG_TYPE_ERROR)) {
        return 4823;
      }
    }
LABEL_44:
    sub_100744F6C();
    return 4823;
  }
  if (sub_100058654())
  {
    sub_100056E24((uint64_t)"This command is only available to LE devices.", v15, v16, v17, v18, v19, v20, v21, v72);
    long long v22 = sub_100050B4C(0x43u);
    if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR)) {
      sub_100744F6C();
    }
  }
  return 4820;
}

uint64_t sub_100238D74(uint64_t a1, int a2, unsigned __int8 a3)
{
  char v3 = byte_1009FAEF9;
  if (byte_1009FAEF9 == 255) {
    char v3 = 11;
  }
  if (byte_1009FAEFA == 255) {
    char v4 = 11;
  }
  else {
    char v4 = byte_1009FAEFA;
  }
  char v5 = v3 & 0xF7;
  char v6 = v4 & 0xF7;
  if (byte_100A10260) {
    char v7 = v3 & 0xF7;
  }
  else {
    char v7 = v3;
  }
  if (byte_100A10260) {
    char v8 = v4 & 0xF7;
  }
  else {
    char v8 = v4;
  }
  if (!a1 || !sub_100197770(a1))
  {
    if (!sub_100058654()) {
      return 4820;
    }
    sub_100056E24((uint64_t)"This handle is not a LE connection.", v25, v26, v27, v28, v29, v30, v31, v97);
    uint64_t v32 = sub_100050B4C(0x43u);
    if (!os_log_type_enabled(v32, OS_LOG_TYPE_ERROR)) {
      return 4820;
    }
LABEL_34:
    sub_100744F6C();
    return 4820;
  }
  uint64_t v12 = sub_1001F0BBC(a1);
  if (!v12)
  {
    if (!sub_100058654()) {
      return 4820;
    }
    sub_100056E24((uint64_t)"There is no security request for this connection. Ignoring reply.", v34, v35, v36, v37, v38, v39, v40, v97);
    uint64_t v41 = sub_100050B4C(0x43u);
    if (!os_log_type_enabled(v41, OS_LOG_TYPE_ERROR)) {
      return 4820;
    }
    goto LABEL_34;
  }
  uint64_t v13 = (char *)v12;
  *(unsigned char *)(v12 + 72) = a3;
  if (!a2)
  {
LABEL_73:
    sub_1002379C0(a1, 8, v13);
    return 0;
  }
  if (*(unsigned char *)(a1 + 55)) {
    __int8 v14 = (_DWORD *)(a1 + 56);
  }
  else {
    __int8 v14 = 0;
  }
  BOOL v15 = sub_100233B84((_DWORD *)(a1 + 48), v14);
  char v16 = v13[80];
  if ((v16 & 4) != 0 && byte_1009FAEFB != 3) {
    v13[72] |= 4u;
  }
  if ((v16 & 8) != 0 && byte_100A10261)
  {
    v13[72] |= 8u;
    if ((byte_100A10262 & 1) == 0 && (v16 & 0x20) != 0 && !*(unsigned char *)(a1 + 232) && (v7 & 8) != 0)
    {
      if (sub_100058654())
      {
        sub_100056E24((uint64_t)"Sending CT2=1", v17, v18, v19, v20, v21, v22, v23, v97);
        uint64_t v24 = sub_100050B4C(0x43u);
        if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v99 = sub_100050714();
          _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
        }
      }
      a3 |= 0x20u;
    }
  }
  else
  {
    a3 &= ~0x20u;
    char v7 = v5;
    char v8 = v6;
  }
  if (*(unsigned char *)(a1 + 232)) {
    unsigned __int8 v42 = a3 & 0xDF;
  }
  else {
    unsigned __int8 v42 = a3;
  }
  if (*(unsigned char *)(a1 + 232))
  {
    char v7 = v5;
    char v43 = v6;
  }
  else
  {
    char v43 = v8;
  }
  if (byte_100A10263 == 1 && (v42 & 0x20) == 0)
  {
    if (sub_100058654())
    {
      sub_100056E24((uint64_t)"Force sending CT2=1", v44, v45, v46, v47, v48, v49, v50, v97);
      uint64_t v51 = sub_100050B4C(0x43u);
      if (os_log_type_enabled(v51, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v52 = sub_100050714();
        *(_DWORD *)buf = 136446210;
        uint64_t v99 = v52;
        _os_log_impl((void *)&_mh_execute_header, v51, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
      }
    }
    v42 |= 0x20u;
  }
  v13[73] = v15;
  v13[76] &= v7;
  v13[74] &= v43;
  v13[72] |= byte_100A10264 | v42;
  if (sub_100058654())
  {
    sub_100056E24((uint64_t)"authReq=%x expectedKeys=%x requestedKeys=%x", v53, v54, v55, v56, v57, v58, v59, v42);
    uint64_t v60 = sub_100050B4C(0x43u);
    if (os_log_type_enabled(v60, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v61 = sub_100050714();
      *(_DWORD *)buf = 136446210;
      uint64_t v99 = v61;
      _os_log_impl((void *)&_mh_execute_header, v60, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
    }
  }
  uint8_t v62 = v13[73];
  uint8_t v63 = v13[72];
  char v64 = v13[74];
  char v65 = v13[76];
  buf[0] = 2;
  buf[1] = byte_1009FAEFB;
  buf[2] = v62;
  buf[3] = v63;
  LOBYTE(v99) = 16;
  BYTE1(v99) = v64;
  BYTE2(v99) = v65;
  if (!sub_100197770(a1))
  {
    if (!sub_100058654()) {
      goto LABEL_73;
    }
    sub_100056E24((uint64_t)"This command is only available to LE devices.", v69, v70, v71, v72, v73, v74, v75, v97);
    uint64_t v76 = sub_100050B4C(0x43u);
    if (!os_log_type_enabled(v76, OS_LOG_TYPE_ERROR)) {
      goto LABEL_73;
    }
    goto LABEL_72;
  }
  if (*(unsigned char *)(a1 + 70) != 1)
  {
    if (!sub_100058654()) {
      goto LABEL_73;
    }
    sub_100056E24((uint64_t)"You cannot send this command when central.", v77, v78, v79, v80, v81, v82, v83, v97);
    uint64_t v84 = sub_100050B4C(0x43u);
    if (!os_log_type_enabled(v84, OS_LOG_TYPE_ERROR)) {
      goto LABEL_73;
    }
    goto LABEL_72;
  }
  uint64_t v66 = sub_1001F0BBC(a1);
  if (!v66)
  {
    if ((sub_100058654() & 1) == 0) {
      goto LABEL_73;
    }
    goto LABEL_71;
  }
  uint64_t v67 = v66;
  if (!sub_1001F11E4(v66, 17))
  {
    if (!sub_100058654()) {
      goto LABEL_73;
    }
    sub_1001F10E8();
LABEL_71:
    sub_100056E24((uint64_t)"Invalid pairing state for handle 0x%x : %s", v85, v86, v87, v88, v89, v90, v91, a1);
    uint64_t v92 = sub_100050B4C(0x43u);
    if (!os_log_type_enabled(v92, OS_LOG_TYPE_ERROR)) {
      goto LABEL_73;
    }
LABEL_72:
    sub_100744F6C();
    goto LABEL_73;
  }
  uint64_t v68 = sub_1001F0C08(*(void *)v67, (char *)buf, 7uLL, 1);
  if (v68)
  {
    sub_1001F0828((char *)v67, v68, 1);
    goto LABEL_73;
  }
  sub_1001F10F4(v67, 18);
  *(_DWORD *)(v67 + 586) = *(_DWORD *)buf;
  *(_WORD *)(v67 + 590) = (_WORD)v99;
  *(unsigned char *)(v67 + 592) = BYTE2(v99);
  int v93 = v13[72];
  int v94 = v13[80];
  int v95 = v13[73];
  if ((v93 & v94 & 8) != 0)
  {
    if (v95 == 1) {
      goto LABEL_79;
    }
  }
  else if (v95 != 1)
  {
    goto LABEL_80;
  }
  if (v13[79] == 1)
  {
LABEL_79:
    char v96 = 5;
    goto LABEL_83;
  }
LABEL_80:
  if (((v94 | v93) & 4) != 0) {
    char v96 = sub_100239354(v13[78], byte_1009FAEFB, (v93 & v94 & 8) != 0);
  }
  else {
    char v96 = 1;
  }
LABEL_83:
  v13[16] = v96;
  uint64_t result = sub_1002394C8((uint64_t)v13, 0);
  if (result) {
    goto LABEL_73;
  }
  return result;
}

uint64_t sub_100239354(int a1, unsigned int a2, int a3)
{
  switch(a1)
  {
    case 0:
      if (a2 >= 5) {
        goto LABEL_14;
      }
      unint64_t v3 = 0x201020101uLL >> (8 * a2);
      break;
    case 1:
      LOBYTE(v3) = 1;
      switch(a2)
      {
        case 0u:
        case 3u:
          return v3;
        case 1u:
          if (a3) {
            LOBYTE(v3) = 6;
          }
          else {
            LOBYTE(v3) = 1;
          }
          break;
        case 2u:
          goto LABEL_16;
        case 4u:
          goto LABEL_17;
        default:
          goto LABEL_14;
      }
      break;
    case 2:
      if (a2 >= 5) {
        goto LABEL_14;
      }
      unint64_t v3 = 0x301040303uLL >> (8 * a2);
      break;
    case 3:
      if (a2 >= 5) {
        goto LABEL_14;
      }
LABEL_13:
      LOBYTE(v3) = 1;
      break;
    case 4:
      LOBYTE(v3) = 3;
      switch(a2)
      {
        case 0u:
          return v3;
        case 1u:
          BOOL v4 = a3 == 0;
          LOBYTE(v3) = 3;
          goto LABEL_18;
        case 2u:
LABEL_16:
          LOBYTE(v3) = 2;
          return v3;
        case 3u:
          goto LABEL_13;
        case 4u:
LABEL_17:
          BOOL v4 = a3 == 0;
          LOBYTE(v3) = 2;
LABEL_18:
          if (!v4) {
            LOBYTE(v3) = 6;
          }
          break;
        default:
          goto LABEL_14;
      }
      break;
    default:
LABEL_14:
      sub_10025B8C0();
      LOBYTE(v3) = 1;
      break;
  }
  return v3;
}

uint64_t sub_1002394C8(uint64_t a1, int a2)
{
  char v3 = *(unsigned char *)(a1 + 80) & *(unsigned char *)(a1 + 72);
  if ((v3 & 8) == 0)
  {
    *(unsigned char *)(a1 + 74) &= ~8u;
    *(unsigned char *)(a1 + 76) &= ~8u;
    arc4random_buf((void *)(a1 + 120), 0x10uLL);
    if (off_100A19758)
    {
      int v5 = *(unsigned __int8 *)(a1 + 16);
      if (v5 != 1)
      {
        if (a2) {
          int v6 = 2;
        }
        else {
          int v6 = 3;
        }
        if (v5 == v6)
        {
          *(_DWORD *)__buf = 0;
          *(_DWORD *)(a1 + 52) = 1;
          arc4random_buf(__buf, 4uLL);
          unsigned int v7 = *(_DWORD *)__buf % 0xF423Fu + 1;
          *(_WORD *)(a1 + 33) = v7;
          *(_WORD *)(a1 + 35) = BYTE2(v7);
LABEL_35:
          sub_100240608(*(void *)a1);
          return 0;
        }
        if (v5 == 5) {
          int v18 = 3;
        }
        else {
          int v18 = 2;
        }
LABEL_34:
        *(_DWORD *)(a1 + 52) = v18;
        goto LABEL_35;
      }
LABEL_23:
      *(_DWORD *)(a1 + 52) = 0;
      goto LABEL_35;
    }
    return 4824;
  }
  *(unsigned char *)(a1 + 77) |= 1u;
  *(unsigned char *)(a1 + 75) |= 1u;
  if ((*(unsigned char *)(a1 + 76) & 8) != 0)
  {
    char v8 = *(unsigned char *)(a1 + 74);
    *(unsigned char *)(a1 + 594) = (v8 & 8) != 0;
    if ((v3 & 0x20) != 0 && (v8 & 8) != 0)
    {
      if (sub_100058654())
      {
        sub_100056E24((uint64_t)"Both sides set CT2=1, will use H7", v9, v10, v11, v12, v13, v14, v15, v31);
        char v16 = sub_100050B4C(0x43u);
        if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)__buf = 136446210;
          *(void *)&__uint8_t buf[4] = sub_100050714();
          _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, " %{public}s", __buf, 0xCu);
        }
      }
      *(unsigned char *)(a1 + 593) = 1;
    }
  }
  else
  {
    *(unsigned char *)(a1 + 594) = 0;
  }
  if (*(unsigned char *)(*(void *)a1 + 70) == 1) {
    sub_1001F10F4(a1, 32);
  }
  int v17 = *(unsigned __int8 *)(a1 + 16);
  if (v17 == 1) {
    goto LABEL_23;
  }
  if (v17 == 5)
  {
    if (off_100A19758)
    {
      int v18 = 5;
      goto LABEL_34;
    }
    if (sub_100058654())
    {
      sub_100056E24((uint64_t)"Cannot do OOB if there is no PAIRING_DISPLAY callback registered", v21, v22, v23, v24, v25, v26, v27, v31);
      uint64_t v28 = sub_100050B4C(0x43u);
      if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR)) {
        sub_100744F6C();
      }
    }
    return 4824;
  }
  if (*(unsigned char *)(*(void *)a1 + 70) == 1) {
    return 0;
  }
  uint64_t v19 = (_OWORD *)(a1 + 152);
  uint64_t result = sub_1001818CC((_OWORD *)(a1 + 152), (_OWORD *)(a1 + 216));
  if (result)
  {
    *(_OWORD *)(a1 + 184) = 0u;
    *(_OWORD *)(a1 + 200) = 0u;
    *uint64_t v19 = 0u;
    *(_OWORD *)(a1 + 168) = 0u;
    *(_OWORD *)(a1 + 216) = 0u;
    *(_OWORD *)(a1 + 232) = 0u;
    *(_OWORD *)(a1 + 248) = 0u;
    *(_OWORD *)(a1 + 264) = 0u;
    *(_OWORD *)(a1 + 280) = 0u;
    *(_OWORD *)(a1 + 296) = 0u;
  }
  else
  {
    sub_1001F10F4(a1, 33);
    __buf[0] = 12;
    long long v29 = *(_OWORD *)(a1 + 168);
    *(_OWORD *)&__buf[1] = *v19;
    long long v33 = v29;
    long long v30 = *(_OWORD *)(a1 + 200);
    long long v34 = *(_OWORD *)(a1 + 184);
    long long v35 = v30;
    return sub_1001F0C08(*(void *)a1, __buf, 0x41uLL, 1);
  }
  return result;
}

uint64_t sub_1002397E4(const void *a1, unsigned int a2)
{
  if (a2 < 0x10) {
    return 1;
  }
  long long __s2 = xmmword_1007BA9F0;
  v13[0] = 0;
  v13[1] = 0;
  sub_100008A18((uint64_t)v13, (uint64_t)&__s2, 0x10uLL);
  if (memcmp(a1, &__s2, a2))
  {
    if (memcmp(a1, v13, a2)) {
      return 1;
    }
  }
  uint64_t result = sub_100058654();
  if (result)
  {
    sub_100056E24((uint64_t)"Peer device is using a debug LTK, aborting pairing", v5, v6, v7, v8, v9, v10, v11, v13[0]);
    uint64_t v12 = sub_100050B4C(0x43u);
    uint64_t result = os_log_type_enabled(v12, OS_LOG_TYPE_ERROR);
    if (result)
    {
      sub_100744F6C();
      return 0;
    }
  }
  return result;
}

uint64_t sub_1002398DC(unsigned char *a1, uint64_t a2)
{
  if (!a2)
  {
    if (sub_100058654())
    {
      sub_100056E24((uint64_t)"Invalid keys structure.", v22, v23, v24, v25, v26, v27, v28, v35);
      long long v29 = sub_100050B4C(0x43u);
      if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR)) {
        sub_100744F6C();
      }
    }
    return 101;
  }
  if (!a1 || !sub_100197770((uint64_t)a1))
  {
    if (sub_100058654())
    {
      sub_100056E24((uint64_t)"This handle is not a LE connection.", v14, v15, v16, v17, v18, v19, v20, v35);
      uint64_t v21 = sub_100050B4C(0x43u);
      if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR)) {
        sub_100744F6C();
      }
    }
    return 4820;
  }
  a1[264] = *(unsigned char *)(a2 + 82);
  if (a1[166] == 3)
  {
    if (a1[55]) {
      BOOL v4 = a1 + 56;
    }
    else {
      BOOL v4 = a1 + 48;
    }
    uint64_t v5 = sub_100233780(v4, a2 + 28, *(unsigned __int8 *)(a2 + 44), *(unsigned char *)(a2 + 45));
    if (v5 && sub_100058654())
    {
      sub_100056E24((uint64_t)"LE_LongTermKeyReply failed %!", v6, v7, v8, v9, v10, v11, v12, v5);
      uint64_t v13 = sub_100050B4C(0x43u);
      if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR)) {
        sub_100745764();
      }
    }
    return v5;
  }
  int v31 = *(unsigned __int16 *)(a2 + 80);
  if ((v31 & 8) != 0 && (*(unsigned char *)(a2 + 45) & 0xFE) == 2)
  {
    uint64_t v36 = 0;
    a1[208] = 1;
    return sub_10023436C(a1, (uint64_t)&v36, 0, a2 + 28, *(unsigned __int8 *)(a2 + 44), *(unsigned char *)(a2 + 45));
  }
  if ((~v31 & 7) != 0) {
    return 101;
  }
  a1[208] = 1;
  uint64_t v32 = *(unsigned __int16 *)(a2 + 18);
  uint64_t v33 = *(unsigned __int8 *)(a2 + 16);
  char v34 = *(unsigned char *)(a2 + 17);

  return sub_10023436C(a1, a2 + 20, v32, a2, v33, v34);
}

uint64_t sub_100239B08(uint64_t a1, int a2, uint64_t a3)
{
  char v3 = byte_1009FAEF9;
  if (byte_1009FAEF9 == 255) {
    char v3 = 11;
  }
  if (byte_1009FAEFA == 255) {
    char v4 = 11;
  }
  else {
    char v4 = byte_1009FAEFA;
  }
  char v5 = v3 & 0xF7;
  char v6 = v4 & 0xF7;
  if (byte_100A10260) {
    char v7 = v3 & 0xF7;
  }
  else {
    char v7 = v3;
  }
  if (byte_100A10260) {
    char v8 = v4 & 0xF7;
  }
  else {
    char v8 = v4;
  }
  if (!a1 || !sub_100197770(a1))
  {
    if (!sub_100058654()) {
      return 4820;
    }
    sub_100056E24((uint64_t)"This handle is not a LE connection.", v29, v30, v31, v32, v33, v34, v35, v59);
    uint64_t v36 = sub_100050B4C(0x43u);
    if (!os_log_type_enabled(v36, OS_LOG_TYPE_ERROR)) {
      return 4820;
    }
LABEL_33:
    sub_100744F6C();
    return 4820;
  }
  uint64_t v12 = sub_1001F0BBC(a1);
  if (!v12)
  {
    if (!sub_100058654()) {
      return 4820;
    }
    sub_100056E24((uint64_t)"There is no security request for this connection. Ignoring reply.", v37, v38, v39, v40, v41, v42, v43, v59);
    uint64_t v44 = sub_100050B4C(0x43u);
    if (!os_log_type_enabled(v44, OS_LOG_TYPE_ERROR)) {
      return 4820;
    }
    goto LABEL_33;
  }
  uint64_t v13 = (char *)v12;
  if (!a2) {
    goto LABEL_53;
  }
  if (!a3 || (uint64_t result = sub_1002345C4((unsigned char *)a1, a3), result))
  {
    if (*(unsigned char *)(a1 + 55)) {
      uint64_t v15 = (_DWORD *)(a1 + 56);
    }
    else {
      uint64_t v15 = 0;
    }
    char v16 = sub_100233B84((_DWORD *)(a1 + 48), v15);
    int v17 = v13[80] & 4;
    int v18 = byte_100A10264;
    int v19 = v17 | v18 | sub_1002290A0();
    if ((v13[80] & 8) != 0 && byte_100A10261)
    {
      unsigned __int8 v20 = v19 | 8;
      if ((byte_100A10262 & 1) == 0 && (v13[80] & 0x20) != 0 && !*(unsigned char *)(a1 + 232) && (v7 & 8) != 0)
      {
        if (sub_100058654())
        {
          sub_100056E24((uint64_t)"Sending CT2=1", v21, v22, v23, v24, v25, v26, v27, v59);
          uint64_t v28 = sub_100050B4C(0x43u);
          if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 136446210;
            uint64_t v61 = sub_100050714();
            _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
          }
        }
        unsigned __int8 v20 = v19 | 0x28;
      }
    }
    else
    {
      unsigned __int8 v20 = v19 & 0xDF;
      char v7 = v5;
      char v8 = v6;
    }
    if (*(unsigned char *)(a1 + 232)) {
      unsigned __int8 v45 = v20 & 0xDF;
    }
    else {
      unsigned __int8 v45 = v20;
    }
    if (*(unsigned char *)(a1 + 232))
    {
      char v7 = v5;
      char v46 = v6;
    }
    else
    {
      char v46 = v8;
    }
    if (sub_100058654())
    {
      sub_100056E24((uint64_t)"authReq=%x expectedKeys=%x requestedKeys=%x", v47, v48, v49, v50, v51, v52, v53, v45);
      uint64_t v54 = sub_100050B4C(0x43u);
      if (os_log_type_enabled(v54, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v55 = sub_100050714();
        *(_DWORD *)buf = 136446210;
        uint64_t v61 = v55;
        _os_log_impl((void *)&_mh_execute_header, v54, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
      }
    }
    if (byte_100A10265)
    {
      uint64_t v56 = a1;
      int v57 = 3;
LABEL_54:
      sub_1002379C0(v56, v57, v13);
      return 0;
    }
    int v58 = sub_100239E6C(a1, byte_1009FAEFB, v16, v45, v7, v46);
    uint64_t result = 0;
    if (v58)
    {
      if (v58 != 4804)
      {
LABEL_53:
        uint64_t v56 = a1;
        int v57 = 8;
        goto LABEL_54;
      }
    }
  }
  return result;
}

uint64_t sub_100239E6C(uint64_t a1, char a2, char a3, char a4, char a5, char a6)
{
  LOBYTE(v47) = 1;
  BYTE1(v47) = a2;
  BYTE2(v47) = a3;
  HIBYTE(v47) = a4;
  LOBYTE(v48) = 16;
  HIBYTE(v48) = a5;
  char v49 = a6;
  if (sub_100197770(a1))
  {
    if (*(unsigned char *)(a1 + 70))
    {
      if (sub_100058654())
      {
        sub_100056E24((uint64_t)"You cannot send this command when peripheral.", v9, v10, v11, v12, v13, v14, v15, v46);
        char v16 = sub_100050B4C(0x43u);
        if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR)) {
          sub_100744F6C();
        }
      }
      return 4821;
    }
    uint64_t v27 = sub_1001F0BBC(a1);
    if (v27)
    {
      uint64_t v28 = (unsigned char *)v27;
      if (*(unsigned __int8 *)(v27 + 8) >= 0x11u)
      {
        if (sub_100058654())
        {
          uint64_t v29 = sub_1001F10E8();
          sub_100056E24((uint64_t)"Cannot ask for pairing, device is already in state %s.", v30, v31, v32, v33, v34, v35, v36, (uint64_t)v29);
          uint64_t v37 = sub_100050B4C(0x43u);
          if (os_log_type_enabled(v37, OS_LOG_TYPE_ERROR)) {
            sub_100745764();
          }
        }
        return 4804;
      }
LABEL_19:
      v28[72] = a4;
      v28[73] = a3;
      uint64_t v17 = sub_1001F0C08(*(void *)v28, (char *)&v47, 7uLL, 1);
      if (v17)
      {
        sub_1001F0828(v28, v17, 1);
      }
      else
      {
        sub_1001F10F4((uint64_t)v28, 17);
        *(_DWORD *)(v28 + 579) = v47;
        *(_WORD *)(v28 + 583) = v48;
        v28[585] = v49;
      }
      return v17;
    }
    uint64_t v28 = sub_1001F0EE8(a1);
    if (v28) {
      goto LABEL_19;
    }
    if (sub_100058654())
    {
      sub_100056E24((uint64_t)"Could not allocate a pairing record for handle 0x%x", v38, v39, v40, v41, v42, v43, v44, a1);
      unsigned __int8 v45 = sub_100050B4C(0x43u);
      if (os_log_type_enabled(v45, OS_LOG_TYPE_ERROR)) {
        sub_100745764();
      }
    }
    return 104;
  }
  else
  {
    if (sub_100058654())
    {
      sub_100056E24((uint64_t)"Invalid connection handle.", v18, v19, v20, v21, v22, v23, v24, v46);
      uint64_t v25 = sub_100050B4C(0x43u);
      if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR)) {
        sub_100744F6C();
      }
    }
    return 4820;
  }
}

void sub_10023A098(uint64_t a1, int *a2, uint64_t a3)
{
  uint64_t v110 = a1;
  char v6 = byte_1009FAEF9;
  if (byte_1009FAEF9 == 255) {
    char v6 = 11;
  }
  if (byte_1009FAEFA == 255) {
    char v7 = 11;
  }
  else {
    char v7 = byte_1009FAEFA;
  }
  if (byte_100A10260) {
    char v8 = v6 & 0xF7;
  }
  else {
    char v8 = v6;
  }
  if (byte_100A10260) {
    char v9 = v7 & 0xF7;
  }
  else {
    char v9 = v7;
  }
  uint64_t v10 = (uint64_t *)sub_1001F0BBC(a1);
  uint64_t v11 = (char *)v10;
  int v12 = byte_100A102B0;
  if (byte_100A102B0) {
    goto LABEL_51;
  }
  if (a3 != 6)
  {
    if (!sub_100058654()) {
      goto LABEL_50;
    }
    sub_100056E24((uint64_t)"Invalid Pairing Request size %d.", v22, v23, v24, v25, v26, v27, v28, a3);
    uint64_t v29 = sub_100050B4C(0x43u);
    if (!os_log_type_enabled(v29, OS_LOG_TYPE_ERROR)) {
      goto LABEL_50;
    }
LABEL_69:
    sub_100744F6C();
LABEL_50:
    int v12 = 8;
    goto LABEL_51;
  }
  if (!*(unsigned char *)(a1 + 70))
  {
    if (!sub_100058654()) {
      goto LABEL_50;
    }
    sub_100056E24((uint64_t)"This command should only be received if we are peripheral.", v30, v31, v32, v33, v34, v35, v36, v109);
    uint64_t v37 = sub_100050B4C(0x43u);
    if (!os_log_type_enabled(v37, OS_LOG_TYPE_ERROR)) {
      goto LABEL_50;
    }
    goto LABEL_69;
  }
  if (v10)
  {
    sub_1001F0FFC(v10);
    if (!sub_1001F11E4((uint64_t)v11, 16) && !v11[9])
    {
      if (!sub_100058654()) {
        goto LABEL_50;
      }
      uint64_t v13 = sub_1001F10E8();
      sub_100056E24((uint64_t)"Received pairing request from central, but we had already a previous non-encrypted entry in state %s.", v14, v15, v16, v17, v18, v19, v20, (uint64_t)v13);
      uint64_t v21 = sub_100050B4C(0x43u);
      if (!os_log_type_enabled(v21, OS_LOG_TYPE_ERROR)) {
        goto LABEL_50;
      }
      goto LABEL_69;
    }
  }
  else
  {
    uint64_t v11 = sub_1001F0EE8(a1);
    if (!v11)
    {
      if (sub_100058654())
      {
        sub_100056E24((uint64_t)"Could not allocate new device...", v70, v71, v72, v73, v74, v75, v76, v109);
        uint64_t v77 = sub_100050B4C(0x43u);
        if (os_log_type_enabled(v77, OS_LOG_TYPE_ERROR)) {
          sub_100744F6C();
        }
      }
      uint64_t v11 = 0;
      goto LABEL_50;
    }
  }
  sub_1001F0F88((uint64_t)v11, *(unsigned char *)a2, *((unsigned char *)a2 + 1), *((unsigned char *)a2 + 2), *((unsigned __int8 *)a2 + 3), *((unsigned char *)a2 + 4), *((unsigned char *)a2 + 5));
  if (v11[78] >= 5u)
  {
    if (sub_100058654())
    {
      sub_100056E24((uint64_t)"Invalid remote IOCaps %d.", v38, v39, v40, v41, v42, v43, v44, v11[78]);
      unsigned __int8 v45 = sub_100050B4C(0x43u);
      if (os_log_type_enabled(v45, OS_LOG_TYPE_ERROR)) {
        sub_100744F6C();
      }
    }
    goto LABEL_32;
  }
  if (v11[79] >= 2u)
  {
    if (!sub_100058654()) {
      goto LABEL_50;
    }
    sub_100056E24((uint64_t)"Invalid OOB flags %d.", v46, v47, v48, v49, v50, v51, v52, v11[79]);
    uint64_t v53 = sub_100050B4C(0x43u);
    if (!os_log_type_enabled(v53, OS_LOG_TYPE_ERROR)) {
      goto LABEL_50;
    }
    goto LABEL_69;
  }
  if ((v11[80] & 0xC2) != 0)
  {
    if (sub_100058654())
    {
      sub_100056E24((uint64_t)"Invalid authentication requirements 0x%x.", v54, v55, v56, v57, v58, v59, v60, v11[80]);
      uint64_t v61 = sub_100050B4C(0x43u);
      if (os_log_type_enabled(v61, OS_LOG_TYPE_ERROR)) {
        sub_100744F6C();
      }
    }
  }
  if (v11[81] - 17 <= 0xFFFFFFF5)
  {
    if (sub_100058654())
    {
      sub_100056E24((uint64_t)"Invalid maximum encryption size %d", v62, v63, v64, v65, v66, v67, v68, v11[81]);
      uint64_t v69 = sub_100050B4C(0x43u);
      if (os_log_type_enabled(v69, OS_LOG_TYPE_ERROR)) {
        sub_100744F6C();
      }
    }
    int v12 = 6;
    goto LABEL_51;
  }
  unsigned int v78 = v11[82];
  if (v78 > 0xF || (unsigned int v79 = v11[83], v79 >= 0x10))
  {
    if (!sub_100058654()) {
      goto LABEL_50;
    }
    sub_100056E24((uint64_t)"Invalid key distribution parameters initiator:0x%x, responder:0xx", v93, v94, v95, v96, v97, v98, v99, v11[82]);
    uint64_t v100 = sub_100050B4C(0x43u);
    if (!os_log_type_enabled(v100, OS_LOG_TYPE_ERROR)) {
      goto LABEL_50;
    }
    goto LABEL_69;
  }
  if (byte_100A10265 && (v11[80] & 8) == 0)
  {
LABEL_32:
    int v12 = 3;
LABEL_51:
    sub_1002379C0(a1, v12, v11);
    return;
  }
  char v80 = v78 & v9;
  if (byte_1009FAEF9 != -1) {
    char v80 = byte_1009FAEF9;
  }
  v11[74] = v80;
  v11[75] = 0;
  char v81 = v79 & v8;
  if (byte_1009FAEFA != 255) {
    char v81 = byte_1009FAEFA;
  }
  v11[76] = v81;
  v11[77] = 0;
  sub_1001F10F4((uint64_t)v11, 17);
  v11[579] = 1;
  int v82 = *a2;
  *((_WORD *)v11 + 292) = *((_WORD *)a2 + 2);
  *((_DWORD *)v11 + 145) = v82;
  if (off_100A19750)
  {
    if (*(_DWORD *)(v110 + 132) == 7)
    {
      *((void *)&buf + 1) = &v110;
      *(void *)&long long buf = 8;
      uint64_t v83 = sub_1000268E4((uint64_t)sub_10023EF04, (const void **)&buf, 0, 0);
      if (v83)
      {
        uint64_t v84 = v83;
        if (sub_100058654())
        {
          sub_100056E24((uint64_t)"Could not dispatch pairing request with status %!.", v85, v86, v87, v88, v89, v90, v91, v84);
          uint64_t v92 = sub_100050B4C(0x43u);
          if (os_log_type_enabled(v92, OS_LOG_TYPE_ERROR)) {
            sub_100745764();
          }
        }
      }
    }
    else if (sub_100058654())
    {
      sub_100056E24((uint64_t)"Got Pairing Request before link is ready for handle %p, lets handle this when the link is actually ready. Link state is %d", v101, v102, v103, v104, v105, v106, v107, v110);
      uint64_t v108 = sub_100050B4C(0x43u);
      if (os_log_type_enabled(v108, OS_LOG_TYPE_DEFAULT))
      {
        LODWORD(buf) = 136446210;
        *(void *)((char *)&buf + 4) = sub_100050714();
        _os_log_impl((void *)&_mh_execute_header, v108, OS_LOG_TYPE_DEFAULT, " %{public}s", (uint8_t *)&buf, 0xCu);
      }
    }
  }
}

uint64_t sub_10023A638(uint64_t a1, int *a2, uint64_t a3)
{
  char v6 = (uint64_t *)sub_1001F0BBC(a1);
  uint64_t v7 = (uint64_t)v6;
  if (!v6)
  {
    if (!sub_100058654()) {
      goto LABEL_46;
    }
    sub_100056E24((uint64_t)"Pairing response with no pairing request for handle %d.", v17, v18, v19, v20, v21, v22, v23, a1);
    uint64_t v24 = sub_100050B4C(0x43u);
    if (!os_log_type_enabled(v24, OS_LOG_TYPE_ERROR)) {
      goto LABEL_46;
    }
LABEL_45:
    sub_100744F6C();
LABEL_46:
    int v8 = 8;
    return sub_1002379C0(a1, v8, (char *)v7);
  }
  int v8 = byte_100A102B0;
  if (byte_100A102B0) {
    return sub_1002379C0(a1, v8, (char *)v7);
  }
  if (a3 != 6)
  {
    if (!sub_100058654()) {
      goto LABEL_46;
    }
    sub_100056E24((uint64_t)"Invalid Pairing Response size %d.", v25, v26, v27, v28, v29, v30, v31, a3);
    uint64_t v32 = sub_100050B4C(0x43u);
    if (!os_log_type_enabled(v32, OS_LOG_TYPE_ERROR)) {
      goto LABEL_46;
    }
    goto LABEL_45;
  }
  sub_1001F0FFC(v6);
  if (*(unsigned char *)(a1 + 70) == 1)
  {
    if (!sub_100058654()) {
      goto LABEL_46;
    }
    sub_100056E24((uint64_t)"This command should only be received if we are central.", v9, v10, v11, v12, v13, v14, v15, v89);
    uint64_t v16 = sub_100050B4C(0x43u);
    if (!os_log_type_enabled(v16, OS_LOG_TYPE_ERROR)) {
      goto LABEL_46;
    }
    goto LABEL_45;
  }
  if (!sub_1001F11E4(v7, 17))
  {
    if (!sub_100058654()) {
      goto LABEL_46;
    }
    sub_100056E24((uint64_t)"Pairing response was received without a pairing request for handle %d.", v41, v42, v43, v44, v45, v46, v47, a1);
    uint64_t v48 = sub_100050B4C(0x43u);
    if (!os_log_type_enabled(v48, OS_LOG_TYPE_ERROR)) {
      goto LABEL_46;
    }
    goto LABEL_45;
  }
  sub_1001F0F88(v7, *(unsigned char *)a2, *((unsigned char *)a2 + 1), *((unsigned char *)a2 + 2), *((unsigned __int8 *)a2 + 3), *((unsigned char *)a2 + 4), *((unsigned char *)a2 + 5));
  if (*(unsigned __int8 *)(v7 + 78) >= 5u)
  {
    if (sub_100058654())
    {
      sub_100056E24((uint64_t)"Invalid remote IOCaps %d.", v33, v34, v35, v36, v37, v38, v39, *(unsigned __int8 *)(v7 + 78));
      uint64_t v40 = sub_100050B4C(0x43u);
      if (os_log_type_enabled(v40, OS_LOG_TYPE_ERROR)) {
        sub_100744F6C();
      }
    }
    goto LABEL_19;
  }
  if (*(unsigned __int8 *)(v7 + 79) >= 2u)
  {
    if (!sub_100058654()) {
      goto LABEL_46;
    }
    sub_100056E24((uint64_t)"Invalid OOB flags %d.", v49, v50, v51, v52, v53, v54, v55, *(unsigned __int8 *)(v7 + 79));
    uint64_t v56 = sub_100050B4C(0x43u);
    if (!os_log_type_enabled(v56, OS_LOG_TYPE_ERROR)) {
      goto LABEL_46;
    }
    goto LABEL_45;
  }
  if ((*(unsigned char *)(v7 + 80) & 0xC2) != 0)
  {
    if (sub_100058654())
    {
      sub_100056E24((uint64_t)"Invalid authentication requirements 0x%x.", v57, v58, v59, v60, v61, v62, v63, *(unsigned __int8 *)(v7 + 80));
      uint64_t v64 = sub_100050B4C(0x43u);
      if (os_log_type_enabled(v64, OS_LOG_TYPE_ERROR)) {
        sub_100744F6C();
      }
    }
  }
  if (*(unsigned __int8 *)(v7 + 81) - 17 <= 0xFFFFFFF5)
  {
    if (sub_100058654())
    {
      sub_100056E24((uint64_t)"Invalid maximum encryption size %d", v65, v66, v67, v68, v69, v70, v71, *(unsigned __int8 *)(v7 + 81));
      uint64_t v72 = sub_100050B4C(0x43u);
      if (os_log_type_enabled(v72, OS_LOG_TYPE_ERROR)) {
        sub_100744F6C();
      }
    }
    int v8 = 6;
    return sub_1002379C0(a1, v8, (char *)v7);
  }
  unsigned int v73 = *(unsigned __int8 *)(v7 + 82);
  if (v73 > 0xF || (unsigned int v74 = *(unsigned __int8 *)(v7 + 83), v74 >= 0x10))
  {
    if (!sub_100058654()) {
      goto LABEL_46;
    }
    sub_100056E24((uint64_t)"Invalid key distribution parameters initiator:0x%x, responder:0xx", v78, v79, v80, v81, v82, v83, v84, *(unsigned __int8 *)(v7 + 82));
    uint64_t v85 = sub_100050B4C(0x43u);
    if (!os_log_type_enabled(v85, OS_LOG_TYPE_ERROR)) {
      goto LABEL_46;
    }
    goto LABEL_45;
  }
  *(unsigned char *)(v7 + 76) = v73 & 0xB;
  *(unsigned char *)(v7 + 75) = 0;
  *(unsigned char *)(v7 + 74) = v74 & 0xB;
  *(unsigned char *)(v7 + 77) = 0;
  sub_1001F10F4(v7, 18);
  int v75 = *(unsigned __int8 *)(v7 + 72);
  int v76 = *(unsigned __int8 *)(v7 + 80);
  if (byte_100A10265 && (v75 & v76 & 8) == 0)
  {
LABEL_19:
    int v8 = 3;
    return sub_1002379C0(a1, v8, (char *)v7);
  }
  int v77 = *(unsigned __int8 *)(v7 + 73);
  if ((v75 & v76 & 8) != 0)
  {
    if (v77 == 1) {
      goto LABEL_50;
    }
  }
  else if (v77 != 1)
  {
    goto LABEL_51;
  }
  if (*(unsigned char *)(v7 + 79) == 1)
  {
LABEL_50:
    char v87 = 5;
    goto LABEL_54;
  }
LABEL_51:
  if (((v76 | v75) & 4) != 0) {
    char v87 = sub_100239354(byte_1009FAEFB, *(unsigned __int8 *)(v7 + 78), (v75 & v76 & 8) != 0);
  }
  else {
    char v87 = 1;
  }
LABEL_54:
  *(unsigned char *)(v7 + 16) = v87;
  *(unsigned char *)(v7 + 586) = 2;
  int v88 = *a2;
  *(_WORD *)(v7 + 591) = *((_WORD *)a2 + 2);
  *(_DWORD *)(v7 + 587) = v88;
  uint64_t result = sub_1002394C8(v7, 1);
  if (result) {
    goto LABEL_46;
  }
  return result;
}

void sub_10023AA8C(uint64_t a1, _OWORD *a2, uint64_t a3)
{
  uint64_t v6 = sub_1001F0BBC(a1);
  uint64_t v7 = v6;
  if (!v6)
  {
    if (!sub_100058654()) {
      goto LABEL_23;
    }
    sub_100056E24((uint64_t)"Could not find associated pairing data.", v20, v21, v22, v23, v24, v25, v26, v128);
    uint64_t v27 = sub_100050B4C(0x43u);
    if (!os_log_type_enabled(v27, OS_LOG_TYPE_ERROR)) {
      goto LABEL_23;
    }
    goto LABEL_22;
  }
  if (a3 != 16)
  {
    if (!sub_100058654()) {
      goto LABEL_23;
    }
    sub_100056E24((uint64_t)"Invalid Pairing Confirmation size %d", v28, v29, v30, v31, v32, v33, v34, a3);
    uint64_t v35 = sub_100050B4C(0x43u);
    if (!os_log_type_enabled(v35, OS_LOG_TYPE_ERROR)) {
      goto LABEL_23;
    }
    goto LABEL_22;
  }
  char v8 = *(unsigned char *)(v6 + 72) & *(unsigned char *)(v6 + 80);
  uint64_t v9 = (uint64_t *)sub_1001F0BBC(a1);
  uint64_t v7 = (uint64_t)v9;
  if ((v8 & 8) != 0)
  {
    if (v9)
    {
      sub_1001F0FFC(v9);
      int v10 = *(unsigned __int8 *)(a1 + 70);
      if (v10 == 1)
      {
        if (!sub_1001F11E4(v7, 34))
        {
          if (!sub_100058654()) {
            goto LABEL_23;
          }
          uint64_t v53 = sub_1001F10E8();
          sub_100056E24((uint64_t)"Device was not in the proper state. State is %s.", v54, v55, v56, v57, v58, v59, v60, (uint64_t)v53);
          uint64_t v61 = sub_100050B4C(0x43u);
          if (!os_log_type_enabled(v61, OS_LOG_TYPE_ERROR)) {
            goto LABEL_23;
          }
          goto LABEL_22;
        }
        int v10 = *(unsigned __int8 *)(a1 + 70);
      }
      if (v10 || sub_1001F11E4(v7, 35))
      {
        *(_OWORD *)(v7 + 104) = *a2;
        int v11 = *(unsigned __int8 *)(v7 + 16);
        if (v11 == 6) {
          goto LABEL_13;
        }
        if (v11 != 5)
        {
          if (v11 != 1)
          {
            *(_OWORD *)(v7 + 104) = *a2;
            if (*(unsigned char *)(a1 + 70))
            {
              if (!*(unsigned char *)(v7 + 490)) {
                return;
              }
              if (!*(void *)(v7 + 104) && *(void *)(v7 + 112) == 0) {
                return;
              }
              uint64_t v71 = sub_100240578((uint64_t *)v7);
              if (!v71) {
                return;
              }
              uint64_t v72 = v71;
              if (!sub_100058654()) {
                goto LABEL_23;
              }
              sub_100056E24((uint64_t)"recvdSMPDoSecuredConnectionPasskeySendCai failed %!", v73, v74, v75, v76, v77, v78, v79, v72);
              uint64_t v80 = sub_100050B4C(0x43u);
              if (!os_log_type_enabled(v80, OS_LOG_TYPE_ERROR)) {
                goto LABEL_23;
              }
            }
            else
            {
              uint64_t v118 = sub_1002408F8(*(void *)v7, (long long *)(v7 + 457));
              if (!v118)
              {
LABEL_77:
                sub_1001F10F4(v7, 37);
                return;
              }
              uint64_t v119 = v118;
              if (!sub_100058654()) {
                goto LABEL_23;
              }
              sub_100056E24((uint64_t)"smpSendPairingRandom failed %!", v120, v121, v122, v123, v124, v125, v126, v119);
              v127 = sub_100050B4C(0x43u);
              if (!os_log_type_enabled(v127, OS_LOG_TYPE_ERROR)) {
                goto LABEL_23;
              }
            }
LABEL_76:
            sub_100745764();
            goto LABEL_23;
          }
LABEL_13:
          if (*(unsigned char *)(a1 + 70))
          {
            if (!sub_100058654()) {
              goto LABEL_23;
            }
            sub_100056E24((uint64_t)"At this point, peripheral should not get a confirmation value", v12, v13, v14, v15, v16, v17, v18, v128);
            uint64_t v19 = sub_100050B4C(0x43u);
            if (!os_log_type_enabled(v19, OS_LOG_TYPE_ERROR)) {
              goto LABEL_23;
            }
            goto LABEL_22;
          }
          uint64_t v99 = sub_1002408F8(a1, (long long *)(v7 + 457));
          if (v99)
          {
            uint64_t v100 = v99;
            if (!sub_100058654()) {
              goto LABEL_23;
            }
            sub_100056E24((uint64_t)"Failed to send pairing random to peripheral %!", v101, v102, v103, v104, v105, v106, v107, v100);
            uint64_t v108 = sub_100050B4C(0x43u);
            if (!os_log_type_enabled(v108, OS_LOG_TYPE_ERROR)) {
              goto LABEL_23;
            }
            goto LABEL_76;
          }
          goto LABEL_77;
        }
        if (!sub_100058654()) {
          goto LABEL_23;
        }
        sub_100056E24((uint64_t)"Should not be here !", v62, v63, v64, v65, v66, v67, v68, v128);
        uint64_t v69 = sub_100050B4C(0x43u);
        if (!os_log_type_enabled(v69, OS_LOG_TYPE_ERROR)) {
          goto LABEL_23;
        }
      }
      else
      {
        if (!sub_100058654()) {
          goto LABEL_23;
        }
        uint64_t v90 = sub_1001F10E8();
        sub_100056E24((uint64_t)"Device was not in the proper state. State is %s.", v91, v92, v93, v94, v95, v96, v97, (uint64_t)v90);
        uint64_t v98 = sub_100050B4C(0x43u);
        if (!os_log_type_enabled(v98, OS_LOG_TYPE_ERROR)) {
          goto LABEL_23;
        }
      }
    }
    else
    {
      if (!sub_100058654()) {
        goto LABEL_23;
      }
      sub_100056E24((uint64_t)"Could not find associated pairing data.", v37, v38, v39, v40, v41, v42, v43, v128);
      uint64_t v44 = sub_100050B4C(0x43u);
      if (!os_log_type_enabled(v44, OS_LOG_TYPE_ERROR)) {
        goto LABEL_23;
      }
    }
LABEL_22:
    sub_100744F6C();
LABEL_23:
    sub_1002379C0(a1, 8, (char *)v7);
    return;
  }
  if (!v9)
  {
    if (!sub_100058654()) {
      goto LABEL_23;
    }
    sub_100056E24((uint64_t)"Could not find associated pairing data.", v45, v46, v47, v48, v49, v50, v51, v128);
    uint64_t v52 = sub_100050B4C(0x43u);
    if (!os_log_type_enabled(v52, OS_LOG_TYPE_ERROR)) {
      goto LABEL_23;
    }
    goto LABEL_22;
  }
  sub_1001F0FFC(v9);
  int v36 = *(unsigned __int8 *)(a1 + 70);
  if (v36 == 1)
  {
    if (!sub_1001F11E4(v7, 18))
    {
      if (!sub_100058654()) {
        goto LABEL_23;
      }
      uint64_t v81 = sub_1001F10E8();
      sub_100056E24((uint64_t)"Device was not in the proper state. State is %s.", v82, v83, v84, v85, v86, v87, v88, (uint64_t)v81);
      uint64_t v89 = sub_100050B4C(0x43u);
      if (!os_log_type_enabled(v89, OS_LOG_TYPE_ERROR)) {
        goto LABEL_23;
      }
      goto LABEL_22;
    }
    int v36 = *(unsigned __int8 *)(a1 + 70);
  }
  if (!v36 && !sub_1001F11E4(v7, 34))
  {
    if (!sub_100058654()) {
      goto LABEL_23;
    }
    uint64_t v109 = sub_1001F10E8();
    sub_100056E24((uint64_t)"Device was not in the proper state. State is %s.", v110, v111, v112, v113, v114, v115, v116, (uint64_t)v109);
    v117 = sub_100050B4C(0x43u);
    if (!os_log_type_enabled(v117, OS_LOG_TYPE_ERROR)) {
      goto LABEL_23;
    }
    goto LABEL_22;
  }
  *(_OWORD *)(v7 + 104) = *a2;
  if (*(unsigned char *)(a1 + 70) == 1)
  {
    sub_1001F10F4(v7, 34);
    if (*(_DWORD *)(v7 + 84) != 2)
    {
      *(_DWORD *)(v7 + 84) = 1;
      return;
    }
    if (sub_1002389B4(a1, (void *)(v7 + 88))) {
      goto LABEL_23;
    }
  }
  else
  {
    sub_1001F10F4(v7, 35);
    if (sub_1002408F8(a1, (long long *)(v7 + 120))) {
      goto LABEL_23;
    }
  }
}

void sub_10023B074(unsigned char *a1, _OWORD *a2, uint64_t a3)
{
  uint64_t v6 = sub_1001F0BBC((uint64_t)a1);
  uint64_t v7 = v6;
  if (!v6)
  {
    if (!sub_100058654()) {
      goto LABEL_22;
    }
    sub_100056E24((uint64_t)"Could not find associated pairing data.", v13, v14, v15, v16, v17, v18, v19, v297);
    uint64_t v20 = sub_100050B4C(0x43u);
    if (!os_log_type_enabled(v20, OS_LOG_TYPE_ERROR)) {
      goto LABEL_22;
    }
    goto LABEL_21;
  }
  if (a3 != 16)
  {
    if (!sub_100058654()) {
      goto LABEL_22;
    }
    sub_100056E24((uint64_t)"Invalid Pairing Random size %d", v21, v22, v23, v24, v25, v26, v27, a3);
    uint64_t v28 = sub_100050B4C(0x43u);
    if (!os_log_type_enabled(v28, OS_LOG_TYPE_ERROR)) {
      goto LABEL_22;
    }
    goto LABEL_21;
  }
  if ((*(unsigned char *)(v6 + 72) & *(unsigned char *)(v6 + 80) & 8) == 0)
  {
    long long v303 = 0uLL;
    *(void *)&long long v301 = 0;
    uint64_t v31 = (uint64_t *)sub_1001F0BBC((uint64_t)a1);
    uint64_t v7 = (uint64_t)v31;
    if (v31)
    {
      sub_1001F0FFC(v31);
      int v32 = a1[70];
      if (v32 == 1)
      {
        if (!sub_1001F11E4(v7, 35))
        {
          if (!sub_100058654()) {
            goto LABEL_22;
          }
          uint64_t v99 = sub_1001F10E8();
          sub_100056E24((uint64_t)"Initiator device was not in the proper state. State is %s.", v100, v101, v102, v103, v104, v105, v106, (uint64_t)v99);
          uint64_t v107 = sub_100050B4C(0x43u);
          if (!os_log_type_enabled(v107, OS_LOG_TYPE_ERROR)) {
            goto LABEL_22;
          }
          goto LABEL_21;
        }
        int v32 = a1[70];
      }
      if (v32 || sub_1001F11E4(v7, 36))
      {
        *(_OWORD *)(v7 + 136) = *a2;
        if (a1[70] == 1) {
          char v33 = 36;
        }
        else {
          char v33 = 37;
        }
        sub_1001F10F4(v7, v33);
        if (sub_100238814(v7, 1, &v303, v34)) {
          goto LABEL_22;
        }
        if ((void)v303 == *(void *)(v7 + 104) && *((void *)&v303 + 1) == *(void *)(v7 + 112))
        {
          if (a1[70] == 1 && sub_1002408F8((uint64_t)a1, (long long *)(v7 + 120))) {
            goto LABEL_22;
          }
          sub_1001F10F4(v7, 40);
          v163 = (void *)(v7 + 120);
          if (a1[70])
          {
            v164 = (uint64_t *)(v7 + 120);
            v163 = (void *)(v7 + 136);
          }
          else
          {
            v164 = (uint64_t *)(v7 + 136);
          }
          if (sub_100180BC0((long long *)(v7 + 17), v164, v163, (void *)(v7 + 56))) {
            goto LABEL_22;
          }
          uint64_t v220 = *(unsigned __int8 *)(v7 + 81);
          if (v220 != 16) {
            bzero((void *)(v7 + 56 + v220), 16 - v220);
          }
          sub_1001F10F4(v7, 41);
          if (!a1[70])
          {
            if (sub_10023436C(a1, (uint64_t)&v301, 0, v7 + 56, 16, *(unsigned char *)(v7 + 16) != 1)) {
              goto LABEL_22;
            }
          }
          return;
        }
        if (sub_100058654())
        {
          sub_100056E24((uint64_t)"The confirmation value does not match.", v36, v37, v38, v39, v40, v41, v42, v297);
          uint64_t v43 = sub_100050B4C(0x43u);
          if (os_log_type_enabled(v43, OS_LOG_TYPE_ERROR)) {
            sub_100744F6C();
          }
        }
LABEL_42:
        uint64_t v29 = (uint64_t)a1;
        int v30 = 4;
        goto LABEL_23;
      }
      if (!sub_100058654()) {
        goto LABEL_22;
      }
      v117 = sub_1001F10E8();
      sub_100056E24((uint64_t)"Responder device was not in the proper state. State is %s.", v118, v119, v120, v121, v122, v123, v124, (uint64_t)v117);
      uint64_t v125 = sub_100050B4C(0x43u);
      if (!os_log_type_enabled(v125, OS_LOG_TYPE_ERROR)) {
        goto LABEL_22;
      }
    }
    else
    {
      if (!sub_100058654()) {
        goto LABEL_22;
      }
      sub_100056E24((uint64_t)"Could not find associated pairing data.", v52, v53, v54, v55, v56, v57, v58, v297);
      uint64_t v59 = sub_100050B4C(0x43u);
      if (!os_log_type_enabled(v59, OS_LOG_TYPE_ERROR)) {
        goto LABEL_22;
      }
    }
LABEL_21:
    sub_100744F6C();
LABEL_22:
    uint64_t v29 = (uint64_t)a1;
    int v30 = 8;
LABEL_23:
    sub_1002379C0(v29, v30, (char *)v7);
    return;
  }
  long long v301 = 0u;
  long long v302 = 0u;
  long long v299 = 0u;
  long long v300 = 0u;
  char v8 = (uint64_t *)sub_1001F0BBC((uint64_t)a1);
  uint64_t v7 = (uint64_t)v8;
  if (!v8)
  {
    if (!sub_100058654()) {
      goto LABEL_22;
    }
    sub_100056E24((uint64_t)"Could not find associated pairing data.", v44, v45, v46, v47, v48, v49, v50, v297);
    uint64_t v51 = sub_100050B4C(0x43u);
    if (!os_log_type_enabled(v51, OS_LOG_TYPE_ERROR)) {
      goto LABEL_22;
    }
    goto LABEL_21;
  }
  sub_1001F0FFC(v8);
  int v9 = a1[70];
  if (v9 != 1) {
    goto LABEL_8;
  }
  if (!sub_1001F11E4(v7, 36))
  {
    if (!sub_100058654()) {
      goto LABEL_22;
    }
    uint64_t v60 = sub_1001F10E8();
    sub_100056E24((uint64_t)"Initiator device was not in the proper state. State is %s.", v61, v62, v63, v64, v65, v66, v67, (uint64_t)v60);
    uint64_t v68 = sub_100050B4C(0x43u);
    if (!os_log_type_enabled(v68, OS_LOG_TYPE_ERROR)) {
      goto LABEL_22;
    }
    goto LABEL_21;
  }
  int v9 = a1[70];
LABEL_8:
  if (v9) {
    goto LABEL_11;
  }
  if (!sub_1001F11E4(v7, 37))
  {
    if (!sub_100058654()) {
      goto LABEL_22;
    }
    uint64_t v108 = sub_1001F10E8();
    sub_100056E24((uint64_t)"Initiator device was not in the proper state. State is %s.", v109, v110, v111, v112, v113, v114, v115, (uint64_t)v108);
    uint64_t v116 = sub_100050B4C(0x43u);
    if (!os_log_type_enabled(v116, OS_LOG_TYPE_ERROR)) {
      goto LABEL_22;
    }
    goto LABEL_21;
  }
  int v9 = a1[70];
LABEL_11:
  if (v9 == 1) {
    int v10 = (_OWORD *)(v7 + 457);
  }
  else {
    int v10 = (_OWORD *)(v7 + 473);
  }
  *int v10 = *a2;
  long long v303 = 0u;
  long long v304 = 0u;
  uint64_t v11 = *(void *)v7 + 63;
  if (*(unsigned char *)(*(void *)v7 + 70))
  {
    uint64_t v12 = *(void *)v7 + 48;
  }
  else
  {
    uint64_t v12 = *(void *)v7 + 63;
    uint64_t v11 = *(void *)v7 + 48;
  }
  uint64_t v69 = sub_100181008((_OWORD *)(v7 + 376), (_OWORD *)(v7 + 457), (_OWORD *)(v7 + 473), 1651797093, v12, v11, (char *)&v303, 32);
  if (v69)
  {
    if (sub_100058654())
    {
      sub_100056E24((uint64_t)"Failed to generate LTK %!", v70, v71, v72, v73, v74, v75, v76, v69);
      uint64_t v77 = sub_100050B4C(0x43u);
      if (os_log_type_enabled(v77, OS_LOG_TYPE_ERROR)) {
        sub_100745764();
      }
    }
    if (!sub_100058654()) {
      goto LABEL_22;
    }
    sub_100056E24((uint64_t)"smpCalculateLtkAndMacKey Failed %!", v78, v79, v80, v81, v82, v83, v84, v69);
    uint64_t v85 = sub_100050B4C(0x43u);
    if (!os_log_type_enabled(v85, OS_LOG_TYPE_ERROR)) {
      goto LABEL_22;
    }
LABEL_103:
    sub_100745764();
    goto LABEL_22;
  }
  long long v86 = v304;
  *(_OWORD *)(v7 + 408) = v303;
  *(_OWORD *)(v7 + 524) = v86;
  uint64_t v87 = *(unsigned __int8 *)(v7 + 81);
  if (v87 != 16) {
    bzero((void *)(v7 + 524 + v87), 16 - v87);
  }
  *(unsigned char *)(v7 + 424) = 1;
  int v88 = *(unsigned __int8 *)(v7 + 16);
  if (v88 != 6)
  {
    if (v88 == 5)
    {
      if (a1[70] != 1)
      {
        sub_1001F10F4(v7, 39);
        uint64_t v165 = sub_100238054((unsigned char *)v7);
        if (v165)
        {
          uint64_t v166 = v165;
          if (!sub_100058654()) {
            goto LABEL_22;
          }
          sub_100056E24((uint64_t)"Failed to send DHKey value with status %!", v167, v168, v169, v170, v171, v172, v173, v166);
          v174 = sub_100050B4C(0x43u);
          if (!os_log_type_enabled(v174, OS_LOG_TYPE_ERROR)) {
            goto LABEL_22;
          }
          goto LABEL_103;
        }
        return;
      }
      uint64_t v126 = sub_1002408F8((uint64_t)a1, (long long *)(v7 + 473));
      if (v126)
      {
        uint64_t v127 = v126;
        if (!sub_100058654()) {
          goto LABEL_22;
        }
        sub_100056E24((uint64_t)"Failed to send Nb to central with status %!", v128, v129, v130, v131, v132, v133, v134, v127);
        v135 = sub_100050B4C(0x43u);
        if (!os_log_type_enabled(v135, OS_LOG_TYPE_ERROR)) {
          goto LABEL_22;
        }
        goto LABEL_103;
      }
    }
    else
    {
      if (v88 == 1) {
        goto LABEL_65;
      }
      if (!a1[70])
      {
        long long v303 = 0uLL;
        unsigned int v187 = *(unsigned __int8 *)(v7 + 441) | (*(unsigned __int8 *)(v7 + 426) << 8) | (*(unsigned __int8 *)(v7 + 427) << 16) | (*(unsigned __int8 *)(v7 + 428) << 24);
        char v188 = *(unsigned char *)(v7 + 489);
        long long v189 = *(_OWORD *)(v7 + 328);
        long long v299 = *(_OWORD *)(v7 + 312);
        long long v300 = v189;
        long long v190 = *(_OWORD *)(v7 + 168);
        long long v301 = *(_OWORD *)(v7 + 152);
        long long v302 = v190;
        if ((v187 >> v188)) {
          char v191 = -127;
        }
        else {
          char v191 = 0x80;
        }
        uint64_t v192 = sub_100180EA8(&v299, &v301, (long long *)(v7 + 473), v191, &v303);
        if (v192)
        {
          uint64_t v193 = v192;
          if (!sub_100058654()) {
            goto LABEL_22;
          }
          sub_100056E24((uint64_t)"Failed to generate confirmation value %!", v194, v195, v196, v197, v198, v199, v200, v193);
          v201 = sub_100050B4C(0x43u);
          if (!os_log_type_enabled(v201, OS_LOG_TYPE_ERROR)) {
            goto LABEL_22;
          }
        }
        else
        {
          if ((void)v303 != *(void *)(v7 + 104) || *((void *)&v303 + 1) != *(void *)(v7 + 112))
          {
            if (!sub_100058654()) {
              goto LABEL_42;
            }
            sub_100056E24((uint64_t)"pairing confirmation does not match %!", v222, v223, v224, v225, v226, v227, v228, 0);
            v229 = sub_100050B4C(0x43u);
            if (!os_log_type_enabled(v229, OS_LOG_TYPE_ERROR)) {
              goto LABEL_42;
            }
LABEL_143:
            sub_100744F6C();
            goto LABEL_42;
          }
          *(void *)(v7 + 104) = 0;
          *(void *)(v7 + 112) = 0;
          unsigned int v263 = ++*(unsigned char *)(v7 + 489);
          if (v263 > 0x13)
          {
            sub_1001F10F4(v7, 39);
            uint64_t v287 = sub_100238054((unsigned char *)v7);
            if (!v287) {
              return;
            }
            uint64_t v288 = v287;
            if (!sub_100058654()) {
              goto LABEL_22;
            }
            sub_100056E24((uint64_t)"Failed to send DHKey value with status %!", v289, v290, v291, v292, v293, v294, v295, v288);
            v296 = sub_100050B4C(0x43u);
            if (!os_log_type_enabled(v296, OS_LOG_TYPE_ERROR)) {
              goto LABEL_22;
            }
          }
          else
          {
            uint64_t v264 = sub_100238568(v7);
            if (!v264)
            {
              uint64_t v285 = v7;
              char v286 = 35;
              goto LABEL_170;
            }
            uint64_t v265 = v264;
            if (!sub_100058654()) {
              goto LABEL_22;
            }
            sub_100056E24((uint64_t)"smpDoOneLeSecuredConnectionPasskeyAuthItteration returned %!", v266, v267, v268, v269, v270, v271, v272, v265);
            v273 = sub_100050B4C(0x43u);
            if (!os_log_type_enabled(v273, OS_LOG_TYPE_ERROR)) {
              goto LABEL_22;
            }
          }
        }
LABEL_178:
        sub_100745764();
        goto LABEL_22;
      }
      long long v303 = 0uLL;
      unsigned int v136 = *(_DWORD *)(v7 + 441);
      char v137 = *(unsigned char *)(v7 + 489);
      long long v138 = *(_OWORD *)(v7 + 328);
      long long v301 = *(_OWORD *)(v7 + 312);
      long long v302 = v138;
      long long v139 = *(_OWORD *)(v7 + 168);
      long long v299 = *(_OWORD *)(v7 + 152);
      long long v300 = v139;
      if ((v136 >> v137)) {
        char v140 = -127;
      }
      else {
        char v140 = 0x80;
      }
      uint64_t v141 = sub_100180EA8(&v301, &v299, (long long *)(v7 + 457), v140, &v303);
      if (v141)
      {
        uint64_t v142 = v141;
        if (!sub_100058654()) {
          goto LABEL_22;
        }
        sub_100056E24((uint64_t)"Failed to generate confirmation value %!", v143, v144, v145, v146, v147, v148, v149, v142);
        v150 = sub_100050B4C(0x43u);
        if (!os_log_type_enabled(v150, OS_LOG_TYPE_ERROR)) {
          goto LABEL_22;
        }
        goto LABEL_178;
      }
      if ((void)v303 != *(void *)(v7 + 104) || *((void *)&v303 + 1) != *(void *)(v7 + 112))
      {
        if (!sub_100058654()) {
          goto LABEL_42;
        }
        sub_100056E24((uint64_t)"pairing confirmation does not match %!", v212, v213, v214, v215, v216, v217, v218, 0);
        v219 = sub_100050B4C(0x43u);
        if (!os_log_type_enabled(v219, OS_LOG_TYPE_ERROR)) {
          goto LABEL_42;
        }
        goto LABEL_143;
      }
      *(void *)(v7 + 104) = 0;
      *(void *)(v7 + 112) = 0;
      uint64_t v242 = sub_1002408F8(*(void *)v7, (long long *)(v7 + 473));
      if (v242)
      {
        uint64_t v243 = v242;
        if (!sub_100058654()) {
          goto LABEL_22;
        }
        sub_100056E24((uint64_t)"smpSendPairingRandom failed %!", v244, v245, v246, v247, v248, v249, v250, v243);
        v251 = sub_100050B4C(0x43u);
        if (!os_log_type_enabled(v251, OS_LOG_TYPE_ERROR)) {
          goto LABEL_22;
        }
        goto LABEL_178;
      }
      unsigned int v274 = ++*(unsigned char *)(v7 + 489);
      if (v274 <= 0x13)
      {
        uint64_t v275 = sub_100238568(v7);
        if (v275)
        {
          uint64_t v276 = v275;
          if (!sub_100058654()) {
            goto LABEL_22;
          }
          sub_100056E24((uint64_t)"smpDoOneLeSecuredConnectionPasskeyAuthItteration returned %!", v277, v278, v279, v280, v281, v282, v283, v276);
          v284 = sub_100050B4C(0x43u);
          if (!os_log_type_enabled(v284, OS_LOG_TYPE_ERROR)) {
            goto LABEL_22;
          }
          goto LABEL_178;
        }
        uint64_t v285 = v7;
        char v286 = 34;
LABEL_170:
        sub_1001F10F4(v285, v286);
        return;
      }
    }
    uint64_t v285 = v7;
    char v286 = 38;
    goto LABEL_170;
  }
LABEL_65:
  if (a1[70] == 1)
  {
    uint64_t v89 = sub_1002408F8((uint64_t)a1, (long long *)(v7 + 473));
    if (v89)
    {
      uint64_t v90 = v89;
      if (!sub_100058654()) {
        goto LABEL_22;
      }
      sub_100056E24((uint64_t)"Failed to send Nb to central with status %!", v91, v92, v93, v94, v95, v96, v97, v90);
      uint64_t v98 = sub_100050B4C(0x43u);
      if (!os_log_type_enabled(v98, OS_LOG_TYPE_ERROR)) {
        goto LABEL_22;
      }
      goto LABEL_103;
    }
    sub_1001F10F4(v7, 38);
    if (*(unsigned char *)(v7 + 16) == 6)
    {
      LODWORD(v303) = 0;
      long long v175 = *(_OWORD *)(v7 + 328);
      long long v301 = *(_OWORD *)(v7 + 312);
      long long v302 = v175;
      long long v176 = *(_OWORD *)(v7 + 168);
      long long v299 = *(_OWORD *)(v7 + 152);
      long long v300 = v176;
      sub_10018149C(&v301, &v299, (long long *)(v7 + 457), (long long *)(v7 + 473), &v303);
      if (v177)
      {
        uint64_t v178 = v177;
        if (!sub_100058654()) {
          goto LABEL_22;
        }
        sub_100056E24((uint64_t)"Failed to generate vb with status %!", v179, v180, v181, v182, v183, v184, v185, v178);
        v186 = sub_100050B4C(0x43u);
        if (!os_log_type_enabled(v186, OS_LOG_TYPE_ERROR)) {
          goto LABEL_22;
        }
        goto LABEL_178;
      }
      if (!off_100A19758)
      {
        uint64_t v29 = (uint64_t)a1;
        int v30 = 12;
        goto LABEL_23;
      }
      unsigned int v252 = v303 % 0xF4240;
      LODWORD(v303) = v303 % 0xF4240;
LABEL_173:
      *(_WORD *)(v7 + 33) = v252;
      *(unsigned char *)(v7 + 35) = BYTE2(v252);
      *(unsigned char *)(v7 + 36) = 0;
      *(_DWORD *)(v7 + 52) = 4;
      sub_100240608(*(void *)v7);
      return;
    }
    return;
  }
  long long v303 = 0uLL;
  long long v151 = *(_OWORD *)(v7 + 168);
  long long v301 = *(_OWORD *)(v7 + 152);
  long long v302 = v151;
  long long v152 = *(_OWORD *)(v7 + 328);
  long long v299 = *(_OWORD *)(v7 + 312);
  long long v300 = v152;
  uint64_t v153 = sub_100180EA8(&v299, &v301, (long long *)(v7 + 473), 0, &v303);
  if (v153)
  {
    uint64_t v154 = v153;
    if (!sub_100058654()) {
      goto LABEL_22;
    }
    sub_100056E24((uint64_t)"Failed to generate confirmation value Cb with status %!", v155, v156, v157, v158, v159, v160, v161, v154);
    v162 = sub_100050B4C(0x43u);
    if (!os_log_type_enabled(v162, OS_LOG_TYPE_ERROR)) {
      goto LABEL_22;
    }
    goto LABEL_178;
  }
  if ((void)v303 != *(void *)(v7 + 104) || *((void *)&v303 + 1) != *(void *)(v7 + 112))
  {
    if (!sub_100058654()) {
      goto LABEL_42;
    }
    sub_100056E24((uint64_t)"Mismatch in Confirm calculations", v203, v204, v205, v206, v207, v208, v209, v297);
    v210 = sub_100050B4C(0x43u);
    if (!os_log_type_enabled(v210, OS_LOG_TYPE_ERROR)) {
      goto LABEL_42;
    }
    goto LABEL_143;
  }
  sub_1001F10F4(v7, 39);
  if (*(unsigned char *)(v7 + 16) == 6)
  {
    unsigned int v298 = 0;
    long long v230 = *(_OWORD *)(v7 + 168);
    long long v301 = *(_OWORD *)(v7 + 152);
    long long v302 = v230;
    long long v231 = *(_OWORD *)(v7 + 328);
    long long v299 = *(_OWORD *)(v7 + 312);
    long long v300 = v231;
    sub_10018149C(&v301, &v299, (long long *)(v7 + 457), (long long *)(v7 + 473), &v298);
    if (v232)
    {
      uint64_t v233 = v232;
      if (sub_100058654())
      {
        sub_100056E24((uint64_t)"Failed to generate vb with status %!", v234, v235, v236, v237, v238, v239, v240, v233);
        v241 = sub_100050B4C(0x43u);
        if (os_log_type_enabled(v241, OS_LOG_TYPE_ERROR)) {
          sub_100745764();
        }
      }
      goto LABEL_22;
    }
    if (!off_100A19758)
    {
      uint64_t v29 = (uint64_t)a1;
      int v30 = 5;
      goto LABEL_23;
    }
    unsigned int v252 = v298 % 0xF4240;
    v298 %= 0xF4240u;
    goto LABEL_173;
  }
  uint64_t v253 = sub_100238054((unsigned char *)v7);
  if (v253)
  {
    uint64_t v254 = v253;
    if (!sub_100058654()) {
      goto LABEL_22;
    }
    sub_100056E24((uint64_t)"Failed to send DHKey value with status %!", v255, v256, v257, v258, v259, v260, v261, v254);
    v262 = sub_100050B4C(0x43u);
    if (!os_log_type_enabled(v262, OS_LOG_TYPE_ERROR)) {
      goto LABEL_22;
    }
    goto LABEL_178;
  }
}

void sub_10023BE78(uint64_t a1, unsigned __int8 *a2, uint64_t a3)
{
  char v5 = (uint64_t *)sub_1001F0BBC(a1);
  if (v5)
  {
    uint64_t v6 = (char *)v5;
    sub_1001F0FFC(v5);
    if (a3 == 1)
    {
      unsigned int v7 = *a2;
    }
    else
    {
      if (sub_100058654())
      {
        sub_100056E24((uint64_t)"Invalid Pairing Failed size %d", v16, v17, v18, v19, v20, v21, v22, a3);
        uint64_t v23 = sub_100050B4C(0x43u);
        if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR)) {
          sub_100744F6C();
        }
      }
      unsigned int v7 = 8;
    }
    if (sub_100058654())
    {
      sub_100056E24((uint64_t)"Peer sent Pairing Failed with reason=%d", v24, v25, v26, v27, v28, v29, v30, v7);
      uint64_t v31 = sub_100050B4C(0x43u);
      if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR)) {
        sub_100744F6C();
      }
    }
    uint64_t v32 = sub_1001F10BC(v7);
    sub_1001F0828(v6, v32, 1);
  }
  else if (sub_100058654())
  {
    sub_100056E24((uint64_t)"Could not find associated pairing data.", v8, v9, v10, v11, v12, v13, v14, v33);
    uint64_t v15 = sub_100050B4C(0x43u);
    if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR)) {
      sub_100744F6C();
    }
  }
}

__n128 sub_10023BFB4(uint64_t a1, __n128 *a2, uint64_t a3)
{
  if (a3 != 16)
  {
    if (!sub_100058654()) {
      goto LABEL_14;
    }
    sub_100056E24((uint64_t)"Invalid Encrypt Information size %d", v10, v11, v12, v13, v14, v15, v16, a3);
    uint64_t v17 = sub_100050B4C(0x43u);
    if (!os_log_type_enabled(v17, OS_LOG_TYPE_ERROR)) {
      goto LABEL_14;
    }
LABEL_13:
    sub_100744F6C();
LABEL_14:
    uint64_t v6 = 0;
LABEL_15:
    sub_1002379C0(a1, 8, (char *)v6);
    return result;
  }
  char v5 = (uint64_t *)sub_1001F0BBC(a1);
  if (!v5)
  {
    if (!sub_100058654()) {
      goto LABEL_14;
    }
    sub_100056E24((uint64_t)"Could not find associated pairing data.", v18, v19, v20, v21, v22, v23, v24, v60);
    uint64_t v25 = sub_100050B4C(0x43u);
    if (!os_log_type_enabled(v25, OS_LOG_TYPE_ERROR)) {
      goto LABEL_14;
    }
    goto LABEL_13;
  }
  uint64_t v6 = (uint64_t)v5;
  sub_1001F0FFC(v5);
  if (!*(unsigned char *)(v6 + 9))
  {
    if (!sub_100058654()) {
      goto LABEL_15;
    }
    sub_100056E24((uint64_t)"The link is not encrypted, dumping LTK", v27, v28, v29, v30, v31, v32, v33, v60);
    uint8x8_t v34 = sub_100050B4C(0x43u);
    if (!os_log_type_enabled(v34, OS_LOG_TYPE_ERROR)) {
      goto LABEL_15;
    }
LABEL_19:
    sub_100744F6C();
    goto LABEL_15;
  }
  if ((*(unsigned __int8 *)(v6 + 75) | 8) != 8)
  {
    if (sub_100058654())
    {
      sub_100056E24((uint64_t)"We got LTK after some other keys.", v35, v36, v37, v38, v39, v40, v41, v60);
      uint64_t v42 = sub_100050B4C(0x43u);
      if (os_log_type_enabled(v42, OS_LOG_TYPE_ERROR)) {
        sub_100744F6C();
      }
    }
    goto LABEL_25;
  }
  if (!*(unsigned char *)(a1 + 70))
  {
    uint64_t v7 = v6;
    char v8 = 66;
    goto LABEL_24;
  }
  if (!sub_1001F11E4(v6, 67))
  {
    if (!sub_100058654()) {
      goto LABEL_15;
    }
    uint64_t v51 = sub_1001F10E8();
    sub_100056E24((uint64_t)"Central is sending keys before we are (state is %s).", v52, v53, v54, v55, v56, v57, v58, (uint64_t)v51);
    uint64_t v59 = sub_100050B4C(0x43u);
    if (!os_log_type_enabled(v59, OS_LOG_TYPE_ERROR)) {
      goto LABEL_15;
    }
    goto LABEL_19;
  }
  uint64_t v7 = v6;
  char v8 = 64;
LABEL_24:
  sub_1001F10F4(v7, v8);
LABEL_25:
  if (*(unsigned char *)(v6 + 74))
  {
    if ((sub_1002397E4(a2, *(unsigned __int8 *)(v6 + 81)) & 1) == 0) {
      *(unsigned char *)(v6 + 612) = 1;
    }
    __n128 result = *a2;
    *(__n128 *)(v6 + 508) = *a2;
  }
  else if (sub_100058654())
  {
    sub_100056E24((uint64_t)"We were not expecting LTK...", v43, v44, v45, v46, v47, v48, v49, v60);
    uint64_t v50 = sub_100050B4C(0x43u);
    if (os_log_type_enabled(v50, OS_LOG_TYPE_ERROR)) {
      sub_100744F6C();
    }
  }
  return result;
}

void sub_10023C224(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a3 != 10)
  {
    if (!sub_100058654()) {
      goto LABEL_19;
    }
    sub_100056E24((uint64_t)"Invalid Central Identification size %d", v17, v18, v19, v20, v21, v22, v23, a3);
    uint64_t v24 = sub_100050B4C(0x43u);
    if (!os_log_type_enabled(v24, OS_LOG_TYPE_ERROR)) {
      goto LABEL_19;
    }
LABEL_18:
    sub_100744F6C();
LABEL_19:
    uint64_t v6 = 0;
    goto LABEL_20;
  }
  char v5 = (uint64_t *)sub_1001F0BBC(a1);
  if (!v5)
  {
    if (!sub_100058654()) {
      goto LABEL_19;
    }
    sub_100056E24((uint64_t)"Could not find associated pairing data.", v25, v26, v27, v28, v29, v30, v31, v66);
    uint64_t v32 = sub_100050B4C(0x43u);
    if (!os_log_type_enabled(v32, OS_LOG_TYPE_ERROR)) {
      goto LABEL_19;
    }
    goto LABEL_18;
  }
  uint64_t v6 = (uint64_t)v5;
  sub_1001F0FFC(v5);
  if (!*(unsigned char *)(v6 + 9))
  {
    if (!sub_100058654()) {
      goto LABEL_20;
    }
    sub_100056E24((uint64_t)"The link is not encrypted, dumping EDIV/Rand", v33, v34, v35, v36, v37, v38, v39, v66);
    uint64_t v40 = sub_100050B4C(0x43u);
    if (!os_log_type_enabled(v40, OS_LOG_TYPE_ERROR)) {
      goto LABEL_20;
    }
LABEL_12:
    sub_100744F6C();
LABEL_20:
    sub_1002379C0(a1, 8, (char *)v6);
    return;
  }
  if ((*(unsigned __int8 *)(v6 + 75) | 8) == 8)
  {
    int v7 = *(unsigned __int8 *)(a1 + 70);
    if (v7 == 1)
    {
      if (!sub_1001F11E4(v6, 64)) {
        goto LABEL_10;
      }
      int v7 = *(unsigned __int8 *)(a1 + 70);
    }
    if (!v7 && !sub_1001F11E4(v6, 66))
    {
LABEL_10:
      if (!sub_100058654()) {
        goto LABEL_20;
      }
      sub_100056E24((uint64_t)"We got a EDIV/RAND without a LTK.", v8, v9, v10, v11, v12, v13, v14, v66);
      uint64_t v15 = sub_100050B4C(0x43u);
      if (!os_log_type_enabled(v15, OS_LOG_TYPE_ERROR)) {
        goto LABEL_20;
      }
      goto LABEL_12;
    }
  }
  else if (sub_100058654())
  {
    sub_100056E24((uint64_t)"We got EDIV/RAND after some other keys.", v41, v42, v43, v44, v45, v46, v47, v66);
    uint64_t v48 = sub_100050B4C(0x43u);
    if (os_log_type_enabled(v48, OS_LOG_TYPE_ERROR)) {
      sub_100744F6C();
    }
  }
  if ((*(unsigned char *)(v6 + 74) & 1) == 0)
  {
    if (!sub_100058654()) {
      goto LABEL_38;
    }
    sub_100056E24((uint64_t)"We were not expecting LTK...", v49, v50, v51, v52, v53, v54, v55, v66);
    uint64_t v56 = sub_100050B4C(0x43u);
    if (!os_log_type_enabled(v56, OS_LOG_TYPE_ERROR)) {
      goto LABEL_38;
    }
    goto LABEL_30;
  }
  *(unsigned char *)(v6 + 75) |= 1u;
  *(_WORD *)(v6 + 542) = *(_WORD *)a2;
  *(void *)(v6 + 546) = *(void *)(a2 + 2);
  BOOL v67 = *(unsigned char *)(v6 + 16) != 1;
  if (!*(unsigned char *)(v6 + 612))
  {
    if (unk_100A19740 && (*(unsigned char *)(v6 + 80) & 1) != 0)
    {
      uint64_t v65 = a1 + 48;
      unk_100A19740(v65, 0, v6 + 508, 16, 0);
      unk_100A19740(v65, 1, v6 + 81, 1, 0);
      unk_100A19740(v65, 2, &v67, 1, 0);
      unk_100A19740(v65, 3, v6 + 542, 2, 0);
      unk_100A19740(v65, 4, v6 + 546, 8, 0);
    }
    goto LABEL_38;
  }
  if (sub_100058654())
  {
    sub_100056E24((uint64_t)"Compromised device, dropping keys", v57, v58, v59, v60, v61, v62, v63, v66);
    uint64_t v64 = sub_100050B4C(0x43u);
    if (os_log_type_enabled(v64, OS_LOG_TYPE_ERROR)) {
LABEL_30:
    }
      sub_100744F6C();
  }
LABEL_38:
  sub_100240BFC((char *)v6);
}

__n128 sub_10023C598(uint64_t a1, __n128 *a2, uint64_t a3)
{
  if (a3 != 16)
  {
    if (!sub_100058654()) {
      goto LABEL_14;
    }
    sub_100056E24((uint64_t)"Invalid Identity Information size %d", v9, v10, v11, v12, v13, v14, v15, a3);
    uint64_t v16 = sub_100050B4C(0x43u);
    if (!os_log_type_enabled(v16, OS_LOG_TYPE_ERROR)) {
      goto LABEL_14;
    }
LABEL_13:
    sub_100744F6C();
LABEL_14:
    uint64_t v6 = 0;
LABEL_15:
    sub_1002379C0(a1, 8, (char *)v6);
    return result;
  }
  char v5 = (uint64_t *)sub_1001F0BBC(a1);
  if (!v5)
  {
    if (!sub_100058654()) {
      goto LABEL_14;
    }
    sub_100056E24((uint64_t)"Could not find associated pairing data.", v17, v18, v19, v20, v21, v22, v23, v50);
    uint64_t v24 = sub_100050B4C(0x43u);
    if (!os_log_type_enabled(v24, OS_LOG_TYPE_ERROR)) {
      goto LABEL_14;
    }
    goto LABEL_13;
  }
  uint64_t v6 = (uint64_t)v5;
  sub_1001F0FFC(v5);
  if (!*(unsigned char *)(v6 + 9))
  {
    if (!sub_100058654()) {
      goto LABEL_15;
    }
    sub_100056E24((uint64_t)"The link is not encrypted, dumping IRK", v26, v27, v28, v29, v30, v31, v32, v50);
    uint64_t v33 = sub_100050B4C(0x43u);
    if (!os_log_type_enabled(v33, OS_LOG_TYPE_ERROR)) {
      goto LABEL_15;
    }
LABEL_19:
    sub_100744F6C();
    goto LABEL_15;
  }
  if (*(unsigned char *)(v6 + 75)) {
    goto LABEL_22;
  }
  if (!*(unsigned char *)(a1 + 70))
  {
    char v7 = 66;
    goto LABEL_21;
  }
  if (!sub_1001F11E4(v6, 67))
  {
    if (!sub_100058654()) {
      goto LABEL_15;
    }
    sub_100056E24((uint64_t)"Central is sending keys before we are ...", v42, v43, v44, v45, v46, v47, v48, v50);
    uint64_t v49 = sub_100050B4C(0x43u);
    if (!os_log_type_enabled(v49, OS_LOG_TYPE_ERROR)) {
      goto LABEL_15;
    }
    goto LABEL_19;
  }
  char v7 = 64;
LABEL_21:
  sub_1001F10F4(v6, v7);
LABEL_22:
  if ((*(unsigned char *)(v6 + 74) & 2) != 0)
  {
    __n128 result = *a2;
    *(__n128 *)(v6 + 562) = *a2;
  }
  else if (sub_100058654())
  {
    sub_100056E24((uint64_t)"We were not expecting IRK...", v34, v35, v36, v37, v38, v39, v40, v50);
    uint64_t v41 = sub_100050B4C(0x43u);
    if (os_log_type_enabled(v41, OS_LOG_TYPE_ERROR)) {
      sub_100744F6C();
    }
  }
  return result;
}

void sub_10023C798(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a3 != 7)
  {
    if (!sub_100058654()) {
      goto LABEL_20;
    }
    sub_100056E24((uint64_t)"Invalid Identity Address Information size %d", v17, v18, v19, v20, v21, v22, v23, a3);
    uint64_t v24 = sub_100050B4C(0x43u);
    if (!os_log_type_enabled(v24, OS_LOG_TYPE_ERROR)) {
      goto LABEL_20;
    }
LABEL_19:
    sub_100744F6C();
LABEL_20:
    uint64_t v6 = 0;
    goto LABEL_21;
  }
  char v5 = (uint64_t *)sub_1001F0BBC(a1);
  if (!v5)
  {
    if (!sub_100058654()) {
      goto LABEL_20;
    }
    sub_100056E24((uint64_t)"Could not find associated pairing data.", v25, v26, v27, v28, v29, v30, v31, v86);
    uint64_t v32 = sub_100050B4C(0x43u);
    if (!os_log_type_enabled(v32, OS_LOG_TYPE_ERROR)) {
      goto LABEL_20;
    }
    goto LABEL_19;
  }
  uint64_t v6 = (uint64_t)v5;
  sub_1001F0FFC(v5);
  if (!*(unsigned char *)(v6 + 9))
  {
    if (!sub_100058654()) {
      goto LABEL_21;
    }
    sub_100056E24((uint64_t)"The link is not encrypted, dumping Remote address", v34, v35, v36, v37, v38, v39, v40, v86);
    uint64_t v41 = sub_100050B4C(0x43u);
    if (!os_log_type_enabled(v41, OS_LOG_TYPE_ERROR)) {
      goto LABEL_21;
    }
LABEL_25:
    sub_100744F6C();
    goto LABEL_21;
  }
  if (*(unsigned char *)(v6 + 75)) {
    goto LABEL_10;
  }
  int v7 = *(unsigned __int8 *)(a1 + 70);
  if (v7 == 1)
  {
    if (!sub_1001F11E4(v6, 64)) {
      goto LABEL_33;
    }
    int v7 = *(unsigned __int8 *)(a1 + 70);
  }
  if (!v7 && !sub_1001F11E4(v6, 66))
  {
LABEL_33:
    if (!sub_100058654()) {
      goto LABEL_21;
    }
    sub_100056E24((uint64_t)"We got an address without IRK.", v50, v51, v52, v53, v54, v55, v56, v86);
    uint64_t v57 = sub_100050B4C(0x43u);
    if (!os_log_type_enabled(v57, OS_LOG_TYPE_ERROR)) {
      goto LABEL_21;
    }
    goto LABEL_25;
  }
LABEL_10:
  if ((*(unsigned char *)(v6 + 74) & 2) == 0)
  {
    if (!sub_100058654()) {
      goto LABEL_32;
    }
    sub_100056E24((uint64_t)"We were not expecting address info...", v8, v9, v10, v11, v12, v13, v14, v86);
    uint64_t v15 = sub_100050B4C(0x43u);
    if (!os_log_type_enabled(v15, OS_LOG_TYPE_ERROR)) {
      goto LABEL_32;
    }
    goto LABEL_13;
  }
  *(unsigned char *)(v6 + 75) |= 2u;
  if (!*(unsigned char *)(v6 + 612))
  {
    if (!unk_100A19740 || (*(unsigned char *)(v6 + 80) & 1) == 0) {
      goto LABEL_32;
    }
    v87[0] = *(unsigned char *)a2;
    *(_DWORD *)&v87[1] = *(_DWORD *)(a2 + 1);
    *(_WORD *)&v87[5] = *(_WORD *)(a2 + 5);
    sub_1001F03A0(&v87[1], 6);
    if (v87[0] && (v87[0] != 1 || v87[1] <= 0xBFu))
    {
      if (!sub_100058654()) {
        goto LABEL_21;
      }
      sub_100056E24((uint64_t)"We got a remote address (%:) that is neither public nor static!", v69, v70, v71, v72, v73, v74, v75, (uint64_t)&v87[1]);
      uint64_t v76 = sub_100050B4C(0x43u);
      if (!os_log_type_enabled(v76, OS_LOG_TYPE_ERROR)) {
        goto LABEL_21;
      }
      goto LABEL_54;
    }
    if (*(_DWORD *)v87) {
      BOOL v58 = 0;
    }
    else {
      BOOL v58 = *(unsigned __int16 *)&v87[4] == 0;
    }
    if (!v58)
    {
      *(unsigned char *)(a1 + 55) = 1;
      *(_DWORD *)(a1 + 56) = *(_DWORD *)v87;
      *(_DWORD *)(a1 + 59) = *(_DWORD *)&v87[3];
      uint64_t v59 = (void *)sub_100234CA8(v87);
      if (!v59 || (*v59 == *(void *)(v6 + 562) ? (BOOL v60 = v59[1] == *(void *)(v6 + 570)) : (BOOL v60 = 0), v60))
      {
        uint64_t v77 = a1 + 48;
        unk_100A19740(v77, 10, v6 + 562, 16, 0);
        unk_100A19740(v77, 11, v87, 7, 0);
        goto LABEL_32;
      }
      if (sub_100058654())
      {
        sub_100056E24((uint64_t)"device %: is already paired, with a different irk (old:%@ new %@). Unpair first and then restart pairing.", v61, v62, v63, v64, v65, v66, v67, a1 + 57);
        uint64_t v68 = sub_100050B4C(0x43u);
        if (os_log_type_enabled(v68, OS_LOG_TYPE_ERROR)) {
          sub_100744F6C();
        }
      }
      int v33 = 240;
LABEL_22:
      sub_1002379C0(a1, v33, (char *)v6);
      return;
    }
    if (sub_100058654())
    {
      sub_100056E24((uint64_t)"Identity address cannot be all 0.", v78, v79, v80, v81, v82, v83, v84, v86);
      uint64_t v85 = sub_100050B4C(0x43u);
      if (os_log_type_enabled(v85, OS_LOG_TYPE_ERROR)) {
LABEL_54:
      }
        sub_100744F6C();
    }
LABEL_21:
    int v33 = 8;
    goto LABEL_22;
  }
  if (!sub_100058654()) {
    goto LABEL_32;
  }
  sub_100056E24((uint64_t)"Compromised device, dropping keys", v42, v43, v44, v45, v46, v47, v48, v86);
  uint64_t v49 = sub_100050B4C(0x43u);
  if (!os_log_type_enabled(v49, OS_LOG_TYPE_ERROR)) {
    goto LABEL_32;
  }
LABEL_13:
  sub_100744F6C();
LABEL_32:
  sub_100240BFC((char *)v6);
}

void sub_10023CBDC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a3 != 16)
  {
    if (!sub_100058654()) {
      goto LABEL_14;
    }
    sub_100056E24((uint64_t)"Invalid Signing Information size %d", v8, v9, v10, v11, v12, v13, v14, a3);
    uint64_t v15 = sub_100050B4C(0x43u);
    if (!os_log_type_enabled(v15, OS_LOG_TYPE_ERROR)) {
      goto LABEL_14;
    }
LABEL_13:
    sub_100744F6C();
LABEL_14:
    char v5 = 0;
    goto LABEL_15;
  }
  char v4 = (uint64_t *)sub_1001F0BBC(a1);
  if (!v4)
  {
    if (!sub_100058654()) {
      goto LABEL_14;
    }
    sub_100056E24((uint64_t)"Could not find associated pairing data.", v16, v17, v18, v19, v20, v21, v22, v48);
    uint64_t v23 = sub_100050B4C(0x43u);
    if (!os_log_type_enabled(v23, OS_LOG_TYPE_ERROR)) {
      goto LABEL_14;
    }
    goto LABEL_13;
  }
  char v5 = (char *)v4;
  sub_1001F0FFC(v4);
  if (!v5[9])
  {
    if (!sub_100058654()) {
      goto LABEL_15;
    }
    sub_100056E24((uint64_t)"The link is not encrypted.", v24, v25, v26, v27, v28, v29, v30, v48);
    uint64_t v31 = sub_100050B4C(0x43u);
    if (!os_log_type_enabled(v31, OS_LOG_TYPE_ERROR)) {
      goto LABEL_15;
    }
    goto LABEL_18;
  }
  if (!v5[75])
  {
    if (!*(unsigned char *)(a1 + 70))
    {
      char v6 = 66;
      goto LABEL_20;
    }
    if (sub_1001F11E4((uint64_t)v5, 67))
    {
      char v6 = 64;
LABEL_20:
      sub_1001F10F4((uint64_t)v5, v6);
      goto LABEL_21;
    }
    if (sub_100058654())
    {
      sub_100056E24((uint64_t)"Central is sending keys before we are ...", v40, v41, v42, v43, v44, v45, v46, v48);
      uint64_t v47 = sub_100050B4C(0x43u);
      if (os_log_type_enabled(v47, OS_LOG_TYPE_ERROR)) {
LABEL_18:
      }
        sub_100744F6C();
    }
LABEL_15:
    sub_1002379C0(a1, 8, v5);
    return;
  }
LABEL_21:
  if ((v5[74] & 4) != 0)
  {
    v5[75] |= 4u;
  }
  else if (sub_100058654())
  {
    sub_100056E24((uint64_t)"We were not expecting CSRK...", v32, v33, v34, v35, v36, v37, v38, v48);
    uint64_t v39 = sub_100050B4C(0x43u);
    if (os_log_type_enabled(v39, OS_LOG_TYPE_ERROR)) {
      sub_100744F6C();
    }
  }
  sub_100240BFC(v5);
}

void sub_10023CDE0(uint64_t a1, char *a2, uint64_t a3)
{
  if (xmmword_100A10276 == 0 || xmmword_100A10296 == 0)
  {
    if (!sub_100058654()) {
      goto LABEL_10;
    }
    sub_100056E24((uint64_t)"Root keys are not set, can't pair.", v14, v15, v16, v17, v18, v19, v20, v59);
    uint64_t v21 = sub_100050B4C(0x43u);
    if (!os_log_type_enabled(v21, OS_LOG_TYPE_ERROR)) {
      goto LABEL_10;
    }
    goto LABEL_9;
  }
  if (!sub_1001F0BBC(a1))
  {
    if (a3 == 1)
    {
      if (*(unsigned char *)(a1 + 166) == 2)
      {
        if (sub_100058654())
        {
          sub_100056E24((uint64_t)"There is already an encryption in progress on this link, ignoring this request", v22, v23, v24, v25, v26, v27, v28, v59);
          uint64_t v29 = sub_100050B4C(0x43u);
          if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR)) {
            goto LABEL_6;
          }
        }
      }
      else
      {
        char v38 = *a2;
        uint64_t v39 = sub_1001F0EE8(a1);
        uint64_t v40 = v39;
        if (v39)
        {
          v39[80] = v38;
          sub_1001F10F4((uint64_t)v39, 16);
        }
        if (*(_DWORD *)(a1 + 132) == 7)
        {
          *((void *)&buf + 1) = v40;
          *(void *)&long long buf = 8;
          uint64_t v41 = sub_1000268E4((uint64_t)sub_10023EDFC, (const void **)&buf, 0, 0);
          if (v41)
          {
            uint64_t v42 = v41;
            if (sub_100058654())
            {
              sub_100056E24((uint64_t)"Could not dispatch SecurityRequest CB with status %!.", v43, v44, v45, v46, v47, v48, v49, v42);
              uint64_t v50 = sub_100050B4C(0x43u);
              if (os_log_type_enabled(v50, OS_LOG_TYPE_ERROR)) {
                sub_100745764();
              }
            }
          }
        }
        else if (sub_100058654())
        {
          sub_100056E24((uint64_t)"Got Security request before link is ready for handle %p, lets handle this when the link is actually ready. Link state is %d", v51, v52, v53, v54, v55, v56, v57, a1);
          BOOL v58 = sub_100050B4C(0x43u);
          if (os_log_type_enabled(v58, OS_LOG_TYPE_DEFAULT))
          {
            LODWORD(buf) = 136446210;
            *(void *)((char *)&buf + 4) = sub_100050714();
            _os_log_impl((void *)&_mh_execute_header, v58, OS_LOG_TYPE_DEFAULT, " %{public}s", (uint8_t *)&buf, 0xCu);
          }
        }
      }
      return;
    }
    if (!sub_100058654()
      || (sub_100056E24((uint64_t)"Invalid Security Request size %d", v30, v31, v32, v33, v34, v35, v36, a3),
          uint64_t v37 = sub_100050B4C(0x43u),
          !os_log_type_enabled(v37, OS_LOG_TYPE_ERROR)))
    {
LABEL_10:
      LOWORD(buf) = 2053;
      sub_1001F0C08(a1, (char *)&buf, 2uLL, 0);
      return;
    }
LABEL_9:
    sub_100744F6C();
    goto LABEL_10;
  }
  if (sub_100058654())
  {
    sub_100056E24((uint64_t)"There is already a pairing request for this connection. Ignoring request.", v6, v7, v8, v9, v10, v11, v12, v59);
    uint64_t v13 = sub_100050B4C(0x43u);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR)) {
LABEL_6:
    }
      sub_100744F6C();
  }
}

void sub_10023D0CC(uint64_t a1, long long *a2, uint64_t a3)
{
  memset(__s2, 0, sizeof(__s2));
  uint64_t v6 = sub_1001F0BBC(a1);
  uint64_t v7 = v6;
  if (!v6)
  {
    if (!sub_100058654()) {
      goto LABEL_63;
    }
    sub_100056E24((uint64_t)"Could not find associated pairing data.", v22, v23, v24, v25, v26, v27, v28, v127);
    uint64_t v29 = sub_100050B4C(0x43u);
    if (!os_log_type_enabled(v29, OS_LOG_TYPE_ERROR)) {
      goto LABEL_63;
    }
    goto LABEL_39;
  }
  if (a3 != 64)
  {
    if (!sub_100058654()) {
      goto LABEL_63;
    }
    sub_100056E24((uint64_t)"Invalid pairing public key size %d", v30, v31, v32, v33, v34, v35, v36, a3);
    uint64_t v37 = sub_100050B4C(0x43u);
    if (!os_log_type_enabled(v37, OS_LOG_TYPE_ERROR)) {
      goto LABEL_63;
    }
    goto LABEL_39;
  }
  if ((*(unsigned char *)(v6 + 72) & *(unsigned char *)(v6 + 80) & 8) == 0)
  {
    if (!sub_100058654()) {
      goto LABEL_63;
    }
    sub_100056E24((uint64_t)"Both devices should be using secured connection to get this PDU.", v38, v39, v40, v41, v42, v43, v44, v127);
    uint64_t v45 = sub_100050B4C(0x43u);
    if (!os_log_type_enabled(v45, OS_LOG_TYPE_ERROR)) {
      goto LABEL_63;
    }
    goto LABEL_39;
  }
  int v8 = *(unsigned __int8 *)(a1 + 70);
  if (!*(unsigned char *)(a1 + 70))
  {
    if (sub_1001F11E4(v6, 33))
    {
      int v8 = *(unsigned __int8 *)(a1 + 70);
      goto LABEL_7;
    }
    if (!sub_100058654()) {
      goto LABEL_63;
    }
    uint64_t v65 = sub_1001F10E8();
    sub_100056E24((uint64_t)"Central connection should be in SMP_STATE_PAIRING_SPUBLICK to send this command, current state is %s.", v66, v67, v68, v69, v70, v71, v72, (uint64_t)v65);
    uint64_t v73 = sub_100050B4C(0x43u);
    if (!os_log_type_enabled(v73, OS_LOG_TYPE_ERROR)) {
      goto LABEL_63;
    }
LABEL_39:
    sub_100744F6C();
LABEL_63:
    sub_1002379C0(a1, 8, (char *)v7);
    return;
  }
LABEL_7:
  if (v8 == 1 && !sub_1001F11E4(v7, 32))
  {
    if (!sub_100058654()) {
      goto LABEL_63;
    }
    uint64_t v56 = sub_1001F10E8();
    sub_100056E24((uint64_t)"Peripheral connection should be in SMP_STATE_PAIRING_MPUBLICK to send this command, current state is %s.", v57, v58, v59, v60, v61, v62, v63, (uint64_t)v56);
    uint64_t v64 = sub_100050B4C(0x43u);
    if (!os_log_type_enabled(v64, OS_LOG_TYPE_ERROR)) {
      goto LABEL_63;
    }
    goto LABEL_39;
  }
  long long v9 = *a2;
  long long v10 = a2[1];
  long long v11 = a2[3];
  *(_OWORD *)(v7 + 344) = a2[2];
  *(_OWORD *)(v7 + 360) = v11;
  *(_OWORD *)(v7 + 312) = v9;
  *(_OWORD *)(v7 + 328) = v10;
  if (*(unsigned char *)(*(void *)v7 + 70) == 1 && *(unsigned char *)(v7 + 16) != 5)
  {
    uint64_t v74 = sub_1001818CC((_OWORD *)(v7 + 152), (_OWORD *)(v7 + 216));
    if (v74)
    {
      uint64_t v75 = v74;
      if (sub_100058654())
      {
        sub_100056E24((uint64_t)"LE_ReadLocalPublicKey failed %!", v76, v77, v78, v79, v80, v81, v82, v75);
        uint64_t v83 = sub_100050B4C(0x43u);
        if (os_log_type_enabled(v83, OS_LOG_TYPE_ERROR)) {
          sub_100745764();
        }
      }
      goto LABEL_63;
    }
    int v94 = *(unsigned __int8 *)(v7 + 16);
    if (v94 != 1 && v94 != 6)
    {
      __buf[0] = 12;
      long long v95 = *(_OWORD *)(v7 + 168);
      *(_OWORD *)&__buf[1] = *(_OWORD *)(v7 + 152);
      long long v130 = v95;
      long long v96 = *(_OWORD *)(v7 + 200);
      long long v131 = *(_OWORD *)(v7 + 184);
      long long v132 = v96;
      uint64_t v97 = sub_1001F0C08(*(void *)v7, __buf, 0x41uLL, 1);
      if (v97)
      {
        uint64_t v98 = v97;
        if (sub_100058654())
        {
          sub_100056E24((uint64_t)"smpSendPairingPublicKey failed %!", v99, v100, v101, v102, v103, v104, v105, v98);
          uint64_t v106 = sub_100050B4C(0x43u);
          if (os_log_type_enabled(v106, OS_LOG_TYPE_ERROR)) {
            sub_100745764();
          }
        }
        goto LABEL_63;
      }
    }
  }
  if (!memcmp((const void *)(v7 + 312), __s2, 0x40uLL) || !memcmp((const void *)(v7 + 216), __s2, 0x60uLL))
  {
    if (sub_100058654())
    {
      sub_100056E24((uint64_t)"Invalid all zeros public key or all zeros private key", v46, v47, v48, v49, v50, v51, v52, v127);
      uint64_t v53 = sub_100050B4C(0x43u);
      if (os_log_type_enabled(v53, OS_LOG_TYPE_ERROR)) {
        sub_100745764();
      }
    }
  }
  else
  {
    uint64_t v12 = sub_100181A54((const void *)(v7 + 312), 0x40u, (const void *)(v7 + 216), 0x60u, (void *)(v7 + 376));
    if (v12)
    {
      uint64_t v13 = v12;
      if (sub_100058654())
      {
        sub_100056E24((uint64_t)"DHKey generation failed %!", v14, v15, v16, v17, v18, v19, v20, v13);
        uint64_t v21 = sub_100050B4C(0x43u);
        if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR)) {
LABEL_62:
        }
          sub_100745764();
      }
      goto LABEL_63;
    }
  }
  int v54 = *(unsigned __int8 *)(v7 + 16);
  switch(*(unsigned char *)(v7 + 16))
  {
    case 1:
    case 6:
      if (v54 != 6 && !*(unsigned char *)(v7 + 490)) {
        return;
      }
      uint64_t v84 = sub_100238328(v7);
      if (!v84) {
        return;
      }
      uint64_t v85 = v84;
      if (sub_100058654())
      {
        sub_100056E24((uint64_t)"recvdSMPDeferredJustWorksNumComparPublicKey failed %!", v86, v87, v88, v89, v90, v91, v92, v85);
        uint64_t v93 = sub_100050B4C(0x43u);
        if (os_log_type_enabled(v93, OS_LOG_TYPE_ERROR)) {
          goto LABEL_62;
        }
      }
      goto LABEL_63;
    case 2:
    case 3:
    case 4:
      *(_DWORD *)__long long buf = 0;
      uint64_t v55 = *(void *)v7;
      if (*(unsigned char *)(*(void *)v7 + 70))
      {
        if (*(unsigned char *)(*(void *)v7 + 70) != 1 || v54 != 3) {
          goto LABEL_33;
        }
      }
      else if (v54 != 2)
      {
LABEL_33:
        *(_DWORD *)(v7 + 52) = 2;
        goto LABEL_67;
      }
      arc4random_buf(__buf, 4uLL);
      unsigned int v125 = *(_DWORD *)__buf % 0xF423Fu + 1;
      *(_DWORD *)__long long buf = v125;
      *(_WORD *)(v7 + 33) = v125;
      *(unsigned char *)(v7 + 35) = BYTE2(v125);
      *(unsigned char *)(v7 + 36) = 0;
      *(_DWORD *)(v7 + 52) = 1;
      uint64_t v55 = *(void *)v7;
LABEL_67:
      if (*(unsigned char *)(v55 + 70)) {
        char v126 = 34;
      }
      else {
        char v126 = 35;
      }
      sub_1001F10F4(v7, v126);
      sub_100240608(*(void *)v7);
      return;
    case 5:
      uint64_t v115 = sub_10024003C(v7);
      if (!v115) {
        return;
      }
      uint64_t v116 = v115;
      if (sub_100058654())
      {
        sub_100056E24((uint64_t)"recvdSMPDeferredOOBPublicKey failed %!", v117, v118, v119, v120, v121, v122, v123, v116);
        uint64_t v124 = sub_100050B4C(0x43u);
        if (os_log_type_enabled(v124, OS_LOG_TYPE_ERROR)) {
          goto LABEL_62;
        }
      }
      goto LABEL_63;
    default:
      if (sub_100058654())
      {
        sub_100056E24((uint64_t)"Don't know what to do now", v107, v108, v109, v110, v111, v112, v113, v127);
        uint64_t v114 = sub_100050B4C(0x43u);
        if (os_log_type_enabled(v114, OS_LOG_TYPE_ERROR)) {
          sub_100744F6C();
        }
      }
      goto LABEL_63;
  }
}

uint64_t sub_10023D6FC(unsigned char *a1, _OWORD *a2, uint64_t a3)
{
  uint64_t result = sub_1001F0BBC((uint64_t)a1);
  uint64_t v7 = result;
  if (!result)
  {
    if (!sub_100058654()) {
      return sub_1002379C0((uint64_t)a1, 8, (char *)v7);
    }
    sub_100056E24((uint64_t)"Could not find associated pairing data.", v18, v19, v20, v21, v22, v23, v24, v52);
    uint64_t v25 = sub_100050B4C(0x43u);
    if (!os_log_type_enabled(v25, OS_LOG_TYPE_ERROR)) {
      return sub_1002379C0((uint64_t)a1, 8, (char *)v7);
    }
    goto LABEL_20;
  }
  if (a3 != 16)
  {
    if (!sub_100058654()) {
      return sub_1002379C0((uint64_t)a1, 8, (char *)v7);
    }
    sub_100056E24((uint64_t)"Invalid pairing DHKey check size %d", v26, v27, v28, v29, v30, v31, v32, a3);
    uint64_t v33 = sub_100050B4C(0x43u);
    if (!os_log_type_enabled(v33, OS_LOG_TYPE_ERROR)) {
      return sub_1002379C0((uint64_t)a1, 8, (char *)v7);
    }
    goto LABEL_20;
  }
  int v8 = a1[70];
  if (!a1[70])
  {
    uint64_t result = sub_1001F11E4(result, 39);
    if (result)
    {
      int v8 = a1[70];
      goto LABEL_6;
    }
    if (!sub_100058654()) {
      return sub_1002379C0((uint64_t)a1, 8, (char *)v7);
    }
    uint64_t v43 = sub_1001F10E8();
    sub_100056E24((uint64_t)"Central connection should be in SMP_STATE_PAIRING_SDHKEY to send this command, current state is %s.", v44, v45, v46, v47, v48, v49, v50, (uint64_t)v43);
    uint64_t v51 = sub_100050B4C(0x43u);
    if (!os_log_type_enabled(v51, OS_LOG_TYPE_ERROR)) {
      return sub_1002379C0((uint64_t)a1, 8, (char *)v7);
    }
LABEL_20:
    sub_100744F6C();
    return sub_1002379C0((uint64_t)a1, 8, (char *)v7);
  }
LABEL_6:
  if (v8 == 1)
  {
    uint64_t result = sub_1001F11E4(v7, 38);
    if ((result & 1) == 0)
    {
      if (!sub_100058654()) {
        return sub_1002379C0((uint64_t)a1, 8, (char *)v7);
      }
      uint64_t v34 = sub_1001F10E8();
      sub_100056E24((uint64_t)"Peripheral connection should be in SMP_STATE_PAIRING_MDHKEY to send this command, current state is %s.", v35, v36, v37, v38, v39, v40, v41, (uint64_t)v34);
      uint64_t v42 = sub_100050B4C(0x43u);
      if (!os_log_type_enabled(v42, OS_LOG_TYPE_ERROR)) {
        return sub_1002379C0((uint64_t)a1, 8, (char *)v7);
      }
      goto LABEL_20;
    }
  }
  *(_OWORD *)(v7 + 492) = *a2;
  *(unsigned char *)(v7 + 491) = 1;
  if (*(unsigned char *)(*(void *)v7 + 70) != 1 || *(unsigned char *)(v7 + 16) != 6 || *(unsigned char *)(v7 + 490))
  {
    uint64_t result = sub_100238130(a1);
    if (result)
    {
      uint64_t v9 = result;
      if (sub_100058654())
      {
        sub_100056E24((uint64_t)"recvdSMPDeferredDHKeyCheck Failed %! ", v10, v11, v12, v13, v14, v15, v16, v9);
        uint64_t v17 = sub_100050B4C(0x43u);
        if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR)) {
          sub_100745764();
        }
      }
      return sub_1002379C0((uint64_t)a1, 8, (char *)v7);
    }
  }
  return result;
}

uint64_t sub_10023D934(uint64_t a1, int a2, char a3)
{
  if (!sub_100197770(a1)) {
    sub_10025B8C0();
  }
  uint64_t v6 = sub_1001F0BBC(a1);
  uint64_t result = sub_1001F0BBC(a1);
  if (!a2)
  {
    if (result) {
      *(unsigned char *)(v6 + 9) = a3;
    }
  }
  return result;
}

void sub_10023D990(uint64_t a1, int a2, int a3)
{
  char v6 = byte_1009FAEF9;
  if (byte_1009FAEF9 == 255) {
    char v6 = 11;
  }
  if (byte_1009FAEFA == 255) {
    char v7 = 11;
  }
  else {
    char v7 = byte_1009FAEFA;
  }
  char v8 = v6 & 0xF7;
  char v9 = v7 & 0xF7;
  if (byte_100A10260) {
    char v10 = v6 & 0xF7;
  }
  else {
    char v10 = v6;
  }
  if (byte_100A10260) {
    char v11 = v7 & 0xF7;
  }
  else {
    char v11 = v7;
  }
  if (!sub_100197770(a1)) {
    sub_10025B8C0();
  }
  uint64_t v12 = (char *)sub_1001F0BBC(a1);
  if (v12)
  {
    uint64_t v13 = v12;
    if (a2)
    {
      if (sub_1001F11E4((uint64_t)v12, 16) && !*(unsigned char *)(a1 + 70))
      {
        int v23 = v13[80] & 4;
        int v24 = byte_100A10264;
        int v25 = v23 | v24 | sub_1002290A0();
        if ((v13[80] & 8) != 0)
        {
          if ((v10 & 8) != 0 && (v13[80] & 0x20) != 0 && (byte_100A10262 & 1) == 0)
          {
            if (sub_100058654())
            {
              sub_100056E24((uint64_t)"Sending CT2=1", v29, v30, v31, v32, v33, v34, v35, v49);
              uint64_t v36 = sub_100050B4C(0x43u);
              if (os_log_type_enabled(v36, OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)long long buf = 136446210;
                uint64_t v51 = sub_100050714();
                _os_log_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
              }
            }
          }
          unsigned __int8 v26 = v25 | 0x28;
        }
        else
        {
          unsigned __int8 v26 = v25 & 0xDF;
          char v10 = v8;
          char v11 = v9;
        }
        if (*(unsigned char *)(a1 + 55)) {
          uint64_t v37 = (_DWORD *)(a1 + 56);
        }
        else {
          uint64_t v37 = 0;
        }
        char v38 = sub_100233B84((_DWORD *)(a1 + 48), v37);
        if (sub_100058654())
        {
          sub_100056E24((uint64_t)"authReq=%x expectedKeys=%x requestedKeys=%x", v39, v40, v41, v42, v43, v44, v45, v26);
          uint64_t v46 = sub_100050B4C(0x43u);
          if (os_log_type_enabled(v46, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v47 = sub_100050714();
            *(_DWORD *)long long buf = 136446210;
            uint64_t v51 = v47;
            _os_log_impl((void *)&_mh_execute_header, v46, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
          }
        }
        sub_100239E6C(a1, byte_1009FAEFB, v38, v26, v10, v11);
      }
      else
      {
        if (sub_100058654())
        {
          sub_100056E24((uint64_t)"Could not encrypt the link.", v14, v15, v16, v17, v18, v19, v20, v49);
          uint64_t v21 = sub_100050B4C(0x43u);
          if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR)) {
            sub_100744F6C();
          }
        }
        sub_1001F0828(v13, 4802, 1);
      }
    }
    else
    {
      *(unsigned char *)(*(void *)v12 + 167) = v12[81];
      if (sub_1001F11E4((uint64_t)v12, 16) && !*(unsigned char *)(a1 + 70))
      {
        uint64_t v27 = v13;
        int v28 = 0;
      }
      else
      {
        if (!a3) {
          return;
        }
        sub_1001F10F4((uint64_t)v13, 42);
        if (*(unsigned char *)(a1 + 70))
        {
          if (*(unsigned char *)(a1 + 70) != 1) {
            return;
          }
          sub_10023DDC0((uint64_t)v13);
          sub_10023DF48((uint64_t)v13);
          char v22 = (v13[72] & v13[80] & 8) != 0 ? -10 : -9;
          if ((v22 & v13[74] & 0xF7) != (v22 & v13[75] & 0xF7)
            && (v22 & v13[74]) != 0)
          {
            return;
          }
        }
        else
        {
          if ((v13[72] & v13[80] & 8) != 0) {
            char v48 = -10;
          }
          else {
            char v48 = -9;
          }
          if ((v48 & v13[74] & 0xF7) != (v48 & v13[75] & 0xF7)
            && (v48 & v13[74]) != 0)
          {
            return;
          }
          sub_10023DDC0((uint64_t)v13);
          sub_10023DF48((uint64_t)v13);
        }
        uint64_t v27 = v13;
        int v28 = 1;
      }
      sub_1001F0828(v27, 0, v28);
    }
  }
}

void sub_10023DDC0(uint64_t a1)
{
  if ((*(unsigned char *)(a1 + 72) & *(unsigned char *)(a1 + 80) & 8) != 0)
  {
    sub_1001F10F4(a1, 128);
    return;
  }
  __int16 v24 = 0;
  arc4random_buf((void *)(a1 + 540), 2uLL);
  arc4random_buf((void *)(a1 + 554), 8uLL);
  uint64_t v2 = sub_100180684(&xmmword_100A10266, (uint64_t *)(a1 + 554), &v24);
  if (v2)
  {
    uint64_t v3 = v2;
    if (!sub_100058654()) {
      return;
    }
    sub_100056E24((uint64_t)"Could not generate DIV %!", v4, v5, v6, v7, v8, v9, v10, v3);
    char v11 = sub_100050B4C(0x43u);
    if (!os_log_type_enabled(v11, OS_LOG_TYPE_ERROR)) {
      return;
    }
    goto LABEL_8;
  }
  __int16 v12 = *(_WORD *)(a1 + 540);
  *(_WORD *)(a1 + 544) = v12 ^ v24;
  uint64_t v13 = sub_100180D78(&xmmword_100A10276, v12, 0, (void *)(a1 + 524));
  if (v13)
  {
    uint64_t v14 = v13;
    if (!sub_100058654()) {
      return;
    }
    sub_100056E24((uint64_t)"Could not generate LTK %!", v15, v16, v17, v18, v19, v20, v21, v14);
    char v22 = sub_100050B4C(0x43u);
    if (!os_log_type_enabled(v22, OS_LOG_TYPE_ERROR)) {
      return;
    }
LABEL_8:
    sub_100745764();
    return;
  }
  uint64_t v23 = *(unsigned __int8 *)(a1 + 81);
  if (v23 != 16) {
    bzero((void *)(a1 + 524 + v23), 16 - v23);
  }
  sub_1001F10F4(a1, 128);
}

void sub_10023DF48(uint64_t a1)
{
  if (!sub_1001F11E4(a1, 128))
  {
    if (sub_100058654())
    {
      sub_100056E24((uint64_t)"SMP State is not GENERATED.", v2, v3, v4, v5, v6, v7, v8, v79);
      uint64_t v9 = sub_100050B4C(0x43u);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR)) {
        sub_100744F6C();
      }
    }
  }
  if (*(unsigned char *)(*(void *)a1 + 70)) {
    char v10 = 66;
  }
  else {
    char v10 = 64;
  }
  sub_1001F10F4(a1, v10);
  if ((*(unsigned char *)(a1 + 72) & *(unsigned char *)(a1 + 80) & 8) != 0)
  {
    if ((*(unsigned char *)(a1 + 80) & 1) != 0 && unk_100A19740)
    {
      if (*(unsigned char *)(a1 + 16) == 1) {
        char v11 = 2;
      }
      else {
        char v11 = 3;
      }
      LOBYTE(v81[0]) = v11;
      unk_100A19740(*(void *)a1 + 48, 5, a1 + 524, 16, 0);
      unk_100A19740(*(void *)a1 + 48, 7, v81, 1, 0);
      unk_100A19740(*(void *)a1 + 48, 6, a1 + 81, 1, 0);
      if (*(unsigned char *)(a1 + 594))
      {
        if (*(unsigned char *)(a1 + 593)) {
          unsigned __int8 v12 = 2;
        }
        else {
          unsigned __int8 v12 = 1;
        }
      }
      else
      {
        unsigned __int8 v12 = 0;
      }
      unsigned __int8 v80 = v12;
      if (sub_100058654())
      {
        sub_100056E24((uint64_t)"deriveLKLTK=%d useH7=%d", v14, v15, v16, v17, v18, v19, v20, v12);
        uint64_t v21 = sub_100050B4C(0x43u);
        if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
        {
          char v22 = sub_100050714();
          *(_DWORD *)long long buf = 136446210;
          *(void *)&uint8_t buf[4] = v22;
          _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
        }
      }
      if (v12) {
        unk_100A19740(*(void *)a1 + 48, 16, &v80, 1, 0);
      }
      goto LABEL_30;
    }
  }
  else if ((*(unsigned char *)(a1 + 76) & 1) != 0 && (*(unsigned char *)(a1 + 77) & 1) == 0)
  {
    buf[0] = 6;
    *(_OWORD *)&buf[1] = *(_OWORD *)(a1 + 524);
    if (*(unsigned char *)(a1 + 9))
    {
      int v13 = sub_1001F0C08(*(void *)a1, buf, 0x11uLL, 1);
      if (!v13)
      {
        buf[0] = 7;
        *(_WORD *)&buf[1] = *(_WORD *)(a1 + 544);
        *(void *)&buf[3] = *(void *)(a1 + 554);
        if (*(unsigned char *)(a1 + 9))
        {
          int v13 = sub_1001F0C08(*(void *)a1, buf, 0xBuLL, 1);
        }
        else
        {
          if (sub_100058654())
          {
            sub_100056E24((uint64_t)"This link is not encrypted, cannot send EDIV/RAND.", v63, v64, v65, v66, v67, v68, v69, v79);
            uint64_t v70 = sub_100050B4C(0x43u);
            if (os_log_type_enabled(v70, OS_LOG_TYPE_ERROR)) {
              sub_100744F6C();
            }
          }
          int v13 = 4802;
        }
      }
      if (!*(unsigned char *)(a1 + 612))
      {
        if (!v13 && (*(unsigned char *)(a1 + 80) & 1) != 0 && unk_100A19740)
        {
          buf[0] = *(unsigned char *)(a1 + 16) != 1;
          unk_100A19740(*(void *)a1 + 48, 6, a1 + 81, 1, 0);
          unk_100A19740(*(void *)a1 + 48, 7, buf, 1, 0);
          unk_100A19740(*(void *)a1 + 48, 8, a1 + 544, 2, 0);
          unk_100A19740(*(void *)a1 + 48, 9, a1 + 554, 8, 0);
        }
        goto LABEL_30;
      }
    }
    else
    {
      if (sub_100058654())
      {
        sub_100056E24((uint64_t)"This link is not encrypted, cannot send LTK.", v55, v56, v57, v58, v59, v60, v61, v79);
        uint64_t v62 = sub_100050B4C(0x43u);
        if (os_log_type_enabled(v62, OS_LOG_TYPE_ERROR)) {
          sub_100744F6C();
        }
      }
      if (!*(unsigned char *)(a1 + 612)) {
        goto LABEL_30;
      }
    }
    if (sub_100058654())
    {
      sub_100056E24((uint64_t)"Compromised device, dropping keys", v71, v72, v73, v74, v75, v76, v77, v79);
      uint64_t v78 = sub_100050B4C(0x43u);
      if (os_log_type_enabled(v78, OS_LOG_TYPE_ERROR)) {
        sub_100744F6C();
      }
    }
LABEL_30:
    *(unsigned char *)(a1 + 77) |= 1u;
  }
  if ((*(unsigned char *)(a1 + 76) & 2) != 0 && (*(unsigned char *)(a1 + 77) & 2) == 0)
  {
    buf[0] = 8;
    buf[1] = *(unsigned char *)sub_1001F07E8();
    buf[2] = *((unsigned char *)sub_1001F07E8() + 1);
    buf[3] = *((unsigned char *)sub_1001F07E8() + 2);
    uint8_t buf[4] = *((unsigned char *)sub_1001F07E8() + 3);
    buf[5] = *((unsigned char *)sub_1001F07E8() + 4);
    buf[6] = *((unsigned char *)sub_1001F07E8() + 5);
    buf[7] = *((unsigned char *)sub_1001F07E8() + 6);
    buf[8] = *((unsigned char *)sub_1001F07E8() + 7);
    buf[9] = *((unsigned char *)sub_1001F07E8() + 8);
    buf[10] = *((unsigned char *)sub_1001F07E8() + 9);
    buf[11] = *((unsigned char *)sub_1001F07E8() + 10);
    buf[12] = *((unsigned char *)sub_1001F07E8() + 11);
    buf[13] = *((unsigned char *)sub_1001F07E8() + 12);
    buf[14] = *((unsigned char *)sub_1001F07E8() + 13);
    buf[15] = *((unsigned char *)sub_1001F07E8() + 14);
    buf[16] = *((unsigned char *)sub_1001F07E8() + 15);
    if (*(unsigned char *)(a1 + 9))
    {
      sub_1001F0C08(*(void *)a1, buf, 0x11uLL, 1);
    }
    else if (sub_100058654())
    {
      sub_100056E24((uint64_t)"This link is not encrypted, cannot send IRK.", v23, v24, v25, v26, v27, v28, v29, v79);
      uint64_t v30 = sub_100050B4C(0x43u);
      if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR)) {
        sub_100744F6C();
      }
    }
    int v31 = *(_DWORD *)(*(void *)a1 + 236);
    if (v31 == 1)
    {
      int v32 = 0;
    }
    else if (v31 || (*(unsigned char *)(a1 + 76) & 8) != 0 && (*(unsigned char *)(a1 + 74) & 8) != 0)
    {
      int v32 = 1;
    }
    else
    {
      int v32 = sub_1000EAA20(*(void *)a1);
    }
    memset(v81, 0, 7);
    sub_100229724((uint64_t)v81);
    if (LOBYTE(v81[0])
      && ((unsigned int v33 = *(unsigned __int8 *)(*(void *)a1 + 24), *(_WORD *)(*(void *)a1 + 20) == 13)
        ? (BOOL v34 = v33 >= 0xB)
        : (BOOL v34 = 1),
          v34 ? (BOOL v35 = v33 >= 0xA) : (BOOL v35 = 0),
          v35 ? (BOOL v36 = byte_1009FAEFC == 0) : (BOOL v36 = 0),
          !v36 ? (int v37 = 1) : (int v37 = v32),
          v37 != 1))
    {
      unint64_t v43 = sub_100232C70();
      unint64_t v38 = sub_1002284B8(v43);
      v81[0] = v38;
      BYTE2(v81[1]) = BYTE6(v38);
      LOWORD(v81[1]) = WORD2(v38);
      v44.i64[0] = 0xFFFFFFFFFFFFFFLL;
      v44.i64[1] = 0xFFFFFFFFFFFFFFLL;
      uint64x2_t v45 = (uint64x2_t)vandq_s8((int8x16_t)vdupq_n_s64(v38), v44);
      int16x8_t v40 = (int16x8_t)vuzp1q_s32((int32x4_t)vshlq_u64(v45, (uint64x2_t)xmmword_1007BA9E0), (int32x4_t)vshlq_u64(v45, (uint64x2_t)xmmword_1007BA9D0));
      *(int16x4_t *)v40.i8 = vmovn_s32((int32x4_t)v40);
      unint64_t v41 = v38 >> 16;
      unint64_t v42 = v38 >> 8;
    }
    else
    {
      sub_100229758((uint64_t)v81);
      LOBYTE(v38) = v81[0];
      v39.i32[0] = *(_DWORD *)((char *)v81 + 3);
      int16x8_t v40 = (int16x8_t)vmovl_u8(v39);
      *(int16x4_t *)v40.i8 = vrev64_s16(*(int16x4_t *)v40.i8);
      LOBYTE(v41) = BYTE2(v81[0]);
      LOBYTE(v42) = BYTE1(v81[0]);
    }
    buf[0] = 9;
    buf[1] = v38;
    *(_DWORD *)&buf[2] = vmovn_s16(v40).u32[0];
    buf[6] = v41;
    buf[7] = v42;
    if (*(unsigned char *)(a1 + 9))
    {
      sub_1001F0C08(*(void *)a1, buf, 8uLL, 1);
    }
    else if (sub_100058654())
    {
      sub_100056E24((uint64_t)"This link is not encrypted, cannot send address.", v46, v47, v48, v49, v50, v51, v52, v79);
      uint64_t v53 = sub_100050B4C(0x43u);
      if (os_log_type_enabled(v53, OS_LOG_TYPE_ERROR)) {
        sub_100744F6C();
      }
    }
    *(unsigned char *)(a1 + 77) |= 2u;
  }
  if (*(unsigned char *)(*(void *)a1 + 70)) {
    char v54 = 67;
  }
  else {
    char v54 = 65;
  }
  sub_1001F10F4(a1, v54);
}

uint64_t sub_10023E644(uint64_t a1, _OWORD *a2, unsigned char *a3)
{
  if (!sub_100197770(a1)) {
    sub_10025B8C0();
  }
  uint64_t v6 = sub_1001F0BBC(a1);
  if (v6)
  {
    uint64_t v7 = v6;
    if (sub_1001F11E4(v6, 41))
    {
      int v8 = *(unsigned __int8 *)(v7 + 16);
      if ((*(unsigned char *)(v7 + 72) & *(unsigned char *)(v7 + 80) & 8) != 0)
      {
        if (v8 == 1) {
          char v9 = 2;
        }
        else {
          char v9 = 3;
        }
        *a3 = v9;
        if (!a2) {
          return 1;
        }
        long long v10 = *(_OWORD *)(v7 + 524);
      }
      else
      {
        *a3 = v8 != 1;
        if (!a2) {
          return 1;
        }
        long long v10 = *(_OWORD *)(v7 + 56);
      }
      *a2 = v10;
      return 1;
    }
    uint64_t result = sub_100058654();
    if (result)
    {
      sub_100056E24((uint64_t)"STK not generated for handle 0x%x", v20, v21, v22, v23, v24, v25, v26, a1);
      uint64_t v27 = sub_100050B4C(0x43u);
      uint64_t result = os_log_type_enabled(v27, OS_LOG_TYPE_ERROR);
      if (result)
      {
LABEL_16:
        sub_100744F6C();
        return 0;
      }
    }
  }
  else
  {
    uint64_t result = sub_100058654();
    if (result)
    {
      sub_100056E24((uint64_t)"There is no pairing data for this connection.", v12, v13, v14, v15, v16, v17, v18, v28);
      uint64_t v19 = sub_100050B4C(0x43u);
      uint64_t result = os_log_type_enabled(v19, OS_LOG_TYPE_ERROR);
      if (result) {
        goto LABEL_16;
      }
    }
  }
  return result;
}

uint64_t sub_10023E778(uint64_t *a1, __int16 a2, void *a3)
{
  __int16 v24 = 0;
  uint64_t v5 = sub_100180684(&xmmword_100A10266, a1, &v24);
  if (v5)
  {
    uint64_t v6 = v5;
    if (sub_100058654())
    {
      sub_100056E24((uint64_t)"Could not generate DIV %!", v7, v8, v9, v10, v11, v12, v13, v6);
      uint64_t v14 = sub_100050B4C(0x43u);
      if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR)) {
LABEL_8:
      }
        sub_100745764();
    }
  }
  else
  {
    uint64_t v6 = sub_100180D78(&xmmword_100A10276, v24 ^ a2, 0, a3);
    if (v6)
    {
      if (sub_100058654())
      {
        sub_100056E24((uint64_t)"Could not generate LTK %!", v15, v16, v17, v18, v19, v20, v21, v6);
        uint64_t v22 = sub_100050B4C(0x43u);
        if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR)) {
          goto LABEL_8;
        }
      }
    }
  }
  return v6;
}

uint64_t sub_10023E880(__int16 *a1, int a2)
{
  if ((unsigned __int16)*a1 | *((unsigned __int8 *)a1 + 2))
  {
    if (a2) {
      uint64_t v4 = sub_1001F07F4();
    }
    else {
      uint64_t v4 = sub_1001F07E8();
    }
    if (*v4 == 0)
    {
      if (sub_100058654())
      {
        sub_100056E24((uint64_t)"Cannot generate local random address when the IRK is set to 0's", v23, v24, v25, v26, v27, v28, v29, v32);
        uint64_t v30 = sub_100050B4C(0x43u);
        if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR)) {
          sub_100744F6C();
        }
      }
      return 103;
    }
    else
    {
      uint64_t v13 = sub_100180780(v4, a1, (uint64_t)a1 + 3);
      if (sub_100017A14() && sub_100058654())
      {
        uint64_t v21 = "Primary";
        if (a2) {
          uint64_t v21 = "Secondary";
        }
        sub_100056E24((uint64_t)"******* GENERATING RANDOM ADDRESS WITH %s IRK:%@ address:%@ AH result:%d", v14, v15, v16, v17, v18, v19, v20, (uint64_t)v21);
        uint64_t v22 = sub_100050B4C(0x43u);
        if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)long long buf = 136446210;
          BOOL v34 = sub_100050714();
          _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
        }
      }
    }
  }
  else
  {
    if (sub_100058654())
    {
      sub_100056E24((uint64_t)"Cannot generate local random address when the address bytes are set to 0's", v5, v6, v7, v8, v9, v10, v11, v32);
      uint64_t v12 = sub_100050B4C(0x43u);
      if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR)) {
        sub_100744F6C();
      }
    }
    return 101;
  }
  return v13;
}

void sub_10023EA58(uint64_t a1, uint64_t a2)
{
  uint64_t v66 = a1;
  if (a2)
  {
    if (sub_100058654())
    {
      sub_100056E24((uint64_t)"Link ready CB with status %!(%d).", v3, v4, v5, v6, v7, v8, v9, a2);
      uint64_t v10 = sub_100050B4C(0x43u);
      if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR)) {
LABEL_31:
      }
        sub_100744F6C();
    }
  }
  else
  {
    uint64_t v12 = sub_1001F0BBC(a1);
    if (v12)
    {
      uint64_t v13 = (char *)v12;
      if (*(unsigned char *)(a1 + 166) == 1)
      {
        if (sub_100058654())
        {
          sub_100056E24((uint64_t)"Connection %p is already encrypted, lets drop this pairing data", v14, v15, v16, v17, v18, v19, v20, a1);
          uint64_t v21 = sub_100050B4C(0x43u);
          if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
          {
            LODWORD(buf) = 136446210;
            *(void *)((char *)&buf + 4) = sub_100050714();
            _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, " %{public}s", (uint8_t *)&buf, 0xCu);
          }
        }
        sub_1001F0828(v13, 0, 0);
      }
      else if (sub_1001F11E4(v12, 16))
      {
        if (sub_100058654())
        {
          sub_1001F10E8();
          sub_100056E24((uint64_t)"continue deferred handling of incoming Security Request from device %: (%s)", v22, v23, v24, v25, v26, v27, v28, a1 + 49);
          uint64_t v29 = sub_100050B4C(0x43u);
          if (os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
          {
            LODWORD(buf) = 136446210;
            *(void *)((char *)&buf + 4) = sub_100050714();
            _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEFAULT, " %{public}s", (uint8_t *)&buf, 0xCu);
          }
        }
        *((void *)&buf + 1) = v13;
        *(void *)&long long buf = 8;
        uint64_t v30 = sub_1000268E4((uint64_t)sub_10023EDFC, (const void **)&buf, 5, 0);
        if (v30)
        {
          uint64_t v31 = v30;
          if (sub_100058654())
          {
            sub_100056E24((uint64_t)"Could not dispatch SecurityRequest CB with status %!.", v32, v33, v34, v35, v36, v37, v38, v31);
            uint8x8_t v39 = sub_100050B4C(0x43u);
            if (os_log_type_enabled(v39, OS_LOG_TYPE_ERROR)) {
              sub_100745764();
            }
          }
        }
      }
      else if (sub_1001F11E4((uint64_t)v13, 17))
      {
        if (sub_100058654())
        {
          sub_1001F10E8();
          sub_100056E24((uint64_t)"continue deferred handling of incoming Pairing Request from device %: (%s)", v40, v41, v42, v43, v44, v45, v46, a1 + 49);
          uint64_t v47 = sub_100050B4C(0x43u);
          if (os_log_type_enabled(v47, OS_LOG_TYPE_DEFAULT))
          {
            LODWORD(buf) = 136446210;
            *(void *)((char *)&buf + 4) = sub_100050714();
            _os_log_impl((void *)&_mh_execute_header, v47, OS_LOG_TYPE_DEFAULT, " %{public}s", (uint8_t *)&buf, 0xCu);
          }
        }
        *((void *)&buf + 1) = &v66;
        *(void *)&long long buf = 8;
        uint64_t v48 = sub_1000268E4((uint64_t)sub_10023EF04, (const void **)&buf, 5, 0);
        if (v48)
        {
          uint64_t v49 = v48;
          if (sub_100058654())
          {
            sub_100056E24((uint64_t)"Could not dispatch pairing request with status %!.", v50, v51, v52, v53, v54, v55, v56, v49);
            uint64_t v57 = sub_100050B4C(0x43u);
            if (os_log_type_enabled(v57, OS_LOG_TYPE_ERROR)) {
              sub_100745764();
            }
          }
        }
      }
      else if (sub_100237A40(a1))
      {
        if (sub_100058654())
        {
          sub_1001F10E8();
          sub_100056E24((uint64_t)"Device %: is in state %s, but its not supposed to be in this state", v58, v59, v60, v61, v62, v63, v64, a1 + 49);
          uint64_t v65 = sub_100050B4C(0x43u);
          if (os_log_type_enabled(v65, OS_LOG_TYPE_ERROR)) {
            goto LABEL_31;
          }
        }
      }
    }
  }
}

void sub_10023EDFC(uint64_t a1)
{
  uint64_t v1 = **(void **)(a1 + 8);
  if (!sub_100197770(v1))
  {
    if (!sub_100058654()) {
      return;
    }
    sub_100056E24((uint64_t)"Handle is not valid anymore.", v6, v7, v8, v9, v10, v11, v12, v22);
    uint64_t v13 = sub_100050B4C(0x43u);
    if (!os_log_type_enabled(v13, OS_LOG_TYPE_ERROR)) {
      return;
    }
LABEL_15:
    sub_100744F6C();
    return;
  }
  uint64_t v2 = sub_1001F0BBC(v1);
  if (!v2)
  {
    if (!sub_100058654()) {
      return;
    }
    sub_100056E24((uint64_t)"There is no pairing data for connection", v14, v15, v16, v17, v18, v19, v20, v22);
    uint64_t v21 = sub_100050B4C(0x43u);
    if (!os_log_type_enabled(v21, OS_LOG_TYPE_ERROR)) {
      return;
    }
    goto LABEL_15;
  }
  uint64_t v3 = off_100A19748;
  if (off_100A19748)
  {
    unsigned int v4 = *(unsigned __int8 *)(v2 + 80);
    if (*(unsigned char *)(v1 + 55)) {
      uint64_t v5 = v1 + 56;
    }
    else {
      uint64_t v5 = v1 + 48;
    }
    ((void (*)(uint64_t, void, void))v3)(v5, (v4 >> 2) & 1, 0);
  }
}

void sub_10023EF04(uint64_t a1)
{
  uint64_t v1 = *(uint64_t **)(a1 + 8);
  uint64_t v2 = *v1;
  if (!*v1 || !sub_100197770(*v1))
  {
    if (!sub_100058654()) {
      return;
    }
    sub_100056E24((uint64_t)"This handle is not a LE connection.", v4, v5, v6, v7, v8, v9, v10, v20);
    uint64_t v11 = sub_100050B4C(0x43u);
    if (!os_log_type_enabled(v11, OS_LOG_TYPE_ERROR)) {
      return;
    }
LABEL_10:
    sub_100744F6C();
    return;
  }
  if (!sub_1001F0BBC(v2))
  {
    if (!sub_100058654()) {
      return;
    }
    sub_100056E24((uint64_t)"There is no security request for this connection. Ignoring reply.", v12, v13, v14, v15, v16, v17, v18, v20);
    uint64_t v19 = sub_100050B4C(0x43u);
    if (!os_log_type_enabled(v19, OS_LOG_TYPE_ERROR)) {
      return;
    }
    goto LABEL_10;
  }
  uint64_t v3 = (void (*)(uint64_t, void))off_100A19750;
  if (off_100A19750)
  {
    v3(v2 + 48, 0);
  }
}

void sub_10023EFF8(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (char *)sub_1001F0BBC(a1);
  if (v3)
  {
    sub_1001F0828(v3, a2, 1);
  }
}

uint64_t sub_10023F044(uint64_t a1)
{
  if (!sub_100197770(a1)) {
    return 122;
  }
  uint64_t v2 = *(char **)(a1 + 240);
  if (v2) {
    sub_1001F0828(v2, 122, 1);
  }
  uint64_t result = *(unsigned int *)(a1 + 180);
  if (result)
  {
    sub_100026DB4(result);
    uint64_t result = 0;
    *(_DWORD *)(a1 + 180) = 0;
  }
  return result;
}

void sub_10023F09C(long long *a1)
{
  int v2 = sub_100058654();
  if (a1)
  {
    if (v2)
    {
      sub_100056E24((uint64_t)"MUC - save IRK and update RSA adv instance", v3, v4, v5, v6, v7, v8, v9, *(uint64_t *)v12);
      uint64_t v10 = sub_100050B4C(0x43u);
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)uint64_t v12 = 136446210;
        *(void *)&v12[4] = sub_100050714();
        _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, " %{public}s", v12, 0xCu);
      }
    }
    xmmword_100A10286 = *a1;
  }
  else
  {
    if (v2)
    {
      sub_100056E24((uint64_t)"MUC - reset IRK", v3, v4, v5, v6, v7, v8, v9, *(uint64_t *)v12);
      uint64_t v11 = sub_100050B4C(0x43u);
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)uint64_t v12 = 136446210;
        *(void *)&v12[4] = sub_100050714();
        _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, " %{public}s", v12, 0xCu);
      }
    }
    xmmword_100A10286 = 0uLL;
  }
}

uint64_t sub_10023F1E0(long long *a1, __n128 *a2, long long *a3, long long *a4, __n128 *a5)
{
  xmmword_100A10296 = *a1;
  sub_1001F0800(a2);
  sub_1001F0814(a5);
  xmmword_100A10276 = *a3;
  xmmword_100A10266 = *a4;
  return 0;
}

uint64_t sub_10023F254(uint64_t (*a1)(void, void, void, void, void), uint64_t a2, uint64_t (*a3)(void, void, void, void), int a4, int a5, char a6, char a7)
{
  if (qword_100A102A8) {
    sub_10025B8C0();
  }
  byte_1009FAEFB = sub_10023F3B0(a4, a5);
  unk_100A19740 = a1;
  *(_OWORD *)&off_100A19748 = *(_OWORD *)a2;
  off_100A19758 = *(_UNKNOWN **)(a2 + 16);
  unk_100A19760 = a3;
  uint64_t v14 = sub_1001DEA28(6u, 2, 8, 8u, &qword_100A102A8, (uint64_t)sub_1001F0A1C);
  if (v14 || !qword_100A102A8)
  {
    if (sub_100058654())
    {
      sub_100056E24((uint64_t)"Could not register the LE SecurityManager : %!", v15, v16, v17, v18, v19, v20, v21, v14);
      uint64_t v22 = sub_100050B4C(0x43u);
      if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR)) {
        sub_100745764();
      }
    }
  }
  else
  {
    *(_WORD *)sub_1001E688C((unsigned int *)qword_100A102A8) = 65;
    byte_100A10261 = a6;
    byte_100A10265 = a7;
    *(_WORD *)(sub_1001E688C((unsigned int *)qword_100A102A8) + 2) = -1;
    sub_100224014((uint64_t)&unk_10099F318);
  }
  return v14;
}

uint64_t sub_10023F3B0(int a1, int a2)
{
  switch(a1)
  {
    case 3:
      if (a2 == 16) {
        return 2;
      }
      if (a2 == 32) {
        return 4;
      }
      goto LABEL_13;
    case 2:
      if (a2 != 16)
      {
        if (a2 == 32) {
          return 1;
        }
        goto LABEL_13;
      }
      break;
    case 1:
      if (a2 != 16)
      {
        if (a2 == 32) {
          return 0;
        }
        goto LABEL_13;
      }
      break;
    default:
LABEL_13:
      sub_10025B8C0();
      return 3;
  }
  return 3;
}

uint64_t sub_10023F434()
{
  sub_1002241AC((uint64_t)&unk_10099F318);
  uint64_t v0 = sub_1001DEC18(qword_100A102A8);
  if (v0)
  {
    if (sub_100058654())
    {
      sub_100056E24((uint64_t)"Could not de-register the LE SecurityManager : %!", v1, v2, v3, v4, v5, v6, v7, v0);
      uint64_t v8 = sub_100050B4C(0x43u);
      if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR)) {
        sub_100745764();
      }
    }
  }
  else
  {
    qword_100A102A8 = 0;
    *(_OWORD *)&unk_100A19740 = 0u;
    *(_OWORD *)&off_100A19750 = 0u;
    *(_OWORD *)&unk_100A19760 = 0u;
    byte_1009FAEFB = 3;
    sub_1001F0800(&xmmword_1007BAA02);
    sub_1001F0814(&xmmword_1007BAA02);
    xmmword_100A10266 = 0uLL;
    xmmword_100A10276 = 0uLL;
    xmmword_100A10296 = 0uLL;
  }
  return v0;
}

uint64_t sub_10023F520()
{
  if (xmmword_100A10276 != 0 && xmmword_100A10296 != 0) {
    return 0;
  }
  if (sub_100058654())
  {
    sub_100056E24((uint64_t)"Root keys are not set, can't pair.", v1, v2, v3, v4, v5, v6, v7, v9);
    uint64_t v8 = sub_100050B4C(0x43u);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR)) {
      sub_100744F6C();
    }
  }
  sub_10025B8C0();
  return 4826;
}

uint64_t sub_10023F5B4(uint64_t a1, int a2)
{
  char v4 = byte_1009FAEF9;
  if (byte_1009FAEF9 == 255) {
    char v4 = 11;
  }
  if (byte_1009FAEFA == 255) {
    char v5 = 11;
  }
  else {
    char v5 = byte_1009FAEFA;
  }
  char v6 = v4 & 0xF7;
  char v7 = v5 & 0xF7;
  if (byte_100A10260) {
    char v8 = v4 & 0xF7;
  }
  else {
    char v8 = v4;
  }
  if (byte_100A10260) {
    char v9 = v5 & 0xF7;
  }
  else {
    char v9 = v5;
  }
  if (sub_100058654())
  {
    sub_100056E24((uint64_t)"StartPairing was called", v10, v11, v12, v13, v14, v15, v16, v91);
    uint64_t v17 = sub_100050B4C(0x43u);
    if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 136446210;
      uint64_t v93 = sub_100050714();
      _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
    }
  }
  uint64_t v18 = sub_10023F520();
  if (v18) {
    return v18;
  }
  if (!sub_100197770(a1))
  {
    if (!sub_100058654()) {
      return 4820;
    }
    sub_100056E24((uint64_t)"Connection handle is not a LE handle...", v19, v20, v21, v22, v23, v24, v25, v91);
    uint64_t v26 = sub_100050B4C(0x43u);
    if (!os_log_type_enabled(v26, OS_LOG_TYPE_ERROR)) {
      return 4820;
    }
LABEL_21:
    sub_100744F6C();
    return 4820;
  }
  if (*(unsigned char *)(a1 + 233)) {
    return 4837;
  }
  char v28 = v6;
  char v29 = v7;
  if (a2) {
    int v30 = 4;
  }
  else {
    int v30 = 0;
  }
  int v31 = v30 | sub_1002290A0();
  if (byte_100A10261)
  {
    if (*(unsigned __int8 *)(a1 + 24) > 7u
      || (int v32 = *(unsigned __int16 *)(a1 + 20), v32 != 2) && v32 != 90 && v32 != 13
      || *(unsigned char *)(a1 + 70) == 1)
    {
      if ((byte_100A10262 & 1) != 0 || *(unsigned char *)(a1 + 232) || (v8 & 8) == 0)
      {
        v31 |= 8u;
      }
      else
      {
        if (sub_100058654())
        {
          sub_100056E24((uint64_t)"Sending CT2=1", v33, v34, v35, v36, v37, v38, v39, v91);
          uint64_t v40 = sub_100050B4C(0x43u);
          if (os_log_type_enabled(v40, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v41 = sub_100050714();
            *(_DWORD *)long long buf = 136446210;
            uint64_t v93 = v41;
            _os_log_impl((void *)&_mh_execute_header, v40, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
          }
        }
        v31 |= 0x28u;
      }
      char v28 = v8;
      char v29 = v9;
    }
  }
  if (*(unsigned char *)(a1 + 232)) {
    int v42 = v31 & 0x1F;
  }
  else {
    int v42 = v31;
  }
  if (*(unsigned char *)(a1 + 232)) {
    char v43 = v6;
  }
  else {
    char v43 = v28;
  }
  if (!*(unsigned char *)(a1 + 232)) {
    char v7 = v29;
  }
  uint64_t v44 = v42 | byte_100A10264;
  if (*(unsigned char *)(a1 + 55)) {
    uint64_t v45 = (_DWORD *)(a1 + 56);
  }
  else {
    uint64_t v45 = 0;
  }
  char v46 = sub_100233B84((_DWORD *)(a1 + 48), v45);
  if (sub_100058654())
  {
    sub_100056E24((uint64_t)"authReq=%x localKeyDist=%x localKeyReq=%x", v47, v48, v49, v50, v51, v52, v53, v44);
    uint64_t v54 = sub_100050B4C(0x43u);
    if (os_log_type_enabled(v54, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v55 = sub_100050714();
      *(_DWORD *)long long buf = 136446210;
      uint64_t v93 = v55;
      _os_log_impl((void *)&_mh_execute_header, v54, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
    }
  }
  if (*(unsigned char *)(a1 + 70) != 1) {
    return sub_100239E6C(a1, byte_1009FAEFB, v46, v44, v43, v7);
  }
  buf[0] = 11;
  buf[1] = v44;
  if (!sub_100197770(a1))
  {
    if (!sub_100058654()) {
      return 4820;
    }
    sub_100056E24((uint64_t)"This command is only available to LE devices.", v67, v68, v69, v70, v71, v72, v73, v91);
    uint64_t v74 = sub_100050B4C(0x43u);
    if (!os_log_type_enabled(v74, OS_LOG_TYPE_ERROR)) {
      return 4820;
    }
    goto LABEL_21;
  }
  if (*(unsigned char *)(a1 + 70))
  {
    uint64_t v56 = sub_1001F0BBC(a1);
    if (v56)
    {
      uint64_t v57 = (char *)v56;
      if (!sub_1001F11E4(v56, 0))
      {
        if (sub_100058654())
        {
          uint64_t v58 = sub_1001F10E8();
          sub_100056E24((uint64_t)"Cannot send a security request, device is in state %s.", v59, v60, v61, v62, v63, v64, v65, (uint64_t)v58);
          uint64_t v66 = sub_100050B4C(0x43u);
          if (os_log_type_enabled(v66, OS_LOG_TYPE_ERROR)) {
            sub_100745764();
          }
        }
        return 4804;
      }
LABEL_74:
      v57[72] = v44;
      v57[73] = v46;
      uint64_t v18 = sub_1001F0C08(*(void *)v57, (char *)buf, 2uLL, 0);
      if (v18) {
        sub_1001F0828(v57, v18, 1);
      }
      else {
        sub_1001F10F4((uint64_t)v57, 16);
      }
      return v18;
    }
    uint64_t v57 = sub_1001F0EE8(a1);
    if (v57) {
      goto LABEL_74;
    }
    if (sub_100058654())
    {
      sub_100056E24((uint64_t)"Could not allocate a pairing record for handle 0x%x", v83, v84, v85, v86, v87, v88, v89, a1);
      uint64_t v90 = sub_100050B4C(0x43u);
      if (os_log_type_enabled(v90, OS_LOG_TYPE_ERROR)) {
        sub_100745764();
      }
    }
    return 104;
  }
  else
  {
    if (sub_100058654())
    {
      sub_100056E24((uint64_t)"You cannot send this command when central.", v75, v76, v77, v78, v79, v80, v81, v91);
      uint64_t v82 = sub_100050B4C(0x43u);
      if (os_log_type_enabled(v82, OS_LOG_TYPE_ERROR)) {
        sub_100744F6C();
      }
    }
    return 4822;
  }
}

uint64_t sub_10023FAF4(_OWORD *a1)
{
  if (a1)
  {
    uint64_t v2 = a1 + 2;
    uint64_t v3 = sub_1001818CC(a1 + 2, a1 + 6);
    if (v3)
    {
      uint64_t v4 = v3;
      if (sub_100058654())
      {
        sub_100056E24((uint64_t)"Failed to generate public/private key %!", v5, v6, v7, v8, v9, v10, v11, v4);
        uint64_t v12 = sub_100050B4C(0x43u);
        if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR)) {
          sub_100745764();
        }
      }
    }
    else
    {
      arc4random_buf(a1, 0x10uLL);
      long long v22 = v2[1];
      v32[0] = *v2;
      v32[1] = v22;
      uint64_t v4 = sub_100180EA8(v32, v32, a1, 0, a1 + 1);
      if (v4)
      {
        if (sub_100058654())
        {
          sub_100056E24((uint64_t)"Failed to generate confirmation value C with status %!", v23, v24, v25, v26, v27, v28, v29, v4);
          int v30 = sub_100050B4C(0x43u);
          if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR)) {
            sub_100745764();
          }
        }
      }
    }
  }
  else
  {
    if (sub_100058654())
    {
      sub_100056E24((uint64_t)"Must provide storage for OOB Bundle and private key", v13, v14, v15, v16, v17, v18, v19, v31);
      uint64_t v20 = sub_100050B4C(0x43u);
      if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR)) {
        sub_100744F6C();
      }
    }
    return 101;
  }
  return v4;
}

uint64_t sub_10023FC80(_DWORD *a1, _OWORD *a2, _OWORD *a3, _OWORD *a4)
{
  uint64_t v7 = sub_100197B34(a1);
  if (!v7) {
    return 122;
  }
  uint64_t v8 = v7;
  uint64_t v9 = sub_1001F0BBC(v7);
  if (!v9) {
    return 4806;
  }
  uint64_t v10 = (char *)v9;
  if ((*(unsigned char *)(v9 + 72) & *(unsigned char *)(v9 + 80) & 8) == 0 || *(unsigned char *)(v9 + 16) != 5)
  {
    if (sub_100058654())
    {
      sub_100056E24((uint64_t)"This API can only be called on LE Secured Connection OOB Pairing.", v26, v27, v28, v29, v30, v31, v32, v67);
      uint64_t v33 = sub_100050B4C(0x43u);
      if (os_log_type_enabled(v33, OS_LOG_TYPE_ERROR)) {
        sub_100744F6C();
      }
    }
    uint64_t v17 = 408;
    goto LABEL_27;
  }
  if (a4)
  {
    long long v11 = a4[2];
    long long v12 = a4[3];
    long long v13 = a4[4];
    *(_OWORD *)(v9 + 200) = a4[5];
    *(_OWORD *)(v9 + 184) = v13;
    *(_OWORD *)(v9 + 168) = v12;
    *(_OWORD *)(v9 + 152) = v11;
    memmove((void *)(v9 + 216), a4 + 6, 0x60uLL);
    if (*(unsigned char *)(*(void *)v10 + 70) == 1) {
      uint64_t v14 = v10 + 441;
    }
    else {
      uint64_t v14 = v10 + 425;
    }
    *uint64_t v14 = *a4;
    *(_OWORD *)(v10 + 88) = a4[1];
  }
  else
  {
    uint64_t v35 = (_OWORD *)(v9 + 152);
    uint64_t v36 = sub_1001818CC((_OWORD *)(v9 + 152), (_OWORD *)(v9 + 216));
    if (v36)
    {
      uint64_t v17 = v36;
      if (sub_100058654())
      {
        sub_100056E24((uint64_t)"Failed to generate public/private key %!", v37, v38, v39, v40, v41, v42, v43, v17);
        uint64_t v44 = sub_100050B4C(0x43u);
        if (os_log_type_enabled(v44, OS_LOG_TYPE_ERROR)) {
          sub_100745764();
        }
      }
      goto LABEL_27;
    }
    if (*(unsigned char *)(*(void *)v10 + 70) == 1) {
      uint64_t v53 = v10 + 441;
    }
    else {
      uint64_t v53 = v10 + 425;
    }
    arc4random_buf(v53, 0x10uLL);
    uint64_t v54 = *(void *)v10;
    if (*(unsigned char *)(*(void *)v10 + 70) == 1) {
      uint64_t v55 = v10 + 425;
    }
    else {
      uint64_t v55 = v10 + 441;
    }
    *uint64_t v55 = 0;
    v55[1] = 0;
    long long v56 = *(_OWORD *)(v10 + 168);
    *(_OWORD *)uint64_t v68 = *v35;
    *(_OWORD *)&v68[16] = v56;
    if (*(unsigned char *)(v54 + 70) == 1) {
      uint64_t v57 = (long long *)(v10 + 441);
    }
    else {
      uint64_t v57 = (long long *)(v10 + 425);
    }
    uint64_t v58 = sub_100180EA8(v68, v68, v57, 0, v10 + 88);
    if (v58)
    {
      uint64_t v17 = v58;
      if (!sub_100058654()) {
        goto LABEL_27;
      }
      sub_100056E24((uint64_t)"Failed to generate confirmation value C with status %!", v59, v60, v61, v62, v63, v64, v65, v17);
      uint64_t v66 = sub_100050B4C(0x43u);
      if (!os_log_type_enabled(v66, OS_LOG_TYPE_ERROR)) {
        goto LABEL_27;
      }
      goto LABEL_50;
    }
  }
  if (a2)
  {
    if (*(unsigned char *)(*(void *)v10 + 70) == 1) {
      uint64_t v15 = v10 + 425;
    }
    else {
      uint64_t v15 = v10 + 441;
    }
    _OWORD *v15 = *a2;
  }
  if (a3) {
    *(_OWORD *)(v10 + 104) = *a3;
  }
  v10[490] = 1;
  uint64_t v16 = *(void *)v10;
  if (!*(unsigned char *)(*(void *)v10 + 70))
  {
    v68[0] = 12;
    *(_OWORD *)&v68[1] = *(_OWORD *)(v10 + 152);
    *(_OWORD *)&v68[17] = *(_OWORD *)(v10 + 168);
    long long v69 = *(_OWORD *)(v10 + 184);
    long long v70 = *(_OWORD *)(v10 + 200);
    uint64_t v17 = sub_1001F0C08(v16, v68, 0x41uLL, 1);
    if (!v17)
    {
      sub_1001F10F4((uint64_t)v10, 33);
      return v17;
    }
    if (!sub_100058654()) {
      goto LABEL_27;
    }
    sub_100056E24((uint64_t)"Failed to send public keys %!", v45, v46, v47, v48, v49, v50, v51, v17);
    uint64_t v52 = sub_100050B4C(0x43u);
    if (!os_log_type_enabled(v52, OS_LOG_TYPE_ERROR)) {
      goto LABEL_27;
    }
LABEL_50:
    sub_100745764();
LABEL_27:
    sub_1002379C0(v8, 8, v10);
    return v17;
  }
  sub_1001F10F4((uint64_t)v10, 32);
  uint64_t v17 = sub_10024003C((uint64_t)v10);
  if (v17)
  {
    if (!sub_100058654()) {
      goto LABEL_27;
    }
    sub_100056E24((uint64_t)"recvdSMPDeferredOOBPublicKey failed %!", v18, v19, v20, v21, v22, v23, v24, v17);
    uint64_t v25 = sub_100050B4C(0x43u);
    if (!os_log_type_enabled(v25, OS_LOG_TYPE_ERROR)) {
      goto LABEL_27;
    }
    goto LABEL_50;
  }
  return v17;
}

uint64_t sub_10024003C(uint64_t a1)
{
  memset(__s2, 0, sizeof(__s2));
  sub_1001F0FFC((uint64_t *)a1);
  if (!*(unsigned char *)(a1 + 490) || !memcmp((const void *)(a1 + 312), __s2, 0x40uLL))
  {
    if (*(unsigned char *)(*(void *)a1 + 70) == 1) {
      char v15 = 32;
    }
    else {
      char v15 = 33;
    }
    sub_1001F10F4(a1, v15);
    return 0;
  }
  uint64_t v2 = *(void *)a1;
  if (*(unsigned char *)(*(void *)a1 + 70) != 1) {
    goto LABEL_15;
  }
  if (!memcmp((const void *)(a1 + 152), __s2, 0x40uLL))
  {
    uint64_t v43 = sub_1001818CC((_OWORD *)(a1 + 152), (_OWORD *)(a1 + 216));
    if (v43)
    {
      uint64_t v6 = v43;
      if (sub_100058654())
      {
        sub_100056E24((uint64_t)"LE_ReadLocalPublicKey failed %!", v44, v45, v46, v47, v48, v49, v50, v6);
        uint64_t v51 = sub_100050B4C(0x43u);
        if (os_log_type_enabled(v51, OS_LOG_TYPE_ERROR)) {
          goto LABEL_40;
        }
      }
      return v6;
    }
    uint64_t v2 = *(void *)a1;
  }
  v76[0] = 12;
  long long v3 = *(_OWORD *)(a1 + 168);
  *(_OWORD *)&v76[1] = *(_OWORD *)(a1 + 152);
  *(_OWORD *)&v76[17] = v3;
  long long v4 = *(_OWORD *)(a1 + 200);
  long long v77 = *(_OWORD *)(a1 + 184);
  long long v78 = v4;
  uint64_t v5 = sub_1001F0C08(v2, v76, 0x41uLL, 1);
  if (!v5)
  {
LABEL_15:
    uint64_t v17 = sub_100181A54((const void *)(a1 + 312), 0x40u, (const void *)(a1 + 216), 0x60u, (void *)(a1 + 376));
    if (v17)
    {
      uint64_t v6 = v17;
      if (sub_100058654())
      {
        sub_100056E24((uint64_t)"DHKey generation failed %!", v18, v19, v20, v21, v22, v23, v24, v6);
        uint64_t v25 = sub_100050B4C(0x43u);
        if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR)) {
          goto LABEL_40;
        }
      }
      return v6;
    }
    sub_1001F0FFC((uint64_t *)a1);
    BOOL v26 = *(void *)(a1 + 104) == *(void *)&__s2[0] && *(void *)(a1 + 112) == *((void *)&__s2[0] + 1);
    uint64_t v27 = *(void *)a1;
    int v28 = *(unsigned __int8 *)(*(void *)a1 + 70);
    if (v26
      || (*(unsigned char *)(*(void *)a1 + 70) ? (uint64_t v29 = (uint64_t *)(a1 + 425)) : (uint64_t v29 = (uint64_t *)(a1 + 441)),
          (v31 = *v29, uint64_t v30 = v29[1], v31 == *(void *)&__s2[0]) ? (v32 = v30 == *((void *)&__s2[0] + 1)) : (v32 = 0),
          v32))
    {
      if (*(unsigned char *)(*(void *)a1 + 70)) {
        uint64_t v52 = (void *)(a1 + 425);
      }
      else {
        uint64_t v52 = (void *)(a1 + 441);
      }
    }
    else
    {
      uint64_t v73 = 0;
      uint64_t v74 = 0;
      long long v33 = *(_OWORD *)(a1 + 328);
      *(_OWORD *)uint64_t v76 = *(_OWORD *)(a1 + 312);
      *(_OWORD *)&v76[16] = v33;
      if (v28 == 1) {
        uint64_t v34 = (long long *)(a1 + 425);
      }
      else {
        uint64_t v34 = (long long *)(a1 + 441);
      }
      uint64_t v6 = sub_100180EA8(v76, v76, v34, 0, &v73);
      if (v6)
      {
        if (!sub_100058654()) {
          return v6;
        }
        sub_100056E24((uint64_t)"Failed to calculate remote C value with status %!", v35, v36, v37, v38, v39, v40, v41, v6);
        uint64_t v42 = sub_100050B4C(0x43u);
        if (!os_log_type_enabled(v42, OS_LOG_TYPE_ERROR)) {
          return v6;
        }
        goto LABEL_36;
      }
      if (*(void *)(a1 + 104) != v73 || *(void *)(a1 + 112) != v74)
      {
        if (sub_100058654())
        {
          sub_100056E24((uint64_t)"Received and calculated remote C values do not match", v64, v65, v66, v67, v68, v69, v70, v72);
          uint64_t v71 = sub_100050B4C(0x43u);
          if (os_log_type_enabled(v71, OS_LOG_TYPE_ERROR)) {
            sub_100744F6C();
          }
        }
        sub_1002379C0(*(void *)a1, 4, (char *)a1);
        return v6;
      }
      uint64_t v27 = *(void *)a1;
      if (*(unsigned char *)(a1 + 79)) {
        goto LABEL_45;
      }
      if (*(unsigned char *)(v27 + 70) == 1) {
        uint64_t v52 = (void *)(a1 + 441);
      }
      else {
        uint64_t v52 = (void *)(a1 + 425);
      }
    }
    *uint64_t v52 = 0;
    v52[1] = 0;
LABEL_45:
    if (*(unsigned char *)(v27 + 70) == 1) {
      uint64_t v53 = (void *)(a1 + 473);
    }
    else {
      uint64_t v53 = (void *)(a1 + 457);
    }
    arc4random_buf(v53, 0x10uLL);
    if (*(unsigned char *)(*(void *)a1 + 70)) {
      char v54 = 36;
    }
    else {
      char v54 = 35;
    }
    sub_1001F10F4(a1, v54);
    if (!*(unsigned char *)(*(void *)a1 + 70))
    {
      uint64_t v6 = sub_1002408F8(*(void *)a1, (long long *)(a1 + 457));
      if (!v6)
      {
        sub_1001F10F4(a1, 37);
        return v6;
      }
      if (!sub_100058654()) {
        return v6;
      }
      sub_100056E24((uint64_t)"Failed to send pairing random to peripheral %!", v55, v56, v57, v58, v59, v60, v61, v6);
      uint64_t v62 = sub_100050B4C(0x43u);
      if (!os_log_type_enabled(v62, OS_LOG_TYPE_ERROR)) {
        return v6;
      }
LABEL_36:
      sub_100745764();
      return v6;
    }
    return 0;
  }
  uint64_t v6 = v5;
  if (sub_100058654())
  {
    sub_100056E24((uint64_t)"smpSendPairingPublicKey failed %!", v7, v8, v9, v10, v11, v12, v13, v6);
    uint64_t v14 = sub_100050B4C(0x43u);
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR)) {
LABEL_40:
    }
      sub_100745764();
  }
  return v6;
}

uint64_t sub_100240484(_DWORD *a1, unsigned char *a2)
{
  uint64_t v3 = sub_100197B34(a1);
  if (!v3) {
    return 122;
  }
  uint64_t v4 = sub_1001F0BBC(v3);
  if (!v4) {
    return 4806;
  }
  uint64_t v5 = v4;
  uint64_t result = 0;
  *a2 = *(unsigned char *)(v5 + 80);
  return result;
}

uint64_t sub_1002404D4(uint64_t result)
{
  byte_1009FAEF9 = result;
  return result;
}

uint64_t sub_1002404E0(uint64_t result)
{
  byte_1009FAEFC = result;
  return result;
}

uint64_t sub_1002404EC(uint64_t result)
{
  byte_1009FAEFA = result;
  return result;
}

uint64_t sub_1002404F8(uint64_t result)
{
  byte_100A15220 = result;
  return result;
}

void sub_100240508()
{
  byte_100A10262 = 1;
}

void sub_100240518()
{
  byte_100A10263 = 1;
}

void sub_100240530()
{
  byte_100A10260 = 1;
}

BOOL sub_100240540(BOOL result, char a2)
{
  if (result)
  {
    uint64_t v3 = result;
    uint64_t result = sub_100197770(result);
    if (result) {
      *(unsigned char *)(v3 + 232) = a2;
    }
  }
  return result;
}

uint64_t sub_100240578(uint64_t *a1)
{
  uint64_t v2 = sub_1002389B4(*a1, a1 + 11);
  if (v2)
  {
    if (sub_100058654())
    {
      sub_100056E24((uint64_t)"smpSendPairingConfirmation failed %!", v3, v4, v5, v6, v7, v8, v9, v2);
      uint64_t v10 = sub_100050B4C(0x43u);
      if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR)) {
        sub_100745764();
      }
    }
  }
  else
  {
    sub_1001F10F4((uint64_t)a1, 36);
  }
  return v2;
}

void sub_100240608(uint64_t a1)
{
  v11[1] = &v12;
  uint64_t v12 = a1;
  v11[0] = (const void *)8;
  uint64_t v1 = sub_1000268E4((uint64_t)sub_1002406AC, v11, 0, 0);
  if (v1)
  {
    uint64_t v2 = v1;
    if (sub_100058654())
    {
      sub_100056E24((uint64_t)"Could not dispatch dispatchPairingDisplay CB with status %!.", v3, v4, v5, v6, v7, v8, v9, v2);
      uint64_t v10 = sub_100050B4C(0x43u);
      if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR)) {
        sub_100745764();
      }
    }
  }
}

void sub_1002406AC(uint64_t a1)
{
  uint64_t v1 = *(uint64_t **)(a1 + 8);
  uint64_t v2 = *v1;
  if (!*v1 || !sub_100197770(*v1))
  {
    if (!sub_100058654()) {
      return;
    }
    sub_100056E24((uint64_t)"This handle is not a LE connection.", v7, v8, v9, v10, v11, v12, v13, v23);
    uint64_t v14 = sub_100050B4C(0x43u);
    if (!os_log_type_enabled(v14, OS_LOG_TYPE_ERROR)) {
      return;
    }
LABEL_12:
    sub_100744F6C();
    return;
  }
  uint64_t v3 = sub_1001F0BBC(v2);
  if (!v3)
  {
    if (!sub_100058654()) {
      return;
    }
    sub_100056E24((uint64_t)"There is no security request for this connection. Ignoring reply.", v15, v16, v17, v18, v19, v20, v21, v23);
    uint64_t v22 = sub_100050B4C(0x43u);
    if (!os_log_type_enabled(v22, OS_LOG_TYPE_ERROR)) {
      return;
    }
    goto LABEL_12;
  }
  uint64_t v4 = (void (*)(uint64_t, uint64_t, uint64_t, void))off_100A19758;
  if (off_100A19758)
  {
    uint64_t v5 = v2 + 48;
    if (*(unsigned char *)(v2 + 55)) {
      uint64_t v5 = v2 + 56;
    }
    uint64_t v6 = *(unsigned int *)(v3 + 52);
    v4(v5, v6, v3 + 33, 0);
  }
}

uint64_t sub_1002407BC(unsigned char *a1, void *a2, int a3)
{
  uint64_t v3 = a1 + 78;
  uint64_t v4 = 80;
  if (a3) {
    uint64_t v4 = 72;
  }
  uint64_t v5 = 79;
  if (a3)
  {
    uint64_t v5 = 73;
    uint64_t v3 = &byte_1009FAEFB;
  }
  char v6 = *v3;
  char v7 = a1[v5];
  LOBYTE(v26) = a1[v4];
  HIBYTE(v26) = v7;
  char v27 = v6;
  if (a1[424])
  {
    uint64_t v9 = (char *)(*(void *)a1 + 48);
    uint64_t v10 = *(void *)a1 + 63;
    if (*(unsigned char *)(*(void *)a1 + 70))
    {
      if (a3)
      {
        uint64_t v11 = (long long *)(a1 + 473);
        uint64_t v12 = (long long *)(a1 + 457);
        uint64_t v13 = (long long *)(a1 + 425);
LABEL_15:
        uint64_t v23 = (long long *)(a1 + 408);
        uint64_t v24 = (char *)v10;
LABEL_19:
        sub_1001812C0(v23, v11, v12, v13, &v26, v24, v9, a2);
        return 0;
      }
      uint64_t v11 = (long long *)(a1 + 457);
      uint64_t v12 = (long long *)(a1 + 473);
      uint64_t v13 = (long long *)(a1 + 441);
    }
    else
    {
      if (a3)
      {
        uint64_t v11 = (long long *)(a1 + 457);
        uint64_t v12 = (long long *)(a1 + 473);
        uint64_t v13 = (long long *)(a1 + 441);
        goto LABEL_15;
      }
      uint64_t v11 = (long long *)(a1 + 473);
      uint64_t v12 = (long long *)(a1 + 457);
      uint64_t v13 = (long long *)(a1 + 425);
    }
    uint64_t v23 = (long long *)(a1 + 408);
    uint64_t v24 = v9;
    uint64_t v9 = (char *)v10;
    goto LABEL_19;
  }
  if (sub_100058654())
  {
    sub_100056E24((uint64_t)"LTK And MacKey are not generated, we have a problem.", v14, v15, v16, v17, v18, v19, v20, v25);
    uint64_t v21 = sub_100050B4C(0x43u);
    if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR)) {
      sub_100744F6C();
    }
  }
  return 4824;
}

uint64_t sub_1002408F8(uint64_t a1, long long *a2)
{
  char v62 = 4;
  long long v63 = *a2;
  if (sub_100197770(a1))
  {
    uint64_t v3 = sub_1001F0BBC(a1);
    if (v3)
    {
      uint64_t v4 = (uint64_t *)v3;
      int v5 = *(unsigned __int8 *)(a1 + 70);
      if ((*(unsigned char *)(v3 + 72) & *(unsigned char *)(v3 + 80) & 8) != 0)
      {
        if (v5 != 1)
        {
LABEL_7:
          if (!v5 && !sub_1001F11E4((uint64_t)v4, 35))
          {
            if (!sub_100058654()) {
              return 4823;
            }
            char v6 = sub_1001F10E8();
            sub_100056E24((uint64_t)"Central connection should be in SMP_STATE_PAIRING_SCONFIRM to send this command, current state is %s.", v7, v8, v9, v10, v11, v12, v13, (uint64_t)v6);
            uint64_t v14 = sub_100050B4C(0x43u);
            if (!os_log_type_enabled(v14, OS_LOG_TYPE_ERROR)) {
              return 4823;
            }
            goto LABEL_38;
          }
          goto LABEL_24;
        }
        if (sub_1001F11E4(v3, 36))
        {
          int v5 = *(unsigned __int8 *)(a1 + 70);
          goto LABEL_7;
        }
        if (!sub_100058654()) {
          return 4823;
        }
        long long v33 = sub_1001F10E8();
        sub_100056E24((uint64_t)"Peripheral connection should be in SMP_STATE_PAIRING_MRAND to send this command, current state is %s.", v34, v35, v36, v37, v38, v39, v40, (uint64_t)v33);
        uint64_t v41 = sub_100050B4C(0x43u);
        if (!os_log_type_enabled(v41, OS_LOG_TYPE_ERROR)) {
          return 4823;
        }
      }
      else
      {
        if (!*(unsigned char *)(a1 + 70))
        {
          if (!sub_1001F11E4(v3, 35))
          {
            if (!sub_100058654()) {
              return 4823;
            }
            uint64_t v51 = sub_1001F10E8();
            sub_100056E24((uint64_t)"Central connection should be in SMP_STATE_PAIRING_SCONFIRM to send this command, current state is %s.", v52, v53, v54, v55, v56, v57, v58, (uint64_t)v51);
            uint64_t v59 = sub_100050B4C(0x43u);
            if (!os_log_type_enabled(v59, OS_LOG_TYPE_ERROR)) {
              return 4823;
            }
            goto LABEL_38;
          }
          int v5 = *(unsigned __int8 *)(a1 + 70);
        }
        if (v5 != 1 || sub_1001F11E4((uint64_t)v4, 36))
        {
LABEL_24:
          uint64_t v23 = sub_1001F0C08(*v4, &v62, 0x11uLL, 1);
          if (v23)
          {
            sub_1001F0828((char *)v4, v23, 1);
          }
          else
          {
            if (*(unsigned char *)(a1 + 70)) {
              char v32 = 37;
            }
            else {
              char v32 = 36;
            }
            sub_1001F10F4((uint64_t)v4, v32);
          }
          return v23;
        }
        if (!sub_100058654()) {
          return 4823;
        }
        uint64_t v42 = sub_1001F10E8();
        sub_100056E24((uint64_t)"Peripheral connection should be in SMP_STATE_PAIRING_MRAND to send this command, current state is %s.", v43, v44, v45, v46, v47, v48, v49, (uint64_t)v42);
        uint64_t v50 = sub_100050B4C(0x43u);
        if (!os_log_type_enabled(v50, OS_LOG_TYPE_ERROR)) {
          return 4823;
        }
      }
    }
    else
    {
      if (!sub_100058654()) {
        return 4823;
      }
      sub_100056E24((uint64_t)"This device is not in a pairing state.", v24, v25, v26, v27, v28, v29, v30, v61);
      uint64_t v31 = sub_100050B4C(0x43u);
      if (!os_log_type_enabled(v31, OS_LOG_TYPE_ERROR)) {
        return 4823;
      }
    }
LABEL_38:
    sub_100744F6C();
    return 4823;
  }
  if (sub_100058654())
  {
    sub_100056E24((uint64_t)"This command is only available to LE devices.", v15, v16, v17, v18, v19, v20, v21, v61);
    uint64_t v22 = sub_100050B4C(0x43u);
    if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR)) {
      sub_100744F6C();
    }
  }
  return 4820;
}

void sub_100240BFC(char *a1)
{
  if ((a1[72] & a1[80] & 8) != 0) {
    char v1 = -10;
  }
  else {
    char v1 = -9;
  }
  if ((v1 & a1[74] & 0xF7) == (v1 & a1[75] & 0xF7)
    || (v1 & a1[74]) == 0)
  {
    if (*(unsigned char *)(*(void *)a1 + 70))
    {
      sub_1001F10F4((uint64_t)a1, 65);
    }
    else
    {
      sub_1001F10F4((uint64_t)a1, 67);
      sub_10023DDC0((uint64_t)a1);
      sub_10023DF48((uint64_t)a1);
    }
    sub_1001F0828(a1, 0, 1);
  }
}

uint64_t sub_100240CC0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if ((_BYTE)qword_100A102B8 || (qword_100A102B8 & 0x100) != 0) {
    return 118;
  }
  if (a1 < 0x28)
  {
    uint64_t v17 = sub_10001BDE0(189, (uint64_t)sub_100240DE0, a3, a4, a5, a6, a7, a8, a1);
    if (v17)
    {
      if (sub_100058654())
      {
        sub_100056E24((uint64_t)"Failed to start RX LE test %!", v19, v20, v21, v22, v23, v24, v25, v17);
        uint64_t v26 = sub_100050B4C(0x42u);
        if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR)) {
          sub_100744F6C();
        }
      }
    }
    else
    {
      BYTE2(qword_100A102B8) = a1;
      LOBYTE(qword_100A102B8) = 1;
    }
  }
  else
  {
    if (sub_100058654())
    {
      sub_100056E24((uint64_t)"Invalid test frequency %d", v9, v10, v11, v12, v13, v14, v15, a1);
      uint64_t v16 = sub_100050B4C(0x42u);
      if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR)) {
        sub_100744F6C();
      }
    }
    return 101;
  }
  return v17;
}

void sub_100240DE0(uint64_t a1)
{
  if (a1)
  {
    if (sub_100058654())
    {
      sub_100056E24((uint64_t)"Could not start RX test %!", v2, v3, v4, v5, v6, v7, v8, a1);
      uint64_t v9 = sub_100050B4C(0x42u);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR)) {
        sub_100744F6C();
      }
    }
  }
  else
  {
    BYTE1(qword_100A102B8) |= 1u;
  }
  LOBYTE(qword_100A102B8) = 0;
}

uint64_t sub_100240E68(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if ((_BYTE)qword_100A102B8 || (qword_100A102B8 & 0x200) != 0) {
    return 118;
  }
  if (a1 >= 0x28)
  {
    if (!sub_100058654()) {
      return 101;
    }
    sub_100056E24((uint64_t)"Invalid test frequency %d", v9, v10, v11, v12, v13, v14, v15, a1);
    uint64_t v16 = sub_100050B4C(0x42u);
    if (!os_log_type_enabled(v16, OS_LOG_TYPE_ERROR)) {
      return 101;
    }
    goto LABEL_16;
  }
  if (a2 >= 0x26)
  {
    if (!sub_100058654()) {
      return 101;
    }
    sub_100056E24((uint64_t)"Invalid payload length %d", v20, v21, v22, v23, v24, v25, v26, a2);
    uint64_t v27 = sub_100050B4C(0x42u);
    if (!os_log_type_enabled(v27, OS_LOG_TYPE_ERROR)) {
      return 101;
    }
    goto LABEL_16;
  }
  if (a3 >= 8)
  {
    if (!sub_100058654()) {
      return 101;
    }
    sub_100056E24((uint64_t)"Invalid payload type %d", v29, v30, v31, v32, v33, v34, v35, a3);
    uint64_t v36 = sub_100050B4C(0x42u);
    if (!os_log_type_enabled(v36, OS_LOG_TYPE_ERROR)) {
      return 101;
    }
LABEL_16:
    sub_100744F6C();
    return 101;
  }
  uint64_t v17 = sub_10001BDE0(190, (uint64_t)sub_100241044, a3, a4, a5, a6, a7, a8, a1);
  if (v17)
  {
    if (sub_100058654())
    {
      sub_100056E24((uint64_t)"Failed to start TX LE test %!", v37, v38, v39, v40, v41, v42, v43, v17);
      uint64_t v44 = sub_100050B4C(0x42u);
      if (os_log_type_enabled(v44, OS_LOG_TYPE_ERROR)) {
        sub_100744F6C();
      }
    }
  }
  else
  {
    BYTE3(qword_100A102B8) = a1;
    BYTE4(qword_100A102B8) = a2;
    BYTE5(qword_100A102B8) = a3;
    LOBYTE(qword_100A102B8) = 1;
  }
  return v17;
}

void sub_100241044(uint64_t a1)
{
  if (a1)
  {
    if (sub_100058654())
    {
      sub_100056E24((uint64_t)"Could not start TX test %!", v2, v3, v4, v5, v6, v7, v8, a1);
      uint64_t v9 = sub_100050B4C(0x42u);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR)) {
        sub_100744F6C();
      }
    }
  }
  else
  {
    BYTE1(qword_100A102B8) |= 2u;
  }
  LOBYTE(qword_100A102B8) = 0;
}

uint64_t sub_1002410CC(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (BYTE1(qword_100A102B8))
  {
    uint64_t v9 = sub_10001BDE0(191, (uint64_t)sub_1002411C4, a3, a4, a5, a6, a7, a8, v27);
    if (v9)
    {
      if (sub_100058654())
      {
        sub_100056E24((uint64_t)"Failed to stop LE test %!", v10, v11, v12, v13, v14, v15, v16, v9);
        uint64_t v17 = sub_100050B4C(0x42u);
        if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR)) {
          sub_100744F6C();
        }
      }
    }
    else
    {
      LOBYTE(qword_100A102B8) = 1;
      off_100A102C0 = a1;
    }
  }
  else
  {
    if (sub_100058654())
    {
      sub_100056E24((uint64_t)"No test started", v18, v19, v20, v21, v22, v23, v24, v27);
      uint64_t v25 = sub_100050B4C(0x42u);
      if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR)) {
        sub_100744F6C();
      }
    }
    return 114;
  }
  return v9;
}

void sub_1002411C4(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (void (*)(uint64_t, uint64_t))off_100A102C0;
  if (a1)
  {
    if (sub_100058654())
    {
      sub_100056E24((uint64_t)"Could not stop the test %!", v5, v6, v7, v8, v9, v10, v11, a1);
      uint64_t v12 = sub_100050B4C(0x42u);
      if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR)) {
        sub_100744F6C();
      }
    }
  }
  else
  {
    qword_100A102B8 = 0;
    off_100A102C0 = 0;
  }
  LOBYTE(qword_100A102B8) = 0;
  if (v4) {
    v4(a1, a2);
  }
}

void sub_10024126C()
{
  qword_100A102B8 = 0;
  off_100A102C0 = 0;
}

uint64_t sub_10024127C(uint64_t a1)
{
  __int16 v1 = word_100A102C8;
  uint64_t v2 = (unsigned __int16)word_100A102C8;
  if (word_100A102C8)
  {
    if (word_100A102C8 == 8)
    {
      if (sub_100058654())
      {
        sub_100056E24((uint64_t)"Can't add anymore callbacks.", v3, v4, v5, v6, v7, v8, v9, v14);
        uint64_t v10 = sub_100050B4C(0x42u);
        if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR)) {
          sub_100744F6C();
        }
      }
      return 4150;
    }
    else
    {
      unsigned __int8 v12 = 0;
      while (qword_100A102D0[v12] != a1)
      {
        if ((unsigned __int16)word_100A102C8 <= ++v12)
        {
          uint64_t v2 = v12;
          goto LABEL_11;
        }
      }
      return 0;
    }
  }
  else
  {
LABEL_11:
    uint64_t v11 = 0;
    qword_100A102D0[v2] = a1;
    word_100A102C8 = v1 + 1;
  }
  return v11;
}

uint64_t sub_100241348(unsigned __int8 *a1)
{
  if (!*((void *)&xmmword_100A10310 + 1)) {
    return 118;
  }
  if ((unsigned __int16)xmmword_100A10310 <= BYTE2(xmmword_100A10310))
  {
    if (sub_100058654())
    {
      sub_100056E24((uint64_t)"No room in filter accept list %d (+%d pending)/%d.", v3, v4, v5, v6, v7, v8, v9, BYTE2(xmmword_100A10310));
      uint64_t v10 = sub_100050B4C(0x42u);
      if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR)) {
        sub_100744F6C();
      }
    }
    return 104;
  }
  else if (sub_1002414F4(a1))
  {
    return 4152;
  }
  else
  {
    unsigned __int8 v12 = sub_100022FE8(0x10uLL);
    if (v12)
    {
      uint64_t v19 = v12;
      uint64_t v20 = sub_10001BDE0(177, (uint64_t)sub_100241578, v13, v14, v15, v16, v17, v18, *a1);
      if (v20)
      {
        uint64_t v2 = v20;
        if (sub_100058654())
        {
          sub_100056E24((uint64_t)"Could not add device to filter accept list %!", v21, v22, v23, v24, v25, v26, v27, v2);
          uint64_t v28 = sub_100050B4C(0x42u);
          if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR)) {
            sub_100744F6C();
          }
        }
        sub_100023010(v19);
      }
      else
      {
        int v29 = *(_DWORD *)a1;
        __int16 v30 = *((_WORD *)a1 + 2);
        *((unsigned char *)v19 + 6) = a1[6];
        *((_WORD *)v19 + 2) = v30;
        *uint64_t v19 = v29;
        *((void *)v19 + 1) = 0;
        if (qword_100A10328)
        {
          *(void *)(qword_100A10328 + 8) = v19;
          qword_100A10328 = (uint64_t)v19;
        }
        uint64_t v2 = 0;
        if (!qword_100A10320)
        {
          qword_100A10320 = (uint64_t)v19;
          qword_100A10328 = (uint64_t)v19;
        }
      }
    }
    else
    {
      return 106;
    }
  }
  return v2;
}

BOOL sub_1002414F4(_DWORD *a1)
{
  if (!BYTE2(xmmword_100A10310)) {
    return 0;
  }
  if (**((_DWORD **)&xmmword_100A10310 + 1) == *a1
    && *(_DWORD *)(*((void *)&xmmword_100A10310 + 1) + 3) == *(_DWORD *)((char *)a1 + 3))
  {
    return 1;
  }
  uint64_t v2 = (_DWORD *)(*((void *)&xmmword_100A10310 + 1) + 7);
  uint64_t v3 = 1;
  do
  {
    unint64_t v4 = v3;
    if (BYTE2(xmmword_100A10310) == v3) {
      break;
    }
    BOOL v5 = *v2 == *a1 && *(_DWORD *)((char *)v2 + 3) == *(_DWORD *)((char *)a1 + 3);
    ++v3;
    uint64_t v2 = (_DWORD *)((char *)v2 + 7);
  }
  while (!v5);
  return v4 < BYTE2(xmmword_100A10310);
}

uint64_t sub_100241578(uint64_t a1)
{
  if (a1)
  {
    if (sub_100058654())
    {
      sub_100056E24((uint64_t)"Error adding device to filter accept list %!", v19, v20, v21, v22, v23, v24, v25, a1);
      uint64_t v26 = sub_100050B4C(0x42u);
      if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR)) {
        sub_1007456E8();
      }
    }
    sub_10010B844(a1, "Filter Accept List add error");
  }
  uint64_t v1 = qword_100A10320;
  if (qword_100A10320 || (sub_10025B8C0(), (uint64_t v1 = qword_100A10320) != 0))
  {
    char v2 = BYTE2(xmmword_100A10310);
    uint64_t v3 = *((void *)&xmmword_100A10310 + 1) - BYTE2(xmmword_100A10310) + 8 * BYTE2(xmmword_100A10310);
    int v4 = *(_DWORD *)v1;
    __int16 v5 = *(_WORD *)(v1 + 4);
    *(unsigned char *)(v3 + 6) = *(unsigned char *)(v1 + 6);
    *(_WORD *)(v3 + 4) = v5;
    *(_DWORD *)uint64_t v3 = v4;
    BYTE2(xmmword_100A10310) = v2 + 1;
  }
  unsigned int v6 = (unsigned __int16)word_100A102C8;
  if (word_100A102C8)
  {
    unint64_t v7 = 0;
    uint64_t v8 = qword_100A10320;
    do
    {
      uint64_t v9 = *(void (**)(uint64_t, void))qword_100A102D0[v7];
      if (v9) {
        BOOL v10 = v8 == 0;
      }
      else {
        BOOL v10 = 1;
      }
      if (!v10)
      {
        v9(v8, 0);
        uint64_t v8 = qword_100A10320;
        unsigned int v6 = (unsigned __int16)word_100A102C8;
      }
      ++v7;
    }
    while (v7 < v6);
  }
  sub_100241C70();
  sub_100218E58(1, v11, v12, v13, v14, v15, v16, v17);
  sub_10020A1C0(1);

  return sub_100232068(1);
}

uint64_t sub_1002416C4(unsigned __int8 *a1)
{
  if (!*((void *)&xmmword_100A10310 + 1)) {
    return 118;
  }
  if (!sub_1002414F4(a1)) {
    return 4151;
  }
  char v2 = sub_100022FE8(0x10uLL);
  if (!v2) {
    return 106;
  }
  uint64_t v9 = v2;
  uint64_t v10 = sub_10001BDE0(178, (uint64_t)sub_100241804, v3, v4, v5, v6, v7, v8, *a1);
  if (v10)
  {
    uint64_t v11 = v10;
    if (sub_100058654())
    {
      sub_100056E24((uint64_t)"Could not remove device from filter accept list %!", v12, v13, v14, v15, v16, v17, v18, v11);
      uint64_t v19 = sub_100050B4C(0x42u);
      if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR)) {
        sub_100744F6C();
      }
    }
    sub_100023010(v9);
  }
  else
  {
    int v20 = *(_DWORD *)a1;
    __int16 v21 = *((_WORD *)a1 + 2);
    *((unsigned char *)v9 + 6) = a1[6];
    *((_WORD *)v9 + 2) = v21;
    *uint64_t v9 = v20;
    *((void *)v9 + 1) = 0;
    if (qword_100A10328)
    {
      *(void *)(qword_100A10328 + 8) = v9;
      qword_100A10328 = (uint64_t)v9;
    }
    uint64_t v11 = 0;
    if (!qword_100A10320)
    {
      qword_100A10320 = (uint64_t)v9;
      qword_100A10328 = (uint64_t)v9;
    }
  }
  return v11;
}

uint64_t sub_100241804(uint64_t a1)
{
  if (a1)
  {
    if (sub_100058654())
    {
      sub_100056E24((uint64_t)"Error removing device from filter accept list %!", v31, v32, v33, v34, v35, v36, v37, a1);
      uint64_t v38 = sub_100050B4C(0x42u);
      if (os_log_type_enabled(v38, OS_LOG_TYPE_ERROR)) {
        sub_1007456E8();
      }
    }
    sub_10010B844(a1, "Filter Accept List remove error");
  }
  if (!qword_100A10320) {
    sub_10025B8C0();
  }
  if (BYTE2(xmmword_100A10310))
  {
    uint64_t v1 = 0;
    uint64_t v2 = *((void *)&xmmword_100A10310 + 1);
    while (1)
    {
      uint64_t v3 = *((void *)&xmmword_100A10310 + 1) + v1;
      if (*(_DWORD *)(*((void *)&xmmword_100A10310 + 1) + v1) == *(_DWORD *)qword_100A10320
        && *(_DWORD *)(*((void *)&xmmword_100A10310 + 1) + v1 + 3) == *(_DWORD *)(qword_100A10320 + 3))
      {
        break;
      }
      v1 += 7;
      if (7 * BYTE2(xmmword_100A10310) == v1) {
        goto LABEL_11;
      }
    }
    unsigned __int8 v13 = --BYTE2(xmmword_100A10310);
    if (7 * BYTE2(xmmword_100A10310) != v1)
    {
      uint64_t v14 = *((void *)&xmmword_100A10310 + 1) - BYTE2(xmmword_100A10310) + 8 * BYTE2(xmmword_100A10310);
      int v15 = *(_DWORD *)v14;
      __int16 v16 = *(_WORD *)(v14 + 4);
      *(unsigned char *)(v3 + 6) = *(unsigned char *)(v14 + 6);
      *(_WORD *)(v3 + 4) = v16;
      *(_DWORD *)uint64_t v3 = v15;
      uint64_t v2 = *((void *)&xmmword_100A10310 + 1);
      unsigned __int8 v13 = BYTE2(xmmword_100A10310);
    }
    uint64_t v17 = (_DWORD *)(v2 - v13 + 8 * v13);
    *(_DWORD *)((char *)v17 + 3) = 0;
    *uint64_t v17 = 0;
  }
  else
  {
LABEL_11:
    if (sub_100058654())
    {
      sub_100056E24((uint64_t)"Device is not in the list anymore", v5, v6, v7, v8, v9, v10, v11, v39);
      uint64_t v12 = sub_100050B4C(0x42u);
      if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR)) {
        sub_100744F6C();
      }
    }
  }
  unsigned int v18 = (unsigned __int16)word_100A102C8;
  if (word_100A102C8)
  {
    unint64_t v19 = 0;
    uint64_t v20 = qword_100A10320;
    do
    {
      __int16 v21 = *(void (**)(uint64_t, void))(qword_100A102D0[v19] + 8);
      if (v21) {
        BOOL v22 = v20 == 0;
      }
      else {
        BOOL v22 = 1;
      }
      if (!v22)
      {
        v21(v20, 0);
        uint64_t v20 = qword_100A10320;
        unsigned int v18 = (unsigned __int16)word_100A102C8;
      }
      ++v19;
    }
    while (v19 < v18);
  }
  sub_100241C70();
  sub_100218E58(1, v23, v24, v25, v26, v27, v28, v29);
  sub_10020A1C0(1);
  return sub_100232068(1);
}

uint64_t sub_1002419F0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!*((void *)&xmmword_100A10310 + 1)) {
    return 118;
  }
  uint64_t v8 = sub_10001BDE0(176, (uint64_t)sub_100241A8C, a3, a4, a5, a6, a7, a8, v18);
  if (v8)
  {
    if (sub_100058654())
    {
      sub_100056E24((uint64_t)"Could not remove device from filter accept list %!", v9, v10, v11, v12, v13, v14, v15, v8);
      __int16 v16 = sub_100050B4C(0x42u);
      if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR)) {
        sub_100744F6C();
      }
    }
  }
  return v8;
}

uint64_t sub_100241A8C(uint64_t a1)
{
  if (a1)
  {
    if (sub_100058654())
    {
      sub_100056E24((uint64_t)"Error clearing filter accept list %!", v9, v10, v11, v12, v13, v14, v15, a1);
      __int16 v16 = sub_100050B4C(0x42u);
      if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR)) {
        sub_1007456E8();
      }
    }
    sub_10010B844(a1, "Filter Accept List clear error");
  }
  bzero(*((void **)&xmmword_100A10310 + 1), 7 * (unsigned __int16)xmmword_100A10310);
  BYTE2(xmmword_100A10310) = 0;
  sub_100218E58(1, v1, v2, v3, v4, v5, v6, v7);
  sub_10020A1C0(1);

  return sub_100232068(1);
}

uint64_t sub_100241B50()
{
  return (unsigned __int16)xmmword_100A10310;
}

uint64_t sub_100241B5C(_DWORD *a1)
{
  *a1 = BYTE2(xmmword_100A10310);
  return *((void *)&xmmword_100A10310 + 1);
}

uint64_t sub_100241B74(int *a1)
{
  if (sub_1002414F4(a1)) {
    return 4152;
  }
  uint64_t result = 0;
  char v3 = BYTE2(xmmword_100A10310);
  uint64_t v4 = *((void *)&xmmword_100A10310 + 1) - BYTE2(xmmword_100A10310) + 8 * BYTE2(xmmword_100A10310);
  int v5 = *a1;
  __int16 v6 = *((_WORD *)a1 + 2);
  *(unsigned char *)(v4 + 6) = *((unsigned char *)a1 + 6);
  *(_WORD *)(v4 + 4) = v6;
  *(_DWORD *)uint64_t v4 = v5;
  BYTE2(xmmword_100A10310) = v3 + 1;
  return result;
}

void *sub_100241BE0(unsigned int a1)
{
  LOWORD(xmmword_100A10310) = a1;
  if (*((void *)&xmmword_100A10310 + 1)) {
    sub_100023010(*((void **)&xmmword_100A10310 + 1));
  }
  uint64_t result = sub_100022FE8(7 * a1);
  *((void *)&xmmword_100A10310 + 1) = result;
  BYTE2(xmmword_100A10310) = 0;
  qword_100A10328 = 0;
  qword_100A10320 = 0;
  return result;
}

double sub_100241C3C()
{
  if (*((void *)&xmmword_100A10310 + 1)) {
    sub_100023010(*((void **)&xmmword_100A10310 + 1));
  }
  double result = 0.0;
  xmmword_100A10310 = 0u;
  *(_OWORD *)&qword_100A10320 = 0u;
  return result;
}

void sub_100241C70()
{
  if (qword_100A10320)
  {
    uint64_t v0 = *(void *)(qword_100A10320 + 8);
    sub_100023010((void *)qword_100A10320);
    qword_100A10320 = v0;
    if (!v0) {
      qword_100A10328 = 0;
    }
  }
  else
  {
    sub_10025B8C0();
  }
}

uint64_t sub_100241CCC(uint64_t a1)
{
  if (qword_100A10330) {
    return 119;
  }
  uint64_t v4 = sub_100022FE8(0x18uLL);
  qword_100A10330 = (uint64_t)v4;
  if (!v4) {
    return 106;
  }
  uint64_t v1 = sub_1001DEA28(0x2Au, 2, 10, 0xAu, v4, (uint64_t)sub_100241DBC);
  if (v1)
  {
    sub_100023010((void *)qword_100A10330);
    qword_100A10330 = 0;
    return v1;
  }
  if (!sub_1001DEA28(0x2Bu, 2, 10, 0xAu, (void *)(qword_100A10330 + 8), (uint64_t)sub_1002420EC))
  {
    uint64_t v1 = 0;
    *(void *)(qword_100A10330 + 16) = a1;
    return v1;
  }
  uint64_t v5 = sub_1001DEC18(*(void *)qword_100A10330);
  sub_100023010((void *)qword_100A10330);
  qword_100A10330 = 0;
  return v5;
}

void sub_100241DBC(uint64_t a1, unsigned char *a2, int a3)
{
  if (!a2)
  {
    uint64_t v24 = "buf";
    goto LABEL_40;
  }
  if (!a3)
  {
    uint64_t v24 = "(length) > 0";
LABEL_40:
    sub_10014327C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LEA.c", 425, v24);
  }
  uint64_t v25 = a2;
  __int16 v26 = a3;
  __int16 v27 = a3;
  int v28 = 65537;
  uint64_t v4 = *a2;
  switch(*a2)
  {
    case 1:
      uint64_t v5 = sub_100242D70(a1, (uint64_t)&v25);
      goto LABEL_32;
    case 2:
      uint64_t v5 = sub_10024306C(a1, (uint64_t *)&v25);
      goto LABEL_32;
    case 3:
      uint64_t v5 = sub_100243290(a1, (uint64_t *)&v25);
      goto LABEL_32;
    case 4:
      uint64_t v5 = sub_1002434DC(a1, (uint64_t)&v25);
      goto LABEL_32;
    case 5:
      uint64_t v5 = sub_1002435E4(a1, (uint64_t *)&v25);
      goto LABEL_32;
    case 6:
      __int16 v6 = *(void (**)(uint64_t))(*(void *)(qword_100A10330 + 16) + 40);
      if (v6) {
        goto LABEL_24;
      }
      uint64_t v7 = 3;
      goto LABEL_33;
    case 7:
      uint64_t v5 = sub_100243754(a1, (uint64_t)&v25);
      goto LABEL_32;
    case 8:
      sub_1002437E8(a1, (uint64_t *)&v25);
      return;
    case 9:
      __int16 v6 = *(void (**)(uint64_t))(*(void *)(qword_100A10330 + 16) + 64);
LABEL_24:
      v6(a1);
      return;
    case 0xA:
      uint64_t v5 = sub_10024394C(a1, (uint64_t *)&v25);
      goto LABEL_32;
    case 0xC:
      uint64_t v5 = sub_100243A44(a1, (uint64_t *)&v25);
      goto LABEL_32;
    case 0xD:
      (*(void (**)(uint64_t))(*(void *)(qword_100A10330 + 16) + 88))(a1);
      return;
    case 0xE:
      uint64_t v5 = sub_100243BA0(a1, (uint64_t *)&v25);
      goto LABEL_32;
    case 0xF:
      uint64_t v5 = sub_100243C9C(a1, (uint64_t *)&v25);
      goto LABEL_32;
    case 0x10:
      uint64_t v5 = sub_100243E00(a1, (uint64_t *)&v25);
      goto LABEL_32;
    case 0x11:
      uint64_t v5 = sub_100243FA0(a1, (uint64_t *)&v25);
      goto LABEL_32;
    case 0x12:
      uint64_t v5 = sub_10024409C(a1, (uint64_t *)&v25);
      goto LABEL_32;
    case 0x13:
      uint64_t v5 = sub_1002442FC(a1, (uint64_t)&v25);
      goto LABEL_32;
    case 0x14:
      uint64_t v5 = sub_1002444F8(a1, (uint64_t)&v25);
      goto LABEL_32;
    case 0x15:
      uint64_t v5 = sub_1002446F4(a1, (uint64_t)&v25);
      goto LABEL_32;
    case 0x16:
      uint64_t v5 = sub_1002448A4(a1, (uint64_t *)&v25);
LABEL_32:
      uint64_t v7 = v5;
      if (v5) {
        goto LABEL_33;
      }
      return;
    default:
      if (sub_100058654())
      {
        sub_100056E24((uint64_t)"Unhandled opcode: %u", v8, v9, v10, v11, v12, v13, v14, v4);
        uint64_t v15 = sub_100050B4C(0x42u);
        if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR)) {
          sub_100744F6C();
        }
      }
      uint64_t v7 = 1;
LABEL_33:
      if (sub_100058654())
      {
        sub_100056E24((uint64_t)"Sending error %u", v16, v17, v18, v19, v20, v21, v22, v7);
        uint64_t v23 = sub_100050B4C(0x42u);
        if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR)) {
          sub_100744F6C();
        }
      }
      v29[0] = v4;
      v29[1] = v7;
      v29[2] = 0;
      sub_1002421F8(a1, 8u, v29, 3uLL);
      return;
  }
}

uint64_t sub_1002420EC()
{
  uint64_t v0 = *(uint64_t (**)(void))(*(void *)(qword_100A10330 + 16) + 96);
  if (v0) {
    return v0();
  }
  return result;
}

uint64_t sub_100242108()
{
  if (!qword_100A10330) {
    return 121;
  }
  uint64_t result = sub_1001DEC18(*(void *)(qword_100A10330 + 8));
  if (!result)
  {
    uint64_t result = sub_1001DEC18(*(void *)qword_100A10330);
    if (!result)
    {
      sub_100023010((void *)qword_100A10330);
      uint64_t result = 0;
      qword_100A10330 = 0;
    }
  }
  return result;
}

uint64_t sub_100242164(uint64_t a1, __int16 a2, __int16 a3, __int16 a4, __int16 a5)
{
  int v6 = 1346454860;
  __int16 v7 = a2;
  __int16 v8 = a3;
  __int16 v9 = a4;
  __int16 v10 = a5;
  return sub_1002421F8(a1, 1u, (char *)&v6, 0xCuLL);
}

uint64_t sub_1002421F8(uint64_t a1, unsigned __int8 a2, char *a3, size_t a4)
{
  unsigned __int8 v21 = a2;
  if (!a1)
  {
    uint64_t v9 = 1310;
    goto LABEL_10;
  }
  memset(&v20[1], 0, 96);
  if (a3) {
    unsigned int v7 = 2;
  }
  else {
    unsigned int v7 = 1;
  }
  v20[0] = 0uLL;
  uint64_t v8 = sub_1000226D0((uint64_t)v20, v7);
  if (v8)
  {
    uint64_t v9 = v8;
LABEL_10:
    if (sub_100058654())
    {
      sub_100056E24((uint64_t)"Failed to send PDU %u: %!", v11, v12, v13, v14, v15, v16, v17, v21);
      uint64_t v18 = sub_100050B4C(0x42u);
      if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR)) {
        sub_100744F6C();
      }
    }
    return v9;
  }
  uint64_t v10 = sub_100022798((unsigned __int8 *)v20, (char *)&v21, 1uLL, 0);
  if (v10)
  {
    uint64_t v9 = v10;
    sub_10025C480((uint64_t)v20);
    goto LABEL_10;
  }
  if (!a3 || (uint64_t v9 = sub_100022798((unsigned __int8 *)v20, a3, a4, 2u), !v9)) {
    uint64_t v9 = ((uint64_t (*)(void, uint64_t, uint64_t, _OWORD *, uint64_t))loc_1001DE1A4)(0, 42, a1, v20, 1);
  }
  sub_10025C480((uint64_t)v20);
  uint64_t result = 0;
  if (v9 && v9 != 412) {
    goto LABEL_10;
  }
  return result;
}

uint64_t sub_10024233C(uint64_t a1, char a2, char a3, char a4, char a5)
{
  v6[0] = a2;
  v6[1] = a3;
  v6[2] = a4;
  v6[3] = a5;
  return sub_1002421F8(a1, 3u, v6, 4uLL);
}

uint64_t sub_100242378(uint64_t a1, int a2, int a3, __int16 a4, char a5)
{
  int v9 = a4;
  BYTE1(v9) = HIBYTE(a4);
  BYTE2(v9) = a3 == 2;
  *(_WORD *)(a1 + 127) = 257;
  *(unsigned char *)(a1 + 129) = a5;
  if (a2) {
    size_t v6 = 4;
  }
  else {
    size_t v6 = 2;
  }
  uint64_t v7 = sub_1002421F8(a1, 5u, (char *)&v9, v6);
  if (!v7) {
    sub_100219B7C((unsigned __int16 *)a1, 5);
  }
  return v7;
}

uint64_t sub_1002423FC(uint64_t a1)
{
  uint64_t v2 = sub_1002421F8(a1, 6u, 0, 0);
  if (!v2)
  {
    *(unsigned char *)(a1 + 128) = 0;
    sub_100219B7C((unsigned __int16 *)a1, 6);
  }
  return v2;
}

uint64_t sub_100242448(uint64_t a1, char *a2, unsigned __int8 a3)
{
  return sub_1002421F8(a1, 7u, a2, a3);
}

uint64_t sub_10024245C(uint64_t a1, char a2, __int16 a3)
{
  char v4 = a2;
  __int16 v5 = a3;
  return sub_1002421F8(a1, 8u, &v4, 3uLL);
}

uint64_t sub_100242498(uint64_t a1, char a2)
{
  char v3 = a2;
  return sub_1002421F8(a1, 0xAu, &v3, 1uLL);
}

uint64_t sub_1002424C8(uint64_t a1, uint64_t a2, char a3)
{
  *(_DWORD *)&v6[3] = 0;
  *(_DWORD *)size_t v6 = 0;
  sub_100008A18((uint64_t)v6, a2, 6uLL);
  v6[6] = a3;
  return sub_1002421F8(a1, 0x10u, v6, 7uLL);
}

uint64_t sub_100242520(uint64_t a1, uint64_t a2, __int16 a3, uint64_t *a4)
{
  uint64_t v8 = 0;
  uint64_t v9 = 0;
  sub_100008A18((uint64_t)&v8, a2, 6uLL);
  HIWORD(v8) = a3;
  uint64_t v9 = *a4;
  return sub_1002421F8(a1, 0x12u, (char *)&v8, 0x10uLL);
}

uint64_t sub_1002425B4(uint64_t a1, uint64_t a2, _OWORD *a3)
{
  memset(v6, 0, 22);
  sub_100008A18((uint64_t)v6, a2, 6uLL);
  *(_OWORD *)&v6[6] = *a3;
  return sub_1002421F8(a1, 0x13u, v6, 0x16uLL);
}

uint64_t sub_10024263C(uint64_t a1, uint64_t a2, _OWORD *a3)
{
  memset(v6, 0, 22);
  sub_100008A18((uint64_t)v6, a2, 6uLL);
  *(_OWORD *)&v6[6] = *a3;
  return sub_1002421F8(a1, 0x14u, v6, 0x16uLL);
}

BOOL sub_1002426C4(uint64_t a1)
{
  unsigned int v2 = 10 - sub_1001F4460(43);
  if (v2 < a1)
  {
    if (sub_100058654())
    {
      sub_1001F4460(43);
      sub_100056E24((uint64_t)"LEA Queue full: request buffers %d, queue-size %d", v3, v4, v5, v6, v7, v8, v9, a1);
      uint64_t v10 = sub_100050B4C(0x42u);
      if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR)) {
        sub_1007456E8();
      }
    }
  }
  sub_1001F355C();
  return v2 >= a1;
}

uint64_t sub_100242768(_WORD *a1, char *a2, size_t a3, char a4, int a5)
{
  char v32 = a4;
  if (a1 && sub_100197770((uint64_t)a1))
  {
    if (a5) {
      int v9 = 412;
    }
    else {
      int v9 = 625;
    }
    if (sub_1001F7D74()) {
      BOOL v10 = sub_1001F7D74() < 0x7D0;
    }
    else {
      BOOL v10 = 0;
    }
    memset(v31, 0, sizeof(v31));
    uint64_t v19 = sub_1000226D0((uint64_t)v31, 2u);
    if (!v19)
    {
      uint64_t v19 = sub_100022798((unsigned __int8 *)v31, a2, a3, 2u);
      if (!v19)
      {
        if (!v10 || (uint64_t v19 = sub_100022798((unsigned __int8 *)v31, &v32, 1uLL, 0), !v19))
        {
          if (a5) {
            uint64_t v21 = ((uint64_t (*)(void, uint64_t, _WORD *, _OWORD *, uint64_t))loc_1001DE1A4)(0, 43, a1, v31, 1);
          }
          else {
            uint64_t v21 = sub_10019DE9C(a1, (uint64_t)v31, WORD2(v31[0]));
          }
          uint64_t v19 = v21;
        }
      }
      sub_10025C480((uint64_t)v31);
    }
    if (v19 != v9)
    {
      if (v19)
      {
        if (sub_100058654())
        {
          sub_100056E24((uint64_t)"Failed to send audio: %!", v22, v23, v24, v25, v26, v27, v28, v19);
          uint64_t v29 = sub_100050B4C(0x42u);
          if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR)) {
            sub_100744F6C();
          }
        }
      }
    }
  }
  else
  {
    if (sub_100058654())
    {
      sub_100056E24((uint64_t)"Failed to send audio as handle is invalid", v11, v12, v13, v14, v15, v16, v17, v30);
      uint64_t v18 = sub_100050B4C(0x42u);
      if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR)) {
        sub_100744F6C();
      }
    }
    return 1310;
  }
  return v19;
}

void sub_100242928()
{
}

uint64_t sub_100242930(uint64_t a1, unsigned int a2, int a3)
{
  if (!a1) {
    return 1310;
  }
  if (a3 == 2) {
    int v3 = 4;
  }
  else {
    int v3 = 2;
  }
  return sub_10021A718(a1, a2, a2, 0, 300, v3, v3);
}

BOOL sub_100242960(unsigned __int16 *a1, int a2, int a3)
{
  if (a3 == 2) {
    int v3 = 4;
  }
  else {
    int v3 = 2;
  }
  return sub_10021C824(a1, a2, v3, v3);
}

uint64_t sub_100242978(uint64_t a1)
{
  if (!a1 || !sub_100197770(a1)) {
    return 1310;
  }
  if (*(_DWORD *)(a1 + 132) <= 4u)
  {
    if (sub_100058654())
    {
      sub_100056E24((uint64_t)"Disconnecting LEA device before it is ready, tell the upper layer we failed", v2, v3, v4, v5, v6, v7, v8, *(uint64_t *)v11);
      int v9 = sub_100050B4C(0x42u);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)uint64_t v11 = 136446210;
        *(void *)&v11[4] = sub_100050714();
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, " %{public}s", v11, 0xCu);
      }
    }
    *(_DWORD *)(a1 + 132) = 6;
    *(_DWORD *)(a1 + 140) = 5300;
  }
  return sub_1002189B4(a1);
}

uint64_t sub_100242A74(uint64_t a1)
{
  uint64_t result = sub_100234878(a1);
  if (result)
  {
    return sub_100234720(a1);
  }
  return result;
}

uint64_t sub_100242ABC(uint64_t a1)
{
  if (!a1 || !sub_100197770(a1)) {
    return 1310;
  }
  int v2 = *(_DWORD *)(a1 + 148);
  if (v2 == 2)
  {
    uint64_t v3 = 60;
  }
  else if (v2 == 1)
  {
    if (*(unsigned __int16 *)(a1 + 104) <= 0x3Cu && *(unsigned __int16 *)(a1 + 108) <= 0x3Cu) {
      return 0;
    }
    uint64_t v3 = 40;
  }
  else
  {
    uint64_t v3 = 0;
  }
  unsigned int v5 = *(unsigned __int16 *)(a1 + 104);
  if (v5 == v3 && *(unsigned __int16 *)(a1 + 108) == v3
    || v5 <= 0x1B && *(unsigned __int16 *)(a1 + 108) < 0x1Cu)
  {
    return 0;
  }
  if (sub_100058654())
  {
    sub_100056E24((uint64_t)"LEA set data length %dB %dus", v6, v7, v8, v9, v10, v11, v12, v3);
    uint64_t v13 = sub_100050B4C(0x42u);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 136446210;
      uint64_t v15 = sub_100050714();
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
    }
  }
  return sub_1001F9008(a1);
}

void sub_100242C64(uint64_t a1)
{
  if (sub_100058654())
  {
    sub_100056E24((uint64_t)"LEA setTxDataLengthExtendedCB %!", v2, v3, v4, v5, v6, v7, v8, a1);
    uint64_t v9 = sub_100050B4C(0x42u);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 136446210;
      uint64_t v19 = sub_100050714();
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
    }
  }
  if (a1 && sub_100058654())
  {
    sub_100056E24((uint64_t)"Set data length extended error status %!", v10, v11, v12, v13, v14, v15, v16, a1);
    uint64_t v17 = sub_100050B4C(0x42u);
    if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR)) {
      sub_1007456E8();
    }
  }
}

uint64_t sub_100242D70(uint64_t a1, uint64_t a2)
{
  if (*(unsigned char *)(a2 + 14) != 1) {
    sub_10014327C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LEA.c", 48, "(*bs).__RWFlag == BYTESTREAM_READ");
  }
  if (*(unsigned char *)(a2 + 15))
  {
    sub_10025A794((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LEA.c");
    int v3 = *(unsigned __int8 *)(a2 + 14);
    *(unsigned char *)(a2 + 15) = 1;
    if (v3 != 1) {
      sub_10014327C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LEA.c", 49, "(*bs).__RWFlag == BYTESTREAM_READ");
    }
    goto LABEL_14;
  }
  uint64_t v4 = *(unsigned __int16 *)(a2 + 12);
  if (*(unsigned __int16 *)(a2 + 10) - (int)v4 <= 3)
  {
    *(unsigned char *)(a2 + 15) = 1;
LABEL_14:
    sub_10025A794((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LEA.c");
    int v14 = *(unsigned __int8 *)(a2 + 14);
    *(unsigned char *)(a2 + 15) = 1;
    if (v14 != 1) {
      sub_10014327C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LEA.c", 50, "(*bs).__RWFlag == BYTESTREAM_READ");
    }
    goto LABEL_15;
  }
  unsigned int v5 = *(_DWORD *)(*(void *)a2 + v4);
  *(_WORD *)(a2 + 12) = v4 + 4;
  if (*(unsigned __int16 *)(a2 + 10) - (unsigned __int16)(v4 + 4) <= 1)
  {
    *(unsigned char *)(a2 + 15) = 1;
LABEL_15:
    sub_10025A794((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LEA.c");
    int v15 = *(unsigned __int8 *)(a2 + 14);
    *(unsigned char *)(a2 + 15) = 1;
    if (v15 != 1) {
      sub_10014327C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LEA.c", 51, "(*bs).__RWFlag == BYTESTREAM_READ");
    }
    goto LABEL_16;
  }
  unsigned __int16 v6 = *(_WORD *)(*(void *)a2 + (unsigned __int16)(v4 + 4));
  *(_WORD *)(a2 + 12) = v4 + 6;
  if (*(unsigned __int16 *)(a2 + 10) - (unsigned __int16)(v4 + 6) <= 1)
  {
    *(unsigned char *)(a2 + 15) = 1;
LABEL_16:
    sub_10025A794((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LEA.c");
    int v16 = *(unsigned __int8 *)(a2 + 14);
    *(unsigned char *)(a2 + 15) = 1;
    if (v16 != 1) {
      sub_10014327C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LEA.c", 52, "(*bs).__RWFlag == BYTESTREAM_READ");
    }
    goto LABEL_17;
  }
  unsigned __int16 v7 = *(_WORD *)(*(void *)a2 + (unsigned __int16)(v4 + 6));
  *(_WORD *)(a2 + 12) = v4 + 8;
  if (*(unsigned __int16 *)(a2 + 10) - (unsigned __int16)(v4 + 8) <= 1)
  {
    *(unsigned char *)(a2 + 15) = 1;
LABEL_17:
    sub_10025A794((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LEA.c");
    goto LABEL_18;
  }
  unsigned __int16 v8 = *(_WORD *)(*(void *)a2 + (unsigned __int16)(v4 + 8));
  *(_WORD *)(a2 + 12) = v4 + 10;
  if (*(unsigned __int16 *)(a2 + 10) - (unsigned __int16)(v4 + 10) <= 1)
  {
LABEL_18:
    *(unsigned char *)(a2 + 15) = 1;
    goto LABEL_19;
  }
  unsigned int v9 = bswap32(v5);
  uint64_t v10 = (unsigned __int8 *)(*(void *)a2 + (unsigned __int16)(v4 + 10));
  int v11 = *v10;
  int v12 = v10[1];
  *(_WORD *)(a2 + 12) = v4 + 12;
  if (v9 == 1279607120 && (unsigned __int16)(v6 - 1) <= 1u)
  {
    (**(void (***)(uint64_t, void, void, void, void))(qword_100A10330 + 16))(a1, v6, v7, v8, v11 | (v12 << 8));
    return 0;
  }
LABEL_19:
  uint64_t v13 = 2;
  if (sub_100058654())
  {
    sub_100056E24((uint64_t)"Failed to read version", v17, v18, v19, v20, v21, v22, v23, v26);
    uint64_t v24 = sub_100050B4C(0x42u);
    if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR)) {
      sub_100744F6C();
    }
    return 2;
  }
  return v13;
}

uint64_t sub_10024306C(uint64_t a1, uint64_t *a2)
{
  if (!*(void *)(*(void *)(qword_100A10330 + 16) + 8)) {
    return 3;
  }
  if (*((unsigned char *)a2 + 15))
  {
    sub_10025A794((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LEA.c");
    unsigned __int8 v4 = 0;
  }
  else
  {
    unsigned __int8 v4 = *((unsigned char *)a2 + 10) - *((unsigned char *)a2 + 12);
  }
  __chkstk_darwin(a1, v4);
  unsigned __int16 v7 = (char *)&v25 - v6;
  bzero((char *)&v25 - v6, v8);
  if (*((unsigned char *)a2 + 14) != 1) {
    sub_10014327C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LEA.c", 72, "(*bs).__RWFlag == BYTESTREAM_READ");
  }
  uint64_t v9 = *a2;
  uint64_t v10 = *((unsigned __int16 *)a2 + 6);
  if (*((unsigned char *)a2 + 15))
  {
    sub_10025A794((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LEA.c");
    int v11 = 0;
  }
  else
  {
    int v11 = *((unsigned __int16 *)a2 + 5) - v10;
  }
  if (v11 >= v4)
  {
    if (v4)
    {
      int v12 = (char *)(v9 + v10);
      uint64_t v13 = v7;
      do
      {
        char v14 = *v12++;
        *v13++ = v14;
      }
      while (v13 < &v7[v4]);
    }
    *((_WORD *)a2 + 6) += v4;
    if (*((unsigned char *)a2 + 15)) {
      BOOL v15 = 1;
    }
    else {
      BOOL v15 = v4 == 0;
    }
    if (!v15)
    {
      (*(void (**)(uint64_t, char *, void))(*(void *)(qword_100A10330 + 16) + 8))(a1, v7, v4);
      return 0;
    }
  }
  else
  {
    *((unsigned char *)a2 + 15) = 1;
  }
  uint64_t v5 = 2;
  if (sub_100058654())
  {
    sub_100056E24((uint64_t)"Failed to read supported codec list", v16, v17, v18, v19, v20, v21, v22, v25);
    uint64_t v23 = sub_100050B4C(0x42u);
    if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR)) {
      sub_100744F6C();
    }
    return 2;
  }
  return v5;
}

uint64_t sub_100243290(uint64_t a1, uint64_t *a2)
{
  if (!*(void *)(*(void *)(qword_100A10330 + 16) + 16)) {
    return 3;
  }
  if (*((unsigned char *)a2 + 14) != 1) {
    sub_10014327C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LEA.c", 97, "(*bs).__RWFlag == BYTESTREAM_READ");
  }
  if (*((unsigned char *)a2 + 15))
  {
    sub_10025A794((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LEA.c");
    int v3 = *((unsigned __int8 *)a2 + 14);
    *((unsigned char *)a2 + 15) = 1;
    if (v3 != 1) {
      sub_10014327C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LEA.c", 98, "(*bs).__RWFlag == BYTESTREAM_READ");
    }
    goto LABEL_13;
  }
  uint64_t v5 = *((unsigned __int16 *)a2 + 6);
  if (*((unsigned __int16 *)a2 + 5) <= v5)
  {
    *((unsigned char *)a2 + 15) = 1;
LABEL_13:
    sub_10025A794((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LEA.c");
    int v13 = *((unsigned __int8 *)a2 + 14);
    *((unsigned char *)a2 + 15) = 1;
    if (v13 != 1) {
      sub_10014327C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LEA.c", 99, "(*bs).__RWFlag == BYTESTREAM_READ");
    }
    goto LABEL_14;
  }
  uint64_t v6 = *a2;
  *((_WORD *)a2 + 6) = v5 + 1;
  if (*((unsigned __int16 *)a2 + 5) <= (v5 + 1))
  {
    *((unsigned char *)a2 + 15) = 1;
LABEL_14:
    sub_10025A794((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LEA.c");
    int v14 = *((unsigned __int8 *)a2 + 14);
    *((unsigned char *)a2 + 15) = 1;
    if (v14 != 1) {
      sub_10014327C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LEA.c", 100, "(*bs).__RWFlag == BYTESTREAM_READ");
    }
    goto LABEL_15;
  }
  uint64_t v7 = *(unsigned __int8 *)(v6 + v5);
  uint64_t v8 = *a2;
  *((_WORD *)a2 + 6) = v5 + 2;
  if (*((unsigned __int16 *)a2 + 5) > (v5 + 2))
  {
    uint64_t v9 = *(unsigned __int8 *)(v8 + v5 + 1);
    uint64_t v10 = *a2;
    *((_WORD *)a2 + 6) = v5 + 3;
    if (*((unsigned __int16 *)a2 + 5) > (v5 + 3))
    {
      uint64_t v11 = *(unsigned __int8 *)(v10 + v5 + 2);
      uint64_t v12 = *a2;
      *((_WORD *)a2 + 6) = v5 + 4;
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, void))(*(void *)(qword_100A10330 + 16) + 16))(a1, v7, v9, v11, *(unsigned __int8 *)(v12 + v5 + 3));
      return 0;
    }
    goto LABEL_16;
  }
  *((unsigned char *)a2 + 15) = 1;
LABEL_15:
  sub_10025A794((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LEA.c");
LABEL_16:
  *((unsigned char *)a2 + 15) = 1;
  uint64_t v4 = 2;
  if (sub_100058654())
  {
    sub_100056E24((uint64_t)"Failed to read select codec", v15, v16, v17, v18, v19, v20, v21, v24);
    uint64_t v22 = sub_100050B4C(0x42u);
    if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR)) {
      sub_100744F6C();
    }
    return 2;
  }
  return v4;
}

uint64_t sub_1002434DC(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void (**)(uint64_t, uint64_t))(*(void *)(qword_100A10330 + 16) + 24);
  if (!v2) {
    return 3;
  }
  if (*(unsigned char *)(a2 + 14) != 1) {
    sub_10014327C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LEA.c", 122, "(*bs).__RWFlag == BYTESTREAM_READ");
  }
  if (*(unsigned char *)(a2 + 15))
  {
    sub_10025A794((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LEA.c");
  }
  else
  {
    uint64_t v5 = *(unsigned __int16 *)(a2 + 12);
    if (*(unsigned __int16 *)(a2 + 10) - (int)v5 >= 2)
    {
      uint64_t v6 = *(unsigned __int16 *)(*(void *)a2 + v5);
      *(_WORD *)(a2 + 12) = v5 + 2;
      v2(a1, v6);
      return 0;
    }
  }
  *(unsigned char *)(a2 + 15) = 1;
  uint64_t v4 = 2;
  if (sub_100058654())
  {
    sub_100056E24((uint64_t)"Failed to read codec ready", v7, v8, v9, v10, v11, v12, v13, v16);
    int v14 = sub_100050B4C(0x42u);
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR)) {
      sub_100744F6C();
    }
    return 2;
  }
  return v4;
}

uint64_t sub_1002435E4(uint64_t a1, uint64_t *a2)
{
  if (!*(void *)(*(void *)(qword_100A10330 + 16) + 32)) {
    return 3;
  }
  if (*((unsigned char *)a2 + 14) != 1) {
    sub_10014327C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LEA.c", 145, "(*bs).__RWFlag == BYTESTREAM_READ");
  }
  if (*((unsigned char *)a2 + 15))
  {
    sub_10025A794((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LEA.c");
  }
  else
  {
    int v5 = *((unsigned __int16 *)a2 + 5);
    uint64_t v6 = *((unsigned __int16 *)a2 + 6);
    if (v5 - (int)v6 >= 2)
    {
      uint64_t v7 = *a2;
      unsigned __int16 v8 = *(_WORD *)(*a2 + v6);
      *((_WORD *)a2 + 6) = v6 + 2;
      if (v5 - (unsigned __int16)(v6 + 2) >= 2)
      {
        unsigned __int16 v9 = *(_WORD *)(v7 + (unsigned __int16)(v6 + 2));
        *((_WORD *)a2 + 6) = v6 + 4;
LABEL_15:
        (*(void (**)(uint64_t, void, void))(*(void *)(qword_100A10330 + 16) + 32))(a1, v8, v9);
        return 0;
      }
LABEL_14:
      unsigned __int16 v9 = 0;
      goto LABEL_15;
    }
  }
  *((unsigned char *)a2 + 15) = 1;
  sub_10025A794((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LEA.c");
  unsigned __int16 v8 = *((unsigned __int8 *)a2 + 15);
  if (!*((unsigned char *)a2 + 15)) {
    goto LABEL_14;
  }
  uint64_t v4 = 2;
  if (sub_100058654())
  {
    sub_100056E24((uint64_t)"Failed to read start stream", v10, v11, v12, v13, v14, v15, v16, v19);
    uint64_t v17 = sub_100050B4C(0x42u);
    if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR)) {
      sub_100744F6C();
    }
    return 2;
  }
  return v4;
}

uint64_t sub_100243754(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void (**)(uint64_t, uint64_t, void))(*(void *)(qword_100A10330 + 16) + 48);
  if (!v2) {
    return 3;
  }
  uint64_t v4 = *(unsigned __int16 *)(a2 + 12);
  uint64_t v5 = *(void *)a2 + v4;
  if (*(unsigned char *)(a2 + 15))
  {
    sub_10025A794((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LEA.c");
    unsigned __int16 v6 = 0;
  }
  else
  {
    unsigned __int16 v6 = *(_WORD *)(a2 + 10) - v4;
  }
  v2(a1, v5, v6);
  return 0;
}

void sub_1002437E8(uint64_t a1, uint64_t *a2)
{
  if (*((unsigned char *)a2 + 14) != 1) {
    sub_10014327C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LEA.c", 194, "(*bs).__RWFlag == BYTESTREAM_READ");
  }
  if (*((unsigned char *)a2 + 15))
  {
    sub_10025A794((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LEA.c");
    int v3 = *((unsigned __int8 *)a2 + 14);
    *((unsigned char *)a2 + 15) = 1;
    if (v3 != 1) {
      sub_10014327C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LEA.c", 195, "(*bs).__RWFlag == BYTESTREAM_READ");
    }
    goto LABEL_11;
  }
  uint64_t v4 = *((unsigned __int16 *)a2 + 6);
  if (*((unsigned __int16 *)a2 + 5) <= v4)
  {
    *((unsigned char *)a2 + 15) = 1;
LABEL_11:
    sub_10025A794((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LEA.c");
LABEL_12:
    *((unsigned char *)a2 + 15) = 1;
    if (sub_100058654())
    {
      sub_100056E24((uint64_t)"Failed to read error", v9, v10, v11, v12, v13, v14, v15, v17);
      uint64_t v16 = sub_100050B4C(0x42u);
      if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR)) {
        sub_100744F6C();
      }
    }
    return;
  }
  uint64_t v5 = *a2;
  *((_WORD *)a2 + 6) = v4 + 1;
  if (*((unsigned __int16 *)a2 + 5) - ((int)v4 + 1) < 2) {
    goto LABEL_12;
  }
  uint64_t v6 = *(unsigned __int8 *)(v5 + v4);
  uint64_t v7 = *(unsigned __int16 *)(*a2 + v4 + 1);
  *((_WORD *)a2 + 6) = v4 + 3;
  unsigned __int16 v8 = *(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(qword_100A10330 + 16) + 56);

  v8(a1, v6, v7);
}

uint64_t sub_10024394C(uint64_t a1, uint64_t *a2)
{
  if (*((unsigned char *)a2 + 14) != 1) {
    sub_10014327C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LEA.c", 216, "(*bs).__RWFlag == BYTESTREAM_READ");
  }
  if (*((unsigned char *)a2 + 15))
  {
    sub_10025A794((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LEA.c");
  }
  else
  {
    uint64_t v3 = *((unsigned __int16 *)a2 + 6);
    if (*((unsigned __int16 *)a2 + 5) > v3)
    {
      uint64_t v4 = *a2;
      *((_WORD *)a2 + 6) = v3 + 1;
      (*(void (**)(uint64_t, void))(*(void *)(qword_100A10330 + 16) + 72))(a1, *(unsigned __int8 *)(v4 + v3));
      return 0;
    }
  }
  *((unsigned char *)a2 + 15) = 1;
  uint64_t v5 = 2;
  if (sub_100058654())
  {
    sub_100056E24((uint64_t)"Failed to read set volume", v6, v7, v8, v9, v10, v11, v12, v15);
    uint64_t v13 = sub_100050B4C(0x42u);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR)) {
      sub_100744F6C();
    }
    return 2;
  }
  return v5;
}

uint64_t sub_100243A44(uint64_t a1, uint64_t *a2)
{
  if (*((unsigned char *)a2 + 14) != 1) {
    sub_10014327C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LEA.c", 234, "(*bs).__RWFlag == BYTESTREAM_READ");
  }
  if (*((unsigned char *)a2 + 15))
  {
    sub_10025A794((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LEA.c");
    int v3 = *((unsigned __int8 *)a2 + 14);
    *((unsigned char *)a2 + 15) = 1;
    if (v3 != 1) {
      sub_10014327C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LEA.c", 235, "(*bs).__RWFlag == BYTESTREAM_READ");
    }
    goto LABEL_9;
  }
  uint64_t v4 = *((unsigned __int16 *)a2 + 6);
  if (*((unsigned __int16 *)a2 + 5) <= v4)
  {
    *((unsigned char *)a2 + 15) = 1;
LABEL_9:
    sub_10025A794((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LEA.c");
    goto LABEL_10;
  }
  uint64_t v5 = *a2;
  *((_WORD *)a2 + 6) = v4 + 1;
  if (*((unsigned __int16 *)a2 + 5) > (v4 + 1))
  {
    uint64_t v6 = *(unsigned __int8 *)(v5 + v4);
    uint64_t v7 = *a2;
    *((_WORD *)a2 + 6) = v4 + 2;
    (*(void (**)(uint64_t, uint64_t, void))(*(void *)(qword_100A10330 + 16) + 80))(a1, v6, *(unsigned __int8 *)(v7 + v4 + 1));
    return 0;
  }
LABEL_10:
  *((unsigned char *)a2 + 15) = 1;
  uint64_t v8 = 2;
  if (sub_100058654())
  {
    sub_100056E24((uint64_t)"Failed to read capabilities", v9, v10, v11, v12, v13, v14, v15, v18);
    uint64_t v16 = sub_100050B4C(0x42u);
    if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR)) {
      sub_100744F6C();
    }
    return 2;
  }
  return v8;
}

uint64_t sub_100243BA0(uint64_t a1, uint64_t *a2)
{
  if (*((unsigned char *)a2 + 14) != 1) {
    sub_10014327C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LEA.c", 262, "(*bs).__RWFlag == BYTESTREAM_READ");
  }
  if (*((unsigned char *)a2 + 15))
  {
    sub_10025A794((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LEA.c");
LABEL_7:
    *((unsigned char *)a2 + 15) = 1;
    goto LABEL_8;
  }
  uint64_t v3 = *((unsigned __int16 *)a2 + 6);
  if (*((unsigned __int16 *)a2 + 5) <= v3) {
    goto LABEL_7;
  }
  uint64_t v4 = *a2;
  *((_WORD *)a2 + 6) = v3 + 1;
  uint64_t v5 = *(void (**)(uint64_t, void))(*(void *)(qword_100A10330 + 16) + 104);
  if (v5)
  {
    v5(a1, *(unsigned __int8 *)(v4 + v3));
    return 0;
  }
LABEL_8:
  uint64_t v6 = 2;
  if (sub_100058654())
  {
    sub_100056E24((uint64_t)"Failed to read State Notification", v7, v8, v9, v10, v11, v12, v13, v16);
    uint64_t v14 = sub_100050B4C(0x42u);
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR)) {
      sub_100744F6C();
    }
    return 2;
  }
  return v6;
}

uint64_t sub_100243C9C(uint64_t a1, uint64_t *a2)
{
  if (*((unsigned char *)a2 + 14) != 1) {
    sub_10014327C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LEA.c", 279, "(*bs).__RWFlag == BYTESTREAM_READ");
  }
  if (*((unsigned char *)a2 + 15))
  {
    sub_10025A794((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LEA.c");
    int v3 = *((unsigned __int8 *)a2 + 14);
    *((unsigned char *)a2 + 15) = 1;
    if (v3 != 1) {
      sub_10014327C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LEA.c", 280, "(*bs).__RWFlag == BYTESTREAM_READ");
    }
    goto LABEL_10;
  }
  uint64_t v4 = *((unsigned __int16 *)a2 + 6);
  if (*((unsigned __int16 *)a2 + 5) <= v4)
  {
    *((unsigned char *)a2 + 15) = 1;
LABEL_10:
    sub_10025A794((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LEA.c");
    goto LABEL_11;
  }
  uint64_t v5 = *a2;
  uint64_t v6 = v4 + 1;
  *((_WORD *)a2 + 6) = v4 + 1;
  if (*((unsigned __int16 *)a2 + 5) <= (v4 + 1))
  {
LABEL_11:
    *((unsigned char *)a2 + 15) = 1;
    goto LABEL_12;
  }
  char v7 = *(unsigned char *)(v5 + v4);
  uint64_t v8 = *a2;
  *((_WORD *)a2 + 6) = v4 + 2;
  uint64_t v9 = *(void (**)(uint64_t, void, void))(*(void *)(qword_100A10330 + 16) + 112);
  if (v9)
  {
    v9(a1, v7, *(unsigned __int8 *)(v8 + v6));
    return 0;
  }
LABEL_12:
  uint64_t v10 = 2;
  if (sub_100058654())
  {
    sub_100056E24((uint64_t)"Failed to read LinkQuality Notification", v11, v12, v13, v14, v15, v16, v17, v20);
    uint64_t v18 = sub_100050B4C(0x42u);
    if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR)) {
      sub_100744F6C();
    }
    return 2;
  }
  return v10;
}

uint64_t sub_100243E00(uint64_t a1, uint64_t *a2)
{
  if (*((unsigned char *)a2 + 14) != 1) {
    sub_10014327C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LEA.c", 297, "(*bs).__RWFlag == BYTESTREAM_READ");
  }
  __int16 v20 = 0;
  int v19 = 0;
  if (*((unsigned char *)a2 + 15))
  {
    sub_10025A794((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LEA.c");
  }
  else
  {
    uint64_t v4 = *((unsigned __int16 *)a2 + 6);
    if (*((unsigned __int16 *)a2 + 5) - (int)v4 >= 6)
    {
      sub_100008A18((uint64_t)&v19, *a2 + v4, 6uLL);
      *((_WORD *)a2 + 6) += 6;
      goto LABEL_7;
    }
  }
  *((unsigned char *)a2 + 15) = 1;
LABEL_7:
  if (*((unsigned char *)a2 + 14) != 1) {
    sub_10014327C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LEA.c", 298, "(*bs).__RWFlag == BYTESTREAM_READ");
  }
  if (*((unsigned char *)a2 + 15))
  {
    sub_10025A794((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LEA.c");
LABEL_13:
    *((unsigned char *)a2 + 15) = 1;
    goto LABEL_14;
  }
  uint64_t v5 = *((unsigned __int16 *)a2 + 6);
  if (*((unsigned __int16 *)a2 + 5) <= v5) {
    goto LABEL_13;
  }
  uint64_t v6 = *a2;
  *((_WORD *)a2 + 6) = v5 + 1;
  char v7 = *(void (**)(uint64_t, int *, void))(*(void *)(qword_100A10330 + 16) + 136);
  if (v7)
  {
    v7(a1, &v19, *(unsigned __int8 *)(v6 + v5));
    return 0;
  }
LABEL_14:
  uint64_t v8 = 2;
  if (sub_100058654())
  {
    sub_100056E24((uint64_t)"Failed to read Bonding Status", v9, v10, v11, v12, v13, v14, v15, v18);
    uint64_t v16 = sub_100050B4C(0x42u);
    if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR)) {
      sub_100744F6C();
    }
    return 2;
  }
  return v8;
}

uint64_t sub_100243FA0(uint64_t a1, uint64_t *a2)
{
  if (*((unsigned char *)a2 + 14) != 1) {
    sub_10014327C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LEA.c", 314, "(*bs).__RWFlag == BYTESTREAM_READ");
  }
  if (*((unsigned char *)a2 + 15))
  {
    sub_10025A794((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LEA.c");
LABEL_7:
    *((unsigned char *)a2 + 15) = 1;
    goto LABEL_8;
  }
  uint64_t v3 = *((unsigned __int16 *)a2 + 6);
  if (*((unsigned __int16 *)a2 + 5) <= v3) {
    goto LABEL_7;
  }
  uint64_t v4 = *a2;
  *((_WORD *)a2 + 6) = v3 + 1;
  uint64_t v5 = *(void (**)(uint64_t, void))(*(void *)(qword_100A10330 + 16) + 120);
  if (v5)
  {
    v5(a1, *(unsigned __int8 *)(v4 + v3));
    return 0;
  }
LABEL_8:
  uint64_t v6 = 2;
  if (sub_100058654())
  {
    sub_100056E24((uint64_t)"Failed to read Bonding Status Response", v7, v8, v9, v10, v11, v12, v13, v16);
    uint64_t v14 = sub_100050B4C(0x42u);
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR)) {
      sub_100744F6C();
    }
    return 2;
  }
  return v6;
}

uint64_t sub_10024409C(uint64_t a1, uint64_t *a2)
{
  if (*((unsigned char *)a2 + 14) != 1) {
    sub_10014327C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LEA.c", 332, "(*bs).__RWFlag == BYTESTREAM_READ");
  }
  __int16 v24 = 0;
  int v23 = 0;
  uint64_t v25 = 0;
  if (*((unsigned char *)a2 + 15))
  {
    sub_10025A794((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LEA.c");
  }
  else
  {
    uint64_t v4 = *((unsigned __int16 *)a2 + 6);
    if (*((unsigned __int16 *)a2 + 5) - (int)v4 >= 6)
    {
      sub_100008A18((uint64_t)&v23, *a2 + v4, 6uLL);
      *((_WORD *)a2 + 6) += 6;
      goto LABEL_7;
    }
  }
  *((unsigned char *)a2 + 15) = 1;
LABEL_7:
  if (*((unsigned char *)a2 + 14) != 1) {
    sub_10014327C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LEA.c", 333, "(*bs).__RWFlag == BYTESTREAM_READ");
  }
  if (*((unsigned char *)a2 + 15))
  {
    sub_10025A794((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LEA.c");
    int v5 = *((unsigned __int8 *)a2 + 14);
    *((unsigned char *)a2 + 15) = 1;
    if (v5 != 1) {
      sub_10014327C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LEA.c", 334, "(*bs).__RWFlag == BYTESTREAM_READ");
    }
    goto LABEL_18;
  }
  uint64_t v6 = *((unsigned __int16 *)a2 + 6);
  if (*((unsigned __int16 *)a2 + 5) - (int)v6 <= 1)
  {
    *((unsigned char *)a2 + 15) = 1;
LABEL_18:
    sub_10025A794((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LEA.c");
    goto LABEL_19;
  }
  uint64_t v7 = *a2;
  unsigned __int16 v8 = *(_WORD *)(*a2 + v6);
  *((_WORD *)a2 + 6) = v6 + 2;
  if (*((unsigned __int16 *)a2 + 5) - (unsigned __int16)(v6 + 2) < 8)
  {
LABEL_19:
    *((unsigned char *)a2 + 15) = 1;
    goto LABEL_20;
  }
  uint64_t v9 = 0;
  uint64_t v10 = v7 + (unsigned __int16)(v6 + 2);
  do
  {
    *((unsigned char *)&v25 + v9) = *(unsigned char *)(v10 + v9);
    ++v9;
  }
  while (v9 != 8);
  *((_WORD *)a2 + 6) = v6 + 10;
  uint64_t v11 = *(void (**)(uint64_t, int *, void, uint64_t *))(*(void *)(qword_100A10330 + 16) + 144);
  if (v11)
  {
    v11(a1, &v23, v8, &v25);
    return 0;
  }
LABEL_20:
  uint64_t v12 = 2;
  if (sub_100058654())
  {
    sub_100056E24((uint64_t)"Failed to read Central ID", v13, v14, v15, v16, v17, v18, v19, v22);
    __int16 v20 = sub_100050B4C(0x42u);
    if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR)) {
      sub_100744F6C();
    }
    return 2;
  }
  return v12;
}

uint64_t sub_1002442FC(uint64_t a1, uint64_t a2)
{
  if (*(unsigned char *)(a2 + 14) != 1) {
    sub_10014327C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LEA.c", 351, "(*bs).__RWFlag == BYTESTREAM_READ");
  }
  WORD2(v19) = 0;
  LODWORD(v19) = 0;
  v20[0] = 0;
  v20[1] = 0;
  if (*(unsigned char *)(a2 + 15))
  {
    sub_10025A794((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LEA.c");
    LOWORD(v4) = *(_WORD *)(a2 + 12);
  }
  else
  {
    uint64_t v4 = *(unsigned __int16 *)(a2 + 12);
    if (*(unsigned __int16 *)(a2 + 10) - (int)v4 >= 6)
    {
      sub_100008A18((uint64_t)&v19, *(void *)a2 + v4, 6uLL);
      LOWORD(v4) = *(_WORD *)(a2 + 12) + 6;
      *(_WORD *)(a2 + 12) = v4;
      goto LABEL_7;
    }
  }
  *(unsigned char *)(a2 + 15) = 1;
LABEL_7:
  if (*(unsigned char *)(a2 + 14) != 1) {
    sub_10014327C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LEA.c", 352, "(*bs).__RWFlag == BYTESTREAM_READ");
  }
  if (*(unsigned char *)(a2 + 15))
  {
    sub_10025A794((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LEA.c");
LABEL_15:
    *(unsigned char *)(a2 + 15) = 1;
    goto LABEL_16;
  }
  __int16 v5 = v4;
  if (*(unsigned __int16 *)(a2 + 10) - (unsigned __int16)v4 < 16) {
    goto LABEL_15;
  }
  uint64_t v6 = 0;
  uint64_t v7 = *(void *)a2 + (unsigned __int16)v4;
  do
  {
    *((unsigned char *)v20 + v6) = *(unsigned char *)(v7 + v6);
    ++v6;
  }
  while (v6 != 16);
  *(_WORD *)(a2 + 12) = v5 + 16;
  unsigned __int16 v8 = *(void (**)(uint64_t, uint64_t *, void *))(*(void *)(qword_100A10330 + 16) + 152);
  if (v8)
  {
    v8(a1, &v19, v20);
    return 0;
  }
LABEL_16:
  uint64_t v9 = 2;
  if (sub_100058654())
  {
    sub_100056E24((uint64_t)"Failed to read ID info", v10, v11, v12, v13, v14, v15, v16, v19);
    uint64_t v17 = sub_100050B4C(0x42u);
    if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR)) {
      sub_100744F6C();
    }
    return 2;
  }
  return v9;
}

uint64_t sub_1002444F8(uint64_t a1, uint64_t a2)
{
  if (*(unsigned char *)(a2 + 14) != 1) {
    sub_10014327C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LEA.c", 369, "(*bs).__RWFlag == BYTESTREAM_READ");
  }
  WORD2(v19) = 0;
  LODWORD(v19) = 0;
  v20[0] = 0;
  v20[1] = 0;
  if (*(unsigned char *)(a2 + 15))
  {
    sub_10025A794((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LEA.c");
    LOWORD(v4) = *(_WORD *)(a2 + 12);
  }
  else
  {
    uint64_t v4 = *(unsigned __int16 *)(a2 + 12);
    if (*(unsigned __int16 *)(a2 + 10) - (int)v4 >= 6)
    {
      sub_100008A18((uint64_t)&v19, *(void *)a2 + v4, 6uLL);
      LOWORD(v4) = *(_WORD *)(a2 + 12) + 6;
      *(_WORD *)(a2 + 12) = v4;
      goto LABEL_7;
    }
  }
  *(unsigned char *)(a2 + 15) = 1;
LABEL_7:
  if (*(unsigned char *)(a2 + 14) != 1) {
    sub_10014327C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LEA.c", 370, "(*bs).__RWFlag == BYTESTREAM_READ");
  }
  if (*(unsigned char *)(a2 + 15))
  {
    sub_10025A794((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LEA.c");
LABEL_15:
    *(unsigned char *)(a2 + 15) = 1;
    goto LABEL_16;
  }
  __int16 v5 = v4;
  if (*(unsigned __int16 *)(a2 + 10) - (unsigned __int16)v4 < 16) {
    goto LABEL_15;
  }
  uint64_t v6 = 0;
  uint64_t v7 = *(void *)a2 + (unsigned __int16)v4;
  do
  {
    *((unsigned char *)v20 + v6) = *(unsigned char *)(v7 + v6);
    ++v6;
  }
  while (v6 != 16);
  *(_WORD *)(a2 + 12) = v5 + 16;
  unsigned __int16 v8 = *(void (**)(uint64_t, uint64_t *, void *))(*(void *)(qword_100A10330 + 16) + 160);
  if (v8)
  {
    v8(a1, &v19, v20);
    return 0;
  }
LABEL_16:
  uint64_t v9 = 2;
  if (sub_100058654())
  {
    sub_100056E24((uint64_t)"Failed to read Encryption Info", v10, v11, v12, v13, v14, v15, v16, v19);
    uint64_t v17 = sub_100050B4C(0x42u);
    if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR)) {
      sub_100744F6C();
    }
    return 2;
  }
  return v9;
}

uint64_t sub_1002446F4(uint64_t a1, uint64_t a2)
{
  if (*(unsigned char *)(a2 + 14) != 1) {
    sub_10014327C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LEA.c", 387, "(*bs).__RWFlag == BYTESTREAM_READ");
  }
  __int16 v22 = 0;
  int v21 = 0;
  if (*(unsigned char *)(a2 + 15))
  {
    sub_10025A794((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LEA.c");
  }
  else
  {
    uint64_t v4 = *(unsigned __int16 *)(a2 + 12);
    if (*(unsigned __int16 *)(a2 + 10) - (int)v4 >= 6)
    {
      sub_100008A18((uint64_t)&v21, *(void *)a2 + v4, 6uLL);
      *(_WORD *)(a2 + 12) += 6;
      goto LABEL_7;
    }
  }
  *(unsigned char *)(a2 + 15) = 1;
LABEL_7:
  if (*(unsigned char *)(a2 + 14) != 1) {
    sub_10014327C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LEA.c", 388, "(*bs).__RWFlag == BYTESTREAM_READ");
  }
  if (*(unsigned char *)(a2 + 15))
  {
    sub_10025A794((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LEA.c");
LABEL_13:
    *(unsigned char *)(a2 + 15) = 1;
    goto LABEL_14;
  }
  uint64_t v5 = *(unsigned __int16 *)(a2 + 12);
  if (*(unsigned __int16 *)(a2 + 10) - (int)v5 <= 1) {
    goto LABEL_13;
  }
  uint64_t v6 = (unsigned __int8 *)(*(void *)a2 + v5);
  int v7 = *v6;
  int v8 = v6[1];
  *(_WORD *)(a2 + 12) = v5 + 2;
  uint64_t v9 = *(void (**)(uint64_t, int *, void))(*(void *)(qword_100A10330 + 16) + 168);
  if (v9)
  {
    v9(a1, &v21, v7 | (v8 << 8));
    return 0;
  }
LABEL_14:
  uint64_t v10 = 2;
  if (sub_100058654())
  {
    sub_100056E24((uint64_t)"Failed to read Disconnect", v11, v12, v13, v14, v15, v16, v17, v20);
    uint64_t v18 = sub_100050B4C(0x42u);
    if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR)) {
      sub_100744F6C();
    }
    return 2;
  }
  return v10;
}

uint64_t sub_1002448A4(uint64_t a1, uint64_t *a2)
{
  if (*((unsigned char *)a2 + 14) != 1) {
    sub_10014327C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LEA.c", 404, "(*bs).__RWFlag == BYTESTREAM_READ");
  }
  if (*((unsigned char *)a2 + 15))
  {
    sub_10025A794((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LEA.c");
LABEL_7:
    *((unsigned char *)a2 + 15) = 1;
    goto LABEL_8;
  }
  uint64_t v3 = *((unsigned __int16 *)a2 + 6);
  if (*((unsigned __int16 *)a2 + 5) <= v3) {
    goto LABEL_7;
  }
  uint64_t v4 = *a2;
  *((_WORD *)a2 + 6) = v3 + 1;
  uint64_t v5 = *(void (**)(uint64_t, void))(*(void *)(qword_100A10330 + 16) + 128);
  if (v5)
  {
    v5(a1, *(unsigned __int8 *)(v4 + v3));
    return 0;
  }
LABEL_8:
  uint64_t v6 = 2;
  if (sub_100058654())
  {
    sub_100056E24((uint64_t)"Failed to read Siri", v7, v8, v9, v10, v11, v12, v13, v16);
    uint64_t v14 = sub_100050B4C(0x42u);
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR)) {
      sub_100744F6C();
    }
    return 2;
  }
  return v6;
}

uint64_t sub_1002449A0(uint64_t a1, unsigned int a2)
{
  if (!a1) {
    sub_10025B8C0();
  }
  if (a2 == 1 || a2 >= 0x3E) {
    sub_10025B8C0();
  }
  if (*(unsigned char *)qword_100A19778)
  {
    uint64_t v4 = 0;
    uint64_t v5 = qword_100A10338 - 88;
    while (1)
    {
      v5 += 88;
      if (v5 == a1) {
        break;
      }
      if (*(unsigned __int8 *)qword_100A19778 == ++v4) {
        goto LABEL_10;
      }
    }
    return (unsigned __int16)(a2 | ((_WORD)v4 << 8));
  }
  else
  {
LABEL_10:
    sub_10025B8C0();
    return 0;
  }
}

uint64_t sub_100244A2C(uint64_t a1, int a2, void *a3)
{
  if (a1)
  {
    if (a3) {
      goto LABEL_3;
    }
  }
  else
  {
    sub_10025B8C0();
    if (a3) {
      goto LABEL_3;
    }
  }
  sub_10025B8C0();
LABEL_3:
  if (!dword_100A19878) {
    return 408;
  }
  uint64_t v6 = (void *)(a1 + 16);
  while (1)
  {
    uint64_t v6 = (void *)*v6;
    if (!v6 || v6 == (void *)(a1 + 16)) {
      break;
    }
    if (*((unsigned __int8 *)v6 - 134) == a2)
    {
      uint64_t result = 0;
      *a3 = v6 - 18;
      return result;
    }
  }
  return 912;
}

uint64_t sub_100244AC4(uint64_t a1, unsigned int a2, void *a3)
{
  if (a2 < 2) {
    return 121;
  }
  uint64_t v4 = *(unsigned __int8 *)(qword_100A19778 + 1);
  if (!*(unsigned char *)(qword_100A19778 + 1)) {
    return 121;
  }
  for (i = (unsigned __int16 *)(qword_100A10348 + 24); *((unsigned __int8 *)i + 2) != a2 >> 1; i += 28)
  {
    if (!--v4) {
      return 121;
    }
  }
  uint64_t result = sub_100244B90(a1, a2, a3);
  if (!result)
  {
    uint64_t v8 = *a3;
    *(unsigned char *)(v8 + 20) = 1;
    *(void *)(v8 + 40) = *((void *)i - 1);
    uint64_t v9 = *a3;
    *(_WORD *)(*a3 + 160) = i[8];
    unsigned int v10 = *i;
    if (v10 >= *(unsigned __int16 *)(a1 + 4)) {
      LOWORD(v10) = *(_WORD *)(a1 + 4);
    }
    *(_WORD *)(v9 + 16) = v10;
    *(void *)(v9 + 48) = *((void *)i + 3);
  }
  return result;
}

uint64_t sub_100244B90(uint64_t a1, unsigned int a2, void *a3)
{
  if (!a1) {
    sub_10025B8C0();
  }
  if (!dword_100A19878) {
    return 408;
  }
  uint64_t v6 = (void *)(a1 + 16);
  while (1)
  {
    uint64_t v6 = (void *)*v6;
    if (!v6 || v6 == (void *)(a1 + 16)) {
      break;
    }
    if (*((unsigned __int8 *)v6 - 134) == a2) {
      return 911;
    }
  }
  uint64_t v9 = sub_10010CE48(0xA8uLL);
  if (!v9) {
    return 106;
  }
  unsigned int v10 = v9;
  v9[20] = 0;
  *((_WORD *)v9 + 4) = sub_1002449A0(a1, a2);
  *((void *)v10 + 16) = a1;
  v10[10] = a2;
  *((void *)v10 + 11) = 0;
  *((_WORD *)v10 + 8) = 127;
  *((_WORD *)v10 + 6) = 140;
  *((void *)v10 + 13) = 0;
  *((_WORD *)v10 + 81) = 0;
  *(void *)(v10 + 22) = 50544511;
  *(_DWORD *)(v10 + 30) = 16847633;
  *((_DWORD *)v10 + 14) = 0;
  sub_10025C10C((void *)v10 + 18, a1 + 16);
  uint64_t result = 0;
  *a3 = v10;
  return result;
}

void sub_100244C94(uint64_t a1)
{
  if (!a1) {
    sub_10025B8C0();
  }
  uint64_t v2 = *(void *)(a1 + 128);
  if (!v2)
  {
    sub_10025B8C0();
    uint64_t v2 = *(void *)(a1 + 128);
  }
  if (*(unsigned __int8 *)(v2 + 81) == *(unsigned __int8 *)(a1 + 10) && *(void *)(v2 + 72)) {
    sub_1001F68C8(*(unsigned __int16 *)(v2 + 2));
  }
  if (*(unsigned char *)(a1 + 96))
  {
    *(unsigned char *)(a1 + 96) = 0;
    uint64_t v3 = *(void *)(a1 + 88);
    if (v3)
    {
      *(void *)(a1 + 88) = 0;
      (*(void (**)(void, uint64_t, uint64_t))(a1 + 80))(*(unsigned __int16 *)(a1 + 8), v3, 143);
    }
  }
  uint64_t v4 = *(void *)(a1 + 128);
  uint64_t v7 = *(void **)(v4 + 56);
  uint64_t v6 = (void *)(v4 + 56);
  uint64_t v5 = v7;
  if (v7 != v6)
  {
    do
    {
      uint64_t v8 = (void *)*v5;
      if (*((unsigned __int8 *)v5 - 7) == *(unsigned __int8 *)(a1 + 10))
      {
        sub_10025C120(v5);
        sub_10025C53C((void *)*(v5 - 2));
        if (*((unsigned char *)v5 - 8)) {
          sub_100247158(a1, 143);
        }
        sub_100023010(v5 - 2);
      }
      uint64_t v5 = v8;
    }
    while (v8 != v6);
  }
}

void sub_100244D78(uint64_t a1, int a2)
{
  if (!a1) {
    sub_10025B8C0();
  }
  uint64_t v4 = *(void *)(a1 + 128);
  if (!v4)
  {
    sub_10025B8C0();
    uint64_t v4 = *(void *)(a1 + 128);
  }
  sub_10025D444(*(unsigned int *)(a1 + 56));
  sub_10025C120((void *)(a1 + 144));
  uint64_t v5 = *(unsigned int *)(a1 + 136);
  if (v5)
  {
    sub_100026DB4(v5);
    *(_DWORD *)(a1 + 136) = 0;
  }
  sub_100244C94(a1);
  sub_10024803C(a1);
  if (a2 && *(void *)(v4 + 16) == v4 + 16) {
    sub_100244E24((unsigned __int8 *)v4, 0, *(unsigned int *)(a1 + 164));
  }

  sub_100023010((void *)a1);
}

uint64_t sub_100244E24(unsigned __int8 *a1, int a2, uint64_t a3)
{
  if (!a1) {
    sub_10025B8C0();
  }
  if (sub_100058654())
  {
    sub_100056E24((uint64_t)"Shutting down session to %:", v6, v7, v8, v9, v10, v11, v12, (uint64_t)(a1 + 6));
    uint64_t v13 = sub_100050B4C(0x32u);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 136446210;
      uint64_t v18 = sub_100050714();
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
    }
  }
  int v14 = *a1;
  if (!a2)
  {
    if (v14 != 9)
    {
      *a1 = 9;
      uint64_t v15 = sub_1002485D4(67, (uint64_t)a1, 0);
      goto LABEL_12;
    }
    return 116;
  }
  if (v14 == 10) {
    return 116;
  }
  *a1 = 10;
  uint64_t v15 = sub_1001E121C(*((unsigned __int16 *)a1 + 1), a3);
LABEL_12:
  if (v15) {
    sub_1002450DC((uint64_t)a1, v15, 1);
  }
  return 0;
}

uint64_t sub_100244F6C(int a1)
{
  if (!dword_100A19878)
  {
    if (sub_100058654())
    {
      sub_100056E24((uint64_t)"OI_Rfcomm_GetSessionByCID", v4, v5, v6, v7, v8, v9, v10, v12);
      uint64_t v11 = sub_100050B4C(0x32u);
      if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR)) {
        sub_100749CC4();
      }
    }
    return 0;
  }
  uint64_t v1 = *(unsigned __int8 *)qword_100A19778;
  if (!*(unsigned char *)qword_100A19778) {
    return 0;
  }
  for (uint64_t result = qword_100A10338; !*(unsigned char *)result || *(unsigned __int16 *)(result + 2) != a1; result += 88)
  {
    if (!--v1) {
      return 0;
    }
  }
  return result;
}

uint64_t sub_10024501C(uint64_t a1)
{
  if (!dword_100A19878)
  {
    if (sub_100058654())
    {
      sub_100056E24((uint64_t)"OI_Rfcomm_GetSessionByAddr", v5, v6, v7, v8, v9, v10, v11, v13);
      uint64_t v12 = sub_100050B4C(0x32u);
      if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR)) {
        sub_100749CC4();
      }
    }
    return 0;
  }
  uint64_t v1 = *(unsigned __int8 *)qword_100A19778;
  if (!*(unsigned char *)qword_100A19778) {
    return 0;
  }
  for (uint64_t result = qword_100A10338; ; result += 88)
  {
    if (*(unsigned char *)result)
    {
      if (*(_DWORD *)a1 == *(_DWORD *)(result + 6)
        && *(unsigned __int16 *)(a1 + 4) == *(unsigned __int16 *)(result + 10))
      {
        break;
      }
    }
    if (!--v1) {
      return 0;
    }
  }
  return result;
}

void sub_1002450DC(uint64_t a1, uint64_t a2, char a3)
{
  if (!a1) {
    sub_10025B8C0();
  }
  if (!*(unsigned char *)a1) {
    sub_10025B8C0();
  }
  sub_100249EE4(a1);
  sub_100249F20(a1);
  sub_1002483F0(a1);
  uint64_t v5 = (void *)(a1 + 16);
  uint64_t v6 = *(void **)(a1 + 16);
  if (v6 == (void *)(a1 + 16))
  {
LABEL_30:
    *(unsigned char *)a1 = 0;
    sub_100249EE4(a1);
    sub_100249F20(a1);
    sub_1002483F0(a1);
    sub_100245570();
    uint64_t v28 = (unsigned __int16 *)qword_100A10340;
    if (qword_100A10340)
    {
      do
      {
        uint64_t v29 = (void (*)(void, uint64_t))*((void *)v28 + 3);
        if (v29)
        {
          v29(*v28, a2);
        }
        else
        {
          uint64_t v30 = (void (*)(void, void, uint64_t))*((void *)v28 + 2);
          if (v30) {
            v30(*v28, 0, a2);
          }
        }
        uint64_t v28 = *(unsigned __int16 **)(qword_100A10340 + 32);
        sub_100023010((void *)qword_100A10340);
        qword_100A10340 = (uint64_t)v28;
      }
      while (v28);
    }
    qword_100A10340 = 0;
    return;
  }
  char v32 = 0;
  int v33 = *(char *)(a1 + 82);
  uint64_t v31 = 136446466;
  uint64_t v7 = (void *)(a1 + 16);
  do
  {
    while (1)
    {
      uint64_t v8 = v6 - 18;
      *((_DWORD *)v6 + 5) = a2;
      unsigned int v9 = *((unsigned __int8 *)v6 - 131);
      if (v9 > 1 || (a3 & 1) != 0 || *((unsigned char *)v6 - 124) || (v33 & 0x80000000) == 0) {
        break;
      }
      *(_WORD *)((char *)v6 - 131) = 0;
      *(v6 - 7) = 0;
      char v32 = 1;
      *((unsigned char *)v6 - 111) = 1;
      *((_WORD *)v6 - 63) = 0;
      *((_DWORD *)v6 - 22) = 0;
      sub_10024803C((uint64_t)(v6 - 18));
      uint64_t v7 = (void *)*v7;
      uint64_t v6 = (void *)*v7;
      if ((void *)*v7 == v5) {
        goto LABEL_29;
      }
    }
    if (v9 - 5 >= 4)
    {
      if (v9 == 9)
      {
        sub_100244D78(v6 - 18, 0);
        goto LABEL_24;
      }
      uint64_t v11 = 0;
      *((unsigned char *)v6 - 131) = 9;
      uint64_t v10 = *(v6 - 9);
    }
    else
    {
      *((unsigned char *)v6 - 131) = 9;
      sub_100244C94((uint64_t)(v6 - 18));
      uint64_t v10 = 0;
      uint64_t v11 = *(void *)*(v6 - 13);
    }
    uint64_t v12 = *(v6 - 18);
    uint64_t v13 = *(unsigned __int16 *)(a1 + 10);
    uint64_t v14 = *(unsigned int *)(a1 + 6);
    __int16 v15 = *((_WORD *)v6 - 68);
    sub_100244D78(v8, 0);
    uint64_t v16 = (char *)sub_100022FE8(0x28uLL);
    if (v16)
    {
      *(_WORD *)uint64_t v16 = v15;
      *(_DWORD *)(v16 + 2) = v14;
      *((_WORD *)v16 + 3) = (v14 | (unint64_t)(v13 << 32)) >> 32;
      *((void *)v16 + 1) = v12;
      *((void *)v16 + 2) = v10;
      *((void *)v16 + 3) = v11;
      *((void *)v16 + 4) = 0;
      uint64_t v17 = qword_100A10340;
      if (qword_100A10340)
      {
        do
        {
          uint64_t v18 = v17;
          uint64_t v17 = *(void *)(v17 + 32);
        }
        while (v17);
        *(void *)(v18 + 32) = v16;
      }
      else
      {
        qword_100A10340 = (uint64_t)v16;
      }
    }
    else
    {
      sub_10025B8C0();
      if (sub_100058654())
      {
        sub_100056E24((uint64_t)"Alloc RFCOMM link cache failed!", v19, v20, v21, v22, v23, v24, v25, v31);
        uint64_t v26 = sub_100050B4C(0x32u);
        if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
        {
          uint64_t v27 = sub_100050714();
          *(_DWORD *)long long buf = v31;
          uint64_t v36 = v27;
          __int16 v37 = 1024;
          int v38 = 104;
          _os_log_error_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_ERROR, "%{public}s (status=%{bluetooth:OI_STATUS}u)", buf, 0x12u);
        }
      }
    }
LABEL_24:
    uint64_t v6 = (void *)*v5;
    uint64_t v7 = (void *)(a1 + 16);
  }
  while ((void *)*v5 != v5);
  if ((v32 & 1) == 0) {
    goto LABEL_30;
  }
LABEL_29:
  ++*(unsigned char *)(a1 + 82);
  *(unsigned char *)a1 = 1;
  sub_100245404(a1, *(unsigned __int16 *)(a1 + 4));
}

uint64_t sub_100245404(uint64_t a1, unsigned int a2)
{
  uint64_t v20 = 0;
  uint64_t v21 = 0;
  uint64_t v22 = 0;
  sub_10025B218(0x28u);
  int v18 = 327745535;
  __int16 v19 = 776;
  if (a2 <= 0x7F) {
    __int16 v4 = 5;
  }
  else {
    __int16 v4 = 6;
  }
  unsigned __int16 v5 = v4 + a2;
  __int16 v17 = v5;
  if (v5 > 0x80u)
  {
    if (*(unsigned __int16 *)(sub_10025B218(0x28u) + 8) >= v5) {
      goto LABEL_9;
    }
    __int16 v6 = *(_WORD *)(sub_10025B218(0x28u) + 8);
  }
  else
  {
    __int16 v6 = 128;
  }
  __int16 v17 = v6;
LABEL_9:
  *(unsigned char *)(a1 + 12) = 1;
  *(void *)(a1 + 32) = 0;
  uint64_t v7 = sub_1001DF7BC((uint64_t)sub_100247028, (uint64_t)sub_10024770C, (uint64_t)sub_100246F8C, 3, a1 + 6, (uint64_t)&v17, (_WORD *)(a1 + 2), (uint64_t)&unk_1007BAA20);
  if (v7)
  {
    if (sub_100058654())
    {
      sub_100056E24((uint64_t)"L2CAP_CreateConnection failed with result %!", v8, v9, v10, v11, v12, v13, v14, v7);
      __int16 v15 = sub_100050B4C(0x32u);
      if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR)) {
        sub_100745764();
      }
    }
    sub_1002450DC(a1, v7, 1);
  }
  else
  {
    *(unsigned char *)a1 = 2;
  }
  return v7;
}

void sub_100245570()
{
  uint64_t v0 = (_DWORD *)qword_100A10350;
  if (qword_100A10350 || (sub_10025B8C0(), (uint64_t v0 = (_DWORD *)qword_100A10350) != 0))
  {
    if ((*v0)-- == 1)
    {
      sub_10024633C();
    }
  }
}

uint64_t sub_1002455D0(uint64_t a1, __int16 a2, uint64_t *a3)
{
  uint64_t v9 = 0;
  uint64_t result = sub_10024563C(a1, &v9);
  if (!result)
  {
    uint64_t v7 = v9;
    __int16 v8 = *(_WORD *)(a1 + 4);
    *(_DWORD *)(v9 + 6) = *(_DWORD *)a1;
    *(_WORD *)(v7 + 10) = v8;
    *(unsigned char *)(v7 + 12) = 0;
    *(void *)(v7 + 32) = 0;
    *(_WORD *)(v7 + 2) = a2;
    *a3 = v7;
  }
  return result;
}

uint64_t sub_10024563C(uint64_t a1, uint64_t *a2)
{
  if (!dword_100A19878) {
    return 408;
  }
  if (!*(unsigned char *)qword_100A19778) {
    return 104;
  }
  unint64_t v3 = 0;
  uint64_t v4 = qword_100A10338;
  unsigned __int16 v5 = (unsigned __int8 *)qword_100A10338;
  do
  {
    *a2 = v4;
    int v6 = *v5;
    v5 += 88;
    if (v6)
    {
      int v7 = *(_DWORD *)(v4 + 6);
      int v8 = *(unsigned __int16 *)(v4 + 10);
      if (*(_DWORD *)a1 == v7 && *(unsigned __int16 *)(a1 + 4) == v8) {
        return 909;
      }
    }
    ++v3;
    unint64_t v10 = *(unsigned __int8 *)qword_100A19778;
    uint64_t v4 = (uint64_t)v5;
  }
  while (v3 < v10);
  if (!*(unsigned char *)qword_100A19778) {
    return 104;
  }
  for (uint64_t i = qword_100A10338; *(unsigned char *)i; i += 88)
  {
    if (!--v10) {
      return 104;
    }
  }
  *(_OWORD *)uint64_t i = 0u;
  *(void *)(i + 80) = 0;
  *(_OWORD *)(i + 48) = 0u;
  *(_OWORD *)(i + 64) = 0u;
  *(_OWORD *)(i + 16) = 0u;
  *(_OWORD *)(i + 32) = 0u;
  *(unsigned char *)uint64_t i = 1;
  *(_WORD *)(i + 44) = 257;
  sub_10025C0F0((void *)(i + 56));
  sub_10025C0F0((void *)(i + 16));
  uint64_t result = 0;
  *(unsigned char *)(i + 82) = 0;
  *a2 = i;
  ++*(_DWORD *)qword_100A10350;
  return result;
}

uint64_t sub_100245764(uint64_t a1)
{
  if (!a1) {
    sub_10025B8C0();
  }
  if (*(unsigned char *)(a1 + 13)) {
    sub_10025B8C0();
  }
  uint64_t v2 = sub_100247F44(a1);
  if (v2)
  {
    uint64_t v3 = v2;
    if (sub_100058654())
    {
      sub_100056E24((uint64_t)"DLCI: %d", v4, v5, v6, v7, v8, v9, v10, *(unsigned __int8 *)(a1 + 10));
      uint64_t v11 = sub_100050B4C(0x32u);
      if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR)) {
        sub_100748324();
      }
    }
    return v3;
  }
  else
  {
    unsigned int v13 = *(unsigned __int16 *)(a1 + 16);
    uint64_t v14 = *(void *)(a1 + 128);
    if (v13 >= *(unsigned __int16 *)(v14 + 4)) {
      LOWORD(v13) = *(_WORD *)(v14 + 4);
    }
    *(_WORD *)(a1 + 16) = v13;
    __int16 v15 = *(long long **)(a1 + 48);
    return sub_10025CE54((uint64_t)sub_100245858, v14 + 6, v15, (int *)(a1 + 56), 0);
  }
}

void sub_100245858(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = sub_100246E2C(a1);
  if (v4)
  {
    uint64_t v5 = v4;
    if (a2
      || (a2 = sub_100249F98(v4[16], 1, *((unsigned __int8 *)v4 + 10), 0, *((_WORD *)v4 + 8), *((unsigned char *)v4 + 14)),
          a2))
    {
      if (sub_100058654())
      {
        sub_100056E24((uint64_t)"connection failed", v6, v7, v8, v9, v10, v11, v12, v14);
        unsigned int v13 = sub_100050B4C(0x32u);
        if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR)) {
          sub_100748324();
        }
      }
      *((_DWORD *)v5 + 41) = a2;
      ((void (*)(void, void, uint64_t))v5[9])(*((unsigned __int16 *)v5 + 4), 0, a2);
      sub_100244D78(v5, 1);
    }
  }
  else
  {
    sub_10025D444(a1);
  }
}

uint64_t sub_100245944()
{
  uint64_t v0 = *(unsigned __int8 *)(qword_100A19778 + 1);
  if (!*(unsigned char *)(qword_100A19778 + 1)) {
    return 0;
  }
  LOWORD(result) = 0;
  uint64_t v2 = (unsigned __int16 *)(qword_100A10348 + 24);
  do
  {
    unsigned int v4 = *v2;
    v2 += 28;
    unsigned int v3 = v4;
    if (v4 <= (unsigned __int16)result) {
      uint64_t result = (unsigned __int16)result;
    }
    else {
      uint64_t result = v3;
    }
    --v0;
  }
  while (v0);
  return result;
}

uint64_t sub_100245988(uint64_t a1, int a2)
{
  if (!a2) {
    return 121;
  }
  uint64_t v2 = *(unsigned __int8 *)(qword_100A19778 + 1);
  if (!*(unsigned char *)(qword_100A19778 + 1)) {
    return 121;
  }
  for (uint64_t i = (unsigned __int8 *)(qword_100A10348 + 26); *i != a2; i += 56)
  {
    if (!--v2) {
      return 121;
    }
  }
  (*(void (**)(void))(i - 18))();
  return 0;
}

uint64_t sub_1002459F4(unsigned int a1, void *a2)
{
  if (!dword_100A19878) {
    return 408;
  }
  if (a1 >> 8 >= *(unsigned __int8 *)qword_100A19778) {
    return 916;
  }
  uint64_t v2 = (unsigned char *)(qword_100A10338 + 88 * (a1 >> 8));
  if (!*v2) {
    return 916;
  }
  uint64_t result = sub_100244A2C((uint64_t)v2, a1, a2);
  if (!result)
  {
    if (*(unsigned char *)(*a2 + 13) == 9) {
      return 927;
    }
    else {
      return 0;
    }
  }
  return result;
}

uint64_t sub_100245A8C(uint64_t a1, uint64_t a2, unsigned int a3, unsigned int a4, unsigned char *a5, uint64_t a6)
{
  if (dword_100A19878 || (uint64_t v14 = sub_100245C2C(), !v14))
  {
    ++*(_DWORD *)qword_100A10350;
    BOOL v13 = a4 < a3 && a4 != 0;
    uint64_t v14 = 101;
    if (a3 && !v13 && a1 && a2)
    {
      uint64_t v15 = *(unsigned __int8 *)(qword_100A19778 + 1);
      if (*(unsigned char *)(qword_100A19778 + 1))
      {
        unsigned int v16 = 0;
        uint64_t v17 = 0;
        uint64_t v18 = qword_100A10348;
        do
        {
          if (*(unsigned char *)(v18 + 26))
          {
            v16 |= 1 << *(unsigned char *)(v18 + 26);
          }
          else if (!v17)
          {
            *(_WORD *)(v18 + 24) = a3;
            uint64_t v17 = v18;
          }
          v18 += 56;
          --v15;
        }
        while (v15);
        if (v17)
        {
          int v19 = *a5;
          if ((v19 - 1) >= 0x1E) {
            unsigned int v20 = 1;
          }
          else {
            unsigned int v20 = *a5;
          }
          do
          {
            if (((v16 >> v20) & 1) == 0)
            {
              uint64_t v14 = 0;
              *(void *)(v17 + 8) = a1;
              *(void *)(v17 + 16) = a2;
              *(_WORD *)(v17 + 24) = a3;
              *(_WORD *)(v17 + 40) = a4 / a3;
              *(void *)(v17 + 48) = a6;
              *(unsigned char *)(v17 + 26) = v20;
              *a5 = v20;
              return v14;
            }
            unsigned int v20 = v20 % 0x1E + 1;
          }
          while (v20 != v19);
          if (sub_100058654())
          {
            sub_100056E24((uint64_t)"No free channel numbers", v21, v22, v23, v24, v25, v26, v27, v30);
            uint64_t v28 = sub_100050B4C(0x32u);
            if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR)) {
              sub_10074A9B4();
            }
          }
        }
      }
      uint64_t v14 = 104;
    }
    sub_100245570();
  }
  return v14;
}

uint64_t sub_100245C2C()
{
  if (dword_100A19878) {
    sub_10025B8C0();
  }
  uint64_t v0 = (unsigned __int8 *)sub_10025B218(0x32u);
  qword_100A19778 = (uint64_t)v0;
  if (!v0)
  {
    sub_10025B8C0();
    uint64_t v0 = (unsigned __int8 *)qword_100A19778;
    if (!qword_100A19778) {
      return 127;
    }
  }
  qword_100A10340 = 0;
  qword_100A10338 = 0;
  qword_100A10348 = 0;
  qword_100A10350 = 0;
  qword_100A10338 = (uint64_t)sub_10010CE48(88 * *v0);
  if (!qword_100A10338
    || (qword_100A10348 = (uint64_t)sub_10010CE48(56 * *(unsigned __int8 *)(qword_100A19778 + 1))) == 0)
  {
    uint64_t v2 = 106;
LABEL_11:
    if (qword_100A10350)
    {
      sub_100023010((void *)qword_100A10350);
      qword_100A10350 = 0;
    }
    goto LABEL_15;
  }
  uint64_t v1 = sub_10010CE48(4uLL);
  qword_100A10350 = (uint64_t)v1;
  if (v1)
  {
    *uint64_t v1 = 0;
    uint64_t v2 = sub_1001E5FF0(3, (uint64_t)sub_100247538);
    if (!v2)
    {
      dword_100A19878 = 1;
      return v2;
    }
    goto LABEL_11;
  }
  uint64_t v2 = 106;
LABEL_15:
  if (qword_100A10348)
  {
    sub_100023010((void *)qword_100A10348);
    qword_100A10348 = 0;
  }
  if (qword_100A10338)
  {
    sub_100023010((void *)qword_100A10338);
    qword_100A10338 = 0;
  }
  return v2;
}

uint64_t sub_100245D68(int a1)
{
  if (!dword_100A19878) {
    return 408;
  }
  if ((a1 - 31) < 0xFFFFFFE2) {
    return 101;
  }
  uint64_t v2 = *(unsigned __int8 *)(qword_100A19778 + 1);
  if (!*(unsigned char *)(qword_100A19778 + 1)) {
    return 120;
  }
  for (uint64_t i = (unsigned char *)(qword_100A10348 + 26); *i != a1; i += 56)
  {
    if (!--v2) {
      return 120;
    }
  }
  if (*(unsigned char *)qword_100A19778)
  {
    uint64_t v4 = 0;
    do
    {
      if (*(unsigned char *)(qword_100A10338 + 88 * v4))
      {
        uint64_t v5 = qword_100A10338 + 88 * v4;
        uint64_t v8 = *(void **)(v5 + 16);
        uint64_t v6 = (void *)(v5 + 16);
        for (j = v8; j && j != v6; j = (void *)*j)
        {
          if (*((unsigned char *)j - 124) && *((unsigned char *)j - 131) != 9 && a1 == *((unsigned __int8 *)j - 134) >> 1) {
            return 141;
          }
        }
      }
      ++v4;
    }
    while (v4 != *(unsigned __int8 *)qword_100A19778);
  }
  unsigned char *i = 0;
  *((_WORD *)i - 1) = 0;
  sub_100245570();
  return 0;
}

uint64_t sub_100245E68(uint64_t a1, unsigned int a2, uint64_t a3)
{
  return sub_100245E70(a1, a2, a3, 1);
}

uint64_t sub_100245E70(uint64_t a1, unsigned int a2, uint64_t a3, int a4)
{
  if (!dword_100A19878) {
    return 408;
  }
  if (!a1 || !a3)
  {
    sub_10025B8C0();
    return 101;
  }
  if (*(unsigned char *)(a3 + 1) || *(_WORD *)(a3 + 6)) {
    sub_10025B8C0();
  }
  unsigned int v8 = *(unsigned __int16 *)(a3 + 4);
  if (!*(_WORD *)(a3 + 4)) {
    return 101;
  }
  uint64_t v23 = 0;
  uint64_t v9 = sub_1002459F4(a2, &v23);
  if (!v9)
  {
    uint64_t v10 = v23;
    if (*(void *)(v23 + 88))
    {
      return 901;
    }
    else
    {
      uint64_t v12 = *(unsigned __int16 *)(v23 + 16);
      if (v8 <= v12 || a4)
      {
        *(void *)(v23 + 80) = a1;
        *(void *)(v10 + 88) = a3;
        sub_10025C9FC(a3, v12);
        BOOL v13 = sub_100247EE8(v23);
        uint64_t v14 = v23;
        if (v13)
        {
          *(unsigned char *)(v23 + 96) = 0;
          uint64_t v9 = sub_1002488B0(*(void *)(v14 + 128), *(unsigned __int8 *)(v14 + 10), a3, 0, 1);
          if (v9)
          {
            if (sub_100058654())
            {
              sub_100056E24((uint64_t)"DLCI: %d", v15, v16, v17, v18, v19, v20, v21, *(unsigned __int8 *)(v23 + 10));
              uint64_t v22 = sub_100050B4C(0x32u);
              if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR)) {
                sub_100748324();
              }
            }
            *(void *)(v23 + 88) = 0;
          }
        }
        else
        {
          uint64_t v9 = 0;
          *(unsigned char *)(v23 + 96) = 1;
        }
      }
      else
      {
        return 918;
      }
    }
  }
  return v9;
}

uint64_t sub_100245FEC(uint64_t a1, unsigned int a2, char *a3, size_t a4, int a5, int a6)
{
  if (!dword_100A19878) {
    return 408;
  }
  if (a1)
  {
    uint64_t v7 = 101;
    if (a3 && a4)
    {
      uint64_t v10 = sub_10025C6D8(a3, a4, a6);
      if (v10)
      {
        uint64_t v11 = v10;
        *((void *)v10 + 1) = a1;
        uint64_t v7 = sub_100245E70((uint64_t)sub_100246F10, a2, (uint64_t)v10, a5);
        if (v7) {
          sub_10025C53C(v11);
        }
      }
      else
      {
        return 106;
      }
    }
  }
  else
  {
    sub_10025B8C0();
    return 101;
  }
  return v7;
}

uint64_t sub_1002460B0(uint64_t a1, unsigned int a2, char *a3, size_t a4)
{
  return sub_100245FEC(a1, a2, a3, a4, 0, 0);
}

uint64_t sub_1002460BC(uint64_t a1, unsigned int a2, char *a3, size_t a4)
{
  return sub_100245FEC(a1, a2, a3, a4, 1, 2);
}

uint64_t sub_1002460C8(uint64_t a1, void *a2, uint64_t a3, char a4, unsigned int a5, unsigned int a6, _WORD *a7, uint64_t a8)
{
  uint64_t v39 = 0;
  if (!dword_100A19878)
  {
    uint64_t v18 = sub_100245C2C();
    if (v18) {
      return v18;
    }
  }
  if (!a2) {
    goto LABEL_19;
  }
  if (!a2[1])
  {
    sub_10025B8C0();
    if (!a2[1]) {
      return 101;
    }
  }
  if (!*a2)
  {
    sub_10025B8C0();
    if (!*a2) {
      return 101;
    }
  }
  if (!a1 || !a3)
  {
LABEL_19:
    sub_10025B8C0();
    return 101;
  }
  unsigned int v38 = *(_DWORD *)qword_100A10350;
  BOOL v17 = a6 < a5 && a6 != 0;
  uint64_t v18 = 101;
  if (!a5 || v17) {
    goto LABEL_33;
  }
  if ((a4 - 31) < 0xE2u)
  {
    uint64_t v18 = 910;
    goto LABEL_33;
  }
  uint64_t v40 = sub_10024501C(a3);
  uint64_t v20 = v40;
  uint64_t v37 = v40;
  if (!v40)
  {
    uint64_t v18 = sub_10024563C(a3, &v40);
    if (v18) {
      goto LABEL_33;
    }
    __int16 v26 = *(_WORD *)(a3 + 4);
    int v27 = *(_DWORD *)a3;
    uint64_t v28 = v40;
    *(_DWORD *)(v40 + 6) = v27;
    *(_WORD *)(v28 + 10) = v26;
    uint64_t v18 = sub_100245404(v28, a5);
    if (v18) {
      goto LABEL_33;
    }
    uint64_t v20 = v28;
  }
  unsigned int v21 = (*(unsigned __int8 *)(v20 + 12) | (2 * (a4 & 0x7F))) ^ 1;
  uint64_t v22 = (unsigned char *)v20;
  uint64_t v18 = sub_100244B90(v20, v21, &v39);
  if (v18)
  {
LABEL_33:
    if (sub_100058654())
    {
      sub_100056E24((uint64_t)"OI_RFCOMM_Connect failed", v29, v30, v31, v32, v33, v34, v35, v37);
      uint64_t v36 = sub_100050B4C(0x32u);
      if (os_log_type_enabled(v36, OS_LOG_TYPE_ERROR)) {
        sub_100748324();
      }
    }
    if (dword_100A19878)
    {
      if (*(_DWORD *)qword_100A10350 <= v38)
      {
        if (!*(_DWORD *)qword_100A10350) {
          sub_10024633C();
        }
      }
      else
      {
        sub_100245570();
      }
    }
    return v18;
  }
  uint64_t v23 = v22;
  uint64_t v24 = v39;
  *(void *)(v39 + 72) = a1;
  *(void *)(v24 + 40) = a2;
  *(_WORD *)(v24 + 16) = a5;
  if (a7) {
    *a7 = *(_WORD *)(v24 + 8);
  }
  *(_WORD *)(v24 + 160) = a6 / a5;
  *(void *)(v24 + 48) = a8;
  if (!v37 || *v23 != 7) {
    return 0;
  }
  uint64_t v25 = sub_100245764(v24);
  uint64_t v18 = v25;
  if (v25)
  {
    *(_DWORD *)(v24 + 164) = v25;
    sub_100244D78(v24, 1);
  }
  return v18;
}

void sub_10024633C()
{
  if (dword_100A19878 != 1) {
    sub_10025B8C0();
  }
  uint64_t v0 = sub_1001E61E4(3);
  if (v0)
  {
    uint64_t v1 = sub_10010B394(v0);
    sub_1002463C0(v1);
  }
  else
  {
    if (qword_100A10350)
    {
      sub_100023010((void *)qword_100A10350);
      qword_100A10350 = 0;
    }
    if (qword_100A10348)
    {
      sub_100023010((void *)qword_100A10348);
      qword_100A10348 = 0;
    }
    if (qword_100A10338)
    {
      sub_100023010((void *)qword_100A10338);
      qword_100A10338 = 0;
    }
    dword_100A19878 = 0;
  }
}

uint64_t sub_1002463C0(uint64_t a1, unsigned int a2, int a3)
{
  uint64_t v19 = 0;
  if (!dword_100A19878) {
    return 408;
  }
  if (!a1 && a3)
  {
    sub_10025B8C0();
    return 101;
  }
  uint64_t v6 = sub_1002459F4(a2, &v19);
  if (v6)
  {
    uint64_t v5 = v6;
    if (sub_100058654())
    {
      sub_100056E24((uint64_t)"OI_RFCOMM_Accept - linkhandle %d not found", v7, v8, v9, v10, v11, v12, v13, v19);
      uint64_t v14 = sub_100050B4C(0x32u);
      if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR)) {
        sub_100748324();
      }
    }
    return v5;
  }
  uint64_t v15 = v19;
  if (*(unsigned char *)(v19 + 13) != 3) {
    return 408;
  }
  *(void *)(v19 + 72) = a1;
  uint64_t v16 = *(void *)(v15 + 128);
  if (a3) {
    return sub_10025CE54((uint64_t)sub_100246514, v16 + 6, *(long long **)(v15 + 48), (int *)(v15 + 56), 1);
  }
  uint64_t v5 = sub_1002485D4(15, v16, *(unsigned __int8 *)(v15 + 10));
  uint64_t v18 = v19;
  if (v5)
  {
    *(_DWORD *)(v19 + 164) = v5;
    sub_100244D78(v18, 1);
  }
  else
  {
    if (!v19)
    {
      sub_10025B8C0();
      uint64_t v18 = v19;
    }
    uint64_t v5 = 0;
    *(unsigned char *)(v18 + 13) = 9;
  }
  return v5;
}

void sub_100246514(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v6 = sub_100246E2C(a1);
  if (v6)
  {
    uint64_t v7 = (uint64_t)v6;
    if (a2)
    {
      if (sub_100058654())
      {
        uint64_t v15 = "";
        if (a3) {
          uint64_t v15 = "Security failure, ";
        }
        sub_100056E24((uint64_t)"Policy enforcement failed, %s disconnecting ", v8, v9, v10, v11, v12, v13, v14, (uint64_t)v15);
        uint64_t v16 = sub_100050B4C(0x32u);
        if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR)) {
          sub_100748324();
        }
      }
      *(unsigned char *)(v7 + 13) = 9;
      *(_DWORD *)(v7 + 164) = a2;
      (*(void (**)(void, void, uint64_t))(v7 + 72))(*(unsigned __int16 *)(v7 + 8), 0, a2);
      int v17 = sub_1002485D4(15, *(void *)(v7 + 128), *(unsigned __int8 *)(v7 + 10));
      if (v17)
      {
        int v18 = v17;
        if (sub_100058654())
        {
          sub_100056E24((uint64_t)"send DM failed", v19, v20, v21, v22, v23, v24, v25, v40);
          __int16 v26 = sub_100050B4C(0x32u);
          if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR)) {
            sub_100748324();
          }
        }
        *(_DWORD *)(v7 + 164) = v18;
LABEL_21:
        sub_100244D78(v7, 1);
      }
    }
    else
    {
      uint64_t v27 = sub_1002485D4(99, v6[16], *((unsigned __int8 *)v6 + 10));
      if (v27)
      {
        uint64_t v28 = v27;
        if (sub_100058654())
        {
          sub_100056E24((uint64_t)"connection failed", v29, v30, v31, v32, v33, v34, v35, v40);
          uint64_t v36 = sub_100050B4C(0x32u);
          if (os_log_type_enabled(v36, OS_LOG_TYPE_ERROR)) {
            sub_100748324();
          }
        }
        *(unsigned char *)(v7 + 13) = 9;
        *(_DWORD *)(v7 + 164) = v28;
        (*(void (**)(void, void, uint64_t))(v7 + 72))(*(unsigned __int16 *)(v7 + 8), 0, v28);
        goto LABEL_21;
      }
      *(unsigned char *)(v7 + 13) = 4;
      uint64_t v37 = *(void *)(v7 + 128);
      char v38 = *(unsigned char *)(v7 + 10);
      char v39 = *(unsigned char *)(v7 + 12);
      sub_10024A338(v37, 1, v38, v39, 0);
    }
  }
  else
  {
    sub_10025D444(a1);
  }
}

uint64_t sub_100246730(unsigned int a1, int a2)
{
  if (!dword_100A19878) {
    return 408;
  }
  unsigned __int8 v2 = a1;
  uint64_t v7 = 0;
  if (a1 >> 8 >= *(unsigned __int8 *)qword_100A19778) {
    return 916;
  }
  unsigned int v3 = (unsigned char *)(qword_100A10338 + 88 * (a1 >> 8));
  if (!*v3) {
    return 916;
  }
  uint64_t result = sub_100244A2C((uint64_t)v3, a1, &v7);
  if (!result)
  {
    if (*(unsigned __int8 *)(v7 + 13) - 6 >= 4)
    {
      *(_DWORD *)(v7 + 164) = a2;
      uint64_t result = sub_1002485D4(67, (uint64_t)v3, v2);
      if (!result)
      {
        uint64_t v6 = v7;
        if (!v7)
        {
          sub_10025B8C0();
          uint64_t v6 = v7;
        }
        uint64_t result = 0;
        *(unsigned char *)(v6 + 13) = 6;
      }
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t sub_10024681C(unsigned int a1, uint64_t a2)
{
  if (!dword_100A19878) {
    return 408;
  }
  uint64_t v4 = 0;
  uint64_t result = sub_1002459F4(a1, &v4);
  if (result) {
    return 120;
  }
  *uint64_t v4 = a2;
  return result;
}

uint64_t sub_10024687C(unsigned int a1, uint64_t a2)
{
  uint64_t v10 = 0;
  uint64_t result = sub_1002459F4(a1, &v10);
  if (!result)
  {
    uint64_t v6 = v10;
    if (!v10)
    {
      sub_10025B8C0();
      uint64_t v6 = v10;
    }
    uint64_t v7 = *(void *)(v6 + 128);
    if (v7) {
      goto LABEL_12;
    }
    sub_10025B8C0();
LABEL_11:
    uint64_t v7 = *(void *)(v10 + 128);
LABEL_12:
    uint64_t v8 = (unsigned __int16 *)(v7 + 6);
    goto LABEL_13;
  }
  if (result == 927) {
    goto LABEL_11;
  }
  uint64_t v5 = (unsigned __int16 *)qword_100A10340;
  if (!qword_100A10340) {
    return result;
  }
  while (*v5 != a1)
  {
    uint64_t v5 = (unsigned __int16 *)*((void *)v5 + 4);
    if (!v5) {
      return result;
    }
  }
  uint64_t v8 = v5 + 1;
LABEL_13:
  uint64_t result = 0;
  int v9 = *(_DWORD *)v8;
  *(_WORD *)(a2 + 4) = v8[2];
  *(_DWORD *)a2 = v9;
  return result;
}

uint64_t sub_100246928(uint64_t a1, uint64_t a2, uint64_t a3, char a4, unsigned int a5, unsigned int a6, _WORD *a7, _WORD *a8, uint64_t a9, int a10)
{
  uint64_t v56 = 0;
  uint64_t v57 = 0;
  if (!dword_100A19878)
  {
    uint64_t v19 = sub_100245C2C();
    if (v19) {
      return v19;
    }
  }
  uint64_t v18 = sub_10024563C(a3, &v57);
  if (v18)
  {
    uint64_t v19 = v18;
    if (sub_100058654())
    {
      sub_100056E24((uint64_t)"OI_RFCOMM_createChannelForFastConnect Allocate Session failed", v20, v21, v22, v23, v24, v25, v26, v55[0]);
      uint64_t v27 = sub_100050B4C(0x32u);
      if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR)) {
        sub_100748324();
      }
    }
    return v19;
  }
  uint64_t v28 = v57;
  __int16 v29 = *(_WORD *)(a3 + 4);
  uint64_t v30 = v57;
  *(_DWORD *)(v57 + 6) = *(_DWORD *)a3;
  uint64_t v31 = v30 + 6;
  *(_WORD *)(v28 + 10) = v29;
  *(void *)(v28 + 32) = 0;
  sub_10025B218(0x28u);
  if (a5 <= 0x7F) {
    __int16 v32 = 5;
  }
  else {
    __int16 v32 = 6;
  }
  unsigned __int16 v33 = v32 + a5;
  if ((unsigned __int16)(v32 + a5) >= 0x81u)
  {
    if (*(unsigned __int16 *)(sub_10025B218(0x28u) + 8) < v33) {
      unsigned __int16 v33 = *(_WORD *)(sub_10025B218(0x28u) + 8);
    }
  }
  else
  {
    unsigned __int16 v33 = 128;
  }
  LOWORD(v55[0]) = v33;
  *(_DWORD *)((char *)v55 + 2) = 327745535;
  HIWORD(v55[0]) = 776;
  memset(&v55[1], 0, 24);
  uint64_t v34 = sub_1001DEF88(3, (uint64_t)v55, v31, (uint64_t)sub_100247028, (uint64_t)sub_10024770C, (uint64_t)sub_100246F8C, (_WORD *)(v28 + 2), (uint64_t)&unk_1007BAA20);
  if (v34)
  {
    uint64_t v19 = v34;
    *(unsigned char *)uint64_t v28 = 0;
    if (!sub_100058654()) {
      return v19;
    }
    sub_100056E24((uint64_t)"OI_RFCOMM_createChannelForFastConnect create L2CAP channel failed", v35, v36, v37, v38, v39, v40, v41, v55[0]);
    uint64_t v42 = sub_100050B4C(0x32u);
    if (!os_log_type_enabled(v42, OS_LOG_TYPE_ERROR)) {
      return v19;
    }
    goto LABEL_18;
  }
  *a8 = *(_WORD *)(v28 + 2);
  *(unsigned char *)(v28 + 12) = a10 != 0;
  unsigned int v43 = (2 * a4);
  if (a10) {
    uint64_t v44 = sub_100244B90(v28, v43, &v56);
  }
  else {
    uint64_t v44 = sub_100244AC4(v28, v43, &v56);
  }
  uint64_t v19 = v44;
  *(unsigned char *)(v28 + 12) = a10 != 0;
  if (v44)
  {
    *(unsigned char *)uint64_t v28 = 0;
    if (!sub_100058654()) {
      return v19;
    }
    sub_100056E24((uint64_t)"OI_RFCOMM_createChannelForFastConnect allocate link failed", v45, v46, v47, v48, v49, v50, v51, v55[0]);
    uint64_t v52 = sub_100050B4C(0x32u);
    if (!os_log_type_enabled(v52, OS_LOG_TYPE_ERROR)) {
      return v19;
    }
LABEL_18:
    sub_100748324();
    return v19;
  }
  uint64_t v53 = v56;
  *(void *)(v56 + 72) = a1;
  *(void *)(v53 + 40) = a2;
  *(_WORD *)(v53 + 16) = a5;
  if (a7) {
    *a7 = *(_WORD *)(v53 + 8);
  }
  *(_WORD *)(v53 + 160) = a6 / a5;
  *(void *)(v53 + 48) = a9;
  uint64_t v19 = sub_100247F44(v53);
  *(unsigned char *)uint64_t v28 = 7;
  return v19;
}

void sub_100246BF4(uint64_t a1, unsigned int a2)
{
  uint64_t v25 = 0;
  if (sub_1001DD56C(a2, (uint64_t *)&v25))
  {
    if (sub_100058654())
    {
      sub_100056E24((uint64_t)"OI_RFCOMM_FastConnectSetSessionMaxFrameSize L2CAP signal channel not found", v3, v4, v5, v6, v7, v8, v9, v24);
      uint64_t v10 = sub_100050B4C(0x32u);
      if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR)) {
LABEL_14:
      }
        sub_100745764();
    }
  }
  else
  {
    uint64_t v11 = sub_10024501C(a1);
    if (v11)
    {
      uint64_t v12 = v11;
      unsigned int v13 = *(unsigned __int16 *)(sub_1001E6484(v25) + 32);
      unsigned int v14 = *(unsigned __int16 *)(sub_1001E6484(v25) + 36);
      if (v13 < v14) {
        unsigned int v14 = v13;
      }
      if (v14 >= 0x85) {
        __int16 v15 = -6;
      }
      else {
        __int16 v15 = -5;
      }
      *(_WORD *)(v12 + 4) = v15 + v14;
    }
    else if (sub_100058654())
    {
      sub_100056E24((uint64_t)"OI_RFCOMM_FastConnectSetSessionMaxFrameSize Session not found", v16, v17, v18, v19, v20, v21, v22, v24);
      uint64_t v23 = sub_100050B4C(0x32u);
      if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR)) {
        goto LABEL_14;
      }
    }
  }
}

void sub_100246CFC(uint64_t a1, unsigned int a2)
{
  uint64_t v4 = sub_10024501C(a1);
  uint64_t v21 = 0;
  if (v4)
  {
    uint64_t v5 = (unsigned char *)v4;
    uint64_t v6 = v4 + 16;
    uint64_t v7 = (void *)(v4 + 16);
    do
    {
      uint64_t v8 = (void *)*v7;
      if (*v7 == v6) {
        break;
      }
      *((unsigned char *)v8 - 131) = 0;
      sub_100244D78((uint64_t)(v8 - 18), 0);
      uint64_t v7 = (void *)*v7;
    }
    while (v7);
    *uint64_t v5 = 0;
    sub_100249EE4((uint64_t)v5);
    sub_100249F20((uint64_t)v5);
    sub_1002483F0((uint64_t)v5);
    sub_100245570();
    uint64_t v9 = (void *)qword_100A10340;
    if (qword_100A10340)
    {
      do
      {
        uint64_t v10 = v9[4];
        sub_100023010(v9);
        qword_100A10340 = v10;
        uint64_t v9 = (void *)v10;
      }
      while (v10);
    }
    qword_100A10340 = 0;
  }
  if (a2 && !sub_1001DD56C(a2, &v21) && v21)
  {
    sub_1001DEC18(v21);
    uint64_t v11 = sub_100197A30(a1);
    if (v11)
    {
      sub_100182088(v11);
    }
    else if (sub_100058654())
    {
      sub_100056E24((uint64_t)"OI_RFCOMM_destroyChannelForFastConnect NULL Handle", v12, v13, v14, v15, v16, v17, v18, v20);
      uint64_t v19 = sub_100050B4C(0x32u);
      if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR)) {
        sub_100745764();
      }
    }
  }
}

void *sub_100246E2C(int a1)
{
  if (dword_100A19878)
  {
    if (*(unsigned char *)qword_100A19778)
    {
      uint64_t v1 = 0;
      do
      {
        if (qword_100A10338 && *(unsigned char *)(qword_100A10338 + 88 * v1))
        {
          unsigned __int8 v2 = (void *)(qword_100A10338 + 88 * v1 + 16);
          while (1)
          {
            unsigned __int8 v2 = (void *)*v2;
            if (!v2 || v2 == (void *)(qword_100A10338 + 88 * v1 + 16)) {
              break;
            }
            if (*((_DWORD *)v2 - 22) == a1) {
              return v2 - 18;
            }
          }
        }
        ++v1;
      }
      while (v1 != *(unsigned __int8 *)qword_100A19778);
    }
  }
  else if (sub_100058654())
  {
    sub_100056E24((uint64_t)"OI_GetLinkByPolicyHandle", v4, v5, v6, v7, v8, v9, v10, v13);
    uint64_t v11 = sub_100050B4C(0x32u);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR)) {
      sub_100749CC4();
    }
  }
  return 0;
}

uint64_t sub_100246F10(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (!a2) {
    sub_10025B8C0();
  }
  uint64_t v6 = *(uint64_t (**)(uint64_t, uint64_t, void, uint64_t))(a2 + 8);
  if (!v6)
  {
    sub_10025B8C0();
    uint64_t v6 = *(uint64_t (**)(uint64_t, uint64_t, void, uint64_t))(a2 + 8);
  }
  uint64_t v9 = 0;
  unsigned __int16 v8 = 0;
  sub_10025C5EC((unsigned __int8 *)a2, &v9, &v8);
  return v6(a1, v9, v8, a3);
}

void sub_100246F8C(int a1, uint64_t a2, uint64_t a3)
{
  if (dword_100A19878)
  {
    sub_100248BD8(a1, a2, a3);
  }
  else if (sub_100058654())
  {
    sub_100056E24((uint64_t)"%!", v3, v4, v5, v6, v7, v8, v9, 103);
    uint64_t v10 = sub_100050B4C(0x32u);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR)) {
      sub_100744F6C();
    }
  }
}

void sub_100247028(int a1, unsigned int a2, unsigned int a3, uint64_t a4)
{
  if (dword_100A19878)
  {
    uint64_t v7 = (unsigned char *)sub_100244F6C(a1);
    if (!v7) {
      return;
    }
    uint64_t v8 = (uint64_t)v7;
    if ((*v7 & 0xFE) != 2) {
      sub_10025B8C0();
    }
    if (a4)
    {
      sub_1002450DC(v8, a4, 0);
    }
    else
    {
      if (a3 >= a2) {
        unsigned int v17 = a2;
      }
      else {
        unsigned int v17 = a3;
      }
      if (v17 >= 0x85) {
        __int16 v18 = -6;
      }
      else {
        __int16 v18 = -5;
      }
      *(_WORD *)(v8 + 4) = v18 + v17;
      if (*(unsigned char *)v8 == 2)
      {
        if (sub_1002485D4(47, v8, 0)) {
          return;
        }
        char v19 = 5;
      }
      else
      {
        char v19 = 4;
      }
      *(unsigned char *)uint64_t v8 = v19;
    }
  }
  else if (sub_100058654())
  {
    sub_100056E24((uint64_t)"%!", v9, v10, v11, v12, v13, v14, v15, 103);
    uint64_t v16 = sub_100050B4C(0x32u);
    if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR)) {
      sub_100744F6C();
    }
  }
}

uint64_t sub_100247158(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a1 + 88);
  *(void *)(a1 + 88) = 0;
  sub_10025C574(v4);
  uint64_t v5 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1 + 80);
  uint64_t v6 = *(unsigned __int16 *)(a1 + 8);

  return v5(v6, v4, a2);
}

void sub_1002471B4(int a1, void *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = a4;
  uint64_t v57 = 0;
  if (!a4
    || !sub_100058654()
    || (sub_100056E24((uint64_t)"RFCOMM Write failed %!", v7, v8, v9, v10, v11, v12, v13, v4),
        uint64_t v14 = sub_100050B4C(0x32u),
        !os_log_type_enabled(v14, OS_LOG_TYPE_ERROR)))
  {
    if (a2) {
      goto LABEL_6;
    }
    goto LABEL_5;
  }
  sub_100744F6C();
  if (!a2) {
LABEL_5:
  }
    sub_10025B8C0();
LABEL_6:
  uint64_t v15 = sub_100244F6C(a1);
  if (v15)
  {
    uint64_t v16 = v15;
    if (*(void **)(v15 + 72) != a2) {
      sub_10025B8C0();
    }
    *(void *)(v16 + 72) = 0;
    sub_10025C53C(a2);
    int v17 = *(unsigned __int8 *)(v16 + 80);
    uint64_t v18 = *(unsigned __int8 *)(v16 + 81);
    if (!*(unsigned char *)(v16 + 80)) {
      goto LABEL_19;
    }
    uint64_t v19 = sub_100244A2C(v16, *(unsigned __int8 *)(v16 + 81), &v57);
    if (v19)
    {
      uint64_t v20 = v19;
      if (sub_100058654())
      {
        sub_100056E24((uint64_t)"%! (%d)", v21, v22, v23, v24, v25, v26, v27, v20);
        uint64_t v28 = sub_100050B4C(0x32u);
        if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR)) {
          sub_100744F6C();
        }
      }
      return;
    }
    if (v4) {
      goto LABEL_19;
    }
    if (!sub_10025CA4C(*(void *)(v57 + 88), *(unsigned __int16 *)(v57 + 16)))
    {
      uint64_t v4 = 0;
LABEL_19:
      if (*(void *)(v16 + 56) != v16 + 56)
      {
        uint64_t v37 = sub_10025C1A4((void **)(v16 + 56));
        uint64_t v38 = (void **)(v37 - 16);
        if (((uint64_t (*)(uint64_t (*)(), void, void, void, void))loc_1001DE1A4)(sub_1002471B4, *(unsigned __int16 *)(v16 + 2), 0, *(void *)(v37 - 16), 0))
        {
          sub_10025C53C(*v38);
          if (sub_100058654())
          {
            sub_100056E24((uint64_t)"Write failed", v39, v40, v41, v42, v43, v44, v45, v56);
            uint64_t v46 = sub_100050B4C(0x32u);
            if (os_log_type_enabled(v46, OS_LOG_TYPE_ERROR)) {
              sub_100744F6C();
            }
          }
        }
        else
        {
          *(_WORD *)(v16 + 80) = *(_WORD *)(v37 - 8);
          *(void *)(v16 + 72) = *(void *)(v37 - 16);
        }
        sub_100023010(v38);
      }
      if (v17)
      {
        uint64_t v47 = v57;
        if (!v57)
        {
          sub_10025B8C0();
          uint64_t v47 = v57;
        }
        uint64_t v48 = *(void *)(v47 + 88);
        *(void *)(v47 + 88) = 0;
        sub_10025C574(v48);
        (*(void (**)(void, uint64_t, uint64_t))(v47 + 80))(*(unsigned __int16 *)(v47 + 8), v48, v4);
      }
      else if (v18 && !sub_100244A2C(v16, v18, &v57))
      {
        uint64_t v49 = v57;
        int v50 = *(unsigned __int8 *)(v57 + 11);
        *(unsigned char *)(v57 + 11) = 0;
        if (v50 == 15)
        {
          int v53 = *(unsigned __int8 *)(v49 + 13);
          if (v53 != 6 && v53 != 9)
          {
            sub_10025B8C0();
            int v53 = *(unsigned __int8 *)(v49 + 13);
          }
          if (v53 == 9) {
            sub_100244D78(v49, 1);
          }
        }
        else if (v50 == 99)
        {
          int v51 = *(unsigned __int8 *)(v49 + 13);
          if (v51 == 8)
          {
            uint64_t v54 = *(void (**)(uint64_t, void, uint64_t))(v49 + 72);
            uint64_t v55 = *(unsigned __int16 *)(v49 + 8);
            sub_100244D78(v49, 0);
            v54(v55, 0, 927);
          }
          else if (v51 == 7)
          {
            *(_DWORD *)(v49 + 164) = 927;
            sub_10024856C(v49, 0);
          }
        }
      }
      return;
    }
    if (!sub_100247EE8(v57))
    {
      *(unsigned char *)(v57 + 96) = 1;
      return;
    }
    uint64_t v52 = sub_1002488B0(v16, v18, *(void *)(v57 + 88), 0, 1);
    if (v52)
    {
      uint64_t v4 = v52;
      if (v52 == 410)
      {
        sub_10025B8C0();
        uint64_t v4 = 410;
      }
      goto LABEL_19;
    }
  }
  else
  {
    if (sub_100058654())
    {
      sub_100056E24((uint64_t)"RFCOMM session has gone away - freeing orphaned MBUF %lx", v29, v30, v31, v32, v33, v34, v35, (uint64_t)a2);
      uint64_t v36 = sub_100050B4C(0x32u);
      if (os_log_type_enabled(v36, OS_LOG_TYPE_ERROR)) {
        sub_100744F6C();
      }
    }
    sub_10025C53C(a2);
  }
}

void sub_100247538(uint64_t a1, uint64_t a2, unsigned int a3)
{
  if (dword_100A19878)
  {
    uint64_t v23 = (unsigned char *)sub_10024501C(a2);
    if (v23 || sub_1002455D0(a2, a3, (uint64_t *)&v23))
    {
      unsigned int v5 = a3;
      uint64_t v6 = 0;
      int v7 = 0;
LABEL_5:
      sub_1001E0320((uint64_t)sub_100247028, (uint64_t)sub_10024770C, (uint64_t)sub_100246F8C, v5, (uint64_t)v6, v7, (uint64_t)&unk_1007BAA20);
      return;
    }
    uint64_t v16 = v23;
    if (!v23)
    {
      sub_10025B8C0();
      uint64_t v16 = v23;
    }
    *uint64_t v16 = 3;
    long long v21 = 0u;
    long long v22 = 0u;
    sub_10025B218(0x28u);
    *(_DWORD *)((char *)&v21 + 2) = 327745535;
    WORD3(v21) = 776;
    WORD6(v21) = 0;
    BYTE8(v22) = 0;
    unsigned int v17 = sub_100245944();
    __int16 v18 = sub_100245944();
    if (v17 <= 0x7F) {
      __int16 v19 = 5;
    }
    else {
      __int16 v19 = 6;
    }
    LOWORD(v21) = v18 + v19;
    if ((unsigned __int16)(v18 + v19) > 0x80u)
    {
      if (*(unsigned __int16 *)(sub_10025B218(0x28u) + 8) >= (unsigned __int16)(v18 + v19))
      {
LABEL_20:
        uint64_t v6 = &v21;
        unsigned int v5 = a3;
        int v7 = 1;
        goto LABEL_5;
      }
      __int16 v20 = *(_WORD *)(sub_10025B218(0x28u) + 8);
    }
    else
    {
      __int16 v20 = 128;
    }
    LOWORD(v21) = v20;
    goto LABEL_20;
  }
  if (sub_100058654())
  {
    sub_100056E24((uint64_t)"%!", v8, v9, v10, v11, v12, v13, v14, 103);
    uint64_t v15 = sub_100050B4C(0x32u);
    if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR)) {
      sub_100744F6C();
    }
  }
}

void sub_10024770C(int a1, uint64_t a2)
{
  if (sub_100058654())
  {
    sub_100056E24((uint64_t)"RFCOMM's L2CAP link disconnected uint64_t result = %!", v4, v5, v6, v7, v8, v9, v10, a2);
    uint64_t v11 = sub_100050B4C(0x32u);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 136446210;
      long long v22 = sub_100050714();
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
    }
  }
  if (dword_100A19878)
  {
    uint64_t v12 = (unsigned __int8 *)sub_100244F6C(a1);
    if (v12) {
      sub_1002450DC(v12, a2, *v12 == 10);
    }
  }
  else if (sub_100058654())
  {
    sub_100056E24((uint64_t)"%!", v13, v14, v15, v16, v17, v18, v19, 103);
    __int16 v20 = sub_100050B4C(0x32u);
    if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR)) {
      sub_100744F6C();
    }
  }
}

uint64_t sub_100247858(uint64_t a1)
{
  sub_10025B778("BTVirtualTransportRegisterCBs\n");
  if (a1
    && *(void *)a1
    && (unsigned __int8 v2 = *(void **)(a1 + 8)) != 0
    && (uint64_t v3 = *(void **)(a1 + 16)) != 0
    && (uint64_t v4 = *(void **)(a1 + 24)) != 0
    && (uint64_t v5 = *(void **)(a1 + 32)) != 0)
  {
    uint64_t result = 0;
    off_100A10358 = *(_UNKNOWN **)a1;
    off_100A10360 = v2;
    off_100A10368 = v3;
    off_100A10370 = v4;
    off_100A10378 = v5;
  }
  else
  {
    sub_10025B778("BTVirtualTransportRegisterCBs invalid cbs\n");
    return 114;
  }
  return result;
}

uint64_t sub_1002478F0()
{
  if (qword_100A10380 != -1) {
    dispatch_once(&qword_100A10380, &stru_10099F368);
  }
  if (qword_100A10388) {
    return 0;
  }
  else {
    return 114;
  }
}

void sub_100247940(int a1, int a2, unsigned int a3)
{
  if (!off_100A10370) {
    sub_10025B8C0();
  }
  sub_10025B778("BTVirtual transport send packet type: 0x%x\n", a1);
  if (a1 == 1)
  {
    unsigned int v6 = 3;
    uint64_t v7 = &qword_100A10398;
  }
  else
  {
    if (a1 != 2)
    {
      sub_10025B778("Virtual transport default packet type: 0x%x\n", a1);
      return;
    }
    unsigned int v6 = 4;
    uint64_t v7 = &qword_100A103A8;
  }
  uint64_t v8 = *v7;
  uint64_t v9 = v6;
  uint64_t v10 = malloc_type_malloc(v6 + (unint64_t)a3, 0x5F94FA6AuLL);
  if (!v10) {
    sub_10074AA40();
  }
  uint64_t v11 = v10;
  *(_WORD *)uint64_t v10 = a2;
  v10[2] = a3;
  if (a1 == 2) {
    v10[3] = BYTE1(a3);
  }
  if (a3) {
    sub_100022CA0(&v10[v9]);
  }
  else {
    sub_100023604();
  }
  sub_10025B778("BTVirtual transport send packet type: 0x%x 0x%x\n", a1, a2);
  int v12 = 0;
  if ((off_100A10370(v8, v11, v9 + a3, &v12, 0xFFFFFFFFLL, sub_100247EAC) & 1) == 0
    && (byte_100A10390 & 1) == 0)
  {
    sub_10025B778("Virtual transport write failed: type %u\n", a1);
    __break(1u);
  }
}

uint64_t sub_100247AC8()
{
  return 0;
}

void sub_100247AD0(id a1)
{
  uint64_t v1 = dispatch_queue_attr_make_with_qos_class(0, QOS_CLASS_DEFAULT, 0);
  qword_100A10388 = (uint64_t)dispatch_queue_create("com.apple.bluetoothd.virtual-event", v1);
}

uint64_t sub_100247B0C()
{
  return 0;
}

uint64_t sub_100247B14()
{
  sub_10025B778("BTVirtual transport init");
  if (off_100A10358) {
    BOOL v0 = off_100A10360 == 0;
  }
  else {
    BOOL v0 = 1;
  }
  if (v0 || off_100A10368 == 0 || off_100A10370 == 0 || off_100A10378 == 0)
  {
    sub_10025B778("BTVirtual transport init failed, callbacks error");
    return 633;
  }
  else
  {
    uint64_t v11 = 0;
    long long v9 = 0u;
    long long v10 = 0u;
    long long v7 = 0u;
    long long v8 = 0u;
    long long v6 = 0u;
    byte_100A10390 = 0;
    off_100A10358(&v6);
    LODWORD(v6) = 2;
    DWORD2(v7) = 5000;
    LODWORD(v8) = v8 | 0xC;
    *(void *)((char *)&v8 + 4) = 0x10200000020;
    LODWORD(v11) = 25;
    *(void *)&long long v7 = &stru_10099F3A8;
    *(void *)&long long v9 = &stru_10099F3E8;
    *((void *)&v9 + 1) = &stru_10099F428;
    char v5 = off_100A10360(&v6, &qword_100A10398);
    uint64_t result = 0;
    if ((v5 & 1) == 0) {
      sub_10074AA5C();
    }
  }
  return result;
}

void sub_100247C30(id a1, int a2, void *a3, void *a4)
{
}

void sub_100247C60(id a1, int a2, void *a3, unsigned int a4)
{
  sub_10025B778("BTVirtual readCompletionBlock: %d\n", a2);
  sub_10025B778("BTVirtual handle_read type %u, status 0x%x, size %d\n", 4, a2, a4);
  if (!a2)
  {
    if ((byte_100A10390 & 1) == 0)
    {
      if ((byte_100A103A0 & 1) == 0)
      {
        v8[1] = 0;
        v8[0] = mach_continuous_time();
        long long v7 = sub_100023568(4, (unsigned __int8 *)a3, (unsigned __int16)a4);
        sub_10025B778("BTVirtual handle_read OI_HCIIfc_DataReceived\n");
        sub_100023868(4, (unsigned __int8 *)a3, v7, (uint64_t)v8);
        if (!a3) {
          return;
        }
LABEL_8:
        free(a3);
        return;
      }
      sub_10025B778("BTVirtual handle_read OI_SNIFF_LogReceive\n");
      sub_100025840();
    }
    if (!a3) {
      return;
    }
    goto LABEL_8;
  }
  if ((byte_100A10390 & 1) == 0) {
    sub_10025B778("Virtual read failed: type %u, status 0x%x\n", 4, a2);
  }
}

void sub_100247D68(id a1, int a2, void *a3, unsigned int a4)
{
  if (a2)
  {
    if ((byte_100A10390 & 1) == 0)
    {
      sub_10025B778("Virtual transport HCI write failed: 0x%x\n", a2);
      __break(1u);
    }
  }
}

void sub_100247DA8()
{
  sub_10025B778("BTVirtual transport free\n");
  if (off_100A10378) {
    BOOL v0 = off_100A10368 == 0;
  }
  else {
    BOOL v0 = 1;
  }
  if (!v0)
  {
    if (off_100A10378(qword_100A10398) && (off_100A10368(&qword_100A10398) & 1) == 0) {
      sub_10074AAB4();
    }
    if (off_100A10378(qword_100A103A8) && (off_100A10368(&qword_100A103A8) & 1) == 0) {
      sub_10074AA98();
    }
    if (off_100A10378(qword_100A103B0))
    {
      if ((off_100A10368(&qword_100A103B0) & 1) == 0) {
        sub_10074AA7C();
      }
    }
  }
}

uint64_t sub_100247E6C()
{
  return 0;
}

uint64_t sub_100247E74()
{
  return 0;
}

uint64_t sub_100247EA4()
{
  return 2594;
}

void sub_100247EAC(void *a1)
{
  if (a1) {
    free(a1);
  }
}

uint64_t sub_100247EB8()
{
  return 0;
}

uint64_t sub_100247EC0()
{
  return 0;
}

void sub_100247EC8()
{
  byte_100A10390 = 1;
}

void sub_100247ED8()
{
  byte_100A103A0 = 1;
}

BOOL sub_100247EE8(uint64_t a1)
{
  if (!a1) {
    sub_10025B8C0();
  }
  uint64_t v2 = *(void *)(a1 + 128);
  if (!*(unsigned char *)(v2 + 44)) {
    return *(unsigned char *)(a1 + 32) && *(unsigned char *)(v2 + 45);
  }
  return *(_WORD *)(a1 + 18) != 0;
}

uint64_t sub_100247F44(uint64_t a1)
{
  if (!a1) {
    sub_10025B8C0();
  }
  unsigned int v2 = *(unsigned __int16 *)(a1 + 160);
  if (!*(_WORD *)(a1 + 160))
  {
    uint64_t result = 0;
    *(unsigned char *)(a1 + 162) = 0;
    goto LABEL_13;
  }
  if (v2 >= 0xFF) {
    unsigned int v2 = 255;
  }
  *(unsigned char *)(a1 + 162) = v2;
  uint64_t v3 = (unsigned char *)(a1 + 162);
  *(unsigned char *)(a1 + 163) = 0;
  uint64_t v4 = sub_100022FE8(24 * v2);
  *(void *)(a1 + 104) = v4;
  if (v4)
  {
    if (*v3)
    {
      uint64_t v5 = 0;
      unint64_t v6 = 0;
      while (1)
      {
        long long v7 = sub_100022FE8(*(unsigned __int16 *)(a1 + 16));
        long long v8 = *(char **)(a1 + 104);
        long long v9 = &v8[v5];
        *(void *)long long v9 = v7;
        *((_WORD *)v9 + 4) = 0;
        if (!v7) {
          break;
        }
        ++v6;
        v5 += 24;
        if (v6 >= *v3) {
          goto LABEL_11;
        }
      }
      if (v6)
      {
        uint64_t v11 = 0;
        do
        {
          sub_100023010(*(void **)(*(void *)(a1 + 104) + v11));
          v11 += 24;
          --v6;
        }
        while (v6);
        long long v8 = *(char **)(a1 + 104);
      }
      sub_100023010(v8);
      uint64_t result = 106;
      goto LABEL_14;
    }
LABEL_11:
    uint64_t result = 0;
LABEL_13:
    uint64_t v3 = (unsigned char *)(a1 + 14);
LABEL_14:
    *uint64_t v3 = 0;
    return result;
  }
  return 106;
}

uint64_t sub_10024803C(uint64_t a1)
{
  if (!a1) {
    sub_10025B8C0();
  }
  if (*(unsigned char *)(a1 + 162))
  {
    uint64_t v2 = sub_10024813C(a1);
    if (v2)
    {
      int v3 = 0;
      int v4 = 0;
      do
      {
        v4 += *(unsigned __int16 *)(v2 + 8);
        uint64_t v2 = sub_10024813C(a1);
        --v3;
      }
      while (v2);
      if (v3)
      {
        if (sub_100058654())
        {
          sub_100056E24((uint64_t)"%d rcv packets discarded (%d bytes total)", v5, v6, v7, v8, v9, v10, v11, -v3);
          int v12 = sub_100050B4C(0x32u);
          if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR)) {
            sub_100744F6C();
          }
        }
      }
    }
    if (*(unsigned char *)(a1 + 162))
    {
      uint64_t v13 = 0;
      unint64_t v14 = 0;
      do
      {
        sub_100023010(*(void **)(*(void *)(a1 + 104) + v13));
        ++v14;
        v13 += 24;
      }
      while (v14 < *(unsigned __int8 *)(a1 + 162));
      if (*(unsigned char *)(a1 + 162))
      {
        sub_100023010(*(void **)(a1 + 104));
        *(void *)(a1 + 104) = 0;
        *(_WORD *)(a1 + 162) = 0;
      }
    }
  }
  return 0;
}

uint64_t sub_10024813C(uint64_t a1)
{
  if (!a1) {
    sub_10025B8C0();
  }
  uint64_t result = *(void *)(a1 + 112);
  if (result)
  {
    *(void *)(a1 + 112) = *(void *)(result + 16);
    if (result == *(void *)(a1 + 120)) {
      *(void *)(a1 + 120) = 0;
    }
    --*(unsigned char *)(a1 + 163);
  }
  return result;
}

uint64_t sub_100248190(uint64_t a1, const void *a2, uint64_t a3)
{
  if (!a1) {
    sub_10025B8C0();
  }
  unsigned int v6 = *(unsigned __int16 *)(a1 + 16);
  if (v6 >= a3)
  {
    if (!a3) {
      return 0;
    }
  }
  else
  {
    sub_10025B8C0();
    unsigned int v6 = *(unsigned __int16 *)(a1 + 16);
  }
  if (v6 < a3)
  {
    if (sub_100058654())
    {
      sub_100056E24((uint64_t)"Received RFCOMM packet with larger payload size %d than set on link (%d)", v7, v8, v9, v10, v11, v12, v13, a3);
      unint64_t v14 = sub_100050B4C(0x32u);
      if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR)) {
        sub_100744F6C();
      }
    }
    return 104;
  }
  if (!*(unsigned char *)(a1 + 162)) {
    return 104;
  }
  uint64_t v15 = 0;
  uint64_t v16 = *(void *)(a1 + 104);
  while (1)
  {
    uint64_t v17 = v16 + v15;
    if (!*(_WORD *)(v16 + v15 + 8)) {
      break;
    }
    v15 += 24;
    if (24 * *(unsigned __int8 *)(a1 + 162) == v15) {
      return 104;
    }
  }
  *(_WORD *)(v17 + 8) = a3;
  memmove(*(void **)v17, a2, a3);
  uint64_t v19 = *(void *)(a1 + 104);
  if (!v19) {
    sub_10025B8C0();
  }
  uint64_t v20 = v19 + v15;
  long long v21 = (void *)(a1 + 112);
  if (*(void *)(a1 + 112)) {
    long long v21 = (void *)(*(void *)(a1 + 120) + 16);
  }
  uint64_t result = 0;
  *long long v21 = v20;
  *(void *)(v19 + v15 + 16) = 0;
  *(void *)(a1 + 120) = v20;
  ++*(unsigned char *)(a1 + 163);
  return result;
}

uint64_t sub_1002482D4(uint64_t a1, unsigned int a2)
{
  if (!a1) {
    sub_10025B8C0();
  }
  if (!*(unsigned char *)(*(void *)(a1 + 128) + 44)) {
    sub_10025B8C0();
  }
  if (*(unsigned __int8 *)(a1 + 14) + a2 >= 0x100) {
    sub_10025B8C0();
  }
  uint64_t result = sub_100248ABC(*(void *)(a1 + 128), *(unsigned __int8 *)(a1 + 10), 0, 0, a2);
  if (!result) {
    *(unsigned char *)(a1 + 14) += a2;
  }
  return result;
}

uint64_t sub_10024834C(uint64_t a1)
{
  if (!a1) {
    sub_10025B8C0();
  }
  uint64_t result = sub_100247EE8(a1);
  if (result && *(unsigned char *)(a1 + 96))
  {
    uint64_t result = sub_1002488B0(*(void *)(a1 + 128), *(unsigned __int8 *)(a1 + 10), *(void *)(a1 + 88), 0, 1);
    if (!result) {
      *(unsigned char *)(a1 + 96) = 0;
    }
  }
  return result;
}

void sub_1002483A8(uint64_t a1)
{
  if (!a1) {
    sub_10025B8C0();
  }
  int v4 = *(void **)(a1 + 16);
  uint64_t v2 = (void *)(a1 + 16);
  for (uint64_t i = v4; i && i != v2; uint64_t i = (void *)*i)
    sub_10024834C((uint64_t)(i - 18));
}

uint64_t sub_1002483F0(uint64_t a1)
{
  if (!a1) {
    sub_10025B8C0();
  }
  uint64_t v2 = *(unsigned int *)(a1 + 40);

  return sub_100026DB4(v2);
}

uint64_t sub_10024842C(uint64_t a1, int a2)
{
  uint64_t v15 = a1;
  v14[0] = 0;
  int v3 = (int *)(a1 + 40);
  sub_100026DB4(*(unsigned int *)(a1 + 40));
  v14[1] = &v15;
  LOWORD(v14[0]) = 8;
  uint64_t v4 = sub_1000268E4((uint64_t)sub_1002484E8, v14, a2, v3);
  if (v4)
  {
    if (sub_100058654())
    {
      sub_100056E24((uint64_t)"Error registering session shutdown dispatch - %!", v5, v6, v7, v8, v9, v10, v11, v4);
      uint64_t v12 = sub_100050B4C(0x32u);
      if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR)) {
        sub_100744F6C();
      }
    }
  }
  return v4;
}

void sub_1002484E8(uint64_t a1)
{
  uint64_t v1 = sub_100244E24(**(void **)(a1 + 8), 1, 930);
  if (v1)
  {
    uint64_t v2 = v1;
    if (sub_100058654())
    {
      sub_100056E24((uint64_t)"RFCOMM session shutdown failed - %!", v3, v4, v5, v6, v7, v8, v9, v2);
      uint64_t v10 = sub_100050B4C(0x32u);
      if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR)) {
        sub_100744F6C();
      }
    }
  }
}

uint64_t sub_10024856C(uint64_t a1, uint64_t a2)
{
  if (!a1) {
    sub_10025B8C0();
  }
  *(unsigned char *)(a1 + 13) = 9;
  sub_100244C94(a1);
  (**(void (***)(void, void))(a1 + 40))(*(unsigned __int16 *)(a1 + 8), *(unsigned int *)(a1 + 164));

  return sub_100244D78(a1, a2);
}

uint64_t sub_1002485D4(int a1, uint64_t a2, uint64_t a3)
{
  if (((a1 - 47) > 0x34 || ((1 << (a1 - 47)) & 0x10000000100001) == 0) && a1 != 15) {
    sub_10025B8C0();
  }
  if (*(unsigned char *)(a2 + 12)) {
    int v6 = 67;
  }
  else {
    int v6 = 99;
  }
  if (*(unsigned char *)(a2 + 12)) {
    int v7 = 47;
  }
  else {
    int v7 = 15;
  }
  if (v7 == a1 || v6 == a1) {
    char v9 = 3;
  }
  else {
    char v9 = 1;
  }
  __int16 v28 = 1;
  v27[0] = v9 | (4 * a3);
  v27[1] = a1 | 0x10;
  HIBYTE(v28) = sub_100249CC8(v27, 3);
  uint64_t v10 = sub_10025C6D8(v27, 4uLL, 0);
  if (!v10) {
    return 106;
  }
  uint64_t v11 = v10;
  uint64_t v12 = sub_10024879C(a2, a3, v10, 0);
  if (!v12)
  {
    uint64_t v26 = 0;
    if (a3)
    {
      uint64_t v22 = sub_100244A2C(a2, a3, &v26);
      if (v22) {
        return v22;
      }
      uint64_t v23 = v26;
      *(unsigned char *)(v26 + 11) = a1;
      if (a1 == 47)
      {
        char v24 = 2;
      }
      else
      {
        if (a1 != 67) {
          return 0;
        }
        char v24 = 6;
      }
      *(unsigned char *)(v23 + 13) = v24;
    }
    else if (a1 != 47 && a1 != 67)
    {
      return 0;
    }
    sub_100249D80(a2);
    return 0;
  }
  uint64_t v13 = v12;
  if (sub_100058654())
  {
    sub_100056E24((uint64_t)"%! (%d)", v14, v15, v16, v17, v18, v19, v20, v13);
    long long v21 = sub_100050B4C(0x32u);
    if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR)) {
      sub_100744F6C();
    }
  }
  sub_10025C53C(v11);
  return v13;
}

uint64_t sub_10024879C(uint64_t a1, char a2, uint64_t a3, char a4)
{
  if (!a1) {
    sub_10025B8C0();
  }
  int v8 = ((uint64_t (*)(void (*)(int, void *, uint64_t, uint64_t), void, void, uint64_t, void))loc_1001DE1A4)(sub_1002471B4, *(unsigned __int16 *)(a1 + 2), 0, a3, 0);
  if (!v8)
  {
    uint64_t v10 = 0;
    *(unsigned char *)(a1 + 80) = a4;
    *(unsigned char *)(a1 + 81) = a2;
    *(void *)(a1 + 72) = a3;
    return v10;
  }
  if (v8 == 410)
  {
    char v9 = sub_100022FE8(0x20uLL);
    if (v9)
    {
      *(void *)char v9 = a3;
      v9[8] = a4;
      v9[9] = a2;
      sub_10025C10C((void *)v9 + 2, a1 + 56);
      return 0;
    }
    return 106;
  }
  uint64_t v11 = sub_100022FE8(0x20uLL);
  if (!v11) {
    return 106;
  }
  uint64_t v12 = v11;
  *uint64_t v11 = a3;
  *((unsigned char *)v11 + 8) = a4;
  uint64_t v13 = v11 + 2;
  *((unsigned char *)v11 + 9) = a2;
  sub_10025C10C(v11 + 2, a1 + 56);
  uint64_t v10 = sub_10024842C(a1, 0);
  if (v10)
  {
    sub_10025C120(v13);
    sub_100023010(v12);
  }
  return v10;
}

uint64_t sub_1002488B0(uint64_t a1, int a2, uint64_t a3, unsigned int a4, char a5)
{
  if (a1)
  {
    if (a3) {
      goto LABEL_3;
    }
  }
  else
  {
    sub_10025B8C0();
    if (a3) {
      goto LABEL_3;
    }
  }
  sub_10025B8C0();
LABEL_3:
  char v22 = 0;
  int v21 = 0;
  uint64_t v19 = 0;
  unsigned int v10 = *(unsigned __int16 *)(a3 + 4);
  size_t v11 = sub_100248A30(a1, a2, v10, a4, &v21);
  char v20 = sub_100249CC8((char *)&v21, 2);
  uint64_t v12 = (unsigned __int8 *)sub_10025C1E0(3u);
  if (!v12) {
    return 106;
  }
  uint64_t v13 = v12;
  sub_100022798(v12, (char *)&v21, v11, 0);
  sub_10025C92C(v13, a3);
  sub_100022798(v13, &v20, 1uLL, 0);
  if (*(unsigned char *)(a1 + 44) && a2 && v10)
  {
    uint64_t v14 = sub_100244A2C(a1, a2, &v19);
    if (v14)
    {
LABEL_14:
      sub_10025C53C(v13);
      return v14;
    }
    uint64_t v15 = v19;
    int v16 = *(unsigned __int8 *)(v19 + 14);
    if (v16 + a4 >= 0x100)
    {
      sub_10025B8C0();
      uint64_t v15 = v19;
      LOBYTE(v16) = *(unsigned char *)(v19 + 14);
    }
    *(unsigned char *)(v15 + 14) = v16 + a4;
    __int16 v17 = *(_WORD *)(v15 + 18);
    if (!v17)
    {
      sub_10025B8C0();
      uint64_t v15 = v19;
      __int16 v17 = *(_WORD *)(v19 + 18);
    }
    *(_WORD *)(v15 + 18) = v17 - 1;
  }
  uint64_t v14 = sub_10024879C(a1, a2, (uint64_t)v13, a5);
  if (v14) {
    goto LABEL_14;
  }
  return v14;
}

uint64_t sub_100248A30(uint64_t a1, char a2, unsigned int a3, unsigned int a4, unsigned char *a5)
{
  if (*(unsigned char *)(a1 + 12)) {
    char v5 = 3;
  }
  else {
    char v5 = 1;
  }
  *a5 = v5 | (4 * a2);
  char v6 = 2 * a3;
  if (a4)
  {
    a5[1] = -1;
    if (a3 < 0x80)
    {
      a5[2] = v6 | 1;
LABEL_11:
      uint64_t result = 4;
      uint64_t v8 = 3;
      goto LABEL_12;
    }
    a5[2] = v6;
    a5[3] = a3 >> 7;
    uint64_t result = 5;
    uint64_t v8 = 4;
  }
  else
  {
    a5[1] = -17;
    if (a3 >= 0x80)
    {
      a5[2] = v6;
      a4 = a3 >> 7;
      goto LABEL_11;
    }
    LOBYTE(a4) = v6 | 1;
    uint64_t result = 3;
    uint64_t v8 = 2;
  }
LABEL_12:
  a5[v8] = a4;
  return result;
}

uint64_t sub_100248ABC(uint64_t a1, uint64_t a2, char *a3, size_t a4, unsigned int a5)
{
  if (a2 && a4) {
    sub_10025B8C0();
  }
  unsigned int v10 = sub_10025C1E0(3u);
  if (!v10) {
    return 106;
  }
  size_t v11 = (unsigned __int8 *)v10;
  char v17 = 0;
  int v15 = 0;
  char v16 = 0;
  size_t v12 = sub_100248A30(a1, a2, a4, a5, &v15);
  uint64_t v13 = sub_100022798(v11, (char *)&v15, v12, 0);
  if (v13
    || (uint64_t v13 = sub_100022798(v11, a3, a4, 0), v13)
    || (v17 = sub_100249CC8((char *)&v15, 2), uint64_t v13 = sub_100022798(v11, &v17, 1uLL, 0), v13)
    || (uint64_t v13 = sub_10024879C(a1, a2, v11, 0), v13))
  {
    sub_10025C53C(v11);
  }
  return v13;
}

void sub_100248BD8(int a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = sub_100244F6C(a1);
  if (!v5) {
    return;
  }
  if (a3 > 3)
  {
    uint64_t v14 = (unsigned __int8 *)v5;
    int v15 = *(unsigned __int8 *)(a2 + 1);
    unsigned int v16 = v15 & 0xFFFFFFEF;
    if ((v15 & 0xFFFFFFEF) - 47 > 0x34 || ((1 << ((v15 & 0xEFu) - 47)) & 0x10000000100001) == 0)
    {
      if (v16 == 239)
      {
        if (sub_100249D4C(*(unsigned char *)a2, v15, *(unsigned __int8 *)(a2 + (a3 - 1))))
        {
          if (sub_100058654())
          {
            sub_100056E24((uint64_t)"UIH FCS Error: %@", v27, v28, v29, v30, v31, v32, v33, a2);
            uint64_t v34 = sub_100050B4C(0x32u);
            if (os_log_type_enabled(v34, OS_LOG_TYPE_ERROR)) {
              goto LABEL_26;
            }
          }
        }
        else
        {
          sub_1002497C8(v14, (unsigned __int8 *)a2, a3, v26);
        }
        return;
      }
      if (v16 != 15) {
        return;
      }
    }
    if (sub_100249D0C(*(unsigned char *)a2, v15, *(unsigned char *)(a2 + 2), *(unsigned __int8 *)(a2 + (a3 - 1))))
    {
      if (sub_100058654())
      {
        sub_100056E24((uint64_t)"FCS Error: %@", v18, v19, v20, v21, v22, v23, v24, a2);
        uint64_t v25 = sub_100050B4C(0x32u);
        if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR)) {
          goto LABEL_26;
        }
      }
    }
    else if (v16 > 0x42u)
    {
      if (v16 == 67)
      {
        sub_1002492EC(v14, (unsigned __int8 *)a2);
      }
      else if (v16 == 99)
      {
        sub_10024902C(v14, (unsigned __int8 *)a2);
      }
    }
    else if (v16 == 15)
    {
      sub_100249564(v14, (unsigned __int8 *)a2);
    }
    else if (v16 == 47)
    {
      sub_100248E60(v14, (unsigned __int8 *)a2);
    }
  }
  else if (sub_100058654())
  {
    sub_100056E24((uint64_t)"OI_Rfcomm_ReceiveFrame invalid frame length=%d", v6, v7, v8, v9, v10, v11, v12, a3);
    uint64_t v13 = sub_100050B4C(0x32u);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR)) {
LABEL_26:
    }
      sub_100744F6C();
  }
}

unsigned __int8 *sub_100248E60(unsigned __int8 *result, unsigned __int8 *a2)
{
  unsigned int v2 = *a2;
  if ((v2 & 1) != 0 && (a2[1] & 0x10) != 0)
  {
    uint64_t v3 = result;
    if (result[12])
    {
      if ((v2 & 2) != 0) {
        return result;
      }
    }
    else if ((v2 & 2) == 0)
    {
      return result;
    }
    uint64_t v25 = 0;
    unsigned int v4 = v2 >> 2;
    int v5 = *result;
    if (v5 != 7)
    {
      if (v5 == 4 && v2 <= 3)
      {
        uint64_t result = (unsigned __int8 *)sub_1002485D4(99, (uint64_t)result, v2 >> 2);
        if (!result) {
          *uint64_t v3 = 7;
        }
        return result;
      }
      return (unsigned __int8 *)sub_1002485D4(15, (uint64_t)v3, v2 >> 2);
    }
    if (v2 > 0xF7 || v4 == 1)
    {
      if (sub_100058654())
      {
        sub_100056E24((uint64_t)"%! (%d)", v16, v17, v18, v19, v20, v21, v22, 912);
        uint64_t v23 = sub_100050B4C(0x32u);
        if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR)) {
          sub_100744F6C();
        }
      }
      return (unsigned __int8 *)sub_1002485D4(15, (uint64_t)v3, v2 >> 2);
    }
    if (sub_100244A2C((uint64_t)result, v2 >> 2, &v25))
    {
      uint64_t v6 = sub_100244AC4((uint64_t)v3, v2 >> 2, &v25);
      if (v6)
      {
        uint64_t v7 = v6;
        if (sub_100058654())
        {
          sub_100056E24((uint64_t)"%! (%d)", v8, v9, v10, v11, v12, v13, v14, v7);
          int v15 = sub_100050B4C(0x32u);
          if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR)) {
            sub_100744F6C();
          }
        }
        return (unsigned __int8 *)sub_1002485D4(15, (uint64_t)v3, v2 >> 2);
      }
      uint64_t v24 = v25;
      if (!v25)
      {
        sub_10025B8C0();
        uint64_t v24 = v25;
      }
    }
    else
    {
      uint64_t v24 = v25;
      if (*(unsigned char *)(v25 + 13) == 6) {
        return (unsigned __int8 *)sub_1002485D4(15, (uint64_t)v3, v2 >> 2);
      }
    }
    *(unsigned char *)(v24 + 13) = 3;
    *(unsigned char *)(v24 + 10) = v4;
    uint64_t result = (unsigned __int8 *)sub_100245988((uint64_t)(v3 + 6), v2 >> 3);
    if (!result) {
      return result;
    }
    *(_DWORD *)(v25 + 164) = 921;
    sub_100244D78();
    return (unsigned __int8 *)sub_1002485D4(15, (uint64_t)v3, v2 >> 2);
  }
  return result;
}

void sub_10024902C(unsigned __int8 *a1, unsigned __int8 *a2)
{
  sub_100249EE4((uint64_t)a1);
  unsigned int v4 = *a2;
  if ((v4 & 1) == 0 || (a2[1] & 0x10) == 0) {
    return;
  }
  if (a1[12])
  {
    if ((v4 & 2) == 0) {
      return;
    }
  }
  else if ((v4 & 2) != 0)
  {
    return;
  }
  uint64_t v41 = 0;
  int v5 = v4 >> 2;
  int v6 = *a1;
  if (v6 == 9)
  {
    if (v4 <= 3)
    {
      uint64_t v14 = sub_1001E121C(*((unsigned __int16 *)a1 + 1), 560);
      if (v14)
      {
        sub_1002450DC(a1, v14, 1);
      }
      else
      {
        *a1 = 10;
      }
      return;
    }
    if (sub_100244A2C((uint64_t)a1, v4 >> 2, &v41))
    {
      if (!sub_100058654()) {
        return;
      }
      sub_100056E24((uint64_t)"%! (%d)", v17, v18, v19, v20, v21, v22, v23, 912);
      uint64_t v24 = sub_100050B4C(0x32u);
      if (!os_log_type_enabled(v24, OS_LOG_TYPE_ERROR)) {
        return;
      }
LABEL_45:
      sub_100744F6C();
      return;
    }
    uint64_t v15 = v41;
LABEL_41:
    sub_10024856C(v15, 1);
    return;
  }
  if (v6 != 7)
  {
    if (v6 == 5 && v4 <= 3)
    {
      *a1 = 7;
      uint64_t v9 = (unsigned __int8 *)*((void *)a1 + 2);
      uint64_t v7 = a1 + 16;
      uint64_t v8 = v9;
      if (v9)
      {
        if (v8 != v7)
        {
          do
          {
            uint64_t v41 = (uint64_t)(v8 - 144);
            uint64_t v10 = sub_100245764((uint64_t)(v8 - 144));
            if (v10)
            {
              int v11 = v10;
              uint64_t v12 = (unsigned __int8 *)*((void *)v8 + 1);
              (*((void (**)(void, void, uint64_t))v8 - 9))(*((unsigned __int16 *)v8 - 68), 0, v10);
              *((_DWORD *)v8 + 5) = v11;
              sub_100244D78(v8 - 144, 1);
              uint64_t v8 = v12;
            }
            uint64_t v8 = *(unsigned __int8 **)v8;
            if (v8) {
              BOOL v13 = v8 == v7;
            }
            else {
              BOOL v13 = 1;
            }
          }
          while (!v13);
        }
      }
    }
    return;
  }
  if (v5 == 1 || (v4 + 8) <= 0xBu)
  {
    if (sub_100058654())
    {
      sub_100056E24((uint64_t)"%! (%d)", v25, v26, v27, v28, v29, v30, v31, 101);
      uint64_t v32 = sub_100050B4C(0x32u);
      if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR)) {
        sub_100744F6C();
      }
    }
    return;
  }
  if (sub_100244A2C((uint64_t)a1, v5, &v41)) {
    return;
  }
  uint64_t v15 = v41;
  int v16 = *(unsigned __int8 *)(v41 + 13);
  if (v16 == 6) {
    goto LABEL_41;
  }
  if (v16 == 2)
  {
    *(unsigned char *)(v41 + 13) = 4;
    sub_10024A338((uint64_t)a1, 1, v5, *(unsigned char *)(v15 + 12), 0);
    return;
  }
  if (sub_100058654())
  {
    sub_100056E24((uint64_t)"%! (%d)", v33, v34, v35, v36, v37, v38, v39, 408);
    uint64_t v40 = sub_100050B4C(0x32u);
    if (os_log_type_enabled(v40, OS_LOG_TYPE_ERROR)) {
      goto LABEL_45;
    }
  }
}

void sub_1002492EC(unsigned char *a1, unsigned __int8 *a2)
{
  unsigned int v2 = *a2;
  if ((v2 & 1) == 0 || (a2[1] & 0x10) == 0) {
    return;
  }
  uint64_t v45 = 0;
  if (!a1[12])
  {
    if ((v2 & 2) != 0) {
      goto LABEL_6;
    }
LABEL_18:
    if (!sub_100058654()) {
      return;
    }
    sub_100056E24((uint64_t)"%! (%d)", v7, v8, v9, v10, v11, v12, v13, 917);
    uint64_t v14 = sub_100050B4C(0x32u);
    if (!os_log_type_enabled(v14, OS_LOG_TYPE_ERROR)) {
      return;
    }
LABEL_20:
    sub_100744F6C();
    return;
  }
  if ((v2 & 2) != 0) {
    goto LABEL_18;
  }
LABEL_6:
  uint64_t v4 = v2 >> 2;
  if (v2 > 0xF7 || v4 == 1)
  {
    if (!sub_100058654()) {
      return;
    }
    sub_100056E24((uint64_t)"%! (%d)", v15, v16, v17, v18, v19, v20, v21, 920);
    uint64_t v22 = sub_100050B4C(0x32u);
    if (!os_log_type_enabled(v22, OS_LOG_TYPE_ERROR)) {
      return;
    }
    goto LABEL_20;
  }
  if (*a1 != 7)
  {
LABEL_14:
    sub_1002485D4(99, (uint64_t)a1, v4);
    return;
  }
  if (v2 <= 3)
  {
    uint64_t v5 = sub_10025B218(0x32u);
    if (*(_WORD *)(v5 + 10)) {
      int v6 = *(unsigned __int16 *)(v5 + 10);
    }
    else {
      int v6 = 30;
    }
    *a1 = 8;
    sub_10024842C((uint64_t)a1, v6);
    goto LABEL_14;
  }
  if (sub_100244A2C((uint64_t)a1, v2 >> 2, &v45))
  {
    if (sub_100058654())
    {
      sub_100056E24((uint64_t)"DLCI %d not found", v23, v24, v25, v26, v27, v28, v29, v4);
      uint64_t v30 = sub_100050B4C(0x32u);
      if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR)) {
        sub_100744F6C();
      }
    }
  }
  else
  {
    uint64_t v31 = sub_1002485D4(99, (uint64_t)a1, v4);
    uint64_t v32 = v45;
    int v33 = *(unsigned __int8 *)(v45 + 13);
    if (v33 != 6)
    {
      if (v33 == 5)
      {
        *(unsigned char *)(v45 + 13) = 7;
        if (v31)
        {
          if (sub_100058654())
          {
            sub_100056E24((uint64_t)"RFCOMM send command failed with result : %!", v34, v35, v36, v37, v38, v39, v40, v31);
            uint64_t v41 = sub_100050B4C(0x32u);
            if (os_log_type_enabled(v41, OS_LOG_TYPE_ERROR)) {
              sub_100744F6C();
            }
          }
          uint64_t v42 = v45;
          *(_DWORD *)(v45 + 164) = 933;
          sub_10024856C(v42, 0);
        }
      }
      else
      {
        uint64_t v43 = *(void (**)(uint64_t, void, uint64_t))(v45 + 72);
        if (v43)
        {
          *(unsigned char *)(v45 + 13) = 8;
          if (v31)
          {
            uint64_t v44 = *(unsigned __int16 *)(v32 + 8);
            sub_100244D78(v32, 0);
            v43(v44, 0, 927);
          }
        }
      }
    }
  }
}

void sub_100249564(unsigned __int8 *a1, unsigned __int8 *a2)
{
  unsigned int v2 = *a2;
  if (v2)
  {
    if (a1[12])
    {
      if ((v2 & 2) == 0) {
        return;
      }
    }
    else if ((v2 & 2) != 0)
    {
      return;
    }
    uint64_t v36 = 0;
    uint64_t v5 = sub_100244A2C((uint64_t)a1, v2 >> 2, &v36);
    if (v5)
    {
      uint64_t v6 = v5;
      if (sub_100058654())
      {
        sub_100056E24((uint64_t)"%! (%d)", v7, v8, v9, v10, v11, v12, v13, v6);
        uint64_t v14 = sub_100050B4C(0x32u);
        if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR)) {
LABEL_33:
        }
          sub_100744F6C();
      }
    }
    else if ((a2[1] & 0x10) != 0 || (*(unsigned __int8 *)(v36 + 13) | 4) != 6)
    {
      int v15 = *a1;
      if (v15 == 7)
      {
        if (v2 >> 2 != 1 && (v2 + 8) >= 0xCu)
        {
          if ((*(unsigned __int8 *)(v36 + 13) | 4) == 6) {
            sub_100249EE4((uint64_t)a1);
          }
          else {
            sub_100249F20((uint64_t)a1);
          }
          uint64_t v24 = v36;
          switch(*(unsigned char *)(v36 + 13))
          {
            case 0:
            case 1:
            case 2:
              uint64_t v25 = *(void (**)(void, void, uint64_t))(v36 + 72);
              if (v25)
              {
                *(_DWORD *)(v36 + 164) = 934;
                v25(*(unsigned __int16 *)(v24 + 8), 0, 913);
                sub_100244D78(v36, 1);
              }
              else if (sub_100058654())
              {
                sub_100056E24((uint64_t)"Received unsolicited remote reject, ignore", v27, v28, v29, v30, v31, v32, v33, v35);
                uint64_t v34 = sub_100050B4C(0x32u);
                if (os_log_type_enabled(v34, OS_LOG_TYPE_ERROR)) {
                  goto LABEL_33;
                }
              }
              return;
            case 3:
            case 4:
            case 5:
              int v26 = 934;
              goto LABEL_28;
            case 6:
            case 9:
              goto LABEL_29;
            case 7:
            case 8:
              int v26 = 927;
LABEL_28:
              *(_DWORD *)(v36 + 164) = v26;
LABEL_29:
              sub_10024856C(v24, 1);
              break;
            default:
              return;
          }
        }
      }
      else
      {
        if (v15 == 5)
        {
          sub_100249EE4((uint64_t)a1);
          sub_100244E24(a1, 0, 929);
          return;
        }
        if (sub_100058654())
        {
          sub_100056E24((uint64_t)"Unexpected DM received", v16, v17, v18, v19, v20, v21, v22, v35);
          uint64_t v23 = sub_100050B4C(0x32u);
          if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR)) {
            goto LABEL_33;
          }
        }
      }
    }
  }
}

void sub_1002497C8(unsigned char *a1, unsigned __int8 *a2, int a3, int16x8_t a4)
{
  uint64_t v103 = 0;
  unsigned int v4 = *a2;
  if (v4)
  {
    if (a1[12])
    {
      if ((v4 & 2) != 0)
      {
        if (sub_100058654())
        {
          sub_100056E24((uint64_t)"%! (%d)", v14, v15, v16, v17, v18, v19, v20, 917);
          uint64_t v21 = sub_100050B4C(0x32u);
          if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR)) {
            goto LABEL_37;
          }
        }
        return;
      }
    }
    else if ((v4 & 2) == 0)
    {
      if (sub_100058654())
      {
        sub_100056E24((uint64_t)"%! (%d)", v22, v23, v24, v25, v26, v27, v28, 917);
        uint64_t v29 = sub_100050B4C(0x32u);
        if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR)) {
          goto LABEL_37;
        }
      }
      return;
    }
    unsigned int v30 = a2[2];
    if (v30)
    {
      uint64_t v31 = v30 >> 1;
      unsigned int v32 = 3;
    }
    else
    {
      uint64_t v31 = (unsigned __int16)(v30 | (a2[3] << 8)) >> 1;
      unsigned int v32 = 4;
    }
    unsigned __int8 v33 = a2[1];
    if ((v33 & 0x10) != 0)
    {
      if (!a1[44])
      {
        if (sub_100058654())
        {
          sub_100056E24((uint64_t)"%! (%d)", v45, v46, v47, v48, v49, v50, v51, 917);
          uint64_t v52 = sub_100050B4C(0x32u);
          if (os_log_type_enabled(v52, OS_LOG_TYPE_ERROR)) {
            goto LABEL_37;
          }
        }
        return;
      }
      unsigned int v34 = a2[v32++];
    }
    else
    {
      unsigned int v34 = 0;
    }
    if (v31 + v32 + 1 != a3)
    {
      if (sub_100058654())
      {
        sub_100056E24((uint64_t)"%! (%d)", v37, v38, v39, v40, v41, v42, v43, 917);
        uint64_t v44 = sub_100050B4C(0x32u);
        if (os_log_type_enabled(v44, OS_LOG_TYPE_ERROR)) {
          goto LABEL_37;
        }
      }
      return;
    }
    if (*a1 != 7) {
      return;
    }
    if (v4 > 0xF7 || v4 >> 2 == 1)
    {
      if (sub_100058654())
      {
        sub_100056E24((uint64_t)"%! (%d)", v53, v54, v55, v56, v57, v58, v59, 917);
        uint64_t v60 = sub_100050B4C(0x32u);
        if (os_log_type_enabled(v60, OS_LOG_TYPE_ERROR)) {
          goto LABEL_37;
        }
      }
      return;
    }
    uint64_t v35 = &a2[v32];
    if (v4 <= 3)
    {
      uint64_t v36 = (char *)&a2[v32];
      sub_10024A548((uint64_t)a1, v36, v31, a4);
      return;
    }
    uint64_t v61 = sub_100244A2C((uint64_t)a1, v4 >> 2, &v103);
    if (v61)
    {
      uint64_t v62 = v61;
      if (!sub_100058654()) {
        return;
      }
      sub_100056E24((uint64_t)"%! (%d)", v63, v64, v65, v66, v67, v68, v69, v62);
      uint64_t v70 = sub_100050B4C(0x32u);
      if (!os_log_type_enabled(v70, OS_LOG_TYPE_ERROR)) {
        return;
      }
      goto LABEL_41;
    }
    if (a1[44])
    {
      if ((v33 & 0x10) != 0 && v34)
      {
        uint64_t v71 = v103;
        int v72 = *(unsigned __int16 *)(v103 + 18);
        if ((v72 ^ 0xFFFFu) <= v34)
        {
          if (sub_100058654())
          {
            sub_100056E24((uint64_t)"%! (%d)", v74, v75, v76, v77, v78, v79, v80, 922);
            uint64_t v81 = sub_100050B4C(0x32u);
            if (os_log_type_enabled(v81, OS_LOG_TYPE_ERROR)) {
              sub_100744F6C();
            }
          }
          sub_100246730(*(unsigned __int16 *)(v103 + 8), 922);
          return;
        }
        *(_WORD *)(v103 + 18) = v72 + v34;
        if (!v72) {
          sub_10024834C(v71);
        }
      }
      uint64_t v73 = v103;
      if (!v31)
      {
        if (*(unsigned char *)(v103 + 33) || !a1[44]) {
          return;
        }
        goto LABEL_68;
      }
      if (*(unsigned char *)(v103 + 14))
      {
        --*(unsigned char *)(v103 + 14);
      }
      else if (sub_100058654())
      {
        sub_100056E24((uint64_t)"Received data when remote credits = 0!", v82, v83, v84, v85, v86, v87, v88, v102);
        uint64_t v89 = sub_100050B4C(0x32u);
        if (os_log_type_enabled(v89, OS_LOG_TYPE_ERROR)) {
          sub_100744F6C();
        }
      }
    }
    uint64_t v73 = v103;
    if (*(unsigned char *)(v103 + 33))
    {
      if (!v31) {
        return;
      }
      if (a1[44])
      {
        unsigned int v90 = *(unsigned __int8 *)(v103 + 14);
        if (v90 <= *(unsigned __int8 *)(qword_100A19778 + 2))
        {
          if (*(unsigned char *)(v103 + 162)) {
            unsigned __int8 v91 = *(unsigned char *)(v103 + 162) - (v90 + *(unsigned char *)(v103 + 163));
          }
          else {
            unsigned __int8 v91 = ~(_BYTE)v90;
          }
          if (sub_1002482D4(v103, v91)) {
            return;
          }
          uint64_t v73 = v103;
        }
      }
LABEL_77:
      (*(void (**)(void, unsigned __int8 *, uint64_t))(*(void *)(v73 + 40) + 8))(*(unsigned __int16 *)(v73 + 8), v35, v31);
      return;
    }
    if (!a1[44])
    {
      if (!v31) {
        return;
      }
      goto LABEL_77;
    }
LABEL_68:
    uint64_t v92 = sub_100248190(v73, v35, v31);
    if (!v92) {
      return;
    }
    uint64_t v93 = v92;
    if (!sub_100058654()) {
      return;
    }
    sub_100056E24((uint64_t)"Save received packet failed in Receive_UIH %! (%d)", v94, v95, v96, v97, v98, v99, v100, v93);
    uint64_t v101 = sub_100050B4C(0x32u);
    if (!os_log_type_enabled(v101, OS_LOG_TYPE_ERROR)) {
      return;
    }
LABEL_41:
    sub_100744F6C();
    return;
  }
  if (sub_100058654())
  {
    sub_100056E24((uint64_t)"%! (%d)", v5, v6, v7, v8, v9, v10, v11, 917);
    uint64_t v12 = sub_100050B4C(0x32u);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR)) {
LABEL_37:
    }
      sub_100744F6C();
  }
}

uint64_t sub_100249CC8(char *a1, int a2)
{
  if ((_BYTE)a2)
  {
    char v2 = -1;
    do
    {
      char v3 = *a1++;
      --a2;
      char v2 = byte_1007BAA50[(v3 ^ v2)];
    }
    while ((_BYTE)a2);
    return ~v2;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_100249D0C(char a1, char a2, char a3, int a4)
{
  if ((byte_1007BAA50[(byte_1007BAA50[(byte_1007BAA50[~a1] ^ a2)] ^ a3)] ^ a4) == 0xFF) {
    return 0;
  }
  else {
    return 255;
  }
}

uint64_t sub_100249D4C(char a1, char a2, int a3)
{
  if ((byte_1007BAA50[(byte_1007BAA50[~a1] ^ a2)] ^ a3) == 0xFF) {
    return 0;
  }
  else {
    return 255;
  }
}

uint64_t sub_100249D80(uint64_t a1)
{
  uint64_t v4 = a1;
  v3[0] = 0;
  uint64_t v1 = (int *)(a1 + 32);
  sub_100026DB4(*(unsigned int *)(a1 + 32));
  v3[1] = &v4;
  LOWORD(v3[0]) = 8;
  return sub_1000268E4((uint64_t)sub_100249DF4, v3, *(unsigned __int16 *)(qword_100A19778 + 4), v1);
}

uint64_t sub_100249DF4(uint64_t a1)
{
  if (sub_100058654())
  {
    sub_100056E24((uint64_t)"Timeout occurred", v2, v3, v4, v5, v6, v7, v8, v11);
    uint64_t v9 = sub_100050B4C(0x32u);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR)) {
      sub_1007457DC(v9);
    }
  }
  return sub_100244E24(**(void **)(a1 + 8), 1, 931);
}

uint64_t sub_100249E68(uint64_t a1)
{
  uint64_t v4 = a1;
  if (!a1) {
    sub_10025B8C0();
  }
  v3[0] = 0;
  sub_100026DB4(*(unsigned int *)(a1 + 36));
  v3[1] = &v4;
  LOWORD(v3[0]) = 8;
  return sub_1000268E4((uint64_t)sub_100249DF4, v3, *(unsigned __int16 *)(qword_100A19778 + 8), (int *)(a1 + 36));
}

uint64_t sub_100249EE4(uint64_t a1)
{
  if (!a1) {
    sub_10025B8C0();
  }
  uint64_t v2 = *(unsigned int *)(a1 + 32);

  return sub_100026DB4(v2);
}

uint64_t sub_100249F20(uint64_t a1)
{
  if (!a1) {
    sub_10025B8C0();
  }
  uint64_t v2 = *(unsigned int *)(a1 + 36);

  return sub_100026DB4(v2);
}

uint64_t sub_100249F5C(uint64_t a1)
{
  if (!a1) {
    sub_10025B8C0();
  }
  unsigned int v2 = *(_DWORD *)(a1 + 36);

  return sub_10025BE30(v2);
}

uint64_t sub_100249F98(uint64_t a1, int a2, unsigned int a3, unsigned __int8 a4, __int16 a5, char a6)
{
  if (!a1) {
    sub_10025B8C0();
  }
  if (a2) {
    char v12 = -125;
  }
  else {
    char v12 = -127;
  }
  LOBYTE(v19[0]) = v12;
  HIBYTE(v19[0]) = 17;
  if (a3 >= 0x40) {
    sub_10025B8C0();
  }
  memset((char *)&v19[1] + 1, 0, 7);
  LOBYTE(v19[1]) = a3;
  if (a2) {
    char v13 = -16;
  }
  else {
    char v13 = -32;
  }
  if (*(unsigned char *)(a1 + 44)) {
    char v14 = v13;
  }
  else {
    char v14 = 0;
  }
  if (*(unsigned char *)(a1 + 44)) {
    char v15 = a6;
  }
  else {
    char v15 = 0;
  }
  HIBYTE(v19[1]) = v14;
  v19[2] = a4;
  v19[3] = a5;
  LOBYTE(v19[4]) = 0;
  HIBYTE(v19[4]) = v15;
  if (a2) {
    sub_100249E68(a1);
  }
  uint64_t v18 = 0;
  uint64_t v16 = sub_100248ABC(a1, 0, (char *)v19, 0xAuLL, 0);
  if (!v16)
  {
    uint64_t v16 = sub_100244A2C(a1, a3, &v18);
    if (v16) {
      sub_10025B8C0();
    }
    if (!*(unsigned char *)(v18 + 13)) {
      *(unsigned char *)(v18 + 13) = 1;
    }
  }
  return v16;
}

uint64_t sub_10024A100(uint64_t a1, int a2, uint64_t a3, uint64_t a4)
{
  if (!a1) {
    sub_10025B8C0();
  }
  long long v31 = 0u;
  memset(v32, 0, sizeof(v32));
  long long v29 = 0u;
  long long v30 = 0u;
  long long v27 = 0u;
  long long v28 = 0u;
  long long v25 = 0u;
  long long v26 = 0u;
  long long v23 = 0u;
  long long v24 = 0u;
  long long v21 = 0u;
  long long v22 = 0u;
  long long v19 = 0u;
  long long v20 = 0u;
  long long v18 = 0u;
  if ((a4 & 0x80) != 0)
  {
    if (sub_100058654())
    {
      sub_100056E24((uint64_t)"OI_RfcommMux_TEST invalid size=%d", v9, v10, v11, v12, v13, v14, v15, a4);
      uint64_t v16 = sub_100050B4C(0x32u);
      if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR)) {
        sub_100744F6C();
      }
    }
    return 114;
  }
  else
  {
    if (a2) {
      char v7 = 35;
    }
    else {
      char v7 = 33;
    }
    v17[0] = v7;
    v17[1] = (2 * a4) | 1;
    __memmove_chk();
    if (a2) {
      sub_100249E68(a1);
    }
    return sub_100248ABC(a1, 0, v17, (a4 + 2), 0);
  }
}

uint64_t sub_10024A250(uint64_t a1, int a2)
{
  if (!a1) {
    sub_10025B8C0();
  }
  if (a2) {
    char v4 = -93;
  }
  else {
    char v4 = -95;
  }
  v6[0] = v4;
  v6[1] = 1;
  if (a2) {
    sub_100249E68(a1);
  }
  return sub_100248ABC(a1, 0, v6, 2uLL, 0);
}

uint64_t sub_10024A2C4(uint64_t a1, int a2)
{
  if (!a1) {
    sub_10025B8C0();
  }
  if (a2) {
    char v4 = 99;
  }
  else {
    char v4 = 97;
  }
  v6[0] = v4;
  v6[1] = 1;
  if (a2) {
    sub_100249E68(a1);
  }
  return sub_100248ABC(a1, 0, v6, 2uLL, 0);
}

uint64_t sub_10024A338(uint64_t a1, int a2, char a3, char a4, int a5)
{
  char v11 = 0;
  if (a2) {
    char v6 = -29;
  }
  else {
    char v6 = -31;
  }
  v10[0] = v6;
  if (a5)
  {
    char v11 = (16 * a5) | 3;
    size_t v7 = 5;
    char v8 = 7;
  }
  else
  {
    a4 |= 1u;
    size_t v7 = 4;
    char v8 = 5;
  }
  v10[1] = v8;
  v10[3] = a4;
  v10[2] = (4 * a3) | 3;
  if (a2) {
    sub_100249E68(a1);
  }
  return sub_100248ABC(a1, 0, v10, v7, 0);
}

uint64_t sub_10024A3D8(uint64_t a1, int a2, char a3, uint64_t a4)
{
  memset((char *)&v11[1] + 1, 0, 7);
  if (a2) {
    char v5 = -109;
  }
  else {
    char v5 = -111;
  }
  LOBYTE(v11[0]) = v5;
  LOBYTE(v11[1]) = (4 * a3) | 3;
  if (a4)
  {
    if (*(unsigned __int8 *)(a4 + 2) > 8u) {
      return 903;
    }
    HIBYTE(v11[1]) = *(unsigned char *)(a4 + 2);
    unsigned int v8 = *(unsigned __int8 *)(a4 + 3);
    if (v8 > 3) {
      return 904;
    }
    int v9 = *(unsigned __int8 *)(a4 + 4);
    if ((v9 | 4) != 4) {
      return 905;
    }
    int v10 = *(unsigned __int8 *)(a4 + 5);
    if ((v10 | 8) != 8) {
      return 906;
    }
    if (((*(unsigned char *)(a4 + 6) >> 4) | (16 * *(unsigned char *)(a4 + 6))) > 3u) {
      return 907;
    }
    LOBYTE(v11[2]) = *(unsigned char *)(a4 + 6) | v10 | v9 | v8;
    if (*(unsigned __int8 *)(a4 + 7) > 0x20u) {
      return 908;
    }
    HIBYTE(v11[2]) = *(unsigned char *)(a4 + 7);
    v11[3] = *(_WORD *)(a4 + 8);
    v11[4] = *(_WORD *)a4;
    int v7 = 8;
  }
  else
  {
    int v7 = 1;
  }
  HIBYTE(v11[0]) = (2 * v7) | 1;
  if (a2) {
    sub_100249E68(a1);
  }
  return sub_100248ABC(a1, 0, (char *)v11, v7 | 2u, 0);
}

void sub_10024A548(uint64_t a1, char *a2, int a3, int16x8_t a4)
{
  uint64_t v4 = a1;
  char v5 = *a2;
  int v6 = *a2 & 0xFC;
  uint64_t v7 = a2[1] >> 1;
  if (v7 + 2 != a3)
  {
    if (sub_100058654())
    {
      sub_100056E24((uint64_t)"Invalid RFCOMM packet received, command (%d), force disconnect the link", v10, v11, v12, v13, v14, v15, v16, v5 & 0xFC);
      uint64_t v17 = sub_100050B4C(0x32u);
      if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR)) {
        sub_100744F6C();
      }
    }
    sub_10017C380(v4 + 6);
    return;
  }
  HIDWORD(v8) = *a2 & 0xFC;
  LODWORD(v8) = v6 - 16;
  switch((v8 >> 4))
  {
    case 0u:
      if (v7 == 1)
      {
        sub_100249F5C(a1);
      }
      else if (sub_100058654())
      {
        sub_100056E24((uint64_t)"%! (%d)", v48, v49, v50, v51, v52, v53, v54, 917);
        uint64_t v55 = sub_100050B4C(0x32u);
        if (os_log_type_enabled(v55, OS_LOG_TYPE_ERROR)) {
          goto LABEL_118;
        }
      }
      return;
    case 1u:
      if (v6 != 32)
      {
        sub_10025B8C0();
        char v5 = *a2;
      }
      if ((v5 & 2) != 0)
      {
        sub_10024A100(v4, 0, (uint64_t)(a2 + 2), v7);
      }
      else
      {
        sub_100249F20(v4);
        long long v18 = *(void (**)(uint64_t, char *, uint64_t))(v4 + 48);
        if (v18)
        {
          v18(v4 + 6, a2 + 2, v7);
          *(void *)(v4 + 48) = 0;
        }
        else if (sub_100058654())
        {
          sub_100056E24((uint64_t)"Mux_ReceiveTEST, receive response but no outstanding command, ignoring", v130, v131, v132, v133, v134, v135, v136, v259);
          char v137 = sub_100050B4C(0x32u);
          if (os_log_type_enabled(v137, OS_LOG_TYPE_ERROR)) {
            goto LABEL_118;
          }
        }
      }
      return;
    case 4u:
      uint64_t v263 = 0;
      if (v7 == 2)
      {
        unsigned int v19 = a2[2];
        uint64_t v20 = v19 >> 2;
        if (v19 > 0xF7 || v20 == 1)
        {
          if (sub_100058654())
          {
            sub_100056E24((uint64_t)"%! (%d)", v110, v111, v112, v113, v114, v115, v116, 917);
            uint64_t v117 = sub_100050B4C(0x32u);
            if (os_log_type_enabled(v117, OS_LOG_TYPE_ERROR)) {
              goto LABEL_118;
            }
          }
        }
        else
        {
          if ((v5 & 2) == 0) {
            goto LABEL_22;
          }
          char v156 = a2[3];
          uint64_t v157 = sub_100244A2C(a1, v19 >> 2, &v263);
          if (v157)
          {
            uint64_t v158 = v157;
            if (!sub_100058654()) {
              goto LABEL_90;
            }
            sub_100056E24((uint64_t)"%! (%d)", v159, v160, v161, v162, v163, v164, v165, v158);
            uint64_t v166 = sub_100050B4C(0x32u);
            if (!os_log_type_enabled(v166, OS_LOG_TYPE_ERROR)) {
              goto LABEL_90;
            }
            goto LABEL_122;
          }
          LOWORD(v260) = 1361;
          BYTE2(v260) = v19 | 3;
          BYTE3(v260) = v156;
          sub_100248ABC(v4, 0, (char *)&v260, 4uLL, 0);
          uint64_t v226 = *(void (**)(void, void))(*(void *)(v263 + 40) + 16);
          if (v226) {
            v226(*(unsigned __int16 *)(v263 + 8), v156 & 0xF);
          }
        }
      }
      else if (sub_100058654())
      {
        sub_100056E24((uint64_t)"%! (%d)", v56, v57, v58, v59, v60, v61, v62, 917);
        uint64_t v63 = sub_100050B4C(0x32u);
        if (os_log_type_enabled(v63, OS_LOG_TYPE_ERROR)) {
          goto LABEL_118;
        }
      }
      return;
    case 5u:
      if (!a1)
      {
        sub_10025B8C0();
        char v5 = *a2;
      }
      if ((v5 & 2) == 0) {
        goto LABEL_49;
      }
      sub_10024A2C4(v4, 0);
      if (!*(unsigned char *)(v4 + 44)) {
        *(unsigned char *)(v4 + 45) = 0;
      }
      return;
    case 7u:
      if (!a1) {
        sub_10025B8C0();
      }
      uint64_t v263 = 0;
      if (v7 == 8)
      {
        uint64_t v20 = a2[2] & 0x3F;
        if (v20 == 1 || v20 >= 0x3E)
        {
          if (sub_100058654())
          {
            sub_100056E24((uint64_t)"%! (%d)", v118, v119, v120, v121, v122, v123, v124, 917);
            unsigned int v125 = sub_100050B4C(0x32u);
            if (os_log_type_enabled(v125, OS_LOG_TYPE_ERROR)) {
              goto LABEL_118;
            }
          }
        }
        else
        {
          char v21 = *a2;
          unsigned int v22 = a2[3];
          char v23 = a2[4];
          unsigned __int16 v24 = *((_WORD *)a2 + 3);
          __int16 v25 = a2[9] & 7;
          uint64_t v26 = sub_100244A2C(v4, v20, &v263);
          if (v26)
          {
            if ((v21 & 2) == 0)
            {
              uint64_t v27 = v26;
              if (sub_100058654())
              {
                sub_100056E24((uint64_t)"%! (%d)", v28, v29, v30, v31, v32, v33, v34, v27);
                uint64_t v35 = sub_100050B4C(0x32u);
                if (os_log_type_enabled(v35, OS_LOG_TYPE_ERROR)) {
                  sub_100744F6C();
                }
              }
              return;
            }
            uint64_t v179 = sub_100244AC4(v4, v20, &v263);
            if (v179)
            {
              uint64_t v180 = v179;
              if (sub_100058654())
              {
                sub_100056E24((uint64_t)"%! (%d)", v181, v182, v183, v184, v185, v186, v187, v180);
                char v188 = sub_100050B4C(0x32u);
                if (os_log_type_enabled(v188, OS_LOG_TYPE_ERROR)) {
LABEL_122:
                }
                  sub_100744F6C();
              }
              goto LABEL_90;
            }
          }
          else if ((v21 & 2) == 0)
          {
            if (*(unsigned char *)(v263 + 13) != 1) {
              return;
            }
            sub_100249F20(v4);
            int v168 = (v22 & 0xF0) == 224;
            *(unsigned char *)(v4 + 44) = v168;
            if (*(unsigned __int16 *)(v263 + 16) >= v24)
            {
              *(_WORD *)(v263 + 16) = v24;
            }
            else
            {
              if (sub_100058654())
              {
                sub_100056E24((uint64_t)"%! (%d)", v169, v170, v171, v172, v173, v174, v175, 917);
                long long v176 = sub_100050B4C(0x32u);
                if (os_log_type_enabled(v176, OS_LOG_TYPE_ERROR)) {
                  sub_100744F6C();
                }
              }
              if (sub_1002485D4(67, v4, v20)) {
                return;
              }
              uint64_t v177 = v263;
              *(_DWORD *)(v263 + 164) = 918;
              uint64_t v178 = *(void (**)(void, void, uint64_t))(v177 + 72);
              if (v178)
              {
                v178(0, 0, 918);
                uint64_t v177 = v263;
              }
              sub_100244D78(v177, 1);
              int v168 = *(unsigned __int8 *)(v4 + 44);
            }
            if (v168) {
              *(_WORD *)(v263 + 18) = v25;
            }
            if (!sub_1002485D4(47, v4, v20))
            {
              uint64_t v250 = v263;
              if (!v263)
              {
                sub_10025B8C0();
                uint64_t v250 = v263;
              }
              *(unsigned char *)(v250 + 13) = 2;
            }
            return;
          }
          uint64_t v189 = v263;
          if (*(unsigned char *)(v263 + 13))
          {
            __int16 v190 = v24;
            uint64_t v191 = v4;
            unsigned int v192 = v20;
            unsigned __int8 v193 = v23 & 0x3F;
            char v194 = 0;
          }
          else
          {
            if (*(unsigned __int16 *)(v263 + 16) >= v24) {
              *(_WORD *)(v263 + 16) = v24;
            }
            if (v22 >= 0xF0)
            {
              *(unsigned char *)(v4 + 44) = 1;
              *(_WORD *)(v189 + 18) = v25;
              uint64_t v239 = sub_100247F44(v189);
              if (v239)
              {
                uint64_t v240 = v239;
                if (sub_100058654())
                {
                  sub_100056E24((uint64_t)"%! (%d)", v241, v242, v243, v244, v245, v246, v247, v240);
                  uint64_t v248 = sub_100050B4C(0x32u);
                  if (os_log_type_enabled(v248, OS_LOG_TYPE_ERROR)) {
                    sub_100744F6C();
                  }
                }
                uint64_t v249 = v263;
                if (!v263)
                {
                  sub_10025B8C0();
                  uint64_t v249 = v263;
                }
                *(unsigned char *)(v249 + 13) = 9;
                goto LABEL_90;
              }
              uint64_t v189 = v263;
              char v194 = *(unsigned char *)(v263 + 14);
            }
            else
            {
              char v194 = 0;
              *(unsigned char *)(v4 + 44) = 0;
              *(unsigned char *)(v189 + 14) = 0;
            }
            __int16 v190 = *(_WORD *)(v189 + 16);
            uint64_t v191 = v4;
            unsigned int v192 = v20;
            unsigned __int8 v193 = v23 & 0x3F;
          }
          sub_100249F98(v191, 0, v192, v193, v190, v194);
        }
      }
      else if (sub_100058654())
      {
        sub_100056E24((uint64_t)"Mux_ReceivePN invalid cmdLen=%d, shall be=%d", v64, v65, v66, v67, v68, v69, v70, v7);
        uint64_t v71 = sub_100050B4C(0x32u);
        if (os_log_type_enabled(v71, OS_LOG_TYPE_ERROR)) {
          goto LABEL_118;
        }
      }
      return;
    case 8u:
      __int16 v264 = 0;
      uint64_t v262 = 0;
      uint64_t v263 = 0;
      unsigned int v36 = a2[2];
      uint64_t v20 = v36 >> 2;
      if (v36 > 0xF7 || v20 == 1)
      {
        if (sub_100058654())
        {
          sub_100056E24((uint64_t)"%! (%d)", v38, v39, v40, v41, v42, v43, v44, 917);
          uint64_t v45 = sub_100050B4C(0x32u);
          if (os_log_type_enabled(v45, OS_LOG_TYPE_ERROR)) {
            goto LABEL_118;
          }
        }
        return;
      }
      if (v7 == 8)
      {
        BYTE2(v263) = a2[3];
        *(int8x8_t *)a4.i8 = vand_s8((int8x8_t)vdup_n_s16(a2[4]), (int8x8_t)0x30000800040003);
        *(_DWORD *)((char *)&v263 + 3) = vmovn_s16(a4).u32[0];
        HIBYTE(v263) = a2[5] & 0x3F;
        __int16 v264 = *((_WORD *)a2 + 3);
        LOWORD(v263) = *((_WORD *)a2 + 4);
        uint64_t v138 = sub_100244A2C(a1, v20, &v262);
        if (v138)
        {
          if ((v5 & 2) == 0)
          {
            uint64_t v139 = v138;
            if (!sub_100058654()) {
              return;
            }
            sub_100056E24((uint64_t)"%! (%d)", v140, v141, v142, v143, v144, v145, v146, v139);
            uint64_t v147 = sub_100050B4C(0x32u);
            if (!os_log_type_enabled(v147, OS_LOG_TYPE_ERROR)) {
              return;
            }
            goto LABEL_220;
          }
          uint64_t v204 = sub_100244AC4(v4, v20, &v262);
          if (v204)
          {
            uint64_t v205 = v204;
            if (sub_100058654())
            {
              sub_100056E24((uint64_t)"%! (%d)", v206, v207, v208, v209, v210, v211, v212, v205);
              uint64_t v213 = sub_100050B4C(0x32u);
              if (os_log_type_enabled(v213, OS_LOG_TYPE_ERROR)) {
                sub_100744F6C();
              }
            }
            goto LABEL_90;
          }
        }
        else if ((v5 & 2) == 0)
        {
          if (*(void *)(v262 + 64))
          {
            sub_100249F20(v4);
            uint64_t v203 = v262;
            *(void *)(v262 + 22) = v263;
            *(_WORD *)(v203 + 30) = v264;
            (*(void (**)(void, uint64_t *))(v203 + 64))(*(unsigned __int16 *)(v203 + 8), &v263);
            return;
          }
          if (sub_100058654())
          {
            sub_100056E24((uint64_t)"Mux_ReceiveRPN, unsolicited response, ignoring", v251, v252, v253, v254, v255, v256, v257, v259);
            uint64_t v258 = sub_100050B4C(0x32u);
            if (os_log_type_enabled(v258, OS_LOG_TYPE_ERROR)) {
              goto LABEL_220;
            }
          }
          return;
        }
        uint64_t v214 = *(void (**)(void, uint64_t *))(*(void *)(v262 + 40) + 32);
        if (v214) {
          v214(*(unsigned __int16 *)(v262 + 8), &v263);
        }
        __int16 v215 = v263;
        if (v263)
        {
          *(unsigned char *)(v262 + 24) = BYTE2(v263);
          if ((v215 & 2) == 0)
          {
LABEL_157:
            if ((v215 & 4) == 0) {
              goto LABEL_158;
            }
            goto LABEL_185;
          }
        }
        else if ((v263 & 2) == 0)
        {
          goto LABEL_157;
        }
        *(unsigned char *)(v262 + 25) = BYTE3(v263);
        if ((v215 & 4) == 0)
        {
LABEL_158:
          if ((v215 & 8) == 0) {
            goto LABEL_159;
          }
          goto LABEL_186;
        }
LABEL_185:
        *(unsigned char *)(v262 + 26) = BYTE4(v263);
        if ((v215 & 8) == 0)
        {
LABEL_159:
          if ((v215 & 0x10) == 0) {
            goto LABEL_160;
          }
          goto LABEL_187;
        }
LABEL_186:
        *(unsigned char *)(v262 + 27) = BYTE5(v263);
        if ((v215 & 0x10) == 0)
        {
LABEL_160:
          if ((v215 & 0x20) == 0) {
            goto LABEL_161;
          }
          goto LABEL_188;
        }
LABEL_187:
        *(unsigned char *)(v262 + 28) = BYTE6(v263);
        if ((v215 & 0x20) == 0)
        {
LABEL_161:
          if ((v215 & 0x40) == 0) {
            goto LABEL_162;
          }
          goto LABEL_189;
        }
LABEL_188:
        *(unsigned char *)(v262 + 30) = v264;
        if ((v215 & 0x40) == 0)
        {
LABEL_162:
          if ((v215 & 0x100) == 0) {
            goto LABEL_163;
          }
          goto LABEL_190;
        }
LABEL_189:
        *(unsigned char *)(v262 + 31) = HIBYTE(v264);
        if ((v215 & 0x100) == 0)
        {
LABEL_163:
          if ((v215 & 0x200) == 0) {
            goto LABEL_164;
          }
          goto LABEL_191;
        }
LABEL_190:
        *(unsigned char *)(v262 + 29) = *(unsigned char *)(v262 + 29) & 0xFE | HIBYTE(v263) & 1;
        if ((v215 & 0x200) == 0)
        {
LABEL_164:
          if ((v215 & 0x400) == 0) {
            goto LABEL_165;
          }
          goto LABEL_192;
        }
LABEL_191:
        *(unsigned char *)(v262 + 29) = *(unsigned char *)(v262 + 29) & 0xFD | HIBYTE(v263) & 2;
        if ((v215 & 0x400) == 0)
        {
LABEL_165:
          if ((v215 & 0x800) == 0) {
            goto LABEL_166;
          }
          goto LABEL_193;
        }
LABEL_192:
        *(unsigned char *)(v262 + 29) = *(unsigned char *)(v262 + 29) & 0xFB | HIBYTE(v263) & 4;
        if ((v215 & 0x800) == 0)
        {
LABEL_166:
          if ((v215 & 0x1000) == 0) {
            goto LABEL_167;
          }
          goto LABEL_194;
        }
LABEL_193:
        *(unsigned char *)(v262 + 29) = *(unsigned char *)(v262 + 29) & 0xF7 | HIBYTE(v263) & 8;
        if ((v215 & 0x1000) == 0)
        {
LABEL_167:
          if ((v215 & 0x2000) == 0)
          {
LABEL_169:
            uint64_t v216 = sub_10024A3D8(v4, 0, v20, (uint64_t)&v263);
            if (!v216) {
              return;
            }
            uint64_t v217 = v216;
            if (!sub_100058654()) {
              return;
            }
            sub_100056E24((uint64_t)"%! (%d)", v218, v219, v220, v221, v222, v223, v224, v217);
            uint64_t v225 = sub_100050B4C(0x32u);
            if (!os_log_type_enabled(v225, OS_LOG_TYPE_ERROR)) {
              return;
            }
            goto LABEL_220;
          }
LABEL_168:
          *(unsigned char *)(v262 + 29) = *(unsigned char *)(v262 + 29) & 0xDF | HIBYTE(v263) & 0x20;
          goto LABEL_169;
        }
LABEL_194:
        *(unsigned char *)(v262 + 29) = *(unsigned char *)(v262 + 29) & 0xEF | HIBYTE(v263) & 0x10;
        if ((v215 & 0x2000) == 0) {
          goto LABEL_169;
        }
        goto LABEL_168;
      }
      if (v7 == 1)
      {
        uint64_t v72 = sub_100244A2C(a1, v36 >> 2, &v262);
        if (v72)
        {
          uint64_t v73 = v72;
          if (sub_100058654())
          {
            sub_100056E24((uint64_t)"Receive RPN with result %! on DLCI %d", v74, v75, v76, v77, v78, v79, v80, v73);
            uint64_t v81 = sub_100050B4C(0x32u);
            if (os_log_type_enabled(v81, OS_LOG_TYPE_ERROR)) {
              sub_100744F6C();
            }
          }
          uint64_t v260 = 50806655;
          __int16 v261 = 4881;
          if ((v5 & 2) != 0)
          {
            uint64_t v82 = sub_10024A3D8(v4, 0, v20, (uint64_t)&v260);
            if (v82)
            {
              uint64_t v83 = v82;
              if (sub_100058654())
              {
                sub_100056E24((uint64_t)"%! (%d)", v84, v85, v86, v87, v88, v89, v90, v83);
                unsigned __int8 v91 = sub_100050B4C(0x32u);
                if (os_log_type_enabled(v91, OS_LOG_TYPE_ERROR)) {
                  sub_100744F6C();
                }
              }
            }
          }
          return;
        }
        if ((v5 & 2) != 0)
        {
          uint64_t v227 = sub_10024A3D8(v4, 0, v20, v262 + 22);
          if (!v227) {
            return;
          }
          uint64_t v228 = v227;
          if (!sub_100058654()) {
            return;
          }
          sub_100056E24((uint64_t)"%! (%d)", v229, v230, v231, v232, v233, v234, v235, v228);
          uint64_t v236 = sub_100050B4C(0x32u);
          if (!os_log_type_enabled(v236, OS_LOG_TYPE_ERROR)) {
            return;
          }
        }
        else
        {
          if (!sub_100058654()) {
            return;
          }
          sub_100056E24((uint64_t)"Mux_ReceiveRPN, command is parameter report but C/R bit is not set, ignoring", v195, v196, v197, v198, v199, v200, v201, v259);
          v202 = sub_100050B4C(0x32u);
          if (!os_log_type_enabled(v202, OS_LOG_TYPE_ERROR)) {
            return;
          }
        }
LABEL_220:
        sub_100744F6C();
        return;
      }
      if (sub_100058654())
      {
        sub_100056E24((uint64_t)"%! (%d)", v148, v149, v150, v151, v152, v153, v154, 917);
        uint64_t v155 = sub_100050B4C(0x32u);
        if (os_log_type_enabled(v155, OS_LOG_TYPE_ERROR)) {
          goto LABEL_118;
        }
      }
      return;
    case 9u:
      if (!a1)
      {
        sub_10025B8C0();
        char v5 = *a2;
      }
      if ((v5 & 2) != 0)
      {
        sub_10024A250(v4, 0);
        if (!*(unsigned char *)(v4 + 44))
        {
          *(unsigned char *)(v4 + 45) = 1;
          sub_1002483A8(v4);
        }
      }
      else
      {
LABEL_49:
        a1 = v4;
LABEL_22:
        sub_100249F20(a1);
      }
      return;
    case 0xDu:
      if (!a1) {
        sub_10025B8C0();
      }
      uint64_t v263 = 0;
      uint64_t v20 = a2[2] >> 2;
      char v46 = a2[3];
      if (v7 == 2)
      {
        uint64_t v47 = 0;
      }
      else
      {
        if (v7 != 3)
        {
          if (sub_100058654())
          {
            sub_100056E24((uint64_t)"%! (%d)", v102, v103, v104, v105, v106, v107, v108, 917);
            uint64_t v109 = sub_100050B4C(0x32u);
            if (os_log_type_enabled(v109, OS_LOG_TYPE_ERROR)) {
LABEL_118:
            }
              sub_100744F6C();
          }
          return;
        }
        uint64_t v47 = ((char)(a2[4] << 6) >> 7) & (a2[4] >> 4);
      }
      uint64_t v92 = sub_100244A2C(v4, v20, &v263);
      if (v92)
      {
        uint64_t v93 = v92;
        if (sub_100058654())
        {
          sub_100056E24((uint64_t)"%! (%d)", v94, v95, v96, v97, v98, v99, v100, v93);
          uint64_t v101 = sub_100050B4C(0x32u);
          if (os_log_type_enabled(v101, OS_LOG_TYPE_ERROR)) {
            sub_100744F6C();
          }
        }
        if ((*a2 & 2) != 0) {
LABEL_90:
        }
          sub_1002485D4(15, v4, v20);
        return;
      }
      if ((*a2 & 2) != 0)
      {
        sub_10024A338(v4, 0, v20, v46, v47);
        uint64_t v167 = v263;
        if (!*(unsigned char *)(v4 + 44))
        {
          if ((v46 & 2) != 0)
          {
            *(unsigned char *)(v263 + 32) = 0;
          }
          else
          {
            *(unsigned char *)(v263 + 32) = 1;
            sub_10024834C(v167);
            uint64_t v167 = v263;
          }
        }
        uint64_t v237 = *(void (**)(void, void, uint64_t))(*(void *)(v167 + 40) + 24);
        if (v237) {
          v237(*(unsigned __int16 *)(v167 + 8), v46 & 0xCE, v47);
        }
        return;
      }
      sub_100249F20(v4);
      uint64_t v126 = v263;
      if (*(unsigned char *)(v263 + 13) != 4) {
        return;
      }
      *(unsigned char *)(v263 + 13) = 5;
      if (!*(unsigned char *)(v4 + 44)) {
        goto LABEL_202;
      }
      unsigned int v127 = *(unsigned __int8 *)(v126 + 162);
      if (*(unsigned char *)(v126 + 162))
      {
        unsigned int v128 = *(unsigned __int8 *)(v126 + 14);
        if (v127 < v128)
        {
          sub_10025B8C0();
          uint64_t v126 = v263;
          LOBYTE(v127) = *(unsigned char *)(v263 + 162);
          LOBYTE(v128) = *(unsigned char *)(v263 + 14);
        }
        unsigned __int8 v129 = v127 - v128 - *(unsigned char *)(v126 + 163);
        if (!v129)
        {
LABEL_202:
          uint64_t v238 = *(void (**)(void, void, void))(v126 + 72);
          if (v238)
          {
            v238(*(unsigned __int16 *)(v126 + 8), *(unsigned __int16 *)(v126 + 16), 0);
            *(void *)(v263 + 72) = 0;
          }
          return;
        }
      }
      else
      {
        unsigned __int8 v129 = -1;
      }
      if (sub_1002482D4(v126, v129)) {
        return;
      }
      uint64_t v126 = v263;
      goto LABEL_202;
    default:
      LOWORD(v263) = 785;
      BYTE2(v263) = v5 & 0xFE;
      sub_100248ABC(a1, 0, (char *)&v263, 3uLL, 0);
      return;
  }
}

uint64_t sub_10024B514(int a1, char a2, unsigned int a3, __int16 a4, int a5)
{
  uint64_t v9 = sub_100244F6C(a1);
  if (!v9) {
    return 114;
  }
  uint64_t v40 = 0;
  uint64_t v10 = 2 * (a2 & 0x7Fu);
  if (v10 >= 0x3E)
  {
    if (sub_100058654())
    {
      sub_100056E24((uint64_t)"%! (%d)", v11, v12, v13, v14, v15, v16, v17, 917);
      long long v18 = sub_100050B4C(0x32u);
      if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR)) {
        sub_100744F6C();
      }
    }
    return 114;
  }
  uint64_t v19 = v9;
  if (sub_100244A2C(v9, v10, &v40))
  {
    if (!sub_100058654()) {
      return 114;
    }
    sub_100056E24((uint64_t)"Could not find link for DLCI (%d)", v20, v21, v22, v23, v24, v25, v26, v10);
    uint64_t v27 = sub_100050B4C(0x32u);
    if (!os_log_type_enabled(v27, OS_LOG_TYPE_ERROR)) {
      return 114;
    }
    goto LABEL_9;
  }
  uint64_t v28 = v40;
  if (*(unsigned char *)(v40 + 13)) {
    return 114;
  }
  if (*(unsigned __int16 *)(v40 + 16) >= a3) {
    *(_WORD *)(v40 + 16) = a3;
  }
  if (a5)
  {
    *(unsigned char *)(v19 + 44) = 1;
    *(_WORD *)(v28 + 18) = a4;
    uint64_t v30 = sub_100247F44(v28);
    if (v30)
    {
      uint64_t v31 = v30;
      if (!sub_100058654()) {
        return 114;
      }
      sub_100056E24((uint64_t)"%! (%d)", v32, v33, v34, v35, v36, v37, v38, v31);
      uint64_t v39 = sub_100050B4C(0x32u);
      if (!os_log_type_enabled(v39, OS_LOG_TYPE_ERROR)) {
        return 114;
      }
LABEL_9:
      sub_100744F6C();
      return 114;
    }
    uint64_t v28 = v40;
  }
  else
  {
    LOBYTE(a4) = 0;
    *(unsigned char *)(v19 + 44) = 0;
  }
  uint64_t result = 0;
  *(unsigned char *)(v28 + 14) = a4;
  *(unsigned char *)(v28 + 13) = 5;
  return result;
}

uint64_t sub_10024B6B8(uint64_t a1, int a2, uint64_t a3)
{
  if (!a1 || !a3)
  {
    sub_10025B8C0();
    return 101;
  }
  if (!*(_DWORD *)(a1 + 8) && !*(void *)(a1 + 16))
  {
    sub_10025B8C0();
    if (!*(_DWORD *)(a1 + 8) && !*(void *)(a1 + 16)) {
      return 101;
    }
  }
  if (dword_100A1987C) {
    return 924;
  }
  unint64_t v8 = sub_100022FE8(0x18uLL);
  qword_100A103B8 = (uint64_t)v8;
  if (!v8) {
    return 106;
  }
  v8[1] = a1;
  void v8[2] = a3;
  *(_DWORD *)(a1 + 172) = 0;
  *(unsigned char *)(a1 + 24) = 0;
  *(unsigned char *)(v8[1] + 64) = 0;
  uint64_t v9 = v8[1];
  *(_DWORD *)(v9 + 166) = 0;
  *(_DWORD *)unint64_t v8 = a2;
  *((unsigned char *)v8 + 4) = 0;
  uint64_t v6 = sub_10024BFDC((uint64_t)sub_10024B7CC, (uint64_t)sub_10024B998, v9);
  if (v6)
  {
    if (qword_100A103B8)
    {
      sub_100023010((void *)qword_100A103B8);
      qword_100A103B8 = 0;
    }
  }
  else
  {
    dword_100A1987C = 1;
  }
  return v6;
}

uint64_t sub_10024B7CC(uint64_t a1)
{
  if (a1 == 834)
  {
    uint64_t v4 = *(void *)(qword_100A103B8 + 8);
    uint64_t v1 = 834;
  }
  else
  {
    uint64_t v1 = a1;
    if (!a1)
    {
      long long v10 = 0u;
      long long v11 = 0u;
      v9[0] = 0;
      v8[0] = 0;
      LOBYTE(v10) = 3;
      WORD1(v10) = 2;
      DWORD2(v10) = 3;
      uint64_t v2 = *(void *)(qword_100A103B8 + 8);
      if (*(_DWORD *)(v2 + 8))
      {
        DWORD2(v11) = *(_DWORD *)(v2 + 8);
        __int16 v3 = 4;
      }
      else
      {
        *((void *)&v11 + 1) = *(void *)(v2 + 16);
        __int16 v3 = 16;
      }
      LOBYTE(v11) = 3;
      WORD1(v11) = v3;
      LOBYTE(v9[0]) = 6;
      WORD1(v9[0]) = 2;
      v9[1] = &v10;
      LOBYTE(v8[0]) = 6;
      WORD1(v8[0]) = 6;
      v8[1] = &unk_1007BAB58;
      uint64_t result = sub_10024CE58((uint64_t)sub_10024B9D4, (unsigned __int8 *)v9, (unsigned __int8 *)v8);
      if (result)
      {
        *(_DWORD *)(*(void *)(qword_100A103B8 + 8) + 172) = result;
        return sub_10024BEA4();
      }
      return result;
    }
    uint64_t v5 = qword_100A103B8;
    if ((*(_DWORD *)qword_100A103B8)--)
    {
      uint64_t result = sub_10024BFDC((uint64_t)sub_10024B7CC, (uint64_t)sub_10024B998, *(void *)(v5 + 8));
      if (!result) {
        return result;
      }
      uint64_t v1 = result;
      uint64_t v5 = qword_100A103B8;
    }
    uint64_t v4 = *(void *)(v5 + 8);
  }

  return sub_10024BEE8(v4, v1);
}

uint64_t sub_10024B998()
{
  uint64_t v0 = *(void *)(qword_100A103B8 + 8);
  uint64_t v1 = *(unsigned int *)(v0 + 172);
  if (!v1)
  {
    if (*(unsigned char *)(v0 + 164) && *(unsigned char *)(qword_100A103B8 + 4))
    {
      uint64_t v1 = 0;
    }
    else
    {
      uint64_t v1 = 923;
      *(_DWORD *)(v0 + 172) = 923;
    }
  }
  return sub_10024BEE8(v0, v1);
}

uint64_t sub_10024B9D4(uint64_t a1, int a2, int a3)
{
  if (!a3)
  {
    if (*(_WORD *)(a1 + 2))
    {
      unint64_t v4 = 0;
      uint64_t v50 = a1;
      while (1)
      {
        uint64_t v5 = *(void *)(a1 + 8) + 16 * v4;
        unsigned int v7 = *(unsigned __int16 *)(v5 + 2);
        uint64_t v6 = (unsigned __int16 *)(v5 + 2);
        if (v7 >= 2)
        {
          uint64_t v8 = 0;
          uint64_t v9 = (void *)(*(void *)(a1 + 8) + 16 * v4 + 8);
          do
          {
            uint64_t v10 = *v9 + 16 * v8;
            uint64_t v51 = 0;
            uint64_t v52 = 0;
            int v11 = *(_DWORD *)(v10 + 8);
            if (v11 > 255)
            {
              switch(v11)
              {
                case 512:
                  *(_WORD *)(*(void *)(qword_100A103B8 + 8) + 166) = *(_DWORD *)(v10 + 24);
                  break;
                case 257:
                  int v33 = *(unsigned __int8 *)(v10 + 16);
                  if (v33 == 8 || v33 == 4)
                  {
                    if (*(unsigned __int16 *)(v10 + 18) >= 0x63u) {
                      size_t v35 = 99;
                    }
                    else {
                      size_t v35 = *(unsigned __int16 *)(v10 + 18);
                    }
                    memmove((void *)(*(void *)(qword_100A103B8 + 8) + 64), *(const void **)(v10 + 24), v35);
                    *(unsigned char *)(*(void *)(qword_100A103B8 + 8) + v35 + 64) = 0;
                  }
                  break;
                case 256:
                  int v23 = *(unsigned __int8 *)(v10 + 16);
                  if (v23 == 8 || v23 == 4)
                  {
                    if (*(unsigned __int16 *)(v10 + 18) >= 0x27u) {
                      size_t v25 = 39;
                    }
                    else {
                      size_t v25 = *(unsigned __int16 *)(v10 + 18);
                    }
                    memmove((void *)(*(void *)(qword_100A103B8 + 8) + 24), *(const void **)(v10 + 24), v25);
                    *(unsigned char *)(*(void *)(qword_100A103B8 + 8) + v25 + 24) = 0;
                  }
                  break;
              }
            }
            else if (v11 == 1)
            {
              if ((*(unsigned char *)(v10 + 16) & 0xFE) == 6)
              {
                uint64_t v26 = *(void *)(qword_100A103B8 + 8);
                int v27 = *(_DWORD *)(v26 + 8);
                LOBYTE(v51) = 3;
                if (v27)
                {
                  WORD1(v51) = 4;
                  LODWORD(v52) = v27;
                }
                else
                {
                  WORD1(v51) = 16;
                  uint64_t v52 = *(void *)(v26 + 16);
                }
                if (*(_WORD *)(v10 + 18))
                {
                  uint64_t v36 = 0;
                  unint64_t v37 = 0;
                  while (!sub_1001780EC(*(void *)(v10 + 24) + v36, (uint64_t)&v51))
                  {
                    ++v37;
                    v36 += 16;
                    if (v37 >= *(unsigned __int16 *)(v10 + 18)) {
                      goto LABEL_63;
                    }
                  }
                  *(unsigned char *)(qword_100A103B8 + 4) = 1;
                }
              }
            }
            else if (v11 == 4)
            {
              if ((*(unsigned char *)(v10 + 16) & 0xFE) == 6 && *(_WORD *)(v10 + 18))
              {
                uint64_t v28 = 0;
                unint64_t v29 = 0;
                do
                {
                  uint64_t v30 = *(void *)(v10 + 24);
                  *(_OWORD *)long long buf = xmmword_1007BABC0;
                  if ((*(unsigned char *)(v30 + v28) & 0xFE) == 6)
                  {
                    uint64_t v31 = v30 + v28;
                    if (*(_WORD *)(v30 + v28 + 2))
                    {
                      if (sub_1001780EC(*(void *)(v31 + 8), (uint64_t)buf))
                      {
                        uint64_t v32 = *(void *)(v31 + 8);
                        if (*(unsigned char *)(v32 + 16) == 1 && *(_WORD *)(v32 + 18) == 1) {
                          *(unsigned char *)(*(void *)(qword_100A103B8 + 8) + 164) = *(_DWORD *)(v32 + 24);
                        }
                      }
                    }
                  }
                  ++v29;
                  v28 += 16;
                }
                while (v29 < *(unsigned __int16 *)(v10 + 18));
              }
            }
            else if (v11 == 9 && (*(unsigned char *)(v10 + 16) & 0xFE) == 6)
            {
              uint64_t v12 = *(void *)(v10 + 24);
              if ((*(unsigned char *)v12 & 0xFE) == 6)
              {
                uint64_t v13 = *(void *)(v12 + 8);
                if (*(unsigned __int16 *)(v13 + 2) >= 2u && *(unsigned char *)(v13 + 16) == 1)
                {
                  *(_WORD *)(*(void *)(qword_100A103B8 + 8) + 168) = *(_DWORD *)(v13 + 24);
                  if (sub_100058654())
                  {
                    sub_100056E24((uint64_t)"Profile Version: %x", v14, v15, v16, v17, v18, v19, v20, *(unsigned __int16 *)(*(void *)(qword_100A103B8 + 8) + 168));
                    uint64_t v21 = sub_100050B4C(0x33u);
                    if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
                    {
                      uint64_t v22 = sub_100050714();
                      *(_DWORD *)long long buf = 136446210;
                      *(void *)&uint8_t buf[4] = v22;
                      _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
                    }
                  }
                }
              }
            }
LABEL_63:
            v8 += 2;
          }
          while ((v8 | 1uLL) < *v6);
        }
        uint64_t v38 = qword_100A103B8;
        uint64_t v39 = *(void *)(qword_100A103B8 + 8);
        if (*(unsigned char *)(v39 + 164))
        {
          if (*(unsigned char *)(qword_100A103B8 + 4)) {
            break;
          }
        }
        *(unsigned char *)(v39 + 164) = 0;
        *(unsigned char *)(v39 + 24) = 0;
        *(unsigned char *)(*(void *)(v38 + 8) + 64) = 0;
        ++v4;
        a1 = v50;
        if (v4 >= *(unsigned __int16 *)(v50 + 2)) {
          goto LABEL_67;
        }
      }
      sub_10024D180();
    }
    else
    {
LABEL_67:
      if (a2)
      {
        uint64_t result = sub_10024D124();
        uint64_t v40 = result;
        if (!result) {
          return result;
        }
      }
      else
      {
        uint64_t v40 = 923;
      }
      if (sub_100058654())
      {
        sub_100056E24((uint64_t)"OI_SDP_ContinueCurrentReq returned %!", v41, v42, v43, v44, v45, v46, v47, v40);
        uint64_t v48 = sub_100050B4C(0x33u);
        if (os_log_type_enabled(v48, OS_LOG_TYPE_ERROR)) {
          sub_1007457DC(v48);
        }
      }
      *(_DWORD *)(*(void *)(qword_100A103B8 + 8) + 172) = v40;
    }
    return sub_10024BEA4();
  }
  *(_DWORD *)(*(void *)(qword_100A103B8 + 8) + 172) = a3;

  return sub_10024BEA4();
}

uint64_t sub_10024BEA4()
{
  uint64_t result = sub_10024C674();
  if (result)
  {
    uint64_t v1 = result;
    uint64_t v2 = *(void *)(qword_100A103B8 + 8);
    return sub_10024BEE8(v2, v1);
  }
  return result;
}

uint64_t sub_10024BEE8(uint64_t a1, uint64_t a2)
{
  unint64_t v4 = (void *)qword_100A103B8;
  if (*(void *)(qword_100A103B8 + 8) != a1)
  {
    sub_10025B8C0();
    unint64_t v4 = (void *)qword_100A103B8;
  }
  uint64_t v6 = (uint64_t (*)(uint64_t, uint64_t))v4[2];
  sub_100023010(v4);
  qword_100A103B8 = 0;
  dword_100A1987C = 0;

  return v6(a1, a2);
}

uint64_t sub_10024BF70(unsigned int a1, _WORD *a2)
{
  unsigned int v3 = 0;
  v4[0] = 262147;
  v4[1] = a1;
  if (sub_10024E6B4((uint64_t)v4, 1u, a2, &v3, 0)) {
    return 0;
  }
  else {
    return v3;
  }
}

void sub_10024BFCC()
{
  byte_100A103C0 = 1;
}

uint64_t sub_10024BFDC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (xmmword_100A19880) {
    return 821;
  }
  if (!*(_WORD *)(sub_10025B218(0x34u) + 2)) {
    sub_10025B8C0();
  }
  if (!*(_WORD *)sub_10025B218(0x34u)) {
    sub_10025B8C0();
  }
  if (xmmword_100A19880)
  {
    uint64_t v3 = 140;
LABEL_10:
    if (sub_100058654())
    {
      sub_100056E24((uint64_t)"SDP client init failed %!", v8, v9, v10, v11, v12, v13, v14, v3);
      uint64_t v15 = sub_100050B4C(0x34u);
      if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR)) {
        sub_10074932C();
      }
    }
    return v3;
  }
  uint64_t v16 = sub_10010CE48(0x60uLL);
  qword_100A103C8 = (uint64_t)v16;
  if (!v16)
  {
    uint64_t v3 = 106;
    goto LABEL_10;
  }
  if (byte_100A103C0 == 1)
  {
    unsigned int v17 = 1024;
    v16[44] = 1024;
    LODWORD(xmmword_100A19880) = 1;
    long long v21 = 0u;
    long long v22 = 0u;
    WORD2(v21) = 5000;
    LODWORD(v21) = -64512;
  }
  else
  {
    unsigned int v17 = (unsigned __int16)v16[44];
    LODWORD(xmmword_100A19880) = 1;
    long long v22 = 0uLL;
    *((void *)&v21 + 1) = 0;
    *(_DWORD *)((char *)&v21 + 2) = 327745535;
    if (!v17) {
      unsigned int v17 = *(unsigned __int16 *)sub_10025B218(0x34u);
    }
    LOWORD(v21) = v17;
    if (v17 <= 0x80)
    {
      __int16 v18 = 128;
      goto LABEL_23;
    }
  }
  if (v17 <= *(unsigned __int16 *)(sub_10025B218(0x28u) + 8)) {
    goto LABEL_24;
  }
  __int16 v18 = *(_WORD *)(sub_10025B218(0x28u) + 8);
LABEL_23:
  LOWORD(v21) = v18;
LABEL_24:
  WORD3(v21) = 772;
  WORD6(v21) = 0;
  BYTE8(v22) = 0;
  uint64_t v19 = sub_1001DF7BC((uint64_t)sub_10024C200, (uint64_t)sub_10024C3AC, (uint64_t)sub_10024C3B0, 1, a3, (uint64_t)&v21, (_WORD *)(qword_100A103C8 + 4), (uint64_t)&unk_1007BABD0);
  if (v19)
  {
    uint64_t v3 = v19;
    sub_10024C5C4();
  }
  else
  {
    uint64_t v20 = qword_100A103C8;
    *(_DWORD *)qword_100A103C8 = 0;
    *(void *)(v20 + 72) = a2;
    *(void *)(v20 + 80) = a1;
    if (off_100A103D0) {
      off_100A103D0(1);
    }
    return 0;
  }
  return v3;
}

void sub_10024C200(unsigned int a1, unsigned int a2, unsigned int a3, uint64_t a4)
{
  if (xmmword_100A19880 && !*(_DWORD *)qword_100A103C8)
  {
    uint64_t v13 = a4;
    if (a4)
    {
      if (sub_100058654())
      {
        sub_100056E24((uint64_t)"SDP client connect failed %!", v14, v15, v16, v17, v18, v19, v20, v13);
        long long v21 = sub_100050B4C(0x34u);
        if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR)) {
          sub_10074932C();
        }
      }
      if (off_100A103D0) {
        off_100A103D0(0);
      }
    }
    else
    {
      __int16 v22 = a3;
      if (*(unsigned __int16 *)(sub_10025B218(0x34u) + 2) < a3) {
        __int16 v22 = *(_WORD *)(sub_10025B218(0x34u) + 2);
      }
      uint64_t v24 = qword_100A103C8;
      *(_WORD *)(qword_100A103C8 + 12) = v22;
      int v25 = *(unsigned __int16 *)(v24 + 88);
      if (!v25)
      {
        uint64_t v26 = (unsigned __int16 *)sub_10025B218(0x34u);
        LOWORD(v25) = a2;
        if (*v26 < a2) {
          LOWORD(v25) = *(_WORD *)sub_10025B218(0x34u);
        }
      }
      uint64_t v27 = qword_100A103C8;
      *(_WORD *)(qword_100A103C8 + 14) = v25;
      *(_DWORD *)uint64_t v27 = 1;
      uint64_t v28 = sub_100022FE8(*(unsigned __int16 *)(v27 + 12));
      uint64_t v29 = qword_100A103C8;
      *(void *)(qword_100A103C8 + 24) = v28;
      if (v28)
      {
        (*(void (**)(void))(v29 + 80))(0);
        return;
      }
      uint64_t v13 = 106;
    }
    uint64_t v30 = *(void (**)(uint64_t))(qword_100A103C8 + 80);
    sub_10024C5C4();
    v30(v13);
  }
  else if (sub_100058654())
  {
    sub_100056E24((uint64_t)"Spurious connect complete callback CID = %d", v5, v6, v7, v8, v9, v10, v11, a1);
    uint64_t v12 = sub_100050B4C(0x34u);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR)) {
      sub_10074A5AC();
    }
  }
}

void sub_10024C3B0(uint64_t a1, char *a2, unsigned int a3)
{
  uint64_t v32 = 0;
  uint64_t v33 = 0;
  if (*(unsigned __int16 *)(qword_100A103C8 + 4) == a1)
  {
    sub_100026DB4(*(unsigned int *)(qword_100A103C8 + 8));
    if (*(_DWORD *)qword_100A103C8 == 2)
    {
      if (a3 < 5)
      {
        uint64_t v5 = 804;
LABEL_35:
        sub_10024DBE0(v5);
        return;
      }
      if (!a2) {
        sub_10014327C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdp.c", 1141, "buf");
      }
      uint64_t v32 = a2;
      LOWORD(v33) = a3;
      WORD1(v33) = a3;
      int v23 = *a2;
      unsigned int v24 = bswap32(*(unsigned __int16 *)(a2 + 1));
      HIDWORD(v33) = 65539;
      if (*(unsigned __int16 *)(qword_100A103C8 + 68) != HIWORD(v24))
      {
        uint64_t v5 = 830;
        goto LABEL_35;
      }
      int v25 = a2[4];
      int v26 = a2[3];
      WORD2(v33) = 5;
      if (v23 != *(unsigned __int8 *)(qword_100A103C8 + 32))
      {
        if (v23 == 1)
        {
          if (a3 - 7 > 0xFFFFFFFD)
          {
            HIBYTE(v33) = 1;
            unsigned int v28 = 800;
          }
          else
          {
            unsigned int v27 = __rev16(*(unsigned __int16 *)(a2 + 5));
            WORD2(v33) = 7;
            unsigned int v28 = v27 + 800;
          }
          if (v28 >= 0x327) {
            uint64_t v5 = 807;
          }
          else {
            uint64_t v5 = v28;
          }
        }
        else
        {
          uint64_t v5 = 831;
        }
        goto LABEL_35;
      }
      if ((v25 | (v26 << 8)) < a3 - 5)
      {
        uint64_t v5 = 829;
        goto LABEL_35;
      }
      int v29 = *(unsigned __int8 *)(qword_100A103C8 + 32);
      if (v29 == 7 || v29 == 5)
      {
        uint64_t v5 = sub_10024D458((uint64_t)&v32);
      }
      else if (v29 == 3)
      {
        uint64_t v5 = sub_10024D24C((uint64_t *)&v32);
      }
      else
      {
        sub_10025B8C0();
        uint64_t v5 = 0;
      }
      if (v5) {
        goto LABEL_35;
      }
    }
    else if (sub_100058654())
    {
      sub_100056E24((uint64_t)"SDP client not expecting data at this time", v15, v16, v17, v18, v19, v20, v21, v31);
      __int16 v22 = sub_100050B4C(0x34u);
      if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR)) {
        sub_10074A6AC();
      }
    }
  }
  else if (sub_100058654())
  {
    sub_100056E24((uint64_t)"ReceivedResponseCB no server corresponds to CID = %x", v7, v8, v9, v10, v11, v12, v13, a1);
    uint64_t v14 = sub_100050B4C(0x34u);
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR)) {
      sub_10074A5AC();
    }
  }
}

void sub_10024C5C4()
{
  uint64_t v0 = (void **)qword_100A103C8;
  if (*(_DWORD *)(qword_100A103C8 + 8))
  {
    sub_100026DB4(*(unsigned int *)(qword_100A103C8 + 8));
    uint64_t v1 = qword_100A103C8;
    *(_DWORD *)(qword_100A103C8 + 8) = 0;
    sub_1001E121C(*(unsigned __int16 *)(v1 + 4), 436);
    uint64_t v0 = (void **)qword_100A103C8;
  }
  if (v0[3])
  {
    sub_100023010(v0[3]);
    uint64_t v0 = (void **)qword_100A103C8;
    *(void *)(qword_100A103C8 + 24) = 0;
  }
  if (v0[5])
  {
    sub_100023010(v0[5]);
    uint64_t v0 = (void **)qword_100A103C8;
    *(void *)(qword_100A103C8 + 40) = 0;
  }
  if (v0[7])
  {
    sub_100023010(v0[7]);
    uint64_t v0 = (void **)qword_100A103C8;
    *(void *)(qword_100A103C8 + 56) = 0;
  }
  sub_100023010(v0);
  qword_100A103C8 = 0;
  byte_100A103C0 = 0;
  LODWORD(xmmword_100A19880) = 0;
}

uint64_t sub_10024C674()
{
  if (!xmmword_100A19880) {
    return 810;
  }
  uint64_t v0 = qword_100A103C8;
  if (*(_DWORD *)qword_100A103C8 == 3) {
    return 810;
  }
  if (off_100A103D0)
  {
    off_100A103D0(0);
    uint64_t v0 = qword_100A103C8;
  }
  uint64_t v1 = sub_1001E121C(*(unsigned __int16 *)(v0 + 4), 436);
  if (v1)
  {
    sub_10024C714(*(unsigned __int16 *)(qword_100A103C8 + 4));
  }
  else
  {
    sub_100026DB4(*(unsigned int *)(qword_100A103C8 + 8));
    uint64_t v2 = (_DWORD *)qword_100A103C8;
    *(_DWORD *)(qword_100A103C8 + 8) = 0;
    *uint64_t v2 = 3;
  }
  return v1;
}

uint64_t sub_10024C714(uint64_t result)
{
  if (xmmword_100A19880)
  {
    uint64_t v1 = result;
    if (off_100A103D0) {
      off_100A103D0(0);
    }
    if (*(unsigned __int16 *)(qword_100A103C8 + 4) != v1 && sub_100058654())
    {
      sub_100056E24((uint64_t)"No SDP connection for CID %d", v2, v3, v4, v5, v6, v7, v8, v1);
      uint64_t v9 = sub_100050B4C(0x34u);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR)) {
        sub_10074A5AC();
      }
    }
    uint64_t v10 = *(uint64_t (**)(void))(qword_100A103C8 + 72);
    sub_10024C5C4();
    return v10();
  }
  return result;
}

uint64_t sub_10024C7C8(uint64_t a1, unsigned int a2, unsigned __int8 *a3)
{
  if (!xmmword_100A19880) {
    return 810;
  }
  uint64_t v3 = qword_100A103C8;
  int v4 = *(_DWORD *)qword_100A103C8;
  if (!*(_DWORD *)qword_100A103C8 || v4 == 3) {
    return 810;
  }
  if (v4 == 2) {
    return 817;
  }
  if (!a2) {
    return 825;
  }
  *(_WORD *)(qword_100A103C8 + 48) = a2;
  *(_WORD *)(v3 + 50) = 0;
  int v10 = sub_100179F4C(a3);
  if (v10 == 65534) {
    return 106;
  }
  unsigned __int16 v11 = v10 + 24;
  if (*(unsigned __int16 *)(qword_100A103C8 + 12) < (unsigned __int16)(v10 + 24)) {
    return 816;
  }
  uint64_t v12 = sub_100022FE8(4 * a2);
  uint64_t v13 = qword_100A103C8;
  *(void *)(qword_100A103C8 + 40) = v12;
  if (!v12) {
    return 106;
  }
  uint64_t v14 = *(unsigned char **)(v13 + 24);
  if (!v14)
  {
    uint64_t v19 = "SDP_State->ReqBuffer";
    goto LABEL_32;
  }
  if (!v11)
  {
    uint64_t v19 = "(bufLen) > 0";
LABEL_32:
    sub_10014327C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdp.c", 1315, v19);
  }
  __int16 v22 = v14;
  unsigned __int16 v23 = v11;
  __int16 v26 = 2;
  unsigned __int16 v24 = v11;
  *uint64_t v14 = 2;
  if ((unint64_t)v11 - 5 >= 0xFFFFFFFFFFFFFFFCLL) {
    sub_10014327C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdp.c", 1324, "ByteStream_NumReadBytesAvail(request) >= (2 * sizeof(uint16_t))");
  }
  unsigned __int16 v25 = 5;
  sub_10017A224((uint64_t)&v22, a3);
  if (HIBYTE(v26))
  {
    sub_10025A794((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdp.c");
    goto LABEL_35;
  }
  if (v24 - v25 <= 1)
  {
LABEL_35:
    uint64_t v20 = "ByteStream_NumReadBytesAvail(request) >= 2";
    goto LABEL_37;
  }
  if (v26 != 2)
  {
    uint64_t v20 = "(request).__RWFlag == BYTESTREAM_WRITE";
LABEL_37:
    sub_10014327C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdp.c", 1332, v20);
  }
  v22[v25 + 1] = *(unsigned char *)(qword_100A103C8 + 48);
  v22[v25] = *(unsigned char *)(qword_100A103C8 + 49);
  unsigned __int16 v15 = v25;
  unsigned __int16 v16 = v25 + 2;
  unsigned __int16 v25 = v16;
  *(_WORD *)(qword_100A103C8 + 16) = v16;
  if (HIBYTE(v26))
  {
    sub_10025A794((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdp.c");
    goto LABEL_39;
  }
  if (v24 <= v16)
  {
LABEL_39:
    uint64_t v21 = "ByteStream_NumReadBytesAvail(request) >= 1";
    goto LABEL_41;
  }
  if (v26 != 2)
  {
    uint64_t v21 = "(request).__RWFlag == BYTESTREAM_WRITE";
LABEL_41:
    sub_10014327C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdp.c", 1341, v21);
  }
  unsigned __int16 v25 = v15 + 3;
  v22[v16] = 0;
  if (v26 == 2)
  {
    unsigned __int16 v17 = v25;
    unsigned __int16 v24 = v25;
  }
  else
  {
    unsigned __int16 v17 = v24;
  }
  LOBYTE(v26) = 15;
  uint64_t v18 = qword_100A103C8;
  *(_WORD *)(qword_100A103C8 + 18) = v17;
  *(void *)(v18 + 80) = a1;
  *(unsigned char *)(v18 + 32) = 3;
  return sub_10024CA94();
}

uint64_t sub_10024CA94()
{
  uint64_t v0 = qword_100A103C8;
  __int16 v1 = *(_WORD *)(qword_100A103C8 + 68) + 1;
  *(_WORD *)(qword_100A103C8 + 68) = v1;
  *(unsigned char *)(*(void *)(v0 + 24) + 2) = v1;
  *(unsigned char *)(*(void *)(v0 + 24) + 1) = *(unsigned char *)(v0 + 69);
  __int16 v2 = *(_WORD *)(v0 + 18) - 5;
  *(unsigned char *)(*(void *)(v0 + 24) + 4) = v2;
  *(unsigned char *)(*(void *)(v0 + 24) + 3) = HIBYTE(v2);
  uint64_t result = sub_1001DE4D0((uint64_t)sub_10024E044, *(unsigned __int16 *)(v0 + 4), 0, *(char **)(v0 + 24), *(unsigned __int16 *)(v0 + 18));
  if (!result)
  {
    uint64_t result = sub_1000268E4((uint64_t)sub_10024E060, 0, 70, (int *)(qword_100A103C8 + 8));
    *(_DWORD *)qword_100A103C8 = 2;
  }
  return result;
}

uint64_t sub_10024CB4C(uint64_t a1, unsigned int a2, unsigned __int8 *a3)
{
  if (!xmmword_100A19880) {
    return 810;
  }
  uint64_t v19 = 0;
  int v3 = *(_DWORD *)qword_100A103C8;
  if (!*(_DWORD *)qword_100A103C8 || v3 == 3) {
    return 810;
  }
  if (v3 == 2) {
    return 817;
  }
  uint64_t result = sub_10024CDB0((uint64_t)a3);
  if (!result)
  {
    int v9 = sub_100179F4C(a3);
    if (!v9) {
      return 106;
    }
    uint64_t v10 = qword_100A103C8;
    if (*(unsigned __int16 *)(qword_100A103C8 + 12) < (unsigned __int16)(v9 + 28)) {
      return 816;
    }
    uint64_t v11 = *(void *)(qword_100A103C8 + 24);
    if (v11)
    {
      if ((_WORD)v9 != 0xFFE4)
      {
        uint64_t v18 = *(void *)(qword_100A103C8 + 24);
        LOWORD(v19) = v9 + 28;
        HIWORD(v19) = 2;
        WORD1(v19) = v9 + 28;
        *(unsigned char *)uint64_t v11 = 4;
        if ((unint64_t)(unsigned __int16)(v9 + 28) - 5 >= 0xFFFFFFFFFFFFFFFCLL) {
          sub_10014327C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdp.c", 1470, "ByteStream_NumReadBytesAvail(request) >= (2 * sizeof(uint16_t))");
        }
        unsigned int v12 = (unsigned __int16)(v9 + 28);
        if (v12 <= 8) {
          sub_10014327C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdp.c", 1474, "ByteStream_NumReadBytesAvail(request) >= 4");
        }
        *(_DWORD *)(v11 + 5) = bswap32(a2);
        if (v12 <= 0xA) {
          sub_10014327C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdp.c", 1475, "ByteStream_NumReadBytesAvail(request) >= 2");
        }
        *(unsigned char *)(v11 + 10) = *(unsigned char *)(v10 + 14);
        *(unsigned char *)(v11 + 9) = *(unsigned char *)(v10 + 15);
        WORD2(v19) = 11;
        sub_10017A224((uint64_t)&v18, a3);
        uint64_t v13 = WORD2(v19);
        *(_WORD *)(qword_100A103C8 + 16) = WORD2(v19);
        if (HIBYTE(v19))
        {
          sub_10025A794((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdp.c");
        }
        else if (WORD1(v19) > v13)
        {
          if (BYTE6(v19) == 2)
          {
            WORD2(v19) = v13 + 1;
            *(unsigned char *)(v18 + v13) = 0;
            if (BYTE6(v19) == 2)
            {
              __int16 v14 = WORD2(v19);
              WORD1(v19) = WORD2(v19);
            }
            else
            {
              __int16 v14 = WORD1(v19);
            }
            BYTE6(v19) = 15;
            uint64_t v15 = qword_100A103C8;
            *(_WORD *)(qword_100A103C8 + 18) = v14;
            *(void *)(v15 + 80) = a1;
            *(unsigned char *)(v15 + 32) = 5;
            return sub_10024CA94();
          }
          unsigned __int16 v17 = "(request).__RWFlag == BYTESTREAM_WRITE";
LABEL_37:
          sub_10014327C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdp.c", 1485, v17);
        }
        unsigned __int16 v17 = "ByteStream_NumReadBytesAvail(request) >= 1";
        goto LABEL_37;
      }
      unsigned __int16 v16 = "(bufLen) > 0";
    }
    else
    {
      unsigned __int16 v16 = "SDP_State->ReqBuffer";
    }
    sub_10014327C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdp.c", 1461, v16);
  }
  return result;
}

uint64_t sub_10024CDB0(uint64_t a1)
{
  if (!*(_WORD *)(a1 + 2)) {
    return 0;
  }
  unint64_t v2 = 0;
  uint64_t v3 = *(void *)(a1 + 8);
  int v4 = -1;
  while (1)
  {
    if (*(unsigned char *)v3 != 1)
    {
      sub_10025B8C0();
      if (*(unsigned char *)v3 != 1) {
        break;
      }
    }
    unsigned int v5 = (unsigned __int16)*(_DWORD *)(v3 + 8);
    if (*(_WORD *)(v3 + 2) == 2) {
      int v6 = (unsigned __int16)*(_DWORD *)(v3 + 8);
    }
    else {
      int v6 = HIWORD(*(_DWORD *)(v3 + 8));
    }
    if (v6 < v4 || v5 < v6) {
      return 812;
    }
    ++v2;
    v3 += 16;
    int v4 = v5;
    if (v2 >= *(unsigned __int16 *)(a1 + 2)) {
      return 0;
    }
  }
  return 101;
}

uint64_t sub_10024CE58(uint64_t a1, unsigned __int8 *a2, unsigned __int8 *a3)
{
  if (!xmmword_100A19880) {
    return 810;
  }
  int v3 = *(_DWORD *)qword_100A103C8;
  if (!*(_DWORD *)qword_100A103C8 || v3 == 3) {
    return 810;
  }
  if (v3 == 2) {
    return 817;
  }
  int v9 = sub_100179F4C(a2);
  if (!v9) {
    return 106;
  }
  __int16 v10 = v9;
  uint64_t result = sub_10024CDB0((uint64_t)a3);
  if (result) {
    return result;
  }
  int v11 = sub_100179F4C(a3);
  if (!v11) {
    return 106;
  }
  if (*(unsigned __int16 *)(qword_100A103C8 + 12) < (unsigned __int16)(v10 + 24 + v11)) {
    return 816;
  }
  unsigned int v12 = *(unsigned char **)(qword_100A103C8 + 24);
  if (!v12)
  {
    unsigned __int16 v16 = "SDP_State->ReqBuffer";
    goto LABEL_32;
  }
  if (!(v10 + 24 + (_WORD)v11))
  {
    unsigned __int16 v16 = "(bufLen) > 0";
LABEL_32:
    sub_10014327C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdp.c", 1570, v16);
  }
  uint64_t v19 = *(void *)(qword_100A103C8 + 24);
  unsigned __int16 v20 = v10 + 24 + v11;
  __int16 v23 = 2;
  unsigned __int16 v21 = v20;
  *unsigned int v12 = 6;
  if ((unint64_t)(unsigned __int16)(v10 + 24 + v11) - 5 >= 0xFFFFFFFFFFFFFFFCLL) {
    sub_10014327C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdp.c", 1579, "ByteStream_NumReadBytesAvail(request) >= (2 * sizeof(uint16_t))");
  }
  unsigned __int16 v22 = 5;
  sub_10017A224((uint64_t)&v19, a2);
  if (HIBYTE(v23))
  {
    sub_10025A794((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdp.c");
    goto LABEL_35;
  }
  if (v21 - v22 <= 1)
  {
LABEL_35:
    unsigned __int16 v17 = "ByteStream_NumReadBytesAvail(request) >= 2";
    goto LABEL_37;
  }
  if (v23 != 2)
  {
    unsigned __int16 v17 = "(request).__RWFlag == BYTESTREAM_WRITE";
LABEL_37:
    sub_10014327C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdp.c", 1584, v17);
  }
  *(unsigned char *)(v19 + v22 + 1) = *(unsigned char *)(qword_100A103C8 + 14);
  *(unsigned char *)(v19 + v22) = *(unsigned char *)(qword_100A103C8 + 15);
  v22 += 2;
  sub_10017A224((uint64_t)&v19, a3);
  uint64_t v13 = v22;
  *(_WORD *)(qword_100A103C8 + 16) = v22;
  if (HIBYTE(v23))
  {
    sub_10025A794((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdp.c");
    goto LABEL_39;
  }
  if (v21 <= v13)
  {
LABEL_39:
    uint64_t v18 = "ByteStream_NumReadBytesAvail(request) >= 1";
    goto LABEL_41;
  }
  if (v23 != 2)
  {
    uint64_t v18 = "(request).__RWFlag == BYTESTREAM_WRITE";
LABEL_41:
    sub_10014327C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdp.c", 1594, v18);
  }
  unsigned __int16 v22 = v13 + 1;
  *(unsigned char *)(v19 + v13) = 0;
  if (v23 == 2)
  {
    unsigned __int16 v14 = v22;
    unsigned __int16 v21 = v22;
  }
  else
  {
    unsigned __int16 v14 = v21;
  }
  LOBYTE(v23) = 15;
  uint64_t v15 = qword_100A103C8;
  *(_WORD *)(qword_100A103C8 + 18) = v14;
  *(void *)(v15 + 80) = a1;
  *(unsigned char *)(v15 + 32) = 7;
  return sub_10024CA94();
}

uint64_t sub_10024D124()
{
  if (!xmmword_100A19880) {
    return 810;
  }
  int v0 = *(_DWORD *)qword_100A103C8;
  uint64_t result = 810;
  if (*(_DWORD *)qword_100A103C8)
  {
    if (v0 == 2)
    {
      if ((*(unsigned __int8 *)(qword_100A103C8 + 32) | 2) == 7) {
        return sub_10024CA94();
      }
    }
    else if (v0 == 3)
    {
      return result;
    }
    return 815;
  }
  return result;
}

uint64_t sub_10024D180()
{
  if (!xmmword_100A19880) {
    return 810;
  }
  uint64_t v0 = qword_100A103C8;
  int v1 = *(_DWORD *)qword_100A103C8;
  uint64_t result = 810;
  if (*(_DWORD *)qword_100A103C8)
  {
    if (v1 == 2)
    {
      *(_WORD *)(qword_100A103C8 + 66) = 0;
      int v3 = *(void **)(v0 + 56);
      if (v3)
      {
        sub_100023010(v3);
        uint64_t v0 = qword_100A103C8;
        *(void *)(qword_100A103C8 + 56) = 0;
      }
      uint64_t result = 0;
      *(_DWORD *)uint64_t v0 = 1;
    }
    else if (v1 != 3)
    {
      return 815;
    }
  }
  return result;
}

uint64_t sub_10024D204(void *a1)
{
  if (off_100A103D0)
  {
    if (off_100A103D0 == a1) {
      return 0;
    }
    else {
      return 119;
    }
  }
  else
  {
    uint64_t result = 0;
    off_100A103D0 = a1;
  }
  return result;
}

void *sub_10024D230(void *result)
{
  if (off_100A103D0 == result) {
    off_100A103D0 = 0;
  }
  return result;
}

uint64_t sub_10024D24C(uint64_t *a1)
{
  if (*((unsigned char *)a1 + 14) != 1) {
    sub_10014327C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdp.c", 1023, "(*Response).__RWFlag == BYTESTREAM_READ");
  }
  if (*((unsigned char *)a1 + 15))
  {
    sub_10025A794((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdp.c");
    int v2 = *((unsigned __int8 *)a1 + 14);
    *((unsigned char *)a1 + 15) = 1;
    if (v2 != 1) {
      sub_10014327C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdp.c", 1024, "(*Response).__RWFlag == BYTESTREAM_READ");
    }
    goto LABEL_10;
  }
  uint64_t v3 = *((unsigned __int16 *)a1 + 6);
  if (*((unsigned __int16 *)a1 + 5) - (int)v3 <= 1)
  {
    *((unsigned char *)a1 + 15) = 1;
LABEL_10:
    sub_10025A794((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdp.c");
    goto LABEL_11;
  }
  unsigned int v4 = *(unsigned __int16 *)(*a1 + v3);
  *((_WORD *)a1 + 6) = v3 + 2;
  int v5 = *((unsigned __int16 *)a1 + 5);
  if (v5 - (unsigned __int16)(v3 + 2) <= 1)
  {
LABEL_11:
    *((unsigned char *)a1 + 15) = 1;
    return 829;
  }
  unsigned int v6 = __rev16(v4);
  uint64_t v7 = *a1;
  unsigned int v8 = __rev16(*(unsigned __int16 *)(*a1 + (unsigned __int16)(v3 + 2)));
  unsigned __int16 v9 = v3 + 4;
  *((_WORD *)a1 + 6) = v3 + 4;
  if (v8 > v6) {
    return 833;
  }
  uint64_t v11 = qword_100A103C8;
  if (!v8)
  {
    unsigned __int16 v18 = *(_WORD *)(qword_100A103C8 + 50);
    int v12 = *(unsigned __int16 *)(qword_100A103C8 + 48);
LABEL_20:
    if (v12 == v18 || v6 == v18)
    {
      *(_DWORD *)uint64_t v11 = 1;
    }
    else
    {
      uint64_t result = sub_10024DCB4(a1);
      if (result) {
        return result;
      }
      uint64_t v11 = qword_100A103C8;
      if (*(_DWORD *)qword_100A103C8 == 2)
      {
        return sub_10024CA94();
      }
    }
    (*(void (**)(void, void, void))(v11 + 80))(*(void *)(v11 + 40), *(unsigned __int16 *)(v11 + 50), 0);
    sub_100023010(*(void **)(qword_100A103C8 + 40));
    uint64_t result = 0;
    *(void *)(qword_100A103C8 + 40) = 0;
    return result;
  }
  int v12 = *(unsigned __int16 *)(qword_100A103C8 + 48);
  unsigned __int16 v13 = *(_WORD *)(qword_100A103C8 + 50);
  int v14 = v5 - 3;
  while (v12 != v13)
  {
    if (v14 <= v9) {
      goto LABEL_11;
    }
    uint64_t v15 = v9;
    v9 += 4;
    LODWORD(v15) = *(_DWORD *)(v7 + v15);
    *((_WORD *)a1 + 6) = v9;
    unsigned int v16 = bswap32(v15);
    uint64_t v17 = *(void *)(v11 + 40);
    unsigned __int16 v18 = v13 + 1;
    *(_WORD *)(v11 + 50) = v13 + 1;
    *(_DWORD *)(v17 + 4 * v13++) = v16;
    if (!--v8) {
      goto LABEL_20;
    }
  }
  return 837;
}

uint64_t sub_10024D458(uint64_t a1)
{
  uint64_t v56 = 0;
  unsigned __int16 v54 = 0;
  uint64_t v55 = 6;
  if (*(unsigned char *)(a1 + 14) != 1) {
    sub_10014327C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdp.c", 753, "(*Response).__RWFlag == BYTESTREAM_READ");
  }
  __int16 v53 = 0;
  if (*(unsigned char *)(a1 + 15))
  {
    sub_10025A794((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdp.c");
LABEL_7:
    unsigned int v6 = 0;
    *(unsigned char *)(a1 + 15) = 1;
    goto LABEL_8;
  }
  unsigned int v2 = *(unsigned __int16 *)(a1 + 10);
  uint64_t v3 = *(unsigned __int16 *)(a1 + 12);
  if ((int)(v2 - v3) <= 1) {
    goto LABEL_7;
  }
  unsigned int v4 = *(unsigned __int16 *)(*(void *)a1 + v3);
  unsigned __int16 v5 = v3 + 2;
  *(_WORD *)(a1 + 12) = v3 + 2;
  if ((int)(v2 - (unsigned __int16)(v3 + 2)) >= (int)(bswap32(v4) >> 16))
  {
    size_t v11 = __rev16(v4);
    if (v11 > *(unsigned __int16 *)(qword_100A103C8 + 14))
    {
      unsigned int v6 = 0;
      uint64_t v7 = 836;
      goto LABEL_9;
    }
    unsigned int v12 = (unsigned __int16)(v3 + 2) + v11;
    if (v12 > v2) {
      sub_10014327C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdp.c", 772, "(size_t)(startPos + attrBytes) <= (size_t)((*Response).__size)");
    }
    *(_WORD *)(a1 + 12) = v12;
    uint64_t v13 = sub_10024DCB4((uint64_t *)a1);
    if (v13)
    {
      uint64_t v7 = v13;
LABEL_19:
      unsigned int v6 = 0;
      goto LABEL_9;
    }
    if (*(unsigned __int16 *)(a1 + 10) < v5) {
      sub_10014327C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdp.c", 777, "(size_t)(startPos) <= (size_t)((*Response).__size)");
    }
    *(_WORD *)(a1 + 12) = v5;
    if (v12 > *(unsigned __int16 *)(a1 + 8)) {
      sub_10014327C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdp.c", 781, "((startPos + attrBytes) <= (*Response).__trueSize) && ((startPos + attrBytes) >= (*Response).__pos)");
    }
    *(_WORD *)(a1 + 10) = v12;
    uint64_t v14 = qword_100A103C8;
    if (*(void *)(qword_100A103C8 + 56))
    {
      size_t v15 = *(unsigned __int16 *)(qword_100A103C8 + 64) + v11;
      if (v15 >= 0x2801)
      {
        if (sub_100058654())
        {
          sub_100056E24((uint64_t)"Accumulated attribute reponse data length exceed the limits", v16, v17, v18, v19, v20, v21, v22, v50);
          __int16 v23 = sub_100050B4C(0x34u);
          if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR)) {
            sub_100749944();
          }
        }
        unsigned int v6 = 0;
        goto LABEL_79;
      }
      unsigned __int16 v24 = (char *)sub_100022FE8(v15);
      unsigned int v6 = v24;
      if (!v24) {
        goto LABEL_79;
      }
      memmove(v24, *(const void **)(qword_100A103C8 + 56), *(unsigned __int16 *)(qword_100A103C8 + 64));
      if (*(unsigned char *)(a1 + 14) == 1)
      {
        uint64_t v25 = *(unsigned __int16 *)(qword_100A103C8 + 64);
        uint64_t v26 = *(void *)a1;
        uint64_t v27 = *(unsigned __int16 *)(a1 + 12);
        if (*(unsigned char *)(a1 + 15))
        {
          sub_10025A794((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdp.c");
          int v28 = 0;
        }
        else
        {
          int v28 = *(unsigned __int16 *)(a1 + 10) - v27;
        }
        if (v28 >= (int)v11)
        {
          memmove(&v6[v25], (const void *)(v26 + v27), v11);
          *(_WORD *)(a1 + 12) += v11;
          sub_100023010(*(void **)(qword_100A103C8 + 56));
          uint64_t v14 = qword_100A103C8;
          *(void *)(qword_100A103C8 + 56) = 0;
          if (!v15) {
            sub_10014327C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdp.c", 807, "(catenatedLen) > 0");
          }
          unsigned __int16 v5 = 0;
          *(void *)a1 = v6;
          *(_WORD *)(a1 + 8) = v15;
          *(_DWORD *)(a1 + 12) = 0x10000;
          *(_WORD *)(a1 + 10) = v15;
          goto LABEL_37;
        }
        uint64_t v48 = "ByteStream_NumReadBytesAvail(*Response) >= (attrBytes)";
      }
      else
      {
        uint64_t v48 = "(*Response).__RWFlag == BYTESTREAM_READ";
      }
      sub_10014327C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdp.c", 801, v48);
    }
    unsigned int v6 = 0;
LABEL_37:
    unsigned int v29 = *(unsigned __int16 *)(v14 + 66);
    if (!*(_WORD *)(v14 + 66))
    {
      uint64_t v30 = sub_10017A5EC(a1, &v53, (_WORD *)(v14 + 66));
      if (v30)
      {
        uint64_t v7 = v30;
        if (v30 != 843) {
          goto LABEL_9;
        }
        if (*(unsigned __int16 *)(a1 + 10) < v5) {
          sub_10014327C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdp.c", 822, "(size_t)(startPos) <= (size_t)((*Response).__size)");
        }
        *(_WORD *)(a1 + 12) = v5;
        uint64_t v7 = 843;
        unsigned __int16 v31 = v11;
LABEL_82:
        if (*(_DWORD *)qword_100A103C8 == 2)
        {
          if (v31)
          {
            uint64_t v42 = sub_100022FE8(v31);
            *(void *)(qword_100A103C8 + 56) = v42;
            if (!v42)
            {
              uint64_t v7 = 106;
              goto LABEL_9;
            }
            if (*(unsigned char *)(a1 + 14) == 1)
            {
              uint64_t v43 = v42;
              uint64_t v44 = *(void *)a1;
              uint64_t v45 = *(unsigned __int16 *)(a1 + 12);
              if (*(unsigned char *)(a1 + 15))
              {
                sub_10025A794((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdp.c");
                int v46 = 0;
              }
              else
              {
                int v46 = *(unsigned __int16 *)(a1 + 10) - v45;
              }
              if (v46 >= v31)
              {
                memmove(v43, (const void *)(v44 + v45), v31);
                *(_WORD *)(a1 + 12) += v31;
                *(_WORD *)(qword_100A103C8 + 64) = v31;
                goto LABEL_94;
              }
              uint64_t v49 = "ByteStream_NumReadBytesAvail(*Response) >= (attrBytes)";
            }
            else
            {
              uint64_t v49 = "(*Response).__RWFlag == BYTESTREAM_READ";
            }
            sub_10014327C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdp.c", 951, v49);
          }
        }
        else if (v31)
        {
          goto LABEL_39;
        }
LABEL_94:
        if (v6) {
          sub_100023010(v6);
        }
        if (*(_DWORD *)qword_100A103C8 != 2 || v54 != 0)
        {
          (*(void (**)(uint64_t *, BOOL, uint64_t))(qword_100A103C8 + 80))(&v55, *(_DWORD *)qword_100A103C8 == 2, v7);
          sub_10017B680((unsigned __int8 *)&v55);
          return 0;
        }
        uint64_t v7 = sub_10024CA94();
        if (!v7) {
          return v7;
        }
        goto LABEL_19;
      }
      LOWORD(v11) = v11 - v53;
      v5 += v53;
      uint64_t v14 = qword_100A103C8;
      unsigned int v29 = *(unsigned __int16 *)(qword_100A103C8 + 66);
    }
    if (v29 < (unsigned __int16)v11)
    {
LABEL_39:
      uint64_t v7 = 833;
      goto LABEL_9;
    }
    *(_WORD *)(v14 + 66) = v29 - v11;
    if (*(unsigned char *)(v14 + 32) == 7)
    {
      while (1)
      {
        unsigned __int16 v52 = 0;
        uint64_t v32 = sub_10017A5EC(a1, &v53, &v52);
        if (v32) {
          break;
        }
        if (*(unsigned char *)(a1 + 15))
        {
          sub_10025A794((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdp.c");
          int v33 = 0;
        }
        else
        {
          int v33 = *(unsigned __int16 *)(a1 + 10) - *(unsigned __int16 *)(a1 + 12);
        }
        if (v33 < v52)
        {
          uint64_t v7 = 0;
          goto LABEL_62;
        }
        uint64_t v32 = sub_10024DE68(a1, v52, 0);
        if (v32) {
          break;
        }
        ++v54;
      }
      uint64_t v7 = v32;
      if (v32 != 843) {
        goto LABEL_9;
      }
    }
    else
    {
      if (*(unsigned char *)(a1 + 15))
      {
        sub_10025A794((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdp.c");
        unsigned __int16 v34 = 0;
      }
      else
      {
        unsigned __int16 v34 = *(_WORD *)(a1 + 10) - *(_WORD *)(a1 + 12);
      }
      uint64_t v35 = sub_10024DE68(a1, v34, &v54);
      uint64_t v7 = v35;
      if (v35 != 843 && v35) {
        goto LABEL_9;
      }
    }
LABEL_62:
    if (v7 == 843)
    {
      uint64_t v7 = 0;
      *(unsigned char *)(a1 + 15) = 0;
    }
    if (*(unsigned __int16 *)(a1 + 10) < v5) {
      sub_10014327C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdp.c", 891, "(size_t)(startPos) <= (size_t)((*Response).__size)");
    }
    *(_WORD *)(a1 + 12) = v5;
    if (!v54)
    {
LABEL_77:
      if (*(unsigned char *)(a1 + 15))
      {
        sub_10025A794((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdp.c");
        goto LABEL_94;
      }
      goto LABEL_81;
    }
    LOBYTE(v55) = 6;
    WORD1(v55) = 0;
    uint64_t v36 = sub_100022FE8(16 * v54 + 16);
    uint64_t v56 = v36;
    if (v36)
    {
      uint64_t v37 = v54;
      v36[16 * v54] = 33;
      *(void *)&v56[16 * v37 + 8] = &v55;
      if (!v37) {
        goto LABEL_77;
      }
      uint64_t v38 = 0;
      unint64_t v39 = 0;
      while (1)
      {
        char v51 = 0;
        unsigned __int16 v52 = 0;
        if (sub_10017A288(a1, &v51, (__int16 *)&v52) == 843) {
          break;
        }
        unsigned int v40 = v52;
        if (*(unsigned char *)(a1 + 15))
        {
          sub_10025A794((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdp.c");
          unsigned __int16 v41 = 0;
        }
        else
        {
          unsigned __int16 v41 = *(_WORD *)(a1 + 10) - *(_WORD *)(a1 + 12);
        }
        if (v40 > v41) {
          break;
        }
        if (sub_10017B5D4(a1, &v56[v38])) {
          goto LABEL_39;
        }
        ++WORD1(v55);
        ++v39;
        v38 += 16;
        if (v39 >= v54)
        {
          uint64_t v7 = 0;
          goto LABEL_77;
        }
      }
      uint64_t v7 = 0;
      *(unsigned char *)(a1 + 15) = 0;
LABEL_81:
      unsigned __int16 v31 = *(_WORD *)(a1 + 10) - *(_WORD *)(a1 + 12);
      goto LABEL_82;
    }
LABEL_79:
    uint64_t v7 = 104;
    goto LABEL_9;
  }
  unsigned int v6 = 0;
LABEL_8:
  uint64_t v7 = 829;
LABEL_9:
  uint64_t v8 = qword_100A103C8;
  *(_WORD *)(qword_100A103C8 + 66) = 0;
  unsigned __int16 v9 = *(void **)(v8 + 56);
  if (v9)
  {
    sub_100023010(v9);
    *(void *)(qword_100A103C8 + 56) = 0;
  }
  sub_10017B680((unsigned __int8 *)&v55);
  if (v6) {
    sub_100023010(v6);
  }
  return v7;
}

void sub_10024DBE0(uint64_t a1)
{
  if (sub_100058654())
  {
    sub_100056E24((uint64_t)"SDP CleanupAndReportError %!", v2, v3, v4, v5, v6, v7, v8, a1);
    unsigned __int16 v9 = sub_100050B4C(0x34u);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR)) {
      sub_10074932C();
    }
  }
  int v10 = *(unsigned __int8 *)(qword_100A103C8 + 32);
  if (v10 == 7 || v10 == 5 || v10 == 3) {
    (*(void (**)(void, void, uint64_t))(qword_100A103C8 + 80))(0, 0, a1);
  }
  else {
    sub_10025B8C0();
  }
  uint64_t v11 = qword_100A103C8;
  *(_DWORD *)qword_100A103C8 = 1;
  *(_WORD *)(v11 + 66) = 0;
  unsigned int v12 = *(void **)(v11 + 56);
  if (v12)
  {
    sub_100023010(v12);
    *(void *)(qword_100A103C8 + 56) = 0;
  }
}

uint64_t sub_10024DCB4(uint64_t *a1)
{
  if (*((unsigned char *)a1 + 14) != 1) {
    sub_10014327C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdp.c", 643, "(*Response).__RWFlag == BYTESTREAM_READ");
  }
  if (*((unsigned char *)a1 + 15))
  {
    sub_10025A794((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdp.c");
LABEL_8:
    int v6 = 1;
    *((unsigned char *)a1 + 15) = 1;
LABEL_9:
    *(_DWORD *)qword_100A103C8 = 1;
    goto LABEL_10;
  }
  uint64_t v2 = *((unsigned __int16 *)a1 + 6);
  if (*((unsigned __int16 *)a1 + 5) <= v2) {
    goto LABEL_8;
  }
  uint64_t v3 = *a1;
  *((_WORD *)a1 + 6) = v2 + 1;
  uint64_t v4 = *(unsigned __int8 *)(v3 + v2);
  if (!*(unsigned char *)(v3 + v2))
  {
    int v6 = 0;
    goto LABEL_9;
  }
  if (v4 > 0x10) {
    return 833;
  }
  uint64_t v7 = qword_100A103C8;
  *(unsigned char *)(*(void *)(qword_100A103C8 + 24) + *(unsigned __int16 *)(qword_100A103C8 + 16)) = v4;
  if (*((unsigned char *)a1 + 14) != 1) {
    sub_10014327C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdp.c", 657, "(*Response).__RWFlag == BYTESTREAM_READ");
  }
  uint64_t v8 = *(void *)(v7 + 24);
  uint64_t v9 = *(unsigned __int16 *)(v7 + 16);
  uint64_t v10 = *a1;
  uint64_t v11 = *((unsigned __int16 *)a1 + 6);
  if (*((unsigned char *)a1 + 15))
  {
    sub_10025A794((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdp.c");
    int v12 = 0;
  }
  else
  {
    int v12 = *((unsigned __int16 *)a1 + 5) - v11;
  }
  if (v12 >= (int)v4)
  {
    uint64_t v13 = (unsigned char *)(v9 + v8 + 1);
    uint64_t v14 = (char *)(v10 + v11);
    size_t v15 = &v13[v4];
    do
    {
      char v16 = *v14++;
      *v13++ = v16;
    }
    while (v13 < v15);
    *((_WORD *)a1 + 6) += v4;
    int v6 = *((unsigned __int8 *)a1 + 15);
  }
  else
  {
    int v6 = 1;
    *((unsigned char *)a1 + 15) = 1;
  }
  *(_WORD *)(qword_100A103C8 + 18) = v4 + *(_WORD *)(qword_100A103C8 + 16) + 1;
LABEL_10:
  if (v6) {
    return 829;
  }
  else {
    return 0;
  }
}

uint64_t sub_10024DE68(uint64_t a1, int a2, _WORD *a3)
{
  if (!a2) {
    return 0;
  }
  int v4 = a2;
  while (1)
  {
    char v24 = 0;
    unsigned __int16 v23 = 0;
    uint64_t result = sub_10017A288(a1, &v24, (__int16 *)&v23);
    if (result) {
      break;
    }
    if (v23 > (unsigned __int16)v4) {
      return 843;
    }
    if (v23 != 3 || v24 != 1)
    {
      if (sub_100058654())
      {
        sub_100056E24((uint64_t)"Bad attribute response - expected attribute id", v14, v15, v16, v17, v18, v19, v20, v22);
        uint64_t v21 = sub_100050B4C(0x34u);
        if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR)) {
          sub_10074AAD0();
        }
      }
      return 833;
    }
    if (*(unsigned char *)(a1 + 15))
    {
      sub_10025A794((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdp.c");
      int v8 = 0;
      int v9 = v23;
    }
    else
    {
      int v8 = *(unsigned __int16 *)(a1 + 10) - *(unsigned __int16 *)(a1 + 12);
      int v9 = 3;
    }
    if (v8 < v9) {
      sub_10014327C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdp.c", 702, "ByteStream_NumReadBytesAvail(*Response) >= (elemSize)");
    }
    *(_WORD *)(a1 + 12) += v9;
    uint64_t result = sub_10017A288(a1, &v24, (__int16 *)&v23);
    if (result) {
      return result;
    }
    int v10 = v4 - 3;
    int v11 = v23;
    if (v23 > (unsigned __int16)v10) {
      return 843;
    }
    if (*(unsigned char *)(a1 + 15))
    {
      sub_10025A794((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdp.c");
      int v12 = 0;
      int v11 = v23;
    }
    else
    {
      int v12 = *(unsigned __int16 *)(a1 + 10) - *(unsigned __int16 *)(a1 + 12);
    }
    if (v12 < v11) {
      sub_10014327C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdp.c", 712, "ByteStream_NumReadBytesAvail(*Response) >= (elemSize)");
    }
    *(_WORD *)(a1 + 12) += v11;
    if (a3) {
      *a3 += 2;
    }
    int v4 = v10 - v11;
    if (!(_WORD)v4) {
      return 0;
    }
  }
  return result;
}

void sub_10024E044(uint64_t a1, uint64_t a2)
{
  if (*(void *)(qword_100A103C8 + 24) != a2) {
    sub_10025B8C0();
  }
}

void sub_10024E060()
{
  if (xmmword_100A19880)
  {
    uint64_t v0 = qword_100A103C8;
    if (*(_DWORD *)qword_100A103C8 == 2)
    {
      sub_10024DBE0(832);
      uint64_t v0 = qword_100A103C8;
    }
    *(_DWORD *)(v0 + 8) = 0;
  }
}

uint64_t sub_10024E0B0()
{
  if (DWORD1(xmmword_100A19880)) {
    return 140;
  }
  qword_100A103D8 = (uint64_t)sub_10010CE48(0x80uLL);
  if (!qword_100A103D8) {
    return 106;
  }
  int v1 = (unsigned __int8 *)sub_10025B218(0x28u);
  qword_100A103F8 = (uint64_t)sub_10010CE48(32 * *v1);
  word_100A103F0 = 0;
  byte_100A10400 = 0;
  uint64_t v2 = sub_10010CE48(0x50uLL);
  if (!v2) {
    return 106;
  }
  uint64_t v3 = v2;
  byte_100A103E0 = 1;
  word_100A103E2 = 4;
  dword_100A103E8 = 0;
  byte_100A10408 = 4;
  int v4 = sub_100263A30();
  word_100A1040A = strlen(v4);
  qword_100A10410 = (uint64_t)sub_100263A30();
  byte_100A10418 = 4;
  uint64_t v5 = sub_100263A3C();
  word_100A1041A = strlen(v5);
  qword_100A10420 = (uint64_t)sub_100263A3C();
  v3[12] = 6;
  *((void *)v3 + 2) = &unk_10099F458;
  *((unsigned char *)v3 + 66) = -1;
  *((void *)v3 + 7) = 0;
  v3[32] = 0;
  *((_DWORD *)v3 + 13) = 0;
  *((void *)v3 + 9) = &unk_1007BAC00;
  int v6 = (_WORD *)qword_100A103D8;
  *(void *)(qword_100A103D8 + 120) = v3;
  *int v6 = 0;
  v6[12] = 2;
  char v6[24] = 8;
  v6[36] = 6;
  v6[48] = 5;
  uint64_t v7 = (char *)sub_10010CE48(0x50uLL);
  if (!v7) {
    return 106;
  }
  int v8 = v7;
  uint64_t result = 0;
  *((_DWORD *)v8 + 12) = 1330184192;
  *((void *)v8 + 2) = &unk_10099F508;
  *((_WORD *)v8 + 12) = 1;
  *((void *)v8 + 4) = 0;
  *((_WORD *)v8 + 20) = 0;
  *(void *)(v8 + 52) = 0;
  *(void *)(v8 + 59) = 0;
  *((void *)v8 + 9) = &unk_1007BAC00;
  uint64_t v9 = qword_100A103D8;
  *(void *)int v8 = *(void *)(qword_100A103D8 + 120);
  *(void *)(v9 + 120) = v8;
  byte_100A10404 = 1;
  DWORD2(xmmword_100A19880) = 1;
  return result;
}

uint64_t sub_10024E258(uint64_t a1, int *a2)
{
  int v4 = sub_10010CE48(0x50uLL);
  if (!v4) {
    return 104;
  }
  uint64_t v5 = v4;
  void v4[2] = *(void *)a1;
  *((_WORD *)v4 + 12) = *(_WORD *)(a1 + 8);
  v4[4] = *(void *)(a1 + 16);
  *((_WORD *)v4 + 20) = *(_WORD *)(a1 + 24);
  v4[7] = 0;
  *((_WORD *)v4 + 32) = 0;
  *((unsigned char *)v4 + 66) = -1;
  *((_DWORD *)v4 + 13) = 0;
  v4[9] = &unk_10099F448;
  uint64_t v6 = *(unsigned __int16 *)(a1 + 8);
  if (!*(_WORD *)(a1 + 8)) {
    goto LABEL_14;
  }
  uint64_t v7 = *(void *)a1 + 16;
  while (*(_WORD *)(v7 - 16) != 1)
  {
    v7 += 24;
    if (!--v6) {
      goto LABEL_14;
    }
  }
  if (*(unsigned char *)(v7 - 8) == 6)
  {
    int v9 = *(unsigned __int16 *)(*(void *)v7 + 8) | 0x4F490000;
    int v10 = (void *)(qword_100A103D8 + 120);
LABEL_10:
    *((_DWORD *)v4 + 12) = v9;
    int v11 = v10;
    while (1)
    {
      int v11 = (void *)*v11;
      if (!v11) {
        break;
      }
      if (*((_DWORD *)v11 + 12) == v9)
      {
        v9 += 0x10000;
        goto LABEL_10;
      }
    }
    if (a2) {
      *a2 = v9;
    }
    uint64_t result = 0;
    *uint64_t v5 = *v10;
    *int v10 = v5;
    byte_100A103E0 = 1;
    word_100A103E2 = 4;
    ++dword_100A103E8;
  }
  else
  {
LABEL_14:
    if (sub_100058654())
    {
      sub_100056E24((uint64_t)"ServiceClassIDList is mandatory in an SDP service record", v12, v13, v14, v15, v16, v17, v18, v20);
      uint64_t v19 = sub_100050B4C(0x36u);
      if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR)) {
        sub_100744F6C();
      }
    }
    sub_100023010(v5);
    return 826;
  }
  return result;
}

uint64_t sub_10024E3E0(int a1, char a2)
{
  uint64_t v2 = qword_100A103D8 + 120;
  while (1)
  {
    uint64_t v2 = *(void *)v2;
    if (!v2) {
      break;
    }
    if (*(_DWORD *)(v2 + 48) == a1)
    {
      if (a1)
      {
        uint64_t result = 0;
        *(unsigned char *)(v2 + 66) = a2;
        ++*(_DWORD *)(v2 + 52);
        byte_100A103E0 = 1;
        word_100A103E2 = 4;
        ++dword_100A103E8;
        return result;
      }
      return 802;
    }
  }
  return 802;
}

uint64_t sub_10024E448(int a1)
{
  if (!a1) {
    return 101;
  }
  int v1 = 0;
  uint64_t v2 = (void **)(qword_100A103D8 + 120);
  do
  {
    uint64_t v3 = v1;
    int v1 = *v2;
    if (!*v2) {
      return 802;
    }
    uint64_t v2 = (void **)*v2;
  }
  while (v1[12] != a1);
  if (*((_WORD *)v1 + 32))
  {
    if (sub_100058654())
    {
      sub_100056E24((uint64_t)"Potential memory leak - Attribute list has not been removed", v4, v5, v6, v7, v8, v9, v10, v16);
      int v11 = sub_100050B4C(0x36u);
      if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR)) {
        sub_100744F6C();
      }
    }
  }
  uint64_t v12 = (void *)*((void *)v1 + 1);
  if (v12)
  {
    do
    {
      uint64_t v13 = (void *)*v12;
      sub_100023010(v12);
      uint64_t v12 = v13;
    }
    while (v13);
  }
  uint64_t v14 = (void *)(qword_100A103D8 + 120);
  if (v3) {
    uint64_t v14 = v3;
  }
  *uint64_t v14 = *(void *)v1;
  sub_100023010(v1);
  uint64_t result = 0;
  byte_100A103E0 = 1;
  word_100A103E2 = 4;
  ++dword_100A103E8;
  return result;
}

uint64_t sub_10024E558()
{
  return dword_100A103E8;
}

uint64_t sub_10024E564(uint64_t a1, uint64_t a2)
{
  if (sub_100058654())
  {
    sub_100056E24((uint64_t)"Adding SDP Legacy record for service record handle %d", v4, v5, v6, v7, v8, v9, v10, a1);
    int v11 = sub_100050B4C(0x36u);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 136446210;
      uint64_t v16 = sub_100050714();
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
    }
  }
  uint64_t v12 = qword_100A103D8 + 120;
  while (1)
  {
    uint64_t v12 = *(void *)v12;
    if (!v12) {
      break;
    }
    if (*(_DWORD *)(v12 + 48) == a1) {
      goto LABEL_9;
    }
  }
  sub_10025B8C0();
LABEL_9:
  uint64_t v13 = sub_10010CE48(0x50uLL);
  uint64_t v13[2] = *(void *)a2;
  *((_WORD *)v13 + 12) = *(_WORD *)(a2 + 8);
  v13[4] = *(void *)(a2 + 16);
  *((_WORD *)v13 + 20) = *(_WORD *)(a2 + 24);
  v13[7] = 0;
  *((_WORD *)v13 + 32) = 0;
  *((unsigned char *)v13 + 66) = -1;
  v13[9] = &unk_10099F448;
  *((_DWORD *)v13 + 12) = a1;
  *((_DWORD *)v13 + 13) = 0;
  *uint64_t v13 = *(void *)(v12 + 8);
  *(void *)(v12 + 8) = v13;
  return 0;
}

uint64_t sub_10024E6B4(uint64_t a1, unsigned int a2, _WORD *a3, _DWORD *a4, uint64_t a5)
{
  uint64_t v5 = *(uint64_t **)(qword_100A103D8 + 120);
  if (v5)
  {
    int v8 = 0;
    uint64_t v9 = a2;
    do
    {
      int v45 = v8 + 1;
      if ((unsigned __int16)*a3 <= (unsigned __int16)v8)
      {
        uint64_t v10 = qword_100A103D8;
        *(unsigned char *)(qword_100A103D8 + 8) = 1;
        *(_WORD *)(v10 + 10) = 4;
        *(_DWORD *)(v10 + 16) = *((_DWORD *)v5 + 12);
        *(unsigned char *)(v10 + 32) = 1;
        *(_WORD *)(v10 + 34) = 4;
        *(_DWORD *)(v10 + 40) = *((_DWORD *)v5 + 13);
        *(unsigned char *)(v10 + 56) = 1;
        *(_WORD *)(v10 + 58) = 1;
        *(_DWORD *)(v10 + 64) = *((unsigned __int8 *)v5 + 66);
        *(_OWORD *)(v10 + 80) = unk_1009F9418;
        *(_OWORD *)(v10 + 104) = *(_OWORD *)v5[9];
        if (a2)
        {
          uint64_t v11 = 0;
          if (*(_WORD *)(v10 + 106)) {
            unint64_t v12 = 5;
          }
          else {
            unint64_t v12 = 4;
          }
          while (1)
          {
            if (*((_WORD *)v5 + 12))
            {
              unint64_t v13 = 1;
              uint64_t v14 = 8;
              do
              {
                int v15 = sub_10024E9F4((unsigned __int8 *)(v5[2] + v14), a1 + 16 * v11);
                if (v13 >= *((unsigned __int16 *)v5 + 12)) {
                  break;
                }
                v14 += 24;
                ++v13;
              }
              while ((v15 & 1) == 0);
            }
            else
            {
              int v15 = 0;
            }
            if (*((_WORD *)v5 + 32)) {
              BOOL v16 = v15 == 0;
            }
            else {
              BOOL v16 = 0;
            }
            if (v16)
            {
              unint64_t v17 = 1;
              uint64_t v18 = 8;
              do
              {
                int v15 = sub_10024E9F4((unsigned __int8 *)(v5[7] + v18), a1 + 16 * v11);
                if (v17 >= *((unsigned __int16 *)v5 + 32)) {
                  break;
                }
                v18 += 24;
                ++v17;
              }
              while ((v15 & 1) == 0);
            }
            if (!v15)
            {
              unint64_t v19 = 1;
              uint64_t v20 = 8;
              do
              {
                int v21 = sub_10024E9F4((unsigned __int8 *)(qword_100A103D8 + v20), a1 + 16 * v11);
                if (v19 >= v12) {
                  break;
                }
                v20 += 24;
                ++v19;
              }
              while (!v21);
              if ((v21 & 1) == 0) {
                break;
              }
            }
            if (++v11 == v9)
            {
              uint64_t v23 = (unsigned __int16)word_100A103F0;
              if (!word_100A103F0) {
                goto LABEL_49;
              }
              uint64_t v24 = qword_100A103F8;
              while (*(void *)v24 != a5)
              {
                v24 += 32;
                if (!--v23) {
                  goto LABEL_49;
                }
              }
              if (!*(unsigned char *)(v24 + 28)) {
                goto LABEL_49;
              }
              uint64_t v25 = *((unsigned __int16 *)v5 + 12);
              if (!*((_WORD *)v5 + 12)) {
                goto LABEL_49;
              }
              uint64_t v26 = 0;
              LODWORD(v27) = 0;
              int v28 = (void *)(v5[2] + 16);
              do
              {
                if (*((_WORD *)v28 - 8) == 1)
                {
                  LODWORD(v27) = *((unsigned __int16 *)v28 - 3);
                  uint64_t v26 = *v28;
                }
                v28 += 3;
                --v25;
              }
              while (v25);
              if (!v27)
              {
LABEL_49:
                uint64_t result = 0;
                *a4 = *((_DWORD *)v5 + 12);
                *a3 = v45;
                return result;
              }
              unsigned int v29 = (unsigned int *)(v26 + 8);
              uint64_t v27 = v27;
              while (1)
              {
                unsigned int v31 = *v29;
                v29 += 4;
                unint64_t v30 = v31;
                if (v31 == 4611 || v30 == 4383) {
                  break;
                }
                if (!--v27) {
                  goto LABEL_49;
                }
              }
              if (sub_100058654())
              {
                int v33 = sub_100258E24(v30);
                sub_100056E24((uint64_t)"Wireless Splitter incoming connection ignore %s profile", v34, v35, v36, v37, v38, v39, v40, (uint64_t)v33);
                unsigned __int16 v41 = sub_100050B4C(0x36u);
                if (os_log_type_enabled(v41, OS_LOG_TYPE_DEFAULT))
                {
                  *(_DWORD *)long long buf = 136446210;
                  uint64_t v47 = sub_100050714();
                  _os_log_impl((void *)&_mh_execute_header, v41, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
                }
              }
              return 823;
            }
          }
        }
      }
      uint64_t v5 = (uint64_t *)*v5;
      int v8 = v45;
    }
    while (v5);
  }
  return 823;
}

uint64_t sub_10024E9F4(unsigned __int8 *a1, uint64_t a2)
{
  int v4 = *a1;
  if ((v4 - 6) < 2)
  {
    if (*((_WORD *)a1 + 1))
    {
      unint64_t v5 = 0;
      uint64_t v6 = *((void *)a1 + 1);
      do
      {
        uint64_t result = sub_10024E9F4(v6, a2);
        if (result) {
          break;
        }
        ++v5;
        v6 += 16;
      }
      while (v5 < *((unsigned __int16 *)a1 + 1));
      return result;
    }
    return 0;
  }
  if (v4 != 3) {
    return 0;
  }

  return sub_1001780EC((uint64_t)a1, a2);
}

void *sub_10024EA9C(uint64_t a1)
{
  uint64_t v1 = (unsigned __int16)word_100A103F0;
  if (!word_100A103F0) {
    return 0;
  }
  for (uint64_t result = (void *)qword_100A103F8; *result != a1; result += 4)
  {
    if (!--v1) {
      return 0;
    }
  }
  return result;
}

void sub_10024EAD4(uint64_t a1)
{
  if (sub_100058654())
  {
    sub_100056E24((uint64_t)"%: disconnected with reason %!", v2, v3, v4, v5, v6, v7, v8, a1 + 48);
    uint64_t v9 = sub_100050B4C(0x36u);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 136446210;
      int v45 = sub_100050714();
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
    }
  }
  if (!word_100A103F0)
  {
LABEL_10:
    if (sub_100058654())
    {
      sub_100056E24((uint64_t)"Could not find remote SDP record for handle: %p", v14, v15, v16, v17, v18, v19, v20, a1);
      int v21 = sub_100050B4C(0x36u);
      if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR)) {
        sub_100744F6C();
      }
    }
    return;
  }
  if (*(void *)qword_100A103F8 != a1)
  {
    unint64_t v10 = 0;
    uint64_t v11 = (uint64_t *)(qword_100A103F8 + 32);
    while ((unsigned __int16)word_100A103F0 - 1 != v10)
    {
      uint64_t v12 = *v11;
      v11 += 4;
      ++v10;
      if (v12 == a1)
      {
        BOOL v13 = v10 < (unsigned __int16)word_100A103F0;
        goto LABEL_14;
      }
    }
    goto LABEL_10;
  }
  unint64_t v10 = 0;
  BOOL v13 = 1;
LABEL_14:
  if (sub_100058654())
  {
    sub_100056E24((uint64_t)"Deleting remote SDP record at entry %d", v22, v23, v24, v25, v26, v27, v28, (unsigned __int16)v10);
    unsigned int v29 = sub_100050B4C(0x36u);
    if (os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
    {
      unint64_t v30 = sub_100050714();
      *(_DWORD *)long long buf = 136446210;
      int v45 = v30;
      _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
    }
  }
  uint64_t v31 = qword_100A103F8 + 32 * v10;
  *(_WORD *)(v31 + 26) = 0;
  *(void *)(v31 + 8) = 0;
  *(void *)(v31 + 16) = 0;
  *(void *)uint64_t v31 = 0;
  unsigned __int16 v32 = --word_100A103F0;
  if ((unsigned __int16)word_100A103F0 > (unsigned __int16)v10)
  {
    int v33 = (_OWORD *)(v31 + 32);
    do
    {
      long long v34 = v33[1];
      *(v33 - 2) = *v33;
      *(v33 - 1) = v34;
      LODWORD(v10) = v10 + 1;
      v33 += 2;
    }
    while ((unsigned __int16)v10 < v32);
  }
  if (v13 && sub_100058654())
  {
    sub_100056E24((uint64_t)"Deleted Remote SDP Record for %:", v35, v36, v37, v38, v39, v40, v41, a1 + 48);
    uint64_t v42 = sub_100050B4C(0x36u);
    if (os_log_type_enabled(v42, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v43 = sub_100050714();
      *(_DWORD *)long long buf = 136446210;
      int v45 = v43;
      _os_log_impl((void *)&_mh_execute_header, v42, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
    }
  }
}

void sub_10024ED84(uint64_t a1, char a2)
{
  uint64_t v3 = (unsigned __int16)word_100A103F0;
  if (word_100A103F0)
  {
    uint64_t v5 = qword_100A103F8;
    while (*(void *)v5 != a1)
    {
      v5 += 32;
      if (!--v3) {
        goto LABEL_5;
      }
    }
    if (sub_100058654())
    {
      sub_100056E24((uint64_t)"Wireless Splitter SDP record for remote device with hci handle: %p already exists, updating it", v14, v15, v16, v17, v18, v19, v20, *(void *)v5);
      int v21 = sub_100050B4C(0x36u);
      if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)long long buf = 136446210;
        uint64_t v23 = sub_100050714();
        _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
      }
    }
    *(unsigned char *)(v5 + 28) = a2;
  }
  else
  {
LABEL_5:
    if (sub_100058654())
    {
      sub_100056E24((uint64_t)"Wireless Splitter SDP record for remote device with hci handle: %p does not exist", v6, v7, v8, v9, v10, v11, v12, a1);
      BOOL v13 = sub_100050B4C(0x36u);
      if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)long long buf = 136446210;
        uint64_t v23 = sub_100050714();
        _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
      }
    }
  }
}

void sub_10024EEFC(uint64_t a1, char a2)
{
  uint64_t v3 = (unsigned __int16)word_100A103F0;
  if (word_100A103F0)
  {
    uint64_t v5 = qword_100A103F8;
    while (*(void *)v5 != a1)
    {
      v5 += 32;
      if (!--v3) {
        goto LABEL_5;
      }
    }
    if (sub_100058654())
    {
      sub_100056E24((uint64_t)"SDP record for remote device with hci handle: %p already exists, updating requiresLegacyPnPInformation flag in record.", v14, v15, v16, v17, v18, v19, v20, *(void *)v5);
      int v21 = sub_100050B4C(0x36u);
      if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)long long buf = 136446210;
        uint64_t v23 = sub_100050714();
        _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
      }
    }
    *(unsigned char *)(v5 + 24) = a2;
  }
  else
  {
LABEL_5:
    if (sub_100058654())
    {
      sub_100056E24((uint64_t)"SDP record for remote device with hci handle: %p does not exist", v6, v7, v8, v9, v10, v11, v12, a1);
      BOOL v13 = sub_100050B4C(0x36u);
      if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)long long buf = 136446210;
        uint64_t v23 = sub_100050714();
        _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
      }
    }
  }
}

uint64_t sub_10024F074(uint64_t a1, int a2, __int16 a3, __int16 a4)
{
  uint64_t v8 = (unsigned __int16)word_100A103F0;
  if (word_100A103F0)
  {
    uint64_t v9 = (_WORD *)(qword_100A103F8 + 14);
    while (*(void *)(v9 - 7) != a1)
    {
      v9 += 16;
      if (!--v8) {
        goto LABEL_5;
      }
    }
    if (sub_100058654())
    {
      sub_100056E24((uint64_t)"SDP record for remote device with hci handle: %p already exists, let's update the record", v32, v33, v34, v35, v36, v37, v38, *(void *)(v9 - 7));
      uint64_t v39 = sub_100050B4C(0x36u);
      if (os_log_type_enabled(v39, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)long long buf = 136446210;
        uint64_t v44 = sub_100050714();
        _os_log_impl((void *)&_mh_execute_header, v39, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
      }
    }
    uint64_t result = 0;
    if (a2 > 4381)
    {
      switch(a2)
      {
        case 4382:
          uint64_t result = 0;
          v9[3] = a3;
          v9[4] = a4;
          break;
        case 4398:
          uint64_t result = 0;
          v9[1] = a3;
          void v9[2] = a4;
          break;
        case 4404:
          uint64_t result = 0;
          v9[6] = a3;
          break;
      }
    }
    else if ((a2 - 4366) >= 2)
    {
      if (a2 == 4364)
      {
        uint64_t result = 0;
        *(v9 - 3) = a3;
        *(v9 - 2) = a4;
      }
    }
    else
    {
      uint64_t result = 0;
      *(v9 - 1) = a3;
      *uint64_t v9 = a4;
    }
  }
  else
  {
LABEL_5:
    if (sub_100058654())
    {
      sub_100056E24((uint64_t)"SDP record for remote device with hci handle: %p does not exist, creating one", v10, v11, v12, v13, v14, v15, v16, a1);
      uint64_t v17 = sub_100050B4C(0x36u);
      if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)long long buf = 136446210;
        uint64_t v44 = sub_100050714();
        _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
      }
    }
    unsigned int v18 = (unsigned __int16)word_100A103F0;
    if (v18 >= *(unsigned __int8 *)sub_10025B218(0x28u)) {
      sub_10025B8C0();
    }
    int v19 = (unsigned __int16)word_100A103F0;
    if (v19 == *(unsigned __int8 *)sub_10025B218(0x28u))
    {
      if (sub_100058654())
      {
        sub_100056E24((uint64_t)"No room to add another SDP remote record for connection %p. Total number of SDP remote records : %d", v20, v21, v22, v23, v24, v25, v26, (unsigned __int16)word_100A103F0);
        uint64_t v27 = sub_100050B4C(0x36u);
        if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR)) {
          sub_100748B78(v27);
        }
      }
      return 104;
    }
    else
    {
      uint64_t v29 = qword_100A103F8;
      uint64_t v30 = (unsigned __int16)word_100A103F0;
      *(void *)(qword_100A103F8 + 32 * (unsigned __int16)word_100A103F0) = a1;
      if (a2 > 4381)
      {
        switch(a2)
        {
          case 4382:
            uint64_t v41 = v29 + 32 * v30;
            *(_WORD *)(v41 + 20) = a3;
            *(_WORD *)(v41 + 22) = a4;
            break;
          case 4398:
            uint64_t v42 = v29 + 32 * v30;
            *(_WORD *)(v42 + 16) = a3;
            *(_WORD *)(v42 + 18) = a4;
            break;
          case 4404:
            *(_WORD *)(v29 + 32 * v30 + 26) = a3;
            break;
        }
      }
      else if ((a2 - 4366) >= 2)
      {
        if (a2 == 4364)
        {
          uint64_t v40 = v29 + 32 * v30;
          *(_WORD *)(v40 + 8) = a3;
          *(_WORD *)(v40 + 10) = a4;
        }
      }
      else
      {
        uint64_t v31 = v29 + 32 * v30;
        *(_WORD *)(v31 + 12) = a3;
        *(_WORD *)(v31 + 14) = a4;
      }
      uint64_t result = 0;
      word_100A103F0 = v30 + 1;
    }
  }
  return result;
}

uint64_t sub_10024F3CC(uint64_t result)
{
  byte_100A10400 = result;
  return result;
}

uint64_t sub_10024F3D8(uint64_t a1, uint64_t a2, unsigned int a3, unsigned __int16 *a4, __int16 **a5, uint64_t a6)
{
  uint64_t v6 = a4;
  unsigned int v7 = a3;
  unsigned int v10 = *a4;
  uint64_t v11 = (char *)&xmmword_100A0FFF8 + 8;
  uint64_t v12 = qword_100A103D8 + 120;
  if (byte_100A10400)
  {
    while (1)
    {
      uint64_t v12 = *(void *)v12;
      if (!v12) {
        return 802;
      }
      if (*(_DWORD *)(v12 + 48) == a1) {
        goto LABEL_28;
      }
    }
  }
  do
  {
    uint64_t v12 = *(void *)v12;
    if (!v12)
    {
      if (sub_100058654())
      {
        sub_100056E24((uint64_t)"Could not find record for service handle %u", v13, v14, v15, v16, v17, v18, v19, a1);
        uint64_t v20 = sub_100050B4C(0x36u);
        if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR)) {
          sub_100744F6C();
        }
      }
      return 802;
    }
  }
  while (*(_DWORD *)(v12 + 48) != a1);
  uint64_t v21 = *(unsigned __int16 *)(v12 + 24);
  if (*(_WORD *)(v12 + 24))
  {
    uint64_t v22 = 0;
    unsigned int v23 = 0;
    uint64_t v24 = 0;
    uint64_t v25 = *(void *)(v12 + 16) + 16;
    do
    {
      int v26 = *(unsigned __int16 *)(v25 - 16);
      if (v26 == 9)
      {
        uint64_t v24 = *(unsigned __int16 *)(*(void *)(*(void *)v25 + 8) + 24);
      }
      else if (v26 == 1)
      {
        unsigned int v23 = *(unsigned __int16 *)(v25 - 6);
        uint64_t v22 = *(void *)v25;
      }
      v25 += 24;
      --v21;
    }
    while (v21);
  }
  else
  {
    uint64_t v24 = 0;
    unsigned int v23 = 0;
    uint64_t v22 = 0;
  }
  uint64_t v27 = (unsigned __int16)word_100A103F0;
  if (!word_100A103F0)
  {
LABEL_23:
    uint64_t v29 = a5;
    if (sub_100058654())
    {
      sub_100056E24((uint64_t)"No remote SDP record found for device. Returning SDP record with profile version %x", v30, v31, v32, v33, v34, v35, v36, v24);
      uint64_t v37 = sub_100050B4C(0x36u);
      if (os_log_type_enabled(v37, OS_LOG_TYPE_ERROR)) {
        sub_100744F6C();
      }
    }
    a5 = v29;
LABEL_27:
    if (v12) {
      goto LABEL_28;
    }
    return 802;
  }
  uint64_t v28 = (unsigned __int16 *)(qword_100A103F8 + 16);
  while (*((void *)v28 - 2) != a6)
  {
    v28 += 16;
    if (!--v27) {
      goto LABEL_23;
    }
  }
  if (!v23) {
    goto LABEL_27;
  }
  char v65 = 0;
  unsigned int v66 = 0;
  uint64_t v67 = v23;
  uint64_t v68 = (int *)(v22 + 8);
  uint64_t v101 = a5;
  do
  {
    int v70 = *v68;
    v68 += 4;
    int v69 = v70;
    if (v70 <= 4398)
    {
      switch(v69)
      {
        case 4364:
          unsigned int v66 = *(v28 - 2);
          if (!*(v28 - 2)) {
            unsigned int v66 = *(v28 - 4);
          }
          break;
        case 4367:
          unsigned int v66 = *(v28 - 4);
          if (!*(v28 - 4)) {
            unsigned int v66 = *(v28 - 2);
          }
          break;
        case 4383:
          unsigned int v66 = v28[2];
          break;
        default:
          goto LABEL_97;
      }
      goto LABEL_96;
    }
    switch(v69)
    {
      case 4399:
        unsigned int v66 = *v28;
LABEL_96:
        char v65 = 1;
        break;
      case 4402:
        unsigned int v66 = v28[5];
        goto LABEL_96;
      case 4608:
        if (sub_100058654())
        {
          sub_100056E24((uint64_t)"Service class ID is OI_UUID_PnPInformation, so check if we need to send legacy PnPInformation record", v71, v72, v73, v74, v75, v76, v77, v99);
          uint64_t v78 = sub_100050B4C(0x36u);
          if (os_log_type_enabled(v78, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v79 = sub_100050714();
            *(_DWORD *)long long buf = 136446210;
            uint64_t v104 = v79;
            _os_log_impl((void *)&_mh_execute_header, v78, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
          }
        }
        char v65 = *((unsigned char *)v28 + 8);
        if (v65)
        {
          if (sub_100058654())
          {
            sub_100056E24((uint64_t)"Need to send legacy PnPInformation record to remote", v80, v81, v82, v83, v84, v85, v86, v99);
            uint64_t v87 = sub_100050B4C(0x36u);
            if (os_log_type_enabled(v87, OS_LOG_TYPE_DEFAULT))
            {
              uint64_t v88 = sub_100050714();
              *(_DWORD *)long long buf = 136446210;
              uint64_t v104 = v88;
              _os_log_impl((void *)&_mh_execute_header, v87, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
            }
          }
          char v65 = 0;
          uint64_t v12 = *(void *)(v12 + 8);
        }
        a5 = v101;
        uint64_t v6 = a4;
        break;
    }
LABEL_97:
    --v67;
  }
  while (v67);
  uint64_t v11 = (unsigned char *)(&xmmword_100A0FFF8 + 8);
  if (!v66 || v24 <= v66)
  {
    unsigned int v7 = a3;
    goto LABEL_27;
  }
  if (v65)
  {
    uint64_t v89 = *(void **)(v12 + 8);
    if (v89)
    {
      uint64_t v90 = 0;
      unsigned __int16 v91 = -1;
      do
      {
        if (*(_WORD *)(v12 + 24))
        {
          uint64_t v92 = v89[2] + 16;
          uint64_t v93 = *(unsigned __int16 *)(v12 + 24);
          do
          {
            if (*(_WORD *)(v92 - 16) == 9)
            {
              unsigned int v94 = *(unsigned __int16 *)(*(void *)(*(void *)v92 + 8) + 24);
              if (v94 <= v66)
              {
                if ((int)(v66 - v94) <= v91)
                {
                  uint64_t v90 = v89;
                  unsigned __int16 v91 = v66 - v94;
                }
              }
              else if ((int)(v94 - v66) < v91)
              {
                uint64_t v90 = v89;
                unsigned __int16 v91 = v94 - v66;
              }
            }
            v92 += 24;
            --v93;
          }
          while (v93);
        }
        uint64_t v89 = (void *)*v89;
      }
      while (v89);
    }
    else
    {
      uint64_t v90 = 0;
    }
    if (v90) {
      uint64_t v12 = (uint64_t)v90;
    }
  }
  unsigned int v7 = a3;
  if (!v12)
  {
    sub_10025B8C0();
    return 802;
  }
LABEL_28:
  unint64_t v38 = v7;
  uint64_t v39 = *((void *)v11 + 123);
  *(unsigned char *)(v39 + 8) = 1;
  *(_WORD *)(v39 + 10) = 4;
  *(_DWORD *)(v39 + 16) = *(_DWORD *)(v12 + 48);
  *(unsigned char *)(v39 + 32) = 1;
  *(_WORD *)(v39 + 34) = 4;
  *(_DWORD *)(v39 + 40) = *(_DWORD *)(v12 + 52);
  *(unsigned char *)(v39 + 56) = 1;
  *(_WORD *)(v39 + 58) = 1;
  *(_DWORD *)(v39 + 64) = *(unsigned __int8 *)(v12 + 66);
  *(_OWORD *)(v39 + 80) = unk_1009F9418;
  *(_OWORD *)(v39 + 104) = *(_OWORD *)*(void *)(v12 + 72);
  if (*(_WORD *)(v39 + 106)) {
    int v40 = 5;
  }
  else {
    int v40 = 4;
  }
  if (!v7)
  {
LABEL_69:
    *a5 = 0;
    *uint64_t v6 = 0;
    return 826;
  }
  uint64_t v41 = 0;
  uint64_t v42 = (uint64_t *)(v12 + 56);
  uint64_t v43 = (unsigned __int16 *)(v12 + 64);
  uint64_t v44 = (uint64_t *)(v12 + 32);
  int v45 = (uint64_t *)(v12 + 16);
  int v46 = (unsigned __int16 *)(v12 + 40);
  uint64_t v47 = (unsigned __int16 *)(v12 + 24);
  if (byte_100A10404) {
    int v48 = 1330184192;
  }
  else {
    int v48 = 0;
  }
  while (2)
  {
    if (*(unsigned char *)(a2 + 16 * v41) != 1) {
      return 825;
    }
    uint64_t v49 = a2 + 16 * v41;
    int v50 = *(unsigned __int16 *)(v49 + 2);
    if (v50 == 4)
    {
      LODWORD(v52) = *(_DWORD *)(v49 + 8);
      unsigned int v51 = v52 >> 16;
    }
    else
    {
      if (v50 != 2) {
        return 825;
      }
      unsigned int v51 = *(unsigned __int16 *)(a2 + 16 * v41 + 8);
      LOWORD(v52) = *(_WORD *)(a2 + 16 * v41 + 8);
    }
    if (v10 > (unsigned __int16)v52)
    {
LABEL_68:
      if (++v41 >= v38) {
        goto LABEL_69;
      }
      continue;
    }
    break;
  }
  int v53 = 0;
  unsigned __int16 v54 = 0;
  if (v51 <= v10) {
    unsigned int v55 = v10;
  }
  else {
    unsigned int v55 = v51;
  }
  do
  {
    uint64_t v56 = v45;
    uint64_t v57 = v47;
    int v58 = v40;
    uint64_t v59 = v39;
    switch(v53)
    {
      case 0:
        goto LABEL_49;
      case 1:
        goto LABEL_47;
      case 2:
        uint64_t v56 = v44;
        uint64_t v57 = v46;
        goto LABEL_47;
      case 3:
        uint64_t v56 = v42;
        uint64_t v57 = v43;
LABEL_47:
        uint64_t v59 = *v56;
        int v58 = *v57;
        break;
      default:
        break;
    }
    if (v58 >= 1)
    {
LABEL_49:
      unsigned __int16 v60 = 0;
      while (1)
      {
        uint64_t v61 = (_WORD *)(v59 + 24 * v60);
        unsigned int v62 = (unsigned __int16)*v61;
        if (v55 <= v62 && v62 <= (unsigned __int16)v52)
        {
          unsigned __int16 v54 = (__int16 *)(v59 + 24 * v60);
          LOWORD(v52) = *v61;
          if (v55 == v62) {
            break;
          }
        }
        if (v58 <= ++v60) {
          goto LABEL_56;
        }
      }
      unsigned __int16 v54 = (__int16 *)(v59 + 24 * v60);
      LOWORD(v52) = *v61;
    }
LABEL_56:
    ++v53;
  }
  while (v53 != 4);
  if (!v54)
  {
    if (v48 == a1
      && v38 == 1
      && *(unsigned char *)a2 == 1
      && *(_WORD *)(a2 + 2) == 4
      && HIWORD(*(_DWORD *)(a2 + 8)) == 1024)
    {
      unsigned int v63 = (unsigned __int16)*v6;
      if ((unsigned __int16)*(_DWORD *)(a2 + 8) >= v63)
      {
        LODWORD(v52) = v63 <= 0x400 ? 1024 : (unsigned __int16)*v6;
        if ((v52 - 1024) < 0x25)
        {
          unsigned __int16 v54 = &word_100A10428;
          word_100A10428 = (__int16)v52;
          byte_100A10430 = 6;
          word_100A10432 = 2;
          qword_100A10438 = (uint64_t)&byte_100A10440;
          byte_100A10440 = 4;
          uint64_t v95 = &(&off_10099FB80)[2 * (v52 - 1024)];
          uint64_t v96 = *v95;
          uint64_t v97 = a5;
          __int16 v98 = strlen(*v95);
          a5 = v97;
          word_100A10442 = v98;
          qword_100A10448 = (uint64_t)v96;
          byte_100A10450 = 1;
          word_100A10452 = 2;
          dword_100A10458 = *((unsigned __int16 *)v95 + 4);
          goto LABEL_117;
        }
      }
    }
    goto LABEL_68;
  }
  if ((unsigned __int16)*v54 != (unsigned __int16)v52)
  {
    unsigned __int16 v52 = a5;
    sub_10025B8C0();
    a5 = v52;
    LOWORD(v52) = *v54;
  }
LABEL_117:
  uint64_t result = 0;
  *a5 = v54;
  *uint64_t v6 = (_WORD)v52 + 1;
  return result;
}

uint64_t sub_10024FB34(uint64_t *a1, char *a2)
{
  uint64_t v2 = a2;
  if (*a2 == 32) {
    uint64_t v2 = (char *)*((void *)a2 + 1);
  }
  if (*((unsigned char *)a1 + 15))
  {
    sub_10025A794((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpdb.c");
    goto LABEL_77;
  }
  uint64_t v4 = *((unsigned __int16 *)a1 + 6);
  if (*((unsigned __int16 *)a1 + 5) <= v4)
  {
LABEL_77:
    uint64_t v32 = "ByteStream_NumReadBytesAvail(*pByteStream) >= 1";
    goto LABEL_79;
  }
  if (*((unsigned char *)a1 + 14) != 2)
  {
    uint64_t v32 = "(*pByteStream).__RWFlag == BYTESTREAM_WRITE";
LABEL_79:
    sub_10014327C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpdb.c", 1532, v32);
  }
  char v5 = *v2;
  uint64_t v6 = *a1;
  *((_WORD *)a1 + 6) = v4 + 1;
  *(unsigned char *)(v6 + v4) = v5;
  if (*((unsigned char *)a1 + 15))
  {
    sub_10025A794((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpdb.c");
    goto LABEL_81;
  }
  uint64_t v7 = *((unsigned __int16 *)a1 + 6);
  if (*((unsigned __int16 *)a1 + 5) - (int)v7 <= 1)
  {
LABEL_81:
    uint64_t v33 = "ByteStream_NumReadBytesAvail(*pByteStream) >= 2";
    goto LABEL_83;
  }
  if (*((unsigned char *)a1 + 14) != 2)
  {
    uint64_t v33 = "(*pByteStream).__RWFlag == BYTESTREAM_WRITE";
LABEL_83:
    sub_10014327C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpdb.c", 1533, v33);
  }
  *(unsigned char *)(*a1 + v7) = v2[2];
  *(unsigned char *)(*a1 + *((unsigned __int16 *)a1 + 6) + 1) = v2[3];
  __int16 v8 = *((_WORD *)a1 + 6);
  unsigned __int16 v9 = v8 + 2;
  *((_WORD *)a1 + 6) = v8 + 2;
  switch(*v2)
  {
    case 0:
      return 1;
    case 1:
      int v10 = *((unsigned __int16 *)v2 + 1);
      if (v10 != 16)
      {
        if (v10 == 8)
        {
          if (*((unsigned char *)a1 + 15))
          {
            sub_10025A794((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpdb.c");
          }
          else
          {
            uint64_t v11 = v9;
            if (*((unsigned __int16 *)a1 + 5) - (unint64_t)v9 > 7)
            {
              if (*((unsigned char *)a1 + 14) != 2)
              {
                uint64_t v12 = "(*pByteStream).__RWFlag == BYTESTREAM_WRITE";
                goto LABEL_101;
              }
              goto LABEL_21;
            }
          }
          uint64_t v12 = "ByteStream_NumReadBytesAvail(*pByteStream) >= (sizeof(OI_UINT64))";
LABEL_101:
          sub_10014327C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpdb.c", 1542, v12);
        }
        if (*((unsigned char *)a1 + 15))
        {
          sub_10025A794((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpdb.c");
        }
        else if (*((unsigned __int16 *)a1 + 5) - v9 > 3)
        {
          if (*((unsigned char *)a1 + 14) != 2)
          {
            uint64_t v31 = "(*pByteStream).__RWFlag == BYTESTREAM_WRITE";
            goto LABEL_111;
          }
LABEL_73:
          *(unsigned char *)(*a1 + v9) = *((_DWORD *)v2 + 2);
          *(unsigned char *)(*a1 + *((unsigned __int16 *)a1 + 6) + 1) = BYTE1(*((_DWORD *)v2 + 2));
          *(unsigned char *)(*a1 + *((unsigned __int16 *)a1 + 6) + 2) = *((_WORD *)v2 + 5);
          *(unsigned char *)(*a1 + *((unsigned __int16 *)a1 + 6) + 3) = v2[11];
          __int16 v14 = *((_WORD *)a1 + 6) + 4;
          goto LABEL_74;
        }
        uint64_t v31 = "ByteStream_NumReadBytesAvail(*pByteStream) >= 4";
LABEL_111:
        sub_10014327C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpdb.c", 1546, v31);
      }
      if (*((unsigned char *)a1 + 15))
      {
        sub_10025A794((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpdb.c");
      }
      else if (*((unsigned __int16 *)a1 + 5) - (unint64_t)v9 > 0xF)
      {
        if (*((unsigned char *)a1 + 14) != 2)
        {
          uint64_t v30 = "(*pByteStream).__RWFlag == BYTESTREAM_WRITE";
          goto LABEL_108;
        }
LABEL_69:
        *(_OWORD *)(*a1 + v9) = *(_OWORD *)*((void *)v2 + 1);
        __int16 v14 = *((_WORD *)a1 + 6) + 16;
        goto LABEL_74;
      }
      uint64_t v30 = "ByteStream_NumReadBytesAvail(*pByteStream) >= (sizeof(OI_UINT128))";
LABEL_108:
      sub_10014327C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpdb.c", 1544, v30);
    case 2:
      int v13 = *((unsigned __int16 *)v2 + 1);
      if (v13 != 16)
      {
        if (v13 == 8)
        {
          if (*((unsigned char *)a1 + 15))
          {
            sub_10025A794((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpdb.c");
          }
          else
          {
            uint64_t v11 = v9;
            if (*((unsigned __int16 *)a1 + 5) - (unint64_t)v9 > 7)
            {
              if (*((unsigned char *)a1 + 14) == 2)
              {
LABEL_21:
                *(void *)(*a1 + v11) = **((void **)v2 + 1);
                __int16 v14 = *((_WORD *)a1 + 6) + 8;
LABEL_74:
                *((_WORD *)a1 + 6) = v14;
                return 1;
              }
              uint64_t v36 = "(*pByteStream).__RWFlag == BYTESTREAM_WRITE";
LABEL_105:
              sub_10014327C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpdb.c", 1552, v36);
            }
          }
          uint64_t v36 = "ByteStream_NumReadBytesAvail(*pByteStream) >= (sizeof(OI_INT64))";
          goto LABEL_105;
        }
        if (*((unsigned char *)a1 + 15))
        {
          sub_10025A794((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpdb.c");
        }
        else if (*((unsigned __int16 *)a1 + 5) - v9 > 3)
        {
          if (*((unsigned char *)a1 + 14) == 2) {
            goto LABEL_73;
          }
          unint64_t v38 = "(*pByteStream).__RWFlag == BYTESTREAM_WRITE";
LABEL_119:
          sub_10014327C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpdb.c", 1556, v38);
        }
        unint64_t v38 = "ByteStream_NumReadBytesAvail(*pByteStream) >= 4";
        goto LABEL_119;
      }
      if (*((unsigned char *)a1 + 15))
      {
        sub_10025A794((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpdb.c");
      }
      else if (*((unsigned __int16 *)a1 + 5) - (unint64_t)v9 > 0xF)
      {
        if (*((unsigned char *)a1 + 14) == 2) {
          goto LABEL_69;
        }
        uint64_t v37 = "(*pByteStream).__RWFlag == BYTESTREAM_WRITE";
LABEL_115:
        sub_10014327C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpdb.c", 1554, v37);
      }
      uint64_t v37 = "ByteStream_NumReadBytesAvail(*pByteStream) >= (sizeof(OI_INT128))";
      goto LABEL_115;
    case 3:
      if (*((_WORD *)v2 + 1) == 16)
      {
        if (*((unsigned char *)a1 + 15))
        {
          sub_10025A794((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpdb.c");
        }
        else if (*((unsigned __int16 *)a1 + 5) - (unint64_t)(unsigned __int16)(v8 + 2) > 0xF)
        {
          if (*((unsigned char *)a1 + 14) == 2) {
            goto LABEL_69;
          }
          uint64_t v15 = "(*pByteStream).__RWFlag == BYTESTREAM_WRITE";
LABEL_95:
          sub_10014327C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpdb.c", 1562, v15);
        }
        uint64_t v15 = "ByteStream_NumReadBytesAvail(*pByteStream) >= (sizeof (OI_UUID128))";
        goto LABEL_95;
      }
      if (*((unsigned char *)a1 + 15))
      {
        sub_10025A794((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpdb.c");
      }
      else if (*((unsigned __int16 *)a1 + 5) - v9 > 3)
      {
        if (*((unsigned char *)a1 + 14) == 2) {
          goto LABEL_73;
        }
        uint64_t v27 = "(*pByteStream).__RWFlag == BYTESTREAM_WRITE";
LABEL_98:
        sub_10014327C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpdb.c", 1564, v27);
      }
      uint64_t v27 = "ByteStream_NumReadBytesAvail(*pByteStream) >= 4";
      goto LABEL_98;
    case 4:
      uint64_t v16 = *a1;
      uint64_t v17 = (const void *)*((void *)v2 + 1);
      if (*((unsigned char *)a1 + 15))
      {
        sub_10025A794((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpdb.c");
        int v18 = 0;
      }
      else
      {
        int v18 = *((unsigned __int16 *)a1 + 5) - v9;
      }
      size_t v28 = *((unsigned __int16 *)v2 + 1);
      if (v18 < (int)v28)
      {
        uint64_t v29 = "ByteStream_NumReadBytesAvail(*pByteStream) >= (elem->Size)";
LABEL_89:
        sub_10014327C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpdb.c", 1569, v29);
      }
      if (*((unsigned char *)a1 + 14) != 2)
      {
        uint64_t v29 = "(*pByteStream).__RWFlag == BYTESTREAM_WRITE";
        goto LABEL_89;
      }
      goto LABEL_57;
    case 5:
      if (*((unsigned char *)a1 + 15))
      {
        sub_10025A794((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpdb.c");
        goto LABEL_85;
      }
      if (*((unsigned __int16 *)a1 + 5) <= v9)
      {
LABEL_85:
        uint64_t v34 = "ByteStream_NumReadBytesAvail(*pByteStream) >= 1";
        goto LABEL_87;
      }
      if (*((unsigned char *)a1 + 14) != 2)
      {
        uint64_t v34 = "(*pByteStream).__RWFlag == BYTESTREAM_WRITE";
LABEL_87:
        sub_10014327C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpdb.c", 1573, v34);
      }
      char v19 = v2[8];
      uint64_t v20 = *a1;
      *((_WORD *)a1 + 6) = v8 + 3;
      *(unsigned char *)(v20 + (unsigned __int16)(v8 + 2)) = v19;
      return 1;
    case 6:
      if (!*((_WORD *)v2 + 1)) {
        return 1;
      }
      uint64_t v21 = 0;
      unint64_t v22 = 0;
      while ((sub_10024FB34(a1, *((void *)v2 + 1) + v21) & 1) != 0)
      {
        ++v22;
        v21 += 16;
        if (v22 >= *((unsigned __int16 *)v2 + 1)) {
          return 1;
        }
      }
      return 0;
    case 7:
      if (!*((_WORD *)v2 + 1)) {
        return 1;
      }
      uint64_t v23 = 0;
      unint64_t v24 = 0;
      while ((sub_10024FB34(a1, *((void *)v2 + 1) + v23) & 1) != 0)
      {
        ++v24;
        v23 += 16;
        if (v24 >= *((unsigned __int16 *)v2 + 1)) {
          return 1;
        }
      }
      return 0;
    case 8:
      uint64_t v16 = *a1;
      uint64_t v17 = (const void *)*((void *)v2 + 1);
      if (*((unsigned char *)a1 + 15))
      {
        sub_10025A794((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpdb.c");
        int v26 = 0;
      }
      else
      {
        int v26 = *((unsigned __int16 *)a1 + 5) - v9;
      }
      size_t v28 = *((unsigned __int16 *)v2 + 1);
      if (v26 < (int)v28)
      {
        uint64_t v35 = "ByteStream_NumReadBytesAvail(*pByteStream) >= (elem->Size)";
      }
      else
      {
        if (*((unsigned char *)a1 + 14) == 2)
        {
LABEL_57:
          memmove((void *)(v16 + v9), v17, v28);
          __int16 v14 = *((_WORD *)a1 + 6) + *((_WORD *)v2 + 1);
          goto LABEL_74;
        }
        uint64_t v35 = "(*pByteStream).__RWFlag == BYTESTREAM_WRITE";
      }
      sub_10014327C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpdb.c", 1596, v35);
    default:
      return 0;
  }
}

uint64_t sub_100250314(uint64_t a1)
{
  if (!a1) {
    return 101;
  }
  if (*(unsigned char *)(a1 + 15))
  {
    sub_10025A794((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpdb.c");
    goto LABEL_60;
  }
  uint64_t v2 = *(unsigned __int16 *)(a1 + 12);
  if (*(unsigned __int16 *)(a1 + 10) - (int)v2 <= 1)
  {
LABEL_60:
    int v26 = "ByteStream_NumReadBytesAvail(*sdpDataRecord) >= 2";
    goto LABEL_62;
  }
  if (*(unsigned char *)(a1 + 14) != 2)
  {
    int v26 = "(*sdpDataRecord).__RWFlag == BYTESTREAM_WRITE";
LABEL_62:
    sub_10014327C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpdb.c", 1612, v26);
  }
  *(unsigned char *)(*(void *)a1 + v2) = 0;
  *(unsigned char *)(*(void *)a1 + *(unsigned __int16 *)(a1 + 12) + 1) = 0;
  *(_WORD *)(a1 + 12) += 2;
  uint64_t v3 = *(uint64_t **)(qword_100A103D8 + 120);
  if (!v3)
  {
    LOBYTE(v4) = 0;
    char v22 = 0;
LABEL_45:
    uint64_t result = 0;
    **(unsigned char **)a1 = v4;
    *(unsigned char *)(*(void *)a1 + 1) = v22;
    return result;
  }
  __int16 v4 = 0;
LABEL_7:
  uint64_t v5 = *((unsigned __int16 *)v3 + 12);
  if (!*((_WORD *)v3 + 12)) {
    goto LABEL_13;
  }
  uint64_t v6 = (char *)(v3[2] + 8);
  while (*((_WORD *)v6 - 4) != 1)
  {
    v6 += 24;
    if (!--v5) {
      goto LABEL_13;
    }
  }
  uint64_t result = sub_10024FB34((uint64_t *)a1, v6);
  if (result)
  {
LABEL_13:
    if (*(unsigned char *)(a1 + 15))
    {
      sub_10025A794((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpdb.c");
    }
    else
    {
      uint64_t v8 = *(unsigned __int16 *)(a1 + 12);
      if (*(unsigned __int16 *)(a1 + 10) - (int)v8 > 1)
      {
        if (*(unsigned char *)(a1 + 14) == 2)
        {
          uint64_t v9 = 0;
          *(unsigned char *)(*(void *)a1 + *(unsigned __int16 *)(a1 + 12)) = 0;
          ++v4;
          *(unsigned char *)(*(void *)a1 + *(unsigned __int16 *)(a1 + 12) + 1) = 0;
          *(_WORD *)(a1 + 12) += 2;
          uint64_t v10 = qword_100A103D8;
          *(unsigned char *)(qword_100A103D8 + 8) = 1;
          *(_WORD *)(v10 + 10) = 4;
          *(_DWORD *)(v10 + 16) = *((_DWORD *)v3 + 12);
          *(unsigned char *)(v10 + 32) = 1;
          *(_WORD *)(v10 + 34) = 4;
          *(_DWORD *)(v10 + 40) = *((_DWORD *)v3 + 13);
          *(unsigned char *)(v10 + 56) = 1;
          *(_WORD *)(v10 + 58) = 1;
          *(_DWORD *)(v10 + 64) = *((unsigned __int8 *)v3 + 66);
          *(_OWORD *)(v10 + 80) = unk_1009F9418;
          *(_OWORD *)(v10 + 104) = *(_OWORD *)v3[9];
          if (*(_WORD *)(v10 + 106)) {
            unsigned int v11 = 5;
          }
          else {
            unsigned int v11 = 4;
          }
          while (1)
          {
            if (*(unsigned char *)(a1 + 15))
            {
              sub_10025A794((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpdb.c");
LABEL_48:
              uint64_t v23 = "ByteStream_NumReadBytesAvail(*sdpDataRecord) >= 2";
LABEL_50:
              sub_10014327C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpdb.c", 1634, v23);
            }
            uint64_t v12 = *(unsigned __int16 *)(a1 + 12);
            if (*(unsigned __int16 *)(a1 + 10) - (int)v12 <= 1) {
              goto LABEL_48;
            }
            if (*(unsigned char *)(a1 + 14) != 2)
            {
              uint64_t v23 = "(*sdpDataRecord).__RWFlag == BYTESTREAM_WRITE";
              goto LABEL_50;
            }
            uint64_t v13 = qword_100A103D8 + v9;
            *(unsigned char *)(*(void *)a1 + v12) = *(unsigned char *)(qword_100A103D8 + v9);
            *(unsigned char *)(*(void *)a1 + *(unsigned __int16 *)(a1 + 12) + 1) = *(unsigned char *)(v13 + 1);
            *(_WORD *)(a1 + 12) += 2;
            if ((sub_10024FB34((uint64_t *)a1, (char *)(v13 + 8)) & 1) == 0) {
              return 0;
            }
            v9 += 24;
            if (24 * v11 == v9)
            {
              unsigned __int16 v14 = *((_WORD *)v3 + 12);
              if (v14)
              {
                uint64_t v15 = 0;
                for (unint64_t i = 0; i < v14; ++i)
                {
                  int v17 = *(unsigned __int16 *)(v3[2] + v15);
                  if (v17 != 1)
                  {
                    if (*(unsigned char *)(a1 + 15))
                    {
                      sub_10025A794((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpdb.c");
LABEL_56:
                      uint64_t v25 = "ByteStream_NumReadBytesAvail(*sdpDataRecord) >= 2";
LABEL_58:
                      sub_10014327C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpdb.c", 1646, v25);
                    }
                    uint64_t v18 = *(unsigned __int16 *)(a1 + 12);
                    if (*(unsigned __int16 *)(a1 + 10) - (int)v18 <= 1) {
                      goto LABEL_56;
                    }
                    if (*(unsigned char *)(a1 + 14) != 2)
                    {
                      uint64_t v25 = "(*sdpDataRecord).__RWFlag == BYTESTREAM_WRITE";
                      goto LABEL_58;
                    }
                    *(unsigned char *)(*(void *)a1 + v18) = v17;
                    *(unsigned char *)(*(void *)a1 + *(unsigned __int16 *)(a1 + 12) + 1) = *(unsigned char *)(v3[2] + v15 + 1);
                    *(_WORD *)(a1 + 12) += 2;
                    uint64_t result = sub_10024FB34((uint64_t *)a1, (char *)(v3[2] + v15 + 8));
                    if (!result) {
                      return result;
                    }
                    LOWORD(v11) = v11 + 1;
                    unsigned __int16 v14 = *((_WORD *)v3 + 12);
                  }
                  v15 += 24;
                }
              }
              if (*((_WORD *)v3 + 32))
              {
                uint64_t v19 = 0;
                unint64_t v20 = 0;
                while (!*(unsigned char *)(a1 + 15))
                {
                  uint64_t v21 = *(unsigned __int16 *)(a1 + 12);
                  if (*(unsigned __int16 *)(a1 + 10) - (int)v21 <= 1) {
                    goto LABEL_52;
                  }
                  if (*(unsigned char *)(a1 + 14) != 2)
                  {
                    unint64_t v24 = "(*sdpDataRecord).__RWFlag == BYTESTREAM_WRITE";
                    goto LABEL_54;
                  }
                  *(unsigned char *)(*(void *)a1 + v21) = *(unsigned char *)(v3[7] + v19);
                  *(unsigned char *)(*(void *)a1 + *(unsigned __int16 *)(a1 + 12) + 1) = *(unsigned char *)(v3[7] + v19 + 1);
                  *(_WORD *)(a1 + 12) += 2;
                  if ((sub_10024FB34((uint64_t *)a1, (char *)(v3[7] + v19 + 8)) & 1) == 0) {
                    return 0;
                  }
                  ++v20;
                  v19 += 24;
                  LOWORD(v11) = v11 + 1;
                  if (v20 >= *((unsigned __int16 *)v3 + 32)) {
                    goto LABEL_40;
                  }
                }
                sub_10025A794((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpdb.c");
LABEL_52:
                unint64_t v24 = "ByteStream_NumReadBytesAvail(*sdpDataRecord) >= 2";
LABEL_54:
                sub_10014327C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpdb.c", 1654, v24);
              }
LABEL_40:
              *(_WORD *)(*(void *)a1 + v8) = v11;
              uint64_t v3 = (uint64_t *)*v3;
              if (!v3)
              {
                char v22 = HIBYTE(v4);
                goto LABEL_45;
              }
              goto LABEL_7;
            }
          }
        }
        uint64_t v27 = "(*sdpDataRecord).__RWFlag == BYTESTREAM_WRITE";
LABEL_66:
        sub_10014327C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpdb.c", 1629, v27);
      }
    }
    uint64_t v27 = "ByteStream_NumReadBytesAvail(*sdpDataRecord) >= 2";
    goto LABEL_66;
  }
  return result;
}

uint64_t sub_100250820(uint64_t a1)
{
  if (a1)
  {
    if (sub_100058654())
    {
      sub_100056E24((uint64_t)"OI_SDPServer_Init: configuration parameter is deprecated", v2, v3, v4, v5, v6, v7, v8, v14);
      uint64_t v9 = sub_100050B4C(0x35u);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR)) {
        sub_100744F6C();
      }
    }
    sub_10025B260(a1, 53);
  }
  if (DWORD1(xmmword_100A19880)) {
    return 140;
  }
  unsigned int v11 = (unsigned __int8 *)sub_10025B218(0x35u);
  if (!v11)
  {
    sub_10025B8C0();
    return 127;
  }
  uint64_t v12 = v11;
  unsigned int v13 = *v11;
  if (!*v11) {
    goto LABEL_17;
  }
  if (*((unsigned __int16 *)v11 + 1) <= 0xFu)
  {
    sub_10025B8C0();
    if (*((unsigned __int16 *)v12 + 1) < 0x10u) {
      return 101;
    }
    unsigned int v13 = *v12;
  }
  xmmword_100A10460 = 0u;
  *(_OWORD *)&qword_100A10470 = 0u;
  *((void *)&xmmword_100A10460 + 1) = sub_10010CE48(32 * v13);
  if (!*((void *)&xmmword_100A10460 + 1)) {
    return 106;
  }
  *(void *)&xmmword_100A10460 = sub_10025B218(0x35u);
  uint64_t result = sub_10024E0B0();
  if (!result)
  {
    uint64_t result = sub_1001E5FF0(1, (uint64_t)sub_100250FFC);
    if (!result)
    {
LABEL_17:
      uint64_t result = 0;
      DWORD1(xmmword_100A19880) = 1;
    }
  }
  return result;
}

uint64_t sub_10025095C(uint64_t a1)
{
  if (!DWORD1(xmmword_100A19880)) {
    return 103;
  }
  uint64_t result = 0;
  qword_100A10470 = a1;
  return result;
}

void sub_100250988(int a1, unsigned int a2)
{
  long long v36 = 0u;
  long long v37 = 0u;
  if (sub_100058654())
  {
    sub_100056E24((uint64_t)"SDPSERVER OI_SDPSRV_RespondToStalledIncomingRequest: stalled cid is %u, accept: %d", v4, v5, v6, v7, v8, v9, v10, a2);
    unsigned int v11 = sub_100050B4C(0x35u);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 136446210;
      uint64_t v39 = sub_100050714();
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
    }
  }
  uint64_t v12 = xmmword_100A10460;
  uint64_t v13 = *(unsigned __int8 *)xmmword_100A10460;
  if (!*(unsigned char *)xmmword_100A10460)
  {
LABEL_9:
    if (sub_100058654())
    {
      sub_100056E24((uint64_t)"stalled sdpclient is NULL", v15, v16, v17, v18, v19, v20, v21, v35);
      char v22 = sub_100050B4C(0x35u);
      if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR)) {
        sub_100744F6C();
      }
    }
    return;
  }
  uint64_t v14 = (__int16 *)(*((void *)&xmmword_100A10460 + 1) + 4);
  while (!*((unsigned char *)v14 - 2) || (unsigned __int16)*(v14 - 2) != a2)
  {
    v14 += 16;
    if (!--v13) {
      goto LABEL_9;
    }
  }
  if (a1)
  {
    *((unsigned char *)v14 - 2) = 1;
    unsigned int v23 = *(unsigned __int16 *)(v12 + 4);
    *uint64_t v14 = v23;
    if (v23 > 0x80)
    {
      if (v23 <= *(unsigned __int16 *)(sub_10025B218(0x28u) + 8))
      {
        __int16 v24 = *v14;
        goto LABEL_19;
      }
      __int16 v24 = *(_WORD *)(sub_10025B218(0x28u) + 8);
    }
    else
    {
      __int16 v24 = 128;
    }
    *uint64_t v14 = v24;
LABEL_19:
    *((void *)&v36 + 1) = 0;
    long long v37 = 0uLL;
    LOWORD(v36) = v24;
    *(_DWORD *)((char *)&v36 + 2) = 327745535;
    WORD3(v36) = 772;
  }
  uint64_t v25 = sub_1001E0320((uint64_t)sub_100250BEC, (uint64_t)sub_100250CA0, (uint64_t)sub_100250D74, a2, (uint64_t)&v36, a1, (uint64_t)&unk_1007BAC80);
  if (v25)
  {
    uint64_t v26 = v25;
    if (sub_100058654())
    {
      sub_100056E24((uint64_t)"SDPServer: L2CAP failed to complete the connection %!", v27, v28, v29, v30, v31, v32, v33, v26);
      uint64_t v34 = sub_100050B4C(0x35u);
      if (os_log_type_enabled(v34, OS_LOG_TYPE_ERROR)) {
        sub_100744F6C();
      }
    }
    *((unsigned char *)v14 - 2) = 0;
  }
}

void sub_100250BEC(uint64_t a1, unsigned int a2, unsigned int a3, int a4)
{
  if (a4)
  {
    sub_100250CA0(a1);
  }
  else
  {
    uint64_t v4 = xmmword_100A10460;
    uint64_t v5 = *(unsigned __int8 *)xmmword_100A10460;
    if (*(unsigned char *)xmmword_100A10460)
    {
      uint64_t v6 = (_WORD *)(*((void *)&xmmword_100A10460 + 1) + 6);
      while (!*((unsigned char *)v6 - 4) || (unsigned __int16)*(v6 - 3) != a1)
      {
        v6 += 16;
        if (!--v5) {
          goto LABEL_10;
        }
      }
    }
    else
    {
LABEL_10:
      sub_10025B8C0();
      __break(1u);
    }
    if ((unsigned __int16)*(v6 - 1) >= a2)
    {
      unsigned int v7 = *(unsigned __int16 *)(v4 + 2);
      if (v7 <= a3) {
        *uint64_t v6 = v7;
      }
      else {
        *uint64_t v6 = a3;
      }
    }
    else
    {
      sub_100251324(a1);
    }
  }
}

void sub_100250CA0(int a1)
{
  LODWORD(v2) = *(unsigned __int8 *)xmmword_100A10460;
  if (*(unsigned char *)xmmword_100A10460)
  {
    uint64_t v3 = (unsigned __int16 *)*((void *)&xmmword_100A10460 + 1);
    uint64_t v4 = *(unsigned __int8 *)xmmword_100A10460;
    while (!*((unsigned char *)v3 + 2) || *v3 != a1)
    {
      v3 += 16;
      if (!--v4) {
        goto LABEL_6;
      }
    }
  }
  else
  {
LABEL_6:
    uint64_t v3 = 0;
  }
  if (qword_100A10470)
  {
    uint64_t v5 = *(void (**)(unsigned __int16 *))(qword_100A10470 + 8);
    if (v5)
    {
      v5(v3 + 12);
      LODWORD(v2) = *(unsigned __int8 *)xmmword_100A10460;
    }
  }
  if (v2)
  {
    uint64_t v2 = v2;
    for (unint64_t i = (void **)(*((void *)&xmmword_100A10460 + 1) + 16);
          !*((unsigned char *)i - 14) || *((unsigned __int16 *)i - 8) != a1;
          i += 4)
    {
      if (!--v2) {
        return;
      }
    }
    *((unsigned char *)i - 14) = 0;
    if (*i)
    {
      sub_100023010(*i);
      void *i = 0;
    }
  }
}

void sub_100250D74(uint64_t a1, unsigned __int8 *a2, unsigned int a3)
{
  uint64_t v3 = *(unsigned __int8 *)xmmword_100A10460;
  if (!*(unsigned char *)xmmword_100A10460)
  {
LABEL_6:
    if (sub_100058654())
    {
      sub_100056E24((uint64_t)"Client not allocated", v6, v7, v8, v9, v10, v11, v12, (uint64_t)ptr);
      uint64_t v13 = sub_100050B4C(0x35u);
      if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
      {
LABEL_8:
        sub_100744F6C();
        return;
      }
    }
    return;
  }
  uint64_t v5 = *((void *)&xmmword_100A10460 + 1) + 8;
  while (!*(unsigned char *)(v5 - 6) || *(unsigned __int16 *)(v5 - 8) != a1)
  {
    v5 += 32;
    if (!--v3) {
      goto LABEL_6;
    }
  }
  if (*(void *)(v5 + 8))
  {
    if (sub_100058654())
    {
      sub_100056E24((uint64_t)"Client sent overlapping request", v14, v15, v16, v17, v18, v19, v20, (uint64_t)ptr);
      uint64_t v21 = sub_100050B4C(0x35u);
      if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR)) {
        goto LABEL_8;
      }
    }
    return;
  }
  if (a3 < 5) {
    return;
  }
  if (!a2) {
    sub_10014327C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpserver.c", 1591, "requestBuffer");
  }
  uint64_t v36 = 0;
  long long v37 = a2;
  __int16 v38 = a3;
  __int16 v39 = a3;
  int v22 = *a2;
  unsigned int v23 = bswap32(*(unsigned __int16 *)(a2 + 1)) >> 16;
  int v40 = 65541;
  ptr = 0;
  if (a3 - 5 != bswap32(*(unsigned __int16 *)(a2 + 3)) >> 16)
  {
    int v25 = 804;
LABEL_25:
    int v24 = sub_10025136C(v25, v23, (uint64_t)&ptr);
    goto LABEL_26;
  }
  if (v22 == 6)
  {
    int v24 = sub_100251F5C(v23, (uint64_t)&v37, (uint64_t)&ptr, *(_WORD *)(v5 - 2), a1);
    goto LABEL_26;
  }
  if (v22 == 4)
  {
    int v24 = sub_100251CAC(v23, (uint64_t)&v37, (uint64_t)&ptr, *(_WORD *)(v5 - 2), a1);
    goto LABEL_26;
  }
  if (v22 != 2)
  {
    int v25 = 803;
    goto LABEL_25;
  }
  int v24 = sub_100251600(v23, (uint64_t)&v37, (uint64_t)&ptr, *(unsigned __int16 *)(v5 - 2), a1);
LABEL_26:
  if (v24) {
    goto LABEL_39;
  }
  int v34 = sub_1001DE4D0((uint64_t)sub_10025229C, a1, 0, (char *)ptr, WORD1(v36));
  if (!v34) {
    return;
  }
  if (v34 != 410)
  {
LABEL_39:
    if (sub_100058654())
    {
      sub_100056E24((uint64_t)"IncomingRequest_CB failed", v26, v27, v28, v29, v30, v31, v32, (uint64_t)ptr);
      uint64_t v33 = sub_100050B4C(0x35u);
      if (os_log_type_enabled(v33, OS_LOG_TYPE_ERROR)) {
        sub_100744FE4();
      }
    }
    sub_100023010(ptr);
  }
  else
  {
    if (*(void *)(v5 + 8)) {
      sub_10025B8C0();
    }
    *(void *)(v5 + 8) = ptr;
    *(_WORD *)uint64_t v5 = WORD1(v36);
  }
}

void sub_100250FFC(uint64_t a1, int *a2, uint64_t a3)
{
  unsigned int v3 = a3;
  long long v39 = 0u;
  long long v40 = 0u;
  uint64_t v4 = *(unsigned __int8 *)xmmword_100A10460;
  if (!*(unsigned char *)xmmword_100A10460) {
    goto LABEL_5;
  }
  uint64_t v6 = *((void *)&xmmword_100A10460 + 1);
  while (*(unsigned char *)(v6 + 2))
  {
    v6 += 32;
    if (!--v4) {
      goto LABEL_5;
    }
  }
  if (qword_100A10470 && *(void *)qword_100A10470)
  {
    int v7 = (*(uint64_t (**)(int *, uint64_t))qword_100A10470)(a2, a3);
    __int16 v8 = *((_WORD *)a2 + 2);
    *(_DWORD *)(v6 + 24) = *a2;
    *(_WORD *)(v6 + 28) = v8;
    if (v7 != 845)
    {
      if (v7 == 847)
      {
        *(_WORD *)uint64_t v6 = v3;
        *(unsigned char *)(v6 + 2) = 1;
        if (sub_100058654())
        {
          sub_100056E24((uint64_t)"Stalled incoming SDP request for cid=%d", v9, v10, v11, v12, v13, v14, v15, v3);
          uint64_t v16 = sub_100050B4C(0x35u);
          if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)long long buf = 136446210;
            uint64_t v42 = sub_100050714();
            _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
          }
        }
        return;
      }
LABEL_5:
      sub_1001E0320((uint64_t)sub_100250BEC, (uint64_t)sub_100250CA0, (uint64_t)sub_100250D74, v3, (uint64_t)&v39, 0, (uint64_t)&unk_1007BAC80);
      return;
    }
  }
  else
  {
    int v17 = *a2;
    *(_WORD *)(v6 + 28) = *((_WORD *)a2 + 2);
    *(_DWORD *)(v6 + 24) = v17;
  }
  if (sub_100058654())
  {
    sub_100056E24((uint64_t)"Setting up connection parameters for the server connection", v18, v19, v20, v21, v22, v23, v24, v38);
    int v25 = sub_100050B4C(0x35u);
    if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 136446210;
      uint64_t v42 = sub_100050714();
      _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
    }
  }
  *(_WORD *)uint64_t v6 = v3;
  *(unsigned char *)(v6 + 2) = 1;
  unsigned int v26 = *(unsigned __int16 *)(xmmword_100A10460 + 4);
  *(_WORD *)(v6 + 4) = v26;
  if (v26 >= 0x81)
  {
    if (v26 <= *(unsigned __int16 *)(sub_10025B218(0x28u) + 8)) {
      goto LABEL_23;
    }
    __int16 v27 = *(_WORD *)(sub_10025B218(0x28u) + 8);
  }
  else
  {
    __int16 v27 = 128;
  }
  *(_WORD *)(v6 + 4) = v27;
LABEL_23:
  long long v39 = 0u;
  long long v40 = 0u;
  LOWORD(v39) = *(_WORD *)(v6 + 4);
  *(_DWORD *)((char *)&v39 + 2) = 327745535;
  WORD3(v39) = 772;
  BYTE13(v39) = 0;
  uint64_t v28 = sub_1001E0320((uint64_t)sub_100250BEC, (uint64_t)sub_100250CA0, (uint64_t)sub_100250D74, v3, (uint64_t)&v39, 1, (uint64_t)&unk_1007BAC80);
  if (v28)
  {
    uint64_t v29 = v28;
    if (sub_100058654())
    {
      sub_100056E24((uint64_t)"SDPServer: L2CAP failed to complete the connection %!", v30, v31, v32, v33, v34, v35, v36, v29);
      long long v37 = sub_100050B4C(0x35u);
      if (os_log_type_enabled(v37, OS_LOG_TYPE_ERROR)) {
        sub_100744F6C();
      }
    }
    *(unsigned char *)(v6 + 2) = 0;
  }
}

uint64_t sub_100251324(uint64_t result)
{
  uint64_t v1 = *(unsigned __int8 *)xmmword_100A10460;
  if (*(unsigned char *)xmmword_100A10460)
  {
    for (unint64_t i = (unsigned char *)(*((void *)&xmmword_100A10460 + 1) + 2);
          !*i || *((unsigned __int16 *)i - 1) != result;
          i += 32)
    {
      if (!--v1) {
        return result;
      }
    }
    return sub_1001E121C(result, 436);
  }
  return result;
}

uint64_t sub_10025136C(int a1, __int16 a2, uint64_t a3)
{
  if ((a1 - 807) > 0xFFFFFFF9)
  {
    __int16 v13 = a1 - 800;
  }
  else
  {
    if (sub_100058654())
    {
      sub_100056E24((uint64_t)"ComposeErrorResponse, generic error", v5, v6, v7, v8, v9, v10, v11, v23);
      uint64_t v12 = sub_100050B4C(0x35u);
      if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR)) {
        sub_100744F6C();
      }
    }
    __int16 v13 = 6;
  }
  uint64_t v14 = sub_100022FE8(7uLL);
  if (!v14) {
    return 106;
  }
  *(void *)a3 = v14;
  *(_WORD *)(a3 + 8) = 7;
  *(_WORD *)(a3 + 14) = 2;
  *(_DWORD *)(a3 + 10) = 65543;
  *uint64_t v14 = 1;
  if (*(unsigned char *)(a3 + 15))
  {
    sub_10025A794((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpserver.c");
    goto LABEL_22;
  }
  uint64_t v15 = *(unsigned __int16 *)(a3 + 12);
  if (*(unsigned __int16 *)(a3 + 10) - (int)v15 <= 1)
  {
LABEL_22:
    uint64_t v20 = "ByteStream_NumReadBytesAvail(*responseBS) >= 2";
    goto LABEL_24;
  }
  if (*(unsigned char *)(a3 + 14) != 2)
  {
    uint64_t v20 = "(*responseBS).__RWFlag == BYTESTREAM_WRITE";
LABEL_24:
    sub_10014327C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpserver.c", 655, v20);
  }
  *(unsigned char *)(*(void *)a3 + v15 + 1) = a2;
  *(unsigned char *)(*(void *)a3 + *(unsigned __int16 *)(a3 + 12)) = HIBYTE(a2);
  unsigned __int16 v16 = *(_WORD *)(a3 + 12) + 2;
  *(_WORD *)(a3 + 12) = v16;
  if (*(unsigned char *)(a3 + 15))
  {
    sub_10025A794((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpserver.c");
    goto LABEL_26;
  }
  if (*(unsigned __int16 *)(a3 + 10) - v16 <= 1)
  {
LABEL_26:
    uint64_t v21 = "ByteStream_NumReadBytesAvail(*responseBS) >= 2";
    goto LABEL_28;
  }
  if (*(unsigned char *)(a3 + 14) != 2)
  {
    uint64_t v21 = "(*responseBS).__RWFlag == BYTESTREAM_WRITE";
LABEL_28:
    sub_10014327C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpserver.c", 656, v21);
  }
  *(unsigned char *)(*(void *)a3 + v16 + 1) = 2;
  *(unsigned char *)(*(void *)a3 + *(unsigned __int16 *)(a3 + 12)) = 0;
  unsigned __int16 v17 = *(_WORD *)(a3 + 12) + 2;
  *(_WORD *)(a3 + 12) = v17;
  if (*(unsigned char *)(a3 + 15))
  {
    sub_10025A794((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpserver.c");
    goto LABEL_30;
  }
  if (*(unsigned __int16 *)(a3 + 10) - v17 <= 1)
  {
LABEL_30:
    uint64_t v22 = "ByteStream_NumReadBytesAvail(*responseBS) >= 2";
    goto LABEL_32;
  }
  if (*(unsigned char *)(a3 + 14) != 2)
  {
    uint64_t v22 = "(*responseBS).__RWFlag == BYTESTREAM_WRITE";
LABEL_32:
    sub_10014327C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpserver.c", 657, v22);
  }
  *(unsigned char *)(*(void *)a3 + v17 + 1) = v13;
  *(unsigned char *)(*(void *)a3 + *(unsigned __int16 *)(a3 + 12)) = HIBYTE(v13);
  __int16 v18 = *(_WORD *)(a3 + 12) + 2;
  *(_WORD *)(a3 + 12) = v18;
  if (*(unsigned char *)(a3 + 14) == 2) {
    *(_WORD *)(a3 + 10) = v18;
  }
  uint64_t result = 0;
  *(unsigned char *)(a3 + 14) = 15;
  return result;
}

uint64_t sub_100251600(__int16 a1, uint64_t a2, uint64_t a3, int a4, unsigned int a5)
{
  uint64_t v60 = 0;
  uint64_t v61 = 0;
  int v58 = 0;
  int v59 = 0;
  uint64_t v57 = 0;
  sub_1001DDA80(a5, &v57);
  uint64_t v9 = sub_100252370(a2, (uint64_t)&v60);
  if (v9)
  {
    uint64_t v10 = v9;
    if (sub_100058654())
    {
      sub_100056E24((uint64_t)"SDPServer: ServiceSearchRequest bad UUID list", v11, v12, v13, v14, v15, v16, v17, v55);
      __int16 v18 = sub_100050B4C(0x35u);
      if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR)) {
        sub_100744F6C();
      }
    }
    goto LABEL_29;
  }
  if (*(unsigned char *)(a2 + 14) != 1) {
    sub_10014327C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpserver.c", 807, "(*requestBS).__RWFlag == BYTESTREAM_READ");
  }
  if (*(unsigned char *)(a2 + 15))
  {
    sub_10025A794((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpserver.c");
LABEL_27:
    *(unsigned char *)(a2 + 15) = 1;
    goto LABEL_28;
  }
  uint64_t v19 = *(unsigned __int16 *)(a2 + 12);
  if (*(unsigned __int16 *)(a2 + 10) - (int)v19 <= 1) {
    goto LABEL_27;
  }
  uint64_t v20 = (unsigned __int8 *)(*(void *)a2 + v19);
  int v21 = v20[1];
  unsigned int v22 = v21 | (*v20 << 8);
  *(_WORD *)(a2 + 12) = v19 + 2;
  if (!v22)
  {
LABEL_28:
    uint64_t v10 = 803;
LABEL_29:
    if (sub_100058654())
    {
      sub_100056E24((uint64_t)"Error response to service search request: %!", v32, v33, v34, v35, v36, v37, v38, v10);
      long long v39 = sub_100050B4C(0x35u);
      if (os_log_type_enabled(v39, OS_LOG_TYPE_ERROR)) {
        sub_100744F6C();
      }
    }
    if (*(void *)a3) {
      sub_100023010(*(void **)a3);
    }
    sub_10017B680((unsigned __int8 *)&v60);
    return sub_10025136C(v10, a1, a3);
  }
  uint64_t v10 = sub_1002523E0((uint64_t *)a2, &v58);
  if (v10) {
    goto LABEL_29;
  }
  unsigned __int16 v23 = v22 >= (unsigned __int16)((a4 + 262132) >> 2) ? (a4 + 262132) >> 2 : v22;
  uint64_t v10 = sub_1002524E0(a3, (4 * v23 + 4) & 0xFFFC);
  if (v10) {
    goto LABEL_29;
  }
  if (*(unsigned char *)(a3 + 15))
  {
    sub_10025A794((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpserver.c");
LABEL_64:
    sub_10014327C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpserver.c", 842, "ByteStream_NumReadBytesAvail(*responseBS) >= (2 * sizeof(uint16_t))");
  }
  uint64_t v24 = *(unsigned __int16 *)(a3 + 12);
  if ((unint64_t)*(unsigned __int16 *)(a3 + 10) - v24 <= 3) {
    goto LABEL_64;
  }
  unsigned int v25 = 0;
  unsigned __int16 v26 = 0;
  __int16 v27 = 0;
  uint64_t v56 = *(unsigned __int16 *)(a3 + 12);
  *(_WORD *)(a3 + 12) = v24 + 4;
  unsigned int v28 = (unsigned __int16)v58;
  while (1)
  {
    uint64_t v29 = sub_10024E6B4(v61, WORD1(v60), (_WORD *)&v58 + 1, &v59, v57);
    if (v29) {
      break;
    }
    char v30 = HIBYTE(v26);
    if (HIWORD(v58) > v28 && v26 < v23)
    {
      if (*(unsigned char *)(a3 + 15))
      {
        sub_10025A794((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpserver.c");
LABEL_60:
        uint64_t v49 = "ByteStream_NumReadBytesAvail(*responseBS) >= 4";
LABEL_62:
        sub_10014327C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpserver.c", 862, v49);
      }
      uint64_t v31 = *(unsigned __int16 *)(a3 + 12);
      if (*(unsigned __int16 *)(a3 + 10) - (int)v31 <= 3) {
        goto LABEL_60;
      }
      if (*(unsigned char *)(a3 + 14) != 2)
      {
        uint64_t v49 = "(*responseBS).__RWFlag == BYTESTREAM_WRITE";
        goto LABEL_62;
      }
      *(unsigned char *)(*(void *)a3 + v31 + 3) = v59;
      *(unsigned char *)(*(void *)a3 + *(unsigned __int16 *)(a3 + 12) + 2) = BYTE1(v59);
      *(unsigned char *)(*(void *)a3 + *(unsigned __int16 *)(a3 + 12) + 1) = BYTE2(v59);
      *(unsigned char *)(*(void *)a3 + *(unsigned __int16 *)(a3 + 12)) = HIBYTE(v59);
      *(_WORD *)(a3 + 12) += 4;
      ++v26;
      unsigned int v25 = HIWORD(v58);
      char v30 = HIBYTE(v26);
    }
    if (v22 <= (unsigned __int16)++v27) {
      goto LABEL_37;
    }
  }
  uint64_t v10 = v29;
  if (v29 != 823) {
    goto LABEL_29;
  }
  char v30 = HIBYTE(v26);
  LOBYTE(v21) = v27;
LABEL_37:
  if (HIWORD(v58) > v25)
  {
    if (*(unsigned char *)(a3 + 15))
    {
      sub_10025A794((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpserver.c");
    }
    else
    {
      uint64_t v41 = *(unsigned __int16 *)(a3 + 12);
      if (*(unsigned __int16 *)(a3 + 10) > v41)
      {
        if (*(unsigned char *)(a3 + 14) == 2)
        {
          uint64_t v42 = *(unsigned char **)a3;
          *(_WORD *)(a3 + 12) = v41 + 1;
          v42[v41] = 2;
          if (*(unsigned char *)(a3 + 15))
          {
            sub_10025A794((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpserver.c");
          }
          else
          {
            uint64_t v43 = *(unsigned __int16 *)(a3 + 12);
            if (*(unsigned __int16 *)(a3 + 10) - (int)v43 > 1)
            {
              if (*(unsigned char *)(a3 + 14) == 2)
              {
                *(unsigned char *)(*(void *)a3 + v43 + 1) = v25;
                *(unsigned char *)(*(void *)a3 + *(unsigned __int16 *)(a3 + 12)) = BYTE1(v25);
                unsigned __int16 v44 = *(_WORD *)(a3 + 12) + 2;
                *(_WORD *)(a3 + 12) = v44;
                goto LABEL_49;
              }
              int v53 = "(*responseBS).__RWFlag == BYTESTREAM_WRITE";
LABEL_82:
              sub_10014327C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpserver.c", 877, v53);
            }
          }
          int v53 = "ByteStream_NumReadBytesAvail(*responseBS) >= 2";
          goto LABEL_82;
        }
        unsigned __int16 v52 = "(*responseBS).__RWFlag == BYTESTREAM_WRITE";
LABEL_78:
        sub_10014327C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpserver.c", 876, v52);
      }
    }
    unsigned __int16 v52 = "ByteStream_NumReadBytesAvail(*responseBS) >= 1";
    goto LABEL_78;
  }
  if (*(unsigned char *)(a3 + 15))
  {
    sub_10025A794((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpserver.c");
    goto LABEL_84;
  }
  uint64_t v45 = *(unsigned __int16 *)(a3 + 12);
  if (*(unsigned __int16 *)(a3 + 10) <= v45)
  {
LABEL_84:
    unsigned __int16 v54 = "ByteStream_NumReadBytesAvail(*responseBS) >= 1";
    goto LABEL_86;
  }
  if (*(unsigned char *)(a3 + 14) != 2)
  {
    unsigned __int16 v54 = "(*responseBS).__RWFlag == BYTESTREAM_WRITE";
LABEL_86:
    sub_10014327C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpserver.c", 879, v54);
  }
  int v46 = *(unsigned char **)a3;
  *(_WORD *)(a3 + 12) = v45 + 1;
  v46[v45] = 0;
  unsigned __int16 v44 = *(_WORD *)(a3 + 12);
LABEL_49:
  unsigned int v47 = *(unsigned __int16 *)(a3 + 10);
  if (v56 > v47) {
    sub_10014327C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpserver.c", 885, "(size_t)(paramPos) <= (size_t)((*responseBS).__size)");
  }
  *(_WORD *)(a3 + 12) = v56;
  if (*(unsigned char *)(a3 + 15))
  {
    sub_10025A794((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpserver.c");
    goto LABEL_67;
  }
  if ((int)(v47 - v56) <= 1)
  {
LABEL_67:
    int v50 = "ByteStream_NumReadBytesAvail(*responseBS) >= 2";
    goto LABEL_69;
  }
  if (*(unsigned char *)(a3 + 14) != 2)
  {
    int v50 = "(*responseBS).__RWFlag == BYTESTREAM_WRITE";
LABEL_69:
    sub_10014327C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpserver.c", 886, v50);
  }
  *(unsigned char *)(*(void *)a3 + v56 + 1) = v21;
  *(unsigned char *)(*(void *)a3 + *(unsigned __int16 *)(a3 + 12)) = HIBYTE(v27);
  unsigned __int16 v48 = *(_WORD *)(a3 + 12) + 2;
  *(_WORD *)(a3 + 12) = v48;
  if (*(unsigned char *)(a3 + 15))
  {
    sub_10025A794((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpserver.c");
    goto LABEL_71;
  }
  if (*(unsigned __int16 *)(a3 + 10) - v48 <= 1)
  {
LABEL_71:
    unsigned int v51 = "ByteStream_NumReadBytesAvail(*responseBS) >= 2";
    goto LABEL_73;
  }
  if (*(unsigned char *)(a3 + 14) != 2)
  {
    unsigned int v51 = "(*responseBS).__RWFlag == BYTESTREAM_WRITE";
LABEL_73:
    sub_10014327C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpserver.c", 887, v51);
  }
  *(unsigned char *)(*(void *)a3 + v48 + 1) = v26;
  *(unsigned char *)(*(void *)a3 + *(unsigned __int16 *)(a3 + 12)) = v30;
  *(_WORD *)(a3 + 12) += 2;
  if (*(unsigned __int16 *)(a3 + 10) < v44) {
    sub_10014327C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpserver.c", 888, "(size_t)(contPos) <= (size_t)((*responseBS).__size)");
  }
  *(_WORD *)(a3 + 12) = v44;
  sub_1002525CC(a3, 3, a1);
  sub_10017B680((unsigned __int8 *)&v60);
  return 0;
}

uint64_t sub_100251CAC(__int16 a1, uint64_t a2, uint64_t a3, __int16 a4, unsigned int a5)
{
  v33[0] = 0;
  v33[1] = 0;
  __int16 v31 = 0;
  if (*(unsigned char *)(a2 + 15))
  {
    sub_10025A794((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpserver.c");
LABEL_4:
    uint64_t v10 = 804;
    goto LABEL_5;
  }
  uint64_t v8 = *(unsigned __int16 *)(a2 + 10);
  uint64_t v9 = *(unsigned __int16 *)(a2 + 12);
  if ((unint64_t)(v8 - v9) < 6) {
    goto LABEL_4;
  }
  if (*(unsigned char *)(a2 + 14) != 1) {
    sub_10014327C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpserver.c", 1228, "(*requestBS).__RWFlag == BYTESTREAM_READ");
  }
  if ((int)v8 - (int)v9 <= 3)
  {
    *(unsigned char *)(a2 + 15) = 1;
    sub_10025A794((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpserver.c");
    goto LABEL_26;
  }
  unsigned int v20 = *(_DWORD *)(*(void *)a2 + v9);
  *(_WORD *)(a2 + 12) = v9 + 4;
  if ((int)(v8 - (unsigned __int16)(v9 + 4)) <= 1)
  {
LABEL_26:
    *(unsigned char *)(a2 + 15) = 1;
    goto LABEL_27;
  }
  unsigned int v21 = bswap32(*(unsigned __int16 *)(*(void *)a2 + (unsigned __int16)(v9 + 4))) >> 16;
  *(_WORD *)(a2 + 12) = v9 + 6;
  if (v21 < 7)
  {
LABEL_27:
    uint64_t v10 = 803;
    goto LABEL_5;
  }
  uint64_t v10 = sub_1002527C0(a2, (uint64_t)v33);
  if (v10) {
    goto LABEL_5;
  }
  __int16 v32 = 0;
  uint64_t v10 = sub_1002523E0((uint64_t *)a2, &v32);
  if (v10) {
    goto LABEL_5;
  }
  unsigned __int16 v30 = 0;
  uint64_t v10 = sub_100252840(a3, v21, a4, &v30);
  if (v10) {
    goto LABEL_5;
  }
  uint64_t v24 = bswap32(v20);
  __int16 v25 = v32;
  if (!v32)
  {
    unsigned __int16 v29 = 0;
    uint64_t v28 = sub_100252924(v24, (uint64_t)v33, &v29, a5);
    if (v28)
    {
      uint64_t v10 = v28;
      goto LABEL_5;
    }
    sub_100252A1C((uint64_t *)a3, v29, &v32);
    __int16 v25 = v32;
  }
  __int16 v31 = v25;
  __int16 v26 = *(_WORD *)(a3 + 12);
  if (sub_100252C7C(v24, (uint64_t)v33, &v31, a3, a5)) {
    goto LABEL_22;
  }
  unsigned __int16 v27 = *(_WORD *)(a3 + 12) - v26 + v25;
  if (!v27)
  {
    sub_10025B8C0();
LABEL_22:
    unsigned __int16 v27 = 0;
  }
  if (!v31)
  {
    sub_100252DA0((uint64_t *)a3, v30, v27);
    sub_1002525CC(a3, 5, a1);
    sub_10017B680((unsigned __int8 *)v33);
    return 0;
  }
  uint64_t v10 = 805;
LABEL_5:
  if (sub_100058654())
  {
    sub_100056E24((uint64_t)"Error response to service attribute request: %!", v11, v12, v13, v14, v15, v16, v17, v10);
    __int16 v18 = sub_100050B4C(0x35u);
    if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR)) {
      sub_100744F6C();
    }
  }
  if (*(void *)a3) {
    sub_100023010(*(void **)a3);
  }
  sub_10017B680((unsigned __int8 *)v33);
  return sub_10025136C(v10, a1, a3);
}

uint64_t sub_100251F5C(__int16 a1, uint64_t a2, uint64_t a3, __int16 a4, unsigned int a5)
{
  v37[0] = 0;
  v37[1] = 0;
  uint64_t v35 = 0;
  uint64_t v36 = 0;
  int v34 = 0;
  uint64_t v31 = 0;
  sub_1001DDA80(a5, &v31);
  uint64_t v10 = sub_100252370(a2, (uint64_t)&v35);
  if (v10) {
    goto LABEL_20;
  }
  if (*(unsigned char *)(a2 + 14) != 1) {
    sub_10014327C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpserver.c", 1371, "(*requestBS).__RWFlag == BYTESTREAM_READ");
  }
  if (*(unsigned char *)(a2 + 15))
  {
    sub_10025A794((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpserver.c");
LABEL_18:
    *(unsigned char *)(a2 + 15) = 1;
    goto LABEL_19;
  }
  uint64_t v11 = *(unsigned __int16 *)(a2 + 12);
  if (*(unsigned __int16 *)(a2 + 10) - (int)v11 <= 1) {
    goto LABEL_18;
  }
  unsigned int v12 = bswap32(*(unsigned __int16 *)(*(void *)a2 + v11)) >> 16;
  *(_WORD *)(a2 + 12) = v11 + 2;
  if (v12 < 7)
  {
LABEL_19:
    uint64_t v10 = 803;
    goto LABEL_20;
  }
  uint64_t v10 = sub_1002527C0(a2, (uint64_t)v37);
  if (!v10)
  {
    unsigned __int16 v33 = 0;
    uint64_t v10 = sub_1002523E0((uint64_t *)a2, &v33);
    if (!v10)
    {
      unsigned __int16 v32 = 0;
      uint64_t v10 = sub_100252840(a3, v12, a4, &v32);
      if (!v10)
      {
        unsigned __int16 v13 = v33;
        if (!v33)
        {
          unsigned int v30 = 0;
          unsigned __int16 v29 = 0;
          HIWORD(v34) = 0;
          while (1)
          {
            uint64_t v27 = sub_10024E6B4(v36, WORD1(v35), (_WORD *)&v34 + 1, &v30, v31);
            if (v27) {
              break;
            }
            uint64_t v16 = sub_100252924(v30, (uint64_t)v37, &v29, a5);
            if (v16)
            {
LABEL_37:
              uint64_t v10 = v16;
              goto LABEL_20;
            }
            if (v29 <= 0xFFu) {
              __int16 v28 = 2;
            }
            else {
              __int16 v28 = 3;
            }
            v13 += v29 + v28;
          }
          uint64_t v10 = v27;
          if (v27 != 823) {
            goto LABEL_20;
          }
          sub_100252A1C((uint64_t *)a3, v13, (__int16 *)&v33);
          unsigned __int16 v13 = v33;
        }
        int v34 = v13;
        __int16 v14 = *(_WORD *)(a3 + 12);
        do
        {
          unsigned int v30 = 0;
          unsigned __int16 v29 = 0;
          uint64_t v15 = sub_10024E6B4(v36, WORD1(v35), (_WORD *)&v34 + 1, &v30, v31);
          if (v15)
          {
            uint64_t v10 = v15;
            if (v15 != 823) {
              goto LABEL_20;
            }
            goto LABEL_34;
          }
          uint64_t v16 = sub_100252924(v30, (uint64_t)v37, &v29, a5);
          if (v16) {
            goto LABEL_37;
          }
        }
        while (sub_100252A1C((uint64_t *)a3, v29, (__int16 *)&v34)
             && (sub_100252C7C(v30, (uint64_t)v37, &v34, a3, a5) & 1) != 0);
        unsigned __int16 v17 = *(_WORD *)(a3 + 12) - v14 + v13;
        if (v17) {
          goto LABEL_35;
        }
        sub_10025B8C0();
LABEL_34:
        unsigned __int16 v17 = 0;
LABEL_35:
        if (!(_WORD)v34)
        {
          sub_100252DA0((uint64_t *)a3, v32, v17);
          sub_1002525CC(a3, 7, a1);
          sub_10017B680((unsigned __int8 *)&v35);
          sub_10017B680((unsigned __int8 *)v37);
          return 0;
        }
        uint64_t v10 = 805;
      }
    }
  }
LABEL_20:
  if (sub_100058654())
  {
    sub_100056E24((uint64_t)"Error response to service search request: %!", v18, v19, v20, v21, v22, v23, v24, v10);
    __int16 v25 = sub_100050B4C(0x35u);
    if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR)) {
      sub_100744F6C();
    }
  }
  if (*(void *)a3) {
    sub_100023010(*(void **)a3);
  }
  sub_10017B680((unsigned __int8 *)&v35);
  sub_10017B680((unsigned __int8 *)v37);
  return sub_10025136C(v10, a1, a3);
}

void sub_10025229C(uint64_t a1, void *ptr, uint64_t a3, int a4)
{
  uint64_t v6 = *(unsigned __int8 *)xmmword_100A10460;
  if (*(unsigned char *)xmmword_100A10460)
  {
    uint64_t v7 = (unsigned __int16 *)*((void *)&xmmword_100A10460 + 1);
    while (!*((unsigned char *)v7 + 2) || *v7 != a1)
    {
      v7 += 16;
      if (!--v6) {
        goto LABEL_6;
      }
    }
  }
  else
  {
LABEL_6:
    uint64_t v7 = 0;
  }
  sub_100023010(ptr);
  if (a4 || !v7)
  {
    if (!a4) {
      return;
    }
  }
  else
  {
    uint64_t v8 = (char *)*((void *)v7 + 2);
    if (!v8) {
      return;
    }
    if (!sub_1001DE4D0((uint64_t)sub_10025229C, a1, 0, v8, v7[4]))
    {
      *((void *)v7 + 2) = 0;
      return;
    }
  }

  sub_100251324(a1);
}

uint64_t sub_100252370(uint64_t a1, uint64_t a2)
{
  uint64_t result = sub_10017B5D4(a1, (unsigned __int8 *)a2);
  if (!result)
  {
    if (*(unsigned char *)a2 == 6)
    {
      uint64_t v4 = *(unsigned __int16 *)(a2 + 2);
      if ((v4 - 13) >= 0xFFFFFFF4)
      {
        uint64_t v5 = *(unsigned __int8 **)(a2 + 8);
        while (1)
        {
          int v6 = *v5;
          v5 += 16;
          if (v6 != 3) {
            break;
          }
          if (!--v4) {
            return 0;
          }
        }
      }
    }
    sub_10017B680((unsigned __int8 *)a2);
    return 803;
  }
  return result;
}

uint64_t sub_1002523E0(uint64_t *a1, _WORD *a2)
{
  *a2 = 0;
  if (*((unsigned char *)a1 + 14) != 1) {
    sub_10014327C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpserver.c", 726, "(*requestBS).__RWFlag == BYTESTREAM_READ");
  }
  if (*((unsigned char *)a1 + 15))
  {
    sub_10025A794((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpserver.c");
LABEL_8:
    *((unsigned char *)a1 + 15) = 1;
    return 804;
  }
  unsigned int v3 = *((unsigned __int16 *)a1 + 5);
  uint64_t v4 = *((unsigned __int16 *)a1 + 6);
  if (v3 <= v4) {
    goto LABEL_8;
  }
  uint64_t v5 = *a1;
  uint64_t v6 = v4 + 1;
  *((_WORD *)a1 + 6) = v4 + 1;
  if (!*(unsigned char *)(v5 + v4)
    || ((int v7 = v3 - (unsigned __int16)v6, v7 >= 2)
      ? (*a2 = bswap32(*(unsigned __int16 *)(v5 + v6)) >> 16,
         LOWORD(v6) = *((_WORD *)a1 + 6) + 2,
         *((_WORD *)a1 + 6) = v6)
      : (*((unsigned char *)a1 + 15) = 1),
        *a2 ? (uint64_t result = 804) : (uint64_t result = 805),
        *a2 && v7 >= 2))
  {
    if (*((unsigned __int16 *)a1 + 5) == (unsigned __int16)v6) {
      return 0;
    }
    else {
      return 804;
    }
  }
  return result;
}

uint64_t sub_1002524E0(uint64_t a1, __int16 a2)
{
  unsigned __int16 v3 = a2 + 8;
  uint64_t v4 = sub_100022FE8((unsigned __int16)(a2 + 8));
  if (v4)
  {
    if (!v3) {
      sub_10014327C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpserver.c", 607, "(allocSize) > 0");
    }
    *(void *)a1 = v4;
    *(_WORD *)(a1 + 8) = v3;
    *(_DWORD *)(a1 + 12) = 0x20000;
    *(_WORD *)(a1 + 10) = v3;
    if (v3 <= 4u) {
      sub_10014327C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpserver.c", 612, "ByteStream_NumReadBytesAvail(*responseBS) >= (5)");
    }
    uint64_t result = 0;
    *(_WORD *)(a1 + 12) = 5;
  }
  else
  {
    if (sub_100058654())
    {
      sub_100056E24((uint64_t)"CreateResponsePDU, OI_Malloc (%d) failed", v6, v7, v8, v9, v10, v11, v12, v3);
      unsigned __int16 v13 = sub_100050B4C(0x35u);
      if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR)) {
        sub_100744F6C();
      }
    }
    return 806;
  }
  return result;
}

uint64_t sub_1002525CC(uint64_t result, char a2, __int16 a3)
{
  unsigned int v3 = *(unsigned __int16 *)(result + 12);
  *(_WORD *)(result + 12) = 0;
  if (*(unsigned char *)(result + 15))
  {
    sub_10025A794((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpserver.c");
    goto LABEL_15;
  }
  if (!*(_WORD *)(result + 10))
  {
LABEL_15:
    uint64_t v7 = "ByteStream_NumReadBytesAvail(*responseBS) >= 1";
    goto LABEL_17;
  }
  if (*(unsigned char *)(result + 14) != 2)
  {
    uint64_t v7 = "(*responseBS).__RWFlag == BYTESTREAM_WRITE";
LABEL_17:
    sub_10014327C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpserver.c", 568, v7);
  }
  uint64_t v4 = *(unsigned char **)result;
  *(_WORD *)(result + 12) = 1;
  *uint64_t v4 = a2;
  if (*(unsigned char *)(result + 15))
  {
    sub_10025A794((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpserver.c");
    goto LABEL_19;
  }
  uint64_t v5 = *(unsigned __int16 *)(result + 12);
  if (*(unsigned __int16 *)(result + 10) - (int)v5 <= 1)
  {
LABEL_19:
    uint64_t v8 = "ByteStream_NumReadBytesAvail(*responseBS) >= 2";
    goto LABEL_21;
  }
  if (*(unsigned char *)(result + 14) != 2)
  {
    uint64_t v8 = "(*responseBS).__RWFlag == BYTESTREAM_WRITE";
LABEL_21:
    sub_10014327C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpserver.c", 569, v8);
  }
  *(unsigned char *)(*(void *)result + v5 + 1) = a3;
  *(unsigned char *)(*(void *)result + *(unsigned __int16 *)(result + 12)) = HIBYTE(a3);
  unsigned __int16 v6 = *(_WORD *)(result + 12) + 2;
  *(_WORD *)(result + 12) = v6;
  if (*(unsigned char *)(result + 15))
  {
    sub_10025A794((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpserver.c");
    goto LABEL_23;
  }
  if (*(unsigned __int16 *)(result + 10) - v6 <= 1)
  {
LABEL_23:
    uint64_t v9 = "ByteStream_NumReadBytesAvail(*responseBS) >= 2";
    goto LABEL_25;
  }
  if (*(unsigned char *)(result + 14) != 2)
  {
    uint64_t v9 = "(*responseBS).__RWFlag == BYTESTREAM_WRITE";
LABEL_25:
    sub_10014327C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpserver.c", 570, v9);
  }
  *(unsigned char *)(*(void *)result + v6 + 1) = v3 - 5;
  *(unsigned char *)(*(void *)result + *(unsigned __int16 *)(result + 12)) = (unsigned __int16)(v3 - 5) >> 8;
  *(_WORD *)(result + 12) += 2;
  if (v3 > *(unsigned __int16 *)(result + 10)) {
    sub_10014327C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpserver.c", 575, "(size_t)(pos) <= (size_t)((*responseBS).__size)");
  }
  *(_WORD *)(result + 12) = v3;
  if (*(unsigned char *)(result + 14) == 2) {
    *(_WORD *)(result + 10) = v3;
  }
  *(unsigned char *)(result + 14) = 15;
  return result;
}

uint64_t sub_1002527C0(uint64_t a1, uint64_t a2)
{
  uint64_t result = sub_10017B5D4(a1, (unsigned __int8 *)a2);
  if (!result)
  {
    if (*(unsigned char *)a2 == 6)
    {
      uint64_t v4 = *(unsigned __int16 *)(a2 + 2);
      if (*(_WORD *)(a2 + 2))
      {
        for (unint64_t i = (unsigned __int16 *)(*(void *)(a2 + 8) + 2); *((unsigned char *)i - 2) == 1; i += 8)
        {
          int v6 = *i;
          if (v6 != 4 && v6 != 2) {
            break;
          }
          if (!--v4) {
            return 0;
          }
        }
      }
    }
    sub_10017B680((unsigned __int8 *)a2);
    return 803;
  }
  return result;
}

uint64_t sub_100252840(uint64_t a1, unsigned int a2, __int16 a3, _WORD *a4)
{
  unsigned int v6 = (unsigned __int16)(a3 - 8);
  if (v6 >= a2) {
    unsigned int v6 = a2;
  }
  if (v6 >= *(unsigned __int16 *)(xmmword_100A10460 + 2)) {
    __int16 v7 = *(_WORD *)(xmmword_100A10460 + 2);
  }
  else {
    __int16 v7 = v6;
  }
  uint64_t result = sub_1002524E0(a1, v7);
  if (!result)
  {
    if (*(unsigned char *)(a1 + 15))
    {
      sub_10025A794((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpserver.c");
    }
    else
    {
      uint64_t v9 = *(unsigned __int16 *)(a1 + 12);
      if ((unint64_t)*(unsigned __int16 *)(a1 + 10) - v9 > 1)
      {
        __int16 v10 = v9 + 2;
        *(_WORD *)(a1 + 12) = v10;
        *a4 = v10;
        unint64_t v11 = *(unsigned __int16 *)(a1 + 10) - 3;
        if (v11 > *(unsigned __int16 *)(a1 + 8) || v11 < *(unsigned __int16 *)(a1 + 12)) {
          sub_10014327C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpserver.c", 1085, "((size - (sizeof(uint8_t) + sizeof(uint16_t))) <= (*responseBS).__trueSize) && ((size - (sizeof(uint8_t) + sizeof(uint16_t))) >= (*responseBS).__pos)");
        }
        *(_WORD *)(a1 + 10) = v11;
        return result;
      }
    }
    sub_10014327C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpserver.c", 1075, "ByteStream_NumReadBytesAvail(*responseBS) >= (sizeof(uint16_t))");
  }
  return result;
}

uint64_t sub_100252924(uint64_t a1, uint64_t a2, _WORD *a3, unsigned int a4)
{
  uint64_t v21 = 0;
  unsigned __int16 v20 = 0;
  *a3 = 0;
  uint64_t v19 = 0;
  sub_1001DDA80(a4, &v19);
  while (1)
  {
    uint64_t v7 = sub_10024F3D8(a1, *(void *)(a2 + 8), *(unsigned __int16 *)(a2 + 2), &v20, (__int16 **)&v21, v19);
    if (v7) {
      break;
    }
    int v8 = sub_100179F4C(v21 + 8);
    if (!v8) {
      return 106;
    }
    *a3 += v8 + 3;
  }
  uint64_t v9 = v7;
  if (v7 == 826) {
    return 0;
  }
  if (sub_100058654())
  {
    sub_100056E24((uint64_t)"Internal SDP error AttributeSearch returned %!", v10, v11, v12, v13, v14, v15, v16, v9);
    unsigned __int16 v17 = sub_100050B4C(0x35u);
    if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR)) {
      sub_100744F6C();
    }
  }
  return v9;
}

uint64_t sub_100252A1C(uint64_t *a1, unsigned int a2, __int16 *a3)
{
  uint64_t v3 = *((unsigned __int16 *)a1 + 6);
  int v4 = *((unsigned __int16 *)a1 + 5) - v3;
  __int16 v5 = *a3;
  if (a2 < 0x100)
  {
    if (*a3)
    {
      __int16 v6 = v5 - 2;
      goto LABEL_6;
    }
    if ((v4 & 0xFFFE) == 0) {
      return 0;
    }
    if (*((unsigned char *)a1 + 15))
    {
      sub_10025A794((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpserver.c");
    }
    else if (v4 > 0)
    {
      if (*((unsigned char *)a1 + 14) == 2)
      {
        uint64_t v10 = *a1;
        *((_WORD *)a1 + 6) = v3 + 1;
        *(unsigned char *)(v10 + v3) = 53;
        if (*((unsigned char *)a1 + 15))
        {
          sub_10025A794((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpserver.c");
        }
        else
        {
          uint64_t v11 = *((unsigned __int16 *)a1 + 6);
          if (*((unsigned __int16 *)a1 + 5) > v11)
          {
            if (*((unsigned char *)a1 + 14) == 2)
            {
              uint64_t v12 = *a1;
              *((_WORD *)a1 + 6) = v11 + 1;
              *(unsigned char *)(v12 + v11) = a2;
              return 1;
            }
            uint64_t v14 = "(*responseBS).__RWFlag == BYTESTREAM_WRITE";
LABEL_33:
            sub_10014327C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpserver.c", 1125, v14);
          }
        }
        uint64_t v14 = "ByteStream_NumReadBytesAvail(*responseBS) >= 1";
        goto LABEL_33;
      }
      uint64_t v13 = "(*responseBS).__RWFlag == BYTESTREAM_WRITE";
LABEL_29:
      sub_10014327C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpserver.c", 1124, v13);
    }
    uint64_t v13 = "ByteStream_NumReadBytesAvail(*responseBS) >= 1";
    goto LABEL_29;
  }
  if (!*a3)
  {
    if ((unsigned __int16)(*((_WORD *)a1 + 5) - v3) >= 3u)
    {
      if (*((unsigned char *)a1 + 15))
      {
        sub_10025A794((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpserver.c");
      }
      else if (v4 > 0)
      {
        if (*((unsigned char *)a1 + 14) == 2)
        {
          uint64_t v8 = *a1;
          *((_WORD *)a1 + 6) = v3 + 1;
          *(unsigned char *)(v8 + v3) = 54;
          if (*((unsigned char *)a1 + 15))
          {
            sub_10025A794((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpserver.c");
          }
          else
          {
            uint64_t v9 = *((unsigned __int16 *)a1 + 6);
            if (*((unsigned __int16 *)a1 + 5) - (int)v9 > 1)
            {
              if (*((unsigned char *)a1 + 14) == 2)
              {
                *(unsigned char *)(*a1 + v9 + 1) = a2;
                *(unsigned char *)(*a1 + *((unsigned __int16 *)a1 + 6)) = BYTE1(a2);
                *((_WORD *)a1 + 6) += 2;
                return 1;
              }
              uint64_t v16 = "(*responseBS).__RWFlag == BYTESTREAM_WRITE";
LABEL_41:
              sub_10014327C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpserver.c", 1115, v16);
            }
          }
          uint64_t v16 = "ByteStream_NumReadBytesAvail(*responseBS) >= 2";
          goto LABEL_41;
        }
        uint64_t v15 = "(*responseBS).__RWFlag == BYTESTREAM_WRITE";
LABEL_37:
        sub_10014327C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpserver.c", 1114, v15);
      }
      uint64_t v15 = "ByteStream_NumReadBytesAvail(*responseBS) >= 1";
      goto LABEL_37;
    }
    return 0;
  }
  __int16 v6 = v5 - 3;
LABEL_6:
  *a3 = v6;
  return 1;
}

uint64_t sub_100252C7C(uint64_t a1, uint64_t a2, _WORD *a3, uint64_t a4, unsigned int a5)
{
  uint64_t v23 = 0;
  long long v22 = xmmword_1007BACB0;
  unsigned __int16 v21 = 0;
  uint64_t v20 = 0;
  sub_1001DDA80(a5, &v20);
  while (1)
  {
    uint64_t v9 = sub_10024F3D8(a1, *(void *)(a2 + 8), *(unsigned __int16 *)(a2 + 2), &v21, (__int16 **)&v23, v20);
    if (v9) {
      break;
    }
    DWORD2(v22) = *(unsigned __int16 *)v23;
    uint64_t result = sub_10017A24C(a4, a3, (unsigned __int8 *)&v22);
    if (!result) {
      return result;
    }
    if (!sub_10017A24C(a4, a3, v23 + 8)) {
      return 0;
    }
  }
  uint64_t v11 = v9;
  if (v9 == 826) {
    return 1;
  }
  uint64_t result = sub_100058654();
  if (result)
  {
    sub_100056E24((uint64_t)"Internal SDP error AttributeSearch returned %!", v12, v13, v14, v15, v16, v17, v18, v11);
    uint64_t v19 = sub_100050B4C(0x35u);
    uint64_t result = os_log_type_enabled(v19, OS_LOG_TYPE_ERROR);
    if (result)
    {
      sub_100744F6C();
      return 0;
    }
  }
  return result;
}

uint64_t *sub_100252DA0(uint64_t *result, unsigned int a2, int a3)
{
  unint64_t v3 = a2 - 2;
  unint64_t v4 = *((unsigned __int16 *)result + 5);
  if (v3 > v4) {
    sub_10014327C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpserver.c", 1162, "(size_t)(attrBytesPos - sizeof(uint16_t)) <= (size_t)((*responseBS).__size)");
  }
  uint64_t v5 = *((unsigned __int16 *)result + 6);
  *((_WORD *)result + 6) = v3;
  if (*((unsigned char *)result + 15))
  {
    sub_10025A794((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpserver.c");
    goto LABEL_22;
  }
  if ((int)(v4 - (unsigned __int16)v3) <= 1)
  {
LABEL_22:
    uint64_t v11 = "ByteStream_NumReadBytesAvail(*responseBS) >= 2";
    goto LABEL_24;
  }
  if (*((unsigned char *)result + 14) != 2)
  {
    uint64_t v11 = "(*responseBS).__RWFlag == BYTESTREAM_WRITE";
LABEL_24:
    sub_10014327C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpserver.c", 1163, v11);
  }
  *(unsigned char *)(*result + (unsigned __int16)v3 + 1) = v5 - a2;
  *(unsigned char *)(*result + *((unsigned __int16 *)result + 6)) = (unsigned __int16)(v5 - a2) >> 8;
  *((_WORD *)result + 6) += 2;
  uint64_t v6 = *((unsigned __int16 *)result + 5);
  if (v5 > v6) {
    sub_10014327C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpserver.c", 1167, "(size_t)(attrEndPos) <= (size_t)((*responseBS).__size)");
  }
  *((_WORD *)result + 6) = v5;
  unint64_t v7 = v6 + 3;
  if (v7 > *((unsigned __int16 *)result + 4)) {
    sub_10014327C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpserver.c", 1172, "((size + (sizeof(uint8_t) + sizeof(uint16_t))) <= (*responseBS).__trueSize) && ((size + (sizeof(uint8_t) + sizeof(uint16_t))) >= (*responseBS).__pos)");
  }
  *((_WORD *)result + 5) = v7;
  if (a3)
  {
    if (*((unsigned char *)result + 15))
    {
      sub_10025A794((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpserver.c");
    }
    else if (v5 < (unsigned __int16)v7)
    {
      if (*((unsigned char *)result + 14) == 2)
      {
        uint64_t v8 = *result;
        *((_WORD *)result + 6) = v5 + 1;
        *(unsigned char *)(v8 + v5) = 2;
        if (*((unsigned char *)result + 15))
        {
          sub_10025A794((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpserver.c");
        }
        else
        {
          uint64_t v9 = *((unsigned __int16 *)result + 6);
          if (*((unsigned __int16 *)result + 5) - (int)v9 > 1)
          {
            if (*((unsigned char *)result + 14) == 2)
            {
              *(unsigned char *)(*result + v9 + 1) = a3;
              *(unsigned char *)(*result + *((unsigned __int16 *)result + 6)) = BYTE1(a3);
              *((_WORD *)result + 6) += 2;
              return result;
            }
            uint64_t v13 = "(*responseBS).__RWFlag == BYTESTREAM_WRITE";
LABEL_34:
            sub_10014327C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpserver.c", 1178, v13);
          }
        }
        uint64_t v13 = "ByteStream_NumReadBytesAvail(*responseBS) >= 2";
        goto LABEL_34;
      }
      uint64_t v12 = "(*responseBS).__RWFlag == BYTESTREAM_WRITE";
LABEL_30:
      sub_10014327C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpserver.c", 1177, v12);
    }
    uint64_t v12 = "ByteStream_NumReadBytesAvail(*responseBS) >= 1";
    goto LABEL_30;
  }
  if (*((unsigned char *)result + 15))
  {
    sub_10025A794((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpserver.c");
    goto LABEL_36;
  }
  if (v5 >= (unsigned __int16)v7)
  {
LABEL_36:
    uint64_t v14 = "ByteStream_NumReadBytesAvail(*responseBS) >= 1";
    goto LABEL_38;
  }
  if (*((unsigned char *)result + 14) != 2)
  {
    uint64_t v14 = "(*responseBS).__RWFlag == BYTESTREAM_WRITE";
LABEL_38:
    sub_10014327C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpserver.c", 1180, v14);
  }
  uint64_t v10 = *result;
  *((_WORD *)result + 6) = v5 + 1;
  *(unsigned char *)(v10 + v5) = 0;
  return result;
}

void sub_100253048(uint64_t a1)
{
  if (a1 && sub_100058654())
  {
    sub_100056E24((uint64_t)"Write Secure Connection failed %!", v2, v3, v4, v5, v6, v7, v8, a1);
    uint64_t v9 = sub_100050B4C(0x37u);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR)) {
      sub_100745764();
    }
  }
}

uint64_t sub_1002530BC()
{
  if (HIDWORD(xmmword_100A19880)) {
    return 140;
  }
  uint64_t v1 = (unsigned __int8 *)sub_10025B218(0x28u);
  uint64_t v2 = sub_10010CE48(16 * *v1);
  qword_100A10480 = (uint64_t)v2;
  if (v2) {
    uint64_t v0 = 0;
  }
  else {
    uint64_t v0 = 106;
  }
  if (v2)
  {
    word_100A10508 = 0;
    qword_100A10490 = 0;
    qword_100A104E8 = 0;
    off_100A10500 = 0;
    dword_100A104D8 = 3;
    DWORD2(xmmword_100A104B0) = 6;
    dword_100A1048C = 0;
    byte_100A10489 = 0;
    if (sub_10017E718() && !byte_100A10488) {
      sub_10001BDE0(140, (uint64_t)sub_100253048, v3, v4, v5, v6, v7, v8, 1);
    }
    HIDWORD(xmmword_100A19880) = 1;
  }
  byte_100A19780 = 0;
  return v0;
}

uint64_t sub_1002531B4(uint64_t a1, BOOL *a2)
{
  uint64_t v22 = 0;
  if (a1 && a2)
  {
    uint64_t v3 = sub_10017E2D4(a1, &v22);
    if (v3)
    {
      if (sub_100058654())
      {
        sub_100056E24((uint64_t)"OI_SECMGR_RemoteSupportSSP: invalid address", v4, v5, v6, v7, v8, v9, v10, v21);
        uint64_t v11 = sub_100050B4C(0x37u);
        if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR)) {
          sub_100745764();
        }
      }
    }
    else
    {
      *a2 = *(unsigned char *)(v22 + 277) != 0;
    }
  }
  else
  {
    if (sub_100058654())
    {
      sub_100056E24((uint64_t)"OI_SECMGR_RemoteSupportSSP: invalid parameters", v12, v13, v14, v15, v16, v17, v18, v21);
      uint64_t v19 = sub_100050B4C(0x37u);
      if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR)) {
        sub_100745764();
      }
    }
    return 101;
  }
  return v3;
}

uint64_t sub_100253298(uint64_t a1, __int16 a2)
{
  uint64_t v3 = sub_100197A30(a1);
  if (v3)
  {
    *(_WORD *)(v3 + 274) = 10 * a2;
    sub_10017BB4C(v3);
    return 0;
  }
  else
  {
    if (sub_100058654())
    {
      sub_100056E24((uint64_t)"Invalid connection", v5, v6, v7, v8, v9, v10, v11, v13);
      uint64_t v12 = sub_100050B4C(0x37u);
      if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR)) {
        sub_100744F6C();
      }
    }
    return 122;
  }
}

uint64_t sub_10025331C(uint64_t a1, char a2)
{
  if (!a1) {
    return 101;
  }
  uint64_t v3 = sub_100197A30(a1);
  if (v3 && (uint64_t v4 = (unsigned __int16)word_100A10508, word_100A10508))
  {
    uint64_t v5 = qword_100A10480;
    while (*(void *)v5 != v3)
    {
      v5 += 16;
      if (!--v4) {
        goto LABEL_7;
      }
    }
    uint64_t result = 0;
    *(unsigned char *)(v5 + 13) = a2;
  }
  else
  {
LABEL_7:
    if (sub_100058654())
    {
      sub_100056E24((uint64_t)"Device is no longer connected", v6, v7, v8, v9, v10, v11, v12, v15);
      uint64_t v13 = sub_100050B4C(0x37u);
      if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR)) {
        sub_100744F6C();
      }
    }
    return 122;
  }
  return result;
}

uint64_t sub_1002533D0(uint64_t a1)
{
  if (a1 && (uint64_t v1 = (unsigned __int16)word_100A10508, word_100A10508))
  {
    uint64_t v2 = qword_100A10480;
    while (*(void *)v2 != a1)
    {
      v2 += 16;
      if (!--v1) {
        goto LABEL_6;
      }
    }
    return *(unsigned char *)(v2 + 13) != 0;
  }
  else
  {
LABEL_6:
    uint64_t result = sub_100058654();
    if (result)
    {
      sub_100056E24((uint64_t)"Device is no longer connected", v4, v5, v6, v7, v8, v9, v10, v12);
      uint64_t v11 = sub_100050B4C(0x37u);
      uint64_t result = os_log_type_enabled(v11, OS_LOG_TYPE_ERROR);
      if (result)
      {
        sub_100744F6C();
        return 0;
      }
    }
  }
  return result;
}

uint64_t sub_10025346C(uint64_t result)
{
  byte_100A10489 = result;
  return result;
}

uint64_t sub_100253478(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1)
  {
    uint64_t v8 = sub_10001BDE0(119, a1, a3, a4, a5, a6, a7, a8, v18);
    if (v8)
    {
      if (sub_100058654())
      {
        sub_100056E24((uint64_t)"OI_HCICMD_ReadLocalOOBData %!", v9, v10, v11, v12, v13, v14, v15, v8);
        uint64_t v16 = sub_100050B4C(0x37u);
        if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR)) {
          sub_100745764();
        }
      }
    }
  }
  else
  {
    sub_10025B8C0();
    return 101;
  }
  return v8;
}

uint64_t sub_100253504(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1)
  {
    uint64_t v8 = sub_10001BDE0(132, a1, a3, a4, a5, a6, a7, a8, v18);
    if (v8)
    {
      if (sub_100058654())
      {
        sub_100056E24((uint64_t)"OI_HCICMD_ReadLocalOOBExtendedData %!", v9, v10, v11, v12, v13, v14, v15, v8);
        uint64_t v16 = sub_100050B4C(0x37u);
        if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR)) {
          sub_100745764();
        }
      }
    }
  }
  else
  {
    sub_10025B8C0();
    return 101;
  }
  return v8;
}

uint64_t sub_100253590(uint64_t a1)
{
  uint64_t v1 = (unsigned __int16)word_100A10508;
  if (word_100A10508)
  {
    uint64_t v2 = (_DWORD *)(qword_100A10480 + 8);
    while (*((void *)v2 - 1) != a1)
    {
      v2 += 4;
      if (!--v1) {
        goto LABEL_5;
      }
    }
    return *v2 == 2;
  }
  else
  {
LABEL_5:
    uint64_t result = sub_100058654();
    if (result)
    {
      sub_100056E24((uint64_t)"OI_SECMGR_ConnectionIsEncrypted %!", v4, v5, v6, v7, v8, v9, v10, 122);
      uint64_t v11 = sub_100050B4C(0x37u);
      uint64_t result = os_log_type_enabled(v11, OS_LOG_TYPE_ERROR);
      if (result)
      {
        sub_100745764();
        return 0;
      }
    }
  }
  return result;
}

uint64_t sub_10025363C(uint64_t a1, unsigned char *a2)
{
  memset(v6, 0, sizeof(v6));
  int v7 = 0;
  *a2 = 0;
  uint64_t v3 = a1 + 48;
  if ((sub_10022EB74(a1 + 48, (uint64_t)v6) & 1) != 0
    || (uint64_t result = (*(uint64_t (**)(uint64_t, void *))(qword_100A10490 + 32))(v3, v6), result))
  {
    uint64_t result = 1;
    if (v7 == 8 || v7 == 5) {
      *a2 = 1;
    }
  }
  return result;
}

BOOL sub_1002536E8(uint64_t a1)
{
  if (dword_100A1048C < 2) {
    return 0;
  }
  return *(_DWORD *)(a1 + 48) == dword_100A10498 && *(unsigned __int16 *)(a1 + 52) == (unsigned __int16)word_100A1049C;
}

void sub_100253728(uint64_t (*a1)(void, void, void))
{
  if (!a1) {
    sub_10025B8C0();
  }
  off_100A104E0 = a1;
}

uint64_t sub_100253758(uint64_t a1, uint64_t a2, uint64_t a3, uint8x8_t a4)
{
  memset(v27, 0, sizeof(v27));
  int v28 = 0;
  if (HIDWORD(xmmword_100A19880)) {
    BOOL v4 = dword_100A1048C == 0;
  }
  else {
    BOOL v4 = 1;
  }
  if (v4)
  {
    uint64_t result = sub_100058654();
    if (result)
    {
      sub_100056E24((uint64_t)"!SECMGR_IS_INITIALIZED", v6, v7, v8, v9, v10, v11, v12, v26);
      uint64_t v13 = sub_100050B4C(0x37u);
      uint64_t result = os_log_type_enabled(v13, OS_LOG_TYPE_ERROR);
      if (result)
      {
        sub_100745764();
        return 0;
      }
    }
  }
  else
  {
    if (!qword_100A104E8
      || (*(void *)(qword_100A104E8 + 8) ? (BOOL v17 = qword_100A10490 == 0) : (BOOL v17 = 1),
          v17 || !*(void *)(qword_100A10490 + 32)))
    {
      sub_10025B8C0();
    }
    a4.i32[0] = dword_100A10498;
    if (vmovn_s16((int16x8_t)vmovl_u8(a4)).u32[0]) {
      BOOL v18 = 0;
    }
    else {
      BOOL v18 = word_100A1049C == 0;
    }
    if (v18 && HIBYTE(word_100A1049C) == 0) {
      return 0;
    }
    int v20 = (*(uint64_t (**)(uint64_t, uint64_t, int *))(qword_100A104E8 + 8))(a2, a3, &dword_100A10498);
    uint64_t v21 = (unsigned __int16)word_100A10508;
    if (word_100A10508)
    {
      uint64_t v22 = qword_100A10480;
      while (1)
      {
        BOOL v23 = *(void *)v22 != a1;
        if (*(void *)v22 == a1) {
          break;
        }
        v22 += 16;
        if (!--v21)
        {
          uint64_t v22 = 0;
          break;
        }
      }
    }
    else
    {
      uint64_t v22 = 0;
      BOOL v23 = 1;
    }
    if (sub_10022EB74((uint64_t)&dword_100A10498, (uint64_t)v27)) {
      char v24 = 1;
    }
    else {
      char v24 = (*(uint64_t (**)(int *, void *))(qword_100A10490 + 32))(&dword_100A10498, v27);
    }
    uint64_t result = v20 != 0;
    if (v20) {
      char v25 = v23;
    }
    else {
      char v25 = 1;
    }
    if ((v25 & 1) == 0)
    {
      if (*(_DWORD *)(v22 + 8) == 2)
      {
        if (v28 != 5) {
          char v24 = 0;
        }
        if (v24) {
          return 0;
        }
      }
      return 1;
    }
  }
  return result;
}

uint64_t sub_100253960(uint64_t result)
{
  byte_100A10488 = result;
  return result;
}

uint64_t sub_10025396C(void *a1)
{
  if (!a1)
  {
    sub_10025B8C0();
    return 101;
  }
  if (!*a1)
  {
    sub_10025B8C0();
    if (!*a1) {
      return 101;
    }
  }
  if (!a1[1])
  {
    sub_10025B8C0();
    if (!a1[1]) {
      return 101;
    }
  }
  if (!a1[2])
  {
    sub_10025B8C0();
    if (!a1[2]) {
      return 101;
    }
  }
  if (!a1[3])
  {
    sub_10025B8C0();
    if (!a1[3]) {
      return 101;
    }
  }
  if (!a1[4])
  {
    sub_10025B8C0();
    if (!a1[4]) {
      return 101;
    }
  }
  if (!a1[5])
  {
    sub_10025B8C0();
    if (!a1[5]) {
      return 101;
    }
  }
  if (!a1[6])
  {
    sub_10025B8C0();
    if (!a1[6]) {
      return 101;
    }
  }
  if (!a1[7])
  {
    sub_10025B8C0();
    if (!a1[7]) {
      return 101;
    }
  }
  if (!a1[8])
  {
    sub_10025B8C0();
    if (!a1[8]) {
      return 101;
    }
  }
  if (!a1[9])
  {
    sub_10025B8C0();
    if (!a1[9]) {
      return 101;
    }
  }
  if (!a1[10])
  {
    sub_10025B8C0();
    if (!a1[10]) {
      return 101;
    }
  }
  if (!a1[11])
  {
    sub_10025B8C0();
    if (!a1[11]) {
      return 101;
    }
  }
  if (!a1[13])
  {
    sub_10025B8C0();
    if (!a1[13]) {
      return 101;
    }
  }
  if (!a1[14])
  {
    sub_10025B8C0();
    if (!a1[14]) {
      return 101;
    }
  }
  uint64_t result = 0;
  qword_100A10490 = (uint64_t)a1;
  if (!dword_100A1048C)
  {
    if (qword_100A104E8)
    {
      sub_100253AE4(1);
      return 0;
    }
  }
  return result;
}

double sub_100253AE4(int a1)
{
  dword_100A1048C = a1;
  if (a1 == 1 && (dword_100A19790 || word_100A19794 != 0))
  {
    v13[0] = (const void *)40;
    v13[1] = &qword_100A19788;
    uint64_t v2 = sub_100026DA8((uint64_t)sub_1002585FC, v13, 0);
    if (v2)
    {
      uint64_t v3 = v2;
      if (sub_100058654())
      {
        sub_100056E24((uint64_t)"Dispatch registration failed %!", v4, v5, v6, v7, v8, v9, v10, v3);
        uint64_t v11 = sub_100050B4C(0x37u);
        if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR)) {
          sub_100745764();
        }
      }
      sub_10025B8C0();
    }
    qword_100A197A8 = 0;
    double result = 0.0;
    *(_OWORD *)&qword_100A19788 = 0u;
    xmmword_100A19798 = 0u;
  }
  return result;
}

uint64_t sub_100253BCC(void *a1)
{
  if (!a1)
  {
    sub_10025B8C0();
    return 101;
  }
  if (!*a1)
  {
    sub_10025B8C0();
    if (!*a1) {
      return 101;
    }
  }
  if (!a1[1])
  {
    sub_10025B8C0();
    if (!a1[1]) {
      return 101;
    }
  }
  qword_100A104E8 = (uint64_t)a1;
  if (dword_100A1048C) {
    BOOL v2 = 1;
  }
  else {
    BOOL v2 = qword_100A10490 == 0;
  }
  if (!v2) {
    sub_100253AE4(1);
  }
  return 0;
}

uint64_t sub_100253C54(void *a1)
{
  off_100A10500 = a1;
  return 0;
}

void sub_100253C64(uint64_t a1, unsigned int a2)
{
  uint64_t v41 = 0;
  if (HIDWORD(xmmword_100A19880)) {
    BOOL v2 = dword_100A1048C == 0;
  }
  else {
    BOOL v2 = 1;
  }
  if (v2)
  {
    if (sub_100058654())
    {
      sub_100056E24((uint64_t)"!SECMGR_IS_INITIALIZED", v3, v4, v5, v6, v7, v8, v9, v40);
      uint64_t v10 = sub_100050B4C(0x37u);
      if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR)) {
LABEL_8:
      }
        sub_100745764();
    }
  }
  else
  {
    uint64_t v12 = (unsigned __int16)word_100A10508;
    if (word_100A10508)
    {
      uint64_t v13 = (void *)qword_100A10480;
      while (*v13 != a1)
      {
        v13 += 2;
        if (!--v12) {
          goto LABEL_13;
        }
      }
      if (sub_100058654())
      {
        sub_100056E24((uint64_t)"OI_SECMGR_ConnectComplete, connection already exists", v24, v25, v26, v27, v28, v29, v30, v40);
        uint64_t v31 = sub_100050B4C(0x37u);
        if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR)) {
          goto LABEL_8;
        }
      }
    }
    else
    {
LABEL_13:
      uint64_t v14 = sub_100253E10(a1, &v41);
      if (v14)
      {
        uint64_t v15 = v14;
        if (sub_100058654())
        {
          sub_100056E24((uint64_t)"_createSecurityRecord %!", v16, v17, v18, v19, v20, v21, v22, v15);
          BOOL v23 = sub_100050B4C(0x37u);
          if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR)) {
            sub_100745764();
          }
        }
      }
      else
      {
        if (a2 >= 3)
        {
          if (sub_100058654())
          {
            sub_100056E24((uint64_t)"%! (%d)", v32, v33, v34, v35, v36, v37, v38, 1411);
            long long v39 = sub_100050B4C(0x37u);
            if (os_log_type_enabled(v39, OS_LOG_TYPE_ERROR)) {
              sub_100745764();
            }
          }
          a2 = 0;
        }
        sub_100253F44(v41, a2);
      }
    }
  }
}

uint64_t sub_100253E10(uint64_t a1, void *a2)
{
  unsigned int v4 = (unsigned __int16)word_100A10508;
  if (word_100A10508)
  {
    uint64_t v5 = (void *)qword_100A10480;
    uint64_t v6 = (unsigned __int16)word_100A10508;
    while (*v5 != a1)
    {
      v5 += 2;
      if (!--v6) {
        goto LABEL_8;
      }
    }
    sub_10025B8C0();
    unsigned int v4 = (unsigned __int16)word_100A10508;
LABEL_8:
    if (v4 > *(unsigned __int8 *)sub_10025B218(0x28u)) {
      sub_10025B8C0();
    }
  }
  else
  {
    sub_10025B218(0x28u);
  }
  unsigned int v7 = (unsigned __int16)word_100A10508;
  if (v7 >= *(unsigned __int8 *)sub_10025B218(0x28u))
  {
    if (sub_100058654())
    {
      sub_100056E24((uint64_t)"No room to add another connection %d", v12, v13, v14, v15, v16, v17, v18, (unsigned __int16)word_100A10508);
      uint64_t v19 = sub_100050B4C(0x37u);
      if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR)) {
        sub_100745764();
      }
    }
    return 104;
  }
  else
  {
    uint64_t v8 = qword_100A10480;
    uint64_t v9 = (unsigned __int16)word_100A10508;
    if (a2) {
      *a2 = qword_100A10480 + 16 * (unsigned __int16)word_100A10508;
    }
    uint64_t result = 0;
    uint64_t v11 = v8 + 16 * v9;
    *(void *)uint64_t v11 = a1;
    *(_DWORD *)(v11 + 8) = 0;
    *(_WORD *)(v11 + 12) = 0;
    word_100A10508 = v9 + 1;
  }
  return result;
}

void sub_100253F44(uint64_t a1, int a2)
{
  if (a1)
  {
    if (a2)
    {
LABEL_3:
      *(_DWORD *)(a1 + 8) = 2;
      uint64_t v4 = *(void *)a1;
      sub_100188C50(v4, 3);
      return;
    }
  }
  else
  {
    sub_10025B8C0();
    if (a2) {
      goto LABEL_3;
    }
  }
  if (*(_DWORD *)(a1 + 8) == 2) {
    *(_DWORD *)(a1 + 8) = 1;
  }
}

void sub_100253FB8(uint64_t a1, uint64_t a2)
{
  if (!sub_100197698(a1))
  {
    if (!sub_100058654()) {
      return;
    }
    sub_100056E24((uint64_t)"Connection is invalid", v22, v23, v24, v25, v26, v27, v28, v44);
    uint64_t v29 = sub_100050B4C(0x37u);
    if (!os_log_type_enabled(v29, OS_LOG_TYPE_ERROR)) {
      return;
    }
LABEL_9:
    sub_100745764();
    return;
  }
  unsigned int v12 = dword_100A1048C;
  if (HIDWORD(xmmword_100A19880)) {
    BOOL v13 = dword_100A1048C == 0;
  }
  else {
    BOOL v13 = 1;
  }
  if (v13)
  {
    if (!sub_100058654()) {
      return;
    }
    sub_100056E24((uint64_t)"!SECMGR_IS_INITIALIZED", v14, v15, v16, v17, v18, v19, v20, v44);
    uint64_t v21 = sub_100050B4C(0x37u);
    if (!os_log_type_enabled(v21, OS_LOG_TYPE_ERROR)) {
      return;
    }
    goto LABEL_9;
  }
  if (!qword_100A10490 || !*(void *)(qword_100A10490 + 8))
  {
    sub_10025B8C0();
    unsigned int v12 = dword_100A1048C;
  }
  if (v12 >= 2)
  {
    if (*(_DWORD *)(a1 + 48) ^ dword_100A10498 | *(unsigned __int16 *)(a1 + 52) ^ (unsigned __int16)word_100A1049C) {
      BOOL v30 = 1;
    }
    else {
      BOOL v30 = BYTE1(dword_100A104A8) == 0;
    }
    if (!v30)
    {
      *(_WORD *)((char *)&dword_100A104A8 + 1) = 0;
      (*(void (**)(void))(qword_100A10490 + 8))();
      unsigned int v12 = dword_100A1048C;
    }
    if (v12 == 5 && qword_100A104A0 == a1)
    {
      sub_10025428C(a2);
    }
    else if (v12 == 2)
    {
      if (qword_100A104A0 == a1 && DWORD2(xmmword_100A104B0) != 4) {
        sub_100254494(a2, v4, v5, v6, v7, v8, v9, v10);
      }
    }
    else if (v12 == 3 && qword_100A104A0 == a1 || v12 == 4 && qword_100A104A0 == a1)
    {
      v11.n128_f64[0] = sub_100253AE4(1);
    }
  }
  unsigned int v31 = (unsigned __int16)word_100A10508;
  if (word_100A10508)
  {
    uint64_t v32 = qword_100A10480;
    uint64_t v33 = qword_100A10480 + 16;
    int v34 = (unsigned __int16)(word_100A10508 - 1);
    do
    {
      unsigned int v35 = 0;
      do
      {
        unsigned int v36 = v35;
        uint64_t v37 = *(void *)(v32 + 16 * v35);
      }
      while (v37 != a1 && ++v35 < v31);
      if (v37 != a1) {
        break;
      }
      word_100A10508 = --v31;
      if (v35 < (unsigned __int16)v31)
      {
        long long v39 = (__n128 *)(v33 + 16 * v35);
        if (v37 == a1) {
          char v40 = 2;
        }
        else {
          char v40 = 1;
        }
        int v41 = v34 - v36 - (v40 & 1);
        do
        {
          __n128 v11 = *v39;
          v39[-1] = *v39;
          ++v39;
          --v41;
        }
        while (v41);
      }
      --v34;
    }
    while ((_WORD)v31);
  }
  if (*(_DWORD *)(a1 + 48) == dword_100A19790 && *(unsigned __int16 *)(a1 + 52) == (unsigned __int16)word_100A19794)
  {
    qword_100A197A8 = 0;
    __n128 v11 = 0uLL;
    *(_OWORD *)&qword_100A19788 = 0u;
    xmmword_100A19798 = 0u;
  }
  if (qword_100A104A0 == a1) {
    qword_100A104A0 = 0;
  }
  uint64_t v43 = *(void (**)(__n128))(qword_100A10490 + 96);
  if (v43)
  {
    v43(v11);
  }
}

void sub_10025428C(uint64_t a1)
{
  if (sub_100058654())
  {
    sub_100056E24((uint64_t)"Enforcement complete with %!", v2, v3, v4, v5, v6, v7, v8, a1);
    uint64_t v9 = sub_100050B4C(0x37u);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 136446210;
      uint64_t v32 = sub_100050714();
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
    }
  }
  if (dword_100A1048C != 5)
  {
    sub_10025B8C0();
    if (dword_100A1048C != 5)
    {
      if (sub_100058654())
      {
        uint64_t v17 = dword_100A1048C > 5 ? "unknown" : off_10099F530[dword_100A1048C];
        sub_100056E24((uint64_t)"enforcementFinish - %s state, %!", v10, v11, v12, v13, v14, v15, v16, (uint64_t)v17);
        uint64_t v18 = sub_100050B4C(0x37u);
        if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR)) {
          sub_100745764();
        }
      }
    }
  }
  sub_100253AE4(1);
  dword_100A104D8 = 3;
  uint64_t v19 = qword_100A104A0;
  if (qword_100A104A0)
  {
    if (*(unsigned char *)(qword_100A104A0 + 194))
    {
      *(unsigned char *)(qword_100A104A0 + 194) = 0;
      sub_100187790(v19);
      uint64_t v19 = qword_100A104A0;
    }
    if (!*(_DWORD *)(v19 + 148))
    {
      uint64_t v21 = sub_10017BB4C(v19);
      if (v21)
      {
        uint64_t v22 = v21;
        if (sub_100058654())
        {
          sub_100056E24((uint64_t)"OI_DevMgr_aclActivity failed with %!", v23, v24, v25, v26, v27, v28, v29, v22);
          BOOL v30 = sub_100050B4C(0x37u);
          if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR)) {
            sub_100744F6C();
          }
        }
      }
    }
  }
  uint64_t v20 = (void (*)(uint64_t, void))off_100A104D0;
  if (off_100A104D0 || (sub_10025B8C0(), (uint64_t v20 = (void (*)(uint64_t, void))off_100A104D0) != 0)) {
    v20(a1, dword_100A104C0);
  }
}

void sub_100254494(int a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (dword_100A1048C != 2) {
    sub_10025B8C0();
  }
  if (!HIDWORD(xmmword_100A104B0)) {
    HIDWORD(xmmword_100A104B0) = a1;
  }
  uint64_t v9 = sub_10001BDE0(77, (uint64_t)sub_1002589D8, a3, a4, a5, a6, a7, a8, 0);
  if (v9)
  {
    uint64_t v10 = v9;
    if (sub_100058654())
    {
      sub_100056E24((uint64_t)"OI_HCICMD_WriteAuthenticationEnable %!", v11, v12, v13, v14, v15, v16, v17, v10);
      uint64_t v18 = sub_100050B4C(0x37u);
      if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR)) {
        sub_100745764();
      }
    }
    sub_1002589D8(v10);
  }
}

void sub_100254550(uint64_t a1)
{
  if (sub_100197698(a1))
  {
    if (sub_100058654())
    {
      sub_100056E24((uint64_t)"AuthenticatedPayloadTimeoutEvent device %: , disconnecting", v2, v3, v4, v5, v6, v7, v8, a1 + 48);
      uint64_t v9 = sub_100050B4C(0x37u);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR)) {
        sub_100745764();
      }
    }
    uint64_t v10 = sub_10017C104(a1 + 48, 61);
    if (v10)
    {
      uint64_t v11 = v10;
      if (sub_100058654())
      {
        sub_100056E24((uint64_t)"Failed to force-disconnect due to MIC with status %!", v12, v13, v14, v15, v16, v17, v18, v11);
        uint64_t v19 = sub_100050B4C(0x37u);
        if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR)) {
          sub_100745764();
        }
      }
    }
  }
}

uint64_t sub_100254620(uint64_t a1, uint64_t a2)
{
  if (!qword_100A10490 || (uint64_t v4 = *(uint64_t (**)(uint64_t, uint64_t))(qword_100A10490 + 104)) == 0)
  {
    sub_10025B8C0();
    uint64_t v4 = *(uint64_t (**)(uint64_t, uint64_t))(qword_100A10490 + 104);
  }
  if (a2) {
    uint64_t v5 = a2 + 48;
  }
  else {
    uint64_t v5 = 0;
  }

  return v4(a1, v5);
}

void sub_10025468C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v85 = 0;
  if (HIDWORD(xmmword_100A19880)) {
    BOOL v4 = dword_100A1048C == 0;
  }
  else {
    BOOL v4 = 1;
  }
  if (v4)
  {
    if (!sub_100058654()) {
      return;
    }
    sub_100056E24((uint64_t)"!SECMGR_IS_INITIALIZED", v5, v6, v7, v8, v9, v10, v11, v84);
    uint64_t v12 = sub_100050B4C(0x37u);
    if (!os_log_type_enabled(v12, OS_LOG_TYPE_ERROR)) {
      return;
    }
LABEL_8:
    sub_100745764();
    return;
  }
  if (a1 == 702) {
    return;
  }
  if (!sub_100197698(a2))
  {
    if (!sub_100058654()) {
      return;
    }
    sub_100056E24((uint64_t)"Invalid Handle: 0x%x", v65, v66, v67, v68, v69, v70, v71, a2);
    uint64_t v72 = sub_100050B4C(0x37u);
    if (!os_log_type_enabled(v72, OS_LOG_TYPE_ERROR)) {
      return;
    }
    goto LABEL_8;
  }
  if (sub_100058654())
  {
    uint64_t v17 = sub_10025B7D0(a3);
    sub_100056E24((uint64_t)"HCIEvent EncryptionChange: %s", v18, v19, v20, v21, v22, v23, v24, (uint64_t)v17);
    uint64_t v25 = sub_100050B4C(0x37u);
    if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 136446210;
      uint64_t v87 = sub_100050714();
      _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
    }
  }
  if (sub_100058654())
  {
    sub_100056E24((uint64_t)"        addr     = %:", v26, v27, v28, v29, v30, v31, v32, a2 + 48);
    uint64_t v33 = sub_100050B4C(0x37u);
    if (os_log_type_enabled(v33, OS_LOG_TYPE_DEFAULT))
    {
      int v34 = sub_100050714();
      *(_DWORD *)long long buf = 136446210;
      uint64_t v87 = v34;
      _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
    }
  }
  if (sub_100058654())
  {
    sub_100056E24((uint64_t)"        status   = %!", v35, v36, v37, v38, v39, v40, v41, a1);
    uint64_t v42 = sub_100050B4C(0x37u);
    if (os_log_type_enabled(v42, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v43 = sub_100050714();
      *(_DWORD *)long long buf = 136446210;
      uint64_t v87 = v43;
      _os_log_impl((void *)&_mh_execute_header, v42, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
    }
  }
  if (sub_100058654())
  {
    sub_100056E24((uint64_t)"        key size = %d", v44, v45, v46, v47, v48, v49, v50, a4);
    unsigned int v51 = sub_100050B4C(0x37u);
    if (os_log_type_enabled(v51, OS_LOG_TYPE_DEFAULT))
    {
      unsigned __int16 v52 = sub_100050714();
      *(_DWORD *)long long buf = 136446210;
      uint64_t v87 = v52;
      _os_log_impl((void *)&_mh_execute_header, v51, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
    }
  }
  if (!a1)
  {
    if (a3 < 3)
    {
      if (a3)
      {
        uint64_t v53 = 1;
        goto LABEL_25;
      }
    }
    else if (sub_100058654())
    {
      sub_100056E24((uint64_t)"%! (%d)", v73, v74, v75, v76, v77, v78, v79, 1411);
      uint64_t v80 = sub_100050B4C(0x37u);
      if (os_log_type_enabled(v80, OS_LOG_TYPE_ERROR)) {
        sub_100745764();
      }
    }
  }
  a3 = 0;
  uint64_t v53 = 2;
LABEL_25:
  if (off_100A10500) {
    off_100A10500(v53, a1, a2 + 48);
  }
  uint64_t v54 = (unsigned __int16)word_100A10508;
  if (word_100A10508)
  {
    uint64_t v55 = (void *)qword_100A10480;
    while (*v55 != a2)
    {
      v55 += 2;
      if (!--v54) {
        goto LABEL_31;
      }
    }
    uint64_t v85 = v55;
    sub_100253F44((uint64_t)v55, a3);
    uint64_t v56 = 0;
  }
  else
  {
LABEL_31:
    uint64_t v56 = sub_100253E10(a2, &v85);
    if (v56)
    {
      if (sub_100058654())
      {
        sub_100056E24((uint64_t)"could not create security record %!", v57, v58, v59, v60, v61, v62, v63, v56);
        uint64_t v64 = sub_100050B4C(0x37u);
        if (os_log_type_enabled(v64, OS_LOG_TYPE_ERROR)) {
          sub_100745764();
        }
      }
      a3 = 0;
    }
    else
    {
      sub_100253F44((uint64_t)v85, a3);
    }
  }
  if (!qword_100A10490 || !*(void *)(qword_100A10490 + 112)) {
    sub_10025B8C0();
  }
  if (a2)
  {
    uint64_t v81 = *(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(qword_100A10490 + 112);
    if (v81) {
      v81(v56, a2 + 48, a3, a4);
    }
  }
  sub_1001886A0(v56, a2, a3);
  if (dword_100A1048C == 5 && qword_100A104A0 == a2 && dword_100A104D8 == 2)
  {
    if (a3) {
      unsigned int v82 = 0;
    }
    else {
      unsigned int v82 = 1414;
    }
    if (v56) {
      uint64_t v83 = v56;
    }
    else {
      uint64_t v83 = v82;
    }
    sub_10025428C(v83);
  }
  if (off_100A104E0) {
    off_100A104E0(v56, a2, a3);
  }
}

void sub_100254B60(uint64_t a1, uint64_t a2)
{
  if (HIDWORD(xmmword_100A19880)) {
    BOOL v2 = dword_100A1048C == 0;
  }
  else {
    BOOL v2 = 1;
  }
  if (v2)
  {
    if (sub_100058654())
    {
      sub_100056E24((uint64_t)"!SECMGR_IS_INITIALIZED", v3, v4, v5, v6, v7, v8, v9, v13);
      uint64_t v10 = sub_100050B4C(0x37u);
      if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR)) {
        sub_100745764();
      }
    }
  }
  else if (byte_100A104F0)
  {
    if (*(_DWORD *)(a2 + 48) == dword_100A104F1 && *(unsigned __int16 *)(a2 + 52) == (unsigned __int16)word_100A104F5)
    {
      byte_100A104F0 = 0;
      uint64_t v12 = (void (*)(uint64_t, int *))off_100A104F8;
      v12(a1, &dword_100A104F1);
    }
  }
}

void sub_100254C3C()
{
  if (HIDWORD(xmmword_100A19880)) {
    BOOL v0 = dword_100A1048C == 0;
  }
  else {
    BOOL v0 = 1;
  }
  if (v0 && sub_100058654())
  {
    sub_100056E24((uint64_t)"!SECMGR_IS_INITIALIZED", v1, v2, v3, v4, v5, v6, v7, v9);
    uint64_t v8 = sub_100050B4C(0x37u);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR)) {
      sub_100745764();
    }
  }
}

void sub_100254CB8(int a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v10 = HIDWORD(xmmword_100A19880);
  int v11 = dword_100A1048C;
  if (HIDWORD(xmmword_100A19880)) {
    BOOL v12 = dword_100A1048C == 0;
  }
  else {
    BOOL v12 = 1;
  }
  if (v12)
  {
    sub_10025B8C0();
    int v10 = HIDWORD(xmmword_100A19880);
    int v11 = dword_100A1048C;
  }
  if (v10) {
    BOOL v13 = v11 == 0;
  }
  else {
    BOOL v13 = 1;
  }
  if (v13)
  {
    if (sub_100058654())
    {
      sub_100056E24((uint64_t)"!SECMGR_IS_INITIALIZED", v14, v15, v16, v17, v18, v19, v20, v30);
      uint64_t v21 = sub_100050B4C(0x37u);
      if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR)) {
        goto LABEL_14;
      }
    }
  }
  else
  {
    if (a2)
    {
      if (a1) {
        sub_10001BDE0(31, (uint64_t)sub_100254DE8, a3, a4, a5, a6, a7, a8, a2);
      }
      else {
        sub_10001BDE0(32, (uint64_t)sub_100254DE8, a3, a4, a5, a6, a7, a8, a2);
      }
      return;
    }
    sub_10025B8C0();
    if (sub_100058654())
    {
      sub_100056E24((uint64_t)"OI_STATUS_INVALID_PARAMETERS", v22, v23, v24, v25, v26, v27, v28, v30);
      uint64_t v29 = sub_100050B4C(0x37u);
      if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR)) {
LABEL_14:
      }
        sub_100745764();
    }
  }
}

void sub_100254DE8(uint64_t a1)
{
  if (a1 && sub_100058654())
  {
    sub_100056E24((uint64_t)"status %!", v2, v3, v4, v5, v6, v7, v8, a1);
    uint64_t v9 = sub_100050B4C(0x37u);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR)) {
      sub_100745764();
    }
  }
}

void sub_100254E5C(uint64_t a1, uint64_t a2)
{
  uint64_t v35 = 0;
  unsigned int v2 = dword_100A1048C;
  if (HIDWORD(xmmword_100A19880)) {
    BOOL v3 = dword_100A1048C == 0;
  }
  else {
    BOOL v3 = 1;
  }
  if (v3)
  {
    if (sub_100058654())
    {
      sub_100056E24((uint64_t)"!SECMGR_IS_INITIALIZED", v4, v5, v6, v7, v8, v9, v10, v34);
      int v11 = sub_100050B4C(0x37u);
      if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR)) {
        sub_100745764();
      }
    }
  }
  else
  {
    if (!qword_100A10490 || !*(void *)(qword_100A10490 + 56))
    {
      sub_10025B8C0();
      unsigned int v2 = dword_100A1048C;
    }
    if (v2 < 2
      || (*(_DWORD *)a1 == dword_100A10498
        ? (BOOL v14 = *(unsigned __int16 *)(a1 + 4) == (unsigned __int16)word_100A1049C)
        : (BOOL v14 = 0),
          !v14))
    {
      if (sub_100058654())
      {
        sub_100056E24((uint64_t)"Not actively pairing or enforcing %:", v15, v16, v17, v18, v19, v20, v21, a1);
        uint64_t v22 = sub_100050B4C(0x37u);
        if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR)) {
          sub_100745764();
        }
      }
LABEL_20:
      sub_100254CB8(0, a1, v16, v17, v18, v19, v20, v21);
      return;
    }
    int v23 = dword_100A104A8;
    uint64_t v24 = sub_10017E2D4(a1, &v35);
    if (!v24)
    {
      if (!sub_1002533D0(v35))
      {
        (*(void (**)(uint64_t, uint64_t, BOOL, void))(qword_100A10490 + 56))(a1, a2, v23 != 0, BYTE2(dword_100A104A8));
        return;
      }
      goto LABEL_20;
    }
    uint64_t v25 = v24;
    if (sub_100058654())
    {
      sub_100056E24((uint64_t)"No longer connected %!", v26, v27, v28, v29, v30, v31, v32, v25);
      uint64_t v33 = sub_100050B4C(0x37u);
      if (os_log_type_enabled(v33, OS_LOG_TYPE_ERROR)) {
        sub_100745764();
      }
    }
  }
}

void sub_100255028(int a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v10 = HIDWORD(xmmword_100A19880);
  int v11 = dword_100A1048C;
  if (HIDWORD(xmmword_100A19880)) {
    BOOL v12 = dword_100A1048C == 0;
  }
  else {
    BOOL v12 = 1;
  }
  if (v12)
  {
    sub_10025B8C0();
    int v10 = HIDWORD(xmmword_100A19880);
    int v11 = dword_100A1048C;
  }
  if (v10) {
    BOOL v13 = v11 == 0;
  }
  else {
    BOOL v13 = 1;
  }
  if (v13)
  {
    if (sub_100058654())
    {
      sub_100056E24((uint64_t)"!SECMGR_IS_INITIALIZED", v14, v15, v16, v17, v18, v19, v20, v50);
      uint64_t v21 = sub_100050B4C(0x37u);
      if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR)) {
        goto LABEL_27;
      }
    }
  }
  else if (a2)
  {
    if (a1)
    {
      uint64_t v22 = sub_10001BDE0(33, (uint64_t)sub_1002551FC, a3, a4, a5, a6, a7, a8, a2);
      if (v22)
      {
        uint64_t v23 = v22;
        if (sub_100058654())
        {
          sub_100056E24((uint64_t)"OI_HCICMD_UserPasskeyRequestReply %!", v24, v25, v26, v27, v28, v29, v30, v23);
          uint64_t v31 = sub_100050B4C(0x37u);
          if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR)) {
LABEL_27:
          }
            sub_100745764();
        }
      }
    }
    else
    {
      uint64_t v40 = sub_10001BDE0(34, (uint64_t)sub_1002551FC, a3, a4, a5, a6, a7, a8, a2);
      if (v40)
      {
        uint64_t v41 = v40;
        if (sub_100058654())
        {
          sub_100056E24((uint64_t)"OI_HCICMD_UserPasskeyRequestNegativeReply %!", v42, v43, v44, v45, v46, v47, v48, v41);
          uint64_t v49 = sub_100050B4C(0x37u);
          if (os_log_type_enabled(v49, OS_LOG_TYPE_ERROR)) {
            goto LABEL_27;
          }
        }
      }
    }
  }
  else
  {
    sub_10025B8C0();
    if (sub_100058654())
    {
      sub_100056E24((uint64_t)"OI_STATUS_INVALID_PARAMETERS", v32, v33, v34, v35, v36, v37, v38, v50);
      uint64_t v39 = sub_100050B4C(0x37u);
      if (os_log_type_enabled(v39, OS_LOG_TYPE_ERROR)) {
        goto LABEL_27;
      }
    }
  }
}

void sub_1002551FC(uint64_t a1)
{
  if (a1 && sub_100058654())
  {
    sub_100056E24((uint64_t)"status %!", v2, v3, v4, v5, v6, v7, v8, a1);
    uint64_t v9 = sub_100050B4C(0x37u);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR)) {
      sub_100745764();
    }
  }
}

void sub_100255270(uint64_t a1)
{
  if (HIDWORD(xmmword_100A19880)) {
    BOOL v1 = dword_100A1048C == 0;
  }
  else {
    BOOL v1 = 1;
  }
  if (v1)
  {
    if (sub_100058654())
    {
      sub_100056E24((uint64_t)"!SECMGR_IS_INITIALIZED", v2, v3, v4, v5, v6, v7, v8, v26);
      uint64_t v9 = sub_100050B4C(0x37u);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR)) {
        sub_100745764();
      }
    }
  }
  else
  {
    if (!qword_100A10490 || !*(void *)(qword_100A10490 + 64)) {
      sub_10025B8C0();
    }
    uint64_t v11 = sub_100197A30(a1);
    if (v11)
    {
      if (sub_1002533D0(v11))
      {
        sub_100255028(0, a1, 0, v12, v13, v14, v15, v16);
      }
      else
      {
        uint64_t v25 = *(void (**)(uint64_t))(qword_100A10490 + 64);
        v25(a1);
      }
    }
    else if (sub_100058654())
    {
      sub_100056E24((uint64_t)"Invalid connection", v17, v18, v19, v20, v21, v22, v23, v26);
      uint64_t v24 = sub_100050B4C(0x37u);
      if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR)) {
        sub_100744F6C();
      }
    }
  }
}

void sub_1002553AC(uint64_t a1, uint64_t a2)
{
  if (HIDWORD(xmmword_100A19880)) {
    BOOL v2 = dword_100A1048C == 0;
  }
  else {
    BOOL v2 = 1;
  }
  if (v2)
  {
    if (sub_100058654())
    {
      sub_100056E24((uint64_t)"!SECMGR_IS_INITIALIZED", v3, v4, v5, v6, v7, v8, v9, v14);
      int v10 = sub_100050B4C(0x37u);
      if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR)) {
        sub_100745764();
      }
    }
  }
  else
  {
    if (!qword_100A10490 || (uint64_t v13 = *(void (**)(uint64_t, uint64_t))(qword_100A10490 + 72)) == 0)
    {
      sub_10025B8C0();
      uint64_t v13 = *(void (**)(uint64_t, uint64_t))(qword_100A10490 + 72);
    }
    v13(a1, a2);
  }
}

void sub_100255480(uint64_t a1, uint64_t a2)
{
  if (HIDWORD(xmmword_100A19880)) {
    BOOL v2 = dword_100A1048C == 0;
  }
  else {
    BOOL v2 = 1;
  }
  if (v2)
  {
    if (sub_100058654())
    {
      sub_100056E24((uint64_t)"!SECMGR_IS_INITIALIZED", v3, v4, v5, v6, v7, v8, v9, v28);
      int v10 = sub_100050B4C(0x37u);
      if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR)) {
        sub_100745764();
      }
    }
  }
  else
  {
    if (!qword_100A10490 || !*(void *)(qword_100A10490 + 80)) {
      sub_10025B8C0();
    }
    uint64_t v13 = sub_100197A30(a1);
    if (v13)
    {
      if (sub_1002533D0(v13))
      {
        sub_100255028(0, a1, 0, v14, v15, v16, v17, v18);
      }
      else
      {
        uint64_t v27 = *(void (**)(uint64_t, uint64_t))(qword_100A10490 + 80);
        v27(a1, a2);
      }
    }
    else if (sub_100058654())
    {
      sub_100056E24((uint64_t)"Invalid connection", v19, v20, v21, v22, v23, v24, v25, v28);
      uint64_t v26 = sub_100050B4C(0x37u);
      if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR)) {
        sub_100744F6C();
      }
    }
  }
}

void sub_1002555D4(uint64_t a1)
{
  if (HIDWORD(xmmword_100A19880)) {
    BOOL v1 = dword_100A1048C == 0;
  }
  else {
    BOOL v1 = 1;
  }
  if (v1)
  {
    if (sub_100058654())
    {
      sub_100056E24((uint64_t)"!SECMGR_IS_INITIALIZED", v2, v3, v4, v5, v6, v7, v8, v23);
      uint64_t v9 = sub_100050B4C(0x37u);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR)) {
        sub_100745764();
      }
    }
  }
  else
  {
    if (!qword_100A10490 || !*(void *)(qword_100A10490 + 88)) {
      sub_10025B8C0();
    }
    uint64_t v11 = sub_100197A30(a1);
    if (v11)
    {
      if (sub_1002533D0(v11))
      {
        sub_10025571C(0, a1, 0, 0, 0, 0, v12, v13);
      }
      else
      {
        uint64_t v22 = *(void (**)(uint64_t))(qword_100A10490 + 88);
        v22(a1);
      }
    }
    else if (sub_100058654())
    {
      sub_100056E24((uint64_t)"Invalid connection", v14, v15, v16, v17, v18, v19, v20, v23);
      uint64_t v21 = sub_100050B4C(0x37u);
      if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR)) {
        sub_100744F6C();
      }
    }
  }
}

void sub_10025571C(int a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v14 = HIDWORD(xmmword_100A19880);
  int v15 = dword_100A1048C;
  if (HIDWORD(xmmword_100A19880)) {
    BOOL v16 = dword_100A1048C == 0;
  }
  else {
    BOOL v16 = 1;
  }
  if (v16)
  {
    sub_10025B8C0();
    int v14 = HIDWORD(xmmword_100A19880);
    int v15 = dword_100A1048C;
  }
  if (v14) {
    BOOL v17 = v15 == 0;
  }
  else {
    BOOL v17 = 1;
  }
  if (v17)
  {
    if (sub_100058654())
    {
      sub_100056E24((uint64_t)"!SECMGR_IS_INITIALIZED", v18, v19, v20, v21, v22, v23, v24, v62);
      uint64_t v25 = sub_100050B4C(0x37u);
      if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR)) {
        goto LABEL_41;
      }
    }
    return;
  }
  if (!a2)
  {
    sub_10025B8C0();
    if (sub_100058654())
    {
      sub_100056E24((uint64_t)"OI_STATUS_INVALID_PARAMETERS pAddr %:", v36, v37, v38, v39, v40, v41, v42, 0);
      uint64_t v43 = sub_100050B4C(0x37u);
      if (os_log_type_enabled(v43, OS_LOG_TYPE_ERROR)) {
        goto LABEL_41;
      }
    }
    return;
  }
  if (!a1)
  {
    uint64_t v44 = sub_10001BDE0(36, (uint64_t)sub_100255990, a3, a4, a5, a6, a7, a8, a2);
    if (v44)
    {
      uint64_t v45 = v44;
      if (sub_100058654())
      {
        sub_100056E24((uint64_t)"OI_HCICMD_RemoteOOBDataRequestNegativeReply %!", v46, v47, v48, v49, v50, v51, v52, v45);
        uint64_t v53 = sub_100050B4C(0x37u);
        if (os_log_type_enabled(v53, OS_LOG_TYPE_ERROR)) {
          goto LABEL_41;
        }
      }
    }
    return;
  }
  if (a3)
  {
    if (a4) {
      goto LABEL_19;
    }
  }
  else
  {
    sub_10025B8C0();
    if (a4)
    {
LABEL_19:
      if (a5) {
        goto LABEL_20;
      }
LABEL_37:
      sub_10025B8C0();
      if (a6) {
        goto LABEL_21;
      }
LABEL_38:
      sub_10025B8C0();
      goto LABEL_39;
    }
  }
  sub_10025B8C0();
  if (!a5) {
    goto LABEL_37;
  }
LABEL_20:
  if (!a6) {
    goto LABEL_38;
  }
LABEL_21:
  if (!a5 || !a3 || !a4)
  {
LABEL_39:
    if (sub_100058654())
    {
      sub_100056E24((uint64_t)"oob data %!", v54, v55, v56, v57, v58, v59, v60, 101);
      uint64_t v61 = sub_100050B4C(0x37u);
      if (os_log_type_enabled(v61, OS_LOG_TYPE_ERROR)) {
        goto LABEL_41;
      }
    }
    return;
  }
  uint64_t v26 = sub_10001BDE0(39, (uint64_t)sub_100255990, a3, a4, a5, a6, a7, a8, a2);
  if (v26)
  {
    uint64_t v27 = v26;
    if (sub_100058654())
    {
      sub_100056E24((uint64_t)"OI_HCICMD_RemoteOOBDataRequestReply %!", v28, v29, v30, v31, v32, v33, v34, v27);
      uint64_t v35 = sub_100050B4C(0x37u);
      if (os_log_type_enabled(v35, OS_LOG_TYPE_ERROR)) {
LABEL_41:
      }
        sub_100745764();
    }
  }
}

void sub_100255990(uint64_t a1)
{
  if (a1 && sub_100058654())
  {
    sub_100056E24((uint64_t)"status %!", v2, v3, v4, v5, v6, v7, v8, a1);
    uint64_t v9 = sub_100050B4C(0x37u);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR)) {
      sub_100745764();
    }
  }
}

void sub_100255A04(uint64_t a1)
{
  int v1 = dword_100A1048C;
  if (HIDWORD(xmmword_100A19880)) {
    BOOL v2 = dword_100A1048C == 0;
  }
  else {
    BOOL v2 = 1;
  }
  if (v2)
  {
    if (sub_100058654())
    {
      sub_100056E24((uint64_t)"!SECMGR_IS_INITIALIZED", v3, v4, v5, v6, v7, v8, v9, v49);
      int v10 = sub_100050B4C(0x37u);
      if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR)) {
        sub_100745764();
      }
    }
  }
  else
  {
    if (!qword_100A10490 || !*(void *)(qword_100A10490 + 24) || !*(void *)qword_100A10490)
    {
      sub_10025B8C0();
      int v1 = dword_100A1048C;
    }
    int v12 = 20;
    switch(v1)
    {
      case 1:
        return;
      case 2:
      case 5:
        if (*(_DWORD *)a1 != dword_100A10498 || *(unsigned __int16 *)(a1 + 4) != (unsigned __int16)word_100A1049C) {
          goto LABEL_45;
        }
        BYTE1(dword_100A104A8) = 1;
        (*(void (**)(uint64_t))qword_100A10490)(a1);
        if (dword_100A1048C != 2) {
          goto LABEL_38;
        }
        if (DWORD2(xmmword_100A104B0) == 1) {
          goto LABEL_45;
        }
        if (DWORD2(xmmword_100A104B0) == 2)
        {
          DWORD2(xmmword_100A104B0) = 5;
          goto LABEL_38;
        }
        sub_10025B8C0();
        goto LABEL_45;
      case 3:
        if (*(_DWORD *)a1 != dword_100A10498 || *(unsigned __int16 *)(a1 + 4) != (unsigned __int16)word_100A1049C) {
          goto LABEL_45;
        }
        if (byte_100A10489 || xmmword_100A104B0 < 2u || xmmword_100A104B0 > 5u)
        {
LABEL_38:
          uint64_t v31 = *(void (**)(uint64_t))(qword_100A10490 + 24);
          v31(a1);
        }
        else
        {
          if (sub_100058654())
          {
            sub_100056E24((uint64_t)"Non-bondable mode, rejecting IO caps request from %:", v23, v24, v25, v26, v27, v28, v29, a1);
            uint64_t v30 = sub_100050B4C(0x37u);
            if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR)) {
              sub_100745764();
            }
          }
          int v12 = 24;
LABEL_45:
          if (sub_100058654())
          {
            sub_100056E24((uint64_t)"rejecting %: ioCaps request, secmgrState: %s, %!", v33, v34, v35, v36, v37, v38, v39, a1);
            uint64_t v40 = sub_100050B4C(0x37u);
            if (os_log_type_enabled(v40, OS_LOG_TYPE_ERROR)) {
              sub_100745764();
            }
          }
          if (sub_100058654())
          {
            sub_100056E24((uint64_t)"%:", v41, v42, v43, v44, v45, v46, v47, a1);
            uint64_t v48 = sub_100050B4C(0x37u);
            if (os_log_type_enabled(v48, OS_LOG_TYPE_ERROR)) {
              sub_100745764();
            }
          }
          sub_100255D70(v12, a1, 0);
        }
        break;
      case 4:
        goto LABEL_45;
      default:
        if (sub_100058654())
        {
          uint64_t v21 = dword_100A1048C > 5 ? "unknown" : off_10099F530[dword_100A1048C];
          sub_100056E24((uint64_t)"secmgrState %s (%d)", v14, v15, v16, v17, v18, v19, v20, (uint64_t)v21);
          uint64_t v32 = sub_100050B4C(0x37u);
          if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR)) {
            sub_100745764();
          }
        }
        sub_10025B8C0();
        int v12 = 20;
        goto LABEL_45;
    }
  }
}

void sub_100255D70(int a1, uint64_t a2, int a3)
{
  int v6 = HIDWORD(xmmword_100A19880);
  int v7 = dword_100A1048C;
  if (HIDWORD(xmmword_100A19880)) {
    BOOL v8 = dword_100A1048C == 0;
  }
  else {
    BOOL v8 = 1;
  }
  if (v8)
  {
    sub_10025B8C0();
    int v7 = dword_100A1048C;
    int v6 = HIDWORD(xmmword_100A19880);
  }
  if (v6) {
    BOOL v9 = v7 == 0;
  }
  else {
    BOOL v9 = 1;
  }
  if (v9)
  {
    if (sub_100058654())
    {
      sub_100056E24((uint64_t)"!SECMGR_IS_INITIALIZED", v10, v11, v12, v13, v14, v15, v16, v62);
      uint64_t v17 = sub_100050B4C(0x37u);
      if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR)) {
        goto LABEL_50;
      }
    }
  }
  else
  {
    if (a2)
    {
      switch(v7)
      {
        case 1:
        case 2:
        case 4:
        case 5:
          goto LABEL_37;
        case 3:
          LOBYTE(dword_100A104A8) = a3 != 3
                                 && BYTE1(xmmword_100A104B0) != 3
                                 && (a3 == 2 || BYTE1(xmmword_100A104B0) == 2 || a3 == 1
                                                                              || BYTE1(xmmword_100A104B0) == 1);
LABEL_37:
          if (!qword_100A104E8 || (uint64_t v35 = *(unsigned int (**)(void))qword_100A104E8) == 0)
          {
            sub_10025B8C0();
            uint64_t v35 = *(unsigned int (**)(void))qword_100A104E8;
          }
          if (v35() >= 3) {
            LOBYTE(dword_100A104A8) = 1;
          }
          if (a1)
          {
            uint64_t v42 = sub_10001BDE0(37, (uint64_t)sub_100256480, v36, v37, v38, v39, v40, v41, a2);
            if (!v42) {
              return;
            }
            uint64_t v43 = v42;
            if (!sub_100058654()) {
              return;
            }
            sub_100056E24((uint64_t)"OI_HCICMD_IOCapabilityRequestNegativeReply %!", v44, v45, v46, v47, v48, v49, v50, v43);
            uint64_t v51 = sub_100050B4C(0x37u);
            if (!os_log_type_enabled(v51, OS_LOG_TYPE_ERROR)) {
              return;
            }
          }
          else
          {
            uint64_t v52 = sub_10001BDE0(30, (uint64_t)sub_100256480, v36, v37, v38, v39, v40, v41, a2);
            if (!v52) {
              return;
            }
            uint64_t v53 = v52;
            if (!sub_100058654()) {
              return;
            }
            sub_100056E24((uint64_t)"%!", v54, v55, v56, v57, v58, v59, v60, v53);
            uint64_t v61 = sub_100050B4C(0x37u);
            if (!os_log_type_enabled(v61, OS_LOG_TYPE_ERROR)) {
              return;
            }
          }
          break;
        default:
          if (sub_100058654())
          {
            uint64_t v33 = dword_100A1048C > 5 ? "unknown" : off_10099F530[dword_100A1048C];
            sub_100056E24((uint64_t)"secmgrState %s (%d), %!", v26, v27, v28, v29, v30, v31, v32, (uint64_t)v33);
            uint64_t v34 = sub_100050B4C(0x37u);
            if (os_log_type_enabled(v34, OS_LOG_TYPE_ERROR)) {
              sub_100745764();
            }
          }
          sub_10025B8C0();
          return;
      }
      goto LABEL_50;
    }
    sub_10025B8C0();
    if (sub_100058654())
    {
      sub_100056E24((uint64_t)"OI_STATUS_INVALID_PARAMETERS", v18, v19, v20, v21, v22, v23, v24, v62);
      uint64_t v25 = sub_100050B4C(0x37u);
      if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR)) {
LABEL_50:
      }
        sub_100745764();
    }
  }
}

void sub_100256108(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  int v4 = dword_100A1048C;
  if (HIDWORD(xmmword_100A19880)) {
    BOOL v5 = dword_100A1048C == 0;
  }
  else {
    BOOL v5 = 1;
  }
  if (v5)
  {
    if (sub_100058654())
    {
      sub_100056E24((uint64_t)"!SECMGR_IS_INITIALIZED", v6, v7, v8, v9, v10, v11, v12, v55);
      uint64_t v13 = sub_100050B4C(0x37u);
      if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR)) {
        sub_100745764();
      }
    }
  }
  else
  {
    if (!qword_100A10490 || !*(void *)(qword_100A10490 + 16) || !*(void *)qword_100A10490)
    {
      sub_10025B8C0();
      int v4 = dword_100A1048C;
    }
    switch(v4)
    {
      case 1:
        uint64_t v56 = 0;
        if (sub_10017E2D4(a1, &v56))
        {
          if (sub_100058654())
          {
            sub_100056E24((uint64_t)"IoCapsResponse, internal inconsistency for %:, %!", v27, v28, v29, v30, v31, v32, v33, a1);
            uint64_t v34 = sub_100050B4C(0x37u);
            if (os_log_type_enabled(v34, OS_LOG_TYPE_ERROR)) {
              sub_100745764();
            }
          }
          goto LABEL_38;
        }
        dword_100A1048C = 3;
        uint64_t v35 = v56;
        char v36 = *(unsigned char *)(v56 + 277);
        if (!v36)
        {
          char v36 = 1;
          *(unsigned char *)(v56 + 277) = 1;
        }
        int v37 = *(_DWORD *)a1;
        word_100A1049C = *(_WORD *)(a1 + 4);
        dword_100A10498 = v37;
        qword_100A104A0 = v35;
        *(_WORD *)((char *)&dword_100A104A8 + 1) = 257;
        LOBYTE(dword_100A104A8) = a4 & 1;
        HIBYTE(dword_100A104A8) = v36 & (BYTE8(xmmword_100A195C0) > 3u);
        LOBYTE(xmmword_100A104B0) = a4;
        BYTE1(xmmword_100A104B0) = a2;
        (*(void (**)(uint64_t))qword_100A10490)(a1);
        goto LABEL_33;
      case 2:
      case 5:
        if (*(_DWORD *)a1 != dword_100A10498 || *(unsigned __int16 *)(a1 + 4) != (unsigned __int16)word_100A1049C) {
          goto LABEL_38;
        }
        if (a4) {
          LOBYTE(dword_100A104A8) = 1;
        }
        if (!BYTE1(dword_100A104A8)) {
          *(_WORD *)((char *)&dword_100A104A8 + 1) = 256;
        }
LABEL_33:
        (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(qword_100A10490 + 16))(a1, a2, a3, a4);
        break;
      case 3:
      case 4:
        goto LABEL_38;
      default:
        if (sub_100058654())
        {
          uint64_t v26 = dword_100A1048C > 5 ? "unknown" : off_10099F530[dword_100A1048C];
          sub_100056E24((uint64_t)"secmgrState %s (%d)", v19, v20, v21, v22, v23, v24, v25, (uint64_t)v26);
          uint64_t v38 = sub_100050B4C(0x37u);
          if (os_log_type_enabled(v38, OS_LOG_TYPE_ERROR)) {
            sub_100745764();
          }
        }
        sub_10025B8C0();
LABEL_38:
        if (sub_100058654())
        {
          sub_100056E24((uint64_t)"Ignoring IoCapsResponse event from %:, %!", v39, v40, v41, v42, v43, v44, v45, a1);
          uint64_t v46 = sub_100050B4C(0x37u);
          if (os_log_type_enabled(v46, OS_LOG_TYPE_ERROR)) {
            sub_100745764();
          }
        }
        if (sub_1001F7D74() == 6 || sub_1001F7D74() == 12)
        {
          if (sub_100058654())
          {
            sub_100056E24((uint64_t)"Unexpected IoCapsResponse event. Forcing disconnect from %:, %!", v47, v48, v49, v50, v51, v52, v53, a1);
            uint64_t v54 = sub_100050B4C(0x37u);
            if (os_log_type_enabled(v54, OS_LOG_TYPE_ERROR)) {
              sub_100745764();
            }
          }
          sub_10017C104(a1, 19);
        }
        break;
    }
  }
}

void sub_100256480(uint64_t a1)
{
  if (a1 && sub_100058654())
  {
    sub_100056E24((uint64_t)"ioCapsReplyCmdCb %!", v2, v3, v4, v5, v6, v7, v8, a1);
    uint64_t v9 = sub_100050B4C(0x37u);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR)) {
      sub_100745764();
    }
  }
}

void sub_1002564F4(int a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v11 = HIDWORD(xmmword_100A19880);
  int v12 = dword_100A1048C;
  if (HIDWORD(xmmword_100A19880)) {
    BOOL v13 = dword_100A1048C == 0;
  }
  else {
    BOOL v13 = 1;
  }
  if (v13)
  {
    sub_10025B8C0();
    int v11 = HIDWORD(xmmword_100A19880);
    int v12 = dword_100A1048C;
  }
  if (v11) {
    BOOL v14 = v12 == 0;
  }
  else {
    BOOL v14 = 1;
  }
  if (v14)
  {
    if (!sub_100058654()) {
      return;
    }
    sub_100056E24((uint64_t)"!SECMGR_IS_INITIALIZED", v15, v16, v17, v18, v19, v20, v21, v41);
    uint64_t v22 = sub_100050B4C(0x37u);
    if (!os_log_type_enabled(v22, OS_LOG_TYPE_ERROR)) {
      return;
    }
LABEL_32:
    sub_100745764();
    return;
  }
  if (!a2)
  {
    sub_10025B8C0();
    if (a3 || (a1 & 1) == 0)
    {
LABEL_25:
      if (!sub_100058654()) {
        return;
      }
      sub_100056E24((uint64_t)"OI_STATUS_INVALID_PARAMETERS", v24, v25, v26, v27, v28, v29, v30, v41);
      uint64_t v31 = sub_100050B4C(0x37u);
      if (!os_log_type_enabled(v31, OS_LOG_TYPE_ERROR)) {
        return;
      }
      goto LABEL_32;
    }
LABEL_24:
    sub_10025B8C0();
    goto LABEL_25;
  }
  if (!a3 && a1) {
    goto LABEL_24;
  }
  if (dword_100A1048C == 4) {
    sub_100253AE4(1);
  }
  if (a1) {
    uint64_t v23 = sub_10001BDE0(12, (uint64_t)sub_1002566B0, a3, a4, a5, a6, a7, a8, a2);
  }
  else {
    uint64_t v23 = sub_10001BDE0(13, (uint64_t)sub_1002566B0, a3, a4, a5, a6, a7, a8, a2);
  }
  uint64_t v32 = v23;
  if (v23)
  {
    if (sub_100058654())
    {
      sub_100056E24((uint64_t)"OI_SECMGR_PinCode %!", v33, v34, v35, v36, v37, v38, v39, v32);
      uint64_t v40 = sub_100050B4C(0x37u);
      if (os_log_type_enabled(v40, OS_LOG_TYPE_ERROR)) {
        goto LABEL_32;
      }
    }
  }
}

void sub_1002566B0(int a1, uint64_t a2)
{
  if (a1 && sub_100058654())
  {
    sub_100056E24((uint64_t)"pinCodeRequestReplyCb %:, %!", v3, v4, v5, v6, v7, v8, v9, a2);
    uint64_t v10 = sub_100050B4C(0x37u);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR)) {
      sub_100745764();
    }
  }
}

void sub_100256728(uint64_t a1)
{
  uint64_t v46 = 0;
  if (HIDWORD(xmmword_100A19880)) {
    BOOL v1 = dword_100A1048C == 0;
  }
  else {
    BOOL v1 = 1;
  }
  if (v1)
  {
    if (sub_100058654())
    {
      sub_100056E24((uint64_t)"!SECMGR_IS_INITIALIZED", v2, v3, v4, v5, v6, v7, v8, v45);
      uint64_t v9 = sub_100050B4C(0x37u);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR)) {
        sub_100745764();
      }
    }
  }
  else
  {
    if (!qword_100A10490 || !*(void *)(qword_100A10490 + 48)) {
      sub_10025B8C0();
    }
    if (byte_100A10489)
    {
      uint64_t v11 = sub_10017E2D4(a1, &v46);
      if (v11)
      {
        uint64_t v16 = v11;
        if (sub_100058654())
        {
          sub_100056E24((uint64_t)"OI_DEVMGR_GetAclHandleFromAddr %!", v17, v18, v19, v12, v13, v14, v15, v16);
          uint64_t v20 = sub_100050B4C(0x37u);
          if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR)) {
            sub_100745764();
          }
        }
      }
      else
      {
        switch(dword_100A1048C)
        {
          case 0:
          case 3:
          case 4:
            goto LABEL_43;
          case 1:
            dword_100A1048C = 4;
            int v25 = *(_DWORD *)a1;
            word_100A1049C = *(_WORD *)(a1 + 4);
            dword_100A10498 = v25;
            qword_100A104A0 = v46;
            dword_100A104A8 = 0;
            break;
          case 2:
            if (*(_DWORD *)a1 == dword_100A10498 && *(unsigned __int16 *)(a1 + 4) == (unsigned __int16)word_100A1049C)
            {
              switch(DWORD2(xmmword_100A104B0))
              {
                case 0:
                case 4:
                  goto LABEL_43;
                case 1:
                case 2:
                  DWORD2(xmmword_100A104B0) = 3;
                  goto LABEL_37;
                case 3:
                  goto LABEL_37;
                default:
                  if (sub_100058654())
                  {
                    sub_100056E24((uint64_t)"curContext.u.bondingContext.substate %d, %!", v37, v38, v39, v40, v41, v42, v43, DWORD2(xmmword_100A104B0));
                    uint64_t v44 = sub_100050B4C(0x37u);
                    if (os_log_type_enabled(v44, OS_LOG_TYPE_ERROR)) {
                      sub_100745764();
                    }
                  }
                  sub_100254494(105, v37, v38, v39, v40, v41, v42, v43);
                  goto LABEL_42;
              }
            }
            goto LABEL_43;
          case 5:
            if (*(_DWORD *)a1 != dword_100A10498 || *(unsigned __int16 *)(a1 + 4) != (unsigned __int16)word_100A1049C) {
              goto LABEL_43;
            }
            break;
          default:
            if (sub_100058654())
            {
              uint64_t v33 = dword_100A1048C > 5 ? "unknown" : off_10099F530[dword_100A1048C];
              sub_100056E24((uint64_t)"secmgrState %s (%d), %!", v26, v27, v28, v29, v30, v31, v32, (uint64_t)v33);
              uint64_t v36 = sub_100050B4C(0x37u);
              if (os_log_type_enabled(v36, OS_LOG_TYPE_ERROR)) {
                sub_100745764();
              }
            }
LABEL_42:
            sub_10025B8C0();
            goto LABEL_43;
        }
LABEL_37:
        if ((sub_1002533D0(v46) & 1) == 0)
        {
          (*(void (**)(uint64_t))(qword_100A10490 + 48))(a1);
          return;
        }
      }
    }
    else if (sub_100058654())
    {
      sub_100056E24((uint64_t)"Non-bondable mode, rejecting pin code request from %:, %!", v21, v22, v23, v12, v13, v14, v15, a1);
      uint64_t v24 = sub_100050B4C(0x37u);
      if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR)) {
        sub_100745764();
      }
    }
LABEL_43:
    sub_1002564F4(0, a1, 0, 0, v12, v13, v14, v15);
  }
}

void sub_100256A8C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  memset(v49, 0, sizeof(v49));
  unsigned int v50 = 0;
  int v8 = dword_100A1048C;
  if (HIDWORD(xmmword_100A19880)) {
    BOOL v9 = dword_100A1048C == 0;
  }
  else {
    BOOL v9 = 1;
  }
  if (v9)
  {
    if (sub_100058654())
    {
      sub_100056E24((uint64_t)"!SECMGR_IS_INITIALIZED", v10, v11, v12, v13, v14, v15, v16, v48);
      uint64_t v17 = sub_100050B4C(0x37u);
      if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR)) {
        sub_100745764();
      }
    }
    return;
  }
  if (!qword_100A10490 || !*(void *)(qword_100A10490 + 32))
  {
    sub_10025B8C0();
    int v8 = dword_100A1048C;
  }
  if (v8 == 2)
  {
    switch(DWORD2(xmmword_100A104B0))
    {
      case 0:
      case 3:
      case 4:
      case 5:
      case 6:
        if (!sub_100058654()) {
          goto LABEL_17;
        }
        sub_100056E24((uint64_t)"curContext.u.bondingContext.substate %d, %!", v19, v20, v21, v22, v23, v24, v25, DWORD2(xmmword_100A104B0));
        uint64_t v26 = sub_100050B4C(0x37u);
        if (!os_log_type_enabled(v26, OS_LOG_TYPE_ERROR)) {
          goto LABEL_17;
        }
        goto LABEL_16;
      case 1:
        DWORD2(xmmword_100A104B0) = 3;
        break;
      case 2:
        break;
      default:
        if (sub_100058654())
        {
          sub_100056E24((uint64_t)"Unknown bonding substate %!", v19, v20, v21, v22, v23, v24, v25, 105);
          uint64_t v37 = sub_100050B4C(0x37u);
          if (os_log_type_enabled(v37, OS_LOG_TYPE_ERROR)) {
LABEL_16:
          }
            sub_100745764();
        }
LABEL_17:
        sub_100254494(105, v19, v20, v21, v22, v23, v24, v25);
        sub_10025B8C0();
        break;
    }
  }
  else if (((sub_10022EB74(a1, (uint64_t)v49) & 1) != 0 {
          || (*(unsigned int (**)(uint64_t, void *))(qword_100A10490 + 32))(a1, v49))
  }
         && (dword_100A1048C != 5
          || dword_100A104D8 != 1
          || sub_100256DA8(HIBYTE(dword_100A104A8), dword_100A104C8, v50)))
  {
    uint64_t v27 = sub_10001BDE0(10, (uint64_t)sub_10025702C, a3, a4, a5, a6, a7, a8, a1);
    if (v27)
    {
      uint64_t v28 = v27;
      if (sub_100058654())
      {
        sub_100056E24((uint64_t)"OI_HCICMD_LinkKeyRequestReply %!", v29, v30, v31, v32, v33, v34, v35, v28);
        uint64_t v36 = sub_100050B4C(0x37u);
        if (os_log_type_enabled(v36, OS_LOG_TYPE_ERROR)) {
          goto LABEL_34;
        }
      }
    }
    return;
  }
  uint64_t v38 = sub_10001BDE0(11, (uint64_t)sub_10025702C, a3, a4, a5, a6, a7, a8, a1);
  if (v38)
  {
    uint64_t v39 = v38;
    if (sub_100058654())
    {
      sub_100056E24((uint64_t)"OI_HCICMD_LinkKeyRequestNegativeReply %!", v40, v41, v42, v43, v44, v45, v46, v39);
      uint64_t v47 = sub_100050B4C(0x37u);
      if (os_log_type_enabled(v47, OS_LOG_TYPE_ERROR)) {
LABEL_34:
      }
        sub_100745764();
    }
  }
}

uint64_t sub_100256DA8(int a1, uint64_t a2, uint64_t a3)
{
  if (dword_100A1048C != 5) {
    sub_10025B8C0();
  }
  uint64_t result = 1;
  switch((int)a2)
  {
    case 0:
      return result;
    case 1:
      if (a1)
      {
        if (a3 > 8)
        {
          uint64_t result = sub_100058654();
          if (result)
          {
            sub_100056E24((uint64_t)"Unhandled keytype", v31, v32, v33, v34, v35, v36, v37, a3);
            uint64_t v38 = sub_100050B4C(0x37u);
            uint64_t result = os_log_type_enabled(v38, OS_LOG_TYPE_ERROR);
            if (result) {
              goto LABEL_34;
            }
          }
        }
        else if (((1 << a3) & 0x1B8) == 0)
        {
          if (((1 << a3) & 7) != 0) {
            goto LABEL_8;
          }
          uint64_t result = sub_100058654();
          if (result)
          {
            sub_100056E24((uint64_t)"keyTypeIsSufficient %!", v39, v40, v41, v42, v43, v44, v45, 1420);
            uint64_t v46 = sub_100050B4C(0x37u);
            uint64_t result = os_log_type_enabled(v46, OS_LOG_TYPE_ERROR);
            if (result) {
              goto LABEL_34;
            }
          }
        }
      }
      break;
    case 2:
      uint64_t result = 0;
      if (a3 <= 8)
      {
        if (((1 << a3) & 0x1B8) != 0) {
          goto LABEL_21;
        }
        if (!a3) {
          goto LABEL_28;
        }
        if (a3 == 6)
        {
          uint64_t result = sub_100058654();
          if (result)
          {
            sub_100056E24((uint64_t)"keyTypeIsSufficient %!", v15, v16, v17, v18, v19, v20, v21, 1420);
            uint64_t v22 = sub_100050B4C(0x37u);
            uint64_t result = os_log_type_enabled(v22, OS_LOG_TYPE_ERROR);
            if (result) {
              goto LABEL_34;
            }
          }
        }
      }
      break;
    case 3:
      uint64_t result = 0;
      if (a3 <= 8)
      {
        if (((1 << a3) & 0x1A8) != 0)
        {
LABEL_21:
          uint64_t result = 1;
        }
        else if (a3)
        {
          if (a3 == 6)
          {
            uint64_t result = sub_100058654();
            if (result)
            {
              sub_100056E24((uint64_t)"keyTypeIsSufficient %!", v23, v24, v25, v26, v27, v28, v29, 1420);
              uint64_t v30 = sub_100050B4C(0x37u);
              uint64_t result = os_log_type_enabled(v30, OS_LOG_TYPE_ERROR);
              if (result) {
                goto LABEL_34;
              }
            }
          }
        }
        else
        {
LABEL_28:
          uint64_t result = a1 ^ 1u;
        }
      }
      break;
    default:
      uint64_t result = sub_100058654();
      if (result)
      {
        sub_100056E24((uint64_t)"Invalid security level %d, %!", v7, v8, v9, v10, v11, v12, v13, a2);
        uint64_t v14 = sub_100050B4C(0x37u);
        uint64_t result = os_log_type_enabled(v14, OS_LOG_TYPE_ERROR);
        if (result)
        {
LABEL_34:
          sub_100745764();
LABEL_8:
          uint64_t result = 0;
        }
      }
      break;
  }
  return result;
}

void sub_10025702C(uint64_t a1)
{
  if (a1 && sub_100058654())
  {
    sub_100056E24((uint64_t)"linkKeyRequestReplyCb %!", v2, v3, v4, v5, v6, v7, v8, a1);
    uint64_t v9 = sub_100050B4C(0x37u);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR)) {
      sub_100745764();
    }
  }
}

void sub_1002570A0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v18 = 0;
  if (HIDWORD(xmmword_100A19880)) {
    BOOL v3 = dword_100A1048C == 0;
  }
  else {
    BOOL v3 = 1;
  }
  if (v3)
  {
    if (sub_100058654())
    {
      sub_100056E24((uint64_t)"!SECMGR_IS_INITIALIZED", v4, v5, v6, v7, v8, v9, v10, v17);
      uint64_t v11 = sub_100050B4C(0x37u);
      if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR)) {
        sub_100745764();
      }
    }
  }
  else
  {
    if (!*(void *)(qword_100A10490 + 40)) {
      sub_10025B8C0();
    }
    if (sub_10017E2D4(a1, &v18) || (uint64_t v16 = (unsigned __int16)word_100A10508, !word_100A10508))
    {
LABEL_12:
      uint64_t v15 = 0;
    }
    else
    {
      uint64_t v15 = qword_100A10480;
      while (*(void *)v15 != v18)
      {
        v15 += 16;
        if (!--v16) {
          goto LABEL_12;
        }
      }
    }
    (*(void (**)(uint64_t, uint64_t, uint64_t, void))(qword_100A10490 + 40))(a1, a2, a3, byte_100A10489);
    if (v15)
    {
      if (*(_DWORD *)(v15 + 8) != 2) {
        *(_DWORD *)(v15 + 8) = 1;
      }
    }
  }
}

void sub_1002571D8(uint64_t a1, uint64_t a2)
{
  if (HIDWORD(xmmword_100A19880)) {
    BOOL v2 = dword_100A1048C == 0;
  }
  else {
    BOOL v2 = 1;
  }
  if (!v2)
  {
    if (dword_100A1048C == 2 && qword_100A104A0 == a2)
    {
      if (DWORD2(xmmword_100A104B0) > 6) {
        goto LABEL_48;
      }
      if (((1 << SBYTE8(xmmword_100A104B0)) & 0x57) == 0)
      {
        HIDWORD(xmmword_100A104B0) = a1;
        sub_1002574C8();
        goto LABEL_48;
      }
      if (sub_100058654())
      {
        sub_100056E24((uint64_t)"curContext.u.bondingContext.substate %d, %!", v16, v17, v18, v19, v20, v21, v22, DWORD2(xmmword_100A104B0));
        uint64_t v23 = sub_100050B4C(0x37u);
        if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR)) {
          sub_100745764();
        }
      }
      sub_100254494(105, v16, v17, v18, v19, v20, v21, v22);
    }
    else
    {
      if (dword_100A1048C != 5 || qword_100A104A0 != a2) {
        goto LABEL_48;
      }
      if (dword_100A104D8 == 1)
      {
        if (!qword_100A10490 || !*(void *)(qword_100A10490 + 32))
        {
          sub_10025B8C0();
          if (dword_100A1048C != 5) {
            sub_10025B8C0();
          }
        }
        if (dword_100A104D8 != 1) {
          sub_10025B8C0();
        }
        if (a1)
        {
          uint64_t v15 = a1;
        }
        else
        {
          memset(v41, 0, sizeof(v41));
          unsigned int v42 = 0;
          if (((sub_10022EB74((uint64_t)&dword_100A10498, (uint64_t)v41) & 1) != 0
             || (*(unsigned int (**)(int *, void *))(qword_100A10490 + 32))(&dword_100A10498, v41))
            && sub_100256DA8(HIBYTE(dword_100A104A8), dword_100A104C8, v42))
          {
            sub_1002586F4();
            goto LABEL_48;
          }
          if (sub_100058654())
          {
            sub_100056E24((uint64_t)"enforceAuthenticationDone %!", v32, v33, v34, v35, v36, v37, v38, 1419);
            uint64_t v39 = sub_100050B4C(0x37u);
            if (os_log_type_enabled(v39, OS_LOG_TYPE_ERROR)) {
              sub_100745764();
            }
          }
          uint64_t v15 = 1419;
        }
        sub_10025428C(v15);
LABEL_48:
        if (off_100A10500) {
          off_100A10500(0, a1, a2 + 48);
        }
        return;
      }
      if (sub_100058654())
      {
        sub_100056E24((uint64_t)"curContext.u.enforceContext.substate %d, %!", v24, v25, v26, v27, v28, v29, v30, dword_100A104D8);
        uint64_t v31 = sub_100050B4C(0x37u);
        if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR)) {
          sub_100745764();
        }
      }
      sub_10025428C(105);
    }
    sub_10025B8C0();
    goto LABEL_48;
  }
  if (sub_100058654())
  {
    sub_100056E24((uint64_t)"!SECMGR_IS_INITIALIZED", v3, v4, v5, v6, v7, v8, v9, v40);
    uint64_t v10 = sub_100050B4C(0x37u);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR)) {
      sub_100745764();
    }
  }
}

void sub_1002574C8()
{
  if (dword_100A1048C != 2) {
    sub_10025B8C0();
  }
  DWORD2(xmmword_100A104B0) = 4;
  uint64_t v0 = sub_10017C5F0(sub_100258960, (unsigned __int16 *)qword_100A104A0);
  if (v0)
  {
    uint64_t v1 = v0;
    if (sub_100058654())
    {
      sub_100056E24((uint64_t)"OI_DevMgr_BondingDisconnect %!", v2, v3, v4, v5, v6, v7, v8, v1);
      uint64_t v9 = sub_100050B4C(0x37u);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR)) {
        sub_100745764();
      }
    }
    sub_100254494(v1, v2, v3, v4, v5, v6, v7, v8);
  }
}

void sub_10025757C(uint64_t a1, uint64_t a2, __n128 a3)
{
  unsigned int v3 = dword_100A1048C;
  if (HIDWORD(xmmword_100A19880)) {
    BOOL v4 = dword_100A1048C == 0;
  }
  else {
    BOOL v4 = 1;
  }
  if (v4)
  {
    if (sub_100058654())
    {
      sub_100056E24((uint64_t)"!SECMGR_IS_INITIALIZED", v5, v6, v7, v8, v9, v10, v11, v24);
      uint64_t v12 = sub_100050B4C(0x37u);
      if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR)) {
        sub_100745764();
      }
    }
  }
  else
  {
    if (!qword_100A10490 || !*(void *)(qword_100A10490 + 8))
    {
      sub_10025B8C0();
      unsigned int v3 = dword_100A1048C;
    }
    if (v3 < 2
      || (!(*(_DWORD *)a2 ^ dword_100A10498 | *(unsigned __int16 *)(a2 + 4) ^ (unsigned __int16)word_100A1049C)
        ? (BOOL v15 = BYTE1(dword_100A104A8) == 0)
        : (BOOL v15 = 1),
          v15))
    {
      if (sub_100058654())
      {
        sub_100056E24((uint64_t)"SimplePairingComplete %:, %!", v16, v17, v18, v19, v20, v21, v22, a2);
        uint64_t v23 = sub_100050B4C(0x37u);
        if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR)) {
          sub_100745764();
        }
      }
    }
    else
    {
      *(_WORD *)((char *)&dword_100A104A8 + 1) = 0;
      if (v3 == 3) {
        a3.n128_f64[0] = sub_100253AE4(1);
      }
    }
    (*(void (**)(uint64_t, uint64_t, __n128))(qword_100A10490 + 8))(a2, a1, a3);
  }
}

uint64_t sub_1002576E0(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5, char a6)
{
  *(void *)&long long v64 = a3;
  *((void *)&v64 + 1) = a4;
  uint64_t v63 = 0;
  if (sub_100058654())
  {
    sub_100178240((uint64_t)&v64);
    sub_100056E24((uint64_t)"Enforce policy for %:, %s", v10, v11, v12, v13, v14, v15, v16, a2);
    uint64_t v17 = sub_100050B4C(0x37u);
    if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v18 = sub_100050714();
      *(_DWORD *)long long buf = 136446210;
      uint64_t v66 = v18;
      _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
    }
  }
  if (HIDWORD(xmmword_100A19880)) {
    BOOL v19 = dword_100A1048C == 0;
  }
  else {
    BOOL v19 = 1;
  }
  if (v19) {
    return 103;
  }
  if (qword_100A104E8 && *(void *)(qword_100A104E8 + 8))
  {
    if (!a1) {
      goto LABEL_20;
    }
  }
  else
  {
    sub_10025B8C0();
    if (!a1)
    {
LABEL_20:
      sub_10025B8C0();
      return 101;
    }
  }
  if (!a2) {
    goto LABEL_20;
  }
  if ((dword_100A1048C - 2) < 4)
  {
    if (sub_100058654())
    {
      uint64_t v28 = dword_100A1048C > 5 ? "unknown" : off_10099F530[dword_100A1048C];
      sub_100056E24((uint64_t)"State:  %s, Input Addr %:, Cur Addr %:, Pending Addr %:", v21, v22, v23, v24, v25, v26, v27, (uint64_t)v28);
      uint64_t v34 = sub_100050B4C(0x37u);
      if (os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v35 = sub_100050714();
        *(_DWORD *)long long buf = 136446210;
        uint64_t v66 = v35;
        _os_log_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
      }
    }
    if (dword_100A19790) {
      BOOL v36 = 0;
    }
    else {
      BOOL v36 = word_100A19794 == 0;
    }
    if (v36)
    {
      uint64_t v20 = 0;
      qword_100A19788 = (uint64_t)a1;
      int v45 = *(_DWORD *)a2;
      word_100A19794 = *(_WORD *)(a2 + 4);
      dword_100A19790 = v45;
      xmmword_100A19798 = v64;
      LODWORD(qword_100A197A8) = a5;
      BYTE4(qword_100A197A8) = a6;
      return v20;
    }
    if (sub_100058654())
    {
      sub_100056E24((uint64_t)"Security Mgr Busy with: Cur Addr %:, Pending Addr %:, Input Addr %:", v37, v38, v39, v40, v41, v42, v43, (uint64_t)&dword_100A10498);
      uint64_t v44 = sub_100050B4C(0x37u);
      if (os_log_type_enabled(v44, OS_LOG_TYPE_ERROR)) {
        sub_100745764();
      }
    }
    uint64_t v20 = 1404;
    goto LABEL_53;
  }
  if (dword_100A1048C == 1)
  {
    uint64_t v20 = sub_10017E2D4(a2, &v63);
    if (!v20)
    {
      uint64_t v30 = (unsigned __int16)word_100A10508;
      if (word_100A10508)
      {
        uint64_t v31 = (void *)qword_100A10480;
        while (*v31 != v63)
        {
          v31 += 2;
          if (!--v30) {
            goto LABEL_28;
          }
        }
LABEL_29:
        uint64_t v32 = qword_100A104E8;
        if (!qword_100A104E8 || !*(void *)(qword_100A104E8 + 8))
        {
          sub_10025B8C0();
          uint64_t v32 = qword_100A104E8;
        }
        int v33 = *(_DWORD *)a2;
        word_100A1049C = *(_WORD *)(a2 + 4);
        dword_100A10498 = v33;
        qword_100A104A0 = v63;
        LOBYTE(dword_100A104A8) = 0;
        HIBYTE(dword_100A104A8) = *(unsigned char *)(v63 + 277) & (BYTE8(xmmword_100A195C0) > 3u);
        xmmword_100A104B0 = v64;
        dword_100A104C0 = a5;
        byte_100A104C4 = a6;
        dword_100A104C8 = (*(uint64_t (**)(void, void, uint64_t))(v32 + 8))(v64, *((void *)&v64 + 1), a2);
        off_100A104D0 = a1;
        uint64_t v20 = sub_100026DA8((uint64_t)sub_100257B70, 0, 0);
        if (!v20)
        {
          dword_100A1048C = 5;
          dword_100A104D8 = 0;
          return v20;
        }
        goto LABEL_53;
      }
LABEL_28:
      uint64_t v20 = sub_100253E10(v63, 0);
      if (!v20) {
        goto LABEL_29;
      }
    }
  }
  else
  {
    if (sub_100058654())
    {
      uint64_t v53 = dword_100A1048C > 5 ? "unknown" : off_10099F530[dword_100A1048C];
      sub_100056E24((uint64_t)"secmgrState %s (%d), %!", v46, v47, v48, v49, v50, v51, v52, (uint64_t)v53);
      uint64_t v54 = sub_100050B4C(0x37u);
      if (os_log_type_enabled(v54, OS_LOG_TYPE_ERROR)) {
        sub_100745764();
      }
    }
    sub_10025B8C0();
    uint64_t v20 = 105;
  }
LABEL_53:
  if (sub_100058654())
  {
    sub_100056E24((uint64_t)"Enforce Policy error %!", v55, v56, v57, v58, v59, v60, v61, v20);
    uint64_t v62 = sub_100050B4C(0x37u);
    if (os_log_type_enabled(v62, OS_LOG_TYPE_ERROR)) {
      sub_100745764();
    }
  }
  return v20;
}

void sub_100257B70()
{
  if (sub_100058654())
  {
    sub_100056E24((uint64_t)"Deferred enforcement request", v0, v1, v2, v3, v4, v5, v6, v103);
    uint64_t v7 = sub_100050B4C(0x37u);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(buf) = 136446210;
      *(void *)((char *)&buf + 4) = sub_100050714();
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, " %{public}s", (uint8_t *)&buf, 0xCu);
    }
  }
  if (!qword_100A10490 || !*(void *)(qword_100A10490 + 32)) {
    sub_10025B8C0();
  }
  if (dword_100A1048C != 5
    && (!qword_100A104A0
     || !sub_100197698(qword_100A104A0)
     && !sub_100197740(qword_100A104A0)
     && !sub_100197770(qword_100A104A0)
     && !sub_1001977A0(qword_100A104A0)))
  {
    if (!sub_100058654()) {
      return;
    }
    sub_100056E24((uint64_t)"Disconnection happened during enforcement, ignoring (enforcementFinish was already called).", v32, v33, v34, v35, v36, v37, v38, v103);
    uint64_t v39 = sub_100050B4C(0x37u);
    if (!os_log_type_enabled(v39, OS_LOG_TYPE_ERROR)) {
      return;
    }
    goto LABEL_54;
  }
  if (!qword_100A104A0
    || !sub_100197698(qword_100A104A0)
    && !sub_100197740(qword_100A104A0)
    && !sub_100197770(qword_100A104A0)
    && !sub_1001977A0(qword_100A104A0))
  {
    if (!sub_100058654()) {
      return;
    }
    sub_100056E24((uint64_t)"HCI handle not valid can not enforce request", v16, v17, v18, v19, v20, v21, v22, v103);
    uint64_t v23 = sub_100050B4C(0x37u);
    if (!os_log_type_enabled(v23, OS_LOG_TYPE_ERROR)) {
      return;
    }
    goto LABEL_54;
  }
  if (!*(_DWORD *)(qword_100A104A0 + 148))
  {
    uint64_t v40 = sub_10017BB4C(qword_100A104A0);
    if (v40)
    {
      uint64_t v41 = v40;
      if (sub_100058654())
      {
        sub_100056E24((uint64_t)"OI_DevMgr_aclActivity failed with %!", v42, v43, v44, v45, v46, v47, v48, v41);
        uint64_t v49 = sub_100050B4C(0x37u);
        if (os_log_type_enabled(v49, OS_LOG_TYPE_ERROR)) {
          sub_100744F6C();
        }
      }
    }
  }
  if (dword_100A1048C != 5) {
    sub_10025B8C0();
  }
  if (dword_100A104D8) {
    sub_10025B8C0();
  }
  if (!qword_100A104E8 || !*(void *)(qword_100A104E8 + 8)) {
    sub_10025B8C0();
  }
  if (dword_100A1048C != 5)
  {
    if (!sub_100058654()) {
      return;
    }
    uint64_t v31 = dword_100A1048C > 5 ? "unknown" : off_10099F530[dword_100A1048C];
    sub_100056E24((uint64_t)"enforcementDeferredRequest - %s, %!", v24, v25, v26, v27, v28, v29, v30, (uint64_t)v31);
    uint64_t v61 = sub_100050B4C(0x37u);
    if (!os_log_type_enabled(v61, OS_LOG_TYPE_ERROR)) {
      return;
    }
LABEL_54:
    sub_100745764();
    return;
  }
  if (dword_100A104D8)
  {
    if (sub_100058654())
    {
      if (dword_100A104D8 > 3) {
        uint64_t v15 = "unknown";
      }
      else {
        uint64_t v15 = off_10099F598[dword_100A104D8];
      }
      sub_100056E24((uint64_t)"enforcementDeferredRequest - enforceSubstate %s, %!", v8, v9, v10, v11, v12, v13, v14, (uint64_t)v15);
      uint64_t v62 = sub_100050B4C(0x37u);
      if (os_log_type_enabled(v62, OS_LOG_TYPE_ERROR)) {
        sub_100745764();
      }
    }
    uint64_t v60 = 105;
    goto LABEL_59;
  }
  uint64_t v50 = (unsigned __int16)word_100A10508;
  if (!word_100A10508)
  {
LABEL_48:
    if (sub_100058654())
    {
      sub_100056E24((uint64_t)"enforcementDeferredRequest - no connection %!", v52, v53, v54, v55, v56, v57, v58, 1408);
      uint64_t v59 = sub_100050B4C(0x37u);
      if (os_log_type_enabled(v59, OS_LOG_TYPE_ERROR)) {
        sub_100745764();
      }
    }
    uint64_t v60 = 1408;
    goto LABEL_59;
  }
  uint64_t v51 = qword_100A10480 + 8;
  while (*(void *)(v51 - 8) != qword_100A104A0)
  {
    v51 += 16;
    if (!--v50) {
      goto LABEL_48;
    }
  }
  if (!byte_100A104C4 || *(unsigned char *)(qword_100A104A0 + 212))
  {
    long long buf = 0uLL;
    unsigned int v108 = 0;
    uint64_t v107 = 0;
    if (sub_10022EB74((uint64_t)&dword_100A10498, (uint64_t)&buf)) {
      unsigned int v63 = 1;
    }
    else {
      unsigned int v63 = (*(uint64_t (**)(int *, long long *))(qword_100A10490 + 32))(&dword_100A10498, &buf);
    }
    char v64 = *(unsigned char *)(qword_100A104A0 + 277) & (BYTE8(xmmword_100A195C0) > 3u);
    if (sub_100058654())
    {
      sub_100056E24((uint64_t)"Deferred security enforcement with linkKeyExists %d, remoteSupportsSSP %d, bothTwoDotOne %d, seclevel %d", v65, v66, v67, v68, v69, v70, v71, v63);
      uint64_t v72 = sub_100050B4C(0x37u);
      if (os_log_type_enabled(v72, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)uint64_t v104 = 136446210;
        uint64_t v105 = sub_100050714();
        _os_log_impl((void *)&_mh_execute_header, v72, OS_LOG_TYPE_DEFAULT, " %{public}s", v104, 0xCu);
      }
    }
    if ((dword_100A104C8 - 2) < 3) {
      goto LABEL_98;
    }
    if (dword_100A104C8 != 1)
    {
      if (dword_100A104C8)
      {
        if (sub_100058654())
        {
          uint64_t v74 = dword_100A104C8;
          sub_100178240((uint64_t)&off_100A104B0);
          sub_100056E24((uint64_t)"%d specified for %s, %!", v75, v76, v77, v78, v79, v80, v81, v74);
          unsigned int v82 = sub_100050B4C(0x37u);
          if (os_log_type_enabled(v82, OS_LOG_TYPE_ERROR)) {
            sub_100745764();
          }
        }
        uint64_t v60 = 1418;
        goto LABEL_59;
      }
      goto LABEL_93;
    }
    if (v64)
    {
LABEL_98:
      if (sub_100058654())
      {
        uint64_t v73 = dword_100A104C8;
        sub_100256DA8(HIBYTE(dword_100A104A8), dword_100A104C8, v108);
        sub_100056E24((uint64_t)"Security level %d: state %s, key %s sufficient", v93, v94, v95, v96, v97, v98, v99, v73);
        uint64_t v100 = sub_100050B4C(0x37u);
        if (os_log_type_enabled(v100, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v101 = sub_100050714();
          *(_DWORD *)uint64_t v104 = 136446210;
          uint64_t v105 = v101;
          _os_log_impl((void *)&_mh_execute_header, v100, OS_LOG_TYPE_DEFAULT, " %{public}s", v104, 0xCu);
        }
      }
      *(unsigned char *)(v51 + 4) = 1;
      if (*(_DWORD *)v51) {
        unsigned int v102 = v63;
      }
      else {
        unsigned int v102 = 0;
      }
      if (v102 != 1 || !sub_100256DA8(HIBYTE(dword_100A104A8), dword_100A104C8, v108))
      {
        sub_10025882C();
        return;
      }
      if (*(_DWORD *)v51 != 2)
      {
        sub_1002586F4();
        return;
      }
    }
LABEL_93:
    uint64_t v60 = 0;
LABEL_59:
    sub_10025428C(v60);
    return;
  }
  uint64_t v83 = sub_1000268E4((uint64_t)sub_100257B70, 0, 3, 0);
  if (v83)
  {
    uint64_t v84 = v83;
    if (sub_100058654())
    {
      sub_100056E24((uint64_t)"enforcementDeferredRequest - Could not register function %!", v85, v86, v87, v88, v89, v90, v91, v84);
      uint64_t v92 = sub_100050B4C(0x37u);
      if (os_log_type_enabled(v92, OS_LOG_TYPE_ERROR)) {
        sub_100745764();
      }
    }
    sub_10017C104(&dword_100A10498, 5);
    uint64_t v60 = 1421;
    goto LABEL_59;
  }
}

uint64_t sub_10025828C()
{
  if (dword_100A1048C > 5) {
    uint64_t v0 = "unknown";
  }
  else {
    uint64_t v0 = off_10099F530[dword_100A1048C];
  }
  sub_10025B778("\nsecmgrState: %s\n", v0);
  int v1 = dword_100A1048C;
  if ((dword_100A1048C - 2) <= 3)
  {
    sub_10025B778("current context:\n");
    sub_10025B778("   addr:          %:\n", &dword_100A10498);
    sub_10025B778("   hciHandle:     0x%x\n", &qword_100A104A0);
    sub_10025B778("   mitm reqd:     %B\n", &dword_100A104A8);
    sub_10025B778("   sspInProgress: %B\n", (char *)&dword_100A104A8 + 1);
    sub_10025B778("   isRemoteSSP:   %B\n", (char *)&dword_100A104A8 + 2);
    int v1 = dword_100A1048C;
  }
  switch(v1)
  {
    case 5:
      if (dword_100A104D8 > 3) {
        uint64_t v3 = "unknown";
      }
      else {
        uint64_t v3 = off_10099F598[dword_100A104D8];
      }
      sub_10025B778("   substate:      %s\n", v3);
      sub_10025B778("   cookie:        0x%x\n", dword_100A104C0);
      sub_10025B778("   incomingCnct:  %B\n", byte_100A104C4);
      if (dword_100A104C8 > 4) {
        uint64_t v4 = "unknown";
      }
      else {
        uint64_t v4 = off_10099F5B8[dword_100A104C8];
      }
      sub_10025B778("   secLevel:      %s\n", v4);
      break;
    case 3:
      sub_10025B778("   authReqs:      %d\n");
      goto LABEL_22;
    case 2:
      if (dword_100A104B8 > 6) {
        uint64_t v2 = "unknown";
      }
      else {
        uint64_t v2 = off_10099F560[dword_100A104B8];
      }
      sub_10025B778("   substate:      %s\n", v2);
      sub_10025B778("   finalStatus:   %!\n", dword_100A104BC);
      break;
    default:
      goto LABEL_22;
  }
  sub_10025B778("   callback:      0x%x\n");
LABEL_22:
  sub_10025B778("bondable: %B\n", byte_100A10489);
  sub_10025B778("Connections known to secmgr: %d\n", (unsigned __int16)word_100A10508);
  if (word_100A10508)
  {
    uint64_t v5 = 0;
    unint64_t v6 = 0;
    do
    {
      sub_10025B778("   %: ", *(void *)(qword_100A10480 + v5) + 48);
      uint64_t v7 = *(int *)(qword_100A10480 + v5 + 8);
      uint64_t v8 = "unknown";
      if (v7 <= 2) {
        uint64_t v8 = off_10099F5E0[v7];
      }
      sub_10025B778(", state %s", v8);
      if (*(unsigned char *)(qword_100A10480 + v5 + 13)) {
        sub_10025B778(", auto-rejecting");
      }
      sub_10025B778("\n");
      ++v6;
      v5 += 16;
    }
    while (v6 < (unsigned __int16)word_100A10508);
  }
  sub_10025B778("Pending Enforcement Req: %:, cb %x, cookie %x, incoming %d\n", &dword_100A19790, qword_100A19788, qword_100A197A8, BYTE4(qword_100A197A8));

  return sub_10025B778("\n");
}

void sub_1002585FC(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 8);
  uint64_t v2 = v1 + 8;
  int v3 = sub_1002576E0(*(void **)v1, v1 + 8, *(void *)(v1 + 16), *(void *)(v1 + 24), *(_DWORD *)(v1 + 32), *(unsigned char *)(v1 + 36));
  if (v3 && v3 != 1301)
  {
    if (sub_100058654())
    {
      sub_100056E24((uint64_t)"PolicyEnforceReq failed addr %:, status %!", v4, v5, v6, v7, v8, v9, v10, v2);
      uint64_t v11 = sub_100050B4C(0x37u);
      if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR)) {
        sub_100745764();
      }
    }
    sub_10025828C();
    uint64_t v12 = sub_10017C104(v2, 14);
    if (v12)
    {
      uint64_t v13 = v12;
      if (sub_100058654())
      {
        sub_100056E24((uint64_t)"PolicyEnforceReq Disconnect failed %!", v14, v15, v16, v17, v18, v19, v20, v13);
        uint64_t v21 = sub_100050B4C(0x37u);
        if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR)) {
          sub_100745764();
        }
      }
    }
    sub_10025B8C0();
  }
}

void sub_1002586F4()
{
  if (sub_100058654())
  {
    sub_100056E24((uint64_t)"Send set encryption on", v0, v1, v2, v3, v4, v5, v6, v18);
    uint64_t v7 = sub_100050B4C(0x37u);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 136446210;
      uint64_t v20 = sub_100050714();
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
    }
  }
  uint64_t v8 = sub_10019304C(16);
  if (v8)
  {
    uint64_t v9 = v8;
    if (sub_100058654())
    {
      sub_100056E24((uint64_t)"OI_HCICMD_SetConnectionEncryption %!", v10, v11, v12, v13, v14, v15, v16, v9);
      uint64_t v17 = sub_100050B4C(0x37u);
      if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR)) {
        sub_100745764();
      }
    }
    sub_10025428C(v9);
  }
  else
  {
    dword_100A104D8 = 2;
  }
}

void sub_10025882C()
{
  if (sub_100058654())
  {
    sub_100056E24((uint64_t)"Send authentication request", v0, v1, v2, v3, v4, v5, v6, v18);
    uint64_t v7 = sub_100050B4C(0x37u);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 136446210;
      uint64_t v20 = sub_100050714();
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
    }
  }
  uint64_t v8 = sub_10019304C(15);
  if (v8)
  {
    uint64_t v9 = v8;
    if (sub_100058654())
    {
      sub_100056E24((uint64_t)"OI_HCICMD_AuthenticationRequested %!", v10, v11, v12, v13, v14, v15, v16, v9);
      uint64_t v17 = sub_100050B4C(0x37u);
      if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR)) {
        sub_100745764();
      }
    }
    sub_10025428C(v9);
  }
  else
  {
    dword_100A104D8 = 1;
  }
}

void sub_100258960(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1)
  {
    if (sub_100058654())
    {
      sub_100056E24((uint64_t)"bondingDisconnectCb %!", a2, a3, a4, a5, a6, a7, a8, a1);
      uint64_t v9 = sub_100050B4C(0x37u);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR)) {
        sub_100745764();
      }
    }
  }
  sub_100254494(a1, a2, a3, a4, a5, a6, a7, a8);
}

void sub_1002589D8(uint64_t a1)
{
  if (dword_100A1048C != 2) {
    sub_10025B8C0();
  }
  if (!(void)xmmword_100A104B0) {
    sub_10025B8C0();
  }
  if (!HIDWORD(xmmword_100A104B0)) {
    HIDWORD(xmmword_100A104B0) = a1;
  }
  sub_10017C388();
  DWORD2(xmmword_100A104B0) = 6;
  v2.n128_f64[0] = sub_100253AE4(1);
  uint64_t v3 = (void (*)(uint64_t, __n128))xmmword_100A104B0;
  if ((void)xmmword_100A104B0)
  {
    uint64_t v4 = HIDWORD(xmmword_100A104B0);
    v3(v4, v2);
  }
  else if (sub_100058654())
  {
    sub_100056E24((uint64_t)"bondingFinishWriteAuthCB %!, %!", v5, v6, v7, v8, v9, v10, v11, a1);
    uint64_t v12 = sub_100050B4C(0x37u);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR)) {
      sub_100745764();
    }
  }
}

__int16 *sub_100258ACC(unint64_t a1)
{
  word_100A1050A = 30768;
  char v1 = a0123456789abcd[(a1 >> 8) & 0xF];
  byte_100A1050C = a0123456789abcd[(unint64_t)a1 >> 12];
  byte_100A1050D = v1;
  byte_100A1050E = a0123456789abcd[a1 >> 4];
  byte_100A1050F = a0123456789abcd[a1 & 0xF];
  byte_100A10510 = 0;
  return &word_100A1050A;
}

const char *sub_100258B24(unsigned int *a1)
{
  if (!a1) {
    return "invalid";
  }
  if (*(void *)a1 == 0x10000000000001 && *((void *)a1 + 1) == 0x20000EE02000080) {
    return "SyncMLServer";
  }
  if (*(void *)a1 == 0x10000000000002 && *((void *)a1 + 1) == 0x20000EE02000080) {
    return "SyncMLClient";
  }
  if (*(void *)a1 == 0xFECACADE00000000 && *((void *)a1 + 1) == 0xFECACADEFECACADELL) {
    return "D2D";
  }
  if (*(void *)a1 == 0xDEFACADE00000000 && *((void *)a1 + 1) == 0xFECACADEAFDECADELL) {
    return "WiapGateWay";
  }
  if (*(void *)a1 == 0xDEFACADE00000000 && *((void *)a1 + 1) == 0xFFCACADEAFDECADELL) {
    return "WiapSink";
  }
  if (*(void *)a1 == 0x5F41191DC327ED08 && *((void *)a1 + 1) == 0x770A6A10A222F286) {
    return "WiapGateWay_v2";
  }
  if (*(void *)a1 == 0x5F41191DC327ED08 && *((void *)a1 + 1) == 0x780A6A10A222F286) {
    return "WiapSink_v2";
  }
  if (*(void *)a1 == 0x14DAD0B74EC2172 && *((void *)a1 + 1) == 0x2A72E02B7B99778FLL) {
    return "AapServer";
  }
  if (*(void *)a1 == 0xDE49F4074B7C6F4BLL && *((void *)a1 + 1) == 0x298F720443ABB9B0) {
    return "AapService";
  }
  if (*(void *)a1 == 0x364B2E573619F31FLL && *((void *)a1 + 1) == 0xF4A61A9B40B2BFA2) {
    return "AapClient";
  }
  if (*(void *)a1 == 0x2A43B1001E0DE104 && *((void *)a1 + 1) == 0x41F93A98BADD64B7) {
    return "Magnet";
  }
  if (*(void *)a1 == 0xA24041CD484388ECLL && *((void *)a1 + 1) == 0xD31FBF505D572797) {
    return "Carplay";
  }
  if (*(void *)a1 == 0x1C454DE166248D2DLL && *((void *)a1 + 1) == 0x1A29EAAB0173BC88) {
    return "CarplayGateway";
  }
  if (*(void *)(a1 + 1) == 0x8000008000100000 && a1[3] == -80438433) {
    return sub_100258E24(*a1);
  }
  else {
    return "unknown";
  }
}

const char *sub_100258E24(unint64_t a1)
{
  if ((int)a1 <= 4352)
  {
    if ((int)a1 > 255)
    {
      if ((int)a1 > 4096)
      {
        if (a1 == 4097) {
          return "BrowseGroupDescriptorServiceClassID";
        }
        if (a1 == 4098) {
          return "PublicBrowseGroup";
        }
      }
      else
      {
        if (a1 == 256) {
          return "L2CAP";
        }
        if (a1 == 4096) {
          return "ServiceDiscoveryServerServiceClassID";
        }
      }
      goto LABEL_111;
    }
    uint64_t result = "NULL";
    switch((int)a1)
    {
      case 0:
        return result;
      case 1:
        uint64_t result = "SDP";
        break;
      case 2:
        uint64_t result = "UDP";
        break;
      case 3:
        uint64_t result = "RFCOMM";
        break;
      case 4:
        uint64_t result = "TCP";
        break;
      case 5:
        uint64_t result = "TCS_BIN";
        break;
      case 6:
        uint64_t result = "TCS_AT";
        break;
      case 8:
        uint64_t result = "OBEX";
        break;
      case 9:
        uint64_t result = "IP";
        break;
      case 10:
        uint64_t result = "FTP";
        break;
      case 12:
        uint64_t result = "HTTP";
        break;
      case 14:
        uint64_t result = "WSP";
        break;
      case 15:
        uint64_t result = "BNEP";
        break;
      case 16:
        uint64_t result = "UPNP";
        break;
      case 17:
        uint64_t result = "HIDP";
        break;
      case 18:
        uint64_t result = "HardcopyControlChannel";
        break;
      case 20:
        uint64_t result = "HardcopyDataChannel";
        break;
      case 22:
        uint64_t result = "HardcopyNotification";
        break;
      case 23:
        uint64_t result = "AVCTP";
        break;
      case 25:
        uint64_t result = "AVDTP";
        break;
      default:
        goto LABEL_111;
    }
  }
  else
  {
    if ((int)a1 <= 4607)
    {
      switch((int)a1)
      {
        case 4353:
          uint64_t result = "SerialPort";
          break;
        case 4354:
          uint64_t result = "LANAccessUsingPPP";
          break;
        case 4355:
          uint64_t result = "DialupNetworking";
          break;
        case 4356:
          uint64_t result = "IrMCSync";
          break;
        case 4357:
          uint64_t result = "OBEXObjectPush";
          break;
        case 4358:
          uint64_t result = "OBEXFileTransfer";
          break;
        case 4359:
          uint64_t result = "IrMCSyncCommand";
          break;
        case 4360:
          uint64_t result = "Headset";
          break;
        case 4361:
          uint64_t result = "CordlessTelephony";
          break;
        case 4362:
          uint64_t result = "AudioSource";
          break;
        case 4363:
          uint64_t result = "AudioSink";
          break;
        case 4364:
          uint64_t result = "AV_RemoteControlTarget";
          break;
        case 4365:
          uint64_t result = "AdvancedAudioDistribution";
          break;
        case 4366:
          uint64_t result = "AV_RemoteControl";
          break;
        case 4367:
          uint64_t result = "AV_RemoteControlController";
          break;
        case 4368:
          uint64_t result = "Intercom";
          break;
        case 4369:
          uint64_t result = "Fax";
          break;
        case 4370:
          uint64_t result = "HeadsetAudioGateway";
          break;
        case 4371:
          uint64_t result = "WAP";
          break;
        case 4372:
          uint64_t result = "WAP_CLIENT";
          break;
        case 4373:
          uint64_t result = "PANU";
          break;
        case 4374:
          uint64_t result = "NAP";
          break;
        case 4375:
          uint64_t result = "GN";
          break;
        case 4376:
          uint64_t result = "DirectPrinting";
          break;
        case 4377:
          uint64_t result = "ReferencePrinting";
          break;
        case 4378:
          uint64_t result = "Imaging";
          break;
        case 4379:
          uint64_t result = "ImagingResponder";
          break;
        case 4380:
          uint64_t result = "ImagingAutomaticArchive";
          break;
        case 4381:
          uint64_t result = "ImagingReferencedObjects";
          break;
        case 4382:
          uint64_t result = "Handsfree";
          break;
        case 4383:
          uint64_t result = "HandsfreeAudioGateway";
          break;
        case 4384:
          uint64_t result = "DirectPrintingReferenceObjectsService";
          break;
        case 4385:
          uint64_t result = "ReflectedUI";
          break;
        case 4386:
          uint64_t result = "BasicPrinting";
          break;
        case 4387:
          uint64_t result = "PrintingStatus";
          break;
        case 4388:
          uint64_t result = "HumanInterfaceDeviceService";
          break;
        case 4389:
          uint64_t result = "HardcopyCableReplacement";
          break;
        case 4390:
          uint64_t result = "HCR_Print";
          break;
        case 4391:
          uint64_t result = "HCR_Scan";
          break;
        case 4392:
          uint64_t result = "Common_ISDN_Access";
          break;
        case 4393:
          uint64_t result = "VideoConferencingGW";
          break;
        case 4394:
          uint64_t result = "UID_MT";
          break;
        case 4395:
          uint64_t result = "UID_TA";
          break;
        case 4396:
          uint64_t result = "Audio_Video";
          break;
        case 4397:
          uint64_t result = "SIM_Access";
          break;
        case 4398:
          uint64_t result = "PhonebookAccessClient";
          break;
        case 4399:
          uint64_t result = "PhonebookAccessServer";
          break;
        case 4400:
          uint64_t result = "PhonebookAccess";
          break;
        case 4401:
          uint64_t result = "Headset_HS";
          break;
        case 4402:
          uint64_t result = "Message_Access_Server";
          break;
        case 4403:
          uint64_t result = "OI_UUID_Message_Notification_Server";
          break;
        case 4404:
          uint64_t result = "OI_UUID_Message_Access_Profile";
          break;
        default:
          goto LABEL_111;
      }
      return result;
    }
    if ((int)a1 > 4863)
    {
      if ((int)a1 <= 5119)
      {
        switch((int)a1)
        {
          case 4864:
            uint64_t result = "ESDP_UPNP_IP_PAN";
            break;
          case 4865:
            uint64_t result = "ESDP_UPNP_IP_LAP";
            break;
          case 4866:
            uint64_t result = "ESDP_UPNP_IP_L2CAP";
            break;
          case 4867:
            uint64_t result = "VideoSource";
            break;
          case 4868:
            uint64_t result = "VideoSink";
            break;
          case 4869:
            uint64_t result = "VideoDistribution";
            break;
          default:
            goto LABEL_111;
        }
        return result;
      }
      if ((int)a1 <= 5121)
      {
        if (a1 == 5120) {
          return "Health_Device_Profile";
        }
        else {
          return "Health_Device_Profile_Source";
        }
      }
      if (a1 == 5122) {
        return "Health_Device_Profile_Sink";
      }
      if (a1 == 6145) {
        return "GATT";
      }
LABEL_111:
      uint64_t result = (const char *)&word_100A1050A;
      word_100A1050A = 30768;
      byte_100A1050C = a0123456789abcd[(unsigned __int16)a1 >> 12];
      byte_100A1050D = a0123456789abcd[(a1 >> 8) & 0xF];
      byte_100A1050E = a0123456789abcd[a1 >> 4];
      byte_100A1050F = a0123456789abcd[a1 & 0xF];
      byte_100A10510 = 0;
      return result;
    }
    switch((int)a1)
    {
      case 4608:
        uint64_t result = "PnPInformation";
        break;
      case 4609:
        uint64_t result = "GenericNetworking";
        break;
      case 4610:
        uint64_t result = "GenericFileTransfer";
        break;
      case 4611:
        uint64_t result = "GenericAudio";
        break;
      case 4612:
        uint64_t result = "GenericTelephony";
        break;
      case 4613:
        uint64_t result = "UPNP_Service";
        break;
      case 4614:
        uint64_t result = "UPNP_IP_Service";
        break;
      default:
        goto LABEL_111;
    }
  }
  return result;
}

void *sub_10025959C(uint64_t a1, uint64_t a2)
{
  uint64_t result = sub_100022FE8(0x28uLL);
  if (result)
  {
    *uint64_t result = a1;
    result[1] = a2;
    result[2] = 0;
    result[3] = 0;
    *((_DWORD *)result + 8) = 0;
  }
  return result;
}

void sub_1002595D8(void *ptr)
{
  if (ptr)
  {
    while (1)
    {
      __n128 v2 = (void *)ptr[2];
      if (!v2) {
        break;
      }
      ptr[2] = v2[1];
      uint64_t v3 = (void (*)(void))ptr[1];
      if (v3) {
        v3(*v2);
      }
      sub_100023010(v2);
    }
    sub_100023010(ptr);
  }
}

void sub_100259640(uint64_t a1)
{
  uint64_t v2 = a1 + 16;
  char v1 = *(void **)(a1 + 16);
  if (v1)
  {
    do
    {
      *(void *)(a1 + 16) = v1[1];
      uint64_t v4 = *(void (**)(void))(a1 + 8);
      if (v4) {
        v4(*v1);
      }
      sub_100023010(v1);
      char v1 = *(void **)v2;
    }
    while (*(void *)v2);
  }
  *(void *)uint64_t v2 = 0;
  *(void *)(v2 + 8) = 0;
  *(_DWORD *)(v2 + 16) = 0;
}

void *sub_1002596A4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result = sub_1002596EC((void (**)(void *, uint64_t, uint64_t))a1, a2, a3);
  if (result)
  {
    uint64_t v5 = *(void *)(a1 + 24);
    result[1] = *(void *)(a1 + 16);
    *(void *)(a1 + 16) = result;
    if (!v5) {
      *(void *)(a1 + 24) = result;
    }
    ++*(_DWORD *)(a1 + 32);
  }
  return result;
}

void *sub_1002596EC(void (**a1)(void *, uint64_t, uint64_t), uint64_t a2, uint64_t a3)
{
  uint64_t v6 = sub_100022FE8(0x10uLL);
  uint64_t v7 = v6;
  if (v6)
  {
    v6[1] = 0;
    if (*a1)
    {
      uint64_t v8 = sub_100022FE8(a3);
      *uint64_t v7 = v8;
      if (v8) {
        (*a1)(v8, a2, a3);
      }
    }
    else
    {
      *uint64_t v6 = a2;
    }
  }
  return v7;
}

void *sub_100259764(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result = sub_1002596EC((void (**)(void *, uint64_t, uint64_t))a1, a2, a3);
  if (result)
  {
    result[1] = 0;
    uint64_t v5 = *(void *)(a1 + 24);
    if (v5) {
      *(void *)(v5 + 8) = result;
    }
    *(void *)(a1 + 24) = result;
    if (!*(void *)(a1 + 16)) {
      *(void *)(a1 + 16) = result;
    }
    ++*(_DWORD *)(a1 + 32);
  }
  return result;
}

void *sub_1002597B8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t (*a4)(void, uint64_t))
{
  uint64_t v8 = (void *)(a1 + 16);
  uint64_t v7 = *(void **)(a1 + 16);
  if (v7)
  {
    uint64_t v10 = 0;
    while (1)
    {
      uint64_t v11 = v7;
      uint64_t result = (void *)a4(*v7, a2);
      if (!result) {
        break;
      }
      if ((int)result >= 1)
      {
        uint64_t result = sub_1002596EC((void (**)(void *, uint64_t, uint64_t))a1, a2, a3);
        if (!result) {
          return result;
        }
        result[1] = v11;
        uint64_t v14 = v10 + 1;
        if (!v10) {
          uint64_t v14 = v8;
        }
        *uint64_t v14 = result;
        goto LABEL_15;
      }
      uint64_t v7 = (void *)v11[1];
      uint64_t v10 = v11;
      if (!v7) {
        goto LABEL_6;
      }
    }
  }
  else
  {
LABEL_6:
    uint64_t result = sub_1002596EC((void (**)(void *, uint64_t, uint64_t))a1, a2, a3);
    if (result)
    {
      uint64_t v13 = *(void *)(a1 + 24);
      if (v13) {
        *(void *)(v13 + 8) = result;
      }
      *(void *)(a1 + 24) = result;
      if (!*(void *)(a1 + 16)) {
        *uint64_t v8 = result;
      }
LABEL_15:
      ++*(_DWORD *)(a1 + 32);
    }
  }
  return result;
}

uint64_t sub_10025989C(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 16);
  if (v1) {
    return *(void *)v1;
  }
  else {
    return 0;
  }
}

uint64_t sub_1002598B4(uint64_t a1, int a2)
{
  if (!a1) {
    return 0;
  }
  uint64_t v3 = *(void **)(a1 + 16);
  if (!v3) {
    return 0;
  }
  uint64_t v4 = *v3;
  uint64_t v5 = v3[1];
  if (a2)
  {
    uint64_t v6 = *(void (**)(void))(a1 + 8);
    if (v6)
    {
      v6(*v3);
      uint64_t v3 = *(void **)(a1 + 16);
    }
  }
  sub_100023010(v3);
  *(void *)(a1 + 16) = v5;
  if (!v5) {
    *(void *)(a1 + 24) = 0;
  }
  --*(_DWORD *)(a1 + 32);
  return v4;
}

uint64_t sub_10025992C(uint64_t a1, int a2)
{
  uint64_t v2 = (void *)(a1 + 16);
  if (!*(void *)(a1 + 16)) {
    return 0;
  }
  uint64_t v4 = *(void **)(a1 + 24);
  uint64_t v5 = *v4;
  if (a2)
  {
    uint64_t v6 = *(void (**)(void))(a1 + 8);
    if (v6)
    {
      v6(*v4);
      uint64_t v4 = *(void **)(a1 + 24);
    }
  }
  sub_100023010(v4);
  uint64_t v8 = *(void *)(a1 + 16);
  uint64_t v7 = *(void *)(a1 + 24);
  if (v8 == v7)
  {
    uint64_t v9 = 0;
  }
  else
  {
    do
    {
      uint64_t v9 = v8;
      uint64_t v8 = *(void *)(v8 + 8);
    }
    while (v8 != v7);
    uint64_t v2 = (void *)(v9 + 8);
  }
  *uint64_t v2 = 0;
  *(void *)(a1 + 24) = v9;
  --*(_DWORD *)(a1 + 32);
  return v5;
}

uint64_t sub_1002599CC(uint64_t a1)
{
  return *(void *)(a1 + 16);
}

uint64_t sub_1002599D4(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = *(void *)(*(void *)result + 8);
    *(void *)uint64_t result = v1;
    return v1 != 0;
  }
  return result;
}

uint64_t sub_1002599F0(uint64_t a1)
{
  return *(void *)a1;
}

uint64_t sub_1002599F8(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(result + 16);
  if (v2 != a2)
  {
    uint64_t v3 = *(void *)(result + 16);
    while (v3)
    {
      uint64_t v4 = v3;
      uint64_t v3 = *(void *)(v3 + 8);
      if (v3 == a2)
      {
        *(void *)(v4 + 8) = *(void *)(a2 + 8);
        *(void *)(a2 + 8) = v2;
        *(void *)(result + 16) = a2;
        if (*(void *)(result + 24) == a2) {
          *(void *)(result + 24) = v4;
        }
        return result;
      }
    }
  }
  return result;
}

void sub_100259A44(uint64_t a1, void *ptr, int a3)
{
  uint64_t v3 = *(void **)(a1 + 16);
  if (!v3) {
    return;
  }
  if (v3 == ptr)
  {
    uint64_t v5 = 0;
LABEL_8:
    uint64_t v6 = ptr[1];
    if (v5)
    {
      v5[1] = v6;
      if (ptr[1]) {
        goto LABEL_11;
      }
    }
    else
    {
      *(void *)(a1 + 16) = v6;
      if (v6)
      {
LABEL_11:
        --*(_DWORD *)(a1 + 32);
        if (a3)
        {
          uint64_t v7 = *(void (**)(void))(a1 + 8);
          if (v7) {
            v7(*ptr);
          }
        }
        sub_100023010(ptr);
        return;
      }
    }
    *(void *)(a1 + 24) = v5;
    goto LABEL_11;
  }
  while (1)
  {
    uint64_t v5 = v3;
    uint64_t v3 = (void *)v3[1];
    if (!v3) {
      break;
    }
    if (v3 == ptr) {
      goto LABEL_8;
    }
  }
}

void sub_100259AF4(void *a1, void *ptr, int a3)
{
  uint64_t v4 = (void *)a1[2];
  if (v4 == ptr)
  {
    sub_100259640((uint64_t)a1);
  }
  else
  {
    uint64_t v6 = ptr;
    do
    {
      uint64_t v7 = v4;
      uint64_t v4 = (void *)v4[1];
      if (v4) {
        BOOL v8 = v4 == ptr;
      }
      else {
        BOOL v8 = 1;
      }
    }
    while (!v8);
    if (v4)
    {
      v7[1] = 0;
      a1[3] = v7;
      if (ptr)
      {
        do
        {
          uint64_t v9 = v6;
          uint64_t v6 = (void *)v6[1];
          if (a3)
          {
            uint64_t v10 = (void (*)(void))a1[1];
            if (v10) {
              v10(*v9);
            }
          }
          sub_100023010(v9);
        }
        while (v6);
      }
    }
  }
}

double sub_100259BA0(uint64_t a1)
{
  double result = -3.59869635e230;
  *(_OWORD *)a1 = xmmword_1007BACF0;
  *(void *)(a1 + 16) = 0;
  return result;
}

void *sub_100259BB4(uint64_t a1, long long *__src, size_t a3)
{
  __int16 v3 = a3;
  uint64_t v4 = __src;
  int v6 = *(_DWORD *)(a1 + 16);
  *(_DWORD *)(a1 + 16) = v6 + a3;
  if (__CFADD__(v6, a3)) {
    ++*(_DWORD *)(a1 + 20);
  }
  uint64_t v7 = v6 & 0x3F;
  uint64_t v8 = 64 - v7;
  if (64 - (int)v7 <= a3)
  {
    uint64_t v10 = (_OWORD *)(a1 + 24);
    memmove((void *)(a1 - v8 + 88), __src, v8);
    uint64_t v11 = 0;
    do
      v11 += 4;
    while (v11 != 64);
    sub_100259CD4((_DWORD *)a1, (int *)(a1 + 24));
    uint64_t v4 = (long long *)((char *)v4 + v8);
    unsigned __int16 v12 = v3 - v8;
    if (v12 >= 0x40u)
    {
      do
      {
        uint64_t v13 = 0;
        long long v14 = *v4;
        long long v15 = v4[1];
        long long v16 = v4[3];
        *(_OWORD *)(a1 + 56) = v4[2];
        *(_OWORD *)(a1 + 72) = v16;
        *uint64_t v10 = v14;
        *(_OWORD *)(a1 + 40) = v15;
        do
          v13 += 4;
        while (v13 != 64);
        sub_100259CD4((_DWORD *)a1, (int *)(a1 + 24));
        v4 += 4;
        v12 -= 64;
      }
      while (v12 > 0x3Fu);
    }
    a3 = v12;
    uint64_t v9 = (void *)(a1 + 24);
  }
  else
  {
    uint64_t v9 = (void *)(a1 - v8 + 88);
    a3 = a3;
  }

  return memmove(v9, v4, a3);
}

_DWORD *sub_100259CD4(_DWORD *result, int *a2)
{
  int v2 = result[1];
  int v4 = result[2];
  int v3 = result[3];
  int v5 = *a2;
  int v6 = a2[1];
  HIDWORD(v7) = *result + *a2 - 680876936 + (v4 & v2 | v3 & ~v2);
  LODWORD(v7) = HIDWORD(v7);
  int v8 = (v7 >> 25) + v2;
  HIDWORD(v7) = v3 + v6 - 389564586 + (v2 & v8 | v4 & ~v8);
  LODWORD(v7) = HIDWORD(v7);
  int v9 = (v7 >> 20) + v8;
  int v10 = a2[2];
  int v11 = a2[3];
  HIDWORD(v7) = v4 + v10 + 606105819 + (v8 & v9 | v2 & ~v9);
  LODWORD(v7) = HIDWORD(v7);
  int v12 = (v7 >> 15) + v9;
  HIDWORD(v7) = v2 + v11 - 1044525330 + (v9 & v12 | v8 & ~v12);
  LODWORD(v7) = HIDWORD(v7);
  int v13 = (v7 >> 10) + v12;
  int v15 = a2[4];
  int v14 = a2[5];
  HIDWORD(v7) = v15 + v8 - 176418897 + (v12 & v13 | v9 & ~v13);
  LODWORD(v7) = HIDWORD(v7);
  int v16 = (v7 >> 25) + v13;
  HIDWORD(v7) = v14 + v9 + 1200080426 + (v13 & v16 | v12 & ~v16);
  LODWORD(v7) = HIDWORD(v7);
  int v17 = (v7 >> 20) + v16;
  int v18 = a2[6];
  int v19 = a2[7];
  HIDWORD(v7) = v18 + v12 - 1473231341 + (v16 & v17 | v13 & ~v17);
  LODWORD(v7) = HIDWORD(v7);
  int v20 = (v7 >> 15) + v17;
  HIDWORD(v7) = v19 + v13 - 45705983 + (v17 & v20 | v16 & ~v20);
  LODWORD(v7) = HIDWORD(v7);
  int v21 = (v7 >> 10) + v20;
  int v22 = a2[8];
  int v23 = a2[9];
  HIDWORD(v7) = v22 + v16 + 1770035416 + (v20 & v21 | v17 & ~v21);
  LODWORD(v7) = HIDWORD(v7);
  int v24 = (v7 >> 25) + v21;
  HIDWORD(v7) = v23 + v17 - 1958414417 + (v21 & v24 | v20 & ~v24);
  LODWORD(v7) = HIDWORD(v7);
  int v25 = (v7 >> 20) + v24;
  int v27 = a2[10];
  int v26 = a2[11];
  HIDWORD(v7) = v27 + v20 - 42063 + (v24 & v25 | v21 & ~v25);
  LODWORD(v7) = HIDWORD(v7);
  int v28 = (v7 >> 15) + v25;
  HIDWORD(v7) = v26 + v21 - 1990404162 + (v25 & v28 | v24 & ~v28);
  LODWORD(v7) = HIDWORD(v7);
  int v29 = (v7 >> 10) + v28;
  int v31 = a2[12];
  int v30 = a2[13];
  HIDWORD(v7) = v31 + v24 + 1804603682 + (v28 & v29 | v25 & ~v29);
  LODWORD(v7) = HIDWORD(v7);
  int v32 = (v7 >> 25) + v29;
  HIDWORD(v7) = v30 + v25 - 40341101 + (v29 & v32 | v28 & ~v32);
  LODWORD(v7) = HIDWORD(v7);
  int v33 = (v7 >> 20) + v32;
  int v35 = a2[14];
  int v34 = a2[15];
  HIDWORD(v7) = v35 + v28 - 1502002290 + (v32 & v33 | v29 & ~v33);
  LODWORD(v7) = HIDWORD(v7);
  int v36 = (v7 >> 15) + v33;
  HIDWORD(v7) = v34 + v29 + 1236535329 + (v33 & v36 | v32 & ~v36);
  LODWORD(v7) = HIDWORD(v7);
  int v37 = (v7 >> 10) + v36;
  HIDWORD(v7) = v6 + v32 - 165796510 + (v37 & v33 | v36 & ~v33);
  LODWORD(v7) = HIDWORD(v7);
  int v38 = (v7 >> 27) + v37;
  HIDWORD(v7) = v18 + v33 - 1069501632 + (v38 & v36 | v37 & ~v36);
  LODWORD(v7) = HIDWORD(v7);
  int v39 = (v7 >> 23) + v38;
  HIDWORD(v7) = v26 + v36 + 643717713 + (v39 & v37 | v38 & ~v37);
  LODWORD(v7) = HIDWORD(v7);
  int v40 = (v7 >> 18) + v39;
  HIDWORD(v7) = v5 + v37 - 373897302 + (v40 & v38 | v39 & ~v38);
  LODWORD(v7) = HIDWORD(v7);
  int v41 = (v7 >> 12) + v40;
  HIDWORD(v7) = v14 + v38 - 701558691 + (v41 & v39 | v40 & ~v39);
  LODWORD(v7) = HIDWORD(v7);
  int v42 = (v7 >> 27) + v41;
  HIDWORD(v7) = v27 + v39 + 38016083 + (v42 & v40 | v41 & ~v40);
  LODWORD(v7) = HIDWORD(v7);
  int v43 = (v7 >> 23) + v42;
  HIDWORD(v7) = v34 + v40 - 660478335 + (v43 & v41 | v42 & ~v41);
  LODWORD(v7) = HIDWORD(v7);
  int v44 = (v7 >> 18) + v43;
  HIDWORD(v7) = v15 + v41 - 405537848 + (v44 & v42 | v43 & ~v42);
  LODWORD(v7) = HIDWORD(v7);
  int v45 = (v7 >> 12) + v44;
  HIDWORD(v7) = v23 + v42 + 568446438 + (v45 & v43 | v44 & ~v43);
  LODWORD(v7) = HIDWORD(v7);
  int v46 = (v7 >> 27) + v45;
  HIDWORD(v7) = v35 + v43 - 1019803690 + (v46 & v44 | v45 & ~v44);
  LODWORD(v7) = HIDWORD(v7);
  int v47 = (v7 >> 23) + v46;
  HIDWORD(v7) = v11 + v44 - 187363961 + (v47 & v45 | v46 & ~v45);
  LODWORD(v7) = HIDWORD(v7);
  int v48 = (v7 >> 18) + v47;
  HIDWORD(v7) = v22 + v45 + 1163531501 + (v48 & v46 | v47 & ~v46);
  LODWORD(v7) = HIDWORD(v7);
  int v49 = (v7 >> 12) + v48;
  HIDWORD(v7) = v30 + v46 - 1444681467 + (v49 & v47 | v48 & ~v47);
  LODWORD(v7) = HIDWORD(v7);
  int v50 = (v7 >> 27) + v49;
  HIDWORD(v7) = v10 + v47 - 51403784 + (v50 & v48 | v49 & ~v48);
  LODWORD(v7) = HIDWORD(v7);
  int v51 = (v7 >> 23) + v50;
  HIDWORD(v7) = v19 + v48 + 1735328473 + (v51 & v49 | v50 & ~v49);
  LODWORD(v7) = HIDWORD(v7);
  int v52 = (v7 >> 18) + v51;
  HIDWORD(v7) = v31 + v49 - 1926607734 + ((v52 ^ v51) & v50 ^ v51);
  LODWORD(v7) = HIDWORD(v7);
  int v53 = (v7 >> 12) + v52;
  HIDWORD(v7) = v14 + v50 - 378558 + (v52 ^ v51 ^ v53);
  LODWORD(v7) = HIDWORD(v7);
  int v54 = (v7 >> 28) + v53;
  HIDWORD(v7) = v22 + v51 - 2022574463 + (v53 ^ v52 ^ v54);
  LODWORD(v7) = HIDWORD(v7);
  int v55 = (v7 >> 21) + v54;
  HIDWORD(v7) = v26 + v52 + 1839030562 + (v54 ^ v53 ^ v55);
  LODWORD(v7) = HIDWORD(v7);
  int v56 = (v7 >> 16) + v55;
  HIDWORD(v7) = v35 + v53 - 35309556 + (v55 ^ v54 ^ v56);
  LODWORD(v7) = HIDWORD(v7);
  int v57 = (v7 >> 9) + v56;
  HIDWORD(v7) = v6 + v54 - 1530992060 + (v56 ^ v55 ^ v57);
  LODWORD(v7) = HIDWORD(v7);
  int v58 = (v7 >> 28) + v57;
  HIDWORD(v7) = v15 + v55 + 1272893353 + (v57 ^ v56 ^ v58);
  LODWORD(v7) = HIDWORD(v7);
  int v59 = (v7 >> 21) + v58;
  HIDWORD(v7) = v19 + v56 - 155497632 + (v58 ^ v57 ^ v59);
  LODWORD(v7) = HIDWORD(v7);
  int v60 = (v7 >> 16) + v59;
  HIDWORD(v7) = v27 + v57 - 1094730640 + (v59 ^ v58 ^ v60);
  LODWORD(v7) = HIDWORD(v7);
  int v61 = (v7 >> 9) + v60;
  HIDWORD(v7) = v30 + v58 + 681279174 + (v60 ^ v59 ^ v61);
  LODWORD(v7) = HIDWORD(v7);
  int v62 = (v7 >> 28) + v61;
  HIDWORD(v7) = v5 + v59 - 358537222 + (v61 ^ v60 ^ v62);
  LODWORD(v7) = HIDWORD(v7);
  int v63 = (v7 >> 21) + v62;
  HIDWORD(v7) = v11 + v60 - 722521979 + (v62 ^ v61 ^ v63);
  LODWORD(v7) = HIDWORD(v7);
  int v64 = (v7 >> 16) + v63;
  HIDWORD(v7) = v18 + v61 + 76029189 + (v63 ^ v62 ^ v64);
  LODWORD(v7) = HIDWORD(v7);
  int v65 = (v7 >> 9) + v64;
  HIDWORD(v7) = v23 + v62 - 640364487 + (v64 ^ v63 ^ v65);
  LODWORD(v7) = HIDWORD(v7);
  int v66 = (v7 >> 28) + v65;
  HIDWORD(v7) = v31 + v63 - 421815835 + (v65 ^ v64 ^ v66);
  LODWORD(v7) = HIDWORD(v7);
  int v67 = (v7 >> 21) + v66;
  HIDWORD(v7) = v34 + v64 + 530742520 + (v66 ^ v65 ^ v67);
  LODWORD(v7) = HIDWORD(v7);
  int v68 = (v7 >> 16) + v67;
  HIDWORD(v7) = v10 + v65 - 995338651 + (v67 ^ v66 ^ v68);
  LODWORD(v7) = HIDWORD(v7);
  int v69 = (v7 >> 9) + v68;
  HIDWORD(v7) = v5 + v66 - 198630844 + ((v69 | ~v67) ^ v68);
  LODWORD(v7) = HIDWORD(v7);
  int v70 = (v7 >> 26) + v69;
  HIDWORD(v7) = v19 + v67 + 1126891415 + ((v70 | ~v68) ^ v69);
  LODWORD(v7) = HIDWORD(v7);
  int v71 = (v7 >> 22) + v70;
  HIDWORD(v7) = v35 + v68 - 1416354905 + ((v71 | ~v69) ^ v70);
  LODWORD(v7) = HIDWORD(v7);
  int v72 = (v7 >> 17) + v71;
  HIDWORD(v7) = v14 + v69 - 57434055 + ((v72 | ~v70) ^ v71);
  LODWORD(v7) = HIDWORD(v7);
  int v73 = (v7 >> 11) + v72;
  HIDWORD(v7) = v31 + v70 + 1700485571 + ((v73 | ~v71) ^ v72);
  LODWORD(v7) = HIDWORD(v7);
  int v74 = (v7 >> 26) + v73;
  HIDWORD(v7) = v11 + v71 - 1894986606 + ((v74 | ~v72) ^ v73);
  LODWORD(v7) = HIDWORD(v7);
  int v75 = (v7 >> 22) + v74;
  HIDWORD(v7) = v27 + v72 - 1051523 + ((v75 | ~v73) ^ v74);
  LODWORD(v7) = HIDWORD(v7);
  int v76 = (v7 >> 17) + v75;
  HIDWORD(v7) = v6 + v73 - 2054922799 + ((v76 | ~v74) ^ v75);
  LODWORD(v7) = HIDWORD(v7);
  int v77 = (v7 >> 11) + v76;
  HIDWORD(v7) = v22 + v74 + 1873313359 + ((v77 | ~v75) ^ v76);
  LODWORD(v7) = HIDWORD(v7);
  int v78 = (v7 >> 26) + v77;
  HIDWORD(v7) = v34 + v75 - 30611744 + ((v78 | ~v76) ^ v77);
  LODWORD(v7) = HIDWORD(v7);
  int v79 = (v7 >> 22) + v78;
  HIDWORD(v7) = v18 + v76 - 1560198380 + ((v79 | ~v77) ^ v78);
  LODWORD(v7) = HIDWORD(v7);
  int v80 = (v7 >> 17) + v79;
  HIDWORD(v7) = v30 + v77 + 1309151649 + ((v80 | ~v78) ^ v79);
  LODWORD(v7) = HIDWORD(v7);
  int v81 = (v7 >> 11) + v80;
  HIDWORD(v7) = v15 + v78 - 145523070 + ((v81 | ~v79) ^ v80);
  LODWORD(v7) = HIDWORD(v7);
  int v82 = (v7 >> 26) + v81;
  HIDWORD(v7) = v26 + v79 - 1120210379 + ((v82 | ~v80) ^ v81);
  LODWORD(v7) = HIDWORD(v7);
  int v83 = (v7 >> 22) + v82;
  HIDWORD(v7) = v10 + v80 + 718787259 + ((v83 | ~v81) ^ v82);
  LODWORD(v7) = HIDWORD(v7);
  int v84 = (v7 >> 17) + v83;
  HIDWORD(v7) = v23 + v81 - 343485551 + ((v84 | ~v82) ^ v83);
  LODWORD(v7) = HIDWORD(v7);
  *result += v82;
  result[1] = v84 + v2 + (v7 >> 11);
  result[2] = v84 + v4;
  result[3] = v83 + v3;
  return result;
}

double sub_10025A6B0(_OWORD *a1, uint64_t a2)
{
  uint64_t v4 = *(_DWORD *)(a2 + 16) & 0x3F;
  int v5 = (int *)(a2 + 24);
  int v6 = (unsigned char *)(a2 + 24 + v4);
  *int v6 = 0x80;
  unint64_t v7 = (int *)(v6 + 1);
  if (v4 < 0x38)
  {
    int v9 = 55 - v4;
  }
  else
  {
    bzero(v7, v4 ^ 0x3F);
    uint64_t v8 = 0;
    do
      v8 += 4;
    while (v8 != 64);
    sub_100259CD4((_DWORD *)a2, v5);
    int v9 = 56;
    unint64_t v7 = v5;
  }
  bzero(v7, (v9 + 8));
  uint64_t v10 = 0;
  do
    v10 += 4;
  while (v10 != 56);
  *(void *)(a2 + 80) = 8 * *(void *)(a2 + 16);
  sub_100259CD4((_DWORD *)a2, v5);
  uint64_t v11 = 0;
  do
    v11 += 4;
  while (v11 != 16);
  *a1 = *(_OWORD *)a2;
  *(void *)(a2 + 80) = 0;
  double result = 0.0;
  *(_OWORD *)(a2 + 48) = 0u;
  *(_OWORD *)(a2 + 64) = 0u;
  *(_OWORD *)(a2 + 16) = 0u;
  *(_OWORD *)(a2 + 32) = 0u;
  *(_OWORD *)a2 = 0u;
  return result;
}

void sub_10025A794(uint64_t a1)
{
  if (sub_100058654())
  {
    sub_100056E24((uint64_t)"WARNING!!! ByteStream_NumReadBytesAvail fault at File:%s, Line:%d, Func:%s", v2, v3, v4, v5, v6, v7, v8, a1);
    int v9 = sub_100050B4C(0x39u);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 136446210;
      uint64_t v11 = sub_100050714();
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
    }
  }
}

uint64_t sub_10025A86C(uint64_t *a1, unsigned int a2, uint64_t a3, unsigned int a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  if (!a1) {
    sub_10014327C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/support/oi_bytestream.c", 142, "bs");
  }
  if (!*a1) {
    sub_10014327C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/support/oi_bytestream.c", 143, "ByteStream_GetDataPointer(*bs)");
  }
  int v73 = &a9;
  if (a4)
  {
    uint64_t v10 = a3;
    uint64_t v12 = 0;
    uint64_t v13 = a4;
    int v14 = "OI_STATUS ByteStream_Parse(OI_BYTE_STREAM *, int, const char *, unsigned int, ...)";
    while (1)
    {
      switch(*(unsigned char *)(v10 + v12))
      {
        case 0:
        case 1:
          int v17 = v73++;
          if (*((unsigned char *)a1 + 14) != 1) {
            sub_10014327C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/support/oi_bytestream.c", 151, "(*bs).__RWFlag == BYTESTREAM_READ");
          }
          if (*((unsigned char *)a1 + 15)) {
            goto LABEL_74;
          }
          uint64_t v39 = *((unsigned __int16 *)a1 + 6);
          if (*((unsigned __int16 *)a1 + 5) <= v39) {
            goto LABEL_75;
          }
          int v40 = (unsigned char *)*v17;
          uint64_t v41 = *a1;
          *((_WORD *)a1 + 6) = v39 + 1;
          *int v40 = *(unsigned char *)(v41 + v39);
          goto LABEL_76;
        case 2:
        case 3:
        case 0xC:
          int v15 = v73++;
          if (*((unsigned char *)a1 + 14) != 1)
          {
            int v67 = "(*bs).__RWFlag == BYTESTREAM_READ";
            goto LABEL_88;
          }
          if (a2 >= 2)
          {
            int v67 = "((byteorder) == OI_BIG_ENDIAN_BYTE_ORDER) || ((byteorder) == OI_LITTLE_ENDIAN_BYTE_ORDER)";
LABEL_88:
            sub_10014327C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/support/oi_bytestream.c", 157, v67);
          }
          if (*((unsigned char *)a1 + 15))
          {
LABEL_74:
            sub_10025A794((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/support/oi_bytestream.c");
LABEL_75:
            *((unsigned char *)a1 + 15) = 1;
            goto LABEL_76;
          }
          uint64_t v19 = *((unsigned __int16 *)a1 + 6);
          if (*((unsigned __int16 *)a1 + 5) - (int)v19 < 2) {
            goto LABEL_75;
          }
          int v20 = (_WORD *)*v15;
          int v21 = (unsigned __int8 *)(*a1 + v19);
          if (a2) {
            int v22 = v21 + 1;
          }
          else {
            int v22 = v21;
          }
          if (!a2) {
            ++v21;
          }
          *int v20 = *v21 | (*v22 << 8);
          __int16 v23 = *((_WORD *)a1 + 6) + 2;
LABEL_82:
          *((_WORD *)a1 + 6) = v23;
LABEL_76:
          if (++v12 == v13) {
            goto LABEL_83;
          }
          break;
        case 4:
        case 5:
          int v18 = (unsigned int **)v73++;
          if (*((unsigned char *)a1 + 14) != 1)
          {
            int v69 = "(*bs).__RWFlag == BYTESTREAM_READ";
            goto LABEL_95;
          }
          if (a2 >= 2)
          {
            int v69 = "((byteorder) == OI_BIG_ENDIAN_BYTE_ORDER) || ((byteorder) == OI_LITTLE_ENDIAN_BYTE_ORDER)";
LABEL_95:
            sub_10014327C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/support/oi_bytestream.c", 162, v69);
          }
          if (*((unsigned char *)a1 + 15)) {
            goto LABEL_74;
          }
          uint64_t v42 = *((unsigned __int16 *)a1 + 6);
          if (*((unsigned __int16 *)a1 + 5) - (int)v42 < 3) {
            goto LABEL_75;
          }
          int v43 = (unsigned __int16 *)(*a1 + v42);
          if (a2)
          {
            unsigned int v45 = *v43++;
            unsigned int v44 = v45;
          }
          else
          {
            unsigned int v44 = __rev16(*(unsigned __int16 *)((char *)v43 + 1));
          }
          **int v18 = v44 | (*(unsigned __int8 *)v43 << 16);
          __int16 v23 = v42 + 3;
          goto LABEL_82;
        case 6:
        case 7:
        case 0xD:
          int v16 = (unsigned int **)v73++;
          if (*((unsigned char *)a1 + 14) != 1)
          {
            int v68 = "(*bs).__RWFlag == BYTESTREAM_READ";
            goto LABEL_91;
          }
          if (a2 >= 2)
          {
            int v68 = "((byteorder) == OI_BIG_ENDIAN_BYTE_ORDER) || ((byteorder) == OI_LITTLE_ENDIAN_BYTE_ORDER)";
LABEL_91:
            sub_10014327C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/support/oi_bytestream.c", 168, v68);
          }
          if (*((unsigned char *)a1 + 15)) {
            goto LABEL_74;
          }
          uint64_t v24 = *((unsigned __int16 *)a1 + 6);
          if (*((unsigned __int16 *)a1 + 5) - (int)v24 < 4) {
            goto LABEL_75;
          }
          int v25 = (unsigned int *)(*a1 + v24);
          if (a2) {
            unsigned int v26 = *v25;
          }
          else {
            unsigned int v26 = bswap32(*v25);
          }
          **int v16 = v26;
          __int16 v23 = v24 + 4;
          goto LABEL_82;
        case 0xA:
          int v27 = v73;
          int v28 = (unsigned char *)*v73;
          v73 += 2;
          if (*((unsigned char *)a1 + 14) != 1) {
            sub_10014327C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/support/oi_bytestream.c", 174, "(*bs).__RWFlag == BYTESTREAM_READ");
          }
          int v29 = v14;
          int v30 = (_WORD *)v27[1];
          uint64_t v71 = *a1;
          uint64_t v31 = *((unsigned __int16 *)a1 + 6);
          uint64_t v32 = (unsigned __int16)*v30;
          if (*((unsigned char *)a1 + 15))
          {
            sub_10025A794((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/support/oi_bytestream.c");
            int v33 = 0;
          }
          else
          {
            int v33 = *((unsigned __int16 *)a1 + 5) - v31;
          }
          int v34 = (unsigned __int16)*v30;
          if (v33 >= v34)
          {
            if (v32)
            {
              int v46 = (char *)(v71 + v31);
              int v47 = &v28[v32];
              do
              {
                char v48 = *v46++;
                *v28++ = v48;
              }
              while (v28 < v47);
              LOWORD(v34) = *v30;
            }
            *((_WORD *)a1 + 6) += v34;
          }
          else
          {
            *((unsigned char *)a1 + 15) = 1;
          }
          int v14 = v29;
          uint64_t v10 = a3;
          goto LABEL_76;
        case 0xB:
          int v35 = v73++;
          if (*((unsigned char *)a1 + 14) != 1)
          {
            int v70 = "(*bs).__RWFlag == BYTESTREAM_READ";
            goto LABEL_100;
          }
          if (a2 >= 2)
          {
            int v70 = "((byteorder) == OI_BIG_ENDIAN_BYTE_ORDER) || ((byteorder) == OI_LITTLE_ENDIAN_BYTE_ORDER)";
LABEL_100:
            sub_10014327C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/support/oi_bytestream.c", 178, v70);
          }
          if (*((unsigned char *)a1 + 15)) {
            goto LABEL_74;
          }
          uint64_t v62 = *((unsigned __int16 *)a1 + 6);
          if (*((unsigned __int16 *)a1 + 5) - (int)v62 < 6) {
            goto LABEL_75;
          }
          uint64_t v63 = *v35;
          uint64_t v64 = *a1 + v62;
          if (a2)
          {
            sub_100008A18(v63, v64, 6uLL);
          }
          else
          {
            int v65 = *(_DWORD *)v64;
            *(_WORD *)(v63 + 4) = *(_WORD *)(v64 + 4);
            *(_DWORD *)uint64_t v63 = v65;
          }
          __int16 v23 = *((_WORD *)a1 + 6) + 6;
          goto LABEL_82;
        case 0xE:
          int v36 = v73++;
          if (*((unsigned char *)a1 + 14) != 1) {
            sub_10014327C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/support/oi_bytestream.c", 182, "(*bs).__RWFlag == BYTESTREAM_READ");
          }
          if (*((unsigned char *)a1 + 15))
          {
            sub_10025A794((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/support/oi_bytestream.c");
            int v37 = *((unsigned __int8 *)a1 + 14);
            *((unsigned char *)a1 + 15) = 1;
            if (v37 != 1) {
              sub_10014327C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/support/oi_bytestream.c", 183, "(*bs).__RWFlag == BYTESTREAM_READ");
            }
            goto LABEL_74;
          }
          uint64_t v49 = *((unsigned __int16 *)a1 + 6);
          if (*((unsigned __int16 *)a1 + 5) - (int)v49 <= 3)
          {
            *((unsigned char *)a1 + 15) = 1;
            goto LABEL_74;
          }
          int v50 = (_DWORD *)*v36;
          uint64_t v51 = *a1;
          int v52 = (_DWORD *)*v36;
          *int v52 = bswap32(*(_DWORD *)(*a1 + v49));
          int v53 = v52 + 4;
          unsigned __int16 v54 = v49 + 4;
          *((_WORD *)a1 + 6) = v54;
          if (*((unsigned __int16 *)a1 + 5) - (unint64_t)v54 < 0xC) {
            goto LABEL_75;
          }
          int v55 = (char *)(v51 + v54);
          int v56 = v50 + 1;
          do
          {
            char v57 = *v55++;
            *v56++ = v57;
          }
          while (v56 < (unsigned char *)v53);
          __int16 v23 = *((_WORD *)a1 + 6) + 12;
          goto LABEL_82;
        case 0x10:
          int v38 = v73++;
          if (*((unsigned char *)a1 + 14) != 1) {
            sub_10014327C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/support/oi_bytestream.c", 188, "(*bs).__RWFlag == BYTESTREAM_READ");
          }
          if (*((unsigned char *)a1 + 15)) {
            goto LABEL_74;
          }
          uint64_t v58 = *((unsigned __int16 *)a1 + 6);
          if (*((unsigned __int16 *)a1 + 5) - (int)v58 < 16) {
            goto LABEL_75;
          }
          uint64_t v59 = 0;
          uint64_t v60 = *v38;
          uint64_t v61 = *a1 + v58;
          do
          {
            *(unsigned char *)(v60 + v59) = *(unsigned char *)(v61 + v59);
            ++v59;
          }
          while (v59 != 16);
          __int16 v23 = *((_WORD *)a1 + 6) + 16;
          goto LABEL_82;
        default:
          sub_10014327C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/support/oi_bytestream.c", 192, "FALSE");
      }
    }
  }
LABEL_83:
  if (*((unsigned char *)a1 + 15)) {
    return 1031;
  }
  else {
    return 0;
  }
}

uint64_t sub_10025AF38(void *a1)
{
  if (!dword_100A19854)
  {
    for (uint64_t i = 0; i != 10; i += 2)
      qword_100A10518[i] = 0;
    dword_100A19854 = 1;
  }
  if (!*a1) {
    sub_10025B8C0();
  }
  if (!a1[1]) {
    sub_10025B8C0();
  }
  uint64_t v3 = 0;
  for (uint64_t j = &stru_100000020.vmsize; j != -16; j -= 16)
  {
    uint64_t v5 = *(void **)((char *)qword_100A10518 + j);
    if (v5)
    {
      if (v5 == a1)
      {
        sub_10025B8C0();
        return 105;
      }
    }
    else
    {
      uint64_t v3 = (char *)qword_100A10518 + j;
    }
  }
  if (v3)
  {
    *(void *)uint64_t v3 = a1;
    *((void *)v3 + 1) = 0x100000001;
    sub_10025B074((uint64_t)v3);
    if (*((_DWORD *)v3 + 3) == 2)
    {
      if (sub_100058654())
      {
        sub_100056E24((uint64_t)"Command chain initiation failed in first command", v6, v7, v8, v9, v10, v11, v12, v15);
        uint64_t v13 = sub_100050B4C(0x29u);
        if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR)) {
          sub_10074AB50(v13);
        }
      }
      *(void *)uint64_t v3 = 0;
      *((_DWORD *)v3 + 3) = 0;
      return 1023;
    }
    else
    {
      uint64_t result = 0;
      *((_DWORD *)v3 + 3) = 3;
    }
  }
  else
  {
    sub_10025B8C0();
    return 104;
  }
  return result;
}

uint64_t sub_10025B074(uint64_t result)
{
  uint64_t v1 = *(int *)(result + 8);
  uint64_t v2 = *(uint64_t (**)(void))(*(void *)result + 8 * v1);
  if (v2)
  {
    *(_DWORD *)(result + 8) = v1 + 1;
    return v2();
  }
  else if (*(_DWORD *)(result + 12) == 1)
  {
    *(_DWORD *)(result + 12) = 2;
  }
  else
  {
    uint64_t v3 = **(uint64_t (***)(void))result;
    *(void *)uint64_t result = 0;
    *(_DWORD *)(result + 12) = 0;
    return v3(0);
  }
  return result;
}

void sub_10025B0BC(uint64_t a1)
{
  if (!dword_100A19854) {
    sub_10025B8C0();
  }
  uint64_t v2 = 0;
  while (qword_100A10518[v2] != a1)
  {
    v2 += 2;
    if (v2 == 10)
    {
      sub_10025B8C0();
      return;
    }
  }

  sub_10025B074((uint64_t)&qword_100A10518[v2]);
}

void sub_10025B144(void (**a1)(uint64_t), uint64_t a2)
{
  if (!dword_100A19854) {
    sub_10025B8C0();
  }
  uint64_t v4 = 0;
  while ((void (**)(uint64_t))qword_100A10518[v4] != a1)
  {
    v4 += 2;
    if (v4 == 10)
    {
      sub_10025B8C0();
      return;
    }
  }
  uint64_t v5 = &qword_100A10518[v4];
  if (*((_DWORD *)v5 + 3) == 1)
  {
    *((_DWORD *)v5 + 3) = 2;
  }
  else
  {
    uint64_t v6 = *a1;
    *uint64_t v5 = 0;
    *((_DWORD *)v5 + 3) = 0;
    v6(a2);
  }
}

void *sub_10025B200()
{
  return memcpy(qword_100A10568, &unk_10099F5F8, sizeof(qword_100A10568));
}

uint64_t sub_10025B218(unsigned int a1)
{
  if (a1 >= 0x47) {
    sub_10025B8C0();
  }
  uint64_t result = qword_100A10568[a1];
  if (!result)
  {
    sub_10025B8C0();
    return qword_100A10568[a1];
  }
  return result;
}

void sub_10025B260(uint64_t a1, uint64_t a2)
{
  if (a2 >= 0x47) {
    sub_10025B8C0();
  }
  if (sub_10025C070(a2)) {
    sub_10025B8C0();
  }
  if (sub_10025C070(a2))
  {
    if (sub_100058654())
    {
      sub_100056E24((uint64_t)"OI_ConfigTable_SetConfig fail: module %d is already initialized", v4, v5, v6, v7, v8, v9, v10, a2);
      uint64_t v11 = sub_100050B4C(0x39u);
      if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR)) {
LABEL_8:
      }
        sub_100744F6C();
    }
  }
  else if (a2 == 40 && !sub_10025C0A8())
  {
    if (sub_100058654())
    {
      sub_100056E24((uint64_t)"OI_ConfigTable_SetConfig fail: cannot set Common Configuration", v12, v13, v14, v15, v16, v17, v18, v20);
      uint64_t v19 = sub_100050B4C(0x39u);
      if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR)) {
        goto LABEL_8;
      }
    }
  }
  else
  {
    qword_100A10568[a2] = a1;
  }
}

char *sub_10025B354(char *result, int a2, _WORD *a3)
{
  LOWORD(v3) = *a3;
  if (a2)
  {
    do
    {
      --a2;
      char v4 = *result++;
      int v3 = word_1007BAD00[(v4 ^ v3)] ^ ((unsigned __int16)(v3 & 0xFF00) >> 8);
    }
    while ((_WORD)a2);
  }
  *a3 = v3;
  return result;
}

unint64_t sub_10025B390(unint64_t result, unsigned char *a2)
{
  *a2 = byte_1007BAF00[result >> 4] | (16 * byte_1007BAF00[result & 0xF]);
  a2[1] = byte_1007BAF00[(unint64_t)result >> 12] | (16 * byte_1007BAF00[(result >> 8) & 0xF]);
  return result;
}

uint64_t sub_10025B3D0()
{
  if (qword_100A107B0) {
    free((void *)qword_100A107B0);
  }
  qword_100A107B0 = 0;
  dword_100A107A8 = 0;
  uint64_t result = qword_100A107B8;
  if (qword_100A107B8)
  {
    uint64_t result = munmap((void *)qword_100A107B8, dword_100A107A4);
    qword_100A107B8 = 0;
  }
  if (dword_1009FB020 != -1)
  {
    shm_unlink("com.apple.bluetooth.magnet.shm");
    uint64_t result = close(dword_1009FB020);
    dword_1009FB020 = -1;
  }
  return result;
}

char *sub_10025B450(unsigned int a1)
{
  if (a1 <= 0x5C) {
    return off_10099F830[a1];
  }
  else {
    return 0;
  }
}

uint64_t sub_10025B470()
{
  return 0;
}

uint64_t sub_10025B48C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  long long v9 = unk_10099FB18;
  sub_1002639B0((uint64_t)&v9, (uint64_t)"%:", a3, a4, a5, a6, a7, a8, a1);
  return sub_1002639DC((uint64_t)&v9);
}

uint64_t sub_10025B4D4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  long long v9 = unk_10099FB18;
  sub_1002639B0((uint64_t)&v9, (uint64_t)"%@", a3, a4, a5, a6, a7, a8, a1);
  return sub_1002639DC((uint64_t)&v9);
}

void sub_10025B520(unsigned __int8 *a1, char **a2)
{
  long long v11 = unk_10099FB28;
  uint64_t v2 = sub_100057728((uint64_t)&v11, a1, a2);
  if (v2)
  {
    WORD2(v11) = 0;
    sub_1002639B0((uint64_t)&v11, (uint64_t)"Invalid parameter in debug output %! \"%s\"", v3, v4, v5, v6, v7, v8, v2);
  }
  long long v9 = sub_100050B4C(0x5Cu);
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v10 = sub_1002639DC((uint64_t)&v11);
    *(_DWORD *)long long buf = 136446210;
    uint64_t v13 = v10;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "%{public}s", buf, 0xCu);
  }
}

void sub_10025B604(uint64_t a1, uint64_t a2)
{
  long long v11 = unk_10099FB28;
  uint64_t v2 = sub_100057728(&v11, a1, a2);
  if (v2)
  {
    WORD2(v11) = 0;
    sub_1002639B0((uint64_t)&v11, (uint64_t)"Invalid parameter in debug output %! \"%s\"", v3, v4, v5, v6, v7, v8, v2);
  }
  long long v9 = sub_100050B4C(0x58u);
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v10 = sub_1002639DC((uint64_t)&v11);
    *(_DWORD *)long long buf = 136446210;
    uint64_t v13 = v10;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "%{public}s", buf, 0xCu);
  }
}

uint64_t sub_10025B6E8(uint64_t a1, int a2, uint64_t a3, uint64_t a4)
{
  uint64_t result = 0xFFFFFFFFLL;
  if (a1 && a2)
  {
    v6[0] = 0;
    v6[1] = a1;
    *(_DWORD *)((char *)v6 + 2) = (unsigned __int16)(a2 - 1);
    if (sub_100057728(v6, a3, a4))
    {
      return 0xFFFFFFFFLL;
    }
    else
    {
      uint64_t result = WORD2(v6[0]);
      *(unsigned char *)(a1 + WORD2(v6[0])) = 0;
    }
  }
  return result;
}

uint64_t sub_10025B74C(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  return sub_10025B6E8(a1, a2, a3, (uint64_t)&a9);
}

void sub_10025B778(char *a1, ...)
{
  va_start(va, a1);
  sub_10025B520((unsigned __int8 *)a1, (char **)va);
}

void sub_10025B7A4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

const char *sub_10025B7D0(unsigned int a1)
{
  if (a1 > 2) {
    return "unknown";
  }
  else {
    return off_10099FB38[(char)a1];
  }
}

const char *sub_10025B7F8(int a1)
{
  if (a1 <= 1)
  {
    if (!a1) {
      return "sco";
    }
    if (a1 == 1) {
      return "acl";
    }
  }
  else
  {
    switch(a1)
    {
      case 2:
        return "esco";
      case 240:
        return "acl-hdr";
      case 241:
        return "acl-hdr-hrb";
    }
  }
  return "unknown";
}

const char *sub_10025B86C(unsigned int a1)
{
  if (a1 > 2) {
    return "unknown";
  }
  else {
    return off_10099FB50[(char)a1];
  }
}

const char *sub_10025B894(int a1)
{
  uint64_t v1 = "unknown";
  if (a1 == 1) {
    uint64_t v1 = "peripheral";
  }
  if (a1) {
    return v1;
  }
  else {
    return "central";
  }
}

void sub_10025B8C0()
{
  uint64_t v0 = qword_100A11FC8;
  if (qword_100A11FC8 || (v3 = 0, sub_1001E694C(&qword_100A11FC8, &v3), (uint64_t v0 = qword_100A11FC8) != 0))
  {
    uint64_t v1 = *(uint64_t (**)(void))(v0 + 96);
    if (v1)
    {
      uint64_t v2 = v1(0);
      if (v2)
      {
        if (v2 != 102) {
          sub_10025B778("Calling HciDriver_t::triggerCapture failed with status %!", v2);
        }
      }
    }
  }
  else
  {
    sub_10025B778("BT driver not ready yet!, skipping");
  }
}

void *sub_10025B94C(void *result)
{
  off_100A11FC0 = result;
  return result;
}

uint64_t sub_10025B958()
{
  if (off_100A11FC0) {
    return off_100A11FC0();
  }
  return result;
}

void sub_10025B96C(uint64_t a1)
{
  if (sub_100017A14())
  {
    sub_10025E0A8(a1);
    sub_10025B778("------------------------- Stack Dump reason: %s (%d) ------------------------------\n", v2, a1);
    if (sub_100103620())
    {
      uint64_t v3 = sub_100058654();
      char v9 = v3;
      if ((v3 & 1) == 0) {
        sub_100023344();
      }
      if ((int)a1 > 3699)
      {
        if (a1 == 3700 || a1 == 3702) {
          goto LABEL_14;
        }
      }
      else if (a1 == 621 || a1 == 3602)
      {
        goto LABEL_14;
      }
      long long v26 = 0u;
      long long v27 = 0u;
      long long v24 = 0u;
      long long v25 = 0u;
      long long v22 = 0u;
      long long v23 = 0u;
      long long v20 = 0u;
      long long v21 = 0u;
      long long v18 = 0u;
      long long v19 = 0u;
      long long v16 = 0u;
      long long v17 = 0u;
      long long v14 = 0u;
      long long v15 = 0u;
      *(_OWORD *)long long buf = 0u;
      long long v13 = 0u;
      sub_10025B74C((uint64_t)buf, 256, (uint64_t)"Fatal error detected, reason %! (0x%x)", v4, v5, v6, v7, v8, a1);
      sub_10011631C((const char *)buf);
LABEL_14:
      nullsub_95(v3);
      sub_100227AF0();
      sub_1000EB420();
      sub_10016ECE4();
      sub_10025828C();
      sub_1001F31EC();
      sub_1001DD658();
      sub_10017B728();
      sub_10019749C();
      uint64_t v11 = sub_10019F7F0();
      nullsub_95(v11);
      sub_10025BEE4();
      sub_1000D5B18();
      if ((v9 & 1) == 0) {
        sub_1000232E0();
      }
      return;
    }
    uint64_t v10 = sub_100050B4C(0x5Cu);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 136446210;
      *(void *)&uint8_t buf[4] = "Stack is not running";
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "%{public}s", buf, 0xCu);
    }
  }
}

void *sub_10025BB04(uint64_t a1, uint64_t (*a2)(void))
{
  if (dword_100A19858)
  {
    if (sub_100058654())
    {
      sub_100056E24((uint64_t)"OI_Dispatch_Init: %!", v4, v5, v6, v7, v8, v9, v10, 140);
      uint64_t v11 = sub_100050B4C(0x2Au);
      if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR)) {
        sub_100744F6C();
      }
    }
    sub_10025B8C0();
  }
  if (a1)
  {
    if (sub_100058654())
    {
      sub_100056E24((uint64_t)"OI_Dispatch_Init: configuration parameter is deprecated", v12, v13, v14, v15, v16, v17, v18, v21);
      long long v19 = sub_100050B4C(0x2Au);
      if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR)) {
        sub_100744F6C();
      }
    }
    sub_10025B260(a1, 42);
  }
  if (!sub_10025B218(0x2Au)) {
    sub_10025B8C0();
  }
  byte_100A11FD0 = 0;
  byte_100A11FD8 = 0;
  word_100A11FE4 = *(_WORD *)sub_10025B218(0x2Au);
  uint64_t result = sub_10010CE48(24 * (unsigned __int16)word_100A11FE4);
  qword_100A11FF0 = (uint64_t)result;
  word_100A11FE0 = -1;
  off_100A11FF8 = a2;
  dword_100A12000 = -1;
  dword_100A19858 = 1;
  return result;
}

uint64_t sub_10025BC54(unsigned int a1, int a2)
{
  if (!sub_100026E24(a1)) {
    return 1001;
  }
  if ((a2 & 0x8000) != 0)
  {
    sub_10025B8C0();
    return 101;
  }
  else
  {
    sub_100026B78(qword_100A11FF0 + 24 * HIWORD(a1), a2);
    return 0;
  }
}

uint64_t sub_10025BCB8(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 8) + 8))(**(void **)(a1 + 8));
}

uint64_t sub_10025BCC4(unsigned int a1, int a2)
{
  if (!sub_100026E24(a1)) {
    return 1001;
  }
  uint64_t v4 = qword_100A11FF0;
  uint64_t v7 = 0;
  sub_100026C30((uint64_t)&v7);
  int v5 = (SWORD2(v7) + 99) / 100 + 10 * v7;
  *(_WORD *)(v4 + 24 * HIWORD(a1) + 2) = v5 + a2;
  if (a2 <= (__int16)(word_100A11FE8 - v5))
  {
    word_100A11FE8 = v5 + a2;
    if (off_100A11FF8) {
      off_100A11FF8((100 * a2));
    }
  }
  return 0;
}

uint64_t sub_10025BD90(unsigned int a1, _WORD *a2)
{
  if (!sub_100026E24(a1)) {
    return 1001;
  }
  uint64_t v4 = qword_100A11FF0;
  uint64_t v6 = 0;
  sub_100026C30((uint64_t)&v6);
  uint64_t result = 0;
  *a2 = *(_WORD *)(v4 + 24 * HIWORD(a1) + 2) + (SWORD2(v6) + 99) / -100 - 10 * v6;
  return result;
}

uint64_t sub_10025BE30(unsigned int a1)
{
  if (!sub_100026E24(a1)) {
    return 1001;
  }
  uint64_t v8 = 0;
  uint64_t v9 = 0;
  uint64_t v2 = qword_100A11FF0;
  unsigned int v3 = HIWORD(a1);
  uint64_t v4 = qword_100A11FF0 + 24 * v3;
  *(unsigned char *)uint64_t v4 = 1;
  int v5 = *(__int16 *)(v4 + 6);
  if (v5)
  {
    LOWORD(v8) = v5;
    uint64_t v6 = (void *)(v2 + 24 * v3 + 16);
    if (v5 >= 9) {
      uint64_t v6 = (void *)*v6;
    }
    uint64_t v9 = v6;
    (*(void (**)(uint64_t *))(v2 + 24 * v3 + 8))(&v8);
  }
  else
  {
    (*(void (**)(void))(v2 + 24 * v3 + 8))(0);
  }
  sub_1000264E4((__int16)v3);
  return 0;
}

uint64_t sub_10025BEE4()
{
  uint64_t v11 = 0;
  sub_100026C30((uint64_t)&v11);
  __int16 v0 = v11;
  int v1 = SWORD2(v11);
  sub_10025B778("Dispatcher dump:\n");
  sub_10025B778("   Running\t\t%d\n", byte_100A11FD0);
  sub_10025B778("   TableSize\t  %d\n", (unsigned __int16)word_100A11FE4);
  uint64_t result = sub_10025B778("   max_used_count %d\n", dword_100A12000);
  unsigned int v3 = (unsigned __int16)word_100A11FE4;
  if (word_100A11FE4)
  {
    uint64_t v4 = 0;
    unint64_t v5 = 0;
    int v6 = (unsigned __int16)(((unint64_t)(1374389535 * (v1 + 99)) >> 37)
                          + ((unint64_t)(1374389535 * (v1 + 99)) >> 63)
                          + 10 * v0);
    uint64_t v7 = qword_100A11FF0;
    do
    {
      uint64_t v8 = *(void *)(v7 + v4 + 8);
      if (v8)
      {
        unint64_t v9 = *(char *)(v7 + v4);
        uint64_t v10 = "unknown state";
        if (v9 <= 2) {
          uint64_t v10 = off_10099FB68[v9];
        }
        uint64_t result = sub_10025B778("entry %2d: %18s timeout %d, CBFunc 0x%x\n", v5, v10, *(unsigned __int16 *)(v7 + v4 + 2) - v6, v8);
        uint64_t v7 = qword_100A11FF0;
        unsigned int v3 = (unsigned __int16)word_100A11FE4;
      }
      ++v5;
      v4 += 24;
    }
    while (v5 < v3);
  }
  return result;
}

double sub_10025C034()
{
  double result = 0.0;
  xmmword_100A198A0 = 0u;
  unk_100A198B0 = 0u;
  xmmword_100A19880 = 0u;
  unk_100A19890 = 0u;
  xmmword_100A19860 = 0u;
  unk_100A19870 = 0u;
  xmmword_100A19840 = 0u;
  unk_100A19850 = 0u;
  unk_100A19820 = 0u;
  unk_100A19830 = 0u;
  unk_100A19800 = 0u;
  *(_OWORD *)&dword_100A19810 = 0u;
  unk_100A197E0 = 0u;
  *(_OWORD *)&dword_100A197F0 = 0u;
  xmmword_100A197C0 = 0u;
  unk_100A197D0 = 0u;
  *(_OWORD *)&dword_100A197B0 = 0u;
  xmmword_100A198BC = 0u;
  return result;
}

uint64_t sub_10025C070(unsigned int a1)
{
  if (a1 >= 0x47) {
    sub_10025B8C0();
  }
  return dword_100A197B0[a1];
}

BOOL sub_10025C0A8()
{
  if (dword_100A197B0[0]) {
    return 0;
  }
  unint64_t v1 = 0;
  do
  {
    unint64_t v2 = v1;
    if (v1 == 70) {
      break;
    }
  }
  while (!dword_100A197B0[++v1]);
  return v2 > 0x45;
}

void *sub_10025C0F0(void *result)
{
  *double result = result;
  result[1] = result;
  return result;
}

void *sub_10025C0F8(void *result, uint64_t *a2)
{
  uint64_t v2 = *a2;
  *a2 = (uint64_t)result;
  *double result = v2;
  result[1] = a2;
  *(void *)(v2 + 8) = result;
  return result;
}

void *sub_10025C10C(void *result, uint64_t a2)
{
  uint64_t v2 = *(void **)(a2 + 8);
  *uint64_t v2 = result;
  *double result = a2;
  result[1] = v2;
  *(void *)(a2 + 8) = result;
  return result;
}

void sub_10025C120(void *a1)
{
  unint64_t v1 = (void *)a1[1];
  if ((void *)*v1 == a1 && (uint64_t v2 = *a1, *(void **)(*a1 + 8) == a1))
  {
    *unint64_t v1 = v2;
    *(void *)(v2 + 8) = v1;
  }
  else if (sub_100058654())
  {
    sub_100056E24((uint64_t)"Attempt to delete element not in list\n", v3, v4, v5, v6, v7, v8, v9, v11);
    uint64_t v10 = sub_100050B4C(0x39u);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR)) {
      sub_1007457DC(v10);
    }
  }
}

uint64_t sub_10025C1A4(void **a1)
{
  uint64_t v1 = (uint64_t)*a1;
  if (*a1 == a1) {
    return 0;
  }
  sub_10025C120(*a1);
  return v1;
}

char *sub_10025C1E0(unsigned int a1)
{
  char v1 = a1;
  double result = (char *)sub_100022FE8(24 * a1 + 16);
  if (result)
  {
    *double result = v1;
    *(_WORD *)(result + 1) = 0;
    *((_DWORD *)result + 1) = 0;
  }
  return result;
}

uint64_t sub_10025C220(void *a1, uint64_t a2, char a3)
{
  unsigned __int8 v6 = *(unsigned char *)a2 + a3;
  uint64_t v7 = (char *)sub_100022FE8(24 * v6 + 16);
  if (!v7) {
    return 106;
  }
  uint64_t v8 = v7;
  *uint64_t v7 = v6;
  *(_WORD *)(v7 + 1) = 0;
  *((_DWORD *)v7 + 1) = 0;
  *uint64_t v7 = *(unsigned char *)a2 + a3;
  v7[1] = *(unsigned char *)(a2 + 1);
  *((_WORD *)v7 + 3) = *(_WORD *)(a2 + 6);
  v7[2] = *(unsigned char *)(a2 + 2);
  *((_WORD *)v7 + 2) = *(_WORD *)(a2 + 4);
  *((void *)v7 + 1) = *(void *)(a2 + 8);
  if (*(unsigned char *)(a2 + 2))
  {
    uint64_t v9 = 0;
    unint64_t v10 = 0;
    while (1)
    {
      uint64_t v11 = a2 + v9;
      uint64_t v12 = &v8[v9];
      *(_WORD *)&v8[v9 + 18] = *(_WORD *)(a2 + v9 + 18);
      unsigned int v13 = *(unsigned __int8 *)(a2 + v9 + 16);
      if (v13 < 3) {
        break;
      }
      if (v13 == 4)
      {
        v12[16] = 4;
        uint64_t v16 = &v8[v9];
        *((_WORD *)v16 + 17) = *(_WORD *)(a2 + v9 + 34);
        v16[32] = *(unsigned char *)(a2 + v9 + 32);
        sub_10025C220(&v8[v9 + 24], *(void *)(a2 + v9 + 24), 0);
        goto LABEL_13;
      }
      if (v13 == 3)
      {
        v12[16] = 3;
        uint64_t v14 = &v8[v9 + 24];
        uint64_t v15 = (const void *)(a2 + v9 + 24);
LABEL_10:
        memmove(v14, v15, *(unsigned __int16 *)(v11 + 18));
      }
LABEL_13:
      ++v10;
      v9 += 24;
      if (v10 >= *(unsigned __int8 *)(a2 + 2)) {
        goto LABEL_14;
      }
    }
    v12[16] = 0;
    uint64_t v14 = (char *)sub_100022FE8(*(unsigned __int16 *)(v11 + 18));
    *((void *)v12 + 3) = v14;
    if (!v14)
    {
      *((_WORD *)v12 + 9) = 0;
      goto LABEL_13;
    }
    uint64_t v15 = *(const void **)(a2 + v9 + 24);
    goto LABEL_10;
  }
LABEL_14:
  uint64_t result = 0;
  *a1 = v8;
  return result;
}

void sub_10025C3A8(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 2))
  {
    unint64_t v2 = 0;
    uint64_t v3 = a1 + 18;
    do
    {
      unsigned int v4 = *(unsigned __int8 *)(v3 - 2);
      if (v4 >= 2)
      {
        if (v4 == 4)
        {
          *(unsigned char *)(*(void *)(v3 + 6) + 1) = *(unsigned char *)(v3 + 14);
          *(_WORD *)(*(void *)(v3 + 6) + 6) = *(_WORD *)(v3 + 16);
          *(_WORD *)(*(void *)(v3 + 6) + 4) = *(_WORD *)v3;
          sub_10025C3A8(*(void *)(v3 + 6));
        }
      }
      else
      {
        uint64_t v5 = *(void **)(v3 + 6);
        if (!v5) {
          sub_10014327C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/support/oi_mbuf.c", 133, "cell->buf.ptr");
        }
        sub_100023010(v5);
        *(void *)(v3 + 6) = 0;
      }
      v3 += 24;
      ++v2;
    }
    while (v2 < *(unsigned __int8 *)(a1 + 2));
  }
  *(_DWORD *)(a1 + 4) = 0;
  *(_WORD *)(a1 + 1) = 0;
  *(void *)(a1 + 8) = 0;

  sub_100023010((void *)a1);
}

void sub_10025C480(uint64_t a1)
{
  unsigned int v2 = *(unsigned __int8 *)(a1 + 2);
  if (*(unsigned char *)(a1 + 2))
  {
    unint64_t v3 = 0;
    uint64_t v4 = a1 + 18;
    do
    {
      unsigned int v5 = *(unsigned __int8 *)(v4 - 2);
      if (v5 >= 2)
      {
        if (v5 == 4)
        {
          *(unsigned char *)(*(void *)(v4 + 6) + 1) = *(unsigned char *)(v4 + 14);
          *(_WORD *)(*(void *)(v4 + 6) + 6) = *(_WORD *)(v4 + 16);
          *(_WORD *)(*(void *)(v4 + 6) + 4) = *(_WORD *)v4;
        }
      }
      else
      {
        unsigned __int8 v6 = *(void **)(v4 + 6);
        if (!v6) {
          sub_10014327C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/support/oi_mbuf.c", 207, "cell->buf.ptr");
        }
        sub_100023010(v6);
        *(void *)(v4 + 6) = 0;
        unsigned int v2 = *(unsigned __int8 *)(a1 + 2);
      }
      v4 += 24;
      ++v3;
    }
    while (v3 < v2);
  }
  *(_DWORD *)(a1 + 4) = 0;
  *(_WORD *)(a1 + 1) = 0;
  *(void *)(a1 + 8) = 0;
}

void sub_10025C53C(void *a1)
{
  sub_10025C480((uint64_t)a1);

  sub_100023010(a1);
}

uint64_t sub_10025C574(uint64_t result)
{
  *(unsigned char *)(result + 1) = 0;
  *(_DWORD *)(result + 4) = 0;
  unsigned int v1 = *(unsigned __int8 *)(result + 2);
  if (*(unsigned char *)(result + 2))
  {
    uint64_t v2 = result;
    unint64_t v3 = 0;
    uint64_t v4 = result + 16;
    do
    {
      *(_WORD *)(v2 + 4) += *(_WORD *)(v4 + 2);
      if (*(unsigned char *)v4 == 4)
      {
        uint64_t result = sub_10025C574(*(void *)(v4 + 8));
        unsigned int v1 = *(unsigned __int8 *)(v2 + 2);
      }
      v4 += 24;
      ++v3;
    }
    while (v3 < v1);
  }
  return result;
}

void sub_10025C5EC(unsigned __int8 *ptr, void *a2, _WORD *a3)
{
  if (!ptr || !a2 || !a3) {
    sub_10014327C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/support/oi_mbuf.c", 331, "mbuf && data && len");
  }
  unsigned int v6 = *ptr;
  if (v6 >= 2) {
    sub_10014327C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/support/oi_mbuf.c", 332, "mbuf->allocCells <= 1");
  }
  if (ptr[2] != v6) {
    sub_10014327C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/support/oi_mbuf.c", 333, "mbuf->usedCells == mbuf->allocCells");
  }
  if (v6 == 1)
  {
    if (ptr[16])
    {
      if (ptr[16] == 2)
      {
        *a2 = *((void *)ptr + 3);
        __int16 v7 = *((_WORD *)ptr + 9);
        goto LABEL_12;
      }
    }
    else
    {
      sub_100023010(*((void **)ptr + 3));
    }
  }
  __int16 v7 = 0;
  *a2 = 0;
LABEL_12:
  *a3 = v7;

  sub_100023010(ptr);
}

void *sub_10025C6D8(char *a1, size_t a2, int a3)
{
  if (a1 && a2)
  {
    unsigned int v6 = sub_100022FE8(0x28uLL);
    __int16 v7 = v6;
    if (v6)
    {
      *unsigned int v6 = 1;
      void v6[3] = 0;
      *((unsigned char *)v6 + 2) = 1;
      void v6[2] = a2;
      uint64_t v8 = sub_100022F2C((uint64_t)(v6 + 8), a1, a2, a3);
      if (v8)
      {
        uint64_t v9 = v8;
        if (sub_100058654())
        {
          sub_100056E24((uint64_t)"OI_MBUF_Wrap - InitCell failed %!", v10, v11, v12, v13, v14, v15, v16, v9);
          uint64_t v17 = sub_100050B4C(0x30u);
          if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR)) {
            sub_100744F6C();
          }
        }
        sub_10025C480((uint64_t)v7);
        sub_100023010(v7);
        return 0;
      }
    }
  }
  else
  {
    uint64_t v18 = sub_100022FE8(0x10uLL);
    __int16 v7 = v18;
    if (v18)
    {
      *uint64_t v18 = 0;
      *((unsigned char *)v18 + 2) = 0;
      *((_DWORD *)v18 + 1) = 0;
    }
  }
  return v7;
}

uint64_t sub_10025C7D4(unsigned __int8 *a1, char *a2, size_t size, unsigned int a4)
{
  if (!a1) {
    sub_10014327C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/support/oi_mbuf.c", 403, "mbuf");
  }
  if (!a2) {
    sub_10014327C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/support/oi_mbuf.c", 404, "buf");
  }
  if (*((_WORD *)a1 + 3)) {
    sub_10014327C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/support/oi_mbuf.c", 405, "mbuf->currPos == 0");
  }
  if (a4 > 2) {
    return 101;
  }
  __int16 v6 = size;
  if (!size) {
    return 0;
  }
  uint64_t v7 = a1[2];
  if (v7 >= *a1)
  {
    if (sub_100058654())
    {
      sub_100056E24((uint64_t)"MBUF Prepend overflow: alloc %d", v13, v14, v15, v16, v17, v18, v19, *a1);
      long long v20 = sub_100050B4C(0x30u);
      if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR)) {
        sub_100744F6C();
      }
    }
    return 124;
  }
  else
  {
    if (a1[2])
    {
      uint64_t v8 = (uint64_t)&a1[24 * a1[2] + 16];
      uint64_t v9 = v7 - 1;
      do
      {
        uint64_t v10 = v9;
        uint64_t v11 = &a1[24 * v9];
        long long v12 = *((_OWORD *)v11 + 1);
        *(void *)(v8 + 16) = *((void *)v11 + 4);
        *(_OWORD *)uint64_t v8 = v12;
        v8 -= 24;
        --v9;
      }
      while (v10);
    }
    a1[2] = v7 + 1;
    uint64_t result = sub_100022F2C((uint64_t)(a1 + 16), a2, size, a4);
    if (!result) {
      *((_WORD *)a1 + 2) += v6;
    }
  }
  return result;
}

uint64_t sub_10025C92C(unsigned __int8 *a1, uint64_t a2)
{
  unsigned int v3 = a1[2];
  if (v3 >= *a1)
  {
    if (sub_100058654())
    {
      sub_100056E24((uint64_t)"MBUF Append Mbuf overflow: alloc %d", v6, v7, v8, v9, v10, v11, v12, *a1);
      uint64_t v13 = sub_100050B4C(0x30u);
      if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR)) {
        sub_100744F6C();
      }
    }
    return 124;
  }
  else
  {
    uint64_t result = 0;
    unsigned int v5 = &a1[24 * v3];
    a1[2] = v3 + 1;
    *((_WORD *)a1 + 2) += *(_WORD *)(a2 + 4);
    v5[16] = 4;
    *((void *)v5 + 3) = a2;
    *((_WORD *)v5 + 9) = *(_WORD *)(a2 + 4);
    v5[32] = *(unsigned char *)(a2 + 1);
    *((_WORD *)v5 + 17) = *(_WORD *)(a2 + 6);
  }
  return result;
}

uint64_t sub_10025C9FC(uint64_t a1, uint64_t a2)
{
  if (!a1) {
    sub_10014327C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/support/oi_mbuf.c", 582, "mbuf");
  }
  uint64_t v2 = *(unsigned __int16 *)(a1 + 4);
  if (v2 > a2)
  {
    *(_WORD *)(a1 + 4) = a2;
    uint64_t v2 = a2;
  }
  *(_WORD *)(a1 + 6) = 0;
  *(unsigned char *)(a1 + 1) = 0;
  return v2;
}

uint64_t sub_10025CA4C(uint64_t a1, unsigned int a2)
{
  if (!a1) {
    sub_10014327C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/support/oi_mbuf.c", 605, "mbuf");
  }
  uint64_t v2 = *(unsigned __int8 *)(a1 + 1);
  uint64_t v3 = *(unsigned __int8 *)(a1 + 2);
  if (v2 >= v3) {
    sub_10014327C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/support/oi_mbuf.c", 606, "mbuf->currCell < mbuf->usedCells");
  }
  unsigned __int16 v4 = *(_WORD *)(a1 + 6) + *(_WORD *)(a1 + 4);
  *(_WORD *)(a1 + 6) = v4;
  unsigned int v5 = *(unsigned __int16 *)(a1 + 24 * v2 + 18);
  if (v5 <= v4)
  {
    uint64_t v6 = (unsigned __int16 *)(a1 + 24 * v2 + 42);
    uint64_t v7 = v2 + 1;
    do
    {
      LOBYTE(v2) = v7;
      v4 -= v5;
      if (v3 == v7) {
        break;
      }
      unsigned int v8 = *v6;
      v6 += 12;
      LOWORD(v5) = v8;
      ++v7;
    }
    while (v8 <= v4);
    *(_WORD *)(a1 + 6) = v4;
    *(unsigned char *)(a1 + 1) = v2;
  }
  if (v2 == v3)
  {
    LOWORD(v9) = 0;
    unsigned __int8 v10 = v3 - 1;
    *(unsigned char *)(a1 + 1) = v10;
    *(_WORD *)(a1 + 6) = *(_WORD *)(a1 + 24 * v10 + 18);
  }
  else
  {
    unsigned int v11 = *(unsigned __int16 *)(a1 + 24 * v2 + 18);
    BOOL v12 = v11 >= v4;
    unsigned int v9 = v11 - v4;
    if (!v12) {
      sub_10014327C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/support/oi_mbuf.c", 638, "mbuf->cells[mbuf->currCell].len >= mbuf->currPos");
    }
    if (v2 + 1 < v3)
    {
      uint64_t v13 = (unsigned __int16 *)(a1 + 24 * v2 + 42);
      uint64_t v14 = ~(unint64_t)v2 + v3;
      do
      {
        int v15 = *v13;
        v13 += 12;
        v9 += v15;
        --v14;
      }
      while (v14);
    }
    if (v9 >= a2) {
      LOWORD(v9) = a2;
    }
  }
  *(_WORD *)(a1 + 4) = v9;
  return (unsigned __int16)v9;
}

void sub_10025CB9C(uint64_t a1, char *a2, _WORD *a3)
{
  unsigned int v6 = *(unsigned __int16 *)(sub_10025B218(0x2Cu) + 10);
  if (a1)
  {
    if (a2) {
      goto LABEL_3;
    }
LABEL_26:
    sub_10025B8C0();
    if (a3) {
      goto LABEL_4;
    }
    goto LABEL_27;
  }
  sub_10025B8C0();
  if (!a2) {
    goto LABEL_26;
  }
LABEL_3:
  if (a3) {
    goto LABEL_4;
  }
LABEL_27:
  sub_10025B8C0();
LABEL_4:
  if (dword_100A19874)
  {
    if (*(_WORD *)(qword_100A12008 + 20))
    {
      char v7 = 0;
      uint64_t v8 = *(void *)(qword_100A12008 + 24);
      uint64_t v9 = *(unsigned __int16 *)(qword_100A12008 + 20);
      do
      {
        if (*(_DWORD *)(v8 + 56) >> 18 >= 0x69u
          && (unsigned __int16)*(_DWORD *)(v8 + 56) < *(unsigned __int16 *)(qword_100A12008 + 20)
          && *(_DWORD *)a1 == *(_DWORD *)v8
          && *(unsigned __int16 *)(a1 + 4) == *(unsigned __int16 *)(v8 + 4))
        {
          if (*(unsigned char *)(v8 + 24)) {
            char v7 = 1;
          }
          unsigned int v12 = v6 & 0xFFFFFFFD;
          if ((*(unsigned char *)(v8 + 40) & 1) == 0) {
            unsigned int v12 = v6;
          }
          if ((*(unsigned char *)(v8 + 40) & 2) != 0) {
            unsigned int v6 = v12 & 0xFFFFFFFB;
          }
          else {
            unsigned int v6 = v12;
          }
        }
        v8 += 64;
        --v9;
      }
      while (v9);
    }
    else
    {
      char v7 = 0;
    }
  }
  else
  {
    if (sub_100058654())
    {
      sub_100056E24((uint64_t)"OI_POLICYMGR_GetDevmgrPolicy", v13, v14, v15, v16, v17, v18, v19, v21);
      long long v20 = sub_100050B4C(0x31u);
      if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR)) {
        sub_100749CC4();
      }
    }
    char v7 = 0;
  }
  *a2 = v7;
  *a3 = v6;
}

uint64_t sub_10025CCEC(uint64_t a1)
{
  if (a1)
  {
    if (sub_100058654())
    {
      sub_100056E24((uint64_t)"OI_POLICYMGR_Init: configuration parameter is deprecated", v2, v3, v4, v5, v6, v7, v8, v19);
      uint64_t v9 = sub_100050B4C(0x31u);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR)) {
        sub_100744F6C();
      }
    }
    sub_10025B260(a1, 49);
  }
  if (dword_100A19874) {
    return 140;
  }
  uint64_t v11 = sub_10025B218(0x31u);
  if (v11)
  {
    unsigned int v12 = (unsigned __int16 *)v11;
    uint64_t v13 = sub_10010CE48(0x30uLL);
    qword_100A12008 = (uint64_t)v13;
    if (v13)
    {
      v13[4] = 0;
      uint64_t v14 = *v12;
      *((_WORD *)v13 + 10) = v14;
      uint64_t v15 = sub_10010CE48(v14 << 6);
      uint64_t v16 = qword_100A12008;
      *(void *)(qword_100A12008 + 24) = v15;
      if (!v15)
      {
        sub_10025B8C0();
        uint64_t v16 = qword_100A12008;
      }
      uint64_t v17 = *(unsigned __int16 *)(v16 + 20);
      if (*(_WORD *)(v16 + 20))
      {
        uint64_t v18 = (_DWORD *)(*(void *)(v16 + 24) + 56);
        do
        {
          *uint64_t v18 = 0;
          v18 += 16;
          --v17;
        }
        while (v17);
      }
      uint64_t result = 0;
      *(_WORD *)(v16 + 32) = 420;
      *(_DWORD *)(v16 + 16) = 1;
      *(void *)(v16 + 40) = 0;
      dword_100A19874 = 1;
    }
    else
    {
      return 106;
    }
  }
  else
  {
    sub_10025B8C0();
    return 127;
  }
  return result;
}

void sub_10025CE14(uint64_t a1)
{
  if (!dword_100A19874) {
    sub_10025B8C0();
  }
  *(void *)(qword_100A12008 + 40) = a1;
}

uint64_t sub_10025CE54(uint64_t a1, uint64_t a2, long long *a3, int *a4, char a5)
{
  if (a3 && a2 && a4)
  {
    if (dword_100A19874)
    {
      v33[0] = 0;
      uint64_t v31 = 0;
      v32[0] = 0;
      uint64_t result = sub_10017E2D4(a2, &v31);
      if (!result)
      {
        uint64_t v11 = qword_100A12008;
        unsigned int v12 = (unsigned __int16)(*(_WORD *)(qword_100A12008 + 32) + 1);
        if (v12 <= 0x1A4) {
          __int16 v13 = 420;
        }
        else {
          __int16 v13 = *(_WORD *)(qword_100A12008 + 32) + 1;
        }
        *(_WORD *)(qword_100A12008 + 32) = v13;
        uint64_t v14 = *(unsigned __int16 *)(v11 + 20);
        if (*(_WORD *)(v11 + 20))
        {
          uint64_t v15 = *(void *)(v11 + 24);
          if (v12 <= 0x1A4) {
            int v16 = 420;
          }
          else {
            int v16 = v12;
          }
          int v17 = v16 << 16;
          uint64_t v18 = v15 + 56;
          while (*(_DWORD *)v18)
          {
            ++v17;
            v18 += 64;
            if (!--v14) {
              goto LABEL_16;
            }
          }
          *(_DWORD *)uint64_t v18 = v17;
          int v27 = *(_DWORD *)a2;
          *(_WORD *)(v18 - 52) = *(_WORD *)(a2 + 4);
          *(_DWORD *)(v18 - 56) = v27;
          *(unsigned char *)(v18 + 4) = a5;
          long long v28 = a3[2];
          long long v29 = *a3;
          *(_OWORD *)(v18 - 32) = a3[1];
          *(_OWORD *)(v18 - 16) = v28;
          *(_OWORD *)(v18 - 48) = v29;
          v32[1] = a1;
          LODWORD(v32[0]) = v17;
          *a4 = v17;
          v33[1] = v32;
          LOWORD(v33[0]) = 16;
          return sub_100026DA8((uint64_t)sub_10025CFE4, v33, 0);
        }
        else
        {
LABEL_16:
          if (sub_100058654())
          {
            sub_100056E24((uint64_t)"OI_POLICYMGR_NewConnection: connection list full!", v19, v20, v21, v22, v23, v24, v25, v30);
            long long v26 = sub_100050B4C(0x31u);
            if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR)) {
              sub_100744F6C();
            }
          }
          return 104;
        }
      }
    }
    else
    {
      return 103;
    }
  }
  else
  {
    sub_10025B8C0();
    return 101;
  }
  return result;
}

void sub_10025CFE4(uint64_t a1)
{
  int v66 = 0;
  int v67 = 0;
  unsigned int v1 = *(unsigned int **)(a1 + 8);
  if (sub_100058654())
  {
    sub_100056E24((uint64_t)"Trace deferredEnforcerCB, handle 0x%x", v2, v3, v4, v5, v6, v7, v8, *v1);
    uint64_t v9 = sub_100050B4C(0x31u);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 136446210;
      int v69 = sub_100050714();
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
    }
  }
  BOOL v10 = sub_10022EC3C(*(void *)(qword_100A12008 + 24) + ((unint64_t)*(unsigned __int16 *)v1 << 6));
  if (*(_DWORD *)(qword_100A12008 + 16) != 1 || v10)
  {
    uint64_t v65 = 0;
    sub_100026C30((uint64_t)&v65);
    unsigned int v12 = sub_100262904(&dword_100A12010, (int *)&v65);
    if (dword_100A12010 && v12 >= 0x258) {
      sub_10010B844(1501, "Policy enforcement timeout");
    }
    if (sub_100058654())
    {
      uint64_t v20 = *(int *)(qword_100A12008 + 16);
      uint64_t v21 = v20 > 5 ? "unknown" : off_10099FDD0[v20];
      sub_100056E24((uint64_t)"deferredEnforcerCB busy, reposting request, pmanState %s", v13, v14, v15, v16, v17, v18, v19, (uint64_t)v21);
      unsigned int v44 = sub_100050B4C(0x31u);
      if (os_log_type_enabled(v44, OS_LOG_TYPE_DEFAULT))
      {
        unsigned int v45 = sub_100050714();
        *(_DWORD *)long long buf = 136446210;
        int v69 = v45;
        _os_log_impl((void *)&_mh_execute_header, v44, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
      }
    }
    int v67 = v1;
    LOWORD(v66) = 16;
    uint64_t v46 = sub_1000268E4((uint64_t)sub_10025CFE4, &v66, 1, 0);
    if (v46)
    {
      uint64_t v47 = v46;
      if (sub_100058654())
      {
        sub_100056E24((uint64_t)"OI_Dispatch_RegisterTimedFunc failed %!", v48, v49, v50, v51, v52, v53, v54, v47);
        int v55 = sub_100050B4C(0x31u);
        if (os_log_type_enabled(v55, OS_LOG_TYPE_ERROR)) {
          sub_100744F6C();
        }
      }
      (*((void (**)(void, uint64_t, void))v1 + 1))(*v1, v47, 0);
    }
    return;
  }
  sub_100026C30((uint64_t)&dword_100A12010);
  uint64_t v22 = qword_100A12008;
  *(_OWORD *)qword_100A12008 = *(_OWORD *)v1;
  uint64_t v23 = *(void *)(v22 + 24) + ((unint64_t)(unsigned __int16)*(_DWORD *)v22 << 6);
  if (*(_DWORD *)(v23 + 56) != *(_DWORD *)v22)
  {
    if (sub_100058654())
    {
      sub_100056E24((uint64_t)"startSecurityPolicyEnforcement, handle %d no longer valid", v36, v37, v38, v39, v40, v41, v42, *(unsigned int *)qword_100A12008);
      int v43 = sub_100050B4C(0x31u);
      if (os_log_type_enabled(v43, OS_LOG_TYPE_ERROR)) {
        sub_100744F6C();
      }
    }
    uint64_t v34 = 122;
    uint64_t v35 = 0;
    goto LABEL_23;
  }
  uint64_t v24 = sub_1002576E0(sub_10025DC1C, v23, *(void *)(v23 + 8), *(void *)(v23 + 16), *(_DWORD *)v22, *(unsigned char *)(v23 + 60));
  if (v24)
  {
    uint64_t v25 = v24;
    if (sub_100058654())
    {
      sub_100056E24((uint64_t)"OI_SECMGR_EnforcePolicy failed addr %:, status %!", v26, v27, v28, v29, v30, v31, v32, v23);
      int v33 = sub_100050B4C(0x31u);
      if (os_log_type_enabled(v33, OS_LOG_TYPE_ERROR)) {
        sub_100748B78(v33);
      }
    }
    uint64_t v34 = v25;
    uint64_t v35 = 1;
LABEL_23:
    sub_10025DA6C(v34, v35);
    return;
  }
  if (sub_100058654())
  {
    sub_100056E24((uint64_t)"Trace startSecurityPolicyEnforcement handle %#x : %s --------------------> %s\n\n\n\n", v56, v57, v58, v59, v60, v61, v62, *(unsigned int *)(v23 + 56));
    uint64_t v63 = sub_100050B4C(0x31u);
    if (os_log_type_enabled(v63, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v64 = sub_100050714();
      *(_DWORD *)long long buf = 136446210;
      int v69 = v64;
      _os_log_impl((void *)&_mh_execute_header, v63, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
    }
  }
  *(_DWORD *)(qword_100A12008 + 16) = 2;
}

uint64_t sub_10025D408(uint64_t a1, uint64_t a2, long long *a3, int *a4)
{
  if (!dword_100A19874) {
    return 103;
  }
  uint64_t result = 101;
  if (a2 && a3)
  {
    if (a4) {
      return sub_10025CE54(a1, a2, a3, a4, 0);
    }
  }
  return result;
}

void sub_10025D444(uint64_t a1)
{
  __int16 v33 = 0;
  int v32 = 0;
  v30[0] = 0;
  v29[0] = 0;
  if (dword_100A19874)
  {
    if (a1)
    {
      if (a1 >> 18 < 0x69
        || (unsigned __int16)a1 >= *(unsigned __int16 *)(qword_100A12008 + 20))
      {
        if (sub_100058654())
        {
          sub_100056E24((uint64_t)"OI_POLICYMGR_Disconnect invalid handle 0x%x", v20, v21, v22, v23, v24, v25, v26, a1);
          uint64_t v27 = sub_100050B4C(0x31u);
          if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR)) {
            sub_100744F6C();
          }
        }
      }
      else if (sub_10025D5FC(a1, (uint64_t)&v32))
      {
        int v31 = 0;
        if (sub_10025D6F4((uint64_t)&v32, &v31))
        {
          v29[1] = nullsub_110;
          LODWORD(v29[0]) = *(_DWORD *)(*(void *)(qword_100A12008 + 24) + ((uint64_t)v31 << 6) + 56);
          v30[1] = v29;
          LOWORD(v30[0]) = 16;
          uint64_t v2 = sub_100026DA8((uint64_t)sub_10025D770, v30, 0);
          if (v2)
          {
            uint64_t v3 = v2;
            if (sub_100058654())
            {
              sub_100056E24((uint64_t)"OI_Dispatch_RegisterFunc failed %!", v4, v5, v6, v7, v8, v9, v10, v3);
              uint64_t v11 = sub_100050B4C(0x31u);
              if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR)) {
                sub_100744F6C();
              }
            }
          }
        }
      }
    }
  }
  else if (sub_100058654())
  {
    sub_100056E24((uint64_t)"OI_POLICYMGR_Disconnect", v12, v13, v14, v15, v16, v17, v18, v28);
    uint64_t v19 = sub_100050B4C(0x31u);
    if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR)) {
      sub_100749CC4();
    }
  }
}

uint64_t sub_10025D5FC(uint64_t a1, uint64_t a2)
{
  if (a1 >> 18 < 0x69
    || (uint64_t v3 = qword_100A12008, (unsigned __int16)a1 >= *(unsigned __int16 *)(qword_100A12008 + 20)))
  {
    uint64_t result = sub_100058654();
    if (!result) {
      return result;
    }
    sub_100056E24((uint64_t)"Invalid handle 0x%x", v11, v12, v13, v14, v15, v16, v17, a1);
    uint64_t v18 = sub_100050B4C(0x31u);
    uint64_t result = os_log_type_enabled(v18, OS_LOG_TYPE_ERROR);
    if (!result) {
      return result;
    }
    sub_100744F6C();
    return 0;
  }
  uint64_t v4 = *(void *)(qword_100A12008 + 24);
  uint64_t v5 = v4 + ((unint64_t)(unsigned __int16)a1 << 6);
  int v7 = *(_DWORD *)(v5 + 56);
  uint64_t v6 = (_DWORD *)(v5 + 56);
  if (v7 != a1) {
    return 0;
  }
  *uint64_t v6 = 0;
  if (a2)
  {
    uint64_t v8 = (int *)(v4 + ((unint64_t)(unsigned __int16)a1 << 6));
    int v9 = *v8;
    *(_WORD *)(a2 + 4) = *((_WORD *)v8 + 2);
    *(_DWORD *)a2 = v9;
  }
  if (*(void *)(v3 + 40))
  {
    uint64_t v19 = 0;
    if (!sub_10017E2D4(*(void *)(v3 + 24) + ((unint64_t)(unsigned __int16)a1 << 6), &v19)) {
      (*(void (**)(uint64_t))(qword_100A12008 + 40))(v19);
    }
  }
  return 1;
}

BOOL sub_10025D6F4(uint64_t a1, _DWORD *a2)
{
  unint64_t v2 = *(unsigned __int16 *)(qword_100A12008 + 20);
  if (*(_WORD *)(qword_100A12008 + 20))
  {
    uint64_t v3 = 0;
    uint64_t v4 = *(void *)(qword_100A12008 + 24);
    BOOL v5 = 1;
    while (*(_DWORD *)(v4 + 56) >> 18 < 0x69u
         || (unsigned __int16)*(_DWORD *)(v4 + 56) >= v2
         || *(_DWORD *)a1 != *(_DWORD *)v4
         || *(unsigned __int16 *)(a1 + 4) != *(unsigned __int16 *)(v4 + 4))
    {
      BOOL v5 = ++v3 < v2;
      v4 += 64;
      if (v2 == v3) {
        return 0;
      }
    }
    *a2 = v3;
  }
  else
  {
    return 0;
  }
  return v5;
}

void sub_10025D770(uint64_t a1)
{
  __int16 v30 = 0;
  char v29 = 0;
  v28[0] = 0;
  unsigned int v1 = *(unsigned __int16 **)(a1 + 8);
  BOOL v2 = sub_10022EC3C(*(void *)(qword_100A12008 + 24) + ((unint64_t)*v1 << 6));
  uint64_t v3 = qword_100A12008;
  if (*(_DWORD *)(qword_100A12008 + 16) == 1 && !v2)
  {
    *(_OWORD *)qword_100A12008 = *(_OWORD *)v1;
    uint64_t v15 = *(void *)(v3 + 24);
    int v16 = *(_DWORD *)v3;
    uint64_t v17 = v15 + ((unint64_t)(unsigned __int16)v16 << 6);
    if (*(_DWORD *)(v17 + 56) == v16)
    {
      sub_10025CB9C(v17, &v29, &v30);
      uint64_t v18 = sub_100187ED8((uint64_t)sub_10025DE08, v17, v29, v30, *(_DWORD *)(v17 + 56));
      if (v18)
      {
        uint64_t v19 = v18;
        if (sub_100058654())
        {
          sub_100056E24((uint64_t)"OI_DEVMGR_EnforceLinkPolicy failed %!", v20, v21, v22, v23, v24, v25, v26, v19);
          uint64_t v27 = sub_100050B4C(0x31u);
          if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR)) {
            sub_100744F6C();
          }
        }
      }
      else
      {
        *(_DWORD *)(qword_100A12008 + 16) = 3;
      }
    }
  }
  else
  {
    v28[1] = v1;
    LOWORD(v28[0]) = 16;
    uint64_t v5 = sub_1000268E4((uint64_t)sub_10025D770, v28, 1, 0);
    if (v5)
    {
      uint64_t v6 = v5;
      if (sub_100058654())
      {
        sub_100056E24((uint64_t)"OI_Dispatch_RegisterTimedFunc failed %!", v7, v8, v9, v10, v11, v12, v13, v6);
        uint64_t v14 = sub_100050B4C(0x31u);
        if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR)) {
          sub_100744F6C();
        }
      }
    }
  }
}

void sub_10025D904(uint64_t a1)
{
  if (!dword_100A19874)
  {
    if (sub_100058654())
    {
      sub_100056E24((uint64_t)"OI_POLICYMGR_RemoveConnectionPolicy", v2, v3, v4, v5, v6, v7, v8, v10);
      uint64_t v9 = sub_100050B4C(0x31u);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR)) {
        sub_100749CC4();
      }
    }
  }
  sub_10025D444(a1);
}

void sub_10025D97C(uint64_t a1)
{
  if (dword_100A19874)
  {
    int v13 = 0;
    if (sub_10025D6F4(a1, &v13))
    {
      uint64_t v2 = qword_100A12008;
      do
      {
        uint64_t v3 = v13;
        if (*(_DWORD *)(v2 + 16) != 1 && *(_DWORD *)v2 == *(_DWORD *)(*(void *)(v2 + 24) + ((uint64_t)v13 << 6) + 56))
        {
          sub_10025DA6C(1500, 1);
          uint64_t v2 = qword_100A12008;
        }
        *(_DWORD *)(*(void *)(v2 + 24) + (v3 << 6) + 56) = 0;
      }
      while (sub_10025D6F4(a1, &v13));
    }
  }
  else if (sub_100058654())
  {
    sub_100056E24((uint64_t)"OI_POLICYMGR_DevmgrDisconnect", v4, v5, v6, v7, v8, v9, v10, v12);
    uint64_t v11 = sub_100050B4C(0x31u);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR)) {
      sub_100749CC4();
    }
  }
}

uint64_t sub_10025DA6C(uint64_t a1, uint64_t a2)
{
  if (!*(void *)(qword_100A12008 + 8)) {
    sub_10025B8C0();
  }
  if (sub_100058654())
  {
    sub_100056E24((uint64_t)"Trace finishEnforcementEffort handle %#x : %s --------------------> %s\n\n\n\n", v4, v5, v6, v7, v8, v9, v10, *(unsigned int *)qword_100A12008);
    uint64_t v11 = sub_100050B4C(0x31u);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 136446210;
      uint64_t v23 = sub_100050714();
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
    }
  }
  uint64_t v12 = (unsigned int *)qword_100A12008;
  *(_DWORD *)(qword_100A12008 + 16) = 1;
  dword_100A12010 = 0;
  word_100A12014 = 0;
  if (a1)
  {
    if ((sub_10025D5FC(*v12, 0) & 1) == 0)
    {
      if (sub_100058654())
      {
        sub_100056E24((uint64_t)"Orphaned policy, handle 0x%x", v13, v14, v15, v16, v17, v18, v19, *(unsigned int *)qword_100A12008);
        uint64_t v20 = sub_100050B4C(0x31u);
        if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR)) {
          sub_100744F6C();
        }
      }
    }
  }
  return (*(uint64_t (**)(void, uint64_t, uint64_t))(qword_100A12008 + 8))(*(unsigned int *)qword_100A12008, a1, a2);
}

void sub_10025DC1C(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = qword_100A12008;
  if (*(_DWORD *)(qword_100A12008 + 16) != 2)
  {
    sub_10025B8C0();
    uint64_t v4 = qword_100A12008;
  }
  if (*(_DWORD *)v4 == a2)
  {
    if (a1)
    {
      sub_10025DA6C(a1, 1);
    }
    else
    {
      __int16 v34 = 0;
      char v33 = 0;
      uint64_t v13 = *(void *)(v4 + 24) + ((unint64_t)(unsigned __int16)a2 << 6);
      if (*(_DWORD *)(v13 + 56) == a2)
      {
        sub_10025CB9C(v13, &v33, &v34);
        uint64_t v14 = sub_100187ED8((uint64_t)sub_10025DE08, v13, v33, v34, *(_DWORD *)(v13 + 56));
        if (!v14)
        {
          *(_DWORD *)(qword_100A12008 + 16) = 3;
          return;
        }
        uint64_t v15 = v14;
        if (sub_100058654())
        {
          sub_100056E24((uint64_t)"OI_DEVMGR_EnforceLinkPolicy failed %!", v16, v17, v18, v19, v20, v21, v22, v15);
          uint64_t v23 = sub_100050B4C(0x31u);
          if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR)) {
            sub_100744F6C();
          }
        }
        uint64_t v24 = v15;
      }
      else
      {
        if (sub_100058654())
        {
          sub_100056E24((uint64_t)"startDevmgrPolicyEnforcement, handle %d no longer valid", v25, v26, v27, v28, v29, v30, v31, *(unsigned int *)qword_100A12008);
          int v32 = sub_100050B4C(0x31u);
          if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR)) {
            sub_100744F6C();
          }
        }
        uint64_t v24 = 122;
      }
      sub_10025DA6C(v24, 0);
    }
  }
  else if (sub_100058654())
  {
    sub_100056E24((uint64_t)"cookie does not match current enforcement (%d vs 0x%x)", v5, v6, v7, v8, v9, v10, v11, a2);
    uint64_t v12 = sub_100050B4C(0x31u);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR)) {
      sub_100744F6C();
    }
  }
}

void sub_10025DE08(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_DWORD *)(qword_100A12008 + 16) != 3)
  {
    if (!sub_100058654()) {
      return;
    }
    sub_100056E24((uint64_t)"Policy Enforce State == %d", v4, v5, v6, v7, v8, v9, v10, *(unsigned int *)(qword_100A12008 + 16));
    uint64_t v11 = sub_100050B4C(0x31u);
    if (!os_log_type_enabled(v11, OS_LOG_TYPE_ERROR)) {
      return;
    }
LABEL_9:
    sub_100744F6C();
    return;
  }
  if (*(_DWORD *)qword_100A12008 != a3)
  {
    if (!sub_100058654()) {
      return;
    }
    sub_100056E24((uint64_t)"cookie does not match current enforcement (0x%x vs 0x%x)", v12, v13, v14, v15, v16, v17, v18, a3);
    uint64_t v19 = sub_100050B4C(0x31u);
    if (!os_log_type_enabled(v19, OS_LOG_TYPE_ERROR)) {
      return;
    }
    goto LABEL_9;
  }
  if (a1)
  {
LABEL_4:
    sub_10025DA6C(a1, 0);
    return;
  }
  if (*(_DWORD *)(*(void *)(qword_100A12008 + 24) + ((unint64_t)(unsigned __int16)a3 << 6) + 56) == a3)
  {
    a1 = sub_100026DA8((uint64_t)sub_10025DFB0, 0, 0);
    if (!a1)
    {
      *(_DWORD *)(qword_100A12008 + 16) = 4;
      return;
    }
    goto LABEL_4;
  }
  if (sub_100058654())
  {
    sub_100056E24((uint64_t)"startPowerPolicyEnforcement, handle %d no longer valid", v20, v21, v22, v23, v24, v25, v26, *(unsigned int *)qword_100A12008);
    uint64_t v27 = sub_100050B4C(0x31u);
    if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR)) {
      sub_100744F6C();
    }
  }
  sub_10025DA6C(122, 0);
}

uint64_t sub_10025DFB0()
{
  __int16 v0 = (unsigned __int16 *)qword_100A12008;
  if (*(_DWORD *)(qword_100A12008 + 16) != 4)
  {
    sub_10025B8C0();
    __int16 v0 = (unsigned __int16 *)qword_100A12008;
  }
  uint64_t v1 = *((void *)v0 + 3);
  uint64_t v2 = v1 + ((unint64_t)*v0 << 6);
  uint64_t v3 = v0[10];
  if (v3)
  {
    uint64_t v4 = 0;
    uint64_t v5 = v3;
    do
    {
      if (*(_DWORD *)(v1 + 56) >> 18 >= 0x69u
        && (unsigned __int16)*(_DWORD *)(v1 + 56) < v3
        && *(_DWORD *)v2 == *(_DWORD *)v1
        && *(unsigned __int16 *)(v2 + 4) == *(unsigned __int16 *)(v1 + 4))
      {
        uint64_t v8 = *(void *)(v1 + 48);
        if (v8)
        {
          if (!v4
            || *(_DWORD *)v8 > *(_DWORD *)v4
            || *(unsigned __int16 *)(v8 + 4) < *(unsigned __int16 *)(v4 + 4)
            || *(unsigned __int16 *)(v8 + 10) > *(unsigned __int16 *)(v4 + 10))
          {
            uint64_t v4 = *(void *)(v1 + 48);
          }
        }
      }
      v1 += 64;
      --v5;
    }
    while (v5);
  }
  else
  {
    uint64_t v4 = 0;
  }
  sub_10018362C(v2, (uint64_t *)v4);

  return sub_10025DA6C(0, 0);
}

double sub_10025E0A8(uint64_t a1)
{
  if (sub_100017A14())
  {
    for (unint64_t i = 0; ; ++i)
    {
      uint64_t v3 = off_1009FB028[i];
      if (!v3 || i > 4) {
        break;
      }
      if (((uint64_t (*)(uint64_t))v3)(a1)) {
        return result;
      }
    }
  }

  return sub_10025E128(a1);
}

double sub_10025E128(unsigned int a1)
{
  if (a1)
  {
    unsigned int v1 = a1;
    if (a1 != 0xFFFF)
    {
      uint64_t v2 = &unk_100A12025;
      byte_100A1202D = 0;
      do
      {
        v2[7] = a0123456789_0[v1 % 0xA];
        --v2;
        BOOL v3 = v1 > 9;
        v1 /= 0xAu;
      }
      while (v3);
      double result = 5.76777859e-153;
      *(void *)uint64_t v2 = 0x2053555441545320;
    }
  }
  return result;
}

const char *sub_10025E1A8(int a1)
{
  if (a1 <= 1499)
  {
    if (a1 > 1200)
    {
      switch(a1)
      {
        case 1201:
          double result = "OI_HCITRANS_CANNOT_CONNECT_TO_DEVICE";
          break;
        case 1203:
          double result = "OI_HCITRANS_BUFFER_TOO_SMALL";
          break;
        case 1204:
          double result = "OI_HCITRANS_NULL_DEVICE_HANDLE";
          break;
        case 1205:
          double result = "OI_HCITRANS_IO_ERROR";
          break;
        case 1206:
          double result = "OI_HCITRANS_DEVICE_NOT_READY";
          break;
        case 1207:
          double result = "OI_HCITRANS_FUNCTION_NOT_SUPPORTED";
          break;
        case 1209:
          double result = "OI_HCITRANS_ACCESS_DENIED";
          break;
        case 1210:
          double result = "OI_HCITRANS_ACL_DATA_ERROR";
          break;
        case 1211:
          double result = "OI_HCITRANS_SCO_DATA_ERROR";
          break;
        case 1212:
          double result = "OI_HCITRANS_EVENT_DATA_ERROR";
          break;
        case 1214:
          double result = "OI_HCITRANS_INTERNAL_ERROR";
          break;
        case 1215:
          double result = "OI_HCITRANS_LINK_NOT_ACTIVE";
          break;
        case 1216:
          double result = "OI_HCITRANS_INITIALIZING";
          break;
        case 1217:
          double result = "OI_HCITRANS_H4BC_TIMEOUT";
          break;
        case 1218:
          double result = "OI_HCITRANS_NO_RESOURCES";
          break;
        case 1219:
          double result = "OI_HCITRANS_DRIVER_ERROR";
          break;
        case 1220:
          double result = "OI_HCITRANS_DEVICE_FATAL_ERROR";
          break;
        case 1301:
          double result = "OI_DEVMGR_NO_CONNECTION";
          break;
        case 1302:
          double result = "OI_DEVMGR_CONNECTION_PENDING_READY";
          break;
        case 1305:
          double result = "OI_DEVMGR_HARDWARE_ERROR";
          break;
        case 1307:
          double result = "OI_DEVMGR_PENDING_CONNECT_LIST_FULL";
          break;
        case 1309:
          double result = "OI_DEVMGR_CONNECTION_LIST_FULL";
          break;
        case 1310:
          double result = "OI_DEVMGR_NO_SUCH_CONNECTION";
          break;
        case 1311:
          double result = "OI_DEVMGR_INQUIRY_IN_PROGRESS";
          break;
        case 1312:
          double result = "OI_DEVMGR_PERIODIC_INQUIRY_ACTIVE";
          break;
        case 1313:
          double result = "OI_DEVMGR_NO_INQUIRIES_ACTIVE";
          break;
        case 1314:
          double result = "OI_DEVMGR_DUPLICATE_CONNECTION";
          break;
        case 1316:
          double result = "OI_DEVMGR_DUPLICATE_EVENT_CALLBACK";
          break;
        case 1317:
          double result = "OI_DEVMGR_EVENT_CALLBACK_LIST_FULL";
          break;
        case 1318:
          double result = "OI_DEVMGR_EVENT_CALLBACK_NOT_FOUND";
          break;
        case 1319:
          double result = "OI_DEVMGR_BUSY";
          break;
        case 1320:
          double result = "OI_DEVMGR_ENUM_UNEXPECTED_INQ_COMPLETE";
          break;
        case 1321:
          double result = "OI_DEVMGR_ENUM_UNEXPECTED_INQ_RESULT";
          break;
        case 1322:
          double result = "OI_DEVMGR_ENUM_DATABASE_FULL";
          break;
        case 1323:
          double result = "OI_DEVMGR_ENUM_INQUIRIES_OVERLAP";
          break;
        case 1324:
          double result = "OI_DEVMGR_UNKNOWN_LINK_TYPE";
          break;
        case 1325:
          double result = "OI_DEVMGR_PARAM_IO_ACTIVE";
          break;
        case 1326:
          double result = "OI_DEVMGR_UNKNOWN_IAC_LAP";
          break;
        case 1327:
          double result = "OI_DEVMGR_SCO_ALREADY_REGISTERED";
          break;
        case 1328:
          double result = "OI_DEVMGR_SCO_NOT_REGISTERED";
          break;
        case 1329:
          double result = "OI_DEVMGR_SCO_WITHOUT_ACL";
          break;
        case 1330:
          double result = "OI_DEVMGR_NO_SUPPORT";
          break;
        case 1331:
          double result = "OI_DEVMGR_WRITE_POLICY_FAILED";
          break;
        case 1332:
          double result = "OI_DEVMGR_NOT_IN_CENTRAL_MODE";
          break;
        case 1333:
          double result = "OI_DEVMGR_POLICY_VIOLATION";
          break;
        case 1334:
          double result = "OI_DEVMGR_BUSY_TIMEOUT";
          break;
        case 1335:
          double result = "OI_DEVMGR_REENCRYPT_FAILED";
          break;
        case 1336:
          double result = "OI_DEVMGR_ROLE_POLICY_CONFLICT";
          break;
        case 1337:
          double result = "OI_DEVMGR_BAD_INTERVAL";
          break;
        case 1338:
          double result = "OI_DEVMGR_INVALID_SCO_HANDLE";
          break;
        case 1339:
          double result = "OI_DEVMGR_CONNECTION_OVERLAP";
          break;
        case 1340:
          double result = "OI_DEVMGR_ORPHAN_SUBRATE_COMPLETE";
          break;
        case 1341:
          double result = "OI_DEVMGR_EIR_RESPONSE_2_LARGE";
          break;
        case 1342:
          double result = "OI_DEVMGR_GENTLY_CENTRAL_SKIP_CONN";
          break;
        case 1343:
          double result = "OI_DEVMGR_REQUEST_INVALID_TYPE";
          break;
        case 1344:
          double result = "OI_DEVMGR_REQUEST_CONN_DISCONNECTED";
          break;
        case 1345:
          double result = "OI_DEVMGR_REQUEST_FINISH_BONDING";
          break;
        case 1346:
          double result = "OI_DEVMGR_REQUEST_FINISH_NAME_REQ";
          break;
        case 1348:
          double result = "OI_DEVMGR_DISCONNECT_UNCONDITIONAL";
          break;
        case 1349:
          double result = "OI_DEVMGR_INVALID_HANDLE_LINK_INFO";
          break;
        case 1350:
          double result = "OI_DEVMGR_INVALID_HANDLE_COUNTER";
          break;
        case 1351:
          double result = "OI_DEVMGR_INVALID_HANDLE_LINK_QUAL";
          break;
        case 1352:
          double result = "OI_DEVMGR_INVALID_HANDLE_RSSI";
          break;
        case 1353:
          double result = "OI_DEVMGR_INVALID_HANDLE_AUTO_FLUSH";
          break;
        case 1354:
          double result = "OI_DEVMGR_INVALID_HANDLE_TX_POWER";
          break;
        case 1355:
          double result = "OI_DEVMGR_INVALID_HANDLE_MAX_POWER";
          break;
        case 1356:
          double result = "OI_DEVMGR_INVALID_HANDLE_LSTO";
          break;
        case 1358:
          double result = "OI_DEVMGR_STATUS_DEFAULT";
          break;
        case 1359:
          double result = "OI_DEVMGR_NAME_REQUEST_IS_INVALID";
          break;
        case 1360:
          double result = "OI_DEVMGR_SCO_NO_ESCO_SUPPORT";
          break;
        case 1361:
          double result = "OI_DEVMGR_INVALID_ACL_STATE";
          break;
        case 1362:
          double result = "OI_DEVMGR_REMOTENAMECANCEL_CB";
          break;
        case 1363:
          double result = "OI_DEVMGR_INVALID_HANDLE_LINK_POL";
          break;
        case 1401:
          double result = "OI_SECMGR_NO_POLICY";
          break;
        case 1402:
          double result = "OI_SECMGR_INTERNAL_ERROR";
          break;
        case 1403:
          double result = "OI_SECMGR_ORPHANED_CALLBACK";
          break;
        case 1404:
          double result = "OI_SECMGR_BUSY";
          break;
        case 1405:
          double result = "OI_SECMGR_DEVICE_NOT_TRUSTED";
          break;
        case 1407:
          double result = "OI_SECMGR_DEVICE_ENCRYPT_FAIL";
          break;
        case 1408:
          double result = "OI_SECMGR_DISCONNECTED_FAIL";
          break;
        case 1409:
          double result = "OI_SECMGR_ACCESS_PENDING";
          break;
        case 1410:
          double result = "OI_SECMGR_PIN_CODE_TOO_SHORT";
          break;
        case 1411:
          double result = "OI_SECMGR_UNKNOWN_ENCRYPT_VALUE";
          break;
        case 1412:
          double result = "OI_SECMGR_INVALID_POLICY";
          break;
        case 1413:
          double result = "OI_SECMGR_AUTHORIZATION_FAILED";
          break;
        case 1414:
          double result = "OI_SECMGR_ENCRYPTION_FAILED";
          break;
        case 1415:
          double result = "OI_SECMGR_UNIT_KEY_UNSUPPORTED";
          break;
        case 1416:
          double result = "OI_SECMGR_NOT_REGISTERED";
          break;
        case 1417:
          double result = "OI_SECMGR_ILLEGAL_WRITE_SSP_MODE";
          break;
        case 1418:
          double result = "OI_SECMGR_INVALID_SEC_LEVEL";
          break;
        case 1419:
          double result = "OI_SECMGR_INSUFFICIENT_LINK_KEY";
          break;
        case 1420:
          double result = "OI_SECMGR_INVALID_KEY_TYPE";
          break;
        case 1421:
          double result = "OI_SECMGR_SSP_NOT_ENCRYPTED";
          break;
        case 1422:
          double result = "OI_SECMGR_ORPHAN_EVENT";
          break;
        case 1423:
          double result = "OI_SECMGR_NOT_BONDABLE";
          break;
        case 1424:
          double result = "OI_SECMGR_INVALID_REMOTE_AUTH";
          break;
        default:
          return 0;
      }
    }
    else
    {
      switch(a1)
      {
        case 402:
          double result = "OI_STATUS_PSM_ALREADY_REGISTERED";
          break;
        case 403:
          double result = "OI_STATUS_INVALID_CID";
          break;
        case 404:
          double result = "OI_STATUS_CID_NOT_FOUND";
          break;
        case 405:
        case 409:
        case 413:
        case 415:
        case 416:
        case 417:
        case 419:
        case 420:
        case 421:
        case 422:
        case 424:
        case 432:
        case 438:
        case 442:
        case 443:
        case 446:
        case 447:
        case 448:
        case 449:
        case 455:
        case 456:
        case 457:
        case 458:
        case 459:
        case 465:
        case 466:
        case 467:
        case 468:
        case 469:
        case 473:
        case 474:
        case 475:
        case 476:
        case 477:
        case 478:
        case 479:
        case 480:
        case 481:
        case 487:
        case 488:
        case 489:
        case 491:
        case 492:
        case 493:
        case 494:
        case 495:
        case 496:
        case 497:
        case 498:
        case 499:
        case 504:
        case 505:
        case 506:
        case 507:
        case 512:
        case 513:
        case 514:
        case 515:
        case 516:
        case 517:
        case 518:
        case 519:
        case 520:
        case 521:
        case 522:
        case 523:
        case 524:
        case 525:
        case 526:
        case 527:
        case 528:
        case 529:
        case 557:
        case 561:
        case 562:
        case 563:
        case 564:
        case 565:
        case 566:
        case 567:
        case 568:
        case 569:
        case 570:
        case 571:
        case 572:
        case 573:
        case 574:
        case 575:
        case 576:
        case 577:
        case 578:
        case 579:
        case 581:
        case 583:
        case 592:
        case 593:
        case 594:
        case 595:
        case 596:
        case 597:
        case 598:
        case 599:
        case 600:
        case 602:
        case 604:
        case 606:
        case 609:
        case 610:
        case 617:
        case 618:
        case 636:
        case 655:
        case 656:
        case 657:
        case 658:
        case 659:
        case 660:
        case 661:
        case 662:
        case 663:
        case 664:
        case 665:
        case 666:
        case 667:
        case 668:
        case 669:
        case 670:
        case 671:
        case 672:
        case 673:
        case 674:
        case 675:
        case 676:
        case 677:
        case 678:
        case 679:
        case 680:
        case 681:
        case 682:
        case 683:
        case 684:
        case 685:
        case 686:
        case 687:
        case 688:
        case 689:
        case 690:
        case 691:
        case 692:
        case 693:
        case 694:
        case 695:
        case 696:
        case 697:
        case 698:
        case 699:
        case 700:
        case 764:
        case 765:
        case 767:
        case 768:
        case 770:
        case 771:
        case 772:
        case 773:
        case 774:
        case 775:
        case 776:
        case 777:
        case 778:
        case 779:
        case 780:
        case 781:
        case 782:
        case 783:
        case 784:
        case 785:
        case 786:
        case 787:
        case 788:
        case 789:
        case 790:
        case 791:
        case 792:
        case 793:
        case 794:
        case 795:
        case 796:
        case 797:
        case 798:
        case 799:
        case 801:
        case 809:
        case 814:
        case 818:
        case 820:
        case 822:
        case 828:
        case 848:
        case 849:
        case 850:
        case 851:
        case 852:
        case 853:
        case 854:
        case 855:
        case 856:
        case 857:
        case 858:
        case 859:
        case 860:
        case 861:
        case 862:
        case 863:
        case 864:
        case 865:
        case 866:
        case 867:
        case 868:
        case 869:
        case 870:
        case 871:
        case 872:
        case 873:
        case 874:
        case 875:
        case 876:
        case 877:
        case 878:
        case 879:
        case 880:
        case 881:
        case 882:
        case 883:
        case 884:
        case 885:
        case 886:
        case 887:
        case 888:
        case 889:
        case 890:
        case 891:
        case 892:
        case 893:
        case 894:
        case 895:
        case 896:
        case 897:
        case 898:
        case 899:
        case 900:
        case 902:
        case 914:
        case 919:
        case 936:
        case 937:
        case 938:
        case 939:
        case 940:
        case 941:
        case 942:
        case 943:
        case 944:
        case 945:
        case 946:
        case 947:
        case 948:
        case 949:
        case 950:
        case 951:
        case 952:
        case 953:
        case 954:
        case 955:
        case 956:
        case 957:
        case 958:
        case 959:
        case 960:
        case 961:
        case 962:
        case 963:
        case 964:
        case 965:
        case 966:
        case 967:
        case 968:
        case 969:
        case 970:
        case 971:
        case 972:
        case 973:
        case 974:
        case 975:
        case 976:
        case 977:
        case 978:
        case 979:
        case 980:
        case 981:
        case 982:
        case 983:
        case 984:
        case 985:
        case 986:
        case 987:
        case 988:
        case 989:
        case 990:
        case 991:
        case 992:
        case 993:
        case 994:
        case 995:
        case 996:
        case 997:
        case 998:
        case 999:
        case 1000:
        case 1003:
        case 1004:
        case 1005:
        case 1006:
        case 1007:
        case 1008:
        case 1009:
        case 1011:
        case 1012:
        case 1013:
        case 1014:
        case 1015:
        case 1016:
        case 1017:
        case 1018:
        case 1019:
        case 1020:
        case 1024:
        case 1025:
        case 1026:
        case 1027:
        case 1028:
        case 1029:
        case 1032:
        case 1033:
        case 1034:
        case 1035:
        case 1036:
        case 1037:
        case 1038:
        case 1039:
        case 1052:
        case 1053:
        case 1054:
        case 1055:
        case 1056:
        case 1057:
        case 1058:
        case 1059:
        case 1060:
        case 1061:
        case 1062:
        case 1063:
        case 1064:
        case 1068:
        case 1069:
        case 1070:
        case 1071:
        case 1072:
        case 1073:
        case 1074:
        case 1075:
        case 1076:
        case 1077:
        case 1078:
        case 1079:
        case 1080:
        case 1081:
        case 1082:
        case 1083:
        case 1084:
        case 1085:
        case 1086:
        case 1087:
        case 1088:
        case 1089:
        case 1090:
        case 1091:
        case 1092:
        case 1093:
        case 1094:
        case 1095:
        case 1096:
        case 1097:
        case 1098:
        case 1099:
        case 1100:
          return 0;
        case 406:
          double result = "OI_STATUS_CHANNEL_NOT_FOUND";
          break;
        case 407:
          double result = "OI_STATUS_PSM_NOT_FOUND";
          break;
        case 408:
          double result = "OI_STATUS_INVALID_STATE";
          break;
        case 410:
          double result = "OI_STATUS_WRITE_IN_PROGRESS";
          break;
        case 411:
          double result = "OI_STATUS_INVALID_PACKET";
          break;
        case 412:
          double result = "OI_STATUS_SEND_COMPLETE";
          break;
        case 414:
          double result = "OI_STATUS_INVALID_HANDLE";
          break;
        case 418:
          double result = "OI_STATUS_GROUP_FULL";
          break;
        case 423:
          double result = "OI_STATUS_DEVICE_ALREADY_IN_GROUP";
          break;
        case 425:
          double result = "OI_STATUS_DUPLICATE_GROUP";
          break;
        case 426:
          double result = "OI_STATUS_EMPTY_GROUP";
          break;
        case 427:
          double result = "OI_STATUS_PACKET_NOT_FOUND";
          break;
        case 428:
          double result = "OI_STATUS_BUFFER_TOO_SMALL";
          break;
        case 429:
          double result = "OI_STATUS_IDENTIFIER_NOT_FOUND";
          break;
        case 430:
          double result = "OI_L2CAP_DISCONNECT_LOWER_LAYER";
          break;
        case 431:
          double result = "OI_L2CAP_DISCONNECT_REMOTE_REQUEST";
          break;
        case 433:
          double result = "OI_L2CAP_GROUP_ADD_CONNECT_FAIL";
          break;
        case 434:
          double result = "OI_L2CAP_GROUP_REMOVE_FAILURE";
          break;
        case 435:
          double result = "OI_L2CAP_DATA_WRITE_ERROR_LINK_TERM";
          break;
        case 436:
          double result = "OI_L2CAP_DISCONNECT_LOCAL_REQUEST";
          break;
        case 437:
          double result = "OI_L2CAP_CONNECT_TIMEOUT";
          break;
        case 439:
          double result = "OI_L2CAP_DISCONNECT_TIMEOUT";
          break;
        case 440:
          double result = "OI_L2CAP_PING_TIMEOUT";
          break;
        case 441:
          double result = "OI_L2CAP_GET_INFO_TIMEOUT";
          break;
        case 444:
          double result = "OI_L2CAP_INVALID_ADDRESS";
          break;
        case 445:
          double result = "OI_L2CAP_CMD_REJECT_RCVD";
          break;
        case 450:
          double result = "OI_L2CAP_CONNECT_BASE";
          break;
        case 451:
          double result = "OI_L2CAP_CONNECT_PENDING";
          break;
        case 452:
          double result = "OI_L2CAP_CONNECT_REFUSED_INVALID_PSM";
          break;
        case 453:
          double result = "OI_L2CAP_CONNECT_REFUSED_SECURITY";
          break;
        case 454:
          double result = "OI_L2CAP_CONNECT_REFUSED_NO_RESOURCES";
          break;
        case 460:
          double result = "OI_L2CAP_CONFIG_BASE";
          break;
        case 461:
          double result = "OI_L2CAP_CONFIG_FAIL_INVALID_PARAMETERS";
          break;
        case 462:
          double result = "OI_L2CAP_CONFIG_FAIL_NO_REASON";
          break;
        case 463:
          double result = "OI_L2CAP_CONFIG_FAIL_UNKNOWN_OPTIONS";
          break;
        case 464:
          double result = "OI_L2CAP_CONFIG_FAIL_TIMEOUT";
          break;
        case 470:
          double result = "OI_L2CAP_GET_INFO_BASE";
          break;
        case 471:
          double result = "OI_L2CAP_GET_INFO_NOT_SUPPORTED";
          break;
        case 472:
          double result = "OI_L2CAP_MTU_EXCEEDED";
          break;
        case 482:
          double result = "OI_L2CAP_INVALID_PSM";
          break;
        case 483:
          double result = "OI_L2CAP_INVALID_MTU";
          break;
        case 484:
          double result = "OI_L2CAP_INVALID_FLUSHTO";
          break;
        case 485:
          double result = "OI_L2CAP_DEQUEUE_ERT_ERROR";
          break;
        case 486:
          double result = "OI_L2CAP_ZERO_LENGTH_RECV_PAYLOAD";
          break;
        case 490:
          double result = "OI_L2CAP_INVALID_FLOW_CONTROL";
          break;
        case 500:
          double result = "OI_L2CAP_QUEUE_LOCAL_NOT_READY";
          break;
        case 501:
          double result = "OI_L2CAP_QUEUE_REMOTE_NOT_READY";
          break;
        case 502:
          double result = "OI_L2CAP_QUEUE_FRAGMENTATION";
          break;
        case 503:
          double result = "OI_L2CAP_QUEUE_SFRAME_HEADER_ERROR";
          break;
        case 508:
          double result = "OI_L2CAP_QUEUE_ERTM_CID_ERROR";
          break;
        case 509:
          double result = "OI_L2CAP_QUEUE_SUPERVISION_ERROR";
          break;
        case 510:
          double result = "OI_L2CAP_QUEUE_RETRANS_ERROR";
          break;
        case 511:
          double result = "OI_L2CAP_QUEUE_THREAD_CREATION_FAILED";
          break;
        case 530:
          double result = "OI_L2CAP_ACCEPT_RESPOND_REJECT";
          break;
        case 531:
          double result = "OI_L2CAP_CONMAN_DEFAULT";
          break;
        case 532:
          double result = "OI_L2CAP_FIXCHAN_WRONG_TYPE";
          break;
        case 533:
          double result = "OI_L2CAP_FLOW_SENT_INVALID_CHANNEL";
          break;
        case 534:
          double result = "OI_L2CAP_FLOW_UNEXPECTED_STATE";
          break;
        case 535:
          double result = "OI_L2CAP_FLOW_INIT_INVALID_CHAN";
          break;
        case 536:
          double result = "OI_L2CAP_FLOW_RECV_INVALID_CHAN";
          break;
        case 537:
          double result = "OI_L2CAP_QOS_POKE_INVALID_CHAN";
          break;
        case 538:
          double result = "OI_L2CAP_ERTM_SENDSREJLIST_ERROR";
          break;
        case 539:
          double result = "OI_L2CAP_ERTM_SENDSREJTAIL_ERROR";
          break;
        case 540:
          double result = "OI_L2CAP_ERTM_RETRANS_IFRAME_ERROR";
          break;
        case 541:
          double result = "OI_L2CAP_ERTM_RETRANS_IFRAME_COUNT_EXCEEDED";
          break;
        case 542:
          double result = "OI_L2CAP_ERTM_RETRANS_REQ_IFRAME_ERROR";
          break;
        case 543:
          double result = "OI_L2CAP_ERTM_RX_IFRAME_IN_RX_UNEXPECTED_STATE";
          break;
        case 544:
          double result = "OI_L2CAP_ERTM_RX_IFRAME_IN_REJ_UNEXPECTED_STATE";
          break;
        case 545:
          double result = "OI_L2CAP_ERTM_RX_IFRAME_IN_SREJ_UNEXPECTED_STATE";
          break;
        case 546:
          double result = "OI_L2CAP_ERTM_RETRANS_BAD_LENGTH_RECVD_DATA";
          break;
        case 547:
          double result = "OI_L2CAP_ERTM_RETRANS_BAD_SFRAME_RECVD_DATA";
          break;
        case 548:
          double result = "OI_L2CAP_ERTM_RETRANS_BAD_IFRAME_RECVD_DATA";
          break;
        case 549:
          double result = "OI_L2CAP_ERTM_RETRANS_ALLOC_FAIL_RECVD_DATA";
          break;
        case 550:
          double result = "OI_L2CAP_ERTM_RECVDATA_UNEXPECTED_STATE";
          break;
        case 551:
          double result = "OI_L2CAP_ERTM_LOCAL_BUSY_UNEXPECTED_STATE";
          break;
        case 552:
          double result = "OI_L2CAP_ERTM_LOCAL_BUSY_CLEAR_UNEXPECTED_STATE";
          break;
        case 553:
          double result = "OI_L2CAP_ERTM_SEQ_N_FBIT_UNEXPECTED_STATE";
          break;
        case 554:
          double result = "OI_L2CAP_ERTM_FBIT_UNEXPECTED_STATE";
          break;
        case 555:
          double result = "OI_L2CAP_ERTM_UNEXPECTED_RETRX_TIMER";
          break;
        case 556:
          double result = "OI_L2CAP_ERTM_UNEXPECTED_MONITOR_TIMER";
          break;
        case 558:
          double result = "OI_L2CAP_ERTM_TIMEOUT";
          break;
        case 559:
          double result = "OI_L2CAP_SIGNALMAN_TIMEOUT";
          break;
        case 560:
          double result = "OI_L2CAP_DISC_DLCI0";
          break;
        case 580:
          double result = "OI_L2CAP_LE_BASE";
          break;
        case 582:
          double result = "OI_L2CAP_LE_LE_PSM_NOT_SUPPORTED";
          break;
        case 584:
          double result = "OI_L2CAP_LE_NO_RESOURCES";
          break;
        case 585:
          double result = "OI_L2CAP_LE_INSUFFICIENT_AUTHENTICATION";
          break;
        case 586:
          double result = "OI_L2CAP_LE_INSUFFICIENT_AUTHORIZATION";
          break;
        case 587:
          double result = "OI_L2CAP_LE_INSUFFICIENT_ENC_KEY_SIZE";
          break;
        case 588:
          double result = "OI_L2CAP_LE_INSUFFICIENT_ENCRYPTION";
          break;
        case 589:
          double result = "OI_L2CAP_LE_INVALID_SOURCE_CID";
          break;
        case 590:
          double result = "OI_L2CAP_LE_SOURCE_CID_ALREADY_REGISTERED";
          break;
        case 591:
          double result = "OI_L2CAP_LE_UNACCEPTABLE_PARAMS";
          break;
        case 601:
          double result = "OI_HCI_NO_SUCH_CONNECTION";
          break;
        case 603:
          double result = "OI_HCI_CB_LIST_FULL";
          break;
        case 605:
          double result = "OI_HCI_EVENT_UNDERRUN";
          break;
        case 607:
          double result = "OI_HCI_UNKNOWN_EVENT_CODE";
          break;
        case 608:
          double result = "OI_HCI_BAD_EVENT_PARM_LEN";
          break;
        case 611:
          double result = "OI_HCI_CMD_QUEUE_FULL";
          break;
        case 612:
          double result = "OI_HCI_SHORT_EVENT";
          break;
        case 613:
          double result = "OI_HCI_TRANSMIT_NOT_READY";
          break;
        case 614:
          double result = "OI_HCI_ORPHAN_SENT_EVENT";
          break;
        case 615:
          double result = "OI_HCI_CMD_TABLE_ERROR";
          break;
        case 616:
          double result = "OI_HCI_UNKNOWN_CMD_ID";
          break;
        case 619:
          double result = "OI_HCI_UNEXPECTED_EVENT";
          break;
        case 620:
          double result = "OI_HCI_EVENT_TABLE_ERROR";
          break;
        case 621:
          double result = "OI_HCI_EXPECTED_EVENT_TIMEOUT";
          break;
        case 622:
          double result = "OI_HCI_NO_CMD_DESC_FOR_OPCODE";
          break;
        case 623:
          double result = "OI_HCI_INVALID_OPCODE_ERROR";
          break;
        case 624:
          double result = "OI_HCI_FLOW_CONTROL_DISABLED";
          break;
        case 625:
          double result = "OI_HCI_TX_COMPLETE";
          break;
        case 626:
          double result = "OI_HCI_TX_ERROR";
          break;
        case 627:
          double result = "OI_HCI_DEVICE_NOT_INITIALIZED";
          break;
        case 628:
          double result = "OI_HCI_UNSUPPORTED_COMMAND";
          break;
        case 629:
          double result = "OI_HCI_PASSTHROUGH_ERROR";
          break;
        case 630:
          double result = "OI_HCI_PASSTHROUGH_ALREADY_SET";
          break;
        case 631:
          double result = "OI_HCI_RESET_FAILURE";
          break;
        case 632:
          double result = "OI_HCI_TRANSPORT_RESET";
          break;
        case 633:
          double result = "OI_HCIERR_HCIIFC_INIT_FAILURE";
          break;
        case 634:
          double result = "OI_HCI_EXPECTED_EVENT_CONN_RELEASED";
          break;
        case 635:
          double result = "OI_HCI_EXPECTED_EVENT_ORPHANED";
          break;
        case 637:
          double result = "OI_HCI_STATUS_DEFAULT";
          break;
        case 638:
          double result = "OI_HCI_FAIL_MISSING_PARAMS";
          break;
        case 639:
          double result = "OI_HCI_MISSING_LINKTYPE";
          break;
        case 640:
          double result = "OI_HCI_EXPECTED_EVENT_NOT_FOUND";
          break;
        case 641:
          double result = "OI_HCI_WRITE_COD_HW_WORKAROUND";
          break;
        case 642:
          double result = "OI_HCI_HW_ERROR_CHIP_RX_INVALID";
          break;
        case 643:
          double result = "OI_HCI_HW_ERROR_HOST_RX_INVALID";
          break;
        case 644:
          double result = "OI_HCI_HW_ERROR_TIMEDOUT_INVALID";
          break;
        case 645:
          double result = "OI_HCI_HW_ERROR_RX_INVALID_STATE";
          break;
        case 646:
          double result = "OI_HCI_HW_ERROR_TIMEDOUT_INVALID_STATE";
          break;
        case 647:
          double result = "OI_HCI_HW_ERROR_RX_INVALID_LENGTH";
          break;
        case 648:
          double result = "OI_HCI_HW_ERROR_CODE_UNKNOWN";
          break;
        case 649:
          double result = "OI_HCI_DUPLICATE_LM_HANDLE";
          break;
        case 650:
          double result = "OI_HCI_HW_ERROR_NOT_INITIALIZED";
          break;
        case 651:
          double result = "OI_HCI_EVENT_DATA_UNDERRUN";
          break;
        case 652:
          double result = "OI_HCI_HW_ERROR_SPMI_TIMEOUT";
          break;
        case 653:
          double result = "OI_HCI_HW_ERROR_DID_NOT_SLEEP";
          break;
        case 654:
          double result = "OI_HCI_HW_ERROR_CMD_DISALLOWED";
          break;
        case 701:
          double result = "OI_HCIERR_UNKNOWN_HCI_COMMAND";
          break;
        case 702:
          double result = "OI_HCIERR_UNKNOWN_CONNECTION_IDENTIFIER";
          break;
        case 703:
          double result = "OI_HCIERR_HARDWARE_FAILURE";
          break;
        case 704:
          double result = "OI_HCIERR_PAGE_TIMEOUT";
          break;
        case 705:
          double result = "OI_HCIERR_AUTHENTICATION_FAILURE";
          break;
        case 706:
          double result = "OI_HCIERR_KEY_MISSING";
          break;
        case 707:
          double result = "OI_HCIERR_MEMORY_CAPACITY_EXCEEDED";
          break;
        case 708:
          double result = "OI_HCIERR_CONNECTION_TIMEOUT";
          break;
        case 709:
          double result = "OI_HCIERR_MAX_NUM_OF_CONNECTIONS";
          break;
        case 710:
          double result = "OI_HCIERR_MAX_NUM_OF_SCO_CONNECTIONS";
          break;
        case 711:
          double result = "OI_HCIERR_ACL_CONNECTION_ALREADY_EXISTS";
          break;
        case 712:
          double result = "OI_HCIERR_COMMAND_DISALLOWED";
          break;
        case 713:
          double result = "OI_HCIERR_HOST_REJECTED_RESOURCES";
          break;
        case 714:
          double result = "OI_HCIERR_HOST_REJECTED_SECURITY";
          break;
        case 715:
          double result = "OI_HCIERR_HOST_REJECTED_PERSONAL_DEVICE";
          break;
        case 716:
          double result = "OI_HCIERR_HOST_TIMEOUT";
          break;
        case 717:
          double result = "OI_HCIERR_UNSUPPORTED";
          break;
        case 718:
          double result = "OI_HCIERR_INVALID_PARAMETERS";
          break;
        case 719:
          double result = "OI_HCIERR_OTHER_END_USER_DISCONNECT";
          break;
        case 720:
          double result = "OI_HCIERR_OTHER_END_LOW_RESOURCES";
          break;
        case 721:
          double result = "OI_HCIERR_OTHER_END_POWERING_OFF";
          break;
        case 722:
          double result = "OI_HCIERR_CONNECTION_TERMINATED_LOCALLY";
          break;
        case 723:
          double result = "OI_HCIERR_REPEATED_ATTEMPTS";
          break;
        case 724:
          double result = "OI_HCIERR_PAIRING_NOT_ALLOWED";
          break;
        case 725:
          double result = "OI_HCIERR_UNKNOWN_LMP_PDU";
          break;
        case 726:
          double result = "OI_HCIERR_UNSUPPORTED_REMOTE_FEATURE";
          break;
        case 727:
          double result = "OI_HCIERR_SCO_OFFSET_REJECTED";
          break;
        case 728:
          double result = "OI_HCIERR_SCO_INTERVAL_REJECTED";
          break;
        case 729:
          double result = "OI_HCIERR_SCO_AIR_MODE_REJECTED";
          break;
        case 730:
          double result = "OI_HCIERR_INVALID_LMP_PARMS";
          break;
        case 731:
          double result = "OI_HCIERR_UNSPECIFIED_ERROR";
          break;
        case 732:
          double result = "OI_HCIERR_UNSUPPORTED_LMP_PARAMETERS";
          break;
        case 733:
          double result = "OI_HCIERR_ROLE_CHANGE_NOT_ALLOWED";
          break;
        case 734:
          double result = "OI_HCIERR_LMP_RESPONSE_TIMEOUT";
          break;
        case 735:
          double result = "OI_HCIERR_LMP_ERROR_TRANS_COLLISION";
          break;
        case 736:
          double result = "OI_HCIERR_LMP_PDU_NOT_ALLOWED";
          break;
        case 737:
          double result = "OI_HCIERR_ENCRYPTION_MODE_NOT_ACCEPTABLE";
          break;
        case 738:
          double result = "OI_HCIERR_UNIT_KEY_USED";
          break;
        case 739:
          double result = "OI_HCIERR_QOS_NOT_SUPPORTED";
          break;
        case 740:
          double result = "OI_HCIERR_INSTANT_PASSED";
          break;
        case 741:
          double result = "OI_HCIERR_UNIT_KEY_PAIRING_UNSUPPORTED";
          break;
        case 742:
          double result = "OI_HCIERR_DIFFERENT_TRANS_COLLISION";
          break;
        case 743:
          double result = "OI_HCIERR_RESERVED_2B";
          break;
        case 744:
          double result = "OI_HCIERR_QOS_UNACCEPTABLE_PARAMETER";
          break;
        case 745:
          double result = "OI_HCIERR_QOS_REJECTED";
          break;
        case 746:
          double result = "OI_HCIERR_CHANNEL_CLASSIFICATION_NOT_SUPPORTED";
          break;
        case 747:
          double result = "OI_HCIERR_INSUFFICIENT_SECURITY";
          break;
        case 748:
          double result = "OI_HCIERR_PARAMETER_OUT_OF_MANDATORY_RANGE";
          break;
        case 749:
          double result = "OI_HCIERR_RESERVED_31";
          break;
        case 750:
          double result = "OI_HCIERR_ROLE_SWITCH_PENDING";
          break;
        case 751:
          double result = "OI_HCIERR_RESERVED_33";
          break;
        case 752:
          double result = "OI_HCIERR_RESERVED_SLOT_VIOLATION";
          break;
        case 753:
          double result = "OI_HCIERR_ROLE_SWITCH_FAILED";
          break;
        case 754:
          double result = "OI_HCIERR_EIR_TOO_LARGE";
          break;
        case 755:
          double result = "OI_HCIERR_SSP_NOT_SUPPORTED_BY_HOST";
          break;
        case 756:
          double result = "OI_HCIERR_HOST_BUSY_PAIRING";
          break;
        case 757:
          double result = "OI_HCIERR_CONNECTION_REJ_NO_SUITABLE_CHANNEL";
          break;
        case 758:
          double result = "OI_HCIERR_CONTROLLER_BUSY";
          break;
        case 759:
          double result = "OI_HCIERR_UNACCEPTABLE_CONNECTION_PARAMETERS";
          break;
        case 760:
          double result = "OI_HCIERR_ADVERTISING_TIMEOUT";
          break;
        case 761:
          double result = "OI_HCIERR_CONNECTION_TERMINATED_DUE_TO_MIC_FAILURE";
          break;
        case 762:
          double result = "OI_HCIERR_CONNECTION_FAILED_TO_BE_ESTABLISHED";
          break;
        case 763:
          double result = "OI_HCIERR_MAC_CONNECTION_FAILED";
          break;
        case 766:
          double result = "OI_HCIERR_UNKNOWN_ADVERTISING_IDENTIFIER";
          break;
        case 769:
          double result = "OI_HCIERR_UNKNOWN_ERROR";
          break;
        case 800:
          double result = "OI_SDP_SPEC_ERROR";
          break;
        case 802:
          double result = "OI_SDP_INVALID_SERVICE_RECORD_HANDLE";
          break;
        case 803:
          double result = "OI_SDP_INVALID_REQUEST_SYNTAX";
          break;
        case 804:
          double result = "OI_SDP_INVALID_PDU_SIZE";
          break;
        case 805:
          double result = "OI_SDP_INVALID_CONTINUATION_STATE";
          break;
        case 806:
          double result = "OI_SDP_INSUFFICIENT_RESOURCES";
          break;
        case 807:
          double result = "OI_SDP_ERROR";
          break;
        case 808:
          double result = "OI_SDP_CORRUPT_DATA_ELEMENT";
          break;
        case 810:
          double result = "OI_SDP_SERVER_NOT_CONNECTED";
          break;
        case 811:
          double result = "OI_SDP_ACCESS_DENIED";
          break;
        case 812:
          double result = "OI_SDP_ATTRIBUTES_OUT_OF_ORDER";
          break;
        case 813:
          double result = "OI_SDP_DEVICE_DOES_NOT_SUPPORT_SDP";
          break;
        case 815:
          double result = "OI_SDP_NO_MORE_DATA";
          break;
        case 816:
          double result = "OI_SDP_REQUEST_PARAMS_TOO_LONG";
          break;
        case 817:
          double result = "OI_SDP_REQUEST_PENDING";
          break;
        case 819:
          double result = "OI_SDP_SERVER_CONNECT_FAILED";
          break;
        case 821:
          double result = "OI_SDP_SERVER_TOO_MANY_CONNECTIONS";
          break;
        case 823:
          double result = "OI_SDP_NO_MATCHING_SERVICE_RECORD";
          break;
        case 824:
          double result = "OI_SDP_PARTIAL_RESPONSE";
          break;
        case 825:
          double result = "OI_SDP_ILLEGAL_ARGUMENT";
          break;
        case 826:
          double result = "OI_SDP_ATTRIBUTE_NOT_FOUND";
          break;
        case 827:
          double result = "OI_SDP_DATABASE_OUT_OF_RESOURCES";
          break;
        case 829:
          double result = "OI_SDP_SHORT_PDU";
          break;
        case 830:
          double result = "OI_SDP_TRANSACTION_ID_MISMATCH";
          break;
        case 831:
          double result = "OI_SDP_UNEXPECTED_RESPONSE_PDU_ID";
          break;
        case 832:
          double result = "OI_SDP_REQUEST_TIMEOUT";
          break;
        case 833:
          double result = "OI_SDP_INVALID_RESPONSE_SYNTAX";
          break;
        case 834:
          double result = "OI_SDP_CONNECTION_TIMEOUT";
          break;
        case 835:
          double result = "OI_SDP_RESPONSE_DATA_ERROR";
          break;
        case 836:
          double result = "OI_SDP_TOO_MANY_ATTRIBUTE_BYTES";
          break;
        case 837:
          double result = "OI_SDP_TOO_MANY_SERVICE_RECORDS";
          break;
        case 838:
          double result = "OI_SDP_INVALID_CONNECTION_ID";
          break;
        case 839:
          double result = "OI_SDP_CANNOT_SET_ATTRIBUTE";
          break;
        case 840:
          double result = "OI_SDP_BADLY_FORMED_ATTRIBUTE_VALUE";
          break;
        case 841:
          double result = "OI_SDP_NO_ATTRIBUTE_LIST_TO_REMOVE";
          break;
        case 842:
          double result = "OI_SDP_ATTRIBUTE_LIST_ALREADY_ADDED";
          break;
        case 843:
          double result = "OI_SDP_DATA_ELEMENT_TRUNCATED";
          break;
        case 844:
          double result = "OI_SDP_STATUS_DEFAULT";
          break;
        case 845:
          double result = "OI_SDP_ACCEPT_INCOMING_REQUEST";
          break;
        case 846:
          double result = "OI_SDP_REJECT_INCOMING_REQUEST";
          break;
        case 847:
          double result = "OI_SDP_STALL_INCOMING_REQUEST";
          break;
        case 901:
          double result = "OI_RFCOMM_WRITE_IN_PROGRESS";
          break;
        case 903:
          double result = "OI_RFCOMM_INVALID_BAUDRATE";
          break;
        case 904:
          double result = "OI_RFCOMM_INVALID_DATABIT";
          break;
        case 905:
          double result = "OI_RFCOMM_INVALID_STOPBIT";
          break;
        case 906:
          double result = "OI_RFCOMM_INVALID_PARITY";
          break;
        case 907:
          double result = "OI_RFCOMM_INVALID_PARITYTYPE";
          break;
        case 908:
          double result = "OI_RFCOMM_INVALID_FLOWCONTROL";
          break;
        case 909:
          double result = "OI_RFCOMM_SESSION_EXISTS";
          break;
        case 910:
          double result = "OI_RFCOMM_INVALID_CHANNEL";
          break;
        case 911:
          double result = "OI_RFCOMM_DLCI_EXISTS";
          break;
        case 912:
          double result = "OI_RFCOMM_LINK_NOT_FOUND";
          break;
        case 913:
          double result = "OI_RFCOMM_REMOTE_REJECT";
          break;
        case 915:
          double result = "OI_RFCOMM_TEST_IN_PROGRESS";
          break;
        case 916:
          double result = "OI_RFCOMM_SESSION_NOT_FOUND";
          break;
        case 917:
          double result = "OI_RFCOMM_INVALID_PACKET";
          break;
        case 918:
          double result = "OI_RFCOMM_FRAMESIZE_EXCEEDED";
          break;
        case 920:
          double result = "OI_RFCOMM_INVALID_DLCI";
          break;
        case 921:
          double result = "OI_RFCOMM_SERVER_NOT_REGISTERED";
          break;
        case 922:
          double result = "OI_RFCOMM_CREDIT_ERROR";
          break;
        case 923:
          double result = "OI_RFCOMM_NO_CHANNEL_NUMBER";
          break;
        case 924:
          double result = "OI_RFCOMM_QUERY_IN_PROGRESS";
          break;
        case 925:
          double result = "OI_RFCOMM_SESSION_SHUTDOWN";
          break;
        case 926:
          double result = "OI_RFCOMM_LOCAL_DEVICE_DISCONNECTED";
          break;
        case 927:
          double result = "OI_RFCOMM_REMOTE_DEVICE_DISCONNECTED";
          break;
        case 928:
          double result = "OI_RFCOMM_OUT_OF_SERVER_CHANNELS";
          break;
        case 929:
          double result = "OI_RFCOMM_SESSION_REQ_REJECTED";
          break;
        case 930:
          double result = "OI_RFCOMM_SESSION_SHUTDOWN_TIMER_EXPIRED";
          break;
        case 931:
          double result = "OI_RFCOMM_SESSION_SHUTDOWN_FRAME_TIMER_EXPIRED";
          break;
        case 932:
          double result = "OI_RFCOMM_SESSION_SHUTDOWN_SEND_CREDIT_FAILED";
          break;
        case 933:
          double result = "OI_RFCOMM_LINK_DISC_UA_SEND_FAILED";
          break;
        case 934:
          double result = "OI_RFCOMM_LINK_DISC_REMOTE_ERROR";
          break;
        case 935:
          double result = "OI_RFCOMM_LINK_DISC_FAILED";
          break;
        case 1001:
          double result = "OI_DISPATCH_INVALID_CB_HANDLE";
          break;
        case 1002:
          double result = "OI_DISPATCH_TABLE_OVERFLOW";
          break;
        case 1010:
          double result = "OI_DATAELEM_INVALID_TYPE_ERROR";
          break;
        case 1021:
          double result = "OI_SUPPORT_STRCAT_ERROR";
          break;
        case 1022:
          double result = "OI_SUPPORT_MUTEX_FAILED";
          break;
        case 1023:
          double result = "OI_SUPPORT_CMDCHAIN_INITIATE_ERROR";
          break;
        case 1030:
          double result = "OI_BYTESTREAM_INVALID_DATA_POINTER";
          break;
        case 1031:
          double result = "OI_BYTESTREAM_PARSE_ERROR";
          break;
        case 1040:
          double result = "OI_OS_INTF_ABS_TIME_FAIL";
          break;
        case 1041:
          double result = "OI_OS_INTF_AES128_CREATE_ERROR";
          break;
        case 1042:
          double result = "OI_OS_INTF_AES128_UPDATE_ERROR";
          break;
        case 1043:
          double result = "OI_OS_INTF_AES128_SIZE_ERROR";
          break;
        case 1044:
          double result = "OI_OS_INTF_SUBKEY_ERROR";
          break;
        case 1045:
          double result = "OI_OS_INTF_MAC_SUBKEY_ERROR";
          break;
        case 1046:
          double result = "OI_OS_INTF_MAC_BLOCKS_ERROR";
          break;
        case 1047:
          double result = "OI_OS_INTF_MAC_XOR_ERROR";
          break;
        case 1048:
          double result = "OI_OS_INTF_DHKEY_PUB_ERROR";
          break;
        case 1049:
          double result = "OI_OS_INTF_DHKEY_PRIV_ERROR";
          break;
        case 1050:
          double result = "OI_OS_INTF_DHKEY_COMPUTE_KEY_ERROR";
          break;
        case 1051:
          double result = "OI_OS_INTF_READ_LOCAL_PUBLIC_ERROR";
          break;
        case 1065:
          double result = "OI_PLTF_INIT_ERROR";
          break;
        case 1066:
          double result = "OI_PLTF_DEV_NAME_ERROR";
          break;
        case 1067:
          double result = "OI_PLTF_DEV_ADDR_ERROR";
          break;
        case 1101:
          double result = "OI_TEST_UNKNOWN_TEST";
          break;
        case 1102:
          double result = "OI_TEST_FAIL";
          break;
        default:
          switch(a1)
          {
            case 101:
              double result = "OI_STATUS_INVALID_PARAMETERS";
              break;
            case 102:
              double result = "OI_STATUS_NOT_IMPLEMENTED";
              break;
            case 103:
              double result = "OI_STATUS_NOT_INITIALIZED";
              break;
            case 104:
              double result = "OI_STATUS_NO_RESOURCES";
              break;
            case 105:
              double result = "OI_STATUS_INTERNAL_ERROR";
              break;
            case 106:
              double result = "OI_STATUS_OUT_OF_MEMORY";
              break;
            case 107:
              double result = "OI_ILLEGAL_REENTRANT_CALL";
              break;
            case 108:
              double result = "OI_STATUS_INITIALIZATION_FAILED";
              break;
            case 109:
              double result = "OI_STATUS_INITIALIZATION_PENDING";
              break;
            case 110:
              double result = "OI_STATUS_NO_SCO_SUPPORT";
              break;
            case 111:
              double result = "OI_STATUS_OUT_OF_STATIC_MEMORY";
              break;
            case 112:
              double result = "OI_TIMEOUT";
              break;
            case 113:
              double result = "OI_OS_ERROR";
              break;
            case 114:
              double result = "OI_FAIL";
              break;
            case 115:
              double result = "OI_STRING_FORMAT_ERROR";
              break;
            case 116:
              double result = "OI_STATUS_PENDING";
              break;
            case 117:
              double result = "OI_STATUS_INVALID_COMMAND";
              break;
            case 118:
              double result = "OI_BUSY_FAIL";
              break;
            case 119:
              double result = "OI_STATUS_ALREADY_REGISTERED";
              break;
            case 120:
              double result = "OI_STATUS_NOT_FOUND";
              break;
            case 121:
              double result = "OI_STATUS_NOT_REGISTERED";
              break;
            case 122:
              double result = "OI_STATUS_NOT_CONNECTED";
              break;
            case 123:
              double result = "OI_CALLBACK_FUNCTION_REQUIRED";
              break;
            case 124:
              double result = "OI_STATUS_MBUF_OVERFLOW";
              break;
            case 125:
              double result = "OI_STATUS_MBUF_UNDERFLOW";
              break;
            case 126:
              double result = "OI_STATUS_CONNECTION_EXISTS";
              break;
            case 127:
              double result = "OI_STATUS_NOT_CONFIGURED";
              break;
            case 128:
              double result = "OI_LOWER_STACK_ERROR";
              break;
            case 129:
              double result = "OI_STATUS_RESET_IN_PROGRESS";
              break;
            case 130:
              double result = "OI_STATUS_ACCESS_DENIED";
              break;
            case 131:
              double result = "OI_STATUS_DATA_ERROR";
              break;
            case 132:
              double result = "OI_STATUS_INVALID_ROLE";
              break;
            case 133:
              double result = "OI_STATUS_ALREADY_CONNECTED";
              break;
            case 134:
              double result = "OI_STATUS_PARSE_ERROR";
              break;
            case 135:
              double result = "OI_STATUS_END_OF_FILE";
              break;
            case 136:
              double result = "OI_STATUS_READ_ERROR";
              break;
            case 137:
              double result = "OI_STATUS_WRITE_ERROR";
              break;
            case 138:
              double result = "OI_STATUS_NEGOTIATION_FAILURE";
              break;
            case 139:
              double result = "OI_STATUS_READ_IN_PROGRESS";
              break;
            case 140:
              double result = "OI_STATUS_ALREADY_INITIALIZED";
              break;
            case 141:
              double result = "OI_STATUS_STILL_CONNECTED";
              break;
            case 142:
              double result = "OI_STATUS_MTU_EXCEEDED";
              break;
            case 143:
              double result = "OI_STATUS_LINK_TERMINATED";
              break;
            case 144:
              double result = "OI_STATUS_PIN_CODE_TOO_LONG";
              break;
            case 145:
              double result = "OI_STATUS_STILL_REGISTERED";
              break;
            case 146:
              double result = "OI_STATUS_SPEC_VIOLATION";
              break;
            case 147:
              double result = "OI_STATUS_LE_NOT_SUPPORTED";
              break;
            case 148:
              double result = "OI_STATUS_MUTEX_DESTROY_FAILED";
              break;
            case 149:
              double result = "OI_STATUS_INVALID_LE_CONNECTION";
              break;
            case 150:
              double result = "OI_STACKWRAPPER_TIMEOUT";
              break;
            case 151:
              double result = "OI_CONDITIONAL_TIMEOUT";
              break;
            case 152:
              double result = "OI_STATUS_UNSUPPORTED";
              break;
            case 153:
              double result = "OI_STATUS_WATCH_TS_REMOTE_UNSUPPORTED";
              break;
            case 154:
              double result = "OI_STATUS_CCECB_FAIL";
              break;
            case 155:
              double result = "OI_STATUS_INVALID_LE_PERIODIC_SYNC";
              break;
            case 156:
              return 0;
            case 157:
              double result = "OI_STATUS_LE_DUPLICATE_CONNECTIONS";
              break;
            case 158:
              double result = "OI_STATUS_DUPLICATE_BD_ADDR";
              break;
            case 159:
              double result = "OI_STATUS_FAST_LE_CONNECTION_FAILED";
              break;
            case 160:
              double result = "OI_STATUS_OUTGOING_CONNECTION_DENIED";
              break;
            case 161:
              double result = "OI_STATUS_INCOMPLETE_DATA";
              break;
            case 162:
              double result = "OI_STATUS_INVALID_LENGTH";
              break;
            default:
              if (a1) {
                return 0;
              }
              double result = "OI_OK";
              break;
          }
          break;
      }
    }
    return result;
  }
  if (a1 <= 3569)
  {
    if (a1 > 2100)
    {
      if (a1 > 3100)
      {
        if (a1 > 3389)
        {
          switch(a1)
          {
            case 3450:
              double result = "BT_MAP_CONNECT_MNS_MAX_CONN";
              break;
            case 3451:
              double result = "BT_MAP_SERVER_CONN_IND_MAX_CLIENT";
              break;
            case 3452:
              double result = "BT_MAP_SERVER_GET_IND_MAX_CLIENT";
              break;
            case 3453:
              double result = "BT_MAP_SERVER_PUT_IND_MAX_CLIENT";
              break;
            case 3454:
              double result = "BT_MAP_SERVER_DISC_MAX_CLIENT";
              break;
            case 3455:
              double result = "BT_MAP_SERVER_ACCEPT_MAX_CLIENT";
              break;
            case 3456:
              double result = "BT_MAP_SEND_MAX_CLIENT";
              break;
            case 3457:
              double result = "BT_MAP_GETRESPONSE_MAX_CLIENT";
              break;
            case 3458:
              double result = "BT_MAP_SEND_MSG_RESPONSE_ERROR";
              break;
            case 3459:
              double result = "BT_MAP_SEND_MSG_MAX_CLIENT";
              break;
            case 3460:
              double result = "BT_MAP_GET_FOLDER_MAX_CLIENT";
              break;
            case 3461:
            case 3462:
            case 3463:
            case 3464:
            case 3465:
            case 3466:
            case 3467:
            case 3468:
            case 3469:
              return 0;
            case 3470:
              double result = "BT_NETWORK_STATUS_DEFAULT";
              break;
            case 3471:
              double result = "BT_NETWORK_IF_CREATE_ERROR";
              break;
            case 3472:
              double result = "BT_NETWORK_ADD_HOST_ERROR";
              break;
            case 3473:
              double result = "BT_NETWORK_MAX_CONN_ERROR";
              break;
            case 3474:
              double result = "BT_NETWORK_IF_WRITE_ERROR";
              break;
            default:
              switch(a1)
              {
                case 3390:
                  double result = "OI_BIPSRV_REJECT";
                  break;
                case 3391:
                case 3392:
                case 3393:
                case 3394:
                case 3395:
                case 3396:
                case 3397:
                case 3398:
                case 3399:
                  return 0;
                case 3400:
                  double result = "OI_PAN_CONSUMER_IF_WRITE_ERROR";
                  break;
                case 3401:
                  double result = "OI_PAN_STATUS_DEFAULT";
                  break;
                case 3402:
                  double result = "OI_PAN_INVALID_NET_IFC";
                  break;
                case 3403:
                  double result = "OI_PAN_USER_IFCREATE_ERROR";
                  break;
                case 3404:
                  double result = "OI_PAN_USER_IFWRITE_ERROR";
                  break;
                default:
                  switch(a1)
                  {
                    case 3550:
                      double result = "BT_MAGIC_PAIRING_IN_PROGRESS";
                      break;
                    case 3551:
                      double result = "BT_MAGIC_PAIRING_NO_TABLE_FOUND";
                      break;
                    case 3552:
                      double result = "BT_MAGIC_PAIRING_NO_HINT";
                      break;
                    case 3553:
                      double result = "BT_MAGIC_PAIRING_NOT_INPROGRESS";
                      break;
                    default:
                      return 0;
                  }
                  break;
              }
              break;
          }
        }
        else
        {
          if (a1 <= 3200)
          {
            switch(a1)
            {
              case 3101:
                return "OI_AADP_BAD_ENDPOINT";
              case 3102:
                return "OI_AADP_BAD_STATE";
              case 3200:
                return "OI_UNICODE_INVALID_SOURCE";
            }
            return 0;
          }
          switch(a1)
          {
            case 3300:
              double result = "OI_AVRCP_TOO_MANY_CONNECTIONS";
              break;
            case 3301:
              double result = "OI_AVRCP_NOT_IMPLEMENTED";
              break;
            case 3302:
              double result = "OI_AVRCP_REJECTED";
              break;
            case 3303:
              double result = "OI_AVRCP_INVALID_RESPONSE";
              break;
            case 3304:
              double result = "OI_AVRCP_RESPONSE_PACKET_OVERFLOW";
              break;
            case 3305:
              double result = "OI_AVRCP_RESPONSE_INVALID_PDU";
              break;
            case 3306:
              double result = "OI_AVRCP_RESPONSE_INVALID_PARAMETER";
              break;
            case 3307:
              double result = "OI_AVRCP_RESPONSE_PARAMETER_NOT_FOUND";
              break;
            case 3308:
              double result = "OI_AVRCP_RESPONSE_INTERNAL_ERROR";
              break;
            case 3309:
              double result = "OI_AVRCP_NO_REGISTERED_HANDLER_ERROR";
              break;
            case 3310:
              double result = "OI_AVRCP_RECVIND_INVALID_PID_ERROR";
              break;
            case 3311:
              double result = "OI_AVRCP_B_RECVIND_INVALID_PID_ERROR";
              break;
            case 3312:
              double result = "OI_AVRCP_TIMEOUT";
              break;
            default:
              if (a1 == 3201)
              {
                double result = "OI_UNICODE_SOURCE_EXHAUSTED";
              }
              else
              {
                if (a1 != 3202) {
                  return 0;
                }
                double result = "OI_UNICODE_DESTINATION_EXHAUSTED";
              }
              break;
          }
        }
      }
      else if (a1 > 2600)
      {
        if (a1 > 2800)
        {
          if (a1 > 2902)
          {
            switch(a1)
            {
              case 3001:
                double result = "OI_PBAP_REPOSITORY_NOT_SET";
                break;
              case 3002:
                double result = "OI_PBAP_PHONEBOOK_NOT_SET";
                break;
              case 3003:
                double result = "OI_PBAP_SET_PATH_DONE_ERROR";
                break;
              case 3004:
                double result = "OI_PBAP_SERVER_SIZE_ERROR";
                break;
              case 3005:
                double result = "OI_PBAP_CLIENT_ADDR_ERROR";
                break;
              default:
                if (a1 != 2903) {
                  return 0;
                }
                double result = "OI_AVDTP_INVALID_STREAM_HANDLE";
                break;
            }
          }
          else
          {
            switch(a1)
            {
              case 2801:
                double result = "OI_BLST_CHARACTER_TIMEOUT";
                break;
              case 2802:
                double result = "OI_BLST_ACKNOWLDGE_TIMEOUT";
                break;
              case 2803:
                double result = "OI_BLST_TX_NOT_READY";
                break;
              case 2804:
                double result = "OI_BLST_TX_BUSY";
                break;
              default:
                if (a1 == 2901)
                {
                  double result = "OI_AVDTP_CONNECTION_SEQ_ERROR";
                }
                else
                {
                  if (a1 != 2902) {
                    return 0;
                  }
                  double result = "OI_AVDTP_OUT_OF_RESOURCES";
                }
                break;
            }
          }
        }
        else
        {
          switch(a1)
          {
            case 2701:
              double result = "OI_AT_ERROR";
              break;
            case 2702:
              double result = "OI_AT_NO_CARRIER";
              break;
            case 2703:
              double result = "OI_AT_BUSY";
              break;
            case 2704:
              double result = "OI_AT_NO_ANSWER";
              break;
            case 2705:
              double result = "OI_AT_DELAYED";
              break;
            case 2706:
              double result = "OI_AT_BLACKLISTED";
              break;
            case 2707:
              double result = "OI_AT_CME_ERROR";
              break;
            case 2708:
              double result = "OI_AT_CMS_ERROR";
              break;
            default:
              switch(a1)
              {
                case 2601:
                  double result = "OI_HID_HOST_SERVICE_NOT_STARTED";
                  break;
                case 2602:
                  double result = "OI_HID_DEVICE_SERVICE_NOT_STARTED";
                  break;
                case 2603:
                  double result = "OI_HID_CONTROL_DISC_IND";
                  break;
                case 2604:
                  double result = "OI_HID_TIMEOUT";
                  break;
                default:
                  return 0;
              }
              break;
          }
        }
      }
      else if (a1 > 2300)
      {
        switch(a1)
        {
          case 2401:
            double result = "OI_FIFOQ_QUEUE_NOT_ALIGNED";
            break;
          case 2402:
            double result = "OI_FIFOQ_INVALID_Q";
            break;
          case 2403:
            double result = "OI_FIFOQ_BUF_TOO_LARGE";
            break;
          case 2404:
            double result = "OI_FIFOQ_FULL";
            break;
          case 2405:
            double result = "OI_FIFOQ_NOT_ALLOCATED";
            break;
          case 2406:
            double result = "OI_FIFOQ_INVALID_DATA_PTR";
            break;
          default:
            return 0;
        }
      }
      else
      {
        switch(a1)
        {
          case 2201:
            double result = "OI_PAN_ROLE_ALREADY_REGISTERED";
            break;
          case 2202:
            double result = "OI_PAN_ROLE_NOT_ALLOWED";
            break;
          case 2203:
            double result = "OI_PAN_INCOMPATIBLE_ROLES";
            break;
          case 2204:
            double result = "OI_PAN_INVALID_ROLE";
            break;
          case 2205:
            double result = "OI_PAN_CONNECTION_IN_PROGRESS";
            break;
          case 2206:
            double result = "OI_PAN_USER_ALREADY_CONNECTED";
            break;
          case 2207:
            double result = "OI_PAN_DEVICE_CONNECTED";
            break;
          default:
            switch(a1)
            {
              case 2101:
                double result = "OI_NETIFC_UP_FAILED";
                break;
              case 2102:
                double result = "OI_NETIFC_COULD_NOT_CREATE_THREAD";
                break;
              case 2103:
                double result = "OI_NETIFC_INITIALIZATION_FAILED";
                break;
              case 2104:
                double result = "OI_NETIFC_INTERFACE_ALREADY_UP";
                break;
              case 2105:
                double result = "OI_NETIFC_INTERFACE_NOT_UP";
                break;
              case 2106:
                double result = "OI_NETIFC_PACKET_TOO_BIG";
                break;
              default:
                return 0;
            }
            break;
        }
      }
    }
    else if (a1 > 1900)
    {
      if (a1 <= 2000)
      {
        switch(a1)
        {
          case 1901:
            return "OI_HEADSET_SERVICE_NOT_STARTED";
          case 1902:
            return "OI_HEADSET_AG_SERVICE_NOT_STARTED";
          case 1903:
            return "OI_HEADSET_COMMAND_IN_PROGRESS";
        }
        return 0;
      }
      switch(a1)
      {
        case 2001:
          double result = "OI_BNEP_INVALID_MTU";
          break;
        case 2002:
          double result = "OI_BNEP_SETUP_TIMEOUT";
          break;
        case 2003:
          double result = "OI_BNEP_SERVICE_NOT_REGISTERED";
          break;
        case 2004:
          double result = "OI_BNEP_INVALID_HANDLE";
          break;
        case 2005:
          double result = "OI_BNEP_RESPONSE_TIMEOUT";
          break;
        case 2006:
          double result = "OI_BNEP_INVALID_CONNECTION";
          break;
        case 2007:
          double result = "OI_BNEP_INVALID_FILTER";
          break;
        case 2008:
          double result = "OI_BNEP_CONNECTION_EXISTS";
          break;
        case 2009:
          double result = "OI_BNEP_NOT_INITIALIZED";
          break;
        case 2010:
          double result = "OI_BNEP_CONNECT_BASE";
          break;
        case 2011:
          double result = "OI_BNEP_CONNECT_FAILED_INVALID_DEST_UUID";
          break;
        case 2012:
          double result = "OI_BNEP_CONNECT_FAILED_INVALID_SOURCE_UUID";
          break;
        case 2013:
          double result = "OI_BNEP_CONNECT_FAILED_INVALID_UUID_SIZE";
          break;
        case 2014:
          double result = "OI_BNEP_CONNECT_FAILED_NOT_ALLOWED";
          break;
        case 2020:
          double result = "OI_BNEP_FILTER_NET_BASE";
          break;
        case 2021:
          double result = "OI_BNEP_FILTER_NET_UNSUPPORTED_REQUEST";
          break;
        case 2022:
          double result = "OI_BNEP_FILTER_NET_FAILED_INVALID_PROTOCOL_TYPE";
          break;
        case 2023:
          double result = "OI_BNEP_FILTER_NET_FAILED_MAX_LIMIT_REACHED";
          break;
        case 2024:
          double result = "OI_BNEP_FILTER_NET_FAILED_SECURITY";
          break;
        case 2030:
          double result = "OI_BNEP_FILTER_MULTI_BASE";
          break;
        case 2031:
          double result = "OI_BNEP_FILTER_MULTI_UNSUPPORTED_REQUEST";
          break;
        case 2032:
          double result = "OI_BNEP_FILTER_MULTI_FAILED_INVALID_ADDRESS";
          break;
        case 2033:
          double result = "OI_BNEP_FILTER_MULTI_FAILED_MAX_LIMIT_REACHED";
          break;
        case 2034:
          double result = "OI_BNEP_FILTER_MULTI_FAILED_SECURITY";
          break;
        case 2040:
          double result = "OI_BNEP_LOCAL_DEVICE_MUST_BE_CENTRAL";
          break;
        case 2041:
          double result = "OI_BNEP_PACKET_FILTERED_OUT";
          break;
        case 2042:
          double result = "OI_BNEP_NO_PACKET_FOUND";
          break;
        case 2043:
          double result = "OI_BNEP_TIMEOUT";
          break;
        default:
          return 0;
      }
    }
    else if (a1 <= 1700)
    {
      switch(a1)
      {
        case 1602:
          double result = "OI_TCS_INVALID_ELEMENT_TYPE";
          break;
        case 1603:
          double result = "OI_TCS_INVALID_PACKET";
          break;
        case 1604:
          double result = "OI_TCS_CALL_IN_PROGRESS";
          break;
        case 1605:
          double result = "OI_TCS_NO_CALL_IN_PROGRESS";
          break;
        default:
          if (a1 == 1500)
          {
            double result = "OI_DEVMGR_POLICY_ACL_DISCONNECTED";
          }
          else
          {
            if (a1 != 1501) {
              return 0;
            }
            double result = "OI_DEVMGR_POLICY_ENFORCEMENT_TIMEOUT";
          }
          break;
      }
    }
    else
    {
      switch(a1)
      {
        case 1701:
          double result = "OI_OBEX_CONTINUE";
          break;
        case 1702:
          double result = "OI_OBEX_COMMAND_ERROR";
          break;
        case 1703:
          double result = "OI_OBEX_CONNECTION_TIMEOUT";
          break;
        case 1704:
          double result = "OI_OBEX_CONNECT_FAILED";
          break;
        case 1705:
          double result = "OI_OBEX_DISCONNECT_FAILED";
          break;
        case 1706:
          double result = "OI_OBEX_ERROR";
          break;
        case 1707:
          double result = "OI_OBEX_INCOMPLETE_PACKET";
          break;
        case 1708:
          double result = "OI_OBEX_LENGTH_REQUIRED";
          break;
        case 1709:
          double result = "OI_OBEX_NOT_CONNECTED";
          break;
        case 1710:
          double result = "OI_OBEX_NO_MORE_CONNECTIONS";
          break;
        case 1711:
          double result = "OI_OBEX_OPERATION_IN_PROGRESS";
          break;
        case 1712:
          double result = "OI_OBEX_PUT_RESPONSE_ERROR";
          break;
        case 1713:
          double result = "OI_OBEX_GET_RESPONSE_ERROR";
          break;
        case 1714:
          double result = "OI_OBEX_REQUIRED_HEADER_NOT_FOUND";
          break;
        case 1715:
          double result = "OI_OBEX_SERVICE_UNAVAILABLE";
          break;
        case 1716:
          double result = "OI_OBEX_TOO_MANY_HEADER_BYTES";
          break;
        case 1717:
          double result = "OI_OBEX_UNKNOWN_COMMAND";
          break;
        case 1718:
          double result = "OI_OBEX_UNSUPPORTED_VERSION";
          break;
        case 1719:
          double result = "OI_OBEX_CLIENT_ABORTED_COMMAND";
          break;
        case 1720:
          double result = "OI_OBEX_BAD_PACKET";
          break;
        case 1721:
          double result = "OI_OBEX_BAD_REQUEST";
          break;
        case 1723:
          double result = "OI_OBEX_OBJECT_OVERFLOW";
          break;
        case 1724:
          double result = "OI_OBEX_NOT_FOUND";
          break;
        case 1735:
          double result = "OI_OBEX_ACCESS_DENIED";
          break;
        case 1736:
          double result = "OI_OBEX_VALUE_NOT_ACCEPTABLE";
          break;
        case 1737:
          double result = "OI_OBEX_PACKET_OVERFLOW";
          break;
        case 1738:
          double result = "OI_OBEX_NO_SUCH_FOLDER";
          break;
        case 1739:
          double result = "OI_OBEX_NAME_REQUIRED";
          break;
        case 1740:
          double result = "OI_OBEX_PASSWORD_TOO_LONG";
          break;
        case 1741:
          double result = "OI_OBEX_PRECONDITION_FAILED";
          break;
        case 1742:
          double result = "OI_OBEX_UNAUTHORIZED";
          break;
        case 1743:
          double result = "OI_OBEX_NOT_IMPLEMENTED";
          break;
        case 1744:
          double result = "OI_OBEX_INVALID_AUTH_DIGEST";
          break;
        case 1745:
          double result = "OI_OBEX_INVALID_OPERATION";
          break;
        case 1746:
          double result = "OI_OBEX_DATABASE_FULL";
          break;
        case 1747:
          double result = "OI_OBEX_DATABASE_LOCKED";
          break;
        case 1748:
          double result = "OI_OBEX_INTERNAL_SERVER_ERROR";
          break;
        case 1749:
          double result = "OI_OBEX_UNSUPPORTED_MEDIA_TYPE";
          break;
        case 1750:
          double result = "OI_OBEX_PARTIAL_CONTENT";
          break;
        case 1751:
          double result = "OI_OBEX_METHOD_NOT_ALLOWED";
          break;
        case 1752:
          double result = "OI_OBEXSRV_INCOMPLETE_GET";
          break;
        case 1753:
          double result = "OI_OBEX_FOLDER_BROWSING_NOT_ALLOWED";
          break;
        case 1754:
          double result = "OI_OBEX_SERVER_FORCED_DISCONNECT";
          break;
        case 1755:
          double result = "OI_OBEX_OFS_ERROR";
          break;
        case 1756:
          double result = "OI_OBEX_FILEOP_ERROR";
          break;
        case 1757:
          double result = "OI_OBEX_USERID_TOO_LONG";
          break;
        case 1758:
          double result = "OI_OBEX_APPEND_PARSER_ERROR";
          break;
        case 1759:
          double result = "OI_OBEXSRV_REJECT";
          break;
        case 1801:
          double result = "OI_HANDSFREE_EVENT_REPORTING_DISABLED";
          break;
        case 1802:
          double result = "OI_HANDSFREE_NOT_CONNECTED";
          break;
        case 1803:
          double result = "OI_HANDSFREE_SERVICE_NOT_STARTED";
          break;
        case 1804:
          double result = "OI_HANDSFREE_AG_SERVICE_NOT_STARTED";
          break;
        case 1805:
          double result = "OI_HANDSFREE_COMMAND_IN_PROGRESS";
          break;
        case 1806:
          double result = "OI_HANDSFREE_AUDIO_ALREADY_CONNECTED";
          break;
        case 1807:
          double result = "OI_HANDSFREE_AUDIO_NOT_CONNECTED";
          break;
        case 1808:
          double result = "OI_HANDSFREE_FEATURE_NOT_SUPPORTED";
          break;
        case 1809:
          double result = "OI_HANDSFREE_CODEC_SELECTION_TIMEOUT";
          break;
        case 1810:
          double result = "OI_HANDSFREE_CODEC_SELECTION_FAILED";
          break;
        case 1811:
          double result = "OI_HANDSFREE_PARAMS_EXCEEDED";
          break;
        case 1812:
          double result = "OI_HANDSFREE_CODEC_NOT_SUPPORTED";
          break;
        case 1813:
          double result = "OI_HANDSFREE_INVALID_CODEC";
          break;
        case 1814:
          double result = "OI_HANDSFREE_AG_TIMEOUT";
          break;
        case 1815:
          double result = "OI_HANDSFREE_DISC_MAX_HFP_DEVICES";
          break;
        case 1816:
          double result = "OI_HANDSFREE_LOCAL_DISC_CTRL_MISMATCH";
          break;
        case 1817:
          double result = "OI_HANDSFREE_LOCAL_DISC_SCO_REG_FAIL";
          break;
        case 1818:
          double result = "OI_LOCAL_DEVICE_DISC";
          break;
        default:
          return 0;
      }
    }
  }
  else
  {
    if (a1 > 4299)
    {
      if (a1 <= 4999)
      {
        switch(a1)
        {
          case 4800:
            double result = "OI_SMP_ERROR_FAIL";
            break;
          case 4801:
            double result = "OI_SMP_ERROR_ALREADY_ENCRYPTED";
            break;
          case 4802:
            double result = "OI_SMP_ERROR_NOT_ENCRYPTED";
            break;
          case 4803:
            double result = "OI_SMP_ERROR_NO_KEY";
            break;
          case 4804:
            double result = "OI_SMP_ERROR_IN_PROGRESS";
            break;
          case 4805:
            double result = "OI_SMP_ERROR_CONFIRM_VALUE_FAILED";
            break;
          case 4806:
            double result = "OI_SMP_ERROR_NOT_IN_PAIRING_MODE";
            break;
          case 4807:
            double result = "OI_SMP_ERROR_TIMEOUT";
            break;
          case 4808:
            double result = "OI_SMP_ERROR_ALREADY_PAIRED";
            break;
          case 4809:
            double result = "OI_SMP_ERROR_PASSKEY_ENTRY_FAILED";
            break;
          case 4810:
            double result = "OI_SMP_ERROR_OOB_NOT_AVAILABLE";
            break;
          case 4811:
            double result = "OI_SMP_ERROR_AUTH_REQUIREMENT";
            break;
          case 4812:
            double result = "OI_SMP_ERROR_PAIRING_NOT_SUPPORTED";
            break;
          case 4813:
            double result = "OI_SMP_ERROR_ENCYPRTION_KEY_SIZE";
            break;
          case 4814:
            double result = "OI_SMP_ERROR_COMMAND_NOT_SUPPORTED";
            break;
          case 4815:
            double result = "OI_SMP_ERROR_UNSPECIFIED_REASON";
            break;
          case 4816:
            double result = "OI_SMP_ERROR_REPEATED_ATTEMPS";
            break;
          case 4817:
            double result = "OI_SMP_ERROR_INVALID_PARAMETERS";
            break;
          case 4818:
            double result = "OI_SMP_ERROR_DHKEY_CHECK_FAILED";
            break;
          case 4819:
            double result = "OI_SMP_ERROR_NUM_COMPARISON_FAILED";
            break;
          case 4820:
            double result = "OI_SMP_ERROR_INVALID_HANDLE";
            break;
          case 4821:
            double result = "OI_SMP_ERROR_NOT_CENTRAL";
            break;
          case 4822:
            double result = "OI_SMP_ERROR_NOT_PERIPHERAL";
            break;
          case 4823:
            double result = "OI_SMP_ERROR_INVALID_PAIR_STATE";
            break;
          case 4824:
            double result = "OI_SMP_ERROR_NO_CALLBACK";
            break;
          case 4825:
            double result = "OI_SMP_ERROR_CRYPTO_FAILED";
            break;
          case 4826:
            double result = "OI_SMP_ERROR_NO_ROOT_KEYS";
            break;
          case 4827:
            double result = "OI_SMP_ERROR_TIMEOUT_USER_RSP";
            break;
          case 4828:
            double result = "OI_SMP_ERROR_CRYPTO_IRK";
            break;
          case 4829:
            double result = "OI_SMP_ERROR_CRYPTO";
            break;
          case 4830:
            double result = "OI_SMP_ERROR_BREDR_PAIRING_IN_PROGRESS";
            break;
          case 4831:
            double result = "OI_SMP_ERROR_CTKD_NA";
            break;
          case 4832:
            double result = "LE_SECURITY_ERROR_COMPROMISED_DEVICE";
            break;
          case 4833:
            double result = "LE_SECURITY_ERROR_OTHER_SIDE_UNPAIRED";
            break;
          case 4834:
            double result = "LE_SECURITY_ERROR_ENCRYPTION_TIMEOUT";
            break;
          case 4835:
            double result = "LE_SECURITY_ERROR_TOO_MANY_PAIRED_DEVICES";
            break;
          case 4836:
            double result = "LE_SECURITY_ERROR_NEW_LOCAL_DEVICE_IDENTIFIER";
            break;
          case 4837:
            double result = "LE_SECURITY_ERROR_PAIRING_NOT_ALLOWED";
            break;
          default:
            switch(a1)
            {
              case 4300:
                double result = "BT_ATT_STATUS_SUCCESS";
                break;
              case 4301:
                double result = "BT_ATT_ERROR_INVALID_HANDLE";
                break;
              case 4302:
                double result = "BT_ATT_ERROR_READ_NOT_PERMITTED";
                break;
              case 4303:
                double result = "BT_ATT_ERROR_WRITE_NOT_PERMITTED";
                break;
              case 4304:
                double result = "BT_ATT_ERROR_INVALID_PDU";
                break;
              case 4305:
                double result = "BT_ATT_ERROR_INSUFFICIENT_AUTHENTICATION";
                break;
              case 4306:
                double result = "BT_ATT_ERROR_REQUEST_NOT_SUPPORTED";
                break;
              case 4307:
                double result = "BT_ATT_ERROR_INVALID_OFFSET";
                break;
              case 4308:
                double result = "BT_ATT_ERROR_INSUFFICIENT_AUTHORIZATION";
                break;
              case 4309:
                double result = "BT_ATT_ERROR_PREPARE_QUEUE_FULL";
                break;
              case 4310:
                double result = "BT_ATT_ERROR_ATTRIBUTE_NOT_FOUND";
                break;
              case 4311:
                double result = "BT_ATT_ERROR_ATTRIBUTE_NOT_LONG";
                break;
              case 4312:
                double result = "BT_ATT_ERROR_INSUFFICIENT_ENCRYPTION_KEY_SIZE";
                break;
              case 4313:
                double result = "BT_ATT_ERROR_INVALID_ATTRIBUTE_VALUE_LENGTH";
                break;
              case 4314:
                double result = "BT_ATT_ERROR_UNLIKELY_ERROR";
                break;
              case 4315:
                double result = "BT_ATT_ERROR_INSUFFICIENT_ENCRYPTION";
                break;
              case 4316:
                double result = "BT_ATT_ERROR_UNSUPPORTED_GROUP_TYPEN";
                break;
              case 4317:
                double result = "BT_ATT_ERROR_INSUFFICIENT_RESOURCES";
                break;
              default:
                switch(a1)
                {
                  case 4540:
                    double result = "BT_ATT_ERROR_RESPONSE_PENDING";
                    break;
                  case 4541:
                    double result = "BT_ATT_ERROR_RESPONSE_TIMEOUT_REACHED";
                    break;
                  case 4542:
                    double result = "BT_ATT_ERROR_APPLICATION_UNAVAILABLE";
                    break;
                  case 4543:
                    double result = "BT_ATT_ERROR_RESPONSE_FULL";
                    break;
                  case 4544:
                    double result = "BT_ATT_ERROR_PREPARE_WRITE_INVALID";
                    break;
                  case 4545:
                    double result = "BT_ATT_ERROR_WRITE_REJECTED";
                    break;
                  default:
                    return 0;
                }
                break;
            }
            break;
        }
        return result;
      }
      if (a1 <= 5099)
      {
        switch(a1)
        {
          case 5000:
            double result = "BT_TS_TIMEOUT_UPGRADE_ERR";
            break;
          case 5001:
            double result = "BT_TS_TIMEOUT_UPGRADING_ERR";
            break;
          case 5002:
            double result = "BT_TS_TIMEOUT_UPGRADE_ENCRYPT_ERR";
            break;
          case 5003:
            double result = "BT_TS_TIMEOUT_UPGRADE_FINAL_ERR";
            break;
          case 5004:
            double result = "BT_TS_TIMEOUT_DOWNGRADE_STALL_ERR";
            break;
          case 5005:
            double result = "BT_TS_TIMEOUT_DOWNGRADE_ERR";
            break;
          case 5006:
            double result = "BT_TS_L2CAP_ERR";
            break;
          case 5007:
            double result = "BT_TS_NO_ALTERNATE_TRANSPORT";
            break;
          case 5008:
            double result = "BT_TS_FLUSH_NOT_SUPPORTED_ON_LE";
            break;
          case 5009:
            double result = "BT_TS_LE_DISCONNECTED";
            break;
          case 5010:
            double result = "BT_TS_UPGRADE_NOT_TRACKED_CENTRAL";
            break;
          case 5011:
            double result = "BT_TS_UPGRADE_NOT_TRACKED_PERIPHERAL";
            break;
          case 5012:
            double result = "BT_TS_UPGRADE_POLICY_ENF_FAILED";
            break;
          case 5013:
            double result = "BT_TS_STATUS_DEFAULT";
            break;
          case 5014:
            double result = "BT_TS_TIMEOUT";
            break;
          case 5015:
            double result = "BT_TS_SWITCH_HW_ERROR";
            break;
          case 5016:
            double result = "BT_TS_ERROR_INVALID_LMHANDLE";
            break;
          case 5017:
            double result = "BT_TS_ERROR_LL_COLLISION_DETECTED_AFH";
            break;
          case 5018:
            double result = "BT_TS_ERROR_LL_COLLISION_DETECTED_CON_UPDATE";
            break;
          case 5019:
            double result = "BT_TS_ERROR_LL_COLLISION_REJECTED_AFH";
            break;
          case 5020:
            double result = "BT_TS_ERROR_LL_COLLISION_REJECTED_CON_UPDATE";
            break;
          case 5021:
          case 5022:
          case 5023:
          case 5024:
          case 5025:
          case 5026:
          case 5027:
          case 5028:
          case 5029:
          case 5030:
          case 5031:
          case 5032:
          case 5033:
          case 5034:
          case 5035:
          case 5036:
          case 5037:
          case 5038:
          case 5039:
          case 5040:
          case 5041:
          case 5042:
          case 5043:
          case 5044:
          case 5045:
          case 5046:
          case 5047:
          case 5048:
          case 5049:
            return 0;
          case 5050:
            double result = "BT_TS_STATUS_SUCCESS";
            break;
          case 5051:
            double result = "BT_TS_STATUS_ERROR_INTERNAL";
            break;
          case 5052:
            double result = "BT_TS_STATUS_ERROR_ROLE";
            break;
          case 5053:
            double result = "BT_TS_STATUS_ERROR_PDU";
            break;
          case 5054:
            double result = "BT_TS_STATUS_ERROR_TRANSPORT";
            break;
          case 5055:
            double result = "BT_TS_STATUS_ERROR_STATE";
            break;
          case 5056:
            double result = "BT_TS_STATUS_ERROR_ENCRYPTION";
            break;
          case 5057:
            double result = "BT_TS_STATUS_ERROR_CONTROLLER";
            break;
          default:
            if (a1 != 5090) {
              return 0;
            }
            double result = "BT_TR_PARSER_PRELUDE_INCOMPLETE";
            break;
        }
        return result;
      }
      if (a1 > 5402)
      {
        switch(a1)
        {
          case 9500:
            double result = "BD_HCI_STALL_ERROR";
            break;
          case 9501:
            double result = "BD_GATT_UPDATE_GAP_NAME_ERROR";
            break;
          case 9502:
            double result = "BD_TEST_ERROR";
            break;
          case 9503:
            double result = "BD_PROFILE_FAILED_TO_STOP_ERROR";
            break;
          case 9504:
            double result = "BD_PROFILE_FAILED_TO_DEREGISTER_ERROR";
            break;
          case 9505:
            double result = "BD_PROFILE_FAILED_TO_CLEANUP_ERROR";
            break;
          default:
            if (a1 == 5403)
            {
              double result = "OI_MAX_BM3_STATUS_VAL";
            }
            else
            {
              if (a1 != 0xFFFF) {
                return 0;
              }
              double result = "OI_STATUS_NONE";
            }
            break;
        }
        return result;
      }
      if (a1 <= 5101)
      {
        if (a1 == 5100) {
          return "BT_CL_SEND_PDU_INVALID_HANDLE";
        }
        else {
          return "BT_CL_PEER_REMOVED_SERVICE";
        }
      }
      if (a1 == 5102) {
        return "BT_CL_SERVICE_UNREGISTERED_LOCALLY";
      }
      if (a1 == 5300) {
        return "BT_LEA_ERROR_STALLED_CONNECTION";
      }
      return 0;
    }
    if (a1 <= 3999)
    {
      if (a1 <= 3601)
      {
        switch(a1)
        {
          case 3570:
            return "BT_AAP_DISCONNECT";
          case 3600:
            return "BT_VSC_SEND_INPROGRESS_ERROR";
          case 3601:
            return "BT_VSC_NOT_IMPLEMENTED_ERROR";
        }
        return 0;
      }
      switch(a1)
      {
        case 3700:
          double result = "BD_DEBUG_DUMP";
          break;
        case 3701:
          double result = "BT_ASSERT_FAILURE";
          break;
        case 3702:
          return 0;
        case 3703:
          double result = "BT_CONTROLLER_CORE_DUMP";
          break;
        case 3704:
          double result = "BT_CONTROLLER_CORE_DUMP_INPROGRESS";
          break;
        case 3705:
          double result = "BD_ABORT_FAILURE";
          break;
        case 3706:
          double result = "BD_COREDUMP_IDLE_TIMEOUT";
          break;
        case 3707:
          double result = "BD_COREDUMP_TOO_LONG";
          break;
        case 3708:
          double result = "BT_MAC_IN_DARK_SLEEP_MODE";
          break;
        case 3709:
          double result = "BT_HCI_CMD_PENDING_BEFORE_DARK_SLEEP";
          break;
        case 3710:
          double result = "BT_TRANS_NOT_READY_BEFORE_DARK_WAKE";
          break;
        case 3711:
          double result = "BT_MAC_DARK_WAKE_TAKE_TOO_LONG";
          break;
        case 3712:
          double result = "BT_FAILED_TO_START_MAC_USER";
          break;
        case 3713:
          double result = "BT_FAILED_TO_CREATE_PCIE_ERROR_LISTENER";
          break;
        case 3714:
          double result = "BT_FAILED_TO_CREATE_PCIE_TIMESYNC_LISTENER";
          break;
        case 3715:
          double result = "BT_STACK_STOP_ERROR";
          break;
        case 3716:
          double result = "BT_MISSED_HEART_BEAT_NOTIFICATION";
          break;
        default:
          if (a1 != 3602) {
            return 0;
          }
          double result = "BT_VSC_STALL_ERROR";
          break;
      }
    }
    else
    {
      if (a1 > 4199)
      {
        switch(a1)
        {
          case 4200:
            return "BT_ATT_CLASSIC_MTU_REQ_ERROR";
          case 4201:
            return "BT_ATT_UNHANDLED_CLIENT_REQ_ERROR";
          case 4202:
            return "BT_ATT_SESSION_NOT_FOUND_ERROR";
        }
        return 0;
      }
      switch(a1)
      {
        case 4000:
          double result = "LE_LENGTH_ALREADY_BEST_FIT";
          break;
        case 4001:
          double result = "LE_ATT_WRITE_DATA_DROP_ERROR";
          break;
        case 4002:
          double result = "LE_ATT_SENDPDU_INVALID_BEARER";
          break;
        case 4003:
          double result = "LE_ATT_SENDPDU_INVALID_CONN";
          break;
        case 4004:
          double result = "LE_ATT_STATUS_DEFAULT";
          break;
        case 4005:
          double result = "LE_ATT_MTU_EXCH_ERROR";
          break;
        case 4006:
          double result = "LE_ATT_RSP_FIND_INFO_ERROR";
          break;
        case 4007:
          double result = "LE_ATT_RSP_FIND_INFO_UUID_ERROR";
          break;
        case 4008:
          double result = "LE_ATT_RSP_READ_BY_TYPE_LEN_ERROR";
          break;
        case 4009:
          double result = "LE_ATT_RSP_READ_BY_TYPE_ATRB_LEN_ERROR";
          break;
        case 4010:
          double result = "LE_ATT_RSP_READ_BY_GROUP_LEN_ERROR";
          break;
        case 4011:
          double result = "LE_ATT_RSP_READ_BY_GROUP_ATTRB_ERROR";
          break;
        case 4012:
          double result = "LE_ATT_RSP_PREPARE_WRITE_ERROR";
          break;
        case 4013:
          double result = "LE_ATT_INIT_FAIL";
          break;
        case 4014:
          double result = "LE_ATT_DB_SET_CB_ERROR";
          break;
        case 4015:
          double result = "LE_ATT_DB_UNSET_CB_ERROR";
          break;
        case 4016:
          double result = "LE_ATT_REG_ATRB_MAX_HANDLE_ERROR";
          break;
        case 4017:
          double result = "LE_ATT_REG_ATRB_INVALID_HANDLE_ERROR";
          break;
        case 4018:
          double result = "LE_ATT_SEND_CHAR_VAL_UPDATE_ERROR";
          break;
        case 4019:
          double result = "LE_ATT_SEND_CHAR_VAL_UPDATE_ALLOC_ERROR";
          break;
        case 4020:
          double result = "LE_ATT_SEND_CHAR_VAL_UPDATE_SESS_ERROR";
          break;
        case 4021:
          double result = "LE_ATT_WRITE_UNPACK_ERROR";
          break;
        case 4022:
          double result = "LE_ATT_RSP_FIND_BY_TYPE_ERROR";
          break;
        case 4050:
          double result = "LE_GAP_CALLBACK_MAX_ERROR";
          break;
        case 4051:
          double result = "LE_GAP_GETCONNINT_INVALIDHANDLE";
          break;
        case 4052:
          double result = "LE_GAP_GETADDR_INVALIDHANDLE";
          break;
        case 4053:
          double result = "LE_GAP_ADDADDR_MAXCB_ERROR";
          break;
        case 4054:
          double result = "LE_GAP_ROLE_ALREADY_SET_ERROR";
          break;
        case 4055:
          double result = "LE_GAP_SET_DISCOVERABLE_STATE_ERROR";
          break;
        case 4056:
          double result = "LE_GAP_PARSE_UUID_ERROR";
          break;
        case 4057:
          double result = "LE_GAP_PARSE_ADSERVICE_ERROR";
          break;
        case 4058:
          double result = "LE_GAP_PARSE_AD_RSP_ERROR";
          break;
        case 4059:
          double result = "LE_GAP_PARSE_AD_RSP_SIZE_ERROR";
          break;
        case 4060:
          double result = "LE_GAP_DISCOVERY_ALREADY_SCANNING";
          break;
        case 4061:
          double result = "LE_GAP_START_ADVERTISING_ERROR";
          break;
        case 4062:
          double result = "LE_GAP_INIT_ADVERTISING_WRONG_ADDR_ERROR";
          break;
        case 4063:
          double result = "LE_GAP_DIRECT_CONNECTABLE_ERROR";
          break;
        case 4064:
          double result = "LE_GAP_UNDIRECT_CONNECTABLE_ERROR";
          break;
        case 4065:
          double result = "LE_GAP_AUTO_CONNECT_ROLE_ERROR";
          break;
        case 4066:
          double result = "LE_GAP_AUTO_CONNECT_FILTER_ACCEPT_LIST_ERROR";
          break;
        case 4067:
          double result = "LE_GAP_DIRECT_CONNECT_ERROR";
          break;
        case 4068:
          double result = "LE_GAP_START_BONDING_ERROR";
          break;
        case 4069:
          double result = "LE_GAP_UNKNOWN_RANDOM_ADDR_ERROR";
          break;
        case 4070:
          double result = "LE_GAP_GEN_ADDR_ERROR";
          break;
        case 4071:
          double result = "LE_GAP_SET_ADDR_ERROR";
          break;
        case 4072:
          double result = "LE_GAP_REFRESH_ADDR_ERROR";
          break;
        case 4073:
          double result = "LE_GAP_ADDRESS_REFRESH_IN_PROGRESS";
          break;
        case 4074:
          double result = "LE_GAP_ADDRESS_REFRESH_TIMEOUT";
          break;
        case 4075:
          double result = "LE_GAP_ADVERTISING_STATE_UNSETTLED";
          break;
        case 4100:
          double result = "LE_GATT_SESSION_MTU_ERROR";
          break;
        case 4101:
          double result = "LE_GATT_EXE_LONGCHARVALUE_RSP_ERROR";
          break;
        case 4102:
          double result = "LE_GATT_WRITE_LONGCHARVALUE_RSP_ERROR";
          break;
        case 4103:
          double result = "LE_GATT_ADD_CHAR_CB_ERROR";
          break;
        case 4104:
          double result = "LE_GATT_ADD_CHAR_PROPERTIES_ERROR";
          break;
        case 4105:
          double result = "LE_GATT_DB_REGISTERATION_ERROR";
          break;
        case 4106:
          double result = "LE_GATT_DB_REGISTER_ATTRB_ERROR";
          break;
        case 4107:
          double result = "LE_GATT_SENDCHAR_UPDATE_UUID_ERROR";
          break;
        case 4108:
          double result = "LE_GATT_SENDCHAR_NOTIFY_ERROR";
          break;
        case 4109:
          double result = "LE_GATT_SENDCHAR_INDICATE_ERROR";
          break;
        case 4120:
          double result = "LE_SIGNALMAN_SEND_REJECTED";
          break;
        case 4121:
          double result = "LE_SIGNALMAN_SEND_CONN_UPDATE";
          break;
        case 4122:
          double result = "LE_SIGNALMAN_SEND_CHANN_RSP";
          break;
        case 4123:
          double result = "LE_SIGNALMAN_SEND_CHANN_REQ";
          break;
        case 4124:
          double result = "LE_SIGNALMAN_FLOW_ERROR";
          break;
        case 4125:
          double result = "LE_SIGNALMAN_CMD_REJECT_ERROR";
          break;
        case 4126:
          double result = "LE_SIGNALMAN_DISC_REQ_ERROR";
          break;
        case 4127:
          double result = "LE_SIGNALMAN_DISC_RSP_ERROR";
          break;
        case 4151:
          double result = "LE_FILTER_ACCEPT_LIST_ADDRESS_NOT_FOUND_ERROR";
          break;
        case 4152:
          double result = "LE_FILTER_ACCEPT_LIST_DUPLICATE_ADDRESS_FOUND_ERROR";
          break;
        case 4170:
          double result = "LE_CONNECTION_UPDATE_DUPLICATE";
          break;
        default:
          return 0;
      }
    }
  }
  return result;
}

uint64_t sub_100262880(uint64_t a1)
{
  return (*(__int16 *)(a1 + 4) + 1000 * *(_DWORD *)a1);
}

uint64_t sub_100262894(uint64_t a1, uint64_t a2)
{
  if (!a1 || !a2) {
    sub_10025B8C0();
  }
  if (*(_DWORD *)a1 >= *(_DWORD *)a2)
  {
    if (*(_DWORD *)a1 <= *(_DWORD *)a2)
    {
      int v5 = *(__int16 *)(a1 + 4);
      int v6 = *(__int16 *)(a2 + 4);
      BOOL v7 = v5 < v6;
      __int16 v4 = v5 > v6;
      if (v7) {
        return -1;
      }
    }
    else
    {
      return 1;
    }
  }
  else
  {
    return -1;
  }
  return v4;
}

uint64_t sub_100262904(int *a1, int *a2)
{
  int v4 = *a2;
  int v5 = *a1;
  __int16 v6 = *((_WORD *)a2 + 2);
  __int16 v7 = *((_WORD *)a1 + 2);
  int v8 = *a2 - *a1;
  if (*a2 < *a1)
  {
    sub_10025B8C0();
    int v4 = *a2;
    int v5 = *a1;
  }
  if (v4 == v5 && *((__int16 *)a2 + 2) < *((__int16 *)a1 + 2)) {
    sub_10025B8C0();
  }
  __int16 v9 = v6 - v7;
  int v10 = (__int16)(v6 - v7);
  if (v10 < 0) {
    __int16 v9 = v6 - v7 + 1000;
  }
  int v11 = 10 * v9;
  int v13 = v11 + 512;
  BOOL v12 = v11 < -512;
  unsigned int v14 = v11 + 1535;
  if (!v12) {
    unsigned int v14 = v13;
  }
  return (unsigned __int16)(10 * (v8 + (v10 >> 15)) + (v14 >> 10));
}

uint64_t sub_1002629B8(int *a1, int *a2)
{
  int v4 = *a2;
  int v5 = *a1;
  __int16 v6 = *((_WORD *)a2 + 2);
  __int16 v7 = *((_WORD *)a1 + 2);
  int v8 = *a2 - *a1;
  if (*a2 < *a1)
  {
    sub_10025B8C0();
    int v4 = *a2;
    int v5 = *a1;
  }
  if (v4 == v5 && *((__int16 *)a2 + 2) < *((__int16 *)a1 + 2)) {
    sub_10025B8C0();
  }
  __int16 v9 = v6 - v7;
  int v10 = (__int16)(v6 - v7);
  if (v10 < 0) {
    __int16 v9 = v6 - v7 + 1000;
  }
  return (1000 * (v8 + (v10 >> 15)) + v9);
}

BOOL sub_100262A50(uint64_t a1)
{
  uint64_t v3 = 0;
  sub_100026C30((uint64_t)&v3);
  return (sub_100262894((uint64_t)&v3, a1) & 0x8000) == 0;
}

uint64_t sub_100262A98(unsigned __int8 *a1, int a2, _WORD *a3, int a4)
{
  __int16 v7 = a3;
  int v8 = a1;
  if (a1 && a2 > 0 && a3 && a4 > 0)
  {
    int v4 = &a3[a4];
    int v5 = sub_1000F6768(&v8, (unint64_t)&a1[a2], &v7, (unint64_t)v4, 0);
    if (v5)
    {
      return dword_1007BAF20[v5];
    }
    else if (v7 >= v4)
    {
      if (v7 == v4)
      {
        if (*(v4 - 1)) {
          return 3202;
        }
        else {
          return 0;
        }
      }
      else
      {
        return 0;
      }
    }
    else
    {
      uint64_t result = 0;
      *__int16 v7 = 0;
    }
  }
  else
  {
    sub_10025B8C0();
    return 101;
  }
  return result;
}

uint64_t sub_100262B48(unint64_t a1, int a2, unsigned char *a3, int a4)
{
  __int16 v7 = a3;
  unint64_t v8 = a1;
  if (a1 && a2 > 0 && a3 && a4 > 0)
  {
    unint64_t v4 = (unint64_t)&a3[a4];
    int v5 = sub_1000F6500(&v8, a1 + 2 * a2, (uint64_t *)&v7, v4, 0);
    if (v5)
    {
      return dword_1007BAF20[v5];
    }
    else if ((unint64_t)v7 >= v4)
    {
      if (v7 == (unsigned char *)v4)
      {
        if (*(unsigned char *)(v4 - 1)) {
          return 3202;
        }
        else {
          return 0;
        }
      }
      else
      {
        return 0;
      }
    }
    else
    {
      uint64_t result = 0;
      *__int16 v7 = 0;
    }
  }
  else
  {
    sub_10025B8C0();
    return 101;
  }
  return result;
}

uint64_t sub_100262BF8(unsigned __int16 *a1)
{
  unsigned int v1 = a1;
  if (!a1) {
    sub_10025B8C0();
  }
  LODWORD(result) = -1;
  do
  {
    int v3 = *v1++;
    uint64_t result = (result + 1);
  }
  while (v3);
  return result;
}

uint64_t sub_100262C30(unsigned __int16 *a1, unsigned __int16 *a2)
{
  if (a1)
  {
    if (a2) {
      goto LABEL_4;
    }
    goto LABEL_3;
  }
  sub_10025B8C0();
  if (!a2) {
LABEL_3:
  }
    sub_10025B8C0();
LABEL_4:
  unsigned int v4 = *a1;
  unsigned int v5 = *a2;
  if (v4 < v5) {
    return 0xFFFFFFFFLL;
  }
  __int16 v6 = a2 + 1;
  __int16 v7 = a1 + 1;
  while (1)
  {
    if (v4 > v5) {
      return 1;
    }
    if (!v4) {
      break;
    }
    unsigned int v8 = *v7++;
    unsigned int v4 = v8;
    unsigned int v9 = *v6++;
    unsigned int v5 = v9;
    if (v4 < v9) {
      return 0xFFFFFFFFLL;
    }
  }
  return 0;
}

uint64_t sub_100262CB4(unsigned __int16 *a1, unsigned __int16 *a2, int a3)
{
  unsigned int v4 = a2;
  unsigned int v5 = a1;
  if (a1)
  {
    if (a2) {
      goto LABEL_3;
    }
  }
  else
  {
    sub_10025B8C0();
    if (v4)
    {
LABEL_3:
      if (a3) {
        goto LABEL_4;
      }
      return 0;
    }
  }
  sub_10025B8C0();
  if (!a3) {
    return 0;
  }
  while (1)
  {
LABEL_4:
    LOWORD(a3) = a3 - 1;
    unsigned int v6 = *v5;
    unsigned int v7 = *v4;
    if (v6 < v7) {
      return 0xFFFFFFFFLL;
    }
    if (v6 > v7) {
      break;
    }
    ++v5;
    ++v4;
    if (v6) {
      BOOL v8 = (unsigned __int16)a3 == 0;
    }
    else {
      BOOL v8 = 1;
    }
    if (v8) {
      return 0;
    }
  }
  return 1;
}

unsigned char *sub_100262D48(unsigned char *result, int *a2)
{
  if (result && a2)
  {
    for (uint64_t i = 0; ; ++i)
    {
      int v3 = result[i];
      if (v3 != 32 && v3 != 9) {
        break;
      }
    }
    uint64_t v5 = v3 == 45;
    uint64_t v6 = (uint64_t)(v3 == 45 ? result + 1 : result);
    unsigned int v7 = (unsigned char *)(v6 + i);
    int v8 = *(unsigned __int8 *)(v6 + i);
    if ((v8 - 48) <= 9)
    {
      if (v8 == 48 && (unsigned int v9 = &result[v5 + i], v9[1] == 120))
      {
        int v12 = v9[2];
        int v11 = v9 + 2;
        int v10 = v12;
        if (v12)
        {
          int v13 = 0;
          do
          {
            if ((v10 - 48) >= 0xA)
            {
              if ((v10 - 97) >= 6)
              {
                if ((v10 - 65) > 5) {
                  break;
                }
                int v14 = -55;
              }
              else
              {
                int v14 = -87;
              }
            }
            else
            {
              int v14 = -48;
            }
            int v13 = v14 + 16 * v13 + v10;
            int v10 = result[v5++ + 3 + i];
          }
          while (v10);
          result += i + v5 + 2;
        }
        else
        {
          int v13 = 0;
          uint64_t result = v11;
        }
      }
      else
      {
        int v15 = 0;
        do
        {
          int v13 = v15;
          uint64_t result = v7;
          int v16 = *v7;
          if (!*v7) {
            break;
          }
          unsigned int v17 = v16 - 48;
          int v15 = v16 - 48 + 10 * v13;
          ++v7;
        }
        while (v17 < 0xA);
      }
      if (v3 == 45) {
        int v18 = -v13;
      }
      else {
        int v18 = v13;
      }
      *a2 = v18;
    }
  }
  return result;
}

uint64_t sub_100262E60(unsigned __int8 *a1, unsigned __int8 *a2, int a3)
{
  unsigned int v4 = a2;
  uint64_t v5 = a1;
  if (a1)
  {
    if (a2) {
      goto LABEL_3;
    }
  }
  else
  {
    sub_10025B8C0();
    if (v4)
    {
LABEL_3:
      if (!a3) {
        return 0;
      }
      goto LABEL_7;
    }
  }
  sub_10025B8C0();
  if (!a3) {
    return 0;
  }
LABEL_7:
  for (int i = a3 - 1; ; --i)
  {
    int v7 = *v5;
    if ((v7 - 97) < 0x1A) {
      LOBYTE(v7) = v7 - 32;
    }
    int v8 = *v4;
    if ((v8 - 97) < 0x1A) {
      LOBYTE(v8) = v8 - 32;
    }
    if (v7 < v8) {
      return 0xFFFFFFFFLL;
    }
    if (v7 > v8) {
      break;
    }
    ++v5;
    ++v4;
    if ((_BYTE)v7) {
      BOOL v9 = i == 0;
    }
    else {
      BOOL v9 = 1;
    }
    if (v9) {
      return 0;
    }
  }
  return 1;
}

uint64_t sub_100262F1C(unsigned char *a1)
{
  unsigned int v2 = 0;
  if (sub_100262D48(a1, (int *)&v2) == a1) {
    return 0;
  }
  else {
    return v2;
  }
}

uint64_t sub_100262F5C(unsigned __int8 *a1, unsigned __int8 *a2)
{
  if (a1)
  {
    if (a2) {
      goto LABEL_4;
    }
    goto LABEL_3;
  }
  sub_10025B8C0();
  if (!a2) {
LABEL_3:
  }
    sub_10025B8C0();
LABEL_4:
  int v4 = *a1;
  if ((v4 - 97) < 0x1A) {
    LOBYTE(v4) = v4 - 32;
  }
  int v5 = *a2;
  if ((v5 - 97) >= 0x1A) {
    unsigned __int8 v6 = *a2;
  }
  else {
    unsigned __int8 v6 = v5 - 32;
  }
  if (v4 < v6) {
    return 0xFFFFFFFFLL;
  }
  int v7 = a2 + 1;
  int v8 = a1 + 1;
  while (1)
  {
    if (v4 > v6) {
      return 1;
    }
    if (!(_BYTE)v4) {
      break;
    }
    int v9 = *v8++;
    LOBYTE(v4) = v9;
    char v10 = v9 - 32;
    if ((v9 - 97) < 0x1A) {
      LOBYTE(v4) = v10;
    }
    int v11 = *v7++;
    unsigned __int8 v6 = v11;
    unsigned __int8 v12 = v11 - 32;
    if ((v11 - 97) < 0x1A) {
      unsigned __int8 v6 = v12;
    }
    if (v4 < v6) {
      return 0xFFFFFFFFLL;
    }
  }
  return 0;
}

unsigned __int8 *sub_100263030(unsigned __int8 *a1, uint64_t a2)
{
  if (!a1 || !a2) {
    return a1;
  }
  for (int i = a1; ; ++i)
  {
    int v3 = *i;
    if (v3 != 9 && v3 != 32) {
      break;
    }
  }
  for (uint64_t j = 0; j != 6; ++j)
  {
    int v5 = *i;
    if ((v5 - 48) >= 0xA)
    {
      if ((v5 - 97) >= 6)
      {
        if ((v5 - 65) > 5) {
          return a1;
        }
        char v6 = -55;
      }
      else
      {
        char v6 = -87;
      }
    }
    else
    {
      char v6 = -48;
    }
    int v7 = i[1];
    if ((v7 - 48) >= 0xA)
    {
      if ((v7 - 97) >= 6)
      {
        if ((v7 - 65) > 5) {
          return a1;
        }
        char v8 = -55;
      }
      else
      {
        char v8 = -87;
      }
    }
    else
    {
      char v8 = -48;
    }
    *(unsigned char *)(a2 + j) = v7 + 16 * (v6 + v5) + v8;
    int v9 = i + 2;
    int v10 = i[2];
    if (v10 == 58 || v10 == 45) {
      int v9 = i + 3;
    }
    int i = v9;
  }
  return v9;
}

BOOL sub_100263120(unsigned __int8 *a1, uint64_t a2)
{
  return sub_100263030(a1, a2) != a1;
}

uint64_t sub_10026314C(uint64_t a1, size_t size)
{
  __int16 v2 = size;
  *(unsigned char *)a1 = 1;
  *(_WORD *)(a1 + 4) = 0;
  int v4 = sub_100022FE8(size);
  *(void *)(a1 + 8) = v4;
  if (v4) {
    __int16 v5 = v2;
  }
  else {
    __int16 v5 = 0;
  }
  if (v4) {
    uint64_t result = 0;
  }
  else {
    uint64_t result = 106;
  }
  *(_WORD *)(a1 + 2) = v5;
  return result;
}

void sub_10026319C(uint64_t a1)
{
  if (!*(unsigned char *)a1) {
    sub_10025B8C0();
  }
  sub_100023010(*(void **)(a1 + 8));
  *(void *)(a1 + 8) = 0;
  *(_WORD *)(a1 + 2) = 0;
}

uint64_t sub_1002631D8(uint64_t a1, char *a2, int a3)
{
  uint64_t result = 0;
  if (a2)
  {
    int v5 = a3;
    if (a3)
    {
      char v6 = a2;
      while (1)
      {
        char v7 = *v6;
        if (!*v6) {
          return 0;
        }
        if (!*(_WORD *)(a1 + 2)
          || (unsigned int v8 = *(unsigned __int16 *)(a1 + 4), *(unsigned __int16 *)(a1 + 2) - 1 <= v8))
        {
          if (!*(unsigned char *)a1) {
            return 0;
          }
          if (!sub_10026327C(a1)) {
            return 106;
          }
          char v7 = *v6;
          unsigned int v8 = *(unsigned __int16 *)(a1 + 4);
        }
        --v5;
        ++v6;
        uint64_t v9 = *(void *)(a1 + 8);
        *(_WORD *)(a1 + 4) = v8 + 1;
        *(unsigned char *)(v9 + v8) = v7;
        if (!(_WORD)v5) {
          return 0;
        }
      }
    }
  }
  return result;
}

BOOL sub_10026327C(uint64_t a1)
{
  if (!*(void *)(a1 + 8)) {
    sub_10025B8C0();
  }
  if (!*(unsigned char *)a1) {
    sub_10025B8C0();
  }
  __int16 v2 = sub_100022FE8(*(unsigned __int16 *)(a1 + 2) + 32);
  int v3 = v2;
  if (v2)
  {
    if (*(_WORD *)(a1 + 4))
    {
      unint64_t v4 = 0;
      do
      {
        v2[v4] = *(unsigned char *)(*(void *)(a1 + 8) + v4);
        ++v4;
      }
      while (v4 < *(unsigned __int16 *)(a1 + 4));
    }
    sub_100023010(*(void **)(a1 + 8));
    *(void *)(a1 + 8) = v3;
    *(_WORD *)(a1 + 2) += 32;
  }
  return v3 != 0;
}

uint64_t sub_100263310(uint64_t a1, unsigned char *a2)
{
  if (!a2) {
    return 0;
  }
  int v2 = *a2;
  if (!*a2) {
    return 0;
  }
  unint64_t v4 = a2 + 1;
  while (*(_WORD *)(a1 + 2) && *(unsigned __int16 *)(a1 + 2) - 1 > *(unsigned __int16 *)(a1 + 4))
  {
LABEL_9:
    if (v2 == 10)
    {
      uint64_t v5 = a1;
      char v6 = "<lf>";
    }
    else
    {
      if (v2 != 13)
      {
        uint64_t v7 = *(void *)(a1 + 8);
        uint64_t v8 = *(unsigned __int16 *)(a1 + 4);
        *(_WORD *)(a1 + 4) = v8 + 1;
        *(unsigned char *)(v7 + v8) = v2;
        goto LABEL_15;
      }
      uint64_t v5 = a1;
      char v6 = "<cr>";
    }
    sub_100057604(v5, v6);
LABEL_15:
    int v9 = *v4++;
    int v2 = v9;
    if (!v9) {
      return 0;
    }
  }
  if (!*(unsigned char *)a1) {
    return 0;
  }
  if (sub_10026327C(a1))
  {
    int v2 = *(v4 - 1);
    goto LABEL_9;
  }
  return 106;
}

uint64_t sub_1002633E8(uint64_t a1, unsigned char *a2, int a3)
{
  uint64_t result = 0;
  if (a2)
  {
    int v5 = a3;
    if (a3)
    {
      for (int i = a2; ; ++i)
      {
        if (!*(_WORD *)(a1 + 2) || *(unsigned __int16 *)(a1 + 2) - 1 <= *(unsigned __int16 *)(a1 + 4))
        {
          if (!*(unsigned char *)a1) {
            return 0;
          }
          if (!sub_10026327C(a1)) {
            return 106;
          }
        }
        int v7 = *i;
        if (*i)
        {
          if (v7 == 10)
          {
            uint64_t v8 = a1;
            int v9 = "<lf>";
          }
          else
          {
            if (v7 != 13)
            {
              uint64_t v10 = *(void *)(a1 + 8);
              uint64_t v11 = *(unsigned __int16 *)(a1 + 4);
              *(_WORD *)(a1 + 4) = v11 + 1;
              *(unsigned char *)(v10 + v11) = v7;
              goto LABEL_16;
            }
            uint64_t v8 = a1;
            int v9 = "<cr>";
          }
        }
        else
        {
          uint64_t v8 = a1;
          int v9 = "<null>";
        }
        sub_100057604(v8, v9);
LABEL_16:
        if (!(_WORD)--v5) {
          return 0;
        }
      }
    }
  }
  return result;
}

uint64_t sub_1002634E0(uint64_t a1, int a2)
{
  if (!a2) {
    return 0;
  }
  int v2 = a2;
  while (1)
  {
    if (*(_WORD *)(a1 + 2))
    {
      unsigned int v4 = *(unsigned __int16 *)(a1 + 4);
      if (*(unsigned __int16 *)(a1 + 2) - 1 > v4) {
        goto LABEL_8;
      }
    }
    if (!*(unsigned char *)a1) {
      return 0;
    }
    if (!sub_10026327C(a1)) {
      return 106;
    }
    unsigned int v4 = *(unsigned __int16 *)(a1 + 4);
LABEL_8:
    --v2;
    uint64_t v5 = *(void *)(a1 + 8);
    *(_WORD *)(a1 + 4) = v4 + 1;
    *(unsigned char *)(v5 + v4) = 32;
    if (!(_BYTE)v2) {
      return 0;
    }
  }
}

uint64_t sub_100263578(uint64_t a1, unsigned int a2)
{
  if (a2 == 0x80000000)
  {
    return sub_100057604(a1, "-2147483648");
  }
  else
  {
    unsigned int v4 = a2;
    if ((a2 & 0x80000000) != 0)
    {
      sub_100057604(a1, "-");
      unsigned int v4 = -v4;
    }
    char v7 = 0;
    uint64_t v5 = &v8;
    char v8 = 0;
    do
    {
      *--uint64_t v5 = a0123456789abcd_0[v4 % 0xA];
      BOOL v6 = v4 > 9;
      v4 /= 0xAu;
    }
    while (v6);
    return sub_100057604(a1, v5);
  }
}

uint64_t sub_100263854(uint64_t a1, unint64_t a2)
{
  int v3 = (char *)&v6 + 1;
  __int16 v6 = 0;
  do
  {
    *--int v3 = a0123456789abcd_0[a2 % 0xA];
    BOOL v4 = a2 > 9;
    a2 /= 0xAuLL;
  }
  while (v4);
  return sub_100057604(a1, v3);
}

uint64_t sub_1002638E8(uint64_t result, unsigned __int16 *a2, int a3)
{
  uint64_t v10 = a2;
  if (a2)
  {
    int v3 = a3;
    uint64_t v5 = result;
    if ((int)sub_100262BF8(a2) <= a3) {
      int v3 = sub_100262BF8(a2);
    }
    unint64_t v6 = (unint64_t)&a2[v3];
    do
    {
      uint64_t v7 = *(void *)(v5 + 8);
      uint64_t v9 = v7 + *(unsigned __int16 *)(v5 + 4);
      __int16 v8 = *(_WORD *)(v5 + 2) + v7 - 1;
      uint64_t result = sub_1000F6500((unint64_t *)&v10, v6, &v9, *(unsigned __int16 *)(v5 + 2) + v7 - 1, 0);
      *(_WORD *)(v5 + 4) = ~v8 + *(_WORD *)(v5 + 2) + v9;
      if (result != 2) {
        break;
      }
      if (!*(unsigned char *)v5) {
        break;
      }
      uint64_t result = sub_10026327C(v5);
    }
    while ((result & 1) != 0);
  }
  return result;
}

uint64_t sub_1002639B0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  return sub_100057728(a1, a2, &a9);
}

uint64_t sub_1002639DC(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 8);
  if (!v1) {
    return 0;
  }
  unsigned int v3 = *(unsigned __int16 *)(a1 + 4);
  if (v3 >= *(unsigned __int16 *)(a1 + 2))
  {
    sub_10025B8C0();
    uint64_t v1 = *(void *)(a1 + 8);
    unsigned int v3 = *(unsigned __int16 *)(a1 + 4);
  }
  *(unsigned char *)(v1 + v3) = 0;
  return *(void *)(a1 + 8);
}

const char *sub_100263A30()
{
  return "5.0";
}

const char *sub_100263A3C()
{
  return "Copyright (c) 2017 Apple Inc. All rights reserved";
}

uint64_t sub_100263A48(void *a1, _WORD *a2)
{
  *a2 = 0;
  *a1 = 0;
  return 102;
}

uint64_t sub_100263A58(NSObject *a1, uint64_t (*a2)(void, void))
{
  kern_return_t v9;
  io_object_t notification;

  if (a1 && a2)
  {
    CFDictionaryRef v4 = IOServiceMatching("AppleBluetoothModule");
    io_service_t MatchingService = IOServiceGetMatchingService(kIOMainPortDefault, v4);
    if (MatchingService)
    {
      io_service_t v6 = MatchingService;
      IONotificationPortRef v7 = IONotificationPortCreate(kIOMainPortDefault);
      if (v7)
      {
        __int16 v8 = v7;
        notification = 0;
        dispatch_retain(a1);
        off_100A12030 = a2;
        IONotificationPortSetDispatchQueue(v8, a1);
        uint64_t v9 = IOServiceAddInterestNotification(v8, v6, "IOGeneralInterest", (IOServiceInterestCallback)sub_100263B74, 0, &notification);
        if (!v9) {
          return 1;
        }
        sub_10025B778("Could not add interest notification on service: %#x\n", v9);
        IONotificationPortDestroy(v8);
        dispatch_release(a1);
      }
      else
      {
        sub_10025B778("Cannot create notification port\n");
      }
    }
    else
    {
      sub_10025B778("Cannot find AppleBluetoothModule service\n");
    }
  }
  else
  {
    sub_10025B778("Invalid parameter\n");
  }
  return 0;
}

uint64_t sub_100263B74(uint64_t a1, uint64_t a2, int a3, unsigned int *a4)
{
  if (a3 == -469794804 && a4 != 0) {
    return off_100A12030(*a4, *((void *)a4 + 1));
  }
  return result;
}

void *sub_100263BA0(unsigned __int16 *a1, uint64_t a2)
{
  uint64_t result = (void *)((uint64_t (*)(void (*)(int, void *, uint64_t, uint64_t), void, void, uint64_t, void))loc_1001DE1A4)(sub_100263C40, *a1, 0, a2, 0);
  if (*(_WORD *)(a2 + 4))
  {
    uint64_t v5 = *((void *)a1 + 14);
    io_service_t v6 = sub_10010CE48(8uLL);
    sub_10025C220(v6, a2, 0);
    return sub_1002596A4(v5, (uint64_t)v6, 8);
  }
  return result;
}

void sub_100263C40(int a1, void *a2, uint64_t a3, uint64_t a4)
{
  io_service_t v6 = sub_100112300(a1);
  sub_10011255C((uint64_t)v6, a2, a4);
  if (sub_100059E10(*((void *)v6 + 14)))
  {
    IONotificationPortRef v7 = (void *)sub_1002598B4(*((void *)v6 + 14), 0);
    sub_100263BA0(v6, *v7);
    sub_100023010(v7);
  }
}

uint64_t sub_100263CCC(uint64_t a1)
{
  if (!a1) {
    return 114;
  }
  uint64_t v2 = *(void *)(a1 + 112);
  if (!v2) {
    return 114;
  }
  if (sub_100059E10(v2))
  {
    uint64_t v3 = *(void *)(a1 + 112);
    uint64_t v4 = *(void *)(a1 + 40);
    uint64_t v5 = sub_10010CE48(8uLL);
    sub_10025C220(v5, v4, 0);
    sub_100259764(v3, (uint64_t)v5, 8);
    sub_10025C53C(*(void **)(a1 + 40));
    uint64_t result = 0;
    *(void *)(a1 + 40) = 0;
  }
  else
  {
    sub_100263BA0((unsigned __int16 *)a1, *(void *)(a1 + 40));
    return 0;
  }
  return result;
}

uint64_t sub_100263D70(uint64_t a1, uint64_t a2, int a3, _WORD *a4, uint64_t a5, char a6)
{
  sub_1001E6318(a4);
  uint64_t v12 = sub_1001E5FF0((unsigned __int16)*a4, (uint64_t)sub_100263F80);
  if (v12)
  {
    uint64_t v13 = v12;
    if (sub_100058654())
    {
      sub_100056E24((uint64_t)"OI_L2CAP_Register failed with result %!", v14, v15, v16, v17, v18, v19, v20, v13);
      uint64_t v21 = sub_100050B4C(0x18u);
      if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR)) {
        sub_100744F6C();
      }
    }
  }
  else
  {
    if (sub_100058654())
    {
      sub_100056E24((uint64_t)"Registered PSM %d", v22, v23, v24, v25, v26, v27, v28, (unsigned __int16)*a4);
      uint64_t v29 = sub_100050B4C(0x18u);
      if (os_log_type_enabled(v29, OS_LOG_TYPE_INFO))
      {
        *(_DWORD *)long long buf = 136446210;
        uint64_t v41 = sub_100050714();
        _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_INFO, " %{public}s", buf, 0xCu);
      }
    }
    uint64_t v30 = sub_10010CE48(0xD8uLL);
    v30[18] = a2;
    *((_DWORD *)v30 + 38) = a3;
    *((_WORD *)v30 + 100) = 0;
    *((_DWORD *)v30 + 51) = 0;
    *((_WORD *)v30 + 98) = *a4;
    if (a1)
    {
      v30[17] = *(void *)(a1 + 8);
      *((_WORD *)v30 + 64) = *(_WORD *)a1;
    }
    v30[23] = a5;
    *((unsigned char *)v30 + 192) = a6;
    v30[8] = 0;
    v30[1] = 0;
    uint64_t v13 = sub_100112490((uint64_t)v30);
    if (v13)
    {
      if (sub_100058654())
      {
        sub_100056E24((uint64_t)"AddConnection failed with result %!", v31, v32, v33, v34, v35, v36, v37, v13);
        uint64_t v38 = sub_100050B4C(0x18u);
        if (os_log_type_enabled(v38, OS_LOG_TYPE_ERROR)) {
          sub_100744F6C();
        }
      }
    }
    else
    {
      ++dword_100A19810;
    }
  }
  return v13;
}

void sub_100263F80(int a1, int *a2, unsigned int a3)
{
  uint64_t v5 = sub_100112390(a1);
  if (*(_DWORD *)(v5 + 204))
  {
    if (sub_100058654())
    {
      sub_100056E24((uint64_t)"Rejecting the L2CAP connection", v6, v7, v8, v9, v10, v11, v12, v27);
      uint64_t v13 = sub_100050B4C(0x18u);
      if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR)) {
        sub_100744F6C();
      }
    }
    sub_1001E0320(0, 0, 0, a3, 0, 0, 0);
  }
  else
  {
    uint64_t v14 = v5;
    uint64_t v15 = *(void **)(v5 + 8);
    if (v15) {
      sub_100023010(v15);
    }
    *(void *)(v14 + 112) = 0;
    *(_OWORD *)(v14 + 80) = 0u;
    *(_OWORD *)(v14 + 96) = 0u;
    *(_OWORD *)(v14 + 48) = 0u;
    *(_OWORD *)(v14 + 64) = 0u;
    *(_OWORD *)(v14 + 16) = 0u;
    *(_OWORD *)(v14 + 32) = 0u;
    *(_OWORD *)uint64_t v14 = 0u;
    int v16 = *a2;
    *(_WORD *)(v14 + 108) = *((_WORD *)a2 + 2);
    *(_DWORD *)(v14 + 104) = v16;
    *(_WORD *)uint64_t v14 = a3;
    *(_DWORD *)(v14 + 4) = 1;
    *(void *)(v14 + 112) = sub_10025959C(0, 0);
    uint64_t v17 = sub_1001E0320((uint64_t)sub_100264188, (uint64_t)sub_100264390, (uint64_t)sub_1002644B0, a3, (uint64_t)&unk_10099FE00, 1, *(void *)(v14 + 184));
    if (v17)
    {
      uint64_t v18 = v17;
      if (sub_100058654())
      {
        sub_100056E24((uint64_t)"OI_L2CAP_Accept failed with result %!", v19, v20, v21, v22, v23, v24, v25, v18);
        uint64_t v26 = sub_100050B4C(0x18u);
        if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR)) {
          sub_100744F6C();
        }
      }
    }
    else
    {
      *(_DWORD *)(v14 + 204) = 1;
    }
  }
}

uint64_t sub_100264110(int a1)
{
  sub_100112420(a1);

  return sub_1001E61E4(a1);
}

uint64_t sub_100264148(unsigned int a1, _WORD *a2)
{
  uint64_t v3 = sub_100112524(a1);
  if (!v3) {
    return 1709;
  }
  uint64_t v4 = v3;
  uint64_t result = 0;
  *a2 = *(_WORD *)(v4 + 196);
  return result;
}

void sub_100264188(int a1, unsigned int a2, unsigned __int16 a3, uint64_t a4)
{
  uint64_t v7 = sub_100112300(a1);
  uint64_t v8 = v7;
  v42[0] = 0;
  if (a4)
  {
    if (sub_100058654())
    {
      sub_100056E24((uint64_t)"L2CAPConnectCB failed with result %!", v9, v10, v11, v12, v13, v14, v15, a4);
      int v16 = sub_100050B4C(0x18u);
      if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR)) {
        sub_100744F6C();
      }
    }
    *((_DWORD *)v8 + 51) = 0;
    uint64_t v17 = (void *)*((void *)v8 + 1);
    if (v17)
    {
      sub_100023010(v17);
      *((void *)v8 + 1) = 0;
    }
  }
  else
  {
    *((_DWORD *)v7 + 51) = 2;
    v7[36] = a3;
    v7[38] = a3;
    v7[37] = a2;
    uint64_t v18 = sub_10010CE48(a2);
    uint64_t v20 = v8 + 88;
    int v19 = *((_DWORD *)v8 + 44);
    *((void *)v8 + 1) = v18;
    if (v19)
    {
      if (sub_100058654())
      {
        sub_100056E24((uint64_t)"Cancelling timeout countdown", v21, v22, v23, v24, v25, v26, v27, v41);
        uint64_t v28 = sub_100050B4C(0x18u);
        if (os_log_type_enabled(v28, OS_LOG_TYPE_INFO))
        {
          *(_DWORD *)long long buf = 136446210;
          unsigned int v44 = sub_100050714();
          _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_INFO, " %{public}s", buf, 0xCu);
        }
      }
      sub_100026DB4(*v20);
      *uint64_t v20 = 0;
    }
    BOOL v29 = *((_DWORD *)v8 + 38) != 0;
    int v30 = *(unsigned __int16 *)(sub_10025B218(0x18u) + 2 * v29);
    v42[1] = v8 + 104;
    LOWORD(v42[0]) = 2;
    uint64_t v31 = sub_1000268E4((uint64_t)sub_1002644F0, v42, v30, (int *)v8 + 44);
    if (v31)
    {
      uint64_t v32 = v31;
      if (sub_100058654())
      {
        sub_100056E24((uint64_t)"OI_Dispatch_RegisterTimedFunc failed with result %!", v33, v34, v35, v36, v37, v38, v39, v32);
        uint64_t v40 = sub_100050B4C(0x18u);
        if (os_log_type_enabled(v40, OS_LOG_TYPE_ERROR)) {
          sub_100744F6C();
        }
      }
    }
  }
}

void sub_100264390(unsigned int a1)
{
  uint64_t v2 = sub_100112300(a1);
  if (v2)
  {
    uint64_t v3 = (uint64_t)v2;
    sub_1002595D8(*((void **)v2 + 14));
    *(void *)long long buf = 0;
    if (!sub_1001DD56C(a1, (uint64_t *)buf)) {
      sub_1001DEC18(*(uint64_t *)buf);
    }
    sub_1001137D0(v3);
  }
  else if (sub_100058654())
  {
    sub_100056E24((uint64_t)"IGNORING L2CAPDisconnectCB as connection was NULL (cid = %d, reason = %!)", v4, v5, v6, v7, v8, v9, v10, a1);
    uint64_t v11 = sub_100050B4C(0x18u);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 136446210;
      *(void *)&uint8_t buf[4] = sub_100050714();
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
    }
  }
}

void sub_1002644B0(int a1, void *a2, size_t a3)
{
  uint64_t v5 = sub_100112300(a1);

  sub_1001138B0((uint64_t)v5, a2, a3);
}

uint64_t sub_1002644F0(uint64_t a1)
{
  unsigned int v1 = **(unsigned __int16 **)(a1 + 8);
  uint64_t v2 = sub_100112524(v1);
  if (*(_DWORD *)(v2 + 204) == 5) {
    sub_10025B8C0();
  }
  *(_DWORD *)(v2 + 176) = 0;

  return sub_1001148A0(v1);
}

void *sub_100264548(uint64_t a1)
{
  if (sub_100058654())
  {
    sub_100056E24((uint64_t)"HandsfreeAoS_Register", v2, v3, v4, v5, v6, v7, v8, *(uint64_t *)v11);
    uint64_t v9 = sub_100050B4C(0x5Au);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)uint64_t v11 = 136446210;
      *(void *)&v11[4] = sub_100050714();
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, " %{public}s", v11, 0xCu);
    }
  }
  uint64_t result = malloc_type_calloc(1uLL, 0x88uLL, 0xA004050197E0BuLL);
  qword_100A12038 = (uint64_t)result;
  result[16] = a1;
  return result;
}

uint64_t sub_100264630(uint64_t a1)
{
  if (sub_100058654())
  {
    sub_100056E24((uint64_t)"HandsfreeAoS_Connect - addr:%:", v2, v3, v4, v5, v6, v7, v8, a1);
    uint64_t v9 = sub_100050B4C(0x5Au);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 136446210;
      uint64_t v22 = sub_100050714();
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
    }
  }
  if (sub_1002647B8(a1)) {
    return 126;
  }
  uint64_t v12 = (_WORD *)(sub_100264804(a1) + 128);
  uint64_t v10 = sub_1001DF7BC((uint64_t)sub_100264894, (uint64_t)sub_100264988, (uint64_t)sub_100264A94, 4099, a1, (uint64_t)&xmmword_1007BAF48, v12, (uint64_t)&unk_10099FE20);
  if (v10)
  {
    sub_100264AC8((unsigned __int16)*v12);
    if (sub_100058654())
    {
      sub_100056E24((uint64_t)"L2CAP connection attempt failed %!", v13, v14, v15, v16, v17, v18, v19, v10);
      uint64_t v20 = sub_100050B4C(0x5Au);
      if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR)) {
        sub_100744F6C();
      }
    }
  }
  return v10;
}

uint64_t sub_1002647B8(uint64_t a1)
{
  uint64_t v1 = 0;
  while (1)
  {
    uint64_t v2 = *(void *)(qword_100A12038 + v1);
    if (v2)
    {
      uint64_t v3 = *(int **)(v2 + 8);
      int v4 = *v3;
      int v5 = *((unsigned __int16 *)v3 + 2);
      if (v4 == *(_DWORD *)a1 && v5 == *(unsigned __int16 *)(a1 + 4)) {
        break;
      }
    }
    v1 += 8;
    if (v1 == 128) {
      return 0;
    }
  }
  return v2;
}

uint64_t sub_100264804(uint64_t a1)
{
  uint64_t v2 = 0;
  while (*(void *)(qword_100A12038 + v2))
  {
    v2 += 8;
    if (v2 == 128) {
      return 0;
    }
  }
  int v4 = malloc_type_calloc(1uLL, 0x88uLL, 0x10F20406ED7B6AEuLL);
  *(void *)(qword_100A12038 + v2) = v4;
  v4[1] = a1;
  uint64_t v5 = sub_100197A30(a1);
  uint64_t v6 = qword_100A12038;
  **(void **)(qword_100A12038 + v2) = v5;
  return *(void *)(v6 + v2);
}

void sub_100264894(unsigned int a1, uint64_t a2, uint64_t a3, int a4)
{
  if (sub_100058654())
  {
    sub_100056E24((uint64_t)"L2CAPConnectCB - cid:%d inMTU:%d outMTU:%d result:%!", v6, v7, v8, v9, v10, v11, v12, a1);
    uint64_t v13 = sub_100050B4C(0x5Au);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 136446210;
      uint64_t v15 = sub_100050714();
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
    }
  }
  if (a4) {
    sub_100264AC8(a1);
  }
}

void sub_100264988(unsigned int a1)
{
  if (sub_100058654())
  {
    sub_100056E24((uint64_t)"L2CAPDisconnectCB - cid:%d reason:%!", v2, v3, v4, v5, v6, v7, v8, a1);
    uint64_t v9 = sub_100050B4C(0x5Au);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 136446210;
      uint64_t v14 = sub_100050714();
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
    }
  }
  for (uint64_t i = 0; ; i += 8)
  {
    uint64_t v11 = *(void *)(qword_100A12038 + i);
    if (v11)
    {
      if (*(unsigned __int16 *)(v11 + 128) == a1) {
        break;
      }
    }
  }
  uint64_t v12 = sub_100156DD0(*(void *)v11);
  sub_1001568B4(v12, 0);
  sub_100264AC8(a1);
}

uint64_t sub_100264A94(int a1)
{
  for (uint64_t i = 0; ; i += 8)
  {
    uint64_t v2 = *(void *)(qword_100A12038 + i);
    if (v2)
    {
      if (*(unsigned __int16 *)(v2 + 128) == a1) {
        break;
      }
    }
  }
  return (*(uint64_t (**)(void))(qword_100A12038 + 128))(*(void *)(v2 + 8));
}

void sub_100264AC8(int a1)
{
  uint64_t v1 = 0;
  uint64_t v2 = qword_100A12038;
  while (1)
  {
    uint64_t v3 = *(void *)(qword_100A12038 + v1);
    if (v3)
    {
      if (*(unsigned __int16 *)(v3 + 128) == a1) {
        break;
      }
    }
    v1 += 8;
    if (v1 == 128) {
      return;
    }
  }
  free(*(void **)(qword_100A12038 + v1));
  *(void *)(v2 + v1) = 0;
}

void sub_100264B20(uint64_t a1, char *a2, size_t a3)
{
  uint64_t v6 = sub_1002647B8(a1);
  if (v6)
  {
    uint64_t v7 = v6;
    uint64_t v8 = (unsigned __int8 *)(v6 + 16);
    uint64_t v9 = sub_1000226D0(v6 + 16, 1u);
    if (v9)
    {
      uint64_t v10 = v9;
      if (sub_100058654())
      {
        sub_100056E24((uint64_t)"Failed to initialize mbuf - result:%!", v11, v12, v13, v14, v15, v16, v17, v10);
        uint64_t v18 = sub_100050B4C(0x5Au);
        if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR)) {
          sub_100744F6C();
        }
      }
    }
    uint64_t v19 = sub_100022798(v8, a2, a3, 2u);
    if (v19)
    {
      uint64_t v20 = v19;
      if (sub_100058654())
      {
        sub_100056E24((uint64_t)"Failed to append mbuf - result:%!", v21, v22, v23, v24, v25, v26, v27, v20);
        uint64_t v28 = sub_100050B4C(0x5Au);
        if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR)) {
          sub_100744F6C();
        }
      }
    }
    uint64_t v29 = ((uint64_t (*)(void, void, void, unsigned __int8 *, void))loc_1001DE1A4)(0, *(unsigned __int16 *)(v7 + 128), 0, v8, 0);
    if (v29)
    {
      uint64_t v30 = v29;
      if (v29 != 412)
      {
        if (sub_100058654())
        {
          sub_100056E24((uint64_t)"Failed to send HandsfreeAoS data - result:%!", v31, v32, v33, v34, v35, v36, v37, v30);
          uint64_t v38 = sub_100050B4C(0x5Au);
          if (os_log_type_enabled(v38, OS_LOG_TYPE_ERROR)) {
            goto LABEL_17;
          }
        }
      }
    }
  }
  else if (sub_100058654())
  {
    sub_100056E24((uint64_t)"Trying to send audio data to nonexistent connection - addr:%: length:%d", v39, v40, v41, v42, v43, v44, v45, a1);
    uint64_t v46 = sub_100050B4C(0x5Au);
    if (os_log_type_enabled(v46, OS_LOG_TYPE_ERROR)) {
LABEL_17:
    }
      sub_100744F6C();
  }
}

uint64_t sub_100264CDC(uint64_t a1)
{
  return *(unsigned __int16 *)(sub_1002647B8(a1) + 128);
}

uint64_t sub_100264CF8(uint64_t a1)
{
  if (sub_100058654())
  {
    sub_100056E24((uint64_t)"HandsfreeAoS_Disconnect - addr:%:", v2, v3, v4, v5, v6, v7, v8, a1);
    uint64_t v9 = sub_100050B4C(0x5Au);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 136446210;
      uint64_t v22 = sub_100050714();
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
    }
  }
  uint64_t v10 = sub_1002647B8(a1);
  uint64_t v11 = sub_1001E121C(*(unsigned __int16 *)(v10 + 128), 436);
  if (v11)
  {
    if (sub_100058654())
    {
      sub_100056E24((uint64_t)"HandsfreeAoS failed to disconnect, reason %!", v12, v13, v14, v15, v16, v17, v18, v11);
      uint64_t v19 = sub_100050B4C(0x5Au);
      if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR)) {
        sub_100744F6C();
      }
    }
  }
  return v11;
}

uint64_t sub_100264E20()
{
  if (sub_100058654())
  {
    sub_100056E24((uint64_t)"HandsfreeAoS_Deregister", v0, v1, v2, v3, v4, v5, v6, *(uint64_t *)v11);
    uint64_t v7 = sub_100050B4C(0x5Au);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)uint64_t v11 = 136446210;
      *(void *)&v11[4] = sub_100050714();
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, " %{public}s", v11, 0xCu);
    }
  }
  if (*(void *)qword_100A12038) {
    return 126;
  }
  uint64_t v9 = 1;
  while (v9 != 16)
  {
    if (*(void *)(qword_100A12038 + 8 * v9++))
    {
      if ((unint64_t)(v9 - 2) < 0xF) {
        return 126;
      }
      break;
    }
  }
  free((void *)qword_100A12038);
  uint64_t result = 0;
  qword_100A12038 = 0;
  return result;
}

uint64_t sub_100264F24(uint64_t a1)
{
  if (!qword_100A12038) {
    return 0;
  }
  uint64_t v1 = 0;
  while (1)
  {
    uint64_t v2 = *(void *)(qword_100A12038 + v1);
    if (v2)
    {
      uint64_t v3 = *(int **)(v2 + 8);
      int v4 = *v3;
      int v5 = *((unsigned __int16 *)v3 + 2);
      if (v4 == *(_DWORD *)a1 && v5 == *(unsigned __int16 *)(a1 + 4)) {
        break;
      }
    }
    v1 += 8;
    if (v1 == 128) {
      return 0;
    }
  }
  return *(unsigned __int16 *)(v2 + 128);
}

uint64_t sub_100264F78(uint64_t a1, _WORD *a2)
{
  if (sub_100058654())
  {
    sub_100056E24((uint64_t)"HandsfreeAoS_FastConnect_CreateChannel - addr:%:", v4, v5, v6, v7, v8, v9, v10, a1);
    uint64_t v11 = sub_100050B4C(0x5Au);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 136446210;
      *(void *)&uint8_t buf[4] = sub_100050714();
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
    }
  }
  if (sub_1002647B8(a1)) {
    return 126;
  }
  *(_OWORD *)long long buf = xmmword_1007BAF48;
  long long v23 = unk_1007BAF58;
  uint64_t v12 = sub_1001DEF88(4099, (uint64_t)buf, a1, (uint64_t)sub_100264894, (uint64_t)sub_100264988, (uint64_t)sub_100264A94, a2, (uint64_t)&unk_10099FE20);
  if (v12)
  {
    if (sub_100058654())
    {
      sub_100056E24((uint64_t)"HandsfreeAoS_FastConnect_CreateChannel error creating L2CAP channel, reason %!", v13, v14, v15, v16, v17, v18, v19, v12);
      uint64_t v20 = sub_100050B4C(0x5Au);
      if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR)) {
        sub_100744F6C();
      }
    }
    sub_10025B8C0();
  }
  *(_WORD *)(sub_100264804(a1) + 128) = *a2;
  return v12;
}

void sub_10026511C(uint64_t a1, unsigned int a2)
{
  if (sub_100058654())
  {
    sub_100056E24((uint64_t)"HandsfreeAoS_FastConnect_DestroyChannel", v4, v5, v6, v7, v8, v9, v10, v38);
    uint64_t v11 = sub_100050B4C(0x5Au);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 136446210;
      *(void *)&uint8_t buf[4] = sub_100050714();
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
    }
  }
  uint64_t v12 = sub_1002647B8(a1);
  if (v12)
  {
    sub_100264AC8(*(unsigned __int16 *)(v12 + 128));
  }
  else if (sub_100058654())
  {
    sub_100056E24((uint64_t)"HandsfreeAoS_FastConnect_DestroyChannel no connection exists for addr:%:", v13, v14, v15, v16, v17, v18, v19, a1);
    uint64_t v20 = sub_100050B4C(0x5Au);
    if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR)) {
      sub_100744F6C();
    }
  }
  *(void *)long long buf = 0;
  if (sub_1001DD56C(a2, (uint64_t *)buf) || !*(void *)buf)
  {
    if (sub_100058654())
    {
      sub_100056E24((uint64_t)"HandsfreeAoS_FastConnect_DestroyChannel failed to get channel, cid:%d", v22, v23, v24, v25, v26, v27, v28, a2);
      uint64_t v29 = sub_100050B4C(0x5Au);
      if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR)) {
LABEL_18:
      }
        sub_100744F6C();
    }
  }
  else
  {
    sub_1001DEC18(*(uint64_t *)buf);
    uint64_t v21 = sub_100197A30(a1);
    if (v21)
    {
      sub_100182088(v21);
      return;
    }
    if (sub_100058654())
    {
      sub_100056E24((uint64_t)"HandsfreeAoS_FastConnect_DestroyChannel NULL Handle", v30, v31, v32, v33, v34, v35, v36, v38);
      uint64_t v37 = sub_100050B4C(0x5Au);
      if (os_log_type_enabled(v37, OS_LOG_TYPE_ERROR)) {
        goto LABEL_18;
      }
    }
  }
}

void sub_100265300(uint64_t a1)
{
  v10[0] = 0;
  v10[1] = v10;
  v10[2] = 0x3032000000;
  v10[3] = sub_10004CF6C;
  char v10[4] = sub_10004CD88;
  id v11 = 0;
  v8[0] = 0;
  v8[1] = v8;
  void v8[2] = 0x2020000000;
  char v9 = 0;
  uint64_t v2 = dispatch_semaphore_create(0);
  uint64_t v3 = qword_100A1A040;
  if (os_log_type_enabled((os_log_t)qword_100A1A040, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Set LPM flags for White Glove Tests", buf, 2u);
  }
  uint64_t v4 = +[NFHardwareManager sharedHardwareManager];
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 3221225472;
  void v6[2] = sub_1002654B4;
  void v6[3] = &unk_10099FE58;
  v6[6] = a1;
  v6[7] = v2;
  char v6[4] = v10;
  v6[5] = v8;
  id v5 = [v4 startLPEMConfigSession:v6];

  dispatch_semaphore_wait(v2, 0xFFFFFFFFFFFFFFFFLL);
  _Block_object_dispose(v8, 8);
  _Block_object_dispose(v10, 8);
}

void sub_10026547C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);

  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v12 - 80), 8);

  _Unwind_Resume(a1);
}

void sub_1002654B4(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  if (v6)
  {
    objc_storeStrong((id *)(*(void *)(*(void *)(a1 + 32) + 8) + 40), a3);
    dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 56));
    uint64_t v7 = qword_100A1A040;
    if (os_log_type_enabled((os_log_t)qword_100A1A040, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 138412290;
      id v54 = v6;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "Start session error (error=%@)", buf, 0xCu);
    }
  }
  else
  {
    uint64_t v8 = (const std::string *)(*(void *)(a1 + 48) + 72);
    if (!std::string::compare(v8, "Alisha"))
    {
      uint64_t v20 = qword_100A1A040;
      if (os_log_type_enabled((os_log_t)qword_100A1A040, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "Set lpm1 flag", buf, 2u);
      }
      uint64_t v21 = *(void *)(*(void *)(a1 + 32) + 8);
      id v52 = *(id *)(v21 + 40);
      unsigned __int8 v22 = [v5 enableLPEMFeature:2 error:&v52];
      objc_storeStrong((id *)(v21 + 40), v52);
      *(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = v22;
      uint64_t v23 = qword_100A1A040;
      if (!*(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24)
        && os_log_type_enabled((os_log_t)qword_100A1A040, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 138412290;
        id v54 = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_ERROR, "Failed to set lpm1 flag with error %@", buf, 0xCu);
        uint64_t v23 = qword_100A1A040;
      }
      if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "Clear lpm2 flag", buf, 2u);
      }
      uint64_t v24 = *(void *)(*(void *)(a1 + 32) + 8);
      id v51 = *(id *)(v24 + 40);
      unsigned __int8 v25 = [v5 disableLPEMFeature:4 error:&v51];
      objc_storeStrong((id *)(v24 + 40), v51);
      *(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = v25;
      if (!*(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24))
      {
        uint64_t v26 = qword_100A1A040;
        if (os_log_type_enabled((os_log_t)qword_100A1A040, OS_LOG_TYPE_ERROR)) {
          sub_10074ABEC(v26, v27, v28, v29, v30, v31, v32, v33);
        }
      }
    }
    else if (!std::string::compare(v8, "FindMy"))
    {
      uint64_t v34 = qword_100A1A040;
      if (os_log_type_enabled((os_log_t)qword_100A1A040, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_DEFAULT, "Set lpm2 flags", buf, 2u);
      }
      uint64_t v35 = *(void *)(*(void *)(a1 + 32) + 8);
      id v50 = *(id *)(v35 + 40);
      unsigned __int8 v36 = [v5 enableLPEMFeature:4 error:&v50];
      objc_storeStrong((id *)(v35 + 40), v50);
      *(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = v36;
      uint64_t v37 = qword_100A1A040;
      if (!*(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24)
        && os_log_type_enabled((os_log_t)qword_100A1A040, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 138412290;
        id v54 = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_ERROR, "Failed to set lpm2 flag with error %@", buf, 0xCu);
        uint64_t v37 = qword_100A1A040;
      }
      if (os_log_type_enabled(v37, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_DEFAULT, "Clear lpm1 flag", buf, 2u);
      }
      uint64_t v38 = *(void *)(*(void *)(a1 + 32) + 8);
      id v49 = *(id *)(v38 + 40);
      unsigned __int8 v39 = [v5 disableLPEMFeature:2 error:&v49];
      objc_storeStrong((id *)(v38 + 40), v49);
      *(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = v39;
      if (!*(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24))
      {
        uint64_t v40 = qword_100A1A040;
        if (os_log_type_enabled((os_log_t)qword_100A1A040, OS_LOG_TYPE_ERROR)) {
          sub_10074AC5C(v40, v41, v42, v43, v44, v45, v46, v47);
        }
      }
    }
    else if (!std::string::compare(v8, "All"))
    {
      char v9 = qword_100A1A040;
      if (os_log_type_enabled((os_log_t)qword_100A1A040, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "Set All flags", buf, 2u);
      }
      uint64_t v10 = *(void *)(*(void *)(a1 + 32) + 8);
      obuint64_t j = *(id *)(v10 + 40);
      unsigned __int8 v11 = [v5 enableLPEMFeature:31 error:&obj];
      objc_storeStrong((id *)(v10 + 40), obj);
      *(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = v11;
      if (!*(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24))
      {
        uint64_t v12 = qword_100A1A040;
        if (os_log_type_enabled((os_log_t)qword_100A1A040, OS_LOG_TYPE_ERROR)) {
          sub_10074ACCC(v12, v13, v14, v15, v16, v17, v18, v19);
        }
      }
    }
    dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 56));
    [v5 endSessionWithCompletion:0];
  }
}

void sub_1002659B4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1002659CC(const std::string *a1)
{
  if (!std::string::compare(a1 + 4, "All"))
  {
    uint64_t v2 = qword_100A1A040;
    if (os_log_type_enabled((os_log_t)qword_100A1A040, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t v4 = 0;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Set All flags", v4, 2u);
    }
    uint64_t v3 = +[NFHardwareManager sharedHardwareManager];
    uint64_t v1 = [v3 enableLPEMFeature:31];

    if (v1 && os_log_type_enabled((os_log_t)qword_100A1A040, OS_LOG_TYPE_ERROR)) {
      sub_10074AD3C();
    }
  }
  else
  {
    uint64_t v1 = 0;
  }
}

void sub_100265AAC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t sub_100265ABC(uint64_t result)
{
  if (!*(void *)(result + 224)) {
    sub_1003733D8();
  }
  return result;
}

void sub_100265BB0(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 224);
  if (v1)
  {
    uint64_t v3 = qword_100A19F40;
    if (!os_log_type_enabled((os_log_t)qword_100A19F40, OS_LOG_TYPE_DEFAULT)
      || (uint64_t v4 = (*(uint64_t (**)(uint64_t))(*(void *)v1 + 16))(v1),
          int v5 = 136446210,
          uint64_t v6 = v4,
          _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Destroying %{public}s", (uint8_t *)&v5, 0xCu), (uint64_t v1 = *(void *)(a1 + 224)) != 0))
    {
      (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
    }
    *(void *)(a1 + 224) = 0;
  }
}

double sub_100265CC0(uint64_t a1)
{
  *(void *)a1 = off_10099FE88;
  *(void *)(a1 + 8) = off_10099FEF0;
  *(void *)(a1 + 16) = &off_10099FF20;
  *(unsigned char *)(a1 + 24) = 1;
  *(void *)(a1 + 25) = 0;
  *(_WORD *)(a1 + 33) = 0;
  *(void *)(a1 + 48) = 0;
  *(void *)(a1 + 56) = 0;
  *(void *)(a1 + 40) = 0;
  *(unsigned char *)(a1 + 64) = 0;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_OWORD *)(a1 + 88) = 0u;
  *(_OWORD *)(a1 + 104) = 0u;
  *(_OWORD *)(a1 + 120) = 0u;
  *(void *)(a1 + 136) = 0;
  *(void *)&double result = 33;
  *(_OWORD *)(a1 + 144) = xmmword_1007BAFA0;
  *(void *)(a1 + 176) = 0;
  *(void *)(a1 + 168) = 0;
  *(void *)(a1 + 160) = a1 + 168;
  *(_DWORD *)(a1 + 184) = 0;
  *(void *)(a1 + 192) = 0;
  *(void *)(a1 + 200) = 0;
  *(_DWORD *)(a1 + 216) = -1;
  *(void *)(a1 + 224) = 0;
  *(_DWORD *)(a1 + 232) = 96;
  return result;
}

void sub_100265D90(uint64_t a1)
{
  uint64_t v2 = sub_100017768();
  sub_10004191C(buf, "LPM");
  sub_10004191C(__p, "Enable");
  (*(void (**)(uint64_t, unsigned char *, void **, uint64_t))(*(void *)v2 + 72))(v2, buf, __p, a1 + 24);
  if (v25 < 0) {
    operator delete(__p[0]);
  }
  if (v29 < 0) {
    operator delete(*(void **)buf);
  }
  uint64_t v3 = sub_100017768();
  sub_10004191C(buf, "LPM");
  sub_10004191C(__p, "EnableHCI");
  (*(void (**)(uint64_t, unsigned char *, void **, uint64_t))(*(void *)v3 + 72))(v3, buf, __p, a1 + 26);
  if (v25 < 0) {
    operator delete(__p[0]);
  }
  if (v29 < 0) {
    operator delete(*(void **)buf);
  }
  sub_10003FB34();
  *(unsigned char *)(a1 + 25) = sub_10035213C();
  uint64_t v4 = sub_100017768();
  sub_10004191C(buf, "LPM");
  sub_10004191C(__p, "ConfigFlag");
  (*(void (**)(uint64_t, unsigned char *, void **, uint64_t))(*(void *)v4 + 128))(v4, buf, __p, a1 + 144);
  if (v25 < 0) {
    operator delete(__p[0]);
  }
  if (v29 < 0) {
    operator delete(*(void **)buf);
  }
  uint64_t v5 = sub_100017768();
  sub_10004191C(buf, "LPM");
  sub_10004191C(__p, "ScanWindow");
  (*(void (**)(uint64_t, unsigned char *, void **, uint64_t))(*(void *)v5 + 128))(v5, buf, __p, a1 + 152);
  if (v25 < 0) {
    operator delete(__p[0]);
  }
  if (v29 < 0) {
    operator delete(*(void **)buf);
  }
  uint64_t v6 = sub_100017768();
  sub_10004191C(buf, "LPM");
  sub_10004191C(__p, "ScanInterval");
  (*(void (**)(uint64_t, unsigned char *, void **, uint64_t))(*(void *)v6 + 128))(v6, buf, __p, a1 + 156);
  if (v25 < 0) {
    operator delete(__p[0]);
  }
  if (v29 < 0) {
    operator delete(*(void **)buf);
  }
  uint64_t v7 = sub_100017768();
  sub_10004191C(buf, "LPM");
  sub_10004191C(__p, "LoggingMode");
  (*(void (**)(uint64_t, unsigned char *, void **, uint64_t))(*(void *)v7 + 128))(v7, buf, __p, a1 + 148);
  if (v25 < 0) {
    operator delete(__p[0]);
  }
  if (v29 < 0) {
    operator delete(*(void **)buf);
  }
  uint64_t v8 = sub_100017768();
  sub_10004191C(buf, "LPM");
  sub_10004191C(__p, "ConfigFlagAdv");
  (*(void (**)(uint64_t, unsigned char *, void **, uint64_t))(*(void *)v8 + 128))(v8, buf, __p, a1 + 184);
  if (v25 < 0) {
    operator delete(__p[0]);
  }
  if (v29 < 0) {
    operator delete(*(void **)buf);
  }
  uint64_t v9 = sub_100017768();
  sub_10004191C(buf, "LPM");
  sub_10004191C(__p, "WhiteGloveMode");
  uint64_t v10 = (void *)(a1 + 72);
  (*(void (**)(uint64_t, unsigned char *, void **, uint64_t))(*(void *)v9 + 56))(v9, buf, __p, a1 + 72);
  if (v25 < 0) {
    operator delete(__p[0]);
  }
  if (v29 < 0) {
    operator delete(*(void **)buf);
  }
  uint64_t v11 = sub_100017768();
  sub_10004191C(buf, "LPM");
  sub_10004191C(__p, "FactoryMode");
  uint64_t v12 = (void *)(a1 + 96);
  (*(void (**)(uint64_t, unsigned char *, void **, uint64_t))(*(void *)v11 + 56))(v11, buf, __p, a1 + 96);
  if (v25 < 0) {
    operator delete(__p[0]);
  }
  if (v29 < 0) {
    operator delete(*(void **)buf);
  }
  uint64_t v13 = sub_100017768();
  sub_10004191C(buf, "LPM");
  sub_10004191C(__p, "LocalBDAddr");
  (*(void (**)(uint64_t, unsigned char *, void **, uint64_t))(*(void *)v13 + 56))(v13, buf, __p, a1 + 120);
  if (v25 < 0) {
    operator delete(__p[0]);
  }
  if (v29 < 0) {
    operator delete(*(void **)buf);
  }
  uint64_t v14 = sub_100017768();
  sub_10004191C(buf, "LPM");
  sub_10004191C(__p, "HowManyKeys");
  (*(void (**)(uint64_t, unsigned char *, void **, uint64_t))(*(void *)v14 + 128))(v14, buf, __p, a1 + 232);
  if (v25 < 0) {
    operator delete(__p[0]);
  }
  if (v29 < 0) {
    operator delete(*(void **)buf);
  }
  *(void *)(a1 + 208) = 0;
  if (!*(unsigned char *)(a1 + 24) || !*(unsigned char *)(a1 + 25)) {
    goto LABEL_71;
  }
  uint64_t v15 = qword_100A1A040;
  if (os_log_type_enabled((os_log_t)qword_100A1A040, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "LPM mode is supported and enabled.", buf, 2u);
    uint64_t v15 = qword_100A1A040;
  }
  if (os_log_type_enabled(v15, OS_LOG_TYPE_INFO))
  {
    int v16 = *(_DWORD *)(a1 + 144);
    int v17 = *(_DWORD *)(a1 + 152);
    int v18 = *(_DWORD *)(a1 + 156);
    *(_DWORD *)long long buf = 67109632;
    *(_DWORD *)&uint8_t buf[4] = v16;
    *(_WORD *)&buf[8] = 1024;
    *(_DWORD *)&buf[10] = v17;
    __int16 v27 = 1024;
    int v28 = v18;
    _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_INFO, "LPM ConfigFlag: %d ScanWindow: %d ScanInterval:%d", buf, 0x14u);
  }
  if (qword_1009F8070 != -1) {
    dispatch_once(&qword_1009F8070, &stru_10099FF70);
  }
  sub_10026B36C((uint64_t)off_1009F8068 + 64, a1);
  uint64_t v19 = sub_10003FFD4();
  sub_10026B638(v19 + 368, a1 + 8);
  uint64_t v20 = sub_1003705E4();
  (*(void (**)(uint64_t, uint64_t))(*(void *)v20 + 32))(v20, a1 + 29);
  if ((*(char *)(a1 + 95) & 0x80000000) == 0)
  {
    if (!*(unsigned char *)(a1 + 95)) {
      goto LABEL_62;
    }
LABEL_57:
    if (IsAppleInternalBuild())
    {
      *(_DWORD *)(a1 + 144) |= 0x10u;
      *(unsigned char *)(a1 + 27) = 1;
      uint64_t v21 = qword_100A1A040;
      if (os_log_type_enabled((os_log_t)qword_100A1A040, OS_LOG_TYPE_DEFAULT))
      {
        if (*(char *)(a1 + 95) < 0) {
          uint64_t v10 = (void *)*v10;
        }
        *(_DWORD *)long long buf = 136315138;
        *(void *)&uint8_t buf[4] = v10;
        _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "LPM White Glove mode: %s is enabled.", buf, 0xCu);
      }
    }
    goto LABEL_62;
  }
  if (*(void *)(a1 + 80)) {
    goto LABEL_57;
  }
LABEL_62:
  if (*(char *)(a1 + 119) < 0)
  {
    if (!*(void *)(a1 + 104)) {
      goto LABEL_71;
    }
  }
  else if (!*(unsigned char *)(a1 + 119))
  {
    goto LABEL_71;
  }
  if (IsAppleInternalBuild())
  {
    *(unsigned char *)(a1 + 28) = 1;
    unsigned __int8 v22 = qword_100A1A040;
    if (os_log_type_enabled((os_log_t)qword_100A1A040, OS_LOG_TYPE_DEFAULT))
    {
      if (*(char *)(a1 + 119) < 0) {
        uint64_t v12 = (void *)*v12;
      }
      *(_DWORD *)long long buf = 136315138;
      *(void *)&uint8_t buf[4] = v12;
      _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "LPM Factory Test mode: %s is enabled.", buf, 0xCu);
    }
  }
LABEL_71:
  if (notify_register_check("com.apple.bluetooth.low-power-mode", (int *)(a1 + 216))
    && os_log_type_enabled((os_log_t)qword_100A1A040, OS_LOG_TYPE_ERROR))
  {
    sub_10074ADA4();
  }
  uint64_t v23 = sub_10003FFD4();
  sub_10026B948(v23 + 288, a1 + 16);
}

void sub_1002665F4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  if (a21 < 0) {
    operator delete(a16);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100266680(uint64_t a1, unsigned int a2)
{
  if (!*(unsigned char *)(a1 + 24) || !*(unsigned char *)(a1 + 25))
  {
    if (os_log_type_enabled((os_log_t)qword_100A1A040, OS_LOG_TYPE_ERROR)) {
      sub_10074ADD8();
    }
    return 11;
  }
  uint64_t v4 = qword_100A1A040;
  if (os_log_type_enabled((os_log_t)qword_100A1A040, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Triggering LPM", buf, 2u);
  }
  io_registry_entry_t v5 = sub_10026BC58();
  io_object_t v6 = v5;
  if (!v5) {
    goto LABEL_21;
  }
  CFTypeRef v7 = IORegistryEntrySearchCFProperty(v5, "IOService", @"IOPMUBootLPMFWOK", kCFAllocatorDefault, 1u);
  uint64_t v8 = v7;
  if (!v7)
  {
LABEL_20:
    IOObjectRelease(v6);
LABEL_21:
    uint64_t v18 = qword_100A1A040;
    if (!os_log_type_enabled((os_log_t)qword_100A1A040, OS_LOG_TYPE_INFO)) {
      goto LABEL_24;
    }
    *(_WORD *)long long buf = 0;
    uint64_t v13 = "Failed to get IOPMUBootLPMFWOK flag";
    uint64_t v14 = v18;
    os_log_type_t v15 = OS_LOG_TYPE_INFO;
    goto LABEL_23;
  }
  int valuePtr = 0;
  CFTypeID v9 = CFGetTypeID(v7);
  if (v9 != CFNumberGetTypeID() || !CFNumberGetValue((CFNumberRef)v8, kCFNumberSInt32Type, &valuePtr))
  {
    CFRelease(v8);
    goto LABEL_20;
  }
  int v10 = valuePtr;
  uint64_t v11 = qword_100A1A040;
  if (os_log_type_enabled((os_log_t)qword_100A1A040, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)long long buf = 67109120;
    *(_DWORD *)&uint8_t buf[4] = v10 != 0;
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_INFO, "Get IOPMUBootLPMFWOK: %d", buf, 8u);
  }
  CFRelease(v8);
  IOObjectRelease(v6);
  if (v10)
  {
    if (!sub_1002675F4(0))
    {
      uint64_t v12 = qword_100A1A040;
      if (os_log_type_enabled((os_log_t)qword_100A1A040, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        uint64_t v13 = "BT_FW_OK flag is cleared.";
        uint64_t v14 = v12;
        os_log_type_t v15 = OS_LOG_TYPE_DEFAULT;
LABEL_23:
        _os_log_impl((void *)&_mh_execute_header, v14, v15, v13, buf, 2u);
      }
    }
  }
LABEL_24:
  if (*(unsigned char *)(a1 + 27))
  {
    sub_100265300(a1);
    if (!std::string::compare((const std::string *)(a1 + 72), "Alisha")
      || !std::string::compare((const std::string *)(a1 + 72), "All"))
    {
      uint64_t v19 = qword_100A1A040;
      if (os_log_type_enabled((os_log_t)qword_100A1A040, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "Fake alisha device", buf, 2u);
      }
      id v20 = [objc_alloc((Class)NSUUID) initWithUUIDString:@"4DA4C51F-95BF-4550-82B7-F1CC159E0DB7"];
      uint64_t v69 = 0;
      memset(&buf[8], 0, 32);
      *(void *)long long buf = (((unint64_t)*(unsigned __int8 *)(a1 + 29) << 40) | ((unint64_t)*(unsigned __int8 *)(a1 + 30) << 32) | ((unint64_t)*(unsigned __int8 *)(a1 + 31) << 24) | ((unint64_t)*(unsigned __int8 *)(a1 + 32) << 16) | ((unint64_t)*(unsigned __int8 *)(a1 + 33) << 8) | *(unsigned __int8 *)(a1 + 34))
                     + 1;
      if (qword_1009F7ED0 != -1) {
        dispatch_once(&qword_1009F7ED0, &stru_10099FF90);
      }
      sub_1000335D8(&buf[8], (const void *)(qword_1009F7EC8 + 184), 0x10uLL);
      if (qword_1009F7ED0 != -1) {
        dispatch_once(&qword_1009F7ED0, &stru_10099FF90);
      }
      sub_1000335D8(&buf[24], (const void *)(qword_1009F7EC8 + 184), 0x10uLL);
      LODWORD(v69) = 0;
      BYTE4(v69) = 1;
      sub_1000305AC(&valuePtr, v20);
      const unsigned __int8 *__attribute__((__org_typedef(uuid_t))) p_valuePtr = (const unsigned __int8 *)&valuePtr;
      uint64_t v21 = sub_10026C254((uint64_t **)(a1 + 160), (unsigned __int8 *)&valuePtr, (uint64_t)&unk_1007BE9D0, &p_valuePtr);
      *((void *)v21 + 6) = *(void *)buf;
      sub_100049EE0((uint64_t)(v21 + 56), (uint64_t)&buf[8]);
      sub_100049EE0((uint64_t)(v21 + 72), (uint64_t)&buf[24]);
      *((_DWORD *)v21 + 22) = v69;
      v21[92] = BYTE4(v69);
      *(void *)&unsigned char buf[24] = &off_100998428;
      if (*(void *)&buf[32]) {
        sub_1000368F4(*(atomic_uint **)&buf[32]);
      }
      *(void *)&buf[8] = &off_100998428;
      if (*(void *)&buf[16]) {
        sub_1000368F4(*(atomic_uint **)&buf[16]);
      }
    }
    if (!std::string::compare((const std::string *)(a1 + 72), "FindMy")
      || !std::string::compare((const std::string *)(a1 + 72), "All"))
    {
      unsigned __int8 v22 = qword_100A1A040;
      if (os_log_type_enabled((os_log_t)qword_100A1A040, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "Fake FindMy keys", buf, 2u);
      }
      uint64_t v23 = +[NSMutableArray array];
      if (*(_DWORD *)(a1 + 232))
      {
        unsigned int v24 = 0;
        do
        {
          memset(buf, 0, 37);
          arc4random_buf(buf, 0x25uLL);
          char v25 = +[NSData dataWithBytes:buf length:36];
          [v23 addObject:v25];

          ++v24;
        }
        while (v24 < *(_DWORD *)(a1 + 232));
      }
      objc_storeStrong((id *)(a1 + 192), v23);
      *(_DWORD *)(a1 + 208) = 15;
    }
  }
  if (*(unsigned char *)(a1 + 28))
  {
    uint64_t v26 = qword_100A1A040;
    if (os_log_type_enabled((os_log_t)qword_100A1A040, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "LPM Factory Test mode: set flags.", buf, 2u);
    }
    sub_1002659CC((const std::string *)a1);
  }
  uint64_t v27 = sub_10003FB34();
  (*(void (**)(uint64_t, uint64_t, void, uint64_t))(*(void *)v27 + 2904))(v27, 20, 0, 1);
  BOOL v62 = 0;
  sub_100267804(1, &v62);
  BOOL v61 = 0;
  sub_100267804(0, &v61);
  if (a2 != 1 || !v62)
  {
    if (!v61)
    {
      if (!v62)
      {
        if (os_log_type_enabled((os_log_t)qword_100A1A040, OS_LOG_TYPE_ERROR)) {
          sub_10074B228();
        }
        return 1400;
      }
      goto LABEL_62;
    }
    goto LABEL_55;
  }
  *(unsigned char *)(a1 + 64) |= 1u;
  if (v61)
  {
LABEL_55:
    if (_os_feature_enabled_impl()) {
      *(unsigned char *)(a1 + 64) |= 2u;
    }
    if ((_os_feature_enabled_impl() & 1) == 0)
    {
      if (os_log_type_enabled((os_log_t)qword_100A1A040, OS_LOG_TYPE_ERROR)) {
        sub_10074B1F4();
      }
      return 1405;
    }
  }
LABEL_62:
  if (*(unsigned char *)(a1 + 64))
  {
    if ((*(unsigned char *)(a1 + 64) & 1) != 0 && !*(void *)(a1 + 176) && (*(unsigned char *)(a1 + 144) & 0x10) != 0)
    {
      if (os_log_type_enabled((os_log_t)qword_100A1A040, OS_LOG_TYPE_ERROR)) {
        sub_10074B1C0();
      }
      return 1401;
    }
    else
    {
      int v28 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_timer, 0, 0, 0);
      dispatch_time_t v29 = dispatch_time(0, 4000000000);
      dispatch_source_set_timer(v28, v29, 0xFFFFFFFFFFFFFFFFLL, 0x3B9ACA00uLL);
      dispatch_source_set_event_handler(v28, &stru_10099FF28);
      dispatch_resume(v28);
      if (qword_1009F8748 != -1) {
        dispatch_once(&qword_1009F8748, &stru_10099FFB0);
      }
      uint64_t v16 = sub_1004B9F48((uint64_t)off_1009F8740);
      dispatch_source_cancel(v28);
      dispatch_release(v28);
      if (v16)
      {
        uint64_t v30 = qword_100A1A040;
        if (os_log_type_enabled((os_log_t)qword_100A1A040, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)long long buf = 67109120;
          *(_DWORD *)&uint8_t buf[4] = v16;
          _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_DEFAULT, "PowerManager::getInstance()->powerHostlessMode failed with error %d", buf, 8u);
        }
        byte_100A19940 = 0;
        return v16;
      }
      int v31 = *(_DWORD *)(a1 + 216);
      uint64_t v32 = qword_100A1A040;
      if (v31 == -1)
      {
        if (os_log_type_enabled((os_log_t)qword_100A1A040, OS_LOG_TYPE_ERROR)) {
          sub_10074B048(v32, v33, v34, v35, v36, v37, v38, v39);
        }
      }
      else
      {
        if (os_log_type_enabled((os_log_t)qword_100A1A040, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)long long buf = 136315138;
          *(void *)&uint8_t buf[4] = "com.apple.bluetooth.low-power-mode";
          _os_log_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_DEFAULT, "Notifying %s", buf, 0xCu);
          int v31 = *(_DWORD *)(a1 + 216);
        }
        if (notify_set_state(v31, a2))
        {
          if (os_log_type_enabled((os_log_t)qword_100A1A040, OS_LOG_TYPE_ERROR)) {
            sub_10074B140();
          }
        }
        else if (notify_post("com.apple.bluetooth.low-power-mode") {
               && os_log_type_enabled((os_log_t)qword_100A1A040, OS_LOG_TYPE_ERROR))
        }
        {
          sub_10074B0C0();
        }
      }
      double Current = CFAbsoluteTimeGetCurrent();
      if ((*(unsigned char *)(a1 + 64) & 2) != 0)
      {
        uint64_t v41 = qword_100A1A040;
        if (os_log_type_enabled((os_log_t)qword_100A1A040, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)long long buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v41, OS_LOG_TYPE_DEFAULT, "Waiting for offline ADV data", buf, 2u);
        }
        *(void *)long long buf = 0;
        *(void *)&buf[8] = 0;
        sub_10003AED0((uint64_t)buf, (uint64_t)&unk_100A19900);
        if (byte_100A19940 && !*(unsigned char *)(a1 + 27) && !*(unsigned char *)(a1 + 28))
        {
          uint64_t v42 = qword_100A1A040;
          if (os_log_type_enabled((os_log_t)qword_100A1A040, OS_LOG_TYPE_DEFAULT))
          {
            LOWORD(valuePtr) = 0;
            _os_log_impl((void *)&_mh_execute_header, v42, OS_LOG_TYPE_DEFAULT, "fOfflineADVDataPending = true", (uint8_t *)&valuePtr, 2u);
          }
          if (!sub_10001BCA8(&stru_100A198D0, (pthread_mutex_t **)buf, 0x1F40uLL))
          {
            if (os_log_type_enabled((os_log_t)qword_100A1A040, OS_LOG_TYPE_ERROR)) {
              sub_10074B014();
            }
            sub_10003AFB4((uint64_t)buf);
            return 1403;
          }
        }
        sub_10003AFE8((uint64_t)buf);
        uint64_t v43 = qword_100A1A040;
        if (os_log_type_enabled((os_log_t)qword_100A1A040, OS_LOG_TYPE_DEFAULT))
        {
          unsigned __int16 v44 = (unsigned __int16)[*(id *)(a1 + 192) count];
          unsigned __int16 v45 = (unsigned __int16)[*(id *)(a1 + 200) count];
          int valuePtr = 67109376;
          unsigned int v65 = v44;
          __int16 v66 = 1024;
          int v67 = v45;
          _os_log_impl((void *)&_mh_execute_header, v43, OS_LOG_TYPE_DEFAULT, "Done waiting, count set1Data:%d, count set2Data:%d", (uint8_t *)&valuePtr, 0xEu);
        }
        sub_10003AFB4((uint64_t)buf);
      }
      double v46 = CFAbsoluteTimeGetCurrent();
      __int16 v60 = 0;
      __int16 v59 = 0;
      char v58 = 0;
      LODWORD(p_valuePtr) = 0;
      uint64_t v47 = sub_10003FFD4();
      (*(void (**)(uint64_t, char *, __int16 *, char *, __int16 *, char *, const unsigned __int8 *__attribute__((__org_typedef(uuid_t))) *))(*(void *)v47 + 48))(v47, (char *)&v60 + 1, &v60, (char *)&v59 + 1, &v59, &v58, &p_valuePtr);
      double v48 = (v46 - Current) * 1000.0;
      if (v48 < 8000.0)
      {
        unint64_t v49 = 8000 - v48;
        id v50 = qword_100A1A040;
        if (os_log_type_enabled((os_log_t)qword_100A1A040, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)long long buf = 67109376;
          *(_DWORD *)&uint8_t buf[4] = v59;
          *(_WORD *)&buf[8] = 1024;
          *(_DWORD *)&buf[10] = v49;
          _os_log_impl((void *)&_mh_execute_header, v50, OS_LOG_TYPE_DEFAULT, "wifiIsOn:%d duration:%u", buf, 0xEu);
        }
        if ((_BYTE)v59)
        {
          *(void *)long long buf = 0;
          *(void *)&buf[8] = 0;
          sub_10003AED0((uint64_t)buf, (uint64_t)&unk_100A19978);
          byte_100A199B8 = 1;
          id v51 = qword_100A1A040;
          if (os_log_type_enabled((os_log_t)qword_100A1A040, OS_LOG_TYPE_DEFAULT))
          {
            LOWORD(valuePtr) = 0;
            _os_log_impl((void *)&_mh_execute_header, v51, OS_LOG_TYPE_DEFAULT, "fWaitForWifiOffPending = true", (uint8_t *)&valuePtr, 2u);
          }
          if (!sub_10001BCA8(&stru_100A19948, (pthread_mutex_t **)buf, v49)
            && os_log_type_enabled((os_log_t)qword_100A1A040, OS_LOG_TYPE_ERROR))
          {
            sub_10074AFE0();
          }
          sub_10003AFB4((uint64_t)buf);
        }
      }
      if (*(unsigned char *)(a1 + 28))
      {
        sub_1002679C4((unsigned char *)a1);
LABEL_116:
        *(void *)long long buf = 0;
        *(void *)&buf[8] = 0;
        sub_10003AED0((uint64_t)buf, (uint64_t)&unk_100A199C0);
        id v52 = qword_100A1A040;
        if (os_log_type_enabled((os_log_t)qword_100A1A040, OS_LOG_TYPE_DEFAULT))
        {
          int valuePtr = 67109120;
          unsigned int v65 = byte_100A199B9;
          _os_log_impl((void *)&_mh_execute_header, v52, OS_LOG_TYPE_DEFAULT, "fIsSystemSleep = %d", (uint8_t *)&valuePtr, 8u);
        }
        if (byte_100A199B9)
        {
          unsigned int v53 = 1000 * (CFAbsoluteTimeGetCurrent() - Current);
          id v54 = qword_100A1A040;
          if (os_log_type_enabled((os_log_t)qword_100A1A040, OS_LOG_TYPE_DEFAULT))
          {
            int valuePtr = 67109120;
            unsigned int v65 = v53;
            _os_log_impl((void *)&_mh_execute_header, v54, OS_LOG_TYPE_DEFAULT, "fIsSystemSleep = true, lpmEntryTimeUsedMs=%u", (uint8_t *)&valuePtr, 8u);
          }
          if (v53 >> 6 <= 0x7C
            && !sub_10001BCA8(&stru_100A19A00, (pthread_mutex_t **)buf, 8000 - v53)
            && os_log_type_enabled((os_log_t)qword_100A1A040, OS_LOG_TYPE_ERROR))
          {
            sub_10074AF44();
          }
        }
        sub_10003AFE8((uint64_t)buf);
        uint64_t v16 = sub_100267E38(a1);
        if (v16)
        {
          if (os_log_type_enabled((os_log_t)qword_100A1A040, OS_LOG_TYPE_ERROR)) {
            sub_10074AEDC();
          }
        }
        else
        {
          if (*(unsigned char *)(a1 + 26) && ((*(unsigned char *)(a1 + 144) & 1) == 0 || (*(unsigned char *)(a1 + 184) & 8) != 0))
          {
            int v55 = qword_100A1A040;
            if (os_log_type_enabled((os_log_t)qword_100A1A040, OS_LOG_TYPE_INFO))
            {
              LOWORD(valuePtr) = 0;
              _os_log_impl((void *)&_mh_execute_header, v55, OS_LOG_TYPE_INFO, "Enable sniff mode only", (uint8_t *)&valuePtr, 2u);
            }
            if (!sub_10016AB24() && os_log_type_enabled((os_log_t)qword_100A1A040, OS_LOG_TYPE_ERROR)) {
              sub_10074AEA8();
            }
            if ((sub_100115A40() & 1) == 0 && os_log_type_enabled((os_log_t)qword_100A1A040, OS_LOG_TYPE_ERROR)) {
              sub_10074AE74();
            }
          }
          int v56 = sub_1002675F4(1);
          uint64_t v57 = qword_100A1A040;
          if (v56)
          {
            if (os_log_type_enabled((os_log_t)qword_100A1A040, OS_LOG_TYPE_ERROR)) {
              sub_10074AE40();
            }
            uint64_t v16 = 1;
          }
          else
          {
            if (os_log_type_enabled((os_log_t)qword_100A1A040, OS_LOG_TYPE_DEFAULT))
            {
              LOWORD(valuePtr) = 0;
              _os_log_impl((void *)&_mh_execute_header, v57, OS_LOG_TYPE_DEFAULT, "BT_FW_OK flag is set. Entering LPM...", (uint8_t *)&valuePtr, 2u);
            }
            if (*(unsigned char *)(a1 + 27)) {
              sub_100265300(a1);
            }
            if (*(unsigned char *)(a1 + 28)) {
              sub_1002659CC((const std::string *)a1);
            }
            uint64_t v16 = 0;
          }
        }
        sub_10003AFB4((uint64_t)buf);
        return v16;
      }
      uint64_t v16 = sub_100267B00(a1);
      if (!v16) {
        goto LABEL_116;
      }
      if (os_log_type_enabled((os_log_t)qword_100A1A040, OS_LOG_TYPE_ERROR)) {
        sub_10074AF78();
      }
    }
  }
  else
  {
    if (os_log_type_enabled((os_log_t)qword_100A1A040, OS_LOG_TYPE_ERROR)) {
      sub_10074AE0C();
    }
    return 1402;
  }
  return v16;
}

void sub_100267564(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  sub_10003AFB4((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1002675F4(int a1)
{
  kern_return_t v6;
  NSObject *v8;
  int valuePtr;
  uint8_t buf[4];
  int v11;

  io_object_t v2 = sub_10026BC58();
  if (!v2)
  {
LABEL_5:
    if (os_log_type_enabled((os_log_t)qword_100A1A040, OS_LOG_TYPE_ERROR)) {
      sub_10074B25C();
    }
    return 1;
  }
  io_object_t v3 = v2;
  int valuePtr = a1;
  CFNumberRef v4 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt32Type, &valuePtr);
  if (!v4 || (CFNumberRef v5 = v4, v6 = IORegistryEntrySetCFProperty(v3, @"IOPMUBootLPMFWOK", v4), CFRelease(v5), v6))
  {
    IOObjectRelease(v3);
    goto LABEL_5;
  }
  uint64_t v8 = qword_100A1A040;
  if (os_log_type_enabled((os_log_t)qword_100A1A040, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)long long buf = 67109120;
    uint64_t v11 = a1;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_INFO, "Set IOPMUBootLPMFWOK to %d", buf, 8u);
  }
  IOObjectRelease(v3);
  return 0;
}

uint64_t sub_100267738(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = *(void *)a2;
  sub_100049EE0(a1 + 8, a2 + 8);
  sub_100049EE0(a1 + 24, a2 + 24);
  char v4 = *(unsigned char *)(a2 + 44);
  *(_DWORD *)(a1 + 40) = *(_DWORD *)(a2 + 40);
  *(unsigned char *)(a1 + 44) = v4;
  return a1;
}

void *sub_100267788(void *a1)
{
  a1[3] = &off_100998428;
  io_object_t v2 = (atomic_uint *)a1[4];
  if (v2) {
    sub_1000368F4(v2);
  }
  a1[1] = &off_100998428;
  io_object_t v3 = (atomic_uint *)a1[2];
  if (v3) {
    sub_1000368F4(v3);
  }
  return a1;
}

void sub_100267804(uint64_t a1, BOOL *a2)
{
  int valuePtr = 0;
  io_registry_entry_t v4 = sub_10026BC58();
  if (v4)
  {
    io_object_t v5 = v4;
    CFDictionaryRef v6 = (const __CFDictionary *)IORegistryEntrySearchCFProperty(v4, "IOService", @"IOPMUBootLPMCtrl", kCFAllocatorDefault, 1u);
    if (v6)
    {
      CFDictionaryRef v7 = v6;
      CFTypeID v8 = CFGetTypeID(v6);
      if (v8 == CFDictionaryGetTypeID())
      {
        CFTypeID v9 = a1 ? @"lpm1" : @"lpm2";
        CFNumberRef Value = (const __CFNumber *)CFDictionaryGetValue(v7, v9);
        if (Value)
        {
          CFNumberGetValue(Value, kCFNumberSInt32Type, &valuePtr);
          *a2 = valuePtr != 0;
          CFRelease(v7);
          IOObjectRelease(v5);
          return;
        }
      }
      CFRelease(v7);
    }
    IOObjectRelease(v5);
  }
  uint64_t v11 = qword_100A1A040;
  if (os_log_type_enabled((os_log_t)qword_100A1A040, OS_LOG_TYPE_ERROR)) {
    sub_10074B290(a1, v11, v12, v13, v14, v15, v16, v17);
  }
}

void sub_100267920(id a1)
{
  uint64_t v1 = qword_100A1A040;
  if (os_log_type_enabled((os_log_t)qword_100A1A040, OS_LOG_TYPE_ERROR)) {
    sub_10074B314(v1, v2, v3, v4, v5, v6, v7, v8);
  }
  uint64_t v9 = sub_100017768();
  sub_10004191C(__p, "LPM stack shutdown stuck");
  sub_1005C9A14(v9, (uint64_t *)__p, 3172327085);
  if (v11 < 0) {
    operator delete(__p[0]);
  }
}

void sub_1002679A8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1002679C4(unsigned char *a1)
{
  sub_100268E04((uint64_t)a1, 1);
  sub_100268E04((uint64_t)a1, 0);
  if ((*(_DWORD *)(sub_10003FB34() + 712) & 0xFFFFFFFC) == 0x14) {
    int v2 = 3;
  }
  else {
    int v2 = 2;
  }
  sub_100268E04((uint64_t)a1, v2);
  sub_100268E04((uint64_t)a1, 4);
  sub_100268E04((uint64_t)a1, 5);
  sub_100268E04((uint64_t)a1, 6);
  sub_100268E04((uint64_t)a1, 7);
  sub_100268E04((uint64_t)a1, 16);
  sub_100268E04((uint64_t)a1, 18);
  sub_100268E04((uint64_t)a1, 19);
  sub_100268E04((uint64_t)a1, 20);
  sub_100268E04((uint64_t)a1, 21);
  sub_100268E04((uint64_t)a1, 14);
  sub_100268E04((uint64_t)a1, 22);
  if (a1[26] && ((a1[144] & 1) == 0 || (a1[184] & 8) != 0)) {
    sub_100268E04((uint64_t)a1, 15);
  }
  return 0;
}

uint64_t sub_100267B00(uint64_t a1)
{
  sub_100268E04(a1, 1);
  sub_100268E04(a1, 0);
  int v2 = *(_DWORD *)(sub_10003FB34() + 712);
  memset(&v13, 0, sizeof(v13));
  uint64_t v3 = sub_10003FB34();
  (*(void (**)(std::string *__return_ptr))(*(void *)v3 + 16))(&v13);
  BOOL v4 = (v2 & 0xFFFFFFFE) == 0x14 || v2 == 23;
  if (v4 || v2 == 22 && std::string::compare(&v13, "C2") <= 0) {
    int v5 = 3;
  }
  else {
    int v5 = 2;
  }
  sub_100268E04(a1, v5);
  sub_100268E04(a1, 4);
  sub_100268E04(a1, 5);
  sub_100268E04(a1, 6);
  sub_100268E04(a1, 7);
  if (*(unsigned char *)(a1 + 64))
  {
    sub_100268E04(a1, 8);
    uint64_t v6 = *(void **)(a1 + 160);
    if (v6 != (void *)(a1 + 168))
    {
      do
      {
        long long v16 = 0u;
        long long v17 = 0u;
        long long v14 = 0u;
        long long v15 = 0u;
        sub_10026BE44((uint64_t)&v14, (uint64_t)(v6 + 4));
        sub_100268E04(a1, 9);
        *((void *)&v16 + 1) = &off_100998428;
        if ((void)v17) {
          sub_1000368F4((atomic_uint *)v17);
        }
        *((void *)&v15 + 1) = &off_100998428;
        if ((void)v16) {
          sub_1000368F4((atomic_uint *)v16);
        }
        uint64_t v7 = (void *)v6[1];
        if (v7)
        {
          do
          {
            uint64_t v8 = v7;
            uint64_t v7 = (void *)*v7;
          }
          while (v7);
        }
        else
        {
          do
          {
            uint64_t v8 = (void *)v6[2];
            BOOL v4 = *v8 == (void)v6;
            uint64_t v6 = v8;
          }
          while (!v4);
        }
        uint64_t v6 = v8;
      }
      while (v8 != (void *)(a1 + 168));
    }
  }
  if ((*(unsigned char *)(a1 + 64) & 2) != 0)
  {
    sub_100268E04(a1, 11);
    while (1)
    {
      unint64_t v9 = (unsigned __int16)word_100A19942;
      int v10 = (char *)[*(id *)(a1 + 192) count];
      if (&v10[(void)[*(id *)(a1 + 200) count]] <= (char *)v9) {
        break;
      }
      uint64_t v11 = sub_100268E04(a1, 12);
      if (v11) {
        goto LABEL_33;
      }
    }
    sub_100268E04(a1, 13);
  }
  sub_100268E04(a1, 14);
  sub_100268E04(a1, 10);
  if (*(unsigned char *)(a1 + 26) && ((*(unsigned char *)(a1 + 144) & 1) == 0 || (*(unsigned char *)(a1 + 184) & 8) != 0)) {
    sub_100268E04(a1, 15);
  }
  uint64_t v11 = 0;
LABEL_33:
  if (SHIBYTE(v13.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v13.__r_.__value_.__l.__data_);
  }
  return v11;
}

void sub_100267DF8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, char a16)
{
}

uint64_t sub_100267E38(uint64_t a1)
{
  uint64_t v3 = qword_100A1A040;
  if (os_log_type_enabled((os_log_t)qword_100A1A040, OS_LOG_TYPE_INFO))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_INFO, "Initialization for hostless mode", buf, 2u);
  }
  uint64_t v4 = *(void *)(a1 + 40);
  uint64_t v5 = *(void *)(a1 + 48);
  if (v4 != v5)
  {
    while (1)
    {
      uint64_t v38 = 0;
      memset(v37, 0, sizeof(v37));
      LODWORD(v37[0]) = *(_DWORD *)v4;
      if (*(char *)(v4 + 31) < 0)
      {
        sub_10003B098(&v37[1], *(void **)(v4 + 8), *(void *)(v4 + 16));
      }
      else
      {
        long long v6 = *(_OWORD *)(v4 + 8);
        v37[3] = *(void **)(v4 + 24);
        *(_OWORD *)&v37[1] = v6;
      }
      uint64_t v38 = *(uint64_t (**)(void **))(v4 + 32);
      uint64_t v7 = (void *)HIBYTE(v37[3]);
      if (SHIBYTE(v37[3]) < 0) {
        uint64_t v7 = v37[2];
      }
      if (!v7)
      {
LABEL_52:
        char v11 = 1;
        goto LABEL_53;
      }
      bzero(buf, 0x800uLL);
      uint64_t v8 = sub_1003705E4();
      if (SHIBYTE(v37[3]) >= 0) {
        unint64_t v9 = &v37[1];
      }
      else {
        unint64_t v9 = (void **)v37[1];
      }
      uint64_t v10 = (*(uint64_t (**)(uint64_t, void **, uint8_t *, uint64_t))(*(void *)v8 + 128))(v8, v9, buf, 2048);
      if (v10)
      {
        char v11 = 0;
        uint64_t v1 = v10;
        goto LABEL_53;
      }
      __p = 0;
      uint64_t v35 = 0;
      uint64_t v36 = 0;
      int v12 = strlen((const char *)buf);
      int v13 = v12;
      if (v12)
      {
        if (v12 <= 2048)
        {
          if (v12 >= 4)
          {
            uint64_t v14 = 0;
            while (1)
            {
              char v41 = 0;
              if (!sscanf((const char *)&buf[v14], "0x%hhx", &v41)) {
                break;
              }
              long long v15 = v35;
              if (v35 >= v36)
              {
                unint64_t v17 = (unint64_t)__p;
                uint64_t v18 = v35 - (unsigned char *)__p;
                uint64_t v19 = v35 - (unsigned char *)__p + 1;
                if (v19 < 0) {
                  abort();
                }
                unint64_t v20 = v36 - (unsigned char *)__p;
                if (2 * (v36 - (unsigned char *)__p) > (unint64_t)v19) {
                  uint64_t v19 = 2 * v20;
                }
                if (v20 >= 0x3FFFFFFFFFFFFFFFLL) {
                  size_t v21 = 0x7FFFFFFFFFFFFFFFLL;
                }
                else {
                  size_t v21 = v19;
                }
                if (v21) {
                  unsigned __int8 v22 = (char *)operator new(v21);
                }
                else {
                  unsigned __int8 v22 = 0;
                }
                uint64_t v23 = &v22[v18];
                unsigned int v24 = &v22[v18];
                *unsigned int v24 = v41;
                long long v16 = v24 + 1;
                if (v15 != (char *)v17)
                {
                  char v25 = &v15[~v17];
                  do
                  {
                    char v26 = *--v15;
                    (v25--)[(void)v22] = v26;
                  }
                  while (v15 != (char *)v17);
                  long long v15 = (char *)__p;
                  uint64_t v23 = v22;
                }
                __p = v23;
                uint64_t v35 = v16;
                uint64_t v36 = &v22[v21];
                if (v15) {
                  operator delete(v15);
                }
              }
              else
              {
                *uint64_t v35 = v41;
                long long v16 = v15 + 1;
              }
              uint64_t v35 = v16;
              v14 += 5;
              BOOL v27 = v13 <= 8;
              v13 -= 5;
              if (v27) {
                goto LABEL_44;
              }
            }
            if (os_log_type_enabled((os_log_t)qword_100A1A040, OS_LOG_TYPE_ERROR)) {
              sub_10074B3E0(&v39, v40);
            }
          }
        }
        else if (os_log_type_enabled((os_log_t)qword_100A1A040, OS_LOG_TYPE_ERROR))
        {
          sub_10074B3B4(&v42, v43);
        }
      }
LABEL_44:
      if (!v38) {
        goto LABEL_48;
      }
      int v28 = (char *)__p;
      if (v35 != __p) {
        break;
      }
      if (os_log_type_enabled((os_log_t)qword_100A1A040, OS_LOG_TYPE_ERROR))
      {
        sub_10074B388(&v32, v33);
        char v30 = 0;
        uint64_t v1 = 112;
        goto LABEL_49;
      }
      char v30 = 0;
      uint64_t v1 = 112;
      if (v28) {
        goto LABEL_50;
      }
LABEL_51:
      if (v30) {
        goto LABEL_52;
      }
      char v11 = 0;
LABEL_53:
      if (SHIBYTE(v37[3]) < 0) {
        operator delete(v37[1]);
      }
      if ((v11 & 1) == 0) {
        return v1;
      }
      v4 += 40;
      if (v4 == v5) {
        return 0;
      }
    }
    uint64_t v29 = v38(&__p);
    if (v29)
    {
      char v30 = 0;
      uint64_t v1 = v29;
    }
    else
    {
LABEL_48:
      char v30 = 1;
    }
LABEL_49:
    int v28 = (char *)__p;
    if (!__p) {
      goto LABEL_51;
    }
LABEL_50:
    uint64_t v35 = v28;
    operator delete(v28);
    goto LABEL_51;
  }
  return 0;
}

void sub_100268234(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, uint64_t a16, uint64_t a17, void *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  if (__p) {
    operator delete(__p);
  }
  if (a23 < 0) {
    operator delete(a18);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100268278()
{
  uint64_t v0 = qword_100A1A040;
  if (os_log_type_enabled((os_log_t)qword_100A1A040, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v2[0]) = 0;
    _os_log_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_DEFAULT, "LPMManager::powerManagementEventSystemWillSleep", (uint8_t *)v2, 2u);
  }
  v2[0] = 0;
  v2[1] = 0;
  sub_10003AED0((uint64_t)v2, (uint64_t)&unk_100A199C0);
  byte_100A199B9 = 1;
  return sub_10003AFB4((uint64_t)v2);
}

uint64_t sub_10026830C()
{
  uint64_t v0 = qword_100A1A040;
  if (os_log_type_enabled((os_log_t)qword_100A1A040, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v2[0]) = 0;
    _os_log_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_DEFAULT, "LPMManager::powerManagementEventSystemWokeUp", (uint8_t *)v2, 2u);
  }
  v2[0] = 0;
  v2[1] = 0;
  sub_10003AED0((uint64_t)v2, (uint64_t)&unk_100A199C0);
  byte_100A199B9 = 0;
  sub_100026264(&stru_100A19A00);
  return sub_10003AFB4((uint64_t)v2);
}

void sub_1002683A4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_1002683BC(uint64_t a1)
{
  int v2 = qword_100A1A040;
  if (os_log_type_enabled((os_log_t)qword_100A1A040, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "LPMManager::powerManagementEventSystemWillShutDown", buf, 2u);
  }
  if (*(unsigned char *)(a1 + 24) && *(unsigned char *)(a1 + 25))
  {
    uint64_t v3 = qword_100A1A040;
    if (os_log_type_enabled((os_log_t)qword_100A1A040, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t v5 = 0;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "LPMManager::powerManagementEventSystemWillShutDown fOfflineADVDataPending = true", v5, 2u);
    }
    byte_100A19940 = 1;
  }
  return 1;
}

uint64_t sub_10026848C(uint64_t a1)
{
  return 1;
}

uint64_t sub_1002684AC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v10[0] = a2;
  v10[1] = a3;
  uint64_t v3 = qword_100A1A040;
  if (os_log_type_enabled((os_log_t)qword_100A1A040, OS_LOG_TYPE_DEFAULT))
  {
    sub_10001A260((uint64_t)v10);
    uint64_t v4 = v9 >= 0 ? __p : (void **)__p[0];
    *(_DWORD *)long long buf = 136315138;
    int v12 = v4;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "wifiStateChanged:%s", buf, 0xCu);
    if (v9 < 0) {
      operator delete(__p[0]);
    }
  }
  __p[0] = 0;
  __p[1] = 0;
  sub_10003AED0((uint64_t)__p, (uint64_t)&unk_100A19978);
  if (byte_100A199B8) {
    BOOL v5 = LOBYTE(v10[0]) == 0;
  }
  else {
    BOOL v5 = 0;
  }
  if (v5)
  {
    long long v6 = qword_100A1A040;
    if (os_log_type_enabled((os_log_t)qword_100A1A040, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "wifiStateChanged and wifi power is off", buf, 2u);
    }
    byte_100A199B8 = 0;
    sub_100026264(&stru_100A19948);
  }
  return sub_10003AFB4((uint64_t)__p);
}

void sub_100268608(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_10003AFB4((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_100268628()
{
  uint64_t v0 = qword_100A1A040;
  if (os_log_type_enabled((os_log_t)qword_100A1A040, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_DEFAULT, "LPMManager::getLPEMBluetoothLog", buf, 2u);
  }
  v13[0] = 0;
  v13[1] = v13;
  uint64_t v13[2] = 0x3032000000;
  v13[3] = sub_10004CF6C;
  v13[4] = sub_10004CD88;
  id v14 = 0;
  *(void *)long long buf = 0;
  BOOL v5 = buf;
  uint64_t v6 = 0x4812000000;
  uint64_t v7 = sub_1002687E8;
  uint64_t v8 = nullsub_111;
  char v9 = "";
  uint64_t v10 = 0;
  uint64_t v11 = 0;
  int v12 = 0;
  uint64_t v1 = +[NFHardwareManager sharedHardwareManager];
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 3221225472;
  v3[2] = sub_100268800;
  v3[3] = &unk_10099FF50;
  v3[4] = v13;
  v3[5] = buf;
  id v2 = [v1 startLPEMConfigSession:v3];

  _Block_object_dispose(buf, 8);
  _Block_object_dispose(v13, 8);
}

void sub_1002687B0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);

  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v8 - 80), 8);

  _Unwind_Resume(a1);
}

__n128 sub_1002687E8(__n128 *a1, __n128 *a2)
{
  __n128 result = a2[3];
  a1[4].n128_u32[0] = a2[4].n128_u32[0];
  a1[3] = result;
  return result;
}

void sub_100268800(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  uint64_t v7 = *(void *)(*(void *)(a1 + 32) + 8);
  uint64_t v8 = (id *)(v7 + 40);
  if (v6)
  {
    objc_storeStrong((id *)(v7 + 40), a3);
    char v9 = qword_100A1A040;
    if (os_log_type_enabled((os_log_t)qword_100A1A040, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 138412290;
      id v23 = v6;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "Start session error (error=%@)", buf, 0xCu);
    }
    *(_DWORD *)(*(void *)(*(void *)(a1 + 40) + 8) + 48) = [*(id *)(*(void *)(*(void *)(a1 + 32) + 8)+ 40) code];
    uint64_t v10 = sub_100050530();
    (*(void (**)(uint64_t, uint64_t))(*(void *)v10 + 664))(v10, *(void *)(*(void *)(a1 + 40) + 8) + 48);
  }
  else
  {
    obuint64_t j = *v8;
    uint64_t v11 = [v5 getAndClearLPEMBluetoothLogWithError:&obj];
    objc_storeStrong(v8, obj);
    if (v11)
    {
      CFDictionaryGetTypeID();
      int v12 = CFDictionaryGetTypedValue();
      if (v12)
      {
        CFDataGetTypeID();
        int v13 = CFDictionaryGetTypedValue();
        int v14 = [v13 length];
        if (v13 && v14 >= 1 && v14 <= 32)
        {
          memset(__dst, 0, sizeof(__dst));
          memcpy(__dst, [v13 bytes], v14);
          long long v15 = qword_100A1A040;
          if (os_log_type_enabled((os_log_t)qword_100A1A040, OS_LOG_TYPE_DEFAULT))
          {
            long long v16 = *(void **)(*(void *)(*(void *)(a1 + 32) + 8) + 40);
            *(_DWORD *)long long buf = 138416386;
            id v23 = v16;
            __int16 v24 = 1024;
            int v25 = LOBYTE(__dst[0]);
            __int16 v26 = 1024;
            int v27 = BYTE1(__dst[0]);
            __int16 v28 = 1024;
            int v29 = BYTE2(__dst[0]);
            __int16 v30 = 1024;
            int v31 = BYTE3(__dst[0]);
            __int16 v32 = 1024;
            int v33 = BYTE4(__dst[0]);
            __int16 v34 = 1024;
            int v35 = BYTE5(__dst[0]);
            __int16 v36 = 1024;
            int v37 = BYTE6(__dst[0]);
            __int16 v38 = 1024;
            int v39 = BYTE7(__dst[0]);
            __int16 v40 = 1024;
            int v41 = BYTE8(__dst[0]);
            __int16 v42 = 1024;
            int v43 = BYTE9(__dst[0]);
            __int16 v44 = 1024;
            int v45 = BYTE10(__dst[0]);
            __int16 v46 = 1024;
            int v47 = BYTE11(__dst[0]);
            __int16 v48 = 1024;
            int v49 = BYTE12(__dst[0]);
            __int16 v50 = 1024;
            int v51 = BYTE13(__dst[0]);
            __int16 v52 = 1024;
            int v53 = BYTE14(__dst[0]);
            __int16 v54 = 1024;
            int v55 = HIBYTE(__dst[0]);
            _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "Get LPM Bluetooth log succeed (error=%@)\nlog: BT connection counter = 0x%02x, BT connection time = 0x%02x%02x%02x%02x, \nSEP2 Ranging setup counter = 0x%02x, SEP2 Clock info = 0x%02x%02x%02x%02x, \nSEP2 based unlock counter = 0x%02x, SEP2 based lock counter = 0x%02x, \nBT SE reset counter = 0x%02x,RPA rollover counter = 0x%02x, \nBT entry counter = 0x%02x, BT Exit counter = 0x%02x\n", buf, 0x6Cu);
          }
          *(_DWORD *)(*(void *)(*(void *)(a1 + 40) + 8) + 48) = 0;
          *(_DWORD *)(*(void *)(*(void *)(a1 + 40) + 8) + 52) = LOBYTE(__dst[0]);
          *(_DWORD *)(*(void *)(*(void *)(a1 + 40) + 8) + 56) = bswap32(*(unsigned int *)((char *)__dst + 1));
          *(_DWORD *)(*(void *)(*(void *)(a1 + 40) + 8) + 60) = BYTE14(__dst[0]);
          *(_DWORD *)(*(void *)(*(void *)(a1 + 40) + 8) + 64) = HIBYTE(__dst[0]);
          uint64_t v17 = sub_100050530();
          (*(void (**)(uint64_t, uint64_t))(*(void *)v17 + 664))(v17, *(void *)(*(void *)(a1 + 40) + 8) + 48);
        }
      }
      else
      {
        unint64_t v20 = qword_100A1A040;
        if (os_log_type_enabled((os_log_t)qword_100A1A040, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)long long buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "Get LPM Bluetooth log no FixBuf", buf, 2u);
        }
      }
    }
    else
    {
      uint64_t v18 = qword_100A1A040;
      if (os_log_type_enabled((os_log_t)qword_100A1A040, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v19 = *(void **)(*(void *)(*(void *)(a1 + 32) + 8) + 40);
        *(_DWORD *)long long buf = 138412290;
        id v23 = v19;
        _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "Get LPM Bluetooth log failed (error=%@)", buf, 0xCu);
      }
    }
    [v5 endSessionWithCompletion:0];
  }
}

void sub_100268C74(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100268CC0(uint64_t a1)
{
  id v2 = qword_100A1A040;
  if (os_log_type_enabled((os_log_t)qword_100A1A040, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "LPMManager::stackDidStart", buf, 2u);
  }
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_100268D98;
  block[3] = &unk_100997528;
  block[4] = a1;
  if (qword_100A12040 != -1) {
    dispatch_once(&qword_100A12040, block);
  }
}

void sub_100268D9C()
{
  uint64_t v0 = qword_100A1A040;
  if (os_log_type_enabled((os_log_t)qword_100A1A040, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v1 = 0;
    _os_log_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_DEFAULT, "LPMManager::stackWillStop", v1, 2u);
  }
}

uint64_t sub_100268E04(uint64_t a1, int a2)
{
  bzero(__str, 0x800uLL);
  v13.__r_.__value_.__r.__words[2] = 0;
  uint64_t v14 = 0;
  uint64_t v15 = 0;
  sub_10004191C(&v13.__r_.__value_.__r.__words[2], "");
  switch(a2)
  {
    case 0:
      *(_DWORD *)long long buf = 0;
      sub_10004191C(&v17[4], "device -D");
      uint64_t v19 = 0;
      sub_1002698E0((uint64_t *)(a1 + 40), (uint64_t)buf);
      goto LABEL_46;
    case 1:
      *(_DWORD *)long long buf = 1;
      sub_10004191C(&v17[4], "power off");
      uint64_t v19 = 0;
      sub_1002698E0((uint64_t *)(a1 + 40), (uint64_t)buf);
      goto LABEL_46;
    case 2:
      *(_DWORD *)long long buf = 2;
      sub_10004191C(&v17[4], "bcm -W");
      uint64_t v19 = 0;
      sub_1002698E0((uint64_t *)(a1 + 40), (uint64_t)buf);
      goto LABEL_46;
    case 3:
      *(_DWORD *)long long buf = 3;
      sub_10004191C(&v17[4], "bcm -L");
      uint64_t v19 = 0;
      sub_1002698E0((uint64_t *)(a1 + 40), (uint64_t)buf);
      goto LABEL_46;
    case 4:
      *(_DWORD *)long long buf = 4;
      sub_10004191C(&v17[4], "bcm -A");
      uint64_t v19 = 0;
      sub_1002698E0((uint64_t *)(a1 + 40), (uint64_t)buf);
      goto LABEL_46;
    case 5:
      *(_DWORD *)long long buf = 5;
      sub_10004191C(&v17[4], "bcm -Q");
      uint64_t v19 = 0;
      sub_1002698E0((uint64_t *)(a1 + 40), (uint64_t)buf);
      goto LABEL_46;
    case 6:
      *(_DWORD *)long long buf = 6;
      sub_10004191C(&v17[4], "bcm -x");
      uint64_t v19 = 0;
      sub_1002698E0((uint64_t *)(a1 + 40), (uint64_t)buf);
      goto LABEL_46;
    case 7:
      *(_DWORD *)long long buf = 7;
      sub_10004191C(&v17[4], "hci reset");
      uint64_t v19 = sub_100269A2C;
      sub_1002698E0((uint64_t *)(a1 + 40), (uint64_t)buf);
      goto LABEL_46;
    case 8:
      sub_100269AB8();
    case 9:
      sub_100269E78();
    case 10:
      v13.__r_.__value_.__s.__data_[8] = 4;
      sub_100269D38((std::string *)&v13.__r_.__value_.__r.__words[1], 1, (std::string *)&v13.__r_.__value_.__r.__words[2]);
      if (v15 >= 0) {
        uint64_t v4 = &v13.__r_.__value_.__s.__data_[16];
      }
      else {
        uint64_t v4 = (const char *)v13.__r_.__value_.__r.__words[2];
      }
      snprintf(__str, 0x800uLL, "hci cmd 0x%04X %s", 65122, v4);
      *(_DWORD *)long long buf = 10;
      sub_10004191C(&v17[4], __str);
      uint64_t v19 = sub_100269DEC;
      sub_1002698E0((uint64_t *)(a1 + 40), (uint64_t)buf);
      goto LABEL_46;
    case 11:
      sub_10026A040();
    case 12:
      LODWORD(v13.__r_.__value_.__r.__words[1]) = 0;
      sub_10026A174();
    case 13:
      v13.__r_.__value_.__s.__data_[10] = 1;
      LOWORD(v13.__r_.__value_.__r.__words[1]) = 7;
      sub_100269D38((std::string *)&v13.__r_.__value_.__r.__words[1], 3, (std::string *)&v13.__r_.__value_.__r.__words[2]);
      if (v15 >= 0) {
        id v5 = &v13.__r_.__value_.__s.__data_[16];
      }
      else {
        id v5 = (const char *)v13.__r_.__value_.__r.__words[2];
      }
      snprintf(__str, 0x800uLL, "hci cmd 0x%04X %s", 65122, v5);
      *(_DWORD *)long long buf = 13;
      sub_10004191C(&v17[4], __str);
      uint64_t v19 = sub_100269DEC;
      sub_1002698E0((uint64_t *)(a1 + 40), (uint64_t)buf);
      goto LABEL_46;
    case 14:
      *(_DWORD *)long long buf = 14;
      sub_10004191C(&v17[4], "bcm -s 0x0f,0x00,0x02,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00");
      uint64_t v19 = 0;
      sub_1002698E0((uint64_t *)(a1 + 40), (uint64_t)buf);
      goto LABEL_46;
    case 15:
      *(_DWORD *)long long buf = 15;
      sub_10004191C(&v17[4], "quit");
      uint64_t v19 = 0;
      sub_1002698E0((uint64_t *)(a1 + 40), (uint64_t)buf);
      goto LABEL_46;
    case 16:
      id v6 = (unsigned __int8 *)(a1 + 120);
      if (*(char *)(a1 + 143) < 0)
      {
        if (*(void *)(a1 + 128))
        {
          WORD2(v13.__r_.__value_.__r.__words[1]) = 0;
          LODWORD(v13.__r_.__value_.__r.__words[1]) = 0;
          WORD2(v13.__r_.__value_.__r.__words[0]) = 0;
          LODWORD(v13.__r_.__value_.__l.__data_) = 0;
          id v6 = *(unsigned __int8 **)v6;
LABEL_35:
          if (!sub_100465DF0(v6, (uint64_t)&v13.__r_.__value_.__l.__size_))
          {
            uint64_t v7 = 0;
            uint64_t v8 = &v13.__r_.__value_.__s.__data_[13];
            do
            {
              std::string::value_type v9 = *v8--;
              v13.__r_.__value_.__s.__data_[v7++] = v9;
            }
            while (v7 != 6);
            sub_100269D38(&v13, 6, (std::string *)&v13.__r_.__value_.__r.__words[2]);
            if (v15 >= 0) {
              uint64_t v10 = &v13.__r_.__value_.__s.__data_[16];
            }
            else {
              uint64_t v10 = (const char *)v13.__r_.__value_.__r.__words[2];
            }
            snprintf(__str, 0x800uLL, "hci cmd 0xfc01 %s", v10);
            *(_DWORD *)long long buf = 16;
            sub_10004191C(&v17[4], __str);
            uint64_t v19 = 0;
            sub_1002698E0((uint64_t *)(a1 + 40), (uint64_t)buf);
            if (v18 < 0) {
              operator delete(*(void **)&v17[4]);
            }
            uint64_t v11 = qword_100A1A040;
            if (os_log_type_enabled((os_log_t)qword_100A1A040, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)long long buf = 136315138;
              *(void *)uint64_t v17 = __str;
              _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "BCM_WRITE_BDADDR:%s", buf, 0xCu);
            }
          }
          goto LABEL_48;
        }
      }
      else if (*(unsigned char *)(a1 + 143))
      {
        WORD2(v13.__r_.__value_.__r.__words[1]) = 0;
        LODWORD(v13.__r_.__value_.__r.__words[1]) = 0;
        WORD2(v13.__r_.__value_.__r.__words[0]) = 0;
        LODWORD(v13.__r_.__value_.__l.__data_) = 0;
        goto LABEL_35;
      }
      *(_DWORD *)long long buf = 16;
      sub_10004191C(&v17[4], "hci cmd 0xfc01 0x98 0x98 0x98 0xC2 0x87 0x43");
      uint64_t v19 = 0;
      sub_1002698E0((uint64_t *)(a1 + 40), (uint64_t)buf);
LABEL_46:
      if (v18 < 0) {
        operator delete(*(void **)&v17[4]);
      }
LABEL_48:
      if (SHIBYTE(v15) < 0) {
        operator delete((void *)v13.__r_.__value_.__r.__words[2]);
      }
      return 0;
    case 17:
      *(_DWORD *)long long buf = 17;
      sub_10004191C(&v17[4], "hci cmd 0x2011 0x00 0x12 0x12 0x12 0xB0 0x68 0x43");
      uint64_t v19 = 0;
      sub_1002698E0((uint64_t *)(a1 + 40), (uint64_t)buf);
      goto LABEL_46;
    case 18:
      *(_DWORD *)long long buf = 18;
      sub_10004191C(&v17[4], "hci cmd 0x2006 0x20 0x03 0x20 0x03 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x07 0x00");
      uint64_t v19 = 0;
      sub_1002698E0((uint64_t *)(a1 + 40), (uint64_t)buf);
      goto LABEL_46;
    case 19:
      *(_DWORD *)long long buf = 19;
      sub_10004191C(&v17[4], "hci cmd 0x2008 0x03 0x31 0x32 0x33");
      uint64_t v19 = 0;
      sub_1002698E0((uint64_t *)(a1 + 40), (uint64_t)buf);
      goto LABEL_46;
    case 20:
      *(_DWORD *)long long buf = 20;
      sub_10004191C(&v17[4], "hci cmd 0x2024 0xFB 0x00 0x48 0x08");
      uint64_t v19 = 0;
      sub_1002698E0((uint64_t *)(a1 + 40), (uint64_t)buf);
      goto LABEL_46;
    case 21:
      *(_DWORD *)long long buf = 21;
      sub_10004191C(&v17[4], "hci cmd 0x200A 0x01");
      uint64_t v19 = 0;
      sub_1002698E0((uint64_t *)(a1 + 40), (uint64_t)buf);
      goto LABEL_46;
    case 22:
      *(_DWORD *)long long buf = 22;
      sub_10004191C(&v17[4], "hci cmd 0xFE45 0x01 0x01");
      uint64_t v19 = 0;
      sub_1002698E0((uint64_t *)(a1 + 40), (uint64_t)buf);
      goto LABEL_46;
    default:
      goto LABEL_48;
  }
}

void sub_1002696F8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, uint64_t a15, int a16, __int16 a17, char a18, char a19, uint64_t a20,void *__p,uint64_t a22,int a23,__int16 a24,char a25,char a26)
{
  if (a26 < 0) {
    operator delete(__p);
  }
  if (a19 < 0) {
    operator delete(a14);
  }
  _Unwind_Resume(exception_object);
}

void *sub_100269864(void *a1)
{
  a1[5] = &off_100998428;
  id v2 = (atomic_uint *)a1[6];
  if (v2) {
    sub_1000368F4(v2);
  }
  a1[3] = &off_100998428;
  uint64_t v3 = (atomic_uint *)a1[4];
  if (v3) {
    sub_1000368F4(v3);
  }
  return a1;
}

uint64_t sub_1002698E0(uint64_t *a1, uint64_t a2)
{
  unint64_t v6 = a1[2];
  uint64_t result = (uint64_t)(a1 + 2);
  unint64_t v5 = v6;
  unint64_t v7 = *(void *)(result - 8);
  if (v7 >= v6)
  {
    unint64_t v10 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v7 - *a1) >> 3);
    unint64_t v11 = v10 + 1;
    if (v10 + 1 > 0x666666666666666) {
      abort();
    }
    unint64_t v12 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v5 - *a1) >> 3);
    if (2 * v12 > v11) {
      unint64_t v11 = 2 * v12;
    }
    if (v12 >= 0x333333333333333) {
      unint64_t v13 = 0x666666666666666;
    }
    else {
      unint64_t v13 = v11;
    }
    v18[4] = result;
    uint64_t v14 = (char *)sub_10026C508(result, v13);
    uint64_t v15 = &v14[40 * v10];
    v18[0] = v14;
    v18[1] = v15;
    v18[3] = &v14[40 * v16];
    *(_DWORD *)uint64_t v15 = *(_DWORD *)a2;
    long long v17 = *(_OWORD *)(a2 + 8);
    *((void *)v15 + 3) = *(void *)(a2 + 24);
    *(_OWORD *)(v15 + 8) = v17;
    *(void *)(a2 + 16) = 0;
    *(void *)(a2 + 24) = 0;
    *(void *)(a2 + 8) = 0;
    *((void *)v15 + 4) = *(void *)(a2 + 32);
    v18[2] = v15 + 40;
    sub_10026C490(a1, v18);
    uint64_t v9 = a1[1];
    uint64_t result = sub_10026C550((uint64_t)v18);
  }
  else
  {
    *(_DWORD *)unint64_t v7 = *(_DWORD *)a2;
    long long v8 = *(_OWORD *)(a2 + 8);
    *(void *)(v7 + 24) = *(void *)(a2 + 24);
    *(_OWORD *)(v7 + 8) = v8;
    *(void *)(a2 + 16) = 0;
    *(void *)(a2 + 24) = 0;
    *(void *)(a2 + 8) = 0;
    *(void *)(v7 + 32) = *(void *)(a2 + 32);
    uint64_t v9 = v7 + 40;
    a1[1] = v7 + 40;
  }
  a1[1] = v9;
  return result;
}

void sub_100269A18(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_10026C550((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_100269A2C(uint64_t a1)
{
  id v2 = *(unsigned char **)a1;
  uint64_t v1 = *(void *)(a1 + 8);
  if (v1 - *(void *)a1 != 6 || *v2 != 14 || v2[1] != 4) {
    return 3;
  }
  uint64_t v3 = *(unsigned __int8 *)(v1 - 1);
  if (!*(unsigned char *)(v1 - 1)) {
    return 0;
  }
  uint64_t v4 = qword_100A1A040;
  if (os_log_type_enabled((os_log_t)qword_100A1A040, OS_LOG_TYPE_ERROR)) {
    sub_10074B40C(v3, v4, v5, v6, v7, v8, v9, v10);
  }
  return 112;
}

void sub_100269AB8()
{
}

std::string *sub_100269D38(std::string *result, int a2, std::string *a3)
{
  if (result)
  {
    if (a2 >= 1)
    {
      uint64_t v4 = result;
      uint64_t v5 = a2;
      do
      {
        __int16 v9 = 0;
        *(_DWORD *)__str = 0;
        int v6 = v4->__r_.__value_.__s.__data_[0];
        uint64_t v4 = (std::string *)((char *)v4 + 1);
        snprintf(__str, 6uLL, "0x%02x ", v6);
        uint64_t result = std::string::append(a3, __str);
        --v5;
      }
      while (v5);
    }
    if (SHIBYTE(a3->__r_.__value_.__r.__words[2]) < 0)
    {
      uint64_t v7 = a3->__r_.__value_.__l.__size_ - 1;
      a3->__r_.__value_.__l.__size_ = v7;
      a3 = (std::string *)a3->__r_.__value_.__r.__words[0];
    }
    else
    {
      uint64_t v7 = HIBYTE(a3->__r_.__value_.__r.__words[2]) - 1;
      *((unsigned char *)&a3->__r_.__value_.__s + 23) = v7 & 0x7F;
    }
    a3->__r_.__value_.__s.__data_[v7] = 0;
  }
  return result;
}

uint64_t sub_100269DEC(uint64_t a1)
{
  uint64_t v1 = *(unsigned char **)a1;
  if (*(void *)(a1 + 8) - *(void *)a1 != 7 || *v1 != 14 || v1[1] != 5) {
    return 3;
  }
  uint64_t v2 = v1[5];
  if (!v1[5]) {
    return 0;
  }
  uint64_t v3 = qword_100A1A040;
  if (os_log_type_enabled((os_log_t)qword_100A1A040, OS_LOG_TYPE_ERROR)) {
    sub_10074B74C(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  return 112;
}

void sub_100269E78()
{
}

void sub_10026A040()
{
}

void sub_10026A174()
{
}

void sub_10026A37C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t sub_10026A390(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (*(unsigned char *)(a1 + 24) && *(unsigned char *)(a1 + 25))
  {
    if (*(void *)(a1 + 176) >= 8uLL)
    {
      if (os_log_type_enabled((os_log_t)qword_100A1A040, OS_LOG_TYPE_ERROR)) {
        sub_10074BAC0();
      }
LABEL_26:
      uint64_t v4 = 1;
      goto LABEL_27;
    }
    sub_1000305AC(uu2, v3);
    uint64_t v5 = (uint64_t **)(a1 + 160);
    if (a1 + 168 != sub_1000308C0(a1 + 160, uu2))
    {
      if (os_log_type_enabled((os_log_t)qword_100A1A040, OS_LOG_TYPE_ERROR)) {
        sub_10074BC2C();
      }
      goto LABEL_26;
    }
    if (qword_1009F7ED0 != -1) {
      dispatch_once(&qword_1009F7ED0, &stru_10099FF90);
    }
    if (!sub_100008DC4(qword_1009F7EC8, v3))
    {
      if (os_log_type_enabled((os_log_t)qword_100A1A040, OS_LOG_TYPE_ERROR)) {
        sub_10074BBC4();
      }
      goto LABEL_26;
    }
    int v36 = 0;
    memset(v35, 0, sizeof(v35));
    *(_OWORD *)uu2 = 0u;
    if (qword_1009F7ED0 != -1) {
      dispatch_once(&qword_1009F7ED0, &stru_10099FF90);
    }
    sub_10070FA68(qword_1009F7EC8, v3, (uint64_t)uu2);
    long long v20 = 0u;
    long long v21 = 0u;
    long long v19 = 0u;
    if (qword_1009F7EE0 != -1) {
      dispatch_once(&qword_1009F7EE0, &stru_10099FFD0);
    }
    *(void *)&long long v19 = sub_100030DCC((uint64_t)off_1009F7ED8, v3, 0);
    sub_1000335D8((void *)&v19 + 1, (char *)&v35[2] + 8, 0x10uLL);
    sub_1000335D8((void *)&v20 + 1, (char *)v35 + 12, 0x10uLL);
    uint64_t v6 = *(void *)(a1 + 176);
    DWORD2(v21) = v6;
    BYTE12(v21) = v6 == 0;
    if ((void)v19)
    {
      if (!sub_100013DCC((uint64_t)&v19 + 8) && !sub_100013DCC((uint64_t)&v20 + 8))
      {
        sub_1000305AC(buf, v3);
        v17[0] = buf;
        uint64_t v8 = sub_10026C254(v5, buf, (uint64_t)&unk_1007BE9D0, (const unsigned __int8 *__attribute__((__org_typedef(uuid_t))) *)v17);
        sub_100267738((uint64_t)(v8 + 48), (uint64_t)&v19);
        uint64_t v9 = qword_100A1A040;
        if (os_log_type_enabled((os_log_t)qword_100A1A040, OS_LOG_TYPE_DEBUG))
        {
          sub_1000305AC(uu1, v3);
          v17[0] = uu1;
          sub_10026C254(v5, uu1, (uint64_t)&unk_1007BE9D0, (const unsigned __int8 *__attribute__((__org_typedef(uuid_t))) *)v17);
          sub_1006AD3F0();
          id v10 = (id)objc_claimAutoreleasedReturnValue();
          sub_1000305AC(v24, v3);
          __p[0] = v24;
          unint64_t v11 = sub_10026C254(v5, v24, (uint64_t)&unk_1007BE9D0, (const unsigned __int8 *__attribute__((__org_typedef(uuid_t))) *)__p);
          unint64_t v12 = v17;
          sub_10004C2C4((uint64_t)(v11 + 56), v17);
          if (v18 < 0) {
            unint64_t v12 = (void **)v17[0];
          }
          sub_1000305AC(v23, v3);
          unsigned __int8 v22 = v23;
          unint64_t v13 = sub_10026C254(v5, v23, (uint64_t)&unk_1007BE9D0, (const unsigned __int8 *__attribute__((__org_typedef(uuid_t))) *)&v22);
          sub_10004C2C4((uint64_t)(v13 + 72), __p);
          if (v16 >= 0) {
            uint64_t v14 = __p;
          }
          else {
            uint64_t v14 = (void **)__p[0];
          }
          *(_DWORD *)long long buf = 138413058;
          id v27 = v3;
          __int16 v28 = 2112;
          id v29 = v10;
          __int16 v30 = 2080;
          int v31 = v12;
          __int16 v32 = 2080;
          int v33 = v14;
          _os_log_debug_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEBUG, "Device %@ is added to the list with address: %@, irk: %s, ltk: %s", buf, 0x2Au);
          if (v16 < 0) {
            operator delete(__p[0]);
          }
          if (v18 < 0) {
            operator delete(v17[0]);
          }
        }
        uint64_t v4 = 0;
        goto LABEL_31;
      }
      if (os_log_type_enabled((os_log_t)qword_100A1A040, OS_LOG_TYPE_ERROR)) {
        sub_10074BB5C();
      }
    }
    else if (os_log_type_enabled((os_log_t)qword_100A1A040, OS_LOG_TYPE_ERROR))
    {
      sub_10074BAF4();
    }
    uint64_t v4 = 1;
LABEL_31:
    *((void *)&v20 + 1) = &off_100998428;
    if ((void)v21) {
      sub_1000368F4((atomic_uint *)v21);
    }
    *((void *)&v19 + 1) = &off_100998428;
    if ((void)v20) {
      sub_1000368F4((atomic_uint *)v20);
    }
    goto LABEL_27;
  }
  if (os_log_type_enabled((os_log_t)qword_100A1A040, OS_LOG_TYPE_ERROR)) {
    sub_10074ADD8();
  }
  uint64_t v4 = 11;
LABEL_27:

  return v4;
}

void sub_10026A8AC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20)
{
  if (a17 < 0) {
    operator delete(__p);
  }

  sub_100267788(&a18);
  _Unwind_Resume(a1);
}

uint64_t sub_10026A940(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (*(unsigned char *)(a1 + 24) && *(unsigned char *)(a1 + 25))
  {
    sub_1000305AC(uu2, v3);
    uint64_t v4 = (uint64_t *)sub_1000308C0(a1 + 160, uu2);
    if ((uint64_t *)(a1 + 168) == v4)
    {
      if (os_log_type_enabled((os_log_t)qword_100A1A040, OS_LOG_TYPE_ERROR)) {
        sub_10074BC94();
      }
      uint64_t v5 = 1;
    }
    else
    {
      sub_10004D3B8((uint64_t **)(a1 + 160), v4);
      sub_10026C050(v4 + 4);
      operator delete(v4);
      uint64_t v5 = 0;
    }
  }
  else
  {
    if (os_log_type_enabled((os_log_t)qword_100A1A040, OS_LOG_TYPE_ERROR)) {
      sub_10074ADD8();
    }
    uint64_t v5 = 11;
  }

  return v5;
}

void sub_10026AA64(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t sub_10026AA7C(uint64_t a1, uint64_t **a2)
{
  if (*(unsigned char *)(a1 + 24) && *(unsigned char *)(a1 + 25))
  {
    uint64_t v2 = *(void **)(a1 + 160);
    id v3 = (void *)(a1 + 168);
    if (v2 != (void *)(a1 + 168))
    {
      uint64_t v5 = (uint64_t)(a2 + 2);
      do
      {
        long long v33 = 0u;
        long long v34 = 0u;
        long long v31 = 0u;
        long long v32 = 0u;
        sub_10026BE44((uint64_t)&v31, (uint64_t)(v2 + 4));
        uint64_t v6 = sub_100031234((const unsigned __int8 *)&v31);
        uint64_t v7 = v6;
        uint64_t v9 = a2[1];
        unint64_t v8 = (unint64_t)a2[2];
        if ((unint64_t)v9 >= v8)
        {
          uint64_t v11 = v9 - *a2;
          if ((unint64_t)(v11 + 1) >> 61) {
            abort();
          }
          uint64_t v12 = v8 - (void)*a2;
          uint64_t v13 = v12 >> 2;
          if (v12 >> 2 <= (unint64_t)(v11 + 1)) {
            uint64_t v13 = v11 + 1;
          }
          if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v14 = v13;
          }
          uint64_t v30 = v5;
          if (v14) {
            uint64_t v15 = (char *)sub_1000405F8(v5, v14);
          }
          else {
            uint64_t v15 = 0;
          }
          char v16 = (uint64_t *)&v15[8 * v11];
          long long v17 = &v15[8 * v14];
          id v29 = v17;
          *char v16 = v7;
          id v10 = v16 + 1;
          v28.i64[1] = (uint64_t)(v16 + 1);
          long long v19 = *a2;
          char v18 = a2[1];
          if (v18 == *a2)
          {
            int64x2_t v21 = vdupq_n_s64((unint64_t)v18);
          }
          else
          {
            do
            {
              uint64_t v20 = *--v18;
              *char v18 = 0;
              *--char v16 = v20;
            }
            while (v18 != v19);
            int64x2_t v21 = *(int64x2_t *)a2;
            id v10 = (uint64_t *)v28.i64[1];
            long long v17 = v29;
          }
          *a2 = v16;
          a2[1] = v10;
          int64x2_t v28 = v21;
          unsigned __int8 v22 = (char *)a2[2];
          a2[2] = (uint64_t *)v17;
          id v29 = v22;
          uint64_t v27 = v21.i64[0];
          sub_10026C648((uint64_t)&v27);
        }
        else
        {
          *uint64_t v9 = v6;
          id v10 = v9 + 1;
        }
        a2[1] = v10;
        *((void *)&v33 + 1) = &off_100998428;
        if ((void)v34) {
          sub_1000368F4((atomic_uint *)v34);
        }
        *((void *)&v32 + 1) = &off_100998428;
        if ((void)v33) {
          sub_1000368F4((atomic_uint *)v33);
        }
        id v23 = (void *)v2[1];
        if (v23)
        {
          do
          {
            __int16 v24 = v23;
            id v23 = (void *)*v23;
          }
          while (v23);
        }
        else
        {
          do
          {
            __int16 v24 = (void *)v2[2];
            BOOL v25 = *v24 == (void)v2;
            uint64_t v2 = v24;
          }
          while (!v25);
        }
        uint64_t v2 = v24;
      }
      while (v24 != v3);
    }
    return 0;
  }
  else
  {
    if (os_log_type_enabled((os_log_t)qword_100A1A040, OS_LOG_TYPE_ERROR)) {
      sub_10074ADD8();
    }
    return 11;
  }
}

void sub_10026ACD8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);

  sub_100269864((uint64_t *)va);
  _Unwind_Resume(a1);
}

uint64_t sub_10026AD04(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 24) && *(unsigned char *)(a1 + 25))
  {
    uint64_t v1 = (void *)(a1 + 168);
    sub_10026BFF4(a1 + 160, *(void **)(a1 + 168));
    uint64_t result = 0;
    *(v1 - 1) = v1;
    *uint64_t v1 = 0;
    v1[1] = 0;
  }
  else
  {
    if (os_log_type_enabled((os_log_t)qword_100A1A040, OS_LOG_TYPE_ERROR)) {
      sub_10074ADD8();
    }
    return 11;
  }
  return result;
}

uint64_t sub_10026AD7C(uint64_t a1, unsigned int a2, void *a3, int a4)
{
  id v8 = a3;
  if (*(unsigned char *)(a1 + 27))
  {
LABEL_2:
    uint64_t v9 = 0;
    goto LABEL_3;
  }
  if (a2 == 255)
  {
    uint64_t v12 = qword_100A1A040;
    if (os_log_type_enabled((os_log_t)qword_100A1A040, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v13) = 0;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "setOfflineAdvertisingDataAndPayload Done!", (uint8_t *)&v13, 2u);
    }
    uint64_t v13 = 0;
    uint64_t v14 = 0;
    sub_10003AED0((uint64_t)&v13, (uint64_t)&unk_100A19900);
    byte_100A19940 = 0;
    sub_100026264(&stru_100A198D0);
    sub_10003AFB4((uint64_t)&v13);
    goto LABEL_2;
  }
  uint64_t v11 = qword_100A1A040;
  if (a2 < 2)
  {
    if (os_log_type_enabled((os_log_t)qword_100A1A040, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(v13) = 67109634;
      HIDWORD(v13) = a2;
      LOWORD(v14) = 1024;
      *(_DWORD *)((char *)&v14 + 2) = a4;
      HIWORD(v14) = 2112;
      id v15 = v8;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "setOfflineAdvertisingDataAndPayload set:%d interval:%d data:%@", (uint8_t *)&v13, 0x18u);
    }
    objc_storeStrong((id *)(a1 + 8 * a2 + 192), a3);
    uint64_t v9 = 0;
    *(_DWORD *)(a1 + 4 * a2 + 208) = a4;
  }
  else
  {
    if (os_log_type_enabled((os_log_t)qword_100A1A040, OS_LOG_TYPE_ERROR)) {
      sub_10074BCFC();
    }
    uint64_t v9 = 3;
  }
LABEL_3:

  return v9;
}

void sub_10026AF34(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  sub_10003AFB4((uint64_t)&a9);

  _Unwind_Resume(a1);
}

uint64_t sub_10026AF5C(uint64_t a1, void *a2)
{
  uint64_t v14 = a1;
  long long v28 = 0u;
  long long v29 = 0u;
  long long v30 = 0u;
  long long v31 = 0u;
  obuint64_t j = a2;
  id v18 = [obj countByEnumeratingWithState:&v28 objects:v34 count:16];
  if (v18)
  {
    int v16 = 0;
    uint64_t v17 = *(void *)v29;
    while (2)
    {
      for (uint64_t i = 0; i != v18; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v29 != v17) {
          objc_enumerationMutation(obj);
        }
        id v20 = *(id *)(*((void *)&v28 + 1) + 8 * i);
        id v2 = objc_alloc_init((Class)NSMutableArray);
        id v23 = [v20 objectForKey:@"kCBMsgArgOfflineAdvertisingData"];
        uint64_t v3 = [v20 objectForKey:@"kCBMsgArgOfflineAdvertisingRotationInterval"];
        int64x2_t v21 = (void *)v3;
        if (v23) {
          BOOL v4 = v3 == 0;
        }
        else {
          BOOL v4 = 1;
        }
        int v5 = !v4;
        int v19 = v5;
        if (!v4)
        {
          long long v26 = 0u;
          long long v27 = 0u;
          long long v24 = 0u;
          long long v25 = 0u;
          id v6 = v23;
          id v7 = [v6 countByEnumeratingWithState:&v24 objects:v33 count:16];
          if (v7)
          {
            uint64_t v8 = *(void *)v25;
            do
            {
              for (uint64_t j = 0; j != v7; uint64_t j = (char *)j + 1)
              {
                if (*(void *)v25 != v8) {
                  objc_enumerationMutation(v6);
                }
                id v10 = *(void **)(*((void *)&v24 + 1) + 8 * (void)j);
                memset(v32, 0, 37);
                [v10 getBytes:v32 range:0, 6, v14];
                [v10 getBytes:((char *)v32 + 13) range:NSMakeRange(22, 6)];
                *(_DWORD *)((char *)v32 + 9) = 1643008;
                *(_DWORD *)((char *)v32 + 6) = 5046046;
                BYTE3(v32[2]) = BYTE3(v32[2]) & 0xFC | (LOBYTE(v32[0]) >> 6);
                LOBYTE(v32[0]) |= 0xC0u;
                uint64_t v11 = +[NSData dataWithBytes:v32 length:37];
                [v2 addObject:v11];
              }
              id v7 = [v6 countByEnumeratingWithState:&v24 objects:v33 count:16];
            }
            while (v7);
          }

          sub_10026AD7C(v14, v16++, v2, (int)[v21 intValue]);
        }

        if (!v19)
        {

          uint64_t v12 = 3;
          goto LABEL_26;
        }
      }
      id v18 = [obj countByEnumeratingWithState:&v28 objects:v34 count:16];
      if (v18) {
        continue;
      }
      break;
    }
  }

  sub_10026AD7C(v14, 0xFFu, 0, -1);
  uint64_t v12 = 0;
LABEL_26:

  return v12;
}

void sub_10026B280(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  _Unwind_Resume(a1);
}

void sub_10026B324(uint64_t a1)
{
  sub_10026BF08(a1);

  operator delete();
}

uint64_t sub_10026B35C()
{
  return 1;
}

uint64_t sub_10026B364()
{
  return 1;
}

void sub_10026B36C(uint64_t a1, uint64_t a2)
{
  os_unfair_lock_lock((os_unfair_lock_t)a1);
  int v5 = *(char **)(a1 + 8);
  BOOL v4 = *(char **)(a1 + 16);
  if (v5 != v4)
  {
    while (*(void *)v5 != a2)
    {
      v5 += 8;
      if (v5 == v4)
      {
        int v5 = *(char **)(a1 + 16);
        break;
      }
    }
  }
  if (v5 == v4)
  {
    uint64_t v6 = a2;
    sub_10026B3F8(a1 + 8, v4, (char *)&v6);
    sub_100061554(a1 + 8);
  }
  os_unfair_lock_unlock((os_unfair_lock_t)a1);
}

char *sub_10026B3F8(uint64_t a1, char *__src, char *a3)
{
  uint64_t v3 = a3;
  BOOL v4 = __src;
  uint64_t v6 = *(char **)(a1 + 8);
  uint64_t v8 = a1 + 16;
  unint64_t v7 = *(void *)(a1 + 16);
  if ((unint64_t)v6 >= v7)
  {
    uint64_t v13 = *(char **)a1;
    unint64_t v14 = ((uint64_t)&v6[-*(void *)a1] >> 3) + 1;
    if (v14 >> 61) {
      abort();
    }
    uint64_t v15 = __src - v13;
    uint64_t v16 = (__src - v13) >> 3;
    uint64_t v17 = v7 - (void)v13;
    if (v17 >> 2 > v14) {
      unint64_t v14 = v17 >> 2;
    }
    if ((unint64_t)v17 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v18 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v18 = v14;
    }
    uint64_t v30 = a1 + 16;
    if (v18) {
      int v19 = (char *)sub_1000405F8(a1 + 16, v18);
    }
    else {
      int v19 = 0;
    }
    id v20 = &v19[8 * v16];
    __p = v19;
    long long v27 = v20;
    long long v28 = v20;
    long long v29 = &v19[8 * v18];
    if (v16 == v18)
    {
      if (v15 < 1)
      {
        if (v13 == v4) {
          unint64_t v22 = 1;
        }
        else {
          unint64_t v22 = v15 >> 2;
        }
        id v23 = (char *)sub_1000405F8(v8, v22);
        id v20 = &v23[8 * (v22 >> 2)];
        __p = v23;
        long long v27 = v20;
        long long v29 = &v23[8 * v24];
        if (v19) {
          operator delete(v19);
        }
      }
      else
      {
        unint64_t v21 = v16 + 2;
        if (v16 >= -1) {
          unint64_t v21 = v16 + 1;
        }
        v20 -= 8 * (v21 >> 1);
        long long v27 = v20;
      }
    }
    *(void *)id v20 = *(void *)v3;
    long long v28 = v20 + 8;
    BOOL v4 = sub_100061614((void **)a1, (uint64_t)&__p, v4);
    if (v28 != v27) {
      v28 += (v27 - v28 + 7) & 0xFFFFFFFFFFFFFFF8;
    }
    if (__p) {
      operator delete(__p);
    }
  }
  else if (__src == v6)
  {
    *(void *)__src = *(void *)a3;
    *(void *)(a1 + 8) = __src + 8;
  }
  else
  {
    uint64_t v9 = __src + 8;
    id v10 = v6 - 8;
    uint64_t v11 = *(void **)(a1 + 8);
    while (v10 < v6)
    {
      uint64_t v12 = *(void *)v10;
      v10 += 8;
      *v11++ = v12;
    }
    *(void *)(a1 + 8) = v11;
    if (v6 != v9) {
      memmove(&v6[-8 * ((v6 - v9) >> 3)], __src, v6 - v9);
    }
    if (v4 <= v3) {
      v3 += 8 * (*(void *)(a1 + 8) > (unint64_t)v3);
    }
    *(void *)BOOL v4 = *(void *)v3;
  }
  return v4;
}

void sub_10026B600(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_10026B638(uint64_t a1, uint64_t a2)
{
  os_unfair_lock_lock((os_unfair_lock_t)a1);
  BOOL v4 = *(char **)(a1 + 8);
  int v5 = *(char **)(a1 + 16);
  if (v4 == v5)
  {
    uint64_t v6 = *(char **)(a1 + 8);
    goto LABEL_10;
  }
  uint64_t v6 = *(char **)(a1 + 8);
  while (*(void *)v6 != a2)
  {
    v6 += 8;
    if (v6 == v5)
    {
      uint64_t v6 = *(char **)(a1 + 16);
      break;
    }
  }
  if (v6 == v5)
  {
    if (v4 != v5)
    {
LABEL_11:
      uint64_t v7 = a2;
      sub_10026B708(a1 + 8, v6, (char *)&v7);
      sub_100061554(a1 + 8);
      goto LABEL_12;
    }
LABEL_10:
    (***(void (****)(void, uint64_t))(a1 + 32))(*(void *)(a1 + 32), a1);
    goto LABEL_11;
  }
LABEL_12:
  os_unfair_lock_unlock((os_unfair_lock_t)a1);
}

char *sub_10026B708(uint64_t a1, char *__src, char *a3)
{
  uint64_t v3 = a3;
  BOOL v4 = __src;
  uint64_t v6 = *(char **)(a1 + 8);
  uint64_t v8 = a1 + 16;
  unint64_t v7 = *(void *)(a1 + 16);
  if ((unint64_t)v6 >= v7)
  {
    uint64_t v13 = *(char **)a1;
    unint64_t v14 = ((uint64_t)&v6[-*(void *)a1] >> 3) + 1;
    if (v14 >> 61) {
      abort();
    }
    uint64_t v15 = __src - v13;
    uint64_t v16 = (__src - v13) >> 3;
    uint64_t v17 = v7 - (void)v13;
    if (v17 >> 2 > v14) {
      unint64_t v14 = v17 >> 2;
    }
    if ((unint64_t)v17 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v18 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v18 = v14;
    }
    uint64_t v30 = a1 + 16;
    if (v18) {
      int v19 = (char *)sub_1000405F8(a1 + 16, v18);
    }
    else {
      int v19 = 0;
    }
    id v20 = &v19[8 * v16];
    __p = v19;
    long long v27 = v20;
    long long v28 = v20;
    long long v29 = &v19[8 * v18];
    if (v16 == v18)
    {
      if (v15 < 1)
      {
        if (v13 == v4) {
          unint64_t v22 = 1;
        }
        else {
          unint64_t v22 = v15 >> 2;
        }
        id v23 = (char *)sub_1000405F8(v8, v22);
        id v20 = &v23[8 * (v22 >> 2)];
        __p = v23;
        long long v27 = v20;
        long long v29 = &v23[8 * v24];
        if (v19) {
          operator delete(v19);
        }
      }
      else
      {
        unint64_t v21 = v16 + 2;
        if (v16 >= -1) {
          unint64_t v21 = v16 + 1;
        }
        v20 -= 8 * (v21 >> 1);
        long long v27 = v20;
      }
    }
    *(void *)id v20 = *(void *)v3;
    long long v28 = v20 + 8;
    BOOL v4 = sub_100061614((void **)a1, (uint64_t)&__p, v4);
    if (v28 != v27) {
      v28 += (v27 - v28 + 7) & 0xFFFFFFFFFFFFFFF8;
    }
    if (__p) {
      operator delete(__p);
    }
  }
  else if (__src == v6)
  {
    *(void *)__src = *(void *)a3;
    *(void *)(a1 + 8) = __src + 8;
  }
  else
  {
    uint64_t v9 = __src + 8;
    id v10 = v6 - 8;
    uint64_t v11 = *(void **)(a1 + 8);
    while (v10 < v6)
    {
      uint64_t v12 = *(void *)v10;
      v10 += 8;
      *v11++ = v12;
    }
    *(void *)(a1 + 8) = v11;
    if (v6 != v9) {
      memmove(&v6[-8 * ((v6 - v9) >> 3)], __src, v6 - v9);
    }
    if (v4 <= v3) {
      v3 += 8 * (*(void *)(a1 + 8) > (unint64_t)v3);
    }
    *(void *)BOOL v4 = *(void *)v3;
  }
  return v4;
}

void sub_10026B910(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_10026B948(uint64_t a1, uint64_t a2)
{
  os_unfair_lock_lock((os_unfair_lock_t)a1);
  BOOL v4 = *(char **)(a1 + 8);
  int v5 = *(char **)(a1 + 16);
  if (v4 == v5)
  {
    uint64_t v6 = *(char **)(a1 + 8);
    goto LABEL_10;
  }
  uint64_t v6 = *(char **)(a1 + 8);
  while (*(void *)v6 != a2)
  {
    v6 += 8;
    if (v6 == v5)
    {
      uint64_t v6 = *(char **)(a1 + 16);
      break;
    }
  }
  if (v6 == v5)
  {
    if (v4 != v5)
    {
LABEL_11:
      uint64_t v7 = a2;
      sub_10026BA18(a1 + 8, v6, (char *)&v7);
      sub_100061554(a1 + 8);
      goto LABEL_12;
    }
LABEL_10:
    (***(void (****)(void, uint64_t))(a1 + 32))(*(void *)(a1 + 32), a1);
    goto LABEL_11;
  }
LABEL_12:
  os_unfair_lock_unlock((os_unfair_lock_t)a1);
}

char *sub_10026BA18(uint64_t a1, char *__src, char *a3)
{
  uint64_t v3 = a3;
  BOOL v4 = __src;
  uint64_t v6 = *(char **)(a1 + 8);
  uint64_t v8 = a1 + 16;
  unint64_t v7 = *(void *)(a1 + 16);
  if ((unint64_t)v6 >= v7)
  {
    uint64_t v13 = *(char **)a1;
    unint64_t v14 = ((uint64_t)&v6[-*(void *)a1] >> 3) + 1;
    if (v14 >> 61) {
      abort();
    }
    uint64_t v15 = __src - v13;
    uint64_t v16 = (__src - v13) >> 3;
    uint64_t v17 = v7 - (void)v13;
    if (v17 >> 2 > v14) {
      unint64_t v14 = v17 >> 2;
    }
    if ((unint64_t)v17 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v18 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v18 = v14;
    }
    uint64_t v30 = a1 + 16;
    if (v18) {
      int v19 = (char *)sub_1000405F8(a1 + 16, v18);
    }
    else {
      int v19 = 0;
    }
    id v20 = &v19[8 * v16];
    __p = v19;
    long long v27 = v20;
    long long v28 = v20;
    long long v29 = &v19[8 * v18];
    if (v16 == v18)
    {
      if (v15 < 1)
      {
        if (v13 == v4) {
          unint64_t v22 = 1;
        }
        else {
          unint64_t v22 = v15 >> 2;
        }
        id v23 = (char *)sub_1000405F8(v8, v22);
        id v20 = &v23[8 * (v22 >> 2)];
        __p = v23;
        long long v27 = v20;
        long long v29 = &v23[8 * v24];
        if (v19) {
          operator delete(v19);
        }
      }
      else
      {
        unint64_t v21 = v16 + 2;
        if (v16 >= -1) {
          unint64_t v21 = v16 + 1;
        }
        v20 -= 8 * (v21 >> 1);
        long long v27 = v20;
      }
    }
    *(void *)id v20 = *(void *)v3;
    long long v28 = v20 + 8;
    BOOL v4 = sub_100061614((void **)a1, (uint64_t)&__p, v4);
    if (v28 != v27) {
      v28 += (v27 - v28 + 7) & 0xFFFFFFFFFFFFFFF8;
    }
    if (__p) {
      operator delete(__p);
    }
  }
  else if (__src == v6)
  {
    *(void *)__src = *(void *)a3;
    *(void *)(a1 + 8) = __src + 8;
  }
  else
  {
    uint64_t v9 = __src + 8;
    id v10 = v6 - 8;
    uint64_t v11 = *(void **)(a1 + 8);
    while (v10 < v6)
    {
      uint64_t v12 = *(void *)v10;
      v10 += 8;
      *v11++ = v12;
    }
    *(void *)(a1 + 8) = v11;
    if (v6 != v9) {
      memmove(&v6[-8 * ((v6 - v9) >> 3)], __src, v6 - v9);
    }
    if (v4 <= v3) {
      v3 += 8 * (*(void *)(a1 + 8) > (unint64_t)v3);
    }
    *(void *)BOOL v4 = *(void *)v3;
  }
  return v4;
}

void sub_10026BC20(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10026BC58()
{
  io_iterator_t existing = 0;
  CFDictionaryRef v0 = IOServiceNameMatching("AppleDialogSPMIPMU");
  if (IOServiceGetMatchingServices(kIOMainPortDefault, v0, &existing))
  {
    if (os_log_type_enabled((os_log_t)qword_100A1A040, OS_LOG_TYPE_ERROR)) {
      sub_10074BE2C();
    }
    return 0;
  }
  io_iterator_t v2 = existing;
  if (!existing)
  {
    int v5 = qword_100A1A040;
    if (os_log_type_enabled((os_log_t)qword_100A1A040, OS_LOG_TYPE_ERROR)) {
      sub_10074BD80(v5, v6, v7, v8, v9, v10, v11, v12);
    }
    return 0;
  }
  do
  {
    if (!IOIteratorIsValid(v2)) {
      break;
    }
    uint64_t v3 = IOIteratorNext(existing);
    uint64_t v1 = v3;
    if (!v3) {
      goto LABEL_16;
    }
    CFTypeRef CFProperty = IORegistryEntryCreateCFProperty(v3, @"IOPMUPrimary", 0, 0);
    if (CFProperty)
    {
      CFRelease(CFProperty);
      goto LABEL_16;
    }
    IOObjectRelease(v1);
    io_iterator_t v2 = existing;
  }
  while (existing);
  if (os_log_type_enabled((os_log_t)qword_100A1A040, OS_LOG_TYPE_ERROR)) {
    sub_10074BDF8();
  }
  uint64_t v1 = 0;
LABEL_16:
  IOObjectRelease(existing);
  return v1;
}

void *sub_10026BD9C(void *__b, size_t __len, int __c)
{
  if (__len >= 0x7FFFFFFFFFFFFFF8) {
    abort();
  }
  if (__len >= 0x17)
  {
    size_t v7 = (__len & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((__len | 7) != 0x17) {
      size_t v7 = __len | 7;
    }
    size_t v8 = v7 + 1;
    uint64_t v6 = operator new(v7 + 1);
    __b[1] = __len;
    __b[2] = v8 | 0x8000000000000000;
    *__b = v6;
  }
  else
  {
    *((unsigned char *)__b + 23) = __len;
    uint64_t v6 = __b;
    if (!__len) {
      goto LABEL_9;
    }
  }
  memset(v6, __c, __len);
LABEL_9:
  *((unsigned char *)v6 + __len) = 0;
  return __b;
}

uint64_t sub_10026BE44(uint64_t a1, uint64_t a2)
{
  uuid_copy((unsigned __int8 *)a1, (const unsigned __int8 *)a2);
  *(void *)(a1 + 16) = *(void *)(a2 + 16);
  uint64_t v4 = *(void *)(a2 + 32);
  *(void *)(a1 + 24) = &off_100998428;
  *(void *)(a1 + 32) = v4;
  if (v4) {
    sub_100037354(v4);
  }
  uint64_t v5 = *(void *)(a2 + 48);
  *(void *)(a1 + 40) = &off_100998428;
  *(void *)(a1 + 48) = v5;
  if (v5) {
    sub_100037354(v5);
  }
  int v6 = *(_DWORD *)(a2 + 56);
  *(unsigned char *)(a1 + 60) = *(unsigned char *)(a2 + 60);
  *(_DWORD *)(a1 + 56) = v6;
  return a1;
}

void sub_10026BEEC(_Unwind_Exception *exception_object)
{
  *(void *)(v1 + 24) = v2;
  uint64_t v4 = *(atomic_uint **)(v1 + 32);
  if (v4) {
    sub_1000368F4(v4);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10026BF08(uint64_t a1)
{
  *(void *)a1 = off_10099FE88;
  *(void *)(a1 + 8) = off_10099FEF0;
  *(void *)(a1 + 16) = &off_10099FF20;
  for (uint64_t i = 200; i != 184; i -= 8)

  sub_10026BFF4(a1 + 160, *(void **)(a1 + 168));
  if (*(char *)(a1 + 143) < 0) {
    operator delete(*(void **)(a1 + 120));
  }
  if (*(char *)(a1 + 119) < 0) {
    operator delete(*(void **)(a1 + 96));
  }
  if (*(char *)(a1 + 95) < 0) {
    operator delete(*(void **)(a1 + 72));
  }
  uint64_t v4 = (void **)(a1 + 40);
  sub_10026C0E0(&v4);
  return a1;
}

void sub_10026BFF4(uint64_t a1, void *a2)
{
  if (a2)
  {
    sub_10026BFF4(a1, *a2);
    sub_10026BFF4(a1, a2[1]);
    sub_10026C050(a2 + 4);
    operator delete(a2);
  }
}

void sub_10026C050(void *a1)
{
  a1[5] = &off_100998428;
  uint64_t v2 = (atomic_uint *)a1[6];
  if (v2) {
    sub_1000368F4(v2);
  }
  a1[3] = &off_100998428;
  uint64_t v3 = (atomic_uint *)a1[4];
  if (v3)
  {
    sub_1000368F4(v3);
  }
}

void sub_10026C0E0(void ***a1)
{
  uint64_t v2 = *a1;
  if (*v2)
  {
    sub_10026C134((uint64_t *)v2);
    uint64_t v3 = **a1;
    operator delete(v3);
  }
}

void sub_10026C134(uint64_t *a1)
{
  uint64_t v2 = *a1;
  for (uint64_t i = a1[1]; i != v2; i -= 40)
  {
    if (*(char *)(i - 9) < 0) {
      operator delete(*(void **)(i - 32));
    }
  }
  a1[1] = v2;
}

void sub_10026C184(id a1)
{
}

void sub_10026C1C8()
{
}

void sub_10026C1EC(id a1)
{
}

void sub_10026C230()
{
}

unsigned __int8 *sub_10026C254(uint64_t **a1, unsigned __int8 *uu1, uint64_t a3, const unsigned __int8 *__attribute__((__org_typedef(uuid_t))) *a4)
{
  uint64_t v11 = 0;
  int v6 = (unsigned __int8 **)sub_10004A0BC((uint64_t)a1, &v11, uu1);
  size_t v7 = *v6;
  if (!*v6)
  {
    size_t v8 = (uint64_t **)v6;
    memset(v10, 0, sizeof(v10));
    sub_10026C30C((uint64_t)a1, a4, v10);
    sub_100036CA0(a1, v11, v8, (uint64_t *)v10[0]);
    size_t v7 = v10[0];
    v10[0] = 0;
    sub_10026C3D0((uint64_t)v10, 0);
  }
  return v7;
}

double sub_10026C30C@<D0>(uint64_t a1@<X0>, const unsigned __int8 *__attribute__((__org_typedef(uuid_t))) *a2@<X2>, unsigned __int8 **a3@<X8>)
{
  uint64_t v5 = (unsigned __int8 *)(a1 + 8);
  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  int v6 = (unsigned __int8 *)operator new(0x60uLL);
  *a3 = v6;
  a3[1] = v5;
  *((unsigned char *)a3 + 16) = 0;
  uuid_copy(v6 + 32, *a2);
  double result = 0.0;
  *((_OWORD *)v6 + 3) = 0u;
  *((_OWORD *)v6 + 4) = 0u;
  *((_OWORD *)v6 + 5) = 0u;
  *((void *)v6 + 7) = &off_100998428;
  *((void *)v6 + 9) = &off_100998428;
  *((unsigned char *)a3 + 16) = 1;
  return result;
}

void sub_10026C3B8(_Unwind_Exception *a1)
{
  sub_10026C3D0(v1, 0);
  _Unwind_Resume(a1);
}

void sub_10026C3D0(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void **)a1;
  *(void *)a1 = a2;
  if (v2)
  {
    if (*(unsigned char *)(a1 + 16)) {
      sub_10026C050(v2 + 4);
    }
    operator delete(v2);
  }
}

void sub_10026C428(id a1)
{
}

void sub_10026C46C()
{
}

uint64_t *sub_10026C490(uint64_t *result, void *a2)
{
  uint64_t v3 = *result;
  uint64_t v2 = result[1];
  uint64_t v4 = a2[1];
  while (v2 != v3)
  {
    int v5 = *(_DWORD *)(v2 - 40);
    v2 -= 40;
    *(_DWORD *)(v4 - 40) = v5;
    v4 -= 40;
    long long v6 = *(_OWORD *)(v2 + 8);
    *(void *)(v4 + 24) = *(void *)(v2 + 24);
    *(_OWORD *)(v4 + 8) = v6;
    *(void *)(v2 + 16) = 0;
    *(void *)(v2 + 24) = 0;
    *(void *)(v2 + 8) = 0;
    *(void *)(v4 + 32) = *(void *)(v2 + 32);
  }
  a2[1] = v4;
  uint64_t v7 = *result;
  *double result = v4;
  a2[1] = v7;
  uint64_t v8 = result[1];
  result[1] = a2[2];
  a2[2] = v8;
  uint64_t v9 = result[2];
  result[2] = a2[3];
  a2[3] = v9;
  *a2 = a2[1];
  return result;
}

void *sub_10026C508(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x666666666666667) {
    sub_1000616DC();
  }
  return operator new(40 * a2);
}

uint64_t sub_10026C550(uint64_t a1)
{
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void sub_10026C588(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 16);
  if (v2 != a2)
  {
    do
    {
      uint64_t v5 = v2 - 40;
      *(void *)(a1 + 16) = v2 - 40;
      if (*(char *)(v2 - 9) < 0)
      {
        operator delete(*(void **)(v2 - 32));
        uint64_t v5 = *(void *)(a1 + 16);
      }
      uint64_t v2 = v5;
    }
    while (v5 != a2);
  }
}

void sub_10026C5E0(id a1)
{
}

void sub_10026C624()
{
}

uint64_t sub_10026C648(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 8;
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

unsigned char *sub_10026C69C(unsigned char *result, unsigned char *a2)
{
  *double result = 0;
  *a2 = 0;
  return result;
}

void sub_10026C6C0()
{
  sub_1002B80C0(&stru_100A198D0);
  __cxa_atexit((void (*)(void *))sub_1002B812C, &stru_100A198D0, (void *)&_mh_execute_header);
  sub_100052DA8(&unk_100A19900);
  __cxa_atexit((void (*)(void *))sub_100052DA4, &unk_100A19900, (void *)&_mh_execute_header);
  sub_1002B80C0(&stru_100A19948);
  __cxa_atexit((void (*)(void *))sub_1002B812C, &stru_100A19948, (void *)&_mh_execute_header);
  sub_100052DA8(&unk_100A19978);
  __cxa_atexit((void (*)(void *))sub_100052DA4, &unk_100A19978, (void *)&_mh_execute_header);
  sub_100052DA8(&unk_100A199C0);
  __cxa_atexit((void (*)(void *))sub_100052DA4, &unk_100A199C0, (void *)&_mh_execute_header);
  sub_1002B80C0(&stru_100A19A00);
  __cxa_atexit((void (*)(void *))sub_1002B812C, &stru_100A19A00, (void *)&_mh_execute_header);
}

void *sub_10026C7FC(uint64_t a1, uint64_t a2, __int16 a3)
{
  double result = (void *)sub_1004EC10C(a1, a2, a3);
  *double result = &off_1009A0020;
  return result;
}

void sub_10026C830(uint64_t a1, const uint8_t *a2, CFIndex a3)
{
  if (a3)
  {
    uint64_t v5 = *a2;
    if (*(void *)(a1 + 216))
    {
      uint64_t v7 = (void *)(a1 + 192);
      if (*a2 <= 0x8Fu)
      {
        if (*a2 > 0x13u)
        {
          if ((v5 - 32) >= 3)
          {
            if (v5 == 20)
            {
              uint64_t v8 = qword_100A1A018;
              if (os_log_type_enabled((os_log_t)qword_100A1A018, OS_LOG_TYPE_DEFAULT))
              {
                int v9 = (*(uint64_t (**)(void, void))(**(void **)(a1 + 8) + 32))(*(void *)(a1 + 8), *(unsigned __int16 *)(a1 + 40));
                *(_DWORD *)long long buf = 67109376;
                *(_DWORD *)&uint8_t buf[4] = 20;
                __int16 v38 = 1024;
                int v39 = v9;
                _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "Received exit suspend input report (ID %u), should undim %d", buf, 0xEu);
              }
LABEL_31:
              long long v29 = qword_100A1A018;
              if (os_log_type_enabled((os_log_t)qword_100A1A018, OS_LOG_TYPE_ERROR)) {
                sub_10074BFA4(v5, v29, v30, v31, v32, v33, v34, v35);
              }
              return;
            }
            goto LABEL_25;
          }
LABEL_21:
          uint8_t v18 = -12;
          goto LABEL_28;
        }
        switch(v5)
        {
          case 1:
            uint8_t v18 = -15;
            goto LABEL_28;
          case 0x11:
            goto LABEL_21;
          case 0x13:
            int v19 = qword_100A1A018;
            if (os_log_type_enabled((os_log_t)qword_100A1A018, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)long long buf = 67109120;
              *(_DWORD *)&uint8_t buf[4] = 19;
              _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "Received power-off notice input report (ID %u)", buf, 8u);
            }
            return;
        }
LABEL_25:
        id v20 = qword_100A1A018;
        if (os_log_type_enabled((os_log_t)qword_100A1A018, OS_LOG_TYPE_ERROR)) {
          sub_10074BF38(v5, v20, v21, v22, v23, v24, v25, v26);
        }
        return;
      }
      uint64_t v17 = (v5 - 144);
      if (v17 <= 0x36)
      {
        if (((1 << (v5 + 112)) & 0x40000000000C01) != 0) {
          goto LABEL_15;
        }
        if (v17 == 48)
        {
          uint8_t v18 = -14;
          goto LABEL_28;
        }
      }
      if (v5 != 224) {
        goto LABEL_25;
      }
LABEL_15:
      uint8_t v18 = -16;
LABEL_28:
      buf[0] = v18;
      if (sub_10026D430(v7, buf))
      {
        uint8_t v36 = v18;
        *(void *)long long buf = &v36;
        long long v27 = (__IOHIDUserDevice *)sub_10026D4E4((uint64_t)v7, &v36, (uint64_t)&unk_1007BE9D0, (unsigned char **)buf)[3];
        if (v27)
        {
          uint64_t v28 = mach_absolute_time();
          IOHIDUserDeviceHandleReportWithTimeStamp(v27, v28, a2, a3);
          return;
        }
      }
      goto LABEL_31;
    }
    uint64_t v10 = qword_100A1A018;
    if (os_log_type_enabled((os_log_t)qword_100A1A018, OS_LOG_TYPE_ERROR)) {
      sub_10074BEC8(v5, v10, v11, v12, v13, v14, v15, v16);
    }
  }
  else if (os_log_type_enabled((os_log_t)qword_100A1A018, OS_LOG_TYPE_ERROR))
  {
    sub_10074BE94();
  }
}

uint64_t sub_10026CB30(uint64_t a1, void *a2)
{
  sub_1004EC630(a1, a2);
  sub_10026CD74(a1, a2);
  id v4 = a2;
  uint64_t v5 = [v4 valueForKey:@"ProductID"];
  unsigned int v6 = [v5 intValue];
  int v13 = 14;
  if (v6 == *(unsigned __int16 *)sub_10026CEEC((uint64_t)&unk_100A19C10, &v13)
    || (int v12 = 16, v6 == *(unsigned __int16 *)sub_10026CEEC((uint64_t)&unk_100A19C10, &v12))
    || (int v11 = 26, v6 == *(unsigned __int16 *)sub_10026CEEC((uint64_t)&unk_100A19C10, &v11))
    || (int v10 = 27, v6 == *(unsigned __int16 *)sub_10026CEEC((uint64_t)&unk_100A19C10, &v10)))
  {
    uint64_t v7 = sub_10026D034();
    sub_10026CF3C(a1, v4, v7);

    sub_10026D0E4(a1, v4);
  }
  else
  {
    int v13 = 15;
    if (v6 == *(unsigned __int16 *)sub_10026CEEC((uint64_t)&unk_100A19C10, &v13)
      || (int v12 = 25, v6 == *(unsigned __int16 *)sub_10026CEEC((uint64_t)&unk_100A19C10, &v12)))
    {
      int v9 = sub_10026D034();
      sub_10026CF3C(a1, v4, v9);
    }
    else
    {
      int v9 = sub_10026D1E4();
      sub_10026CF3C(a1, v4, v9);
    }
  }
  int v13 = 12;
  if (v6 == *(unsigned __int16 *)sub_10026CEEC((uint64_t)&unk_100A19C10, &v13)) {
    sub_10026D294(a1, v4);
  }

  return 1;
}

void sub_10026CD24(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t sub_10026CD74(uint64_t a1, void *a2)
{
  long long v8 = xmmword_1007BAFEE;
  long long v9 = unk_1007BAFFE;
  *(_OWORD *)int v10 = xmmword_1007BB00E;
  long long v6 = xmmword_1007BAFCE;
  long long v7 = unk_1007BAFDE;
  *(_DWORD *)&v10[15] = -1073577627;
  *(void *)(a1 + 304) = a1;
  *(unsigned char *)(a1 + 312) = -16;
  id v3 = [a2 mutableCopy:v6, v7, v8, v9, *(_OWORD *)v10, *(void *)&v10[16]];
  [v3 setObject:@"Keyboard" forKeyedSubscript:@"Accessory Category"];
  [v3 setObject:&off_1009E18E8 forKeyedSubscript:@"ExtendedData"];
  uint64_t v4 = sub_1004EC498(a1, v3, (uint64_t)&v6, 83, *(unsigned __int8 *)(a1 + 312), 0);
  if (v4)
  {
    IOHIDUserDeviceRegisterGetReportWithReturnLengthCallback();
    IOHIDUserDeviceRegisterSetReportCallback();
  }
  else if (os_log_type_enabled((os_log_t)qword_100A1A018, OS_LOG_TYPE_ERROR))
  {
    sub_10074C010();
  }

  return v4;
}

void sub_10026CED0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t *sub_10026CEEC(uint64_t a1, int *a2)
{
  uint64_t v2 = *(uint64_t **)(a1 + 8);
  if (!v2) {
LABEL_8:
  }
    abort();
  int v3 = *a2;
  while (1)
  {
    while (1)
    {
      int v4 = *((_DWORD *)v2 + 7);
      if (v3 >= v4) {
        break;
      }
      uint64_t v2 = (uint64_t *)*v2;
      if (!v2) {
        goto LABEL_8;
      }
    }
    if (v4 >= v3) {
      return v2 + 4;
    }
    uint64_t v2 = (uint64_t *)v2[1];
    if (!v2) {
      goto LABEL_8;
    }
  }
}

uint64_t sub_10026CF3C(uint64_t a1, void *a2, void *a3)
{
  id v5 = a3;
  *(void *)(a1 + 320) = a1;
  *(unsigned char *)(a1 + 328) = -15;
  id v6 = v5;
  uint64_t v7 = sub_1004EC498(a1, a2, (uint64_t)[v6 bytes], (uint64_t)[v6 length], *(unsigned __int8 *)(a1 + 328), 1);
  if (v7)
  {
    IOHIDUserDeviceRegisterGetReportWithReturnLengthCallback();
    IOHIDUserDeviceRegisterSetReportCallback();
  }
  else if (os_log_type_enabled((os_log_t)qword_100A1A018, OS_LOG_TYPE_ERROR))
  {
    sub_10074C044();
  }

  return v7;
}

void sub_10026D024(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id sub_10026D034()
{
  v2[10] = xmmword_1007BB109;
  v3[0] = unk_1007BB119;
  *(_OWORD *)((char *)v3 + 15) = unk_1007BB128;
  v2[6] = xmmword_1007BB0C9;
  v2[7] = unk_1007BB0D9;
  v2[8] = xmmword_1007BB0E9;
  v2[9] = unk_1007BB0F9;
  void v2[2] = xmmword_1007BB089;
  v2[3] = unk_1007BB099;
  v2[4] = xmmword_1007BB0A9;
  v2[5] = unk_1007BB0B9;
  v2[0] = xmmword_1007BB069;
  v2[1] = unk_1007BB079;
  CFDictionaryRef v0 = +[NSData dataWithBytes:v2 length:207];

  return v0;
}

uint64_t sub_10026D0E4(uint64_t a1, void *a2)
{
  long long v4 = xmmword_1007BB03C;
  v5[0] = unk_1007BB04C;
  *(_OWORD *)((char *)v5 + 13) = unk_1007BB059;
  *(void *)(a1 + 352) = a1;
  *(unsigned char *)(a1 + 360) = -12;
  uint64_t v2 = sub_1004EC498(a1, a2, (uint64_t)&v4, 45, 244, 2);
  if (v2)
  {
    IOHIDUserDeviceRegisterGetReportWithReturnLengthCallback();
    IOHIDUserDeviceRegisterSetReportCallback();
  }
  else if (os_log_type_enabled((os_log_t)qword_100A1A018, OS_LOG_TYPE_ERROR))
  {
    sub_10074C078();
  }
  return v2;
}

id sub_10026D1E4()
{
  v2[8] = xmmword_1007BB1B8;
  v2[9] = unk_1007BB1C8;
  *(_OWORD *)int v3 = xmmword_1007BB1D8;
  *(void *)&v3[14] = 0xC022813F85409508;
  v2[4] = xmmword_1007BB178;
  v2[5] = unk_1007BB188;
  v2[6] = xmmword_1007BB198;
  v2[7] = unk_1007BB1A8;
  v2[0] = xmmword_1007BB138;
  v2[1] = unk_1007BB148;
  void v2[2] = xmmword_1007BB158;
  v2[3] = unk_1007BB168;
  CFDictionaryRef v0 = +[NSData dataWithBytes:v2 length:182];

  return v0;
}

uint64_t sub_10026D294(uint64_t a1, void *a2)
{
  v4[0] = xmmword_1007BB021;
  *(_OWORD *)((char *)v4 + 11) = *(long long *)((char *)&xmmword_1007BB021 + 11);
  *(void *)(a1 + 336) = a1;
  *(unsigned char *)(a1 + 344) = -14;
  uint64_t v2 = sub_1004EC498(a1, a2, (uint64_t)v4, 27, 242, 2);
  if (v2)
  {
    IOHIDUserDeviceRegisterGetReportWithReturnLengthCallback();
    IOHIDUserDeviceRegisterSetReportCallback();
  }
  else if (os_log_type_enabled((os_log_t)qword_100A1A018, OS_LOG_TYPE_ERROR))
  {
    sub_10074C0AC();
  }
  return v2;
}

uint64_t sub_10026D394(unsigned __int8 *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return (*(uint64_t (**)(void, uint64_t, uint64_t, uint64_t, uint64_t, void))(**(void **)a1 + 112))(*(void *)a1, a2, a3, a4, a5, a1[8]);
}

uint64_t sub_10026D3C4(unsigned __int8 *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return (*(uint64_t (**)(void, uint64_t, uint64_t, uint64_t, uint64_t, void))(**(void **)a1 + 120))(*(void *)a1, a2, a3, a4, a5, a1[8]);
}

void sub_10026D3F8(uint64_t a1)
{
  sub_1004EC1D4(a1);

  operator delete();
}

uint64_t **sub_10026D430(void *a1, unsigned __int8 *a2)
{
  int8x8_t v2 = (int8x8_t)a1[1];
  if (!*(void *)&v2) {
    return 0;
  }
  unint64_t v3 = *a2;
  uint8x8_t v4 = (uint8x8_t)vcnt_s8(v2);
  v4.i16[0] = vaddlv_u8(v4);
  if (v4.u32[0] > 1uLL)
  {
    unint64_t v5 = *a2;
    if (*(void *)&v2 <= v3) {
      unint64_t v5 = v3 % *(void *)&v2;
    }
  }
  else
  {
    unint64_t v5 = (v2.i32[0] - 1) & v3;
  }
  id v6 = *(uint64_t ****)(*a1 + 8 * v5);
  if (!v6) {
    return 0;
  }
  for (double result = *v6; result; double result = (uint64_t **)*result)
  {
    unint64_t v8 = (unint64_t)result[1];
    if (v8 == v3)
    {
      if (*((unsigned __int8 *)result + 16) == v3) {
        return result;
      }
    }
    else
    {
      if (v4.u32[0] > 1uLL)
      {
        if (v8 >= *(void *)&v2) {
          v8 %= *(void *)&v2;
        }
      }
      else
      {
        v8 &= *(void *)&v2 - 1;
      }
      if (v8 != v5) {
        return 0;
      }
    }
  }
  return result;
}

void *sub_10026D4E4(uint64_t a1, unsigned __int8 *a2, uint64_t a3, unsigned char **a4)
{
  unint64_t v6 = *a2;
  unint64_t v7 = *(void *)(a1 + 8);
  if (v7)
  {
    uint8x8_t v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      unint64_t v9 = *a2;
      if (v7 <= v6) {
        unint64_t v9 = v6 % v7;
      }
    }
    else
    {
      unint64_t v9 = (v7 - 1) & v6;
    }
    int v10 = *(void ***)(*(void *)a1 + 8 * v9);
    if (v10)
    {
      int v11 = *v10;
      if (*v10)
      {
        do
        {
          unint64_t v12 = v11[1];
          if (v12 == v6)
          {
            if (*((unsigned __int8 *)v11 + 16) == v6) {
              return v11;
            }
          }
          else
          {
            if (v8.u32[0] > 1uLL)
            {
              if (v12 >= v7) {
                v12 %= v7;
              }
            }
            else
            {
              v12 &= v7 - 1;
            }
            if (v12 != v9) {
              break;
            }
          }
          int v11 = (void *)*v11;
        }
        while (v11);
      }
    }
  }
  else
  {
    unint64_t v9 = 0;
  }
  int v11 = operator new(0x20uLL);
  *int v11 = 0;
  v11[1] = v6;
  *((unsigned char *)v11 + 16) = **a4;
  v11[3] = 0;
  float v13 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v14 = *(float *)(a1 + 32);
  if (!v7 || (float)(v14 * (float)v7) < v13)
  {
    BOOL v15 = 1;
    if (v7 >= 3) {
      BOOL v15 = (v7 & (v7 - 1)) != 0;
    }
    unint64_t v16 = v15 | (2 * v7);
    unint64_t v17 = vcvtps_u32_f32(v13 / v14);
    if (v16 <= v17) {
      size_t v18 = v17;
    }
    else {
      size_t v18 = v16;
    }
    sub_1000A9204(a1, v18);
    unint64_t v7 = *(void *)(a1 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v7 <= v6) {
        unint64_t v9 = v6 % v7;
      }
      else {
        unint64_t v9 = v6;
      }
    }
    else
    {
      unint64_t v9 = (v7 - 1) & v6;
    }
  }
  uint64_t v19 = *(void *)a1;
  id v20 = *(void **)(*(void *)a1 + 8 * v9);
  if (v20)
  {
    *int v11 = *v20;
LABEL_38:
    *id v20 = v11;
    goto LABEL_39;
  }
  *int v11 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = v11;
  *(void *)(v19 + 8 * v9) = a1 + 16;
  if (*v11)
  {
    unint64_t v21 = *(void *)(*v11 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v21 >= v7) {
        v21 %= v7;
      }
    }
    else
    {
      v21 &= v7 - 1;
    }
    id v20 = (void *)(*(void *)a1 + 8 * v21);
    goto LABEL_38;
  }
LABEL_39:
  ++*(void *)(a1 + 24);
  return v11;
}

void sub_10026D6FC(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_10026D710()
{
  int v5 = 0;
  long long v4 = 0u;
  long long v3 = 0u;
  long long v2 = 0u;
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_10026D7B0;
  block[3] = &unk_1009A00A0;
  if (qword_100A12070 != -1) {
    dispatch_once(&qword_100A12070, block);
  }
  return qword_100A19A30;
}

void sub_10026D7B0()
{
}

uint64_t sub_10026D804(uint64_t result)
{
  *(void *)double result = &off_1009A00D0;
  *(unsigned char *)(result + 152) = 0;
  return result;
}

void sub_10026D82C()
{
}

uint64_t sub_10026D840(uint64_t a1, uint64_t a2, unsigned __int16 *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*a3 > 3uLL)
  {
    float v14 = qword_100A19EF8;
    if (os_log_type_enabled((os_log_t)qword_100A19EF8, OS_LOG_TYPE_ERROR)) {
      sub_10074C0E0(v14);
    }
  }
  else
  {
    uint64_t v10 = a1 + 52 * *a3;
    long long v11 = *(_OWORD *)a3;
    long long v12 = *((_OWORD *)a3 + 1);
    long long v13 = *((_OWORD *)a3 + 2);
    *(_DWORD *)(v10 + 202) = *((_DWORD *)a3 + 12);
    *(_OWORD *)(v10 + 186) = v13;
    *(_OWORD *)(v10 + 170) = v12;
    *(_OWORD *)(v10 + 154) = v11;
  }
  return sub_10019304C(0x10Au, (uint64_t)(a3 + 11), a3[21], a3[22], a3[23], a3[24], a3[25], a8, a2);
}

uint64_t sub_10026D940(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return sub_10019304C(0x10Bu, a2, a3, a4, a5, a6, a7, a8, a2);
}

uint64_t sub_10026D96C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return sub_10019304C(0x10Eu, a2, a3, a4, a5, a6, a7, a8, a2);
}

uint64_t sub_10026D9A0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return sub_10019304C(0x10Fu, a2, a3, a4, a5, a6, a7, a8, a2);
}

uint64_t sub_10026D9C8(uint64_t a1, uint64_t a2, unsigned __int16 *a3)
{
  return sub_10019304C(0x105u, a2, a3[20], a3[12], a3[13], a3[14], a3[15], a3[16], a2);
}

uint64_t sub_10026DA78(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return sub_10001BDE0(269, (uint64_t)sub_10026DAFC, *(unsigned __int8 *)(a3 + 23), *(unsigned __int8 *)(a3 + 22), a5, a6, a7, a8, a2);
}

void sub_10026DAFC(int a1)
{
  long long v2 = qword_100A19EF8;
  if (os_log_type_enabled((os_log_t)qword_100A19EF8, OS_LOG_TYPE_DEFAULT))
  {
    v3[0] = 67109120;
    v3[1] = a1;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "csSetProcedureParamsCB status=%{bluetooth:OI_STATUS}u", (uint8_t *)v3, 8u);
  }
}

uint64_t sub_10026DBA0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return sub_10001BDE0(268, (uint64_t)sub_10026DBD8, a3, a4, a5, a6, a7, a8, a2);
}

void sub_10026DBD8(int a1)
{
  long long v2 = qword_100A19EF8;
  if (os_log_type_enabled((os_log_t)qword_100A19EF8, OS_LOG_TYPE_DEFAULT))
  {
    v3[0] = 67109120;
    v3[1] = a1;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "csSetAfhCB status=%{bluetooth:OI_STATUS}u", (uint8_t *)v3, 8u);
  }
}

uint64_t sub_10026DC7C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return sub_10001BDE0(262, (uint64_t)sub_10026DCC4, a3, a4, a5, a6, a7, a8, a2);
}

void sub_10026DCC4(int a1)
{
  long long v2 = qword_100A19EF8;
  if (os_log_type_enabled((os_log_t)qword_100A19EF8, OS_LOG_TYPE_DEFAULT))
  {
    v3[0] = 67109120;
    v3[1] = a1;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "csSetDefaultSettingsCB status=%{bluetooth:OI_STATUS}u", (uint8_t *)v3, 8u);
  }
}

void sub_10026DD68(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (sub_10001BDE0(263, (uint64_t)sub_10026DDC8, a3, a4, a5, a6, a7, a8, v9))
  {
    uint8x8_t v8 = qword_100A19EF8;
    if (os_log_type_enabled((os_log_t)qword_100A19EF8, OS_LOG_TYPE_ERROR)) {
      sub_10074C124(v8);
    }
  }
}

__n128 sub_10026DDC8(int a1, uint64_t a2)
{
  long long v4 = qword_100A19EF8;
  if (os_log_type_enabled((os_log_t)qword_100A19EF8, OS_LOG_TYPE_DEFAULT))
  {
    v9[0] = 67109120;
    v9[1] = a1;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "csLeReadLocalFAETableCB status=%{bluetooth:OI_STATUS}u", (uint8_t *)v9, 8u);
  }
  uint64_t v5 = sub_10026D710();
  *(_OWORD *)(v5 + 80) = *(_OWORD *)a2;
  long long v7 = *(_OWORD *)(a2 + 32);
  __n128 result = *(__n128 *)(a2 + 48);
  long long v8 = *(_OWORD *)(a2 + 16);
  *(void *)(v5 + 144) = *(void *)(a2 + 64);
  *(_OWORD *)(v5 + 112) = v7;
  *(__n128 *)(v5 + 128) = result;
  *(_OWORD *)(v5 + 96) = v8;
  return result;
}

uint64_t sub_10026DE9C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return sub_10019304C(0x108u, a2, a3, a4, a5, a6, a7, a8, a2);
}

uint64_t sub_10026DEC4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return sub_10001BDE0(265, (uint64_t)sub_10026DEFC, a3, a4, a5, a6, a7, a8, a2);
}

void sub_10026DEFC(int a1)
{
  long long v2 = qword_100A19EF8;
  if (os_log_type_enabled((os_log_t)qword_100A19EF8, OS_LOG_TYPE_DEFAULT))
  {
    v3[0] = 67109120;
    v3[1] = a1;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "csLeWriteRemoteFAETableCB status=%{bluetooth:OI_STATUS}u", (uint8_t *)v3, 8u);
  }
}

__n128 sub_10026DFA0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(_OWORD *)(a1 + 8) = *(_OWORD *)a3;
  __n128 result = *(__n128 *)(a3 + 16);
  long long v4 = *(_OWORD *)(a3 + 32);
  long long v5 = *(_OWORD *)(a3 + 48);
  *(void *)(a1 + 72) = *(void *)(a3 + 64);
  *(_OWORD *)(a1 + 56) = v5;
  *(_OWORD *)(a1 + 40) = v4;
  *(__n128 *)(a1 + 24) = result;
  return result;
}

uint64_t sub_10026DFC8(uint64_t result)
{
  *(unsigned char *)(result + 152) = 1;
  return result;
}

void sub_10026DFD4(uint64_t a1, int a2)
{
  long long v3 = qword_100A19EF8;
  if (os_log_type_enabled((os_log_t)qword_100A19EF8, OS_LOG_TYPE_DEFAULT))
  {
    v4[0] = 67109120;
    v4[1] = a2;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "LE_CsProcedureEnableComplete status=%{bluetooth:OI_STATUS}u", (uint8_t *)v4, 8u);
  }
}

void sub_10026E078(uint64_t a1, uint64_t a2, int a3, int a4, int a5, int a6, int a7, int a8, char a9, unsigned __int8 __na, size_t __n, const void *a12, unsigned __int8 *a13, const void *a14)
{
  uint64_t v14 = __chkstk_darwin(a1, a2);
  char v16 = v15;
  char v38 = v17;
  int v19 = v18;
  char v21 = v20;
  __int16 v23 = v22;
  char v25 = v24;
  uint64_t v36 = v26;
  uint64_t v27 = v14;
  uint64_t v28 = qword_100A19EF8;
  if (os_log_type_enabled((os_log_t)qword_100A19EF8, OS_LOG_TYPE_DEFAULT))
  {
    buf[0] = 67109120;
    buf[1] = v19;
    _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, "LE_CsSubeventResultComplete procedureDoneStatus=%{bluetooth:OI_STATUS}u", (uint8_t *)buf, 8u);
  }
  int v29 = v19 & 0xF;
  if (v29 != 14)
  {
    char v37 = v16;
    uint64_t v30 = a13;
    uint64_t v31 = (const void *)__n;
    uint64_t v32 = __na;
    if (v29 == 15)
    {
      bzero((void *)(v27 + 372), 0x65E1uLL);
      uint64_t v31 = (const void *)__n;
    }
    *(unsigned char *)(v27 + 362) = v25;
    *(_WORD *)(v27 + 364) = v23;
    *(unsigned char *)(v27 + 366) = v21;
    *(unsigned char *)(v27 + 367) = v19;
    *(unsigned char *)(v27 + 368) = v38;
    *(unsigned char *)(v27 + 369) = v37;
    *(unsigned char *)(v27 + 370) = a9;
    *(unsigned char *)(v27 + 371) = __na;
    if (v29 == 1) {
      *(unsigned char *)(v27 + 26452) += __na;
    }
    memcpy((void *)(v27 + 372), v31, __na);
    memcpy((void *)(v27 + 532), a12, __na);
    memcpy((void *)(v27 + 692), a13, __na);
    if (__na)
    {
      unsigned __int16 v33 = 0;
      do
      {
        __int16 v34 = *v30++;
        v33 += v34;
        --v32;
      }
      while (v32);
      size_t v35 = v33;
    }
    else
    {
      size_t v35 = 0;
    }
    memcpy((void *)(v27 + 852), a14, v35);
    if ((v38 & 0xF) == 0)
    {
      if (qword_1009F7EC0 != -1) {
        dispatch_once(&qword_1009F7EC0, &stru_1009A00E0);
      }
      memcpy(__dst, (const void *)(v27 + 362), sizeof(__dst));
      sub_1006A2CF4(v36, (uint64_t)__dst);
    }
  }
}

void sub_10026E2B4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9, unsigned __int8 *a10, const void *a11)
{
  uint64_t v11 = __chkstk_darwin(a1, a2);
  long long v13 = v12;
  unsigned int v15 = v14;
  char v17 = v16;
  char v19 = v18;
  int v21 = v20;
  char v23 = v22;
  uint64_t v32 = v24;
  char v25 = (unsigned char *)v11;
  uint64_t v26 = a10;
  uint64_t v27 = qword_100A19EF8;
  if (os_log_type_enabled((os_log_t)qword_100A19EF8, OS_LOG_TYPE_DEFAULT))
  {
    buf[0] = 67109120;
    buf[1] = v21;
    _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "LE_CsSubeventResultComplete status=%{bluetooth:OI_STATUS}u", (uint8_t *)buf, 8u);
  }
  v25[362] = v23;
  v25[367] = v21;
  v25[368] = v19;
  v25[370] = v17;
  uint64_t v28 = v15;
  v25[371] = v15;
  memcpy(v25 + 372, v13, v15);
  memcpy(v25 + 532, a9, v15);
  memcpy(v25 + 692, a10, v15);
  if (v15)
  {
    unsigned __int16 v29 = 0;
    do
    {
      __int16 v30 = *v26++;
      v29 += v30;
      --v28;
    }
    while (v28);
    size_t v31 = v29;
  }
  else
  {
    size_t v31 = 0;
  }
  memcpy(v25 + 852, a11, v31);
  if ((v19 & 0xF) == 0)
  {
    if (qword_1009F7EC0 != -1) {
      dispatch_once(&qword_1009F7EC0, &stru_1009A00E0);
    }
    memcpy(__dst, v25 + 362, sizeof(__dst));
    sub_1006A2CF4(v32, (uint64_t)__dst);
  }
}

__n128 sub_10026E48C(uint64_t a1, unsigned __int16 *a2)
{
  if (*a2 <= 3uLL)
  {
    uint64_t v2 = a1 + 52 * *a2;
    __n128 result = *(__n128 *)a2;
    long long v4 = *((_OWORD *)a2 + 1);
    long long v5 = *((_OWORD *)a2 + 2);
    *(_DWORD *)(v2 + 202) = *((_DWORD *)a2 + 12);
    *(_OWORD *)(v2 + 186) = v5;
    *(_OWORD *)(v2 + 170) = v4;
    *(__n128 *)(v2 + 154) = result;
  }
  return result;
}

void sub_10026E4C0(id a1)
{
}

void sub_10026E504()
{
}

uint64_t sub_10026E528(uint64_t a1)
{
  *(_OWORD *)(a1 + 8) = 0u;
  *(_WORD *)(a1 + 69) = 0;
  uint64_t v2 = (std::string *)(a1 + 32);
  *(_DWORD *)(a1 + 65) = 0;
  *(unsigned char *)a1 = 0;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  std::string::assign((std::string *)(a1 + 8), "");
  std::string::assign(v2, "");
  *(unsigned char *)(a1 + 56) = 2;
  *(_DWORD *)(a1 + 60) = 0;
  *(unsigned char *)(a1 + 64) = 0;
  *(unsigned char *)(a1 + 71) = 0;
  return a1;
}

void sub_10026E5AC(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 55) < 0) {
    operator delete(*v3);
  }
  if (*(char *)(v1 + 31) < 0) {
    operator delete(*v2);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10026E5DC(uint64_t result, char a2)
{
  *(unsigned char *)(result + 71) = a2;
  return result;
}

void sub_10026E5E4(uint64_t a1)
{
  if (qword_1009F8080 != -1) {
    dispatch_once(&qword_1009F8080, &stru_1009A0100);
  }
  uint64_t v2 = (uint64_t *)(a1 + 32);
  sub_10049FE28((uint64_t)off_1009F8078, (unsigned char *)(a1 + 64), a1 + 32);
  long long v3 = qword_100A19ED8;
  if (os_log_type_enabled((os_log_t)qword_100A19ED8, OS_LOG_TYPE_DEFAULT))
  {
    if (*(unsigned char *)(a1 + 64)) {
      long long v4 = "Sign in";
    }
    else {
      long long v4 = "Sign out";
    }
    uint64_t v5 = a1 + 32;
    if (*(char *)(a1 + 55) < 0) {
      uint64_t v5 = *v2;
    }
    *(_DWORD *)long long buf = 136315394;
    uint64_t v10 = v4;
    __int16 v11 = 2080;
    uint64_t v12 = v5;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Sending version info request to magnet device, local cloud sign-in status = \"%s\", local cloud account = \"%s\"", buf, 0x16u);
  }
  uint64_t v6 = sub_100373068();
  if (*(char *)(a1 + 55) < 0)
  {
    sub_10003B098(__p, *(void **)(a1 + 32), *(void *)(a1 + 40));
  }
  else
  {
    *(_OWORD *)__p = *(_OWORD *)v2;
    uint64_t v8 = *(void *)(a1 + 48);
  }
  (*(void (**)(uint64_t, uint64_t, void **))(*(void *)v6 + 72))(v6, 1, __p);
  if (SHIBYTE(v8) < 0) {
    operator delete(__p[0]);
  }
  *(_DWORD *)(a1 + 60) = 1;
  *(unsigned char *)(a1 + 56) = 2;
}

void sub_10026E788(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_10026E7AC(uint64_t a1, int a2, std::string *__str)
{
  long long v3 = __str;
  *(_DWORD *)(a1 + 60) = 2;
  *(unsigned char *)a1 = a2;
  std::string::operator=((std::string *)(a1 + 8), __str);
  if (qword_1009F8080 != -1) {
    dispatch_once(&qword_1009F8080, &stru_1009A0100);
  }
  uint64_t v6 = (void **)(a1 + 32);
  sub_10049FE28((uint64_t)off_1009F8078, (unsigned char *)(a1 + 64), a1 + 32);
  long long v7 = qword_100A19ED8;
  uint64_t v8 = os_log_type_enabled((os_log_t)qword_100A19ED8, OS_LOG_TYPE_DEFAULT);
  if (v8)
  {
    uint64_t v9 = v3;
    if (SHIBYTE(v3->__r_.__value_.__r.__words[2]) < 0) {
      uint64_t v9 = (std::string *)v3->__r_.__value_.__r.__words[0];
    }
    if (*(unsigned char *)(a1 + 64)) {
      uint64_t v10 = "Sign in";
    }
    else {
      uint64_t v10 = "Sign out";
    }
    __int16 v11 = (void *)(a1 + 32);
    if (*(char *)(a1 + 55) < 0) {
      __int16 v11 = *v6;
    }
    *(_DWORD *)long long buf = 67109890;
    int v28 = a2;
    __int16 v29 = 2080;
    __int16 v30 = v9;
    __int16 v31 = 2080;
    uint64_t v32 = v10;
    __int16 v33 = 2080;
    __int16 v34 = v11;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "Received version info request, remote version = %d, remote cloud account = %s, local cloud sign-in status = \"%s\", local cloud account = \"%s\"", buf, 0x26u);
  }
  if (a2)
  {
    uint64_t v12 = HIBYTE(v3->__r_.__value_.__r.__words[2]);
    if (SHIBYTE(v3->__r_.__value_.__r.__words[2]) < 0)
    {
      if (v3->__r_.__value_.__l.__size_)
      {
LABEL_15:
        if (*(unsigned char *)(a1 + 64))
        {
          char v13 = *(unsigned char *)(a1 + 55);
          if (v13 < 0)
          {
            if (*(void *)(a1 + 40))
            {
LABEL_18:
              if ((v12 & 0x80u) == 0) {
                std::string::size_type size = HIBYTE(v3->__r_.__value_.__r.__words[2]);
              }
              else {
                std::string::size_type size = v3->__r_.__value_.__l.__size_;
              }
              unint64_t v15 = *(void *)(a1 + 40);
              if (v13 >= 0) {
                uint64_t v16 = *(unsigned __int8 *)(a1 + 55);
              }
              else {
                uint64_t v16 = *(void *)(a1 + 40);
              }
              if (size == v16)
              {
                char v17 = *v6;
                if (v13 >= 0) {
                  char v18 = (unsigned __int8 *)(a1 + 32);
                }
                else {
                  char v18 = (unsigned __int8 *)*v6;
                }
                if ((v12 & 0x80) == 0)
                {
                  if (*((unsigned char *)&v3->__r_.__value_.__s + 23))
                  {
                    while (v3->__r_.__value_.__s.__data_[0] == *v18)
                    {
                      long long v3 = (std::string *)((char *)v3 + 1);
                      ++v18;
                      if (!--v12) {
                        goto LABEL_44;
                      }
                    }
                    goto LABEL_42;
                  }
                  goto LABEL_44;
                }
                uint64_t v8 = memcmp(v3->__r_.__value_.__l.__data_, v18, v3->__r_.__value_.__l.__size_);
                if (!v8)
                {
LABEL_44:
                  if (v13 < 0)
                  {
                    uint64_t v8 = (uint64_t)sub_10003B098(&v25, v17, v15);
                  }
                  else
                  {
                    long long v25 = *(_OWORD *)v6;
                    uint64_t v26 = *(void *)(a1 + 48);
                  }
                  sub_10026EB08(v8, 1, (void **)&v25, 2);
                  if ((SHIBYTE(v26) & 0x80000000) == 0) {
                    goto LABEL_53;
                  }
                  p_dst = (void **)&v25;
LABEL_52:
                  operator delete(*p_dst);
LABEL_53:
                  int v19 = 4;
                  goto LABEL_54;
                }
              }
LABEL_42:
              if (v13 < 0)
              {
                uint64_t v8 = (uint64_t)sub_10003B098(&__dst, *v6, v15);
              }
              else
              {
                long long __dst = *(_OWORD *)v6;
                uint64_t v24 = *(void *)(a1 + 48);
              }
              sub_10026EB08(v8, 1, (void **)&__dst, 1);
              if ((SHIBYTE(v24) & 0x80000000) == 0) {
                goto LABEL_53;
              }
              p_dst = (void **)&__dst;
              goto LABEL_52;
            }
          }
          else if (*(unsigned char *)(a1 + 55))
          {
            goto LABEL_18;
          }
        }
        int v19 = 3;
LABEL_54:
        *(_DWORD *)(a1 + 60) = v19;
        return;
      }
    }
    else if (*((unsigned char *)&v3->__r_.__value_.__s + 23))
    {
      goto LABEL_15;
    }
    if (*(char *)(a1 + 55) < 0)
    {
      uint64_t v8 = (uint64_t)sub_10003B098(&v21, *(void **)(a1 + 32), *(void *)(a1 + 40));
    }
    else
    {
      long long v21 = *(_OWORD *)v6;
      uint64_t v22 = *(void *)(a1 + 48);
    }
    sub_10026EB08(v8, 1, (void **)&v21, 2);
    if ((SHIBYTE(v22) & 0x80000000) == 0) {
      goto LABEL_53;
    }
    p_dst = (void **)&v21;
    goto LABEL_52;
  }
}

void sub_10026EAB8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, char a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,void *a23,uint64_t a24,int a25,__int16 a26,char a27,char a28)
{
  if (a28 < 0) {
    operator delete(a23);
  }
  _Unwind_Resume(exception_object);
}

void sub_10026EB08(uint64_t a1, uint64_t a2, void **a3, uint64_t a4)
{
  long long v7 = qword_100A19ED8;
  if (os_log_type_enabled((os_log_t)qword_100A19ED8, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v8 = a3;
    if (*((char *)a3 + 23) < 0) {
      uint64_t v8 = *a3;
    }
    uint64_t v9 = "Disallow";
    *(_DWORD *)long long buf = 67109634;
    int v14 = a2;
    __int16 v15 = 2080;
    if (a4 == 2) {
      uint64_t v9 = "Allow";
    }
    uint64_t v16 = v8;
    __int16 v17 = 2080;
    char v18 = v9;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "Sending version info response to magnet device, localVersion = %d, localCloudAccount = \"%s\", easyPairingStatus = \"%s\"", buf, 0x1Cu);
  }
  uint64_t v10 = sub_100373068();
  if (*((char *)a3 + 23) < 0)
  {
    sub_10003B098(__p, *a3, (unint64_t)a3[1]);
  }
  else
  {
    *(_OWORD *)__p = *(_OWORD *)a3;
    uint64_t v12 = a3[2];
  }
  (*(void (**)(uint64_t, uint64_t, void **, uint64_t))(*(void *)v10 + 80))(v10, a2, __p, a4);
  if (SHIBYTE(v12) < 0) {
    operator delete(__p[0]);
  }
}

void sub_10026EC6C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

std::string *sub_10026EC90(uint64_t a1, int a2, const std::string *a3, int a4)
{
  uint64_t v8 = qword_100A19ED8;
  if (os_log_type_enabled((os_log_t)qword_100A19ED8, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v9 = a3;
    if (SHIBYTE(a3->__r_.__value_.__r.__words[2]) < 0) {
      uint64_t v9 = (const std::string *)a3->__r_.__value_.__r.__words[0];
    }
    uint64_t v10 = "Disallow";
    v12[0] = 67109634;
    v12[1] = a2;
    __int16 v13 = 2080;
    if (a4 == 2) {
      uint64_t v10 = "Allow";
    }
    int v14 = v9;
    __int16 v15 = 2080;
    uint64_t v16 = v10;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "Received version info response, remote version = %d, remote cloud account = \"%s\", easyPairingStatus = \"%s\"", (uint8_t *)v12, 0x1Cu);
  }
  *(unsigned char *)(a1 + 56) = a4;
  *(unsigned char *)a1 = a2;
  *(_DWORD *)(a1 + 60) = 5;
  return std::string::operator=((std::string *)(a1 + 8), a3);
}

void sub_10026EDA8(uint64_t a1, uint64_t a2)
{
  __int16 v2 = *(_WORD *)(a2 + 4);
  *(_DWORD *)(a1 + 65) = *(_DWORD *)a2;
  *(_WORD *)(a1 + 69) = v2;
  if (*(unsigned char *)a1 && *(_DWORD *)(a1 + 60) == 3)
  {
    long long v3 = qword_100A19ED8;
    if (os_log_type_enabled((os_log_t)qword_100A19ED8, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long v4 = 0;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Remote device supports version info query and there is pending cloud sign-in on local device. Delay the response for pairing status request", v4, 2u);
    }
  }
  else
  {
    sub_10026EE58(a1, (unsigned __int8 *)(a1 + 65));
  }
}

uint64_t sub_10026EE58(uint64_t a1, unsigned __int8 *a2)
{
  __n128 v18 = 0uLL;
  int v19 = 0;
  sub_100600E3C((uint64_t)&v18);
  if (qword_1009F7F00 != -1) {
    dispatch_once(&qword_1009F7F00, &stru_1009A0120);
  }
  long long v3 = (unsigned __int8 *)sub_1004AA194((uint64_t)off_1009F7EF8, (uint64_t)a2, 0);
  if (!v3) {
    goto LABEL_7;
  }
  if (qword_1009F8778 != -1) {
    dispatch_once(&qword_1009F8778, &stru_1009A0140);
  }
  if (!sub_100618630((uint64_t)off_1009F8770, v3, &v18))
  {
    uint64_t v4 = 2;
    uint64_t v5 = "Paired";
  }
  else
  {
LABEL_7:
    uint64_t v4 = 1;
    uint64_t v5 = "Not Paired";
  }
  uint64_t v6 = qword_100A19ED8;
  if (os_log_type_enabled((os_log_t)qword_100A19ED8, OS_LOG_TYPE_DEFAULT))
  {
    sub_1004A82EC(a2, __p);
    long long v7 = v13 >= 0 ? __p : (void **)__p[0];
    *(_DWORD *)long long buf = 136315394;
    __int16 v15 = v7;
    __int16 v16 = 2080;
    __int16 v17 = v5;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "Sending pair stauts response to magnet device for aacp device \"%s\", pairStatus = \"%s\"", buf, 0x16u);
    if (v13 < 0) {
      operator delete(__p[0]);
    }
  }
  uint64_t v8 = sub_100373068();
  sub_1004A82EC(a2, v10);
  (*(void (**)(uint64_t, void **, uint64_t))(*(void *)v8 + 96))(v8, v10, v4);
  if (v11 < 0) {
    operator delete(v10[0]);
  }
  return nullsub_95(&v18);
}

void sub_10026F054(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,char a22)
{
}

BOOL sub_10026F08C(uint64_t a1)
{
  __int16 v2 = qword_100A19ED8;
  if (os_log_type_enabled((os_log_t)qword_100A19ED8, OS_LOG_TYPE_DEFAULT))
  {
    int v3 = *(unsigned __int8 *)(a1 + 71);
    int v4 = *(_DWORD *)(a1 + 60);
    if (*(unsigned char *)(a1 + 56) == 2) {
      uint64_t v5 = "Allow";
    }
    else {
      uint64_t v5 = "Disallow";
    }
    v7[0] = 67109634;
    v7[1] = v3;
    __int16 v8 = 1024;
    int v9 = v4;
    __int16 v10 = 2080;
    char v11 = v5;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Current MagnetVersion = %d, VersionInfoState = %d, EasyPairingStatus = \"%s\"", (uint8_t *)v7, 0x18u);
  }
  if (*(unsigned __int8 *)(a1 + 71) < 0xAu) {
    return 1;
  }
  if (*(_DWORD *)(a1 + 60) == 5) {
    return *(unsigned char *)(a1 + 56) == 2;
  }
  return 0;
}

void sub_10026F1A0(uint64_t a1, int a2, std::string *__str)
{
  if (*(unsigned __int8 *)(a1 + 64) != a2)
  {
    int v3 = __str;
    *(unsigned char *)(a1 + 64) = a2;
    uint64_t v6 = (unsigned __int8 *)(a1 + 32);
    std::string::operator=((std::string *)(a1 + 32), __str);
    long long v7 = qword_100A19ED8;
    uint64_t v8 = os_log_type_enabled((os_log_t)qword_100A19ED8, OS_LOG_TYPE_DEFAULT);
    if (v8)
    {
      int v9 = "Sign out";
      if (a2) {
        int v9 = "Sign in";
      }
      if (SHIBYTE(v3->__r_.__value_.__r.__words[2]) < 0) {
        int v3 = (std::string *)v3->__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)long long buf = 136315394;
      long long v25 = v9;
      __int16 v26 = 2080;
      uint64_t v27 = v3;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "Cloud sign-in status changed, status = \"%s\", cloudAccount = \"%s\"", buf, 0x16u);
    }
    if (*(_DWORD *)(a1 + 60) == 3)
    {
      unint64_t v10 = *(void *)(a1 + 40);
      if (*(char *)(a1 + 55) >= 0) {
        uint64_t v11 = *(unsigned __int8 *)(a1 + 55);
      }
      else {
        uint64_t v11 = *(void *)(a1 + 40);
      }
      uint64_t v12 = *(unsigned __int8 *)(a1 + 31);
      int v13 = (char)v12;
      if ((v12 & 0x80u) != 0) {
        uint64_t v12 = *(void *)(a1 + 16);
      }
      if (v11 == v12)
      {
        if (v13 >= 0) {
          int v14 = (unsigned __int8 *)(a1 + 8);
        }
        else {
          int v14 = *(unsigned __int8 **)(a1 + 8);
        }
        if ((*(unsigned char *)(a1 + 55) & 0x80) != 0)
        {
          __int16 v17 = *(void **)v6;
          if (memcmp(v17, v14, *(void *)(a1 + 40))) {
            goto LABEL_28;
          }
          uint64_t v8 = (uint64_t)sub_10003B098(&__dst, v17, v10);
        }
        else
        {
          if (*(unsigned char *)(a1 + 55))
          {
            __int16 v15 = v6;
            uint64_t v16 = *(unsigned __int8 *)(a1 + 55);
            while (*v15 == *v14)
            {
              ++v15;
              ++v14;
              if (!--v16) {
                goto LABEL_23;
              }
            }
            goto LABEL_24;
          }
LABEL_23:
          long long __dst = *(_OWORD *)v6;
          uint64_t v23 = *((void *)v6 + 2);
        }
        sub_10026EB08(v8, 1, (void **)&__dst, 2);
        if (SHIBYTE(v23) < 0)
        {
          p_dst = (void **)&__dst;
          goto LABEL_34;
        }
LABEL_35:
        *(_DWORD *)(a1 + 60) = 4;
        sub_10026EE58(v18, (unsigned __int8 *)(a1 + 65));
        return;
      }
LABEL_24:
      if ((*(unsigned char *)(a1 + 55) & 0x80) == 0)
      {
        long long v20 = *(_OWORD *)v6;
        uint64_t v21 = *((void *)v6 + 2);
        goto LABEL_29;
      }
      __int16 v17 = *(void **)v6;
LABEL_28:
      uint64_t v8 = (uint64_t)sub_10003B098(&v20, v17, v10);
LABEL_29:
      sub_10026EB08(v8, 1, (void **)&v20, 1);
      if (SHIBYTE(v21) < 0)
      {
        p_dst = (void **)&v20;
LABEL_34:
        operator delete(*p_dst);
        goto LABEL_35;
      }
      goto LABEL_35;
    }
  }
}

void sub_10026F3E4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0) {
    operator delete(a16);
  }
  _Unwind_Resume(exception_object);
}

void sub_10026F420(id a1)
{
}

void sub_10026F464()
{
}

void sub_10026F488(id a1)
{
}

void sub_10026F4CC()
{
}

void sub_10026F4F0(id a1)
{
}

void sub_10026F534()
{
}

uint64_t sub_10026F558(uint64_t a1, unint64_t a2)
{
  _DWORD v12[2] = a2;
  if (a2)
  {
    v12[0] = 0;
    v12[1] = 0;
    sub_10003AED0((uint64_t)v12, a1);
    uint64_t v6 = *(void **)(a1 + 72);
    uint64_t v5 = a1 + 72;
    int v4 = v6;
    if (!v6) {
      goto LABEL_13;
    }
    long long v7 = (void *)v5;
    do
    {
      unint64_t v8 = v4[4];
      BOOL v9 = v8 >= a2;
      if (v8 >= a2) {
        unint64_t v10 = v4;
      }
      else {
        unint64_t v10 = v4 + 1;
      }
      if (v9) {
        long long v7 = v4;
      }
      int v4 = (void *)*v10;
    }
    while (*v10);
    if (v7 == (void *)v5 || v7[4] > a2) {
LABEL_13:
    }
      operator new();
    sub_10003AFB4((uint64_t)v12);
    return 0;
  }
  else
  {
    if (os_log_type_enabled((os_log_t)qword_100A19F78, OS_LOG_TYPE_ERROR)) {
      sub_10074C168();
    }
    return 3;
  }
}

void sub_10026F6C8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, char a16)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  sub_10003AFB4((uint64_t)&a16);
  _Unwind_Resume(a1);
}

uint64_t sub_10026F6F8(uint64_t a1, unint64_t a2)
{
  unint64_t v16 = a2;
  if (a2)
  {
    v15[0] = 0;
    v15[1] = 0;
    sub_10003AED0((uint64_t)v15, a1);
    uint64_t v6 = *(void **)(a1 + 72);
    uint64_t v5 = a1 + 72;
    int v4 = v6;
    if (!v6) {
      goto LABEL_13;
    }
    long long v7 = (void *)v5;
    do
    {
      unint64_t v8 = v4[4];
      BOOL v9 = v8 >= a2;
      if (v8 >= a2) {
        unint64_t v10 = v4;
      }
      else {
        unint64_t v10 = v4 + 1;
      }
      if (v9) {
        long long v7 = v4;
      }
      int v4 = (void *)*v10;
    }
    while (*v10);
    if (v7 != (void *)v5 && v7[4] <= a2)
    {
      v14[0] = (uint64_t *)&v16;
      if (sub_1000097B0((uint64_t **)(v5 - 8), &v16, (uint64_t)&unk_1007BE9D0, v14)[5]) {
        operator delete();
      }
      sub_1000517A4(v5 - 8, &v16);
      uint64_t v12 = 0;
    }
    else
    {
LABEL_13:
      uint64_t v11 = (id)qword_100A19F78;
      if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
      {
        sub_100475EE0(a2, (uint64_t)v14);
        sub_10074C19C();
      }

      uint64_t v12 = 3;
    }
    sub_10003AFB4((uint64_t)v15);
  }
  else
  {
    if (os_log_type_enabled((os_log_t)qword_100A19F78, OS_LOG_TYPE_ERROR)) {
      sub_10074C168();
    }
    return 3;
  }
  return v12;
}

void sub_10026F880(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  sub_10003AFB4((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_10026F8A8(uint64_t a1, unint64_t a2, int a3, int a4)
{
  unint64_t v20 = a2;
  if (!a2)
  {
    if (os_log_type_enabled((os_log_t)qword_100A19F78, OS_LOG_TYPE_ERROR)) {
      sub_10074C1F4();
    }
    return 3;
  }
  if (a3 >= 1)
  {
    if (os_log_type_enabled((os_log_t)qword_100A19F78, OS_LOG_TYPE_ERROR)) {
      sub_10074C228();
    }
    return 3;
  }
  v19[0] = 0;
  v19[1] = 0;
  sub_10003AED0((uint64_t)v19, a1);
  uint64_t v11 = *(void **)(a1 + 72);
  uint64_t v10 = a1 + 72;
  BOOL v9 = v11;
  if (!v11) {
    goto LABEL_19;
  }
  uint64_t v12 = (void *)v10;
  do
  {
    unint64_t v13 = v9[4];
    BOOL v14 = v13 >= a2;
    if (v13 >= a2) {
      __int16 v15 = v9;
    }
    else {
      __int16 v15 = v9 + 1;
    }
    if (v14) {
      uint64_t v12 = v9;
    }
    BOOL v9 = (void *)*v15;
  }
  while (*v15);
  if (v12 != (void *)v10 && v12[4] <= a2)
  {
    if (a3)
    {
      uint64_t v5 = 0;
    }
    else
    {
      uint64_t v18 = qword_100A19F78;
      if (os_log_type_enabled((os_log_t)qword_100A19F78, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)long long buf = 67109120;
        *(_DWORD *)&uint8_t buf[4] = a4;
        _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "BTLQ set Link Quality Data codec to %u", buf, 8u);
      }
      *(void *)long long buf = &v20;
      uint64_t v5 = 0;
      *(_WORD *)(sub_1000097B0((uint64_t **)(v10 - 8), &v20, (uint64_t)&unk_1007BE9D0, (uint64_t **)buf)[5] + 10) = a4;
    }
  }
  else
  {
LABEL_19:
    unint64_t v16 = (id)qword_100A19F78;
    if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
    {
      sub_100475EE0(a2, (uint64_t)buf);
      sub_10074C25C();
    }

    uint64_t v5 = 7;
  }
  sub_10003AFB4((uint64_t)v19);
  return v5;
}

void sub_10026FAAC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_10003AFB4((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_10026FAD4(uint64_t a1, _WORD *a2)
{
  if (a2)
  {
    v13[0] = 0;
    v13[1] = 0;
    sub_10003AED0((uint64_t)v13, a1);
    int v4 = *(void **)(a1 + 64);
    uint64_t v5 = a1 + 72;
    if (v4 == (void *)v5)
    {
      __int16 v10 = 0;
    }
    else
    {
      unint64_t v6 = 0;
      do
      {
        memcpy(&a2[134 * v6 + 1], (const void *)v4[5], 0x10CuLL);
        long long v7 = (void *)v4[1];
        unint64_t v8 = v4;
        if (v7)
        {
          do
          {
            int v4 = v7;
            long long v7 = (void *)*v7;
          }
          while (v7);
        }
        else
        {
          do
          {
            int v4 = (void *)v8[2];
            BOOL v9 = *v4 == (void)v8;
            unint64_t v8 = v4;
          }
          while (!v9);
        }
        __int16 v10 = v6 + 1;
        if (v4 == (void *)v5) {
          break;
        }
      }
      while (v6++ < 2);
    }
    *a2 = v10;
    sub_10003AFB4((uint64_t)v13);
    return 0;
  }
  else
  {
    if (os_log_type_enabled((os_log_t)qword_100A19F78, OS_LOG_TYPE_ERROR)) {
      sub_10074C2B4();
    }
    return 3;
  }
}

id sub_10026FBE0(uint64_t a1)
{
  v18[0] = 0;
  v18[1] = 0;
  sub_10003AED0((uint64_t)v18, a1);
  __int16 v2 = *(void **)(a1 + 64);
  int v3 = (void *)(a1 + 72);
  if (v2 == (void *)(a1 + 72))
  {
    id v16 = 0;
  }
  else
  {
    id v4 = objc_alloc_init((Class)NSMutableArray);
    do
    {
      uint64_t v5 = (unsigned __int8 *)v2[5];
      id v6 = objc_alloc_init((Class)CBAudioLinkQualityInfo);
      [v6 setAosState:*v5];
      [v6 setBitRate:1000 * *((unsigned __int16 *)v5 + 3)];
      int v7 = *((unsigned __int16 *)v5 + 5);
      if (v7 == 33023) {
        unsigned int v8 = 30;
      }
      else {
        unsigned int v8 = 0;
      }
      if (v7 == 2) {
        unsigned int v8 = 20;
      }
      if (*((_WORD *)v5 + 5)) {
        uint64_t v9 = v8;
      }
      else {
        uint64_t v9 = 10;
      }
      [v6 setCodecType:v9];
      __int16 v10 = +[NSString stringWithUTF8String:v5 + 12];
      [v6 setDeviceName:v10];

      [v6 setBtBand:v5[1]];
      LOWORD(v11) = *((_WORD *)v5 + 4);
      [v6 setJitterBufferSeconds:(double)v11 / 1000.0];
      [v6 setNoiseFloor90:(char)v5[4]];
      LOBYTE(v12) = v5[2];
      [v6 setRetransmitRate:(double)v12 / 100.0];
      [v6 setRssiAverage:(char)v5[3]];
      [v6 setSignalToNoiseRatio:(char)v5[5]];
      [v4 addObject:v6];

      unint64_t v13 = (void *)v2[1];
      if (v13)
      {
        do
        {
          BOOL v14 = v13;
          unint64_t v13 = (void *)*v13;
        }
        while (v13);
      }
      else
      {
        do
        {
          BOOL v14 = (void *)v2[2];
          BOOL v15 = *v14 == (void)v2;
          __int16 v2 = v14;
        }
        while (!v15);
      }
      __int16 v2 = v14;
    }
    while (v14 != v3);
    id v16 = [v4 copy];
  }
  sub_10003AFB4((uint64_t)v18);

  return v16;
}

void sub_10026FDD0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  sub_10003AFB4((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t sub_10026FE14(uint64_t a1, unint64_t a2, uint64_t a3, __int16 a4, __int16 a5)
{
  unint64_t v30 = a2;
  if (a2 && a3)
  {
    v29[0] = 0;
    v29[1] = 0;
    sub_10003AED0((uint64_t)v29, a1);
    unint64_t v12 = *(void **)(a1 + 72);
    uint64_t v11 = a1 + 72;
    __int16 v10 = v12;
    if (!v12) {
      goto LABEL_14;
    }
    unint64_t v13 = (uint64_t **)(v11 - 8);
    BOOL v14 = (void *)v11;
    do
    {
      unint64_t v15 = v10[4];
      BOOL v16 = v15 >= a2;
      if (v15 >= a2) {
        __int16 v17 = v10;
      }
      else {
        __int16 v17 = v10 + 1;
      }
      if (v16) {
        BOOL v14 = v10;
      }
      __int16 v10 = (void *)*v17;
    }
    while (*v17);
    if (v14 != (void *)v11 && v14[4] <= a2)
    {
      v28[0] = (uint64_t *)&v30;
      uint64_t v22 = sub_1000097B0((uint64_t **)(v11 - 8), &v30, (uint64_t)&unk_1007BE9D0, v28)[5];
      if (v22)
      {
        unsigned int v23 = *(unsigned __int16 *)(a3 + 16);
        if (*(_WORD *)(a3 + 16)) {
          unsigned int v23 = 100 * *(unsigned __int16 *)(a3 + 18) / v23;
        }
        *(unsigned char *)(v22 + 2) = v23;
        *(unsigned char *)uint64_t v22 = *(unsigned char *)(v30 + 1371);
        v28[0] = (uint64_t *)&v30;
        if (!*(unsigned char *)(sub_1000097B0(v13, &v30, (uint64_t)&unk_1007BE9D0, v28)[5] + 1))
        {
          uint64_t v24 = sub_100197B9C(v30 + 128);
          if (v24)
          {
            unsigned int v25 = *(unsigned __int8 *)(v24 + 289);
            if (v25 <= 1) {
              LOBYTE(v25) = 1;
            }
          }
          else
          {
            LOBYTE(v25) = 1;
          }
          *(unsigned char *)(v22 + 1) = v25;
        }
        uint64_t v19 = 0;
        char v26 = *(unsigned char *)(a3 + 6);
        *(unsigned char *)(v22 + 3) = v26;
        char v27 = *(unsigned char *)(a3 + 219);
        *(unsigned char *)(v22 + 4) = v27;
        *(unsigned char *)(v22 + 5) = v26 - v27;
        *(_WORD *)(v22 + 6) = a4;
        *(_WORD *)(v22 + 8) = a5;
      }
      else
      {
        uint64_t v19 = 7;
      }
    }
    else
    {
LABEL_14:
      uint64_t v18 = (id)qword_100A19F78;
      if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
      {
        sub_100475EE0(a2, (uint64_t)v28);
        sub_10074C2E8();
      }

      uint64_t v19 = 3;
    }
    sub_10003AFB4((uint64_t)v29);
  }
  else
  {
    unint64_t v20 = qword_100A19F78;
    if (os_log_type_enabled((os_log_t)qword_100A19F78, OS_LOG_TYPE_ERROR)) {
      sub_10074C340(a2, v20);
    }
    return 3;
  }
  return v19;
}

void sub_100270040(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  sub_10003AFB4((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_10027006C(uint64_t a1, uint64_t a2, char a3)
{
  if (qword_1009F80B0 != -1) {
    dispatch_once(&qword_1009F80B0, &stru_1009A0180);
  }
  id v6 = *((void *)off_1009F80A8 + 32);
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_10027012C;
  block[3] = &unk_1009A0160;
  void block[4] = a1;
  void block[5] = a2;
  char v8 = a3;
  dispatch_async(v6, block);
}

void sub_10027012C(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (qword_1009F80B0 != -1) {
    dispatch_once(&qword_1009F80B0, &stru_1009A0180);
  }
  int v3 = (void *)*((void *)off_1009F80A8 + 25);
  if (v3)
  {
    id v4 = (uint64_t *)(a1 + 40);
    unint64_t v5 = *(void *)(a1 + 40);
    id v6 = (char *)off_1009F80A8 + 200;
    do
    {
      unint64_t v7 = v3[4];
      BOOL v8 = v7 >= v5;
      if (v7 >= v5) {
        uint64_t v9 = v3;
      }
      else {
        uint64_t v9 = v3 + 1;
      }
      if (v8) {
        id v6 = (char *)v3;
      }
      int v3 = (void *)*v9;
    }
    while (*v9);
    if (v6 != (char *)off_1009F80A8 + 200 && v5 >= *((void *)v6 + 4))
    {
      char v10 = *(unsigned char *)(a1 + 48);
      uint64_t v11 = v4;
      *(unsigned char *)sub_1000097B0((uint64_t **)(v2 + 64), (unint64_t *)v4, (uint64_t)&unk_1007BE9D0, &v11)[5] = v10;
    }
  }
}

void sub_1002701F4(uint64_t a1, uint64_t a2, char a3)
{
  if (qword_1009F80B0 != -1) {
    dispatch_once(&qword_1009F80B0, &stru_1009A0180);
  }
  id v6 = *((void *)off_1009F80A8 + 32);
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_1002702B4;
  block[3] = &unk_1009A0160;
  void block[4] = a1;
  void block[5] = a2;
  char v8 = a3;
  dispatch_async(v6, block);
}

void sub_1002702B4(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (qword_1009F80B0 != -1) {
    dispatch_once(&qword_1009F80B0, &stru_1009A0180);
  }
  int v3 = (void *)*((void *)off_1009F80A8 + 25);
  if (v3)
  {
    id v4 = (uint64_t *)(a1 + 40);
    unint64_t v5 = *(void *)(a1 + 40);
    id v6 = (char *)off_1009F80A8 + 200;
    do
    {
      unint64_t v7 = v3[4];
      BOOL v8 = v7 >= v5;
      if (v7 >= v5) {
        uint64_t v9 = v3;
      }
      else {
        uint64_t v9 = v3 + 1;
      }
      if (v8) {
        id v6 = (char *)v3;
      }
      int v3 = (void *)*v9;
    }
    while (*v9);
    if (v6 != (char *)off_1009F80A8 + 200 && v5 >= *((void *)v6 + 4))
    {
      char v10 = *(unsigned char *)(a1 + 48);
      uint64_t v11 = v4;
      *(unsigned char *)(sub_1000097B0((uint64_t **)(v2 + 64), (unint64_t *)v4, (uint64_t)&unk_1007BE9D0, &v11)[5] + 1) = v10;
    }
  }
}

void sub_10027037C(id a1)
{
}

void sub_1002703C0()
{
}

void sub_100270484(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1002706DC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_10027074C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1002707B4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100270B78(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, id location,char a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,void *a26)
{
  objc_destroyWeak(v29);
  objc_destroyWeak(v28);
  _Block_object_dispose(&a21, 8);

  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_100270BF4(uint64_t a1, int a2, void *a3)
{
  id v6 = a3;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  if (WeakRetained)
  {
    BOOL v8 = qword_100A19FE8;
    if (os_log_type_enabled((os_log_t)qword_100A19FE8, OS_LOG_TYPE_DEFAULT))
    {
      int v21 = 67109120;
      LODWORD(v22) = a2;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "[BTVCBonjourService] advertiser state handler with state %d", (uint8_t *)&v21, 8u);
    }
    if (v6)
    {
      uint64_t v9 = qword_100A19FE8;
      if (os_log_type_enabled((os_log_t)qword_100A19FE8, OS_LOG_TYPE_DEFAULT))
      {
        int v21 = 138412290;
        id v22 = v6;
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "[BTVCBonjourService] advertiser error %@", (uint8_t *)&v21, 0xCu);
      }
    }
    switch(a2)
    {
      case 4:
        BOOL v14 = qword_100A19FE8;
        if (os_log_type_enabled((os_log_t)qword_100A19FE8, OS_LOG_TYPE_DEFAULT))
        {
          LOWORD(v21) = 0;
          _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "[BTVCBonjourService] advertiser cancelled", (uint8_t *)&v21, 2u);
        }
        [WeakRetained setListener:0];
        [WeakRetained _cleanupAdvertiser];
        unint64_t v15 = *(NSObject **)(*(void *)(*(void *)(a1 + 32) + 8) + 40);
        if (v15) {
          uint64_t v13 = (uint64_t)nw_error_copy_cf_error(v15);
        }
        else {
          uint64_t v13 = 0;
        }
        BOOL v16 = [WeakRetained advertisingStateUpdateHandler];
        BOOL v17 = v16 == 0;

        if (!v17)
        {
          uint64_t v18 = [WeakRetained advertisingStateUpdateHandler];
          v18[2](v18, 0, v13);
        }
        uint64_t v19 = *(void *)(*(void *)(a1 + 32) + 8);
        unint64_t v20 = *(void **)(v19 + 40);
        *(void *)(v19 + 40) = 0;

        goto LABEL_25;
      case 3:
        if (os_log_type_enabled((os_log_t)qword_100A19FE8, OS_LOG_TYPE_ERROR)) {
          sub_10074C404();
        }
        objc_storeStrong((id *)(*(void *)(*(void *)(a1 + 32) + 8) + 40), a3);
        uint64_t v13 = [WeakRetained listener];
        nw_listener_cancel((nw_listener_t)v13);
        goto LABEL_25;
      case 2:
        char v10 = qword_100A19FE8;
        if (os_log_type_enabled((os_log_t)qword_100A19FE8, OS_LOG_TYPE_DEFAULT))
        {
          LOWORD(v21) = 0;
          _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "[BTVCBonjourService] advertiser is ready", (uint8_t *)&v21, 2u);
        }
        [WeakRetained setAdvertiserState:2];
        uint64_t v11 = [WeakRetained advertisingStateUpdateHandler];
        BOOL v12 = v11 == 0;

        if (!v12)
        {
          uint64_t v13 = [WeakRetained advertisingStateUpdateHandler];
          (*(void (**)(uint64_t, uint64_t, void))(v13 + 16))(v13, 1, 0);
LABEL_25:
        }
        break;
    }
  }
}

void sub_100270EE0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100270F2C(uint64_t a1, void *a2)
{
  id v3 = a2;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  unint64_t v5 = [WeakRetained _handleConnection:v3 isAdvToBrowserConnection:1];

  id v6 = qword_100A19FE8;
  if (os_log_type_enabled((os_log_t)qword_100A19FE8, OS_LOG_TYPE_DEFAULT))
  {
    int v7 = 138412546;
    id v8 = v3;
    __int16 v9 = 2112;
    char v10 = v5;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "[BTVCBonjourService] New Adv to browser connection %@ (endpoint %@)", (uint8_t *)&v7, 0x16u);
  }
}

void sub_100271018(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100271188(uint64_t a1)
{
  uint64_t v2 = [*(id *)(a1 + 32) advertiserAdvs];
  unsigned int v3 = [v2 containsObject:*(void *)(a1 + 40)];

  if (v3)
  {
    id v4 = qword_100A19FE8;
    if (os_log_type_enabled((os_log_t)qword_100A19FE8, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v5 = *(void *)(a1 + 40);
      int v13 = 138412290;
      uint64_t v14 = v5;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "[BTVCBonjourService] Already advertising for advData %@", (uint8_t *)&v13, 0xCu);
    }
  }
  else
  {
    id v6 = [*(id *)(a1 + 32) advertiserAdvs];
    [v6 addObject:*(void *)(a1 + 40)];

    int v7 = qword_100A19FE8;
    if (os_log_type_enabled((os_log_t)qword_100A19FE8, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v8 = *(void *)(a1 + 40);
      int v13 = 138412290;
      uint64_t v14 = v8;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "[BTVCBonjourService] Starting advertising with advData %@", (uint8_t *)&v13, 0xCu);
    }
    unsigned int v9 = [*(id *)(a1 + 32) advertiserState];
    char v10 = *(unsigned char **)(a1 + 32);
    if (v9 == 3)
    {
      v10[25] = 1;
    }
    else
    {
      unsigned int v11 = [v10 advertiserState];
      BOOL v12 = *(void **)(a1 + 32);
      if (v11 == 2) {
        [v12 _sendAdvMessageWithData:*(void *)(a1 + 40) isStart:1 completionHandler:*(void *)(a1 + 48)];
      }
      else {
        [v12 _startAdvertiser];
      }
    }
  }
}

void sub_100271320(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100271450(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id sub_100271530(uint64_t a1)
{
  unsigned __int8 v2 = [*(id *)(*(void *)(a1 + 32) + 160) containsObject:*(void *)(a1 + 40)];
  unsigned int v3 = qword_100A19FE8;
  BOOL v4 = os_log_type_enabled((os_log_t)qword_100A19FE8, OS_LOG_TYPE_DEFAULT);
  if (v2)
  {
    if (v4)
    {
      uint64_t v5 = *(void *)(a1 + 40);
      int v9 = 138412290;
      uint64_t v10 = v5;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "[BTVCBonjourService] Stop advertising for advData %@", (uint8_t *)&v9, 0xCu);
    }
    if ([*(id *)(a1 + 32) advertiserState] == 2) {
      [*(id *)(a1 + 32) _sendAdvMessageWithData:*(void *)(a1 + 40) isStart:0 completionHandler:*(void *)(a1 + 48)];
    }
    [*(id *)(*(void *)(a1 + 32) + 160) removeObject:*(void *)(a1 + 40)];
    id result = [*(id *)(*(void *)(a1 + 32) + 160) count];
    if (!result)
    {
      int v7 = qword_100A19FE8;
      if (os_log_type_enabled((os_log_t)qword_100A19FE8, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(v9) = 0;
        _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "[BTVCBonjourService] No more advertisements, stopping advertiser completely.", (uint8_t *)&v9, 2u);
      }
      *(unsigned char *)(*(void *)(a1 + 32) + 25) = 0;
      return [*(id *)(a1 + 32) _stopAdvertising];
    }
  }
  else
  {
    if (v4)
    {
      uint64_t v8 = *(void *)(a1 + 40);
      int v9 = 138412290;
      uint64_t v10 = v8;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "[BTVCBonjourService] Unable to stop advertising for advData %@", (uint8_t *)&v9, 0xCu);
    }
    id result = *(id *)(a1 + 48);
    if (result) {
      return (id)(*((uint64_t (**)(id, void, void))result + 2))(result, *(void *)(a1 + 40), 0);
    }
  }
  return result;
}

void sub_100271780(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100271790(id a1, id a2, BTVCBonjourEndpoint *a3, BOOL *a4)
{
  BOOL v4 = a3;
  if (![(BTVCBonjourEndpoint *)v4 isConnected]) {
    [(BTVCBonjourEndpoint *)v4 cancel];
  }
}

void sub_1002717E0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_100271894(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

BOOL sub_1002718B4(id a1, id a2, BTVCBonjourEndpoint *a3, BOOL *a4)
{
  return ![(BTVCBonjourEndpoint *)a3 isConnected];
}

void sub_100271B5C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, id location)
{
  objc_destroyWeak(v22);
  objc_destroyWeak(v21);
  objc_destroyWeak(&location);

  _Unwind_Resume(a1);
}

void sub_100271BBC(uint64_t a1, int a2, void *a3)
{
  id v5 = a3;
  id v6 = qword_100A19FE8;
  if (os_log_type_enabled((os_log_t)qword_100A19FE8, OS_LOG_TYPE_DEFAULT))
  {
    v13[0] = 67109378;
    v13[1] = a2;
    __int16 v14 = 2112;
    id v15 = v5;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "[BTVCBonjourService] nw_browser_state_t changed:%d error:%@", (uint8_t *)v13, 0x12u);
  }
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  uint64_t v8 = WeakRetained;
  if (WeakRetained)
  {
    if ((a2 - 2) >= 2)
    {
      if (a2 == 1)
      {
        [WeakRetained setBrowserState:2];
        int v9 = qword_100A19FE8;
        if (os_log_type_enabled((os_log_t)qword_100A19FE8, OS_LOG_TYPE_DEFAULT))
        {
          LOWORD(v13[0]) = 0;
          _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "[BTVCBonjourService] BTVCBonjourServiceBrowser successfully started", (uint8_t *)v13, 2u);
        }
        uint64_t v10 = [v8 deviceDidStartScanning];
        BOOL v11 = v10 == 0;

        if (!v11)
        {
          BOOL v12 = [v8 deviceDidStartScanning];
          v12[2](v12, 0);
        }
      }
    }
    else
    {
      [WeakRetained setBrowser:0];
      [v8 _cleanupBrowser];
    }
  }
}

void sub_100271D54(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100271D7C(uint64_t a1, void *a2, void *a3, int a4)
{
  old_id result = a2;
  int v7 = a3;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  if (WeakRetained)
  {
    nw_browse_result_change_t changes = nw_browse_result_get_changes(old_result, v7);
    if (changes >= 2)
    {
      uint64_t v10 = [[BTVCBonjourBrowserResultChanges alloc] initWithOldResult:old_result freshResult:v7 change:changes];
      BOOL v11 = [WeakRetained resultChanges];
      [v11 addObject:v10];

      if (a4)
      {
        BOOL v12 = [WeakRetained resultChanges];
        id v13 = [v12 copy];

        __int16 v14 = [WeakRetained resultChanges];
        [v14 removeAllObjects];

        [WeakRetained handleBrowseResults:v13];
      }
    }
  }
}

void sub_100271E98(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  id v15 = v13;

  _Unwind_Resume(a1);
}

unsigned char *sub_100271F70(uint64_t a1)
{
  unsigned int v2 = [*(id *)(a1 + 32) browserState];
  id result = *(unsigned char **)(a1 + 32);
  if (v2 == 3)
  {
    result[24] = 1;
  }
  else
  {
    unsigned int v4 = [result browserState];
    id v5 = *(void **)(a1 + 32);
    if (v4 == 2)
    {
      return [v5 _reportCachedDiscoveryResults];
    }
    else
    {
      return [v5 _startBrowser];
    }
  }
  return result;
}

void sub_100272110(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id sub_10027219C(uint64_t a1)
{
  return [*(id *)(a1 + 32) _stopBrowser];
}

void sub_100272254(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  unsigned int v2 = WeakRetained;
  if (WeakRetained && [WeakRetained browserState] == 2)
  {
    unsigned int v3 = [v2 browserToAdvNwToSFendpoints];
    v4[0] = _NSConcreteStackBlock;
    v4[1] = 3221225472;
    _DWORD v4[2] = sub_100272324;
    v4[3] = &unk_1009A02F0;
    v4[4] = v2;
    [v3 enumerateKeysAndObjectsUsingBlock:v4];
  }
}

void sub_100272308(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100272324(uint64_t a1, uint64_t a2, void *a3)
{
  id v11 = a3;
  unsigned int v4 = [*(id *)(a1 + 32) deviceFoundHandler];

  if (v4)
  {
    id v5 = [*(id *)(a1 + 32) deviceFoundHandler];
    id v6 = objc_alloc((Class)NSUUID);
    int v7 = [v11 remoteUniqueIDString];
    id v8 = [v6 initWithUUIDString:v7];
    int v9 = [v11 remoteAdvDataSet];
    uint64_t v10 = [v9 allObjects];
    ((void (**)(void, id, void *))v5)[2](v5, v8, v10);
  }
}

void sub_100272418(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  id v15 = v13;

  _Unwind_Resume(a1);
}

void sub_100272544(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100272558(id a1, id a2, BTVCBonjourEndpoint *a3, BOOL *a4)
{
  unsigned int v4 = a3;
  if (![(BTVCBonjourEndpoint *)v4 isConnected]) {
    [(BTVCBonjourEndpoint *)v4 cancel];
  }
}

void sub_1002725A8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_10027268C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL sub_1002726A8(id a1, id a2, BTVCBonjourEndpoint *a3, BOOL *a4)
{
  return ![(BTVCBonjourEndpoint *)a3 isConnected];
}

void sub_100272A30(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100272DF8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id *location)
{
  _Unwind_Resume(a1);
}

void sub_100272E98(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  unsigned int v3 = (id *)objc_loadWeakRetained((id *)(a1 + 40));
  if (v3 && WeakRetained)
  {
    unsigned int v4 = [WeakRetained remoteUniqueIDString];

    if (v4)
    {
      id v5 = (id)qword_100A19FE8;
      if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR)) {
        sub_10074C5B8((uint64_t)[WeakRetained isAdvToBrowserConnection], (uint64_t)WeakRetained, (uint64_t)&v10);
      }

      if (*(unsigned char *)(a1 + 48)) {
        [v3 advToBrowserUuidToSFendpoints];
      }
      else {
      id v6 = [v3 browserToAdvUuidToSFendpoints];
      }
      int v7 = [WeakRetained remoteUniqueIDString];
      [v6 setObject:WeakRetained forKey:v7];

      if ([WeakRetained isAdvToBrowserConnection])
      {
        id v8 = [v3[20] allObjects];
        int v9 = [WeakRetained remoteUniqueIDString];
        [v3 _sendMessage:v8 withType:@"BTVCBonjourServiceMessageTypeStartAdvertiseData" toDevice:v9 completionCallback:&stru_1009A0378];
      }
    }
    else if (os_log_type_enabled((os_log_t)qword_100A19FE8, OS_LOG_TYPE_ERROR))
    {
      sub_10074C550();
    }
  }
}

void sub_100273060(_Unwind_Exception *a1)
{
  id v5 = v3;

  _Unwind_Resume(a1);
}

void sub_1002730E0(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  id v3 = objc_loadWeakRetained((id *)(a1 + 40));
  unsigned int v4 = v3;
  if (!WeakRetained || !v3) {
    goto LABEL_20;
  }
  id v5 = (id)qword_100A19FE8;
  if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR)) {
    sub_10074C608((uint64_t)[v4 isAdvToBrowserConnection], (uint64_t)v4, (uint64_t)&v29);
  }

  id v6 = [v4 remoteUniqueIDString];
  BOOL v7 = v6 == 0;

  if (!v7)
  {
    id v8 = [WeakRetained deviceDidDisconnectHandler];
    if (v8)
    {
      unsigned int v9 = [v4 isConnected];

      if (v9)
      {
        uint64_t v10 = [WeakRetained deviceDidDisconnectHandler];
        id v11 = objc_alloc((Class)NSUUID);
        BOOL v12 = [v4 remoteUniqueIDString];
        id v13 = [v11 initWithUUIDString:v12];
        ((void (**)(void, id))v10)[2](v10, v13);
LABEL_12:

        goto LABEL_13;
      }
    }
    __int16 v14 = [WeakRetained deviceLostHandler];
    if (v14)
    {
      unsigned __int8 v15 = [v4 isAdvToBrowserConnection];

      if ((v15 & 1) == 0)
      {
        uint64_t v10 = [WeakRetained deviceLostHandler];
        id v16 = objc_alloc((Class)NSUUID);
        BOOL v12 = [v4 remoteUniqueIDString];
        id v13 = [v16 initWithUUIDString:v12];
        ((void (*)(void (**)(void, void), id, void))v10[2])(v10, v13, 0);
        goto LABEL_12;
      }
    }
  }
LABEL_13:
  if ([v4 isAdvToBrowserConnection])
  {
    BOOL v17 = [WeakRetained advToBrowserNwToSFendpoints];
    uint64_t v18 = [v4 remoteEndpoint];
    [v17 removeObjectForKey:v18];

    uint64_t v19 = [v4 remoteUniqueIDString];
    BOOL v20 = v19 == 0;

    if (!v20)
    {
      int v21 = [WeakRetained advToBrowserUuidToSFendpoints];
      id v22 = [v4 remoteUniqueIDString];
      [v21 removeObjectForKey:v22];
    }
    [WeakRetained _updateAdvertiserState];
  }
  else
  {
    unsigned int v23 = [WeakRetained browserToAdvNwToSFendpoints];
    uint64_t v24 = [v4 remoteEndpoint];
    [v23 removeObjectForKey:v24];

    unsigned int v25 = [v4 remoteUniqueIDString];
    BOOL v26 = v25 == 0;

    if (!v26)
    {
      char v27 = [WeakRetained browserToAdvUuidToSFendpoints];
      int v28 = [v4 remoteUniqueIDString];
      [v27 removeObjectForKey:v28];
    }
    [WeakRetained _updateBrowserState];
  }
LABEL_20:
}

void sub_1002733F8(_Unwind_Exception *a1)
{
  id v6 = v3;

  _Unwind_Resume(a1);
}

void sub_1002734E8(uint64_t a1, void *a2)
{
  id v3 = a2;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  id v5 = objc_loadWeakRetained((id *)(a1 + 40));
  id v6 = v5;
  if (WeakRetained && v5)
  {
    uint64_t v51 = 0;
    BOOL v7 = +[NSPropertyListSerialization propertyListWithData:v3 options:0 format:&v51 error:0];
    if (v7)
    {
      id v8 = [v6 remoteUniqueIDString];
      BOOL v9 = v8 == 0;

      uint64_t v10 = qword_100A19FE8;
      if (v9)
      {
        if (os_log_type_enabled((os_log_t)qword_100A19FE8, OS_LOG_TYPE_ERROR)) {
          sub_10074C6C8();
        }
      }
      else
      {
        if (os_log_type_enabled((os_log_t)qword_100A19FE8, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)long long buf = 138412546;
          int v53 = v7;
          __int16 v54 = 2112;
          int v55 = v6;
          _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "[BTVCBonjourService] Received browser endpoint message %@ from endpoint %@", buf, 0x16u);
        }
        id v11 = [v7 objectForKeyedSubscript:@"BTVCBonjourServiceMessageType"];
        if ([v11 isEqualToString:@"BTVCBonjourServiceMessageTypeStartAdvertiseData"])
        {
          BOOL v12 = [v6 remoteAdvDataSet];
          id v13 = [v7 objectForKeyedSubscript:@"BTVCBonjourServiceMessageValue"];
          [v12 addObjectsFromArray:v13];

          __int16 v14 = [WeakRetained deviceFoundHandler];
          BOOL v15 = v14 == 0;

          if (!v15)
          {
            id v16 = [WeakRetained deviceFoundHandler];
            id v17 = objc_alloc((Class)NSUUID);
            uint64_t v18 = [v6 remoteUniqueIDString];
            id v19 = [v17 initWithUUIDString:v18];
            BOOL v20 = [v7 objectForKeyedSubscript:@"BTVCBonjourServiceMessageValue"];
            ((void (**)(void, id, void *))v16)[2](v16, v19, v20);
          }
        }
        else if ([v11 isEqualToString:@"BTVCBonjourServiceMessageTypeStopAdvertiseData"])
        {
          int v21 = [v6 remoteAdvDataSet];
          id v22 = [v7 objectForKeyedSubscript:@"BTVCBonjourServiceMessageValue"];
          unsigned int v23 = +[NSSet setWithArray:v22];
          [v21 minusSet:v23];

          uint64_t v24 = [WeakRetained deviceLostHandler];
          BOOL v25 = v24 == 0;

          if (!v25)
          {
            BOOL v26 = [WeakRetained deviceLostHandler];
            id v27 = objc_alloc((Class)NSUUID);
            int v28 = [v6 remoteUniqueIDString];
            id v29 = [v27 initWithUUIDString:v28];
            unint64_t v30 = [v7 objectForKeyedSubscript:@"BTVCBonjourServiceMessageValue"];
            ((void (**)(void, id, void *))v26)[2](v26, v29, v30);
          }
        }
        else if ([v11 isEqualToString:@"BTVCBonjourServiceMessageTypeConnect"])
        {
          [v6 setIsConnected:1];
          __int16 v31 = [WeakRetained deviceDidConnectHandler];
          BOOL v32 = v31 == 0;

          if (!v32)
          {
            __int16 v33 = [WeakRetained deviceDidConnectHandler];
            id v34 = objc_alloc((Class)NSUUID);
            size_t v35 = [v6 remoteUniqueIDString];
            id v36 = [v34 initWithUUIDString:v35];
            ((void (**)(void, id, void))v33)[2](v33, v36, 0);
          }
        }
        else if ([v11 isEqualToString:@"BTVCBonjourServiceMessageTypeDisconnect"])
        {
          [v6 setIsConnected:0];
          char v37 = [WeakRetained deviceDidDisconnectHandler];
          BOOL v38 = v37 == 0;

          if (!v38)
          {
            int v39 = [WeakRetained deviceDidDisconnectHandler];
            id v40 = objc_alloc((Class)NSUUID);
            int v41 = [v6 remoteUniqueIDString];
            id v42 = [v40 initWithUUIDString:v41];
            ((void (**)(void, id))v39)[2](v39, v42);
          }
        }
        else if ([v11 isEqualToString:@"BTVCBonjourServiceMessageTypeDataPacket"])
        {
          int v43 = [WeakRetained deviceDidReceiveDataHandler];
          BOOL v44 = v43 == 0;

          if (!v44)
          {
            int v45 = [v7 objectForKeyedSubscript:@"BTVCBonjourServiceMessageValue"];
            __int16 v46 = [WeakRetained deviceDidReceiveDataHandler];
            id v47 = objc_alloc((Class)NSUUID);
            __int16 v48 = [v6 remoteUniqueIDString];
            id v49 = [v47 initWithUUIDString:v48];
            ((void (**)(void, id, void *))v46)[2](v46, v49, v45);
          }
        }
        else
        {
          __int16 v50 = qword_100A19FE8;
          if (os_log_type_enabled((os_log_t)qword_100A19FE8, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)long long buf = 138412290;
            int v53 = v11;
            _os_log_impl((void *)&_mh_execute_header, v50, OS_LOG_TYPE_DEFAULT, "[BTVCBonjourService] BTVCBonjourService unknown message type:%@", buf, 0xCu);
          }
        }
      }
    }
    else if (os_log_type_enabled((os_log_t)qword_100A19FE8, OS_LOG_TYPE_ERROR))
    {
      sub_10074C658();
    }
  }
}

void sub_100273AE0(_Unwind_Exception *a1)
{
  uint64_t v10 = v6;

  _Unwind_Resume(a1);
}

void sub_100273EB0(_Unwind_Exception *a1)
{
  id v8 = v7;

  _Unwind_Resume(a1);
}

void sub_100273F1C(uint64_t a1, void *a2)
{
  id v4 = a2;
  uint64_t v3 = *(void *)(a1 + 32);
  if (v3) {
    (*(void (**)(uint64_t, id))(v3 + 16))(v3, v4);
  }
}

void sub_100273F78(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1002740CC(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 64));
  uint64_t v3 = WeakRetained;
  if (WeakRetained)
  {
    id v4 = [WeakRetained _endpointForUniqueID:*(void *)(a1 + 32)];
    if (v4 && *(void *)(a1 + 40) && *(void *)(a1 + 48))
    {
      [v3 _sendMessage:withType:toEndpoint:completionCallback:];
    }
    else
    {
      if (os_log_type_enabled((os_log_t)qword_100A19FE8, OS_LOG_TYPE_ERROR)) {
        sub_10074C7A0();
      }
      if (*(void *)(a1 + 56))
      {
        NSErrorUserInfoKey v7 = NSLocalizedDescriptionKey;
        CFStringRef v8 = @"Unable to send message, invalid params";
        id v5 = +[NSDictionary dictionaryWithObjects:&v8 forKeys:&v7 count:1];
        id v6 = +[NSError errorWithDomain:NSOSStatusErrorDomain code:-6705 userInfo:v5];

        (*(void (**)(void))(*(void *)(a1 + 56) + 16))();
      }
    }
  }
}

void sub_10027423C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1002743C0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, void *a15, void *a16)
{
  _Unwind_Resume(a1);
}

void sub_10027441C(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = *(void **)(a1 + 32);
  uint64_t v10 = *(void *)(a1 + 40);
  id v5 = +[NSArray arrayWithObjects:&v10 count:1];
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 3221225472;
  _DWORD v7[2] = sub_10027456C;
  v7[3] = &unk_1009A0468;
  uint64_t v6 = *(void *)(a1 + 48);
  id v9 = *(id *)(a1 + 56);
  id v8 = *(id *)(a1 + 40);
  [v4 _sendMessage:v5 withType:v6 toDevice:v3 completionCallback:v7];
}

void sub_100274538(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, void *a14)
{
  _Unwind_Resume(a1);
}

void sub_10027456C(uint64_t a1, void *a2)
{
  id v4 = a2;
  if (v4)
  {
    uint64_t v3 = *(void *)(a1 + 40);
    if (v3) {
      (*(void (**)(uint64_t, void, id))(v3 + 16))(v3, *(void *)(a1 + 32), v4);
    }
  }
}

void sub_1002745D0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1002746AC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{
  _Unwind_Resume(a1);
}

void sub_1002746D0(uint64_t a1, void *a2)
{
  id v8 = a2;
  uint64_t v3 = *(void **)(a1 + 32);
  id v4 = [*(id *)(a1 + 40) UUIDString];
  id v5 = [v3 _endpointForUniqueID:v4];

  if (!v8) {
    [v5 setIsConnected:1];
  }
  uint64_t v6 = [*(id *)(a1 + 32) deviceDidConnectHandler];

  if (v6)
  {
    NSErrorUserInfoKey v7 = [*(id *)(a1 + 32) deviceDidConnectHandler];
    ((void (**)(void, void, id))v7)[2](v7, *(void *)(a1 + 40), v8);
  }
}

void sub_10027479C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_10027489C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{
  _Unwind_Resume(a1);
}

void sub_1002748C0(uint64_t a1)
{
  unsigned int v2 = *(void **)(a1 + 32);
  uint64_t v3 = [*(id *)(a1 + 40) UUIDString];
  id v9 = [v2 _endpointForUniqueID:v3];

  [v9 setIsConnected:0];
  id v4 = [*(id *)(a1 + 32) deviceDidDisconnectHandler];

  if (v4)
  {
    id v5 = [*(id *)(a1 + 32) deviceDidDisconnectHandler];
    v5[2](v5, *(void *)(a1 + 40));
  }
  uint64_t v6 = [*(id *)(a1 + 32) deviceLostHandler];
  if (v6)
  {
    unsigned __int8 v7 = [v9 isAdvToBrowserConnection];

    if ((v7 & 1) == 0)
    {
      id v8 = [*(id *)(a1 + 32) deviceLostHandler];
      v8[2](v8, *(void *)(a1 + 40), 0);
    }
  }
}

void sub_1002749C4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_100274B18(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, void *a15, void *a16)
{
  _Unwind_Resume(a1);
}

void sub_100274B54(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (v3 && os_log_type_enabled((os_log_t)qword_100A19FE8, OS_LOG_TYPE_ERROR)) {
    sub_10074C814();
  }
  uint64_t v4 = *(void *)(a1 + 48);
  if (v4) {
    (*(void (**)(uint64_t, id))(v4 + 16))(v4, v3);
  }
}

void sub_100274BD4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100274C64(_Unwind_Exception *a1)
{
  uint64_t v4 = v3;

  _Unwind_Resume(a1);
}

void sub_100274D84(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id sub_100274E1C(uint64_t a1)
{
  [*(id *)(a1 + 32) _stopBrowser];
  unsigned int v2 = *(void **)(a1 + 32);

  return [v2 _stopAdvertising];
}

uint64_t sub_100275120(uint64_t result, uint64_t a2, uint64_t a3, float a4)
{
  if (result) {
    uint64_t v4 = v5;
  }
  *(float *)a3 = a4;
  *(void *)(a3 + 4) = v4;
  *(_WORD *)(a3 + 12) = 2112;
  *(void *)(a3 + 14) = a2;
  return result;
}

void sub_100275174(void *a1, uint64_t a2, os_log_t log, const char *a4, ...)
{
  va_start(va, a4);
  _os_log_error_impl(a1, log, OS_LOG_TYPE_ERROR, a4, (uint8_t *)va, 0x20u);
}

uint64_t sub_100275194(uint64_t a1)
{
  unsigned int v2 = (uint64_t *)(sub_100052DA8(a1) + 64);
  sub_10061F99C(v2);
  *(_DWORD *)(a1 + 96) = 0;
  sub_10004191C((void *)(a1 + 104), "");
  *(void *)(a1 + 128) = 0;
  sub_10061F99C((void *)(a1 + 152));
  sub_10062E4F0(a1 + 192);
  *(void *)(a1 + 248) = 0;
  *(void *)(a1 + 256) = 0;
  *(void *)(a1 + 264) = 0;
  *(unsigned char *)(a1 + 275) = 0;
  sub_10061F99C((void *)(a1 + 280));
  *(_DWORD *)(a1 + 304) = 0;
  *(unsigned char *)(a1 + 308) = 0;
  sub_100052DA8(a1 + 320);
  *(void *)(a1 + 384) = 0;
  sub_10061FA80(v2);
  *(_WORD *)(a1 + 88) = 0;
  *(unsigned char *)(a1 + 90) = 0;
  std::string::assign((std::string *)(a1 + 104), "");
  *(_DWORD *)(a1 + 96) = 0;
  *(_WORD *)(a1 + 136) = 0;
  *(unsigned char *)(a1 + 138) = 0;
  *(_DWORD *)(a1 + 140) = 0;
  *(_DWORD *)(a1 + 144) = 0;
  sub_10061FA80((uint64_t *)(a1 + 152));
  *(_WORD *)(a1 + 176) = 0;
  *(_DWORD *)(a1 + 180) = 0;
  *(_DWORD *)(a1 + 184) = 0;
  sub_10062EC08(a1 + 192);
  if (*(char *)(a1 + 271) < 0)
  {
    **(unsigned char **)(a1 + 248) = 0;
    *(void *)(a1 + 256) = 0;
  }
  else
  {
    *(unsigned char *)(a1 + 248) = 0;
    *(unsigned char *)(a1 + 271) = 0;
  }
  *(void *)(a1 + 312) = 0;
  *(_DWORD *)(a1 + 272) = 0;
  sub_10061FA80((uint64_t *)(a1 + 280));
  return a1;
}

void sub_1002752D0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_10027696C((void ***)va);
  if (*(char *)(v2 + 271) < 0) {
    operator delete(*v5);
  }
  sub_10062E8E8(v4);
  sub_10027696C((void ***)va);

  if (*(char *)(v2 + 127) < 0) {
    operator delete(*v3);
  }
  sub_10027696C((void ***)va);
  sub_100052DA4(v2);
  _Unwind_Resume(a1);
}

uint64_t sub_10027537C(uint64_t a1)
{
  sub_10027547C(a1);

  sub_100052DA4(a1 + 320);
  id v3 = (void **)(a1 + 280);
  sub_10027696C(&v3);
  if (*(char *)(a1 + 271) < 0) {
    operator delete(*(void **)(a1 + 248));
  }
  sub_10062E8E8(a1 + 192);
  id v3 = (void **)(a1 + 152);
  sub_10027696C(&v3);

  if (*(char *)(a1 + 127) < 0) {
    operator delete(*(void **)(a1 + 104));
  }
  id v3 = (void **)(a1 + 64);
  sub_10027696C(&v3);
  return sub_100052DA4(a1);
}

void sub_100275420(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void **a10)
{
  sub_100052DA4(v10 + 320);
  a10 = (void **)(v10 + 280);
  sub_10027696C(&a10);
  if (*(char *)(v10 + 271) < 0) {
    operator delete(*(void **)(v10 + 248));
  }
  sub_10074C920(v10);
  a10 = (void **)(v10 + 64);
  sub_10027696C(&a10);
  sub_100052DA4(v10);
  _Unwind_Resume(a1);
}

uint64_t sub_10027547C(uint64_t a1)
{
  if (*(void *)(a1 + 312))
  {
    uint64_t v2 = qword_100A19E70;
    if (!os_log_type_enabled((os_log_t)qword_100A19E70, OS_LOG_TYPE_INFO)
      || (*(_WORD *)long long buf = 0,
          _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_INFO, "Deleting pending sco route change", buf, 2u),
          *(void *)(a1 + 312)))
    {
      operator delete();
    }
    *(void *)(a1 + 312) = 0;
  }
  *(void *)long long buf = 0;
  uint64_t v9 = 0;
  sub_10003AED0((uint64_t)buf, a1 + 320);
  id v3 = *(void **)(a1 + 384);
  if (v3)
  {
    uint64_t v4 = qword_100A19E70;
    if (os_log_type_enabled((os_log_t)qword_100A19E70, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)unsigned __int8 v7 = 0;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Canceling pending Disconnection timeout dispatch", v7, 2u);
      id v3 = *(void **)(a1 + 384);
    }
    dispatch_block_cancel(v3);
    uint64_t v5 = *(void **)(a1 + 384);
    *(void *)(a1 + 384) = 0;
  }
  return sub_10003AFB4((uint64_t)buf);
}

void *sub_100275594@<X0>(int *a1@<X0>, void *a2@<X8>)
{
  uint64_t v4 = *a1;
  if (v4 > 2) {
    uint64_t v5 = "unknown";
  }
  else {
    uint64_t v5 = off_1009A0520[v4];
  }
  return sub_10004191C(a2, v5);
}

void *sub_1002755C4@<X0>(int *a1@<X0>, void *a2@<X8>)
{
  uint64_t v4 = *a1;
  if (v4 > 3) {
    uint64_t v5 = "unknown";
  }
  else {
    uint64_t v5 = off_1009A0538[v4];
  }
  return sub_10004191C(a2, v5);
}

const char *sub_1002755F4(int *a1)
{
  uint64_t v1 = *a1;
  if (v1 > 7) {
    return "Unknown";
  }
  else {
    return off_1009A0558[v1];
  }
}

uint64_t sub_10027561C(uint64_t result, __int16 a2)
{
  *(_WORD *)(result + 88) = a2;
  return result;
}

uint64_t sub_100275624(uint64_t a1)
{
  return *(unsigned __int16 *)(a1 + 88);
}

uint64_t sub_10027562C(uint64_t result, char a2)
{
  *(unsigned char *)(result + 90) = a2;
  return result;
}

uint64_t sub_100275634(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 90);
}

char *sub_10027563C@<X0>(char *result@<X0>, uint64_t a2@<X8>)
{
  if (result[127] < 0) {
    return (char *)sub_10003B098((unsigned char *)a2, *((void **)result + 13), *((void *)result + 14));
  }
  *(_OWORD *)a2 = *(_OWORD *)(result + 104);
  *(void *)(a2 + 16) = *((void *)result + 15);
  return result;
}

uint64_t sub_100275668(uint64_t a1)
{
  return *(unsigned int *)(a1 + 96);
}

std::string *sub_100275670(uint64_t a1, uint64_t a2)
{
  id result = std::string::operator=((std::string *)(a1 + 104), (const std::string *)(a2 + 8));
  *(_DWORD *)(a1 + 96) = *(_DWORD *)a2;
  return result;
}

id sub_1002756A8(uint64_t a1)
{
  return [*(id *)(a1 + 128) service];
}

id sub_1002756B0(uint64_t a1)
{
  return [*(id *)(a1 + 128) roaming];
}

void sub_1002756B8(uint64_t a1, void *a2)
{
}

BOOL sub_1002756C0(uint64_t a1)
{
  return sub_10061FEFC((void *)(a1 + 64));
}

BOOL sub_1002756C8(uint64_t a1)
{
  return sub_10061FEC8((void *)(a1 + 64));
}

BOOL sub_1002756D0(uint64_t a1)
{
  return sub_10061FF64((void *)(a1 + 64));
}

BOOL sub_1002756D8(uint64_t a1)
{
  return sub_10061FF30((void *)(a1 + 64));
}

uint64_t sub_1002756E0(uint64_t a1)
{
  return sub_10061FE5C((uint64_t *)(a1 + 64));
}

uint64_t sub_1002756E8(uint64_t a1)
{
  return sub_10061FE90((uint64_t *)(a1 + 64));
}

uint64_t sub_1002756F0(uint64_t a1)
{
  return sub_10061FE28((uint64_t *)(a1 + 64));
}

uint64_t sub_1002756F8(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 138);
}

uint64_t sub_100275700(uint64_t result, char a2)
{
  *(unsigned char *)(result + 138) = a2;
  return result;
}

uint64_t sub_100275708@<X0>(int a1@<W8>)
{
  return sub_10061FA28(a1);
}

void sub_100275714(uint64_t a1, uint64_t *a2)
{
  uint64_t v2 = a1 + 152;
  if ((uint64_t *)v2 != a2) {
    sub_100276A50(v2, *a2, a2[1], 0x4EC4EC4EC4EC4EC5 * ((a2[1] - *a2) >> 3));
  }
}

uint64_t sub_10027574C(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 176);
}

uint64_t sub_100275754(uint64_t result, char a2)
{
  *(unsigned char *)(result + 176) = a2;
  return result;
}

uint64_t sub_10027575C(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 273);
}

uint64_t sub_100275764(uint64_t result, char a2)
{
  *(unsigned char *)(result + 273) = a2;
  return result;
}

uint64_t sub_10027576C(uint64_t result, char a2)
{
  *(unsigned char *)(result + 274) = a2;
  return result;
}

uint64_t sub_100275774(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 274);
}

std::string *sub_10027577C(uint64_t a1)
{
  *(_DWORD *)(a1 + 180) = 0;
  id result = sub_10062EC08(a1 + 192);
  if (*(char *)(a1 + 271) < 0)
  {
    **(unsigned char **)(a1 + 248) = 0;
    *(void *)(a1 + 256) = 0;
  }
  else
  {
    *(unsigned char *)(a1 + 248) = 0;
    *(unsigned char *)(a1 + 271) = 0;
  }
  *(_DWORD *)(a1 + 184) = 0;
  return result;
}

std::string *sub_1002757CC(uint64_t a1, uint64_t a2, const std::string *a3, int a4)
{
  sub_10062E90C((std::string *)(a1 + 192), a2);
  id result = std::string::operator=((std::string *)(a1 + 248), a3);
  *(_DWORD *)(a1 + 180) = a4;
  return result;
}

BOOL sub_100275814(uint64_t a1, int a2)
{
  return *(_DWORD *)(a1 + 180) == a2;
}

uint64_t sub_100275824(uint64_t result)
{
  return result;
}

uint64_t sub_100275834(uint64_t result, int a2)
{
  *(_DWORD *)(result + ++*(_DWORD *)(result + 184) = a2;
  return result;
}

uint64_t sub_10027583C(uint64_t a1)
{
  return *(unsigned int *)(a1 + 184);
}

std::string *sub_100275844@<X0>(uint64_t a1@<X0>, std::string *a2@<X8>)
{
  return sub_10062EA4C(a1 + 192, a2);
}

char *sub_10027584C@<X0>(char *result@<X0>, uint64_t a2@<X8>)
{
  if (result[271] < 0) {
    return (char *)sub_10003B098((unsigned char *)a2, *((void **)result + 31), *((void *)result + 32));
  }
  *(_OWORD *)a2 = *(_OWORD *)(result + 248);
  *(void *)(a2 + 16) = *((void *)result + 33);
  return result;
}

uint64_t sub_100275878(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 216);
}

uint64_t sub_100275880(uint64_t result, int a2)
{
  *(_DWORD *)(result + 144) = a2;
  return result;
}

uint64_t sub_100275888(uint64_t a1, int a2)
{
  v5[0] = 0;
  v5[1] = 0;
  sub_10003AED0((uint64_t)v5, a1);
  *(_DWORD *)(a1 + 140) = a2;
  return sub_10003AFB4((uint64_t)v5);
}

uint64_t sub_1002758D0(uint64_t a1)
{
  v4[0] = 0;
  v4[1] = 0;
  sub_10003AED0((uint64_t)v4, a1);
  uint64_t v2 = *(unsigned int *)(a1 + 140);
  sub_10003AFB4((uint64_t)v4);
  return v2;
}

BOOL sub_100275918(uint64_t a1, int a2)
{
  return *(_DWORD *)(a1 + 140) == a2;
}

uint64_t sub_100275928(uint64_t result, char a2)
{
  *(unsigned char *)(result + 136) = a2;
  return result;
}

uint64_t sub_100275930(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 136);
}

uint64_t sub_100275938(uint64_t result, char a2)
{
  *(unsigned char *)(result + 137) = a2;
  return result;
}

uint64_t sub_100275940(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 137);
}

uint64_t sub_100275948(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 272);
}

uint64_t sub_100275950(uint64_t result, char a2)
{
  *(unsigned char *)(result + 272) = a2;
  return result;
}

uint64_t sub_100275958(uint64_t result, char a2)
{
  *(unsigned char *)(result + 177) = a2;
  return result;
}

uint64_t sub_100275960(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 177);
}

uint64_t sub_100275968@<X0>(uint64_t a1@<X0>, int a2@<W8>)
{
  v4[0] = 0;
  v4[1] = 0;
  sub_10003AED0((uint64_t)v4, a1);
  sub_10061FA28(a2);
  return sub_10003AFB4((uint64_t)v4);
}

void sub_1002759B8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_1002759CC(uint64_t a1, uint64_t *a2)
{
  v5[0] = 0;
  v5[1] = 0;
  sub_10003AED0((uint64_t)v5, a1);
  if ((uint64_t *)(a1 + 64) != a2) {
    sub_100276A50(a1 + 64, *a2, a2[1], 0x4EC4EC4EC4EC4EC5 * ((a2[1] - *a2) >> 3));
  }
  return sub_10003AFB4((uint64_t)v5);
}

void sub_100275A40(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

unint64_t sub_100275A54(uint64_t a1, uint64_t *a2)
{
  v9[0] = 0;
  v9[1] = 0;
  sub_10003AED0((uint64_t)v9, a1);
  uint64_t v4 = a1 + 64;
  unint64_t v5 = sub_10061FD80((uint64_t *)(a1 + 64), a2);
  unint64_t v6 = v5;
  if ((uint64_t *)v4 == a2) {
    char v7 = 1;
  }
  else {
    char v7 = v5;
  }
  if ((v7 & 1) == 0) {
    sub_100276A50(v4, *a2, a2[1], 0x4EC4EC4EC4EC4EC5 * ((a2[1] - *a2) >> 3));
  }
  sub_10003AFB4((uint64_t)v9);
  return v6;
}

void sub_100275AEC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_100275B00(uint64_t a1)
{
  return *(unsigned __int16 *)(a1 + 12);
}

void sub_100275B08(uint64_t a1)
{
  uint64_t v2 = qword_100A19E70;
  if (os_log_type_enabled((os_log_t)qword_100A19E70, OS_LOG_TYPE_INFO))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_INFO, "Set pending sco route change", buf, 2u);
  }
  sub_10027547C(a1);
  operator new();
}

uint64_t sub_100275C6C(uint64_t result)
{
  if (*(void *)(result + 40))
  {
    uint64_t v1 = *(void *)(result + 32);
    id result = sub_100275CD0(v1);
    if (result)
    {
      uint64_t v2 = qword_100A19E70;
      if (os_log_type_enabled((os_log_t)qword_100A19E70, OS_LOG_TYPE_ERROR)) {
        sub_10074C978(v2);
      }
      return sub_10027547C(v1);
    }
  }
  return result;
}

uint64_t sub_100275CD0(uint64_t a1)
{
  uint64_t v2 = qword_100A19E70;
  if (os_log_type_enabled((os_log_t)qword_100A19E70, OS_LOG_TYPE_INFO))
  {
    if (*(void *)(a1 + 312)) {
      id v3 = "true";
    }
    else {
      id v3 = "false";
    }
    int v5 = 136446210;
    unint64_t v6 = v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_INFO, "Getting pending sco route change %{public}s", (uint8_t *)&v5, 0xCu);
  }
  return *(void *)(a1 + 312);
}

void sub_100275D94(uint64_t a1)
{
  if (sub_100275CD0(a1))
  {
    uint64_t v2 = *(unsigned int **)(a1 + 312);
    uint64_t v3 = *v2;
    uint64_t v4 = v2[1];
    uint64_t v5 = v2[2];
    unsigned int v6 = *((unsigned __int16 *)v2 + 6);
    if (qword_1009FB058 != -1) {
      dispatch_once(&qword_1009FB058, &stru_1009A0500);
    }
    uint64_t v7 = sub_1005160B8((uint64_t)off_1009FB050, v6);
    if (qword_1009FB058 != -1) {
      dispatch_once(&qword_1009FB058, &stru_1009A0500);
    }
    id v8 = sub_100511724((uint64_t)off_1009FB050, v6);
    if (v7) {
      BOOL v9 = v8 == 0;
    }
    else {
      BOOL v9 = 1;
    }
    if (v9)
    {
      uint64_t v10 = qword_100A19E70;
      if (os_log_type_enabled((os_log_t)qword_100A19E70, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(__p[0]) = 0;
        _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "Audio device has already disconnected, cannot retry route change", (uint8_t *)__p, 2u);
      }
    }
    else
    {
      id v11 = v8;
      sub_10027547C(a1);
      BOOL v12 = qword_100A19E70;
      if (os_log_type_enabled((os_log_t)qword_100A19E70, OS_LOG_TYPE_DEFAULT))
      {
        sub_100475EE0(v7, (uint64_t)__p);
        __int16 v14 = v16 >= 0 ? __p : (void **)__p[0];
        *(_DWORD *)long long buf = 141558275;
        uint64_t v18 = 1752392040;
        __int16 v19 = 2081;
        BOOL v20 = v14;
        _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "Retrying sco route change to device %{private, mask.hash}s", buf, 0x16u);
        if (v16 < 0) {
          operator delete(__p[0]);
        }
      }
      if (qword_1009FB058 != -1) {
        dispatch_once(&qword_1009FB058, &stru_1009A0500);
      }
      (*(void (**)(void *, uint64_t *, uint64_t, uint64_t, uint64_t))(*(void *)off_1009FB050 + 136))(off_1009FB050, v11, v3, v4, v5);
    }
  }
}

uint64_t sub_100275FDC(uint64_t a1, char a2)
{
  v5[0] = 0;
  v5[1] = 0;
  sub_10003AED0((uint64_t)v5, a1);
  *(unsigned char *)(a1 + 275) = a2;
  return sub_10003AFB4((uint64_t)v5);
}

uint64_t sub_100276024(uint64_t a1)
{
  v4[0] = 0;
  v4[1] = 0;
  sub_10003AED0((uint64_t)v4, a1);
  uint64_t v2 = *(unsigned __int8 *)(a1 + 275);
  sub_10003AFB4((uint64_t)v4);
  return v2;
}

uint64_t sub_10027606C@<X0>(uint64_t a1@<X0>, int a2@<W8>)
{
  v4[0] = 0;
  v4[1] = 0;
  sub_10003AED0((uint64_t)v4, a1);
  sub_10061FA28(a2);
  return sub_10003AFB4((uint64_t)v4);
}

void sub_1002760BC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_1002760D0(uint64_t a1, uint64_t *a2)
{
  v5[0] = 0;
  v5[1] = 0;
  sub_10003AED0((uint64_t)v5, a1);
  if ((uint64_t *)(a1 + 280) != a2) {
    sub_100276A50(a1 + 280, *a2, a2[1], 0x4EC4EC4EC4EC4EC5 * ((a2[1] - *a2) >> 3));
  }
  return sub_10003AFB4((uint64_t)v5);
}

void sub_100276144(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_100276158(uint64_t a1)
{
  return *(unsigned int *)(a1 + 304);
}

uint64_t sub_100276160(uint64_t result, int a2)
{
  *(_DWORD *)(result + 304) = a2;
  return result;
}

uint64_t sub_100276168(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 308);
}

uint64_t sub_100276170(uint64_t result, char a2)
{
  *(unsigned char *)(result + 308) = a2;
  return result;
}

double sub_100276178(uint64_t a1, uint64_t a2, __int16 a3, int *a4)
{
  *(_DWORD *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 152) = 0;
  *(void *)(a1 + 160) = 0;
  *(void *)(a1 + 32) = a2;
  *(_WORD *)(a1 + 40) = a3;
  *(_WORD *)(a1 + 70) = 0;
  *(void *)(a1 + 56) = 0;
  *(_DWORD *)(a1 + 64) = 0;
  *(unsigned char *)(a1 + 72) = 1;
  *(unsigned char *)(a1 + 68) = 0;
  *(void *)(a1 + 73) = 0;
  *(unsigned char *)(a1 + 81) = 0;
  *(_DWORD *)(a1 + 88) = 1;
  *(unsigned char *)(a1 + 92) = 0;
  *(void *)&double result = 0x100000040;
  *(_OWORD *)(a1 + 108) = xmmword_1007BB210;
  *(_DWORD *)(a1 + 128) = 0;
  *(unsigned char *)(a1 + 132) = 0;
  int v5 = *a4;
  *(_WORD *)(a1 + 46) = *((_WORD *)a4 + 2);
  *(_DWORD *)(a1 + 42) = v5;
  *(_WORD *)(a1 + 82) = 0;
  *(unsigned char *)(a1 + 84) = 0;
  *(unsigned char *)(a1 + 69) = 0;
  *(void *)(a1 + 48) = 0;
  *(_DWORD *)(a1 + 144) = 0;
  *(_WORD *)(a1 + 168) = 0;
  *(unsigned char *)(a1 + 170) = 0;
  *(unsigned char *)(a1 + 140) = 0;
  *(_DWORD *)(a1 + 100) = 0;
  *(unsigned char *)(a1 + 104) = 0;
  return result;
}

uint64_t sub_100276208(uint64_t a1)
{
  return a1;
}

uint64_t sub_100276230(uint64_t a1)
{
  uint64_t v12 = 0;
  long long v11 = 0u;
  memset(v10, 0, sizeof(v10));
  long long v8 = 0u;
  *(_OWORD *)__p = 0u;
  long long v6 = 0u;
  *(_OWORD *)uint64_t v7 = 0u;
  long long v4 = 0u;
  *(_OWORD *)int v5 = 0u;
  sub_1006161E0((uint64_t)&v4 + 1);
  BYTE2(v5[0]) = 0;
  BYTE4(v5[0]) = 0;
  BYTE2(v7[0]) = 0;
  BYTE4(v7[0]) = 0;
  DWORD1(v10[1]) = 0;
  long long v6 = 0uLL;
  v5[1] = 0;
  LOBYTE(v7[0]) = 0;
  long long v8 = 0uLL;
  v7[1] = 0;
  LOBYTE(__p[0]) = 0;
  memset(v10, 0, 19);
  __p[1] = 0;
  BYTE8(v10[1]) = 1;
  BYTE2(v12) = 0;
  *(void *)((char *)&v10[1] + 14) = 0;
  *(void *)((char *)&v10[1] + 9) = 0;
  long long v11 = 0uLL;
  *((void *)&v10[2] + 1) = 0;
  LOBYTE(v12) = 0;
  LODWORD(a1) = sub_1004783B8(*(void *)(a1 + 32), (uint64_t)&v4);
  int v2 = BYTE2(v10[1]);
  if (SHIBYTE(v10[0]) < 0) {
    operator delete(__p[1]);
  }
  if (SHIBYTE(v8) < 0) {
    operator delete(v7[1]);
  }
  if (SHIBYTE(v6) < 0) {
    operator delete(v5[1]);
  }
  if (v2) {
    a1 = a1;
  }
  else {
    a1 = 0;
  }
  nullsub_95((char *)&v4 + 1);
  return a1;
}

void sub_100276368(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_100276384(uint64_t a1)
{
  if (*(char *)(a1 + 111) < 0) {
    operator delete(*(void **)(a1 + 88));
  }
  if (*(char *)(a1 + 79) < 0) {
    operator delete(*(void **)(a1 + 56));
  }
  if (*(char *)(a1 + 47) < 0) {
    operator delete(*(void **)(a1 + 24));
  }
  nullsub_95(a1 + 1);
  return a1;
}

uint64_t sub_1002763E0(uint64_t a1)
{
  uint64_t v14 = 0;
  long long v13 = 0u;
  memset(v12, 0, sizeof(v12));
  long long v10 = 0u;
  *(_OWORD *)__p = 0u;
  long long v8 = 0u;
  *(_OWORD *)BOOL v9 = 0u;
  long long v6 = 0u;
  *(_OWORD *)uint64_t v7 = 0u;
  sub_1006161E0((uint64_t)&v6 + 1);
  BYTE2(v7[0]) = 0;
  BYTE4(v7[0]) = 0;
  BYTE2(v9[0]) = 0;
  BYTE4(v9[0]) = 0;
  DWORD1(v12[1]) = 0;
  long long v8 = 0uLL;
  v7[1] = 0;
  LOBYTE(v9[0]) = 0;
  long long v10 = 0uLL;
  v9[1] = 0;
  LOBYTE(__p[0]) = 0;
  memset(v12, 0, 19);
  __p[1] = 0;
  BYTE8(v12[1]) = 1;
  BYTE2(v14) = 0;
  *(void *)((char *)&v12[1] + 14) = 0;
  *(void *)((char *)&v12[1] + 9) = 0;
  long long v13 = 0uLL;
  *((void *)&v12[2] + 1) = 0;
  LOBYTE(v14) = 0;
  BOOL v2 = sub_1004783B8(*(void *)(a1 + 32), (uint64_t)&v6);
  unsigned int v3 = DWORD1(v12[1]);
  if (SHIBYTE(v12[0]) < 0) {
    operator delete(__p[1]);
  }
  if (SHIBYTE(v10) < 0) {
    operator delete(v9[1]);
  }
  if (SHIBYTE(v8) < 0) {
    operator delete(v7[1]);
  }
  if (v2) {
    uint64_t v4 = v3;
  }
  else {
    uint64_t v4 = 0;
  }
  nullsub_95((char *)&v6 + 1);
  return v4;
}

void sub_100276518(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_100276534(uint64_t a1)
{
  return *(unsigned __int16 *)(a1 + 40);
}

uint64_t sub_10027653C(uint64_t a1)
{
  return *(void *)(a1 + 32);
}

uint64_t sub_100276544(uint64_t result, uint64_t a2)
{
  *(void *)(result + 48) = a2;
  return result;
}

uint64_t sub_10027654C(uint64_t a1)
{
  return *(void *)(a1 + 48);
}

unint64_t sub_100276554(uint64_t a1)
{
  return *(unsigned int *)(a1 + 42) | ((unint64_t)*(unsigned __int16 *)(a1 + 46) << 32);
}

uint64_t sub_100276564(uint64_t a1)
{
  return *(unsigned int *)(a1 + 56);
}

uint64_t sub_10027656C(uint64_t result, int a2)
{
  *(_DWORD *)(result + 56) = a2;
  return result;
}

uint64_t sub_100276574(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 60);
}

uint64_t sub_10027657C(uint64_t result, char a2)
{
  *(unsigned char *)(result + 60) = a2;
  return result;
}

uint64_t sub_100276584(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 61);
}

uint64_t sub_10027658C(uint64_t result, char a2)
{
  *(unsigned char *)(result + 61) = a2;
  return result;
}

uint64_t sub_100276594(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 62);
}

uint64_t sub_10027659C(uint64_t result, char a2)
{
  *(unsigned char *)(result + 62) = a2;
  return result;
}

uint64_t sub_1002765A4(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 63);
}

uint64_t sub_1002765AC(uint64_t result, char a2)
{
  *(unsigned char *)(result + 63) = a2;
  return result;
}

uint64_t sub_1002765B4(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 64);
}

uint64_t sub_1002765BC(uint64_t result, char a2)
{
  *(unsigned char *)(result + 64) = a2;
  return result;
}

uint64_t sub_1002765C4(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 65);
}

uint64_t sub_1002765CC(uint64_t result, char a2)
{
  *(unsigned char *)(result + 65) = a2;
  return result;
}

uint64_t sub_1002765D4(uint64_t result, char a2)
{
  *(unsigned char *)(result + 66) = a2;
  return result;
}

uint64_t sub_1002765DC(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 68);
}

uint64_t sub_1002765E4(uint64_t result, char a2)
{
  *(unsigned char *)(result + 68) = a2;
  if ((a2 & 1) == 0) {
    *(unsigned char *)(result + 69) = 0;
  }
  return result;
}

uint64_t sub_1002765F4(uint64_t result, char a2)
{
  *(unsigned char *)(result + 69) = a2;
  return result;
}

uint64_t sub_1002765FC(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 69);
}

uint64_t sub_100276604(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 67);
}

uint64_t sub_10027660C(uint64_t result, char a2)
{
  *(unsigned char *)(result + 67) = a2;
  return result;
}

uint64_t sub_100276614(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 72);
}

uint64_t sub_10027661C(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 73);
}

uint64_t sub_100276624(uint64_t result, char a2)
{
  *(unsigned char *)(result + 73) = a2;
  return result;
}

uint64_t sub_10027662C(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 74);
}

uint64_t sub_100276634(uint64_t result, char a2)
{
  *(unsigned char *)(result + 74) = a2;
  return result;
}

uint64_t sub_10027663C(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 75);
}

uint64_t sub_100276644(uint64_t result, char a2)
{
  *(unsigned char *)(result + 75) = a2;
  return result;
}

uint64_t sub_10027664C(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 76);
}

uint64_t sub_100276654(uint64_t result, char a2)
{
  *(unsigned char *)(result + 76) = a2;
  return result;
}

uint64_t sub_10027665C(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 79);
}

uint64_t sub_100276664(uint64_t result, char a2)
{
  *(unsigned char *)(result + 79) = a2;
  return result;
}

uint64_t sub_10027666C(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 80);
}

uint64_t sub_100276674(uint64_t result, char a2)
{
  *(unsigned char *)(result + 80) = a2;
  return result;
}

uint64_t sub_10027667C(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 77);
}

uint64_t sub_100276684(uint64_t result, char a2)
{
  *(unsigned char *)(result + 77) = a2;
  return result;
}

uint64_t sub_10027668C(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 78);
}

uint64_t sub_100276694(uint64_t result, char a2)
{
  *(unsigned char *)(result + 78) = a2;
  return result;
}

uint64_t sub_10027669C(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 81);
}

uint64_t sub_1002766A4(uint64_t result, char a2)
{
  *(unsigned char *)(result + 81) = a2;
  return result;
}

uint64_t sub_1002766AC(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 101);
}

uint64_t sub_1002766B4(uint64_t result, char a2)
{
  *(unsigned char *)(result + 101) = a2;
  return result;
}

uint64_t sub_1002766BC(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 102);
}

uint64_t sub_1002766C4(uint64_t result, char a2)
{
  *(unsigned char *)(result + 102) = a2;
  return result;
}

uint64_t sub_1002766CC(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 100);
}

uint64_t sub_1002766D4(uint64_t result, char a2)
{
  *(unsigned char *)(result + 100) = a2;
  return result;
}

uint64_t sub_1002766DC(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 140);
}

uint64_t sub_1002766E4(uint64_t result, char a2)
{
  *(unsigned char *)(result + 140) = a2;
  return result;
}

uint64_t sub_1002766EC(uint64_t a1)
{
  return *(unsigned int *)(a1 + 88);
}

uint64_t sub_1002766F4(uint64_t result, int a2)
{
  *(_DWORD *)(result + 88) = a2;
  return result;
}

uint64_t sub_1002766FC(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 92);
}

uint64_t sub_100276704(uint64_t result, char a2)
{
  *(unsigned char *)(result + 92) = a2;
  return result;
}

uint64_t sub_10027670C(uint64_t result, char a2)
{
  *(unsigned char *)(result + 70) = a2;
  return result;
}

uint64_t sub_100276714(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 70);
}

uint64_t sub_10027671C(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 71);
}

uint64_t sub_100276724(uint64_t result, char a2)
{
  *(unsigned char *)(result + 170) = a2;
  return result;
}

uint64_t sub_10027672C(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 170);
}

uint64_t sub_100276734(uint64_t result, int a2)
{
  *(_DWORD *)(result + 96) = a2;
  return result;
}

uint64_t sub_10027673C(uint64_t result, int a2)
{
  *(_DWORD *)(result + 112) = a2;
  return result;
}

uint64_t sub_100276744(uint64_t result, int a2)
{
  *(_DWORD *)(result + 116) = a2;
  return result;
}

uint64_t sub_10027674C(uint64_t a1)
{
  return *(unsigned int *)(a1 + 116);
}

uint64_t sub_100276754(uint64_t result, int a2)
{
  *(_DWORD *)(result + 120) = a2;
  return result;
}

uint64_t sub_10027675C(uint64_t a1)
{
  return *(unsigned int *)(a1 + 120);
}

uint64_t sub_100276764(uint64_t result, int a2)
{
  *(_DWORD *)(result + 128) = a2;
  return result;
}

uint64_t sub_10027676C(uint64_t a1)
{
  return *(unsigned int *)(a1 + 128);
}

uint64_t sub_100276774(uint64_t result, int a2)
{
  *(_DWORD *)(result + 124) = a2;
  return result;
}

uint64_t sub_10027677C(uint64_t a1)
{
  return *(unsigned int *)(a1 + 124);
}

uint64_t sub_100276784(uint64_t result, char a2)
{
  *(unsigned char *)(result + 132) = a2;
  return result;
}

uint64_t sub_10027678C(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 132);
}

uint64_t sub_100276794(uint64_t result, char a2)
{
  *(unsigned char *)(result + 82) = a2;
  return result;
}

uint64_t sub_10027679C(uint64_t result, int a2)
{
  *(_DWORD *)(result + 136) = a2;
  return result;
}

uint64_t sub_1002767A4(uint64_t a1)
{
  return *(unsigned int *)(a1 + 136);
}

uint64_t sub_1002767AC(uint64_t a1)
{
  uint64_t v12 = 0;
  long long v11 = 0u;
  memset(v10, 0, sizeof(v10));
  long long v8 = 0u;
  *(_OWORD *)__p = 0u;
  long long v6 = 0u;
  *(_OWORD *)uint64_t v7 = 0u;
  long long v4 = 0u;
  *(_OWORD *)int v5 = 0u;
  sub_1006161E0((uint64_t)&v4 + 1);
  BYTE2(v5[0]) = 0;
  BYTE4(v5[0]) = 0;
  BYTE2(v7[0]) = 0;
  BYTE4(v7[0]) = 0;
  DWORD1(v10[1]) = 0;
  long long v6 = 0uLL;
  v5[1] = 0;
  LOBYTE(v7[0]) = 0;
  long long v8 = 0uLL;
  v7[1] = 0;
  LOBYTE(__p[0]) = 0;
  memset(v10, 0, 19);
  __p[1] = 0;
  BYTE8(v10[1]) = 1;
  BYTE2(v12) = 0;
  *(void *)((char *)&v10[1] + 14) = 0;
  *(void *)((char *)&v10[1] + 9) = 0;
  long long v11 = 0uLL;
  *((void *)&v10[2] + 1) = 0;
  LOBYTE(v12) = 0;
  LODWORD(a1) = sub_1004783B8(*(void *)(a1 + 32), (uint64_t)&v4);
  int v2 = BYTE11(v10[1]);
  if (SHIBYTE(v10[0]) < 0) {
    operator delete(__p[1]);
  }
  if (SHIBYTE(v8) < 0) {
    operator delete(v7[1]);
  }
  if (SHIBYTE(v6) < 0) {
    operator delete(v5[1]);
  }
  if (v2) {
    a1 = a1;
  }
  else {
    a1 = 0;
  }
  nullsub_95((char *)&v4 + 1);
  return a1;
}

void sub_1002768E4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_100276900(uint64_t a1)
{
  return *(unsigned int *)(a1 + 144);
}

__n128 sub_100276908(uint64_t a1, __n128 *a2)
{
  if ((__n128 *)(a1 + 152) != a2)
  {
    __n128 result = *a2;
    *(__n128 *)(a1 + 152) = *a2;
  }
  return result;
}

__n128 sub_100276920@<Q0>(uint64_t a1@<X0>, __n128 *a2@<X8>)
{
  __n128 result = *(__n128 *)(a1 + 152);
  *a2 = result;
  return result;
}

uint64_t sub_10027692C(uint64_t result, char a2)
{
  *(unsigned char *)(result + 169) = a2;
  return result;
}

uint64_t sub_100276934(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 169);
}

uint64_t sub_10027693C(uint64_t result, char a2)
{
  *(unsigned char *)(result + 103) = a2;
  return result;
}

uint64_t sub_100276944(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 103);
}

uint64_t sub_10027694C(uint64_t result)
{
  return result;
}

uint64_t sub_10027695C(uint64_t result)
{
  *(unsigned char *)(result + ++*(unsigned char *)(result + 104) = 0;
  return result;
}

uint64_t sub_100276964(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 104);
}

void sub_10027696C(void ***a1)
{
  uint64_t v1 = *a1;
  int v2 = **a1;
  if (v2)
  {
    uint64_t v4 = (uint64_t)v1[1];
    int v5 = **a1;
    if ((void *)v4 != v2)
    {
      do
      {
        v4 -= 104;
        sub_100276A04((uint64_t)(v1 + 2), v4);
      }
      while ((void *)v4 != v2);
      int v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void sub_100276A04(uint64_t a1, uint64_t a2)
{
  if (*(char *)(a2 + 103) < 0) {
    operator delete(*(void **)(a2 + 80));
  }
  sub_10062E8E8(a2 + 24);
  unsigned int v3 = *(void **)a2;
}

void sub_100276A50(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  uint64_t v8 = a1 + 16;
  BOOL v9 = *(id **)a1;
  if (0x4EC4EC4EC4EC4EC5 * ((uint64_t)(*(void *)(a1 + 16) - *(void *)a1) >> 3) >= a4)
  {
    if (0x4EC4EC4EC4EC4EC5 * ((uint64_t)(*(void *)(a1 + 8) - (void)v9) >> 3) >= a4)
    {
      sub_100276DF4((int)&v17, a2, a3, v9);
      uint64_t v14 = v13;
      uint64_t v15 = *(void *)(a1 + 8);
      if (v15 != v13)
      {
        do
        {
          v15 -= 104;
          sub_100276A04(v8, v15);
        }
        while (v15 != v14);
      }
      *(void *)(a1 + 8) = v14;
    }
    else
    {
      uint64_t v12 = a2 + 8 * ((uint64_t)(*(void *)(a1 + 8) - (void)v9) >> 3);
      sub_100276DF4((int)&v16, a2, v12, v9);
      sub_100276C10(a1, v12, a3);
    }
  }
  else
  {
    sub_100276C84((void **)a1);
    if (a4 > 0x276276276276276) {
      abort();
    }
    unint64_t v10 = 0x9D89D89D89D89D8ALL * ((uint64_t)(*(void *)(a1 + 16) - *(void *)a1) >> 3);
    if (v10 <= a4) {
      unint64_t v10 = a4;
    }
    if ((unint64_t)(0x4EC4EC4EC4EC4EC5 * ((uint64_t)(*(void *)(a1 + 16) - *(void *)a1) >> 3)) >= 0x13B13B13B13B13BLL) {
      unint64_t v11 = 0x276276276276276;
    }
    else {
      unint64_t v11 = v10;
    }
    sub_100276CF4((void *)a1, v11);
    sub_100276C10(a1, a2, a3);
  }
}

uint64_t sub_100276C10(uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = result;
  uint64_t v4 = *(void *)(result + 8);
  if (a2 != a3)
  {
    uint64_t v7 = 0;
    do
    {
      __n128 result = sub_100276D48(v4 + v7, a2 + v7);
      v7 += 104;
    }
    while (a2 + v7 != a3);
    v4 += v7;
  }
  *(void *)(v3 + 8) = v4;
  return result;
}

void sub_100276C7C(_Unwind_Exception *a1)
{
  *(void *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

void sub_100276C84(void **a1)
{
  uint64_t v1 = *a1;
  if (*a1)
  {
    uint64_t v3 = (uint64_t)a1[1];
    uint64_t v4 = *a1;
    if ((void *)v3 != v1)
    {
      do
      {
        v3 -= 104;
        sub_100276A04((uint64_t)(a1 + 2), v3);
      }
      while ((void *)v3 != v1);
      uint64_t v4 = *a1;
    }
    a1[1] = v1;
    operator delete(v4);
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
  }
}

char *sub_100276CF4(void *a1, unint64_t a2)
{
  if (a2 >= 0x276276276276277) {
    abort();
  }
  __n128 result = (char *)sub_100276E80((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[104 * v4];
  return result;
}

uint64_t sub_100276D48(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = *(id *)a2;
  *(void *)(a1 + 8) = *(void *)(a2 + 8);
  *(_DWORD *)(a1 + 16) = *(_DWORD *)(a2 + 16);
  sub_10062E8E4((void *)(a1 + 24));
  uint64_t v4 = (unsigned char *)(a1 + 80);
  if (*(char *)(a2 + 103) < 0)
  {
    sub_10003B098(v4, *(void **)(a2 + 80), *(void *)(a2 + 88));
  }
  else
  {
    long long v5 = *(_OWORD *)(a2 + 80);
    *(void *)(a1 + 96) = *(void *)(a2 + 96);
    *(_OWORD *)uint64_t v4 = v5;
  }
  return a1;
}

void sub_100276DD0(_Unwind_Exception *a1)
{
  sub_10062E8E8(v2);

  _Unwind_Resume(a1);
}

uint64_t sub_100276DF4(int a1, uint64_t a2, uint64_t a3, id *location)
{
  uint64_t v5 = a2;
  if (a2 == a3) {
    return a2;
  }
  uint64_t v6 = a3;
  do
  {
    objc_storeStrong(location, *(id *)v5);
    uint64_t v7 = *(void **)(v5 + 8);
    *((_DWORD *)location + 4) = *(_DWORD *)(v5 + 16);
    location[1] = v7;
    sub_10062E90C((std::string *)location + 1, v5 + 24);
    std::string::operator=((std::string *)(location + 10), (const std::string *)(v5 + 80));
    location += 13;
    v5 += 104;
  }
  while (v5 != v6);
  return v6;
}

void *sub_100276E80(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x276276276276277) {
    sub_1000616DC();
  }
  return operator new(104 * a2);
}

void sub_100276ECC(id a1)
{
}

void sub_100276F10()
{
}

xpc_connection_t *sub_100276F34(xpc_connection_t *a1, _xpc_connection_s *a2, _xpc_connection_s *name, _xpc_connection_s *targetq)
{
  *a1 = a2;
  a1[1] = name;
  a1[2] = targetq;
  mach_service = xpc_connection_create_mach_service((const char *)name, (dispatch_queue_t)targetq, 0);
  a1[3] = mach_service;
  a1[4] = 0;
  if (a1[2])
  {
    dispatch_retain((dispatch_object_t)a1[2]);
    mach_service = a1[3];
  }
  handler[0] = _NSConcreteStackBlock;
  handler[1] = 3221225472;
  handler[2] = sub_100277018;
  handler[3] = &unk_1009A0598;
  handler[4] = a1;
  xpc_connection_set_event_handler(mach_service, handler);
  xpc_connection_set_context(a1[3], a1);
  xpc_connection_set_finalizer_f(a1[3], (xpc_finalizer_t)sub_100277108);
  return a1;
}

void sub_100277004(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100277018(uint64_t a1, void *a2)
{
}

void sub_100277020(uint64_t (****a1)(void), xpc_object_t object)
{
  xpc_type_t type = xpc_get_type(object);
  if (type == (xpc_type_t)&_xpc_type_dictionary)
  {
    sub_100277544(a1, object);
  }
  else if (type == (xpc_type_t)&_xpc_type_error)
  {
    sub_1002775E4((uint64_t)a1, object);
  }
  else
  {
    uint64_t v5 = xpc_copy_description(object);
    uint64_t v6 = qword_100A19EC8;
    if (os_log_type_enabled((os_log_t)qword_100A19EC8, OS_LOG_TYPE_ERROR)) {
      sub_10074C9BC((uint64_t)a1, (uint64_t)v5, v6);
    }
    free(v5);
  }
}

uint64_t sub_100277110(uint64_t a1)
{
  uint64_t v2 = *(NSObject **)(a1 + 16);
  if (v2) {
    dispatch_release(v2);
  }

  return a1;
}

void sub_10027714C(uint64_t a1)
{
  uint64_t v2 = qword_100A19EC8;
  if (os_log_type_enabled((os_log_t)qword_100A19EC8, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = *(void *)(a1 + 8);
    int v4 = 136315138;
    uint64_t v5 = v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Opening XPC Connection %s", (uint8_t *)&v4, 0xCu);
  }
  xpc_connection_resume(*(xpc_connection_t *)(a1 + 24));
}

void sub_1002771FC(uint64_t a1, void *a2)
{
  id v5 = a2;
  uint64_t v3 = _Block_copy(v5);
  int v4 = *(void **)(a1 + 32);
  *(void *)(a1 + 32) = v3;

  xpc_connection_cancel(*(xpc_connection_t *)(a1 + 24));
  xpc_release(*(xpc_object_t *)(a1 + 24));
}

void sub_100277264(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_100277278(uint64_t a1, void *a2, void *a3)
{
  id v5 = a3;
  uint64_t v6 = *(_xpc_connection_s **)(a1 + 24);
  id v7 = v5;
  if (v5) {
    xpc_connection_send_message_with_reply(v6, a2, *(dispatch_queue_t *)(a1 + 16), v5);
  }
  else {
    xpc_connection_send_message(v6, a2);
  }
  xpc_release(a2);
}

void sub_1002772EC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_100277300(uint64_t a1, void *a2, void *a3)
{
  uint64_t v6 = a3;
  xpc_object_t v5 = xpc_connection_send_message_with_reply_sync(*(xpc_connection_t *)(a1 + 24), a2);
  if (v5)
  {
    v6[2](v6, v5);
    xpc_release(v5);
  }
  xpc_release(a2);
}

void sub_100277380(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_100277398(uint64_t a1, char *a2, void *a3, void *a4)
{
  id v8 = a4;
  xpc_object_t v7 = sub_10027741C((int)v8, a2, a3);
  sub_100277278(a1, v7, v8);
}

void sub_100277408(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

xpc_object_t sub_10027741C(int a1, char *string, void *a3)
{
  *(_OWORD *)keys = *(_OWORD *)off_1009A05B8;
  object[0] = xpc_string_create(string);
  object[1] = a3;
  if (a3) {
    size_t v4 = 2;
  }
  else {
    size_t v4 = 1;
  }
  xpc_object_t v5 = xpc_dictionary_create((const char *const *)keys, object, v4);
  xpc_release(object[0]);
  if (a3) {
    xpc_release(a3);
  }
  return v5;
}

void sub_1002774C0(uint64_t a1, char *a2, void *a3, void *a4)
{
  id v8 = a4;
  xpc_object_t v7 = sub_10027741C((int)v8, a2, a3);
  sub_100277300(a1, v7, v8);
}

void sub_100277530(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

uint64_t sub_100277544(uint64_t (****a1)(void), xpc_object_t xdict)
{
  xpc_dictionary_get_string(xdict, "kMsgId");
  xpc_dictionary_get_value(xdict, "kMsgArgs");
  size_t v4 = ***a1;

  return v4();
}

void sub_1002775E4(uint64_t a1, void *a2)
{
  if (a2 == &_xpc_error_connection_interrupted)
  {
    sub_1002776A8(a1);
  }
  else if (a2 == &_xpc_error_connection_invalid)
  {
    sub_10027771C(a1);
  }
  else
  {
    size_t v4 = qword_100A19EC8;
    if (os_log_type_enabled((os_log_t)qword_100A19EC8, OS_LOG_TYPE_ERROR)) {
      sub_10074CA48(a1, a2, v4);
    }
  }
}

uint64_t sub_1002776A8(uint64_t a1)
{
  uint64_t v2 = qword_100A19EC8;
  if (os_log_type_enabled((os_log_t)qword_100A19EC8, OS_LOG_TYPE_ERROR)) {
    sub_10074CAF8(a1, v2);
  }
  return (*(uint64_t (**)(void))(**(void **)a1 + 8))();
}

uint64_t sub_10027771C(uint64_t result)
{
  if (!*(void *)(result + 32))
  {
    uint64_t v1 = result;
    uint64_t v2 = qword_100A19EC8;
    if (os_log_type_enabled((os_log_t)qword_100A19EC8, OS_LOG_TYPE_ERROR)) {
      sub_10074CB74(v1, v2);
    }
    return (*(uint64_t (**)(void))(**(void **)v1 + 16))();
  }
  return result;
}

void sub_100277798(uint64_t a1)
{
  uint64_t v2 = qword_100A19EC8;
  if (os_log_type_enabled((os_log_t)qword_100A19EC8, OS_LOG_TYPE_INFO))
  {
    uint64_t v3 = *(void *)(a1 + 8);
    int v6 = 136446210;
    uint64_t v7 = v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_INFO, "XPCServiceConnection (%{public}s) finalized", (uint8_t *)&v6, 0xCu);
  }
  size_t v4 = (void (**)(void))objc_retainBlock(*(id *)(a1 + 32));
  if (v4)
  {
    xpc_object_t v5 = *(void **)(a1 + 32);
    *(void *)(a1 + 32) = 0;

    v4[2](v4);
    _Block_release(v4);
  }
}

void sub_100277878(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t sub_100277890(uint64_t a1, uint64_t a2, __int16 a3)
{
  *(void *)a1 = off_1009A05D8;
  *(void *)(a1 + 8) = a2;
  *(_WORD *)(a1 + 40) = a3;
  *(_WORD *)(a1 + 42) = 0;
  *(void *)(a1 + 48) = 0;
  sub_100052DA8(a1 + 64);
  sub_1002B80C0((pthread_cond_t *)(a1 + 128));
  *(void *)(a1 + ++*(_DWORD *)(result + 184) = 0;
  *(void *)(a1 + 16) = dispatch_queue_create("com.apple.MobileBluetooth.InputDevice", 0);
  Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  *(void *)(a1 + 56) = Mutable;
  CFDictionarySetValue(Mutable, @"Transport", @"Bluetooth");
  return a1;
}

void sub_100277954(_Unwind_Exception *a1)
{
  sub_100052DA4(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_10027797C(uint64_t a1)
{
  *(void *)a1 = off_1009A05D8;
  if (*(void *)(a1 + 48))
  {
    uint64_t v2 = qword_100A1A018;
    if (os_log_type_enabled((os_log_t)qword_100A1A018, OS_LOG_TYPE_FAULT)) {
      sub_10074CBF0(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  CFRelease(*(CFTypeRef *)(a1 + 56));
  sub_1002B812C(a1 + 128);
  sub_100052DA4(a1 + 64);
  return a1;
}

void sub_100277A04(_Unwind_Exception *a1)
{
  sub_1002B812C(v1 + 128);
  sub_100052DA4(v1 + 64);
  _Unwind_Resume(a1);
}

void sub_100277A24(uint64_t a1)
{
  sub_10027797C(a1);

  operator delete();
}

uint64_t sub_100277A5C(uint64_t a1, uint64_t a2)
{
  if (*(unsigned char *)(a1 + 43))
  {
    uint64_t v4 = qword_100A1A018;
    if (os_log_type_enabled((os_log_t)qword_100A1A018, OS_LOG_TYPE_FAULT)) {
      sub_10074CC68(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  uint64_t result = sub_100277AD0(a1, a2);
  if (result) {
    *(unsigned char *)(a1 + 43) = 1;
  }
  return result;
}

uint64_t sub_100277AD0(uint64_t a1, uint64_t a2)
{
  if (*(void *)(a1 + 48))
  {
    uint64_t v4 = qword_100A1A018;
    if (os_log_type_enabled((os_log_t)qword_100A1A018, OS_LOG_TYPE_FAULT)) {
      sub_10074CBF0(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
  BOOL v12 = sub_10047B784(a2);
  uint64_t v13 = qword_100A1A018;
  if (!v12 && os_log_type_enabled((os_log_t)qword_100A1A018, OS_LOG_TYPE_FAULT))
  {
    LODWORD(__p) = 136446210;
    *(void *)((char *)&__p + 4) = "device->hasHIDInfos()";
    _os_log_fault_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_FAULT, "Assertion failed: %{public}s", (uint8_t *)&__p, 0xCu);
    uint64_t v13 = qword_100A1A018;
  }
  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
  {
    sub_100475EE0(a2, (uint64_t)&__p);
    uint64_t v14 = v38 >= 0 ? &__p : (long long *)__p;
    *(_DWORD *)long long buf = 136446210;
    id v40 = v14;
    _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "Creating IOHIDUserDevice for device %{public}s", buf, 0xCu);
    if (v38 < 0) {
      operator delete((void *)__p);
    }
  }
  HIDWORD(v15) = *(unsigned __int8 *)(a2 + 131);
  LODWORD(v15) = bswap32(*(unsigned __int16 *)(a2 + 132));
  *(_DWORD *)long long buf = (v15 >> 16) | ((*(unsigned char *)(a2 + 130) & 0x7F) << 24);
  CFNumberRef v16 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt32Type, buf);
  CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 56), @"LocationID", v16);
  CFRelease(v16);
  sub_1004A82EC((unsigned __int8 *)(a2 + 128), &__p);
  if (v38 >= 0) {
    p_p = (const char *)&__p;
  }
  else {
    p_p = (const char *)__p;
  }
  CFStringRef v18 = CFStringCreateWithCString(kCFAllocatorDefault, p_p, 0x8000100u);
  if (v38 < 0) {
    operator delete((void *)__p);
  }
  CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 56), @"SerialNumber", v18);
  CFRelease(v18);
  sub_100475EE0(a2, (uint64_t)&__p);
  if (v38 >= 0) {
    __int16 v19 = (const char *)&__p;
  }
  else {
    __int16 v19 = (const char *)__p;
  }
  CFStringRef v20 = CFStringCreateWithCString(kCFAllocatorDefault, v19, 0x8000100u);
  if (v38 < 0) {
    operator delete((void *)__p);
  }
  CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 56), @"Product", v20);
  CFRelease(v20);
  int valuePtr = 5000000;
  CFNumberRef v21 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt32Type, &valuePtr);
  CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 56), @"RequestTimeout", v21);
  CFRelease(v21);
  CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 56), @"HIDVirtualDevice", kCFBooleanFalse);
  *(void *)&long long __p = &off_100998428;
  *((void *)&__p + 1) = 0;
  int v34 = 0;
  int v35 = 0;
  if (sub_10047B6EC((_WORD *)a2, (uint64_t)&__p, (_WORD *)&v35 + 1, &v35, (_WORD *)&v34 + 1, &v34))
  {
    id v22 = (const UInt8 *)sub_10004A6E4((uint64_t)&__p);
    CFIndex v23 = sub_100045F00((uint64_t)&__p);
    CFDataRef v24 = CFDataCreate(kCFAllocatorDefault, v22, v23);
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 56), @"ReportDescriptor", v24);
    CFRelease(v24);
    CFNumberRef v25 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt16Type, (char *)&v35 + 2);
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 56), @"VendorID", v25);
    CFRelease(v25);
    CFNumberRef v26 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt16Type, &v35);
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 56), @"VendorIDSource", v26);
    CFRelease(v26);
    CFNumberRef v27 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt16Type, (char *)&v34 + 2);
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 56), @"ProductID", v27);
    CFRelease(v27);
    CFNumberRef v28 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt16Type, &v34);
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 56), @"VersionNumber", v28);
    CFRelease(v28);
  }
  if (sub_100478AF4(a2)) {
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 56), @"Manufacturer", @"Apple Inc.");
  }
  __int16 v33 = 0;
  if (sub_10047BBB0((unsigned char *)a2, (unsigned char *)&v33 + 1, &v33))
  {
    if (HIBYTE(v33)) {
      CFBooleanRef v29 = kCFBooleanTrue;
    }
    else {
      CFBooleanRef v29 = kCFBooleanFalse;
    }
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 56), @"Authenticated", v29);
    CFNumberRef v30 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt8Type, &v33);
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 56), @"IAPHIDAccessoryCategory", v30);
    CFRelease(v30);
  }
  *(void *)(a1 + ++*(_DWORD *)(result + 184) = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 56), @"SerialNumber");
  uint64_t v31 = (*(uint64_t (**)(uint64_t, void))(*(void *)a1 + 88))(a1, *(void *)(a1 + 56));
  *(void *)&long long __p = &off_100998428;
  if (*((void *)&__p + 1)) {
    sub_1000368F4(*((atomic_uint **)&__p + 1));
  }
  return v31;
}

void sub_100277FF0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, atomic_uint *a12, int a13, __int16 a14, char a15, char a16)
{
  if (a12) {
    sub_1000368F4(a12);
  }
  _Unwind_Resume(exception_object);
}

unsigned char *sub_100278050(unsigned char *result, uint64_t a2)
{
  if (result[43])
  {
    uint64_t v3 = (uint64_t)result;
    (*(void (**)(unsigned char *))(*(void *)result + 104))(result);
    sub_100277AD0(v3, a2);
    uint64_t v4 = *(uint64_t (**)(uint64_t))(*(void *)v3 + 96);
    return (unsigned char *)v4(v3);
  }
  return result;
}

uint64_t sub_1002780EC(uint64_t a1)
{
  uint64_t v2 = qword_100A1A018;
  if (os_log_type_enabled((os_log_t)qword_100A1A018, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v4 = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Starting input device", v4, 2u);
  }
  return (*(uint64_t (**)(uint64_t))(*(void *)a1 + 96))(a1);
}

uint64_t sub_100278180(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 104))();
}

void sub_1002781A4(dispatch_object_t *context)
{
  dispatch_set_context(context[2], context);
  dispatch_set_finalizer_f(context[2], (dispatch_function_t)sub_1002781FC);
  uint64_t v2 = context[2];

  dispatch_release(v2);
}

uint64_t sub_1002781FC(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void sub_100278228()
{
  CFDictionaryRef v0 = qword_100A1A018;
  if (os_log_type_enabled((os_log_t)qword_100A1A018, OS_LOG_TYPE_ERROR)) {
    sub_10074CCE0(v0, v1, v2, v3, v4, v5, v6, v7);
  }
}

void sub_10027826C(uint64_t a1, const uint8_t *a2, CFIndex a3)
{
  if (*(void *)(a1 + 48))
  {
    uint64_t v6 = sub_1002B7B48();
    uint64_t v7 = *(__IOHIDUserDevice **)(a1 + 48);
    if (!v6) {
      uint64_t v6 = mach_absolute_time();
    }
    IOHIDUserDeviceHandleReportWithTimeStamp(v7, v6, a2, a3);
  }
  else
  {
    uint64_t v8 = qword_100A1A018;
    if (os_log_type_enabled((os_log_t)qword_100A1A018, OS_LOG_TYPE_ERROR)) {
      sub_10074CD18(v8, v9, v10, v11, v12, v13, v14, v15);
    }
  }
}

void sub_100278310(uint64_t a1, char a2, int a3, uint64_t a4, uint64_t a5)
{
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 3221225472;
  void v5[2] = sub_100278424;
  v5[3] = &unk_1009A0648;
  char v6 = a2;
  v5[4] = a1;
  v5[5] = a5;
  v5[6] = a4;
  sub_100278384(a1, a2, a3, v5);
}

void sub_100278384(uint64_t a1, char a2, int a3, void *a4)
{
  uint64_t v7 = a4;
  v8[0] = 0;
  v8[1] = 0;
  sub_10003AED0((uint64_t)v8, a1 + 64);
  *(unsigned char *)(a1 + 176) = a2;
  *(_DWORD *)(a1 + 180) = a3;
  if (v7) {
    v7[2](v7);
  }
  sub_1002B818C((pthread_cond_t *)(a1 + 128));
  sub_10003AFB4((uint64_t)v8);
}

void sub_100278404(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void *sub_100278424(void *result)
{
  if (*((unsigned char *)result + 56))
  {
    uint64_t v1 = *((void *)result + 4);
    uint64_t v2 = *(size_t **)(v1 + 32);
    if (v2)
    {
      if (*(void *)(v1 + 24))
      {
        size_t v3 = *v2;
        if (*((void *)result + 5) >= v3) {
          size_t v4 = v3;
        }
        else {
          size_t v4 = *((void *)result + 5);
        }
        uint64_t result = memcpy(*(void **)(v1 + 24), *((const void **)result + 6), v4);
        **(void **)(v1 + 32) = v4;
      }
    }
  }
  return result;
}

void sub_100278480(uint64_t a1, char a2, int a3)
{
}

BOOL sub_100278488(uint64_t a1)
{
  if (*(void *)(a1 + 48))
  {
    uint64_t v2 = qword_100A1A018;
    if (os_log_type_enabled((os_log_t)qword_100A1A018, OS_LOG_TYPE_FAULT)) {
      sub_10074CBF0(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  uint64_t v10 = IOHIDUserDeviceCreateWithOptions();
  *(void *)(a1 + 48) = v10;
  if (v10)
  {
    IOHIDUserDeviceRegisterGetReportWithReturnLengthCallback();
    IOHIDUserDeviceRegisterSetReportCallback();
  }
  else
  {
    uint64_t v11 = qword_100A1A018;
    if (os_log_type_enabled((os_log_t)qword_100A1A018, OS_LOG_TYPE_ERROR)) {
      sub_10074CD50(v11, v12, v13, v14, v15, v16, v17, v18);
    }
  }
  return v10 != 0;
}

uint64_t sub_100278570(uint64_t a1, int a2, int a3, uint64_t a4, uint64_t a5)
{
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 3221225472;
  void v6[2] = sub_100278A04;
  void v6[3] = &unk_1009A0668;
  int v7 = a2;
  int v8 = a3;
  char v6[4] = a1;
  v6[5] = a4;
  v6[6] = a5;
  return sub_1002788FC(a1, v6);
}

void sub_1002785E4(uint64_t a1)
{
  if (!*(void *)(a1 + 48))
  {
    uint64_t v1 = qword_100A1A018;
    if (!os_log_type_enabled((os_log_t)qword_100A1A018, OS_LOG_TYPE_DEFAULT)) {
      return;
    }
    LOWORD(v4[0]) = 0;
    uint64_t v2 = "Could not schedule IOHIDUserDevice";
    goto LABEL_7;
  }
  if (*(unsigned char *)(a1 + 42))
  {
    uint64_t v1 = qword_100A1A018;
    if (!os_log_type_enabled((os_log_t)qword_100A1A018, OS_LOG_TYPE_DEFAULT)) {
      return;
    }
    LOWORD(v4[0]) = 0;
    uint64_t v2 = "IOHIDUserDevice is already scheduled";
LABEL_7:
    _os_log_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_DEFAULT, v2, (uint8_t *)v4, 2u);
    return;
  }
  *(unsigned char *)(a1 + 42) = 1;
  uint64_t v3 = qword_100A1A018;
  if (os_log_type_enabled((os_log_t)qword_100A1A018, OS_LOG_TYPE_DEFAULT))
  {
    v4[0] = 67109120;
    v4[1] = 1;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Scheduling IOHIDUserDevice: fIsScheduled %d", (uint8_t *)v4, 8u);
  }
  IOHIDUserDeviceScheduleWithDispatchQueue();
}

void sub_100278734(uint64_t a1)
{
  uint64_t v2 = *(const void **)(a1 + 48);
  uint64_t v3 = qword_100A1A018;
  BOOL v4 = os_log_type_enabled((os_log_t)qword_100A1A018, OS_LOG_TYPE_DEFAULT);
  if (v2)
  {
    if (v4)
    {
      int v5 = *(unsigned __int8 *)(a1 + 42);
      v6[0] = 67109120;
      v6[1] = v5;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Releasing IOHIDUserDevice: fIsScheduled %d", (uint8_t *)v6, 8u);
      uint64_t v2 = *(const void **)(a1 + 48);
    }
    if (*(unsigned char *)(a1 + 42))
    {
      *(unsigned char *)(a1 + 42) = 0;
      IOHIDUserDeviceUnscheduleFromDispatchQueue();
      uint64_t v2 = *(const void **)(a1 + 48);
    }
    CFRelease(v2);
    *(void *)(a1 + 48) = 0;
    sub_100278384(a1, 0, -536870212, 0);
  }
  else if (v4)
  {
    LOWORD(v6[0]) = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Could not release IOHIDUserDevice", (uint8_t *)v6, 2u);
  }
  if (*(void *)(a1 + 184)) {
    *(void *)(a1 + ++*(_DWORD *)(result + 184) = 0;
  }
}

uint64_t sub_10027886C(uint64_t a1, int a2, int a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5 = 3758097090;
  if (a4 && a5)
  {
    v7[0] = _NSConcreteStackBlock;
    v7[1] = 3221225472;
    _DWORD v7[2] = sub_1002789B8;
    v7[3] = &unk_1009A0668;
    void v7[4] = a1;
    v7[5] = a4;
    v7[6] = a5;
    int v8 = a2;
    int v9 = a3;
    return sub_1002788FC(a1, v7);
  }
  return v5;
}

uint64_t sub_1002788FC(uint64_t a1, void *a2)
{
  uint64_t v3 = a2;
  v6[0] = 0;
  v6[1] = 0;
  sub_10003AED0((uint64_t)v6, a1 + 64);
  if (v3[2](v3))
  {
    sub_1002B8130((pthread_cond_t *)(a1 + 128), (pthread_mutex_t *)(a1 + 64));
    if (*(unsigned char *)(a1 + 176)) {
      uint64_t v4 = 0;
    }
    else {
      uint64_t v4 = *(unsigned int *)(a1 + 180);
    }
  }
  else
  {
    uint64_t v4 = 3758097084;
  }
  sub_10003AFB4((uint64_t)v6);

  return v4;
}

void sub_100278998(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t sub_1002789B8(void *a1)
{
  uint64_t v1 = a1[4];
  *(void *)(v1 + 24) = a1[5];
  *(void *)(v1 + 32) = a1[6];
  return (***(uint64_t (****)(void))(v1 + 8))(*(void *)(v1 + 8));
}

uint64_t sub_100278A04(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(*(void *)(a1 + 32) + 8) + 8))(*(void *)(*(void *)(a1 + 32) + 8));
}

uint64_t sub_100278A48(uint64_t a1, int *a2, uint64_t a3, uint64_t a4, char a5)
{
  uint64_t result = sub_100052DA8();
  *(void *)(result + 64) = 0;
  *(void *)(result + 73) = 0;
  int v10 = *a2;
  *(_WORD *)(result + 68) = *((_WORD *)a2 + 2);
  *(_DWORD *)(result + 64) = v10;
  LOWORD(v10) = *(_WORD *)(a3 + 4);
  *(_DWORD *)(result + 73) = *(_DWORD *)a3;
  *(_WORD *)(result + 77) = v10;
  *(void *)(result + 88) = a4;
  *(unsigned char *)(result + 72) = a5;
  return result;
}

uint64_t sub_100278AB4(uint64_t a1)
{
  uint64_t v2 = qword_100A19ED8;
  if (os_log_type_enabled((os_log_t)qword_100A19ED8, OS_LOG_TYPE_DEFAULT))
  {
    if (*(unsigned char *)(a1 + 71) || *(unsigned char *)(a1 + 80)) {
      uint64_t v3 = "Yes";
    }
    else {
      uint64_t v3 = "No";
    }
    *(_DWORD *)long long buf = 136446210;
    *(void *)&uint8_t buf[4] = v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "start: already running..? %{public}s", buf, 0xCu);
  }
  if (*(unsigned char *)(a1 + 71) || *(unsigned char *)(a1 + 80) || !*(void *)(a1 + 88)) {
    return 0;
  }
  if (qword_1009FB068 != -1) {
    dispatch_once(&qword_1009FB068, &stru_1009A0688);
  }
  sub_10026E5DC(qword_1009FB060, *(unsigned char *)(a1 + 72));
  if (*(unsigned __int8 *)(a1 + 72) >= 0xAu)
  {
    if (qword_1009FB068 != -1) {
      dispatch_once(&qword_1009FB068, &stru_1009A0688);
    }
    sub_10026E5E4(qword_1009FB060);
  }
  uint64_t v5 = qword_100A19ED8;
  if (os_log_type_enabled((os_log_t)qword_100A19ED8, OS_LOG_TYPE_INFO))
  {
    sub_100278E34((unsigned __int8 *)(a1 + 64), buf);
    int v6 = v18;
    int v7 = *(unsigned char **)buf;
    sub_100278E34((unsigned __int8 *)(a1 + 73), __p);
    int v8 = buf;
    if (v6 < 0) {
      int v8 = v7;
    }
    if (v16 >= 0) {
      int v9 = __p;
    }
    else {
      int v9 = (void **)__p[0];
    }
    *(_DWORD *)__int16 v19 = 136315394;
    CFStringRef v20 = v8;
    __int16 v21 = 2080;
    id v22 = v9;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_INFO, "sending pair status request to \"%s\" for magnet device \"%s\" ", v19, 0x16u);
    if (v16 < 0) {
      operator delete(__p[0]);
    }
    if (v18 < 0) {
      operator delete(*(void **)buf);
    }
  }
  (***(void (****)(void, uint64_t, uint64_t))(a1 + 88))(*(void *)(a1 + 88), a1 + 64, a1 + 73);
  *(unsigned char *)(a1 + 71) = 1;
  int v10 = qword_100A19ED8;
  if (os_log_type_enabled((os_log_t)qword_100A19ED8, OS_LOG_TYPE_INFO))
  {
    sub_100278E34((unsigned __int8 *)(a1 + 73), buf);
    int v11 = v18;
    uint64_t v12 = *(unsigned char **)buf;
    sub_100278E34((unsigned __int8 *)(a1 + 64), __p);
    uint64_t v13 = buf;
    if (v11 < 0) {
      uint64_t v13 = v12;
    }
    if (v16 >= 0) {
      uint64_t v14 = __p;
    }
    else {
      uint64_t v14 = (void **)__p[0];
    }
    *(_DWORD *)__int16 v19 = 136315394;
    CFStringRef v20 = v13;
    __int16 v21 = 2080;
    id v22 = v14;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_INFO, "sending pair status request to \"%s\"  for aacp device \"%s\" ", v19, 0x16u);
    if (v16 < 0) {
      operator delete(__p[0]);
    }
    if (v18 < 0) {
      operator delete(*(void **)buf);
    }
  }
  (***(void (****)(void, uint64_t, uint64_t))(a1 + 88))(*(void *)(a1 + 88), a1 + 73, a1 + 64);
  uint64_t result = 1;
  *(unsigned char *)(a1 + 80) = 1;
  *(unsigned char *)(a1 + 96) = 0;
  return result;
}

void sub_100278E0C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100278E34(unsigned __int8 *a1@<X1>, void *a2@<X8>)
{
  if (qword_1009F7F00 != -1) {
    dispatch_once(&qword_1009F7F00, &stru_1009A06A8);
  }
  uint64_t v4 = sub_1004AA194((uint64_t)off_1009F7EF8, (uint64_t)a1, 1);
  if (v4)
  {
    uint64_t v5 = v4;
    sub_100475EE0(v4, (uint64_t)__p);
    if ((v8 & 0x80u) == 0) {
      unint64_t v6 = v8;
    }
    else {
      unint64_t v6 = (unint64_t)__p[1];
    }
    if ((char)v8 < 0)
    {
      operator delete(__p[0]);
      if (v6) {
        goto LABEL_9;
      }
    }
    else if (v6)
    {
LABEL_9:
      sub_100474E18(v5, a2);
      return;
    }
  }
  sub_1004A82EC(a1, a2);
}

uint64_t sub_100278EF8(uint64_t a1, uint64_t a2, unsigned __int8 *a3, int a4)
{
  if (qword_1009FB068 != -1) {
    dispatch_once(&qword_1009FB068, &stru_1009A0688);
  }
  BOOL v8 = sub_10026F08C(qword_1009FB060);
  int v9 = qword_100A19ED8;
  if (os_log_type_enabled((os_log_t)qword_100A19ED8, OS_LOG_TYPE_DEFAULT))
  {
    if (a4 == 2) {
      int v10 = "Paired";
    }
    else {
      int v10 = "Not paired";
    }
    sub_100278E34((unsigned __int8 *)a2, __p);
    if (v36 >= 0) {
      int v11 = __p;
    }
    else {
      int v11 = *(unsigned char **)__p;
    }
    uint64_t v12 = "Disallow";
    *(_DWORD *)long long buf = 136446722;
    if (v8) {
      uint64_t v12 = "Allow";
    }
    *(void *)&uint8_t buf[4] = v10;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&unsigned char buf[14] = v11;
    __int16 v38 = 2080;
    int v39 = v12;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "received pair status response \"%{public}s\" from device \"%s\", isEasyPairingAllowed = \"%s\"", buf, 0x20u);
    if (v36 < 0) {
      operator delete(*(void **)__p);
    }
  }
  v30[0] = 0;
  v30[1] = 0;
  sub_10003AED0((uint64_t)v30, a1);
  if (*(_DWORD *)a2 == *(_DWORD *)(a1 + 64) && *(unsigned __int16 *)(a2 + 4) == *(unsigned __int16 *)(a1 + 68))
  {
    *(unsigned char *)(a1 + 70) = a4;
    uint64_t v15 = (unsigned char *)(a1 + 71);
    goto LABEL_25;
  }
  if (*(_DWORD *)a2 == *(_DWORD *)(a1 + 73) && *(unsigned __int16 *)(a2 + 4) == *(unsigned __int16 *)(a1 + 77))
  {
    *(unsigned char *)(a1 + 79) = a4;
    uint64_t v15 = (unsigned char *)(a1 + 80);
LABEL_25:
    unsigned char *v15 = 0;
  }
  if (!*(unsigned char *)(a1 + 71) && !*(unsigned char *)(a1 + 80))
  {
    if (v8)
    {
      int v17 = (*(unsigned char *)(a1 + 79) & *(unsigned char *)(a1 + 70));
      char v18 = qword_100A19ED8;
      BOOL v19 = os_log_type_enabled((os_log_t)qword_100A19ED8, OS_LOG_TYPE_DEFAULT);
      if (v17 == 2)
      {
        if (v19)
        {
          sub_100278E34((unsigned __int8 *)a2, buf);
          int v20 = SHIBYTE(v38);
          __int16 v21 = *(unsigned char **)buf;
          sub_100278E34(a3, __p);
          id v22 = buf;
          if (v20 < 0) {
            id v22 = v21;
          }
          if (v36 >= 0) {
            CFIndex v23 = __p;
          }
          else {
            CFIndex v23 = *(unsigned char **)__p;
          }
          *(_DWORD *)uint64_t v31 = 136315394;
          BOOL v32 = v22;
          __int16 v33 = 2080;
          int v34 = v23;
          _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "Devices \"%s\" and \"%s\" are already paired", v31, 0x16u);
          if (v36 < 0) {
            operator delete(*(void **)__p);
          }
          if (SHIBYTE(v38) < 0) {
            operator delete(*(void **)buf);
          }
        }
        (*(void (**)(void, uint64_t, unsigned __int8 *, uint64_t))(**(void **)(a1 + 88) + 16))(*(void *)(a1 + 88), a2, a3, 1);
      }
      else
      {
        if (v19)
        {
          sub_100278E34((unsigned __int8 *)a2, buf);
          int v26 = SHIBYTE(v38);
          CFNumberRef v27 = *(unsigned char **)buf;
          sub_100278E34(a3, __p);
          CFNumberRef v28 = buf;
          if (v26 < 0) {
            CFNumberRef v28 = v27;
          }
          if (v36 >= 0) {
            CFBooleanRef v29 = __p;
          }
          else {
            CFBooleanRef v29 = *(unsigned char **)__p;
          }
          *(_DWORD *)uint64_t v31 = 136315394;
          BOOL v32 = v28;
          __int16 v33 = 2080;
          int v34 = v29;
          _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "Generate linkkey to pair between \"%s\" and \"%s\"", v31, 0x16u);
          if (v36 < 0) {
            operator delete(*(void **)__p);
          }
          if (SHIBYTE(v38) < 0) {
            operator delete(*(void **)buf);
          }
        }
        *(void *)long long buf = 0;
        *(void *)&uint8_t buf[8] = 0;
        arc4random_buf(buf, 0x10uLL);
        (*(void (**)(void, uint64_t, uint64_t, unsigned char *, uint64_t))(**(void **)(a1 + 88) + 8))(*(void *)(a1 + 88), a1 + 64, a1 + 73, buf, 16);
        (*(void (**)(void, uint64_t, uint64_t, unsigned char *, uint64_t))(**(void **)(a1 + 88) + 8))(*(void *)(a1 + 88), a1 + 73, a1 + 64, buf, 16);
        *(unsigned char *)(a1 + 71) = 1;
        *(unsigned char *)(a1 + 80) = 1;
      }
    }
    else
    {
      CFDataRef v24 = qword_100A19ED8;
      if (os_log_type_enabled((os_log_t)qword_100A19ED8, OS_LOG_TYPE_DEFAULT))
      {
        sub_100278E34((unsigned __int8 *)a2, buf);
        CFNumberRef v25 = v38 >= 0 ? buf : *(unsigned char **)buf;
        *(_DWORD *)long long __p = 136315138;
        *(void *)&__p[4] = v25;
        _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "Easy pairing request is rejected from remote source \"%s\"", __p, 0xCu);
        if (SHIBYTE(v38) < 0) {
          operator delete(*(void **)buf);
        }
      }
    }
  }
  return sub_10003AFB4((uint64_t)v30);
}

void sub_1002793A8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *__p, uint64_t a20,int a21,__int16 a22,char a23,char a24)
{
  if (a24 < 0) {
    operator delete(__p);
  }
  sub_10003AFB4((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void sub_1002793F0(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  BOOL v8 = qword_100A19ED8;
  if (os_log_type_enabled((os_log_t)qword_100A19ED8, OS_LOG_TYPE_DEFAULT))
  {
    int v9 = a4 ? "Fail" : "Success";
    sub_100278E34((unsigned __int8 *)a2, __p);
    int v10 = v16 >= 0 ? __p : (void **)__p[0];
    *(_DWORD *)long long buf = 136446466;
    char v18 = v9;
    __int16 v19 = 2080;
    int v20 = v10;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "Received link key store result \"%{public}s\" from device \"%s\" ", buf, 0x16u);
    if (v16 < 0) {
      operator delete(__p[0]);
    }
  }
  if (*(_DWORD *)a2 == *(_DWORD *)(a1 + 64) && *(unsigned __int16 *)(a2 + 4) == *(unsigned __int16 *)(a1 + 68))
  {
    uint64_t v13 = (unsigned char *)(a1 + 71);
  }
  else
  {
    if (*(_DWORD *)a2 != *(_DWORD *)(a1 + 73) || *(unsigned __int16 *)(a2 + 4) != *(unsigned __int16 *)(a1 + 77)) {
      goto LABEL_22;
    }
    uint64_t v13 = (unsigned char *)(a1 + 80);
  }
  *uint64_t v13 = 0;
LABEL_22:
  int v14 = *(unsigned __int8 *)(a1 + 96) | a4;
  *(unsigned char *)(a1 + 96) |= a4;
  if (!*(unsigned char *)(a1 + 71) && !*(unsigned char *)(a1 + 80)) {
    (*(void (**)(void, uint64_t, uint64_t, void))(**(void **)(a1 + 88) + 16))(*(void *)(a1 + 88), a2, a3, 2 * (v14 != 0));
  }
}

void sub_1002795AC(id a1)
{
}

void sub_1002795F0()
{
}

void sub_100279614(id a1)
{
}

void sub_100279658()
{
}

uint64_t sub_10027967C(uint64_t a1, uint64_t a2, _xpc_connection_s *a3, uint64_t a4)
{
  uint64_t v5 = sub_100056C90(a1, a2, a3, a4);
  *(void *)uint64_t v5 = off_1009A08D0;
  *(void *)(v5 + 144) = off_1009A09A0;
  *(void *)(v5 + 152) = off_1009A09E8;
  *(void *)(v5 + 160) = off_1009A0A18;
  *(unsigned char *)(v5 + 168) = 0;
  uint64_t v6 = v5 + 216;
  *(void *)(v5 + 176) = 0;
  *(void *)(v5 + ++*(_DWORD *)(result + 184) = 0;
  *(_WORD *)(v5 + 192) = 0;
  *(void *)(v5 + 204) = 0;
  *(void *)(v5 + 196) = 0;
  *(unsigned char *)(v5 + 212) = 0;
  sub_100052DA8(v5 + 216);
  *(void *)(a1 + 280) = 0;
  v10[0] = 0;
  v10[1] = 0;
  sub_10003AED0((uint64_t)v10, v6);
  uint64_t v7 = +[NSMutableDictionary dictionary];
  BOOL v8 = *(void **)(a1 + 280);
  *(void *)(a1 + 280) = v7;

  sub_10003AFB4((uint64_t)v10);
  return a1;
}

void sub_10027978C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  sub_10003AFB4((uint64_t)&a9);

  sub_100052DA4(v10);
  uint64_t v12 = *(std::__shared_weak_count **)(v9 + 184);
  if (v12) {
    sub_10008A294(v12);
  }
  sub_10000C178(v9);
  _Unwind_Resume(a1);
}

uint64_t sub_1002797E0(uint64_t a1)
{
  *(void *)a1 = off_1009A08D0;
  *(void *)(a1 + 144) = off_1009A09A0;
  *(void *)(a1 + 152) = off_1009A09E8;
  *(void *)(a1 + 160) = off_1009A0A18;

  sub_100052DA4(a1 + 216);
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 184);
  if (v2) {
    sub_10008A294(v2);
  }

  return sub_10000C178(a1);
}

void sub_1002798B8(uint64_t a1)
{
  sub_1002797E0(a1);

  operator delete();
}

void (*sub_1002798F0(uint64_t a1, int a2))(uint64_t a1, xpc_object_t xdict)
{
  uint64_t result = sub_100279D20;
  switch(a2)
  {
    case 1:
      return result;
    case 2:
      uint64_t v3 = (void (*)(uint64_t, xpc_object_t))sub_10027A3B8;
      goto LABEL_39;
    case 7:
      uint64_t v3 = sub_10027A5D0;
      goto LABEL_39;
    case 8:
      uint64_t v3 = sub_10027B448;
      goto LABEL_39;
    case 9:
      uint64_t v3 = (void (*)(uint64_t, xpc_object_t))sub_10027B520;
      goto LABEL_39;
    case 10:
      uint64_t v3 = sub_10027BA74;
      goto LABEL_39;
    case 12:
      uint64_t v3 = (void (*)(uint64_t, xpc_object_t))sub_10027B76C;
      goto LABEL_39;
    case 13:
      uint64_t v3 = sub_10027B59C;
      goto LABEL_39;
    case 25:
      uint64_t v3 = sub_10027C988;
      goto LABEL_39;
    case 26:
      uint64_t v3 = sub_10027CBA8;
      goto LABEL_39;
    case 27:
      uint64_t v3 = (void (*)(uint64_t, xpc_object_t))sub_10027A420;
      goto LABEL_39;
    case 28:
      uint64_t v3 = (void (*)(uint64_t, xpc_object_t))sub_10027A860;
      goto LABEL_39;
    case 29:
      uint64_t v3 = (void (*)(uint64_t, xpc_object_t))sub_10027A93C;
      goto LABEL_39;
    case 30:
      uint64_t v3 = sub_10027B078;
      goto LABEL_39;
    case 31:
      uint64_t v3 = sub_10027CD6C;
      goto LABEL_39;
    case 32:
      uint64_t v3 = sub_10027D408;
      goto LABEL_39;
    case 33:
      uint64_t v3 = (void (*)(uint64_t, xpc_object_t))sub_10027D89C;
      goto LABEL_39;
    case 34:
      uint64_t v3 = (void (*)(uint64_t, xpc_object_t))sub_10027B2F4;
      goto LABEL_39;
    case 35:
      uint64_t v3 = (void (*)(uint64_t, xpc_object_t))sub_10027B338;
      goto LABEL_39;
    case 36:
      uint64_t v3 = (void (*)(uint64_t, xpc_object_t))sub_10027B37C;
      goto LABEL_39;
    case 37:
      uint64_t v3 = sub_10027AA18;
      goto LABEL_39;
    case 38:
      uint64_t v3 = sub_10027AB50;
      goto LABEL_39;
    case 39:
      uint64_t v3 = sub_10027AD24;
      goto LABEL_39;
    case 40:
      uint64_t v3 = sub_10027AF00;
      goto LABEL_39;
    case 41:
      uint64_t v3 = sub_10027C44C;
      goto LABEL_39;
    case 42:
      uint64_t v3 = (void (*)(uint64_t, xpc_object_t))sub_10027BB48;
      goto LABEL_39;
    case 44:
      uint64_t v3 = (void (*)(uint64_t, xpc_object_t))sub_10027B3C0;
      goto LABEL_39;
    case 47:
      uint64_t v3 = (void (*)(uint64_t, xpc_object_t))sub_10027B404;
      goto LABEL_39;
    case 52:
      uint64_t v3 = (void (*)(uint64_t, xpc_object_t))sub_10027B1FC;
      goto LABEL_39;
    case 53:
      uint64_t v3 = (void (*)(uint64_t, xpc_object_t))sub_10027D94C;
      goto LABEL_39;
    case 54:
      uint64_t v3 = (void (*)(uint64_t, xpc_object_t))sub_10027DB1C;
      goto LABEL_39;
    case 55:
      uint64_t v3 = (void (*)(uint64_t, xpc_object_t))sub_10027DC6C;
      goto LABEL_39;
    case 58:
      uint64_t v3 = sub_10027DE74;
      goto LABEL_39;
    case 59:
      uint64_t v3 = sub_10027E000;
      goto LABEL_39;
    case 60:
      uint64_t v3 = (void (*)(uint64_t, xpc_object_t))sub_10027E168;
LABEL_39:
      uint64_t result = v3;
      break;
    default:
      if (os_log_type_enabled((os_log_t)qword_100A19EC8, OS_LOG_TYPE_ERROR)) {
        sub_10074CD88();
      }
      uint64_t result = 0;
      break;
  }
  return result;
}

void sub_100279D20(uint64_t a1, xpc_object_t xdict)
{
  uint64_t v60 = 0;
  uint64_t v61 = 0;
  __int16 v59 = 0;
  uint64_t v55 = 0;
  int v56 = &v55;
  uint64_t v57 = 0x2020000000;
  int v58 = 0;
  v53[0] = 0;
  v53[1] = v53;
  v53[2] = 0x2020000000;
  char v54 = 0;
  xpc_object_t value = xpc_dictionary_get_value(xdict, "kCBMsgArgs");
  sub_100019738(value, "kCBMsgArgName");
  id v4 = (id)objc_claimAutoreleasedReturnValue();
  if (!sub_1000198BC(value, 1, v5, v6, v7, v8, v9, v10, (uint64_t)"kCBMsgArgType") && v4)
  {
    int v11 = v61;
    uint64_t v51 = 0;
    uint64_t v52 = 0;
    uint64_t v49 = 0;
    uint64_t v50 = 0;
    uint64_t v47 = 0;
    uint64_t v48 = 1;
    uint64_t v12 = sub_100019738(v59, "kCBInitOptionRestoreIdentifier");
    sub_1000198BC(v59, 0, v13, v14, v15, v16, v17, v18, (uint64_t)"kCBInitOptionShowPowerAlert");
    int v19 = sub_1002D4A5C(v59, "kCBManagerPrivacySupported");
    long long v45 = 0u;
    long long v46 = 0u;
    xpc_connection_get_audit_token();
    uint64_t v20 = sub_10000F1E0();
    __int16 v21 = *(void **)(a1 + 96);
    *(void *)(a1 + 96) = v20;

    id v22 = *(id *)(a1 + 96);
    CFIndex v23 = qword_100A19EC8;
    if (os_log_type_enabled((os_log_t)qword_100A19EC8, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 138412546;
      *(void *)&uint8_t buf[4] = v22;
      *(_WORD *)&unsigned char buf[12] = 1024;
      *(_DWORD *)&unsigned char buf[14] = v19;
      _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "Classic kCBManagerAppSDKVersion for app %@ : %d", buf, 0x12u);
    }
    uint64_t v79 = 0;
    long long v77 = 0u;
    long long v78 = 0u;
    long long v75 = 0u;
    long long v76 = 0u;
    long long v73 = 0u;
    long long v74 = 0u;
    long long v71 = 0u;
    long long v72 = 0u;
    long long v69 = 0u;
    long long v70 = 0u;
    long long v67 = 0u;
    long long v68 = 0u;
    long long v65 = 0u;
    long long v66 = 0u;
    memset(buf, 0, sizeof(buf));
    sub_1000419CC((uint64_t)buf);
    id v4 = v22;
    strlen((const char *)[v4 UTF8String]);
    uint64_t v24 = sub_10003AB28((uint64_t)buf);
    sub_10003AB28(v24);
    uint64_t v25 = std::ostream::operator<<();
    sub_10003AB28(v25);
    std::ostream::operator<<();
    std::stringbuf::str();
    int v26 = (void *)v12;
    CFNumberRef v27 = (void **)(a1 + 56);
    if (*(char *)(a1 + 79) < 0) {
      operator delete(*v27);
    }
    *(_OWORD *)CFNumberRef v27 = v62;
    *(void *)(a1 + 72) = v63;
    CFNumberRef v28 = qword_100A19EC8;
    if (os_log_type_enabled((os_log_t)qword_100A19EC8, OS_LOG_TYPE_DEFAULT))
    {
      CFBooleanRef v29 = (void *)(a1 + 56);
      if (*(char *)(a1 + 79) < 0) {
        CFBooleanRef v29 = *v27;
      }
      LODWORD(v62) = 136446210;
      *(void *)((char *)&v62 + 4) = v29;
      _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, "Classic Received XPC check-in from session \"%{public}s\"", (uint8_t *)&v62, 0xCu);
    }
    CFNumberRef v30 = v26;
    if (*(void *)(a1 + 128))
    {
      uint64_t v31 = qword_100A19EC8;
      if (os_log_type_enabled((os_log_t)qword_100A19EC8, OS_LOG_TYPE_ERROR)) {
        sub_10074CE7C((char *)(a1 + 79), (void *)(a1 + 56), v31);
      }
    }
    else
    {
      int v32 = v60;
      if (v60 == 20161219)
      {
        uint64_t v33 = sub_100019878();
        v36[0] = _NSConcreteStackBlock;
        v36[1] = 3221225472;
        v36[2] = sub_10027E1E0;
        v36[3] = &unk_1009A0A48;
        __int16 v44 = 0;
        uint64_t v41 = a1;
        uint64_t v42 = v52;
        id v37 = v4;
        int v43 = v11;
        id v38 = v26;
        int v39 = &v55;
        id v40 = v53;
        sub_1000197D8(v33, v36);
      }
      else
      {
        int v34 = qword_100A19EC8;
        if (os_log_type_enabled((os_log_t)qword_100A19EC8, OS_LOG_TYPE_ERROR)) {
          sub_10074CDF0(v32, v34);
        }
      }
    }
    if (SHIBYTE(v68) < 0) {
      operator delete(*((void **)&v67 + 1));
    }
    std::streambuf::~streambuf();
    std::ostream::~ostream();
    std::ios::~ios();
  }
  uint64_t v35 = *(void *)(a1 + 128);
  if (v35) {
    (*(void (**)(uint64_t, uint64_t, void))(*(void *)a1 + 64))(a1, v35, *((unsigned int *)v56 + 6));
  }
  else {
    sub_1004F10B0(a1, 2u);
  }

  _Block_object_dispose(v53, 8);
  _Block_object_dispose(&v55, 8);
}

void sub_10027A320(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,void *a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,void *a34,void *a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,char a52,uint64_t a53,uint64_t a54,uint64_t a55,char a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  sub_10027E318((uint64_t)&a67);
  _Block_object_dispose(&a52, 8);
  _Block_object_dispose(&a56, 8);
  _Unwind_Resume(a1);
}

void sub_10027A3B8(uint64_t a1)
{
  (*(void (**)(uint64_t, uint64_t))(*(void *)a1 + 24))(a1, 1);

  sub_1000173FC(a1, 5, 0, 0);
}

void sub_10027A420(int a1, xpc_object_t xdict)
{
  xpc_object_t value = xpc_dictionary_get_value(xdict, "kCBMsgArgs");
  int v3 = sub_1002D4A5C(value, "kCBMsgArgBTPowerState");
  if (+[CBController bluetoothModificationAllowed])
  {
    if (v3)
    {
      if (qword_1009F8748 != -1) {
        dispatch_once(&qword_1009F8748, &stru_1009A0D20);
      }
      id v4 = off_1009F8740;
      sub_1004B94DC((uint64_t)v4);
    }
    else
    {
      if (qword_1009F8748 != -1) {
        dispatch_once(&qword_1009F8748, &stru_1009A0D20);
      }
      uint64_t v7 = off_1009F8740;
      sub_1004B98D4((uint64_t)v7);
    }
  }
  else
  {
    uint64_t v5 = qword_100A19EC8;
    if (os_log_type_enabled((os_log_t)qword_100A19EC8, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v6 = "on";
      if (v3) {
        uint64_t v6 = "off";
      }
      int v8 = 136315138;
      uint64_t v9 = v6;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "Bluetooth Toggling is turned off by managing client,keeping the power state to %s", (uint8_t *)&v8, 0xCu);
    }
  }
}

void sub_10027A5D0(uint64_t a1, xpc_object_t original)
{
  xpc_object_t reply = xpc_dictionary_create_reply(original);
  if (reply)
  {
    id v4 = reply;
    __int16 v13 = 0;
    int v12 = 0;
    if (qword_1009F8070 != -1) {
      dispatch_once(&qword_1009F8070, &stru_1009A0CC0);
    }
    sub_1004E219C((uint64_t)off_1009F8068, (uint64_t)&v12);
    sub_1004A82EC((unsigned __int8 *)&v12, &__p);
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      p_p = &__p;
    }
    else {
      p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
    }
    xpc_dictionary_set_string(v4, "kCBMsgArgAddressString", (const char *)p_p);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
    if (qword_1009F8748 != -1) {
      dispatch_once(&qword_1009F8748, &stru_1009A0D20);
    }
    unsigned int v6 = sub_100028CB4((uint64_t)off_1009F8740);
    xpc_dictionary_set_int64(v4, "kCBMsgArgBTPowerState", v6);
    memset(&__p, 0, sizeof(__p));
    if (qword_1009F8070 != -1) {
      dispatch_once(&qword_1009F8070, &stru_1009A0CC0);
    }
    sub_1004E2268((uint64_t)off_1009F8068, &__p);
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      uint64_t v7 = &__p;
    }
    else {
      uint64_t v7 = (std::string *)__p.__r_.__value_.__r.__words[0];
    }
    xpc_dictionary_set_string(v4, "kCBMsgArgName", (const char *)v7);
    if (qword_1009F7EB0 != -1) {
      dispatch_once(&qword_1009F7EB0, &stru_1009A0D40);
    }
    char v8 = sub_1004B6000();
    xpc_dictionary_set_BOOL(v4, "kCBMsgArgInquiryState", v8);
    BOOL value = 0;
    if (qword_1009F8070 != -1) {
      dispatch_once(&qword_1009F8070, &stru_1009A0CC0);
    }
    sub_1004E3008((uint64_t)off_1009F8068, &value);
    BOOL v9 = 0;
    if (qword_1009F8070 != -1) {
      dispatch_once(&qword_1009F8070, &stru_1009A0CC0);
    }
    sub_1004E4370((uint64_t)off_1009F8068, &v9);
    xpc_dictionary_set_BOOL(v4, "kCBMsgArgDiscoverableState", value);
    xpc_dictionary_set_BOOL(v4, "kCBMsgArgConnectableState", v9);
    xpc_connection_send_message(*(xpc_connection_t *)(a1 + 16), v4);
    xpc_release(v4);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
  }
}

void sub_10027A838(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10027A860(uint64_t a1, xpc_object_t xdict)
{
  xpc_object_t value = xpc_dictionary_get_value(xdict, "kCBMsgArgs");
  int v4 = sub_1002D4A5C(value, "kCBMsgArgConnectableState");
  if (qword_1009F7EB0 != -1) {
    dispatch_once(&qword_1009F7EB0, &stru_1009A0D40);
  }
  uint64_t v5 = off_1009F7EA8;
  unint64_t v6 = sub_100019D1C(*(void *)(a1 + 128));
  unint64_t v7 = sub_1004B11D8(v5, v6);
  if (qword_1009F7EB0 != -1) {
    dispatch_once(&qword_1009F7EB0, &stru_1009A0D40);
  }
  char v8 = off_1009F7EA8;

  return sub_1004B14D8(v8, v7, v4);
}

uint64_t sub_10027A93C(uint64_t a1, xpc_object_t xdict)
{
  xpc_object_t value = xpc_dictionary_get_value(xdict, "kCBMsgArgs");
  int v4 = sub_1002D4A5C(value, "kCBMsgArgDiscoverableState");
  if (qword_1009F7EB0 != -1) {
    dispatch_once(&qword_1009F7EB0, &stru_1009A0D40);
  }
  uint64_t v5 = off_1009F7EA8;
  unint64_t v6 = sub_100019D1C(*(void *)(a1 + 128));
  unint64_t v7 = sub_1004B11D8(v5, v6);
  if (qword_1009F7EB0 != -1) {
    dispatch_once(&qword_1009F7EB0, &stru_1009A0D40);
  }
  char v8 = off_1009F7EA8;

  return sub_1004B170C(v8, v7, v4);
}

void sub_10027AA18(uint64_t a1, void *a2)
{
  xpc_object_t v4 = xpc_array_create(0, 0);
  xpc_object_t value = xpc_dictionary_get_value(a2, "kCBMsgArgs");
  unint64_t v6 = sub_1002D49BC(value, "kCBMsgArgConnectionState");
  unint64_t v7 = v6;
  if (v6) {
    unsigned __int8 v8 = [v6 BOOLValue];
  }
  else {
    unsigned __int8 v8 = 0;
  }
  uint64_t v9 = sub_100019878();
  v12[0] = _NSConcreteStackBlock;
  v12[1] = 3221225472;
  _DWORD v12[2] = sub_10027E68C;
  _OWORD v12[3] = &unk_1009A0160;
  unsigned __int8 v13 = v8;
  v12[4] = a1;
  v12[5] = v4;
  sub_1000197D8(v9, v12);
  xpc_object_t reply = xpc_dictionary_create_reply(a2);
  int v11 = reply;
  if (reply)
  {
    xpc_dictionary_set_value(reply, "kCBMsgArgDevices", v4);
    xpc_connection_send_message(*(xpc_connection_t *)(a1 + 16), v11);
    xpc_release(v11);
  }
  xpc_release(v4);
}

void sub_10027AB3C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_10027AB50(uint64_t a1, xpc_object_t xdict)
{
  xpc_object_t value = xpc_dictionary_get_value(xdict, "kCBMsgArgs");
  uint64_t v5 = sub_100019738(value, "kCBMsgArgAddressString");
  unint64_t v6 = sub_1006ADA24(v5);
  if ((v6 & 0xFFFFFFFFFFFFLL) != 0)
  {
    long long v12 = 0uLL;
    if (qword_1009F7EE0 != -1) {
      dispatch_once(&qword_1009F7EE0, &stru_1009A0D80);
    }
    sub_100014B58((uint64_t)off_1009F7ED8, v6, 1u, 0, 0, 0, (unsigned __int8 *)&v12);
    unint64_t v7 = sub_100031234((const unsigned __int8 *)&v12);
    xpc_object_t v8 = sub_10027E878(v7);
  }
  else
  {
    uint64_t v9 = qword_100A19EC8;
    if (os_log_type_enabled((os_log_t)qword_100A19EC8, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(v12) = 138412290;
      *(void *)((char *)&v12 + 4) = v5;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "Warning: Invalid parameters, cannot retrieve a peer with address \"%@\"", (uint8_t *)&v12, 0xCu);
    }
    xpc_object_t v8 = 0;
  }
  xpc_object_t reply = xpc_dictionary_create_reply(xdict);
  int v11 = reply;
  if (reply)
  {
    xpc_dictionary_set_value(reply, "kCBMsgArgDevices", v8);
    xpc_connection_send_message(*(xpc_connection_t *)(a1 + 16), v11);
    xpc_release(v11);
  }
  if (v8) {
    xpc_release(v8);
  }
}

void sub_10027ACF8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_10027AD24(uint64_t a1, xpc_object_t xdict)
{
  uint64_t v24 = 0;
  xpc_object_t value = xpc_dictionary_get_value(xdict, "kCBMsgArgs");
  uint64_t v5 = sub_1002D48BC(value, "kCBMsgArgDeviceUUID");
  int v12 = sub_1000198BC(value, 1, v6, v7, v8, v9, v10, v11, (uint64_t)"kCBMsgArgOptions");
  char v13 = sub_1002D4A5C(0, "kCBMsgIdSessionPairingRequest");
  uint64_t v14 = sub_1002D4A5C(0, "kCBMsgArgConnectToPAN");
  if (v12 || !v5)
  {
    sub_1004F1028(a1, 49, xdict, 3);
  }
  else
  {
    uint64_t v15 = v14;
    uint64_t v16 = +[ConnectOptions alertOptionsWithConnectionAlerts:0 disconnectionAlerts:0 notificationAlerts:0 delay:0 bridgeTransport:0];
    [v16 setConnectingToPANServices:v15];
    uint64_t v17 = sub_100019878();
    v19[0] = _NSConcreteStackBlock;
    v19[1] = 3221225472;
    void v19[2] = sub_10027EDA4;
    v19[3] = &unk_1009999E8;
    uint64_t v22 = a1;
    id v20 = v5;
    id v18 = v16;
    id v21 = v18;
    char v23 = v13;
    sub_1000197D8(v17, v19);
  }
}

void sub_10027AEC0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18, void *a19)
{
  _Unwind_Resume(a1);
}

void sub_10027AF00(uint64_t a1, xpc_object_t xdict)
{
  uint64_t v24 = 0;
  xpc_object_t value = xpc_dictionary_get_value(xdict, "kCBMsgArgs");
  uint64_t v5 = sub_1002D48BC(value, "kCBMsgArgDeviceUUID");
  char v23 = 0;
  if (sub_1000198BC(value, 1, v6, v7, v8, v9, v10, v11, (uint64_t)"kCBMsgArgOptions") || !v5)
  {
    sub_1004F1028(a1, 50, xdict, 3);
  }
  else if (!sub_1000198BC(v23, 0, v12, v13, v14, v15, v16, v17, (uint64_t)"kCBCancelConnectOptionForce"))
  {
    uint64_t v18 = sub_100019878();
    v19[0] = _NSConcreteStackBlock;
    v19[1] = 3221225472;
    void v19[2] = sub_10027EEF8;
    v19[3] = &unk_100998570;
    uint64_t v21 = a1;
    id v20 = v5;
    uint64_t v22 = v24;
    sub_1000197D8(v18, v19);
  }
}

void sub_10027B058(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18)
{
  _Unwind_Resume(a1);
}

void sub_10027B078(uint64_t a1, xpc_object_t xdict)
{
  xpc_object_t value = xpc_dictionary_get_value(xdict, "kCBMsgArgs");
  if (value)
  {
    xpc_object_t v4 = value;
    int v5 = sub_1002D4A5C(value, "kCBMsgArgInquiryInfinite");
    int v6 = sub_1002D4A5C(v4, "kCBMsgArgInquiryReportDuplicates");
    uint64_t v7 = sub_1002D49BC(v4, "kCBMsgArgInquiryLength");
    unsigned int v8 = [v7 intValue];

    uint64_t v9 = qword_100A19EC8;
    if (os_log_type_enabled((os_log_t)qword_100A19EC8, OS_LOG_TYPE_DEFAULT))
    {
      v11[0] = 67109632;
      v11[1] = v5;
      __int16 v12 = 1024;
      int v13 = v6;
      __int16 v14 = 1024;
      unsigned int v15 = v8;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "Bluetooth discovery Handle Inquiry Msg: continuous=%d, reportDuplicates=%d , length=%d", (uint8_t *)v11, 0x14u);
    }
    sub_10027F4A0(a1, v5, v10, 0, 0, v6);
  }
  else if (os_log_type_enabled((os_log_t)qword_100A19EC8, OS_LOG_TYPE_ERROR))
  {
    sub_10074CEF8();
  }
}

void sub_10027B1E4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_10027B1FC(uint64_t a1)
{
  if (qword_1009F8398 != -1) {
    dispatch_once(&qword_1009F8398, &stru_1009A0DE0);
  }
  uint64_t v2 = off_1009F8390;
  int v3 = *(std::__shared_weak_count **)(a1 + 184);
  uint64_t v6 = *(void *)(a1 + 176);
  uint64_t v7 = v3;
  if (v3) {
    atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  sub_10050542C(v2, &v6);
  if (v7) {
    sub_10008A294(v7);
  }
  *(_WORD *)(a1 + 192) = 0;
  if (*(unsigned char *)(a1 + 212))
  {
    xpc_object_t v4 = qword_100A19EC8;
    if (os_log_type_enabled((os_log_t)qword_100A19EC8, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)int v5 = 0;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "startInquiry: Disabling duplicate reporting.", v5, 2u);
    }
    sub_100501568(*(void *)(a1 + 176));
    *(unsigned char *)(a1 + 212) = 0;
  }
}

void sub_10027B2DC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a12) {
    sub_10008A294(a12);
  }
  _Unwind_Resume(exception_object);
}

void sub_10027B2F4()
{
  CFDictionaryRef v0 = qword_100A19EC8;
  if (os_log_type_enabled((os_log_t)qword_100A19EC8, OS_LOG_TYPE_ERROR)) {
    sub_10074CF2C(v0, v1, v2, v3, v4, v5, v6, v7);
  }
}

void sub_10027B338()
{
  CFDictionaryRef v0 = qword_100A19EC8;
  if (os_log_type_enabled((os_log_t)qword_100A19EC8, OS_LOG_TYPE_ERROR)) {
    sub_10074CFA4(v0, v1, v2, v3, v4, v5, v6, v7);
  }
}

void sub_10027B37C()
{
  CFDictionaryRef v0 = qword_100A19EC8;
  if (os_log_type_enabled((os_log_t)qword_100A19EC8, OS_LOG_TYPE_ERROR)) {
    sub_10074D01C(v0, v1, v2, v3, v4, v5, v6, v7);
  }
}

void sub_10027B3C0()
{
  CFDictionaryRef v0 = qword_100A19EC8;
  if (os_log_type_enabled((os_log_t)qword_100A19EC8, OS_LOG_TYPE_ERROR)) {
    sub_10074D094(v0, v1, v2, v3, v4, v5, v6, v7);
  }
}

void sub_10027B404()
{
  CFDictionaryRef v0 = qword_100A19EC8;
  if (os_log_type_enabled((os_log_t)qword_100A19EC8, OS_LOG_TYPE_ERROR)) {
    sub_10074D10C(v0, v1, v2, v3, v4, v5, v6, v7);
  }
}

void sub_10027B448(uint64_t a1, xpc_object_t xdict)
{
  uint64_t v14 = 0;
  xpc_object_t value = xpc_dictionary_get_value(xdict, "kCBMsgArgs");
  if (!sub_1000198BC(value, 0, v4, v5, v6, v7, v8, v9, (uint64_t)"kCBMsgArgProgrammaticPairing"))
  {
    BOOL v10 = v14 != 0;
    uint64_t v11 = sub_100019878();
    v12[0] = _NSConcreteStackBlock;
    v12[1] = 3221225472;
    _DWORD v12[2] = sub_1002801D4;
    _OWORD v12[3] = &unk_100998A58;
    v12[4] = a1;
    BOOL v13 = v10;
    sub_1000197D8(v11, v12);
    *(unsigned char *)(a1 + 168) = 1;
  }
}

void sub_10027B520(uint64_t a1)
{
  uint64_t v2 = sub_100019878();
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 3221225472;
  _DWORD v3[2] = sub_1002802D0;
  v3[3] = &unk_100997528;
  v3[4] = a1;
  sub_1000197D8(v2, v3);
}

void sub_10027B59C(uint64_t a1, xpc_object_t xdict)
{
  xpc_object_t value = xpc_dictionary_get_value(xdict, "kCBMsgArgs");
  uint64_t v4 = sub_1002D48BC(value, "kCBMsgArgDeviceUUID");
  if (v4)
  {
    uint64_t v5 = qword_100A19EC8;
    if (os_log_type_enabled((os_log_t)qword_100A19EC8, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v6 = (void *)(a1 + 56);
      if (*(char *)(a1 + 79) < 0) {
        uint64_t v6 = (void *)*v6;
      }
      int v9 = 136446466;
      BOOL v10 = v6;
      __int16 v11 = 2112;
      __int16 v12 = v4;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "Session \"%{public}s\" is asking to unpair device \"%@\"", (uint8_t *)&v9, 0x16u);
    }
    if (qword_1009F7EE0 != -1) {
      dispatch_once(&qword_1009F7EE0, &stru_1009A0D80);
    }
    uint64_t v7 = sub_100030DCC((uint64_t)off_1009F7ED8, v4, 0);
    if (qword_1009F7F00 != -1) {
      dispatch_once(&qword_1009F7F00, &stru_1009A0DA0);
    }
    uint64_t v8 = (unsigned __int8 *)sub_100030F10((uint64_t)off_1009F7EF8, v7, 0);
    if (v8)
    {
      if (qword_1009F8768 != -1) {
        dispatch_once(&qword_1009F8768, &stru_1009A0D60);
      }
      sub_100611000((uint64_t)off_1009F8760, v8);
    }
  }
}

void sub_10027B750(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_10027B76C(int a1, xpc_object_t xdict)
{
  xpc_object_t value = xpc_dictionary_get_value(xdict, "kCBMsgArgs");
  uint64_t v4 = sub_1002D48BC(value, "kCBMsgArgDeviceUUID");
  xpc_object_t v5 = xpc_dictionary_get_value(xdict, "kCBMsgArgs");
  if (!sub_1000198BC(v5, 1, v6, v7, v8, v9, v10, v11, (uint64_t)"kCBMsgArgPairingType") && v4)
  {
    if (qword_1009F7EE0 != -1) {
      dispatch_once(&qword_1009F7EE0, &stru_1009A0D80);
    }
    uint64_t v12 = sub_100030DCC((uint64_t)off_1009F7ED8, v4, 0);
    if (qword_1009F7F00 != -1) {
      dispatch_once(&qword_1009F7F00, &stru_1009A0DA0);
    }
    uint64_t v13 = sub_100030F10((uint64_t)off_1009F7EF8, v12, 0);
    if (v13)
    {
      uint64_t v14 = qword_100A19EC8;
      if (os_log_type_enabled((os_log_t)qword_100A19EC8, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)long long buf = 134218242;
        uint64_t v16 = 0;
        __int16 v17 = 2112;
        uint64_t v18 = v4;
        _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "handlePairingAgentRespondToPairing: Accepting Pairing Request with Passkey %llu for the device \"%@\"", buf, 0x16u);
      }
      if (qword_1009F8768 != -1) {
        dispatch_once(&qword_1009F8768, &stru_1009A0D60);
      }
      sub_10060FAF0((uint64_t)off_1009F8760, v13, 0);
    }
    else if (os_log_type_enabled((os_log_t)qword_100A19EC8, OS_LOG_TYPE_ERROR))
    {
      sub_10074D1B8();
    }
  }
}

void sub_10027BA54(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_10027BA74(uint64_t a1, void *a2)
{
  xpc_object_t v4 = xpc_array_create(0, 0);
  uint64_t v5 = sub_100019878();
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 3221225472;
  void v8[2] = sub_1002803BC;
  void v8[3] = &unk_100998260;
  v8[4] = a1;
  v8[5] = v4;
  sub_1000197D8(v5, v8);
  xpc_object_t reply = xpc_dictionary_create_reply(a2);
  if (reply)
  {
    uint64_t v7 = reply;
    xpc_dictionary_set_value(reply, "kCBMsgArgDevices", v4);
    xpc_connection_send_message(*(xpc_connection_t *)(a1 + 16), v7);
    xpc_release(v7);
  }
  xpc_release(v4);
}

void sub_10027BB48(int a1, xpc_object_t xdict)
{
  xpc_object_t value = xpc_dictionary_get_value(xdict, "kCBMsgArgs");
  if (value)
  {
    uint64_t v3 = value;
    xpc_object_t v4 = sub_1002D48BC(value, "kCBMsgArgDeviceUUID");
    if (v4)
    {
      if (qword_1009F7EE0 != -1) {
        dispatch_once(&qword_1009F7EE0, &stru_1009A0D80);
      }
      uint64_t v5 = sub_100030DCC((uint64_t)off_1009F7ED8, v4, 0);
      if (qword_1009F7F00 != -1) {
        dispatch_once(&qword_1009F7F00, &stru_1009A0DA0);
      }
      uint64_t v6 = sub_100030F10((uint64_t)off_1009F7EF8, v5, 0);
      if (v6)
      {
        uint64_t v7 = sub_100019738(v3, "kCBMsgArgName");
        uint64_t v21 = v7;
        if (v7)
        {
          sub_10004191C(__p, (char *)[v7 UTF8String]);
          sub_1004776CC(v6, (uint64_t)__p, 1);
          if (v31 < 0) {
            operator delete(__p[0]);
          }
        }
        uint64_t v8 = sub_1002D49BC(v3, "kCBMsgArgSmartRoutingEnabled");
        id v20 = v8;
        if (v8) {
          sub_100484DC4(v6, (uint64_t)[v8 charValue]);
        }
        sub_100485154(v6);
        CFBooleanRef v29 = sub_1002D49BC(v3, "kCBMsgArgInEarDetectionEnabled");
        if (v29)
        {
          if (qword_1009F7EF0 != -1) {
            dispatch_once(&qword_1009F7EF0, &stru_1009A0E20);
          }
          sub_100456548((uint64_t)off_1009F7EE8, v6, (int)[v29 BOOLValue:v20]);
        }
        CFNumberRef v28 = sub_1002D49BC(v3, "kCBMsgArgMicMode");
        if (v28)
        {
          if (qword_1009F7EF0 != -1) {
            dispatch_once(&qword_1009F7EF0, &stru_1009A0E20);
          }
          sub_1004556A0((uint64_t)off_1009F7EE8, v6, (uint64_t)[v28 unsignedIntValue]);
        }
        CFNumberRef v27 = sub_1002D49BC(v3, "kCBMsgArgDoubleTapAction");
        if (v27)
        {
          if (qword_1009F7EF0 != -1) {
            dispatch_once(&qword_1009F7EF0, &stru_1009A0E20);
          }
          sub_100455710((uint64_t)off_1009F7EE8, v6, (uint64_t)[v27 unsignedIntValue:v20]);
        }
        int v26 = sub_1002D49BC(v3, "kCBMsgArgDoubleTapActionEx");
        if (v26)
        {
          unsigned __int16 v9 = (unsigned __int16)[v26 unsignedIntValue];
          unsigned int v10 = HIBYTE(v9);
          unsigned int v11 = v9;
          if (qword_1009F7EF0 != -1) {
            dispatch_once(&qword_1009F7EF0, &stru_1009A0E20);
          }
          sub_10045577C((uint64_t)off_1009F7EE8, v6, v10, v11);
        }
        uint64_t v25 = sub_1002D49BC(v3, "kCBMsgArgListeningMode");
        if (v25)
        {
          if (qword_1009F80A0 != -1) {
            dispatch_once(&qword_1009F80A0, &stru_1009A0E40);
          }
          sub_1002859A4((uint64_t)off_1009F8098, v6, 13, (uint64_t)[v25 unsignedIntValue:v20], 2u);
        }
        uint64_t v24 = sub_1002D49BC(v3, "kCBMsgArgListeningConfigs");
        if (v24)
        {
          if (qword_1009F80A0 != -1) {
            dispatch_once(&qword_1009F80A0, &stru_1009A0E40);
          }
          sub_1002859A4((uint64_t)off_1009F8098, v6, 26, (uint64_t)[v24 unsignedIntValue:v20], 2u);
        }
        char v23 = sub_1002D49BC(v3, "kCBMsgArgAutoAnswerCalls");
        if (v23)
        {
          if (qword_1009F80A0 != -1) {
            dispatch_once(&qword_1009F80A0, &stru_1009A0E40);
          }
          uint64_t v12 = off_1009F8098;
          if (objc_msgSend(v23, "BOOLValue", v20)) {
            uint64_t v13 = 1;
          }
          else {
            uint64_t v13 = 2;
          }
          sub_1002859A4((uint64_t)v12, v6, 30, v13, 2u);
        }
        uint64_t v22 = sub_1002D49BC(v3, "kCBMsgArgCrownRotationDirection");
        if (v22)
        {
          if (qword_1009F80A0 != -1) {
            dispatch_once(&qword_1009F80A0, &stru_1009A0E40);
          }
          sub_1002859A4((uint64_t)off_1009F8098, v6, 28, (uint64_t)[v22 unsignedCharValue:v20], 2u);
        }
        uint64_t v14 = sub_1002D49BC(v3, "kCBMsgArgSingleClickMode");
        if (v14)
        {
          if (qword_1009F80A0 != -1) {
            dispatch_once(&qword_1009F80A0, &stru_1009A0E40);
          }
          sub_1002859A4((uint64_t)off_1009F8098, v6, 20, (uint64_t)[v14 unsignedIntValue], 2u);
        }
        unsigned int v15 = sub_1002D49BC(v3, "kCBMsgArgDoubleClickMode");
        if (v15)
        {
          if (qword_1009F80A0 != -1) {
            dispatch_once(&qword_1009F80A0, &stru_1009A0E40);
          }
          sub_1002859A4((uint64_t)off_1009F8098, v6, 21, (uint64_t)[v15 unsignedIntValue], 2u);
        }
        uint64_t v16 = sub_1002D49BC(v3, "kCBMsgArgClickHoldMode");
        if (v16)
        {
          if (qword_1009F80A0 != -1) {
            dispatch_once(&qword_1009F80A0, &stru_1009A0E40);
          }
          sub_1002859A4((uint64_t)off_1009F8098, v6, 22, (uint64_t)[v16 unsignedIntValue:v20], 2u);
        }
        __int16 v17 = sub_1002D49BC(v3, "kCBMsgArgDoubleClickInterval");
        if (v17)
        {
          if (qword_1009F80A0 != -1) {
            dispatch_once(&qword_1009F80A0, &stru_1009A0E40);
          }
          sub_1002859A4((uint64_t)off_1009F8098, v6, 23, (uint64_t)[v17 unsignedIntValue], 2u);
        }
        uint64_t v18 = sub_1002D49BC(v3, "kCBMsgArgClickHoldInterval");
        if (v18)
        {
          if (qword_1009F80A0 != -1) {
            dispatch_once(&qword_1009F80A0, &stru_1009A0E40);
          }
          sub_1002859A4((uint64_t)off_1009F8098, v6, 24, (uint64_t)[v18 unsignedIntValue], 2u);
        }
        int v19 = sub_1002D49BC(v3, "kCBMsgArgOneBudANCMode");
        if (v19)
        {
          if (qword_1009F80A0 != -1) {
            dispatch_once(&qword_1009F80A0, &stru_1009A0E40);
          }
          sub_1002859A4((uint64_t)off_1009F8098, v6, 27, (uint64_t)[v19 unsignedIntValue:v20], 2u);
        }
      }
      else if (os_log_type_enabled((os_log_t)qword_100A19EC8, OS_LOG_TYPE_ERROR))
      {
        sub_10074D254();
      }
    }
  }
}

void sub_10027C2EC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, void *a10, void *a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *a16, void *a17, void *a18, void *a19, void *__p,uint64_t a21,int a22,__int16 a23,char a24,char a25)
{
  _Unwind_Resume(a1);
}

void sub_10027C434()
{
}

void sub_10027C44C(uint64_t a1, xpc_object_t xdict)
{
  xpc_object_t v4 = xpc_dictionary_get_value(xdict, "kCBMsgArgs");
  if (v4)
  {
    uint64_t v5 = sub_1002D48BC(v4, "kCBMsgArgDeviceUUID");
    if (v5)
    {
      if (qword_1009F7EE0 != -1) {
        dispatch_once(&qword_1009F7EE0, &stru_1009A0D80);
      }
      uint64_t v6 = sub_100030DCC((uint64_t)off_1009F7ED8, v5, 0);
      if (!v6) {
        goto LABEL_31;
      }
      if (qword_1009F7F00 != -1) {
        dispatch_once(&qword_1009F7F00, &stru_1009A0DA0);
      }
      uint64_t v7 = sub_100030F10((uint64_t)off_1009F7EF8, v6, 0);
      if (v7)
      {
        xpc_object_t v8 = sub_10027E878(v5);
        char v9 = sub_100484FCC(v7);
        xpc_dictionary_set_BOOL(v8, "kCBMsgArgSmartRoutingSupported", v9);
        if (sub_100484FCC(v7))
        {
          unsigned int v10 = sub_1004874AC(v7);
          xpc_dictionary_set_int64(v8, "kCBMsgArgSmartRoutingEnabled", v10);
        }
        char v11 = sub_100487464(v7);
        xpc_dictionary_set_BOOL(v8, "kCBMsgArgInEarDetectionEnabled", v11);
        unsigned int v12 = sub_10048741C(v7);
        xpc_dictionary_set_int64(v8, "kCBMsgArgMicMode", v12);
        unsigned int v13 = sub_100487564(v7);
        xpc_dictionary_set_int64(v8, "kCBMsgArgListeningMode", v13);
        BOOL v14 = sub_10048787C(v7) == 1;
        xpc_dictionary_set_BOOL(v8, "kCBMsgArgAutoAnswerCalls", v14);
        unsigned int v15 = sub_100487834(v7);
        xpc_dictionary_set_int64(v8, "kCBMsgArgCrownRotationDirection", v15);
        int v36 = 0;
        sub_10047E0D4(v7, (uint64_t)&v36);
        int v16 = sub_10047E688((unsigned int *)v7, 1);
        if (v36 <= 0) {
          int64_t v17 = v16;
        }
        else {
          int64_t v17 = v36;
        }
        xpc_dictionary_set_int64(v8, "kCBMsgArgBatteryPercent", v17);
        int v18 = sub_10047E688((unsigned int *)v7, 2);
        xpc_dictionary_set_int64(v8, "kCBMsgArgBatteryPercentRight", v18);
        int v19 = sub_10047E688((unsigned int *)v7, 4);
        xpc_dictionary_set_int64(v8, "kCBMsgArgBatteryPercentLeft", v19);
        int v20 = sub_10047E688((unsigned int *)v7, 8);
        xpc_dictionary_set_int64(v8, "kCBMsgArgBatteryPercentCase", v20);
        int v21 = sub_10047E688((unsigned int *)v7, 1);
        xpc_dictionary_set_int64(v8, "kCBMsgArgBatteryPercentSingle", v21);
        int v22 = sub_10047E688((unsigned int *)v7, 16);
        xpc_dictionary_set_int64(v8, "kCBMsgArgBatteryPercentCombined", v22);
        if (sub_100478B2C(v7, 14))
        {
          xpc_dictionary_set_int64(v8, "kCBMsgArgDoubleTapCapability", 1);
          unsigned int v23 = sub_10047C698(v7);
          uint64_t v24 = "kCBMsgArgDoubleTapActionEx";
        }
        else
        {
          xpc_dictionary_set_int64(v8, "kCBMsgArgDoubleTapCapability", 0);
          unsigned int v23 = sub_10047C698(v7);
          uint64_t v24 = "kCBMsgArgDoubleTapAction";
        }
        xpc_dictionary_set_int64(v8, v24, v23);
        if (qword_1009F7EF0 != -1) {
          dispatch_once(&qword_1009F7EF0, &stru_1009A0E20);
        }
        if (off_1009F7EE8)
        {
          int64_t value = 0;
          sub_1004565B8((uint64_t)off_1009F7EE8, v7, (int *)&value + 1, (int *)&value);
          xpc_dictionary_set_int64(v8, "kCBMsgArgPrimaryInEarStatus", HIDWORD(value));
          xpc_dictionary_set_int64(v8, "kCBMsgArgSecondaryInEarStatus", value);
        }
        else if (os_log_type_enabled((os_log_t)qword_100A19EC8, OS_LOG_TYPE_ERROR))
        {
          sub_10074D288();
        }
        unsigned int v25 = sub_1004875AC(v7);
        xpc_dictionary_set_int64(v8, "kCBMsgArgListeningConfigs", v25);
        unsigned int v26 = sub_100487684(v7);
        xpc_dictionary_set_int64(v8, "kCBMsgArgSingleClickMode", v26);
        unsigned int v27 = sub_1004876CC(v7);
        xpc_dictionary_set_int64(v8, "kCBMsgArgDoubleClickMode", v27);
        unsigned int v28 = sub_100487714(v7);
        xpc_dictionary_set_int64(v8, "kCBMsgArgClickHoldMode", v28);
        unsigned int v29 = sub_10048775C(v7);
        xpc_dictionary_set_int64(v8, "kCBMsgArgDoubleClickInterval", v29);
        unsigned int v30 = sub_1004877A4(v7);
        xpc_dictionary_set_int64(v8, "kCBMsgArgClickHoldInterval", v30);
        unsigned int v31 = sub_1004877EC(v7);
        xpc_dictionary_set_int64(v8, "kCBMsgArgOneBudANCMode", v31);
        xpc_dictionary_set_BOOL(v8, "kCBMsgArgIsConnectedOverUSB", *(unsigned char *)(v7 + 1296));
        unsigned int v32 = sub_100489318(v7);
        xpc_dictionary_set_int64(v8, "kCBMsgArgColorID", v32);
        xpc_object_t reply = xpc_dictionary_create_reply(xdict);
        int v34 = reply;
        if (reply)
        {
          xpc_dictionary_set_value(reply, "kCBMsgArgState", v8);
          xpc_connection_send_message(*(xpc_connection_t *)(a1 + 16), v34);
          xpc_release(v34);
        }
        xpc_release(v8);
      }
      else
      {
LABEL_31:
        if (os_log_type_enabled((os_log_t)qword_100A19EC8, OS_LOG_TYPE_ERROR)) {
          sub_10074D254();
        }
      }
    }
  }
}

void sub_10027C95C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_10027C988(uint64_t a1, xpc_object_t xdict)
{
  uint64_t v24 = 0;
  uint64_t v25 = 0;
  xpc_object_t value = xpc_dictionary_get_value(xdict, "kCBMsgArgs");
  xpc_object_t v4 = sub_1002D48BC(value, "kCBMsgArgDeviceUUID");
  if (!sub_1000198BC(value, 1, v5, v6, v7, v8, v9, v10, (uint64_t)"kCBMsgArgPSM") && v4)
  {
    char v11 = qword_100A19EC8;
    if (os_log_type_enabled((os_log_t)qword_100A19EC8, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 134217984;
      *(void *)&uint8_t buf[4] = v25;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "Classic handleOpenL2CAPChannel psm: %lld", buf, 0xCu);
    }
    *(void *)long long buf = 0;
    if (!sub_1000198BC(v24, 0, v12, v13, v14, v15, v16, v17, (uint64_t)"kCBL2CAPChannelInMTU"))
    {
      uint64_t v18 = sub_100019878();
      v19[0] = _NSConcreteStackBlock;
      v19[1] = 3221225472;
      void v19[2] = sub_100280590;
      v19[3] = &unk_1009A0A70;
      uint64_t v21 = a1;
      uint64_t v22 = v25;
      uint64_t v23 = *(void *)buf;
      id v20 = v4;
      sub_1000197D8(v18, v19);
    }
  }
}

void sub_10027CB7C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,void *a21)
{
  _Unwind_Resume(a1);
}

void sub_10027CBA8(uint64_t a1, xpc_object_t xdict)
{
  uint64_t v18 = 0;
  xpc_object_t value = xpc_dictionary_get_value(xdict, "kCBMsgArgs");
  xpc_object_t v4 = sub_1002D48BC(value, "kCBMsgArgDeviceUUID");
  int v11 = sub_1000198BC(value, 1, v5, v6, v7, v8, v9, v10, (uint64_t)"kCBMsgArgPSM");
  uint64_t v12 = qword_100A19EC8;
  if (os_log_type_enabled((os_log_t)qword_100A19EC8, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 134217984;
    uint64_t v20 = v18;
    _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "Classic handleCloseL2CAPChannel psm: %lld", buf, 0xCu);
  }
  if (!v11 && v4)
  {
    uint64_t v13 = sub_100019878();
    v14[0] = _NSConcreteStackBlock;
    v14[1] = 3221225472;
    v14[2] = sub_100280688;
    v14[3] = &unk_100998570;
    uint64_t v16 = a1;
    uint64_t v17 = v18;
    id v15 = v4;
    sub_1000197D8(v13, v14);
  }
}

void sub_10027CD44(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17)
{
  _Unwind_Resume(a1);
}

void sub_10027CD6C(uint64_t a1, xpc_object_t xdict)
{
  xpc_object_t value = xpc_dictionary_get_value(xdict, "kCBMsgArgs");
  uint64_t v5 = sub_100019738(value, "kCBMsgArgName");
  uint64_t v6 = sub_1002D4930(value, "kCBMsgArgServiceUUID");
  uint64_t v7 = sub_1002D4930(value, "kCBMsgArgSDPRecordData");
  uint64_t v8 = qword_100A19EC8;
  if (os_log_type_enabled((os_log_t)qword_100A19EC8, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 138412802;
    *(void *)&uint8_t buf[4] = v6;
    *(_WORD *)&unsigned char buf[12] = 2112;
    *(void *)&unsigned char buf[14] = v5;
    *(_WORD *)&unsigned char buf[22] = 2112;
    v51[0] = v7;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "handleAddServiceToSDP: %@ with name: %@ record: %@ to SDP", buf, 0x20u);
  }
  if (!v7)
  {
    if (!v6) {
      goto LABEL_24;
    }
    uint64_t v42 = 0;
    int v43 = &v42;
    uint64_t v44 = 0x2020000000;
    char v45 = 0;
    v41[0] = 0;
    v41[1] = 0;
    sub_10003AED0((uint64_t)v41, a1 + 216);
    uint64_t v12 = *(void **)(a1 + 280);
    v38[0] = _NSConcreteStackBlock;
    v38[1] = 3221225472;
    v38[2] = sub_100282268;
    v38[3] = &unk_1009A0BA8;
    id v13 = v6;
    id v39 = v13;
    id v40 = &v42;
    [v12 enumerateKeysAndObjectsUsingBlock:v38];
    uint64_t v14 = qword_100A19EC8;
    if (*((unsigned char *)v43 + 24))
    {
      if (os_log_type_enabled((os_log_t)qword_100A19EC8, OS_LOG_TYPE_ERROR)) {
        sub_10074D358();
      }
      int64_t v15 = 15;
    }
    else
    {
      if (os_log_type_enabled((os_log_t)qword_100A19EC8, OS_LOG_TYPE_INFO))
      {
        sub_10003AE4C(*(void *)(a1 + 128), (uint64_t)buf);
        uint64_t v16 = buf[23] >= 0 ? buf : *(unsigned char **)buf;
        *(_DWORD *)long long v46 = 138412546;
        *(void *)&v46[4] = v13;
        __int16 v47 = 2082;
        uint64_t v48 = v16;
        _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_INFO, "Adding service %@ for session \"%{public}s\"", v46, 0x16u);
        if ((buf[23] & 0x80000000) != 0) {
          operator delete(*(void **)buf);
        }
      }
      unsigned __int16 v37 = 0;
      char v36 = 0;
      sub_10001B8E0(&v36);
      int v17 = sub_1001E6318(&v37);
      sub_10001B910(&v36);
      uint64_t v18 = qword_100A19EC8;
      if (v17)
      {
        if (os_log_type_enabled((os_log_t)qword_100A19EC8, OS_LOG_TYPE_ERROR)) {
          sub_10074D2F0();
        }
        int64_t v15 = 4;
      }
      else
      {
        BOOL v21 = os_log_type_enabled((os_log_t)qword_100A19EC8, OS_LOG_TYPE_DEFAULT);
        if (v21)
        {
          *(_DWORD *)long long buf = 67109378;
          *(_DWORD *)&uint8_t buf[4] = v37;
          *(_WORD *)&uint8_t buf[8] = 2112;
          *(void *)&buf[10] = v13;
          _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "psm: 0x%x assigned to service: %@", buf, 0x12u);
        }
        uint64_t v23 = sub_1002813D0(v21, v22, v13, v37);
        uint64_t v24 = qword_100A19EC8;
        if (v23)
        {
          if (os_log_type_enabled((os_log_t)qword_100A19EC8, OS_LOG_TYPE_DEFAULT))
          {
            int v25 = v37;
            sub_10003AE4C(*(void *)(a1 + 128), (uint64_t)v46);
            unsigned int v26 = v46;
            if (v49 < 0) {
              unsigned int v26 = *(unsigned char **)v46;
            }
            *(_DWORD *)long long buf = 138413058;
            *(void *)&uint8_t buf[4] = v13;
            *(_WORD *)&unsigned char buf[12] = 1024;
            *(_DWORD *)&unsigned char buf[14] = v25;
            *(_WORD *)&buf[18] = 1024;
            *(_DWORD *)&buf[20] = v23;
            LOWORD(v51[0]) = 2082;
            *(void *)((char *)v51 + 2) = v26;
            _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "Successfully added service uuid %@ with psm: 0x%x, srh: 0x%X for session \"%{public}s\"", buf, 0x22u);
            if (v49 < 0) {
              operator delete(*(void **)v46);
            }
          }
          uint64_t v33 = +[NSNumber numberWithUnsignedShort:v37];
          unsigned int v27 = +[NSMutableDictionary dictionaryWithObject:forKey:](NSMutableDictionary, "dictionaryWithObject:forKey:", v13);
          unsigned int v28 = *(void **)(a1 + 280);
          unsigned int v29 = +[NSNumber numberWithUnsignedInt:v23];
          [v28 setObject:v27 forKeyedSubscript:v29];

          unsigned int v30 = qword_100A19EC8;
          if (os_log_type_enabled((os_log_t)qword_100A19EC8, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v31 = *(void *)(a1 + 280);
            *(_DWORD *)long long buf = 138412290;
            *(void *)&uint8_t buf[4] = v31;
            _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_DEFAULT, "currently published services in sdp: %@", buf, 0xCu);
          }
          uint64_t v32 = sub_100019878();
          v34[0] = _NSConcreteStackBlock;
          v34[1] = 3221225472;
          v34[2] = sub_100282380;
          v34[3] = &unk_1009A0B58;
          v34[4] = a1;
          unsigned __int16 v35 = v37;
          sub_1000197D8(v32, v34);
          sub_10001B8AC(&v36);

          goto LABEL_23;
        }
        if (os_log_type_enabled((os_log_t)qword_100A19EC8, OS_LOG_TYPE_ERROR)) {
          sub_10074D2BC();
        }
        int64_t v15 = 14;
      }
      sub_10001B8AC(&v36);
    }
    xpc_object_t v19 = xpc_dictionary_create(0, 0, 0);
    xpc_dictionary_set_int64(v19, "kCBMsgArgResult", v15);
    id v20 = v13;
    xpc_dictionary_set_data(v19, "kCBMsgArgServiceUUID", [v20 bytes], (size_t)[v20 length]);
    sub_1000173FC(a1, 46, v19, 1);

LABEL_23:
    sub_10003AFB4((uint64_t)v41);
    _Block_object_dispose(&v42, 8);
    goto LABEL_24;
  }
  unsigned int v9 = sub_100281558(a1, v7);
  xpc_object_t reply = xpc_dictionary_create_reply(xdict);
  int v11 = reply;
  if (reply)
  {
    xpc_dictionary_set_uint64(reply, "kCBMsgArgServiceHandle", v9);
    xpc_connection_send_message(*(xpc_connection_t *)(a1 + 16), v11);
    xpc_release(v11);
  }
LABEL_24:
}

void sub_10027D35C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, int a16, char a17, char a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,id a23,uint64_t a24,char a25,uint64_t a26,char a27)
{
  sub_10001B8AC(&a18);

  sub_10003AFB4((uint64_t)&a25);
  _Block_object_dispose(&a27, 8);

  _Unwind_Resume(a1);
}

void sub_10027D408(uint64_t a1, xpc_object_t xdict)
{
  xpc_object_t value = xpc_dictionary_get_value(xdict, "kCBMsgArgs");
  xpc_object_t v4 = sub_1002D4930(value, "kCBMsgArgServiceUUID");
  int64_t int64 = xpc_dictionary_get_int64(value, "kCBMsgArgServiceHandle");
  v30[0] = 0;
  v30[1] = 0;
  sub_10003AED0((uint64_t)v30, a1 + 216);
  if (v4)
  {
    uint64_t v6 = qword_100A19EC8;
    if (os_log_type_enabled((os_log_t)qword_100A19EC8, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(buf) = 138412290;
      *(void *)((char *)&buf + 4) = v4;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "remove service: %@ from SDP", (uint8_t *)&buf, 0xCu);
    }
    *(void *)&long long buf = 0;
    *((void *)&buf + 1) = &buf;
    uint64_t v38 = 0x2020000000;
    int v39 = 0;
    v27[0] = 0;
    v27[1] = v27;
    uint64_t v28 = 0x2020000000;
    __int16 v29 = 0;
    uint64_t v7 = *(void **)(a1 + 280);
    v23[0] = _NSConcreteStackBlock;
    v23[1] = 3221225472;
    v23[2] = sub_100282408;
    v23[3] = &unk_1009A0BF8;
    id v8 = v4;
    id v24 = v8;
    p_long long buf = &buf;
    unsigned int v26 = v27;
    [v7 enumerateKeysAndObjectsUsingBlock:v23];
    if (*(_DWORD *)(*((void *)&buf + 1) + 24))
    {
      char v22 = 0;
      sub_10001B8E0(&v22);
      int v9 = sub_10024E448(*(_DWORD *)(*((void *)&buf + 1) + 24));
      sub_10001B910(&v22);
      uint64_t v10 = qword_100A19EC8;
      if (os_log_type_enabled((os_log_t)qword_100A19EC8, OS_LOG_TYPE_DEFAULT))
      {
        sub_10003AE4C(*(void *)(a1 + 128), (uint64_t)__p);
        if (v21 >= 0) {
          int v11 = __p;
        }
        else {
          int v11 = (void **)__p[0];
        }
        *(_DWORD *)uint64_t v31 = 138412802;
        id v32 = v8;
        __int16 v33 = 1024;
        int v34 = v9;
        __int16 v35 = 2082;
        char v36 = v11;
        _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "Removed service uuid %@ with status 0x%x  for session \"%{public}s\"", v31, 0x1Cu);
        if (v21 < 0) {
          operator delete(__p[0]);
        }
      }
      uint64_t v12 = sub_100019878();
      v19[0] = _NSConcreteStackBlock;
      v19[1] = 3221225472;
      void v19[2] = sub_1002825C4;
      v19[3] = &unk_100999720;
      void v19[4] = v27;
      _WORD v19[5] = a1;
      sub_1000197D8(v12, v19);
      sub_10001B8AC(&v22);
    }

    _Block_object_dispose(v27, 8);
    _Block_object_dispose(&buf, 8);
  }
  else if (int64)
  {
    id v13 = *(void **)(a1 + 280);
    uint64_t v14 = +[NSNumber numberWithUnsignedInt:int64];
    int64_t v15 = [v13 objectForKeyedSubscript:v14];
    LOBYTE(v13) = v15 == 0;

    if (v13)
    {
      int v16 = 414;
    }
    else
    {
      LOBYTE(buf) = 0;
      sub_10001B8E0(&buf);
      int v16 = sub_10024E448(int64);
      sub_10001B910(&buf);
      sub_10001B8AC(&buf);
    }
    int v17 = qword_100A19EC8;
    if (os_log_type_enabled((os_log_t)qword_100A19EC8, OS_LOG_TYPE_DEFAULT))
    {
      sub_10003AE4C(*(void *)(a1 + 128), (uint64_t)v27);
      uint64_t v18 = v28 >= 0 ? v27 : (void **)v27[0];
      LODWORD(buf) = 67109634;
      DWORD1(buf) = int64;
      WORD4(buf) = 1024;
      *(_DWORD *)((char *)&buf + 10) = v16;
      HIWORD(buf) = 2082;
      uint64_t v38 = (uint64_t)v18;
      _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "Removed service handle 0x%X with status 0x%X  for session \"%{public}s\"", (uint8_t *)&buf, 0x18u);
      if (SHIBYTE(v28) < 0) {
        operator delete(v27[0]);
      }
    }
  }
  sub_10003AFB4((uint64_t)v30);
}

void sub_10027D80C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,char a31)
{
  sub_10003AFB4((uint64_t)&a31);

  _Unwind_Resume(a1);
}

uint64_t sub_10027D89C(uint64_t a1)
{
  v5[0] = 0;
  v5[1] = 0;
  sub_10003AED0((uint64_t)v5, a1 + 216);
  uint64_t v2 = *(void **)(a1 + 280);
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 3221225472;
  _DWORD v4[2] = sub_100282638;
  v4[3] = &unk_1009A0C40;
  v4[4] = a1;
  [v2 enumerateKeysAndObjectsUsingBlock:v4];
  [*(id *)(a1 + 280) removeAllObjects];
  return sub_10003AFB4((uint64_t)v5);
}

void sub_10027D938(_Unwind_Exception *a1)
{
  sub_10003AFB4(v1 - 32);
  _Unwind_Resume(a1);
}

void sub_10027D94C(int a1, xpc_object_t xdict)
{
  xpc_object_t value = xpc_dictionary_get_value(xdict, "kCBMsgArgs");
  uint64_t v3 = sub_1002D48BC(value, "kCBMsgArgDeviceUUID");
  int v10 = sub_1000198BC(value, 1, v4, v5, v6, v7, v8, v9, (uint64_t)"kCBMsgArgRFCOMMChannelID");
  int v11 = qword_100A19EC8;
  if (os_log_type_enabled((os_log_t)qword_100A19EC8, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)long long buf = 67109634;
    *(_DWORD *)id v13 = v10;
    *(_WORD *)&v13[4] = 2112;
    *(void *)&v13[6] = v3;
    __int16 v14 = 2048;
    uint64_t v15 = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "handleOpenRFCOMMChannel failed with result 0x%x, identifier: %@, rfcommChannelID: %lld", buf, 0x1Cu);
  }
}

void sub_10027DB04(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_10027DB1C(int a1, xpc_object_t xdict)
{
  xpc_object_t value = xpc_dictionary_get_value(xdict, "kCBMsgArgs");
  uint64_t v3 = sub_1002D48BC(value, "kCBMsgArgDeviceUUID");
  sub_1000198BC(value, 1, v4, v5, v6, v7, v8, v9, (uint64_t)"kCBMsgArgRFCOMMChannelID");
  int v10 = qword_100A19EC8;
  if (os_log_type_enabled((os_log_t)qword_100A19EC8, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 134217984;
    uint64_t v12 = 0;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "handleCloseRFCOMMChannel rfcommChannelID: %lld", buf, 0xCu);
  }
}

void sub_10027DC54(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_10027DC6C(int a1, xpc_object_t xdict)
{
  xpc_object_t value = xpc_dictionary_get_value(xdict, "kCBMsgArgs");
  uint64_t v3 = sub_1002D48BC(value, "kCBMsgArgDeviceUUID");
  int v10 = sub_1000198BC(value, 1, v4, v5, v6, v7, v8, v9, (uint64_t)"kCBMsgArgRFCOMMChannelID");
  int v11 = qword_100A19EC8;
  if (os_log_type_enabled((os_log_t)qword_100A19EC8, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)long long buf = 67109634;
    *(_DWORD *)id v13 = v10;
    *(_WORD *)&v13[4] = 2112;
    *(void *)&v13[6] = v3;
    __int16 v14 = 2048;
    uint64_t v15 = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "handleRFCOMMPortConfiguration failed with result 0x%x, identifier: %@, rfcommChannelID: %lld", buf, 0x1Cu);
  }
}

void sub_10027DE5C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_10027DE74(uint64_t a1, xpc_object_t xdict)
{
  xpc_object_t value = xpc_dictionary_get_value(xdict, "kCBMsgArgs");
  sub_1002D48BC(value, "kCBMsgArgDeviceUUID");
  id v9 = (id)objc_claimAutoreleasedReturnValue();
  if (v9)
  {
    if (qword_1009F7EE0 != -1) {
      dispatch_once(&qword_1009F7EE0, &stru_1009A0D80);
    }
    uint64_t v5 = sub_100030DCC((uint64_t)off_1009F7ED8, v9, 0);
    if (qword_1009F7F00 != -1) {
      dispatch_once(&qword_1009F7F00, &stru_1009A0DA0);
    }
    uint64_t v6 = sub_100030F10((uint64_t)off_1009F7EF8, v5, 0);
    if (v6)
    {
      if (qword_1009F8090 != -1) {
        dispatch_once(&qword_1009F8090, &stru_1009A0DC0);
      }
      LODWORD(v6) = sub_1004D41B4((uint64_t)off_1009F8088, v6);
    }
  }
  else
  {
    LODWORD(v6) = 0;
  }
  xpc_object_t reply = xpc_dictionary_create_reply(xdict);
  uint64_t v8 = reply;
  if (reply)
  {
    xpc_dictionary_set_int64(reply, "kCBMsgArgConnectedServices", v6);
    xpc_connection_send_message(*(xpc_connection_t *)(a1 + 16), v8);
    xpc_release(v8);
  }
}

void sub_10027DFE4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_10027E000(uint64_t a1, xpc_object_t original)
{
  xpc_object_t reply = xpc_dictionary_create_reply(original);
  if (reply)
  {
    uint64_t v4 = reply;
    bytes = 0;
    size_t length = 0;
    uint64_t v5 = malloc_type_malloc(0x3E80uLL, 0x1A12BF70uLL);
    if (v5)
    {
      uint64_t v6 = v5;
      bytes = v5;
      size_t length = 0x200003E803E80;
      char v9 = 0;
      sub_10001B8E0(&v9);
      if (!sub_100250314((uint64_t)&bytes))
      {
        uint64_t v7 = qword_100A19EC8;
        if (os_log_type_enabled((os_log_t)qword_100A19EC8, OS_LOG_TYPE_DEFAULT))
        {
          int v8 = *(unsigned __int16 *)bytes;
          *(_DWORD *)long long buf = 67109120;
          int v13 = v8;
          _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "Sending sdp record state (%d records)", buf, 8u);
        }
        xpc_dictionary_set_data(v4, "kCBMsgArgSDPRecordData", bytes, WORD2(length));
      }
      sub_10001B910(&v9);
      free(v6);
      sub_10001B8AC(&v9);
    }
    xpc_connection_send_message(*(xpc_connection_t *)(a1 + 16), v4);
    xpc_release(v4);
  }
}

void sub_10027E14C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, int a10, __int16 a11, char a12, char a13)
{
}

void sub_10027E168()
{
  CFDictionaryRef v0 = qword_100A19EC8;
  if (os_log_type_enabled((os_log_t)qword_100A19EC8, OS_LOG_TYPE_ERROR)) {
    sub_10074D38C(v0, v1, v2, v3, v4, v5, v6, v7);
  }
}

uint64_t sub_10027E1AC(uint64_t a1, unsigned int a2)
{
  return (a2 < 0x3D) & (0x1010006008000080uLL >> a2);
}

BOOL sub_10027E1D0(uint64_t a1, __int16 a2)
{
  return (a2 & 0xFFFE) == 8;
}

void sub_10027E1E0(uint64_t a1)
{
  uint64_t v2 = *(unsigned __int8 *)(a1 + 84);
  uint64_t v3 = *(void *)(a1 + 64);
  uint64_t v4 = *(void *)(a1 + 72);
  uint64_t v5 = *(unsigned __int8 *)(a1 + 85);
  if (qword_1009F8788 != -1) {
    dispatch_once(&qword_1009F8788, &stru_1009A0CE0);
  }
  uint64_t v6 = off_1009F8780;
  unsigned int v7 = *(_DWORD *)(v3 + 40);
  int v8 = *(void **)(a1 + 32);
  if (*(char *)(v3 + 79) < 0)
  {
    sub_10003B098(__p, *(void **)(v3 + 56), *(void *)(v3 + 64));
  }
  else
  {
    *(_OWORD *)std::string __p = *(_OWORD *)(v3 + 56);
    uint64_t v10 = *(void *)(v3 + 72);
  }
  *(void *)(v3 + 128) = sub_1002F30B8((uint64_t)v6, v3 + 144, v7, v8, (uint64_t)__p, *(_DWORD *)(a1 + 80), *(void **)(a1 + 40), (_DWORD *)(*(void *)(*(void *)(a1 + 48) + 8) + 24), (unsigned char *)(*(void *)(*(void *)(a1 + 56) + 8) + 24), (v4 != 0) | (unint64_t)(v2 << 8) | (v5 << 32));
  if (SHIBYTE(v10) < 0) {
    operator delete(__p[0]);
  }
}

void sub_10027E2FC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10027E318(uint64_t a1)
{
  if (*(char *)(a1 + 95) < 0) {
    operator delete(*(void **)(a1 + 72));
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  std::ios::~ios();
  return a1;
}

void sub_10027E41C(uint64_t a1)
{
  sub_10027E4B0(a1);
  sub_10027D89C(a1);
  if (*(void *)(a1 + 128))
  {
    uint64_t v2 = sub_100019878();
    v3[0] = _NSConcreteStackBlock;
    v3[1] = 3221225472;
    _DWORD v3[2] = sub_10027E5A0;
    v3[3] = &unk_100997528;
    v3[4] = a1;
    sub_1000197D8(v2, v3);
    *(void *)(a1 + 128) = 0;
  }
}

void sub_10027E4B0(uint64_t a1)
{
  if (*(void *)(a1 + 176))
  {
    if (qword_1009F8398 != -1) {
      dispatch_once(&qword_1009F8398, &stru_1009A0DE0);
    }
    uint64_t v2 = off_1009F8390;
    uint64_t v3 = *(std::__shared_weak_count **)(a1 + 184);
    uint64_t v6 = *(void *)(a1 + 176);
    unsigned int v7 = v3;
    if (v3) {
      atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    unint64_t v4 = sub_100504ECC((uint64_t)v2, &v6);
    if (v7) {
      sub_10008A294(v7);
    }
    if (qword_1009F8398 != -1) {
      dispatch_once(&qword_1009F8398, &stru_1009A0DE0);
    }
    sub_100504FC0((uint64_t)off_1009F8390, v4);
    uint64_t v5 = *(std::__shared_weak_count **)(a1 + 184);
    *(void *)(a1 + 176) = 0;
    *(void *)(a1 + ++*(_DWORD *)(result + 184) = 0;
    if (v5) {
      sub_10008A294(v5);
    }
  }
}

void sub_10027E588(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10008A294(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10027E5A0(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  if (qword_1009FB078 != -1) {
    dispatch_once(&qword_1009FB078, &stru_1009A0D00);
  }
  sub_10005332C(qword_1009FB070, *(void *)(v1 + 128));
  if (qword_1009F8788 != -1) {
    dispatch_once(&qword_1009F8788, &stru_1009A0CE0);
  }
  uint64_t v2 = off_1009F8780;
  unint64_t v3 = *(void *)(v1 + 128);

  return sub_10002CE08((uint64_t)v2, v3, 0);
}

void sub_10027E640(uint64_t a1, uint64_t a2, unsigned int a3)
{
  if (a3 - 2 >= 3)
  {
    if (a3) {
      int v4 = 0;
    }
    else {
      int v4 = 4;
    }
    if (a3 == 1) {
      unsigned int v3 = 5;
    }
    else {
      unsigned int v3 = v4;
    }
  }
  else
  {
    unsigned int v3 = *(_DWORD *)(a1 + 136);
  }
  sub_1004F11F0(a1, v3, a3);
}

void sub_10027E670(uint64_t a1, uint64_t a2, unsigned int a3)
{
}

void sub_10027E678(uint64_t a1, uint64_t a2, int a3)
{
}

void sub_10027E680(uint64_t a1, uint64_t a2, int a3)
{
}

void sub_10027E68C(uint64_t a1)
{
  unsigned int v7 = 0;
  int v8 = 0;
  uint64_t v9 = 0;
  if (qword_1009F8768 != -1) {
    dispatch_once(&qword_1009F8768, &stru_1009A0D60);
  }
  sub_10060C508((uint64_t)off_1009F8760, &v7);
  uint64_t v2 = v7;
  unsigned int v3 = v8;
  if (v7 != v8)
  {
    do
    {
      int v4 = (unsigned __int8 *)*v2;
      if (sub_1004764A0(*v2) || !*(unsigned char *)(a1 + 48))
      {
        v10[0] = 0;
        v10[1] = 0;
        if (qword_1009F7EE0 != -1) {
          dispatch_once(&qword_1009F7EE0, &stru_1009A0D80);
        }
        sub_100014B58((uint64_t)off_1009F7ED8, ((unint64_t)v4[128] << 40) | ((unint64_t)v4[129] << 32) | ((unint64_t)v4[130] << 24) | ((unint64_t)v4[131] << 16) | ((unint64_t)v4[132] << 8) | v4[133], 1u, 0, 0, 0, (unsigned __int8 *)v10);
        uint64_t v5 = sub_100031234((const unsigned __int8 *)v10);
        xpc_object_t v6 = sub_10027E878(v5);

        xpc_array_append_value(*(xpc_object_t *)(a1 + 40), v6);
        xpc_release(v6);
      }
      ++v2;
    }
    while (v2 != v3);
    uint64_t v2 = v7;
  }
  if (v2)
  {
    int v8 = v2;
    operator delete(v2);
  }
}

void sub_10027E83C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

xpc_object_t sub_10027E878(void *a1)
{
  id v1 = a1;
  xpc_object_t v2 = xpc_dictionary_create(0, 0, 0);
  id v3 = v1;
  int v4 = v3;
  if (v3)
  {
    *(void *)uuid = 0;
    uint64_t v29 = 0;
    [v3 getUUIDBytes:uuid];
    xpc_dictionary_set_uuid(v2, "kCBMsgArgDeviceUUID", uuid);
  }

  if (qword_1009F7EE0 != -1) {
    dispatch_once(&qword_1009F7EE0, &stru_1009A0D80);
  }
  uint64_t v5 = sub_100030DCC((uint64_t)off_1009F7ED8, v4, 0);
  if (qword_1009F7F00 != -1) {
    dispatch_once(&qword_1009F7F00, &stru_1009A0DA0);
  }
  uint64_t v6 = sub_100030F10((uint64_t)off_1009F7EF8, v5, 0);
  uint64_t v7 = v6;
  if (v6)
  {
    *(void *)uuid = 0;
    uint64_t v29 = 0;
    uint64_t v30 = 0;
    sub_100475EE0(v6, (uint64_t)uuid);
    if (SHIBYTE(v30) < 0)
    {
      if (!v29) {
        goto LABEL_14;
      }
      int v8 = *(unsigned __int8 **)uuid;
    }
    else
    {
      if (!HIBYTE(v30)) {
        goto LABEL_14;
      }
      int v8 = uuid;
    }
    xpc_dictionary_set_string(v2, "kCBMsgArgName", (const char *)v8);
LABEL_14:
    unsigned int v9 = sub_100476054(v7);
    xpc_dictionary_set_int64(v2, "kCBMsgArgDeviceType", v9);
    unsigned int value_4 = 0;
    if (sub_100476250(v7, &value_4)) {
      xpc_dictionary_set_int64(v2, "kCBMsgArgClassOfDevice", value_4);
    }
    unsigned int v10 = sub_100040630((unsigned __int8 *)v7);
    xpc_dictionary_set_int64(v2, "kCBMsgArgPairingState", v10);
    int v11 = sub_10047637C(v7);
    xpc_dictionary_set_int64(v2, "kCBMsgArgRssi", v11);
    xpc_dictionary_set_int64(v2, "kCBMsgArgInternalState", 2 * *(unsigned __int8 *)(v7 + 1332));
    unsigned int value = 0;
    memset(v25, 0, sizeof(v25));
    if (sub_10047B7A8(v7, &value, &v25[2], &v25[1], v25))
    {
      xpc_dictionary_set_int64(v2, "kCBMsgArgVIDSource", value);
      xpc_dictionary_set_int64(v2, "kCBMsgArgVID", v25[2]);
      xpc_dictionary_set_int64(v2, "kCBMsgArgPID", v25[1]);
      xpc_dictionary_set_int64(v2, "kCBMsgArgVersion", v25[0]);
    }
    *(_OWORD *)&__dst[1] = 0uLL;
    uint64_t v24 = 0;
    if (*(char *)(v7 + 415) < 0)
    {
      sub_10003B098(&__dst[1], *(void **)(v7 + 392), *(void *)(v7 + 400));
    }
    else
    {
      *(_OWORD *)&__dst[1] = *(_OWORD *)(v7 + 392);
      uint64_t v24 = *(void *)(v7 + 408);
    }
    if (SHIBYTE(v24) < 0)
    {
      if (!*(void *)&__dst[3]) {
        goto LABEL_27;
      }
      uint64_t v12 = *(const char **)&__dst[1];
    }
    else
    {
      if (!HIBYTE(v24)) {
        goto LABEL_27;
      }
      uint64_t v12 = (const char *)&__dst[1];
    }
    xpc_dictionary_set_string(v2, "kCBMsgArgModelIdentifier", v12);
LABEL_27:
    __dst[0] = 0;
    if (sub_10047D434(v7, __dst)) {
      xpc_dictionary_set_int64(v2, "kCBMsgArgAppleFeatureBitMask", __dst[0]);
    }
    uint64_t v22 = 0;
    if (sub_10047D4F0(v7, &v22)) {
      xpc_dictionary_set_int64(v2, "kCBMsgArgExtendedAppleFeatureBitMask", HIDWORD(v22) | ((unint64_t)v22 << 32));
    }
    string = 0;
    uint64_t v20 = 0;
    uint64_t v21 = 0;
    sub_1004A82EC((unsigned __int8 *)(v7 + 128), &string);
    if (SHIBYTE(v21) < 0)
    {
      if (v20)
      {
        p_string = string;
        goto LABEL_36;
      }
    }
    else if (HIBYTE(v21))
    {
      p_string = (const char *)&string;
LABEL_36:
      xpc_dictionary_set_string(v2, "kCBMsgArgAddressString", p_string);
    }
    bytes[0] = BYTE5(v5);
    bytes[1] = BYTE4(v5);
    bytes[2] = BYTE3(v5);
    bytes[3] = BYTE2(v5);
    bytes[4] = BYTE1(v5);
    bytes[5] = v5;
    xpc_dictionary_set_data(v2, "kCBAdvDataDeviceAddress", bytes, 6uLL);
    __int16 v14 = sub_10048B5E0(v7);
    if ([v14 count])
    {
      xpc_object_t v15 = sub_100056D28(v14);
      xpc_dictionary_set_value(v2, "kCBMsgArgServices", v15);
      xpc_release(v15);
    }
    xpc_dictionary_set_BOOL(v2, "kCBMsgArgIsConnectedOverUSB", *(unsigned char *)(v7 + 1296));
    if (sub_100489318(v7))
    {
      unsigned int v16 = sub_100489318(v7);
      xpc_dictionary_set_int64(v2, "kCBMsgArgColorID", v16);
    }

    if (SHIBYTE(v21) < 0) {
      operator delete(string);
    }
    if (SHIBYTE(v24) < 0) {
      operator delete(*(void **)&__dst[1]);
    }
    if (SHIBYTE(v30) < 0) {
      operator delete(*(void **)uuid);
    }
  }

  return v2;
}

void sub_10027ECF4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  if (*(char *)(v24 - 57) < 0) {
    operator delete(*(void **)(v24 - 80));
  }

  _Unwind_Resume(a1);
}

void sub_10027EDA4(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 48);
  if (qword_1009F8788 != -1) {
    dispatch_once(&qword_1009F8788, &stru_1009A0CE0);
  }
  sub_1002F6B48((uint64_t)off_1009F8780, *(void *)(v2 + 128), *(void **)(a1 + 32), *(void **)(a1 + 40));
  if (qword_1009F8788 != -1) {
    dispatch_once(&qword_1009F8788, &stru_1009A0CE0);
  }
  uint64_t v3 = sub_1000066B0((uint64_t)off_1009F8780, *(void *)(v2 + 128), 2u);
  int v4 = qword_100A19EC8;
  if (os_log_type_enabled((os_log_t)qword_100A19EC8, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = *(void *)(v3 + 88);
    int v6 = *(unsigned __int8 *)(a1 + 56);
    int v7 = 136315650;
    int v8 = "handleConnectPeerMsg_block_invoke";
    __int16 v9 = 2114;
    uint64_t v10 = v5;
    __int16 v11 = 1024;
    int v12 = v6;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "%s: Setting didRequestPairing for Application %{public}@ to %d", (uint8_t *)&v7, 0x1Cu);
  }
  *(unsigned char *)(v3 + 208) = *(unsigned char *)(a1 + 56);
}

void sub_10027EEF8(void *a1)
{
  uint64_t v2 = a1[5];
  if (qword_1009F8788 != -1) {
    dispatch_once(&qword_1009F8788, &stru_1009A0CE0);
  }
  uint64_t v3 = off_1009F8780;
  unint64_t v4 = *(void *)(v2 + 128);
  uint64_t v5 = (void *)a1[4];
  BOOL v6 = a1[6] != 0;

  sub_1002F8C80((uint64_t)v3, v4, v5, v6, 1, 0);
}

void sub_10027EF78(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  switch(a2)
  {
    case 0:
      uint64_t v5 = qword_100A19EC8;
      if (os_log_type_enabled((os_log_t)qword_100A19EC8, OS_LOG_TYPE_DEFAULT))
      {
        __int16 v13 = 0;
        BOOL v6 = "Bluetooth discoveryStatus: scan started";
        int v7 = (uint8_t *)&v13;
        goto LABEL_13;
      }
      break;
    case 1:
      __int16 v9 = qword_100A19EC8;
      if (os_log_type_enabled((os_log_t)qword_100A19EC8, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "Bluetooth discoveryStatus: scan stopped", buf, 2u);
      }
      sub_10027F110(a5);
      break;
    case 2:
      uint64_t v5 = qword_100A19EC8;
      if (os_log_type_enabled((os_log_t)qword_100A19EC8, OS_LOG_TYPE_DEFAULT))
      {
        __int16 v11 = 0;
        BOOL v6 = "Bluetooth discoveryStatus: query started";
        int v7 = (uint8_t *)&v11;
        goto LABEL_13;
      }
      break;
    case 3:
      uint64_t v5 = qword_100A19EC8;
      if (os_log_type_enabled((os_log_t)qword_100A19EC8, OS_LOG_TYPE_DEFAULT))
      {
        __int16 v10 = 0;
        BOOL v6 = "Bluetooth discoveryStatus: query stopped";
        int v7 = (uint8_t *)&v10;
LABEL_13:
        _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, v6, v7, 2u);
      }
      break;
    default:
      if (os_log_type_enabled((os_log_t)qword_100A19EC8, OS_LOG_TYPE_ERROR)) {
        sub_10074D404();
      }
      break;
  }
}

void sub_10027F110(uint64_t a1)
{
  uint64_t v2 = qword_100A19EC8;
  if (os_log_type_enabled((os_log_t)qword_100A19EC8, OS_LOG_TYPE_DEFAULT))
  {
    int v3 = *(unsigned __int8 *)(a1 + 192);
    int v4 = *(unsigned __int8 *)(a1 + 193);
    v5[0] = 67109376;
    v5[1] = v3;
    __int16 v6 = 1024;
    int v7 = v4;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "restartInquiry: continuous? %d, already scanning? %d", (uint8_t *)v5, 0xEu);
  }
  if (*(unsigned char *)(a1 + 193))
  {
    if (*(unsigned char *)(a1 + 192))
    {
      *(unsigned char *)(a1 + 193) = 0;
      sub_10027F4A0(a1, 1);
    }
  }
}

void sub_10027F1F4(uint64_t a1, int a2, unint64_t a3, uint64_t a4, uint64_t a5)
{
  if (qword_1009F7F00 != -1) {
    dispatch_once(&qword_1009F7F00, &stru_1009A0DA0);
  }
  int v8 = (unsigned __int8 *)sub_1004A930C((uint64_t)off_1009F7EF8, a3);
  __p[0] = 0;
  __p[1] = 0;
  uint64_t v16 = 0;
  sub_100475F84((uint64_t)v8, (uint64_t)__p);
  v19[0] = 0;
  v19[1] = 0;
  if (qword_1009F7EE0 != -1) {
    dispatch_once(&qword_1009F7EE0, &stru_1009A0D80);
  }
  sub_100014B58((uint64_t)off_1009F7ED8, ((unint64_t)v8[128] << 40) | ((unint64_t)v8[129] << 32) | ((unint64_t)v8[130] << 24) | ((unint64_t)v8[131] << 16) | ((unint64_t)v8[132] << 8) | v8[133], 1u, 0, 0, 0, (unsigned __int8 *)v19);
  __int16 v9 = sub_100031234((const unsigned __int8 *)v19);
  xpc_object_t v10 = sub_10027E878(v9);

  if (!a2)
  {
    sub_1000173FC(a5, 44, v10, 1);
    __int16 v11 = qword_100A19EC8;
    if (!os_log_type_enabled((os_log_t)qword_100A19EC8, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_19;
    }
    __int16 v14 = __p;
    if (v16 < 0) {
      __int16 v14 = (void **)__p[0];
    }
    *(_DWORD *)long long buf = 136315138;
    uint64_t v18 = v14;
    __int16 v13 = "Bluetooth discoveryEvent: device found: %s";
    goto LABEL_15;
  }
  if (a2 == 2)
  {
    sub_1000173FC(a5, 45, v10, 1);
    __int16 v11 = qword_100A19EC8;
    if (!os_log_type_enabled((os_log_t)qword_100A19EC8, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_19;
    }
    int v12 = __p;
    if (v16 < 0) {
      int v12 = (void **)__p[0];
    }
    *(_DWORD *)long long buf = 136315138;
    uint64_t v18 = v12;
    __int16 v13 = "Bluetooth discoveryEvent: device changed: %s";
LABEL_15:
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, v13, buf, 0xCu);
    goto LABEL_19;
  }
  if (os_log_type_enabled((os_log_t)qword_100A19EC8, OS_LOG_TYPE_ERROR)) {
    sub_10074D46C();
  }
  xpc_release(v10);
LABEL_19:
  if (SHIBYTE(v16) < 0) {
    operator delete(__p[0]);
  }
}

void sub_10027F46C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void sub_10027F4A0(uint64_t a1, int a2, uint64_t a3, void *a4, int a5, int a6)
{
  id v11 = a4;
  int v12 = qword_100A19EC8;
  if (os_log_type_enabled((os_log_t)qword_100A19EC8, OS_LOG_TYPE_DEFAULT))
  {
    int v13 = *(unsigned __int8 *)(a1 + 193);
    *(_DWORD *)long long buf = 67109632;
    int v28 = a2;
    __int16 v29 = 1024;
    int v30 = v13;
    __int16 v31 = 1024;
    int v32 = a6;
    _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "startInquiry: continuous? %d, already scanning? %d, duplicates to be reported? %d", buf, 0x14u);
  }
  if (!*(unsigned char *)(a1 + 193))
  {
    objc_storeStrong((id *)(a1 + 200), a4);
    *(_DWORD *)(a1 + 208) = a5;
    sub_10027F754((__n128 *)a1, v14);
    uint64_t v15 = *(void *)(a1 + 176);
    if (v15)
    {
      if (a6)
      {
        uint64_t v16 = qword_100A19EC8;
        if (os_log_type_enabled((os_log_t)qword_100A19EC8, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)long long buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "startInquiry: Enabling duplicate reporting.", buf, 2u);
          uint64_t v15 = *(void *)(a1 + 176);
        }
        sub_1005014F4(v15);
        *(unsigned char *)(a1 + 212) = 1;
      }
      if (a2)
      {
        if (qword_1009F8398 != -1) {
          dispatch_once(&qword_1009F8398, &stru_1009A0DE0);
        }
        int v17 = off_1009F8390;
        uint64_t v18 = *(std::__shared_weak_count **)(a1 + 184);
        uint64_t v25 = *(void *)(a1 + 176);
        unsigned int v26 = v18;
        if (v18) {
          atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        int v19 = sub_1005057C8((uint64_t)v17, &v25, 1u, -1);
        if (v26) {
          sub_10008A294(v26);
        }
        if (v19) {
          goto LABEL_4;
        }
        *(unsigned char *)(a1 + 192) = 1;
      }
      else
      {
        if (qword_1009F8398 != -1) {
          dispatch_once(&qword_1009F8398, &stru_1009A0DE0);
        }
        uint64_t v20 = off_1009F8390;
        uint64_t v21 = *(std::__shared_weak_count **)(a1 + 184);
        uint64_t v23 = *(void *)(a1 + 176);
        uint64_t v24 = v21;
        if (v21) {
          atomic_fetch_add_explicit(&v21->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        int v22 = sub_1005057C8((uint64_t)v20, &v23, 0, -1);
        if (v24) {
          sub_10008A294(v24);
        }
        *(unsigned char *)(a1 + 192) = 0;
        if (v22) {
          goto LABEL_4;
        }
      }
      *(unsigned char *)(a1 + 193) = 1;
      goto LABEL_4;
    }
    if (os_log_type_enabled((os_log_t)qword_100A19EC8, OS_LOG_TYPE_ERROR)) {
      sub_10074D4D4();
    }
  }
LABEL_4:
}

void sub_10027F718(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10008A294(a10);
  }

  _Unwind_Resume(a1);
}

double sub_10027F754(__n128 *a1, __n128 a2)
{
  if (!a1[11].n128_u64[0])
  {
    unint64_t v11 = 0;
    if (qword_1009F8398 != -1) {
      dispatch_once(&qword_1009F8398, &stru_1009A0DE0);
    }
    int v3 = off_1009F8390;
    unint64_t v4 = sub_100019D1C(a1[8].n128_i64[0]);
    sub_100504BC4((uint64_t)v3, v4, &v11, &v9);
    if (v10) {
      sub_10008A294(v10);
    }
    if (qword_1009F8398 != -1) {
      dispatch_once(&qword_1009F8398, &stru_1009A0DE0);
    }
    sub_100504E18((uint64_t)off_1009F8390, v11, &v8);
    a2 = v8;
    __n128 v8 = 0uLL;
    uint64_t v5 = (std::__shared_weak_count *)a1[11].n128_u64[1];
    a1[11] = a2;
    if (v5)
    {
      sub_10008A294(v5);
      if (v8.n128_u64[1]) {
        sub_10008A294((std::__shared_weak_count *)v8.n128_u64[1]);
      }
      __int16 v6 = (uint64_t *)a1[11].n128_u64[0];
      if (v6) {
        goto LABEL_12;
      }
    }
    else
    {
      __int16 v6 = (uint64_t *)a2.n128_u64[0];
      if (a2.n128_u64[0])
      {
LABEL_12:
        v8.n128_u64[0] = (unint64_t)sub_10027EF78;
        v8.n128_u64[1] = (unint64_t)sub_10027F1F4;
        sub_100500908(v6, v11, (uint64_t *)&v8, (uint64_t)a1);
      }
    }
  }
  return a2.n128_f64[0];
}

void sub_10027F884(uint64_t a1, unsigned __int8 *a2)
{
  if (a2)
  {
    uint64_t v20 = 0;
    unint64_t v21 = 0;
    uint64_t v22 = 0;
    sub_100475EE0((uint64_t)a2, (uint64_t)&v20);
    if (SHIBYTE(v22) < 0)
    {
      unint64_t v4 = v20;
      if (!v20)
      {
        uint64_t v15 = 0;
        goto LABEL_33;
      }
    }
    else
    {
      unint64_t v4 = &v20;
    }
    v26[0] = 0;
    v26[1] = 0;
    if (qword_1009F7EE0 != -1) {
      dispatch_once(&qword_1009F7EE0, &stru_1009A0D80);
    }
    sub_100014B58((uint64_t)off_1009F7ED8, ((unint64_t)a2[128] << 40) | ((unint64_t)a2[129] << 32) | ((unint64_t)a2[130] << 24) | ((unint64_t)a2[131] << 16) | ((unint64_t)a2[132] << 8) | a2[133], 1u, 0, 0, 0, (unsigned __int8 *)v26);
    uint64_t v5 = +[NSString stringWithUTF8String:v4];
    if (v5)
    {
      uint64_t v6 = sub_100031234((const unsigned __int8 *)v26);
      id v7 = (id)v6;
      if (v6)
      {
        v23[0] = @"kCBMsgArgDeviceUUID";
        v23[1] = @"kCBMsgArgName";
        v24[0] = v6;
        v24[1] = v5;
        __n128 v8 = +[NSDictionary dictionaryWithObjects:v24 forKeys:v23 count:2];
        sub_100017388(a1, 45, v8);

        if (os_log_type_enabled((os_log_t)qword_100A19EC8, OS_LOG_TYPE_DEBUG)) {
          sub_10074D624();
        }
      }
      else if (os_log_type_enabled((os_log_t)qword_100A19EC8, OS_LOG_TYPE_ERROR))
      {
        sub_10074D5BC();
      }
    }
    else
    {
      uint64_t v9 = qword_100A19EC8;
      if (os_log_type_enabled((os_log_t)qword_100A19EC8, OS_LOG_TYPE_ERROR))
      {
        xpc_object_t v10 = sub_100031234((const unsigned __int8 *)v26);
        sub_10074D570(v10, (uint64_t)v25, v9);
      }
      id v7 = objc_alloc_init((Class)NSMutableString);
      unint64_t v11 = HIBYTE(v22);
      if (v22 < 0) {
        unint64_t v11 = v21;
      }
      if (v11)
      {
        for (unint64_t i = 0; i < v13; ++i)
        {
          [v7 appendFormat:@"%X ", *((unsigned __int8 *)v4 + i)];
          unint64_t v13 = HIBYTE(v22);
          if (v22 < 0) {
            unint64_t v13 = v21;
          }
        }
      }
      if (os_log_type_enabled((os_log_t)qword_100A19EC8, OS_LOG_TYPE_ERROR)) {
        sub_10074D508();
      }
      if (qword_1009FB088 != -1) {
        dispatch_once(&qword_1009FB088, &stru_1009A0E00);
      }
      uint64_t v14 = qword_1009FB080;
      sub_10004191C(v18, "XpcClassicConnection::deviceNameUpdated");
      sub_10004191C(__p, "Unparseable name change");
      sub_1004B7DA8(0.0, v14, (uint64_t *)v18, (uint64_t *)__p);
      if (v17 < 0) {
        operator delete(__p[0]);
      }
      if (v19 < 0) {
        operator delete(v18[0]);
      }
    }

    if (SHIBYTE(v22) < 0)
    {
      uint64_t v15 = v20;
LABEL_33:
      operator delete(v15);
    }
  }
}

void sub_10027FBCC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void sub_10027FC64(uint64_t a1, unsigned __int8 *a2)
{
}

void sub_10027FC6C(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    sub_100475EE0(a2, (uint64_t)&__p);
    BOOL v5 = v9 < 0 && __p == 0;
    if (v9 < 0)
    {
      operator delete(__p);
      if (v5) {
        return;
      }
    }
    else if (v5)
    {
      return;
    }
    uint64_t v6 = sub_100019878();
    v7[0] = _NSConcreteStackBlock;
    v7[1] = 3221225472;
    _DWORD v7[2] = sub_10027FD30;
    v7[3] = &unk_100998260;
    void v7[4] = a1;
    v7[5] = a2;
    sub_100013018(v6, v7);
  }
}

void sub_10027FD30(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (qword_1009F7EE0 != -1) {
    dispatch_once(&qword_1009F7EE0, &stru_1009A0D80);
  }
  v10[0] = 0;
  v10[1] = 0;
  int v3 = *(unsigned __int8 **)(a1 + 40);
  sub_100014B58((uint64_t)off_1009F7ED8, ((unint64_t)v3[128] << 40) | ((unint64_t)v3[129] << 32) | ((unint64_t)v3[130] << 24) | ((unint64_t)v3[131] << 16) | ((unint64_t)v3[132] << 8) | v3[133], 1u, 0, 0, 0, (unsigned __int8 *)v10);
  unint64_t v4 = sub_100031234((const unsigned __int8 *)v10);
  BOOL v5 = v4;
  if (v4)
  {
    xpc_object_t v6 = sub_10027E878(v4);
    sub_1000173FC(v2, 45, v6, 1);
  }
  else
  {
    id v7 = qword_100A19EC8;
    if (os_log_type_enabled((os_log_t)qword_100A19EC8, OS_LOG_TYPE_ERROR))
    {
      sub_100474E18(*(void *)(a1 + 40), v8);
      sub_10074D698((char *)v8, (uint64_t)v9, v7);
    }
  }
}

void sub_10027FE80(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_10027FE9C(uint64_t a1, uint64_t a2)
{
}

void sub_10027FEA4(uint64_t a1, uint64_t a2, BOOL a3)
{
  xpc_object_t v5 = xpc_dictionary_create(0, 0, 0);
  xpc_object_t v6 = qword_100A19EC8;
  if (os_log_type_enabled((os_log_t)qword_100A19EC8, OS_LOG_TYPE_DEFAULT))
  {
    id v7 = (void *)(a1 + 56);
    if (*(char *)(a1 + 79) < 0) {
      id v7 = (void *)*v7;
    }
    v8[0] = 67109378;
    v8[1] = a3;
    __int16 v9 = 2082;
    xpc_object_t v10 = v7;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "Sending 'connectable state' event with state \"%d\" to session \"%{public}s\"", (uint8_t *)v8, 0x12u);
  }
  xpc_dictionary_set_BOOL(v5, "kCBMsgArgConnectableState", a3);
  sub_1000173FC(a1, 6, v5, 1);
}

void sub_10027FFAC(uint64_t a1, uint64_t a2, BOOL a3)
{
}

void sub_10027FFB4(uint64_t a1, uint64_t a2, BOOL a3)
{
  xpc_object_t v5 = xpc_dictionary_create(0, 0, 0);
  xpc_object_t v6 = qword_100A19EC8;
  if (os_log_type_enabled((os_log_t)qword_100A19EC8, OS_LOG_TYPE_DEFAULT))
  {
    id v7 = (void *)(a1 + 56);
    if (*(char *)(a1 + 79) < 0) {
      id v7 = (void *)*v7;
    }
    v8[0] = 67109378;
    v8[1] = a3;
    __int16 v9 = 2082;
    xpc_object_t v10 = v7;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "Sending 'discoverable state' event with state \"%d\" to session \"%{public}s\"", (uint8_t *)v8, 0x12u);
  }
  xpc_dictionary_set_BOOL(v5, "kCBMsgArgDiscoverableState", a3);
  sub_1000173FC(a1, 6, v5, 1);
}

void sub_1002800BC(uint64_t a1, uint64_t a2, BOOL a3)
{
}

void sub_1002800C4(uint64_t a1, uint64_t a2, BOOL a3)
{
  xpc_object_t v5 = xpc_dictionary_create(0, 0, 0);
  xpc_object_t v6 = qword_100A19EC8;
  if (os_log_type_enabled((os_log_t)qword_100A19EC8, OS_LOG_TYPE_DEFAULT))
  {
    id v7 = (void *)(a1 + 56);
    if (*(char *)(a1 + 79) < 0) {
      id v7 = (void *)*v7;
    }
    v8[0] = 67109378;
    v8[1] = a3;
    __int16 v9 = 2082;
    xpc_object_t v10 = v7;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "Sending 'inquiry state' event with state \"%d\" to session \"%{public}s\"", (uint8_t *)v8, 0x12u);
  }
  xpc_dictionary_set_BOOL(v5, "kCBMsgArgInquiryState", a3);
  sub_1000173FC(a1, 6, v5, 1);
}

void sub_1002801CC(uint64_t a1, uint64_t a2, BOOL a3)
{
}

void sub_1002801D4(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  int v3 = qword_100A19EC8;
  if (os_log_type_enabled((os_log_t)qword_100A19EC8, OS_LOG_TYPE_DEFAULT))
  {
    unint64_t v4 = (void *)(v2 + 56);
    if (*(char *)(v2 + 79) < 0) {
      unint64_t v4 = (void *)*v4;
    }
    int v5 = 136446210;
    xpc_object_t v6 = v4;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Session \"%{public}s\" is asking to register pairing agent", (uint8_t *)&v5, 0xCu);
  }
  if (qword_1009F8788 != -1) {
    dispatch_once(&qword_1009F8788, &stru_1009A0CE0);
  }
  sub_1002F60AC((uint64_t)off_1009F8780, *(void *)(v2 + 128), *(unsigned __int8 *)(a1 + 40));
}

void sub_1002802D0(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  uint64_t v2 = qword_100A19EC8;
  if (os_log_type_enabled((os_log_t)qword_100A19EC8, OS_LOG_TYPE_DEFAULT))
  {
    int v3 = (void *)(v1 + 56);
    if (*(char *)(v1 + 79) < 0) {
      int v3 = (void *)*v3;
    }
    int v4 = 136446210;
    int v5 = v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Session \"%{public}s\" is asking to unregister pairing agent", (uint8_t *)&v4, 0xCu);
  }
  if (qword_1009F8788 != -1) {
    dispatch_once(&qword_1009F8788, &stru_1009A0CE0);
  }
  sub_100055E1C((uint64_t)off_1009F8780, *(void *)(v1 + 128));
}

void sub_1002803BC(uint64_t a1)
{
  id v7 = 0;
  __n128 v8 = 0;
  uint64_t v9 = 0;
  if (qword_1009F8768 != -1) {
    dispatch_once(&qword_1009F8768, &stru_1009A0D60);
  }
  sub_10060C508((uint64_t)off_1009F8760, &v7);
  uint64_t v2 = v7;
  int v3 = v8;
  if (v7 != v8)
  {
    do
    {
      int v4 = (unsigned __int8 *)*v2;
      v10[0] = 0;
      v10[1] = 0;
      if (qword_1009F7EE0 != -1) {
        dispatch_once(&qword_1009F7EE0, &stru_1009A0D80);
      }
      sub_100014B58((uint64_t)off_1009F7ED8, ((unint64_t)v4[128] << 40) | ((unint64_t)v4[129] << 32) | ((unint64_t)v4[130] << 24) | ((unint64_t)v4[131] << 16) | ((unint64_t)v4[132] << 8) | v4[133], 1u, 0, 0, 0, (unsigned __int8 *)v10);
      int v5 = sub_100031234((const unsigned __int8 *)v10);
      xpc_object_t v6 = sub_10027E878(v5);

      xpc_array_append_value(*(xpc_object_t *)(a1 + 40), v6);
      xpc_release(v6);
      ++v2;
    }
    while (v2 != v3);
    uint64_t v2 = v7;
  }
  if (v2)
  {
    __n128 v8 = v2;
    operator delete(v2);
  }
}

void sub_100280558(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100280590(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 40);
  if (qword_1009FB078 != -1) {
    dispatch_once(&qword_1009FB078, &stru_1009A0D00);
  }
  uint64_t v3 = qword_1009FB070;
  unint64_t v4 = *(void *)(v2 + 128);
  int v5 = (void (***)(void, void *, uint64_t, uint64_t, void, void, void))(v2 + 152);
  int v6 = *(_DWORD *)(v2 + 40);
  uint64_t v7 = *(unsigned __int16 *)(a1 + 48);
  int v8 = *(unsigned __int16 *)(a1 + 56);
  sub_1000305AC(uu, *(void *)(a1 + 32));
  sub_100401028(v3, v4, v5, v6, v7, v8, 0, 0, 0, uu, 0, 0);
}

void sub_100280688(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 40);
  if (qword_1009FB078 != -1) {
    dispatch_once(&qword_1009FB078, &stru_1009A0D00);
  }
  uint64_t v3 = qword_1009FB070;
  unint64_t v4 = *(void *)(v2 + 128);
  uint64_t v5 = *(unsigned __int16 *)(a1 + 48);
  sub_1000305AC(uu, *(void *)(a1 + 32));
  sub_100402710(v3, v4, v5, uu);
}

void sub_100280740(uint64_t a1, int a2, int a3)
{
  int v6 = qword_100A19EC8;
  if (os_log_type_enabled((os_log_t)qword_100A19EC8, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 67109376;
    *(_DWORD *)&uint8_t buf[4] = a2;
    LOWORD(v21) = 1024;
    *(_DWORD *)((char *)&v21 + 2) = a3;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "Classic Channel published callback PSM : %u result : %d", buf, 0xEu);
  }
  *(void *)long long buf = 0;
  unint64_t v21 = buf;
  uint64_t v22 = 0x3032000000;
  uint64_t v23 = sub_10004CF8C;
  uint64_t v24 = sub_10004CD98;
  id v25 = 0;
  uint64_t v16 = 0;
  char v17 = &v16;
  uint64_t v18 = 0x2020000000;
  int v19 = 0;
  v15[0] = 0;
  v15[1] = 0;
  sub_10003AED0((uint64_t)v15, a1 + 216);
  uint64_t v7 = *(void **)(a1 + 280);
  v13[0] = _NSConcreteStackBlock;
  v13[1] = 3221225472;
  _DWORD v13[2] = sub_100280A50;
  v13[3] = &unk_1009A0AC0;
  __int16 v14 = a2;
  v13[4] = buf;
  void v13[5] = &v16;
  [v7 enumerateKeysAndObjectsUsingBlock:v13];
  if (*((void *)v21 + 5))
  {
    if (a3)
    {
      if (os_log_type_enabled((os_log_t)qword_100A19EC8, OS_LOG_TYPE_ERROR)) {
        sub_10074D700();
      }
      char v12 = 0;
      sub_10001B8E0(&v12);
      sub_10024E448(*((_DWORD *)v17 + 6));
      sub_10001B910(&v12);
      int v8 = *(void **)(a1 + 280);
      uint64_t v9 = +[NSNumber numberWithUnsignedInt:*((unsigned int *)v17 + 6)];
      [v8 removeObjectForKey:v9];

      sub_10001B8AC(&v12);
    }
    xpc_object_t v10 = xpc_dictionary_create(0, 0, 0);
    xpc_dictionary_set_int64(v10, "kCBMsgArgResult", a3);
    id v11 = [*((id *)v21 + 5) bytes];
    xpc_dictionary_set_data(v10, "kCBMsgArgServiceUUID", v11, (size_t)[*((id *)v21 + 5) length]);
    sub_1000173FC(a1, 46, v10, 1);
  }
  sub_10003AFB4((uint64_t)v15);
  _Block_object_dispose(&v16, 8);
  _Block_object_dispose(buf, 8);
}

void sub_1002809E8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, int a9, __int16 a10, char a11, char a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, char a20,uint64_t a21,char a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  sub_10001B8AC(&a12);
  sub_10003AFB4((uint64_t)&a20);
  _Block_object_dispose(&a22, 8);
  _Block_object_dispose(&a26, 8);

  _Unwind_Resume(a1);
}

void sub_100280A50(uint64_t a1, void *a2, void *a3, unsigned char *a4)
{
  id v7 = a2;
  v9[0] = _NSConcreteStackBlock;
  v9[1] = 3221225472;
  void v9[2] = sub_100280B34;
  v9[3] = &unk_1009A0A98;
  __int16 v12 = *(_WORD *)(a1 + 48);
  long long v11 = *(_OWORD *)(a1 + 32);
  id v10 = v7;
  id v8 = v7;
  [a3 enumerateKeysAndObjectsUsingBlock:v9];
  if (*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 40)) {
    *a4 = 1;
  }
}

void sub_100280B1C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13)
{
  _Unwind_Resume(a1);
}

void sub_100280B34(uint64_t a1, void *a2, void *a3, unsigned char *a4)
{
  id v9 = a2;
  id v7 = a3;
  int v8 = *(unsigned __int16 *)(a1 + 56);
  if ([v9 intValue] == v8)
  {
    objc_storeStrong((id *)(*(void *)(*(void *)(a1 + 40) + 8) + 40), a3);
    *(_DWORD *)(*(void *)(*(void *)(a1 + 48) + 8) + 24) = [*(id *)(a1 + 32) intValue];
    *a4 = 1;
  }
}

void sub_100280BE0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_100280BF8(uint64_t a1, int a2, int a3)
{
}

void sub_100280C00(uint64_t a1, int a2, int a3)
{
  int v6 = qword_100A19EC8;
  if (os_log_type_enabled((os_log_t)qword_100A19EC8, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 67109376;
    *(_DWORD *)&uint8_t buf[4] = a2;
    LOWORD(v22) = 1024;
    *(_DWORD *)((char *)&v22 + 2) = a3;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "Classic Channel unpublished callback PSM : %u, result : %d", buf, 0xEu);
  }
  *(void *)long long buf = 0;
  uint64_t v22 = buf;
  uint64_t v23 = 0x3032000000;
  uint64_t v24 = sub_10004CF8C;
  id v25 = sub_10004CD98;
  id v26 = 0;
  uint64_t v15 = 0;
  uint64_t v16 = &v15;
  uint64_t v17 = 0x2020000000;
  int v18 = 0;
  v14[0] = 0;
  v14[1] = 0;
  sub_10003AED0((uint64_t)v14, a1 + 216);
  id v7 = *(void **)(a1 + 280);
  v12[0] = _NSConcreteStackBlock;
  v12[1] = 3221225472;
  _DWORD v12[2] = sub_100280EC4;
  _OWORD v12[3] = &unk_1009A0AC0;
  __int16 v13 = a2;
  v12[4] = buf;
  void v12[5] = &v15;
  [v7 enumerateKeysAndObjectsUsingBlock:v12];
  if (*((void *)v22 + 5))
  {
    int v8 = qword_100A19EC8;
    if (os_log_type_enabled((os_log_t)qword_100A19EC8, OS_LOG_TYPE_DEFAULT))
    {
      int v9 = *((_DWORD *)v16 + 6);
      *(_DWORD *)int v19 = 67109120;
      int v20 = v9;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "Classic Channel unpublished removing SRH 0x%X", v19, 8u);
    }
    v19[0] = 0;
    sub_10001B8E0(v19);
    sub_10024E448(*((_DWORD *)v16 + 6));
    sub_10001B910(v19);
    id v10 = *(void **)(a1 + 280);
    long long v11 = +[NSNumber numberWithUnsignedInt:*((unsigned int *)v16 + 6)];
    [v10 removeObjectForKey:v11];

    sub_10001B8AC(v19);
  }
  sub_10003AFB4((uint64_t)v14);
  _Block_object_dispose(&v15, 8);
  _Block_object_dispose(buf, 8);
}

void sub_100280E60(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va2, a9);
  va_start(va1, a9);
  va_start(va, a9);
  uint64_t v12 = va_arg(va1, void);
  uint64_t v14 = va_arg(va1, void);
  va_copy(va2, va1);
  uint64_t v15 = va_arg(va2, void);
  uint64_t v17 = va_arg(va2, void);
  uint64_t v18 = va_arg(va2, void);
  uint64_t v19 = va_arg(va2, void);

  sub_10001B8AC(va2);
  sub_10003AFB4((uint64_t)va);
  _Block_object_dispose(va1, 8);
  _Block_object_dispose((const void *)(v10 - 112), 8);

  _Unwind_Resume(a1);
}

void sub_100280EC4(uint64_t a1, void *a2, void *a3, unsigned char *a4)
{
  id v7 = a2;
  v9[0] = _NSConcreteStackBlock;
  v9[1] = 3221225472;
  void v9[2] = sub_100280FA8;
  v9[3] = &unk_1009A0A98;
  __int16 v12 = *(_WORD *)(a1 + 48);
  long long v11 = *(_OWORD *)(a1 + 32);
  id v10 = v7;
  id v8 = v7;
  [a3 enumerateKeysAndObjectsUsingBlock:v9];
  if (*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 40)) {
    *a4 = 1;
  }
}

void sub_100280F90(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13)
{
  _Unwind_Resume(a1);
}

void sub_100280FA8(uint64_t a1, void *a2, void *a3, unsigned char *a4)
{
  id v9 = a2;
  id v7 = a3;
  int v8 = *(unsigned __int16 *)(a1 + 56);
  if ([v9 intValue] == v8)
  {
    objc_storeStrong((id *)(*(void *)(*(void *)(a1 + 40) + 8) + 40), a3);
    *(_DWORD *)(*(void *)(*(void *)(a1 + 48) + 8) + 24) = [*(id *)(a1 + 32) intValue];
    *a4 = 1;
  }
}

void sub_100281054(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_10028106C(uint64_t a1, int a2, int a3)
{
}

void sub_100281074(uint64_t a1, void *a2, int a3, unsigned int a4, int a5, BOOL a6, int a7)
{
  id v13 = a2;
  uint64_t v14 = qword_100A19EC8;
  if (os_log_type_enabled((os_log_t)qword_100A19EC8, OS_LOG_TYPE_DEFAULT))
  {
    unint64_t v18 = __PAIR64__(a3, 67109888);
    LOWORD(v19) = 1024;
    *(_DWORD *)((char *)&v19 + 2) = a4;
    HIWORD(v19) = 1024;
    int v20 = a5;
    __int16 v21 = 1024;
    int v22 = a7;
    _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "Classic Channel connected callback : result: 0x%x, psm: 0x%x, cid: 0x%x, sock: 0x%x", (uint8_t *)&v18, 0x1Au);
  }
  xpc_object_t v15 = xpc_dictionary_create(0, 0, 0);
  id v16 = v13;
  uint64_t v17 = v16;
  if (v16)
  {
    unint64_t v18 = 0;
    uint64_t v19 = 0;
    [v16 getUUIDBytes:&v18];
    xpc_dictionary_set_uuid(v15, "kCBMsgArgDeviceUUID", (const unsigned __int8 *)&v18);
  }

  xpc_dictionary_set_int64(v15, "kCBMsgArgResult", a3);
  xpc_dictionary_set_int64(v15, "kCBMsgArgPSM", a4);
  xpc_dictionary_set_fd(v15, "kCBMsgArgSocket", a7);
  xpc_dictionary_set_BOOL(v15, "kCBMsgArgIsIncoming", a6);
  sub_1000173FC(a1, 23, v15, 1);
}

void sub_100281214(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100281238(uint64_t a1, void *a2, int a3, unsigned int a4, int a5, BOOL a6, int a7)
{
}

void sub_100281240(uint64_t a1, void *a2, int a3, unsigned int a4, int a5)
{
  id v9 = a2;
  id v10 = qword_100A19EC8;
  if (os_log_type_enabled((os_log_t)qword_100A19EC8, OS_LOG_TYPE_DEFAULT))
  {
    LODWORD(v14) = 67109632;
    HIDWORD(v14) = a3;
    LOWORD(v15) = 1024;
    *(_DWORD *)((char *)&v15 + 2) = a4;
    HIWORD(v15) = 1024;
    int v16 = a5;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "Classic Channel disconnected callback result : %d, psm : %u, cid = %u", (uint8_t *)&v14, 0x14u);
  }
  xpc_object_t v11 = xpc_dictionary_create(0, 0, 0);
  id v12 = v9;
  id v13 = v12;
  if (v12)
  {
    uint64_t v14 = 0;
    uint64_t v15 = 0;
    [v12 getUUIDBytes:&v14];
    xpc_dictionary_set_uuid(v11, "kCBMsgArgDeviceUUID", (const unsigned __int8 *)&v14);
  }

  xpc_dictionary_set_int64(v11, "kCBMsgArgResult", a3);
  xpc_dictionary_set_int64(v11, "kCBMsgArgPSM", a4);
  sub_1000173FC(a1, 24, v11, 1);
}

void sub_1002813A4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1002813C8(uint64_t a1, void *a2, int a3, unsigned int a4, int a5)
{
}

uint64_t sub_1002813D0(uint64_t a1, uint64_t a2, void *a3, int a4)
{
  id v5 = a3;
  memset(v15, 0, sizeof(v15));
  unsigned int v14 = 0;
  byte_100A12078 = 1;
  word_100A1207A = 2;
  dword_100A12080 = a4;
  if ([v5 length] == (id)2)
  {
    id v6 = [v5 bytes];
    __int16 v7 = 2;
  }
  else
  {
    id v8 = [v5 length];
    id v6 = [v5 bytes];
    if (v8 == (id)4) {
      __int16 v7 = 4;
    }
    else {
      __int16 v7 = 16;
    }
  }
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_100A12098, memory_order_acquire) & 1) == 0)
  {
    uint64_t v12 = (uint64_t)v6;
    if (__cxa_guard_acquire(&qword_100A12098))
    {
      byte_100A12088 = 3;
      word_100A1208A = v7;
      qword_100A12090 = v12;
      __cxa_guard_release(&qword_100A12098);
    }
  }
  *(void *)&v15[0] = &unk_1009A0B10;
  WORD4(v15[0]) = 3;
  char v13 = 0;
  sub_10001B8E0(&v13);
  int v9 = sub_10024E258((uint64_t)v15, (int *)&v14);
  sub_10001B910(&v13);
  if (v9)
  {
    uint64_t v10 = 0;
    unsigned int v14 = 0;
  }
  else
  {
    uint64_t v10 = v14;
  }
  sub_10001B8AC(&v13);

  return v10;
}

void sub_100281528(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t sub_100281558(uint64_t a1, void *a2)
{
  id v2 = a2;
  uint64_t v3 = qword_100A19EC8;
  if (os_log_type_enabled((os_log_t)qword_100A19EC8, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 138412290;
    *(void *)&uint8_t buf[4] = v2;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "addServiceDataToLocalSDP: %@", buf, 0xCu);
  }
  unint64_t v4 = v2;
  if (v2)
  {
    if ([v2 length])
    {
      long long v75 = 0;
      uint64_t v76 = 0;
      *(_OWORD *)long long buf = 0u;
      long long v82 = 0u;
      unsigned int v74 = 0;
      id v58 = v2;
      id v5 = v2;
      if ([v5 bytes])
      {
        if ([v5 length])
        {
          HIBYTE(v76) = 0;
          id v6 = v5;
          long long v75 = (unsigned __int16 *)[v6 bytes];
          LOWORD(v76) = (unsigned __int16)[v6 length];
          WORD1(v76) = (unsigned __int16)[v6 length];
          __int16 v7 = "((byteStreamData).__data != NULL) && ((byteStreamData).__trueSize > 0)";
          int v8 = 1529;
          if (v75 && (_WORD)v76)
          {
            BYTE6(v76) = 1;
            *(_DWORD *)((char *)&v76 + 2) = (unsigned __int16)v76;
            if ((unsigned __int16)v76 > 1u)
            {
              size_t v9 = *v75;
              WORD2(v76) = 2;
              uint64_t v10 = qword_100A19EC8;
              if (os_log_type_enabled((os_log_t)qword_100A19EC8, OS_LOG_TYPE_DEFAULT))
              {
                LODWORD(v79) = 67109376;
                DWORD1(v79) = v9;
                WORD4(v79) = 1024;
                *(_DWORD *)((char *)&v79 + 10) = v9;
                _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "addServiceDataToLocalSDP: Number of attributes: %d, 0x%x", (uint8_t *)&v79, 0xEu);
              }
              xpc_object_t v11 = (char *)malloc_type_calloc(v9, 0x18uLL, 0x10F20406C095635uLL);
              if (v11)
              {
                if (v9)
                {
                  LODWORD(v12) = 0;
                  char v13 = "ByteStream_NumReadBytesAvail(byteStreamData) >= 2";
                  while (1)
                  {
                    if (HIBYTE(v76))
                    {
                      sub_10025A794((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Daemon/Server/Xp"
                                             "cClassicConnection.mm");
                      char v13 = "ByteStream_NumReadBytesAvail(byteStreamData) >= 2";
LABEL_95:
                      sub_10014327C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Daemon/Server/XpcClassicConnection.mm", 1544, v13);
                    }
                    if (WORD1(v76) - WORD2(v76) <= 1) {
                      goto LABEL_95;
                    }
                    if (BYTE6(v76) != 1)
                    {
                      char v13 = "(byteStreamData).__RWFlag == BYTESTREAM_READ";
                      goto LABEL_95;
                    }
                    uint64_t v14 = *(unsigned __int16 *)((char *)v75 + WORD2(v76));
                    WORD2(v76) += 2;
                    uint64_t v15 = &v11[24 * (unsigned __int16)v12];
                    *(_WORD *)uint64_t v15 = v14;
                    if ((sub_1002D54E4((uint64_t *)&v75, (uint64_t)(v15 + 8)) & 1) == 0) {
                      break;
                    }
                    if (v14 <= 8 && ((1 << v14) & 0x165) != 0)
                    {
                      LOWORD(v9) = v9 - 1;
                      LODWORD(v12) = v12 - 1;
                    }
                    LODWORD(v12) = v12 + 1;
                    if ((unsigned __int16)v12 >= (unsigned __int16)v9) {
                      goto LABEL_25;
                    }
                  }
                  __int16 v31 = qword_100A19EC8;
                  if (os_log_type_enabled((os_log_t)qword_100A19EC8, OS_LOG_TYPE_ERROR)) {
                    sub_10074D9A4(v14, v31, v32, v33, v34, v35, v36, v37);
                  }
                  unint64_t v4 = v58;
                  if ((_WORD)v12)
                  {
                    uint64_t v38 = v11 + 8;
                    uint64_t v12 = (unsigned __int16)v12;
                    do
                    {
                      sub_1002D5394(v38);
                      v38 += 24;
                      --v12;
                    }
                    while (v12);
                  }
                  free(v11);
                  goto LABEL_61;
                }
LABEL_25:
                *(void *)long long buf = v11;
                *(_WORD *)&uint8_t buf[8] = v9;
                *(void *)&long long v82 = 0;
                WORD4(v82) = 0;
                char v73 = 0;
                uint64_t v17 = sub_10001B8E0(&v73);
                if ((_WORD)v9)
                {
                  uint64_t v18 = 0;
                  id v19 = 0;
                  while (1)
                  {
                    int v20 = &v11[24 * v18];
                    if (*(_WORD *)v20 == 1)
                    {
                      long long v71 = *(_OWORD *)v20;
                      uint64_t v72 = *((void *)v20 + 2);
                      __int16 v21 = sub_100281F88((uint64_t)v17, (uint64_t)&v71);

                      if (![v21 count])
                      {
                        if (os_log_type_enabled((os_log_t)qword_100A19EC8, OS_LOG_TYPE_ERROR)) {
                          sub_10074D8AC();
                        }
                        uint64_t v27 = 0;
                        id v19 = v21;
                        goto LABEL_87;
                      }
                      long long v69 = 0u;
                      long long v70 = 0u;
                      long long v67 = 0u;
                      long long v68 = 0u;
                      id v19 = v21;
                      id v22 = [v19 countByEnumeratingWithState:&v67 objects:v80 count:16];
                      if (v22)
                      {
                        uint64_t v23 = *(void *)v68;
                        while (2)
                        {
                          for (unint64_t i = 0; i != v22; unint64_t i = (char *)i + 1)
                          {
                            if (*(void *)v68 != v23) {
                              objc_enumerationMutation(v19);
                            }
                            id v25 = *(void **)(*((void *)&v67 + 1) + 8 * i);
                            if ((unint64_t)[v25 length] > 4)
                            {
                              int v30 = qword_100A19EC8;
                              if (os_log_type_enabled((os_log_t)qword_100A19EC8, OS_LOG_TYPE_ERROR)) {
                                sub_10074D964(&v65, v66, v30);
                              }
                            }
                            else
                            {
                              *(_WORD *)long long v77 = 0;
                              id v26 = v25;
                              uint64_t v27 = sub_10024BF70(*(_DWORD *)[v26 bytes], v77);
                              int v28 = qword_100A19EC8;
                              BOOL v29 = os_log_type_enabled((os_log_t)qword_100A19EC8, OS_LOG_TYPE_ERROR);
                              if (v27)
                              {
                                if (v29) {
                                  sub_10074D8E0();
                                }

                                goto LABEL_87;
                              }
                              if (v29)
                              {
                                LODWORD(v79) = 138412290;
                                *(void *)((char *)&v79 + 4) = v26;
                                _os_log_error_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_ERROR, "New service being added for %@", (uint8_t *)&v79, 0xCu);
                              }
                            }
                          }
                          id v22 = [v19 countByEnumeratingWithState:&v67 objects:v80 count:16];
                          if (v22) {
                            continue;
                          }
                          break;
                        }
                      }
                    }
                    if (++v18 == (unsigned __int16)v9) {
                      goto LABEL_63;
                    }
                  }
                }
                id v19 = 0;
LABEL_63:
                int v39 = sub_10024E258((uint64_t)buf, (int *)&v74);
                sub_10001B910(&v73);
                id v40 = qword_100A19EC8;
                if (v39)
                {
                  if (os_log_type_enabled((os_log_t)qword_100A19EC8, OS_LOG_TYPE_ERROR)) {
                    sub_10074D844();
                  }
                }
                else
                {
                  if (os_log_type_enabled((os_log_t)qword_100A19EC8, OS_LOG_TYPE_DEFAULT))
                  {
                    LODWORD(v79) = 67109120;
                    DWORD1(v79) = v74;
                    _os_log_impl((void *)&_mh_execute_header, v40, OS_LOG_TYPE_DEFAULT, "addServiceDataToLocalSDP: SRH 0x%X", (uint8_t *)&v79, 8u);
                  }
                  long long v79 = 0uLL;
                  sub_10003AED0((uint64_t)&v79, a1 + 216);
                  uint64_t v60 = +[NSMutableArray array];
                  if ((_WORD)v9)
                  {
                    uint64_t v41 = (unsigned __int16)v9;
                    uint64_t v42 = (uint64_t)(v11 + 8);
                    do
                    {
                      int v43 = *(unsigned __int16 *)(v42 - 8);
                      if (v43 == 13 || v43 == 4)
                      {
                        uint64_t v45 = sub_100282100(a1, v42);
                        if (v45)
                        {
                          long long v46 = +[NSNumber numberWithUnsignedShort:v45];
                          unsigned __int8 v47 = [v60 containsObject:v46];

                          if ((v47 & 1) == 0)
                          {
                            uint64_t v48 = qword_100A19EC8;
                            if (os_log_type_enabled((os_log_t)qword_100A19EC8, OS_LOG_TYPE_DEFAULT))
                            {
                              *(_DWORD *)long long v77 = 67109120;
                              int v78 = v45;
                              _os_log_impl((void *)&_mh_execute_header, v48, OS_LOG_TYPE_DEFAULT, "addServiceDataToLocalSDP: publishing PSM %d", v77, 8u);
                            }
                            char v49 = +[NSNumber numberWithUnsignedShort:v45];
                            [v60 addObject:v49];

                            if (v19)
                            {
                              uint64_t v50 = [v19 firstObject];
                              uint64_t v51 = +[NSNumber numberWithUnsignedShort:v45];
                              uint64_t v52 = +[NSMutableDictionary dictionaryWithObject:v50 forKey:v51];
                              int v53 = *(void **)(a1 + 280);
                              char v54 = +[NSNumber numberWithUnsignedInt:v74];
                              [v53 setObject:v52 forKeyedSubscript:v54];
                            }
                            else
                            {
                              uint64_t v55 = qword_100A19EC8;
                              if (os_log_type_enabled((os_log_t)qword_100A19EC8, OS_LOG_TYPE_ERROR)) {
                                sub_10074D804(&v63, v64, v55);
                              }
                            }
                            uint64_t v56 = sub_100019878();
                            v61[0] = _NSConcreteStackBlock;
                            v61[1] = 3221225472;
                            v61[2] = sub_1002821E0;
                            v61[3] = &unk_1009A0B58;
                            v61[4] = a1;
                            __int16 v62 = v45;
                            sub_1000197D8(v56, v61);
                          }
                        }
                      }
                      v42 += 24;
                      --v41;
                    }
                    while (v41);
                  }

                  sub_10003AFB4((uint64_t)&v79);
                }
                uint64_t v27 = v74;
LABEL_87:

                sub_10001B8AC(&v73);
              }
              else
              {
                if (os_log_type_enabled((os_log_t)qword_100A19EC8, OS_LOG_TYPE_ERROR)) {
                  sub_10074D7D0();
                }
                uint64_t v27 = 0;
              }
              unint64_t v4 = v58;
              goto LABEL_89;
            }
            __int16 v7 = "ByteStream_NumReadBytesAvail(byteStreamData) >= 2";
            int v8 = 1530;
          }
LABEL_100:
          sub_10014327C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Daemon/Server/XpcClassicConnection.mm", v8, v7);
        }
        __int16 v7 = "(serviceRecordData.length) > 0";
      }
      else
      {
        __int16 v7 = "(uint8_t*)serviceRecordData.bytes";
      }
      int v8 = 1528;
      goto LABEL_100;
    }
    if (os_log_type_enabled((os_log_t)qword_100A19EC8, OS_LOG_TYPE_ERROR)) {
      sub_10074D79C();
    }
  }
  else if (os_log_type_enabled((os_log_t)qword_100A19EC8, OS_LOG_TYPE_ERROR))
  {
    sub_10074D768();
  }
LABEL_61:
  uint64_t v27 = 0;
LABEL_89:

  return v27;
}

void sub_100281EB8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,__int16 a38,char a39,char a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,char a45)
{
  sub_10003AFB4((uint64_t)&a45);

  sub_10001B8AC(&a40);
  _Unwind_Resume(a1);
}

id sub_100281F88(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = +[NSMutableArray array];
  if (*(_WORD *)a2 == 1 && *(unsigned char *)(a2 + 8) == 6)
  {
    uint64_t v4 = *(unsigned __int16 *)(a2 + 10);
    if (*(_WORD *)(a2 + 10))
    {
      id v5 = *(long long **)(a2 + 16);
      while (1)
      {
        long long v9 = *v5;
        if (v9 == 3) {
          break;
        }
        ++v5;
        if (!--v4) {
          goto LABEL_11;
        }
      }
      if (WORD1(v9) == 16)
      {
        long long v10 = **((_OWORD **)&v9 + 1);
        id v6 = +[NSData dataWithBytes:&v10 length:16];
        [v3 addObject:v6];
      }
      else
      {
        __int16 v7 = +[NSData dataWithBytes:(char *)&v9 + 8 length:4];
        [v3 addObject:v7];
      }
    }
  }
LABEL_11:

  return v3;
}

void sub_1002820C4(_Unwind_Exception *a1)
{
  uint64_t v3 = v2;

  _Unwind_Resume(a1);
}

uint64_t sub_100282100(uint64_t a1, uint64_t a2)
{
  if (*(unsigned char *)a2 == 6)
  {
    long long v11 = xmmword_1007BB250;
    if (*(_WORD *)(a2 + 2))
    {
      uint64_t v4 = 0;
      unint64_t v5 = 1;
      do
      {
        if (*(unsigned char *)(*(void *)(a2 + 8) + v4) == 6)
        {
          LODWORD(result) = sub_100282100(a1, *(void *)(a2 + 8) + v4);
          if (result) {
            return (unsigned __int16)result;
          }
          unint64_t v7 = *(unsigned __int16 *)(a2 + 2);
        }
        else
        {
          BOOL v8 = sub_1002D65C8(*(void *)(a2 + 8) + v4, (uint64_t)&v11);
          unint64_t v7 = *(unsigned __int16 *)(a2 + 2);
          BOOL v9 = !v8 || v5 >= v7;
          if (!v9)
          {
            uint64_t v10 = *(void *)(a2 + 8) + v4;
            if (*(unsigned char *)(v10 + 16) == 1)
            {
              LODWORD(result) = *(_DWORD *)(v10 + 24);
              return (unsigned __int16)result;
            }
          }
        }
        v4 += 16;
        BOOL v9 = v5++ >= v7;
      }
      while (!v9);
    }
  }
  LOWORD(result) = 0;
  return (unsigned __int16)result;
}

void sub_1002821E0(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (qword_1009FB078 != -1) {
    dispatch_once(&qword_1009FB078, &stru_1009A0D00);
  }
  sub_1003FFABC(qword_1009FB070, *(void *)(v2 + 128), v2 + 152, *(_DWORD *)(v2 + 40), *(_WORD *)(a1 + 40), 0, 0, 0, 0, 0, 0, 0);
}

void sub_100282268(uint64_t a1, uint64_t a2, void *a3, unsigned char *a4)
{
  v9[0] = _NSConcreteStackBlock;
  v9[1] = 3221225472;
  void v9[2] = sub_100282334;
  v9[3] = &unk_1009A0B80;
  id v7 = *(id *)(a1 + 32);
  uint64_t v8 = *(void *)(a1 + 40);
  id v10 = v7;
  uint64_t v11 = v8;
  [a3 enumerateKeysAndObjectsUsingBlock:v9];
  if (*(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24)) {
    *a4 = 1;
  }
}

void sub_100282320(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13)
{
  _Unwind_Resume(a1);
}

id sub_100282334(uint64_t a1, uint64_t a2, void *a3, unsigned char *a4)
{
  id result = [a3 isEqualToData:*(void *)(a1 + 32)];
  if (result)
  {
    *(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = 1;
    *a4 = 1;
  }
  return result;
}

void sub_100282380(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (qword_1009FB078 != -1) {
    dispatch_once(&qword_1009FB078, &stru_1009A0D00);
  }
  sub_1003FFABC(qword_1009FB070, *(void *)(v2 + 128), v2 + 152, *(_DWORD *)(v2 + 40), *(_WORD *)(a1 + 40), 0, 0, 0, 0, 0, 0, 0);
}

void sub_100282408(uint64_t a1, void *a2, void *a3, unsigned char *a4)
{
  id v7 = a2;
  v12[0] = _NSConcreteStackBlock;
  v12[1] = 3221225472;
  _DWORD v12[2] = sub_10028250C;
  _OWORD v12[3] = &unk_1009A0BD0;
  id v8 = *(id *)(a1 + 32);
  uint64_t v9 = *(void *)(a1 + 40);
  id v13 = v8;
  uint64_t v15 = v9;
  id v10 = v7;
  uint64_t v11 = *(void *)(a1 + 48);
  id v14 = v10;
  uint64_t v16 = v11;
  [a3 enumerateKeysAndObjectsUsingBlock:v12];
  if (*(_DWORD *)(*(void *)(*(void *)(a1 + 40) + 8) + 24)) {
    *a4 = 1;
  }
}

void sub_1002824EC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, void *a14)
{
  _Unwind_Resume(a1);
}

void sub_10028250C(uint64_t a1, void *a2, void *a3, unsigned char *a4)
{
  id v8 = a2;
  id v7 = a3;
  if ([v7 isEqualToData:*(void *)(a1 + 32)])
  {
    *(_DWORD *)(*(void *)(*(void *)(a1 + 48) + 8) + 24) = [*(id *)(a1 + 40) intValue];
    *(_WORD *)(*(void *)(*(void *)(a1 + 56) + 8) + 24) = (unsigned __int16)[v8 intValue];
    *a4 = 1;
  }
}

void sub_1002825AC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1002825C4(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 40);
  if (qword_1009FB078 != -1) {
    dispatch_once(&qword_1009FB078, &stru_1009A0D00);
  }
  uint64_t v3 = (void *)qword_1009FB070;
  unint64_t v4 = *(void *)(v2 + 128);
  uint64_t v5 = *(unsigned __int16 *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);

  sub_100400940(v3, v4, v5);
}

void sub_100282638(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  uint64_t v6 = *(void *)(a1 + 32);
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 3221225472;
  _DWORD v8[2] = sub_1002826EC;
  void v8[3] = &unk_1009A0C20;
  id v9 = v5;
  uint64_t v10 = v6;
  id v7 = v5;
  [a3 enumerateKeysAndObjectsUsingBlock:v8];
}

void sub_1002826D4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13)
{
  _Unwind_Resume(a1);
}

void sub_1002826EC(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  uint64_t v7 = *(void *)(a1 + 40);
  char v16 = 0;
  sub_10001B8E0(&v16);
  LODWORD(a1) = sub_10024E448((int)[*(id *)(a1 + 32) intValue]);
  sub_10001B910(&v16);
  if (!a1)
  {
    id v8 = qword_100A19EC8;
    if (os_log_type_enabled((os_log_t)qword_100A19EC8, OS_LOG_TYPE_DEFAULT))
    {
      sub_10003AE4C(*(void *)(v7 + 128), (uint64_t)__p);
      if (v15 >= 0) {
        id v9 = __p;
      }
      else {
        id v9 = (void **)__p[0];
      }
      *(_DWORD *)long long buf = 138412546;
      id v18 = v6;
      __int16 v19 = 2082;
      int v20 = v9;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "Successfully removed service uuid %@  for session \"%{public}s\"", buf, 0x16u);
      if (v15 < 0) {
        operator delete(__p[0]);
      }
    }
    uint64_t v10 = sub_100019878();
    v11[0] = _NSConcreteStackBlock;
    v11[1] = 3221225472;
    _DWORD v11[2] = sub_1002828D8;
    v11[3] = &unk_100998A38;
    uint64_t v13 = v7;
    id v12 = v5;
    sub_100013018(v10, v11);
  }
  sub_10001B8AC(&v16);
}

void sub_100282898(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  sub_10001B8AC(&a21);

  _Unwind_Resume(a1);
}

void sub_1002828D8(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 40);
  if (qword_1009FB078 != -1) {
    dispatch_once(&qword_1009FB078, &stru_1009A0D00);
  }
  uint64_t v3 = (void *)qword_1009FB070;
  unint64_t v4 = *(void *)(v2 + 128);
  uint64_t v5 = (unsigned __int16)[*(id *)(a1 + 32) intValue];

  sub_100400940(v3, v4, v5);
}

void sub_100282968(uint64_t a1, void *a2, int a3, unsigned int a4, unsigned int a5, int a6, BOOL a7, int a8)
{
  id v15 = a2;
  char v16 = qword_100A19EC8;
  if (os_log_type_enabled((os_log_t)qword_100A19EC8, OS_LOG_TYPE_DEFAULT))
  {
    LODWORD(v25) = 67110400;
    HIDWORD(v25) = a3;
    LOWORD(v26) = 1024;
    *(_DWORD *)((char *)&v26 + 2) = a4;
    HIWORD(v26) = 1024;
    unsigned int v27 = a5;
    __int16 v28 = 1024;
    int v29 = a6;
    __int16 v30 = 1024;
    BOOL v31 = a7;
    __int16 v32 = 1024;
    int v33 = a8;
    _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "RFCOMM Channel connected: result: 0x%x, rfcommChannelID: 0x%x, frameSize: 0x%x, link handle: 0x%x, incoming?: %d, sock: 0x%x", (uint8_t *)&v25, 0x26u);
  }
  xpc_object_t v17 = xpc_dictionary_create(0, 0, 0);
  id v18 = v15;
  __int16 v19 = v18;
  if (v18)
  {
    uint64_t v25 = 0;
    uint64_t v26 = 0;
    [v18 getUUIDBytes:&v25];
    xpc_dictionary_set_uuid(v17, "kCBMsgArgDeviceUUID", (const unsigned __int8 *)&v25);
  }

  xpc_dictionary_set_int64(v17, "kCBMsgArgResult", a3);
  xpc_dictionary_set_int64(v17, "kCBMsgArgRFCOMMChannelID", a4);
  xpc_dictionary_set_int64(v17, "kCBMsgArgMTU", a5);
  xpc_dictionary_set_BOOL(v17, "kCBMsgArgIsIncoming", a7);
  xpc_dictionary_set_fd(v17, "kCBMsgArgSocket", a8);
  if (qword_1009F7EE0 != -1) {
    dispatch_once(&qword_1009F7EE0, &stru_1009A0D80);
  }
  uint64_t v20 = sub_100030DCC((uint64_t)off_1009F7ED8, v19, 0);
  if (qword_1009F7F00 != -1) {
    dispatch_once(&qword_1009F7F00, &stru_1009A0DA0);
  }
  uint64_t v21 = sub_100030F10((uint64_t)off_1009F7EF8, v20, 0);
  if (v21)
  {
    id v22 = sub_10048B7F0(v21, a4);
    uint64_t v23 = v22;
    if (v22)
    {
      id v24 = v22;
      xpc_dictionary_set_data(v17, "kCBMsgArgServiceUUID", [v24 bytes], (size_t)[v24 length]);
    }
  }
  sub_1000173FC(a1, 56, v17, 1);
}

void sub_100282C08(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100282C44(uint64_t a1, void *a2, int a3, unsigned int a4, unsigned int a5, int a6, BOOL a7, int a8)
{
}

void sub_100282C4C(uint64_t a1, void *a2, int a3, unsigned int a4, int a5)
{
  id v9 = a2;
  uint64_t v10 = qword_100A19EC8;
  if (os_log_type_enabled((os_log_t)qword_100A19EC8, OS_LOG_TYPE_DEFAULT))
  {
    LODWORD(v14) = 67109632;
    HIDWORD(v14) = a3;
    LOWORD(v15) = 1024;
    *(_DWORD *)((char *)&v15 + 2) = a4;
    HIWORD(v15) = 1024;
    int v16 = a5;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "RFCOMM Channel disconnected: result: 0x%x, rfcommChannelID: 0x%x, link handle: 0x%x", (uint8_t *)&v14, 0x14u);
  }
  xpc_object_t v11 = xpc_dictionary_create(0, 0, 0);
  id v12 = v9;
  uint64_t v13 = v12;
  if (v12)
  {
    uint64_t v14 = 0;
    uint64_t v15 = 0;
    [v12 getUUIDBytes:&v14];
    xpc_dictionary_set_uuid(v11, "kCBMsgArgDeviceUUID", (const unsigned __int8 *)&v14);
  }

  xpc_dictionary_set_int64(v11, "kCBMsgArgResult", a3);
  xpc_dictionary_set_int64(v11, "kCBMsgArgRFCOMMChannelID", a4);
  sub_1000173FC(a1, 57, v11, 1);
}

void sub_100282DB0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100282DD4(uint64_t a1, void *a2, int a3, unsigned int a4, int a5)
{
}

char *sub_100282DDC(uint64_t a1, int a2)
{
  return off_1009A06C8[a2];
}

void sub_100282E04(id a1)
{
}

void sub_100282E48()
{
}

void sub_100282E6C(id a1)
{
}

void sub_100282EB0()
{
}

void sub_100282ED4(id a1)
{
}

void sub_100282F18()
{
}

void sub_100282F3C(id a1)
{
}

void sub_100282F80()
{
}

void sub_100282FA4(id a1)
{
}

void sub_100282FE8()
{
}

void sub_10028300C(id a1)
{
}

void sub_100283050()
{
}

void sub_100283074(id a1)
{
}

void sub_1002830B8()
{
}

void sub_1002830DC(id a1)
{
}

void sub_100283120()
{
}

void sub_100283144(id a1)
{
}

void sub_100283188()
{
}

void sub_1002831AC(id a1)
{
}

void sub_1002831F0()
{
}

void sub_100283214(id a1)
{
}

void sub_100283258(id a1)
{
}

void sub_10028329C()
{
}

void sub_1002832C0(id a1)
{
}

void sub_100283304()
{
}

uint64_t sub_100283328(uint64_t a1)
{
  uint64_t v2 = (void *)sub_1004C9B7C(a1, "AACPService", 0x80000);
  *uint64_t v2 = off_1009A0E70;
  sub_100052DA8(v2 + 41);
  *(_OWORD *)(a1 + 400) = 0u;
  *(_OWORD *)(a1 + 416) = 0u;
  if (qword_1009F80A0 != -1) {
    dispatch_once(&qword_1009F80A0, &stru_1009A0F80);
  }
  uint64_t v3 = off_1009F8098;
  *(void *)(a1 + 424) = off_1009F8098;
  sub_1004C9E90(a1, (uint64_t)v3);
  return a1;
}

void sub_1002833D4(_Unwind_Exception *a1)
{
  unint64_t v4 = v3;
  id v6 = *v4;
  if (*v4)
  {
    *(void *)(v1 + 408) = v6;
    operator delete(v6);
  }
  sub_100052DA4(v2);
  sub_1004C9C80(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100283410(void *a1)
{
  *a1 = off_1009A0E70;
  uint64_t v2 = (void *)a1[50];
  if (v2)
  {
    a1[51] = v2;
    operator delete(v2);
  }
  sub_100052DA4(a1 + 41);

  return sub_1004C9C80((uint64_t)a1);
}

void sub_10028347C(void *a1)
{
  sub_100283410(a1);

  operator delete();
}

uint64_t sub_1002834B4(uint64_t a1)
{
  uint64_t v2 = qword_100A19E38;
  if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)unint64_t v4 = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "AACPService start", v4, 2u);
  }
  return sub_1004CA044(a1);
}

uint64_t sub_100283528(uint64_t a1)
{
  uint64_t v2 = qword_100A19E38;
  if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)unint64_t v4 = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "AACPService stop", v4, 2u);
  }
  return sub_1004CA358(a1);
}

uint64_t sub_10028359C(uint64_t a1, uint64_t a2)
{
  long long v8 = unk_1009A0F60;
  if (sub_10047B300(a2))
  {
    if (sub_100478F30(a2, &v8, 4u)) {
      int v4 = 4;
    }
    else {
      int v4 = 1;
    }
  }
  else
  {
    int v4 = 0;
  }
  unsigned int v5 = *(_DWORD *)(a1 + 32);
  uint64_t v9 = 0;
  sub_100026C30((uint64_t)&v9);
  *(void *)&long long v7 = (int)v9;
  *((void *)&v7 + 1) = SWORD2(v9);
  return sub_100477F4C(a2, v5, v4, &v7, 0);
}

BOOL sub_100283644(uint64_t a1, uint64_t a2, unsigned char *a3)
{
  long long v6 = unk_1009A0F70;
  *a3 = 0;
  BOOL result = sub_10047B300(a2);
  if (result)
  {
    BOOL result = sub_100478F30(a2, &v6, 4u);
    if (result) {
      *a3 = 1;
    }
  }
  return result;
}

void sub_1002836AC(void *a1, uint64_t a2)
{
  int v4 = (uint64_t *)a1[50];
  unsigned int v5 = (uint64_t *)a1[51];
  if (v4 == v5)
  {
LABEL_5:
    unint64_t v7 = a1[52];
    if ((unint64_t)v5 >= v7)
    {
      uint64_t v9 = v5 - v4;
      if ((unint64_t)(v9 + 1) >> 61) {
        abort();
      }
      uint64_t v10 = v7 - (void)v4;
      uint64_t v11 = v10 >> 2;
      if (v10 >> 2 <= (unint64_t)(v9 + 1)) {
        uint64_t v11 = v9 + 1;
      }
      if ((unint64_t)v10 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v12 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v12 = v11;
      }
      if (v12) {
        uint64_t v13 = (char *)sub_1000405F8((uint64_t)(a1 + 52), v12);
      }
      else {
        uint64_t v13 = 0;
      }
      uint64_t v15 = (uint64_t *)&v13[8 * v9];
      int v16 = &v13[8 * v12];
      uint64_t *v15 = a2;
      long long v8 = v15 + 1;
      id v18 = (char *)a1[50];
      xpc_object_t v17 = (char *)a1[51];
      if (v17 != v18)
      {
        do
        {
          uint64_t v19 = *((void *)v17 - 1);
          v17 -= 8;
          *--uint64_t v15 = v19;
        }
        while (v17 != v18);
        xpc_object_t v17 = (char *)a1[50];
      }
      a1[50] = v15;
      a1[51] = v8;
      a1[52] = v16;
      if (v17) {
        operator delete(v17);
      }
    }
    else
    {
      *unsigned int v5 = a2;
      long long v8 = v5 + 1;
    }
    a1[51] = v8;
  }
  else
  {
    long long v6 = (void *)a1[50];
    while (*v6 != a2)
    {
      if (++v6 == v5) {
        goto LABEL_5;
      }
    }
    uint64_t v14 = qword_100A19E38;
    if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_ERROR)) {
      sub_10074DA14(a2, v14);
    }
  }
}

BOOL sub_1002837D0(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a1 + 400);
  uint64_t v2 = *(void *)(a1 + 408);
  if (v3 == v2) {
    return 0;
  }
  uint64_t v4 = v3 + 8;
  do
  {
    uint64_t v5 = *(void *)(v4 - 8);
    BOOL result = v5 == a2;
    BOOL v7 = v5 == a2 || v4 == v2;
    v4 += 8;
  }
  while (!v7);
  return result;
}

void *sub_100283804(void *result, uint64_t a2)
{
  uint64_t v3 = (char *)result[50];
  uint64_t v2 = (char *)result[51];
  if (v3 != v2)
  {
    uint64_t v4 = result;
    uint64_t v5 = 0;
    while (*(void *)&v3[v5] != a2)
    {
      v5 += 8;
      if (&v3[v5] == v2) {
        return result;
      }
    }
    long long v6 = &v3[v5];
    BOOL v7 = &v3[v5 + 8];
    int64_t v8 = v2 - v7;
    if (v2 != v7) {
      BOOL result = memmove(&v3[v5], v7, v2 - v7);
    }
    v4[51] = &v6[v8];
  }
  return result;
}

uint64_t sub_100283880()
{
  return 1;
}

uint64_t sub_100283888()
{
  return 1;
}

uint64_t sub_100283890()
{
  return 0;
}

char *sub_100283898@<X0>(char *result@<X0>, uint64_t a2@<X8>)
{
  if (result[31] < 0) {
    return (char *)sub_10003B098((unsigned char *)a2, *((void **)result + 1), *((void *)result + 2));
  }
  *(_OWORD *)a2 = *(_OWORD *)(result + 8);
  *(void *)(a2 + 16) = *((void *)result + 3);
  return result;
}

void sub_1002838C4(uint64_t a1, uint64_t a2, _WORD *a3)
{
  *a3 = 0;
}

uint64_t sub_1002838CC()
{
  return 1;
}

void sub_1002838D8(id a1)
{
}

void sub_10028391C()
{
}

uint64_t sub_100283940(uint64_t a1)
{
  return a1;
}

uint64_t sub_10028396C(uint64_t a1)
{
  uint64_t v2 = (void *)sub_100283C88(a1, 24);
  uint64_t v3 = v2 + 32;
  uint64_t v4 = (uint64_t)(v2 + 36);
  *uint64_t v2 = off_1009A0FB0;
  v2[32] = &off_1009A1088;
  v2[33] = off_1009A10A0;
  v2[34] = off_1009A10C8;
  v2[35] = &off_1009A10F8;
  v2[36] = off_1009A1110;
  v2[43] = 0;
  v2[44] = 0;
  v2[42] = 0;
  v2[38] = 0;
  v2[39] = 0;
  v2[37] = off_1009A1140;
  sub_100052DA8(v2 + 45);
  *(_WORD *)(a1 + 428) = 0;
  *(_DWORD *)(a1 + 424) = 0;
  *(void *)(a1 + 440) = @"XZ";
  *(_OWORD *)(a1 + 448) = 0u;
  *(_OWORD *)(a1 + 464) = 0u;
  *(_DWORD *)(a1 + 480) = 1065353216;
  *(void *)(a1 + 488) = 0;
  *(void *)(a1 + 496) = 0;
  *(void *)(a1 + 504) = -1;
  *(void *)(a1 + 512) = -1;
  *(void *)(a1 + 552) = 0;
  *(void *)(a1 + 544) = 0;
  *(void *)(a1 + 536) = a1 + 544;
  sub_1002AFEE0((void *)(a1 + 560));
  sub_100052DA8(a1 + 648);
  *(unsigned char *)(a1 + 328) = 0;
  if (qword_1009F8070 != -1) {
    dispatch_once(&qword_1009F8070, &stru_1009A1D70);
  }
  sub_10026B36C((uint64_t)off_1009F8068 + 64, v4);
  uint64_t v5 = sub_100373254();
  (*(void (**)(uint64_t, void *))(*(void *)v5 + 32))(v5, v3);
  uint64_t v6 = sub_1004AFA9C();
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 3221225472;
  _DWORD v8[2] = sub_100283D28;
  void v8[3] = &unk_100997528;
  void v8[4] = a1;
  sub_100013018(v6, v8);
  *(unsigned char *)(a1 + 520) = 0;
  *(void *)(a1 + 424) = 0;
  *(unsigned char *)(a1 + 432) = 0;
  *(void *)(a1 + 528) = 255;
  return a1;
}

void sub_100283BDC(_Unwind_Exception *a1)
{
  sub_100283D8C(v3);
  sub_1000486F0(v1 + 536, *v4);
  uint64_t v6 = *(void *)(v1 + 488);
  *(void *)(v1 + 488) = 0;
  if (v6) {
    (*(void (**)(uint64_t))(*(void *)v6 + 64))(v6);
  }
  sub_1002B38CC(v1 + 448);

  sub_100052DA4(v2);
  BOOL v7 = *(void **)(v1 + 336);
  if (v7)
  {
    *(void *)(v1 + 344) = v7;
    operator delete(v7);
  }
  sub_100283DC8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100283C88(uint64_t a1, int a2)
{
  *(void *)a1 = off_1009A1538;
  sub_100052DA8(a1 + 16);
  *(_DWORD *)(a1 + 80) = 0;
  sub_100052DA8(a1 + 88);
  *(void *)(a1 + 240) = 0;
  *(void *)(a1 + 232) = 0;
  *(_OWORD *)(a1 + 152) = 0u;
  *(_OWORD *)(a1 + 168) = 0u;
  *(_OWORD *)(a1 + ++*(_DWORD *)(result + 184) = 0u;
  *(_OWORD *)(a1 + 200) = 0u;
  *(void *)(a1 + 216) = 0;
  *(void *)(a1 + 224) = a1 + 232;
  *(_DWORD *)(a1 + 248) = a2;
  return a1;
}

void sub_100283D14(_Unwind_Exception *a1)
{
  sub_100052DA4(v1);
  _Unwind_Resume(a1);
}

void sub_100283D28(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  if (qword_1009FB120 != -1) {
    dispatch_once(&qword_1009FB120, &stru_1009A1D90);
  }
  uint64_t v2 = off_1009FB118;

  sub_10062ECC4((uint64_t)v2, v1 + 296);
}

uint64_t sub_100283D8C(uint64_t a1)
{
  sub_100052DA4(a1 + 24);
  uint64_t v2 = *(void **)a1;
  if (*(void *)a1)
  {
    *(void *)(a1 + 8) = v2;
    operator delete(v2);
  }
  return a1;
}

uint64_t sub_100283DC8(uint64_t a1)
{
  *(void *)a1 = off_1009A1538;
  sub_1000486F0(a1 + 224, *(void **)(a1 + 232));
  uint64_t v2 = *(void **)(a1 + 200);
  if (v2)
  {
    *(void *)(a1 + 208) = v2;
    operator delete(v2);
  }
  uint64_t v3 = *(void **)(a1 + 176);
  if (v3)
  {
    *(void *)(a1 + ++*(_DWORD *)(result + 184) = v3;
    operator delete(v3);
  }
  uint64_t v4 = *(void **)(a1 + 152);
  if (v4)
  {
    *(void *)(a1 + 160) = v4;
    operator delete(v4);
  }
  sub_100052DA4(a1 + 88);
  sub_100052DA4(a1 + 16);
  return a1;
}

uint64_t sub_100283E54(uint64_t a1)
{
  if (qword_1009F8158 != -1) {
    dispatch_once(&qword_1009F8158, &stru_1009A1DB0);
  }
  if (sub_1004FA58C((uint64_t)off_1009F8150))
  {
    uint64_t v2 = (void *)MGCopyAnswer();
    uint64_t v3 = [v2 componentsSeparatedByString:@"."];
    uint64_t v4 = [v3 objectAtIndexedSubscript:0];
    uint64_t v5 = +[NSString stringWithFormat:@"%@", v4];

    if ([v5 isEqualToString:off_1009FB090])
    {
      uint64_t v20 = 0;
      uint64_t v21 = 0;
      uint64_t v22 = 0;
      if (qword_1009F8768 != -1) {
        dispatch_once(&qword_1009F8768, &stru_1009A1DD0);
      }
      sub_10060C508((uint64_t)off_1009F8760, &v20);
      uint64_t v6 = v20;
      BOOL v7 = v21;
      if (v20 != v21)
      {
        do
        {
          uint64_t v8 = *v6;
          if (sub_100478B2C(*v6, 14))
          {
            uint64_t v9 = qword_100A19E38;
            if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
            {
              sub_100474E18(v8, __p);
              uint64_t v10 = v19 >= 0 ? __p : (void **)__p[0];
              *(_DWORD *)long long buf = 136446210;
              id v24 = v10;
              _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "Migrating double tap settings for device %{public}s", buf, 0xCu);
              if (v19 < 0) {
                operator delete(__p[0]);
              }
            }
            int v11 = sub_10047C698(v8);
            sub_10047C6E0(v8, v11 | (v11 << 8));
          }
          ++v6;
        }
        while (v6 != v7);
        uint64_t v6 = v20;
      }
      if (v6)
      {
        uint64_t v21 = v6;
        operator delete(v6);
      }
    }
  }
  uint64_t v12 = sub_10003FB34();
  if ((sub_100350CA0(v12, 2u) & 1) == 0) {
    *(void *)(a1 + 528) &= ~2uLL;
  }
  uint64_t v13 = sub_10003FB34();
  if ((sub_100350CA0(v13, 3u) & 1) == 0) {
    *(void *)(a1 + 528) &= ~4uLL;
  }
  uint64_t v14 = sub_10003FB34();
  if ((sub_100350CA0(v14, 0) & 1) == 0) {
    *(void *)(a1 + 528) &= ~8uLL;
  }
  uint64_t v15 = sub_10003FB34();
  if ((sub_100350CA0(v15, 5u) & 1) == 0) {
    *(void *)(a1 + 528) &= ~0x10uLL;
  }
  uint64_t v16 = sub_10003FB34();
  if ((sub_100350CA0(v16, 6u) & 1) == 0) {
    *(void *)(a1 + 528) &= ~0x20uLL;
  }
  sub_10003FB34();
  if (sub_100351204()) {
    *(void *)(a1 + 528) |= 0x100uLL;
  }
  if (_os_feature_enabled_impl() && _os_feature_enabled_impl()) {
    *(void *)(a1 + 528) |= 0x200uLL;
  }
  LOBYTE(v20) = 0;
  sub_10001B8E0(&v20);
  sub_1000D7600((uint64_t)off_1009A1170);
  sub_10001B8AC(&v20);
  return 0;
}

void sub_1002841B0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19)
{
  if (__p) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

uint64_t sub_100284230(uint64_t result)
{
  *(unsigned char *)(result + 328) = 1;
  return result;
}

uint64_t sub_10028423C(uint64_t result)
{
  *(unsigned char *)(result + 40) = 1;
  return result;
}

uint64_t sub_100284248(uint64_t result)
{
  *(unsigned char *)(result + 328) = 0;
  return result;
}

uint64_t sub_100284250(uint64_t result)
{
  *(unsigned char *)(result + 40) = 0;
  return result;
}

void sub_100284258(uint64_t a1, void *a2, int a3, int a4, int a5)
{
  id v10 = a2;
  int v11 = qword_100A19E38;
  if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 138544130;
    *(void *)__int16 v28 = v10;
    *(_WORD *)&v28[8] = 1024;
    *(_DWORD *)&v28[10] = a3;
    __int16 v29 = 1024;
    int v30 = a4;
    __int16 v31 = 1024;
    int v32 = a5;
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "AACPClient::locationUpdate - country: %{public}@, CC: %u, LEFlag: %u, HDRFlag: %u", buf, 0x1Eu);
  }
  objc_storeStrong((id *)(a1 + 440), a2);
  uint64_t v12 = *(uint64_t **)(a1 + 336);
  for (unint64_t i = *(uint64_t **)(a1 + 344); v12 != i; ++v12)
  {
    uint64_t v14 = *v12;
    if (*v12)
    {
      unsigned int v15 = *(_DWORD *)(v14 + 80) - 8212;
      BOOL v16 = v15 > 0x10;
      int v17 = (1 << v15) & 0x116A1;
      if (!v16 && v17 != 0)
      {
        uint64_t v19 = *(void *)v14;
        if (*(void *)v14)
        {
          if ((*(unsigned int (**)(void))(**(void **)(v14 + 768) + 176))(*(void *)(v14 + 768)) == 1)
          {
            uint64_t v26 = -256;
            uint64_t v20 = sub_100373254();
            (*(void (**)(uint64_t, void, uint64_t *, void))(*(void *)v20 + 16))(v20, *(void *)(a1 + 440), &v26, *(unsigned int *)(*v12 + 80));
            int v21 = sub_100284530(a1, v19, (uint64_t)&v26);
            if (v21)
            {
              uint64_t v22 = qword_100A19E38;
              if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_ERROR))
              {
                sub_100474E18(v19, __p);
                uint64_t v23 = __p;
                if (v25 < 0) {
                  uint64_t v23 = (void **)__p[0];
                }
                *(_DWORD *)long long buf = 67109634;
                *(_DWORD *)__int16 v28 = a3;
                *(_WORD *)&v28[4] = 2082;
                *(void *)&v28[6] = v23;
                __int16 v29 = 1024;
                int v30 = v21;
                _os_log_error_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_ERROR, "Failed to set country code (%u) for device %{public}s with result %u", buf, 0x18u);
                if (v25 < 0) {
                  operator delete(__p[0]);
                }
              }
            }
          }
        }
      }
    }
  }
}

void sub_100284508(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13)
{
  _Unwind_Resume(a1);
}

uint64_t sub_100284530(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v10[0] = 0;
  v10[1] = 0;
  sub_10003AED0((uint64_t)v10, a1 + 360);
  if (a2)
  {
    for (uint64_t i = *(void *)(a1 + 336); i != *(void *)(a1 + 344); i += 8)
    {
      if (**(void **)i == a2)
      {
        uint64_t v7 = (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(*(void *)i + 768) + 104))(*(void *)(*(void *)i + 768), a2, a3);
        goto LABEL_9;
      }
    }
  }
  if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_ERROR))
  {
    sub_100474E18(a2, v9);
    sub_10074DAD4();
  }
  uint64_t v7 = 312;
LABEL_9:
  sub_10003AFB4((uint64_t)v10);
  return v7;
}

void sub_10028464C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  sub_10003AFB4((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_10028466C(uint64_t a1, void *a2, int a3, int a4, int a5)
{
}

uint64_t sub_100284674(uint64_t a1)
{
  uint64_t v2 = qword_100A19E38;
  if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v4 = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Register AACP Profile", v4, 2u);
  }
  if (qword_1009FB130 != -1) {
    dispatch_once(&qword_1009FB130, &stru_1009A1DF0);
  }
  sub_1002AFF30(qword_1009FB128 + 120, a1 + 280);
  return 0;
}

uint64_t sub_100284720(uint64_t a1)
{
  uint64_t v2 = qword_100A19E38;
  if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v4 = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Deregister AACP profile", v4, 2u);
  }
  if (qword_1009FB130 != -1) {
    dispatch_once(&qword_1009FB130, &stru_1009A1DF0);
  }
  sub_100052718(qword_1009FB128 + 120, a1 + 280);
  return 0;
}

uint64_t sub_1002847CC(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = qword_100A19E38;
  if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
  {
    sub_100474E18(a2, __p);
    uint64_t v5 = v11 >= 0 ? __p : (void **)__p[0];
    *(_DWORD *)long long buf = 136446210;
    *(void *)&uint8_t buf[4] = v5;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "disconnecting %{public}s", buf, 0xCu);
    if (v11 < 0) {
      operator delete(__p[0]);
    }
  }
  *(_OWORD *)long long buf = 0uLL;
  sub_10003AED0((uint64_t)buf, a1 + 360);
  if (a2)
  {
    for (uint64_t i = *(void **)(a1 + 336); i != *(void **)(a1 + 344); ++i)
    {
      uint64_t v7 = (void *)*i;
      if (*(void *)*i == a2)
      {
        sub_1002B3CA0((uint64_t **)(a1 + 536), a2 + 128);
        uint64_t v8 = (*(uint64_t (**)(void, uint64_t))(*(void *)v7[96] + 136))(v7[96], a2);
        goto LABEL_15;
      }
    }
  }
  if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_ERROR))
  {
    sub_100474E18(a2, __p);
    sub_10074DAD4();
  }
  uint64_t v8 = 312;
LABEL_15:
  sub_10003AFB4((uint64_t)buf);
  return v8;
}

void sub_10028496C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  sub_10003AFB4((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_10028498C(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = qword_100A19E38;
  if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
  {
    sub_100474E18(a2, __p);
    uint64_t v4 = v10 >= 0 ? __p : (void **)__p[0];
    *(_DWORD *)long long buf = 136446210;
    uint64_t v12 = v4;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "connecting to %{public}s", buf, 0xCu);
    if (v10 < 0) {
      operator delete(__p[0]);
    }
  }
  char v8 = 0;
  sub_10001B8E0(&v8);
  uint64_t v5 = sub_1000D76C0(a2 + 128, (uint64_t)off_1009A1170);
  sub_10001B910(&v8);
  if (v5 && os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_ERROR))
  {
    sub_100474E18(a2, __p);
    sub_10074DB28();
  }
  if (qword_1009F8070 != -1) {
    dispatch_once(&qword_1009F8070, &stru_1009A1D70);
  }
  uint64_t v6 = sub_1004E2340((uint64_t)off_1009F8068, v5, 10000);
  sub_10001B8AC(&v8);
  return v6;
}

void sub_100284B14(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, int a9, __int16 a10, char a11, char a12)
{
}

uint64_t sub_100284B34(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v10[0] = 0;
  v10[1] = 0;
  sub_10003AED0((uint64_t)v10, a1 + 360);
  if (a2)
  {
    for (uint64_t i = *(void *)(a1 + 336); i != *(void *)(a1 + 344); i += 8)
    {
      if (**(void **)i == a2)
      {
        uint64_t v7 = (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(*(void *)i + 768) + 88))(*(void *)(*(void *)i + 768), a2, a3);
        goto LABEL_9;
      }
    }
  }
  if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_ERROR))
  {
    sub_100474E18(a2, v9);
    sub_10074DAD4();
  }
  uint64_t v7 = 312;
LABEL_9:
  sub_10003AFB4((uint64_t)v10);
  return v7;
}

void sub_100284C50(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  sub_10003AFB4((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_100284C70(uint64_t a1, uint64_t a2)
{
  v8[0] = 0;
  v8[1] = 0;
  sub_10003AED0((uint64_t)v8, a1 + 360);
  if (a2)
  {
    for (uint64_t i = *(void *)(a1 + 336); i != *(void *)(a1 + 344); i += 8)
    {
      if (**(void **)i == a2)
      {
        uint64_t v5 = (*(uint64_t (**)(void, uint64_t))(**(void **)(*(void *)i + 768) + 56))(*(void *)(*(void *)i + 768), a2);
        goto LABEL_9;
      }
    }
  }
  if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_ERROR))
  {
    sub_100474E18(a2, v7);
    sub_10074DAD4();
  }
  uint64_t v5 = 312;
LABEL_9:
  sub_10003AFB4((uint64_t)v8);
  return v5;
}

void sub_100284D7C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  sub_10003AFB4((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_100284D9C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  v14[0] = 0;
  v14[1] = 0;
  sub_10003AED0((uint64_t)v14, a1 + 360);
  if (a2)
  {
    for (uint64_t i = *(void *)(a1 + 336); i != *(void *)(a1 + 344); i += 8)
    {
      if (**(void **)i == a2)
      {
        uint64_t v11 = (*(uint64_t (**)(void, uint64_t, uint64_t, uint64_t, uint64_t))(**(void **)(*(void *)i + 768)
                                                                                    + 64))(*(void *)(*(void *)i + 768), a2, a3, a4, a5);
        goto LABEL_9;
      }
    }
  }
  if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_ERROR))
  {
    sub_100474E18(a2, v13);
    sub_10074DAD4();
  }
  uint64_t v11 = 312;
LABEL_9:
  sub_10003AFB4((uint64_t)v14);
  return v11;
}

void sub_100284ED0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  sub_10003AFB4((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_100284EF0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v10[0] = 0;
  v10[1] = 0;
  sub_10003AED0((uint64_t)v10, a1 + 360);
  if (a2)
  {
    for (uint64_t i = *(void *)(a1 + 336); i != *(void *)(a1 + 344); i += 8)
    {
      if (**(void **)i == a2)
      {
        uint64_t v7 = (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(*(void *)i + 768) + 72))(*(void *)(*(void *)i + 768), a2, a3);
        goto LABEL_9;
      }
    }
  }
  if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_ERROR))
  {
    sub_100474E18(a2, v9);
    sub_10074DAD4();
  }
  uint64_t v7 = 312;
LABEL_9:
  sub_10003AFB4((uint64_t)v10);
  return v7;
}

void sub_10028500C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  sub_10003AFB4((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_10028502C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  v14[0] = 0;
  v14[1] = 0;
  sub_10003AED0((uint64_t)v14, a1 + 360);
  if (a2)
  {
    for (uint64_t i = *(void *)(a1 + 336); i != *(void *)(a1 + 344); i += 8)
    {
      if (**(void **)i == a2)
      {
        uint64_t v11 = (*(uint64_t (**)(void, uint64_t, uint64_t, uint64_t, uint64_t))(**(void **)(*(void *)i + 768)
                                                                                    + 16))(*(void *)(*(void *)i + 768), a2, a3, a4, a5);
        goto LABEL_9;
      }
    }
  }
  if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_ERROR))
  {
    sub_100474E18(a2, v13);
    sub_10074DAD4();
  }
  uint64_t v11 = 312;
LABEL_9:
  sub_10003AFB4((uint64_t)v14);
  return v11;
}

void sub_100285160(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  sub_10003AFB4((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_100285180(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  char v10 = qword_100A19E38;
  if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
  {
    sub_100474E18(a2, __p);
    uint64_t v11 = v16 >= 0 ? __p : (void **)__p[0];
    *(_DWORD *)long long buf = 136446210;
    *(void *)&uint8_t buf[4] = v11;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "send device info message to %{public}s", buf, 0xCu);
    if (v16 < 0) {
      operator delete(__p[0]);
    }
  }
  *(_OWORD *)long long buf = 0uLL;
  sub_10003AED0((uint64_t)buf, a1 + 360);
  if (a2)
  {
    for (uint64_t i = *(void *)(a1 + 336); i != *(void *)(a1 + 344); i += 8)
    {
      if (**(void **)i == a2)
      {
        uint64_t v13 = (*(uint64_t (**)(void, uint64_t, uint64_t, uint64_t, uint64_t))(**(void **)(*(void *)i + 768)
                                                                                    + 144))(*(void *)(*(void *)i + 768), a2, a3, a4, a5);
        goto LABEL_15;
      }
    }
  }
  if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_ERROR))
  {
    sub_100474E18(a2, __p);
    sub_10074DAD4();
  }
  uint64_t v13 = 312;
LABEL_15:
  sub_10003AFB4((uint64_t)buf);
  return v13;
}

void sub_100285334(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  sub_10003AFB4((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_100285354(uint64_t a1, uint64_t a2, unsigned int a3, const void *a4)
{
  if (!*(unsigned char *)(a1 + 328)) {
    return 111;
  }
  char v8 = qword_100A19E38;
  if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
  {
    sub_100474E18(a2, __p);
    uint64_t v9 = v15 >= 0 ? __p : (void **)__p[0];
    *(_DWORD *)long long buf = 136446210;
    int v17 = v9;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "send setRemoteDeviceName to %{public}s", buf, 0xCu);
    if (v15 < 0) {
      operator delete(__p[0]);
    }
  }
  LOBYTE(__p[0]) = 0;
  sub_10001B8E0(__p);
  if (sub_1000D8CA0((unsigned __int8 *)(a2 + 128), 1, a3, a4)
    && os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_ERROR))
  {
    sub_10074DC00();
  }
  uint64_t v10 = sub_1000D81FC((unsigned __int8 *)(a2 + 128), 255);
  sub_10001B910(__p);
  if (v10 && os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_ERROR)) {
    sub_10074DB98();
  }
  uint64_t v11 = sub_100035F54();
  if ((*(unsigned int (**)(uint64_t))(*(void *)v11 + 328))(v11)) {
    sub_10028558C(a1, a2);
  }
  if (qword_1009F8070 != -1) {
    dispatch_once(&qword_1009F8070, &stru_1009A1D70);
  }
  uint64_t v12 = sub_1004E2340((uint64_t)off_1009F8068, v10, 10000);
  sub_10001B8AC(__p);
  return v12;
}

void sub_100285570(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
}

uint64_t sub_10028558C(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = sub_100035F54();
  if (!(*(unsigned int (**)(uint64_t))(*(void *)v4 + 328))(v4)) {
    return 17;
  }
  id v5 = objc_alloc_init((Class)NSMutableDictionary);
  if (sub_10028B72C(a1, a2))
  {
    uint64_t v6 = +[NSNumber numberWithInt:sub_10048741C(a2)];
    [v5 setObject:v6 forKey:@"kCfgMicSide"];

    uint64_t v7 = +[NSNumber numberWithBool:sub_100487464(a2)];
    [v5 setObject:v7 forKey:@"kCfgInEarMode"];

    char v8 = +[NSNumber numberWithInt:sub_10047C698(a2)];
    [v5 setObject:v8 forKey:@"kCfgDoubleTap"];

    if ((sub_100478B2C(a2, 29) & 1) != 0 || sub_100487DD4(a2, 128))
    {
      uint64_t v9 = +[NSNumber numberWithInt:sub_10048775C(a2)];
      [v5 setObject:v9 forKey:@"kCfgDoubleClickInt"];
    }
    if (sub_100478B2C(a2, 30))
    {
      uint64_t v10 = +[NSNumber numberWithInt:sub_100487714(a2)];
      [v5 setObject:v10 forKey:@"kCfgClickHold"];
    }
    if ((sub_100478B2C(a2, 30) & 1) != 0 || sub_100487DD4(a2, 128))
    {
      uint64_t v11 = +[NSNumber numberWithInt:sub_1004877A4(a2)];
      [v5 setObject:v11 forKey:@"kCfgClickHoldInt"];
    }
    if (sub_100478B2C(a2, 28))
    {
      uint64_t v12 = +[NSNumber numberWithInt:sub_1004875AC(a2)];
      [v5 setObject:v12 forKey:@"kCfgListenModeCfgs"];
    }
    if (sub_100478B2C(a2, 16) && sub_100478B2C(a2, 1))
    {
      uint64_t v13 = +[NSNumber numberWithInt:sub_1004877EC(a2)];
      [v5 setObject:v13 forKey:@"kCfgOneBudANCMode"];
    }
    else
    {
      if (!sub_100478B2C(a2, 16) || !sub_100478B2C(a2, 15))
      {
LABEL_21:
        uint64_t v15 = sub_100373068();
        sub_1004A82EC((unsigned __int8 *)(a2 + 128), v19);
        sub_100475EE0(a2, (uint64_t)__p);
        if (v18 >= 0) {
          char v16 = __p;
        }
        else {
          char v16 = (void **)__p[0];
        }
        (*(void (**)(uint64_t, void **, id, void **))(*(void *)v15 + 120))(v15, v19, v5, v16);
        if (v18 < 0) {
          operator delete(__p[0]);
        }
        if (v20 < 0) {
          operator delete(v19[0]);
        }
        goto LABEL_28;
      }
      uint64_t v13 = +[NSNumber numberWithInt:1];
      [v5 setObject:v13 forKey:@"kCfgOneBudANCMode"];
    }

    goto LABEL_21;
  }
LABEL_28:

  return 0;
}

void sub_100285938(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  _Unwind_Resume(a1);
}

uint64_t sub_1002859A4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unsigned int a5)
{
  if (*(unsigned char *)(a1 + 328))
  {
    if (a5)
    {
      BOOL v10 = 0;
      switch((int)a3)
      {
        case 1:
          uint64_t v11 = qword_100A19E38;
          if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)long long buf = 67109120;
            *(_DWORD *)&uint8_t buf[4] = a4;
            _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "Set Mic Mode to value 0x%08X", buf, 8u);
          }
          uint64_t v12 = sub_100035F54();
          if (((*(uint64_t (**)(uint64_t))(*(void *)v12 + 328))(v12) & 1) == 0)
          {
            uint64_t v13 = sub_100035F54();
            if (!(*(unsigned int (**)(uint64_t))(*(void *)v13 + 384))(v13)) {
              goto LABEL_127;
            }
          }
          int v14 = 0;
          int v15 = sub_10048741C(a2) != a4;
          BOOL v10 = v15;
          goto LABEL_167;
        case 5:
          uint64_t v23 = qword_100A19E38;
          if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)long long buf = 67109120;
            *(_DWORD *)&uint8_t buf[4] = a4;
            _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "Set Button Send Mode: %d", buf, 8u);
          }
          if (a4 == 1 && !*(void *)(a1 + 488)) {
            sub_100287074();
          }
          goto LABEL_127;
        case 13:
          v80[0] = 0;
          v80[1] = 0;
          sub_10003AED0((uint64_t)v80, a1 + 360);
          if (!a2) {
            goto LABEL_109;
          }
          id v24 = *(void ***)(a1 + 336);
          while (2)
          {
            if (v24 == *(void ***)(a1 + 344))
            {
LABEL_109:
              if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_ERROR))
              {
                sub_100474E18(a2, buf);
                sub_10074DAD4();
              }
              uint64_t v16 = 312;
              goto LABEL_112;
            }
            char v25 = *v24;
            if (**v24 != a2)
            {
              ++v24;
              continue;
            }
            break;
          }
          if (sub_1004877EC(a2) == 2 && (a4 == 4 || a4 == 2))
          {
            if (sub_100478B2C(a2, 1))
            {
              if (sub_100487464(a2))
              {
                uint64_t v74 = *((unsigned __int8 *)v25 + 8);
                if (*((unsigned char *)v25 + 8) || *((unsigned char *)v25 + 9))
                {
                  long long v75 = qword_100A19E38;
                  if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_ERROR)) {
                    sub_10074DD48(v74, (uint64_t)v25, v75);
                  }
                  uint64_t v16 = 11;
LABEL_112:
                  uint64_t v51 = v80;
                  goto LABEL_144;
                }
              }
            }
          }
          uint64_t v76 = qword_100A19E38;
          if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)long long buf = 67109120;
            *(_DWORD *)&uint8_t buf[4] = a4;
            _os_log_impl((void *)&_mh_execute_header, v76, OS_LOG_TYPE_DEFAULT, "Set ListeningMode device setting: %d", buf, 8u);
          }
          sub_100485628(a2, a4);
          sub_10003AFB4((uint64_t)v80);
          BOOL v10 = 0;
          int v15 = 1;
          int v14 = 1;
LABEL_167:
          BOOL v55 = a5 != 3;
          if (a5 != 3 && v15)
          {
            sub_10028558C(a1, a2);
            BOOL v55 = 1;
            int v15 = 1;
          }
LABEL_129:
          if ((a5 & 0xFFFFFFFE) == 2 && v10)
          {
            uint64_t v56 = sub_1004AF8EC();
            v83[0] = _NSConcreteStackBlock;
            v83[1] = 3221225472;
            v83[2] = sub_100287210;
            v83[3] = &unk_100997528;
            v83[4] = a2;
            sub_100013018(v56, v83);
          }
          uint64_t v57 = sub_100035F54();
          if ((v14 & v55 & (*(unsigned int (**)(uint64_t))(*(void *)v57 + 344))(v57)) == 1) {
            sub_10028558C(a1, a2);
          }
          v82[0] = 0;
          v82[1] = 0;
          sub_10003AED0((uint64_t)v82, a1 + 360);
          if (a2)
          {
            for (uint64_t i = *(void *)(a1 + 336); i != *(void *)(a1 + 344); i += 8)
            {
              if (**(void **)i == a2)
              {
                uint64_t v16 = (*(uint64_t (**)(void, uint64_t, uint64_t, uint64_t))(**(void **)(*(void *)i + 768)
                                                                                   + 24))(*(void *)(*(void *)i + 768), a2, a3, a4);
                __int16 v59 = qword_100A19E38;
                if (v16) {
                  goto LABEL_142;
                }
                BOOL v62 = os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT);
                if (v62)
                {
                  uint8_t v63 = sub_100287278(v62, a3);
                  sub_1002872A4(a1, a3, a4, v80);
                  int v64 = v81;
                  uint8_t v65 = (void **)v80[0];
                  sub_100474E18(a2, v84);
                  long long v66 = v80;
                  if (v64 < 0) {
                    long long v66 = v65;
                  }
                  long long v67 = v84;
                  if (v85 < 0) {
                    long long v67 = (void **)v84[0];
                  }
                  if (a5 > 4) {
                    long long v68 = "Unknown";
                  }
                  else {
                    long long v68 = off_1009A21F0[a5 - 1];
                  }
                  *(_DWORD *)long long buf = 136448002;
                  *(void *)&uint8_t buf[4] = v63;
                  *(_WORD *)&unsigned char buf[12] = 1024;
                  *(_DWORD *)uint64_t v87 = a3;
                  *(_WORD *)&v87[4] = 2082;
                  uint64_t v88 = v66;
                  *(_WORD *)uint64_t v89 = 2082;
                  *(void *)&v89[2] = v67;
                  __int16 v90 = 2082;
                  uint64_t v91 = v68;
                  __int16 v92 = 1024;
                  int v93 = v14;
                  __int16 v94 = 1024;
                  int v95 = v15;
                  __int16 v96 = 1024;
                  BOOL v97 = v10;
                  _os_log_impl((void *)&_mh_execute_header, v59, OS_LOG_TYPE_DEFAULT, "Sent %{public}s (control cmd 0x%02X) as %{public}s to %{public}s, reqType = %{public}s, magnet from watch = %d, magnet to watch = %d, cloud sync = %d", buf, 0x42u);
                  if (v85 < 0) {
                    operator delete(v84[0]);
                  }
                  if (v81 < 0) {
                    operator delete(v80[0]);
                  }
                  uint64_t v16 = 0;
                }
                goto LABEL_143;
              }
            }
          }
          __int16 v59 = qword_100A19E38;
          if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_ERROR))
          {
            sub_100474E18(a2, v80);
            sub_10074DCD0((char *)v80, (uint64_t)v98, (uint64_t)v59, buf);
            __int16 v59 = *(NSObject **)buf;
          }
          uint64_t v16 = 312;
LABEL_142:
          BOOL v60 = os_log_type_enabled(v59, OS_LOG_TYPE_ERROR);
          if (v60)
          {
            long long v69 = sub_100287278(v60, a3);
            sub_1002872A4(a1, a3, a4, v84);
            int v70 = v85;
            long long v71 = (void **)v84[0];
            sub_100474E18(a2, __p);
            uint64_t v72 = v84;
            if (v70 < 0) {
              uint64_t v72 = v71;
            }
            if (v79 >= 0) {
              char v73 = __p;
            }
            else {
              char v73 = (void **)__p[0];
            }
            *(_DWORD *)long long buf = 136447234;
            *(void *)&uint8_t buf[4] = v69;
            *(_WORD *)&unsigned char buf[12] = 1024;
            *(_DWORD *)uint64_t v87 = a3;
            *(_WORD *)&v87[4] = 2082;
            uint64_t v88 = v72;
            *(_WORD *)uint64_t v89 = 2082;
            *(void *)&v89[2] = v73;
            __int16 v90 = 1024;
            LODWORD(v91) = v16;
            _os_log_error_impl((void *)&_mh_execute_header, v59, OS_LOG_TYPE_ERROR, "Failed to send %{public}s (control cmd 0x%02X) as %{public}s to %{public}s, error %d", buf, 0x2Cu);
            if (v79 < 0) {
              operator delete(__p[0]);
            }
            if (v85 < 0) {
              operator delete(v84[0]);
            }
          }
LABEL_143:
          uint64_t v51 = (void **)v82;
LABEL_144:
          sub_10003AFB4((uint64_t)v51);
          break;
        case 20:
          uint64_t v26 = qword_100A19E38;
          if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)long long buf = 67109120;
            *(_DWORD *)&uint8_t buf[4] = a4;
            _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "Set SingleClickMode device setting: %d", buf, 8u);
          }
          sub_100485A28(a2, a4);
          goto LABEL_127;
        case 21:
          unsigned int v27 = qword_100A19E38;
          if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)long long buf = 67109120;
            *(_DWORD *)&uint8_t buf[4] = a4;
            _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "Set DoubleClickMode device setting: %d", buf, 8u);
          }
          sub_100485ABC(a2, a4);
          goto LABEL_127;
        case 22:
          __int16 v28 = qword_100A19E38;
          if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)long long buf = 67110400;
            *(_DWORD *)&uint8_t buf[4] = WORD1(a4);
            *(_WORD *)&uint8_t buf[8] = 1024;
            *(_DWORD *)&buf[10] = WORD1(a4);
            *(_WORD *)uint64_t v87 = 1024;
            *(_DWORD *)&v87[2] = BYTE1(a4);
            LOWORD(v88) = 1024;
            *(_DWORD *)((char *)&v88 + 2) = BYTE1(a4);
            HIWORD(v88) = 1024;
            *(_DWORD *)uint64_t v89 = a4;
            *(_WORD *)&v89[4] = 1024;
            *(_DWORD *)&v89[6] = a4;
            _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, "Set ClickHoldMode device setting: extra %u (0x%04X), left %u (0x%02X), right %u (0x%02X)", buf, 0x26u);
          }
          int v29 = sub_100478B2C(a2, 38);
          BOOL v10 = (v29 & 1) == 0 && sub_100487714(a2) != a4;
          sub_100485B50(a2, a4);
          goto LABEL_165;
        case 23:
          int v30 = sub_100478B2C(a2, 43);
          __int16 v31 = qword_100A19E38;
          if (a5 == 3 && v30)
          {
            if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_ERROR)) {
              sub_10074DDC8();
            }
            return 17;
          }
          if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)long long buf = 67109120;
            *(_DWORD *)&uint8_t buf[4] = a4;
            _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_DEFAULT, "Set DoubleClickInterval device setting: %d", buf, 8u);
          }
          int v29 = sub_100478B2C(a2, 43);
          sub_100485C3C(a2, a4);
          goto LABEL_122;
        case 24:
          int v32 = sub_100478B2C(a2, 43);
          int v33 = qword_100A19E38;
          if (a5 == 3 && v32)
          {
            if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_ERROR)) {
              sub_10074DDFC();
            }
            return 17;
          }
          if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)long long buf = 67109120;
            *(_DWORD *)&uint8_t buf[4] = a4;
            _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_DEFAULT, "Set ClickHoldInterval device setting: %d", buf, 8u);
          }
          int v29 = sub_100478B2C(a2, 43);
          sub_100485CD0(a2, a4);
LABEL_122:
          int v14 = 0;
          BOOL v10 = 0;
          goto LABEL_166;
        case 26:
          uint64_t v34 = qword_100A19E38;
          if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)long long buf = 67109120;
            *(_DWORD *)&uint8_t buf[4] = a4;
            _os_log_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_DEFAULT, "Set ListeningModeConfigs device setting: %d", buf, 8u);
          }
          BOOL v10 = sub_1004875AC(a2) != a4;
          sub_1004857E0(a2, a4);
          int v14 = 0;
          int v15 = 1;
          goto LABEL_167;
        case 27:
          int v35 = sub_100478B2C(a2, 43);
          if (a5 - 3 <= 1 && v35)
          {
            if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_ERROR)) {
              sub_10074DE30();
            }
            return 17;
          }
          char v52 = sub_100478B2C(a2, 15);
          int v53 = qword_100A19E38;
          BOOL v54 = os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT);
          if (v52)
          {
            if (v54)
            {
              *(_WORD *)long long buf = 0;
              _os_log_impl((void *)&_mh_execute_header, v53, OS_LOG_TYPE_DEFAULT, "Don't set OneBudANCMode device setting for this device right now", buf, 2u);
            }
            goto LABEL_127;
          }
          if (v54)
          {
            *(_DWORD *)long long buf = 67109120;
            *(_DWORD *)&uint8_t buf[4] = a4;
            _os_log_impl((void *)&_mh_execute_header, v53, OS_LOG_TYPE_DEFAULT, "Set OneBudANCMode device setting: %d", buf, 8u);
          }
          int v29 = sub_100478B2C(a2, 43);
          BOOL v10 = (v29 & 1) == 0 && sub_1004877EC(a2) != a4;
          uint64_t v77 = sub_100485D64(a2, a4);
          sub_100286EF8(v77, a2);
LABEL_165:
          int v14 = 0;
LABEL_166:
          int v15 = v29 ^ 1;
          goto LABEL_167;
        case 28:
          uint64_t v36 = qword_100A19E38;
          if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)long long buf = 67109120;
            *(_DWORD *)&uint8_t buf[4] = a4;
            _os_log_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_DEFAULT, "Set CrownRotationDirection: %d", buf, 8u);
          }
          sub_100485DF8(a2, a4);
          goto LABEL_127;
        case 30:
          uint64_t v37 = qword_100A19E38;
          if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)long long buf = 67109120;
            *(_DWORD *)&uint8_t buf[4] = a4;
            _os_log_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_DEFAULT, "Set AutoAnswerMode: %d", buf, 8u);
          }
          sub_100485E40(a2, a4);
          goto LABEL_127;
        case 31:
          uint64_t v38 = qword_100A19E38;
          if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)long long buf = 67109120;
            *(_DWORD *)&uint8_t buf[4] = a4;
            _os_log_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_DEFAULT, "Set Chime Volume: %d", buf, 8u);
          }
          sub_100485E88(a2, a4);
          goto LABEL_127;
        case 35:
          int v39 = qword_100A19E38;
          if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)long long buf = 67109120;
            *(_DWORD *)&uint8_t buf[4] = a4;
            _os_log_impl((void *)&_mh_execute_header, v39, OS_LOG_TYPE_DEFAULT, "Set VolumeSwipeInterval device setting : VolumeSwipeInterval value %d", buf, 8u);
          }
          sub_100485FAC(a2, a4);
          goto LABEL_127;
        case 36:
          id v40 = qword_100A19E38;
          if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)long long buf = 67109120;
            *(_DWORD *)&uint8_t buf[4] = a4;
            _os_log_impl((void *)&_mh_execute_header, v40, OS_LOG_TYPE_DEFAULT, "Set Call Management Config to value 0x%08X", buf, 8u);
          }
          sub_10048612C(a2, a4);
          goto LABEL_127;
        case 37:
          uint64_t v41 = qword_100A19E38;
          if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)long long buf = 67109120;
            *(_DWORD *)&uint8_t buf[4] = a4;
            _os_log_impl((void *)&_mh_execute_header, v41, OS_LOG_TYPE_DEFAULT, "Set VolumeSwipeMode device setting : VolumeSwipeMode value %d", buf, 8u);
          }
          sub_100485F18(a2, a4);
          goto LABEL_127;
        case 38:
          uint64_t v42 = qword_100A19E38;
          if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)long long buf = 67109120;
            *(_DWORD *)&uint8_t buf[4] = a4;
            _os_log_impl((void *)&_mh_execute_header, v42, OS_LOG_TYPE_DEFAULT, "Set Adaptive Volume Config to value 0x%08X", buf, 8u);
          }
          sub_100486040(a2, a4);
          if (qword_1009F8418 != -1) {
            dispatch_once(&qword_1009F8418, &stru_1009A1E10);
          }
          sub_10041526C((void *)qword_1009F8410, a2, a4);
          goto LABEL_127;
        case 39:
          int v43 = qword_100A19E38;
          if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)long long buf = 67109120;
            *(_DWORD *)&uint8_t buf[4] = a4;
            _os_log_impl((void *)&_mh_execute_header, v43, OS_LOG_TYPE_DEFAULT, "Set Software Mute config to 0x%08X", buf, 8u);
          }
          sub_100486210(a2, a4);
          goto LABEL_127;
        case 40:
          int v17 = qword_100A19E38;
          BOOL v18 = os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT);
          if (v18)
          {
            *(_DWORD *)long long buf = 67109120;
            *(_DWORD *)&uint8_t buf[4] = a4;
            _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "Set Conversation Detect config to 0x%08X", buf, 8u);
          }
          sub_1002870DC(v18, a2, a4);
          sub_1004862BC(a2, a4);
          if (qword_1009F7EF0 != -1) {
            dispatch_once(&qword_1009F7EF0, &stru_1009A1E30);
          }
          sub_100455E64((uint64_t)off_1009F7EE8, a2);
          goto LABEL_127;
        case 41:
          uint64_t v44 = qword_100A19E38;
          if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)long long buf = 67109120;
            *(_DWORD *)&uint8_t buf[4] = a4;
            _os_log_impl((void *)&_mh_execute_header, v44, OS_LOG_TYPE_DEFAULT, "Set SSL to 0x%08X", buf, 8u);
          }
          sub_100486368(a2, a4);
          goto LABEL_127;
        case 44:
          uint64_t v45 = qword_100A19E38;
          int v46 = a4;
          if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)long long buf = 67109376;
            *(_DWORD *)&uint8_t buf[4] = a4;
            *(_WORD *)&uint8_t buf[8] = 1024;
            *(_DWORD *)&buf[10] = BYTE1(a4);
            _os_log_impl((void *)&_mh_execute_header, v45, OS_LOG_TYPE_DEFAULT, "Set Hearing Aid Enrolled to 0x%08X and Hearing Aid Enabled to 0x%08X", buf, 0xEu);
          }
          sub_10048E03C(a2, v46);
          sub_10048E124(a2, BYTE1(a4));
          goto LABEL_127;
        case 46:
          uint64_t v19 = qword_100A19E38;
          if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)long long buf = 67109120;
            *(_DWORD *)&uint8_t buf[4] = a4;
            _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "Set AutoANC Strength to 0x%08X", buf, 8u);
          }
          sub_10048645C(a2, a4);
          goto LABEL_127;
        case 47:
          unsigned __int8 v47 = qword_100A19E38;
          if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)long long buf = 67109120;
            *(_DWORD *)&uint8_t buf[4] = a4;
            _os_log_impl((void *)&_mh_execute_header, v47, OS_LOG_TYPE_DEFAULT, "Set HPS Gain Swipe to 0x%08X", buf, 8u);
          }
          sub_100486660(a2, a4);
          goto LABEL_127;
        case 48:
          int v20 = sub_100478B2C(a2, 31);
          int v21 = qword_100A19E38;
          if (!v20)
          {
            if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_ERROR)) {
              sub_10074DE64();
            }
            return 11;
          }
          if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)long long buf = 67109120;
            *(_DWORD *)&uint8_t buf[4] = a4;
            _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "Set HRM enable / disable state to 0x%08X", buf, 8u);
          }
          sub_100486508(a2, a4);
LABEL_127:
          BOOL v10 = 0;
LABEL_128:
          int v14 = 0;
          int v15 = 0;
          BOOL v55 = a5 != 3;
          goto LABEL_129;
        case 49:
          uint64_t v48 = qword_100A19E38;
          if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)long long buf = 67109120;
            *(_DWORD *)&uint8_t buf[4] = a4;
            _os_log_impl((void *)&_mh_execute_header, v48, OS_LOG_TYPE_DEFAULT, "Set In Case Tone config to 0x%08X", buf, 8u);
          }
          sub_100486414(a2, a4);
          goto LABEL_127;
        case 50:
          uint64_t v22 = qword_100A19E38;
          if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)long long buf = 67109120;
            *(_DWORD *)&uint8_t buf[4] = a4;
            _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "Set Siri Multitone config to 0x%08X", buf, 8u);
          }
          sub_1004865B4(a2, a4);
          goto LABEL_127;
        case 51:
          char v49 = qword_100A19E38;
          if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)long long buf = 67109120;
            *(_DWORD *)&uint8_t buf[4] = a4;
            _os_log_impl((void *)&_mh_execute_header, v49, OS_LOG_TYPE_DEFAULT, "Set Hearing Assist config to 0x%08X", buf, 8u);
          }
          sub_10048670C(a2, a4);
          goto LABEL_127;
        case 52:
          uint64_t v50 = qword_100A19E38;
          if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)long long buf = 67109120;
            *(_DWORD *)&uint8_t buf[4] = a4;
            _os_log_impl((void *)&_mh_execute_header, v50, OS_LOG_TYPE_DEFAULT, "Set Allow Off Option for Listening Mode config to 0x%08X", buf, 8u);
          }
          BOOL v10 = sub_100487BDC(a2) != a4;
          sub_1004867B8(a2, a4);
          goto LABEL_128;
        default:
          goto LABEL_128;
      }
    }
    else
    {
      if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_ERROR)) {
        sub_10074DC9C();
      }
      return 3;
    }
  }
  else
  {
    if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_ERROR)) {
      sub_10074DC68();
    }
    return 111;
  }
  return v16;
}

void sub_100286DC4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, char a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,int a28,__int16 a29,char a30,char a31)
{
}

void sub_100286EF8(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = qword_100A19E38;
  if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
  {
    sub_100475EE0(a2, (uint64_t)__p);
    if (v10 >= 0) {
      uint64_t v4 = __p;
    }
    else {
      uint64_t v4 = (void **)__p[0];
    }
    *(_DWORD *)long long buf = 136315138;
    uint64_t v12 = v4;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Notify one bud ANC mode change for device \"%s\"", buf, 0xCu);
    if (v10 < 0) {
      operator delete(__p[0]);
    }
  }
  uint64_t v5 = sub_1004AFA9C();
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 3221225472;
  void v8[2] = sub_1002A8BA8;
  void v8[3] = &unk_100997528;
  void v8[4] = a2;
  sub_100013018(v5, v8);
  uint64_t v6 = sub_1004AFB34();
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 3221225472;
  _DWORD v7[2] = sub_1002A8C20;
  void v7[3] = &unk_100997528;
  void v7[4] = a2;
  sub_100013018(v6, v7);
}

void sub_100287074()
{
}

void sub_1002870B8()
{
}

void sub_1002870DC(uint64_t a1, uint64_t a2, int a3)
{
  char v4 = sub_100477E48(a2);
  uint64_t v5 = qword_100A19E38;
  BOOL v6 = os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT);
  if (v4)
  {
    if (v6)
    {
      v7[0] = 67109120;
      v7[1] = a3;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "Notify conversation awareness changed \"%i\"", (uint8_t *)v7, 8u);
    }
    if (qword_100A120B0 != -1) {
      dispatch_once(&qword_100A120B0, &stru_1009A13E0);
    }
    notify_set_state(dword_100A120B8, a3 == 1);
    notify_post("com.apple.bluetoothd.conversationAwarenessValueChanged");
  }
  else if (v6)
  {
    LOWORD(v7[0]) = 0;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "Notify of conversation awareness change ignored as Adaptive Controls Share Sheet not yet shown.", (uint8_t *)v7, 2u);
  }
}

uint64_t sub_100287210(uint64_t a1)
{
  if (qword_1009F8080 != -1) {
    dispatch_once(&qword_1009F8080, &stru_1009A1E50);
  }
  uint64_t v2 = off_1009F8078;
  uint64_t v3 = *(void *)(a1 + 32);

  return sub_10049FF74((uint64_t)v2, v3, 4097);
}

const char *sub_100287278(uint64_t a1, int a2)
{
  if ((a2 - 1) > 0x33) {
    return "unknown";
  }
  else {
    return off_1009A2050[(char)(a2 - 1)];
  }
}

void *sub_1002872A4@<X0>(uint64_t a1@<X0>, int a2@<W1>, unsigned int a3@<W2>, void *a4@<X8>)
{
  long long v32 = 0u;
  long long v33 = 0u;
  long long v30 = 0u;
  long long v31 = 0u;
  long long v28 = 0u;
  long long v29 = 0u;
  long long v26 = 0u;
  long long v27 = 0u;
  long long v24 = 0u;
  long long v25 = 0u;
  long long v22 = 0u;
  long long v23 = 0u;
  long long v20 = 0u;
  long long v21 = 0u;
  *(_OWORD *)__str = 0u;
  long long v19 = 0u;
  switch(a2)
  {
    case 1:
      if (a3 > 2u) {
        goto LABEL_32;
      }
      uint64_t v10 = (char)a3;
      uint64_t v11 = off_1009A22D0;
      goto LABEL_15;
    case 4:
      char v8 = "Off";
      switch((__int16)a3)
      {
        case 0:
          goto LABEL_8;
        case 1:
          char v8 = "Siri";
          break;
        case 2:
          char v8 = "Play/Pause";
          break;
        case 3:
          char v8 = "Next Track";
          break;
        case 4:
          char v8 = "Prev Track";
          break;
        default:
          if ((unsigned __int16)a3 == 15) {
            char v8 = "unknown-cloud";
          }
          else {
            char v8 = "unknown";
          }
          break;
      }
      break;
    case 6:
      uint64_t v12 = "owned";
      uint64_t v13 = "not owned";
      goto LABEL_25;
    case 8:
      uint64_t v5 = "unknown";
      int v14 = a3;
      int v15 = "secondary";
      BOOL v16 = a3 == 2;
      BOOL v6 = "primary";
      goto LABEL_35;
    case 10:
      uint64_t v5 = "unknown";
      int v14 = a3;
      int v15 = "Enabled";
      BOOL v16 = a3 == 2;
      BOOL v6 = "Disabled";
      goto LABEL_35;
    case 11:
      snprintf(__str, 0x100uLL, "%u ms");
      return sub_10004191C(a4, __str);
    case 12:
    case 22:
      snprintf(__str, 0x100uLL, "%s for left bud and %s for right bud (value 0x%X)");
      return sub_10004191C(a4, __str);
    case 13:
      if (a3 - 1 > 3) {
        goto LABEL_32;
      }
      char v8 = off_1009A2320[a3 - 1];
      break;
    case 18:
    case 27:
    case 30:
    case 32:
    case 37:
    case 38:
    case 39:
    case 40:
    case 41:
    case 47:
    case 48:
    case 49:
    case 50:
    case 51:
    case 52:
      uint64_t v5 = "unknown";
      BOOL v6 = "Disabled";
      if (a3 == 1) {
        uint64_t v5 = "Enabled";
      }
      BOOL v7 = a3 == 2;
      goto LABEL_5;
    case 19:
      uint64_t v12 = "Enabled";
      uint64_t v13 = "Disabled";
LABEL_25:
      if (a3) {
        char v8 = (char *)v12;
      }
      else {
        char v8 = (char *)v13;
      }
      break;
    case 20:
    case 21:
      LOBYTE(v10) = a3 - 1;
      if ((a3 - 1) > 6u) {
        goto LABEL_32;
      }
      uint64_t v10 = (char)v10;
      uint64_t v11 = off_1009A23B8;
LABEL_15:
      char v8 = v11[v10];
      break;
    case 23:
      if (a3 > 2) {
        goto LABEL_32;
      }
      int v17 = off_1009A2408;
      goto LABEL_40;
    case 24:
      if (a3 <= 2)
      {
        int v17 = off_1009A2420;
        goto LABEL_40;
      }
LABEL_32:
      char v8 = "unknown";
      break;
    case 26:
      char v8 = (char *)sub_1002A8D50(a1, a3);
      break;
    case 28:
      uint64_t v5 = "unknown";
      int v14 = a3;
      int v15 = "Front-to-Back";
      BOOL v16 = a3 == 2;
      BOOL v6 = "Back-to-Front";
LABEL_35:
      if (v16) {
        uint64_t v5 = v15;
      }
      BOOL v7 = v14 == 1;
LABEL_5:
      if (v7) {
        char v8 = (char *)v6;
      }
      else {
        char v8 = (char *)v5;
      }
      break;
    case 34:
      if (a3 > 2)
      {
        char v8 = "Invalid";
      }
      else
      {
        int v17 = off_1009A23F0;
LABEL_40:
        char v8 = v17[a3];
      }
      break;
    case 36:
      if ((a3 & 0xF) != 0) {
        snprintf(__str, 0x100uLL, "Version: %u, endCallStatus: %s, endCall: %s, muteControlStatus: %s, muteControl: %s");
      }
      else {
        snprintf(__str, 0x100uLL, "Version: %u, endCallStatus: %s, endCall: %s");
      }
      return sub_10004191C(a4, __str);
    case 44:
      snprintf(__str, 0x100uLL, "Hearing aid enrolled: %s, enabled: %s");
      return sub_10004191C(a4, __str);
    case 46:
      snprintf(__str, 0x100uLL, "%u");
      return sub_10004191C(a4, __str);
    default:
      snprintf(__str, 0x100uLL, "0x%08X");
      return sub_10004191C(a4, __str);
  }
LABEL_8:

  return sub_10004191C(a4, v8);
}

uint64_t sub_1002879DC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v10[0] = 0;
  v10[1] = 0;
  sub_10003AED0((uint64_t)v10, a1 + 360);
  if (a2)
  {
    for (uint64_t i = *(void *)(a1 + 336); i != *(void *)(a1 + 344); i += 8)
    {
      if (**(void **)i == a2)
      {
        uint64_t v7 = (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(*(void *)i + 768) + 96))(*(void *)(*(void *)i + 768), a2, a3);
        goto LABEL_9;
      }
    }
  }
  if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_ERROR))
  {
    sub_100474E18(a2, v9);
    sub_10074DAD4();
  }
  uint64_t v7 = 312;
LABEL_9:
  sub_10003AFB4((uint64_t)v10);
  return v7;
}

void sub_100287AF8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  sub_10003AFB4((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_100287B18(uint64_t a1, uint64_t a2, uint64_t a3, unsigned int a4)
{
  v16[0] = 0;
  v16[1] = 0;
  sub_10003AED0((uint64_t)v16, a1 + 360);
  char v8 = qword_100A19E38;
  BOOL v9 = os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT);
  if (v9)
  {
    uint64_t v10 = sub_100287278(v9, a2);
    *(_DWORD *)long long buf = 136446722;
    BOOL v18 = v10;
    __int16 v19 = 1024;
    int v20 = a2;
    __int16 v21 = 1024;
    int v22 = a3;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "broadcastControlCommand: %{public}s (control cmd 0x%02X), value %d", buf, 0x18u);
  }
  uint64_t v12 = *(uint64_t ***)(a1 + 336);
  uint64_t v11 = *(uint64_t ***)(a1 + 344);
  uint64_t v13 = 1;
  while (v12 != v11)
  {
    int v14 = *v12;
    if (*v12)
    {
      if (*v14)
      {
        uint64_t v13 = sub_1002859A4(a1, *v14, a2, a3, a4);
        uint64_t v11 = *(uint64_t ***)(a1 + 344);
      }
    }
    ++v12;
  }
  sub_10003AFB4((uint64_t)v16);
  return v13;
}

void sub_100287C54(_Unwind_Exception *exception_object)
{
}

uint64_t sub_100287C70(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v14[0] = 0;
  v14[1] = 0;
  sub_10003AED0((uint64_t)v14, a1 + 360);
  char v8 = qword_100A19E38;
  if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 67109376;
    int v16 = a2;
    __int16 v17 = 1024;
    int v18 = a3;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "broadcastCustomMsg: type: %u, len: %u", buf, 0xEu);
  }
  uint64_t v10 = *(uint64_t ***)(a1 + 336);
  BOOL v9 = *(uint64_t ***)(a1 + 344);
  uint64_t v11 = 1;
  while (v10 != v9)
  {
    uint64_t v12 = *v10;
    if (*v10)
    {
      if (*v12)
      {
        uint64_t v11 = sub_10028502C(a1, *v12, a2, a3, a4);
        BOOL v9 = *(uint64_t ***)(a1 + 344);
      }
    }
    ++v10;
  }
  sub_10003AFB4((uint64_t)v14);
  return v11;
}

void sub_100287D9C(_Unwind_Exception *exception_object)
{
}

uint64_t sub_100287DB8(double a1)
{
  if (a1 == 8000.0) {
    return 1;
  }
  if (a1 == 16000.0) {
    return 2;
  }
  if (a1 == 24000.0) {
    return 3;
  }
  if (a1 == 44100.0) {
    return 4;
  }
  if (a1 == 48000.0) {
    return 5;
  }
  return 0;
}

uint64_t sub_100287E30(uint64_t a1)
{
  v11[0] = 0;
  v11[1] = 0;
  sub_10003AED0((uint64_t)v11, a1 + 360);
  uint64_t v2 = qword_100A19E38;
  if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v10 = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "getStreamingDevice: no connected devices", v10, 2u);
  }
  uint64_t v3 = *(uint64_t ***)(a1 + 336);
  char v4 = *(uint64_t ***)(a1 + 344);
  while (1)
  {
    if (v3 == v4)
    {
      uint64_t v7 = qword_100A19E38;
      if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)uint64_t v10 = 0;
        char v8 = "getA2DPStreamingDevice: no connected devices";
        goto LABEL_10;
      }
LABEL_11:
      uint64_t v6 = 0;
      goto LABEL_12;
    }
    uint64_t v5 = *v3;
    if (*v3)
    {
      uint64_t v6 = *v5;
      if (*v5) {
        break;
      }
    }
    ++v3;
  }
  if (qword_1009F8418 != -1) {
    dispatch_once(&qword_1009F8418, &stru_1009A1E10);
  }
  if ((sub_100409E0C((void *)qword_1009F8410, v6) & 1) == 0)
  {
    uint64_t v7 = qword_100A19E38;
    if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t v10 = 0;
      char v8 = "getA2DPStreamingDevice: no A2DP stream";
LABEL_10:
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, v8, v10, 2u);
    }
    goto LABEL_11;
  }
LABEL_12:
  sub_10003AFB4((uint64_t)v11);
  return v6;
}

void sub_100287F8C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  sub_10003AFB4((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_100287FA0(uint64_t a1, unsigned __int8 *a2, uint64_t a3)
{
  __int16 v15 = 0;
  int v14 = 0;
  if ((char)a2[23] < 0) {
    a2 = *(unsigned __int8 **)a2;
  }
  if (!sub_1004A82DC((uint64_t)&v14, a2))
  {
    if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_ERROR)) {
      sub_10074DE98();
    }
    return 1;
  }
  if (qword_1009F7F00 != -1) {
    dispatch_once(&qword_1009F7F00, &stru_1009A1E70);
  }
  LODWORD(__p[0]) = v14;
  WORD2(__p[0]) = v15;
  uint64_t v5 = sub_1004AA194((uint64_t)off_1009F7EF8, (uint64_t)__p, 1);
  uint64_t v6 = v5;
  if (v5)
  {
    int v7 = sub_100487CFC(v5);
    sub_100486CBC(v6, a3);
  }
  else
  {
    int v7 = 0;
  }
  if (!sub_1004BDB84(a1) || v7 == a3) {
    return 1;
  }
  BOOL v9 = qword_100A19E38;
  if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
  {
    sub_1004A82EC((unsigned __int8 *)&v14, __p);
    uint64_t v10 = (void **)__p[0];
    uint64_t v11 = "doesn't own";
    if (v13 >= 0) {
      uint64_t v10 = __p;
    }
    if (a3) {
      uint64_t v11 = "owns";
    }
    *(_DWORD *)long long buf = 136315394;
    __int16 v17 = v10;
    __int16 v18 = 2082;
    __int16 v19 = v11;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "Telling device \"%s\" that this source %{public}s the connection", buf, 0x16u);
    if (v13 < 0) {
      operator delete(__p[0]);
    }
  }
  return sub_1002859A4(a1, v6, 6, a3, 1u);
}

uint64_t sub_10028819C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v12[0] = 0;
  v12[1] = 0;
  sub_10003AED0((uint64_t)v12, a1 + 360);
  if (a2)
  {
    for (uint64_t i = *(void *)(a1 + 336); i != *(void *)(a1 + 344); i += 8)
    {
      if (**(void **)i == a2)
      {
        uint64_t v9 = (*(uint64_t (**)(void, uint64_t, uint64_t, uint64_t))(**(void **)(*(void *)i + 768) + 112))(*(void *)(*(void *)i + 768), a2, a3, a4);
        goto LABEL_9;
      }
    }
  }
  if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_ERROR))
  {
    sub_100474E18(a2, v11);
    sub_10074DAD4();
  }
  uint64_t v9 = 312;
LABEL_9:
  sub_10003AFB4((uint64_t)v12);
  return v9;
}

void sub_1002882C0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  sub_10003AFB4((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1002882E0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v12[0] = 0;
  v12[1] = 0;
  sub_10003AED0((uint64_t)v12, a1 + 360);
  if (a2)
  {
    for (uint64_t i = *(void *)(a1 + 336); i != *(void *)(a1 + 344); i += 8)
    {
      if (**(void **)i == a2)
      {
        uint64_t v9 = (*(uint64_t (**)(void, uint64_t, uint64_t, uint64_t))(**(void **)(*(void *)i + 768) + 120))(*(void *)(*(void *)i + 768), a2, a3, a4);
        goto LABEL_9;
      }
    }
  }
  if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_ERROR))
  {
    sub_100474E18(a2, v11);
    sub_10074DECC();
  }
  uint64_t v9 = 312;
LABEL_9:
  sub_10003AFB4((uint64_t)v12);
  return v9;
}

void sub_100288404(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  sub_10003AFB4((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_100288424(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v10[0] = 0;
  v10[1] = 0;
  sub_10003AED0((uint64_t)v10, a1 + 360);
  if (a2)
  {
    for (uint64_t i = *(void *)(a1 + 336); i != *(void *)(a1 + 344); i += 8)
    {
      if (**(void **)i == a2)
      {
        uint64_t v7 = (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(*(void *)i + 768) + 128))(*(void *)(*(void *)i + 768), a2, a3);
        goto LABEL_9;
      }
    }
  }
  if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_ERROR))
  {
    sub_100474E18(a2, v9);
    sub_10074DF20();
  }
  uint64_t v7 = 312;
LABEL_9:
  sub_10003AFB4((uint64_t)v10);
  return v7;
}

void sub_100288540(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  sub_10003AFB4((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_100288560(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, unsigned __int16 *a6)
{
  uint64_t v12 = qword_100A19E38;
  if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
  {
    sub_100474E18(a2, __p);
    char v13 = v24 >= 0 ? __p : (void **)__p[0];
    *(_DWORD *)long long buf = 136446978;
    *(void *)long long v26 = v13;
    *(_WORD *)&v26[8] = 1024;
    int v27 = a3;
    __int16 v28 = 1024;
    int v29 = a4;
    __int16 v30 = 1024;
    int v31 = a5;
    _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "send setup command to %{public}s, setupType -> %d, opType -> %d, pldLen -> %d", buf, 0x1Eu);
    if (v24 < 0) {
      operator delete(__p[0]);
    }
  }
  if (a3 != 1)
  {
    uint64_t v19 = qword_100A19E38;
    if (!os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_15;
    }
    *(_DWORD *)long long buf = 67109120;
    *(_DWORD *)long long v26 = a3;
    int v16 = "Unsupported setup type = %d";
    __int16 v17 = v19;
    uint32_t v18 = 8;
    goto LABEL_14;
  }
  if (a5 >= 2)
  {
    if (!a6) {
      sub_10014327C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Server/aacp/AACPClient.mm", 1098, "pldData");
    }
    uint64_t v14 = qword_100A19E38;
    if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
    {
      int v15 = *a6;
      *(_DWORD *)long long buf = 67109376;
      *(_DWORD *)long long v26 = a4;
      *(_WORD *)&v26[4] = 1024;
      *(_DWORD *)&v26[6] = v15;
      int v16 = "send seal setup operation opType = %d result = %d";
      __int16 v17 = v14;
      uint32_t v18 = 14;
LABEL_14:
      _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, v16, buf, v18);
    }
  }
LABEL_15:
  __p[0] = 0;
  __p[1] = 0;
  sub_10003AED0((uint64_t)__p, a1 + 360);
  if (a2)
  {
    for (uint64_t i = *(void *)(a1 + 336); i != *(void *)(a1 + 344); i += 8)
    {
      if (**(void **)i == a2)
      {
        uint64_t v21 = (*(uint64_t (**)(void, uint64_t, uint64_t, uint64_t, uint64_t, unsigned __int16 *))(**(void **)(*(void *)i + 768) + 152))(*(void *)(*(void *)i + 768), a2, a3, a4, a5, a6);
        goto LABEL_23;
      }
    }
  }
  if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_ERROR))
  {
    sub_100474E18(a2, buf);
    sub_10074DF74();
  }
  uint64_t v21 = 312;
LABEL_23:
  sub_10003AFB4((uint64_t)__p);
  return v21;
}

void sub_100288810(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_10003AFB4((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_100288830(uint64_t a1, uint64_t a2, uint64_t a3, int a4, unsigned int a5, const void *a6)
{
  if (!*(unsigned char *)(a1 + 328)) {
    return 111;
  }
  bzero(&v32, 0x3E7uLL);
  char v24 = 0;
  v23[0] = 0;
  v23[1] = 0;
  sub_10003AED0((uint64_t)v23, a1 + 360);
  if (a2)
  {
    for (uint64_t i = *(void **)(a1 + 336); i != *(void **)(a1 + 344); ++i)
    {
      char v13 = (void *)*i;
      if (*(void *)*i == a2) {
        goto LABEL_8;
      }
    }
  }
  char v13 = 0;
LABEL_8:
  uint64_t v14 = qword_100A19E38;
  if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
  {
    sub_100474E18(a2, __p);
    int v15 = v26 >= 0 ? __p : *(unsigned char **)__p;
    *(_DWORD *)long long buf = 136446722;
    *(void *)&uint8_t buf[4] = v15;
    int v16 = a4 == 1 ? "Audio Arbitration" : "Unknown";
    __int16 v28 = 2082;
    int v29 = v16;
    __int16 v30 = 1024;
    unsigned int v31 = a5;
    _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "Send relay message to %{public}s, relayMessageType -> %{public}s, relayMessageLen -> %d", buf, 0x1Cu);
    if (v26 < 0) {
      operator delete(*(void **)__p);
    }
  }
  if (a5 < 0x3E7)
  {
    if (v13)
    {
      if (a4 == 1)
      {
        char v22 = 0;
        sub_10001B8E0(&v22);
        if (!sub_100181DC4(a2 + 128, &v24) && v24 == 2)
        {
          uint32_t v18 = qword_100A19E38;
          if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
          {
            sub_100474E18(a2, buf);
            uint64_t v19 = v30 >= 0 ? buf : *(unsigned char **)buf;
            *(_DWORD *)std::string __p = 136446210;
            *(void *)&__p[4] = v19;
            _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "Unsniff ACL link with %{public}s for TiPi audio arbitration message", __p, 0xCu);
            if (SHIBYTE(v30) < 0) {
              operator delete(*(void **)buf);
            }
          }
          sub_10018354C(a2 + 128);
        }
        sub_10001B910(&v22);
        sub_10001B8AC(&v22);
      }
      char v32 = a4;
      memcpy(v33, a6, a5);
      buf[0] = 0;
      sub_10001B8E0(buf);
      uint64_t v20 = sub_1000D84B0((unsigned __int8 *)(a2 + 128), a3, (unsigned __int16)(a5 + 1), &v32);
      sub_10001B910(buf);
      if (v20 && os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_ERROR)) {
        sub_10074E098();
      }
      if (qword_1009F8070 != -1) {
        dispatch_once(&qword_1009F8070, &stru_1009A1D70);
      }
      uint64_t v17 = sub_1004E2340((uint64_t)off_1009F8068, v20, 10000);
      sub_10001B8AC(buf);
    }
    else
    {
      if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_ERROR))
      {
        sub_100474E18(a2, buf);
        sub_10074E044();
      }
      uint64_t v17 = 312;
    }
  }
  else
  {
    if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_ERROR)) {
      sub_10074DFC8();
    }
    uint64_t v17 = 3;
  }
  sub_10003AFB4((uint64_t)v23);
  return v17;
}

void sub_100288BB8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, int a9, __int16 a10, char a11, char a12, char a13)
{
}

uint64_t sub_100288C00(uint64_t a1, uint64_t a2, int a3, int *a4, unsigned int a5)
{
  if (!*(unsigned char *)(a1 + 328)) {
    return 111;
  }
  v20[0] = 0;
  v20[1] = 0;
  sub_10003AED0((uint64_t)v20, a1 + 360);
  if (a2)
  {
    uint64_t v10 = *(void ***)(a1 + 336);
    uint64_t v11 = *(void ***)(a1 + 344);
    while (v10 != v11)
    {
      uint64_t v12 = *v10;
      if (**v10 == a2) {
        goto LABEL_8;
      }
      ++v10;
    }
  }
  uint64_t v12 = 0;
LABEL_8:
  char v13 = qword_100A19E38;
  if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
  {
    sub_100474E18(a2, __p);
    if (v22 >= 0) {
      uint64_t v14 = __p;
    }
    else {
      uint64_t v14 = (void **)__p[0];
    }
    int v15 = "Unknown";
    if (a3 == 2) {
      int v15 = "Legacy Triangle";
    }
    *(_DWORD *)long long buf = 136446722;
    char v24 = v14;
    if (a3 == 1) {
      int v16 = "TiPi";
    }
    else {
      int v16 = v15;
    }
    __int16 v25 = 2082;
    char v26 = v16;
    __int16 v27 = 1024;
    unsigned int v28 = a5;
    _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "Send update request for connection priority list to %{public}s, reqType -> %{public}s, numOfConn -> %d", buf, 0x1Cu);
    if (v22 < 0) {
      operator delete(__p[0]);
    }
  }
  if (a5 < 3)
  {
    if (v12)
    {
      if (!sub_100478B2C(a2, 32) || (uint64_t v17 = sub_100288EFC((uint64_t)v12, a3, a4, a5), !v17))
      {
        buf[0] = 0;
        sub_10001B8E0(buf);
        uint64_t v18 = sub_1000D86C8((unsigned __int8 *)(a2 + 128), a5, (uint64_t)a4);
        sub_10001B910(buf);
        if (v18 && os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_ERROR)) {
          sub_10074E17C();
        }
        if (qword_1009F8070 != -1) {
          dispatch_once(&qword_1009F8070, &stru_1009A1D70);
        }
        uint64_t v17 = sub_1004E2340((uint64_t)off_1009F8068, v18, 10000);
        sub_10001B8AC(buf);
      }
    }
    else
    {
      if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_ERROR))
      {
        sub_100474E18(a2, buf);
        sub_10074E044();
      }
      uint64_t v17 = 312;
    }
  }
  else
  {
    if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_ERROR)) {
      sub_10074E100();
    }
    uint64_t v17 = 3;
  }
  sub_10003AFB4((uint64_t)v20);
  return v17;
}

void sub_100288EC4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_100288EFC(uint64_t a1, int a2, int *a3, int a4)
{
  int v57 = a2;
  if (a2 == 2)
  {
    uint64_t v9 = qword_100A19E38;
    if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
    {
      sub_100474E18(*(void *)a1, &__p);
      uint64_t v10 = v61 >= 0 ? &__p : (void **)__p;
      *(_DWORD *)long long buf = 136446210;
      uint8_t v63 = v10;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "Request Legacy Triangle connection priority list update for device %{public}s", buf, 0xCu);
      if (v61 < 0) {
        operator delete(__p);
      }
    }
LABEL_24:
    __int16 v27 = *(char **)(a1 + 680);
    if (v27 != *(char **)(a1 + 688)) {
      *(void *)(a1 + 688) = v27;
    }
    if (a4)
    {
      uint64_t v28 = 0;
      int v29 = (void *)(a1 + 696);
      do
      {
        __int16 v30 = qword_100A19E38;
        if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v38 = sub_10025B48C((uint64_t)a3 + 6 * v28, v31, v32, v33, v34, v35, v36, v37);
          LODWORD(__p) = 67109378;
          HIDWORD(__p) = v28;
          __int16 v59 = 2080;
          uint64_t v60 = v38;
          _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_DEFAULT, "Address of source [%d] in connection priority list update is \"%s\"", (uint8_t *)&__p, 0x12u);
          __int16 v27 = *(char **)(a1 + 688);
        }
        int v39 = (int *)((char *)a3 + 6 * v28);
        LODWORD(__p) = *v39;
        WORD2(__p) = *((_WORD *)v39 + 2);
        if ((unint64_t)v27 >= *v29)
        {
          uint64_t v41 = *(void *)(a1 + 680);
          unint64_t v42 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)&v27[-v41] >> 1);
          unint64_t v43 = v42 + 1;
          if (v42 + 1 > 0x2AAAAAAAAAAAAAAALL) {
            abort();
          }
          if (0x5555555555555556 * ((*v29 - v41) >> 1) > v43) {
            unint64_t v43 = 0x5555555555555556 * ((*v29 - v41) >> 1);
          }
          if (0xAAAAAAAAAAAAAAABLL * ((*v29 - v41) >> 1) >= 0x1555555555555555) {
            unint64_t v44 = 0x2AAAAAAAAAAAAAAALL;
          }
          else {
            unint64_t v44 = v43;
          }
          if (v44) {
            uint64_t v45 = (char *)sub_1002B5B2C(a1 + 696, v44);
          }
          else {
            uint64_t v45 = 0;
          }
          int v46 = &v45[6 * v42];
          *(_DWORD *)int v46 = __p;
          *((_WORD *)v46 + 2) = WORD2(__p);
          unsigned __int8 v47 = *(_WORD **)(a1 + 688);
          uint64_t v48 = *(_WORD **)(a1 + 680);
          char v49 = v46;
          if (v47 != v48)
          {
            do
            {
              int v50 = *(_DWORD *)(v47 - 3);
              v47 -= 3;
              __int16 v51 = v47[2];
              *(_DWORD *)(v49 - 6) = v50;
              v49 -= 6;
              *((_WORD *)v49 + 2) = v51;
            }
            while (v47 != v48);
            unsigned __int8 v47 = *(_WORD **)(a1 + 680);
          }
          *(void *)(a1 + 680) = v49;
          __int16 v27 = v46 + 6;
          *(void *)(a1 + 688) = v46 + 6;
          *(void *)(a1 + 696) = &v45[6 * v44];
          if (v47) {
            operator delete(v47);
          }
        }
        else
        {
          int v40 = *v39;
          *((_WORD *)v27 + 2) = *((_WORD *)v39 + 2);
          *(_DWORD *)__int16 v27 = v40;
          v27 += 6;
        }
        *(void *)(a1 + 688) = v27;
        ++v28;
      }
      while (v28 != a4);
    }
    sub_1002B5B74((void *)(a1 + 632), &v57);
    return 0;
  }
  if (a2 == 1)
  {
    uint64_t v7 = qword_100A19E38;
    if (*(unsigned char *)(a1 + 618))
    {
      if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_ERROR)) {
        sub_10074E24C();
      }
      return 17;
    }
    if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
    {
      sub_100474E18(*(void *)a1, &__p);
      int v11 = v61;
      uint64_t v12 = (void **)__p;
      uint64_t v20 = sub_10025B48C((uint64_t)a3 + 6, v13, v14, v15, v16, v17, v18, v19);
      p_p = &__p;
      if (v11 < 0) {
        p_p = v12;
      }
      *(_DWORD *)long long buf = 136446466;
      uint8_t v63 = p_p;
      __int16 v64 = 2080;
      uint64_t v65 = v20;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "Request TiPi connection priority list update for device %{public}s, TiPi source addr = \"%s\"", buf, 0x16u);
      if (v61 < 0) {
        operator delete(__p);
      }
    }
    int v55 = *a3;
    __int16 v56 = *((_WORD *)a3 + 2);
    int v53 = *(int *)((char *)a3 + 6);
    __int16 v54 = *((_WORD *)a3 + 5);
    *(unsigned char *)(a1 + 618) = 1;
    sub_10028BA10(a1, (uint64_t)&v55, (uint64_t)&v53);
    if (qword_1009F80A0 != -1) {
      dispatch_once(&qword_1009F80A0, &stru_1009A1E90);
    }
    uint64_t v22 = *(void *)a1;
    BOOL v23 = sub_10028BC74(a1);
    sub_10028BB94(v23, v22, v23);
    v52[0] = _NSConcreteStackBlock;
    v52[1] = 3221225472;
    v52[2] = sub_1002A9BF8;
    v52[3] = &unk_1009A1400;
    v52[4] = a1;
    uint64_t v24 = +[NSTimer timerWithTimeInterval:0 repeats:v52 block:2.0];
    __int16 v25 = *(void **)(a1 + 624);
    *(void *)(a1 + 624) = v24;

    char v26 = +[NSRunLoop mainRunLoop];
    [v26 addTimer:*(void *)(a1 + 624) forMode:NSDefaultRunLoopMode];

    goto LABEL_24;
  }
  if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_ERROR)) {
    sub_10074E1E4();
  }
  return 3;
}

void sub_1002893CC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *__p, uint64_t a20,int a21,__int16 a22,char a23,char a24)
{
  if (a24 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1002893FC(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = sub_100035F54();
  if ((*(uint64_t (**)(uint64_t))(*(void *)v4 + 328))(v4))
  {
    if (qword_1009FB140 != -1) {
      dispatch_once(&qword_1009FB140, &stru_1009A1EB0);
    }
    v5[0] = _NSConcreteStackBlock;
    v5[1] = 3221225472;
    _DWORD v5[2] = sub_100289508;
    v5[3] = &unk_100998260;
    v5[4] = a1;
    v5[5] = a2;
    sub_1004C9DF0((uint64_t)off_1009FB138, v5);
  }
  else if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_ERROR))
  {
    sub_10074E280();
  }
}

uint64_t sub_100289508(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  v20[0] = 0;
  v20[1] = 0;
  sub_10003AED0((uint64_t)v20, v2 + 360);
  if (!*(void *)(v2 + 304))
  {
    uint64_t v3 = qword_100A19E38;
    if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "GAPA showCannotVerifyAlert", buf, 2u);
    }
    *(void *)(v2 + 312) = *(void *)(a1 + 40);
    *(_DWORD *)long long buf = 0;
    uint64_t v18 = 0;
    int v17 = 0;
    uint64_t v4 = sub_10047ECFC(*(void *)(a1 + 40));
    if ((v4 & 2) != 0 && sub_1002898E0(v4, *(_DWORD **)(a1 + 40))) {
      sub_10048E1C4(*(_DWORD **)(a1 + 40), buf, (_DWORD *)&v18 + 1, &v18, &v17);
    }
    else {
      sub_10047B7A8(*(void *)(a1 + 40), buf, (_DWORD *)&v18 + 1, &v18, &v17);
    }
    if ((v18 - 8195) <= 0x23 && ((1 << (v18 - 3)) & 0xC0498E74DLL) != 0)
    {
      uint64_t v5 = sub_100379650(@"GAPA_BT_SETTINGS_ALERT_HEADER_BEATS", @"Cannot Verify Beats");
      uint64_t v6 = sub_100379650(@"GAPA_BT_SETTINGS_ALERT_MESSAGE_BEATS", @"These headphones could not be verified as genuine Beats. Would you like to connect anyway?");
    }
    else
    {
      uint64_t v5 = sub_100379650(@"GAPA_BT_SETTINGS_ALERT_HEADER", @"Cannot Verify AirPods");
      uint64_t v6 = sub_100379650(@"GAPA_BT_SETTINGS_ALERT_MESSAGE", @"These headphones could not be verified as genuine Apple AirPods. Would you like to connect anyway?");
    }
    uint64_t v7 = (void *)v6;
    char v8 = sub_100379650(@"GAPA_BT_SETTINGS_ALERT_LEARNMORE", @"Learn More");
    uint64_t v9 = sub_100379650(@"GAPA_BT_SETTINGS_ALERT_PAIRANYWAY", @"Connect Anyway");
    uint64_t v10 = sub_100379650(@"GAPA_BT_SETTINGS_ALERT_CANCEL", @"Cancel");
    v21[0] = kCFUserNotificationAlertHeaderKey;
    v21[1] = kCFUserNotificationAlertMessageKey;
    v22[0] = v5;
    v22[1] = v7;
    v21[2] = kCFUserNotificationAlternateButtonTitleKey;
    v21[3] = kCFUserNotificationOtherButtonTitleKey;
    v22[2] = v8;
    v22[3] = v9;
    v21[4] = kCFUserNotificationDefaultButtonTitleKey;
    v22[4] = v10;
    int v11 = +[NSDictionary dictionaryWithObjects:v22 forKeys:v21 count:5];
    CFDictionaryRef v12 = (const __CFDictionary *)[v11 mutableCopy];

    uint64_t v13 = CFUserNotificationCreate(kCFAllocatorDefault, 0.0, 3uLL, 0, v12);
    *(void *)(v2 + 304) = v13;
    RunLoopSource = CFUserNotificationCreateRunLoopSource(kCFAllocatorDefault, v13, (CFUserNotificationCallBack)sub_10028999C, 0);
    if (RunLoopSource)
    {
      Main = CFRunLoopGetMain();
      CFRunLoopAddSource(Main, RunLoopSource, kCFRunLoopCommonModes);
      CFRelease(RunLoopSource);
    }
    else
    {
      CFUserNotificationCancel(*(CFUserNotificationRef *)(v2 + 304));
      CFRelease(*(CFTypeRef *)(v2 + 304));
      *(void *)(v2 + 304) = 0;
    }
  }
  return sub_10003AFB4((uint64_t)v20);
}

void sub_100289860(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);

  sub_10003AFB4((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1002898E0(uint64_t a1, _DWORD *a2)
{
  uint64_t v7 = 0;
  uint64_t v8 = 0;
  sub_10047B7A8((uint64_t)a2, (_DWORD *)&v8 + 1, &v8, (_DWORD *)&v7 + 1, &v7);
  int v3 = HIDWORD(v7);
  if (!HIDWORD(v7))
  {
    sub_10048E1C4(a2, (_DWORD *)&v8 + 1, &v8, (_DWORD *)&v7 + 1, &v7);
    int v3 = HIDWORD(v7);
  }
  unsigned int v4 = ((v3 - 8212) < 0x11) & (0x116A1u >> (v3 - 20));
  uint64_t v5 = sub_100017768();
  return v4 | (*(unsigned int (**)(uint64_t))(*(void *)v5 + 744))(v5);
}

void sub_10028999C(uint64_t a1, uint64_t a2)
{
  if (qword_1009F80A0 != -1) {
    dispatch_once(&qword_1009F80A0, &stru_1009A1E90);
  }
  int v3 = off_1009F8098;

  sub_100289A00((uint64_t)v3, a2, a2);
}

void sub_100289A00(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (qword_1009FB140 != -1) {
    dispatch_once(&qword_1009FB140, &stru_1009A1EB0);
  }
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 3221225472;
  _DWORD v5[2] = sub_100289AAC;
  v5[3] = &unk_100998260;
  v5[4] = a1;
  v5[5] = a3;
  sub_1004C9DF0((uint64_t)off_1009FB138, v5);
}

uint64_t sub_100289AAC(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  v13[0] = 0;
  v13[1] = 0;
  sub_10003AED0((uint64_t)v13, v2 + 360);
  int v3 = qword_100A19E38;
  if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v4 = *(void *)(a1 + 40);
    *(_DWORD *)long long buf = 134217984;
    uint64_t v15 = v4;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "GAPA user responded to cannot verify alert %ld", buf, 0xCu);
  }
  uint64_t v5 = *(void *)(a1 + 40);
  if (!v5)
  {
    uint64_t v10 = qword_100A19E38;
    if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "GAPA cancelButton", buf, 2u);
    }
    sub_10047ED44(*(void *)(v2 + 312), 0, 1799);
    if (qword_1009F8768 != -1) {
      dispatch_once(&qword_1009F8768, &stru_1009A1DD0);
    }
    sub_100611000((uint64_t)off_1009F8760, *(unsigned __int8 **)(v2 + 312));
    goto LABEL_26;
  }
  if (v5 == 2)
  {
    int v11 = qword_100A19E38;
    if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "GAPA pairAnywayButton", buf, 2u);
    }
    if (qword_1009F8090 != -1) {
      dispatch_once(&qword_1009F8090, &stru_1009A1ED0);
    }
    sub_1004D76C0((uint64_t)off_1009F8088, *(void *)(v2 + 312), -1);
    goto LABEL_26;
  }
  if (v5 != 1)
  {
    if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_ERROR)) {
      sub_10074E2B4();
    }
    goto LABEL_26;
  }
  uint64_t v6 = qword_100A19E38;
  if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "GAPA learnMoreButton", buf, 2u);
  }
  if (qword_1009F8090 != -1) {
    dispatch_once(&qword_1009F8090, &stru_1009A1ED0);
  }
  sub_1004D76C0((uint64_t)off_1009F8088, *(void *)(v2 + 312), -1);
  id v7 = [objc_alloc((Class)NSURL) initWithString:@"https://support.apple.com/kb/HT213102"];
  if (v7)
  {
    uint64_t v8 = +[LSApplicationWorkspace defaultWorkspace];
    [v8 openURL:v7 withOptions:0];

    uint64_t v9 = qword_100A19E38;
    if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "GAPA user sent to URL", buf, 2u);
    }

LABEL_26:
    CFRelease(*(CFTypeRef *)(v2 + 304));
    *(void *)(v2 + 304) = 0;
    *(void *)(v2 + 312) = 0;
    return sub_10003AFB4((uint64_t)v13);
  }
  if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_ERROR)) {
    sub_10074E320();
  }
  return sub_10003AFB4((uint64_t)v13);
}

void sub_100289DE4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  int v11 = v10;

  sub_10003AFB4((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t sub_100289E20(int a1, void *__s)
{
  uint64_t v2 = qword_100A19A38;
  if ((_UNKNOWN *)qword_100A19A38 == &unk_100A19A40) {
    return 0;
  }
  uint64_t v4 = *((unsigned __int8 *)__s + 23);
  while (1)
  {
    uint64_t v5 = __s;
    uint64_t v6 = v4;
    if ((v4 & 0x80) != 0)
    {
      uint64_t v5 = (void *)*__s;
      uint64_t v6 = __s[1];
    }
    int v7 = *(char *)(v2 + 55);
    uint64_t v8 = v7 >= 0 ? (unsigned __int8 *)(v2 + 32) : *(unsigned __int8 **)(v2 + 32);
    int64_t v9 = v7 >= 0 ? *(unsigned __int8 *)(v2 + 55) : *(void *)(v2 + 40);
    if (!v9) {
      return *(unsigned int *)(v2 + 56);
    }
    if (v6 >= v9)
    {
      uint64_t v13 = (char *)v5 + v6;
      int v14 = *v8;
      uint64_t v15 = v5;
      do
      {
        uint64_t v16 = v6 - v9;
        if (v16 == -1) {
          break;
        }
        int v17 = (char *)memchr(v15, v14, v16 + 1);
        if (!v17) {
          break;
        }
        uint64_t v18 = v17;
        if (!memcmp(v17, v8, v9))
        {
          if (v18 == v13 || v18 - (char *)v5 == -1) {
            break;
          }
          return *(unsigned int *)(v2 + 56);
        }
        uint64_t v15 = v18 + 1;
        uint64_t v6 = v13 - (v18 + 1);
      }
      while (v6 >= v9);
    }
    uint64_t v10 = *(void **)(v2 + 8);
    if (v10)
    {
      do
      {
        int v11 = v10;
        uint64_t v10 = (void *)*v10;
      }
      while (v10);
    }
    else
    {
      do
      {
        int v11 = *(void **)(v2 + 16);
        BOOL v12 = *v11 == v2;
        uint64_t v2 = (uint64_t)v11;
      }
      while (!v12);
    }
    uint64_t v2 = (uint64_t)v11;
    if (v11 == (void *)&unk_100A19A40) {
      return 0;
    }
  }
}

void sub_100289F60(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v27 = *(_DWORD *)(a2 + 128);
  __int16 v28 = *(_WORD *)(a2 + 132);
  v25[0] = 0;
  v25[1] = 0;
  uint64_t v26 = 0;
  uint64_t v5 = sub_100480344(a2, 0xAu, v25);
  uint64_t v23 = 0;
  uint64_t v24 = 0;
  if ((a3 & 2) != 0 && sub_1002898E0(v5, (_DWORD *)a2)) {
    int v6 = sub_10048E1C4((_DWORD *)a2, (_DWORD *)&v24 + 1, &v24, (_DWORD *)&v23 + 1, &v23);
  }
  else {
    int v6 = sub_10047B7A8(a2, (_DWORD *)&v24 + 1, &v24, (_DWORD *)&v23 + 1, &v23);
  }
  if (*(char *)(a2 + 1503) < 0)
  {
    int v6 = sub_10003B098(__p, *(void **)(a2 + 1480), *(void *)(a2 + 1488));
  }
  else
  {
    *(_OWORD *)std::string __p = *(_OWORD *)(a2 + 1480);
    uint64_t v22 = *(void *)(a2 + 1496);
  }
  unsigned int v7 = sub_100289E20(v6, __p);
  if (SHIBYTE(v22) < 0) {
    operator delete(__p[0]);
  }
  id v20 = 0;
  if (v7 > 3) {
    CFStringRef v8 = @"Unknown";
  }
  else {
    CFStringRef v8 = (const __CFString *)*((void *)&off_1009A2210 + (int)v7);
  }
  CFStringRef v15 = v8;
  NSAppendPrintF_safe();
  id v9 = v20;
  v31[0] = 0;
  v31[1] = 0;
  int v32 = 0;
  v29[0] = 0;
  v29[1] = 0;
  int v30 = 0;
  sub_100482A04(a2, (uint64_t)v31);
  sub_100482A38(a2, (uint64_t)v29);
  uint64_t v10 = +[NSData dataWithBytes:length:](NSData, "dataWithBytes:length:", v31, 20, v15);
  int v11 = +[NSData dataWithBytes:v29 length:20];
  uint64_t v12 = sub_100050530();
  int v18 = v27;
  __int16 v19 = v28;
  uint64_t v14 = HIDWORD(v23);
  uint64_t v13 = v24;
  if (SHIBYTE(v26) < 0)
  {
    sub_10003B098(__dst, v25[0], (unint64_t)v25[1]);
  }
  else
  {
    *(_OWORD *)long long __dst = *(_OWORD *)v25;
    uint64_t v17 = v26;
  }
  (*(void (**)(uint64_t, int *, uint64_t, uint64_t, uint64_t, void **, id, void *, void *))(*(void *)v12 + 360))(v12, &v18, a3, v13, v14, __dst, v9, v10, v11);
  if (SHIBYTE(v17) < 0) {
    operator delete(__dst[0]);
  }

  if (SHIBYTE(v26) < 0) {
    operator delete(v25[0]);
  }
}

void sub_10028A1EC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,void *__p,uint64_t a26,int a27,__int16 a28,char a29,char a30)
{
  if (a30 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10028A258(uint64_t a1, uint64_t a2, unsigned int a3)
{
  v24[0] = 0;
  v24[1] = 0;
  sub_10003AED0((uint64_t)v24, a1 + 360);
  uint64_t v6 = sub_100017768();
  if (((*(unsigned int (**)(uint64_t))(*(void *)v6 + 712))(v6) & (a3 >> 9)) == 1)
  {
    unsigned int v7 = qword_100A19E38;
    BOOL v8 = os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT);
    if (v8)
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "GAPA hide auth fail", buf, 2u);
    }
    sub_100289F60(v8, a2, a3 | 2);
  }
  else
  {
    uint64_t v9 = sub_10047ECFC(a2);
    if ((v9 & 2) != 0)
    {
      uint64_t v14 = qword_100A19E38;
      if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)long long buf = 67109120;
        *(_DWORD *)&uint8_t buf[4] = a3;
        _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "Add new GAPA bits 0x%x", buf, 8u);
      }
      sub_10047ED44(a2, a3, a3);
    }
    else
    {
      int v10 = sub_1002898E0(v9, (_DWORD *)a2);
      uint64_t v11 = a3 | 2;
      uint64_t v12 = qword_100A19E38;
      BOOL v13 = os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT);
      if (v10)
      {
        if (v13)
        {
          *(_DWORD *)long long buf = 67109120;
          *(_DWORD *)&uint8_t buf[4] = v11;
          _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "Zero device GAPA 0x%x", buf, 8u);
        }
        sub_10048E1E8(a2);
        sub_10047C89C(a2, 0, 0, 0, 0);
        sub_10047CC64(a2, 0, 0);
        sub_10047CF64(a2, 0, 0);
        sub_100486E34(a2);
      }
      else if (v13)
      {
        *(_DWORD *)long long buf = 67109120;
        *(_DWORD *)&uint8_t buf[4] = v11;
        _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "Limited morph device GAPA 0x%x", buf, 8u);
      }
      uint64_t v15 = sub_10047ED44(a2, v11, v11);
      sub_100289F60(v15, a2, v11);
      int v17 = *(unsigned __int8 *)(a2 + 1435);
      memset(buf, 0, sizeof(buf));
      uint64_t v32 = 0;
      if (*(char *)(a2 + 1503) < 0)
      {
        int v16 = sub_10003B098(buf, *(void **)(a2 + 1480), *(void *)(a2 + 1488));
      }
      else
      {
        *(_OWORD *)long long buf = *(_OWORD *)(a2 + 1480);
        uint64_t v32 = *(void *)(a2 + 1496);
      }
      if (SHIBYTE(v32) < 0)
      {
        int v16 = sub_10003B098(__p, *(void **)buf, *(unint64_t *)&buf[8]);
      }
      else
      {
        *(_OWORD *)std::string __p = *(_OWORD *)buf;
        uint64_t v23 = v32;
      }
      int v18 = sub_100289E20(v16, __p);
      if (SHIBYTE(v23) < 0) {
        operator delete(__p[0]);
      }
      __int16 v19 = qword_100A19E38;
      if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
      {
        id v20 = buf;
        if (v32 < 0) {
          id v20 = *(uint8_t **)buf;
        }
        *(_DWORD *)__int16 v25 = 67109634;
        int v26 = v17;
        __int16 v27 = 1024;
        int v28 = v18;
        __int16 v29 = 2080;
        int v30 = v20;
        _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "GAPA alert control userConnected=%d, deviceStartSession=%d (%s)", v25, 0x18u);
      }
      if (v17 && v18 == 1) {
        sub_1002893FC(a1, a2);
      }
      if (SHIBYTE(v32) < 0) {
        operator delete(*(void **)buf);
      }
    }
  }
  return sub_10003AFB4((uint64_t)v24);
}

void sub_10028A5FC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *__p, uint64_t a20,int a21,__int16 a22,char a23,char a24)
{
}

void sub_10028A634(uint64_t a1, uint64_t a2)
{
  if ((_os_feature_enabled_impl() & 1) == 0)
  {
    uint64_t v13 = qword_100A19E38;
    if (!os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT)) {
      return;
    }
    sub_100474E18(a2, __p);
    if (v46[0] >= 0) {
      uint64_t v14 = __p;
    }
    else {
      uint64_t v14 = *(unsigned char **)__p;
    }
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = v14;
    int v10 = "GAPA non-auth disabled for \"%s\"";
LABEL_18:
    uint64_t v11 = v13;
    uint32_t v12 = 12;
LABEL_19:
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, v10, buf, v12);
    if (SHIBYTE(v46[0]) < 0) {
      operator delete(*(void **)__p);
    }
    return;
  }
  uint64_t v4 = sub_100017768();
  if (((*(uint64_t (**)(uint64_t))(*(void *)v4 + 736))(v4) & 1) == 0)
  {
    uint64_t v15 = qword_100A19E38;
    if (!os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT)) {
      return;
    }
    *(_WORD *)std::string __p = 0;
    int v16 = "GAPA non-auth is disabled by defaults write";
LABEL_25:
    int v17 = v15;
    uint32_t v18 = 2;
    goto LABEL_26;
  }
  uint64_t v5 = sub_100035F54();
  if (((*(uint64_t (**)(uint64_t))(*(void *)v5 + 328))(v5) & 1) == 0)
  {
    uint64_t v15 = qword_100A19E38;
    if (!os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT)) {
      return;
    }
    *(_WORD *)std::string __p = 0;
    int v16 = "GAPA non-auth is disabled for this OS";
    goto LABEL_25;
  }
  if (qword_1009F7F00 != -1) {
    dispatch_once(&qword_1009F7F00, &stru_1009A1E70);
  }
  if ((sub_1004AB1F0((uint64_t)off_1009F7EF8) & 1) == 0)
  {
    uint64_t v13 = qword_100A19E38;
    if (!os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT)) {
      return;
    }
    sub_100474E18(a2, __p);
    if (v46[0] >= 0) {
      __int16 v19 = __p;
    }
    else {
      __int16 v19 = *(unsigned char **)__p;
    }
    *(_DWORD *)long long buf = 136446210;
    *(void *)&uint8_t buf[4] = v19;
    int v10 = "Device has not been unlocked (or device prefs not read yet) - disabling GAPA non-auth for %{public}s";
    goto LABEL_18;
  }
  int v6 = sub_10047ECFC(a2);
  if (v6)
  {
    int v7 = v6;
    uint64_t v8 = qword_100A19E38;
    if (!os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT)) {
      return;
    }
    sub_100474E18(a2, __p);
    if (v46[0] >= 0) {
      uint64_t v9 = __p;
    }
    else {
      uint64_t v9 = *(unsigned char **)__p;
    }
    *(_DWORD *)long long buf = 136315394;
    *(void *)&uint8_t buf[4] = v9;
    __int16 v41 = 1024;
    int v42 = v7;
    int v10 = "Known GAPA result for \"%s\" cbGAPAFlags=0x%x non-auth not supported";
    uint64_t v11 = v8;
    uint32_t v12 = 18;
    goto LABEL_19;
  }
  uint64_t v38 = 0;
  uint64_t v39 = 0;
  sub_10047B7A8(a2, (_DWORD *)&v39 + 1, &v39, (_DWORD *)&v38 + 1, &v38);
  if (!sub_100478AF4(a2)
    || (+[CBProductInfo productInfoWithProductID:](CBProductInfo, "productInfoWithProductID:", HIDWORD(v38)), id v20 = objc_claimAutoreleasedReturnValue(), v21 = ((unsigned __int16)[v20 flags] & 0x800) == 0, v20, v21))
  {
    uint64_t v23 = qword_100A19E38;
    if (!os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT)) {
      return;
    }
    *(_DWORD *)std::string __p = 67109888;
    *(_DWORD *)&__p[4] = HIDWORD(v39);
    *(_WORD *)&__p[8] = 1024;
    *(_DWORD *)&__p[10] = v39;
    *(_WORD *)uint64_t v45 = 1024;
    *(_DWORD *)&v45[2] = HIDWORD(v38);
    LOWORD(v46[0]) = 1024;
    *(_DWORD *)((char *)v46 + 2) = v38;
    int v16 = "No GAPA non-auth for vidSrc=%d, vid=0x%x, pid=0x%x, version=%d";
    int v17 = v23;
    uint32_t v18 = 26;
LABEL_26:
    _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, v16, __p, v18);
    return;
  }
  int v24 = sub_1002898E0(v22, (_DWORD *)a2);
  if ((v24 ^ 1 | sub_100478B2C(a2, 42)))
  {
    unsigned int v25 = 0;
  }
  else
  {
    int v26 = qword_100A19E38;
    if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
    {
      sub_100474E18(a2, buf);
      __int16 v27 = v43 >= 0 ? buf : *(unsigned char **)buf;
      *(_DWORD *)std::string __p = 136315650;
      *(void *)&__p[4] = v27;
      *(_WORD *)&unsigned char __p[12] = 1024;
      *(_DWORD *)uint64_t v45 = HIDWORD(v38);
      *(_WORD *)&v45[4] = 1024;
      v46[0] = 0;
      _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "Invalid device configuration \"%s\" pid=0x%x deviceInfoGAPA=%d", __p, 0x18u);
      if (v43 < 0) {
        operator delete(*(void **)buf);
      }
    }
    unsigned int v25 = 1024;
  }
  unsigned __int16 v37 = 0;
  char v36 = 0;
  __int16 v35 = 0;
  if (sub_10047D450(a2, &v37, &v36, &v35))
  {
    uint64_t v28 = sub_100017768();
    if ((*(unsigned int (**)(uint64_t))(*(void *)v28 + 720))(v28))
    {
      unsigned __int16 v37 = 1494;
      goto LABEL_50;
    }
    if (v37 != 76)
    {
LABEL_50:
      __int16 v29 = qword_100A19E38;
      if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
      {
        sub_100474E18(a2, __p);
        int v30 = v46[0] >= 0 ? __p : *(unsigned char **)__p;
        *(_DWORD *)long long buf = 136315394;
        *(void *)&uint8_t buf[4] = v30;
        __int16 v41 = 1024;
        int v42 = v37;
        _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEFAULT, "GAPA detect for \"%s\" is mfgName=0x%x", buf, 0x12u);
        if (SHIBYTE(v46[0]) < 0) {
          operator delete(*(void **)__p);
        }
      }
      v25 |= 4u;
    }
  }
  uint64_t v31 = sub_100050530();
  int v33 = *(_DWORD *)(a2 + 128);
  __int16 v34 = *(_WORD *)(a2 + 132);
  (*(void (**)(uint64_t, int *, void, void))(*(void *)v31 + 368))(v31, &v33, 0, 0);
  *(void *)std::string __p = a2 + 128;
  sub_1002B40A4((uint64_t **)(a1 + 536), a2 + 128, (uint64_t)&unk_1007BE9D0, (_DWORD **)__p)[31] = 1;
  uint64_t v32 = qword_100A19E38;
  if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)std::string __p = 67109120;
    *(_DWORD *)&__p[4] = v25;
    _os_log_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_DEFAULT, "GAPA non-auth detect is complete flags=0x%x", __p, 8u);
  }
  if (v25) {
    sub_10028A258(a1, a2, v25);
  }
  if (qword_1009F8080 != -1) {
    dispatch_once(&qword_1009F8080, &stru_1009A1E50);
  }
  sub_10049FF74((uint64_t)off_1009F8078, a2, 4102);
}

void sub_10028ACE8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL sub_10028AD00(uint64_t a1, uint64_t a2)
{
  return sub_1002B4214(a1 + 536, a2 + 128) == 1;
}

uint64_t sub_10028AD28(uint64_t a1, _DWORD *a2, uint64_t a3, char a4)
{
  if ((_os_feature_enabled_impl() & 1) == 0)
  {
    uint64_t v17 = qword_100A19E38;
    BOOL v18 = os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT);
    uint64_t result = 0;
    if (!v18) {
      return result;
    }
    sub_100474E18((uint64_t)a2, __p);
    if (v51[0] >= 0) {
      __int16 v19 = __p;
    }
    else {
      __int16 v19 = *(unsigned char **)__p;
    }
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = v19;
    int v16 = "GAPA auth disabled for \"%s\"";
    goto LABEL_18;
  }
  uint64_t v8 = sub_100017768();
  if (((*(uint64_t (**)(uint64_t))(*(void *)v8 + 728))(v8) & 1) == 0)
  {
    uint64_t v22 = qword_100A19E38;
    BOOL v23 = os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT);
    uint64_t result = 0;
    if (!v23) {
      return result;
    }
    *(_WORD *)std::string __p = 0;
    int v24 = "GAPA auth is disabled by defaults write";
    goto LABEL_25;
  }
  uint64_t v9 = sub_100035F54();
  if (((*(uint64_t (**)(uint64_t))(*(void *)v9 + 328))(v9) & 1) == 0)
  {
    uint64_t v22 = qword_100A19E38;
    BOOL v25 = os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT);
    uint64_t result = 0;
    if (!v25) {
      return result;
    }
    *(_WORD *)std::string __p = 0;
    int v24 = "GAPA auth is disabled for this OS";
    goto LABEL_25;
  }
  if (qword_1009F7F00 != -1) {
    dispatch_once(&qword_1009F7F00, &stru_1009A1E70);
  }
  if ((sub_1004AB1F0((uint64_t)off_1009F7EF8) & 1) == 0)
  {
    uint64_t v17 = qword_100A19E38;
    BOOL v28 = os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT);
    uint64_t result = 0;
    if (!v28) {
      return result;
    }
    sub_100474E18((uint64_t)a2, __p);
    if (v51[0] >= 0) {
      __int16 v29 = __p;
    }
    else {
      __int16 v29 = *(unsigned char **)__p;
    }
    *(_DWORD *)long long buf = 136446210;
    *(void *)&uint8_t buf[4] = v29;
    int v16 = "Device has not been unlocked (or device prefs not read yet) - disabling GAPA auth for %{public}s";
LABEL_18:
    id v20 = v17;
    uint32_t v21 = 12;
    goto LABEL_19;
  }
  int v10 = sub_10047ECFC((uint64_t)a2);
  if (v10)
  {
    int v11 = v10;
    uint64_t v12 = qword_100A19E38;
    BOOL v13 = os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT);
    uint64_t result = 0;
    if (!v13) {
      return result;
    }
    sub_100474E18((uint64_t)a2, __p);
    if (v51[0] >= 0) {
      uint64_t v15 = __p;
    }
    else {
      uint64_t v15 = *(unsigned char **)__p;
    }
    *(_DWORD *)long long buf = 136315394;
    *(void *)&uint8_t buf[4] = v15;
    __int16 v46 = 1024;
    int v47 = v11;
    int v16 = "Known GAPA result for \"%s\" cbGAPAFlags=0x%x auth not supported";
    goto LABEL_40;
  }
  int v30 = *(_DWORD *)(a3 + 600);
  if (!v30)
  {
    uint64_t v43 = 0;
    uint64_t v44 = 0;
    sub_10047B7A8((uint64_t)a2, (_DWORD *)&v44 + 1, &v44, (_DWORD *)&v43 + 1, &v43);
    if (!sub_100478AF4((uint64_t)a2)
      || (+[CBProductInfo productInfoWithProductID:](CBProductInfo, "productInfoWithProductID:", HIDWORD(v43)), int v33 = objc_claimAutoreleasedReturnValue(), v34 = ((unsigned __int16)[v33 flags] & 0x800) == 0, v33, v34))
    {
      uint64_t v35 = qword_100A19E38;
      BOOL v36 = os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT);
      uint64_t result = 0;
      if (!v36) {
        return result;
      }
      *(_DWORD *)std::string __p = 67109888;
      *(_DWORD *)&__p[4] = HIDWORD(v44);
      *(_WORD *)&__p[8] = 1024;
      *(_DWORD *)&__p[10] = v44;
      *(_WORD *)int v50 = 1024;
      *(_DWORD *)&v50[2] = HIDWORD(v43);
      LOWORD(v51[0]) = 1024;
      *(_DWORD *)((char *)v51 + 2) = v43;
      int v24 = "No GAPA auth for vidSrc=%d, vid=0x%x, pid=0x%x, version=%d";
      int v26 = v35;
      uint32_t v27 = 26;
LABEL_26:
      _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, v24, __p, v27);
      return 0;
    }
    uint64_t v37 = sub_100478B2C((uint64_t)a2, 42);
    if (v37)
    {
      int v38 = sub_1002898E0(v37, a2);
      uint64_t result = 1;
      if (v38 && (a4 & 1) == 0)
      {
        uint64_t v39 = qword_100A19E38;
        if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
        {
          sub_100474E18((uint64_t)a2, buf);
          int v40 = v48 >= 0 ? buf : *(unsigned char **)buf;
          *(_DWORD *)std::string __p = 136315650;
          *(void *)&__p[4] = v40;
          *(_WORD *)&unsigned char __p[12] = 1024;
          *(_DWORD *)int v50 = HIDWORD(v43);
          *(_WORD *)&v50[4] = 1024;
          v51[0] = 0;
          _os_log_impl((void *)&_mh_execute_header, v39, OS_LOG_TYPE_DEFAULT, "Invalid device configuration \"%s\" pid=0x%x isCertificateSupported=%d", __p, 0x18u);
          if (v48 < 0) {
            operator delete(*(void **)buf);
          }
        }
        uint64_t v41 = sub_100017768();
        if ((*(uint64_t (**)(uint64_t))(*(void *)v41 + 760))(v41)) {
          return 1;
        }
        sub_10028A258(a1, (uint64_t)a2, 0x100u);
        return 0;
      }
      return result;
    }
    uint64_t v22 = qword_100A19E38;
    BOOL v42 = os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT);
    uint64_t result = 0;
    if (!v42) {
      return result;
    }
    *(_WORD *)std::string __p = 0;
    int v24 = "Accessory device does not support GAPA auth not supported";
LABEL_25:
    int v26 = v22;
    uint32_t v27 = 2;
    goto LABEL_26;
  }
  uint64_t v12 = qword_100A19E38;
  BOOL v31 = os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT);
  uint64_t result = 0;
  if (v31)
  {
    sub_100474E18((uint64_t)a2, __p);
    if (v51[0] >= 0) {
      uint64_t v32 = __p;
    }
    else {
      uint64_t v32 = *(unsigned char **)__p;
    }
    *(_DWORD *)long long buf = 136315394;
    *(void *)&uint8_t buf[4] = v32;
    __int16 v46 = 1024;
    int v47 = v30;
    int v16 = "Invalid GAPA state for \"%s\" authState=%d auth not supported";
LABEL_40:
    id v20 = v12;
    uint32_t v21 = 18;
LABEL_19:
    _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, v16, buf, v21);
    if (SHIBYTE(v51[0]) < 0) {
      operator delete(*(void **)__p);
    }
    return 0;
  }
  return result;
}

void sub_10028B2F8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_10028B310(uint64_t a1, uint64_t a2)
{
  if (*(unsigned char *)(a1 + 328))
  {
    if (qword_1009FB140 != -1) {
      dispatch_once(&qword_1009FB140, &stru_1009A1EB0);
    }
    v4[0] = _NSConcreteStackBlock;
    v4[1] = 3221225472;
    _DWORD v4[2] = sub_10028B3C4;
    v4[3] = &unk_100998260;
    v4[4] = a1;
    void v4[5] = a2;
    sub_1004C9DF0((uint64_t)off_1009FB138, v4);
  }
}

void sub_10028B3C4(uint64_t a1)
{
}

uint64_t sub_10028B3D0(uint64_t a1, uint64_t a2, uint64_t a3, int a4, char a5)
{
  if (!*(unsigned char *)(a1 + 328)) {
    return 111;
  }
  if (!a2) {
    return 8;
  }
  v40[0] = 0;
  v40[1] = 0;
  sub_10003AED0((uint64_t)v40, a1 + 360);
  for (uint64_t i = *(void ***)(a1 + 336); i != *(void ***)(a1 + 344); ++i)
  {
    int v11 = *i;
    if (**i == a2)
    {
      BOOL v13 = qword_100A19E38;
      if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
      {
        sub_100474E18(a2, __p);
        int v14 = v39;
        uint64_t v15 = (void **)__p[0];
        uint64_t v23 = sub_10025B48C(a3, v16, v17, v18, v19, v20, v21, v22);
        int v24 = __p;
        if (v14 < 0) {
          int v24 = v15;
        }
        if ((a4 - 1) > 2) {
          BOOL v25 = "Unknown";
        }
        else {
          BOOL v25 = off_1009A2230[a4 - 1];
        }
        *(_DWORD *)long long buf = 136446722;
        BOOL v42 = v24;
        __int16 v43 = 2080;
        uint64_t v44 = v23;
        __int16 v45 = 2082;
        __int16 v46 = v25;
        _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "setDeviceStateOnPeerSrc: device %{public}s, peer source \"%s\", device state %{public}s", buf, 0x20u);
        if (v39 < 0) {
          operator delete(__p[0]);
        }
      }
      if ((a5 & 1) == 0)
      {
        int v26 = sub_10028B72C(a1, a2) ^ 1;
        if (a4 != 3) {
          LOBYTE(v26) = 1;
        }
        if ((v26 & 1) == 0
          && *(_DWORD *)a3 == dword_1009FB110
          && *(unsigned __int16 *)(a3 + 4) == (unsigned __int16)word_1009FB114)
        {
          BOOL v28 = qword_100A19E38;
          if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)long long buf = 0;
            _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, "setDeviceStateOnPeerSrc: Triangle recovery begun; starting easy pairing agent first",
              buf,
              2u);
          }
          *((unsigned char *)v11 + 728) = 1;
          sub_10028B794(a1, v11);
        }
      }
      if (*(_DWORD *)a3 != dword_1009FB110 || *(unsigned __int16 *)(a3 + 4) != (unsigned __int16)word_1009FB114)
      {
        int v36 = *(_DWORD *)a3;
        __int16 v37 = *(_WORD *)(a3 + 4);
        sub_10028B8F4((uint64_t)v11, (unsigned __int8 *)&v36, a4);
        LOWORD(v42) = 0;
        *(_DWORD *)long long buf = 0;
        if (qword_1009F8070 != -1) {
          dispatch_once(&qword_1009F8070, &stru_1009A1D70);
        }
        sub_1004E219C((uint64_t)off_1009F8068, (uint64_t)buf);
        int v34 = *(_DWORD *)buf;
        __int16 v35 = (__int16)v42;
        int v32 = *(_DWORD *)a3;
        __int16 v33 = *(_WORD *)(a3 + 4);
        sub_10028BA10((uint64_t)v11, (uint64_t)&v34, (uint64_t)&v32);
        BOOL v30 = sub_10028BC74((uint64_t)v11);
        sub_10028BB94(v30, a2, v30);
      }
      uint64_t v12 = 0;
      goto LABEL_40;
    }
  }
  if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_ERROR)) {
    sub_10074E354();
  }
  uint64_t v12 = 312;
LABEL_40:
  sub_10003AFB4((uint64_t)v40);
  return v12;
}

void sub_10028B6F0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, char a18)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  sub_10003AFB4((uint64_t)&a18);
  _Unwind_Resume(a1);
}

uint64_t sub_10028B72C(uint64_t a1, uint64_t a2)
{
  if (!*(unsigned char *)(a1 + 430)) {
    return 0;
  }
  if (*(unsigned char *)(a1 + 424))
  {
    BOOL v2 = 0;
    if (!a2) {
      return 0;
    }
  }
  else
  {
    unint64_t v3 = 0;
    do
    {
      unint64_t v4 = v3;
      if (v3 == 5) {
        break;
      }
      ++v3;
    }
    while (!*(unsigned char *)(a1 + 425 + v4));
    BOOL v2 = v4 > 4;
    if (!a2) {
      return 0;
    }
  }
  if (v2 || *(unsigned char *)(a2 + 960)) {
    return 0;
  }
  return sub_100478B2C(a2, 12);
}

void sub_10028B794(uint64_t a1, uint64_t *a2)
{
  sub_1002A8C98(a2);
  uint64_t v4 = *a2;
  if (sub_10028B72C(a1, *a2))
  {
    uint64_t v5 = a2[6];
    if (v5)
    {
      int v6 = qword_100A19E38;
      if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
      {
        sub_100474E18(v4, __p);
        if (v10 >= 0) {
          int v7 = __p;
        }
        else {
          int v7 = (void **)__p[0];
        }
        *(_DWORD *)long long buf = 136446210;
        uint64_t v12 = v7;
        _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "startEasyPairAgent: starting easy pair agent for %{public}s", buf, 0xCu);
        if (v10 < 0) {
          operator delete(__p[0]);
        }
      }
      sub_100278AB4(v5);
    }
  }
  else
  {
    uint64_t v8 = qword_100A19E38;
    if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(__p[0]) = 0;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "startEasyPairAgent: Cannot use magnet link", (uint8_t *)__p, 2u);
    }
  }
}

char *sub_10028B8F4(uint64_t a1, unsigned __int8 *a2, int a3)
{
  int v6 = qword_100A19E38;
  if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
  {
    sub_1004A82EC(a2, __p);
    if (v10 >= 0) {
      int v7 = __p;
    }
    else {
      int v7 = (void **)__p[0];
    }
    *(_DWORD *)long long buf = 136446466;
    uint64_t v12 = v7;
    __int16 v13 = 1024;
    int v14 = a3;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "fSrcConnMap Setting %{public}s to %d", buf, 0x12u);
    if (v10 < 0) {
      operator delete(__p[0]);
    }
  }
  __p[0] = a2;
  uint64_t result = sub_1002B40A4((uint64_t **)(a1 + 704), (uint64_t)a2, (uint64_t)&unk_1007BE9D0, (_DWORD **)__p);
  result[31] = a3;
  return result;
}

void sub_10028BA10(uint64_t a1, uint64_t a2, uint64_t a3)
{
  __int16 v29 = 0;
  int v28 = 0;
  if (qword_1009F8070 != -1) {
    dispatch_once(&qword_1009F8070, &stru_1009A1D70);
  }
  sub_1004E219C((uint64_t)off_1009F8068, (uint64_t)&v28);
  int v6 = *(_DWORD *)a2;
  *(_WORD *)(a1 + 609) = *(_WORD *)(a2 + 4);
  *(_DWORD *)(a1 + 605) = v6;
  LOWORD(v6) = *(_WORD *)(a3 + 4);
  *(_DWORD *)(a1 + 611) = *(_DWORD *)a3;
  *(_WORD *)(a1 + 615) = v6;
  BOOL v8 = v28 != *(_DWORD *)a3 || v29 != *(_WORD *)(a3 + 4);
  *(unsigned char *)(a1 + 617) = v8;
  uint64_t v9 = qword_100A19E38;
  if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v17 = sub_10025B48C(a2, v10, v11, v12, v13, v14, v15, v16);
    uint64_t v25 = sub_10025B48C(a3, v18, v19, v20, v21, v22, v23, v24);
    int v26 = *(unsigned __int8 *)(a1 + 617);
    *(_DWORD *)long long buf = 136446722;
    uint64_t v31 = v17;
    if (v26) {
      uint32_t v27 = "Yes";
    }
    else {
      uint32_t v27 = "No";
    }
    __int16 v32 = 2082;
    uint64_t v33 = v25;
    __int16 v34 = 2080;
    __int16 v35 = v27;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "Set source addresses in TiPi, primaryAddr \"%{public}s\", tipiAddr \"%{public}s\", is_primary = \"%s\" ", buf, 0x20u);
  }
}

uint64_t sub_10028BB94(uint64_t a1, uint64_t a2, char a3)
{
  uint64_t v5 = sub_1004AFA9C();
  v10[0] = _NSConcreteStackBlock;
  v10[1] = 3221225472;
  void v10[2] = sub_1002AFCCC;
  _OWORD v10[3] = &unk_100998A58;
  char v10[4] = a2;
  char v11 = a3;
  sub_100013018(v5, v10);
  uint64_t v6 = sub_1004AFB34();
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 3221225472;
  void v8[2] = sub_1002AFD34;
  void v8[3] = &unk_100998A58;
  void v8[4] = a2;
  char v9 = a3;
  sub_100013018(v6, v8);
  return 0;
}

BOOL sub_10028BC74(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 617)) {
    BOOL v2 = (int *)(a1 + 611);
  }
  else {
    BOOL v2 = (int *)(a1 + 605);
  }
  int v5 = *v2;
  __int16 v6 = *((_WORD *)v2 + 2);
  uint64_t v3 = sub_1002B3CF4(a1 + 704, (uint64_t)&v5);
  return a1 + 712 != v3 && *(unsigned char *)(v3 + 31) == 1;
}

uint64_t sub_10028BCF0(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 520);
}

uint64_t sub_10028BCF8(uint64_t a1, uint64_t a2, int a3)
{
  __int16 v6 = qword_100A19E38;
  BOOL v7 = os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT);
  if (v7)
  {
    BOOL v8 = "Legacy Connection";
    if (a3) {
      BOOL v8 = "TiPi Connection";
    }
    int v10 = 136446210;
    char v11 = v8;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "Notify Connection update: %{public}s", (uint8_t *)&v10, 0xCu);
  }
  sub_10028BB94(v7, a2, a3);
  *(unsigned char *)(a1 + 520) = a3;
  return 0;
}

uint64_t sub_10028BDD8(uint64_t a1, uint64_t a2)
{
  v9[0] = 0;
  v9[1] = 0;
  sub_10003AED0((uint64_t)v9, a1 + 360);
  if (a2)
  {
    for (uint64_t i = *(void ***)(a1 + 336); i != *(void ***)(a1 + 344); ++i)
    {
      if (**i == a2)
      {
        char v8 = 0;
        sub_10001B8E0(&v8);
        uint64_t v7 = sub_1000D9BFC((unsigned __int8 *)(a2 + 128));
        sub_10001B910(&v8);
        if (v7 && os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_ERROR)) {
          sub_10074E3BC();
        }
        if (qword_1009F8070 != -1) {
          dispatch_once(&qword_1009F8070, &stru_1009A1D70);
        }
        uint64_t v5 = sub_1004E2340((uint64_t)off_1009F8068, v7, 10000);
        sub_10001B8AC(&v8);
        goto LABEL_9;
      }
    }
  }
  if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_ERROR)) {
    sub_10074E388();
  }
  uint64_t v5 = 312;
LABEL_9:
  sub_10003AFB4((uint64_t)v9);
  return v5;
}

void sub_10028BF10(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  sub_10003AFB4((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_10028BF34(int a1@<W1>, uint64_t a2@<X8>)
{
  *(void *)a2 = 0;
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = 0;
  if (qword_1009F7F00 != -1) {
    dispatch_once(&qword_1009F7F00, &stru_1009A1E70);
  }
  uint64_t v16 = 0;
  uint64_t v17 = 0;
  uint64_t v18 = 0;
  sub_1004AC984((uint64_t)off_1009F7EF8, a1, (void **)&v16);
  uint64_t v4 = v16;
  uint64_t v5 = v17;
  if (v16 != v17)
  {
    while (1)
    {
      uint64_t v6 = *v4;
      if ((sub_100478B2C(*v4, 3) & 1) == 0)
      {
LABEL_24:
        uint64_t v4 = v16;
        goto LABEL_25;
      }
      __p[0] = 0;
      __p[1] = 0;
      uint64_t v15 = 0;
      sub_100480344(v6, 3u, __p);
      unint64_t v7 = HIBYTE(v15);
      int v8 = SHIBYTE(v15);
      if (v15 < 0) {
        unint64_t v7 = (unint64_t)__p[1];
      }
      if (v7 >= 2) {
        break;
      }
      if (v15 < 0) {
        goto LABEL_9;
      }
LABEL_10:
      if (++v4 == v5) {
        goto LABEL_24;
      }
    }
    char v9 = qword_100A19E38;
    if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
    {
      int v10 = (void **)__p[0];
      if (v8 >= 0) {
        int v10 = __p;
      }
      *(_DWORD *)long long buf = 136446466;
      uint64_t v20 = v10;
      __int16 v21 = 1024;
      int v22 = a1;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "getCaseSerialNumbersForAppleProductId: Retrieved serial number %{public}s belonging to pId %u", buf, 0x12u);
    }
    unint64_t v11 = *(void *)(a2 + 8);
    if (v11 >= *(void *)(a2 + 16))
    {
      uint64_t v13 = sub_1002B42D4((char **)a2, (long long *)__p);
    }
    else
    {
      if (SHIBYTE(v15) < 0)
      {
        sub_10003B098(*(unsigned char **)(a2 + 8), __p[0], (unint64_t)__p[1]);
      }
      else
      {
        long long v12 = *(_OWORD *)__p;
        *(void *)(v11 + 16) = v15;
        *(_OWORD *)unint64_t v11 = v12;
      }
      uint64_t v13 = (char *)(v11 + 24);
      *(void *)(a2 + 8) = v11 + 24;
    }
    *(void *)(a2 + 8) = v13;
    if ((v15 & 0x8000000000000000) == 0) {
      goto LABEL_10;
    }
LABEL_9:
    operator delete(__p[0]);
    goto LABEL_10;
  }
LABEL_25:
  if (v4)
  {
    uint64_t v17 = v4;
    operator delete(v4);
  }
}

void sub_10028C168(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, void *a17, uint64_t a18)
{
  v18[1] = v19;
  if (a16 < 0) {
    operator delete(__p);
  }
  if (a17)
  {
    a18 = (uint64_t)a17;
    operator delete(a17);
  }
  a17 = v18;
  sub_100051568((void ***)&a17);
  _Unwind_Resume(a1);
}

uint64_t sub_10028C1C0(uint64_t a1, uint64_t a2)
{
  v7[0] = 0;
  v7[1] = 0;
  sub_10003AED0((uint64_t)v7, a1 + 360);
  if (a2)
  {
    for (uint64_t i = *(void *)(a1 + 336); i != *(void *)(a1 + 344); i += 8)
    {
      if (**(void **)i == a2)
      {
        uint64_t v5 = *(unsigned int *)(*(void *)i + 16);
        goto LABEL_8;
      }
    }
  }
  uint64_t v5 = 3;
LABEL_8:
  sub_10003AFB4((uint64_t)v7);
  return v5;
}

uint64_t sub_10028C23C(uint64_t a1, unsigned char *a2)
{
  if (*a2)
  {
    if (*a2 != 1) {
      goto LABEL_20;
    }
    uint64_t v4 = sub_100035F54();
    if ((*(unsigned int (**)(uint64_t))(*(void *)v4 + 384))(v4))
    {
      uint64_t v5 = a2 + 5;
      if (a2[5] != 2)
      {
        int v6 = *(_DWORD *)(a1 + 512);
        if (v6 == -1)
        {
          unint64_t v7 = (int *)(a1 + 512);
          notify_register_check("com.apple.audioaccessoryd.MuteEducationalCard", v7);
          int v6 = *v7;
        }
        notify_set_state(v6, 1uLL);
        notify_post("com.apple.audioaccessoryd.MuteEducationalCard");
        goto LABEL_13;
      }
    }
    else
    {
      uint64_t v8 = sub_100035F54();
      if ((*(unsigned int (**)(uint64_t))(*(void *)v8 + 424))(v8))
      {
        uint64_t v5 = a2 + 5;
        if (a2[5] != 2)
        {
LABEL_13:
          *uint64_t v5 = 2;
          int v9 = 1;
LABEL_14:
          if (a2[6]) {
            BOOL v10 = a2[4] == 0;
          }
          else {
            BOOL v10 = 1;
          }
          if (v10 | v9)
          {
            a2[6] = 2;
            a2[4] = 3;
            goto LABEL_19;
          }
          goto LABEL_20;
        }
      }
    }
    int v9 = 0;
    goto LABEL_14;
  }
  if (!a2[2])
  {
    a2[2] = 2;
LABEL_19:
    uint64_t v11 = 1;
    goto LABEL_21;
  }
LABEL_20:
  uint64_t v11 = 0;
LABEL_21:
  long long v12 = qword_100A19E38;
  if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v13 = "No";
    if (v11) {
      uint64_t v13 = "Yes";
    }
    int v15 = 136315138;
    uint64_t v16 = v13;
    _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "Call Management: shouldSendDefault %s", (uint8_t *)&v15, 0xCu);
  }
  return v11;
}

void sub_10028C444(uint64_t a1, uint64_t a2, int a3, int a4)
{
  *(_DWORD *)((char *)v16 + 3) = 0;
  v16[0] = 0;
  if ((a4 & 0xF) == 1)
  {
    LOBYTE(v16[0]) = 1;
    HIBYTE(v16[0]) = a4 >> 4;
    LOBYTE(v16[1]) = BYTE1(a4) & 0xF;
    BYTE1(v16[1]) = (unsigned __int16)a4 >> 12;
    BYTE2(v16[1]) = BYTE2(a4) & 0xF;
  }
  else if ((a4 & 0xF) == 0)
  {
    LOBYTE(v16[0]) = 0;
    BYTE1(v16[0]) = a4 >> 4;
    BYTE2(v16[0]) = BYTE1(a4) & 0xF;
    HIBYTE(v16[0]) = a4 >> 4;
    LOBYTE(v16[1]) = BYTE1(a4) & 0xF;
  }
  if (sub_10028C23C(a1, v16))
  {
    unint64_t v7 = v16[0] | ((unint64_t)(LOWORD(v16[1]) | (BYTE2(v16[1]) << 16)) << 32);
    unsigned int v8 = (v16[0] >> 20) & 0xF0 | (v7 >> 24) & 0xF00 | (v7 >> 28) & 0xF000 | (LOWORD(v16[1]) | (BYTE2(v16[1]) << 16)) & 0xF0000 | 1;
    unsigned int v9 = (v16[0] >> 4) & 0xF0 | (v16[0] >> 8) & 0xF00;
    if (LOBYTE(v16[0])) {
      unsigned int v9 = 0;
    }
    if (LOBYTE(v16[0]) == 1) {
      uint64_t v10 = v8;
    }
    else {
      uint64_t v10 = v9;
    }
    int v11 = sub_1002859A4(a1, a2, 36, v10, 2u);
    long long v12 = qword_100A19E38;
    if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
    {
      sub_1002872A4(a1, a3, v10, __p);
      uint64_t v13 = v15 >= 0 ? __p : (void **)__p[0];
      *(_DWORD *)long long buf = 136446210;
      uint64_t v18 = v13;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "Call Management: sending default %{public}s", buf, 0xCu);
      if (v15 < 0) {
        operator delete(__p[0]);
      }
    }
    if (v11 == 1 && os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_ERROR)) {
      sub_10074E424();
    }
  }
}

uint64_t sub_10028C65C(uint64_t a1)
{
  int v2 = *(_DWORD *)(a1 + 508);
  if (v2 == -1)
  {
    uint64_t v3 = (int *)(a1 + 508);
    notify_register_check("com.apple.audioaccessoryd.MuteState", (int *)(a1 + 508));
    int v2 = *v3;
  }
  notify_set_state(v2, 1uLL);

  return notify_post("com.apple.audioaccessoryd.MuteState");
}

uint64_t sub_10028C6C0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  sub_100485628(a2, a3);
  uint64_t v6 = sub_1004BDB84(a1);
  if (v6)
  {
    uint64_t v6 = sub_1002859A4(a1, a2, 13, a3, 2u);
    uint64_t v7 = v6;
  }
  else
  {
    uint64_t v7 = 1;
  }
  sub_10028C738(v6, a2);
  return v7;
}

void sub_10028C738(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = qword_100A19E38;
  if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
  {
    sub_100475EE0(a2, (uint64_t)__p);
    if (v10 >= 0) {
      uint64_t v4 = __p;
    }
    else {
      uint64_t v4 = (void **)__p[0];
    }
    *(_DWORD *)long long buf = 136315138;
    long long v12 = v4;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Notify listen mode change for device \"%s\"", buf, 0xCu);
    if (v10 < 0) {
      operator delete(__p[0]);
    }
  }
  uint64_t v5 = sub_1004AFA9C();
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 3221225472;
  void v8[2] = sub_1002A8894;
  void v8[3] = &unk_100997528;
  void v8[4] = a2;
  sub_100013018(v5, v8);
  uint64_t v6 = sub_1004AFB34();
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 3221225472;
  void v7[2] = sub_1002A890C;
  void v7[3] = &unk_100997528;
  void v7[4] = a2;
  sub_100013018(v6, v7);
}

void sub_10028C8B4(uint64_t a1, uint64_t a2)
{
  int v3 = sub_10028CB30(a1, a2);
  unsigned __int8 v13 = v3;
  if (qword_1009F7F00 != -1) {
    dispatch_once(&qword_1009F7F00, &stru_1009A1E70);
  }
  if (sub_1004AB1F0((uint64_t)off_1009F7EF8))
  {
    uint64_t v4 = sub_1003708B0();
    int v5 = (*(uint64_t (**)(uint64_t, uint64_t, unsigned __int8 *))(*(void *)v4 + 864))(v4, a2, &v13);
    sub_100485460(a2, v13, v5 != 0);
    uint64_t v6 = qword_100A19E38;
    if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
    {
      if (v13) {
        uint64_t v7 = "enabled";
      }
      else {
        uint64_t v7 = "disabled";
      }
      sub_100474E18(a2, __p);
      if (v17 >= 0) {
        unsigned int v8 = __p;
      }
      else {
        unsigned int v8 = *(unsigned char **)__p;
      }
      unsigned int v9 = "Success";
      *(_DWORD *)long long buf = 136315650;
      if (v5) {
        unsigned int v9 = "Error";
      }
      *(void *)&uint8_t buf[4] = v7;
      __int16 v19 = 2082;
      uint64_t v20 = v8;
      __int16 v21 = 2080;
      int v22 = v9;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "Device unlocked, initializing IED enable to %s for device %{public}s with read %s", buf, 0x20u);
      if (v17 < 0) {
        operator delete(*(void **)__p);
      }
    }
  }
  else
  {
    char v10 = qword_100A19E38;
    if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
    {
      int v11 = v3 ? "enabled" : "disabled";
      sub_100474E18(a2, buf);
      long long v12 = v21 >= 0 ? buf : *(unsigned char **)buf;
      *(_DWORD *)std::string __p = 136315394;
      *(void *)&__p[4] = v11;
      __int16 v15 = 2082;
      uint64_t v16 = v12;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "Device not unlocked yet (or device prefs not read yet), initializing IED enable to %s for device %{public}s", __p, 0x16u);
      if (SHIBYTE(v21) < 0) {
        operator delete(*(void **)buf);
      }
    }
    sub_100485460(a2, v3, 0);
  }
}

uint64_t sub_10028CB30(uint64_t a1, uint64_t a2)
{
  if (!a2) {
    return 0;
  }
  uint64_t v3 = 1;
  if ((sub_100478B2C(a2, 1) & 1) == 0) {
    uint64_t v3 = sub_100478B2C(a2, 15);
  }
  uint64_t v4 = qword_100A19E38;
  if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_INFO))
  {
    sub_100474E18(a2, __p);
    int v5 = (void **)__p[0];
    uint64_t v6 = "false";
    if (v9 >= 0) {
      int v5 = __p;
    }
    if (v3) {
      uint64_t v6 = "true";
    }
    *(_DWORD *)long long buf = 136446466;
    int v11 = v5;
    __int16 v12 = 2082;
    unsigned __int8 v13 = v6;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_INFO, "In Ear detection support state for %{public}s is %{public}s", buf, 0x16u);
    if (v9 < 0) {
      operator delete(__p[0]);
    }
  }
  return v3;
}

uint64_t sub_10028CC64(uint64_t a1, uint64_t a2)
{
  v8[0] = 0;
  v8[1] = 0;
  sub_10003AED0((uint64_t)v8, a1 + 360);
  if (a2)
  {
    for (uint64_t i = *(void ***)(a1 + 336); i != *(void ***)(a1 + 344); ++i)
    {
      if (**i == a2)
      {
        unsigned int v7 = 0;
        sub_10028C8B4(a1, a2);
        uint64_t v5 = sub_1003708B0();
        if (!(*(unsigned int (**)(uint64_t, uint64_t, unsigned int *))(*(void *)v5 + 848))(v5, a2, &v7)) {
          sub_1002859A4(a1, a2, 12, v7, 1u);
        }
        return sub_10003AFB4((uint64_t)v8);
      }
    }
  }
  return sub_10003AFB4((uint64_t)v8);
}

void sub_10028CD34(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  sub_10003AFB4((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_10028CD4C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v12[0] = 0;
  v12[1] = 0;
  sub_10003AED0((uint64_t)v12, a1 + 360);
  if (a2)
  {
    for (uint64_t i = *(void *)(a1 + 336); i != *(void *)(a1 + 344); i += 8)
    {
      if (**(void **)i == a2)
      {
        uint64_t v9 = (*(uint64_t (**)(void, uint64_t, uint64_t, uint64_t))(**(void **)(*(void *)i + 768) + 80))(*(void *)(*(void *)i + 768), a2, a3, a4);
        goto LABEL_9;
      }
    }
  }
  if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_ERROR))
  {
    sub_100474E18(a2, v11);
    sub_10074DAD4();
  }
  uint64_t v9 = 312;
LABEL_9:
  sub_10003AFB4((uint64_t)v12);
  return v9;
}

void sub_10028CE70(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  sub_10003AFB4((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_10028CE90(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v10[0] = 0;
  v10[1] = 0;
  sub_10003AED0((uint64_t)v10, a1 + 360);
  if (a2)
  {
    for (uint64_t i = *(void *)(a1 + 336); i != *(void *)(a1 + 344); i += 8)
    {
      if (**(void **)i == a2)
      {
        uint64_t v7 = (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(*(void *)i + 768) + 160))(*(void *)(*(void *)i + 768), a2, a3);
        goto LABEL_9;
      }
    }
  }
  if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_ERROR))
  {
    sub_100474E18(a2, v9);
    sub_10074DAD4();
  }
  uint64_t v7 = 312;
LABEL_9:
  sub_10003AFB4((uint64_t)v10);
  return v7;
}

void sub_10028CFAC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  sub_10003AFB4((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_10028CFCC(uint64_t a1, uint64_t a2)
{
  v8[0] = 0;
  v8[1] = 0;
  sub_10003AED0((uint64_t)v8, a1 + 360);
  if (a2)
  {
    for (uint64_t i = *(void *)(a1 + 336); i != *(void *)(a1 + 344); i += 8)
    {
      if (**(void **)i == a2)
      {
        uint64_t v5 = (*(uint64_t (**)(void, uint64_t))(**(void **)(*(void *)i + 768) + 168))(*(void *)(*(void *)i + 768), a2);
        goto LABEL_9;
      }
    }
  }
  if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_ERROR))
  {
    sub_100474E18(a2, v7);
    sub_10074DAD4();
  }
  uint64_t v5 = 312;
LABEL_9:
  sub_10003AFB4((uint64_t)v8);
  return v5;
}

void sub_10028D0D8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  sub_10003AFB4((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_10028D0F8(uint64_t a1, uint64_t a2)
{
  char v15 = 0;
  uint64_t v4 = sub_100035F54();
  if ((*(unsigned int (**)(uint64_t))(*(void *)v4 + 352))(v4))
  {
    int v5 = 1;
LABEL_17:
    char v15 = v5;
    goto LABEL_18;
  }
  uint64_t v6 = sub_100035F54();
  if ((*(unsigned int (**)(uint64_t))(*(void *)v6 + 360))(v6))
  {
    int v5 = 2;
    goto LABEL_17;
  }
  uint64_t v7 = sub_100035F54();
  if ((*(unsigned int (**)(uint64_t))(*(void *)v7 + 368))(v7))
  {
    int v5 = 3;
    goto LABEL_17;
  }
  uint64_t v8 = sub_100035F54();
  if ((*(unsigned int (**)(uint64_t))(*(void *)v8 + 384))(v8))
  {
    int v5 = 16;
    goto LABEL_17;
  }
  uint64_t v9 = sub_100035F54();
  if ((*(unsigned int (**)(uint64_t))(*(void *)v9 + 376))(v9))
  {
    int v5 = 32;
    goto LABEL_17;
  }
  uint64_t v10 = sub_100035F54();
  if ((*(unsigned int (**)(uint64_t))(*(void *)v10 + 336))(v10))
  {
    int v5 = 48;
    goto LABEL_17;
  }
  uint64_t v11 = sub_100035F54();
  if ((*(unsigned int (**)(uint64_t))(*(void *)v11 + 400))(v11))
  {
    int v5 = 49;
    goto LABEL_17;
  }
  uint64_t v12 = sub_100035F54();
  if ((*(unsigned int (**)(uint64_t))(*(void *)v12 + 424))(v12))
  {
    int v5 = 64;
    goto LABEL_17;
  }
  int v5 = 0;
LABEL_18:
  unsigned __int8 v13 = qword_100A19E38;
  if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 67109120;
    int v17 = v5;
    _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "sendSourceType %d", buf, 8u);
  }
  return sub_100285180(a1, a2, 2, 1, (uint64_t)&v15);
}

uint64_t sub_10028D3AC(uint64_t result, uint64_t a2)
{
  char v3 = 0;
  memset(&v2[2], 0, 24);
  if (a2)
  {
    v2[0] = 0;
    v2[1] = 0;
    sub_10003AED0((uint64_t)v2, result + 360);
    sub_10028DEB4();
  }
  return result;
}

void sub_10028DE14(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19, uint64_t a20,void *__p,uint64_t a22,int a23,__int16 a24,char a25,char a26)
{
  if (a26 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void sub_10028DEB4()
{
}

void sub_10028E004()
{
}

BOOL sub_10028E028(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    uint64_t v9 = 0;
    uint64_t v10 = 0;
    sub_10047B7A8(a2, (_DWORD *)&v10 + 1, &v10, (_DWORD *)&v9 + 1, &v9);
    int v2 = HIDWORD(v9);
    BOOL v3 = HIDWORD(v9) == 8194 || HIDWORD(v9) == 8207;
    if (v3
      || (int v6 = v9, HIDWORD(v9) == 8195) && v9 > 0x767
      || HIDWORD(v9) == 8197 && v9 > 0x76F
      || HIDWORD(v9) == 8198 && v9 > 0x768
      || HIDWORD(v9) == 8201 && v9 >= 0x240)
    {
      uint64_t v4 = qword_100A19E38;
      if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)long long buf = 67109376;
        int v12 = v2;
        __int16 v13 = 1024;
        int v14 = v9;
        _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "AACP Config Jitter Buffer is supported. pid: %x, version: %x", buf, 0xEu);
      }
      return 1;
    }
    else
    {
      uint64_t v7 = qword_100A19E38;
      BOOL v8 = os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT);
      BOOL result = 0;
      if (v8)
      {
        *(_DWORD *)long long buf = 67109376;
        int v12 = v2;
        __int16 v13 = 1024;
        int v14 = v6;
        _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "AACP Config Jitter Buffer is NOT supported. pid: %x, version: %x", buf, 0xEu);
        return 0;
      }
    }
  }
  else
  {
    BOOL result = os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_ERROR);
    if (result)
    {
      sub_10074E4AC();
      return 0;
    }
  }
  return result;
}

uint64_t sub_10028E208(uint64_t a1, uint64_t a2, int a3, int a4)
{
  v83[0] = 0;
  v83[1] = 0;
  sub_10003AED0((uint64_t)v83, a1 + 360);
  if (a2)
  {
    for (uint64_t i = *(void ***)(a1 + 336); ; ++i)
    {
      if (i == *(void ***)(a1 + 344)) {
        goto LABEL_6;
      }
      uint64_t v9 = *i;
      if (**i == a2) {
        break;
      }
    }
    if (a4)
    {
      uint64_t v10 = sub_10048741C(a2);
      uint64_t v11 = sub_1002859A4(a1, a2, 1, v10, 1u);
      if (sub_10028CB30(v11, a2) && *((_DWORD *)v9 + 20) != 8208)
      {
        if (sub_100487464(a2)) {
          uint64_t v12 = 2;
        }
        else {
          uint64_t v12 = 1;
        }
        sub_1002859A4(a1, a2, 10, v12, 1u);
      }
      uint64_t v13 = sub_100487CFC(a2);
      sub_1002859A4(a1, a2, 6, v13, 1u);
      if (sub_100478B2C(a2, 29) && (sub_100478B2C(a2, 43) & 1) == 0)
      {
        uint64_t v14 = sub_10048775C(a2);
        sub_1002859A4(a1, a2, 23, v14, 1u);
      }
      if (sub_100478B2C(a2, 30))
      {
        if ((sub_100478B2C(a2, 38) & 1) == 0)
        {
          uint64_t v15 = sub_100487714(a2);
          sub_1002859A4(a1, a2, 22, v15, 1u);
          if ((sub_100478B2C(a2, 43) & 1) == 0)
          {
            uint64_t v16 = sub_1004877A4(a2);
            sub_1002859A4(a1, a2, 24, v16, 1u);
          }
        }
      }
      if (sub_100478B2C(a2, 28))
      {
        uint64_t v17 = sub_1004875AC(a2);
        sub_1002859A4(a1, a2, 26, v17, 1u);
      }
      if (sub_100487EFC(a2, 0x15u) == 1 && sub_100487CB4(a2))
      {
        uint64_t v18 = sub_100487CB4(a2);
        sub_1002859A4(a1, a2, 50, v18, 1u);
      }
      if (_os_feature_enabled_impl() && sub_100487EFC(a2, 0x13u) == 1)
      {
        uint64_t v19 = sub_100487BDC(a2);
        sub_1002859A4(a1, a2, 52, v19, 1u);
      }
    }
    if (sub_100478B2C(a2, 16) && sub_100478B2C(a2, 1) && (sub_100478B2C(a2, 43) & 1) == 0)
    {
      if (a4)
      {
        uint64_t v21 = sub_1004877EC(a2);
        sub_1002859A4(a1, a2, 27, v21, 1u);
      }
    }
    else if (sub_100478B2C(a2, 16) && sub_100478B2C(a2, 15))
    {
      uint64_t v20 = sub_100485D64(a2, 1);
      sub_100286EF8(v20, a2);
    }
    if (sub_100478B2C(a2, 32) && !sub_1004874AC(a2))
    {
      if (a4)
      {
        __int16 v29 = qword_100A19E38;
        if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
        {
          sub_100474E18(a2, buf);
          if (v87 >= 0) {
            BOOL v30 = buf;
          }
          else {
            BOOL v30 = *(unsigned char **)buf;
          }
          int v31 = sub_100478B2C(a2, 32);
          int v32 = sub_1004874AC(a2);
          uint64_t v33 = "No";
          *(_DWORD *)std::string __p = 136446722;
          *(void *)&__p[4] = v30;
          if (v31) {
            uint64_t v33 = "Yes";
          }
          *(_WORD *)&unsigned char __p[12] = 2080;
          *(void *)&unsigned char __p[14] = v33;
          __int16 v89 = 1024;
          int v90 = v32;
          _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEFAULT, "%{public}s Initialize setSmartRouteMode via connection Tipi Support = %s current SR Mode =%d", __p, 0x1Cu);
          if (v87 < 0) {
            operator delete(*(void **)buf);
          }
        }
        sub_100484DC4(a2, 1);
      }
    }
    else if (sub_100487DD4(a2, 64))
    {
      uint64_t v22 = sub_100035F54();
      if ((*(unsigned int (**)(uint64_t, uint64_t))(*(void *)v22 + 792))(v22, 1))
      {
        if (!sub_10048751C(a2))
        {
          uint64_t v23 = qword_100A19E38;
          if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
          {
            sub_100474E18(a2, __p);
            int v24 = SHIBYTE(v89);
            uint64_t v25 = *(unsigned char **)__p;
            int v26 = sub_100487DD4(a2, 64);
            uint32_t v27 = __p;
            int v28 = "No";
            if (v24 < 0) {
              uint32_t v27 = v25;
            }
            if (v26) {
              int v28 = "Yes";
            }
            *(_DWORD *)long long buf = 136446466;
            *(void *)&uint8_t buf[4] = v27;
            __int16 v85 = 2080;
            uint64_t v86 = v28;
            _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "%{public}s Initialize Spatial Audio via connection Spatial support = %s", buf, 0x16u);
            if (SHIBYTE(v89) < 0) {
              operator delete(*(void **)__p);
            }
          }
          sub_1004852A8(a2, 1);
        }
      }
    }
    uint64_t v34 = sub_100035F54();
    if (((*(uint64_t (**)(uint64_t))(*(void *)v34 + 328))(v34) & 1) != 0
      || (uint64_t v35 = sub_100035F54(), ((*(uint64_t (**)(uint64_t))(*(void *)v35 + 384))(v35) & 1) != 0)
      || (uint64_t v36 = sub_100035F54(), (*(unsigned int (**)(uint64_t))(*(void *)v36 + 424))(v36)))
    {
      if (sub_100478B2C(a2, 14))
      {
        if (qword_1009F7F00 != -1) {
          dispatch_once(&qword_1009F7F00, &stru_1009A1E70);
        }
        if (sub_1004AB1F0((uint64_t)off_1009F7EF8))
        {
          unsigned int v37 = sub_10047C698(a2);
          uint64_t v38 = sub_100478B2C(a2, 22);
          uint64_t v39 = sub_10028F788(v38, a2, v37, v38);
          if (v37 != v39) {
            sub_10047C6E0(a2, v39);
          }
          sub_1002859A4(a1, a2, 12, v39, 1u);
          int v40 = *((_DWORD *)v9 + 20);
          if (v40 == 8208)
          {
            if (!sub_10048787C(a2))
            {
              sub_100485E40(a2, 1);
              sub_1002859A4(a1, a2, 30, 1, 1u);
            }
            int v40 = *((_DWORD *)v9 + 20);
          }
          if ((v40 == 8202 || (sub_100487DD4(a2, 32) & 1) != 0 || *((_DWORD *)v9 + 20) == 8223)
            && !sub_100487834(a2))
          {
            sub_100485DF8(a2, 1);
            sub_1002859A4(a1, a2, 28, 1, 1u);
          }
        }
        else
        {
          uint64_t v41 = qword_100A19E38;
          if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
          {
            sub_100474E18(a2, __p);
            BOOL v42 = v89 >= 0 ? __p : *(unsigned char **)__p;
            *(_DWORD *)long long buf = 136446210;
            *(void *)&uint8_t buf[4] = v42;
            _os_log_impl((void *)&_mh_execute_header, v41, OS_LOG_TYPE_DEFAULT, "Device has not been unlocked (or device prefs not read yet) - disabling double tap on %{public}s", buf, 0xCu);
            if (SHIBYTE(v89) < 0) {
              operator delete(*(void **)__p);
            }
          }
          sub_1002859A4(a1, a2, 12, 0, 1u);
          *(_DWORD *)std::string __p = 0;
          __int16 v43 = *(NSObject **)(sub_1004AF8EC() + 8);
          handler[0] = _NSConcreteStackBlock;
          handler[1] = 3221225472;
          handler[2] = sub_10028F640;
          handler[3] = &unk_1009A12B0;
          handler[4] = a1;
          void handler[5] = a2;
          uint32_t v44 = notify_register_dispatch("com.apple.mobile.keybagd.first_unlock", (int *)__p, v43, handler);
          __int16 v45 = qword_100A19E38;
          if (v44)
          {
            if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_ERROR)) {
              sub_10074E514();
            }
          }
          else if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)long long buf = 0;
            _os_log_impl((void *)&_mh_execute_header, v45, OS_LOG_TYPE_DEFAULT, "Successfully registered for MKB first unlock notification", buf, 2u);
          }
        }
        sub_10028502C(a1, a2, 32, 0, 0);
      }
    }
    if (a4)
    {
      if (sub_100478B2C(a2, 32))
      {
        uint64_t v46 = sub_1004874AC(a2);
        if (v46) {
          sub_1002859A4(a1, a2, 32, v46, 1u);
        }
      }
    }
    uint64_t v47 = sub_100017768();
    if ((*(unsigned int (**)(uint64_t))(*(void *)v47 + 8))(v47))
    {
      unsigned int v48 = *((_DWORD *)v9 + 20) - 8194;
      if (v48 > 0xE || ((1 << v48) & 0x409B) == 0)
      {
        uint64_t v74 = sub_100017768();
        uint64_t v75 = (*(uint64_t (**)(uint64_t))(*(void *)v74 + 832))(v74);
        sub_1002859A4(a1, a2, 34, v75, 1u);
      }
    }
    uint64_t v49 = sub_100017768();
    if ((*(unsigned int (**)(uint64_t))(*(void *)v49 + 8))(v49))
    {
      uint64_t v50 = sub_100035F54();
      if ((*(unsigned int (**)(uint64_t))(*(void *)v50 + 328))(v50))
      {
        unsigned int v51 = *((_DWORD *)v9 + 20) - 8212;
        if (v51 <= 0x10 && ((1 << v51) & 0x116A1) != 0)
        {
          LOBYTE(v81) = 0;
          uint64_t v52 = sub_100017768();
          sub_10004191C(__p, "A2DP");
          sub_10004191C(buf, "AdaptiveEQEnable");
          (*(void (**)(uint64_t, unsigned char *, unsigned char *, uint64_t *))(*(void *)v52 + 72))(v52, __p, buf, &v81);
          if (v87 < 0) {
            operator delete(*(void **)buf);
          }
          if (SHIBYTE(v89) < 0) {
            operator delete(*(void **)__p);
          }
          int v53 = v81;
          __int16 v54 = malloc_type_malloc(0x10uLL, 0xBD7C984FuLL);
          int v55 = v54;
          float v56 = 0.0;
          if (v53) {
            float v56 = 1.0;
          }
          *__int16 v54 = 514;
          *((_DWORD *)v54 + 2) = 1677721850;
          *((float *)v54 + 3) = v56;
          sub_10028502C(a1, a2, 1, 16, (uint64_t)v54);
          free(v55);
        }
      }
    }
    uint64_t v57 = sub_100017768();
    if ((*(unsigned int (**)(uint64_t))(*(void *)v57 + 8))(v57))
    {
      uint64_t v58 = sub_100035F54();
      if ((*(unsigned int (**)(uint64_t))(*(void *)v58 + 328))(v58))
      {
        unsigned int v59 = *((_DWORD *)v9 + 20) - 8217;
        if (v59 <= 7 && ((1 << v59) & 0xA5) != 0)
        {
          LOBYTE(v81) = 0;
          uint64_t v60 = sub_100017768();
          sub_10004191C(__p, "AutomaticIEDKey");
          sub_10004191C(buf, "DefaultAutoIEDOff");
          (*(void (**)(uint64_t, unsigned char *, unsigned char *, uint64_t *))(*(void *)v60 + 72))(v60, __p, buf, &v81);
          if (v87 < 0) {
            operator delete(*(void **)buf);
          }
          if (SHIBYTE(v89) < 0) {
            operator delete(*(void **)__p);
          }
          char v61 = qword_100A19E38;
          if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)std::string __p = 67109120;
            *(_DWORD *)&__p[4] = v81;
            _os_log_impl((void *)&_mh_execute_header, v61, OS_LOG_TYPE_DEFAULT, "internalSetupAACP: Defaults write value to set Automatic Ear Detection off upon every connection = %d", __p, 8u);
          }
          if ((_BYTE)v81) {
            sub_100485460(a2, 0, 1);
          }
        }
      }
    }
    unsigned int v62 = *((_DWORD *)v9 + 20) - 8212;
    if (v62 <= 0x10 && ((1 << v62) & 0x116A1) != 0)
    {
      if (a3)
      {
        LOBYTE(v81) = 0;
        memset((char *)&v81 + 1, 255, 7);
        uint64_t v63 = sub_100373254();
        (*(void (**)(uint64_t, void, uint64_t *, void))(*(void *)v63 + 16))(v63, *(void *)(a1 + 440), &v81, *((unsigned int *)v9 + 20));
        int v64 = sub_100284530(a1, a2, (uint64_t)&v81);
        if (v64)
        {
          uint64_t v65 = qword_100A19E38;
          if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_ERROR))
          {
            uint64_t v76 = *(void *)(a1 + 440);
            sub_100474E18(a2, buf);
            uint64_t v77 = v87 >= 0 ? buf : *(unsigned char **)buf;
            *(_DWORD *)std::string __p = 138412802;
            *(void *)&__p[4] = v76;
            *(_WORD *)&unsigned char __p[12] = 2082;
            *(void *)&unsigned char __p[14] = v77;
            __int16 v89 = 1024;
            int v90 = v64;
            _os_log_error_impl((void *)&_mh_execute_header, v65, OS_LOG_TYPE_ERROR, "Failed to set country codes for country %@ for device %{public}s with result %u", __p, 0x1Cu);
            if (v87 < 0) {
              operator delete(*(void **)buf);
            }
          }
        }
      }
    }
    if (qword_1009F8080 != -1) {
      dispatch_once(&qword_1009F8080, &stru_1009A1E50);
    }
    long long v66 = off_1009F8078;
    if (!sub_1004962BC()
      || !v66[240]
      || *(unsigned char *)(a2 + 988)
      || *(unsigned char *)(a2 + 989)
      || (sub_10047ECFC(a2) & 2) != 0)
    {
      goto LABEL_136;
    }
    if (qword_1009F8080 != -1) {
      dispatch_once(&qword_1009F8080, &stru_1009A1E50);
    }
    if (sub_100497A84((uint64_t)off_1009F8078, a2))
    {
LABEL_136:
      if (qword_1009F8080 != -1) {
        dispatch_once(&qword_1009F8080, &stru_1009A1E50);
      }
      if (!sub_1004962BC()) {
        goto LABEL_147;
      }
      if (qword_1009F8080 != -1) {
        dispatch_once(&qword_1009F8080, &stru_1009A1E50);
      }
      if (sub_100497A84((uint64_t)off_1009F8078, a2)) {
        goto LABEL_147;
      }
      *(void *)std::string __p = 0;
      *(void *)&__p[8] = 0;
      buf[0] = 0;
      *(_DWORD *)&buf[1] = *(_DWORD *)(a2 + 128);
      *(_WORD *)&buf[5] = *(_WORD *)(a2 + 132);
      if (qword_1009F7ED0 != -1) {
        dispatch_once(&qword_1009F7ED0, &stru_1009A1F30);
      }
      if (sub_100714570(qword_1009F7EC8, buf, __p)) {
        goto LABEL_147;
      }
      if (qword_1009F7F00 == -1)
      {
LABEL_146:
        sub_1004ABED0((uint64_t)off_1009F7EF8, a2);
LABEL_147:
        if (qword_1009F8080 != -1) {
          dispatch_once(&qword_1009F8080, &stru_1009A1E50);
        }
        long long v67 = sub_1004979F4((uint64_t)off_1009F8078, a2);
        uint64_t v68 = (uint64_t)v67;
        if (v67 && *((unsigned char *)v67 + 112) == 2)
        {
          long long v69 = qword_100A19ED8;
          if (os_log_type_enabled((os_log_t)qword_100A19ED8, OS_LOG_TYPE_DEFAULT))
          {
            sub_100475EE0(a2, (uint64_t)__p);
            int v70 = v89 >= 0 ? __p : *(const char **)__p;
            *(_DWORD *)long long buf = 141558275;
            *(void *)&uint8_t buf[4] = 1752392040;
            __int16 v85 = 2081;
            uint64_t v86 = v70;
            _os_log_impl((void *)&_mh_execute_header, v69, OS_LOG_TYPE_DEFAULT, "Sending magic keys 'again' to device %{private, mask.hash}s", buf, 0x16u);
            if (SHIBYTE(v89) < 0) {
              operator delete(*(void **)__p);
            }
          }
          if (qword_1009F8080 != -1) {
            dispatch_once(&qword_1009F8080, &stru_1009A1E50);
          }
          sub_1004997A8((uint64_t)off_1009F8078, v68);
          sub_10028F9A8(v71, (unsigned __int8 *)a2);
        }
        if (qword_1009F8080 != -1) {
          dispatch_once(&qword_1009F8080, &stru_1009A1E50);
        }
        sub_1004A4CD8((uint64_t)off_1009F8078, a2);
        if (sub_10028B72C(a1, a2))
        {
          sub_10028B794(a1, v9);
        }
        else
        {
          uint64_t v72 = qword_100A19E38;
          if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)std::string __p = 0;
            _os_log_impl((void *)&_mh_execute_header, v72, OS_LOG_TYPE_DEFAULT, "internalSetupAACP: Conditions not met for easy pairing", __p, 2u);
          }
        }
        if (*(unsigned char *)(a1 + 520)) {
          *(unsigned char *)(a1 + 520) = 0;
        }
        return sub_10003AFB4((uint64_t)v83);
      }
    }
    else
    {
      int v78 = qword_100A19ED8;
      BOOL v79 = os_log_type_enabled((os_log_t)qword_100A19ED8, OS_LOG_TYPE_DEFAULT);
      if (v79)
      {
        sub_100475EE0(a2, (uint64_t)__p);
        int v80 = v89 >= 0 ? __p : *(const char **)__p;
        *(_DWORD *)long long buf = 141558275;
        *(void *)&uint8_t buf[4] = 1752392040;
        __int16 v85 = 2081;
        uint64_t v86 = v80;
        _os_log_impl((void *)&_mh_execute_header, v78, OS_LOG_TYPE_DEFAULT, "Sending magic keys and renaming device %{private, mask.hash}s", buf, 0x16u);
        if (SHIBYTE(v89) < 0) {
          operator delete(*(void **)__p);
        }
      }
      sub_10028F9A8(v79, (unsigned __int8 *)a2);
      if (qword_1009F7F00 == -1) {
        goto LABEL_146;
      }
    }
    dispatch_once(&qword_1009F7F00, &stru_1009A1E70);
    goto LABEL_146;
  }
LABEL_6:
  if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_ERROR)) {
    sub_10074E4E0();
  }
  return sub_10003AFB4((uint64_t)v83);
}

void sub_10028F3C0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17, uint64_t a18, void *a19, uint64_t a20,int a21,__int16 a22,char a23,char a24,uint64_t a25,void *__p,uint64_t a27,int a28,__int16 a29,char a30,char a31)
{
}

uint64_t sub_10028F48C(uint64_t a1, uint64_t a2)
{
  BOOL v3 = qword_100A19E38;
  if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
  {
    sub_100475EE0(a2, (uint64_t)__p);
    uint64_t v4 = v11 >= 0 ? __p : (void **)__p[0];
    *(_DWORD *)long long buf = 136315138;
    uint64_t v13 = v4;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Notify in ear status change for device \"%s\"", buf, 0xCu);
    if (v11 < 0) {
      operator delete(__p[0]);
    }
  }
  uint64_t v5 = sub_1004AFA9C();
  v9[0] = _NSConcreteStackBlock;
  v9[1] = 3221225472;
  void v9[2] = sub_1002A87A4;
  void v9[3] = &unk_100997528;
  void v9[4] = a2;
  sub_100013018(v5, v9);
  uint64_t v6 = sub_1004AFB34();
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 3221225472;
  void v8[2] = sub_1002A881C;
  void v8[3] = &unk_100997528;
  void v8[4] = a2;
  sub_100013018(v6, v8);
  if (qword_1009F7EF0 != -1) {
    dispatch_once(&qword_1009F7EF0, &stru_1009A1E30);
  }
  return sub_100455438((uint64_t)off_1009F7EE8, a2);
}

void sub_10028F640(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  BOOL v3 = qword_100A19E38;
  if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 67109120;
    int v8 = MKBDeviceUnlockedSinceBoot();
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Received MKB first unlock notification. MKBDeviceUnlockedSinceBoot returns : %d", buf, 8u);
  }
  if (MKBDeviceUnlockedSinceBoot() != 1
    && os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_FAULT))
  {
    sub_10074E57C();
  }
  uint64_t v4 = sub_1004AF8EC();
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 3221225472;
  void v6[2] = sub_10028F77C;
  void v6[3] = &unk_100998260;
  uint64_t v5 = *(void *)(a1 + 40);
  char v6[4] = v2;
  v6[5] = v5;
  sub_1004AFF58(v4, 2000, v6);
}

uint64_t sub_10028F77C(uint64_t a1)
{
  return sub_10028CC64(*(void *)(a1 + 32), *(void *)(a1 + 40));
}

uint64_t sub_10028F788(uint64_t a1, uint64_t a2, unsigned int a3, int a4)
{
  if (a4) {
    LOBYTE(v6) = 3;
  }
  else {
    LOBYTE(v6) = 1;
  }
  if (a3 == 0xFFFF)
  {
    int v8 = qword_100A19E38;
    if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
    {
      sub_100474E18(a2, &__p);
      uint64_t v9 = v21 >= 0 ? &__p : (void **)__p;
      *(_DWORD *)long long buf = 136446210;
      uint64_t v23 = v9;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "Setting double tap for %{public}s for first time", buf, 0xCu);
      if (v21 < 0) {
        operator delete(__p);
      }
    }
    int v10 = 255;
  }
  else
  {
    int v10 = a3;
    unsigned __int8 v11 = a3;
    if (a3 < 5u) {
      goto LABEL_17;
    }
  }
  uint64_t v12 = qword_100A19E38;
  unsigned __int8 v11 = v6;
  if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v13 = "Siri";
    if (a4) {
      uint64_t v13 = "Next Track";
    }
    LODWORD(__p) = 67109378;
    HIDWORD(__p) = v10;
    __int16 v19 = 2082;
    uint64_t v20 = v13;
    _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "Right double tap was %d, now %{public}s", (uint8_t *)&__p, 0x12u);
    unsigned __int8 v11 = v6;
  }
LABEL_17:
  int v14 = BYTE1(a3);
  if (BYTE1(a3) < 5u)
  {
    unsigned int v6 = a3 >> 8;
  }
  else
  {
    uint64_t v15 = qword_100A19E38;
    if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v16 = "Siri";
      if (a4) {
        uint64_t v16 = "Next Track";
      }
      LODWORD(__p) = 67109378;
      HIDWORD(__p) = v14;
      __int16 v19 = 2082;
      uint64_t v20 = v16;
      _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "Left double tap was %d, now %{public}s", (uint8_t *)&__p, 0x12u);
    }
  }
  return v11 | (v6 << 8);
}

uint64_t sub_10028F9A8(uint64_t a1, unsigned __int8 *a2)
{
  v31[0] = (void *)1048592;
  v32[0] = (void *)1052672;
  v30[0] = (void *)1048584;
  BOOL v3 = malloc_type_malloc(0x10uLL, 0x4430C814uLL);
  v30[1] = v3;
  uint64_t v4 = malloc_type_malloc(0x10uLL, 0xE3F39105uLL);
  v31[1] = v4;
  uint64_t v5 = malloc_type_malloc(0x10uLL, 0x62A67C01uLL);
  v32[1] = v5;
  uint64_t v33 = 401408;
  unsigned int v6 = malloc_type_malloc(6uLL, 0x128E9DCEuLL);
  uint64_t v34 = v6;
  if (qword_1009F8080 != -1) {
    dispatch_once(&qword_1009F8080, &stru_1009A1E50);
  }
  uint64_t v7 = (void *)&unk_1009F8000;
  if (sub_10049A898((uint64_t)off_1009F8078, (uint64_t)a2, v3, v4))
  {
    uint64_t v8 = 0;
    goto LABEL_32;
  }
  uint64_t v9 = qword_100A19ED8;
  if (os_log_type_enabled((os_log_t)qword_100A19ED8, OS_LOG_TYPE_DEFAULT))
  {
    sub_100474E18((uint64_t)a2, __p);
    int v10 = v25;
    unsigned __int8 v11 = (void **)__p[0];
    int v12 = sub_100040630(a2);
    uint64_t v13 = __p;
    if (v10 < 0) {
      uint64_t v13 = v11;
    }
    *(_DWORD *)long long buf = 136446466;
    uint32_t v27 = v13;
    __int16 v28 = 1024;
    int v29 = v12;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "Updating magic keys to device %{public}s, paired %d", buf, 0x12u);
    if (v25 < 0) {
      operator delete(__p[0]);
    }
    uint64_t v7 = &unk_1009F8000;
  }
  if (sub_100040630(a2) && sub_100478B2C((uint64_t)a2, 19))
  {
    if (qword_1009F8080 != -1) {
      dispatch_once(&qword_1009F8080, &stru_1009A1E50);
    }
    uint64_t v8 = sub_10049ACBC((uint64_t)off_1009F8078, v5, (uint64_t)v6);
  }
  else
  {
    uint64_t v8 = 1;
  }
  int v14 = qword_100A19ED8;
  if (os_log_type_enabled((os_log_t)qword_100A19ED8, OS_LOG_TYPE_DEFAULT))
  {
    sub_100474E18((uint64_t)a2, __p);
    int v15 = v25;
    uint64_t v16 = (void **)__p[0];
    int v17 = sub_100040630(a2);
    uint64_t v18 = __p;
    if (v15 < 0) {
      uint64_t v18 = v16;
    }
    *(_DWORD *)long long buf = 136446466;
    uint32_t v27 = v18;
    __int16 v28 = 1024;
    int v29 = v17;
    _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "Get magic key from cloud for device %{public}s is %d", buf, 0x12u);
    if (v25 < 0)
    {
      operator delete(__p[0]);
      if (v8) {
        goto LABEL_22;
      }
LABEL_26:
      uint64_t v20 = 0;
      uint64_t v21 = 0xF00000000;
      do
      {
        char v22 = *((unsigned char *)v5 + v20);
        *((unsigned char *)v5 + v20) = *((unsigned char *)v5 + (v21 >> 32));
        *((unsigned char *)v5 + (v21 >> 32)) = v22;
        ++v20;
        v21 -= 0x100000000;
      }
      while (v20 != 8);
      if (qword_1009F80A0 != -1) {
        dispatch_once(&qword_1009F80A0, &stru_1009A1E90);
      }
      uint64_t v8 = 0;
      uint64_t v19 = 4;
      goto LABEL_31;
    }
  }
  if (!v8) {
    goto LABEL_26;
  }
LABEL_22:
  if (qword_1009F80A0 != -1) {
    dispatch_once(&qword_1009F80A0, &stru_1009A1E90);
  }
  uint64_t v19 = 2;
LABEL_31:
  sub_1002882E0(v7[19], (uint64_t)a2, v19, (uint64_t)v30);
LABEL_32:
  free(v30[1]);
  free(v31[1]);
  free(v32[1]);
  free(v34);
  if (qword_1009F80A0 != -1) {
    dispatch_once(&qword_1009F80A0, &stru_1009A1E90);
  }
  sub_100288424(v7[19], (uint64_t)a2, 5);
  return v8;
}

void sub_10028FD88(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10028FDB0(uint64_t a1, uint64_t a2)
{
  if (!a2) {
    return 0;
  }
  uint64_t v3 = sub_100487464(a2);
  uint64_t v4 = qword_100A19E38;
  if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_INFO))
  {
    sub_100474E18(a2, __p);
    if (v9 >= 0) {
      uint64_t v5 = __p;
    }
    else {
      uint64_t v5 = (void **)__p[0];
    }
    unsigned int v6 = "Disabled";
    unsigned __int8 v11 = "In Ear detection";
    *(_DWORD *)long long buf = 136446722;
    if (v3) {
      unsigned int v6 = "Enabled";
    }
    __int16 v12 = 2082;
    uint64_t v13 = v5;
    __int16 v14 = 2082;
    int v15 = v6;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_INFO, "%{public}s for %{public}s is %{public}s", buf, 0x20u);
    if (v9 < 0) {
      operator delete(__p[0]);
    }
  }
  return v3;
}

uint64_t sub_10028FEDC(uint64_t a1, uint64_t a2, int *a3, int *a4)
{
  v28[0] = 0;
  v28[1] = 0;
  uint64_t v8 = sub_10003AED0((uint64_t)v28, a1 + 360);
  if (a2)
  {
    char v9 = *(void **)(a1 + 336);
    int v10 = *(void **)(a1 + 344);
    while (v9 != v10)
    {
      unsigned __int8 v11 = (void *)*v9;
      if (*(void *)*v9 == a2)
      {
        uint64_t v14 = sub_100290124(v8, *((unsigned __int8 *)v11 + 8));
        *a3 = v14;
        *a4 = sub_100290124(v14, *((unsigned __int8 *)v11 + 9));
        int v15 = qword_100A19E38;
        if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_INFO))
        {
          sub_100474E18(a2, __p);
          int v16 = v30;
          int v17 = (void **)__p[0];
          int v18 = *a3;
          int v19 = *a4;
          uint64_t v20 = sub_100487464(a2);
          int v21 = v20;
          char v22 = sub_100290148(v20, v19);
          uint64_t v23 = sub_100290148((uint64_t)v22, v18);
          int v24 = __p;
          if (v16 < 0) {
            int v24 = v17;
          }
          *(_DWORD *)long long buf = 136446978;
          int v32 = v24;
          char v25 = "yes";
          __int16 v33 = 2082;
          uint64_t v34 = v23;
          if (!v21) {
            char v25 = "no";
          }
          __int16 v35 = 2082;
          uint64_t v36 = v22;
          __int16 v37 = 2080;
          uint64_t v38 = v25;
          _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_INFO, "getInEarStatus: %{public}s primary %{public}s, secondary %{public}s, IED enabled: %s", buf, 0x2Au);
          if (v30 < 0) {
            operator delete(__p[0]);
          }
        }
        uint64_t v26 = 0;
        goto LABEL_19;
      }
      ++v9;
    }
  }
  *a3 = 3;
  *a4 = 3;
  __int16 v12 = qword_100A19E38;
  if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_ERROR))
  {
    if (a2)
    {
      sub_100474E18(a2, buf);
      sub_10074E600();
    }
    else
    {
      sub_10074E5BC((uint64_t)__p, v12, v13);
    }
  }
  uint64_t v26 = 312;
LABEL_19:
  sub_10003AFB4((uint64_t)v28);
  return v26;
}

void sub_1002900EC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  sub_10003AFB4((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t sub_100290124(uint64_t a1, unsigned int a2)
{
  if (a2 > 0xC) {
    return 3;
  }
  else {
    return dword_1007BB354[(char)a2];
  }
}

const char *sub_100290148(uint64_t a1, unsigned int a2)
{
  if (a2 > 0xC) {
    return "unknown";
  }
  else {
    return off_1009A2248[(char)a2];
  }
}

uint64_t sub_100290170(uint64_t a1, uint64_t a2, int *a3)
{
  v19[0] = 0;
  v19[1] = 0;
  sub_10003AED0((uint64_t)v19, a1 + 360);
  if (a2)
  {
    for (uint64_t i = *(void *)(a1 + 336); i != *(void *)(a1 + 344); i += 8)
    {
      if (**(void **)i == a2)
      {
        int v9 = *(unsigned __int8 *)(*(void *)i + 10);
        if (v9 == 2) {
          int v10 = 2;
        }
        else {
          int v10 = 3;
        }
        if (v9 == 1) {
          int v11 = 1;
        }
        else {
          int v11 = v10;
        }
        *a3 = v11;
        __int16 v12 = qword_100A19E38;
        if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_INFO))
        {
          sub_100475EE0(a2, (uint64_t)__p);
          if (v18 >= 0) {
            uint64_t v13 = __p;
          }
          else {
            uint64_t v13 = (void **)__p[0];
          }
          int v14 = *(unsigned __int8 *)a3;
          int v15 = "unknown";
          if (v14 == 2) {
            int v15 = "right";
          }
          if (v14 == 1) {
            int v16 = "left";
          }
          else {
            int v16 = v15;
          }
          *(_DWORD *)long long buf = 136315394;
          int v21 = v13;
          __int16 v22 = 2082;
          uint64_t v23 = v16;
          _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_INFO, "getPrimaryBudSide: primary bud side of \"%s\" is %{public}s", buf, 0x16u);
          if (v18 < 0) {
            operator delete(__p[0]);
          }
        }
        uint64_t v7 = 0;
        goto LABEL_11;
      }
    }
    *a3 = 3;
    if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_ERROR))
    {
      sub_100474E18(a2, __p);
      sub_10074E688();
    }
  }
  else
  {
    *a3 = 3;
    if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_ERROR)) {
      sub_10074E654();
    }
  }
  uint64_t v7 = 312;
LABEL_11:
  sub_10003AFB4((uint64_t)v19);
  return v7;
}

void sub_100290368(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  sub_10003AFB4((uint64_t)va);
  _Unwind_Resume(a1);
}

const char *sub_100290388(uint64_t a1, int a2)
{
  uint64_t v2 = "unknown";
  if (a2 == 2) {
    uint64_t v2 = "right";
  }
  if (a2 == 1) {
    return "left";
  }
  else {
    return v2;
  }
}

void sub_1002903B4(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (qword_1009F7EE0 != -1) {
    dispatch_once(&qword_1009F7EE0, &stru_1009A1EF0);
  }
  uint64_t v4 = sub_100030DCC((uint64_t)off_1009F7ED8, v3, 0);
  *(unsigned char *)(a1 + 424) = BYTE5(v4);
  *(unsigned char *)(a1 + 425) = BYTE4(v4);
  *(unsigned char *)(a1 + 426) = BYTE3(v4);
  *(unsigned char *)(a1 + 427) = BYTE2(v4);
  *(unsigned char *)(a1 + 428) = BYTE1(v4);
  *(unsigned char *)(a1 + 429) = v4;
  char v24 = 0;
  sub_10001B8E0(&v24);
  uint64_t v5 = (unsigned __int8 *)(a1 + 432);
  int v6 = sub_1000E958C(((unint64_t)*(unsigned __int8 *)(a1 + 424) << 40) | ((unint64_t)*(unsigned __int8 *)(a1 + 425) << 32) | ((unint64_t)*(unsigned __int8 *)(a1 + 426) << 24) | ((unint64_t)*(unsigned __int8 *)(a1 + 427) << 16) | ((unint64_t)*(unsigned __int8 *)(a1 + 428) << 8) | *(unsigned __int8 *)(a1 + 429), (unsigned char *)(a1 + 432));
  sub_10001B910(&v24);
  uint64_t v7 = qword_100A19E38;
  if (v6 && os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)std::string __p = 67109120;
    *(_DWORD *)&__p[4] = v6;
    _os_log_error_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, "CL get version failed with status %d", __p, 8u);
    uint64_t v7 = qword_100A19E38;
  }
  uint64_t v8 = a1 + 424;
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    sub_1004A82EC((unsigned __int8 *)(a1 + 424), __p);
    int v9 = v33 >= 0 ? __p : *(unsigned char **)__p;
    int v10 = *v5;
    *(_DWORD *)long long buf = 136315394;
    *(void *)&uint8_t buf[4] = v9;
    __int16 v26 = 1024;
    int v27 = v10;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "Magnet link connected with device \"%s\" with version %d", buf, 0x12u);
    if (SHIBYTE(v33) < 0) {
      operator delete(*(void **)__p);
    }
  }
  uint64_t v23 = 0;
  if (qword_1009F7EC0 != -1) {
    dispatch_once(&qword_1009F7EC0, &stru_1009A1F50);
  }
  int v11 = off_1009F7EB8;
  sub_1000305AC(__p, v3);
  BOOL v12 = sub_1006856B8((uint64_t)v11, __p, &v23);
  if (v23) {
    BOOL v13 = v12;
  }
  else {
    BOOL v13 = 0;
  }
  if (!v13) {
    goto LABEL_25;
  }
  sub_1002B804C(&v24);
  int v14 = qword_100A19E38;
  if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
  {
    sub_1004A82EC((unsigned __int8 *)(a1 + 424), buf);
    int v15 = v28 >= 0 ? buf : *(unsigned char **)buf;
    int v16 = *v5;
    int v17 = sub_1000EB160(v23);
    int v18 = sub_1000EB088(v23);
    *(_DWORD *)std::string __p = 136315906;
    *(void *)&__p[4] = v15;
    __int16 v30 = 1024;
    int v31 = v16;
    __int16 v32 = 1024;
    int v33 = v17;
    __int16 v34 = 1024;
    int v35 = v18;
    _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "device \"%s\" with version %d  (peerIsPhone=%d peerIsWatch=%d)", __p, 0x1Eu);
    if (v28 < 0) {
      operator delete(*(void **)buf);
    }
  }
  char v19 = sub_1000EB238(v23);
  sub_10001B910(&v24);
  if ((v19 & 1) == 0)
  {
    __int16 v22 = qword_100A19E38;
    if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string __p = 0;
      _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "Magnet link up between two devices that do not support EasyPairing", __p, 2u);
    }
    *(_WORD *)(v8 + 4) = 0;
    *(_DWORD *)uint64_t v8 = 0;
  }
  else
  {
LABEL_25:
    *(unsigned char *)(a1 + 430) = 1;
    sub_1002907E8(a1);
    int v20 = *(_DWORD *)(a1 + 516);
    if (v20 == -1)
    {
      int v21 = (int *)(a1 + 516);
      notify_register_check("com.apple.bluetooth.magnet", v21);
      int v20 = *v21;
    }
    notify_set_state(v20, 1uLL);
    notify_post("com.apple.bluetooth.magnet");
  }
  sub_10001B8AC(&v24);
}

void sub_100290794(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, int a10, __int16 a11, char a12, char a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19)
{
  sub_10001B8AC(&a13);

  _Unwind_Resume(a1);
}

uint64_t sub_1002907E8(uint64_t a1)
{
  v5[0] = 0;
  v5[1] = 0;
  sub_10003AED0((uint64_t)v5, a1 + 360);
  id v3 = *(uint64_t ***)(a1 + 336);
  uint64_t v2 = *(uint64_t ***)(a1 + 344);
  while (v3 != v2)
  {
    if (*v3)
    {
      sub_10028B794(a1, *v3);
      uint64_t v2 = *(uint64_t ***)(a1 + 344);
    }
    ++v3;
  }
  return sub_10003AFB4((uint64_t)v5);
}

void sub_100290850(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_100290864(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (qword_1009F7EE0 != -1) {
    dispatch_once(&qword_1009F7EE0, &stru_1009A1EF0);
  }
  uint64_t v4 = sub_100030DCC((uint64_t)off_1009F7ED8, v3, 0);
  LOBYTE(v15) = BYTE5(v4);
  BYTE1(v15) = BYTE4(v4);
  BYTE2(v15) = BYTE3(v4);
  HIBYTE(v15) = BYTE2(v4);
  LOBYTE(v16) = BYTE1(v4);
  HIBYTE(v16) = v4;
  uint64_t v5 = qword_100A19E38;
  if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
  {
    int v6 = sub_1006AD3F0();
    *(_DWORD *)long long buf = 138412290;
    *(void *)&uint8_t buf[4] = v6;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "magnet link disconnected with device \"%@\"", buf, 0xCu);
  }
  if (v15 == *(_DWORD *)(a1 + 424) && v16 == *(_WORD *)(a1 + 428))
  {
    *(unsigned char *)(a1 + 432) = 0;
    *(_DWORD *)(a1 + 424) = 0;
    *(_DWORD *)(a1 + 427) = 0;
    *(_OWORD *)long long buf = 0uLL;
    sub_10003AED0((uint64_t)buf, a1 + 360);
    for (uint64_t i = *(uint64_t **)(a1 + 336); i != *(uint64_t **)(a1 + 344); ++i)
    {
      int v11 = (void *)*i;
      uint64_t v12 = *(void *)*i;
      sub_100290B30(*i);
      if (v12 && !sub_10028BC74((uint64_t)v11))
      {
        v18[0] = 0;
        sub_10001B8E0(v18);
        sub_1000D884C((unsigned __int8 *)(v12 + 128), (uint64_t)&v15, 2);
        sub_10001B910(v18);
        *((unsigned char *)v11 + 728) = 0;
        sub_10001B8AC(v18);
      }
    }
    sub_10003AFB4((uint64_t)buf);
  }
  else
  {
    uint64_t v8 = qword_100A19E38;
    if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_ERROR))
    {
      sub_1006AD3F0();
      id v9 = (id)objc_claimAutoreleasedReturnValue();
      sub_1004A82EC((unsigned __int8 *)(a1 + 424), buf);
      sub_10074E6DC(v9, (char *)buf, (uint64_t)v18, v8);
    }
  }
  int v13 = *(_DWORD *)(a1 + 516);
  if (v13 == -1)
  {
    int v14 = (int *)(a1 + 516);
    notify_register_check("com.apple.bluetooth.magnet", v14);
    int v13 = *v14;
  }
  notify_set_state(v13, 0);
  notify_post("com.apple.bluetooth.magnet");
}

void sub_100290AD4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t sub_100290B30(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 48);
  if (result)
  {
    sub_100278AB0(result);
    operator delete();
  }
  *(void *)(a1 + 48) = 0;
  return result;
}

uint64_t sub_100290B74(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t result = sub_10028B72C(a1, a2);
  if (result)
  {
    v11[0] = 0;
    v11[1] = 0;
    sub_10003AED0((uint64_t)v11, a1 + 360);
    if (a2)
    {
      for (uint64_t i = *(void *)(a1 + 336); i != *(void *)(a1 + 344); i += 8)
      {
        if (**(void **)i == a2)
        {
          uint64_t v8 = *(void *)(*(void *)i + 48);
          if (v8)
          {
            int v9 = *(_DWORD *)(a2 + 128);
            __int16 v10 = *(_WORD *)(a2 + 132);
            sub_100278EF8(v8, a1 + 424, (unsigned __int8 *)&v9, a3);
          }
          return sub_10003AFB4((uint64_t)v11);
        }
      }
    }
    return sub_10003AFB4((uint64_t)v11);
  }
  return result;
}

void sub_100290C1C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  sub_10003AFB4((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_100290C30(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t result = sub_10028B72C(a1, a2);
  if (result)
  {
    v11[0] = 0;
    v11[1] = 0;
    sub_10003AED0((uint64_t)v11, a1 + 360);
    if (a2)
    {
      for (uint64_t i = *(void *)(a1 + 336); i != *(void *)(a1 + 344); i += 8)
      {
        if (**(void **)i == a2)
        {
          uint64_t v8 = *(void *)(*(void *)i + 48);
          if (v8)
          {
            int v9 = *(_DWORD *)(a2 + 128);
            __int16 v10 = *(_WORD *)(a2 + 132);
            sub_1002793F0(v8, a1 + 424, (uint64_t)&v9, a3);
          }
          return sub_10003AFB4((uint64_t)v11);
        }
      }
    }
    return sub_10003AFB4((uint64_t)v11);
  }
  return result;
}

void sub_100290CD8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  sub_10003AFB4((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_100290CEC(uint64_t a1, uint64_t a2)
{
  v63[0] = 0;
  v63[1] = 0;
  sub_10003AED0((uint64_t)v63, a1 + 360);
  if (a2)
  {
    for (uint64_t i = *(void **)(a1 + 336); i != *(void **)(a1 + 344); ++i)
    {
      uint64_t v5 = (void *)*i;
      if (*(void *)*i == a2) {
        goto LABEL_7;
      }
    }
  }
  uint64_t v5 = 0;
LABEL_7:
  int v6 = qword_100A19E38;
  if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
  {
    sub_100474E18(a2, __p);
    uint64_t v7 = v57 >= 0 ? __p : (void **)__p[0];
    unint64_t v8 = *(char *)(a1 + 431);
    int v9 = v8 > 3 ? "Unknown" : off_1009A22B0[v8];
    *(_DWORD *)long long buf = 136446466;
    *(void *)&uint8_t buf[4] = v7;
    __int16 v67 = 2080;
    uint64_t v68 = v9;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "Easy unpair request for device %{public}s; Unpair Initiator: %s",
      buf,
      0x16u);
    if (SHIBYTE(v57) < 0) {
      operator delete(__p[0]);
    }
  }
  __p[0] = 0;
  __p[1] = __p;
  uint64_t v57 = 0x3812000000;
  uint64_t v58 = sub_10004CF9C;
  int v11 = (_DWORD *)(a2 + 128);
  int v10 = *(_DWORD *)(a2 + 128);
  unsigned int v59 = nullsub_21;
  uint64_t v60 = "";
  v61[0] = 0;
  __int16 v62 = 0;
  *(_DWORD *)&v61[1] = v10;
  __int16 v62 = *(_WORD *)(a2 + 132);
  uint64_t v12 = sub_100019878();
  v55[0] = _NSConcreteStackBlock;
  v55[1] = 3221225472;
  v55[2] = sub_1002916A8;
  v55[3] = &unk_1009995E0;
  uint64_t v55[4] = __p;
  sub_100013018(v12, v55);
  int v13 = *(unsigned __int8 *)(a1 + 431);
  if ((v13 | 2) == 3)
  {
    int v14 = qword_100A19E38;
    if (!os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_57;
    }
    sub_100474E18(a2, buf);
    int v15 = "user-switch";
    if (v13 == 1) {
      int v15 = "cloud";
    }
    __int16 v16 = v69 >= 0 ? buf : *(unsigned char **)buf;
    *(_DWORD *)int v64 = 136315394;
    *(void *)&v64[4] = v15;
    *(_WORD *)&v64[12] = 2082;
    *(void *)&v64[14] = v16;
    _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "Skip easy unpair request from %s: %{public}s", v64, 0x16u);
    if ((SHIBYTE(v69) & 0x80000000) == 0) {
      goto LABEL_57;
    }
    int v17 = *(void **)buf;
    goto LABEL_25;
  }
  if (!v5)
  {
    if (sub_100475E4C(a2, 0x80000u) != 4 || !sub_10028B72C(a1, a2) || *(unsigned char *)(a1 + 431)) {
      goto LABEL_57;
    }
    int v31 = qword_100A19E38;
    if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
    {
      sub_1004A82EC((unsigned __int8 *)(a1 + 424), v64);
      int v32 = v65;
      int v33 = *(char **)v64;
      sub_100474E18(a2, v53);
      __int16 v34 = v64;
      if (v32 < 0) {
        __int16 v34 = v33;
      }
      if (v54 >= 0) {
        int v35 = v53;
      }
      else {
        int v35 = (void **)v53[0];
      }
      int v36 = *(unsigned __int8 *)(a1 + 432);
      *(_DWORD *)long long buf = 141558787;
      *(void *)&uint8_t buf[4] = 1752392040;
      __int16 v67 = 2081;
      uint64_t v68 = v34;
      __int16 v69 = 2082;
      int v70 = v35;
      __int16 v71 = 1024;
      int v72 = v36;
      _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_DEFAULT, "Sending Easy Unpair request to device %{private, mask.hash}s for device %{public}s with version %d", buf, 0x26u);
      if (v54 < 0) {
        operator delete(v53[0]);
      }
      if (v65 < 0) {
        operator delete(*(void **)v64);
      }
    }
    LODWORD(v53[0]) = *v11;
    WORD2(v53[0]) = *(_WORD *)(a2 + 132);
    *(void *)int v64 = 0;
    *(void *)&v64[8] = 0;
    if (*(unsigned __int8 *)(a1 + 432) < 5u)
    {
      uint64_t v40 = sub_100373068();
      sub_1004A82EC((unsigned __int8 *)v53, v49);
      sub_100475EE0(a2, (uint64_t)buf);
      if (v69 >= 0) {
        uint64_t v41 = buf;
      }
      else {
        uint64_t v41 = *(unsigned char **)buf;
      }
      (*(void (**)(uint64_t, void *, unsigned char *, unsigned char *, uint64_t))(*(void *)v40 + 104))(v40, v49, v41, v64, 16);
      if (SHIBYTE(v69) < 0) {
        operator delete(*(void **)buf);
      }
      if ((v50 & 0x80000000) == 0) {
        goto LABEL_57;
      }
      uint64_t v39 = (void **)v49;
    }
    else
    {
      uint64_t v37 = sub_100373068();
      sub_1004A82EC((unsigned __int8 *)v53, v51);
      sub_100475EE0(a2, (uint64_t)buf);
      if (v69 >= 0) {
        uint64_t v38 = buf;
      }
      else {
        uint64_t v38 = *(unsigned char **)buf;
      }
      (*(void (**)(uint64_t, void *, unsigned char *, unsigned char *, uint64_t, void, void))(*(void *)v37 + 112))(v37, v51, v38, v64, 16, 0, 0);
      if (SHIBYTE(v69) < 0) {
        operator delete(*(void **)buf);
      }
      if ((v52 & 0x80000000) == 0) {
        goto LABEL_57;
      }
      uint64_t v39 = (void **)v51;
    }
    int v17 = *v39;
LABEL_25:
    operator delete(v17);
LABEL_57:
    uint64_t v27 = 0;
    *(unsigned char *)(a1 + 431) = 0;
    goto LABEL_58;
  }
  if (*(unsigned char *)(a1 + 328))
  {
    char v48 = 0;
    sub_10001B8E0(&v48);
    __int16 v47 = 0;
    int v46 = 0;
    if (qword_1009F8070 != -1) {
      dispatch_once(&qword_1009F8070, &stru_1009A1D70);
    }
    sub_1004E219C((uint64_t)off_1009F8068, (uint64_t)&v46);
    sub_10001B910(&v48);
    sub_100284D9C(a1, a2, (uint64_t)&v46, 0, 0);
    if (sub_10028B72C(a1, a2)) {
      sub_100284D9C(a1, a2, a1 + 424, 0, 0);
    }
    *((unsigned char *)v5 + 12) = 1;
    sub_100284EF0(a1, a2, (uint64_t)&v46);
    if (!sub_10028B72C(a1, a2)
      || *(unsigned char *)(a1 + 431) && (*(unsigned char *)(a1 + 431) != 1 || *(unsigned __int8 *)(a1 + 432) > 9u))
    {
      goto LABEL_70;
    }
    int v18 = qword_100A19E38;
    if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
    {
      sub_1004A82EC((unsigned __int8 *)(a1 + 424), v64);
      int v19 = v65;
      int v20 = *(char **)v64;
      sub_100474E18(a2, v53);
      int v21 = v64;
      if (v19 < 0) {
        int v21 = v20;
      }
      if (v54 >= 0) {
        __int16 v22 = v53;
      }
      else {
        __int16 v22 = (void **)v53[0];
      }
      int v23 = *(unsigned __int8 *)(a1 + 432);
      *(_DWORD *)long long buf = 141558787;
      *(void *)&uint8_t buf[4] = 1752392040;
      __int16 v67 = 2081;
      uint64_t v68 = v21;
      __int16 v69 = 2082;
      int v70 = v22;
      __int16 v71 = 1024;
      int v72 = v23;
      _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "Sending Easy Unpair request to device %{private, mask.hash}s for device %{public}s with version %d", buf, 0x26u);
      if (v54 < 0) {
        operator delete(v53[0]);
      }
      if (v65 < 0) {
        operator delete(*(void **)v64);
      }
    }
    LODWORD(v53[0]) = *v11;
    WORD2(v53[0]) = *(_WORD *)(a2 + 132);
    *(void *)int v64 = 0;
    *(void *)&v64[8] = 0;
    if (*(unsigned __int8 *)(a1 + 432) < 5u)
    {
      uint64_t v29 = sub_100373068();
      sub_1004A82EC((unsigned __int8 *)v53, v42);
      sub_100475EE0(a2, (uint64_t)buf);
      if (v69 >= 0) {
        __int16 v30 = buf;
      }
      else {
        __int16 v30 = *(unsigned char **)buf;
      }
      (*(void (**)(uint64_t, void *, unsigned char *, unsigned char *, uint64_t))(*(void *)v29 + 104))(v29, v42, v30, v64, 16);
      if (SHIBYTE(v69) < 0) {
        operator delete(*(void **)buf);
      }
      if ((v43 & 0x80000000) == 0) {
        goto LABEL_70;
      }
      __int16 v26 = (void **)v42;
    }
    else
    {
      uint64_t v24 = sub_100373068();
      sub_1004A82EC((unsigned __int8 *)v53, v44);
      sub_100475EE0(a2, (uint64_t)buf);
      if (v69 >= 0) {
        char v25 = buf;
      }
      else {
        char v25 = *(unsigned char **)buf;
      }
      (*(void (**)(uint64_t, void *, unsigned char *, unsigned char *, uint64_t, void, void))(*(void *)v24 + 112))(v24, v44, v25, v64, 16, 0, 0);
      if (SHIBYTE(v69) < 0) {
        operator delete(*(void **)buf);
      }
      if ((v45 & 0x80000000) == 0) {
        goto LABEL_70;
      }
      __int16 v26 = (void **)v44;
    }
    operator delete(*v26);
LABEL_70:
    *(unsigned char *)(a1 + 431) = 0;
    sub_10001B8AC(&v48);
    uint64_t v27 = 1;
    goto LABEL_58;
  }
  if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_ERROR)) {
    sub_10074E764();
  }
  uint64_t v27 = 0;
LABEL_58:
  _Block_object_dispose(__p, 8);
  sub_10003AFB4((uint64_t)v63);
  return v27;
}

void sub_100291548(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,int a21,__int16 a22,char a23,char a24,void *__p,uint64_t a26,int a27,__int16 a28,char a29,char a30,uint64_t a31,uint64_t a32,int a33,__int16 a34,char a35,char a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,char a45)
{
  if (*(char *)(v45 - 105) < 0) {
    operator delete(*(void **)(v45 - 128));
  }
  if (a30 < 0) {
    operator delete(__p);
  }
  _Block_object_dispose(&a45, 8);
  sub_10003AFB4(v45 - 176);
  _Unwind_Resume(a1);
}

const char *sub_100291680(uint64_t a1, unsigned int a2)
{
  if (a2 > 3) {
    return "Unknown";
  }
  else {
    return off_1009A22B0[(char)a2];
  }
}

uint64_t sub_1002916A8(uint64_t a1)
{
  if (qword_1009F85C8 != -1) {
    dispatch_once(&qword_1009F85C8, &stru_1009A1F70);
  }
  sub_1006F4278((uint64_t)off_1009F85C0, *(void *)(*(void *)(a1 + 32) + 8) + 48);
  if (qword_1009F7ED0 != -1) {
    dispatch_once(&qword_1009F7ED0, &stru_1009A1F30);
  }
  uint64_t v2 = qword_1009F7EC8;
  id v3 = (_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 48);

  return sub_10071170C(v2, v3);
}

uint64_t sub_100291754(uint64_t a1, uint64_t a2)
{
  v6[0] = 0;
  v6[1] = 0;
  sub_10003AED0((uint64_t)v6, a1 + 360);
  if (a2)
  {
    for (uint64_t i = *(uint64_t ***)(a1 + 336); i != *(uint64_t ***)(a1 + 344); ++i)
    {
      if (**i == a2)
      {
        sub_10028B794(a1, *i);
        return sub_10003AFB4((uint64_t)v6);
      }
    }
  }
  return sub_10003AFB4((uint64_t)v6);
}

void sub_1002917C8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_1002917DC(uint64_t a1, uint64_t a2, uint64_t a3, unsigned int a4)
{
  v12[0] = 0;
  v12[1] = 0;
  sub_10003AED0((uint64_t)v12, a1 + 360);
  if (a2)
  {
    for (uint64_t i = *(void ***)(a1 + 336); i != *(void ***)(a1 + 344); ++i)
    {
      if (**i == a2)
      {
        uint64_t v9 = sub_1002859A4(a1, a2, 1, a3, a4);
        goto LABEL_7;
      }
    }
  }
  uint64_t v9 = 312;
LABEL_7:
  uint64_t v10 = sub_100484CD8(a2, a3);
  sub_10028F48C(v10, a2);
  sub_10003AFB4((uint64_t)v12);
  return v9;
}

void sub_100291894(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_1002918A8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  sub_10047C6E0(a2, a3);
  v17[0] = 0;
  v17[1] = 0;
  sub_10003AED0((uint64_t)v17, a1 + 360);
  if (a2)
  {
    for (uint64_t i = *(void ***)(a1 + 336); i != *(void ***)(a1 + 344); ++i)
    {
      if (**i == a2)
      {
        if (a3)
        {
          sub_1002859A4(a1, a2, 7, 0, 2u);
          uint64_t v13 = 4;
          uint64_t v14 = a3;
        }
        else
        {
          uint64_t v14 = 0xFFFFFFFFLL;
          uint64_t v13 = 7;
        }
        uint64_t v7 = sub_1002859A4(a1, a2, v13, v14, 2u);
        goto LABEL_7;
      }
    }
  }
  uint64_t v7 = 1;
LABEL_7:
  uint64_t v8 = sub_100035F54();
  if (((*(uint64_t (**)(uint64_t))(*(void *)v8 + 328))(v8) & 1) != 0
    || (uint64_t v9 = sub_100035F54(), ((*(uint64_t (**)(uint64_t))(*(void *)v9 + 384))(v9) & 1) != 0)
    || (uint64_t v10 = sub_100035F54(), (*(unsigned int (**)(uint64_t))(*(void *)v10 + 424))(v10)))
  {
    sub_10028558C(a1, a2);
    if (qword_1009F8080 != -1) {
      dispatch_once(&qword_1009F8080, &stru_1009A1E50);
    }
    sub_10049FF74((uint64_t)off_1009F8078, a2, 4097);
    v15[0] = 0;
    v15[1] = 0;
    uint64_t v16 = 0;
    sub_1004B8C24((uint64_t)v15, 4, a2);
    LODWORD(v16) = a3;
    HIDWORD(v16) = a3;
    uint64_t v11 = sub_100050530();
    (*(void (**)(uint64_t, void *))(*(void *)v11 + 56))(v11, v15);
  }
  sub_10003AFB4((uint64_t)v17);
  return v7;
}

void sub_100291AA8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  sub_10003AFB4((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_100291AC0(uint64_t a1, uint64_t a2, unsigned int a3, unsigned int a4, int a5)
{
  if (!sub_100478B2C(a2, 14)) {
    return 11;
  }
  int v10 = sub_10047C698(a2);
  sub_10047C6E0(a2, a4 | (a3 << 8));
  v20[0] = 0;
  v20[1] = 0;
  sub_10003AED0((uint64_t)v20, a1 + 360);
  if (a2)
  {
    for (uint64_t i = *(void ***)(a1 + 336); i != *(void ***)(a1 + 344); ++i)
    {
      if (**i == a2)
      {
        uint64_t v12 = sub_1002859A4(a1, a2, 12, a4 | (a3 << 8), 2u);
        goto LABEL_9;
      }
    }
  }
  uint64_t v12 = 1;
LABEL_9:
  uint64_t v13 = sub_100035F54();
  if (((*(uint64_t (**)(uint64_t))(*(void *)v13 + 328))(v13) & 1) != 0
    || (uint64_t v14 = sub_100035F54(), ((*(uint64_t (**)(uint64_t))(*(void *)v14 + 384))(v14) & 1) != 0)
    || (uint64_t v15 = sub_100035F54(), (*(unsigned int (**)(uint64_t))(*(void *)v15 + 424))(v15)))
  {
    sub_10028558C(a1, a2);
    if (v10 != 0xFFFF && a5 == 2 && v10 != (a4 | (a3 << 8)))
    {
      if (qword_1009F8080 != -1) {
        dispatch_once(&qword_1009F8080, &stru_1009A1E50);
      }
      sub_10049FF74((uint64_t)off_1009F8078, a2, 4097);
    }
    v18[0] = 0;
    v18[1] = 0;
    unint64_t v19 = 0;
    sub_1004B8C24((uint64_t)v18, 4, a2);
    unint64_t v19 = __PAIR64__(a3, a4);
    uint64_t v16 = sub_100050530();
    (*(void (**)(uint64_t, void *))(*(void *)v16 + 56))(v16, v18);
  }
  sub_10003AFB4((uint64_t)v20);
  return v12;
}

void sub_100291CF4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  sub_10003AFB4((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_100291D0C(uint64_t a1, uint64_t a2, int a3, unsigned int a4)
{
  if (*(unsigned char *)(a1 + 328))
  {
    if (a3) {
      unsigned __int16 v8 = -1;
    }
    else {
      unsigned __int16 v8 = -3;
    }
    char v9 = sub_100487464(a2);
    int v10 = qword_100A19E38;
    if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
    {
      sub_100475EE0(a2, (uint64_t)__p);
      uint64_t v11 = (void **)__p[0];
      uint64_t v12 = "Disabled";
      if (v27 >= 0) {
        uint64_t v11 = __p;
      }
      if (a3) {
        uint64_t v12 = "Enabled";
      }
      *(_DWORD *)long long buf = 136315394;
      uint64_t v29 = v11;
      __int16 v30 = 2080;
      int v31 = v12;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "Set InEarDetection for device \"%s\", InEarDetection = \"%s\"", buf, 0x16u);
      if (v27 < 0) {
        operator delete(__p[0]);
      }
    }
    uint64_t v13 = sub_100485460(a2, a3, 1);
    sub_100292084(v13, a2);
    __p[0] = 0;
    __p[1] = 0;
    sub_10003AED0((uint64_t)__p, a1 + 360);
    if (a2)
    {
      for (uint64_t i = *(void **)(a1 + 336); i != *(void **)(a1 + 344); ++i)
      {
        uint64_t v15 = (void *)*i;
        if (*(void *)*i == a2)
        {
          sub_10028CD4C(a1, a2, 0xFFFFLL, v8);
          if (a3) {
            uint64_t v25 = 2;
          }
          else {
            uint64_t v25 = 1;
          }
          uint64_t v17 = sub_1002859A4(a1, a2, 10, v25, a4);
          if (a3)
          {
            int v16 = 0;
          }
          else
          {
            *((unsigned char *)v15 + 8) = 0;
            if (*((unsigned char *)v15 + 9) != 3) {
              *((unsigned char *)v15 + 9) = 0;
            }
            int v16 = 1;
          }
          goto LABEL_18;
        }
      }
    }
    int v16 = 0;
    uint64_t v17 = 312;
LABEL_18:
    sub_10003AFE8((uint64_t)__p);
    uint64_t v18 = sub_100035F54();
    if ((*(unsigned int (**)(uint64_t))(*(void *)v18 + 328))(v18)) {
      sub_10028558C(a1, a2);
    }
    uint64_t v19 = sub_100035F54();
    uint64_t v20 = (*(uint64_t (**)(uint64_t))(*(void *)v19 + 328))(v19);
    if ((v20 & 1) != 0
      || (v21 = sub_100035F54(), uint64_t v20 = (*(uint64_t (**)(uint64_t))(*(void *)v21 + 384))(v21),
                                 (v20 & 1) != 0)
      || (v22 = sub_100035F54(), uint64_t v20 = (*(uint64_t (**)(uint64_t))(*(void *)v22 + 424))(v22), v20))
    {
      if (v16)
      {
        if (a4 != 2) {
          goto LABEL_35;
        }
      }
      else
      {
        char v23 = v9;
        if (a4 != 2) {
          char v23 = 1;
        }
        if ((v23 & 1) != 0 || (a3 & 1) == 0) {
          goto LABEL_36;
        }
      }
      if (qword_1009F8080 != -1) {
        dispatch_once(&qword_1009F8080, &stru_1009A1E50);
      }
      uint64_t v20 = sub_10049FF74((uint64_t)off_1009F8078, a2, 4097);
    }
    if (!v16)
    {
LABEL_36:
      sub_10003AFB4((uint64_t)__p);
      return v17;
    }
LABEL_35:
    sub_10028F48C(v20, a2);
    goto LABEL_36;
  }
  return 111;
}

void sub_100292068(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
}

uint64_t sub_100292084(uint64_t a1, uint64_t a2)
{
  id v3 = qword_100A19E38;
  if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
  {
    sub_100475EE0(a2, (uint64_t)__p);
    uint64_t v4 = v9 >= 0 ? __p : (void **)__p[0];
    *(_DWORD *)long long buf = 136315138;
    uint64_t v11 = v4;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Notify in ear enabled change for device \"%s\"", buf, 0xCu);
    if (v9 < 0) {
      operator delete(__p[0]);
    }
  }
  uint64_t v5 = sub_1004AFA9C();
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 3221225472;
  void v7[2] = sub_1002A8984;
  void v7[3] = &unk_100997528;
  void v7[4] = a2;
  sub_100013018(v5, v7);
  if (qword_1009F8418 != -1) {
    dispatch_once(&qword_1009F8418, &stru_1009A1E10);
  }
  sub_10041437C((void *)qword_1009F8410, a2);
  if (qword_1009F7EF0 != -1) {
    dispatch_once(&qword_1009F7EF0, &stru_1009A1E30);
  }
  return sub_100455480((uint64_t)off_1009F7EE8, a2);
}

uint64_t sub_100292224(uint64_t a1, uint64_t a2, int a3)
{
  int v6 = qword_100A19E38;
  if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
  {
    sub_100474E18(a2, __p);
    uint64_t v7 = v28 >= 0 ? __p : *(unsigned char **)__p;
    *(_DWORD *)long long buf = 136446466;
    *(void *)&uint8_t buf[4] = v7;
    __int16 v23 = 1024;
    int v24 = a3;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "Received primary bud side notification for device %{public}s, with bud side = %d from other end of magnet", buf, 0x12u);
    if (SHIBYTE(v28) < 0) {
      operator delete(*(void **)__p);
    }
  }
  v21[0] = 0;
  v21[1] = 0;
  sub_10003AED0((uint64_t)v21, a1 + 360);
  if (a2)
  {
    for (uint64_t i = *(unsigned __int8 ***)(a1 + 336); i != *(unsigned __int8 ***)(a1 + 344); ++i)
    {
      char v9 = *i;
      if (*(void *)*i == a2)
      {
        v9[11] = a3;
        int v10 = qword_100A19E38;
        if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
        {
          int v11 = v9[10];
          int v12 = v9[9];
          *(_DWORD *)std::string __p = 67109632;
          *(_DWORD *)&__p[4] = a3;
          *(_WORD *)&__p[8] = 1024;
          *(_DWORD *)&__p[10] = v11;
          *(_WORD *)char v27 = 1024;
          *(_DWORD *)&char v27[2] = v12;
          _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "Primary bud info over magnet link -> %d, current connection primary bud info -> %d, current connection secondary bud in ear status -> %d", __p, 0x14u);
        }
        uint64_t v13 = sub_100035F54();
        if (!(*(unsigned int (**)(uint64_t))(*(void *)v13 + 344))(v13)) {
          break;
        }
        uint64_t v14 = 0;
        if (a3 != 3 && v9[10] != a3)
        {
          if (v9[9] != 3) {
            break;
          }
          uint64_t v15 = qword_100A19E38;
          if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
          {
            sub_100474E18(a2, buf);
            int v16 = v25 >= 0 ? buf : *(unsigned char **)buf;
            int v17 = v9[10];
            *(_DWORD *)std::string __p = 136446722;
            *(void *)&__p[4] = v16;
            *(_WORD *)&unsigned char __p[12] = 1024;
            *(_DWORD *)char v27 = v17;
            *(_WORD *)&v27[4] = 1024;
            int v28 = a3;
            _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "Info update from Magnet, Primary bud side  for device %{public}s seen locally is different from that of companion, we see  %d, and companion sees %d. Requesting connected bud to go secondary", __p, 0x18u);
            if (v25 < 0) {
              operator delete(*(void **)buf);
            }
          }
          uint64_t v14 = sub_1002859A4(a1, a2, 8, 2, 1u);
          uint64_t v18 = qword_100A19E38;
          if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
          {
            sub_100474E18(a2, __p);
            uint64_t v19 = v28 >= 0 ? __p : *(unsigned char **)__p;
            *(_DWORD *)long long buf = 136315138;
            *(void *)&uint8_t buf[4] = v19;
            _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "Schedule reconnection to W1 device after LSTO (5 seconds) on Gizmo, device addr : %s", buf, 0xCu);
            if (SHIBYTE(v28) < 0) {
              operator delete(*(void **)__p);
            }
          }
          *(_DWORD *)std::string __p = *(_DWORD *)(a2 + 128);
          *(_WORD *)&__p[4] = *(_WORD *)(a2 + 132);
          if (qword_1009F8090 != -1) {
            dispatch_once(&qword_1009F8090, &stru_1009A1ED0);
          }
          sub_1004D6030((uint64_t)off_1009F8088, __p);
        }
        goto LABEL_34;
      }
    }
  }
  uint64_t v14 = 0;
LABEL_34:
  sub_10003AFB4((uint64_t)v21);
  return v14;
}

void sub_10029259C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_1002925C4(uint64_t a1, uint64_t a2)
{
  v21[0] = 0;
  v21[1] = 0;
  sub_10003AED0((uint64_t)v21, a1 + 360);
  if (a2)
  {
    for (uint64_t i = *(uint64_t **)(a1 + 336); i != *(uint64_t **)(a1 + 344); ++i)
    {
      uint64_t v5 = *i;
      if (*(void *)*i == a2)
      {
        if (sub_10028BC74(*i))
        {
          char v9 = qword_100A19E38;
          if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
          {
            if (*(unsigned char *)(v5 + 617)) {
              uint64_t v17 = v5 + 611;
            }
            else {
              uint64_t v17 = v5 + 605;
            }
            int v19 = *(_DWORD *)v17;
            __int16 v20 = *(_WORD *)(v17 + 4);
            uint64_t v18 = sub_10025B48C((uint64_t)&v19, v10, v11, v12, v13, v14, v15, v16);
            *(_DWORD *)long long buf = 136446210;
            uint64_t v23 = v18;
            _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "Peer source \"%{public}s\" is currently connected in TiPi, skip connection stealing", buf, 0xCu);
          }
          uint64_t v6 = 17;
        }
        else
        {
          if (sub_10028B72C(a1, a2))
          {
            sub_10028B794(a1, (uint64_t *)v5);
            uint64_t v6 = 0;
            goto LABEL_9;
          }
          uint64_t v6 = 1;
        }
        goto LABEL_7;
      }
    }
  }
  uint64_t v6 = 7;
LABEL_7:
  uint64_t v7 = qword_100A19E38;
  if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 67109120;
    LODWORD(v23) = v6;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "reformTriangle: Conditions not met for easy pairing, result %d", buf, 8u);
  }
LABEL_9:
  sub_10003AFB4((uint64_t)v21);
  return v6;
}

void sub_100292770(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  sub_10003AFB4((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_100292790(uint64_t a1)
{
  return a1 + 560;
}

void sub_100292798(uint64_t a1)
{
  uint64_t v1 = qword_100A19E38;
  if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_DEFAULT, "statedump: ----------------- AACP connections ------------------", buf, 2u);
  }
  *(void *)long long buf = 0;
  BOOL v42 = 0;
  uint64_t v43 = 0;
  sub_100040550(buf, a1 + 336);
  uint64_t v2 = *(uint64_t ***)buf;
  if (*(uint64_t ***)buf != v42)
  {
    while (1)
    {
      uint64_t v3 = **v2;
      int v4 = *((_DWORD *)*v2 + 20);
      uint64_t v5 = qword_100A19E38;
      if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
      {
        sub_100474E18(v3, &v52);
        uint64_t v6 = &v52;
        if (v53 < 0) {
          uint64_t v6 = (long long *)v52;
        }
        *(_DWORD *)uint32_t v44 = 136446466;
        *(void *)&v44[4] = v6;
        __int16 v45 = 1024;
        LODWORD(v46) = v4;
        _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "statedump: Device %{public}s (pId 0x%04X)", v44, 0x12u);
        if (SHIBYTE(v53) < 0) {
          operator delete((void *)v52);
        }
      }
      if ((v4 - 8194) > 0xE || ((1 << (v4 - 2)) & 0x409B) == 0)
      {
        uint64_t v37 = qword_100A19E38;
        if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
        {
          BOOL v38 = sub_100480504(v3);
          uint64_t v39 = "no";
          if (v38) {
            uint64_t v39 = "yes";
          }
          LODWORD(v52) = 136446210;
          *(void *)((char *)&v52 + 4) = v39;
          _os_log_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_DEFAULT, "statedump:   Dev-fused: %{public}s", (uint8_t *)&v52, 0xCu);
        }
      }
      long long v52 = 0uLL;
      uint64_t v53 = 0;
      sub_100480344(v3, 0xAu, &v52);
      unint64_t v8 = HIBYTE(v53);
      int v9 = SHIBYTE(v53);
      if (v53 < 0) {
        unint64_t v8 = *((void *)&v52 + 1);
      }
      uint64_t v10 = qword_100A19E38;
      if (v8 >= 2 && os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v11 = (long long *)v52;
        if (v9 >= 0) {
          uint64_t v11 = &v52;
        }
        *(_DWORD *)uint32_t v44 = 136446210;
        *(void *)&v44[4] = v11;
        _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "statedump:   Firmware version: %{public}s", v44, 0xCu);
        uint64_t v10 = qword_100A19E38;
      }
      BOOL v12 = os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT);
      if (v12)
      {
        unsigned __int8 v13 = sub_10048741C(v3);
        uint64_t v14 = "unknown";
        if (v13 <= 2u) {
          uint64_t v14 = off_1009A22D0[(char)v13];
        }
        *(_DWORD *)uint32_t v44 = 136446466;
        *(void *)&v44[4] = "Mic mode";
        __int16 v45 = 2082;
        int v46 = v14;
        _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "statedump:   %{public}s: %{public}s", v44, 0x16u);
      }
      if (sub_10028CB30(v12, v3))
      {
        uint64_t v15 = qword_100A19E38;
        if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
        {
          int v16 = sub_100487464(v3);
          *(_DWORD *)uint32_t v44 = 136446466;
          uint64_t v17 = "Disabled";
          if (v16) {
            uint64_t v17 = "Enabled";
          }
          *(void *)&v44[4] = "In Ear detection";
          __int16 v45 = 2082;
          int v46 = v17;
          _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "statedump:   %{public}s: %{public}s", v44, 0x16u);
        }
      }
      if (sub_100478B2C(v3, 30)) {
        break;
      }
      if (sub_100478B2C(v3, 14))
      {
        int v19 = 12;
        goto LABEL_33;
      }
      if (v4 - 8194) < 0xF && ((0x409Bu >> (v4 - 2)))
      {
        int v19 = 4;
LABEL_33:
        unsigned int v18 = sub_10047C698(v3);
LABEL_34:
        __int16 v20 = qword_100A19E38;
        if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v21 = sub_1002872A4(a1, v19, v18, v44);
          uint64_t v22 = sub_100287278((uint64_t)v21, v19);
          uint64_t v23 = v47 >= 0 ? v44 : *(unsigned char **)v44;
          *(_DWORD *)char v48 = 136446466;
          uint64_t v49 = v22;
          __int16 v50 = 2082;
          unsigned int v51 = v23;
          _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "statedump:   %{public}s: %{public}s", v48, 0x16u);
          if (v47 < 0) {
            operator delete(*(void **)v44);
          }
        }
      }
      if ((sub_100478B2C(v3, 16) & 1) != 0 || sub_100478B2C(v3, 17))
      {
        int v24 = qword_100A19E38;
        if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
        {
          unsigned int v25 = sub_100487564(v3) - 1;
          __int16 v26 = "unknown";
          if (v25 <= 3) {
            __int16 v26 = off_1009A2320[v25];
          }
          sub_10004191C(v44, v26);
          if (v47 >= 0) {
            char v27 = v44;
          }
          else {
            char v27 = *(unsigned char **)v44;
          }
          *(_DWORD *)char v48 = 136446466;
          uint64_t v49 = "Listen mode";
          __int16 v50 = 2082;
          unsigned int v51 = v27;
          _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "statedump:   %{public}s: %{public}s", v48, 0x16u);
          if (v47 < 0) {
            operator delete(*(void **)v44);
          }
        }
      }
      if (sub_100478B2C(v3, 28))
      {
        int v28 = qword_100A19E38;
        if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v29 = sub_1004875AC(v3);
          __int16 v30 = (char *)sub_1002A8D50(v29, v29);
          sub_10004191C(v44, v30);
          int v31 = v47 >= 0 ? v44 : *(unsigned char **)v44;
          *(_DWORD *)char v48 = 136446466;
          uint64_t v49 = "Listening Mode Configs";
          __int16 v50 = 2082;
          unsigned int v51 = v31;
          _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, "statedump:   %{public}s: %{public}s", v48, 0x16u);
          if (v47 < 0) {
            operator delete(*(void **)v44);
          }
        }
      }
      if (sub_100478B2C(v3, 16))
      {
        if (sub_100478B2C(v3, 1))
        {
          int v32 = qword_100A19E38;
          if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
          {
            int v33 = sub_1004877EC(v3);
            __int16 v34 = "unknown";
            if (v33 == 1) {
              __int16 v34 = "Enabled";
            }
            if (v33 == 2) {
              int v35 = "Disabled";
            }
            else {
              int v35 = (char *)v34;
            }
            sub_10004191C(v44, v35);
            if (v47 >= 0) {
              int v36 = v44;
            }
            else {
              int v36 = *(unsigned char **)v44;
            }
            *(_DWORD *)char v48 = 136446466;
            uint64_t v49 = "One Bud ANC Mode";
            __int16 v50 = 2082;
            unsigned int v51 = v36;
            _os_log_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_DEFAULT, "statedump:   %{public}s: %{public}s", v48, 0x16u);
            if (v47 < 0) {
              operator delete(*(void **)v44);
            }
          }
        }
      }
      if (SHIBYTE(v53) < 0) {
        operator delete((void *)v52);
      }
      if (++v2 == v42)
      {
        uint64_t v2 = *(uint64_t ***)buf;
        goto LABEL_81;
      }
    }
    unsigned int v18 = sub_100487714(v3);
    int v19 = 22;
    goto LABEL_34;
  }
LABEL_81:
  if (v2)
  {
    BOOL v42 = v2;
    operator delete(v2);
  }
}

void sub_100292E70(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
}

id sub_100292ED4(uint64_t a1, uint64_t a2)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_100A120A8, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_100A120A8))
  {
    uint64_t v21 = +[NSCharacterSet alphanumericCharacterSet];
    qword_100A120A0 = [v21 invertedSet];

    __cxa_guard_release(&qword_100A120A8);
  }
  if (qword_1009F7F00 != -1) {
    dispatch_once(&qword_1009F7F00, &stru_1009A1E70);
  }
  LODWORD(__p[0]) = *(_DWORD *)a2;
  WORD2(__p[0]) = *(_WORD *)(a2 + 4);
  uint64_t v3 = (void *)sub_1004AA194((uint64_t)off_1009F7EF8, (uint64_t)__p, 1);
  uint64_t v11 = +[NSString stringWithFormat:@"%s", sub_10025B48C(a2, v4, v5, v6, v7, v8, v9, v10)];
  BOOL v12 = [v11 stringByReplacingOccurrencesOfString:@":" withString:&stru_1009C1AC8];

  uint64_t v13 = sub_100017768();
  if ((*(unsigned int (**)(uint64_t))(*(void *)v13 + 8))(v13))
  {
    if (v3)
    {
      sub_100475EE0((uint64_t)v3, (uint64_t)__p);
      if (v23 >= 0) {
        uint64_t v14 = __p;
      }
      else {
        uint64_t v14 = (void **)__p[0];
      }
      uint64_t v15 = +[NSString stringWithUTF8String:v14];
      if (v23 < 0) {
        operator delete(__p[0]);
      }
      int v16 = [v15 componentsSeparatedByCharactersInSet:qword_100A120A0];
      uint64_t v17 = [v16 componentsJoinedByString:&stru_1009C1AC8];

      if ((unint64_t)[v17 length] < 0x41)
      {
        uint64_t v3 = v17;
      }
      else
      {
        uint64_t v18 = [v17 substringToIndex:64];

        uint64_t v3 = (void *)v18;
      }
    }
    id v19 = +[NSString stringWithFormat:@"%@_%@", v12, v3];
  }
  else
  {
    id v19 = v12;
  }

  return v19;
}

void sub_100293130(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  __cxa_guard_abort(&qword_100A120A8);
  _Unwind_Resume(a1);
}

id sub_100293198(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = sub_100292ED4(a1, a2);
  uint64_t v3 = +[NSString stringWithFormat:@"/private/var/mobile/Library/Logs/Bluetooth/AccessoryVersionInfo_%@.txt", v2];

  return v3;
}

void sub_100293204(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t sub_100293214(uint64_t a1, uint64_t a2, const void *a3, unsigned int a4)
{
  uint64_t v4 = qword_100A19E38;
  if (*(unsigned char *)(a1 + 328))
  {
    if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
    {
      sub_100475EE0(a2, (uint64_t)__p);
      uint64_t v8 = v13 >= 0 ? __p : (void **)__p[0];
      *(_DWORD *)long long buf = 67109635;
      unsigned int v15 = a4;
      __int16 v16 = 2160;
      uint64_t v17 = 1752392040;
      __int16 v18 = 2081;
      id v19 = v8;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "sendSmartRoutingInformation: Sending SR 2.0 info of length %u to %{private, mask.hash}s", buf, 0x1Cu);
      if (v13 < 0) {
        operator delete(__p[0]);
      }
    }
    buf[0] = 0;
    sub_10001B8E0(buf);
    uint64_t v9 = sub_1000D9E48((unsigned __int8 *)(a2 + 128), a3, a4);
    sub_10001B910(buf);
    if (v9 && os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_ERROR)) {
      sub_10074E7CC();
    }
    if (qword_1009F8070 != -1) {
      dispatch_once(&qword_1009F8070, &stru_1009A1D70);
    }
    uint64_t v10 = sub_1004E2340((uint64_t)off_1009F8068, v9, 10000);
    sub_10001B8AC(buf);
  }
  else
  {
    if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_ERROR)) {
      sub_10074E798();
    }
    return 111;
  }
  return v10;
}

void sub_1002933E0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13)
{
}

uint64_t sub_1002933FC(uint64_t a1, uint64_t a2, const void *a3, unsigned int a4)
{
  uint64_t v4 = qword_100A19E38;
  if (*(unsigned char *)(a1 + 328))
  {
    if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
    {
      sub_100475EE0(a2, (uint64_t)__p);
      uint64_t v8 = v13 >= 0 ? __p : (void **)__p[0];
      *(_DWORD *)long long buf = 67109635;
      unsigned int v15 = a4;
      __int16 v16 = 2160;
      uint64_t v17 = 1752392040;
      __int16 v18 = 2081;
      id v19 = v8;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "sendConversationDetectMessage: Sending CD Message of length %u to %{private, mask.hash}s", buf, 0x1Cu);
      if (v13 < 0) {
        operator delete(__p[0]);
      }
    }
    buf[0] = 0;
    sub_10001B8E0(buf);
    uint64_t v9 = sub_1000D9F90((unsigned __int8 *)(a2 + 128), a3, a4);
    sub_10001B910(buf);
    if (v9 && os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_ERROR)) {
      sub_10074E868();
    }
    if (qword_1009F8070 != -1) {
      dispatch_once(&qword_1009F8070, &stru_1009A1D70);
    }
    uint64_t v10 = sub_1004E2340((uint64_t)off_1009F8068, v9, 10000);
    sub_10001B8AC(buf);
  }
  else
  {
    if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_ERROR)) {
      sub_10074E834();
    }
    return 111;
  }
  return v10;
}

void sub_1002935C8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13)
{
}

uint64_t sub_1002935E4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = qword_100A19E38;
  if (*(unsigned char *)(a1 + 328))
  {
    if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
    {
      sub_100475EE0(a2, (uint64_t)__p);
      uint64_t v6 = v12 >= 0 ? __p : (void **)__p[0];
      *(_DWORD *)long long buf = 134218499;
      uint64_t v14 = a3;
      __int16 v15 = 2160;
      uint64_t v16 = 1752392040;
      __int16 v17 = 2081;
      __int16 v18 = v6;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "sendFeatureProxCardStatusUpdate: Sending prox card status bitmask 0x%02llX to %{private, mask.hash}s", buf, 0x20u);
      if (v12 < 0) {
        operator delete(__p[0]);
      }
    }
    uint64_t v7 = sub_100477E48(a2);
    sub_100477DB4(a2, v7 | a3);
    buf[0] = 0;
    sub_10001B8E0(buf);
    uint64_t v8 = sub_1000DA620((unsigned __int8 *)(a2 + 128), a3);
    sub_10001B910(buf);
    if (v8 && os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_ERROR)) {
      sub_10074E904();
    }
    if (qword_1009F8070 != -1) {
      dispatch_once(&qword_1009F8070, &stru_1009A1D70);
    }
    uint64_t v9 = sub_1004E2340((uint64_t)off_1009F8068, v8, 10000);
    sub_10001B8AC(buf);
  }
  else
  {
    if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_ERROR)) {
      sub_10074E8D0();
    }
    return 111;
  }
  return v9;
}

void sub_1002937BC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  sub_10001B8AC(va);
  _Unwind_Resume(a1);
}

uint64_t sub_1002937D8(uint64_t a1, uint64_t a2, unsigned int a3, const void *a4)
{
  uint64_t v4 = qword_100A19E38;
  if (*(unsigned char *)(a1 + 328))
  {
    if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
    {
      sub_100475EE0(a2, (uint64_t)__p);
      uint64_t v8 = v13 >= 0 ? __p : (void **)__p[0];
      *(_DWORD *)long long buf = 67109635;
      unsigned int v15 = a3;
      __int16 v16 = 2160;
      uint64_t v17 = 1752392040;
      __int16 v18 = 2081;
      id v19 = v8;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "sendSourceContextMessage: Sending source context message of length %u to %{private, mask.hash}s", buf, 0x1Cu);
      if (v13 < 0) {
        operator delete(__p[0]);
      }
    }
    buf[0] = 0;
    sub_10001B8E0(buf);
    uint64_t v9 = sub_1000DA6DC((unsigned __int8 *)(a2 + 128), a3, a4);
    sub_10001B910(buf);
    if (v9 && os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_ERROR)) {
      sub_10074E9A0();
    }
    if (qword_1009F8070 != -1) {
      dispatch_once(&qword_1009F8070, &stru_1009A1D70);
    }
    uint64_t v10 = sub_1004E2340((uint64_t)off_1009F8068, v9, 10000);
    sub_10001B8AC(buf);
  }
  else
  {
    if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_ERROR)) {
      sub_10074E96C();
    }
    return 111;
  }
  return v10;
}

void sub_1002939A4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13)
{
}

uint64_t sub_1002939C0(uint64_t a1, uint64_t a2, unsigned int a3, unsigned __int8 *a4)
{
  if (*(unsigned char *)(a1 + 328))
  {
    v14[0] = 0;
    v14[1] = 0;
    sub_10003AED0((uint64_t)v14, a1 + 360);
    if (a2)
    {
      for (uint64_t i = *(void ***)(a1 + 336); i != *(void ***)(a1 + 344); ++i)
      {
        if (**i == a2)
        {
          v16[0] = 0;
          sub_10001B8E0(v16);
          uint64_t v11 = sub_1000DA2A8((unsigned __int8 *)(a2 + 128), a3, a4);
          sub_10001B910(v16);
          char v12 = qword_100A19E38;
          if (v11)
          {
            if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_ERROR)) {
              sub_10074EA3C();
            }
          }
          else if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
          {
            int v13 = *a4;
            *(_DWORD *)long long buf = 67109120;
            *(_DWORD *)&uint8_t buf[4] = v13;
            _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "sendAdaptiveVolumeMessage: message sent of subtype %u", buf, 8u);
          }
          if (qword_1009F8070 != -1) {
            dispatch_once(&qword_1009F8070, &stru_1009A1D70);
          }
          uint64_t v9 = sub_1004E2340((uint64_t)off_1009F8068, v11, 10000);
          sub_10001B8AC(v16);
          goto LABEL_10;
        }
      }
    }
    if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_ERROR))
    {
      sub_100474E18(a2, buf);
      sub_10074E044();
    }
    uint64_t v9 = 312;
LABEL_10:
    sub_10003AFB4((uint64_t)v14);
  }
  else
  {
    if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_ERROR)) {
      sub_10074EA08();
    }
    return 111;
  }
  return v9;
}

void sub_100293BC4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_100293BF4(uint64_t a1, uint64_t a2, unsigned int a3, unsigned __int8 *a4)
{
  if (*(unsigned char *)(a1 + 328))
  {
    v14[0] = 0;
    v14[1] = 0;
    sub_10003AED0((uint64_t)v14, a1 + 360);
    if (a2)
    {
      for (uint64_t i = *(void ***)(a1 + 336); i != *(void ***)(a1 + 344); ++i)
      {
        if (**i == a2)
        {
          v16[0] = 0;
          sub_10001B8E0(v16);
          uint64_t v11 = sub_1000DA850((unsigned __int8 *)(a2 + 128), a3, a4);
          sub_10001B910(v16);
          char v12 = qword_100A19E38;
          if (v11)
          {
            if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_ERROR)) {
              sub_10074EAD8();
            }
          }
          else if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
          {
            int v13 = *a4;
            *(_DWORD *)long long buf = 67109120;
            *(_DWORD *)&uint8_t buf[4] = v13;
            _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "sendPMEConfigMessage: message sent of subtype %u", buf, 8u);
          }
          if (qword_1009F8070 != -1) {
            dispatch_once(&qword_1009F8070, &stru_1009A1D70);
          }
          uint64_t v9 = sub_1004E2340((uint64_t)off_1009F8068, v11, 10000);
          sub_10001B8AC(v16);
          goto LABEL_10;
        }
      }
    }
    if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_ERROR))
    {
      sub_100474E18(a2, buf);
      sub_10074E044();
    }
    uint64_t v9 = 312;
LABEL_10:
    sub_10003AFB4((uint64_t)v14);
  }
  else
  {
    if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_ERROR)) {
      sub_10074EAA4();
    }
    return 111;
  }
  return v9;
}

void sub_100293DF8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_100293E28(uint64_t a1, uint64_t a2, unsigned int a3, const void *a4)
{
  if (*(unsigned char *)(a1 + 328))
  {
    v13[0] = 0;
    v13[1] = 0;
    sub_10003AED0((uint64_t)v13, a1 + 360);
    if (a2)
    {
      for (uint64_t i = *(void ***)(a1 + 336); i != *(void ***)(a1 + 344); ++i)
      {
        if (**i == a2)
        {
          LOBYTE(v12[0]) = 0;
          sub_10001B8E0(v12);
          uint64_t v11 = sub_1000DA3F0((unsigned __int8 *)(a2 + 128), a3, a4);
          sub_10001B910(v12);
          if (v11 && os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_ERROR)) {
            sub_10074EB74();
          }
          if (qword_1009F8070 != -1) {
            dispatch_once(&qword_1009F8070, &stru_1009A1D70);
          }
          uint64_t v9 = sub_1004E2340((uint64_t)off_1009F8068, v11, 10000);
          sub_10001B8AC(v12);
          goto LABEL_10;
        }
      }
    }
    if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_ERROR))
    {
      sub_100474E18(a2, v12);
      sub_10074E044();
    }
    uint64_t v9 = 312;
LABEL_10:
    sub_10003AFB4((uint64_t)v13);
  }
  else
  {
    if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_ERROR)) {
      sub_10074EB40();
    }
    return 111;
  }
  return v9;
}

void sub_100293FE4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  sub_10003AFB4((uint64_t)va);
  _Unwind_Resume(a1);
}

id sub_100294014(uint64_t a1, unsigned int a2)
{
  char v2 = a2;
  uint64_t v3 = +[NSString stringWithFormat:@"%d%c%d", (a2 >> 20) & 0xF, (HIWORD(a2) & 0xF) + 65, (unsigned __int16)a2 >> 4];
  if ((v2 & 0xF) != 0)
  {
    uint64_t v4 = +[NSString stringWithFormat:@"%@%c", v3, v2 & 0xF | 0x60u];

    uint64_t v3 = (void *)v4;
  }

  return v3;
}

void sub_1002940BC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1002940CC(void *a1, uint64_t a2)
{
  if (qword_1009F7F00 != -1) {
    dispatch_once(&qword_1009F7F00, &stru_1009A1E70);
  }
  LODWORD(__p[0]) = *(_DWORD *)a2;
  WORD2(__p[0]) = *(_WORD *)(a2 + 4);
  uint64_t v4 = sub_1004AA194((uint64_t)off_1009F7EF8, (uint64_t)__p, 1);
  uint64_t v5 = qword_100A19E38;
  if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
  {
    sub_100475EE0(v4, (uint64_t)__p);
    int v6 = v18;
    uint64_t v7 = (void **)__p[0];
    uint64_t v15 = sub_10025B48C(a2, v8, v9, v10, v11, v12, v13, v14);
    __int16 v16 = __p;
    if (v6 < 0) {
      __int16 v16 = v7;
    }
    *(_DWORD *)long long buf = 136315394;
    __int16 v20 = v16;
    __int16 v21 = 2080;
    uint64_t v22 = v15;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "AACP Connection attempt by device \"%s\", addr \"%s\",", buf, 0x16u);
    if (v18 < 0) {
      operator delete(__p[0]);
    }
  }
  sub_1004BD554(a1, v4);
}

void sub_100294228(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_10029424C(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  if (qword_1009F7F00 != -1) {
    dispatch_once(&qword_1009F7F00, &stru_1009A1E70);
  }
  *(_DWORD *)std::string __p = *(_DWORD *)a2;
  *(_WORD *)&__p[4] = *(_WORD *)(a2 + 4);
  uint64_t v8 = sub_1004AA194((uint64_t)off_1009F7EF8, (uint64_t)__p, 1);
  uint64_t v9 = qword_100A19E38;
  BOOL v10 = os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT);
  if (a4)
  {
    if (v10)
    {
      sub_100475EE0(v8, (uint64_t)__p);
      uint64_t v11 = v31 >= 0 ? __p : *(unsigned char **)__p;
      *(_DWORD *)int v24 = 136315394;
      *(void *)&v24[4] = v11;
      __int16 v25 = 1024;
      int v26 = a4;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "connection to device \"%s\" failed... reason %d", v24, 0x12u);
      if (SHIBYTE(v31) < 0) {
        operator delete(*(void **)__p);
      }
    }
    if (qword_1009F8070 != -1) {
      dispatch_once(&qword_1009F8070, &stru_1009A1D70);
    }
    int v12 = sub_1004E2340((uint64_t)off_1009F8068, a4, 20000);
    sub_1004BD6C8(a1, v8, v12);
  }
  if (v10)
  {
    sub_100475EE0(v8, (uint64_t)v24);
    int v13 = v27;
    uint64_t v14 = *(unsigned char **)v24;
    uint64_t v22 = sub_10025B48C(a2, v15, v16, v17, v18, v19, v20, v21);
    char v23 = v24;
    *(_DWORD *)std::string __p = 136315906;
    if (v13 < 0) {
      char v23 = v14;
    }
    *(void *)&__p[4] = v23;
    __int16 v29 = 2080;
    uint64_t v30 = v22;
    __int16 v31 = 1024;
    int v32 = a3;
    __int16 v33 = 1024;
    int v34 = 0;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "Connection succeeded to device \"%s\", addr \"%s\", mtu %d, result %d", __p, 0x22u);
    if (v27 < 0) {
      operator delete(*(void **)v24);
    }
  }
  sub_1004BD6C8(a1, v8, 0);
}

void sub_1002944A8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1002944CC(void *a1, unsigned __int8 *a2, int a3)
{
  unint64_t v5 = ((unint64_t)*a2 << 40) | ((unint64_t)a2[1] << 32) | ((unint64_t)a2[2] << 24) | ((unint64_t)a2[3] << 16) | ((unint64_t)a2[4] << 8) | a2[5];
  if (qword_1009F7F00 != -1) {
    dispatch_once(&qword_1009F7F00, &stru_1009A1E70);
  }
  uint64_t v6 = sub_100030F10((uint64_t)off_1009F7EF8, v5, 1);
  if (v6)
  {
    uint64_t v7 = v6;
    sub_100486CBC(v6, 0);
    v17[0] = 0;
    v17[1] = 0;
    sub_10003AED0((uint64_t)v17, (uint64_t)(a1 + 45));
    for (uint64_t i = (uint64_t **)a1[42]; i != (uint64_t **)a1[43]; ++i)
    {
      uint64_t v9 = *i;
      if (**i == v7) {
        goto LABEL_9;
      }
    }
    uint64_t v9 = 0;
LABEL_9:
    BOOL v10 = qword_100A19E38;
    if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT)
      && ((sub_100475EE0(v7, (uint64_t)__p), v16 >= 0) ? (uint64_t v11 = __p) : (uint64_t v11 = (void **)__p[0]),
          *(_DWORD *)long long buf = 136315394,
          uint64_t v19 = v11,
          __int16 v20 = 1024,
          int v21 = a3,
          _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "disconnecting \"%s\", reason = %d", buf, 0x12u), v16 < 0))
    {
      operator delete(__p[0]);
      if (v9)
      {
LABEL_15:
        if ((*(unsigned int (**)(uint64_t))(*(void *)v9[96] + 176))(v9[96]) == 1)
        {
          sub_1004BE538((uint64_t)a1, v7, 0);
          sub_1002947CC(a1, v9);
        }
LABEL_22:
        if (a3 == 734 || a3 == 708)
        {
          uint64_t v13 = sub_1004AF8EC();
          v14[0] = _NSConcreteStackBlock;
          v14[1] = 3221225472;
          void v14[2] = sub_10029495C;
          v14[3] = &unk_1009A12D0;
          void v14[4] = a1;
          v14[5] = v7;
          v14[6] = v5;
          sub_1004AFF58(v13, 5000, v14);
        }
        sub_10003AFB4((uint64_t)v17);
        return;
      }
    }
    else if (v9)
    {
      goto LABEL_15;
    }
    if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_ERROR))
    {
      sub_100475EE0(v7, (uint64_t)__p);
      sub_10074EC6C();
    }
    goto LABEL_22;
  }
  int v12 = qword_100A19E38;
  if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_ERROR)) {
    sub_10074EBDC(v5, v12);
  }
}

void sub_1002947A8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  sub_10003AFB4((uint64_t)va);
  _Unwind_Resume(a1);
}

void *sub_1002947CC(void *result, uint64_t *a2)
{
  uint64_t v3 = result;
  uint64_t v4 = (char *)result[42];
  unint64_t v5 = (char *)result[43];
  uint64_t v6 = v4;
  if (v4 != v5)
  {
    while ((uint64_t *)*v6 != a2)
    {
      if (++v6 == (void *)v5)
      {
        uint64_t v6 = (void *)result[43];
        break;
      }
    }
  }
  if (v6 != (void *)v5)
  {
    uint64_t v7 = *a2;
    int64_t v8 = v5 - (char *)(v6 + 1);
    if (v5 != (char *)(v6 + 1)) {
      memmove(v6, v6 + 1, v5 - (char *)(v6 + 1));
    }
    v3[43] = (char *)v6 + v8;
    sub_1002A8634(a2);
    sub_1002A2170(v9, (uint64_t)a2);
    sub_1002A3AF0(v10, (uint64_t)a2);
    if (qword_1009F8798 != -1) {
      dispatch_once(&qword_1009F8798, &stru_1009A1F10);
    }
    sub_1003F0308(qword_1009F8790, v7 + 128);
    sub_1002A923C((uint64_t)a2);
    operator delete();
  }
  if (v4 == v5)
  {
    if (qword_1009F7F00 != -1) {
      dispatch_once(&qword_1009F7F00, &stru_1009A1E70);
    }
    sub_100052718((uint64_t)off_1009F7EF8 + 240, (uint64_t)(v3 + 34));
    uint64_t result = (void *)v3[61];
    v3[61] = 0;
    if (result)
    {
      uint64_t v11 = *(uint64_t (**)(void))(*result + 64);
      return (void *)v11();
    }
  }
  return result;
}

void sub_10029495C(uint64_t a1)
{
  if (sub_10028B72C(*(void *)(a1 + 32), *(void *)(a1 + 40)))
  {
    v7[0] = 0;
    v7[1] = 0;
    uint64_t v8 = 0;
    sub_1006ACEAC();
    id v1 = objc_claimAutoreleasedReturnValue();
    sub_10004191C(v7, (char *)[v1 UTF8String]);

    char v2 = qword_100A19E38;
    if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v3 = v7;
      if (v8 < 0) {
        uint64_t v3 = (void **)v7[0];
      }
      *(_DWORD *)long long buf = 136315138;
      uint64_t v10 = v3;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Notifying Phone/Watch of unexpected disconnection from device addr %s", buf, 0xCu);
    }
    uint64_t v4 = sub_100373068();
    if (SHIBYTE(v8) < 0)
    {
      sub_10003B098(__p, v7[0], (unint64_t)v7[1]);
    }
    else
    {
      *(_OWORD *)std::string __p = *(_OWORD *)v7;
      uint64_t v6 = v8;
    }
    (*(void (**)(uint64_t, void **))(*(void *)v4 + 136))(v4, __p);
    if (SHIBYTE(v6) < 0) {
      operator delete(__p[0]);
    }
    if (SHIBYTE(v8) < 0) {
      operator delete(v7[0]);
    }
  }
}

void sub_100294AD0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if (a20 < 0) {
    operator delete(a15);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100294B1C(uint64_t result, uint64_t a2, int a3, __int16 a4)
{
  if (a3 == 30 && (a4 & 0x8000) == 0)
  {
    uint64_t v5 = result;
    v7[0] = 0;
    v7[1] = 0;
    sub_10003AED0((uint64_t)v7, result + 360);
    uint64_t v6 = sub_100294BC0(v5, a2);
    if (v6)
    {
      sub_100294C04(v6);
    }
    else if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_ERROR))
    {
      sub_10074ECC0();
    }
    return sub_10003AFB4((uint64_t)v7);
  }
  return result;
}

void sub_100294BAC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t *sub_100294BC0(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    char v2 = *(uint64_t ***)(a1 + 336);
    uint64_t v3 = *(uint64_t ***)(a1 + 344);
    while (v2 != v3)
    {
      uint64_t result = *v2;
      uint64_t v5 = **v2;
      int v6 = *(_DWORD *)(v5 + 128);
      int v7 = *(unsigned __int16 *)(v5 + 132);
      if (v6 == *(_DWORD *)a2 && v7 == *(unsigned __int16 *)(a2 + 4)) {
        return result;
      }
      ++v2;
    }
  }
  return 0;
}

uint64_t sub_100294C04(void *a1)
{
  v21[0] = 0;
  v21[1] = 0;
  sub_10003AED0((uint64_t)v21, (uint64_t)(a1 + 55));
  uint64_t v2 = a1[54];
  if (v2)
  {
    uint64_t v3 = (uint64_t *)a1[53];
    uint64_t v4 = (const void **)v3[2];
    uint64_t v5 = *v3;
    *(void *)(v5 + 8) = v3[1];
    *(void *)v3[1] = v5;
    a1[54] = v2 - 1;
    operator delete(v3);
    unint64_t v6 = *(unsigned __int8 *)v4;
    if (v6 <= 0x1F)
    {
      uint64_t v7 = a1[v6 + 20];
      if (v7)
      {
        if (*(unsigned char *)(v7 + 97))
        {
          char v18 = 0;
          sub_10001B8E0(&v18);
          int v8 = sub_1000D8E98((unsigned __int8 *)(*a1 + 128), *(unsigned __int8 *)v4, *((unsigned __int16 *)v4 + 1), v4[1]);
          sub_10001B910(&v18);
          if (v8)
          {
            uint64_t v9 = qword_100A19E38;
            if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)long long buf = 67109120;
              int v23 = v8;
              _os_log_error_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "sendEASessionPacket: error %d", buf, 8u);
            }
            if (v4[1]) {
              operator delete[]();
            }
            operator delete();
          }
          if (*((unsigned __int16 *)v4 + 1) >= 3u)
          {
            uint64_t v13 = qword_100A19E38;
            if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
            {
              uint64_t v14 = (unsigned __int8 *)v4[1];
              int v15 = *v14;
              int v16 = v14[1];
              LODWORD(v14) = v14[2];
              uint64_t v17 = a1[54];
              *(_DWORD *)long long buf = 67109888;
              int v23 = v15;
              __int16 v24 = 1024;
              int v25 = v16;
              __int16 v26 = 1024;
              int v27 = (int)v14;
              __int16 v28 = 2048;
              uint64_t v29 = v17;
              _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "sendEASessionPacket: Packet start %02X %02X %02X; %lu remaining",
                buf,
                0x1Eu);
            }
          }
          if (v4[1]) {
            operator delete[]();
          }
          operator delete();
        }
      }
    }
    uint64_t v10 = qword_100A19E38;
    if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_ERROR)) {
      sub_10074ECF4(&v19, v20, v10);
    }
    if (v4[1]) {
      operator delete[]();
    }
    operator delete();
  }
  uint64_t v11 = qword_100A19E38;
  if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_INFO))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_INFO, "sendEASessionPacket: No more packets to send", buf, 2u);
  }
  return sub_10003AFB4((uint64_t)v21);
}

void sub_100294F18(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  sub_10003AFB4((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_100294F44(uint64_t a1, _DWORD *a2, unsigned char *a3)
{
  int v4 = sub_1002898E0(a1, a2);
  uint64_t v5 = qword_100A19E38;
  BOOL v6 = os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT);
  if (v4)
  {
    if (v6)
    {
      int v7 = *a3;
      v8[0] = 67109120;
      v8[1] = v7;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "GAPA device remove all %d AACP capabilities", (uint8_t *)v8, 8u);
    }
    *a3 = 0;
  }
  else if (v6)
  {
    LOWORD(v8[0]) = 0;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "GAPA device remove limited AACP capabilities", (uint8_t *)v8, 2u);
  }
}

uint64_t sub_100295034(uint64_t a1, uint64_t a2, unsigned __int8 a3, uint64_t a4)
{
  unsigned __int8 v49 = a3;
  v48[0] = 0;
  v48[1] = 0;
  sub_10003AED0((uint64_t)v48, a1 + 360);
  if (qword_1009F7F00 != -1) {
    dispatch_once(&qword_1009F7F00, &stru_1009A1E70);
  }
  *(_DWORD *)__int16 v50 = *(_DWORD *)a2;
  *(_WORD *)&v50[4] = *(_WORD *)(a2 + 4);
  int v7 = (_DWORD *)sub_1004AA194((uint64_t)off_1009F7EF8, (uint64_t)v50, 1);
  int v8 = sub_100294BC0(a1, a2);
  if (v7 && v8)
  {
    uint64_t v45 = (uint64_t)v8;
    uint64_t v9 = sub_10047ECFC((uint64_t)v7);
    if ((v9 & 2) != 0) {
      sub_100294F44(v9, v7, &v49);
    }
    uint64_t v10 = qword_100A19E38;
    BOOL v11 = os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT);
    if (v11)
    {
      sub_100474E18((uint64_t)v7, v50);
      if (v55 >= 0) {
        int v12 = v50;
      }
      else {
        int v12 = *(uint8_t **)v50;
      }
      unsigned int v13 = v49;
      *(_DWORD *)long long buf = 136446466;
      uint64_t v57 = v12;
      __int16 v58 = 1024;
      int v59 = v49;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "capabilitiesResponseEvent: device %{public}s response: numCaps = %d", buf, 0x12u);
      if (v55 < 0) {
        operator delete(*(void **)v50);
      }
      if (v13) {
        goto LABEL_14;
      }
    }
    else
    {
      unsigned int v13 = v49;
      if (v49)
      {
LABEL_14:
        unint64_t v14 = 0;
        unint64_t v15 = v13;
        int v16 = (int *)(a4 + 1);
        char v17 = 0;
        while (1)
        {
          unsigned int v18 = *((unsigned __int8 *)v16 - 1);
          if (v18 <= 0x3F)
          {
            switch(*((unsigned char *)v16 - 1))
            {
              case 1:
              case 2:
                int v19 = *(unsigned __int8 *)v16;
                break;
              case 4:
                int v19 = *v16;
                break;
              case 5:
              case 6:
              case 7:
              case 0x30:
                int v19 = *v16;
                goto LABEL_38;
              case 8:
                int v19 = *v16;
                if (*v16) {
                  *(unsigned char *)(v45 + 152) = 1;
                }
                goto LABEL_18;
              case 9:
              case 0xC:
              case 0xF:
              case 0x11:
              case 0x12:
              case 0x14:
                goto LABEL_17;
              case 0xA:
                int v19 = *(unsigned __int8 *)v16;
                if (v19)
                {
                  if (qword_1009F8418 != -1) {
                    dispatch_once(&qword_1009F8418, &stru_1009A1E10);
                  }
                  sub_100414FAC((void *)qword_1009F8410, (uint64_t)v7, 1);
                }
                goto LABEL_18;
              case 0xB:
                int v19 = *(unsigned __int8 *)v16;
                if (v19)
                {
                  uint64_t v22 = sub_1004AFA9C();
                  v47[0] = _NSConcreteStackBlock;
                  v47[1] = 3221225472;
                  v47[2] = sub_100295B28;
                  v47[3] = &unk_100997528;
                  v47[4] = v7;
                  sub_100013018(v22, v47);
                }
                goto LABEL_18;
              case 0xD:
                int v19 = *(unsigned __int8 *)v16;
                if (v19)
                {
                  uint64_t v23 = sub_1004AFA9C();
                  v46[0] = _NSConcreteStackBlock;
                  v46[1] = 3221225472;
                  v46[2] = sub_100295B90;
                  v46[3] = &unk_100997528;
                  v46[4] = v7;
                  sub_100013018(v23, v46);
                }
                goto LABEL_18;
              case 0x10:
                int v19 = *(unsigned __int8 *)v16;
                if (*(unsigned char *)v16)
                {
                  __int16 v24 = qword_100A19E38;
                  if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
                  {
                    sub_100474E18((uint64_t)v7, v50);
                    int v25 = v55 >= 0 ? v50 : *(uint8_t **)v50;
                    *(_DWORD *)long long buf = 136446210;
                    uint64_t v57 = v25;
                    _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "capabilitiesResponseEvent: Requested case information from device %{public}s", buf, 0xCu);
                    if (v55 < 0) {
                      operator delete(*(void **)v50);
                    }
                  }
                  sub_10028CFCC(a1, (uint64_t)v7);
                }
                char v17 = 1;
                goto LABEL_18;
              case 0x13:
                int v19 = *(unsigned __int8 *)v16;
                int v26 = _os_feature_enabled_impl();
                if (v19 == 1) {
                  int v27 = v26;
                }
                else {
                  int v27 = 0;
                }
                if (v27 == 1)
                {
                  if (sub_100487EFC((uint64_t)v7, 0x13u))
                  {
                    int v19 = 1;
                  }
                  else
                  {
                    uint64_t v37 = sub_100487BDC((uint64_t)v7);
                    int v19 = 1;
                    sub_1002859A4(a1, (uint64_t)v7, 52, v37, 1u);
                  }
                }
                goto LABEL_38;
              case 0x15:
              case 0x16:
              case 0x17:
              case 0x18:
                goto LABEL_37;
              case 0x20:
                int v19 = *(unsigned __int8 *)v16;
                if (v19)
                {
                  if (qword_1009F8418 != -1) {
                    dispatch_once(&qword_1009F8418, &stru_1009A1E10);
                  }
                  sub_100415050((void *)qword_1009F8410, (uint64_t)v7, 1);
                }
                goto LABEL_18;
              default:
                goto LABEL_103;
            }
            goto LABEL_39;
          }
          if (*((unsigned __int8 *)v16 - 1) <= 0x9Fu)
          {
            if (*((unsigned __int8 *)v16 - 1) <= 0x5Fu)
            {
              if (v18 == 64)
              {
LABEL_17:
                int v19 = *(unsigned __int8 *)v16;
              }
              else
              {
                if (v18 != 80) {
                  goto LABEL_103;
                }
                int v19 = *(unsigned __int8 *)v16;
                if (v19 == 2)
                {
                  if (qword_1009F8418 != -1) {
                    dispatch_once(&qword_1009F8418, &stru_1009A1E10);
                  }
                  sub_1004152B8((void *)qword_1009F8410, (uint64_t)v7, 1);
                  int v19 = 2;
                }
              }
            }
            else
            {
              switch(v18)
              {
                case 0x60u:
                  goto LABEL_37;
                case 0x80u:
                  int v19 = *(unsigned __int8 *)v16;
                  if (v19)
                  {
                    uint64_t v30 = qword_100A19E38;
                    if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
                    {
                      sub_100474E18((uint64_t)v7, v50);
                      __int16 v31 = v50;
                      if (v55 < 0) {
                        __int16 v31 = *(uint8_t **)v50;
                      }
                      *(_DWORD *)long long buf = 136446210;
                      uint64_t v57 = v31;
                      _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_DEFAULT, "capabilitiesResponseEvent: Setting double click & click and hold intervals for device %{public}s", buf, 0xCu);
                      if (v55 < 0) {
                        operator delete(*(void **)v50);
                      }
                    }
                    if ((sub_100478B2C((uint64_t)v7, 29) & 1) == 0 && (sub_100478B2C((uint64_t)v7, 43) & 1) == 0)
                    {
                      uint64_t v32 = sub_10048775C((uint64_t)v7);
                      sub_1002859A4(a1, (uint64_t)v7, 23, v32, 1u);
                    }
                    if ((sub_100478B2C((uint64_t)v7, 30) & 1) == 0 && (sub_100478B2C((uint64_t)v7, 43) & 1) == 0)
                    {
                      uint64_t v33 = sub_1004877A4((uint64_t)v7);
                      sub_1002859A4(a1, (uint64_t)v7, 24, v33, 1u);
                    }
                  }
                  break;
                case 0x90u:
                  int v19 = *(unsigned __int8 *)v16;
                  if (v19)
                  {
                    if (qword_1009F8418 != -1) {
                      dispatch_once(&qword_1009F8418, &stru_1009A1E10);
                    }
                    sub_1004151DC((void *)qword_1009F8410, (uint64_t)v7, 1);
                  }
                  break;
                default:
                  goto LABEL_103;
              }
            }
          }
          else
          {
            if (*((unsigned __int8 *)v16 - 1) > 0xCFu)
            {
              if (v18 == 208)
              {
                int v19 = *(unsigned __int8 *)v16;
                sub_10048705C((uint64_t)v7, 208, *(unsigned char *)v16 != 0);
              }
              else
              {
                if (v18 != 224 && v18 != 240)
                {
LABEL_103:
                  int v34 = qword_100A19E38;
                  if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
                  {
                    sub_100474E18((uint64_t)v7, v50);
                    int v35 = v50;
                    if (v55 < 0) {
                      int v35 = *(uint8_t **)v50;
                    }
                    int v36 = *((unsigned __int8 *)v16 - 1);
                    *(_DWORD *)long long buf = 136446466;
                    uint64_t v57 = v35;
                    __int16 v58 = 1024;
                    int v59 = v36;
                    _os_log_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_DEFAULT, "Warning: capabilitiesResponseEvent: device %{public}s unexpected response capId = %d", buf, 0x12u);
                    if (v55 < 0) {
                      operator delete(*(void **)v50);
                    }
                  }
                  int v19 = 0;
                  goto LABEL_39;
                }
LABEL_37:
                int v19 = *(unsigned __int8 *)v16;
              }
LABEL_38:
              sub_1004872D0((uint64_t)v7, *((unsigned __int8 *)v16 - 1), v19);
              goto LABEL_39;
            }
            if (v18 != 160)
            {
              if (v18 == 176)
              {
                int v19 = *(unsigned __int8 *)v16;
                if (v19 == 1)
                {
                  *(_DWORD *)long long buf = 4;
                  if (qword_1009F8418 != -1) {
                    dispatch_once(&qword_1009F8418, &stru_1009A1E10);
                  }
                  sub_100415108((void *)qword_1009F8410, (uint64_t)v7, (int *)buf);
                  __int16 v28 = qword_100A19E38;
                  if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
                  {
                    *(_DWORD *)__int16 v50 = 67109120;
                    *(_DWORD *)&v50[4] = *(_DWORD *)buf;
                    _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, "capabilitiesResponseEvent: supportedListening modes: %u", v50, 8u);
                  }
                  int v29 = *((unsigned __int8 *)v16 - 1);
                }
                else
                {
                  int v29 = 176;
                }
                sub_10048705C((uint64_t)v7, v29, v19 != 0);
              }
              else
              {
                if (v18 != 192) {
                  goto LABEL_103;
                }
                int v19 = *(unsigned __int8 *)v16;
                sub_10048705C((uint64_t)v7, 192, *(unsigned char *)v16 != 0);
              }
              goto LABEL_38;
            }
            int v19 = *(unsigned __int8 *)v16;
            if (v19 == 1)
            {
              if (qword_1009F8418 != -1) {
                dispatch_once(&qword_1009F8418, &stru_1009A1E10);
              }
              int v19 = 1;
              sub_10041509C((void *)qword_1009F8410, (uint64_t)v7, 1);
            }
          }
LABEL_18:
          sub_10048705C((uint64_t)v7, *((unsigned __int8 *)v16 - 1), v19 != 0);
LABEL_39:
          __int16 v20 = qword_100A19E38;
          BOOL v11 = os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT);
          if (v11)
          {
            int v21 = *((unsigned __int8 *)v16 - 1);
            *(_DWORD *)__int16 v50 = 67109632;
            *(_DWORD *)&v50[4] = v14;
            __int16 v51 = 1024;
            int v52 = v21;
            __int16 v53 = 1024;
            int v54 = v19;
            _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "capabilitiesResponseEvent: index %d, capId %d, capInfo %d", v50, 0x14u);
          }
          ++v14;
          int v16 = (int *)((char *)v16 + 5);
          if (v14 >= v15) {
            goto LABEL_114;
          }
        }
      }
    }
    char v17 = 0;
LABEL_114:
    sub_100295BF8(v11, (uint64_t)v7);
    if ((v17 & 1) == 0)
    {
      if (sub_100487464((uint64_t)v7)) {
        uint64_t v38 = 0xFFFFLL;
      }
      else {
        uint64_t v38 = 65533;
      }
      sub_10028CD4C(a1, (uint64_t)v7, 0xFFFFLL, v38);
    }
    unsigned int v39 = *(unsigned __int8 *)(v45 + 604);
    int v40 = v39 & 1;
    int v41 = (v39 >> 1) & 1;
    BOOL v42 = qword_100A19E38;
    if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
    {
      if (v40) {
        int v43 = v41;
      }
      else {
        int v43 = 0;
      }
      *(_DWORD *)__int16 v50 = 67109376;
      *(_DWORD *)&v50[4] = v43;
      __int16 v51 = 1024;
      int v52 = v40;
      _os_log_impl((void *)&_mh_execute_header, v42, OS_LOG_TYPE_DEFAULT, "GAPA capabilitiesResponseEvent newlyPaired=%d invokeNow=%d", v50, 0xEu);
    }
    if (v40)
    {
      *(unsigned char *)(v45 + 604) = 0;
      sub_100295E84(a1, v45, 1, v41);
    }
  }
  return sub_10003AFB4((uint64_t)v48);
}

void sub_100295A2C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,char a32)
{
}

uint64_t sub_100295B28(uint64_t a1)
{
  if (qword_1009FB058 != -1) {
    dispatch_once(&qword_1009FB058, &stru_1009A1F90);
  }
  uint64_t v2 = off_1009FB050;
  uint64_t v3 = *(void *)(a1 + 32);

  return sub_100514B9C((uint64_t)v2, v3, 1);
}

uint64_t sub_100295B90(uint64_t a1)
{
  if (qword_1009FB058 != -1) {
    dispatch_once(&qword_1009FB058, &stru_1009A1F90);
  }
  uint64_t v2 = off_1009FB050;
  uint64_t v3 = *(void *)(a1 + 32);

  return sub_100514C28((uint64_t)v2, v3, 1);
}

uint64_t sub_100295BF8(uint64_t a1, uint64_t a2)
{
  sub_100486FCC(a2);
  if (qword_1009F7EF0 != -1) {
    dispatch_once(&qword_1009F7EF0, &stru_1009A1E30);
  }
  sub_1004567B0((uint64_t)off_1009F7EE8, a2);
  uint64_t result = sub_100487DD4(a2, 64);
  if (result)
  {
    int v4 = qword_100A19E38;
    if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(__p[0]) = 0;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Setting up spatial audio", (uint8_t *)__p, 2u);
    }
    if (qword_1009F8418 != -1) {
      dispatch_once(&qword_1009F8418, &stru_1009A1E10);
    }
    sub_100415324((void *)qword_1009F8410, a2, 1);
    char v11 = 0;
    if (qword_1009F7F00 != -1) {
      dispatch_once(&qword_1009F7F00, &stru_1009A1E70);
    }
    uint64_t result = sub_1004AB1F0((uint64_t)off_1009F7EF8);
    if (result)
    {
      uint64_t v5 = sub_1003708B0();
      uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, char *))(*(void *)v5 + 1208))(v5, a2, &v11);
      if (result)
      {
        BOOL v6 = qword_100A19E38;
        if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
        {
          sub_100474E18(a2, __p);
          if (v10 >= 0) {
            int v7 = __p;
          }
          else {
            int v7 = (void **)__p[0];
          }
          *(_DWORD *)long long buf = 136446210;
          unsigned int v13 = v7;
          _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "Initialize spatial audio to true for %{public}s", buf, 0xCu);
          if (v10 < 0) {
            operator delete(__p[0]);
          }
        }
        CFPreferencesSetAppValue(@"spatial-audio-accessory-feature", kCFBooleanTrue, @"com.apple.springboard");
        CFPreferencesAppSynchronize(@"com.apple.springboard");
        uint64_t v8 = *(void *)sub_1003708B0();
        return (*(uint64_t (**)(void))(v8 + 1216))();
      }
    }
  }
  return result;
}

void sub_100295E84(uint64_t a1, uint64_t a2, int a3, int a4)
{
  if (!a2)
  {
    if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_ERROR)) {
      sub_10074ED34();
    }
    return;
  }
  unsigned int v5 = *(_DWORD *)(a2 + 80) - 8194;
  BOOL v6 = v5 > 0xE;
  int v7 = (1 << v5) & 0x409B;
  if (!v6 && v7 != 0) {
    return;
  }
  uint64_t v82 = *(void *)a2;
  if (!*(void *)a2) {
    return;
  }
  if (!*(void *)(a2 + 128))
  {
    sub_1004A82EC((unsigned __int8 *)(v82 + 128), keys);
    if (SHIBYTE(keys[2]) >= 0) {
      unint64_t v15 = keys;
    }
    else {
      unint64_t v15 = (void **)keys[0];
    }
    CFStringRef v16 = CFStringCreateWithCString(kCFAllocatorDefault, (const char *)v15, 0x8000100u);
    if (SHIBYTE(keys[2]) < 0) {
      operator delete(keys[0]);
    }
    if (!v16)
    {
      __int16 v67 = qword_100A19E38;
      if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_ERROR)) {
        sub_10074ED68(v82, v67);
      }
      return;
    }
    uint64_t Connection = acc_transportClient_createConnection();
    if (!Connection)
    {
      uint64_t v68 = qword_100A19E38;
      if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_ERROR)) {
        sub_10074EE08(v82, v68);
      }
      CFRelease(v16);
      return;
    }
    *(void *)(a2 + 128) = Connection;
    CFRelease(v16);
  }
  if (*(unsigned char *)(a2 + 152))
  {
    uint64_t v10 = 0;
    while (1)
    {
      uint64_t v11 = *(void *)(a2 + 160 + v10);
      if (v11)
      {
        if (*(void *)(v11 + 24)) {
          break;
        }
      }
      v10 += 8;
      if (v10 == 256)
      {
        if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_ERROR)) {
          sub_10074F058();
        }
        break;
      }
    }
    uint64_t v98 = _NSConcreteStackBlock;
    uint64_t v99 = 3221225472;
    uint64_t v100 = sub_1002A2534;
    uint64_t v101 = &unk_1009A1320;
    uint64_t v102 = a1;
    uint64_t v103 = v82;
    uint64_t Endpoint = acc_transportClient_createEndpoint();
    unsigned int v13 = qword_100A19E38;
    if (Endpoint)
    {
      if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
      {
        sub_100474E18(v82, keys);
        unint64_t v14 = SHIBYTE(keys[2]) >= 0 ? keys : (void **)keys[0];
        *(_DWORD *)long long buf = 136446466;
        *(void *)&uint8_t buf[4] = v14;
        *(_WORD *)&unsigned char buf[12] = 2112;
        *(void *)&unsigned char buf[14] = Endpoint;
        _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "publishAccRemoteFirmware: device %{public}s endpoint = %@", buf, 0x16u);
        if (SHIBYTE(keys[2]) < 0) {
          operator delete(keys[0]);
        }
      }
      *(void *)(a2 + 136) = Endpoint;
      *(unsigned char *)(a2 + 152) = 0;
    }
    else if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_ERROR))
    {
      sub_10074EFB8(v82, v13);
    }
  }
  uint64_t v18 = 0;
  int v80 = (void *)kCFACCInfo_Name;
  BOOL v79 = (void *)kCFACCInfo_Manufacturer;
  uint64_t v77 = (void *)kCFACCInfo_SerialNumber;
  int v78 = (void *)kCFACCInfo_Model;
  uint64_t v76 = kCFACCInfo_HardwareVersion;
  uint64_t v19 = kCFACCInfo_FirmwareVersionActive;
  uint64_t v20 = kCFACCInfo_FirmwareVersionPending;
  while (1)
  {
    int v21 = *(void **)(a2 + 8 * v18 + 160);
    if (v21)
    {
      if (!v21[11]) {
        break;
      }
    }
LABEL_49:
    if (++v18 == 32)
    {
      if (!a3) {
        return;
      }
      uint64_t v34 = *(void *)(a2 + 192);
      if (v34)
      {
        if (*(void *)(v34 + 88))
        {
          uint64_t v35 = sub_100035F54();
          if (((*(uint64_t (**)(uint64_t))(*(void *)v35 + 328))(v35) & 1) != 0
            || (uint64_t v36 = sub_100035F54(), ((*(uint64_t (**)(uint64_t))(*(void *)v36 + 384))(v36) & 1) != 0)
            || (uint64_t v37 = sub_100035F54(), (*(unsigned int (**)(uint64_t))(*(void *)v37 + 424))(v37)))
          {
            *(_DWORD *)long long buf = 0;
            uint64_t v38 = (void *)acc_transportClient_createEndpoint();
            unsigned int v39 = objc_opt_new();
            id v40 = *(id *)(v34 + 64);
            id v41 = *(id *)(v34 + 72);
            id v83 = *(id *)(v34 + 24);
            if ((unint64_t)[v40 length] >= 2)
            {
              BOOL v42 = qword_100A19E38;
              if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
              {
                LODWORD(keys[0]) = 141558275;
                *(void **)((char *)keys + 4) = (void *)1752392040;
                WORD2(keys[1]) = 2113;
                *(void **)((char *)&keys[1] + 6) = v40;
                _os_log_impl((void *)&_mh_execute_header, v42, OS_LOG_TYPE_DEFAULT, "publishAccRemoteFirmware: Left bud serial %{private, mask.hash}@", (uint8_t *)keys, 0x16u);
              }
              int v43 = +[NSNumber numberWithInt:2];
              uint32_t v44 = +[NSDictionary dictionaryWithObjectsAndKeys:](NSDictionary, "dictionaryWithObjectsAndKeys:", v43, kCFACCProperties_Endpoint_AACP_CertificateInfo_Type, v40, kCFACCProperties_Endpoint_AACP_CertificateInfo_Serial, 0);
              [v39 addObject:v44];
            }
            if ((unint64_t)[v41 length] >= 2)
            {
              uint64_t v45 = qword_100A19E38;
              if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
              {
                LODWORD(keys[0]) = 141558275;
                *(void **)((char *)keys + 4) = (void *)1752392040;
                WORD2(keys[1]) = 2113;
                *(void **)((char *)&keys[1] + 6) = v41;
                _os_log_impl((void *)&_mh_execute_header, v45, OS_LOG_TYPE_DEFAULT, "publishAccRemoteFirmware: Right bud serial %{private, mask.hash}@", (uint8_t *)keys, 0x16u);
              }
              int v46 = +[NSNumber numberWithInt:3];
              char v47 = +[NSDictionary dictionaryWithObjectsAndKeys:](NSDictionary, "dictionaryWithObjectsAndKeys:", v46, kCFACCProperties_Endpoint_AACP_CertificateInfo_Type, v41, kCFACCProperties_Endpoint_AACP_CertificateInfo_Serial, 0);
              [v39 addObject:v47];
            }
            if (![v39 count] && (unint64_t)objc_msgSend(v83, "length") >= 2)
            {
              char v48 = qword_100A19E38;
              if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
              {
                LODWORD(keys[0]) = 141558275;
                *(void **)((char *)keys + 4) = (void *)1752392040;
                WORD2(keys[1]) = 2113;
                *(void **)((char *)&keys[1] + 6) = v83;
                _os_log_impl((void *)&_mh_execute_header, v48, OS_LOG_TYPE_DEFAULT, "publishAccRemoteFirmware: Single tethered serial %{private, mask.hash}@", (uint8_t *)keys, 0x16u);
              }
              unsigned __int8 v49 = +[NSNumber numberWithInt:1];
              __int16 v50 = +[NSDictionary dictionaryWithObjectsAndKeys:](NSDictionary, "dictionaryWithObjectsAndKeys:", v49, kCFACCProperties_Endpoint_AACP_CertificateInfo_Type, v83, kCFACCProperties_Endpoint_AACP_CertificateInfo_Serial, 0);
              [v39 addObject:v50];

              *(_DWORD *)long long buf = 1;
            }
            __int16 v51 = qword_100A19E38;
            if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
            {
              LODWORD(keys[0]) = 141558275;
              *(void **)((char *)keys + 4) = (void *)1752392040;
              WORD2(keys[1]) = 2113;
              *(void **)((char *)&keys[1] + 6) = v39;
              _os_log_impl((void *)&_mh_execute_header, v51, OS_LOG_TYPE_DEFAULT, "publishAccRemoteFirmware: Dictionary %{private, mask.hash}@", (uint8_t *)keys, 0x16u);
            }
            if (v38)
            {
              id v52 = [v39 count];
              __int16 v53 = qword_100A19E38;
              if (v52)
              {
                if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
                {
                  int v54 = *(void **)(a2 + 128);
                  LODWORD(keys[0]) = 138543618;
                  *(void **)((char *)keys + 4) = v38;
                  WORD2(keys[1]) = 2114;
                  *(void **)((char *)&keys[1] + 6) = v54;
                  _os_log_impl((void *)&_mh_execute_header, v53, OS_LOG_TYPE_DEFAULT, "publishAccRemoteFirmware: Creating certificate endpoint %{public}@ for %{public}@", (uint8_t *)keys, 0x16u);
                }
                *(void *)(a2 + 144) = v38;
                *(_DWORD *)int valuePtr = 0;
                *(_DWORD *)int valuePtr = sub_100487DD4(v82, 9);
                uint64_t v55 = sub_100017768();
                if ((*(unsigned int (**)(uint64_t))(*(void *)v55 + 752))(v55)) {
                  *(_DWORD *)int valuePtr = 0;
                }
                float v56 = qword_100A19E38;
                if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
                {
                  LODWORD(keys[0]) = 67109120;
                  HIDWORD(keys[0]) = *(_DWORD *)valuePtr;
                  _os_log_impl((void *)&_mh_execute_header, v56, OS_LOG_TYPE_DEFAULT, "publishAccRemoteFirmware: isCertificateSupported %d", (uint8_t *)keys, 8u);
                }
                CFNumberRef v57 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, valuePtr);
                acc_transportClient_setPropertyForEndpointWithUUID();
                *(_DWORD *)std::string __p = a4;
                CFNumberRef v58 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, __p);
                acc_transportClient_setPropertyForEndpointWithUUID();
                acc_transportClient_setPropertyForEndpointWithUUID();
                if (sub_10028AD28(a1, (_DWORD *)v82, a2, *(_DWORD *)valuePtr != 0))
                {
                  *(_DWORD *)(a2 + 600) = 1;
                  uint64_t v59 = sub_100050530();
                  int v86 = *(_DWORD *)(v82 + 128);
                  __int16 v87 = *(_WORD *)(v82 + 132);
                  (*(void (**)(uint64_t, int *, uint64_t, void))(*(void *)v59 + 368))(v59, &v86, 1, 0);
                  int v85 = 3;
                  if (qword_1009F80A0 != -1) {
                    dispatch_once(&qword_1009F80A0, &stru_1009A1E90);
                  }
                  id v81 = v40;
                  sub_100290170((uint64_t)off_1009F8098, v82, &v85);
                  int v60 = *(_DWORD *)buf;
                  if (!*(_DWORD *)buf)
                  {
                    if (v85 == 1) {
                      int v60 = 2;
                    }
                    else {
                      int v60 = 3;
                    }
                    *(_DWORD *)long long buf = v60;
                  }
                  char v61 = qword_100A19E38;
                  if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
                  {
                    LODWORD(keys[0]) = 67109120;
                    HIDWORD(keys[0]) = v60;
                    _os_log_impl((void *)&_mh_execute_header, v61, OS_LOG_TYPE_DEFAULT, "publishAccRemoteFirmware GAPA_AUTH_SUPPORTED for this connection certificateInfoType=%d", (uint8_t *)keys, 8u);
                  }
                  Mutable = CFArrayCreateMutable(0, 0, 0);
                  id v40 = v81;
                  CFNumberRef v63 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, buf);
                  CFArrayAppendValue(Mutable, v63);
                  acc_transportClient_setPropertyForEndpointWithUUID();
                  CFRelease(v63);
                  CFArrayRemoveAllValues(Mutable);
                  CFRelease(Mutable);
                }
                acc_transportClient_setEndpointPropertyDidChangeHandler();
                acc_transportClient_setEndpointPropertyDidChangeHandler();
                acc_transportClient_setEndpointPropertyDidChangeHandler();
                CFRelease(v57);
                CFRelease(v58);
              }
              else if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_ERROR))
              {
                sub_100474E18(v82, keys);
                sub_10074EF64();
              }
              CFRelease(v38);
            }
            else if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_ERROR))
            {
              sub_100474E18(v82, keys);
              sub_10074EF10();
            }
          }
          acc_transportClient_setPropertyForConnectionWithUUID();
          int v69 = acc_transportClient_publishConnection();
          int v70 = qword_100A19E38;
          if (v69)
          {
            if (!os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT)) {
              return;
            }
            sub_100474E18(v82, buf);
            if ((buf[23] & 0x80u) == 0) {
              __int16 v71 = buf;
            }
            else {
              __int16 v71 = *(uint8_t **)buf;
            }
            uint64_t v72 = *(void *)(a2 + 128);
            *(_DWORD *)int valuePtr = 136446466;
            *(void *)&valuePtr[4] = v71;
            __int16 v109 = 2112;
            *(void *)uint64_t v110 = v72;
            _os_log_impl((void *)&_mh_execute_header, v70, OS_LOG_TYPE_DEFAULT, "publishAccRemoteFirmware: Published connection for device %{public}s, connection %@", valuePtr, 0x16u);
LABEL_118:
            if (((char)buf[23] & 0x80000000) == 0) {
              return;
            }
            long long v66 = *(void **)buf;
LABEL_120:
            operator delete(v66);
            return;
          }
          if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_ERROR))
          {
            sub_100474E18(v82, buf);
            if ((buf[23] & 0x80u) == 0) {
              char v73 = buf;
            }
            else {
              char v73 = *(uint8_t **)buf;
            }
            uint64_t v74 = *(void *)(a2 + 128);
            *(_DWORD *)int valuePtr = 136446466;
            *(void *)&valuePtr[4] = v73;
            __int16 v109 = 2112;
            *(void *)uint64_t v110 = v74;
            _os_log_error_impl((void *)&_mh_execute_header, v70, OS_LOG_TYPE_ERROR, "publishAccRemoteFirmware: Failed to publish connection for device %{public}s, connection %@", valuePtr, 0x16u);
            goto LABEL_118;
          }
        }
        else if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_ERROR))
        {
          sub_10074EEDC();
        }
      }
      else if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_ERROR))
      {
        sub_10074EEA8();
      }
      return;
    }
  }
  uint64_t v118 = 0;
  long long v117 = 0u;
  memset(keys, 0, sizeof(keys));
  uint64_t v115 = 0;
  long long v114 = 0u;
  memset(buf, 0, sizeof(buf));
  int v93 = _NSConcreteStackBlock;
  uint64_t v94 = 3221225472;
  int v95 = sub_1002A2754;
  __int16 v96 = &unk_1009A1340;
  uint64_t v97 = a1;
  uint64_t v22 = acc_transportClient_createEndpoint();
  if (v22)
  {
    uint64_t v88 = _NSConcreteStackBlock;
    uint64_t v89 = 3221225472;
    int v90 = sub_1002A2CB0;
    uint64_t v91 = &unk_1009A1360;
    uint64_t v92 = a1;
    acc_transportClient_setEndpointPropertyDidChangeHandler();
    v21[11] = v22;
    keys[0] = v80;
    keys[1] = v79;
    keys[2] = v78;
    keys[3] = v77;
    *(void *)&long long v117 = v76;
    *((void *)&v117 + 1) = v19;
    uint64_t v118 = v20;
    uint64_t v23 = v21[2];
    uint64_t v24 = v21[3];
    *(void *)long long buf = *v21;
    *(void *)&uint8_t buf[8] = v23;
    *(void *)&uint8_t buf[16] = v21[1];
    *(void *)&uint8_t buf[24] = v24;
    *((void *)&v114 + 1) = v21[10];
    CFStringRef v25 = (const __CFString *)v21[5];
    *(void *)&long long v114 = v21[6];
    CFIndex Length = CFStringGetLength(v25);
    uint64_t v27 = 5;
    if (!Length) {
      uint64_t v27 = 4;
    }
    uint64_t v115 = v21[v27];
    CFDictionaryRef v28 = CFDictionaryCreate(kCFAllocatorDefault, (const void **)keys, (const void **)buf, 7, &kCFCopyStringDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    acc_transportClient_setAccessoryInfo();
    CFNumberRef v29 = CFNumberCreate(kCFAllocatorDefault, kCFNumberCharType, v21 + 12);
    acc_transportClient_setPropertyForEndpointWithUUID();
    uint64_t v30 = qword_100A19E38;
    if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
    {
      sub_100474E18(v82, __p);
      __int16 v31 = __p;
      if (v107 < 0) {
        __int16 v31 = *(unsigned char **)__p;
      }
      uint64_t v32 = *(void *)(a2 + 128);
      uint64_t v33 = v21[11];
      *(_DWORD *)int valuePtr = 136446978;
      *(void *)&valuePtr[4] = v31;
      __int16 v109 = 1024;
      *(_DWORD *)uint64_t v110 = v18;
      *(_WORD *)&v110[4] = 2112;
      *(void *)&v110[6] = v32;
      __int16 v111 = 2112;
      uint64_t v112 = v33;
      _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_DEFAULT, "publishAccRemoteFirmware: Created EA endpoint for device %{public}s (index %d), connection %@, endpoint %@", valuePtr, 0x26u);
      if (v107 < 0) {
        operator delete(*(void **)__p);
      }
    }
    CFRelease(v28);
    CFRelease(v29);
    goto LABEL_49;
  }
  int v64 = qword_100A19E38;
  if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_ERROR))
  {
    sub_100474E18(v82, valuePtr);
    char v65 = v110[9] >= 0 ? valuePtr : *(unsigned char **)valuePtr;
    *(_DWORD *)std::string __p = 136446466;
    *(void *)&__p[4] = v65;
    __int16 v105 = 1024;
    int v106 = v18;
    _os_log_error_impl((void *)&_mh_execute_header, v64, OS_LOG_TYPE_ERROR, "publishAccRemoteFirmware: Failed to create CoreAccessories EA endpoint for device %{public}s (index %d)", __p, 0x12u);
    if ((v110[9] & 0x80000000) != 0)
    {
      long long v66 = *(void **)valuePtr;
      goto LABEL_120;
    }
  }
}

void sub_100296FD8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,void *a26)
{
  _Unwind_Resume(a1);
}

void sub_10029708C(uint64_t a1, uint64_t a2, int a3, char *a4)
{
  LODWORD(v5) = a3;
  if (qword_1009F7F00 != -1) {
    dispatch_once(&qword_1009F7F00, &stru_1009A1E70);
  }
  LODWORD(__p[0]) = *(_DWORD *)a2;
  WORD2(__p[0]) = *(_WORD *)(a2 + 4);
  uint64_t v8 = sub_1004AA194((uint64_t)off_1009F7EF8, (uint64_t)__p, 1);
  if (v8)
  {
    v18[0] = 0;
    v18[1] = 0;
    sub_10003AED0((uint64_t)v18, a1 + 360);
    uint64_t v9 = *(uint64_t ***)(a1 + 336);
    uint64_t v10 = *(uint64_t ***)(a1 + 344);
    while (v9 != v10)
    {
      uint64_t v11 = *v9;
      if (**v9 == v8)
      {
        unsigned int v13 = qword_100A19E38;
        if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
        {
          sub_100475EE0(v8, (uint64_t)__p);
          unint64_t v14 = v17 >= 0 ? __p : (void **)__p[0];
          *(_DWORD *)long long buf = 136315394;
          uint64_t v20 = v14;
          __int16 v21 = 1024;
          int v22 = v5;
          _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "received battery info from device \"%s\" num reports = %d", buf, 0x12u);
          if (v17 < 0) {
            operator delete(__p[0]);
          }
        }
        if (v5)
        {
          uint64_t v5 = v5;
          do
          {
            unsigned int v15 = a4[3] - 5;
            if (v15 >= 0xFFFFFFFE) {
              sub_1002972D0((uint64_t)v11, *a4);
            }
            sub_1002974B4(v11, a4, v15 < 0xFFFFFFFE);
            a4 += 5;
            --v5;
          }
          while (v5);
        }
        goto LABEL_23;
      }
      ++v9;
    }
    if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_ERROR)) {
      sub_10074F124();
    }
LABEL_23:
    sub_10003AFB4((uint64_t)v18);
  }
  else
  {
    int v12 = qword_100A19E38;
    if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_ERROR)) {
      sub_10074F08C(v12);
    }
  }
}

void sub_1002972AC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  sub_10003AFB4((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_1002972D0(uint64_t a1, unsigned int a2)
{
  int v4 = qword_100A19E38;
  if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
  {
    sub_1002A947C(a2, __p);
    uint64_t v5 = v18 >= 0 ? __p : (void **)__p[0];
    *(_DWORD *)long long buf = 136446210;
    uint64_t v20 = v5;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "destroy battery info \"%{public}s\"", buf, 0xCu);
    if (v18 < 0) {
      operator delete(__p[0]);
    }
  }
  uint64_t v8 = *(void *)(a1 + 32);
  uint64_t v7 = a1 + 32;
  uint64_t v6 = v8;
  if (v8)
  {
    uint64_t v9 = (uint64_t **)(v7 - 8);
    uint64_t v10 = v7;
    do
    {
      unsigned int v11 = *(unsigned __int8 *)(v6 + 32);
      BOOL v12 = v11 >= a2;
      if (v11 >= a2) {
        unsigned int v13 = (uint64_t *)v6;
      }
      else {
        unsigned int v13 = (uint64_t *)(v6 + 8);
      }
      if (v12) {
        uint64_t v10 = v6;
      }
      uint64_t v6 = *v13;
    }
    while (*v13);
    if (v10 != v7 && *(unsigned __int8 *)(v10 + 32) <= a2)
    {
      uint64_t v14 = *(void *)(v10 + 40);
      if (v14)
      {
        unsigned int v15 = qword_100A19E38;
        if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
        {
          sub_1002A947C(a2, __p);
          if (v18 >= 0) {
            CFStringRef v16 = __p;
          }
          else {
            CFStringRef v16 = (void **)__p[0];
          }
          *(_DWORD *)long long buf = 136315138;
          uint64_t v20 = v16;
          _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "battery instance for \"%s\" found. Destroying...", buf, 0xCu);
          if (v18 < 0) {
            operator delete(__p[0]);
          }
        }
        (*(void (**)(uint64_t))(*(void *)v14 + 8))(v14);
      }
      sub_10004D3B8(v9, (uint64_t *)v10);
      operator delete((void *)v10);
    }
  }
}

BOOL sub_1002974B4(uint64_t *a1, char *a2, int a3)
{
  uint64_t v6 = a1[4];
  uint64_t v7 = (uint64_t **)(a1 + 3);
  if (!v6) {
    goto LABEL_12;
  }
  unsigned int v8 = *a2;
  uint64_t v9 = a1 + 4;
  do
  {
    unsigned int v10 = *(unsigned __int8 *)(v6 + 32);
    BOOL v11 = v10 >= v8;
    if (v10 >= v8) {
      BOOL v12 = (uint64_t *)v6;
    }
    else {
      BOOL v12 = (uint64_t *)(v6 + 8);
    }
    if (v11) {
      uint64_t v9 = (uint64_t *)v6;
    }
    uint64_t v6 = *v12;
  }
  while (*v12);
  if (v9 == a1 + 4 || v8 < *((unsigned __int8 *)v9 + 32))
  {
LABEL_12:
    unsigned int v13 = qword_100A19E38;
    if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
    {
      sub_1002A947C(*a2, __p);
      if (v49 >= 0) {
        uint64_t v14 = __p;
      }
      else {
        uint64_t v14 = (void **)__p[0];
      }
      int v15 = a2[2];
      if (a2[3] == 1) {
        CFStringRef v16 = "Yes";
      }
      else {
        CFStringRef v16 = "No";
      }
      if (a2[3]) {
        char v17 = "No";
      }
      else {
        char v17 = "Yes";
      }
      *(_DWORD *)long long buf = 136446978;
      *(void *)&uint8_t buf[4] = v14;
      *(_WORD *)&unsigned char buf[12] = 1024;
      *(_DWORD *)&unsigned char buf[14] = v15;
      *(_WORD *)&buf[18] = 2082;
      *(void *)&buf[20] = v16;
      __int16 v51 = 2082;
      id v52 = v17;
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "Create Battery for \"%{public}s\" battery, battery level %d, charging = \"%{public}s\" fully charged = \"%{public}s\"", buf, 0x26u);
      if (v49 < 0) {
        operator delete(__p[0]);
      }
    }
    sub_10037336C();
  }
  char v18 = qword_100A19E38;
  if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
  {
    sub_1002A947C(v8, __p);
    if (v49 >= 0) {
      uint64_t v19 = __p;
    }
    else {
      uint64_t v19 = (void **)__p[0];
    }
    int v20 = a2[2];
    __int16 v21 = "No";
    if (a2[3] == 1) {
      int v22 = "Yes";
    }
    else {
      int v22 = "No";
    }
    if (!a2[3]) {
      __int16 v21 = "Yes";
    }
    *(_DWORD *)long long buf = 136446978;
    *(void *)&uint8_t buf[4] = v19;
    *(_WORD *)&unsigned char buf[12] = 1024;
    *(_DWORD *)&unsigned char buf[14] = v20;
    *(_WORD *)&buf[18] = 2080;
    *(void *)&buf[20] = v22;
    __int16 v51 = 2082;
    id v52 = v21;
    _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "Update Battery for \"%{public}s\" battery, battery level %d, charging = \"%s\" fully charged = \"%{public}s\"", buf, 0x26u);
    if (v49 < 0) {
      operator delete(__p[0]);
    }
  }
  uint64_t v23 = v9[5];
  if (!v23)
  {
    int v25 = 0;
    goto LABEL_76;
  }
  (*(void (**)(uint64_t, void))(*(void *)v23 + 48))(v9[5], a2[2]);
  if (a2[3]) {
    uint64_t v24 = a2[3] == 1;
  }
  else {
    uint64_t v24 = 2;
  }
  (*(void (**)(uint64_t, uint64_t))(*(void *)v23 + 64))(v23, v24);
  sub_1002A94B0(a1, *a2, buf);
  if ((buf[23] & 0x80000000) != 0)
  {
    uint64_t v26 = *(void *)&buf[8];
    operator delete(*(void **)buf);
    if (!v26) {
      goto LABEL_47;
    }
LABEL_45:
    *(void *)long long buf = a2;
    uint64_t v27 = sub_1002B5A68(v7, (unsigned __int8 *)a2, (uint64_t)&unk_1007BE9D0, (unsigned char **)buf)[5];
    sub_1002A94B0(a1, *a2, buf);
    (*(void (**)(uint64_t *, unsigned char *))(*v27 + 72))(v27, buf);
    if ((buf[23] & 0x80000000) != 0) {
      operator delete(*(void **)buf);
    }
    goto LABEL_47;
  }
  if (buf[23]) {
    goto LABEL_45;
  }
LABEL_47:
  int v25 = 0;
  unint64_t v28 = a2[3];
  if (v28 >= 3) {
    unsigned __int8 v29 = 0;
  }
  else {
    unsigned __int8 v29 = 0x20103u >> (8 * v28);
  }
  int v30 = *a2;
  switch(*a2)
  {
    case 1:
      int v31 = sub_10047E688((unsigned int *)*a1, 1);
      unsigned int v32 = a2[2];
      if (v31 == v32) {
        goto LABEL_61;
      }
      sub_10047EA78(*a1, v32, 1);
      goto LABEL_63;
    case 2:
      int v35 = sub_10047E688((unsigned int *)*a1, 2);
      unsigned int v36 = a2[2];
      if (v35 == v36) {
        goto LABEL_61;
      }
      sub_10047EA78(*a1, v36, 2);
      goto LABEL_63;
    case 3:
    case 5:
    case 6:
    case 7:
      goto LABEL_66;
    case 4:
      int v37 = sub_10047E688((unsigned int *)*a1, 4);
      unsigned int v38 = a2[2];
      if (v37 == v38) {
        goto LABEL_61;
      }
      sub_10047EA78(*a1, v38, 4);
      goto LABEL_63;
    case 8:
      int v39 = sub_10047E688((unsigned int *)*a1, 8);
      unsigned int v40 = a2[2];
      if (v39 == v40) {
        goto LABEL_61;
      }
      sub_10047EA78(*a1, v40, 8);
      goto LABEL_63;
    default:
      if (v30 != 16) {
        goto LABEL_66;
      }
      int v33 = sub_10047E688((unsigned int *)*a1, 16);
      unsigned int v34 = a2[2];
      if (v33 == v34)
      {
LABEL_61:
        int v25 = 0;
      }
      else
      {
        sub_10047EA78(*a1, v34, 16);
LABEL_63:
        int v25 = 1;
      }
      if (sub_10047EBCC(*a1, v29, v30)) {
        int v25 = 1;
      }
LABEL_66:
      LODWORD(__p[0]) = 0;
      uint64_t v47 = 0;
      int v46 = 0;
      sub_10047B7A8(*a1, __p, (_DWORD *)&v47 + 1, &v47, &v46);
      id v41 = +[CBProductInfo productInfoWithProductID:v47];
      if (([v41 flags] & 0x100000) == 0 || HIDWORD(v47) != 76)
      {

LABEL_73:
        if (a3)
        {
          sub_1002A9598((uint64_t)a1, *a2, buf);
          (*(void (**)(uint64_t, unsigned char *))(*(void *)v23 + 24))(v23, buf);
          if ((buf[23] & 0x80000000) != 0) {
            operator delete(*(void **)buf);
          }
        }
        goto LABEL_76;
      }
      BOOL v42 = *a2 == 8;

      if (v42) {
        int v25 = 0;
      }
      if (!v42) {
        goto LABEL_73;
      }
LABEL_76:
      memset(buf, 0, 24);
      int v43 = a2[3];
      sub_1004B8C24((uint64_t)buf, 3, 0);
      *(_DWORD *)&uint8_t buf[16] = v43;
      uint64_t v44 = sub_100050530();
      (*(void (**)(uint64_t, unsigned char *))(*(void *)v44 + 56))(v44, buf);
      return v25 != 0;
  }
}

void sub_100297E30(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a20 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100297E9C(uint64_t a1, uint64_t a2, unsigned __int8 *a3)
{
  if (qword_1009F7F00 != -1) {
    dispatch_once(&qword_1009F7F00, &stru_1009A1E70);
  }
  *(_DWORD *)long long buf = *(_DWORD *)a2;
  *(_WORD *)&uint8_t buf[4] = *(_WORD *)(a2 + 4);
  uint64_t v6 = sub_1004AA194((uint64_t)off_1009F7EF8, (uint64_t)buf, 1);
  if (v6)
  {
    v28[0] = 0;
    v28[1] = 0;
    sub_10003AED0((uint64_t)v28, a1 + 360);
    for (uint64_t i = *(unsigned __int8 ***)(a1 + 336); i != *(unsigned __int8 ***)(a1 + 344); ++i)
    {
      unsigned int v8 = *i;
      if (*(void *)*i == v6)
      {
        uint64_t v10 = sub_100487464(v6);
        if (v10)
        {
          uint64_t v11 = sub_100290124(v10, *a3);
          int v12 = v11;
          int v13 = sub_100290124(v11, a3[1]);
          int v14 = v8[10];
          if (v14 == 1) {
            int v15 = 2;
          }
          else {
            int v15 = 1;
          }
          CFStringRef v16 = qword_100A19E38;
          if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
          {
            sub_100474E18(v6, __p);
            char v18 = v30 >= 0 ? __p : *(unsigned char **)__p;
            uint64_t v19 = sub_100290148(v17, v12);
            int v20 = sub_100290148((uint64_t)v19, v13);
            *(_DWORD *)long long buf = 136446722;
            *(void *)&uint8_t buf[4] = v18;
            *(_WORD *)&unsigned char buf[12] = 2082;
            *(void *)&unsigned char buf[14] = v19;
            *(_WORD *)&unsigned char buf[22] = 2082;
            unsigned int v32 = v20;
            _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "received in-ear state update from device %{public}s primary bud state = %{public}s, secondary bud state = %{public}s", buf, 0x20u);
            if (v30 < 0) {
              operator delete(*(void **)__p);
            }
          }
          int v21 = v8[8];
          BOOL v22 = v12 != v21;
          if (v12 != v21)
          {
            v8[8] = v12;
            memset(buf, 0, sizeof(buf));
            sub_1004B8C24((uint64_t)buf, 2, v6);
            *(_DWORD *)&uint8_t buf[16] = v14;
            *(_DWORD *)&buf[20] = v12;
            uint64_t v23 = sub_100050530();
            (*(void (**)(uint64_t, uint8_t *))(*(void *)v23 + 56))(v23, buf);
          }
          if (v13 != v8[9])
          {
            v8[9] = v13;
            memset(buf, 0, sizeof(buf));
            sub_1004B8C24((uint64_t)buf, 2, v6);
            *(_DWORD *)&uint8_t buf[16] = v15;
            *(_DWORD *)&buf[20] = v13;
            uint64_t v24 = sub_100050530();
            (*(void (**)(uint64_t, uint8_t *))(*(void *)v24 + 56))(v24, buf);
            BOOL v22 = 1;
          }
          sub_10003AFE8((uint64_t)v28);
          if (v22) {
            sub_10028F48C(v25, v6);
          }
        }
        else
        {
          uint64_t v26 = qword_100A19E38;
          if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
          {
            sub_100474E18(v6, buf);
            uint64_t v27 = (buf[23] & 0x80u) == 0 ? buf : *(uint8_t **)buf;
            *(_DWORD *)std::string __p = 136446210;
            *(void *)&__p[4] = v27;
            _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "Ignoring in-ear status update from device %{public}s that's disabled for tracking in-ear detection", __p, 0xCu);
            if ((char)buf[23] < 0) {
              operator delete(*(void **)buf);
            }
          }
        }
        goto LABEL_10;
      }
    }
    if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_ERROR)) {
      sub_10074F1F0();
    }
LABEL_10:
    sub_10003AFB4((uint64_t)v28);
  }
  else
  {
    uint64_t v9 = qword_100A19E38;
    if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_ERROR)) {
      sub_10074F158(v9);
    }
  }
}

void sub_100298224(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_100298250(uint64_t a1, uint64_t a2, unsigned __int8 *a3)
{
  if (qword_1009F7F00 != -1) {
    dispatch_once(&qword_1009F7F00, &stru_1009A1E70);
  }
  *(_DWORD *)long long buf = *(_DWORD *)a2;
  *(_WORD *)&uint8_t buf[4] = *(_WORD *)(a2 + 4);
  uint64_t v6 = sub_1004AA194((uint64_t)off_1009F7EF8, (uint64_t)buf, 1);
  if (v6)
  {
    v58[0] = 0;
    v58[1] = 0;
    sub_10003AED0((uint64_t)v58, a1 + 360);
    uint64_t v7 = *(unsigned char ***)(a1 + 336);
    unsigned int v8 = *(unsigned char ***)(a1 + 344);
    if (v7 == v8)
    {
LABEL_7:
      if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_ERROR)) {
        sub_10074F2BC();
      }
    }
    else
    {
      while (1)
      {
        uint64_t v9 = *v7;
        if (*(void *)*v7 == v6) {
          break;
        }
        if (++v7 == v8) {
          goto LABEL_7;
        }
      }
      int v11 = *a3;
      if (v11 == 2) {
        int v12 = 2;
      }
      else {
        int v12 = 3;
      }
      if (v11 == 1) {
        int v13 = 1;
      }
      else {
        int v13 = v12;
      }
      int v14 = qword_100A19E38;
      if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
      {
        sub_100474E18(v6, __p);
        if (v60 >= 0) {
          int v15 = __p;
        }
        else {
          int v15 = *(unsigned char **)__p;
        }
        CFStringRef v16 = "unknown";
        if (v13 == 2) {
          CFStringRef v16 = "right";
        }
        if (v13 == 1) {
          uint64_t v17 = "left";
        }
        else {
          uint64_t v17 = v16;
        }
        char v18 = "Yes";
        int v19 = *(unsigned __int8 *)(a1 + 430);
        int v20 = a3[3];
        BOOL v21 = a3[2] == 0;
        *(_DWORD *)long long buf = 136447234;
        *(void *)&uint8_t buf[4] = v15;
        BOOL v22 = "not";
        if (v21) {
          char v18 = "No";
        }
        if (v19) {
          BOOL v22 = "is";
        }
        *(_WORD *)&unsigned char buf[12] = 2082;
        *(void *)__int16 v62 = v17;
        uint64_t v23 = "disabled";
        *(_WORD *)&v62[8] = 2082;
        CFNumberRef v63 = v18;
        __int16 v64 = 2082;
        char v65 = v22;
        if (v20) {
          uint64_t v23 = "enabled";
        }
        __int16 v66 = 2082;
        __int16 v67 = v23;
        _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "received role state from device %{public}s, primary bud side is \"%{public}s\", secondary connected = %{public}s, magnet %{public}s connected, quickdisconnect %{public}s", buf, 0x34u);
        if (v60 < 0) {
          operator delete(*(void **)__p);
        }
      }
      int v24 = v9[10];
      BOOL v25 = v13 != v24;
      if (v13 != v24) {
        v9[10] = v13;
      }
      if (!a3[2] && sub_100487464(v6) && v9[9] != 3)
      {
        v9[9] = 3;
        BOOL v25 = 1;
      }
      sub_10003AFE8((uint64_t)v58);
      if (v25)
      {
        sub_10028F48C(v26, v6);
        if (sub_10028B72C(a1, v6))
        {
          uint64_t v27 = qword_100A19E38;
          if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
          {
            sub_1004A82EC((unsigned __int8 *)(v6 + 128), buf);
            unint64_t v28 = v62[9] >= 0 ? buf : *(unsigned char **)buf;
            *(_DWORD *)std::string __p = 67109378;
            *(_DWORD *)&__p[4] = v13;
            *(_WORD *)&__p[8] = 2082;
            *(void *)&__p[10] = v28;
            _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "Sending current primary bud side as %d to other end of magnet link for device %{public}s", __p, 0x12u);
            if ((v62[9] & 0x80000000) != 0) {
              operator delete(*(void **)buf);
            }
          }
          uint64_t v29 = sub_100373068();
          char v30 = (unsigned __int8 *)(v6 + 128);
          sub_1004A82EC((unsigned __int8 *)(v6 + 128), v56);
          (*(void (**)(uint64_t, void **, void))(*(void *)v29 + 144))(v29, v56, v13);
          if (v57 < 0) {
            operator delete(v56[0]);
          }
          int v31 = qword_100A19E38;
          if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
          {
            int v32 = v9[11];
            int v33 = v9[9];
            *(_DWORD *)long long buf = 67109632;
            *(_DWORD *)&uint8_t buf[4] = v32;
            *(_WORD *)&uint8_t buf[8] = 1024;
            *(_DWORD *)&buf[10] = v13;
            *(_WORD *)__int16 v62 = 1024;
            *(_DWORD *)&v62[2] = v33;
            _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_DEFAULT, "Primary bud info over magnet link before -> %d, primary bud info from Headset -> %d, current connection secondary bud in ear status -> %d", buf, 0x14u);
          }
          uint64_t v34 = sub_100035F54();
          if (!(*(unsigned int (**)(uint64_t))(*(void *)v34 + 344))(v34)
            || (int v35 = v9[11], v35 == 3)
            || v13 == v35
            || v9[9] != 3)
          {
            if (sub_10028BC74((uint64_t)v9))
            {
              id v41 = qword_100A19E38;
              if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
              {
                if (v9[617]) {
                  char v49 = v9 + 611;
                }
                else {
                  char v49 = v9 + 605;
                }
                *(_DWORD *)std::string __p = *(_DWORD *)v49;
                *(_WORD *)&__p[4] = *((_WORD *)v49 + 2);
                uint64_t v50 = sub_10025B48C((uint64_t)__p, v42, v43, v44, v45, v46, v47, v48);
                *(_DWORD *)long long buf = 136446210;
                *(void *)&uint8_t buf[4] = v50;
                _os_log_impl((void *)&_mh_execute_header, v41, OS_LOG_TYPE_DEFAULT, "Peer source \"%{public}s\" is currently connected in TiPi, skip connection stealing", buf, 0xCu);
              }
            }
            else if (a3[3] && sub_100298A1C((uint64_t)v9))
            {
              __int16 v51 = qword_100A19E38;
              if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
              {
                sub_100474E18(v6, buf);
                id v52 = v62[9] >= 0 ? buf : *(unsigned char **)buf;
                *(_DWORD *)std::string __p = 136446210;
                *(void *)&__p[4] = v52;
                _os_log_impl((void *)&_mh_execute_header, v51, OS_LOG_TYPE_DEFAULT, "Sending message to Phone/Watch to connect to device %{public}s", __p, 0xCu);
                if ((v62[9] & 0x80000000) != 0) {
                  operator delete(*(void **)buf);
                }
              }
              uint64_t v53 = sub_100373068();
              sub_1004A82EC(v30, v54);
              (*(void (**)(uint64_t, void **, BOOL))(*(void *)v53 + 128))(v53, v54, a3[3] != 0);
              if (v55 < 0) {
                operator delete(v54[0]);
              }
            }
          }
          else
          {
            unsigned int v36 = qword_100A19E38;
            if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
            {
              sub_100474E18(v6, __p);
              int v37 = v60 >= 0 ? __p : *(unsigned char **)__p;
              int v38 = v9[11];
              *(_DWORD *)long long buf = 136446722;
              *(void *)&uint8_t buf[4] = v37;
              *(_WORD *)&unsigned char buf[12] = 1024;
              *(_DWORD *)__int16 v62 = v38;
              *(_WORD *)&v62[4] = 1024;
              *(_DWORD *)&v62[6] = v13;
              _os_log_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_DEFAULT, "Info update from Headset, Primary bud side  for device %{public}s seen locally is different from that of companion, we see  %d, and companion sees %d. Requesting connected Bud to be secondary", buf, 0x18u);
              if (v60 < 0) {
                operator delete(*(void **)__p);
              }
            }
            sub_1002859A4(a1, v6, 8, 2, 1u);
            int v39 = qword_100A19E38;
            if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
            {
              sub_100474E18(v6, buf);
              unsigned int v40 = v62[9] >= 0 ? buf : *(unsigned char **)buf;
              *(_DWORD *)std::string __p = 136446210;
              *(void *)&__p[4] = v40;
              _os_log_impl((void *)&_mh_execute_header, v39, OS_LOG_TYPE_DEFAULT, "Schedule reconnection to W1 device after LSTO (5 seconds) on Gizmo, device : %{public}s", __p, 0xCu);
              if ((v62[9] & 0x80000000) != 0) {
                operator delete(*(void **)buf);
              }
            }
            *(_DWORD *)long long buf = *(_DWORD *)v30;
            *(_WORD *)&uint8_t buf[4] = *(_WORD *)(v6 + 132);
            if (qword_1009F8090 != -1) {
              dispatch_once(&qword_1009F8090, &stru_1009A1ED0);
            }
            sub_1004D6030((uint64_t)off_1009F8088, buf);
          }
        }
      }
    }
    sub_10003AFB4((uint64_t)v58);
  }
  else
  {
    uint64_t v10 = qword_100A19E38;
    if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_ERROR)) {
      sub_10074F224(v10);
    }
  }
}

void sub_1002989B8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,char a21)
{
}

BOOL sub_100298A1C(uint64_t a1)
{
  uint64_t v2 = sub_100035F54();
  if (((*(uint64_t (**)(uint64_t))(*(void *)v2 + 344))(v2) & 1) != 0 || *(unsigned char *)(a1 + 728)) {
    return 1;
  }
  if (qword_1009F80A0 != -1) {
    dispatch_once(&qword_1009F80A0, &stru_1009A1E90);
  }
  return !*((unsigned char *)off_1009F8098 + 520) && !sub_10028BC74(a1) && sub_1004874AC(*(void *)a1) != 1;
}

uint64_t sub_100298ADC(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  if (qword_1009F7F00 != -1) {
    dispatch_once(&qword_1009F7F00, &stru_1009A1E70);
  }
  *(_DWORD *)long long buf = *(_DWORD *)a2;
  LOWORD(v30) = *(_WORD *)(a2 + 4);
  uint64_t result = sub_1004AA194((uint64_t)off_1009F7EF8, (uint64_t)buf, 1);
  uint64_t v9 = result;
  if (result)
  {
    v28[0] = 0;
    v28[1] = 0;
    sub_10003AED0((uint64_t)v28, a1 + 360);
    for (uint64_t i = *(void **)(a1 + 336); i != *(void **)(a1 + 344); ++i)
    {
      int v11 = (void *)*i;
      if (*(void *)*i == v9) {
        goto LABEL_9;
      }
    }
    int v11 = 0;
LABEL_9:
    int v12 = qword_100A19E38;
    if (!os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_16;
    }
    int v13 = a4 == 1 ? "Pair success" : "Pair failed";
    sub_100475EE0(v9, (uint64_t)__p);
    int v14 = v27;
    int v15 = (void **)__p[0];
    uint64_t v23 = sub_10025B48C(a3, v16, v17, v18, v19, v20, v21, v22);
    int v24 = __p;
    *(_DWORD *)long long buf = 136446722;
    if (v14 < 0) {
      int v24 = v15;
    }
    char v30 = v13;
    __int16 v31 = 2080;
    int v32 = v24;
    __int16 v33 = 2080;
    uint64_t v34 = v23;
    _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "received easy pair response \"%{public}s\" from device \"%s\", for address \"%s\" ", buf, 0x20u);
    if (v27 < 0)
    {
      operator delete(__p[0]);
      if (v11)
      {
LABEL_17:
        uint64_t v25 = v11[6];
        if (v25)
        {
          *(_DWORD *)long long buf = *(_DWORD *)a2;
          LOWORD(v30) = *(_WORD *)(a2 + 4);
          LODWORD(__p[0]) = *(_DWORD *)a3;
          WORD2(__p[0]) = *(_WORD *)(a3 + 4);
          sub_1002793F0(v25, (uint64_t)buf, (uint64_t)__p, a4 != 1);
        }
      }
    }
    else
    {
LABEL_16:
      if (v11) {
        goto LABEL_17;
      }
    }
    return sub_10003AFB4((uint64_t)v28);
  }
  return result;
}

void sub_100298CE4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, char a16)
{
}

uint64_t sub_100298D1C(uint64_t a1, uint64_t a2, unint64_t a3, int a4, int a5)
{
  if (qword_1009F7F00 != -1) {
    dispatch_once(&qword_1009F7F00, &stru_1009A1E70);
  }
  uint64_t result = sub_100030F10((uint64_t)off_1009F7EF8, a2, 1);
  if (result)
  {
    uint64_t v11 = result;
    v29[0] = 0;
    v29[1] = 0;
    sub_10003AED0((uint64_t)v29, a1 + 360);
    int v12 = *(void ***)(a1 + 336);
    int v13 = *(void ***)(a1 + 344);
    while (v12 != v13)
    {
      int v14 = *v12;
      if (**v12 == v11)
      {
        unint64_t v15 = sub_10022A5E0(a3);
        int v36 = v15;
        __int16 v37 = WORD2(v15);
        uint64_t v16 = qword_100A19E38;
        if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v24 = sub_10025B48C((uint64_t)&v36, v17, v18, v19, v20, v21, v22, v23);
          uint64_t v25 = "Connected";
          if (!a4) {
            uint64_t v25 = "Disconnected";
          }
          *(_DWORD *)long long buf = 136446722;
          uint64_t v31 = v24;
          __int16 v32 = 2082;
          __int16 v33 = v25;
          if (a5 == 1) {
            uint64_t v26 = "Source";
          }
          else {
            uint64_t v26 = "UTP";
          }
          __int16 v34 = 2082;
          int v35 = v26;
          _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "Received connection state info : target addr = \"%{public}s\", connState %{public}s, connType = \"%{public}s\" ", buf, 0x20u);
        }
        if (a5 == 1)
        {
          v28[0] = BYTE5(a3);
          v28[1] = BYTE4(a3);
          void v28[2] = BYTE3(a3);
          v28[3] = BYTE2(a3);
          v28[4] = BYTE1(a3);
          v28[5] = a3;
          sub_10028B8F4((uint64_t)v14, v28, a4);
          BOOL v27 = sub_10028BC74((uint64_t)v14);
          sub_10028BB94(v27, v11, v27);
        }
        return sub_10003AFB4((uint64_t)v29);
      }
      ++v12;
    }
    if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_ERROR))
    {
      sub_100474E18(v11, buf);
      sub_10074F2F0();
    }
    return sub_10003AFB4((uint64_t)v29);
  }
  return result;
}

void sub_100298F54(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  sub_10003AFB4((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_100298F78(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  if (qword_1009F7F00 != -1) {
    dispatch_once(&qword_1009F7F00, &stru_1009A1E70);
  }
  uint64_t v7 = sub_100030F10((uint64_t)off_1009F7EF8, a2, 1);
  __p[0] = 0;
  __p[1] = 0;
  uint64_t v20 = 0;
  sub_10004191C(__p, "");
  if (a4 == 2)
  {
    sub_10004191C(v17, "streaming A2DP");
  }
  else if (a4 == 1)
  {
    sub_10004191C(v17, "streaming SCO");
  }
  else if (a4)
  {
    sub_10004191C(v17, "in unknown state");
  }
  else
  {
    sub_10004191C(v17, "stopped streaming");
  }
  if (SHIBYTE(v20) < 0) {
    operator delete(__p[0]);
  }
  *(_OWORD *)std::string __p = *(_OWORD *)v17;
  uint64_t v20 = v18;
  unsigned int v8 = qword_100A19E38;
  if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
  {
    sub_100475EE0(v7, (uint64_t)v17);
    if (v18 >= 0) {
      uint64_t v9 = v17;
    }
    else {
      uint64_t v9 = (void **)v17[0];
    }
    uint64_t v10 = __p;
    if (v20 < 0) {
      uint64_t v10 = (void **)__p[0];
    }
    *(_DWORD *)long long buf = 136315394;
    uint64_t v22 = v9;
    __int16 v23 = 2080;
    uint64_t v24 = v10;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "Received device %s stream state info: %s", buf, 0x16u);
    if (SHIBYTE(v18) < 0) {
      operator delete(v17[0]);
    }
  }
  v16[0] = 0;
  v16[1] = 0;
  sub_10003AED0((uint64_t)v16, a1 + 360);
  if (v7)
  {
    uint64_t v11 = *(void **)(a1 + 336);
    int v12 = *(void **)(a1 + 344);
    while (v11 != v12)
    {
      int v13 = (void *)*v11;
      if (*(void *)*v11 == v7)
      {
        if (*((_DWORD *)v13 + 4) != a4)
        {
          if (qword_1009F7EF0 != -1) {
            dispatch_once(&qword_1009F7EF0, &stru_1009A1E30);
          }
          sub_1004555D8((uint64_t)off_1009F7EE8, v7, a4);
        }
        char v14 = 0;
        *((_DWORD *)v13 + 4) = a4;
        goto LABEL_28;
      }
      ++v11;
    }
  }
  if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_ERROR))
  {
    sub_100475EE0(v7, (uint64_t)v17);
    sub_10074F398();
  }
  char v14 = 1;
LABEL_28:
  sub_10003AFE8((uint64_t)v16);
  if (v14)
  {
    if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_ERROR))
    {
      sub_100475EE0(v7, (uint64_t)buf);
      sub_10074F344();
    }
  }
  else
  {
    sub_1002992D0(v15, v7, a4);
  }
  sub_10003AFB4((uint64_t)v16);
  if (SHIBYTE(v20) < 0) {
    operator delete(__p[0]);
  }
}

void sub_100299280(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a20 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void sub_1002992D0(uint64_t a1, uint64_t a2, char a3)
{
  uint64_t v5 = qword_100A19E38;
  if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_INFO))
  {
    sub_100475EE0(a2, (uint64_t)__p);
    if (v14 >= 0) {
      uint64_t v6 = __p;
    }
    else {
      uint64_t v6 = (void **)__p[0];
    }
    *(_DWORD *)long long buf = 136315138;
    uint64_t v16 = v6;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_INFO, "Notify stream state change for device \"%s\"", buf, 0xCu);
    if (v14 < 0) {
      operator delete(__p[0]);
    }
  }
  uint64_t v7 = sub_1004AFA9C();
  v11[0] = _NSConcreteStackBlock;
  v11[1] = 3221225472;
  void v11[2] = sub_1002A89E8;
  void v11[3] = &unk_100998A58;
  void v11[4] = a2;
  char v12 = a3;
  sub_100013018(v7, v11);
  uint64_t v8 = sub_1004AFB34();
  v9[0] = _NSConcreteStackBlock;
  v9[1] = 3221225472;
  void v9[2] = sub_1002A8A50;
  void v9[3] = &unk_100998A58;
  void v9[4] = a2;
  char v10 = a3;
  sub_100013018(v8, v9);
}

uint64_t sub_100299458(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  if (qword_1009F7F00 != -1) {
    dispatch_once(&qword_1009F7F00, &stru_1009A1E70);
  }
  *(_DWORD *)long long buf = *(_DWORD *)a2;
  LOWORD(v32) = *(_WORD *)(a2 + 4);
  uint64_t result = sub_1004AA194((uint64_t)off_1009F7EF8, (uint64_t)buf, 1);
  uint64_t v9 = (unsigned __int8 *)result;
  if (result)
  {
    v30[0] = 0;
    v30[1] = 0;
    sub_10003AED0((uint64_t)v30, a1 + 360);
    for (uint64_t i = *(unsigned __int8 ****)(a1 + 336); i != *(unsigned __int8 ****)(a1 + 344); ++i)
    {
      uint64_t v11 = *i;
      if (**i == v9) {
        goto LABEL_9;
      }
    }
    uint64_t v11 = 0;
LABEL_9:
    char v12 = qword_100A19E38;
    if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
    {
      if (a4) {
        int v13 = "paired";
      }
      else {
        int v13 = "not paired";
      }
      sub_100475EE0((uint64_t)v9, (uint64_t)__p);
      int v14 = v29;
      uint64_t v15 = (void **)__p[0];
      uint64_t v23 = sub_10025B48C(a3, v16, v17, v18, v19, v20, v21, v22);
      uint64_t v24 = __p;
      int v25 = *((unsigned __int8 *)v11 + 12);
      if (v14 < 0) {
        uint64_t v24 = v15;
      }
      *(_DWORD *)long long buf = 136446978;
      __int16 v32 = v13;
      __int16 v33 = 2080;
      __int16 v34 = v24;
      __int16 v35 = 2080;
      uint64_t v36 = v23;
      __int16 v37 = 1024;
      int v38 = v25;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "received triangle status response \"%{public}s\" from device \"%s\", for address \"%s\", easy unpairing? - %d", buf, 0x26u);
      if (v29 < 0) {
        operator delete(__p[0]);
      }
    }
    else if (!v11)
    {
      return sub_10003AFB4((uint64_t)v30);
    }
    *((unsigned char *)v11 + 84) = a4;
    if (*((unsigned char *)v11 + 12))
    {
      *((unsigned char *)v11 + 12) = 0;
      if (qword_1009F8768 != -1) {
        dispatch_once(&qword_1009F8768, &stru_1009A1DD0);
      }
      sub_1006112E0((uint64_t)off_1009F8760, v9, 2u);
    }
    else
    {
      uint64_t v26 = (uint64_t)v11[6];
      if (v26)
      {
        *(_DWORD *)long long buf = *(_DWORD *)a2;
        LOWORD(v32) = *(_WORD *)(a2 + 4);
        LODWORD(__p[0]) = *(_DWORD *)a3;
        WORD2(__p[0]) = *(_WORD *)(a3 + 4);
        if (a4) {
          int v27 = 2;
        }
        else {
          int v27 = 1;
        }
        sub_100278EF8(v26, (uint64_t)buf, (unsigned __int8 *)__p, v27);
      }
    }
    return sub_10003AFB4((uint64_t)v30);
  }
  return result;
}

void sub_1002996C8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, char a16)
{
}

uint64_t sub_100299704(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  LODWORD(v5) = a3;
  if (qword_1009F7F00 != -1) {
    dispatch_once(&qword_1009F7F00, &stru_1009A1E70);
  }
  *(_DWORD *)long long buf = *(_DWORD *)a2;
  *(_WORD *)&uint8_t buf[4] = *(_WORD *)(a2 + 4);
  uint64_t v8 = (unsigned __int8 *)sub_1004AA194((uint64_t)off_1009F7EF8, (uint64_t)buf, 1);
  *(_DWORD *)&v72[3] = 0;
  *(_DWORD *)uint64_t v72 = 0;
  uint64_t v83 = 0;
  uint64_t v84 = 0;
  long long v82 = 0uLL;
  uint64_t v80 = 0;
  uint64_t v81 = 0;
  v71[0] = 0;
  v71[1] = 0;
  sub_10003AED0((uint64_t)v71, a1 + 360);
  if (v8)
  {
    for (uint64_t i = *(unsigned __int8 ****)(a1 + 336); ; ++i)
    {
      if (i == *(unsigned __int8 ****)(a1 + 344)) {
        return sub_10003AFB4((uint64_t)v71);
      }
      if (**i == v8) {
        break;
      }
    }
    if (v5 && a4)
    {
      int v10 = v8[960];
      if (qword_1009F8080 != -1) {
        dispatch_once(&qword_1009F8080, &stru_1009A1E50);
      }
      uint64_t v11 = off_1009F8078;
      if (sub_1004962BC())
      {
        BOOL v70 = v11[240] != 0;
        if (v10) {
          goto LABEL_23;
        }
      }
      else
      {
        BOOL v70 = 0;
        if (v10) {
          goto LABEL_23;
        }
      }
      if (v8[988])
      {
        if (qword_1009F8080 != -1) {
          dispatch_once(&qword_1009F8080, &stru_1009A1E50);
        }
        if ((v70 & sub_100497A84((uint64_t)off_1009F8078, (uint64_t)v8) & 1) == 0) {
          goto LABEL_23;
        }
        goto LABEL_22;
      }
      if (v70)
      {
LABEL_22:
        if (v8[989]) {
          goto LABEL_23;
        }
        v72[0] = 0;
        *(_DWORD *)&v72[1] = *(_DWORD *)a2;
        *(_WORD *)&v72[5] = *(_WORD *)(a2 + 4);
        if (qword_1009F85C8 != -1) {
          dispatch_once(&qword_1009F85C8, &stru_1009A1F70);
        }
        sub_1006F4674((uint64_t)off_1009F85C0, ((unint64_t)v72[1] << 40) | ((unint64_t)v72[2] << 32) | ((unint64_t)v72[3] << 24) | ((unint64_t)v72[4] << 16) | ((unint64_t)v72[5] << 8) | v72[6] | ((unint64_t)v72[0] << 48), (uint64_t)&v83);
        if (qword_1009F7ED0 != -1) {
          dispatch_once(&qword_1009F7ED0, &stru_1009A1F30);
        }
        sub_100714570(qword_1009F7EC8, v72, &v82);
        uint64_t v5 = v5;
        for (uint64_t j = (uint64_t *)(a4 + 8); ; j += 2)
        {
          int v39 = qword_100A19ED8;
          if (os_log_type_enabled((os_log_t)qword_100A19ED8, OS_LOG_TYPE_DEFAULT))
          {
            int v40 = *((unsigned __int16 *)j - 4);
            int v41 = *((unsigned __int16 *)j - 3);
            sub_100475EE0((uint64_t)v8, (uint64_t)__p);
            uint64_t v42 = v79 >= 0 ? __p : *(unsigned char **)__p;
            *(_DWORD *)long long buf = 67109634;
            *(_DWORD *)&uint8_t buf[4] = v40;
            *(_WORD *)&uint8_t buf[8] = 1024;
            *(_DWORD *)&buf[10] = v41;
            *(_WORD *)uint64_t v74 = 2080;
            *(void *)&v74[2] = v42;
            _os_log_impl((void *)&_mh_execute_header, v39, OS_LOG_TYPE_DEFAULT, "received Key update with keyType = %x, keyCFIndex Length = %d  from device\"%s\" ", buf, 0x18u);
            if (v79 < 0) {
              operator delete(*(void **)__p);
            }
          }
          int v43 = *((unsigned __int16 *)j - 4);
          if (v43 == 1) {
            break;
          }
LABEL_142:
          if (v43 != 4) {
            goto LABEL_171;
          }
          if (*(void *)*j == v80 && *(void *)(*j + 8) == v81)
          {
            uint64_t v60 = qword_100A19ED8;
            if (!os_log_type_enabled((os_log_t)qword_100A19ED8, OS_LOG_TYPE_ERROR)) {
              goto LABEL_171;
            }
            sub_100475EE0((uint64_t)v8, (uint64_t)buf);
            char v61 = buf;
            if (v74[9] < 0) {
              char v61 = *(unsigned char **)buf;
            }
            *(_DWORD *)std::string __p = 136315138;
            *(void *)&__p[4] = v61;
            __int16 v62 = v60;
            CFNumberRef v63 = " Received invalid Enc key from %s";
            uint32_t v64 = 12;
            goto LABEL_186;
          }
          if (qword_1009F8080 != -1) {
            dispatch_once(&qword_1009F8080, &stru_1009A1E50);
          }
          sub_10049B350((uint64_t)off_1009F8078, (uint64_t)v8, (void *)*j);
          if (v83 == *(void *)*j && v84 == *(void *)(*j + 8)) {
            goto LABEL_171;
          }
          if (qword_1009F85C8 != -1) {
            dispatch_once(&qword_1009F85C8, &stru_1009A1F70);
          }
          sub_1006D4BEC((uint64_t)off_1009F85C0, (uint64_t)v72, *j);
          uint64_t v54 = sub_100370758();
          int v55 = (*(uint64_t (**)(uint64_t, unsigned __int8 *, uint64_t, uint64_t))(*(void *)v54 + 88))(v54, v8, 3, *j);
          float v56 = qword_100A19ED8;
          BOOL v57 = os_log_type_enabled((os_log_t)qword_100A19ED8, OS_LOG_TYPE_ERROR);
          if (v55)
          {
            if (!v57) {
              goto LABEL_171;
            }
            sub_100475EE0((uint64_t)v8, (uint64_t)__p);
            CFNumberRef v58 = v79 >= 0 ? __p : *(unsigned char **)__p;
            *(_DWORD *)long long buf = 141558531;
            *(void *)&uint8_t buf[4] = 1752392040;
            *(_WORD *)&unsigned char buf[12] = 2081;
            *(void *)uint64_t v74 = v58;
            *(_WORD *)&v74[8] = 1024;
            int v75 = v55;
            _os_log_error_impl((void *)&_mh_execute_header, v56, OS_LOG_TYPE_ERROR, "Failed to store encryption key to storage for device %{private, mask.hash}s with error %d", buf, 0x1Cu);
            if ((v79 & 0x80000000) == 0) {
              goto LABEL_171;
            }
            uint64_t v59 = *(void **)__p;
            goto LABEL_188;
          }
          if (v57)
          {
            sub_100475EE0((uint64_t)v8, (uint64_t)buf);
            uint64_t v68 = buf;
            if (v74[9] < 0) {
              uint64_t v68 = *(unsigned char **)buf;
            }
            *(_DWORD *)std::string __p = 141558275;
            *(void *)&__p[4] = 1752392040;
            __int16 v77 = 2081;
            int v78 = v68;
            __int16 v62 = v56;
            CFNumberRef v63 = "Successfully stored encryption key to storage for device %{private, mask.hash}s ";
            uint32_t v64 = 22;
LABEL_186:
            _os_log_error_impl((void *)&_mh_execute_header, v62, OS_LOG_TYPE_ERROR, v63, __p, v64);
            if ((v74[9] & 0x80000000) != 0)
            {
              uint64_t v59 = *(void **)buf;
LABEL_188:
              operator delete(v59);
            }
          }
LABEL_171:
          if (*((_WORD *)j - 4) == 256)
          {
            unsigned int v66 = *(_DWORD *)*j;
            if (qword_1009F8080 != -1) {
              dispatch_once(&qword_1009F8080, &stru_1009A1E50);
            }
            sub_10049B7DC((uint64_t)off_1009F8078, (uint64_t)v8, v66);
          }
          if (!--v5) {
            return sub_10003AFB4((uint64_t)v71);
          }
        }
        if (*(void *)*j == v80 && *(void *)(*j + 8) == v81)
        {
          __int16 v51 = qword_100A19ED8;
          if (!os_log_type_enabled((os_log_t)qword_100A19ED8, OS_LOG_TYPE_ERROR)) {
            goto LABEL_141;
          }
          sub_100475EE0((uint64_t)v8, (uint64_t)buf);
          __int16 v67 = buf;
          if (v74[9] < 0) {
            __int16 v67 = *(unsigned char **)buf;
          }
          *(_DWORD *)std::string __p = 136315138;
          *(void *)&__p[4] = v67;
          _os_log_error_impl((void *)&_mh_execute_header, v51, OS_LOG_TYPE_ERROR, " Received invalid IRK from %s", __p, 0xCu);
        }
        else
        {
          if (qword_1009F8080 != -1) {
            dispatch_once(&qword_1009F8080, &stru_1009A1E50);
          }
          sub_10049AFC8((uint64_t)off_1009F8078, (uint64_t)v8, (_OWORD *)*j);
          if ((void)v82 == *(void *)*j && *((void *)&v82 + 1) == *(void *)(*j + 8)) {
            goto LABEL_141;
          }
          if (qword_1009F7ED0 != -1) {
            dispatch_once(&qword_1009F7ED0, &stru_1009A1F30);
          }
          sub_1007071C4(qword_1009F7EC8, v72, *j);
          uint64_t v46 = sub_100370758();
          int v47 = (*(uint64_t (**)(uint64_t, unsigned __int8 *, uint64_t, uint64_t))(*(void *)v46 + 88))(v46, v8, 2, *j);
          uint64_t v48 = qword_100A19ED8;
          if (v47)
          {
            if (!os_log_type_enabled((os_log_t)qword_100A19ED8, OS_LOG_TYPE_ERROR)) {
              goto LABEL_141;
            }
            sub_100475EE0((uint64_t)v8, (uint64_t)__p);
            char v49 = v79 >= 0 ? __p : *(unsigned char **)__p;
            *(_DWORD *)long long buf = 141558531;
            *(void *)&uint8_t buf[4] = 1752392040;
            *(_WORD *)&unsigned char buf[12] = 2081;
            *(void *)uint64_t v74 = v49;
            *(_WORD *)&v74[8] = 1024;
            int v75 = v47;
            _os_log_error_impl((void *)&_mh_execute_header, v48, OS_LOG_TYPE_ERROR, "Failed to store IRK to storage for device %{private, mask.hash}s with error %d", buf, 0x1Cu);
            if ((v79 & 0x80000000) == 0) {
              goto LABEL_141;
            }
            uint64_t v50 = *(void **)__p;
            goto LABEL_182;
          }
          if (!os_log_type_enabled((os_log_t)qword_100A19ED8, OS_LOG_TYPE_INFO))
          {
LABEL_141:
            int v43 = *((unsigned __int16 *)j - 4);
            goto LABEL_142;
          }
          sub_100475EE0((uint64_t)v8, (uint64_t)buf);
          char v65 = buf;
          if (v74[9] < 0) {
            char v65 = *(unsigned char **)buf;
          }
          *(_DWORD *)std::string __p = 141558275;
          *(void *)&__p[4] = 1752392040;
          __int16 v77 = 2081;
          int v78 = v65;
          _os_log_impl((void *)&_mh_execute_header, v48, OS_LOG_TYPE_INFO, "Successfully stored IRK to storage for device %{private, mask.hash}s ", __p, 0x16u);
        }
        if ((v74[9] & 0x80000000) != 0)
        {
          uint64_t v50 = *(void **)buf;
LABEL_182:
          operator delete(v50);
          goto LABEL_141;
        }
        goto LABEL_141;
      }
LABEL_23:
      v72[0] = 0;
      *(_DWORD *)&v72[1] = *(_DWORD *)a2;
      *(_WORD *)&v72[5] = *(_WORD *)(a2 + 4);
      if (qword_1009F7ED0 != -1) {
        dispatch_once(&qword_1009F7ED0, &stru_1009A1F30);
      }
      char v12 = sub_100714570(qword_1009F7EC8, v72, &v82);
      int v13 = 0;
      uint64_t v14 = v5;
      for (k = (uint64_t *)(a4 + 8); ; k += 2)
      {
        uint64_t v16 = qword_100A19ED8;
        if (os_log_type_enabled((os_log_t)qword_100A19ED8, OS_LOG_TYPE_DEFAULT))
        {
          int v17 = *((unsigned __int16 *)k - 4);
          int v18 = *((unsigned __int16 *)k - 3);
          sub_100475EE0((uint64_t)v8, (uint64_t)__p);
          uint64_t v19 = __p;
          if (v79 < 0) {
            uint64_t v19 = *(unsigned char **)__p;
          }
          *(_DWORD *)long long buf = 67109634;
          *(_DWORD *)&uint8_t buf[4] = v17;
          *(_WORD *)&uint8_t buf[8] = 1024;
          *(_DWORD *)&buf[10] = v18;
          *(_WORD *)uint64_t v74 = 2080;
          *(void *)&v74[2] = v19;
          _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "Device received non-magic Key update with keyType = %x, keyCFIndex Length = %d from device\"%s\" ", buf, 0x18u);
          if (v79 < 0) {
            operator delete(*(void **)__p);
          }
        }
        int v20 = *((unsigned __int16 *)k - 4);
        char v21 = v20 == 1 ? v12 : 1;
        if ((v21 & 1) == 0) {
          break;
        }
LABEL_66:
        if (v20 != 4) {
          goto LABEL_97;
        }
        if (v83 == *(void *)*k && v84 == *(void *)(*k + 8))
        {
          __int16 v32 = qword_100A19ED8;
          if (!os_log_type_enabled((os_log_t)qword_100A19ED8, OS_LOG_TYPE_ERROR)) {
            goto LABEL_97;
          }
          sub_100475EE0((uint64_t)v8, (uint64_t)buf);
          __int16 v33 = buf;
          if (v74[9] < 0) {
            __int16 v33 = *(unsigned char **)buf;
          }
          *(_DWORD *)std::string __p = 136315138;
          *(void *)&__p[4] = v33;
          _os_log_error_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_ERROR, "Receive invalid non-magic Enc Key from %s", __p, 0xCu);
          if ((v74[9] & 0x80000000) == 0) {
            goto LABEL_97;
          }
          __int16 v34 = *(void **)buf;
          goto LABEL_90;
        }
        if (qword_1009F85C8 != -1) {
          dispatch_once(&qword_1009F85C8, &stru_1009A1F70);
        }
        sub_1006D4BEC((uint64_t)off_1009F85C0, (uint64_t)v72, *k);
        if (v10)
        {
          uint64_t v31 = (uint64_t (**)(void))(*(void *)sub_100370758() + 112);
LABEL_83:
          int v13 = (*v31)();
          goto LABEL_84;
        }
        if (!v70 || v8[989]) {
          goto LABEL_82;
        }
        if (v8[988])
        {
          if (qword_1009F8080 != -1) {
            dispatch_once(&qword_1009F8080, &stru_1009A1E50);
          }
          if ((sub_100497A84((uint64_t)off_1009F8078, (uint64_t)v8) & 1) == 0)
          {
LABEL_82:
            uint64_t v31 = (uint64_t (**)(void))(*(void *)sub_100370758() + 88);
            goto LABEL_83;
          }
        }
LABEL_84:
        __int16 v35 = qword_100A19ED8;
        if (!v13)
        {
          if (os_log_type_enabled((os_log_t)qword_100A19ED8, OS_LOG_TYPE_INFO))
          {
            sub_100475EE0((uint64_t)v8, (uint64_t)buf);
            __int16 v37 = buf;
            if (v74[9] < 0) {
              __int16 v37 = *(unsigned char **)buf;
            }
            *(_DWORD *)std::string __p = 141558275;
            *(void *)&__p[4] = 1752392040;
            __int16 v77 = 2081;
            int v78 = v37;
            _os_log_impl((void *)&_mh_execute_header, v35, OS_LOG_TYPE_INFO, "Successfully stored non-magic Enc Key to storage for device %{private, mask.hash}s ", __p, 0x16u);
            if ((v74[9] & 0x80000000) != 0) {
              operator delete(*(void **)buf);
            }
          }
          int v13 = 0;
          goto LABEL_97;
        }
        if (os_log_type_enabled((os_log_t)qword_100A19ED8, OS_LOG_TYPE_ERROR))
        {
          sub_100475EE0((uint64_t)v8, (uint64_t)__p);
          uint64_t v36 = __p;
          if (v79 < 0) {
            uint64_t v36 = *(unsigned char **)__p;
          }
          *(_DWORD *)long long buf = 141558531;
          *(void *)&uint8_t buf[4] = 1752392040;
          *(_WORD *)&unsigned char buf[12] = 2081;
          *(void *)uint64_t v74 = v36;
          *(_WORD *)&v74[8] = 1024;
          int v75 = v13;
          _os_log_error_impl((void *)&_mh_execute_header, v35, OS_LOG_TYPE_ERROR, "Failed to store non-magic Enc Key to storage for device %{private, mask.hash}s with error %d", buf, 0x1Cu);
          if (v79 < 0)
          {
            __int16 v34 = *(void **)__p;
LABEL_90:
            operator delete(v34);
          }
        }
LABEL_97:
        if (!--v14) {
          return sub_10003AFB4((uint64_t)v71);
        }
      }
      if ((void)v82 == *(void *)*k && *((void *)&v82 + 1) == *(void *)(*k + 8))
      {
        uint64_t v24 = qword_100A19ED8;
        if (!os_log_type_enabled((os_log_t)qword_100A19ED8, OS_LOG_TYPE_ERROR)) {
          goto LABEL_65;
        }
        sub_100475EE0((uint64_t)v8, (uint64_t)buf);
        int v25 = buf;
        if (v74[9] < 0) {
          int v25 = *(unsigned char **)buf;
        }
        *(_DWORD *)std::string __p = 136315138;
        *(void *)&__p[4] = v25;
        _os_log_error_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_ERROR, "Received invalid non-magic key from %s", __p, 0xCu);
        if ((v74[9] & 0x80000000) == 0) {
          goto LABEL_65;
        }
        uint64_t v26 = *(void **)buf;
        goto LABEL_58;
      }
      if (qword_1009F7ED0 != -1) {
        dispatch_once(&qword_1009F7ED0, &stru_1009A1F30);
      }
      sub_1007071C4(qword_1009F7EC8, v72, *k);
      if (v10)
      {
        uint64_t v23 = (uint64_t (**)(void))(*(void *)sub_100370758() + 112);
      }
      else
      {
        if (v70 && !v8[989])
        {
          if (!v8[988]) {
            goto LABEL_52;
          }
          if (qword_1009F8080 != -1) {
            dispatch_once(&qword_1009F8080, &stru_1009A1E50);
          }
          if (sub_100497A84((uint64_t)off_1009F8078, (uint64_t)v8)) {
            goto LABEL_52;
          }
        }
        uint64_t v23 = (uint64_t (**)(void))(*(void *)sub_100370758() + 88);
      }
      int v13 = (*v23)();
LABEL_52:
      int v27 = qword_100A19ED8;
      if (!v13)
      {
        if (os_log_type_enabled((os_log_t)qword_100A19ED8, OS_LOG_TYPE_INFO))
        {
          sub_100475EE0((uint64_t)v8, (uint64_t)buf);
          char v29 = buf;
          if (v74[9] < 0) {
            char v29 = *(unsigned char **)buf;
          }
          *(_DWORD *)std::string __p = 141558275;
          *(void *)&__p[4] = 1752392040;
          __int16 v77 = 2081;
          int v78 = v29;
          _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_INFO, "Successfully stored non-magic key to storage for device %{private, mask.hash}s ", __p, 0x16u);
          if ((v74[9] & 0x80000000) != 0) {
            operator delete(*(void **)buf);
          }
        }
        int v13 = 0;
        goto LABEL_65;
      }
      if (!os_log_type_enabled((os_log_t)qword_100A19ED8, OS_LOG_TYPE_ERROR)) {
        goto LABEL_65;
      }
      sub_100475EE0((uint64_t)v8, (uint64_t)__p);
      unint64_t v28 = __p;
      if (v79 < 0) {
        unint64_t v28 = *(unsigned char **)__p;
      }
      *(_DWORD *)long long buf = 141558531;
      *(void *)&uint8_t buf[4] = 1752392040;
      *(_WORD *)&unsigned char buf[12] = 2081;
      *(void *)uint64_t v74 = v28;
      *(_WORD *)&v74[8] = 1024;
      int v75 = v13;
      _os_log_error_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_ERROR, "Failed to store non-magic key to storage for device %{private, mask.hash}s with error %d", buf, 0x1Cu);
      if ((v79 & 0x80000000) == 0)
      {
LABEL_65:
        int v20 = *((unsigned __int16 *)k - 4);
        goto LABEL_66;
      }
      uint64_t v26 = *(void **)__p;
LABEL_58:
      operator delete(v26);
      goto LABEL_65;
    }
  }
  return sub_10003AFB4((uint64_t)v71);
}

void sub_10029A684(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, ...)
{
  va_start(va, a12);
  sub_10003AFB4((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_10029A6E8(uint64_t a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5)
{
  if (qword_1009F7F00 != -1) {
    dispatch_once(&qword_1009F7F00, &stru_1009A1E70);
  }
  *(_DWORD *)long long buf = *(_DWORD *)a2;
  LOWORD(v28) = *(_WORD *)(a2 + 4);
  uint64_t result = sub_1004AA194((uint64_t)off_1009F7EF8, (uint64_t)buf, 1);
  uint64_t v11 = result;
  if (result)
  {
    v26[0] = 0;
    v26[1] = 0;
    sub_10003AED0((uint64_t)v26, a1 + 360);
    char v12 = *(void ***)(a1 + 336);
    int v13 = *(void ***)(a1 + 344);
    while (v12 != v13)
    {
      uint64_t v14 = *v12;
      if (**v12 == v11) {
        goto LABEL_9;
      }
      ++v12;
    }
    uint64_t v14 = 0;
LABEL_9:
    uint64_t v15 = qword_100A19E38;
    if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v23 = sub_10025B48C(a2, v16, v17, v18, v19, v20, v21, v22);
      *(_DWORD *)long long buf = 136315906;
      uint64_t v28 = v23;
      __int16 v29 = 1024;
      int v30 = a3;
      __int16 v31 = 1024;
      int v32 = a4;
      __int16 v33 = 1024;
      int v34 = a5;
      _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "Receive command status from device \"%s\", commandType = %d, result -> %d, reason -> %d", buf, 0x1Eu);
    }
    int v24 = sub_100478B2C(v11, 32);
    if (a3 == 20) {
      int v25 = v24;
    }
    else {
      int v25 = 0;
    }
    if (v14)
    {
      if (v25) {
        sub_10029A8B8((uint64_t)v14, a4, a5);
      }
    }
    return sub_10003AFB4((uint64_t)v26);
  }
  return result;
}

void sub_10029A898(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_10029A8B8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(void *)(a1 + 672);
  if (v3)
  {
    unint64_t v7 = *(void *)(a1 + 664);
    int v8 = *(_DWORD *)(*(void *)(*(void *)(a1 + 640) + ((v7 >> 7) & 0x1FFFFFFFFFFFFF8)) + 4 * (v7 & 0x3FF));
    *(void *)(a1 + 672) = v3 - 1;
    *(void *)(a1 + 664) = v7 + 1;
    sub_1002B5F14(a1 + 632, 1);
    if (v8 == 1)
    {
      uint64_t v9 = qword_100A19E38;
      if (*(unsigned char *)(a1 + 618))
      {
        if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
        {
          sub_100474E18(*(void *)a1, __p);
          int v10 = v14 >= 0 ? __p : (void **)__p[0];
          *(_DWORD *)long long buf = 136446210;
          uint64_t v16 = v10;
          _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "Acknowledgement request TiPi connection priority list update for device %{public}s", buf, 0xCu);
          if (v14 < 0) {
            operator delete(__p[0]);
          }
        }
        *(unsigned char *)(a1 + 618) = 0;
        if (qword_1009F7EF0 != -1) {
          dispatch_once(&qword_1009F7EF0, &stru_1009A1E30);
        }
        sub_100455570((uint64_t)off_1009F7EE8, *(void *)a1, 1, a2, a3);
        uint64_t v11 = *(void **)(a1 + 624);
        if (v11)
        {
          [v11 invalidate];
          char v12 = *(void **)(a1 + 624);
          *(void *)(a1 + 624) = 0;
        }
      }
      else if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_ERROR))
      {
        sub_10074F420();
      }
    }
  }
  else if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_ERROR))
  {
    sub_10074F3EC();
  }
}

uint64_t sub_10029AA98(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  unsigned __int16 v8 = sub_100045F00(a4);
  uint64_t v9 = sub_10004A6E4(a4);

  return sub_10029AB0C(a1, a2, a3, v8, v9);
}

uint64_t sub_10029AB0C(uint64_t a1, uint64_t a2, int a3, int a4, uint64_t a5)
{
  unsigned __int16 v46 = a4;
  if (qword_1009F7F00 != -1) {
    dispatch_once(&qword_1009F7F00, &stru_1009A1E70);
  }
  *(_DWORD *)long long buf = *(_DWORD *)a2;
  *(_WORD *)&uint8_t buf[4] = *(_WORD *)(a2 + 4);
  uint64_t result = sub_1004AA194((uint64_t)off_1009F7EF8, (uint64_t)buf, 1);
  uint64_t v14 = result;
  if (result)
  {
    if (a3 <= 127)
    {
      if (a3 == 2 || a3 == 4) {
        goto LABEL_66;
      }
      if (a3 != 32)
      {
LABEL_26:
        uint64_t v23 = qword_100A19E38;
        if (!os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT)) {
          return sub_10029BA14(a1 + 560, v14, a3);
        }
        sub_100474E18(v14, __p);
        if (v50 >= 0) {
          int v24 = __p;
        }
        else {
          int v24 = *(unsigned char **)__p;
        }
        *(_DWORD *)long long buf = 136446722;
        *(void *)&uint8_t buf[4] = v24;
        *(_WORD *)&unsigned char buf[12] = 1024;
        *(_DWORD *)&unsigned char buf[14] = a3;
        *(_WORD *)&buf[18] = 1024;
        int v52 = a4;
        _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "Received custom message from %{public}s: type 0x%x, len %u", buf, 0x18u);
LABEL_31:
        if (v50 < 0) {
          operator delete(*(void **)__p);
        }
        return sub_10029BA14(a1 + 560, v14, a3);
      }
      uint64_t v15 = sub_100035F54();
      if (((*(uint64_t (**)(uint64_t))(*(void *)v15 + 328))(v15) & 1) == 0)
      {
        uint64_t v16 = sub_100035F54();
        if (((*(uint64_t (**)(uint64_t))(*(void *)v16 + 384))(v16) & 1) == 0)
        {
          uint64_t v17 = sub_100035F54();
          if (!(*(unsigned int (**)(uint64_t))(*(void *)v17 + 424))(v17)) {
            goto LABEL_66;
          }
        }
      }
      uint64_t v44 = 0;
      uint64_t v45 = 0;
      sub_10003AED0((uint64_t)&v44, a1 + 360);
      for (uint64_t i = *(void ***)(a1 + 336); i != *(void ***)(a1 + 344); ++i)
      {
        uint64_t v19 = *i;
        if (**i == v14)
        {
          uint64_t v42 = *(void *)((char *)v19 + 85);
          int v43 = *(_DWORD *)((char *)v19 + 93);
          if (!(*(unsigned __int16 *)((char *)&v42 + 3) | BYTE5(v42)))
          {
            *(_WORD *)((char *)&v42 + 3) = *(_WORD *)(a5 + 48);
            BYTE5(v42) = *(unsigned char *)(a5 + 50);
            LOWORD(v42) = *(_WORD *)(a5 + 36);
            BYTE2(v42) = *(unsigned char *)(a5 + 38);
            *(_WORD *)((char *)&v43 + 1) = *(_WORD *)(a5 + 54);
            HIBYTE(v43) = *(unsigned char *)(a5 + 56);
            if (100 * v42 + 10 * BYTE1(v42) + BYTE2(v42) >= 0x174
              && *((_DWORD *)v19 + 20) == 8194)
            {
              __int16 v29 = qword_100A19E38;
              if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
              {
                sub_100474E18(v14, buf);
                int v30 = v52 >= 0 ? buf : *(unsigned char **)buf;
                int v31 = *((_DWORD *)v19 + 20);
                *(_DWORD *)std::string __p = 136446466;
                *(void *)&__p[4] = v30;
                __int16 v48 = 1024;
                int v49 = v31;
                _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEFAULT, "Enabling enhanced double tap feature support on device %{public}s (pid = 0x%x)", __p, 0x12u);
                if (SHIBYTE(v52) < 0) {
                  operator delete(*(void **)buf);
                }
              }
              sub_10047D50C(v14, 14, 1);
            }
            int v32 = qword_100A19E38;
            if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)long long buf = 67109632;
              *(_DWORD *)&uint8_t buf[4] = BYTE3(v42);
              *(_WORD *)&uint8_t buf[8] = 1024;
              *(_DWORD *)&buf[10] = BYTE4(v42);
              *(_WORD *)&unsigned char buf[14] = 1024;
              *(_DWORD *)&uint8_t buf[16] = BYTE5(v42);
              _os_log_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_DEFAULT, "case F/W version from Headset  %d, %d, %d", buf, 0x14u);
              int v32 = qword_100A19E38;
            }
            if (os_log_type_enabled(v32, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)long long buf = 67109632;
              *(_DWORD *)&uint8_t buf[4] = BYTE1(v43);
              *(_WORD *)&uint8_t buf[8] = 1024;
              *(_DWORD *)&buf[10] = BYTE2(v43);
              *(_WORD *)&unsigned char buf[14] = 1024;
              *(_DWORD *)&uint8_t buf[16] = HIBYTE(v43);
              _os_log_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_DEFAULT, "case H/W version from Headset  %d, %d, %d", buf, 0x14u);
              int v32 = qword_100A19E38;
            }
            if (os_log_type_enabled(v32, OS_LOG_TYPE_DEFAULT))
            {
              int v33 = *(unsigned __int8 *)(a5 + 36);
              int v34 = *(unsigned __int8 *)(a5 + 37);
              int v35 = *(unsigned __int8 *)(a5 + 38);
              *(_DWORD *)long long buf = 67109632;
              *(_DWORD *)&uint8_t buf[4] = v33;
              *(_WORD *)&uint8_t buf[8] = 1024;
              *(_DWORD *)&buf[10] = v34;
              *(_WORD *)&unsigned char buf[14] = 1024;
              *(_DWORD *)&uint8_t buf[16] = v35;
              _os_log_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_DEFAULT, "Active Bud F/W version from Headset  %d, %d, %d", buf, 0x14u);
              int v32 = qword_100A19E38;
            }
            if (os_log_type_enabled(v32, OS_LOG_TYPE_DEFAULT))
            {
              int v36 = *(unsigned __int8 *)(a5 + 39);
              int v37 = *(unsigned __int8 *)(a5 + 40);
              int v38 = *(unsigned __int8 *)(a5 + 41);
              *(_DWORD *)long long buf = 67109632;
              *(_DWORD *)&uint8_t buf[4] = v36;
              *(_WORD *)&uint8_t buf[8] = 1024;
              *(_DWORD *)&buf[10] = v37;
              *(_WORD *)&unsigned char buf[14] = 1024;
              *(_DWORD *)&uint8_t buf[16] = v38;
              _os_log_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_DEFAULT, "Pending Bud F/W version from Headset  %d, %d, %d", buf, 0x14u);
            }
            *(void *)((char *)v19 + 85) = v42;
            *(_DWORD *)((char *)v19 + 93) = v43;
            if (qword_1009FB150 != -1) {
              dispatch_once(&qword_1009FB150, &stru_1009A1FB0);
            }
            uint64_t v39 = (*(uint64_t (**)(void *, void))(*(void *)off_1009FB148 + 120))(off_1009FB148, *v19);
            if (v39) {
              sub_10029B320(v39, (uint64_t)v19);
            }
          }
          sub_10003AFE8((uint64_t)&v44);
          sub_10003AFB4((uint64_t)&v44);
          goto LABEL_66;
        }
      }
    }
    else
    {
      if (a3 < 0x40000)
      {
        if (a3 != 128 && a3 != 1024) {
          goto LABEL_26;
        }
LABEL_66:
        if (qword_1009F8798 != -1) {
          dispatch_once(&qword_1009F8798, &stru_1009A1F10);
        }
        sub_1003F059C(qword_1009F8790, (unsigned int *)a2, a3, v46, (int *)a5);
        return sub_10029BA14(a1 + 560, v14, a3);
      }
      if (a3 != 0x40000)
      {
        if (a3 == 0x100000)
        {
          int v20 = sub_1000D40C0(a5, (unsigned __int16)(a4 - 2), v11, v12, v13);
          if (v20 == 1)
          {
            *(void *)long long buf = 0;
            *(void *)&uint8_t buf[8] = 0;
            uint64_t v21 = sub_10003AED0((uint64_t)buf, a1 + 360);
            for (uint64_t j = *(uint64_t **)(a1 + 336); ; ++j)
            {
              if (j == *(uint64_t **)(a1 + 344))
              {
                int v27 = (uint64_t *)buf;
                return sub_10003AFB4((uint64_t)v27);
              }
              if (*(void *)*j == v14) {
                break;
              }
            }
            sub_10029B8C8(v21, *j, v14, &v46, a5);
            sub_10003AFB4((uint64_t)buf);
          }
          int v40 = qword_100A19E38;
          if (!os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEBUG)) {
            return sub_10029BA14(a1 + 560, v14, a3);
          }
          sub_100474E18(v14, __p);
          if (v50 >= 0) {
            int v41 = __p;
          }
          else {
            int v41 = *(unsigned char **)__p;
          }
          *(_DWORD *)long long buf = 136446722;
          *(void *)&uint8_t buf[4] = v41;
          *(_WORD *)&unsigned char buf[12] = 1024;
          *(_DWORD *)&unsigned char buf[14] = v20;
          *(_WORD *)&buf[18] = 1024;
          int v52 = v46;
          _os_log_debug_impl((void *)&_mh_execute_header, v40, OS_LOG_TYPE_DEBUG, "Received AACP_CUSTOM_MESSAGE_TYPE_SENSOR_WX message from %{public}s: protocol %u, len %u", buf, 0x18u);
          goto LABEL_31;
        }
        goto LABEL_26;
      }
      uint64_t v44 = 0;
      uint64_t v45 = 0;
      uint64_t v25 = sub_10003AED0((uint64_t)&v44, a1 + 360);
      for (k = *(uint64_t **)(a1 + 336); k != *(uint64_t **)(a1 + 344); ++k)
      {
        if (*(void *)*k == v14)
        {
          sub_10029B8C8(v25, *k, v14, &v46, a5);
          uint64_t v28 = qword_100A19E38;
          if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEBUG))
          {
            sub_100474E18(v14, buf);
            sub_10074F454(buf, &v46, __p, v28);
          }
          sub_10003AFB4((uint64_t)&v44);
          return sub_10029BA14(a1 + 560, v14, a3);
        }
      }
    }
    int v27 = &v44;
    return sub_10003AFB4((uint64_t)v27);
  }
  return result;
}

void sub_10029B2EC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  sub_10003AFB4((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_10029B320(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    if (*(_DWORD *)(a2 + 80) == 8194)
    {
      uint64_t v3 = *(void *)a2;
      if (*(void *)a2)
      {
        int v4 = qword_100A19E38;
        if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
        {
          sub_100475EE0(v3, (uint64_t)__p);
          uint64_t v5 = __p[23] >= 0 ? __p : *(unsigned char **)__p;
          *(_DWORD *)long long buf = 141558275;
          *(void *)&uint8_t buf[4] = 1752392040;
          *(_WORD *)&unsigned char buf[12] = 2081;
          *(void *)&unsigned char buf[14] = v5;
          _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "publishW1RemoteFirmware: Publishing F/W version for \"%{private, mask.hash}s\"", buf, 0x16u);
          if ((__p[23] & 0x80000000) != 0) {
            operator delete(*(void **)__p);
          }
        }
        __int16 v35 = 0;
        uint64_t cStr = 0;
        __int16 v33 = 0;
        uint64_t v32 = 0;
        uint64_t v20 = *(void *)(a2 + 85);
        int v21 = *(_DWORD *)(a2 + 93);
        if (*(unsigned __int16 *)((char *)&v20 + 3) | BYTE5(v20))
        {
          sub_1004A82EC((unsigned __int8 *)(v3 + 128), __p);
          if (__p[23] >= 0) {
            uint64_t v6 = __p;
          }
          else {
            uint64_t v6 = *(const char **)__p;
          }
          CFStringRef v7 = CFStringCreateWithCString(kCFAllocatorDefault, v6, 0x8000100u);
          if ((__p[23] & 0x80000000) != 0) {
            operator delete(*(void **)__p);
          }
          if (v7)
          {
            sprintf((char *)&cStr, "%d.%d.%d", BYTE3(v20), BYTE4(v20), BYTE5(v20));
            CFStringRef v8 = CFStringCreateWithCString(kCFAllocatorDefault, (const char *)&cStr, 0x8000100u);
            if (v8)
            {
              sprintf((char *)&v32, "%d.%d.%d", BYTE1(v21), BYTE2(v21), HIBYTE(v21));
              CFStringRef v9 = CFStringCreateWithCString(kCFAllocatorDefault, (const char *)&v32, 0x8000100u);
              if (v9)
              {
                uint64_t Connection = (const void *)acc_transportClient_createConnection();
                if (Connection)
                {
                  uint64_t Endpoint = acc_transportClient_createEndpoint();
                  uint64_t v12 = qword_100A19E38;
                  if (Endpoint)
                  {
                    if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
                    {
                      *(_DWORD *)std::string __p = 138412546;
                      *(void *)&__p[4] = Connection;
                      *(_WORD *)&unsigned char __p[12] = 2112;
                      *(void *)&unsigned char __p[14] = Endpoint;
                      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "publishW1RemoteFirmware: connection %@ endpoint %@", __p, 0x16u);
                    }
                    *(void *)(a2 + 112) = Connection;
                    *(void *)(a2 + 120) = Endpoint;
                    *(void *)std::string __p = kCFACCInfo_Name;
                    *(_OWORD *)&__p[8] = __PAIR128__(kCFACCInfo_Model, kCFACCInfo_Manufacturer);
                    uint64_t v28 = kCFACCInfo_SerialNumber;
                    uint64_t v29 = kCFACCInfo_HardwareVersion;
                    uint64_t v30 = kCFACCInfo_FirmwareVersionActive;
                    uint64_t v31 = kCFACCInfo_FirmwareVersionPending;
                    *(void *)long long buf = @"AirPods Case";
                    *(void *)&uint8_t buf[8] = @"Apple Inc";
                    *(void *)&uint8_t buf[16] = @"A1602";
                    CFNullRef v23 = kCFNull;
                    CFStringRef v24 = v9;
                    CFStringRef v25 = v8;
                    CFNullRef v26 = kCFNull;
                    CFDictionaryRef v13 = CFDictionaryCreate(kCFAllocatorDefault, (const void **)__p, (const void **)buf, 7, &kCFCopyStringDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
                    acc_transportClient_setAccessoryInfo();
                    CFRelease(v13);
                    acc_transportClient_setPropertyForConnectionWithUUID();
                    acc_transportClient_publishConnection();
                    CFRelease(v7);
                    CFRelease(v8);
                    CFRelease(v9);
                  }
                  else
                  {
                    if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_ERROR)) {
                      sub_10074F770(v3, v12);
                    }
                    CFRelease(Connection);
                    CFRelease(v9);
                    CFRelease(v8);
                    CFRelease(v7);
                  }
                }
                else
                {
                  uint64_t v19 = qword_100A19E38;
                  if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_ERROR)) {
                    sub_10074F6D8(v3, v19);
                  }
                  CFRelease(v9);
                  CFRelease(v8);
                  CFRelease(v7);
                }
              }
              else
              {
                uint64_t v18 = qword_100A19E38;
                if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_ERROR)) {
                  sub_10074F640(v3, v18);
                }
                CFRelease(v8);
                CFRelease(v7);
              }
            }
            else
            {
              uint64_t v17 = qword_100A19E38;
              if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_ERROR)) {
                sub_10074F5A8(v3, v17);
              }
              CFRelease(v7);
            }
          }
          else
          {
            uint64_t v16 = qword_100A19E38;
            if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_ERROR)) {
              sub_10074F510(v3, v16);
            }
          }
        }
        else
        {
          uint64_t v14 = qword_100A19E38;
          if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
          {
            sub_100475EE0(v3, (uint64_t)__p);
            uint64_t v15 = __p[23] >= 0 ? __p : *(unsigned char **)__p;
            *(_DWORD *)long long buf = 141558275;
            *(void *)&uint8_t buf[4] = 1752392040;
            *(_WORD *)&unsigned char buf[12] = 2081;
            *(void *)&unsigned char buf[14] = v15;
            _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "Warning: publishW1RemoteFirmware: No case version info available for \"%{private, mask.hash}s\"", buf, 0x16u);
            if ((__p[23] & 0x80000000) != 0) {
              operator delete(*(void **)__p);
            }
          }
        }
      }
    }
  }
  else if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_ERROR))
  {
    sub_10074F4DC();
  }
}

void sub_10029B8A4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,void *__p,uint64_t a24,int a25,__int16 a26,char a27,char a28)
{
  if (a28 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_10029B8C8(uint64_t a1, uint64_t a2, uint64_t a3, unsigned __int16 *a4, uint64_t a5)
{
  if (*a4 >= 2u && (sub_100487EFC(a3, 0xE0u) != 2 || *(_DWORD *)(a2 + 16) != 1))
  {
    unsigned __int16 v9 = *a4 - 2;
    int v10 = *(unsigned __int16 *)(a5 + v9);
    if (v10 != *(unsigned __int16 *)(a2 + 760))
    {
      uint64_t v11 = qword_100A19E38;
      if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
      {
        v12[0] = 67109120;
        v12[1] = v10;
        _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "Received new sensor data v2 JB: %u", (uint8_t *)v12, 8u);
      }
      *(_WORD *)(a2 + 760) = v10;
      if (qword_1009F80B0 != -1) {
        dispatch_once(&qword_1009F80B0, &stru_1009A1FD0);
      }
      sub_100567258((uint64_t)off_1009F80A8, a3, v10);
    }
    *a4 = v9;
  }
}

uint64_t sub_10029BA14(uint64_t a1, uint64_t a2, int a3)
{
  v17[0] = 0;
  v17[1] = 0;
  sub_10003AED0((uint64_t)v17, a1 + 24);
  uint64_t v5 = *(unint64_t **)a1;
  if (*(void *)a1 == *(void *)(a1 + 8))
  {
    uint64_t v11 = 106;
  }
  else
  {
    do
    {
      if (qword_1009F8168 != -1) {
        dispatch_once(&qword_1009F8168, &stru_1009A1FF0);
      }
      if (sub_1000181D0(qword_1009F8160, *v5))
      {
        v5 += 4;
      }
      else
      {
        uint64_t v6 = qword_100A19E38;
        if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)long long buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "Warning: AACPDebugUtils, Invalid BTAccessoryManager handle - removing associated callbacks", buf, 2u);
        }
        uint64_t v5 = (unint64_t *)sub_1002AA304(a1, (uint64_t)v5);
      }
    }
    while (v5 != *(unint64_t **)(a1 + 8));
    uint64_t v7 = *(void *)a1;
    unint64_t v8 = ((uint64_t)v5 - *(void *)a1) >> 5;
    *(void *)long long buf = 0;
    uint64_t v15 = 0;
    uint64_t v16 = 0;
    sub_1002B63D4((char *)buf, v7, (uint64_t)v5, v8);
    sub_10003AFE8((uint64_t)v17);
    uint64_t v9 = *(void *)buf;
    uint64_t v10 = v15;
    if (*(void *)buf != v15)
    {
      do
      {
        if (qword_1009F8168 != -1) {
          dispatch_once(&qword_1009F8168, &stru_1009A1FF0);
        }
        sub_1000181D0(qword_1009F8160, *(void *)v9);
        if (qword_1009F7F00 != -1) {
          dispatch_once(&qword_1009F7F00, &stru_1009A1E70);
        }
        sub_1004A93A0((uint64_t)off_1009F7EF8, *(void *)v9, a2);
        if ((a3 & ~*(_DWORD *)(v9 + 16)) == 0)
        {
          if (qword_1009FB160 != -1) {
            dispatch_once(&qword_1009FB160, &stru_1009A2010);
          }
          operator new();
        }
        v9 += 32;
      }
      while (v9 != v10);
      uint64_t v9 = *(void *)buf;
    }
    if (v9)
    {
      uint64_t v15 = v9;
      operator delete((void *)v9);
    }
    uint64_t v11 = 0;
  }
  sub_10003AFB4((uint64_t)v17);
  return v11;
}

void sub_10029BCDC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13, uint64_t a14, char a15)
{
  if (__p) {
    operator delete(__p);
  }
  sub_10003AFB4((uint64_t)&a15);
  _Unwind_Resume(a1);
}

void sub_10029BD38(uint64_t a1, uint64_t a2, int a3)
{
  if (qword_1009F7F00 != -1) {
    dispatch_once(&qword_1009F7F00, &stru_1009A1E70);
  }
  LODWORD(__p[0]) = *(_DWORD *)a2;
  WORD2(__p[0]) = *(_WORD *)(a2 + 4);
  uint64_t v5 = sub_1004AA194((uint64_t)off_1009F7EF8, (uint64_t)__p, 1);
  uint64_t v6 = qword_100A19E38;
  if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
  {
    sub_100475EE0(v5, (uint64_t)__p);
    if (v9 >= 0) {
      uint64_t v7 = __p;
    }
    else {
      uint64_t v7 = (void **)__p[0];
    }
    *(_DWORD *)long long buf = 136315394;
    uint64_t v11 = v7;
    __int16 v12 = 1024;
    int v13 = a3;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "received tap interval info from device \"%s\", tapInterval = %d", buf, 0x12u);
    if (v9 < 0) {
      operator delete(__p[0]);
    }
  }
}

void sub_10029BE74(uint64_t a1, uint64_t a2, int a3, unsigned int a4)
{
  if (qword_1009F7F00 != -1) {
    dispatch_once(&qword_1009F7F00, &stru_1009A1E70);
  }
  *(_DWORD *)long long buf = *(_DWORD *)a2;
  *(_WORD *)uint64_t v32 = *(_WORD *)(a2 + 4);
  uint64_t v8 = sub_1004AA194((uint64_t)off_1009F7EF8, (uint64_t)buf, 1);
  uint64_t v9 = v8;
  if (v8)
  {
    for (uint64_t i = *(void ***)(a1 + 336); i != *(void ***)(a1 + 344); ++i)
    {
      if (**i == v8)
      {
        __int16 v12 = qword_100A19E38;
        BOOL v13 = os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT);
        if (v13)
        {
          sub_1002872A4(a1, a3, a4, v29);
          int v14 = v30;
          uint64_t v15 = (void **)v29[0];
          sub_100474E18(v9, __p);
          if (v14 >= 0) {
            uint64_t v15 = v29;
          }
          uint64_t v17 = sub_100287278(v16, a3);
          if (v28 >= 0) {
            uint64_t v18 = __p;
          }
          else {
            uint64_t v18 = (void **)__p[0];
          }
          *(_DWORD *)long long buf = 136446978;
          *(void *)uint64_t v32 = v17;
          *(_WORD *)&v32[8] = 1024;
          *(_DWORD *)__int16 v33 = a3;
          *(_WORD *)&v33[4] = 2082;
          int v34 = v15;
          __int16 v35 = 2082;
          int v36 = v18;
          _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "Received %{public}s (control cmd 0x%02X) as %{public}s from device %{public}s", buf, 0x26u);
          if (v28 < 0) {
            operator delete(__p[0]);
          }
          if (v30 < 0) {
            operator delete(v29[0]);
          }
        }
        switch(a3)
        {
          case 6:
            BOOL v19 = a4 == 0;
            BOOL v20 = a4 != 0;
            char v21 = v19;
            sub_10029C988(a1, v9, v21);
            sub_100486CBC(v9, v20);
            if (qword_1009F7EF0 != -1) {
              goto LABEL_89;
            }
            goto LABEL_78;
          case 10:
            sub_100291D0C(a1, v9, a4 != 1, 2u);
            if (qword_1009F7EF0 == -1) {
              goto LABEL_78;
            }
            goto LABEL_89;
          case 13:
            CFNullRef v23 = qword_100A19E38;
            if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)long long buf = 67109120;
              *(_DWORD *)uint64_t v32 = a4;
              _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "Set ListeningMode device setting : ListeningMode value %d", buf, 8u);
            }
            uint64_t v24 = sub_100485628(v9, a4);
            sub_10028C738(v24, v9);
            if (qword_1009F7EF0 == -1) {
              goto LABEL_78;
            }
            goto LABEL_89;
          case 22:
            CFStringRef v25 = qword_100A19E38;
            if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)long long buf = 67109888;
              *(_DWORD *)uint64_t v32 = a4;
              *(_WORD *)&v32[4] = 1024;
              *(_DWORD *)&v32[6] = BYTE1(a4);
              *(_WORD *)__int16 v33 = 1024;
              *(_DWORD *)&void v33[2] = BYTE2(a4);
              LOWORD(v34) = 1024;
              *(_DWORD *)((char *)&v34 + 2) = HIBYTE(a4);
              _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "Received ClickHoldMode device setting: right 0x%02X, left 0x%02X, prevRight 0x%02X, prevLeft 0x%02X", buf, 0x1Au);
            }
            sub_100485B50(v9, a4);
            if (qword_1009F7EF0 == -1) {
              goto LABEL_78;
            }
            goto LABEL_89;
          case 23:
            sub_100485C3C(v9, a4);
            if (qword_1009F7EF0 != -1) {
              dispatch_once(&qword_1009F7EF0, &stru_1009A1E30);
            }
            sub_1004566A0((uint64_t)off_1009F7EE8, v9, 16, (uint64_t)"Double Click Interval");
            return;
          case 24:
            sub_100485CD0(v9, a4);
            if (qword_1009F7EF0 != -1) {
              dispatch_once(&qword_1009F7EF0, &stru_1009A1E30);
            }
            sub_1004566A0((uint64_t)off_1009F7EE8, v9, 18, (uint64_t)"Click and Hold Interval");
            return;
          case 27:
            sub_100485D64(v9, a4);
            if (qword_1009F7EF0 != -1) {
              dispatch_once(&qword_1009F7EF0, &stru_1009A1E30);
            }
            sub_1004566A0((uint64_t)off_1009F7EE8, v9, 21, (uint64_t)"One Bud ANC Mode");
            return;
          case 28:
            sub_100485DF8(v9, a4);
            if (qword_1009F7EF0 == -1) {
              goto LABEL_78;
            }
            goto LABEL_89;
          case 30:
            sub_100485E40(v9, a4);
            if (qword_1009F7EF0 == -1) {
              goto LABEL_78;
            }
            goto LABEL_89;
          case 31:
            sub_100485E88(v9, a4);
            if (qword_1009F7EF0 != -1) {
              dispatch_once(&qword_1009F7EF0, &stru_1009A1E30);
            }
            sub_100455E64((uint64_t)off_1009F7EE8, v9);
            if (qword_1009F7EF0 != -1) {
              dispatch_once(&qword_1009F7EF0, &stru_1009A1E30);
            }
            sub_1004566A0((uint64_t)off_1009F7EE8, v9, 17, (uint64_t)"Chime Volume");
            return;
          case 35:
            sub_100485FAC(v9, a4);
            if (qword_1009F7EF0 != -1) {
              dispatch_once(&qword_1009F7EF0, &stru_1009A1E30);
            }
            sub_1004566A0((uint64_t)off_1009F7EE8, v9, 20, (uint64_t)"Volume Swipe Interval");
            return;
          case 36:
            CFNullRef v26 = qword_100A19E38;
            if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)long long buf = 67109120;
              *(_DWORD *)uint64_t v32 = a4;
              _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "Prox Card Status: Received Call Management: 0x%x", buf, 8u);
            }
            sub_10048612C(v9, a4);
            sub_10028C444(a1, v9, 36, a4);
            if (qword_1009F7EF0 == -1) {
              goto LABEL_78;
            }
            goto LABEL_89;
          case 37:
            sub_100485F18(v9, a4);
            if (qword_1009F7EF0 != -1) {
              dispatch_once(&qword_1009F7EF0, &stru_1009A1E30);
            }
            sub_1004566A0((uint64_t)off_1009F7EE8, v9, 19, (uint64_t)"Volume Swipe Mode");
            return;
          case 38:
            sub_100486040(v9, a4);
            if (qword_1009F8418 != -1) {
              dispatch_once(&qword_1009F8418, &stru_1009A1E10);
            }
            sub_10041526C((void *)qword_1009F8410, v9, a4);
            if (qword_1009F7EF0 == -1) {
              goto LABEL_78;
            }
            goto LABEL_89;
          case 39:
            sub_100486210(v9, a4);
            sub_10028C65C(a1);
            if (qword_1009F7EF0 == -1) {
              goto LABEL_78;
            }
            goto LABEL_89;
          case 40:
            sub_1002870DC(v13, v9, a4);
            sub_1004862BC(v9, a4);
            if (qword_1009F7EF0 == -1) {
              goto LABEL_78;
            }
            goto LABEL_89;
          case 41:
            sub_100486368(v9, a4);
            if (qword_1009F7EF0 == -1) {
              goto LABEL_78;
            }
LABEL_89:
            dispatch_once(&qword_1009F7EF0, &stru_1009A1E30);
LABEL_78:
            sub_100455E64((uint64_t)off_1009F7EE8, v9);
            break;
          case 44:
            sub_10048E03C(v9, a4);
            sub_10048E124(v9, BYTE1(a4));
            break;
          case 46:
            sub_10048645C(v9, a4);
            break;
          case 47:
            sub_100486660(v9, a4);
            break;
          case 48:
            sub_100486508(v9, a4);
            break;
          case 49:
            sub_100486414(v9, a4);
            if (qword_1009F7EF0 != -1) {
              dispatch_once(&qword_1009F7EF0, &stru_1009A1E30);
            }
            sub_1004566A0((uint64_t)off_1009F7EE8, v9, 24, (uint64_t)"In Case Tone");
            break;
          case 50:
            sub_1004865B4(v9, a4);
            break;
          case 51:
            sub_10048670C(v9, a4);
            break;
          case 52:
            sub_1004867B8(v9, a4);
            break;
          default:
            uint64_t v22 = qword_100A19E38;
            if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)long long buf = 67109120;
              *(_DWORD *)uint64_t v32 = a3;
              _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "Unsupported control xpc_type_t type = %d", buf, 8u);
            }
            break;
        }
        return;
      }
    }
    if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_ERROR)) {
      sub_10074F8A0();
    }
  }
  else
  {
    uint64_t v11 = qword_100A19E38;
    if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_ERROR)) {
      sub_10074F808(v11);
    }
  }
}

void sub_10029C8A8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10029C988(uint64_t a1, uint64_t a2, char a3)
{
  v16[0] = 0;
  v16[1] = 0;
  sub_10003AED0((uint64_t)v16, a1 + 360);
  if (a2)
  {
    for (uint64_t i = *(void ***)(a1 + 336); i != *(void ***)(a1 + 344); ++i)
    {
      if (**i == a2)
      {
        uint64_t v8 = sub_1004AFA9C();
        v14[0] = _NSConcreteStackBlock;
        v14[1] = 3221225472;
        void v14[2] = sub_1002AFBFC;
        v14[3] = &unk_100998A58;
        void v14[4] = a2;
        char v15 = a3;
        sub_100013018(v8, v14);
        uint64_t v9 = sub_1004AFB34();
        v12[0] = _NSConcreteStackBlock;
        v12[1] = 3221225472;
        _DWORD v12[2] = sub_1002AFC64;
        void v12[3] = &unk_100998A58;
        void v12[4] = a2;
        char v13 = a3;
        sub_100013018(v9, v12);
        goto LABEL_9;
      }
    }
  }
  uint64_t v7 = qword_100A19E38;
  if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v11 = 0;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "setHijackAudioRoute unable to find AACP connection", v11, 2u);
  }
LABEL_9:
  sub_10003AFB4((uint64_t)v16);
  return 0;
}

void sub_10029CAF4(_Unwind_Exception *a1)
{
  sub_10003AFB4(v1 - 64);
  _Unwind_Resume(a1);
}

uint64_t sub_10029CB08(uint64_t a1, uint64_t a2, int a3, unsigned int a4, unsigned __int8 *a5)
{
  unsigned int v128 = a5;
  LODWORD(v127) = a3;
  uint64_t v129 = a1;
  if (qword_1009F7F00 != -1) {
    dispatch_once(&qword_1009F7F00, &stru_1009A1E70);
  }
  *(_DWORD *)uint64_t v152 = *(_DWORD *)a2;
  uint64_t v126 = (void *)a2;
  *(_WORD *)&v152[4] = *(_WORD *)(a2 + 4);
  uint64_t result = sub_1004AA194((uint64_t)off_1009F7EF8, (uint64_t)v152, 1);
  uint64_t v8 = result;
  if (!result) {
    return result;
  }
  v148[0] = 0;
  v148[1] = 0;
  uint64_t v9 = sub_10003AED0((uint64_t)v148, v129 + 360);
  uint64_t v10 = *(void **)(v129 + 336);
  uint64_t v11 = *(void **)(v129 + 344);
  if (v10 == v11)
  {
LABEL_7:
    if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_ERROR))
    {
      sub_100474E18(v8, v152);
      sub_10074F8D4();
    }
    return sub_10003AFB4((uint64_t)v148);
  }
  while (1)
  {
    __int16 v12 = (void *)*v10;
    if (*(void *)*v10 == v8) {
      break;
    }
    if (++v10 == v11) {
      goto LABEL_7;
    }
  }
  if ((v127 - 3) <= 0xFFFFFFFD)
  {
    if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_ERROR)) {
      sub_10074F928();
    }
    return sub_10003AFB4((uint64_t)v148);
  }
  uint64_t v121 = &v117;
  uint64_t v13 = byte_1007BB350[v127];
  __chkstk_darwin(v9, v13 << 8);
  bzero(&v117 - 32 * v13, v14);
  if ((int)v13 + 2 > a4)
  {
    if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_ERROR)) {
      sub_10074F990();
    }
    return sub_10003AFB4((uint64_t)v148);
  }
  if (*v128 > 0x1Fu)
  {
    if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_ERROR)) {
      sub_10074F9F8();
    }
    return sub_10003AFB4((uint64_t)v148);
  }
  uint64_t v123 = *v128;
  uint64_t v16 = 0;
  uint64_t v122 = (char *)(&v117 - 32 * v13 + 320);
  uint64_t v118 = v13;
  if (v13 <= 1) {
    uint64_t v17 = 1;
  }
  else {
    uint64_t v17 = v13;
  }
  uint64_t v124 = v17;
  unsigned int v125 = (char *)(&v117 - 32 * v13);
  int v18 = 2;
  *(void *)&long long v15 = 136446466;
  long long v120 = v15;
  *(void *)&long long v15 = 67109632;
  long long v119 = v15;
  while (1)
  {
    while (1)
    {
      if ((unsigned __int16)v18 >= a4)
      {
        int v27 = qword_100A19E38;
        if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)uint64_t v152 = v119;
          *(_DWORD *)&v152[4] = v16;
          *(_WORD *)&v152[8] = 1024;
          *(_DWORD *)&v152[10] = (unsigned __int16)v18;
          *(_WORD *)&v152[14] = 1024;
          *(_DWORD *)&v152[16] = a4;
          _os_log_error_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_ERROR, "versionInfoEvent: Reached end of strings in version info, count %d, %d >= %d", v152, 0x14u);
        }
        v125[256 * v16] = 0;
        goto LABEL_43;
      }
      BOOL v19 = (const char *)&v128[(unsigned __int16)v18];
      if (v16 != 10) {
        break;
      }
      uint64_t v20 = atoi(v19);
      int v21 = v20;
      sub_100294014(v20, v20);
      id v22 = objc_claimAutoreleasedReturnValue();
      CFNullRef v23 = (const char *)[v22 UTF8String];
      BOOL v24 = v123 == 4;
      strcpy(v122, v23);

      v18 += strlen(v19) + 1;
      if (!v24) {
        goto LABEL_43;
      }
      sub_100482938(v8, v21);
      CFStringRef v25 = qword_100A19E38;
      if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
      {
        sub_100474E18(v8, v152);
        CFNullRef v26 = v152;
        if (v152[23] < 0) {
          CFNullRef v26 = *(unsigned char **)v152;
        }
        *(_DWORD *)long long buf = v120;
        *(void *)&uint8_t buf[4] = v122;
        *(_WORD *)&unsigned char buf[12] = 2082;
        *(void *)&unsigned char buf[14] = v26;
        _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "Identification - Apple Audio Device firmware version of %{public}s for device %{public}s received.", buf, 0x16u);
        if ((v152[23] & 0x80000000) != 0) {
          operator delete(*(void **)v152);
        }
      }
      sub_100477298(v8);
      uint64_t v16 = 11;
      if (v124 == 11) {
        goto LABEL_46;
      }
    }
    if (strlen(v19) != 1 || *v19 != 48) {
      break;
    }
    v125[256 * v16] = 0;
    v18 += 2;
LABEL_43:
    if (++v16 == v124)
    {
      uint64_t v32 = v123;
      if (v123 == 13)
      {
        sub_10004191C(&v130, v122);
        sub_10048068C(v8, &v130);
        if (SHIBYTE(v130.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v130.__r_.__value_.__l.__data_);
        }
        LODWORD(v127) = 0;
      }
      else
      {
        if (v123 == 4)
        {
LABEL_46:
          memset(buf, 0, 24);
          uint64_t v145 = 0;
          uint64_t v146 = 0;
          uint64_t v147 = 0;
          sub_10047FF14(v8, (uint64_t)&v145);
          uint64_t v142 = 0;
          uint64_t v143 = 0;
          uint64_t v144 = 0;
          sub_1002B3390((char *)&v142, v145, v146, 0xAAAAAAAAAAAAAAABLL * (((char *)v146 - (char *)v145) >> 3));
          unsigned int v33 = v118;
          if (0xAAAAAAAAAAAAAAABLL * ((v143 - v142) >> 3) < 4)
          {
            LODWORD(v119) = 0;
          }
          else
          {
            if (*(char *)(v142 + 95) < 0) {
              unint64_t v34 = *(void *)(v142 + 80);
            }
            else {
              unint64_t v34 = *(unsigned __int8 *)(v142 + 95);
            }
            LODWORD(v119) = v34 > 1;
          }
          *(void *)uint64_t v152 = &v142;
          sub_100051568((void ***)v152);
          sub_10004191C(&v149, "");
          __int16 v35 = *(_OWORD **)&buf[8];
          if (*(void *)&buf[8] >= *(void *)&buf[16])
          {
            unint64_t v37 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)&buf[8] - *(void *)buf) >> 3);
            unint64_t v38 = v37 + 1;
            if (v37 + 1 > 0xAAAAAAAAAAAAAAALL) {
              abort();
            }
            if (0x5555555555555556 * ((uint64_t)(*(void *)&buf[16] - *(void *)buf) >> 3) > v38) {
              unint64_t v38 = 0x5555555555555556 * ((uint64_t)(*(void *)&buf[16] - *(void *)buf) >> 3);
            }
            if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)&buf[16] - *(void *)buf) >> 3) >= 0x555555555555555) {
              unint64_t v39 = 0xAAAAAAAAAAAAAAALL;
            }
            else {
              unint64_t v39 = v38;
            }
            *(void *)&v152[32] = &buf[16];
            if (v39) {
              int v40 = (char *)sub_1002B3440((uint64_t)&buf[16], v39);
            }
            else {
              int v40 = 0;
            }
            int v41 = &v40[24 * v37];
            long long v42 = v149;
            *((void *)v41 + 2) = v150;
            *(_OWORD *)int v41 = v42;
            uint64_t v150 = 0;
            long long v149 = 0uLL;
            uint64_t v44 = *(void *)buf;
            uint64_t v43 = *(void *)&buf[8];
            if (*(void *)&buf[8] == *(void *)buf)
            {
              int64x2_t v47 = vdupq_n_s64(*(unint64_t *)&buf[8]);
              uint64_t v45 = &v40[24 * v37];
            }
            else
            {
              uint64_t v45 = &v40[24 * v37];
              do
              {
                long long v46 = *(_OWORD *)(v43 - 24);
                *((void *)v45 - 1) = *(void *)(v43 - 8);
                *(_OWORD *)(v45 - 24) = v46;
                v45 -= 24;
                *(void *)(v43 - 16) = 0;
                *(void *)(v43 - 8) = 0;
                *(void *)(v43 - 24) = 0;
                v43 -= 24;
              }
              while (v43 != v44);
              int64x2_t v47 = *(int64x2_t *)buf;
            }
            __int16 v48 = v41 + 24;
            *(void *)long long buf = v45;
            *(void *)&uint8_t buf[8] = v41 + 24;
            *(int64x2_t *)&v152[8] = v47;
            uint64_t v49 = *(void *)&buf[16];
            *(void *)&uint8_t buf[16] = &v40[24 * v39];
            *(void *)&v152[24] = v49;
            *(void *)uint64_t v152 = v47.i64[0];
            sub_1002B4440((uint64_t)v152);
            *(void *)&uint8_t buf[8] = v48;
            if (SHIBYTE(v150) < 0) {
              operator delete((void *)v149);
            }
          }
          else
          {
            long long v36 = v149;
            *(void *)(*(void *)&buf[8] + 16) = v150;
            *__int16 v35 = v36;
            *(void *)&uint8_t buf[8] = (char *)v35 + 24;
          }
          if ((v127 - 1) <= 1)
          {
            if (v33 <= 2) {
              uint64_t v50 = 2;
            }
            else {
              uint64_t v50 = v33;
            }
            for (uint64_t i = 1; i != v50; ++i)
            {
              sub_10004191C(&v149, &v125[256 * i]);
              int v52 = *(_OWORD **)&buf[8];
              if (*(void *)&buf[8] >= *(void *)&buf[16])
              {
                unint64_t v54 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)&buf[8] - *(void *)buf) >> 3);
                unint64_t v55 = v54 + 1;
                if (v54 + 1 > 0xAAAAAAAAAAAAAAALL) {
                  abort();
                }
                if (0x5555555555555556 * ((uint64_t)(*(void *)&buf[16] - *(void *)buf) >> 3) > v55) {
                  unint64_t v55 = 0x5555555555555556 * ((uint64_t)(*(void *)&buf[16] - *(void *)buf) >> 3);
                }
                if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)&buf[16] - *(void *)buf) >> 3) >= 0x555555555555555) {
                  unint64_t v56 = 0xAAAAAAAAAAAAAAALL;
                }
                else {
                  unint64_t v56 = v55;
                }
                *(void *)&v152[32] = &buf[16];
                if (v56) {
                  BOOL v57 = (char *)sub_1002B3440((uint64_t)&buf[16], v56);
                }
                else {
                  BOOL v57 = 0;
                }
                CFNumberRef v58 = &v57[24 * v54];
                long long v59 = v149;
                *((void *)v58 + 2) = v150;
                *(_OWORD *)CFNumberRef v58 = v59;
                uint64_t v150 = 0;
                long long v149 = 0uLL;
                uint64_t v61 = *(void *)buf;
                uint64_t v60 = *(void *)&buf[8];
                if (*(void *)&buf[8] == *(void *)buf)
                {
                  int64x2_t v64 = vdupq_n_s64(*(unint64_t *)&buf[8]);
                  __int16 v62 = &v57[24 * v54];
                }
                else
                {
                  __int16 v62 = &v57[24 * v54];
                  do
                  {
                    long long v63 = *(_OWORD *)(v60 - 24);
                    *((void *)v62 - 1) = *(void *)(v60 - 8);
                    *(_OWORD *)(v62 - 24) = v63;
                    v62 -= 24;
                    *(void *)(v60 - 16) = 0;
                    *(void *)(v60 - 8) = 0;
                    *(void *)(v60 - 24) = 0;
                    v60 -= 24;
                  }
                  while (v60 != v61);
                  int64x2_t v64 = *(int64x2_t *)buf;
                }
                char v65 = v58 + 24;
                *(void *)long long buf = v62;
                *(void *)&uint8_t buf[8] = v58 + 24;
                *(int64x2_t *)&v152[8] = v64;
                uint64_t v66 = *(void *)&buf[16];
                *(void *)&uint8_t buf[16] = &v57[24 * v56];
                *(void *)&v152[24] = v66;
                *(void *)uint64_t v152 = v64.i64[0];
                sub_1002B4440((uint64_t)v152);
                *(void *)&uint8_t buf[8] = v65;
                if (SHIBYTE(v150) < 0) {
                  operator delete((void *)v149);
                }
              }
              else
              {
                long long v53 = v149;
                *(void *)(*(void *)&buf[8] + 16) = v150;
                *int v52 = v53;
                *(void *)&uint8_t buf[8] = (char *)v52 + 24;
              }
            }
          }
          memset(v141, 0, sizeof(v141));
          sub_1002B3390((char *)v141, *(long long **)buf, *(long long **)&buf[8], 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)&buf[8] - *(void *)buf) >> 3));
          __int16 v67 = v125;
          memset(v140, 0, sizeof(v140));
          uint64_t v68 = sub_1002B3390((char *)v140, v145, v146, 0xAAAAAAAAAAAAAAABLL * (((char *)v146 - (char *)v145) >> 3));
          char v69 = sub_10029E0C4((uint64_t)v68, v141, v140);
          *(void *)uint64_t v152 = v140;
          sub_100051568((void ***)v152);
          *(void *)uint64_t v152 = v141;
          sub_100051568((void ***)v152);
          if ((v69 & 1) == 0)
          {
            BOOL v70 = qword_100A19E38;
            if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
            {
              *(_WORD *)uint64_t v152 = 0;
              _os_log_impl((void *)&_mh_execute_header, v70, OS_LOG_TYPE_DEFAULT, "versionInfoEvent: New version information received", v152, 2u);
            }
            __int16 v71 = +[CBProductInfo productInfoWithProductID:*((unsigned int *)v12 + 20)];
            id v72 = [v71 flags];
            int v73 = v119;
            if ((v72 & 0x100000) == 0) {
              int v73 = 1;
            }
            if (v73 == 1)
            {

              goto LABEL_111;
            }
            uint64_t v137 = 0;
            uint64_t v138 = 0;
            uint64_t v139 = 0;
            sub_1002B3390((char *)&v137, *(long long **)buf, *(long long **)&buf[8], 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)&buf[8] - *(void *)buf) >> 3));
            if (0xAAAAAAAAAAAAAAABLL * ((v138 - v137) >> 3) < 4)
            {
              *(void *)uint64_t v152 = &v137;
              sub_100051568((void ***)v152);

LABEL_111:
              __int16 v67 = v125;
            }
            else
            {
              if (*(char *)(v137 + 95) < 0) {
                unint64_t v74 = *(void *)(v137 + 80);
              }
              else {
                unint64_t v74 = *(unsigned __int8 *)(v137 + 95);
              }
              BOOL v115 = v74 > 1;
              *(void *)uint64_t v152 = &v137;
              sub_100051568((void ***)v152);

              __int16 v67 = v125;
              if (v115)
              {
                uint64_t v116 = sub_100019878();
                v135[0] = _NSConcreteStackBlock;
                v135[1] = 3321888768;
                v135[2] = sub_10029E2FC;
                v135[3] = &unk_1009A12F0;
                v135[4] = v8;
                memset(v136, 0, sizeof(v136));
                sub_1002B3390(v136, *(long long **)buf, *(long long **)&buf[8], 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)&buf[8] - *(void *)buf) >> 3));
                sub_100013018(v116, v135);
                *(void *)uint64_t v152 = v136;
                sub_100051568((void ***)v152);
              }
            }
            memset(v134, 0, sizeof(v134));
            sub_1002B3390(v134, *(long long **)buf, *(long long **)&buf[8], 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)&buf[8] - *(void *)buf) >> 3));
            sub_10047FFCC(v8, (uint64_t)v134);
            *(void *)uint64_t v152 = v134;
            sub_100051568((void ***)v152);
            sub_10047FF14(v8, (uint64_t)buf);
          }
          if (qword_1009F8080 != -1) {
            dispatch_once(&qword_1009F8080, &stru_1009A1E50);
          }
          sub_1004A0B94((uint64_t)off_1009F8078, v8);
          int v75 = qword_100A19E38;
          if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
          {
            sub_100474E18(v8, &v149);
            int v76 = SHIBYTE(v150);
            __int16 v77 = (long long *)v149;
            BOOL v78 = sub_100480504(v8);
            char v79 = &v149;
            int v80 = *((_DWORD *)v12 + 20);
            if (v76 < 0) {
              char v79 = v77;
            }
            uint64_t v81 = "no";
            *(_DWORD *)uint64_t v152 = 136446978;
            *(void *)&v152[4] = v79;
            *(_WORD *)&v152[12] = 2082;
            if (v78) {
              uint64_t v81 = "yes";
            }
            *(void *)&v152[14] = v81;
            *(_WORD *)&v152[22] = 1024;
            *(_DWORD *)&v152[24] = v80;
            *(_WORD *)&v152[28] = 2082;
            *(void *)&v152[30] = v122;
            _os_log_impl((void *)&_mh_execute_header, v75, OS_LOG_TYPE_DEFAULT, "versionInfoEvent: Device %{public}s dev-fused: %{public}s pId: 0x%x FW version: %{public}s", v152, 0x26u);
            if (SHIBYTE(v150) < 0) {
              operator delete((void *)v149);
            }
          }
          if (strlen(v67 + 768) <= 1)
          {
            uint64_t v131 = 0;
            uint64_t v132 = 0;
            uint64_t v133 = 0;
            sub_1002B3390((char *)&v131, *(long long **)buf, *(long long **)&buf[8], 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)&buf[8] - *(void *)buf) >> 3));
            if (0xAAAAAAAAAAAAAAABLL * ((v132 - v131) >> 3) < 4
              || (*(char *)(v131 + 95) < 0 ? (unint64_t v82 = *(void *)(v131 + 80)) : (unint64_t v82 = *(unsigned __int8 *)(v131 + 95)),
                  v82 < 2))
            {
              uint64_t v83 = "?";
            }
            else
            {
              uint64_t v83 = (const char *)(*(void *)buf + 72);
              if (*(char *)(*(void *)buf + 95) < 0) {
                uint64_t v83 = *(const char **)v83;
              }
            }
            snprintf(v67 + 768, 0x100uLL, "%s", v83);
            *(void *)uint64_t v152 = &v131;
            sub_100051568((void ***)v152);
          }
          uint64_t v84 = sub_100017768();
          uint64_t v85 = (*(uint64_t (**)(uint64_t))(*(void *)v84 + 160))(v84);
          if (v85)
          {
            sub_100293198(v85, (uint64_t)v126);
            id v86 = objc_claimAutoreleasedReturnValue();
            __int16 v87 = (const char *)[v86 UTF8String];
            uint64_t v88 = v125;
            uint64_t v89 = fopen(v87, "w");
            if (v89)
            {
              fwrite("App Version Info Collected from Accessory Device\n\n", 0x32uLL, 1uLL, v89);
              fwrite("New Features Enabled: 1\n", 0x18uLL, 1uLL, v89);
              uint64_t v97 = (const char *)sub_10025B48C((uint64_t)v126, v90, v91, v92, v93, v94, v95, v96);
              fprintf(v89, "Device Bluetooth Address: %s\n", v97);
              fprintf(v89, "Device Product ID: %d\n", *((_DWORD *)v12 + 20));
              BOOL v98 = sub_100480504(v8);
              id v127 = v86;
              uint64_t v99 = "Prod-fused";
              if (v98) {
                uint64_t v99 = "Dev-fused";
              }
              fprintf(v89, "Fusing: %s\n\n", v99);
              unint64_t v100 = 0;
              uint64_t v101 = 8 * v124;
              do
              {
                int64_t v102 = strlen((const char *)v88);
                if (v100 == 32 && (int64_t v104 = v102, v102 >= 20))
                {
                  __chkstk_darwin(v102, v103);
                  __int16 v105 = (char *)&v117 - ((v104 + 9) & 0xFFFFFFFFFFFFFFF0);
                  if (v106 >= 4) {
                    size_t v107 = v104 - 9;
                  }
                  else {
                    size_t v107 = 0;
                  }
                  bzero(v105 + 3, v107);
                  *(_WORD *)__int16 v105 = *(_WORD *)((char *)v88 + 3);
                  v105[2] = *((unsigned char *)v88 + 5);
                  v105[3] = 46;
                  *((_WORD *)v105 + 2) = *((_WORD *)v88 + 3);
                  v105[6] = *((unsigned char *)v88 + 8);
                  v105[7] = 46;
                  *((_WORD *)v105 + 4) = *(_WORD *)((char *)v88 + 9);
                  v105[10] = *((unsigned char *)v88 + 11);
                  v105[11] = 126;
                  memcpy(v105 + 12, (char *)v88 + 19, v104 - 19);
                  v105[v104 - 7] = 0;
                  fprintf(v89, "%s: %s (%s)\n", off_1009FB0B8[0], (const char *)&v117 - ((v104 + 9) & 0xFFFFFFFFFFFFFFF0), (const char *)v88);
                }
                else
                {
                  fprintf(v89, "%s: %s\n", off_1009FB098[v100 / 8], (const char *)v88);
                }
                v100 += 8;
                v88 += 32;
              }
              while (v101 != v100);
              fclose(v89);
              id v86 = v127;
            }
            else
            {
              unsigned int v108 = qword_100A19E38;
              if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_ERROR))
              {
                __int16 v109 = __error();
                sub_10074FB08((uint64_t)v86, v109, (uint64_t)&v149, v108);
              }
            }
          }
          if (qword_1009F7EE0 != -1) {
            dispatch_once(&qword_1009F7EE0, &stru_1009A1EF0);
          }
          sub_1006C71A8();
          *(void *)uint64_t v152 = &v145;
          sub_100051568((void ***)v152);
          *(void *)uint64_t v152 = buf;
          sub_100051568((void ***)v152);
          LODWORD(v127) = 1;
        }
        else
        {
          LODWORD(v127) = 0;
        }
        uint64_t v32 = v123;
      }
      uint64_t v110 = &v12[v32];
      uint64_t v111 = v110[20];
      uint64_t v126 = v110 + 20;
      if (v111)
      {
        uint64_t v112 = qword_100A19E38;
        if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
        {
          sub_100474E18(v8, buf);
          uint64_t v113 = (buf[23] & 0x80u) == 0 ? buf : *(uint8_t **)buf;
          uint64_t v114 = v12[16];
          *(_DWORD *)uint64_t v152 = 136446722;
          *(void *)&v152[4] = v113;
          *(_WORD *)&v152[12] = 1024;
          *(_DWORD *)&v152[14] = v32;
          *(_WORD *)&v152[18] = 2112;
          *(void *)&v152[20] = v114;
          _os_log_impl((void *)&_mh_execute_header, v112, OS_LOG_TYPE_DEFAULT, "versionInfoEvent: Overwriting already existing version info for device %{public}s (index = %d); destroying o"
            "ld CoreAcc connection %@",
            v152,
            0x1Cu);
          if ((char)buf[23] < 0) {
            operator delete(*(void **)buf);
          }
        }
        sub_1002B01FC(v111);
        operator delete();
      }
      operator new();
    }
  }
  if ((v16 - 11) <= 1)
  {
    id v28 = [objc_alloc((Class)NSUUID) initWithUUIDBytes:v19];
    id v29 = [v28 UUIDString];
    char v30 = (const char *)[v29 UTF8String];
    strcpy(&v125[256 * v16], v30);

    v18 += 17;
    goto LABEL_43;
  }
  if (strnlen(v19, 0x100uLL) < 0x100)
  {
    uint64_t v31 = strcpy(&v125[256 * v16], v19);
    v18 += strlen(v31) + 1;
    goto LABEL_43;
  }
  if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_ERROR)) {
    sub_10074FB5C();
  }
  return sub_10003AFB4((uint64_t)v148);
}

void sub_10029DF2C(_Unwind_Exception *a1)
{
  *(void *)(v2 - 144) = v1;
  sub_100051568((void ***)(v2 - 144));
  *(void *)(v2 - 216) = v2 - 256;
  sub_100051568((void ***)(v2 - 216));
  *(void *)(v2 - 256) = v2 - 176;
  sub_100051568((void ***)(v2 - 256));
  sub_10003AFB4(v2 - 232);
  _Unwind_Resume(a1);
}

BOOL sub_10029E064(uint64_t a1, void *a2, unsigned int a3)
{
  if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(a2[1] - *a2) >> 3) <= a3) {
    return 0;
  }
  if (!a3) {
    return 1;
  }
  uint64_t v3 = *a2 + 24 * a3;
  if (*(char *)(v3 + 23) < 0) {
    unint64_t v4 = *(void *)(v3 + 8);
  }
  else {
    unint64_t v4 = *(unsigned __int8 *)(v3 + 23);
  }
  return v4 > 1;
}

uint64_t sub_10029E0C4(uint64_t a1, long long **a2, long long **a3)
{
  uint64_t v5 = *a2;
  uint64_t v6 = a2[1];
  if ((char *)v6 - (char *)v5 != (char *)a3[1] - (char *)*a3) {
    return 0;
  }
  if (v6 == v5) {
    return 1;
  }
  unint64_t v8 = 0;
  unint64_t v9 = 0xAAAAAAAAAAAAAAABLL * (((char *)v6 - (char *)v5) >> 3);
  while (1)
  {
    if (v8)
    {
      uint64_t v25 = 0;
      uint64_t v26 = 0;
      uint64_t v27 = 0;
      sub_1002B3390((char *)&v25, v5, v6, v9);
      if (0xAAAAAAAAAAAAAAABLL * ((v26 - v25) >> 3) <= v8
        || ((uint64_t v10 = v25 + 24 * v8, *(char *)(v10 + 23) < 0)
          ? (unint64_t v11 = *(void *)(v10 + 8))
          : (unint64_t v11 = *(unsigned __int8 *)(v10 + 23)),
            v11 < 2))
      {
        uint64_t v22 = 0;
        uint64_t v23 = 0;
        uint64_t v24 = 0;
        sub_1002B3390((char *)&v22, *a3, a3[1], 0xAAAAAAAAAAAAAAABLL * (((char *)a3[1] - (char *)*a3) >> 3));
        if (0xAAAAAAAAAAAAAAABLL * ((v23 - v22) >> 3) <= v8)
        {
          id v28 = (void **)&v22;
          sub_100051568(&v28);
          id v28 = (void **)&v25;
          sub_100051568(&v28);
          goto LABEL_32;
        }
        uint64_t v12 = v22 + 24 * v8;
        if (*(char *)(v12 + 23) < 0) {
          unint64_t v13 = *(void *)(v12 + 8);
        }
        else {
          unint64_t v13 = *(unsigned __int8 *)(v12 + 23);
        }
        id v28 = (void **)&v22;
        sub_100051568(&v28);
        id v28 = (void **)&v25;
        sub_100051568(&v28);
        if (v13 <= 1) {
          goto LABEL_32;
        }
      }
      else
      {
        id v28 = (void **)&v25;
        sub_100051568(&v28);
      }
      size_t v14 = (unsigned __int8 *)*a2 + 24 * v8;
      uint64_t v15 = (uint64_t)*a3 + 24 * v8;
      uint64_t v16 = v14[23];
      if ((v16 & 0x80u) == 0) {
        uint64_t v17 = v14[23];
      }
      else {
        uint64_t v17 = *((void *)v14 + 1);
      }
      uint64_t v18 = *(unsigned __int8 *)(v15 + 23);
      int v19 = (char)v18;
      if ((v18 & 0x80u) != 0) {
        uint64_t v18 = *(void *)(v15 + 8);
      }
      if (v17 != v18) {
        return 0;
      }
      if (v19 >= 0) {
        uint64_t v20 = (unsigned __int8 *)*a3 + 24 * v8;
      }
      else {
        uint64_t v20 = *(unsigned __int8 **)v15;
      }
      if ((v16 & 0x80) != 0)
      {
        if (memcmp(*(const void **)v14, v20, *((void *)v14 + 1))) {
          return 0;
        }
        goto LABEL_32;
      }
      if (v14[23]) {
        break;
      }
    }
LABEL_32:
    ++v8;
    uint64_t v5 = *a2;
    uint64_t v6 = a2[1];
    unint64_t v9 = 0xAAAAAAAAAAAAAAABLL * (((char *)v6 - (char *)*a2) >> 3);
    if (v9 <= v8) {
      return 1;
    }
  }
  while (*v14 == *v20)
  {
    ++v14;
    ++v20;
    if (!--v16) {
      goto LABEL_32;
    }
  }
  return 0;
}

void sub_10029E2E0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, uint64_t a15, void **a16)
{
  a16 = (void **)&a13;
  sub_100051568(&a16);
  _Unwind_Resume(a1);
}

void sub_10029E2FC(uint64_t a1)
{
  v13[0] = 0;
  v13[1] = 0;
  if (qword_1009F85C8 != -1) {
    dispatch_once(&qword_1009F85C8, &stru_1009A1F70);
  }
  uint64_t v2 = *(unsigned __int8 **)(a1 + 32);
  BOOL v3 = sub_1006F4674((uint64_t)off_1009F85C0, ((unint64_t)v2[128] << 40) | ((unint64_t)v2[129] << 32) | ((unint64_t)v2[130] << 24) | ((unint64_t)v2[131] << 16) | ((unint64_t)v2[132] << 8) | v2[133], (uint64_t)v13);
  unint64_t v4 = qword_100A19E38;
  if (v3)
  {
    if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v5 = *(void *)(a1 + 40);
      uint64_t v6 = (void *)(v5 + 72);
      if (*(char *)(v5 + 95) < 0) {
        uint64_t v6 = (void *)*v6;
      }
      int v11 = 136315138;
      uint64_t v12 = v6;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "versionInfoEvent: Setting key for %s", (uint8_t *)&v11, 0xCu);
    }
    if (qword_1009F85C8 != -1) {
      dispatch_once(&qword_1009F85C8, &stru_1009A1F70);
    }
    uint64_t v7 = *(void *)(a1 + 40);
    unint64_t v8 = (void *)(v7 + 72);
    if (*(char *)(v7 + 95) < 0) {
      unint64_t v8 = (void *)*v8;
    }
    unint64_t v9 = off_1009F85C0;
    uint64_t v10 = +[NSString stringWithUTF8String:v8];
    sub_1006F4198((uint64_t)v9, v10, (uint64_t)v13);
  }
  else if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_ERROR))
  {
    sub_10074FBC4();
  }
}

void sub_10029E4B0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

char *sub_10029E4C8(uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + 40) = 0;
  *(void *)(a1 + 48) = 0;
  uint64_t v2 = a1 + 40;
  *(void *)(v2 + 16) = 0;
  return sub_1002B3390((char *)v2, *(long long **)(a2 + 40), *(long long **)(a2 + 48), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a2 + 48) - *(void *)(a2 + 40)) >> 3));
}

void sub_10029E4F0(uint64_t a1)
{
  uint64_t v1 = (void **)(a1 + 40);
  sub_100051568(&v1);
}

void sub_10029E51C(uint64_t a1, int *a2, unsigned int a3, unsigned int a4, const UInt8 *a5)
{
  if (qword_1009F7F00 != -1) {
    dispatch_once(&qword_1009F7F00, &stru_1009A1E70);
  }
  int v18 = *a2;
  __int16 v19 = *((_WORD *)a2 + 2);
  uint64_t v10 = sub_1004AA194((uint64_t)off_1009F7EF8, (uint64_t)&v18, 1);
  if (v10)
  {
    uint64_t v11 = v10;
    for (uint64_t i = *(void ***)(a1 + 336); ; ++i)
    {
      if (i == *(void ***)(a1 + 344))
      {
        unint64_t v13 = qword_100A19E38;
        if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_ERROR)) {
          sub_10074FBF8(v11, v13);
        }
        return;
      }
      if (**i == v10) {
        break;
      }
    }
    if (a3 <= 0x1F && (uint64_t v14 = (*i)[a3 + 20]) != 0 && *(unsigned char *)(v14 + 97) && *(void *)(v14 + 88))
    {
      CFDataRef v15 = CFDataCreate(kCFAllocatorDefault, a5, a4);
      if ((acc_transportClient_processIncomingData() & 1) != 0
        || (uint64_t v16 = qword_100A19E38, !os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_ERROR)))
      {
        if (!v15) {
          return;
        }
        goto LABEL_17;
      }
      sub_10074FD18(v11, v16);
      if (v15) {
LABEL_17:
      }
        CFRelease(v15);
    }
    else
    {
      uint64_t v17 = qword_100A19E38;
      if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_ERROR)) {
        sub_10074FC88(v11, v17);
      }
    }
  }
}

void sub_10029E6C0(uint64_t a1, uint64_t a2, unsigned int a3, const UInt8 *a4)
{
  if (qword_1009F7F00 != -1) {
    dispatch_once(&qword_1009F7F00, &stru_1009A1E70);
  }
  LODWORD(__p[0]) = *(_DWORD *)a2;
  WORD2(__p[0]) = *(_WORD *)(a2 + 4);
  uint64_t v8 = sub_1004AA194((uint64_t)off_1009F7EF8, (uint64_t)__p, 1);
  if (v8)
  {
    uint64_t v9 = v8;
    for (uint64_t i = *(void *)(a1 + 336); ; i += 8)
    {
      if (i == *(void *)(a1 + 344))
      {
        uint64_t v11 = qword_100A19E38;
        if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_ERROR)) {
          sub_10074FDA8(v9, v11);
        }
        return;
      }
      if (**(void **)i == v8) {
        break;
      }
    }
    uint64_t v12 = qword_100A19E38;
    if (*(void *)(*(void *)i + 136))
    {
      if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
      {
        sub_100474E18(v9, __p);
        if (v17 >= 0) {
          unint64_t v13 = __p;
        }
        else {
          unint64_t v13 = (void **)__p[0];
        }
        *(_DWORD *)long long buf = 67109378;
        unsigned int v19 = a3;
        __int16 v20 = 2082;
        int v21 = v13;
        _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "authenticationDataEvent: Processing %d bytes received from device %{public}s", buf, 0x12u);
        if (v17 < 0) {
          operator delete(__p[0]);
        }
      }
      CFDataRef v14 = CFDataCreate(kCFAllocatorDefault, a4, a3);
      if ((acc_transportClient_processIncomingData() & 1) != 0
        || (CFDataRef v15 = qword_100A19E38, !os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_ERROR)))
      {
        if (!v14) {
          return;
        }
        goto LABEL_21;
      }
      sub_10074FEC8(v9, v15);
      if (v14) {
LABEL_21:
      }
        CFRelease(v14);
    }
    else if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_ERROR))
    {
      sub_10074FE38(v9, v12);
    }
  }
}

void sub_10029E8EC(uint64_t a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5, unsigned __int16 *a6)
{
  if (qword_1009F7F00 != -1) {
    dispatch_once(&qword_1009F7F00, &stru_1009A1E70);
  }
  *(_DWORD *)long long buf = *(_DWORD *)a2;
  *(_WORD *)int v21 = *(_WORD *)(a2 + 4);
  uint64_t v11 = sub_1004AA194((uint64_t)off_1009F7EF8, (uint64_t)buf, 1);
  if (v11)
  {
    uint64_t v12 = v11;
    unint64_t v13 = qword_100A19E38;
    if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
    {
      sub_100475EE0(v12, (uint64_t)__p);
      CFDataRef v14 = v19 >= 0 ? __p : (void **)__p[0];
      *(_DWORD *)long long buf = 136315906;
      *(void *)int v21 = v14;
      *(_WORD *)&v21[8] = 1024;
      int v22 = a3;
      __int16 v23 = 1024;
      int v24 = a4;
      __int16 v25 = 1024;
      int v26 = a5;
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "received setup command from device \"%s\", setupType = %d, opType = %d, pldLen = %d", buf, 0x1Eu);
      if (v19 < 0) {
        operator delete(__p[0]);
      }
    }
    if (a3 == 1)
    {
      if (a5 >= 2)
      {
        if (!a6) {
          sub_10014327C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Server/aacp/AACPClient.mm", 5464, "pldData");
        }
        CFDataRef v15 = qword_100A19E38;
        if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
        {
          int v16 = *a6;
          *(_DWORD *)long long buf = 67109376;
          *(_DWORD *)int v21 = a4;
          *(_WORD *)&v21[4] = 1024;
          *(_DWORD *)&v21[6] = v16;
          _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "received seal setup operation opType = %d uint64_t result = %d", buf, 0xEu);
        }
      }
      if (qword_1009F7EF0 != -1) {
        dispatch_once(&qword_1009F7EF0, &stru_1009A1E30);
      }
      sub_10045548C(off_1009F7EE8, v12, 1, a4, a5, a6);
    }
    else
    {
      char v17 = qword_100A19E38;
      if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)long long buf = 67109120;
        *(_DWORD *)int v21 = a3;
        _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "Unsupported setup xpc_type_t type = %d", buf, 8u);
      }
    }
  }
}

void sub_10029EB70(uint64_t a1, uint64_t a2, unsigned __int8 *a3)
{
  if (qword_1009F7F00 != -1) {
    dispatch_once(&qword_1009F7F00, &stru_1009A1E70);
  }
  *(_DWORD *)long long buf = *(_DWORD *)a2;
  LOWORD(v27) = *(_WORD *)(a2 + 4);
  uint64_t v5 = sub_1004AA194((uint64_t)off_1009F7EF8, (uint64_t)buf, 1);
  if (v5)
  {
    uint64_t v6 = qword_100A19E38;
    if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
    {
      int v7 = *a3;
      int v8 = *(unsigned __int16 *)(a3 + 1);
      int v9 = *(_DWORD *)(a3 + 3);
      int v10 = *(unsigned __int16 *)(a3 + 7);
      int v11 = a3[9];
      uint64_t v12 = *(void *)(a3 + 10);
      int v13 = *(_DWORD *)(a3 + 18);
      CFDataRef v14 = *(const char **)(a3 + 22);
      if (!v14) {
        CFDataRef v14 = "";
      }
      *(_DWORD *)long long buf = 67110914;
      int v27 = v7;
      __int16 v28 = 1024;
      int v29 = v8;
      __int16 v30 = 1024;
      int v31 = v9;
      __int16 v32 = 1024;
      int v33 = v10;
      __int16 v34 = 1024;
      int v35 = v11;
      __int16 v36 = 2048;
      uint64_t v37 = v12;
      __int16 v38 = 1024;
      int v39 = v13;
      __int16 v40 = 2082;
      int v41 = v14;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "caseInfoResponseEvent: messageVersion = %u, vendorID = %u, productID = %u, vendorIDSource = %u, caseColor = %u, caseVersion = %llu, reserved = %u, caseName = %{public}s", buf, 0x3Au);
    }
    char v15 = *a3;
    __int16 v16 = *(_WORD *)(a3 + 1);
    int v17 = *(_DWORD *)(a3 + 3);
    __int16 v18 = *(_WORD *)(a3 + 7);
    char v19 = a3[9];
    uint64_t v20 = *(void *)(a3 + 10);
    int v21 = *(_DWORD *)(a3 + 18);
    if (*(void *)(a3 + 22)) {
      int v22 = *(char **)(a3 + 22);
    }
    else {
      int v22 = "";
    }
    sub_10004191C(&__p, v22);
    sub_100480824(v5, v15, v16, v17, v18, v19, v20, v21, &__p);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
    if (sub_100487464(v5)) {
      uint64_t v23 = 0xFFFFLL;
    }
    else {
      uint64_t v23 = 65533;
    }
    sub_10028CD4C(a1, v5, 0xFFFFLL, v23);
    if (qword_1009F8080 != -1) {
      dispatch_once(&qword_1009F8080, &stru_1009A1E50);
    }
    sub_1004A1EF8((uint64_t)off_1009F8078, v5);
  }
}

void sub_10029EDD0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_10029EDF4(uint64_t a1, uint64_t a2, int a3, int a4, char *a5)
{
  if (qword_1009F7F00 != -1) {
    dispatch_once(&qword_1009F7F00, &stru_1009A1E70);
  }
  int v15 = *(_DWORD *)a2;
  LOWORD(v16) = *(_WORD *)(a2 + 4);
  uint64_t v9 = sub_1004AA194((uint64_t)off_1009F7EF8, (uint64_t)&v15, 1);
  if (v9)
  {
    uint64_t v10 = v9;
    int v11 = qword_100A19E38;
    if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
    {
      int v12 = *a5;
      int v15 = 67109632;
      int v16 = a3;
      __int16 v17 = 1024;
      int v18 = a4;
      __int16 v19 = 1024;
      int v20 = v12;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "deviceInfoEvent: devInfoType = %u, devInfoLen = %u, devInfoData=%d", (uint8_t *)&v15, 0x14u);
    }
    if (a3 == 1)
    {
      uint64_t v13 = sub_10048944C(v10, *a5);
      sub_10029EF88(v13, v10);
    }
    else
    {
      CFDataRef v14 = qword_100A19E38;
      if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
      {
        int v15 = 67109120;
        int v16 = a3;
        _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "Unsupported device info xpc_type_t type = %d", (uint8_t *)&v15, 8u);
      }
    }
  }
}

void sub_10029EF88(uint64_t a1, uint64_t a2)
{
  BOOL v3 = qword_100A19E38;
  if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
  {
    sub_100475EE0(a2, (uint64_t)__p);
    if (v10 >= 0) {
      unint64_t v4 = __p;
    }
    else {
      unint64_t v4 = (void **)__p[0];
    }
    *(_DWORD *)long long buf = 136315138;
    int v12 = v4;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Notify EU region bit change for device \"%s\"", buf, 0xCu);
    if (v10 < 0) {
      operator delete(__p[0]);
    }
  }
  uint64_t v5 = sub_1004AFA9C();
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 3221225472;
  _DWORD v8[2] = sub_1002A8AB8;
  void v8[3] = &unk_100997528;
  void v8[4] = a2;
  sub_100013018(v5, v8);
  uint64_t v6 = sub_1004AFB34();
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 3221225472;
  void v7[2] = sub_1002A8B30;
  void v7[3] = &unk_100997528;
  void v7[4] = a2;
  sub_100013018(v6, v7);
}

uint64_t sub_10029F104(uint64_t a1, uint64_t a2, unsigned int *a3, int a4, unsigned __int8 *a5)
{
  uint64_t v9 = *a5;
  if (qword_1009F7F00 != -1) {
    dispatch_once(&qword_1009F7F00, &stru_1009A1E70);
  }
  int v22 = *(_DWORD *)a2;
  LOWORD(v23) = *(_WORD *)(a2 + 4);
  uint64_t result = sub_1004AA194((uint64_t)off_1009F7EF8, (uint64_t)&v22, 1);
  if (result)
  {
    uint64_t v11 = result;
    int v12 = qword_100A19E38;
    if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v20 = sub_10025B48C(a2, v13, v14, v15, v16, v17, v18, v19);
      int v21 = "Unknown";
      int v22 = 136315650;
      uint64_t v23 = v20;
      if (v9 == 1) {
        int v21 = "Audio Arbitration";
      }
      __int16 v24 = 2080;
      __int16 v25 = v21;
      __int16 v26 = 1024;
      int v27 = a4 - 1;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "Receive relay message from device \"%s\", relayMessageType -> %s, relayMessageLen -> %d", (uint8_t *)&v22, 0x1Cu);
    }
    if (qword_1009F7EF0 != -1) {
      dispatch_once(&qword_1009F7EF0, &stru_1009A1E30);
    }
    return sub_100455490((uint64_t)off_1009F7EE8, v11, a3, v9, (unsigned __int16)(a4 - 1), (uint64_t)(a5 + 1));
  }
  return result;
}

uint64_t sub_10029F2AC(uint64_t a1, uint64_t a2, int a3, int a4, int a5, int a6, char *a7, unsigned int a8, char *__src)
{
  v27[0] = 0;
  v27[1] = 0;
  sub_10003AED0((uint64_t)v27, a1 + 360);
  if (qword_1009F7F00 != -1) {
    dispatch_once(&qword_1009F7F00, &stru_1009A1E70);
  }
  *(_DWORD *)long long buf = *(_DWORD *)a2;
  LOWORD(v29) = *(_WORD *)(a2 + 4);
  uint64_t v17 = sub_1004AA194((uint64_t)off_1009F7EF8, (uint64_t)buf, 1);
  if (!v17 || (uint64_t v18 = *(void ***)(a1 + 336), v19 = *(void ***)(a1 + 344), v18 == v19))
  {
LABEL_7:
    int v21 = qword_100A19E38;
    if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
    {
      if (a7[23] < 0) {
        a7 = *(char **)a7;
      }
      *(_DWORD *)long long buf = 67110402;
      int v29 = a3;
      __int16 v30 = 1024;
      int v31 = a4;
      __int16 v32 = 1024;
      int v33 = a5;
      __int16 v34 = 1024;
      int v35 = a6;
      __int16 v36 = 2080;
      uint64_t v37 = a7;
      __int16 v38 = 1024;
      unsigned int v39 = a8;
      _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "AACPClient::getCertificatesResponseEvent (not handled, connection is gone) - certSeqNum == %d, responseInfo == %d, endpointType == %d, serialNumberLength == %d, serialNumber == %s, certificateLength == %d", buf, 0x2Au);
    }
  }
  else
  {
    while (1)
    {
      uint64_t v20 = *v18;
      if (**v18 == v17) {
        break;
      }
      if (++v18 == v19) {
        goto LABEL_7;
      }
    }
    int v22 = qword_100A19E38;
    if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v23 = a7;
      if (a7[23] < 0) {
        uint64_t v23 = *(char **)a7;
      }
      *(_DWORD *)long long buf = 67110402;
      int v29 = a3;
      __int16 v30 = 1024;
      int v31 = a4;
      __int16 v32 = 1024;
      int v33 = a5;
      __int16 v34 = 1024;
      int v35 = a6;
      __int16 v36 = 2080;
      uint64_t v37 = v23;
      __int16 v38 = 1024;
      unsigned int v39 = a8;
      _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "AACPClient::getCertificatesResponseEvent - certSeqNum == %d, responseInfo == %d, endpointType == %d, serialNumberLength == %d, serialNumber == %s, certificateLength == %d", buf, 0x2Au);
    }
    if (a7[23] < 0)
    {
      sub_10003B098(__p, *(void **)a7, *((void *)a7 + 1));
    }
    else
    {
      *(_OWORD *)std::string __p = *(_OWORD *)a7;
      uint64_t v26 = *((void *)a7 + 2);
    }
    sub_10029F588((uint64_t)v20, (int *)a2, a3, a4, a5, a6, (int)__p, a8, __src);
    if (SHIBYTE(v26) < 0) {
      operator delete(__p[0]);
    }
  }
  return sub_10003AFB4((uint64_t)v27);
}

void sub_10029F550(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, char a18)
{
}

uint64_t sub_10029F588(uint64_t a1, int *a2, int a3, int a4, int a5, int a6, int a7, unsigned int a8, char *__src)
{
  v19[0] = 0;
  v19[1] = 0;
  sub_10003AED0((uint64_t)v19, a1 + 536);
  if (*(unsigned char *)(a1 + 528))
  {
    int v14 = *(_DWORD *)(a1 + 532);
    goto LABEL_3;
  }
  if (a3)
  {
    int v14 = *(_DWORD *)(a1 + 532);
    if (v14 != -1)
    {
LABEL_3:
      if (v14 == a3)
      {
        if (!a3) {
          operator new();
        }
        sub_1000119B0(*(void *)(*(void *)(a1 + 512) - 8), *(char **)(*(void *)(*(void *)(a1 + 512) - 8) + 8), __src, &__src[a8], a8);
        switch(a4)
        {
          case 2:
            *(unsigned char *)(a1 + 528) = 0;
            *(_DWORD *)(a1 + 532) = -1;
            sub_1002A9874(a1);
            uint64_t v15 = sub_100050530();
            int v17 = *a2;
            __int16 v18 = *((_WORD *)a2 + 2);
            (*(void (**)(uint64_t, int *, uint64_t, void))(*(void *)v15 + 368))(v15, &v17, 3, 0);
            break;
          case 1:
            *(unsigned char *)(a1 + 528) = 1;
            *(_DWORD *)(a1 + 532) = 0;
            break;
          case 0:
            *(unsigned char *)(a1 + 528) = 0;
            ++*(_DWORD *)(a1 + 532);
            break;
        }
      }
      else if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_ERROR))
      {
        sub_10074FF8C();
      }
      goto LABEL_19;
    }
  }
  if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_ERROR)) {
    sub_10074FF58();
  }
LABEL_19:
  sub_10003AFE8((uint64_t)v19);
  return sub_10003AFB4((uint64_t)v19);
}

void sub_10029F868(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, char a18)
{
}

uint64_t sub_10029F8BC(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  v16[0] = 0;
  v16[1] = 0;
  sub_10003AED0((uint64_t)v16, a1 + 360);
  if (qword_1009F7F00 != -1) {
    dispatch_once(&qword_1009F7F00, &stru_1009A1E70);
  }
  LODWORD(__p) = *(_DWORD *)a2;
  WORD2(__p) = *(_WORD *)(a2 + 4);
  uint64_t v7 = sub_1004AA194((uint64_t)off_1009F7EF8, (uint64_t)&__p, 1);
  if (a4 == 1)
  {
    int v8 = *(unsigned char **)a3;
    if (*(void *)(a3 + 8) - *(void *)a3 == 1)
    {
      uint64_t v9 = v7;
      char v10 = operator new(3uLL);
      int v14 = v10 + 3;
      uint64_t v15 = v10 + 3;
      *(_WORD *)char v10 = 0;
      void v10[2] = 0;
      std::string __p = v10;
      uint64_t v11 = qword_100A19E38;
      if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)long long buf = 134218240;
        uint64_t v18 = 1;
        __int16 v19 = 1024;
        int v20 = 1;
        _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "AACPClient::getGyroInformationMessageEvent - received gyroInfoDataLength: %lu, gyroInfoVersion: %u", buf, 0x12u);
        int v8 = *(unsigned char **)a3;
      }
      *char v10 = 1;
      v10[1] = (*v8 & 4) != 0;
      void v10[2] = *v8 & 1;
      sub_100477CA4(v9, (char **)&__p);
      if (__p)
      {
        int v14 = __p;
        operator delete(__p);
      }
    }
    else if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_ERROR))
    {
      sub_10074FFF4();
    }
  }
  else if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_ERROR))
  {
    sub_100750060();
  }
  return sub_10003AFB4((uint64_t)v16);
}

void sub_10029FAC0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12, char a13)
{
  if (__p) {
    operator delete(__p);
  }
  sub_10003AFB4((uint64_t)&a13);
  _Unwind_Resume(a1);
}

uint64_t sub_10029FAF8(uint64_t a1, uint64_t a2, unsigned int a3, unint64_t a4, unsigned int a5, void *a6)
{
  v37[0] = 0;
  v37[1] = 0;
  sub_10003AED0((uint64_t)v37, a1 + 360);
  if (a3 < 2)
  {
    uint64_t v9 = +[NSDate date];
    [v9 timeIntervalSince1970];
    double v11 = v10;

    unsigned int v12 = (61681 * a5) >> 20;
    uint64_t v13 = qword_100A19E38;
    if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 67109120;
      unsigned int v39 = (61681 * a5) >> 20;
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "AACPClient::getBTEventHistoryListMessageEvent - Last %u BT Events \n", buf, 8u);
    }
    if (a5 >= 0x11)
    {
      uint64_t v14 = 0;
      if (v12 <= 1) {
        uint64_t v15 = 1;
      }
      else {
        uint64_t v15 = v12;
      }
      uint64_t v16 = v15 + 16 * v15;
      int v17 = 1;
      while (v14 + 17 <= (unint64_t)a5)
      {
        memset(v36, 0, 17);
        uint64_t v18 = *a6 + v14;
        char v19 = *(unsigned char *)(v18 + 16);
        v36[0] = *(_OWORD *)v18;
        LOBYTE(v36[1]) = v19;
        __int16 v35 = 0;
        int v34 = 0;
        uint64_t v20 = sub_100008A18((uint64_t)&v34, (uint64_t)v36 + 8, 6uLL);
        int v21 = sub_10029FDF0(v11, v20, a4, *(unint64_t *)&v36[0]);
        int v22 = sub_10029FEFC((uint64_t)v21, BYTE14(v36[0]), *(unsigned __int16 *)((char *)v36 + 15));
        uint64_t v30 = sub_10025B48C((uint64_t)&v34, v23, v24, v25, v26, v27, v28, v29);
        int v31 = qword_100A19E38;
        if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)long long buf = 67109891;
          unsigned int v39 = v17;
          __int16 v40 = 2112;
          int v41 = v21;
          __int16 v42 = 2081;
          uint64_t v43 = v30;
          __int16 v44 = 2112;
          uint64_t v45 = v22;
          _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_DEFAULT, "BTEventHistory: %2d. Time: %@, BT Addr: %{private}s, Event: %@", buf, 0x26u);
        }

        v14 += 17;
        ++v17;
        if (v16 == v14) {
          return sub_10003AFB4((uint64_t)v37);
        }
      }
      if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_ERROR)) {
        sub_100750130();
      }
    }
  }
  else if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_ERROR))
  {
    sub_1007500C8();
  }
  return sub_10003AFB4((uint64_t)v37);
}

void sub_10029FDA8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);

  sub_10003AFB4((uint64_t)va);
  _Unwind_Resume(a1);
}

id sub_10029FDF0(double a1, uint64_t a2, unint64_t a3, unint64_t a4)
{
  id v4 = [objc_alloc((Class)NSDate) initWithTimeIntervalSince1970:a1 - (double)a3 / 1000000.0 + (double)a4 / 1000000.0];
  id v5 = objc_alloc_init((Class)NSDateFormatter);
  [v5 setDateFormat:@"yyyy-MM-dd HH:mm:ss.SSS zzz"];
  uint64_t v6 = [v5 stringFromDate:v4];
  uint64_t v7 = +[NSString stringWithFormat:@"%@", v6];

  return v7;
}

void sub_10029FED0(_Unwind_Exception *a1)
{
  id v4 = v3;

  _Unwind_Resume(a1);
}

id sub_10029FEFC(uint64_t a1, unsigned int a2, unsigned int a3)
{
  switch(a2)
  {
    case 1u:
      if (a3 == 2)
      {
        +[NSString stringWithFormat:@"Connect,        Direction: Source initiated, Status %u", 2, v5];
      }
      else if (a3 == 1)
      {
        +[NSString stringWithFormat:@"Connect,        Direction: Accessory initiated, Status %u", 1, v5];
      }
      else
      {
        +[NSString stringWithFormat:@"Connect,        Invalid direction: %u", a3, v5];
      }
      break;
    case 2u:
      +[NSString stringWithFormat:@"Disconnect,     Reason: %u", a3, v5];
      break;
    case 3u:
      +[NSString stringWithFormat:@"Pairing,        Status: %u", a3, v5];
      break;
    case 4u:
      +[NSString stringWithFormat:@"Unpairing,      Status: %u", a3, v5];
      break;
    case 5u:
      +[NSString stringWithFormat:@"UTP Connect,    Status: %u", a3, v5];
      break;
    case 6u:
      +[NSString stringWithFormat:@"UTP Disconnect, Reason: %u", a3, v5];
      break;
    case 7u:
      +[NSString stringWithFormat:@"LE Connect,     Status: %u", a3, v5];
      break;
    case 8u:
      +[NSString stringWithFormat:@"LE Disconnect,  Reason: %u", a3, v5];
      break;
    case 9u:
      +[NSString stringWithFormat:@"Connect,        Accessory Initiated, Status: %u", a3, v5];
      break;
    case 0xAu:
      +[NSString stringWithFormat:@"Connect,        Source Initiated, Status: %u", a3, v5];
      break;
    default:
      +[NSString stringWithFormat:@"Unknown: %X,    Status: %u", a2, a3];
      break;
  BOOL v3 = };

  return v3;
}

uint64_t sub_1002A00F8(uint64_t a1, uint64_t a2, void *a3)
{
  v12[0] = 0;
  v12[1] = 0;
  sub_10003AED0((uint64_t)v12, a1 + 360);
  if (qword_1009F7F00 != -1) {
    dispatch_once(&qword_1009F7F00, &stru_1009A1E70);
  }
  LODWORD(__p[0]) = *(_DWORD *)a2;
  WORD2(__p[0]) = *(_WORD *)(a2 + 4);
  uint64_t v5 = sub_1004AA194((uint64_t)off_1009F7EF8, (uint64_t)__p, 1);
  if (v5)
  {
    uint64_t v6 = a3[1] - *a3;
    uint64_t v7 = qword_100A19E38;
    if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
    {
      sub_100474E18(v5, __p);
      int v8 = v11 >= 0 ? __p : (void **)__p[0];
      *(_DWORD *)long long buf = 136446466;
      uint64_t v14 = v8;
      __int16 v15 = 1024;
      int v16 = (unsigned __int16)v6;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "Conversation Detect Message Received from device \"%{public}s\", len -> %u", buf, 0x12u);
      if (v11 < 0) {
        operator delete(__p[0]);
      }
    }
    if (qword_1009F7EF0 != -1) {
      dispatch_once(&qword_1009F7EF0, &stru_1009A1E30);
    }
    sub_100455514(off_1009F7EE8, v5, (unsigned __int16)v6, *a3);
  }
  return sub_10003AFB4((uint64_t)v12);
}

void sub_1002A02A4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  sub_10003AFB4((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1002A02C8(uint64_t a1, uint64_t a2, uint64_t a3, unsigned __int8 **a4)
{
  v22[0] = 0;
  v22[1] = 0;
  sub_10003AED0((uint64_t)v22, a1 + 360);
  if (qword_1009F7F00 != -1) {
    dispatch_once(&qword_1009F7F00, &stru_1009A1E70);
  }
  *(_DWORD *)long long buf = *(_DWORD *)a2;
  LOWORD(v24) = *(_WORD *)(a2 + 4);
  uint64_t v7 = sub_1004AA194((uint64_t)off_1009F7EF8, (uint64_t)buf, 1);
  uint64_t v8 = (uint64_t)*a4;
  int v9 = **a4;
  if (v9 == 1)
  {
    uint64_t v13 = *(unsigned __int8 *)(v8 + 1);
    uint64_t v14 = *(unsigned __int8 *)(v8 + 2);
    uint64_t v15 = *(unsigned __int8 *)(v8 + 3);
    uint64_t v16 = *(unsigned __int16 *)(v8 + 4);
    uint64_t v17 = *(unsigned __int16 *)(v8 + 6);
    uint64_t v18 = qword_100A19E38;
    if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 67110144;
      int v24 = v13;
      __int16 v25 = 1024;
      int v26 = v14;
      __int16 v27 = 1024;
      int v28 = v15;
      __int16 v29 = 1024;
      int v30 = v16;
      __int16 v31 = 1024;
      int v32 = v17;
      _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "AACPClient::adaptiveVolumeMessageRecvEvent: setAdaptiveVolumeRequestTargets media: %u, telephony: %u, voiceCommand: %u, rampUpRate: %u ms, rampDownRate: %u ms", buf, 0x20u);
    }
    char v19 = sub_1002A05C4(a1, v13 | (v14 << 8) | (v15 << 16) | (v16 << 24) | (v17 << 40));
    if (qword_1009F8418 != -1) {
      dispatch_once(&qword_1009F8418, &stru_1009A1E10);
    }
    sub_1004146DC((void *)qword_1009F8410, v7, v19);
  }
  else if (v9 == 4)
  {
    int v10 = *(unsigned __int8 *)(v8 + 1);
    char v11 = qword_100A19E38;
    if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
    {
      int v12 = *(unsigned __int8 *)(v8 + 2);
      *(_DWORD *)long long buf = 67109376;
      int v24 = v10;
      __int16 v25 = 1024;
      int v26 = v12;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "AACPClient::adaptiveVolumeMessageRecvEvent: setDRC mode: %u, version: %u", buf, 0xEu);
    }
    if (qword_1009F8418 != -1) {
      dispatch_once(&qword_1009F8418, &stru_1009A1E10);
    }
    sub_10041477C((void *)qword_1009F8410, v7, v10 == 1);
  }
  else
  {
    uint64_t v20 = qword_100A19E38;
    if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "AACPClient::adaptiveVolumeMessageRecvEvent: invalid message type", buf, 2u);
    }
  }
  return sub_10003AFB4((uint64_t)v22);
}

void sub_1002A0594(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  sub_10003AFB4((uint64_t)&a9);
  _Unwind_Resume(a1);
}

id sub_1002A05C4(uint64_t a1, unint64_t a2)
{
  v15[0] = 0;
  v15[1] = 0;
  sub_10003AED0((uint64_t)v15, a1 + 360);
  id v3 = objc_alloc_init((Class)NSMutableDictionary);
  *(float *)&double v4 = (float)a2 / 100.0;
  uint64_t v5 = +[NSNumber numberWithFloat:v4];
  [v3 setObject:v5 forKey:@"kCBMsgArgParamAutoVolumeMediaTarget"];
  *(float *)&double v6 = (float)BYTE1(a2) / 100.0;
  uint64_t v7 = +[NSNumber numberWithFloat:v6];
  [v3 setObject:v7 forKey:@"kCBMsgArgParamAutoVolumeTelephonyTarget"];
  *(float *)&double v8 = (float)BYTE2(a2) / 100.0;
  int v9 = +[NSNumber numberWithFloat:v8];
  [v3 setObject:v9 forKey:@"kCBMsgArgParamAutoVolumeVoiceTarget"];
  *(float *)&double v10 = (float)(unsigned __int16)(a2 >> 24);
  char v11 = +[NSNumber numberWithFloat:v10];
  [v3 setObject:v11 forKey:@"kCBMsgArgParamAutoVolumeRampUpRate"];
  *(float *)&double v12 = (float)(unsigned __int16)(HIDWORD(a2) >> 8);
  uint64_t v13 = +[NSNumber numberWithFloat:v12];
  [v3 setObject:v13 forKey:@"kCBMsgArgParamAutoVolumeRampDownRate"];

  sub_10003AFB4((uint64_t)v15);

  return v3;
}

void sub_1002A0768(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  uint64_t v15 = v12;

  sub_10003AFB4((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void sub_1002A07C8()
{
}

void sub_1002A07D0()
{
}

uint64_t sub_1002A07D8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v8[0] = 0;
  v8[1] = 0;
  sub_10003AED0((uint64_t)v8, a1 + 360);
  if (qword_1009F7F00 != -1) {
    dispatch_once(&qword_1009F7F00, &stru_1009A1E70);
  }
  *(_DWORD *)long long buf = *(_DWORD *)a2;
  LOWORD(v10) = *(_WORD *)(a2 + 4);
  uint64_t v5 = sub_1004AA194((uint64_t)off_1009F7EF8, (uint64_t)buf, 1);
  double v6 = qword_100A19E38;
  if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 134217984;
    uint64_t v10 = a3;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "Prox Card Status: Received Prox Card Features: 0x%llx", buf, 0xCu);
  }
  sub_100477DB4(v5, a3);
  return sub_10003AFB4((uint64_t)v8);
}

void sub_1002A08FC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_1002A091C(uint64_t a1, uint64_t a2, int a3, unsigned __int8 **a4)
{
  switch(a3)
  {
    case 0:
      uint64_t v6 = qword_100A19E38;
      if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
      {
        int v7 = (*a4)[8];
        int v8 = (char)(*a4)[7];
        int v9 = (*a4)[6];
        int v10 = (*a4)[5];
        int v11 = (*a4)[4];
        int v12 = (*a4)[3];
        int v13 = *(unsigned __int16 *)(*a4 + 1);
        int v14 = **a4;
        int v35 = 67110912;
        int v36 = v14;
        __int16 v37 = 1024;
        int v38 = v13;
        __int16 v39 = 1024;
        int v40 = v12;
        __int16 v41 = 1024;
        int v42 = v11;
        __int16 v43 = 1024;
        int v44 = v10;
        __int16 v45 = 1024;
        int v46 = v9;
        __int16 v47 = 1024;
        int v48 = v8;
        __int16 v49 = 1024;
        int v50 = v7;
        uint64_t v15 = "PerfStats: Connection Record | Direction: %u, Baseband time: %u, BBFC Scan Req Received: %u, Num 2.4G conn"
              "ections: %u, Num hrb connections: %u, UTP state: %u, RSSI: %u, Audio state: %u";
        uint64_t v16 = v6;
        uint32_t v17 = 50;
        goto LABEL_13;
      }
      break;
    case 1:
      uint64_t v19 = qword_100A19E38;
      if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
      {
        int v20 = *(unsigned __int16 *)(*a4 + 9);
        int v21 = *(unsigned __int16 *)(*a4 + 7);
        int v22 = *(unsigned __int16 *)(*a4 + 5);
        int v23 = *(unsigned __int16 *)(*a4 + 3);
        int v24 = *(unsigned __int16 *)(*a4 + 1);
        int v25 = **a4;
        int v35 = 67110400;
        int v36 = v25;
        __int16 v37 = 1024;
        int v38 = v24;
        __int16 v39 = 1024;
        int v40 = v23;
        __int16 v41 = 1024;
        int v42 = v22;
        __int16 v43 = 1024;
        int v44 = v21;
        __int16 v45 = 1024;
        int v46 = v20;
        uint64_t v15 = "PerfStats: Boot time Record | Boot type: %u, Boot time total: %u, Boot time end: %u, Boot time nvram init:"
              " %u, Boot time core loading: %u, UTP setup time: %u";
        uint64_t v16 = v19;
        uint32_t v17 = 38;
        goto LABEL_13;
      }
      break;
    case 2:
      uint64_t v26 = qword_100A19E38;
      if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
      {
        int v27 = *((unsigned __int16 *)*a4 + 3);
        int v28 = *((unsigned __int16 *)*a4 + 2);
        int v29 = *((unsigned __int16 *)*a4 + 1);
        int v30 = *(unsigned __int16 *)*a4;
        int v35 = 67109888;
        int v36 = v30;
        __int16 v37 = 1024;
        int v38 = v29;
        __int16 v39 = 1024;
        int v40 = v28;
        __int16 v41 = 1024;
        int v42 = v27;
        uint64_t v15 = "PerfStats: A2dp Record | AM setup: %u, DSP setup: %u, UTP config: %u, Snoop setup: %u";
        goto LABEL_12;
      }
      break;
    case 3:
      uint64_t v26 = qword_100A19E38;
      if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
      {
        int v31 = *((unsigned __int16 *)*a4 + 3);
        int v32 = *((unsigned __int16 *)*a4 + 2);
        int v33 = *((unsigned __int16 *)*a4 + 1);
        int v34 = *(unsigned __int16 *)*a4;
        int v35 = 67109888;
        int v36 = v34;
        __int16 v37 = 1024;
        int v38 = v33;
        __int16 v39 = 1024;
        int v40 = v32;
        __int16 v41 = 1024;
        int v42 = v31;
        uint64_t v15 = "PerfStats: Sco Record | AM setup: %u, DSP setup: %u, UTP config: %u, Snoop setup: %u";
LABEL_12:
        uint64_t v16 = v26;
        uint32_t v17 = 26;
        goto LABEL_13;
      }
      break;
    default:
      uint64_t v18 = qword_100A19E38;
      if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
      {
        int v35 = 67109120;
        int v36 = a3;
        uint64_t v15 = "Invalid subtype %d";
        uint64_t v16 = v18;
        uint32_t v17 = 8;
LABEL_13:
        _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, v15, (uint8_t *)&v35, v17);
      }
      break;
  }
}

uint64_t sub_1002A0C30(uint64_t a1, unsigned __int8 *a2, uint64_t a3, uint64_t a4)
{
  v10[0] = 0;
  v10[1] = 0;
  sub_10003AED0((uint64_t)v10, a1 + 360);
  if (qword_1009F7EE0 != -1) {
    dispatch_once(&qword_1009F7EE0, &stru_1009A1EF0);
  }
  sub_1006C0414((uint64_t)off_1009F7ED8, a2, v11);
  int v7 = sub_100031234(v11);
  uint64_t v8 = sub_100373068();
  (*(void (**)(uint64_t, void *, uint64_t, uint64_t))(*(void *)v8 + 192))(v8, v7, a3, a4);

  return sub_10003AFB4((uint64_t)v10);
}

void sub_1002A0D30(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);

  sub_10003AFB4((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1002A0D58(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  v13[0] = 0;
  v13[1] = 0;
  sub_10003AED0((uint64_t)v13, a1 + 360);
  if (sub_100294BC0(a1, a2))
  {
    if (qword_1009F7F00 != -1) {
      dispatch_once(&qword_1009F7F00, &stru_1009A1E70);
    }
    LODWORD(__p[0]) = *(_DWORD *)a2;
    WORD2(__p[0]) = *(_WORD *)(a2 + 4);
    uint64_t v6 = sub_1004AA194((uint64_t)off_1009F7EF8, (uint64_t)__p, 1);
    if (v6)
    {
      uint64_t v7 = a3[1] - *a3;
      uint64_t v8 = qword_100A19E38;
      if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
      {
        sub_100474E18(v6, __p);
        int v9 = v12 >= 0 ? __p : (void **)__p[0];
        *(_DWORD *)long long buf = 136446466;
        uint64_t v15 = v9;
        __int16 v16 = 1024;
        int v17 = (unsigned __int16)v7;
        _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "Multimodal Context Message Received from device \"%{public}s\", len -> %u", buf, 0x12u);
        if (v12 < 0) {
          operator delete(__p[0]);
        }
      }
      if (qword_1009F7EF0 != -1) {
        dispatch_once(&qword_1009F7EF0, &stru_1009A1E30);
      }
      sub_100451C98((uint64_t)off_1009F7EE8, v6, (unsigned __int16)v7, *a3);
    }
  }
  else if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_ERROR))
  {
    sub_100750164();
  }
  return sub_10003AFB4((uint64_t)v13);
}

void sub_1002A0F40(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  sub_10003AFB4((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1002A0F64(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  v15[0] = 0;
  v15[1] = 0;
  sub_10003AED0((uint64_t)v15, a1 + 360);
  if (qword_1009F7F00 != -1) {
    dispatch_once(&qword_1009F7F00, &stru_1009A1E70);
  }
  *(_DWORD *)long long buf = *(_DWORD *)a2;
  LOWORD(v17) = *(_WORD *)(a2 + 4);
  uint64_t v6 = sub_1004AA194((uint64_t)off_1009F7EF8, (uint64_t)buf, 1);
  if (v6)
  {
    uint64_t v7 = (unsigned __int8 *)*a4;
    uint64_t v8 = a4[1] - *a4;
    int v9 = qword_100A19E38;
    if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
    {
      int v10 = *v7;
      sub_100474E18(v6, __p);
      int v11 = v14 >= 0 ? __p : (void **)__p[0];
      *(_DWORD *)long long buf = 67109634;
      int v17 = v10;
      __int16 v18 = 2082;
      uint64_t v19 = v11;
      __int16 v20 = 1024;
      int v21 = (unsigned __int16)v8;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "PME Config Message, subtype %d received from device \"%{public}s\", len -> %u", buf, 0x18u);
      if (v14 < 0) {
        operator delete(__p[0]);
      }
    }
    if (qword_1009F7EF0 != -1) {
      dispatch_once(&qword_1009F7EF0, &stru_1009A1E30);
    }
    sub_100452038((uint64_t)off_1009F7EE8, v6, (unsigned __int16)v8, *a4);
  }
  return sub_10003AFB4((uint64_t)v15);
}

void sub_1002A1120(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  sub_10003AFB4((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1002A1144(uint64_t a1, uint64_t a2, int a3, uint64_t *a4)
{
  v39[0] = 0;
  v39[1] = 0;
  sub_10003AED0((uint64_t)v39, a1 + 360);
  uint64_t v8 = sub_100294BC0(a1, a2);
  int v9 = qword_100A19E38;
  if (v8)
  {
    uint64_t v34 = a2;
    int v35 = v8;
    if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v10 = (a4[1] - *a4) >> 3;
      *(_DWORD *)long long buf = 67109376;
      int v41 = a3;
      __int16 v42 = 2048;
      uint64_t v43 = v10;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "tipiTableEvent: Setting state %d and table of size %zu", buf, 0x12u);
    }
    char v36 = a3;
    uint64_t v12 = *a4;
    uint64_t v11 = a4[1];
    if (v11 != *a4)
    {
      unint64_t v13 = 0;
      char v14 = qword_100A19E38;
      do
      {
        if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v22 = sub_10025B48C(v12 + 8 * v13, v15, v16, v17, v18, v19, v20, v21);
          uint64_t v23 = *a4 + 8 * v13;
          int v24 = *(unsigned __int8 *)(v23 + 6);
          LODWORD(v23) = *(unsigned __int8 *)(v23 + 7);
          *(_DWORD *)long long buf = 67109891;
          int v41 = v13 + 1;
          __int16 v42 = 2081;
          uint64_t v43 = v22;
          __int16 v44 = 1024;
          int v45 = v24;
          __int16 v46 = 1024;
          int v47 = v23;
          _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "tipiTableEvent:   Entry %d: addr %{private}s, connectionStatus %u, stateFlags 0x%02x", buf, 0x1Eu);
          char v14 = qword_100A19E38;
          ++v13;
          uint64_t v12 = *a4;
          uint64_t v11 = a4[1];
        }
        else
        {
          ++v13;
        }
      }
      while (v13 < (v11 - v12) >> 3);
    }
    *((unsigned char *)v35 + 729) = v36;
    sub_100040550(&__p, (uint64_t)a4);
    if (v35 + 92 != (uint64_t *)&__p) {
      sub_1002B5F74((char *)v35 + 736, (char *)__p, (uint64_t)v38, (v38 - (unsigned char *)__p) >> 3);
    }
    if (__p)
    {
      int v38 = __p;
      operator delete(__p);
    }
    sub_10003AFE8((uint64_t)v39);
    id v25 = objc_alloc_init((Class)CBDevice);
    id v26 = [objc_alloc((Class)NSData) initWithBytes:v34 length:6];
    [v25 setBtAddressData:v26];

    id v27 = objc_alloc_init((Class)NSMutableArray);
    uint64_t v29 = *a4;
    uint64_t v28 = a4[1];
    while (v29 != v28)
    {
      id v30 = objc_alloc_init((Class)CBDevice);
      id v31 = [objc_alloc((Class)NSData) initWithBytes:v29 length:6];
      [v30 setBtAddressData:v31];

      [v30 setTipiConnectionStatus:*(unsigned __int8 *)(v29 + 6)];
      [v30 setTipiState:*(unsigned __int8 *)(v29 + 7)];
      [v27 addObject:v30];

      uint64_t v28 = a4[1];
      v29 += 8;
    }
    [v25 setTipiDevices:v27];
    int v32 = +[NSNotificationCenter defaultCenter];
    [v32 postNotificationName:@"com.apple.bluetooth.TipiChanged" object:v25 userInfo:0];
  }
  else if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_ERROR))
  {
    sub_100750198();
  }
  return sub_10003AFB4((uint64_t)v39);
}

void sub_1002A148C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *__p, uint64_t a17, uint64_t a18, char a19)
{
  if (__p) {
    operator delete(__p);
  }
  sub_10003AFB4((uint64_t)&a19);
  _Unwind_Resume(a1);
}

uint64_t sub_1002A1518(uint64_t a1, uint64_t a2, int a3, unsigned __int8 **a4)
{
  v14[0] = 0;
  v14[1] = 0;
  sub_10003AED0((uint64_t)v14, a1 + 360);
  if (sub_100294BC0(a1, a2))
  {
    if (qword_1009F7F00 != -1) {
      dispatch_once(&qword_1009F7F00, &stru_1009A1E70);
    }
    LODWORD(__p[0]) = *(_DWORD *)a2;
    WORD2(__p[0]) = *(_WORD *)(a2 + 4);
    uint64_t v8 = sub_1004AA194((uint64_t)off_1009F7EF8, (uint64_t)__p, 1);
    if (v8)
    {
      if (qword_1009F80B0 != -1) {
        dispatch_once(&qword_1009F80B0, &stru_1009A1FD0);
      }
      sub_1005672E4((uint64_t)off_1009F80A8, v8, **a4);
      int v9 = qword_100A19E38;
      if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
      {
        sub_100474E18(v8, __p);
        uint64_t v10 = v13 >= 0 ? __p : (void **)__p[0];
        *(_DWORD *)long long buf = 136446466;
        uint64_t v16 = v10;
        __int16 v17 = 1024;
        int v18 = a3;
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "Sensor Streaming Config Message received from device \"%{public}s\", version -> %u", buf, 0x12u);
        if (v13 < 0) {
          operator delete(__p[0]);
        }
      }
      if (qword_1009F7EF0 != -1) {
        dispatch_once(&qword_1009F7EF0, &stru_1009A1E30);
      }
      sub_100455518((uint64_t)off_1009F7EE8, v8);
    }
  }
  else if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_ERROR))
  {
    sub_1007501CC();
  }
  return sub_10003AFB4((uint64_t)v14);
}

void sub_1002A1744(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  sub_10003AFB4((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_1002A1768(uint64_t a1, uint64_t a2, const UInt8 *a3, unsigned int a4, int a5, int a6)
{
  uint64_t v12 = qword_100A19E38;
  if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 68159234;
    int v26 = 6;
    __int16 v27 = 2096;
    uint64_t v28 = a2;
    __int16 v29 = 1024;
    int v30 = a5;
    __int16 v31 = 1024;
    int v32 = a6;
    __int16 v33 = 1024;
    unsigned int v34 = a4;
    __int16 v35 = 1040;
    int v36 = 72;
    __int16 v37 = 2096;
    int v38 = a3;
    _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "Received GAPA signature response from %.6P version=%u endpointType=%u dataLen=%u data=%.72P", buf, 0x34u);
  }
  char v13 = sub_100294BC0(a1, a2);
  if (v13)
  {
    uint64_t v14 = *v13;
    if (*v13)
    {
      *((_DWORD *)v13 + 150) = 3;
      uint64_t v15 = sub_100050530();
      int v23 = *(_DWORD *)(v14 + 128);
      __int16 v24 = *(_WORD *)(v14 + 132);
      (*(void (**)(uint64_t, int *, uint64_t, void))(*(void *)v15 + 368))(v15, &v23, 5, 0);
      CFDataRef v16 = CFDataCreate(kCFAllocatorDefault, a3, a4);
      Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
      CFDictionaryAddValue(Mutable, kCFACCProperties_Endpoint_AudioProduct_AuthData, v16);
      *(_DWORD *)long long buf = a6;
      CFNumberRef v18 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, buf);
      CFDictionaryAddValue(Mutable, kCFACCProperties_Endpoint_AudioProduct_AuthInfoType, v18);
      uint64_t v19 = CFArrayCreateMutable(0, 0, 0);
      CFArrayAppendValue(v19, Mutable);
      int v20 = acc_transportClient_setPropertyForEndpointWithUUID();
      uint64_t v21 = qword_100A19E38;
      if (v20)
      {
        if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)uint64_t v22 = 0;
          _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "gapaResponseEvent: Published kCFACCProperties_Endpoint_AudioProduct_AuthResponse", v22, 2u);
        }
      }
      else if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_ERROR))
      {
        sub_1007502D8();
      }
      CFArrayRemoveAllValues(v19);
      CFRelease(v19);
      CFRelease(Mutable);
      CFRelease(v16);
    }
    else if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_ERROR))
    {
      sub_10075026C();
    }
  }
  else if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_ERROR))
  {
    sub_100750200();
  }
}

void sub_1002A1A68(uint64_t a1, uint64_t a2, int a3)
{
  if (a3 == 4098)
  {
    v7[8] = v3;
    v7[9] = v4;
    if (qword_1009FB140 != -1) {
      dispatch_once(&qword_1009FB140, &stru_1009A1EB0);
    }
    v7[0] = _NSConcreteStackBlock;
    v7[1] = 3221225472;
    void v7[2] = sub_1002A1B24;
    void v7[3] = &unk_100998260;
    void v7[4] = a1;
    void v7[5] = a2;
    sub_1004C9DF0((uint64_t)off_1009FB138, v7);
  }
}

uint64_t sub_1002A1B24(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  v31[0] = 0;
  v31[1] = 0;
  sub_10003AED0((uint64_t)v31, v2 + 360);
  uint64_t v3 = *(void *)(a1 + 40);
  if (v3)
  {
    for (uint64_t i = *(void **)(v2 + 336); ; ++i)
    {
      if (i == *(void **)(v2 + 344)) {
        return sub_10003AFB4((uint64_t)v31);
      }
      uint64_t v5 = (void *)*i;
      if (*(void *)*i == v3) {
        break;
      }
    }
    sub_100475EE0(v3, (uint64_t)&__p);
    uint64_t v6 = (std::string *)(v5 + 7);
    if (*((char *)v5 + 79) < 0)
    {
      sub_10003B098(__dst, (void *)v5[7], v5[8]);
    }
    else
    {
      *(_OWORD *)long long __dst = *(_OWORD *)&v6->__r_.__value_.__l.__data_;
      uint64_t v33 = v5[9];
    }
    int v7 = SHIBYTE(v33);
    uint64_t v8 = __dst[0];
    unsigned __int8 v9 = v30;
    if ((v30 & 0x80u) == 0) {
      size_t v10 = v30;
    }
    else {
      size_t v10 = v29;
    }
    if ((v30 & 0x80u) == 0) {
      p_p = &__p;
    }
    else {
      p_p = __p;
    }
    if (v33 >= 0) {
      uint64_t v12 = (void *)HIBYTE(v33);
    }
    else {
      uint64_t v12 = __dst[1];
    }
    if (v33 >= 0) {
      char v13 = __dst;
    }
    else {
      char v13 = (void **)__dst[0];
    }
    if ((unint64_t)v12 >= v10) {
      size_t v14 = v10;
    }
    else {
      size_t v14 = (size_t)v12;
    }
    BOOL v15 = memcmp(p_p, v13, v14) == 0;
    BOOL v16 = v12 == (void *)v10 && v15;
    if (v7 < 0)
    {
      operator delete(v8);
      if ((v30 & 0x80) == 0)
      {
LABEL_29:
        if (v16) {
          return sub_10003AFB4((uint64_t)v31);
        }
LABEL_33:
        sub_100475EE0(*(void *)(a1 + 40), (uint64_t)&__p);
        if ((v30 & 0x80u) == 0) {
          size_t v17 = v30;
        }
        else {
          size_t v17 = v29;
        }
        CFNumberRef v18 = malloc_type_malloc(v17, 0xB72A291BuLL);
        if ((char)v30 < 0) {
          operator delete(__p);
        }
        sub_100475EE0(*(void *)(a1 + 40), (uint64_t)&__p);
        int v19 = (char)v30;
        int v20 = (void **)__p;
        sub_100475EE0(*(void *)(a1 + 40), (uint64_t)__dst);
        if (v19 >= 0) {
          uint64_t v21 = &__p;
        }
        else {
          uint64_t v21 = v20;
        }
        if (v33 >= 0) {
          size_t v22 = HIBYTE(v33);
        }
        else {
          size_t v22 = (size_t)__dst[1];
        }
        memcpy(v18, v21, v22);
        if (SHIBYTE(v33) < 0) {
          operator delete(__dst[0]);
        }
        if ((char)v30 < 0) {
          operator delete(__p);
        }
        uint64_t v23 = *(void *)(a1 + 40);
        sub_100475EE0(v23, (uint64_t)&__p);
        unsigned __int16 v24 = v30;
        if ((v30 & 0x80u) != 0) {
          unsigned __int16 v24 = v29;
        }
        int v25 = sub_100285354(v2, v23, v24, v18);
        if ((char)v30 < 0) {
          operator delete(__p);
        }
        if (v25 && os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_ERROR))
        {
          sub_100475EE0(*(void *)(a1 + 40), (uint64_t)&__p);
          sub_10075030C();
        }
        sub_100475EE0(*(void *)(a1 + 40), (uint64_t)&v27);
        std::string::operator=(v6, &v27);
        if (SHIBYTE(v27.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v27.__r_.__value_.__l.__data_);
        }
        free(v18);
        return sub_10003AFB4((uint64_t)v31);
      }
    }
    else if ((v9 & 0x80) == 0)
    {
      goto LABEL_29;
    }
    operator delete(__p);
    if (v16) {
      return sub_10003AFB4((uint64_t)v31);
    }
    goto LABEL_33;
  }
  return sub_10003AFB4((uint64_t)v31);
}

void sub_1002A1DEC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20,char a21)
{
}

void sub_1002A1E54(uint64_t a1, uint64_t a2, int a3)
{
}

void sub_1002A1E5C(uint64_t a1, int a2)
{
  if (a2) {
    uint64_t v3 = 1;
  }
  else {
    uint64_t v3 = 2;
  }
  uint64_t v4 = qword_100A19E38;
  if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = "unknown";
    if (v3 == 1) {
      uint64_t v5 = "Enabled";
    }
    if (v3 == 2) {
      uint64_t v6 = "Disabled";
    }
    else {
      uint64_t v6 = (char *)v5;
    }
    sub_10004191C(__p, v6);
    if (v12 >= 0) {
      int v7 = __p;
    }
    else {
      int v7 = (void **)__p[0];
    }
    *(_DWORD *)long long buf = 136446210;
    size_t v14 = v7;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "VoiceTriggerSetting changed to %{public}s", buf, 0xCu);
    if (v12 < 0) {
      operator delete(__p[0]);
    }
  }
  uint64_t v8 = *(uint64_t ***)(a1 + 336);
  unsigned __int8 v9 = *(uint64_t ***)(a1 + 344);
  while (v8 != v9)
  {
    uint64_t v10 = **v8;
    if (!*(unsigned char *)(v10 + 960)) {
      sub_1002859A4(a1, v10, 18, v3, 2u);
    }
    ++v8;
  }
}

void sub_1002A1FA4(uint64_t a1, int a2)
{
}

void sub_1002A1FAC(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v8 = 0;
  unsigned __int8 v9 = 0;
  uint64_t v10 = 0;
  sub_10061F99C(&v8);
  if (qword_1009FB120 != -1) {
    dispatch_once(&qword_1009FB120, &stru_1009A1D90);
  }
  if (sub_10062F0BC((uint64_t)off_1009FB118))
  {
    if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_ERROR)) {
      sub_10075037C();
    }
  }
  else
  {
    uint64_t v4 = sub_10061FB58(&v8, v3);
    if (v9 == v4)
    {
      *(_DWORD *)(a1 + 500) = 0;
    }
    else
    {
      int v5 = *((_DWORD *)v4 + 4);
      *(_DWORD *)(a1 + 500) = v5;
      uint64_t v6 = qword_100A19E38;
      if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
      {
        if ((v5 - 1) > 6) {
          int v7 = "unknown";
        }
        else {
          int v7 = off_1009A22E8[v5 - 1];
        }
        *(_DWORD *)long long buf = 136315138;
        *(void *)&uint8_t buf[4] = v7;
        _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "Call status is now %s", buf, 0xCu);
      }
    }
  }
  *(void *)long long buf = &v8;
  sub_10027696C((void ***)buf);
}

void sub_1002A2134(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, void **a13)
{
  a13 = (void **)&a10;
  sub_10027696C(&a13);

  _Unwind_Resume(a1);
}

void sub_1002A2168(uint64_t a1, void *a2)
{
}

void sub_1002A2170(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    if (*(_DWORD *)(a2 + 80) == 8194)
    {
      uint64_t v3 = *(void *)a2;
      if (*(void *)a2)
      {
        uint64_t v4 = qword_100A19E38;
        if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
        {
          sub_100475EE0(v3, (uint64_t)__p);
          int v5 = v13 >= 0 ? __p : *(unsigned char **)__p;
          uint64_t v6 = *(void *)(a2 + 112);
          uint64_t v7 = *(void *)(a2 + 120);
          *(_DWORD *)long long buf = 141558787;
          *(void *)&uint8_t buf[4] = 1752392040;
          __int16 v15 = 2081;
          BOOL v16 = v5;
          __int16 v17 = 2112;
          uint64_t v18 = v6;
          __int16 v19 = 2112;
          uint64_t v20 = v7;
          _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "unPublishW1RemoteFirmware: Un-Publishing F/W version for \"%{private, mask.hash}s\" (connection %@ endpoint %@)", buf, 0x2Au);
          if (v13 < 0) {
            operator delete(*(void **)__p);
          }
        }
        if ((unsigned __int16)(*(void *)(a2 + 85) >> 24) | ((unsigned __int16)WORD2(*(void *)(a2 + 85)) >> 8))
        {
          if (*(void *)(a2 + 112))
          {
            if ((acc_transportClient_destroyConnection() & 1) == 0
              && os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_ERROR))
            {
              sub_1007503E4();
            }
            CFRelease(*(CFTypeRef *)(a2 + 120));
            *(void *)(a2 + 120) = 0;
            CFRelease(*(CFTypeRef *)(a2 + 112));
            *(void *)(a2 + 112) = 0;
          }
        }
        else
        {
          uint64_t v8 = qword_100A19E38;
          if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
          {
            sub_100475EE0(v3, (uint64_t)buf);
            unsigned __int8 v9 = v17 >= 0 ? buf : *(unsigned char **)buf;
            *(_DWORD *)std::string __p = 141558275;
            *(void *)&__p[4] = 1752392040;
            __int16 v11 = 2081;
            char v12 = v9;
            _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "Warning: unPublishW1RemoteFirmware: No case version info available for \"%{private, mask.hash}s\"", __p, 0x16u);
            if (SHIBYTE(v17) < 0) {
              operator delete(*(void **)buf);
            }
          }
        }
      }
    }
  }
  else if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_ERROR))
  {
    sub_1007503B0();
  }
}

BOOL sub_1002A23C8(uint64_t a1, uint64_t *a2, void *a3, CFStringRef theString2, const __CFString *a5)
{
  uint64_t v8 = sub_1002A24C0(a1, theString2);
  *a2 = v8;
  if (!v8)
  {
    BOOL result = os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_ERROR);
    if (!result) {
      return result;
    }
    sub_100750418();
    return 0;
  }
  if (CFStringCompare(a5, *(CFStringRef *)(v8 + 144), 0))
  {
    BOOL result = os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_ERROR);
    if (!result) {
      return result;
    }
    sub_1007504F0();
    return 0;
  }
  uint64_t v10 = *(void *)*a2;
  *a3 = v10;
  if (v10) {
    return 1;
  }
  BOOL result = os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_ERROR);
  if (result)
  {
    sub_100750484();
    return 0;
  }
  return result;
}

uint64_t sub_1002A24C0(uint64_t a1, CFStringRef theString2)
{
  if (theString2)
  {
    uint64_t v4 = *(uint64_t **)(a1 + 336);
    for (uint64_t i = *(uint64_t **)(a1 + 344); v4 != i; ++v4)
    {
      uint64_t v6 = *v4;
      if (*v4)
      {
        CFStringRef v7 = *(const __CFString **)(v6 + 128);
        if (v7)
        {
          if (CFEqual(v7, theString2)) {
            return v6;
          }
          uint64_t i = *(uint64_t **)(a1 + 344);
        }
      }
    }
  }
  return 0;
}

uint64_t sub_1002A2534(uint64_t a1, const __CFString *a2, const __CFString *a3, const __CFData *a4)
{
  uint64_t v8 = *(void *)(a1 + 32);
  v20[0] = 0;
  v20[1] = 0;
  sub_10003AED0((uint64_t)v20, v8 + 360);
  uint64_t v9 = sub_1002A24C0(v8, a2);
  if (v9)
  {
    uint64_t v10 = *(void *)v9;
    if (*(void *)v9)
    {
      if (CFStringCompare(a3, *(CFStringRef *)(v9 + 136), 0))
      {
        if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_ERROR)) {
          sub_1007505D4();
        }
      }
      else
      {
        char v19 = 0;
        sub_10001B8E0(&v19);
        unsigned __int16 Length = CFDataGetLength(a4);
        BytePtr = CFDataGetBytePtr(a4);
        int v13 = sub_1000D9084((unsigned __int8 *)(v10 + 128), Length, BytePtr);
        sub_10001B910(&v19);
        size_t v14 = qword_100A19E38;
        if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
        {
          sub_100474E18(*(void *)(a1 + 40), __p);
          __int16 v15 = v18 >= 0 ? __p : (void **)__p[0];
          *(_DWORD *)long long buf = 136446466;
          size_t v22 = v15;
          __int16 v23 = 1024;
          int v24 = v13;
          _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "publishAccRemoteFirmware auth data: Data sent to device %{public}s, status %d", buf, 0x12u);
          if (v18 < 0) {
            operator delete(__p[0]);
          }
        }
        sub_10001B8AC(&v19);
      }
    }
  }
  else if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_ERROR))
  {
    sub_100750568();
  }
  return sub_10003AFB4((uint64_t)v20);
}

void sub_1002A271C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, char a16)
{
}

uint64_t sub_1002A2754(uint64_t a1, const __CFString *a2, const __CFString *a3, const __CFData *a4)
{
  uint64_t v7 = *(void *)(a1 + 32);
  v22[0] = 0;
  v22[1] = 0;
  sub_10003AED0((uint64_t)v22, v7 + 360);
  uint64_t v8 = (uint64_t *)sub_1002A24C0(v7, a2);
  uint64_t v9 = v8;
  if (v8)
  {
    uint64_t v10 = *v8;
    if (*v8)
    {
      unsigned int v11 = sub_1002A29C8(v7, a2, a3);
      int v12 = v11;
      if (v11 <= 0x1F && (uint64_t v13 = v9[v11 + 20]) != 0 && *(void *)(v13 + 88))
      {
        if (*(unsigned char *)(v13 + 97))
        {
          int Length = CFDataGetLength(a4);
          CFDataGetBytePtr(a4);
          sub_1002A2A40(v9, v12, Length);
          return sub_10003AFB4((uint64_t)v22);
        }
        __int16 v15 = qword_100A19E38;
        if (!os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_ERROR)) {
          return sub_10003AFB4((uint64_t)v22);
        }
        sub_100474E18(v10, __p);
        if (v21 >= 0) {
          __int16 v17 = __p;
        }
        else {
          __int16 v17 = (void **)__p[0];
        }
        *(_DWORD *)long long buf = 136446722;
        int v24 = v17;
        __int16 v25 = 2112;
        CFStringRef v26 = a3;
        __int16 v27 = 1024;
        int v28 = v12;
        char v18 = "publishAccRemoteFirmware EA data: EA session currently closed on device %{public}s for endpoint %@ index %d";
      }
      else
      {
        __int16 v15 = qword_100A19E38;
        if (!os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_ERROR)) {
          return sub_10003AFB4((uint64_t)v22);
        }
        sub_100474E18(v10, __p);
        if (v21 >= 0) {
          char v19 = __p;
        }
        else {
          char v19 = (void **)__p[0];
        }
        *(_DWORD *)long long buf = 136446722;
        int v24 = v19;
        __int16 v25 = 2112;
        CFStringRef v26 = a3;
        __int16 v27 = 1024;
        int v28 = v12;
        char v18 = "publishAccRemoteFirmware EA data: device %{public}s has no endpoint %@ (index = %d)";
      }
      _os_log_error_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, v18, buf, 0x1Cu);
      if (v21 < 0) {
        operator delete(__p[0]);
      }
    }
  }
  else if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_ERROR))
  {
    sub_100750648();
  }
  return sub_10003AFB4((uint64_t)v22);
}

void sub_1002A299C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  sub_10003AFB4((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1002A29C8(uint64_t a1, const __CFString *a2, const __CFString *a3)
{
  LOBYTE(v3) = -1;
  if (a2 && a3)
  {
    uint64_t v5 = sub_1002A24C0(a1, a2);
    if (v5)
    {
      uint64_t v3 = 0;
      uint64_t v6 = v5 + 160;
      while (1)
      {
        uint64_t v7 = *(void *)(v6 + 8 * v3);
        if (v7)
        {
          CFStringRef v8 = *(const __CFString **)(v7 + 88);
          if (v8)
          {
            if (CFEqual(a3, v8)) {
              break;
            }
          }
        }
        if (++v3 == 32) {
          goto LABEL_9;
        }
      }
    }
    else
    {
LABEL_9:
      LOBYTE(v3) = -1;
    }
  }
  return v3;
}

uint64_t sub_1002A2A40(uint64_t *a1, int a2, int a3)
{
  v13[0] = 0;
  v13[1] = 0;
  sub_10003AED0((uint64_t)v13, (uint64_t)(a1 + 55));
  uint64_t v10 = a1[54];
  if (a3) {
    operator new();
  }
  sub_10003AFE8((uint64_t)v13);
  if (!v10)
  {
    uint64_t v6 = qword_100A19E38;
    if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_INFO))
    {
      sub_100475EE0(*a1, (uint64_t)__p);
      if (v12 >= 0) {
        uint64_t v7 = __p;
      }
      else {
        uint64_t v7 = (void **)__p[0];
      }
      uint64_t v8 = a1[54];
      *(_DWORD *)long long buf = 67110147;
      int v15 = 0;
      __int16 v16 = 2160;
      uint64_t v17 = 1752392040;
      __int16 v18 = 2081;
      char v19 = v7;
      __int16 v20 = 1024;
      int v21 = a2;
      __int16 v22 = 2048;
      uint64_t v23 = v8;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_INFO, "addEASessionData: Queueing %d bytes for \"%{private, mask.hash}s\" (index %d), queue size now %lu", buf, 0x2Cu);
      if (v12 < 0) {
        operator delete(__p[0]);
      }
    }
    sub_100294C04(a1);
  }
  return sub_10003AFB4((uint64_t)v13);
}

void sub_1002A2C6C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  sub_10003AFB4((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1002A2CB0(uint64_t a1, const __CFString *a2, uint64_t a3, const __CFBoolean *a4, uint64_t a5, const __CFString *a6)
{
  uint64_t v9 = *(void *)(a1 + 32);
  v27[0] = 0;
  v27[1] = 0;
  sub_10003AED0((uint64_t)v27, v9 + 360);
  uint64_t v10 = (uint64_t *)sub_1002A24C0(v9, a6);
  unsigned int v11 = v10;
  if (v10)
  {
    uint64_t v12 = *v10;
    if (*v10)
    {
      unsigned int v13 = sub_1002A29C8(v9, a6, a2);
      unsigned int v14 = v13;
      if (v13 <= 0x1F && (uint64_t v15 = v11[v13 + 20]) != 0 && *(void *)(v15 + 88))
      {
        __int16 v16 = qword_100A19E38;
        if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
        {
          sub_100474E18(v12, __p);
          uint64_t v17 = v26 >= 0 ? __p : (void **)__p[0];
          *(_DWORD *)long long buf = 136446978;
          size_t v29 = v17;
          __int16 v30 = 2112;
          CFStringRef v31 = a2;
          __int16 v32 = 1024;
          unsigned int v33 = v14;
          __int16 v34 = 1024;
          BOOL v35 = kCFBooleanFalse != a4;
          _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "publishAccRemoteFirmware EA property: Switching EA session for device %{public}s endpoint %@ index %d: enable = %d", buf, 0x22u);
          if (v26 < 0) {
            operator delete(__p[0]);
          }
        }
        *(unsigned char *)(v15 + 97) = kCFBooleanFalse != a4;
        char v24 = 0;
        sub_10001B8E0(&v24);
        int v18 = sub_1000D8DF4((unsigned __int8 *)(v12 + 128), v14, kCFBooleanFalse != a4);
        sub_10001B910(&v24);
        sub_10003AFE8((uint64_t)v27);
        if (v18)
        {
          char v19 = qword_100A19E38;
          if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_ERROR))
          {
            sub_100474E18(v12, __p);
            if (v26 >= 0) {
              uint64_t v23 = __p;
            }
            else {
              uint64_t v23 = (void **)__p[0];
            }
            *(_DWORD *)long long buf = 136446978;
            size_t v29 = v23;
            __int16 v30 = 2112;
            CFStringRef v31 = a2;
            __int16 v32 = 1024;
            unsigned int v33 = v14;
            __int16 v34 = 1024;
            BOOL v35 = v18;
            _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "publishAccRemoteFirmware EA property: Error sending EA session switch for device %{public}s endpoint %@ index %d: %d", buf, 0x22u);
            if (v26 < 0) {
              operator delete(__p[0]);
            }
          }
        }
        sub_10001B8AC(&v24);
      }
      else
      {
        __int16 v20 = qword_100A19E38;
        if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_ERROR))
        {
          sub_100474E18(v12, __p);
          __int16 v22 = v26 >= 0 ? __p : (void **)__p[0];
          *(_DWORD *)long long buf = 136446722;
          size_t v29 = v22;
          __int16 v30 = 2112;
          CFStringRef v31 = a2;
          __int16 v32 = 1024;
          unsigned int v33 = v14;
          _os_log_error_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_ERROR, "publishAccRemoteFirmware EA property: device %{public}s has no endpoint %@ (index = %d)", buf, 0x1Cu);
          if (v26 < 0) {
            operator delete(__p[0]);
          }
        }
      }
    }
  }
  else if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_ERROR))
  {
    sub_1007506B4();
  }
  return sub_10003AFB4((uint64_t)v27);
}

void sub_1002A2FFC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  sub_10003AFB4((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1002A3040(uint64_t a1, const __CFString *a2, uint64_t a3, const void *a4, uint64_t a5, const __CFString *a6)
{
  uint64_t v11 = *(void *)(a1 + 32);
  v40[0] = 0;
  v40[1] = 0;
  sub_10003AED0((uint64_t)v40, v11 + 360);
  uint64_t v12 = qword_100A19E38;
  if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 138412546;
    *(void *)__int16 v42 = a3;
    *(_WORD *)&v42[8] = 2112;
    *(void *)&v42[10] = a4;
    _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "publishAccRemoteFirmware acc_transportClient_setEndpointPropertyDidChangeHandler GAPA handler property=%@ value=%@", buf, 0x16u);
  }
  if (a4)
  {
    uint64_t v38 = 0;
    uint64_t v39 = 0;
    if (sub_1002A23C8(v11, &v39, &v38, a6, a2))
    {
      uint64_t v13 = v39;
      if (*(_DWORD *)(v39 + 600) == 1)
      {
        CFTypeID v14 = CFGetTypeID(a4);
        if (v14 == CFArrayGetTypeID())
        {
          if (CFArrayGetCount((CFArrayRef)a4) == 1)
          {
            ValueAtIndex = CFArrayGetValueAtIndex((CFArrayRef)a4, 0);
            CFTypeID v16 = CFGetTypeID(ValueAtIndex);
            if (v16 == CFDictionaryGetTypeID())
            {
              CFDictionaryRef v17 = (const __CFDictionary *)CFArrayGetValueAtIndex((CFArrayRef)a4, 0);
              CFDictionaryRef v18 = v17;
              if (v17)
              {
                char v19 = (const void *)kCFACCProperties_Endpoint_AudioProduct_AuthData;
                CFNumberRef Value = CFDictionaryGetValue(v17, kCFACCProperties_Endpoint_AudioProduct_AuthData);
                CFTypeID v21 = CFGetTypeID(Value);
                if (v21 == CFDataGetTypeID())
                {
                  CFDataRef v22 = (const __CFData *)CFDictionaryGetValue(v18, v19);
                  CFDataRef v23 = v22;
                  if (v22)
                  {
                    BytePtr = CFDataGetBytePtr(v22);
                    unsigned __int16 Length = CFDataGetLength(v23);
                    char v26 = (unsigned __int8 *)(v38 + 128);
                    __int16 v27 = qword_100A19E38;
                    BOOL v28 = os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT);
                    if (v28)
                    {
                      *(_DWORD *)long long buf = 68158978;
                      *(_DWORD *)__int16 v42 = 6;
                      *(_WORD *)&v42[4] = 2096;
                      *(void *)&v42[6] = v26;
                      *(_WORD *)&v42[14] = 1024;
                      *(_DWORD *)&v42[16] = 1;
                      __int16 v43 = 1024;
                      int v44 = Length;
                      __int16 v45 = 1040;
                      int v46 = 32;
                      __int16 v47 = 2096;
                      int v48 = BytePtr;
                      _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "Send gapa auth challenge to wx %.6P version=%u (%hu bytes) %.32P", buf, 0x2Eu);
                    }
                    int v29 = sub_1002A351C(v28, v26, BytePtr, Length, 1);
                    __int16 v30 = qword_100A19E38;
                    if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
                    {
                      *(_DWORD *)long long buf = 67109120;
                      *(_DWORD *)__int16 v42 = v29;
                      _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_DEFAULT, "publishAccRemoteFirmware GAPA handler: BT_AACP_CLIENT_GAPASendChallenge result %d", buf, 8u);
                    }
                    *(_DWORD *)(v13 + 600) = 2;
                    uint64_t v31 = sub_100050530();
                    uint64_t v32 = *(void *)(a1 + 40);
                    int v36 = *(_DWORD *)(v32 + 128);
                    __int16 v37 = *(_WORD *)(v32 + 132);
                    (*(void (**)(uint64_t, int *, uint64_t, void))(*(void *)v31 + 368))(v31, &v36, 4, 0);
                  }
                  else if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_ERROR))
                  {
                    sub_100750788();
                  }
                }
                else if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_ERROR))
                {
                  __int16 v34 = CFDictionaryGetValue(v18, v19);
                  CFGetTypeID(v34);
                  CFDataGetTypeID();
                  sub_1007507BC();
                }
              }
              else if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_ERROR))
              {
                sub_100750754();
              }
            }
            else if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_ERROR))
            {
              unsigned int v33 = CFArrayGetValueAtIndex((CFArrayRef)a4, 0);
              CFGetTypeID(v33);
              CFDictionaryGetTypeID();
              sub_1007507F8();
            }
          }
          else if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_ERROR))
          {
            sub_100750834();
          }
        }
        else if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_ERROR))
        {
          CFGetTypeID(a4);
          CFArrayGetTypeID();
          sub_1007508A0();
        }
      }
      else if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_ERROR))
      {
        sub_1007508DC();
      }
    }
  }
  else if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_ERROR))
  {
    sub_100750720();
  }
  return sub_10003AFB4((uint64_t)v40);
}

void sub_1002A34D8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  sub_10003AFB4((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1002A351C(uint64_t a1, unsigned __int8 *a2, const void *a3, uint64_t a4, char a5)
{
  char v11 = 0;
  sub_10001B8E0(&v11);
  uint64_t v9 = sub_1000D9C64(a2, a3, a4, a5);
  sub_10001B8AC(&v11);
  return v9;
}

void sub_1002A3588(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, int a10, __int16 a11, char a12, char a13)
{
}

uint64_t sub_1002A359C(uint64_t a1, const __CFString *a2, uint64_t a3, const void *a4, uint64_t a5, const __CFString *a6)
{
  uint64_t v11 = *(void *)(a1 + 32);
  v27[0] = 0;
  v27[1] = 0;
  sub_10003AED0((uint64_t)v27, v11 + 360);
  uint64_t v12 = qword_100A19E38;
  if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 138412546;
    *(void *)&uint8_t buf[4] = a3;
    __int16 v29 = 2112;
    __int16 v30 = a4;
    _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "publishAccRemoteFirmware acc_transportClient_setEndpointPropertyDidChangeHandler GAPA auth result property=%@ value=%@", buf, 0x16u);
  }
  CFTypeID v13 = CFGetTypeID(a4);
  if (v13 == CFNumberGetTypeID())
  {
    char valuePtr = 0;
    CFNumberGetValue((CFNumberRef)a4, kCFNumberSInt8Type, &valuePtr);
    BOOL v14 = valuePtr != 0;
    uint64_t v15 = sub_100017768();
    if ((*(unsigned int (**)(uint64_t))(*(void *)v15 + 696))(v15))
    {
      CFTypeID v16 = qword_100A19E38;
      BOOL v14 = 1;
      if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)long long buf = 67109120;
        *(_DWORD *)&uint8_t buf[4] = 1;
        _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "Override GAPA authResult=%d", buf, 8u);
      }
    }
    uint64_t v17 = sub_100017768();
    if ((*(unsigned int (**)(uint64_t))(*(void *)v17 + 704))(v17))
    {
      CFDictionaryRef v18 = qword_100A19E38;
      BOOL v14 = 0;
      if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)long long buf = 67109120;
        *(_DWORD *)&uint8_t buf[4] = 0;
        _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "Override GAPA authResult=%d", buf, 8u);
        BOOL v14 = 0;
      }
    }
    *(void *)long long buf = 0;
    uint64_t v25 = 0;
    if (sub_1002A23C8(v11, (uint64_t *)buf, &v25, a6, a2))
    {
      *(_DWORD *)(*(void *)buf + 600) = 4;
      uint64_t v19 = sub_100050530();
      uint64_t v20 = *(void *)(a1 + 40);
      int v23 = *(_DWORD *)(v20 + 128);
      __int16 v24 = *(_WORD *)(v20 + 132);
      (*(void (**)(uint64_t, int *, uint64_t, void))(*(void *)v19 + 368))(v19, &v23, 6, 0);
      if (v14)
      {
        uint64_t v21 = sub_10047ED44(v25, 1, 1);
        sub_100289F60(v21, *(void *)(a1 + 40), 1);
      }
      else
      {
        sub_10028A258(v11, v25, 0x200u);
      }
    }
  }
  else if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_ERROR))
  {
    CFGetTypeID(a4);
    CFNumberGetTypeID();
    sub_100750944();
  }
  return sub_10003AFB4((uint64_t)v27);
}

void sub_1002A38BC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  sub_10003AFB4((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1002A38E8(uint64_t a1, const __CFString *a2, uint64_t a3, uint64_t a4, uint64_t a5, const __CFString *a6)
{
  uint64_t v9 = *(void *)(a1 + 32);
  v20[0] = 0;
  v20[1] = 0;
  sub_10003AED0((uint64_t)v20, v9 + 360);
  uint64_t v10 = sub_1002A24C0(v9, a6);
  if (v10)
  {
    uint64_t v11 = *(void *)v10;
    if (*(void *)v10)
    {
      if (CFStringCompare(a2, *(CFStringRef *)(v10 + 144), 0))
      {
        if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_ERROR)) {
          sub_1007509EC();
        }
      }
      else
      {
        char v19 = 0;
        sub_10001B8E0(&v19);
        int v12 = sub_1000D9B94((unsigned __int8 *)(v11 + 128));
        sub_10001B910(&v19);
        CFTypeID v13 = qword_100A19E38;
        if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)long long buf = 67109120;
          int v22 = v12;
          _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "publishAccRemoteFirmware cert required handler: BT_AACP_CLIENT_GetCertificates result %d", buf, 8u);
        }
        uint64_t v14 = sub_100050530();
        uint64_t v15 = *(void *)(a1 + 40);
        int v17 = *(_DWORD *)(v15 + 128);
        __int16 v18 = *(_WORD *)(v15 + 132);
        (*(void (**)(uint64_t, int *, uint64_t, void))(*(void *)v14 + 368))(v14, &v17, 2, 0);
        sub_10001B8AC(&v19);
      }
    }
  }
  else if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_ERROR))
  {
    sub_100750980();
  }
  return sub_10003AFB4((uint64_t)v20);
}

void sub_1002A3ABC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  sub_10003AFB4((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_1002A3AF0(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    unsigned int v3 = *(_DWORD *)(a2 + 80) - 8194;
    BOOL v4 = v3 > 0xE;
    int v5 = (1 << v3) & 0x409B;
    if (v4 || v5 == 0)
    {
      uint64_t v7 = *(void *)a2;
      if (*(void *)a2)
      {
        uint64_t v8 = *(void *)(a2 + 128);
        if (v8)
        {
          uint64_t v9 = qword_100A19E38;
          if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
          {
            sub_100475EE0(v7, (uint64_t)__p);
            uint64_t v10 = v15 >= 0 ? __p : (void **)__p[0];
            *(_DWORD *)long long buf = 138412803;
            uint64_t v17 = v8;
            __int16 v18 = 2160;
            uint64_t v19 = 1752392040;
            __int16 v20 = 2081;
            uint64_t v21 = v10;
            _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "unPublishAccRemoteFirmware: Un-Publishing connection %@ and all endpoints for \"%{private, mask.hash}s\"", buf, 0x20u);
            if (v15 < 0) {
              operator delete(__p[0]);
            }
          }
          if (!acc_transportClient_destroyConnection()
            && os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_ERROR))
          {
            sub_100750A94();
          }
          for (uint64_t i = 0; i != 256; i += 8)
          {
            uint64_t v12 = *(void *)(a2 + 160 + i);
            if (v12)
            {
              sub_1002B01FC(v12);
              operator delete();
            }
          }
          CFRelease(*(CFTypeRef *)(a2 + 128));
          *(void *)(a2 + 128) = 0;
          CFTypeID v13 = *(const void **)(a2 + 136);
          if (v13)
          {
            CFRelease(v13);
            *(void *)(a2 + 136) = 0;
          }
        }
      }
    }
  }
  else if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_ERROR))
  {
    sub_100750A60();
  }
}

uint64_t sub_1002A3CE0(uint64_t a1, uint64_t a2, char *a3, size_t a4, char *a5, size_t a6, char *a7, size_t a8, char *a9, size_t a10, char *a11, size_t a12, char *a13, size_t a14, char *a15, size_t a16)
{
  v43[1] = 0;
  uint64_t v44 = a2;
  v43[0] = 0;
  sub_10003AED0((uint64_t)v43, a1 + 360);
  int v22 = *(uint64_t ***)(a1 + 336);
  int v23 = *(uint64_t ***)(a1 + 344);
  if (v22 == v23)
  {
LABEL_9:
    uint64_t v27 = 7;
  }
  else
  {
    size_t v38 = a6;
    size_t v39 = a8;
    while (1)
    {
      __int16 v24 = (unsigned __int8 *)*v22;
      uint64_t v25 = **v22;
      if (v25)
      {
        if (v44 == *(_DWORD *)(v25 + 128) && WORD2(v44) == *(unsigned __int16 *)(v25 + 132)) {
          break;
        }
      }
      if (++v22 == v23) {
        goto LABEL_9;
      }
    }
    long long __dst = a5;
    BOOL v28 = qword_100A19E38;
    if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
    {
      sub_100475EE0(v25, (uint64_t)__p);
      __int16 v29 = __p;
      if (v42 < 0) {
        __int16 v29 = (void **)__p[0];
      }
      *(_DWORD *)long long buf = 141558275;
      *(void *)&uint8_t buf[4] = 1752392040;
      __int16 v46 = 2081;
      __int16 v47 = v29;
      _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, " Returning F/W version for \"%{private, mask.hash}s\"", buf, 0x16u);
      if (v42 < 0) {
        operator delete(__p[0]);
      }
    }
    int v30 = v24[88];
    int v31 = v24[89];
    int v32 = v24[90];
    *(_WORD *)&uint8_t buf[8] = 0;
    *(void *)long long buf = 0;
    sprintf(buf, "%d.%d.%d", v30, v31, v32);
    if (a14 < 0xA) {
      goto LABEL_23;
    }
    strlcpy(a13, buf, a14);
    size_t v33 = v39;
    sub_1004A82EC((unsigned __int8 *)(v25 + 128), __p);
    if (v42 < 0)
    {
      size_t v34 = strlen((const char *)__p[0]) + 1;
      operator delete(__p[0]);
      BOOL v35 = v34 > a4;
      size_t v33 = v39;
      if (v35)
      {
LABEL_23:
        uint64_t v27 = 5;
        goto LABEL_24;
      }
    }
    else if (strlen((const char *)__p) + 1 > a4)
    {
      goto LABEL_23;
    }
    strlcpy(a3, "AirPods Case", a4);
    if (v38 < 0xD) {
      goto LABEL_23;
    }
    strlcpy(__dst, "AirPods Case", v38);
    if (a10 < 6) {
      goto LABEL_23;
    }
    strlcpy(a9, "A1602", a10);
    if (v33 < 0xA) {
      goto LABEL_23;
    }
    strlcpy(a7, "Apple Inc", v33);
    if (a16 >= 2) {
      strlcpy(a15, " ", a16);
    }
    if (a12 >= 2) {
      strlcpy(a11, " ", a12);
    }
    uint64_t v27 = 0;
  }
LABEL_24:
  sub_10003AFB4((uint64_t)v43);
  return v27;
}

void sub_1002A3FD4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, ...)
{
  va_start(va, a16);
  sub_10003AFB4((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1002A3FF8(uint64_t a1, uint64_t a2)
{
  v216[0] = 0;
  v216[1] = 0;
  sub_10003AED0((uint64_t)v216, a1 + 360);
  if (a2)
  {
    unsigned int v3 = *(void ***)(a1 + 336);
    BOOL v4 = *(void ***)(a1 + 344);
    if (v3 != v4)
    {
      while (**v3 != a2)
      {
        if (++v3 == v4) {
          return sub_10003AFB4((uint64_t)v216);
        }
      }
      int v5 = +[EAAccessoryManager sharedAccessoryManager];
      uint64_t v205 = [v5 connectedAccessories];

      sub_1004A82EC((unsigned __int8 *)(a2 + 128), &__p);
      if (v218.i8[15] >= 0) {
        p_p = &__p;
      }
      else {
        p_p = __p;
      }
      uint64_t v208 = +[NSString stringWithUTF8String:p_p];
      if (v218.i8[15] < 0) {
        operator delete(__p);
      }
      long long v212 = 0u;
      long long v213 = 0u;
      long long v214 = 0u;
      long long v215 = 0u;
      obuint64_t j = v205;
      id v7 = [obj countByEnumeratingWithState:&v212 objects:v225 count:16];
      if (v7)
      {
        uint64_t v207 = *(void *)v213;
        do
        {
          id v209 = v7;
          for (uint64_t i = 0; i != v209; uint64_t i = (char *)i + 1)
          {
            if (*(void *)v213 != v207) {
              objc_enumerationMutation(obj);
            }
            uint64_t v9 = *(void **)(*((void *)&v212 + 1) + 8 * i);
            uint64_t v10 = [v9 macAddress];
            unsigned __int8 v11 = [v10 isEqualToString:v208];

            if (v11)
            {
              uint64_t v12 = [v9 name];
              unsigned __int8 v13 = [v12 hasSuffix:@"Case"];

              if ((v13 & 1) == 0)
              {
                uint64_t v14 = qword_100A19E38;
                if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
                {
                  sub_100474E18(a2, &__p);
                  char v15 = &__p;
                  if (v218.i8[15] < 0) {
                    char v15 = __p;
                  }
                  buf.i32[0] = 136446210;
                  *(uint64_t *)((char *)buf.i64 + 4) = (uint64_t)v15;
                  _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "getVersionInfoFromWiAP: saving ExternalAccessory information for %{public}s", (uint8_t *)&buf, 0xCu);
                  if (v218.i8[15] < 0) {
                    operator delete(__p);
                  }
                }
                int64x2_t buf = 0uLL;
                uint64_t v224 = 0;
                sub_10004191C(&v221, "");
                CFTypeID v16 = (_OWORD *)buf.i64[1];
                if (buf.i64[1] >= (unint64_t)v224)
                {
                  unint64_t v18 = 0xAAAAAAAAAAAAAAABLL * ((buf.i64[1] - buf.i64[0]) >> 3);
                  unint64_t v19 = v18 + 1;
                  if (v18 + 1 > 0xAAAAAAAAAAAAAAALL) {
                    abort();
                  }
                  if (0x5555555555555556 * ((uint64_t)&v224[-buf.i64[0]] >> 3) > v19) {
                    unint64_t v19 = 0x5555555555555556 * ((uint64_t)&v224[-buf.i64[0]] >> 3);
                  }
                  if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)&v224[-buf.i64[0]] >> 3) >= 0x555555555555555) {
                    unint64_t v20 = 0xAAAAAAAAAAAAAAALL;
                  }
                  else {
                    unint64_t v20 = v19;
                  }
                  uint64_t v220 = &v224;
                  if (v20) {
                    uint64_t v21 = (char *)sub_1002B3440((uint64_t)&v224, v20);
                  }
                  else {
                    uint64_t v21 = 0;
                  }
                  int v22 = &v21[24 * v18];
                  long long v23 = v221;
                  *((void *)v22 + 2) = v222;
                  *(_OWORD *)int v22 = v23;
                  uint64_t v222 = 0;
                  long long v221 = 0uLL;
                  uint64_t v24 = buf.i64[1];
                  uint64_t v25 = buf.i64[0];
                  if (buf.i64[1] == buf.i64[0])
                  {
                    int64x2_t v28 = vdupq_n_s64(buf.u64[1]);
                    char v26 = &v21[24 * v18];
                  }
                  else
                  {
                    char v26 = &v21[24 * v18];
                    do
                    {
                      long long v27 = *(_OWORD *)(v24 - 24);
                      *((void *)v26 - 1) = *(void *)(v24 - 8);
                      *(_OWORD *)(v26 - 24) = v27;
                      v26 -= 24;
                      *(void *)(v24 - 16) = 0;
                      *(void *)(v24 - 8) = 0;
                      *(void *)(v24 - 24) = 0;
                      v24 -= 24;
                    }
                    while (v24 != v25);
                    int64x2_t v28 = buf;
                  }
                  __int16 v29 = v22 + 24;
                  buf.i64[0] = (uint64_t)v26;
                  buf.i64[1] = (uint64_t)(v22 + 24);
                  int64x2_t v218 = v28;
                  int v30 = v224;
                  uint64_t v224 = &v21[24 * v20];
                  uint64_t v219 = v30;
                  std::string __p = (void *)v28.i64[0];
                  sub_1002B4440((uint64_t)&__p);
                  buf.i64[1] = (uint64_t)v29;
                  if (SHIBYTE(v222) < 0) {
                    operator delete((void *)v221);
                  }
                }
                else
                {
                  long long v17 = v221;
                  *(void *)(buf.i64[1] + 16) = v222;
                  *CFTypeID v16 = v17;
                  buf.i64[1] = (uint64_t)v16 + 24;
                }
                id v31 = [v9 modelNumber];
                int v32 = (char *)[v31 UTF8String];
                if (v32) {
                  size_t v33 = v32;
                }
                else {
                  size_t v33 = "";
                }
                sub_10004191C(&v221, v33);
                size_t v34 = (_OWORD *)buf.i64[1];
                if (buf.i64[1] >= (unint64_t)v224)
                {
                  unint64_t v36 = 0xAAAAAAAAAAAAAAABLL * ((buf.i64[1] - buf.i64[0]) >> 3);
                  unint64_t v37 = v36 + 1;
                  if (v36 + 1 > 0xAAAAAAAAAAAAAAALL) {
                    abort();
                  }
                  if (0x5555555555555556 * ((uint64_t)&v224[-buf.i64[0]] >> 3) > v37) {
                    unint64_t v37 = 0x5555555555555556 * ((uint64_t)&v224[-buf.i64[0]] >> 3);
                  }
                  if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)&v224[-buf.i64[0]] >> 3) >= 0x555555555555555) {
                    unint64_t v38 = 0xAAAAAAAAAAAAAAALL;
                  }
                  else {
                    unint64_t v38 = v37;
                  }
                  uint64_t v220 = &v224;
                  if (v38) {
                    size_t v39 = (char *)sub_1002B3440((uint64_t)&v224, v38);
                  }
                  else {
                    size_t v39 = 0;
                  }
                  int v40 = &v39[24 * v36];
                  long long v41 = v221;
                  *((void *)v40 + 2) = v222;
                  *(_OWORD *)int v40 = v41;
                  uint64_t v222 = 0;
                  long long v221 = 0uLL;
                  uint64_t v42 = buf.i64[1];
                  uint64_t v43 = buf.i64[0];
                  if (buf.i64[1] == buf.i64[0])
                  {
                    int64x2_t v46 = vdupq_n_s64(buf.u64[1]);
                    uint64_t v44 = &v39[24 * v36];
                  }
                  else
                  {
                    uint64_t v44 = &v39[24 * v36];
                    do
                    {
                      long long v45 = *(_OWORD *)(v42 - 24);
                      *((void *)v44 - 1) = *(void *)(v42 - 8);
                      *(_OWORD *)(v44 - 24) = v45;
                      v44 -= 24;
                      *(void *)(v42 - 16) = 0;
                      *(void *)(v42 - 8) = 0;
                      *(void *)(v42 - 24) = 0;
                      v42 -= 24;
                    }
                    while (v42 != v43);
                    int64x2_t v46 = buf;
                  }
                  __int16 v47 = v40 + 24;
                  buf.i64[0] = (uint64_t)v44;
                  buf.i64[1] = (uint64_t)(v40 + 24);
                  int64x2_t v218 = v46;
                  int v48 = v224;
                  uint64_t v224 = &v39[24 * v38];
                  uint64_t v219 = v48;
                  std::string __p = (void *)v46.i64[0];
                  sub_1002B4440((uint64_t)&__p);
                  buf.i64[1] = (uint64_t)v47;
                  if (SHIBYTE(v222) < 0) {
                    operator delete((void *)v221);
                  }
                }
                else
                {
                  long long v35 = v221;
                  *(void *)(buf.i64[1] + 16) = v222;
                  *size_t v34 = v35;
                  uint64_t v222 = 0;
                  long long v221 = 0uLL;
                  buf.i64[1] = (uint64_t)v34 + 24;
                }

                id v49 = [v9 manufacturer];
                int v50 = (char *)[v49 UTF8String];
                if (v50) {
                  __int16 v51 = v50;
                }
                else {
                  __int16 v51 = "";
                }
                sub_10004191C(&v221, v51);
                int v52 = (_OWORD *)buf.i64[1];
                if (buf.i64[1] >= (unint64_t)v224)
                {
                  unint64_t v54 = 0xAAAAAAAAAAAAAAABLL * ((buf.i64[1] - buf.i64[0]) >> 3);
                  unint64_t v55 = v54 + 1;
                  if (v54 + 1 > 0xAAAAAAAAAAAAAAALL) {
                    abort();
                  }
                  if (0x5555555555555556 * ((uint64_t)&v224[-buf.i64[0]] >> 3) > v55) {
                    unint64_t v55 = 0x5555555555555556 * ((uint64_t)&v224[-buf.i64[0]] >> 3);
                  }
                  if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)&v224[-buf.i64[0]] >> 3) >= 0x555555555555555) {
                    unint64_t v56 = 0xAAAAAAAAAAAAAAALL;
                  }
                  else {
                    unint64_t v56 = v55;
                  }
                  uint64_t v220 = &v224;
                  if (v56) {
                    BOOL v57 = (char *)sub_1002B3440((uint64_t)&v224, v56);
                  }
                  else {
                    BOOL v57 = 0;
                  }
                  CFNumberRef v58 = &v57[24 * v54];
                  long long v59 = v221;
                  *((void *)v58 + 2) = v222;
                  *(_OWORD *)CFNumberRef v58 = v59;
                  uint64_t v222 = 0;
                  long long v221 = 0uLL;
                  uint64_t v60 = buf.i64[1];
                  uint64_t v61 = buf.i64[0];
                  if (buf.i64[1] == buf.i64[0])
                  {
                    int64x2_t v64 = vdupq_n_s64(buf.u64[1]);
                    __int16 v62 = &v57[24 * v54];
                  }
                  else
                  {
                    __int16 v62 = &v57[24 * v54];
                    do
                    {
                      long long v63 = *(_OWORD *)(v60 - 24);
                      *((void *)v62 - 1) = *(void *)(v60 - 8);
                      *(_OWORD *)(v62 - 24) = v63;
                      v62 -= 24;
                      *(void *)(v60 - 16) = 0;
                      *(void *)(v60 - 8) = 0;
                      *(void *)(v60 - 24) = 0;
                      v60 -= 24;
                    }
                    while (v60 != v61);
                    int64x2_t v64 = buf;
                  }
                  char v65 = v58 + 24;
                  buf.i64[0] = (uint64_t)v62;
                  buf.i64[1] = (uint64_t)(v58 + 24);
                  int64x2_t v218 = v64;
                  uint64_t v66 = v224;
                  uint64_t v224 = &v57[24 * v56];
                  uint64_t v219 = v66;
                  std::string __p = (void *)v64.i64[0];
                  sub_1002B4440((uint64_t)&__p);
                  buf.i64[1] = (uint64_t)v65;
                  if (SHIBYTE(v222) < 0) {
                    operator delete((void *)v221);
                  }
                }
                else
                {
                  long long v53 = v221;
                  *(void *)(buf.i64[1] + 16) = v222;
                  *int v52 = v53;
                  uint64_t v222 = 0;
                  long long v221 = 0uLL;
                  buf.i64[1] = (uint64_t)v52 + 24;
                }

                id v67 = [v9 serialNumber];
                uint64_t v68 = (char *)[v67 UTF8String];
                if (v68) {
                  char v69 = v68;
                }
                else {
                  char v69 = "";
                }
                sub_10004191C(&v221, v69);
                BOOL v70 = (_OWORD *)buf.i64[1];
                if (buf.i64[1] >= (unint64_t)v224)
                {
                  unint64_t v72 = 0xAAAAAAAAAAAAAAABLL * ((buf.i64[1] - buf.i64[0]) >> 3);
                  unint64_t v73 = v72 + 1;
                  if (v72 + 1 > 0xAAAAAAAAAAAAAAALL) {
                    abort();
                  }
                  if (0x5555555555555556 * ((uint64_t)&v224[-buf.i64[0]] >> 3) > v73) {
                    unint64_t v73 = 0x5555555555555556 * ((uint64_t)&v224[-buf.i64[0]] >> 3);
                  }
                  if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)&v224[-buf.i64[0]] >> 3) >= 0x555555555555555) {
                    unint64_t v74 = 0xAAAAAAAAAAAAAAALL;
                  }
                  else {
                    unint64_t v74 = v73;
                  }
                  uint64_t v220 = &v224;
                  if (v74) {
                    int v75 = (char *)sub_1002B3440((uint64_t)&v224, v74);
                  }
                  else {
                    int v75 = 0;
                  }
                  int v76 = &v75[24 * v72];
                  long long v77 = v221;
                  *((void *)v76 + 2) = v222;
                  *(_OWORD *)int v76 = v77;
                  uint64_t v222 = 0;
                  long long v221 = 0uLL;
                  uint64_t v78 = buf.i64[1];
                  uint64_t v79 = buf.i64[0];
                  if (buf.i64[1] == buf.i64[0])
                  {
                    int64x2_t v82 = vdupq_n_s64(buf.u64[1]);
                    int v80 = &v75[24 * v72];
                  }
                  else
                  {
                    int v80 = &v75[24 * v72];
                    do
                    {
                      long long v81 = *(_OWORD *)(v78 - 24);
                      *((void *)v80 - 1) = *(void *)(v78 - 8);
                      *(_OWORD *)(v80 - 24) = v81;
                      v80 -= 24;
                      *(void *)(v78 - 16) = 0;
                      *(void *)(v78 - 8) = 0;
                      *(void *)(v78 - 24) = 0;
                      v78 -= 24;
                    }
                    while (v78 != v79);
                    int64x2_t v82 = buf;
                  }
                  uint64_t v83 = v76 + 24;
                  buf.i64[0] = (uint64_t)v80;
                  buf.i64[1] = (uint64_t)(v76 + 24);
                  int64x2_t v218 = v82;
                  uint64_t v84 = v224;
                  uint64_t v224 = &v75[24 * v74];
                  uint64_t v219 = v84;
                  std::string __p = (void *)v82.i64[0];
                  sub_1002B4440((uint64_t)&__p);
                  buf.i64[1] = (uint64_t)v83;
                  if (SHIBYTE(v222) < 0) {
                    operator delete((void *)v221);
                  }
                }
                else
                {
                  long long v71 = v221;
                  *(void *)(buf.i64[1] + 16) = v222;
                  *BOOL v70 = v71;
                  uint64_t v222 = 0;
                  long long v221 = 0uLL;
                  buf.i64[1] = (uint64_t)v70 + 24;
                }

                id v85 = [v9 firmwareRevisionActive];
                id v86 = (char *)[v85 UTF8String];
                if (v86) {
                  __int16 v87 = v86;
                }
                else {
                  __int16 v87 = "";
                }
                sub_10004191C(&v221, v87);
                uint64_t v88 = (_OWORD *)buf.i64[1];
                if (buf.i64[1] >= (unint64_t)v224)
                {
                  unint64_t v90 = 0xAAAAAAAAAAAAAAABLL * ((buf.i64[1] - buf.i64[0]) >> 3);
                  unint64_t v91 = v90 + 1;
                  if (v90 + 1 > 0xAAAAAAAAAAAAAAALL) {
                    abort();
                  }
                  if (0x5555555555555556 * ((uint64_t)&v224[-buf.i64[0]] >> 3) > v91) {
                    unint64_t v91 = 0x5555555555555556 * ((uint64_t)&v224[-buf.i64[0]] >> 3);
                  }
                  if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)&v224[-buf.i64[0]] >> 3) >= 0x555555555555555) {
                    unint64_t v92 = 0xAAAAAAAAAAAAAAALL;
                  }
                  else {
                    unint64_t v92 = v91;
                  }
                  uint64_t v220 = &v224;
                  if (v92) {
                    uint64_t v93 = (char *)sub_1002B3440((uint64_t)&v224, v92);
                  }
                  else {
                    uint64_t v93 = 0;
                  }
                  uint64_t v94 = &v93[24 * v90];
                  long long v95 = v221;
                  *((void *)v94 + 2) = v222;
                  *(_OWORD *)uint64_t v94 = v95;
                  uint64_t v222 = 0;
                  long long v221 = 0uLL;
                  uint64_t v96 = buf.i64[1];
                  uint64_t v97 = buf.i64[0];
                  if (buf.i64[1] == buf.i64[0])
                  {
                    int64x2_t v100 = vdupq_n_s64(buf.u64[1]);
                    BOOL v98 = &v93[24 * v90];
                  }
                  else
                  {
                    BOOL v98 = &v93[24 * v90];
                    do
                    {
                      long long v99 = *(_OWORD *)(v96 - 24);
                      *((void *)v98 - 1) = *(void *)(v96 - 8);
                      *(_OWORD *)(v98 - 24) = v99;
                      v98 -= 24;
                      *(void *)(v96 - 16) = 0;
                      *(void *)(v96 - 8) = 0;
                      *(void *)(v96 - 24) = 0;
                      v96 -= 24;
                    }
                    while (v96 != v97);
                    int64x2_t v100 = buf;
                  }
                  uint64_t v101 = v94 + 24;
                  buf.i64[0] = (uint64_t)v98;
                  buf.i64[1] = (uint64_t)(v94 + 24);
                  int64x2_t v218 = v100;
                  int64_t v102 = v224;
                  uint64_t v224 = &v93[24 * v92];
                  uint64_t v219 = v102;
                  std::string __p = (void *)v100.i64[0];
                  sub_1002B4440((uint64_t)&__p);
                  buf.i64[1] = (uint64_t)v101;
                  if (SHIBYTE(v222) < 0) {
                    operator delete((void *)v221);
                  }
                }
                else
                {
                  long long v89 = v221;
                  *(void *)(buf.i64[1] + 16) = v222;
                  *uint64_t v88 = v89;
                  uint64_t v222 = 0;
                  long long v221 = 0uLL;
                  buf.i64[1] = (uint64_t)v88 + 24;
                }

                id v103 = [v9 firmwareRevisionPending];
                int64_t v104 = (char *)[v103 UTF8String];
                if (v104) {
                  __int16 v105 = v104;
                }
                else {
                  __int16 v105 = "";
                }
                sub_10004191C(&v221, v105);
                unint64_t v106 = (_OWORD *)buf.i64[1];
                if (buf.i64[1] >= (unint64_t)v224)
                {
                  unint64_t v108 = 0xAAAAAAAAAAAAAAABLL * ((buf.i64[1] - buf.i64[0]) >> 3);
                  unint64_t v109 = v108 + 1;
                  if (v108 + 1 > 0xAAAAAAAAAAAAAAALL) {
                    abort();
                  }
                  if (0x5555555555555556 * ((uint64_t)&v224[-buf.i64[0]] >> 3) > v109) {
                    unint64_t v109 = 0x5555555555555556 * ((uint64_t)&v224[-buf.i64[0]] >> 3);
                  }
                  if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)&v224[-buf.i64[0]] >> 3) >= 0x555555555555555) {
                    unint64_t v110 = 0xAAAAAAAAAAAAAAALL;
                  }
                  else {
                    unint64_t v110 = v109;
                  }
                  uint64_t v220 = &v224;
                  if (v110) {
                    uint64_t v111 = (char *)sub_1002B3440((uint64_t)&v224, v110);
                  }
                  else {
                    uint64_t v111 = 0;
                  }
                  uint64_t v112 = &v111[24 * v108];
                  long long v113 = v221;
                  *((void *)v112 + 2) = v222;
                  *(_OWORD *)uint64_t v112 = v113;
                  uint64_t v222 = 0;
                  long long v221 = 0uLL;
                  uint64_t v114 = buf.i64[1];
                  uint64_t v115 = buf.i64[0];
                  if (buf.i64[1] == buf.i64[0])
                  {
                    int64x2_t v118 = vdupq_n_s64(buf.u64[1]);
                    uint64_t v116 = &v111[24 * v108];
                  }
                  else
                  {
                    uint64_t v116 = &v111[24 * v108];
                    do
                    {
                      long long v117 = *(_OWORD *)(v114 - 24);
                      *((void *)v116 - 1) = *(void *)(v114 - 8);
                      *(_OWORD *)(v116 - 24) = v117;
                      v116 -= 24;
                      *(void *)(v114 - 16) = 0;
                      *(void *)(v114 - 8) = 0;
                      *(void *)(v114 - 24) = 0;
                      v114 -= 24;
                    }
                    while (v114 != v115);
                    int64x2_t v118 = buf;
                  }
                  long long v119 = v112 + 24;
                  buf.i64[0] = (uint64_t)v116;
                  buf.i64[1] = (uint64_t)(v112 + 24);
                  int64x2_t v218 = v118;
                  long long v120 = v224;
                  uint64_t v224 = &v111[24 * v110];
                  uint64_t v219 = v120;
                  std::string __p = (void *)v118.i64[0];
                  sub_1002B4440((uint64_t)&__p);
                  buf.i64[1] = (uint64_t)v119;
                  if (SHIBYTE(v222) < 0) {
                    operator delete((void *)v221);
                  }
                }
                else
                {
                  long long v107 = v221;
                  *(void *)(buf.i64[1] + 16) = v222;
                  *unint64_t v106 = v107;
                  uint64_t v222 = 0;
                  long long v221 = 0uLL;
                  buf.i64[1] = (uint64_t)v106 + 24;
                }

                id v121 = [v9 hardwareRevision];
                uint64_t v122 = (char *)[v121 UTF8String];
                if (v122) {
                  uint64_t v123 = v122;
                }
                else {
                  uint64_t v123 = "";
                }
                sub_10004191C(&v221, v123);
                uint64_t v124 = (_OWORD *)buf.i64[1];
                if (buf.i64[1] >= (unint64_t)v224)
                {
                  unint64_t v126 = 0xAAAAAAAAAAAAAAABLL * ((buf.i64[1] - buf.i64[0]) >> 3);
                  unint64_t v127 = v126 + 1;
                  if (v126 + 1 > 0xAAAAAAAAAAAAAAALL) {
                    abort();
                  }
                  if (0x5555555555555556 * ((uint64_t)&v224[-buf.i64[0]] >> 3) > v127) {
                    unint64_t v127 = 0x5555555555555556 * ((uint64_t)&v224[-buf.i64[0]] >> 3);
                  }
                  if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)&v224[-buf.i64[0]] >> 3) >= 0x555555555555555) {
                    unint64_t v128 = 0xAAAAAAAAAAAAAAALL;
                  }
                  else {
                    unint64_t v128 = v127;
                  }
                  uint64_t v220 = &v224;
                  if (v128) {
                    uint64_t v129 = (char *)sub_1002B3440((uint64_t)&v224, v128);
                  }
                  else {
                    uint64_t v129 = 0;
                  }
                  std::string v130 = &v129[24 * v126];
                  long long v131 = v221;
                  *((void *)v130 + 2) = v222;
                  *(_OWORD *)std::string v130 = v131;
                  uint64_t v222 = 0;
                  long long v221 = 0uLL;
                  uint64_t v132 = buf.i64[1];
                  uint64_t v133 = buf.i64[0];
                  if (buf.i64[1] == buf.i64[0])
                  {
                    int64x2_t v136 = vdupq_n_s64(buf.u64[1]);
                    uint64_t v134 = &v129[24 * v126];
                  }
                  else
                  {
                    uint64_t v134 = &v129[24 * v126];
                    do
                    {
                      long long v135 = *(_OWORD *)(v132 - 24);
                      *((void *)v134 - 1) = *(void *)(v132 - 8);
                      *(_OWORD *)(v134 - 24) = v135;
                      v134 -= 24;
                      *(void *)(v132 - 16) = 0;
                      *(void *)(v132 - 8) = 0;
                      *(void *)(v132 - 24) = 0;
                      v132 -= 24;
                    }
                    while (v132 != v133);
                    int64x2_t v136 = buf;
                  }
                  uint64_t v137 = v130 + 24;
                  buf.i64[0] = (uint64_t)v134;
                  buf.i64[1] = (uint64_t)(v130 + 24);
                  int64x2_t v218 = v136;
                  uint64_t v138 = v224;
                  uint64_t v224 = &v129[24 * v128];
                  uint64_t v219 = v138;
                  std::string __p = (void *)v136.i64[0];
                  sub_1002B4440((uint64_t)&__p);
                  buf.i64[1] = (uint64_t)v137;
                  if (SHIBYTE(v222) < 0) {
                    operator delete((void *)v221);
                  }
                }
                else
                {
                  long long v125 = v221;
                  *(void *)(buf.i64[1] + 16) = v222;
                  *uint64_t v124 = v125;
                  uint64_t v222 = 0;
                  long long v221 = 0uLL;
                  buf.i64[1] = (uint64_t)v124 + 24;
                }

                sub_10004191C(&v221, "");
                uint64_t v139 = (_OWORD *)buf.i64[1];
                if (buf.i64[1] >= (unint64_t)v224)
                {
                  unint64_t v141 = 0xAAAAAAAAAAAAAAABLL * ((buf.i64[1] - buf.i64[0]) >> 3);
                  unint64_t v142 = v141 + 1;
                  if (v141 + 1 > 0xAAAAAAAAAAAAAAALL) {
                    abort();
                  }
                  if (0x5555555555555556 * ((uint64_t)&v224[-buf.i64[0]] >> 3) > v142) {
                    unint64_t v142 = 0x5555555555555556 * ((uint64_t)&v224[-buf.i64[0]] >> 3);
                  }
                  if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)&v224[-buf.i64[0]] >> 3) >= 0x555555555555555) {
                    unint64_t v143 = 0xAAAAAAAAAAAAAAALL;
                  }
                  else {
                    unint64_t v143 = v142;
                  }
                  uint64_t v220 = &v224;
                  if (v143) {
                    uint64_t v144 = (char *)sub_1002B3440((uint64_t)&v224, v143);
                  }
                  else {
                    uint64_t v144 = 0;
                  }
                  uint64_t v145 = &v144[24 * v141];
                  long long v146 = v221;
                  *((void *)v145 + 2) = v222;
                  *(_OWORD *)uint64_t v145 = v146;
                  uint64_t v222 = 0;
                  long long v221 = 0uLL;
                  uint64_t v147 = buf.i64[1];
                  uint64_t v148 = buf.i64[0];
                  if (buf.i64[1] == buf.i64[0])
                  {
                    int64x2_t v151 = vdupq_n_s64(buf.u64[1]);
                    long long v149 = &v144[24 * v141];
                  }
                  else
                  {
                    long long v149 = &v144[24 * v141];
                    do
                    {
                      long long v150 = *(_OWORD *)(v147 - 24);
                      *((void *)v149 - 1) = *(void *)(v147 - 8);
                      *(_OWORD *)(v149 - 24) = v150;
                      v149 -= 24;
                      *(void *)(v147 - 16) = 0;
                      *(void *)(v147 - 8) = 0;
                      *(void *)(v147 - 24) = 0;
                      v147 -= 24;
                    }
                    while (v147 != v148);
                    int64x2_t v151 = buf;
                  }
                  uint64_t v152 = v145 + 24;
                  buf.i64[0] = (uint64_t)v149;
                  buf.i64[1] = (uint64_t)(v145 + 24);
                  int64x2_t v218 = v151;
                  uint64_t v153 = v224;
                  uint64_t v224 = &v144[24 * v143];
                  uint64_t v219 = v153;
                  std::string __p = (void *)v151.i64[0];
                  sub_1002B4440((uint64_t)&__p);
                  buf.i64[1] = (uint64_t)v152;
                  if (SHIBYTE(v222) < 0) {
                    operator delete((void *)v221);
                  }
                }
                else
                {
                  long long v140 = v221;
                  *(void *)(buf.i64[1] + 16) = v222;
                  *uint64_t v139 = v140;
                  buf.i64[1] = (uint64_t)v139 + 24;
                }
                sub_10004191C(&v221, "");
                uint64_t v154 = (_OWORD *)buf.i64[1];
                if (buf.i64[1] >= (unint64_t)v224)
                {
                  unint64_t v156 = 0xAAAAAAAAAAAAAAABLL * ((buf.i64[1] - buf.i64[0]) >> 3);
                  unint64_t v157 = v156 + 1;
                  if (v156 + 1 > 0xAAAAAAAAAAAAAAALL) {
                    abort();
                  }
                  if (0x5555555555555556 * ((uint64_t)&v224[-buf.i64[0]] >> 3) > v157) {
                    unint64_t v157 = 0x5555555555555556 * ((uint64_t)&v224[-buf.i64[0]] >> 3);
                  }
                  if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)&v224[-buf.i64[0]] >> 3) >= 0x555555555555555) {
                    unint64_t v158 = 0xAAAAAAAAAAAAAAALL;
                  }
                  else {
                    unint64_t v158 = v157;
                  }
                  uint64_t v220 = &v224;
                  if (v158) {
                    uint64_t v159 = (char *)sub_1002B3440((uint64_t)&v224, v158);
                  }
                  else {
                    uint64_t v159 = 0;
                  }
                  uint64_t v160 = &v159[24 * v156];
                  long long v161 = v221;
                  *((void *)v160 + 2) = v222;
                  *(_OWORD *)uint64_t v160 = v161;
                  uint64_t v222 = 0;
                  long long v221 = 0uLL;
                  uint64_t v162 = buf.i64[1];
                  uint64_t v163 = buf.i64[0];
                  if (buf.i64[1] == buf.i64[0])
                  {
                    int64x2_t v166 = vdupq_n_s64(buf.u64[1]);
                    uint64_t v164 = &v159[24 * v156];
                  }
                  else
                  {
                    uint64_t v164 = &v159[24 * v156];
                    do
                    {
                      long long v165 = *(_OWORD *)(v162 - 24);
                      *((void *)v164 - 1) = *(void *)(v162 - 8);
                      *(_OWORD *)(v164 - 24) = v165;
                      v164 -= 24;
                      *(void *)(v162 - 16) = 0;
                      *(void *)(v162 - 8) = 0;
                      *(void *)(v162 - 24) = 0;
                      v162 -= 24;
                    }
                    while (v162 != v163);
                    int64x2_t v166 = buf;
                  }
                  uint64_t v167 = v160 + 24;
                  buf.i64[0] = (uint64_t)v164;
                  buf.i64[1] = (uint64_t)(v160 + 24);
                  int64x2_t v218 = v166;
                  int v168 = v224;
                  uint64_t v224 = &v159[24 * v158];
                  uint64_t v219 = v168;
                  std::string __p = (void *)v166.i64[0];
                  sub_1002B4440((uint64_t)&__p);
                  buf.i64[1] = (uint64_t)v167;
                  if (SHIBYTE(v222) < 0) {
                    operator delete((void *)v221);
                  }
                }
                else
                {
                  long long v155 = v221;
                  *(void *)(buf.i64[1] + 16) = v222;
                  *uint64_t v154 = v155;
                  buf.i64[1] = (uint64_t)v154 + 24;
                }
                sub_10004191C(&v221, "");
                uint64_t v169 = (_OWORD *)buf.i64[1];
                if (buf.i64[1] >= (unint64_t)v224)
                {
                  unint64_t v171 = 0xAAAAAAAAAAAAAAABLL * ((buf.i64[1] - buf.i64[0]) >> 3);
                  unint64_t v172 = v171 + 1;
                  if (v171 + 1 > 0xAAAAAAAAAAAAAAALL) {
                    abort();
                  }
                  if (0x5555555555555556 * ((uint64_t)&v224[-buf.i64[0]] >> 3) > v172) {
                    unint64_t v172 = 0x5555555555555556 * ((uint64_t)&v224[-buf.i64[0]] >> 3);
                  }
                  if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)&v224[-buf.i64[0]] >> 3) >= 0x555555555555555) {
                    unint64_t v173 = 0xAAAAAAAAAAAAAAALL;
                  }
                  else {
                    unint64_t v173 = v172;
                  }
                  uint64_t v220 = &v224;
                  if (v173) {
                    uint64_t v174 = (char *)sub_1002B3440((uint64_t)&v224, v173);
                  }
                  else {
                    uint64_t v174 = 0;
                  }
                  uint64_t v175 = &v174[24 * v171];
                  long long v176 = v221;
                  *((void *)v175 + 2) = v222;
                  *(_OWORD *)uint64_t v175 = v176;
                  uint64_t v222 = 0;
                  long long v221 = 0uLL;
                  uint64_t v177 = buf.i64[1];
                  uint64_t v178 = buf.i64[0];
                  if (buf.i64[1] == buf.i64[0])
                  {
                    int64x2_t v181 = vdupq_n_s64(buf.u64[1]);
                    uint64_t v179 = &v174[24 * v171];
                  }
                  else
                  {
                    uint64_t v179 = &v174[24 * v171];
                    do
                    {
                      long long v180 = *(_OWORD *)(v177 - 24);
                      *((void *)v179 - 1) = *(void *)(v177 - 8);
                      *(_OWORD *)(v179 - 24) = v180;
                      v179 -= 24;
                      *(void *)(v177 - 16) = 0;
                      *(void *)(v177 - 8) = 0;
                      *(void *)(v177 - 24) = 0;
                      v177 -= 24;
                    }
                    while (v177 != v178);
                    int64x2_t v181 = buf;
                  }
                  uint64_t v182 = v175 + 24;
                  buf.i64[0] = (uint64_t)v179;
                  buf.i64[1] = (uint64_t)(v175 + 24);
                  int64x2_t v218 = v181;
                  uint64_t v183 = v224;
                  uint64_t v224 = &v174[24 * v173];
                  uint64_t v219 = v183;
                  std::string __p = (void *)v181.i64[0];
                  sub_1002B4440((uint64_t)&__p);
                  buf.i64[1] = (uint64_t)v182;
                  if (SHIBYTE(v222) < 0) {
                    operator delete((void *)v221);
                  }
                }
                else
                {
                  long long v170 = v221;
                  *(void *)(buf.i64[1] + 16) = v222;
                  *uint64_t v169 = v170;
                  buf.i64[1] = (uint64_t)v169 + 24;
                }
                id v184 = [v9 firmwareRevision];
                uint64_t v185 = (char *)[v184 UTF8String];
                if (v185) {
                  uint64_t v186 = v185;
                }
                else {
                  uint64_t v186 = "";
                }
                sub_10004191C(&v221, v186);
                uint64_t v187 = (_OWORD *)buf.i64[1];
                if (buf.i64[1] >= (unint64_t)v224)
                {
                  unint64_t v189 = 0xAAAAAAAAAAAAAAABLL * ((buf.i64[1] - buf.i64[0]) >> 3);
                  unint64_t v190 = v189 + 1;
                  if (v189 + 1 > 0xAAAAAAAAAAAAAAALL) {
                    abort();
                  }
                  if (0x5555555555555556 * ((uint64_t)&v224[-buf.i64[0]] >> 3) > v190) {
                    unint64_t v190 = 0x5555555555555556 * ((uint64_t)&v224[-buf.i64[0]] >> 3);
                  }
                  if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)&v224[-buf.i64[0]] >> 3) >= 0x555555555555555) {
                    unint64_t v191 = 0xAAAAAAAAAAAAAAALL;
                  }
                  else {
                    unint64_t v191 = v190;
                  }
                  uint64_t v220 = &v224;
                  if (v191) {
                    unsigned int v192 = (char *)sub_1002B3440((uint64_t)&v224, v191);
                  }
                  else {
                    unsigned int v192 = 0;
                  }
                  unsigned __int8 v193 = &v192[24 * v189];
                  long long v194 = v221;
                  *((void *)v193 + 2) = v222;
                  *(_OWORD *)unsigned __int8 v193 = v194;
                  uint64_t v222 = 0;
                  long long v221 = 0uLL;
                  uint64_t v195 = buf.i64[1];
                  uint64_t v196 = buf.i64[0];
                  if (buf.i64[1] == buf.i64[0])
                  {
                    int64x2_t v199 = vdupq_n_s64(buf.u64[1]);
                    uint64_t v197 = &v192[24 * v189];
                  }
                  else
                  {
                    uint64_t v197 = &v192[24 * v189];
                    do
                    {
                      long long v198 = *(_OWORD *)(v195 - 24);
                      *((void *)v197 - 1) = *(void *)(v195 - 8);
                      *(_OWORD *)(v197 - 24) = v198;
                      v197 -= 24;
                      *(void *)(v195 - 16) = 0;
                      *(void *)(v195 - 8) = 0;
                      *(void *)(v195 - 24) = 0;
                      v195 -= 24;
                    }
                    while (v195 != v196);
                    int64x2_t v199 = buf;
                  }
                  uint64_t v200 = v193 + 24;
                  buf.i64[0] = (uint64_t)v197;
                  buf.i64[1] = (uint64_t)(v193 + 24);
                  int64x2_t v218 = v199;
                  uint64_t v201 = v224;
                  uint64_t v224 = &v192[24 * v191];
                  uint64_t v219 = v201;
                  std::string __p = (void *)v199.i64[0];
                  sub_1002B4440((uint64_t)&__p);
                  buf.i64[1] = (uint64_t)v200;
                  if (SHIBYTE(v222) < 0) {
                    operator delete((void *)v221);
                  }
                }
                else
                {
                  long long v188 = v221;
                  *(void *)(buf.i64[1] + 16) = v222;
                  *uint64_t v187 = v188;
                  uint64_t v222 = 0;
                  long long v221 = 0uLL;
                  buf.i64[1] = (uint64_t)v187 + 24;
                }

                memset(v211, 0, sizeof(v211));
                sub_1002B3390((char *)v211, (long long *)buf.i64[0], (long long *)buf.i64[1], 0xAAAAAAAAAAAAAAABLL * ((buf.i64[1] - buf.i64[0]) >> 3));
                sub_10047FFCC(a2, (uint64_t)v211);
                std::string __p = v211;
                sub_100051568((void ***)&__p);
                if (qword_1009F8080 != -1) {
                  dispatch_once(&qword_1009F8080, &stru_1009A1E50);
                }
                sub_1004A0B94((uint64_t)off_1009F8078, a2);
                v202 = qword_100A19E38;
                if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
                {
                  sub_100474E18(a2, &__p);
                  uint64_t v203 = &__p;
                  if (v218.i8[15] < 0) {
                    uint64_t v203 = __p;
                  }
                  LODWORD(v221) = 136446210;
                  *(void *)((char *)&v221 + 4) = v203;
                  _os_log_impl((void *)&_mh_execute_header, v202, OS_LOG_TYPE_DEFAULT, "Identification - Device %{public}s is a W1 device. Setting Firmware Version to 1 for Identification hash purposes.", (uint8_t *)&v221, 0xCu);
                  if (v218.i8[15] < 0) {
                    operator delete(__p);
                  }
                }
                sub_100482938(a2, 1);
                sub_100477298(a2);
                std::string __p = &buf;
                sub_100051568((void ***)&__p);
              }
            }
          }
          id v7 = [obj countByEnumeratingWithState:&v212 objects:v225 count:16];
        }
        while (v7);
      }
    }
  }
  return sub_10003AFB4((uint64_t)v216);
}

void sub_1002A5280(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, void *a15, uint64_t a16, uint64_t a17, char a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,char a30,uint64_t a31,void *__p,uint64_t a33,int a34,__int16 a35,char a36,char a37,uint64_t a38,uint64_t a39,void *a40,uint64_t a41,int a42,__int16 a43,char a44,char a45,uint64_t a46,char a47)
{
  sub_10003AFB4((uint64_t)&a30);
  _Unwind_Resume(a1);
}

void sub_1002A54B8()
{
  if (qword_1009FB140 != -1) {
    dispatch_once(&qword_1009FB140, &stru_1009A1EB0);
  }
  operator new();
}

void sub_1002A556C()
{
  if (qword_1009FB140 != -1) {
    dispatch_once(&qword_1009FB140, &stru_1009A1EB0);
  }
  operator new();
}

void sub_1002A5638()
{
  if (qword_1009FB140 != -1) {
    dispatch_once(&qword_1009FB140, &stru_1009A1EB0);
  }
  operator new();
}

void sub_1002A56FC()
{
  if (qword_1009FB140 != -1) {
    dispatch_once(&qword_1009FB140, &stru_1009A1EB0);
  }
  operator new();
}

void sub_1002A57B0()
{
}

void sub_1002A57D4()
{
  if (qword_1009FB140 != -1) {
    dispatch_once(&qword_1009FB140, &stru_1009A1EB0);
  }
  operator new();
}

void sub_1002A58D8()
{
}

void sub_1002A58FC()
{
  if (qword_1009FB140 != -1) {
    dispatch_once(&qword_1009FB140, &stru_1009A1EB0);
  }
  operator new();
}

void sub_1002A5A00()
{
}

void sub_1002A5A24()
{
  if (qword_1009FB140 != -1) {
    dispatch_once(&qword_1009FB140, &stru_1009A1EB0);
  }
  operator new();
}

void sub_1002A5AEC()
{
  if (qword_1009FB140 != -1) {
    dispatch_once(&qword_1009FB140, &stru_1009A1EB0);
  }
  operator new();
}

void sub_1002A5BB4(unsigned __int8 *a1, unsigned __int8 *a2, char a3, char a4)
{
  uint64_t v4 = *a1;
  uint64_t v5 = a1[1];
  uint64_t v6 = a1[2];
  uint64_t v7 = a1[3];
  uint64_t v8 = a1[4];
  uint64_t v9 = a1[5];
  uint64_t v10 = *a2;
  uint64_t v11 = a2[1];
  uint64_t v12 = a2[2];
  uint64_t v13 = a2[3];
  uint64_t v14 = a2[4];
  uint64_t v15 = a2[5];
  if (qword_1009FB140 != -1)
  {
    char v18 = a3;
    char v19 = a4;
    uint64_t v16 = a1[5];
    uint64_t v17 = a1[4];
    dispatch_once(&qword_1009FB140, &stru_1009A1EB0);
    uint64_t v9 = v16;
    uint64_t v8 = v17;
    a3 = v18;
    a4 = v19;
  }
  v20[0] = _NSConcreteStackBlock;
  v20[1] = 3221225472;
  void v20[2] = sub_1002A5CF0;
  v20[3] = &unk_1009988A0;
  v20[4] = (v4 << 40) | (v5 << 32) | (v6 << 24) | (v7 << 16) | (v8 << 8) | v9;
  v20[5] = (v10 << 40) | (v11 << 32) | (v12 << 24) | (v13 << 16) | (v14 << 8) | v15;
  char v21 = a3;
  char v22 = a4;
  sub_1004C9DF0((uint64_t)off_1009FB138, v20);
}

uint64_t sub_1002A5CF0(uint64_t a1)
{
  if (qword_1009F80A0 != -1) {
    dispatch_once(&qword_1009F80A0, &stru_1009A1E90);
  }
  uint64_t v2 = off_1009F8098;
  uint64_t v3 = *(void *)(a1 + 32);
  unint64_t v4 = *(void *)(a1 + 40);
  int v5 = *(unsigned __int8 *)(a1 + 48);
  int v6 = *(unsigned __int8 *)(a1 + 49);

  return sub_100298D1C((uint64_t)v2, v3, v4, v5, v6);
}

void sub_1002A5D5C(unsigned __int8 *a1, unsigned __int8 *a2, int a3)
{
  uint64_t v3 = *a1;
  uint64_t v4 = a1[1];
  uint64_t v5 = a1[2];
  uint64_t v6 = a1[3];
  uint64_t v7 = a1[4];
  uint64_t v8 = a1[5];
  uint64_t v9 = *a2;
  uint64_t v10 = a2[1];
  uint64_t v11 = a2[2];
  uint64_t v12 = a2[3];
  uint64_t v13 = a2[4];
  uint64_t v14 = a2[5];
  if (qword_1009FB140 != -1)
  {
    int v17 = a3;
    uint64_t v15 = *a1;
    uint64_t v16 = a1[5];
    dispatch_once(&qword_1009FB140, &stru_1009A1EB0);
    uint64_t v3 = v15;
    uint64_t v8 = v16;
    a3 = v17;
  }
  v18[0] = _NSConcreteStackBlock;
  v18[1] = 3221225472;
  void v18[2] = sub_1002A5E94;
  v18[3] = &unk_100998280;
  v18[4] = (v3 << 40) | (v4 << 32) | (v5 << 24) | (v6 << 16) | (v7 << 8) | v8;
  void v18[5] = (v9 << 40) | (v10 << 32) | (v11 << 24) | (v12 << 16) | (v13 << 8) | v14;
  int v19 = a3;
  sub_1004C9DF0((uint64_t)off_1009FB138, v18);
}

void sub_1002A5E94(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (qword_1009F80A0 != -1) {
    dispatch_once(&qword_1009F80A0, &stru_1009A1E90);
  }
  uint64_t v4 = off_1009F8098;
  uint64_t v5 = *(void *)(a1 + 32);
  int v6 = *(_DWORD *)(a1 + 48);

  sub_100298F78((uint64_t)v4, v5, a3, v6);
}

void sub_1002A5EFC()
{
  if (qword_1009FB140 != -1) {
    dispatch_once(&qword_1009FB140, &stru_1009A1EB0);
  }
  operator new();
}

void sub_1002A5FD4()
{
  if (qword_1009FB140 != -1) {
    dispatch_once(&qword_1009FB140, &stru_1009A1EB0);
  }
  operator new();
}

void sub_1002A60AC()
{
  if (qword_1009FB140 != -1) {
    dispatch_once(&qword_1009FB140, &stru_1009A1EB0);
  }
  operator new();
}

void sub_1002A6170()
{
  if (qword_1009FB140 != -1) {
    dispatch_once(&qword_1009FB140, &stru_1009A1EB0);
  }
  operator new();
}

void sub_1002A6224()
{
}

void sub_1002A6248()
{
  if (qword_1009FB140 != -1) {
    dispatch_once(&qword_1009FB140, &stru_1009A1EB0);
  }
  operator new();
}

void sub_1002A6324()
{
  if (qword_1009FB140 != -1) {
    dispatch_once(&qword_1009FB140, &stru_1009A1EB0);
  }
  operator new();
}

void sub_1002A642C()
{
}

void sub_1002A6450()
{
  if (qword_1009FB140 != -1) {
    dispatch_once(&qword_1009FB140, &stru_1009A1EB0);
  }
  operator new();
}

void sub_1002A6514()
{
  if (qword_1009FB140 != -1) {
    dispatch_once(&qword_1009FB140, &stru_1009A1EB0);
  }
  operator new();
}

void sub_1002A65E0()
{
  if (qword_1009FB140 != -1) {
    dispatch_once(&qword_1009FB140, &stru_1009A1EB0);
  }
  operator new();
}

void sub_1002A66E8()
{
}

void sub_1002A670C()
{
  if (qword_1009FB140 != -1) {
    dispatch_once(&qword_1009FB140, &stru_1009A1EB0);
  }
  operator new();
}

void sub_1002A6814()
{
}

void sub_1002A6838()
{
  if (qword_1009FB140 != -1) {
    dispatch_once(&qword_1009FB140, &stru_1009A1EB0);
  }
  operator new();
}

void sub_1002A6938()
{
}

void sub_1002A695C()
{
  if (qword_1009FB140 != -1) {
    dispatch_once(&qword_1009FB140, &stru_1009A1EB0);
  }
  operator new();
}

void sub_1002A6A74()
{
}

void sub_1002A6A98()
{
  if (qword_1009FB140 != -1) {
    dispatch_once(&qword_1009FB140, &stru_1009A1EB0);
  }
  operator new();
}

void sub_1002A6B34()
{
}

void sub_1002A6B58()
{
  if (qword_1009FB140 != -1) {
    dispatch_once(&qword_1009FB140, &stru_1009A1EB0);
  }
  operator new();
}

void sub_1002A6C6C()
{
}

void sub_1002A6C90()
{
  if (qword_1009FB140 != -1) {
    dispatch_once(&qword_1009FB140, &stru_1009A1EB0);
  }
  operator new();
}

void sub_1002A6D7C()
{
}

void sub_1002A6DA0()
{
  if (qword_1009FB140 != -1) {
    dispatch_once(&qword_1009FB140, &stru_1009A1EB0);
  }
  operator new();
}

void sub_1002A6E54()
{
}

void sub_1002A6E78()
{
  if (qword_1009FB140 != -1) {
    dispatch_once(&qword_1009FB140, &stru_1009A1EB0);
  }
  operator new();
}

void sub_1002A6F24()
{
}

void sub_1002A6F48()
{
  if (qword_1009FB140 != -1) {
    dispatch_once(&qword_1009FB140, &stru_1009A1EB0);
  }
  operator new();
}

void sub_1002A6FF4()
{
}

void sub_1002A7018()
{
  if (qword_1009FB140 != -1) {
    dispatch_once(&qword_1009FB140, &stru_1009A1EB0);
  }
  operator new();
}

void sub_1002A70DC()
{
  if (qword_1009FB140 != -1) {
    dispatch_once(&qword_1009FB140, &stru_1009A1EB0);
  }
  operator new();
}

void sub_1002A7188()
{
}

void sub_1002A71AC()
{
  if (qword_1009FB140 != -1) {
    dispatch_once(&qword_1009FB140, &stru_1009A1EB0);
  }
  operator new();
}

void sub_1002A7270()
{
}

void sub_1002A7294()
{
  if (qword_1009FB140 != -1) {
    dispatch_once(&qword_1009FB140, &stru_1009A1EB0);
  }
  operator new();
}

void sub_1002A73AC()
{
}

void sub_1002A73D0()
{
  if (qword_1009FB140 != -1) {
    dispatch_once(&qword_1009FB140, &stru_1009A1EB0);
  }
  operator new();
}

void sub_1002A74D0()
{
}

void sub_1002A74F4()
{
  if (qword_1009FB140 != -1) {
    dispatch_once(&qword_1009FB140, &stru_1009A1EB0);
  }
  operator new();
}

void sub_1002A75A0()
{
}

void sub_1002A75C4()
{
  if (qword_1009FB140 != -1) {
    dispatch_once(&qword_1009FB140, &stru_1009A1EB0);
  }
  operator new();
}

void sub_1002A7678()
{
}

void sub_1002A769C()
{
  if (qword_1009FB140 != -1) {
    dispatch_once(&qword_1009FB140, &stru_1009A1EB0);
  }
  operator new();
}

void sub_1002A7748()
{
}

void sub_1002A776C()
{
  if (qword_1009FB140 != -1) {
    dispatch_once(&qword_1009FB140, &stru_1009A1EB0);
  }
  operator new();
}

void sub_1002A7820()
{
}

void sub_1002A7844()
{
  if (qword_1009FB140 != -1) {
    dispatch_once(&qword_1009FB140, &stru_1009A1EB0);
  }
  operator new();
}

void sub_1002A794C()
{
}

void sub_1002A7970(uint64_t a1, uint64_t a2, unsigned __int8 *a3)
{
  if (qword_1009F7F00 != -1) {
    dispatch_once(&qword_1009F7F00, &stru_1009A1E70);
  }
  uint64_t v6 = sub_1004AA194((uint64_t)off_1009F7EF8, (uint64_t)a3, 1);
  if (*(_DWORD *)a2 == *(_DWORD *)(a1 + 424) && *(unsigned __int16 *)(a2 + 4) == *(unsigned __int16 *)(a1 + 428))
  {
    if (sub_10028B72C(a1, v6))
    {
      uint64_t v11 = qword_100A19ED8;
      if (os_log_type_enabled((os_log_t)qword_100A19ED8, OS_LOG_TYPE_DEFAULT))
      {
        sub_1004A82EC(a3, __p);
        uint64_t v12 = v17 >= 0 ? __p : (void **)__p[0];
        *(_DWORD *)int64x2_t buf = 136315138;
        int v19 = v12;
        _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "sending pair status request to magnet for device \"%s\"", buf, 0xCu);
        if (v17 < 0) {
          operator delete(__p[0]);
        }
      }
      uint64_t v13 = sub_100373068();
      sub_1004A82EC(a3, v14);
      (*(void (**)(uint64_t, void **))(*(void *)v13 + 88))(v13, v14);
      if (v15 < 0) {
        operator delete(v14[0]);
      }
    }
  }
  else
  {
    uint64_t v8 = qword_100A19ED8;
    if (os_log_type_enabled((os_log_t)qword_100A19ED8, OS_LOG_TYPE_DEFAULT))
    {
      sub_1004A82EC((unsigned __int8 *)a2, __p);
      uint64_t v9 = v17 >= 0 ? __p : (void **)__p[0];
      *(_DWORD *)int64x2_t buf = 136315138;
      int v19 = v9;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "sending pair status request to AACP device \"%s\"", buf, 0xCu);
      if (v17 < 0) {
        operator delete(__p[0]);
      }
    }
    if (qword_1009F7F00 != -1) {
      dispatch_once(&qword_1009F7F00, &stru_1009A1E70);
    }
    uint64_t v10 = sub_1004AA194((uint64_t)off_1009F7EF8, a2, 1);
    sub_100284EF0(a1, v10, (uint64_t)a3);
  }
}

void sub_1002A7BE4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1002A7C08(uint64_t a1, uint64_t a2, unsigned __int8 *a3)
{
}

void sub_1002A7C10(uint64_t a1, uint64_t a2, unsigned __int8 *a3, uint64_t a4, uint64_t a5)
{
  if (qword_1009F7F00 != -1) {
    dispatch_once(&qword_1009F7F00, &stru_1009A1E70);
  }
  uint64_t v10 = sub_1004AA194((uint64_t)off_1009F7EF8, (uint64_t)a3, 1);
  if (*(_DWORD *)a2 != *(_DWORD *)(a1 + 424) || *(unsigned __int16 *)(a2 + 4) != *(unsigned __int16 *)(a1 + 428))
  {
    if (*(unsigned char *)(a1 + 328))
    {
      uint64_t v12 = qword_100A19ED8;
      if (os_log_type_enabled((os_log_t)qword_100A19ED8, OS_LOG_TYPE_DEFAULT))
      {
        sub_1004A82EC((unsigned __int8 *)a2, __p);
        uint64_t v13 = v30 >= 0 ? __p : (void **)__p[0];
        *(_DWORD *)int64x2_t buf = 136315138;
        int v32 = v13;
        _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "sending store link key request to AACP device \"%s\"", buf, 0xCu);
        if (v30 < 0) {
          operator delete(__p[0]);
        }
      }
      if (qword_1009F7F00 != -1) {
        dispatch_once(&qword_1009F7F00, &stru_1009A1E70);
      }
      uint64_t v14 = sub_1004AA194((uint64_t)off_1009F7EF8, a2, 1);
      sub_100284D9C(a1, v14, (uint64_t)a3, a5, a4);
    }
    return;
  }
  uint64_t v15 = v10;
  if (!sub_10028B72C(a1, v10)) {
    return;
  }
  uint64_t v16 = qword_100A19ED8;
  if (os_log_type_enabled((os_log_t)qword_100A19ED8, OS_LOG_TYPE_DEFAULT))
  {
    sub_1004A82EC(a3, __p);
    char v17 = v30 >= 0 ? __p : (void **)__p[0];
    int v18 = *(unsigned __int8 *)(a1 + 432);
    *(_DWORD *)int64x2_t buf = 136315394;
    int v32 = v17;
    __int16 v33 = 1024;
    int v34 = v18;
    _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "sending store link key request to magnet link for device \"%s\" with version %d", buf, 0x12u);
    if (v30 < 0) {
      operator delete(__p[0]);
    }
  }
  if (*(unsigned __int8 *)(a1 + 432) < 5u)
  {
    uint64_t v23 = sub_100373068();
    sub_1004A82EC(a3, v25);
    sub_100475EE0(v15, (uint64_t)__p);
    if (v30 >= 0) {
      uint64_t v24 = __p;
    }
    else {
      uint64_t v24 = (void **)__p[0];
    }
    (*(void (**)(uint64_t, void **, void **, uint64_t, uint64_t))(*(void *)v23 + 104))(v23, v25, v24, a4, a5);
    if (v30 < 0) {
      operator delete(__p[0]);
    }
    if (v26 < 0)
    {
      char v22 = v25[0];
      goto LABEL_40;
    }
  }
  else
  {
    *(_DWORD *)int64x2_t buf = 0;
    sub_100476250(v15, buf);
    uint64_t v19 = sub_100373068();
    sub_1004A82EC(a3, v27);
    unint64_t v20 = __p;
    sub_100475EE0(v15, (uint64_t)__p);
    if (v30 < 0) {
      unint64_t v20 = (void **)__p[0];
    }
    if (qword_1009F8090 != -1) {
      dispatch_once(&qword_1009F8090, &stru_1009A1ED0);
    }
    uint64_t v21 = sub_1004D6124((uint64_t)off_1009F8088, v15);
    (*(void (**)(uint64_t, void *, void **, uint64_t, uint64_t, uint64_t, void))(*(void *)v19 + 112))(v19, v27, v20, a4, a5, v21, *(unsigned int *)buf);
    if (v30 < 0) {
      operator delete(__p[0]);
    }
    if (v28 < 0)
    {
      char v22 = (void *)v27[0];
LABEL_40:
      operator delete(v22);
    }
  }
}

void sub_1002A7FD8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0) {
    operator delete(__p);
  }
  if (a15 < 0) {
    operator delete(a10);
  }
  _Unwind_Resume(exception_object);
}

void sub_1002A8040(uint64_t a1, uint64_t a2, unsigned __int8 *a3, uint64_t a4, uint64_t a5)
{
}

void sub_1002A8048(uint64_t a1, uint64_t a2, unsigned __int8 *a3, int a4)
{
  if (a4 == 2)
  {
    uint64_t v6 = qword_100A19ED8;
    if (os_log_type_enabled((os_log_t)qword_100A19ED8, OS_LOG_TYPE_ERROR))
    {
      sub_1004A82EC((unsigned __int8 *)a2, v42);
      int v7 = SHIBYTE(v46);
      uint64_t v8 = *(unsigned char **)v42;
      sub_1004A82EC(a3, __p);
      uint64_t v9 = v42;
      if (v7 < 0) {
        uint64_t v9 = v8;
      }
      if (v41 >= 0) {
        uint64_t v10 = __p;
      }
      else {
        uint64_t v10 = (void **)__p[0];
      }
      *(_DWORD *)int64x2_t buf = 136315394;
      *(void *)&uint8_t buf[4] = v9;
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&unsigned char buf[14] = v10;
      _os_log_error_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, "easy pair failed between devices \"%s\" and \"%s\"", buf, 0x16u);
      if (v41 < 0) {
        operator delete(__p[0]);
      }
      if (SHIBYTE(v46) < 0) {
        operator delete(*(void **)v42);
      }
    }
  }
  else
  {
    if (*(_DWORD *)a2 == *(_DWORD *)(a1 + 424) && *(unsigned __int16 *)(a2 + 4) == *(unsigned __int16 *)(a1 + 428))
    {
      if (qword_1009F7F00 != -1) {
        dispatch_once(&qword_1009F7F00, &stru_1009A1E70);
      }
    }
    else
    {
      if (qword_1009F7F00 != -1) {
        dispatch_once(&qword_1009F7F00, &stru_1009A1E70);
      }
      a3 = (unsigned __int8 *)a2;
    }
    uint64_t v13 = sub_1004AA194((uint64_t)off_1009F7EF8, (uint64_t)a3, 1);
    *(void *)int64x2_t buf = 0;
    *(void *)&uint8_t buf[8] = 0;
    sub_10003AED0((uint64_t)buf, a1 + 360);
    if (v13)
    {
      uint64_t v14 = *(void ***)(a1 + 336);
      uint64_t v15 = *(void ***)(a1 + 344);
      if (v14 != v15)
      {
        while (1)
        {
          uint64_t v16 = *v14;
          if (**v14 == v13) {
            break;
          }
          if (++v14 == v15) {
            goto LABEL_56;
          }
        }
        uint64_t v17 = sub_100035F54();
        if ((*(unsigned int (**)(uint64_t))(*(void *)v17 + 328))(v17))
        {
          if (sub_10028B72C(a1, v13))
          {
            sub_10028558C(a1, v13);
            uint64_t v18 = sub_100373068();
            sub_1004A82EC((unsigned __int8 *)(v13 + 128), v36);
            (*(void (**)(uint64_t, void **, void))(*(void *)v18 + 144))(v18, v36, *((unsigned __int8 *)v16 + 10));
            if (v37 < 0) {
              operator delete(v36[0]);
            }
          }
        }
        if (sub_10028B72C(a1, v13) && sub_100298A1C((uint64_t)v16))
        {
          __int16 v35 = 0;
          int v34 = 0;
          memset(__p, 0, 12);
          if (qword_1009F8070 != -1) {
            dispatch_once(&qword_1009F8070, &stru_1009A1D70);
          }
          sub_1004E219C((uint64_t)off_1009F8068, (uint64_t)&v34);
          uint64_t v19 = sub_100035F54();
          int v20 = (*(uint64_t (**)(uint64_t))(*(void *)v19 + 328))(v19);
          uint64_t v21 = &v34;
          if (v20) {
            char v22 = &v34;
          }
          else {
            char v22 = (int *)(a1 + 424);
          }
          if (v20) {
            uint64_t v21 = (int *)(a1 + 424);
          }
          LODWORD(__p[0]) = *v22;
          WORD2(__p[0]) = *((_WORD *)v22 + 2);
          *(_DWORD *)((char *)__p + 6) = *v21;
          WORD1(__p[1]) = *((_WORD *)v21 + 2);
          if (sub_100478B2C(v13, 32)) {
            sub_100288EFC((uint64_t)v16, 2, (int *)__p, 2);
          }
          char v33 = 0;
          sub_10001B8E0(&v33);
          uint64_t v23 = (unsigned __int8 *)(v13 + 128);
          sub_1000D86C8((unsigned __int8 *)(v13 + 128), 2u, (uint64_t)__p);
          sub_10001B910(&v33);
          uint64_t v24 = qword_100A19ED8;
          if (os_log_type_enabled((os_log_t)qword_100A19ED8, OS_LOG_TYPE_DEFAULT))
          {
            sub_100474E18(v13, v42);
            uint64_t v25 = v46 >= 0 ? v42 : *(unsigned char **)v42;
            *(_DWORD *)unint64_t v38 = 136446210;
            size_t v39 = v25;
            _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "Sending message to Phone/Watch to connect to %{public}s", v38, 0xCu);
            if (SHIBYTE(v46) < 0) {
              operator delete(*(void **)v42);
            }
          }
          uint64_t v26 = sub_100373068();
          sub_1004A82EC(v23, v31);
          (*(void (**)(uint64_t, void **, void))(*(void *)v26 + 128))(v26, v31, 0);
          if (v32 < 0) {
            operator delete(v31[0]);
          }
          sub_10001B8AC(&v33);
        }
        else
        {
          long long v27 = qword_100A19ED8;
          if (os_log_type_enabled((os_log_t)qword_100A19ED8, OS_LOG_TYPE_DEFAULT))
          {
            char v28 = __p;
            sub_100474E18(v13, __p);
            if (v41 < 0) {
              char v28 = (void **)__p[0];
            }
            int v29 = sub_10028B72C(a1, v13);
            BOOL v30 = sub_100298A1C((uint64_t)v16);
            *(_DWORD *)uint64_t v42 = 136446722;
            *(void *)&v42[4] = v28;
            __int16 v43 = 1024;
            int v44 = v29;
            __int16 v45 = 1024;
            int v46 = v30;
            _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "Not establishing triangle with %{public}s (magnet check %d, triangle check %d)", v42, 0x18u);
            if (v41 < 0) {
              operator delete(__p[0]);
            }
          }
        }
        *((unsigned char *)v16 + 728) = 0;
      }
    }
LABEL_56:
    sub_10003AFB4((uint64_t)buf);
  }
}

void sub_1002A8594(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, void *a20,uint64_t a21,int a22,__int16 a23,char a24,char a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,int a31,__int16 a32,char a33,char a34,void *a35,uint64_t a36,int a37,__int16 a38,char a39,char a40)
{
  sub_10001B8AC(&a18);
  sub_10003AFB4(v40 - 80);
  _Unwind_Resume(a1);
}

void sub_1002A862C(uint64_t a1, uint64_t a2, unsigned __int8 *a3, int a4)
{
}

void sub_1002A8634(void *a1)
{
  uint64_t v2 = (uint64_t)(a1 + 3);
  uint64_t v3 = (void *)a1[3];
  uint64_t v4 = a1 + 4;
  if (v3 != a1 + 4)
  {
    do
    {
      uint64_t v5 = v3[5];
      if (v5) {
        (*(void (**)(uint64_t))(*(void *)v5 + 8))(v5);
      }
      uint64_t v6 = (void *)v3[1];
      if (v6)
      {
        do
        {
          int v7 = v6;
          uint64_t v6 = (void *)*v6;
        }
        while (v6);
      }
      else
      {
        do
        {
          int v7 = (void *)v3[2];
          BOOL v8 = *v7 == (void)v3;
          uint64_t v3 = v7;
        }
        while (!v8);
      }
      uint64_t v3 = v7;
    }
    while (v7 != v4);
  }
  if (a1[5])
  {
    sub_1000486F0(v2, (void *)a1[4]);
    a1[4] = 0;
    a1[5] = 0;
    a1[3] = v4;
  }
}

BOOL sub_1002A86F0(uint64_t a1, uint64_t a2)
{
  int v11 = a2;
  unsigned __int16 v12 = WORD2(a2);
  v10[0] = 0;
  v10[1] = 0;
  sub_10003AED0((uint64_t)v10, a1 + 360);
  uint64_t v4 = *(void *)(a1 + 336);
  uint64_t v3 = *(void *)(a1 + 344);
  if (v4 == v3)
  {
    BOOL v7 = 0;
  }
  else
  {
    uint64_t v5 = v4 + 8;
    do
    {
      int v6 = *(_DWORD *)(**(void **)(v5 - 8) + 128) ^ v11 | *(unsigned __int16 *)(**(void **)(v5 - 8) + 132) ^ v12;
      BOOL v7 = v6 == 0;
      if (v6) {
        BOOL v8 = v5 == v3;
      }
      else {
        BOOL v8 = 1;
      }
      v5 += 8;
    }
    while (!v8);
  }
  sub_10003AFB4((uint64_t)v10);
  return v7;
}

void sub_1002A8790(id a1)
{
}

uint64_t sub_1002A87A4(uint64_t result)
{
  if (*(void *)(result + 32))
  {
    uint64_t v1 = result;
    if (qword_1009FB058 != -1) {
      dispatch_once(&qword_1009FB058, &stru_1009A1F90);
    }
    uint64_t v2 = off_1009FB050;
    uint64_t v3 = *(void *)(v1 + 32);
    return sub_1005295E8((uint64_t)v2, v3);
  }
  return result;
}

uint64_t sub_1002A881C(uint64_t result)
{
  if (*(void *)(result + 32))
  {
    uint64_t v1 = result;
    if (qword_1009F8418 != -1) {
      dispatch_once(&qword_1009F8418, &stru_1009A1E10);
    }
    uint64_t v2 = (void *)qword_1009F8410;
    uint64_t v3 = *(void *)(v1 + 32);
    return sub_100414268(v2, v3);
  }
  return result;
}

uint64_t sub_1002A8894(uint64_t result)
{
  if (*(void *)(result + 32))
  {
    uint64_t v1 = result;
    if (qword_1009FB058 != -1) {
      dispatch_once(&qword_1009FB058, &stru_1009A1F90);
    }
    uint64_t v2 = off_1009FB050;
    uint64_t v3 = *(void *)(v1 + 32);
    return sub_1005296EC((uint64_t)v2, v3);
  }
  return result;
}

uint64_t sub_1002A890C(uint64_t result)
{
  if (*(void *)(result + 32))
  {
    uint64_t v1 = result;
    if (qword_1009F8418 != -1) {
      dispatch_once(&qword_1009F8418, &stru_1009A1E10);
    }
    uint64_t v2 = (void *)qword_1009F8410;
    uint64_t v3 = *(void *)(v1 + 32);
    return sub_100414444(v2, v3);
  }
  return result;
}

uint64_t sub_1002A8984(uint64_t a1)
{
  if (qword_1009FB058 != -1) {
    dispatch_once(&qword_1009FB058, &stru_1009A1F90);
  }
  uint64_t v2 = off_1009FB050;
  uint64_t v3 = *(void *)(a1 + 32);

  return sub_100529738((uint64_t)v2, v3);
}

uint64_t sub_1002A89E8(uint64_t a1)
{
  if (qword_1009FB058 != -1) {
    dispatch_once(&qword_1009FB058, &stru_1009A1F90);
  }
  uint64_t v2 = off_1009FB050;
  uint64_t v3 = *(void *)(a1 + 32);
  int v4 = *(unsigned __int8 *)(a1 + 40);

  return sub_1005297B4((uint64_t)v2, v3, v4);
}

uint64_t sub_1002A8A50(uint64_t a1)
{
  if (qword_1009F8418 != -1) {
    dispatch_once(&qword_1009F8418, &stru_1009A1E10);
  }
  uint64_t v2 = (void *)qword_1009F8410;
  uint64_t v3 = *(void *)(a1 + 32);
  int v4 = *(unsigned __int8 *)(a1 + 40);

  return sub_100414400(v2, v3, v4);
}

uint64_t sub_1002A8AB8(uint64_t result)
{
  if (*(void *)(result + 32))
  {
    uint64_t v1 = result;
    if (qword_1009FB058 != -1) {
      dispatch_once(&qword_1009FB058, &stru_1009A1F90);
    }
    uint64_t v2 = off_1009FB050;
    uint64_t v3 = *(void *)(v1 + 32);
    return sub_1005297F0((uint64_t)v2, v3);
  }
  return result;
}

uint64_t sub_1002A8B30(uint64_t result)
{
  if (*(void *)(result + 32))
  {
    uint64_t v1 = result;
    if (qword_1009F8418 != -1) {
      dispatch_once(&qword_1009F8418, &stru_1009A1E10);
    }
    uint64_t v2 = (void *)qword_1009F8410;
    uint64_t v3 = *(void *)(v1 + 32);
    return sub_100414498(v2, v3);
  }
  return result;
}

uint64_t sub_1002A8BA8(uint64_t result)
{
  if (*(void *)(result + 32))
  {
    uint64_t v1 = result;
    if (qword_1009FB058 != -1) {
      dispatch_once(&qword_1009FB058, &stru_1009A1F90);
    }
    uint64_t v2 = off_1009FB050;
    uint64_t v3 = *(void *)(v1 + 32);
    return sub_10052983C((uint64_t)v2, v3);
  }
  return result;
}

uint64_t sub_1002A8C20(uint64_t result)
{
  if (*(void *)(result + 32))
  {
    uint64_t v1 = result;
    if (qword_1009F8418 != -1) {
      dispatch_once(&qword_1009F8418, &stru_1009A1E10);
    }
    uint64_t v2 = (void *)qword_1009F8410;
    uint64_t v3 = *(void *)(v1 + 32);
    return sub_1004144EC(v2, v3);
  }
  return result;
}

void *sub_1002A8C98(void *result)
{
  if (!result[6])
  {
    uint64_t v1 = *result;
    int v2 = *(_DWORD *)(*result + 128);
    __int16 v3 = *(_WORD *)(v1 + 132);
    operator new();
  }
  return result;
}

void sub_1002A8D2C()
{
}

const char *sub_1002A8D50(uint64_t a1, int a2)
{
  if ((a2 - 1) > 0xE) {
    return "unknown";
  }
  else {
    return off_1009A2340[a2 - 1];
  }
}

uint64_t sub_1002A8D78(uint64_t a1, uint64_t a2, int a3)
{
  *(void *)a1 = a2;
  *(_DWORD *)(a1 + 8) = 50529027;
  *(unsigned char *)(a1 + 12) = 0;
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 24) = a1 + 32;
  *(_DWORD *)(a1 + 16) = 3;
  *(void *)(a1 + 40) = 0;
  int v6 = (std::string *)(a1 + 56);
  *(unsigned char *)(a1 + 84) = 0;
  *(_OWORD *)(a1 + ++*(unsigned char *)(result + 104) = 0u;
  BOOL v7 = (uint64_t *)(a1 + 104);
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 120) = 0u;
  *(_OWORD *)(a1 + 136) = 0u;
  *(unsigned char *)(a1 + 152) = 0;
  *(void *)(a1 + 416) = a1 + 416;
  *(void *)(a1 + 424) = a1 + 416;
  *(void *)(a1 + 432) = 0;
  sub_100052DA8(a1 + 440);
  *(void *)(a1 + 504) = 0;
  *(void *)(a1 + 512) = 0;
  *(void *)(a1 + 520) = 0;
  sub_100052DA8(a1 + 536);
  *(unsigned char *)(a1 + 618) = 0;
  *(_OWORD *)(a1 + 712) = 0u;
  *(unsigned char *)(a1 + 616) = 0;
  *(_OWORD *)(a1 + 600) = 0u;
  *(_OWORD *)(a1 + 624) = 0u;
  *(_OWORD *)(a1 + 640) = 0u;
  *(_OWORD *)(a1 + 656) = 0u;
  *(_OWORD *)(a1 + 672) = 0u;
  *(_OWORD *)(a1 + 688) = 0u;
  *(void *)(a1 + 704) = a1 + 712;
  *(_WORD *)(a1 + 728) = 0;
  *(void *)(a1 + 736) = 0;
  *(void *)(a1 + 752) = 0;
  *(void *)(a1 + 744) = 0;
  if ((sub_100487464(a2) & 1) == 0) {
    *(_WORD *)(a1 + 8) = 0;
  }
  memset(&__str, 0, sizeof(__str));
  uint64_t v8 = sub_1003708B0();
  if (!(*(unsigned int (**)(uint64_t, uint64_t, std::string *))(*(void *)v8 + 32))(v8, a2, &__str)) {
    std::string::operator=(v6, &__str);
  }
  uint64_t v19 = 0;
  uint64_t v9 = (_DWORD *)(a1 + 80);
  int v18 = 0;
  if (!sub_10047B7A8(a2, (_DWORD *)&v19 + 1, &v19, (_DWORD *)(a1 + 80), &v18))
  {
    if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_ERROR)) {
      sub_100750AC8();
    }
    *uint64_t v9 = 0;
  }
  uint64_t v10 = sub_100035F54();
  if (((*(uint64_t (**)(uint64_t))(*(void *)v10 + 328))(v10) & 1) != 0
    || (uint64_t v11 = sub_100035F54(), (*(unsigned int (**)(uint64_t))(*(void *)v11 + 384))(v11)))
  {
    unsigned int v12 = *v9 - 8194;
    if (v12 <= 0xE && ((1 << v12) & 0x409B) != 0)
    {
      v17[0] = _NSConcreteStackBlock;
      v17[1] = 3221225472;
      void v17[2] = sub_1002A91D8;
      v17[3] = &unk_1009A1400;
      v17[4] = a2;
      uint64_t v13 = +[NSTimer timerWithTimeInterval:0 repeats:v17 block:10.0];
      uint64_t v14 = (void *)*v7;
      *BOOL v7 = v13;

      uint64_t v15 = +[NSRunLoop mainRunLoop];
      [v15 addTimer:*v7 forMode:NSDefaultRunLoopMode];
    }
  }
  *(_DWORD *)(a1 + 93) = 0;
  *(void *)(a1 + 85) = 0;
  *(_OWORD *)(a1 + 160) = 0u;
  *(_OWORD *)(a1 + 176) = 0u;
  *(_OWORD *)(a1 + 192) = 0u;
  *(_OWORD *)(a1 + 208) = 0u;
  *(_OWORD *)(a1 + 224) = 0u;
  *(_OWORD *)(a1 + 240) = 0u;
  *(_OWORD *)(a1 + 256) = 0u;
  *(_OWORD *)(a1 + 272) = 0u;
  *(_OWORD *)(a1 + 288) = 0u;
  *(_OWORD *)(a1 + 304) = 0u;
  *(_OWORD *)(a1 + 320) = 0u;
  *(_OWORD *)(a1 + 336) = 0u;
  *(_OWORD *)(a1 + 352) = 0u;
  *(_OWORD *)(a1 + 368) = 0u;
  *(_OWORD *)(a1 + 384) = 0u;
  *(_OWORD *)(a1 + 400) = 0u;
  *(_WORD *)(a1 + 760) = -1;
  if (a3) {
    operator new();
  }
  sub_1002A9414(a1);
  *(unsigned char *)(a1 + 528) = 1;
  *(_DWORD *)(a1 + 532) = 0;
  if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__str.__r_.__value_.__l.__data_);
  }
  return a1;
}

void sub_1002A90F8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void **a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21,int a22,__int16 a23,char a24,char a25)
{
  if (a25 < 0) {
    operator delete(__p);
  }
  char v32 = *(void **)(v25 + 736);
  if (v32)
  {
    *(void *)(v25 + 744) = v32;
    operator delete(v32);
  }
  sub_1000486F0(v29, *(void **)(v25 + 712));
  char v33 = *(void **)(v25 + 680);
  if (v33)
  {
    *(void *)(v25 + 688) = v33;
    operator delete(v33);
  }
  sub_1002B2F94((void *)(v25 + 632));

  sub_100052DA4(a11);
  int v34 = *(void **)(v25 + 504);
  if (v34)
  {
    *(void *)(v25 + 512) = v34;
    operator delete(v34);
  }
  sub_100052DA4(a12);
  sub_1002B308C(v27);

  if (*(char *)(v25 + 79) < 0) {
    operator delete(*a10);
  }
  sub_1000486F0(v26, *v28);
  _Unwind_Resume(a1);
}

uint64_t sub_1002A91D8(uint64_t a1)
{
  if (qword_1009F80A0 != -1) {
    dispatch_once(&qword_1009F80A0, &stru_1009A1E90);
  }
  int v2 = off_1009F8098;
  uint64_t v3 = *(void *)(a1 + 32);

  return sub_1002A3FF8((uint64_t)v2, v3);
}

uint64_t sub_1002A923C(uint64_t a1)
{
  [*(id *)(a1 + 104) invalidate];
  int v2 = *(void **)(a1 + 104);
  *(void *)(a1 + ++*(unsigned char *)(result + 104) = 0;

  uint64_t v3 = *(void **)(a1 + 624);
  if (v3)
  {
    [v3 invalidate];
    int v4 = *(void **)(a1 + 624);
    *(void *)(a1 + 624) = 0;
  }
  uint64_t v5 = *(void *)(a1 + 48);
  if (v5)
  {
    sub_100278AB0(v5);
    goto LABEL_5;
  }
  while (1)
  {
    uint64_t v6 = *(void *)(a1 + 432);
    if (!v6) {
      break;
    }
    BOOL v7 = *(uint64_t **)(a1 + 424);
    uint64_t v8 = v7[2];
    uint64_t v9 = *v7;
    *(void *)(v9 + 8) = v7[1];
    *(void *)v7[1] = v9;
    *(void *)(a1 + 432) = v6 - 1;
    operator delete(v7);
    if (v8)
    {
      if (*(void *)(v8 + 8)) {
        operator delete[]();
      }
LABEL_5:
      operator delete();
    }
  }
  uint64_t v10 = *(void *)(a1 + 768);
  if (v10) {
    (*(void (**)(uint64_t))(*(void *)v10 + 8))(v10);
  }
  sub_1002A9414(a1);
  uint64_t v11 = *(void **)(a1 + 736);
  if (v11)
  {
    *(void *)(a1 + 744) = v11;
    operator delete(v11);
  }
  sub_1000486F0(a1 + 704, *(void **)(a1 + 712));
  unsigned int v12 = *(void **)(a1 + 680);
  if (v12)
  {
    *(void *)(a1 + 688) = v12;
    operator delete(v12);
  }
  sub_1002B2F94((void *)(a1 + 632));

  sub_100052DA4(a1 + 536);
  uint64_t v13 = *(void **)(a1 + 504);
  if (v13)
  {
    *(void *)(a1 + 512) = v13;
    operator delete(v13);
  }
  sub_100052DA4(a1 + 440);
  sub_1002B308C((void *)(a1 + 416));

  if (*(char *)(a1 + 79) < 0) {
    operator delete(*(void **)(a1 + 56));
  }
  sub_1000486F0(a1 + 24, *(void **)(a1 + 32));
  return a1;
}

uint64_t sub_1002A9414(uint64_t result)
{
  uint64_t v1 = result;
  int v2 = *(uint64_t **)(result + 504);
  uint64_t v3 = *(uint64_t **)(result + 512);
  if (v2 != v3)
  {
    do
    {
      BOOL result = *v2;
      if (*v2)
      {
        sub_1002B30F0(result);
        operator delete();
      }
      ++v2;
    }
    while (v2 != v3);
    int v2 = *(uint64_t **)(v1 + 504);
  }
  *(void *)(v1 + 512) = v2;
  return result;
}

void *sub_1002A947C@<X0>(char a1@<W1>, void *a2@<X8>)
{
  if ((a1 - 1) > 7u) {
    int v2 = "Other";
  }
  else {
    int v2 = off_1009A2470[(char)(a1 - 1)];
  }
  return sub_10004191C(a2, v2);
}

void sub_1002A94B0(uint64_t *a1@<X0>, int a2@<W1>, void *a3@<X8>)
{
  if (a2 == 4)
  {
    sub_100475EE0(*a1, (uint64_t)&v6);
    int v4 = std::string::append(&v6, " 🅛");
LABEL_5:
    long long v5 = *(_OWORD *)&v4->__r_.__value_.__l.__data_;
    a3[2] = *((void *)&v4->__r_.__value_.__l + 2);
    *(_OWORD *)a3 = v5;
    v4->__r_.__value_.__l.__size_ = 0;
    v4->__r_.__value_.__r.__words[2] = 0;
    v4->__r_.__value_.__r.__words[0] = 0;
    if (SHIBYTE(v6.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v6.__r_.__value_.__l.__data_);
    }
    return;
  }
  if (a2 == 2)
  {
    sub_100475EE0(*a1, (uint64_t)&v6);
    int v4 = std::string::append(&v6, " 🅡");
    goto LABEL_5;
  }

  sub_10004191C(a3, "");
}

void sub_1002A9578(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1002A9598(uint64_t a1@<X0>, int a2@<W1>, void *a3@<X8>)
{
  if (a2 == 8)
  {
    long long v5 = @"AIRPODS_CASE";
    if (*(_DWORD *)(a1 + 80) == 8203) {
      long long v5 = @"POWERBEATS_PRO_CASE";
    }
    std::string v6 = v5;
    if (*(_DWORD *)(a1 + 80) == 8203) {
      BOOL v7 = @"Powerbeats Pro Case";
    }
    else {
      BOOL v7 = @"AirPods Case";
    }
    uint64_t v8 = v7;
    uint64_t v21 = 0;
    long long v19 = 0u;
    *(_OWORD *)std::string __p = 0u;
    long long v18 = 0u;
    sub_10004191C(__p, "");
    if (!sub_100480790(*(void *)a1, (uint64_t)&v18)) {
      goto LABEL_22;
    }
    if (SHIBYTE(v21) < 0)
    {
      if (__p[1] <= (void *)1)
      {
LABEL_22:
        sub_100379650(v6, v8);
        id v17 = objc_claimAutoreleasedReturnValue();
        sub_10004191C(a3, (char *)[v17 UTF8String]);

        if (SHIBYTE(v21) < 0) {
          operator delete(__p[0]);
        }

        return;
      }
      uint64_t v9 = (void **)__p[0];
    }
    else
    {
      uint64_t v9 = __p;
      if (HIBYTE(v21) <= 1u) {
        goto LABEL_22;
      }
    }
    uint64_t v11 = +[NSString stringWithCString:encoding:](NSString, "stringWithCString:encoding:", v9, +[NSString defaultCStringEncoding]);

    uint64_t v8 = (__CFString *)v11;
    unsigned int v12 = qword_100A19E38;
    if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
    {
      int v13 = *(_DWORD *)(a1 + 80);
      if (v21 >= 0) {
        uint64_t v14 = __p;
      }
      else {
        uint64_t v14 = (void **)__p[0];
      }
      *(_DWORD *)int64x2_t buf = 67109378;
      int v23 = v13;
      __int16 v24 = 2082;
      uint64_t v25 = v14;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "Case for buds with productId = %d reports case name %{public}s", buf, 0x12u);
    }
    uint64_t v15 = [(__CFString *)v8 uppercaseString];
    uint64_t v16 = [v15 stringByReplacingOccurrencesOfString:@" " withString:@"_"];

    std::string v6 = (__CFString *)v16;
    goto LABEL_22;
  }
  uint64_t v10 = *(void *)a1;

  sub_100475EE0(v10, (uint64_t)a3);
}

void sub_1002A9828(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

void sub_1002A9874(uint64_t a1)
{
  if (*(void *)(a1 + 128))
  {
    if (*(void *)(a1 + 144))
    {
      if (*(void *)(a1 + 512) == *(void *)(a1 + 504))
      {
        if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_ERROR)) {
          sub_100750C0C();
        }
      }
      else
      {
        long long v19 = objc_opt_new();
        uint64_t v3 = *(uint64_t **)(a1 + 504);
        int v2 = *(uint64_t **)(a1 + 512);
        if (v3 != v2)
        {
          uint64_t v4 = kCFACCProperties_Endpoint_AACP_CertificateInfo_Type;
          uint64_t v5 = kCFACCProperties_Endpoint_AACP_CertificateInfo_Serial;
          uint64_t v6 = kCFACCProperties_Endpoint_AACP_CertificateInfo_Data;
          do
          {
            uint64_t v7 = *v3;
            if (*(char *)(*v3 + 47) < 0) {
              unint64_t v8 = *(void *)(v7 + 32);
            }
            else {
              unint64_t v8 = *(unsigned __int8 *)(*v3 + 47);
            }
            if (v8 > 1)
            {
              uint64_t v11 = +[NSNumber numberWithInt:*(unsigned __int8 *)(v7 + 48)];
              unsigned int v12 = (void *)(v7 + 24);
              if (*(char *)(v7 + 47) < 0) {
                unsigned int v12 = (void *)*v12;
              }
              int v13 = +[NSString stringWithUTF8String:v12];
              uint64_t v14 = +[NSData dataWithBytes:*(void *)v7 length:*(void *)(v7 + 8) - *(void *)v7];
              uint64_t v15 = +[NSDictionary dictionaryWithObjectsAndKeys:](NSDictionary, "dictionaryWithObjectsAndKeys:", v11, v4, v13, v5, v14, v6, 0);
              [v19 addObject:v15];
            }
            else
            {
              uint64_t v9 = qword_100A19E38;
              if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_ERROR))
              {
                int v10 = *(unsigned __int8 *)(v7 + 48);
                *(_DWORD *)int64x2_t buf = 67109120;
                LODWORD(v21) = v10;
                _os_log_error_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "dispatchCertificates: Cert of type %d lacks serial number", buf, 8u);
              }
            }
            ++v3;
          }
          while (v3 != v2);
        }
        int v16 = acc_transportClient_setPropertyForEndpointWithUUID();
        id v17 = qword_100A19E38;
        if (v16)
        {
          if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
          {
            id v18 = [v19 count];
            *(_DWORD *)int64x2_t buf = 134217984;
            id v21 = v18;
            _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "dispatchCertificates: Published %lu certificates", buf, 0xCu);
          }
        }
        else if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_ERROR))
        {
          sub_100750C40((uint64_t)buf, (uint64_t)[v19 count], v17);
        }
        sub_1002A9414(a1);
        *(unsigned char *)(a1 + 528) = 1;
        *(_DWORD *)(a1 + 532) = 0;
      }
    }
    else if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_ERROR))
    {
      sub_100750BD8();
    }
  }
  else if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_ERROR))
  {
    sub_100750BA4();
  }
}

void sub_1002A9BA0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18)
{
  _Unwind_Resume(a1);
}

void sub_1002A9BF8(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  int v2 = qword_100A19E38;
  if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_ERROR)) {
    sub_100750C7C(v2, v3, v4);
  }
  *(unsigned char *)(v1 + 618) = 0;
}

uint64_t sub_1002A9C44(void *a1, uint64_t a2, int a3, uint64_t *a4, uint64_t a5)
{
  v35[0] = 0;
  v35[1] = 0;
  sub_10003AED0((uint64_t)v35, (uint64_t)(a1 + 45));
  if (*(_DWORD *)(a5 + 16))
  {
    int v10 = *(_DWORD *)(a5 + 20);
    unsigned int v12 = (uint64_t *)a1[42];
    uint64_t v11 = (uint64_t *)a1[43];
    if (v11 == v12)
    {
      long long v27 = qword_100A19E38;
      if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)int64x2_t buf = 67109120;
        *(_DWORD *)&uint8_t buf[4] = v10 == -1;
        _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "Warning: registerCustomDataCallback: No AACP connection (isFromDE = %d)", buf, 8u);
      }
      uint64_t v28 = 312;
      goto LABEL_53;
    }
    LODWORD(v13) = 0;
    uint64_t v14 = 0;
    do
    {
      uint64_t v16 = *v12++;
      uint64_t v15 = (uint64_t *)v16;
      unsigned int v17 = *(_DWORD *)(v16 + 80);
      if (v17 >= v13) {
        uint64_t v14 = v15;
      }
      if (v17 <= v13) {
        uint64_t v13 = v13;
      }
      else {
        uint64_t v13 = v17;
      }
    }
    while (v12 != v11);
    BOOL v33 = v10 == -1;
    if (qword_1009F8798 != -1) {
      dispatch_once(&qword_1009F8798, &stru_1009A1F10);
    }
    int v18 = sub_1003EFF78(qword_1009F8790);
    if (v18)
    {
      if (v10 != -1) {
        goto LABEL_50;
      }
      if (qword_1009F8798 != -1) {
        dispatch_once(&qword_1009F8798, &stru_1009A1F10);
      }
      if (!sub_1003F02E8(qword_1009F8790))
      {
LABEL_50:
        id v31 = qword_100A19E38;
        if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)int64x2_t buf = 67109120;
          *(_DWORD *)&uint8_t buf[4] = v10 == -1;
          _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_DEFAULT, "Warning: registerCustomDataCallback: Logging already ongoing (isFromDE = %d)", buf, 8u);
        }
        uint64_t v28 = 10;
        goto LABEL_53;
      }
      if (v14)
      {
        if (qword_1009F8798 != -1) {
          dispatch_once(&qword_1009F8798, &stru_1009A1F10);
        }
        sub_1003F01D4(qword_1009F8790, *v14);
      }
      long long v19 = qword_100A19E38;
      if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)int64x2_t buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "registerCustomDataCallback: Replacing sysdiagnose callback with DE callback", buf, 2u);
      }
    }
    int v20 = v18 ^ 1;
    *(void *)(a5 + 8) = v13;
    BOOL v21 = v33;
  }
  else
  {
    char v22 = qword_100A19E38;
    if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)int64x2_t buf = 67109120;
      *(_DWORD *)&uint8_t buf[4] = a3;
      _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "registerCustomDataCallback: Registering client type %d", buf, 8u);
    }
    BOOL v21 = 0;
    uint64_t v14 = 0;
    int v20 = 0;
  }
  v34[0] = 0;
  v34[1] = 0;
  sub_10003AED0((uint64_t)v34, (uint64_t)(a1 + 81));
  uint64_t v23 = *a4;
  __int16 v24 = (void *)a1[70];
  unint64_t v25 = a1[71];
  uint64_t v37 = *a4;
  if (v24 != (void *)v25)
  {
    while (*v24 != a2 || v37 != v24[1])
    {
      v24 += 4;
      if (v24 == (void *)v25) {
        goto LABEL_33;
      }
    }
  }
  if (v24 == (void *)v25)
  {
LABEL_33:
    *(void *)int64x2_t buf = a2;
    uint64_t v37 = v23;
    int v38 = a3;
    uint64_t v39 = a5;
    if (v25 >= a1[72])
    {
      uint64_t v26 = sub_1002B607C(a1 + 70, (uint64_t)buf);
    }
    else
    {
      *(void *)unint64_t v25 = a2;
      *(void *)(v25 + 8) = v23;
      *(_DWORD *)(v25 + 16) = a3;
      uint64_t v26 = v25 + 32;
      *(void *)(v25 + 24) = a5;
    }
    a1[71] = v26;
  }
  if (v14) {
    int v29 = v20;
  }
  else {
    int v29 = 0;
  }
  if (v29 == 1)
  {
    BOOL v30 = qword_100A19E38;
    if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)int64x2_t buf = 67109120;
      *(_DWORD *)&uint8_t buf[4] = v21;
      _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_DEFAULT, "registerCustomDataCallback: Calling triggerAccessoryLogRetrieval (isFromDE = %d)", buf, 8u);
    }
    if (qword_1009F8798 != -1) {
      dispatch_once(&qword_1009F8798, &stru_1009A1F10);
    }
    sub_1003EF858(qword_1009F8790, *v14, v21);
  }
  sub_10003AFB4((uint64_t)v34);
  uint64_t v28 = 0;
LABEL_53:
  sub_10003AFB4((uint64_t)v35);
  return v28;
}

void sub_1002AA08C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  sub_10003AFB4((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1002AA0BC(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v4 = a1 + 560;
  uint64_t v5 = sub_1002B62D0(*(void *)(a1 + 560), *(void *)(a1 + 568), a2, *a3);
  sub_1002B626C(v4, v5, *(void *)(a1 + 568));
  return 0;
}

uint64_t sub_1002AA10C(uint64_t a1)
{
  *(void *)a1 = off_1009A1430;
  free(*(void **)(a1 + 64));
  return a1;
}

void sub_1002AA154(uint64_t a1)
{
  *(void *)a1 = off_1009A1430;
  free(*(void **)(a1 + 64));

  operator delete();
}

void sub_1002AA1BC(uint64_t a1, uint64_t a2, uint64_t (*a3)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t), uint64_t a4)
{
  if (qword_1009F80A0 != -1) {
    dispatch_once(&qword_1009F80A0, &stru_1009A1E90);
  }
  unint64_t v8 = off_1009F8098;
  if (sub_1002AA2A0(a1, *(void *)(a1 + 40)) && sub_1002AA2A0(a1, *(void *)(a1 + 48)) && v8[70] != v8[71])
  {
    sub_100458288(a2, a3, *(void *)(a1 + 40), *(void *)(a1 + 48), *(unsigned int *)(a1 + 56), *(void *)(a1 + 64), *(void *)(a1 + 72), a4);
  }
  else if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_ERROR))
  {
    sub_100750CF4();
  }
}

BOOL sub_1002AA2A0(uint64_t a1, unint64_t a2)
{
  if (qword_1009F8168 != -1) {
    dispatch_once(&qword_1009F8168, &stru_1009A1FF0);
  }
  uint64_t v3 = qword_1009F8160;

  return sub_10055363C(v3, a2);
}

uint64_t sub_1002AA304(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  uint64_t v3 = a2;
  if (a2 + 32 != v2)
  {
    uint64_t v4 = a2;
    uint64_t v3 = a2;
    do
    {
      uint64_t v5 = *(void *)(v3 + 32);
      v3 += 32;
      uint64_t v6 = *(void *)(v4 + 40);
      *(void *)uint64_t v4 = v5;
      *(void *)(v4 + 8) = v6;
      *(_DWORD *)(v4 + 16) = *(_DWORD *)(v4 + 48);
      *(void *)(v4 + 24) = *(void *)(v4 + 56);
      uint64_t v7 = v4 + 64;
      uint64_t v4 = v3;
    }
    while (v7 != v2);
  }
  *(void *)(a1 + 8) = v3;
  return a2;
}

uint64_t sub_1002AA358(uint64_t a1, uint64_t a2, unsigned int a3, unsigned int a4, unsigned __int8 *a5)
{
  if (qword_1009F80A0 != -1) {
    dispatch_once(&qword_1009F80A0, &stru_1009A1E90);
  }
  if (!*((unsigned char *)off_1009F8098 + 328)) {
    return 111;
  }
  char v17 = 0;
  sub_10001B8E0(&v17);
  uint64_t v9 = sub_1000D88D4((unsigned __int8 *)(a2 + 128), a3, a4, a5);
  sub_10001B910(&v17);
  int v10 = qword_100A19E38;
  if (v9)
  {
    if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_ERROR))
    {
      sub_100474E18(a2, __p);
      if (v16 >= 0) {
        uint64_t v11 = __p;
      }
      else {
        uint64_t v11 = (void **)__p[0];
      }
      *(_DWORD *)int64x2_t buf = 136446978;
      long long v19 = v11;
      __int16 v20 = 1024;
      unsigned int v21 = a3;
      __int16 v22 = 1024;
      unsigned int v23 = a4;
      __int16 v24 = 1024;
      int v25 = v9;
      _os_log_error_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "Failed to send custom message to %{public}s: type 0x%x, len %u, error %u", buf, 0x1Eu);
      goto LABEL_16;
    }
  }
  else if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
  {
    sub_100474E18(a2, __p);
    if (v16 >= 0) {
      uint64_t v13 = __p;
    }
    else {
      uint64_t v13 = (void **)__p[0];
    }
    *(_DWORD *)int64x2_t buf = 136446722;
    long long v19 = v13;
    __int16 v20 = 1024;
    unsigned int v21 = a3;
    __int16 v22 = 1024;
    unsigned int v23 = a4;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "Sent custom message to %{public}s: type 0x%x, len %u", buf, 0x18u);
LABEL_16:
    if (v16 < 0) {
      operator delete(__p[0]);
    }
  }
  if (qword_1009F8070 != -1) {
    dispatch_once(&qword_1009F8070, &stru_1009A1D70);
  }
  uint64_t v12 = sub_1004E2340((uint64_t)off_1009F8068, v9, 10000);
  sub_10001B8AC(&v17);
  return v12;
}

void sub_1002AA598(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
}

uint64_t sub_1002AA5BC(uint64_t a1, uint64_t a2, char a3, int a4)
{
  if (qword_1009F80A0 != -1) {
    dispatch_once(&qword_1009F80A0, &stru_1009A1E90);
  }
  if (!*((unsigned char *)off_1009F8098 + 328)) {
    return 111;
  }
  uint64_t v7 = qword_100A19E38;
  if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
  {
    sub_100474E18(a2, __p);
    unint64_t v8 = v13 >= 0 ? __p : (void **)__p[0];
    *(_DWORD *)int64x2_t buf = 136446210;
    uint64_t v15 = v8;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "send control command message to %{public}s", buf, 0xCu);
    if (v13 < 0) {
      operator delete(__p[0]);
    }
  }
  LOBYTE(__p[0]) = 0;
  sub_10001B8E0(__p);
  uint64_t v9 = sub_1000D8330((unsigned __int8 *)(a2 + 128), a3, a4);
  sub_10001B910(__p);
  if (qword_1009F8070 != -1) {
    dispatch_once(&qword_1009F8070, &stru_1009A1D70);
  }
  uint64_t v10 = sub_1004E2340((uint64_t)off_1009F8068, v9, 10000);
  sub_10001B8AC(__p);
  return v10;
}

void sub_1002AA75C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
}

uint64_t sub_1002AA778(uint64_t a1, uint64_t a2, char *a3)
{
  if (qword_1009F80A0 != -1) {
    dispatch_once(&qword_1009F80A0, &stru_1009A1E90);
  }
  if (!*((unsigned char *)off_1009F8098 + 328)) {
    return 111;
  }
  uint64_t v5 = qword_100A19E38;
  if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
  {
    sub_100474E18(a2, __p);
    uint64_t v6 = v16 >= 0 ? __p : (void **)__p[0];
    *(_DWORD *)int64x2_t buf = 136446210;
    int v18 = v6;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "send set country code message to %{public}s", buf, 0xCu);
    if (v16 < 0) {
      operator delete(__p[0]);
    }
  }
  LOBYTE(__p[0]) = 0;
  sub_10001B8E0(__p);
  uint64_t v7 = operator new(1uLL);
  char v8 = *a3;
  *uint64_t v7 = *a3;
  uint64_t v9 = operator new(2uLL);
  v9[1] = a3[1];
  *uint64_t v9 = v8;
  operator delete(v7);
  uint64_t v10 = operator new(4uLL);
  void v10[2] = a3[2];
  *(_WORD *)uint64_t v10 = *(_WORD *)v9;
  operator delete(v9);
  _OWORD v10[3] = a3[3];
  uint64_t v11 = operator new(8uLL);
  void v11[4] = a3[4];
  *(_DWORD *)uint64_t v11 = *(_DWORD *)v10;
  operator delete(v10);
  void v11[5] = a3[5];
  *((_WORD *)v11 + 3) = *((_WORD *)a3 + 3);
  uint64_t v12 = sub_1000D9AE4((unsigned __int8 *)(a2 + 128), v11, 8u);
  sub_10001B910(__p);
  if (qword_1009F8070 != -1) {
    dispatch_once(&qword_1009F8070, &stru_1009A1D70);
  }
  uint64_t v13 = sub_1004E2340((uint64_t)off_1009F8068, v12, 10000);
  operator delete(v11);
  sub_10001B8AC(__p);
  return v13;
}

void sub_1002AA9C0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
}

uint64_t sub_1002AA9F4(uint64_t a1, uint64_t a2, __int16 a3, __int16 a4)
{
  if (qword_1009F80A0 != -1) {
    dispatch_once(&qword_1009F80A0, &stru_1009A1E90);
  }
  if (!*((unsigned char *)off_1009F8098 + 328)) {
    return 111;
  }
  uint64_t v7 = qword_100A19E38;
  if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
  {
    sub_100474E18(a2, __p);
    char v8 = v13 >= 0 ? __p : (void **)__p[0];
    *(_DWORD *)int64x2_t buf = 136446210;
    uint64_t v15 = v8;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "send set notification filter message to %{public}s", buf, 0xCu);
    if (v13 < 0) {
      operator delete(__p[0]);
    }
  }
  LOBYTE(__p[0]) = 0;
  sub_10001B8E0(__p);
  uint64_t v9 = sub_1000D8424((unsigned __int8 *)(a2 + 128), a3, a4);
  sub_10001B910(__p);
  if (qword_1009F8070 != -1) {
    dispatch_once(&qword_1009F8070, &stru_1009A1D70);
  }
  uint64_t v10 = sub_1004E2340((uint64_t)off_1009F8068, v9, 10000);
  sub_10001B8AC(__p);
  return v10;
}

void sub_1002AAB94(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
}

uint64_t sub_1002AABB0(uint64_t a1, uint64_t a2, char a3)
{
  if (qword_1009F80A0 != -1) {
    dispatch_once(&qword_1009F80A0, &stru_1009A1E90);
  }
  if (!*((unsigned char *)off_1009F8098 + 328)) {
    return 111;
  }
  uint64_t v5 = qword_100A19E38;
  if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
  {
    sub_100474E18(a2, __p);
    uint64_t v6 = v11 >= 0 ? __p : (void **)__p[0];
    *(_DWORD *)int64x2_t buf = 136446210;
    char v13 = v6;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "send get capabilities message to %{public}s", buf, 0xCu);
    if (v11 < 0) {
      operator delete(__p[0]);
    }
  }
  LOBYTE(__p[0]) = 0;
  sub_10001B8E0(__p);
  uint64_t v7 = sub_1000D8194((unsigned __int8 *)(a2 + 128), a3);
  sub_10001B910(__p);
  if (qword_1009F8070 != -1) {
    dispatch_once(&qword_1009F8070, &stru_1009A1D70);
  }
  uint64_t v8 = sub_1004E2340((uint64_t)off_1009F8068, v7, 10000);
  sub_10001B8AC(__p);
  return v8;
}

void sub_1002AAD40(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
}

uint64_t sub_1002AAD5C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (qword_1009F80A0 != -1) {
    dispatch_once(&qword_1009F80A0, &stru_1009A1E90);
  }
  if (!*((unsigned char *)off_1009F8098 + 328)) {
    return 111;
  }
  uint64_t v5 = qword_100A19E38;
  if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
  {
    sub_100474E18(a2, __p);
    uint64_t v6 = v11 >= 0 ? __p : (void **)__p[0];
    *(_DWORD *)int64x2_t buf = 134218242;
    uint64_t v13 = a3;
    __int16 v14 = 2082;
    uint64_t v15 = v6;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "Send source feature capabilities mask 0x%llx message to %{public}s", buf, 0x16u);
    if (v11 < 0) {
      operator delete(__p[0]);
    }
  }
  LOBYTE(__p[0]) = 0;
  sub_10001B8E0(__p);
  uint64_t v7 = sub_1000DA564((unsigned __int8 *)(a2 + 128), a3);
  sub_10001B910(__p);
  if (qword_1009F8070 != -1) {
    dispatch_once(&qword_1009F8070, &stru_1009A1D70);
  }
  uint64_t v8 = sub_1004E2340((uint64_t)off_1009F8068, v7, 10000);
  sub_10001B8AC(__p);
  return v8;
}

void sub_1002AAEF8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
}

uint64_t sub_1002AAF14(uint64_t a1, uint64_t a2)
{
  if (qword_1009F80A0 != -1) {
    dispatch_once(&qword_1009F80A0, &stru_1009A1E90);
  }
  if (!*((unsigned char *)off_1009F8098 + 328)) {
    return 111;
  }
  uint64_t v3 = qword_100A19E38;
  if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
  {
    sub_100474E18(a2, __p);
    uint64_t v4 = v9 >= 0 ? __p : (void **)__p[0];
    *(_DWORD *)int64x2_t buf = 136446210;
    char v11 = v4;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "send request case info message to %{public}s", buf, 0xCu);
    if (v9 < 0) {
      operator delete(__p[0]);
    }
  }
  LOBYTE(__p[0]) = 0;
  sub_10001B8E0(__p);
  uint64_t v5 = sub_1000D934C((unsigned __int8 *)(a2 + 128));
  sub_10001B910(__p);
  if (qword_1009F8070 != -1) {
    dispatch_once(&qword_1009F8070, &stru_1009A1D70);
  }
  uint64_t v6 = sub_1004E2340((uint64_t)off_1009F8068, v5, 10000);
  sub_10001B8AC(__p);
  return v6;
}

void sub_1002AB09C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
}

uint64_t sub_1002AB0B8(uint64_t a1, uint64_t a2)
{
  if (qword_1009F80A0 != -1) {
    dispatch_once(&qword_1009F80A0, &stru_1009A1E90);
  }
  if (!*((unsigned char *)off_1009F8098 + 328)) {
    return 111;
  }
  uint64_t v3 = qword_100A19E38;
  if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
  {
    sub_100474E18(a2, __p);
    uint64_t v4 = v9 >= 0 ? __p : (void **)__p[0];
    *(_DWORD *)int64x2_t buf = 136446210;
    char v11 = v4;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "query stream state info message to %{public}s", buf, 0xCu);
    if (v9 < 0) {
      operator delete(__p[0]);
    }
  }
  LOBYTE(__p[0]) = 0;
  sub_10001B8E0(__p);
  uint64_t v5 = sub_1000D83C4((unsigned __int8 *)(a2 + 128));
  sub_10001B910(__p);
  if (qword_1009F8070 != -1) {
    dispatch_once(&qword_1009F8070, &stru_1009A1D70);
  }
  uint64_t v6 = sub_1004E2340((uint64_t)off_1009F8068, v5, 10000);
  sub_10001B8AC(__p);
  return v6;
}

void sub_1002AB240(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
}

uint64_t sub_1002AB25C(uint64_t a1, uint64_t a2, uint64_t a3, unsigned int a4, const void *a5)
{
  if (qword_1009F80A0 != -1) {
    dispatch_once(&qword_1009F80A0, &stru_1009A1E90);
  }
  if (!*((unsigned char *)off_1009F8098 + 328)) {
    return 111;
  }
  char v9 = qword_100A19E38;
  if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
  {
    sub_100474E18(a2, __p);
    uint64_t v10 = v15 >= 0 ? __p : (void **)__p[0];
    *(_DWORD *)int64x2_t buf = 136446210;
    char v17 = v10;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "send easy pair req message to %{public}s", buf, 0xCu);
    if (v15 < 0) {
      operator delete(__p[0]);
    }
  }
  LOBYTE(__p[0]) = 0;
  sub_10001B8E0(__p);
  uint64_t v11 = sub_1000D8610((unsigned __int8 *)(a2 + 128), a3, a4, a5);
  sub_10001B910(__p);
  if (qword_1009F8070 != -1) {
    dispatch_once(&qword_1009F8070, &stru_1009A1D70);
  }
  uint64_t v12 = sub_1004E2340((uint64_t)off_1009F8068, v11, 10000);
  sub_10001B8AC(__p);
  return v12;
}

void sub_1002AB404(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
}

uint64_t sub_1002AB420(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (qword_1009F80A0 != -1) {
    dispatch_once(&qword_1009F80A0, &stru_1009A1E90);
  }
  if (!*((unsigned char *)off_1009F8098 + 328)) {
    return 111;
  }
  uint64_t v5 = qword_100A19E38;
  if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
  {
    sub_100474E18(a2, __p);
    uint64_t v6 = v11 >= 0 ? __p : (void **)__p[0];
    *(_DWORD *)int64x2_t buf = 136446210;
    uint64_t v13 = v6;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "send easy pair req message to %{public}s", buf, 0xCu);
    if (v11 < 0) {
      operator delete(__p[0]);
    }
  }
  LOBYTE(__p[0]) = 0;
  sub_10001B8E0(__p);
  uint64_t v7 = sub_1000D87CC((unsigned __int8 *)(a2 + 128), a3);
  sub_10001B910(__p);
  if (qword_1009F8070 != -1) {
    dispatch_once(&qword_1009F8070, &stru_1009A1D70);
  }
  uint64_t v8 = sub_1004E2340((uint64_t)off_1009F8068, v7, 10000);
  sub_10001B8AC(__p);
  return v8;
}

void sub_1002AB5B0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
}

uint64_t sub_1002AB5CC(uint64_t a1, uint64_t a2, char a3)
{
  if (qword_1009F80A0 != -1) {
    dispatch_once(&qword_1009F80A0, &stru_1009A1E90);
  }
  if (!*((unsigned char *)off_1009F8098 + 328)) {
    return 111;
  }
  uint64_t v5 = qword_100A19E38;
  if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
  {
    sub_100474E18(a2, __p);
    uint64_t v6 = v11 >= 0 ? __p : (void **)__p[0];
    *(_DWORD *)int64x2_t buf = 136446210;
    uint64_t v13 = v6;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "send get battery info message to %{public}s", buf, 0xCu);
    if (v11 < 0) {
      operator delete(__p[0]);
    }
  }
  LOBYTE(__p[0]) = 0;
  sub_10001B8E0(__p);
  uint64_t v7 = sub_1000D81FC((unsigned __int8 *)(a2 + 128), a3);
  sub_10001B910(__p);
  if (v7 && os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_ERROR)) {
    sub_100750D28();
  }
  if (qword_1009F8070 != -1) {
    dispatch_once(&qword_1009F8070, &stru_1009A1D70);
  }
  uint64_t v8 = sub_1004E2340((uint64_t)off_1009F8068, v7, 10000);
  sub_10001B8AC(__p);
  return v8;
}

void sub_1002AB788(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
}

uint64_t sub_1002AB7A4(uint64_t a1, uint64_t a2)
{
  if (qword_1009F80A0 != -1) {
    dispatch_once(&qword_1009F80A0, &stru_1009A1E90);
  }
  if (!*((unsigned char *)off_1009F8098 + 328)) {
    return 111;
  }
  uint64_t v3 = qword_100A19E38;
  if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
  {
    sub_100474E18(a2, __p);
    uint64_t v4 = v9 >= 0 ? __p : (void **)__p[0];
    *(_DWORD *)int64x2_t buf = 136446210;
    char v11 = v4;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "send get in ear state info message to %{public}s", buf, 0xCu);
    if (v9 < 0) {
      operator delete(__p[0]);
    }
  }
  LOBYTE(__p[0]) = 0;
  sub_10001B8E0(__p);
  uint64_t v5 = sub_1000D8270((unsigned __int8 *)(a2 + 128));
  sub_10001B910(__p);
  if (v5 && os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_ERROR)) {
    sub_100750D90();
  }
  if (qword_1009F8070 != -1) {
    dispatch_once(&qword_1009F8070, &stru_1009A1D70);
  }
  uint64_t v6 = sub_1004E2340((uint64_t)off_1009F8068, v5, 10000);
  sub_10001B8AC(__p);
  return v6;
}

void sub_1002AB950(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
}

uint64_t sub_1002AB96C(uint64_t a1, uint64_t a2)
{
  if (qword_1009F80A0 != -1) {
    dispatch_once(&qword_1009F80A0, &stru_1009A1E90);
  }
  if (!*((unsigned char *)off_1009F8098 + 328)) {
    return 111;
  }
  uint64_t v3 = qword_100A19E38;
  if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
  {
    sub_100474E18(a2, __p);
    uint64_t v4 = v9 >= 0 ? __p : (void **)__p[0];
    *(_DWORD *)int64x2_t buf = 136446210;
    char v11 = v4;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "send get role state info message to %{public}s", buf, 0xCu);
    if (v9 < 0) {
      operator delete(__p[0]);
    }
  }
  LOBYTE(__p[0]) = 0;
  sub_10001B8E0(__p);
  uint64_t v5 = sub_1000D82D0((unsigned __int8 *)(a2 + 128));
  sub_10001B910(__p);
  if (v5 && os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_ERROR)) {
    sub_100750DF8();
  }
  if (qword_1009F8070 != -1) {
    dispatch_once(&qword_1009F8070, &stru_1009A1D70);
  }
  uint64_t v6 = sub_1004E2340((uint64_t)off_1009F8068, v5, 10000);
  sub_10001B8AC(__p);
  return v6;
}

void sub_1002ABB18(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
}

uint64_t sub_1002ABB34(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (qword_1009F80A0 != -1) {
    dispatch_once(&qword_1009F80A0, &stru_1009A1E90);
  }
  if (!*((unsigned char *)off_1009F8098 + 328)) {
    return 111;
  }
  uint64_t v5 = qword_100A19E38;
  if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
  {
    sub_100474E18(a2, __p);
    uint64_t v6 = v11 >= 0 ? __p : (void **)__p[0];
    *(_DWORD *)int64x2_t buf = 136446210;
    uint64_t v13 = v6;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "send time stamp message to %{public}s", buf, 0xCu);
    if (v11 < 0) {
      operator delete(__p[0]);
    }
  }
  LOBYTE(__p[0]) = 0;
  sub_10001B8E0(__p);
  uint64_t v7 = sub_1000D8AF0((unsigned __int8 *)(a2 + 128), a3);
  sub_10001B910(__p);
  if (v7 && os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_ERROR)) {
    sub_100750E60();
  }
  if (qword_1009F8070 != -1) {
    dispatch_once(&qword_1009F8070, &stru_1009A1D70);
  }
  uint64_t v8 = sub_1004E2340((uint64_t)off_1009F8068, v7, 10000);
  sub_10001B8AC(__p);
  return v8;
}

void sub_1002ABCF0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
}

uint64_t sub_1002ABD0C(uint64_t a1, uint64_t a2, int a3, int a4)
{
  if (qword_1009F80A0 != -1) {
    dispatch_once(&qword_1009F80A0, &stru_1009A1E90);
  }
  if (!*((unsigned char *)off_1009F8098 + 328)) {
    return 111;
  }
  uint64_t v7 = qword_100A19E38;
  if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
  {
    sub_100474E18(a2, __p);
    uint64_t v8 = v13 >= 0 ? __p : (void **)__p[0];
    *(_DWORD *)int64x2_t buf = 136446722;
    char v15 = v8;
    __int16 v16 = 1024;
    int v17 = a3;
    __int16 v18 = 1024;
    int v19 = a4;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "notify session state to %{public}s, sesssionType -> %d, sessionState -> %d", buf, 0x18u);
    if (v13 < 0) {
      operator delete(__p[0]);
    }
  }
  buf[0] = 0;
  sub_10001B8E0(buf);
  uint64_t v9 = sub_1000D8FF0((unsigned __int8 *)(a2 + 128), a3, a4);
  sub_10001B910(buf);
  if (v9 && os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_ERROR)) {
    sub_100750EC8();
  }
  if (qword_1009F8070 != -1) {
    dispatch_once(&qword_1009F8070, &stru_1009A1D70);
  }
  uint64_t v10 = sub_1004E2340((uint64_t)off_1009F8068, v9, 10000);
  sub_10001B8AC(buf);
  return v10;
}

void sub_1002ABEE4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13)
{
}

uint64_t sub_1002ABF00(uint64_t a1, uint64_t a2, unsigned int a3, uint64_t a4)
{
  if (qword_1009F80A0 != -1) {
    dispatch_once(&qword_1009F80A0, &stru_1009A1E90);
  }
  if (!*((unsigned char *)off_1009F8098 + 328)) {
    return 111;
  }
  uint64_t v7 = qword_100A19E38;
  if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
  {
    sub_100474E18(a2, __p);
    uint64_t v8 = v13 >= 0 ? __p : (void **)__p[0];
    *(_DWORD *)int64x2_t buf = 136446210;
    char v15 = v8;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "send keys to %{public}s", buf, 0xCu);
    if (v13 < 0) {
      operator delete(__p[0]);
    }
  }
  LOBYTE(__p[0]) = 0;
  sub_10001B8E0(__p);
  uint64_t v9 = sub_1000D9784((unsigned __int8 *)(a2 + 128), a3, a4);
  if (v9 && os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_ERROR)) {
    sub_100750F30();
  }
  if (qword_1009F8070 != -1) {
    dispatch_once(&qword_1009F8070, &stru_1009A1D70);
  }
  uint64_t v10 = sub_1004E2340((uint64_t)off_1009F8068, v9, 10000);
  sub_10001B8AC(__p);
  return v10;
}

void sub_1002AC0BC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
}

uint64_t sub_1002AC0D8(uint64_t a1, uint64_t a2, int a3)
{
  if (qword_1009F80A0 != -1) {
    dispatch_once(&qword_1009F80A0, &stru_1009A1E90);
  }
  if (!*((unsigned char *)off_1009F8098 + 328)) {
    return 111;
  }
  uint64_t v5 = qword_100A19E38;
  if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
  {
    sub_100474E18(a2, __p);
    uint64_t v6 = v11 >= 0 ? __p : (void **)__p[0];
    *(_DWORD *)int64x2_t buf = 136446210;
    char v13 = v6;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "request keys from %{public}s", buf, 0xCu);
    if (v11 < 0) {
      operator delete(__p[0]);
    }
  }
  LOBYTE(__p[0]) = 0;
  sub_10001B8E0(__p);
  uint64_t v7 = sub_1000D9508((unsigned __int8 *)(a2 + 128), a3);
  if (v7 && os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_ERROR)) {
    sub_100750F98();
  }
  if (qword_1009F8070 != -1) {
    dispatch_once(&qword_1009F8070, &stru_1009A1D70);
  }
  uint64_t v8 = sub_1004E2340((uint64_t)off_1009F8068, v7, 10000);
  sub_10001B8AC(__p);
  return v8;
}

void sub_1002AC28C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
}

uint64_t sub_1002AC2A8(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = qword_100A19E38;
  if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
  {
    sub_100474E18(a2, __p);
    uint64_t v4 = v9 >= 0 ? __p : (void **)__p[0];
    *(_DWORD *)int64x2_t buf = 136446210;
    char v11 = v4;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "send disconnect message to %{public}s", buf, 0xCu);
    if (v9 < 0) {
      operator delete(__p[0]);
    }
  }
  LOBYTE(__p[0]) = 0;
  sub_10001B8E0(__p);
  uint64_t v5 = sub_1000D7B30((unsigned __int8 *)(a2 + 128));
  sub_10001B910(__p);
  if (v5 && os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_ERROR)) {
    sub_100751000();
  }
  if (qword_1009F8070 != -1) {
    dispatch_once(&qword_1009F8070, &stru_1009A1D70);
  }
  uint64_t v6 = sub_1004E2340((uint64_t)off_1009F8068, v5, 10000);
  sub_10001B8AC(__p);
  return v6;
}

void sub_1002AC414(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
}

uint64_t sub_1002AC430(uint64_t a1, uint64_t a2, int a3, unsigned int a4, const void *a5)
{
  if (qword_1009F80A0 != -1) {
    dispatch_once(&qword_1009F80A0, &stru_1009A1E90);
  }
  if (!*((unsigned char *)off_1009F8098 + 328)) {
    return 111;
  }
  char v17 = 0;
  sub_10001B8E0(&v17);
  uint64_t v9 = sub_1000D93B4((unsigned __int8 *)(a2 + 128), a3, a4, a5);
  sub_10001B910(&v17);
  uint64_t v10 = qword_100A19E38;
  if (v9)
  {
    if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_ERROR))
    {
      sub_100474E18(a2, __p);
      if (v16 >= 0) {
        char v11 = __p;
      }
      else {
        char v11 = (void **)__p[0];
      }
      *(_DWORD *)int64x2_t buf = 136446978;
      int v19 = v11;
      __int16 v20 = 1024;
      int v21 = a3;
      __int16 v22 = 1024;
      unsigned int v23 = a4;
      __int16 v24 = 1024;
      int v25 = v9;
      _os_log_error_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "Failed to send device info to %{public}s: type 0x%x, len %u, error %u", buf, 0x1Eu);
      goto LABEL_16;
    }
  }
  else if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
  {
    sub_100474E18(a2, __p);
    if (v16 >= 0) {
      char v13 = __p;
    }
    else {
      char v13 = (void **)__p[0];
    }
    *(_DWORD *)int64x2_t buf = 136446722;
    int v19 = v13;
    __int16 v20 = 1024;
    int v21 = a3;
    __int16 v22 = 1024;
    unsigned int v23 = a4;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "Sent device info to %{public}s: type 0x%x, len %u", buf, 0x18u);
LABEL_16:
    if (v16 < 0) {
      operator delete(__p[0]);
    }
  }
  if (qword_1009F8070 != -1) {
    dispatch_once(&qword_1009F8070, &stru_1009A1D70);
  }
  uint64_t v12 = sub_1004E2340((uint64_t)off_1009F8068, v9, 10000);
  sub_10001B8AC(&v17);
  return v12;
}

void sub_1002AC670(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
}

uint64_t sub_1002AC694(uint64_t a1, uint64_t a2, char a3, char a4, unsigned int a5, const void *a6)
{
  if (qword_1009F80A0 != -1) {
    dispatch_once(&qword_1009F80A0, &stru_1009A1E90);
  }
  if (!*((unsigned char *)off_1009F8098 + 328)) {
    return 111;
  }
  char v14 = 0;
  sub_10001B8E0(&v14);
  uint64_t v11 = sub_1000D91C4((unsigned __int8 *)(a2 + 128), a3, a4, a5, a6);
  sub_10001B910(&v14);
  if (v11 && os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_ERROR)) {
    sub_100751068();
  }
  if (qword_1009F8070 != -1) {
    dispatch_once(&qword_1009F8070, &stru_1009A1D70);
  }
  uint64_t v12 = sub_1004E2340((uint64_t)off_1009F8068, v11, 10000);
  sub_10001B8AC(&v14);
  return v12;
}

void sub_1002AC7C8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, int a10, __int16 a11, char a12, char a13)
{
}

uint64_t sub_1002AC7DC(uint64_t a1, uint64_t a2, unsigned __int16 *a3)
{
  uint64_t v3 = sub_1000D978C(a2, 1001, (uint64_t)off_1009A1170, a3);
  if (v3 && os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_ERROR)) {
    sub_1007510D0();
  }
  return v3;
}

uint64_t sub_1002AC844(uint64_t a1, uint64_t a2, uint64_t a3, __int16 *a4)
{
  sub_10028C8B4(a1, a2);
  sub_100011B98(a3, 3);
  sub_100011B98(a3, 2);
  sub_10001195C(a3, 1);
  sub_100011B98(a3, 16);
  sub_100011B98(a3, 2);
  sub_10001195C(a3, 2);
  __int16 v12 = 0;
  char v11 = 0;
  __int16 v10 = 0;
  uint64_t v7 = sub_1001DF230((unsigned __int16)*a4, &v10, &v12, &v11);
  if (!v7)
  {
    sub_100011B98(a3, 1);
    sub_100011B98(a3, 7);
    sub_10001195C(a3, *a4);
    sub_10001195C(a3, v10);
    sub_10001195C(a3, v12);
    sub_100011B98(a3, v11);
    if (!_os_feature_enabled_impl()) {
      return v7;
    }
    uint64_t v8 = sub_100035F54();
    if ((*(unsigned int (**)(uint64_t))(*(void *)v8 + 184))(v8))
    {
      sub_100011B98(a3, 25);
      sub_100011B98(a3, 0);
    }
LABEL_9:
    sub_100011B98(a3, 26);
    sub_100011B98(a3, 8);
    sub_1004BC554(a3, *(void *)(a1 + 528));
    return v7;
  }
  if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_ERROR)) {
    sub_100751104();
  }
  if (_os_feature_enabled_impl()) {
    goto LABEL_9;
  }
  return v7;
}

uint64_t sub_1002ACA00(uint64_t a1, uint64_t a2, uint64_t a3, unsigned int a4)
{
  int v5 = sub_100045F00(a2 + 8) - *(_DWORD *)(a2 + 24);
  int v25 = 0;
  unsigned int v6 = v5 << 16;
  if (v5 << 16 >= 1)
  {
    unsigned __int16 v7 = 0;
    unsigned __int16 v8 = 0;
    unsigned __int16 v22 = 0;
    unsigned __int16 v20 = 4;
    while (1)
    {
      int v9 = (char)sub_1004BC378(a2);
      if (v9 < 0)
      {
        unsigned int v10 = sub_1004BC3C8(a2);
        int v5 = HIWORD(v6) - 3;
      }
      else
      {
        unsigned int v10 = sub_1004BC378(a2);
        LOWORD(v5) = v5 - 2;
      }
      unsigned int v11 = v9 & 0x7F;
      if (v11 > 0xF)
      {
        if (v11 == 16)
        {
          if (v10 != 2) {
            goto LABEL_23;
          }
          unsigned __int16 v8 = sub_1004BC3C8(a2);
        }
        else
        {
          if (v11 != 18)
          {
LABEL_21:
            char v16 = qword_100A19E38;
            if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)int64x2_t buf = 67109120;
              int v27 = v9 & 0x7F;
              _os_log_error_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_ERROR, "parseAACPDescriptor Key not recognized %d", buf, 8u);
            }
LABEL_23:
            unsigned int v12 = v10;
            unsigned __int16 v13 = v10;
LABEL_24:
            if (v13)
            {
              char v17 = qword_100A19E38;
              if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_ERROR))
              {
                *(_DWORD *)int64x2_t buf = 67109632;
                int v27 = v11;
                __int16 v28 = 1024;
                unsigned int v29 = v12;
                __int16 v30 = 1024;
                unsigned int v31 = v10;
                _os_log_error_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_ERROR, "parseAACPDescriptor Key:%d Dumped %d of %d bytes ", buf, 0x14u);
              }
              sub_1004BC490(a2, v13);
            }
            goto LABEL_28;
          }
          if (v10 != 2) {
            goto LABEL_23;
          }
          unsigned __int16 v20 = sub_1004BC3C8(a2);
        }
      }
      else
      {
        if (v11 == 1)
        {
          unsigned int v12 = v10;
          unsigned __int16 v13 = v10;
          if (v10 >= 7)
          {
            __int16 v14 = sub_1004BC3C8(a2);
            sub_1004BC3C8(a2);
            unsigned __int16 v7 = sub_1004BC3C8(a2);
            sub_1004BC378(a2);
            buf[0] = 0;
            sub_10001B8E0(buf);
            if (sub_1001DD56C(a4, (uint64_t *)&v25) || !sub_1001E6484(v25))
            {
              char v15 = qword_100A19E38;
              if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_ERROR)) {
                sub_100751138(&v23, v24, v15);
              }
            }
            else
            {
              *(_WORD *)(sub_1001E6484(v25) + 8) = v14;
              *(_WORD *)(sub_1001E6484(v25) + 32) = v7;
              v7 -= 4;
              sub_1001102EC(v7, v20, a4);
            }
            sub_10001B910(buf);
            sub_10001B8AC(buf);
            unsigned int v12 = (unsigned __int16)(v10 - 7);
            unsigned __int16 v13 = v10 - 7;
          }
          goto LABEL_24;
        }
        if (v11 != 3) {
          goto LABEL_21;
        }
        if (v10 != 2) {
          goto LABEL_23;
        }
        unsigned __int16 v22 = sub_1004BC3C8(a2);
      }
LABEL_28:
      int v5 = (__int16)v5 - v10;
      unsigned int v6 = v5 << 16;
      if (v5 << 16 <= 0) {
        goto LABEL_34;
      }
    }
  }
  unsigned __int16 v22 = 0;
  unsigned __int16 v8 = 0;
  unsigned __int16 v7 = 0;
LABEL_34:
  buf[0] = 0;
  sub_10001B8E0(buf);
  sub_1000D9A8C(v8, v22, v7, (unsigned __int8 *)(a3 + 128));
  sub_10001B910(buf);
  sub_10001B8AC(buf);
  return 0;
}

void sub_1002ACD88(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  sub_10001B8AC(va);
  _Unwind_Resume(a1);
}

CFStringRef sub_1002ACDA8(unsigned int a1)
{
  if (a1 > 0xC) {
    return @"UNKNOWN";
  }
  else {
    return off_1009A24B0[(char)a1];
  }
}

uint64_t sub_1002ACDD0(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  id v5 = a4;
  int v6 = sub_100045F00(a2 + 8);
  int v7 = *(_DWORD *)(a2 + 24);
  memset(v98, 0, sizeof(v98));
  if (qword_1009FB170 != -1) {
    dispatch_once(&qword_1009FB170, &stru_1009A2030);
  }
  if (*(_DWORD *)(sub_100667D14((uint64_t)off_1009FB168, a3 + 128) + 32) < 5u)
  {
    BOOL v90 = 0;
  }
  else
  {
    if (qword_1009FB170 != -1) {
      dispatch_once(&qword_1009FB170, &stru_1009A2030);
    }
    BOOL v90 = sub_100667EF4((uint64_t)off_1009FB168) > 4;
  }
  LOWORD(v94) = v6 - v7;
  int v9 = (v6 - v7) << 16;
  if (v9 >= 1)
  {
    *(void *)&long long v8 = 136446466;
    long long v88 = v8;
    while (2)
    {
      int v10 = (char)sub_1004BC378(a2);
      if (v10 < 0)
      {
        unsigned int v93 = sub_1004BC3C8(a2);
        int v11 = HIWORD(v9) - 3;
      }
      else
      {
        unsigned int v93 = sub_1004BC378(a2);
        LOWORD(v11) = v94 - 2;
      }
      int v12 = (__int16)v11;
      unsigned int v13 = v93;
      unsigned int v94 = (__int16)v11 - v93;
      if ((__int16)v11 >= (int)v93)
      {
        int v14 = v10 & 0x7F;
        int v92 = v14;
        switch(v10 & 0x7F)
        {
          case 0x13:
            int v15 = _os_feature_enabled_impl();
            if (v93 > 3) {
              int v16 = v15;
            }
            else {
              int v16 = 0;
            }
            if ((v90 & v16) == 1)
            {
              unsigned __int16 v17 = v93;
              do
              {
                int v18 = sub_1004BC3C8(a2);
                unsigned int v19 = sub_1004BC3C8(a2);
                unsigned int v20 = v19;
                if (v18 == 9)
                {
                  unsigned int v27 = (unsigned __int16)v19 / 5u;
                  __int16 v28 = qword_100A19E38;
                  if ((unsigned __int16)v19 % 5u)
                  {
                    if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_ERROR))
                    {
                      *(_DWORD *)int64x2_t buf = 67109120;
                      *(_DWORD *)&uint8_t buf[4] = v20;
                      _os_log_error_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_ERROR, "Invalid control command length: %u", buf, 8u);
                    }
                  }
                  else
                  {
                    if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_INFO))
                    {
                      sub_100474E18(a3, buf);
                      unsigned int v31 = buf;
                      if (SBYTE3(v100) < 0) {
                        unsigned int v31 = *(unsigned char **)buf;
                      }
                      *(_DWORD *)id v103 = 67109378;
                      *(_DWORD *)&v103[4] = v27;
                      *(_WORD *)&v103[8] = 2082;
                      *(void *)&v103[10] = v31;
                      _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_INFO, "parseAACPSetupComplete rcvd %u control commands from device %{public}s", v103, 0x12u);
                      if (SBYTE3(v100) < 0) {
                        operator delete(*(void **)buf);
                      }
                    }
                    if (v20)
                    {
                      int v32 = sub_1004BC378(a2);
                      unsigned int v33 = sub_1004BC430(a2);
                      int v34 = qword_100A19E38;
                      BOOL v35 = os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEBUG);
                      if (v35)
                      {
                        unint64_t v36 = sub_100287278(v35, v32);
                        sub_1002872A4(a1, v32, v33, v103);
                        int v37 = v104;
                        int v38 = *(unsigned char **)v103;
                        sub_100474E18(a3, __p);
                        uint64_t v39 = v103;
                        if (v37 < 0) {
                          uint64_t v39 = v38;
                        }
                        uint64_t v40 = __p;
                        if (v97 < 0) {
                          uint64_t v40 = *(unsigned char **)__p;
                        }
                        *(_DWORD *)int64x2_t buf = 136446978;
                        *(void *)&uint8_t buf[4] = v36;
                        *(_WORD *)&unsigned char buf[12] = 1024;
                        *(_DWORD *)&unsigned char buf[14] = v32;
                        *(_WORD *)&buf[18] = 2082;
                        int64x2_t v100 = v39;
                        __int16 v101 = 2082;
                        int64_t v102 = v40;
                        _os_log_debug_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_DEBUG, "parseAACPSetupComplete rcvd control command: %{public}s (control cmd 0x%02X) as %{public}s from device %{public}s", buf, 0x26u);
                        if (v97 < 0) {
                          operator delete(*(void **)__p);
                        }
                        if (v104 < 0) {
                          operator delete(*(void **)v103);
                        }
                      }
                      operator new();
                    }
                  }
                }
                else
                {
                  if (v18 == 46)
                  {
                    int v21 = sub_1004BC378(a2);
                    int v22 = sub_1004BC378(a2);
                    unsigned int v23 = sub_1004BC378(a2);
                    size_t v24 = 8 * v23;
                    int v25 = sub_10010CE48(v24);
                    sub_1004BC33C(a2, v25, v24);
                    uint64_t v26 = qword_100A19E38;
                    if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_INFO))
                    {
                      *(_DWORD *)int64x2_t buf = 67109888;
                      *(_DWORD *)&uint8_t buf[4] = v21;
                      *(_WORD *)&uint8_t buf[8] = 1024;
                      *(_DWORD *)&buf[10] = v22;
                      *(_WORD *)&unsigned char buf[14] = 1024;
                      *(_DWORD *)&uint8_t buf[16] = v23;
                      LOWORD(v100) = 1024;
                      *(_DWORD *)((char *)&v100 + 2) = v20;
                      _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_INFO, "parseAACPSetupComplete rcvd tipi table with version %u, audioState %u, sourceCount %u, length %u", buf, 0x1Au);
                    }
                    operator new();
                  }
                  unsigned int v29 = qword_100A19E38;
                  if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_ERROR))
                  {
                    *(_DWORD *)int64x2_t buf = 67109376;
                    *(_DWORD *)&uint8_t buf[4] = v18;
                    *(_WORD *)&uint8_t buf[8] = 1024;
                    *(_DWORD *)&buf[10] = v20;
                    _os_log_error_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_ERROR, "parseAACPSetupComplete unhandled AACP Opcode %u, opcodeLength %u", buf, 0xEu);
                  }
                  sub_1004BC490(a2, v20);
                }
                __int16 v30 = v17 - v20;
                unsigned __int16 v17 = v17 - v20 - 4;
                unsigned int v13 = (unsigned __int16)(v30 - 4);
              }
              while (v13 > 3);
            }
            else
            {
              unsigned int v13 = v93;
              unsigned __int16 v17 = v93;
            }
            goto LABEL_103;
          case 0x14:
            unsigned __int16 v17 = v93;
            if (v93 != 19) {
              goto LABEL_103;
            }
            __int16 v43 = qword_100A19E38;
            if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_INFO))
            {
              *(_WORD *)int64x2_t buf = 0;
              _os_log_impl((void *)&_mh_execute_header, v43, OS_LOG_TYPE_INFO, "parseAACPSetupComplete FC_AACP_AIRPODS_INFO received", buf, 2u);
            }
            memset(__p, 0, sizeof(__p));
            sub_1004BC33C(a2, __p, 0x13uLL);
            int v44 = +[NSNumber numberWithUnsignedShort:*(unsigned __int16 *)__p];
            [v5 setObject:v44 forKeyedSubscript:@"AirpodsTimeSinceBoot"];

            __int16 v45 = +[NSNumber numberWithUnsignedShort:*(unsigned __int16 *)&__p[2]];
            [v5 setObject:v45 forKeyedSubscript:@"ConnectionTimeHRB"];

            int v46 = +[NSNumber numberWithUnsignedChar:__p[11]];
            [v5 setObject:v46 forKeyedSubscript:@"NumberConnections24G"];

            __int16 v47 = +[NSNumber numberWithUnsignedChar:__p[12]];
            [v5 setObject:v47 forKeyedSubscript:@"NumberConnectionsHRB"];

            int v48 = +[NSNumber numberWithUnsignedChar:__p[13]];
            [v5 setObject:v48 forKeyedSubscript:@"NumberConnectionsLE"];

            id v49 = +[NSNumber numberWithUnsignedChar:__p[14]];
            [v5 setObject:v49 forKeyedSubscript:@"NumberConnectionsSCO"];

            int v50 = +[NSNumber numberWithUnsignedChar:__p[15]];
            [v5 setObject:v50 forKeyedSubscript:@"NumberAOSLinks"];

            __int16 v51 = +[NSNumber numberWithUnsignedChar:__p[16]];
            [v5 setObject:v51 forKeyedSubscript:@"UtpConnected"];

            CFStringRef v52 = @"UNKNOWN";
            if ((unint64_t)__p[17] < 5) {
              CFStringRef v52 = off_1009A2518[__p[17]];
            }
            [v5 setObject:v52 forKeyedSubscript:@"AudioState" v88];
            long long v53 = +[NSNumber numberWithUnsignedChar:__p[18]];
            [v5 setObject:v53 forKeyedSubscript:@"PendingCrashReport"];

            if (!__p[10]) {
              goto LABEL_107;
            }
            [v5 setObject:&__kCFBooleanTrue forKeyedSubscript:@"BBFCStatusSink"];
            uint64_t v61 = sub_10025B48C((uint64_t)&__p[4], v54, v55, v56, v57, v58, v59, v60);
            __int16 v62 = qword_100A19E38;
            if (!os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT)) {
              goto LABEL_107;
            }
            sub_100474E18(a3, buf);
            long long v63 = buf;
            if (SBYTE3(v100) < 0) {
              long long v63 = *(unsigned char **)buf;
            }
            *(_DWORD *)id v103 = v88;
            *(void *)&v103[4] = v63;
            *(_WORD *)&v103[12] = 2082;
            *(void *)&v103[14] = v61;
            _os_log_impl((void *)&_mh_execute_header, v62, OS_LOG_TYPE_DEFAULT, "BB FastConnect seen by %{public}s BT Addr: %{public}s", v103, 0x16u);
            if ((SBYTE3(v100) & 0x80000000) == 0) {
              goto LABEL_107;
            }
            int64x2_t v64 = *(void **)buf;
            goto LABEL_72;
          case 0x15:
            unsigned __int16 v17 = v93;
            if (v93 != 4) {
              goto LABEL_103;
            }
            *(_DWORD *)std::string __p = 0;
            sub_1004BC33C(a2, __p, 4uLL);
            char v65 = +[NSNumber numberWithUnsignedShort:*(unsigned __int16 *)__p];
            [v5 setObject:v65 forKeyedSubscript:@"BasebandDuration"];

            uint64_t v66 = +[NSNumber numberWithUnsignedShort:*(unsigned __int16 *)&__p[2]];
            [v5 setObject:v66 forKeyedSubscript:@"BasebandDurationTotal"];

            id v67 = qword_100A19E38;
            if (!os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT)) {
              goto LABEL_107;
            }
            sub_100474E18(a3, v103);
            uint64_t v68 = v103;
            if (v104 < 0) {
              uint64_t v68 = *(unsigned char **)v103;
            }
            *(_DWORD *)int64x2_t buf = 136446722;
            *(void *)&uint8_t buf[4] = v68;
            *(_WORD *)&unsigned char buf[12] = 1024;
            *(_DWORD *)&unsigned char buf[14] = *(unsigned __int16 *)__p;
            *(_WORD *)&buf[18] = 1024;
            LODWORD(v100) = *(unsigned __int16 *)&__p[2];
            _os_log_impl((void *)&_mh_execute_header, v67, OS_LOG_TYPE_DEFAULT, "FastConnect Incoming Baseband time for %{public}s took %u ms Total Baseband %u ms", buf, 0x18u);
            if ((v104 & 0x80000000) == 0) {
              goto LABEL_107;
            }
            int64x2_t v64 = *(void **)v103;
LABEL_72:
            operator delete(v64);
            goto LABEL_107;
          case 0x16:
            unsigned __int16 v17 = v93;
            if (v93 != 2) {
              goto LABEL_103;
            }
            char v69 = qword_100A19E38;
            if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_INFO))
            {
              *(_WORD *)int64x2_t buf = 0;
              _os_log_impl((void *)&_mh_execute_header, v69, OS_LOG_TYPE_INFO, "parseAACPSetupComplete FC_AACP_BUD_INEAR_STATE received", buf, 2u);
            }
            *(_WORD *)id v103 = 0;
            sub_1004BC33C(a2, v103, 2uLL);
            BOOL v70 = sub_1002ACDA8(v103[0]);
            [v5 setObject:v70 forKeyedSubscript:@"InEarStatusPrimary"];

            long long v71 = sub_1002ACDA8(v103[1]);
            [v5 setObject:v71 forKeyedSubscript:@"InEarStatusSecondary"];

            if ((v90 & _os_feature_enabled_impl()) == 1) {
              operator new();
            }
            goto LABEL_107;
          case 0x17:
            unsigned __int16 v17 = v93;
            if (v93 != 4) {
              goto LABEL_103;
            }
            unint64_t v72 = qword_100A19E38;
            if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_INFO))
            {
              *(_WORD *)int64x2_t buf = 0;
              _os_log_impl((void *)&_mh_execute_header, v72, OS_LOG_TYPE_INFO, "parseAACPSetupComplete FC_AACP_ROLE_STATE received", buf, 2u);
            }
            *(_DWORD *)id v103 = 0;
            sub_1004BC33C(a2, v103, 4uLL);
            if ((v90 & _os_feature_enabled_impl()) == 1) {
              operator new();
            }
            goto LABEL_107;
          case 0x18:
            if (v93 - 6 > 0xA) {
              goto LABEL_101;
            }
            unint64_t v73 = qword_100A19E38;
            if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_INFO))
            {
              *(_WORD *)int64x2_t buf = 0;
              _os_log_impl((void *)&_mh_execute_header, v73, OS_LOG_TYPE_INFO, "parseAACPSetupComplete FC_AACP_BATTERY_STATE received", buf, 2u);
            }
            *(void *)int64x2_t buf = 0;
            *(void *)&uint8_t buf[8] = 0;
            sub_1004BC33C(a2, buf, v93);
            if (buf[0])
            {
              unint64_t v74 = 0;
              int v75 = &buf[3];
              do
              {
                int v76 = *(v75 - 2);
                switch(*(v75 - 2))
                {
                  case 1u:
                  case 4u:
                    long long v77 = +[NSNumber numberWithUnsignedChar:*v75];
                    [v5 setObject:v77 forKeyedSubscript:@"BatteryLevelPrimary"];

                    break;
                  case 2u:
                    long long v81 = +[NSNumber numberWithUnsignedChar:*v75];
                    [v5 setObject:v81 forKeyedSubscript:@"BatteryLevelSecondary"];

                    break;
                  case 3u:
                  case 5u:
                  case 6u:
                  case 7u:
                    goto LABEL_92;
                  case 8u:
                    int64x2_t v82 = +[NSNumber numberWithUnsignedChar:*v75];
                    [v5 setObject:v82 forKeyedSubscript:@"BatteryLevelCase"];

                    break;
                  default:
                    if (v76 == 16)
                    {
                      uint64_t v78 = +[NSNumber numberWithUnsignedChar:*v75];
                      [v5 setObject:v78 forKeyedSubscript:@"BatteryLevelPrimary"];

                      uint64_t v79 = +[NSNumber numberWithUnsignedChar:*v75];
                      [v5 setObject:v79 forKeyedSubscript:@"BatteryLevelSecondary"];
                    }
                    else
                    {
LABEL_92:
                      int v80 = qword_100A19E38;
                      if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_ERROR))
                      {
                        *(_DWORD *)id v103 = 67109120;
                        *(_DWORD *)&v103[4] = v76;
                        _os_log_error_impl((void *)&_mh_execute_header, v80, OS_LOG_TYPE_ERROR, "parseAACPDescriptor unknown battery id %d", v103, 8u);
                      }
                    }
                    break;
                }
                v75 += 5;
                ++v74;
              }
              while (v74 < buf[0]);
            }
            if ((v90 & _os_feature_enabled_impl()) == 1) {
              operator new();
            }
            goto LABEL_107;
          default:
            if (v14 != 4)
            {
              uint64_t v83 = qword_100A19E38;
              if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_ERROR))
              {
                *(_DWORD *)int64x2_t buf = 67109120;
                *(_DWORD *)&uint8_t buf[4] = v14;
                _os_log_error_impl((void *)&_mh_execute_header, v83, OS_LOG_TYPE_ERROR, "parseAACPSetupComplete Key not recognized %d", buf, 8u);
              }
LABEL_101:
              unsigned __int16 v17 = v93;
LABEL_103:
              if (v17)
              {
                uint64_t v84 = qword_100A19E38;
                if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_ERROR))
                {
                  *(_DWORD *)int64x2_t buf = 67109632;
                  *(_DWORD *)&uint8_t buf[4] = v92;
                  *(_WORD *)&uint8_t buf[8] = 1024;
                  *(_DWORD *)&buf[10] = v13;
                  *(_WORD *)&unsigned char buf[14] = 1024;
                  *(_DWORD *)&uint8_t buf[16] = v93;
                  _os_log_error_impl((void *)&_mh_execute_header, v84, OS_LOG_TYPE_ERROR, "parseAACPSetupComplete Key:%d Dumped %d of %d bytes ", buf, 0x14u);
                }
                sub_1004BC490(a2, v17);
              }
              goto LABEL_107;
            }
            unsigned __int16 v17 = v93;
            if (v93 != 2) {
              goto LABEL_103;
            }
            int v41 = sub_1004BC3C8(a2);
            if (v41)
            {
              uint64_t v42 = qword_100A19E38;
              if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_ERROR))
              {
                *(_DWORD *)int64x2_t buf = 67109120;
                *(_DWORD *)&uint8_t buf[4] = v41;
                _os_log_error_impl((void *)&_mh_execute_header, v42, OS_LOG_TYPE_ERROR, "parseAACPSetupComplete AACP status %d", buf, 8u);
              }
            }
LABEL_107:
            int v9 = v94 << 16;
            if ((int)(v94 << 16) <= 0) {
              goto LABEL_111;
            }
            continue;
        }
      }
      break;
    }
    id v85 = qword_100A19E38;
    if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)int64x2_t buf = 67109376;
      *(_DWORD *)&uint8_t buf[4] = v12;
      *(_WORD *)&uint8_t buf[8] = 1024;
      *(_DWORD *)&buf[10] = v93;
      _os_log_error_impl((void *)&_mh_execute_header, v85, OS_LOG_TYPE_ERROR, "parseAACPSetupComplete not enough data remaining %d for %d", buf, 0xEu);
    }
  }
LABEL_111:
  if ((v90 & _os_feature_enabled_impl()) == 1)
  {
    if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEBUG))
    {
      sub_100474E18(a3, buf);
      sub_100751178();
    }
    uint64_t v95 = a3 + 128;
    *(void *)std::string __p = &v95;
    id v86 = sub_1002B44D0(a1 + 448, &v95, (uint64_t)&unk_1007BE9D0, (void **)__p);
    sub_1002AE340(v86 + 3, v98);
  }
  sub_1002B5410(v98);

  return 0;
}

void sub_1002AE02C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39)
{
  sub_1002B5410(&a39);

  _Unwind_Resume(a1);
}

void sub_1002AE238(void *a1, void *a2)
{
  uint64_t v4 = a1[2];
  uint64_t v5 = a1[1];
  if (v4 == v5) {
    uint64_t v6 = 0;
  }
  else {
    uint64_t v6 = ((v4 - v5) << 6) - 1;
  }
  uint64_t v7 = a1[5];
  unint64_t v8 = v7 + a1[4];
  if (v6 == v8)
  {
    sub_1002B6560(a1);
    uint64_t v5 = a1[1];
    uint64_t v7 = a1[5];
    unint64_t v8 = a1[4] + v7;
  }
  *(void *)(*(void *)(v5 + ((v8 >> 6) & 0x3FFFFFFFFFFFFF8)) + 8 * (v8 & 0x1FF)) = *a2;
  a1[5] = v7 + 1;
}

void sub_1002AE2C0(uint64_t a1, void *a2)
{
  unint64_t v4 = *(void *)(a1 + 32);
  if (!v4)
  {
    sub_1002B6878((void **)a1);
    unint64_t v4 = *(void *)(a1 + 32);
  }
  uint64_t v5 = *(void *)(a1 + 8);
  uint64_t v6 = (void *)(v5 + 8 * (v4 >> 9));
  if (*(void *)(a1 + 16) == v5) {
    uint64_t v7 = 0;
  }
  else {
    uint64_t v7 = *v6 + 8 * (v4 & 0x1FF);
  }
  if (v7 == *v6) {
    uint64_t v7 = *(v6 - 1) + 4096;
  }
  *(void *)(v7 - 8) = *a2;
  uint64_t v8 = *(void *)(a1 + 40) + 1;
  *(void *)(a1 + 32) = v4 - 1;
  *(void *)(a1 + 40) = v8;
}

void *sub_1002AE340(void *a1, void *a2)
{
  if (a1 != a2)
  {
    unint64_t v4 = a2[4];
    uint64_t v5 = a2[1];
    uint64_t v6 = a2[2];
    uint64_t v7 = (char **)(v5 + 8 * (v4 >> 9));
    if (v6 == v5)
    {
      uint64_t v8 = 0;
      int v11 = 0;
      int v10 = (char *)(v5 + 8 * ((a2[5] + v4) >> 9));
    }
    else
    {
      uint64_t v8 = &(*v7)[8 * (v4 & 0x1FF)];
      unint64_t v9 = a2[5] + v4;
      int v10 = (char *)(v5 + 8 * (v9 >> 9));
      int v11 = (char *)(*(void *)v10 + 8 * (v9 & 0x1FF));
    }
    sub_1002B6B8C(a1, v7, v8, v10, v11);
  }
  return a1;
}

uint64_t sub_1002AE3D4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  sub_10028C8B4(a1, a2);
  sub_100011B98(a3, 19);
  *(_OWORD *)uint64_t v55 = 0u;
  long long v56 = 0u;
  sub_100053710((uint64_t)v55, 0);
  sub_10001195C((uint64_t)v55, 15);
  sub_10001195C((uint64_t)v55, 4);
  if (a2)
  {
    if (sub_100487464(a2)) {
      __int16 v6 = -1;
    }
    else {
      __int16 v6 = -3;
    }
  }
  else
  {
    __int16 v6 = 122;
  }
  sub_10001195C((uint64_t)v55, 0xFFFF);
  sub_10001195C((uint64_t)v55, v6 & 0xFFFE);
  v54[0] = 0;
  v54[1] = 0;
  sub_10003AED0((uint64_t)v54, a1 + 360);
  if (qword_1009FB170 != -1) {
    dispatch_once(&qword_1009FB170, &stru_1009A2030);
  }
  uint64_t v7 = sub_100667D14((uint64_t)off_1009FB168, a2 + 128);
  uint64_t v8 = qword_100A19E38;
  if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
  {
    int v9 = *(_DWORD *)(v7 + 32);
    *(_DWORD *)int64x2_t buf = 67109120;
    *(_DWORD *)&uint8_t buf[4] = v9;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "composeAACPConfigure: remote fcVersion %u", buf, 8u);
  }
  if (*(_DWORD *)(v7 + 32) >= 5u && _os_feature_enabled_impl())
  {
    sub_10001195C((uint64_t)v55, 9);
    *(_OWORD *)int64x2_t buf = 0u;
    long long v61 = 0u;
    sub_100053710((uint64_t)buf, 0);
    uint64_t v10 = sub_100035F54();
    uint64_t v11 = (*(uint64_t (**)(uint64_t))(*(void *)v10 + 344))(v10);
    if (v11 && sub_10028E028(v11, a2))
    {
      sub_100011B98((uint64_t)buf, 11);
      unsigned int v12 = 500;
    }
    else
    {
      uint64_t v13 = sub_100035F54();
      if (((*(uint64_t (**)(uint64_t))(*(void *)v13 + 328))(v13) & 1) == 0
        && (uint64_t v14 = sub_100035F54(), !(*(unsigned int (**)(uint64_t))(*(void *)v14 + 336))(v14))
        || !sub_100478B2C(a2, 13)
        || (uint64_t v15 = sub_100035F54(), ((*(uint64_t (**)(uint64_t))(*(void *)v15 + 720))(v15) & 1) != 0))
      {
LABEL_21:
        uint64_t v16 = sub_100035F54();
        uint64_t v17 = (*(uint64_t (**)(uint64_t))(*(void *)v16 + 720))(v16);
        if (v17 && sub_10028E028(v17, a2))
        {
          sub_100011B98((uint64_t)buf, 11);
          sub_1004BC500((uint64_t)buf, 0x1F4u);
        }
        int v18 = *(unsigned __int8 *)(a2 + 960);
        int v19 = *(unsigned __int8 *)(a2 + 976);
        sub_100011B98((uint64_t)buf, 19);
        if (v19) {
          unsigned int v20 = 2;
        }
        else {
          unsigned int v20 = 1;
        }
        sub_1004BC500((uint64_t)buf, v20);
        if (sub_100478B2C(a2, 22))
        {
          sub_100011B98((uint64_t)buf, 18);
          if (qword_1009FB130 != -1) {
            dispatch_once(&qword_1009FB130, &stru_1009A1DF0);
          }
          if (((v19 == 0) & sub_1002DE5E8(qword_1009FB128)) != 0) {
            unsigned int v21 = 1;
          }
          else {
            unsigned int v21 = 2;
          }
          sub_1004BC500((uint64_t)buf, v21);
        }
        if (v18) {
          goto LABEL_75;
        }
        sub_100011B98((uint64_t)buf, 1);
        unsigned int v22 = sub_10048741C(a2);
        sub_1004BC500((uint64_t)buf, v22);
        uint64_t v52 = 0;
        uint64_t v53 = 0;
        BOOL v23 = sub_10047B7A8(a2, (_DWORD *)&v53 + 1, &v53, (_DWORD *)&v52 + 1, &v52);
        BOOL v24 = v23;
        if (sub_10028CB30(v23, a2) && HIDWORD(v52) != 8208 && v24)
        {
          sub_100011B98((uint64_t)buf, 10);
          if (sub_100487464(a2)) {
            unsigned int v25 = 2;
          }
          else {
            unsigned int v25 = 1;
          }
          sub_1004BC500((uint64_t)buf, v25);
        }
        sub_100011B98((uint64_t)buf, 6);
        unsigned int v26 = sub_100487CFC(a2);
        sub_1004BC500((uint64_t)buf, v26);
        if (sub_100478B2C(a2, 29) && (sub_100478B2C(a2, 43) & 1) == 0)
        {
          sub_100011B98((uint64_t)buf, 23);
          unsigned int v27 = sub_10048775C(a2);
          sub_1004BC500((uint64_t)buf, v27);
        }
        if (sub_100478B2C(a2, 30))
        {
          if ((sub_100478B2C(a2, 38) & 1) == 0)
          {
            sub_100011B98((uint64_t)buf, 22);
            unsigned int v28 = sub_100487714(a2);
            sub_1004BC500((uint64_t)buf, v28);
            if ((sub_100478B2C(a2, 43) & 1) == 0)
            {
              sub_100011B98((uint64_t)buf, 24);
              unsigned int v29 = sub_1004877A4(a2);
              sub_1004BC500((uint64_t)buf, v29);
            }
          }
        }
        if (sub_100478B2C(a2, 28))
        {
          sub_100011B98((uint64_t)buf, 26);
          unsigned int v30 = sub_1004875AC(a2);
          sub_1004BC500((uint64_t)buf, v30);
        }
        if (sub_100478B2C(a2, 16)
          && sub_100478B2C(a2, 1)
          && (sub_100478B2C(a2, 43) & 1) == 0)
        {
          sub_100011B98((uint64_t)buf, 27);
          unsigned int v31 = sub_1004877EC(a2);
          sub_1004BC500((uint64_t)buf, v31);
        }
        if (sub_100487EFC(a2, 0x15u) == 1 && sub_100487CB4(a2))
        {
          sub_100011B98((uint64_t)buf, 50);
          unsigned int v32 = sub_100487CB4(a2);
          sub_1004BC500((uint64_t)buf, v32);
        }
        if (_os_feature_enabled_impl() && sub_100487EFC(a2, 0x13u) == 1)
        {
          sub_100011B98((uint64_t)buf, 52);
          unsigned int v33 = sub_100487BDC(a2);
          sub_1004BC500((uint64_t)buf, v33);
        }
        if (!sub_100478B2C(a2, 32)) {
          goto LABEL_75;
        }
        unsigned int v34 = sub_1004874AC(a2);
        if (v34)
        {
          sub_100011B98((uint64_t)buf, 32);
        }
        else
        {
          BOOL v35 = qword_100A19E38;
          if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
          {
            sub_100474E18(a2, &__p);
            if (v51 >= 0) {
              p_p = &__p;
            }
            else {
              p_p = __p;
            }
            int v37 = sub_100478B2C(a2, 32);
            int v38 = sub_1004874AC(a2);
            uint64_t v39 = "No";
            *(_DWORD *)uint64_t v57 = 136446722;
            *(void *)&v57[4] = p_p;
            if (v37) {
              uint64_t v39 = "Yes";
            }
            *(_WORD *)&v57[12] = 2080;
            *(void *)&v57[14] = v39;
            __int16 v58 = 1024;
            int v59 = v38;
            _os_log_impl((void *)&_mh_execute_header, v35, OS_LOG_TYPE_DEFAULT, "%{public}s Initialize setSmartRouteMode via connection Tipi Support = %s current SR Mode =%d", v57, 0x1Cu);
            if (v51 < 0) {
              operator delete(__p);
            }
          }
          if (!sub_100484DC4(a2, 1)) {
            goto LABEL_75;
          }
          sub_100011B98((uint64_t)buf, 32);
          unsigned int v34 = 1;
        }
        sub_1004BC500((uint64_t)buf, v34);
LABEL_75:
        sub_1000335D8(v57, *(const void **)&buf[8], v61 - *(void *)&buf[8]);
        __int16 v40 = sub_100045F00((uint64_t)v57);
        sub_10001195C((uint64_t)v55, v40);
        *(void *)uint64_t v57 = &off_100998428;
        if (*(void *)&v57[8]) {
          sub_1000368F4(*(atomic_uint **)&v57[8]);
        }
        sub_1000335D8(v57, *(const void **)&buf[8], v61 - *(void *)&buf[8]);
        int v41 = (char *)sub_10004A6E4((uint64_t)v57);
        sub_1000335D8(&__p, *(const void **)&buf[8], v61 - *(void *)&buf[8]);
        int64_t v42 = sub_100045F00((uint64_t)&__p);
        sub_1004BC4E4((uint64_t)v55, v41, v42);
        std::string __p = &off_100998428;
        if (v50) {
          sub_1000368F4(v50);
        }
        *(void *)uint64_t v57 = &off_100998428;
        if (*(void *)&v57[8]) {
          sub_1000368F4(*(atomic_uint **)&v57[8]);
        }
        if (*(void *)&buf[8])
        {
          *(void *)&long long v61 = *(void *)&buf[8];
          operator delete(*(void **)&buf[8]);
        }
        goto LABEL_83;
      }
      sub_100011B98((uint64_t)buf, 11);
      unsigned int v12 = 150;
    }
    sub_1004BC500((uint64_t)buf, v12);
    goto LABEL_21;
  }
LABEL_83:
  sub_10003AFE8((uint64_t)v54);
  __int16 v43 = sub_1000335D8(buf, v55[1], v56 - (unint64_t)v55[1]);
  char v44 = sub_100045F00((uint64_t)v43);
  sub_100011B98(a3, v44);
  *(void *)int64x2_t buf = &off_100998428;
  if (*(void *)&buf[8]) {
    sub_1000368F4(*(atomic_uint **)&buf[8]);
  }
  __int16 v45 = sub_1000335D8(buf, v55[1], v56 - (unint64_t)v55[1]);
  int v46 = (char *)sub_10004A6E4((uint64_t)v45);
  sub_1000335D8(v57, v55[1], v56 - (unint64_t)v55[1]);
  int64_t v47 = sub_100045F00((uint64_t)v57);
  sub_1004BC4E4(a3, v46, v47);
  *(void *)uint64_t v57 = &off_100998428;
  if (*(void *)&v57[8]) {
    sub_1000368F4(*(atomic_uint **)&v57[8]);
  }
  *(void *)int64x2_t buf = &off_100998428;
  if (*(void *)&buf[8]) {
    sub_1000368F4(*(atomic_uint **)&buf[8]);
  }
  sub_10003AFB4((uint64_t)v54);
  if (v55[1])
  {
    *(void **)&long long v56 = v55[1];
    operator delete(v55[1]);
  }
  return 0;
}

void sub_1002AED38(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, uint64_t a17, char a18, uint64_t a19, uint64_t a20,void *__p,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25)
{
  unsigned int v27 = *(void **)(v25 - 88);
  if (v27)
  {
    *(void *)(v25 - 80) = v27;
    operator delete(v27);
  }
  sub_10003AFB4((uint64_t)&a18);
  if (__p)
  {
    a22 = (uint64_t)__p;
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void sub_1002AEEDC(void *a1, uint64_t a2)
{
  unint64_t v4 = qword_100A19E38;
  if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
  {
    sub_100474E18(a2, __p);
    if (v7 >= 0) {
      uint64_t v5 = __p;
    }
    else {
      uint64_t v5 = (void **)__p[0];
    }
    *(_DWORD *)int64x2_t buf = 136446210;
    int v9 = v5;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Fast Connect AACP Report Connection attempt for %{public}s", buf, 0xCu);
    if (v7 < 0) {
      operator delete(__p[0]);
    }
  }
  sub_1004BD554(a1, a2);
}

void sub_1002AEFD8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  __int16 v6 = qword_100A19E38;
  if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)int64x2_t buf = 67109120;
    *(_DWORD *)&uint8_t buf[4] = a3;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "Fast Connect AACP Setup Complete result %d", buf, 8u);
  }
  *(void *)int64x2_t buf = 0;
  uint64_t v9 = 0;
  sub_10003AED0((uint64_t)buf, a1 + 360);
  if (qword_1009FB170 != -1) {
    dispatch_once(&qword_1009FB170, &stru_1009A2030);
  }
  sub_100667D14((uint64_t)off_1009FB168, a2 + 128);
  sub_10003AFE8((uint64_t)buf);
  if (a3)
  {
    if (qword_1009F8070 != -1) {
      dispatch_once(&qword_1009F8070, &stru_1009A1D70);
    }
    int v7 = sub_1004E2340((uint64_t)off_1009F8068, a3, 20000);
    sub_1004BD6C8(a1, a2, v7);
  }
  sub_1004BD6C8(a1, a2, 0);
}

void sub_1002AF220(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  sub_10003AFB4((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1002AF240(void *a1, uint64_t a2, unsigned int a3, int a4)
{
  v23[0] = 0;
  v23[1] = 0;
  sub_10003AED0((uint64_t)v23, (uint64_t)(a1 + 45));
  if (a2)
  {
    for (uint64_t i = (uint64_t **)a1[42]; i != (uint64_t **)a1[43]; ++i)
    {
      uint64_t v9 = *i;
      if (**i == a2)
      {
        if ((*(unsigned int (**)(uint64_t))(*(void *)v9[96] + 176))(v9[96]) == 1) {
          sub_1002947CC(a1, v9);
        }
        break;
      }
    }
  }
  int v10 = _os_feature_enabled_impl() ^ 1;
  if (!a4) {
    LOBYTE(v10) = 1;
  }
  if ((v10 & 1) == 0)
  {
    long long v21 = 0u;
    long long v22 = 0u;
    long long v20 = 0u;
    uint64_t v11 = a1 + 56;
    v24[0] = a2 + 128;
    v19[0] = v24;
    unsigned int v12 = sub_1002B44D0((uint64_t)v11, v24, (uint64_t)&unk_1007BE9D0, v19);
    sub_1002B47D4((uint64_t)&v20, v12 + 3);
    if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEBUG))
    {
      sub_100474E18(a2, v19);
      sub_1007511D4();
    }
    if ((void)v21 != *((void *)&v20 + 1))
    {
      uint64_t v13 = (void *)(*((void *)&v20 + 1) + 8 * ((unint64_t)v22 >> 9));
      uint64_t v14 = (void *)(*v13 + 8 * (v22 & 0x1FF));
      uint64_t v15 = *(void *)(*((void *)&v20 + 1) + (((*((void *)&v22 + 1) + (void)v22) >> 6) & 0x3FFFFFFFFFFFFF8))
          + 8 * ((*((void *)&v22 + 1) + v22) & 0x1FF);
      while (v14 != (void *)v15)
      {
        if (*v14) {
          (*(void (**)(void))(*(void *)*v14 + 8))(*v14);
        }
        if ((void *)((char *)++v14 - *v13) == (void *)4096)
        {
          uint64_t v16 = (void *)v13[1];
          ++v13;
          uint64_t v14 = v16;
        }
      }
    }
    uint64_t v18 = a2 + 128;
    sub_1002B54B8(v11, &v18);
    sub_1002B5410(&v20);
  }
  LOBYTE(v20) = 0;
  sub_10001B8E0(&v20);
  sub_1000D9A44((unsigned __int8 *)(a2 + 128), a3);
  sub_10001B8AC(&v20);
  return sub_10003AFB4((uint64_t)v23);
}

void sub_1002AF4A4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va1, a5);
  va_start(va, a5);
  uint64_t v6 = va_arg(va1, void);
  uint64_t v8 = va_arg(va1, void);
  uint64_t v9 = va_arg(va1, void);
  uint64_t v10 = va_arg(va1, void);
  uint64_t v11 = va_arg(va1, void);
  uint64_t v12 = va_arg(va1, void);
  sub_1002B5410((uint64_t *)va);
  sub_10003AFB4((uint64_t)va1);
  _Unwind_Resume(a1);
}

void sub_1002AF4EC(uint64_t a1, unsigned int a2)
{
  unint64_t v4 = qword_100A19E38;
  if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
  {
    int v5 = 136315138;
    uint64_t v6 = sub_1005F510C(a2);
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Playback state is now %s", (uint8_t *)&v5, 0xCu);
  }
  *(_DWORD *)(a1 + 496) = a2;
}

uint64_t sub_1002AF5A8(uint64_t a1, uint64_t a2, int *a3, uint64_t a4)
{
  int v18 = *a3;
  __int16 v19 = *((_WORD *)a3 + 2);
  int v16 = *(_DWORD *)(a2 + 128);
  __int16 v17 = *(_WORD *)(a2 + 132);
  uint64_t v6 = qword_100A19E38;
  if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
  {
    sub_1004A82EC((unsigned __int8 *)&v18, v14);
    int v7 = v15;
    uint64_t v8 = (void **)v14[0];
    sub_1004A82EC((unsigned __int8 *)&v16, __p);
    uint64_t v9 = v14;
    if (v7 < 0) {
      uint64_t v9 = v8;
    }
    if (v13 >= 0) {
      uint64_t v10 = __p;
    }
    else {
      uint64_t v10 = (void **)__p[0];
    }
    *(_DWORD *)int64x2_t buf = 136315394;
    long long v21 = v9;
    __int16 v22 = 2080;
    BOOL v23 = v10;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "passLinkKeyRequest sending store linkkey request to accessory  \"%s\" and phone  \"%s\"", buf, 0x16u);
    if (v13 < 0) {
      operator delete(__p[0]);
    }
    if (v15 < 0) {
      operator delete(v14[0]);
    }
  }
  (*(void (**)(uint64_t, int *, int *, uint64_t, uint64_t))(*(void *)a1 + 136))(a1, &v16, &v18, a4, 16);
  return 0;
}

void sub_1002AF728(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1002AF74C(uint64_t a1, uint64_t a2, char a3)
{
  v17[0] = 0;
  v17[1] = 0;
  sub_10003AED0((uint64_t)v17, a1 + 360);
  if (a2)
  {
    for (uint64_t i = *(void ***)(a1 + 336); i != *(void ***)(a1 + 344); ++i)
    {
      if (**i == a2)
      {
        uint64_t v10 = sub_1004AFA9C();
        v15[0] = _NSConcreteStackBlock;
        v15[1] = 3221225472;
        void v15[2] = sub_1002AF8D4;
        v15[3] = &unk_100998A58;
        v15[4] = a2;
        char v16 = a3;
        sub_100013018(v10, v15);
        uint64_t v11 = sub_1004AFB34();
        v13[0] = _NSConcreteStackBlock;
        v13[1] = 3221225472;
        void v13[2] = sub_1002AF93C;
        void v13[3] = &unk_100998A58;
        v13[4] = a2;
        char v14 = a3;
        sub_100013018(v11, v13);
        uint64_t v8 = 0;
        goto LABEL_9;
      }
    }
  }
  int v7 = qword_100A19E38;
  if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v12 = 0;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "setAllowsAutoRoute unable to find AACP connection", v12, 2u);
  }
  uint64_t v8 = 312;
LABEL_9:
  sub_10003AFB4((uint64_t)v17);
  return v8;
}

void sub_1002AF8C0(_Unwind_Exception *a1)
{
  sub_10003AFB4(v1 - 64);
  _Unwind_Resume(a1);
}

uint64_t sub_1002AF8D4(uint64_t a1)
{
  if (qword_1009FB058 != -1) {
    dispatch_once(&qword_1009FB058, &stru_1009A1F90);
  }
  uint64_t v2 = off_1009FB050;
  uint64_t v3 = *(void *)(a1 + 32);
  int v4 = *(unsigned __int8 *)(a1 + 40);

  return sub_10052A88C((uint64_t)v2, v3, v4);
}

uint64_t sub_1002AF93C(uint64_t a1)
{
  if (qword_1009F8418 != -1) {
    dispatch_once(&qword_1009F8418, &stru_1009A1E10);
  }
  uint64_t v2 = (void *)qword_1009F8410;
  uint64_t v3 = *(void *)(a1 + 32);
  int v4 = *(unsigned __int8 *)(a1 + 40);

  return sub_100416790(v2, v3, v4);
}

uint64_t sub_1002AF9A4(uint64_t a1, uint64_t a2, char a3)
{
  v17[0] = 0;
  v17[1] = 0;
  sub_10003AED0((uint64_t)v17, a1 + 360);
  if (a2)
  {
    for (uint64_t i = *(void ***)(a1 + 336); i != *(void ***)(a1 + 344); ++i)
    {
      if (**i == a2)
      {
        uint64_t v10 = sub_1004AFA9C();
        v15[0] = _NSConcreteStackBlock;
        v15[1] = 3221225472;
        void v15[2] = sub_1002AFB2C;
        v15[3] = &unk_100998A58;
        v15[4] = a2;
        char v16 = a3;
        sub_100013018(v10, v15);
        uint64_t v11 = sub_1004AFB34();
        v13[0] = _NSConcreteStackBlock;
        v13[1] = 3221225472;
        void v13[2] = sub_1002AFB94;
        void v13[3] = &unk_100998A58;
        v13[4] = a2;
        char v14 = a3;
        sub_100013018(v11, v13);
        uint64_t v8 = 0;
        goto LABEL_9;
      }
    }
  }
  int v7 = qword_100A19E38;
  if (os_log_type_enabled((os_log_t)qword_100A19E38, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v12 = 0;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "setAudioRouteHidden unable to find AACP connection", v12, 2u);
  }
  uint64_t v8 = 312;
LABEL_9:
  sub_10003AFB4((uint64_t)v17);
  return v8;
}

void sub_1002AFB18(_Unwind_Exception *a1)
{
  sub_10003AFB4(v1 - 64);
  _Unwind_Resume(a1);
}

uint64_t sub_1002AFB2C(uint64_t a1)
{
  if (qword_1009FB058 != -1) {
    dispatch_once(&qword_1009FB058, &stru_1009A1F90);
  }
  uint64_t v2 = off_1009FB050;
  uint64_t v3 = *(void *)(a1 + 32);
  int v4 = *(unsigned __int8 *)(a1 + 40);

  return sub_10052A9D8((uint64_t)v2, v3, v4);
}

uint64_t sub_1002AFB94(uint64_t a1)
{
  if (qword_1009F8418 != -1) {
    dispatch_once(&qword_1009F8418, &stru_1009A1E10);
  }
  uint64_t v2 = (void *)qword_1009F8410;
  uint64_t v3 = *(void *)(a1 + 32);
  int v4 = *(unsigned __int8 *)(a1 + 40);

  return sub_1004168F8(v2, v3, v4);
}

uint64_t sub_1002AFBFC(uint64_t a1)
{
  if (qword_1009FB058 != -1) {
    dispatch_once(&qword_1009FB058, &stru_1009A1F90);
  }
  uint64_t v2 = off_1009FB050;
  uint64_t v3 = *(void *)(a1 + 32);
  int v4 = *(unsigned __int8 *)(a1 + 40);

  return sub_10052AB24((uint64_t)v2, v3, v4);
}

uint64_t sub_1002AFC64(uint64_t a1)
{
  if (qword_1009F8418 != -1) {
    dispatch_once(&qword_1009F8418, &stru_1009A1E10);
  }
  uint64_t v2 = (void *)qword_1009F8410;
  uint64_t v3 = *(void *)(a1 + 32);
  int v4 = *(unsigned __int8 *)(a1 + 40);

  return sub_100416A60(v2, v3, v4);
}

uint64_t sub_1002AFCCC(uint64_t a1)
{
  if (qword_1009FB058 != -1) {
    dispatch_once(&qword_1009FB058, &stru_1009A1F90);
  }
  uint64_t v2 = off_1009FB050;
  uint64_t v3 = *(void *)(a1 + 32);
  int v4 = *(unsigned __int8 *)(a1 + 40);

  return sub_10052AB88((uint64_t)v2, v3, v4);
}

uint64_t sub_1002AFD34(uint64_t a1)
{
  if (qword_1009F8418 != -1) {
    dispatch_once(&qword_1009F8418, &stru_1009A1E10);
  }
  uint64_t v2 = (void *)qword_1009F8410;
  uint64_t v3 = *(void *)(a1 + 32);
  int v4 = *(unsigned __int8 *)(a1 + 40);

  return sub_100416AE8(v2, v3, v4);
}

void sub_1002AFDA0()
{
}

uint64_t sub_1002AFDB4()
{
  return 1;
}

void sub_1002AFDC0(uint64_t a1)
{
  sub_1002B31FC(a1);

  operator delete();
}

uint64_t sub_1002AFDF8()
{
  return 3;
}

uint64_t sub_1002AFE00()
{
  return 1;
}

uint64_t sub_1002AFE08()
{
  return 0;
}

uint64_t sub_1002AFE10()
{
  return 0;
}

uint64_t sub_1002AFE40(unint64_t *a1)
{
  uint64_t result = sub_1002AA2A0((uint64_t)a1, a1[2]);
  if (result)
  {
    unint64_t v3 = a1[2];
    unint64_t v4 = a1[3];
    unint64_t v5 = a1[4];
    uint64_t v6 = *(uint64_t (**)(unint64_t *, unint64_t, unint64_t, unint64_t))(*a1 + 40);
    return v6(a1, v3, v4, v5);
  }
  return result;
}

unsigned char *(*sub_1002AFEB4())(unsigned char *result)
{
  return sub_1004B03B0;
}

uint64_t sub_1002AFEC8()
{
  return 1;
}

uint64_t sub_1002AFED0()
{
  return 1;
}

uint64_t sub_1002AFED8()
{
  return 0;
}

void *sub_1002AFEE0(void *a1)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  sub_100052DA8(a1 + 3);
  return a1;
}

void sub_1002AFF14(_Unwind_Exception *exception_object)
{
  unint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void sub_1002AFF30(uint64_t a1, uint64_t a2)
{
  os_unfair_lock_lock((os_unfair_lock_t)a1);
  unint64_t v5 = *(char **)(a1 + 8);
  unint64_t v4 = *(char **)(a1 + 16);
  if (v5 != v4)
  {
    while (*(void *)v5 != a2)
    {
      v5 += 8;
      if (v5 == v4)
      {
        unint64_t v5 = *(char **)(a1 + 16);
        break;
      }
    }
  }
  if (v5 == v4)
  {
    uint64_t v6 = a2;
    sub_1002AFFBC(a1 + 8, v4, (char *)&v6);
    sub_100061554(a1 + 8);
  }
  os_unfair_lock_unlock((os_unfair_lock_t)a1);
}

char *sub_1002AFFBC(uint64_t a1, char *__src, char *a3)
{
  unint64_t v3 = a3;
  unint64_t v4 = __src;
  uint64_t v6 = *(char **)(a1 + 8);
  uint64_t v8 = a1 + 16;
  unint64_t v7 = *(void *)(a1 + 16);
  if ((unint64_t)v6 >= v7)
  {
    char v13 = *(char **)a1;
    unint64_t v14 = ((uint64_t)&v6[-*(void *)a1] >> 3) + 1;
    if (v14 >> 61) {
      abort();
    }
    uint64_t v15 = __src - v13;
    uint64_t v16 = (__src - v13) >> 3;
    uint64_t v17 = v7 - (void)v13;
    if (v17 >> 2 > v14) {
      unint64_t v14 = v17 >> 2;
    }
    if ((unint64_t)v17 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v18 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v18 = v14;
    }
    uint64_t v30 = a1 + 16;
    if (v18) {
      __int16 v19 = (char *)sub_1000405F8(a1 + 16, v18);
    }
    else {
      __int16 v19 = 0;
    }
    long long v20 = &v19[8 * v16];
    std::string __p = v19;
    unsigned int v27 = v20;
    unsigned int v28 = v20;
    unsigned int v29 = &v19[8 * v18];
    if (v16 == v18)
    {
      if (v15 < 1)
      {
        if (v13 == v4) {
          unint64_t v22 = 1;
        }
        else {
          unint64_t v22 = v15 >> 2;
        }
        BOOL v23 = (char *)sub_1000405F8(v8, v22);
        long long v20 = &v23[8 * (v22 >> 2)];
        std::string __p = v23;
        unsigned int v27 = v20;
        unsigned int v29 = &v23[8 * v24];
        if (v19) {
          operator delete(v19);
        }
      }
      else
      {
        unint64_t v21 = v16 + 2;
        if (v16 >= -1) {
          unint64_t v21 = v16 + 1;
        }
        v20 -= 8 * (v21 >> 1);
        unsigned int v27 = v20;
      }
    }
    *(void *)long long v20 = *(void *)v3;
    unsigned int v28 = v20 + 8;
    unint64_t v4 = sub_100061614((void **)a1, (uint64_t)&__p, v4);
    if (v28 != v27) {
      v28 += (v27 - v28 + 7) & 0xFFFFFFFFFFFFFFF8;
    }
    if (__p) {
      operator delete(__p);
    }
  }
  else if (__src == v6)
  {
    *(void *)__src = *(void *)a3;
    *(void *)(a1 + 8) = __src + 8;
  }
  else
  {
    uint64_t v9 = __src + 8;
    uint64_t v10 = v6 - 8;
    uint64_t v11 = *(void **)(a1 + 8);
    while (v10 < v6)
    {
      uint64_t v12 = *(void *)v10;
      v10 += 8;
      *v11++ = v12;
    }
    *(void *)(a1 + 8) = v11;
    if (v6 != v9) {
      memmove(&v6[-8 * ((v6 - v9) >> 3)], __src, v6 - v9);
    }
    if (v4 <= v3) {
      v3 += 8 * (*(void *)(a1 + 8) > (unint64_t)v3);
    }
    *(void *)unint64_t v4 = *(void *)v3;
  }
  return v4;
}

void sub_1002B01C4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1002B01FC(uint64_t a1)
{
  for (uint64_t i = 0; i != 88; i += 8)
  {
    unint64_t v3 = *(const void **)(a1 + i);
    if (v3)
    {
      CFRelease(v3);
      *(void *)(a1 + i) = 0;
    }
  }
  unint64_t v4 = *(const void **)(a1 + 88);
  if (v4)
  {
    CFRelease(v4);
    *(void *)(a1 + 88) = 0;
  }
  return a1;
}

void sub_1002B0254()
{
}

void sub_1002B0268(uint64_t a1)
{
  if (qword_1009F80A0 != -1) {
    dispatch_once(&qword_1009F80A0, &stru_1009A1E90);
  }
  uint64_t v2 = off_1009F8098;

  sub_1002940CC(v2, a1 + 10);
}

void sub_1002B02D0()
{
}

void sub_1002B02E4(uint64_t a1)
{
  if (qword_1009F80A0 != -1) {
    dispatch_once(&qword_1009F80A0, &stru_1009A1E90);
  }
  uint64_t v2 = off_1009F8098;
  int v3 = *(unsigned __int16 *)(a1 + 16);
  uint64_t v4 = *(unsigned int *)(a1 + 20);

  sub_10029424C((uint64_t)v2, a1 + 10, v3, v4);
}

void sub_1002B0354()
{
}

void sub_1002B0368(uint64_t a1)
{
  if (qword_1009F80A0 != -1) {
    dispatch_once(&qword_1009F80A0, &stru_1009A1E90);
  }
  uint64_t v2 = off_1009F8098;
  int v3 = *(_DWORD *)(a1 + 16);

  sub_1002944CC(v2, (unsigned __int8 *)(a1 + 10), v3);
}

uint64_t sub_1002B03D0(uint64_t a1, int *a2, unsigned __int16 *a3, unsigned int a4, int a5)
{
  *(_WORD *)(a1 + 8) = 1;
  *(void *)a1 = off_1009A1648;
  int v5 = *a2;
  *(_WORD *)(a1 + 14) = *((_WORD *)a2 + 2);
  *(_DWORD *)(a1 + 10) = v5;
  *(_DWORD *)(a1 + 32) = a5;
  *(void *)(a1 + 24) = 0;
  if (!a3)
  {
    uint64_t v10 = "data";
    goto LABEL_14;
  }
  if (a4 != 1)
  {
    if (a4)
    {
      int v7 = *a3;
      *(_WORD *)(a1 + 16) = v7;
      if (v7 == 30)
      {
        if (a4 >= 4)
        {
          uint64_t v8 = a3[1];
LABEL_10:
          *(void *)(a1 + 24) = v8;
          return a1;
        }
LABEL_9:
        uint64_t v8 = 0;
        goto LABEL_10;
      }
      return a1;
    }
    uint64_t v10 = "(dataLen) > 0";
LABEL_14:
    sub_10014327C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Server/aacp/AACPClient.mm", 7472, v10);
  }
  if (*(_WORD *)(a1 + 16) == 30)
  {
    sub_10025A794((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Server/aacp/AACPClient.mm");
    goto LABEL_9;
  }
  return a1;
}

void sub_1002B04BC()
{
}

uint64_t sub_1002B04D0(uint64_t a1)
{
  if (qword_1009F80A0 != -1) {
    dispatch_once(&qword_1009F80A0, &stru_1009A1E90);
  }
  uint64_t v2 = off_1009F8098;
  int v3 = *(unsigned __int16 *)(a1 + 16);
  uint64_t v4 = *(void *)(a1 + 24);

  return sub_100294B1C((uint64_t)v2, a1 + 10, v3, v4);
}

void *sub_1002B053C(void *result)
{
  *uint64_t result = off_1009A1680;
  if (result[3]) {
    operator delete[]();
  }
  return result;
}

void sub_1002B0598(void *a1)
{
  *a1 = off_1009A1680;
  if (a1[3]) {
    operator delete[]();
  }

  operator delete();
}

uint64_t sub_1002B0614(uint64_t a1)
{
  if (qword_1009F80A0 != -1) {
    dispatch_once(&qword_1009F80A0, &stru_1009A1E90);
  }
  uint64_t v2 = off_1009F8098;
  unsigned __int8 v3 = *(unsigned char *)(a1 + 16);
  uint64_t v4 = *(void *)(a1 + 24);

  return sub_100295034((uint64_t)v2, a1 + 10, v3, v4);
}

void *sub_1002B0680(void *result)
{
  *uint64_t result = off_1009A16B8;
  if (result[3]) {
    operator delete[]();
  }
  return result;
}

void sub_1002B06DC(void *a1)
{
  *a1 = off_1009A16B8;
  if (a1[3]) {
    operator delete[]();
  }

  operator delete();
}

void sub_1002B0758(uint64_t a1)
{
  if (qword_1009F80A0 != -1) {
    dispatch_once(&qword_1009F80A0, &stru_1009A1E90);
  }
  uint64_t v2 = off_1009F8098;
  int v3 = *(unsigned __int8 *)(a1 + 16);
  uint64_t v4 = *(char **)(a1 + 24);

  sub_10029708C((uint64_t)v2, a1 + 10, v3, v4);
}

void sub_1002B07C8()
{
}

void sub_1002B07DC(uint64_t a1)
{
  if (qword_1009F80A0 != -1) {
    dispatch_once(&qword_1009F80A0, &stru_1009A1E90);
  }
  uint64_t v2 = off_1009F8098;

  sub_100297E9C((uint64_t)v2, a1 + 10, (unsigned __int8 *)(a1 + 16));
}

void sub_1002B0848()
{
}

void sub_1002B085C(uint64_t a1)
{
  if (qword_1009F80A0 != -1) {
    dispatch_once(&qword_1009F80A0, &stru_1009A1E90);
  }
  uint64_t v2 = off_1009F8098;

  sub_100298250((uint64_t)v2, a1 + 10, (unsigned __int8 *)(a1 + 16));
}

void sub_1002B08C8()
{
}

uint64_t sub_1002B08DC(uint64_t a1)
{
  if (qword_1009F80A0 != -1) {
    dispatch_once(&qword_1009F80A0, &stru_1009A1E90);
  }
  uint64_t v2 = off_1009F8098;
  int v3 = *(unsigned __int8 *)(a1 + 22);

  return sub_100298ADC((uint64_t)v2, a1 + 10, a1 + 16, v3);
}

void sub_1002B094C()
{
}

uint64_t sub_1002B0960(uint64_t a1)
{
  if (qword_1009F80A0 != -1) {
    dispatch_once(&qword_1009F80A0, &stru_1009A1E90);
  }
  uint64_t v2 = off_1009F8098;
  int v3 = *(unsigned __int8 *)(a1 + 22);

  return sub_100299458((uint64_t)v2, a1 + 10, a1 + 16, v3);
}

void sub_1002B09D0()
{
}

void sub_1002B09E4()
{
  if (qword_1009F80A0 != -1) {
    dispatch_once(&qword_1009F80A0, &stru_1009A1E90);
  }
}

void sub_1002B0A0C(uint64_t a1, int *a2, char a3, uint64_t a4, char a5)
{
  *(_WORD *)(a1 + 8) = 1;
  *(void *)a1 = off_1009A1808;
  int v5 = *a2;
  *(_WORD *)(a1 + 14) = *((_WORD *)a2 + 2);
  *(_DWORD *)(a1 + 10) = v5;
  *(unsigned char *)(a1 + 16) = a3;
  *(unsigned char *)(a1 + 32) = a5;
  operator new[]();
}

void sub_1002B0B08(uint64_t a1)
{
  sub_1002B0BB0(a1);

  operator delete();
}

uint64_t sub_1002B0B40(uint64_t a1)
{
  if (qword_1009F80A0 != -1) {
    dispatch_once(&qword_1009F80A0, &stru_1009A1E90);
  }
  uint64_t v2 = off_1009F8098;
  int v3 = *(unsigned __int8 *)(a1 + 16);
  uint64_t v4 = *(void *)(a1 + 24);

  return sub_100299704((uint64_t)v2, a1 + 10, v3, v4);
}

uint64_t sub_1002B0BB0(uint64_t result)
{
  *(void *)uint64_t result = off_1009A1808;
  if (*(unsigned char *)(result + 16))
  {
    unint64_t v1 = 0;
    uint64_t v2 = 8;
    do
    {
      if (*(void *)(*(void *)(result + 24) + v2)) {
        operator delete[]();
      }
      ++v1;
      v2 += 16;
    }
    while (v1 < *(unsigned __int8 *)(result + 16));
  }
  if (*(void *)(result + 24)) {
    operator delete[]();
  }
  return result;
}

void sub_1002B0C5C()
{
}

uint64_t sub_1002B0C70(unsigned __int16 *a1)
{
  if (qword_1009F80A0 != -1) {
    dispatch_once(&qword_1009F80A0, &stru_1009A1E90);
  }
  uint64_t v2 = off_1009F8098;
  int v3 = a1[8];
  uint64_t v4 = a1[9];
  uint64_t v5 = a1[10];

  return sub_10029A6E8((uint64_t)v2, (uint64_t)(a1 + 5), v3, v4, v5);
}

void *sub_1002B0CE0(void *result)
{
  *uint64_t result = off_1009A1878;
  if (result[3]) {
    operator delete[]();
  }
  return result;
}

void sub_1002B0D3C(void *a1)
{
  *a1 = off_1009A1878;
  if (a1[3]) {
    operator delete[]();
  }

  operator delete();
}

uint64_t sub_1002B0DB8(uint64_t a1)
{
  if (qword_1009F80A0 != -1) {
    dispatch_once(&qword_1009F80A0, &stru_1009A1E90);
  }
  uint64_t v2 = off_1009F8098;
  int v3 = *(_DWORD *)(a1 + 20);
  int v4 = *(unsigned __int16 *)(a1 + 16);
  uint64_t v5 = *(void *)(a1 + 24);

  return sub_10029AB0C((uint64_t)v2, a1 + 10, v3, v4, v5);
}

void sub_1002B0E2C()
{
}

void sub_1002B0E40(uint64_t a1)
{
  if (qword_1009F80A0 != -1) {
    dispatch_once(&qword_1009F80A0, &stru_1009A1E90);
  }
  int v2 = *(_DWORD *)(a1 + 16);

  sub_10029BD38(a1, a1 + 10, v2);
}

void sub_1002B0EA4()
{
}

void sub_1002B0EB8(uint64_t a1)
{
  if (qword_1009F80A0 != -1) {
    dispatch_once(&qword_1009F80A0, &stru_1009A1E90);
  }
  int v2 = off_1009F8098;
  int v3 = *(unsigned __int8 *)(a1 + 16);
  unsigned int v4 = *(_DWORD *)(a1 + 20);

  sub_10029BE74((uint64_t)v2, a1 + 10, v3, v4);
}

void *sub_1002B0F24(void *result)
{
  *uint64_t result = off_1009A1920;
  if (result[3]) {
    operator delete[]();
  }
  return result;
}

void sub_1002B0F80(void *a1)
{
  *a1 = off_1009A1920;
  if (a1[3]) {
    operator delete[]();
  }

  operator delete();
}

uint64_t sub_1002B0FFC(uint64_t a1)
{
  if (qword_1009F80A0 != -1) {
    dispatch_once(&qword_1009F80A0, &stru_1009A1E90);
  }
  int v2 = off_1009F8098;
  int v3 = *(unsigned __int8 *)(a1 + 16);
  unsigned int v4 = *(unsigned __int16 *)(a1 + 18);
  uint64_t v5 = *(unsigned __int8 **)(a1 + 24);

  return sub_10029CB08((uint64_t)v2, a1 + 10, v3, v4, v5);
}

void *sub_1002B106C(void *result)
{
  *uint64_t result = off_1009A1958;
  if (result[3]) {
    operator delete[]();
  }
  return result;
}

void sub_1002B10C8(void *a1)
{
  *a1 = off_1009A1958;
  if (a1[3]) {
    operator delete[]();
  }

  operator delete();
}

void sub_1002B1144(uint64_t a1)
{
  if (qword_1009F80A0 != -1) {
    dispatch_once(&qword_1009F80A0, &stru_1009A1E90);
  }
  int v2 = off_1009F8098;
  unsigned int v3 = *(unsigned __int8 *)(a1 + 16);
  unsigned int v4 = *(unsigned __int16 *)(a1 + 18);
  uint64_t v5 = *(const UInt8 **)(a1 + 24);

  sub_10029E51C((uint64_t)v2, (int *)(a1 + 10), v3, v4, v5);
}

void *sub_1002B11B4(void *result)
{
  *uint64_t result = off_1009A1990;
  if (result[3]) {
    operator delete[]();
  }
  return result;
}

void sub_1002B1210(void *a1)
{
  *a1 = off_1009A1990;
  if (a1[3]) {
    operator delete[]();
  }

  operator delete();
}

void sub_1002B128C(uint64_t a1)
{
  if (qword_1009F80A0 != -1) {
    dispatch_once(&qword_1009F80A0, &stru_1009A1E90);
  }
  int v2 = off_1009F8098;
  unsigned int v3 = *(unsigned __int16 *)(a1 + 16);
  unsigned int v4 = *(const UInt8 **)(a1 + 24);

  sub_10029E6C0((uint64_t)v2, a1 + 10, v3, v4);
}

void *sub_1002B12F8(void *result)
{
  *uint64_t result = off_1009A19C8;
  if (result[3]) {
    operator delete[]();
  }
  return result;
}

void sub_1002B1354(void *a1)
{
  *a1 = off_1009A19C8;
  if (a1[3]) {
    operator delete[]();
  }

  operator delete();
}

void sub_1002B13D0(uint64_t a1)
{
  if (qword_1009F80A0 != -1) {
    dispatch_once(&qword_1009F80A0, &stru_1009A1E90);
  }
  int v2 = *(unsigned __int8 *)(a1 + 16);
  uint64_t v3 = *(unsigned __int8 *)(a1 + 17);
  uint64_t v4 = *(unsigned __int16 *)(a1 + 18);
  uint64_t v5 = *(unsigned __int16 **)(a1 + 24);

  sub_10029E8EC(a1, a1 + 10, v2, v3, v4, v5);
}

uint64_t sub_1002B143C(uint64_t a1, int *a2, long long *a3)
{
  *(_WORD *)(a1 + 8) = 1;
  *(void *)a1 = off_1009A1A00;
  int v4 = *a2;
  *(_WORD *)(a1 + 14) = *((_WORD *)a2 + 2);
  *(_DWORD *)(a1 + 10) = v4;
  long long v5 = *a3;
  *(_OWORD *)(a1 + 30) = *(long long *)((char *)a3 + 14);
  *(_OWORD *)(a1 + 16) = v5;
  uint64_t v6 = *(const char **)((char *)a3 + 22);
  if (v6)
  {
    strlen(v6);
    operator new[]();
  }
  return a1;
}

void *sub_1002B14F4(void *result)
{
  *uint64_t result = off_1009A1A00;
  if (result[6]) {
    operator delete[]();
  }
  return result;
}

void sub_1002B1550(void *a1)
{
  *a1 = off_1009A1A00;
  if (a1[6]) {
    operator delete[]();
  }

  operator delete();
}

void sub_1002B15CC(uint64_t a1)
{
  if (qword_1009F80A0 != -1) {
    dispatch_once(&qword_1009F80A0, &stru_1009A1E90);
  }
  int v2 = off_1009F8098;

  sub_10029EB70((uint64_t)v2, a1 + 10, (unsigned __int8 *)(a1 + 16));
}

void *sub_1002B1634(void *result)
{
  *uint64_t result = off_1009A1A38;
  if (result[3]) {
    operator delete[]();
  }
  return result;
}

void sub_1002B1690(void *a1)
{
  *a1 = off_1009A1A38;
  if (a1[3]) {
    operator delete[]();
  }

  operator delete();
}

uint64_t sub_1002B170C(uint64_t a1)
{
  if (qword_1009F80A0 != -1) {
    dispatch_once(&qword_1009F80A0, &stru_1009A1E90);
  }
  int v2 = *(unsigned __int16 *)(a1 + 22);
  uint64_t v3 = *(unsigned __int8 **)(a1 + 24);

  return sub_10029F104(a1, a1 + 10, (unsigned int *)(a1 + 16), v2, v3);
}

void sub_1002B1774(uint64_t a1, int *a2, char a3, char a4, char a5, char a6, char *__s, __int16 a8, void *__src)
{
  *(_WORD *)(a1 + 8) = 1;
  *(void *)a1 = off_1009A1A70;
  int v11 = *a2;
  *(_WORD *)(a1 + 14) = *((_WORD *)a2 + 2);
  *(_DWORD *)(a1 + 10) = v11;
  *(unsigned char *)(a1 + 16) = a3;
  *(unsigned char *)(a1 + 17) = a4;
  *(unsigned char *)(a1 + 18) = a5;
  *(unsigned char *)(a1 + 19) = a6;
  sub_10004191C((void *)(a1 + 24), __s);
  *(_WORD *)(a1 + 48) = a8;
  operator new[]();
}

void sub_1002B1828(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 47) < 0) {
    operator delete(*v2);
  }
  _Unwind_Resume(exception_object);
}

void sub_1002B1848(uint64_t a1)
{
  sub_1002B1988(a1);

  operator delete();
}

void sub_1002B1880(uint64_t a1)
{
  if (qword_1009F80A0 != -1) {
    dispatch_once(&qword_1009F80A0, &stru_1009A1E90);
  }
  int v2 = off_1009F8098;
  int v3 = *(unsigned __int8 *)(a1 + 16);
  int v4 = *(unsigned __int8 *)(a1 + 17);
  int v5 = *(unsigned __int8 *)(a1 + 18);
  int v6 = *(unsigned __int8 *)(a1 + 19);
  if (*(char *)(a1 + 47) < 0)
  {
    sub_10003B098(__p, *(void **)(a1 + 24), *(void *)(a1 + 32));
  }
  else
  {
    *(_OWORD *)std::string __p = *(_OWORD *)(a1 + 24);
    uint64_t v8 = *(void *)(a1 + 40);
  }
  sub_10029F2AC((uint64_t)v2, a1 + 10, v3, v4, v5, v6, (char *)__p, *(unsigned __int16 *)(a1 + 48), *(char **)(a1 + 56));
  if (SHIBYTE(v8) < 0) {
    operator delete(__p[0]);
  }
}

void sub_1002B196C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1002B1988(uint64_t a1)
{
  *(void *)a1 = off_1009A1A70;
  if (*(void *)(a1 + 56)) {
    operator delete[]();
  }
  if (*(char *)(a1 + 47) < 0) {
    operator delete(*(void **)(a1 + 24));
  }
  return a1;
}

uint64_t sub_1002B19F4(uint64_t a1, int *a2, const void *a3, size_t __sz, char a5)
{
  *(_WORD *)(a1 + 8) = 1;
  *(void *)a1 = off_1009A1AA8;
  int v7 = *a2;
  __int16 v8 = *((_WORD *)a2 + 2);
  *(void *)(a1 + 16) = 0;
  uint64_t v9 = (void *)(a1 + 16);
  *((_WORD *)v9 - 1) = v8;
  *(_DWORD *)((char *)v9 - 6) = v7;
  v9[1] = 0;
  void v9[2] = 0;
  if (__sz)
  {
    int v10 = __sz;
    size_t v12 = __sz;
    sub_1002B1BCC(v9, __sz);
    char v13 = *(char **)(a1 + 24);
    memmove(v13, a3, v12);
    *(void *)(a1 + 24) = &v13[v10];
  }
  *(unsigned char *)(a1 + 40) = a5;
  return a1;
}

void *sub_1002B1AA0(void *a1)
{
  *a1 = off_1009A1AA8;
  int v2 = (void *)a1[2];
  if (v2)
  {
    a1[3] = v2;
    operator delete(v2);
  }
  return a1;
}

void sub_1002B1AF0(void *a1)
{
  *a1 = off_1009A1AA8;
  int v2 = (void *)a1[2];
  if (v2)
  {
    a1[3] = v2;
    operator delete(v2);
  }

  operator delete();
}

uint64_t sub_1002B1B60(uint64_t a1)
{
  if (qword_1009F80A0 != -1) {
    dispatch_once(&qword_1009F80A0, &stru_1009A1E90);
  }
  int v2 = off_1009F8098;
  int v3 = *(unsigned __int8 *)(a1 + 40);

  return sub_10029F8BC((uint64_t)v2, a1 + 10, a1 + 16, v3);
}

char *sub_1002B1BCC(void *a1, size_t __sz)
{
  if ((__sz & 0x8000000000000000) != 0) {
    abort();
  }
  uint64_t result = (char *)operator new(__sz);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[__sz];
  return result;
}

uint64_t sub_1002B1C0C(uint64_t a1, int *a2, const void *a3, size_t __sz)
{
  *(_WORD *)(a1 + 8) = 1;
  *(void *)a1 = off_1009A1AE0;
  int v5 = *a2;
  __int16 v6 = *((_WORD *)a2 + 2);
  *(void *)(a1 + 16) = 0;
  int v7 = (void *)(a1 + 16);
  *((_WORD *)v7 - 1) = v6;
  *(_DWORD *)((char *)v7 - 6) = v5;
  v7[1] = 0;
  void v7[2] = 0;
  if (__sz)
  {
    int v8 = __sz;
    size_t v10 = __sz;
    sub_1002B1BCC(v7, __sz);
    int v11 = *(char **)(a1 + 24);
    memmove(v11, a3, v10);
    *(void *)(a1 + 24) = &v11[v8];
  }
  return a1;
}

void *sub_1002B1CB0(void *a1)
{
  *a1 = off_1009A1AE0;
  int v2 = (void *)a1[2];
  if (v2)
  {
    a1[3] = v2;
    operator delete(v2);
  }
  return a1;
}

void sub_1002B1D00(void *a1)
{
  *a1 = off_1009A1AE0;
  int v2 = (void *)a1[2];
  if (v2)
  {
    a1[3] = v2;
    operator delete(v2);
  }

  operator delete();
}

uint64_t sub_1002B1D70(uint64_t a1)
{
  if (qword_1009F80A0 != -1) {
    dispatch_once(&qword_1009F80A0, &stru_1009A1E90);
  }
  int v2 = off_1009F8098;

  return sub_1002A00F8((uint64_t)v2, a1 + 10, (void *)(a1 + 16));
}

uint64_t sub_1002B1DD8(uint64_t a1, int *a2, size_t __sz, const void *a4)
{
  *(_WORD *)(a1 + 8) = 1;
  *(void *)a1 = off_1009A1B18;
  int v5 = *a2;
  __int16 v6 = *((_WORD *)a2 + 2);
  *(void *)(a1 + 24) = 0;
  int v7 = (void *)(a1 + 24);
  *((_WORD *)v7 - 5) = v6;
  *(_DWORD *)((char *)v7 - 14) = v5;
  *((_WORD *)v7 - 4) = __sz;
  v7[1] = 0;
  void v7[2] = 0;
  if (__sz)
  {
    int v9 = __sz;
    size_t v10 = __sz;
    sub_1002B1BCC(v7, __sz);
    int v11 = *(char **)(a1 + 32);
    memmove(v11, a4, v10);
    *(void *)(a1 + 32) = &v11[v9];
  }
  return a1;
}

void *sub_1002B1E80(void *a1)
{
  *a1 = off_1009A1B18;
  int v2 = (void *)a1[3];
  if (v2)
  {
    a1[4] = v2;
    operator delete(v2);
  }
  return a1;
}

void sub_1002B1ED0(void *a1)
{
  *a1 = off_1009A1B18;
  int v2 = (void *)a1[3];
  if (v2)
  {
    a1[4] = v2;
    operator delete(v2);
  }

  operator delete();
}

uint64_t sub_1002B1F40(uint64_t a1)
{
  if (qword_1009F80A0 != -1) {
    dispatch_once(&qword_1009F80A0, &stru_1009A1E90);
  }
  int v2 = off_1009F8098;

  return sub_1002A02C8((uint64_t)v2, a1 + 10, 0, (unsigned __int8 **)(a1 + 24));
}

void sub_1002B1FB0()
{
}

uint64_t sub_1002B1FC4(uint64_t a1)
{
  if (qword_1009F80A0 != -1) {
    dispatch_once(&qword_1009F80A0, &stru_1009A1E90);
  }
  int v2 = off_1009F8098;
  uint64_t v3 = *(void *)(a1 + 16);

  return sub_1002A07D8((uint64_t)v2, a1 + 10, v3);
}

uint64_t sub_1002B202C(uint64_t a1, int *a2, int a3, uint64_t a4)
{
  *(_WORD *)(a1 + 8) = 1;
  *(void *)a1 = off_1009A1B88;
  int v5 = *a2;
  *(_WORD *)(a1 + 14) = *((_WORD *)a2 + 2);
  *(_DWORD *)(a1 + 10) = v5;
  *(unsigned char *)(a1 + 16) = a3;
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 40) = 0;
  *(void *)(a1 + 24) = 0;
  switch(a3)
  {
    case 0:
      int v7 = (char *)operator new(9uLL);
      *(void *)int v7 = *(void *)a4;
      v7[8] = *(unsigned char *)(a4 + 8);
      int v8 = v7 + 9;
      goto LABEL_5;
    case 1:
      int v7 = (char *)operator new(0xBuLL);
      *(void *)int v7 = *(void *)a4;
      *(_DWORD *)(v7 + 7) = *(_DWORD *)(a4 + 7);
      int v8 = v7 + 11;
      goto LABEL_5;
    case 2:
    case 3:
      int v7 = (char *)operator new(8uLL);
      *(void *)int v7 = *(void *)a4;
      int v8 = v7 + 8;
LABEL_5:
      *(void *)(a1 + 24) = v7;
      *(void *)(a1 + 32) = v8;
      *(void *)(a1 + 40) = v8;
      break;
    default:
      return a1;
  }
  return a1;
}

void *sub_1002B212C(void *a1)
{
  *a1 = off_1009A1B88;
  int v2 = (void *)a1[3];
  if (v2)
  {
    a1[4] = v2;
    operator delete(v2);
  }
  return a1;
}

void sub_1002B217C(void *a1)
{
  *a1 = off_1009A1B88;
  int v2 = (void *)a1[3];
  if (v2)
  {
    a1[4] = v2;
    operator delete(v2);
  }

  operator delete();
}

void sub_1002B21EC(uint64_t a1, uint64_t a2)
{
  if (qword_1009F80A0 != -1) {
    dispatch_once(&qword_1009F80A0, &stru_1009A1E90);
  }
  int v3 = *(unsigned __int8 *)(a1 + 16);

  sub_1002A091C(a1, a2, v3, (unsigned __int8 **)(a1 + 24));
}

uint64_t sub_1002B224C(uint64_t a1, int *a2, char a3, uint64_t a4, size_t __sz, const void *a6)
{
  *(_WORD *)(a1 + 8) = 1;
  *(void *)a1 = off_1009A1BC0;
  int v7 = *a2;
  __int16 v8 = *((_WORD *)a2 + 2);
  *(void *)(a1 + 40) = 0;
  int v9 = (void *)(a1 + 40);
  *((_WORD *)v9 - 13) = v8;
  *(_DWORD *)((char *)v9 - 30) = v7;
  *((unsigned char *)v9 - 24) = a3;
  *(v9 - 2) = a4;
  *((_WORD *)v9 - 4) = __sz;
  v9[1] = 0;
  void v9[2] = 0;
  if (__sz)
  {
    int v11 = __sz;
    size_t v12 = __sz;
    sub_1002B1BCC(v9, __sz);
    char v13 = *(char **)(a1 + 48);
    memmove(v13, a6, v12);
    *(void *)(a1 + 48) = &v13[v11];
  }
  return a1;
}

void *sub_1002B22FC(void *a1)
{
  *a1 = off_1009A1BC0;
  int v2 = (void *)a1[5];
  if (v2)
  {
    a1[6] = v2;
    operator delete(v2);
  }
  return a1;
}

void sub_1002B234C(void *a1)
{
  *a1 = off_1009A1BC0;
  int v2 = (void *)a1[5];
  if (v2)
  {
    a1[6] = v2;
    operator delete(v2);
  }

  operator delete();
}

uint64_t sub_1002B23BC(uint64_t a1, uint64_t a2)
{
  if (qword_1009F80A0 != -1) {
    dispatch_once(&qword_1009F80A0, &stru_1009A1E90);
  }
  int v3 = off_1009F8098;
  unsigned int v4 = *(unsigned __int8 *)(a1 + 16);
  unint64_t v5 = *(void *)(a1 + 24);
  unsigned int v6 = *(unsigned __int16 *)(a1 + 32);

  return sub_10029FAF8((uint64_t)v3, a2, v4, v5, v6, (void *)(a1 + 40));
}

void *sub_1002B242C(void *result)
{
  *uint64_t result = off_1009A1BF8;
  if (result[2]) {
    operator delete[]();
  }
  return result;
}

void sub_1002B2488(void *a1)
{
  *a1 = off_1009A1BF8;
  if (a1[2]) {
    operator delete[]();
  }

  operator delete();
}

void sub_1002B2504(uint64_t a1)
{
  if (qword_1009F80A0 != -1) {
    dispatch_once(&qword_1009F80A0, &stru_1009A1E90);
  }
  int v2 = off_1009F8098;
  int v3 = *(const UInt8 **)(a1 + 16);
  unsigned int v4 = *(unsigned __int16 *)(a1 + 24);
  int v5 = *(unsigned __int8 *)(a1 + 26);
  int v6 = *(unsigned __int8 *)(a1 + 27);

  sub_1002A1768((uint64_t)v2, a1 + 10, v3, v4, v5, v6);
}

void *sub_1002B2578(void *result)
{
  *uint64_t result = off_1009A1C30;
  if (result[3]) {
    operator delete[]();
  }
  return result;
}

void sub_1002B25D4(void *a1)
{
  *a1 = off_1009A1C30;
  if (a1[3]) {
    operator delete[]();
  }

  operator delete();
}

uint64_t sub_1002B2650(uint64_t a1)
{
  if (qword_1009F80A0 != -1) {
    dispatch_once(&qword_1009F80A0, &stru_1009A1E90);
  }
  int v2 = off_1009F8098;
  uint64_t v3 = *(unsigned __int16 *)(a1 + 16);
  uint64_t v4 = *(void *)(a1 + 24);

  return sub_1002A0C30((uint64_t)v2, (unsigned __int8 *)(a1 + 10), v3, v4);
}

uint64_t sub_1002B26BC(uint64_t a1, int *a2, size_t __sz, const void *a4)
{
  *(_WORD *)(a1 + 8) = 1;
  *(void *)a1 = off_1009A1C68;
  int v5 = *a2;
  __int16 v6 = *((_WORD *)a2 + 2);
  *(void *)(a1 + 16) = 0;
  int v7 = (void *)(a1 + 16);
  *((_WORD *)v7 - 1) = v6;
  *(_DWORD *)((char *)v7 - 6) = v5;
  v7[1] = 0;
  void v7[2] = 0;
  if (__sz)
  {
    int v9 = __sz;
    size_t v10 = __sz;
    sub_1002B1BCC(v7, __sz);
    int v11 = *(char **)(a1 + 24);
    memmove(v11, a4, v10);
    *(void *)(a1 + 24) = &v11[v9];
  }
  return a1;
}

void *sub_1002B2760(void *a1)
{
  *a1 = off_1009A1C68;
  int v2 = (void *)a1[2];
  if (v2)
  {
    a1[3] = v2;
    operator delete(v2);
  }
  return a1;
}

void sub_1002B27B0(void *a1)
{
  *a1 = off_1009A1C68;
  int v2 = (void *)a1[2];
  if (v2)
  {
    a1[3] = v2;
    operator delete(v2);
  }

  operator delete();
}

uint64_t sub_1002B2820(uint64_t a1)
{
  if (qword_1009F80A0 != -1) {
    dispatch_once(&qword_1009F80A0, &stru_1009A1E90);
  }
  int v2 = off_1009F8098;

  return sub_1002A0D58((uint64_t)v2, a1 + 10, (uint64_t *)(a1 + 16));
}

uint64_t sub_1002B2888(uint64_t a1, int *a2, char a3, unsigned int a4, const void *a5)
{
  *(_WORD *)(a1 + 8) = 1;
  *(void *)a1 = off_1009A1CA0;
  int v6 = *a2;
  __int16 v7 = *((_WORD *)a2 + 2);
  *(void *)(a1 + 24) = 0;
  __int16 v8 = (void *)(a1 + 24);
  *((_WORD *)v8 - 5) = v7;
  *(_DWORD *)((char *)v8 - 14) = v6;
  *((unsigned char *)v8 - 8) = a3;
  v8[1] = 0;
  void v8[2] = 0;
  if (a4)
  {
    size_t v11 = 8 * a4;
    sub_1000405B8(v8, a4);
    size_t v12 = *(char **)(a1 + 32);
    memmove(v12, a5, v11);
    *(void *)(a1 + 32) = &v12[8 * a4];
  }
  return a1;
}

void *sub_1002B2930(void *a1)
{
  *a1 = off_1009A1CA0;
  int v2 = (void *)a1[3];
  if (v2)
  {
    a1[4] = v2;
    operator delete(v2);
  }
  return a1;
}

void sub_1002B2980(void *a1)
{
  *a1 = off_1009A1CA0;
  int v2 = (void *)a1[3];
  if (v2)
  {
    a1[4] = v2;
    operator delete(v2);
  }

  operator delete();
}

void sub_1002B29F0(uint64_t a1)
{
  if (qword_1009F80A0 != -1) {
    dispatch_once(&qword_1009F80A0, &stru_1009A1E90);
  }
  int v2 = off_1009F8098;
  int v3 = *(unsigned __int8 *)(a1 + 16);
  sub_100040550(__p, a1 + 24);
  sub_1002A1144((uint64_t)v2, a1 + 10, v3, (uint64_t *)__p);
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }
}

void sub_1002B2A88(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1002B2AA4(uint64_t a1, int *a2, size_t __sz, const void *a4)
{
  *(_WORD *)(a1 + 8) = 1;
  *(void *)a1 = off_1009A1CD8;
  int v5 = *a2;
  __int16 v6 = *((_WORD *)a2 + 2);
  *(void *)(a1 + 24) = 0;
  __int16 v7 = (void *)(a1 + 24);
  *((_WORD *)v7 - 5) = v6;
  *(_DWORD *)((char *)v7 - 14) = v5;
  *((_WORD *)v7 - 4) = __sz;
  v7[1] = 0;
  void v7[2] = 0;
  if (__sz)
  {
    int v9 = __sz;
    size_t v10 = __sz;
    sub_1002B1BCC(v7, __sz);
    size_t v11 = *(char **)(a1 + 32);
    memmove(v11, a4, v10);
    *(void *)(a1 + 32) = &v11[v9];
  }
  return a1;
}

void *sub_1002B2B4C(void *a1)
{
  *a1 = off_1009A1CD8;
  int v2 = (void *)a1[3];
  if (v2)
  {
    a1[4] = v2;
    operator delete(v2);
  }
  return a1;
}

void sub_1002B2B9C(void *a1)
{
  *a1 = off_1009A1CD8;
  int v2 = (void *)a1[3];
  if (v2)
  {
    a1[4] = v2;
    operator delete(v2);
  }

  operator delete();
}

uint64_t sub_1002B2C0C(uint64_t a1)
{
  if (qword_1009F80A0 != -1) {
    dispatch_once(&qword_1009F80A0, &stru_1009A1E90);
  }
  int v2 = off_1009F8098;

  return sub_1002A0F64((uint64_t)v2, a1 + 10, 0, (uint64_t *)(a1 + 24));
}

uint64_t sub_1002B2C78(uint64_t a1, int *a2, __int16 a3, size_t __sz, const void *a5)
{
  *(_WORD *)(a1 + 8) = 1;
  *(void *)a1 = off_1009A1D10;
  int v6 = *a2;
  __int16 v7 = *((_WORD *)a2 + 2);
  *(void *)(a1 + 24) = 0;
  __int16 v8 = (void *)(a1 + 24);
  *((_WORD *)v8 - 5) = v7;
  *(_DWORD *)((char *)v8 - 14) = v6;
  *((_WORD *)v8 - 4) = a3;
  v8[1] = 0;
  void v8[2] = 0;
  if (__sz)
  {
    int v10 = __sz;
    size_t v11 = __sz;
    sub_1002B1BCC(v8, __sz);
    size_t v12 = *(char **)(a1 + 32);
    memmove(v12, a5, v11);
    *(void *)(a1 + 32) = &v12[v10];
  }
  return a1;
}

void *sub_1002B2D20(void *a1)
{
  *a1 = off_1009A1D10;
  int v2 = (void *)a1[3];
  if (v2)
  {
    a1[4] = v2;
    operator delete(v2);
  }
  return a1;
}

void sub_1002B2D70(void *a1)
{
  *a1 = off_1009A1D10;
  int v2 = (void *)a1[3];
  if (v2)
  {
    a1[4] = v2;
    operator delete(v2);
  }

  operator delete();
}

uint64_t sub_1002B2DE0(uint64_t a1)
{
  if (qword_1009F80A0 != -1) {
    dispatch_once(&qword_1009F80A0, &stru_1009A1E90);
  }
  int v2 = off_1009F8098;
  int v3 = *(unsigned __int8 *)(a1 + 16);

  return sub_1002A1518((uint64_t)v2, a1 + 10, v3, (unsigned __int8 **)(a1 + 24));
}

void *sub_1002B2E4C(void *result)
{
  *uint64_t result = &off_1009A1D48;
  if (result[3]) {
    operator delete[]();
  }
  return result;
}

void sub_1002B2EA8(void *a1)
{
  *a1 = &off_1009A1D48;
  if (a1[3]) {
    operator delete[]();
  }

  operator delete();
}

void sub_1002B2F24(uint64_t a1)
{
  if (qword_1009F80A0 != -1) {
    dispatch_once(&qword_1009F80A0, &stru_1009A1E90);
  }
  int v2 = off_1009F8098;
  int v3 = *(unsigned __int16 *)(a1 + 16);
  int v4 = *(unsigned __int16 *)(a1 + 18);
  int v5 = *(char **)(a1 + 24);

  sub_10029EDF4((uint64_t)v2, a1 + 10, v3, v4, v5);
}

uint64_t sub_1002B2F94(void *a1)
{
  int v2 = (void **)a1[1];
  int v3 = (void **)a1[2];
  a1[5] = 0;
  unint64_t v4 = (char *)v3 - (char *)v2;
  if ((unint64_t)((char *)v3 - (char *)v2) >= 0x11)
  {
    do
    {
      operator delete(*v2);
      int v3 = (void **)a1[2];
      int v2 = (void **)(a1[1] + 8);
      a1[1] = v2;
      unint64_t v4 = (char *)v3 - (char *)v2;
    }
    while ((unint64_t)((char *)v3 - (char *)v2) > 0x10);
  }
  unint64_t v5 = v4 >> 3;
  if (v5 == 1)
  {
    uint64_t v6 = 512;
  }
  else
  {
    if (v5 != 2) {
      goto LABEL_9;
    }
    uint64_t v6 = 1024;
  }
  a1[4] = v6;
LABEL_9:
  while (v2 != v3)
  {
    __int16 v7 = *v2++;
    operator delete(v7);
  }

  return sub_1002B303C((uint64_t)a1);
}

uint64_t sub_1002B303C(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  uint64_t v2 = *(void *)(a1 + 16);
  if (v2 != v3) {
    *(void *)(a1 + 16) = v2 + ((v3 - v2 + 7) & 0xFFFFFFFFFFFFFFF8);
  }
  unint64_t v4 = *(void **)a1;
  if (*(void *)a1) {
    operator delete(v4);
  }
  return a1;
}

void *sub_1002B308C(void *result)
{
  if (result[2])
  {
    uint64_t v1 = result;
    uint64_t result = (void *)result[1];
    uint64_t v2 = *v1;
    uint64_t v3 = *result;
    *(void *)(v3 + 8) = *(void *)(*v1 + 8);
    **(void **)(v2 + 8) = v3;
    v1[2] = 0;
    if (result != v1)
    {
      do
      {
        unint64_t v4 = (void *)result[1];
        operator delete(result);
        uint64_t result = v4;
      }
      while (v4 != v1);
    }
  }
  return result;
}

uint64_t sub_1002B30F0(uint64_t a1)
{
  if (*(char *)(a1 + 47) < 0) {
    operator delete(*(void **)(a1 + 24));
  }
  uint64_t v2 = *(void **)a1;
  if (*(void *)a1)
  {
    *(void *)(a1 + 8) = v2;
    operator delete(v2);
  }
  return a1;
}

uint64_t sub_1002B3134(uint64_t a1, int a2, long long *a3, unsigned int a4, char *__src, char a6)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  if (*((char *)a3 + 23) < 0)
  {
    sub_10003B098((unsigned char *)(a1 + 24), *(void **)a3, *((void *)a3 + 1));
    int v10 = *(char **)(a1 + 8);
  }
  else
  {
    int v10 = 0;
    long long v11 = *a3;
    *(void *)(a1 + 40) = *((void *)a3 + 2);
    *(_OWORD *)(a1 + 24) = v11;
  }
  *(unsigned char *)(a1 + 48) = a6;
  sub_1000119B0(a1, v10, __src, &__src[a4], a4);
  return a1;
}

void sub_1002B31C8(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1002B31FC(uint64_t a1)
{
  *(void *)a1 = off_1009A0FB0;
  *(void *)(a1 + 256) = &off_1009A1088;
  *(void *)(a1 + 264) = off_1009A10A0;
  *(void *)(a1 + 272) = off_1009A10C8;
  *(void *)(a1 + 280) = &off_1009A10F8;
  *(void *)(a1 + 288) = off_1009A1110;
  *(void *)(a1 + 296) = off_1009A1140;
  sub_100052DA4(a1 + 648);
  sub_100052DA4(a1 + 584);
  uint64_t v2 = *(void **)(a1 + 560);
  if (v2)
  {
    *(void *)(a1 + 568) = v2;
    operator delete(v2);
  }
  sub_1000486F0(a1 + 536, *(void **)(a1 + 544));
  uint64_t v3 = *(void *)(a1 + 488);
  *(void *)(a1 + 488) = 0;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 64))(v3);
  }
  sub_1002B38CC(a1 + 448);

  sub_100052DA4(a1 + 360);
  unint64_t v4 = *(void **)(a1 + 336);
  if (v4)
  {
    *(void *)(a1 + 344) = v4;
    operator delete(v4);
  }

  return sub_100283DC8(a1);
}

char *sub_1002B3390(char *result, long long *a2, long long *a3, unint64_t a4)
{
  if (a4)
  {
    uint64_t v6 = result;
    sub_1002B33F0(result, a4);
    uint64_t result = sub_1002B3488((int)v6 + 16, a2, a3, *((char **)v6 + 1));
    *((void *)v6 + 1) = result;
  }
  return result;
}

void sub_1002B33E8(_Unwind_Exception *a1)
{
  *(void *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

char *sub_1002B33F0(void *a1, unint64_t a2)
{
  if (a2 >= 0xAAAAAAAAAAAAAABLL) {
    abort();
  }
  uint64_t result = (char *)sub_1002B3440((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[24 * v4];
  return result;
}

void *sub_1002B3440(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0xAAAAAAAAAAAAAABLL) {
    sub_1000616DC();
  }
  return operator new(24 * a2);
}

char *sub_1002B3488(int a1, long long *a2, long long *a3, char *__dst)
{
  if (a2 != a3)
  {
    uint64_t v6 = a2;
    do
    {
      if (*((char *)v6 + 23) < 0)
      {
        sub_10003B098(__dst, *(void **)v6, *((void *)v6 + 1));
      }
      else
      {
        long long v7 = *v6;
        *((void *)__dst + 2) = *((void *)v6 + 2);
        *(_OWORD *)long long __dst = v7;
      }
      uint64_t v6 = (long long *)((char *)v6 + 24);
      __dst += 24;
    }
    while (v6 != a3);
  }
  return __dst;
}

uint64_t sub_1002B34FC(uint64_t a1, const void **a2, uint64_t a3)
{
  *(void *)(a1 + 8) = 0;
  uint64_t v4 = (uint64_t *)(a1 + 8);
  *(void *)(a1 + 16) = 0;
  *(void *)a1 = a1 + 8;
  if (a3)
  {
    uint64_t v6 = 32 * a3;
    do
    {
      sub_1002B357C((uint64_t **)a1, v4, a2, (uint64_t)a2);
      a2 += 4;
      v6 -= 32;
    }
    while (v6);
  }
  return a1;
}

void sub_1002B3564(_Unwind_Exception *a1)
{
  sub_10004BA28(v1, *(char **)(v1 + 8));
  _Unwind_Resume(a1);
}

uint64_t *sub_1002B357C(uint64_t **a1, uint64_t *a2, const void **a3, uint64_t a4)
{
  uint64_t v9 = 0;
  int v10 = 0;
  uint64_t v6 = (uint64_t **)sub_1002B360C(a1, a2, &v10, &v9, a3);
  uint64_t result = *v6;
  if (!*v6)
  {
    memset(v8, 0, sizeof(v8));
    sub_1002B37B8((uint64_t)a1, a4, v8);
    sub_100036CA0(a1, (uint64_t)v10, v6, v8[0]);
    return v8[0];
  }
  return result;
}

const void **sub_1002B360C(void *a1, uint64_t *a2, const void ***a3, uint64_t *a4, const void **a5)
{
  uint64_t v9 = (const void **)(a1 + 1);
  if (a1 + 1 != a2 && !sub_1000315FC((uint64_t)(a1 + 2), a5, (const void **)a2 + 4))
  {
    if (!sub_1000315FC((uint64_t)(a1 + 2), (const void **)a2 + 4, a5))
    {
      *a3 = (const void **)a2;
      *a4 = (uint64_t)a2;
      return (const void **)a4;
    }
    a4 = a2 + 1;
    uint64_t v13 = a2[1];
    if (v13)
    {
      unint64_t v14 = (const void **)a2[1];
      do
      {
        uint64_t v15 = v14;
        unint64_t v14 = (const void **)*v14;
      }
      while (v14);
    }
    else
    {
      unint64_t v18 = (const void **)a2;
      do
      {
        uint64_t v15 = (const void **)v18[2];
        BOOL v17 = *v15 == v18;
        unint64_t v18 = v15;
      }
      while (!v17);
    }
    if (v15 != v9)
    {
      if (!sub_1000315FC((uint64_t)(a1 + 2), a5, v15 + 4)) {
        goto LABEL_28;
      }
      uint64_t v13 = *a4;
    }
    if (v13)
    {
      *a3 = v15;
      return v15;
    }
    else
    {
      *a3 = (const void **)a2;
    }
    return (const void **)a4;
  }
  if ((uint64_t *)*a1 == a2)
  {
    size_t v12 = (const void **)a2;
LABEL_16:
    if (*a2)
    {
      *a3 = v12;
      return v12 + 1;
    }
    else
    {
      *a3 = (const void **)a2;
      return (const void **)a2;
    }
  }
  long long v11 = (const void **)*a2;
  if (*a2)
  {
    do
    {
      size_t v12 = v11;
      long long v11 = (const void **)v11[1];
    }
    while (v11);
  }
  else
  {
    uint64_t v16 = a2;
    do
    {
      size_t v12 = (const void **)v16[2];
      BOOL v17 = *v12 == v16;
      uint64_t v16 = (uint64_t *)v12;
    }
    while (v17);
  }
  if (sub_1000315FC((uint64_t)(a1 + 2), v12 + 4, a5)) {
    goto LABEL_16;
  }
LABEL_28:

  return (const void **)sub_1000314CC((uint64_t)a1, a3, a5);
}

unsigned char *sub_1002B37B8@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  uint64_t v5 = a1 + 8;
  *a3 = 0;
  a3[2] = 0;
  a3[1] = 0;
  uint64_t v6 = a3 + 1;
  long long v7 = (char *)operator new(0x40uLL);
  *a3 = v7;
  *uint64_t v6 = v5;
  *((unsigned char *)a3 + 16) = 0;
  uint64_t result = v7 + 32;
  if (*(char *)(a2 + 23) < 0)
  {
    uint64_t result = sub_10003B098(result, *(void **)a2, *(void *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)uint64_t result = *(_OWORD *)a2;
    *((void *)v7 + 6) = *(void *)(a2 + 16);
  }
  *((_DWORD *)v7 + 14) = *(_DWORD *)(a2 + 24);
  *((unsigned char *)a3 + 16) = 1;
  return result;
}

void sub_1002B3850(_Unwind_Exception *a1)
{
  *uint64_t v1 = 0;
  sub_1002B386C(v3, v2);
  _Unwind_Resume(a1);
}

void sub_1002B386C(uint64_t a1, void **__p)
{
  if (*(unsigned char *)(a1 + 8))
  {
    if (*((char *)__p + 55) < 0) {
      operator delete(__p[4]);
    }
  }
  else if (!__p)
  {
    return;
  }

  operator delete(__p);
}

uint64_t sub_1002B38CC(uint64_t a1)
{
  sub_1002B3908(a1, *(void **)(a1 + 16));
  uint64_t v2 = *(void **)a1;
  *(void *)a1 = 0;
  if (v2) {
    operator delete(v2);
  }
  return a1;
}

void sub_1002B3908(uint64_t a1, void *a2)
{
  if (a2)
  {
    uint64_t v2 = a2;
    do
    {
      uint64_t v3 = (void *)*v2;
      sub_1002B5410(v2 + 3);
      operator delete(v2);
      uint64_t v2 = v3;
    }
    while (v3);
  }
}

void sub_1002B394C(id a1)
{
}

void sub_1002B3990()
{
}

void sub_1002B39B4(id a1)
{
}

void sub_1002B39F8()
{
}

void sub_1002B3A1C(id a1)
{
}

void sub_1002B3BAC()
{
}

void sub_1002B3BD0(id a1)
{
}

void sub_1002B3C14()
{
}

void sub_1002B3C38(id a1)
{
}

void sub_1002B3C7C()
{
}

uint64_t sub_1002B3CA0(uint64_t **a1, uint64_t a2)
{
  uint64_t v3 = (uint64_t *)sub_1002B3CF4((uint64_t)a1, a2);
  if (a1 + 1 == (uint64_t **)v3) {
    return 0;
  }
  uint64_t v4 = v3;
  sub_10004D3B8(a1, v3);
  operator delete(v4);
  return 1;
}

uint64_t sub_1002B3CF4(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a1 + 8);
  uint64_t v2 = a1 + 8;
  uint64_t v3 = v4;
  if (!v4) {
    return v2;
  }
  uint64_t v5 = v2;
  do
  {
    unsigned int v6 = bswap32(*(_DWORD *)(v3 + 25));
    unsigned int v7 = bswap32(*(_DWORD *)a2);
    if (v6 != v7) {
      goto LABEL_7;
    }
    unsigned int v6 = bswap32(*(unsigned __int16 *)(v3 + 29)) >> 16;
    unsigned int v8 = bswap32(*(unsigned __int16 *)(a2 + 4));
    if (v6 != HIWORD(v8))
    {
      unsigned int v7 = HIWORD(v8);
LABEL_7:
      if (v6 < v7) {
        int v9 = -1;
      }
      else {
        int v9 = 1;
      }
      goto LABEL_10;
    }
    int v9 = 0;
LABEL_10:
    BOOL v10 = v9 < 0;
    if (v9 >= 0) {
      long long v11 = (uint64_t *)v3;
    }
    else {
      long long v11 = (uint64_t *)(v3 + 8);
    }
    if (!v10) {
      uint64_t v5 = v3;
    }
    uint64_t v3 = *v11;
  }
  while (*v11);
  if (v5 == v2) {
    return v2;
  }
  unsigned int v12 = bswap32(*(_DWORD *)a2);
  unsigned int v13 = bswap32(*(_DWORD *)(v5 + 25));
  if (v12 != v13) {
    goto LABEL_20;
  }
  unsigned int v12 = bswap32(*(unsigned __int16 *)(a2 + 4)) >> 16;
  unsigned int v14 = bswap32(*(unsigned __int16 *)(v5 + 29));
  if (v12 != HIWORD(v14))
  {
    unsigned int v13 = HIWORD(v14);
LABEL_20:
    int v15 = v12 < v13 ? -1 : 1;
    if (v15 < 0) {
      return v2;
    }
  }
  return v5;
}

void sub_1002B3DCC(id a1)
{
}

void sub_1002B3E10()
{
}

void sub_1002B3E34(id a1)
{
}

void sub_1002B3E78()
{
}

void sub_1002B3E9C(id a1)
{
}

void sub_1002B3EE0()
{
}

void sub_1002B3F04(id a1)
{
}

void sub_1002B3F48()
{
}

void sub_1002B3F6C(id a1)
{
}

void sub_1002B3FB0()
{
}

void sub_1002B3FD4(id a1)
{
}

void sub_1002B4018()
{
}

void sub_1002B403C(id a1)
{
}

void sub_1002B4080()
{
}

char *sub_1002B40A4(uint64_t **a1, uint64_t a2, uint64_t a3, _DWORD **a4)
{
  uint64_t v11 = 0;
  unsigned int v6 = sub_1002B413C((uint64_t)a1, &v11, a2);
  unsigned int v7 = (char *)*v6;
  if (!*v6)
  {
    unsigned int v8 = (uint64_t **)v6;
    unsigned int v7 = (char *)operator new(0x20uLL);
    __int16 v9 = *((_WORD *)*a4 + 2);
    *(_DWORD *)(v7 + 25) = **a4;
    *(_WORD *)(v7 + 29) = v9;
    v7[31] = 0;
    sub_100036CA0(a1, v11, v8, (uint64_t *)v7);
  }
  return v7;
}

uint64_t *sub_1002B413C(uint64_t a1, void *a2, uint64_t a3)
{
  uint64_t v5 = *(uint64_t **)(a1 + 8);
  uint64_t result = (uint64_t *)(a1 + 8);
  uint64_t v4 = v5;
  if (v5)
  {
    while (1)
    {
      unsigned int v6 = v4;
      unsigned int v7 = bswap32(*(_DWORD *)a3);
      unsigned int v8 = bswap32(*(_DWORD *)((char *)v6 + 25));
      if (v7 != v8) {
        goto LABEL_8;
      }
      unsigned int v7 = bswap32(*(unsigned __int16 *)(a3 + 4)) >> 16;
      unsigned int v9 = bswap32(*(unsigned __int16 *)((char *)v6 + 29));
      if (v7 == HIWORD(v9))
      {
LABEL_12:
        unsigned int v11 = bswap32(*(_DWORD *)((char *)v6 + 25));
        unsigned int v12 = bswap32(*(_DWORD *)a3);
        if (v11 == v12)
        {
          unsigned int v11 = bswap32(*(unsigned __int16 *)((char *)v6 + 29)) >> 16;
          unsigned int v13 = bswap32(*(unsigned __int16 *)(a3 + 4));
          if (v11 == HIWORD(v13)) {
            goto LABEL_22;
          }
          unsigned int v12 = HIWORD(v13);
        }
        if (v11 < v12) {
          int v14 = -1;
        }
        else {
          int v14 = 1;
        }
        if ((v14 & 0x80000000) == 0) {
          goto LABEL_22;
        }
        uint64_t result = v6 + 1;
        uint64_t v4 = (uint64_t *)v6[1];
        if (!v4) {
          goto LABEL_22;
        }
      }
      else
      {
        unsigned int v8 = HIWORD(v9);
LABEL_8:
        if (v7 < v8) {
          int v10 = -1;
        }
        else {
          int v10 = 1;
        }
        if ((v10 & 0x80000000) == 0) {
          goto LABEL_12;
        }
        uint64_t v4 = (uint64_t *)*v6;
        uint64_t result = v6;
        if (!*v6) {
          goto LABEL_22;
        }
      }
    }
  }
  unsigned int v6 = result;
LABEL_22:
  *a2 = v6;
  return result;
}

uint64_t sub_1002B4214(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(uint64_t **)(a1 + 8);
  if (v2)
  {
    uint64_t result = 1;
    while (1)
    {
      unsigned int v4 = bswap32(*(_DWORD *)a2);
      unsigned int v5 = bswap32(*(_DWORD *)((char *)v2 + 25));
      if (v4 == v5)
      {
        unsigned int v4 = bswap32(*(unsigned __int16 *)(a2 + 4)) >> 16;
        unsigned int v6 = bswap32(*(unsigned __int16 *)((char *)v2 + 29));
        if (v4 == HIWORD(v6)) {
          break;
        }
        unsigned int v5 = HIWORD(v6);
      }
      int v7 = v4 < v5 ? -1 : 1;
      if ((v7 & 0x80000000) == 0) {
        break;
      }
LABEL_19:
      uint64_t v2 = (uint64_t *)*v2;
      if (!v2) {
        return 0;
      }
    }
    unsigned int v8 = bswap32(*(_DWORD *)((char *)v2 + 25));
    unsigned int v9 = bswap32(*(_DWORD *)a2);
    if (v8 == v9)
    {
      unsigned int v8 = bswap32(*(unsigned __int16 *)((char *)v2 + 29)) >> 16;
      unsigned int v10 = bswap32(*(unsigned __int16 *)(a2 + 4));
      if (v8 == HIWORD(v10))
      {
        int v11 = 0;
LABEL_17:
        if ((v11 & 0x80000000) == 0) {
          return result;
        }
        ++v2;
        goto LABEL_19;
      }
      unsigned int v9 = HIWORD(v10);
    }
    if (v8 < v9) {
      int v11 = -1;
    }
    else {
      int v11 = 1;
    }
    goto LABEL_17;
  }
  return 0;
}

char *sub_1002B42D4(char **a1, long long *a2)
{
  uint64_t v2 = *a1;
  unint64_t v3 = 0xAAAAAAAAAAAAAAABLL * ((a1[1] - *a1) >> 3);
  unint64_t v4 = v3 + 1;
  if (v3 + 1 > 0xAAAAAAAAAAAAAAALL) {
    abort();
  }
  unsigned int v8 = a1[2];
  uint64_t v7 = (uint64_t)(a1 + 2);
  unint64_t v9 = 0xAAAAAAAAAAAAAAABLL * ((v8 - v2) >> 3);
  if (2 * v9 > v4) {
    unint64_t v4 = 2 * v9;
  }
  if (v9 >= 0x555555555555555) {
    unint64_t v10 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v10 = v4;
  }
  uint64_t v25 = v7;
  if (v10) {
    int v11 = (char *)sub_1002B3440(v7, v10);
  }
  else {
    int v11 = 0;
  }
  unsigned int v12 = &v11[24 * v3];
  unint64_t v22 = v11;
  v23.i64[0] = (uint64_t)v12;
  v23.i64[1] = (uint64_t)v12;
  uint64_t v24 = &v11[24 * v10];
  if (*((char *)a2 + 23) < 0)
  {
    sub_10003B098(v12, *(void **)a2, *((void *)a2 + 1));
    int v14 = (char *)v23.i64[1];
    unsigned int v12 = (char *)v23.i64[0];
  }
  else
  {
    long long v13 = *a2;
    *((void *)v12 + 2) = *((void *)a2 + 2);
    *(_OWORD *)unsigned int v12 = v13;
    int v14 = &v11[24 * v3];
  }
  uint64_t v16 = *a1;
  unint64_t v15 = (unint64_t)a1[1];
  if ((char *)v15 == *a1)
  {
    int64x2_t v18 = vdupq_n_s64(v15);
  }
  else
  {
    do
    {
      long long v17 = *(_OWORD *)(v15 - 24);
      *((void *)v12 - 1) = *(void *)(v15 - 8);
      *(_OWORD *)(v12 - 24) = v17;
      v12 -= 24;
      *(void *)(v15 - 16) = 0;
      *(void *)(v15 - 8) = 0;
      *(void *)(v15 - 24) = 0;
      v15 -= 24;
    }
    while ((char *)v15 != v16);
    int64x2_t v18 = *(int64x2_t *)a1;
  }
  __int16 v19 = v14 + 24;
  *a1 = v12;
  a1[1] = v14 + 24;
  int64x2_t v23 = v18;
  long long v20 = a1[2];
  a1[2] = v24;
  uint64_t v24 = v20;
  unint64_t v22 = (char *)v18.i64[0];
  sub_1002B4440((uint64_t)&v22);
  return v19;
}

void sub_1002B442C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1002B4440((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1002B4440(uint64_t a1)
{
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void sub_1002B4478(uint64_t a1, void **a2)
{
  uint64_t v2 = *(void ***)(a1 + 16);
  if (v2 != a2)
  {
    do
    {
      unsigned int v5 = v2 - 3;
      *(void *)(a1 + 16) = v2 - 3;
      if (*((char *)v2 - 1) < 0)
      {
        operator delete(*v5);
        unsigned int v5 = *(void ***)(a1 + 16);
      }
      uint64_t v2 = v5;
    }
    while (v5 != a2);
  }
}

void *sub_1002B44D0(uint64_t a1, void *a2, uint64_t a3, void **a4)
{
  unint64_t v6 = 0x9DDFEA08EB382D69 * ((8 * *a2 + 8) ^ HIDWORD(*a2));
  unint64_t v7 = 0x9DDFEA08EB382D69 * (HIDWORD(*a2) ^ (v6 >> 47) ^ v6);
  unint64_t v8 = 0x9DDFEA08EB382D69 * (v7 ^ (v7 >> 47));
  unint64_t v9 = *(void *)(a1 + 8);
  if (v9)
  {
    uint8x8_t v10 = (uint8x8_t)vcnt_s8((int8x8_t)v9);
    v10.i16[0] = vaddlv_u8(v10);
    if (v10.u32[0] > 1uLL)
    {
      unint64_t v11 = 0x9DDFEA08EB382D69 * (v7 ^ (v7 >> 47));
      if (v8 >= v9) {
        unint64_t v11 = v8 % v9;
      }
    }
    else
    {
      unint64_t v11 = v8 & (v9 - 1);
    }
    unsigned int v12 = *(void **)(*(void *)a1 + 8 * v11);
    if (v12)
    {
      long long v13 = (void *)*v12;
      if (*v12)
      {
        do
        {
          unint64_t v14 = v13[1];
          if (v14 == v8)
          {
            if (v13[2] == *a2) {
              return v13;
            }
          }
          else
          {
            if (v10.u32[0] > 1uLL)
            {
              if (v14 >= v9) {
                v14 %= v9;
              }
            }
            else
            {
              v14 &= v9 - 1;
            }
            if (v14 != v11) {
              break;
            }
          }
          long long v13 = (void *)*v13;
        }
        while (v13);
      }
    }
  }
  else
  {
    unint64_t v11 = 0;
  }
  uint64_t v15 = a1 + 16;
  uint64_t v27 = 0;
  uint64_t v16 = (char *)operator new(0x48uLL);
  v26[0] = v16;
  v26[1] = a1 + 16;
  *(void *)uint64_t v16 = 0;
  *((void *)v16 + 1) = v8;
  *((void *)v16 + 2) = **a4;
  *(_OWORD *)(v16 + 24) = 0u;
  *(_OWORD *)(v16 + 40) = 0u;
  *(_OWORD *)(v16 + 56) = 0u;
  LOBYTE(v27) = 1;
  float v17 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v18 = *(float *)(a1 + 32);
  if (!v9 || (float)(v18 * (float)v9) < v17)
  {
    BOOL v19 = 1;
    if (v9 >= 3) {
      BOOL v19 = (v9 & (v9 - 1)) != 0;
    }
    unint64_t v20 = v19 | (2 * v9);
    unint64_t v21 = vcvtps_u32_f32(v17 / v18);
    if (v20 <= v21) {
      size_t v22 = v21;
    }
    else {
      size_t v22 = v20;
    }
    sub_1000A9204(a1, v22);
    unint64_t v9 = *(void *)(a1 + 8);
    if ((v9 & (v9 - 1)) != 0)
    {
      if (v8 >= v9) {
        unint64_t v11 = v8 % v9;
      }
      else {
        unint64_t v11 = v8;
      }
    }
    else
    {
      unint64_t v11 = (v9 - 1) & v8;
    }
  }
  int64x2_t v23 = *(void **)(*(void *)a1 + 8 * v11);
  if (v23)
  {
    *(void *)v26[0] = *v23;
    void *v23 = v26[0];
  }
  else
  {
    *(void *)v26[0] = *(void *)(a1 + 16);
    *(void *)(a1 + 16) = v26[0];
    *(void *)(*(void *)a1 + 8 * v11) = v15;
    if (*(void *)v26[0])
    {
      unint64_t v24 = *(void *)(*(void *)v26[0] + 8);
      if ((v9 & (v9 - 1)) != 0)
      {
        if (v24 >= v9) {
          v24 %= v9;
        }
      }
      else
      {
        v24 &= v9 - 1;
      }
      *(void *)(*(void *)a1 + 8 * v24) = v26[0];
    }
  }
  long long v13 = (void *)v26[0];
  v26[0] = 0;
  ++*(void *)(a1 + 24);
  sub_1002B477C((uint64_t)v26, 0);
  return v13;
}

void sub_1002B4764(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1002B477C((uint64_t)va, 0);
  _Unwind_Resume(a1);
}

void sub_1002B477C(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void **)a1;
  *(void *)a1 = a2;
  if (v2)
  {
    if (*(unsigned char *)(a1 + 16)) {
      sub_1002B5410(v2 + 3);
    }
    operator delete(v2);
  }
}

uint64_t sub_1002B47D4(uint64_t a1, void *a2)
{
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)a1 = 0u;
  unint64_t v4 = a2[4];
  uint64_t v5 = a2[1];
  uint64_t v6 = a2[2];
  unint64_t v7 = (char *)(v5 + 8 * (v4 >> 9));
  if (v6 == v5)
  {
    unint64_t v8 = 0;
    unint64_t v11 = 0;
    uint8x8_t v10 = (char *)(v5 + 8 * ((a2[5] + v4) >> 9));
  }
  else
  {
    unint64_t v8 = (uint64_t *)(*(void *)v7 + 8 * (v4 & 0x1FF));
    unint64_t v9 = a2[5] + v4;
    uint8x8_t v10 = (char *)(v5 + 8 * (v9 >> 9));
    unint64_t v11 = (uint64_t *)(*(void *)v10 + 8 * (v9 & 0x1FF));
  }
  sub_1002B4880((void *)a1, v7, v8, v10, v11);
  return a1;
}

void sub_1002B486C(_Unwind_Exception *a1)
{
  sub_1002B303C(v1);
  _Unwind_Resume(a1);
}

void *sub_1002B4880(void *a1, char *a2, uint64_t *a3, char *a4, uint64_t *a5)
{
  if (a5 == a3) {
    unint64_t v5 = 0;
  }
  else {
    unint64_t v5 = (((uint64_t)a5 - *(void *)a4) >> 3) + ((a4 - a2) << 6) - (((uint64_t)a3 - *(void *)a2) >> 3);
  }
  return sub_1002B48B4(a1, a2, a3, v5);
}

void *sub_1002B48B4(void *a1, void *a2, uint64_t *a3, unint64_t a4)
{
  uint64_t v8 = a1[1];
  uint64_t v9 = a1[2];
  if (v9 == v8) {
    uint64_t v10 = 0;
  }
  else {
    uint64_t v10 = ((v9 - v8) << 6) - 1;
  }
  unint64_t v11 = a1[5] + a1[4];
  unint64_t v12 = v10 - v11;
  if (a4 > v12)
  {
    sub_1002B49E8(a1, a4 - v12);
    uint64_t v8 = a1[1];
    uint64_t v9 = a1[2];
    unint64_t v11 = a1[4] + a1[5];
  }
  long long v13 = (void *)(v8 + 8 * (v11 >> 9));
  if (v9 == v8) {
    uint64_t v14 = 0;
  }
  else {
    uint64_t v14 = *v13 + 8 * (v11 & 0x1FF);
  }
  v23[0] = v8 + 8 * (v11 >> 9);
  v23[1] = v14;
  uint64_t result = sub_1002B4F40((uint64_t)v23, a4);
  if (v14 != v16)
  {
    uint64_t v17 = a1[5];
    do
    {
      if (v13 == result) {
        uint64_t v18 = v16;
      }
      else {
        uint64_t v18 = *v13 + 4096;
      }
      if (v14 == v18)
      {
        uint64_t v18 = v14;
      }
      else
      {
        BOOL v19 = (void *)v14;
        do
        {
          uint64_t v20 = *a3++;
          *v19++ = v20;
          if ((uint64_t *)((char *)a3 - *a2) == (uint64_t *)4096)
          {
            unint64_t v21 = (uint64_t *)a2[1];
            ++a2;
            a3 = v21;
          }
        }
        while (v19 != (void *)v18);
      }
      v17 += (v18 - v14) >> 3;
      if (v13 == result) {
        break;
      }
      uint64_t v22 = v13[1];
      ++v13;
      uint64_t v14 = v22;
    }
    while (v22 != v16);
    a1[5] = v17;
  }
  return result;
}

void sub_1002B49E8(void *a1, unint64_t a2)
{
  unint64_t v3 = (char *)a1[2];
  uint64_t v4 = (uint64_t)&v3[-a1[1]];
  if (v4) {
    unint64_t v5 = a2;
  }
  else {
    unint64_t v5 = a2 + 1;
  }
  if ((v5 & 0x1FF) != 0) {
    unint64_t v6 = (v5 >> 9) + 1;
  }
  else {
    unint64_t v6 = v5 >> 9;
  }
  unint64_t v7 = a1[4];
  if (v6 >= v7 >> 9) {
    unint64_t v8 = v7 >> 9;
  }
  else {
    unint64_t v8 = v6;
  }
  if (v6 <= v7 >> 9)
  {
    for (a1[4] = v7 - (v8 << 9); v8; --v8)
    {
      uint64_t v16 = (void *)a1[1];
      uint64_t v19 = *v16;
      uint64_t v17 = (char *)(v16 + 1);
      uint64_t v18 = v19;
      a1[1] = v17;
      if (v3 == (char *)a1[3])
      {
        uint64_t v20 = (uint64_t)&v17[-*a1];
        if ((unint64_t)v17 <= *a1)
        {
          if (v3 == (char *)*a1) {
            unint64_t v28 = 1;
          }
          else {
            unint64_t v28 = (uint64_t)&v3[-*a1] >> 2;
          }
          unsigned int v29 = (char *)sub_1000405F8((uint64_t)(a1 + 3), v28);
          unsigned int v31 = &v29[8 * (v28 >> 2)];
          unsigned int v32 = (uint64_t *)a1[1];
          unint64_t v3 = v31;
          uint64_t v33 = a1[2] - (void)v32;
          if (v33)
          {
            unint64_t v3 = &v31[v33 & 0xFFFFFFFFFFFFFFF8];
            uint64_t v34 = 8 * (v33 >> 3);
            BOOL v35 = &v29[8 * (v28 >> 2)];
            do
            {
              uint64_t v36 = *v32++;
              *(void *)BOOL v35 = v36;
              v35 += 8;
              v34 -= 8;
            }
            while (v34);
          }
          int v37 = (char *)*a1;
          *a1 = v29;
          a1[1] = v31;
          a1[2] = v3;
          a1[3] = &v29[8 * v30];
          if (v37)
          {
            operator delete(v37);
            unint64_t v3 = (char *)a1[2];
          }
        }
        else
        {
          uint64_t v21 = v20 >> 3;
          BOOL v22 = v20 >> 3 < -1;
          uint64_t v23 = (v20 >> 3) + 2;
          if (v22) {
            uint64_t v24 = v23;
          }
          else {
            uint64_t v24 = v21 + 1;
          }
          uint64_t v25 = &v17[-8 * (v24 >> 1)];
          int64_t v26 = v3 - v17;
          if (v3 != v17)
          {
            memmove(&v17[-8 * (v24 >> 1)], v17, v3 - v17);
            unint64_t v3 = (char *)a1[1];
          }
          uint64_t v27 = &v3[-8 * (v24 >> 1)];
          unint64_t v3 = &v25[v26];
          a1[1] = v27;
          a1[2] = &v25[v26];
        }
      }
      *(void *)unint64_t v3 = v18;
      unint64_t v3 = (char *)(a1[2] + 8);
      a1[2] = v3;
    }
  }
  else
  {
    unint64_t v9 = v6 - v8;
    uint64_t v10 = a1[3] - *a1;
    if (v6 - v8 <= (v10 >> 3) - (v4 >> 3))
    {
      if (v9)
      {
        while (a1[3] != a1[2])
        {
          __p[0] = operator new(0x1000uLL);
          sub_1002B4FA4(a1, __p);
          --v6;
          if (!--v9) {
            goto LABEL_75;
          }
        }
        for (uint64_t i = 0; i != v9; ++i)
        {
          __p[0] = operator new(0x1000uLL);
          sub_1002B50BC((uint64_t)a1, __p);
          if (a1[2] - a1[1] == 8) {
            uint64_t v64 = 511;
          }
          else {
            uint64_t v64 = 512;
          }
          uint64_t v65 = v64 + a1[4];
          a1[4] = v65;
        }
        unint64_t v8 = v6;
      }
      else
      {
LABEL_75:
        uint64_t v65 = a1[4];
      }
      a1[4] = v65 - (v8 << 9);
      if (v8)
      {
        uint64_t v66 = (char *)a1[2];
        do
        {
          id v67 = (void *)a1[1];
          uint64_t v70 = *v67;
          uint64_t v68 = (char *)(v67 + 1);
          uint64_t v69 = v70;
          a1[1] = v68;
          if (v66 == (char *)a1[3])
          {
            uint64_t v71 = (uint64_t)&v68[-*a1];
            if ((unint64_t)v68 <= *a1)
            {
              if (v66 == (char *)*a1) {
                unint64_t v78 = 1;
              }
              else {
                unint64_t v78 = (uint64_t)&v66[-*a1] >> 2;
              }
              uint64_t v79 = (char *)sub_1000405F8((uint64_t)(a1 + 3), v78);
              long long v81 = &v79[8 * (v78 >> 2)];
              int64x2_t v82 = (uint64_t *)a1[1];
              uint64_t v66 = v81;
              uint64_t v83 = a1[2] - (void)v82;
              if (v83)
              {
                uint64_t v66 = &v81[v83 & 0xFFFFFFFFFFFFFFF8];
                uint64_t v84 = 8 * (v83 >> 3);
                id v85 = &v79[8 * (v78 >> 2)];
                do
                {
                  uint64_t v86 = *v82++;
                  *(void *)id v85 = v86;
                  v85 += 8;
                  v84 -= 8;
                }
                while (v84);
              }
              __int16 v87 = (char *)*a1;
              *a1 = v79;
              a1[1] = v81;
              a1[2] = v66;
              a1[3] = &v79[8 * v80];
              if (v87)
              {
                operator delete(v87);
                uint64_t v66 = (char *)a1[2];
              }
            }
            else
            {
              uint64_t v72 = v71 >> 3;
              BOOL v22 = v71 >> 3 < -1;
              uint64_t v73 = (v71 >> 3) + 2;
              if (v22) {
                uint64_t v74 = v73;
              }
              else {
                uint64_t v74 = v72 + 1;
              }
              int v75 = &v68[-8 * (v74 >> 1)];
              int64_t v76 = v66 - v68;
              if (v66 != v68)
              {
                memmove(&v68[-8 * (v74 >> 1)], v68, v66 - v68);
                uint64_t v66 = (char *)a1[1];
              }
              long long v77 = &v66[-8 * (v74 >> 1)];
              uint64_t v66 = &v75[v76];
              a1[1] = v77;
              a1[2] = &v75[v76];
            }
          }
          *(void *)uint64_t v66 = v69;
          uint64_t v66 = (char *)(a1[2] + 8);
          a1[2] = v66;
          --v8;
        }
        while (v8);
      }
    }
    else
    {
      uint64_t v11 = v4 >> 3;
      unint64_t v12 = v10 >> 2;
      if (v12 <= v9 + v11) {
        unint64_t v13 = v9 + v11;
      }
      else {
        unint64_t v13 = v12;
      }
      unint64_t v14 = v11 - v8;
      unint64_t v91 = a1 + 3;
      if (v13) {
        uint64_t v15 = (char *)sub_1000405F8((uint64_t)(a1 + 3), v13);
      }
      else {
        uint64_t v15 = 0;
      }
      uint64_t v38 = v8 << 9;
      __p[0] = v15;
      __p[1] = &v15[8 * v14];
      *(void **)&long long v90 = __p[1];
      *((void *)&v90 + 1) = &v15[8 * v13];
      do
      {
        long long v88 = operator new(0x1000uLL);
        sub_1002B51DC(__p, &v88);
        --v9;
      }
      while (v9);
      if (v8)
      {
        uint64_t v39 = (void *)a1[1];
        __int16 v40 = (char *)v90;
        do
        {
          if (v40 == *((char **)&v90 + 1))
          {
            int64_t v41 = (char *)__p[1] - (char *)__p[0];
            if (__p[1] <= __p[0])
            {
              if (v40 == __p[0]) {
                unint64_t v48 = 1;
              }
              else {
                unint64_t v48 = (v40 - (char *)__p[0]) >> 2;
              }
              id v49 = (char *)sub_1000405F8((uint64_t)v91, v48);
              char v51 = (uint64_t *)__p[1];
              __int16 v40 = &v49[8 * (v48 >> 2)];
              uint64_t v52 = v90 - (unint64_t)__p[1];
              if ((void *)v90 != __p[1])
              {
                __int16 v40 = &v49[8 * (v48 >> 2) + (v52 & 0xFFFFFFFFFFFFFFF8)];
                uint64_t v53 = 8 * (v52 >> 3);
                uint64_t v54 = &v49[8 * (v48 >> 2)];
                do
                {
                  uint64_t v55 = *v51++;
                  *(void *)uint64_t v54 = v55;
                  v54 += 8;
                  v53 -= 8;
                }
                while (v53);
              }
              long long v56 = __p[0];
              __p[0] = v49;
              __p[1] = &v49[8 * (v48 >> 2)];
              *(void *)&long long v90 = v40;
              *((void *)&v90 + 1) = &v49[8 * v50];
              if (v56)
              {
                operator delete(v56);
                __int16 v40 = (char *)v90;
              }
            }
            else
            {
              uint64_t v42 = v41 >> 3;
              BOOL v22 = v41 >> 3 < -1;
              uint64_t v43 = (v41 >> 3) + 2;
              if (v22) {
                uint64_t v44 = v43;
              }
              else {
                uint64_t v44 = v42 + 1;
              }
              __int16 v45 = (char *)__p[1] - 8 * (v44 >> 1);
              int64_t v46 = v40 - (char *)__p[1];
              if (v40 != __p[1])
              {
                memmove((char *)__p[1] - 8 * (v44 >> 1), __p[1], v40 - (char *)__p[1]);
                __int16 v40 = (char *)__p[1];
              }
              int64_t v47 = &v40[-8 * (v44 >> 1)];
              __int16 v40 = &v45[v46];
              __p[1] = v47;
              *(void *)&long long v90 = &v45[v46];
            }
          }
          *(void *)__int16 v40 = *v39;
          __int16 v40 = (char *)(v90 + 8);
          *(void *)&long long v90 = v90 + 8;
          uint64_t v39 = (void *)(a1[1] + 8);
          a1[1] = v39;
          --v8;
        }
        while (v8);
      }
      uint64_t v57 = (void *)a1[2];
      uint64_t v58 = -7 - (void)v57;
      while (v57 != (void *)a1[1])
      {
        --v57;
        v58 += 8;
        sub_1002B52F4((uint64_t)__p, v57);
      }
      int v59 = (char *)*a1;
      long long v60 = *(_OWORD *)__p;
      long long v61 = v90;
      __p[0] = *(void **)a1;
      __p[1] = v57;
      long long v62 = *((_OWORD *)a1 + 1);
      *(_OWORD *)a1 = v60;
      *((_OWORD *)a1 + 1) = v61;
      long long v90 = v62;
      a1[4] -= v38;
      if (v57 != (void *)v62) {
        *(void *)&long long v90 = v62 + (-(v62 + v58) & 0xFFFFFFFFFFFFFFF8);
      }
      if (v59) {
        operator delete(v59);
      }
    }
  }
}

void sub_1002B4F00(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void *sub_1002B4F40(uint64_t a1, uint64_t a2)
{
  uint64_t result = *(void **)a1;
  if (a2)
  {
    uint64_t v4 = a2 + ((uint64_t)(*(void *)(a1 + 8) - *result) >> 3);
    if (v4 < 1) {
      result -= (unint64_t)(511 - v4) >> 9;
    }
    else {
      result += (unint64_t)v4 >> 9;
    }
  }
  return result;
}

void sub_1002B4FA4(void *a1, void *a2)
{
  unint64_t v5 = (char *)a1[3];
  uint64_t v4 = (uint64_t)(a1 + 3);
  unint64_t v6 = *(char **)(v4 - 8);
  if (v6 == v5)
  {
    unint64_t v7 = (char *)a1[1];
    uint64_t v8 = (uint64_t)&v7[-*a1];
    if ((unint64_t)v7 <= *a1)
    {
      if (v6 == (char *)*a1) {
        unint64_t v18 = 1;
      }
      else {
        unint64_t v18 = (uint64_t)&v6[-*a1] >> 2;
      }
      uint64_t v19 = (char *)sub_1000405F8(v4, v18);
      uint64_t v21 = &v19[8 * (v18 >> 2)];
      BOOL v22 = (uint64_t *)a1[1];
      unint64_t v6 = v21;
      uint64_t v23 = a1[2] - (void)v22;
      if (v23)
      {
        unint64_t v6 = &v21[v23 & 0xFFFFFFFFFFFFFFF8];
        uint64_t v24 = 8 * (v23 >> 3);
        uint64_t v25 = &v19[8 * (v18 >> 2)];
        do
        {
          uint64_t v26 = *v22++;
          *(void *)uint64_t v25 = v26;
          v25 += 8;
          v24 -= 8;
        }
        while (v24);
      }
      uint64_t v27 = (char *)*a1;
      *a1 = v19;
      a1[1] = v21;
      a1[2] = v6;
      a1[3] = &v19[8 * v20];
      if (v27)
      {
        operator delete(v27);
        unint64_t v6 = (char *)a1[2];
      }
    }
    else
    {
      uint64_t v9 = v8 >> 3;
      BOOL v10 = v8 >> 3 < -1;
      uint64_t v11 = (v8 >> 3) + 2;
      if (v10) {
        uint64_t v12 = v11;
      }
      else {
        uint64_t v12 = v9 + 1;
      }
      uint64_t v13 = -(v12 >> 1);
      uint64_t v14 = v12 >> 1;
      uint64_t v15 = &v7[-8 * v14];
      int64_t v16 = v6 - v7;
      if (v6 != v7)
      {
        memmove(&v7[-8 * v14], v7, v6 - v7);
        unint64_t v6 = (char *)a1[1];
      }
      uint64_t v17 = &v6[8 * v13];
      unint64_t v6 = &v15[v16];
      a1[1] = v17;
      a1[2] = &v15[v16];
    }
  }
  *(void *)unint64_t v6 = *a2;
  a1[2] += 8;
}

void sub_1002B50BC(uint64_t a1, void *a2)
{
  uint64_t v4 = *(char **)(a1 + 8);
  if (v4 == *(char **)a1)
  {
    uint64_t v6 = a1 + 24;
    unint64_t v7 = *(unsigned char **)(a1 + 24);
    uint64_t v8 = *(unsigned char **)(a1 + 16);
    if (v8 >= v7)
    {
      if (v7 == v4) {
        unint64_t v12 = 1;
      }
      else {
        unint64_t v12 = (v7 - v4) >> 2;
      }
      uint64_t v13 = 2 * v12;
      uint64_t v14 = (char *)sub_1000405F8(v6, v12);
      unint64_t v5 = &v14[(v13 + 6) & 0xFFFFFFFFFFFFFFF8];
      int64_t v16 = *(uint64_t **)(a1 + 8);
      uint64_t v17 = v5;
      uint64_t v18 = *(void *)(a1 + 16) - (void)v16;
      if (v18)
      {
        uint64_t v17 = &v5[v18 & 0xFFFFFFFFFFFFFFF8];
        uint64_t v19 = 8 * (v18 >> 3);
        uint64_t v20 = v5;
        do
        {
          uint64_t v21 = *v16++;
          *(void *)uint64_t v20 = v21;
          v20 += 8;
          v19 -= 8;
        }
        while (v19);
      }
      BOOL v22 = *(char **)a1;
      *(void *)a1 = v14;
      *(void *)(a1 + 8) = v5;
      *(void *)(a1 + 16) = v17;
      *(void *)(a1 + 24) = &v14[8 * v15];
      if (v22)
      {
        operator delete(v22);
        unint64_t v5 = *(char **)(a1 + 8);
      }
    }
    else
    {
      uint64_t v9 = (v7 - v8) >> 3;
      if (v9 >= -1) {
        uint64_t v10 = v9 + 1;
      }
      else {
        uint64_t v10 = v9 + 2;
      }
      uint64_t v11 = v10 >> 1;
      unint64_t v5 = &v4[8 * (v10 >> 1)];
      if (v8 != v4)
      {
        memmove(&v4[8 * (v10 >> 1)], v4, v8 - v4);
        uint64_t v4 = *(char **)(a1 + 16);
      }
      *(void *)(a1 + 8) = v5;
      *(void *)(a1 + 16) = &v4[8 * v11];
    }
  }
  else
  {
    unint64_t v5 = *(char **)(a1 + 8);
  }
  *((void *)v5 - 1) = *a2;
  *(void *)(a1 + 8) -= 8;
}

void sub_1002B51DC(void *a1, void *a2)
{
  uint64_t v4 = (char *)a1[2];
  if (v4 == (char *)a1[3])
  {
    unint64_t v5 = (char *)a1[1];
    uint64_t v6 = (uint64_t)&v5[-*a1];
    if ((unint64_t)v5 <= *a1)
    {
      if (v4 == (char *)*a1) {
        unint64_t v16 = 1;
      }
      else {
        unint64_t v16 = (uint64_t)&v4[-*a1] >> 2;
      }
      uint64_t v17 = (char *)sub_1000405F8(a1[4], v16);
      uint64_t v19 = &v17[8 * (v16 >> 2)];
      uint64_t v20 = (uint64_t *)a1[1];
      uint64_t v4 = v19;
      uint64_t v21 = a1[2] - (void)v20;
      if (v21)
      {
        uint64_t v4 = &v19[v21 & 0xFFFFFFFFFFFFFFF8];
        uint64_t v22 = 8 * (v21 >> 3);
        uint64_t v23 = &v17[8 * (v16 >> 2)];
        do
        {
          uint64_t v24 = *v20++;
          *(void *)uint64_t v23 = v24;
          v23 += 8;
          v22 -= 8;
        }
        while (v22);
      }
      uint64_t v25 = (char *)*a1;
      *a1 = v17;
      a1[1] = v19;
      a1[2] = v4;
      a1[3] = &v17[8 * v18];
      if (v25)
      {
        operator delete(v25);
        uint64_t v4 = (char *)a1[2];
      }
    }
    else
    {
      uint64_t v7 = v6 >> 3;
      BOOL v8 = v6 >> 3 < -1;
      uint64_t v9 = (v6 >> 3) + 2;
      if (v8) {
        uint64_t v10 = v9;
      }
      else {
        uint64_t v10 = v7 + 1;
      }
      uint64_t v11 = -(v10 >> 1);
      uint64_t v12 = v10 >> 1;
      uint64_t v13 = &v5[-8 * v12];
      int64_t v14 = v4 - v5;
      if (v4 != v5)
      {
        memmove(&v5[-8 * v12], v5, v4 - v5);
        uint64_t v4 = (char *)a1[1];
      }
      uint64_t v15 = &v4[8 * v11];
      uint64_t v4 = &v13[v14];
      a1[1] = v15;
      a1[2] = &v13[v14];
    }
  }
  *(void *)uint64_t v4 = *a2;
  a1[2] += 8;
}

void sub_1002B52F4(uint64_t a1, void *a2)
{
  uint64_t v4 = *(char **)(a1 + 8);
  if (v4 == *(char **)a1)
  {
    uint64_t v6 = *(unsigned char **)(a1 + 16);
    uint64_t v7 = *(unsigned char **)(a1 + 24);
    if (v6 >= v7)
    {
      if (v7 == v4) {
        unint64_t v11 = 1;
      }
      else {
        unint64_t v11 = (v7 - v4) >> 2;
      }
      uint64_t v12 = 2 * v11;
      uint64_t v13 = (char *)sub_1000405F8(*(void *)(a1 + 32), v11);
      unint64_t v5 = &v13[(v12 + 6) & 0xFFFFFFFFFFFFFFF8];
      uint64_t v15 = *(uint64_t **)(a1 + 8);
      unint64_t v16 = v5;
      uint64_t v17 = *(void *)(a1 + 16) - (void)v15;
      if (v17)
      {
        unint64_t v16 = &v5[v17 & 0xFFFFFFFFFFFFFFF8];
        uint64_t v18 = 8 * (v17 >> 3);
        uint64_t v19 = v5;
        do
        {
          uint64_t v20 = *v15++;
          *(void *)uint64_t v19 = v20;
          v19 += 8;
          v18 -= 8;
        }
        while (v18);
      }
      uint64_t v21 = *(char **)a1;
      *(void *)a1 = v13;
      *(void *)(a1 + 8) = v5;
      *(void *)(a1 + 16) = v16;
      *(void *)(a1 + 24) = &v13[8 * v14];
      if (v21)
      {
        operator delete(v21);
        unint64_t v5 = *(char **)(a1 + 8);
      }
    }
    else
    {
      uint64_t v8 = (v7 - v6) >> 3;
      if (v8 >= -1) {
        uint64_t v9 = v8 + 1;
      }
      else {
        uint64_t v9 = v8 + 2;
      }
      uint64_t v10 = v9 >> 1;
      unint64_t v5 = &v4[8 * (v9 >> 1)];
      if (v6 != v4)
      {
        memmove(&v4[8 * (v9 >> 1)], v4, v6 - v4);
        uint64_t v4 = *(char **)(a1 + 16);
      }
      *(void *)(a1 + 8) = v5;
      *(void *)(a1 + 16) = &v4[8 * v10];
    }
  }
  else
  {
    unint64_t v5 = *(char **)(a1 + 8);
  }
  *((void *)v5 - 1) = *a2;
  *(void *)(a1 + 8) -= 8;
}

uint64_t sub_1002B5410(void *a1)
{
  uint64_t v2 = (void **)a1[1];
  unint64_t v3 = (void **)a1[2];
  a1[5] = 0;
  unint64_t v4 = (char *)v3 - (char *)v2;
  if ((unint64_t)((char *)v3 - (char *)v2) >= 0x11)
  {
    do
    {
      operator delete(*v2);
      unint64_t v3 = (void **)a1[2];
      uint64_t v2 = (void **)(a1[1] + 8);
      a1[1] = v2;
      unint64_t v4 = (char *)v3 - (char *)v2;
    }
    while ((unint64_t)((char *)v3 - (char *)v2) > 0x10);
  }
  unint64_t v5 = v4 >> 3;
  if (v5 == 1)
  {
    uint64_t v6 = 256;
  }
  else
  {
    if (v5 != 2) {
      goto LABEL_9;
    }
    uint64_t v6 = 512;
  }
  a1[4] = v6;
LABEL_9:
  while (v2 != v3)
  {
    uint64_t v7 = *v2++;
    operator delete(v7);
  }

  return sub_1002B303C((uint64_t)a1);
}

uint64_t sub_1002B54B8(void *a1, void *a2)
{
  uint64_t result = (uint64_t)sub_1002B5508(a1, a2);
  if (result)
  {
    sub_1002B55F4(a1, (void *)result, (uint64_t)v4);
    sub_1002B477C((uint64_t)v4, 0);
    return 1;
  }
  return result;
}

void *sub_1002B5508(void *a1, void *a2)
{
  int8x8_t v2 = (int8x8_t)a1[1];
  if (!*(void *)&v2) {
    return 0;
  }
  unint64_t v3 = 0x9DDFEA08EB382D69 * ((8 * *a2 + 8) ^ HIDWORD(*a2));
  unint64_t v4 = 0x9DDFEA08EB382D69 * (HIDWORD(*a2) ^ (v3 >> 47) ^ v3);
  unint64_t v5 = 0x9DDFEA08EB382D69 * (v4 ^ (v4 >> 47));
  uint8x8_t v6 = (uint8x8_t)vcnt_s8(v2);
  v6.i16[0] = vaddlv_u8(v6);
  if (v6.u32[0] > 1uLL)
  {
    unint64_t v7 = v5;
    if (v5 >= *(void *)&v2) {
      unint64_t v7 = v5 % *(void *)&v2;
    }
  }
  else
  {
    unint64_t v7 = v5 & (*(void *)&v2 - 1);
  }
  uint64_t v8 = *(void **)(*a1 + 8 * v7);
  if (!v8) {
    return 0;
  }
  uint64_t result = (void *)*v8;
  if (*v8)
  {
    do
    {
      unint64_t v10 = result[1];
      if (v10 == v5)
      {
        if (result[2] == *a2) {
          return result;
        }
      }
      else
      {
        if (v6.u32[0] > 1uLL)
        {
          if (v10 >= *(void *)&v2) {
            v10 %= *(void *)&v2;
          }
        }
        else
        {
          v10 &= *(void *)&v2 - 1;
        }
        if (v10 != v7) {
          return 0;
        }
      }
      uint64_t result = (void *)*result;
    }
    while (result);
  }
  return result;
}

void *sub_1002B55F4@<X0>(void *result@<X0>, void *a2@<X1>, uint64_t a3@<X8>)
{
  int8x8_t v3 = (int8x8_t)result[1];
  unint64_t v4 = a2[1];
  uint8x8_t v5 = (uint8x8_t)vcnt_s8(v3);
  v5.i16[0] = vaddlv_u8(v5);
  if (v5.u32[0] > 1uLL)
  {
    if (v4 >= *(void *)&v3) {
      v4 %= *(void *)&v3;
    }
  }
  else
  {
    v4 &= *(void *)&v3 - 1;
  }
  uint8x8_t v6 = *(void **)(*result + 8 * v4);
  do
  {
    unint64_t v7 = v6;
    uint8x8_t v6 = (void *)*v6;
  }
  while (v6 != a2);
  if (v7 == result + 2) {
    goto LABEL_18;
  }
  unint64_t v8 = v7[1];
  if (v5.u32[0] > 1uLL)
  {
    if (v8 >= *(void *)&v3) {
      v8 %= *(void *)&v3;
    }
  }
  else
  {
    v8 &= *(void *)&v3 - 1;
  }
  if (v8 != v4)
  {
LABEL_18:
    if (!*a2) {
      goto LABEL_19;
    }
    unint64_t v9 = *(void *)(*a2 + 8);
    if (v5.u32[0] > 1uLL)
    {
      if (v9 >= *(void *)&v3) {
        v9 %= *(void *)&v3;
      }
    }
    else
    {
      v9 &= *(void *)&v3 - 1;
    }
    if (v9 != v4) {
LABEL_19:
    }
      *(void *)(*result + 8 * v4) = 0;
  }
  uint64_t v10 = *a2;
  if (*a2)
  {
    unint64_t v11 = *(void *)(v10 + 8);
    if (v5.u32[0] > 1uLL)
    {
      if (v11 >= *(void *)&v3) {
        v11 %= *(void *)&v3;
      }
    }
    else
    {
      v11 &= *(void *)&v3 - 1;
    }
    if (v11 != v4)
    {
      *(void *)(*result + 8 * v11) = v7;
      uint64_t v10 = *a2;
    }
  }
  *unint64_t v7 = v10;
  *a2 = 0;
  --result[3];
  *(void *)a3 = a2;
  *(void *)(a3 + 8) = result + 2;
  *(unsigned char *)(a3 + 16) = 1;
  return result;
}

void sub_1002B5728(id a1)
{
}

void sub_1002B576C()
{
}

void sub_1002B5790(id a1)
{
}

void sub_1002B57D4()
{
}

void sub_1002B57F8(id a1)
{
}

void sub_1002B583C()
{
}

void sub_1002B5860(id a1)
{
}

void sub_1002B58A4()
{
}

void sub_1002B58C8(id a1)
{
}

void sub_1002B590C()
{
}

void sub_1002B5930(id a1)
{
}

void sub_1002B5974()
{
}

void sub_1002B5998(id a1)
{
}

void sub_1002B59DC()
{
}

void sub_1002B5A00(id a1)
{
}

void sub_1002B5A44()
{
}

uint64_t **sub_1002B5A68(uint64_t **a1, unsigned __int8 *a2, uint64_t a3, unsigned char **a4)
{
  unint64_t v7 = a1 + 1;
  uint8x8_t v6 = a1[1];
  if (v6)
  {
    unsigned int v8 = *a2;
    while (1)
    {
      while (1)
      {
        unint64_t v9 = (uint64_t **)v6;
        unsigned int v10 = *((unsigned __int8 *)v6 + 32);
        if (v8 >= v10) {
          break;
        }
        uint8x8_t v6 = *v9;
        unint64_t v7 = v9;
        if (!*v9) {
          goto LABEL_10;
        }
      }
      if (v10 >= v8) {
        break;
      }
      uint8x8_t v6 = v9[1];
      if (!v6)
      {
        unint64_t v7 = v9 + 1;
        goto LABEL_10;
      }
    }
  }
  else
  {
    unint64_t v9 = a1 + 1;
LABEL_10:
    unint64_t v11 = operator new(0x30uLL);
    v11[32] = **a4;
    *((void *)v11 + 5) = 0;
    sub_100036CA0(a1, (uint64_t)v9, v7, (uint64_t *)v11);
    return (uint64_t **)v11;
  }
  return v9;
}

void *sub_1002B5B2C(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x2AAAAAAAAAAAAAABLL) {
    sub_1000616DC();
  }
  return operator new(6 * a2);
}

void sub_1002B5B74(void *a1, _DWORD *a2)
{
  uint64_t v4 = a1[2];
  uint64_t v5 = a1[1];
  if (v4 == v5) {
    uint64_t v6 = 0;
  }
  else {
    uint64_t v6 = ((v4 - v5) << 7) - 1;
  }
  uint64_t v7 = a1[5];
  unint64_t v8 = v7 + a1[4];
  if (v6 == v8)
  {
    sub_1002B5BFC(a1);
    uint64_t v5 = a1[1];
    uint64_t v7 = a1[5];
    unint64_t v8 = a1[4] + v7;
  }
  *(_DWORD *)(*(void *)(v5 + ((v8 >> 7) & 0x1FFFFFFFFFFFFF8)) + 4 * (v8 & 0x3FF)) = *a2;
  a1[5] = v7 + 1;
}

void sub_1002B5BFC(void *a1)
{
  unint64_t v2 = a1[4];
  BOOL v3 = v2 >= 0x400;
  unint64_t v4 = v2 - 1024;
  if (v3)
  {
    uint64_t v5 = (uint64_t)(a1 + 3);
    uint64_t v6 = (char *)a1[3];
    a1[4] = v4;
    uint64_t v7 = (void *)a1[1];
    unint64_t v8 = (char *)a1[2];
    uint64_t v11 = *v7;
    unint64_t v9 = (char *)(v7 + 1);
    uint64_t v10 = v11;
    a1[1] = v9;
    if (v8 != v6)
    {
LABEL_33:
      *(void *)unint64_t v8 = v10;
      a1[2] += 8;
      return;
    }
    uint64_t v12 = (uint64_t)&v9[-*a1];
    if ((unint64_t)v9 <= *a1)
    {
      if (v8 == (char *)*a1) {
        unint64_t v33 = 1;
      }
      else {
        unint64_t v33 = (uint64_t)&v8[-*a1] >> 2;
      }
      uint64_t v34 = (char *)sub_1000405F8(v5, v33);
      BOOL v35 = &v34[8 * (v33 >> 2)];
      int v37 = &v34[8 * v36];
      uint64_t v38 = (uint64_t *)a1[1];
      unint64_t v8 = v35;
      uint64_t v39 = a1[2] - (void)v38;
      if (v39)
      {
        unint64_t v8 = &v35[v39 & 0xFFFFFFFFFFFFFFF8];
        uint64_t v40 = 8 * (v39 >> 3);
        int64_t v41 = &v34[8 * (v33 >> 2)];
        do
        {
          uint64_t v42 = *v38++;
          *(void *)int64_t v41 = v42;
          v41 += 8;
          v40 -= 8;
        }
        while (v40);
      }
      goto LABEL_30;
    }
LABEL_5:
    uint64_t v13 = v12 >> 3;
    BOOL v14 = v12 >> 3 < -1;
    uint64_t v15 = (v12 >> 3) + 2;
    if (v14) {
      uint64_t v16 = v15;
    }
    else {
      uint64_t v16 = v13 + 1;
    }
    uint64_t v17 = -(v16 >> 1);
    uint64_t v18 = v16 >> 1;
    uint64_t v19 = &v9[-8 * v18];
    int64_t v20 = v8 - v9;
    if (v8 != v9)
    {
      memmove(&v9[-8 * v18], v9, v8 - v9);
      unint64_t v9 = (char *)a1[1];
    }
    unint64_t v8 = &v19[v20];
    a1[1] = &v9[8 * v17];
    a1[2] = &v19[v20];
    goto LABEL_33;
  }
  uint64_t v21 = a1[2];
  unint64_t v22 = (v21 - a1[1]) >> 3;
  uint64_t v23 = a1[3];
  uint64_t v24 = v23 - *a1;
  if (v22 < v24 >> 3)
  {
    if (v23 != v21)
    {
      *(void *)&long long v54 = operator new(0x1000uLL);
      sub_1002B4FA4(a1, &v54);
      return;
    }
    *(void *)&long long v54 = operator new(0x1000uLL);
    sub_1002B50BC((uint64_t)a1, &v54);
    uint64_t v44 = (void *)a1[1];
    unint64_t v8 = (char *)a1[2];
    uint64_t v45 = *v44;
    unint64_t v9 = (char *)(v44 + 1);
    uint64_t v10 = v45;
    a1[1] = v9;
    if (v8 != (char *)a1[3]) {
      goto LABEL_33;
    }
    uint64_t v12 = (uint64_t)&v9[-*a1];
    if ((unint64_t)v9 <= *a1)
    {
      if (v8 == (char *)*a1) {
        unint64_t v46 = 1;
      }
      else {
        unint64_t v46 = (uint64_t)&v8[-*a1] >> 2;
      }
      uint64_t v34 = (char *)sub_1000405F8((uint64_t)(a1 + 3), v46);
      BOOL v35 = &v34[8 * (v46 >> 2)];
      int v37 = &v34[8 * v47];
      unint64_t v48 = (uint64_t *)a1[1];
      unint64_t v8 = v35;
      uint64_t v49 = a1[2] - (void)v48;
      if (v49)
      {
        unint64_t v8 = &v35[v49 & 0xFFFFFFFFFFFFFFF8];
        uint64_t v50 = 8 * (v49 >> 3);
        char v51 = &v34[8 * (v46 >> 2)];
        do
        {
          uint64_t v52 = *v48++;
          *(void *)char v51 = v52;
          v51 += 8;
          v50 -= 8;
        }
        while (v50);
      }
LABEL_30:
      uint64_t v43 = (char *)*a1;
      *a1 = v34;
      a1[1] = v35;
      a1[2] = v8;
      a1[3] = v37;
      if (v43)
      {
        operator delete(v43);
        unint64_t v8 = (char *)a1[2];
      }
      goto LABEL_33;
    }
    goto LABEL_5;
  }
  if (v23 == *a1) {
    unint64_t v25 = 1;
  }
  else {
    unint64_t v25 = v24 >> 2;
  }
  long long v56 = a1 + 3;
  *(void *)&long long v54 = sub_1000405F8((uint64_t)(a1 + 3), v25);
  *((void *)&v54 + 1) = v54 + 8 * v22;
  *(void *)&long long v55 = *((void *)&v54 + 1);
  *((void *)&v55 + 1) = v54 + 8 * v26;
  uint64_t v53 = operator new(0x1000uLL);
  sub_1002B51DC(&v54, &v53);
  uint64_t v27 = (void *)a1[2];
  uint64_t v28 = -7 - (void)v27;
  while (v27 != (void *)a1[1])
  {
    --v27;
    v28 += 8;
    sub_1002B52F4((uint64_t)&v54, v27);
  }
  unsigned int v29 = (char *)*a1;
  long long v30 = v54;
  long long v31 = v55;
  *(void *)&long long v54 = *a1;
  *((void *)&v54 + 1) = v27;
  long long v32 = *((_OWORD *)a1 + 1);
  *(_OWORD *)a1 = v30;
  *((_OWORD *)a1 + 1) = v31;
  long long v55 = v32;
  if (v27 != (void *)v32) {
    *(void *)&long long v55 = v32 + (-(v32 + v28) & 0xFFFFFFFFFFFFFFF8);
  }
  if (v29) {
    operator delete(v29);
  }
}

void sub_1002B5EC8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13)
{
  operator delete(v13);
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_1002B5F14(uint64_t a1, int a2)
{
  unint64_t v2 = *(void *)(a1 + 32);
  if (v2 < 0x400) {
    a2 = 1;
  }
  if (v2 < 0x800) {
    int v4 = a2;
  }
  else {
    int v4 = 0;
  }
  if ((v4 & 1) == 0)
  {
    operator delete(**(void ***)(a1 + 8));
    *(void *)(a1 + 8) += 8;
    *(void *)(a1 + 32) -= 1024;
  }
  return v4 ^ 1u;
}

char *sub_1002B5F74(char *result, char *__src, uint64_t a3, unint64_t a4)
{
  uint64_t v7 = result;
  uint64_t v8 = *((void *)result + 2);
  unint64_t v9 = *(char **)result;
  if (a4 > (v8 - *(void *)result) >> 3)
  {
    if (v9)
    {
      *((void *)result + 1) = v9;
      operator delete(v9);
      uint64_t v8 = 0;
      *uint64_t v7 = 0;
      v7[1] = 0;
      void v7[2] = 0;
    }
    if (a4 >> 61) {
      abort();
    }
    uint64_t v10 = v8 >> 2;
    if (v8 >> 2 <= a4) {
      uint64_t v10 = a4;
    }
    if ((unint64_t)v8 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v11 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v11 = v10;
    }
    uint64_t result = sub_1000405B8(v7, v11);
    uint64_t v13 = (char *)v7[1];
    uint64_t v12 = (void **)(v7 + 1);
    unint64_t v9 = v13;
LABEL_16:
    size_t v17 = a3 - (void)__src;
    if (v17)
    {
      uint64_t v18 = v9;
      uint64_t v19 = __src;
      goto LABEL_18;
    }
    goto LABEL_19;
  }
  uint64_t v12 = (void **)(result + 8);
  BOOL v14 = (unsigned char *)*((void *)result + 1);
  unint64_t v15 = (v14 - v9) >> 3;
  if (v15 >= a4) {
    goto LABEL_16;
  }
  uint64_t v16 = &__src[8 * v15];
  if (v14 != v9)
  {
    uint64_t result = (char *)memmove(*(void **)result, __src, v14 - v9);
    unint64_t v9 = (char *)*v12;
  }
  size_t v17 = a3 - (void)v16;
  if (v17)
  {
    uint64_t v18 = v9;
    uint64_t v19 = v16;
LABEL_18:
    uint64_t result = (char *)memmove(v18, v19, v17);
  }
LABEL_19:
  *uint64_t v12 = &v9[v17];
  return result;
}

uint64_t sub_1002B607C(uint64_t *a1, uint64_t a2)
{
  uint64_t v2 = *a1;
  uint64_t v3 = (a1[1] - *a1) >> 5;
  unint64_t v4 = v3 + 1;
  if ((unint64_t)(v3 + 1) >> 59) {
    abort();
  }
  uint64_t v8 = a1[2];
  uint64_t v7 = (uint64_t)(a1 + 2);
  uint64_t v9 = v8 - v2;
  if (v9 >> 4 > v4) {
    unint64_t v4 = v9 >> 4;
  }
  if ((unint64_t)v9 >= 0x7FFFFFFFFFFFFFE0) {
    unint64_t v10 = 0x7FFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v10 = v4;
  }
  uint64_t v20 = v7;
  unint64_t v11 = (char *)sub_1002B6234(v7, v10);
  uint64_t v12 = &v11[32 * v3];
  std::string __p = v11;
  size_t v17 = v12;
  uint64_t v19 = &v11[32 * v13];
  *(void *)uint64_t v12 = *(void *)a2;
  *((void *)v12 + 1) = *(void *)(a2 + 8);
  *((_DWORD *)v12 + 4) = *(_DWORD *)(a2 + 16);
  *((void *)v12 + 3) = *(void *)(a2 + 24);
  uint64_t v18 = v12 + 32;
  sub_1002B61A8(a1, &__p);
  uint64_t v14 = a1[1];
  if (v18 != v17) {
    v18 += (v17 - v18 + 31) & 0xFFFFFFFFFFFFFFE0;
  }
  if (__p) {
    operator delete(__p);
  }
  return v14;
}

void sub_1002B6170(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t *sub_1002B61A8(uint64_t *result, void *a2)
{
  uint64_t v3 = *result;
  uint64_t v2 = result[1];
  uint64_t v4 = a2[1];
  if (v2 != *result)
  {
    uint64_t v5 = 0;
    do
    {
      uint64_t v6 = v4 + v5;
      *(void *)(v6 - 32) = *(void *)(v2 + v5 - 32);
      *(void *)(v6 - 24) = *(void *)(v2 + v5 - 24);
      *(_DWORD *)(v6 - 16) = *(_DWORD *)(v2 + v5 - 16);
      *(void *)(v6 - 8) = *(void *)(v2 + v5 - 8);
      v5 -= 32;
    }
    while (v2 + v5 != v3);
    v4 += v5;
  }
  a2[1] = v4;
  uint64_t v7 = *result;
  *uint64_t result = v4;
  a2[1] = v7;
  uint64_t v8 = result[1];
  result[1] = a2[2];
  a2[2] = v8;
  uint64_t v9 = result[2];
  result[2] = a2[3];
  a2[3] = v9;
  *a2 = a2[1];
  return result;
}

void *sub_1002B6234(uint64_t a1, unint64_t a2)
{
  if (a2 >> 59) {
    sub_1000616DC();
  }
  return operator new(32 * a2);
}

uint64_t sub_1002B626C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a2 != a3)
  {
    uint64_t v3 = *(void *)(a1 + 8);
    uint64_t v4 = a2;
    if (a3 != v3)
    {
      uint64_t v5 = 32 * ((a3 - a2) >> 5);
      uint64_t v4 = a2;
      do
      {
        uint64_t v6 = *(void *)(v4 + v5 + 8);
        *(void *)uint64_t v4 = *(void *)(v4 + v5);
        *(void *)(v4 + 8) = v6;
        *(_DWORD *)(v4 + 16) = *(_DWORD *)(v4 + v5 + 16);
        *(void *)(v4 + 24) = *(void *)(v4 + v5 + 24);
        v4 += 32;
      }
      while (v4 + v5 != v3);
    }
    *(void *)(a1 + 8) = v4;
  }
  return a2;
}

uint64_t sub_1002B62D0(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (result != a2)
  {
    while (*(void *)result != a3 || a4 != *(void *)(result + 8))
    {
      result += 32;
      if (result == a2) {
        return a2;
      }
    }
  }
  if (result == a2) {
    return a2;
  }
  for (uint64_t i = result + 32; i != a2; i += 32)
  {
    if (*(void *)i != a3 || a4 != *(void *)(i + 8))
    {
      *(void *)uint64_t result = *(void *)i;
      *(void *)(result + 8) = *(void *)(i + 8);
      *(_DWORD *)(result + 16) = *(_DWORD *)(i + 16);
      *(void *)(result + 24) = *(void *)(i + 24);
      result += 32;
    }
  }
  return result;
}

void sub_1002B636C(id a1)
{
}

void sub_1002B63B0()
{
}

char *sub_1002B63D4(char *result, uint64_t a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    uint64_t v6 = result;
    uint64_t result = sub_1002B6450(result, a4);
    uint64_t v7 = *((void *)v6 + 1);
    while (a2 != a3)
    {
      *(void *)uint64_t v7 = *(void *)a2;
      *(void *)(v7 + 8) = *(void *)(a2 + 8);
      *(_DWORD *)(v7 + 16) = *(_DWORD *)(a2 + 16);
      *(void *)(v7 + 24) = *(void *)(a2 + 24);
      v7 += 32;
      a2 += 32;
    }
    *((void *)v6 + 1) = v7;
  }
  return result;
}

char *sub_1002B6450(void *a1, unint64_t a2)
{
  if (a2 >> 59) {
    abort();
  }
  uint64_t result = (char *)sub_1002B6234((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[32 * v4];
  return result;
}

void sub_1002B6490(id a1)
{
}

void sub_1002B64D4()
{
}

void sub_1002B64F8(id a1)
{
}

void sub_1002B653C()
{
}

void sub_1002B6560(void *a1)
{
  unint64_t v2 = a1[4];
  BOOL v3 = v2 >= 0x200;
  unint64_t v4 = v2 - 512;
  if (v3)
  {
    uint64_t v5 = (uint64_t)(a1 + 3);
    uint64_t v6 = (char *)a1[3];
    a1[4] = v4;
    uint64_t v7 = (void *)a1[1];
    uint64_t v8 = (char *)a1[2];
    uint64_t v11 = *v7;
    uint64_t v9 = (char *)(v7 + 1);
    uint64_t v10 = v11;
    a1[1] = v9;
    if (v8 != v6)
    {
LABEL_33:
      *(void *)uint64_t v8 = v10;
      a1[2] += 8;
      return;
    }
    uint64_t v12 = (uint64_t)&v9[-*a1];
    if ((unint64_t)v9 <= *a1)
    {
      if (v8 == (char *)*a1) {
        unint64_t v33 = 1;
      }
      else {
        unint64_t v33 = (uint64_t)&v8[-*a1] >> 2;
      }
      uint64_t v34 = (char *)sub_1000405F8(v5, v33);
      BOOL v35 = &v34[8 * (v33 >> 2)];
      int v37 = &v34[8 * v36];
      uint64_t v38 = (uint64_t *)a1[1];
      uint64_t v8 = v35;
      uint64_t v39 = a1[2] - (void)v38;
      if (v39)
      {
        uint64_t v8 = &v35[v39 & 0xFFFFFFFFFFFFFFF8];
        uint64_t v40 = 8 * (v39 >> 3);
        int64_t v41 = &v34[8 * (v33 >> 2)];
        do
        {
          uint64_t v42 = *v38++;
          *(void *)int64_t v41 = v42;
          v41 += 8;
          v40 -= 8;
        }
        while (v40);
      }
      goto LABEL_30;
    }
LABEL_5:
    uint64_t v13 = v12 >> 3;
    BOOL v14 = v12 >> 3 < -1;
    uint64_t v15 = (v12 >> 3) + 2;
    if (v14) {
      uint64_t v16 = v15;
    }
    else {
      uint64_t v16 = v13 + 1;
    }
    uint64_t v17 = -(v16 >> 1);
    uint64_t v18 = v16 >> 1;
    uint64_t v19 = &v9[-8 * v18];
    int64_t v20 = v8 - v9;
    if (v8 != v9)
    {
      memmove(&v9[-8 * v18], v9, v8 - v9);
      uint64_t v9 = (char *)a1[1];
    }
    uint64_t v8 = &v19[v20];
    a1[1] = &v9[8 * v17];
    a1[2] = &v19[v20];
    goto LABEL_33;
  }
  uint64_t v21 = a1[2];
  unint64_t v22 = (v21 - a1[1]) >> 3;
  uint64_t v23 = a1[3];
  uint64_t v24 = v23 - *a1;
  if (v22 < v24 >> 3)
  {
    if (v23 != v21)
    {
      *(void *)&long long v54 = operator new(0x1000uLL);
      sub_1002B4FA4(a1, &v54);
      return;
    }
    *(void *)&long long v54 = operator new(0x1000uLL);
    sub_1002B50BC((uint64_t)a1, &v54);
    uint64_t v44 = (void *)a1[1];
    uint64_t v8 = (char *)a1[2];
    uint64_t v45 = *v44;
    uint64_t v9 = (char *)(v44 + 1);
    uint64_t v10 = v45;
    a1[1] = v9;
    if (v8 != (char *)a1[3]) {
      goto LABEL_33;
    }
    uint64_t v12 = (uint64_t)&v9[-*a1];
    if ((unint64_t)v9 <= *a1)
    {
      if (v8 == (char *)*a1) {
        unint64_t v46 = 1;
      }
      else {
        unint64_t v46 = (uint64_t)&v8[-*a1] >> 2;
      }
      uint64_t v34 = (char *)sub_1000405F8((uint64_t)(a1 + 3), v46);
      BOOL v35 = &v34[8 * (v46 >> 2)];
      int v37 = &v34[8 * v47];
      unint64_t v48 = (uint64_t *)a1[1];
      uint64_t v8 = v35;
      uint64_t v49 = a1[2] - (void)v48;
      if (v49)
      {
        uint64_t v8 = &v35[v49 & 0xFFFFFFFFFFFFFFF8];
        uint64_t v50 = 8 * (v49 >> 3);
        char v51 = &v34[8 * (v46 >> 2)];
        do
        {
          uint64_t v52 = *v48++;
          *(void *)char v51 = v52;
          v51 += 8;
          v50 -= 8;
        }
        while (v50);
      }
LABEL_30:
      uint64_t v43 = (char *)*a1;
      *a1 = v34;
      a1[1] = v35;
      a1[2] = v8;
      a1[3] = v37;
      if (v43)
      {
        operator delete(v43);
        uint64_t v8 = (char *)a1[2];
      }
      goto LABEL_33;
    }
    goto LABEL_5;
  }
  if (v23 == *a1) {
    unint64_t v25 = 1;
  }
  else {
    unint64_t v25 = v24 >> 2;
  }
  long long v56 = a1 + 3;
  *(void *)&long long v54 = sub_1000405F8((uint64_t)(a1 + 3), v25);
  *((void *)&v54 + 1) = v54 + 8 * v22;
  *(void *)&long long v55 = *((void *)&v54 + 1);
  *((void *)&v55 + 1) = v54 + 8 * v26;
  uint64_t v53 = operator new(0x1000uLL);
  sub_1002B51DC(&v54, &v53);
  uint64_t v27 = (void *)a1[2];
  uint64_t v28 = -7 - (void)v27;
  while (v27 != (void *)a1[1])
  {
    --v27;
    v28 += 8;
    sub_1002B52F4((uint64_t)&v54, v27);
  }
  unsigned int v29 = (char *)*a1;
  long long v30 = v54;
  long long v31 = v55;
  *(void *)&long long v54 = *a1;
  *((void *)&v54 + 1) = v27;
  long long v32 = *((_OWORD *)a1 + 1);
  *(_OWORD *)a1 = v30;
  *((_OWORD *)a1 + 1) = v31;
  long long v55 = v32;
  if (v27 != (void *)v32) {
    *(void *)&long long v55 = v32 + (-(v32 + v28) & 0xFFFFFFFFFFFFFFF8);
  }
  if (v29) {
    operator delete(v29);
  }
}

void sub_1002B682C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13)
{
  operator delete(v13);
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void sub_1002B6878(void **a1)
{
  unint64_t v2 = a1[1];
  BOOL v3 = a1[2];
  unint64_t v4 = v3 - v2;
  if (v3 == v2) {
    uint64_t v5 = 0;
  }
  else {
    uint64_t v5 = ((v3 - v2) << 6) - 1;
  }
  uint64_t v6 = (char *)a1[4];
  if (v5 - (unint64_t)&v6[(void)a1[5]] < 0x200)
  {
    uint64_t v7 = (uint64_t)(a1 + 3);
    uint64_t v8 = a1[3];
    uint64_t v9 = *a1;
    uint64_t v10 = v8 - (unsigned char *)*a1;
    if (v4 >= v10)
    {
      if (v8 == v9) {
        unint64_t v11 = 1;
      }
      else {
        unint64_t v11 = v10 >> 2;
      }
      unint64_t v46 = a1 + 3;
      std::string __p = sub_1000405F8(v7, v11);
      uint64_t v43 = (char *)__p;
      uint64_t v44 = (char *)__p;
      uint64_t v45 = (char *)__p + 8 * v12;
      int64_t v41 = operator new(0x1000uLL);
      sub_1002B51DC(&__p, &v41);
      uint64_t v13 = (char *)a1[1];
      BOOL v14 = v44;
      if (v13 == a1[2])
      {
        unint64_t v33 = (char *)a1[1];
      }
      else
      {
        do
        {
          if (v14 == v45)
          {
            int64_t v15 = v43 - (unsigned char *)__p;
            if (v43 <= __p)
            {
              if (v14 == __p) {
                unint64_t v23 = 1;
              }
              else {
                unint64_t v23 = (v14 - (unsigned char *)__p) >> 2;
              }
              uint64_t v24 = (char *)sub_1000405F8((uint64_t)v46, v23);
              uint64_t v26 = v43;
              BOOL v14 = &v24[8 * (v23 >> 2)];
              uint64_t v27 = v44 - v43;
              if (v44 != v43)
              {
                BOOL v14 = &v24[8 * (v23 >> 2) + (v27 & 0xFFFFFFFFFFFFFFF8)];
                uint64_t v28 = 8 * (v27 >> 3);
                unsigned int v29 = &v24[8 * (v23 >> 2)];
                do
                {
                  uint64_t v30 = *(void *)v26;
                  v26 += 8;
                  *(void *)unsigned int v29 = v30;
                  v29 += 8;
                  v28 -= 8;
                }
                while (v28);
              }
              long long v31 = __p;
              std::string __p = v24;
              uint64_t v43 = &v24[8 * (v23 >> 2)];
              uint64_t v44 = v14;
              uint64_t v45 = &v24[8 * v25];
              if (v31)
              {
                operator delete(v31);
                BOOL v14 = v44;
              }
            }
            else
            {
              uint64_t v16 = v15 >> 3;
              BOOL v17 = v15 >> 3 < -1;
              uint64_t v18 = (v15 >> 3) + 2;
              if (v17) {
                uint64_t v19 = v18;
              }
              else {
                uint64_t v19 = v16 + 1;
              }
              int64_t v20 = &v43[-8 * (v19 >> 1)];
              int64_t v21 = v14 - v43;
              if (v14 != v43)
              {
                memmove(&v43[-8 * (v19 >> 1)], v43, v14 - v43);
                BOOL v14 = v43;
              }
              unint64_t v22 = &v14[-8 * (v19 >> 1)];
              BOOL v14 = &v20[v21];
              uint64_t v43 = v22;
              uint64_t v44 = &v20[v21];
            }
          }
          uint64_t v32 = *(void *)v13;
          v13 += 8;
          *(void *)BOOL v14 = v32;
          BOOL v14 = v44 + 8;
          v44 += 8;
        }
        while (v13 != a1[2]);
        unint64_t v33 = (char *)a1[1];
      }
      uint64_t v36 = *a1;
      int v37 = v43;
      *a1 = __p;
      a1[1] = v37;
      std::string __p = v36;
      uint64_t v43 = v33;
      uint64_t v38 = (char *)a1[3];
      uint64_t v39 = v45;
      a1[2] = v14;
      a1[3] = v39;
      uint64_t v44 = v13;
      uint64_t v45 = v38;
      if (v14 - v37 == 8) {
        uint64_t v40 = 256;
      }
      else {
        uint64_t v40 = (uint64_t)a1[4] + 512;
      }
      a1[4] = (void *)v40;
      if (v13 != v33) {
        uint64_t v44 = &v13[(v33 - v13 + 7) & 0xFFFFFFFFFFFFFFF8];
      }
      if (v36) {
        operator delete(v36);
      }
    }
    else
    {
      if (v2 == v9)
      {
        std::string __p = operator new(0x1000uLL);
        sub_1002B4FA4(a1, &__p);
        uint64_t v34 = a1[2];
        std::string __p = (void *)*(v34 - 1);
        a1[2] = v34 - 1;
      }
      else
      {
        std::string __p = operator new(0x1000uLL);
      }
      sub_1002B50BC((uint64_t)a1, &__p);
      if ((unsigned char *)a1[2] - (unsigned char *)a1[1] == 8) {
        uint64_t v35 = 256;
      }
      else {
        uint64_t v35 = (uint64_t)a1[4] + 512;
      }
      a1[4] = (void *)v35;
    }
  }
  else
  {
    a1[4] = v6 + 512;
    std::string __p = (void *)*((void *)v3 - 1);
    a1[2] = v3 - 8;
    sub_1002B50BC((uint64_t)a1, &__p);
  }
}

void sub_1002B6B40(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12)
{
  operator delete(v12);
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void *sub_1002B6B8C(void *a1, char **a2, char *a3, char *a4, char *a5)
{
  if (a5 == a3) {
    unint64_t v5 = 0;
  }
  else {
    unint64_t v5 = ((uint64_t)&a5[-*(void *)a4] >> 3) + ((a4 - (char *)a2) << 6) - ((a3 - *a2) >> 3);
  }
  return sub_1002B6BC0(a1, a2, a3, v5);
}

void *sub_1002B6BC0(void *a1, char **a2, char *a3, unint64_t a4)
{
  int64_t v20 = a2;
  int64_t v21 = a3;
  unint64_t v7 = a1[5];
  if (v7 >= a4)
  {
    uint64_t v14 = a1[1];
    int64_t v15 = (char *)(v14 + 8 * (a1[4] >> 9));
    if (a1[2] == v14) {
      uint64_t v16 = 0;
    }
    else {
      uint64_t v16 = *(void *)v15 + 8 * (a1[4] & 0x1FFLL);
    }
    v22[0] = a2;
    v22[1] = a3;
    uint64_t v18 = (char **)sub_1002B4F40((uint64_t)v22, a4);
    unint64_t v23 = v15;
    uint64_t v24 = v16;
    sub_1002B6DE4(a2, a3, v18, v19, (uint64_t)&v23);
    return (void *)sub_1002B6CE8((uint64_t)a1, v23, v24);
  }
  else
  {
    uint64_t v9 = (char **)sub_1002B4F40((uint64_t)&v20, v7);
    uint64_t v10 = (uint64_t *)v8;
    uint64_t v11 = a1[1];
    if (a1[2] == v11) {
      uint64_t v12 = 0;
    }
    else {
      uint64_t v12 = *(void *)(v11 + 8 * (a1[4] >> 9)) + 8 * (a1[4] & 0x1FFLL);
    }
    unint64_t v23 = (char *)(v11 + 8 * (a1[4] >> 9));
    uint64_t v24 = v12;
    sub_1002B6DE4(v20, v21, v9, v8, (uint64_t)&v23);
    return sub_1002B48B4(a1, v9, v10, a4 - a1[5]);
  }
}

uint64_t sub_1002B6CE8(uint64_t result, char *a2, uint64_t a3)
{
  BOOL v3 = (void *)result;
  unint64_t v4 = *(void *)(result + 32);
  unint64_t v5 = v4 + *(void *)(result + 40);
  uint64_t v6 = *(void *)(result + 8);
  uint64_t v7 = *(void *)(result + 16);
  uint64_t v8 = (char *)(v6 + 8 * (v5 >> 9));
  if (v7 == v6) {
    uint64_t v9 = 0;
  }
  else {
    uint64_t v9 = *(void *)v8 + 8 * (v5 & 0x1FF);
  }
  if (v9 != a3)
  {
    uint64_t v10 = ((v9 - *(void *)v8) >> 3) + ((v8 - a2) << 6);
    uint64_t v11 = a3 - *(void *)a2;
    uint64_t v12 = v10 - (v11 >> 3);
    if (v12 >= 1)
    {
      uint64_t v13 = (char *)(v6 + 8 * (v4 >> 9));
      if (v7 == v6) {
        uint64_t v14 = 0;
      }
      else {
        uint64_t v14 = *(void *)v13 + 8 * (*(void *)(result + 32) & 0x1FFLL);
      }
      v16[0] = v13;
      v16[1] = v14;
      if (v14 == a3) {
        uint64_t v15 = 0;
      }
      else {
        uint64_t v15 = (v11 >> 3) + ((a2 - v13) << 6) - ((v14 - *(void *)v13) >> 3);
      }
      sub_1002B4F40((uint64_t)v16, v15);
      v3[5] -= v12;
      do
        uint64_t result = sub_1002B6F74(v3, 1);
      while ((result & 1) != 0);
    }
  }
  return result;
}

double sub_1002B6DE4(char **a1, char *__src, char **a3, char *a4, uint64_t a5)
{
  if (a1 == a3)
  {
    uint64_t v11 = *(void ***)a5;
    uint64_t v12 = *(char **)(a5 + 8);
    uint64_t v10 = __src;
  }
  else
  {
    uint64_t v8 = a1 + 1;
    sub_1002B6EB4(__src, *(char **)(a5 + 8), *a1 + 4096, *(void ***)a5, &v14);
    for (*(_OWORD *)a5 = v15; v8 != a3; *(_OWORD *)a5 = v15)
    {
      uint64_t v9 = *v8++;
      sub_1002B6EB4(v9, *(char **)(a5 + 8), v9 + 4096, *(void ***)a5, &v14);
    }
    uint64_t v10 = *a3;
    uint64_t v11 = *(void ***)a5;
    uint64_t v12 = *(char **)(a5 + 8);
  }
  sub_1002B6EB4(v10, v12, a4, v11, &v14);
  double result = *(double *)&v15;
  *(_OWORD *)a5 = v15;
  return result;
}

char *sub_1002B6EB4@<X0>(char *__src@<X0>, char *__dst@<X3>, char *a3@<X1>, void **a4@<X2>, char **a5@<X8>)
{
  uint64_t v6 = a4;
  if (__src != a3)
  {
    uint64_t v9 = __src;
    uint64_t v6 = a4 + 1;
    uint64_t v10 = (char *)*a4;
    while (1)
    {
      uint64_t v11 = v10 - __dst + 4096;
      uint64_t v12 = (a3 - v9) >> 3 >= v11 >> 3 ? v11 >> 3 : (a3 - v9) >> 3;
      if (v12) {
        __src = (char *)memmove(__dst, v9, 8 * v12);
      }
      v9 += 8 * v12;
      if (v9 == a3) {
        break;
      }
      uint64_t v13 = (char *)*v6++;
      uint64_t v10 = v13;
      long long __dst = v13;
    }
    __dst += 8 * v12;
    if ((char *)*(v6 - 1) + 4096 == __dst) {
      long long __dst = (char *)*v6;
    }
    else {
      --v6;
    }
  }
  *a5 = a3;
  a5[1] = (char *)v6;
  a5[2] = __dst;
  return __src;
}

uint64_t sub_1002B6F74(void *a1, int a2)
{
  uint64_t v3 = a1[1];
  uint64_t v2 = a1[2];
  if (v2 == v3) {
    uint64_t v4 = 0;
  }
  else {
    uint64_t v4 = ((v2 - v3) << 6) - 1;
  }
  unint64_t v5 = v4 - (a1[5] + a1[4]);
  if (v5 < 0x200) {
    a2 = 1;
  }
  if (v5 < 0x400) {
    int v7 = a2;
  }
  else {
    int v7 = 0;
  }
  if ((v7 & 1) == 0)
  {
    operator delete(*(void **)(v2 - 8));
    a1[2] -= 8;
  }
  return v7 ^ 1u;
}

uint64_t sub_1002B7004(uint64_t result, uint64_t a2, uint64_t a3, float a4)
{
  *(float *)double result = a4;
  *(void *)(result + 4) = a2;
  *(_WORD *)(result + 12) = 2048;
  *(void *)(result + 14) = a3;
  return result;
}

void *sub_1002B7034(void *result, uint64_t a2, uint64_t a3, float a4)
{
  if (v4 >= 0) {
    unint64_t v5 = result;
  }
  else {
    unint64_t v5 = (void *)*result;
  }
  *(float *)a2 = a4;
  *(void *)(a2 + 4) = a3;
  *(_WORD *)(a2 + 12) = 2081;
  *(void *)(a2 + 14) = v5;
  return result;
}

void sub_1002B7058(uint64_t a1, ...)
{
  va_start(va, a1);
  sub_100474E18(0, (uint64_t *)va);
}

uint64_t sub_1002B70A4(uint64_t a1, uint64_t a2, ...)
{
  va_start(va, a2);
  return sub_100475EE0(a1, (uint64_t)va);
}

void sub_1002B70E0()
{
  sub_10004191C(v2, "com.apple.Preferences");
  int v3 = 1;
  sub_10004191C(v4, "com.apple.SharingViewService");
  int v5 = 2;
  sub_10004191C(v6, "com.apple.HeadphoneProxService");
  int v7 = 3;
  sub_1002B34FC((uint64_t)&qword_100A19A38, v2, 3);
  for (uint64_t i = 0; i != -12; i -= 4)
  {
    if (SHIBYTE(v6[i + 2]) < 0) {
      operator delete((void *)v6[i]);
    }
  }
  __cxa_atexit((void (*)(void *))sub_100283940, &qword_100A19A38, (void *)&_mh_execute_header);
}

void sub_1002B7204(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
  uint64_t v12 = 0;
  while (1)
  {
    if (*(char *)(v10 + v12 + 87) < 0) {
      operator delete(*(void **)(v10 + v12 + 64));
    }
    v12 -= 32;
    if (v12 == -96) {
      _Unwind_Resume(exception_object);
    }
  }
}

void *sub_1002B7268(void *a1, uint64_t a2)
{
  *a1 = off_1009A2550;
  a1[1] = a2;
  a1[2] = 0;
  Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  a1[3] = Mutable;
  CFDictionarySetValue(Mutable, @"Power Source State", @"Battery Power");
  return a1;
}

uint64_t sub_1002B72EC(uint64_t a1)
{
  *(void *)a1 = off_1009A2550;
  CFRelease(*(CFTypeRef *)(a1 + 24));
  if (*(void *)(a1 + 16)) {
    IOPSReleasePowerSource();
  }
  return a1;
}

void sub_1002B7344(uint64_t a1)
{
  sub_1002B72EC(a1);

  operator delete();
}

void sub_1002B737C(uint64_t *a1)
{
  sub_100475EE0(a1[1], (uint64_t)__p);
  (*(void (**)(uint64_t *, void **))(*a1 + 24))(a1, __p);
  if (v3 < 0) {
    operator delete(__p[0]);
  }
}

void sub_1002B73EC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1002B7408(uint64_t a1, uint64_t *a2)
{
  if (!*(void *)(a1 + 16))
  {
    IOPSCreatePowerSource();
    sub_1002B74DC(a1);
  }
  sub_1002B7600(a1, a2);
  int v4 = qword_100A19E50;
  if (os_log_type_enabled((os_log_t)qword_100A19E50, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = *(void *)(a1 + 24);
    int v7 = 138412290;
    uint64_t v8 = v5;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Publishing remote battery report %@", (uint8_t *)&v7, 0xCu);
  }
  return IOPSSetPowerSourceDetails();
}

void sub_1002B74DC(uint64_t a1)
{
  CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 24), @"Type", @"Accessory Source");
  CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 24), @"Transport Type", @"Bluetooth");
  int valuePtr = 100;
  CFNumberRef v2 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, &valuePtr);
  CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 24), @"Max Capacity", v2);
  CFRelease(v2);
  sub_1004A82EC((unsigned __int8 *)(*(void *)(a1 + 8) + 128), __p);
  if (v6 >= 0) {
    char v3 = __p;
  }
  else {
    char v3 = (void **)__p[0];
  }
  CFStringRef v4 = CFStringCreateWithCString(kCFAllocatorDefault, (const char *)v3, 0x8000100u);
  if (v6 < 0) {
    operator delete(__p[0]);
  }
  CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 24), @"Accessory Identifier", v4);
  CFRelease(v4);
}

void sub_1002B75E4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1002B7600(uint64_t a1, uint64_t *a2)
{
  if ((*((char *)a2 + 23) & 0x80000000) == 0)
  {
    if (!*((unsigned char *)a2 + 23)) {
      goto LABEL_7;
    }
LABEL_6:
    CFStringRef v3 = CFStringCreateWithCString(kCFAllocatorDefault, (const char *)a2, 0x8000100u);
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 24), @"Name", v3);
    CFRelease(v3);
    goto LABEL_8;
  }
  if (a2[1])
  {
    a2 = (uint64_t *)*a2;
    goto LABEL_6;
  }
LABEL_7:
  CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(a1 + 24), @"Name");
LABEL_8:
  CFNumberRef Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 24), @"Part Identifier");
  uint64_t v17 = 0;
  long long v15 = 0u;
  *(_OWORD *)std::string __p = 0u;
  long long v14 = 0u;
  sub_10004191C(__p, "");
  uint64_t v12 = 0;
  uint64_t v13 = 0;
  if (sub_10047B7A8(*(void *)(a1 + 8), (_DWORD *)&v13 + 1, &v13, (_DWORD *)&v12 + 1, &v12))
  {
    char valuePtr = BYTE4(v13);
    __int16 v10 = v13;
    CFNumberRef v5 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt8Type, &valuePtr);
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 24), @"Vendor ID Source", v5);
    CFRelease(v5);
    CFNumberRef v6 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt16Type, &v10);
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 24), @"Vendor ID", v6);
    CFRelease(v6);
    CFNumberRef v7 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt32Type, (char *)&v12 + 4);
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 24), @"Product ID", v7);
    CFRelease(v7);
  }
  else
  {
    CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(a1 + 24), @"Vendor ID Source");
    CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(a1 + 24), @"Vendor ID");
    CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(a1 + 24), @"Product ID");
  }
  int v8 = sub_100476054(*(void *)(a1 + 8));
  if (v8 != 16)
  {
    if (v8 == 19)
    {
      CFStringRef v9 = @"Speaker";
      goto LABEL_16;
    }
    if (v8 != 20)
    {
      CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(a1 + 24), @"Accessory Category");
      goto LABEL_18;
    }
  }
  CFStringRef v9 = @"Headphone";
LABEL_16:
  CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 24), @"Accessory Category", v9);
LABEL_18:
  if (Value && CFEqual(Value, @"Case")) {
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 24), @"Accessory Category", @"Audio Battery Case");
  }
  if (SHIBYTE(v17) < 0) {
    operator delete(__p[0]);
  }
}

void sub_1002B7860(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
  if (a22 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1002B7888(uint64_t a1, const char *a2)
{
  if (a2[23] < 0) {
    a2 = *(const char **)a2;
  }
  CFStringRef v3 = CFStringCreateWithCString(kCFAllocatorDefault, a2, 0x8000100u);
  CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 24), @"Group Identifier", v3);

  CFRelease(v3);
}

void sub_1002B78FC(uint64_t a1, const char *a2)
{
  if (a2[23] < 0) {
    a2 = *(const char **)a2;
  }
  CFStringRef v3 = CFStringCreateWithCString(kCFAllocatorDefault, a2, 0x8000100u);
  CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 24), @"Part Name", v3);

  CFRelease(v3);
}

void sub_1002B7970(uint64_t a1, unsigned int a2)
{
  if (a2 > 4) {
    CFNumberRef v2 = 0;
  }
  else {
    CFNumberRef v2 = *(&off_1009A25A0 + (int)a2);
  }
  CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 24), @"Part Identifier", v2);
}

void sub_1002B799C(uint64_t a1, int a2)
{
  int valuePtr = a2;
  CFNumberRef v3 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, &valuePtr);
  CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 24), @"Current Capacity", v3);
  CFRelease(v3);
}

CFNumberRef sub_1002B7A00(uint64_t a1, void *a2)
{
  CFNumberRef result = (const __CFNumber *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 24), @"Current Capacity");
  if (result) {
    return (const __CFNumber *)(CFNumberGetValue(result, kCFNumberIntType, a2) != 0);
  }
  return result;
}

void sub_1002B7A48(uint64_t a1, int a2)
{
  CFNumberRef v3 = (const void **)&kCFBooleanTrue;
  if (a2 != 1) {
    CFNumberRef v3 = (const void **)&kCFBooleanFalse;
  }
  CFStringRef v4 = *(__CFDictionary **)(a1 + 24);
  if (a2 == 1) {
    CFStringRef v5 = @"AC Power";
  }
  else {
    CFStringRef v5 = @"Battery Power";
  }
  CFDictionarySetValue(v4, @"Is Charging", *v3);
  CFNumberRef v6 = *(__CFDictionary **)(a1 + 24);

  CFDictionarySetValue(v6, @"Power Source State", v5);
}

uint64_t sub_1002B7AC8()
{
  if (qword_100A120C8 != -1) {
    dispatch_once(&qword_100A120C8, &stru_1009A25C8);
  }
  if (!byte_100A120C0) {
    return 0;
  }
  uint64_t v0 = mach_absolute_time();
  kdebug_trace();
  return v0;
}

uint64_t sub_1002B7B48()
{
  if (qword_100A120C8 != -1) {
    dispatch_once(&qword_100A120C8, &stru_1009A25C8);
  }
  if (!byte_100A120C0) {
    return 0;
  }
  uint64_t v0 = mach_absolute_time();
  kdebug_trace();
  return v0;
}

void sub_1002B7BC8(uint64_t a1)
{
  if (qword_100A120C8 != -1) {
    dispatch_once(&qword_100A120C8, &stru_1009A25C8);
  }
  if (byte_100A120C0 && (unint64_t)(a1 - 3) <= 3)
  {
    kdebug_trace();
  }
}

void sub_1002B7C60(uint64_t a1)
{
  if (qword_100A120C8 != -1) {
    dispatch_once(&qword_100A120C8, &stru_1009A25C8);
  }
  if (byte_100A120C0 && (a1 == 7 || a1 == 8))
  {
    kdebug_trace();
  }
}

void sub_1002B7CFC(uint64_t a1)
{
  if (qword_100A120C8 != -1) {
    dispatch_once(&qword_100A120C8, &stru_1009A25C8);
  }
  if (byte_100A120C0 && (unint64_t)(a1 - 9) <= 3)
  {
    kdebug_trace();
  }
}

void sub_1002B7D94(uint64_t a1, uint64_t a2)
{
  if (qword_100A120C8 != -1) {
    dispatch_once(&qword_100A120C8, &stru_1009A25C8);
  }
  if (byte_100A120C0)
  {
    if (a2)
    {
      sub_10003AE4C(a2, (uint64_t)__p);
      sub_10044A6C0((uint64_t)__p);
      if (v5 < 0) {
        operator delete(__p[0]);
      }
    }
    if (unint64_t)(a1 - 15) < 8 && ((0xC3u >> (a1 - 15))) {
      kdebug_trace();
    }
  }
}

void sub_1002B7E58(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1002B7E74(uint64_t a1, uint64_t a2, void *a3)
{
  id v5 = a3;
  if (qword_100A120C8 != -1) {
    dispatch_once(&qword_100A120C8, &stru_1009A25C8);
  }
  if (byte_100A120C0)
  {
    if (a2)
    {
      sub_10003AE4C(a2, (uint64_t)__p);
      sub_10044A6C0((uint64_t)__p);
      if (v7 < 0) {
        operator delete(__p[0]);
      }
    }
    [v5 hash];
    if ((unint64_t)(a1 - 17) < 4) {
      kdebug_trace();
    }
  }
}

void sub_1002B7F48(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

void sub_1002B7F74(id a1)
{
  uint64_t v1 = sub_100017768();
  sub_10004191C(v4, "Signposts");
  sub_10004191C(__p, "Enabled");
  (*(void (**)(uint64_t, void **, void **, char *))(*(void *)v1 + 72))(v1, v4, __p, &byte_100A120C0);
  if (v3 < 0) {
    operator delete(__p[0]);
  }
  if (v5 < 0) {
    operator delete(v4[0]);
  }
}

void sub_1002B8018(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if (a20 < 0) {
    operator delete(a15);
  }
  _Unwind_Resume(exception_object);
}

void sub_1002B804C(unsigned char *a1)
{
  *a1 = 1;
  sub_100023344();
}

pthread_cond_t *sub_1002B8058(pthread_cond_t *a1)
{
  if (pthread_cond_init(a1, 0) && os_log_type_enabled((os_log_t)qword_100A19E50, OS_LOG_TYPE_FAULT)) {
    sub_1007514D8();
  }
  return a1;
}

pthread_cond_t *sub_1002B80C0(pthread_cond_t *a1)
{
  return sub_1002B8058(a1);
}

pthread_cond_t *sub_1002B80C8(pthread_cond_t *a1)
{
  if (pthread_cond_destroy(a1) && os_log_type_enabled((os_log_t)qword_100A19E50, OS_LOG_TYPE_FAULT)) {
    sub_1007514D8();
  }
  return a1;
}

void sub_1002B8130(pthread_cond_t *a1, pthread_mutex_t *a2)
{
  if (pthread_cond_wait(a1, a2))
  {
    if (os_log_type_enabled((os_log_t)qword_100A19E50, OS_LOG_TYPE_FAULT)) {
      sub_1007514D8();
    }
  }
}

void sub_1002B8184(pthread_cond_t *a1, pthread_mutex_t **a2)
{
}

void sub_1002B818C(pthread_cond_t *a1)
{
  if (pthread_cond_signal(a1))
  {
    if (os_log_type_enabled((os_log_t)qword_100A19E50, OS_LOG_TYPE_FAULT)) {
      sub_1007514D8();
    }
  }
}

uint64_t sub_1002B81E0(uint64_t a1, char *__s1, char a3)
{
  *(void *)a1 = off_1009A25F8;
  *(void *)(a1 + 8) = strdup(__s1);
  *(unsigned char *)(a1 + 16) = a3;
  sub_100009CB8((pthread_mutex_t *)(a1 + 24));
  *(void *)(a1 + 88) = 0;
  return a1;
}

uint64_t sub_1002B8240(uint64_t a1)
{
  *(void *)a1 = off_1009A25F8;
  free(*(void **)(a1 + 8));
  sub_100052D40((pthread_mutex_t *)(a1 + 24));
  return a1;
}

void sub_1002B8298(pthread_t *a1)
{
  CFNumberRef v2 = a1 + 3;
  uint64_t v3 = 0;
  sub_10003AF00((uint64_t)&v2);
  sub_100117A38(a1 + 11, (void *(__cdecl *)(void *))sub_1002B8318, a1);
  if ((_BYTE)v3) {
    sub_10003AFE8((uint64_t)&v2);
  }
}

void sub_1002B82FC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
  if (a10) {
    sub_10003AFE8((uint64_t)&a9);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1002B8318(uint64_t a1)
{
  return 0;
}

BOOL sub_1002B8334(uint64_t a1, integer_t a2, integer_t a3, int a4, int a5)
{
  return sub_100117B0C(*(_opaque_pthread_t **)(a1 + 88), a2, a3, a4, a5);
}

BOOL sub_1002B833C(uint64_t a1, int a2)
{
  return sub_100117AD8(*(_opaque_pthread_t **)(a1 + 88), a2);
}

uint64_t sub_1002B8344(uint64_t a1)
{
  CFNumberRef v2 = (pthread_mutex_t *)(a1 + 24);
  sub_10003AF60((pthread_mutex_t *)(a1 + 24));
  sub_10003B044(v2);
  int v3 = *(unsigned __int8 *)(a1 + 16);
  CFStringRef v4 = *(const char **)(a1 + 8);
  if (v4) {
    sub_100117BB4(v4);
  }
  (*(void (**)(uint64_t))(*(void *)a1 + 16))(a1);
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)a1 + 8))(a1);
  }
  return 0;
}

void sub_1002B83E0(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_fault_impl(a1, a2, OS_LOG_TYPE_FAULT, a4, &a9, 8u);
}

void sub_1002B8478(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t sub_1002B84F8(uint64_t a1)
{
  *(void *)a1 = off_1009A2620;
  *(void *)(a1 + 8) = off_1009A26C0;
  *(void *)(a1 + 16) = off_1009A2770;
  *(void *)(a1 + 24) = off_1009A27A0;
  *(void *)(a1 + 32) = off_1009A27E0;
  *(void *)(a1 + 40) = &off_1009A2810;
  *(unsigned char *)(a1 + 56) = 0;
  *(unsigned char *)(a1 + 62) = 0;
  *(void *)(a1 + 64) = &stru_1009C1AC8;
  *(unsigned char *)(a1 + 72) = 1;
  sub_100052DA8(a1 + 80);
  *(void *)(a1 + 160) = 0;
  *(void *)(a1 + 152) = 0;
  *(void *)(a1 + 144) = a1 + 152;
  *(_OWORD *)(a1 + 168) = 0u;
  *(_OWORD *)(a1 + ++*(_DWORD *)(result + 184) = 0u;
  *(_OWORD *)(a1 + 200) = 0u;
  *(void *)(a1 + 216) = 0;
  return a1;
}

void sub_1002B8620(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t sub_1002B8638(uint64_t a1)
{
  if (qword_1009F8748 != -1) {
    dispatch_once(&qword_1009F8748, &stru_1009A2A68);
  }
  sub_1002C3EBC((uint64_t)off_1009F8740 + 80, a1);
  if (qword_1009F7EC0 != -1) {
    dispatch_once(&qword_1009F7EC0, &stru_1009A2A88);
  }
  sub_100680938((uint64_t)off_1009F7EB8, a1 + 8, 0);
  if (qword_1009F8070 != -1) {
    dispatch_once(&qword_1009F8070, &stru_1009A2AA8);
  }
  sub_10026B36C((uint64_t)off_1009F8068 + 64, a1 + 32);
  uint64_t v2 = sub_100373254();
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v2 + 32))(v2, a1 + 40);
  *(_WORD *)(a1 + 57) = 0;
  return result;
}

void sub_1002B873C(uint64_t a1)
{
  *(_DWORD *)(a1 + 228) = 0;
  *(unsigned char *)(a1 + 224) = 0;
  unsigned __int8 v19 = 1;
  uint64_t v2 = sub_100017768();
  sub_10004191C(buf, "Magnet");
  sub_10004191C(__p, "AllowPeripheralModeSupport");
  (*(void (**)(uint64_t, uint8_t *, void **, unsigned __int8 *))(*(void *)v2 + 72))(v2, buf, __p, &v19);
  if (v18 < 0) {
    operator delete(__p[0]);
  }
  if (v21 < 0) {
    operator delete(*(void **)buf);
  }
  char v16 = 0;
  uint64_t v3 = sub_100017768();
  sub_10004191C(buf, "Magnet");
  sub_10004191C(__p, "EnableAutomaticPairing");
  (*(void (**)(uint64_t, uint8_t *, void **, char *))(*(void *)v3 + 72))(v3, buf, __p, &v16);
  if (v18 < 0) {
    operator delete(__p[0]);
  }
  if (v21 < 0) {
    operator delete(*(void **)buf);
  }
  char v15 = 0;
  uint64_t v4 = sub_100017768();
  sub_10004191C(buf, "Magnet");
  sub_10004191C(__p, "ForceERTMOnNonReliablePipes");
  (*(void (**)(uint64_t, uint8_t *, void **, char *))(*(void *)v4 + 72))(v4, buf, __p, &v15);
  if (v18 < 0) {
    operator delete(__p[0]);
  }
  if (v21 < 0) {
    operator delete(*(void **)buf);
  }
  if (v15)
  {
    char v5 = qword_100A19EA0;
    if (os_log_type_enabled((os_log_t)qword_100A19EA0, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)int64x2_t buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "Forcing ERTM on non reliable pipe", buf, 2u);
      BOOL v6 = v15 != 0;
    }
    else
    {
      BOOL v6 = 1;
    }
    sub_1000EB058(v6);
  }
  uint64_t v7 = sub_100019878();
  v12[0] = _NSConcreteStackBlock;
  v12[1] = 3221225472;
  void v12[2] = sub_1002B927C;
  void v12[3] = &unk_1009A0B58;
  void v12[4] = a1;
  unsigned __int8 v13 = v19;
  char v14 = v16;
  sub_1000197D8(v7, v12);
  int v8 = qword_100A19EA0;
  if (os_log_type_enabled((os_log_t)qword_100A19EA0, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)int64x2_t buf = 67109120;
    *(_DWORD *)&uint8_t buf[4] = v19;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "Initialized ScalablePipe. Peripheral Support: %d", buf, 8u);
  }
  uint64_t v9 = sub_10003FFD4();
  sub_10026B638(v9 + 368, a1 + 16);
  uint64_t v10 = sub_1004AFA9C();
  v11[0] = _NSConcreteStackBlock;
  v11[1] = 3221225472;
  void v11[2] = sub_1002BA2D0;
  void v11[3] = &unk_100997528;
  void v11[4] = a1;
  sub_1000197D8(v10, v11);
}

void sub_1002B8A9C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,void *__p,uint64_t a22,int a23,__int16 a24,char a25,char a26)
{
  if (a26 < 0) {
    operator delete(__p);
  }
  if (*(char *)(v26 - 57) < 0) {
    operator delete(*(void **)(v26 - 80));
  }
  _Unwind_Resume(exception_object);
}

void sub_1002B8AE8(uint64_t a1, int a2, uint64_t a3, char a4)
{
  int v8 = sub_10016F37C(a1);
  uint64_t v9 = qword_100A19EA0;
  if (os_log_type_enabled((os_log_t)qword_100A19EA0, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)int64x2_t buf = 134218240;
    uint64_t v18 = a1;
    __int16 v19 = 1024;
    int v20 = v8;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "Scalable pipe transport has been upgraded handle:%p p:0x%4x", buf, 0x12u);
  }
  if (a2 == 1)
  {
    uint64_t v10 = qword_100A19EA0;
    if (os_log_type_enabled((os_log_t)qword_100A19EA0, OS_LOG_TYPE_FAULT)) {
      sub_100751540(v10, v11, v12);
    }
  }
  if (qword_1009F7F00 != -1) {
    dispatch_once(&qword_1009F7F00, &stru_1009A2B48);
  }
  *(_DWORD *)int64x2_t buf = *(_DWORD *)a3;
  LOWORD(v18) = *(_WORD *)(a3 + 4);
  uint64_t v13 = sub_1004AA194((uint64_t)off_1009F7EF8, (uint64_t)buf, 1);
  uint64_t v14 = sub_100019878();
  v15[0] = _NSConcreteStackBlock;
  v15[1] = 3221225472;
  void v15[2] = sub_1002BF660;
  v15[3] = &unk_1009A0160;
  char v16 = a4;
  v15[4] = a1;
  void v15[5] = v13;
  sub_100013018(v14, v15);
}

void sub_1002B8C94(uint64_t a1, int a2, int a3)
{
  int v6 = sub_10016F37C(a1);
  uint64_t v7 = qword_100A19EA0;
  if (os_log_type_enabled((os_log_t)qword_100A19EA0, OS_LOG_TYPE_DEFAULT))
  {
    int v9 = 136446978;
    uint64_t v10 = sub_1002BF820(a2);
    __int16 v11 = 1024;
    int v12 = a3;
    __int16 v13 = 2048;
    uint64_t v14 = a1;
    __int16 v15 = 1024;
    int v16 = v6;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "Scalable pipe transport has been downgraded to %{public}s - average transmit throughput was %ukbps, handle %p p:0x%4x", (uint8_t *)&v9, 0x22u);
  }
  uint64_t v8 = sub_100019878();
  sub_100013018(v8, &stru_1009A2878);
}

void sub_1002B8D90(uint64_t a1, char a2, char a3, char a4)
{
  uint64_t v15 = 0;
  sub_10010BB74((_DWORD *)&v15 + 1, (__darwin_suseconds_t *)&v15);
  uint64_t v8 = sub_100019878();
  v9[0] = _NSConcreteStackBlock;
  v9[1] = 3221225472;
  void v9[2] = sub_1002BFDD8;
  void v9[3] = &unk_1009A2898;
  void v9[4] = a1;
  char v12 = a2;
  char v13 = a3;
  char v14 = a4;
  int v10 = HIDWORD(v15);
  int v11 = v15;
  sub_100013018(v8, v9);
}

void sub_1002B8E44()
{
}

void sub_1002B8F10()
{
}

void sub_1002B8FE4(unsigned __int8 *a1, int a2, int a3, int a4)
{
  char v17 = 0;
  if (sub_100197770((uint64_t)a1))
  {
    unint64_t v8 = ((unint64_t)a1[49] << 40) | ((unint64_t)a1[50] << 32) | ((unint64_t)a1[51] << 24) | ((unint64_t)a1[52] << 16) | ((unint64_t)a1[53] << 8) | a1[54] | ((unint64_t)a1[48] << 48);
LABEL_5:
    sub_1000E958C(v8, &v17);
    goto LABEL_6;
  }
  if (sub_100197698((uint64_t)a1))
  {
    unint64_t v8 = ((unint64_t)a1[48] << 40) | ((unint64_t)a1[49] << 32) | ((unint64_t)a1[50] << 24) | ((unint64_t)a1[51] << 16) | ((unint64_t)a1[52] << 8) | a1[53];
    goto LABEL_5;
  }
  int v10 = qword_100A19EA0;
  if (os_log_type_enabled((os_log_t)qword_100A19EA0, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)int64x2_t buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "Invalid handle in error metric CB", buf, 2u);
  }
LABEL_6:
  uint64_t v9 = sub_100019878();
  v11[0] = _NSConcreteStackBlock;
  v11[1] = 3221225472;
  void v11[2] = sub_1002C02A4;
  void v11[3] = &unk_1009A28D8;
  void v11[4] = a1;
  int v12 = a2;
  int v13 = a3;
  int v14 = a4;
  char v15 = v17;
  sub_100013018(v9, v11);
}

void sub_1002B9160(uint64_t a1, int a2, __int16 a3)
{
  int v6 = qword_100A19EA0;
  if (os_log_type_enabled((os_log_t)qword_100A19EA0, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)int64x2_t buf = 67109376;
    int v12 = a2;
    __int16 v13 = 2048;
    uint64_t v14 = a1;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "AP wakeup by pipe 0x%04x handle %p", buf, 0x12u);
  }
  uint64_t v7 = sub_100019878();
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 3221225472;
  void v8[2] = sub_1002C0844;
  void v8[3] = &unk_100997570;
  void v8[4] = a1;
  __int16 v9 = a2;
  __int16 v10 = a3;
  sub_100013018(v7, v8);
}

unsigned char *sub_1002B927C(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  char v65 = 0;
  sub_10001B8E0(&v65);
  if (!sub_10022A2F0()) {
    return sub_10001B8AC(&v65);
  }
  uint64_t v3 = sub_100035F54();
  if (!(*(unsigned int (**)(uint64_t))(*(void *)v3 + 88))(v3)) {
    return sub_10001B8AC(&v65);
  }
  if (sub_1000E6974(*(unsigned char *)(a1 + 40), *(unsigned char *)(a1 + 41)))
  {
    if (os_log_type_enabled((os_log_t)qword_100A19EA0, OS_LOG_TYPE_ERROR)) {
      sub_100751658();
    }
    return sub_10001B8AC(&v65);
  }
  unsigned __int8 v64 = 0;
  __int16 v63 = 0;
  __int16 v62 = 0;
  unsigned int v60 = 0;
  unsigned int v61 = -84;
  unsigned __int8 v59 = 0;
  int v58 = 0;
  uint64_t v4 = sub_100017768();
  if ((*(unsigned int (**)(uint64_t))(*(void *)v4 + 8))(v4)) {
    int v5 = 10;
  }
  else {
    int v5 = 0;
  }
  int v58 = v5;
  uint64_t v6 = sub_100017768();
  sub_10004191C(&buf, "Magnet");
  sub_10004191C(__p, "DisableClassic");
  (*(void (**)(uint64_t, long long *, unsigned char *, unsigned __int8 *))(*(void *)v6 + 72))(v6, &buf, __p, &v64);
  if (SHIBYTE(v69) < 0) {
    operator delete(*(void **)__p);
  }
  if (SBYTE7(v72) < 0) {
    operator delete((void *)buf);
  }
  uint64_t v7 = sub_100017768();
  sub_10004191C(&buf, "Magnet");
  sub_10004191C(__p, "EnableAWDL");
  (*(void (**)(uint64_t, long long *, unsigned char *, char *))(*(void *)v7 + 72))(v7, &buf, __p, (char *)&v63 + 1);
  if (SHIBYTE(v69) < 0) {
    operator delete(*(void **)__p);
  }
  if (SBYTE7(v72) < 0) {
    operator delete((void *)buf);
  }
  uint64_t v8 = sub_100017768();
  sub_10004191C(&buf, "Magnet");
  sub_10004191C(__p, "HistorySize");
  (*(void (**)(uint64_t, long long *, unsigned char *, int *))(*(void *)v8 + 88))(v8, &buf, __p, &v58);
  if (SHIBYTE(v69) < 0) {
    operator delete(*(void **)__p);
  }
  if (SBYTE7(v72) < 0) {
    operator delete((void *)buf);
  }
  uint64_t v9 = sub_100017768();
  sub_10004191C(&buf, "Magnet");
  sub_10004191C(__p, "AssertUpgrade");
  (*(void (**)(uint64_t, long long *, unsigned char *, __int16 *))(*(void *)v9 + 72))(v9, &buf, __p, &v63);
  if (SHIBYTE(v69) < 0) {
    operator delete(*(void **)__p);
  }
  if (SBYTE7(v72) < 0) {
    operator delete((void *)buf);
  }
  uint64_t v10 = sub_100017768();
  sub_10004191C(&buf, "Magnet");
  sub_10004191C(__p, "DisableFlush");
  (*(void (**)(uint64_t, long long *, unsigned char *, char *))(*(void *)v10 + 72))(v10, &buf, __p, (char *)&v62 + 1);
  if (SHIBYTE(v69) < 0) {
    operator delete(*(void **)__p);
  }
  if (SBYTE7(v72) < 0) {
    operator delete((void *)buf);
  }
  uint64_t v11 = sub_100017768();
  sub_10004191C(&buf, "Magnet");
  sub_10004191C(__p, "EnablePerPacketLogging");
  (*(void (**)(uint64_t, long long *, unsigned char *, __int16 *))(*(void *)v11 + 72))(v11, &buf, __p, &v62);
  if (SHIBYTE(v69) < 0) {
    operator delete(*(void **)__p);
  }
  if (SBYTE7(v72) < 0) {
    operator delete((void *)buf);
  }
  uint64_t v12 = sub_100017768();
  sub_10004191C(&buf, "Magnet");
  sub_10004191C(__p, "RSSIMinSwitchThreshold");
  (*(void (**)(uint64_t, long long *, unsigned char *, unsigned int *))(*(void *)v12 + 88))(v12, &buf, __p, &v61);
  if (SHIBYTE(v69) < 0) {
    operator delete(*(void **)__p);
  }
  if (SBYTE7(v72) < 0) {
    operator delete((void *)buf);
  }
  uint64_t v13 = sub_100017768();
  sub_10004191C(&buf, "Magnet");
  sub_10004191C(__p, "ForceMaxLatency");
  (*(void (**)(uint64_t, long long *, unsigned char *, unsigned int *))(*(void *)v13 + 128))(v13, &buf, __p, &v60);
  if (SHIBYTE(v69) < 0) {
    operator delete(*(void **)__p);
  }
  if (SBYTE7(v72) < 0) {
    operator delete((void *)buf);
  }
  uint64_t v14 = sub_100017768();
  sub_10004191C(&buf, "Magnet");
  sub_10004191C(__p, "enableTSEverywhere");
  (*(void (**)(uint64_t, long long *, unsigned char *, unsigned __int8 *))(*(void *)v14 + 72))(v14, &buf, __p, &v59);
  if (SHIBYTE(v69) < 0) {
    operator delete(*(void **)__p);
  }
  if (SBYTE7(v72) < 0) {
    operator delete((void *)buf);
  }
  if (HIBYTE(v63) && os_log_type_enabled((os_log_t)qword_100A19EA0, OS_LOG_TYPE_ERROR)) {
    sub_100751624();
  }
  int v15 = v64;
  if (v64)
  {
    int v16 = qword_100A19EA0;
    if (os_log_type_enabled((os_log_t)qword_100A19EA0, OS_LOG_TYPE_ERROR))
    {
      LOWORD(buf) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_ERROR, "User forced disable Classic transport !", (uint8_t *)&buf, 2u);
      int v15 = v64;
    }
    else
    {
      int v15 = 1;
    }
  }
  BOOL v17 = v15 == 0;
  int v18 = HIBYTE(v63);
  sub_1000262C4();
  __int16 v19 = qword_100A19EA0;
  if (os_log_type_enabled((os_log_t)qword_100A19EA0, OS_LOG_TYPE_DEFAULT))
  {
    LODWORD(buf) = 67109120;
    DWORD1(buf) = v61;
    _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "rssiThreshold = %d", (uint8_t *)&buf, 8u);
  }
  sub_10016F460(v61);
  if ((_BYTE)v63)
  {
    if (os_log_type_enabled((os_log_t)qword_100A19EA0, OS_LOG_TYPE_ERROR)) {
      sub_1007515F0();
    }
    uint64_t v20 = 200;
  }
  else
  {
    uint64_t v20 = 0;
  }
  sub_1000E44C8(v20, 0, 0);
  int v21 = v17 | (2 * v18);
  if (v21)
  {
    v56[0] = *(_OWORD *)&off_1009A2818;
    v56[1] = *(_OWORD *)&off_1009A2828;
    v56[2] = *(_OWORD *)&off_1009A2838;
    uint64_t v57 = sub_1002B9160;
    if (sub_10016BB94(v21, (uint64_t)v56))
    {
      if (os_log_type_enabled((os_log_t)qword_100A19EA0, OS_LOG_TYPE_ERROR)) {
        sub_1007515BC();
      }
      return sub_10001B8AC(&v65);
    }
  }
  else
  {
    uint64_t v22 = sub_10003FB34();
    if (sub_100354254(v22)) {
      sub_1000E7420();
    }
    unint64_t v23 = qword_100A19EA0;
    if (os_log_type_enabled((os_log_t)qword_100A19EA0, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(buf) = 0;
      _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "Warning: Transport switching disabled by defaults write", (uint8_t *)&buf, 2u);
    }
  }
  if (HIBYTE(v62))
  {
    uint64_t v24 = qword_100A19EA0;
    if (os_log_type_enabled((os_log_t)qword_100A19EA0, OS_LOG_TYPE_ERROR))
    {
      LOWORD(buf) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_ERROR, "Disabling L2CAP flush on Isoch endpoint !", (uint8_t *)&buf, 2u);
      BOOL v25 = HIBYTE(v62) != 0;
    }
    else
    {
      BOOL v25 = 1;
    }
    sub_100171E34(v25);
  }
  if ((_BYTE)v62)
  {
    uint64_t v26 = qword_100A19EA0;
    if (os_log_type_enabled((os_log_t)qword_100A19EA0, OS_LOG_TYPE_ERROR))
    {
      LOWORD(buf) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_ERROR, "User forced enable per packet logging", (uint8_t *)&buf, 2u);
      BOOL v27 = (_BYTE)v62 != 0;
    }
    else
    {
      BOOL v27 = 1;
    }
    sub_1000E48A4(v27);
  }
  uint64_t v28 = v60;
  if (v60)
  {
    unsigned int v29 = qword_100A19EA0;
    if (os_log_type_enabled((os_log_t)qword_100A19EA0, OS_LOG_TYPE_ERROR))
    {
      LODWORD(buf) = 67109120;
      DWORD1(buf) = v28;
      _os_log_error_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_ERROR, "User forced enable ForceMaxLatency=%u", (uint8_t *)&buf, 8u);
      uint64_t v28 = v60;
    }
    sub_1000EB748(v28);
  }
  int v30 = v59;
  if (v59)
  {
    long long v31 = qword_100A19EA0;
    if (os_log_type_enabled((os_log_t)qword_100A19EA0, OS_LOG_TYPE_ERROR))
    {
      LODWORD(buf) = 67109120;
      DWORD1(buf) = v30;
      _os_log_error_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_ERROR, "User forced enable forceTSEverywhere=%d", (uint8_t *)&buf, 8u);
      BOOL v32 = v59 != 0;
    }
    else
    {
      BOOL v32 = 1;
    }
    sub_1000EB754(v32);
  }
  uint64_t v33 = sub_10003FB34();
  (*(void (**)(uint64_t))(*(void *)v33 + 3288))(v33);
  *(unsigned char *)(v2 + 56) = 1;
  v55[0] = 0;
  v55[1] = 0;
  sub_10003AED0((uint64_t)v55, v2 + 80);
  uint64_t v34 = *(void **)(v2 + 144);
  uint64_t v52 = (void *)(v2 + 152);
  if (v34 != (void *)(v2 + 152))
  {
    do
    {
      uint64_t v35 = v34[5];
      uint64_t v36 = *(char **)(v35 + 32);
LABEL_84:
      int v37 = *(char **)(v35 + 40);
      while (v36 != v37)
      {
        uint64_t v38 = *(unsigned __int8 **)v36;
        uint64_t v73 = sub_1002BA1B0;
        long long buf = *(_OWORD *)&off_1009A2850;
        long long v72 = *(_OWORD *)&off_1009A2860;
        if ((char)v38[23] < 0)
        {
          uint64_t v40 = *(void **)v38;
          uint64_t v39 = *((void *)v38 + 1);
        }
        else
        {
          LODWORD(v39) = v38[23];
          uint64_t v40 = v38;
        }
        int v41 = *((_DWORD *)v38 + 7);
        if ((v41 - 1) > 3) {
          uint64_t v42 = 1;
        }
        else {
          uint64_t v42 = dword_1007BB7D0[v41 - 1];
        }
        int v43 = sub_1000E9608(v40, (v39 + 1), *((_DWORD *)v38 + 6), v42, v38[36], v38[37], v38[38], v41 == 4, &buf);
        if (!v43)
        {
          v36 += 8;
          goto LABEL_84;
        }
        uint64_t v44 = qword_100A19EA0;
        if (os_log_type_enabled((os_log_t)qword_100A19EA0, OS_LOG_TYPE_ERROR))
        {
          if ((char)v38[23] < 0) {
            uint64_t v38 = *(unsigned __int8 **)v38;
          }
          sub_10003AE4C(v34[4], (uint64_t)v53);
          uint64_t v47 = v53;
          if (v54 < 0) {
            uint64_t v47 = (void **)v53[0];
          }
          *(_DWORD *)std::string __p = 136446722;
          *(void *)&__p[4] = v38;
          __int16 v67 = 2082;
          uint64_t v68 = v47;
          __int16 v69 = 1024;
          int v70 = v43;
          _os_log_error_impl((void *)&_mh_execute_header, v44, OS_LOG_TYPE_ERROR, "Failed to re-register endpoint \"%{public}s\" after power cycle, for session \"%{public}s\" with result %{bluetooth:OI_STATUS}u", __p, 0x1Cu);
          if (v54 < 0) {
            operator delete(v53[0]);
          }
        }
        uint64_t v45 = *(char **)(v35 + 40);
        int64_t v46 = v45 - (v36 + 8);
        if (v45 != v36 + 8) {
          memmove(v36, v36 + 8, v45 - (v36 + 8));
        }
        int v37 = &v36[v46];
        *(void *)(v35 + 40) = &v36[v46];
      }
      unint64_t v48 = (void *)v34[1];
      if (v48)
      {
        do
        {
          uint64_t v49 = v48;
          unint64_t v48 = (void *)*v48;
        }
        while (v48);
      }
      else
      {
        do
        {
          uint64_t v49 = (void *)v34[2];
          BOOL v50 = *v49 == (void)v34;
          uint64_t v34 = v49;
        }
        while (!v50);
      }
      uint64_t v34 = v49;
    }
    while (v49 != v52);
  }
  sub_10003AFB4((uint64_t)v55);
  return sub_10001B8AC(&v65);
}

void sub_1002B9DC8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,int a28,__int16 a29,char a30,char a31,void *__p,uint64_t a33,int a34,__int16 a35,char a36,char a37)
{
}

uint64_t sub_1002B9E94()
{
  return 1;
}

void sub_1002B9E9C(uint64_t a1, __int16 a2)
{
  if (qword_1009FB180 != -1) {
    dispatch_once(&qword_1009FB180, &stru_1009A2A48);
  }
  sub_1002C2BB4((void *)qword_1009FB178, a2);
  sub_100225F4C(a1);
  sub_100019878();
  operator new();
}

void sub_1002B9FA4(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
}

void sub_1002B9FEC()
{
}

void sub_1002BA11C(unsigned int a1, const void *a2, unsigned int a3, __int16 a4, int a5)
{
  if (qword_1009FB180 != -1) {
    dispatch_once(&qword_1009FB180, &stru_1009A2A48);
  }
  uint64_t v10 = qword_1009FB178;

  sub_1002C3024(v10, a1, a2, a3, a4, a5);
}

void sub_1002BA1B0()
{
}

void sub_1002BA288(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
}

uint64_t sub_1002BA2D0(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  if (qword_1009FB120 != -1) {
    dispatch_once(&qword_1009FB120, &stru_1009A2AC8);
  }
  sub_10062ECC4((uint64_t)off_1009FB118, v1 + 24);

  return sub_1002BA33C(v1);
}

uint64_t sub_1002BA33C(uint64_t a1)
{
  sub_10003FB34();
  if (sub_1003542E4())
  {
    uint64_t v2 = (void (***)(void))sub_100373254();
    uint64_t v3 = (**v2)(v2);
  }
  else
  {
    if (qword_1009FB120 != -1) {
      dispatch_once(&qword_1009FB120, &stru_1009A2AC8);
    }
    uint64_t v3 = sub_10062F15C((uint64_t)off_1009FB118);
  }
  uint64_t v4 = (void *)v3;
  uint64_t v6 = *(void **)(a1 + 64);
  int v5 = (id *)(a1 + 64);
  unsigned int v7 = [v6 isEqualToString:v3];
  if ((v7 & 1) == 0)
  {
    objc_storeStrong(v5, v4);
    uint64_t v8 = qword_100A19EA0;
    if (os_log_type_enabled((os_log_t)qword_100A19EA0, OS_LOG_TYPE_DEFAULT))
    {
      id v9 = *v5;
      int v11 = 138543362;
      id v12 = v9;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "Updated country code: %{public}@", (uint8_t *)&v11, 0xCu);
    }
  }

  return v7 ^ 1;
}

void sub_1002BA4A0(_Unwind_Exception *exception_object)
{
}

void sub_1002BA4B8(uint64_t a1)
{
}

void sub_1002BA4C0(uint64_t a1)
{
  uint64_t v2 = qword_100A19EA0;
  if (os_log_type_enabled((os_log_t)qword_100A19EA0, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "ScalablePipe::stackWillStop enter", buf, 2u);
  }
  uint64_t v3 = sub_1004AFA9C();
  v9[0] = _NSConcreteStackBlock;
  v9[1] = 3221225472;
  void v9[2] = sub_1002BA64C;
  void v9[3] = &unk_100997528;
  void v9[4] = a1;
  sub_1000197D8(v3, v9);
  uint64_t v4 = sub_100373254();
  (*(void (**)(uint64_t, uint64_t))(*(void *)v4 + 40))(v4, a1 + 40);
  uint64_t v5 = sub_10003FFD4();
  sub_1002C4188(v5 + 368, a1 + 16);
  uint64_t v6 = sub_100019878();
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 3221225472;
  void v8[2] = sub_1002BA6B0;
  void v8[3] = &unk_100997528;
  void v8[4] = a1;
  sub_1000197D8(v6, v8);
  unsigned int v7 = qword_100A19EA0;
  if (os_log_type_enabled((os_log_t)qword_100A19EA0, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "ScalablePipe::stackWillStop exit", buf, 2u);
  }
}

void sub_1002BA64C(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  if (qword_1009FB120 != -1) {
    dispatch_once(&qword_1009FB120, &stru_1009A2AC8);
  }
  uint64_t v2 = off_1009FB118;

  sub_10062ED9C((uint64_t)v2, v1 + 24);
}