void sub_1007043EC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27)
{
  uint64_t v27;

  if (*(char *)(v27 - 97) < 0) {
    operator delete(*(void **)(v27 - 120));
  }
  _Unwind_Resume(exception_object);
}

void sub_10070445C(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  v2 = qword_100A19E80;
  if (os_log_type_enabled((os_log_t)qword_100A19E80, OS_LOG_TYPE_DEFAULT))
  {
    v5[0] = 67109120;
    v5[1] = MKBDeviceUnlockedSinceBoot();
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Received MKB first unlock notification. MKBDeviceUnlockedSinceBoot returns : %d", (uint8_t *)v5, 8u);
  }
  int v3 = MKBDeviceUnlockedSinceBoot();
  v4 = qword_100A19E80;
  if (v3 != 1 && os_log_type_enabled((os_log_t)qword_100A19E80, OS_LOG_TYPE_FAULT))
  {
    LOWORD(v5[0]) = 0;
    _os_log_fault_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_FAULT, "Received MKB first unlock notification, but MKBDeviceUnlockedSinceBoot returns 0", (uint8_t *)v5, 2u);
    v4 = qword_100A19E80;
  }
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v5[0]) = 0;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Received first unlock notification - loading keychain from synchronized again", (uint8_t *)v5, 2u);
  }
  sub_1007037E0(v1);
}

void sub_10070459C(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  v2 = qword_100A19E80;
  if (os_log_type_enabled((os_log_t)qword_100A19E80, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)int v3 = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Received setup done - loading keychain from synchrnized again", v3, 2u);
  }
  sub_1007037E0(v1);
}

void sub_100704610(uint64_t a1)
{
  bzero((void *)(a1 + 597), 0xC30uLL);
  v11 = 0;
  v12 = 0;
  uint64_t v13 = 0;
  v2 = (void (***)(void, uint64_t **))sub_100370758();
  (**v2)(v2, &v11);
  int v3 = v11;
  if (v11 == v12) {
    goto LABEL_11;
  }
  do
  {
    uint64_t v4 = *v3;
    v18[0] = 0;
    v18[1] = 0;
    uint64_t v5 = sub_100370758();
    int v6 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, void *))(*(void *)v5 + 96))(v5, v4, 2, v18);
    v7 = qword_100A19E80;
    if (!os_log_type_enabled((os_log_t)qword_100A19E80, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_6;
    }
    sub_100474E18(v4, __p);
    v8 = __p;
    if (v10 < 0) {
      v8 = (void **)__p[0];
    }
    *(_DWORD *)buf = 136446466;
    v15 = v8;
    __int16 v16 = 1024;
    int v17 = v6;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "Read IRK for device %{public}s : result %d", buf, 0x12u);
    if ((v10 & 0x80000000) == 0)
    {
LABEL_6:
      if (v6) {
        goto LABEL_9;
      }
LABEL_7:
      LOBYTE(__p[0]) = 0;
      *(_DWORD *)((char *)__p + 1) = *(_DWORD *)(v4 + 128);
      *(_WORD *)((char *)__p + 5) = *(_WORD *)(v4 + 132);
      sub_1007071C4(a1, (unsigned __int8 *)__p, (uint64_t)v18);
      goto LABEL_9;
    }
    operator delete(__p[0]);
    if (!v6) {
      goto LABEL_7;
    }
LABEL_9:
    ++v3;
  }
  while (v3 != v12);
  int v3 = v11;
LABEL_11:
  if (v3)
  {
    v12 = v3;
    operator delete(v3);
  }
}

void sub_100704808(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100704830(uint64_t a1)
{
  uint64_t v2 = sub_100035F54();
  unsigned __int8 v3 = (*(uint64_t (**)(uint64_t))(*(void *)v2 + 80))(v2);
  v60[0] = 0;
  v60[1] = 0;
  sub_10003AED0((uint64_t)v60, a1 + 48);
  char v59 = 0;
  sub_10001B8E0(&v59);
  if (!sub_10022A2F0()) {
    goto LABEL_125;
  }
  if (sub_10023F1E0((long long *)(a1 + 136), (__n128 *)(a1 + 184), (long long *)(a1 + 168), (long long *)(a1 + 200), (__n128 *)(a1 + 224)))
  {
    if (os_log_type_enabled((os_log_t)qword_100A19E80, OS_LOG_TYPE_ERROR)) {
      sub_100797958();
    }
    goto LABEL_125;
  }
  *(_OWORD *)(a1 + 184) = *sub_100240528();
  char v58 = 0;
  uint64_t v4 = sub_100017768();
  sub_10004191C(buf, "LE");
  sub_10004191C(__p, "ForceBoolIOCaps");
  int v5 = (*(uint64_t (**)(uint64_t, uint8_t *, void **, char *))(*(void *)v4 + 72))(v4, buf, __p, &v58);
  if (v58) {
    int v6 = v5;
  }
  else {
    int v6 = 0;
  }
  if (v57 < 0) {
    operator delete(__p[0]);
  }
  if (v62 < 0) {
    operator delete(*(void **)buf);
  }
  if (v6)
  {
    v7 = qword_100A19E80;
    if (os_log_type_enabled((os_log_t)qword_100A19E80, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      unsigned __int8 v3 = 2;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "Warning: Overriding LE security IO capabilities to YES/NO only - DEPRECATED - please move to modern defaults writes", buf, 2u);
    }
    else
    {
      unsigned __int8 v3 = 2;
    }
  }
  int v55 = 0;
  uint64_t v8 = sub_100017768();
  sub_10004191C(buf, "LE");
  sub_10004191C(__p, "InputCaps");
  int v9 = (*(uint64_t (**)(uint64_t, uint8_t *, void **, int *))(*(void *)v8 + 88))(v8, buf, __p, &v55);
  if (v57 < 0) {
    operator delete(__p[0]);
  }
  if (v62 < 0) {
    operator delete(*(void **)buf);
  }
  if (v9)
  {
    char v10 = qword_100A19E80;
    if (os_log_type_enabled((os_log_t)qword_100A19E80, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 67109120;
      *(_DWORD *)&uint8_t buf[4] = v55;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "Warning: Using override value (0x%02x) for LE input capabilities", buf, 8u);
    }
    unsigned __int8 v3 = v55;
  }
  uint64_t v11 = sub_100017768();
  sub_10004191C(buf, "LE");
  sub_10004191C(__p, "OutputCaps");
  int v12 = (*(uint64_t (**)(uint64_t, uint8_t *, void **, int *))(*(void *)v11 + 88))(v11, buf, __p, &v55);
  if (v57 < 0) {
    operator delete(__p[0]);
  }
  if (v62 < 0)
  {
    operator delete(*(void **)buf);
    if (v12) {
      goto LABEL_28;
    }
LABEL_32:
    unsigned __int8 v14 = 32;
    goto LABEL_33;
  }
  if (!v12) {
    goto LABEL_32;
  }
LABEL_28:
  uint64_t v13 = qword_100A19E80;
  if (os_log_type_enabled((os_log_t)qword_100A19E80, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 67109120;
    *(_DWORD *)&uint8_t buf[4] = v55;
    _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "Warning: Using override value (0x%02x) for LE output capabilities", buf, 8u);
  }
  unsigned __int8 v14 = v55;
LABEL_33:
  char v54 = 0;
  uint64_t v15 = sub_100017768();
  sub_10004191C(buf, "LE");
  sub_10004191C(__p, "DisableSSP");
  int v16 = (*(uint64_t (**)(uint64_t, uint8_t *, void **, char *))(*(void *)v15 + 72))(v15, buf, __p, &v54);
  if (v54) {
    int v17 = v16;
  }
  else {
    int v17 = 0;
  }
  if (v57 < 0) {
    operator delete(__p[0]);
  }
  if (v62 < 0) {
    operator delete(*(void **)buf);
  }
  if (v17)
  {
    v18 = qword_100A19E80;
    if (os_log_type_enabled((os_log_t)qword_100A19E80, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "Warning: LE secured connections disabled by defaults write", buf, 2u);
    }
  }
  char v53 = 0;
  uint64_t v19 = sub_100017768();
  sub_10004191C(buf, "LE");
  sub_10004191C(__p, "DisableH7");
  int v20 = (*(uint64_t (**)(uint64_t, uint8_t *, void **, char *))(*(void *)v19 + 72))(v19, buf, __p, &v53);
  if (v53) {
    int v21 = v20;
  }
  else {
    int v21 = 0;
  }
  if (v57 < 0) {
    operator delete(__p[0]);
  }
  if (v62 < 0)
  {
    operator delete(*(void **)buf);
    if (!v21) {
      goto LABEL_55;
    }
  }
  else if (!v21)
  {
    goto LABEL_55;
  }
  v22 = qword_100A19E80;
  if (os_log_type_enabled((os_log_t)qword_100A19E80, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "Warning: Disabling LE SMP local H7 support!", buf, 2u);
  }
  sub_100240508();
LABEL_55:
  char v52 = 0;
  uint64_t v23 = sub_100017768();
  sub_10004191C(buf, "LE");
  sub_10004191C(__p, "ForceReplyH7");
  int v24 = (*(uint64_t (**)(uint64_t, uint8_t *, void **, char *))(*(void *)v23 + 72))(v23, buf, __p, &v52);
  if (v52) {
    int v25 = v24;
  }
  else {
    int v25 = 0;
  }
  if (v57 < 0) {
    operator delete(__p[0]);
  }
  if (v62 < 0)
  {
    operator delete(*(void **)buf);
    if (!v25) {
      goto LABEL_67;
    }
  }
  else if (!v25)
  {
    goto LABEL_67;
  }
  v26 = qword_100A19E80;
  if (os_log_type_enabled((os_log_t)qword_100A19E80, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "Warning: Forcing LE SMP to reply with H7!", buf, 2u);
  }
  sub_100240518();
LABEL_67:
  uint64_t v27 = sub_100017768();
  sub_10004191C(buf, "LE");
  sub_10004191C(__p, "OverrideMaxLEPairedDevices");
  int v28 = (*(uint64_t (**)(uint64_t, uint8_t *, void **, int *))(*(void *)v27 + 88))(v27, buf, __p, &v55);
  if (v55 > 0) {
    int v29 = v28;
  }
  else {
    int v29 = 0;
  }
  if (v57 < 0) {
    operator delete(__p[0]);
  }
  if (v62 < 0) {
    operator delete(*(void **)buf);
  }
  if (v29)
  {
    v30 = qword_100A19E80;
    BOOL v31 = os_log_type_enabled((os_log_t)qword_100A19E80, OS_LOG_TYPE_DEFAULT);
    __int16 v32 = v55;
    if (v31)
    {
      *(_DWORD *)buf = 67109120;
      *(_DWORD *)&uint8_t buf[4] = v55;
      _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_DEFAULT, "Warning: Overriding max number of allowed LE Paired devices to %d", buf, 8u);
      __int16 v32 = v55;
    }
    *(_WORD *)(a1 + 3736) = v32;
  }
  uint64_t v33 = sub_100017768();
  sub_10004191C(buf, "LE");
  sub_10004191C(__p, "OverrideInitiatorKeys");
  int v34 = (*(uint64_t (**)(uint64_t, uint8_t *, void **, int *))(*(void *)v33 + 88))(v33, buf, __p, &v55);
  if (v55 > 0) {
    int v35 = v34;
  }
  else {
    int v35 = 0;
  }
  if (v57 < 0) {
    operator delete(__p[0]);
  }
  if (v62 < 0)
  {
    operator delete(*(void **)buf);
    if (!v35) {
      goto LABEL_90;
    }
  }
  else if (!v35)
  {
    goto LABEL_90;
  }
  v36 = qword_100A19E80;
  BOOL v37 = os_log_type_enabled((os_log_t)qword_100A19E80, OS_LOG_TYPE_DEFAULT);
  unsigned __int8 v38 = v55;
  if (v37)
  {
    *(_DWORD *)buf = 67109120;
    *(_DWORD *)&uint8_t buf[4] = v55;
    _os_log_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_DEFAULT, "Warning: Overriding initiator keys to 0x%0x", buf, 8u);
    unsigned __int8 v38 = v55;
  }
  sub_1002404D4(v38);
LABEL_90:
  uint64_t v39 = sub_100017768();
  sub_10004191C(buf, "LE");
  sub_10004191C(__p, "OverrideResponderKeys");
  int v40 = (*(uint64_t (**)(uint64_t, uint8_t *, void **, int *))(*(void *)v39 + 88))(v39, buf, __p, &v55);
  if (v55 > 0) {
    int v41 = v40;
  }
  else {
    int v41 = 0;
  }
  if (v57 < 0) {
    operator delete(__p[0]);
  }
  if (v62 < 0)
  {
    operator delete(*(void **)buf);
    if (!v41) {
      goto LABEL_102;
    }
  }
  else if (!v41)
  {
    goto LABEL_102;
  }
  v42 = qword_100A19E80;
  BOOL v43 = os_log_type_enabled((os_log_t)qword_100A19E80, OS_LOG_TYPE_DEFAULT);
  unsigned __int8 v44 = v55;
  if (v43)
  {
    *(_DWORD *)buf = 67109120;
    *(_DWORD *)&uint8_t buf[4] = v55;
    _os_log_impl((void *)&_mh_execute_header, v42, OS_LOG_TYPE_DEFAULT, "Warning: Overriding responder keys to 0x%0x", buf, 8u);
    unsigned __int8 v44 = v55;
  }
  sub_1002404EC(v44);
LABEL_102:
  uint64_t v45 = sub_100017768();
  sub_10004191C(buf, "LE");
  sub_10004191C(__p, "OverrideUsePublicAddress");
  int v46 = (*(uint64_t (**)(uint64_t, uint8_t *, void **, int *))(*(void *)v45 + 88))(v45, buf, __p, &v55);
  if (v57 < 0) {
    operator delete(__p[0]);
  }
  if (v62 < 0)
  {
    operator delete(*(void **)buf);
    if (!v46) {
      goto LABEL_111;
    }
LABEL_108:
    v47 = qword_100A19E80;
    if (os_log_type_enabled((os_log_t)qword_100A19E80, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 67109120;
      *(_DWORD *)&uint8_t buf[4] = v55;
      _os_log_impl((void *)&_mh_execute_header, v47, OS_LOG_TYPE_DEFAULT, "Warning: Overriding use Public Address to %d", buf, 8u);
    }
    sub_1002404E0((_BYTE)v55 != 0);
    goto LABEL_111;
  }
  if (v46) {
    goto LABEL_108;
  }
LABEL_111:
  qword_1009FBF20 = a1;
  if (sub_100233C80(off_1009FBF08, v3, v14, v54 == 0, 0))
  {
    if (os_log_type_enabled((os_log_t)qword_100A19E80, OS_LOG_TYPE_ERROR)) {
      sub_1007978F0();
    }
  }
  else
  {
    qword_1009FBF40 = a1;
    sub_100233FC4((uint64_t)off_1009FBF28);
    if (v48)
    {
      if (os_log_type_enabled((os_log_t)qword_100A19E80, OS_LOG_TYPE_ERROR)) {
        sub_100797888();
      }
    }
    else
    {
      qword_1009FBF58 = a1;
      sub_10023413C((__n128 *)off_1009FBF48);
      if (v49)
      {
        if (os_log_type_enabled((os_log_t)qword_100A19E80, OS_LOG_TYPE_ERROR)) {
          sub_100797820();
        }
      }
      else if (sub_100229074(1))
      {
        if (os_log_type_enabled((os_log_t)qword_100A19E80, OS_LOG_TYPE_ERROR)) {
          sub_1007977B8();
        }
      }
      else
      {
        sub_10001B910(&v59);
        *(unsigned char *)(a1 + 41) = 1;
        v50 = qword_100A19E80;
        if (os_log_type_enabled((os_log_t)qword_100A19E80, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v50, OS_LOG_TYPE_DEFAULT, "LESecurityManager stackDidStart", buf, 2u);
        }
      }
    }
  }
LABEL_125:
  sub_10001B8AC(&v59);
  return sub_10003AFB4((uint64_t)v60);
}

void sub_1007053B8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, int a17, __int16 a18, char a19, char a20,char a21,uint64_t a22,void *a23,uint64_t a24,int a25,__int16 a26,char a27,char a28)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  if (a28 < 0) {
    operator delete(a23);
  }
  sub_10001B8AC(&a20);
  sub_10003AFB4((uint64_t)&a21);
  _Unwind_Resume(a1);
}

void sub_100705498(uint64_t a1, void *a2, int a3)
{
  id v5 = a2;
  uint64_t v6 = sub_100019878();
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 3221225472;
  v8[2] = sub_10070556C;
  v8[3] = &unk_100999A10;
  uint64_t v10 = a1;
  id v7 = v5;
  id v9 = v7;
  int v11 = a3;
  sub_100013018(v6, v8);
}

void sub_10070554C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{
  _Unwind_Resume(a1);
}

void sub_10070556C(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 40);
  if ([*(id *)(v2 + 3752) containsObject:*(void *)(a1 + 32)])
  {
    unsigned __int8 v3 = qword_100A19E80;
    if (os_log_type_enabled((os_log_t)qword_100A19E80, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v4 = *(void *)(a1 + 32);
      *(_DWORD *)buf = 138543362;
      *(void *)&uint8_t buf[4] = v4;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Device %{public}@ was pending BMS unpairing but got disconnected, lets complete unpairing", buf, 0xCu);
    }
    [*(id *)(v2 + 3752) removeObject:*(void *)(a1 + 32)];
    sub_1007057D4(v2, *(void **)(a1 + 32), 0);
  }
  else
  {
    int v5 = *(_DWORD *)(a1 + 48);
    if (v5 == 182 || v5 == 179)
    {
      memset(buf, 0, sizeof(buf));
      uint64_t v16 = 0;
      if (qword_1009F7EE0 != -1) {
        dispatch_once(&qword_1009F7EE0, &stru_1009BFD48);
      }
      sub_1006BE7F4((uint64_t)off_1009F7ED8, *(void **)(a1 + 32), (uint64_t)buf);
      uint64_t v6 = HIBYTE(v16);
      int v7 = SHIBYTE(v16);
      if (v16 < 0) {
        uint64_t v6 = *(void *)&buf[8];
      }
      if (v6)
      {
        uint64_t v8 = qword_100A19E60;
        if (os_log_type_enabled((os_log_t)qword_100A19E60, OS_LOG_TYPE_DEFAULT))
        {
          id v9 = *(uint8_t **)buf;
          if (v7 >= 0) {
            id v9 = buf;
          }
          *(_DWORD *)uint64_t v13 = 136446210;
          unsigned __int8 v14 = v9;
          _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "Bad or missing keys, re-cloud pairing for device %{public}s", v13, 0xCu);
        }
        uint64_t v10 = sub_100373114();
        if (SHIBYTE(v16) < 0)
        {
          sub_10003B098(__p, *(void **)buf, *(unint64_t *)&buf[8]);
        }
        else
        {
          *(_OWORD *)__p = *(_OWORD *)buf;
          uint64_t v12 = v16;
        }
        (*(void (**)(uint64_t, void **))(*(void *)v10 + 56))(v10, __p);
        if (SHIBYTE(v12) < 0) {
          operator delete(__p[0]);
        }
      }
      if (SHIBYTE(v16) < 0) {
        operator delete(*(void **)buf);
      }
    }
  }
}

void sub_100705798(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if (a23 < 0) {
    operator delete(a18);
  }
  _Unwind_Resume(exception_object);
}

void sub_1007057D4(uint64_t a1, void *a2, int a3)
{
  id v5 = a2;
  uint64_t v6 = *(uint64_t **)(a1 + 568);
  for (i = *(uint64_t **)(a1 + 576); v6 != i; ++v6)
  {
    uint64_t v8 = *v6;
    uint64_t v9 = sub_100019878();
    v21[0] = _NSConcreteStackBlock;
    v21[1] = 3221225472;
    v21[2] = sub_10070DAD0;
    v21[3] = &unk_100998A38;
    uint64_t v23 = v8;
    id v22 = v5;
    sub_100013018(v9, v21);
  }
  if (qword_1009F7EE0 != -1) {
    dispatch_once(&qword_1009F7EE0, &stru_1009BFD48);
  }
  uint64_t v10 = off_1009F7ED8;
  sub_10004191C(__p, "PrivateModeDevice");
  int v11 = sub_100030A04((uint64_t)v10, v5, (uint64_t)__p);
  int v12 = v11;
  if (v20 < 0)
  {
    operator delete(__p[0]);
    if (!v12) {
      goto LABEL_14;
    }
  }
  else if (!v11)
  {
    goto LABEL_14;
  }
  uint64_t v13 = qword_100A19E80;
  BOOL v14 = os_log_type_enabled((os_log_t)qword_100A19E80, OS_LOG_TYPE_DEFAULT);
  if (v14)
  {
    *(_WORD *)buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "Device being unpaired is tagged with private mode. Restart rotation of random address", buf, 2u);
  }
  *(_WORD *)(a1 + 594) = 0;
  sub_10070D958(v14, 0);
  if (qword_1009F7EE0 != -1) {
    dispatch_once(&qword_1009F7EE0, &stru_1009BFD48);
  }
  sub_1006B85C0((uint64_t)off_1009F7ED8, v5, @"PrivateModeDevice");
LABEL_14:
  if (a3)
  {
    if (qword_1009F7EC0 != -1) {
      dispatch_once(&qword_1009F7EC0, &stru_1009BFD68);
    }
    uint64_t v15 = off_1009F7EB8;
    sub_1000305AC(buf, v5);
    sub_100683CFC((uint64_t)v15, buf, 5u);
    uint64_t v16 = sub_100019878();
    v17[0] = _NSConcreteStackBlock;
    v17[1] = 3221225472;
    v17[2] = sub_10070DAFC;
    v17[3] = &unk_100997450;
    id v18 = v5;
    sub_100013018(v16, v17);
  }
}

void sub_100705A9C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24)
{
  _Unwind_Resume(a1);
}

void sub_100705AF4(uint64_t a1, void *a2, int a3)
{
}

void sub_100705AFC(uint64_t a1, void *a2, uint64_t a3)
{
  id v5 = a2;
  uint64_t v6 = qword_100A19E80;
  if (os_log_type_enabled((os_log_t)qword_100A19E80, OS_LOG_TYPE_DEFAULT))
  {
    int v7 = 138543618;
    id v8 = v5;
    __int16 v9 = 1024;
    int v10 = a3;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "Device %{public}@ disconnected without link ready with result: %d", (uint8_t *)&v7, 0x12u);
  }
  (*(void (**)(uint64_t, id, uint64_t))(*(void *)a1 + 64))(a1, v5, a3);
}

void sub_100705BF4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100705C0C(uint64_t a1, void *a2, uint64_t a3)
{
}

uint64_t sub_100705C14(uint64_t a1)
{
  uint64_t v2 = qword_100A19E80;
  if (os_log_type_enabled((os_log_t)qword_100A19E80, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "LeSecurityManager::stackWillStop enter", buf, 2u);
  }
  *(void *)buf = 0;
  uint64_t v17 = 0;
  sub_10003AED0((uint64_t)buf, a1 + 48);
  char v15 = 0;
  sub_10001B8E0(&v15);
  if (sub_10022A2F0())
  {
    long long v13 = 0u;
    long long v14 = 0u;
    long long v11 = 0u;
    long long v12 = 0u;
    id v3 = *(id *)(a1 + 3752);
    id v4 = [v3 countByEnumeratingWithState:&v11 objects:v18 count:16];
    if (v4)
    {
      uint64_t v5 = *(void *)v12;
      do
      {
        uint64_t v6 = 0;
        do
        {
          if (*(void *)v12 != v5) {
            objc_enumerationMutation(v3);
          }
          id v7 = *(id *)(*((void *)&v11 + 1) + 8 * (void)v6);
          sub_1007057D4(a1, v7, 0);

          uint64_t v6 = (char *)v6 + 1;
        }
        while (v4 != v6);
        id v4 = [v3 countByEnumeratingWithState:&v11 objects:v18 count:16];
      }
      while (v4);
    }

    [*(id *)(a1 + 3752) removeAllObjects];
    sub_1002341F8(off_1009FBF48);
    sub_100234070((uint64_t)off_1009FBF28);
    sub_100233EB8((uint64_t)off_1009FBF08);
    sub_100229074(0);
    sub_10001B910(&v15);
    *(unsigned char *)(a1 + 41) = 0;
    [*(id *)(a1 + 3728) removeAllObjects];
    sub_10071AF54(a1 + 464, *(void **)(a1 + 472));
    *(void *)(a1 + 472) = 0;
    *(void *)(a1 + 480) = 0;
    *(void *)(a1 + 464) = a1 + 472;
    sub_10071AF54(a1 + 488, *(void **)(a1 + 496));
    *(void *)(a1 + 496) = 0;
    *(void *)(a1 + 504) = 0;
    *(void *)(a1 + 488) = a1 + 496;
    sub_10071AF54(a1 + 512, *(void **)(a1 + 520));
    *(void *)(a1 + 512) = a1 + 520;
    *(void *)(a1 + 528) = 0;
    *(void *)(a1 + 520) = 0;
    id v8 = qword_100A19E80;
    if (os_log_type_enabled((os_log_t)qword_100A19E80, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)int v10 = 0;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "LeSecurityManager::stackWillStop exit", v10, 2u);
    }
  }
  sub_10001B8AC(&v15);
  return sub_10003AFB4((uint64_t)buf);
}

void sub_100705E6C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, int a20,__int16 a21,char a22,char a23,char a24)
{
  sub_10001B8AC(&a23);
  sub_10003AFB4((uint64_t)&a24);
  _Unwind_Resume(a1);
}

void sub_100705EB8(uint64_t a1, unsigned __int8 *a2)
{
  id v4 = (void *)(((unint64_t)a2[1] << 40) | ((unint64_t)a2[2] << 32) | ((unint64_t)a2[3] << 24) | ((unint64_t)a2[4] << 16) | ((unint64_t)a2[5] << 8) | a2[6] | ((unint64_t)*a2 << 48));
  uint64_t v5 = qword_100A19E80;
  if (os_log_type_enabled((os_log_t)qword_100A19E80, OS_LOG_TYPE_DEFAULT))
  {
    sub_10004BDF8();
    uint64_t v6 = (SBYTE7(v86) & 0x80u) == 0 ? dst : *(unsigned __int8 **)dst;
    *(_DWORD *)buf = 136446210;
    v76 = v6;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "Deriving key for device %{public}s", buf, 0xCu);
    if (SBYTE7(v86) < 0) {
      operator delete(*(void **)dst);
    }
  }
  v73 = &off_1009B4578;
  v74 = 0;
  id v7 = *(const unsigned __int8 **)(a1 + 440);
  if (v7 != (const unsigned __int8 *)(a1 + 448))
  {
    char v8 = 0;
    while (1)
    {
      sub_100049EE0((uint64_t)&v73, (uint64_t)(v7 + 48));
      memset(dst, 0, sizeof(dst));
      uuid_copy(dst, v7 + 32);
      if (qword_1009F7EE0 != -1) {
        dispatch_once(&qword_1009F7EE0, &stru_1009BFD48);
      }
      __int16 v9 = off_1009F7ED8;
      int v10 = sub_100031234(dst);
      uint64_t v11 = sub_100030DCC((uint64_t)v9, v10, 0);

      if (v4 == (void *)v11) {
        break;
      }
      long long v12 = (unsigned __int8 *)*((void *)v7 + 1);
      if (v12)
      {
        do
        {
          long long v13 = (const unsigned __int8 **)v12;
          long long v12 = *(unsigned __int8 **)v12;
        }
        while (v12);
      }
      else
      {
        do
        {
          long long v13 = (const unsigned __int8 **)*((void *)v7 + 2);
          BOOL v14 = *v13 == v7;
          id v7 = (const unsigned __int8 *)v13;
        }
        while (!v14);
      }
      v8 |= v4 == (void *)v11;
      id v7 = (const unsigned __int8 *)v13;
      if (v13 == (const unsigned __int8 **)(a1 + 448))
      {
        if ((v8 & 1) == 0) {
          goto LABEL_23;
        }
        break;
      }
    }
    char v72 = 0;
    sub_10001B8E0(&v72);
    uint64_t v15 = sub_100197B34(a2);
    sub_10001B910(&v72);
    memset(uu, 0, sizeof(uu));
    uuid_clear(uu);
    if (v15)
    {
      if (qword_1009F7EC0 != -1) {
        dispatch_once(&qword_1009F7EC0, &stru_1009BFD68);
      }
      sub_10067F618((uint64_t)off_1009F7EB8, v15, uu);
    }
    else
    {
      if (qword_1009F7EE0 != -1) {
        dispatch_once(&qword_1009F7EE0, &stru_1009BFD48);
      }
      sub_100014B58((uint64_t)off_1009F7ED8, ((unint64_t)a2[1] << 40) | ((unint64_t)a2[2] << 32) | ((unint64_t)a2[3] << 24) | ((unint64_t)a2[4] << 16) | ((unint64_t)a2[5] << 8) | a2[6] | ((unint64_t)*a2 << 48), 0, 1u, 0, 0, dst);
      uuid_copy(uu, dst);
    }
    if (uuid_is_null(uu))
    {
LABEL_33:
      v70 = 0;
      v71 = 0;
      sub_1003BC0D4((uint64_t)v74, 16, &v70);
      BOOL v18 = sub_100013DCC((uint64_t)&v70);
      if (qword_1009F7EE0 != -1) {
        dispatch_once(&qword_1009F7EE0, &stru_1009BFD48);
      }
      uint64_t v19 = off_1009F7ED8;
      char v20 = sub_100031234(uu);
      int v21 = (void *)sub_1006BDD68((uint64_t)v19, v20);

      int v22 = !v18;
      uint64_t v23 = qword_100A19E80;
      if (os_log_type_enabled((os_log_t)qword_100A19E80, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)uuid_t dst = 67109376;
        *(_DWORD *)&dst[4] = v21;
        *(_WORD *)&dst[8] = 1024;
        *(_DWORD *)&dst[10] = v22;
        _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "hasTS:%d hasLKLTK:%d", dst, 0xEu);
      }
      if (((v22 | v21) & 1) == 0)
      {
        int v29 = qword_100A19E80;
        if (os_log_type_enabled((os_log_t)qword_100A19E80, OS_LOG_TYPE_DEFAULT))
        {
          sub_10004BDF8();
          v30 = (SBYTE7(v86) & 0x80u) == 0 ? dst : *(unsigned __int8 **)dst;
          *(_DWORD *)buf = 136446210;
          v76 = v30;
          _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEFAULT, "Device %{public}s is not an ï£¿Watch and does not have the LKLTK bit set, will not derive a link key for it.", buf, 0xCu);
          if (SBYTE7(v86) < 0) {
            operator delete(*(void **)dst);
          }
        }
        goto LABEL_67;
      }
      int v90 = 0;
      long long v88 = 0u;
      long long v89 = 0u;
      long long v86 = 0u;
      long long v87 = 0u;
      *(_OWORD *)uuid_t dst = 0u;
      unsigned __int8 v69 = 0;
      long long v84 = 0uLL;
      __n128 v82 = 0uLL;
      int v83 = 0;
      sub_100600E3C((uint64_t)&v82);
      sub_1007030D4(a1, (uint64_t)&v73, dst);
      char v68 = 0;
      sub_10001B8E0(&v68);
      int v24 = sub_100234B18(&v84, &v69, (uint64_t)dst);
      sub_10001B910(&v68);
      if (v24 || (v69 & 0xFE) != 2)
      {
        int v34 = qword_100A19E80;
        if (os_log_type_enabled((os_log_t)qword_100A19E80, OS_LOG_TYPE_ERROR))
        {
          sub_10004BDF8();
          char v53 = v59 >= 0 ? &v58 : (void **)v58;
          *(_DWORD *)buf = 136446722;
          v76 = v53;
          __int16 v77 = 1024;
          int v78 = v24;
          __int16 v79 = 1024;
          int v80 = v69;
          _os_log_error_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_ERROR, "LE_Security_DeriveLinkKeyForAddress %{public}s with result %{bluetooth:OI_STATUS}u ltkType=%d ", buf, 0x18u);
          if (v59 < 0) {
            operator delete(v58);
          }
        }
        goto LABEL_66;
      }
      if (v69 != 3)
      {
        if (v69 != 2)
        {
          char v52 = qword_100A19E80;
          if (os_log_type_enabled((os_log_t)qword_100A19E80, OS_LOG_TYPE_FAULT))
          {
            *(_WORD *)buf = 0;
            _os_log_fault_impl((void *)&_mh_execute_header, v52, OS_LOG_TYPE_FAULT, "Unknown LTK Type - aborting\n", buf, 2u);
            char v52 = qword_100A19E80;
          }
          if (os_log_type_enabled(v52, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 67109120;
            LODWORD(v76) = v69;
            _os_log_error_impl((void *)&_mh_execute_header, v52, OS_LOG_TYPE_ERROR, "Unknown LTK Type (%d) - aborting", buf, 8u);
            char v52 = qword_100A19E80;
          }
          if (os_log_type_enabled(v52, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)buf = 0;
            _os_log_impl((void *)&_mh_execute_header, v52, OS_LOG_TYPE_DEFAULT, "LinkKey is not valid", buf, 2u);
          }
          goto LABEL_66;
        }
        uint64_t v25 = sub_100035F54();
        char v26 = (*(uint64_t (**)(uint64_t))(*(void *)v25 + 344))(v25);
        if (v26) {
          goto LABEL_46;
        }
        if (qword_1009F7EE0 != -1) {
          dispatch_once(&qword_1009F7EE0, &stru_1009BFD48);
        }
        int v21 = off_1009F7ED8;
        id v4 = sub_100031234(uu);
        sub_10004191C(__p, "IsAppleWatch");
        if (sub_100030A04((uint64_t)v21, v4, (uint64_t)__p))
        {
LABEL_46:
          int v27 = 0;
        }
        else
        {
          if (qword_1009F7EE0 != -1) {
            dispatch_once(&qword_1009F7EE0, &stru_1009BFD48);
          }
          char v54 = off_1009F7ED8;
          int v21 = sub_100031234(uu);
          if (!sub_1006BDD68((uint64_t)v54, v21))
          {
            unsigned int v28 = 4;
            int v27 = 1;
            goto LABEL_48;
          }
          int v27 = 1;
        }
        unsigned int v28 = 7;
LABEL_48:
        sub_100600E5C((uint64_t)buf, &v84, v28);
        sub_100600E48(&v82, (__n128 *)buf);
        nullsub_95(buf);
        if (v27) {

        }
        if ((v26 & 1) == 0)
        {
          if (v67 < 0) {
            operator delete(__p[0]);
          }
        }
LABEL_91:
        int v40 = qword_100A19E80;
        if (os_log_type_enabled((os_log_t)qword_100A19E80, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v40, OS_LOG_TYPE_DEFAULT, "Calling PairingManager::getInstance()->leDevicePaired", buf, 2u);
        }
        if (qword_1009F8768 != -1) {
          dispatch_once(&qword_1009F8768, &stru_1009BFD88);
        }
        int v41 = off_1009F8760;
        uint64_t v57 = a2[1];
        uint64_t v42 = a2[2];
        uint64_t v43 = a2[3];
        uint64_t v44 = a2[4];
        uint64_t v45 = a2[5];
        uint64_t v46 = a2[6];
        uint64_t v47 = *a2;
        sub_100600E48(&v81, &v82);
        uint64_t v56 = (uint64_t)v41;
        if (qword_1009F7EE0 != -1) {
          dispatch_once(&qword_1009F7EE0, &stru_1009BFD48);
        }
        int v48 = off_1009F7ED8;
        int v49 = sub_100031234(uu);
        sub_10003093C((uint64_t)v48, v49, (uint64_t)v62);
        sub_100610604(v56, (v57 << 40) | (v42 << 32) | (v43 << 24) | (v44 << 16) | (v45 << 8) | v46 | (v47 << 48), &v81, (uint64_t)v62);
        if (v63 < 0) {
          operator delete(v62[0]);
        }

        nullsub_95(&v81);
        if (qword_1009F7EE0 != -1) {
          dispatch_once(&qword_1009F7EE0, &stru_1009BFD48);
        }
        v50 = off_1009F7ED8;
        v51 = sub_100031234(uu);
        sub_10004191C(v60, "_CTKD_");
        sub_1006BC69C((uint64_t)v50, v51, (unsigned __int8 *)v60);
        if (v61 < 0) {
          operator delete(v60[0]);
        }

LABEL_66:
        sub_10001B8AC(&v68);
        nullsub_95(&v82);
LABEL_67:
        v70 = &off_100998428;
        if (v71) {
          sub_1000368F4(v71);
        }
LABEL_74:
        sub_10001B8AC(&v72);
        goto LABEL_75;
      }
      uint64_t v36 = sub_100035F54();
      char v37 = (*(uint64_t (**)(uint64_t))(*(void *)v36 + 344))(v36);
      if (v37) {
        goto LABEL_83;
      }
      if (qword_1009F7EE0 != -1) {
        dispatch_once(&qword_1009F7EE0, &stru_1009BFD48);
      }
      int v21 = off_1009F7ED8;
      id v4 = sub_100031234(uu);
      sub_10004191C(v64, "IsAppleWatch");
      if (sub_100030A04((uint64_t)v21, v4, (uint64_t)v64))
      {
LABEL_83:
        int v38 = 0;
      }
      else
      {
        if (qword_1009F7EE0 != -1) {
          dispatch_once(&qword_1009F7EE0, &stru_1009BFD48);
        }
        int v55 = off_1009F7ED8;
        int v21 = sub_100031234(uu);
        if (!sub_1006BDD68((uint64_t)v55, v21))
        {
          unsigned int v39 = 5;
          int v38 = 1;
          goto LABEL_85;
        }
        int v38 = 1;
      }
      unsigned int v39 = 8;
LABEL_85:
      sub_100600E5C((uint64_t)buf, &v84, v39);
      sub_100600E48(&v82, (__n128 *)buf);
      nullsub_95(buf);
      if (v38) {

      }
      if ((v37 & 1) == 0)
      {
        if (v65 < 0) {
          operator delete(v64[0]);
        }
      }
      goto LABEL_91;
    }
    memset(dst, 0, sizeof(dst));
    *(void *)&long long v86 = 0;
    if (qword_1009F7EE0 != -1) {
      dispatch_once(&qword_1009F7EE0, &stru_1009BFD48);
    }
    BOOL v31 = off_1009F7ED8;
    __int16 v32 = sub_100031234(uu);
    sub_1006BE7F4((uint64_t)v31, v32, (uint64_t)dst);

    char v33 = BYTE7(v86);
    if (SBYTE7(v86) < 0)
    {
      if (!*(void *)&dst[8])
      {
        operator delete(*(void **)dst);
        goto LABEL_33;
      }
    }
    else if (!BYTE7(v86))
    {
      goto LABEL_33;
    }
    int v35 = qword_100A19E80;
    if (os_log_type_enabled((os_log_t)qword_100A19E80, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v35, OS_LOG_TYPE_DEFAULT, "LE_Security_DeriveLinkKeyForAddress not applicable for cloud paired devices", buf, 2u);
      char v33 = BYTE7(v86);
    }
    if (v33 < 0) {
      operator delete(*(void **)dst);
    }
    goto LABEL_74;
  }
LABEL_23:
  uint64_t v16 = qword_100A19E80;
  if (os_log_type_enabled((os_log_t)qword_100A19E80, OS_LOG_TYPE_DEFAULT))
  {
    sub_10004BDF8();
    uint64_t v17 = (SBYTE7(v86) & 0x80u) == 0 ? dst : *(unsigned __int8 **)dst;
    *(_DWORD *)buf = 136446210;
    v76 = v17;
    _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "Could not find keys for device %{public}s", buf, 0xCu);
    if (SBYTE7(v86) < 0) {
      operator delete(*(void **)dst);
    }
  }
LABEL_75:
  v73 = &off_1009B4578;
  if (v74) {
    sub_1000368F4(v74);
  }
}

void sub_100706B34(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,void *__p,uint64_t a28,int a29,__int16 a30,char a31,char a32,void *a33,uint64_t a34,int a35,__int16 a36,char a37,char a38,int a39,__int16 a40,char a41,uint64_t (**a42)(),atomic_uint *a43,int a44,__int16 a45,char a46,char a47,uint64_t a48,atomic_uint *a49,char a50,uint64_t a51,uint64_t a52,uint64_t a53,int a54,char a55,uint64_t a56,uint64_t a57,char a58)
{
  if (a32 < 0) {
    operator delete(__p);
  }

  sub_10001B8AC(&a41);
  nullsub_95(&a58);
  a42 = &off_100998428;
  if (a43) {
    sub_1000368F4(a43);
  }
  sub_10001B8AC(&a47);
  a48 = a11;
  if (a49) {
    sub_1000368F4(a49);
  }
  _Unwind_Resume(a1);
}

void sub_100706D34(uint64_t a1, void *a2, int a3)
{
  id v5 = a2;
  v22[0] = 0;
  v22[1] = 0;
  sub_10003AED0((uint64_t)v22, a1 + 48);
  uint64_t v6 = qword_100A19E80;
  if (os_log_type_enabled((os_log_t)qword_100A19E80, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 138543362;
    *(void *)&uint8_t buf[4] = v5;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "Deriving key for device %{public}@", buf, 0xCu);
  }
  if (qword_1009F7EE0 != -1) {
    dispatch_once(&qword_1009F7EE0, &stru_1009BFD48);
  }
  unint64_t v7 = sub_100030DCC((uint64_t)off_1009F7ED8, v5, 0);
  char v20 = 0;
  int v21 = 0;
  sub_1000305AC(buf, v5);
  BOOL v18 = (uint64_t (**)())buf;
  char v8 = (atomic_uint *)sub_10071B344((uint64_t **)(a1 + 440), buf, (uint64_t)&unk_1007BE9D0, (const unsigned __int8 *__attribute__((__org_typedef(uuid_t))) *)&v18)[7];
  char v20 = &off_1009B4578;
  int v21 = v8;
  if (v8) {
    sub_100037354((uint64_t)v8);
  }
  uint64_t v9 = sub_100035F54();
  if ((((*(unsigned int (**)(uint64_t))(*(void *)v9 + 344))(v9) | a3 ^ 1) & 1) == 0)
  {
    int v10 = qword_100A19E80;
    if (os_log_type_enabled((os_log_t)qword_100A19E80, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 138543362;
      *(void *)&uint8_t buf[4] = v5;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "Switching derivation method for device \"%{public}@\"", buf, 0xCu);
    }
    BOOL v18 = 0;
    uint64_t v19 = 0;
    sub_1003BC0D4((uint64_t)v21, 16, &v18);
    __uuid_t dst = 1;
    if (!sub_100013DCC((uint64_t)&v18)) {
      sub_100052430((uint64_t)&v18, &__dst, 1uLL);
    }
    uint64_t v11 = qword_100A19E80;
    if (os_log_type_enabled((os_log_t)qword_100A19E80, OS_LOG_TYPE_DEFAULT))
    {
      if (__dst == 1) {
        long long v12 = "6";
      }
      else {
        long long v12 = "7";
      }
      *(_DWORD *)buf = 138543618;
      *(void *)&uint8_t buf[4] = v5;
      *(_WORD *)&buf[12] = 2080;
      *(void *)&buf[14] = v12;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "Current key derivation method for device \"%{public}@\" is H%s", buf, 0x16u);
      uint64_t v11 = qword_100A19E80;
    }
    int v13 = __dst;
    if (__dst == 2) {
      char v14 = 1;
    }
    else {
      char v14 = 2;
    }
    __uuid_t dst = v14;
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      if (v13 == 2) {
        uint64_t v15 = "6";
      }
      else {
        uint64_t v15 = "7";
      }
      *(_DWORD *)buf = 138543618;
      *(void *)&uint8_t buf[4] = v5;
      *(_WORD *)&buf[12] = 2080;
      *(void *)&buf[14] = v15;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "New key derivation method for device \"%{public}@\" is H%s", buf, 0x16u);
    }
    uint64_t v16 = v21;
    sub_1000335D8(buf, &__dst, 1uLL);
    sub_1003BB660((uint64_t)v16, 16, (uint64_t)buf);
    *(void *)buf = &off_100998428;
    if (*(void *)&buf[8]) {
      sub_1000368F4(*(atomic_uint **)&buf[8]);
    }
    BOOL v18 = &off_100998428;
    if (v19) {
      sub_1000368F4(v19);
    }
  }
  uint64_t v17 = sub_1002284B8(v7);
  *(_DWORD *)buf = v17;
  buf[6] = BYTE6(v17);
  *(_WORD *)&uint8_t buf[4] = WORD2(v17);
  sub_100705EB8(a1, buf);
  char v20 = &off_1009B4578;
  if (v21) {
    sub_1000368F4(v21);
  }
  sub_10003AFB4((uint64_t)v22);
}

void sub_100707110(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, atomic_uint *a11, uint64_t a12, atomic_uint *a13, char a14, uint64_t a15, uint64_t a16, uint64_t (**a17)(), atomic_uint *a18)
{
  a17 = &off_100998428;
  if (a18) {
    sub_1000368F4(a18);
  }
  if (a11) {
    sub_1000368F4(a11);
  }
  if (a13) {
    sub_1000368F4(a13);
  }
  sub_10003AFB4((uint64_t)&a14);

  _Unwind_Resume(a1);
}

void sub_1007071C4(uint64_t a1, unsigned __int8 *a2, uint64_t a3)
{
  uint64_t v6 = 0;
  for (uint64_t i = 0; i != 130; ++i)
  {
    BOOL v8 = *(_DWORD *)(a1 + v6 + 613) == *(_DWORD *)a2 && *(_DWORD *)(a1 + v6 + 616) == *(_DWORD *)(a2 + 3);
    if (v8 && *(unsigned char *)(a1 + v6 + 620))
    {
      uint64_t v19 = a1 + v6;
      if (*(void *)(v19 + 597) == *(void *)a3 && *(void *)(v19 + 605) == *(void *)(a3 + 8))
      {
        uint64_t v25 = qword_100A19E80;
        if (os_log_type_enabled((os_log_t)qword_100A19E80, OS_LOG_TYPE_ERROR))
        {
          sub_10004BDF8();
          char v26 = v29 >= 0 ? &__p : (void **)__p;
          *(_DWORD *)buf = 136446723;
          BOOL v31 = v26;
          __int16 v32 = 1041;
          int v33 = 16;
          __int16 v34 = 2097;
          uint64_t v35 = a3;
          _os_log_error_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_ERROR, "address %{public}s Incorrect IRK %{private}.16P", buf, 0x1Cu);
          if (v29 < 0) {
            operator delete(__p);
          }
        }
      }
      else
      {
        *(_OWORD *)(v19 + 597) = *(_OWORD *)a3;
        *(unsigned char *)(v19 + 620) = 1;
        if (*(unsigned char *)(a1 + 41))
        {
          sub_10070D770(a1, a2);
          uint64_t v21 = *(void *)sub_10003FB34();
          (*(void (**)(void))(v21 + 376))();
LABEL_22:
          sub_100703C48(a1, (int *)(a1 + 24 * i + 613), (_OWORD *)(a1 + 24 * i + 597));
          unint64_t v22 = ((unint64_t)a2[1] << 40) | ((unint64_t)a2[2] << 32) | ((unint64_t)a2[3] << 24) | ((unint64_t)a2[4] << 16) | ((unint64_t)a2[5] << 8) | a2[6] | ((unint64_t)*a2 << 48);
          uint64_t v23 = *(void *)sub_10003FB34();
          int v24 = (*(uint64_t (**)(void))(v23 + 368))();
          sub_100713998(a1, v22);
          id v27 = (id)objc_claimAutoreleasedReturnValue();
          sub_100703BE0((uint64_t)v27, v27, v24);
        }
      }
      return;
    }
    v6 += 24;
  }
  uint64_t i = 0;
  for (uint64_t j = a1 + 597; *(unsigned char *)(j + 23); j += 24)
  {
    if (++i == 130)
    {
      int v10 = qword_100A19E80;
      if (os_log_type_enabled((os_log_t)qword_100A19E80, OS_LOG_TYPE_ERROR)) {
        sub_1007979C0(v10, v11, v12, v13, v14, v15, v16, v17);
      }
      return;
    }
  }
  int v18 = *(_DWORD *)a2;
  *(_DWORD *)(j + 19) = *(_DWORD *)(a2 + 3);
  *(_DWORD *)(j + 16) = v18;
  *(_OWORD *)uint64_t j = *(_OWORD *)a3;
  *(unsigned char *)(j + 23) = 1;
  if (*(unsigned char *)(a1 + 41)) {
    goto LABEL_22;
  }
}

void sub_10070757C(uint64_t a1)
{
  uint64_t v25 = +[NSMutableDictionary dictionary];
  v30[0] = 0;
  v30[1] = 0;
  sub_10003AED0((uint64_t)v30, a1 + 48);
  int v24 = sub_100312698(0);
  uint64_t v2 = qword_100A19E80;
  if (os_log_type_enabled((os_log_t)qword_100A19E80, OS_LOG_TYPE_DEFAULT))
  {
    id v3 = [v24 count];
    id v4 = [v24 count];
    id v5 = "s";
    if (v4 == (id)1) {
      id v5 = "";
    }
    *(_DWORD *)buf = 134218242;
    *(void *)&uint8_t buf[4] = v3;
    *(_WORD *)&buf[12] = 2082;
    *(void *)&buf[14] = v5;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Found %lu paired LE device%{public}s in local keychain", buf, 0x16u);
  }
  if (qword_1009F7EE0 != -1) {
    dispatch_once(&qword_1009F7EE0, &stru_1009BFD48);
  }
  sub_1006BF590((uint64_t)off_1009F7ED8, v24, 0);
  long long v28 = 0u;
  long long v29 = 0u;
  long long v26 = 0u;
  long long v27 = 0u;
  id v6 = v24;
  id v7 = [v6 countByEnumeratingWithState:&v26 objects:v34 count:16];
  if (v7)
  {
    uint64_t v8 = *(void *)v27;
    do
    {
      uint64_t v9 = 0;
      do
      {
        if (*(void *)v27 != v8) {
          objc_enumerationMutation(v6);
        }
        int v10 = *(void **)(*((void *)&v26 + 1) + 8 * (void)v9);
        uint64_t v12 = [v6 objectForKeyedSubscript:v10];
        id v13 = [v12 unsignedLongLongValue];

        if (sub_100700DE4(a1, (unint64_t)v13, v10))
        {
          *(void *)uuid_t uu = 0;
          uint64_t v33 = 0;
          if (qword_1009F7EE0 != -1) {
            dispatch_once(&qword_1009F7EE0, &stru_1009BFD48);
          }
          sub_100014B58((uint64_t)off_1009F7ED8, (unint64_t)v13, 0, 1u, 0, 0, uu);
          if (!uuid_is_null(uu))
          {
            memset(buf, 0, 24);
            if (qword_1009F7EE0 != -1) {
              dispatch_once(&qword_1009F7EE0, &stru_1009BFD48);
            }
            uint64_t v14 = off_1009F7ED8;
            uint64_t v15 = sub_100031234(uu);
            sub_1006BE7F4((uint64_t)v14, v15, (uint64_t)buf);

            if (((char)buf[23] & 0x80000000) == 0)
            {
              if (!buf[23]) {
                goto LABEL_28;
              }
              uint64_t v16 = buf;
              goto LABEL_26;
            }
            if (*(void *)&buf[8])
            {
              uint64_t v16 = *(uint8_t **)buf;
LABEL_26:
              uint64_t v17 = +[NSString stringWithUTF8String:v16];
              int v18 = sub_100031234(uu);
              [v25 setObject:v17 forKeyedSubscript:v18];

              if (((char)buf[23] & 0x80000000) == 0) {
                goto LABEL_28;
              }
            }
            operator delete(*(void **)buf);
            goto LABEL_28;
          }
          if (uuid_is_null(uu) && os_log_type_enabled((os_log_t)qword_100A19E80, OS_LOG_TYPE_FAULT))
          {
            sub_1006AD3F0();
            objc_claimAutoreleasedReturnValue();
            sub_100797570();
          }
        }
LABEL_28:
        uint64_t v9 = (char *)v9 + 1;
      }
      while (v7 != v9);
      id v7 = [v6 countByEnumeratingWithState:&v26 objects:v34 count:16];
    }
    while (v7);
  }

  int v19 = *(unsigned __int8 *)(a1 + 424);
  char v20 = qword_100A19E80;
  BOOL v21 = os_log_type_enabled((os_log_t)qword_100A19E80, OS_LOG_TYPE_DEFAULT);
  if (v19)
  {
    if (v21)
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "CloudPairing is Enabled", buf, 2u);
    }
    unint64_t v22 = *(void (****)(void, void *))(a1 + 432);
    if (v22) {
      goto LABEL_37;
    }
    uint64_t v23 = qword_100A19E80;
    if (os_log_type_enabled((os_log_t)qword_100A19E80, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "Initialize CloudPairing", buf, 2u);
    }
    unint64_t v22 = (void (***)(void, void *))sub_100373114();
    *(void *)(a1 + 432) = v22;
    if (v22) {
LABEL_37:
    }
      (**v22)(v22, v25);
  }
  else if (v21)
  {
    *(_WORD *)buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "CloudPairing is Disabled", buf, 2u);
  }

  sub_10003AFB4((uint64_t)v30);
}

void sub_100707A3C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, void *a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,char a21,uint64_t a22,void *__p,uint64_t a24,int a25,__int16 a26,char a27,char a28)
{
  sub_10003AFB4((uint64_t)&a21);
  _Unwind_Resume(a1);
}

uint64_t sub_100707AE8(void *a1)
{
  v62[0] = 0;
  v62[1] = 0;
  sub_10003AED0((uint64_t)v62, (uint64_t)(a1 + 6));
  sub_100708480();
  uint64_t v2 = (const unsigned __int8 *)a1[55];
  int v55 = (const unsigned __int8 *)(a1 + 56);
  if (v2 != (const unsigned __int8 *)(a1 + 56))
  {
    do
    {
      *(void *)buf = 0;
      *(void *)&uint8_t buf[8] = 0;
      sub_1003BC0D4(*((void *)v2 + 7), 10, buf);
      if (!sub_100013DCC((uint64_t)buf))
      {
        uint64_t v4 = sub_10003FB34();
        if (qword_1009F7EE0 != -1) {
          dispatch_once(&qword_1009F7EE0, &stru_1009BFD48);
        }
        id v5 = off_1009F7ED8;
        id v6 = sub_100031234(v2 + 32);
        uint64_t v7 = sub_100030DCC((uint64_t)v5, v6, 0);
        uint64_t v8 = sub_10004A6E4((uint64_t)buf);
        int v9 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)v4 + 368))(v4, v7, v8, 1);

        sub_1003BC0D4(*((void *)v2 + 7), 11, dst);
        int v10 = (int *)sub_10004A6E4((uint64_t)dst);
        uint64_t v11 = (_OWORD *)sub_10004A6E4((uint64_t)buf);
        sub_100703C48((uint64_t)a1, v10, v11);
        *(void *)uuid_t dst = &off_100998428;
        if (*(void *)&dst[8]) {
          sub_1000368F4(*(atomic_uint **)&dst[8]);
        }
        uint64_t v12 = sub_100031234(v2 + 32);
        sub_100703BE0((uint64_t)v12, v12, v9);
      }
      *(void *)buf = &off_100998428;
      if (*(void *)&buf[8]) {
        sub_1000368F4(*(atomic_uint **)&buf[8]);
      }
      id v13 = (const unsigned __int8 *)*((void *)v2 + 1);
      if (v13)
      {
        do
        {
          uint64_t v14 = v13;
          id v13 = *(const unsigned __int8 **)v13;
        }
        while (v13);
      }
      else
      {
        do
        {
          uint64_t v14 = (const unsigned __int8 *)*((void *)v2 + 2);
          BOOL v15 = *(void *)v14 == (void)v2;
          uint64_t v2 = v14;
        }
        while (!v15);
      }
      uint64_t v2 = v14;
    }
    while (v14 != v55);
    uint64_t v2 = (const unsigned __int8 *)a1[55];
  }
  if (v2 != v55)
  {
    *(void *)&long long v1 = 138543362;
    long long v53 = v1;
    do
    {
      memset(dst, 0, sizeof(dst));
      uuid_copy(dst, v2 + 32);
      if (qword_1009F7EE0 != -1) {
        dispatch_once(&qword_1009F7EE0, &stru_1009BFD48);
      }
      uint64_t v17 = off_1009F7ED8;
      int v18 = sub_100031234(dst);
      sub_10004191C(__p, "_CTKD_");
      int v19 = sub_100030A04((uint64_t)v17, v18, (uint64_t)__p);
      if (v61 < 0) {
        operator delete(__p[0]);
      }

      if (qword_1009F7EE0 != -1) {
        dispatch_once(&qword_1009F7EE0, &stru_1009BFD48);
      }
      char v20 = off_1009F7ED8;
      BOOL v21 = sub_100031234(dst);
      int v22 = sub_1006BDD68((uint64_t)v20, v21);

      if (qword_1009F7EE0 != -1) {
        dispatch_once(&qword_1009F7EE0, &stru_1009BFD48);
      }
      uint64_t v23 = off_1009F7ED8;
      int v24 = sub_100031234(dst);
      sub_10004191C(v58, "IsAppleWatch");
      int v25 = sub_100030A04((uint64_t)v23, v24, (uint64_t)v58);
      if (v59 < 0) {
        operator delete(v58[0]);
      }

      long long v26 = qword_100A19E80;
      if (os_log_type_enabled((os_log_t)qword_100A19E80, OS_LOG_TYPE_INFO))
      {
        long long v27 = sub_100031234(dst);
        *(_DWORD *)buf = 138544130;
        *(void *)&uint8_t buf[4] = v27;
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = v19;
        *(_WORD *)&buf[18] = 1024;
        *(_DWORD *)&buf[20] = v22;
        *(_WORD *)&buf[24] = 1024;
        *(_DWORD *)&buf[26] = v25;
        _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_INFO, "%{public}@ CTKDTag:%d hasTSTag:%d isAppleWatchTag:%d", buf, 0x1Eu);
      }
      if ((((v22 | v25) ^ 1 | v19) & 1) == 0)
      {
        long long v28 = qword_100A19E80;
        if (os_log_type_enabled((os_log_t)qword_100A19E80, OS_LOG_TYPE_DEFAULT))
        {
          long long v29 = sub_100031234(dst);
          *(_DWORD *)buf = v53;
          *(void *)&uint8_t buf[4] = v29;
          _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, "Upgrading device %{public}@ to the new CTKD derived LK", buf, 0xCu);
        }
        if (qword_1009F7EE0 != -1) {
          dispatch_once(&qword_1009F7EE0, &stru_1009BFD48);
        }
        v30 = off_1009F7ED8;
        BOOL v31 = sub_100031234(dst);
        unint64_t v32 = sub_100030DCC((uint64_t)v30, v31, 0);

        *(_DWORD *)&buf[3] = 0;
        *(_DWORD *)buf = 0;
        uint64_t v33 = sub_1002284B8(v32);
        *(_DWORD *)buf = v33;
        buf[6] = BYTE6(v33);
        *(_WORD *)&uint8_t buf[4] = WORD2(v33);
        sub_100705EB8((uint64_t)a1, buf);
      }
      __int16 v34 = (const unsigned __int8 *)*((void *)v2 + 1);
      if (v34)
      {
        do
        {
          uint64_t v35 = v34;
          __int16 v34 = *(const unsigned __int8 **)v34;
        }
        while (v34);
      }
      else
      {
        do
        {
          uint64_t v35 = (const unsigned __int8 *)*((void *)v2 + 2);
          BOOL v15 = *(void *)v35 == (void)v2;
          uint64_t v2 = v35;
        }
        while (!v15);
      }
      uint64_t v2 = v35;
    }
    while (v35 != v55);
  }
  sub_1002339C8();
  uint64_t v36 = (void *)a1[67];
  if (v36 != a1 + 68)
  {
    do
    {
      char v37 = (const unsigned __int8 *)v36[5];
      if (v37 != (const unsigned __int8 *)(v36 + 6))
      {
        do
        {
          memset(uu, 0, sizeof(uu));
          uuid_copy(uu, v37 + 32);
          if (!uuid_is_null(uu))
          {
            if (qword_1009F7EE0 != -1) {
              dispatch_once(&qword_1009F7EE0, &stru_1009BFD48);
            }
            unsigned int v39 = off_1009F7ED8;
            int v40 = sub_100031234(uu);
            unint64_t v41 = sub_100030DCC((uint64_t)v39, v40, 0);

            memset(v57, 0, 7);
            uint64_t v42 = sub_1002284B8(v41);
            v57[0] = v42;
            BYTE2(v57[1]) = BYTE6(v42);
            LOWORD(v57[1]) = WORD2(v42);
            char v56 = 0;
            sub_10001B8E0(&v56);
            if (uuid_is_null(uu)) {
              uint64_t v43 = 0;
            }
            else {
              uint64_t v43 = v57;
            }
            if (sub_100233A00(v43, 1))
            {
              uint64_t v44 = qword_100A19E80;
              if (os_log_type_enabled((os_log_t)qword_100A19E80, OS_LOG_TYPE_ERROR))
              {
                memset(buf, 0, 37);
                uuid_unparse_upper(uu, (char *)buf);
                sub_10004191C(dst, (char *)buf);
                uint64_t v47 = dst;
                if (v64 < 0) {
                  uint64_t v47 = *(unsigned __int8 **)dst;
                }
                *(_DWORD *)char v65 = 136446210;
                v66 = v47;
                _os_log_error_impl((void *)&_mh_execute_header, v44, OS_LOG_TYPE_ERROR, "Failed to re-enable OOB pairing for device \"%{public}s\"", v65, 0xCu);
                if (v64 < 0) {
                  operator delete(*(void **)dst);
                }
              }
            }
            sub_10001B8AC(&v56);
          }
          uint64_t v45 = (unsigned __int8 *)*((void *)v37 + 1);
          if (v45)
          {
            do
            {
              uint64_t v46 = (const unsigned __int8 **)v45;
              uint64_t v45 = *(unsigned __int8 **)v45;
            }
            while (v45);
          }
          else
          {
            do
            {
              uint64_t v46 = (const unsigned __int8 **)*((void *)v37 + 2);
              BOOL v15 = *v46 == v37;
              char v37 = (const unsigned __int8 *)v46;
            }
            while (!v15);
          }
          char v37 = (const unsigned __int8 *)v46;
        }
        while (v46 != v36 + 6);
      }
      int v48 = (void *)v36[1];
      if (v48)
      {
        do
        {
          int v49 = v48;
          int v48 = (void *)*v48;
        }
        while (v48);
      }
      else
      {
        do
        {
          int v49 = (void *)v36[2];
          BOOL v15 = *v49 == (void)v36;
          uint64_t v36 = v49;
        }
        while (!v15);
      }
      uint64_t v36 = v49;
    }
    while (v49 != a1 + 68);
  }
  uint64_t v50 = +[NSMutableArray array];
  v51 = (void *)a1[466];
  a1[466] = v50;

  sub_100704610((uint64_t)a1);
  sub_10070757C((uint64_t)a1);
  if (sub_10022A2F0())
  {
    if (qword_1009F7EE0 != -1) {
      dispatch_once(&qword_1009F7EE0, &stru_1009BFD48);
    }
    sub_1006BAE00((uint64_t)off_1009F7ED8, 0);
  }
  return sub_10003AFB4((uint64_t)v62);
}

void sub_100708328(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, int a16, __int16 a17, char a18, char a19, uint64_t a20,void *__p,uint64_t a22,int a23,__int16 a24,char a25,char a26,void *a27,uint64_t a28,int a29,__int16 a30,char a31,char a32,char a33,uint64_t a34,uint64_t a35,uint64_t a36)
{
}

unsigned char *sub_100708480()
{
  v0 = qword_100A19E80;
  if (os_log_type_enabled((os_log_t)qword_100A19E80, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_DEFAULT, "Clearing address resolving cache", buf, 2u);
  }
  char v2 = 0;
  sub_10001B8E0(&v2);
  sub_100235628();
  sub_10001B910(&v2);
  return sub_10001B8AC(&v2);
}

void sub_100708508(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, int a10, __int16 a11, char a12, char a13)
{
}

uint64_t sub_10070851C(uint64_t a1, uint64_t a2)
{
  v5[0] = 0;
  v5[1] = 0;
  sub_10003AED0((uint64_t)v5, a1 + 48);
  *(void *)(a1 + 560) = a2;
  return sub_10003AFB4((uint64_t)v5);
}

uint64_t sub_100708564(void *a1, uint64_t a2)
{
  v20[0] = 0;
  v20[1] = 0;
  sub_10003AED0((uint64_t)v20, (uint64_t)(a1 + 6));
  uint64_t v4 = (void *)a1[71];
  id v5 = (void *)a1[72];
  id v6 = v4;
  if (v4 != v5)
  {
    while (*v6 != a2)
    {
      if (++v6 == v5)
      {
        id v6 = (void *)a1[72];
        break;
      }
    }
  }
  if (v6 == v5)
  {
    unint64_t v7 = a1[73];
    if ((unint64_t)v5 >= v7)
    {
      uint64_t v9 = v5 - v4;
      if ((unint64_t)(v9 + 1) >> 61) {
        abort();
      }
      uint64_t v10 = v7 - (void)v4;
      uint64_t v11 = v10 >> 2;
      if (v10 >> 2 <= (unint64_t)(v9 + 1)) {
        uint64_t v11 = v9 + 1;
      }
      if ((unint64_t)v10 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v12 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v12 = v11;
      }
      if (v12) {
        id v13 = (char *)sub_1000405F8((uint64_t)(a1 + 73), v12);
      }
      else {
        id v13 = 0;
      }
      uint64_t v14 = &v13[8 * v9];
      BOOL v15 = &v13[8 * v12];
      *(void *)uint64_t v14 = a2;
      uint64_t v8 = v14 + 8;
      uint64_t v16 = (char *)a1[72];
      uint64_t v17 = (char *)a1[71];
      if (v16 != v17)
      {
        do
        {
          uint64_t v18 = *((void *)v16 - 1);
          v16 -= 8;
          *((void *)v14 - 1) = v18;
          v14 -= 8;
        }
        while (v16 != v17);
        uint64_t v16 = (char *)a1[71];
      }
      a1[71] = v14;
      a1[72] = v8;
      a1[73] = v15;
      if (v16) {
        operator delete(v16);
      }
    }
    else
    {
      *id v5 = a2;
      uint64_t v8 = v5 + 1;
    }
    a1[72] = v8;
  }
  return sub_10003AFB4((uint64_t)v20);
}

void sub_100708698(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_1007086AC(uint64_t a1, uint64_t a2)
{
  v8[0] = 0;
  v8[1] = 0;
  sub_10003AED0((uint64_t)v8, a1 + 48);
  uint64_t v4 = *(char **)(a1 + 568);
  id v5 = *(char **)(a1 + 576);
  if (v4 != v5)
  {
    while (*(void *)v4 != a2)
    {
      v4 += 8;
      if (v4 == v5)
      {
        uint64_t v4 = *(char **)(a1 + 576);
        break;
      }
    }
  }
  if (v4 != v5)
  {
    int64_t v6 = v5 - (v4 + 8);
    if (v5 != v4 + 8) {
      memmove(v4, v4 + 8, v5 - (v4 + 8));
    }
    *(void *)(a1 + 576) = &v4[v6];
  }
  return sub_10003AFB4((uint64_t)v8);
}

void sub_10070874C(uint64_t a1, void *a2, int a3, int a4, int a5)
{
  id v9 = a2;
  if (*(unsigned char *)(a1 + 3718))
  {
LABEL_2:
    if (*(unsigned char *)(a1 + 41))
    {
      sub_1002B7E74(19, 0, v9);
      uint64_t v10 = qword_100A19E80;
      if (os_log_type_enabled((os_log_t)qword_100A19E80, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 138544130;
        unint64_t v23 = (unint64_t)v9;
        __int16 v24 = 1024;
        int v25 = a3;
        __int16 v26 = 1024;
        int v27 = a4;
        __int16 v28 = 1024;
        int v29 = a5;
        _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "Initiating pairing to device \"%{public}@\" useMITM=%d distributeIRK=%d disableCTKD=%d", buf, 0x1Eu);
      }
      uint64_t v21 = 0;
      if (qword_1009F7EC0 != -1) {
        dispatch_once(&qword_1009F7EC0, &stru_1009BFD68);
      }
      uint64_t v11 = off_1009F7EB8;
      sub_1000305AC(buf, v9);
      if (sub_1006856B8((uint64_t)v11, buf, &v21))
      {
        unint64_t v12 = *(void *)(a1 + 456);
        if (v12 >= *(unsigned __int16 *)(a1 + 3736))
        {
          uint64_t v18 = qword_100A19E80;
          if (os_log_type_enabled((os_log_t)qword_100A19E80, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 134217984;
            unint64_t v23 = v12;
            _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "Ignoring pairing request as there are too many paired devices (%lu)", buf, 0xCu);
          }
          char v20 = 0;
          sub_10001B8E0(&v20);
          sub_1001F11F4(v21, 4835);
          sub_10001B910(&v20);
          if (qword_1009F7EC0 != -1) {
            dispatch_once(&qword_1009F7EC0, &stru_1009BFD68);
          }
          int v19 = off_1009F7EB8;
          sub_1000305AC(buf, v9);
          sub_100683CFC((uint64_t)v19, buf, 8u);
          uint64_t v16 = (uint8_t *)&v20;
        }
        else
        {
          if (a5)
          {
            id v13 = qword_100A19E80;
            BOOL v14 = os_log_type_enabled((os_log_t)qword_100A19E80, OS_LOG_TYPE_DEFAULT);
            if (v14)
            {
              *(_DWORD *)buf = 138543362;
              unint64_t v23 = (unint64_t)v9;
              _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "Disabling CTKD for device \"%{public}@", buf, 0xCu);
            }
            sub_100708B14(v14, v9, 1);
          }
          buf[0] = 0;
          sub_10001B8E0(buf);
          if ((a4 & 1) == 0) {
            sub_1002404D4(1);
          }
          int v15 = sub_1002290AC(v21, a3);
          sub_10001B910(buf);
          if (v15 && os_log_type_enabled((os_log_t)qword_100A19E80, OS_LOG_TYPE_ERROR)) {
            sub_100797A68();
          }
          uint64_t v16 = buf;
        }
        sub_10001B8AC(v16);
      }
      else if (os_log_type_enabled((os_log_t)qword_100A19E80, OS_LOG_TYPE_ERROR))
      {
        sub_100797AD0();
      }
    }
    goto LABEL_30;
  }
  uint64_t v17 = qword_100A19E80;
  if (os_log_type_enabled((os_log_t)qword_100A19E80, OS_LOG_TYPE_FAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_fault_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_FAULT, "We don't have root keys for LE, something's wrong, file a radar!", buf, 2u);
    if (*(unsigned char *)(a1 + 3718)) {
      goto LABEL_2;
    }
    uint64_t v17 = qword_100A19E80;
  }
  if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR)) {
    sub_100797A34();
  }
LABEL_30:
}

void sub_100708AC8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  sub_10001B8AC(va);

  _Unwind_Resume(a1);
}

void sub_100708B14(uint64_t a1, void *a2, int a3)
{
  id v4 = a2;
  id v5 = qword_100A19E80;
  if (os_log_type_enabled((os_log_t)qword_100A19E80, OS_LOG_TYPE_DEFAULT))
  {
    int64_t v6 = "enable";
    if (a3) {
      int64_t v6 = "disable";
    }
    *(_DWORD *)buf = 136446466;
    uint64_t v10 = v6;
    __int16 v11 = 2114;
    id v12 = v4;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "Warning: Trying to %{public}s CTKD for device %{public}@", buf, 0x16u);
  }
  BOOL v8 = 0;
  if (qword_1009F7EC0 != -1) {
    dispatch_once(&qword_1009F7EC0, &stru_1009BFD68);
  }
  unint64_t v7 = off_1009F7EB8;
  sub_1000305AC(buf, v4);
  if (sub_1006856B8((uint64_t)v7, buf, &v8))
  {
    buf[0] = 0;
    sub_10001B8E0(buf);
    sub_100240540(v8, a3);
    sub_10001B8AC(buf);
  }
  else if (os_log_type_enabled((os_log_t)qword_100A19E80, OS_LOG_TYPE_ERROR))
  {
    sub_100797B3C();
  }
}

void sub_100708C88(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  sub_10001B8AC(va);

  _Unwind_Resume(a1);
}

void sub_100708CB4(uint64_t a1, void *a2, int a3, unsigned int a4)
{
  id v7 = a2;
  if (*(unsigned char *)(a1 + 3718))
  {
LABEL_2:
    if (*(unsigned char *)(a1 + 41))
    {
      if (qword_1009F7EE0 != -1) {
        dispatch_once(&qword_1009F7EE0, &stru_1009BFD48);
      }
      unint64_t v8 = sub_100030DCC((uint64_t)off_1009F7ED8, v7, 0);
      uint64_t v9 = sub_1002284B8(v8);
      int v16 = v9;
      char v18 = BYTE6(v9);
      __int16 v17 = WORD2(v9);
      if (a3)
      {
        uint64_t v10 = qword_100A19E80;
        BOOL v11 = os_log_type_enabled((os_log_t)qword_100A19E80, OS_LOG_TYPE_DEFAULT);
        if (a4)
        {
          if (v11)
          {
            id v12 = sub_1006AD3F0();
            *(_DWORD *)buf = 67109634;
            *(_DWORD *)char v20 = a4;
            *(_WORD *)&v20[4] = 2114;
            *(void *)&v20[6] = v7;
            *(_WORD *)&v20[14] = 2114;
            *(void *)&v20[16] = v12;
            _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "Accepting pairing request with passkey %u from device \"%{public}@\" (%{public}@)", buf, 0x1Cu);
          }
        }
        else if (v11)
        {
          int v15 = sub_1006AD3F0();
          *(_DWORD *)buf = 138543618;
          *(void *)char v20 = v7;
          *(_WORD *)&v20[8] = 2114;
          *(void *)&v20[10] = v15;
          _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "Accepting pairing request from device \"%{public}@\"(%{public}@)", buf, 0x16u);
        }
        buf[0] = 0;
        sub_10001B8E0(buf);
        if (sub_100237AF8(&v16, a4))
        {
          if (os_log_type_enabled((os_log_t)qword_100A19E80, OS_LOG_TYPE_ERROR)) {
            sub_100797BA8();
          }
          sub_1002378AC(&v16);
        }
      }
      else
      {
        BOOL v14 = qword_100A19E80;
        if (os_log_type_enabled((os_log_t)qword_100A19E80, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 138543362;
          *(void *)char v20 = v7;
          _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "Rejecting pairing request from device \"%{public}@\"", buf, 0xCu);
        }
        buf[0] = 0;
        sub_10001B8E0(buf);
        if (sub_1002378AC(&v16) && os_log_type_enabled((os_log_t)qword_100A19E80, OS_LOG_TYPE_ERROR)) {
          sub_100797C10();
        }
      }
      sub_10001B8AC(buf);
    }
    goto LABEL_24;
  }
  id v13 = qword_100A19E80;
  if (os_log_type_enabled((os_log_t)qword_100A19E80, OS_LOG_TYPE_FAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_fault_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_FAULT, "We don't have root keys for LE, something's wrong, file a radar!", buf, 2u);
    if (*(unsigned char *)(a1 + 3718)) {
      goto LABEL_2;
    }
    id v13 = qword_100A19E80;
  }
  if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR)) {
    sub_100797A34();
  }
LABEL_24:
}

void sub_100708FD0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100709010(uint64_t a1, unint64_t a2, void *a3, int a4, uint64_t a5)
{
  unint64_t v49 = a2;
  id v8 = a3;
  if (*(unsigned char *)(a1 + 3718))
  {
LABEL_2:
    if (*(unsigned char *)(a1 + 41))
    {
      if (qword_1009F7EE0 != -1) {
        dispatch_once(&qword_1009F7EE0, &stru_1009BFD48);
      }
      unint64_t v9 = sub_100030DCC((uint64_t)off_1009F7ED8, v8, 0);
      uint64_t v10 = sub_1002284B8(v9);
      int v46 = v10;
      char v48 = BYTE6(v10);
      __int16 v47 = WORD2(v10);
      if (a4)
      {
        v45[0] = 0;
        v45[1] = 0;
        sub_10003AED0((uint64_t)v45, a1 + 48);
        char v44 = 0;
        sub_10001B8E0(&v44);
        *(void *)uuid_t uu = &v49;
        BOOL v11 = sub_1002CC204((uint64_t **)(a1 + 536), &v49, (uint64_t)&unk_1007BE9D0, (uint64_t **)uu);
        sub_1000305AC(uu, v8);
        uint64_t v12 = (uint64_t)(v11 + 5);
        uint64_t v13 = sub_1000308C0((uint64_t)(v11 + 5), uu);
        BOOL v14 = v11 + 6;
        if ((v14 == (uint64_t *)v13 || (int v15 = *(_OWORD **)(v13 + 48)) == 0)
          && ((uuid_clear(uu), uint64_t v16 = sub_1000308C0(v12, uu), v14 == (uint64_t *)v16)
           || (int v15 = *(_OWORD **)(v16 + 48)) == 0))
        {
          uint64_t v36 = qword_100A19E80;
          if (os_log_type_enabled((os_log_t)qword_100A19E80, OS_LOG_TYPE_DEFAULT))
          {
            char v37 = sub_1006AD3F0();
            *(_DWORD *)uuid_t uu = 138543618;
            *(void *)&uu[4] = v8;
            *(_WORD *)&uu[12] = 2114;
            *(void *)&uu[14] = v37;
            _os_log_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_DEFAULT, "Accepting out-of-band pairing request from device \"%{public}@\" (%{public}@) with remote keys", uu, 0x16u);
          }
          int v30 = sub_10023FC80(&v46, (_OWORD *)a5, (_OWORD *)(a5 + 16), 0);
        }
        else
        {
          long long v17 = v15[1];
          *(_OWORD *)uuid_t uu = *v15;
          *(_OWORD *)&uu[16] = v17;
          uint64_t v18 = *(void *)(a5 + 8);
          BOOL v26 = *(void *)a5 == *(void *)uu;
          long long v19 = v15[2];
          long long v20 = v15[3];
          long long v21 = v15[5];
          long long v57 = v15[4];
          long long v58 = v21;
          long long v55 = v19;
          long long v56 = v20;
          long long v22 = v15[7];
          long long v59 = v15[6];
          long long v60 = v22;
          long long v23 = v15[11];
          long long v25 = v15[8];
          long long v24 = v15[9];
          long long v63 = v15[10];
          long long v64 = v23;
          BOOL v26 = v26 && v18 == *(void *)&uu[8];
          long long v61 = v25;
          long long v62 = v24;
          if (v26
            && (*(void *)(a5 + 16) == *(void *)&uu[16]
              ? (BOOL v27 = *(void *)(a5 + 24) == *(void *)&uu[24])
              : (BOOL v27 = 0),
                v27))
          {
            int v40 = qword_100A19E80;
            if (os_log_type_enabled((os_log_t)qword_100A19E80, OS_LOG_TYPE_DEFAULT))
            {
              unint64_t v41 = sub_1006AD3F0();
              *(_DWORD *)buf = 138543618;
              id v51 = v8;
              __int16 v52 = 2114;
              long long v53 = v41;
              _os_log_impl((void *)&_mh_execute_header, v40, OS_LOG_TYPE_DEFAULT, "Accepting out-of-band pairing request from device \"%{public}@\" (%{public}@) with locally generated key bundle", buf, 0x16u);
            }
            int v30 = sub_10023FC80(&v46, 0, 0, uu);
          }
          else
          {
            __int16 v28 = qword_100A19E80;
            if (os_log_type_enabled((os_log_t)qword_100A19E80, OS_LOG_TYPE_DEFAULT))
            {
              int v29 = sub_1006AD3F0();
              *(_DWORD *)buf = 138543618;
              id v51 = v8;
              __int16 v52 = 2114;
              long long v53 = v29;
              _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, "Accepting out-of-band pairing request from device \"%{public}@\" (%{public}@) with locally generated key bundle for 2-way OOB", buf, 0x16u);
            }
            int v30 = sub_10023FC80(&v46, (_OWORD *)a5, (_OWORD *)(a5 + 16), uu);
          }
        }
        int v38 = v30;
        if (v30)
        {
          unsigned int v39 = qword_100A19E80;
          if (os_log_type_enabled((os_log_t)qword_100A19E80, OS_LOG_TYPE_ERROR))
          {
            uint64_t v43 = sub_1006AD3F0();
            *(_DWORD *)uuid_t uu = 138543874;
            *(void *)&uu[4] = v8;
            *(_WORD *)&uu[12] = 2114;
            *(void *)&uu[14] = v43;
            *(_WORD *)&uu[22] = 1024;
            *(_DWORD *)&uu[24] = v38;
            _os_log_error_impl((void *)&_mh_execute_header, v39, OS_LOG_TYPE_ERROR, "Failed to accept pairing for device \"%{public}@\" (%{public}@) with result %{bluetooth:OI_STATUS}u - cancelling...", uu, 0x1Cu);
          }
          sub_1002378AC(&v46);
        }
        sub_10001B8AC(&v44);
        sub_10003AFB4((uint64_t)v45);
      }
      else
      {
        unint64_t v32 = qword_100A19E80;
        if (os_log_type_enabled((os_log_t)qword_100A19E80, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v33 = sub_1006AD3F0();
          *(_DWORD *)uuid_t uu = 138543618;
          *(void *)&uu[4] = v8;
          *(_WORD *)&uu[12] = 2114;
          *(void *)&uu[14] = v33;
          _os_log_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_DEFAULT, "Rejecting out-of-band pairing request from device \"%{public}@\" (%{public}@)", uu, 0x16u);
        }
        buf[0] = 0;
        sub_10001B8E0(buf);
        int v34 = sub_1002378AC(&v46);
        if (v34)
        {
          uint64_t v35 = qword_100A19E80;
          if (os_log_type_enabled((os_log_t)qword_100A19E80, OS_LOG_TYPE_ERROR))
          {
            uint64_t v42 = sub_1006AD3F0();
            *(_DWORD *)uuid_t uu = 138543874;
            *(void *)&uu[4] = v8;
            *(_WORD *)&uu[12] = 2114;
            *(void *)&uu[14] = v42;
            *(_WORD *)&uu[22] = 1024;
            *(_DWORD *)&uu[24] = v34;
            _os_log_error_impl((void *)&_mh_execute_header, v35, OS_LOG_TYPE_ERROR, "Failed to cancel pairing to device \"%{public}@\" (%{public}@) with result %{bluetooth:OI_STATUS}u", uu, 0x1Cu);
          }
        }
        sub_10001B8AC(buf);
      }
    }
    goto LABEL_39;
  }
  BOOL v31 = qword_100A19E80;
  if (os_log_type_enabled((os_log_t)qword_100A19E80, OS_LOG_TYPE_FAULT))
  {
    *(_WORD *)uuid_t uu = 0;
    _os_log_fault_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_FAULT, "We don't have root keys for LE, something's wrong, file a radar!", uu, 2u);
    if (*(unsigned char *)(a1 + 3718)) {
      goto LABEL_2;
    }
    BOOL v31 = qword_100A19E80;
  }
  if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR)) {
    sub_100797A34();
  }
LABEL_39:
}

void sub_1007095B0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, int a10, __int16 a11, char a12, char a13, char a14)
{
  sub_10001B8AC(&a13);
  sub_10003AFB4((uint64_t)&a14);

  _Unwind_Resume(a1);
}

uint64_t sub_10070962C(uint64_t a1, uint64_t a2, void *a3)
{
  v7[2] = a2;
  id v4 = a3;
  memset(v8, 0, sizeof(v8));
  v7[0] = 0;
  v7[1] = 0;
  sub_10003AED0((uint64_t)v7, a1 + 48);
  char v6 = 0;
  sub_10001B8E0(&v6);
  if (!sub_10023FAF4(v8)) {
    operator new();
  }
  if (os_log_type_enabled((os_log_t)qword_100A19E80, OS_LOG_TYPE_ERROR)) {
    sub_100797C78();
  }
  sub_10001B8AC(&v6);
  sub_10003AFB4((uint64_t)v7);

  return 0;
}

void sub_10070992C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, int a9, __int16 a10, char a11, char a12, char a13)
{
  sub_10001B8AC(&a12);
  sub_10003AFB4((uint64_t)&a13);

  _Unwind_Resume(a1);
}

void sub_100709978(uint64_t a1, unint64_t a2, void *a3, char a4)
{
  unint64_t v17 = a2;
  id v6 = a3;
  v16[0] = 0;
  v16[1] = 0;
  sub_10003AED0((uint64_t)v16, a1 + 48);
  *(void *)buf = &v17;
  id v7 = sub_1002CC204((uint64_t **)(a1 + 536), &v17, (uint64_t)&unk_1007BE9D0, (uint64_t **)buf);
  sub_1000305AC(buf, v6);
  id v8 = (uint64_t **)(v7 + 5);
  const unsigned __int8 *__attribute__((__org_typedef(uuid_t))) v18 = buf;
  unint64_t v9 = sub_10071B498(v8, buf, (uint64_t)&unk_1007BE9D0, &v18);
  *((unsigned char *)v9 + 56) = a4;
  if (a4)
  {
    uint64_t v10 = qword_100A19E80;
    BOOL v11 = os_log_type_enabled((os_log_t)qword_100A19E80, OS_LOG_TYPE_DEFAULT);
    if (v6)
    {
      if (v11)
      {
        *(_DWORD *)buf = 138543362;
        *(void *)&uint8_t buf[4] = v6;
        _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "Enabling out-of-band pairing for device \"%{public}@\"", buf, 0xCu);
      }
      if (qword_1009F7EE0 != -1) {
        dispatch_once(&qword_1009F7EE0, &stru_1009BFD48);
      }
      unint64_t v12 = sub_100030DCC((uint64_t)off_1009F7ED8, v6, 0);
    }
    else
    {
      if (v11)
      {
        *(_WORD *)buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "Enabling out-of-band pairing for all devices", buf, 2u);
      }
      unint64_t v12 = 0;
    }
    uint64_t v14 = sub_1002284B8(v12);
    *(_DWORD *)buf = v14;
    buf[6] = BYTE6(v14);
    *(_WORD *)&uint8_t buf[4] = WORD2(v14);
    LOBYTE(v18) = 0;
    sub_10001B8E0(&v18);
    if (v6) {
      int v15 = (int *)buf;
    }
    else {
      int v15 = 0;
    }
    if (sub_100233A00(v15, 1) && os_log_type_enabled((os_log_t)qword_100A19E80, OS_LOG_TYPE_ERROR)) {
      sub_100797CE0();
    }
    sub_10001B8AC(&v18);
  }
  else
  {
    if (!v9[6])
    {
      sub_1000305AC(buf, v6);
      uint64_t v13 = (uint64_t *)sub_1000308C0((uint64_t)v8, buf);
      sub_10004D3B8(v8, v13);
      operator delete(v13);
    }
    sub_100709C2C(a1, v6);
  }
  sub_10003AFB4((uint64_t)v16);
}

void sub_100709BDC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_10003AFB4((uint64_t)va);

  _Unwind_Resume(a1);
}

void sub_100709C2C(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = *(void **)(a1 + 536);
  if (v4 == (void *)(a1 + 544))
  {
LABEL_21:
    if (!*(unsigned char *)(a1 + 41)) {
      goto LABEL_39;
    }
    char v22 = 0;
    sub_10001B8E0(&v22);
    uint64_t v14 = qword_100A19E80;
    BOOL v15 = os_log_type_enabled((os_log_t)qword_100A19E80, OS_LOG_TYPE_DEFAULT);
    if (v3)
    {
      if (v15)
      {
        *(_DWORD *)buf = 138543362;
        id v24 = v3;
        _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "Disabling out-of-band pairing for device \"%{public}@\"", buf, 0xCu);
      }
      if (qword_1009F7EE0 != -1) {
        dispatch_once(&qword_1009F7EE0, &stru_1009BFD48);
      }
      unint64_t v16 = sub_100030DCC((uint64_t)off_1009F7ED8, v3, 0);
      uint64_t v17 = sub_1002284B8(v16);
      *(_DWORD *)buf = v17;
      BYTE2(v24) = BYTE6(v17);
      LOWORD(v24) = WORD2(v17);
      int v18 = sub_100233A00((int *)buf, 0);
      if (v18 != 120) {
        goto LABEL_35;
      }
      if (qword_1009F7EE0 != -1) {
        dispatch_once(&qword_1009F7EE0, &stru_1009BFD48);
      }
      unint64_t v19 = sub_100030DCC((uint64_t)off_1009F7ED8, v3, 1);
      uint64_t v20 = sub_1002284B8(v19);
      *(_DWORD *)buf = v20;
      BYTE2(v24) = BYTE6(v20);
      LOWORD(v24) = WORD2(v20);
      int v21 = sub_100233A00((int *)buf, 0);
    }
    else
    {
      if (v15)
      {
        *(_WORD *)buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "Disabling out-of-band pairing for all devices", buf, 2u);
      }
      int v21 = sub_100233A00(0, 0);
    }
    int v18 = v21;
LABEL_35:
    if (v18 && os_log_type_enabled((os_log_t)qword_100A19E80, OS_LOG_TYPE_ERROR)) {
      sub_100797D4C();
    }
    sub_10001B8AC(&v22);
    goto LABEL_39;
  }
  char v5 = 1;
  do
  {
    id v6 = (const unsigned __int8 *)v4[5];
    if (v6 == (const unsigned __int8 *)(v4 + 6)) {
      goto LABEL_14;
    }
    while (1)
    {
      id v7 = sub_100031234(v6 + 32);
      if (![v3 isEqual:v7])
      {

        goto LABEL_8;
      }
      int v8 = v6[56];

      if (v8) {
        break;
      }
LABEL_8:
      unint64_t v9 = (unsigned __int8 *)*((void *)v6 + 1);
      if (v9)
      {
        do
        {
          uint64_t v10 = (const unsigned __int8 **)v9;
          unint64_t v9 = *(unsigned __int8 **)v9;
        }
        while (v9);
      }
      else
      {
        do
        {
          uint64_t v10 = (const unsigned __int8 **)*((void *)v6 + 2);
          BOOL v11 = *v10 == v6;
          id v6 = (const unsigned __int8 *)v10;
        }
        while (!v11);
      }
      id v6 = (const unsigned __int8 *)v10;
      if (v10 == v4 + 6) {
        goto LABEL_14;
      }
    }
    char v5 = 0;
LABEL_14:
    unint64_t v12 = (void *)v4[1];
    if (v12)
    {
      do
      {
        uint64_t v13 = v12;
        unint64_t v12 = (void *)*v12;
      }
      while (v12);
    }
    else
    {
      do
      {
        uint64_t v13 = (void *)v4[2];
        BOOL v11 = *v13 == (void)v4;
        id v4 = v13;
      }
      while (!v11);
    }
    id v4 = v13;
  }
  while (v13 != (void *)(a1 + 544));
  if (v5) {
    goto LABEL_21;
  }
LABEL_39:
}

void sub_100709F1C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, int a10, __int16 a11, char a12, char a13)
{
  sub_10001B8AC(&a13);

  _Unwind_Resume(a1);
}

uint64_t sub_100709F60(uint64_t a1, unint64_t a2)
{
  v16[0] = 0;
  v16[1] = 0;
  sub_10003AED0((uint64_t)v16, a1 + 48);
  id v4 = *(void **)(a1 + 544);
  if (v4)
  {
    uint64_t v5 = a1 + 544;
    do
    {
      unint64_t v6 = v4[4];
      BOOL v7 = v6 >= a2;
      if (v6 >= a2) {
        int v8 = v4;
      }
      else {
        int v8 = v4 + 1;
      }
      if (v7) {
        uint64_t v5 = (uint64_t)v4;
      }
      id v4 = (void *)*v8;
    }
    while (*v8);
    if (v5 != a1 + 544 && *(void *)(v5 + 32) <= a2)
    {
      unint64_t v9 = *(unsigned __int8 **)(v5 + 40);
      if (v9 != (unsigned __int8 *)(v5 + 48))
      {
        do
        {
          memset(dst, 0, sizeof(dst));
          uuid_copy(dst, v9 + 32);
          if (*((void *)v9 + 6)) {
            operator delete();
          }
          uint64_t v10 = (unsigned __int8 *)*((void *)v9 + 1);
          BOOL v11 = v9;
          if (v10)
          {
            do
            {
              unint64_t v12 = v10;
              uint64_t v10 = *(unsigned __int8 **)v10;
            }
            while (v10);
          }
          else
          {
            do
            {
              unint64_t v12 = (unsigned __int8 *)*((void *)v11 + 2);
              BOOL v13 = *(void *)v12 == (void)v11;
              BOOL v11 = v12;
            }
            while (!v13);
          }
          sub_10004D3B8((uint64_t **)(v5 + 40), (uint64_t *)v9);
          operator delete(v9);
          uint64_t v14 = sub_100031234(dst);
          sub_100709C2C(a1, v14);

          unint64_t v9 = v12;
        }
        while (v12 != (unsigned __int8 *)(v5 + 48));
      }
      sub_1003B9B30((uint64_t **)(a1 + 536), v5);
    }
  }
  return sub_10003AFB4((uint64_t)v16);
}

void sub_10070A0E8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_10003AFB4((uint64_t)va);
  _Unwind_Resume(a1);
}

id sub_10070A118(uint64_t a1, unint64_t a2, uint64_t a3, uint64_t a4, const std::string *a5)
{
  v26[0] = 0;
  v26[1] = 0;
  sub_10003AED0((uint64_t)v26, a1 + 48);
  unint64_t v10 = *(void *)(a1 + 456);
  if (v10 >= *(unsigned __int16 *)(a1 + 3736))
  {
    BOOL v11 = qword_100A19E80;
    if (os_log_type_enabled((os_log_t)qword_100A19E80, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 134217984;
      *(void *)&uint8_t buf[4] = v10;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "Too many paired devices (%lu), but cloud paired devices are allowed", buf, 0xCu);
    }
  }
  *(_OWORD *)buf = 0uLL;
  sub_1003BC0D4(*(void *)(a4 + 8), 10, buf);
  *(void *)uu2 = 0;
  uint64_t v29 = 0;
  if (qword_1009F7EE0 != -1) {
    dispatch_once(&qword_1009F7EE0, &stru_1009BFD48);
  }
  unint64_t v12 = off_1009F7ED8;
  if (sub_100013DCC((uint64_t)buf)) {
    BOOL v13 = 0;
  }
  else {
    BOOL v13 = (long long *)sub_10004A6E4((uint64_t)buf);
  }
  sub_100014B58((uint64_t)v12, a2, 1u, 0, 0, v13, uu2);
  if (qword_1009F7EE0 != -1) {
    dispatch_once(&qword_1009F7EE0, &stru_1009BFD48);
  }
  uint64_t v14 = off_1009F7ED8;
  if (*(char *)(a3 + 23) < 0)
  {
    sub_10003B098(__p, *(void **)a3, *(void *)(a3 + 8));
  }
  else
  {
    *(_OWORD *)__p = *(_OWORD *)a3;
    uint64_t v25 = *(void *)(a3 + 16);
  }
  sub_1006B7F8C((uint64_t)v14, uu2, (uint64_t)__p, 2);
  if (SHIBYTE(v25) < 0) {
    operator delete(__p[0]);
  }
  if (a1 + 472 != sub_1000308C0(a1 + 464, uu2))
  {
    BOOL v15 = qword_100A19E80;
    if (os_log_type_enabled((os_log_t)qword_100A19E80, OS_LOG_TYPE_FAULT)) {
      sub_100797DB4(v15, v16, v17);
    }
  }
  BOOL v27 = uu2;
  int v18 = sub_10071B0A4((uint64_t **)(a1 + 464), uu2, (uint64_t)&unk_1007BE9D0, (const unsigned __int8 *__attribute__((__org_typedef(uuid_t))) *)&v27);
  sub_100049EE0((uint64_t)(v18 + 6), a4);
  if (qword_1009F7EE0 != -1) {
    dispatch_once(&qword_1009F7EE0, &stru_1009BFD48);
  }
  unint64_t v19 = off_1009F7ED8;
  uint64_t v20 = sub_100031234(uu2);
  unint64_t v21 = sub_100030DCC((uint64_t)v19, v20, 0);
  sub_10070A4A0(a1, v21, a2, 0, a5);

  char v22 = sub_100031234(uu2);
  *(void *)buf = &off_100998428;
  if (*(void *)&buf[8]) {
    sub_1000368F4(*(atomic_uint **)&buf[8]);
  }
  sub_10003AFB4((uint64_t)v26);

  return v22;
}

void sub_10070A428(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t (**a22)(),atomic_uint *a23)
{
  a22 = &off_100998428;
  if (a23) {
    sub_1000368F4(a23);
  }
  sub_10003AFB4((uint64_t)&a16);
  _Unwind_Resume(a1);
}

void sub_10070A4A0(uint64_t a1, unint64_t a2, unint64_t a3, int a4, const std::string *a5)
{
  memset(uu, 0, sizeof(uu));
  uuid_clear(uu);
  if (*(unsigned char *)(a1 + 41))
  {
    uint64_t v9 = sub_1002284B8(a2);
    *(_DWORD *)src = v9;
    src[6] = BYTE6(v9);
    *(_WORD *)&src[4] = WORD2(v9);
    LOBYTE(v76) = 0;
    sub_10001B8E0(&v76);
    uint64_t v10 = sub_100197B34(src);
    sub_10001B910(&v76);
    if (v10)
    {
      if (qword_1009F7EC0 != -1) {
        dispatch_once(&qword_1009F7EC0, &stru_1009BFD68);
      }
      sub_10067F618((uint64_t)off_1009F7EB8, v10, uu);
    }
    sub_10001B8AC(&v76);
  }
  if (uuid_is_null(uu))
  {
    if (qword_1009F7EE0 != -1) {
      dispatch_once(&qword_1009F7EE0, &stru_1009BFD48);
    }
    sub_100014B58((uint64_t)off_1009F7ED8, a2, 0, 1u, 0, 0, src);
    uuid_copy(uu, src);
    if (uuid_is_null(uu))
    {
      if (qword_1009F7EE0 != -1) {
        dispatch_once(&qword_1009F7EE0, &stru_1009BFD48);
      }
      sub_100014B58((uint64_t)off_1009F7ED8, a3, 0, 1u, 0, 0, src);
      uuid_copy(uu, src);
    }
  }
  BOOL v11 = qword_100A19E80;
  if (os_log_type_enabled((os_log_t)qword_100A19E80, OS_LOG_TYPE_INFO))
  {
    sub_1006AD3F0();
    id v12 = (id)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)src = 138543618;
    *(void *)&src[4] = v12;
    *(_WORD *)&src[12] = 1024;
    *(_DWORD *)&src[14] = a4;
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_INFO, "Device \"%{public}@\" finished pairing with status  %{bluetooth:OI_STATUS}u", src, 0x12u);
  }
  if (!uuid_is_null(uu))
  {
    v71[0] = 0;
    v71[1] = 0;
    sub_10003AED0((uint64_t)v71, a1 + 48);
    long long v56 = (uint64_t **)(a1 + 464);
    long long v57 = (uint64_t *)sub_1000308C0(a1 + 464, uu);
    if (a4)
    {
      if (a4 != 4832)
      {
        if (os_log_type_enabled((os_log_t)qword_100A19E80, OS_LOG_TYPE_ERROR))
        {
          sub_100401EBC(uu, src);
          sub_100797E64();
        }
        if (!v49 & v48)
        {
          switch(a4)
          {
            case 4808:
              if (a3)
              {
                long long buf = 0uLL;
                if (qword_1009F7EE0 != -1) {
                  dispatch_once(&qword_1009F7EE0, &stru_1009BFD48);
                }
                sub_100014B58((uint64_t)off_1009F7ED8, a3, 0, 1u, 0, 0, (unsigned __int8 *)&buf);
                if (uuid_is_null((const unsigned __int8 *)&buf)
                  && os_log_type_enabled((os_log_t)qword_100A19E80, OS_LOG_TYPE_FAULT))
                {
                  sub_100797E30();
                }
                if (!uuid_is_null((const unsigned __int8 *)&buf))
                {
                  if (qword_1009F7EE0 != -1) {
                    dispatch_once(&qword_1009F7EE0, &stru_1009BFD48);
                  }
                  long long v53 = off_1009F7ED8;
                  char v54 = sub_100031234(uu);
                  long long v55 = sub_100031234((const unsigned __int8 *)&buf);
                  sub_1006C02E0((uint64_t)v53, v54, v55);
                }
              }
              break;
            default:
              break;
          }
        }
        else
        {
          switch(a4)
          {
            case 4818:
            case 4819:
            case 4820:
            case 4821:
            case 4822:
            case 4823:
            case 4824:
            case 4825:
            case 4826:
            case 4827:
              break;
            default:
              JUMPOUT(0);
          }
        }
        if ((uint64_t *)(a1 + 472) != v57) {
          sub_10071B5BC(v56, v57);
        }
        if (qword_1009F7F10 != -1) {
          dispatch_once(&qword_1009F7F10, &stru_1009BFDA8);
        }
        sub_10063F9A4(qword_1009F7F08, 0, uu);
      }
      if ((uint64_t *)(a1 + 472) != v57) {
        sub_10071B5BC(v56, v57);
      }
      if (qword_1009F7EE0 != -1) {
        dispatch_once(&qword_1009F7EE0, &stru_1009BFD48);
      }
      BOOL v15 = off_1009F7ED8;
      uint64_t v16 = sub_100031234(uu);
      sub_10004191C(__p, "_UNPAIR_AFTER_DISCONNECTION_");
      sub_1006BC69C((uint64_t)v15, v16, (unsigned __int8 *)__p);
      if (v70 < 0) {
        operator delete(__p[0]);
      }

      uint64_t v17 = sub_100031234(uu);
      sub_1007131A0(a1, v17);

      sub_100712624(a1);
    }
    int v18 = qword_100A19E80;
    if (os_log_type_enabled((os_log_t)qword_100A19E80, OS_LOG_TYPE_DEFAULT))
    {
      memset(src, 0, 37);
      uuid_unparse_upper(uu, (char *)src);
      sub_10004191C(&v76, (char *)src);
      unint64_t v19 = v78 >= 0 ? (void **)&v76 : v76;
      LODWORD(buf) = 136446210;
      *(void *)((char *)&buf + 4) = v19;
      _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "Pairing succeeded to device \"%{public}s\"", (uint8_t *)&buf, 0xCu);
      if (v78 < 0) {
        operator delete(v76);
      }
    }
    if (qword_1009F7EE0 != -1) {
      dispatch_once(&qword_1009F7EE0, &stru_1009BFD48);
    }
    uint64_t v20 = off_1009F7ED8;
    unint64_t v21 = sub_100031234(uu);
    sub_1006BE8B4((uint64_t)v20, v21, a5);

    if (qword_1009F7EE0 != -1) {
      dispatch_once(&qword_1009F7EE0, &stru_1009BFD48);
    }
    char v22 = off_1009F7ED8;
    long long v23 = sub_100031234(uu);
    sub_1006C27E0((uint64_t)v22, v23, 1, 2, 0);

    sub_1007113D4(a1, uu);
    if ((uint64_t *)(a1 + 472) != v57)
    {
      uint64_t v24 = v57[7];
      *(void *)&long long buf = &off_1009B4578;
      *((void *)&buf + 1) = v24;
      if (v24) {
        sub_100037354(v24);
      }
      if (a3)
      {
        sub_1003BC0D4(*((uint64_t *)&buf + 1), 11, src);
        uint64_t v25 = *(unsigned __int8 *)(sub_10004A6E4((uint64_t)src) + 1);
        sub_1003BC0D4(*((uint64_t *)&buf + 1), 11, &v76);
        uint64_t v26 = *(unsigned __int8 *)(sub_10004A6E4((uint64_t)&v76) + 2);
        sub_1003BC0D4(*((uint64_t *)&buf + 1), 11, &v67);
        uint64_t v27 = *(unsigned __int8 *)(sub_10004A6E4((uint64_t)&v67) + 3);
        sub_1003BC0D4(*((uint64_t *)&buf + 1), 11, &v65);
        uint64_t v28 = *(unsigned __int8 *)(sub_10004A6E4((uint64_t)&v65) + 4);
        sub_1003BC0D4(*((uint64_t *)&buf + 1), 11, &v73);
        uint64_t v29 = *(unsigned __int8 *)(sub_10004A6E4((uint64_t)&v73) + 5);
        sub_1003BC0D4(*((uint64_t *)&buf + 1), 11, &v63);
        uint64_t v30 = *(unsigned __int8 *)(sub_10004A6E4((uint64_t)&v63) + 6);
        sub_1003BC0D4(*((uint64_t *)&buf + 1), 11, &v61);
        uint64_t v31 = v25 << 40;
        uint64_t v32 = *(unsigned __int8 *)sub_10004A6E4((uint64_t)&v61);
        long long v61 = &off_100998428;
        if (v62) {
          sub_1000368F4(v62);
        }
        uint64_t v33 = v31 | (v26 << 32);
        long long v63 = &off_100998428;
        if (v64) {
          sub_1000368F4(v64);
        }
        uint64_t v34 = v33 | (v27 << 24);
        v73 = &off_100998428;
        if (v74) {
          sub_1000368F4(v74);
        }
        uint64_t v35 = v34 | (v28 << 16);
        char v65 = &off_100998428;
        if (v66) {
          sub_1000368F4(v66);
        }
        uint64_t v36 = v35 | (v29 << 8);
        char v67 = &off_100998428;
        if (v68) {
          sub_1000368F4(v68);
        }
        uint64_t v37 = v36 | v30;
        v76 = (void **)&off_100998428;
        if (v77) {
          sub_1000368F4(v77);
        }
        uint64_t v38 = v37 | (v32 << 48);
        *(void *)src = &off_100998428;
        if (*(void *)&src[8]) {
          sub_1000368F4(*(atomic_uint **)&src[8]);
        }
        if (v38 != a3)
        {
          unsigned int v39 = qword_100A19E80;
          if (os_log_type_enabled((os_log_t)qword_100A19E80, OS_LOG_TYPE_FAULT))
          {
            sub_1006AD3F0();
            id v40 = (id)objc_claimAutoreleasedReturnValue();
            unint64_t v41 = sub_1006AD3F0();
            sub_100797F54(v40, v41, (uint64_t)&v76, v39);
          }
        }
        sub_1003BC0D4(*((uint64_t *)&buf + 1), 10, src);
        BOOL v42 = sub_100013DCC((uint64_t)src);
        *(void *)src = &off_100998428;
        if (*(void *)&src[8]) {
          sub_1000368F4(*(atomic_uint **)&src[8]);
        }
        if (v42)
        {
          uint64_t v43 = qword_100A19E80;
          if (os_log_type_enabled((os_log_t)qword_100A19E80, OS_LOG_TYPE_FAULT))
          {
            char v44 = sub_1006AD3F0();
            sub_100797EE4(v44, (uint64_t)&v73, v43);
          }
        }
        if (qword_1009F7EE0 != -1) {
          dispatch_once(&qword_1009F7EE0, &stru_1009BFD48);
        }
        sub_1006C0C10((uint64_t)off_1009F7ED8, uu, a3);
        if (*(unsigned char *)(a1 + 41))
        {
          if (qword_1009F7EE0 != -1) {
            dispatch_once(&qword_1009F7EE0, &stru_1009BFD48);
          }
          uint64_t v45 = off_1009F7ED8;
          int v46 = sub_100031234(uu);
          sub_10004191C(v59, "IsAppleWatch");
          if (sub_100030A04((uint64_t)v45, v46, (uint64_t)v59))
          {
            int v47 = 1;
          }
          else
          {
            if (qword_1009F7EE0 != -1) {
              dispatch_once(&qword_1009F7EE0, &stru_1009BFD48);
            }
            uint64_t v50 = off_1009F7ED8;
            id v51 = sub_100031234(uu);
            int v47 = sub_1006BDD68((uint64_t)v50, v51);
          }
          if (v60 < 0) {
            operator delete(v59[0]);
          }

          if (v47)
          {
            if (qword_1009F7EE0 != -1) {
              dispatch_once(&qword_1009F7EE0, &stru_1009BFD48);
            }
            sub_1006C0A24((uint64_t)off_1009F7ED8, uu, a3);
            sub_100019878();
            operator new();
          }
          sub_100019878();
          operator new();
        }
      }
      *(void *)src = uu;
      __int16 v52 = sub_10071B0A4((uint64_t **)(a1 + 440), uu, (uint64_t)&unk_1007BE9D0, (const unsigned __int8 *__attribute__((__org_typedef(uuid_t))) *)src);
      sub_100049EE0((uint64_t)(v52 + 6), (uint64_t)&buf);
      sub_10071B5BC(v56, v57);
      sub_100019878();
      operator new();
    }
    *(void *)src = 0;
    *(void *)&src[8] = 0;
    operator new();
  }
  BOOL v13 = qword_100A19E80;
  if (os_log_type_enabled((os_log_t)qword_100A19E80, OS_LOG_TYPE_INFO))
  {
    uint64_t v14 = sub_1006AD3F0();
    *(_DWORD *)src = 138543362;
    *(void *)&src[4] = v14;
    _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_INFO, "Device \"%{public}@\" finished pairing but wasn't being tracked by device manager, ignoring this event", src, 0xCu);
  }
}

void sub_10070B788(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,void *a25,uint64_t a26,int a27,__int16 a28,char a29,char a30,void *__p,uint64_t a32,int a33,__int16 a34,char a35,char a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,void *a45,uint64_t a46,int a47,__int16 a48,char a49,char a50,char a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61)
{
  sub_10003AFB4((uint64_t)&a51);
  _Unwind_Resume(a1);
}

uint64_t sub_10070BC30(uint64_t a1, unsigned __int8 *a2)
{
  v27[0] = 0;
  v27[1] = 0;
  sub_10003AED0((uint64_t)v27, a1 + 48);
  if (((char)a2[23] & 0x80000000) == 0)
  {
    if (a2[23]) {
      goto LABEL_3;
    }
LABEL_38:
    if (os_log_type_enabled((os_log_t)qword_100A19E80, OS_LOG_TYPE_FAULT)) {
      sub_100797FDC();
    }
    goto LABEL_40;
  }
  if (!*((void *)a2 + 1)) {
    goto LABEL_38;
  }
LABEL_3:
  id v3 = *(const unsigned __int8 **)(a1 + 440);
  if (v3 == (const unsigned __int8 *)(a1 + 448))
  {
LABEL_35:
    unint64_t v19 = qword_100A19E80;
    if (os_log_type_enabled((os_log_t)qword_100A19E80, OS_LOG_TYPE_ERROR)) {
      sub_100798010((char *)a2 + 23, a2, v19);
    }
LABEL_40:
    uint64_t v20 = 0;
    goto LABEL_41;
  }
  while (1)
  {
    memset(dst, 0, sizeof(dst));
    uuid_copy(dst, v3 + 32);
    if (qword_1009F7EE0 != -1) {
      dispatch_once(&qword_1009F7EE0, &stru_1009BFD48);
    }
    id v4 = off_1009F7ED8;
    uint64_t v5 = sub_100031234(dst);
    sub_1006BE7F4((uint64_t)v4, v5, (uint64_t)&__s1);
    if ((v26 & 0x80u) == 0) {
      size_t v6 = v26;
    }
    else {
      size_t v6 = __n;
    }
    uint64_t v7 = a2[23];
    int v8 = (char)v7;
    if ((v7 & 0x80u) != 0) {
      uint64_t v7 = *((void *)a2 + 1);
    }
    if (v6 != v7)
    {
      if ((v26 & 0x80) != 0) {
        operator delete(__s1);
      }

      goto LABEL_29;
    }
    if (v8 >= 0) {
      uint64_t v9 = a2;
    }
    else {
      uint64_t v9 = *(unsigned __int8 **)a2;
    }
    if ((v26 & 0x80) != 0)
    {
      BOOL v15 = __s1;
      BOOL v16 = memcmp(__s1, v9, __n) == 0;
      operator delete(v15);

      if (v16) {
        goto LABEL_43;
      }
      goto LABEL_29;
    }
    if (!v26) {
      break;
    }
    uint64_t v10 = 0;
    do
    {
      int v11 = *((unsigned __int8 *)&__s1 + v10);
      int v12 = v9[v10];
      BOOL v13 = v11 != v12 || v26 - 1 == v10++;
    }
    while (!v13);
    BOOL v14 = v11 != v12;

    if (!v14) {
      goto LABEL_43;
    }
LABEL_29:
    uint64_t v17 = (unsigned __int8 *)*((void *)v3 + 1);
    if (v17)
    {
      do
      {
        int v18 = (const unsigned __int8 **)v17;
        uint64_t v17 = *(unsigned __int8 **)v17;
      }
      while (v17);
    }
    else
    {
      do
      {
        int v18 = (const unsigned __int8 **)*((void *)v3 + 2);
        BOOL v13 = *v18 == v3;
        id v3 = (const unsigned __int8 *)v18;
      }
      while (!v13);
    }
    id v3 = (const unsigned __int8 *)v18;
    if (v18 == (const unsigned __int8 **)(a1 + 448)) {
      goto LABEL_35;
    }
  }

LABEL_43:
  char v22 = sub_100031234(dst);
  sub_10070BF0C(a1, v22);

  uint64_t v20 = 1;
LABEL_41:
  sub_10003AFB4((uint64_t)v27);
  return v20;
}

void sub_10070BED0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);

  sub_10003AFB4((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_10070BF0C(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (sub_100008DC4(a1, v3))
  {
    id v4 = qword_100A19E80;
    if (os_log_type_enabled((os_log_t)qword_100A19E80, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 138543362;
      *(void *)&uint8_t buf[4] = v3;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Unpairing device \"%{public}@\"", buf, 0xCu);
    }
    v39[0] = 0;
    v39[1] = 0;
    sub_10003AED0((uint64_t)v39, a1 + 48);
    if (qword_1009F7EE0 != -1) {
      dispatch_once(&qword_1009F7EE0, &stru_1009BFD48);
    }
    uint64_t v5 = sub_100030DCC((uint64_t)off_1009F7ED8, v3, 0);
    uint64_t v6 = sub_1002284B8(v5);
    int v36 = v6;
    char v38 = BYTE6(v6);
    __int16 v37 = WORD2(v6);
    if (sub_10070C8C8(a1, v3))
    {
      sub_1000305AC(buf, v3);
      uint64_t v7 = (uint64_t *)sub_1000308C0(a1 + 440, buf);
      uint64_t v8 = v7[7];
      *(void *)long long buf = &off_1009B4578;
      *(void *)&uint8_t buf[8] = v8;
      if (v8) {
        sub_100037354(v8);
      }
      if (*(unsigned char *)(a1 + 41))
      {
        unint64_t v41 = 0;
        BOOL v42 = 0;
        sub_1003BC0D4(*(uint64_t *)&buf[8], 10, &v41);
        BOOL v9 = sub_100013DCC((uint64_t)&v41);
        if (!v9)
        {
          sub_100019878();
          operator new();
        }
        sub_10070D770(v9, &v36);
        unint64_t v41 = &off_100998428;
        if (v42) {
          sub_1000368F4(v42);
        }
      }
      sub_10071B5BC((uint64_t **)(a1 + 440), v7);
      *(void *)long long buf = &off_1009B4578;
      if (*(void *)&buf[8]) {
        sub_1000368F4(*(atomic_uint **)&buf[8]);
      }
    }
    if (qword_1009F7EE0 != -1) {
      dispatch_once(&qword_1009F7EE0, &stru_1009BFD48);
    }
    uint64_t v10 = off_1009F7ED8;
    sub_1000305AC(buf, v3);
    if (sub_1006C0274((uint64_t)v10, buf, v5))
    {
      if (os_log_type_enabled((os_log_t)qword_100A19E80, OS_LOG_TYPE_ERROR))
      {
        sub_1006AD3F0();
        objc_claimAutoreleasedReturnValue();
        sub_100798090();
      }
    }
    else
    {
      uint64_t v17 = sub_100035F54();
      int v18 = (*(uint64_t (**)(uint64_t))(*(void *)v17 + 352))(v17);
      sub_1003131C8(v5, 0, v18);
      unint64_t v19 = qword_100A19E80;
      if (os_log_type_enabled((os_log_t)qword_100A19E80, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v20 = *(void *)(a1 + 456);
        *(_DWORD *)long long buf = 134217984;
        *(void *)&uint8_t buf[4] = v20;
        _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "Number of LE Paired devices:%lu", buf, 0xCu);
      }
    }
    if (qword_1009F7EE0 != -1) {
      dispatch_once(&qword_1009F7EE0, &stru_1009BFD48);
    }
    unint64_t v21 = off_1009F7ED8;
    sub_10004191C(__p, "_CTKD_");
    int v22 = sub_100030A04((uint64_t)v21, v3, (uint64_t)__p);
    int v23 = v22;
    if (v35 < 0)
    {
      operator delete(__p[0]);
      if (v23) {
        goto LABEL_37;
      }
    }
    else if (v22)
    {
LABEL_37:
      uint64_t v24 = qword_100A19E80;
      if (os_log_type_enabled((os_log_t)qword_100A19E80, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "Removing _CTKD_ Tag", buf, 2u);
      }
      if (qword_1009F7EE0 != -1) {
        dispatch_once(&qword_1009F7EE0, &stru_1009BFD48);
      }
      sub_1006B85C0((uint64_t)off_1009F7ED8, v3, @"_CTKD_");
      if (qword_1009F8768 != -1) {
        dispatch_once(&qword_1009F8768, &stru_1009BFD88);
      }
      sub_100610F18(off_1009F8760, v5);
      goto LABEL_64;
    }
    if (_os_feature_enabled_impl())
    {
      if (qword_1009F7EE0 != -1) {
        dispatch_once(&qword_1009F7EE0, &stru_1009BFD48);
      }
      uint64_t v25 = sub_1006BE4EC((uint64_t)off_1009F7ED8, v3, @"ASK_LINKED_RADIO_ADDRESS");
      if (qword_1009F7EE0 != -1) {
        dispatch_once(&qword_1009F7EE0, &stru_1009BFD48);
      }
      unsigned __int8 v26 = off_1009F7ED8;
      sub_10004191C(v32, "DA_ASK_RETAIN_DEVICE");
      int v27 = sub_100030A04((uint64_t)v26, v3, (uint64_t)v32);
      if (v33 < 0) {
        operator delete(v32[0]);
      }
      uint64_t v28 = qword_100A19E80;
      if (os_log_type_enabled((os_log_t)qword_100A19E80, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)long long buf = 138412546;
        *(void *)&uint8_t buf[4] = v25;
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = v27;
        _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, "ASKLinkedRadioAddressString:%@ hasTag:%d", buf, 0x12u);
      }
      if (v25) {
        int v29 = v27;
      }
      else {
        int v29 = 0;
      }
      if (v29 == 1)
      {
        unint64_t v30 = sub_1006ADA24(v25);
        if (qword_1009F8768 != -1) {
          dispatch_once(&qword_1009F8768, &stru_1009BFD88);
        }
        sub_100610F18(off_1009F8760, v30);
        if (qword_1009F7EE0 != -1) {
          dispatch_once(&qword_1009F7EE0, &stru_1009BFD48);
        }
        sub_1006BE60C((uint64_t)off_1009F7ED8, v3, @"ASK_LINKED_RADIO_ADDRESS", 0);
      }
    }
LABEL_64:
    if (qword_1009F7F10 != -1) {
      dispatch_once(&qword_1009F7F10, &stru_1009BFDA8);
    }
    uint64_t v31 = qword_1009F7F08;
    sub_1000305AC(buf, v3);
    sub_10063FC28(v31, a1 + 8, buf);
  }
  unsigned int v11 = [*(id *)(a1 + 3752) containsObject:v3];
  int v12 = qword_100A19E80;
  BOOL v13 = os_log_type_enabled((os_log_t)qword_100A19E80, OS_LOG_TYPE_DEFAULT);
  if (v11)
  {
    if (v13)
    {
      *(_DWORD *)long long buf = 138543362;
      *(void *)&uint8_t buf[4] = v3;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "Device \"%{public}@\" is still in the process of unpairing, ignore this request, wait for BMS to complete or a disconnection", buf, 0xCu);
    }
  }
  else
  {
    if (v13)
    {
      *(_DWORD *)long long buf = 138543362;
      *(void *)&uint8_t buf[4] = v3;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "Device \"%{public}@\" isn't paired", buf, 0xCu);
    }
    sub_1007057D4(a1, v3, 0);
    sub_1000305AC(buf, v3);
    uint64_t v14 = sub_1000308C0(a1 + 440, buf);
    BOOL v15 = (uint64_t *)v14;
    if (a1 + 448 != v14)
    {
      uint64_t v16 = *(void *)(v14 + 56);
      *(void *)long long buf = &off_1009B4578;
      *(void *)&uint8_t buf[8] = v16;
      if (v16) {
        sub_100037354(v16);
      }
      sub_10071B5BC((uint64_t **)(a1 + 440), v15);
      *(void *)long long buf = &off_1009B4578;
      if (*(void *)&buf[8]) {
        sub_1000368F4(*(atomic_uint **)&buf[8]);
      }
    }
  }
}

void sub_10070C6E4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,char a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30)
{
  _Unwind_Resume(a1);
}

uint64_t sub_10070C7E4(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (*(unsigned char *)(a1 + 41))
  {
    if (qword_1009F7EE0 != -1) {
      dispatch_once(&qword_1009F7EE0, &stru_1009BFD48);
    }
    unint64_t v4 = sub_100030DCC((uint64_t)off_1009F7ED8, v3, 0);
    uint64_t v5 = sub_1002284B8(v4);
    int v9 = v5;
    char v11 = BYTE6(v5);
    __int16 v10 = WORD2(v5);
    char v8 = 0;
    sub_10001B8E0(&v8);
    uint64_t v6 = sub_100237AD0(&v9);
    sub_10001B8AC(&v8);
  }
  else
  {
    uint64_t v6 = 0;
  }

  return v6;
}

void sub_10070C8A0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, int a9, __int16 a10, char a11, char a12)
{
  sub_10001B8AC(&a12);

  _Unwind_Resume(a1);
}

BOOL sub_10070C8C8(uint64_t a1, void *a2)
{
  id v3 = a2;
  v7[0] = 0;
  v7[1] = 0;
  sub_10003AED0((uint64_t)v7, a1 + 48);
  sub_1000305AC(uu2, v3);
  uint64_t v4 = sub_1000308C0(a1 + 440, uu2);
  if (a1 + 448 == v4)
  {
    BOOL v5 = 0;
  }
  else
  {
    *(void *)uu2 = 0;
    int v9 = 0;
    sub_1003BC0D4(*(void *)(v4 + 56), 17, uu2);
    BOOL v5 = sub_100013DCC((uint64_t)uu2);
    *(void *)uu2 = &off_100998428;
    if (v9) {
      sub_1000368F4(v9);
    }
  }
  sub_10003AFB4((uint64_t)v7);

  return v5;
}

void sub_10070C9C4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, uint64_t a11, uint64_t (**a12)(), atomic_uint *a13)
{
  a12 = &off_100998428;
  if (a13) {
    sub_1000368F4(a13);
  }
  sub_10003AFB4((uint64_t)&a10);

  _Unwind_Resume(a1);
}

id sub_10070CA20(uint64_t a1)
{
  char v2 = +[NSMutableArray array];
  v11[0] = 0;
  v11[1] = 0;
  sub_10003AED0((uint64_t)v11, a1 + 48);
  id v3 = *(const unsigned __int8 **)(a1 + 440);
  if (v3 != (const unsigned __int8 *)(a1 + 448))
  {
    do
    {
      uint64_t v4 = sub_100031234(v3 + 32);
      BOOL v5 = sub_100008DC4(a1, v4);

      if (v5)
      {
        uint64_t v6 = sub_100031234(v3 + 32);
        [v2 addObject:v6];
      }
      uint64_t v7 = (unsigned __int8 *)*((void *)v3 + 1);
      if (v7)
      {
        do
        {
          char v8 = (const unsigned __int8 **)v7;
          uint64_t v7 = *(unsigned __int8 **)v7;
        }
        while (v7);
      }
      else
      {
        do
        {
          char v8 = (const unsigned __int8 **)*((void *)v3 + 2);
          BOOL v9 = *v8 == v3;
          id v3 = (const unsigned __int8 *)v8;
        }
        while (!v9);
      }
      id v3 = (const unsigned __int8 *)v8;
    }
    while (v8 != (const unsigned __int8 **)(a1 + 448));
  }
  sub_10003AFB4((uint64_t)v11);

  return v2;
}

void sub_10070CB34(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id sub_10070CB6C(uint64_t a1)
{
  char v2 = +[NSMutableArray array];
  v11[0] = 0;
  v11[1] = 0;
  sub_10003AED0((uint64_t)v11, a1 + 48);
  id v3 = *(const unsigned __int8 **)(a1 + 440);
  if (v3 != (const unsigned __int8 *)(a1 + 448))
  {
    do
    {
      uint64_t v4 = sub_100031234(v3 + 32);
      if (sub_100008DC4(a1, v4))
      {
        if (qword_1009F7EE0 != -1) {
          dispatch_once(&qword_1009F7EE0, &stru_1009BFD48);
        }
        BOOL v5 = off_1009F7ED8;
        uint64_t v6 = sub_100031234(v3 + 32);
        LODWORD(v5) = sub_1006BE998((uint64_t)v5, v6);

        if (!v5) {
          goto LABEL_8;
        }
        uint64_t v4 = sub_100031234(v3 + 32);
        [v2 addObject:v4];
      }

LABEL_8:
      uint64_t v7 = (unsigned __int8 *)*((void *)v3 + 1);
      if (v7)
      {
        do
        {
          char v8 = (const unsigned __int8 **)v7;
          uint64_t v7 = *(unsigned __int8 **)v7;
        }
        while (v7);
      }
      else
      {
        do
        {
          char v8 = (const unsigned __int8 **)*((void *)v3 + 2);
          BOOL v9 = *v8 == v3;
          id v3 = (const unsigned __int8 *)v8;
        }
        while (!v9);
      }
      id v3 = (const unsigned __int8 *)v8;
    }
    while (v8 != (const unsigned __int8 **)(a1 + 448));
  }
  sub_10003AFB4((uint64_t)v11);

  return v2;
}

void sub_10070CCE0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_10070CD1C(uint64_t a1, void *a2)
{
  id v3 = a2;
  v6[0] = 0;
  v6[1] = 0;
  sub_10003AED0((uint64_t)v6, a1 + 48);
  uint64_t v4 = qword_100A19E80;
  if (os_log_type_enabled((os_log_t)qword_100A19E80, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 138543362;
    id v8 = v3;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Device \"%{public}@\" is tagged as a watch", buf, 0xCu);
  }
  if (qword_1009F7EE0 != -1) {
    dispatch_once(&qword_1009F7EE0, &stru_1009BFD48);
  }
  unint64_t v5 = sub_100030DCC((uint64_t)off_1009F7ED8, v3, 0);
  sub_10070CE60(a1, v5, 0xAu);
  sub_10003AFB4((uint64_t)v6);
}

void sub_10070CE38(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t sub_10070CE60(uint64_t a1, unint64_t a2, unsigned int a3)
{
  v21[0] = 0;
  v21[1] = 0;
  sub_10003AED0((uint64_t)v21, a1 + 48);
  unint64_t v5 = qword_100A19E80;
  if (os_log_type_enabled((os_log_t)qword_100A19E80, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v6 = sub_1006AD3F0();
    *(_DWORD *)long long buf = 67109378;
    *(_DWORD *)&uint8_t buf[4] = a3;
    *(_WORD *)int v23 = 2114;
    *(void *)&v23[2] = v6;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "Adding keys %d to synced keychain for device \"%{public}@\" tagged as a watch", buf, 0x12u);
  }
  unint64_t v19 = 0;
  uint64_t v20 = 0;
  uint64_t v18 = 0;
  signed int v7 = a3 - 1;
  if (a3 - 1 < 0x10 && ((0x81EFu >> v7) & 1) != 0)
  {
    unsigned int v8 = dword_1007C06E8[v7];
  }
  else if ((a3 & 0xFFFFFFFE) == 0xE)
  {
    unsigned int v8 = 4;
  }
  else
  {
    unsigned int v8 = 16;
  }
  uint64_t v17 = 0;
  BOOL v9 = qword_100A19E80;
  if (os_log_type_enabled((os_log_t)qword_100A19E80, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "addKeyToSyncedKeychainForDevice is calling BTKCCopyLEData", buf, 2u);
  }
  v24[0] = 0;
  v24[1] = 0;
  if (qword_1009F7EE0 != -1) {
    dispatch_once(&qword_1009F7EE0, &stru_1009BFD48);
  }
  sub_100014B58((uint64_t)off_1009F7ED8, a2, 0, 1u, 0, 0, (unsigned __int8 *)v24);
  sub_100031234((const unsigned __int8 *)v24);

  sub_100313010(a2, a3, (uint64_t)&v20, (_DWORD *)&v18 + 1, (_DWORD *)&v17 + 1, (uint64_t)&v19, &v18, &v17);
  int v10 = HIDWORD(v18);
  if (!HIDWORD(v17) && HIDWORD(v18))
  {
    char v11 = qword_100A19E80;
    if (os_log_type_enabled((os_log_t)qword_100A19E80, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 67109632;
      *(_DWORD *)&uint8_t buf[4] = v17;
      *(_WORD *)int v23 = 1024;
      *(_DWORD *)&v23[2] = v10;
      *(_WORD *)&v23[6] = 1024;
      *(_DWORD *)&v23[8] = v18;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "Found key in local Keychain syncedStatus=%d localLen=%d syncedLen=%d", buf, 0x14u);
      int v10 = HIDWORD(v18);
    }
    if (v10 == v8)
    {
      if (v17 || memcmp(v20, v19, v8))
      {
        *(void *)long long buf = 0;
        *(void *)int v23 = 0;
        if (qword_1009F7EE0 != -1) {
          dispatch_once(&qword_1009F7EE0, &stru_1009BFD48);
        }
        sub_100014B58((uint64_t)off_1009F7ED8, a2, 0, 1u, 0, 0, buf);
        int v12 = sub_100031234(buf);
        sub_100312C44(a2, v12, a3, v20, HIDWORD(v18), 1);

        BOOL v13 = qword_100A19E80;
        if (os_log_type_enabled((os_log_t)qword_100A19E80, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)uint64_t v16 = 0;
          _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "Added Key to synced keychain", v16, 2u);
        }
      }
    }
    else
    {
      uint64_t v14 = qword_100A19E80;
      if (!os_log_type_enabled((os_log_t)qword_100A19E80, OS_LOG_TYPE_FAULT)) {
        goto LABEL_26;
      }
      *(_DWORD *)long long buf = 67109632;
      *(_DWORD *)&uint8_t buf[4] = a3;
      *(_WORD *)int v23 = 1024;
      *(_DWORD *)&v23[2] = v8;
      *(_WORD *)&v23[6] = 1024;
      *(_DWORD *)&v23[8] = v10;
      _os_log_fault_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_FAULT, "Ignoring data of invalid length for key type %d - expected %d byte(s), read %d byte(s)", buf, 0x14u);
    }
    int v10 = HIDWORD(v18);
  }
LABEL_26:
  if (v10 && v20) {
    operator delete[]();
  }
  if (v18 && v19) {
    operator delete[]();
  }
  return sub_10003AFB4((uint64_t)v21);
}

void sub_10070D260(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);

  sub_10003AFB4((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_10070D294(uint64_t a1, void *a2)
{
  id v3 = a2;
  v6[0] = 0;
  v6[1] = 0;
  sub_10003AED0((uint64_t)v6, a1 + 48);
  uint64_t v4 = qword_100A19E80;
  if (os_log_type_enabled((os_log_t)qword_100A19E80, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 138543362;
    id v8 = v3;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Device \"%{public}@\" is untagged as a watch", buf, 0xCu);
  }
  if (qword_1009F7EE0 != -1) {
    dispatch_once(&qword_1009F7EE0, &stru_1009BFD48);
  }
  uint64_t v5 = sub_100030DCC((uint64_t)off_1009F7ED8, v3, 0);
  sub_10070D3D8(a1, v5, 0xAu);
  sub_10003AFB4((uint64_t)v6);
}

void sub_10070D3B0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t sub_10070D3D8(uint64_t a1, uint64_t a2, unsigned int a3)
{
  v17[0] = 0;
  v17[1] = 0;
  sub_10003AED0((uint64_t)v17, a1 + 48);
  uint64_t v6 = qword_100A19E80;
  if (os_log_type_enabled((os_log_t)qword_100A19E80, OS_LOG_TYPE_INFO))
  {
    signed int v7 = sub_1006AD3F0();
    *(_DWORD *)long long buf = 67109378;
    *(_DWORD *)&uint8_t buf[4] = a3;
    LOWORD(v19[0]) = 2114;
    *(void *)((char *)v19 + 2) = v7;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_INFO, "removing keys %d from synced keychain for device \"%{public}@\" tagged as a watch", buf, 0x12u);

    uint64_t v6 = qword_100A19E80;
  }
  uint64_t v15 = 0;
  uint64_t v16 = 0;
  if (os_log_type_enabled(v6, OS_LOG_TYPE_INFO))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_INFO, "removeKeyFromSyncedKeychainForDevice is calling BTKCCopyLEData", buf, 2u);
  }
  *(void *)long long buf = 0;
  v19[0] = 0;
  if (qword_1009F7EE0 != -1) {
    dispatch_once(&qword_1009F7EE0, &stru_1009BFD48);
  }
  sub_100014B58(buf, off_1009F7ED8, a2, 0, 1, 0, 0);
  sub_100031234(buf);

  sub_100313010(a2, a3, 0, 0, 0, (uint64_t)&v16, (_DWORD *)&v15 + 1, &v15);
  if (!v15 && HIDWORD(v15))
  {
    id v8 = qword_100A19E80;
    if (os_log_type_enabled((os_log_t)qword_100A19E80, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t v14 = 0;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "Found key", v14, 2u);
    }
    BOOL v9 = sub_100031234(buf);
    sub_100312C44(a2, v9, a3, v16, 0, 1);

    int v10 = qword_100A19E80;
    if (os_log_type_enabled((os_log_t)qword_100A19E80, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t v14 = 0;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "Moved Key", v14, 2u);
    }
    char v11 = sub_100031234(buf);
    BOOL v12 = sub_100008DC4(a1, v11);

    if (!v12)
    {
      if (a3 == 10 && *(unsigned char *)(a1 + 41))
      {
        sub_100019878();
        operator new();
      }
      sub_1003131C8(a2, 0, 1);
    }
    if (v16) {
      operator delete[]();
    }
  }
  return sub_10003AFB4((uint64_t)v17);
}

void sub_10070D730(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  sub_10003AFB4((uint64_t)va);
  _Unwind_Resume(a1);
}

BOOL sub_10070D770(uint64_t a1, _DWORD *a2)
{
  id v3 = qword_100A19E80;
  if (os_log_type_enabled((os_log_t)qword_100A19E80, OS_LOG_TYPE_DEFAULT))
  {
    sub_10004BDF8();
    uint64_t v4 = v11 >= 0 ? __p : (void **)__p[0];
    *(_DWORD *)long long buf = 136446210;
    BOOL v13 = v4;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Removing \"%{public}s\" from the cache.", buf, 0xCu);
    if (v11 < 0) {
      operator delete(__p[0]);
    }
  }
  char v9 = 0;
  sub_10001B8E0(&v9);
  int v5 = sub_1002354D8(a2);
  sub_10001B910(&v9);
  uint64_t v6 = qword_100A19E80;
  if (os_log_type_enabled((os_log_t)qword_100A19E80, OS_LOG_TYPE_DEFAULT))
  {
    sub_10004BDF8();
    if (v11 >= 0) {
      signed int v7 = __p;
    }
    else {
      signed int v7 = (void **)__p[0];
    }
    *(_DWORD *)long long buf = 136446210;
    BOOL v13 = v7;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "Removed \"%{public}s\" from the cache.", buf, 0xCu);
    if (v11 < 0) {
      operator delete(__p[0]);
    }
  }
  sub_10001B8AC(&v9);
  return v5 == 0;
}

void sub_10070D938(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, int a9, __int16 a10, char a11, char a12)
{
}

unsigned char *sub_10070D958(uint64_t a1, uint64_t a2)
{
  id v3 = qword_100A19E80;
  if (os_log_type_enabled((os_log_t)qword_100A19E80, OS_LOG_TYPE_DEFAULT))
  {
    int v8 = 67109120;
    int v9 = a2;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "setPrivateModeEnabled %d", (uint8_t *)&v8, 8u);
  }
  uint64_t v4 = sub_10003FB34();
  int v5 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v4 + 1824))(v4, a2);
  uint64_t v6 = qword_100A19E80;
  if (os_log_type_enabled((os_log_t)qword_100A19E80, OS_LOG_TYPE_DEFAULT))
  {
    int v8 = 67109376;
    int v9 = a2;
    __int16 v10 = 1024;
    int v11 = v5;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "enable2MBPHYForDenylistedDevices %d returned %d", (uint8_t *)&v8, 0xEu);
  }
  LOBYTE(v8) = 0;
  sub_10001B8E0(&v8);
  sub_100229480(a2);
  sub_10001B910(&v8);
  return sub_10001B8AC(&v8);
}

void sub_10070DAB4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
}

uint64_t sub_10070DAD0(uint64_t a1)
{
  return (*(uint64_t (**)(void, void))(**(void **)(a1 + 40) + 8))(*(void *)(a1 + 40), *(void *)(a1 + 32));
}

void sub_10070DAFC(uint64_t a1)
{
  if (qword_1009F7F10 != -1) {
    dispatch_once(&qword_1009F7F10, &stru_1009BFDA8);
  }
  uint64_t v2 = qword_1009F7F08;
  id v3 = *(void **)(a1 + 32);

  sub_1006386B4(v2, v3);
}

void sub_10070DB60(uint64_t a1, uint64_t a2)
{
  if (!*(_WORD *)(a1 + 594) || *(unsigned char *)(a1 + 596))
  {
    *(_WORD *)(a1 + 594) = a2;
    sub_10070D958(a1, 1);
    sub_100019878();
    operator new();
  }
  uint64_t v4 = qword_100A19E80;
  if (os_log_type_enabled((os_log_t)qword_100A19E80, OS_LOG_TYPE_ERROR)) {
    sub_1007980D8(a2, v4, v5, v6, v7, v8, v9, v10);
  }
  *(unsigned char *)(a1 + 596) = 1;
  *(_WORD *)(a1 + 594) = a2;
}

void sub_10070DC6C(id a1)
{
  if (qword_1009F7EC0 != -1) {
    dispatch_once(&qword_1009F7EC0, &stru_1009BFD68);
  }
  long long v1 = off_1009F7EB8;

  sub_10069963C((uint64_t)v1, 1);
}

void sub_10070DCC4(uint64_t a1)
{
  if (*(_WORD *)(a1 + 594))
  {
    int v2 = *(unsigned __int8 *)(a1 + 596);
    id v3 = qword_100A19E80;
    BOOL v4 = os_log_type_enabled((os_log_t)qword_100A19E80, OS_LOG_TYPE_DEFAULT);
    if (v2)
    {
      if (v4)
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Renew private mode.", buf, 2u);
      }
      sub_100019878();
      operator new();
    }
    if (v4)
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Disable private mode.", buf, 2u);
    }
    *(_WORD *)(a1 + 594) = 0;
    long long v13 = 0u;
    long long v14 = 0u;
    long long v15 = 0u;
    long long v16 = 0u;
    if (qword_1009F7ED0 != -1) {
      dispatch_once(&qword_1009F7ED0, &stru_1009BFD08);
    }
    uint64_t v6 = sub_10070CA20(qword_1009F7EC8);
    id v7 = [v6 countByEnumeratingWithState:&v13 objects:v18 count:16];
    if (v7)
    {
      uint64_t v8 = *(void *)v14;
      do
      {
        uint64_t v9 = 0;
        do
        {
          if (*(void *)v14 != v8) {
            objc_enumerationMutation(v6);
          }
          uint64_t v10 = *(void **)(*((void *)&v13 + 1) + 8 * (void)v9);
          if (qword_1009F7EE0 != -1) {
            dispatch_once(&qword_1009F7EE0, &stru_1009BFD48);
          }
          sub_1006B85C0((uint64_t)off_1009F7ED8, v10, @"PrivateModeDevice");
          uint64_t v9 = (char *)v9 + 1;
        }
        while (v7 != v9);
        id v7 = [v6 countByEnumeratingWithState:&v13 objects:v18 count:16];
      }
      while (v7);
    }

    sub_10070D958(v11, 0);
    uint64_t v12 = sub_100019878();
    sub_100013018(v12, &stru_1009BFB88);
  }
  else
  {
    uint64_t v5 = qword_100A19E80;
    if (os_log_type_enabled((os_log_t)qword_100A19E80, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "Private mode has already been disabled. Nothing more to do here", buf, 2u);
    }
  }
}

void sub_10070DF8C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_10070DFAC(id a1)
{
  if (qword_1009F7EC0 != -1) {
    dispatch_once(&qword_1009F7EC0, &stru_1009BFD68);
  }
  long long v1 = off_1009F7EB8;

  sub_10069963C((uint64_t)v1, 0);
}

void sub_10070E004(uint64_t a1, void *a2)
{
  id v3 = a2;
  [*(id *)(a1 + 3752) removeObject:];
  sub_1007057D4(a1, v3, 1);
}

void sub_10070E064(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_10070E078(uint64_t a1, void *a2)
{
}

uint64_t sub_10070E080(uint64_t a1, unint64_t a2, uint64_t a3, unsigned int **a4, int a5)
{
  v23[0] = 0;
  v23[1] = 0;
  sub_10003AED0((uint64_t)v23, a1 + 48);
  uint64_t v9 = qword_100A19E80;
  if (os_log_type_enabled((os_log_t)qword_100A19E80, OS_LOG_TYPE_INFO))
  {
    sub_1006ACF44();
    uint64_t v10 = v29 >= 0 ? __p : *(unsigned char **)__p;
    uint64_t v11 = a5 ? "YES" : "NO";
    *(_DWORD *)long long buf = 136446466;
    *(void *)&uint8_t buf[4] = v10;
    __int16 v25 = 2082;
    unsigned __int8 v26 = v11;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_INFO, "readKeyForDevice address:%{public}s syncedKeychain:%{public}s", buf, 0x16u);
    if (SHIBYTE(v29) < 0) {
      operator delete(*(void **)__p);
    }
  }
  unint64_t v21 = 0;
  CFTypeRef cf = 0;
  uint64_t v20 = 0;
  v35[0] = 0;
  v35[1] = 0;
  if (qword_1009F7EE0 != -1) {
    dispatch_once(&qword_1009F7EE0, &stru_1009BFD48);
  }
  sub_100014B58((uint64_t)off_1009F7ED8, a2, 0, 1u, 0, 0, (unsigned __int8 *)v35);
  sub_100031234((const unsigned __int8 *)v35);

  uint64_t v12 = *a4;
  long long v13 = a4[1];
  if (*a4 != v13)
  {
    if (a5) {
      long long v14 = "YES";
    }
    else {
      long long v14 = "NO";
    }
    do
    {
      int v15 = *v12;
      sub_100312FB0(a2, *v12, (uint64_t)&v21, (_DWORD *)&v20 + 1, &v20, a5, (const __CFDictionary **)&cf);
      long long v16 = qword_100A19E80;
      if (os_log_type_enabled((os_log_t)qword_100A19E80, OS_LOG_TYPE_INFO))
      {
        sub_1006ACF44();
        uint64_t v17 = buf;
        if (v27 < 0) {
          uint64_t v17 = *(unsigned char **)buf;
        }
        *(_DWORD *)__p = 136447234;
        *(void *)&__p[4] = v17;
        *(_WORD *)&__p[12] = 2082;
        *(void *)&__p[14] = v14;
        __int16 v29 = 1024;
        int v30 = v15;
        __int16 v31 = 1024;
        int v32 = v20;
        __int16 v33 = 1024;
        int v34 = HIDWORD(v20);
        _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_INFO, "readKeyForDevice BTKCCopyLEDataEx address:%{public}s synced:%{public}s type:%d status:%d dataLen:%d", __p, 0x28u);
        if (v27 < 0) {
          operator delete(*(void **)buf);
        }
      }
      if (!v20 && HIDWORD(v20))
      {
        uint64_t v18 = *(void *)(a3 + 8);
        sub_1000335D8(__p, v21, HIDWORD(v20));
        sub_1003BB660(v18, v15, (uint64_t)__p);
        *(void *)__p = &off_100998428;
        if (*(void *)&__p[8]) {
          sub_1000368F4(*(atomic_uint **)&__p[8]);
        }
        if (v21) {
          operator delete[]();
        }
      }
      ++v12;
    }
    while (v12 != v13);
    if (cf) {
      CFRelease(cf);
    }
  }
  return sub_10003AFB4((uint64_t)v23);
}

void sub_10070E3A0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  sub_10003AFB4((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_10070E404(uint64_t a1, unint64_t a2, uint64_t a3, unsigned int a4, int a5)
{
  v35[0] = 0;
  v35[1] = 0;
  sub_10003AED0((uint64_t)v35, a1 + 48);
  __int16 v33 = 0;
  int v34 = 0;
  uint64_t v32 = 0;
  unsigned int v10 = a4 - 1;
  if (a4 - 1 < 0x10 && ((0x81EFu >> v10) & 1) != 0)
  {
    unsigned int v11 = dword_1007C06E8[v10];
  }
  else if ((a4 & 0xFFFFFFFE) == 0xE)
  {
    unsigned int v11 = 4;
  }
  else
  {
    unsigned int v11 = 16;
  }
  uint64_t v31 = 0;
  v47[0] = 0;
  v47[1] = 0;
  if (qword_1009F7EE0 != -1) {
    dispatch_once(&qword_1009F7EE0, &stru_1009BFD48);
  }
  sub_100014B58((uint64_t)off_1009F7ED8, a2, 0, 1u, 0, 0, (unsigned __int8 *)v47);
  sub_100031234((const unsigned __int8 *)v47);

  sub_100313010(a2, a4, (uint64_t)&v34, (_DWORD *)&v32 + 1, (_DWORD *)&v31 + 1, (uint64_t)&v33, &v32, &v31);
  uint64_t v12 = qword_100A19E80;
  if (os_log_type_enabled((os_log_t)qword_100A19E80, OS_LOG_TYPE_INFO))
  {
    sub_1006ACF44();
    p_p = __p;
    long long v14 = "NO";
    if (v30 >= 0) {
      p_p = &__p;
    }
    if (a5) {
      long long v14 = "YES";
    }
    *(_DWORD *)long long buf = 136447746;
    *(void *)&uint8_t buf[4] = p_p;
    *(_WORD *)&unsigned char buf[12] = 2082;
    *(void *)&buf[14] = v14;
    __int16 v37 = 1024;
    unsigned int v38 = a4;
    __int16 v39 = 1024;
    int v40 = HIDWORD(v32);
    __int16 v41 = 1024;
    int v42 = HIDWORD(v31);
    __int16 v43 = 1024;
    int v44 = v32;
    __int16 v45 = 1024;
    int v46 = v31;
    _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_INFO, "readKeyForDevice BTKCCopyLEData address:%{public}s syncedKeychain:%{public}s type:%d localLen:%d localStatus:%d syncedLen:%d, SynedStatus:%d", buf, 0x34u);
    if (v30 < 0) {
      operator delete(__p);
    }
  }
  if (!HIDWORD(v31))
  {
    unsigned int v15 = HIDWORD(v32);
    if (HIDWORD(v32))
    {
      if (HIDWORD(v32) != v11)
      {
        long long v16 = qword_100A19E80;
        if (os_log_type_enabled((os_log_t)qword_100A19E80, OS_LOG_TYPE_FAULT))
        {
          *(_DWORD *)long long buf = 67109632;
          *(_DWORD *)&uint8_t buf[4] = a4;
          *(_WORD *)&uint8_t buf[8] = 1024;
          *(_DWORD *)&buf[10] = v11;
          *(_WORD *)&buf[14] = 1024;
          *(_DWORD *)&uint8_t buf[16] = v15;
          _os_log_fault_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_FAULT, "Ignoring data of invalid length for key type %d - expected %d byte(s), read %d byte(s)", buf, 0x14u);
          unsigned int v11 = HIDWORD(v32);
        }
        else
        {
          unsigned int v11 = v15;
        }
      }
      uint64_t v17 = *(void *)(a3 + 8);
      sub_1000335D8(buf, v34, v11);
      sub_1003BB660(v17, a4, (uint64_t)buf);
      *(void *)long long buf = &off_100998428;
      if (*(void *)&buf[8]) {
        sub_1000368F4(*(atomic_uint **)&buf[8]);
      }
      if (v31 || !v32)
      {
        if (!v31 || !a5) {
          goto LABEL_49;
        }
      }
      else
      {
        if (HIDWORD(v32) >= v32) {
          size_t v18 = v32;
        }
        else {
          size_t v18 = HIDWORD(v32);
        }
        if (!memcmp(v34, v33, v18) || (a5 & 1) == 0) {
          goto LABEL_49;
        }
      }
      char v27 = qword_100A19E80;
      if (os_log_type_enabled((os_log_t)qword_100A19E80, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "storing synced data with the local values", buf, 2u);
      }
      unsigned __int8 v26 = sub_100031234((const unsigned __int8 *)v47);
      sub_10070E9F0(a1, a2, v26, a3, a4, 1);
LABEL_48:

LABEL_49:
      int v19 = v31;
      goto LABEL_50;
    }
  }
  int v19 = v31;
  if (!v31)
  {
    unsigned int v20 = v32;
    if (v32)
    {
      if (v32 != v11)
      {
        unint64_t v21 = qword_100A19E80;
        if (os_log_type_enabled((os_log_t)qword_100A19E80, OS_LOG_TYPE_FAULT))
        {
          *(_DWORD *)long long buf = 67109632;
          *(_DWORD *)&uint8_t buf[4] = a4;
          *(_WORD *)&uint8_t buf[8] = 1024;
          *(_DWORD *)&buf[10] = v11;
          *(_WORD *)&buf[14] = 1024;
          *(_DWORD *)&uint8_t buf[16] = v20;
          _os_log_fault_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_FAULT, "Ignoring data of invalid length for key type %d - expected %d byte(s), read %d byte(s)", buf, 0x14u);
          unsigned int v11 = v32;
        }
        else
        {
          unsigned int v11 = v20;
        }
      }
      uint64_t v22 = *(void *)(a3 + 8);
      sub_1000335D8(buf, v33, v11);
      sub_1003BB660(v22, a4, (uint64_t)buf);
      *(void *)long long buf = &off_100998428;
      if (*(void *)&buf[8]) {
        sub_1000368F4(*(atomic_uint **)&buf[8]);
      }
      if (a5) {
        goto LABEL_49;
      }
      int v23 = sub_100031234((const unsigned __int8 *)v47);
      BOOL v24 = sub_100008DC4(a1, v23);

      if (!v24) {
        goto LABEL_49;
      }
      __int16 v25 = qword_100A19E80;
      if (os_log_type_enabled((os_log_t)qword_100A19E80, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "writing local data with the synced values", buf, 2u);
      }
      unsigned __int8 v26 = sub_100031234((const unsigned __int8 *)v47);
      sub_10070E9F0(a1, a2, v26, a3, a4, 0);
      goto LABEL_48;
    }
  }
LABEL_50:
  if (!v19 && v33) {
    operator delete[]();
  }
  if (!HIDWORD(v31) && v34) {
    operator delete[]();
  }
  return sub_10003AFB4((uint64_t)v35);
}

void sub_10070E96C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);

  sub_10003AFB4((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_10070E9F0(uint64_t a1, uint64_t a2, void *a3, uint64_t a4, unsigned int a5, int a6)
{
  id v11 = a3;
  v21[0] = 0;
  v21[1] = 0;
  sub_10003AED0((uint64_t)v21, a1 + 48);
  int v19 = 0;
  unsigned int v20 = 0;
  sub_1003BC0D4(*(void *)(a4 + 8), a5, &v19);
  if (!sub_100013DCC((uint64_t)&v19))
  {
    uint64_t v12 = qword_100A19E80;
    if (os_log_type_enabled((os_log_t)qword_100A19E80, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)size_t v18 = 0;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "writeKeyForDevice is calling BTKCSetLEData sync=0", v18, 2u);
    }
    long long v13 = (const UInt8 *)sub_10004A6E4((uint64_t)&v19);
    CFIndex v14 = sub_100045F00((uint64_t)&v19);
    sub_100312C44(a2, v11, a5, v13, v14, 0);
    if (a6)
    {
      unsigned int v15 = qword_100A19E80;
      if (os_log_type_enabled((os_log_t)qword_100A19E80, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)size_t v18 = 0;
        _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "writeKeyForDevice is calling BTKCSetLEData sync=1", v18, 2u);
      }
      long long v16 = (const UInt8 *)sub_10004A6E4((uint64_t)&v19);
      CFIndex v17 = sub_100045F00((uint64_t)&v19);
      sub_100312C44(a2, v11, a5, v16, v17, 1);
    }
  }
  int v19 = &off_100998428;
  if (v20) {
    sub_1000368F4(v20);
  }
  sub_10003AFB4((uint64_t)v21);
}

void sub_10070EBA0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  sub_10003AFB4((uint64_t)va);

  _Unwind_Resume(a1);
}

void sub_10070EBF0(uint64_t a1, uint64_t a2, void *a3, uint64_t a4, unsigned int **a5, int a6)
{
  id v11 = a3;
  v23[0] = 0;
  v23[1] = 0;
  sub_10003AED0((uint64_t)v23, a1 + 48);
  CFTypeRef cf = 0;
  uint64_t v12 = *a5;
  long long v13 = a5[1];
  if (*a5 != v13)
  {
    char v14 = 0;
    do
    {
      unsigned int v15 = *v12;
      unsigned int v20 = 0;
      unint64_t v21 = 0;
      sub_1003BC0D4(*(void *)(a4 + 8), v15, &v20);
      if (!sub_100013DCC((uint64_t)&v20))
      {
        long long v16 = qword_100A19E80;
        if (os_log_type_enabled((os_log_t)qword_100A19E80, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)long long buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "writeKeyForDevice is calling BTKCSetLEData sync=0", buf, 2u);
        }
        CFIndex v17 = (const UInt8 *)sub_10004A6E4((uint64_t)&v20);
        CFIndex v18 = sub_100045F00((uint64_t)&v20);
        sub_100312818(a2, v11, v15, v17, v18, a6, &cf, 0);
        ++v14;
      }
      unsigned int v20 = &off_100998428;
      if (v21) {
        sub_1000368F4(v21);
      }
      ++v12;
    }
    while (v12 != v13);
    if (v14) {
      sub_1003126C0(a2, v11, a6, &cf);
    }
    if (cf) {
      CFRelease(cf);
    }
  }
  sub_10003AFB4((uint64_t)v23);
}

void sub_10070ED8C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  sub_10003AFB4((uint64_t)va);

  _Unwind_Resume(a1);
}

void sub_10070EDE4(uint64_t a1, uint64_t a2, void *a3, uint64_t a4)
{
  id v7 = a3;
  v149[0] = 0;
  v149[1] = 0;
  sub_10003AED0((uint64_t)v149, a1 + 48);
  if (qword_1009F7EE0 != -1) {
    dispatch_once(&qword_1009F7EE0, &stru_1009BFD48);
  }
  uint64_t v8 = off_1009F7ED8;
  sub_10004191C(__p, "IsAppleWatch");
  int v9 = sub_100030A04((uint64_t)v8, v7, (uint64_t)__p);
  if (v148 < 0) {
    operator delete(__p[0]);
  }
  unsigned int v10 = qword_100A19E80;
  if (os_log_type_enabled((os_log_t)qword_100A19E80, OS_LOG_TYPE_DEFAULT))
  {
    sub_1006AD3F0();
    id v11 = (id)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)long long buf = 138543618;
    *(void *)&uint8_t buf[4] = v11;
    *(_WORD *)&unsigned char buf[12] = 1024;
    *(_DWORD *)&buf[14] = v9;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "Writing keys to disk for device %{public}@ (isWatch=%d)", buf, 0x12u);
  }
  sub_10070E9F0(a1, a2, v7, a4, 0xAu, v9);
  memset(buf, 0, sizeof(buf));
  long long v13 = sub_1002C44F0((uint64_t)&buf[16], 1uLL);
  char v14 = *(char **)buf;
  unsigned int v15 = *(char **)&buf[8];
  long long v16 = (char *)&v13[v12];
  *long long v13 = 0;
  CFIndex v17 = (char *)(v13 + 1);
  CFIndex v18 = v13;
  while (v15 != v14)
  {
    int v19 = *((_DWORD *)v15 - 1);
    v15 -= 4;
    *--CFIndex v18 = v19;
  }
  *(void *)long long buf = v18;
  *(void *)&uint8_t buf[8] = v13 + 1;
  *(void *)&uint8_t buf[16] = &v13[v12];
  if (v14)
  {
    operator delete(v14);
    long long v16 = *(char **)&buf[16];
  }
  *(void *)&uint8_t buf[8] = v13 + 1;
  if (v17 >= v16)
  {
    unint64_t v21 = *(char **)buf;
    uint64_t v22 = (uint64_t)&v17[-*(void *)buf] >> 2;
    unint64_t v23 = v22 + 1;
    if ((unint64_t)(v22 + 1) >> 62) {
      abort();
    }
    uint64_t v24 = (uint64_t)&v16[-*(void *)buf];
    if (v24 >> 1 > v23) {
      unint64_t v23 = v24 >> 1;
    }
    if ((unint64_t)v24 >= 0x7FFFFFFFFFFFFFFCLL) {
      unint64_t v25 = 0x3FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v25 = v23;
    }
    if (v25)
    {
      unsigned __int8 v26 = (char *)sub_1002C44F0((uint64_t)&buf[16], v25);
      unint64_t v21 = *(char **)buf;
      CFIndex v17 = *(char **)&buf[8];
    }
    else
    {
      unsigned __int8 v26 = 0;
    }
    char v27 = &v26[4 * v22];
    long long v16 = &v26[4 * v25];
    *(_DWORD *)char v27 = 1;
    unsigned int v20 = v27 + 4;
    while (v17 != v21)
    {
      int v28 = *((_DWORD *)v17 - 1);
      v17 -= 4;
      *((_DWORD *)v27 - 1) = v28;
      v27 -= 4;
    }
    *(void *)long long buf = v27;
    *(void *)&uint8_t buf[8] = v20;
    *(void *)&uint8_t buf[16] = v16;
    if (v21)
    {
      operator delete(v21);
      long long v16 = *(char **)&buf[16];
    }
  }
  else
  {
    v13[1] = 1;
    unsigned int v20 = (char *)(v13 + 2);
  }
  *(void *)&uint8_t buf[8] = v20;
  if (v20 >= v16)
  {
    char v30 = *(char **)buf;
    uint64_t v31 = (uint64_t)&v20[-*(void *)buf] >> 2;
    unint64_t v32 = v31 + 1;
    if ((unint64_t)(v31 + 1) >> 62) {
      abort();
    }
    uint64_t v33 = (uint64_t)&v16[-*(void *)buf];
    if (v33 >> 1 > v32) {
      unint64_t v32 = v33 >> 1;
    }
    if ((unint64_t)v33 >= 0x7FFFFFFFFFFFFFFCLL) {
      unint64_t v34 = 0x3FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v34 = v32;
    }
    if (v34)
    {
      char v35 = (char *)sub_1002C44F0((uint64_t)&buf[16], v34);
      char v30 = *(char **)buf;
      unsigned int v20 = *(char **)&buf[8];
    }
    else
    {
      char v35 = 0;
    }
    int v36 = &v35[4 * v31];
    long long v16 = &v35[4 * v34];
    *(_DWORD *)int v36 = 2;
    __int16 v29 = v36 + 4;
    while (v20 != v30)
    {
      int v37 = *((_DWORD *)v20 - 1);
      v20 -= 4;
      *((_DWORD *)v36 - 1) = v37;
      v36 -= 4;
    }
    *(void *)long long buf = v36;
    *(void *)&uint8_t buf[8] = v29;
    *(void *)&uint8_t buf[16] = v16;
    if (v30)
    {
      operator delete(v30);
      long long v16 = *(char **)&buf[16];
    }
  }
  else
  {
    *(_DWORD *)unsigned int v20 = 2;
    __int16 v29 = v20 + 4;
  }
  *(void *)&uint8_t buf[8] = v29;
  if (v29 >= v16)
  {
    __int16 v39 = *(char **)buf;
    uint64_t v40 = (uint64_t)&v29[-*(void *)buf] >> 2;
    unint64_t v41 = v40 + 1;
    if ((unint64_t)(v40 + 1) >> 62) {
      abort();
    }
    uint64_t v42 = (uint64_t)&v16[-*(void *)buf];
    if (v42 >> 1 > v41) {
      unint64_t v41 = v42 >> 1;
    }
    if ((unint64_t)v42 >= 0x7FFFFFFFFFFFFFFCLL) {
      unint64_t v43 = 0x3FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v43 = v41;
    }
    if (v43)
    {
      int v44 = (char *)sub_1002C44F0((uint64_t)&buf[16], v43);
      __int16 v39 = *(char **)buf;
      __int16 v29 = *(char **)&buf[8];
    }
    else
    {
      int v44 = 0;
    }
    __int16 v45 = &v44[4 * v40];
    long long v16 = &v44[4 * v43];
    *(_DWORD *)__int16 v45 = 3;
    unsigned int v38 = v45 + 4;
    while (v29 != v39)
    {
      int v46 = *((_DWORD *)v29 - 1);
      v29 -= 4;
      *((_DWORD *)v45 - 1) = v46;
      v45 -= 4;
    }
    *(void *)long long buf = v45;
    *(void *)&uint8_t buf[8] = v38;
    *(void *)&uint8_t buf[16] = v16;
    if (v39)
    {
      operator delete(v39);
      long long v16 = *(char **)&buf[16];
    }
  }
  else
  {
    *(_DWORD *)__int16 v29 = 3;
    unsigned int v38 = v29 + 4;
  }
  *(void *)&uint8_t buf[8] = v38;
  if (v38 >= v16)
  {
    char v48 = *(char **)buf;
    uint64_t v49 = (uint64_t)&v38[-*(void *)buf] >> 2;
    unint64_t v50 = v49 + 1;
    if ((unint64_t)(v49 + 1) >> 62) {
      abort();
    }
    uint64_t v51 = (uint64_t)&v16[-*(void *)buf];
    if (v51 >> 1 > v50) {
      unint64_t v50 = v51 >> 1;
    }
    if ((unint64_t)v51 >= 0x7FFFFFFFFFFFFFFCLL) {
      unint64_t v52 = 0x3FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v52 = v50;
    }
    if (v52)
    {
      long long v53 = (char *)sub_1002C44F0((uint64_t)&buf[16], v52);
      char v48 = *(char **)buf;
      unsigned int v38 = *(char **)&buf[8];
    }
    else
    {
      long long v53 = 0;
    }
    char v54 = &v53[4 * v49];
    long long v16 = &v53[4 * v52];
    *(_DWORD *)char v54 = 4;
    int v47 = v54 + 4;
    while (v38 != v48)
    {
      int v55 = *((_DWORD *)v38 - 1);
      v38 -= 4;
      *((_DWORD *)v54 - 1) = v55;
      v54 -= 4;
    }
    *(void *)long long buf = v54;
    *(void *)&uint8_t buf[8] = v47;
    *(void *)&uint8_t buf[16] = v16;
    if (v48)
    {
      operator delete(v48);
      long long v16 = *(char **)&buf[16];
    }
  }
  else
  {
    *(_DWORD *)unsigned int v38 = 4;
    int v47 = v38 + 4;
  }
  *(void *)&uint8_t buf[8] = v47;
  if (v47 >= v16)
  {
    long long v57 = *(char **)buf;
    uint64_t v58 = (uint64_t)&v47[-*(void *)buf] >> 2;
    unint64_t v59 = v58 + 1;
    if ((unint64_t)(v58 + 1) >> 62) {
      abort();
    }
    uint64_t v60 = (uint64_t)&v16[-*(void *)buf];
    if (v60 >> 1 > v59) {
      unint64_t v59 = v60 >> 1;
    }
    if ((unint64_t)v60 >= 0x7FFFFFFFFFFFFFFCLL) {
      unint64_t v61 = 0x3FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v61 = v59;
    }
    if (v61)
    {
      long long v62 = (char *)sub_1002C44F0((uint64_t)&buf[16], v61);
      long long v57 = *(char **)buf;
      int v47 = *(char **)&buf[8];
    }
    else
    {
      long long v62 = 0;
    }
    long long v63 = &v62[4 * v58];
    long long v16 = &v62[4 * v61];
    *(_DWORD *)long long v63 = 12;
    long long v56 = v63 + 4;
    while (v47 != v57)
    {
      int v64 = *((_DWORD *)v47 - 1);
      v47 -= 4;
      *((_DWORD *)v63 - 1) = v64;
      v63 -= 4;
    }
    *(void *)long long buf = v63;
    *(void *)&uint8_t buf[8] = v56;
    *(void *)&uint8_t buf[16] = v16;
    if (v57)
    {
      operator delete(v57);
      long long v16 = *(char **)&buf[16];
    }
  }
  else
  {
    *(_DWORD *)int v47 = 12;
    long long v56 = v47 + 4;
  }
  *(void *)&uint8_t buf[8] = v56;
  if (v56 >= v16)
  {
    v66 = *(char **)buf;
    uint64_t v67 = (uint64_t)&v56[-*(void *)buf] >> 2;
    unint64_t v68 = v67 + 1;
    if ((unint64_t)(v67 + 1) >> 62) {
      abort();
    }
    uint64_t v69 = (uint64_t)&v16[-*(void *)buf];
    if (v69 >> 1 > v68) {
      unint64_t v68 = v69 >> 1;
    }
    if ((unint64_t)v69 >= 0x7FFFFFFFFFFFFFFCLL) {
      unint64_t v70 = 0x3FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v70 = v68;
    }
    if (v70)
    {
      v71 = (char *)sub_1002C44F0((uint64_t)&buf[16], v70);
      v66 = *(char **)buf;
      long long v56 = *(char **)&buf[8];
    }
    else
    {
      v71 = 0;
    }
    char v72 = &v71[4 * v67];
    long long v16 = &v71[4 * v70];
    *(_DWORD *)char v72 = 15;
    char v65 = v72 + 4;
    while (v56 != v66)
    {
      int v73 = *((_DWORD *)v56 - 1);
      v56 -= 4;
      *((_DWORD *)v72 - 1) = v73;
      v72 -= 4;
    }
    *(void *)long long buf = v72;
    *(void *)&uint8_t buf[8] = v65;
    *(void *)&uint8_t buf[16] = v16;
    if (v66)
    {
      operator delete(v66);
      long long v16 = *(char **)&buf[16];
    }
  }
  else
  {
    *(_DWORD *)long long v56 = 15;
    char v65 = v56 + 4;
  }
  *(void *)&uint8_t buf[8] = v65;
  if (v65 >= v16)
  {
    v75 = *(char **)buf;
    uint64_t v76 = (uint64_t)&v65[-*(void *)buf] >> 2;
    unint64_t v77 = v76 + 1;
    if ((unint64_t)(v76 + 1) >> 62) {
      abort();
    }
    uint64_t v78 = (uint64_t)&v16[-*(void *)buf];
    if (v78 >> 1 > v77) {
      unint64_t v77 = v78 >> 1;
    }
    if ((unint64_t)v78 >= 0x7FFFFFFFFFFFFFFCLL) {
      unint64_t v79 = 0x3FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v79 = v77;
    }
    if (v79)
    {
      int v80 = (char *)sub_1002C44F0((uint64_t)&buf[16], v79);
      v75 = *(char **)buf;
      char v65 = *(char **)&buf[8];
    }
    else
    {
      int v80 = 0;
    }
    __n128 v81 = &v80[4 * v76];
    long long v16 = &v80[4 * v79];
    *(_DWORD *)__n128 v81 = 5;
    v74 = v81 + 4;
    while (v65 != v75)
    {
      int v82 = *((_DWORD *)v65 - 1);
      v65 -= 4;
      *((_DWORD *)v81 - 1) = v82;
      v81 -= 4;
    }
    *(void *)long long buf = v81;
    *(void *)&uint8_t buf[8] = v74;
    *(void *)&uint8_t buf[16] = v16;
    if (v75)
    {
      operator delete(v75);
      long long v16 = *(char **)&buf[16];
    }
  }
  else
  {
    *(_DWORD *)char v65 = 5;
    v74 = v65 + 4;
  }
  *(void *)&uint8_t buf[8] = v74;
  if (v74 >= v16)
  {
    long long v84 = *(char **)buf;
    uint64_t v85 = (uint64_t)&v74[-*(void *)buf] >> 2;
    unint64_t v86 = v85 + 1;
    if ((unint64_t)(v85 + 1) >> 62) {
      abort();
    }
    uint64_t v87 = (uint64_t)&v16[-*(void *)buf];
    if (v87 >> 1 > v86) {
      unint64_t v86 = v87 >> 1;
    }
    if ((unint64_t)v87 >= 0x7FFFFFFFFFFFFFFCLL) {
      unint64_t v88 = 0x3FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v88 = v86;
    }
    if (v88)
    {
      long long v89 = (char *)sub_1002C44F0((uint64_t)&buf[16], v88);
      long long v84 = *(char **)buf;
      v74 = *(char **)&buf[8];
    }
    else
    {
      long long v89 = 0;
    }
    int v90 = &v89[4 * v85];
    long long v16 = &v89[4 * v88];
    *(_DWORD *)int v90 = 6;
    int v83 = v90 + 4;
    while (v74 != v84)
    {
      int v91 = *((_DWORD *)v74 - 1);
      v74 -= 4;
      *((_DWORD *)v90 - 1) = v91;
      v90 -= 4;
    }
    *(void *)long long buf = v90;
    *(void *)&uint8_t buf[8] = v83;
    *(void *)&uint8_t buf[16] = v16;
    if (v84)
    {
      operator delete(v84);
      long long v16 = *(char **)&buf[16];
    }
  }
  else
  {
    *(_DWORD *)v74 = 6;
    int v83 = v74 + 4;
  }
  *(void *)&uint8_t buf[8] = v83;
  if (v83 >= v16)
  {
    v93 = *(char **)buf;
    uint64_t v94 = (uint64_t)&v83[-*(void *)buf] >> 2;
    unint64_t v95 = v94 + 1;
    if ((unint64_t)(v94 + 1) >> 62) {
      abort();
    }
    uint64_t v96 = (uint64_t)&v16[-*(void *)buf];
    if (v96 >> 1 > v95) {
      unint64_t v95 = v96 >> 1;
    }
    if ((unint64_t)v96 >= 0x7FFFFFFFFFFFFFFCLL) {
      unint64_t v97 = 0x3FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v97 = v95;
    }
    if (v97)
    {
      v98 = (char *)sub_1002C44F0((uint64_t)&buf[16], v97);
      v93 = *(char **)buf;
      int v83 = *(char **)&buf[8];
    }
    else
    {
      v98 = 0;
    }
    v99 = &v98[4 * v94];
    long long v16 = &v98[4 * v97];
    *(_DWORD *)v99 = 7;
    v92 = v99 + 4;
    while (v83 != v93)
    {
      int v100 = *((_DWORD *)v83 - 1);
      v83 -= 4;
      *((_DWORD *)v99 - 1) = v100;
      v99 -= 4;
    }
    *(void *)long long buf = v99;
    *(void *)&uint8_t buf[8] = v92;
    *(void *)&uint8_t buf[16] = v16;
    if (v93)
    {
      operator delete(v93);
      long long v16 = *(char **)&buf[16];
    }
  }
  else
  {
    *(_DWORD *)int v83 = 7;
    v92 = v83 + 4;
  }
  *(void *)&uint8_t buf[8] = v92;
  if (v92 >= v16)
  {
    v102 = *(char **)buf;
    uint64_t v103 = (uint64_t)&v92[-*(void *)buf] >> 2;
    unint64_t v104 = v103 + 1;
    if ((unint64_t)(v103 + 1) >> 62) {
      abort();
    }
    uint64_t v105 = (uint64_t)&v16[-*(void *)buf];
    if (v105 >> 1 > v104) {
      unint64_t v104 = v105 >> 1;
    }
    if ((unint64_t)v105 >= 0x7FFFFFFFFFFFFFFCLL) {
      unint64_t v106 = 0x3FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v106 = v104;
    }
    if (v106)
    {
      v107 = (char *)sub_1002C44F0((uint64_t)&buf[16], v106);
      v102 = *(char **)buf;
      v92 = *(char **)&buf[8];
    }
    else
    {
      v107 = 0;
    }
    v108 = &v107[4 * v103];
    long long v16 = &v107[4 * v106];
    *(_DWORD *)v108 = 8;
    v101 = v108 + 4;
    while (v92 != v102)
    {
      int v109 = *((_DWORD *)v92 - 1);
      v92 -= 4;
      *((_DWORD *)v108 - 1) = v109;
      v108 -= 4;
    }
    *(void *)long long buf = v108;
    *(void *)&uint8_t buf[8] = v101;
    *(void *)&uint8_t buf[16] = v16;
    if (v102)
    {
      operator delete(v102);
      long long v16 = *(char **)&buf[16];
    }
  }
  else
  {
    *(_DWORD *)v92 = 8;
    v101 = v92 + 4;
  }
  *(void *)&uint8_t buf[8] = v101;
  if (v101 >= v16)
  {
    v111 = *(char **)buf;
    uint64_t v112 = (uint64_t)&v101[-*(void *)buf] >> 2;
    unint64_t v113 = v112 + 1;
    if ((unint64_t)(v112 + 1) >> 62) {
      abort();
    }
    uint64_t v114 = (uint64_t)&v16[-*(void *)buf];
    if (v114 >> 1 > v113) {
      unint64_t v113 = v114 >> 1;
    }
    if ((unint64_t)v114 >= 0x7FFFFFFFFFFFFFFCLL) {
      unint64_t v115 = 0x3FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v115 = v113;
    }
    if (v115)
    {
      v116 = (char *)sub_1002C44F0((uint64_t)&buf[16], v115);
      v111 = *(char **)buf;
      v101 = *(char **)&buf[8];
    }
    else
    {
      v116 = 0;
    }
    v117 = &v116[4 * v112];
    long long v16 = &v116[4 * v115];
    *(_DWORD *)v117 = 9;
    v110 = v117 + 4;
    while (v101 != v111)
    {
      int v118 = *((_DWORD *)v101 - 1);
      v101 -= 4;
      *((_DWORD *)v117 - 1) = v118;
      v117 -= 4;
    }
    *(void *)long long buf = v117;
    *(void *)&uint8_t buf[8] = v110;
    *(void *)&uint8_t buf[16] = v16;
    if (v111)
    {
      operator delete(v111);
      long long v16 = *(char **)&buf[16];
    }
  }
  else
  {
    *(_DWORD *)v101 = 9;
    v110 = v101 + 4;
  }
  *(void *)&uint8_t buf[8] = v110;
  if (v110 >= v16)
  {
    v120 = *(char **)buf;
    uint64_t v121 = (uint64_t)&v110[-*(void *)buf] >> 2;
    unint64_t v122 = v121 + 1;
    if ((unint64_t)(v121 + 1) >> 62) {
      abort();
    }
    uint64_t v123 = (uint64_t)&v16[-*(void *)buf];
    if (v123 >> 1 > v122) {
      unint64_t v122 = v123 >> 1;
    }
    if ((unint64_t)v123 >= 0x7FFFFFFFFFFFFFFCLL) {
      unint64_t v124 = 0x3FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v124 = v122;
    }
    if (v124)
    {
      v125 = (char *)sub_1002C44F0((uint64_t)&buf[16], v124);
      v120 = *(char **)buf;
      v110 = *(char **)&buf[8];
    }
    else
    {
      v125 = 0;
    }
    v126 = &v125[4 * v121];
    long long v16 = &v125[4 * v124];
    *(_DWORD *)v126 = 13;
    v119 = v126 + 4;
    while (v110 != v120)
    {
      int v127 = *((_DWORD *)v110 - 1);
      v110 -= 4;
      *((_DWORD *)v126 - 1) = v127;
      v126 -= 4;
    }
    *(void *)long long buf = v126;
    *(void *)&uint8_t buf[8] = v119;
    *(void *)&uint8_t buf[16] = v16;
    if (v120)
    {
      operator delete(v120);
      long long v16 = *(char **)&buf[16];
    }
  }
  else
  {
    *(_DWORD *)v110 = 13;
    v119 = v110 + 4;
  }
  *(void *)&uint8_t buf[8] = v119;
  if (v119 >= v16)
  {
    v129 = *(char **)buf;
    uint64_t v130 = (uint64_t)&v119[-*(void *)buf] >> 2;
    unint64_t v131 = v130 + 1;
    if ((unint64_t)(v130 + 1) >> 62) {
      abort();
    }
    uint64_t v132 = (uint64_t)&v16[-*(void *)buf];
    if (v132 >> 1 > v131) {
      unint64_t v131 = v132 >> 1;
    }
    if ((unint64_t)v132 >= 0x7FFFFFFFFFFFFFFCLL) {
      unint64_t v133 = 0x3FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v133 = v131;
    }
    if (v133)
    {
      v134 = (char *)sub_1002C44F0((uint64_t)&buf[16], v133);
      v129 = *(char **)buf;
      v119 = *(char **)&buf[8];
    }
    else
    {
      v134 = 0;
    }
    v135 = &v134[4 * v130];
    long long v16 = &v134[4 * v133];
    *(_DWORD *)v135 = 14;
    v128 = v135 + 4;
    while (v119 != v129)
    {
      int v136 = *((_DWORD *)v119 - 1);
      v119 -= 4;
      *((_DWORD *)v135 - 1) = v136;
      v135 -= 4;
    }
    *(void *)long long buf = v135;
    *(void *)&uint8_t buf[8] = v128;
    *(void *)&uint8_t buf[16] = v16;
    if (v129)
    {
      operator delete(v129);
      long long v16 = *(char **)&buf[16];
    }
  }
  else
  {
    *(_DWORD *)v119 = 14;
    v128 = v119 + 4;
  }
  *(void *)&uint8_t buf[8] = v128;
  if (v128 >= v16)
  {
    v138 = *(char **)buf;
    uint64_t v139 = (uint64_t)&v128[-*(void *)buf] >> 2;
    unint64_t v140 = v139 + 1;
    if ((unint64_t)(v139 + 1) >> 62) {
      abort();
    }
    uint64_t v141 = (uint64_t)&v16[-*(void *)buf];
    if (v141 >> 1 > v140) {
      unint64_t v140 = v141 >> 1;
    }
    if ((unint64_t)v141 >= 0x7FFFFFFFFFFFFFFCLL) {
      unint64_t v142 = 0x3FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v142 = v140;
    }
    if (v142)
    {
      v143 = (char *)sub_1002C44F0((uint64_t)&buf[16], v142);
      v138 = *(char **)buf;
      v128 = *(char **)&buf[8];
    }
    else
    {
      v143 = 0;
    }
    v144 = &v143[4 * v139];
    v145 = &v143[4 * v142];
    *(_DWORD *)v144 = 16;
    v137 = v144 + 4;
    while (v128 != v138)
    {
      int v146 = *((_DWORD *)v128 - 1);
      v128 -= 4;
      *((_DWORD *)v144 - 1) = v146;
      v144 -= 4;
    }
    *(void *)long long buf = v144;
    *(void *)&uint8_t buf[8] = v137;
    *(void *)&uint8_t buf[16] = v145;
    if (v138) {
      operator delete(v138);
    }
  }
  else
  {
    *(_DWORD *)v128 = 16;
    v137 = v128 + 4;
  }
  *(void *)&uint8_t buf[8] = v137;
  sub_10070EBF0(a1, a2, v7, a4, (unsigned int **)buf, 0);
  if (*(void *)buf)
  {
    *(void *)&uint8_t buf[8] = *(void *)buf;
    operator delete(*(void **)buf);
  }
  sub_10003AFB4((uint64_t)v149);
}

void sub_10070F9D4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, char a16, uint64_t a17, void *__p, uint64_t a19)
{
  sub_10003AFB4((uint64_t)&a16);

  _Unwind_Resume(a1);
}

void sub_10070FA68(uint64_t a1, void *a2, uint64_t a3)
{
  id v5 = a2;
  v20[0] = 0;
  v20[1] = 0;
  sub_10003AED0((uint64_t)v20, a1 + 48);
  sub_1000305AC(buf, v5);
  uint64_t v6 = sub_1000308C0(a1 + 488, buf);
  if (qword_1009F7EE0 != -1) {
    dispatch_once(&qword_1009F7EE0, &stru_1009BFD48);
  }
  if (sub_1006C65B8((uint64_t)off_1009F7ED8, v5))
  {
    if (qword_1009F7EE0 != -1) {
      dispatch_once(&qword_1009F7EE0, &stru_1009BFD48);
    }
    id v7 = sub_1006B6290((uint64_t)off_1009F7ED8, v5);
    uint64_t v8 = v7;
    if (v7)
    {
      *(_WORD *)(a3 + 80) |= 8u;
      *(_WORD *)(a3 + 44) = 528;
      *(_OWORD *)(a3 + 28) = *(_OWORD *)[v7 bytes];
    }
    else if (os_log_type_enabled((os_log_t)qword_100A19E80, OS_LOG_TYPE_ERROR))
    {
      sub_100798148();
    }

    goto LABEL_17;
  }
  if (a1 + 496 == v6)
  {
    sub_1000305AC(buf, v5);
    uint64_t v15 = sub_1000308C0(a1 + 440, buf);
    if (a1 + 448 != v15)
    {
      sub_1007030D4(a1, v15 + 48, (_WORD *)a3);
      goto LABEL_17;
    }
    uint64_t v19 = qword_100A19E80;
    if (!os_log_type_enabled((os_log_t)qword_100A19E80, OS_LOG_TYPE_INFO)) {
      goto LABEL_17;
    }
    *(_DWORD *)long long buf = 138543362;
    id v22 = v5;
    long long v16 = "No security keys found for device \"%{public}@\"";
    CFIndex v17 = v19;
    os_log_type_t v18 = OS_LOG_TYPE_INFO;
LABEL_22:
    _os_log_impl((void *)&_mh_execute_header, v17, v18, v16, buf, 0xCu);
    goto LABEL_17;
  }
  sub_1007030D4(a1, v6 + 48, (_WORD *)a3);
  uint64_t v9 = sub_100017768();
  int v10 = (*(uint64_t (**)(uint64_t))(*(void *)v9 + 8))(v9);
  id v11 = qword_100A19E80;
  BOOL v12 = os_log_type_enabled((os_log_t)qword_100A19E80, OS_LOG_TYPE_DEFAULT);
  if (!v10)
  {
    if (!v12) {
      goto LABEL_17;
    }
    *(_DWORD *)long long buf = 138543362;
    id v22 = v5;
    long long v16 = "using temporary keys for device \"%{public}@\"";
    CFIndex v17 = v11;
    os_log_type_t v18 = OS_LOG_TYPE_DEFAULT;
    goto LABEL_22;
  }
  if (v12)
  {
    long long v13 = +[NSData dataWithBytes:a3 + 28 length:*(unsigned __int8 *)(a3 + 44)];
    int v14 = *(unsigned __int8 *)(a3 + 45);
    *(_DWORD *)long long buf = 138543874;
    id v22 = v5;
    __int16 v23 = 2112;
    uint64_t v24 = v13;
    __int16 v25 = 1024;
    int v26 = v14;
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "using temporary keys for device \"%{public}@\" LocalLTK:%@(type:%d)", buf, 0x1Cu);
  }
LABEL_17:
  sub_10003AFB4((uint64_t)v20);
}

void sub_10070FD80(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  sub_10003AFB4((uint64_t)&a9);

  _Unwind_Resume(a1);
}

void sub_10070FDC4(uint64_t a1, unint64_t a2, unsigned int a3, int a4, char a5)
{
  if (qword_1009F7EE0 != -1) {
    dispatch_once(&qword_1009F7EE0, &stru_1009BFD48);
  }
  *(void *)uuid_t uu = 0;
  uint64_t v62 = 0;
  sub_100014B58((uint64_t)off_1009F7ED8, a2, 0, 1u, 0, 0, uu);
  uint64_t v9 = qword_100A19E80;
  if (os_log_type_enabled((os_log_t)qword_100A19E80, OS_LOG_TYPE_DEFAULT))
  {
    memset(out, 0, sizeof(out));
    uuid_unparse_upper(uu, out);
    sub_10004191C(__p, out);
    int v10 = v54;
    id v11 = (void **)__p[0];
    uint64_t v12 = sub_1006AD3F0();
    long long v13 = (void *)v12;
    int v14 = __p;
    if (v10 < 0) {
      int v14 = v11;
    }
    uint64_t v15 = "disabled";
    *(_DWORD *)long long buf = 136446722;
    if (a4) {
      uint64_t v15 = "enabled";
    }
    long long v56 = (void *)v15;
    __int16 v57 = 2082;
    uint64_t v58 = (uint64_t)v14;
    __int16 v59 = 2114;
    uint64_t v60 = v12;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "Encryption is now %{public}s for device \"%{public}s\" (%{public}@)", buf, 0x20u);
    if (v54 < 0) {
      operator delete(__p[0]);
    }
  }
  if (a4)
  {
    uint64_t v16 = sub_1000308C0(a1 + 488, uu);
    if (qword_1009F7EE0 != -1) {
      dispatch_once(&qword_1009F7EE0, &stru_1009BFD48);
    }
    CFIndex v17 = off_1009F7ED8;
    os_log_type_t v18 = sub_100031234(uu);
    BOOL v19 = sub_1006C65B8((uint64_t)v17, v18);

    unsigned int v20 = sub_100031234(uu);
    BOOL v21 = sub_100008DC4(a1, v20);

    if (v21)
    {
      uint64_t v22 = sub_10003FB34();
      (*(void (**)(uint64_t, unint64_t, uint64_t))(*(void *)v22 + 1136))(v22, a2, 1);
    }
    else
    {
      char v23 = a1 + 496 != v16 || v19;
      if ((v23 & 1) == 0 && (a5 & 1) == 0)
      {
        uint64_t v24 = qword_100A19E80;
        if (os_log_type_enabled((os_log_t)qword_100A19E80, OS_LOG_TYPE_ERROR))
        {
          sub_100401EBC(uu, out);
          int v43 = out[23];
          int v44 = *(char **)out;
          uint64_t v45 = sub_1006AD3F0();
          int v46 = (void *)v45;
          int v47 = out;
          if (v43 < 0) {
            int v47 = v44;
          }
          *(_DWORD *)long long buf = 136446466;
          long long v56 = v47;
          __int16 v57 = 2114;
          uint64_t v58 = v45;
          _os_log_error_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_ERROR, "Unexpected encryption state for device \"%{public}s\" (%{public}@), disconnecting", buf, 0x16u);
          if (out[23] < 0) {
            operator delete(*(void **)out);
          }
        }
        if (qword_1009F7EC0 != -1) {
          dispatch_once(&qword_1009F7EC0, &stru_1009BFD68);
        }
        sub_100683CFC((uint64_t)off_1009F7EB8, uu, 6u);
      }
    }
  }
  if (a3 == 706)
  {
    if (qword_1009F7ED0 != -1) {
      dispatch_once(&qword_1009F7ED0, &stru_1009BFD08);
    }
    uint64_t v25 = qword_1009F7EC8;
    int v26 = sub_100031234(uu);
    LODWORD(v25) = sub_100008DC4(v25, v26);

    if (v25)
    {
      char v27 = qword_100A19E80;
      if (os_log_type_enabled((os_log_t)qword_100A19E80, OS_LOG_TYPE_ERROR)) {
        sub_1007981B4(v27, v28, v29, v30, v31, v32, v33, v34);
      }
      if (qword_1009F7F10 != -1) {
        dispatch_once(&qword_1009F7F10, &stru_1009BFDA8);
      }
      uint64_t v35 = qword_1009F7F08;
      int v36 = sub_100031234(uu);
      sub_1006386B4(v35, v36);
    }
  }
  int v37 = sub_100031234(uu);
  unsigned int v38 = *(uint64_t **)(a1 + 568);
  for (uint64_t i = *(uint64_t **)(a1 + 576); v38 != i; ++v38)
  {
    uint64_t v40 = *v38;
    uint64_t v41 = sub_100019878();
    v49[0] = _NSConcreteStackBlock;
    v49[1] = 3221225472;
    v49[2] = sub_100710368;
    v49[3] = &unk_1009AB678;
    uint64_t v51 = v40;
    id v50 = v37;
    char v52 = a4;
    sub_100013018(v41, v49);
  }
  uint64_t v42 = sub_100050530();
  (*(void (**)(uint64_t, void, uint64_t))(*(void *)v42 + 640))(v42, a3, 2);
}

void sub_1007102E0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, int a20,__int16 a21,char a22,char a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,void *__p,uint64_t a31,int a32,__int16 a33,char a34,char a35)
{
  if (a35 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100710368(uint64_t a1)
{
  return (*(uint64_t (**)(void, void, void))(**(void **)(a1 + 40) + 16))(*(void *)(a1 + 40), *(void *)(a1 + 32), *(unsigned __int8 *)(a1 + 48));
}

uint64_t sub_100710398(uint64_t a1, unint64_t a2, uint64_t *a3, int a4)
{
  v28[0] = 0;
  v28[1] = 0;
  sub_10003AED0((uint64_t)v28, a1 + 48);
  *(void *)uuid_t uu = 0;
  uint64_t v32 = 0;
  if (qword_1009F7EE0 != -1) {
    dispatch_once(&qword_1009F7EE0, &stru_1009BFD48);
  }
  sub_100014B58((uint64_t)off_1009F7ED8, a2, 1u, 1u, 0, 0, uu);
  if (uuid_is_null(uu))
  {
    char v8 = 0;
    uint64_t v9 = 0;
    goto LABEL_5;
  }
  uint64_t v12 = sub_1000308C0(a1 + 488, uu);
  if (a1 + 496 == v12) {
    uint64_t v12 = sub_1000308C0(a1 + 440, uu);
  }
  if (v12 != a1 + 448)
  {
    long long v13 = *(atomic_uint **)(v12 + 56);
    int v26 = &off_1009B4578;
    char v27 = v13;
    if (v13)
    {
      sub_100037354((uint64_t)v13);
      long long v13 = v27;
    }
    uint64_t v24 = 0;
    uint64_t v25 = 0;
    sub_1003BC0D4((uint64_t)v13, 9, &v24);
    uint64_t v22 = 0;
    char v23 = 0;
    sub_1003BC0D4((uint64_t)v27, 8, &v22);
    unsigned int v20 = 0;
    BOOL v21 = 0;
    sub_1003BC0D4((uint64_t)v27, 7, &v20);
    if (sub_100013DCC((uint64_t)&v24) && sub_100013DCC((uint64_t)&v22))
    {
      uint64_t v29 = 0;
      if (a4) {
        BOOL v14 = 0;
      }
      else {
        BOOL v14 = *a3 == 0;
      }
      char v15 = v14;
      if ((sub_100013DCC((uint64_t)&v20)
         || *(unsigned char *)sub_10004A6E4((uint64_t)&v20) != 2 && *(unsigned char *)sub_10004A6E4((uint64_t)&v20) != 3)
        && (v15 & 1) == 0)
      {
        goto LABEL_38;
      }
    }
    else
    {
      if (sub_100013DCC((uint64_t)&v24) || sub_100013DCC((uint64_t)&v22)) {
        goto LABEL_38;
      }
      int v16 = *(unsigned __int16 *)sub_10004A6E4((uint64_t)&v22);
      char v8 = 0;
      uint64_t v9 = 0;
      if (*a3 != *(void *)sub_10004A6E4((uint64_t)&v24) || v16 != a4) {
        goto LABEL_40;
      }
    }
    if (!sub_100013DCC((uint64_t)&v20))
    {
      char v8 = *(unsigned char *)sub_10004A6E4((uint64_t)&v20);
      sub_1003BC0D4((uint64_t)v27, 6, &v29);
      sub_100049EE0((uint64_t)&v22, (uint64_t)&v29);
      uint64_t v29 = &off_100998428;
      if (v30) {
        sub_1000368F4(v30);
      }
      if (!sub_100013DCC((uint64_t)&v22))
      {
        uint64_t v9 = *(unsigned __int8 *)sub_10004A6E4((uint64_t)&v22);
        goto LABEL_40;
      }
LABEL_39:
      uint64_t v9 = 0;
LABEL_40:
      unsigned int v20 = &off_100998428;
      if (v21) {
        sub_1000368F4(v21);
      }
      uint64_t v22 = &off_100998428;
      if (v23) {
        sub_1000368F4(v23);
      }
      uint64_t v24 = &off_100998428;
      if (v25) {
        sub_1000368F4(v25);
      }
      int v26 = &off_1009B4578;
      if (v27) {
        sub_1000368F4(v27);
      }
      goto LABEL_5;
    }
LABEL_38:
    char v8 = 0;
    goto LABEL_39;
  }
  if (qword_1009F7EE0 != -1) {
    dispatch_once(&qword_1009F7EE0, &stru_1009BFD48);
  }
  CFIndex v17 = off_1009F7ED8;
  os_log_type_t v18 = sub_100031234(uu);
  LODWORD(v17) = sub_1006C65B8((uint64_t)v17, v18);

  BOOL v19 = v17 == 0;
  if (v17) {
    char v8 = 2;
  }
  else {
    char v8 = 0;
  }
  if (v19) {
    uint64_t v9 = 0;
  }
  else {
    uint64_t v9 = 16;
  }
LABEL_5:
  uint64_t v10 = sub_1002284B8(a2);
  LODWORD(v26) = v10;
  BYTE6(v26) = BYTE6(v10);
  WORD2(v26) = WORD2(v10);
  LOBYTE(v24) = 0;
  sub_10001B8E0(&v24);
  sub_100233348(&v26, a3, a4, v9, v8);
  sub_10001B8AC(&v24);
  return sub_10003AFB4((uint64_t)v28);
}

void sub_1007107A8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, atomic_uint *a11, uint64_t a12, atomic_uint *a13, uint64_t a14, atomic_uint *a15, uint64_t a16, atomic_uint *a17, char a18, uint64_t a19, uint64_t (**a20)(),atomic_uint *a21)
{
  a20 = &off_100998428;
  if (a21) {
    sub_1000368F4(a21);
  }
  if (a11) {
    sub_1000368F4(a11);
  }
  if (a13) {
    sub_1000368F4(a13);
  }
  if (a15) {
    sub_1000368F4(a15);
  }
  if (a17) {
    sub_1000368F4(a17);
  }
  sub_10003AFB4((uint64_t)&a18);
  _Unwind_Resume(a1);
}

unsigned char *sub_1007108E4(uint64_t a1, unint64_t a2)
{
  int v16 = 0;
  memset(v15, 0, sizeof(v15));
  if (qword_1009F7EE0 != -1) {
    dispatch_once(&qword_1009F7EE0, &stru_1009BFD48);
  }
  *(void *)uuid_t uu = 0;
  uint64_t v14 = 0;
  sub_100014B58((uint64_t)off_1009F7ED8, a2, 1u, 1u, 0, 0, uu);
  if (!uuid_is_null(uu))
  {
    BOOL v4 = sub_100031234(uu);
    sub_10070FA68(a1, v4, (uint64_t)v15);

    if (qword_1009F7EE0 != -1) {
      dispatch_once(&qword_1009F7EE0, &stru_1009BFD48);
    }
    id v5 = off_1009F7ED8;
    uint64_t v6 = sub_100031234(uu);
    BYTE2(v16) = sub_1006C6284((uint64_t)v5, v6);
  }
  uint64_t v7 = sub_1002284B8(a2);
  int v10 = v7;
  char v12 = BYTE6(v7);
  __int16 v11 = WORD2(v7);
  char v9 = 0;
  sub_10001B8E0(&v9);
  sub_100234F14(&v10, (uint64_t)v15);
  return sub_10001B8AC(&v9);
}

void sub_100710A68(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t sub_100710A9C(uint64_t a1, unint64_t a2, int a3, unsigned __int8 *a4, unsigned int a5)
{
  int v10 = qword_100A19E80;
  if (os_log_type_enabled((os_log_t)qword_100A19E80, OS_LOG_TYPE_DEFAULT))
  {
    __int16 v11 = sub_1006AD3F0();
    v13[0] = 67109634;
    v13[1] = a3;
    __int16 v14 = 1024;
    unsigned int v15 = a5;
    __int16 v16 = 2114;
    CFIndex v17 = v11;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "Adding temporary security keys (type:%d lengh:%d) to device %{public}@", (uint8_t *)v13, 0x18u);
  }
  return sub_100710BB0(a1, a2, a3, a4, a5, 1);
}

uint64_t sub_100710BB0(uint64_t a1, unint64_t a2, int a3, unsigned __int8 *a4, unsigned int a5, int a6)
{
  v26[0] = 0;
  v26[1] = 0;
  sub_10003AED0((uint64_t)v26, a1 + 48);
  uint64_t v12 = sub_1002284B8(a2);
  int v23 = v12;
  char v25 = BYTE6(v12);
  __int16 v24 = WORD2(v12);
  char v22 = 0;
  sub_10001B8E0(&v22);
  uint64_t v13 = sub_100197B34(&v23);
  sub_10001B910(&v22);
  memset(uu, 0, sizeof(uu));
  uuid_clear(uu);
  if (!v13) {
    goto LABEL_38;
  }
  if (qword_1009F7EC0 != -1) {
    dispatch_once(&qword_1009F7EC0, &stru_1009BFD68);
  }
  if (sub_10067F618((uint64_t)off_1009F7EB8, v13, uu)) {
    goto LABEL_38;
  }
  if (uuid_is_null(uu) && os_log_type_enabled((os_log_t)qword_100A19E80, OS_LOG_TYPE_FAULT))
  {
    sub_1006AD3F0();
    objc_claimAutoreleasedReturnValue();
    sub_100798300();
  }
  if (!uuid_is_null(uu))
  {
LABEL_38:
    if (!uuid_is_null(uu)) {
      goto LABEL_16;
    }
    if (qword_1009F7EE0 != -1) {
      dispatch_once(&qword_1009F7EE0, &stru_1009BFD48);
    }
    sub_100014B58((uint64_t)off_1009F7ED8, a2, 0, 1u, 0, 0, src);
    uuid_copy(uu, src);
    if (uuid_is_null(uu) && os_log_type_enabled((os_log_t)qword_100A19E80, OS_LOG_TYPE_FAULT))
    {
      sub_1006AD3F0();
      objc_claimAutoreleasedReturnValue();
      sub_1007982B8();
    }
    if (!uuid_is_null(uu))
    {
LABEL_16:
      __int16 v14 = qword_100A19E80;
      if (os_log_type_enabled((os_log_t)qword_100A19E80, OS_LOG_TYPE_DEFAULT))
      {
        unsigned int v15 = sub_1006AD3F0();
        int v16 = *a4;
        *(_DWORD *)src = 138544386;
        *(void *)&src[4] = v15;
        *(_WORD *)&src[12] = 1024;
        *(_DWORD *)&src[14] = a3;
        __int16 v28 = 1024;
        int v29 = v16;
        __int16 v30 = 1024;
        unsigned int v31 = a5;
        __int16 v32 = 1024;
        int v33 = a6;
        _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "Key generated for \"%{public}@\" type=%d value=%d len=%d temporary=%d", src, 0x24u);
      }
      *(void *)src = &off_1009B4578;
      *(void *)&src[8] = 0;
      if (a6)
      {
        if (a1 + 472 != sub_1000308C0(a1 + 464, uu))
        {
          if (os_log_type_enabled((os_log_t)qword_100A19E80, OS_LOG_TYPE_ERROR))
          {
            sub_1006AD3F0();
            objc_claimAutoreleasedReturnValue();
            sub_100798270();
          }
          goto LABEL_28;
        }
        if (a1 + 448 != sub_1000308C0(a1 + 440, uu))
        {
          if (os_log_type_enabled((os_log_t)qword_100A19E80, OS_LOG_TYPE_ERROR))
          {
            sub_1006AD3F0();
            objc_claimAutoreleasedReturnValue();
            sub_100798228();
          }
          goto LABEL_28;
        }
        uint64_t v17 = sub_1000308C0(a1 + 488, uu);
        if (a1 + 496 == v17) {
          operator new();
        }
      }
      else
      {
        uint64_t v17 = sub_1000308C0(a1 + 464, uu);
        if (a1 + 472 == v17) {
          operator new();
        }
      }
      sub_100049EE0((uint64_t)src, v17 + 48);
LABEL_28:
      uint64_t v18 = *(void *)&src[8];
      if (*(void *)&src[8])
      {
        sub_1000335D8(&v20, a4, a5);
        sub_1003BB660(v18, a3, (uint64_t)&v20);
        unsigned int v20 = &off_100998428;
        if (v21) {
          sub_1000368F4(v21);
        }
        *(void *)src = &off_1009B4578;
        if (*(void *)&src[8]) {
          sub_1000368F4(*(atomic_uint **)&src[8]);
        }
      }
    }
  }
  sub_10001B8AC(&v22);
  return sub_10003AFB4((uint64_t)v26);
}

void sub_100711154(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, atomic_uint *a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,atomic_uint *a21)
{
  if (a10) {
    sub_1000368F4(a10);
  }
  if (a21) {
    sub_1000368F4(a21);
  }
  sub_10001B8AC(&a14);
  sub_10003AFB4((uint64_t)&a16);
  _Unwind_Resume(a1);
}

uint64_t *sub_100711218(uint64_t a1, unsigned __int8 *a2)
{
  BOOL v4 = qword_100A19E80;
  if (os_log_type_enabled((os_log_t)qword_100A19E80, OS_LOG_TYPE_DEFAULT))
  {
    memset(out, 0, 37);
    uuid_unparse_upper(a2, (char *)out);
    sub_10004191C(__p, (char *)out);
    id v5 = v12 >= 0 ? __p : (void **)__p[0];
    *(_DWORD *)uuid_string_t out = 136446210;
    *(void *)&out[4] = v5;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Removing temporary security keys for device %{public}s", out, 0xCu);
    if (v12 < 0) {
      operator delete(__p[0]);
    }
  }
  uint64_t v6 = (uint64_t **)(a1 + 488);
  result = (uint64_t *)sub_1000308C0(a1 + 488, a2);
  if ((uint64_t *)(a1 + 496) != result)
  {
    char v8 = result;
    char v9 = qword_100A19E80;
    if (os_log_type_enabled((os_log_t)qword_100A19E80, OS_LOG_TYPE_DEFAULT))
    {
      memset(out, 0, 37);
      uuid_unparse_upper(a2, (char *)out);
      sub_10004191C(__p, (char *)out);
      if (v12 >= 0) {
        int v10 = __p;
      }
      else {
        int v10 = (void **)__p[0];
      }
      *(_DWORD *)uuid_string_t out = 136446210;
      *(void *)&out[4] = v10;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "Found temporary security keys for device %{public}s, removing now.", out, 0xCu);
      if (v12 < 0) {
        operator delete(__p[0]);
      }
    }
    return sub_10071B5BC(v6, v8);
  }
  return result;
}

uint64_t sub_1007113D4(uint64_t a1, unsigned __int8 *a2)
{
  BOOL v4 = qword_100A19E80;
  if (os_log_type_enabled((os_log_t)qword_100A19E80, OS_LOG_TYPE_DEFAULT))
  {
    memset(out, 0, sizeof(out));
    uuid_unparse_upper(a2, out);
    sub_10004191C(__p, out);
    id v5 = v19 >= 0 ? __p : (void **)__p[0];
    *(_DWORD *)uuid_string_t out = 136446210;
    *(void *)&out[4] = v5;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Removing temporary IRK for device %{public}s", (uint8_t *)out, 0xCu);
    if (v19 < 0) {
      operator delete(__p[0]);
    }
  }
  uint64_t v6 = (uint64_t **)(a1 + 512);
  uint64_t result = sub_1000308C0(a1 + 512, a2);
  char v8 = (uint64_t *)result;
  if (a1 + 520 != result)
  {
    char v9 = qword_100A19E80;
    if (os_log_type_enabled((os_log_t)qword_100A19E80, OS_LOG_TYPE_DEFAULT))
    {
      memset(out, 0, sizeof(out));
      uuid_unparse_upper(a2, out);
      sub_10004191C(__p, out);
      int v10 = v19 >= 0 ? __p : (void **)__p[0];
      *(_DWORD *)uuid_string_t out = 136446210;
      *(void *)&out[4] = v10;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "Found temporary IRK for device %{public}s, removing now.", (uint8_t *)out, 0xCu);
      if (v19 < 0) {
        operator delete(__p[0]);
      }
    }
    if (qword_1009F7ED0 != -1) {
      dispatch_once(&qword_1009F7ED0, &stru_1009BFD08);
    }
    uint64_t v11 = qword_1009F7EC8;
    sub_1003BC0D4(v8[7], 11, out);
    char v12 = (_DWORD *)sub_10004A6E4((uint64_t)out);
    sub_10071170C(v11, v12);
    *(void *)uuid_string_t out = &off_100998428;
    if (*(void *)&out[8]) {
      sub_1000368F4(*(atomic_uint **)&out[8]);
    }
    sub_10071B5BC(v6, v8);
    if (qword_1009F7EE0 != -1) {
      dispatch_once(&qword_1009F7EE0, &stru_1009BFD48);
    }
    uint64_t v13 = off_1009F7ED8;
    __int16 v14 = sub_100031234(a2);
    unint64_t v15 = sub_100030DCC((uint64_t)v13, v14, 1);

    out[0] = 0;
    unint64_t v16 = sub_10022A5E0(v15);
    *(_DWORD *)&out[1] = v16;
    *(_WORD *)&out[5] = WORD2(v16);
    sub_10070D770(v16, out);
    uint64_t v17 = sub_10003FB34();
    return (*(uint64_t (**)(uint64_t, unint64_t, uint64_t))(*(void *)v17 + 376))(v17, v15, 1);
  }
  return result;
}

void sub_1007116C4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t sub_10071170C(uint64_t result, _DWORD *a2)
{
  uint64_t v2 = 0;
  while (1)
  {
    BOOL v3 = *(_DWORD *)(result + v2 + 613) == *a2 && *(_DWORD *)(result + v2 + 616) == *(_DWORD *)((char *)a2 + 3);
    if (v3 && *(unsigned char *)(result + v2 + 620)) {
      break;
    }
    v2 += 24;
    if (v2 == 3120) {
      return result;
    }
  }
  *(unsigned char *)(result + v2 + 620) = 0;
  sub_10070D770(result, a2);
  BOOL v4 = *(uint64_t (**)(void))(*(void *)sub_10003FB34() + 376);

  return v4();
}

void sub_10071180C(uint64_t a1, unint64_t a2, int a3)
{
  if (*(unsigned char *)(a1 + 3718))
  {
LABEL_2:
    int v36 = 0;
    long long v34 = 0u;
    long long v35 = 0u;
    long long v33 = 0u;
    *(_OWORD *)unsigned int v31 = 0u;
    long long v32 = 0u;
    v24[0] = 0;
    v24[1] = 0;
    sub_10003AED0((uint64_t)v24, a1 + 48);
    *(void *)uuid_t uu = 0;
    uint64_t v30 = 0;
    if (qword_1009F7EE0 != -1) {
      dispatch_once(&qword_1009F7EE0, &stru_1009BFD48);
    }
    sub_100014B58((uint64_t)off_1009F7ED8, a2, 0, 1u, 0, 0, uu);
    if (uuid_is_null(uu) && os_log_type_enabled((os_log_t)qword_100A19E80, OS_LOG_TYPE_FAULT))
    {
      sub_1006AD3F0();
      objc_claimAutoreleasedReturnValue();
      sub_100798348();
    }
    if (!uuid_is_null(uu))
    {
      char v9 = qword_100A19E80;
      if (os_log_type_enabled((os_log_t)qword_100A19E80, OS_LOG_TYPE_DEFAULT))
      {
        memset(out, 0, sizeof(out));
        uuid_unparse_upper(uu, out);
        sub_10004191C(__p, out);
        int v10 = "without";
        if (a3) {
          int v10 = "with";
        }
        if (v23 >= 0) {
          uint64_t v11 = __p;
        }
        else {
          uint64_t v11 = (void **)__p[0];
        }
        *(_DWORD *)long long buf = 136446466;
        int v26 = (void *)v10;
        __int16 v27 = 2082;
        __int16 v28 = v11;
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "Security (%{public}s man-in-the-middle) was requested by device \"%{public}s\"", buf, 0x16u);
        if (v23 < 0) {
          operator delete(__p[0]);
        }
      }
      unint64_t v12 = *(void *)(a1 + 456);
      if (v12 >= *(unsigned __int16 *)(a1 + 3736))
      {
        char v19 = qword_100A19E80;
        if (os_log_type_enabled((os_log_t)qword_100A19E80, OS_LOG_TYPE_DEFAULT))
        {
          unsigned int v20 = sub_1006AD3F0();
          *(_DWORD *)uuid_string_t out = 134218242;
          *(void *)&out[4] = v12;
          *(_WORD *)&out[12] = 2114;
          *(void *)&out[14] = v20;
          _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "Ignoring security request as there are too many paired devices (%lu), disconnecting %{public}@", (uint8_t *)out, 0x16u);
        }
        *(void *)uuid_string_t out = 0;
        if (qword_1009F7EC0 != -1) {
          dispatch_once(&qword_1009F7EC0, &stru_1009BFD68);
        }
        if (sub_1006856B8((uint64_t)off_1009F7EB8, uu, out))
        {
          LOBYTE(__p[0]) = 0;
          sub_10001B8E0(__p);
          sub_1001F11F4(*(uint64_t *)out, 4835);
          sub_10001B910(__p);
          sub_10001B8AC(__p);
        }
        if (qword_1009F7EC0 != -1) {
          dispatch_once(&qword_1009F7EC0, &stru_1009BFD68);
        }
        sub_100683CFC((uint64_t)off_1009F7EB8, uu, 8u);
        goto LABEL_10;
      }
      uint64_t v13 = *(uint64_t (****)(void, void *, void))(a1 + 560);
      if (v13)
      {
        __int16 v14 = sub_100031234(uu);
        int v15 = (**v13)(v13, v14, 0);

        unint64_t v16 = qword_100A19E80;
        if (v15)
        {
          if (os_log_type_enabled((os_log_t)qword_100A19E80, OS_LOG_TYPE_DEFAULT))
          {
            memset(out, 0, sizeof(out));
            uuid_unparse_upper(uu, out);
            sub_10004191C(__p, out);
            if (v23 >= 0) {
              uint64_t v17 = __p;
            }
            else {
              uint64_t v17 = (void **)__p[0];
            }
            *(_DWORD *)long long buf = 136446210;
            int v26 = v17;
            _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "Accepting security request from device \"%{public}s\"", buf, 0xCu);
            if (v23 < 0) {
              operator delete(__p[0]);
            }
          }
          uint64_t v18 = sub_100031234(uu);
          sub_10070FA68(a1, v18, (uint64_t)v31);

          int v6 = 1;
          goto LABEL_9;
        }
      }
      else
      {
        unint64_t v16 = qword_100A19E80;
      }
      int v6 = 0;
      if (!os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
      {
LABEL_9:
        uint64_t v7 = sub_1002284B8(a2);
        *(_DWORD *)uuid_string_t out = v7;
        out[6] = BYTE6(v7);
        *(_WORD *)&out[4] = WORD2(v7);
        LOBYTE(__p[0]) = 0;
        sub_10001B8E0(__p);
        sub_1002351FC(out, v6, (uint64_t)v31);
        sub_10001B8AC(__p);
LABEL_10:
        sub_10003AFB4((uint64_t)v24);
        return;
      }
      if (*(void *)(a1 + 560)) {
        BOOL v21 = "there are no sessions that support it!";
      }
      else {
        BOOL v21 = "there is no listener";
      }
      *(_DWORD *)uuid_string_t out = 136446210;
      *(void *)&out[4] = v21;
      _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "Ignoring security request as %{public}s", (uint8_t *)out, 0xCu);
    }
    int v6 = 0;
    goto LABEL_9;
  }
  char v8 = qword_100A19E80;
  if (os_log_type_enabled((os_log_t)qword_100A19E80, OS_LOG_TYPE_FAULT))
  {
    *(_WORD *)unsigned int v31 = 0;
    _os_log_fault_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_FAULT, "We don't have root keys for LE, something's wrong, file a radar!", v31, 2u);
    if (*(unsigned char *)(a1 + 3718)) {
      goto LABEL_2;
    }
    char v8 = qword_100A19E80;
  }
  if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR)) {
    sub_100797A34();
  }
}

void sub_100711D5C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);

  sub_10003AFB4((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_100711DC4(uint64_t a1, unint64_t a2)
{
  if (*(unsigned char *)(a1 + 3718))
  {
LABEL_2:
    v17[0] = 0;
    v17[1] = 0;
    sub_10003AED0((uint64_t)v17, a1 + 48);
    *(void *)uuid_t uu = 0;
    uint64_t v23 = 0;
    if (qword_1009F7EE0 != -1) {
      dispatch_once(&qword_1009F7EE0, &stru_1009BFD48);
    }
    sub_100014B58((uint64_t)off_1009F7ED8, a2, 1u, 1u, 0, 0, uu);
    if (!uuid_is_null(uu))
    {
      uint64_t v7 = qword_100A19E80;
      if (os_log_type_enabled((os_log_t)qword_100A19E80, OS_LOG_TYPE_DEFAULT))
      {
        memset(out, 0, sizeof(out));
        uuid_unparse_upper(uu, out);
        sub_10004191C(__p, out);
        char v8 = v19 >= 0 ? __p : (void **)__p[0];
        *(_DWORD *)long long buf = 136446210;
        BOOL v21 = v8;
        _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "Received a pairing request from device \"%{public}s\"", buf, 0xCu);
        if (v19 < 0) {
          operator delete(__p[0]);
        }
      }
      unint64_t v9 = *(void *)(a1 + 456);
      if (v9 >= *(unsigned __int16 *)(a1 + 3736))
      {
        uint64_t v13 = qword_100A19E80;
        if (os_log_type_enabled((os_log_t)qword_100A19E80, OS_LOG_TYPE_DEFAULT))
        {
          __int16 v14 = sub_1006AD3F0();
          *(_DWORD *)uuid_string_t out = 134218242;
          *(void *)&out[4] = v9;
          *(_WORD *)&out[12] = 2112;
          *(void *)&out[14] = v14;
          _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "Ignoring security request as there are too many paired devices (%lu), disconnecting %@", (uint8_t *)out, 0x16u);
        }
        *(void *)uuid_string_t out = 0;
        if (qword_1009F7EC0 != -1) {
          dispatch_once(&qword_1009F7EC0, &stru_1009BFD68);
        }
        if (sub_1006856B8((uint64_t)off_1009F7EB8, uu, out))
        {
          LOBYTE(__p[0]) = 0;
          sub_10001B8E0(__p);
          sub_1001F11F4(*(uint64_t *)out, 4835);
          sub_10001B910(__p);
          sub_10001B8AC(__p);
        }
        if (qword_1009F7EC0 != -1) {
          dispatch_once(&qword_1009F7EC0, &stru_1009BFD68);
        }
        sub_100683CFC((uint64_t)off_1009F7EB8, uu, 8u);
        goto LABEL_9;
      }
      int v10 = *(uint64_t (****)(void, void *, void))(a1 + 560);
      if (v10)
      {
        uint64_t v11 = sub_100031234(uu);
        char v12 = (**v10)(v10, v11, 0);

        if (v12)
        {
          int v4 = 1;
          goto LABEL_6;
        }
      }
      if (os_log_type_enabled((os_log_t)qword_100A19E80, OS_LOG_TYPE_ERROR))
      {
        sub_100401EBC(uu, out);
        sub_100798390();
      }
    }
    int v4 = 0;
LABEL_6:
    uint64_t v5 = sub_1002284B8(a2);
    *(_DWORD *)long long buf = v5;
    BYTE2(v21) = BYTE6(v5);
    LOWORD(v21) = WORD2(v5);
    char v16 = 0;
    sub_10001B8E0(&v16);
    char v15 = 0;
    if (!sub_100240484(buf, &v15)) {
      sub_1002352D4(buf, v4, v15 & 4 | v4);
    }
    sub_10001B8AC(&v16);
LABEL_9:
    sub_10003AFB4((uint64_t)v17);
    return;
  }
  int v6 = qword_100A19E80;
  if (os_log_type_enabled((os_log_t)qword_100A19E80, OS_LOG_TYPE_FAULT))
  {
    *(_WORD *)uuid_string_t out = 0;
    _os_log_fault_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_FAULT, "We don't have root keys for LE, something's wrong, file a radar!", (uint8_t *)out, 2u);
    if (*(unsigned char *)(a1 + 3718)) {
      goto LABEL_2;
    }
    int v6 = qword_100A19E80;
  }
  if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR)) {
    sub_100797A34();
  }
}

void sub_1007121BC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  sub_10003AFB4((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_10071221C(uint64_t a1, unint64_t a2, uint64_t a3, unsigned int *a4)
{
  if (*(unsigned char *)(a1 + 3718)) {
    goto LABEL_2;
  }
  char v12 = qword_100A19E80;
  if (!os_log_type_enabled((os_log_t)qword_100A19E80, OS_LOG_TYPE_FAULT))
  {
LABEL_13:
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR)) {
      sub_100797A34();
    }
    return;
  }
  *(_WORD *)long long buf = 0;
  _os_log_fault_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_FAULT, "We don't have root keys for LE, something's wrong, file a radar!", buf, 2u);
  if (!*(unsigned char *)(a1 + 3718))
  {
    char v12 = qword_100A19E80;
    goto LABEL_13;
  }
LABEL_2:
  uint64_t v8 = *a4;
  *(void *)uuid_t uu = 0;
  uint64_t v32 = 0;
  if (qword_1009F7EE0 != -1) {
    dispatch_once(&qword_1009F7EE0, &stru_1009BFD48);
  }
  sub_100014B58((uint64_t)off_1009F7ED8, a2, 0, 1u, 0, 0, uu);
  if (uuid_is_null(uu))
  {
    unint64_t v9 = qword_100A19E80;
    if (os_log_type_enabled((os_log_t)qword_100A19E80, OS_LOG_TYPE_FAULT)) {
      sub_1007984FC(a2, v9);
    }
  }
  if (uuid_is_null(uu)) {
    goto LABEL_8;
  }
  uint64_t v13 = *(uint64_t (****)(void, void *, void))(a1 + 560);
  if (!v13
    || (sub_100031234(uu),
        __int16 v14 = objc_claimAutoreleasedReturnValue(),
        int v15 = (**v13)(v13, v14, 0),
        v14,
        !v15))
  {
    uint64_t v18 = qword_100A19E80;
    if (os_log_type_enabled((os_log_t)qword_100A19E80, OS_LOG_TYPE_ERROR)) {
      sub_10079844C(uu, v18);
    }
LABEL_8:
    LOBYTE(__p[0]) = 0;
    sub_10001B8E0(__p);
    uint64_t v10 = sub_1002284B8(a2);
    LODWORD(v25[0]) = v10;
    BYTE6(v25[0]) = BYTE6(v10);
    WORD2(v25[0]) = WORD2(v10);
    int v11 = sub_1002378AC(v25);
    sub_10001B910(__p);
    if (v11)
    {
      if (os_log_type_enabled((os_log_t)qword_100A19E80, OS_LOG_TYPE_ERROR))
      {
        sub_1006AD3F0();
        objc_claimAutoreleasedReturnValue();
        sub_1007983EC();
      }
    }
    sub_10001B8AC(__p);
    return;
  }
  char v16 = qword_100A19E80;
  if (os_log_type_enabled((os_log_t)qword_100A19E80, OS_LOG_TYPE_DEFAULT))
  {
    if (a3 >= 3)
    {
      if (a3 == 4) {
        uint64_t v17 = "Numeric Comparison";
      }
      else {
        uint64_t v17 = "Out-of-band";
      }
    }
    else
    {
      uint64_t v17 = off_1009BFE08[(int)a3];
    }
    char v19 = v25;
    sub_10004191C(v25, v17);
    if (v26 < 0) {
      char v19 = (void **)v25[0];
    }
    *(_OWORD *)long long buf = 0u;
    memset(v34, 0, sizeof(v34));
    uuid_unparse_upper(uu, (char *)buf);
    sub_10004191C(__p, (char *)buf);
    if (v24 >= 0) {
      unsigned int v20 = __p;
    }
    else {
      unsigned int v20 = (void **)__p[0];
    }
    *(_DWORD *)__int16 v27 = 136446466;
    __int16 v28 = v19;
    __int16 v29 = 2082;
    uint64_t v30 = v20;
    _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "Received \"%{public}s\" pairing request for device \"%{public}s\"", v27, 0x16u);
    if (v24 < 0) {
      operator delete(__p[0]);
    }
    if (v26 < 0) {
      operator delete(v25[0]);
    }
  }
  uint64_t v21 = *(void *)(a1 + 560);
  char v22 = sub_100031234(uu);
  (*(void (**)(uint64_t, void *, uint64_t, uint64_t))(*(void *)v21 + 8))(v21, v22, a3, v8);
}

void sub_1007125D0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  _Unwind_Resume(a1);
}

void sub_100712624(uint64_t a1)
{
  uint64_t v2 = sub_100019878();
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 3221225472;
  v3[2] = sub_1007126A0;
  v3[3] = &unk_100997528;
  v3[4] = a1;
  sub_100013018(v2, v3);
}

uint64_t sub_1007126A0(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  v31[0] = 0;
  v31[1] = 0;
  sub_10003AED0((uint64_t)v31, v1 + 48);
  uint64_t v2 = qword_100A19E80;
  if (os_log_type_enabled((os_log_t)qword_100A19E80, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(buf) = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "In showAuthorizationAlert", (uint8_t *)&buf, 2u);
  }
  if (*(void *)(v1 + 3720))
  {
    BOOL v3 = qword_100A19E80;
    if (os_log_type_enabled((os_log_t)qword_100A19E80, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(buf) = 0;
      int v4 = "Already busy with another notification, waiting for the current one to complete";
LABEL_6:
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, v4, (uint8_t *)&buf, 2u);
    }
  }
  else
  {
    if (![*(id *)(v1 + 3728) count])
    {
      BOOL v3 = qword_100A19E80;
      if (!os_log_type_enabled((os_log_t)qword_100A19E80, OS_LOG_TYPE_DEFAULT)) {
        return sub_10003AFB4((uint64_t)v31);
      }
      LOWORD(buf) = 0;
      int v4 = "No more pending devices for AuthorizationAlert";
      goto LABEL_6;
    }
    __int16 v27 = [*(id *)(v1 + 3728) objectAtIndex:0];
    uint64_t v5 = qword_100A19E80;
    if (os_log_type_enabled((os_log_t)qword_100A19E80, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(buf) = 138543362;
      *(void *)((char *)&buf + 4) = v27;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "Display Compromised device alert for %{public}@ ", (uint8_t *)&buf, 0xCu);
    }
    if (qword_1009F7EE0 != -1) {
      dispatch_once(&qword_1009F7EE0, &stru_1009BFD48);
    }
    sub_10003093C((uint64_t)off_1009F7ED8, v27, (uint64_t)&buf);
    uint64_t v6 = v35;
    if ((v35 & 0x80u) != 0) {
      uint64_t v6 = *((void *)&buf + 1);
    }
    if (v6)
    {
      if (qword_1009F7EE0 != -1) {
        dispatch_once(&qword_1009F7EE0, &stru_1009BFD48);
      }
      sub_10003093C((uint64_t)off_1009F7ED8, v27, (uint64_t)__p);
      if (v30 >= 0) {
        uint64_t v7 = __p;
      }
      else {
        uint64_t v7 = (void **)__p[0];
      }
      char v26 = +[NSString stringWithUTF8String:v7];
      if (v30 < 0) {
        operator delete(__p[0]);
      }
    }
    else
    {
      if (qword_1009F7EE0 != -1) {
        dispatch_once(&qword_1009F7EE0, &stru_1009BFD48);
      }
      sub_100030DCC((uint64_t)off_1009F7ED8, v27, 0);
      char v26 = sub_1006AD3F0();
    }
    if ((char)v35 < 0) {
      operator delete((void *)buf);
    }
    uint64_t v8 = sub_100035F54();
    if ((*(unsigned int (**)(uint64_t))(*(void *)v8 + 328))(v8))
    {
      uint64_t v9 = sub_100035F54();
      if ((*(uint64_t (**)(uint64_t))(*(void *)v9 + 368))(v9))
      {
        uint64_t v10 = @"iPod";
      }
      else
      {
        uint64_t v11 = sub_100035F54();
        int v12 = (*(uint64_t (**)(uint64_t))(*(void *)v11 + 360))(v11);
        uint64_t v13 = @"iPhone";
        if (v12) {
          uint64_t v13 = @"iPad";
        }
        uint64_t v10 = v13;
      }
    }
    else
    {
      uint64_t v10 = @"iDevice";
    }
    LODWORD(buf) = 0;
    __int16 v14 = sub_100379650(@"COMPROMISED_DEVICE_TITLE", @"Bluetooth Security Alert");
    int v15 = sub_100379650(@"COMPROMISED_DEVICE_ALLOW", @"Allow");
    char v16 = sub_100379650(@"COMPROMISED_DEVICE_DONT_ALLOW", @"Don't Allow");
    uint64_t v17 = sub_100379650(@"COMPROMISED_DEVICE_AUTHORIZATION_MESSAGE", @"\"%@\" is trying to connect using an unsecured Bluetooth connection. Unsecured Bluetooth accessories can be used to control your %@ or gain access to your data.");
    id v28 = 0;
    uint64_t v18 = +[NSString stringWithValidatedFormat:v17, @"%@%@", &v28, v26, v10 validFormatSpecifiers error];
    id v19 = v28;

    if (v18)
    {
      v32[0] = kCFUserNotificationAlertTopMostKey;
      v32[1] = SBUserNotificationAllowMenuButtonDismissal;
      v33[0] = &__kCFBooleanTrue;
      v33[1] = &__kCFBooleanTrue;
      v32[2] = SBUserNotificationDismissOnLock;
      v32[3] = kCFUserNotificationAlertHeaderKey;
      v33[2] = &__kCFBooleanTrue;
      v33[3] = v14;
      v32[4] = kCFUserNotificationAlertMessageKey;
      v32[5] = kCFUserNotificationDefaultButtonTitleKey;
      v33[4] = v18;
      v33[5] = v16;
      v32[6] = kCFUserNotificationAlternateButtonTitleKey;
      v33[6] = v15;
      unsigned int v20 = +[NSDictionary dictionaryWithObjects:v33 forKeys:v32 count:7];
      CFDictionaryRef v21 = (const __CFDictionary *)[v20 mutableCopy];

      char v22 = CFUserNotificationCreate(kCFAllocatorDefault, 0.0, 3uLL, (SInt32 *)&buf, v21);
      *(void *)(v1 + 3720) = v22;
      RunLoopSource = CFUserNotificationCreateRunLoopSource(kCFAllocatorDefault, v22, (CFUserNotificationCallBack)sub_100712D54, 0);
      if (RunLoopSource)
      {
        Main = CFRunLoopGetMain();
        CFRunLoopAddSource(Main, RunLoopSource, kCFRunLoopCommonModes);
        CFRelease(RunLoopSource);
      }
      else
      {
        CFUserNotificationCancel(v22);
        CFRelease(v22);
      }
    }
    else if (os_log_type_enabled((os_log_t)qword_100A19E80, OS_LOG_TYPE_ERROR))
    {
      sub_10079858C();
    }
  }
  return sub_10003AFB4((uint64_t)v31);
}

void sub_100712C70(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, void *a12, uint64_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19, char a20)
{
  sub_10003AFB4((uint64_t)&a20);
  _Unwind_Resume(a1);
}

void sub_100712D54(uint64_t a1, uint64_t a2)
{
  if (qword_1009F7ED0 != -1) {
    dispatch_once(&qword_1009F7ED0, &stru_1009BFD08);
  }
  uint64_t v3 = qword_1009F7EC8;

  sub_100712DB8(v3, a2, a2);
}

void sub_100712DB8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = sub_100019878();
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 3221225472;
  void v6[2] = sub_100712E38;
  v6[3] = &unk_100998260;
  v6[4] = a1;
  v6[5] = a3;
  sub_100013018(v5, v6);
}

void sub_100712E38(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  uint64_t v3 = [*(id *)(v2 + 3728) objectAtIndex:0];
  int v4 = qword_100A19E80;
  if (os_log_type_enabled((os_log_t)qword_100A19E80, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = *(void *)(a1 + 40);
    uint64_t v6 = "unknown";
    if (!v5) {
      uint64_t v6 = "Disallow";
    }
    int v9 = 138543874;
    uint64_t v10 = v3;
    if (v5 == 1) {
      uint64_t v6 = "Allow";
    }
    __int16 v11 = 2082;
    int v12 = v6;
    __int16 v13 = 2048;
    uint64_t v14 = v5;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "User responded to authorization notification for device \"%{public}@\" with %{public}s (%ld) button", (uint8_t *)&v9, 0x20u);
  }
  uint64_t v7 = *(void *)(a1 + 40);
  if (v7 != 1)
  {
    if (v7)
    {
      if (os_log_type_enabled((os_log_t)qword_100A19E80, OS_LOG_TYPE_ERROR)) {
        sub_1007985F8();
      }
    }
    else
    {
      if (qword_1009F7EC0 != -1) {
        dispatch_once(&qword_1009F7EC0, &stru_1009BFD68);
      }
      uint64_t v8 = off_1009F7EB8;
      sub_1000305AC(&v9, v3);
      sub_100683CFC((uint64_t)v8, (unsigned __int8 *)&v9, 7u);
    }
  }
  sub_100713010(v2, v3);
  CFRelease(*(CFTypeRef *)(v2 + 3720));
  *(void *)(v2 + 3720) = 0;
  if ([*(id *)(v2 + 3728) count]) {
    sub_100712624(v2);
  }
}

void sub_100712FF4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100713010(uint64_t a1, void *a2)
{
  id v3 = a2;
  long long v12 = 0u;
  long long v13 = 0u;
  long long v14 = 0u;
  long long v15 = 0u;
  id v4 = *(id *)(a1 + 3728);
  id v5 = [v4 countByEnumeratingWithState:&v12 objects:v16 count:16];
  if (v5)
  {
    uint64_t v6 = *(void *)v13;
    while (2)
    {
      for (uint64_t i = 0; i != v5; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v13 != v6) {
          objc_enumerationMutation(v4);
        }
        uint64_t v8 = *(void **)(*((void *)&v12 + 1) + 8 * i);
        int v9 = [v8 UUIDString];
        uint64_t v10 = [v3 UUIDString];
        unsigned int v11 = [v9 isEqualToString:v10];

        if (v11)
        {
          [*(id *)(a1 + 3728) removeObject:v8];
          goto LABEL_11;
        }
      }
      id v5 = [v4 countByEnumeratingWithState:&v12 objects:v16 count:16];
      if (v5) {
        continue;
      }
      break;
    }
  }
LABEL_11:
}

void sub_100713164(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1007131A0(uint64_t a1, void *a2)
{
  id v3 = a2;
  long long v13 = 0u;
  long long v14 = 0u;
  long long v15 = 0u;
  long long v16 = 0u;
  id v4 = *(id *)(a1 + 3728);
  id v5 = [v4 countByEnumeratingWithState:&v13 objects:v19 count:16];
  if (v5)
  {
    uint64_t v6 = *(void *)v14;
    while (2)
    {
      uint64_t v7 = 0;
      do
      {
        if (*(void *)v14 != v6) {
          objc_enumerationMutation(v4);
        }
        uint64_t v8 = [*(id *)(*((void *)&v13 + 1) + 8 * (void)v7) UUIDString];
        int v9 = [v3 UUIDString];
        unsigned int v10 = [v8 isEqualToString:v9];

        if (v10)
        {
          long long v12 = qword_100A19E80;
          if (os_log_type_enabled((os_log_t)qword_100A19E80, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)long long buf = 138543362;
            id v18 = v3;
            _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "Device '%{public}@' is present in the authorization queue.", buf, 0xCu);
          }

          goto LABEL_15;
        }
        uint64_t v7 = (char *)v7 + 1;
      }
      while (v5 != v7);
      id v5 = [v4 countByEnumeratingWithState:&v13 objects:v19 count:16];
      if (v5) {
        continue;
      }
      break;
    }
  }

  unsigned int v11 = qword_100A19E80;
  if (os_log_type_enabled((os_log_t)qword_100A19E80, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 138543362;
    id v18 = v3;
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "Device '%{public}@' is not present in the authorization queue, creating device object and adding it to the queue", buf, 0xCu);
  }
  [*(id *)(a1 + 3728) addObject:v3];
LABEL_15:
}

void sub_100713394(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1007133D8(uint64_t a1)
{
  if (qword_1009F7EE0 != -1) {
    dispatch_once(&qword_1009F7EE0, &stru_1009BFD48);
  }
  uint64_t v2 = off_1009F7ED8;
  sub_100031234((const unsigned __int8 *)(a1 + 40));
  id v3 = (id)objc_claimAutoreleasedReturnValue();
  sub_1006C8790((uint64_t)v2, v3, *(void *)(*(void *)(a1 + 32) + 8) + 48);
}

void sub_10071346C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

uint64_t sub_100713480(uint64_t a1)
{
  return (***(uint64_t (****)(void, void, void))(a1 + 40))(*(void *)(a1 + 40), *(void *)(a1 + 32), *(unsigned int *)(a1 + 48));
}

uint64_t sub_1007134B0()
{
  if (qword_1009F7EB0 != -1) {
    dispatch_once(&qword_1009F7EB0, &stru_1009BFDC8);
  }
  v0 = *(uint64_t (**)(void))(*(void *)off_1009F7EA8 + 64);

  return v0();
}

uint64_t sub_100713538(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  id v7 = a2;
  if (sub_10070C8C8(a1, v7))
  {
    if (os_log_type_enabled((os_log_t)qword_100A19E80, OS_LOG_TYPE_ERROR)) {
      sub_10079862C();
    }
    uint64_t v8 = 168;
  }
  else if (sub_10070C7E4(a1, v7))
  {
    if (os_log_type_enabled((os_log_t)qword_100A19E80, OS_LOG_TYPE_ERROR)) {
      sub_100798698();
    }
    uint64_t v8 = 169;
  }
  else
  {
    unint64_t v9 = *(void *)(a1 + 456);
    if (v9 >= *(unsigned __int16 *)(a1 + 3736))
    {
      long long v12 = qword_100A19E80;
      if (os_log_type_enabled((os_log_t)qword_100A19E80, OS_LOG_TYPE_DEFAULT))
      {
        LODWORD(buf) = 134217984;
        *(void *)((char *)&buf + 4) = v9;
        _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "Ignoring offline pairing request as there are too many paired devices (%lu)", (uint8_t *)&buf, 0xCu);
      }
      uint64_t v8 = 180;
    }
    else
    {
      sub_1000305AC(&buf, v7);
      p_long long buf = (const unsigned __int8 *)&buf;
      unsigned int v10 = sub_10071B344((uint64_t **)(a1 + 464), (unsigned __int8 *)&buf, (uint64_t)&unk_1007BE9D0, &p_buf);
      sub_100049EE0((uint64_t)(v10 + 6), a3);
      if (*(char *)(a4 + 23) < 0) {
        uint64_t v11 = *(void *)(a4 + 8);
      }
      else {
        uint64_t v11 = *(unsigned __int8 *)(a4 + 23);
      }
      if (v11)
      {
        if (qword_1009F7EE0 != -1) {
          dispatch_once(&qword_1009F7EE0, &stru_1009BFD48);
        }
        long long v13 = off_1009F7ED8;
        sub_1000305AC(&buf, v7);
        if (*(char *)(a4 + 23) < 0)
        {
          sub_10003B098(__p, *(void **)a4, *(void *)(a4 + 8));
        }
        else
        {
          *(_OWORD *)__p = *(_OWORD *)a4;
          uint64_t v27 = *(void *)(a4 + 16);
        }
        sub_1006B7F8C((uint64_t)v13, (unsigned __int8 *)&buf, (uint64_t)__p, 2);
        if (SHIBYTE(v27) < 0) {
          operator delete(__p[0]);
        }
      }
      sub_1003BC0D4(*(void *)(a3 + 8), 11, &buf);
      long long v14 = (unsigned __int8 *)sub_10004A6E4((uint64_t)&buf);
      uint64_t v15 = *v14;
      uint64_t v16 = v14[1];
      uint64_t v17 = v14[2];
      uint64_t v18 = v14[3];
      uint64_t v19 = v14[4];
      uint64_t v20 = v14[5];
      uint64_t v21 = v14[6];
      *(void *)&long long buf = &off_100998428;
      if (*((void *)&buf + 1)) {
        sub_1000368F4(*((atomic_uint **)&buf + 1));
      }
      if (qword_1009F7EE0 != -1) {
        dispatch_once(&qword_1009F7EE0, &stru_1009BFD48);
      }
      uint64_t v22 = sub_100030DCC((uint64_t)off_1009F7ED8, v7, 0);
      uint64_t v23 = sub_100019878();
      v25[0] = _NSConcreteStackBlock;
      v25[1] = 3221225472;
      v25[2] = sub_100713910;
      v25[3] = &unk_1009A12D0;
      v25[4] = a1;
      v25[5] = v22;
      v25[6] = (v15 << 48) | (v16 << 40) | (v17 << 32) | (v18 << 24) | (v19 << 16) | (v20 << 8) | v21;
      sub_100013018(v23, v25);
      uint64_t v8 = 0;
    }
  }

  return v8;
}

void sub_1007138A0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27)
{
  if (a22 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

void sub_100713910(void *a1)
{
  uint64_t v1 = a1[4];
  unint64_t v2 = a1[5];
  unint64_t v3 = a1[6];
  sub_10004191C(&__p, "");
  sub_10070A4A0(v1, v2, v3, 0, &__p);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
}

void sub_10071397C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

id sub_100713998(uint64_t a1, unint64_t a2)
{
  if ((a2 & 0xFFC00000000000) == 0x1400000000000)
  {
    uint64_t v4 = sub_1002284B8(a2);
    int v21 = v4;
    char v23 = BYTE6(v4);
    __int16 v22 = WORD2(v4);
    id v5 = *(const unsigned __int8 **)(a1 + 440);
    if (v5 == (const unsigned __int8 *)(a1 + 448))
    {
LABEL_16:
      uint64_t v11 = qword_100A19E80;
      if (os_log_type_enabled((os_log_t)qword_100A19E80, OS_LOG_TYPE_DEFAULT))
      {
        sub_1006AD3F0();
        id v12 = objc_claimAutoreleasedReturnValue();
        id v13 = [v12 UTF8String];
        *(_DWORD *)long long buf = 136446210;
        *(void *)&uint8_t buf[4] = v13;
        _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "address \"%{public}s\" is not tracked by LeDeviceManager, trying other devices now.", buf, 0xCu);
      }
      uint64_t v14 = 0;
      while (!*(unsigned char *)(a1 + v14 + 620) || !sub_100234C1C((uint64_t)&v21, (long long *)(a1 + v14 + 597)))
      {
        v14 += 24;
        if (v14 == 3120)
        {
          uint64_t v15 = qword_100A19E80;
          if (os_log_type_enabled((os_log_t)qword_100A19E80, OS_LOG_TYPE_DEFAULT))
          {
            sub_1006AD3F0();
            id v16 = objc_claimAutoreleasedReturnValue();
            id v17 = [v16 UTF8String];
            *(_DWORD *)long long buf = 136446210;
            *(void *)&uint8_t buf[4] = v17;
            _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "address \"%{public}s\" could not be resolved.", buf, 0xCu);
          }
          goto LABEL_26;
        }
      }
      if (qword_1009F7EE0 != -1) {
        dispatch_once(&qword_1009F7EE0, &stru_1009BFD48);
      }
      sub_100014B58((uint64_t)off_1009F7ED8, ((unint64_t)*(unsigned __int8 *)(a1 + v14 + 614) << 40) | ((unint64_t)*(unsigned __int8 *)(a1 + v14 + 615) << 32) | ((unint64_t)*(unsigned __int8 *)(a1 + v14 + 616) << 24) | ((unint64_t)*(unsigned __int8 *)(a1 + v14 + 617) << 16) | ((unint64_t)*(unsigned __int8 *)(a1 + v14 + 618) << 8) | *(unsigned __int8 *)(a1 + v14 + 619) | ((unint64_t)*(unsigned __int8 *)(a1 + v14 + 613) << 48), 1u, 1u, 0, 0, buf);
      unint64_t v2 = sub_100031234(buf);
    }
    else
    {
      while (1)
      {
        *(_OWORD *)long long buf = 0uLL;
        sub_1003BC0D4(*((void *)v5 + 7), 10, buf);
        if (sub_100013DCC((uint64_t)buf)
          || (uint64_t v6 = (long long *)sub_10004A6E4((uint64_t)buf), !sub_100234C1C((uint64_t)&v21, v6)))
        {
          int v7 = 1;
        }
        else
        {
          unint64_t v2 = sub_100031234(v5 + 32);
          int v7 = 0;
        }
        *(void *)long long buf = &off_100998428;
        if (*(void *)&buf[8]) {
          sub_1000368F4(*(atomic_uint **)&buf[8]);
        }
        if (!v7) {
          break;
        }
        uint64_t v8 = (unsigned __int8 *)*((void *)v5 + 1);
        if (v8)
        {
          do
          {
            unint64_t v9 = (const unsigned __int8 **)v8;
            uint64_t v8 = *(unsigned __int8 **)v8;
          }
          while (v8);
        }
        else
        {
          do
          {
            unint64_t v9 = (const unsigned __int8 **)*((void *)v5 + 2);
            BOOL v10 = *v9 == v5;
            id v5 = (const unsigned __int8 *)v9;
          }
          while (!v10);
        }
        id v5 = (const unsigned __int8 *)v9;
        if (v9 == (const unsigned __int8 **)(a1 + 448)) {
          goto LABEL_16;
        }
      }
    }
  }
  else
  {
    uint64_t v18 = qword_100A19E80;
    if (os_log_type_enabled((os_log_t)qword_100A19E80, OS_LOG_TYPE_DEFAULT))
    {
      sub_1006AD3F0();
      id v19 = objc_claimAutoreleasedReturnValue();
      *(_DWORD *)long long buf = 136446210;
      *(void *)&uint8_t buf[4] = [v19 UTF8String];
      _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "address \"%{public}s\" is not resolvable.", buf, 0xCu);
    }
LABEL_26:
    unint64_t v2 = 0;
  }

  return v2;
}

void sub_100713D20(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t sub_100713D84(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = sub_10003FB34();
  if ((*(unsigned int (**)(uint64_t))(*(void *)v4 + 2152))(v4))
  {
    if (sub_100008DC4(a1, v3))
    {
      if (v3 && *(unsigned char *)(a1 + 41))
      {
        *(_OWORD *)long long buf = 0uLL;
        sub_10003AED0((uint64_t)buf, a1 + 48);
        sub_1000305AC(&uu2, v3);
        uint64_t v5 = sub_1000308C0(a1 + 440, (unsigned __int8 *)&uu2);
        uint64_t v6 = v5;
        if (a1 + 448 == v5)
        {
          id v13 = qword_100A19E80;
          if (os_log_type_enabled((os_log_t)qword_100A19E80, OS_LOG_TYPE_DEFAULT))
          {
            LODWORD(uu2) = 138543362;
            *(void *)((char *)&uu2 + 4) = v3;
            _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "Device \"%{public}@\" does not have any keys for Fast IRK resolution", (uint8_t *)&uu2, 0xCu);
          }
          uint64_t v11 = 1601;
        }
        else
        {
          int v7 = (const unsigned __int8 *)(v5 + 32);
          uint64_t v8 = sub_100031234((const unsigned __int8 *)(v5 + 32));
          unsigned int v9 = [v8 isEqual:v3];

          if (v9)
          {
            long long uu2 = 0uLL;
            sub_1003BC0D4(*(void *)(v6 + 56), 10, &uu2);
            if (sub_100013DCC((uint64_t)&uu2))
            {
              BOOL v10 = qword_100A19E80;
              if (os_log_type_enabled((os_log_t)qword_100A19E80, OS_LOG_TYPE_DEFAULT))
              {
                int v20 = 138543362;
                id v21 = v3;
                _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "Device \"%{public}@\" has an empty IRK", (uint8_t *)&v20, 0xCu);
              }
              uint64_t v11 = 1601;
            }
            else
            {
              uint64_t v14 = sub_10003FB34();
              if (qword_1009F7EE0 != -1) {
                dispatch_once(&qword_1009F7EE0, &stru_1009BFD48);
              }
              uint64_t v15 = off_1009F7ED8;
              id v16 = sub_100031234(v7);
              uint64_t v17 = sub_100030DCC((uint64_t)v15, v16, 0);
              uint64_t v18 = sub_10004A6E4((uint64_t)&uu2);
              uint64_t v11 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)v14 + 384))(v14, v17, v18, 1);
            }
            *(void *)&long long uu2 = &off_100998428;
            if (*((void *)&uu2 + 1)) {
              sub_1000368F4(*((atomic_uint **)&uu2 + 1));
            }
          }
          else
          {
            uint64_t v11 = 0;
          }
        }
        sub_10003AFB4((uint64_t)buf);
      }
      else
      {
        uint64_t v11 = 0;
      }
    }
    else
    {
      id v12 = qword_100A19E80;
      if (os_log_type_enabled((os_log_t)qword_100A19E80, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)long long buf = 138543362;
        *(void *)&uint8_t buf[4] = v3;
        _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "Device \"%{public}@\" is not paired", buf, 0xCu);
      }
      uint64_t v11 = 1600;
    }
  }
  else
  {
    uint64_t v11 = 1602;
  }

  return v11;
}

void sub_1007140C4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  sub_10003AFB4((uint64_t)va);

  _Unwind_Resume(a1);
}

void sub_100714144(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  id v5 = a4;
  if (v5)
  {
    sub_1000305AC(buf, v5);
    if (a1 + 520 == sub_1000308C0(a1 + 512, (unsigned __int8 *)buf))
    {
      if (*(unsigned char *)(a1 + 41)) {
        operator new();
      }
      uint64_t v12 = qword_100A19E80;
      if (os_log_type_enabled((os_log_t)qword_100A19E80, OS_LOG_TYPE_DEFAULT))
      {
        buf[0] = 138543618;
        *(void *)&buf[1] = v5;
        __int16 v14 = 1024;
        LODWORD(v15) = 0;
        uint64_t v8 = "Unable to configure IRK for \"%{public}@\" since fStarted = %d";
        unsigned int v9 = v12;
        uint32_t v10 = 18;
        goto LABEL_5;
      }
    }
    else
    {
      uint64_t v6 = qword_100A19E80;
      if (os_log_type_enabled((os_log_t)qword_100A19E80, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v7 = *(void *)(a1 + 528);
        buf[0] = 134218242;
        *(void *)&buf[1] = v7;
        __int16 v14 = 2114;
        id v15 = v5;
        uint64_t v8 = "IRK is already configured size=%zu, %{public}@\" ";
        unsigned int v9 = v6;
        uint32_t v10 = 22;
LABEL_5:
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, v8, (uint8_t *)buf, v10);
      }
    }
  }
  else
  {
    uint64_t v11 = qword_100A19E80;
    if (os_log_type_enabled((os_log_t)qword_100A19E80, OS_LOG_TYPE_DEFAULT))
    {
      buf[0] = 138543362;
      *(void *)&buf[1] = 0;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "Device is nil in setTemporaryIrkForAddress IRK\"%{public}@\" ", (uint8_t *)buf, 0xCu);
    }
  }
}

void sub_1007144F4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, atomic_uint *a11)
{
  if (a11) {
    sub_1000368F4(a11);
  }

  _Unwind_Resume(a1);
}

uint64_t sub_100714570(uint64_t a1, _DWORD *a2, _OWORD *a3)
{
  uint64_t v3 = 0;
  if (a2 && a3)
  {
    v26[0] = 0;
    v26[1] = 0;
    sub_10003AED0((uint64_t)v26, a1 + 48);
    for (uint64_t i = 0; i != 3120; i += 24)
    {
      BOOL v8 = *(_DWORD *)(a1 + i + 613) == *a2 && *(_DWORD *)(a1 + i + 616) == *(_DWORD *)((char *)a2 + 3);
      if (v8 && *(unsigned char *)(a1 + i + 620))
      {
        *a3 = *(_OWORD *)(a1 + i + 597);
        uint64_t v3 = 1;
        goto LABEL_37;
      }
    }
    unsigned int v9 = *(void **)(a1 + 440);
    uint32_t v10 = (void *)(a1 + 448);
    if (v9 == (void *)(a1 + 448))
    {
      uint64_t v3 = 0;
    }
    else
    {
      do
      {
        char v24 = 0;
        char v25 = 0;
        sub_1003BC0D4(v9[7], 10, &v24);
        sub_1003BC0D4(v9[7], 11, &v22);
        uint64_t v12 = (_DWORD *)sub_10004A6E4((uint64_t)&v22);
        __int16 v22 = &off_100998428;
        if (v23) {
          sub_1000368F4(v23);
        }
        BOOL v13 = sub_100013DCC((uint64_t)&v24);
        if (v12) {
          char v14 = v13;
        }
        else {
          char v14 = 1;
        }
        if ((v14 & 1) == 0
          && (*v12 == *a2 ? (BOOL v15 = *(_DWORD *)((char *)v12 + 3) == *(_DWORD *)((char *)a2 + 3)) : (BOOL v15 = 0), v15))
        {
          id v19 = (const void *)sub_10004A6E4((uint64_t)&v24);
          size_t v20 = sub_100045F00((uint64_t)&v24);
          memcpy(a3, v19, v20);
          int v16 = 0;
        }
        else
        {
          int v16 = 1;
        }
        char v24 = &off_100998428;
        if (v25) {
          sub_1000368F4(v25);
        }
        if (!v16) {
          break;
        }
        uint64_t v17 = (void *)v9[1];
        if (v17)
        {
          do
          {
            uint64_t v18 = v17;
            uint64_t v17 = (void *)*v17;
          }
          while (v17);
        }
        else
        {
          do
          {
            uint64_t v18 = (void *)v9[2];
            BOOL v8 = *v18 == (void)v9;
            unsigned int v9 = v18;
          }
          while (!v8);
        }
        unsigned int v9 = v18;
      }
      while (v18 != v10);
      uint64_t v3 = v16 ^ 1u;
    }
LABEL_37:
    sub_10003AFB4((uint64_t)v26);
  }
  return v3;
}

void sub_100714788(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  sub_10003AFB4((uint64_t)va);
  _Unwind_Resume(a1);
}

BOOL sub_10071480C(uint64_t a1, void *a2, void *a3, unsigned char *a4, unint64_t *a5)
{
  id v9 = a2;
  if (sub_100008DC4(a1, v9))
  {
    if (sub_10070C8C8(a1, v9))
    {
      if (sub_10070C7E4(a1, v9))
      {
        uint32_t v10 = qword_100A19E80;
        BOOL v11 = 0;
        if (os_log_type_enabled((os_log_t)qword_100A19E80, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)long long buf = 138543362;
          id v46 = v9;
          uint64_t v12 = "Device \"%{public}@\" pairing at the moment, keys are not complete yet";
LABEL_10:
          _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, v12, buf, 0xCu);
          BOOL v11 = 0;
        }
      }
      else
      {
        v44[0] = 0;
        v44[1] = 0;
        sub_10003AED0((uint64_t)v44, a1 + 48);
        sub_1000305AC(buf, v9);
        uint64_t v13 = sub_1000308C0(a1 + 440, buf);
        if (a1 + 448 == v13)
        {
          int v16 = qword_100A19E80;
          BOOL v11 = 0;
          if (os_log_type_enabled((os_log_t)qword_100A19E80, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)long long buf = 138543362;
            id v46 = v9;
            _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "Device \"%{public}@\" does not have any keys", buf, 0xCu);
            BOOL v11 = 0;
          }
        }
        else
        {
          char v14 = *(atomic_uint **)(v13 + 56);
          uint64_t v42 = &off_1009B4578;
          int v43 = v14;
          if (v14)
          {
            sub_100037354((uint64_t)v14);
            char v14 = v43;
          }
          uint64_t v40 = 0;
          uint64_t v41 = 0;
          sub_1003BC0D4((uint64_t)v14, 10, &v40);
          if (sub_100013DCC((uint64_t)&v40))
          {
            BOOL v15 = qword_100A19E80;
            BOOL v11 = 0;
            if (os_log_type_enabled((os_log_t)qword_100A19E80, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)long long buf = 138543362;
              id v46 = v9;
              _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "Device \"%{public}@\" does not have an IRK", buf, 0xCu);
              BOOL v11 = 0;
            }
          }
          else
          {
            unsigned int v38 = 0;
            __int16 v39 = 0;
            sub_1003BC0D4((uint64_t)v43, 11, &v38);
            BOOL v33 = sub_100013DCC((uint64_t)&v38);
            if (v33)
            {
              uint64_t v17 = qword_100A19E80;
              if (os_log_type_enabled((os_log_t)qword_100A19E80, OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)long long buf = 138543362;
                id v46 = v9;
                _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "Device \"%{public}@\" does not have an identity address", buf, 0xCu);
              }
            }
            else
            {
              uint64_t v32 = *(unsigned __int8 *)(sub_10004A6E4((uint64_t)&v38) + 1);
              uint64_t v18 = *(unsigned __int8 *)(sub_10004A6E4((uint64_t)&v38) + 2);
              uint64_t v19 = *(unsigned __int8 *)(sub_10004A6E4((uint64_t)&v38) + 3);
              uint64_t v20 = *(unsigned __int8 *)(sub_10004A6E4((uint64_t)&v38) + 4);
              uint64_t v21 = *(unsigned __int8 *)(sub_10004A6E4((uint64_t)&v38) + 5);
              uint64_t v22 = *(unsigned __int8 *)(sub_10004A6E4((uint64_t)&v38) + 6);
              *a5 = (v32 << 40) | (v18 << 32) | (v19 << 24) | (v20 << 16) | (v21 << 8) | v22 | ((unint64_t)*(unsigned __int8 *)sub_10004A6E4((uint64_t)&v38) << 48);
              char v23 = (const void *)sub_10004A6E4((uint64_t)&v40);
              size_t v24 = sub_100045F00((uint64_t)&v40);
              memcpy(a3, v23, v24);
              *a4 = sub_100045F00((uint64_t)&v40);
              char v25 = qword_100A19E80;
              if (os_log_type_enabled((os_log_t)qword_100A19E80, OS_LOG_TYPE_DEFAULT))
              {
                unint64_t v26 = *a5;
                sub_10004C2C4((uint64_t)&v38, v36);
                int v27 = v37;
                id v28 = (void **)v36[0];
                sub_10004C2C4((uint64_t)&v40, __p);
                __int16 v29 = v36;
                if (v27 < 0) {
                  __int16 v29 = v28;
                }
                if (v35 >= 0) {
                  char v30 = __p;
                }
                else {
                  char v30 = (void **)__p[0];
                }
                *(_DWORD *)long long buf = 138544130;
                id v46 = v9;
                __int16 v47 = 2048;
                unint64_t v48 = v26;
                __int16 v49 = 2080;
                id v50 = v29;
                __int16 v51 = 2080;
                char v52 = v30;
                _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "device %{public}@ address:%lld identity:%s IRK:%s", buf, 0x2Au);
                if (v35 < 0) {
                  operator delete(__p[0]);
                }
                if (v37 < 0) {
                  operator delete(v36[0]);
                }
              }
            }
            BOOL v11 = !v33;
            unsigned int v38 = &off_100998428;
            if (v39) {
              sub_1000368F4(v39);
            }
          }
          uint64_t v40 = &off_100998428;
          if (v41) {
            sub_1000368F4(v41);
          }
          uint64_t v42 = &off_1009B4578;
          if (v43) {
            sub_1000368F4(v43);
          }
        }
        sub_10003AFB4((uint64_t)v44);
      }
    }
    else
    {
      uint32_t v10 = qword_100A19E80;
      BOOL v11 = 0;
      if (os_log_type_enabled((os_log_t)qword_100A19E80, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)long long buf = 138543362;
        id v46 = v9;
        uint64_t v12 = "Device \"%{public}@\" isn't bonded";
        goto LABEL_10;
      }
    }
  }
  else
  {
    uint32_t v10 = qword_100A19E80;
    BOOL v11 = 0;
    if (os_log_type_enabled((os_log_t)qword_100A19E80, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 138543362;
      id v46 = v9;
      uint64_t v12 = "Device \"%{public}@\" isn't paired";
      goto LABEL_10;
    }
  }

  return v11;
}

void sub_100714D60(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19, uint64_t a20,atomic_uint *a21,uint64_t a22,atomic_uint *a23,uint64_t a24,atomic_uint *a25,char a26)
{
  if (a19 < 0) {
    operator delete(__p);
  }
  if (a21) {
    sub_1000368F4(a21);
  }
  if (a23) {
    sub_1000368F4(a23);
  }
  if (a25) {
    sub_1000368F4(a25);
  }
  sub_10003AFB4((uint64_t)&a26);

  _Unwind_Resume(a1);
}

uint64_t sub_100714E30(uint64_t a1, unint64_t a2, uint64_t a3)
{
  if ((a2 & 0xFFC00000000000) == 0x1400000000000)
  {
    uint64_t v5 = sub_1002284B8(a2);
    int v26 = v5;
    char v28 = BYTE6(v5);
    __int16 v27 = WORD2(v5);
    *(_OWORD *)char v30 = 0uLL;
    sub_10003AED0((uint64_t)v30, a1 + 48);
    uint64_t v6 = *(void **)(a1 + 440);
    if (v6 == (void *)(a1 + 448))
    {
LABEL_13:
      for (uint64_t i = 0; i != 3120; i += 24)
      {
        if (*(unsigned char *)(a1 + i + 620) && sub_100234C1C((uint64_t)&v26, (long long *)(a1 + i + 597)))
        {
          uint64_t v15 = 0;
          int v18 = *(_DWORD *)(a1 + i + 613);
          __int16 v19 = *(_WORD *)(a1 + i + 617);
          *(unsigned char *)(a3 + 6) = *(unsigned char *)(a1 + i + 619);
          *(_WORD *)(a3 + 4) = v19;
          *(_DWORD *)a3 = v18;
          goto LABEL_29;
        }
      }
      uint64_t v12 = qword_100A19E80;
      if (os_log_type_enabled((os_log_t)qword_100A19E80, OS_LOG_TYPE_DEFAULT))
      {
        sub_1006AD3F0();
        id v13 = objc_claimAutoreleasedReturnValue();
        id v14 = [v13 UTF8String];
        LODWORD(buf) = 136446210;
        *(void *)((char *)&buf + 4) = v14;
        _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "address \"%{public}s\" could not be resolved.", (uint8_t *)&buf, 0xCu);
      }
      uint64_t v15 = 114;
    }
    else
    {
      while (1)
      {
        long long buf = 0uLL;
        sub_1003BC0D4(v6[7], 10, &buf);
        if (!sub_100013DCC((uint64_t)&buf))
        {
          uint64_t v7 = (long long *)sub_10004A6E4((uint64_t)&buf);
          if (sub_100234C1C((uint64_t)&v26, v7)) {
            break;
          }
        }
        *(void *)&long long buf = &off_100998428;
        if (*((void *)&buf + 1)) {
          sub_1000368F4(*((atomic_uint **)&buf + 1));
        }
        BOOL v8 = (void *)v6[1];
        if (v8)
        {
          do
          {
            id v9 = v8;
            BOOL v8 = (void *)*v8;
          }
          while (v8);
        }
        else
        {
          do
          {
            id v9 = (void *)v6[2];
            BOOL v10 = *v9 == (void)v6;
            uint64_t v6 = v9;
          }
          while (!v10);
        }
        uint64_t v6 = v9;
        if (v9 == (void *)(a1 + 448)) {
          goto LABEL_13;
        }
      }
      sub_1003BC0D4(v6[7], 11, &v24);
      uint64_t v20 = sub_10004A6E4((uint64_t)&v24);
      size_t v24 = &off_100998428;
      if (v25) {
        sub_1000368F4(v25);
      }
      int v21 = *(_DWORD *)v20;
      __int16 v22 = *(_WORD *)(v20 + 4);
      *(unsigned char *)(a3 + 6) = *(unsigned char *)(v20 + 6);
      *(_WORD *)(a3 + 4) = v22;
      *(_DWORD *)a3 = v21;
      *(void *)&long long buf = &off_100998428;
      if (*((void *)&buf + 1)) {
        sub_1000368F4(*((atomic_uint **)&buf + 1));
      }
      uint64_t v15 = 0;
    }
LABEL_29:
    sub_10003AFB4((uint64_t)v30);
  }
  else
  {
    int v16 = qword_100A19E80;
    if (os_log_type_enabled((os_log_t)qword_100A19E80, OS_LOG_TYPE_DEFAULT))
    {
      sub_1006AD3F0();
      id v17 = objc_claimAutoreleasedReturnValue();
      *(_DWORD *)char v30 = 136446210;
      *(void *)&v30[4] = [v17 UTF8String];
      _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "address \"%{public}s\" is not resolvable.", v30, 0xCu);
    }
    return 114;
  }
  return v15;
}

void sub_100715160(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, atomic_uint *a4, uint64_t a5, uint64_t a6, atomic_uint *a7, ...)
{
  va_start(va, a7);
  if (a4) {
    sub_1000368F4(a4);
  }
  if (a7) {
    sub_1000368F4(a7);
  }
  sub_10003AFB4((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_100715204(uint64_t a1, uint64_t a2, int a3, _OWORD *a4, _OWORD *a5, int a6, int a7, uint64_t a8)
{
  int v16 = qword_100A19E80;
  BOOL v17 = os_log_type_enabled((os_log_t)qword_100A19E80, OS_LOG_TYPE_DEFAULT);
  if (a3)
  {
    if (v17)
    {
      sub_1006ACF44();
      int v18 = v31 >= 0 ? v30 : *(unsigned char **)v30;
      LODWORD(buf[0]) = 136316675;
      *(void *)((char *)buf + 4) = v18;
      WORD6(buf[0]) = 1041;
      *(_DWORD *)((char *)buf + 14) = 16;
      WORD1(buf[1]) = 2097;
      *(void *)((char *)&buf[1] + 4) = a4;
      WORD6(buf[1]) = 1041;
      *(_DWORD *)((char *)&buf[1] + 14) = 16;
      WORD1(buf[2]) = 2097;
      *(void *)((char *)&buf[2] + 4) = a5;
      WORD6(buf[2]) = 1024;
      *(_DWORD *)((char *)&buf[2] + 14) = a6;
      WORD1(buf[3]) = 1024;
      DWORD1(buf[3]) = a7;
      _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "LeSecurityManager::classicDevicePaired CTKD Device address:%s LTK:%{private}.16P IRK:%{private}.16P useH7:%d Auth:%d", (uint8_t *)buf, 0x38u);
      if (v31 < 0) {
        operator delete(*(void **)v30);
      }
    }
    __int16 v19 = malloc_type_malloc(0x10uLL, 0x1EFD8FA5uLL);
    uint64_t v20 = malloc_type_malloc(0x10uLL, 0x7AF53DCAuLL);
    *__int16 v19 = *a5;
    *uint64_t v20 = *a4;
    *(void *)&buf[0] = 0;
    *((void *)&buf[0] + 1) = buf;
    *(void *)&buf[1] = 0x4812000000;
    *((void *)&buf[1] + 1) = sub_100715594;
    *(void *)&buf[2] = sub_1007155B0;
    memset((char *)&buf[2] + 8, 0, 32);
    if (*(char *)(a8 + 23) < 0)
    {
      sub_10003B098(&buf[3], *(void **)a8, *(void *)(a8 + 8));
    }
    else
    {
      _DWORD buf[3] = *(_OWORD *)a8;
      *(void *)&uint8_t buf[4] = *(void *)(a8 + 16);
    }
    uint64_t v23 = sub_100019878();
    v26[0] = _NSConcreteStackBlock;
    v26[1] = 3221225472;
    void v26[2] = sub_1007155C4;
    v26[3] = &unk_1009BFBE8;
    char v27 = a7;
    char v28 = a6;
    v26[6] = a2;
    v26[7] = v19;
    v26[8] = v20;
    v26[4] = buf;
    v26[5] = a1;
    sub_100013018(v23, v26);
    _Block_object_dispose(buf, 8);
    if (SBYTE7(buf[4]) < 0) {
      operator delete(*(void **)&buf[3]);
    }
  }
  else
  {
    if (v17)
    {
      sub_1006ACF44();
      int v21 = (SBYTE7(buf[1]) & 0x80u) == 0 ? buf : *(_OWORD **)&buf[0];
      *(_DWORD *)char v30 = 136315138;
      *(void *)&v30[4] = v21;
      _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "LeSecurityManager::classicDevicePaired Non CTKD Device address:%s", v30, 0xCu);
      if (SBYTE7(buf[1]) < 0) {
        operator delete(*(void **)&buf[0]);
      }
    }
    if (_os_feature_enabled_impl())
    {
      uint64_t v22 = sub_100019878();
      v25[0] = _NSConcreteStackBlock;
      v25[1] = 3221225472;
      v25[2] = sub_1007159EC;
      v25[3] = &unk_100998260;
      v25[4] = a1;
      v25[5] = a2;
      sub_100013018(v22, v25);
    }
  }
  return 0;
}

void sub_100715564(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,char a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,void *__p,uint64_t a32,int a33,__int16 a34,char a35,char a36)
{
  if (a36 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

__n128 sub_100715594(__n128 *a1, __n128 *a2)
{
  __n128 result = a2[3];
  a1[4].n128_u64[0] = a2[4].n128_u64[0];
  a1[3] = result;
  a2[3].n128_u64[1] = 0;
  a2[4].n128_u64[0] = 0;
  a2[3].n128_u64[0] = 0;
  return result;
}

void sub_1007155B0(uint64_t a1)
{
  if (*(char *)(a1 + 71) < 0) {
    operator delete(*(void **)(a1 + 48));
  }
}

uint64_t sub_1007155C4(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 40);
  v25[0] = 0;
  v25[1] = 0;
  sub_10003AED0((uint64_t)v25, v2 + 48);
  v26[0] = 0;
  v26[1] = 0;
  if (qword_1009F7EE0 != -1) {
    dispatch_once(&qword_1009F7EE0, &stru_1009BFD48);
  }
  sub_100014B58((uint64_t)off_1009F7ED8, *(void *)(a1 + 48), 1u, 1u, 0, 0, (unsigned __int8 *)v26);
  uint64_t v3 = sub_100031234((const unsigned __int8 *)v26);
  BOOL v4 = sub_100008DC4(v2, v3);

  if (!v4)
  {
    *(_DWORD *)((char *)v24 + 3) = 0;
    v24[0] = 0;
    uint64_t v5 = sub_1002284B8(*(void *)(a1 + 48));
    v24[0] = v5;
    BYTE2(v24[1]) = BYTE6(v5);
    LOWORD(v24[1]) = WORD2(v5);
    unsigned __int8 v23 = 16;
    if (*(unsigned char *)(a1 + 72)) {
      unsigned __int8 v6 = 3;
    }
    else {
      unsigned __int8 v6 = 2;
    }
    unsigned __int8 v22 = v6;
    if (*(unsigned char *)(a1 + 73)) {
      unsigned __int8 v7 = 2;
    }
    else {
      unsigned __int8 v7 = 1;
    }
    unsigned __int8 v21 = v7;
    sub_100710BB0(v2, *(void *)(a1 + 48), 10, *(unsigned __int8 **)(a1 + 56), 0x10u, 0);
    unint64_t v8 = *(void *)(a1 + 48);
    sub_1000335D8(&__p, v24, 7uLL);
    id v9 = (unsigned __int8 *)sub_10004A6E4((uint64_t)&__p);
    sub_100710BB0(v2, v8, 11, v9, 7u, 0);
    __p.__r_.__value_.__r.__words[0] = (std::string::size_type)&off_100998428;
    if (__p.__r_.__value_.__l.__size_) {
      sub_1000368F4((atomic_uint *)__p.__r_.__value_.__l.__size_);
    }
    sub_100710BB0(v2, *(void *)(a1 + 48), 5, *(unsigned __int8 **)(a1 + 64), 0x10u, 0);
    sub_100710BB0(v2, *(void *)(a1 + 48), 6, &v23, 1u, 0);
    sub_100710BB0(v2, *(void *)(a1 + 48), 7, &v22, 1u, 0);
    sub_100710BB0(v2, *(void *)(a1 + 48), 16, &v21, 1u, 0);
    unint64_t v10 = *(void *)(a1 + 48);
    sub_10004191C(&__p, "");
    sub_10070A4A0(v2, v10, v10, 0, &__p);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
    if (qword_1009F7EE0 != -1) {
      dispatch_once(&qword_1009F7EE0, &stru_1009BFD48);
    }
    BOOL v11 = off_1009F7ED8;
    uint64_t v12 = *(void *)(*(void *)(a1 + 32) + 8);
    if (*(char *)(v12 + 71) < 0)
    {
      sub_10003B098(__dst, *(void **)(v12 + 48), *(void *)(v12 + 56));
    }
    else
    {
      *(_OWORD *)__uuid_t dst = *(_OWORD *)(v12 + 48);
      uint64_t v19 = *(void *)(v12 + 64);
    }
    sub_1006B7F8C((uint64_t)v11, (unsigned __int8 *)v26, (uint64_t)__dst, 2);
    if (SHIBYTE(v19) < 0) {
      operator delete(__dst[0]);
    }
    if (qword_1009F7EE0 != -1) {
      dispatch_once(&qword_1009F7EE0, &stru_1009BFD48);
    }
    id v13 = off_1009F7ED8;
    id v14 = sub_100031234((const unsigned __int8 *)v26);
    sub_10004191C(v16, "_CTKD_");
    sub_1006BC69C((uint64_t)v13, v14, (unsigned __int8 *)v16);
    if (v17 < 0) {
      operator delete(v16[0]);
    }
  }
  free(*(void **)(a1 + 56));
  free(*(void **)(a1 + 64));
  return sub_10003AFB4((uint64_t)v25);
}

void sub_100715934(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,int a25,__int16 a26,char a27,char a28)
{
  if (a15 < 0) {
    operator delete(__p);
  }

  sub_10003AFB4(v29 - 88);
  _Unwind_Resume(a1);
}

uint64_t sub_1007159EC(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  v21[0] = 0;
  v21[1] = 0;
  sub_10003AED0((uint64_t)v21, v2 + 48);
  if (qword_1009F7EE0 != -1) {
    dispatch_once(&qword_1009F7EE0, &stru_1009BFD48);
  }
  sub_1006BE280((uint64_t)off_1009F7ED8, &off_1009E1A68);
  long long v19 = 0u;
  long long v20 = 0u;
  long long v17 = 0u;
  long long v18 = 0u;
  obuint64_t j = (id)objc_claimAutoreleasedReturnValue();
  id v3 = [obj countByEnumeratingWithState:&v17 objects:v22 count:16];
  if (v3)
  {
    uint64_t v4 = *(void *)v18;
    do
    {
      uint64_t v5 = 0;
      do
      {
        if (*(void *)v18 != v4) {
          objc_enumerationMutation(obj);
        }
        id v6 = *(id *)(*((void *)&v17 + 1) + 8 * (void)v5);
        if (qword_1009F7EE0 != -1) {
          dispatch_once(&qword_1009F7EE0, &stru_1009BFD48);
        }
        unsigned __int8 v7 = off_1009F7ED8;
        sub_10004191C(v15, "DA_ASK_RETAIN_DEVICE");
        if (sub_100030A04((uint64_t)v7, v6, (uint64_t)v15))
        {
          if (qword_1009F7EE0 != -1) {
            dispatch_once(&qword_1009F7EE0, &stru_1009BFD48);
          }
          unint64_t v8 = off_1009F7ED8;
          sub_10004191C(__p, "_CTKD_");
          int v9 = sub_100030A04((uint64_t)v8, v6, (uint64_t)__p) ^ 1;
          if (v14 < 0) {
            operator delete(__p[0]);
          }
        }
        else
        {
          int v9 = 0;
        }
        if (v16 < 0)
        {
          operator delete(v15[0]);
          if (!v9) {
            goto LABEL_29;
          }
        }
        else if (!v9)
        {
          goto LABEL_29;
        }
        if (qword_1009F7EE0 != -1) {
          dispatch_once(&qword_1009F7EE0, &stru_1009BFD48);
        }
        unint64_t v10 = sub_1006BE4EC((uint64_t)off_1009F7ED8, v6, @"ASK_RELATED_RADIO_ADDRESS");
        if (*(void *)(a1 + 40) == sub_1006ADA24(v10))
        {
          if (qword_1009F7EE0 != -1) {
            dispatch_once(&qword_1009F7EE0, &stru_1009BFD48);
          }
          sub_1006BE60C((uint64_t)off_1009F7ED8, v6, @"ASK_LINKED_RADIO_ADDRESS", v10);
          if (qword_1009F7EE0 != -1) {
            dispatch_once(&qword_1009F7EE0, &stru_1009BFD48);
          }
          sub_1006BE60C((uint64_t)off_1009F7ED8, v6, @"ASK_RELATED_RADIO_ADDRESS", 0);
        }

LABEL_29:
        uint64_t v5 = (char *)v5 + 1;
      }
      while (v3 != v5);
      id v3 = [obj countByEnumeratingWithState:&v17 objects:v22 count:16];
    }
    while (v3);
  }

  if (qword_1009F7EE0 != -1) {
    dispatch_once(&qword_1009F7EE0, &stru_1009BFD48);
  }
  sub_1006B93F4((uint64_t)off_1009F7ED8, 0);

  return sub_10003AFB4((uint64_t)v21);
}

void sub_100715D28(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, void *a17, uint64_t a18, int a19, __int16 a20,char a21,char a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,char a31)
{
  sub_10003AFB4((uint64_t)&a31);
  _Unwind_Resume(a1);
}

uint64_t sub_100715DB8(uint64_t a1, uint64_t a2, int a3)
{
  id v6 = qword_100A19E80;
  if (os_log_type_enabled((os_log_t)qword_100A19E80, OS_LOG_TYPE_DEFAULT))
  {
    unsigned __int8 v7 = sub_1006ACEAC();
    *(_DWORD *)long long buf = 138543618;
    *(void *)&uint8_t buf[4] = v7;
    *(_WORD *)&unsigned char buf[12] = 1024;
    *(_DWORD *)&buf[14] = a3;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "Trying to unpair classic device %{public}@ ctkd:%d", buf, 0x12u);
  }
  if (a2)
  {
    *(void *)long long buf = 0;
    *(void *)&uint8_t buf[8] = 0;
    if (qword_1009F7EE0 != -1) {
      dispatch_once(&qword_1009F7EE0, &stru_1009BFD48);
    }
    sub_100014B58(buf, off_1009F7ED8, a2, 0, 1, 0, 0);
    if (uuid_is_null(buf)) {
      return 101;
    }
    if (a3)
    {
      int v9 = sub_100031234(buf);
      BOOL v10 = sub_100008DC4(a1, v9);

      if (v10)
      {
        if (qword_1009F7EE0 != -1) {
          dispatch_once(&qword_1009F7EE0, &stru_1009BFD48);
        }
        BOOL v11 = off_1009F7ED8;
        uint64_t v12 = sub_100031234(buf);
        sub_10004191C(__p, "_CTKD_");
        int v13 = sub_100030A04((uint64_t)v11, v12, (uint64_t)__p);
        if (v27 < 0) {
          operator delete(__p[0]);
        }

        if (v13)
        {
          char v14 = qword_100A19E80;
          if (os_log_type_enabled((os_log_t)qword_100A19E80, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)char v25 = 0;
            _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "Removing _CTKD_ Tag", v25, 2u);
          }
          if (qword_1009F7EE0 != -1) {
            dispatch_once(&qword_1009F7EE0, &stru_1009BFD48);
          }
          uint64_t v15 = off_1009F7ED8;
          char v16 = sub_100031234(buf);
          sub_1006B85C0((uint64_t)v15, v16, @"_CTKD_");

          uint64_t v17 = sub_100019878();
          v28[0] = _NSConcreteStackBlock;
          v28[1] = 3321888768;
          void v28[2] = sub_1007161D4;
          v28[3] = &unk_1009A2CC0;
          v28[4] = a1;
          uuid_copy(v29, buf);
          sub_1000197D8(v17, v28);
        }
      }
    }
    else
    {
      uint64_t result = _os_feature_enabled_impl();
      if (!result) {
        return result;
      }
      if (qword_1009F7EE0 != -1) {
        dispatch_once(&qword_1009F7EE0, &stru_1009BFD48);
      }
      long long v18 = off_1009F7ED8;
      long long v19 = sub_100031234(buf);
      sub_10004191C(v23, "_CTKD_");
      char v20 = sub_100030A04((uint64_t)v18, v19, (uint64_t)v23);
      if (v24 < 0) {
        operator delete(v23[0]);
      }

      if ((v20 & 1) == 0)
      {
        uint64_t v21 = sub_100019878();
        v22[0] = _NSConcreteStackBlock;
        v22[1] = 3221225472;
        void v22[2] = sub_100716240;
        v22[3] = &unk_100998260;
        v22[4] = a1;
        v22[5] = a2;
        sub_100013018(v21, v22);
      }
    }
  }
  return 0;
}

void sub_100716184(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,int a26,__int16 a27,char a28,char a29)
{
  _Unwind_Resume(a1);
}

void sub_1007161D4(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  sub_100031234((const unsigned __int8 *)(a1 + 40));
  id v2 = (id)objc_claimAutoreleasedReturnValue();
  sub_10070BF0C(v1, v2);
}

void sub_10071622C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_100716240(uint64_t a1)
{
  uint64_t v13 = *(void *)(a1 + 32);
  if (qword_1009F7EE0 != -1) {
    dispatch_once(&qword_1009F7EE0, &stru_1009BFD48);
  }
  id v2 = sub_1006BE280((uint64_t)off_1009F7ED8, &off_1009E1A80);
  id v3 = qword_100A19E80;
  if (os_log_type_enabled((os_log_t)qword_100A19E80, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)long long buf = 138412290;
    *(void *)&uint8_t buf[4] = v2;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_INFO, "Found LE Devices linked with classic radios:%@", buf, 0xCu);
  }
  long long v17 = 0u;
  long long v18 = 0u;
  long long v15 = 0u;
  long long v16 = 0u;
  obuint64_t j = v2;
  id v4 = [obj countByEnumeratingWithState:&v15 objects:v25 count:16];
  if (v4)
  {
    uint64_t v5 = *(void *)v16;
    while (2)
    {
      id v6 = 0;
      do
      {
        if (*(void *)v16 != v5) {
          objc_enumerationMutation(obj);
        }
        id v7 = *(id *)(*((void *)&v15 + 1) + 8 * (void)v6);
        if (qword_1009F7EE0 != -1) {
          dispatch_once(&qword_1009F7EE0, &stru_1009BFD48);
        }
        unint64_t v8 = sub_1006BE4EC((uint64_t)off_1009F7ED8, v7, @"ASK_LINKED_RADIO_ADDRESS");
        unint64_t v9 = sub_1006ADA24(v8);
        BOOL v10 = qword_100A19E80;
        if (os_log_type_enabled((os_log_t)qword_100A19E80, OS_LOG_TYPE_INFO))
        {
          sub_1006ACF44();
          BOOL v11 = buf;
          if (v20 < 0) {
            BOOL v11 = *(unsigned char **)buf;
          }
          *(_DWORD *)uint64_t v21 = 138412547;
          id v22 = v7;
          __int16 v23 = 2081;
          char v24 = v11;
          _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_INFO, "%@ has linked address %{private}s", v21, 0x16u);
          if (v20 < 0) {
            operator delete(*(void **)buf);
          }
        }
        if (*(void *)(a1 + 40) == v9)
        {
          if (qword_1009F7EE0 != -1) {
            dispatch_once(&qword_1009F7EE0, &stru_1009BFD48);
          }
          sub_1006BE60C((uint64_t)off_1009F7ED8, v7, @"ASK_LINKED_RADIO_ADDRESS", 0);
          if (qword_1009F7EE0 != -1) {
            dispatch_once(&qword_1009F7EE0, &stru_1009BFD48);
          }
          sub_1006BE60C((uint64_t)off_1009F7ED8, v7, @"ASK_RELATED_RADIO_ADDRESS", 0);
          if (sub_100008DC4(v13, v7))
          {
            uint64_t v12 = qword_100A19E80;
            if (os_log_type_enabled((os_log_t)qword_100A19E80, OS_LOG_TYPE_INFO))
            {
              *(_DWORD *)long long buf = 138412290;
              *(void *)&uint8_t buf[4] = v7;
              _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_INFO, "Unpairing LE device %@", buf, 0xCu);
            }
            sub_10070BF0C(v13, v7);
          }
          else
          {
            if (qword_1009F7EE0 != -1) {
              dispatch_once(&qword_1009F7EE0, &stru_1009BFD48);
            }
            sub_1006B85C0((uint64_t)off_1009F7ED8, v7, @"DA_ASK_RETAIN_DEVICE");
            if (qword_1009F7EE0 != -1) {
              dispatch_once(&qword_1009F7EE0, &stru_1009BFD48);
            }
            sub_1006B7A50(off_1009F7ED8, v7);
          }

          goto LABEL_35;
        }

        id v6 = (char *)v6 + 1;
      }
      while (v4 != v6);
      id v4 = [obj countByEnumeratingWithState:&v15 objects:v25 count:16];
      if (v4) {
        continue;
      }
      break;
    }
  }
LABEL_35:
}

void sub_100716654(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{
  _Unwind_Resume(a1);
}

void sub_1007166A0(uint64_t a1, void *a2)
{
  id v2 = a2;
  uint64_t v3 = sub_100035F54();
  if ((*(unsigned int (**)(uint64_t))(*(void *)v3 + 344))(v3))
  {
    uint64_t v9 = 0;
    if (qword_1009F7EC0 != -1) {
      dispatch_once(&qword_1009F7EC0, &stru_1009BFD68);
    }
    id v4 = off_1009F7EB8;
    sub_1000305AC(buf, v2);
    if (sub_1006856B8((uint64_t)v4, buf, &v9))
    {
      char v8 = 0;
      sub_10001B8E0(&v8);
      char v5 = sub_1000EAA20(v9);
      id v6 = qword_100A19E80;
      BOOL v7 = os_log_type_enabled((os_log_t)qword_100A19E80, OS_LOG_TYPE_DEFAULT);
      if (v5)
      {
        if (v7)
        {
          *(_DWORD *)long long buf = 138543362;
          id v11 = v2;
          _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "Not disabled CTKD for device %{public}@", buf, 0xCu);
        }
      }
      else
      {
        if (v7)
        {
          *(_DWORD *)long long buf = 138543362;
          id v11 = v2;
          _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "Warning: Disabled CTKD for device %{public}@", buf, 0xCu);
        }
        sub_100240540(v9, 1);
      }
      sub_10001B8AC(&v8);
    }
  }
}

void sub_100716848(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_10071687C()
{
  uint64_t v0 = sub_100017768();
  if ((*(unsigned int (**)(uint64_t))(*(void *)v0 + 176))(v0))
  {
    uint64_t v1 = qword_100A19F98;
    if (os_log_type_enabled((os_log_t)qword_100A19F98, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_DEFAULT, "checkCTDebugVectors started", buf, 2u);
    }
  }
  uint64_t v2 = sub_100017768();
  if ((*(unsigned int (**)(uint64_t))(*(void *)v2 + 176))(v2))
  {
    uint64_t v3 = qword_100A19F98;
    if (os_log_type_enabled((os_log_t)qword_100A19F98, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)id v4 = 0;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "checkCTDebugVectors completed!", v4, 2u);
    }
  }
}

uint64_t sub_100716978(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v7[0] = 0;
  v7[1] = 0;
  uint64_t v5 = sub_1007169F8(a1, (uint64_t)v7, 0x10uLL, 0);
  return sub_100716C64(v5, (uint64_t)v7, 0, a2, a3);
}

uint64_t sub_1007169F8(uint64_t a1, uint64_t a2, unint64_t a3, char a4)
{
  char v7 = sub_1007179F4(a1) ^ 1 | a4;
  unsigned int v8 = ((CFAbsoluteTimeGetCurrent() + kCFAbsoluteTimeIntervalSince1970) / 600.0)
     / *(_DWORD *)(a1 + 32)
     * *(_DWORD *)(a1 + 32);
  uint64_t v9 = sub_100017768();
  if ((*(unsigned int (**)(uint64_t))(*(void *)v9 + 184))(v9))
  {
    BOOL v10 = qword_100A19F98;
    if (os_log_type_enabled((os_log_t)qword_100A19F98, OS_LOG_TYPE_DEFAULT))
    {
      int v12 = *(_DWORD *)(a1 + 32);
      int v11 = *(_DWORD *)(a1 + 36);
      int v20 = 67109632;
      int v21 = v8;
      __int16 v22 = 1024;
      *(_DWORD *)__int16 v23 = v11;
      *(_WORD *)&v23[4] = 1024;
      *(_DWORD *)&v23[6] = v12;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "getCurrentTEK interval=%d fENIntervalNumber=%d fEKRollingPeriod=%d", (uint8_t *)&v20, 0x14u);
    }
  }
  if ((v7 & 1) != 0
    || v8 >= *(_DWORD *)(a1 + 32) + *(_DWORD *)(a1 + 36)
    || ![*(id *)(a1 + 24) count]
    || v8 < *(_DWORD *)(a1 + 36))
  {
    *(_DWORD *)(a1 + 36) = v8;
    uint64_t v13 = sub_100717D40(a1, v8);
    sub_100717E7C(a1, v13);
  }
  char v14 = [*(id *)(a1 + 24) objectAtIndex:0];
  long long v15 = v14;
  if (a3 >= 0x10) {
    uint64_t v16 = 16;
  }
  else {
    uint64_t v16 = a3;
  }
  [v14 getBytes:a2 length:v16];

  uint64_t v17 = sub_100017768();
  if ((*(unsigned int (**)(uint64_t))(*(void *)v17 + 184))(v17))
  {
    long long v18 = qword_100A19F98;
    if (os_log_type_enabled((os_log_t)qword_100A19F98, OS_LOG_TYPE_DEFAULT))
    {
      int v20 = 68157954;
      int v21 = 16;
      __int16 v22 = 2096;
      *(void *)__int16 v23 = a2;
      _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "getCurrentTEK returning %.16P", (uint8_t *)&v20, 0x12u);
    }
  }
  return 0;
}

void sub_100716C48(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t sub_100716C64(uint64_t a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5)
{
  uint64_t result = 3;
  if (a4 && a5 == 16)
  {
    if (!a3) {
      CFAbsoluteTimeGetCurrent();
    }
    ENRPIKDerive();
    ENRPIDerive();
    return 0;
  }
  return result;
}

uint64_t sub_100716D24(uint64_t a1)
{
  uint64_t v2 = sub_100017768();
  if ((*(unsigned int (**)(uint64_t))(*(void *)v2 + 176))(v2))
  {
    uint64_t v3 = qword_100A19F98;
    if (os_log_type_enabled((os_log_t)qword_100A19F98, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)char v7 = 0;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Erasing TEK History", v7, 2u);
    }
  }
  uint64_t v4 = +[NSMutableArray array];
  uint64_t v5 = *(void **)(a1 + 24);
  *(void *)(a1 + 24) = v4;

  sub_1003137A0(12);
  sub_100716E1C(a1);
  if (qword_1009FB798 != -1) {
    dispatch_once(&qword_1009FB798, &stru_1009BFDE8);
  }
  return sub_10044B980((uint64_t)off_1009FB790);
}

BOOL sub_100716E1C(uint64_t a1)
{
  uint64_t v2 = sub_100017768();
  if ((*(unsigned int (**)(uint64_t))(*(void *)v2 + 184))(v2))
  {
    uint64_t v3 = qword_100A19F98;
    if (os_log_type_enabled((os_log_t)qword_100A19F98, OS_LOG_TYPE_DEBUG)) {
      sub_1007987D4(a1, v3);
    }
  }
  unsigned __int16 v4 = (unsigned __int16)[*(id *)(a1 + 24) count];
  LOWORD(v13) = 22 * v4;
  if (22 * v4)
  {
    uint64_t v5 = (char *)malloc_type_malloc((unsigned __int16)(22 * v4), 0xCB64FB4DuLL);
    bzero(v5, (unsigned __int16)v13);
    if ([*(id *)(a1 + 24) count])
    {
      unint64_t v6 = 0;
      unsigned __int16 v7 = 0;
      do
      {
        v5[v7] = 21;
        unsigned __int16 v8 = v7 + 1;
        uint64_t v9 = [*(id *)(a1 + 24) objectAtIndex:v6];
        [v9 getBytes:&v5[v8] length:21];

        unsigned __int16 v7 = v8 + 21;
        ++v6;
      }
      while ((unint64_t)[*(id *)(a1 + 24) count] > v6);
    }
    int v10 = sub_100313540(0xEu, (const UInt8 *)v5, (unsigned __int16)v13);
    if (v10)
    {
      int v11 = v10;
      if (os_log_type_enabled((os_log_t)qword_100A19F90, OS_LOG_TYPE_ERROR)) {
        sub_10079876C();
      }
    }
    else
    {
      int v11 = sub_100313540(0xDu, (const UInt8 *)&v13, 2u);
      if (v11 && os_log_type_enabled((os_log_t)qword_100A19F90, OS_LOG_TYPE_ERROR)) {
        sub_100798704();
      }
    }
    free(v5);
  }
  else
  {
    if (sub_1003137A0(14) && os_log_type_enabled((os_log_t)qword_100A19F90, OS_LOG_TYPE_ERROR)) {
      sub_10079876C();
    }
    if (sub_100313540(0xDu, (const UInt8 *)&v13, 2u))
    {
      if (os_log_type_enabled((os_log_t)qword_100A19F90, OS_LOG_TYPE_ERROR)) {
        sub_100798704();
      }
      int v11 = 1;
    }
    else
    {
      int v11 = 0;
    }
  }
  return v11 != 0;
}

void sub_100717070(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id sub_100717080(uint64_t a1, char a2, int a3)
{
  if (a3)
  {
    sub_100717160(a1);
    if (*(unsigned char *)(a1 + 41))
    {
      if (qword_1009FB798 != -1) {
        dispatch_once(&qword_1009FB798, &stru_1009BFDE8);
      }
      if (*((void *)off_1009FB790 + 10)) {
        sub_100717424(a1);
      }
    }
  }
  sub_10071754C(a1);
  if (a2) {
    uint64_t v5 = 0;
  }
  else {
    uint64_t v5 = sub_1007179F4(a1);
  }
  if ([*(id *)(a1 + 24) count])
  {
    unint64_t v6 = [[*(id *)(a1 + 24) subarrayWithRange:v5, [*(id *)(a1 + 24) count] - v5];
  }
  else
  {
    unint64_t v6 = &__NSArray0__struct;
  }

  return v6;
}

uint64_t sub_100717160(uint64_t a1)
{
  if (sub_1007179F4(a1))
  {
    memset(&v18[1], 0, 13);
    uint64_t v2 = (id *)(a1 + 24);
    uint64_t v3 = [*(id *)(a1 + 24) objectAtIndex:0];
    [v3 getBytes:v18 length:21];

    int v4 = LOBYTE(v18[2]);
    LODWORD(v3) = BYTE1(v18[2]);
    int v5 = BYTE2(v18[2]);
    int v6 = BYTE3(v18[2]);
    double Current = CFAbsoluteTimeGetCurrent();
    uint64_t v8 = sub_100017768();
    unsigned int v9 = ((Current + kCFAbsoluteTimeIntervalSince1970) / 600.0)
       - (v4 | (v3 << 8) | (v5 << 16) | (v6 << 24));
    if ((*(unsigned int (**)(uint64_t))(*(void *)v8 + 184))(v8)
      && os_log_type_enabled((os_log_t)qword_100A19F98, OS_LOG_TYPE_DEBUG))
    {
      sub_100798954();
    }
    if (v9 < *(_DWORD *)(a1 + 32))
    {
      BYTE4(v18[2]) = ((kCFAbsoluteTimeIntervalSince1970 + CFAbsoluteTimeGetCurrent()) / 600.0) - v4 + 1;
      uint64_t v10 = sub_100017768();
      if ((*(unsigned int (**)(uint64_t))(*(void *)v10 + 184))(v10))
      {
        int v11 = qword_100A19F98;
        if (os_log_type_enabled((os_log_t)qword_100A19F98, OS_LOG_TYPE_DEBUG)) {
          sub_1007988CC((uint64_t)v18, v11);
        }
      }
      [*v2 removeObjectAtIndex:0];
      id v12 = *v2;
      size_t v13 = +[NSData dataWithBytes:v18 length:21];
      [v12 insertObject:v13 atIndex:0];

      uint64_t v14 = sub_100017768();
      if ((*(unsigned int (**)(uint64_t))(*(void *)v14 + 184))(v14))
      {
        long long v15 = qword_100A19F98;
        if (os_log_type_enabled((os_log_t)qword_100A19F98, OS_LOG_TYPE_DEBUG)) {
          sub_100798850((uint64_t *)v2, v15);
        }
      }
    }
  }
  else
  {
    uint64_t v16 = sub_100017768();
    if ((*(unsigned int (**)(uint64_t))(*(void *)v16 + 184))(v16)
      && os_log_type_enabled((os_log_t)qword_100A19F98, OS_LOG_TYPE_DEBUG))
    {
      sub_1007989C8();
    }
  }
  return 0;
}

void sub_100717408(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t sub_100717424(uint64_t a1)
{
  v7[0] = 0;
  v7[1] = 0;
  sub_1007169F8(a1, (uint64_t)v7, 0x10uLL, 1);
  uint64_t v1 = sub_100017768();
  if ((*(unsigned int (**)(uint64_t))(*(void *)v1 + 184))(v1))
  {
    uint64_t v2 = qword_100A19F98;
    if (os_log_type_enabled((os_log_t)qword_100A19F98, OS_LOG_TYPE_DEFAULT))
    {
      v4[0] = 68157954;
      v4[1] = 16;
      __int16 v5 = 2096;
      int v6 = v7;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "forceRefreshTEK new TEK:%.16P", (uint8_t *)v4, 0x12u);
    }
  }
  if (qword_1009FB798 != -1) {
    dispatch_once(&qword_1009FB798, &stru_1009BFDE8);
  }
  return sub_10044B980((uint64_t)off_1009FB790);
}

uint64_t sub_10071754C(uint64_t a1)
{
  obuint64_t j = +[NSMutableArray array];
  double Current = CFAbsoluteTimeGetCurrent();
  unsigned int v2 = *(_DWORD *)(a1 + 32);
  uint64_t v3 = sub_100017768();
  unsigned int v4 = ((Current + kCFAbsoluteTimeIntervalSince1970) / 600.0) / v2 * v2 - 2016;
  if ((*(unsigned int (**)(uint64_t))(*(void *)v3 + 184))(v3)
    && os_log_type_enabled((os_log_t)qword_100A19F98, OS_LOG_TYPE_DEBUG))
  {
    sub_100798A08();
  }
  long long v33 = 0u;
  long long v34 = 0u;
  long long v31 = 0u;
  long long v32 = 0u;
  __int16 v5 = *(void **)(a1 + 24);
  locationa = (id *)(a1 + 24);
  id v6 = v5;
  id v7 = [v6 countByEnumeratingWithState:&v31 objects:v43 count:16];
  if (v7)
  {
    uint64_t v8 = *(void *)v32;
    do
    {
      unsigned int v9 = 0;
      do
      {
        if (*(void *)v32 != v8) {
          objc_enumerationMutation(v6);
        }
        id v10 = *(id *)(*((void *)&v31 + 1) + 8 * (void)v9);
        int v11 = *((unsigned __int8 *)[v10 bytes] + 16);
        id v12 = v10;
        int v13 = *((unsigned __int8 *)[v12 bytes] + 17);
        id v14 = v12;
        int v15 = *((unsigned __int8 *)[v14 bytes] + 18);
        id v16 = v14;
        LODWORD(v14) = *((unsigned __int8 *)[v16 bytes] + 19);
        uint64_t v17 = sub_100017768();
        unsigned int v18 = v11 | (v13 << 8) | (v15 << 16) | (v14 << 24);
        if ((*(unsigned int (**)(uint64_t))(*(void *)v17 + 184))(v17))
        {
          long long v19 = qword_100A19F98;
          if (os_log_type_enabled((os_log_t)qword_100A19F98, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)long long buf = 138413058;
            id v36 = v16;
            __int16 v37 = 1024;
            unsigned int v38 = v18;
            __int16 v39 = 1024;
            unsigned int v40 = v4;
            __int16 v41 = 1024;
            unsigned int v42 = v18 - v4;
            _os_log_debug_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEBUG, "maintainTEKList key:%@ ENIN:%d oldestInterval:%d delta:%d", buf, 0x1Eu);
          }
        }
        if (v18 <= v4)
        {
          uint64_t v22 = sub_100017768();
          if ((*(unsigned int (**)(uint64_t))(*(void *)v22 + 184))(v22))
          {
            __int16 v23 = qword_100A19F98;
            if (os_log_type_enabled((os_log_t)qword_100A19F98, OS_LOG_TYPE_DEBUG))
            {
              *(_DWORD *)long long buf = 138412290;
              id v36 = v16;
              _os_log_debug_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEBUG, "dropping %@ as its too old", buf, 0xCu);
            }
          }
        }
        else
        {
          uint64_t v20 = sub_100017768();
          if ((*(unsigned int (**)(uint64_t))(*(void *)v20 + 184))(v20))
          {
            int v21 = qword_100A19F98;
            if (os_log_type_enabled((os_log_t)qword_100A19F98, OS_LOG_TYPE_DEBUG))
            {
              *(_DWORD *)long long buf = 138412290;
              id v36 = v16;
              _os_log_debug_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEBUG, "keeping %@", buf, 0xCu);
            }
          }
          [obj addObject:v16];
        }
        unsigned int v9 = (char *)v9 + 1;
      }
      while (v7 != v9);
      id v7 = [v6 countByEnumeratingWithState:&v31 objects:v43 count:16];
    }
    while (v7);
  }

  objc_storeStrong(locationa, obj);
  uint64_t v24 = sub_100017768();
  if ((*(unsigned int (**)(uint64_t))(*(void *)v24 + 184))(v24))
  {
    char v25 = qword_100A19F98;
    if (os_log_type_enabled((os_log_t)qword_100A19F98, OS_LOG_TYPE_INFO))
    {
      id v26 = *locationa;
      *(_DWORD *)long long buf = 138412290;
      id v36 = v26;
      _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_INFO, "updated list of keys:%@", buf, 0xCu);
    }
  }

  return 0;
}

void sub_1007179BC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *a16)
{
  _Unwind_Resume(a1);
}

id sub_1007179F4(uint64_t a1)
{
  id result = [*(id *)(a1 + 24) count];
  if (result)
  {
    id v3 = [*(id *)(a1 + 24) objectAtIndex:0];
    unsigned int v4 = (unsigned __int8 *)[v3 bytes];

    uint64_t v5 = sub_100017768();
    if ((*(unsigned int (**)(uint64_t))(*(void *)v5 + 184))(v5))
    {
      id v6 = qword_100A19F98;
      if (os_log_type_enabled((os_log_t)qword_100A19F98, OS_LOG_TYPE_DEBUG)) {
        sub_100798A70((uint64_t)v4, a1, v6);
      }
    }
    return (id)(*(_DWORD *)(a1 + 32) == v4[20]);
  }
  return result;
}

void sub_100717AB8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t sub_100717AC8(CFAbsoluteTime a1)
{
  if (a1 == 0.0) {
    a1 = CFAbsoluteTimeGetCurrent() + kCFAbsoluteTimeIntervalSince1970;
  }
  return (a1 / 600.0);
}

void sub_100717B08(uint64_t a1, int a2)
{
  [*(id *)(a1 + 24) removeAllObjects];
  double Current = CFAbsoluteTimeGetCurrent();
  unsigned int v5 = *(_DWORD *)(a1 + 32);
  uint64_t v6 = sub_100017768();
  if ((*(unsigned int (**)(uint64_t))(*(void *)v6 + 176))(v6)
    && os_log_type_enabled((os_log_t)qword_100A19F98, OS_LOG_TYPE_DEBUG))
  {
    sub_100798AF0();
  }
  unsigned int v7 = *(_DWORD *)(a1 + 32);
  if (0x90 / v7 * a2)
  {
    unsigned int v8 = 0;
    unsigned int v9 = ((Current + kCFAbsoluteTimeIntervalSince1970) / 600.0) / v5 * v5 - 144 * a2;
    do
    {
      id v10 = sub_100717D40(a1, v9 + v7 * v8);
      sub_100717E7C(a1, v10);
      int v11 = *(_DWORD *)(a1 + 32);
      uint64_t v12 = sub_100017768();
      v9 += v11;
      if ((*(unsigned int (**)(uint64_t))(*(void *)v12 + 176))(v12))
      {
        int v13 = qword_100A19F98;
        if (os_log_type_enabled((os_log_t)qword_100A19F98, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)long long buf = 67109634;
          unsigned int v15 = v8;
          __int16 v16 = 1024;
          unsigned int v17 = v9;
          __int16 v18 = 2112;
          long long v19 = v10;
          _os_log_debug_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEBUG, "debugFillTEKHistory i:%d interval:%d tek:%@", buf, 0x18u);
        }
      }

      ++v8;
      unsigned int v7 = *(_DWORD *)(a1 + 32);
    }
    while (v8 < 0x90 / v7 * a2);
  }
}

void sub_100717D28(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id sub_100717D40(uint64_t a1, int a2)
{
  memset(__buf, 0, 21);
  arc4random_buf(__buf, 0x10uLL);
  LODWORD(__buf[2]) = a2;
  BYTE4(__buf[2]) = *(_DWORD *)(a1 + 32);
  uint64_t v4 = sub_100017768();
  if ((*(unsigned int (**)(uint64_t))(*(void *)v4 + 184))(v4))
  {
    unsigned int v5 = qword_100A19F98;
    if (os_log_type_enabled((os_log_t)qword_100A19F98, OS_LOG_TYPE_DEFAULT))
    {
      v8[0] = 68158210;
      v8[1] = 21;
      __int16 v9 = 2096;
      id v10 = __buf;
      __int16 v11 = 1024;
      int v12 = a2;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "createTEKForInterval outBuffer %.21P interval:%d", (uint8_t *)v8, 0x18u);
    }
  }
  uint64_t v6 = +[NSData dataWithBytes:__buf length:21];

  return v6;
}

void sub_100717E7C(uint64_t a1, void *a2)
{
  id v3 = a2;
  [*(id *)(a1 + 24) insertObject:v3 atIndex:0];
  uint64_t v4 = sub_100017768();
  if ((*(unsigned int (**)(uint64_t))(*(void *)v4 + 184))(v4)
    && os_log_type_enabled((os_log_t)qword_100A19F98, OS_LOG_TYPE_DEBUG))
  {
    sub_100798B64();
  }
  sub_10071754C(a1);
  sub_100716E1C(a1);
}

void sub_100717F30(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t sub_100717F40(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t result = 3;
  if (a2 && a3 && a4)
  {
    if (a5)
    {
      ENRPIMetadataSerialize();
      ENAEMKDerive();
      ENAEMCrypt();
      return 0;
    }
  }
  return result;
}

uint64_t sub_100717FF4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unsigned __int8 *a5)
{
  int v17 = 0;
  uint64_t v6 = sub_10071814C(a1, a4, a2, a3, (uint64_t)&v17);
  if (v6)
  {
    uint64_t v7 = qword_100A19E80;
    if (os_log_type_enabled((os_log_t)qword_100A19E80, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)long long buf = 67109120;
      int v19 = v6;
      unsigned int v8 = "decryptAEM failed with result %d";
      __int16 v9 = v7;
      uint32_t v10 = 8;
LABEL_6:
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_INFO, v8, buf, v10);
    }
  }
  else
  {
    ENRPIMetadataDeserialize();
    uint64_t v11 = qword_100A19E80;
    if (os_log_type_enabled((os_log_t)qword_100A19E80, OS_LOG_TYPE_INFO))
    {
      int v12 = *a5;
      int v13 = a5[1];
      int v14 = (char)a5[2];
      int v15 = a5[3];
      *(_DWORD *)long long buf = 67109888;
      int v19 = v12;
      __int16 v20 = 1024;
      int v21 = v13;
      __int16 v22 = 1024;
      int v23 = v14;
      __int16 v24 = 1024;
      int v25 = v15;
      unsigned int v8 = "decryptAEM majorVersion:%d minorVersion:%d txPower:%d calibrationConfidence:%d";
      __int16 v9 = v11;
      uint32_t v10 = 26;
      goto LABEL_6;
    }
  }
  return v6;
}

uint64_t sub_10071814C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t result = 3;
  if (a2 && a3 && a4)
  {
    if (a5)
    {
      ENAEMKDerive();
      ENAEMCrypt();
      return 0;
    }
  }
  return result;
}

uint64_t sub_1007181F0(uint64_t a1, int a2)
{
  uint64_t result = 3;
  if ((a2 - 1) <= 0x8F && *(_DWORD *)(a1 + 32) != a2)
  {
    sub_100717160(a1);
    *(_DWORD *)(a1 + 32) = a2;
    uint64_t v5 = sub_100017768();
    if ((*(unsigned int (**)(uint64_t))(*(void *)v5 + 184))(v5))
    {
      uint64_t v6 = qword_100A19F98;
      if (os_log_type_enabled((os_log_t)qword_100A19F98, OS_LOG_TYPE_DEFAULT))
      {
        int v7 = *(_DWORD *)(a1 + 32);
        v8[0] = 67109120;
        v8[1] = v7;
        _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "setEKRollingPeriod new EKRollingPeriod set to %d", (uint8_t *)v8, 8u);
      }
    }
    sub_100313540(0xBu, (const UInt8 *)(a1 + 32), 4u);
    if (qword_1009FB798 != -1) {
      dispatch_once(&qword_1009FB798, &stru_1009BFDE8);
    }
    sub_10044B980((uint64_t)off_1009FB790);
    return 0;
  }
  return result;
}

uint64_t sub_100718344(uint64_t a1, _OWORD *a2, int a3, void *a4)
{
  if (a2 && a3 == 16)
  {
    __chkstk_darwin();
    long long v8 = 0uLL;
    uint64_t v9 = 0;
    unsigned int v10 = 0;
    int v6 = sub_100313364(12, (UInt8 *)&v8, 24, &v10);
    uint64_t result = 1;
    if (!v6 && v10 == 24)
    {
      uint64_t result = 0;
      *a2 = v8;
      *a4 = v9;
    }
  }
  else
  {
    if (os_log_type_enabled((os_log_t)qword_100A19F90, OS_LOG_TYPE_ERROR)) {
      sub_100798BEC();
    }
    return 3;
  }
  return result;
}

BOOL sub_10071845C(uint64_t a1, uint64_t a2, int a3)
{
  if (a2 && a3 == 16)
  {
    __chkstk_darwin();
    long long v6 = *v3;
    uint64_t v7 = v4;
    return sub_100313540(0xCu, (const UInt8 *)&v6, 0x18u) != 0;
  }
  else
  {
    if (os_log_type_enabled((os_log_t)qword_100A19F90, OS_LOG_TYPE_ERROR)) {
      sub_100798C54();
    }
    return 1;
  }
}

id sub_10071853C(uint64_t a1, int a2)
{
  if (a2 == 1)
  {
    id v3 = objc_opt_new();
    if (v3)
    {
      uint64_t v4 = +[NSNumber numberWithUnsignedInt:1];
      [v3 setObject:v4 forKeyedSubscript:@"instance"];

      uint64_t v5 = +[NSData dataWithBytes:a1 + 224 length:16];
      [v3 setObject:v5 forKeyedSubscript:@"identity"];

      long long v6 = +[NSNumber numberWithUnsignedLongLong:*(void *)(a1 + 240)];
      [v3 setObject:v6 forKeyedSubscript:@"address"];
    }
  }
  else
  {
    id v3 = 0;
  }

  return v3;
}

void sub_10071862C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100718650(uint64_t a1, const unsigned __int8 **a2)
{
  unsigned int v2 = a2 + 1;
  id v3 = *a2;
  if (*a2 != (const unsigned __int8 *)(a2 + 1))
  {
    do
    {
      uint64_t v4 = (atomic_uint *)*((void *)v3 + 7);
      uint64_t v11 = &off_1009B4578;
      int v12 = v4;
      if (v4) {
        sub_100037354((uint64_t)v4);
      }
      memset(dst, 0, sizeof(dst));
      uuid_copy(dst, v3 + 32);
      uint64_t v5 = v12;
      uint64_t v9 = &off_1009B4578;
      unsigned int v10 = v12;
      if (v12) {
        sub_100037354((uint64_t)v12);
      }
      sub_1007187D0((uint64_t)v5, dst, (uint64_t)&v9);
      uint64_t v9 = &off_1009B4578;
      if (v10) {
        sub_1000368F4(v10);
      }
      uint64_t v11 = &off_1009B4578;
      if (v12) {
        sub_1000368F4(v12);
      }
      long long v6 = (unsigned __int8 *)*((void *)v3 + 1);
      if (v6)
      {
        do
        {
          uint64_t v7 = (const unsigned __int8 **)v6;
          long long v6 = *(unsigned __int8 **)v6;
        }
        while (v6);
      }
      else
      {
        do
        {
          uint64_t v7 = (const unsigned __int8 **)*((void *)v3 + 2);
          BOOL v8 = *v7 == v3;
          id v3 = (const unsigned __int8 *)v7;
        }
        while (!v8);
      }
      id v3 = (const unsigned __int8 *)v7;
    }
    while (v7 != v2);
  }
}

void sub_100718794(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13)
{
}

void sub_1007187D0(uint64_t a1, const unsigned __int8 *a2, uint64_t a3)
{
  uint64_t v5 = qword_100A19E80;
  if (os_log_type_enabled((os_log_t)qword_100A19E80, OS_LOG_TYPE_DEFAULT))
  {
    memset(out, 0, sizeof(out));
    uuid_unparse_upper(a2, out);
    sub_10004191C(&__p, out);
    if (v23 >= 0) {
      p_p = &__p;
    }
    else {
      p_p = __p;
    }
    *(_DWORD *)uuid_string_t out = 136446210;
    *(void *)&out[4] = p_p;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "statedump:    %{public}s", (uint8_t *)out, 0xCu);
    if (v23 < 0) {
      operator delete(__p);
    }
    uint64_t v5 = qword_100A19E80;
  }
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    sub_1003BC0D4(*(void *)(a3 + 8), 0, &__p);
    sub_10004C2C4((uint64_t)&__p, out);
    if (out[23] >= 0) {
      uint64_t v7 = out;
    }
    else {
      uint64_t v7 = *(char **)out;
    }
    *(_DWORD *)long long buf = 136315138;
    int v25 = v7;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "statedump:       Remote LTK:     %s", buf, 0xCu);
    if (out[23] < 0) {
      operator delete(*(void **)out);
    }
    std::string __p = &off_100998428;
    if (v22) {
      sub_1000368F4(v22);
    }
    uint64_t v5 = qword_100A19E80;
  }
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    sub_1003BC0D4(*(void *)(a3 + 8), 1, &__p);
    sub_10004C2C4((uint64_t)&__p, out);
    if (out[23] >= 0) {
      BOOL v8 = out;
    }
    else {
      BOOL v8 = *(char **)out;
    }
    *(_DWORD *)long long buf = 136315138;
    int v25 = v8;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "statedump:       Remote LTK len: %s", buf, 0xCu);
    if (out[23] < 0) {
      operator delete(*(void **)out);
    }
    std::string __p = &off_100998428;
    if (v22) {
      sub_1000368F4(v22);
    }
    uint64_t v5 = qword_100A19E80;
  }
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    sub_1003BC0D4(*(void *)(a3 + 8), 3, &__p);
    sub_10004C2C4((uint64_t)&__p, out);
    if (out[23] >= 0) {
      uint64_t v9 = out;
    }
    else {
      uint64_t v9 = *(char **)out;
    }
    *(_DWORD *)long long buf = 136315138;
    int v25 = v9;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "statedump:       Remote EDIV:    %s", buf, 0xCu);
    if (out[23] < 0) {
      operator delete(*(void **)out);
    }
    std::string __p = &off_100998428;
    if (v22) {
      sub_1000368F4(v22);
    }
    uint64_t v5 = qword_100A19E80;
  }
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    sub_1003BC0D4(*(void *)(a3 + 8), 4, &__p);
    sub_10004C2C4((uint64_t)&__p, out);
    if (out[23] >= 0) {
      unsigned int v10 = out;
    }
    else {
      unsigned int v10 = *(char **)out;
    }
    *(_DWORD *)long long buf = 136315138;
    int v25 = v10;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "statedump:       Remote Rand:    %s", buf, 0xCu);
    if (out[23] < 0) {
      operator delete(*(void **)out);
    }
    std::string __p = &off_100998428;
    if (v22) {
      sub_1000368F4(v22);
    }
    uint64_t v5 = qword_100A19E80;
  }
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    sub_1003BC0D4(*(void *)(a3 + 8), 12, &__p);
    sub_10004C2C4((uint64_t)&__p, out);
    if (out[23] >= 0) {
      uint64_t v11 = out;
    }
    else {
      uint64_t v11 = *(char **)out;
    }
    *(_DWORD *)long long buf = 136315138;
    int v25 = v11;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "statedump:       Remote CSRK:    %s", buf, 0xCu);
    if (out[23] < 0) {
      operator delete(*(void **)out);
    }
    std::string __p = &off_100998428;
    if (v22) {
      sub_1000368F4(v22);
    }
    uint64_t v5 = qword_100A19E80;
  }
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    sub_1003BC0D4(*(void *)(a3 + 8), 10, &__p);
    sub_10004C2C4((uint64_t)&__p, out);
    if (out[23] >= 0) {
      int v12 = out;
    }
    else {
      int v12 = *(char **)out;
    }
    *(_DWORD *)long long buf = 136315138;
    int v25 = v12;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "statedump:       Remote IRK:     %s", buf, 0xCu);
    if (out[23] < 0) {
      operator delete(*(void **)out);
    }
    std::string __p = &off_100998428;
    if (v22) {
      sub_1000368F4(v22);
    }
    uint64_t v5 = qword_100A19E80;
  }
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    sub_1003BC0D4(*(void *)(a3 + 8), 11, &__p);
    sub_10004C2C4((uint64_t)&__p, out);
    if (out[23] >= 0) {
      int v13 = out;
    }
    else {
      int v13 = *(char **)out;
    }
    *(_DWORD *)long long buf = 136446210;
    int v25 = v13;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "statedump:       Remote Address: %{public}s", buf, 0xCu);
    if (out[23] < 0) {
      operator delete(*(void **)out);
    }
    std::string __p = &off_100998428;
    if (v22) {
      sub_1000368F4(v22);
    }
    uint64_t v5 = qword_100A19E80;
  }
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    sub_1003BC0D4(*(void *)(a3 + 8), 6, &__p);
    sub_10004C2C4((uint64_t)&__p, out);
    if (out[23] >= 0) {
      int v14 = out;
    }
    else {
      int v14 = *(char **)out;
    }
    *(_DWORD *)long long buf = 136315138;
    int v25 = v14;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "statedump:       Local LTK len:  %s", buf, 0xCu);
    if (out[23] < 0) {
      operator delete(*(void **)out);
    }
    std::string __p = &off_100998428;
    if (v22) {
      sub_1000368F4(v22);
    }
    uint64_t v5 = qword_100A19E80;
  }
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    sub_1003BC0D4(*(void *)(a3 + 8), 5, &__p);
    sub_10004C2C4((uint64_t)&__p, out);
    if (out[23] >= 0) {
      int v15 = out;
    }
    else {
      int v15 = *(char **)out;
    }
    *(_DWORD *)long long buf = 136315138;
    int v25 = v15;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "statedump:       Local LTK:      %s", buf, 0xCu);
    if (out[23] < 0) {
      operator delete(*(void **)out);
    }
    std::string __p = &off_100998428;
    if (v22) {
      sub_1000368F4(v22);
    }
    uint64_t v5 = qword_100A19E80;
  }
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    sub_1003BC0D4(*(void *)(a3 + 8), 7, &__p);
    sub_10004C2C4((uint64_t)&__p, out);
    if (out[23] >= 0) {
      __int16 v16 = out;
    }
    else {
      __int16 v16 = *(char **)out;
    }
    *(_DWORD *)long long buf = 136315138;
    int v25 = v16;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "statedump:       Local LTK type: %s", buf, 0xCu);
    if (out[23] < 0) {
      operator delete(*(void **)out);
    }
    std::string __p = &off_100998428;
    if (v22) {
      sub_1000368F4(v22);
    }
    uint64_t v5 = qword_100A19E80;
  }
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    sub_1003BC0D4(*(void *)(a3 + 8), 8, &__p);
    sub_10004C2C4((uint64_t)&__p, out);
    if (out[23] >= 0) {
      int v17 = out;
    }
    else {
      int v17 = *(char **)out;
    }
    *(_DWORD *)long long buf = 136315138;
    int v25 = v17;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "statedump:       Local EDIV:     %s", buf, 0xCu);
    if (out[23] < 0) {
      operator delete(*(void **)out);
    }
    std::string __p = &off_100998428;
    if (v22) {
      sub_1000368F4(v22);
    }
    uint64_t v5 = qword_100A19E80;
  }
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    sub_1003BC0D4(*(void *)(a3 + 8), 9, &__p);
    sub_10004C2C4((uint64_t)&__p, out);
    if (out[23] >= 0) {
      __int16 v18 = out;
    }
    else {
      __int16 v18 = *(char **)out;
    }
    *(_DWORD *)long long buf = 136315138;
    int v25 = v18;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "statedump:       Local Rand:     %s", buf, 0xCu);
    if (out[23] < 0) {
      operator delete(*(void **)out);
    }
    std::string __p = &off_100998428;
    if (v22) {
      sub_1000368F4(v22);
    }
    uint64_t v5 = qword_100A19E80;
  }
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    sub_1003BC0D4(*(void *)(a3 + 8), 13, &__p);
    sub_10004C2C4((uint64_t)&__p, out);
    if (out[23] >= 0) {
      int v19 = out;
    }
    else {
      int v19 = *(char **)out;
    }
    *(_DWORD *)long long buf = 136315138;
    int v25 = v19;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "statedump:       Local CSRK:     %s", buf, 0xCu);
    if (out[23] < 0) {
      operator delete(*(void **)out);
    }
    std::string __p = &off_100998428;
    if (v22) {
      sub_1000368F4(v22);
    }
    uint64_t v5 = qword_100A19E80;
  }
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    sub_1003BC0D4(*(void *)(a3 + 8), 16, &__p);
    sub_10004C2C4((uint64_t)&__p, out);
    if (out[23] >= 0) {
      __int16 v20 = out;
    }
    else {
      __int16 v20 = *(char **)out;
    }
    *(_DWORD *)long long buf = 136315138;
    int v25 = v20;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "statedump:       deriveLKLTK:    %s", buf, 0xCu);
    if (out[23] < 0) {
      operator delete(*(void **)out);
    }
    std::string __p = &off_100998428;
    if (v22) {
      sub_1000368F4(v22);
    }
  }
}

void sub_1007192E0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, atomic_uint *a11)
{
  if (a11) {
    sub_1000368F4(a11);
  }
  _Unwind_Resume(exception_object);
}

void sub_10071936C(uint64_t a1)
{
  unsigned int v2 = qword_100A19E80;
  if (os_log_type_enabled((os_log_t)qword_100A19E80, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "statedump: ---------------- LE Security Manager ----------------", buf, 2u);
  }
  uint64_t v3 = sub_100017768();
  int v4 = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 8))(v3);
  uint64_t v5 = qword_100A19E80;
  if (v4)
  {
    if (os_log_type_enabled((os_log_t)qword_100A19E80, OS_LOG_TYPE_DEFAULT))
    {
      sub_10004BDF8();
      if (v42 >= 0) {
        long long v6 = __p;
      }
      else {
        long long v6 = *(unsigned char **)__p;
      }
      *(_DWORD *)long long buf = 141560323;
      *(void *)&uint8_t buf[4] = 1752392040;
      *(_WORD *)&unsigned char buf[12] = 1041;
      *(_DWORD *)&buf[14] = 16;
      *(_WORD *)&unsigned char buf[18] = 2097;
      *(void *)&buf[20] = a1 + 184;
      *(_WORD *)&buf[28] = 1041;
      *(_DWORD *)&buf[30] = 16;
      *(_WORD *)&buf[34] = 2097;
      *(void *)&buf[36] = a1 + 200;
      *(_WORD *)&buf[44] = 1041;
      *(_DWORD *)&buf[46] = 16;
      __int16 v44 = 2097;
      uint64_t v45 = a1 + 136;
      __int16 v46 = 1041;
      int v47 = 16;
      __int16 v48 = 2097;
      uint64_t v49 = a1 + 168;
      __int16 v50 = 2081;
      __int16 v51 = v6;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "statedump: IRK=%{private, mask.hash}.16P DHK=%{private}.16P IR=%{private}.16P ER=%{private}.16P fLocalStaticRandomAddress:%{private}s", buf, 0x56u);
      if (v42 < 0) {
        operator delete(*(void **)__p);
      }
      uint64_t v5 = qword_100A19E80;
    }
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 68224515;
      *(_DWORD *)&uint8_t buf[4] = 96;
      *(_WORD *)&uint8_t buf[8] = 2097;
      *(void *)&buf[10] = a1 + 312;
      *(_WORD *)&unsigned char buf[18] = 1041;
      *(_DWORD *)&buf[20] = 64;
      *(_WORD *)&uint8_t buf[24] = 2097;
      *(void *)&buf[26] = a1 + 248;
      *(_WORD *)&buf[34] = 1041;
      *(_DWORD *)&buf[36] = 16;
      *(_WORD *)&uint8_t buf[40] = 2097;
      *(void *)&buf[42] = a1 + 408;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "statedump: CloudPrivate=%{private}.96P CloudPublic=%{private}.64P CloudNonce=%{private}.16P", buf, 0x32u);
      uint64_t v5 = qword_100A19E80;
    }
  }
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v7 = *(void *)(a1 + 456);
    int v8 = *(unsigned __int16 *)(a1 + 3736);
    *(_DWORD *)long long buf = 134218240;
    *(void *)&uint8_t buf[4] = v7;
    *(_WORD *)&unsigned char buf[12] = 1024;
    *(_DWORD *)&buf[14] = v8;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "statedump: Paired LE devices: %lu/%d", buf, 0x12u);
  }
  uint64_t v9 = sub_100017768();
  if ((*(unsigned int (**)(uint64_t))(*(void *)v9 + 184))(v9))
  {
    unsigned int v10 = qword_100A19F98;
    if (os_log_type_enabled((os_log_t)qword_100A19F98, OS_LOG_TYPE_DEFAULT))
    {
      int v11 = *(_DWORD *)(a1 + 32);
      int v12 = *(_DWORD *)(a1 + 36);
      *(_DWORD *)long long buf = 67109376;
      *(_DWORD *)&uint8_t buf[4] = v11;
      *(_WORD *)&uint8_t buf[8] = 1024;
      *(_DWORD *)&buf[10] = v12;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "statedump: fEKRollingPeriod:%d fENIntervalNumber:%d", buf, 0xEu);
    }
  }
  uint64_t v13 = sub_100017768();
  if ((*(unsigned int (**)(uint64_t))(*(void *)v13 + 184))(v13))
  {
    int v14 = qword_100A19F98;
    if (os_log_type_enabled((os_log_t)qword_100A19F98, OS_LOG_TYPE_DEFAULT))
    {
      id v15 = [*(id *)(a1 + 24) count];
      uint64_t v16 = *(void *)(a1 + 24);
      *(_DWORD *)long long buf = 134218242;
      *(void *)&uint8_t buf[4] = v15;
      *(_WORD *)&unsigned char buf[12] = 2112;
      *(void *)&buf[14] = v16;
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "statedump: fTEKArraySize:%zu fTEKArray:%@", buf, 0x16u);
    }
  }
  int v17 = qword_100A19E80;
  if (os_log_type_enabled((os_log_t)qword_100A19E80, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "statedump: Out-of-band devices:", buf, 2u);
  }
  __int16 v18 = *(void **)(a1 + 536);
  uint64_t v39 = a1;
  unsigned int v40 = (void *)(a1 + 544);
  if (v18 != (void *)(a1 + 544))
  {
    do
    {
      int v19 = qword_100A19E80;
      if (os_log_type_enabled((os_log_t)qword_100A19E80, OS_LOG_TYPE_DEFAULT))
      {
        sub_10003AE4C(v18[4], (uint64_t)buf);
        __int16 v20 = buf;
        if (buf[23] < 0) {
          __int16 v20 = *(unsigned char **)buf;
        }
        *(_DWORD *)std::string __p = 136446210;
        *(void *)&__p[4] = v20;
        _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "statedump:   %{public}s", __p, 0xCu);
        if ((buf[23] & 0x80000000) != 0) {
          operator delete(*(void **)buf);
        }
      }
      int v21 = (const unsigned __int8 *)v18[5];
      if (v21 != (const unsigned __int8 *)(v18 + 6))
      {
        __int16 v22 = qword_100A19E80;
        do
        {
          if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
          {
            memset(buf, 0, 37);
            uuid_unparse_upper(v21 + 32, buf);
            sub_10004191C(__p, buf);
            char v23 = __p;
            if (v42 < 0) {
              char v23 = *(unsigned char **)__p;
            }
            *(_DWORD *)long long buf = 136446210;
            *(void *)&uint8_t buf[4] = v23;
            _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "statedump:      %{public}s", buf, 0xCu);
            if (v42 < 0) {
              operator delete(*(void **)__p);
            }
            __int16 v22 = qword_100A19E80;
          }
          if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
          {
            if (v21[56]) {
              __int16 v24 = "Yes";
            }
            else {
              __int16 v24 = "No";
            }
            *(_DWORD *)long long buf = 136446210;
            *(void *)&uint8_t buf[4] = v24;
            _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "statedump:         Enabled: %{public}s", buf, 0xCu);
            __int16 v22 = qword_100A19E80;
          }
          int v25 = (unsigned __int8 *)*((void *)v21 + 1);
          if (v25)
          {
            do
            {
              id v26 = (const unsigned __int8 **)v25;
              int v25 = *(unsigned __int8 **)v25;
            }
            while (v25);
          }
          else
          {
            do
            {
              id v26 = (const unsigned __int8 **)*((void *)v21 + 2);
              BOOL v27 = *v26 == v21;
              int v21 = (const unsigned __int8 *)v26;
            }
            while (!v27);
          }
          int v21 = (const unsigned __int8 *)v26;
        }
        while (v26 != v18 + 6);
      }
      char v28 = (void *)v18[1];
      if (v28)
      {
        do
        {
          uint64_t v29 = v28;
          char v28 = (void *)*v28;
        }
        while (v28);
      }
      else
      {
        do
        {
          uint64_t v29 = (void *)v18[2];
          BOOL v27 = *v29 == (void)v18;
          __int16 v18 = v29;
        }
        while (!v27);
      }
      __int16 v18 = v29;
    }
    while (v29 != v40);
  }
  char v30 = qword_100A19E80;
  if (os_log_type_enabled((os_log_t)qword_100A19E80, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_DEFAULT, "statedump: In-progress keys:", buf, 2u);
  }
  sub_100718650(v39, (const unsigned __int8 **)(v39 + 464));
  long long v31 = qword_100A19E80;
  if (os_log_type_enabled((os_log_t)qword_100A19E80, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_DEFAULT, "statedump: Temporary Security keys:", buf, 2u);
  }
  sub_100718650(v39, (const unsigned __int8 **)(v39 + 488));
  long long v32 = qword_100A19E80;
  if (os_log_type_enabled((os_log_t)qword_100A19E80, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_DEFAULT, "statedump: Temporary IRKs:", buf, 2u);
  }
  sub_100718650(v39, (const unsigned __int8 **)(v39 + 512));
  long long v33 = qword_100A19E80;
  if (os_log_type_enabled((os_log_t)qword_100A19E80, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_DEFAULT, "statedump: All IRKs:", buf, 2u);
    long long v33 = qword_100A19E80;
  }
  for (uint64_t i = 620; i != 3740; i += 24)
  {
    if (os_log_type_enabled(v33, OS_LOG_TYPE_DEFAULT))
    {
      int v35 = *(unsigned __int8 *)(v39 + i);
      *(_DWORD *)long long buf = 68158723;
      *(_DWORD *)&uint8_t buf[4] = 7;
      *(_WORD *)&uint8_t buf[8] = 2096;
      *(void *)&buf[10] = v39 + i - 7;
      *(_WORD *)&unsigned char buf[18] = 1041;
      *(_DWORD *)&buf[20] = 16;
      *(_WORD *)&uint8_t buf[24] = 2097;
      *(void *)&buf[26] = v39 + i - 23;
      *(_WORD *)&buf[34] = 1024;
      *(_DWORD *)&buf[36] = v35;
      _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_DEFAULT, "statedump: Device %{bluetooth:BD_ADDR}.7P with IRK %{private}.16P used:%d", buf, 0x28u);
      long long v33 = qword_100A19E80;
    }
  }
  if (os_log_type_enabled(v33, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_DEFAULT, "statedump: Security keys:", buf, 2u);
  }
  sub_100718650(v39, (const unsigned __int8 **)(v39 + 440));
  id v36 = qword_100A19E80;
  if (os_log_type_enabled((os_log_t)qword_100A19E80, OS_LOG_TYPE_DEFAULT))
  {
    __int16 v37 = sub_1006AD3F0();
    *(_DWORD *)long long buf = 138543362;
    *(void *)&uint8_t buf[4] = v37;
    _os_log_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_DEFAULT, "statedump: Current user's RSA: %{public}@", buf, 0xCu);
  }
  if (*(unsigned char *)(v39 + 424))
  {
    uint64_t v38 = *(void *)(v39 + 432);
    if (v38) {
      (*(void (**)(uint64_t))(*(void *)v38 + 8))(v38);
    }
  }
}

uint64_t sub_100719C30(uint64_t a1, uint64_t a2, unsigned __int8 *src, uint64_t a4)
{
  *(_WORD *)(a1 + 8) = 1;
  *(void *)a1 = off_1009BFC18;
  *(void *)(a1 + 16) = a2;
  uuid_copy((unsigned __int8 *)(a1 + 24), src);
  uint64_t v6 = *(void *)(a4 + 8);
  *(void *)(a1 + 40) = &off_1009B4578;
  *(void *)(a1 + 48) = v6;
  if (v6) {
    sub_100037354(v6);
  }
  return a1;
}

void *sub_100719CB8(void *a1)
{
  *a1 = off_1009BFC18;
  a1[5] = &off_1009B4578;
  unsigned int v2 = (atomic_uint *)a1[6];
  if (v2) {
    sub_1000368F4(v2);
  }
  return a1;
}

void sub_100719D24(void *a1)
{
  *a1 = off_1009BFC18;
  a1[5] = &off_1009B4578;
  uint64_t v1 = (atomic_uint *)a1[6];
  if (v1) {
    sub_1000368F4(v1);
  }

  operator delete();
}

void sub_100719DB0(uint64_t a1)
{
  if (qword_1009F7ED0 != -1) {
    dispatch_once(&qword_1009F7ED0, &stru_1009BFD08);
  }
  uint64_t v2 = qword_1009F7EC8;
  uint64_t v3 = *(void *)(a1 + 16);
  sub_100031234((const unsigned __int8 *)(a1 + 24));
  id v4 = (id)objc_claimAutoreleasedReturnValue();
  sub_10070EDE4(v2, v3, v4, a1 + 40);
}

void sub_100719E4C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_100719E60()
{
}

void sub_100719F2C(unsigned __int8 *a1)
{
  unint64_t v1 = ((unint64_t)a1[1] << 40) | ((unint64_t)a1[2] << 32) | ((unint64_t)a1[3] << 24) | ((unint64_t)a1[4] << 16) | ((unint64_t)a1[5] << 8) | a1[6] | ((unint64_t)*a1 << 48);
  uint64_t v2 = sub_100019878();
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 3221225472;
  v3[2] = sub_10071A1A4;
  v3[3] = &unk_100997528;
  v3[4] = v1;
  sub_100013018(v2, v3);
}

void sub_100719FDC(unsigned __int8 *a1, int a2, const void *a3, size_t size)
{
  unsigned int v4 = size;
  uint64_t v6 = a1[1];
  uint64_t v7 = a1[2];
  uint64_t v8 = a1[3];
  uint64_t v9 = a1[4];
  uint64_t v10 = a1[5];
  uint64_t v11 = a1[6];
  uint64_t v12 = *a1;
  if (size >= 0x11 && os_log_type_enabled((os_log_t)qword_100A19E80, OS_LOG_TYPE_FAULT)) {
    sub_100798CBC();
  }
  uint64_t v13 = (v6 << 40) | (v7 << 32) | (v8 << 24) | (v9 << 16) | (v10 << 8) | v11 | (v12 << 48);
  int v14 = malloc_type_malloc(v4, 0x6C8E4376uLL);
  memcpy(v14, a3, v4);
  uint64_t v15 = sub_100019878();
  v17[0] = _NSConcreteStackBlock;
  v17[1] = 3221225472;
  void v17[2] = sub_10071A208;
  v17[3] = &unk_1009A28D8;
  int v18 = a2;
  void v17[4] = v13;
  v17[5] = v14;
  char v19 = v4;
  sub_100013018(v15, v17);
}

void sub_10071A124()
{
}

uint64_t sub_10071A138(uint64_t a1)
{
  if (qword_1009F7ED0 != -1) {
    dispatch_once(&qword_1009F7ED0, &stru_1009BFD08);
  }
  uint64_t v2 = qword_1009F7EC8;
  unint64_t v3 = *(void *)(a1 + 16);
  int v4 = *(unsigned __int16 *)(a1 + 32);

  return sub_100710398(v2, v3, (uint64_t *)(a1 + 24), v4);
}

unsigned char *sub_10071A1A4(uint64_t a1)
{
  if (qword_1009F7ED0 != -1) {
    dispatch_once(&qword_1009F7ED0, &stru_1009BFD08);
  }
  uint64_t v2 = qword_1009F7EC8;
  unint64_t v3 = *(void *)(a1 + 32);

  return sub_1007108E4(v2, v3);
}

void sub_10071A208(uint64_t a1)
{
  if (qword_1009F7ED0 != -1) {
    dispatch_once(&qword_1009F7ED0, &stru_1009BFD08);
  }
  sub_100710BB0(qword_1009F7EC8, *(void *)(a1 + 32), *(_DWORD *)(a1 + 48), *(unsigned __int8 **)(a1 + 40), *(unsigned __int8 *)(a1 + 52), 0);
  uint64_t v2 = *(void **)(a1 + 40);

  free(v2);
}

void sub_10071A280(unsigned __int8 *a1, char a2)
{
  unint64_t v3 = ((unint64_t)a1[1] << 40) | ((unint64_t)a1[2] << 32) | ((unint64_t)a1[3] << 24) | ((unint64_t)a1[4] << 16) | ((unint64_t)a1[5] << 8) | a1[6] | ((unint64_t)*a1 << 48);
  uint64_t v4 = sub_100019878();
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 3221225472;
  void v5[2] = sub_10071A4C8;
  v5[3] = &unk_100998A58;
  v5[4] = v3;
  char v6 = a2;
  sub_100013018(v4, v5);
}

void sub_10071A338(unsigned __int8 *a1)
{
  unint64_t v1 = ((unint64_t)a1[1] << 40) | ((unint64_t)a1[2] << 32) | ((unint64_t)a1[3] << 24) | ((unint64_t)a1[4] << 16) | ((unint64_t)a1[5] << 8) | a1[6] | ((unint64_t)*a1 << 48);
  uint64_t v2 = sub_100019878();
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 3221225472;
  v3[2] = sub_10071A530;
  v3[3] = &unk_100997528;
  v3[4] = v1;
  sub_100013018(v2, v3);
}

void sub_10071A3E8(unsigned __int8 *a1, int a2, _OWORD *a3)
{
  unint64_t v5 = ((unint64_t)a1[1] << 40) | ((unint64_t)a1[2] << 32) | ((unint64_t)a1[3] << 24) | ((unint64_t)a1[4] << 16) | ((unint64_t)a1[5] << 8) | a1[6] | ((unint64_t)*a1 << 48);
  char v6 = malloc_type_malloc(0x10uLL, 0xEE12D0D2uLL);
  *char v6 = *a3;
  uint64_t v7 = sub_100019878();
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 3221225472;
  _DWORD v8[2] = sub_10071A594;
  v8[3] = &unk_100998280;
  int v9 = a2;
  void v8[4] = v5;
  v8[5] = v6;
  sub_100013018(v7, v8);
}

void sub_10071A4C8(uint64_t a1)
{
  if (qword_1009F7ED0 != -1) {
    dispatch_once(&qword_1009F7ED0, &stru_1009BFD08);
  }
  uint64_t v2 = qword_1009F7EC8;
  unint64_t v3 = *(void *)(a1 + 32);
  int v4 = *(unsigned __int8 *)(a1 + 40);

  sub_10071180C(v2, v3, v4);
}

void sub_10071A530(uint64_t a1)
{
  if (qword_1009F7ED0 != -1) {
    dispatch_once(&qword_1009F7ED0, &stru_1009BFD08);
  }
  uint64_t v2 = qword_1009F7EC8;
  unint64_t v3 = *(void *)(a1 + 32);

  sub_100711DC4(v2, v3);
}

void sub_10071A594(uint64_t a1)
{
  if (qword_1009F7ED0 != -1) {
    dispatch_once(&qword_1009F7ED0, &stru_1009BFD08);
  }
  sub_10071221C(qword_1009F7EC8, *(void *)(a1 + 32), *(unsigned int *)(a1 + 48), *(unsigned int **)(a1 + 40));
  uint64_t v2 = *(void **)(a1 + 40);

  free(v2);
}

void sub_10071A604(uint64_t a1, int a2, char a3)
{
  *(_DWORD *)&v17[3] = 0;
  *(_DWORD *)int v17 = 0;
  sub_100225E94(a1, (uint64_t)v17, 0);
  unint64_t v6 = ((unint64_t)v17[1] << 40) | ((unint64_t)v17[2] << 32) | ((unint64_t)v17[3] << 24) | ((unint64_t)v17[4] << 16) | ((unint64_t)v17[5] << 8) | v17[6] | ((unint64_t)v17[0] << 48);
  int v7 = sub_100237AD0(v17);
  uint64_t v8 = qword_100A19E80;
  if (os_log_type_enabled((os_log_t)qword_100A19E80, OS_LOG_TYPE_DEFAULT))
  {
    sub_10004BDF8();
    if (v16 >= 0) {
      p_p = &__p;
    }
    else {
      p_p = __p;
    }
    *(_DWORD *)long long buf = 134218754;
    uint64_t v19 = a1;
    __int16 v20 = 1024;
    int v21 = a2;
    __int16 v22 = 2082;
    char v23 = p_p;
    __int16 v24 = 1024;
    int v25 = v7;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "encryptionStatusChangedCb handle:%p status=%{bluetooth:OI_STATUS}u address=%{public}s isPairing=%d", buf, 0x22u);
    if (v16 < 0) {
      operator delete(__p);
    }
  }
  uint64_t v10 = sub_100019878();
  v11[0] = _NSConcreteStackBlock;
  v11[1] = 3221225472;
  void v11[2] = sub_10071AA18;
  v11[3] = &unk_1009AD2E0;
  v11[4] = v6;
  int v12 = a2;
  char v13 = a3;
  char v14 = v7;
  sub_100013018(v10, v11);
}

void sub_10071A7D0(unsigned __int8 *a1, unsigned __int8 *a2, int a3)
{
  if (a2) {
    unint64_t v6 = ((unint64_t)a2[1] << 40) | ((unint64_t)a2[2] << 32) | ((unint64_t)a2[3] << 24) | ((unint64_t)a2[4] << 16) | ((unint64_t)a2[5] << 8) | a2[6] | ((unint64_t)*a2 << 48);
  }
  else {
    unint64_t v6 = 0;
  }
  unint64_t v7 = ((unint64_t)a1[1] << 40) | ((unint64_t)a1[2] << 32) | ((unint64_t)a1[3] << 24) | ((unint64_t)a1[4] << 16) | ((unint64_t)a1[5] << 8) | a1[6] | ((unint64_t)*a1 << 48);
  uint64_t v8 = qword_100A19E80;
  if (os_log_type_enabled((os_log_t)qword_100A19E80, OS_LOG_TYPE_DEFAULT))
  {
    sub_10004BDF8();
    sub_10004BDF8();
    int v9 = &v16;
    if (v17 < 0) {
      int v9 = v16;
    }
    if (v15 >= 0) {
      p_p = &__p;
    }
    else {
      p_p = __p;
    }
    *(_DWORD *)long long buf = 136446722;
    uint64_t v19 = v9;
    __int16 v20 = 2082;
    int v21 = p_p;
    __int16 v22 = 1024;
    int v23 = a3;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "smpPairingCompleted address=%{public}s resolvedAddress:%{public}s status=%{bluetooth:OI_STATUS}u", buf, 0x1Cu);
    if (v15 < 0) {
      operator delete(__p);
    }
    if (v17 < 0) {
      operator delete(v16);
    }
  }
  sub_1002404D4(255);
  uint64_t v11 = sub_100019878();
  v12[0] = _NSConcreteStackBlock;
  v12[1] = 3221225472;
  v12[2] = sub_10071AA90;
  v12[3] = &unk_1009BFC78;
  v12[4] = v7;
  v12[5] = v6;
  int v13 = a3;
  v12[6] = a2;
  v12[7] = a1;
  sub_100013018(v11, v12);
}

void sub_10071A9F4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_10071AA18(uint64_t a1)
{
  if (qword_1009F7ED0 != -1) {
    dispatch_once(&qword_1009F7ED0, &stru_1009BFD08);
  }
  uint64_t v2 = qword_1009F7EC8;
  unint64_t v3 = *(void *)(a1 + 32);
  unsigned int v4 = *(_DWORD *)(a1 + 40);
  BOOL v5 = *(unsigned char *)(a1 + 44) != 0;
  char v6 = *(unsigned char *)(a1 + 45);

  sub_10070FDC4(v2, v3, v4, v5, v6);
}

void sub_10071AA90(uint64_t a1)
{
  if (qword_1009F7ED0 != -1) {
    dispatch_once(&qword_1009F7ED0, &stru_1009BFD08);
  }
  uint64_t v2 = qword_1009F7EC8;
  unint64_t v3 = *(void *)(a1 + 32);
  unint64_t v4 = *(void *)(a1 + 40);
  int v5 = *(_DWORD *)(a1 + 64);
  sub_10004191C(&__p, "");
  sub_10070A4A0(v2, v3, v4, v5, &__p);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  if (!*(_DWORD *)(a1 + 64) && (*(void *)(a1 + 40) || !*(unsigned char *)(a1 + 38)))
  {
    if (qword_1009F7ED0 != -1) {
      dispatch_once(&qword_1009F7ED0, &stru_1009BFD08);
    }
    char v6 = *(unsigned __int8 **)(a1 + 48);
    if (!v6) {
      char v6 = *(unsigned __int8 **)(a1 + 56);
    }
    sub_100705EB8(qword_1009F7EC8, v6);
  }
}

void sub_10071AB94(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10071ABB0(uint64_t result, uint64_t a2, uint64_t a3, char a4)
{
  *(_WORD *)(result + 8) = 1;
  *(void *)uint64_t result = off_1009BFCA8;
  *(void *)(result + 16) = a2;
  *(void *)(result + 24) = 0;
  *(unsigned char *)(result + 32) = a4;
  if (a3) {
    operator new[]();
  }
  return result;
}

void *sub_10071AC2C(void *result)
{
  uint64_t *result = off_1009BFCA8;
  if (result[3]) {
    operator delete[]();
  }
  return result;
}

void sub_10071AC88(void *a1)
{
  *a1 = off_1009BFCA8;
  if (a1[3]) {
    operator delete[]();
  }

  operator delete();
}

uint64_t sub_10071AD04(uint64_t a1)
{
  int v1 = *(unsigned __int8 *)(a1 + 32);
  uint64_t v2 = sub_10003FB34();
  if (v1)
  {
    unint64_t v3 = *(uint64_t (**)(void))(*(void *)v2 + 376);
    return v3();
  }
  else
  {
    int v5 = *(uint64_t (**)(void))(*(void *)v2 + 368);
    return v5();
  }
}

void sub_10071ADC0()
{
}

void sub_10071ADD4()
{
  if (qword_1009F7ED0 != -1) {
    dispatch_once(&qword_1009F7ED0, &stru_1009BFD08);
  }
  uint64_t v0 = qword_1009F7EC8;

  sub_10070DCC4(v0);
}

void sub_10071AE28(id a1)
{
}

void sub_10071AE6C()
{
}

void sub_10071AE90(uint64_t a1, void *a2)
{
  if (a2)
  {
    sub_10071AE90(a1, *a2);
    sub_10071AE90(a1, a2[1]);
    sub_10071AEEC((uint64_t)(a2 + 4));
    operator delete(a2);
  }
}

void sub_10071AEEC(uint64_t a1)
{
  if (*(char *)(a1 + 71) < 0) {
    operator delete(*(void **)(a1 + 48));
  }
  if (*(char *)(a1 + 47) < 0) {
    operator delete(*(void **)(a1 + 24));
  }
  if (*(char *)(a1 + 23) < 0)
  {
    uint64_t v2 = *(void **)a1;
    operator delete(v2);
  }
}

void sub_10071AF54(uint64_t a1, void *a2)
{
  if (a2)
  {
    sub_10071AF54(a1, *a2);
    sub_10071AF54(a1, a2[1]);
    a2[6] = &off_1009B4578;
    unint64_t v4 = (atomic_uint *)a2[7];
    if (v4) {
      sub_1000368F4(v4);
    }
    operator delete(a2);
  }
}

void sub_10071AFD4(id a1)
{
}

void sub_10071B018()
{
}

void sub_10071B03C(id a1)
{
}

void sub_10071B080()
{
}

uint64_t *sub_10071B0A4(uint64_t **a1, unsigned __int8 *uu1, uint64_t a3, const unsigned __int8 *__attribute__((__org_typedef(uuid_t))) *a4)
{
  uint64_t v9 = 0;
  char v6 = (uint64_t **)sub_10004A0BC((uint64_t)a1, &v9, uu1);
  uint64_t result = *v6;
  if (!*v6)
  {
    memset(v8, 0, sizeof(v8));
    sub_10071B148((uint64_t)a1, a4, v8);
    sub_100036CA0(a1, v9, v6, (uint64_t *)v8[0]);
    return (uint64_t *)v8[0];
  }
  return result;
}

void sub_10071B148(uint64_t a1@<X0>, const unsigned __int8 *__attribute__((__org_typedef(uuid_t))) *a2@<X2>, unsigned __int8 **a3@<X8>)
{
  uint64_t v5 = a1 + 8;
  *a3 = 0;
  a3[2] = 0;
  a3[1] = 0;
  char v6 = a3 + 1;
  unint64_t v7 = (unsigned __int8 *)operator new(0x40uLL);
  *a3 = v7;
  *char v6 = v5;
  *((unsigned char *)a3 + 16) = 0;
  uuid_copy(v7 + 32, *a2);
  *((void *)v7 + 6) = &off_1009B4578;
  *((void *)v7 + 7) = 0;
  *((unsigned char *)a3 + 16) = 1;
}

void sub_10071B1DC(_Unwind_Exception *a1)
{
  *int v1 = 0;
  sub_10071B1F8(v2, v3);
  _Unwind_Resume(a1);
}

void sub_10071B1F8(uint64_t a1, void *__p)
{
  if (*(unsigned char *)(a1 + 8))
  {
    __p[6] = &off_1009B4578;
    unint64_t v3 = (atomic_uint *)__p[7];
    if (v3) {
      sub_1000368F4(v3);
    }
  }
  else if (!__p)
  {
    return;
  }

  operator delete(__p);
}

void sub_10071B274(id a1)
{
}

void sub_10071B2B8()
{
}

void sub_10071B2DC(id a1)
{
}

void sub_10071B320()
{
}

uint64_t *sub_10071B344(uint64_t **a1, unsigned __int8 *uu1, uint64_t a3, const unsigned __int8 *__attribute__((__org_typedef(uuid_t))) *a4)
{
  uint64_t v9 = 0;
  char v6 = (uint64_t **)sub_10004A0BC((uint64_t)a1, &v9, uu1);
  uint64_t result = *v6;
  if (!*v6)
  {
    memset(v8, 0, sizeof(v8));
    sub_10071B3E8((uint64_t)a1, a4, v8);
    sub_100036CA0(a1, v9, v6, (uint64_t *)v8[0]);
    return (uint64_t *)v8[0];
  }
  return result;
}

void sub_10071B3E8(uint64_t a1@<X0>, const unsigned __int8 *__attribute__((__org_typedef(uuid_t))) *a2@<X2>, unsigned __int8 **a3@<X8>)
{
  uint64_t v5 = a1 + 8;
  *a3 = 0;
  a3[2] = 0;
  a3[1] = 0;
  char v6 = a3 + 1;
  unint64_t v7 = (unsigned __int8 *)operator new(0x40uLL);
  *a3 = v7;
  *char v6 = v5;
  *((unsigned char *)a3 + 16) = 0;
  uuid_copy(v7 + 32, *a2);
  *((void *)v7 + 6) = &off_1009B4578;
  *((void *)v7 + 7) = 0;
  *((unsigned char *)a3 + 16) = 1;
}

void sub_10071B47C(_Unwind_Exception *a1)
{
  *int v1 = 0;
  sub_10071B1F8(v2, v3);
  _Unwind_Resume(a1);
}

uint64_t *sub_10071B498(uint64_t **a1, unsigned __int8 *uu1, uint64_t a3, const unsigned __int8 *__attribute__((__org_typedef(uuid_t))) *a4)
{
  uint64_t v9 = 0;
  char v6 = (uint64_t **)sub_10004A0BC((uint64_t)a1, &v9, uu1);
  uint64_t result = *v6;
  if (!*v6)
  {
    memset(v8, 0, sizeof(v8));
    sub_10071B53C((uint64_t)a1, a4, v8);
    sub_100036CA0(a1, v9, v6, (uint64_t *)v8[0]);
    return (uint64_t *)v8[0];
  }
  return result;
}

void sub_10071B53C(uint64_t a1@<X0>, const unsigned __int8 *__attribute__((__org_typedef(uuid_t))) *a2@<X2>, unsigned __int8 **a3@<X8>)
{
  uint64_t v5 = (unsigned __int8 *)(a1 + 8);
  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  char v6 = (unsigned __int8 *)operator new(0x40uLL);
  *a3 = v6;
  a3[1] = v5;
  *((unsigned char *)a3 + 16) = 0;
  uuid_copy(v6 + 32, *a2);
  *((void *)v6 + 6) = 0;
  v6[56] = 0;
  *((unsigned char *)a3 + 16) = 1;
}

void sub_10071B5A4(_Unwind_Exception *a1)
{
  *int v1 = 0;
  operator delete(v2);
  _Unwind_Resume(a1);
}

uint64_t *sub_10071B5BC(uint64_t **a1, uint64_t *a2)
{
  unint64_t v3 = sub_10004D3B8(a1, a2);
  a2[6] = (uint64_t)&off_1009B4578;
  unint64_t v4 = (atomic_uint *)a2[7];
  if (v4) {
    sub_1000368F4(v4);
  }
  operator delete(a2);
  return v3;
}

void sub_10071B61C(id a1)
{
}

void sub_10071B660()
{
}

void sub_10071B684(id a1)
{
}

void sub_10071B6C8()
{
}

void sub_10071B6EC(id a1)
{
}

void sub_10071B730()
{
}

void sub_10071B754(void *a1, uint64_t a2, os_log_t log, const char *a4, ...)
{
  va_start(va, a4);
  _os_log_debug_impl(a1, log, OS_LOG_TYPE_DEBUG, a4, (uint8_t *)va, 0xEu);
}

void sub_10071B774(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  id v6 = a4;
  memset(&v24, 0, sizeof(v24));
  memset(&v23, 0, sizeof(v23));
  sub_10004191C(&v23, "Unknown");
  memset(&v22, 0, sizeof(v22));
  sub_10004191C(&v22, "");
  if (v6)
  {
    id v7 = [v6 UUIDString];
    std::string::assign(&v22, (const std::string::value_type *)[v7 UTF8String]);

    if (qword_1009F7EE0 != -1) {
      dispatch_once(&qword_1009F7EE0, &stru_1009BFE88);
    }
    sub_10003093C((uint64_t)off_1009F7ED8, v6, (uint64_t)buf);
    if (v30 >= 0) {
      uint64_t v8 = buf;
    }
    else {
      uint64_t v8 = *(const std::string::value_type **)buf;
    }
    std::string::assign(&v23, v8);
    if (SHIBYTE(v30) < 0) {
      operator delete(*(void **)buf);
    }
  }
  if ((a2 - 1) > 3) {
    uint64_t v9 = "UnknownEvent";
  }
  else {
    uint64_t v9 = off_1009BFEA8[(int)a2 - 1];
  }
  std::string::assign(&v24, v9);
  uint64_t v10 = qword_100A19F40;
  if (os_log_type_enabled((os_log_t)qword_100A19F40, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v11 = &v24;
    if ((v24.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
      uint64_t v11 = (std::string *)v24.__r_.__value_.__r.__words[0];
    }
    int v12 = &v22;
    if ((v22.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
      int v12 = (std::string *)v22.__r_.__value_.__r.__words[0];
    }
    int v13 = &v23;
    if ((v23.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
      int v13 = (std::string *)v23.__r_.__value_.__r.__words[0];
    }
    *(_DWORD *)long long buf = 136315906;
    *(void *)&uint8_t buf[4] = v11;
    __int16 v28 = 2082;
    uint64_t v29 = v12;
    __int16 v30 = 2080;
    long long v31 = v13;
    __int16 v32 = 2082;
    uint64_t v33 = a3;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "ThirdParty App Connection Limit exceeded wakeup by LE %s uuid=%{public}s(%s), bundleID=%{public}s", buf, 0x2Au);
  }
  v25[0] = @"WakeEventType";
  char v15 = +[NSNumber numberWithUnsignedInt:a2];
  v26[0] = v15;
  v25[1] = @"BundleID";
  char v16 = +[NSString stringWithUTF8String:a3];
  v26[1] = v16;
  void v25[2] = @"CBUUID";
  if ((v22.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    char v17 = &v22;
  }
  else {
    char v17 = (std::string *)v22.__r_.__value_.__r.__words[0];
  }
  int v18 = +[NSString stringWithUTF8String:v17];
  void v26[2] = v18;
  v25[3] = @"DeviceName";
  if ((v23.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    uint64_t v19 = &v23;
  }
  else {
    uint64_t v19 = (std::string *)v23.__r_.__value_.__r.__words[0];
  }
  __int16 v20 = +[NSString stringWithUTF8String:v19];
  v26[3] = v20;
  int v21 = +[NSDictionary dictionaryWithObjects:v26 forKeys:v25 count:4];

  PLLogRegisteredEvent();
  if (SHIBYTE(v22.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v22.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v23.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v23.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v24.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v24.__r_.__value_.__l.__data_);
  }
}

void sub_10071BADC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,void *a22,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (*(char *)(v28 - 105) < 0) {
    operator delete(*(void **)(v28 - 128));
  }
  if (a15 < 0) {
    operator delete(__p);
  }
  if (a21 < 0) {
    operator delete(a16);
  }
  if (a27 < 0) {
    operator delete(a22);
  }

  _Unwind_Resume(a1);
}

void sub_10071BBA0(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  id v6 = a4;
  if (sub_100540014())
  {
    v12[0] = @"BundleID";
    uint64_t v8 = +[NSString stringWithUTF8String:a2];
    v13[0] = v8;
    v12[1] = @"Connect";
    uint64_t v9 = +[NSNumber numberWithBool:a3];
    v13[1] = v9;
    v12[2] = @"CBUUID";
    uint64_t v10 = [v6 UUIDString];
    _DWORD v13[2] = v10;
    uint64_t v11 = +[NSDictionary dictionaryWithObjects:v13 forKeys:v12 count:3];

    PLLogRegisteredEvent();
  }
  else if (os_log_type_enabled((os_log_t)qword_100A19E50, OS_LOG_TYPE_ERROR))
  {
    sub_100798D34();
  }
}

void sub_10071BD0C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_10071BD58(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  id v6 = a4;
  if (sub_100540014())
  {
    if (v6)
    {
      if (qword_1009F7EE0 != -1) {
        dispatch_once(&qword_1009F7EE0, &stru_1009BFE88);
      }
      uint64_t v7 = sub_1006C8550((uint64_t)off_1009F7ED8, v6);
      uint64_t v8 = [v6 UUIDString];
      if (qword_1009F7EE0 != -1) {
        dispatch_once(&qword_1009F7EE0, &stru_1009BFE88);
      }
      sub_10003093C((uint64_t)off_1009F7ED8, v6, (uint64_t)__p);
      if (SHIBYTE(v26) < 0)
      {
        uint64_t v11 = *(void *)&__p[8];
        operator delete(*(void **)__p);
        if (v11) {
          goto LABEL_9;
        }
      }
      else if (HIBYTE(v26))
      {
LABEL_9:
        if (qword_1009F7EE0 != -1) {
          dispatch_once(&qword_1009F7EE0, &stru_1009BFE88);
        }
        sub_10003093C((uint64_t)off_1009F7ED8, v6, (uint64_t)__p);
        if (v26 >= 0) {
          uint64_t v9 = __p;
        }
        else {
          uint64_t v9 = *(unsigned char **)__p;
        }
        uint64_t v10 = +[NSString stringWithUTF8String:v9];
        if (SHIBYTE(v26) < 0) {
          operator delete(*(void **)__p);
        }
        goto LABEL_21;
      }
      uint64_t v10 = @"Unknown";
    }
    else
    {
      uint64_t v7 = 0;
      uint64_t v8 = @"Unknown";
      uint64_t v10 = @"Unknown";
    }
LABEL_21:
    int v12 = qword_100A19F40;
    if (os_log_type_enabled((os_log_t)qword_100A19F40, OS_LOG_TYPE_DEFAULT))
    {
      int v13 = sub_1006B11A0(v7);
      char v14 = "disconnect";
      *(_DWORD *)std::string __p = 138544130;
      *(void *)&__p[4] = v6;
      if (a3) {
        char v14 = "connect";
      }
      *(_WORD *)&unsigned char __p[12] = 2080;
      *(void *)&__p[14] = v14;
      __int16 v26 = 2082;
      uint64_t v27 = a2;
      __int16 v28 = 2080;
      uint64_t v29 = v13;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "PowerLogger device \"%{public}@\" %s for bundleIDs \"%{public}s\" peerType %s", __p, 0x2Au);
    }
    char v16 = +[NSString stringWithUTF8String:a2, @"BundleID"];
    v24[0] = v16;
    v23[1] = @"Connect";
    uint64_t v17 = +[NSNumber numberWithBool:a3];
    int v18 = (void *)v17;
    if (v8) {
      CFStringRef v19 = v8;
    }
    else {
      CFStringRef v19 = @"Unknown";
    }
    v24[1] = v17;
    _DWORD v24[2] = v19;
    void v23[2] = @"CBUUID";
    v23[3] = @"Name";
    if (v10) {
      CFStringRef v20 = v10;
    }
    else {
      CFStringRef v20 = @"Unknown";
    }
    v24[3] = v20;
    v23[4] = @"PeerType";
    int v21 = +[NSNumber numberWithUnsignedInt:v7];
    v24[4] = v21;
    std::string v22 = +[NSDictionary dictionaryWithObjects:v24 forKeys:v23 count:5];

    PLLogRegisteredEvent();

    goto LABEL_32;
  }
  if (os_log_type_enabled((os_log_t)qword_100A19E50, OS_LOG_TYPE_ERROR)) {
    sub_100798D34();
  }
LABEL_32:
}

void sub_10071C0E8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *__p, uint64_t a20,int a21,__int16 a22,char a23,char a24)
{
  if (a24 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

void sub_10071C180(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (sub_100540014())
  {
    v12[0] = @"Duration";
    uint64_t v8 = +[NSNumber numberWithUnsignedInt:a2];
    v13[0] = v8;
    v12[1] = @"PercentageEPAPower";
    uint64_t v9 = +[NSNumber numberWithUnsignedInt:a3];
    v13[1] = v9;
    v12[2] = @"PercentageIPAPower";
    uint64_t v10 = +[NSNumber numberWithUnsignedInt:a4];
    _DWORD v13[2] = v10;
    uint64_t v11 = +[NSDictionary dictionaryWithObjects:v13 forKeys:v12 count:3];

    PLLogRegisteredEvent();
  }
  else if (os_log_type_enabled((os_log_t)qword_100A19E50, OS_LOG_TYPE_ERROR))
  {
    sub_100798D34();
  }
}

void sub_10071C2E4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_10071C320(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  if (sub_100540014())
  {
    v18[0] = @"Duration";
    int v12 = +[NSNumber numberWithUnsignedInt:a2];
    v19[0] = v12;
    v18[1] = @"PercentageEPAPowerFirstWindow";
    int v13 = +[NSNumber numberWithUnsignedInt:a3];
    v19[1] = v13;
    void v18[2] = @"PercentageIPAPowerFirstWindow";
    char v14 = +[NSNumber numberWithUnsignedInt:a4];
    void v19[2] = v14;
    void v18[3] = @"PercentageEPAPowerSecondWindow";
    char v15 = +[NSNumber numberWithUnsignedInt:a5];
    v19[3] = v15;
    v18[4] = @"PercentageIPAPowerSecondWindow";
    char v16 = +[NSNumber numberWithUnsignedInt:a6];
    v19[4] = v16;
    uint64_t v17 = +[NSDictionary dictionaryWithObjects:v19 forKeys:v18 count:5];

    PLLogRegisteredEvent();
  }
  else if (os_log_type_enabled((os_log_t)qword_100A19E50, OS_LOG_TYPE_ERROR))
  {
    sub_100798D34();
  }
}

void sub_10071C4E4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_10071C538(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, unsigned char *a6)
{
  if (a6 && *a6)
  {
    uint64_t v10 = *(void *)(a2 + 8);
    int v13 = &off_100998428;
    char v14 = (atomic_uint *)v10;
    if (v10) {
      sub_100037354(v10);
    }
    sub_10071C674((uint64_t)&v13, a3, a4, a5, (uint64_t)a6, 0);
    int v13 = &off_100998428;
    uint64_t v11 = v14;
    if (!v14) {
      return;
    }
LABEL_10:
    sub_1000368F4(v11);
    return;
  }
  uint64_t v12 = *(void *)(a2 + 8);
  char v15 = &off_100998428;
  char v16 = (atomic_uint *)v12;
  if (v12) {
    sub_100037354(v12);
  }
  sub_10071C674((uint64_t)&v15, a3, a4, a5, (uint64_t)"Unknown", 0);
  char v15 = &off_100998428;
  uint64_t v11 = v16;
  if (v16) {
    goto LABEL_10;
  }
}

void sub_10071C644(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, atomic_uint *a10, uint64_t a11, uint64_t a12)
{
  if (a10) {
    sub_1000368F4(a10);
  }
  _Unwind_Resume(exception_object);
}

void sub_10071C674(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  if (sub_100540014())
  {
    memset(&v29, 0, sizeof(v29));
    uint64_t v12 = "PassupAdvertising";
    switch((int)a2)
    {
      case 0:
        std::string::assign(&v29, "Others");
        goto LABEL_17;
      case 1:
        uint64_t v12 = "Advertising";
        goto LABEL_13;
      case 2:
        goto LABEL_13;
      case 3:
        uint64_t v12 = "Connection";
        goto LABEL_13;
      case 4:
        uint64_t v12 = "Data";
        goto LABEL_13;
      case 5:
        uint64_t v12 = "Disconnection";
        goto LABEL_13;
      case 6:
        uint64_t v12 = "RSSIRegionDetection";
        goto LABEL_13;
      case 7:
        uint64_t v12 = "SensorTracking";
        goto LABEL_13;
      default:
        uint64_t v12 = "UnknownEvent";
LABEL_13:
        std::string::assign(&v29, v12);
        int v13 = qword_100A19F40;
        if (os_log_type_enabled((os_log_t)qword_100A19F40, OS_LOG_TYPE_DEFAULT))
        {
          int v14 = SHIBYTE(v29.__r_.__value_.__r.__words[2]);
          std::string::size_type v15 = v29.__r_.__value_.__r.__words[0];
          char v16 = sub_1006B11A0(a6);
          *(_DWORD *)long long buf = 136447234;
          uint64_t v17 = &v29;
          if (v14 < 0) {
            uint64_t v17 = (std::string *)v15;
          }
          uint64_t v33 = v17;
          __int16 v34 = 2082;
          uint64_t v35 = a3;
          __int16 v36 = 2082;
          uint64_t v37 = a4;
          __int16 v38 = 2080;
          uint64_t v39 = a5;
          __int16 v40 = 2082;
          __int16 v41 = v16;
          _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "AP wakeup by LE %{public}s bundleID=%{public}s, uuid=%{public}s, deviceName=%s, peerType=%{public}s", buf, 0x34u);
        }
LABEL_17:
        uint64_t v19 = sub_10004A6E4(a1);
        uint64_t v20 = +[NSData dataWithBytes:v19 length:sub_100045F00(a1)];
        int v21 = (void *)v20;
        CFStringRef v22 = &stru_1009C1AC8;
        if (v20) {
          CFStringRef v22 = (const __CFString *)v20;
        }
        v31[0] = v22;
        v30[0] = @"HostWakeReport";
        v30[1] = @"WakeEventType";
        std::string v23 = +[NSNumber numberWithUnsignedInt:a2];
        v31[1] = v23;
        void v30[2] = @"BundleID";
        if (a3)
        {
          std::string v24 = +[NSString stringWithUTF8String:a3];
        }
        else
        {
          std::string v24 = @"Unknown";
        }
        void v31[2] = v24;
        v30[3] = @"CBUUID";
        int v25 = +[NSString stringWithUTF8String:a4];
        v31[3] = v25;
        v30[4] = @"DeviceName";
        __int16 v26 = +[NSString stringWithUTF8String:a5];
        v31[4] = v26;
        v30[5] = @"PeerType";
        uint64_t v27 = +[NSNumber numberWithUnsignedInt:a6];
        v31[5] = v27;
        __int16 v28 = +[NSDictionary dictionaryWithObjects:v31 forKeys:v30 count:6];

        if (a3) {
        PLLogRegisteredEvent();
        }

        if (SHIBYTE(v29.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v29.__r_.__value_.__l.__data_);
        }
        break;
    }
  }
  else if (os_log_type_enabled((os_log_t)qword_100A19E50, OS_LOG_TYPE_ERROR))
  {
    sub_100798D34();
  }
}

void sub_10071CA08(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_10071CAB0(uint64_t a1, uint64_t a2, uint64_t a3, void *a4, uint64_t a5)
{
  id v8 = a4;
  __p[0] = 0;
  __p[1] = 0;
  uint64_t v20 = 0;
  sub_10004191C(__p, "Unknown");
  memset(&v18, 0, sizeof(v18));
  sub_10004191C(&v18, "Unknown");
  if (v8)
  {
    id v9 = [v8 UUIDString];
    std::string::assign(&v18, (const std::string::value_type *)[v9 UTF8String]);

    if (qword_1009F7EE0 != -1) {
      dispatch_once(&qword_1009F7EE0, &stru_1009BFE88);
    }
    sub_10003093C((uint64_t)off_1009F7ED8, v8, (uint64_t)&v16);
    if (SHIBYTE(v20) < 0) {
      operator delete(__p[0]);
    }
    *(_OWORD *)std::string __p = v16;
    uint64_t v20 = v17;
    if (qword_1009F7EE0 != -1) {
      dispatch_once(&qword_1009F7EE0, &stru_1009BFE88);
    }
    uint64_t v10 = sub_1006C8550((uint64_t)off_1009F7ED8, v8);
  }
  else
  {
    uint64_t v10 = 0;
  }
  uint64_t v11 = *(atomic_uint **)(a5 + 8);
  int v14 = &off_100998428;
  std::string::size_type v15 = v11;
  if (v11) {
    sub_100037354((uint64_t)v11);
  }
  if ((v18.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    uint64_t v12 = &v18;
  }
  else {
    uint64_t v12 = (std::string *)v18.__r_.__value_.__r.__words[0];
  }
  if (v20 >= 0) {
    int v13 = __p;
  }
  else {
    int v13 = (void **)__p[0];
  }
  sub_10071C674((uint64_t)&v14, a2, a3, (uint64_t)v12, (uint64_t)v13, v10);
  int v14 = &off_100998428;
  if (v15) {
    sub_1000368F4(v15);
  }
  if (SHIBYTE(v18.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v18.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v20) < 0) {
    operator delete(__p[0]);
  }
}

void sub_10071CC8C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19, void *a20,uint64_t a21,int a22,__int16 a23,char a24,char a25)
{
  if (a19 < 0) {
    operator delete(__p);
  }
  if (a25 < 0) {
    operator delete(a20);
  }

  _Unwind_Resume(a1);
}

void sub_10071CCF4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  if (sub_100540014())
  {
    v15[0] = @"LegacyDupFilterOverflowReport";
    uint64_t v10 = +[NSNumber numberWithUnsignedChar:a2];
    v16[0] = v10;
    v15[1] = @"ExtDupFilterOverflow";
    uint64_t v11 = +[NSNumber numberWithUnsignedChar:a3];
    v16[1] = v11;
    v15[2] = @"LegacyDupFilterOverflowCnt";
    uint64_t v12 = +[NSNumber numberWithUnsignedShort:a4];
    void v16[2] = v12;
    v15[3] = @"ExtDupFilterOverflowCnt";
    int v13 = +[NSNumber numberWithUnsignedShort:a5];
    v16[3] = v13;
    int v14 = +[NSDictionary dictionaryWithObjects:v16 forKeys:v15 count:4];

    PLLogRegisteredEvent();
  }
  else if (os_log_type_enabled((os_log_t)qword_100A19E50, OS_LOG_TYPE_ERROR))
  {
    sub_100798D34();
  }
}

void sub_10071CE84(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_10071CECC(double a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  v18[0] = @"CTScanCount";
  uint64_t v12 = +[NSNumber numberWithUnsignedLongLong:a3];
  v19[0] = v12;
  v18[1] = @"CTScanDuration";
  int v13 = +[NSNumber numberWithUnsignedLongLong:a4];
  v19[1] = v13;
  void v18[2] = @"CTAdvertisingReports";
  int v14 = +[NSNumber numberWithUnsignedLongLong:a5];
  void v19[2] = v14;
  void v18[3] = @"NonCTAdvertisingReports";
  std::string::size_type v15 = +[NSNumber numberWithUnsignedLongLong:a6];
  v19[3] = v15;
  v18[4] = @"CTLastScanTS";
  long long v16 = +[NSNumber numberWithDouble:a1];
  v19[4] = v16;
  uint64_t v17 = +[NSDictionary dictionaryWithObjects:v19 forKeys:v18 count:5];

  PLLogRegisteredEvent();
}

void sub_10071D068(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_10071D0C0()
{
}

void sub_10071D0D4(id a1)
{
}

void sub_10071D118()
{
}

unsigned char *sub_10071D13C(unsigned char *result)
{
  uint64_t *result = 0;
  return result;
}

uint64_t sub_10071D144(uint64_t a1, __int16 a2)
{
  __int16 v4 = a2;
  sub_10022A5EC((int8x16_t *)&v4, 2, 1, (uint64_t)&v5);
  *(_OWORD *)a1 = v5;
  *(_DWORD *)(a1 + 16) = v6;
  return a1;
}

uint64_t sub_10071D1C4(uint64_t a1, int8x16_t *a2, uint64_t a3)
{
  sub_10022A5EC(a2, a3, 0, (uint64_t)&v5);
  *(_OWORD *)a1 = v5;
  *(_DWORD *)(a1 + 16) = v6;
  return a1;
}

uint64_t sub_10071D240(unsigned __int8 *a1, unsigned char *a2)
{
  if (!*a1) {
    return 0;
  }
  sub_10022A6F4(a2, a1, 0);
  return *a1;
}

BOOL sub_10071D284(unsigned __int8 *a1, unsigned __int8 *a2)
{
  size_t v2 = *a1;
  unsigned int v3 = *a2;
  if (v2 == v3) {
    return memcmp(a1 + 4, a2 + 4, v2) >> 31;
  }
  else {
    return v2 < v3;
  }
}

uint64_t sub_10071D2E4(uint64_t a1)
{
  uint64_t v2 = a1 + 8;
  uint64_t v3 = a1 + 16;
  *(void *)a1 = off_1009BFED8;
  *(void *)(a1 + 8) = off_1009BFF70;
  *(void *)(a1 + 16) = &off_1009BFFA0;
  *(_DWORD *)(a1 + 24) = 0;
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 40) = 0;
  *(void *)(a1 + 48) = 0;
  *(_DWORD *)(a1 + 56) = 0;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  if (qword_1009F8070 != -1) {
    dispatch_once(&qword_1009F8070, &stru_1009C0058);
  }
  sub_10026B36C((uint64_t)off_1009F8068 + 64, v2);
  uint64_t v4 = sub_10003FFD4();
  sub_1007207DC(v4 + 768, v3);
  if (sub_10071D448() && sub_1005403A0())
  {
    DarwinNotifyCenter = CFNotificationCenterGetDarwinNotifyCenter();
    CFNotificationCenterAddObserver(DarwinNotifyCenter, 0, (CFNotificationCallback)sub_10071D57C, kRegulatoryDomainUpdateNotification, 0, CFNotificationSuspensionBehaviorDeliverImmediately);
  }
  return a1;
}

void sub_10071D414(_Unwind_Exception *a1)
{
  uint64_t v4 = *(void **)(v1 + 64);
  if (v4)
  {
    *(void *)(v1 + 72) = v4;
    operator delete(v4);
  }
  long long v5 = *v2;
  if (*v2)
  {
    *(void *)(v1 + 40) = v5;
    operator delete(v5);
  }
  _Unwind_Resume(a1);
}

BOOL sub_10071D448()
{
  if (qword_100A147A0 != -1) {
    dispatch_once(&qword_100A147A0, &stru_1009BFFA8);
  }
  uint64_t v0 = qword_100A19E50;
  if (os_log_type_enabled((os_log_t)qword_100A19E50, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v1 = "TRUE";
    if (byte_100A14798) {
      uint64_t v2 = "TRUE";
    }
    else {
      uint64_t v2 = "FALSE";
    }
    if (byte_100A14799) {
      uint64_t v3 = "TRUE";
    }
    else {
      uint64_t v3 = "FALSE";
    }
    int v5 = 136315650;
    int v6 = v2;
    __int16 v7 = 2080;
    if (!(byte_100A14799 | byte_100A14798)) {
      uint64_t v1 = "FALSE";
    }
    id v8 = v3;
    __int16 v9 = 2080;
    uint64_t v10 = v1;
    _os_log_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_DEFAULT, "PurpleLocation::useRegulatoryDomainForCountryCode() -- enabled = %s -- overrideEnabled = %s -- returning %s", (uint8_t *)&v5, 0x20u);
  }
  return (byte_100A14798 | byte_100A14799) != 0;
}

void sub_10071D57C()
{
  uint64_t v0 = sub_1004AF8EC();

  sub_100013018(v0, &stru_1009C0038);
}

void *sub_10071D5B0(void *a1)
{
  *a1 = off_1009BFED8;
  a1[1] = off_1009BFF70;
  uint64_t v2 = (uint64_t)(a1 + 2);
  a1[2] = &off_1009BFFA0;
  uint64_t v3 = sub_10003FFD4();
  sub_100720B7C(v3 + 768, v2);
  if (sub_10071D448() && sub_1005403A0())
  {
    DarwinNotifyCenter = CFNotificationCenterGetDarwinNotifyCenter();
    CFNotificationCenterRemoveObserver(DarwinNotifyCenter, a1, kRegulatoryDomainUpdateNotification, 0);
  }

  int v5 = (void *)a1[8];
  if (v5)
  {
    a1[9] = v5;
    operator delete(v5);
  }
  int v6 = (void *)a1[4];
  if (v6)
  {
    a1[5] = v6;
    operator delete(v6);
  }
  return a1;
}

void sub_10071D694(_Unwind_Exception *a1)
{
  uint64_t v3 = *(void **)(v1 + 64);
  if (v3)
  {
    *(void *)(v1 + 72) = v3;
    operator delete(v3);
  }
  sub_100798D68(v1);
  _Unwind_Resume(a1);
}

void sub_10071D6C4(void *a1)
{
  sub_10071D5B0(a1);

  operator delete();
}

void sub_10071D6FC(id a1)
{
  byte_100A14798 = _os_feature_enabled_impl();
  uint64_t v1 = sub_100017768();
  sub_10004191C(buf, "CountryCode");
  sub_10004191C(__p, "UseRegulatoryDomain");
  int v2 = (*(uint64_t (**)(uint64_t, unsigned char *, void **, char *))(*(void *)v1 + 72))(v1, buf, __p, &byte_100A14799);
  if (v6 < 0) {
    operator delete(__p[0]);
  }
  if (v8 < 0)
  {
    operator delete(*(void **)buf);
    if (!v2) {
      return;
    }
  }
  else if (!v2)
  {
    return;
  }
  uint64_t v3 = qword_100A19E50;
  if (os_log_type_enabled((os_log_t)qword_100A19E50, OS_LOG_TYPE_DEFAULT))
  {
    if (byte_100A14799) {
      uint64_t v4 = "Yes";
    }
    else {
      uint64_t v4 = "No";
    }
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = v4;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Warning: overrideEnabled: %s", buf, 0xCu);
  }
}

void sub_10071D868(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  if (a21 < 0) {
    operator delete(a16);
  }
  _Unwind_Resume(exception_object);
}

id sub_10071D8A4(uint64_t a1)
{
  return *(id *)(a1 + 88);
}

BOOL sub_10071D8AC()
{
  if ((*(_DWORD *)(sub_10003FB34() + 712) - 1) < 0x16) {
    return 0;
  }
  int v1 = sub_1003FAF7C();
  BOOL v2 = (v1 - 112) >= 4 && v1 != 233;
  return (v1 - 235) >= 0xC && v2;
}

BOOL sub_10071D904()
{
  int v0 = sub_1003FAF7C();
  return (v0 - 255) < 0xB || (v0 - 124) < 2;
}

BOOL sub_10071D940()
{
  return (*(_DWORD *)(sub_10003FB34() + 712) - 1) >= 0x17 && (sub_1003FAF7C() & 0xFFFFFFFE) != 124;
}

BOOL sub_10071D980()
{
  if (*(_DWORD *)(sub_10003FB34() + 712) != 22) {
    return 0;
  }
  uint64_t v0 = sub_10003FB34();
  (*(void (**)(void **__return_ptr))(*(void *)v0 + 16))(__p);
  if ((v4 & 0x80000000) == 0)
  {
    if (v4 == 2) {
      return LOWORD(__p[0]) == 13123;
    }
    return 0;
  }
  BOOL v1 = __p[1] == (void *)2 && *(_WORD *)__p[0] == 13123;
  operator delete(__p[0]);
  return v1;
}

void sub_10071DA40(uint64_t a1, void *a2, unsigned char *a3, unsigned char *a4, BOOL *a5)
{
  char v8 = a2;
  if ([(__CFString *)v8 isEqualToString:@"XZ"])
  {
    *a3 = 0;
    *a4 = 1;
    *a5 = 1;
  }
  else
  {
    int v9 = sub_1003FAF7C();
    if (v9 == 50)
    {
      CFStringRef v10 = @"/Library/Application Support/BTServer/countryCodesV39.plist";
    }
    else
    {
      CFStringRef v10 = @"/Library/Application Support/BTServer/countryCodesJ3tv.plist";
      if (v9 != 150 && v9 != 158)
      {
        unsigned int v11 = *(_DWORD *)(sub_10003FB34() + 712);
        uint64_t v12 = sub_100035F54();
        int v13 = (*(uint64_t (**)(uint64_t))(*(void *)v12 + 384))(v12);
        if (v11) {
          int v14 = v13;
        }
        else {
          int v14 = 0;
        }
        if (v14 == 1 && v11 <= 0x7CF && v11 > 0x16
          || v11 == 22
          && (uint64_t v15 = sub_100035F54(), ((*(uint64_t (**)(uint64_t))(*(void *)v15 + 424))(v15) & 1) != 0))
        {
          CFStringRef v10 = @"/Library/Application Support/BTServer/countryCodes3.plist";
        }
        else
        {
          uint64_t v16 = sub_100035F54();
          unsigned __int8 v17 = (*(uint64_t (**)(uint64_t))(*(void *)v16 + 360))(v16);
          if (v11) {
            unsigned __int8 v18 = v17;
          }
          else {
            unsigned __int8 v18 = 0;
          }
          if (v11 >= 0x7D0) {
            unsigned __int8 v18 = 0;
          }
          if ((v18 & (v11 > 0x12)) != 0) {
            CFStringRef v10 = @"/Library/Application Support/BTServer/countryCodes2.plist";
          }
          else {
            CFStringRef v10 = @"/Library/Application Support/BTServer/countryCodes.plist";
          }
        }
      }
    }
    uint64_t v19 = +[NSURL fileURLWithPath:v10 isDirectory:0 relativeToURL:0];
    id v35 = 0;
    uint64_t v20 = +[NSDictionary dictionaryWithContentsOfURL:v19 error:&v35];
    id v21 = v35;
    if (v21)
    {
      CFStringRef v22 = qword_100A19E50;
      if (os_log_type_enabled((os_log_t)qword_100A19E50, OS_LOG_TYPE_FAULT))
      {
        std::string v23 = [v21 localizedDescription];
        sub_100798D80(v23, v44, v22);
      }
    }
    std::string v24 = [(__CFString *)v8 uppercaseString];
    int v25 = [v20 objectForKey:v24];

    __int16 v26 = [v25 objectForKey:@"CC"];
    *a3 = [v26 intValue];

    uint64_t v27 = [v25 objectForKey:@"LEFlag"];
    *a4 = [v27 BOOLValue];

    __int16 v28 = [v25 objectForKey:@"HDRFlag"];
    *a5 = v28 != 0;
  }
  std::string v29 = qword_100A19E50;
  if (os_log_type_enabled((os_log_t)qword_100A19E50, OS_LOG_TYPE_DEFAULT))
  {
    unsigned int v30 = [(__CFString *)v8 isEqualToString:@"XZ"];
    CFStringRef v31 = @"default";
    if (!v30) {
      CFStringRef v31 = v8;
    }
    int v32 = *a3;
    int v33 = *a4;
    BOOL v34 = *a5;
    *(_DWORD *)long long buf = 138544130;
    CFStringRef v37 = v31;
    __int16 v38 = 1024;
    int v39 = v32;
    __int16 v40 = 1024;
    int v41 = v33;
    __int16 v42 = 1024;
    BOOL v43 = v34;
    _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEFAULT, "Country specific power settings for country: \"%{public}@\" CC %d LEFlag %d HDRFlag %d", buf, 0x1Eu);
  }
}

void sub_10071DDD0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_10071DE48(uint64_t a1, void *a2, unsigned __int8 *a3, unsigned char *a4)
{
  uint64_t v45 = a2;
  if ([(__CFString *)v45 isEqualToString:@"XZ"])
  {
    *a3 = 0;
    *(_DWORD *)(a3 + 1) = -1;
    *((_DWORD *)a3 + 1) = -1;
    *a4 = 1;
    goto LABEL_48;
  }
  uint64_t v6 = sub_100035F54();
  if ((*(unsigned int (**)(uint64_t))(*(void *)v6 + 384))(v6))
  {
    if (sub_10071D8AC())
    {
      if (sub_10071D904())
      {
        CFStringRef v7 = @"/Library/Application Support/BTServer/countryCodes5MacV39.plist";
      }
      else
      {
        unsigned int v9 = sub_1003FAF7C() - 266;
        if (v9 >= 4) {
          CFStringRef v7 = @"/Library/Application Support/BTServer/countryCodes5Mac.plist";
        }
        else {
          CFStringRef v7 = off_1009C0078[v9];
        }
      }
    }
    else
    {
      CFStringRef v7 = @"/Library/Application Support/BTServer/countryCodes4.plist";
    }
    goto LABEL_23;
  }
  uint64_t v8 = sub_100035F54();
  if (!(*(unsigned int (**)(uint64_t))(*(void *)v8 + 360))(v8))
  {
    if (*(_DWORD *)(sub_10003FB34() + 712) == 25) {
      CFStringRef v7 = @"/Library/Application Support/BTServer/countryCodes6_CC6.plist";
    }
    else {
      CFStringRef v7 = @"/Library/Application Support/BTServer/countryCodes5.plist";
    }
    goto LABEL_23;
  }
  if (!sub_10071D8AC())
  {
    BOOL v10 = sub_10071D980();
    CFStringRef v11 = @"/Library/Application Support/BTServer/countryCodes4.plist";
    CFStringRef v12 = @"/Library/Application Support/BTServer/countryCode5iPadsV2_4337C3_7923.plist";
    goto LABEL_20;
  }
  if (!sub_10071D940())
  {
    BOOL v10 = sub_10071D904();
    CFStringRef v11 = @"/Library/Application Support/BTServer/countryCodes5iPads.plist";
    CFStringRef v12 = @"/Library/Application Support/BTServer/countryCodes5MacV39.plist";
LABEL_20:
    if (v10) {
      CFStringRef v7 = v12;
    }
    else {
      CFStringRef v7 = v11;
    }
    goto LABEL_23;
  }
  CFStringRef v7 = @"/Library/Application Support/BTServer/countryCode5iPadsV2.0_4388C2.plist";
LABEL_23:
  +[NSURL fileURLWithPath:v7 isDirectory:0 relativeToURL:0];
  __int16 v42 = v50 = 0;
  __int16 v44 = +[NSDictionary dictionaryWithContentsOfURL:error:](NSDictionary, "dictionaryWithContentsOfURL:error:");
  id v43 = 0;
  if (v43)
  {
    int v13 = qword_100A19E50;
    if (os_log_type_enabled((os_log_t)qword_100A19E50, OS_LOG_TYPE_FAULT))
    {
      int v14 = [v43 localizedDescription];
      sub_100798D80(v14, v64, v13);
    }
  }
  *a3 = 0;
  *(_DWORD *)(a3 + 1) = -1;
  *((_DWORD *)a3 + 1) = -1;
  uint64_t v15 = [(__CFString *)v45 uppercaseString];
  uint64_t v16 = [v44 objectForKey:v15];

  long long v48 = 0u;
  long long v49 = 0u;
  long long v46 = 0u;
  long long v47 = 0u;
  id v17 = v16;
  id v18 = [v17 countByEnumeratingWithState:&v46 objects:v63 count:16];
  if (v18)
  {
    uint64_t v20 = *(void *)v47;
    *(void *)&long long v19 = 138412290;
    long long v41 = v19;
    do
    {
      for (uint64_t i = 0; i != v18; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v47 != v20) {
          objc_enumerationMutation(v17);
        }
        CFStringRef v22 = *(__CFString **)(*((void *)&v46 + 1) + 8 * i);
        if ([(__CFString *)v22 isEqualToString:@"ISM 2.4", v41])
        {
          std::string v23 = [v17 objectForKey:v22];
          *a3 = [v23 unsignedIntValue];
        }
        else if ([(__CFString *)v22 isEqualToString:@"LE Flag"])
        {
          std::string v24 = [v17 objectForKey:v22];
          *a4 = [v24 BOOLValue];
        }
        else if ([(__CFString *)v22 isEqualToString:@"UNII-1"])
        {
          int v25 = [v17 objectForKey:v22];
          a3[1] = [v25 unsignedIntValue];
        }
        else if ([(__CFString *)v22 isEqualToString:@"UNII-3"])
        {
          __int16 v26 = [v17 objectForKey:v22];
          a3[2] = [v26 unsignedIntValue];
        }
        else if ([(__CFString *)v22 isEqualToString:@"UNII-4"])
        {
          uint64_t v27 = [v17 objectForKey:v22];
          a3[3] = [v27 unsignedIntValue];
        }
        else if ([(__CFString *)v22 isEqualToString:@"UNII-5"])
        {
          __int16 v28 = [v17 objectForKey:v22];
          a3[4] = [v28 unsignedIntValue];

          std::string v29 = [v17 objectForKey:v22];
          a3[5] = [v29 unsignedIntValue];

          unsigned int v30 = [v17 objectForKey:v22];
          a3[6] = [v30 unsignedIntValue];

          CFStringRef v31 = [v17 objectForKey:v22];
          a3[7] = [v31 unsignedIntValue];
        }
        else
        {
          int v32 = qword_100A19E50;
          if (os_log_type_enabled((os_log_t)qword_100A19E50, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)long long buf = v41;
            CFStringRef v52 = v22;
            _os_log_error_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_ERROR, "PurpleLocation::getCountrySpecificPowerSettingsHRB: Unexpected key: %@", buf, 0xCu);
          }
        }
      }
      id v18 = [v17 countByEnumeratingWithState:&v46 objects:v63 count:16];
    }
    while (v18);
  }

LABEL_48:
  int v33 = qword_100A19E50;
  if (os_log_type_enabled((os_log_t)qword_100A19E50, OS_LOG_TYPE_DEFAULT))
  {
    unsigned int v34 = [(__CFString *)v45 isEqualToString:@"XZ"];
    int v35 = *a3;
    CFStringRef v36 = @"default";
    int v37 = *a4;
    if (!v34) {
      CFStringRef v36 = v45;
    }
    int v38 = a3[1];
    int v39 = a3[2];
    int v40 = a3[4];
    *(_DWORD *)long long buf = 138544642;
    CFStringRef v52 = v36;
    __int16 v53 = 1024;
    int v54 = v35;
    __int16 v55 = 1024;
    int v56 = v37;
    __int16 v57 = 1024;
    int v58 = v38;
    __int16 v59 = 1024;
    int v60 = v39;
    __int16 v61 = 1024;
    int v62 = v40;
    _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_DEFAULT, "Country specific power settings for country: \"%{public}@\" ISM 2.4 CC: %d, LEFlag: %d, UNII-1 CC: %d, UNII-3 CC: %d, UNII-5 CC: %d", buf, 0x2Au);
  }
}

void sub_10071E45C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15)
{
  _Unwind_Resume(a1);
}

void sub_10071E544(uint64_t a1, void *a2, uint64_t a3, int a4)
{
  id v6 = a2;
  if ([v6 isEqualToString:@"XZ"])
  {
    *(unsigned char *)a3 = 0;
    *(_DWORD *)(a3 + 1) = -1;
    *(_DWORD *)(a3 + 4) = -1;
    goto LABEL_43;
  }
  int v7 = a4 - 8212;
  if (a4 - 8212) < 0x11 && ((0x116A1u >> v7))
  {
    unsigned int v9 = off_1009C0098[v7];
    *(unsigned char *)a3 = 0;
    *(_DWORD *)(a3 + 1) = -1;
    *(_DWORD *)(a3 + 4) = -1;
    id v38 = v6;
    +[NSURL fileURLWithPath:v9 isDirectory:0 relativeToURL:0];
    v36 = id v43 = 0;
    BOOL v10 = +[NSDictionary dictionaryWithContentsOfURL:v36 error:&v43];
    id v37 = v43;
    if (v37)
    {
      CFStringRef v11 = qword_100A19E50;
      if (!os_log_type_enabled((os_log_t)qword_100A19E50, OS_LOG_TYPE_DEFAULT))
      {
LABEL_42:

        id v6 = v38;
        goto LABEL_43;
      }
      int v35 = v10;
      CFStringRef v12 = [v37 localizedDescription];
      *(_DWORD *)long long buf = 67109378;
      *(_DWORD *)long long v46 = a4;
      *(_WORD *)&v46[4] = 2112;
      *(void *)&v46[6] = v12;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "PurpleLocation::getCountrySpecificPowerSettingsForProduct: Unable to extract country code plist for productID 0x%08X: %@", buf, 0x12u);
    }
    else
    {
      int v35 = v10;
      int v13 = [v6 uppercaseString];
      unsigned int v34 = [v10 objectForKey:v13];

      int v14 = qword_100A19E50;
      if (os_log_type_enabled((os_log_t)qword_100A19E50, OS_LOG_TYPE_INFO))
      {
        uint64_t v15 = sub_10003FB34();
        int v16 = (*(uint64_t (**)(uint64_t))(*(void *)v15 + 2488))(v15);
        *(_DWORD *)long long buf = 138413315;
        *(void *)long long v46 = v6;
        *(_WORD *)&v46[8] = 2112;
        *(void *)&v46[10] = v34;
        __int16 v47 = 2160;
        uint64_t v48 = 1752392040;
        __int16 v49 = 2081;
        uint64_t v50 = "device supports HRB";
        __int16 v51 = 1024;
        int v52 = v16;
        _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_INFO, "PurpleLocation::getCountrySpecificPowerSettingsForProduct: countryString: %@, countryCodeDict: %@, %{private, mask.hash}s: %u", buf, 0x30u);
      }
      uint64_t v17 = sub_10003FB34();
      if ((*(unsigned int (**)(uint64_t))(*(void *)v17 + 2488))(v17))
      {
        long long v41 = 0u;
        long long v42 = 0u;
        long long v39 = 0u;
        long long v40 = 0u;
        id v18 = v34;
        id v19 = [v18 countByEnumeratingWithState:&v39 objects:v44 count:16];
        if (v19)
        {
          uint64_t v21 = *(void *)v40;
          *(void *)&long long v20 = 138412290;
          long long v32 = v20;
          do
          {
            for (uint64_t i = 0; i != v19; uint64_t i = (char *)i + 1)
            {
              if (*(void *)v40 != v21) {
                objc_enumerationMutation(v18);
              }
              std::string v23 = *(void **)(*((void *)&v39 + 1) + 8 * i);
              if (objc_msgSend(v23, "isEqualToString:", @"ISM 2.4", v32))
              {
                std::string v24 = [v18 objectForKey:v23];
                *(unsigned char *)a3 = [v24 unsignedIntValue];
              }
              else if ([v23 isEqualToString:@"UNII-1"])
              {
                int v25 = [v18 objectForKey:v23];
                *(unsigned char *)(a3 + 1) = [v25 unsignedIntValue];
              }
              else if ([v23 isEqualToString:@"UNII-3"])
              {
                __int16 v26 = [v18 objectForKey:v23];
                *(unsigned char *)(a3 + 2) = [v26 unsignedIntValue];
              }
              else if ([v23 isEqualToString:@"UNII-4"])
              {
                uint64_t v27 = [v18 objectForKey:v23];
                *(unsigned char *)(a3 + 3) = [v27 unsignedIntValue];
              }
              else if ([v23 isEqualToString:@"UNII-5a"])
              {
                __int16 v28 = [v18 objectForKey:v23];
                *(unsigned char *)(a3 + 4) = [v28 unsignedIntValue];
              }
              else if ([v23 isEqualToString:@"UNII-5b"])
              {
                std::string v29 = [v18 objectForKey:v23];
                *(unsigned char *)(a3 + 5) = [v29 unsignedIntValue];
              }
              else if ([v23 isEqualToString:@"UNII-5c"])
              {
                unsigned int v30 = [v18 objectForKey:v23];
                *(unsigned char *)(a3 + 6) = [v30 unsignedIntValue];
              }
              else if ([v23 isEqualToString:@"UNII-5d"])
              {
                CFStringRef v31 = [v18 objectForKey:v23];
                *(unsigned char *)(a3 + 7) = [v31 unsignedIntValue];
              }
              else
              {
                log = qword_100A19E50;
                if (os_log_type_enabled((os_log_t)qword_100A19E50, OS_LOG_TYPE_ERROR))
                {
                  *(_DWORD *)long long buf = v32;
                  *(void *)long long v46 = v23;
                  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "PurpleLocation::getCountrySpecificPowerSettingsForProduct: Unexpected key: %@", buf, 0xCu);
                }
              }
            }
            id v19 = [v18 countByEnumeratingWithState:&v39 objects:v44 count:16];
          }
          while (v19);
        }
      }
      else
      {
        id v18 = [v34 objectForKey:@"ISM 2.4"];
        *(unsigned char *)a3 = [v18 unsignedIntValue];
      }
    }
    BOOL v10 = v35;
    goto LABEL_42;
  }
  *(unsigned char *)a3 = 0;
  *(_DWORD *)(a3 + 1) = -1;
  *(_DWORD *)(a3 + 4) = -1;
  uint64_t v8 = qword_100A19E50;
  if (os_log_type_enabled((os_log_t)qword_100A19E50, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 67109120;
    *(_DWORD *)long long v46 = a4;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "PurpleLocation::getCountrySpecificPowerSettingsForProduct: Unexpected product ID: %u", buf, 8u);
  }
LABEL_43:
}

void sub_10071EB8C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, void *a13, void *a14, void *a15, void *a16)
{
  _Unwind_Resume(a1);
}

void sub_10071EC80(uint64_t a1)
{
  sub_10003FB34();
  if (sub_1003542E4())
  {
    if (sub_10071D448())
    {
      int v2 = sub_1005403A0();
      uint64_t v3 = qword_100A19E50;
      BOOL v4 = os_log_type_enabled((os_log_t)qword_100A19E50, OS_LOG_TYPE_DEFAULT);
      if (v2)
      {
        if (v4)
        {
          *(_WORD *)long long buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "CountryCode: Location update triggered using RegulatoryDomain", buf, 2u);
        }
        sub_10071EDE0(a1);
      }
      else
      {
        if (v4)
        {
          *(_WORD *)uint64_t v8 = 0;
          _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "RegulatoryDomain is not available -- setting country code to default", v8, 2u);
        }
        sub_10071F19C(a1, @"XZ");
      }
    }
    else
    {
      id v6 = qword_100A19E50;
      if (os_log_type_enabled((os_log_t)qword_100A19E50, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)int v7 = 0;
        _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "CountryCode: Location update triggered using Geo", v7, 2u);
      }
      sub_10071F570(a1);
    }
  }
  else
  {
    int v5 = *(void **)(a1 + 88);
    *(void *)(a1 + 88) = @"XZ";
  }
}

void sub_10071EDE0(uint64_t a1)
{
  int v2 = qword_100A19E50;
  if (os_log_type_enabled((os_log_t)qword_100A19E50, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "PurpleLocation::startLocationUpdatesRD() -- using RegulatoryDomain for country code", buf, 2u);
  }
  uint64_t v3 = sub_10003FB34();
  uint64_t v4 = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 3352))(v3);
  if (v4)
  {
    id v17 = 0;
    int v5 = sub_10071FCC8(v4, &v17);
    id v6 = v17;
    int v7 = qword_100A19E50;
    if (os_log_type_enabled((os_log_t)qword_100A19E50, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 138543618;
      id v19 = v5;
      __int16 v20 = 2114;
      id v21 = v6;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "CountryCode from RegulatoryDomain, Current Country: %{public}@, Last Known Country: %{public}@", buf, 0x16u);
    }
    if (!v5)
    {
      CFStringRef v12 = +[GEOCountryConfiguration sharedConfiguration];
      int v13 = [v12 countryCode];
      int v5 = +[NSString stringWithFormat:@"%@", v13];

      int v14 = qword_100A19E50;
      BOOL v15 = os_log_type_enabled((os_log_t)qword_100A19E50, OS_LOG_TYPE_DEFAULT);
      if (!v5)
      {
        if (v15)
        {
          *(_WORD *)long long buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "Both RegulatoryDomain and GEOCountryConfiguration returned nil", buf, 2u);
        }
        int v16 = qword_100A19E50;
        if (os_log_type_enabled((os_log_t)qword_100A19E50, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)long long buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "RegulatoryDomain and GeoCountryConfiguration returned nil -- setting country code to default", buf, 2u);
        }
        int v5 = 0;
        sub_10071F19C(a1, @"XZ");
        goto LABEL_25;
      }
      if (v15)
      {
        *(_DWORD *)long long buf = 138543362;
        id v19 = v5;
        _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "Setting country code from GeoCountryConfiguration %{public}@", buf, 0xCu);
      }
    }
    unsigned __int8 v8 = [*(id *)(a1 + 88) isEqualToString:v5];
    unsigned int v9 = qword_100A19E50;
    BOOL v10 = os_log_type_enabled((os_log_t)qword_100A19E50, OS_LOG_TYPE_DEFAULT);
    if (v8)
    {
      if (v10)
      {
        *(_DWORD *)long long buf = 138543362;
        id v19 = v5;
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "CountryCode: update not needed -- same country code %{public}@", buf, 0xCu);
      }
    }
    else
    {
      if (v10)
      {
        *(_DWORD *)long long buf = 138543362;
        id v19 = v5;
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "CountryCode changed -- new country code %{public}@", buf, 0xCu);
      }
      sub_10071F19C(a1, v5);
    }
LABEL_25:

    return;
  }
  if (([*(id *)(a1 + 88) isEqualToString:@"XZ"] & 1) == 0)
  {
    CFStringRef v11 = qword_100A19E50;
    if (os_log_type_enabled((os_log_t)qword_100A19E50, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "Does not support location based power tables -- setting country code to default", buf, 2u);
    }
    sub_10071F19C(a1, @"XZ");
  }
}

void sub_10071F160(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_10071F19C(uint64_t a1, void *a2)
{
  id v4 = a2;
  unsigned __int8 v28 = 0;
  __int16 v27 = 0;
  unsigned __int8 v26 = 0;
  unsigned __int8 v25 = 1;
  uint64_t v5 = sub_10003FB34();
  if ((*(_DWORD *)(v5 + 712) - 23) > 0x7B8)
  {
    (*(void (**)(uint64_t, id, unsigned __int8 *, unsigned __int8 *, unsigned __int8 *))(*(void *)a1 + 8))(a1, v4, &v28, &v26, &v25);
    int v14 = qword_100A19E50;
    if (os_log_type_enabled((os_log_t)qword_100A19E50, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 138543874;
      id v30 = v4;
      __int16 v31 = 1024;
      int v32 = v26;
      __int16 v33 = 1024;
      int v34 = v25;
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "PurpleLocation: Action - country: %{public}@,  LEFlag: %u, HDR Flag: %u", buf, 0x18u);
    }
    uint64_t v15 = sub_10003FB34();
    (*(void (**)(uint64_t, uint64_t, void, void, __int16 *, void))(*(void *)v15 + 576))(v15, 1, v28, v26, &v27, 0);
    (*(void (**)(uint64_t, id, void, void, void))(*(void *)a1 + 88))(a1, v4, v28, v26, v25);
  }
  else
  {
    v24[0] = 0;
    memset(&v24[1], 255, 7);
    sub_10071DE48(v5, v4, v24, &v26);
    uint64_t v6 = sub_10003FB34();
    uint64_t v7 = v24[0];
    int v8 = v26;
    int v9 = v24[1];
    int v10 = v24[2];
    int v11 = v24[4];
    (*(void (**)(uint64_t, uint64_t, void, void, void, void, void, __int16 *, void))(*(void *)v6 + 584))(v6, 1, v24[0], v26, v24[1], v24[2], v24[4], &v27, 0);
    sub_1007200B8((os_unfair_lock_s *)a1, v4, v7, v8 != 0, v9, v10, v11);
    CFStringRef v12 = qword_100A19E50;
    if (os_log_type_enabled((os_log_t)qword_100A19E50, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 138544642;
      id v30 = v4;
      __int16 v31 = 1024;
      int v32 = v7;
      __int16 v33 = 1024;
      int v34 = v8;
      __int16 v35 = 1024;
      int v36 = v9;
      __int16 v37 = 1024;
      int v38 = v10;
      __int16 v39 = 1024;
      int v40 = v11;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "PurpleLocation: Notify HRB Listeners - country: %{public}@, ISM 2.4 CC: %u, LEFlag: %u, UNII-1 CC: %u, UNII-3 CC: %u, UNII-5 CC: %u", buf, 0x2Au);
    }
    (*(void (**)(uint64_t, id, uint64_t, BOOL, uint64_t))(*(void *)a1 + 88))(a1, v4, v7, v8 != 0, 1);
    int v13 = qword_100A19E50;
    if (os_log_type_enabled((os_log_t)qword_100A19E50, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 138544130;
      id v30 = v4;
      __int16 v31 = 1024;
      int v32 = v7;
      __int16 v33 = 1024;
      int v34 = v8;
      __int16 v35 = 1024;
      int v36 = 1;
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "PurpleLocation: Notify Legacy Listeners - country: %{public}@, ISM 2.4 CC: %u, LEFlag: %u, HDR Flag: %u", buf, 0x1Eu);
    }
  }
  objc_storeStrong((id *)(a1 + 88), a2);
  int v16 = qword_100A19E50;
  if (os_log_type_enabled((os_log_t)qword_100A19E50, OS_LOG_TYPE_DEBUG)) {
    sub_100798DD8(v16, v17, v18, v19, v20, v21, v22, v23);
  }
}

void sub_10071F554(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_10071F570(uint64_t a1)
{
  int v2 = qword_100A19E50;
  if (os_log_type_enabled((os_log_t)qword_100A19E50, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "PurpleLocation::startLocationUpdates() -- using Geo for country code", buf, 2u);
  }
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_10071F8A4;
  block[3] = &unk_100997528;
  block[4] = a1;
  if (qword_100A147A8 != -1) {
    dispatch_once(&qword_100A147A8, block);
  }
  uint64_t v3 = +[NSBundle bundleWithPath:@"/System/Library/PrivateFrameworks/MobileWiFi.framework"];
  unsigned int v4 = +[CLLocationManager authorizationStatusForBundle:v3];

  if (v4 - 3 > 1)
  {
    if (([*(id *)(a1 + 88) isEqualToString:@"XZ"] & 1) == 0)
    {
      int v14 = qword_100A19E50;
      if (os_log_type_enabled((os_log_t)qword_100A19E50, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "CountryCode: Location Services disabled!", buf, 2u);
      }
      sub_10071F19C(a1, @"XZ");
    }
  }
  else
  {
    uint64_t v5 = qword_100A19E50;
    if (os_log_type_enabled((os_log_t)qword_100A19E50, OS_LOG_TYPE_DEBUG)) {
      sub_100798E10(v5, v6, v7, v8, v9, v10, v11, v12);
    }
    int v13 = +[GEOCountryConfiguration sharedConfiguration];
    v15[0] = _NSConcreteStackBlock;
    v15[1] = 3221225472;
    v15[2] = sub_10071FAA4;
    v15[3] = &unk_1009BFFC8;
    void v15[4] = a1;
    [v13 updateCountryConfiguration:v15];
  }
}

void sub_10071F780(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_10071F794(uint64_t a1, unsigned int a2)
{
  unsigned int v4 = qword_100A19E50;
  if (os_log_type_enabled((os_log_t)qword_100A19E50, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "CountryCode: Location refresh timer expiry", buf, 2u);
  }
  sub_10071F570(a1);
  dispatch_time_t v5 = dispatch_time(0, 1000000000 * a2);
  global_queue = dispatch_get_global_queue(0, 0);
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 3221225472;
  void v7[2] = sub_10071F894;
  void v7[3] = &unk_100997570;
  v7[4] = a1;
  unsigned int v8 = a2;
  dispatch_after(v5, global_queue, v7);
}

uint64_t sub_10071F894(uint64_t a1)
{
  return sub_10071F794(*(void *)(a1 + 32), *(unsigned int *)(a1 + 40));
}

void sub_10071F8A4(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  unsigned int v10 = 3599;
  uint64_t v2 = sub_100017768();
  sub_10004191C(buf, "LOCATION");
  sub_10004191C(__p, "RefreshTime");
  (*(void (**)(uint64_t, uint8_t *, void **, unsigned int *))(*(void *)v2 + 128))(v2, buf, __p, &v10);
  if (v9 < 0) {
    operator delete(__p[0]);
  }
  if (v12 < 0) {
    operator delete(*(void **)buf);
  }
  uint64_t v3 = qword_100A19E50;
  if (os_log_type_enabled((os_log_t)qword_100A19E50, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 67109120;
    *(_DWORD *)&uint8_t buf[4] = v10;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "CountryCode: Location refresh time set to %u", buf, 8u);
  }
  dispatch_time_t v4 = dispatch_time(0, 1000000000 * v10);
  global_queue = dispatch_get_global_queue(0, 0);
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 3221225472;
  void v6[2] = sub_10071FA94;
  v6[3] = &unk_100997570;
  v6[4] = v1;
  unsigned int v7 = v10;
  dispatch_after(v4, global_queue, v6);
}

void sub_10071FA58(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a20 < 0) {
    operator delete(__p);
  }
  if (*(char *)(v20 - 25) < 0) {
    operator delete(*(void **)(v20 - 48));
  }
  _Unwind_Resume(exception_object);
}

void sub_10071FA94(uint64_t a1)
{
}

void sub_10071FAA4(uint64_t a1, int a2)
{
  uint64_t v3 = *(void *)(a1 + 32);
  dispatch_time_t v4 = qword_100A19E50;
  if (os_log_type_enabled((os_log_t)qword_100A19E50, OS_LOG_TYPE_DEFAULT))
  {
    v5[0] = 67109120;
    v5[1] = a2;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "CountryCode: Callback from GEO..country code available?%d", (uint8_t *)v5, 8u);
  }
  sub_10071FB5C(v3);
}

void sub_10071FB5C(uint64_t a1)
{
  uint64_t v2 = +[GEOCountryConfiguration sharedConfiguration];
  uint64_t v3 = [v2 countryCode];
  dispatch_time_t v4 = +[NSString stringWithFormat:@"%@", v3];

  dispatch_time_t v5 = qword_100A19E50;
  if (os_log_type_enabled((os_log_t)qword_100A19E50, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 138543362;
    uint64_t v15 = v4;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "CountryCode: Callback from GEO, Country: %{public}@", buf, 0xCu);
  }
  if (v4 && ([*(id *)(a1 + 88) isEqualToString:v4] & 1) == 0)
  {
    sub_10071F19C(a1, v4);
  }
  else
  {
    uint64_t v6 = qword_100A19E50;
    if (os_log_type_enabled((os_log_t)qword_100A19E50, OS_LOG_TYPE_DEBUG)) {
      sub_100798E48(v6, v7, v8, v9, v10, v11, v12, v13);
    }
  }
}

void sub_10071FC98(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id sub_10071FCC8(uint64_t a1, void *a2)
{
  uint64_t v3 = +[RDEstimate currentEstimates];
  if (![v3 count])
  {
    uint64_t v7 = qword_100A19E50;
    if (os_log_type_enabled((os_log_t)qword_100A19E50, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v15) = 0;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "RegulatoryDomain current estimates not available", (uint8_t *)&v15, 2u);
    }
    dispatch_time_t v5 = 0;
    goto LABEL_10;
  }
  dispatch_time_t v4 = [v3 objectAtIndex:0];
  dispatch_time_t v5 = [v4 countryCode];
  uint64_t v6 = qword_100A19E50;
  if (os_log_type_enabled((os_log_t)qword_100A19E50, OS_LOG_TYPE_DEFAULT))
  {
    int v15 = 138412546;
    id v16 = v5;
    __int16 v17 = 1024;
    unsigned int v18 = [v5 length];
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "RegulatoryDomain current estimates -- countryCode = %@ countryCode length = %d", (uint8_t *)&v15, 0x12u);
  }

  if (!v5 || [v5 length] != (id)2)
  {
LABEL_10:

    dispatch_time_t v5 = 0;
  }
  *a2 = 0;
  uint64_t v8 = +[RDEstimate lastKnownEstimates];
  if ([v8 count])
  {
    uint64_t v9 = [v8 objectAtIndex:0];
    id v10 = [v9 countryCode];
    uint64_t v11 = qword_100A19E50;
    if (os_log_type_enabled((os_log_t)qword_100A19E50, OS_LOG_TYPE_DEFAULT))
    {
      unsigned int v12 = [v10 length];
      int v15 = 138412546;
      id v16 = v10;
      __int16 v17 = 1024;
      unsigned int v18 = v12;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "RegulatoryDomain last-known estimates -- countryCode = %@ countryCode length = %d", (uint8_t *)&v15, 0x12u);
    }

    if (v10 && [v10 length] == (id)2)
    {
      id v10 = v10;
      *a2 = v10;
    }
  }
  else
  {
    uint64_t v13 = qword_100A19E50;
    if (os_log_type_enabled((os_log_t)qword_100A19E50, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v15) = 0;
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "RegulatoryDomain last-known estimates not available", (uint8_t *)&v15, 2u);
    }
    id v10 = 0;
  }

  return v5;
}

void sub_10071FF64(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_10071FFDC(uint64_t a1, void *a2)
{
  id v3 = a2;
  dispatch_time_t v4 = qword_100A19E50;
  if (os_log_type_enabled((os_log_t)qword_100A19E50, OS_LOG_TYPE_DEFAULT))
  {
    int v5 = 138412290;
    id v6 = v3;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "PurpleLocation::simulateLocationUpdate: country = %@", (uint8_t *)&v5, 0xCu);
  }
  sub_10071F19C(a1, v3);
}

void sub_1007200A0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1007200B8(os_unfair_lock_s *a1, void *a2, char a3, char a4, char a5, char a6, char a7)
{
  v14[0] = _NSConcreteStackBlock;
  v14[1] = 3221225472;
  v14[2] = sub_100720738;
  v14[3] = &unk_1009C0018;
  id v15 = a2;
  char v16 = a3;
  char v17 = a4;
  char v18 = a5;
  char v19 = a6;
  char v20 = a7;
  id v13 = v15;
  sub_10072066C(a1 + 14, v14);
}

void sub_100720188(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13)
{
  _Unwind_Resume(a1);
}

uint64_t sub_1007201A0(uint64_t a1, uint64_t a2, int a3)
{
  int v5 = qword_100A19E50;
  if (os_log_type_enabled((os_log_t)qword_100A19E50, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v6 = *(void *)(a1 + 88);
    int v11 = 138543362;
    uint64_t v12 = v6;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "Gaze: Current country code: %{public}@", (uint8_t *)&v11, 0xCu);
  }
  if (([*(id *)(a1 + 88) isEqualToString:@"CA"] & 1) != 0
    || ([*(id *)(a1 + 88) isEqualToString:@"US"] & 1) != 0
    || a3)
  {
    uint64_t v8 = qword_100A19E50;
    if (os_log_type_enabled((os_log_t)qword_100A19E50, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v11) = 0;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "Setting Gaze State to controller: On head", (uint8_t *)&v11, 2u);
    }
  }
  else
  {
    uint64_t v7 = qword_100A19E50;
    if (os_log_type_enabled((os_log_t)qword_100A19E50, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v11) = 0;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "Setting Gaze State to controller: On body", (uint8_t *)&v11, 2u);
    }
  }
  uint64_t v9 = *(uint64_t (**)(void))(*(void *)sub_10003FB34() + 88);
  return v9();
}

uint64_t sub_100720350(uint64_t a1, uint64_t a2, int a3)
{
  return sub_1007201A0(a1 - 16, 0, a3);
}

void sub_10072035C(uint64_t a1, uint64_t a2)
{
}

void sub_100720364(uint64_t a1, uint64_t a2)
{
}

void sub_10072036C(uint64_t a1, uint64_t a2)
{
  os_unfair_lock_lock((os_unfair_lock_t)a1);
  int v5 = *(char **)(a1 + 8);
  dispatch_time_t v4 = *(char **)(a1 + 16);
  if (v5 != v4)
  {
    while (*(void *)v5 != a2)
    {
      v5 += 8;
      if (v5 == v4)
      {
        int v5 = *(char **)(a1 + 16);
        break;
      }
    }
  }
  if (v5 == v4)
  {
    uint64_t v6 = a2;
    sub_100720CBC(a1 + 8, v4, (char *)&v6);
    sub_100061554(a1 + 8);
  }
  os_unfair_lock_unlock((os_unfair_lock_t)a1);
}

void sub_1007203F8(uint64_t a1, uint64_t a2)
{
}

void sub_100720400(uint64_t a1, uint64_t a2)
{
}

void sub_100720408(uint64_t a1, uint64_t a2)
{
  os_unfair_lock_lock((os_unfair_lock_t)a1);
  int v5 = *(char **)(a1 + 8);
  dispatch_time_t v4 = *(char **)(a1 + 16);
  if (v5 != v4)
  {
    while (*(void *)v5 != a2)
    {
      v5 += 8;
      if (v5 == v4)
      {
        int v5 = *(char **)(a1 + 16);
        break;
      }
    }
  }
  if (v5 == v4)
  {
    uint64_t v6 = a2;
    sub_100720EFC(a1 + 8, v4, (char *)&v6);
    sub_100061554(a1 + 8);
  }
  os_unfair_lock_unlock((os_unfair_lock_t)a1);
}

void sub_100720494(os_unfair_lock_s *a1, void *a2, char a3, char a4, char a5)
{
  v10[0] = _NSConcreteStackBlock;
  v10[1] = 3221225472;
  v10[2] = sub_100720630;
  v10[3] = &unk_1009BFFF0;
  id v11 = a2;
  char v12 = a3;
  char v13 = a4;
  char v14 = a5;
  id v9 = v11;
  sub_100720564(a1 + 6, v10);
}

void sub_10072054C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13)
{
  _Unwind_Resume(a1);
}

void sub_100720564(os_unfair_lock_s *a1, void *a2)
{
  id v3 = a2;
  os_unfair_lock_lock(a1);
  int v5 = 0;
  uint64_t v6 = 0;
  uint64_t v7 = 0;
  sub_100040550(&v5, (uint64_t)&a1[2]);
  os_unfair_lock_unlock(a1);
  dispatch_time_t v4 = v5;
  if (v5 != v6)
  {
    do
      v3[2](v3, *v4++);
    while (v4 != v6);
    dispatch_time_t v4 = v5;
  }
  if (v4)
  {
    uint64_t v6 = v4;
    operator delete(v4);
  }
}

void sub_100720608(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  _Unwind_Resume(a1);
}

uint64_t sub_100720630(uint64_t a1, uint64_t (***a2)(void, void, void, void, void))
{
  return (**a2)(a2, *(void *)(a1 + 32), *(unsigned __int8 *)(a1 + 40), *(unsigned __int8 *)(a1 + 41), *(unsigned __int8 *)(a1 + 42));
}

void sub_10072066C(os_unfair_lock_s *a1, void *a2)
{
  id v3 = a2;
  os_unfair_lock_lock(a1);
  int v5 = 0;
  uint64_t v6 = 0;
  uint64_t v7 = 0;
  sub_100040550(&v5, (uint64_t)&a1[2]);
  os_unfair_lock_unlock(a1);
  dispatch_time_t v4 = v5;
  if (v5 != v6)
  {
    do
      v3[2](v3, *v4++);
    while (v4 != v6);
    dispatch_time_t v4 = v5;
  }
  if (v4)
  {
    uint64_t v6 = v4;
    operator delete(v4);
  }
}

void sub_100720710(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  _Unwind_Resume(a1);
}

uint64_t sub_100720738(uint64_t a1, uint64_t (***a2)(void, void, void, void, void, void, void))
{
  return (**a2)(a2, *(void *)(a1 + 32), *(unsigned __int8 *)(a1 + 40), *(unsigned __int8 *)(a1 + 41), *(unsigned __int8 *)(a1 + 42), *(unsigned __int8 *)(a1 + 43), *(unsigned __int8 *)(a1 + 44));
}

uint64_t sub_10072077C(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 24))();
}

uint64_t sub_1007207A0(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 - 8) + 24))();
}

void sub_1007207DC(uint64_t a1, uint64_t a2)
{
  os_unfair_lock_lock((os_unfair_lock_t)a1);
  dispatch_time_t v4 = *(char **)(a1 + 8);
  int v5 = *(char **)(a1 + 16);
  if (v4 == v5)
  {
    uint64_t v6 = *(char **)(a1 + 8);
    goto LABEL_10;
  }
  uint64_t v6 = *(char **)(a1 + 8);
  while (*(void *)v6 != a2)
  {
    v6 += 8;
    if (v6 == v5)
    {
      uint64_t v6 = *(char **)(a1 + 16);
      break;
    }
  }
  if (v6 == v5)
  {
    if (v4 != v5)
    {
LABEL_11:
      uint64_t v7 = a2;
      sub_1007208AC(a1 + 8, v6, (char *)&v7);
      sub_100061554(a1 + 8);
      goto LABEL_12;
    }
LABEL_10:
    (***(void (****)(void, uint64_t))(a1 + 32))(*(void *)(a1 + 32), a1);
    goto LABEL_11;
  }
LABEL_12:
  os_unfair_lock_unlock((os_unfair_lock_t)a1);
}

char *sub_1007208AC(uint64_t a1, char *__src, char *a3)
{
  id v3 = a3;
  dispatch_time_t v4 = __src;
  uint64_t v6 = *(char **)(a1 + 8);
  uint64_t v8 = a1 + 16;
  unint64_t v7 = *(void *)(a1 + 16);
  if ((unint64_t)v6 >= v7)
  {
    char v13 = *(char **)a1;
    unint64_t v14 = ((uint64_t)&v6[-*(void *)a1] >> 3) + 1;
    if (v14 >> 61) {
      abort();
    }
    uint64_t v15 = __src - v13;
    uint64_t v16 = (__src - v13) >> 3;
    uint64_t v17 = v7 - (void)v13;
    if (v17 >> 2 > v14) {
      unint64_t v14 = v17 >> 2;
    }
    if ((unint64_t)v17 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v18 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v18 = v14;
    }
    uint64_t v30 = a1 + 16;
    if (v18) {
      char v19 = (char *)sub_1000405F8(a1 + 16, v18);
    }
    else {
      char v19 = 0;
    }
    char v20 = &v19[8 * v16];
    std::string __p = v19;
    __int16 v27 = v20;
    unsigned __int8 v28 = v20;
    std::string v29 = &v19[8 * v18];
    if (v16 == v18)
    {
      if (v15 < 1)
      {
        if (v13 == v4) {
          unint64_t v22 = 1;
        }
        else {
          unint64_t v22 = v15 >> 2;
        }
        uint64_t v23 = (char *)sub_1000405F8(v8, v22);
        char v20 = &v23[8 * (v22 >> 2)];
        std::string __p = v23;
        __int16 v27 = v20;
        std::string v29 = &v23[8 * v24];
        if (v19) {
          operator delete(v19);
        }
      }
      else
      {
        unint64_t v21 = v16 + 2;
        if (v16 >= -1) {
          unint64_t v21 = v16 + 1;
        }
        v20 -= 8 * (v21 >> 1);
        __int16 v27 = v20;
      }
    }
    *(void *)char v20 = *(void *)v3;
    unsigned __int8 v28 = v20 + 8;
    dispatch_time_t v4 = sub_100061614((void **)a1, (uint64_t)&__p, v4);
    if (v28 != v27) {
      v28 += (v27 - v28 + 7) & 0xFFFFFFFFFFFFFFF8;
    }
    if (__p) {
      operator delete(__p);
    }
  }
  else if (__src == v6)
  {
    *(void *)__src = *(void *)a3;
    *(void *)(a1 + 8) = __src + 8;
  }
  else
  {
    id v9 = __src + 8;
    id v10 = v6 - 8;
    id v11 = *(void **)(a1 + 8);
    while (v10 < v6)
    {
      uint64_t v12 = *(void *)v10;
      v10 += 8;
      *v11++ = v12;
    }
    *(void *)(a1 + 8) = v11;
    if (v6 != v9) {
      memmove(&v6[-8 * ((v6 - v9) >> 3)], __src, v6 - v9);
    }
    if (v4 <= v3) {
      v3 += 8 * (*(void *)(a1 + 8) > (unint64_t)v3);
    }
    *(void *)dispatch_time_t v4 = *(void *)v3;
  }
  return v4;
}

void sub_100720AB4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100720AEC(id a1)
{
  uint64_t v1 = qword_100A19E50;
  if (os_log_type_enabled((os_log_t)qword_100A19E50, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)id v3 = 0;
    _os_log_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_DEFAULT, "Received RegulatoryDomain country code update notification", v3, 2u);
  }
  uint64_t v2 = sub_100373254();
  (*(void (**)(uint64_t))(*(void *)v2 + 24))(v2);
}

void sub_100720B7C(uint64_t a1, uint64_t a2)
{
  os_unfair_lock_lock((os_unfair_lock_t)a1);
  int v5 = *(char **)(a1 + 8);
  dispatch_time_t v4 = *(char **)(a1 + 16);
  if (v5 != v4)
  {
    while (*(void *)v5 != a2)
    {
      v5 += 8;
      if (v5 == v4)
      {
        int v5 = *(char **)(a1 + 16);
        break;
      }
    }
  }
  if (v5 != v4)
  {
    int64_t v6 = v4 - (v5 + 8);
    if (v4 != v5 + 8) {
      memmove(v5, v5 + 8, v4 - (v5 + 8));
    }
    *(void *)(a1 + 16) = &v5[v6];
    sub_100061554(a1 + 8);
    if (*(void *)(a1 + 8) == *(void *)(a1 + 16)) {
      (*(void (**)(void, uint64_t))(**(void **)(a1 + 32) + 8))(*(void *)(a1 + 32), a1);
    }
  }

  os_unfair_lock_unlock((os_unfair_lock_t)a1);
}

void sub_100720C54(id a1)
{
}

void sub_100720C98()
{
}

char *sub_100720CBC(uint64_t a1, char *__src, char *a3)
{
  id v3 = a3;
  dispatch_time_t v4 = __src;
  int64_t v6 = *(char **)(a1 + 8);
  uint64_t v8 = a1 + 16;
  unint64_t v7 = *(void *)(a1 + 16);
  if ((unint64_t)v6 >= v7)
  {
    char v13 = *(char **)a1;
    unint64_t v14 = ((uint64_t)&v6[-*(void *)a1] >> 3) + 1;
    if (v14 >> 61) {
      abort();
    }
    uint64_t v15 = __src - v13;
    uint64_t v16 = (__src - v13) >> 3;
    uint64_t v17 = v7 - (void)v13;
    if (v17 >> 2 > v14) {
      unint64_t v14 = v17 >> 2;
    }
    if ((unint64_t)v17 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v18 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v18 = v14;
    }
    uint64_t v30 = a1 + 16;
    if (v18) {
      char v19 = (char *)sub_1000405F8(a1 + 16, v18);
    }
    else {
      char v19 = 0;
    }
    char v20 = &v19[8 * v16];
    std::string __p = v19;
    __int16 v27 = v20;
    unsigned __int8 v28 = v20;
    std::string v29 = &v19[8 * v18];
    if (v16 == v18)
    {
      if (v15 < 1)
      {
        if (v13 == v4) {
          unint64_t v22 = 1;
        }
        else {
          unint64_t v22 = v15 >> 2;
        }
        uint64_t v23 = (char *)sub_1000405F8(v8, v22);
        char v20 = &v23[8 * (v22 >> 2)];
        std::string __p = v23;
        __int16 v27 = v20;
        std::string v29 = &v23[8 * v24];
        if (v19) {
          operator delete(v19);
        }
      }
      else
      {
        unint64_t v21 = v16 + 2;
        if (v16 >= -1) {
          unint64_t v21 = v16 + 1;
        }
        v20 -= 8 * (v21 >> 1);
        __int16 v27 = v20;
      }
    }
    *(void *)char v20 = *(void *)v3;
    unsigned __int8 v28 = v20 + 8;
    dispatch_time_t v4 = sub_100061614((void **)a1, (uint64_t)&__p, v4);
    if (v28 != v27) {
      v28 += (v27 - v28 + 7) & 0xFFFFFFFFFFFFFFF8;
    }
    if (__p) {
      operator delete(__p);
    }
  }
  else if (__src == v6)
  {
    *(void *)__src = *(void *)a3;
    *(void *)(a1 + 8) = __src + 8;
  }
  else
  {
    id v9 = __src + 8;
    id v10 = v6 - 8;
    id v11 = *(void **)(a1 + 8);
    while (v10 < v6)
    {
      uint64_t v12 = *(void *)v10;
      v10 += 8;
      *v11++ = v12;
    }
    *(void *)(a1 + 8) = v11;
    if (v6 != v9) {
      memmove(&v6[-8 * ((v6 - v9) >> 3)], __src, v6 - v9);
    }
    if (v4 <= v3) {
      v3 += 8 * (*(void *)(a1 + 8) > (unint64_t)v3);
    }
    *(void *)dispatch_time_t v4 = *(void *)v3;
  }
  return v4;
}

void sub_100720EC4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

char *sub_100720EFC(uint64_t a1, char *__src, char *a3)
{
  id v3 = a3;
  dispatch_time_t v4 = __src;
  int64_t v6 = *(char **)(a1 + 8);
  uint64_t v8 = a1 + 16;
  unint64_t v7 = *(void *)(a1 + 16);
  if ((unint64_t)v6 >= v7)
  {
    char v13 = *(char **)a1;
    unint64_t v14 = ((uint64_t)&v6[-*(void *)a1] >> 3) + 1;
    if (v14 >> 61) {
      abort();
    }
    uint64_t v15 = __src - v13;
    uint64_t v16 = (__src - v13) >> 3;
    uint64_t v17 = v7 - (void)v13;
    if (v17 >> 2 > v14) {
      unint64_t v14 = v17 >> 2;
    }
    if ((unint64_t)v17 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v18 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v18 = v14;
    }
    uint64_t v30 = a1 + 16;
    if (v18) {
      char v19 = (char *)sub_1000405F8(a1 + 16, v18);
    }
    else {
      char v19 = 0;
    }
    char v20 = &v19[8 * v16];
    std::string __p = v19;
    __int16 v27 = v20;
    unsigned __int8 v28 = v20;
    std::string v29 = &v19[8 * v18];
    if (v16 == v18)
    {
      if (v15 < 1)
      {
        if (v13 == v4) {
          unint64_t v22 = 1;
        }
        else {
          unint64_t v22 = v15 >> 2;
        }
        uint64_t v23 = (char *)sub_1000405F8(v8, v22);
        char v20 = &v23[8 * (v22 >> 2)];
        std::string __p = v23;
        __int16 v27 = v20;
        std::string v29 = &v23[8 * v24];
        if (v19) {
          operator delete(v19);
        }
      }
      else
      {
        unint64_t v21 = v16 + 2;
        if (v16 >= -1) {
          unint64_t v21 = v16 + 1;
        }
        v20 -= 8 * (v21 >> 1);
        __int16 v27 = v20;
      }
    }
    *(void *)char v20 = *(void *)v3;
    unsigned __int8 v28 = v20 + 8;
    dispatch_time_t v4 = sub_100061614((void **)a1, (uint64_t)&__p, v4);
    if (v28 != v27) {
      v28 += (v27 - v28 + 7) & 0xFFFFFFFFFFFFFFF8;
    }
    if (__p) {
      operator delete(__p);
    }
  }
  else if (__src == v6)
  {
    *(void *)__src = *(void *)a3;
    *(void *)(a1 + 8) = __src + 8;
  }
  else
  {
    id v9 = __src + 8;
    id v10 = v6 - 8;
    id v11 = *(void **)(a1 + 8);
    while (v10 < v6)
    {
      uint64_t v12 = *(void *)v10;
      v10 += 8;
      *v11++ = v12;
    }
    *(void *)(a1 + 8) = v11;
    if (v6 != v9) {
      memmove(&v6[-8 * ((v6 - v9) >> 3)], __src, v6 - v9);
    }
    if (v4 <= v3) {
      v3 += 8 * (*(void *)(a1 + 8) > (unint64_t)v3);
    }
    *(void *)dispatch_time_t v4 = *(void *)v3;
  }
  return v4;
}

void sub_100721104(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_10072113C(uint64_t a1)
{
  uint64_t v1 = sub_100283C88(a1, 23);
  sub_10033F690(v1 + 256, 0, 1, 1007);
}

void sub_1007211B8(_Unwind_Exception *a1)
{
  sub_100283DC8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1007211D0(uint64_t a1)
{
  sub_10033F7C4(a1 + 256);

  return sub_100283DC8(a1);
}

uint64_t sub_10072120C(uint64_t a1)
{
  uint64_t v1 = a1 - 256;
  sub_10033F7C4(a1);

  return sub_100283DC8(v1);
}

void sub_100721244(uint64_t a1)
{
  sub_10033F7C4(a1 + 256);
  sub_100283DC8(a1);

  operator delete();
}

void sub_100721294(uint64_t a1)
{
}

uint64_t sub_10072129C(uint64_t a1)
{
  long long v8 = 0u;
  long long v9 = 0u;
  long long v6 = 0u;
  long long v7 = 0u;
  uint64_t v2 = (unsigned char *)(a1 + 504);
  *(unsigned char *)(a1 + 504) = 3;
  char v5 = 0;
  sub_10001B8E0(&v5);
  if (sub_100245A8C((uint64_t)sub_100721450, (uint64_t)off_1009C01F0, 0x3EFu, 0x3B01u, v2, (uint64_t)&unk_1009C0218))
  {
    if (os_log_type_enabled((os_log_t)qword_100A19E40, OS_LOG_TYPE_ERROR)) {
      sub_100798F50();
    }
LABEL_10:
    uint64_t v3 = 1;
    goto LABEL_11;
  }
  *(void *)&long long v8 = &unk_1009C0248;
  WORD4(v8) = 3;
  *(void *)&long long v9 = &unk_1009C01C0;
  WORD4(v9) = 1;
  *(void *)&long long v6 = &unk_1009C0290;
  WORD4(v6) = 3;
  *(void *)&long long v7 = &unk_1009C01D8;
  WORD4(v7) = 1;
  byte_100A147B0 = 1;
  word_100A147B2 = 1;
  dword_100A147B8 = *(unsigned __int8 *)(a1 + 504);
  if (sub_10024E258((uint64_t)&v8, (int *)(a1 + 496)))
  {
    if (os_log_type_enabled((os_log_t)qword_100A19E40, OS_LOG_TYPE_ERROR)) {
      sub_100798EE8();
    }
    goto LABEL_10;
  }
  uint64_t v3 = sub_10024E258((uint64_t)&v6, (int *)(a1 + 500));
  if (v3)
  {
    if (os_log_type_enabled((os_log_t)qword_100A19E40, OS_LOG_TYPE_ERROR)) {
      sub_100798E80();
    }
    goto LABEL_10;
  }
LABEL_11:
  sub_10001B8AC(&v5);
  return v3;
}

void sub_10072143C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, int a10, __int16 a11, char a12, char a13)
{
}

void sub_100721450(uint64_t a1, uint64_t a2, uint64_t a3, unsigned int a4)
{
  if (qword_1009FBE50 != -1) {
    dispatch_once(&qword_1009FBE50, &stru_1009C02F8);
  }
  long long v6 = off_1009FBE48;

  sub_100721A18(v6, a1, a4);
}

uint64_t sub_1007214BC(uint64_t a1)
{
  char v12 = 0;
  sub_10001B8E0(&v12);
  sub_10024E448(*(_DWORD *)(a1 + 496));
  sub_10024E448(*(_DWORD *)(a1 + 500));
  if (sub_100245D68(*(unsigned __int8 *)(a1 + 504)) == 101)
  {
    uint64_t v2 = qword_100A19E40;
    if (os_log_type_enabled((os_log_t)qword_100A19E40, OS_LOG_TYPE_ERROR)) {
      sub_1007882C8(v2, v3, v4, v5, v6, v7, v8, v9);
    }
    uint64_t v10 = 1;
  }
  else
  {
    uint64_t v10 = 0;
  }
  sub_10001B8AC(&v12);
  return v10;
}

void sub_100721550(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, int a10, __int16 a11, char a12, char a13)
{
}

uint64_t sub_100721568(uint64_t a1)
{
  return 0;
}

uint64_t sub_100721588(uint64_t a1, unint64_t a2)
{
  if (a2)
  {
    long long v21 = unk_1009C02E8;
    long long v22 = unk_1009C02D8;
    unint64_t v18 = 0;
    char v19 = 0;
    uint64_t v20 = 0;
    int v4 = sub_10047AE08(a2, (uint64_t)&v21, 4u, &v18);
    if ((v4 & 1) != 0 || sub_10047AE08(a2, (uint64_t)&v22, 4u, &v18))
    {
      uint64_t v6 = v18;
      uint64_t v5 = v19;
      if (v18 != v19)
      {
        uint64_t v7 = v18;
        while (1)
        {
          if (*(unsigned char *)v7 == 6 && *((_WORD *)v7 + 1) == 2)
          {
            uint64_t v9 = v7[1];
            BOOL v10 = *(unsigned char *)v9 == 3 && *(_DWORD *)(v9 + 8) == 3;
            if (v10 && *(unsigned char *)(v9 + 16) == 1) {
              break;
            }
          }
          v7 += 2;
          if (v7 == (void *)v19)
          {
            int v11 = -1;
            goto LABEL_26;
          }
        }
        int v11 = *(_DWORD *)(v9 + 24);
LABEL_26:
        while (v6 != v5)
        {
          *(_OWORD *)long long buf = *v6;
          sub_1002D5394(buf);
          ++v6;
          uint64_t v5 = v19;
        }
        if (v11 != -1)
        {
          unint64_t v14 = qword_100A19E40;
          if (os_log_type_enabled((os_log_t)qword_100A19E40, OS_LOG_TYPE_INFO))
          {
            sub_100474E18(a2, __p);
            if (v24 >= 0) {
              uint64_t v15 = __p;
            }
            else {
              uint64_t v15 = (void **)__p[0];
            }
            uint64_t v16 = "Old WiAP UUID";
            *(_DWORD *)long long buf = 136446722;
            if (v4) {
              uint64_t v16 = "New WiAP UUID";
            }
            *(void *)&uint8_t buf[4] = v15;
            *(_WORD *)&unsigned char buf[12] = 1024;
            *(_DWORD *)&buf[14] = v11;
            __int16 v26 = 2082;
            __int16 v27 = v16;
            _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_INFO, "Initiating outgoing Wireless IAP connection request to device %{public}s on rfcomm channel %d,  %{public}s", buf, 0x1Cu);
            if (v24 < 0) {
              operator delete(__p[0]);
            }
          }
          LOBYTE(__p[0]) = 0;
          sub_10001B8E0(__p);
          *(_WORD *)long long buf = 0;
          if (sub_1002460C8((uint64_t)sub_100721910, off_1009C01F0, a2 + 128, v11, 0x3EFu, 0x3B01u, buf, (uint64_t)&unk_1009C0218))
          {
            if (os_log_type_enabled((os_log_t)qword_100A19E40, OS_LOG_TYPE_ERROR)) {
              sub_100799020();
            }
            uint64_t v12 = 305;
          }
          else
          {
            sub_1004BE028(a1, a2, *(__int16 *)buf);
            uint64_t v12 = 0;
          }
          sub_10001B8AC(__p);
          goto LABEL_45;
        }
      }
      if (os_log_type_enabled((os_log_t)qword_100A19E40, OS_LOG_TYPE_ERROR)) {
        sub_100798FEC();
      }
    }
    else
    {
      char v13 = qword_100A19E40;
      if (os_log_type_enabled((os_log_t)qword_100A19E40, OS_LOG_TYPE_ERROR))
      {
        sub_100474E18(a2, buf);
        sub_10078840C(buf, (uint8_t *)__p, v13);
      }
    }
    uint64_t v12 = 305;
LABEL_45:
    if (v18)
    {
      char v19 = v18;
      operator delete(v18);
    }
    return v12;
  }
  if (os_log_type_enabled((os_log_t)qword_100A19E40, OS_LOG_TYPE_ERROR)) {
    sub_100798FB8();
  }
  return 1;
}

void sub_1007218CC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100721910(int a1, uint64_t a2, uint64_t a3)
{
  if (qword_1009FBE50 != -1) {
    dispatch_once(&qword_1009FBE50, &stru_1009C02F8);
  }
  uint64_t v5 = off_1009FBE48;

  sub_100721C40(v5, a1, a3);
}

uint64_t sub_10072197C(void *a1, unint64_t a2)
{
  unsigned int v2 = sub_1004BE120(a1, a2);
  char v5 = 0;
  sub_10001B8E0(&v5);
  uint64_t v3 = sub_100246730(v2, 1818);
  if (v3)
  {
    if (os_log_type_enabled((os_log_t)qword_100A19E40, OS_LOG_TYPE_ERROR)) {
      sub_1007787CC();
    }
    uint64_t v3 = 1;
  }
  sub_10001B8AC(&v5);
  return v3;
}

void sub_100721A04(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, int a10, __int16 a11, char a12, char a13)
{
}

void sub_100721A18(void *a1, uint64_t a2, unsigned int a3)
{
  if (qword_1009F7F00 != -1) {
    dispatch_once(&qword_1009F7F00, &stru_1009C0388);
  }
  LODWORD(__p[0]) = *(_DWORD *)a2;
  WORD2(__p[0]) = *(_WORD *)(a2 + 4);
  uint64_t v6 = sub_1004AA194((uint64_t)off_1009F7EF8, (uint64_t)__p, 1);
  uint64_t v7 = qword_100A19E40;
  if (os_log_type_enabled((os_log_t)qword_100A19E40, OS_LOG_TYPE_DEFAULT))
  {
    sub_100474E18(v6, __p);
    uint64_t v8 = v16 >= 0 ? __p : (void **)__p[0];
    *(_DWORD *)long long buf = 136446210;
    unint64_t v18 = v8;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "Received incoming connection attempt from device %{public}s", buf, 0xCu);
    if (v16 < 0) {
      operator delete(__p[0]);
    }
  }
  int v9 = sub_1004BDDAC((uint64_t)a1, v6);
  if (v9)
  {
    int v10 = sub_1002463C0((uint64_t)sub_100721910, a3, v9);
    char v11 = v9 ^ 1;
    if (v10) {
      char v11 = 1;
    }
    if ((v11 & 1) == 0)
    {
      sub_1004BE028((uint64_t)a1, v6, a3);
      sub_1004BD554(a1, v6);
    }
  }
  else
  {
    uint64_t v12 = qword_100A19E40;
    if (os_log_type_enabled((os_log_t)qword_100A19E40, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(__p[0]) = 0;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "Denying connection attempt", (uint8_t *)__p, 2u);
    }
    int v10 = sub_1002463C0((uint64_t)sub_100721910, a3, v9);
  }
  int v13 = v10;
  if (v10)
  {
    unint64_t v14 = qword_100A19E40;
    if (os_log_type_enabled((os_log_t)qword_100A19E40, OS_LOG_TYPE_ERROR)) {
      sub_100788480(v9, v13, v14);
    }
  }
}

void sub_100721C40(void *a1, int a2, uint64_t a3)
{
  uint64_t v5 = sub_1004BE238(a1, a2);
  if (v5)
  {
    uint64_t v6 = v5;
    if (a3)
    {
      uint64_t v7 = qword_100A19E40;
      if (os_log_type_enabled((os_log_t)qword_100A19E40, OS_LOG_TYPE_ERROR))
      {
        sub_100474E18(v6, __p);
        int v9 = v11 >= 0 ? __p : (void **)__p[0];
        *(_DWORD *)long long buf = 136446466;
        int v13 = v9;
        __int16 v14 = 1024;
        int v15 = a3;
        _os_log_error_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, "Connection to device %{public}s failed - result was %{bluetooth:OI_STATUS}u", buf, 0x12u);
        if (v11 < 0) {
          operator delete(__p[0]);
        }
      }
      if (qword_1009F8070 != -1) {
        dispatch_once(&qword_1009F8070, &stru_1009C03A8);
      }
      int v8 = sub_1004E2340((uint64_t)off_1009F8068, a3, 20000);
      sub_1004BD6C8((uint64_t)a1, v6, v8);
    }
    sub_1004BD6C8((uint64_t)a1, v5, 0);
  }
  if (os_log_type_enabled((os_log_t)qword_100A19E40, OS_LOG_TYPE_ERROR)) {
    sub_100799088();
  }
}

void sub_100721E60(void *a1, int a2, uint64_t a3, int a4)
{
  unint64_t v7 = sub_1004BE238(a1, a2);
  if (v7)
  {
    sub_10034051C((uint64_t)(a1 + 32), v7, a3, a4, 0);
  }
  else if (os_log_type_enabled((os_log_t)qword_100A19E40, OS_LOG_TYPE_ERROR))
  {
    sub_100799174();
  }
}

void sub_100721EF4(void *a1, int a2)
{
  unint64_t v3 = sub_1004BE238(a1, a2);
  if (v3)
  {
    sub_100340738((uint64_t)(a1 + 32), v3);
  }
  else if (os_log_type_enabled((os_log_t)qword_100A19E40, OS_LOG_TYPE_ERROR))
  {
    sub_1007991A8();
  }
}

BOOL sub_100721F68(void *a1, unint64_t a2, char *a3, unsigned __int16 a4)
{
  unsigned int v6 = sub_1004BE120(a1, a2);
  char v9 = 0;
  sub_10001B8E0(&v9);
  int v7 = sub_1002460BC((uint64_t)sub_100722034, v6, a3, a4);
  sub_10001B910(&v9);
  if (v7 && os_log_type_enabled((os_log_t)qword_100A19E40, OS_LOG_TYPE_ERROR)) {
    sub_1007991DC();
  }
  sub_10001B8AC(&v9);
  return v7 == 0;
}

void sub_100722020(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, int a10, __int16 a11, char a12, char a13)
{
}

void sub_100722034(int a1, uint64_t a2, uint64_t a3, int a4)
{
  if (a4 && os_log_type_enabled((os_log_t)qword_100A19E40, OS_LOG_TYPE_ERROR)) {
    sub_100799244();
  }
  if (qword_1009FBE50 != -1) {
    dispatch_once(&qword_1009FBE50, &stru_1009C02F8);
  }
  sub_100721EF4(off_1009FBE48, a1);
}

BOOL sub_1007220C8(uint64_t a1, unint64_t a2, char *a3, unsigned __int16 a4)
{
  return sub_100721F68((void *)(a1 - 256), a2, a3, a4);
}

uint64_t sub_1007220D0()
{
  return 3;
}

void sub_1007220D8(int a1)
{
  if (qword_1009FBE50 != -1) {
    dispatch_once(&qword_1009FBE50, &stru_1009C02F8);
  }
  unsigned int v2 = off_1009FBE48;

  sub_100463EFC(v2, a1);
}

void sub_100722144(int a1, uint64_t a2, int a3)
{
  if (qword_1009FBE50 != -1) {
    dispatch_once(&qword_1009FBE50, &stru_1009C02F8);
  }
  unsigned int v6 = off_1009FBE48;

  sub_100721E60(v6, a1, a2, a3);
}

void sub_1007221C0(id a1)
{
}

void sub_100722204()
{
}

void sub_100722228(id a1)
{
}

void sub_10072226C()
{
}

void sub_100722290(id a1)
{
}

void sub_1007222D4()
{
}

void sub_10072239C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100722430(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, objc_super a9)
{
  a9.super_class = (Class)UserNotification;
  [(_Unwind_Exception *)&a9 dealloc];
  _Unwind_Resume(a1);
}

void sub_10072271C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1007227C8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_10072284C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, objc_super a9)
{
  int v10 = v9;

  a9.super_class = (Class)UninstallObserver;
  [(_Unwind_Exception *)&a9 dealloc];
  _Unwind_Resume(a1);
}

void sub_1007228E8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_100722960(id a1)
{
  uint64_t v1 = objc_opt_new();
  unsigned int v2 = (void *)qword_100A147C0;
  qword_100A147C0 = v1;
}

void sub_100722B38(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100722B50(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (objc_msgSend(@"bluetooth-central", "isEqualToString:"))
  {
    [*(id *)(a1 + 32) setSupportsBackgroundedCentrals:1];
  }
  else if ([@"bluetooth-peripheral" isEqualToString:v3])
  {
    [*(id *)(a1 + 32) setSupportsBackgroundedPeripherals:1];
  }
}

void sub_100722BD8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_100722CB8(void *a1)
{
  id v2 = [*(id *)(a1[4] + 40) objectForKey:a1[5]];
  *(_DWORD *)(*(void *)(a1[6] + 8) + 24) = [v2 pid];
}

void sub_100722D18(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_100722DC0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100722EC0(id *a1)
{
  id v2 = [*((id *)a1[4] + 5) objectForKey:a1[5]];
  id v3 = v2;
  if (v2)
  {
    if ([v2 isApp])
    {
      int v4 = +[NSMutableDictionary dictionary];
      if ([a1[6] count]) {
        [v4 setObject:a1[6] forKey:@"UIApplicationLaunchOptionsBluetoothCentralsKey"];
      }
      if ([a1[7] count]) {
        [v4 setObject:a1[7] forKey:@"UIApplicationLaunchOptionsBluetoothPeripheralsKey"];
      }
      v20[0] = BKSOpenApplicationOptionKeyActivateSuspended;
      v20[1] = BKSOpenApplicationOptionKeyPayloadOptions;
      v21[0] = &__kCFBooleanTrue;
      v21[1] = v4;
      uint64_t v5 = +[NSDictionary dictionaryWithObjects:v21 forKeys:v20 count:2];
      unsigned int v6 = qword_100A19F58;
      if (os_log_type_enabled((os_log_t)qword_100A19F58, OS_LOG_TYPE_DEFAULT))
      {
        unsigned int v7 = [v3 isAlive];
        id v8 = a1[5];
        unsigned int v9 = [v3 pid];
        int v10 = "false";
        *(_DWORD *)int v15 = 136315650;
        if (v7) {
          int v10 = "true";
        }
        *(void *)&void v15[4] = v10;
        __int16 v16 = 2112;
        id v17 = v8;
        __int16 v18 = 1024;
        unsigned int v19 = v9;
        _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "launchApplication:{isAlive: %s, bundleId: \"%@\", pid: %d}", v15, 0x1Cu);
      }
      if objc_msgSend(v3, "pid", *(void *)v15) && (objc_msgSend(v3, "isAlive"))
      {
        char v11 = qword_100A19F58;
        if (os_log_type_enabled((os_log_t)qword_100A19F58, OS_LOG_TYPE_DEFAULT))
        {
          id v12 = a1[5];
          *(_DWORD *)int v15 = 138543362;
          *(void *)&void v15[4] = v12;
          _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "Application pending termination, delaying resurrection - %{public}@", v15, 0xCu);
        }
        [*((id *)a1[4] + 14) setObject:v5 forKey:a1[5]];
      }
      else
      {
        [a1[4] openBundle:a1[5] options:v5];
      }
    }
    else
    {
      int v13 = qword_100A19F58;
      if (os_log_type_enabled((os_log_t)qword_100A19F58, OS_LOG_TYPE_DEFAULT))
      {
        id v14 = a1[5];
        *(_DWORD *)int v15 = 138543362;
        *(void *)&void v15[4] = v14;
        _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "Application %{public}@ is a daemon (not supported).", v15, 0xCu);
      }
    }
  }
  else if (os_log_type_enabled((os_log_t)qword_100A19E50, OS_LOG_TYPE_ERROR))
  {
    sub_100799338((uint64_t)[a1[5] UTF8String], (uint64_t)v15);
  }
}

void sub_1007231A4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100723444(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, void *a15)
{
  _Unwind_Resume(a1);
}

void sub_100723498(uint64_t a1)
{
  if (qword_1009F8788 != -1) {
    dispatch_once(&qword_1009F8788, &stru_1009C07B8);
  }
  id v2 = off_1009F8780;
  id v3 = *(void **)(a1 + 32);

  sub_100303FF8((uint64_t)v2, v3);
}

void sub_1007234FC(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  if (v6)
  {
    unsigned int v7 = qword_100A19F58;
    if (os_log_type_enabled((os_log_t)qword_100A19F58, OS_LOG_TYPE_ERROR)) {
      sub_100799490(a1, (uint64_t)v6, v7);
    }
    dispatch_time_t v8 = *(void *)(a1 + 56);
    uint64_t v9 = *(void *)(a1 + 40);
    int v10 = *(NSObject **)(v9 + 16);
    v19[0] = _NSConcreteStackBlock;
    v19[1] = 3221225472;
    void v19[2] = sub_100723770;
    v19[3] = &unk_1009C0438;
    v19[4] = v9;
    id v20 = *(id *)(a1 + 32);
    id v21 = *(id *)(a1 + 48);
    int v22 = *(_DWORD *)(a1 + 64);
    dispatch_after(v8, v10, v19);
  }
  else
  {
    unsigned int v11 = [v5 isValid];
    id v12 = qword_100A19F58;
    if (v11)
    {
      if (os_log_type_enabled((os_log_t)qword_100A19F58, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v13 = *(void *)(a1 + 32);
        *(_DWORD *)long long buf = 138543618;
        uint64_t v24 = v13;
        __int16 v25 = 1026;
        unsigned int v26 = [v5 pid];
        _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "Resurrected: %{public}@, pid: %{public}u", buf, 0x12u);
      }
      id v14 = (uint64_t *)(a1 + 32);
      int v15 = [*(id *)(*(void *)(a1 + 40) + 40) objectForKeyedSubscript:*(void *)(a1 + 32)];
      if (v15)
      {
        [v15 setPid:[v5 pid]];
        [*(id *)(a1 + 40) takeAssertionForProcess:*(void *)(a1 + 32) duration:10 isUrgent:0];
      }
      else
      {
        id v17 = qword_100A19F58;
        if (os_log_type_enabled((os_log_t)qword_100A19F58, OS_LOG_TYPE_ERROR)) {
          sub_1007993A8(v14, v17, v18);
        }
      }
    }
    else if (os_log_type_enabled((os_log_t)qword_100A19F58, OS_LOG_TYPE_ERROR))
    {
      sub_10079941C(a1, v12, v16);
    }
  }
}

void sub_100723744(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id sub_100723770(uint64_t a1)
{
  return [*(id *)(a1 + 32) openBundle:*(void *)(a1 + 40) options:*(void *)(a1 + 48) attempt:(*(_DWORD *)(a1 + 56) + 1)];
}

void sub_100723820(uint64_t a1)
{
  long long v15 = 0u;
  long long v16 = 0u;
  long long v17 = 0u;
  long long v18 = 0u;
  obuint64_t j = *(id *)(a1 + 32);
  id v2 = [obj countByEnumeratingWithState:&v15 objects:v25 count:16];
  if (v2)
  {
    uint64_t v3 = *(void *)v16;
    do
    {
      for (uint64_t i = 0; i != v2; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v16 != v3) {
          objc_enumerationMutation(obj);
        }
        id v5 = *(void **)(*((void *)&v15 + 1) + 8 * i);
        id v6 = [v5 applicationIdentifier];
        unsigned int v7 = [*(id *)(*(void *)(a1 + 40) + 40) objectForKey:v6];
        dispatch_time_t v8 = qword_100A19F58;
        if (os_log_type_enabled((os_log_t)qword_100A19F58, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v9 = *(void *)(*(void *)(a1 + 40) + 40);
          *(_DWORD *)long long buf = 138543874;
          id v20 = v6;
          __int16 v21 = 2112;
          int v22 = v7;
          __int16 v23 = 2112;
          uint64_t v24 = v9;
          _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "%{public}@ %@ %@", buf, 0x20u);
        }
        int v10 = qword_100A19F58;
        BOOL v11 = os_log_type_enabled((os_log_t)qword_100A19F58, OS_LOG_TYPE_DEFAULT);
        if (v7)
        {
          if (v11)
          {
            *(_DWORD *)long long buf = 138543362;
            id v20 = v6;
            _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "Application %{public}@ has been uninstalled!", buf, 0xCu);
          }
          uint64_t v12 = *(void *)(a1 + 40);
          if (*(void *)(v12 + 8))
          {
            block[0] = _NSConcreteStackBlock;
            block[1] = 3221225472;
            block[2] = sub_100723AF8;
            block[3] = &unk_100998510;
            block[4] = v12;
            void block[5] = v5;
            dispatch_async((dispatch_queue_t)&_dispatch_main_q, block);
          }
        }
        else if (v11)
        {
          *(_DWORD *)long long buf = 138543362;
          id v20 = v6;
          _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "Unable To Uninstall %{public}@, AppInfo Not Found", buf, 0xCu);
        }
      }
      id v2 = [obj countByEnumeratingWithState:&v15 objects:v25 count:16];
    }
    while (v2);
  }
}

void sub_100723AC4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *a16)
{
  _Unwind_Resume(a1);
}

void sub_100723AF8(uint64_t a1)
{
  uint64_t v1 = *(void *)(*(void *)(a1 + 32) + 8);
  id v2 = [*(id *)(a1 + 40) applicationIdentifier];
  sub_10004191C(__p, (char *)[v2 UTF8String]);
  (*(void (**)(uint64_t, void **, uint64_t))(*(void *)v1 + 16))(v1, __p, 2);
  if (v4 < 0) {
    operator delete(__p[0]);
  }
}

void sub_100723B88(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

id sub_100723C28(uint64_t a1)
{
  return [*(id *)(*(void *)(a1 + 32) + 48) applicationInfoForPID:*(unsigned int *)(a1 + 40) completion:&stru_1009C0480];
}

void sub_100723C44(id a1, NSDictionary *a2)
{
  uint64_t v3 = a2;
  id v2 = +[BTAppInteraction instance];
  [v2 applicationStateChanged:v3];
}

void sub_100723CA4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_100723D5C(uint64_t a1)
{
  id v2 = [*(id *)(*(void *)(a1 + 32) + 40) objectForKey:*(void *)(a1 + 40)];
  uint64_t v3 = v2;
  if (v2)
  {
    [v2 setIsApp:1];
    [v3 setSupportsBackgroundedCentrals:1];
  }
  else if (os_log_type_enabled((os_log_t)qword_100A19E50, OS_LOG_TYPE_ERROR))
  {
    sub_100799338((uint64_t)[*(id *)(a1 + 40) UTF8String], (uint64_t)&v4);
  }
}

void sub_100723E24(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100723ED8(uint64_t a1)
{
  id v2 = [*(id *)(*(void *)(a1 + 32) + 40) objectForKey:*(void *)(a1 + 40)];
  uint64_t v3 = v2;
  if (v2)
  {
    [v2 setIsApp:1];
    [v3 setSupportsBackgroundedPeripherals:1];
  }
  else if (os_log_type_enabled((os_log_t)qword_100A19E50, OS_LOG_TYPE_ERROR))
  {
    sub_100799338((uint64_t)[*(id *)(a1 + 40) UTF8String], (uint64_t)&v4);
  }
}

void sub_100723FA0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100723FBC(uint64_t a1)
{
  uint64_t v2 = *(void *)(*(void *)(a1 + 32) + 8);
  sub_10004191C(__p, (char *)[*(id *)(a1 + 40) UTF8String]);
  (*(void (**)(uint64_t, void **, void))(*(void *)v2 + 16))(v2, __p, *(unsigned __int8 *)(a1 + 48));
  if (v4 < 0) {
    operator delete(__p[0]);
  }
}

void sub_100724040(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_10072410C(uint64_t a1)
{
  uint64_t v2 = [*(id *)(*(void *)(a1 + 32) + 40) objectForKeyedSubscript:*(void *)(a1 + 40)];
  if ([v2 isApp])
  {
    if (![v2 pid] && os_log_type_enabled((os_log_t)qword_100A19E50, OS_LOG_TYPE_ERROR)) {
      sub_10079950C((uint64_t)[*(id *)(a1 + 40) UTF8String], (uint64_t)v15);
    }
    uint64_t v3 = [*(id *)(*(void *)(a1 + 32) + 88) objectForKeyedSubscript:*(void *)(a1 + 40)];
    if (v3)
    {
      char v4 = qword_100A19E50;
      if (os_log_type_enabled((os_log_t)qword_100A19E50, OS_LOG_TYPE_INFO))
      {
        uint64_t v5 = *(void *)(a1 + 48);
        id v6 = [*(id *)(a1 + 40) UTF8String];
        int v11 = 134218242;
        uint64_t v12 = v5;
        __int16 v13 = 2082;
        id v14 = v6;
        _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_INFO, "Attempting to add %lu seconds to process assertion for application \"%{public}s\"", (uint8_t *)&v11, 0x16u);
      }
      [v3 setSecondsLeft:[v3 secondsLeft] + *(void *)(a1 + 48)];
      if ((unint64_t)[v3 secondsLeft] > 9) {
        uint64_t v7 = 10;
      }
      else {
        uint64_t v7 = (uint64_t)[v3 secondsLeft];
      }
      [v3 setSecondsLeft:v7];
    }
    else
    {
      [*(id *)(a1 + 32) createAssertionForBundleID:*(void *)(a1 + 40) duration:*(void *)(a1 + 48) isUrgent:0 withPid:[v2 pid]];
    }
    if (*(unsigned char *)(a1 + 56)
      && [*(id *)(a1 + 32) isPrivilegedBundleID:*(void *)(a1 + 40)])
    {
      [*(id *)(a1 + 32) disableHIP];
      uint64_t v9 = [*(id *)(*(void *)(a1 + 32) + 96) objectForKeyedSubscript:*(void *)(a1 + 40)];

      dispatch_time_t v8 = v9;
      if (v9)
      {
        int v10 = qword_100A19E50;
        if (os_log_type_enabled((os_log_t)qword_100A19E50, OS_LOG_TYPE_INFO))
        {
          LOWORD(v11) = 0;
          _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_INFO, "(EE) Refreshing URGENT Process Assertion", (uint8_t *)&v11, 2u);
        }
        [v9 setSecondsLeft:3];
      }
      else
      {
        dispatch_time_t v8 = 0;
        [*(id *)(a1 + 32) createAssertionForBundleID:*(void *)(a1 + 40) duration:3 isUrgent:1 withPid:[v2 pid]];
      }
    }
    else
    {
      dispatch_time_t v8 = v3;
    }
  }
  else
  {
    if (os_log_type_enabled((os_log_t)qword_100A19E50, OS_LOG_TYPE_ERROR)) {
      sub_100799548((uint64_t)[*(id *)(a1 + 40) UTF8String], (uint64_t)&v11);
    }
    dispatch_time_t v8 = 0;
  }
}

void sub_1007243FC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100724784(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, id location)
{
  objc_destroyWeak(v21);
  objc_destroyWeak(&location);

  _Unwind_Resume(a1);
}

void sub_1007247F8(uint64_t a1)
{
  id v3 = +[BTAppInteraction instance];
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  [v3 urgentAssertionInvalidationCallback:WeakRetained];
}

void sub_100724864(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_10072487C(uint64_t a1)
{
  id v3 = +[BTAppInteraction instance];
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  [v3 assertionInvalidationCallback:WeakRetained];
}

void sub_1007248E8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_100724998(uint64_t a1)
{
  uint64_t v2 = *(void **)(*(void *)(a1 + 32) + 96);
  id v7 = [*(id *)(a1 + 40) name];
  id v3 = [v2 objectForKeyedSubscript:];
  char v4 = *(void **)(a1 + 40);

  if (v3 == v4)
  {
    uint64_t v5 = *(void **)(a1 + 40);
    id v6 = *(void **)(*(void *)(a1 + 32) + 96);
    id v8 = [v5 name];
    [v6 removeObjectForKey:];
  }
}

void sub_100724A50(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  _Unwind_Resume(a1);
}

void sub_100724B00(uint64_t a1)
{
  uint64_t v2 = *(void **)(*(void *)(a1 + 32) + 88);
  id v3 = [*(id *)(a1 + 40) name];
  char v4 = [v2 objectForKeyedSubscript:v3];
  uint64_t v5 = *(void **)(a1 + 40);

  if (v4 == v5)
  {
    id v6 = qword_100A19E50;
    if (os_log_type_enabled((os_log_t)qword_100A19E50, OS_LOG_TYPE_INFO))
    {
      id v7 = [*(id *)(a1 + 40) name];
      int v11 = 136446210;
      id v12 = [v7 UTF8String];
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_INFO, "Removing invalidated process assertion for application \"%{public}s\"", (uint8_t *)&v11, 0xCu);
    }
    id v8 = *(void **)(a1 + 40);
    uint64_t v9 = *(void **)(*(void *)(a1 + 32) + 88);
    int v10 = [v8 name];
    [v9 removeObjectForKey:v10];
  }
}

void sub_100724C28(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id sub_100724D64(uint64_t a1)
{
  return [*(id *)(a1 + 32) assertionTimerFired];
}

void sub_100724E64(uint64_t a1)
{
  uint64_t v2 = [*(id *)(*(void *)(a1 + 32) + 88) keysOfEntriesPassingTest:&stru_1009C0510];
  id v3 = *(void **)(*(void *)(a1 + 32) + 88);
  char v4 = [v2 allObjects];
  [v3 removeObjectsForKeys:v4];

  id v7 = [*(id *)(*(void *)(a1 + 32) + 96) keysOfEntriesPassingTest:&stru_1009C0530];

  uint64_t v5 = *(void **)(*(void *)(a1 + 32) + 96);
  id v6 = [v7 allObjects];
  [v5 removeObjectsForKeys:v6];

  if (![*(id *)(*(void *)(a1 + 32) + 88) count]
    && ![*(id *)(*(void *)(a1 + 32) + 96) count])
  {
    [*(id *)(a1 + 32) invalidateAssertionTimer];
  }
}

void sub_100724F7C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  _Unwind_Resume(a1);
}

BOOL sub_100724FAC(id a1, NSString *a2, ProcessAssertion *a3, BOOL *a4)
{
  char v4 = a3;
  [(ProcessAssertion *)v4 setSecondsLeft:(char *)[(ProcessAssertion *)v4 secondsLeft] - 1];
  unint64_t v5 = [(ProcessAssertion *)v4 secondsLeft];
  if (!v5)
  {
    id v6 = qword_100A19E50;
    if (os_log_type_enabled((os_log_t)qword_100A19E50, OS_LOG_TYPE_INFO))
    {
      id v7 = [(ProcessAssertion *)v4 name];
      int v9 = 136446210;
      id v10 = [v7 UTF8String];
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_INFO, "Removing expired process assertion for application \"%{public}s\"", (uint8_t *)&v9, 0xCu);
    }
    [(ProcessAssertion *)v4 invalidate];
  }

  return v5 == 0;
}

void sub_1007250B0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL sub_1007250D8(id a1, NSString *a2, ProcessAssertion *a3, BOOL *a4)
{
  char v4 = a3;
  [(ProcessAssertion *)v4 setSecondsLeft:(char *)[(ProcessAssertion *)v4 secondsLeft] - 1];
  unint64_t v5 = [(ProcessAssertion *)v4 secondsLeft];
  if (!v5)
  {
    [(ProcessAssertion *)v4 invalidate];
    id v6 = qword_100A19E50;
    if (os_log_type_enabled((os_log_t)qword_100A19E50, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)id v8 = 0;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_INFO, "(EE) Expired URGENT Process Assertion", v8, 2u);
    }
  }

  return v5 == 0;
}

void sub_100725188(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100725204(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100725394(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1007253A4(uint64_t a1)
{
  uint64_t v2 = [*(id *)(*(void *)(a1 + 32) + 40) objectForKey:*(void *)(a1 + 40)];
  id v3 = v2;
  if (!*(unsigned char *)(a1 + 48) || ([v2 isApp])
    && !*(void *)(*(void *)(a1 + 32) + 64))
  {
    char v4 = [[UserNotification alloc] initWithType:0 device:0 bundleID:*(void *)(a1 + 40)];
    uint64_t v5 = *(void *)(a1 + 32);
    id v6 = *(void **)(v5 + 64);
    *(void *)(v5 + 64) = v4;

    id v7 = +[LSApplicationProxy applicationProxyForIdentifier:*(void *)(a1 + 40)];
    id v8 = [v7 localizedNameForContext:0];
    id v20 = sub_100379650(@"CLOSE", @"Close");
    int v9 = sub_100379650(@"SETTINGS", @"Settings");
    if (*(unsigned char *)(a1 + 49))
    {
      id v10 = sub_100379650(@"LE_DENYLIST_ENABLED_HEADER", @"Allow New Connections");
      id v22 = 0;
      int v11 = v8;
      if (!v8) {
        int v11 = *(void **)(a1 + 40);
      }
      id v12 = +[NSString stringWithValidatedFormat:v10, @"%@", &v22, v11 validFormatSpecifiers error];
      id v13 = v22;

      if (v12)
      {
        id v14 = sub_100379650(@"LE_DENYLIST_ENABLED_BODY", &stru_1009C1AC8);
        v26[0] = kCFUserNotificationAlertHeaderKey;
        v26[1] = kCFUserNotificationAlertMessageKey;
        v27[0] = v12;
        v27[1] = v14;
        void v26[2] = kCFUserNotificationDefaultButtonTitleKey;
        v26[3] = kCFUserNotificationAlternateButtonTitleKey;
        void v27[2] = v20;
        v27[3] = v9;
        void v26[4] = SBUserNotificationAllowMenuButtonDismissal;
        uint8_t v27[4] = &__kCFBooleanTrue;
        CFDictionaryRef v15 = +[NSDictionary dictionaryWithObjects:v27 forKeys:v26 count:5];

        goto LABEL_13;
      }
      if (os_log_type_enabled((os_log_t)qword_100A19E50, OS_LOG_TYPE_ERROR)) {
        sub_1007996A4();
      }
    }
    else
    {
      long long v16 = sub_100379650(@"LE_POWER_OFF_HEADER", @"Power Off");
      id v21 = 0;
      long long v17 = v8;
      if (!v8) {
        long long v17 = *(void **)(a1 + 40);
      }
      id v12 = +[NSString stringWithValidatedFormat:v16, @"%@", &v21, v17 validFormatSpecifiers error];
      id v13 = v21;

      if (v12)
      {
        v24[0] = kCFUserNotificationAlertHeaderKey;
        v24[1] = kCFUserNotificationDefaultButtonTitleKey;
        v25[0] = v12;
        v25[1] = v20;
        _DWORD v24[2] = kCFUserNotificationAlternateButtonTitleKey;
        v24[3] = SBUserNotificationAllowMenuButtonDismissal;
        void v25[2] = v9;
        v25[3] = &__kCFBooleanTrue;
        CFDictionaryRef v15 = +[NSDictionary dictionaryWithObjects:v25 forKeys:v24 count:4];
LABEL_13:
        CFUserNotificationRef v18 = CFUserNotificationCreate(kCFAllocatorDefault, 0.0, 0, 0, v15);
        if (v18)
        {
          [*(id *)(*(void *)(a1 + 32) + 64) setNotification:v18];
          CFRelease(v18);
          CFRunLoopSourceRef RunLoopSource = CFUserNotificationCreateRunLoopSource(kCFAllocatorDefault, v18, (CFUserNotificationCallBack)sub_10072590C, 0);
          if (RunLoopSource)
          {
            [*(id *)(*(void *)(a1 + 32) + 64) setRunLoopSource:RunLoopSource];
            CFRelease(RunLoopSource);
          }
          else if (os_log_type_enabled((os_log_t)qword_100A19E50, OS_LOG_TYPE_ERROR))
          {
            sub_100799668((uint64_t)[*(id *)(a1 + 40) UTF8String], (uint64_t)v23);
          }
        }
        else if (os_log_type_enabled((os_log_t)qword_100A19E50, OS_LOG_TYPE_ERROR))
        {
          sub_10079962C((uint64_t)[*(id *)(a1 + 40) UTF8String], (uint64_t)v23);
        }
        goto LABEL_25;
      }
      if (os_log_type_enabled((os_log_t)qword_100A19E50, OS_LOG_TYPE_ERROR)) {
        sub_1007995C0();
      }
    }
    id v12 = 0;
    CFDictionaryRef v15 = 0;
LABEL_25:
  }
}

void sub_100725848(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  _Unwind_Resume(a1);
}

void sub_10072590C(uint64_t a1, uint64_t a2)
{
  id v4 = +[BTAppInteraction instance];
  [v4 powerAlertCallback:a1 flags:a2];
}

void sub_10072596C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1007259F4(uint64_t a1)
{
  uint64_t v2 = qword_100A19E50;
  if (os_log_type_enabled((os_log_t)qword_100A19E50, OS_LOG_TYPE_DEFAULT))
  {
    id v3 = [*(id *)(*(void *)(a1 + 32) + 64) bundleID];
    id v4 = [v3 UTF8String];
    uint64_t v5 = *(void *)(a1 + 40);
    id v6 = "unknown";
    if (v5 == 1) {
      id v6 = "settings";
    }
    if (v5) {
      id v7 = v6;
    }
    else {
      id v7 = "cancel";
    }
    int v12 = 136446466;
    id v13 = v4;
    __int16 v14 = 2082;
    CFDictionaryRef v15 = v7;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "User responded to power notification callback for application \"%{public}s\" with %{public}s button", (uint8_t *)&v12, 0x16u);
  }
  if (*(void *)(a1 + 40) == 1)
  {
    id v8 = +[LSApplicationWorkspace defaultWorkspace];
    int v9 = +[NSURL URLWithString:@"prefs:root=Bluetooth"];
    [v8 openSensitiveURL:v9 withOptions:0];
  }
  uint64_t v10 = *(void *)(a1 + 32);
  int v11 = *(void **)(v10 + 64);
  *(void *)(v10 + 64) = 0;
}

void sub_100725B5C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100725C58(uint64_t a1)
{
  uint64_t v2 = [*(id *)(*(void *)(a1 + 32) + 40) objectForKey:*(void *)(a1 + 40)];
  if ([v2 isApp])
  {
    unsigned int v26 = [[UserNotification alloc] initWithType:*(unsigned int *)(a1 + 56) device:*(void *)(a1 + 48) bundleID:*(void *)(a1 + 40)];
    id v3 = *(void **)(*(void *)(a1 + 32) + 72);
    v28[0] = _NSConcreteStackBlock;
    v28[1] = 3221225472;
    void v28[2] = sub_100726308;
    v28[3] = &unk_1009C0580;
    id v29 = *(id *)(a1 + 40);
    id v4 = [v3 indexOfObjectPassingTest:v28];
    if (v4 != (id)0x7FFFFFFFFFFFFFFFLL)
    {
      __int16 v25 = [*(id *)(*(void *)(a1 + 32) + 72) objectAtIndexedSubscript:v4];
      uint64_t v5 = [(__CFString *)v25 device];
      if ([v5 isEqual:*(void *)(a1 + 48)])
      {
        BOOL v6 = *(_DWORD *)(a1 + 56) == 1;

        if (!v6)
        {
          id v7 = qword_100A19E50;
          if (os_log_type_enabled((os_log_t)qword_100A19E50, OS_LOG_TYPE_INFO))
          {
            id v8 = [*(id *)(a1 + 40) UTF8String];
            *(_DWORD *)long long buf = 136446210;
            *(void *)&uint8_t buf[4] = v8;
            _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_INFO, "Suppressing duplicate notification for application \"%{public}s\"", buf, 0xCu);
          }
LABEL_33:

          goto LABEL_34;
        }
      }
      else
      {
      }
      [*(id *)(a1 + 32) cancelAppLaunchAlert:*(void *)(a1 + 40)];
    }
    if (*(_DWORD *)(a1 + 56) == 1) {
      int v9 = @"APP_LAUNCH_HEADER_DISCONNECTED";
    }
    else {
      int v9 = @"APP_LAUNCH_HEADER_GENERAL";
    }
    __int16 v25 = v9;
    __int16 v23 = sub_100379650(v25, @"APP_LAUNCH_BODY");
    uint64_t v10 = [(UserNotification *)v26 bundleID];
    uint64_t v24 = +[LSApplicationProxy applicationProxyForIdentifier:v10];

    int v11 = [v24 localizedNameForContext:0];
    int v12 = v11;
    if (!v11) {
      int v12 = *(void **)(a1 + 40);
    }
    id v13 = v12;
    if (qword_1009F7EE0 != -1) {
      dispatch_once(&qword_1009F7EE0, &stru_1009C07D8);
    }
    sub_10003093C((uint64_t)off_1009F7ED8, *(void **)(a1 + 48), (uint64_t)buf);
    if (v33 >= 0) {
      __int16 v14 = buf;
    }
    else {
      __int16 v14 = *(unsigned char **)buf;
    }
    CFDictionaryRef v15 = +[NSString stringWithUTF8String:v14];
    if (v33 < 0) {
      operator delete(*(void **)buf);
    }
    id v27 = 0;
    long long v16 = +[NSString stringWithValidatedFormat:v23, @"%@%@", &v27, v15, v13 validFormatSpecifiers error];
    id v22 = v27;
    if (v16)
    {
      id v21 = sub_100379650(@"CLOSE", @"Close");
      long long v17 = sub_100379650(@"VIEW", @"View");
      v30[0] = kCFUserNotificationAlertHeaderKey;
      v30[1] = kCFUserNotificationAlertMessageKey;
      v31[0] = v13;
      v31[1] = v16;
      void v30[2] = kCFUserNotificationDefaultButtonTitleKey;
      v30[3] = kCFUserNotificationAlternateButtonTitleKey;
      v30[4] = kCFUserNotificationAlertTopMostKey;
      v30[5] = SBUserNotificationDontDismissOnUnlock;
      v31[4] = &__kCFBooleanTrue;
      v31[5] = &__kCFBooleanTrue;
      void v30[6] = SBUserNotificationButtonTagForUnlockActionKey;
      v30[7] = SBUserNotificationSoundRepeatDurationKey;
      void v31[2] = v17;
      v31[3] = v21;
      void v31[6] = &off_1009E1238;
      v31[7] = &off_1009E1250;
      v30[8] = SBUserNotificationSystemSoundIDKey;
      v31[8] = &off_1009E1268;
      CFDictionaryRef v18 = +[NSDictionary dictionaryWithObjects:v31 forKeys:v30 count:9];
      CFUserNotificationRef v19 = CFUserNotificationCreate(kCFAllocatorDefault, 0.0, 0, 0, v18);
      if (v19)
      {
        [(UserNotification *)v26 setNotification:v19];
        CFRelease(v19);
        CFRunLoopSourceRef RunLoopSource = CFUserNotificationCreateRunLoopSource(kCFAllocatorDefault, v19, (CFUserNotificationCallBack)sub_10072635C, 0);
        if (RunLoopSource)
        {
          [(UserNotification *)v26 setRunLoopSource:RunLoopSource];
          CFRelease(RunLoopSource);
          [*(id *)(*(void *)(a1 + 32) + 72) addObject:v26];
        }
        else if (os_log_type_enabled((os_log_t)qword_100A19E50, OS_LOG_TYPE_ERROR))
        {
          sub_1007997B8((uint64_t)[*(id *)(a1 + 40) UTF8String], (uint64_t)buf);
        }
      }
      else if (os_log_type_enabled((os_log_t)qword_100A19E50, OS_LOG_TYPE_ERROR))
      {
        sub_10079977C((uint64_t)[*(id *)(a1 + 40) UTF8String], (uint64_t)buf);
      }
    }
    else if (os_log_type_enabled((os_log_t)qword_100A19E50, OS_LOG_TYPE_ERROR))
    {
      sub_100799710();
    }

    goto LABEL_33;
  }
LABEL_34:
}

void sub_1007261F8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, void *a12, void *a13, void *a14, void *a15, void *a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *a22)
{
  _Unwind_Resume(a1);
}

id sub_100726308(uint64_t a1, void *a2)
{
  id v3 = [a2 bundleID];
  id v4 = [v3 isEqualToString:*(void *)(a1 + 32)];

  return v4;
}

void sub_10072634C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_10072635C(uint64_t a1, uint64_t a2)
{
  id v4 = +[BTAppInteraction instance];
  [v4 appLaunchCallback:a1 flags:a2];
}

void sub_1007263BC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

id sub_1007263D0(uint64_t a1, void *a2)
{
  id v3 = [a2 bundleID];
  id v4 = [v3 isEqualToString:*(void *)(a1 + 32)];

  return v4;
}

void sub_100726414(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_10072649C(void *a1)
{
  uint64_t v2 = *(void **)(a1[4] + 72);
  v22[0] = _NSConcreteStackBlock;
  v22[1] = 3221225472;
  void v22[2] = sub_1007267FC;
  v22[3] = &unk_1009C05A0;
  v22[4] = a1[5];
  id v3 = [v2 indexOfObjectPassingTest:v22];
  if (v3 == (id)0x7FFFFFFFFFFFFFFFLL)
  {
    if (os_log_type_enabled((os_log_t)qword_100A19E50, OS_LOG_TYPE_ERROR)) {
      sub_1007997F4();
    }
  }
  else
  {
    id v4 = [*(id *)(a1[4] + 72) objectAtIndexedSubscript:v3];
    uint64_t v5 = qword_100A19E50;
    if (os_log_type_enabled((os_log_t)qword_100A19E50, OS_LOG_TYPE_DEFAULT))
    {
      id v6 = [v4 bundleID];
      id v7 = [v6 UTF8String];
      uint64_t v8 = a1[6];
      if (v8)
      {
        if (v8 == 1)
        {
          int v9 = "cancel";
        }
        else
        {
          unsigned int v10 = [&off_1009E1238 intValue];
          int v9 = "unknown";
          if (v8 == v10) {
            int v9 = "unlock";
          }
        }
      }
      else
      {
        int v9 = "default";
      }
      *(_DWORD *)long long buf = 136446466;
      id v24 = v7;
      __int16 v25 = 2082;
      unsigned int v26 = v9;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "User responded to app launch notification callback for application \"%{public}s\" with %{public}s button", buf, 0x16u);
    }
    uint64_t v11 = a1[6];
    if (!v11 || v11 == (int)[&off_1009E1238 intValue])
    {
      int v12 = qword_100A19E50;
      if (os_log_type_enabled((os_log_t)qword_100A19E50, OS_LOG_TYPE_DEFAULT))
      {
        id v13 = [v4 bundleID];
        id v14 = [v13 UTF8String];
        *(_DWORD *)long long buf = 136446210;
        id v24 = v14;
        _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "Attempting to launch application \"%{public}s\"", buf, 0xCu);
      }
      CFDictionaryRef v15 = +[FBSOpenApplicationService serviceWithDefaultShellEndpoint];
      long long v16 = [v4 bundleID];
      long long v17 = _NSConcreteStackBlock;
      uint64_t v18 = 3221225472;
      CFUserNotificationRef v19 = sub_100726830;
      id v20 = &unk_1009C05C8;
      id v21 = v4;
      [v15 openApplication:v16 withOptions:0 completion:&v17];
    }
    [*(id *)(a1[4] + 72) removeObjectAtIndex:v3, v17, v18, v19, v20];
  }
}

void sub_1007267A4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL sub_1007267FC(uint64_t a1, void *a2)
{
  return [a2 notification] == *(id *)(a1 + 32);
}

void sub_100726830(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  if (v6)
  {
    id v7 = qword_100A19E50;
    if (os_log_type_enabled((os_log_t)qword_100A19E50, OS_LOG_TYPE_ERROR))
    {
      uint64_t v8 = [*(id *)(a1 + 32) bundleID];
      id v9 = +[NSString stringWithFormat:@"Failed to launch application \"%@\" with error %@", v8, v6];
      *(_DWORD *)long long buf = 136446210;
      id v15 = [v9 UTF8String];
      _os_log_error_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, "%{public}s", buf, 0xCu);
    }
  }
  else
  {
    unsigned int v10 = [v5 isValid];
    uint64_t v11 = qword_100A19E50;
    if (v10)
    {
      if (os_log_type_enabled((os_log_t)qword_100A19E50, OS_LOG_TYPE_DEFAULT))
      {
        id v12 = [*(id *)(a1 + 32) bundleID];
        *(_DWORD *)long long buf = 136446466;
        id v15 = [v12 UTF8String];
        __int16 v16 = 1026;
        unsigned int v17 = [v5 pid];
        _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "Launched application: \"%{public}s\", pid: %{public}ul", buf, 0x12u);
      }
    }
    else if (os_log_type_enabled((os_log_t)qword_100A19E50, OS_LOG_TYPE_ERROR))
    {
      id v13 = [*(id *)(a1 + 32) bundleID];
      *(_DWORD *)long long buf = 136446210;
      id v15 = [v13 UTF8String];
      _os_log_error_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "Failed to lookup the process ID of \"%{public}s\"", buf, 0xCu);
    }
  }
}

void sub_100726A44(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100726BC8(uint64_t a1)
{
  if (!*(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 40)
    || (uint64_t v2 = *(void **)(*(void *)(a1 + 32) + 80),
        id v3 = -[PairingNotification initWithType:passkey:device:]([PairingNotification alloc], "initWithType:passkey:device:", *(unsigned int *)(a1 + 56), *(void *)(a1 + 48), *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 40)), [v2 addObject:v3], v3, (unint64_t)objc_msgSend(*(id *)(*(void *)(a1 + 32) + 80), "count") < 2))
  {
    if ([*(id *)(*(void *)(a1 + 32) + 80) count])
    {
      id v6 = [*(id *)(*(void *)(a1 + 32) + 80) objectAtIndexedSubscript:0];
      id v7 = v6;
      if (v6 && ![v6 notification])
      {
        long long buf = 0uLL;
        uint64_t v74 = 0;
        if (qword_1009F7EE0 != -1) {
          dispatch_once(&qword_1009F7EE0, &stru_1009C07D8);
        }
        uint64_t v8 = off_1009F7ED8;
        id v9 = [v7 device];
        sub_10003093C((uint64_t)v8, v9, (uint64_t)v70);
        if ((v72 & 0x80u) == 0) {
          uint64_t v10 = v72;
        }
        else {
          uint64_t v10 = v71;
        }
        if (v10)
        {
          if (qword_1009F7EE0 != -1) {
            dispatch_once(&qword_1009F7EE0, &stru_1009C07D8);
          }
          uint64_t v11 = off_1009F7ED8;
          id v12 = [v7 device];
          sub_10003093C((uint64_t)v11, v12, (uint64_t)&buf);
        }
        else
        {
          if (qword_1009F7EE0 != -1) {
            dispatch_once(&qword_1009F7EE0, &stru_1009C07D8);
          }
          id v13 = off_1009F7ED8;
          id v12 = [v7 device];
          sub_100030DCC((uint64_t)v13, v12, 0);
          sub_1006AD3F0();
          id v14 = objc_claimAutoreleasedReturnValue();
          sub_10004191C(&buf, (char *)[v14 UTF8String]);
        }
        if ((char)v72 < 0) {
          operator delete(*(void **)v70);
        }

        int v54 = sub_100379650(@"PAIRING_TITLE", @"Pairing");
        __int16 v51 = sub_100379650(@"CANCEL", @"Cancel");
        uint64_t v50 = sub_100379650(@"PAIR", @"Pair");
        if (v74 >= 0) {
          p_long long buf = &buf;
        }
        else {
          p_long long buf = (long long *)buf;
        }
        __int16 v53 = +[NSString stringWithUTF8String:p_buf];
        int v52 = (void *)MGCopyAnswer();
        v68[0] = kCFUserNotificationAlertTopMostKey;
        v68[1] = SBUserNotificationAllowMenuButtonDismissal;
        v69[0] = &__kCFBooleanTrue;
        v69[1] = &__kCFBooleanTrue;
        v68[2] = SBUserNotificationDismissOnLock;
        v68[3] = kCFUserNotificationAlertHeaderKey;
        v69[2] = &__kCFBooleanTrue;
        v69[3] = v54;
        __int16 v16 = +[NSDictionary dictionaryWithObjects:v69 forKeys:v68 count:4];
        CFDictionaryRef dictionary = (CFDictionaryRef)[v16 mutableCopy];

        uint64_t v17 = sub_100035F54();
        int v18 = (*(uint64_t (**)(uint64_t))(*(void *)v17 + 360))(v17);
        uint64_t v19 = sub_100035F54();
        int v20 = (*(uint64_t (**)(uint64_t))(*(void *)v19 + 272))(v19);
        if (qword_1009F7EE0 != -1) {
          dispatch_once(&qword_1009F7EE0, &stru_1009C07D8);
        }
        id v21 = off_1009F7ED8;
        id v22 = [v7 device];
        BOOL v23 = sub_1006C420C((uint64_t)v21, v22);

        id v24 = 0;
        int v56 = &stru_1009C1AC8;
        id v25 = 0;
        id v26 = 0;
        switch([v7 pairingType])
        {
          case 0u:
            id v27 = sub_100379650(@"JUST_WORKS_MESSAGE", @"Body");
            id v65 = 0;
            int v56 = +[NSString stringWithValidatedFormat:v27, @"%@%@", &v65, v53, v52 validFormatSpecifiers error];
            id v26 = v65;

            if (!v56)
            {
              if (os_log_type_enabled((os_log_t)qword_100A19E50, OS_LOG_TYPE_ERROR)) {
                sub_100799900();
              }
              goto LABEL_81;
            }
            if ((v18 & v20 & v23) != 1) {
              goto LABEL_65;
            }
            unsigned __int8 v28 = qword_100A19E50;
            if (os_log_type_enabled((os_log_t)qword_100A19E50, OS_LOG_TYPE_DEFAULT))
            {
              *(_WORD *)unint64_t v70 = 0;
              _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, "Pairing LE HID with old iPad. Show modified message", v70, 2u);
            }
            if (_os_feature_enabled_impl())
            {
              if (qword_1009F7EE0 != -1) {
                dispatch_once(&qword_1009F7EE0, &stru_1009C07D8);
              }
              id v29 = off_1009F7ED8;
              uint64_t v30 = [v7 device];
              sub_1006B85C0((uint64_t)v29, v30, @"HIDDeviceUnknownBehavior");

              if (qword_1009F7EE0 != -1) {
                dispatch_once(&qword_1009F7EE0, &stru_1009C07D8);
              }
              __int16 v31 = off_1009F7ED8;
              int v32 = [v7 device];
              sub_10004191C(v63, "HIDDeviceKnownPoorBehavior");
              sub_1006BC69C((uint64_t)v31, v32, (unsigned __int8 *)v63);
              if ((v64 & 0x80000000) == 0) {
                goto LABEL_61;
              }
              char v33 = (void **)v63;
            }
            else
            {
              if (qword_1009F7EE0 != -1) {
                dispatch_once(&qword_1009F7EE0, &stru_1009C07D8);
              }
              int v38 = off_1009F7ED8;
              int v32 = [v7 device];
              sub_10004191C(v61, "HIDDeviceUnknownBehavior");
              sub_1006BC69C((uint64_t)v38, v32, (unsigned __int8 *)v61);
              if ((v62 & 0x80000000) == 0) {
                goto LABEL_61;
              }
              char v33 = (void **)v61;
            }
            operator delete(*v33);
LABEL_61:

            int v39 = MGGetBoolAnswer();
            CFStringRef v40 = @"WIFI";
            if (v39) {
              CFStringRef v40 = @"WLAN";
            }
            long long v41 = +[NSString stringWithFormat:@"%@_JUST_WORKS_MESSAGE_HID_OLD", v40];
            long long v42 = sub_100379650(v41, @"Body");
            id v43 = v26;
            id v60 = v26;
            uint64_t v44 = +[NSString stringWithValidatedFormat:v42, @"%@%@", &v60, v53, v52 validFormatSpecifiers error];
            id v26 = v60;

            if (v44)
            {
              int v56 = (__CFString *)v44;
              goto LABEL_65;
            }
            if (os_log_type_enabled((os_log_t)qword_100A19E50, OS_LOG_TYPE_ERROR)) {
              sub_10079996C();
            }
            goto LABEL_81;
          case 1u:
            int v36 = sub_100379650(@"PASSKEY_DISPLAY_MESSAGE", @"Body");
            id v59 = 0;
            +[NSString stringWithValidatedFormat:validFormatSpecifiers:error:](NSString, "stringWithValidatedFormat:validFormatSpecifiers:error:", v36, @"%@%@%06u%@", &v59, v53, v52, [v7 passkey], v53, v50);
            int v56 = (__CFString *)objc_claimAutoreleasedReturnValue();
            id v26 = v59;

            if (v56)
            {
              id v24 = v51;
              id v25 = 0;
              goto LABEL_66;
            }
            if (os_log_type_enabled((os_log_t)qword_100A19E50, OS_LOG_TYPE_ERROR)) {
              sub_1007999D8();
            }
            goto LABEL_81;
          case 2u:
            int v34 = sub_100379650(@"PASSKEY_ENTRY_MESSAGE", @"Body");
            id v58 = 0;
            int v56 = +[NSString stringWithValidatedFormat:v34, @"%@%@%@%@", &v58, v53, v52, v53, v53 validFormatSpecifiers error];
            id v26 = v58;

            if (v56)
            {
              id v24 = v50;
              id v25 = v51;
              v66[0] = kCFUserNotificationTextFieldTitlesKey;
              v66[1] = kCFUserNotificationKeyboardTypesKey;
              v67[0] = &stru_1009C1AC8;
              v67[1] = &off_1009E1280;
              __int16 v35 = +[NSDictionary dictionaryWithObjects:v67 forKeys:v66 count:2];
              [(__CFDictionary *)dictionary addEntriesFromDictionary:v35];

              goto LABEL_66;
            }
            if (os_log_type_enabled((os_log_t)qword_100A19E50, OS_LOG_TYPE_ERROR)) {
              sub_100799A44();
            }
            goto LABEL_81;
          case 3u:
            goto LABEL_66;
          case 4u:
            __int16 v37 = sub_100379650(@"NUMERIC_MESSAGE", @"Body");
            id v57 = 0;
            +[NSString stringWithValidatedFormat:validFormatSpecifiers:error:](NSString, "stringWithValidatedFormat:validFormatSpecifiers:error:", v37, @"%@%@%06u%@", &v57, v53, v52, [v7 passkey], v53, v50, v51);
            int v56 = (__CFString *)objc_claimAutoreleasedReturnValue();
            id v26 = v57;

            if (v56)
            {
LABEL_65:
              id v24 = v50;
              id v25 = v51;
LABEL_66:
              [(__CFDictionary *)dictionary setObject:v56 forKey:kCFUserNotificationAlertMessageKey];
              if (v24) {
                [(__CFDictionary *)dictionary setObject:v24 forKey:kCFUserNotificationDefaultButtonTitleKey];
              }
              if (v25) {
                [(__CFDictionary *)dictionary setObject:v25 forKey:kCFUserNotificationAlternateButtonTitleKey];
              }
              uint64_t v45 = v26;
              CFUserNotificationRef v46 = CFUserNotificationCreate(kCFAllocatorDefault, 0.0, 0x10003uLL, 0, dictionary);
              if (v46)
              {
                [v7 setNotification:v46];
                CFRelease(v46);
                CFRunLoopSourceRef RunLoopSource = CFUserNotificationCreateRunLoopSource(kCFAllocatorDefault, v46, (CFUserNotificationCallBack)sub_100727AD8, 0);
                if (RunLoopSource)
                {
                  [v7 setRunLoopSource:RunLoopSource];
                  CFRelease(RunLoopSource);
                  goto LABEL_82;
                }
                if (os_log_type_enabled((os_log_t)qword_100A19E50, OS_LOG_TYPE_ERROR))
                {
                  __int16 v49 = [v7 device];
                  sub_1007998B4(v49, (uint64_t)v70);
                  uint64_t v45 = v26;
                }
              }
              else if (os_log_type_enabled((os_log_t)qword_100A19E50, OS_LOG_TYPE_ERROR))
              {
                uint64_t v48 = [v7 device];
                sub_100799868(v48, (uint64_t)v70);
                uint64_t v45 = v26;
              }
              [*(id *)(*(void *)(a1 + 32) + 80) removeObjectAtIndex:0];
            }
            else
            {
              if (os_log_type_enabled((os_log_t)qword_100A19E50, OS_LOG_TYPE_ERROR)) {
                sub_100799AB0();
              }
LABEL_81:
              int v56 = 0;
              id v24 = 0;
              id v25 = 0;
              uint64_t v45 = v26;
            }
LABEL_82:

            if (SHIBYTE(v74) < 0) {
              operator delete((void *)buf);
            }
            break;
          default:
            id v25 = 0;
            id v26 = 0;
            goto LABEL_66;
        }
      }
    }
    else
    {
      id v7 = 0;
    }

    return;
  }
  id v4 = qword_100A19E50;
  if (os_log_type_enabled((os_log_t)qword_100A19E50, OS_LOG_TYPE_INFO))
  {
    uint64_t v5 = *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 40);
    LODWORD(buf) = 138412290;
    *(void *)((char *)&buf + 4) = v5;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_INFO, "Waiting for current pairing prompt to go away before displaying prompt for device \"%@\"", (uint8_t *)&buf, 0xCu);
  }
}

void sub_100727890(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, void *a14, void *a15, void *a16, void *a17, void *a18, void *a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,void *__p,uint64_t a25,int a26,__int16 a27,char a28,char a29,void *a30,uint64_t a31,int a32,__int16 a33,char a34,char a35)
{
  if (a29 < 0) {
    operator delete(__p);
  }

  if (*(char *)(v38 - 105) < 0) {
    operator delete(*(void **)(v38 - 128));
  }

  _Unwind_Resume(a1);
}

void sub_100727AD8(uint64_t a1, uint64_t a2)
{
  id v4 = +[BTAppInteraction instance];
  [v4 pairingAlertCallback:a1 flags:a2];
}

void sub_100727B38(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_100727BE4(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 32);
  if (v2)
  {
    id v3 = *(void **)(*(void *)(a1 + 40) + 80);
    v7[0] = _NSConcreteStackBlock;
    v7[1] = 3221225472;
    void v7[2] = sub_100727CE8;
    void v7[3] = &unk_1009B84F0;
    id v4 = v2;
    uint64_t v5 = *(void *)(a1 + 40);
    id v8 = v4;
    uint64_t v9 = v5;
    [v3 enumerateObjectsUsingBlock:v7];
  }
  else
  {
    id v6 = qword_100A19E50;
    if (os_log_type_enabled((os_log_t)qword_100A19E50, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "Clearing all active pairing notifications", buf, 2u);
    }
    [*(id *)(*(void *)(a1 + 40) + 80) removeAllObjects];
  }
}

void sub_100727CD4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13)
{
  _Unwind_Resume(a1);
}

void sub_100727CE8(uint64_t a1, void *a2, uint64_t a3, unsigned char *a4)
{
  id v7 = a2;
  id v8 = [v7 device];
  unsigned int v9 = [v8 isEqual:*(void *)(a1 + 32)];

  if (v9)
  {
    uint64_t v10 = qword_100A19E50;
    if (os_log_type_enabled((os_log_t)qword_100A19E50, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v11 = "queued";
      uint64_t v12 = *(void *)(a1 + 32);
      if (!a3) {
        uint64_t v11 = "active";
      }
      int v13 = 136446466;
      id v14 = v11;
      __int16 v15 = 2112;
      uint64_t v16 = v12;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "Clearing %{public}s pairing notification for device \"%@\"", (uint8_t *)&v13, 0x16u);
    }
    [*(id *)(*(void *)(a1 + 40) + 80) removeObjectAtIndex:a3];
    *a4 = 1;
  }
}

void sub_100727E10(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100727EAC(uint64_t a1)
{
  uint64_t v2 = *(void **)(*(void *)(a1 + 32) + 80);
  v24[0] = _NSConcreteStackBlock;
  v24[1] = 3221225472;
  _DWORD v24[2] = sub_10072832C;
  v24[3] = &unk_1009C05A0;
  void v24[4] = *(void *)(a1 + 40);
  id v3 = [v2 indexOfObjectPassingTest:v24];
  if (v3 == (id)0x7FFFFFFFFFFFFFFFLL)
  {
    if (os_log_type_enabled((os_log_t)qword_100A19E50, OS_LOG_TYPE_ERROR)) {
      sub_100799B1C();
    }
  }
  else
  {
    id v4 = [*(id *)(*(void *)(a1 + 32) + 80) objectAtIndexedSubscript:v3];
    uint64_t v5 = 0;
    uint64_t v6 = 1;
    switch([v4 pairingType])
    {
      case 0u:
      case 4u:
        goto LABEL_6;
      case 1u:
        uint64_t v6 = 0;
        uint64_t v5 = 1;
LABEL_6:
        id v7 = qword_100A19E50;
        if (os_log_type_enabled((os_log_t)qword_100A19E50, OS_LOG_TYPE_DEFAULT))
        {
          id v8 = [v4 device];
          unsigned int v9 = *(const char **)(a1 + 48);
          unsigned int v10 = [v4 pairingType];
          uint64_t v11 = "unknown";
          *(_DWORD *)long long buf = 138413058;
          id v26 = v8;
          if (v9 == (const char *)v6) {
            uint64_t v11 = "cancel";
          }
          __int16 v27 = 2082;
          if (v9 == (const char *)v5) {
            uint64_t v11 = "pair";
          }
          unsigned __int8 v28 = v11;
          __int16 v29 = 2048;
          uint64_t v30 = v9;
          __int16 v31 = 1024;
          LODWORD(v32) = v10;
          _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "User responded to pairing notification for device \"%@\" with %{public}s (%ld) button for pairing type:%d", buf, 0x26u);
        }
        break;
      case 2u:
        uint64_t v12 = CFUserNotificationGetResponseValue(*(CFUserNotificationRef *)(a1 + 40), kCFUserNotificationTextFieldValuesKey, 0);
        int v13 = v12;
        if (v12) {
          [v4 setPasskey:[v12 intValue]];
        }
        id v14 = qword_100A19E50;
        if (os_log_type_enabled((os_log_t)qword_100A19E50, OS_LOG_TYPE_DEFAULT))
        {
          __int16 v15 = [v4 device];
          uint64_t v16 = (const char *)[v4 passkey];
          uint64_t v17 = *(void *)(a1 + 48);
          unsigned int v18 = [v4 pairingType];
          uint64_t v19 = "unknown";
          *(_DWORD *)long long buf = 138413314;
          id v26 = v15;
          if (v17 == 1) {
            uint64_t v19 = "cancel";
          }
          unsigned __int8 v28 = v16;
          __int16 v29 = 2082;
          __int16 v27 = 2048;
          if (!v17) {
            uint64_t v19 = "pair";
          }
          uint64_t v30 = v19;
          __int16 v31 = 2048;
          uint64_t v32 = v17;
          __int16 v33 = 1024;
          unsigned int v34 = v18;
          _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "User responded to pairing notification for device \"%@\" with passkey %lu and %{public}s (%ld) button for pairing type:%d", buf, 0x30u);
        }
        uint64_t v5 = 0;
        break;
      default:
        break;
    }
    if (qword_1009F7ED0 != -1) {
      dispatch_once(&qword_1009F7ED0, &stru_1009C07F8);
    }
    uint64_t v20 = qword_1009F7EC8;
    id v21 = [v4 device];
    sub_100708CB4(v20, v21, *(void *)(a1 + 48) == v5, [v4 passkey]);

    [*(id *)(*(void *)(a1 + 32) + 80) removeObjectAtIndex:v3];
    if ([*(id *)(*(void *)(a1 + 32) + 80) count])
    {
      uint64_t v22 = *(void *)(a1 + 32);
      if (*(void *)(v22 + 8))
      {
        v23[0] = _NSConcreteStackBlock;
        v23[1] = 3221225472;
        void v23[2] = sub_100728360;
        v23[3] = &unk_100997450;
        v23[4] = v22;
        dispatch_async((dispatch_queue_t)&_dispatch_main_q, v23);
      }
    }
  }
}

void sub_1007282C4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL sub_10072832C(uint64_t a1, void *a2)
{
  return [a2 notification] == *(id *)(a1 + 32);
}

void sub_100728360(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  uint64_t v2 = *(void *)(v1 + 8);
  id v4 = [*(id *)(v1 + 80) objectAtIndexedSubscript:0];
  id v3 = [v4 device];
  (*(void (**)(uint64_t, void *))(*(void *)v2 + 24))(v2, v3);
}

void sub_1007283F0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1007284E0(id a1, NSString *a2, ProcessAssertion *a3, BOOL *a4)
{
  id v4 = a3;
  uint64_t v5 = qword_100A19E50;
  if (os_log_type_enabled((os_log_t)qword_100A19E50, OS_LOG_TYPE_DEFAULT))
  {
    id v6 = +[NSString stringWithFormat:@"   %@", v4];
    *(_DWORD *)long long buf = 136446210;
    id v8 = [v6 UTF8String];
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "%{public}s", buf, 0xCu);
  }
}

void sub_1007285C0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1007285E4(id a1, NSString *a2, ProcessAssertion *a3, BOOL *a4)
{
  id v4 = a3;
  uint64_t v5 = qword_100A19E50;
  if (os_log_type_enabled((os_log_t)qword_100A19E50, OS_LOG_TYPE_DEFAULT))
  {
    id v6 = +[NSString stringWithFormat:@"   %@", v4];
    *(_DWORD *)long long buf = 136446210;
    id v8 = [v6 UTF8String];
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "%{public}s", buf, 0xCu);
  }
}

void sub_1007286C4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100728B30(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22,uint64_t a23,void *a24,uint64_t a25,int a26,__int16 a27,char a28,char a29)
{
  _Unwind_Resume(a1);
}

void sub_100728BC0(uint64_t a1)
{
  *(unsigned char *)(*(void *)(a1 + 32) + 32) = 1;
  CFOptionFlags v20 = 0;
  uint64_t v2 = +[CBAccessoryLogging getProductNameFromProductID:*(unsigned int *)(a1 + 48)];
  id v3 = +[NSString stringWithFormat:@"%@ Issue Detected", v2];
  sub_100379650(@"TITLE", v3);
  alertHeader = (__CFString *)objc_claimAutoreleasedReturnValue();

  id v4 = +[NSString stringWithFormat:@"An issue was detected with your %@. Do you wish to file a radar with AirWave?", v2];
  sub_100379650(@"CONTENT", v4);
  uint64_t v5 = (__CFString *)objc_claimAutoreleasedReturnValue();

  sub_100379650(@"OPEN_AIRWAVE", @"Open AirWave");
  id v6 = (__CFString *)objc_claimAutoreleasedReturnValue();
  sub_100379650(@"NO_THANKS", @"No thanks");
  id v7 = (__CFString *)objc_claimAutoreleasedReturnValue();
  CFUserNotificationDisplayAlert(0.0, 1uLL, 0, 0, 0, alertHeader, v5, v6, v7, 0, &v20);
  if (v20)
  {
    if (v20 == 1)
    {
      id v8 = qword_100A19E50;
      if (os_log_type_enabled((os_log_t)qword_100A19E50, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        unsigned int v9 = "displayAirWaveLaunchNotification: Dismissing crash log";
LABEL_10:
        _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, v9, buf, 2u);
      }
    }
    else
    {
      id v8 = qword_100A19E50;
      if (os_log_type_enabled((os_log_t)qword_100A19E50, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        unsigned int v9 = "displayAirWaveLaunchNotification: No response";
        goto LABEL_10;
      }
    }
  }
  else
  {
    unsigned int v10 = +[NSURLComponents componentsWithString:@"wayfinder://"];
    [v10 setHost:@"debug"];
    uint64_t v11 = objc_opt_new();
    id v12 = [objc_alloc((Class)NSString) initWithFormat:@"%u", *(unsigned __int8 *)(a1 + 52)];
    int v13 = +[NSURLQueryItem queryItemWithName:@"opcode" value:v12];
    [v11 addObject:v13];

    id v14 = +[NSURLQueryItem queryItemWithName:@"findMySerialNumber" value:*(void *)(a1 + 40)];
    [v11 addObject:v14];

    [v10 setQueryItems:v11];
    __int16 v15 = qword_100A19E50;
    if (os_log_type_enabled((os_log_t)qword_100A19E50, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v16 = [v10 string];
      *(_DWORD *)long long buf = 138543362;
      uint64_t v22 = v16;
      _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "displayAirWaveLaunchNotification: Launching AirWave with URL %{public}@", buf, 0xCu);
    }
    uint64_t v17 = +[LSApplicationWorkspace defaultWorkspace];
    unsigned int v18 = [v10 URL];
    [v17 openURL:v18 configuration:0 completionHandler:&stru_1009C0690];
  }
  *(unsigned char *)(*(void *)(a1 + 32) + 32) = 0;
}

void sub_100728F5C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11)
{
  _Unwind_Resume(a1);
}

void sub_100729020(id a1, NSDictionary *a2, NSError *a3)
{
  id v4 = a2;
  uint64_t v5 = a3;
  id v6 = qword_100A19E50;
  if (os_log_type_enabled((os_log_t)qword_100A19E50, OS_LOG_TYPE_DEFAULT))
  {
    id v7 = [(NSError *)v5 description];
    int v8 = 138412546;
    unsigned int v9 = v4;
    __int16 v10 = 2112;
    uint64_t v11 = v7;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "displayAirWaveLaunchNotification: AirWave launch result %@, error %@", (uint8_t *)&v8, 0x16u);
  }
}

void sub_100729104(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100729478(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21,int a22,__int16 a23,char a24,char a25,void *a26,uint64_t a27,int a28,__int16 a29,char a30,char a31)
{
  _Unwind_Resume(a1);
}

void sub_1007294FC(uint64_t a1)
{
  *(unsigned char *)(*(void *)(a1 + 32) + 32) = 1;
  CFOptionFlags v10 = 0;
  sub_100379650(@"FILE_A_RADAR", @"File a Radar");
  uint64_t v2 = (__CFString *)objc_claimAutoreleasedReturnValue();
  sub_100379650(@"NO_THANKS", @"No thanks");
  id v3 = (__CFString *)objc_claimAutoreleasedReturnValue();
  CFUserNotificationDisplayAlert(0.0, 1uLL, 0, 0, 0, *(CFStringRef *)(a1 + 40), *(CFStringRef *)(a1 + 48), v2, v3, 0, &v10);
  if (v10)
  {
    if (v10 == 1)
    {
      if (qword_1009F8798 != -1) {
        dispatch_once(&qword_1009F8798, &stru_1009C0818);
      }
      int v4 = sub_1003ED54C(qword_1009F8790, a1 + 64, 6, 1u);
      uint64_t v5 = qword_100A19E50;
      if (os_log_type_enabled((os_log_t)qword_100A19E50, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)long long buf = 67109120;
        int v12 = v4;
        _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "showFoundAccessoryCrashAlert: Dismissing crash log (uint64_t result = %d)", buf, 8u);
      }
    }
    else if (os_log_type_enabled((os_log_t)qword_100A19E50, OS_LOG_TYPE_ERROR))
    {
      sub_100799C54();
    }
  }
  else
  {
    if (qword_1009F8798 != -1) {
      dispatch_once(&qword_1009F8798, &stru_1009C0818);
    }
    int v6 = sub_1003ED54C(qword_1009F8790, a1 + 64, 5, 1u);
    id v7 = qword_100A19E50;
    if (os_log_type_enabled((os_log_t)qword_100A19E50, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 67109120;
      int v12 = v6;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "showFoundAccessoryCrashAlert: Requesting crash log (uint64_t result = %d)", buf, 8u);
    }
    if (v6 == 312 || v6 == 12)
    {
      int v8 = +[NSString stringWithFormat:@"Crash retrieval failed as the connection to %@ has been lost.  You will be prompted again after you re-connect.", *(void *)(a1 + 56)];
      sub_100379650(@"OK", @"OK");
      unsigned int v9 = (__CFString *)objc_claimAutoreleasedReturnValue();
      CFUserNotificationDisplayAlert(0.0, 1uLL, 0, 0, 0, @"No Longer Connected", v8, v9, 0, 0, &v10);
    }
  }
  *(unsigned char *)(*(void *)(a1 + 32) + 32) = 0;
}

void sub_1007297D0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100729B94(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21,int a22,__int16 a23,char a24,char a25,void *a26,uint64_t a27,int a28,__int16 a29,char a30,char a31)
{
  _Unwind_Resume(a1);
}

void sub_100729C10(uint64_t a1)
{
  CFOptionFlags v5 = 0;
  sub_100379650(@"FILE_A_RADAR", @"File a Radar");
  uint64_t v2 = (__CFString *)objc_claimAutoreleasedReturnValue();
  sub_100379650(@"NO_THANKS", @"No thanks");
  id v3 = (__CFString *)objc_claimAutoreleasedReturnValue();
  CFUserNotificationDisplayAlert(0.0, 1uLL, 0, 0, 0, *(CFStringRef *)(a1 + 32), *(CFStringRef *)(a1 + 40), v2, v3, 0, &v5);
  if (!v5)
  {
    if (*(unsigned char *)(a1 + 72)) {
      uint64_t v4 = 1;
    }
    else {
      uint64_t v4 = 2;
    }
    [*(id *)(a1 + 48) openTapToRadarWithAccessoryLogs:*(void *)(a1 + 56) reason:v4 pid:*(void *)(a1 + 64)];
  }
}

void sub_100729CD4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_10072A154(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  _Unwind_Resume(a1);
}

void sub_10072A1C8(uint64_t a1)
{
  *(unsigned char *)(*(void *)(a1 + 32) + 32) = 1;
  CFOptionFlags v6 = 0;
  sub_100379650(@"FILE_A_RADAR", @"File a Radar");
  uint64_t v2 = (__CFString *)objc_claimAutoreleasedReturnValue();
  sub_100379650(@"NO_THANKS", @"No thanks");
  id v3 = (__CFString *)objc_claimAutoreleasedReturnValue();
  CFUserNotificationDisplayAlert(0.0, 1uLL, 0, 0, 0, *(CFStringRef *)(a1 + 40), *(CFStringRef *)(a1 + 48), v2, v3, 0, &v6);
  if (!v6)
  {
    if (qword_1009F80A0 != -1) {
      dispatch_once(&qword_1009F80A0, &stru_1009C0838);
    }
    if (sub_1002A86F0((uint64_t)off_1009F8098, *(unsigned int *)(a1 + 76) | ((unint64_t)*(unsigned __int16 *)(a1 + 80) << 32)))
    {
      [*(id *)(a1 + 32) openTapToRadarWithAccessoryLogs:0 reason:*(unsigned int *)(a1 + 72) pid:*(void *)(a1 + 64)];
    }
    else
    {
      +[NSString stringWithFormat:](NSString, "stringWithFormat:", @"Your connection to the %@ does not exist; not opening Tap-to-Radar.  Please re-connect your %@ and file a radar separately.",
        *(void *)(a1 + 56),
        *(void *)(a1 + 56));
      uint64_t v4 = (__CFString *)objc_claimAutoreleasedReturnValue();
      sub_100379650(@"OK", @"OK");
      CFOptionFlags v5 = (__CFString *)objc_claimAutoreleasedReturnValue();
      CFUserNotificationDisplayAlert(0.0, 1uLL, 0, 0, 0, @"No Longer Connected", v4, v5, 0, 0, &v6);
    }
  }
  *(unsigned char *)(*(void *)(a1 + 32) + 32) = 0;
}

void sub_10072A360(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_10072ACAC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  _Unwind_Resume(a1);
}

void sub_10072ADEC(id a1, NSDictionary *a2, NSError *a3)
{
  uint64_t v4 = a2;
  CFOptionFlags v5 = a3;
  if (v5 && os_log_type_enabled((os_log_t)qword_100A19E50, OS_LOG_TYPE_ERROR)) {
    sub_100799DF8();
  }
}

void sub_10072AF70(uint64_t a1)
{
  CFOptionFlags v22 = 0;
  CFUserNotificationDisplayAlert(0.0, 1uLL, 0, 0, 0, @"Your device has BT Issues", @"File a radar now?", @"OK", @"Cancel", 0, &v22);
  if (v22) {
    return;
  }
  int v2 = *(_DWORD *)(a1 + 64);
  switch(v2)
  {
    case 0:
      CFOptionFlags v6 = @"tap-to-radar://new?Title=BT%20Controller%20Crashed&Classification=Crash%2FHang%2FData%20Loss";
LABEL_9:
      unsigned int v9 = [(__CFString *)v6 stringByAppendingString:@"&ComponentID="];

      CFOptionFlags v10 = [v9 stringByAppendingString:*(void *)(a1 + 40)];

      uint64_t v11 = [v10 stringByAppendingString:@"&ComponentName="];

      int v12 = sub_10072B340(*(void **)(a1 + 48));
      int v13 = [v11 stringByAppendingString:v12];

      id v14 = [v13 stringByAppendingString:@"&ComponentVersion="];

      __int16 v15 = sub_10072B340(*(void **)(a1 + 56));
      uint64_t v16 = [v14 stringByAppendingString:v15];

      uint64_t v17 = qword_100A19E50;
      if (os_log_type_enabled((os_log_t)qword_100A19E50, OS_LOG_TYPE_DEFAULT))
      {
        id v18 = [v16 UTF8String];
        *(_DWORD *)long long buf = 136446210;
        id v24 = v18;
        _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "btControllerTapToRadar: Launch TapToRadar URL : %{public}s", buf, 0xCu);
      }
      uint64_t v19 = +[NSURL URLWithString:v16];
      CFOptionFlags v20 = +[LSApplicationWorkspace defaultWorkspace];
      [v20 openURL:v19 configuration:0 completionHandler:&stru_1009C0770];

      return;
    case 2:
      id v7 = sub_10072B340(*(void **)(a1 + 32));
      uint64_t v4 = [@"tap-to-radar://new?Title=" stringByAppendingString:v7];

      uint64_t v5 = [v4 stringByAppendingString:@"&Classification=Security"];
      goto LABEL_8;
    case 1:
      id v3 = sub_10072B340(*(void **)(a1 + 32));
      uint64_t v4 = [@"tap-to-radar://new?Title=BT%20Controller%20Error%20Found%3A%20" stringByAppendingString:v3];

      uint64_t v5 = [v4 stringByAppendingString:@"&Classification=Crash%2FHang%2FData%20Loss"];
LABEL_8:
      int v8 = (__CFString *)v5;

      CFOptionFlags v6 = v8;
      goto LABEL_9;
  }
  id v21 = qword_100A19E50;
  if (os_log_type_enabled((os_log_t)qword_100A19E50, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 67109120;
    LODWORD(v24) = v2;
    _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "Invalid Tap-To-Radar Type %d", buf, 8u);
  }
}

void sub_10072B2B0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id sub_10072B340(void *a1)
{
  id v1 = a1;
  int v2 = +[NSCharacterSet characterSetWithCharactersInString:@"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"];
  id v3 = [v1 stringByAddingPercentEncodingWithAllowedCharacters:v2];

  return v3;
}

void sub_10072B3B8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_10072B47C(id a1)
{
}

void sub_10072B4C0()
{
}

void sub_10072B4E4(id a1)
{
}

void sub_10072B528()
{
}

void sub_10072B54C(id a1)
{
}

void sub_10072B590()
{
}

void sub_10072B5B4(id a1)
{
}

void sub_10072B5F8()
{
}

void sub_10072B61C(id a1)
{
}

void sub_10072B660()
{
}

uint64_t sub_10072B684()
{
  uint64_t result = sub_100052EB4();
  if (result)
  {
    id v1 = *(uint64_t (**)(void))(*(void *)result + 16);
    return v1();
  }
  return result;
}

uint64_t sub_10072B6D8()
{
  uint64_t result = sub_100052EB4();
  if (result)
  {
    id v1 = *(uint64_t (**)(void))(*(void *)result + 32);
    return v1();
  }
  return result;
}

uint64_t sub_10072B748()
{
  uint64_t result = sub_100052EB4();
  if (result)
  {
    id v1 = *(uint64_t (**)(void))(*(void *)result + 40);
    return v1();
  }
  return result;
}

void *sub_10072B7B8(void *a1)
{
  uint64_t v2 = (uint64_t)(a1 + 1);
  *a1 = off_1009C0868;
  a1[1] = &off_1009C0968;
  a1[2] = 0;
  uint64_t v3 = sub_100019878();
  sub_10027710C(a1 + 24, (int)a1, "com.apple.BTServer.le", *(dispatch_queue_t *)(v3 + 8));
  sub_10027714C((uint64_t)(a1 + 3));
  uint64_t v4 = objc_opt_new();
  uint64_t v5 = (void *)a1[2];
  a1[2] = v4;

  if (qword_1009FB240 != -1) {
    dispatch_once(&qword_1009FB240, &stru_1009C0980);
  }
  sub_1004C0E38(qword_1009FB238, v2);
  return a1;
}

void sub_10072B898(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t sub_10072B8C0(uint64_t a1)
{
  *(void *)a1 = off_1009C0868;
  uint64_t v2 = a1 + 8;
  *(void *)(a1 + 8) = &off_1009C0968;
  if (qword_1009FB240 != -1) {
    dispatch_once(&qword_1009FB240, &stru_1009C0980);
  }
  sub_1004C0ECC(qword_1009FB238, v2);
  sub_100277148(a1 + 24);

  return a1;
}

void sub_10072B968(_Unwind_Exception *a1)
{
  sub_100277148(v1 + 24);

  _Unwind_Resume(a1);
}

void sub_10072B988(uint64_t a1)
{
  sub_10072B8C0(a1);

  operator delete();
}

void sub_10072B9C4(uint64_t a1, void *a2)
{
  id v3 = a2;
  xpc_object_t v4 = xpc_dictionary_create(0, 0, 0);
  *(void *)uuid = 0;
  uint64_t v6 = 0;
  [v3 getUUIDBytes:uuid];
  xpc_dictionary_set_uuid(v4, "kPeerIdentifier", uuid);
  sub_100277398(a1 + 24, "ConnectOnce", v4, 0);
}

void sub_10072BA7C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_10072BA9C(uint64_t a1, void *a2)
{
  id v3 = a2;
  xpc_object_t v4 = xpc_dictionary_create(0, 0, 0);
  xpc_object_t v5 = xpc_array_create(0, 0);
  long long v13 = 0u;
  long long v14 = 0u;
  long long v11 = 0u;
  long long v12 = 0u;
  id v6 = v3;
  id v7 = [v6 countByEnumeratingWithState:&v11 objects:v17 count:16];
  if (v7)
  {
    uint64_t v8 = *(void *)v12;
    do
    {
      unsigned int v9 = 0;
      do
      {
        if (*(void *)v12 != v8) {
          objc_enumerationMutation(v6);
        }
        CFOptionFlags v10 = *(void **)(*((void *)&v11 + 1) + 8 * (void)v9);
        *(void *)uuid = 0;
        uint64_t v16 = 0;
        [v10 getUUIDBytes:uuid];
        xpc_array_set_uuid(v5, 0xFFFFFFFFFFFFFFFFLL, uuid);
        unsigned int v9 = (char *)v9 + 1;
      }
      while (v7 != v9);
      id v7 = [v6 countByEnumeratingWithState:&v11 objects:v17 count:16];
    }
    while (v7);
  }

  xpc_dictionary_set_value(v4, "kPeerIdentifiers", v5);
  xpc_release(v5);
  sub_100277398(a1 + 24, "ConnectAlways", v4, 0);
}

void sub_10072BC14(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_10072BC4C(uint64_t a1, unsigned int a2, unsigned int a3)
{
  xpc_object_t v6 = xpc_dictionary_create(0, 0, 0);
  xpc_dictionary_set_uint64(v6, "kPiconetClock", a2);
  xpc_dictionary_set_uint64(v6, "kPiconetPhaseClock", a3);

  sub_100277398(a1 + 24, "NotifyPiconetClock", v6, 0);
}

void sub_10072BCDC(uint64_t a1, void *a2)
{
  id v3 = a2;
  xpc_object_t v4 = xpc_dictionary_create(0, 0, 0);
  *(void *)uuid = 0;
  uint64_t v6 = 0;
  [v3 getUUIDBytes:uuid];
  xpc_dictionary_set_uuid(v4, "kPeerIdentifier", uuid);
  sub_100277398(a1 + 24, "DOAPDeviceConnected", v4, 0);
}

void sub_10072BD94(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_10072BDB0(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v8 = v3;
  if (qword_1009F7EE0 == -1)
  {
    xpc_object_t v4 = v3;
  }
  else
  {
    dispatch_once(&qword_1009F7EE0, &stru_1009C09A0);
    xpc_object_t v4 = v8;
  }
  uint64_t v5 = sub_100030DCC((uint64_t)off_1009F7ED8, v4, 0);
  if (qword_1009F7F00 != -1) {
    dispatch_once(&qword_1009F7F00, &stru_1009C09C0);
  }
  uint64_t v6 = sub_100030F10((uint64_t)off_1009F7EF8, v5, 0);
  if (v6 && sub_100479374(v6)) {
    sub_10072BECC(a1, v8);
  }
  xpc_object_t v7 = xpc_dictionary_create(0, 0, 0);
  sub_100277398(a1 + 24, "UARPDeviceConnected", v7, 0);
}

void sub_10072BEB4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_10072BECC(uint64_t a1, void *a2)
{
  id v3 = a2;
  xpc_object_t v4 = xpc_dictionary_create(0, 0, 0);
  *(void *)uuid = 0;
  uint64_t v6 = 0;
  [v3 getUUIDBytes:uuid];
  xpc_dictionary_set_uuid(v4, "kUARPDeviceUUID", uuid);
  sub_100277398(a1 + 24, "UARPAACPTransportChange", v4, 0);
}

void sub_10072BF84(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_10072BFA4(uint64_t a1, void *a2)
{
  id v3 = a2;
  xpc_object_t v4 = qword_100A19E78;
  if (os_log_type_enabled((os_log_t)qword_100A19E78, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v6 = 0;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Sending HRM connected xpc message", v6, 2u);
  }
  xpc_object_t v5 = xpc_dictionary_create(0, 0, 0);
  sub_100277398(a1 + 24, "HRMDeviceConnected", v5, 0);
}

void sub_10072C04C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_10072C05C(uint64_t a1, unsigned int a2, uint64_t a3)
{
  if (*(char *)(a3 + 23) < 0)
  {
    sub_10003B098(__p, *(void **)a3, *(void *)(a3 + 8));
  }
  else
  {
    *(_OWORD *)std::string __p = *(_OWORD *)a3;
    uint64_t v6 = *(void *)(a3 + 16);
  }
  sub_10072C0EC(a1, a2, (const char *)__p);
  if (SHIBYTE(v6) < 0) {
    operator delete(__p[0]);
  }
}

void sub_10072C0D0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_10072C0EC(uint64_t a1, unsigned int a2, const char *a3)
{
  xpc_object_t v6 = xpc_dictionary_create(0, 0, 0);
  xpc_dictionary_set_uint64(v6, "kEasyPairingVersion", a2);
  if (a3[23] < 0) {
    a3 = *(const char **)a3;
  }
  xpc_dictionary_set_string(v6, "kCloudAccount", a3);

  sub_100277398(a1 + 24, "VersionInfoRequest", v6, 0);
}

void sub_10072C184(uint64_t a1, unsigned int a2, uint64_t a3, unsigned int a4)
{
  if (*(char *)(a3 + 23) < 0)
  {
    sub_10003B098(__p, *(void **)a3, *(void *)(a3 + 8));
  }
  else
  {
    *(_OWORD *)std::string __p = *(_OWORD *)a3;
    uint64_t v8 = *(void *)(a3 + 16);
  }
  sub_10072C224(a1, a2, (const char *)__p, a4);
  if (SHIBYTE(v8) < 0) {
    operator delete(__p[0]);
  }
}

void sub_10072C208(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_10072C224(uint64_t a1, unsigned int a2, const char *a3, unsigned int a4)
{
  xpc_object_t v8 = xpc_dictionary_create(0, 0, 0);
  xpc_dictionary_set_uint64(v8, "kEasyPairingVersion", a2);
  if (a3[23] < 0) {
    a3 = *(const char **)a3;
  }
  xpc_dictionary_set_string(v8, "kCloudAccount", a3);
  xpc_dictionary_set_uint64(v8, "kEasyPairingStatus", a4);

  sub_100277398(a1 + 24, "VersionInfoResponse", v8, 0);
}

void sub_10072C2DC(uint64_t a1, uint64_t a2)
{
  if (*(char *)(a2 + 23) < 0)
  {
    sub_10003B098(__p, *(void **)a2, *(void *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)std::string __p = *(_OWORD *)a2;
    uint64_t v4 = *(void *)(a2 + 16);
  }
  sub_10072C368(a1, (const char *)__p);
  if (SHIBYTE(v4) < 0) {
    operator delete(__p[0]);
  }
}

void sub_10072C34C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_10072C368(uint64_t a1, const char *a2)
{
  xpc_object_t v4 = xpc_dictionary_create(0, 0, 0);
  xpc_object_t v5 = v4;
  if (a2[23] < 0) {
    a2 = *(const char **)a2;
  }
  xpc_dictionary_set_string(v4, "kDeviceAddress", a2);

  sub_100277398(a1 + 24, "ClassicPairStateRequest", v5, 0);
}

void sub_10072C3EC(uint64_t a1, uint64_t a2, unsigned int a3)
{
  if (*(char *)(a2 + 23) < 0)
  {
    sub_10003B098(__p, *(void **)a2, *(void *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)std::string __p = *(_OWORD *)a2;
    uint64_t v6 = *(void *)(a2 + 16);
  }
  sub_10072C480(a1, (const char *)__p, a3);
  if (SHIBYTE(v6) < 0) {
    operator delete(__p[0]);
  }
}

void sub_10072C464(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_10072C480(uint64_t a1, const char *a2, unsigned int a3)
{
  xpc_object_t v6 = xpc_dictionary_create(0, 0, 0);
  xpc_object_t v7 = v6;
  if (a2[23] < 0) {
    a2 = *(const char **)a2;
  }
  xpc_dictionary_set_string(v6, "kDeviceAddress", a2);
  xpc_dictionary_set_uint64(v7, "kDevicePairState", a3);

  sub_100277398(a1 + 24, "ClassicPairStateResponse", v7, 0);
}

void sub_10072C51C(uint64_t a1, uint64_t a2, const char *a3, const void *a4, unsigned int a5)
{
  if (*(char *)(a2 + 23) < 0)
  {
    sub_10003B098(__p, *(void **)a2, *(void *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)std::string __p = *(_OWORD *)a2;
    uint64_t v10 = *(void *)(a2 + 16);
  }
  sub_10072C5C8(a1, (const char *)__p, a3, a4, a5);
  if (SHIBYTE(v10) < 0) {
    operator delete(__p[0]);
  }
}

void sub_10072C5AC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_10072C5C8(uint64_t a1, const char *a2, const char *a3, const void *a4, unsigned int a5)
{
  xpc_object_t v10 = xpc_dictionary_create(0, 0, 0);
  long long v11 = v10;
  if (a2[23] < 0) {
    a2 = *(const char **)a2;
  }
  xpc_dictionary_set_string(v10, "kDeviceAddress", a2);
  xpc_dictionary_set_string(v11, "kDeviceName", a3);
  xpc_dictionary_set_data(v11, "kDeviceLinkKey", a4, a5);

  sub_100277398(a1 + 24, "StoreClassicLinkKeyRequest", v11, 0);
}

void sub_10072C68C(uint64_t a1, uint64_t a2, const char *a3, const void *a4, unsigned int a5, unsigned int a6, unsigned int a7)
{
  if (*(char *)(a2 + 23) < 0)
  {
    sub_10003B098(__p, *(void **)a2, *(void *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)std::string __p = *(_OWORD *)a2;
    uint64_t v14 = *(void *)(a2 + 16);
  }
  sub_10072C750(a1, (const char *)__p, a3, a4, a5, a6, a7);
  if (SHIBYTE(v14) < 0) {
    operator delete(__p[0]);
  }
}

void sub_10072C734(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_10072C750(uint64_t a1, const char *a2, const char *a3, const void *a4, unsigned int a5, unsigned int a6, unsigned int a7)
{
  xpc_object_t v14 = xpc_dictionary_create(0, 0, 0);
  __int16 v15 = v14;
  if (a2[23] < 0) {
    a2 = *(const char **)a2;
  }
  xpc_dictionary_set_string(v14, "kDeviceAddress", a2);
  xpc_dictionary_set_string(v15, "kDeviceName", a3);
  xpc_dictionary_set_data(v15, "kDeviceLinkKey", a4, a5);
  xpc_dictionary_set_uint64(v15, "kDeviceServiceMask", a6);
  xpc_dictionary_set_uint64(v15, "kClassOfDeviceMask", a7);

  sub_100277398(a1 + 24, "StoreClassicLinkKeyRequestExtended", v15, 0);
}

void sub_10072C84C(uint64_t a1, uint64_t a2, void *a3, const char *a4)
{
  id v7 = a3;
  if (*(char *)(a2 + 23) < 0)
  {
    sub_10003B098(__p, *(void **)a2, *(void *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)std::string __p = *(_OWORD *)a2;
    uint64_t v9 = *(void *)(a2 + 16);
  }
  sub_10072C904(a1, (const char *)__p, v7, a4);
  if (SHIBYTE(v9) < 0) {
    operator delete(__p[0]);
  }
}

void sub_10072C8DC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  _Unwind_Resume(a1);
}

void sub_10072C904(uint64_t a1, const char *a2, void *a3, const char *a4)
{
  id v13 = a3;
  xpc_object_t v7 = xpc_dictionary_create(0, 0, 0);
  xpc_object_t v8 = v7;
  if (a2[23] < 0) {
    a2 = *(const char **)a2;
  }
  xpc_dictionary_set_string(v7, "kDeviceAddress", a2);
  xpc_dictionary_set_string(v8, "kDeviceName", a4);
  uint64_t v9 = [v13 objectForKey:@"kCfgMicSide"];
  xpc_dictionary_set_uint64(v8, "kClassicDeviceMicMode", (int)[v9 intValue]);

  xpc_object_t v10 = [v13 objectForKey:@"kCfgInEarMode"];
  xpc_dictionary_set_uint64(v8, "kClassicDeviceInEarEnable", [v10 BOOLValue]);

  long long v11 = [v13 objectForKey:@"kCfgDoubleTap"];
  xpc_dictionary_set_uint64(v8, "kClassicDeviceDoubleTapMode", (int)[v11 intValue]);

  xpc_object_t v12 = sub_1004F0EAC(v13);
  xpc_dictionary_set_value(v8, "kClassicDeviceSettings", v12);
  xpc_release(v12);
  sub_100277398(a1 + 24, "StoreClassicDeviceSettings", v8, 0);
}

void sub_10072CA7C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_10072CAA8(uint64_t a1, uint64_t a2)
{
  if (*(char *)(a2 + 23) < 0)
  {
    sub_10003B098(__p, *(void **)a2, *(void *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)std::string __p = *(_OWORD *)a2;
    uint64_t v4 = *(void *)(a2 + 16);
  }
  sub_10072CB34(a1, (const char *)__p);
  if (SHIBYTE(v4) < 0) {
    operator delete(__p[0]);
  }
}

void sub_10072CB18(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_10072CB34(uint64_t a1, const char *a2)
{
  xpc_object_t v4 = xpc_dictionary_create(0, 0, 0);
  xpc_object_t v5 = v4;
  if (a2[23] < 0) {
    a2 = *(const char **)a2;
  }
  xpc_dictionary_set_string(v4, "kDeviceAddress", a2);

  sub_100277398(a1 + 24, "ClassicDeviceUnexpectedDisconnection", v5, 0);
}

void sub_10072CBB8(uint64_t a1, uint64_t a2, unsigned int a3)
{
  if (*(char *)(a2 + 23) < 0)
  {
    sub_10003B098(__p, *(void **)a2, *(void *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)std::string __p = *(_OWORD *)a2;
    uint64_t v6 = *(void *)(a2 + 16);
  }
  sub_10072CC4C(a1, (const char *)__p, a3);
  if (SHIBYTE(v6) < 0) {
    operator delete(__p[0]);
  }
}

void sub_10072CC30(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_10072CC4C(uint64_t a1, const char *a2, unsigned int a3)
{
  xpc_object_t v6 = xpc_dictionary_create(0, 0, 0);
  xpc_object_t v7 = v6;
  if (a2[23] < 0) {
    a2 = *(const char **)a2;
  }
  xpc_dictionary_set_string(v6, "kDeviceAddress", a2);
  xpc_dictionary_set_uint64(v7, "kQuickDisconnectEnabled", a3);

  sub_100277398(a1 + 24, "ConnectClassicDevice", v7, 0);
}

void sub_10072CCE8(uint64_t a1, uint64_t a2, unsigned int a3)
{
  if (*(char *)(a2 + 23) < 0)
  {
    sub_10003B098(__p, *(void **)a2, *(void *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)std::string __p = *(_OWORD *)a2;
    uint64_t v6 = *(void *)(a2 + 16);
  }
  sub_10072CD7C(a1, (const char *)__p, a3);
  if (SHIBYTE(v6) < 0) {
    operator delete(__p[0]);
  }
}

void sub_10072CD60(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_10072CD7C(uint64_t a1, const char *a2, unsigned int a3)
{
  xpc_object_t v6 = xpc_dictionary_create(0, 0, 0);
  xpc_object_t v7 = v6;
  if (a2[23] < 0) {
    a2 = *(const char **)a2;
  }
  xpc_dictionary_set_string(v6, "kDeviceAddress", a2);
  xpc_dictionary_set_uint64(v7, "kPrimaryBudSide", a3);

  sub_100277398(a1 + 24, "NotifyPrimaryBudSide", v7, 0);
}

void sub_10072CE1C(uint64_t a1, void *a2)
{
  id v3 = a2;
  xpc_object_t v4 = xpc_dictionary_create(0, 0, 0);
  *(void *)uuid = 0;
  uint64_t v6 = 0;
  [v3 getUUIDBytes:uuid];
  xpc_dictionary_set_uuid(v4, "kPeerIdentifier", uuid);
  sub_100277398(a1 + 24, "MFiAccessoryAuth", v4, 0);
}

void sub_10072CED4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_10072CEF4(uint64_t a1, void *a2)
{
  id v4 = a2;
  xpc_object_t v3 = sub_1004F0EAC(v4);
  sub_100277398(a1 + 24, "LaunchBTLEServerWithOptions", v3, 0);
}

void sub_10072CF54(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_10072CF68(uint64_t a1)
{
  xpc_object_t v2 = xpc_dictionary_create(0, 0, 0);

  sub_100277398(a1 + 24, "PreWarmMFiAccessoryAuth", v2, 0);
}

void sub_10072CFC0(uint64_t a1, void *a2, unsigned int a3, const void *a4)
{
  id v7 = a2;
  xpc_object_t v8 = xpc_dictionary_create(0, 0, 0);
  *(void *)uuid = 0;
  uint64_t v10 = 0;
  [v7 getUUIDBytes:uuid];
  xpc_dictionary_set_uuid(v8, "kUARPDeviceUUID", uuid);
  xpc_dictionary_set_data(v8, "kUARPData", a4, a3);
  sub_100277398(a1 + 24, "UARPDataOverAACP", v8, 0);
}

void sub_10072D0A0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_10072D0BC(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  id v7 = a3;
  id v8 = a4;
  if (*(char *)(a2 + 23) < 0)
  {
    sub_10003B098(__p, *(void **)a2, *(void *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)std::string __p = *(_OWORD *)a2;
    uint64_t v10 = *(void *)(a2 + 16);
  }
  sub_10072D184(a1, (const char *)__p, v7, v8);
  if (SHIBYTE(v10) < 0) {
    operator delete(__p[0]);
  }
}

void sub_10072D158(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  _Unwind_Resume(a1);
}

void sub_10072D184(uint64_t a1, const char *a2, void *a3, void *a4)
{
  id v7 = a3;
  id v8 = a4;
  xpc_object_t v9 = xpc_dictionary_create(0, 0, 0);
  uint64_t v10 = v9;
  if (a2[23] < 0) {
    a2 = *(const char **)a2;
  }
  xpc_dictionary_set_string(v9, "kLeaDeviceAddress", a2);
  id v11 = [v7 UUIDString];
  xpc_dictionary_set_string(v10, "kLeaDeviceIdentifier", (const char *)[v11 UTF8String]);

  xpc_object_t v12 = sub_100056D28(v8);
  xpc_dictionary_set_value(v10, "kLeaDeviceTags", v12);
  xpc_release(v12);
  id v13 = qword_100A19E78;
  if (os_log_type_enabled((os_log_t)qword_100A19E78, OS_LOG_TYPE_DEFAULT))
  {
    id v14 = [v7 UUIDString];
    int v15 = 136315138;
    id v16 = [v14 UTF8String];
    _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "Sending requestLeaEasyPairMsg: kLeaDeviceIdentifier = %s", (uint8_t *)&v15, 0xCu);
  }
  sub_100277398(a1 + 24, "LeaEasyPairRequest", v10, 0);
}

void sub_10072D318(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_10072D354(uint64_t a1, uint64_t a2, uint64_t a3, unsigned int a4, const void *a5, const void *a6, const void *a7)
{
  if (*(char *)(a2 + 23) < 0)
  {
    sub_10003B098(__dst, *(void **)a2, *(void *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)__uuid_t dst = *(_OWORD *)a2;
    uint64_t v16 = *(void *)(a2 + 16);
  }
  if (*(char *)(a3 + 23) < 0)
  {
    sub_10003B098(__p, *(void **)a3, *(void *)(a3 + 8));
  }
  else
  {
    *(_OWORD *)std::string __p = *(_OWORD *)a3;
    uint64_t v14 = *(void *)(a3 + 16);
  }
  sub_10072D468(a1, (const char *)__dst, (const char *)__p, a4, a5, a6, a7);
  if (SHIBYTE(v14) < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v16) < 0) {
    operator delete(__dst[0]);
  }
}

void sub_10072D434(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_10072D468(uint64_t a1, const char *a2, const char *a3, unsigned int a4, const void *a5, const void *a6, const void *a7)
{
  xpc_object_t v14 = xpc_dictionary_create(0, 0, 0);
  int v15 = v14;
  if (a2[23] < 0) {
    a2 = *(const char **)a2;
  }
  xpc_dictionary_set_string(v14, "kLeaDeviceAddress", a2);
  if (a3[23] < 0) {
    a3 = *(const char **)a3;
  }
  xpc_dictionary_set_string(v15, "kLeaDeviceName", a3);
  xpc_dictionary_set_uint64(v15, "kLeaDeviceEdiv", a4);
  xpc_dictionary_set_data(v15, "kLeaDeviceRand", a5, 8uLL);
  xpc_dictionary_set_data(v15, "kLeaDeviceLtk", a6, 0x10uLL);
  xpc_dictionary_set_data(v15, "kLeaDeviceIrk", a7, 0x10uLL);

  sub_100277398(a1 + 24, "LeaStoreBondingInfoRequest", v15, 0);
}

void sub_10072D58C(uint64_t a1)
{
  if (qword_1009FB240 != -1) {
    dispatch_once(&qword_1009FB240, &stru_1009C0980);
  }
  BOOL v2 = sub_1004C09B4(qword_1009FB238);

  sub_10072D5F8(a1, v2);
}

void sub_10072D5F8(uint64_t a1, BOOL a2)
{
  xpc_object_t v4 = xpc_dictionary_create(0, 0, 0);
  xpc_dictionary_set_BOOL(v4, "kPersist", a2);

  sub_100277398(a1 + 24, "PersistServerServices", v4, 0);
}

void sub_10072D66C(uint64_t a1, const char *a2, unsigned int a3)
{
  xpc_object_t v6 = xpc_dictionary_create(0, 0, 0);
  id v7 = v6;
  if (a2[23] < 0) {
    a2 = *(const char **)a2;
  }
  xpc_dictionary_set_string(v6, "kDeviceAddress", a2);
  xpc_dictionary_set_uint64(v7, "kStoreClassicLinkKeyResult", a3);

  sub_100277398(a1 + 24, "StoreClassicLinkKeyResponse", v7, 0);
}

void sub_10072D708(uint64_t a1, const char *a2, unsigned int a3)
{
  xpc_object_t v6 = qword_100A19E78;
  if (os_log_type_enabled((os_log_t)qword_100A19E78, OS_LOG_TYPE_DEFAULT))
  {
    v9[0] = 67109120;
    v9[1] = a3;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "Sending LeaEasyPairResponse: status=%d", (uint8_t *)v9, 8u);
  }
  xpc_object_t v7 = xpc_dictionary_create(0, 0, 0);
  id v8 = v7;
  if (a2[23] < 0) {
    a2 = *(const char **)a2;
  }
  xpc_dictionary_set_string(v7, "kLeaDeviceAddress", a2);
  xpc_dictionary_set_uint64(v8, "kLeaDevicePairState", a3);
  sub_100277398(a1 + 24, "LeaEasyPairResponse", v8, 0);
}

void sub_10072D81C(uint64_t a1, const char *a2, unsigned int a3)
{
  xpc_object_t v6 = xpc_dictionary_create(0, 0, 0);
  xpc_object_t v7 = v6;
  if (a2[23] < 0) {
    a2 = *(const char **)a2;
  }
  xpc_dictionary_set_string(v6, "kLeaDeviceAddress", a2);
  xpc_dictionary_set_uint64(v7, "kLeaStoreBondingInfoResult", a3);

  sub_100277398(a1 + 24, "LeaStoreBondingInfoResponse", v7, 0);
}

void sub_10072D8B8(uint64_t a1, const char *a2, void *a3)
{
  xpc_object_t v6 = qword_100A19E78;
  if (os_log_type_enabled((os_log_t)qword_100A19E78, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 136446210;
    *(void *)&uint8_t buf[4] = a2;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "Received XPC message \"%{public}s\"", buf, 0xCu);
  }
  if (!strcmp(a2, "SetConnectionParameters"))
  {
    *(void *)long long buf = 0;
    *(void *)&uint8_t buf[8] = 0;
    uuid = xpc_dictionary_get_uuid(a3, "kPeerIdentifier");
    uuid_copy(buf, uuid);
    double v15 = xpc_dictionary_get_double(a3, "kMinInterval");
    double v16 = xpc_dictionary_get_double(a3, "kPreferredInterval");
    double v17 = xpc_dictionary_get_double(a3, "kMaxInterval");
    unsigned __int16 int64 = xpc_dictionary_get_int64(a3, "kMinCELength");
    unsigned __int16 v19 = xpc_dictionary_get_int64(a3, "kMaxCELength");
    unsigned __int16 v20 = xpc_dictionary_get_int64(a3, "kPreferredPeripheralLatency");
    __int16 v21 = xpc_dictionary_get_int64(a3, "kMaxPeripheralLatency");
    unsigned __int16 v22 = xpc_dictionary_get_int64(a3, "kTimeout");
    xpc_dictionary_get_int64(a3, "kMaxDeferment");
    float v23 = v15;
    float v24 = v16;
    float v25 = v17;
    if (qword_1009F7EC0 != -1) {
      dispatch_once(&qword_1009F7EC0, &stru_1009C09E0);
    }
    sub_10069D688((uint64_t)off_1009F7EB8, buf, int64, v19, v20, v21, v22, v23, v24, v25);
  }
  else if (!strcmp(a2, "AuthenticationDidSucceed"))
  {
    memset(dst, 0, sizeof(dst));
    id v26 = xpc_dictionary_get_uuid(a3, "kPeerIdentifier");
    uuid_copy(dst, v26);
    int64_t v27 = xpc_dictionary_get_int64(a3, "kCertClass");
    memset(buf, 0, sizeof(buf));
    if (v27 == 0x7FFFFFFF) {
      strcpy(buf, "IsMFiAuthenticated");
    }
    else {
      snprintf(buf, 0x20uLL, "IsMFiAuthenticated_CertClass%02X", v27);
    }
    if (qword_1009F7EE0 != -1) {
      dispatch_once(&qword_1009F7EE0, &stru_1009C09A0);
    }
    __int16 v31 = off_1009F7ED8;
    uint64_t v32 = sub_100031234(dst);
    sub_10004191C(__p, buf);
    sub_1006BC69C((uint64_t)v31, v32, (unsigned __int8 *)__p);
    if (v292 < 0) {
      operator delete(__p[0]);
    }
  }
  else if (!strcmp(a2, "AuthenticationDidFail"))
  {
    *(void *)long long buf = 0;
    *(void *)&uint8_t buf[8] = 0;
    unsigned __int8 v28 = xpc_dictionary_get_uuid(a3, "kPeerIdentifier");
    uuid_copy(buf, v28);
    if (qword_1009F7EE0 != -1) {
      dispatch_once(&qword_1009F7EE0, &stru_1009C09A0);
    }
    __int16 v29 = off_1009F7ED8;
    uint64_t v30 = sub_100031234(buf);
    sub_1006B85C0((uint64_t)v29, v30, @"IsMFiAuthenticated");
  }
  else if (!strcmp(a2, "PeerIsUsingBuiltinService"))
  {
    *(void *)long long buf = 0;
    *(void *)&uint8_t buf[8] = 0;
    __int16 v33 = xpc_dictionary_get_uuid(a3, "kPeerIdentifier");
    uuid_copy(buf, v33);
    if (qword_1009F7EE0 != -1) {
      dispatch_once(&qword_1009F7EE0, &stru_1009C09A0);
    }
    unsigned int v34 = off_1009F7ED8;
    __int16 v35 = sub_100031234(buf);
    sub_10004191C(v289, "HasBuiltinServices");
    sub_1006BC69C((uint64_t)v34, v35, (unsigned __int8 *)v289);
    if (v290 < 0) {
      operator delete(v289[0]);
    }
  }
  else if (!strcmp(a2, "PeerIsNotUsingBuiltinService"))
  {
    *(void *)long long buf = 0;
    *(void *)&uint8_t buf[8] = 0;
    int v36 = xpc_dictionary_get_uuid(a3, "kPeerIdentifier");
    uuid_copy(buf, v36);
    if (qword_1009F7EE0 != -1) {
      dispatch_once(&qword_1009F7EE0, &stru_1009C09A0);
    }
    __int16 v37 = off_1009F7ED8;
    uint64_t v38 = sub_100031234(buf);
    sub_1006B85C0((uint64_t)v37, v38, @"HasBuiltinServices");
  }
  else
  {
    if (!strcmp(a2, "DisconnectClassicDevice"))
    {
      memset(buf, 0, 24);
      string = (char *)xpc_dictionary_get_string(a3, "kDeviceAddress");
      sub_10004191C(buf, string);
      *(_WORD *)&v296[4] = 0;
      *(_DWORD *)v296 = 0;
      if (buf[23] >= 0) {
        CFStringRef v40 = buf;
      }
      else {
        CFStringRef v40 = *(unsigned __int8 **)buf;
      }
      if (!sub_1004A82DC((uint64_t)v296, v40))
      {
        if (os_log_type_enabled((os_log_t)qword_100A19E78, OS_LOG_TYPE_ERROR)) {
          sub_100799ED8();
        }
        goto LABEL_136;
      }
      if (qword_1009F7F00 != -1) {
        dispatch_once(&qword_1009F7F00, &stru_1009C09C0);
      }
      uint64_t v41 = sub_1004AA194((uint64_t)off_1009F7EF8, (uint64_t)v296, 1);
      if (!v41)
      {
        __int16 v47 = qword_100A19E78;
        if (os_log_type_enabled((os_log_t)qword_100A19E78, OS_LOG_TYPE_ERROR))
        {
          sub_1004A82EC(v296, dst);
          sub_100799E64((char *)dst, v298, v47);
        }
        goto LABEL_136;
      }
      if (qword_1009F87A8 != -1) {
        dispatch_once(&qword_1009F87A8, &stru_1009C0A00);
      }
      if (sub_10046E654((uint64_t)off_1009F87A0, v41))
      {
        if (qword_1009F8090 != -1) {
          dispatch_once(&qword_1009F8090, &stru_1009C0A20);
        }
        sub_1004D76C0((uint64_t)off_1009F8088, v41, -1);
        goto LABEL_136;
      }
      uint64_t v48 = qword_100A19E78;
      if (!os_log_type_enabled((os_log_t)qword_100A19E78, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_136;
      }
      sub_100474E18(v41, dst);
      if (v304 >= 0) {
        __int16 v49 = dst;
      }
      else {
        __int16 v49 = *(unsigned __int8 **)dst;
      }
      *(_DWORD *)v298 = 136446210;
      *(void *)&v298[4] = v49;
      uint64_t v50 = "Ignoring disconnection request as device \"%{public}s\" is not connected";
      __int16 v51 = v298;
      int v52 = v48;
      uint32_t v53 = 12;
      goto LABEL_102;
    }
    if (!strcmp(a2, "EnableBTSync"))
    {
      id v42 = [objc_alloc((Class)NSUUID) initWithUUIDBytes:xpc_dictionary_get_uuid(a3, "kPeerIdentifier")];
      unsigned __int16 v43 = xpc_dictionary_get_int64(a3, "kPeriod");
      uint64_t v44 = sub_10003FB34();
      (*(void (**)(uint64_t, id, void))(*(void *)v44 + 944))(v44, v42, v43);

      return;
    }
    if (!strcmp(a2, "DevMgmtPipeConnected"))
    {
      id v45 = [objc_alloc((Class)NSUUID) initWithUUIDBytes:xpc_dictionary_get_uuid(a3, "kPeerIdentifier")];
      if (qword_1009F8158 != -1) {
        dispatch_once(&qword_1009F8158, &stru_1009C0A40);
      }
      sub_1004FA758((uint64_t)off_1009F8150, 1);
      [*(id *)(a1 + 16) addObject:v45];
      if (qword_1009F80A0 != -1) {
        dispatch_once(&qword_1009F80A0, &stru_1009C0A60);
      }
      sub_1002903B4((uint64_t)off_1009F8098, v45);
      if (qword_1009F7F20 != -1) {
        dispatch_once(&qword_1009F7F20, &stru_1009C0A80);
      }
      sub_100582854((unsigned char *)qword_1009F7F18, v45);
    }
    else
    {
      if (strcmp(a2, "DevMgmtPipeDisconnected"))
      {
        if (!strcmp(a2, "VersionInfoRequest"))
        {
          unsigned __int8 v55 = xpc_dictionary_get_int64(a3, "kEasyPairingVersion");
          memset(buf, 0, 24);
          int v56 = (char *)xpc_dictionary_get_string(a3, "kCloudAccount");
          sub_10004191C(buf, v56);
          if (qword_1009FB068 != -1) {
            dispatch_once(&qword_1009FB068, &stru_1009C0AA0);
          }
          uint64_t v57 = qword_1009FB060;
          if ((buf[23] & 0x80000000) != 0) {
            sub_10003B098(&__dst, *(void **)buf, *(unint64_t *)&buf[8]);
          }
          else {
            __uuid_t dst = *(std::string *)buf;
          }
          sub_10026E7AC(v57, v55, &__dst);
          if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
            goto LABEL_136;
          }
          int v54 = (void *)__dst.__r_.__value_.__r.__words[0];
          goto LABEL_135;
        }
        if (!strcmp(a2, "VersionInfoResponse"))
        {
          unsigned __int8 v58 = xpc_dictionary_get_int64(a3, "kEasyPairingVersion");
          memset(buf, 0, 24);
          id v59 = (char *)xpc_dictionary_get_string(a3, "kCloudAccount");
          sub_10004191C(buf, v59);
          unsigned __int8 v60 = xpc_dictionary_get_int64(a3, "kEasyPairingStatus");
          if (qword_1009FB068 != -1) {
            dispatch_once(&qword_1009FB068, &stru_1009C0AA0);
          }
          uint64_t v61 = qword_1009FB060;
          if ((buf[23] & 0x80000000) != 0) {
            sub_10003B098(&v287, *(void **)buf, *(unint64_t *)&buf[8]);
          }
          else {
            std::string v287 = *(std::string *)buf;
          }
          sub_10026EC90(v61, v58, &v287, v60);
          if ((SHIBYTE(v287.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
            goto LABEL_136;
          }
          int v54 = (void *)v287.__r_.__value_.__r.__words[0];
          goto LABEL_135;
        }
        if (!strcmp(a2, "ClassicPairStateRequest"))
        {
          memset(buf, 0, 24);
          char v62 = (char *)xpc_dictionary_get_string(a3, "kDeviceAddress");
          sub_10004191C(buf, v62);
          *(_WORD *)&dst[4] = 0;
          *(_DWORD *)uuid_t dst = 0;
          if (buf[23] >= 0) {
            long long v63 = buf;
          }
          else {
            long long v63 = *(unsigned __int8 **)buf;
          }
          if (sub_1004A82DC((uint64_t)dst, v63))
          {
            if (qword_1009FB068 != -1) {
              dispatch_once(&qword_1009FB068, &stru_1009C0AA0);
            }
            sub_10026EDA8(qword_1009FB060, (uint64_t)dst);
          }
          else if (os_log_type_enabled((os_log_t)qword_100A19ED8, OS_LOG_TYPE_ERROR))
          {
            sub_100799F0C();
          }
          goto LABEL_136;
        }
        if (!strcmp(a2, "ClassicPairStateResponse"))
        {
          memset(buf, 0, 24);
          char v64 = (char *)xpc_dictionary_get_string(a3, "kDeviceAddress");
          sub_10004191C(buf, v64);
          unsigned __int8 v65 = xpc_dictionary_get_int64(a3, "kDevicePairState");
          *(_WORD *)&dst[4] = 0;
          *(_DWORD *)uuid_t dst = 0;
          if (buf[23] >= 0) {
            v66 = buf;
          }
          else {
            v66 = *(unsigned __int8 **)buf;
          }
          if (sub_1004A82DC((uint64_t)dst, v66))
          {
            if (qword_1009F7F00 != -1) {
              dispatch_once(&qword_1009F7F00, &stru_1009C09C0);
            }
            uint64_t v67 = sub_1004AA194((uint64_t)off_1009F7EF8, (uint64_t)dst, 1);
            if (qword_1009F80A0 != -1) {
              dispatch_once(&qword_1009F80A0, &stru_1009C0A60);
            }
            sub_100290B74((uint64_t)off_1009F8098, v67, v65);
          }
          else if (os_log_type_enabled((os_log_t)qword_100A19ED8, OS_LOG_TYPE_ERROR))
          {
            sub_100799F40();
          }
          goto LABEL_136;
        }
        if (!strcmp(a2, "StoreClassicLinkKeyRequest"))
        {
          memset(buf, 0, 24);
          uint64_t v69 = (char *)xpc_dictionary_get_string(a3, "kDeviceAddress");
          sub_10004191C(buf, v69);
          memset(dst, 0, sizeof(dst));
          uint64_t v304 = 0;
          unint64_t v70 = (char *)xpc_dictionary_get_string(a3, "kDeviceName");
          sub_10004191C(dst, v70);
          xpc_object_t value = xpc_dictionary_get_value(a3, "kDeviceLinkKey");
          WORD2(v293) = 0;
          LODWORD(v293) = 0;
          if (buf[23] >= 0) {
            unsigned __int8 v72 = buf;
          }
          else {
            unsigned __int8 v72 = *(unsigned __int8 **)buf;
          }
          if (!sub_1004A82DC((uint64_t)&v293, v72))
          {
            if (os_log_type_enabled((os_log_t)qword_100A19ED8, OS_LOG_TYPE_ERROR)) {
              sub_10079A044();
            }
            if ((buf[23] & 0x80000000) != 0)
            {
              sub_10003B098(&v285, *(void **)buf, *(unint64_t *)&buf[8]);
            }
            else
            {
              long long v285 = *(_OWORD *)buf;
              uint64_t v286 = *(void *)&buf[16];
            }
            sub_10072D66C(a1, (const char *)&v285, 1u);
            if ((SHIBYTE(v286) & 0x80000000) == 0) {
              goto LABEL_103;
            }
            uint64_t v112 = (void *)v285;
            goto LABEL_319;
          }
          size_t count = xpc_array_get_count(value);
          if (!value || count != 16)
          {
            if (os_log_type_enabled((os_log_t)qword_100A19ED8, OS_LOG_TYPE_ERROR)) {
              sub_100799F74();
            }
            if ((buf[23] & 0x80000000) != 0)
            {
              sub_10003B098(&v283, *(void **)buf, *(unint64_t *)&buf[8]);
            }
            else
            {
              long long v283 = *(_OWORD *)buf;
              uint64_t v284 = *(void *)&buf[16];
            }
            sub_10072D66C(a1, (const char *)&v283, 1u);
            if ((SHIBYTE(v284) & 0x80000000) == 0) {
              goto LABEL_103;
            }
            uint64_t v112 = (void *)v283;
            goto LABEL_319;
          }
          size_t v74 = 0;
          long long v302 = 0uLL;
          uint64_t v300 = 0;
          uint64_t v301 = 0;
          do
          {
            dst[v74 - 16] = xpc_array_get_int64(value, v74);
            ++v74;
          }
          while (v74 != 16);
          if (qword_1009F7F00 != -1) {
            dispatch_once(&qword_1009F7F00, &stru_1009C09C0);
          }
          v75 = (unsigned __int8 *)sub_1004AA194((uint64_t)off_1009F7EF8, (uint64_t)&v293, 1);
          uint64_t v76 = v75;
          if ((void)v302 != v300 || *((void *)&v302 + 1) != v301)
          {
            memset(v296, 0, 20);
            sub_100600E3C((uint64_t)v296);
            if (qword_1009F8778 != -1) {
              dispatch_once(&qword_1009F8778, &stru_1009C0AC0);
            }
            if (sub_100618630((uint64_t)off_1009F8770, v76, (__n128 *)v296) != 150) {
              goto LABEL_162;
            }
            if (qword_1009F8080 != -1) {
              dispatch_once(&qword_1009F8080, &stru_1009C0AE0);
            }
            if ((sub_100497A84((uint64_t)off_1009F8078, (uint64_t)v76) & 1) == 0)
            {
              sub_100600E5C((uint64_t)v298, &v302, 5u);
              sub_100600E48((__n128 *)v296, (__n128 *)v298);
              nullsub_95(v298);
              if (qword_1009F8778 != -1) {
                dispatch_once(&qword_1009F8778, &stru_1009C0AC0);
              }
              int v143 = sub_100618730((uint64_t)off_1009F8770, v76, (__n128 *)v296, 0);
              if (v143)
              {
                unsigned int v79 = 1;
              }
              else
              {
                v251[0] = 0;
                *(void *)&v298[8] = 0;
                *(void *)v298 = 0;
                sub_100026C30((uint64_t)v251);
                *(void *)v298 = SLODWORD(v251[0]);
                *(void *)&v298[8] = SWORD2(v251[0]);
                sub_100476E14((uint64_t)v76, (uint64_t)dst, v298);
                unsigned int v79 = 0;
              }
              v195 = qword_100A19ED8;
              if (os_log_type_enabled((os_log_t)qword_100A19ED8, OS_LOG_TYPE_DEFAULT))
              {
                v196 = "Failed to store";
                if (!v143) {
                  v196 = "Successfully stored";
                }
                v197 = buf;
                if (buf[23] < 0) {
                  v197 = *(unsigned char **)buf;
                }
                *(_DWORD *)v298 = 136315394;
                *(void *)&v298[4] = v196;
                *(_WORD *)&v298[12] = 2080;
                *(void *)&v298[14] = v197;
                _os_log_impl((void *)&_mh_execute_header, v195, OS_LOG_TYPE_DEFAULT, "%s classic link key for address %s", v298, 0x16u);
              }
            }
            else
            {
LABEL_162:
              uint64_t v78 = qword_100A19ED8;
              unsigned int v79 = 0;
              if (os_log_type_enabled((os_log_t)qword_100A19ED8, OS_LOG_TYPE_DEFAULT))
              {
                if (qword_1009F8080 != -1) {
                  dispatch_once(&qword_1009F8080, &stru_1009C0AE0);
                }
                int v80 = sub_100497A84((uint64_t)off_1009F8078, (uint64_t)v76);
                __n128 v81 = buf;
                if (buf[23] < 0) {
                  __n128 v81 = *(unsigned char **)buf;
                }
                *(_DWORD *)v298 = 67109378;
                *(_DWORD *)&v298[4] = v80;
                *(_WORD *)&v298[8] = 2080;
                *(void *)&v298[10] = v81;
                _os_log_impl((void *)&_mh_execute_header, v78, OS_LOG_TYPE_DEFAULT, "Already stored classic link key (Magic Paired: %d) for address: %s", v298, 0x12u);
                unsigned int v79 = 0;
              }
            }
            if ((buf[23] & 0x80000000) != 0)
            {
              sub_10003B098(&v281, *(void **)buf, *(unint64_t *)&buf[8]);
            }
            else
            {
              long long v281 = *(_OWORD *)buf;
              uint64_t v282 = *(void *)&buf[16];
            }
            sub_10072D66C(a1, (const char *)&v281, v79);
            if ((SHIBYTE(v282) & 0x80000000) == 0) {
              goto LABEL_550;
            }
            v198 = (void *)v281;
            goto LABEL_549;
          }
          if (v75 && sub_100040630(v75))
          {
            if (qword_1009F80A0 != -1) {
              dispatch_once(&qword_1009F80A0, &stru_1009C0A60);
            }
            *((unsigned char *)off_1009F8098 + 431) = 2;
            if (qword_1009F8080 != -1) {
              dispatch_once(&qword_1009F8080, &stru_1009C0AE0);
            }
            int v134 = sub_100497A84((uint64_t)off_1009F8078, (uint64_t)v76);
            BOOL v135 = os_log_type_enabled((os_log_t)qword_100A19ED8, OS_LOG_TYPE_ERROR);
            if (v134)
            {
              if (v135) {
                sub_100799FDC();
              }
              if (qword_1009F8080 == -1) {
                goto LABEL_301;
              }
LABEL_661:
              dispatch_once(&qword_1009F8080, &stru_1009C0AE0);
LABEL_301:
              sub_100497B20((uint64_t)off_1009F8078, v76, 0);
              goto LABEL_103;
            }
            if (v135) {
              sub_10079A010();
            }
            if (qword_1009F8768 == -1)
            {
LABEL_490:
              sub_100611000((uint64_t)off_1009F8760, v76);
              goto LABEL_103;
            }
LABEL_662:
            dispatch_once(&qword_1009F8768, &stru_1009C0B00);
            goto LABEL_490;
          }
          if (!os_log_type_enabled((os_log_t)qword_100A19ED8, OS_LOG_TYPE_ERROR)) {
            goto LABEL_103;
          }
        }
        else
        {
          if (strcmp(a2, "StoreClassicLinkKeyRequestExtended"))
          {
            if (!strcmp(a2, "StoreClassicLinkKeyResponse"))
            {
              memset(buf, 0, 24);
              v98 = (char *)xpc_dictionary_get_string(a3, "kDeviceAddress");
              sub_10004191C(buf, v98);
              unsigned __int8 v99 = xpc_dictionary_get_int64(a3, "kStoreClassicLinkKeyResult");
              *(_WORD *)&dst[4] = 0;
              *(_DWORD *)uuid_t dst = 0;
              if (buf[23] >= 0) {
                int v100 = buf;
              }
              else {
                int v100 = *(unsigned __int8 **)buf;
              }
              if (sub_1004A82DC((uint64_t)dst, v100))
              {
                if (qword_1009F7F00 != -1) {
                  dispatch_once(&qword_1009F7F00, &stru_1009C09C0);
                }
                uint64_t v101 = sub_1004AA194((uint64_t)off_1009F7EF8, (uint64_t)dst, 1);
                if (qword_1009F80A0 != -1) {
                  dispatch_once(&qword_1009F80A0, &stru_1009C0A60);
                }
                sub_100290C30((uint64_t)off_1009F8098, v101, v99);
              }
              else if (os_log_type_enabled((os_log_t)qword_100A19ED8, OS_LOG_TYPE_ERROR))
              {
                sub_10079A078();
              }
              goto LABEL_136;
            }
            if (!strcmp(a2, "StoreClassicDeviceSettings"))
            {
              memset(buf, 0, 24);
              v102 = (char *)xpc_dictionary_get_string(a3, "kDeviceAddress");
              sub_10004191C(buf, v102);
              WORD2(v302) = 0;
              LODWORD(v302) = 0;
              if (buf[23] >= 0) {
                uint64_t v103 = buf;
              }
              else {
                uint64_t v103 = *(unsigned __int8 **)buf;
              }
              if (!sub_1004A82DC((uint64_t)&v302, v103))
              {
                if (os_log_type_enabled((os_log_t)qword_100A19E78, OS_LOG_TYPE_ERROR)) {
                  sub_10079A14C();
                }
                goto LABEL_136;
              }
              int64_t v104 = xpc_dictionary_get_int64(a3, "kClassicDeviceMicMode");
              int64_t v105 = xpc_dictionary_get_int64(a3, "kClassicDeviceInEarEnable");
              int v106 = xpc_dictionary_get_int64(a3, "kClassicDeviceDoubleTapMode");
              xpc_object_t v107 = xpc_dictionary_get_value(a3, "kClassicDeviceSettings");
              xpc_object_t v242 = v107;
              if (v107)
              {
                v108 = sub_100031230(v107);
                int v109 = [v108 allKeys];
                unsigned int v110 = [v109 containsObject:@"kCfgDoubleClickInt"];

                if (v110)
                {
                  v111 = [v108 objectForKey:@"kCfgDoubleClickInt"];
                  unsigned int v244 = [v111 intValue];
                }
                else
                {
                  unsigned int v244 = -1;
                }
                v144 = [v108 allKeys];
                unsigned int v145 = [v144 containsObject:@"kCfgClickHold"];

                if (v145)
                {
                  int v146 = [v108 objectForKey:@"kCfgClickHold"];
                  unsigned int v246 = [v146 intValue];
                }
                else
                {
                  unsigned int v246 = -1;
                }
                v147 = [v108 allKeys];
                unsigned int v148 = [v147 containsObject:@"kCfgClickHoldInt"];

                if (v148)
                {
                  v149 = [v108 objectForKey:@"kCfgClickHoldInt"];
                  unsigned int v243 = [v149 intValue];
                }
                else
                {
                  unsigned int v243 = -1;
                }
                v150 = [v108 allKeys];
                unsigned int v151 = [v150 containsObject:@"kCfgListenModeCfgs"];

                if (v151)
                {
                  v152 = [v108 objectForKey:@"kCfgListenModeCfgs"];
                  unsigned int v245 = [v152 intValue];
                }
                else
                {
                  unsigned int v245 = -1;
                }
                v153 = [v108 allKeys];
                unsigned int v154 = [v153 containsObject:@"kCfgOneBudANCMode"];

                if (v154)
                {
                  v155 = [v108 objectForKey:@"kCfgOneBudANCMode"];
                  unsigned int v241 = [v155 intValue];
                }
                else
                {
                  unsigned int v241 = -1;
                }
                v156 = [v108 allKeys];
                unsigned int v157 = [v156 containsObject:@"kCfgListenMode"];

                if (v157)
                {
                  v158 = [v108 objectForKey:@"kCfgListenMode"];
                  uint64_t v142 = (uint64_t)[v158 intValue];
                }
                else
                {
                  uint64_t v142 = 0xFFFFFFFFLL;
                }
              }
              else
              {
                unsigned int v243 = -1;
                unsigned int v244 = -1;
                unsigned int v245 = -1;
                unsigned int v246 = -1;
                unsigned int v241 = -1;
                uint64_t v142 = 0xFFFFFFFFLL;
              }
              memset(dst, 0, sizeof(dst));
              uint64_t v304 = 0;
              v159 = (char *)xpc_dictionary_get_string(a3, "kDeviceName");
              sub_10004191C(dst, v159);
              if (qword_1009F7F00 != -1) {
                dispatch_once(&qword_1009F7F00, &stru_1009C09C0);
              }
              v160 = (unsigned __int8 *)sub_1004AA194((uint64_t)off_1009F7EF8, (uint64_t)&v302, 1);
              uint64_t v161 = (uint64_t)v160;
              if (v160 && sub_100040630(v160))
              {
                if ((v105 != 0) != sub_100487464(v161) && sub_100478B2C(v161, 1))
                {
                  if (qword_1009F80A0 != -1) {
                    dispatch_once(&qword_1009F80A0, &stru_1009C0A60);
                  }
                  sub_100291D0C((uint64_t)off_1009F8098, v161, v105 != 0, 3u);
                }
                if (sub_10048741C(v161) != v104)
                {
                  if (qword_1009F80A0 != -1) {
                    dispatch_once(&qword_1009F80A0, &stru_1009C0A60);
                  }
                  sub_1002917DC((uint64_t)off_1009F8098, v161, v104, 3u);
                }
                if (sub_10047C698(v161) != v106 && sub_100478B2C(v161, 14))
                {
                  if (qword_1009F80A0 != -1) {
                    dispatch_once(&qword_1009F80A0, &stru_1009C0A60);
                  }
                  sub_100291AC0((uint64_t)off_1009F8098, v161, BYTE1(v106), v106, 3);
                }
                sub_100475EE0(v161, (uint64_t)v298);
                BOOL v162 = sub_100731EF0(v298, dst);
                if (v299 < 0) {
                  operator delete(*(void **)v298);
                }
                if (v162)
                {
                  v163 = qword_100A19E78;
                  if (os_log_type_enabled((os_log_t)qword_100A19E78, OS_LOG_TYPE_DEFAULT))
                  {
                    sub_100475EE0(v161, (uint64_t)v298);
                    if (v299 >= 0) {
                      v164 = v298;
                    }
                    else {
                      v164 = *(unsigned char **)v298;
                    }
                    v165 = dst;
                    if (v304 < 0) {
                      v165 = *(unsigned __int8 **)dst;
                    }
                    *(_DWORD *)v296 = 136315394;
                    *(void *)&v296[4] = v164;
                    *(_WORD *)&v296[12] = 2080;
                    *(void *)&v296[14] = v165;
                    _os_log_impl((void *)&_mh_execute_header, v163, OS_LOG_TYPE_DEFAULT, "StoreClassicDeviceSettings update Device name on Watch side only, oldName = %s, newName = %s", v296, 0x16u);
                    if (v299 < 0) {
                      operator delete(*(void **)v298);
                    }
                  }
                  sub_1004776CC(v161, (uint64_t)dst, 0);
                  sub_1004781A4(v161, (uint64_t *)dst);
                }
                if (v242)
                {
                  if (v246 != -1 && sub_100487714(v161) != v246 && sub_100478B2C(v161, 30))
                  {
                    if (qword_1009F80A0 != -1) {
                      dispatch_once(&qword_1009F80A0, &stru_1009C0A60);
                    }
                    sub_1002859A4((uint64_t)off_1009F8098, v161, 22, v246, 3u);
                  }
                  char v166 = sub_100478B2C(v161, 43);
                  if (v244 == -1) {
                    char v167 = 1;
                  }
                  else {
                    char v167 = v166;
                  }
                  if ((v167 & 1) == 0
                    && sub_10048775C(v161) != v244
                    && ((sub_100478B2C(v161, 29) & 1) != 0 || sub_100487DD4(v161, 128)))
                  {
                    if (qword_1009F80A0 != -1) {
                      dispatch_once(&qword_1009F80A0, &stru_1009C0A60);
                    }
                    sub_1002859A4((uint64_t)off_1009F8098, v161, 23, v244, 3u);
                  }
                  char v168 = sub_100478B2C(v161, 43);
                  if (v243 == -1) {
                    char v169 = 1;
                  }
                  else {
                    char v169 = v168;
                  }
                  if ((v169 & 1) == 0
                    && sub_1004877A4(v161) != v243
                    && ((sub_100478B2C(v161, 30) & 1) != 0 || sub_100487DD4(v161, 128)))
                  {
                    if (qword_1009F80A0 != -1) {
                      dispatch_once(&qword_1009F80A0, &stru_1009C0A60);
                    }
                    sub_1002859A4((uint64_t)off_1009F8098, v161, 24, v243, 3u);
                  }
                  if (v245 != -1 && sub_1004875AC(v161) != v245 && sub_100478B2C(v161, 28))
                  {
                    if (qword_1009F80A0 != -1) {
                      dispatch_once(&qword_1009F80A0, &stru_1009C0A60);
                    }
                    sub_1002859A4((uint64_t)off_1009F8098, v161, 26, v245, 3u);
                  }
                  char v170 = sub_100478B2C(v161, 43);
                  if (v241 == -1) {
                    char v171 = 1;
                  }
                  else {
                    char v171 = v170;
                  }
                  if ((v171 & 1) == 0
                    && v241 != sub_1004877EC(v161)
                    && sub_100478B2C(v161, 16)
                    && sub_100478B2C(v161, 1))
                  {
                    if (qword_1009F80A0 != -1) {
                      dispatch_once(&qword_1009F80A0, &stru_1009C0A60);
                    }
                    sub_1002859A4((uint64_t)off_1009F8098, v161, 27, v241, 3u);
                  }
                  if (v142 != -1
                    && sub_100487564(v161) != v142
                    && sub_100478B2C(v161, 16)
                    && sub_100478B2C(v161, 17))
                  {
                    if (qword_1009F80A0 != -1) {
                      dispatch_once(&qword_1009F80A0, &stru_1009C0A60);
                    }
                    sub_1002859A4((uint64_t)off_1009F8098, v161, 13, v142, 3u);
                  }
                }
              }
              else
              {
                v172 = qword_100A19E78;
                if (os_log_type_enabled((os_log_t)qword_100A19E78, OS_LOG_TYPE_ERROR)) {
                  sub_10079A0AC(&buf[23], buf, v172);
                }
              }
              goto LABEL_103;
            }
            if (!strcmp(a2, "ClassicDeviceUnexpectedDisconnection"))
            {
              memset(buf, 0, 24);
              unint64_t v113 = (char *)xpc_dictionary_get_string(a3, "kDeviceAddress");
              sub_10004191C(buf, v113);
              *(_WORD *)&v296[4] = 0;
              *(_DWORD *)v296 = 0;
              if (buf[23] >= 0) {
                uint64_t v114 = buf;
              }
              else {
                uint64_t v114 = *(unsigned __int8 **)buf;
              }
              if (sub_1004A82DC((uint64_t)v296, v114))
              {
                if (qword_1009F7F00 != -1) {
                  dispatch_once(&qword_1009F7F00, &stru_1009C09C0);
                }
                unint64_t v115 = (unsigned __int8 *)sub_1004AA194((uint64_t)off_1009F7EF8, (uint64_t)v296, 1);
                uint64_t v116 = (uint64_t)v115;
                if (v115 && sub_100040630(v115))
                {
                  v117 = qword_100A19ED8;
                  if (os_log_type_enabled((os_log_t)qword_100A19ED8, OS_LOG_TYPE_DEFAULT))
                  {
                    sub_100474E18(v116, dst);
                    int v118 = SHIBYTE(v304);
                    v119 = *(unsigned __int8 **)dst;
                    BOOL v120 = sub_1004764A0(v116);
                    uint64_t v121 = dst;
                    unint64_t v122 = "not";
                    if (v118 < 0) {
                      uint64_t v121 = v119;
                    }
                    if (v120) {
                      unint64_t v122 = "is";
                    }
                    *(_DWORD *)v298 = 136446466;
                    *(void *)&v298[4] = v121;
                    *(_WORD *)&v298[12] = 2080;
                    *(void *)&v298[14] = v122;
                    _os_log_impl((void *)&_mh_execute_header, v117, OS_LOG_TYPE_DEFAULT, "ClassicDeviceUnexpectedDisconnection: device %{public}s %s connected", v298, 0x16u);
                    if (SHIBYTE(v304) < 0) {
                      operator delete(*(void **)dst);
                    }
                  }
                  if (sub_1004764A0(v116))
                  {
                    if (qword_1009F80A0 != -1) {
                      dispatch_once(&qword_1009F80A0, &stru_1009C0A60);
                    }
                    sub_100291754((uint64_t)off_1009F8098, v116);
                  }
                }
                else if (os_log_type_enabled((os_log_t)qword_100A19ED8, OS_LOG_TYPE_ERROR))
                {
                  sub_10079A180();
                }
              }
              else if (os_log_type_enabled((os_log_t)qword_100A19ED8, OS_LOG_TYPE_ERROR))
              {
                sub_10079A1B4();
              }
              goto LABEL_136;
            }
            if (strcmp(a2, "ConnectClassicDevice"))
            {
              if (!strcmp(a2, "NotifyPrimaryBudSide"))
              {
                memset(buf, 0, 24);
                int v136 = (char *)xpc_dictionary_get_string(a3, "kDeviceAddress");
                sub_10004191C(buf, v136);
                unsigned __int8 v137 = xpc_dictionary_get_int64(a3, "kPrimaryBudSide");
                *(_WORD *)&dst[4] = 0;
                *(_DWORD *)uuid_t dst = 0;
                if (buf[23] >= 0) {
                  v138 = buf;
                }
                else {
                  v138 = *(unsigned __int8 **)buf;
                }
                if (sub_1004A82DC((uint64_t)dst, v138))
                {
                  if (qword_1009F7F00 != -1) {
                    dispatch_once(&qword_1009F7F00, &stru_1009C09C0);
                  }
                  uint64_t v139 = sub_1004AA194((uint64_t)off_1009F7EF8, (uint64_t)dst, 1);
                  if (v139)
                  {
                    if (qword_1009F80A0 != -1) {
                      dispatch_once(&qword_1009F80A0, &stru_1009C0A60);
                    }
                    sub_100292224((uint64_t)off_1009F8098, v139, v137);
                  }
                }
                else if (os_log_type_enabled((os_log_t)qword_100A19E78, OS_LOG_TYPE_ERROR))
                {
                  sub_10079A21C();
                }
                goto LABEL_136;
              }
              if (strcmp(a2, "LeaEasyPairRequest"))
              {
                if (!strcmp(a2, "LeaEasyPairResponse"))
                {
                  memset(buf, 0, 24);
                  v178 = (char *)xpc_dictionary_get_string(a3, "kLeaDeviceAddress");
                  sub_10004191C(buf, v178);
                  unsigned __int8 v179 = xpc_dictionary_get_int64(a3, "kLeaDevicePairState");
                  v180 = qword_100A19E78;
                  if (os_log_type_enabled((os_log_t)qword_100A19E78, OS_LOG_TYPE_DEFAULT))
                  {
                    *(_WORD *)uuid_t dst = 0;
                    _os_log_impl((void *)&_mh_execute_header, v180, OS_LOG_TYPE_DEFAULT, "Received LeaEasyPairResponse", dst, 2u);
                  }
                  *(_WORD *)&dst[4] = 0;
                  *(_DWORD *)uuid_t dst = 0;
                  if (buf[23] >= 0) {
                    v181 = buf;
                  }
                  else {
                    v181 = *(unsigned __int8 **)buf;
                  }
                  if (sub_1004A82DC((uint64_t)dst, v181))
                  {
                    if (qword_1009F7F20 != -1) {
                      dispatch_once(&qword_1009F7F20, &stru_1009C0A80);
                    }
                    int v265 = *(_DWORD *)dst;
                    __int16 v266 = *(_WORD *)&dst[4];
                    sub_100582BB4(qword_1009F7F18, (unsigned __int8 *)&v265, v179);
                    goto LABEL_136;
                  }
                  v207 = qword_100A19E78;
                  if (os_log_type_enabled((os_log_t)qword_100A19E78, OS_LOG_TYPE_DEFAULT))
                  {
                    *(_WORD *)v298 = 0;
                    v208 = "Received invalid device address on LeaEasyPairResponse";
LABEL_585:
                    _os_log_impl((void *)&_mh_execute_header, v207, OS_LOG_TYPE_DEFAULT, v208, v298, 2u);
                  }
LABEL_136:
                  if ((buf[23] & 0x80000000) == 0) {
                    return;
                  }
                  unint64_t v68 = *(void **)buf;
                  goto LABEL_138;
                }
                if (strcmp(a2, "LeaStoreBondingInfoRequest"))
                {
                  if (strcmp(a2, "LeaStoreBondingInfoResponse"))
                  {
                    if (!strcmp(a2, "ANCSNotificationSourceRegistered"))
                    {
                      id v218 = [objc_alloc((Class)NSUUID) initWithUUIDBytes:xpc_dictionary_get_uuid(a3, "kPeerIdentifier")];
                      v219 = qword_100A19E78;
                      if (os_log_type_enabled((os_log_t)qword_100A19E78, OS_LOG_TYPE_DEFAULT))
                      {
                        *(_DWORD *)long long buf = 138412290;
                        *(void *)&uint8_t buf[4] = v218;
                        _os_log_impl((void *)&_mh_execute_header, v219, OS_LOG_TYPE_DEFAULT, "Device %@ has subscribed to ANCSNotificationSource", buf, 0xCu);
                      }
                      if (qword_1009FBC88 != -1) {
                        dispatch_once(&qword_1009FBC88, &stru_1009C0B60);
                      }
                      sub_100602CFC((uint64_t)off_1009FBC80, v218);
                    }
                    else if (!strcmp(a2, "UARPDataOverAACP"))
                    {
                      id v7 = [objc_alloc((Class)NSString) initWithUTF8String:xpc_dictionary_get_string(a3, "kUARPDeviceUUID")];
                      id v8 = [objc_alloc((Class)NSUUID) initWithUUIDString:v7];
                      if (qword_1009F7EE0 != -1) {
                        dispatch_once(&qword_1009F7EE0, &stru_1009C09A0);
                      }
                      uint64_t v9 = sub_100030DCC((uint64_t)off_1009F7ED8, v8, 0);
                      if (qword_1009F7F00 != -1) {
                        dispatch_once(&qword_1009F7F00, &stru_1009C09C0);
                      }
                      uint64_t v10 = sub_100030F10((uint64_t)off_1009F7EF8, v9, 1);
                      if (v10)
                      {
                        *(void *)long long buf = 0;
                        data = xpc_dictionary_get_data(a3, "kUARPData", (size_t *)buf);
                        if (data && *(void *)buf)
                        {
                          xpc_object_t v12 = malloc_type_malloc(*(size_t *)buf, 0x6F805B68uLL);
                          id v13 = v12;
                          if (v12)
                          {
                            memcpy(v12, data, *(size_t *)buf);
                            if (qword_1009F80A0 != -1) {
                              dispatch_once(&qword_1009F80A0, &stru_1009C0A60);
                            }
                            if (sub_100293E28((uint64_t)off_1009F8098, v10, *(unsigned __int16 *)buf, v13))
                            {
                              if (os_log_type_enabled((os_log_t)qword_100A19E78, OS_LOG_TYPE_ERROR)) {
                                sub_10079A3BC();
                              }
                            }
                            free(v13);
                          }
                          else if (os_log_type_enabled((os_log_t)qword_100A19E78, OS_LOG_TYPE_ERROR))
                          {
                            sub_10079A388();
                          }
                        }
                        else if (os_log_type_enabled((os_log_t)qword_100A19E78, OS_LOG_TYPE_ERROR))
                        {
                          sub_10079A354();
                        }
                      }
                      else if (os_log_type_enabled((os_log_t)qword_100A19E78, OS_LOG_TYPE_ERROR))
                      {
                        sub_10079A320();
                      }
                    }
                    return;
                  }
                  memset(buf, 0, 24);
                  v214 = (char *)xpc_dictionary_get_string(a3, "kLeaDeviceAddress");
                  sub_10004191C(buf, v214);
                  unsigned __int8 v215 = xpc_dictionary_get_int64(a3, "kLeaStoreBondingInfoResult");
                  *(_WORD *)&dst[4] = 0;
                  *(_DWORD *)uuid_t dst = 0;
                  if (buf[23] >= 0) {
                    v216 = buf;
                  }
                  else {
                    v216 = *(unsigned __int8 **)buf;
                  }
                  if (sub_1004A82DC((uint64_t)dst, v216))
                  {
                    if (qword_1009F7F20 != -1) {
                      dispatch_once(&qword_1009F7F20, &stru_1009C0A80);
                    }
                    int v247 = *(_DWORD *)dst;
                    __int16 v248 = *(_WORD *)&dst[4];
                    sub_100582CE8(qword_1009F7F18, (unsigned __int8 *)&v247, v215);
                    goto LABEL_136;
                  }
                  v207 = qword_100A19E78;
                  if (os_log_type_enabled((os_log_t)qword_100A19E78, OS_LOG_TYPE_DEFAULT))
                  {
                    *(_WORD *)v298 = 0;
                    v208 = "Received invalid device address on LeaStoreBondingInfoResponse";
                    goto LABEL_585;
                  }
                  goto LABEL_136;
                }
                memset(buf, 0, 24);
                v199 = (char *)xpc_dictionary_get_string(a3, "kLeaDeviceAddress");
                sub_10004191C(buf, v199);
                memset(dst, 0, sizeof(dst));
                uint64_t v304 = 0;
                v200 = (char *)xpc_dictionary_get_string(a3, "kLeaDeviceName");
                sub_10004191C(dst, v200);
                __int16 v201 = xpc_dictionary_get_int64(a3, "kLeaDeviceEdiv");
                __int16 v264 = 0;
                int v263 = 0;
                if (buf[23] >= 0) {
                  v202 = buf;
                }
                else {
                  v202 = *(unsigned __int8 **)buf;
                }
                if (sub_1004A82DC((uint64_t)&v263, v202))
                {
                  uint64_t v293 = 0;
                  *(void *)&v296[8] = 0;
                  *(void *)v296 = 0;
                  long long v302 = 0uLL;
                  size_t length = 0;
                  v203 = (uint64_t *)xpc_dictionary_get_data(a3, "kLeaDeviceRand", &length);
                  if (v203 && length == 8)
                  {
                    uint64_t v293 = *v203;
                    size_t v257 = 0;
                    v204 = xpc_dictionary_get_data(a3, "kLeaDeviceLtk", &v257);
                    if (v204 && v257 == 16)
                    {
                      *(_OWORD *)v296 = *v204;
                      size_t v254 = 0;
                      v205 = (long long *)xpc_dictionary_get_data(a3, "kLeaDeviceIrk", &v254);
                      if (v205 && v254 == 16)
                      {
                        long long v302 = *v205;
                        if (v201)
                        {
                          unint64_t v206 = ((unint64_t)v263 << 40) | ((unint64_t)BYTE1(v263) << 32) | ((unint64_t)BYTE2(v263) << 24) | ((unint64_t)HIBYTE(v263) << 16) | ((unint64_t)v264 << 8) | HIBYTE(v264);
                          uint64_t v300 = 0;
                          uint64_t v301 = 0;
                          if (qword_1009F7EE0 != -1) {
                            dispatch_once(&qword_1009F7EE0, &stru_1009C09A0);
                          }
                          sub_100014B58((uint64_t)off_1009F7ED8, v206, 0, 0, 0, 0, (unsigned __int8 *)&v300);
                          v251[0] = 0;
                          v251[1] = 0;
                          operator new();
                        }
                        v235 = qword_100A19E78;
                        if (os_log_type_enabled((os_log_t)qword_100A19E78, OS_LOG_TYPE_DEFAULT))
                        {
                          *(_WORD *)v298 = 0;
                          _os_log_impl((void *)&_mh_execute_header, v235, OS_LOG_TYPE_DEFAULT, "Received LeaStoreBondingInfoRequest to trigger unpairing", v298, 2u);
                        }
                        *(void *)&v298[8] = 0;
                        *(void *)v298 = 0;
                        if (qword_1009F7EE0 != -1) {
                          dispatch_once(&qword_1009F7EE0, &stru_1009C09A0);
                        }
                        sub_100014B58((uint64_t)off_1009F7ED8, ((unint64_t)v263 << 40) | ((unint64_t)BYTE1(v263) << 32) | ((unint64_t)BYTE2(v263) << 24) | ((unint64_t)HIBYTE(v263) << 16) | ((unint64_t)v264 << 8) | HIBYTE(v264), 0, 0, 0, 0, v298);
                        if (qword_1009F7ED0 != -1) {
                          dispatch_once(&qword_1009F7ED0, &stru_1009C0B40);
                        }
                        uint64_t v236 = qword_1009F7EC8;
                        v237 = sub_100031234(v298);
                        LODWORD(v236) = sub_100008DC4(v236, v237);

                        if (v236)
                        {
                          if (qword_1009F7F20 != -1) {
                            dispatch_once(&qword_1009F7F20, &stru_1009C0A80);
                          }
                          int v249 = v263;
                          __int16 v250 = v264;
                          sub_100582F30(qword_1009F7F18, (unsigned __int8 *)&v249);
                          if (qword_1009F7ED0 != -1) {
                            dispatch_once(&qword_1009F7ED0, &stru_1009C0B40);
                          }
                          uint64_t v238 = qword_1009F7EC8;
                          v239 = sub_100031234(v298);
                          sub_10070BF0C(v238, v239);

                          goto LABEL_103;
                        }
                        uint64_t v240 = qword_100A19E78;
                        if (!os_log_type_enabled((os_log_t)qword_100A19E78, OS_LOG_TYPE_DEFAULT))
                        {
LABEL_103:
                          if ((SHIBYTE(v304) & 0x80000000) == 0) {
                            goto LABEL_136;
                          }
                          int v54 = *(void **)dst;
LABEL_135:
                          operator delete(v54);
                          goto LABEL_136;
                        }
                        LOWORD(v300) = 0;
                        uint64_t v50 = "Device is already unpaired";
                        __int16 v51 = (uint8_t *)&v300;
                        int v52 = v240;
                        uint32_t v53 = 2;
LABEL_102:
                        _os_log_impl((void *)&_mh_execute_header, v52, OS_LOG_TYPE_DEFAULT, v50, v51, v53);
                        goto LABEL_103;
                      }
                      if (os_log_type_enabled((os_log_t)qword_100A19E78, OS_LOG_TYPE_ERROR)) {
                        sub_10079A2EC();
                      }
                      if ((buf[23] & 0x80000000) != 0)
                      {
                        sub_10003B098(&v252, *(void **)buf, *(unint64_t *)&buf[8]);
                      }
                      else
                      {
                        long long v252 = *(_OWORD *)buf;
                        uint64_t v253 = *(void *)&buf[16];
                      }
                      sub_10072D81C(a1, (const char *)&v252, 1u);
                      if ((SHIBYTE(v253) & 0x80000000) == 0) {
                        goto LABEL_103;
                      }
                      uint64_t v112 = (void *)v252;
                    }
                    else
                    {
                      if (os_log_type_enabled((os_log_t)qword_100A19E78, OS_LOG_TYPE_ERROR)) {
                        sub_10079A2B8();
                      }
                      if ((buf[23] & 0x80000000) != 0)
                      {
                        sub_10003B098(&v255, *(void **)buf, *(unint64_t *)&buf[8]);
                      }
                      else
                      {
                        long long v255 = *(_OWORD *)buf;
                        uint64_t v256 = *(void *)&buf[16];
                      }
                      sub_10072D81C(a1, (const char *)&v255, 1u);
                      if ((SHIBYTE(v256) & 0x80000000) == 0) {
                        goto LABEL_103;
                      }
                      uint64_t v112 = (void *)v255;
                    }
                  }
                  else
                  {
                    if (os_log_type_enabled((os_log_t)qword_100A19E78, OS_LOG_TYPE_ERROR)) {
                      sub_10079A284();
                    }
                    if ((buf[23] & 0x80000000) != 0)
                    {
                      sub_10003B098(&v258, *(void **)buf, *(unint64_t *)&buf[8]);
                    }
                    else
                    {
                      long long v258 = *(_OWORD *)buf;
                      uint64_t v259 = *(void *)&buf[16];
                    }
                    sub_10072D81C(a1, (const char *)&v258, 1u);
                    if ((SHIBYTE(v259) & 0x80000000) == 0) {
                      goto LABEL_103;
                    }
                    uint64_t v112 = (void *)v258;
                  }
                }
                else
                {
                  v217 = qword_100A19E78;
                  if (os_log_type_enabled((os_log_t)qword_100A19E78, OS_LOG_TYPE_DEFAULT))
                  {
                    *(_WORD *)v298 = 0;
                    _os_log_impl((void *)&_mh_execute_header, v217, OS_LOG_TYPE_DEFAULT, "Received invalid device address on LeaStoreBondingInfoRequest", v298, 2u);
                  }
                  if ((buf[23] & 0x80000000) != 0)
                  {
                    sub_10003B098(&v261, *(void **)buf, *(unint64_t *)&buf[8]);
                  }
                  else
                  {
                    long long v261 = *(_OWORD *)buf;
                    uint64_t v262 = *(void *)&buf[16];
                  }
                  sub_10072D81C(a1, (const char *)&v261, 1u);
                  if ((SHIBYTE(v262) & 0x80000000) == 0) {
                    goto LABEL_103;
                  }
                  uint64_t v112 = (void *)v261;
                }
LABEL_319:
                operator delete(v112);
                goto LABEL_103;
              }
              memset(buf, 0, 24);
              v173 = (char *)xpc_dictionary_get_string(a3, "kLeaDeviceAddress");
              sub_10004191C(buf, v173);
              memset(dst, 0, sizeof(dst));
              uint64_t v304 = 0;
              v174 = (char *)xpc_dictionary_get_string(a3, "kLeaDeviceIdentifier");
              sub_10004191C(dst, v174);
              v175 = xpc_dictionary_get_value(a3, "kLeaDeviceTags");
              uint64_t v176 = sub_10003FB34();
              if (sub_1003548A0(v176) <= 1)
              {
                if ((buf[23] & 0x80000000) != 0)
                {
                  sub_10003B098(&v273, *(void **)buf, *(unint64_t *)&buf[8]);
                }
                else
                {
                  long long v273 = *(_OWORD *)buf;
                  uint64_t v274 = *(void *)&buf[16];
                }
                sub_10072D708(a1, (const char *)&v273, 3u);
                if ((SHIBYTE(v274) & 0x80000000) == 0) {
                  goto LABEL_103;
                }
                uint64_t v112 = (void *)v273;
                goto LABEL_319;
              }
              *(_WORD *)&v296[4] = 0;
              *(_DWORD *)v296 = 0;
              if (buf[23] >= 0) {
                v182 = buf;
              }
              else {
                v182 = *(unsigned __int8 **)buf;
              }
              if (!sub_1004A82DC((uint64_t)v296, v182))
              {
                if (os_log_type_enabled((os_log_t)qword_100A19ED8, OS_LOG_TYPE_ERROR)) {
                  sub_10079A250();
                }
                goto LABEL_103;
              }
              unint64_t v183 = ((unint64_t)v296[0] << 40) | ((unint64_t)v296[1] << 32) | ((unint64_t)v296[2] << 24) | ((unint64_t)v296[3] << 16) | ((unint64_t)v296[4] << 8) | v296[5];
              *(void *)&v298[8] = 0;
              *(void *)v298 = 0;
              if (qword_1009F7EE0 != -1) {
                dispatch_once(&qword_1009F7EE0, &stru_1009C09A0);
              }
              sub_100014B58((uint64_t)off_1009F7ED8, v183, 1u, 0, 0, 0, v298);
              if (qword_1009F7ED0 != -1) {
                dispatch_once(&qword_1009F7ED0, &stru_1009C0B40);
              }
              uint64_t v184 = qword_1009F7EC8;
              v185 = sub_100031234(v298);
              BOOL v186 = sub_100008DC4(v184, v185);

              if (v175)
              {
                v175 = sub_1004F0EB0(v175);
              }
              v187 = [v175 objectEnumerator];
              if (v187)
              {
                id v188 = 0;
                while (1)
                {
                  uint64_t v189 = [v187 nextObject];

                  if (!v189) {
                    break;
                  }
                  v190 = (void *)v189;
                  if (qword_1009F7EE0 != -1) {
                    dispatch_once(&qword_1009F7EE0, &stru_1009C09A0);
                  }
                  v191 = off_1009F7ED8;
                  v192 = sub_100031234(v298);
                  id v188 = v190;
                  sub_10004191C(v271, (char *)[v188 UTF8String]);
                  sub_1006BC69C((uint64_t)v191, v192, (unsigned __int8 *)v271);
                  if (v272 < 0) {
                    operator delete(v271[0]);
                  }
                }
              }
              if (v186)
              {
                if ((buf[23] & 0x80000000) != 0)
                {
                  sub_10003B098(&v269, *(void **)buf, *(unint64_t *)&buf[8]);
                }
                else
                {
                  long long v269 = *(_OWORD *)buf;
                  uint64_t v270 = *(void *)&buf[16];
                }
                sub_10072D708(a1, (const char *)&v269, 2u);
                if ((SHIBYTE(v270) & 0x80000000) == 0) {
                  goto LABEL_623;
                }
                v234 = (void **)&v269;
              }
              else
              {
                if ((buf[23] & 0x80000000) != 0)
                {
                  sub_10003B098(&v267, *(void **)buf, *(unint64_t *)&buf[8]);
                }
                else
                {
                  long long v267 = *(_OWORD *)buf;
                  uint64_t v268 = *(void *)&buf[16];
                }
                sub_10072D708(a1, (const char *)&v267, 1u);
                if ((SHIBYTE(v268) & 0x80000000) == 0) {
                  goto LABEL_623;
                }
                v234 = (void **)&v267;
              }
              operator delete(*v234);
LABEL_623:

              goto LABEL_103;
            }
            memset(dst, 0, sizeof(dst));
            uint64_t v304 = 0;
            uint64_t v123 = (char *)xpc_dictionary_get_string(a3, "kDeviceAddress");
            sub_10004191C(dst, v123);
            int64_t v124 = xpc_dictionary_get_int64(a3, "kQuickDisconnectEnabled");
            WORD2(v302) = 0;
            LODWORD(v302) = 0;
            if (v304 >= 0) {
              v125 = dst;
            }
            else {
              v125 = *(unsigned __int8 **)dst;
            }
            if (!sub_1004A82DC((uint64_t)&v302, v125))
            {
              if ((_BYTE)v302)
              {
LABEL_334:
                if (os_log_type_enabled((os_log_t)qword_100A19ED8, OS_LOG_TYPE_ERROR)) {
                  sub_10079A21C();
                }
                goto LABEL_339;
              }
              uint64_t v193 = 1;
              while (v193 != 6)
              {
                if (dst[v193++ - 16])
                {
                  if ((unint64_t)(v193 - 2) > 4) {
                    break;
                  }
                  goto LABEL_334;
                }
              }
            }
            if (qword_1009F7F00 != -1) {
              dispatch_once(&qword_1009F7F00, &stru_1009C09C0);
            }
            v126 = (unsigned __int8 *)sub_1004AA194((uint64_t)off_1009F7EF8, (uint64_t)&v302, 0);
            uint64_t v127 = (uint64_t)v126;
            if (v126 && sub_100040630(v126))
            {
              v128 = qword_100A19ED8;
              if (os_log_type_enabled((os_log_t)qword_100A19ED8, OS_LOG_TYPE_DEFAULT))
              {
                sub_100474E18(v127, v298);
                int v129 = v299;
                uint64_t v130 = *(unsigned char **)v298;
                BOOL v131 = sub_1004764A0(v127);
                uint64_t v132 = v298;
                if (v129 < 0) {
                  uint64_t v132 = v130;
                }
                *(_DWORD *)long long buf = 136446722;
                *(void *)&uint8_t buf[4] = v132;
                if (v131) {
                  unint64_t v133 = "is";
                }
                else {
                  unint64_t v133 = "not";
                }
                *(_WORD *)&unsigned char buf[12] = 2080;
                *(void *)&buf[14] = v133;
                *(_WORD *)&unsigned char buf[22] = 1024;
                *(_DWORD *)&uint8_t buf[24] = v124 != 0;
                _os_log_impl((void *)&_mh_execute_header, v128, OS_LOG_TYPE_DEFAULT, "ConnectClassicDevice: device %{public}s %s connected with QuickDisconnectEnabled %d", buf, 0x1Cu);
                if (v299 < 0) {
                  operator delete(*(void **)v298);
                }
              }
              if (sub_1004764A0(v127))
              {
                if (v124)
                {
                  if (qword_1009F8090 != -1) {
                    dispatch_once(&qword_1009F8090, &stru_1009C0A20);
                  }
                  sub_1004D6030((uint64_t)off_1009F8088, (unsigned __int8 *)&v302);
                }
                else
                {
                  uint64_t v225 = sub_100035F54();
                  if ((*(unsigned int (**)(uint64_t))(*(void *)v225 + 352))(v225))
                  {
                    v226 = [*(id *)(a1 + 16) firstObject];
                    if (v226)
                    {
                      if (qword_1009F7EE0 != -1) {
                        dispatch_once(&qword_1009F7EE0, &stru_1009C09A0);
                      }
                      uint64_t v227 = sub_100030DCC((uint64_t)off_1009F7ED8, v226, 0);
                      LOBYTE(v300) = BYTE5(v227);
                      BYTE1(v300) = BYTE4(v227);
                      BYTE2(v300) = BYTE3(v227);
                      BYTE3(v300) = BYTE2(v227);
                      BYTE4(v300) = BYTE1(v227);
                      BYTE5(v300) = v227;
                      v228 = qword_100A19ED8;
                      if (os_log_type_enabled((os_log_t)qword_100A19ED8, OS_LOG_TYPE_DEFAULT))
                      {
                        sub_100474E18(v127, v298);
                        int v229 = v299;
                        v230 = *(unsigned char **)v298;
                        sub_1004A82EC((unsigned __int8 *)&v300, v296);
                        v231 = v298;
                        if (v229 < 0) {
                          v231 = v230;
                        }
                        if (v297 >= 0) {
                          v232 = v296;
                        }
                        else {
                          v232 = *(unsigned char **)v296;
                        }
                        *(_DWORD *)long long buf = 136446723;
                        *(void *)&uint8_t buf[4] = v231;
                        *(_WORD *)&unsigned char buf[12] = 2160;
                        *(void *)&buf[14] = 1752392040;
                        *(_WORD *)&unsigned char buf[22] = 2081;
                        *(void *)&uint8_t buf[24] = v232;
                        _os_log_impl((void *)&_mh_execute_header, v228, OS_LOG_TYPE_DEFAULT, "ConnectClassicDevice: already in triangle, device %{public}s, peerSource %{private, mask.hash}s", buf, 0x20u);
                        if (v297 < 0) {
                          operator delete(*(void **)v296);
                        }
                        if (v299 < 0) {
                          operator delete(*(void **)v298);
                        }
                      }
                      if (qword_1009F80A0 != -1) {
                        dispatch_once(&qword_1009F80A0, &stru_1009C0A60);
                      }
                      sub_10028BB94((uint64_t)off_1009F8098, v127, 0);
                    }
                    else if (os_log_type_enabled((os_log_t)qword_100A19ED8, OS_LOG_TYPE_ERROR))
                    {
                      sub_10079A1E8();
                    }
                  }
                  else
                  {
                    v233 = qword_100A19ED8;
                    if (os_log_type_enabled((os_log_t)qword_100A19ED8, OS_LOG_TYPE_DEFAULT))
                    {
                      *(_WORD *)long long buf = 0;
                      _os_log_impl((void *)&_mh_execute_header, v233, OS_LOG_TYPE_DEFAULT, "Device already connected ignoring connect classic request", buf, 2u);
                    }
                  }
                }
              }
              else
              {
                if (qword_1009F7EB0 != -1) {
                  dispatch_once(&qword_1009F7EB0, &stru_1009C0B20);
                }
                if (sub_1004B4758())
                {
                  v209 = qword_100A19ED8;
                  if (os_log_type_enabled((os_log_t)qword_100A19ED8, OS_LOG_TYPE_DEFAULT))
                  {
                    sub_100474E18(v127, buf);
                    v210 = buf[23] >= 0 ? buf : *(unsigned char **)buf;
                    *(_DWORD *)v298 = 136446466;
                    *(void *)&v298[4] = v210;
                    *(_WORD *)&v298[12] = 2080;
                    *(void *)&v298[14] = "enabled";
                    _os_log_impl((void *)&_mh_execute_header, v209, OS_LOG_TYPE_DEFAULT, "Ignoring ConnectClassicDevice msg for %{public}s, Denylist is %s", v298, 0x16u);
                    if ((buf[23] & 0x80000000) != 0) {
                      operator delete(*(void **)buf);
                    }
                  }
                }
                else
                {
                  if (qword_1009F8090 != -1) {
                    dispatch_once(&qword_1009F8090, &stru_1009C0A20);
                  }
                  memset(buf, 0, 24);
                  sub_1004D2DCC((int64x2_t *)off_1009F8088, v127, -1, (const std::string *)buf, 2);
                  if ((buf[23] & 0x80000000) != 0) {
                    operator delete(*(void **)buf);
                  }
                  CFStringRef v294 = @"wxAddress";
                  v220 = +[NSNumber numberWithUnsignedLongLong:sub_100443A1C((unsigned __int8 *)(v127 + 128))];
                  v295 = v220;
                  v221 = +[NSDictionary dictionaryWithObjects:&v295 forKeys:&v294 count:1];

                  v222 = qword_100A19ED8;
                  if (os_log_type_enabled((os_log_t)qword_100A19ED8, OS_LOG_TYPE_DEFAULT))
                  {
                    sub_100474E18(v127, buf);
                    v223 = buf[23] >= 0 ? buf : *(unsigned char **)buf;
                    *(_DWORD *)v298 = 136446210;
                    *(void *)&v298[4] = v223;
                    _os_log_impl((void *)&_mh_execute_header, v222, OS_LOG_TYPE_DEFAULT, "ConnectClassicDevice: Sending notification to AAD for device %{public}s,", v298, 0xCu);
                    if ((buf[23] & 0x80000000) != 0) {
                      operator delete(*(void **)buf);
                    }
                  }
                  v224 = +[NSDistributedNotificationCenter defaultCenter];
                  [v224 postNotificationName:@"com.apple.BTServer.TriangleRecoveryInitiated" object:0 userInfo:v221];
                }
              }
            }
            else if (os_log_type_enabled((os_log_t)qword_100A19ED8, OS_LOG_TYPE_ERROR))
            {
              sub_10079A180();
            }
LABEL_339:
            if ((SHIBYTE(v304) & 0x80000000) == 0) {
              return;
            }
            unint64_t v68 = *(void **)dst;
LABEL_138:
            operator delete(v68);
            return;
          }
          memset(buf, 0, 24);
          int v82 = (char *)xpc_dictionary_get_string(a3, "kDeviceAddress");
          sub_10004191C(buf, v82);
          memset(dst, 0, sizeof(dst));
          uint64_t v304 = 0;
          int v83 = (char *)xpc_dictionary_get_string(a3, "kDeviceName");
          sub_10004191C(dst, v83);
          xpc_object_t v84 = xpc_dictionary_get_value(a3, "kDeviceLinkKey");
          int v85 = xpc_dictionary_get_int64(a3, "kDeviceServiceMask");
          int64_t v86 = xpc_dictionary_get_int64(a3, "kClassOfDeviceMask");
          WORD2(v293) = 0;
          LODWORD(v293) = 0;
          if (buf[23] >= 0) {
            uint64_t v87 = buf;
          }
          else {
            uint64_t v87 = *(unsigned __int8 **)buf;
          }
          if (!sub_1004A82DC((uint64_t)&v293, v87))
          {
            if (os_log_type_enabled((os_log_t)qword_100A19ED8, OS_LOG_TYPE_ERROR)) {
              sub_10079A044();
            }
            if ((buf[23] & 0x80000000) != 0)
            {
              sub_10003B098(&v279, *(void **)buf, *(unint64_t *)&buf[8]);
            }
            else
            {
              long long v279 = *(_OWORD *)buf;
              uint64_t v280 = *(void *)&buf[16];
            }
            sub_10072D66C(a1, (const char *)&v279, 1u);
            if ((SHIBYTE(v280) & 0x80000000) == 0) {
              goto LABEL_103;
            }
            uint64_t v112 = (void *)v279;
            goto LABEL_319;
          }
          size_t v88 = xpc_array_get_count(v84);
          if (!v84 || v88 != 16)
          {
            if (os_log_type_enabled((os_log_t)qword_100A19ED8, OS_LOG_TYPE_ERROR)) {
              sub_100799F74();
            }
            if ((buf[23] & 0x80000000) != 0)
            {
              sub_10003B098(v277, *(void **)buf, *(unint64_t *)&buf[8]);
            }
            else
            {
              *(_OWORD *)v277 = *(_OWORD *)buf;
              uint64_t v278 = *(void *)&buf[16];
            }
            sub_10072D66C(a1, (const char *)v277, 1u);
            if ((SHIBYTE(v278) & 0x80000000) == 0) {
              goto LABEL_103;
            }
            uint64_t v112 = v277[0];
            goto LABEL_319;
          }
          size_t v89 = 0;
          long long v302 = 0uLL;
          uint64_t v300 = 0;
          uint64_t v301 = 0;
          do
          {
            dst[v89 - 16] = xpc_array_get_int64(v84, v89);
            ++v89;
          }
          while (v89 != 16);
          if (qword_1009F7F00 != -1) {
            dispatch_once(&qword_1009F7F00, &stru_1009C09C0);
          }
          int v90 = (unsigned __int8 *)sub_1004AA194((uint64_t)off_1009F7EF8, (uint64_t)&v293, 1);
          uint64_t v76 = v90;
          if ((void)v302 != v300 || *((void *)&v302 + 1) != v301)
          {
            if (v86)
            {
              if (qword_1009F7F00 != -1) {
                dispatch_once(&qword_1009F7F00, &stru_1009C09C0);
              }
              sub_1004AA7FC((uint64_t)off_1009F7EF8, (uint64_t)v76, v86);
            }
            if (v85)
            {
              unsigned int v92 = 0;
              do
              {
                int v93 = 1 << v92;
                if (((1 << v92) & v85) != 0)
                {
                  *(void *)v296 = 0;
                  *(void *)&v298[8] = 0;
                  *(void *)v298 = 0;
                  sub_100026C30((uint64_t)v296);
                  *(void *)v298 = *(int *)v296;
                  *(void *)&v298[8] = *(__int16 *)&v296[4];
                  sub_100477F4C((uint64_t)v76, v93 & v85, 4, v298, 0);
                }
                if (v92 > 0x1E) {
                  break;
                }
                v85 &= ~v93;
                ++v92;
              }
              while (v85);
            }
            memset(v296, 0, 20);
            sub_100600E3C((uint64_t)v296);
            if (qword_1009F8778 != -1) {
              dispatch_once(&qword_1009F8778, &stru_1009C0AC0);
            }
            if (sub_100618630((uint64_t)off_1009F8770, v76, (__n128 *)v296) != 150) {
              goto LABEL_200;
            }
            if (qword_1009F8080 != -1) {
              dispatch_once(&qword_1009F8080, &stru_1009C0AE0);
            }
            if ((sub_100497A84((uint64_t)off_1009F8078, (uint64_t)v76) & 1) == 0)
            {
              sub_100600E5C((uint64_t)v298, &v302, 5u);
              sub_100600E48((__n128 *)v296, (__n128 *)v298);
              nullsub_95(v298);
              if (qword_1009F8778 != -1) {
                dispatch_once(&qword_1009F8778, &stru_1009C0AC0);
              }
              int v177 = sub_100618730((uint64_t)off_1009F8770, v76, (__n128 *)v296, 0);
              if (v177)
              {
                unsigned int v95 = 1;
              }
              else
              {
                v251[0] = 0;
                *(void *)&v298[8] = 0;
                *(void *)v298 = 0;
                sub_100026C30((uint64_t)v251);
                *(void *)v298 = SLODWORD(v251[0]);
                *(void *)&v298[8] = SWORD2(v251[0]);
                sub_100476E14((uint64_t)v76, (uint64_t)dst, v298);
                unsigned int v95 = 0;
              }
              v211 = qword_100A19ED8;
              if (os_log_type_enabled((os_log_t)qword_100A19ED8, OS_LOG_TYPE_DEFAULT))
              {
                v212 = "Failed to store";
                if (!v177) {
                  v212 = "Successfully stored";
                }
                v213 = buf;
                if (buf[23] < 0) {
                  v213 = *(unsigned char **)buf;
                }
                *(_DWORD *)v298 = 136315394;
                *(void *)&v298[4] = v212;
                *(_WORD *)&v298[12] = 2080;
                *(void *)&v298[14] = v213;
                _os_log_impl((void *)&_mh_execute_header, v211, OS_LOG_TYPE_DEFAULT, "%s classic link key for address %s", v298, 0x16u);
              }
            }
            else
            {
LABEL_200:
              uint64_t v94 = qword_100A19ED8;
              unsigned int v95 = 0;
              if (os_log_type_enabled((os_log_t)qword_100A19ED8, OS_LOG_TYPE_DEFAULT))
              {
                if (qword_1009F8080 != -1) {
                  dispatch_once(&qword_1009F8080, &stru_1009C0AE0);
                }
                int v96 = sub_100497A84((uint64_t)off_1009F8078, (uint64_t)v76);
                unint64_t v97 = buf;
                if (buf[23] < 0) {
                  unint64_t v97 = *(unsigned char **)buf;
                }
                *(_DWORD *)v298 = 67109378;
                *(_DWORD *)&v298[4] = v96;
                *(_WORD *)&v298[8] = 2080;
                *(void *)&v298[10] = v97;
                _os_log_impl((void *)&_mh_execute_header, v94, OS_LOG_TYPE_DEFAULT, "Already stored classic link key (Magic Paired: %d) for address: %s", v298, 0x12u);
                unsigned int v95 = 0;
              }
            }
            if ((buf[23] & 0x80000000) != 0)
            {
              sub_10003B098(v275, *(void **)buf, *(unint64_t *)&buf[8]);
            }
            else
            {
              *(_OWORD *)v275 = *(_OWORD *)buf;
              uint64_t v276 = *(void *)&buf[16];
            }
            sub_10072D66C(a1, (const char *)v275, v95);
            if ((SHIBYTE(v276) & 0x80000000) == 0) {
              goto LABEL_550;
            }
            v198 = v275[0];
LABEL_549:
            operator delete(v198);
LABEL_550:
            nullsub_95(v296);
            goto LABEL_103;
          }
          if (v90 && sub_100040630(v90))
          {
            if (qword_1009F80A0 != -1) {
              dispatch_once(&qword_1009F80A0, &stru_1009C0A60);
            }
            *((unsigned char *)off_1009F8098 + 431) = 2;
            if (qword_1009F8080 != -1) {
              dispatch_once(&qword_1009F8080, &stru_1009C0AE0);
            }
            int v140 = sub_100497A84((uint64_t)off_1009F8078, (uint64_t)v76);
            BOOL v141 = os_log_type_enabled((os_log_t)qword_100A19ED8, OS_LOG_TYPE_ERROR);
            if (v140)
            {
              if (v141) {
                sub_100799FDC();
              }
              if (qword_1009F8080 == -1) {
                goto LABEL_301;
              }
              goto LABEL_661;
            }
            if (v141) {
              sub_10079A010();
            }
            if (qword_1009F8768 == -1) {
              goto LABEL_490;
            }
            goto LABEL_662;
          }
          if (!os_log_type_enabled((os_log_t)qword_100A19ED8, OS_LOG_TYPE_ERROR)) {
            goto LABEL_103;
          }
        }
        sub_100799FA8();
        goto LABEL_103;
      }
      id v46 = [objc_alloc((Class)NSUUID) initWithUUIDBytes:xpc_dictionary_get_uuid(a3, "kPeerIdentifier")];
      if (qword_1009F8158 != -1) {
        dispatch_once(&qword_1009F8158, &stru_1009C0A40);
      }
      sub_1004FA758((uint64_t)off_1009F8150, 0);
      [*(id *)(a1 + 16) removeObject:v46];
      if (qword_1009F80A0 != -1) {
        dispatch_once(&qword_1009F80A0, &stru_1009C0A60);
      }
      sub_100290864((uint64_t)off_1009F8098, v46);
      if (qword_1009F7F20 != -1) {
        dispatch_once(&qword_1009F7F20, &stru_1009C0A80);
      }
      sub_1005829D4(qword_1009F7F18, v46);
    }
  }
}

void sub_1007318DC(_Unwind_Exception *a1)
{
  if (*(char *)(v2 - 185) < 0) {
    operator delete(*(void **)(v2 - 208));
  }
  if (*(char *)(v2 - 153) < 0) {
    operator delete(*(void **)(v2 - 176));
  }
  _Unwind_Resume(a1);
}

BOOL sub_100731EF0(unsigned __int8 *a1, unsigned __int8 *a2)
{
  uint64_t v2 = a1[23];
  if ((v2 & 0x80u) == 0) {
    uint64_t v3 = a1[23];
  }
  else {
    uint64_t v3 = *((void *)a1 + 1);
  }
  uint64_t v4 = a2[23];
  int v5 = (char)v4;
  if ((v4 & 0x80u) != 0) {
    uint64_t v4 = *((void *)a2 + 1);
  }
  if (v3 != v4) {
    return 1;
  }
  if (v5 < 0) {
    a2 = *(unsigned __int8 **)a2;
  }
  if ((v2 & 0x80) != 0) {
    return memcmp(*(const void **)a1, a2, *((void *)a1 + 1)) != 0;
  }
  if (a1[23])
  {
    uint64_t v6 = v2 - 1;
    do
    {
      int v8 = *a1++;
      int v7 = v8;
      int v9 = *a2++;
      BOOL v10 = v7 == v9;
      uint64_t v2 = v7 != v9;
      BOOL v10 = !v10 || v6-- == 0;
    }
    while (!v10);
  }
  return v2;
}

void sub_100731F88(uint64_t a1)
{
  if (qword_1009F8748 != -1) {
    dispatch_once(&qword_1009F8748, &stru_1009C0B80);
  }
  if (sub_100028CB4((uint64_t)off_1009F8740) == 1)
  {
    if (qword_1009F7EE0 != -1) {
      dispatch_once(&qword_1009F7EE0, &stru_1009C09A0);
    }
    sub_1006C3418((uint64_t)off_1009F7ED8);
    id v4 = (id)objc_claimAutoreleasedReturnValue();
    if ([v4 count]) {
      sub_10072BA9C(a1, v4);
    }
    if (qword_1009FB240 != -1) {
      dispatch_once(&qword_1009FB240, &stru_1009C0980);
    }
    if (sub_1004C09B4(qword_1009FB238)) {
      sub_10072D5F8(a1, 1);
    }
    uint64_t v2 = sub_100732164();
    if (v2) {
      (*(void (**)(uint64_t, void *))(*(void *)a1 + 48))(a1, v2);
    }
    uint64_t v3 = sub_1007324C8();
    if (v3) {
      (*(void (**)(uint64_t, void *))(*(void *)a1 + 56))(a1, v3);
    }
  }
}

void sub_100732130(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

id sub_100732164()
{
  double v17 = 0;
  id v18 = 0;
  uint64_t v19 = 0;
  if (qword_1009F87A8 != -1) {
    dispatch_once(&qword_1009F87A8, &stru_1009C0A00);
  }
  sub_10046E85C((uint64_t)off_1009F87A0, &v17);
  std::string __p = 0;
  double v15 = 0;
  double v16 = 0;
  long long v20 = xmmword_1007BA834;
  int v21 = 1729713604;
  sub_100035F98(&v22, (__n128 *)&v20);
  uint64_t v0 = (char *)sub_10003767C((uint64_t)&v16, 1uLL);
  uint64_t v2 = &v0[20 * v1];
  __n128 v3 = v22;
  *((_DWORD *)v0 + 4) = v23;
  *(__n128 *)uint64_t v0 = v3;
  id v4 = v0 + 20;
  uint64_t v6 = (char *)__p;
  int v5 = v15;
  if (v15 != __p)
  {
    do
    {
      long long v7 = *(_OWORD *)(v5 - 20);
      *((_DWORD *)v0 - 1) = *((_DWORD *)v5 - 1);
      *(_OWORD *)(v0 - 20) = v7;
      v0 -= 20;
      v5 -= 20;
    }
    while (v5 != v6);
    int v5 = (char *)__p;
  }
  std::string __p = v0;
  double v15 = v4;
  double v16 = v2;
  if (v5) {
    operator delete(v5);
  }
  double v15 = v4;
  int v8 = (uint64_t *)v17;
  if (v17 == v18)
  {
LABEL_16:
    xpc_object_t v12 = 0;
  }
  else
  {
    while (1)
    {
      uint64_t v9 = *v8;
      if (sub_100478B2C(*v8, 22))
      {
        __n128 v22 = 0uLL;
        if (qword_1009F7EE0 != -1) {
          dispatch_once(&qword_1009F7EE0, &stru_1009C09A0);
        }
        sub_1006C0414((uint64_t)off_1009F7ED8, (unsigned __int8 *)(v9 + 128), (unsigned __int8 *)&v22);
        if (qword_1009F7F10 != -1) {
          dispatch_once(&qword_1009F7F10, &stru_1009C0BA0);
        }
        uint64_t v10 = qword_1009F7F08;
        id v11 = sub_100031234((const unsigned __int8 *)&v22);
        LODWORD(v10) = sub_10063C4FC(v10, v11, (long long **)&__p, 1, 0, 0);

        if (v10) {
          break;
        }
      }
      if (++v8 == v18) {
        goto LABEL_16;
      }
    }
    xpc_object_t v12 = sub_100031234((const unsigned __int8 *)&v22);
  }
  if (__p)
  {
    double v15 = (char *)__p;
    operator delete(__p);
  }
  if (v17)
  {
    id v18 = (uint64_t *)v17;
    operator delete(v17);
  }

  return v12;
}

void sub_100732474(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, void *a12, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  if (a12) {
    operator delete(a12);
  }
  _Unwind_Resume(exception_object);
}

id sub_1007324C8()
{
  id v11 = 0;
  xpc_object_t v12 = 0;
  uint64_t v13 = 0;
  if (qword_1009F87A8 != -1) {
    dispatch_once(&qword_1009F87A8, &stru_1009C0A00);
  }
  sub_10046E85C((uint64_t)off_1009F87A0, &v11);
  uint64_t v1 = (char *)v11;
  uint64_t v2 = v12;
  if (v11 == v12)
  {
    uint64_t v0 = 0;
    if (v11)
    {
LABEL_17:
      xpc_object_t v12 = v1;
      operator delete(v1);
    }
  }
  else
  {
    while (1)
    {
      if (sub_100478B2C(*(void *)v1, 23))
      {
        v18[0] = 0;
        v18[1] = 0;
        if (qword_1009F7EE0 != -1) {
          dispatch_once(&qword_1009F7EE0, &stru_1009C09A0);
        }
        sub_1006C0414((uint64_t)off_1009F7ED8, (unsigned __int8 *)(*(void *)v1 + 128), (unsigned __int8 *)v18);
        std::string __p = 0;
        uint64_t v9 = 0;
        uint64_t v10 = 0;
        long long v14 = xmmword_1007BA848;
        int v15 = 2027922698;
        sub_100035F98(&v16, (__n128 *)&v14);
        __n128 v3 = (__n128 *)operator new(0x14uLL);
        uint64_t v9 = &v3[1].n128_u8[4];
        uint64_t v10 = &v3[1].n128_i8[4];
        *__n128 v3 = v16;
        v3[1].n128_u32[0] = v17;
        std::string __p = v3;
        if (qword_1009F7F10 != -1) {
          dispatch_once(&qword_1009F7F10, &stru_1009C0BA0);
        }
        uint64_t v4 = qword_1009F7F08;
        int v5 = sub_100031234((const unsigned __int8 *)v18);
        int v6 = sub_10063C4FC(v4, v5, (long long **)&__p, 1, 0, 1);

        if (v6)
        {
          uint64_t v0 = sub_100031234((const unsigned __int8 *)v18);
        }
        if (__p)
        {
          uint64_t v9 = (unsigned __int8 *)__p;
          operator delete(__p);
        }
        if (v6) {
          break;
        }
      }
      v1 += 8;
      if (v1 == v2)
      {
        uint64_t v0 = 0;
        break;
      }
    }
    uint64_t v1 = (char *)v11;
    if (v11) {
      goto LABEL_17;
    }
  }

  return v0;
}

void sub_1007326FC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_10073275C(uint64_t a1)
{
}

void sub_100732764(uint64_t a1)
{
}

void sub_100732770(id a1)
{
}

void sub_1007327B4()
{
}

void sub_1007327D8(id a1)
{
}

void sub_10073281C()
{
}

void sub_100732840(id a1)
{
}

void sub_100732884()
{
}

void sub_1007328A8(id a1)
{
}

void sub_1007328EC()
{
}

void sub_100732910(id a1)
{
}

void sub_100732954()
{
}

void sub_100732978(id a1)
{
}

void sub_1007329BC()
{
}

void sub_1007329E0(id a1)
{
}

void sub_100732B70()
{
}

void sub_100732B94(id a1)
{
}

void sub_100732BD8()
{
}

void sub_100732BFC(id a1)
{
}

void sub_100732C40()
{
}

void sub_100732C64(id a1)
{
}

void sub_100732CA8()
{
}

void sub_100732CCC(id a1)
{
}

void sub_100732D10()
{
}

void sub_100732D34(id a1)
{
}

void sub_100732D78()
{
}

void sub_100732D9C(id a1)
{
}

void sub_100732DE0()
{
}

void sub_100732E04(id a1)
{
}

void sub_100732E48()
{
}

void sub_100732E6C(id a1)
{
}

void sub_100732EB0()
{
}

void sub_100732ED4(id a1)
{
}

void sub_100732F18()
{
}

void sub_100732F3C(id a1)
{
}

void sub_100732F80()
{
}

void sub_100732FA4(id a1)
{
}

void sub_100732FE8()
{
}

uint64_t sub_10073300C(uint64_t a1)
{
  *(void *)a1 = &off_1009C0BD0;
  *(_WORD *)(a1 + 8) = 8;
  sub_100052DA8(a1 + 16);
  *(void *)(a1 + 88) = 0;
  *(void *)(a1 + 80) = a1 + 88;
  *(void *)(a1 + 96) = 0;
  *(void *)(a1 + 112) = 0;
  *(void *)(a1 + 104) = a1 + 112;
  *(void *)(a1 + 120) = 0;
  *(void *)(a1 + 136) = 0;
  *(void *)(a1 + 128) = a1 + 136;
  *(void *)(a1 + 144) = 0;
  *(_WORD *)(a1 + 152) = 1;
  *(unsigned char *)(a1 + 154) = 1;
  *(_DWORD *)(a1 + 156) = 0;
  *(_WORD *)(a1 + 160) = 0;
  sub_100733110(a1);
  sub_100733964();
  sub_100734860();
  return a1;
}

void sub_1007330D8(_Unwind_Exception *a1)
{
  sub_1007373A4(v4, *v7);
  sub_10000EDA0(v3, *v6);
  sub_1000486F0(v2, *v5);
  sub_100052DA4(v1);
  _Unwind_Resume(a1);
}

void sub_100733110(uint64_t a1)
{
  uint64_t v1 = qword_100A19F70;
  if (os_log_type_enabled((os_log_t)qword_100A19F70, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_DEFAULT, "BTResourceManager LE initialized.", buf, 2u);
  }
  for (uint64_t i = 0; i != 9; ++i)
  {
    *(void *)__s = 0;
    uint64_t v44 = 0;
    int v45 = 0;
    sprintf(__s, "%d", dword_1009FC020[i]);
    int v38 = 0;
    uint64_t v3 = sub_100017768();
    sub_10004191C(buf, "BTResourceManager");
    sub_10004191C(__p, __s);
    int v4 = (*(uint64_t (**)(uint64_t, unsigned char *, void **, int *))(*(void *)v3 + 88))(v3, buf, __p, &v38);
    if (v37 < 0) {
      operator delete(__p[0]);
    }
    if (v42 < 0)
    {
      operator delete(*(void **)buf);
      if (!v4) {
        goto LABEL_12;
      }
    }
    else if (!v4)
    {
      goto LABEL_12;
    }
    int v5 = qword_100A19F70;
    if (os_log_type_enabled((os_log_t)qword_100A19F70, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 136446466;
      *(void *)&uint8_t buf[4] = __s;
      __int16 v40 = 1024;
      int v41 = v38;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "Warning: Overriding BTResourceManager max connections for %{public}s usecase to %d", buf, 0x12u);
    }
LABEL_12:
    __int16 v6 = v38;
    *(void *)long long buf = &dword_1009FC020[i];
    *((_WORD *)sub_1006A994C((uint64_t **)(a1 + 80), (unsigned int *)&dword_1009FC020[i], (uint64_t)&unk_1007BE9D0, (_DWORD **)buf)+ 16) = v6;
  }
  LOBYTE(v38) = 0;
  uint64_t v7 = sub_100017768();
  sub_10004191C(buf, "LE");
  sub_10004191C(__p, "DoNotEnforceAllowedList");
  int v8 = (*(uint64_t (**)(uint64_t, unsigned char *, void **, int *))(*(void *)v7 + 72))(v7, buf, __p, &v38);
  if ((_BYTE)v38) {
    int v9 = v8;
  }
  else {
    int v9 = 0;
  }
  if (v37 < 0) {
    operator delete(__p[0]);
  }
  if (v42 < 0)
  {
    operator delete(*(void **)buf);
    if (!v9) {
      goto LABEL_24;
    }
  }
  else if (!v9)
  {
    goto LABEL_24;
  }
  *(unsigned char *)(a1 + 152) = 0;
  uint64_t v10 = qword_100A19F70;
  if (os_log_type_enabled((os_log_t)qword_100A19F70, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "Warning: Overriding - Do Not Enforce Allowed List.", buf, 2u);
  }
LABEL_24:
  uint64_t v11 = sub_100017768();
  sub_10004191C(buf, "LE");
  sub_10004191C(__p, "DebugAllowedList");
  int v12 = (*(uint64_t (**)(uint64_t, unsigned char *, void **, int *))(*(void *)v11 + 72))(v11, buf, __p, &v38);
  if ((_BYTE)v38) {
    int v13 = v12;
  }
  else {
    int v13 = 0;
  }
  if (v37 < 0) {
    operator delete(__p[0]);
  }
  if (v42 < 0)
  {
    operator delete(*(void **)buf);
    if (!v13) {
      goto LABEL_35;
    }
  }
  else if (!v13)
  {
    goto LABEL_35;
  }
  *(unsigned char *)(a1 + 153) = 1;
  long long v14 = qword_100A19F70;
  if (os_log_type_enabled((os_log_t)qword_100A19F70, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "Warning: Overriding - Enable Debugging Allowed List.", buf, 2u);
  }
LABEL_35:
  *(_DWORD *)__s = 0;
  uint64_t v15 = sub_100017768();
  sub_10004191C(buf, "LE");
  sub_10004191C(__p, "MaxConnPerBundleIDFromEndConnectingClient");
  int v16 = (*(uint64_t (**)(uint64_t, unsigned char *, void **, char *))(*(void *)v15 + 88))(v15, buf, __p, __s);
  if (*(_DWORD *)__s) {
    int v17 = v16;
  }
  else {
    int v17 = 0;
  }
  if (v37 < 0) {
    operator delete(__p[0]);
  }
  if (v42 < 0)
  {
    operator delete(*(void **)buf);
    if (!v17) {
      goto LABEL_46;
    }
  }
  else if (!v17)
  {
    goto LABEL_46;
  }
  int v18 = *(_DWORD *)__s;
  *(_WORD *)(a1 + 160) = *(_WORD *)__s;
  uint64_t v19 = qword_100A19F70;
  if (os_log_type_enabled((os_log_t)qword_100A19F70, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 67109120;
    *(_DWORD *)&uint8_t buf[4] = v18;
    _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "Warning: Overriding - MaxConnPerBundleIDFromEndConnectingClient %d", buf, 8u);
  }
LABEL_46:
  *(_DWORD *)__s = 0;
  *(_WORD *)(a1 + 156) = 94;
  uint64_t v20 = sub_100017768();
  sub_10004191C(buf, "LE");
  sub_10004191C(__p, "MaxConnPerBundleIDFromFindMyClient");
  int v21 = (*(uint64_t (**)(uint64_t, unsigned char *, void **, char *))(*(void *)v20 + 88))(v20, buf, __p, __s);
  if (*(_DWORD *)__s) {
    int v22 = v21;
  }
  else {
    int v22 = 0;
  }
  if (v37 < 0) {
    operator delete(__p[0]);
  }
  if (v42 < 0)
  {
    operator delete(*(void **)buf);
    if (!v22) {
      goto LABEL_57;
    }
  }
  else if (!v22)
  {
    goto LABEL_57;
  }
  int v23 = *(_DWORD *)__s;
  *(_WORD *)(a1 + 156) = *(_WORD *)__s;
  float v24 = qword_100A19F70;
  if (os_log_type_enabled((os_log_t)qword_100A19F70, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 67109120;
    *(_DWORD *)&uint8_t buf[4] = v23;
    _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "Warning: Overriding - MaxConnPerBundleIDFromFindMyClient %d", buf, 8u);
  }
LABEL_57:
  *(_WORD *)(a1 + 158) = 32;
  uint64_t v25 = sub_100017768();
  sub_10004191C(buf, "LE");
  sub_10004191C(__p, "MaxConnPerBundleID");
  int v26 = (*(uint64_t (**)(uint64_t, unsigned char *, void **, char *))(*(void *)v25 + 88))(v25, buf, __p, __s);
  if (*(_DWORD *)__s) {
    int v27 = v26;
  }
  else {
    int v27 = 0;
  }
  if (v37 < 0) {
    operator delete(__p[0]);
  }
  if (v42 < 0)
  {
    operator delete(*(void **)buf);
    if (!v27) {
      goto LABEL_68;
    }
  }
  else if (!v27)
  {
    goto LABEL_68;
  }
  int v28 = *(_DWORD *)__s;
  *(_WORD *)(a1 + 158) = *(_WORD *)__s;
  __int16 v29 = qword_100A19F70;
  if (os_log_type_enabled((os_log_t)qword_100A19F70, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 67109120;
    *(_DWORD *)&uint8_t buf[4] = v28;
    _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEFAULT, "Warning: Overriding - MaxConnPerBundleID %d", buf, 8u);
  }
LABEL_68:
  uint64_t v30 = sub_100017768();
  sub_10004191C(buf, "LE");
  sub_10004191C(__p, "EnforceUseCaseRequiredList");
  int v31 = (*(uint64_t (**)(uint64_t, unsigned char *, void **, int *))(*(void *)v30 + 72))(v30, buf, __p, &v38);
  if (v37 < 0) {
    operator delete(__p[0]);
  }
  if (v42 < 0)
  {
    operator delete(*(void **)buf);
    if (!v31) {
      return;
    }
  }
  else if (!v31)
  {
    return;
  }
  int v32 = v38;
  *(unsigned char *)(a1 + 154) = v38;
  __int16 v33 = qword_100A19F70;
  if (os_log_type_enabled((os_log_t)qword_100A19F70, OS_LOG_TYPE_DEFAULT))
  {
    unsigned int v34 = "Yes";
    if (!v32) {
      unsigned int v34 = "No";
    }
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = v34;
    _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_DEFAULT, "Warning: Overriding - Enforce Use Case Required List: %s", buf, 0xCu);
  }
}

void sub_1007338F8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, void *a20,uint64_t a21,int a22,__int16 a23,char a24,char a25)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  if (a25 < 0) {
    operator delete(a20);
  }
  _Unwind_Resume(exception_object);
}

void sub_100733964()
{
  +[NSMutableSet setWithObjects:](NSMutableSet, "setWithObjects:", @"554d08b1bf41ced30d076c7ab17284e2afde2f14cf0606f41b106ebabaf98278", @"602926fb95b65d8841071711217c956ada1917462051445917d89356ee415929", @"3a58c9b9f34737fcb1e4ef2c5665843c6d833a2411d47bec0e7caa34ce401e89", @"febeb2bb2afc79b90aee52b3c218ff6772ceb48b3a84caf9aa173247fbe203d9", @"5ad8dab6f1fa117db4bc3427c2853a4feceb05332a2bcd6fb5f3a55db03ff081", @"15f62a1003c7f91a502a48d8b9d6b9e3234972eb2134266269da426531e0f142", @"ec0f8fcfbb71cd4859bdcb14f4840f131b1d0931fda6846f637732a49598a49f", @"ef8ff847079725c8fb3ef45a3ad4c69094b719d6eef6207cced996646cad9eb7", @"358e413d1ec9ed3836bb8fe3f6c47ef03e29bc368636784543f2be232e66541d", @"8b69e99aebb81c30fb34dc5074023e0f5bb05964ee28d7e43010537fba7d36e0", @"bf4ce535225ad51bb284f2c4766a0fd74c536abac7a166d9830d3947f374de80", @"63c4591131b2604f1ca83bf2ae7895f23c723a92106b3740a972b1b14613bc0f", @"38fa5040af8b215d43372179eacbd6f725312c840059488b197711401d7ad5d4", @"c097e6524326b43a007761497aca0a778b5581b035f4f0f9773d57156e9b38a0", @"b96253cbfed55399a9e8b5820dbcf6abc5d9118ee105e2bdef0b201c3b3e9444", @"24f2d03118a59d1daba966600ed07425b0d875d70c06be360d33fd4ca853af58", @"23982ca925a8cd3342289446b7f42903ab99be060475efa8b0abc1a792effc29",
    @"ae5179510709cdca4f1dde3264d1949698b408f426a98be526c4d14dffc26b91",
    @"ff31c07022e965aa2a54968917cd4f3d41e165e82d31a5fd22856c4217c28553",
    @"7fad0ec0a107abc4276a86c201b1bc46d9ef1b0776cc75b71987505da768393d",
    @"ea1d0f537acf0783b76af476c0ec5c3acac48b2a5432a73daa8c5afb42f19b0b",
    @"a800fae19a5d4e1e92dd43934636be8787bf74e832a80bf2ea709062799acb94",
    @"79f5c84c1c254c76b8d4ea7601499b7c3a67914dfd3e567704db4b9309ae4fb1",
    @"06ccfb2f489cc5912a2cda502c69506b82cad5934895ea6ae535cab35c5bc9e3",
    @"bb18ff323ebe7357070647660f905b6c4417447bdbcc79bea36ee4cf2c66b3d7",
    @"06fa9dee637f78720fe2778c92824a6dd80299f34646910a83029d23ca3399a4",
    @"a09e4a534d554ffe8cf0544b591bf9f635ca605771f6a72ef93103fa38c41f95",
    @"089f80bd091e54346dc645636f8f7b51c1d22ba623f3c0f8c05d17c34c92bc27",
    @"ae98258fc9148e2a33ba48f0e2eaa82e813fdb86d010482101cae83f3d2a877d",
    @"decfd0b0b0a0bfeaa333cce4c5ec9590f5f8274561d4347e9f1f6a29aa8f1d34",
    @"ecc1d20a6f0e9ee4e7f384a0cdfe18050cee19a5c7c94adb6c94e12f647d24f2",
    @"8cbd21794df7f1c16bbd5a267f976326a24bf9ddb3ac745bc4a854af006a50b7",
    @"dfa8283074903b24529434aac683ac9d3853d95107f7fd3ee581f7c69ffc65dd",
    @"e5457e14a88f3003c6c64edcaa85fbe18f7fd23e6385c9acb0f210bcd84e837e",
    @"636c1f0ee6b0cccebbbfd5979ae5ecf09bcbe673df044883881fd69d313a9eac",
    @"aaf648093c082f5b9999e9d8eaec9235503aa3963726641be8635701db151cfe",
    @"15f6b2947dd7ad89fe858cbe80ee51c2c6c5e4625ad5d4e9b6de6c1b15db213b",
    @"be0bcf7017deaa4c2f173c24718a2648f5c5e6b7a6b296df919775043acd7b73",
    @"c1d1c54c3bb978737276ec2c974256db9e98e3878cf204c48ecc2bf6a3906e2a",
    @"cdf1779ec4f156ca577a1e99372fe3227e2552dff8d533624ea5312c814e9c85",
    @"619157a2665ca48dbd59740e7993884af9e9aefa23d42ca3beed72450a80130a",
    @"c6538eb30a5e64df30159760d1c20dfb82cf10febdc237bfb3fbeaae8061e958",
    @"306dec84ac641c728a5e52b9257a536faaa292db3109b0c6c3b4b2a24999c1d8",
    @"64b90991318f675b807c35b4ff35850a05967ee72b06176f5d1f57318bcc60e2",
    @"b86e6ba2c543374a4736569af4226371b78532514f935dd1122cdf84199d42b9",
    @"e2ae0f5a011d888eb0249f576a1f6d1cf0ab5953cf25e1451f1a476e86673b93",
    @"b27625a6780b68f433ec7012f3c75a73925c24a6a91868ceb99ac4a0ea0413e6",
    @"e64c7c5f0599df5b5800ec1771e2794491b06f49d43c00707c08c2a8d6fea059",
    @"7abe9e90bfb16aecae19e551312117deb7622939758c83e1d65387f2fb4d94ee",
    @"474646dff450e7a23bd8180829d1712a26d65c6ec4de6eb4ffe233037a2cc69f",
    @"3d56a5b22cbe84a53b45bf7ec935e6dfc346edff2d47d974939f3f8c8b0d2862",
    @"cb9c7eaccfbe7833daf0f9030e6b2b3e75ca158857d0e5307ca9d9064c3199b2",
    @"a7fcb0ca8a4bf8a79ffde6c2e982521085db9296fb451f1bce53819fdfe7d7c2",
    @"4641d059088b8c84e32990ea7dfae36dfa988f109bad552d138771782f681d03",
    @"5b0a008a845215b74ea580c1ca3096e2a67b0283cfc04548124326b1023d1c05",
    @"5ece8d12e33b7abe998fa14e917c5eacd97fecb7be0da94b775389bf92ad8313",
    @"75d3a5e65ae4b047e14682759758d41ed65b98d0ad5a2c57eb51ac80e913c45b",
    @"8ae9aeabfa6411b461c28f082940ecb9eb25009705bd60498d4de57e1b55c5c1",
    @"1d7300686aa7c49abcdbc2a47e30cb7ec451f10f14b240523a57b958c2cb9591",
    @"f9306b984dd3cf87c9277b547eb2f11dce7a40d21c8b1ed4fa1d1fffec5acb9f",
  uint64_t v0 = @"f53de5dac1ebf57ff83dcd8094e03d8229c5d7457e39184e87ce8bac0b1f95ea");
  uint64_t v1 = (void *)qword_100A1A2B8;
  qword_100A1A2B8 = v0;

  int v28 = 0;
  __int16 v29 = 0;
  uint64_t v30 = 0;
  uint64_t v2 = sub_100017768();
  sub_10004191C(&__dst, "LEAllowedBundleIDs");
  if ((*(unsigned int (**)(uint64_t, long long *, long long **))(*(void *)v2 + 48))(v2, &__dst, &v28))
  {
    int v4 = v28;
    uint64_t v3 = v29;
    if (SHIBYTE(v27) < 0) {
      operator delete((void *)__dst);
    }
    if (v3 != v4)
    {
      int v5 = v28;
      for (i = v29; v5 != i; int v5 = (long long *)((char *)v5 + 24))
      {
        __uuid_t dst = 0uLL;
        uint64_t v27 = 0;
        if (*((char *)v5 + 23) < 0)
        {
          sub_10003B098(&__dst, *(void **)v5, *((void *)v5 + 1));
        }
        else
        {
          long long v7 = *v5;
          uint64_t v27 = *((void *)v5 + 2);
          __uuid_t dst = v7;
        }
        int v8 = qword_100A19F70;
        if (os_log_type_enabled((os_log_t)qword_100A19F70, OS_LOG_TYPE_DEFAULT))
        {
          if (v27 >= 0) {
            p_uuid_t dst = &__dst;
          }
          else {
            p_uuid_t dst = (long long *)__dst;
          }
          *(_DWORD *)long long buf = 136446210;
          int v32 = p_dst;
          _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "Additional BundleID for allowedHashedBundleIDsSet by Overriding: %{public}s", buf, 0xCu);
        }
        id v10 = objc_alloc((Class)NSString);
        if (v27 >= 0) {
          uint64_t v11 = &__dst;
        }
        else {
          uint64_t v11 = (long long *)__dst;
        }
        id v12 = [v10 initWithUTF8String:v11];
        int v13 = CBGenerateObfuscatedSHA256HashedString();
        [(id)qword_100A1A2B8 addObject:v13];

        if (SHIBYTE(v27) < 0) {
          operator delete((void *)__dst);
        }
      }
    }
  }
  else if (SHIBYTE(v27) < 0)
  {
    operator delete((void *)__dst);
  }
  uint64_t v14 = sub_100017768();
  sub_10004191C(&__dst, "LEDisallowedBundleIDs");
  if ((*(unsigned int (**)(uint64_t, long long *, long long **))(*(void *)v14 + 48))(v14, &__dst, &v28))
  {
    int v16 = v28;
    uint64_t v15 = v29;
    if (SHIBYTE(v27) < 0) {
      operator delete((void *)__dst);
    }
    if (v15 != v16)
    {
      int v17 = v28;
      for (j = v29; v17 != j; int v17 = (long long *)((char *)v17 + 24))
      {
        __uuid_t dst = 0uLL;
        uint64_t v27 = 0;
        if (*((char *)v17 + 23) < 0)
        {
          sub_10003B098(&__dst, *(void **)v17, *((void *)v17 + 1));
        }
        else
        {
          long long v19 = *v17;
          uint64_t v27 = *((void *)v17 + 2);
          __uuid_t dst = v19;
        }
        uint64_t v20 = qword_100A19F70;
        if (os_log_type_enabled((os_log_t)qword_100A19F70, OS_LOG_TYPE_DEFAULT))
        {
          if (v27 >= 0) {
            int v21 = &__dst;
          }
          else {
            int v21 = (long long *)__dst;
          }
          *(_DWORD *)long long buf = 136446210;
          int v32 = v21;
          _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "BundleID is removed from allowedHashedBundleIDsSet by Overriding: %{public}s", buf, 0xCu);
        }
        id v22 = objc_alloc((Class)NSString);
        if (v27 >= 0) {
          int v23 = &__dst;
        }
        else {
          int v23 = (long long *)__dst;
        }
        id v24 = [v22 initWithUTF8String:v23];
        uint64_t v25 = CBGenerateObfuscatedSHA256HashedString();
        [(id)qword_100A1A2B8 removeObject:v25];

        if (SHIBYTE(v27) < 0) {
          operator delete((void *)__dst);
        }
      }
    }
  }
  else if (SHIBYTE(v27) < 0)
  {
    operator delete((void *)__dst);
  }
  *(void *)&__uuid_t dst = &v28;
  sub_100051568((void ***)&__dst);
}

void sub_1007347D8(_Unwind_Exception *a1)
{
  if (*(char *)(v1 - 137) < 0) {
    operator delete(*(void **)(v1 - 160));
  }
  *(void *)(v1 - 160) = v1 - 136;
  sub_100051568((void ***)(v1 - 160));
  _Unwind_Resume(a1);
}

void sub_100734860()
{
  int v80 = 0;
  __n128 v81 = 0;
  uint64_t v82 = 0;
  uint64_t v0 = +[NSMutableSet setWithObjects:@"f50eeeda9ef9e96cbfd2e255ecd185cedcaa7c023ad51d903de5405e4d94264c", @"28b69483d207baa88955b89e6419fb8a823ddea87ee701fdc8e83b9d819ab4a4", @"c48aec1017d2d0d2c9a4a0a9f34d20b42beed75cad781f9e33e45f1df476fac1", 0];
  uint64_t v1 = (void *)qword_100A1A2C0;
  qword_100A1A2C0 = v0;

  uint64_t v2 = sub_100017768();
  sub_10004191C(__p, "AddLEUseCaseRequiredBundleIDsScan");
  if ((*(unsigned int (**)(uint64_t, void **, long long **))(*(void *)v2 + 48))(v2, __p, &v80))
  {
    int v4 = v80;
    uint64_t v3 = v81;
    if (SHIBYTE(v79) < 0) {
      operator delete(__p[0]);
    }
    if (v3 != v4)
    {
      int v5 = v80;
      for (i = v81; v5 != i; int v5 = (long long *)((char *)v5 + 24))
      {
        __p[0] = 0;
        __p[1] = 0;
        uint64_t v79 = 0;
        if (*((char *)v5 + 23) < 0)
        {
          sub_10003B098(__p, *(void **)v5, *((void *)v5 + 1));
        }
        else
        {
          long long v7 = *v5;
          uint64_t v79 = *((void *)v5 + 2);
          *(_OWORD *)std::string __p = v7;
        }
        int v8 = qword_100A19F70;
        if (os_log_type_enabled((os_log_t)qword_100A19F70, OS_LOG_TYPE_DEFAULT))
        {
          if (v79 >= 0) {
            int v9 = __p;
          }
          else {
            int v9 = (void **)__p[0];
          }
          *(_DWORD *)long long buf = 136446210;
          xpc_object_t v84 = v9;
          _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "Additional BundleID for useCaseRequiredHashedBundleIDsSet for Scanning by Overriding: %{public}s", buf, 0xCu);
        }
        id v10 = objc_alloc((Class)NSString);
        if (v79 >= 0) {
          uint64_t v11 = __p;
        }
        else {
          uint64_t v11 = (void **)__p[0];
        }
        id v12 = [v10 initWithUTF8String:v11];
        int v13 = CBGenerateObfuscatedSHA256HashedString();
        [(id)qword_100A1A2C0 addObject:v13];

        if (SHIBYTE(v79) < 0) {
          operator delete(__p[0]);
        }
      }
    }
  }
  else if (SHIBYTE(v79) < 0)
  {
    operator delete(__p[0]);
  }
  uint64_t v14 = sub_100017768();
  sub_10004191C(__p, "RemoveLEUseCaseRequiredBundleIDsScan");
  if ((*(unsigned int (**)(uint64_t, void **, long long **))(*(void *)v14 + 48))(v14, __p, &v80))
  {
    int v16 = v80;
    uint64_t v15 = v81;
    if (SHIBYTE(v79) < 0) {
      operator delete(__p[0]);
    }
    if (v15 != v16)
    {
      int v17 = v80;
      for (j = v81; v17 != j; int v17 = (long long *)((char *)v17 + 24))
      {
        __p[0] = 0;
        __p[1] = 0;
        uint64_t v79 = 0;
        if (*((char *)v17 + 23) < 0)
        {
          sub_10003B098(__p, *(void **)v17, *((void *)v17 + 1));
        }
        else
        {
          long long v19 = *v17;
          uint64_t v79 = *((void *)v17 + 2);
          *(_OWORD *)std::string __p = v19;
        }
        uint64_t v20 = qword_100A19F70;
        if (os_log_type_enabled((os_log_t)qword_100A19F70, OS_LOG_TYPE_DEFAULT))
        {
          if (v79 >= 0) {
            int v21 = __p;
          }
          else {
            int v21 = (void **)__p[0];
          }
          *(_DWORD *)long long buf = 136446210;
          xpc_object_t v84 = v21;
          _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "BundleID is removed from useCaseRequiredHashedBundleIDsSet for Scanning by Overriding: %{public}s", buf, 0xCu);
        }
        id v22 = objc_alloc((Class)NSString);
        if (v79 >= 0) {
          int v23 = __p;
        }
        else {
          int v23 = (void **)__p[0];
        }
        id v24 = [v22 initWithUTF8String:v23];
        uint64_t v25 = CBGenerateObfuscatedSHA256HashedString();
        [(id)qword_100A1A2C0 removeObject:v25];

        if (SHIBYTE(v79) < 0) {
          operator delete(__p[0]);
        }
      }
    }
  }
  else if (SHIBYTE(v79) < 0)
  {
    operator delete(__p[0]);
  }
  uint64_t v26 = +[NSMutableSet setWithObjects:@"f50eeeda9ef9e96cbfd2e255ecd185cedcaa7c023ad51d903de5405e4d94264c", @"e4c0ceca17dcd39c038c248f92a18f304213be2c9d5c3acba171e8f4dc098d97", @"0604cb11439cce401b58e1cbb1e74790c30d05583fc162c9b0413efacf6a6a4d", 0];
  uint64_t v27 = (void *)qword_100A1A2C8;
  qword_100A1A2C8 = v26;

  uint64_t v28 = sub_100017768();
  sub_10004191C(__p, "AddLEUseCaseRequiredBundleIDsConnect");
  if ((*(unsigned int (**)(uint64_t, void **, long long **))(*(void *)v28 + 48))(v28, __p, &v80))
  {
    uint64_t v30 = v80;
    __int16 v29 = v81;
    if (SHIBYTE(v79) < 0) {
      operator delete(__p[0]);
    }
    if (v29 != v30)
    {
      int v31 = v80;
      for (k = v81; v31 != k; int v31 = (long long *)((char *)v31 + 24))
      {
        __p[0] = 0;
        __p[1] = 0;
        uint64_t v79 = 0;
        if (*((char *)v31 + 23) < 0)
        {
          sub_10003B098(__p, *(void **)v31, *((void *)v31 + 1));
        }
        else
        {
          long long v33 = *v31;
          uint64_t v79 = *((void *)v31 + 2);
          *(_OWORD *)std::string __p = v33;
        }
        unsigned int v34 = qword_100A19F70;
        if (os_log_type_enabled((os_log_t)qword_100A19F70, OS_LOG_TYPE_DEFAULT))
        {
          if (v79 >= 0) {
            __int16 v35 = __p;
          }
          else {
            __int16 v35 = (void **)__p[0];
          }
          *(_DWORD *)long long buf = 136446210;
          xpc_object_t v84 = v35;
          _os_log_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_DEFAULT, "Additional BundleID for useCaseRequiredHashedBundleIDsSet for Connection by Overriding: %{public}s", buf, 0xCu);
        }
        id v36 = objc_alloc((Class)NSString);
        if (v79 >= 0) {
          char v37 = __p;
        }
        else {
          char v37 = (void **)__p[0];
        }
        id v38 = [v36 initWithUTF8String:v37];
        int v39 = CBGenerateObfuscatedSHA256HashedString();
        [(id)qword_100A1A2C8 addObject:v39];

        if (SHIBYTE(v79) < 0) {
          operator delete(__p[0]);
        }
      }
    }
  }
  else if (SHIBYTE(v79) < 0)
  {
    operator delete(__p[0]);
  }
  uint64_t v40 = sub_100017768();
  sub_10004191C(__p, "RemoveLEUseCaseRequiredBundleIDsConnect");
  if ((*(unsigned int (**)(uint64_t, void **, long long **))(*(void *)v40 + 48))(v40, __p, &v80))
  {
    char v42 = v80;
    int v41 = v81;
    if (SHIBYTE(v79) < 0) {
      operator delete(__p[0]);
    }
    if (v41 != v42)
    {
      unsigned __int16 v43 = v80;
      for (m = v81; v43 != m; unsigned __int16 v43 = (long long *)((char *)v43 + 24))
      {
        __p[0] = 0;
        __p[1] = 0;
        uint64_t v79 = 0;
        if (*((char *)v43 + 23) < 0)
        {
          sub_10003B098(__p, *(void **)v43, *((void *)v43 + 1));
        }
        else
        {
          long long v45 = *v43;
          uint64_t v79 = *((void *)v43 + 2);
          *(_OWORD *)std::string __p = v45;
        }
        id v46 = qword_100A19F70;
        if (os_log_type_enabled((os_log_t)qword_100A19F70, OS_LOG_TYPE_DEFAULT))
        {
          if (v79 >= 0) {
            __int16 v47 = __p;
          }
          else {
            __int16 v47 = (void **)__p[0];
          }
          *(_DWORD *)long long buf = 136446210;
          xpc_object_t v84 = v47;
          _os_log_impl((void *)&_mh_execute_header, v46, OS_LOG_TYPE_DEFAULT, "BundleID is removed from useCaseRequiredHashedBundleIDsSet for Connection by Overriding: %{public}s", buf, 0xCu);
        }
        id v48 = objc_alloc((Class)NSString);
        if (v79 >= 0) {
          __int16 v49 = __p;
        }
        else {
          __int16 v49 = (void **)__p[0];
        }
        id v50 = [v48 initWithUTF8String:v49];
        __int16 v51 = CBGenerateObfuscatedSHA256HashedString();
        [(id)qword_100A1A2C8 removeObject:v51];

        if (SHIBYTE(v79) < 0) {
          operator delete(__p[0]);
        }
      }
    }
  }
  else if (SHIBYTE(v79) < 0)
  {
    operator delete(__p[0]);
  }
  uint64_t v52 = +[NSMutableSet setWithObjects:@"962f55acdffc015a6caaf8083446b7e50ed5cb6cf10eeabdcfefd2f1fd76fca6", @"e84ae109a38baeb5483e641b123b64c498a08de3c392e6a15a5464aa163abba1", 0];
  uint32_t v53 = (void *)qword_100A1A2D0;
  qword_100A1A2D0 = v52;

  uint64_t v54 = sub_100017768();
  sub_10004191C(__p, "AddLEUseCaseRequiredBundleIDsAdv");
  if ((*(unsigned int (**)(uint64_t, void **, long long **))(*(void *)v54 + 48))(v54, __p, &v80))
  {
    int v56 = v80;
    unsigned __int8 v55 = v81;
    if (SHIBYTE(v79) < 0) {
      operator delete(__p[0]);
    }
    if (v55 != v56)
    {
      uint64_t v57 = v80;
      for (n = v81; v57 != n; uint64_t v57 = (long long *)((char *)v57 + 24))
      {
        __p[0] = 0;
        __p[1] = 0;
        uint64_t v79 = 0;
        if (*((char *)v57 + 23) < 0)
        {
          sub_10003B098(__p, *(void **)v57, *((void *)v57 + 1));
        }
        else
        {
          long long v59 = *v57;
          uint64_t v79 = *((void *)v57 + 2);
          *(_OWORD *)std::string __p = v59;
        }
        unsigned __int8 v60 = qword_100A19F70;
        if (os_log_type_enabled((os_log_t)qword_100A19F70, OS_LOG_TYPE_DEFAULT))
        {
          if (v79 >= 0) {
            uint64_t v61 = __p;
          }
          else {
            uint64_t v61 = (void **)__p[0];
          }
          *(_DWORD *)long long buf = 136446210;
          xpc_object_t v84 = v61;
          _os_log_impl((void *)&_mh_execute_header, v60, OS_LOG_TYPE_DEFAULT, "Additional BundleID for useCaseRequiredHashedBundleIDsSet for Advertising by overriding: %{public}s", buf, 0xCu);
        }
        id v62 = objc_alloc((Class)NSString);
        if (v79 >= 0) {
          long long v63 = __p;
        }
        else {
          long long v63 = (void **)__p[0];
        }
        id v64 = [v62 initWithUTF8String:v63];
        unsigned __int8 v65 = CBGenerateObfuscatedSHA256HashedString();
        [(id)qword_100A1A2D0 addObject:v65];

        if (SHIBYTE(v79) < 0) {
          operator delete(__p[0]);
        }
      }
    }
  }
  else if (SHIBYTE(v79) < 0)
  {
    operator delete(__p[0]);
  }
  uint64_t v66 = sub_100017768();
  sub_10004191C(__p, "RemoveLEUseCaseRequiredBundleIDsAdv");
  if ((*(unsigned int (**)(uint64_t, void **, long long **))(*(void *)v66 + 48))(v66, __p, &v80))
  {
    unint64_t v68 = v80;
    uint64_t v67 = v81;
    if (SHIBYTE(v79) < 0) {
      operator delete(__p[0]);
    }
    if (v67 != v68)
    {
      uint64_t v69 = v80;
      for (ii = v81; v69 != ii; uint64_t v69 = (long long *)((char *)v69 + 24))
      {
        __p[0] = 0;
        __p[1] = 0;
        uint64_t v79 = 0;
        if (*((char *)v69 + 23) < 0)
        {
          sub_10003B098(__p, *(void **)v69, *((void *)v69 + 1));
        }
        else
        {
          long long v71 = *v69;
          uint64_t v79 = *((void *)v69 + 2);
          *(_OWORD *)std::string __p = v71;
        }
        unsigned __int8 v72 = qword_100A19F70;
        if (os_log_type_enabled((os_log_t)qword_100A19F70, OS_LOG_TYPE_DEFAULT))
        {
          if (v79 >= 0) {
            int v73 = __p;
          }
          else {
            int v73 = (void **)__p[0];
          }
          *(_DWORD *)long long buf = 136446210;
          xpc_object_t v84 = v73;
          _os_log_impl((void *)&_mh_execute_header, v72, OS_LOG_TYPE_DEFAULT, "BundleID is removed from useCaseRequiredHashedBundleIDsSet for Advertising by overriding: %{public}s", buf, 0xCu);
        }
        id v74 = objc_alloc((Class)NSString);
        if (v79 >= 0) {
          v75 = __p;
        }
        else {
          v75 = (void **)__p[0];
        }
        id v76 = [v74 initWithUTF8String:v75];
        unint64_t v77 = CBGenerateObfuscatedSHA256HashedString();
        [(id)qword_100A1A2D0 removeObject:v77];

        if (SHIBYTE(v79) < 0) {
          operator delete(__p[0]);
        }
      }
    }
  }
  else if (SHIBYTE(v79) < 0)
  {
    operator delete(__p[0]);
  }
  __p[0] = &v80;
  sub_100051568((void ***)__p);
}

void sub_1007352E4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20,char a21)
{
  if (a20 < 0) {
    operator delete(__p);
  }
  std::string __p = &a21;
  sub_100051568((void ***)&__p);
  _Unwind_Resume(a1);
}

uint64_t sub_100735410(uint64_t a1, unsigned int a2)
{
  uint64_t v2 = *(void *)(a1 + 88);
  if (v2)
  {
    uint64_t v3 = a1 + 88;
    do
    {
      unsigned int v4 = *(_DWORD *)(v2 + 28);
      BOOL v5 = v4 >= a2;
      if (v4 >= a2) {
        __int16 v6 = (uint64_t *)v2;
      }
      else {
        __int16 v6 = (uint64_t *)(v2 + 8);
      }
      if (v5) {
        uint64_t v3 = v2;
      }
      uint64_t v2 = *v6;
    }
    while (*v6);
    if (v3 != a1 + 88 && *(_DWORD *)(v3 + 28) <= a2)
    {
      uint64_t v7 = *(unsigned __int16 *)(v3 + 32);
      if (v7) {
        return v7;
      }
    }
  }
  if (a2 - 20 < 2 || a2 == 655360) {
    return *(unsigned __int16 *)(a1 + 8);
  }
  if ((a2 & 0xFFFF0000) == 0x10000 && dword_1009FC020[0] != a2)
  {
    uint64_t v9 = 0;
    do
    {
      if (v9 == 8) {
        break;
      }
      int v10 = dword_1009FC020[++v9];
    }
    while (v10 != a2);
  }
  uint64_t v11 = *(uint64_t (**)(void))(*(void *)sub_10003FB34() + 3416);

  return v11();
}

uint64_t sub_100735580(uint64_t a1, int a2)
{
  uint64_t v3 = 0;
  int v4 = 0;
  do
  {
    if (HIWORD(dword_1009FC020[v3]) == a2)
    {
      if (qword_1009F7EC0 != -1) {
        dispatch_once(&qword_1009F7EC0, &stru_1009C0BE0);
      }
      v4 += sub_10068D33C((uint64_t)off_1009F7EB8, dword_1009FC020[v3]);
    }
    ++v3;
  }
  while (v3 != 9);
  return (unsigned __int16)v4;
}

uint64_t sub_100735630(uint64_t a1, int a2)
{
  if ((a2 & 0xFFFF0000) == 0x10000)
  {
    if (dword_1009FC020[0] == a2)
    {
LABEL_3:
      __int16 v3 = sub_100735580(a1, 1);
      if (qword_1009F7EC0 == -1) {
        return (unsigned __int16)(sub_10068D33C((uint64_t)off_1009F7EB8, 3) + v3);
      }
      goto LABEL_18;
    }
    uint64_t v5 = 0;
    while (v5 != 8)
    {
      int v6 = dword_1009FC020[++v5];
      if (v6 == a2)
      {
        if ((unint64_t)(v5 - 1) <= 7) {
          goto LABEL_3;
        }
        break;
      }
    }
    if (qword_1009F7EC0 == -1) {
      goto LABEL_15;
    }
LABEL_19:
    dispatch_once(&qword_1009F7EC0, &stru_1009C0BE0);
    goto LABEL_15;
  }
  if (a2 == 3)
  {
    __int16 v3 = sub_100735580(a1, 1);
    if (qword_1009F7EC0 == -1) {
      return (unsigned __int16)(sub_10068D33C((uint64_t)off_1009F7EB8, 3) + v3);
    }
LABEL_18:
    dispatch_once(&qword_1009F7EC0, &stru_1009C0BE0);
    return (unsigned __int16)(sub_10068D33C((uint64_t)off_1009F7EB8, 3) + v3);
  }
  if (qword_1009F7EC0 != -1) {
    goto LABEL_19;
  }
LABEL_15:
  uint64_t v7 = off_1009F7EB8;

  return sub_10068D33C((uint64_t)v7, a2);
}

uint64_t sub_100735778()
{
  uint64_t v0 = sub_100035F54();
  if ((*(uint64_t (**)(uint64_t))(*(void *)v0 + 336))(v0))
  {
    return 2;
  }
  else
  {
    uint64_t v2 = sub_100035F54();
    unsigned __int16 v1 = 2;
    if (((*(uint64_t (**)(uint64_t))(*(void *)v2 + 344))(v2) & 1) == 0)
    {
      uint64_t v3 = sub_100035F54();
      if ((*(unsigned int (**)(uint64_t))(*(void *)v3 + 424))(v3)) {
        return 2;
      }
      else {
        return (unsigned __int16)-1;
      }
    }
  }
  return v1;
}

uint64_t sub_100735844(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (([v3 isEqualToString:@"com.apple.locationd"] & 1) != 0
    || [v3 isEqualToString:@"com.apple.icloud.searchpartyd"])
  {
    int v4 = (unsigned __int16 *)(a1 + 156);
  }
  else
  {
    int v4 = (unsigned __int16 *)(a1 + 158);
  }
  uint64_t v5 = *v4;

  return v5;
}

void sub_1007358A8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t sub_1007358B8(uint64_t a1)
{
  uint64_t result = *(unsigned __int16 *)(a1 + 160);
  if (!result) {
    return sub_100735778();
  }
  return result;
}

uint64_t sub_1007358C8(void *a1)
{
  id v1 = a1;
  uint64_t v2 = v1;
  if (v1)
  {
    if (sub_100735938(v1))
    {
      uint64_t v3 = 1;
    }
    else if (sub_100735994(v2))
    {
      uint64_t v3 = 15;
    }
    else
    {
      uint64_t v3 = 0;
    }
  }
  else
  {
    uint64_t v3 = 0;
  }

  return v3;
}

void sub_100735928(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id sub_100735938(void *a1)
{
  id v1 = a1;
  uint64_t v2 = v1;
  if (v1) {
    id v3 = [v1 localizedCaseInsensitiveContainsString:@"com.apple.healthkit"];
  }
  else {
    id v3 = 0;
  }

  return v3;
}

void sub_100735984(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t sub_100735994(void *a1)
{
  id v1 = a1;
  uint64_t v2 = v1;
  if (v1)
  {
    if (([v1 localizedCaseInsensitiveContainsString:@"com.dexcom."] & 1) != 0
      || ([v2 localizedCaseInsensitiveContainsString:@"com.medtronic."] & 1) != 0)
    {
      uint64_t v3 = 1;
    }
    else
    {
      uint64_t v3 = (uint64_t)[v2 localizedCaseInsensitiveContainsString:@"com.senseonics."];
    }
  }
  else
  {
    uint64_t v3 = 0;
  }

  return v3;
}

void sub_100735A10(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id sub_100735A20(void *a1)
{
  id v1 = a1;
  uint64_t v2 = v1;
  if (v1) {
    id v3 = [v1 localizedCaseInsensitiveContainsString:@"com.apple.bluetoothd-central"];
  }
  else {
    id v3 = 0;
  }

  return v3;
}

void sub_100735A6C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t sub_100735A7C(uint64_t a1, void *a2, void *a3, uint64_t a4)
{
  id v7 = a2;
  id v8 = a3;
  if (a4)
  {
    uint64_t v9 = qword_100A19F70;
    if (os_log_type_enabled((os_log_t)qword_100A19F70, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)std::string __p = 134217984;
      *(void *)&__p[4] = a4;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "Accept provided connection use type %ld", __p, 0xCu);
    }
LABEL_17:
    uint64_t v14 = 0;
    goto LABEL_18;
  }
  if (!a1)
  {
    int v17 = qword_100A19F70;
    if (os_log_type_enabled((os_log_t)qword_100A19F70, OS_LOG_TYPE_ERROR)) {
      sub_10079A3F0(v17);
    }
    a4 = 0;
    goto LABEL_17;
  }
  sub_10003AE4C(a1, (uint64_t)__p);
  int v10 = v23;
  uint64_t v11 = *(unsigned char **)__p;
  NSStringEncoding v12 = +[NSString defaultCStringEncoding];
  if (v10 >= 0) {
    int v13 = __p;
  }
  else {
    int v13 = v11;
  }
  uint64_t v14 = +[NSString stringWithCString:v13 encoding:v12];
  if (v23 < 0) {
    operator delete(*(void **)__p);
  }
  if ((sub_100735A20(v14) & 1) == 0)
  {
    uint64_t v16 = sub_1007358C8(v14);
    goto LABEL_20;
  }
  uint64_t v15 = v7;
  if (v7 || (uint64_t v15 = v8) != 0)
  {
    uint64_t v16 = sub_1007358C8(v15);
LABEL_20:
    a4 = v16;
    goto LABEL_21;
  }
  a4 = 0;
LABEL_21:
  long long v19 = qword_100A19F70;
  if (os_log_type_enabled((os_log_t)qword_100A19F70, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)std::string __p = 138543618;
    *(void *)&__p[4] = v14;
    __int16 v21 = 2048;
    uint64_t v22 = a4;
    _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "getConnectionUseCase directConnectionClientString %{public}@ connectionUseCase %ld", __p, 0x16u);
  }
LABEL_18:

  return a4;
}

void sub_100735C84(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  _Unwind_Resume(a1);
}

void sub_100735CC4(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  id v37 = a3;
  id v7 = a4;
  v42[0] = 0;
  v42[1] = 0;
  sub_10003AED0((uint64_t)v42, a1 + 16);
  id v8 = qword_100A19F70;
  if (os_log_type_enabled((os_log_t)qword_100A19F70, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v9 = uu1;
    sub_10003AE4C(a2, (uint64_t)uu1);
    if (v46 < 0) {
      uint64_t v9 = *(unsigned __int8 **)uu1;
    }
    int v10 = [v7 clientBundleID];
    if (v10)
    {
      uint64_t v11 = [v7 clientBundleID];
    }
    else
    {
      uint64_t v11 = @"NoClientBundleID";
    }
    NSStringEncoding v12 = [v7 clientProcessID];
    if (v12)
    {
      int v13 = [v7 clientProcessID];
    }
    else
    {
      int v13 = @"NoClientProcessID";
    }
    id v14 = [v7 connectionUseCase];
    id v15 = [v7 maxAllowedConnectionDelay];
    *(_DWORD *)long long buf = 138544642;
    *(void *)&uint8_t buf[4] = v37;
    __int16 v48 = 2082;
    __int16 v49 = v9;
    __int16 v50 = 2114;
    __int16 v51 = v11;
    __int16 v52 = 2112;
    *(void *)uint32_t v53 = v13;
    *(_WORD *)&v53[8] = 2048;
    *(void *)&v53[10] = v14;
    __int16 v54 = 2048;
    id v55 = v15;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "Connect Requested for device %{public}@ by session %{public}s with options clientBundleID %{public}@ clientProcessID %@ connectionUseCase %ld maxAllowedConnectionDelay %ld", buf, 0x3Eu);
    if (v12) {

    }
    if (v10) {
    if (v46 < 0)
    }
      operator delete(*(void **)uu1);
  }
  uint64_t v16 = [v7 clientBundleID];
  int v17 = [v7 clientProcessID];
  unsigned int v18 = sub_100735A7C(a2, v16, v17, (uint64_t)[v7 connectionUseCase]);

  BOOL v20 = v18 == 15 || v18 == 1;
  sub_1000305AC(buf, v37);
  __int16 v21 = (uint64_t **)(a1 + 128);
  *(void *)uu1 = buf;
  uint64_t v22 = +[NSMutableSet setWithSet:sub_100737468((uint64_t **)(a1 + 128), buf, (uint64_t)&unk_1007BE9D0, (const unsigned __int8 *__attribute__((__org_typedef(uuid_t))) *)uu1)[6]];
  char v23 = [v7 connectingClients];
  BOOL v24 = v23 == 0;

  if (v24)
  {
    sub_10003AE4C(a2, (uint64_t)buf);
    if (v50 >= 0) {
      __int16 v29 = buf;
    }
    else {
      __int16 v29 = *(unsigned char **)buf;
    }
    uint64_t v30 = +[NSString stringWithUTF8String:v29];
    [v22 addObject:v30];

    if (SHIBYTE(v50) < 0) {
      operator delete(*(void **)buf);
    }
  }
  else
  {
    long long v40 = 0u;
    long long v41 = 0u;
    long long v38 = 0u;
    long long v39 = 0u;
    uint64_t v25 = [v7 connectingClients];
    id v26 = [v25 countByEnumeratingWithState:&v38 objects:v44 count:16];
    if (v26)
    {
      uint64_t v27 = *(void *)v39;
      do
      {
        for (uint64_t i = 0; i != v26; uint64_t i = (char *)i + 1)
        {
          if (*(void *)v39 != v27) {
            objc_enumerationMutation(v25);
          }
          [v22 addObject:*(void *)(*((void *)&v38 + 1) + 8 * i)];
        }
        id v26 = [v25 countByEnumeratingWithState:&v38 objects:v44 count:16];
      }
      while (v26);
    }
  }
  sub_1000305AC(buf, v37);
  *(void *)uu1 = buf;
  int v31 = sub_100737468(v21, buf, (uint64_t)&unk_1007BE9D0, (const unsigned __int8 *__attribute__((__org_typedef(uuid_t))) *)uu1);
  objc_storeStrong((id *)v31 + 6, v22);
  int v32 = qword_100A19F70;
  if (os_log_type_enabled((os_log_t)qword_100A19F70, OS_LOG_TYPE_DEFAULT))
  {
    long long v33 = (unsigned __int8 *)[v7 connectionUseCase];
    if (v20) {
      int v34 = 5;
    }
    else {
      int v34 = 0;
    }
    sub_1000305AC(uu1, v37);
    unsigned __int16 v43 = uu1;
    __int16 v35 = (void *)sub_100737468(v21, uu1, (uint64_t)&unk_1007BE9D0, (const unsigned __int8 *__attribute__((__org_typedef(uuid_t))) *)&v43)[6];
    *(_DWORD *)long long buf = 138544386;
    *(void *)&uint8_t buf[4] = v37;
    __int16 v48 = 2048;
    __int16 v49 = v33;
    __int16 v50 = 2048;
    __int16 v51 = (__CFString *)v18;
    __int16 v52 = 1024;
    *(_DWORD *)uint32_t v53 = v34;
    *(_WORD *)&v53[4] = 2114;
    *(void *)&v53[6] = v35;
    id v36 = v35;
    _os_log_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_DEFAULT, "Device %{public}@ connectionUseCase (req %ld computed %ld) priority %hhu bundleIDs %{public}@", buf, 0x30u);
  }
  sub_10003AFB4((uint64_t)v42);
}

void sub_100736198(_Unwind_Exception *a1, uint64_t a2, void *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, ...)
{
  va_start(va, a12);

  if (v13) {
  if (*(char *)(v16 - 177) < 0)
  }
    operator delete(*(void **)(v16 - 200));
  sub_10003AFB4((uint64_t)va);

  _Unwind_Resume(a1);
}

void sub_100736290(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  id v7 = a3;
  id v34 = a4;
  v39[0] = 0;
  v39[1] = 0;
  sub_10003AED0((uint64_t)v39, a1 + 16);
  sub_1000305AC(__p, v7);
  id v8 = (uint64_t **)(a1 + 128);
  *(void *)uu1 = __p;
  uint64_t v9 = +[NSMutableSet setWithSet:sub_100737468((uint64_t **)(a1 + 128), __p, (uint64_t)&unk_1007BE9D0, (const unsigned __int8 *__attribute__((__org_typedef(uuid_t))) *)uu1)[6]];
  int v10 = [v34 connectingClients];
  LODWORD(a4) = v10 == 0;

  if (a4)
  {
    sub_10003AE4C(a2, (uint64_t)__p);
    if (v45 >= 0) {
      id v15 = __p;
    }
    else {
      id v15 = *(unsigned char **)__p;
    }
    uint64_t v16 = +[NSString stringWithUTF8String:v15];
    [v9 removeObject:v16];

    if (SHIBYTE(v45) < 0) {
      operator delete(*(void **)__p);
    }
  }
  else
  {
    long long v37 = 0u;
    long long v38 = 0u;
    long long v35 = 0u;
    long long v36 = 0u;
    uint64_t v11 = [v34 connectingClients];
    id v12 = [v11 countByEnumeratingWithState:&v35 objects:v47 count:16];
    if (v12)
    {
      uint64_t v13 = *(void *)v36;
      do
      {
        for (uint64_t i = 0; i != v12; uint64_t i = (char *)i + 1)
        {
          if (*(void *)v36 != v13) {
            objc_enumerationMutation(v11);
          }
          [v9 removeObject:*(void *)(*((void *)&v35 + 1) + 8 * i)];
        }
        id v12 = [v11 countByEnumeratingWithState:&v35 objects:v47 count:16];
      }
      while (v12);
    }
  }
  if ([v9 count])
  {
    sub_1000305AC(__p, v7);
    *(void *)uu1 = __p;
    int v17 = sub_100737468(v8, __p, (uint64_t)&unk_1007BE9D0, (const unsigned __int8 *__attribute__((__org_typedef(uuid_t))) *)uu1);
    objc_storeStrong((id *)v17 + 6, v9);
  }
  unsigned int v18 = qword_100A19F70;
  if (os_log_type_enabled((os_log_t)qword_100A19F70, OS_LOG_TYPE_DEFAULT))
  {
    id v19 = [v34 connectionUseCase];
    sub_1000305AC(uu1, v7);
    long long v40 = uu1;
    BOOL v20 = (void *)sub_100737468(v8, uu1, (uint64_t)&unk_1007BE9D0, (const unsigned __int8 *__attribute__((__org_typedef(uuid_t))) *)&v40)[6];
    *(_DWORD *)std::string __p = 138543874;
    *(void *)&__p[4] = v7;
    __int16 v43 = 2048;
    id v44 = v19;
    __int16 v45 = 2114;
    char v46 = v20;
    id v21 = v20;
    _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "Device %{public}@ connectionUseCase (req %ld) bundleIDs %{public}@", __p, 0x20u);
  }
  if (qword_1009F7EE0 != -1) {
    dispatch_once(&qword_1009F7EE0, &stru_1009C0C00);
  }
  uint64_t v22 = off_1009F7ED8;
  sub_10003AE4C(a2, (uint64_t)__p);
  int v23 = SHIBYTE(v45);
  BOOL v24 = *(unsigned char **)__p;
  NSStringEncoding v25 = +[NSString defaultCStringEncoding];
  if (v23 >= 0) {
    id v26 = __p;
  }
  else {
    id v26 = v24;
  }
  uint64_t v27 = +[NSString stringWithCString:v26 encoding:v25];
  sub_1006C25FC((uint64_t)v22, v7, v27);

  if (SHIBYTE(v45) < 0) {
    operator delete(*(void **)__p);
  }
  if (qword_1009F7EE0 != -1) {
    dispatch_once(&qword_1009F7EE0, &stru_1009C0C00);
  }
  uint64_t v28 = off_1009F7ED8;
  sub_10003AE4C(a2, (uint64_t)__p);
  int v29 = SHIBYTE(v45);
  uint64_t v30 = *(unsigned char **)__p;
  NSStringEncoding v31 = +[NSString defaultCStringEncoding];
  if (v29 >= 0) {
    int v32 = __p;
  }
  else {
    int v32 = v30;
  }
  long long v33 = +[NSString stringWithCString:v32 encoding:v31];
  sub_1006C23F4((uint64_t)v28, v7, v33);

  if (SHIBYTE(v45) < 0) {
    operator delete(*(void **)__p);
  }

  sub_10003AFB4((uint64_t)v39);
}

void sub_1007366BC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,void *__p,uint64_t a26,int a27,__int16 a28,char a29,char a30)
{
  if (a30 < 0) {
    operator delete(__p);
  }

  sub_10003AFB4((uint64_t)&a19);
  _Unwind_Resume(a1);
}

void sub_10073676C(uint64_t a1, void *a2, uint64_t a3)
{
  id v5 = a2;
  v10[1] = 0;
  id v11 = v5;
  v10[0] = 0;
  sub_10003AED0((uint64_t)v10, a1 + 16);
  int v6 = *(void **)(a1 + 104);
  if (v6 != (void *)(a1 + 112))
  {
    while (![v5 isEqual:v6[4]])
    {
      id v7 = (void *)v6[1];
      if (v7)
      {
        do
        {
          id v8 = v7;
          id v7 = (void *)*v7;
        }
        while (v7);
      }
      else
      {
        do
        {
          id v8 = (void *)v6[2];
          BOOL v9 = *v8 == (void)v6;
          int v6 = v8;
        }
        while (!v9);
      }
      int v6 = v8;
      if (v8 == (void *)(a1 + 112)) {
        goto LABEL_11;
      }
    }
    sub_10030C604((uint64_t **)(a1 + 104), (uint64_t)v6);
  }
LABEL_11:
  if (a3)
  {
    v12[0] = &v11;
    sub_10044265C((uint64_t **)(a1 + 104), (unint64_t *)&v11, (uint64_t)&unk_1007BE9D0, v12)[5] = a3;
  }
  else
  {
    sub_1000305AC(v12, v5);
    sub_100737660((uint64_t **)(a1 + 128), (unsigned __int8 *)v12);
  }
  sub_10003AFB4((uint64_t)v10);
}

void sub_1007368B4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, uint64_t a11, id a12)
{
  _Unwind_Resume(a1);
}

void sub_1007368EC(void *a1)
{
  uint64_t v2 = qword_100A19F70;
  if (os_log_type_enabled((os_log_t)qword_100A19F70, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "statedump: ------------------ BT Resource Manager -------------------", buf, 2u);
    uint64_t v2 = qword_100A19F70;
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "statedump: Max Connections for use case:", buf, 2u);
    uint64_t v2 = qword_100A19F70;
  }
  uint64_t v3 = 0;
  int v4 = a1 + 11;
  do
  {
    unsigned int v5 = dword_1009FC020[v3];
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      int v6 = sub_100735410((uint64_t)a1, v5);
      uint64_t v7 = a1[11];
      if (!v7) {
        goto LABEL_18;
      }
      id v8 = a1 + 11;
      do
      {
        unsigned int v9 = *(_DWORD *)(v7 + 28);
        BOOL v10 = v9 >= v5;
        if (v9 >= v5) {
          id v11 = (uint64_t *)v7;
        }
        else {
          id v11 = (uint64_t *)(v7 + 8);
        }
        if (v10) {
          id v8 = (void *)v7;
        }
        uint64_t v7 = *v11;
      }
      while (*v11);
      if (v8 == v4 || v5 < *((_DWORD *)v8 + 7)) {
LABEL_18:
      }
        id v8 = a1 + 11;
      BOOL v12 = v8 == v4;
      *(_DWORD *)long long buf = 67109634;
      uint64_t v13 = "YES";
      if (v12) {
        uint64_t v13 = "NO";
      }
      *(_DWORD *)&uint8_t buf[4] = v5;
      *(_WORD *)&uint8_t buf[8] = 1024;
      *(_DWORD *)&buf[10] = v6;
      *(_WORD *)&buf[14] = 2082;
      *(void *)&uint8_t buf[16] = v13;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "statedump:  useCase:%d maxConnections:%d (override:%{public}s)", buf, 0x18u);
      uint64_t v2 = qword_100A19F70;
    }
    ++v3;
  }
  while (v3 != 9);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "statedump: current device states and use cases:", buf, 2u);
    uint64_t v2 = qword_100A19F70;
  }
  id v14 = (void *)a1[13];
  if (v14 != a1 + 14)
  {
    do
    {
      if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
      {
        unint64_t v15 = v14[5];
        uint64_t v16 = "unknown";
        if (v15 <= 3) {
          uint64_t v16 = off_1009C0C20[v15];
        }
        uint64_t v17 = v14[4];
        if (qword_1009F7EE0 != -1) {
          dispatch_once(&qword_1009F7EE0, &stru_1009C0C00);
        }
        int v18 = sub_1006BDC1C((uint64_t)off_1009F7ED8, (void *)v14[4]);
        *(_DWORD *)long long buf = 138543874;
        *(void *)&uint8_t buf[4] = v17;
        *(_WORD *)&unsigned char buf[12] = 2082;
        *(void *)&buf[14] = v16;
        *(_WORD *)&unsigned char buf[22] = 1024;
        *(_DWORD *)&uint8_t buf[24] = v18;
        _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "statedump:  device:%{public}@ state:%{public}s usecase:%u", buf, 0x1Cu);
        uint64_t v2 = qword_100A19F70;
      }
      id v19 = (void *)v14[1];
      if (v19)
      {
        do
        {
          BOOL v20 = v19;
          id v19 = (void *)*v19;
        }
        while (v19);
      }
      else
      {
        do
        {
          BOOL v20 = (void *)v14[2];
          BOOL v12 = *v20 == (void)v14;
          id v14 = v20;
        }
        while (!v12);
      }
      id v14 = v20;
    }
    while (v20 != a1 + 14);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "statedump: current device connect request bundleIDs:", buf, 2u);
  }
  id v21 = (const unsigned __int8 *)a1[16];
  if (v21 != (const unsigned __int8 *)(a1 + 17))
  {
    do
    {
      uint64_t v64 = 0;
      long long v62 = 0u;
      long long v63 = 0u;
      long long v60 = 0u;
      long long v61 = 0u;
      long long v58 = 0u;
      long long v59 = 0u;
      long long v56 = 0u;
      long long v57 = 0u;
      long long v54 = 0u;
      long long v55 = 0u;
      long long v52 = 0u;
      long long v53 = 0u;
      long long v50 = 0u;
      long long v51 = 0u;
      long long v49 = 0u;
      memset(buf, 0, sizeof(buf));
      sub_10004C67C((uint64_t)buf);
      long long v41 = 0u;
      long long v42 = 0u;
      long long v39 = 0u;
      long long v40 = 0u;
      id v22 = *((id *)v21 + 6);
      id v23 = [v22 countByEnumeratingWithState:&v39 objects:v47 count:16];
      if (v23)
      {
        uint64_t v24 = *(void *)v40;
        do
        {
          for (uint64_t i = 0; i != v23; uint64_t i = (char *)i + 1)
          {
            if (*(void *)v40 != v24) {
              objc_enumerationMutation(v22);
            }
            strlen((const char *)[*(id *)(*((void *)&v39 + 1) + 8 * i) UTF8String]);
            uint64_t v26 = sub_10003AB28((uint64_t)&buf[16]);
            sub_10003AB28(v26);
          }
          id v23 = [v22 countByEnumeratingWithState:&v39 objects:v47 count:16];
        }
        while (v23);
      }

      uint64_t v27 = qword_100A19F70;
      if (os_log_type_enabled((os_log_t)qword_100A19F70, OS_LOG_TYPE_DEFAULT))
      {
        memset(out, 0, sizeof(out));
        uuid_unparse_upper(v21 + 32, out);
        sub_10004191C(__p, out);
        int v28 = v38;
        int v29 = (void **)__p[0];
        std::stringbuf::str();
        uint64_t v30 = __p;
        if (v28 < 0) {
          uint64_t v30 = v29;
        }
        NSStringEncoding v31 = out;
        if (out[23] < 0) {
          NSStringEncoding v31 = *(char **)out;
        }
        *(_DWORD *)__int16 v43 = 136446466;
        id v44 = v30;
        __int16 v45 = 2082;
        char v46 = v31;
        _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "statedump:  device:%{public}s connectRequestBundleIDs:%{public}s", v43, 0x16u);
        if (out[23] < 0) {
          operator delete(*(void **)out);
        }
        if (v38 < 0) {
          operator delete(__p[0]);
        }
      }
      *(void *)long long buf = v36;
      *(void *)&buf[*(void *)(v36 - 24)] = v35;
      *(void *)&uint8_t buf[16] = v34;
      if (SHIBYTE(v53) < 0) {
        operator delete(*((void **)&v52 + 1));
      }
      std::streambuf::~streambuf();
      std::iostream::~basic_iostream();
      std::ios::~ios();
      int v32 = (unsigned __int8 *)*((void *)v21 + 1);
      if (v32)
      {
        do
        {
          long long v33 = (const unsigned __int8 **)v32;
          int v32 = *(unsigned __int8 **)v32;
        }
        while (v32);
      }
      else
      {
        do
        {
          long long v33 = (const unsigned __int8 **)*((void *)v21 + 2);
          BOOL v12 = *v33 == v21;
          id v21 = (const unsigned __int8 *)v33;
        }
        while (!v12);
      }
      id v21 = (const unsigned __int8 *)v33;
    }
    while (v33 != a1 + 17);
  }
}

void sub_100736FDC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21,int a22,__int16 a23,char a24,char a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,char a54)
{
  if (a25 < 0) {
    operator delete(__p);
  }
  sub_100742518((uint64_t)&a54);
  _Unwind_Resume(a1);
}

uint64_t sub_100737024(uint64_t a1, unint64_t a2, void *a3)
{
  id v5 = a3;
  if (v5)
  {
    uint64_t v6 = sub_100017768();
    if (((*(uint64_t (**)(uint64_t))(*(void *)v6 + 8))(v6) & 1) != 0
      && (([v5 hasPrefix:@"com.apple."] & 1) != 0
       || [v5 hasPrefix:@"com.Apple."]))
    {
      uint64_t v7 = CBGenerateObfuscatedSHA256HashedString();
      id v8 = v7;
      if (a2 < 3)
      {
        if ([(id)*(&off_1009C0C40)[a2] containsObject:v7])
        {
          if (*(unsigned char *)(a1 + 154))
          {
            uint64_t v9 = 1;
LABEL_17:

            goto LABEL_13;
          }
          BOOL v12 = qword_100A19F70;
          uint64_t v9 = 0;
          if (!os_log_type_enabled((os_log_t)qword_100A19F70, OS_LOG_TYPE_DEFAULT)) {
            goto LABEL_17;
          }
          int v13 = 138543618;
          id v14 = v5;
          __int16 v15 = 2048;
          unint64_t v16 = a2;
          _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "%{public}@ is required to provide the use case for operation type %ld but check is bypassed due to overriding", (uint8_t *)&v13, 0x16u);
        }
        uint64_t v9 = 0;
        goto LABEL_17;
      }
    }
    goto LABEL_12;
  }
  BOOL v10 = qword_100A19F70;
  uint64_t v9 = 0;
  if (os_log_type_enabled((os_log_t)qword_100A19F70, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v13) = 0;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "BundleID is not available.", (uint8_t *)&v13, 2u);
LABEL_12:
    uint64_t v9 = 0;
  }
LABEL_13:

  return v9;
}

void sub_1007371F8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id sub_100737224(uint64_t a1, void *a2)
{
  id v3 = a2;
  v7[0] = 0;
  v7[1] = 0;
  sub_10003AED0((uint64_t)v7, a1 + 16);
  sub_1000305AC(uu2, v3);
  if (a1 + 136 == sub_1000308C0(a1 + 128, uu2))
  {
    id v4 = +[NSSet setWithObject:@"com.unknown"];
  }
  else
  {
    sub_1000305AC(uu2, v3);
    id v8 = uu2;
    id v4 = (id)sub_100737468((uint64_t **)(a1 + 128), uu2, (uint64_t)&unk_1007BE9D0, (const unsigned __int8 *__attribute__((__org_typedef(uuid_t))) *)&v8)[6];
  }
  id v5 = v4;
  sub_10003AFB4((uint64_t)v7);

  return v5;
}

void sub_100737338(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_10003AFB4((uint64_t)va);

  _Unwind_Resume(a1);
}

void sub_10073736C(uint64_t a1)
{
  sub_1007376E4(a1);

  operator delete();
}

void sub_1007373A4(uint64_t a1, void *a2)
{
  if (a2)
  {
    sub_1007373A4(a1, *a2);
    sub_1007373A4(a1, a2[1]);

    operator delete(a2);
  }
}

void sub_100737400(id a1)
{
}

void sub_100737444()
{
}

uint64_t *sub_100737468(uint64_t **a1, unsigned __int8 *uu1, uint64_t a3, const unsigned __int8 *__attribute__((__org_typedef(uuid_t))) *a4)
{
  uint64_t v9 = 0;
  uint64_t v6 = (uint64_t **)sub_10004A0BC((uint64_t)a1, &v9, uu1);
  uint64_t result = *v6;
  if (!*v6)
  {
    memset(v8, 0, sizeof(v8));
    sub_10073750C((uint64_t)a1, a4, v8);
    sub_100036CA0(a1, v9, v6, (uint64_t *)v8[0]);
    return (uint64_t *)v8[0];
  }
  return result;
}

void sub_10073750C(uint64_t a1@<X0>, const unsigned __int8 *__attribute__((__org_typedef(uuid_t))) *a2@<X2>, unsigned __int8 **a3@<X8>)
{
  uint64_t v5 = a1 + 8;
  *a3 = 0;
  a3[2] = 0;
  a3[1] = 0;
  uint64_t v6 = a3 + 1;
  uint64_t v7 = (unsigned __int8 *)operator new(0x38uLL);
  *a3 = v7;
  *uint64_t v6 = v5;
  *((unsigned char *)a3 + 16) = 0;
  uuid_copy(v7 + 32, *a2);
  *((void *)v7 + 6) = 0;
  *((unsigned char *)a3 + 16) = 1;
}

void sub_100737584(_Unwind_Exception *a1)
{
  *id v1 = 0;
  sub_1007375A0(v2, v3);
  _Unwind_Resume(a1);
}

void sub_1007375A0(uint64_t a1, id *a2)
{
  if (*(unsigned char *)(a1 + 8))
  {
  }
  else if (!a2)
  {
    return;
  }

  operator delete(a2);
}

void sub_1007375F8(id a1)
{
}

void sub_10073763C()
{
}

uint64_t sub_100737660(uint64_t **a1, unsigned __int8 *a2)
{
  uint64_t v3 = sub_1000308C0((uint64_t)a1, a2);
  if (a1 + 1 == (uint64_t **)v3) {
    return 0;
  }
  sub_1007376A8(a1, v3);
  return 1;
}

uint64_t *sub_1007376A8(uint64_t **a1, uint64_t a2)
{
  uint64_t v3 = sub_10004D3B8(a1, (uint64_t *)a2);

  operator delete((void *)a2);
  return v3;
}

uint64_t sub_1007376E4(uint64_t a1)
{
  *(void *)a1 = &off_1009C0BD0;
  sub_1007373A4(a1 + 128, *(void **)(a1 + 136));
  sub_10000EDA0(a1 + 104, *(void **)(a1 + 112));
  sub_1000486F0(a1 + 80, *(void **)(a1 + 88));
  sub_100052DA4(a1 + 16);
  return a1;
}

void *sub_10073774C(void *a1)
{
  uint64_t v2 = sub_1005C3400(a1);
  *((_DWORD *)v2 + 4) = 0;
  *((_WORD *)v2 + 10) = 0;
  if (sub_1007377E8((int)v2, "bluetooth", (uint64_t)(v2 + 2)))
  {
    sub_100737964((uint64_t)a1);
  }
  else
  {
    uint64_t v3 = sub_100737BD8();

    if (v3)
    {
      CFPreferencesSetAppValue(@"GeneratedLocalAddress", 0, @"com.apple.BTServer");
      CFPreferencesAppSynchronize(@"com.apple.BTServer");
    }
  }
  return a1;
}

void sub_1007377D4(_Unwind_Exception *a1)
{
  sub_1005C3408(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1007377E8(int a1, char *name, uint64_t a3)
{
  CFDictionaryRef v4 = IOServiceNameMatching(name);
  if (!v4) {
    return 1;
  }
  io_service_t MatchingService = IOServiceGetMatchingService(kIOMainPortDefault, v4);
  if (!MatchingService) {
    return 1;
  }
  io_object_t v6 = MatchingService;
  __int16 v13 = 0;
  *(_DWORD *)buffer = 0;
  uint64_t v7 = 1;
  CFDataRef v8 = (const __CFData *)IORegistryEntrySearchCFProperty(MatchingService, "IODeviceTree", @"local-mac-address", kCFAllocatorDefault, 1u);
  if (v8)
  {
    CFDataRef v9 = v8;
    v20.location = 0;
    v20.size_t length = 6;
    CFDataGetBytes(v8, v20, buffer);
    *(_DWORD *)a3 = *(_DWORD *)buffer;
    *(_WORD *)(a3 + 4) = v13;
    BOOL v10 = qword_100A19FE8;
    if (os_log_type_enabled((os_log_t)qword_100A19FE8, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 136315650;
      __int16 v15 = "getAddressFrom";
      __int16 v16 = 1040;
      int v17 = 6;
      __int16 v18 = 2096;
      id v19 = buffer;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "%s: DeviceTree address = %{bluetooth:BD_ADDR}.6P", buf, 0x1Cu);
    }
    CFRelease(v9);
    uint64_t v7 = 0;
  }
  IOObjectRelease(v6);
  return v7;
}

void sub_100737964(uint64_t a1)
{
  __int16 v11 = 0;
  int v10 = 0;
  uint64_t v2 = sub_100737BD8();
  uint64_t v3 = v2;
  if (v2 && [v2 length])
  {
    id v4 = v3;
    sscanf((const char *)[v4 UTF8String], "%02hhx:%02hhx:%02hhx:%02hhx:%02hhx:%02hhx", &v10, (char *)&v10 + 1, (char *)&v10 + 2, (char *)&v10 + 3, &v11, (char *)&v11 + 1);
    uint64_t v5 = (id)qword_100A19FE8;
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      io_object_t v6 = (char *)[v4 UTF8String];
      *(_DWORD *)long long buf = 136315394;
      __int16 v16 = "getGeneratedLocalAddress";
      __int16 v17 = 2080;
      __int16 v18 = v6;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "%s Local address from plist:%s.\n", buf, 0x16u);
    }
  }
  else
  {
    for (uint64_t i = 0; i != 6; ++i)
      *((unsigned char *)&v10 + i) = arc4random_uniform(0xFFu);
    *(void *)__str = 0;
    uint64_t v13 = 0;
    __int16 v14 = 0;
    snprintf(__str, 0x12uLL, "%02x:%02x:%02x:%02x:%02x:%02x", v10, BYTE1(v10), BYTE2(v10), HIBYTE(v10), v11, HIBYTE(v11));
    CFDataRef v8 = +[NSString stringWithUTF8String:__str];
    sub_100737C14((uint64_t)v8, v8);

    CFDataRef v9 = qword_100A19FE8;
    if (os_log_type_enabled((os_log_t)qword_100A19FE8, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 136315394;
      __int16 v16 = "getGeneratedLocalAddress";
      __int16 v17 = 2080;
      __int16 v18 = __str;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "%s Storing local address to plist:%s.\n", buf, 0x16u);
    }
  }
  *(_DWORD *)(a1 + 16) = v10;
  *(_WORD *)(a1 + 20) = v11;
}

void sub_100737BA0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id sub_100737BD8()
{
  uint64_t v0 = (void *)CFPreferencesCopyAppValue(@"GeneratedLocalAddress", @"com.apple.BTServer");

  return v0;
}

void sub_100737C14(uint64_t a1, void *a2)
{
  id v2 = a2;
  CFPreferencesSetAppValue(@"GeneratedLocalAddress", v2, @"com.apple.BTServer");
  CFPreferencesAppSynchronize(@"com.apple.BTServer");
}

void sub_100737C78(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

uint64_t sub_100737C8C()
{
  uint64_t v0 = qword_100A19FE8;
  if (os_log_type_enabled((os_log_t)qword_100A19FE8, OS_LOG_TYPE_DEFAULT))
  {
    int v2 = 136315138;
    uint64_t v3 = "registerCallbacks";
    _os_log_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_DEFAULT, "%s", (uint8_t *)&v2, 0xCu);
  }
  return sub_100247858((uint64_t)off_1009FC048);
}

BOOL sub_100737D40(uint64_t *a1, _DWORD *a2, uint64_t *a3)
{
  io_object_t v6 = qword_100A19FE8;
  if (os_log_type_enabled((os_log_t)qword_100A19FE8, OS_LOG_TYPE_DEFAULT))
  {
    int v12 = 136315138;
    uint64_t v13 = "TransportCreate";
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "%s", (uint8_t *)&v12, 0xCu);
  }
  BOOL v7 = sub_1005C3564(a1, a2, a3);
  if (v7)
  {
    BOOL v8 = sub_1005C3484(a1, *a3);
    CFDataRef v9 = qword_100A19FE8;
    BOOL v10 = os_log_type_enabled((os_log_t)qword_100A19FE8, OS_LOG_TYPE_DEFAULT);
    if (v8)
    {
      if (v10)
      {
        int v12 = 136315138;
        uint64_t v13 = "TransportCreate";
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "%s: Link Controller, activate", (uint8_t *)&v12, 0xCu);
      }
      if (qword_1009FBAB0 != -1) {
        dispatch_once(&qword_1009FBAB0, &stru_1009C0C58);
      }
      sub_100443F78((id *)qword_1009FBAA8);
    }
    else if (v10)
    {
      int v12 = 136315138;
      uint64_t v13 = "TransportCreate";
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "%s: Not Hci Transport Command", (uint8_t *)&v12, 0xCu);
    }
  }
  return v7;
}

uint64_t sub_100737EFC(uint64_t *a1, uint64_t *a2)
{
  BOOL v4 = sub_1005C3484(a1, *a2);
  uint64_t v5 = qword_100A19FE8;
  BOOL v6 = os_log_type_enabled((os_log_t)qword_100A19FE8, OS_LOG_TYPE_DEFAULT);
  if (v4)
  {
    if (v6)
    {
      int v8 = 136315138;
      CFDataRef v9 = "TransportFree";
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "%s: Link Controller Invalidate", (uint8_t *)&v8, 0xCu);
    }
    if (qword_1009FBAB0 != -1) {
      dispatch_once(&qword_1009FBAB0, &stru_1009C0C58);
    }
    sub_1004443C0((id *)qword_1009FBAA8);
  }
  else if (v6)
  {
    int v8 = 136315138;
    CFDataRef v9 = "TransportFree";
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "%s: Invalidate Link Controller faile, invalid handle", (uint8_t *)&v8, 0xCu);
  }
  return sub_1005C37D0(a1, a2);
}

uint64_t sub_100738048()
{
  if (qword_1009FBAA0 != -1) {
    dispatch_once(&qword_1009FBAA0, &stru_1009C0C78);
  }
  uint64_t v0 = off_1009FBA98;

  return nullsub_95(v0);
}

BOOL sub_1007380AC(_DWORD *a1, uint64_t *a2)
{
  if (qword_1009FBAA0 != -1) {
    dispatch_once(&qword_1009FBAA0, &stru_1009C0C78);
  }
  BOOL v4 = (uint64_t *)off_1009FBA98;

  return sub_100737D40(v4, a1, a2);
}

uint64_t sub_100738118(uint64_t *a1)
{
  if (qword_1009FBAA0 != -1) {
    dispatch_once(&qword_1009FBAA0, &stru_1009C0C78);
  }
  int v2 = (uint64_t *)off_1009FBA98;

  return sub_100737EFC(v2, a1);
}

uint64_t sub_10073817C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  if (qword_1009FBAA0 != -1) {
    dispatch_once(&qword_1009FBAA0, &stru_1009C0C78);
  }
  int v12 = off_1009FBA98;

  return sub_1005C39AC(v12, a1, a2, a3, a4, a5, a6);
}

BOOL sub_100738218(uint64_t a1)
{
  if (qword_1009FBAA0 != -1) {
    dispatch_once(&qword_1009FBAA0, &stru_1009C0C78);
  }
  int v2 = off_1009FBA98;

  return sub_1005C3A60(v2, a1);
}

void sub_10073827C(id a1)
{
}

void sub_1007382C0()
{
}

void sub_1007382E4(id a1)
{
}

void sub_100738328()
{
}

void sub_10073843C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id sub_10073845C(uint64_t a1, void *a2)
{
  uint64_t v3 = qword_100A19EF0;
  if (os_log_type_enabled((os_log_t)qword_100A19EF0, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v5 = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Received 'favorites changed' notification", v5, 2u);
  }
  [a2 _incrementPrimaryFolderVersionForAddressBook:8];
  return [a2 _incrementSecondaryFolderVersionForAddressBook:8];
}

void sub_100738640(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1007387D4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100738960(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100738B10(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100738C94(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100738E90(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_10073902C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1007390C0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_100739194(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void *sub_100739230(void *a1)
{
  *a1 = off_1009C0CA8;
  a1[1] = 0;
  int v2 = objc_alloc_init(AddressBookObserver);
  uint64_t v3 = (void *)a1[1];
  a1[1] = v2;

  return a1;
}

void sub_100739288(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id sub_1007392A0(uint64_t a1, uint64_t a2)
{
  return [*(id *)(a1 + 8) getPrimaryFolderVersionForAddressBook:a2];
}

id sub_1007392AC(uint64_t a1, uint64_t a2)
{
  return [*(id *)(a1 + 8) getSecondaryFolderVersionForAddressBook:a2];
}

id sub_1007392B8(uint64_t a1)
{
  return [*(id *)(a1 + 8) getDatabaseIdentifier];
}

id sub_1007392C0(uint64_t a1)
{
  return [*(id *)(a1 + 8) incrementMainAddressBookVersions];
}

uint64_t sub_1007392C8(uint64_t a1)
{
  return a1;
}

void sub_1007392F4(uint64_t a1)
{
  operator delete();
}

uint64_t sub_100739340(uint64_t a1)
{
  *(void *)a1 = off_1009C0D20;
  *(void *)(a1 + 8) = &off_1009C0E30;
  *(void *)(a1 + 16) = off_1009C0E48;
  *(void *)(a1 + 24) = &off_1009C0EB0;
  *(void *)(a1 + 32) = off_1009C0EC8;
  *(void *)(a1 + 40) = off_1009C0F78;
  *(void *)(a1 + 48) = &off_1009C0FC8;
  *(void *)(a1 + 56) = &off_1009C0FE0;
  *(void *)(a1 + 64) = off_1009C0FF8;
  *(void *)(a1 + 72) = off_1009C1058;
  sub_100052DA8(a1 + 80);
  *(_OWORD *)(a1 + 168) = 0u;
  *(void *)(a1 + 336) = 0;
  *(unsigned char *)(a1 + 280) = 0;
  *(_OWORD *)(a1 + 184) = 0u;
  *(_OWORD *)(a1 + 200) = 0u;
  *(_OWORD *)(a1 + 216) = 0u;
  *(_OWORD *)(a1 + 232) = 0u;
  *(_OWORD *)(a1 + 248) = 0u;
  *(_OWORD *)(a1 + 263) = 0u;
  *(void *)(a1 + 328) = a1 + 336;
  *(void *)(a1 + 360) = 0;
  *(void *)(a1 + 368) = 0;
  *(void *)(a1 + 344) = 0;
  *(void *)(a1 + 352) = a1 + 360;
  *(void *)(a1 + 376) = a1 + 384;
  *(void *)(a1 + 384) = 0;
  *(void *)(a1 + 408) = 0;
  *(void *)(a1 + 416) = 0;
  *(void *)(a1 + 392) = 0;
  *(void *)(a1 + 400) = a1 + 408;
  *(void *)(a1 + 432) = 0;
  *(void *)(a1 + 440) = 0;
  *(void *)(a1 + 424) = a1 + 432;
  *(unsigned char *)(a1 + 448) = 0;
  *(unsigned char *)(a1 + 452) = 0;
  *(_DWORD *)(a1 + 456) = 0;
  *(unsigned char *)(a1 + 460) = 0;
  *(_DWORD *)(a1 + 464) = 0;
  *(void *)(a1 + 472) = 0;
  *(_DWORD *)(a1 + 480) = 0;
  *(void *)(a1 + 496) = 0;
  *(void *)(a1 + 504) = 0;
  *(void *)(a1 + 488) = 0;
  char v16 = 0;
  uint64_t v2 = sub_100017768();
  sub_10004191C(buf, "CoexManager");
  sub_10004191C(__p, "Disable");
  int v3 = (*(uint64_t (**)(uint64_t, uint8_t *, void **, char *))(*(void *)v2 + 72))(v2, buf, __p, &v16);
  if (v16) {
    int v4 = v3;
  }
  else {
    int v4 = 0;
  }
  if (v13 < 0) {
    operator delete(__p[0]);
  }
  if (v15 < 0)
  {
    operator delete(*(void **)buf);
    if (v4)
    {
LABEL_8:
      uint64_t v5 = qword_100A19E58;
      if (os_log_type_enabled((os_log_t)qword_100A19E58, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "Warning: Disabling WCM interface because of override default", buf, 2u);
      }
      return a1;
    }
  }
  else if (v4)
  {
    goto LABEL_8;
  }
  if (&WCMEnabled)
  {
    mach_service = xpc_connection_create_mach_service("com.apple.WirelessCoexManager", 0, 0);
    *(void *)(a1 + 144) = mach_service;
    handler[0] = _NSConcreteStackBlock;
    handler[1] = 3221225472;
    handler[2] = sub_10004D7B0;
    handler[3] = &unk_1009A0598;
    handler[4] = a1;
    xpc_connection_set_event_handler(mach_service, handler);
    xpc_connection_resume(*(xpc_connection_t *)(a1 + 144));
  }
  else if (os_log_type_enabled((os_log_t)qword_100A19E58, OS_LOG_TYPE_ERROR))
  {
    sub_10079A434();
  }
  *(unsigned char *)(a1 + 154) = 0;
  int v10 = 0;
  uint64_t v7 = sub_100017768();
  sub_10004191C(buf, "BTUCM");
  sub_10004191C(__p, "BTUCMForceFacetimeWifiCoexOverride");
  *(unsigned char *)(a1 + 154) = (*(uint64_t (**)(uint64_t, uint8_t *, void **, int *))(*(void *)v7 + 88))(v7, buf, __p, &v10);
  if (v13 < 0) {
    operator delete(__p[0]);
  }
  if (v15 < 0) {
    operator delete(*(void **)buf);
  }
  if (*(unsigned char *)(a1 + 154)) {
    int v8 = v10;
  }
  else {
    int v8 = 0;
  }
  *(_DWORD *)(a1 + 156) = v8;
  *(void *)(a1 + 160) = 0;
  *(unsigned char *)(a1 + 452) = 0;
  *(_DWORD *)(a1 + 456) = 0;
  *(unsigned char *)(a1 + 460) = 0;
  *(_DWORD *)(a1 + 464) = 0;
  return a1;
}

void sub_100739780(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,void *a22,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  if (a27 < 0) {
    operator delete(a22);
  }
  uint64_t v31 = v29;
  uint64_t v32 = v29 - 8;
  uint64_t v33 = v31 + 16;
  uint64_t v34 = v31 + 40;
  uint64_t v35 = v31 + 64;
  uint64_t v36 = v31 + 88;
  long long v37 = *(void **)(v31 + 152);
  if (v37)
  {
    *(void *)(v27 + 496) = v37;
    operator delete(v37);
  }

  sub_1000486F0(v36, *(void **)(v27 + 432));
  sub_1000486F0(v35, *(void **)(v27 + 408));
  sub_1000486F0(v34, *(void **)(v27 + 384));
  sub_1000486F0(v33, *(void **)(v27 + 360));
  sub_1000486F0(v32, *(void **)(v27 + 336));
  sub_100052DA4(v28);
  _Unwind_Resume(a1);
}

uint64_t sub_100739848(uint64_t a1)
{
  *(void *)a1 = off_1009C0D20;
  *(void *)(a1 + 8) = &off_1009C0E30;
  *(void *)(a1 + 16) = off_1009C0E48;
  *(void *)(a1 + 24) = &off_1009C0EB0;
  *(void *)(a1 + 32) = off_1009C0EC8;
  *(void *)(a1 + 40) = off_1009C0F78;
  *(void *)(a1 + 48) = &off_1009C0FC8;
  *(void *)(a1 + 56) = &off_1009C0FE0;
  *(void *)(a1 + 64) = off_1009C0FF8;
  *(void *)(a1 + 72) = off_1009C1058;
  if (&WCMEnabled) {
    xpc_release(*(xpc_object_t *)(a1 + 144));
  }
  uint64_t v2 = *(void **)(a1 + 488);
  if (v2)
  {
    *(void *)(a1 + 496) = v2;
    operator delete(v2);
  }

  sub_1000486F0(a1 + 424, *(void **)(a1 + 432));
  sub_1000486F0(a1 + 400, *(void **)(a1 + 408));
  sub_1000486F0(a1 + 376, *(void **)(a1 + 384));
  sub_1000486F0(a1 + 352, *(void **)(a1 + 360));
  sub_1000486F0(a1 + 328, *(void **)(a1 + 336));
  sub_100052DA4(a1 + 80);
  return a1;
}

void sub_100739A18(_Unwind_Exception *a1)
{
  int v3 = *(void **)(v1 + 488);
  if (v3)
  {
    *(void *)(v1 + 496) = v3;
    operator delete(v3);
  }

  sub_1000486F0(v1 + 424, *(void **)(v1 + 432));
  sub_1000486F0(v1 + 400, *(void **)(v1 + 408));
  sub_1000486F0(v1 + 376, *(void **)(v1 + 384));
  sub_1000486F0(v1 + 352, *(void **)(v1 + 360));
  sub_1000486F0(v1 + 328, *(void **)(v1 + 336));
  sub_100052DA4(v1 + 80);
  _Unwind_Resume(a1);
}

void sub_100739A84(uint64_t a1)
{
  sub_100739848(a1);

  operator delete();
}

uint64_t sub_100739ABC(uint64_t a1, uint64_t a2)
{
  v5[0] = 0;
  v5[1] = 0;
  sub_10003AED0((uint64_t)v5, a1 + 80);
  sub_100739B20(a1 + 480, a2);
  return sub_10003AFB4((uint64_t)v5);
}

void sub_100739B0C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_100739B20(uint64_t a1, uint64_t a2)
{
  os_unfair_lock_lock((os_unfair_lock_t)a1);
  uint64_t v5 = *(char **)(a1 + 8);
  int v4 = *(char **)(a1 + 16);
  if (v5 != v4)
  {
    while (*(void *)v5 != a2)
    {
      v5 += 8;
      if (v5 == v4)
      {
        uint64_t v5 = *(char **)(a1 + 16);
        break;
      }
    }
  }
  if (v5 == v4)
  {
    uint64_t v6 = a2;
    sub_100741AB8(a1 + 8, v4, (char *)&v6);
    sub_100061554(a1 + 8);
  }
  os_unfair_lock_unlock((os_unfair_lock_t)a1);
}

uint64_t sub_100739BAC(uint64_t a1, uint64_t a2)
{
  v5[0] = 0;
  v5[1] = 0;
  sub_10003AED0((uint64_t)v5, a1 + 80);
  sub_100052718(a1 + 480, a2);
  return sub_10003AFB4((uint64_t)v5);
}

void sub_100739BFC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_100739C10(uint64_t a1)
{
  if (&WCMEnabled)
  {
    sub_100739F04(a1);
    if (qword_1009F8090 != -1) {
      dispatch_once(&qword_1009F8090, &stru_1009C1108);
    }
    sub_1004D12B0(off_1009F8088, a1 + 8);
    if (qword_1009F8748 != -1) {
      dispatch_once(&qword_1009F8748, &stru_1009C1128);
    }
    sub_1002C3EBC((uint64_t)off_1009F8740 + 80, a1 + 24);
    if (qword_1009F7EC0 != -1) {
      dispatch_once(&qword_1009F7EC0, &stru_1009C1148);
    }
    sub_100680938((uint64_t)off_1009F7EB8, a1 + 32, 0);
    if (qword_1009F8158 != -1) {
      dispatch_once(&qword_1009F8158, &stru_1009C1168);
    }
    sub_1004F9E94((uint64_t)off_1009F8150, a1 + 40);
    uint64_t v2 = sub_10003FFD4();
    sub_10026B948(v2 + 288, a1 + 48);
    if (qword_1009FB3D0 != -1) {
      dispatch_once(&qword_1009FB3D0, &stru_1009C1188);
    }
    sub_1005442CC(qword_1009FB3C8, a1 + 56);
    if (qword_1009F85C8 != -1) {
      dispatch_once(&qword_1009F85C8, &stru_1009C11A8);
    }
    sub_1000A7BDC((uint64_t)off_1009F85C0 + 1872, a1 + 64);
    if (qword_1009F7F00 != -1) {
      dispatch_once(&qword_1009F7F00, &stru_1009C11C8);
    }
    sub_100061288((uint64_t)off_1009F7EF8 + 240, a1 + 72);
    *(void *)&long long v3 = -1;
    *((void *)&v3 + 1) = -1;
    *(_OWORD *)(a1 + 248) = v3;
    *(_OWORD *)(a1 + 232) = v3;
    *(_OWORD *)(a1 + 216) = v3;
    *(_OWORD *)(a1 + 200) = v3;
    *(_OWORD *)(a1 + 184) = v3;
    *(_OWORD *)(a1 + 168) = v3;
    int v4 = *(void **)(a1 + 472);
    *(void *)(a1 + 472) = @"XZ";

    if (qword_1009F8158 != -1) {
      dispatch_once(&qword_1009F8158, &stru_1009C1168);
    }
    sub_1004FA970((uint64_t)off_1009F8150, *(void **)(a1 + 472));
    *(_DWORD *)(a1 + 281) = 0;
    *(_OWORD *)(a1 + 288) = xmmword_1007C0780;
    *(void *)(a1 + 304) = 0;
    *(void *)(a1 + 312) = 0;
    *(_DWORD *)(a1 + 320) = 0;
    uint64_t v5 = sub_1004AF8EC();
    v6[0] = _NSConcreteStackBlock;
    v6[1] = 3221225472;
    void v6[2] = sub_100739FAC;
    v6[3] = &unk_100997528;
    v6[4] = a1;
    sub_100013018(v5, v6);
    sub_10073A068(a1);
    sub_10073A198((uint32x2_t *)a1);
  }
  else if (os_log_type_enabled((os_log_t)qword_100A19E58, OS_LOG_TYPE_ERROR))
  {
    sub_10079A560();
  }
}

void sub_100739F04(uint64_t a1)
{
  uint64_t v2 = qword_100A19E58;
  if (os_log_type_enabled((os_log_t)qword_100A19E58, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)int v4 = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Checking in with WCM", v4, 2u);
  }
  xpc_object_t v3 = xpc_dictionary_create(0, 0, 0);
  xpc_dictionary_set_uint64(v3, "kWCMRegisterProcess_ProcessId", 4uLL);
  sub_10073A58C(a1, 1uLL, v3);
  xpc_release(v3);
}

uint64_t sub_100739FAC(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  __int16 v8 = 0;
  __int16 v7 = 0;
  char v6 = 0;
  int v5 = 0;
  uint64_t v2 = sub_10003FFD4();
  uint64_t result = (*(uint64_t (**)(uint64_t, char *, __int16 *, char *, __int16 *, char *, int *))(*(void *)v2 + 48))(v2, (char *)&v8 + 1, &v8, (char *)&v7 + 1, &v7, &v6, &v5);
  if (!result)
  {
    *(unsigned char *)(v1 + 452) = v7;
    if (HIBYTE(v8))
    {
      int v4 = 1;
    }
    else if ((_BYTE)v8)
    {
      int v4 = 2;
    }
    else
    {
      if (!HIBYTE(v7))
      {
        *(_DWORD *)(v1 + 456) = 0;
        return result;
      }
      int v4 = 3;
    }
    *(_DWORD *)(v1 + 456) = v4;
  }
  return result;
}

void sub_10073A068(uint64_t a1)
{
  if (qword_1009F8748 != -1) {
    dispatch_once(&qword_1009F8748, &stru_1009C1128);
  }
  int v2 = sub_100028CB4((uint64_t)off_1009F8740);
  xpc_object_t v3 = qword_100A19E58;
  if (os_log_type_enabled((os_log_t)qword_100A19E58, OS_LOG_TYPE_INFO))
  {
    v5[0] = 67109120;
    v5[1] = v2 == 1;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_INFO, "SendLocalDeviceState with state %d", (uint8_t *)v5, 8u);
  }
  xpc_object_t v4 = xpc_dictionary_create(0, 0, 0);
  xpc_dictionary_set_uint64(v4, "kWCMBTLocalDeviceState", v2 == 1);
  sub_10073A58C(a1, 0x1FAuLL, v4);
  xpc_release(v4);
}

uint64_t sub_10073A198(uint32x2_t *a1)
{
  v15[0] = 0;
  v15[1] = 0;
  sub_10003AED0((uint64_t)v15, (uint64_t)&a1[10]);
  if (a1[35].i8[4]) {
    sub_100740358(a1);
  }
  unsigned int v2 = a1[36].u32[0];
  __int32 v3 = a1[37].i32[0];
  __int32 v4 = a1[39].i32[1];
  if (v2 >= 0xFF) {
    int v5 = 255;
  }
  else {
    int v5 = a1[36].i32[0];
  }
  int v6 = v4 | v3 | v5;
  if (a1[37].i32[1] != v6)
  {
    a1[37].i32[1] = v6;
    __int16 v7 = qword_100A19E58;
    if (os_log_type_enabled((os_log_t)qword_100A19E58, OS_LOG_TYPE_DEFAULT))
    {
      __int32 v8 = a1[38].i32[0];
      __int32 v9 = a1[38].i32[1];
      __int32 v10 = a1[39].i32[0];
      uint32x2_t v11 = a1[46];
      uint32x2_t v12 = a1[43];
      *(_DWORD *)long long buf = 67111424;
      int v17 = v4 | v3 | v5;
      __int16 v18 = 1024;
      __int32 v19 = v3;
      __int16 v20 = 1024;
      __int32 v21 = v4;
      __int16 v22 = 1024;
      int v23 = v5;
      __int16 v24 = 1024;
      unsigned int v25 = v2;
      __int16 v26 = 1024;
      __int32 v27 = v8;
      __int16 v28 = 1024;
      __int32 v29 = v9;
      __int16 v30 = 1024;
      __int32 v31 = v10;
      __int16 v32 = 1024;
      __int32 v33 = v11.i32[0];
      __int16 v34 = 1024;
      __int32 v35 = v12.i32[0];
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "Bandwidth: Sending 32bit hex value 0x%08X to UCM. ActiveNonAudioTasks 0x%08X, ActiveAudioTask is 0x%04X, BTLoadValue sent was 0x%02X actual decimal btload value %d, HighConnections bits 20-21 value %d, IrregularConnections bits 22-23 value %d, NormalConnection bits 24-25 %d, numLeConnections = %d, numClassicHids = %d", buf, 0x3Eu);
    }
    xpc_object_t v13 = xpc_dictionary_create(0, 0, 0);
    xpc_dictionary_set_uint64(v13, "kWCMBTWirelessLoadValue", v4 | v3 | v5);
    sub_10073A58C((uint64_t)a1, 0x57EuLL, v13);
    xpc_release(v13);
  }
  return sub_10003AFB4((uint64_t)v15);
}

void sub_10073A348(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_10073A368(uint64_t a1)
{
  sub_1000486F0(a1 + 424, *(void **)(a1 + 432));
  *(void *)(a1 + 432) = 0;
  *(void *)(a1 + 440) = 0;
  *(void *)(a1 + 424) = a1 + 432;
  if (&WCMEnabled)
  {
    uint64_t v2 = sub_10003FB34();
    sub_100354028(v2, a1 + 16);
    if (qword_1009F8090 != -1) {
      dispatch_once(&qword_1009F8090, &stru_1009C1108);
    }
    sub_1004D13BC((uint64_t)off_1009F8088, a1 + 8);
    if (qword_1009F8748 != -1) {
      dispatch_once(&qword_1009F8748, &stru_1009C1128);
    }
    sub_100052718((uint64_t)off_1009F8740 + 80, a1 + 24);
    if (qword_1009F7EC0 != -1) {
      dispatch_once(&qword_1009F7EC0, &stru_1009C1148);
    }
    sub_100680A44((uint64_t)off_1009F7EB8, a1 + 32);
    if (qword_1009F8158 != -1) {
      dispatch_once(&qword_1009F8158, &stru_1009C1168);
    }
    sub_1004F9F28((uint64_t)off_1009F8150, a1 + 40);
    if (qword_1009FB3D0 != -1) {
      dispatch_once(&qword_1009FB3D0, &stru_1009C1188);
    }
    sub_100544360(qword_1009FB3C8, a1 + 56);
    if (qword_1009F85C8 != -1) {
      dispatch_once(&qword_1009F85C8, &stru_1009C11A8);
    }
    sub_100052718((uint64_t)off_1009F85C0 + 1872, a1 + 64);
    if (qword_1009F7F00 != -1) {
      dispatch_once(&qword_1009F7F00, &stru_1009C11C8);
    }
    __int32 v3 = (char *)off_1009F7EF8 + 240;
    sub_100052718((uint64_t)v3, a1 + 72);
  }
  else if (os_log_type_enabled((os_log_t)qword_100A19E58, OS_LOG_TYPE_ERROR))
  {
    sub_10079A594();
  }
}

void sub_10073A58C(uint64_t a1, uint64_t value, void *a3)
{
  if (&WCMEnabled)
  {
    *(_OWORD *)keys = *(_OWORD *)&off_1009C10D8;
    object[0] = xpc_uint64_create(value);
    object[1] = a3;
    xpc_object_t v5 = xpc_dictionary_create((const char *const *)keys, object, 2uLL);
    xpc_connection_send_message(*(xpc_connection_t *)(a1 + 144), v5);
    xpc_release(object[0]);
    xpc_release(v5);
  }
  else
  {
    int v6 = qword_100A19E58;
    if (os_log_type_enabled((os_log_t)qword_100A19E58, OS_LOG_TYPE_INFO))
    {
      LOWORD(keys[0]) = 0;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_INFO, "WCM not enabled, discarding message", (uint8_t *)keys, 2u);
    }
  }
}

void sub_10073A730(uint64_t a1)
{
  sub_100739F04(a1);
  sub_10073A068(a1);
  sub_10073A780(a1);
  sub_10073A960(a1);

  sub_10073ABBC(a1);
}

void sub_10073A780(uint64_t a1)
{
  __int32 v8 = 0;
  __int32 v9 = 0;
  uint64_t v10 = 0;
  if (qword_1009F87A8 != -1) {
    dispatch_once(&qword_1009F87A8, &stru_1009C1268);
  }
  sub_10046E85C((uint64_t)off_1009F87A0, (void **)&v8);
  uint64_t v2 = v8;
  __int32 v3 = v9;
  if (v8 != v9)
  {
    do
    {
      int v4 = sub_1004809F4(*v2);
      unsigned int v5 = 1;
      do
      {
        if ((v5 & v4) != 0) {
          sub_10073E59C(a1, ((unint64_t)*(unsigned __int8 *)(*v2 + 128) << 40) | ((unint64_t)*(unsigned __int8 *)(*v2 + 129) << 32) | ((unint64_t)*(unsigned __int8 *)(*v2 + 130) << 24) | ((unint64_t)*(unsigned __int8 *)(*v2 + 131) << 16) | ((unint64_t)*(unsigned __int8 *)(*v2 + 132) << 8) | *(unsigned __int8 *)(*v2 + 133), v5, 0xBu, 0);
        }
        v5 *= 2;
      }
      while ((v5 & 0x80000000) == 0);
      int v7 = *(_DWORD *)(*v2 + 1320);
      if ((v7 & 0x10) != 0)
      {
        int v6 = (unsigned __int8 *)*v2;
        sub_10073E9A0(a1, ((unint64_t)v6[128] << 40) | ((unint64_t)v6[129] << 32) | ((unint64_t)v6[130] << 24) | ((unint64_t)v6[131] << 16) | ((unint64_t)v6[132] << 8) | v6[133], 2uLL, 16, 201, 0, 1u);
      }
      if (v7) {
        sub_10073E9A0(a1, ((unint64_t)*(unsigned __int8 *)(*v2 + 128) << 40) | ((unint64_t)*(unsigned __int8 *)(*v2 + 129) << 32) | ((unint64_t)*(unsigned __int8 *)(*v2 + 130) << 24) | ((unint64_t)*(unsigned __int8 *)(*v2 + 131) << 16) | ((unint64_t)*(unsigned __int8 *)(*v2 + 132) << 8) | *(unsigned __int8 *)(*v2 + 133), 1uLL, 1, 101, 0, 1u);
      }
      ++v2;
    }
    while (v2 != v3);
    uint64_t v2 = v8;
  }
  if (v2)
  {
    __int32 v9 = v2;
    operator delete(v2);
  }
}

void sub_10073A938(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_10073A960(uint64_t a1)
{
  if (qword_1009F7EC0 != -1) {
    dispatch_once(&qword_1009F7EC0, &stru_1009C1148);
  }
  sub_10004034C((uint64_t)off_1009F7EB8);
  long long v11 = 0u;
  long long v12 = 0u;
  long long v9 = 0u;
  long long v10 = 0u;
  id v2 = (id)objc_claimAutoreleasedReturnValue();
  id v3 = [v2 countByEnumeratingWithState:&v9 objects:v14 count:16];
  if (v3)
  {
    uint64_t v4 = *(void *)v10;
    do
    {
      unsigned int v5 = 0;
      do
      {
        if (*(void *)v10 != v4) {
          objc_enumerationMutation(v2);
        }
        int v6 = *(void **)(*((void *)&v9 + 1) + 8 * (void)v5);
        if (qword_1009F7EC0 != -1) {
          dispatch_once(&qword_1009F7EC0, &stru_1009C1148);
        }
        int v7 = off_1009F7EB8;
        sub_1000305AC(v13, v6);
        if (sub_1006854C8((uint64_t)v7, v13))
        {
          if (qword_1009F7EE0 != -1) {
            dispatch_once(&qword_1009F7EE0, &stru_1009C1248);
          }
          unint64_t v8 = sub_100030DCC((uint64_t)off_1009F7ED8, v6, 0);
          sub_10073E59C(a1, v8, 0x8000u, 0xBu, 0);
        }
        unsigned int v5 = (char *)v5 + 1;
      }
      while (v3 != v5);
      id v3 = [v2 countByEnumeratingWithState:&v9 objects:v14 count:16];
    }
    while (v3);
  }

  if (qword_1009F8158 != -1) {
    dispatch_once(&qword_1009F8158, &stru_1009C1168);
  }
  if (*((unsigned char *)off_1009F8150 + 199)) {
    sub_10073E9A0(a1, 1uLL, 3uLL, 0x10000, 801, 0, 1u);
  }
}

void sub_10073AB88(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_10073ABBC(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 400);
  id v2 = (void *)(a1 + 408);
  if (v1 != (void *)(a1 + 408))
  {
    do
    {
      xpc_object_t v4 = xpc_dictionary_create(0, 0, 0);
      xpc_dictionary_set_int64(v4, "kWCMBTLeDiscoveryScan_State", 1);
      xpc_dictionary_set_int64(v4, "kWCMBTLeDiscoveryScan_UseCase", 1);
      unsigned int v5 = qword_100A19E58;
      if (os_log_type_enabled((os_log_t)qword_100A19E58, OS_LOG_TYPE_DEFAULT))
      {
        int v6 = sub_10003F3D0(*((_DWORD *)v1 + 7));
        *(_DWORD *)long long buf = 136315138;
        long long v11 = v6;
        _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "sendLEScanningUseCaseInfo: Sending Notification to WiFi for CBUseCase %s", buf, 0xCu);
      }
      sub_10073A58C(a1, 0x206uLL, v4);
      int v7 = (void *)v1[1];
      if (v7)
      {
        do
        {
          unint64_t v8 = v7;
          int v7 = (void *)*v7;
        }
        while (v7);
      }
      else
      {
        do
        {
          unint64_t v8 = (void *)v1[2];
          BOOL v9 = *v8 == (void)v1;
          uint64_t v1 = v8;
        }
        while (!v9);
      }
      uint64_t v1 = v8;
    }
    while (v8 != v2);
  }
}

uint64_t sub_10073AD44(int a1, xpc_object_t xdict)
{
  if (xpc_dictionary_get_uint64(xdict, "kMessageArgs"))
  {
    if (qword_1009F8748 != -1) {
      dispatch_once(&qword_1009F8748, &stru_1009C1128);
    }
    sub_1004B94DC((uint64_t)off_1009F8740);
  }
  else
  {
    if (qword_1009F8748 != -1) {
      dispatch_once(&qword_1009F8748, &stru_1009C1128);
    }
    sub_1004B98D4((uint64_t)off_1009F8740);
  }
  return 1;
}

uint64_t sub_10073ADD0(int a1, xpc_object_t xdict)
{
  uunsigned __int16 int64 = xpc_dictionary_get_uint64(xdict, "kWCMBTPreferredRole");
  id v3 = qword_100A19E58;
  if (os_log_type_enabled((os_log_t)qword_100A19E58, OS_LOG_TYPE_INFO))
  {
    v5[0] = 67109120;
    v5[1] = uint64 == 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_INFO, "Setting preferred role to : %d", (uint8_t *)v5, 8u);
  }
  LOBYTE(v5[0]) = 0;
  sub_10001B8E0(v5);
  sub_100188C08(uint64 == 0);
  sub_10001B910(v5);
  sub_10001B8AC(v5);
  return 1;
}

void sub_10073AEBC(_Unwind_Exception *exception_object)
{
}

uint64_t sub_10073AED8(int a1, xpc_object_t xdict)
{
  __int16 v16 = 0;
  size_t length = 0;
  uint64_t v15 = 0;
  data = xpc_dictionary_get_data(xdict, "kMessageArgs", &length);
  if (data) {
    BOOL v3 = length >= 0xA;
  }
  else {
    BOOL v3 = 0;
  }
  if (!v3) {
    return 1;
  }
  for (uint64_t i = 0; i != 10; ++i)
    *((unsigned char *)&v15 + i) = data[i];
  if (qword_1009F8748 != -1) {
    dispatch_once(&qword_1009F8748, &stru_1009C1128);
  }
  if (sub_100028CB4((uint64_t)off_1009F8740) == 1)
  {
    char v13 = 0;
    sub_10001B8E0(&v13);
    int v11 = sub_10018F088((uint64_t)sub_10073E250, (uint64_t)&v15, v5, v6, v7, v8, v9, v10);
    sub_10001B910(&v13);
    if (v11)
    {
      if (os_log_type_enabled((os_log_t)qword_100A19E58, OS_LOG_TYPE_ERROR)) {
        sub_10076F170();
      }
    }
    sub_10001B8AC(&v13);
    return 1;
  }
  return 202;
}

void sub_10073B018(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, int a10, __int16 a11, char a12, char a13)
{
}

uint64_t sub_10073B034(int a1, xpc_object_t xdict)
{
  char v21 = 0;
  int v20 = 0;
  size_t length = 0;
  data = xpc_dictionary_get_data(xdict, "kMessageArgs", &length);
  if (!data)
  {
    uint64_t v12 = qword_100A19E58;
    if (os_log_type_enabled((os_log_t)qword_100A19E58, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      char v13 = "WCMBLESetChannelMap message is not in expected format";
      __int16 v14 = v12;
      uint32_t v15 = 2;
LABEL_17:
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, v13, buf, v15);
    }
    return 1;
  }
  size_t v3 = length;
  if (length != 5)
  {
    uint64_t v16 = qword_100A19E58;
    if (os_log_type_enabled((os_log_t)qword_100A19E58, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 134217984;
      size_t v23 = v3;
      char v13 = "WCMBLESetChannelMap message has unexpected AFH map with length %zu";
      __int16 v14 = v16;
      uint32_t v15 = 12;
      goto LABEL_17;
    }
    return 1;
  }
  if (qword_1009F8748 != -1) {
    dispatch_once(&qword_1009F8748, &stru_1009C1128);
  }
  if (sub_100028CB4((uint64_t)off_1009F8740) == 1)
  {
    for (uint64_t i = 0; i != 5; ++i)
      *((unsigned char *)&v20 + i) = data[i];
    buf[0] = 0;
    sub_10001B8E0(buf);
    uint64_t v11 = sub_10001BDE0(180, (uint64_t)sub_10073E404, v5, v6, v7, v8, v9, v10, (uint64_t)&v20);
    sub_10001B910(buf);
    if (v11)
    {
      if (os_log_type_enabled((os_log_t)qword_100A19E58, OS_LOG_TYPE_ERROR)) {
        sub_10079A734();
      }
      uint64_t v11 = 1;
    }
    sub_10001B8AC(buf);
  }
  else
  {
    __int16 v18 = qword_100A19E58;
    if (os_log_type_enabled((os_log_t)qword_100A19E58, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "WCMBLESetChannelMap message cannot be handled as the power state is OFF", buf, 2u);
    }
    return 202;
  }
  return v11;
}

void sub_10073B268(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  sub_10001B8AC(va);
  _Unwind_Resume(a1);
}

uint64_t sub_10073B284(uint64_t a1, void *a2)
{
  uint64_t v3 = sub_100035F54();
  if ((*(uint64_t (**)(uint64_t))(*(void *)v3 + 136))(v3))
  {
    uint64_t v4 = sub_100017768();
    if ((*(unsigned int (**)(uint64_t))(*(void *)v4 + 360))(v4))
    {
      uint64_t v5 = qword_100A19E58;
      if (os_log_type_enabled((os_log_t)qword_100A19E58, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        uint64_t v6 = "Diversity host assisted AFH maps overridden: maps from coex manager ignored";
LABEL_7:
        _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, v6, buf, 2u);
      }
    }
    else
    {
      xpc_object_t value = xpc_dictionary_get_value(a2, "kMessageArgs");
      if (value)
      {
        uint64_t v9 = value;
        size_t v23 = 0;
        size_t length = 0;
        size_t v21 = 0;
        size_t v22 = 0;
        data = xpc_dictionary_get_data(value, "kWCMBTDiversityChannelMap_C0B0", &length);
        uint64_t v11 = xpc_dictionary_get_data(v9, "kWCMBTDiversityChannelMap_C0B1", &v23);
        uint64_t v12 = xpc_dictionary_get_data(v9, "kWCMBTDiversityChannelMap_C1B0", &v22);
        char v13 = xpc_dictionary_get_data(v9, "kWCMBTDiversityChannelMap_C1B1", &v21);
        __int16 v14 = qword_100A19E58;
        if (data && length >= 0xA && v11 && v23 >= 0xA && v12 && v22 >= 0xA && (uint32_t v15 = v13) != 0 && v21 > 9)
        {
          if (os_log_type_enabled((os_log_t)qword_100A19E58, OS_LOG_TYPE_INFO))
          {
            *(_WORD *)long long buf = 0;
            _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_INFO, "Sending diversity host assisted AFH maps", buf, 2u);
          }
          *(_WORD *)long long buf = 0;
          uint64_t v16 = *(void *)data;
          __int16 v27 = data[4];
          uint64_t v26 = v16;
          __int16 v28 = 256;
          uint64_t v17 = *(void *)v11;
          __int16 v30 = v11[4];
          uint64_t v29 = v17;
          __int16 v31 = 512;
          uint64_t v18 = *(void *)v12;
          __int16 v33 = v12[4];
          uint64_t v32 = v18;
          __int16 v34 = 768;
          uint64_t v19 = *(void *)v15;
          __int16 v36 = v15[4];
          uint64_t v35 = v19;
          uint64_t v20 = *(void *)sub_10003FB34();
          (*(void (**)(void))(v20 + 920))();
        }
        else if (os_log_type_enabled((os_log_t)qword_100A19E58, OS_LOG_TYPE_ERROR))
        {
          sub_10079A79C();
        }
      }
      else if (os_log_type_enabled((os_log_t)qword_100A19E58, OS_LOG_TYPE_ERROR))
      {
        sub_10079A768();
      }
    }
  }
  else
  {
    uint64_t v5 = qword_100A19E58;
    if (os_log_type_enabled((os_log_t)qword_100A19E58, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      uint64_t v6 = "Diversity not supported on this platform: host assisted AFH maps from coex manager ignored";
      goto LABEL_7;
    }
  }
  return 1;
}

uint64_t sub_10073B5AC(int a1, xpc_object_t xdict)
{
  memset(&v20[3], 0, 98);
  xpc_object_t value = xpc_dictionary_get_value(xdict, "kMessageArgs");
  uint64_t v3 = qword_100A19E58;
  if (os_log_type_enabled((os_log_t)qword_100A19E58, OS_LOG_TYPE_INFO))
  {
    *(_WORD *)uint64_t v19 = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_INFO, "Received MWS External Frame Config", v19, 2u);
  }
  if (!value) {
    return 1;
  }
  v20[0] = xpc_dictionary_get_uint64(value, "kWCMBTSetMWSExternalConfig_ExtFrameDuration");
  v20[1] = xpc_dictionary_get_int64(value, "kWCMBTSetMWSExternalConfig_ExtFrameSyncAssertOffset");
  void v20[2] = xpc_dictionary_get_uint64(value, "kWCMBTSetMWSExternalConfig_ExtFrameSyncAssertJitter");
  uunsigned __int16 int64 = xpc_dictionary_get_uint64(value, "kWCMBTSetMWSExternalConfig_ExtNumPeriods");
  LOBYTE(v20[3]) = uint64;
  xpc_object_t v5 = xpc_dictionary_get_value(value, "kWCMBTSetMWSExternalConfig_ExtPeriodDuration");
  xpc_object_t v6 = xpc_dictionary_get_value(value, "kWCMBTSetMWSExternalConfig_ExtPeriodType");
  if (uint64 - 1 >= 0x20)
  {
    uint64_t v11 = qword_100A19E58;
    if (os_log_type_enabled((os_log_t)qword_100A19E58, OS_LOG_TYPE_ERROR)) {
      sub_10079A8D8(uint64, v11, v12, v13, v14, v15, v16, v17);
    }
    return 1;
  }
  if (!v5 || (uint64_t v7 = v6) == 0)
  {
    if (os_log_type_enabled((os_log_t)qword_100A19E58, OS_LOG_TYPE_ERROR)) {
      sub_10079A8A4();
    }
    return 1;
  }
  size_t count = xpc_array_get_count(v5);
  if (count != uint64)
  {
    uint64_t v18 = qword_100A19E58;
    if (os_log_type_enabled((os_log_t)qword_100A19E58, OS_LOG_TYPE_ERROR)) {
      sub_10079A804(uint64, v5, v18);
    }
    return 1;
  }
  if (xpc_array_get_count(v7) != count)
  {
    if (os_log_type_enabled((os_log_t)qword_100A19E58, OS_LOG_TYPE_ERROR)) {
      sub_10079A7D0();
    }
    return 1;
  }
  size_t v9 = 0;
  do
  {
    v20[v9 + 4] = xpc_array_get_uint64(v5, v9);
    *((unsigned char *)&v20[36] + v9) = xpc_array_get_uint64(v7, v9);
    ++v9;
  }
  while (v9 < uint64);
  if (qword_1009F8070 != -1) {
    dispatch_once(&qword_1009F8070, &stru_1009C11E8);
  }
  sub_1004E86B8((uint64_t)off_1009F8068, 104, v20);
  return 0;
}

uint64_t sub_10073B854(uint64_t a1, void *a2)
{
  uint64_t v3 = qword_100A19E58;
  if (os_log_type_enabled((os_log_t)qword_100A19E58, OS_LOG_TYPE_INFO))
  {
    v7[0] = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_INFO, "Received MWS Signaling Command", (uint8_t *)v7, 2u);
  }
  xpc_object_t value = xpc_dictionary_get_value(a2, "kMessageArgs");
  if (value)
  {
    xpc_object_t v5 = value;
    v7[0] = xpc_dictionary_get_int64(value, "kWCMBTSetMWSSignaling_MWSRxAssertOffset");
    v7[1] = xpc_dictionary_get_uint64(v5, "kWCMBTSetMWSSignaling_MWSRxAssertJitter");
    void v7[2] = xpc_dictionary_get_int64(v5, "kWCMBTSetMWSSignaling_MWSRxDeAssertOffset");
    void v7[3] = xpc_dictionary_get_uint64(v5, "kWCMBTSetMWSSignaling_MWSRxDeAssertJitter");
    void v7[4] = xpc_dictionary_get_int64(v5, "kWCMBTSetMWSSignaling_MWSTxAssertOffset");
    void v7[5] = xpc_dictionary_get_uint64(v5, "kWCMBTSetMWSSignaling_MWSTxAssertJitter");
    v7[6] = xpc_dictionary_get_int64(v5, "kWCMBTSetMWSSignaling_MWSTxDeAssertOffset");
    v7[7] = xpc_dictionary_get_uint64(v5, "kWCMBTSetMWSSignaling_MWSTxDeAssertJitter");
    v7[8] = xpc_dictionary_get_int64(v5, "kWCMBTSetMWSSignaling_MWSPatternAssertOffset");
    v7[9] = xpc_dictionary_get_uint64(v5, "kWCMBTSetMWSSignaling_MWSPatternAssertJitter");
    v7[10] = xpc_dictionary_get_int64(v5, "kWCMBTSetMWSSignaling_MWSInactivityAssertOffset");
    v7[11] = xpc_dictionary_get_uint64(v5, "kWCMBTSetMWSSignaling_MWSInactivityAssertJitter");
    v7[12] = xpc_dictionary_get_int64(v5, "kWCMBTSetMWSSignaling_MWSScanFrequencyAssertOffset");
    v7[13] = xpc_dictionary_get_uint64(v5, "kWCMBTSetMWSSignaling_MWSScanFrequencyAssertJitter");
    v7[14] = xpc_dictionary_get_uint64(v5, "kWCMBTSetMWSSignaling_MWSPriorityAssertOffsetRequest");
    if (qword_1009F8070 != -1) {
      dispatch_once(&qword_1009F8070, &stru_1009C11E8);
    }
    sub_1004E88A0((uint64_t)off_1009F8068, 30, v7);
  }
  return 1;
}

uint64_t sub_10073BA40(int a1, xpc_object_t xdict)
{
  xpc_object_t value = xpc_dictionary_get_value(xdict, "kMessageArgs");
  if (value)
  {
    uint64_t v3 = value;
    xpc_dictionary_get_uint64(value, "kWCMBTSetWCI2Mode_ReceiveMessage");
    xpc_dictionary_get_uint64(v3, "kWCMBTSetWCI2Mode_SendMessage");
    uint64_t v4 = *(void *)sub_10003FB34();
    (*(void (**)(void))(v4 + 496))();
  }
  return 1;
}

uint64_t sub_10073BAE8(int a1, xpc_object_t xdict)
{
  __int16 v5 = 0;
  xpc_object_t value = xpc_dictionary_get_value(xdict, "kMessageArgs");
  xpc_retain(value);
  if (value)
  {
    LOBYTE(v5) = xpc_dictionary_get_uint64(value, "kWCMBTTriggerWCI2Message_MessageId");
    HIBYTE(v5) = xpc_dictionary_get_uint64(value, "kWCMBTTriggerWCI2Message_Value1");
  }
  xpc_release(value);
  uint64_t v3 = sub_10003FB34();
  (*(void (**)(uint64_t, uint64_t, __int16 *))(*(void *)v3 + 520))(v3, 2, &v5);
  return 1;
}

uint64_t sub_10073BB98(uint64_t a1, xpc_object_t xdict)
{
  xpc_object_t value = xpc_dictionary_get_value(xdict, "kMessageArgs");
  uint64_t v4 = qword_100A19E58;
  if (os_log_type_enabled((os_log_t)qword_100A19E58, OS_LOG_TYPE_INFO))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_INFO, "Setting LTE Link Quality Mode", buf, 2u);
  }
  if (value)
  {
    uunsigned __int16 int64 = xpc_dictionary_get_uint64(value, "kWCMBTSetLinkQuality_Duration");
    char v19 = xpc_dictionary_get_uint64(value, "kWCMBTSetLinkQuality_EventType");
    unsigned __int8 v5 = xpc_dictionary_get_uint64(value, "kWCMBTSetLinkQuality_Mode");
    int v6 = v5;
    unsigned __int8 v20 = v5;
    __int16 v21 = xpc_dictionary_get_uint64(value, "kWCMBTSetLinkQuality_RxThreshold");
    __int16 v22 = xpc_dictionary_get_uint64(value, "kWCMBTSetLinkQuality_TxThreshold");
    uint64_t v7 = +[NSString stringWithUTF8String:xpc_dictionary_get_string(value, "kWCMBTSetLinkQuality_DeviceAddress")];
    uint64_t v8 = v7;
    if (v6)
    {
      unint64_t v9 = sub_1006ADA24(v7);
      if (!v9 && os_log_type_enabled((os_log_t)qword_100A19E58, OS_LOG_TYPE_ERROR)) {
        sub_10079A9B4();
      }
      if (qword_1009F7F00 != -1) {
        dispatch_once(&qword_1009F7F00, &stru_1009C11C8);
      }
      uint64_t v10 = sub_100030F10((uint64_t)off_1009F7EF8, v9, 0);
      if (v10)
      {
        uint64_t v11 = sub_10003FB34();
        sub_100353FC0(v11, a1 + 16);
        uint64_t v12 = sub_10003FB34();
        (*(void (**)(uint64_t, uint64_t, __int16 *, uint64_t))(*(void *)v12 + 528))(v12, 8, &uint64, v10);
      }
      else if (os_log_type_enabled((os_log_t)qword_100A19E58, OS_LOG_TYPE_ERROR))
      {
        sub_10079A948();
      }
    }
    else
    {
      uint64_t v14 = sub_10003FB34();
      sub_100354028(v14, a1 + 16);
    }
  }
  else
  {
    uint64_t v13 = qword_100A19E58;
    if (os_log_type_enabled((os_log_t)qword_100A19E58, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)uint64_t v16 = 0;
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_INFO, "Invalid argument for LTE Link Quality Mode", v16, 2u);
    }
  }
  return 1;
}

void sub_10073BE08(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t sub_10073BE20(int a1, xpc_object_t xdict)
{
  uunsigned __int16 int64 = xpc_dictionary_get_uint64(xdict, "kMessageArgs");
  uint64_t v3 = qword_100A19E58;
  if (os_log_type_enabled((os_log_t)qword_100A19E58, OS_LOG_TYPE_INFO))
  {
    uint64_t v4 = "Enabled";
    if (!uint64) {
      uint64_t v4 = "Disabled";
    }
    int v7 = 136446210;
    uint64_t v8 = v4;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_INFO, "Setting sleep mode to %{public}s", (uint8_t *)&v7, 0xCu);
  }
  uint64_t v5 = sub_10003FB34();
  (*(void (**)(uint64_t, void))(*(void *)v5 + 536))(v5, (unsigned __int16)uint64);
  return 1;
}

void sub_10073BF24(uint64_t a1, xpc_object_t xdict)
{
  xpc_object_t v3 = xpc_dictionary_get_value(xdict, "kMessageArgs");
  if (v3)
  {
    uint64_t v4 = v3;
    uunsigned __int16 int64 = xpc_dictionary_get_uint64(v3, "kWCMBTAntennaAction");
    uint64_t v6 = xpc_dictionary_get_uint64(v4, "kWCMBTAntennaConfiguration");
    unsigned __int8 v7 = xpc_dictionary_get_uint64(v4, "kWCMBTAntennaParam1");
    unsigned __int8 v8 = xpc_dictionary_get_uint64(v4, "kWCMBTAntennaParam2");
    value[0] = 0;
    value[1] = 0;
    __int16 v22 = 16;
    uint64_t v9 = sub_10003FB34();
    if (uint64 >= 6)
    {
      unsigned int v10 = *(_DWORD *)(v9 + 712);
      if (v10)
      {
        if (v10 <= 0x16)
        {
          if (os_log_type_enabled((os_log_t)qword_100A19E58, OS_LOG_TYPE_ERROR)) {
            sub_10079AA54();
          }
          return;
        }
      }
    }
    if (uint64) {
      BOOL v11 = uint64 == 10;
    }
    else {
      BOOL v11 = 1;
    }
    if (v11) {
      uint64_t v12 = 4095;
    }
    else {
      uint64_t v12 = 0;
    }
    uint64_t v13 = qword_100A19E58;
    if (os_log_type_enabled((os_log_t)qword_100A19E58, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 134217984;
      uint64_t v24 = uint64;
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "Sending antenna preference action %llu", buf, 0xCu);
    }
    uint64_t v14 = sub_10003FB34();
    (*(void (**)(uint64_t, uint64_t, void, void, void, void, __int16 *, uint64_t *))(*(void *)v14 + 904))(v14, v12, uint64, v6, v7, v8, &v22, value);
    xpc_object_t v15 = xpc_dictionary_create(0, 0, 0);
    uint64_t v16 = v15;
    if (v22)
    {
      unsigned int v17 = LOBYTE(value[0]);
      if (uint64 == 2 || uint64 == 1)
      {
        xpc_dictionary_set_uint64(v15, "kWCMBTCurrentAntenna", BYTE1(value[0]));
        uint64_t v18 = BYTE2(value[0]);
        char v19 = "kWCMBTPreviousAntenna";
        goto LABEL_28;
      }
      if (!uint64)
      {
        uint64_t v18 = BYTE1(value[0]);
        char v19 = "kWCMBTCurrentAntenna";
LABEL_28:
        xpc_dictionary_set_uint64(v16, v19, v18);
LABEL_30:
        xpc_dictionary_set_uint64(v16, "kWCMBTStatus", v17);
        xpc_dictionary_set_uint64(v16, "kWCMBTAntennaAction", uint64);
        sub_10073A58C(a1, 0x1FEuLL, v16);
        xpc_release(v16);
        return;
      }
    }
    else
    {
      unsigned int v17 = 255;
    }
    if (uint64 == 3)
    {
      uint64_t v20 = sub_10003FB34();
      unint64_t v21 = a1 + 16;
      if (v6 != 1 || v17) {
        sub_100354028(v20, v21);
      }
      else {
        sub_100353FC0(v20, v21);
      }
    }
    goto LABEL_30;
  }
  if (os_log_type_enabled((os_log_t)qword_100A19E58, OS_LOG_TYPE_ERROR)) {
    sub_10079AA20();
  }
}

uint64_t sub_10073C204(uint64_t a1, void *a2)
{
  xpc_object_t v3 = qword_100A19E58;
  if (os_log_type_enabled((os_log_t)qword_100A19E58, OS_LOG_TYPE_INFO))
  {
    LOWORD(v21[0]) = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_INFO, "Received MWS Set Scan Freq Table", (uint8_t *)v21, 2u);
  }
  __int16 v22 = 0;
  memset(v21, 0, sizeof(v21));
  xpc_object_t value = xpc_dictionary_get_value(a2, "kMessageArgs");
  if (value)
  {
    uint64_t v5 = value;
    uunsigned __int16 int64 = xpc_dictionary_get_uint64(value, "kWCMBTNumScanFrequencies");
    LOBYTE(v21[0]) = uint64;
    xpc_object_t v7 = xpc_dictionary_get_value(v5, "kWCMBTScanFrequencies");
    if (uint64 >= 0x20u)
    {
      unsigned __int8 v8 = qword_100A19E58;
      if (os_log_type_enabled((os_log_t)qword_100A19E58, OS_LOG_TYPE_ERROR)) {
        sub_10079AAC0(uint64, v8, v9, v10, v11, v12, v13, v14);
      }
      return 1;
    }
    xpc_object_t v15 = v7;
    if (xpc_array_get_count(v7) != uint64
      && os_log_type_enabled((os_log_t)qword_100A19E58, OS_LOG_TYPE_ERROR))
    {
      sub_10079AB30();
      if ((_BYTE)uint64)
      {
LABEL_10:
        size_t v16 = 0;
        do
        {
          xpc_object_t v17 = xpc_array_get_value(v15, v16);
          uint64_t v18 = (char *)v21 + 2 * v16;
          *((_WORD *)v18 + 1) = xpc_array_get_uint64(v17, 0);
          xpc_object_t v19 = xpc_array_get_value(v15, v16);
          *((_WORD *)v18 + 17) = xpc_array_get_uint64(v19, 1uLL);
          ++v16;
        }
        while (v16 < uint64);
      }
    }
    else if ((_BYTE)uint64)
    {
      goto LABEL_10;
    }
    if (qword_1009F8070 != -1) {
      dispatch_once(&qword_1009F8070, &stru_1009C11E8);
    }
    sub_1004E8B9C((uint64_t)off_1009F8068, 66, (char *)v21);
  }
  return 1;
}

void sub_10073C3C0(int a1, xpc_object_t xdict)
{
  xpc_object_t value = xpc_dictionary_get_value(xdict, "kMessageArgs");
  if (value)
  {
    uunsigned __int16 int64 = xpc_dictionary_get_uint64(value, "kWCMBTCoexRxGainModeEnable");
    uint64_t v4 = qword_100A19E58;
    if (os_log_type_enabled((os_log_t)qword_100A19E58, OS_LOG_TYPE_INFO))
    {
      v6[0] = 67109120;
      v6[1] = uint64;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_INFO, "BT coex rx mode value: %d", (uint8_t *)v6, 8u);
    }
    uint64_t v5 = sub_10003FB34();
    (*(void (**)(uint64_t, void))(*(void *)v5 + 1616))(v5, uint64);
  }
  else if (os_log_type_enabled((os_log_t)qword_100A19E58, OS_LOG_TYPE_ERROR))
  {
    sub_10079AB64();
  }
}

void sub_10073C4E8(os_unfair_lock_s *a1, xpc_object_t xdict)
{
  xpc_object_t value = xpc_dictionary_get_value(xdict, "kMessageArgs");
  if (value)
  {
    uunsigned __int16 int64 = xpc_dictionary_get_uint64(value, "kWCMBTAWDLActive");
    uint64_t v5 = qword_100A19E58;
    if (os_log_type_enabled((os_log_t)qword_100A19E58, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)long long buf = 67109120;
      int v9 = uint64;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_INFO, "BT coex AWDL active state is: %d", buf, 8u);
    }
    v6[0] = _NSConcreteStackBlock;
    v6[1] = 3221225472;
    _DWORD v6[2] = sub_10073D950;
    v6[3] = &unk_1009C1078;
    unsigned __int8 v7 = uint64;
    sub_1000145A8(a1 + 120, v6);
  }
  else if (os_log_type_enabled((os_log_t)qword_100A19E58, OS_LOG_TYPE_ERROR))
  {
    sub_10079AB98();
  }
}

void sub_10073C640(os_unfair_lock_s *a1, xpc_object_t xdict)
{
  xpc_object_t value = xpc_dictionary_get_value(xdict, "kMessageArgs");
  if (value)
  {
    uunsigned __int16 int64 = xpc_dictionary_get_uint64(value, "kWCMBT5GHzWiFiRatesLow");
    uint64_t v5 = qword_100A19E58;
    if (os_log_type_enabled((os_log_t)qword_100A19E58, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)long long buf = 67109120;
      int v9 = uint64;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_INFO, "BT coex LowWifiRat state is: %d", buf, 8u);
    }
    v6[0] = _NSConcreteStackBlock;
    v6[1] = 3221225472;
    _DWORD v6[2] = sub_10073D988;
    v6[3] = &unk_1009C1078;
    unsigned __int8 v7 = uint64;
    sub_1000145A8(a1 + 120, v6);
  }
  else if (os_log_type_enabled((os_log_t)qword_100A19E58, OS_LOG_TYPE_ERROR))
  {
    sub_10079ABCC();
  }
}

void sub_10073C798(os_unfair_lock_s *a1, xpc_object_t xdict)
{
  xpc_object_t value = xpc_dictionary_get_value(xdict, "kMessageArgs");
  if (value)
  {
    uunsigned __int16 int64 = xpc_dictionary_get_uint64(value, "kWCMBTAWDLRTGActive");
    uint64_t v5 = qword_100A19E58;
    if (os_log_type_enabled((os_log_t)qword_100A19E58, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)long long buf = 67109120;
      int v9 = uint64;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_INFO, "BT coex AWDLRTG active state is: %d", buf, 8u);
    }
    v6[0] = _NSConcreteStackBlock;
    v6[1] = 3221225472;
    _DWORD v6[2] = sub_10073D9C0;
    v6[3] = &unk_1009C1078;
    unsigned __int8 v7 = uint64;
    sub_1000145A8(a1 + 120, v6);
  }
  else if (os_log_type_enabled((os_log_t)qword_100A19E58, OS_LOG_TYPE_ERROR))
  {
    sub_10079AC00();
  }
}

void sub_10073C8F0(os_unfair_lock_s *a1, xpc_object_t xdict)
{
  xpc_object_t value = xpc_dictionary_get_value(xdict, "kMessageArgs");
  if (value)
  {
    uunsigned __int16 int64 = xpc_dictionary_get_uint64(value, "kWCMBTUWB5GHzActive");
    uint64_t v5 = qword_100A19E58;
    if (os_log_type_enabled((os_log_t)qword_100A19E58, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)long long buf = 67109120;
      int v9 = uint64;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_INFO, "BT coex UWB 5g active state is: %d", buf, 8u);
    }
    v6[0] = _NSConcreteStackBlock;
    v6[1] = 3221225472;
    _DWORD v6[2] = sub_10073D9F8;
    v6[3] = &unk_1009C1078;
    unsigned __int8 v7 = uint64;
    sub_1000145A8(a1 + 120, v6);
  }
  else if (os_log_type_enabled((os_log_t)qword_100A19E58, OS_LOG_TYPE_ERROR))
  {
    sub_10079AC34();
  }
}

void sub_10073CA48(os_unfair_lock_s *a1, xpc_object_t xdict)
{
  xpc_object_t value = xpc_dictionary_get_value(xdict, "kMessageArgs");
  if (value)
  {
    uunsigned __int16 int64 = xpc_dictionary_get_uint64(value, "kWCMBTNANActive");
    uint64_t v5 = qword_100A19E58;
    if (os_log_type_enabled((os_log_t)qword_100A19E58, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)long long buf = 67109120;
      int v9 = uint64;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_INFO, "BT coex Nan active state is: %d", buf, 8u);
    }
    v6[0] = _NSConcreteStackBlock;
    v6[1] = 3221225472;
    _DWORD v6[2] = sub_10073DA30;
    v6[3] = &unk_1009C1078;
    unsigned __int8 v7 = uint64;
    sub_1000145A8(a1 + 120, v6);
  }
  else if (os_log_type_enabled((os_log_t)qword_100A19E58, OS_LOG_TYPE_ERROR))
  {
    sub_10079AC68();
  }
}

void sub_10073CBA0(os_unfair_lock_s *a1, xpc_object_t xdict)
{
  xpc_object_t value = xpc_dictionary_get_value(xdict, "kMessageArgs");
  if (value)
  {
    uunsigned __int16 int64 = xpc_dictionary_get_uint64(value, "kWCMBT5GHzHostAPActive");
    uint64_t v5 = qword_100A19E58;
    if (os_log_type_enabled((os_log_t)qword_100A19E58, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)long long buf = 67109120;
      int v9 = uint64;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_INFO, "BT coex 5Ghz Host AP active state is: %d", buf, 8u);
    }
    v6[0] = _NSConcreteStackBlock;
    v6[1] = 3221225472;
    _DWORD v6[2] = sub_10073DA68;
    v6[3] = &unk_1009C1078;
    unsigned __int8 v7 = uint64;
    sub_1000145A8(a1 + 120, v6);
  }
  else if (os_log_type_enabled((os_log_t)qword_100A19E58, OS_LOG_TYPE_ERROR))
  {
    sub_10079AC9C();
  }
}

void sub_10073CCF8(uint64_t a1, xpc_object_t xdict)
{
  xpc_object_t value = xpc_dictionary_get_value(xdict, "kMessageArgs");
  if (value)
  {
    uint64_t v4 = value;
    uunsigned __int16 int64 = xpc_dictionary_get_uint64(value, "kWCMBTCoexScanIntervalReason");
    uint64_t v6 = xpc_dictionary_get_uint64(v4, "kWCMBTCoexScanIntervalState");
    unsigned __int8 v7 = qword_100A19E58;
    if (os_log_type_enabled((os_log_t)qword_100A19E58, OS_LOG_TYPE_DEFAULT))
    {
      int v8 = 134218240;
      uint64_t v9 = uint64;
      __int16 v10 = 2048;
      uint64_t v11 = v6;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "SetBTCoexParameters reason:%llu state:%llu", (uint8_t *)&v8, 0x16u);
    }
    if (!uint64)
    {
      *(unsigned char *)(a1 + 152) = 1;
      *(unsigned char *)(a1 + 153) = v6 != 0;
    }
  }
  else if (os_log_type_enabled((os_log_t)qword_100A19E58, OS_LOG_TYPE_ERROR))
  {
    sub_10079ACD0();
  }
}

void sub_10073CE34(uint64_t a1, void *a2)
{
  if (MGGetBoolAnswer())
  {
    xpc_object_t value = xpc_dictionary_get_value(a2, "kMessageArgs");
    if (value)
    {
      uint64_t v5 = value;
      BOOL v6 = xpc_dictionary_get_BOOL(value, "kWCMBTRC2GrantEnable");
      uunsigned __int16 int64 = xpc_dictionary_get_uint64(v5, "kWCMBTRC2TimingT3");
      int v8 = xpc_dictionary_get_uint64(v5, "kWCMBTRC2TimingT4");
      uint64_t v9 = qword_100A19E58;
      if (os_log_type_enabled((os_log_t)qword_100A19E58, OS_LOG_TYPE_DEFAULT))
      {
        v12[0] = 67109632;
        v12[1] = v6;
        __int16 v13 = 1024;
        int v14 = uint64;
        __int16 v15 = 1024;
        int v16 = v8;
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "Received UCM GrantRC2MEdium and BT Suppression msg: enable: %d, t3Interval: %u, t4Interval: %u", (uint8_t *)v12, 0x14u);
      }
      if (*(unsigned char *)(a1 + 448) != v6)
      {
        *(unsigned char *)(a1 + 448) = v6;
        uint64_t v10 = sub_10003FB34();
        (*(void (**)(uint64_t, BOOL))(*(void *)v10 + 3384))(v10, v6);
        uint64_t v11 = *(void *)sub_10003FB34();
        (*(void (**)(void))(v11 + 3376))();
      }
    }
    else if (os_log_type_enabled((os_log_t)qword_100A19E58, OS_LOG_TYPE_ERROR))
    {
      sub_10079AD04();
    }
  }
  else if (os_log_type_enabled((os_log_t)qword_100A19E58, OS_LOG_TYPE_ERROR))
  {
    sub_10079AD38();
  }
}

void sub_10073D040(uint64_t a1, xpc_object_t xdict)
{
  xpc_object_t value = xpc_dictionary_get_value(xdict, "kMessageArgs");
  if (value)
  {
    BOOL v4 = xpc_dictionary_get_BOOL(value, "kWCMAirplayCritical");
    uint64_t v5 = qword_100A19E58;
    if (os_log_type_enabled((os_log_t)qword_100A19E58, OS_LOG_TYPE_DEFAULT))
    {
      int v10 = 67109120;
      BOOL v11 = v4;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "WifiAirplayCriticalBuffering state: %d", (uint8_t *)&v10, 8u);
    }
    uint64_t v6 = sub_10003FB34();
    if ((*(unsigned int (**)(uint64_t))(*(void *)v6 + 2584))(v6))
    {
      int v7 = *(unsigned __int8 *)(a1 + 152);
      if (*(unsigned char *)(a1 + 152))
      {
        int v8 = qword_100A19E58;
        if (os_log_type_enabled((os_log_t)qword_100A19E58, OS_LOG_TYPE_DEFAULT))
        {
          int v9 = *(unsigned __int8 *)(a1 + 153);
          int v10 = 67109376;
          BOOL v11 = v7;
          __int16 v12 = 1024;
          int v13 = v9;
          _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "Overriding current CoexParameter state of Parameter: %d, State: %d", (uint8_t *)&v10, 0xEu);
        }
      }
      *(unsigned char *)(a1 + 152) = 2;
      *(unsigned char *)(a1 + 153) = v4;
    }
  }
  else if (os_log_type_enabled((os_log_t)qword_100A19E58, OS_LOG_TYPE_ERROR))
  {
    sub_10079AD6C();
  }
}

void sub_10073D1E8(uint64_t a1, xpc_object_t xdict)
{
  size_t length = 0;
  data = xpc_dictionary_get_data(xdict, "kMessageArgs", &length);
  if (data && length >= 0x60)
  {
    for (uint64_t i = 0; i != 96; ++i)
      *(unsigned char *)(a1 + i + 168) = byte_1007C07D0[i] & data[i];
    int v92 = 412948512;
    uint64_t v91 = 0x17A31725165D141ELL;
    uint64_t v89 = *(void *)aE_0;
    int v90 = 8192125;
    uint64_t v5 = &v65;
    long long v87 = 0u;
    memset(v88, 0, sizeof(v88));
    long long v85 = 0u;
    long long v86 = 0u;
    long long v83 = 0u;
    long long v84 = 0u;
    long long v82 = 0u;
    long long v81 = 0u;
    long long v80 = 0u;
    long long v79 = 0u;
    long long v78 = 0u;
    long long v77 = 0u;
    long long v76 = 0u;
    long long v75 = 0u;
    long long v74 = 0u;
    long long v73 = 0u;
    long long v72 = 0u;
    long long v71 = 0u;
    long long v70 = 0u;
    long long v69 = 0u;
    long long v68 = 0u;
    long long v67 = 0u;
    long long v66 = 0u;
    uint64_t v6 = 168;
    char v65 = -1;
    do
    {
      *uint64_t v5 = *(_OWORD *)(a1 + v6);
      uint64_t v5 = (_OWORD *)((char *)v5 + 63);
      v6 += 16;
    }
    while (v6 != 264);
    uint8x16_t v7 = (uint8x16_t)vcntq_s8(*(int8x16_t *)(a1 + 168));
    uint16x8_t v8 = vmovl_high_u8(v7);
    uint16x8_t v9 = vmovl_u8(*(uint8x8_t *)v7.i8);
    uint8x16_t v10 = (uint8x16_t)vcntq_s8(*(int8x16_t *)(a1 + 184));
    uint16x8_t v11 = vmovl_high_u8(v10);
    uint16x8_t v12 = vmovl_u8(*(uint8x8_t *)v10.i8);
    uint8x16_t v13 = (uint8x16_t)vcntq_s8(*(int8x16_t *)(a1 + 200));
    uint16x8_t v14 = vmovl_high_u8(v13);
    uint16x8_t v15 = vmovl_u8(*(uint8x8_t *)v13.i8);
    uint8x16_t v16 = (uint8x16_t)vcntq_s8(*(int8x16_t *)(a1 + 216));
    uint16x8_t v17 = vmovl_high_u8(v16);
    uint16x8_t v18 = vmovl_u8(*(uint8x8_t *)v16.i8);
    uint8x16_t v19 = (uint8x16_t)vcntq_s8(*(int8x16_t *)(a1 + 232));
    uint16x8_t v20 = vmovl_high_u8(v19);
    uint16x8_t v21 = vmovl_u8(*(uint8x8_t *)v19.i8);
    uint8x16_t v22 = (uint8x16_t)vcntq_s8(*(int8x16_t *)(a1 + 248));
    uint16x8_t v23 = vmovl_high_u8(v22);
    uint16x8_t v24 = vmovl_u8(*(uint8x8_t *)v22.i8);
    v23.i32[0] = vaddvq_s32(vaddq_s32(vaddq_s32((int32x4_t)vaddl_u16(*(uint16x4_t *)v24.i8, *(uint16x4_t *)v23.i8), (int32x4_t)vaddl_high_u16(v24, v23)), (int32x4_t)xmmword_1007C07C0));
    v20.i32[0] = vaddvq_s32(vaddq_s32((int32x4_t)vaddl_u16(*(uint16x4_t *)v21.i8, *(uint16x4_t *)v20.i8), (int32x4_t)vaddl_high_u16(v21, v20)));
    v8.i32[0] = vaddvq_s32(vaddq_s32(vaddq_s32((int32x4_t)vaddl_u16(*(uint16x4_t *)v9.i8, *(uint16x4_t *)v8.i8), (int32x4_t)vaddl_high_u16(v9, v8)), (int32x4_t)xmmword_1007C0790));
    __int32 v40 = v8.i32[0];
    int v41 = vaddvq_s32(vaddq_s32(vaddq_s32((int32x4_t)vaddl_u16(*(uint16x4_t *)v12.i8, *(uint16x4_t *)v11.i8), (int32x4_t)vaddl_high_u16(v12, v11)), (int32x4_t)xmmword_1007C07A0));
    v8.i32[1] = v41;
    uint64_t v62 = v8.i64[0];
    int v63 = 0;
    int v42 = vaddvq_s32(vaddq_s32(vaddq_s32((int32x4_t)vaddl_u16(*(uint16x4_t *)v15.i8, *(uint16x4_t *)v14.i8), (int32x4_t)vaddl_high_u16(v15, v14)), (int32x4_t)xmmword_1007C07B0));
    __int32 v43 = v23.i32[0];
    v8.i32[0] = v42;
    int v44 = vaddvq_s32(vaddq_s32((int32x4_t)vaddl_u16(*(uint16x4_t *)v18.i8, *(uint16x4_t *)v17.i8), (int32x4_t)vaddl_high_u16(v18, v17)));
    __int32 v45 = v20.i32[0];
    v8.i32[1] = v44;
    v8.i64[1] = __PAIR64__(v23.u32[0], v20.u32[0]);
    uint16x8_t v64 = v8;
    unsigned int v25 = qword_100A19E58;
    if (os_log_type_enabled((os_log_t)qword_100A19E58, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 67110656;
      __int32 v49 = v40;
      __int16 v50 = 1024;
      int v51 = v41;
      __int16 v52 = 1024;
      int v53 = 0;
      __int16 v54 = 1024;
      int v55 = v42;
      __int16 v56 = 1024;
      int v57 = v44;
      __int16 v58 = 1024;
      __int32 v59 = v45;
      __int16 v60 = 1024;
      __int32 v61 = v43;
      _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "PurpleCoexManager: TotalUniChannels received from cellular: unii1 %d, unii3 %d, unii4 %d, unii5a %d, unii5b %d, unii5c %d, unii5d %d", buf, 0x2Cu);
    }
    uint64_t v26 = 0;
    char v27 = 0;
    while (1)
    {
      int v28 = *((_DWORD *)&v62 + v26);
      if (v28 <= 19)
      {
        *(unsigned char *)(a1 + v26 + 271) = 0;
      }
      else
      {
        ++v27;
        char v29 = 1;
        *(unsigned char *)(a1 + v26 + 271) = 1;
        if (v28 > 0x31) {
          goto LABEL_15;
        }
      }
      char v29 = 0;
LABEL_15:
      *(unsigned char *)(a1 + v26++ + 264) = v29;
      if (v26 == 7)
      {
        if (v27)
        {
          if (v27 == 6)
          {
            uint64_t v30 = sub_10003FB34();
            (*(void (**)(uint64_t, uint64_t, uint64_t *, uint64_t *, char *, uint64_t))(*(void *)v30 + 1440))(v30, 3, &v91, &v89, &v65, 1);
            uint64_t v31 = *(void *)sub_10003FB34();
            (*(void (**)(void))(v31 + 1440))();
          }
          else
          {
            uint64_t v35 = 0;
            __int16 v36 = (unsigned __int8 *)(a1 + 271);
            long long v37 = &v65;
            do
            {
              int v38 = *v36++;
              if (v38 == 1)
              {
                uint64_t v39 = sub_10003FB34();
                (*(void (**)(uint64_t, uint64_t, char *, char *, char *, uint64_t))(*(void *)v39 + 1440))(v39, 1, (char *)&v91 + v35, (char *)&v89 + v35, v37, 1);
              }
              v37 += 63;
              v35 += 2;
            }
            while (v35 != 14);
          }
        }
        v46[0] = _NSConcreteStackBlock;
        v46[1] = 3221225472;
        v46[2] = sub_10073E2B8;
        v46[3] = &unk_1009C1098;
        v46[4] = a1;
        sub_1000145A8((os_unfair_lock_s *)(a1 + 480), v46);
        sub_10073E2EC(a1, (const void *)(a1 + 168));
        return;
      }
    }
  }
  uint64_t v32 = qword_100A19E58;
  if (os_log_type_enabled((os_log_t)qword_100A19E58, OS_LOG_TYPE_ERROR)) {
    sub_10079ADA0(v32, v33, v34);
  }
}

uint64_t sub_10073D740(uint64_t a1, xpc_object_t xdict)
{
  BOOL v3 = xpc_dictionary_get_BOOL(xdict, "kMessageArgs");
  *(unsigned char *)(a1 + 279) = v3;
  BOOL v4 = qword_100A19E58;
  if (os_log_type_enabled((os_log_t)qword_100A19E58, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = "Disabled";
    if (v3) {
      uint64_t v5 = "Enabled";
    }
    int v8 = 136315394;
    uint16x8_t v9 = "void BT::PurpleCoexManager::SetMWSTxIndHRBEnable(xpc_object_t)";
    __int16 v10 = 2080;
    uint16x8_t v11 = v5;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "%s, MWSTxIndHRBEnable set to %s", (uint8_t *)&v8, 0x16u);
  }
  uint64_t v6 = sub_10003FB34();
  return (*(uint64_t (**)(uint64_t, void, uint64_t, void, uint64_t))(*(void *)v6 + 2968))(v6, 0, 49, *(unsigned __int8 *)(a1 + 279) ^ 1u, 1);
}

void sub_10073D878(os_unfair_lock_s *a1, xpc_object_t xdict)
{
  xpc_object_t value = xpc_dictionary_get_value(xdict, "kMessageArgs");
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 3221225472;
  _DWORD v4[2] = sub_10073E3D0;
  v4[3] = &unk_1009C10B8;
  v4[4] = xpc_dictionary_get_uint64(value, "kWCMBTWiFiChannel");
  v4[5] = xpc_dictionary_get_uint64(value, "kWCMBTWiFiChannelBandwidth");
  v4[6] = xpc_dictionary_get_uint64(value, "kWCMBTWiFiRegulatoryBand");
  sub_1000145A8(a1 + 120, v4);
}

uint64_t sub_10073D950(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, BOOL))(*(void *)a2 + 8))(a2, *(unsigned char *)(a1 + 32) == 1);
}

uint64_t sub_10073D988(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, BOOL))(*(void *)a2 + 16))(a2, *(unsigned char *)(a1 + 32) == 1);
}

uint64_t sub_10073D9C0(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, BOOL))(*(void *)a2 + 24))(a2, *(unsigned char *)(a1 + 32) == 1);
}

uint64_t sub_10073D9F8(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, BOOL))(*(void *)a2 + 32))(a2, *(unsigned char *)(a1 + 32) == 1);
}

uint64_t sub_10073DA30(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, BOOL))(*(void *)a2 + 40))(a2, *(unsigned char *)(a1 + 32) == 1);
}

uint64_t sub_10073DA68(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, BOOL))(*(void *)a2 + 48))(a2, *(unsigned char *)(a1 + 32) == 1);
}

void sub_10073DAA0(uint64_t a1, int a2, int a3, unsigned int a4, int a5, uint64_t a6)
{
  if (a2 <= 95)
  {
    switch(a2)
    {
      case 0:
        uint64_t v12 = 0;
        int v11 = 1;
        goto LABEL_21;
      case 48:
        int v11 = 1;
        uint64_t v12 = 1;
        goto LABEL_21;
      case 64:
        int v11 = 1;
        uint64_t v12 = 2;
        goto LABEL_21;
    }
    goto LABEL_16;
  }
  if (a2 == 96)
  {
    int v11 = 1;
    uint64_t v12 = 3;
    goto LABEL_21;
  }
  if (a2 != 144)
  {
    if (a2 == 480)
    {
      int v11 = 1;
      uint64_t v12 = 6;
      goto LABEL_21;
    }
LABEL_16:
    int v11 = 0;
    uint64_t v12 = -1;
    goto LABEL_21;
  }
  if (a3 == 48)
  {
    int v11 = 1;
    uint64_t v12 = 4;
  }
  else if (a3 == 16)
  {
    int v11 = 1;
    uint64_t v12 = 5;
  }
  else
  {
    if (os_log_type_enabled((os_log_t)qword_100A19E58, OS_LOG_TYPE_ERROR)) {
      sub_10079AF20();
    }
    uint64_t v12 = 1;
    int v11 = 1;
  }
LABEL_21:
  BOOL v14 = byte_100A147D8 != a4 || v12 != byte_100A147D9;
  byte_100A147D8 = a4;
  byte_100A147D9 = v12;
  uint16x8_t v15 = qword_100A19E58;
  if (os_log_type_enabled((os_log_t)qword_100A19E58, OS_LOG_TYPE_INFO))
  {
    uint8x16_t v16 = "-";
    if (v14) {
      uint8x16_t v16 = ">";
    }
    if (v11) {
      uint16x8_t v17 = off_1009C12B8[v12];
    }
    else {
      uint16x8_t v17 = "NA";
    }
    uint16x8_t v18 = "NA";
    uint8x16_t v19 = "NA";
    if (a4 <= 2) {
      uint8x16_t v19 = off_1009C12F0[(char)a4];
    }
    uint16x8_t v20 = "kWCMWiFiStateBand5G";
    if (a5 == 2) {
      uint16x8_t v21 = "kWCMWiFiStateBand5G";
    }
    else {
      uint16x8_t v21 = "NA";
    }
    if (a5 == 1) {
      uint16x8_t v21 = "kWCMWiFiStateBand2_4G";
    }
    int v22 = *(unsigned __int8 *)(a1 + 162);
    if (v22 != 2) {
      uint16x8_t v20 = "NA";
    }
    if (v22 == 1) {
      uint16x8_t v20 = "kWCMWiFiStateBand2_4G";
    }
    __int16 v23 = *(_WORD *)(a1 + 160);
    if (v23 <= 2u) {
      uint16x8_t v18 = off_1009C1308[(char)v23];
    }
    int v25 = 136317186;
    uint64_t v26 = v16;
    __int16 v27 = 2080;
    int v28 = v17;
    __int16 v29 = 1024;
    int v30 = a2;
    __int16 v31 = 2080;
    uint64_t v32 = v19;
    __int16 v33 = 1024;
    unsigned int v34 = a4;
    __int16 v35 = 2080;
    __int16 v36 = v21;
    __int16 v37 = 2080;
    int v38 = v20;
    __int16 v39 = 2080;
    __int32 v40 = v18;
    __int16 v41 = 2048;
    uint64_t v42 = a6;
    _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_INFO, "WCMBTLeConnect(-%s) %s(0x%x) %s(%d) BT:%s WiFi:%s %s kWCMBTLeConnect_Duration:%llums", (uint8_t *)&v25, 0x54u);
  }
  if (v14)
  {
    xpc_object_t v24 = xpc_dictionary_create(0, 0, 0);
    xpc_dictionary_set_uint64(v24, "kWCMBTLeConnect_DC", v12);
    xpc_dictionary_set_uint64(v24, "kWCMBTLeConnect_OverrideReason", a4);
    xpc_dictionary_set_uint64(v24, "kWCMBTLeConnect_Band", 0);
    xpc_dictionary_set_uint64(v24, "kWCMBTLeConnect_Duration", a6);
    sub_10073A58C(a1, 0x6CuLL, v24);
    xpc_release(v24);
  }
}

uint64_t sub_10073DDE0(uint64_t a1)
{
  v22[0] = 0;
  v22[1] = 0;
  sub_10003AED0((uint64_t)v22, a1 + 80);
  uint64_t v2 = sub_100017768();
  sub_10004191C(buf, "COEXDEBUG");
  sub_10004191C(__p, "Enabled");
  (*(void (**)(uint64_t, uint8_t *, void **, uint64_t))(*(void *)v2 + 72))(v2, buf, __p, a1 + 280);
  if (v19 < 0) {
    operator delete(__p[0]);
  }
  if (v21 < 0) {
    operator delete(*(void **)buf);
  }
  if (*(unsigned char *)(a1 + 280))
  {
    BOOL v3 = qword_100A19E58;
    if (os_log_type_enabled((os_log_t)qword_100A19E58, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "PurpleCoexManager::debugWifiStateUpdate COEXDEBUG", buf, 2u);
    }
    char v17 = 0;
    uint64_t v4 = sub_100017768();
    sub_10004191C(buf, "COEXDEBUG");
    sub_10004191C(__p, "wifiStatePower");
    int v5 = (*(uint64_t (**)(uint64_t, uint8_t *, void **, char *))(*(void *)v4 + 72))(v4, buf, __p, &v17);
    if (v19 < 0) {
      operator delete(__p[0]);
    }
    if (v21 < 0) {
      operator delete(*(void **)buf);
    }
    if (v17) {
      int v6 = 0;
    }
    else {
      int v6 = v5;
    }
    if (v6 == 1)
    {
      *(_DWORD *)(a1 + 160) = 0;
      *(_WORD *)(a1 + 166) = 0;
      v16[0] = _NSConcreteStackBlock;
      v16[1] = 3221225472;
      void v16[2] = sub_10073E1E8;
      v16[3] = &unk_1009C1098;
      void v16[4] = a1;
      sub_1000145A8((os_unfair_lock_s *)(a1 + 480), v16);
    }
    else
    {
      int v15 = 0;
      uint64_t v7 = sub_100017768();
      sub_10004191C(buf, "COEXDEBUG");
      sub_10004191C(__p, "wifiStateBand");
      int v8 = (*(uint64_t (**)(uint64_t, uint8_t *, void **, int *))(*(void *)v7 + 88))(v7, buf, __p, &v15);
      if (v19 < 0) {
        operator delete(__p[0]);
      }
      if (v21 < 0) {
        operator delete(*(void **)buf);
      }
      if (v8) {
        *(_WORD *)(a1 + 162) = v15;
      }
      uint64_t v14 = 0;
      uint64_t v9 = sub_100017768();
      sub_10004191C(buf, "COEXDEBUG");
      sub_10004191C(__p, "UCMWifiStateBitmap");
      int v10 = (*(uint64_t (**)(uint64_t, uint8_t *, void **, uint64_t *))(*(void *)v9 + 144))(v9, buf, __p, &v14);
      if (v19 < 0) {
        operator delete(__p[0]);
      }
      if (v21 < 0) {
        operator delete(*(void **)buf);
      }
      if (v10)
      {
        __int16 v11 = v14 != 0;
        *(_WORD *)(a1 + 166) = v14;
        *(_WORD *)(a1 + 160) = 2 * v11;
      }
      v13[0] = _NSConcreteStackBlock;
      v13[1] = 3221225472;
      _DWORD v13[2] = sub_10073E21C;
      void v13[3] = &unk_1009C1098;
      uint8_t v13[4] = a1;
      sub_1000145A8((os_unfair_lock_s *)(a1 + 480), v13);
    }
  }
  return sub_10003AFB4((uint64_t)v22);
}

void sub_10073E170(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0) {
    operator delete(__p);
  }
  if (*(char *)(v27 - 57) < 0) {
    operator delete(*(void **)(v27 - 80));
  }
  sub_10003AFB4(v27 - 48);
  _Unwind_Resume(a1);
}

uint64_t sub_10073E1E8(uint64_t a1, uint64_t (***a2)(void, void))
{
  return (**a2)(a2, *(unsigned __int16 *)(*(void *)(a1 + 32) + 166));
}

uint64_t sub_10073E21C(uint64_t a1, uint64_t (***a2)(void, void))
{
  return (**a2)(a2, *(unsigned __int16 *)(*(void *)(a1 + 32) + 166));
}

void sub_10073E250()
{
  uint64_t v0 = qword_100A19E58;
  if (os_log_type_enabled((os_log_t)qword_100A19E58, OS_LOG_TYPE_INFO))
  {
    *(_WORD *)uint64_t v1 = 0;
    _os_log_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_INFO, "Set AFH CB", v1, 2u);
  }
}

uint64_t sub_10073E2B8(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a2 + 56))(a2, *(void *)(a1 + 32) + 264);
}

void sub_10073E2EC(uint64_t a1, const void *a2)
{
  uint64_t v4 = qword_100A19E58;
  if (!a2 && os_log_type_enabled((os_log_t)qword_100A19E58, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)long long buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_ERROR, "Error: BT is trying to send an empty map to UCM", buf, 2u);
    uint64_t v4 = qword_100A19E58;
  }
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)int v6 = 0;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "BT Sending HRB AFH MAP to WCM", v6, 2u);
  }
  xpc_object_t v5 = xpc_data_create(a2, 0x60uLL);
  sub_10073A58C(a1, 0x205uLL, v5);
  xpc_release(v5);
}

uint64_t sub_10073E3D0(void *a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, void, void, void))(*(void *)a2 + 64))(a2, a1[4], a1[5], a1[6]);
}

void sub_10073E404(int a1)
{
  uint64_t v2 = qword_100A19E58;
  if (os_log_type_enabled((os_log_t)qword_100A19E58, OS_LOG_TYPE_DEFAULT))
  {
    v3[0] = 67109120;
    v3[1] = a1;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Set LE AFH CB status = %{bluetooth:OI_STATUS}u", (uint8_t *)v3, 8u);
  }
}

uint64_t sub_10073E4A8(uint64_t result, unsigned char *a2, unsigned char *a3)
{
  *a2 = *(unsigned char *)(result + 152);
  *a3 = *(unsigned char *)(result + 153);
  return result;
}

uint64_t sub_10073E4BC(uint64_t a1)
{
  uint64_t v2 = sub_100035F54();
  if (((*(uint64_t (**)(uint64_t))(*(void *)v2 + 352))(v2) & 1) == 0)
  {
    uint64_t v3 = sub_100035F54();
    if (((*(uint64_t (**)(uint64_t))(*(void *)v3 + 360))(v3) & 1) == 0)
    {
      uint64_t v4 = sub_100035F54();
      if (((*(uint64_t (**)(uint64_t))(*(void *)v4 + 424))(v4) & 1) == 0) {
        *(_DWORD *)(a1 + 156) = 0;
      }
    }
  }
  return *(unsigned int *)(a1 + 156);
}

uint64_t sub_10073E580(uint64_t a1)
{
  return (*(unsigned __int16 *)(a1 + 166) >> 6) & 1;
}

BOOL sub_10073E58C(uint64_t a1)
{
  return *(unsigned __int16 *)(a1 + 162) == 1;
}

void sub_10073E59C(uint64_t a1, unint64_t a2, unsigned int a3, unsigned int a4, int a5)
{
  if (a3 == 0x8000)
  {
    sub_1006AD3F0();
    id v8 = objc_claimAutoreleasedReturnValue();
    string = (char *)[v8 UTF8String];

    uint64_t v9 = 0;
    uint64_t v10 = 0;
    uint64_t v11 = 0;
    uint64_t v12 = 0;
    uint64_t v13 = 0;
    uint64_t v14 = 0;
  }
  else
  {
    sub_1006ACEAC();
    id v15 = objc_claimAutoreleasedReturnValue();
    string = (char *)[v15 UTF8String];

    uint64_t v9 = 0;
    uint64_t v10 = 0;
    uint64_t v11 = 0;
    uint64_t v12 = 0;
    uint64_t v13 = 0;
    if (a4 == 11 && !a5)
    {
      *(void *)long long buf = 0;
      unint64_t v16 = sub_10022A5E0(a2);
      int v25 = v16;
      __int16 v26 = WORD2(v16);
      char v24 = 0;
      sub_10001B8E0(&v24);
      int v17 = sub_10017E3E4((uint64_t)&v25, (uint64_t)buf);
      sub_10001B910(&v24);
      if (v17)
      {
        if (os_log_type_enabled((os_log_t)qword_100A19E58, OS_LOG_TYPE_ERROR)) {
          sub_10079AFA4();
        }
        uint64_t v9 = 0;
        uint64_t v10 = 0;
        uint64_t v11 = 0;
        uint64_t v12 = 0;
        uint64_t v13 = 0;
      }
      else
      {
        uint64_t v9 = buf[0];
        uint64_t v10 = buf[1];
        uint64_t v11 = buf[2];
        uint64_t v12 = *(unsigned __int16 *)&buf[4];
        uint64_t v13 = *(unsigned __int16 *)&buf[6];
      }
      sub_10001B8AC(&v24);
    }
    if (qword_1009F7F00 != -1) {
      dispatch_once(&qword_1009F7F00, &stru_1009C11C8);
    }
    uint64_t v18 = sub_100030F10((uint64_t)off_1009F7EF8, a2, 0);
    uint64_t v14 = v18;
    if (v18)
    {
      if (sub_10047BAFC(v18))
      {
        uint64_t v14 = 1;
      }
      else if (sub_10047BB08(v14))
      {
        uint64_t v14 = 2;
      }
      else
      {
        uint64_t v14 = 0;
      }
    }
  }
  xpc_object_t v19 = xpc_dictionary_create(0, 0, 0);
  xpc_dictionary_set_string(v19, "kWCMBTConnectionConfiguration_Address", string);
  xpc_dictionary_set_uint64(v19, "kWCMBTConnectionConfiguration_ServiceId", a3);
  xpc_dictionary_set_uint64(v19, "kWCMBTConnectionConfiguration_EventId", a4);
  xpc_dictionary_set_uint64(v19, "kWCMBTConnectionConfiguration_Result", a5);
  if (a3 != 0x8000)
  {
    xpc_dictionary_set_uint64(v19, "kWCMBTConnectionConfiguration_DeviceType", v9);
    xpc_dictionary_set_uint64(v19, "kWCMBTConnectionConfiguration_Role", v10);
    xpc_dictionary_set_uint64(v19, "kWCMBTConnectionConfiguration_Mode", v11);
    xpc_dictionary_set_uint64(v19, "kWCMBTConnectionConfiguration_ConnTo", v12);
    xpc_dictionary_set_uint64(v19, "kWCMBTConnectionConfiguration_ConnIntrvl", v13);
    xpc_dictionary_set_uint64(v19, "kWCMBTConnectionConfiguration_Latncy", 0);
    xpc_dictionary_set_uint64(v19, "kWCMBTConnectionConfiguration_RequiresRC2CoExType", v14);
  }
  uint16x8_t v20 = qword_100A19E58;
  if (os_log_type_enabled((os_log_t)qword_100A19E58, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 136317698;
    *(void *)&uint8_t buf[4] = string;
    __int16 v28 = 1024;
    unsigned int v29 = a3;
    __int16 v30 = 1024;
    unsigned int v31 = a4;
    __int16 v32 = 1024;
    int v33 = a5;
    __int16 v34 = 2048;
    uint64_t v35 = v9;
    __int16 v36 = 2048;
    uint64_t v37 = v10;
    __int16 v38 = 2048;
    uint64_t v39 = v11;
    __int16 v40 = 2048;
    uint64_t v41 = v12;
    __int16 v42 = 2048;
    uint64_t v43 = v13;
    __int16 v44 = 2048;
    uint64_t v45 = 0;
    __int16 v46 = 2048;
    uint64_t v47 = v14;
    _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "Sending Connection Config: Address: %s, ServiceId: %u, EventId: %u, Result: %d, DeviceType: %llu, Role: %llu, Mode: %llu, ConnTo: %llu, ConnIntrv: %llu, Latency: %llu, RC2CoExType: %llu", buf, 0x64u);
  }
  sub_10073A58C(a1, 0x1F4uLL, v19);
  xpc_release(v19);
}

void sub_10073E974(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
}

void sub_10073E9A0(uint64_t a1, unint64_t a2, uint64_t a3, int a4, int a5, int a6, unsigned int a7)
{
  unint64_t v39 = a2;
  if (a4 == 0x10000 || a4 == 0x400000)
  {
    sub_1006AD3F0();
    id v7 = objc_claimAutoreleasedReturnValue();
    uint64_t v14 = (const char *)[v7 UTF8String];
  }
  else
  {
    sub_1006ACEAC();
    id v8 = objc_claimAutoreleasedReturnValue();
    uint64_t v14 = (const char *)[v8 UTF8String];
  }
  if (a4 == 0x400000 || a4 == 0x10000)
  {

    uint64_t v15 = 0;
    uint64_t v16 = 0;
    goto LABEL_49;
  }

  uint64_t v38 = 0;
  unsigned __int8 v37 = 0;
  unint64_t v17 = sub_10022A5E0(v39);
  int v35 = v17;
  __int16 v36 = WORD2(v17);
  char v34 = 0;
  sub_10001B8E0(&v34);
  if (sub_10017E3E4((uint64_t)&v35, (uint64_t)&v38))
  {
    if (os_log_type_enabled((os_log_t)qword_100A19E58, OS_LOG_TYPE_ERROR)) {
      sub_10079B074();
    }
    uint64_t v15 = 0;
  }
  else
  {
    uint64_t v15 = BYTE1(v38);
  }
  uint64_t v16 = 0;
  if (a5 > 109)
  {
    if (a5 == 110)
    {
      __int16 v28 = qword_100A19E58;
      if (os_log_type_enabled((os_log_t)qword_100A19E58, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, "set packetype to 1 for BT_SERVICE_A2DP_LOW_LATENCY_ON", buf, 2u);
      }
      uint64_t v16 = 1;
      goto LABEL_48;
    }
    if (a5 == 111)
    {
      uint64_t v24 = qword_100A19E58;
      if (os_log_type_enabled((os_log_t)qword_100A19E58, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        int v25 = "set packetype to 2 for BT_SERVICE_A2DP_LOW_LATENCY_OFF";
        uint64_t v16 = 2;
        __int16 v26 = v24;
        uint32_t v27 = 2;
LABEL_44:
        _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, v25, buf, v27);
        goto LABEL_48;
      }
      uint64_t v16 = 2;
    }
LABEL_48:
    sub_10001B910(&v34);
    sub_10001B8AC(&v34);
LABEL_49:
    xpc_object_t v31 = xpc_dictionary_create(0, 0, 0);
    xpc_dictionary_set_string(v31, "kWCMBTAudioConfiguration_Address", v14);
    xpc_dictionary_set_uint64(v31, "kWCMBTAudioConfiguration_ConnectionState", a7);
    xpc_dictionary_set_uint64(v31, "kWCMBTAudioConfiguration_Type", a3);
    if (a4 != 0x10000 && a4 != 0x400000)
    {
      xpc_dictionary_set_uint64(v31, "kWCMBTAudioConfiguration_Role", v15);
      xpc_dictionary_set_uint64(v31, "kWCMBTAudioConfiguration_PacketType", v16);
    }
    __int16 v32 = qword_100A19E58;
    if (os_log_type_enabled((os_log_t)qword_100A19E58, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 136316930;
      *(void *)&uint8_t buf[4] = v14;
      __int16 v41 = 1024;
      *(_DWORD *)__int16 v42 = a7;
      *(_WORD *)&v42[4] = 2048;
      *(void *)&v42[6] = a3;
      __int16 v43 = 1024;
      int v44 = a4;
      __int16 v45 = 1024;
      int v46 = a5;
      __int16 v47 = 1024;
      int v48 = a6;
      __int16 v49 = 2048;
      uint64_t v50 = v15;
      __int16 v51 = 2048;
      uint64_t v52 = v16;
      _os_log_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_DEFAULT, "Sending Audio Config: Address: %s, Connection: %d, Type: %llu, ServiceId: %u, Event: %u, Result: %d, Role: %llu, PacketType: %llu", buf, 0x42u);
    }
    sub_10073A58C(a1, 0x1F5uLL, v31);
    xpc_release(v31);
    return;
  }
  if (a5 != 101)
  {
    if (a5 == 102)
    {
      uint64_t v18 = *(void **)(a1 + 432);
      if (!v18) {
        goto LABEL_27;
      }
      uint64_t v19 = a1 + 432;
      do
      {
        unint64_t v20 = v18[4];
        BOOL v21 = v20 >= v39;
        if (v20 >= v39) {
          int v22 = v18;
        }
        else {
          int v22 = v18 + 1;
        }
        if (v21) {
          uint64_t v19 = (uint64_t)v18;
        }
        uint64_t v18 = (void *)*v22;
      }
      while (*v22);
      if (v19 != a1 + 432 && v39 >= *(void *)(v19 + 32))
      {
        *(void *)long long buf = &v39;
        uint64_t v16 = sub_1000097B0((uint64_t **)(a1 + 424), &v39, (uint64_t)&unk_1007BE9D0, (uint64_t **)buf)[5];
        __int16 v30 = qword_100A19E58;
        if (os_log_type_enabled((os_log_t)qword_100A19E58, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)long long buf = 136446466;
          *(void *)&uint8_t buf[4] = v14;
          __int16 v41 = 2048;
          *(void *)__int16 v42 = v16;
          _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_DEFAULT, "Found device %{public}s in fScoPacketTypeMap. Sending packet type %llu", buf, 0x16u);
        }
        sub_1000517A4(a1 + 424, &v39);
      }
      else
      {
LABEL_27:
        __int16 v23 = qword_100A19E58;
        if (os_log_type_enabled((os_log_t)qword_100A19E58, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)long long buf = 136446466;
          *(void *)&uint8_t buf[4] = v14;
          __int16 v41 = 2048;
          *(void *)__int16 v42 = 0;
          _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "Did not find device %{public}s in fScoPacketTypeMap. Sending packet type %llu", buf, 0x16u);
        }
        uint64_t v16 = 0;
      }
    }
    goto LABEL_48;
  }
  if (!sub_10017E45C((uint64_t)&v35, &v37))
  {
    uint64_t v16 = v37;
    *(void *)long long buf = &v39;
    sub_1000097B0((uint64_t **)(a1 + 424), &v39, (uint64_t)&unk_1007BE9D0, (uint64_t **)buf)[5] = v16;
    uint64_t v29 = qword_100A19E58;
    if (os_log_type_enabled((os_log_t)qword_100A19E58, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 134218242;
      *(void *)&uint8_t buf[4] = v16;
      __int16 v41 = 2082;
      *(void *)__int16 v42 = v14;
      int v25 = "Got voice connection info. Sending packet type %llu for device %{public}s";
      __int16 v26 = v29;
      uint32_t v27 = 22;
      goto LABEL_44;
    }
    goto LABEL_48;
  }
  if (os_log_type_enabled((os_log_t)qword_100A19E58, OS_LOG_TYPE_ERROR)) {
    sub_10079B00C();
  }
  sub_10001B8AC(&v34);
}

void sub_10073EF44(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, int a10, __int16 a11, char a12, char a13)
{
}

uint64_t sub_10073EF88(uint64_t a1)
{
  v5[0] = 0;
  v5[1] = 0;
  sub_10003AED0((uint64_t)v5, a1 + 80);
  while (*(void *)(a1 + 392))
  {
    uint64_t v2 = qword_100A19E58;
    if (os_log_type_enabled((os_log_t)qword_100A19E58, OS_LOG_TYPE_DEFAULT))
    {
      int v3 = *(_DWORD *)(a1 + 320);
      *(_DWORD *)long long buf = 67109120;
      int v7 = v3;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Warning: Bandwidth: There was still connection 0x%1X in the map after ACL Disconnectd headset!", buf, 8u);
    }
    sub_10073F0A0(a1, *(_DWORD *)(a1 + 320), 0);
  }
  return sub_10003AFB4((uint64_t)v5);
}

void sub_10073F084(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11)
{
}

uint64_t sub_10073F0A0(uint64_t a1, unsigned int a2, char a3)
{
  v35[0] = 0;
  v35[1] = 0;
  uint64_t v6 = sub_10003AED0((uint64_t)v35, a1 + 80);
  int v7 = *(_DWORD *)(a1 + 320);
  if (a3)
  {
    if (v7 == a2)
    {
      uint64_t v8 = qword_100A19E58;
      if (os_log_type_enabled((os_log_t)qword_100A19E58, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(buf) = 0;
        uint64_t v9 = "Warning: Bandwidth: Received a connection that is currently active!";
        uint64_t v10 = v8;
        uint32_t v11 = 2;
LABEL_33:
        _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, v9, (uint8_t *)&buf, v11);
        return sub_10003AFB4((uint64_t)v35);
      }
      return sub_10003AFB4((uint64_t)v35);
    }
    uint64_t v17 = *(void *)(a1 + 384);
    if (v17)
    {
      uint64_t v18 = a1 + 384;
      do
      {
        unsigned int v19 = *(_DWORD *)(v17 + 28);
        BOOL v20 = v19 >= a2;
        if (v19 >= a2) {
          BOOL v21 = (uint64_t *)v17;
        }
        else {
          BOOL v21 = (uint64_t *)(v17 + 8);
        }
        if (v20) {
          uint64_t v18 = v17;
        }
        uint64_t v17 = *v21;
      }
      while (*v21);
      if (v18 != a1 + 384 && *(_DWORD *)(v18 + 28) <= a2)
      {
        if (os_log_type_enabled((os_log_t)qword_100A19E58, OS_LOG_TYPE_ERROR)) {
          sub_10079B0DC();
        }
        return sub_10003AFB4((uint64_t)v35);
      }
    }
    uint64_t buf = __PAIR64__(sub_10073F458(v6, a2), a2);
    uint64_t v22 = (uint64_t)sub_100742184((uint64_t **)(a1 + 376), (unsigned int *)&buf, &buf);
LABEL_35:
    if (!*(_DWORD *)(a1 + 392) || (uint64_t v24 = *(void **)(a1 + 376), v24 == (void *)(a1 + 384)))
    {
      int v25 = 0;
    }
    else
    {
      int v25 = 0;
      do
      {
        int v26 = *((_DWORD *)v24 + 8);
        uint64_t v22 = sub_10073F458(v22, v25);
        if (v26 > (int)v22) {
          int v25 = *((_DWORD *)v24 + 7);
        }
        uint32_t v27 = (void *)v24[1];
        if (v27)
        {
          do
          {
            __int16 v28 = v27;
            uint32_t v27 = (void *)*v27;
          }
          while (v27);
        }
        else
        {
          do
          {
            __int16 v28 = (void *)v24[2];
            BOOL v29 = *v28 == (void)v24;
            uint64_t v24 = v28;
          }
          while (!v29);
        }
        uint64_t v24 = v28;
      }
      while (v28 != (void *)(a1 + 384));
    }
    *(_DWORD *)(a1 + 288) -= sub_10073F4BC(v22, *(_DWORD *)(a1 + 316));
    *(_DWORD *)(a1 + 316) = v25;
    __int16 v30 = qword_100A19E58;
    BOOL v31 = os_log_type_enabled((os_log_t)qword_100A19E58, OS_LOG_TYPE_DEFAULT);
    if (v31)
    {
      LODWORD(buf) = 67109120;
      HIDWORD(buf) = v25;
      _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_DEFAULT, "Bandwidth: Audio connection 0x%1X, is the current Active Audio Profile", (uint8_t *)&buf, 8u);
      int v25 = *(_DWORD *)(a1 + 316);
    }
    *(_DWORD *)(a1 + 288) += sub_10073F4BC(v31, v25);
    *(_DWORD *)(a1 + 320) = *(_DWORD *)(a1 + 316);
    uint64_t v32 = sub_1004AF8EC();
    v34[0] = _NSConcreteStackBlock;
    v34[1] = 3221225472;
    v34[2] = sub_10073F520;
    v34[3] = &unk_100997528;
    v34[4] = a1;
    sub_100013018(v32, v34);
    return sub_10003AFB4((uint64_t)v35);
  }
  if (v7)
  {
    uint64_t v12 = *(void *)(a1 + 384);
    if (!v12) {
      goto LABEL_56;
    }
    uint64_t v13 = a1 + 384;
    do
    {
      unsigned int v14 = *(_DWORD *)(v12 + 28);
      BOOL v15 = v14 >= a2;
      if (v14 >= a2) {
        uint64_t v16 = (uint64_t *)v12;
      }
      else {
        uint64_t v16 = (uint64_t *)(v12 + 8);
      }
      if (v15) {
        uint64_t v13 = v12;
      }
      uint64_t v12 = *v16;
    }
    while (*v16);
    if (v13 == a1 + 384 || *(_DWORD *)(v13 + 28) > a2)
    {
LABEL_56:
      if (os_log_type_enabled((os_log_t)qword_100A19E58, OS_LOG_TYPE_ERROR)) {
        sub_10079B144();
      }
      return sub_10003AFB4((uint64_t)v35);
    }
    sub_10004D3B8((uint64_t **)(a1 + 376), (uint64_t *)v13);
    operator delete((void *)v13);
    goto LABEL_35;
  }
  uint64_t v23 = qword_100A19E58;
  if (os_log_type_enabled((os_log_t)qword_100A19E58, OS_LOG_TYPE_DEFAULT))
  {
    LODWORD(buf) = 67109120;
    HIDWORD(buf) = a2;
    uint64_t v9 = "Warning: Bandwidth: Tried removing connection 0x%1X from the map, but there was no active audio connection!";
    uint64_t v10 = v23;
    uint32_t v11 = 8;
    goto LABEL_33;
  }
  return sub_10003AFB4((uint64_t)v35);
}

void sub_10073F430(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  sub_10003AFB4((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_10073F450(uint64_t a1)
{
  return sub_10073EF88(a1 - 72);
}

uint64_t sub_10073F458(uint64_t a1, int a2)
{
  HIDWORD(v3) = a2;
  LODWORD(v3) = a2;
  unsigned int v2 = v3 >> 8;
  if (v2 < 0xB) {
    return dword_1007C0854[v2];
  }
  uint64_t result = os_log_type_enabled((os_log_t)qword_100A19E58, OS_LOG_TYPE_ERROR);
  if (result)
  {
    sub_10079B1AC();
    return 0;
  }
  return result;
}

uint64_t sub_10073F4BC(uint64_t a1, int a2)
{
  HIDWORD(v3) = a2;
  LODWORD(v3) = a2;
  unsigned int v2 = v3 >> 8;
  if (v2 < 0xB) {
    return dword_1007C0880[v2];
  }
  uint64_t result = os_log_type_enabled((os_log_t)qword_100A19E58, OS_LOG_TYPE_ERROR);
  if (result)
  {
    sub_10079B1E0();
    return 0;
  }
  return result;
}

uint64_t sub_10073F520(uint64_t a1)
{
  return sub_10073A198(*(uint32x2_t **)(a1 + 32));
}

uint64_t sub_10073F528(uint64_t a1, char a2)
{
  return sub_10073F0A0(a1, 0x900u, a2);
}

uint64_t sub_10073F534(uint32x2_t *a1, uint64_t a2, int a3, int a4, int a5)
{
  int v52 = a4;
  int v53 = a3;
  v51[0] = 0;
  v51[1] = 0;
  sub_10003AED0((uint64_t)v51, (uint64_t)&a1[10]);
  if (a3 == 16)
  {
    if (a4 <= 110)
    {
      switch(a4)
      {
        case 11:
          if (a1[35].i8[1]) {
            goto LABEL_70;
          }
          a1[36].i32[0] += 27;
          a1[35].i8[1] = 1;
          break;
        case 12:
          if (!a1[35].i8[1]) {
            goto LABEL_70;
          }
          a1[36].i32[0] -= 27;
          a1[35].i8[1] = 0;
          break;
        case 110:
          char v15 = 1;
LABEL_64:
          unsigned int v26 = 1024;
          goto LABEL_65;
        default:
          goto LABEL_70;
      }
      sub_10073A198(a1);
      return sub_10003AFB4((uint64_t)v51);
    }
    if (a4 == 111)
    {
      char v15 = 0;
      goto LABEL_64;
    }
    if (a4 == 201)
    {
      if (!a1[35].i8[2])
      {
        a1[35].i8[2] = 1;
        sub_10073F0A0((uint64_t)a1, 0x300u, 1);
        if (!a1[35].i8[1])
        {
          a1[36].i32[0] += 27;
          a1[35].i8[1] = 1;
        }
        return sub_10003AFB4((uint64_t)v51);
      }
      if (a2)
      {
        if (*(_WORD *)(a2 + 986))
        {
          sub_10073F0A0((uint64_t)a1, 0x800u, 1);
        }
        else if (os_log_type_enabled((os_log_t)qword_100A19E58, OS_LOG_TYPE_ERROR))
        {
          sub_10079B2B4();
        }
        return sub_10003AFB4((uint64_t)v51);
      }
    }
    else if (a4 == 202 && a1[35].i8[2])
    {
      uint32x2_t v19 = a1[48];
      if (v19)
      {
        BOOL v20 = a1 + 48;
        BOOL v21 = a1 + 48;
        uint32x2_t v22 = a1[48];
        do
        {
          unsigned int v23 = *(_DWORD *)(*(void *)&v22 + 28);
          BOOL v24 = v23 >= 0x800;
          if (v23 >= 0x800) {
            int v25 = (uint32x2_t *)v22;
          }
          else {
            int v25 = (uint32x2_t *)(*(void *)&v22 + 8);
          }
          if (v24) {
            BOOL v21 = (uint32x2_t *)v22;
          }
          uint32x2_t v22 = *v25;
        }
        while (*v25);
        if (v21 != v20 && v21[3].i32[1] < 0x801u)
        {
          char v15 = 0;
          unsigned int v26 = 2048;
LABEL_65:
          sub_10073F0A0((uint64_t)a1, v26, v15);
          return sub_10003AFB4((uint64_t)v51);
        }
        __int16 v41 = a1 + 48;
        uint32x2_t v42 = a1[48];
        do
        {
          unsigned int v43 = *(_DWORD *)(*(void *)&v42 + 28);
          BOOL v44 = v43 >= 0x300;
          if (v43 >= 0x300) {
            __int16 v45 = (uint32x2_t *)v42;
          }
          else {
            __int16 v45 = (uint32x2_t *)(*(void *)&v42 + 8);
          }
          if (v44) {
            __int16 v41 = (uint32x2_t *)v42;
          }
          uint32x2_t v42 = *v45;
        }
        while (*v45);
        if (v41 != v20 && v41[3].i32[1] <= 0x300u)
        {
          sub_10073F0A0((uint64_t)a1, 0x300u, 0);
          uint32x2_t v19 = *v20;
        }
        if (v19)
        {
          int v46 = a1 + 48;
          do
          {
            unsigned int v47 = *(_DWORD *)(*(void *)&v19 + 28);
            BOOL v48 = v47 >= 0x400;
            if (v47 >= 0x400) {
              __int16 v49 = (uint32x2_t *)v19;
            }
            else {
              __int16 v49 = (uint32x2_t *)(*(void *)&v19 + 8);
            }
            if (v48) {
              int v46 = (uint32x2_t *)v19;
            }
            uint32x2_t v19 = *v49;
          }
          while (*v49);
          if (v46 != v20 && v46[3].i32[1] <= 0x400u) {
            sub_10073F0A0((uint64_t)a1, 0x400u, 0);
          }
        }
      }
      a1[35].i8[2] = 0;
      return sub_10003AFB4((uint64_t)v51);
    }
LABEL_70:
    int v35 = qword_100A19E58;
    if (!os_log_type_enabled((os_log_t)qword_100A19E58, OS_LOG_TYPE_DEFAULT)) {
      return sub_10003AFB4((uint64_t)v51);
    }
    __int16 v36 = sub_1004D8E04(&v52);
    *(_DWORD *)uint64_t buf = 136315394;
    double v55 = *(double *)&v36;
    __int16 v56 = 1024;
    LODWORD(v57) = a5;
    unsigned __int8 v37 = "Bandwidth: A2DP event %s, not counted as bandwidth. BTResult %d";
    goto LABEL_74;
  }
  if (a3 == 1)
  {
    if ((a4 - 11) < 2) {
      return sub_10003AFB4((uint64_t)v51);
    }
    if (!a5 && a4 == 101)
    {
      if (qword_1009FB058 != -1) {
        dispatch_once(&qword_1009FB058, &stru_1009C1208);
      }
      uint64_t v10 = sub_100512018((uint64_t)off_1009FB050, a2);
      if (v10)
      {
        int v11 = sub_10027677C(v10 + 400);
        uint64_t v12 = qword_100A19E58;
        if (os_log_type_enabled((os_log_t)qword_100A19E58, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)uint64_t buf = 134217984;
          double v55 = (double)v11 * 0.625;
          _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "Bandwidth: HFP Connection has a transmission rate of %fMS", buf, 0xCu);
        }
        if (v11 == 12) {
          int v13 = 512;
        }
        else {
          int v13 = 256;
        }
        if (v11 <= 12) {
          unsigned int v14 = v13;
        }
        else {
          unsigned int v14 = 2560;
        }
        sub_10073F0A0((uint64_t)a1, v14, 1);
      }
      else
      {
        sub_10073F0A0((uint64_t)a1, 0x100u, 1);
        unint64_t v39 = qword_100A19E58;
        if (os_log_type_enabled((os_log_t)qword_100A19E58, OS_LOG_TYPE_ERROR))
        {
          if (a2)
          {
            sub_100474E18(a2, buf);
            sub_10079B258();
          }
          else
          {
            sub_10079B214((uint64_t)v60, v39, v40);
          }
        }
      }
      return sub_10003AFB4((uint64_t)v51);
    }
    if (!a5 && a4 == 102)
    {
      uint64_t v27 = 0;
      __int16 v28 = a1 + 48;
      do
      {
        BOOL v29 = (uint32x2_t *)*v28;
        if (*v28)
        {
          unsigned int v30 = dword_1007C0848[v27];
          BOOL v31 = a1 + 48;
          do
          {
            unsigned int v32 = v29[3].u32[1];
            BOOL v33 = v32 >= v30;
            if (v32 >= v30) {
              char v34 = (uint32x2_t **)v29;
            }
            else {
              char v34 = (uint32x2_t **)&v29[1];
            }
            if (v33) {
              BOOL v31 = v29;
            }
            BOOL v29 = *v34;
          }
          while (*v34);
          if (v31 != v28 && v30 >= v31[3].i32[1]) {
            sub_10073F0A0((uint64_t)a1, v30, 0);
          }
        }
        ++v27;
      }
      while (v27 != 3);
      return sub_10003AFB4((uint64_t)v51);
    }
    int v35 = qword_100A19E58;
    if (!os_log_type_enabled((os_log_t)qword_100A19E58, OS_LOG_TYPE_DEFAULT)) {
      return sub_10003AFB4((uint64_t)v51);
    }
    uint64_t v38 = sub_1004D8E04(&v52);
    *(_DWORD *)uint64_t buf = 136315394;
    double v55 = *(double *)&v38;
    __int16 v56 = 1024;
    LODWORD(v57) = a5;
    unsigned __int8 v37 = "Bandwidth: HFP event %s, not counted as bandwidth. BTResult %d";
LABEL_74:
    _os_log_impl((void *)&_mh_execute_header, v35, OS_LOG_TYPE_DEFAULT, v37, buf, 0x12u);
    return sub_10003AFB4((uint64_t)v51);
  }
  uint64_t v16 = qword_100A19E58;
  if (os_log_type_enabled((os_log_t)qword_100A19E58, OS_LOG_TYPE_ERROR))
  {
    uint64_t v17 = sub_1004D8BE8(&v53);
    uint64_t v18 = sub_1004D8E04(&v52);
    *(_DWORD *)uint64_t buf = 136315650;
    double v55 = *(double *)&v17;
    __int16 v56 = 2080;
    int v57 = v18;
    __int16 v58 = 1024;
    int v59 = a5;
    _os_log_error_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_ERROR, "Bandwidth: No matching bandwidth item for serviceID %s, eventID %s, BTResult %d", buf, 0x1Cu);
  }
  return sub_10003AFB4((uint64_t)v51);
}

void sub_10073FADC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_10003AFB4((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_10073FB18(uint64_t a1, uint64_t a2, int a3, int a4)
{
  v17[0] = 0;
  v17[1] = 0;
  sub_10003AED0((uint64_t)v17, a1 + 80);
  if (a3 == 0x10000)
  {
    if (a4 == 802)
    {
      if (*(unsigned char *)(a1 + 283))
      {
        *(unsigned char *)(a1 + 283) = 0;
        unsigned int v11 = *(_DWORD *)(a1 + 316);
        if (v11 == 1280 || v11 == 1792 || v11 == 1536)
        {
          sub_10073F0A0(a1, v11, 0);
        }
        else if (os_log_type_enabled((os_log_t)qword_100A19E58, OS_LOG_TYPE_ERROR))
        {
          sub_10004BDF8();
          sub_10079B31C();
        }
      }
    }
    else if (a4 == 801 && !*(unsigned char *)(a1 + 283))
    {
      if (qword_1009F7F20 != -1) {
        dispatch_once(&qword_1009F7F20, &stru_1009C1228);
      }
      unsigned int v7 = sub_10058202C(qword_1009F7F18);
      uint64_t v8 = qword_100A19E58;
      if (os_log_type_enabled((os_log_t)qword_100A19E58, OS_LOG_TYPE_DEFAULT))
      {
        sub_10004BDF8();
        uint64_t v9 = v16 >= 0 ? &__p : (void **)__p;
        *(_DWORD *)uint64_t buf = 136315394;
        uint32x2_t v19 = v9;
        __int16 v20 = 2048;
        double v21 = (double)v7 * 1.25;
        _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "Bandwidth: LEA Streaming Connection for device %s, connectionInterval %fms", buf, 0x16u);
        if (v16 < 0) {
          operator delete(__p);
        }
      }
      if (v7 != 3)
      {
        if (v7 == 6)
        {
          unsigned int v10 = 1792;
          goto LABEL_28;
        }
        if (v7 == 4)
        {
          unsigned int v10 = 1536;
LABEL_28:
          sub_10073F0A0(a1, v10, 1);
          *(unsigned char *)(a1 + 283) = 1;
          goto LABEL_29;
        }
        if (os_log_type_enabled((os_log_t)qword_100A19E58, OS_LOG_TYPE_ERROR)) {
          sub_10079B2E8();
        }
      }
      unsigned int v10 = 1280;
      goto LABEL_28;
    }
  }
LABEL_29:
  uint64_t v12 = sub_1004AF8EC();
  v14[0] = _NSConcreteStackBlock;
  v14[1] = 3221225472;
  v14[2] = sub_10073FDDC;
  v14[3] = &unk_100997528;
  void v14[4] = a1;
  sub_100013018(v12, v14);
  return sub_10003AFB4((uint64_t)v17);
}

void sub_10073FDB4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  sub_10003AFB4((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_10073FDDC(uint64_t a1)
{
  return sub_10073A198(*(uint32x2_t **)(a1 + 32));
}

uint64_t sub_10073FDE4(uint64_t a1, void *a2, int a3, int a4)
{
  v25[0] = 0;
  v25[1] = 0;
  sub_10003AED0((uint64_t)v25, a1 + 80);
  if (a2)
  {
    if (a4)
    {
      if (a3)
      {
        uint64_t v8 = *(void **)(a1 + 336);
        if (!v8) {
          goto LABEL_15;
        }
        uint64_t v9 = (void *)(a1 + 336);
        do
        {
          unint64_t v10 = v8[4];
          BOOL v11 = v10 >= (unint64_t)a2;
          if (v10 >= (unint64_t)a2) {
            uint64_t v12 = v8;
          }
          else {
            uint64_t v12 = v8 + 1;
          }
          if (v11) {
            uint64_t v9 = v8;
          }
          uint64_t v8 = (void *)*v12;
        }
        while (*v12);
        if (v9 != (void *)(a1 + 336) && v9[4] <= (unint64_t)a2)
        {
          if (*((_DWORD *)v9 + 10) == a3) {
            return sub_10003AFB4((uint64_t)v25);
          }
          *((_DWORD *)v9 + 10) = a3;
        }
        else
        {
LABEL_15:
          __p[0] = a2;
          LODWORD(__p[1]) = a3;
          sub_100742310((uint64_t **)(a1 + 328), (unint64_t *)__p, __p);
        }
        goto LABEL_38;
      }
      uint64_t v18 = qword_100A19E58;
      if (os_log_type_enabled((os_log_t)qword_100A19E58, OS_LOG_TYPE_DEFAULT))
      {
        sub_100475EE0((uint64_t)a2, (uint64_t)__p);
        uint32x2_t v19 = v24 >= 0 ? __p : (void **)__p[0];
        *(_DWORD *)uint64_t buf = 136315138;
        uint64_t v27 = v19;
        _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "Bandwidth: Not adding Classic Connection %s to Classic Connection Map, waiting on an update", buf, 0xCu);
        if (v24 < 0) {
          operator delete(__p[0]);
        }
      }
    }
    else
    {
      int v13 = *(void **)(a1 + 336);
      if (v13)
      {
        unsigned int v14 = (uint64_t *)(a1 + 336);
        do
        {
          unint64_t v15 = v13[4];
          BOOL v16 = v15 >= (unint64_t)a2;
          if (v15 >= (unint64_t)a2) {
            uint64_t v17 = v13;
          }
          else {
            uint64_t v17 = v13 + 1;
          }
          if (v16) {
            unsigned int v14 = v13;
          }
          int v13 = (void *)*v17;
        }
        while (*v17);
        if (v14 != (uint64_t *)(a1 + 336) && v14[4] <= (unint64_t)a2)
        {
          sub_10004D3B8((uint64_t **)(a1 + 328), v14);
          operator delete(v14);
LABEL_38:
          if (a3 <= 24)
          {
            *(unsigned char *)(a1 + 284) = 1;
            uint64_t v20 = sub_1004AF8EC();
            v22[0] = _NSConcreteStackBlock;
            v22[1] = 3221225472;
            void v22[2] = sub_100740068;
            v22[3] = &unk_100997528;
            v22[4] = a1;
            sub_100013018(v20, v22);
          }
        }
      }
    }
  }
  else if (os_log_type_enabled((os_log_t)qword_100A19E58, OS_LOG_TYPE_ERROR))
  {
    sub_10079B378();
  }
  return sub_10003AFB4((uint64_t)v25);
}

void sub_100740044(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  sub_10003AFB4((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_100740068(uint64_t a1)
{
  return sub_10073A198(*(uint32x2_t **)(a1 + 32));
}

void sub_100740070(uint64_t a1, void *a2, int a3, int a4)
{
  id v7 = a2;
  v25[0] = 0;
  v25[1] = 0;
  sub_10003AED0((uint64_t)v25, a1 + 80);
  if (v7)
  {
    if (qword_1009F7EE0 != -1) {
      dispatch_once(&qword_1009F7EE0, &stru_1009C1248);
    }
    uint64_t v8 = (void *)sub_100030DCC((uint64_t)off_1009F7ED8, v7, 0);
    if (a4)
    {
      if (a3)
      {
        uint64_t v9 = *(void **)(a1 + 360);
        if (!v9) {
          goto LABEL_17;
        }
        unint64_t v10 = (void *)(a1 + 360);
        do
        {
          unint64_t v11 = v9[4];
          BOOL v12 = v11 >= (unint64_t)v8;
          if (v11 >= (unint64_t)v8) {
            int v13 = v9;
          }
          else {
            int v13 = v9 + 1;
          }
          if (v12) {
            unint64_t v10 = v9;
          }
          uint64_t v9 = (void *)*v13;
        }
        while (*v13);
        if (v10 != (void *)(a1 + 360) && (unint64_t)v8 >= v10[4])
        {
          if (*((_DWORD *)v10 + 10) == a3) {
            goto LABEL_42;
          }
          *((_DWORD *)v10 + 10) = a3;
        }
        else
        {
LABEL_17:
          __p[0] = v8;
          LODWORD(__p[1]) = a3;
          sub_100742310((uint64_t **)(a1 + 352), (unint64_t *)__p, __p);
        }
        goto LABEL_40;
      }
      uint32x2_t v19 = qword_100A19E58;
      if (os_log_type_enabled((os_log_t)qword_100A19E58, OS_LOG_TYPE_DEFAULT))
      {
        sub_10004BDF8();
        uint64_t v20 = v24 >= 0 ? __p : (void **)__p[0];
        *(_DWORD *)uint64_t buf = 136315138;
        uint64_t v27 = v20;
        _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "Bandwidth: Not adding Le Connection %s to Le Connection Map, waiting on an update", buf, 0xCu);
        if (v24 < 0) {
          operator delete(__p[0]);
        }
      }
    }
    else
    {
      unsigned int v14 = *(void **)(a1 + 360);
      if (v14)
      {
        unint64_t v15 = (uint64_t *)(a1 + 360);
        do
        {
          unint64_t v16 = v14[4];
          BOOL v17 = v16 >= (unint64_t)v8;
          if (v16 >= (unint64_t)v8) {
            uint64_t v18 = v14;
          }
          else {
            uint64_t v18 = v14 + 1;
          }
          if (v17) {
            unint64_t v15 = v14;
          }
          unsigned int v14 = (void *)*v18;
        }
        while (*v18);
        if (v15 != (uint64_t *)(a1 + 360) && (unint64_t)v8 >= v15[4])
        {
          sub_10004D3B8((uint64_t **)(a1 + 352), v15);
          operator delete(v15);
LABEL_40:
          if (a3 <= 12)
          {
            *(unsigned char *)(a1 + 284) = 1;
            uint64_t v21 = sub_1004AF8EC();
            v22[0] = _NSConcreteStackBlock;
            v22[1] = 3221225472;
            void v22[2] = sub_100740350;
            v22[3] = &unk_100997528;
            v22[4] = a1;
            sub_100013018(v21, v22);
          }
        }
      }
    }
  }
  else if (os_log_type_enabled((os_log_t)qword_100A19E58, OS_LOG_TYPE_ERROR))
  {
    sub_10079B3AC();
  }
LABEL_42:
  sub_10003AFB4((uint64_t)v25);
}

void sub_100740320(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  sub_10003AFB4((uint64_t)va);

  _Unwind_Resume(a1);
}

uint64_t sub_100740350(uint64_t a1)
{
  return sub_10073A198(*(uint32x2_t **)(a1 + 32));
}

void sub_100740358(uint32x2_t *a1)
{
  a1[38] = 0;
  a1[39].i32[0] = 0;
  a1[37].i32[0] = 0;
  a1[36].i32[0] -= a1[36].i32[1];
  unsigned int v2 = qword_100A19E58;
  if (os_log_type_enabled((os_log_t)qword_100A19E58, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Bandwidth: Calculating all non audio connections", buf, 2u);
  }
  unint64_t v3 = (uint32x2_t *)a1[44];
  if (v3 == &a1[45])
  {
    __int32 v4 = 0;
  }
  else
  {
    __int32 v4 = 0;
    do
    {
      int v5 = v3[5].i32[0];
      if (v5 > 8)
      {
        if (v5 == 9)
        {
          uint64_t v9 = qword_100A19E58;
          if (os_log_type_enabled((os_log_t)qword_100A19E58, OS_LOG_TYPE_DEFAULT))
          {
            sub_10004BDF8();
            unint64_t v10 = buf;
            if (v40 < 0) {
              unint64_t v10 = *(uint8_t **)buf;
            }
            double v11 = (double)v3[5].i32[0] * 1.25;
            *(_DWORD *)__int16 v41 = 136315394;
            uint32x2_t v42 = v10;
            __int16 v43 = 2048;
            double v44 = v11;
            _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "Bandwidth: Le Connection %s with interval %fms logged", v41, 0x16u);
            if (v40 < 0) {
              operator delete(*(void **)buf);
            }
          }
          v4 += 128;
          ++a1[38].i32[1];
        }
        else
        {
          BOOL v12 = qword_100A19E58;
          BOOL v13 = os_log_type_enabled((os_log_t)qword_100A19E58, OS_LOG_TYPE_DEFAULT);
          if (v5 < 0xD)
          {
            if (v13)
            {
              sub_10004BDF8();
              unint64_t v16 = buf;
              if (v40 < 0) {
                unint64_t v16 = *(uint8_t **)buf;
              }
              double v17 = (double)v3[5].i32[0] * 1.25;
              *(_DWORD *)__int16 v41 = 136315394;
              uint32x2_t v42 = v16;
              __int16 v43 = 2048;
              double v44 = v17;
              _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "Bandwidth: Le Connection %s with interval %fms logged", v41, 0x16u);
              if (v40 < 0) {
                operator delete(*(void **)buf);
              }
            }
            v4 += 42;
            ++a1[39].i32[0];
          }
          else if (v13)
          {
            sub_10004BDF8();
            unsigned int v14 = buf;
            if (v40 < 0) {
              unsigned int v14 = *(uint8_t **)buf;
            }
            double v15 = (double)v3[5].i32[0] * 1.25;
            *(_DWORD *)__int16 v41 = 136315394;
            uint32x2_t v42 = v14;
            __int16 v43 = 2048;
            double v44 = v15;
            _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "Warning: Bandwidth: Le connection %s with interval %fms, has a greater interval than 15ms.  Not counting as bandwidth", v41, 0x16u);
            if (v40 < 0) {
              operator delete(*(void **)buf);
            }
          }
        }
      }
      else
      {
        uint64_t v6 = qword_100A19E58;
        if (os_log_type_enabled((os_log_t)qword_100A19E58, OS_LOG_TYPE_DEFAULT))
        {
          sub_10004BDF8();
          id v7 = buf;
          if (v40 < 0) {
            id v7 = *(uint8_t **)buf;
          }
          double v8 = (double)v3[5].i32[0] * 1.25;
          *(_DWORD *)__int16 v41 = 136315394;
          uint32x2_t v42 = v7;
          __int16 v43 = 2048;
          double v44 = v8;
          _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "Bandwidth: Le Connection %s with interval %fms logged", v41, 0x16u);
          if (v40 < 0) {
            operator delete(*(void **)buf);
          }
        }
        v4 += 170;
        ++a1[38].i32[0];
      }
      uint64_t v18 = (uint32x2_t *)v3[1];
      if (v18)
      {
        do
        {
          uint32x2_t v19 = v18;
          uint64_t v18 = (uint32x2_t *)*v18;
        }
        while (v18);
      }
      else
      {
        do
        {
          uint32x2_t v19 = (uint32x2_t *)v3[2];
          BOOL v20 = *v19 == (void)v3;
          unint64_t v3 = v19;
        }
        while (!v20);
      }
      unint64_t v3 = v19;
    }
    while (v19 != &a1[45]);
  }
  uint64_t v21 = (uint32x2_t *)a1[41];
  if (v21 != &a1[42])
  {
    do
    {
      int v22 = v21[5].i32[0];
      if (v22 > 17)
      {
        if (v22 == 18)
        {
          unsigned int v26 = qword_100A19E58;
          if (os_log_type_enabled((os_log_t)qword_100A19E58, OS_LOG_TYPE_DEFAULT))
          {
            sub_100475EE0(*(void *)&v21[4], (uint64_t)buf);
            double v27 = (double)v21[5].i32[0];
            __int16 v28 = v40 >= 0 ? buf : *(uint8_t **)buf;
            *(_DWORD *)__int16 v41 = 136315394;
            uint32x2_t v42 = v28;
            __int16 v43 = 2048;
            double v44 = v27 * 0.625;
            _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "Bandwidth: Classic Connection %s with interval %fms logged", v41, 0x16u);
            if (v40 < 0) {
              operator delete(*(void **)buf);
            }
          }
          v4 += 128;
          ++a1[38].i32[1];
        }
        else
        {
          BOOL v29 = qword_100A19E58;
          BOOL v30 = os_log_type_enabled((os_log_t)qword_100A19E58, OS_LOG_TYPE_DEFAULT);
          if (v22 < 0x19)
          {
            if (v30)
            {
              sub_100475EE0(*(void *)&v21[4], (uint64_t)buf);
              double v33 = (double)v21[5].i32[0];
              char v34 = v40 >= 0 ? buf : *(uint8_t **)buf;
              *(_DWORD *)__int16 v41 = 136315394;
              uint32x2_t v42 = v34;
              __int16 v43 = 2048;
              double v44 = v33 * 0.625;
              _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEFAULT, "Bandwidth: Classic Connection %s with interval %fms logged", v41, 0x16u);
              if (v40 < 0) {
                operator delete(*(void **)buf);
              }
            }
            v4 += 42;
            ++a1[39].i32[0];
          }
          else if (v30)
          {
            sub_100475EE0(*(void *)&v21[4], (uint64_t)buf);
            double v31 = (double)v21[5].i32[0];
            unsigned int v32 = v40 >= 0 ? buf : *(uint8_t **)buf;
            *(_DWORD *)__int16 v41 = 136315394;
            uint32x2_t v42 = v32;
            __int16 v43 = 2048;
            double v44 = v31 * 0.625;
            _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEFAULT, "Warning: Bandwidth: Classic Connection %s with interval %fms, has a greater interval than 15ms.  Not counting as bandwidth", v41, 0x16u);
            if (v40 < 0) {
              operator delete(*(void **)buf);
            }
          }
        }
      }
      else
      {
        unsigned int v23 = qword_100A19E58;
        if (os_log_type_enabled((os_log_t)qword_100A19E58, OS_LOG_TYPE_DEFAULT))
        {
          sub_100475EE0(*(void *)&v21[4], (uint64_t)buf);
          double v24 = (double)v21[5].i32[0];
          int v25 = v40 >= 0 ? buf : *(uint8_t **)buf;
          *(_DWORD *)__int16 v41 = 136315394;
          uint32x2_t v42 = v25;
          __int16 v43 = 2048;
          double v44 = v24 * 0.625;
          _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "Bandwidth: Classic Connection %s with interval %fms logged", v41, 0x16u);
          if (v40 < 0) {
            operator delete(*(void **)buf);
          }
        }
        v4 += 170;
        ++a1[38].i32[0];
      }
      int v35 = (uint32x2_t *)v21[1];
      if (v35)
      {
        do
        {
          __int16 v36 = v35;
          int v35 = (uint32x2_t *)*v35;
        }
        while (v35);
      }
      else
      {
        do
        {
          __int16 v36 = (uint32x2_t *)v21[2];
          BOOL v20 = *v36 == (void)v21;
          uint64_t v21 = v36;
        }
        while (!v20);
      }
      uint64_t v21 = v36;
    }
    while (v36 != &a1[42]);
  }
  a1[36].i32[0] += v4;
  a1[36].i32[1] = v4;
  uint32x2_t v37 = vmin_u32(a1[38], (uint32x2_t)0x300000003);
  a1[38] = v37;
  unsigned int v38 = a1[39].u32[0];
  if (v38 >= 3) {
    unsigned int v38 = 3;
  }
  a1[39].i32[0] = v38;
  if (v37.i32[0]) {
    a1[37].i32[0] |= v37.i32[0] << 20;
  }
  if (v37.i32[1]) {
    a1[37].i32[0] |= v37.i32[1] << 22;
  }
  if (v38) {
    a1[37].i32[0] |= v38 << 24;
  }
  a1[35].i8[4] = 0;
}

void sub_100740A24(uint64_t a1, unsigned int a2)
{
  __int32 v4 = qword_100A19E58;
  if (os_log_type_enabled((os_log_t)qword_100A19E58, OS_LOG_TYPE_DEFAULT))
  {
    v6[0] = 67109120;
    v6[1] = a2;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Sending Desense State %d WCM", (uint8_t *)v6, 8u);
  }
  xpc_object_t v5 = xpc_dictionary_create(0, 0, 0);
  xpc_dictionary_set_uint64(v5, "kWCMBTUSBDesenseState", a2);
  sub_10073A58C(a1, 0x204uLL, v5);
  xpc_release(v5);
}

void sub_100740B10(uint64_t a1, uint64_t a2, unsigned int a3)
{
  xpc_object_t v6 = xpc_dictionary_create(0, 0, 0);
  xpc_dictionary_set_uint64(v6, "kWCMBTMetricsReport_Classic_RSSI", *(__int16 *)(a2 + 16));
  xpc_dictionary_set_uint64(v6, "kWCMBTMetricsReport_LE_RSSI", *(__int16 *)(a2 + 18));
  xpc_dictionary_set_uint64(v6, "kWCMBTMetricsReportLeSuccessfulTxCount", *(unsigned __int16 *)(a2 + 21));
  xpc_dictionary_set_uint64(v6, "kWCMBTMetricsReportLeReTxCount", *(unsigned __int16 *)(a2 + 23));
  xpc_dictionary_set_uint64(v6, "kWCMBTMetricsReportLeSuccessfulRxCount", *(unsigned __int16 *)(a2 + 25));
  xpc_dictionary_set_uint64(v6, "kWCMBTMetricsReportLeRxErrorCount", *(unsigned __int16 *)(a2 + 27));
  xpc_dictionary_set_uint64(v6, "kWCMBTMetricsReportClassicSuccessfulTxCount", *(unsigned __int16 *)(a2 + 30));
  xpc_dictionary_set_uint64(v6, "kWCMBTMetricsReportClassicReTxCount", *(unsigned __int16 *)(a2 + 32));
  xpc_dictionary_set_uint64(v6, "kWCMBTMetricsReportClassicSuccessfulRxCount", *(unsigned __int16 *)(a2 + 34));
  xpc_dictionary_set_uint64(v6, "kWCMBTMetricsReportClassicRxErrorCount", *(unsigned __int16 *)(a2 + 36));
  xpc_dictionary_set_uint64(v6, "kWCMBTMetricsReportLeCoexDenialCount", *(unsigned __int16 *)(a2 + 12));
  xpc_dictionary_set_uint64(v6, "kWCMBTMetricsReportClassicCoexDenialCount", *(unsigned __int16 *)(a2 + 14));
  xpc_dictionary_set_uint64(v6, "kWCMBTMetricsReport_flushCount", a3);
  if (*(unsigned char *)(a2 + 29)) {
    uint64_t v7 = 2;
  }
  else {
    uint64_t v7 = 1;
  }
  xpc_dictionary_set_uint64(v6, "kWCMBTMetricsReport_Active_PHY", v7);
  sub_10073A58C(a1, 0x200uLL, v6);

  xpc_release(v6);
}

void sub_100740C98(uint64_t a1, unsigned int a2, unsigned int a3)
{
  xpc_object_t v6 = qword_100A19E58;
  if (os_log_type_enabled((os_log_t)qword_100A19E58, OS_LOG_TYPE_DEFAULT))
  {
    v8[0] = 67109376;
    v8[1] = a2;
    __int16 v9 = 1024;
    unsigned int v10 = a3;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "sendPhyReport: %d, %d", (uint8_t *)v8, 0xEu);
  }
  xpc_object_t v7 = xpc_dictionary_create(0, 0, 0);
  xpc_dictionary_set_uint64(v7, "kWCMBTPhyReport_LE_PHY_RATE", a3);
  xpc_dictionary_set_uint64(v7, "kWCMBTPhyReport_CLASSIC_PHY_RATE", a2);
  sub_10073A58C(a1, 0x201uLL, v7);
  xpc_release(v7);
}

void sub_100740DA8(uint32x2_t *a1, unsigned __int8 *a2, unsigned int a3, int a4, int a5)
{
  uint64_t v8 = (uint64_t)a2;
  if (a2) {
    a2 = (unsigned __int8 *)(((unint64_t)a2[128] << 40) | ((unint64_t)a2[129] << 32) | ((unint64_t)a2[130] << 24) | ((unint64_t)a2[131] << 16) | ((unint64_t)a2[132] << 8) | a2[133]);
  }
  if (a4 > 109)
  {
    if (a4 > 200)
    {
      if (a4 != 201)
      {
        if (a4 == 202)
        {
          uint64_t v10 = 2;
          int v11 = a3;
          int v12 = 202;
          goto LABEL_15;
        }
LABEL_31:
        if ((a4 - 3) > 0xFFFFFFFD) {
          return;
        }
        goto LABEL_26;
      }
      uint64_t v10 = 2;
      int v11 = a3;
      int v12 = 201;
    }
    else if (a4 == 110)
    {
      uint64_t v10 = 4;
      int v11 = a3;
      int v12 = 110;
    }
    else
    {
      if (a4 != 111) {
        goto LABEL_31;
      }
      uint64_t v10 = 4;
      int v11 = a3;
      int v12 = 111;
    }
LABEL_24:
    int v13 = a5;
    unsigned int v14 = 1;
    goto LABEL_25;
  }
  if ((a4 - 11) >= 2)
  {
    if (a4 != 101)
    {
      if (a4 == 102)
      {
        uint64_t v10 = 1;
        int v11 = a3;
        int v12 = 102;
LABEL_15:
        int v13 = a5;
        unsigned int v14 = 0;
LABEL_25:
        sub_10073E9A0((uint64_t)a1, (unint64_t)a2, v10, v11, v12, v13, v14);
        goto LABEL_26;
      }
      goto LABEL_31;
    }
    uint64_t v10 = 1;
    int v11 = a3;
    int v12 = 101;
    goto LABEL_24;
  }
  sub_10073E59C((uint64_t)a1, (unint64_t)a2, a3, a4, a5);
  if (!v8 || a3 != 32)
  {
LABEL_26:
    if (a3 == 16 || a3 == 1)
    {
      sub_10073F534(a1, v8, a3, a4, a5);
    }
    return;
  }
  uint64_t v15 = sub_100487D44(v8);
  unint64_t v16 = *(void (**)(uint32x2_t *, uint64_t, uint64_t, BOOL))(*(void *)a1 + 72);

  v16(a1, v8, v15, a4 == 11);
}

void sub_100740FC8(uint64_t a1, unsigned __int8 *a2, unsigned int a3, int a4, int a5)
{
}

void sub_100740FD0(id a1)
{
  CFStringRef v4 = @"NUMBER_OF_LE_CONNECTIONS";
  if (qword_1009F8158 != -1) {
    dispatch_once(&qword_1009F8158, &stru_1009C1168);
  }
  uint64_t v1 = +[NSNumber numberWithInt:*((unsigned int *)off_1009F8150 + 40)];
  xpc_object_t v5 = v1;
  unsigned int v2 = +[NSDictionary dictionaryWithObjects:&v5 forKeys:&v4 count:1];

  unint64_t v3 = +[NSNotificationCenter defaultCenter];
  [v3 postNotificationName:@"com.apple.bluetooth.leconnection" object:0 userInfo:v2];
}

void sub_1007410D8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100741108(uint64_t a1, void *a2, int a3)
{
  id v5 = a2;
  uint64_t v6 = sub_1004AF8EC();
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 3221225472;
  _DWORD v8[2] = sub_1007411DC;
  v8[3] = &unk_100999A10;
  uint64_t v10 = a1;
  id v7 = v5;
  id v9 = v7;
  int v11 = a3;
  sub_100013018(v6, v8);
}

void sub_1007411BC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{
  _Unwind_Resume(a1);
}

uint64_t sub_1007411DC(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 40);
  if (qword_1009F7EE0 != -1) {
    dispatch_once(&qword_1009F7EE0, &stru_1009C1248);
  }
  unint64_t v3 = sub_100030DCC((uint64_t)off_1009F7ED8, *(void **)(a1 + 32), 0);
  sub_10073E59C(v2, v3, 0x8000u, 0xBu, *(_DWORD *)(a1 + 48));
  uint64_t v4 = sub_1004AF8EC();
  sub_100013018(v4, &stru_1009C10E8);
  if (qword_1009F7EC0 != -1) {
    dispatch_once(&qword_1009F7EC0, &stru_1009C1148);
  }
  id v5 = off_1009F7EB8;
  sub_1000305AC(v8, *(void *)(a1 + 32));
  uint64_t v6 = sub_10068640C((uint64_t)v5, v8);
  return (*(uint64_t (**)(uint64_t, void, uint64_t, uint64_t))(*(void *)v2 + 88))(v2, *(void *)(a1 + 32), v6, 1);
}

void sub_10074131C(uint64_t a1, void *a2, int a3)
{
}

void sub_100741324(uint64_t a1, void *a2, int a3)
{
  id v5 = a2;
  uint64_t v6 = sub_1004AF8EC();
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 3221225472;
  _DWORD v8[2] = sub_1007413F8;
  v8[3] = &unk_100999A10;
  uint64_t v10 = a1;
  id v7 = v5;
  id v9 = v7;
  int v11 = a3;
  sub_100013018(v6, v8);
}

void sub_1007413D8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{
  _Unwind_Resume(a1);
}

uint64_t sub_1007413F8(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 40);
  if (qword_1009F7EE0 != -1) {
    dispatch_once(&qword_1009F7EE0, &stru_1009C1248);
  }
  unint64_t v3 = sub_100030DCC((uint64_t)off_1009F7ED8, *(void **)(a1 + 32), 0);
  sub_10073E59C(v2, v3, 0x8000u, 0xCu, *(_DWORD *)(a1 + 48));
  uint64_t v4 = sub_1004AF8EC();
  sub_100013018(v4, &stru_1009C10E8);
  uint64_t v5 = *(void *)(a1 + 32);
  uint64_t v6 = *(uint64_t (**)(uint64_t, uint64_t, void, void))(*(void *)v2 + 88);

  return v6(v2, v5, 0, 0);
}

void sub_1007414C0(uint64_t a1, void *a2, int a3)
{
}

void sub_1007414C8(uint64_t a1, unint64_t a2, unsigned int a3, int a4)
{
  unint64_t v5 = a2;
  uint64_t v6 = a1;
  if (a4 == 4)
  {
    if (a3) {
      int v10 = 803;
    }
    else {
      int v10 = 804;
    }
    uint64_t v8 = 4;
    int v9 = 0x400000;
  }
  else
  {
    if (a4 != 3) {
      return;
    }
    if (a3) {
      int v7 = 801;
    }
    else {
      int v7 = 802;
    }
    sub_10073FB18(a1, a2, 0x10000, v7);
    a1 = v6;
    a2 = v5;
    uint64_t v8 = 3;
    int v9 = 0x10000;
    int v10 = v7;
  }

  sub_10073E9A0(a1, a2, v8, v9, v10, 0, a3);
}

void sub_100741584(uint64_t a1, unint64_t a2, unsigned int a3, int a4)
{
}

void sub_100741590(uint64_t a1)
{
}

uint64_t sub_100741598(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(void *)(result + 452) = a2;
  *(void *)(result + 460) = a3;
  return result;
}

uint64_t sub_1007415A4(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(void *)(result + 404) = a2;
  *(void *)(result + 412) = a3;
  return result;
}

uint64_t **sub_1007415B8(uint64_t a1, unsigned int a2, unsigned int a3)
{
  unsigned int v14 = a2;
  xpc_object_t v6 = xpc_dictionary_create(0, 0, 0);
  xpc_dictionary_set_int64(v6, "kWCMBTLeDiscoveryScan_State", a3);
  xpc_dictionary_set_int64(v6, "kWCMBTLeDiscoveryScan_UseCase", 1);
  int v7 = qword_100A19E58;
  if (os_log_type_enabled((os_log_t)qword_100A19E58, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v8 = sub_10003F3D0(a2);
    int v9 = "false";
    if (a3) {
      int v9 = "true";
    }
    *(_DWORD *)uint64_t buf = 136315394;
    unint64_t v16 = v8;
    __int16 v17 = 2080;
    uint64_t v18 = v9;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "Sending Notification to WiFi for CBUseCase %s Scanning Started %s", buf, 0x16u);
  }
  sub_10073A58C(a1, 0x206uLL, v6);
  uint64_t result = (uint64_t **)(a1 + 400);
  int v11 = *(uint64_t **)(a1 + 408);
  if (a3)
  {
    for (; v11; int v11 = (uint64_t *)*v11)
    {
      unsigned int v12 = *((_DWORD *)v11 + 7);
      if (v12 <= a2)
      {
        if (v12 >= a2) {
          return result;
        }
        ++v11;
      }
    }
    return sub_100036BE4(result, &v14, &v14);
  }
  else
  {
    while (v11)
    {
      unsigned int v13 = *((_DWORD *)v11 + 7);
      if (v13 <= a2)
      {
        if (v13 >= a2) {
          return (uint64_t **)sub_10074249C((uint64_t)result, &v14);
        }
        ++v11;
      }
      int v11 = (uint64_t *)*v11;
    }
  }
  return result;
}

uint64_t **sub_100741918(uint64_t a1, unsigned int a2, unsigned int a3)
{
  return sub_1007415B8(a1 - 64, a2, a3);
}

void sub_100741920(uint64_t a1)
{
  uint64_t v2 = qword_100A19E58;
  if (os_log_type_enabled((os_log_t)qword_100A19E58, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string __p = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "statedump: ------------------ Coex Manager -------------------", __p, 2u);
    uint64_t v2 = qword_100A19E58;
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    sub_10001A260(a1 + 452);
    if (v6 >= 0) {
      unint64_t v3 = __p;
    }
    else {
      unint64_t v3 = *(unsigned char **)__p;
    }
    *(_DWORD *)uint64_t buf = 136446210;
    uint64_t v8 = v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "statedump: %{public}s", buf, 0xCu);
    if (v6 < 0) {
      operator delete(*(void **)__p);
    }
    uint64_t v2 = qword_100A19E58;
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v4 = "Enabled";
    if (!*(unsigned char *)(a1 + 448)) {
      uint64_t v4 = "Disabled";
    }
    *(_DWORD *)std::string __p = 136446210;
    *(void *)&__p[4] = v4;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "statedump: Grant RC2 State: %{public}s", __p, 0xCu);
  }
}

char *sub_100741AB8(uint64_t a1, char *__src, char *a3)
{
  unint64_t v3 = a3;
  uint64_t v4 = __src;
  char v6 = *(char **)(a1 + 8);
  uint64_t v8 = a1 + 16;
  unint64_t v7 = *(void *)(a1 + 16);
  if ((unint64_t)v6 >= v7)
  {
    unsigned int v13 = *(char **)a1;
    unint64_t v14 = ((uint64_t)&v6[-*(void *)a1] >> 3) + 1;
    if (v14 >> 61) {
      abort();
    }
    uint64_t v15 = __src - v13;
    uint64_t v16 = (__src - v13) >> 3;
    uint64_t v17 = v7 - (void)v13;
    if (v17 >> 2 > v14) {
      unint64_t v14 = v17 >> 2;
    }
    if ((unint64_t)v17 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v18 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v18 = v14;
    }
    uint64_t v30 = a1 + 16;
    if (v18) {
      uint32x2_t v19 = (char *)sub_1000405F8(a1 + 16, v18);
    }
    else {
      uint32x2_t v19 = 0;
    }
    BOOL v20 = &v19[8 * v16];
    std::string __p = v19;
    double v27 = v20;
    __int16 v28 = v20;
    BOOL v29 = &v19[8 * v18];
    if (v16 == v18)
    {
      if (v15 < 1)
      {
        if (v13 == v4) {
          unint64_t v22 = 1;
        }
        else {
          unint64_t v22 = v15 >> 2;
        }
        unsigned int v23 = (char *)sub_1000405F8(v8, v22);
        BOOL v20 = &v23[8 * (v22 >> 2)];
        std::string __p = v23;
        double v27 = v20;
        BOOL v29 = &v23[8 * v24];
        if (v19) {
          operator delete(v19);
        }
      }
      else
      {
        unint64_t v21 = v16 + 2;
        if (v16 >= -1) {
          unint64_t v21 = v16 + 1;
        }
        v20 -= 8 * (v21 >> 1);
        double v27 = v20;
      }
    }
    *(void *)BOOL v20 = *(void *)v3;
    __int16 v28 = v20 + 8;
    uint64_t v4 = sub_100061614((void **)a1, (uint64_t)&__p, v4);
    if (v28 != v27) {
      v28 += (v27 - v28 + 7) & 0xFFFFFFFFFFFFFFF8;
    }
    if (__p) {
      operator delete(__p);
    }
  }
  else if (__src == v6)
  {
    *(void *)__src = *(void *)a3;
    *(void *)(a1 + 8) = __src + 8;
  }
  else
  {
    int v9 = __src + 8;
    int v10 = v6 - 8;
    int v11 = *(void **)(a1 + 8);
    while (v10 < v6)
    {
      uint64_t v12 = *(void *)v10;
      v10 += 8;
      *v11++ = v12;
    }
    *(void *)(a1 + 8) = v11;
    if (v6 != v9) {
      memmove(&v6[-8 * ((v6 - v9) >> 3)], __src, v6 - v9);
    }
    if (v4 <= v3) {
      v3 += 8 * (*(void *)(a1 + 8) > (unint64_t)v3);
    }
    *(void *)uint64_t v4 = *(void *)v3;
  }
  return v4;
}

void sub_100741CC0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100741CF8(id a1)
{
}

void sub_100741D3C()
{
}

void sub_100741D60(id a1)
{
}

void sub_100741DA4()
{
}

void sub_100741DC8(id a1)
{
}

void sub_100741E0C()
{
}

void sub_100741E30(id a1)
{
}

void sub_100741FC0()
{
}

void sub_100741FE4(id a1)
{
}

void sub_100742028()
{
}

void sub_10074204C(id a1)
{
}

void sub_100742090()
{
}

void sub_1007420B4(id a1)
{
}

void sub_1007420F8()
{
}

void sub_10074211C(id a1)
{
}

void sub_100742160()
{
}

uint64_t *sub_100742184(uint64_t **a1, unsigned int *a2, uint64_t *a3)
{
  char v6 = a1 + 1;
  unint64_t v5 = a1[1];
  if (v5)
  {
    unsigned int v7 = *a2;
    while (1)
    {
      while (1)
      {
        uint64_t v8 = (uint64_t **)v5;
        unsigned int v9 = *((_DWORD *)v5 + 7);
        if (v7 >= v9) {
          break;
        }
        unint64_t v5 = *v8;
        char v6 = v8;
        if (!*v8) {
          goto LABEL_10;
        }
      }
      if (v9 >= v7) {
        break;
      }
      unint64_t v5 = v8[1];
      if (!v5)
      {
        char v6 = v8 + 1;
        goto LABEL_10;
      }
    }
  }
  else
  {
    uint64_t v8 = a1 + 1;
LABEL_10:
    int v10 = (uint64_t *)operator new(0x28uLL);
    *(uint64_t *)((char *)v10 + 28) = *a3;
    sub_100036CA0(a1, (uint64_t)v8, v6, v10);
    return v10;
  }
  return (uint64_t *)v8;
}

void sub_100742240(id a1)
{
}

void sub_100742284()
{
}

void sub_1007422A8(id a1)
{
}

void sub_1007422EC()
{
}

uint64_t **sub_100742310(uint64_t **a1, unint64_t *a2, _OWORD *a3)
{
  char v6 = a1 + 1;
  unint64_t v5 = a1[1];
  if (v5)
  {
    unint64_t v7 = *a2;
    while (1)
    {
      while (1)
      {
        uint64_t v8 = (uint64_t **)v5;
        unint64_t v9 = v5[4];
        if (v7 >= v9) {
          break;
        }
        unint64_t v5 = *v8;
        char v6 = v8;
        if (!*v8) {
          goto LABEL_10;
        }
      }
      if (v9 >= v7) {
        break;
      }
      unint64_t v5 = v8[1];
      if (!v5)
      {
        char v6 = v8 + 1;
        goto LABEL_10;
      }
    }
  }
  else
  {
    uint64_t v8 = a1 + 1;
LABEL_10:
    int v10 = (uint64_t *)operator new(0x30uLL);
    *((_OWORD *)v10 + 2) = *a3;
    sub_100036CA0(a1, (uint64_t)v8, v6, v10);
    return (uint64_t **)v10;
  }
  return v8;
}

void sub_1007423CC(id a1)
{
}

void sub_100742410()
{
}

void sub_100742434(id a1)
{
}

void sub_100742478()
{
}

uint64_t sub_10074249C(uint64_t a1, unsigned int *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  if (!v2) {
    return 0;
  }
  unsigned int v3 = *a2;
  uint64_t v4 = a1 + 8;
  do
  {
    unsigned int v5 = *(_DWORD *)(v2 + 28);
    BOOL v6 = v5 >= v3;
    if (v5 >= v3) {
      unint64_t v7 = (uint64_t *)v2;
    }
    else {
      unint64_t v7 = (uint64_t *)(v2 + 8);
    }
    if (v6) {
      uint64_t v4 = v2;
    }
    uint64_t v2 = *v7;
  }
  while (*v7);
  if (v4 == a1 + 8 || v3 < *(_DWORD *)(v4 + 28)) {
    return 0;
  }
  sub_10004D3B8((uint64_t **)a1, (uint64_t *)v4);
  operator delete((void *)v4);
  return 1;
}

uint64_t sub_100742518(uint64_t a1)
{
  *(void *)(a1 + 16) = v3;
  if (*(char *)(a1 + 111) < 0) {
    operator delete(*(void **)(a1 + 88));
  }
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  std::ios::~ios();
  return a1;
}

uint64_t sub_100742650(uint64_t result)
{
  *(unsigned char *)(result + 24) = 0;
  return result;
}

ctu::TextConverter *ctu::TextConverter::TextConverter(ctu::TextConverter *this)
{
  uint64_t v2 = operator new(0x38uLL);
  v2[2] = 0;
  *((void *)v2 + 2) = 0;
  *((unsigned char *)v2 + 24) = 0;
  *(void *)uint64_t v2 = &off_1009C1740;
  *((void *)v2 + 5) = 0;
  *((void *)v2 + 6) = 0;
  *((void *)v2 + 4) = 0;
  *(void *)this = v2;
  *((void *)this + 1) = v2;
  return this;
}

void ctu::TextConverter::~TextConverter(ctu::TextConverter *this)
{
  uint64_t v2 = *(void **)this;
  if (v2)
  {
    do
    {
      *(void *)this = v2[2];
      (*(void (**)(void *))(*v2 + 8))(v2);
      uint64_t v2 = *(void **)this;
    }
    while (*(void *)this);
  }
}

uint64_t ctu::TextConverter::setSource(uint64_t this, const char *a2, int a3)
{
  uint64_t v3 = *(void *)(this + 8);
  *(_DWORD *)(v3 + 8) = a3;
  *(void *)(v3 + 32) = a2;
  *(void *)(v3 + 40) = 0;
  *(void *)(v3 + 48) = a3;
  uint64_t v4 = *(void **)this;
  if (*(void *)this)
  {
    do
    {
      this = (*(uint64_t (**)(void *))(*v4 + 24))(v4);
      uint64_t v4 = (void *)v4[2];
    }
    while (v4);
  }
  return this;
}

_DWORD *ctu::TextConverter::pushConversion(void *a1, int a2, int a3, int a4, int a5)
{
  switch(a2)
  {
    case 0:
      uint64_t result = operator new(0x28uLL);
      unint64_t v9 = (_DWORD *)*a1;
      result[2] = 0;
      *((void *)result + 2) = v9;
      *((unsigned char *)result + 24) = 0;
      int v10 = &off_1009C1330;
      goto LABEL_25;
    case 1:
      uint64_t result = operator new(0x20uLL);
      int v11 = (_DWORD *)*a1;
      result[2] = 0;
      *((void *)result + 2) = v11;
      *((unsigned char *)result + 24) = 0;
      uint64_t v12 = &off_1009C1360;
      goto LABEL_29;
    case 2:
      uint64_t result = operator new(0x20uLL);
      unsigned int v13 = (_DWORD *)*a1;
      result[2] = 0;
      *((void *)result + 2) = v13;
      *((unsigned char *)result + 24) = 0;
      uint64_t v12 = &off_1009C1390;
      goto LABEL_29;
    case 3:
      uint64_t result = operator new(0x40uLL);
      unint64_t v14 = (_DWORD *)*a1;
      result[2] = 0;
      *((void *)result + 2) = v14;
      *((unsigned char *)result + 24) = 0;
      *(void *)uint64_t result = &off_1009C13C0;
      result[13] = 0;
      result[14] = 0;
      goto LABEL_30;
    case 4:
      uint64_t result = operator new(0x28uLL);
      uint64_t v15 = (_DWORD *)*a1;
      result[2] = 0;
      *((void *)result + 2) = v15;
      *((unsigned char *)result + 24) = 0;
      *(void *)uint64_t result = &off_1009C1420;
      result[7] = 0;
      result[8] = 0;
      result[9] = (7 - a3) % 7;
      goto LABEL_30;
    case 5:
      uint64_t result = operator new(0x30uLL);
      uint64_t v16 = (_DWORD *)*a1;
      result[2] = 0;
      *((void *)result + 2) = v16;
      *((unsigned char *)result + 24) = 0;
      *(void *)uint64_t result = &off_1009C13F0;
      result[7] = a3;
      *((void *)result + 4) = 0;
      goto LABEL_23;
    case 6:
      uint64_t result = operator new(0x30uLL);
      uint64_t v17 = (_DWORD *)*a1;
      result[2] = 0;
      *((void *)result + 2) = v17;
      *((unsigned char *)result + 24) = 0;
      result[7] = a3;
      *((void *)result + 4) = 0;
      *((_WORD *)result + 20) = 0;
      uint64_t v12 = &off_1009C1450;
      goto LABEL_29;
    case 7:
      uint64_t result = operator new(0x28uLL);
      unint64_t v18 = (_DWORD *)*a1;
      result[2] = 0;
      *((void *)result + 2) = v18;
      *((unsigned char *)result + 24) = 0;
      *(void *)uint64_t result = &off_1009C1570;
      result[7] = -1;
      result[8] = a3;
      goto LABEL_30;
    case 8:
      uint64_t result = operator new(0x28uLL);
      BOOL v20 = (_DWORD *)*a1;
      result[2] = 0;
      *((void *)result + 2) = v20;
      *((unsigned char *)result + 24) = 0;
      *(void *)uint64_t result = &off_1009C15A0;
      result[7] = a3;
      result[8] = a5;
      goto LABEL_30;
    case 9:
      uint64_t result = operator new(0x20uLL);
      unint64_t v21 = (_DWORD *)*a1;
      result[2] = 0;
      *((void *)result + 2) = v21;
      *((unsigned char *)result + 24) = 0;
      uint64_t v12 = &off_1009C1650;
      goto LABEL_29;
    case 10:
      uint64_t result = operator new(0x30uLL);
      unint64_t v22 = (_DWORD *)*a1;
      result[2] = 0;
      *((void *)result + 2) = v22;
      *((unsigned char *)result + 24) = 0;
      *(void *)uint64_t result = &off_1009C1680;
      *((void *)result + 4) = 0;
      result[10] = 0;
      goto LABEL_30;
    case 11:
      uint64_t result = operator new(0x20uLL);
      unsigned int v23 = (_DWORD *)*a1;
      result[2] = 0;
      *((void *)result + 2) = v23;
      *((unsigned char *)result + 24) = 0;
      uint64_t v24 = &off_1009C16B0;
      goto LABEL_16;
    case 12:
      uint64_t result = operator new(0x20uLL);
      int v25 = (_DWORD *)*a1;
      result[2] = 0;
      *((void *)result + 2) = v25;
      *((unsigned char *)result + 24) = 0;
      uint64_t v24 = &off_1009C16E0;
LABEL_16:
      *(void *)uint64_t result = v24;
      *((_WORD *)result + 13) = a3;
      goto LABEL_30;
    case 13:
      uint64_t result = operator new(0x20uLL);
      unsigned int v26 = (_DWORD *)*a1;
      result[2] = 0;
      *((void *)result + 2) = v26;
      *((unsigned char *)result + 24) = 0;
      uint64_t v12 = &off_1009C1620;
      goto LABEL_29;
    case 14:
      uint64_t result = operator new(0x20uLL);
      double v27 = (_DWORD *)*a1;
      result[2] = 0;
      *((void *)result + 2) = v27;
      *((unsigned char *)result + 24) = 0;
      uint64_t v12 = &off_1009C1710;
      goto LABEL_29;
    case 15:
      uint64_t result = operator new(0x30uLL);
      __int16 v28 = (_DWORD *)*a1;
      result[2] = 0;
      *((void *)result + 2) = v28;
      *((unsigned char *)result + 24) = 0;
      *(void *)uint64_t result = &off_1009C1480;
      result[7] = 0;
      result[8] = 0;
      if (a3 <= 0) {
        int v29 = -(-a3 & 7);
      }
      else {
        int v29 = a3 & 7;
      }
      result[9] = v29;
LABEL_23:
      *((unsigned char *)result + 40) = 0;
      goto LABEL_30;
    case 16:
      uint64_t result = operator new(0x28uLL);
      uint64_t v30 = (_DWORD *)*a1;
      result[2] = 0;
      *((void *)result + 2) = v30;
      *((unsigned char *)result + 24) = 0;
      int v10 = &off_1009C14B0;
LABEL_25:
      *(void *)uint64_t result = v10;
      result[7] = 0;
      result[8] = 0;
      goto LABEL_30;
    case 17:
      uint64_t result = operator new(0x20uLL);
      double v31 = (_DWORD *)*a1;
      result[2] = 0;
      *((void *)result + 2) = v31;
      *((unsigned char *)result + 24) = 0;
      uint64_t v12 = &off_1009C14E0;
      goto LABEL_29;
    case 18:
      uint64_t result = operator new(0x20uLL);
      unsigned int v32 = (_DWORD *)*a1;
      result[2] = 0;
      *((void *)result + 2) = v32;
      *((unsigned char *)result + 24) = 0;
      uint64_t v12 = &off_1009C1510;
      goto LABEL_29;
    case 19:
      uint64_t result = operator new(0x20uLL);
      double v33 = (_DWORD *)*a1;
      result[2] = 0;
      *((void *)result + 2) = v33;
      *((unsigned char *)result + 24) = 0;
      uint64_t v12 = &off_1009C1540;
LABEL_29:
      *(void *)uint64_t result = v12;
LABEL_30:
      *a1 = result;
      break;
    default:
      uint64_t result = (_DWORD *)*a1;
      break;
  }
  result[2] = a4;
  return result;
}

void ctu::TextConverter::readChars(ctu::TextConverter *this@<X0>, uint64_t a2@<X1>, std::string *a3@<X8>)
{
  a3->__r_.__value_.__r.__words[0] = 0;
  a3->__r_.__value_.__l.__size_ = 0;
  a3->__r_.__value_.__r.__words[2] = 0;
  if (a2)
  {
    uint64_t v3 = a2;
    do
    {
      int v6 = (*(uint64_t (**)(void))(**(void **)this + 16))();
      if (v6 == -1) {
        break;
      }
      std::string::push_back(a3, v6);
      --v3;
    }
    while (v3);
  }
}

void sub_100742D78(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100742D94(uint64_t a1)
{
  int v1 = *(_DWORD *)(a1 + 8);
  if (!v1) {
    return 0xFFFFFFFFLL;
  }
  *(_DWORD *)(a1 + 8) = v1 - 1;
  uint64_t result = *(unsigned int *)(a1 + 28);
  if (result == -1) {
    return result;
  }
  int v4 = *(_DWORD *)(a1 + 32);
  if (v4)
  {
    *(_DWORD *)(a1 + 32) = v4 - 1;
    if (v4 != 2) {
      return a0123456789abcd_2[result & 0xF];
    }
  }
  else
  {
    uint64_t result = (*(uint64_t (**)(void))(**(void **)(a1 + 16) + 16))(*(void *)(a1 + 16));
    *(_DWORD *)(a1 + 28) = result;
    if (result == -1) {
      return result;
    }
    *(_DWORD *)(a1 + 32) = 1;
  }
  LODWORD(result) = result >> 4;
  return a0123456789abcd_2[result & 0xF];
}

uint64_t sub_100742E44(uint64_t result)
{
  *(_DWORD *)(result + 28) = 0;
  *(_DWORD *)(result + 32) = 0;
  *(unsigned char *)(result + 24) = 0;
  return result;
}

uint64_t sub_100742E50(uint64_t a1)
{
  int v1 = *(_DWORD *)(a1 + 8);
  if (!v1) {
    return 0xFFFFFFFFLL;
  }
  *(_DWORD *)(a1 + 8) = v1 - 1;
  int v3 = (*(uint64_t (**)(void))(**(void **)(a1 + 16) + 16))(*(void *)(a1 + 16));
  int v4 = (*(uint64_t (**)(void))(**(void **)(a1 + 16) + 16))(*(void *)(a1 + 16));
  if (v3 == -1 || v4 == -1) {
    return 0xFFFFFFFFLL;
  }
  if (v3 - 65 >= 6) {
    int v7 = 0;
  }
  else {
    int v7 = (char)v3 - 55;
  }
  if (v3 - 97 <= 5) {
    int v7 = (char)v3 - 87;
  }
  if (v3 - 48 <= 9) {
    int v7 = (char)v3 - 48;
  }
  int v8 = 16 * v7;
  if (v4 - 65 >= 6) {
    int v9 = 0;
  }
  else {
    int v9 = (char)v4 - 55;
  }
  if (v4 - 97 <= 5) {
    int v9 = (char)v4 - 87;
  }
  if (v4 - 48 <= 9) {
    int v9 = (char)v4 - 48;
  }
  return v9 | v8;
}

uint64_t sub_100742F60(uint64_t a1)
{
  int v1 = *(_DWORD *)(a1 + 8);
  if (!v1) {
    return 0xFFFFFFFFLL;
  }
  *(_DWORD *)(a1 + 8) = v1 - 1;
  uint64_t v3 = (*(uint64_t (**)(void))(**(void **)(a1 + 16) + 16))(*(void *)(a1 + 16));
  uint64_t v4 = v3;
  if (v3 != -1 && (v3 & 0x80) != 0)
  {
    if ((v3 & 0x20) == 0)
    {
      int v5 = (*(uint64_t (**)(void))(**(void **)(a1 + 16) + 16))(*(void *)(a1 + 16));
      if (v5 == -1) {
        return 0xFFFFFFFFLL;
      }
      else {
        return v5 & 0x3F | ((v4 & 0x1F) << 6);
      }
    }
    if ((v3 & 0x10) == 0)
    {
      int v6 = (*(uint64_t (**)(void))(**(void **)(a1 + 16) + 16))(*(void *)(a1 + 16));
      int v7 = (*(uint64_t (**)(void))(**(void **)(a1 + 16) + 16))(*(void *)(a1 + 16));
      if (v6 != -1 && v7 != -1) {
        return ((v4 & 0xF) << 12) | ((v6 & 0x3F) << 6) | v7 & 0x3F;
      }
      return 0xFFFFFFFFLL;
    }
    if ((v3 & 8) != 0)
    {
      if ((v3 & 4) != 0)
      {
        if ((v3 & 2) != 0) {
          return 0;
        }
        int v21 = (*(uint64_t (**)(void))(**(void **)(a1 + 16) + 16))(*(void *)(a1 + 16));
        int v22 = (*(uint64_t (**)(void))(**(void **)(a1 + 16) + 16))(*(void *)(a1 + 16));
        int v23 = (*(uint64_t (**)(void))(**(void **)(a1 + 16) + 16))(*(void *)(a1 + 16));
        int v24 = (*(uint64_t (**)(void))(**(void **)(a1 + 16) + 16))(*(void *)(a1 + 16));
        int v11 = (*(uint64_t (**)(void))(**(void **)(a1 + 16) + 16))(*(void *)(a1 + 16));
        if (v21 == -1 || v22 == -1 || v23 == -1 || v24 == -1 || v11 == -1) {
          return 0xFFFFFFFFLL;
        }
        int v14 = ((v4 & 1) << 30) | ((v21 & 0x3F) << 24) | ((v22 & 0x3F) << 18) | ((v23 & 0x3F) << 12) | ((v24 & 0x3F) << 6);
      }
      else
      {
        int v15 = (*(uint64_t (**)(void))(**(void **)(a1 + 16) + 16))(*(void *)(a1 + 16));
        int v16 = (*(uint64_t (**)(void))(**(void **)(a1 + 16) + 16))(*(void *)(a1 + 16));
        int v17 = (*(uint64_t (**)(void))(**(void **)(a1 + 16) + 16))(*(void *)(a1 + 16));
        int v11 = (*(uint64_t (**)(void))(**(void **)(a1 + 16) + 16))(*(void *)(a1 + 16));
        if (v15 == -1 || v16 == -1 || v17 == -1 || v11 == -1) {
          return 0xFFFFFFFFLL;
        }
        int v14 = ((v4 & 3) << 24) | ((v15 & 0x3F) << 18) | ((v16 & 0x3F) << 12) | ((v17 & 0x3F) << 6);
      }
    }
    else
    {
      int v9 = (*(uint64_t (**)(void))(**(void **)(a1 + 16) + 16))(*(void *)(a1 + 16));
      int v10 = (*(uint64_t (**)(void))(**(void **)(a1 + 16) + 16))(*(void *)(a1 + 16));
      int v11 = (*(uint64_t (**)(void))(**(void **)(a1 + 16) + 16))(*(void *)(a1 + 16));
      if (v9 == -1 || v10 == -1 || v11 == -1) {
        return 0xFFFFFFFFLL;
      }
      int v14 = ((v4 & 7) << 18) | ((v9 & 0x3F) << 12) | ((v10 & 0x3F) << 6);
    }
    unsigned int v30 = v14 & 0xFFFFFFC0 | v11 & 0x3F;
    int v31 = v30 - 0x10000;
    unsigned int v32 = v30 - 64513;
    if (v31 >= 0) {
      unsigned int v32 = v31;
    }
    return ((v32 >> 10 << 16) - 671088640) | (v31 - (v32 & 0xFFFFFC00) + 56320);
  }
  return v4;
}

uint64_t sub_10074335C(uint64_t a1)
{
  int v1 = *(_DWORD *)(a1 + 8);
  if (!v1) {
    return 0xFFFFFFFFLL;
  }
  *(_DWORD *)(a1 + 8) = v1 - 1;
  int v3 = *(_DWORD *)(a1 + 52);
  if (*(_DWORD *)(a1 + 56) == v3)
  {
    uint64_t result = (*(uint64_t (**)(void))(**(void **)(a1 + 16) + 16))(*(void *)(a1 + 16));
    if (result == -1) {
      return result;
    }
    unsigned int v5 = ((result >> 6) & 0x3FFFC00) + (unsigned __int16)result - 56613888;
    if (result >> 26 != 54) {
      unsigned int v5 = result;
    }
    if ((v5 & 0x7C000000) != 0)
    {
      *(int8x16_t *)(a1 + 28) = vorrq_s8(vandq_s8((int8x16_t)vshlq_u32((uint32x4_t)vdupq_n_s32(v5), (uint32x4_t)xmmword_1007C08B0), (int8x16_t)xmmword_1007C08C0), (int8x16_t)xmmword_1007C08D0);
      *(_DWORD *)(a1 + 44) = (v5 >> 6) & 0x3F | 0x80;
      *(_DWORD *)(a1 + 48) = v5 & 0x3F | 0x80;
      int v6 = 6;
    }
    else if ((v5 & 0x3E00000) != 0)
    {
      *(int8x16_t *)(a1 + 28) = vorrq_s8(vandq_s8((int8x16_t)vshlq_u32((uint32x4_t)vdupq_n_s32(v5), (uint32x4_t)xmmword_1007C08E0), (int8x16_t)xmmword_1007C08F0), (int8x16_t)xmmword_1007C0900);
      *(_DWORD *)(a1 + 44) = v5 & 0x3F | 0x80;
      int v6 = 5;
    }
    else if ((v5 & 0x1F0000) != 0)
    {
      *(int8x8_t *)(a1 + 28) = vorr_s8(vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v5), (uint32x2_t)0xFFFFFFF4FFFFFFEELL), (int8x8_t)0x3F00000007), (int8x8_t)0x80000000F0);
      *(_DWORD *)(a1 + 36) = (v5 >> 6) & 0x3F | 0x80;
      *(_DWORD *)(a1 + 40) = v5 & 0x3F | 0x80;
      int v6 = 4;
    }
    else if ((v5 & 0xF800) != 0)
    {
      *(int8x8_t *)(a1 + 28) = vorr_s8(vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v5), (uint32x2_t)0xFFFFFFFAFFFFFFF4), (int8x8_t)0x3F0000000FLL), (int8x8_t)0x80000000E0);
      *(_DWORD *)(a1 + 36) = v5 & 0x3F | 0x80;
      int v6 = 3;
    }
    else if ((v5 & 0xFF80) != 0)
    {
      *(_DWORD *)(a1 + 28) = (v5 >> 6) & 0x1F | 0xC0;
      *(_DWORD *)(a1 + 32) = v5 & 0x3F | 0x80;
      int v6 = 2;
    }
    else
    {
      *(_DWORD *)(a1 + 28) = (char)v5;
      int v6 = 1;
    }
    int v3 = 0;
    *(_DWORD *)(a1 + 56) = v6;
  }
  *(_DWORD *)(a1 + 52) = v3 + 1;
  return *(unsigned int *)(a1 + 4 * v3 + 28);
}

uint64_t sub_10074356C(uint64_t result)
{
  *(_DWORD *)(result + 52) = 0;
  *(_DWORD *)(result + 56) = 0;
  *(unsigned char *)(result + 24) = 0;
  return result;
}

uint64_t sub_100743578(uint64_t a1)
{
  int v1 = *(_DWORD *)(a1 + 8);
  if (!v1) {
    return 0xFFFFFFFFLL;
  }
  *(_DWORD *)(a1 + 8) = v1 - 1;
  if (*(unsigned char *)(a1 + 40))
  {
    int v3 = *(_DWORD *)(a1 + 36);
    goto LABEL_8;
  }
  if (!*(_DWORD *)(a1 + 28))
  {
    int v4 = (*(uint64_t (**)(void))(**(void **)(a1 + 16) + 16))(*(void *)(a1 + 16));
    *(_DWORD *)(a1 + 32) = v4;
    if (v4 != -1) {
      goto LABEL_7;
    }
    return 0xFFFFFFFFLL;
  }
  *(_DWORD *)(a1 + 32) = 0;
LABEL_7:
  int v3 = (*(uint64_t (**)(void))(**(void **)(a1 + 16) + 16))(*(void *)(a1 + 16));
  *(_DWORD *)(a1 + 36) = v3;
  *(unsigned char *)(a1 + 40) = 1;
LABEL_8:
  int v5 = *(_DWORD *)(a1 + 32);
  if (v5 == -1 && v3 == -1) {
    return 0xFFFFFFFFLL;
  }
  int v7 = *(_DWORD *)(a1 + 28);
  int v8 = v5 >> v7;
  int v9 = (v3 << (7 - v7));
  if (v3 == -1) {
    int v9 = 0;
  }
  uint64_t v10 = v9 | v8;
  *(_DWORD *)(a1 + 28) = v7 + 1;
  if (v7 == 6)
  {
    *(_DWORD *)(a1 + 28) = 0;
    int v11 = (*(uint64_t (**)(void))(**(void **)(a1 + 16) + 16))(*(void *)(a1 + 16));
    *(_DWORD *)(a1 + 32) = v11;
    if (v11 == -1) {
      goto LABEL_20;
    }
    goto LABEL_19;
  }
  *(_DWORD *)(a1 + 32) = v3;
  if (v3 != -1)
  {
LABEL_19:
    int v11 = (*(uint64_t (**)(void))(**(void **)(a1 + 16) + 16))(*(void *)(a1 + 16));
LABEL_20:
    *(_DWORD *)(a1 + 36) = v11;
  }
  return v10;
}

uint64_t sub_1007436F4(uint64_t result)
{
  *(unsigned char *)(result + 24) = 0;
  *(void *)(result + 28) = 0;
  *(void *)(result + 33) = 0;
  return result;
}

uint64_t sub_100743704(uint64_t a1)
{
  int v1 = *(_DWORD *)(a1 + 8);
  if (!v1) {
    return 0xFFFFFFFFLL;
  }
  *(_DWORD *)(a1 + 8) = v1 - 1;
  int v3 = *(_DWORD *)(a1 + 32);
  if (v3 >= 7)
  {
    int v6 = *(_DWORD *)(a1 + 28);
LABEL_10:
    uint64_t result = v6 & 0x7F;
    *(_DWORD *)(a1 + 28) = v6 >> 7;
    *(_DWORD *)(a1 + 32) = v3 - 7;
  }
  else
  {
    while (1)
    {
      uint64_t result = (*(uint64_t (**)(void))(**(void **)(a1 + 16) + 16))(*(void *)(a1 + 16));
      if (result == -1) {
        break;
      }
      int v5 = *(_DWORD *)(a1 + 32);
      int v6 = *(_DWORD *)(a1 + 28) | (result << v5);
      int v3 = v5 + 8;
      *(_DWORD *)(a1 + 28) = v6;
      *(_DWORD *)(a1 + 32) = v3;
      int v7 = *(_DWORD *)(a1 + 36);
      if (v7)
      {
        v6 >>= v7;
        v3 -= v7;
        *(_DWORD *)(a1 + 28) = v6;
        *(void *)(a1 + 32) = v3;
      }
      if (v3 >= 7) {
        goto LABEL_10;
      }
    }
  }
  return result;
}

uint64_t sub_1007437C4(uint64_t result)
{
  *(_DWORD *)(result + 28) = 0;
  *(_DWORD *)(result + 32) = 0;
  *(unsigned char *)(result + 24) = 0;
  return result;
}

uint64_t sub_1007437D0(uint64_t a1)
{
  uint64_t result = sub_100743578(a1);
  if (result != -1)
  {
    if (*(_DWORD *)(a1 + 32) == -1)
    {
      if ((result & 0xFFFFFFFE) == 0x1A && !*(unsigned char *)(a1 + 41)) {
        *(_DWORD *)(a1 + 32) = 13;
      }
    }
    else if (*(_DWORD *)(a1 + 36) == -1 && *(_DWORD *)(a1 + 28) == 6)
    {
      *(_DWORD *)(a1 + 36) = 13;
      *(unsigned char *)(a1 + 41) = 1;
    }
  }
  return result;
}

uint64_t sub_100743850(uint64_t result)
{
  *(unsigned char *)(result + 24) = 0;
  *(void *)(result + 28) = 0;
  *(void *)(result + 33) = 0;
  return result;
}

uint64_t sub_100743860(uint64_t a1)
{
  int v1 = *(_DWORD *)(a1 + 8);
  if (!v1) {
    return 0xFFFFFFFFLL;
  }
  int v3 = v1 - 1;
  *(_DWORD *)(a1 + 8) = v3;
  if (!*(unsigned char *)(a1 + 40) && *(_DWORD *)(a1 + 36))
  {
    if (v3)
    {
      uint64_t result = (*(uint64_t (**)(void))(**(void **)(a1 + 16) + 16))(*(void *)(a1 + 16));
      *(_DWORD *)(a1 + 28) = result;
      if (result == -1) {
        return result;
      }
      *(_DWORD *)(a1 + 32) = 8 - *(_DWORD *)(a1 + 36);
      goto LABEL_3;
    }
    return 0xFFFFFFFFLL;
  }
LABEL_3:
  *(unsigned char *)(a1 + 40) = 1;
  int v4 = *(_DWORD *)(a1 + 32);
  if (v4 >= 7)
  {
    int v6 = *(_DWORD *)(a1 + 28);
  }
  else
  {
    uint64_t result = (*(uint64_t (**)(void))(**(void **)(a1 + 16) + 16))(*(void *)(a1 + 16));
    if (result == -1) {
      return result;
    }
    int v4 = *(_DWORD *)(a1 + 32) + 8;
    int v6 = result | (*(_DWORD *)(a1 + 28) << 8);
    *(_DWORD *)(a1 + 28) = v6;
  }
  int v7 = v4 - 7;
  uint64_t result = (v6 >> v7) & 0x7F;
  *(_DWORD *)(a1 + 32) = v7;
  return result;
}

uint64_t sub_100743960(uint64_t result)
{
  *(_DWORD *)(result + 28) = 0;
  *(_DWORD *)(result + 32) = 0;
  *(unsigned char *)(result + 40) = 0;
  *(unsigned char *)(result + 24) = 0;
  return result;
}

uint64_t sub_100743970(uint64_t a1)
{
  int v1 = *(_DWORD *)(a1 + 8);
  if (!v1) {
    return 0xFFFFFFFFLL;
  }
  *(_DWORD *)(a1 + 8) = v1 - 1;
  int v3 = *(_DWORD *)(a1 + 32);
  if (v3 >= 8)
  {
    int v7 = *(_DWORD *)(a1 + 28);
LABEL_8:
    int v9 = v3 - 8;
    uint64_t result = (v7 >> v9);
    *(_DWORD *)(a1 + 32) = v9;
  }
  else
  {
    while (1)
    {
      int v4 = (*(uint64_t (**)(void))(**(void **)(a1 + 16) + 16))(*(void *)(a1 + 16));
      int v5 = *(_DWORD *)(a1 + 28);
      if (v4 == -1) {
        break;
      }
      int v6 = *(_DWORD *)(a1 + 32);
      int v3 = v6 + 7;
      int v7 = v4 & 0x7F | (v5 << 7);
      *(_DWORD *)(a1 + 28) = v7;
      *(_DWORD *)(a1 + 32) = v6 + 7;
      if (v6 >= 1) {
        goto LABEL_8;
      }
    }
    uint64_t result = (v5 << (8 - *(_DWORD *)(a1 + 32)));
    *(_DWORD *)(a1 + 8) = 0;
  }
  return result;
}

uint64_t sub_100743A34(uint64_t result)
{
  *(_DWORD *)(result + 28) = 0;
  *(_DWORD *)(result + 32) = 0;
  *(unsigned char *)(result + 24) = 0;
  return result;
}

uint64_t sub_100743A40(uint64_t a1)
{
  int v1 = *(_DWORD *)(a1 + 8);
  if (!v1) {
    return 0xFFFFFFFFLL;
  }
  *(_DWORD *)(a1 + 8) = v1 - 1;
  uint64_t result = (*(uint64_t (**)(void))(**(void **)(a1 + 16) + 16))(*(void *)(a1 + 16));
  if (result != -1 && result >= 0x80)
  {
    *(unsigned char *)(a1 + 24) = 1;
    return 32;
  }
  return result;
}

uint64_t sub_100743ABC(uint64_t a1)
{
  int v1 = *(_DWORD *)(a1 + 8);
  if (!v1) {
    return 0xFFFFFFFFLL;
  }
  *(_DWORD *)(a1 + 8) = v1 - 1;
  return (*(uint64_t (**)(void))(**(void **)(a1 + 16) + 16))();
}

uint64_t sub_100743AFC(uint64_t a1)
{
  int v1 = *(_DWORD *)(a1 + 8);
  if (!v1) {
    return 0xFFFFFFFFLL;
  }
  *(_DWORD *)(a1 + 8) = v1 - 1;
  return (*(uint64_t (**)(void))(**(void **)(a1 + 16) + 16))();
}

uint64_t sub_100743B3C(uint64_t a1)
{
  int v1 = *(_DWORD *)(a1 + 8);
  if (!v1) {
    return 0xFFFFFFFFLL;
  }
  *(_DWORD *)(a1 + 8) = v1 - 1;
  uint64_t result = *(unsigned int *)(a1 + 28);
  if (result != -1)
  {
    *(_DWORD *)(a1 + 28) = -1;
    return result;
  }
  uint64_t result = (*(uint64_t (**)(void))(**(void **)(a1 + 16) + 16))(*(void *)(a1 + 16));
  if (result != -1)
  {
    if ((result & 0x80000000) == 0)
    {
      unsigned int v4 = *(_DWORD *)(a1 + 32);
      if (result < 0x100 || (result <= 0x17F ? (BOOL v5 = v4 == 2) : (BOOL v5 = 0), v5))
      {
        if (v4 == 3) {
          unsigned int v4 = 0;
        }
        int v7 = (unsigned __int8 *)*(&off_1009C1968 + v4) + result;
      }
      else if ((result - 896) <= 0x4F && v4 == 3)
      {
        int v7 = (unsigned __int8 *)&unk_1007C0EAB + (result - 896);
      }
      else
      {
        if ((result - 912) > 0x1F)
        {
          if (result == 8364)
          {
            LOBYTE(result) = -27;
            goto LABEL_24;
          }
          goto LABEL_28;
        }
        int v7 = (unsigned __int8 *)&unk_1007C0EFB + (result - 912);
      }
      uint64_t result = *v7;
      if (result != 255)
      {
        if ((result & 0x80) != 0)
        {
LABEL_24:
          *(_DWORD *)(a1 + 28) = result & 0x7F;
          return 27;
        }
        return result;
      }
    }
LABEL_28:
    *(unsigned char *)(a1 + 24) = 1;
    return 32;
  }
  return result;
}

uint64_t sub_100743C6C(uint64_t result)
{
  *(_DWORD *)(result + 28) = -1;
  *(unsigned char *)(result + 24) = 0;
  return result;
}

uint64_t sub_100743C7C(uint64_t a1)
{
  do
  {
    int v2 = *(_DWORD *)(a1 + 8);
    if (!v2) {
      return 0xFFFFFFFFLL;
    }
    *(_DWORD *)(a1 + 8) = v2 - 1;
    uint64_t result = (*(uint64_t (**)(void))(**(void **)(a1 + 16) + 16))(*(void *)(a1 + 16));
    if (result == -1) {
      return result;
    }
  }
  while ((result & 0x80) != 0);
  uint64_t v4 = (uint64_t)*(&off_1009C15C0 + *(unsigned int *)(a1 + 32));
  if (result != 27) {
    return *(__int16 *)(v4 + 2 * (int)result);
  }
  uint64_t result = (*(uint64_t (**)(void))(**(void **)(a1 + 16) + 16))(*(void *)(a1 + 16));
  if (result != -1)
  {
    int v5 = (unsigned __int16)off_1009C15E8[*(unsigned int *)(a1 + 28)][(int)result];
    if (v5 == 32) {
      LOWORD(v5) = *(_WORD *)(v4 + 2 * (int)result);
    }
    return (__int16)v5;
  }
  return result;
}

uint64_t sub_100743D60(uint64_t a1)
{
  uint64_t v2 = a1;
  do
  {
    if (*(unsigned char *)(v2 + 24)) {
      return 0xFFFFFFFFLL;
    }
    uint64_t v2 = *(void *)(v2 + 16);
  }
  while (v2);
  int v3 = *(_DWORD *)(a1 + 8);
  if (!v3) {
    return 0xFFFFFFFFLL;
  }
  *(_DWORD *)(a1 + 8) = v3 - 1;
  uint64_t result = (*(uint64_t (**)(void))(**(void **)(a1 + 16) + 16))(*(void *)(a1 + 16));
  if (result != -1 && (result & 0x80) != 0) {
    *(unsigned char *)(a1 + 24) = 1;
  }
  return result;
}

uint64_t sub_100743DE8(uint64_t a1)
{
  int v1 = *(_DWORD *)(a1 + 8);
  if (!v1) {
    return 0xFFFFFFFFLL;
  }
  *(_DWORD *)(a1 + 8) = v1 - 1;
  uint64_t v3 = (*(uint64_t (**)(void))(**(void **)(a1 + 16) + 16))(*(void *)(a1 + 16));
  if (v3 != -1)
  {
    unsigned int v4 = (*(uint64_t (**)(void))(**(void **)(a1 + 16) + 16))(*(void *)(a1 + 16));
    if (v4 == -1) {
      return 0xFFFFFFFFLL;
    }
    uint64_t v3 = v4 | (v3 << 8);
    if (v3 >> 10 == 54)
    {
      int v5 = (*(uint64_t (**)(void))(**(void **)(a1 + 16) + 16))(*(void *)(a1 + 16));
      if (v5 != -1)
      {
        int v6 = v5;
        unsigned int v7 = (*(uint64_t (**)(void))(**(void **)(a1 + 16) + 16))(*(void *)(a1 + 16));
        if (v7 != -1) {
          return (v6 << 8) | (v3 << 16) | v7;
        }
      }
      return 0xFFFFFFFFLL;
    }
  }
  return v3;
}

uint64_t sub_100743F10(uint64_t result)
{
  int v1 = *(_DWORD *)(result + 8);
  if (!v1) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v2 = result;
  *(_DWORD *)(result + 8) = v1 - 1;
  uint64_t v3 = *(void *)(result + 32);
  if (!v3)
  {
    uint64_t result = (*(uint64_t (**)(void))(**(void **)(result + 16) + 16))(*(void *)(result + 16));
    *(_DWORD *)(v2 + 40) = result;
    if (result == -1) {
      return result;
    }
    if (result >> 27 == 27)
    {
      *(void *)(v2 + 32) = 3;
      return BYTE3(result);
    }
    *(void *)(v2 + 32) = 1;
    return BYTE1(result);
  }
  *(void *)(result + 32) = v3 - 1;
  switch(v3)
  {
    case 2:
      LODWORD(result) = *(_DWORD *)(result + 40);
      return BYTE1(result);
    case 3:
      return *(unsigned __int8 *)(result + 42);
    case 4:
      LODWORD(result) = *(_DWORD *)(result + 40);
      return BYTE3(result);
  }
  return *(unsigned __int8 *)(result + 40);
}

uint64_t sub_100743FEC(uint64_t result)
{
  *(void *)(result + 32) = 0;
  *(_DWORD *)(result + 40) = 0;
  *(unsigned char *)(result + 24) = 0;
  return result;
}

uint64_t sub_100743FFC(uint64_t a1)
{
  int v1 = *(_DWORD *)(a1 + 8);
  if (!v1) {
    return 0xFFFFFFFFLL;
  }
  *(_DWORD *)(a1 + 8) = v1 - 1;
  uint64_t result = (*(uint64_t (**)(void))(**(void **)(a1 + 16) + 16))(*(void *)(a1 + 16));
  if (result != -1)
  {
    if ((int)result > 255)
    {
      int v4 = result - *(unsigned __int16 *)(a1 + 26);
      if (v4 >= 128) {
        return 32;
      }
      else {
        return v4 | 0x80u;
      }
    }
    else
    {
      return byte_1007C0940[(int)result];
    }
  }
  return result;
}

uint64_t sub_100744094(uint64_t result)
{
  *(unsigned char *)(result + 24) = 0;
  return result;
}

uint64_t sub_10074409C(uint64_t a1)
{
  int v1 = *(_DWORD *)(a1 + 8);
  if (!v1) {
    return 0xFFFFFFFFLL;
  }
  *(_DWORD *)(a1 + 8) = v1 - 1;
  uint64_t result = (*(uint64_t (**)(void))(**(void **)(a1 + 16) + 16))(*(void *)(a1 + 16));
  if (result == -1) {
    return result;
  }
  if ((int)result > 127) {
    return (result & 0x7F) + *(unsigned __int16 *)(a1 + 26);
  }
  if (result == 27)
  {
    uint64_t result = (*(uint64_t (**)(void))(**(void **)(a1 + 16) + 16))(*(void *)(a1 + 16));
    if (result == -1) {
      return result;
    }
    int v4 = asc_1007C0B40;
  }
  else
  {
    int v4 = (const __int16 *)&unk_1007C0A40;
  }
  return v4[(int)result];
}

uint64_t sub_10074416C(uint64_t result)
{
  *(unsigned char *)(result + 24) = 0;
  return result;
}

uint64_t sub_100744174(uint64_t a1)
{
  int v1 = *(_DWORD *)(a1 + 8);
  if (!v1) {
    return 0xFFFFFFFFLL;
  }
  *(_DWORD *)(a1 + 8) = v1 - 1;
  int v3 = (*(uint64_t (**)(void))(**(void **)(a1 + 16) + 16))(*(void *)(a1 + 16));
  if (v3 == -1) {
    return 0xFFFFFFFFLL;
  }
  char v11 = -86;
  UInt8 bytes = v3;
  if (v3 >= 128)
  {
    int v4 = (*(uint64_t (**)(void))(**(void **)(a1 + 16) + 16))(*(void *)(a1 + 16));
    if (v4 != -1)
    {
      char v11 = v4;
      CFIndex v5 = 2;
      goto LABEL_8;
    }
    return 0xFFFFFFFFLL;
  }
  CFIndex v5 = 1;
LABEL_8:
  CFStringRef v7 = CFStringCreateWithBytes(kCFAllocatorDefault, &bytes, v5, 0x422u, 0);
  if (!v7) {
    return 9633;
  }
  CFStringRef v8 = v7;
  uint64_t CharacterAtIndex = CFStringGetCharacterAtIndex(v7, 0);
  CFRelease(v8);
  return CharacterAtIndex;
}

uint64_t sub_10074427C(uint64_t a1)
{
  int v1 = *(_DWORD *)(a1 + 8);
  if (!v1) {
    return 0xFFFFFFFFLL;
  }
  *(_DWORD *)(a1 + 8) = v1 - 1;
  uint64_t v2 = *(void *)(a1 + 32);
  uint64_t v3 = *(void *)(a1 + 40);
  *(void *)(a1 + 40) = v3 + 1;
  return *(unsigned __int8 *)(v2 + v3);
}

uint64_t sub_1007442A8(uint64_t result)
{
  *(void *)(result + 40) = 0;
  *(unsigned char *)(result + 24) = 0;
  return result;
}

void sub_10074435C()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Sniff/Active mode change ignored, couldn't find device", v2, v3, v4, v5, v6);
}

void sub_100744390()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Enter Advanced Sniff ignored - Couldn't find the connection handle", v2, v3, v4, v5, v6);
}

void sub_1007443C4()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Advanced Sniff mode change ignored, connection invalid", v2, v3, v4, v5, v6);
}

void sub_1007443F8(unsigned __int8 a1, int a2, os_log_t log)
{
  v3[0] = 67109376;
  v3[1] = a2;
  __int16 v4 = 1024;
  int v5 = a1;
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "Advanced Sniff mode change ignored, duplicate mode: %d, maxAge %d", (uint8_t *)v3, 0xEu);
}

void sub_100744484()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Exit Advanced Sniff ignored - Couldn't find device", v2, v3, v4, v5, v6);
}

void sub_1007444B8(unint64_t a1, NSObject *a2)
{
  int v3 = *(unsigned __int8 *)sub_10007DFF4(a1, a1);
  v5[0] = 67109120;
  v5[1] = v3;
  sub_100080510((void *)&_mh_execute_header, a2, v4, "Exit Advanced Sniff ignored, link not in Advanced Sniff, mode :%d", (uint8_t *)v5);
}

void sub_100744544()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Exit Advanced Sniff ignored - Couldn't find the connection handle", v2, v3, v4, v5, v6);
}

void sub_100744578()
{
  sub_1000572E8();
  sub_100080510((void *)&_mh_execute_header, v0, v1, "Exit Advanced Sniff command failed - reason: %d", v2);
}

void sub_1007445E4()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Enter Advanced Sniff ignored - Couldn't find device", v2, v3, v4, v5, v6);
}

void sub_100744618()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Enter Advanced Sniff ignored, link already in AdvancedSniff", v2, v3, v4, v5, v6);
}

void sub_10074464C(unint64_t a1, NSObject *a2)
{
  int v3 = *(unsigned __int8 *)sub_10007DFF4(a1, a1);
  v5[0] = 67109120;
  v5[1] = v3;
  sub_100080510((void *)&_mh_execute_header, a2, v4, "Enter Advanced Sniff fail with link in invalid mode: %d", (uint8_t *)v5);
}

void sub_1007446D8()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Enter Advanced Sniff fail - Couldn't find the connection handle", v2, v3, v4, v5, v6);
}

void sub_10074470C()
{
  sub_1000572E8();
  sub_100080510((void *)&_mh_execute_header, v0, v1, "Advanced Sniff Exit command failed - reason: %d", v2);
}

void sub_100744778()
{
  sub_1000572E8();
  sub_100080510((void *)&_mh_execute_header, v0, v1, "Advanced Sniff Reconfig command failed - reason: %d", v2);
}

void sub_1007447E4()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Advanced Sniff band switch, BSM invalid input device or no device connected", v2, v3, v4, v5, v6);
}

void sub_100744818()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Advanced Sniff band switch, BSM input device and ALM device out of sync", v2, v3, v4, v5, v6);
}

void sub_10074484C()
{
}

void sub_100744868(void *a1)
{
  if (os_log_type_enabled((os_log_t)qword_100A19E50, OS_LOG_TYPE_DEFAULT)) {
    sub_1000823D0((void *)&_mh_execute_header, v2, v3, "%s: No valid serial port found (tried cu.bluetooth and uart.bluetooth)\n", v4, v5, v6, v7, 2u);
  }
  *a1 = "%s: No valid serial port found (tried cu.bluetooth and uart.bluetooth)\n";
}

void sub_100744910(void *a1)
{
  if (os_log_type_enabled((os_log_t)qword_100A19E50, OS_LOG_TYPE_DEFAULT)) {
    sub_1000823D0((void *)&_mh_execute_header, v2, v3, "%s: Not a valid MAC address (all 00s).\n", v4, v5, v6, v7, 2u);
  }
  *a1 = "%s: Not a valid MAC address (all 00s).\n";
}

void sub_1007449B8(int *a1, uint64_t a2, NSObject *a3)
{
  int v3 = *a1;
  *(_DWORD *)a2 = 67109120;
  *(_DWORD *)(a2 + 4) = v3;
  sub_1000823B4((void *)&_mh_execute_header, a2, a3, "### _CS_DARWIN_USER_TEMP_DIR failed: %d", (uint8_t *)a2);
}

void sub_1007449F8(int *a1, uint64_t a2, NSObject *a3)
{
  int v3 = *a1;
  *(_DWORD *)a2 = 67109120;
  *(_DWORD *)(a2 + 4) = v3;
  sub_1000823B4((void *)&_mh_execute_header, a2, a3, "### _set_user_dir_suffix failed: %d", (uint8_t *)a2);
}

void sub_100744A38(uint64_t a1, int a2, NSObject *a3)
{
  *(_DWORD *)a1 = 67109120;
  *(_DWORD *)(a1 + 4) = a2;
  sub_1000823B4((void *)&_mh_execute_header, a2, a3, "Failed to update Dynamic Store. BTLocalDeviceGetModulePower returned %d", (uint8_t *)a1);
}

void sub_100744A74(uint64_t a1, NSObject *a2)
{
  int v2 = 136315138;
  uint64_t v3 = a1;
  _os_log_error_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_ERROR, "Update Dynamic Store failed with error %s", (uint8_t *)&v2, 0xCu);
}

void sub_100744AEC(uint64_t a1, NSObject *a2)
{
  int v2 = 136315138;
  uint64_t v3 = a1;
  _os_log_error_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_ERROR, "%s: Unable to match bluetooth service in device tree.\n", (uint8_t *)&v2, 0xCu);
}

void sub_100744B64(uint64_t a1)
{
  if (*(char *)(a1 + 23) < 0) {
    operator delete(*(void **)a1);
  }
}

void sub_100744B88(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_100744BC0(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_100744BF8(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_1000804F4((void *)&_mh_execute_header, a1, a3, "Adaptive Latency Headset Feedback, Invalid Device return", a5, a6, a7, a8, 0);
}

void sub_100744C30(uint64_t a1, NSObject *a2)
{
  int v2 = *(unsigned __int16 *)(a1 + 32);
  v3[0] = 67109120;
  v3[1] = v2;
  _os_log_error_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_ERROR, "Adaptive Latency Headset DSP critical: %d", (uint8_t *)v3, 8u);
}

void sub_100744CAC(int a1, NSObject *a2)
{
  v2[0] = 67109376;
  v2[1] = 200;
  __int16 v3 = 1024;
  int v4 = a1;
  _os_log_error_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_ERROR, "Failed to initialize the packet flush timeout to %d with error %{bluetooth:OI_STATUS}u", (uint8_t *)v2, 0xEu);
}

void sub_100744D34(uint64_t *a1, NSObject *a2)
{
  uint64_t v2 = *a1;
  int v3 = 134217984;
  uint64_t v4 = v2;
  _os_log_error_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_ERROR, "Updated currentJitterBuffer. invalid device param: %p", (uint8_t *)&v3, 0xCu);
}

void sub_100744DB0(uint64_t a1, NSObject *a2)
{
  int v2 = 138412290;
  uint64_t v3 = a1;
  _os_log_debug_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_DEBUG, "Spatial found device: %@", (uint8_t *)&v2, 0xCu);
}

void sub_100744E28(uint64_t a1, NSObject *a2)
{
  int v2 = 138412290;
  uint64_t v3 = a1;
  _os_log_debug_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_DEBUG, "Spatial found no match device: %@", (uint8_t *)&v2, 0xCu);
}

void sub_100744EA0(uint64_t a1, uint64_t a2, os_log_t log)
{
  int v3 = 138412546;
  uint64_t v4 = a1;
  __int16 v5 = 2080;
  uint64_t v6 = a2;
  _os_log_debug_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_DEBUG, "Spatial lost device: %@ (%s)", (uint8_t *)&v3, 0x16u);
}

void sub_100744F28(os_log_t log)
{
  *(_WORD *)uint64_t v1 = 0;
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "Something went wrong, mismatch detected with spatialInteractionDeviceTimestamp array, removing them", v1, 2u);
}

void sub_100744F6C()
{
  sub_100050714();
  sub_1000DDEEC();
  sub_1000DDF08((void *)&_mh_execute_header, v0, v1, "%{public}s (status=%{bluetooth:OI_STATUS}u)", v2, v3, v4, v5, v6);
}

void sub_100744FE4()
{
  sub_100050714();
  sub_1000DDF08((void *)&_mh_execute_header, v0, v1, "%{public}s (status=%{bluetooth:OI_STATUS}u)", v2, v3, v4, v5, 2u);
}

void sub_100745070()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "applebt_rx_main: Exiting rx thread\n", v2, v3, v4, v5, v6);
}

void sub_1007450A4()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "applebt_rx_main: btdev is NULL or not opened\n", v2, v3, v4, v5, v6);
}

void sub_1007450D8()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "applebt_rx_main: applebt_hci_read DEVICE_ERROR - probably Recovery is in progress\n", v2, v3, v4, v5, v6);
}

void sub_10074510C()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "applebt_rx_main: applebt_hci_read NO_MEMORY - driver not READY, failed to allocate shared memory blocks\n", v2, v3, v4, v5, v6);
}

void sub_100745140()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "applebt_rx_main: applebt_hci_read DEVICE_OFFLINE - device was powered off\n", v2, v3, v4, v5, v6);
}

void sub_100745174()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "applebt_rx_main: applebt_hci_close returned 0x%08X\n", v2, v3, v4, v5, v6);
}

void sub_1007451DC(uint64_t *a1, NSObject *a2)
{
  uint64_t v2 = *a1;
  int v3 = 134217984;
  uint64_t v4 = v2;
  _os_log_error_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_ERROR, "applebt_rx_main: applebt_read_crash_info returned unsupported result size=%zu\n", (uint8_t *)&v3, 0xCu);
}

void sub_100745258()
{
  sub_1000DFBEC();
  _os_log_error_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_ERROR, "applebt_rx_main: applebt_read_crash_info succeeds, read result=0x%08X new format(size=%zu)\n", v1, 0x12u);
}

void sub_1007452D0()
{
  sub_1000DFBEC();
  _os_log_error_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_ERROR, "applebt_rx_main: applebt_read_crash_info succeeds, read result=0x%08X old format(size=%zu)\n", v1, 0x12u);
}

void sub_100745348()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "applebt_rx_main: applebt_read_crash_info returned fatal error, read result=0x%08X\n", v2, v3, v4, v5, v6);
}

void sub_1007453B0()
{
  sub_1000572E8();
  __int16 v3 = 1024;
  int v4 = v0;
  _os_log_error_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_ERROR, "applebt_rx_main: applebt_hci_read returned fatal error, read result=0x%08X pipes result=0x%08X - closing HCI device and aborting\n", v2, 0xEu);
}

void sub_100745434(int a1, int a2, NSObject *a3)
{
  int v5 = 136315394;
  uint8_t v6 = sub_1001A01CC(a1);
  __int16 v7 = 2080;
  CFStringRef v8 = sub_1001A01CC(a2);
  _os_log_error_impl((void *)&_mh_execute_header, a3, OS_LOG_TYPE_ERROR, "applebt_rx_main: applebt_hci_read failures, read result=%s pipes result=%s\n", (uint8_t *)&v5, 0x16u);
}

void sub_1007454E4(uint8_t *buf, unsigned __int8 *a2, int *a3, os_log_t log)
{
  int v4 = *a2 + 1;
  *(_DWORD *)uint64_t buf = 67109120;
  *a3 = v4;
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "applebt_rx_main: resetting next seq_num to %d\n", buf, 8u);
}

void sub_100745538(uint64_t a1, NSObject *a2)
{
  int v2 = 134217984;
  uint64_t v3 = a1;
  _os_log_error_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_ERROR, "applebt_set_hci_packet_attrs_from_footer: bt_packet_attr_decode error=0x%zX", (uint8_t *)&v2, 0xCu);
}

void sub_1007455B0()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "applebt_transport_terminate: pthread_join returned 0x%08X\n", v2, v3, v4, v5, v6);
}

void sub_100745618()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "applebt_transport_terminate: applebt_hci_close returned 0x%08X\n", v2, v3, v4, v5, v6);
}

void sub_100745680(uint8_t *a1, void *a2, NSObject *a3)
{
  uint8_t v6 = sub_100050714();
  *(_DWORD *)a1 = 136446210;
  *a2 = v6;
  _os_log_error_impl((void *)&_mh_execute_header, a3, OS_LOG_TYPE_ERROR, "%{public}s", a1, 0xCu);
}

void sub_1007456E8()
{
  sub_100050714();
  sub_1000E37A0((void *)&_mh_execute_header, v0, v1, "%{public}s", v2, v3, v4, v5, 2u);
}

void sub_100745764()
{
  sub_100050714();
  sub_10005732C();
  sub_1000E37A0((void *)&_mh_execute_header, v0, v1, "%{public}s", v2, v3, v4, v5, v6);
}

void sub_1007457DC(NSObject *a1)
{
  int v2 = 136446466;
  uint64_t v3 = sub_100050714();
  __int16 v4 = 1024;
  int v5 = 0xFFFF;
  _os_log_error_impl((void *)&_mh_execute_header, a1, OS_LOG_TYPE_ERROR, "%{public}s (status=%{bluetooth:OI_STATUS}u)", (uint8_t *)&v2, 0x12u);
}

void sub_100745878()
{
  uint64_t v0 = sub_1000F24E4();
  sub_100057338((uint64_t)v0, 4.8751e-34);
  sub_1000F24C4((void *)&_mh_execute_header, v1, v2, "%{public}s");
}

uint64_t sub_1007458C0(NSObject *a1, char a2)
{
  sub_100050714();
  sub_1000DDEEC();
  _os_log_error_impl((void *)&_mh_execute_header, a1, OS_LOG_TYPE_ERROR, "%{public}s (status=%{bluetooth:OI_STATUS}u)", v5, 0x12u);
  return a2 & 1;
}

void sub_100745950(os_log_t log)
{
  *(_WORD *)uint64_t v1 = 0;
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "Unknown ControllerChipset type passed-in.", v1, 2u);
}

void sub_100745994(os_log_t log)
{
  *(_WORD *)uint64_t v1 = 0;
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "Failed to determine ControllerChipset type.", v1, 2u);
}

void sub_1007459D8()
{
  sub_1001004CC();
  sub_100100498();
  sub_100057344((void *)&_mh_execute_header, v0, v1, "HCILite filtering. Buffer is smaller than expected. %ul < %ul (%s)", v2, v3, v4, v5, v6);
}

void sub_100745A54(int a1, int a2, os_log_t log)
{
  v3[0] = 67109376;
  v3[1] = a1;
  __int16 v4 = 1024;
  int v5 = a2;
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "HCILiteEventFilter buffer is smaller than expected. %ul < %ul", (uint8_t *)v3, 0xEu);
}

void sub_100745ADC()
{
  sub_100100498();
  sub_100057344((void *)&_mh_execute_header, v0, v1, "HCILite filtering. Buffer is smaller than expected. %ul < %ul (%s)", v2, v3, v4, v5, 2u);
}

void sub_100745B64()
{
  sub_100100498();
  sub_100057344((void *)&_mh_execute_header, v0, v1, "HCILite filtering. Buffer is smaller than expected. %ul < %ul (%s)", v2, v3, v4, v5, 2u);
}

void sub_100745BEC()
{
  sub_100100498();
  sub_100057344((void *)&_mh_execute_header, v0, v1, "HCILite filtering. Buffer is smaller than expected. %ul < %ul (%s)", v2, v3, v4, v5, 2u);
}

void sub_100745C74()
{
  sub_100100498();
  sub_100057344((void *)&_mh_execute_header, v0, v1, "HCILite filtering. Buffer is smaller than expected. %ul < %ul (%s)", v2, v3, v4, v5, 2u);
}

void sub_100745CFC(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_100745D74()
{
  sub_1001004CC();
  sub_100100498();
  sub_100057344((void *)&_mh_execute_header, v0, v1, "HCILite filtering. Buffer is smaller than expected. %ul < %ul (%s)", v2, v3, v4, v5, v6);
}

void sub_100745DF0()
{
  sub_100100498();
  sub_100057344((void *)&_mh_execute_header, v0, v1, "HCILite filtering. Buffer is smaller than expected. %ul < %ul (%s)", v2, v3, v4, v5, 2u);
}

void sub_100745E7C(int a1, int a2)
{
  v3[0] = 67109634;
  v3[1] = a1;
  __int16 v4 = 1024;
  int v5 = a2;
  sub_1001004A8();
  uint8_t v6 = "_Bool Filter_OI_DHCI_RETURN_LINK_KEYS_EVENT(OI_BYTE_STREAM *)";
  sub_1001004B4((void *)&_mh_execute_header, v2, (uint64_t)v2, "HCILite filtering. Buffer is smaller than expected. %ul < %ul (%s)", (uint8_t *)v3);
}

void sub_100745F0C(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_100745F84()
{
  sub_100100498();
  sub_100057344((void *)&_mh_execute_header, v0, v1, "HCILite filtering. Buffer is smaller than expected. %ul < %ul (%s)", v2, v3, v4, v5, 2u);
}

void sub_10074600C()
{
  sub_100100498();
  sub_100057344((void *)&_mh_execute_header, v0, v1, "HCILite filtering. Buffer is smaller than expected. %ul < %ul (%s)", v2, v3, v4, v5, 2u);
}

void sub_100746094()
{
  sub_100100498();
  sub_100057344((void *)&_mh_execute_header, v0, v1, "HCILite filtering. Buffer is smaller than expected. %ul < %ul (%s)", v2, v3, v4, v5, 2u);
}

void sub_10074611C()
{
  sub_100100498();
  sub_100057344((void *)&_mh_execute_header, v0, v1, "HCILite filtering. Buffer is smaller than expected. %ul < %ul (%s)", v2, v3, v4, v5, 2u);
}

void sub_1007461A4()
{
  sub_100100498();
  sub_100057344((void *)&_mh_execute_header, v0, v1, "HCILite filtering. Buffer is smaller than expected. %ul < %ul (%s)", v2, v3, v4, v5, 2u);
}

void sub_100746230()
{
  sub_100100498();
  sub_100057344((void *)&_mh_execute_header, v0, v1, "HCILite filtering. Buffer is smaller than expected. %ul < %ul (%s)", v2, v3, v4, v5, 2u);
}

void sub_1007462B8(int a1, int a2)
{
  v3[0] = 67109634;
  v3[1] = a1;
  __int16 v4 = 1024;
  int v5 = a2;
  sub_1001004A8();
  uint8_t v6 = "_Bool Filter_OI_DHCI_CONNECTIONLESS_PERIPHERAL_BROADCAST_RECEIVE_EVENT(OI_BYTE_STREAM *)";
  sub_1001004B4((void *)&_mh_execute_header, v2, (uint64_t)v2, "HCILite filtering. Buffer is smaller than expected. %ul < %ul (%s)", (uint8_t *)v3);
}

void sub_100746348(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_1007463C0()
{
  sub_1001004CC();
  sub_100100498();
  sub_100057344((void *)&_mh_execute_header, v0, v1, "HCILite filtering. Buffer is smaller than expected. %ul < %ul (%s)", v2, v3, v4, v5, v6);
}

void sub_10074643C()
{
  sub_1001004CC();
  sub_100100498();
  sub_100057344((void *)&_mh_execute_header, v0, v1, "HCILite filtering. Buffer is smaller than expected. %ul < %ul (%s)", v2, v3, v4, v5, v6);
}

void sub_1007464B8()
{
  sub_100100498();
  sub_100057344((void *)&_mh_execute_header, v0, v1, "HCILite filtering. Buffer is smaller than expected. %ul < %ul (%s)", v2, v3, v4, v5, 2u);
}

void sub_100746540()
{
  sub_100100498();
  sub_100057344((void *)&_mh_execute_header, v0, v1, "HCILite filtering. Buffer is smaller than expected. %ul < %ul (%s)", v2, v3, v4, v5, 2u);
}

void sub_1007465C8()
{
  sub_1001004CC();
  sub_100100498();
  sub_100057344((void *)&_mh_execute_header, v0, v1, "HCILite filtering. Buffer is smaller than expected. %ul < %ul (%s)", v2, v3, v4, v5, v6);
}

void sub_100746644()
{
  sub_1001004CC();
  sub_100100498();
  sub_100057344((void *)&_mh_execute_header, v0, v1, "HCILite filtering. Buffer is smaller than expected. %ul < %ul (%s)", v2, v3, v4, v5, v6);
}

void sub_1007466C0()
{
  sub_100100498();
  sub_100057344((void *)&_mh_execute_header, v0, v1, "HCILite filtering. Buffer is smaller than expected. %ul < %ul (%s)", v2, v3, v4, v5, 2u);
}

void sub_100746748(int a1, int a2)
{
  v3[0] = 67109634;
  v3[1] = a1;
  __int16 v4 = 1024;
  int v5 = a2;
  sub_1001004A8();
  uint8_t v6 = "_Bool Filter_OI_DHCI_CMD_ID_CREATE_PHYSICAL_LINK_OPCODE(OI_BYTE_STREAM *)";
  sub_1001004B4((void *)&_mh_execute_header, v2, (uint64_t)v2, "HCILite filtering. Buffer is smaller than expected. %ul < %ul (%s)", (uint8_t *)v3);
}

void sub_1007467D8(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_100746850()
{
  sub_100100498();
  sub_100057344((void *)&_mh_execute_header, v0, v1, "HCILite filtering. Buffer is smaller than expected. %ul < %ul (%s)", v2, v3, v4, v5, 2u);
}

void sub_1007468D8(int a1, int a2)
{
  v3[0] = 67109634;
  v3[1] = a1;
  __int16 v4 = 1024;
  int v5 = a2;
  sub_1001004A8();
  uint8_t v6 = "_Bool Filter_OI_DHCI_CMD_ID_ACCEPT_PHYSICAL_LINK_OPCODE(OI_BYTE_STREAM *)";
  sub_1001004B4((void *)&_mh_execute_header, v2, (uint64_t)v2, "HCILite filtering. Buffer is smaller than expected. %ul < %ul (%s)", (uint8_t *)v3);
}

void sub_100746968(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_1007469E0()
{
  sub_100100498();
  sub_100057344((void *)&_mh_execute_header, v0, v1, "HCILite filtering. Buffer is smaller than expected. %ul < %ul (%s)", v2, v3, v4, v5, 2u);
}

void sub_100746A68()
{
  sub_100100498();
  sub_100057344((void *)&_mh_execute_header, v0, v1, "HCILite filtering. Buffer is smaller than expected. %ul < %ul (%s)", v2, v3, v4, v5, 2u);
}

void sub_100746AF0()
{
  sub_100100498();
  sub_100057344((void *)&_mh_execute_header, v0, v1, "HCILite filtering. Buffer is smaller than expected. %ul < %ul (%s)", v2, v3, v4, v5, 2u);
}

void sub_100746B78()
{
  sub_1001004CC();
  sub_100100498();
  sub_100057344((void *)&_mh_execute_header, v0, v1, "HCILite filtering. Buffer is smaller than expected. %ul < %ul (%s)", v2, v3, v4, v5, v6);
}

void sub_100746BF4()
{
  sub_100100498();
  sub_100057344((void *)&_mh_execute_header, v0, v1, "HCILite filtering. Buffer is smaller than expected. %ul < %ul (%s)", v2, v3, v4, v5, 2u);
}

void sub_100746C7C()
{
  sub_100100498();
  sub_100057344((void *)&_mh_execute_header, v0, v1, "HCILite filtering. Buffer is smaller than expected. %ul < %ul (%s)", v2, v3, v4, v5, 2u);
}

void sub_100746D04()
{
  sub_100100498();
  sub_100057344((void *)&_mh_execute_header, v0, v1, "HCILite filtering. Buffer is smaller than expected. %ul < %ul (%s)", v2, v3, v4, v5, 2u);
}

void sub_100746D8C()
{
  sub_100100498();
  sub_100057344((void *)&_mh_execute_header, v0, v1, "HCILite filtering. Buffer is smaller than expected. %ul < %ul (%s)", v2, v3, v4, v5, 2u);
}

void sub_100746E14(int a1, int a2)
{
  v3[0] = 67109634;
  v3[1] = a1;
  __int16 v4 = 1024;
  int v5 = a2;
  sub_1001004A8();
  uint8_t v6 = "_Bool Filter_OI_DHCI_CMD_ID_LE_SET_EXTENDED_ADVERTISING_DATA_OPCODE(OI_BYTE_STREAM *)";
  sub_1001004B4((void *)&_mh_execute_header, v2, (uint64_t)v2, "HCILite filtering. Buffer is smaller than expected. %ul < %ul (%s)", (uint8_t *)v3);
}

void sub_100746EA4(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_100746F1C()
{
  sub_100100498();
  sub_100057344((void *)&_mh_execute_header, v0, v1, "HCILite filtering. Buffer is smaller than expected. %ul < %ul (%s)", v2, v3, v4, v5, 2u);
}

void sub_100746FA4(int a1, int a2)
{
  v3[0] = 67109634;
  v3[1] = a1;
  __int16 v4 = 1024;
  int v5 = a2;
  sub_1001004A8();
  uint8_t v6 = "_Bool Filter_OI_DHCI_CMD_ID_LE_SET_EXTENDED_SCAN_RESPONSE_DATA_OPCODE(OI_BYTE_STREAM *)";
  sub_1001004B4((void *)&_mh_execute_header, v2, (uint64_t)v2, "HCILite filtering. Buffer is smaller than expected. %ul < %ul (%s)", (uint8_t *)v3);
}

void sub_100747034(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_1007470AC()
{
  sub_100100498();
  sub_100057344((void *)&_mh_execute_header, v0, v1, "HCILite filtering. Buffer is smaller than expected. %ul < %ul (%s)", v2, v3, v4, v5, 2u);
}

void sub_100747134(int a1, int a2)
{
  v3[0] = 67109634;
  v3[1] = a1;
  __int16 v4 = 1024;
  int v5 = a2;
  sub_1001004A8();
  uint8_t v6 = "_Bool Filter_OI_DHCI_CMD_ID_LE_SET_PERIODIC_ADVERTISING_DATA_OPCODE(OI_BYTE_STREAM *)";
  sub_1001004B4((void *)&_mh_execute_header, v2, (uint64_t)v2, "HCILite filtering. Buffer is smaller than expected. %ul < %ul (%s)", (uint8_t *)v3);
}

void sub_1007471C4(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_10074723C()
{
  sub_100100498();
  sub_100057344((void *)&_mh_execute_header, v0, v1, "HCILite filtering. Buffer is smaller than expected. %ul < %ul (%s)", v2, v3, v4, v5, 2u);
}

void sub_1007472C4()
{
  sub_1001004CC();
  sub_100100498();
  sub_100057344((void *)&_mh_execute_header, v0, v1, "HCILite filtering. Buffer is smaller than expected. %ul < %ul (%s)", v2, v3, v4, v5, v6);
}

void sub_100747340()
{
  sub_1001004CC();
  sub_100100498();
  sub_100057344((void *)&_mh_execute_header, v0, v1, "HCILite filtering. Buffer is smaller than expected. %ul < %ul (%s)", v2, v3, v4, v5, v6);
}

void sub_1007473BC()
{
  sub_100100498();
  sub_100057344((void *)&_mh_execute_header, v0, v1, "HCILite filtering. Buffer is smaller than expected. %ul < %ul (%s)", v2, v3, v4, v5, 2u);
}

void sub_100747448()
{
  sub_100100498();
  sub_100057344((void *)&_mh_execute_header, v0, v1, "HCILite filtering. Buffer is smaller than expected. %ul < %ul (%s)", v2, v3, v4, v5, 2u);
}

void sub_1007474D4(int a1, int a2)
{
  v3[0] = 67109634;
  v3[1] = a1;
  __int16 v4 = 1024;
  int v5 = a2;
  sub_1001004A8();
  uint8_t v6 = "_Bool Filter_OI_DHCI_WRITE_STORED_LINK_KEY_OPCODE(OI_BYTE_STREAM *)";
  sub_1001004B4((void *)&_mh_execute_header, v2, (uint64_t)v2, "HCILite filtering. Buffer is smaller than expected. %ul < %ul (%s)", (uint8_t *)v3);
}

void sub_100747564(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_1007475DC()
{
  sub_100100498();
  sub_100057344((void *)&_mh_execute_header, v0, v1, "HCILite filtering. Buffer is smaller than expected. %ul < %ul (%s)", v2, v3, v4, v5, 2u);
}

void sub_100747664()
{
  sub_1001004CC();
  sub_100100498();
  sub_100057344((void *)&_mh_execute_header, v0, v1, "HCILite filtering. Buffer is smaller than expected. %ul < %ul (%s)", v2, v3, v4, v5, v6);
}

void sub_1007476E0()
{
  sub_100100498();
  sub_100057344((void *)&_mh_execute_header, v0, v1, "HCILite filtering. Buffer is smaller than expected. %ul < %ul (%s)", v2, v3, v4, v5, 2u);
}

void sub_100747768()
{
  sub_100100498();
  sub_100057344((void *)&_mh_execute_header, v0, v1, "HCILite filtering. Buffer is smaller than expected. %ul < %ul (%s)", v2, v3, v4, v5, 2u);
}

void sub_1007477F0()
{
  sub_100100498();
  sub_100057344((void *)&_mh_execute_header, v0, v1, "HCILite filtering. Buffer is smaller than expected. %ul < %ul (%s)", v2, v3, v4, v5, 2u);
}

void sub_10074787C()
{
  sub_100100498();
  sub_100057344((void *)&_mh_execute_header, v0, v1, "HCILite filtering. Buffer is smaller than expected. %ul < %ul (%s)", v2, v3, v4, v5, 2u);
}

void sub_100747908(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_100747980()
{
  sub_1001004CC();
  sub_100100498();
  sub_100057344((void *)&_mh_execute_header, v0, v1, "HCILite filtering. Buffer is smaller than expected. %ul < %ul (%s)", v2, v3, v4, v5, v6);
}

void sub_1007479FC()
{
  sub_1001004CC();
  sub_100100498();
  sub_100057344((void *)&_mh_execute_header, v0, v1, "HCILite filtering. Buffer is smaller than expected. %ul < %ul (%s)", v2, v3, v4, v5, v6);
}

void sub_100747A78()
{
  sub_100100498();
  sub_100057344((void *)&_mh_execute_header, v0, v1, "HCILite filtering. Buffer is smaller than expected. %ul < %ul (%s)", v2, v3, v4, v5, 2u);
}

void sub_100747B00()
{
  sub_1001004CC();
  sub_100100498();
  sub_100057344((void *)&_mh_execute_header, v0, v1, "HCILite filtering. Buffer is smaller than expected. %ul < %ul (%s)", v2, v3, v4, v5, v6);
}

void sub_100747B7C()
{
  sub_100100498();
  sub_100057344((void *)&_mh_execute_header, v0, v1, "HCILite filtering. Buffer is smaller than expected. %ul < %ul (%s)", v2, v3, v4, v5, 2u);
}

void sub_100747C08()
{
  sub_1001004CC();
  sub_100100498();
  sub_100057344((void *)&_mh_execute_header, v0, v1, "HCILite filtering. Buffer is smaller than expected. %ul < %ul (%s)", v2, v3, v4, v5, v6);
}

void sub_100747C84(int a1, int a2)
{
  v3[0] = 67109634;
  v3[1] = a1;
  __int16 v4 = 1024;
  int v5 = a2;
  sub_1001004A8();
  uint8_t v6 = "_Bool Filter_LE_EXTENDED_ADVERTISING_REPORT_SUBEVENT(OI_BYTE_STREAM *)";
  sub_1001004B4((void *)&_mh_execute_header, v2, (uint64_t)v2, "HCILite filtering. Buffer is smaller than expected. %ul < %ul (%s)", (uint8_t *)v3);
}

void sub_100747D14(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_100747D8C()
{
  sub_100100498();
  sub_100057344((void *)&_mh_execute_header, v0, v1, "HCILite filtering. Buffer is smaller than expected. %ul < %ul (%s)", v2, v3, v4, v5, 2u);
}

void sub_100747E14(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_100747E8C()
{
  sub_100100498();
  sub_100057344((void *)&_mh_execute_header, v0, v1, "HCILite filtering. Buffer is smaller than expected. %ul < %ul (%s)", v2, v3, v4, v5, 2u);
}

void sub_100747F14()
{
  sub_1001004CC();
  sub_100100498();
  sub_100057344((void *)&_mh_execute_header, v0, v1, "HCILite filtering. Buffer is smaller than expected. %ul < %ul (%s)", v2, v3, v4, v5, v6);
}

void sub_100747F90()
{
  sub_1001004CC();
  sub_100100498();
  sub_100057344((void *)&_mh_execute_header, v0, v1, "HCILite filtering. Buffer is smaller than expected. %ul < %ul (%s)", v2, v3, v4, v5, v6);
}

void sub_10074800C()
{
  sub_100100498();
  sub_100057344((void *)&_mh_execute_header, v0, v1, "HCILite filtering. Buffer is smaller than expected. %ul < %ul (%s)", v2, v3, v4, v5, 2u);
}

void sub_100748094()
{
  sub_100100498();
  sub_100057344((void *)&_mh_execute_header, v0, v1, "HCILite filtering. Buffer is smaller than expected. %ul < %ul (%s)", v2, v3, v4, v5, 2u);
}

void sub_10074811C()
{
  sub_100100498();
  sub_100057344((void *)&_mh_execute_header, v0, v1, "HCILite filtering. Buffer is smaller than expected. %ul < %ul (%s)", v2, v3, v4, v5, 2u);
}

void sub_1007481A4()
{
  sub_100100498();
  sub_100057344((void *)&_mh_execute_header, v0, v1, "HCILite filtering. Buffer is smaller than expected. %ul < %ul (%s)", v2, v3, v4, v5, 2u);
}

void sub_10074822C()
{
  sub_1001004CC();
  sub_100100498();
  sub_100057344((void *)&_mh_execute_header, v0, v1, "HCILite filtering. Buffer is smaller than expected. %ul < %ul (%s)", v2, v3, v4, v5, v6);
}

void sub_1007482A8()
{
  sub_1001004CC();
  sub_100100498();
  sub_100057344((void *)&_mh_execute_header, v0, v1, "HCILite filtering. Buffer is smaller than expected. %ul < %ul (%s)", v2, v3, v4, v5, v6);
}

void sub_100748324()
{
  sub_1001035D4();
  sub_100050714();
  sub_100057360();
  sub_1000DDF08((void *)&_mh_execute_header, v0, v1, "%{public}s (status=%{bluetooth:OI_STATUS}u)", v2, v3, v4, v5, v6);
}

void sub_10074839C()
{
  perror("Failed to CreateThread ");
  uint64_t v0 = sub_10010B394(108);
  sub_1007483BC(v0);
}

void sub_1007483BC(uint64_t a1)
{
  uint64_t v2 = (void (*)(const char *, uint64_t))dlsym((void *)0xFFFFFFFFFFFFFFFFLL, "WriteStackshotReport_stdc");
  if (v2) {
    v2("BT Stack Stuck", 3172327085);
  }
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  if (!byte_100A000F0) {
    __strlcpy_chk();
  }
  snprintf((char *)a1, 0x80uLL, "Stack watchdog timeout on thread: %s", &byte_100A000F0);
  qword_1009FC078 = a1;
  sub_10025B778("Watchdog_Timer - Stack Mutex try lock failed and watchdog has struck twice -- abort\n");
  sub_10010B390();
  abort();
}

void sub_100748478()
{
  sub_100050714();
  sub_100111D78();
  sub_1000DDF08((void *)&_mh_execute_header, v0, v1, "%{public}s (status=%{bluetooth:OI_STATUS}u)", v2, v3, v4, v5, v6);
}

void sub_1007484F0()
{
  sub_100050714();
  sub_100111D94();
  sub_1000DDF08((void *)&_mh_execute_header, v0, v1, "%{public}s (status=%{bluetooth:OI_STATUS}u)", v2, v3, v4, v5, v6);
}

void sub_100748568()
{
  sub_100050714();
  sub_100057378();
  sub_1000DDF08((void *)&_mh_execute_header, v0, v1, "%{public}s (status=%{bluetooth:OI_STATUS}u)", v2, v3, v4, v5, v6);
}

void sub_1007485E0()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Failed to open directory", v2, v3, v4, v5, v6);
}

void sub_100748614()
{
  uint64_t v0 = __error();
  strerror(*v0);
  sub_100057394((void *)&_mh_execute_header, v1, v2, "Failed to create directory %s %s", v3, v4, v5, v6, 2u);
}

void sub_1007486AC()
{
  uint64_t v0 = __error();
  strerror(*v0);
  sub_100057394((void *)&_mh_execute_header, v1, v2, "Failed to create Log directory %s %s", v3, v4, v5, v6, 2u);
}

void sub_100748740(int a1, NSObject *a2)
{
  v2[0] = 67109120;
  v2[1] = a1;
  _os_log_error_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_ERROR, "Error starting PacketLogger XPC service, error: %d", (uint8_t *)v2, 8u);
}

void sub_1007487B8()
{
  sub_10005732C();
  _os_log_debug_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_DEBUG, "Set header to %s", v1, 0xCu);
}

void sub_10074882C()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Error invalid length", v2, v3, v4, v5, v6);
}

void sub_100748860()
{
  os_log_t v0 = __error();
  strerror(*v0);
  sub_10005732C();
  sub_1000E37A0((void *)&_mh_execute_header, v1, v2, "Failed to open file for writing: %s", v3, v4, v5, v6, v7);
}

void sub_1007488E0()
{
  os_log_t v0 = __error();
  strerror(*v0);
  sub_10005732C();
  sub_1000E37A0((void *)&_mh_execute_header, v1, v2, "Failed to open new file for writing: %s", v3, v4, v5, v6, v7);
}

void sub_100748960(uint8_t *buf, unsigned char *a2, os_log_t log)
{
  *uint64_t buf = 0;
  *a2 = 0;
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "Failed to stat file", buf, 2u);
}

void sub_1007489A0(uint64_t a1, NSObject *a2)
{
  uint64_t v4 = qword_100A01AC0;
  uint64_t v5 = __error();
  uint64_t v6 = strerror(*v5);
  int v7 = 136315650;
  uint64_t v8 = v4;
  __int16 v9 = 2080;
  uint64_t v10 = a1;
  __int16 v11 = 2080;
  uint64_t v12 = v6;
  _os_log_error_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_ERROR, "Failed to rename file %s->%s %s", (uint8_t *)&v7, 0x20u);
}

void sub_100748A5C()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Bluetooth Profile Required", v2, v3, v4, v5, v6);
}

void sub_100748A90()
{
  sub_10005732C();
  _os_log_error_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_ERROR, "Error with PacketLogger connection %{public}s", v1, 0xCu);
}

void sub_100748B04()
{
  sub_10005732C();
  _os_log_error_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_ERROR, "Error with PacketLogger connection %s", v1, 0xCu);
}

void sub_100748B78(NSObject *a1)
{
  int v2 = 136446210;
  uint64_t v3 = sub_100050714();
  _os_log_error_impl((void *)&_mh_execute_header, a1, OS_LOG_TYPE_ERROR, "%{public}s", (uint8_t *)&v2, 0xCu);
}

void sub_100748C04()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "applebt_mgmt_connect: IOServiceOpen returned 0x%08X\n", v2, v3, v4, v5, v6);
}

void sub_100748C6C()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "applebt_set_trace_mode: IOConnectCallMethod returned 0x%08X\n", v2, v3, v4, v5, v6);
}

void sub_100748CD4()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "applebt_set_trace_mode: applebt_mgmt_connect returned 0x%08X\n", v2, v3, v4, v5, v6);
}

void sub_100748D3C()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "applebt_set_trace_level: IOConnectCallMethod returned 0x%08X\n", v2, v3, v4, v5, v6);
}

void sub_100748DA4()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "applebt_set_trace_level: applebt_mgmt_connect returned 0x%08X\n", v2, v3, v4, v5, v6);
}

void sub_100748E0C()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "applebt_set_trace_mask: IOConnectCallMethod returned 0x%08X\n", v2, v3, v4, v5, v6);
}

void sub_100748E74()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "applebt_set_trace_mask: applebt_mgmt_connect returned 0x%08X\n", v2, v3, v4, v5, v6);
}

void sub_100748EDC()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "applebt_set_capture_timeout: IOConnectCallMethod returned 0x%08X\n", v2, v3, v4, v5, v6);
}

void sub_100748F44()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "applebt_set_capture_timeout: applebt_mgmt_connect returned 0x%08X\n", v2, v3, v4, v5, v6);
}

void sub_100748FAC()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "applebt_trigger_capture: IOConnectCallMethod returned 0x%08X\n", v2, v3, v4, v5, v6);
}

void sub_100749014()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "applebt_trigger_capture: applebt_mgmt_connect returned 0x%08X\n", v2, v3, v4, v5, v6);
}

void sub_10074907C()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "applebt_general_debug: IOConnectCallMethod returned 0x%08X\n", v2, v3, v4, v5, v6);
}

void sub_1007490E4()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "applebt_general_debug: applebt_mgmt_connect returned 0x%08X\n", v2, v3, v4, v5, v6);
}

void sub_10074914C()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "applebt_read_crash_info: IOConnectCallMethod returned 0x%08X\n", v2, v3, v4, v5, v6);
}

void sub_1007491B4()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "applebt_read_crash_info: applebt_mgmt_connect returned 0x%08X\n", v2, v3, v4, v5, v6);
}

void sub_10074921C()
{
  sub_100050714();
  sub_10014EB04();
  sub_1000DDF08((void *)&_mh_execute_header, v0, v1, "%{public}s (status=%{bluetooth:OI_STATUS}u)", v2, v3, v4, v5, v6);
}

void sub_100749294(NSObject *a1)
{
  sub_100050714();
  sub_10005732C();
  __int16 v3 = 1024;
  int v4 = 0xFFFF;
  _os_log_error_impl((void *)&_mh_execute_header, a1, OS_LOG_TYPE_ERROR, "%{public}s (status=%{bluetooth:OI_STATUS}u)", v2, 0x12u);
}

void sub_10074932C()
{
  sub_100050714();
  sub_100057360();
  sub_1000DDF08((void *)&_mh_execute_header, v0, v1, "%{public}s (status=%{bluetooth:OI_STATUS}u)", v2, v3, v4, v5, v6);
}

void sub_1007493A8()
{
  sub_100050714();
  sub_1001604AC();
  sub_1000DDF08((void *)&_mh_execute_header, v0, v1, "%{public}s (status=%{bluetooth:OI_STATUS}u)", v2, v3, v4, v5, v6);
}

void sub_100749428()
{
  sub_100050714();
  sub_1001604AC();
  sub_1000DDF08((void *)&_mh_execute_header, v0, v1, "%{public}s (status=%{bluetooth:OI_STATUS}u)", v2, v3, v4, v5, v6);
}

void sub_1007494A8()
{
  sub_100050714();
  sub_10016A838();
  sub_1000DDF08((void *)&_mh_execute_header, v0, v1, "%{public}s (status=%{bluetooth:OI_STATUS}u)", v2, v3, v4, v5, v6);
}

void sub_100749520()
{
  sub_100050714();
  sub_1001604AC();
  sub_1000DDF08((void *)&_mh_execute_header, v0, v1, "%{public}s (status=%{bluetooth:OI_STATUS}u)", v2, v3, v4, v5, v6);
}

void sub_1007495A0()
{
  uint64_t v2 = sub_1000F24E4();
  *uint64_t v1 = 136446210;
  void *v0 = v2;
  sub_1000F24C4((void *)&_mh_execute_header, v3, v4, "%{public}s");
}

void sub_1007495EC()
{
  sub_100050714();
  sub_1000DDF08((void *)&_mh_execute_header, v0, v1, "%{public}s (status=%{bluetooth:OI_STATUS}u)", v2, v3, v4, v5, 2u);
}

void sub_100749678()
{
  sub_100050714();
  sub_10017B6BC();
  sub_1000DDF08((void *)&_mh_execute_header, v0, v1, "%{public}s (status=%{bluetooth:OI_STATUS}u)", v2, v3, v4, v5, v6);
}

void sub_1007496F0()
{
  sub_100050714();
  sub_1001604AC();
  sub_1000DDF08((void *)&_mh_execute_header, v0, v1, "%{public}s (status=%{bluetooth:OI_STATUS}u)", v2, v3, v4, v5, v6);
}

void sub_10074976C()
{
  sub_100050714();
  sub_1001604AC();
  sub_1000DDF08((void *)&_mh_execute_header, v0, v1, "%{public}s (status=%{bluetooth:OI_STATUS}u)", v2, v3, v4, v5, v6);
}

void sub_1007497EC()
{
  sub_100050714();
  sub_1001604AC();
  sub_1000DDF08((void *)&_mh_execute_header, v0, v1, "%{public}s (status=%{bluetooth:OI_STATUS}u)", v2, v3, v4, v5, v6);
}

void sub_10074986C()
{
  sub_100050714();
  sub_1001604AC();
  sub_1000DDF08((void *)&_mh_execute_header, v0, v1, "%{public}s (status=%{bluetooth:OI_STATUS}u)", v2, v3, v4, v5, v6);
}

void sub_1007498EC(_DWORD *a1, void *a2)
{
  uint64_t v4 = sub_100050714();
  *a1 = 136446210;
  *a2 = v4;
  sub_1000F24C4((void *)&_mh_execute_header, v5, v6, "%{public}s");
}

void sub_100749944()
{
  sub_100050714();
  sub_1001604AC();
  sub_1000DDF08((void *)&_mh_execute_header, v0, v1, "%{public}s (status=%{bluetooth:OI_STATUS}u)", v2, v3, v4, v5, v6);
}

void sub_1007499C4()
{
  sub_100050714();
  sub_1000DDF08((void *)&_mh_execute_header, v0, v1, "%{public}s (status=%{bluetooth:OI_STATUS}u)", v2, v3, v4, v5, 2u);
}

void sub_100749A50()
{
  sub_100050714();
  sub_1001604AC();
  sub_1000DDF08((void *)&_mh_execute_header, v0, v1, "%{public}s (status=%{bluetooth:OI_STATUS}u)", v2, v3, v4, v5, v6);
}

void sub_100749AD0()
{
  sub_100050714();
  sub_100199724();
  sub_1000DDF08((void *)&_mh_execute_header, v0, v1, "%{public}s (status=%{bluetooth:OI_STATUS}u)", v2, v3, v4, v5, v6);
}

void sub_100749B48()
{
  sub_100050714();
  sub_10005732C();
  sub_10019BF40((void *)&_mh_execute_header, v0, v1, "%{public}s", v2, v3, v4, v5, v6);
}

void sub_100749BC0()
{
  sub_100050714();
  sub_1000DDF08((void *)&_mh_execute_header, v0, v1, "%{public}s (status=%{bluetooth:OI_STATUS}u)", v2, v3, v4, v5, 2u);
}

void sub_100749C4C()
{
  sub_100050714();
  sub_10019FC80();
  sub_1000DDF08((void *)&_mh_execute_header, v0, v1, "%{public}s (status=%{bluetooth:OI_STATUS}u)", v2, v3, v4, v5, v6);
}

void sub_100749CC4()
{
  sub_100050714();
  sub_10019FC48();
  sub_1000DDF08((void *)&_mh_execute_header, v0, v1, "%{public}s (status=%{bluetooth:OI_STATUS}u)", v2, v3, v4, v5, v6);
}

void sub_100749D3C()
{
  sub_100050714();
  sub_10019FC2C();
  sub_1000DDF08((void *)&_mh_execute_header, v0, v1, "%{public}s (status=%{bluetooth:OI_STATUS}u)", v2, v3, v4, v5, v6);
}

void sub_100749DB4()
{
  sub_100050714();
  sub_1001604AC();
  sub_1000DDF08((void *)&_mh_execute_header, v0, v1, "%{public}s (status=%{bluetooth:OI_STATUS}u)", v2, v3, v4, v5, v6);
}

void sub_100749E34()
{
  sub_100050714();
  sub_1001604AC();
  sub_1000DDF08((void *)&_mh_execute_header, v0, v1, "%{public}s (status=%{bluetooth:OI_STATUS}u)", v2, v3, v4, v5, v6);
}

void sub_100749EB4()
{
  sub_100050714();
  sub_10019FC9C();
  sub_1000DDF08((void *)&_mh_execute_header, v0, v1, "%{public}s (status=%{bluetooth:OI_STATUS}u)", v2, v3, v4, v5, v6);
}

void sub_100749F2C()
{
  sub_100050714();
  sub_10019FCB8();
  sub_1000DDF08((void *)&_mh_execute_header, v0, v1, "%{public}s (status=%{bluetooth:OI_STATUS}u)", v2, v3, v4, v5, v6);
}

void sub_100749FA4()
{
  sub_100050714();
  sub_10019FC64();
  sub_1000DDF08((void *)&_mh_execute_header, v0, v1, "%{public}s (status=%{bluetooth:OI_STATUS}u)", v2, v3, v4, v5, v6);
}

void sub_10074A01C()
{
  sub_100050714();
  sub_10019FCD4();
  sub_1000DDF08((void *)&_mh_execute_header, v0, v1, "%{public}s (status=%{bluetooth:OI_STATUS}u)", v2, v3, v4, v5, v6);
}

void sub_10074A094()
{
  sub_1001035D4();
  sub_1001A01CC(v0);
  sub_1001A1158();
  sub_1000DDF08((void *)&_mh_execute_header, v1, v2, "applebt_hci_open: IOConnectCallMethod returned (0x%08X, %s)\n", v3, v4, v5, v6, v7);
}

void sub_10074A10C(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_100057310((void *)&_mh_execute_header, a2, a3, "applebt_hci_open: applebt_hci_connect returned 0x%08X\n", a5, a6, a7, a8, 0);
}

void sub_10074A178(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_100057310((void *)&_mh_execute_header, a2, a3, "applebt_hci_connect: IOServiceOpen returned 0x%08X\n", a5, a6, a7, a8, 0);
}

void sub_10074A1E4(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_100057310((void *)&_mh_execute_header, a2, a3, "applebt_hci_connect: IOServiceAddMatchingNotification returned 0x%08X\n", a5, a6, a7, a8, 0);
}

void sub_10074A250()
{
  sub_1001035D4();
  sub_1001A01CC(v0);
  sub_1001A1158();
  sub_1000DDF08((void *)&_mh_execute_header, v1, v2, "applebt_hci_close: IOConnectCallMethod returned (0x%08X, %s), closing connection\n", v3, v4, v5, v6, v7);
}

void sub_10074A2C8()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "applebt_hci_close: Not opened\n", v2, v3, v4, v5, v6);
}

void sub_10074A2FC()
{
  sub_1001035D4();
  sub_1001A01CC(v0);
  sub_1001A1158();
  sub_1000DDF08((void *)&_mh_execute_header, v1, v2, "applebt_hci_transport_reset: IOConnectCallMethod returned (0x%08X, %s)\n", v3, v4, v5, v6, v7);
}

void sub_10074A374()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "applebt_hci_transport_reset: Not opened\n", v2, v3, v4, v5, v6);
}

void sub_10074A3A8()
{
  sub_1001035D4();
  sub_1001A01CC(v0);
  sub_1001A1158();
  sub_1000DDF08((void *)&_mh_execute_header, v1, v2, "applebt_hci_write: IOConnectCallMethod returned (0x%08X, %s)\n", v3, v4, v5, v6, v7);
}

void sub_10074A420()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "applebt_hci_write: Not opened\n", v2, v3, v4, v5, v6);
}

void sub_10074A454()
{
  sub_1001035D4();
  sub_1001A01CC(v0);
  sub_1001A1158();
  sub_1000DDF08((void *)&_mh_execute_header, v1, v2, "applebt_hci_read: IOConnectCallMethod returned (0x%08X, %s)\n", v3, v4, v5, v6, v7);
}

void sub_10074A4CC()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "applebt_hci_read: Not opened\n", v2, v3, v4, v5, v6);
}

void sub_10074A500()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "applebt_hci_pipes_info: service not opened\n", v2, v3, v4, v5, v6);
}

void sub_10074A534()
{
  sub_100050714();
  sub_1001E5410();
  sub_1000DDF08((void *)&_mh_execute_header, v0, v1, "%{public}s (status=%{bluetooth:OI_STATUS}u)", v2, v3, v4, v5, v6);
}

void sub_10074A5AC()
{
  sub_100050714();
  sub_1001E53F4();
  sub_1000DDF08((void *)&_mh_execute_header, v0, v1, "%{public}s (status=%{bluetooth:OI_STATUS}u)", v2, v3, v4, v5, v6);
}

void sub_10074A624(NSObject *a1)
{
  sub_100050714();
  sub_10005732C();
  _os_log_fault_impl((void *)&_mh_execute_header, a1, OS_LOG_TYPE_FAULT, "%{public}s", v2, 0xCu);
}

void sub_10074A6AC()
{
  sub_100050714();
  sub_1001604AC();
  sub_1000DDF08((void *)&_mh_execute_header, v0, v1, "%{public}s (status=%{bluetooth:OI_STATUS}u)", v2, v3, v4, v5, v6);
}

void sub_10074A72C()
{
  sub_100050714();
  sub_1001604AC();
  sub_1000DDF08((void *)&_mh_execute_header, v0, v1, "%{public}s (status=%{bluetooth:OI_STATUS}u)", v2, v3, v4, v5, v6);
}

void sub_10074A7AC()
{
  sub_100050714();
  sub_100208CE8();
  sub_1000DDF08((void *)&_mh_execute_header, v0, v1, "%{public}s (status=%{bluetooth:OI_STATUS}u)", v2, v3, v4, v5, v6);
}

void sub_10074A824()
{
  sub_100050714();
  sub_100208CCC();
  sub_1000DDF08((void *)&_mh_execute_header, v0, v1, "%{public}s (status=%{bluetooth:OI_STATUS}u)", v2, v3, v4, v5, v6);
}

void sub_10074A89C()
{
  sub_100050714();
  sub_1000DDF08((void *)&_mh_execute_header, v0, v1, "%{public}s (status=%{bluetooth:OI_STATUS}u)", v2, v3, v4, v5, 2u);
}

void sub_10074A928(NSObject *a1)
{
  int v2 = 136446210;
  uint64_t v3 = sub_100050714();
  _os_log_fault_impl((void *)&_mh_execute_header, a1, OS_LOG_TYPE_FAULT, "%{public}s", (uint8_t *)&v2, 0xCu);
}

void sub_10074A9B4()
{
  sub_100050714();
  sub_1000DDF08((void *)&_mh_execute_header, v0, v1, "%{public}s (status=%{bluetooth:OI_STATUS}u)", v2, v3, v4, v5, 2u);
}

void sub_10074AA40()
{
}

void sub_10074AA5C()
{
}

void sub_10074AA7C()
{
}

void sub_10074AA98()
{
}

void sub_10074AAB4()
{
}

void sub_10074AAD0()
{
  sub_100050714();
  sub_1001604AC();
  sub_1000DDF08((void *)&_mh_execute_header, v0, v1, "%{public}s (status=%{bluetooth:OI_STATUS}u)", v2, v3, v4, v5, v6);
}

void sub_10074AB50(NSObject *a1)
{
  int v2 = 136446466;
  uint64_t v3 = sub_100050714();
  __int16 v4 = 1024;
  int v5 = 1023;
  _os_log_error_impl((void *)&_mh_execute_header, a1, OS_LOG_TYPE_ERROR, "%{public}s (status=%{bluetooth:OI_STATUS}u)", (uint8_t *)&v2, 0x12u);
}

void sub_10074ABEC(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_10074AC5C(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_10074ACCC(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_10074AD3C()
{
  sub_10005732C();
  sub_1000572F4((void *)&_mh_execute_header, v0, v1, "Failed to set all flags with error %@", v2, v3, v4, v5, v6);
}

void sub_10074ADA4()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Failed to create a LPM notification token", v2, v3, v4, v5, v6);
}

void sub_10074ADD8()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "LPM is not supported", v2, v3, v4, v5, v6);
}

void sub_10074AE0C()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Altough lpm1Flag is enabled, power reason is not critical battery.", v2, v3, v4, v5, v6);
}

void sub_10074AE40()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Failed to enter LPM.", v2, v3, v4, v5, v6);
}

void sub_10074AE74()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Failed to start HCI tracing.", v2, v3, v4, v5, v6);
}

void sub_10074AEA8()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Transport layer initialization failed.", v2, v3, v4, v5, v6);
}

void sub_10074AEDC()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to configure hostless mode with error %d", v2, v3, v4, v5, v6);
}

void sub_10074AF44()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "System is still SLEEP!", v2, v3, v4, v5, v6);
}

void sub_10074AF78()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to prepare VSC commands with error %d", v2, v3, v4, v5, v6);
}

void sub_10074AFE0()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Wifi is still ON!", v2, v3, v4, v5, v6);
}

void sub_10074B014()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "We don't have offline ADV data yet", v2, v3, v4, v5, v6);
}

void sub_10074B048(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_10074B0C0()
{
  v1[0] = 136315394;
  sub_10026C6AC();
  _os_log_error_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_ERROR, "Failed to notify %s, notify_post returned %d", (uint8_t *)v1, 0x12u);
}

void sub_10074B140()
{
  v1[0] = 136315394;
  sub_10026C6AC();
  _os_log_error_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_ERROR, "Failed to notify %s, notify_set_state returned %d", (uint8_t *)v1, 0x12u);
}

void sub_10074B1C0()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "No peripheral is found when LPM_CONFIG_FLAG_BIT_DEBUG_MODE_USE_VSC is set.", v2, v3, v4, v5, v6);
}

void sub_10074B1F4()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "BA_LPEM feature is off.", v2, v3, v4, v5, v6);
}

void sub_10074B228()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "lpmFlag is not enabled. Failed to enter LPM.", v2, v3, v4, v5, v6);
}

void sub_10074B25C()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Failed to set IOPMUBootLPMFWOK flag", v2, v3, v4, v5, v6);
}

void sub_10074B290(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_10074B314(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_10074B388(unsigned char *a1, unsigned char *a2)
{
  sub_10026C69C(a1, a2);
  sub_1000573D0((void *)&_mh_execute_header, v2, v3, "No command response is returned.", v4);
}

void sub_10074B3B4(unsigned char *a1, unsigned char *a2)
{
  sub_10026C69C(a1, a2);
  sub_1000573D0((void *)&_mh_execute_header, v2, v3, "Output from LPM_output_buffer should be less than LPM_STR_BUF_MAX_LEN", v4);
}

void sub_10074B3E0(unsigned char *a1, unsigned char *a2)
{
  sub_10026C69C(a1, a2);
  sub_1000573D0((void *)&_mh_execute_header, v2, v3, "Unable to scan bytes", v4);
}

void sub_10074B40C(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_10074B47C(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_10074B4F4(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_10074B56C(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_10074B5E4(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_10074B65C(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_10074B6D4(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_10074B74C(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_10074B7BC(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_10074B834(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_10074B8AC(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_10074B924(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_10074B99C(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_10074BA14(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_10074BA8C()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Invalid offline adv data", v2, v3, v4, v5, v6);
}

void sub_10074BAC0()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Exceed max number of peripherals.", v2, v3, v4, v5, v6);
}

void sub_10074BAF4()
{
  sub_10005732C();
  sub_1000572F4((void *)&_mh_execute_header, v0, v1, "No address is found for %@", v2, v3, v4, v5, v6);
}

void sub_10074BB5C()
{
  sub_10005732C();
  sub_1000572F4((void *)&_mh_execute_header, v0, v1, "No irk or ltk is found for %@", v2, v3, v4, v5, v6);
}

void sub_10074BBC4()
{
  sub_10005732C();
  sub_1000572F4((void *)&_mh_execute_header, v0, v1, "Device %@ is not paired", v2, v3, v4, v5, v6);
}

void sub_10074BC2C()
{
  sub_10005732C();
  sub_1000572F4((void *)&_mh_execute_header, v0, v1, "Device %@ exists.", v2, v3, v4, v5, v6);
}

void sub_10074BC94()
{
  sub_10005732C();
  sub_1000572F4((void *)&_mh_execute_header, v0, v1, "Device %@ doesn't exist.", v2, v3, v4, v5, v6);
}

void sub_10074BCFC()
{
  sub_1000572E8();
  __int16 v2 = 1024;
  int v3 = 2;
  _os_log_error_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_ERROR, "setOfflineAdvertisingDataAndPayload set %d invalid, we only have %d sets", v1, 0xEu);
}

void sub_10074BD80(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_10074BDF8()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Invalid iterator", v2, v3, v4, v5, v6);
}

void sub_10074BE2C()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Error retrieving services : %d", v2, v3, v4, v5, v6);
}

void sub_10074BE94()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Invalid size input report", v2, v3, v4, v5, v6);
}

void sub_10074BEC8(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_10074BF38(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_10074BFA4(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_10074C010()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Failed to create Management HID device", v2, v3, v4, v5, v6);
}

void sub_10074C044()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Failed to create Keyboard HID device", v2, v3, v4, v5, v6);
}

void sub_10074C078()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Failed to create Mesa HID device", v2, v3, v4, v5, v6);
}

void sub_10074C0AC()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Failed to create Accelerometer HID device", v2, v3, v4, v5, v6);
}

void sub_10074C0E0(os_log_t log)
{
  *(_WORD *)uint64_t v1 = 0;
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "above error for csCreateConfigID", v1, 2u);
}

void sub_10074C124(os_log_t log)
{
  *(_WORD *)uint64_t v1 = 0;
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "Error for getting the status", v1, 2u);
}

void sub_10074C168()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "BTLQ Cannot add Link Quality Data, invalid device", v2, v3, v4, v5, v6);
}

void sub_10074C19C()
{
  sub_1000573EC();
  if (v6 != v7) {
    uint64_t v8 = v5;
  }
  else {
    uint64_t v8 = v1;
  }
  *(_DWORD *)uint64_t v2 = 136315138;
  *(void *)(v2 + 4) = v8;
  sub_100057404((void *)&_mh_execute_header, v2, v3, "BTLQ Cannot remove Link Quality Data, device (%s) not existing", v4);
  if (*(char *)(v0 + 23) < 0) {
    operator delete(*(void **)v0);
  }
}

void sub_10074C1F4()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "BTLQ Cannot set Link Quality Data, invalid device", v2, v3, v4, v5, v6);
}

void sub_10074C228()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "BTLQ Cannot set Link Quality Data, invalid data type", v2, v3, v4, v5, v6);
}

void sub_10074C25C()
{
  sub_1000573EC();
  if (v6 != v7) {
    uint64_t v8 = v5;
  }
  else {
    uint64_t v8 = v1;
  }
  *(_DWORD *)uint64_t v2 = 136315138;
  *(void *)(v2 + 4) = v8;
  sub_100057404((void *)&_mh_execute_header, v2, v3, "BTLQ Cannot set Link Quality Data, device (%s) not existing", v4);
  if (*(char *)(v0 + 23) < 0) {
    operator delete(*(void **)v0);
  }
}

void sub_10074C2B4()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "BTLQ Cannot get Link Quality Data, invalid data", v2, v3, v4, v5, v6);
}

void sub_10074C2E8()
{
  sub_1000573EC();
  if (v6 != v7) {
    uint64_t v8 = v5;
  }
  else {
    uint64_t v8 = v1;
  }
  *(_DWORD *)uint64_t v2 = 136315138;
  *(void *)(v2 + 4) = v8;
  sub_100057404((void *)&_mh_execute_header, v2, v3, "BTLQ Cannot update Link Quality Data, device (%s) not existing", v4);
  if (*(char *)(v0 + 23) < 0) {
    operator delete(*(void **)v0);
  }
}

void sub_10074C340(uint64_t a1, NSObject *a2)
{
  uint64_t v2 = "stats";
  if (!a1) {
    uint64_t v2 = "device";
  }
  int v3 = 136315138;
  uint64_t v4 = v2;
  _os_log_error_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_ERROR, "BTLQ Cannot update Link Quality Data, invalid %s", (uint8_t *)&v3, 0xCu);
}

void sub_10074C3D0()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "[BTVCBonjourService] Unable to start BTVCBonjourServiceAdvertiser", v2, v3, v4, v5, v6);
}

void sub_10074C404()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "[BTVCBonjourService] advertiser failed", v2, v3, v4, v5, v6);
}

void sub_10074C438()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "[BTVCBonjourService] Unable to start the browser", v2, v3, v4, v5, v6);
}

void sub_10074C46C(char a1, NSObject *a2)
{
  v2[0] = 67109120;
  v2[1] = a1 & 1;
  _os_log_error_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_ERROR, "[BTVCBonjourService] Got nil connection (isAdvToBrowserConnection : %d)", (uint8_t *)v2, 8u);
}

void sub_10074C4E8()
{
  sub_10005732C();
  sub_1000572F4((void *)&_mh_execute_header, v0, v1, "[BTVCBonjourService] Failed to create endpoint for connection %@", v2, v3, v4, v5, v6);
}

void sub_10074C550()
{
  sub_10005732C();
  sub_1000572F4((void *)&_mh_execute_header, v0, v1, "[BTVCBonjourService] Did not get remoteUniqueIDString from endpoint %@", v2, v3, v4, v5, v6);
}

void sub_10074C5B8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  sub_100275120(a1, a2, a3, 5.778e-34);
  sub_100057420((void *)&_mh_execute_header, v5, v3, "[BTVCBonjourService] Established [%@] connection for endpoint %@", v4);
}

void sub_10074C608(uint64_t a1, uint64_t a2, uint64_t a3)
{
  sub_100275120(a1, a2, a3, 5.778e-34);
  sub_100057420((void *)&_mh_execute_header, v5, v3, "[BTVCBonjourService] [%@] connection closed for endpoint %@", v4);
}

void sub_10074C658()
{
  sub_10027515C();
  sub_100057420((void *)&_mh_execute_header, v0, (uint64_t)v0, "[BTVCBonjourService] Unable to deserialize data: %@, for endpoint %@", v1);
}

void sub_10074C6C8()
{
  sub_10027515C();
  sub_100057420((void *)&_mh_execute_header, v0, (uint64_t)v0, "[BTVCBonjourService] Received browser endpoint message %@ from endpoint %@ without uuid", v1);
}

void sub_10074C738()
{
  sub_10005732C();
  sub_1000572F4((void *)&_mh_execute_header, v0, v1, "[BTVCBonjourService] Unable to send message, failed to serialize payload %@", v2, v3, v4, v5, v6);
}

void sub_10074C7A0()
{
  sub_100275140();
  sub_100275174((void *)&_mh_execute_header, v0, v1, "[BTVCBonjourService] Unable to send message %@ with type %@ to deviceID %@ (Invalid params)");
}

void sub_10074C814()
{
  sub_100275140();
  sub_100275174((void *)&_mh_execute_header, v0, v1, "[BTVCBonjourService] Failed to send data %@ to device %@, error %@");
}

void sub_10074C884()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "[BTVCBonjourService] Empty uniqueID!", v2, v3, v4, v5, v6);
}

void sub_10074C8B8()
{
  sub_10005732C();
  sub_1000572F4((void *)&_mh_execute_header, v0, v1, "[BTVCBonjourService] Unable to find endpoint for deviceID %@", v2, v3, v4, v5, v6);
}

void sub_10074C920(uint64_t a1)
{
  sub_10062E8E8(a1 + 192);
  uint64_t v2 = (void **)(a1 + 152);
  sub_10027696C(&v2);

  if (*(char *)(a1 + 127) < 0) {
    operator delete(*(void **)(a1 + 104));
  }
}

void sub_10074C978(os_log_t log)
{
  *(_WORD *)uint64_t v1 = 0;
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "SCO disconnect stack event never fired, cleaning up route change state", v1, 2u);
}

void sub_10074C9BC(uint64_t a1, uint64_t a2, os_log_t log)
{
  uint64_t v3 = *(void *)(a1 + 8);
  int v4 = 136446466;
  uint64_t v5 = v3;
  __int16 v6 = 2082;
  uint64_t v7 = a2;
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "XPCServiceConnection (%{public}s) event: %{public}s", (uint8_t *)&v4, 0x16u);
}

void sub_10074CA48(uint64_t a1, xpc_object_t xdict, NSObject *a3)
{
  uint64_t v4 = *(void *)(a1 + 8);
  int v5 = 136446466;
  uint64_t v6 = v4;
  __int16 v7 = 2082;
  string = xpc_dictionary_get_string(xdict, _xpc_error_key_description);
  _os_log_error_impl((void *)&_mh_execute_header, a3, OS_LOG_TYPE_ERROR, "XPCServiceConnection (%{public}s) error: %{public}s", (uint8_t *)&v5, 0x16u);
}

void sub_10074CAF8(uint64_t a1, NSObject *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  int v3 = 136446210;
  uint64_t v4 = v2;
  _os_log_error_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_ERROR, "XPCServiceConnection (%{public}s) interrupted", (uint8_t *)&v3, 0xCu);
}

void sub_10074CB74(uint64_t a1, NSObject *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  int v3 = 136446210;
  uint64_t v4 = v2;
  _os_log_error_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_ERROR, "XPCServiceConnection (%{public}s) invalidated", (uint8_t *)&v3, 0xCu);
}

void sub_10074CBF0(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_10074CC68(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_10074CCE0(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_10074CD18(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_10074CD50(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_10074CD88()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Classic Unknown CB MsgID %d", v2, v3, v4, v5, v6);
}

void sub_10074CDF0(int a1, NSObject *a2)
{
  v2[0] = 67109376;
  v2[1] = a1;
  __int16 v3 = 1024;
  int v4 = 20161219;
  _os_log_error_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_ERROR, "CoreBluetooth version %d differs from bluetoothd version %d", (uint8_t *)v2, 0xEu);
}

void sub_10074CE7C(char *a1, void *a2, NSObject *a3)
{
  if (*a1 < 0) {
    a2 = (void *)*a2;
  }
  int v3 = 136446210;
  int v4 = a2;
  sub_100057404((void *)&_mh_execute_header, (int)a2, a3, "Duplicate XPC check-in from session \"%{public}s\"", (uint8_t *)&v3);
}

void sub_10074CEF8()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Bluetooth discovery Handle Inquiry Msg: args is nil", v2, v3, v4, v5, v6);
}

void sub_10074CF2C(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_10074CFA4(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_10074D01C(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_10074D094(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_10074D10C(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_10074D184()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "handlePairingAgentRespondToPairing: Cannot accept out-of-band pairing request for classic connections", v2, v3, v4, v5, v6);
}

void sub_10074D1B8()
{
  sub_10005732C();
  sub_1000572F4((void *)&_mh_execute_header, v0, v1, "handlePairingAgentRespondToPairing: Cannot identify classic device corresponding to device\"%@\"", v2, v3, v4, v5, v6);
}

void sub_10074D220()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "handlePairingAgentRespondToPairing: Cannot accept passkey pairing request without passkey", v2, v3, v4, v5, v6);
}

void sub_10074D254()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "handleSetPeerState, invalid peer", v2, v3, v4, v5, v6);
}

void sub_10074D288()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "handleGetPeerState - can't get AccessoryManager", v2, v3, v4, v5, v6);
}

void sub_10074D2BC()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Failed to add service to local sdp", v2, v3, v4, v5, v6);
}

void sub_10074D2F0()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "L2CAP psm allocation failed: 0x%x", v2, v3, v4, v5, v6);
}

void sub_10074D358()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Service already exist", v2, v3, v4, v5, v6);
}

void sub_10074D38C(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_10074D404()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Bluetooth discoveryStatus: unknown status type %d", v2, v3, v4, v5, v6);
}

void sub_10074D46C()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Bluetooth discoveryEvent: unknown event type %d", v2, v3, v4, v5, v6);
}

void sub_10074D4D4()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "startInquiry: Failed to create a discovery agent.", v2, v3, v4, v5, v6);
}

void sub_10074D508()
{
  sub_10005732C();
  sub_1000572F4((void *)&_mh_execute_header, v0, v1, "Unparseable name bytes \"%@\"", v2, v3, v4, v5, v6);
}

void sub_10074D570(void *a1, uint64_t a2, NSObject *a3)
{
  *(_DWORD *)a2 = 138412290;
  *(void *)(a2 + 4) = a1;
  sub_100057404((void *)&_mh_execute_header, a2, a3, "Unparseable name change for the device \"%@\"", (uint8_t *)a2);
}

void sub_10074D5BC()
{
  sub_10005732C();
  sub_1000572F4((void *)&_mh_execute_header, v0, v1, "deviceNameUpdated: failed to get device uuid for %{public}@", v2, v3, v4, v5, v6);
}

void sub_10074D624()
{
  sub_10005732C();
  _os_log_debug_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_DEBUG, "Sending a name-change XPC message for the device \"%{public}@\"", v1, 0xCu);
}

void sub_10074D698(char *a1, uint64_t a2, NSObject *a3)
{
  if (a1[23] >= 0) {
    uint64_t v4 = a1;
  }
  else {
    uint64_t v4 = *(char **)a1;
  }
  *(_DWORD *)a2 = 136446210;
  *(void *)(a2 + 4) = v4;
  sub_100057404((void *)&_mh_execute_header, a2, a3, "deviceInfoChanged: failed to get device uuid for %{public}s", (uint8_t *)a2);
  if (a1[23] < 0) {
    operator delete(*(void **)a1);
  }
}

void sub_10074D700()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to register psm with result 0x%x", v2, v3, v4, v5, v6);
}

void sub_10074D768()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "addServiceDataToLocalSDP: service record data is nil", v2, v3, v4, v5, v6);
}

void sub_10074D79C()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "addServiceDataToLocalSDP: service record data is empty", v2, v3, v4, v5, v6);
}

void sub_10074D7D0()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "addServiceDataToLocalSDP: can't allocate SDP attributes", v2, v3, v4, v5, v6);
}

void sub_10074D804(uint8_t *buf, unsigned char *a2, os_log_t log)
{
  *uint64_t buf = 0;
  *a2 = 0;
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "addServiceDataToLocalSDP: null uuids", buf, 2u);
}

void sub_10074D844()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "addServiceDataToLocalSDP: Error could not add service record %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_10074D8AC()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Service must include a UUID", v2, v3, v4, v5, v6);
}

void sub_10074D8E0()
{
  sub_10005732C();
  __int16 v3 = 1024;
  int v4 = v0;
  _os_log_error_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_ERROR, "There is already a service handling %@ with handle %X", v2, 0x12u);
}

void sub_10074D964(uint8_t *buf, unsigned char *a2, os_log_t log)
{
  *uint64_t buf = 0;
  *a2 = 0;
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "addServiceDataToLocalSDP: Currently not validating 16Byte UUIDs", buf, 2u);
}

void sub_10074D9A4(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_10074DA14(uint64_t a1, NSObject *a2)
{
  sub_100475EE0(a1, (uint64_t)__p);
  if (v5 >= 0) {
    __int16 v3 = __p;
  }
  else {
    __int16 v3 = (void **)__p[0];
  }
  *(_DWORD *)uint64_t buf = 136315138;
  __int16 v7 = v3;
  _os_log_error_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_ERROR, "addStaleAACPConnReqDev : device \"%s\" is already in the stale AACP connection device list", buf, 0xCu);
  if (v5 < 0) {
    operator delete(__p[0]);
  }
}

void sub_10074DAD4()
{
  sub_1000573EC();
  if (v4 != v5) {
    uint64_t v6 = v3;
  }
  else {
    uint64_t v6 = v1;
  }
  sub_100057464(v2, v6, 4.8751e-34);
  sub_100057404((void *)&_mh_execute_header, v7, v8, "No AACP connection for device %{public}s", v9);
  if (*(char *)(v0 + 23) < 0) {
    operator delete(*(void **)v0);
  }
}

void sub_10074DB28()
{
  sub_1002B7074();
  if (v6 >= 0) {
    int v7 = v1;
  }
  else {
    int v7 = (void *)*v1;
  }
  *(_DWORD *)uint64_t v2 = 136446466;
  *(void *)(v2 + 4) = v7;
  *(_WORD *)(v2 + 12) = 1024;
  *(_DWORD *)(v2 + 14) = v3;
  sub_1000574B8((void *)&_mh_execute_header, v5, v3, "connecting to %{public}s failed, result %d", v4);
  if (*(char *)(v0 + 23) < 0) {
    operator delete(*(void **)v0);
  }
}

void sub_10074DB98()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "getBatteryInfo was not sent successfully. Result Error Code %d", v2, v3, v4, v5, v6);
}

void sub_10074DC00()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "setRemoteDeviceName was not sent successfully. Result Error Code %d", v2, v3, v4, v5, v6);
}

void sub_10074DC68()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "sendControlCommand: No stack", v2, v3, v4, v5, v6);
}

void sub_10074DC9C()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "sendControlCommand: Unknown request type", v2, v3, v4, v5, v6);
}

void sub_10074DCD0(char *a1, uint64_t a2, uint64_t a3, void *a4)
{
  if (a1[23] >= 0) {
    uint8_t v6 = a1;
  }
  else {
    uint8_t v6 = *(char **)a1;
  }
  sub_100057464(a2, (uint64_t)v6, 4.8751e-34);
  sub_100057404((void *)&_mh_execute_header, v7, v8, "No AACP connection for device %{public}s", v9);
  if (a1[23] < 0) {
    operator delete(*(void **)a1);
  }
  *a4 = qword_100A19E38;
}

void sub_10074DD48(uint64_t a1, uint64_t a2, NSObject *a3)
{
  LOWORD(v3) = 1024;
  HIWORD(v3) = *(unsigned __int8 *)(a2 + 9);
  sub_100057498((void *)&_mh_execute_header, a2, a3, "Set ListeningMode : for in-ear support audio headsets, ANC mode cannot be enabled if both sides are not in-ear: primary bud = %d , secondary bud = %d", 67109376, v3);
}

void sub_10074DDC8()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "sendControlCommand: Deprecated magnet settings sync for double click interval", v2, v3, v4, v5, v6);
}

void sub_10074DDFC()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "sendControlCommand: Deprecated magnet settings sync for click hold interval", v2, v3, v4, v5, v6);
}

void sub_10074DE30()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "sendControlCommand: Deprecated iCloud/magnet settings sync for One Bud ANC mode", v2, v3, v4, v5, v6);
}

void sub_10074DE64()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Set HRM enable / disable not supported", v2, v3, v4, v5, v6);
}

void sub_10074DE98()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Received invalid device address", v2, v3, v4, v5, v6);
}

void sub_10074DECC()
{
  sub_1000573EC();
  if (v4 != v5) {
    uint64_t v6 = v3;
  }
  else {
    uint64_t v6 = v1;
  }
  sub_100057464(v2, v6, 4.8751e-34);
  sub_100057404((void *)&_mh_execute_header, v7, v8, "updateKeys: no AACP connection for device %{public}s", v9);
  if (*(char *)(v0 + 23) < 0) {
    operator delete(*(void **)v0);
  }
}

void sub_10074DF20()
{
  sub_1000573EC();
  if (v4 != v5) {
    uint64_t v6 = v3;
  }
  else {
    uint64_t v6 = v1;
  }
  sub_100057464(v2, v6, 4.8751e-34);
  sub_100057404((void *)&_mh_execute_header, v7, v8, "requestKeys: no AACP connection for device %{public}s", v9);
  if (*(char *)(v0 + 23) < 0) {
    operator delete(*(void **)v0);
  }
}

void sub_10074DF74()
{
  sub_1000573EC();
  if (v4 != v5) {
    uint64_t v6 = v3;
  }
  else {
    uint64_t v6 = v1;
  }
  sub_100057464(v2, v6, 4.8751e-34);
  sub_100057404((void *)&_mh_execute_header, v7, v8, "sendSetupCommand: no AACP connection for device %{public}s", v9);
  if (*(char *)(v0 + 23) < 0) {
    operator delete(*(void **)v0);
  }
}

void sub_10074DFC8()
{
  sub_1001004CC();
  int v2 = 998;
  _os_log_error_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_ERROR, "Relay message length -> %d exceeds MTU -> %d", v1, 0xEu);
}

void sub_10074E044()
{
  sub_1000573EC();
  if (v4 != v5) {
    uint64_t v6 = v3;
  }
  else {
    uint64_t v6 = v1;
  }
  sub_100057464(v2, v6, 4.8751e-34);
  sub_100057404((void *)&_mh_execute_header, v7, v8, "No valid AACP Connection for the target device %{public}s", v9);
  if (*(char *)(v0 + 23) < 0) {
    operator delete(*(void **)v0);
  }
}

void sub_10074E098()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Relay message request was not sent successfully. Result Error Code %d", v2, v3, v4, v5, v6);
}

void sub_10074E100()
{
  sub_1001004CC();
  int v2 = 2;
  _os_log_error_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_ERROR, "Number of connections in list -> %d exceeds maximum supported -> %d", v1, 0xEu);
}

void sub_10074E17C()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Update request for connection priority list was not sent successfully. Result Error Code %d", v2, v3, v4, v5, v6);
}

void sub_10074E1E4()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "unknown connectin priority list request type : reqType %d", v2, v3, v4, v5, v6);
}

void sub_10074E24C()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Reject TiPi connectin priority list request as a result of pending one", v2, v3, v4, v5, v6);
}

void sub_10074E280()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "GAPA alert not available", v2, v3, v4, v5, v6);
}

void sub_10074E2B4()
{
  sub_10005732C();
  sub_100057438((void *)&_mh_execute_header, v0, v1, "GAPA user responded with unknown response %ld", v2);
}

void sub_10074E320()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "GAPA URL string is malformed", v2, v3, v4, v5, v6);
}

void sub_10074E354()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "setDeviceStateOnPeerSrc: No AACP connection", v2, v3, v4, v5, v6);
}

void sub_10074E388()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "getTipiTable: No AACP connection", v2, v3, v4, v5, v6);
}

void sub_10074E3BC()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "getTipiTable: Failed to send, result %d", v2, v3, v4, v5, v6);
}

void sub_10074E424()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Failed sending call management configuration to buds ", v2, v3, v4, v5, v6);
}

void sub_10074E458()
{
  sub_1000573EC();
  if (v4 != v5) {
    uint64_t v6 = v3;
  }
  else {
    uint64_t v6 = v1;
  }
  sub_100057464(v2, v6, 4.8751e-34);
  sub_100057404((void *)&_mh_execute_header, v7, v8, "Device %{public}s has empty UUID", v9);
  if (*(char *)(v0 + 23) < 0) {
    operator delete(*(void **)v0);
  }
}

void sub_10074E4AC()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "No device found, cannot check if AACP Config Jitter Buffer is supported", v2, v3, v4, v5, v6);
}

void sub_10074E4E0()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "internalSetupAACP: No AACP connection", v2, v3, v4, v5, v6);
}

void sub_10074E514()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed registration for MKB first unlock notification with error : %u", v2, v3, v4, v5, v6);
}

void sub_10074E57C()
{
  sub_1000572DC();
  _os_log_fault_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_FAULT, "Received MKB first unlock notification, but MKBDeviceUnlockedSinceBoot returns 0", v1, 2u);
}

void sub_10074E5BC(uint64_t a1, NSObject *a2, uint64_t a3)
{
  *(_DWORD *)a1 = 136446210;
  *(void *)(a1 + 4) = "null";
  sub_100057438((void *)&_mh_execute_header, a2, a3, "getInEarStatus: No AACP connection for %{public}s", (uint8_t *)a1);
}

void sub_10074E600()
{
  sub_1000573EC();
  if (v4 != v5) {
    uint64_t v6 = v3;
  }
  else {
    uint64_t v6 = v1;
  }
  sub_100057464(v2, v6, 4.8751e-34);
  sub_100057404((void *)&_mh_execute_header, v7, v8, "getInEarStatus: No AACP connection for %{public}s", v9);
  if (*(char *)(v0 + 23) < 0) {
    operator delete(*(void **)v0);
  }
}

void sub_10074E654()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "getPrimaryBudSide: No device", v2, v3, v4, v5, v6);
}

void sub_10074E688()
{
  sub_1000573EC();
  if (v4 != v5) {
    uint64_t v6 = v3;
  }
  else {
    uint64_t v6 = v1;
  }
  sub_100057464(v2, v6, 4.8751e-34);
  sub_100057404((void *)&_mh_execute_header, v7, v8, "getPrimaryBudSide: No AACP connection for %{public}s", v9);
  if (*(char *)(v0 + 23) < 0) {
    operator delete(*(void **)v0);
  }
}

void sub_10074E6DC(void *a1, char *a2, uint64_t a3, NSObject *a4)
{
  if (a2[23] >= 0) {
    uint64_t v6 = a2;
  }
  else {
    uint64_t v6 = *(char **)a2;
  }
  *(_DWORD *)a3 = 138543618;
  *(void *)(a3 + 4) = a1;
  *(_WORD *)(a3 + 12) = 2080;
  *(void *)(a3 + 14) = v6;
  sub_100057420((void *)&_mh_execute_header, a4, a3, "Magnet link disconnect from \"%{public}@\" does not match connected magnet \"%s\"", (uint8_t *)a3);
  if (a2[23] < 0) {
    operator delete(*(void **)a2);
  }
}

void sub_10074E764()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "easyUnpair: No stack", v2, v3, v4, v5, v6);
}

void sub_10074E798()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "sendSmartRoutingInformation: Stack not ready", v2, v3, v4, v5, v6);
}

void sub_10074E7CC()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "sendSmartRoutingInformation: Failed to send SR info message with status = %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_10074E834()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "sendConversationDetectMessage: Stack not ready", v2, v3, v4, v5, v6);
}

void sub_10074E868()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "sendConversationDetectMessage: Failed to send CD Message with status = %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_10074E8D0()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "sendFeatureProxCardStatusUpdate: Stack not ready", v2, v3, v4, v5, v6);
}

void sub_10074E904()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "sendFeatureProxCardStatusUpdate: Failed to send feature prox card status update with status = %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_10074E96C()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "sendSourceContextMessage: Stack not ready", v2, v3, v4, v5, v6);
}

void sub_10074E9A0()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "sendSourceContextMessage: Failed to send source context message with status = %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_10074EA08()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "sendAdaptiveVolumeMessage: Stack not ready", v2, v3, v4, v5, v6);
}

void sub_10074EA3C()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "sendAdaptiveVolumeMessage: Failed to send adaptive volume message with status = %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_10074EAA4()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "sendPMEConfigMessage: Stack not ready", v2, v3, v4, v5, v6);
}

void sub_10074EAD8()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "sendPMEConfigMessage: Failed to send PME config message with status = %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_10074EB40()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "sendUARPData: Stack not ready", v2, v3, v4, v5, v6);
}

void sub_10074EB74()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "sendUARPData: Failed to send uarp message to buds with status = %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_10074EBDC(uint64_t a1, NSObject *a2)
{
  uint64_t v3 = sub_1006ACEAC();
  sub_10005732C();
  sub_100057438((void *)&_mh_execute_header, a2, v4, "No device found for a disconnect event from \"%@\"", v5);
}

void sub_10074EC6C()
{
  sub_1000573EC();
  if (v4 != v5) {
    uint64_t v6 = v3;
  }
  else {
    uint64_t v6 = v1;
  }
  sub_100057464(v2, v6, 4.8149e-34);
  sub_100057404((void *)&_mh_execute_header, v7, v8, "No active connection for a disconnect event from  device \"%s\"", v9);
  if (*(char *)(v0 + 23) < 0) {
    operator delete(*(void **)v0);
  }
}

void sub_10074ECC0()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "sendEvent: No AACP connection", v2, v3, v4, v5, v6);
}

void sub_10074ECF4(uint8_t *buf, unsigned char *a2, os_log_t log)
{
  *uint64_t buf = 0;
  *a2 = 0;
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "sendEASessionPacket: No existing open BTEASession", buf, 2u);
}

void sub_10074ED34()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "publishAccRemoteFirmware: No AACP connection", v2, v3, v4, v5, v6);
}

void sub_10074ED68(uint64_t a1, NSObject *a2)
{
  sub_100474E18(a1, &__p);
  sub_100057450();
  sub_100057470();
  sub_100057438((void *)&_mh_execute_header, a2, v3, "publishAccRemoteFirmware: Failed to create address string for \"%{public}s\"", v6);
  if (v5 < 0) {
    operator delete(__p);
  }
}

void sub_10074EE08(uint64_t a1, NSObject *a2)
{
  sub_100474E18(a1, &__p);
  sub_100057450();
  sub_100057470();
  sub_100057438((void *)&_mh_execute_header, a2, v3, "publishAccRemoteFirmware: Failed to create CoreAccessories connection for device %{public}s", v6);
  if (v5 < 0) {
    operator delete(__p);
  }
}

void sub_10074EEA8()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "publishAccRemoteFirmware: No FWUP session", v2, v3, v4, v5, v6);
}

void sub_10074EEDC()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "publishAccRemoteFirmware: No FWUP endpoint", v2, v3, v4, v5, v6);
}

void sub_10074EF10()
{
  sub_1000573EC();
  if (v4 != v5) {
    uint64_t v6 = v3;
  }
  else {
    uint64_t v6 = v1;
  }
  sub_100057464(v2, v6, 4.8751e-34);
  sub_100057404((void *)&_mh_execute_header, v7, v8, "publishAccRemoteFirmware: Failed to create CoreAccessories certificate endpoint for %{public}s", v9);
  if (*(char *)(v0 + 23) < 0) {
    operator delete(*(void **)v0);
  }
}

void sub_10074EF64()
{
  sub_1000573EC();
  if (v4 != v5) {
    uint64_t v6 = v3;
  }
  else {
    uint64_t v6 = v1;
  }
  sub_100057464(v2, v6, 4.8751e-34);
  sub_100057404((void *)&_mh_execute_header, v7, v8, "publishAccRemoteFirmware: No serial numbers for %{public}s", v9);
  if (*(char *)(v0 + 23) < 0) {
    operator delete(*(void **)v0);
  }
}

void sub_10074EFB8(uint64_t a1, NSObject *a2)
{
  sub_100474E18(a1, &__p);
  sub_100057450();
  sub_100057470();
  sub_100057438((void *)&_mh_execute_header, a2, v3, "publishAccRemoteFirmware: Failed to create CoreAccessories auth endpoint for device %{public}s", v6);
  if (v5 < 0) {
    operator delete(__p);
  }
}

void sub_10074F058()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "publishAccRemoteFirmware: Could not find serial number", v2, v3, v4, v5, v6);
}

void sub_10074F08C(NSObject *a1)
{
  sub_1002B7058((uint64_t)a1);
  sub_100057450();
  sub_100057470();
  sub_100057438((void *)&_mh_execute_header, a1, v2, "batteryDataInfoEvent: No device for %{public}s", v5);
  if (v4 < 0) {
    operator delete(__p);
  }
}

void sub_10074F124()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "batteryDataInfoEvent: No AACP connection", v2, v3, v4, v5, v6);
}

void sub_10074F158(NSObject *a1)
{
  sub_1002B7058((uint64_t)a1);
  sub_100057450();
  sub_100057470();
  sub_100057438((void *)&_mh_execute_header, a1, v2, "inEarStateInfoEvent: No device for %{public}s", v5);
  if (v4 < 0) {
    operator delete(__p);
  }
}

void sub_10074F1F0()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "inEarStateInfoEvent: No AACP connection", v2, v3, v4, v5, v6);
}

void sub_10074F224(NSObject *a1)
{
  sub_1002B7058((uint64_t)a1);
  sub_100057450();
  sub_100057470();
  sub_100057438((void *)&_mh_execute_header, a1, v2, "roleStateInfoEvent: No device for %{public}s", v5);
  if (v4 < 0) {
    operator delete(__p);
  }
}

void sub_10074F2BC()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "roleStateInfoEvent: No AACP connection", v2, v3, v4, v5, v6);
}

void sub_10074F2F0()
{
  sub_1000573EC();
  if (v4 != v5) {
    uint64_t v6 = v3;
  }
  else {
    uint64_t v6 = v1;
  }
  sub_100057464(v2, v6, 4.8751e-34);
  sub_100057404((void *)&_mh_execute_header, v7, v8, "No valid AACP Connection for the addr %{public}s", v9);
  if (*(char *)(v0 + 23) < 0) {
    operator delete(*(void **)v0);
  }
}

void sub_10074F344()
{
  sub_1000573EC();
  if (v4 != v5) {
    uint64_t v6 = v3;
  }
  else {
    uint64_t v6 = v1;
  }
  sub_100057464(v2, v6, 4.8149e-34);
  sub_100057404((void *)&_mh_execute_header, v7, v8, "No connection exists to notify remote stream state for %s", v9);
  if (*(char *)(v0 + 23) < 0) {
    operator delete(*(void **)v0);
  }
}

void sub_10074F398()
{
  sub_1000573EC();
  if (v4 != v5) {
    uint64_t v6 = v3;
  }
  else {
    uint64_t v6 = v1;
  }
  sub_100057464(v2, v6, 4.8149e-34);
  sub_100057404((void *)&_mh_execute_header, v7, v8, "No connection exists to set remote stream state for %s", v9);
  if (*(char *)(v0 + 23) < 0) {
    operator delete(*(void **)v0);
  }
}

void sub_10074F3EC()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Received ack for connection prioirty list request, but no request in the queue", v2, v3, v4, v5, v6);
}

void sub_10074F420()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Received ack for TiPi connection prioirty list request, but no request in the queue", v2, v3, v4, v5, v6);
}

void sub_10074F454(char *a1, unsigned __int16 *a2, uint8_t *buf, os_log_t log)
{
  if (a1[23] >= 0) {
    uint64_t v5 = a1;
  }
  else {
    uint64_t v5 = *(char **)a1;
  }
  int v6 = *a2;
  *(_DWORD *)uint64_t buf = 136446466;
  *(void *)(buf + 4) = v5;
  *((_WORD *)buf + 6) = 1024;
  *(_DWORD *)(buf + 14) = v6;
  _os_log_debug_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_DEBUG, "Received AACP_CUSTOM_MESSAGE_TYPE_SENSOR_V2 message from %{public}s: len %u", buf, 0x12u);
  if (a1[23] < 0) {
    operator delete(*(void **)a1);
  }
}

void sub_10074F4DC()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "publishW1RemoteFirmware: No AACP connection", v2, v3, v4, v5, v6);
}

void sub_10074F510(uint64_t a1, NSObject *a2)
{
  sub_1002B70A4(a1, (uint64_t)a2);
  sub_100057450();
  sub_1002B6FE4();
  sub_100057420((void *)&_mh_execute_header, a2, v3, "publishW1RemoteFirmware: Failed to create address string for \"%{private, mask.hash}s\"", v6);
  if (v5 < 0) {
    operator delete(__p);
  }
}

void sub_10074F5A8(uint64_t a1, NSObject *a2)
{
  sub_1002B70A4(a1, (uint64_t)a2);
  sub_100057450();
  sub_1002B6FE4();
  sub_100057420((void *)&_mh_execute_header, a2, v3, "publishW1RemoteFirmware: Failed to create firmware version string for \"%{private, mask.hash}s\"", v6);
  if (v5 < 0) {
    operator delete(__p);
  }
}

void sub_10074F640(uint64_t a1, NSObject *a2)
{
  sub_1002B70A4(a1, (uint64_t)a2);
  sub_100057450();
  sub_1002B6FE4();
  sub_100057420((void *)&_mh_execute_header, a2, v3, "publishW1RemoteFirmware: Failed to create hardware version string for \"%{private, mask.hash}s\"", v6);
  if (v5 < 0) {
    operator delete(__p);
  }
}

void sub_10074F6D8(uint64_t a1, NSObject *a2)
{
  sub_1002B70A4(a1, (uint64_t)a2);
  sub_100057450();
  sub_1002B6FE4();
  sub_100057420((void *)&_mh_execute_header, a2, v3, "publishW1RemoteFirmware: Failed to create CoreAcc connection for \"%{private, mask.hash}s\"", v6);
  if (v5 < 0) {
    operator delete(__p);
  }
}

void sub_10074F770(uint64_t a1, NSObject *a2)
{
  sub_1002B70A4(a1, (uint64_t)a2);
  sub_100057450();
  sub_1002B6FE4();
  sub_100057420((void *)&_mh_execute_header, a2, v3, "publishW1RemoteFirmware: Failed to create CoreAcc endpoint for \"%{private, mask.hash}s\"", v6);
  if (v5 < 0) {
    operator delete(__p);
  }
}

void sub_10074F808(NSObject *a1)
{
  sub_1002B7058((uint64_t)a1);
  sub_100057450();
  sub_100057470();
  sub_100057438((void *)&_mh_execute_header, a1, v2, "controlCommandEvent: No device for %{public}s", v5);
  if (v4 < 0) {
    operator delete(__p);
  }
}

void sub_10074F8A0()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "controlCommandEvent: No AACP connection", v2, v3, v4, v5, v6);
}

void sub_10074F8D4()
{
  sub_1000573EC();
  if (v4 != v5) {
    uint64_t v6 = v3;
  }
  else {
    uint64_t v6 = v1;
  }
  sub_100057464(v2, v6, 4.8751e-34);
  sub_100057404((void *)&_mh_execute_header, v7, v8, "versionInfoEvent: No AACP connection for %{public}s", v9);
  if (*(char *)(v0 + 23) < 0) {
    operator delete(*(void **)v0);
  }
}

void sub_10074F928()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "versionInfoEvent: Unexpected message version %u", v2, v3, v4, v5, v6);
}

void sub_10074F990()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "versionInfoEvent: Message too short (len %d)", v2, v3, v4, v5, v6);
}

void sub_10074F9F8()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "versionInfoEvent: Disallowed session index %d", v2, v3, v4, v5, v6);
}

void sub_10074FA60()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "versionInfoEvent: No CoreAcc connection", v2, v3, v4, v5, v6);
}

void sub_10074FA94(uint64_t *a1, NSObject *a2, uint64_t a3)
{
  uint64_t v3 = *a1;
  int v4 = 138412290;
  uint64_t v5 = v3;
  sub_100057438((void *)&_mh_execute_header, a2, a3, "versionInfoEvent: Error destroying connection %@", (uint8_t *)&v4);
}

void sub_10074FB08(uint64_t a1, int *a2, uint64_t a3, NSObject *a4)
{
  int v4 = *a2;
  *(_DWORD *)a3 = 138412546;
  *(void *)(a3 + 4) = a1;
  *(_WORD *)(a3 + 12) = 1024;
  *(_DWORD *)(a3 + 14) = v4;
  sub_1000574B8((void *)&_mh_execute_header, a4, a3, "versionInfoEvent: Could not open %@ (errno %d))", (uint8_t *)a3);
}

void sub_10074FB5C()
{
  sub_1002B70BC();
  sub_100057498((void *)&_mh_execute_header, v0, v1, "versionInfoEvent: string in version info is too long, count %d, stringIndex %d", v2, v3);
}

void sub_10074FBC4()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "versionInfoEvent: Could not retrieve key", v2, v3, v4, v5, v6);
}

void sub_10074FBF8(uint64_t a1, NSObject *a2)
{
  sub_10005747C(a1, __stack_chk_guard, v4);
  sub_100057450();
  sub_100057470();
  sub_100057438((void *)&_mh_execute_header, a2, v3, "eaSessionDataEvent: No AACP connection for %{public}s", v7);
  if (v6 < 0) {
    operator delete(__p);
  }
}

void sub_10074FC88(uint64_t a1, NSObject *a2)
{
  sub_10005747C(a1, __stack_chk_guard, v4);
  sub_100057450();
  sub_100057470();
  sub_100057438((void *)&_mh_execute_header, a2, v3, "eaSessionDataEvent: Received data from device %{public}s without open EA session; dropping data",
    v7);
  if (v6 < 0) {
    operator delete(__p);
  }
}

void sub_10074FD18(uint64_t a1, NSObject *a2)
{
  sub_10005747C(a1, __stack_chk_guard, v4);
  sub_100057450();
  sub_100057470();
  sub_100057438((void *)&_mh_execute_header, a2, v3, "eaSessionDataEvent: Failed to process data from device %{public}s", v7);
  if (v6 < 0) {
    operator delete(__p);
  }
}

void sub_10074FDA8(uint64_t a1, NSObject *a2)
{
  sub_10005747C(a1, __stack_chk_guard, v4);
  sub_100057450();
  sub_100057470();
  sub_100057438((void *)&_mh_execute_header, a2, v3, "authenticationDataEvent: No AACP connection for device %{public}s", v7);
  if (v6 < 0) {
    operator delete(__p);
  }
}

void sub_10074FE38(uint64_t a1, NSObject *a2)
{
  sub_10005747C(a1, __stack_chk_guard, v4);
  sub_100057450();
  sub_100057470();
  sub_100057438((void *)&_mh_execute_header, a2, v3, "authenticationDataEvent: No auth endpoint for device %{public}s", v7);
  if (v6 < 0) {
    operator delete(__p);
  }
}

void sub_10074FEC8(uint64_t a1, NSObject *a2)
{
  sub_10005747C(a1, __stack_chk_guard, v4);
  sub_100057450();
  sub_100057470();
  sub_100057438((void *)&_mh_execute_header, a2, v3, "authenticationDataEvent: Failed to process data from device %{public}s", v7);
  if (v6 < 0) {
    operator delete(__p);
  }
}

void sub_10074FF58()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "updateCertificates: did not expect to receive data for a new certificate", v2, v3, v4, v5, v6);
}

void sub_10074FF8C()
{
  sub_1002B70BC();
  sub_100057498((void *)&_mh_execute_header, v0, v1, "updateCertificates: unexpected sequence number. expected %d, actual %d", v2, v3);
}

void sub_10074FFF4()
{
  sub_10005732C();
  sub_100057438((void *)&_mh_execute_header, v0, v1, "AACPClient::getGyroInformationMessageEvent - Unexpected size of received data (%lu)", v2);
}

void sub_100750060()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "AACPClient::getGyroInformationMessageEvent - Unexpected gyroInfoVersion (%u)", v2, v3, v4, v5, v6);
}

void sub_1007500C8()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "AACPClient::getBTEventHistoryListMessageEvent: Unsupported version %u", v2, v3, v4, v5, v6);
}

void sub_100750130()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "AACPClient::getBTEventHistoryListMessageEvent: BTEventHistoryList did not have expected number of entries", v2, v3, v4, v5, v6);
}

void sub_100750164()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "contextMessageRecvEvent: No AACP connection", v2, v3, v4, v5, v6);
}

void sub_100750198()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "tipiTableEvent: No AACP connection", v2, v3, v4, v5, v6);
}

void sub_1007501CC()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "sensorStreamingConfigMessageRecvEvent: No AACP connection", v2, v3, v4, v5, v6);
}

void sub_100750200()
{
  sub_1002B7088();
  sub_1000574B8((void *)&_mh_execute_header, v0, v1, "gapaResponseEvent: No AACP connection for %.6P", v2);
}

void sub_10075026C()
{
  sub_1002B7088();
  sub_1000574B8((void *)&_mh_execute_header, v0, v1, "gapaResponseEvent: No device for %.6P", v2);
}

void sub_1007502D8()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "gapaResponseEvent: Failed to publish kCFACCProperties_Endpoint_AudioProduct_AuthResponse", v2, v3, v4, v5, v6);
}

void sub_10075030C()
{
  sub_1000573EC();
  if (v6 != v7) {
    uint64_t v8 = v5;
  }
  else {
    uint64_t v8 = v1;
  }
  *(_DWORD *)uint64_t v2 = 141558275;
  *(void *)(v2 + 4) = 1752392040;
  *(_WORD *)(v2 + 12) = 2081;
  *(void *)(v2 + 14) = v8;
  sub_100057420((void *)&_mh_execute_header, v3, (uint64_t)v3, "Unable to rename device %{private, mask.hash}s", v4);
  if (*(char *)(v0 + 23) < 0) {
    operator delete(*(void **)v0);
  }
}

void sub_10075037C()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "getCurrentCalls failed", v2, v3, v4, v5, v6);
}

void sub_1007503B0()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "unPublishW1RemoteFirmware: No AACP connection", v2, v3, v4, v5, v6);
}

void sub_1007503E4()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "unPublishW1RemoteFirmware: Error destroying connection", v2, v3, v4, v5, v6);
}

void sub_100750418()
{
  sub_10005732C();
  sub_100057438((void *)&_mh_execute_header, v0, v1, "getConnAndDevice: No AACP connection for connection %@", v2);
}

void sub_100750484()
{
  sub_10005732C();
  sub_100057438((void *)&_mh_execute_header, v0, v1, "getConnAndDevice: No Device for connection %@", v2);
}

void sub_1007504F0()
{
  sub_1002B701C();
  sub_100057420((void *)&_mh_execute_header, v0, (uint64_t)v0, "getConnAndDevice: UUIDs %@ and %@ do not match", v1);
}

void sub_100750568()
{
  sub_10005732C();
  sub_100057438((void *)&_mh_execute_header, v0, v1, "publishAccRemoteFirmware auth data: No AACP connection for connection %@; dropping data",
    v2);
}

void sub_1007505D4()
{
  sub_1002B701C();
  sub_100057420((void *)&_mh_execute_header, v0, (uint64_t)v0, "publishAccRemoteFirmware auth data: UUIDs %@ and %@ do not match", v1);
}

void sub_100750648()
{
  sub_10005732C();
  sub_100057438((void *)&_mh_execute_header, v0, v1, "publishAccRemoteFirmware EA data: No AACP connection for connection %@; dropping data",
    v2);
}

void sub_1007506B4()
{
  sub_10005732C();
  sub_100057438((void *)&_mh_execute_header, v0, v1, "publishAccRemoteFirmware EA property: No AACP connection for connection %@", v2);
}

void sub_100750720()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Dismiss invalid GAPA challenge value is NULL", v2, v3, v4, v5, v6);
}

void sub_100750754()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "publishAccRemoteFirmware GAPA handler: no CFDictionaryRef", v2, v3, v4, v5, v6);
}

void sub_100750788()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "publishAccRemoteFirmware GAPA handler: no AuthData", v2, v3, v4, v5, v6);
}

void sub_1007507BC()
{
  sub_1002B70D4();
  sub_1002B7004(v0, v1, v2, 3.8521e-34);
  sub_100057420((void *)&_mh_execute_header, v5, v3, "publishAccRemoteFirmware GAPA handler: Invalid type ID (%lu) expecting CFDataRef (%lu)", v4);
}

void sub_1007507F8()
{
  sub_1002B70D4();
  sub_1002B7004(v0, v1, v2, 3.8521e-34);
  sub_100057420((void *)&_mh_execute_header, v5, v3, "publishAccRemoteFirmware GAPA handler: Invalid type ID (%lu) expecting CFDictionaryRef (%lu)", v4);
}

void sub_100750834()
{
  sub_10005732C();
  sub_100057438((void *)&_mh_execute_header, v0, v1, "publishAccRemoteFirmware GAPA handler: Expecting 1 element got %ld", v2);
}

void sub_1007508A0()
{
  sub_1002B70D4();
  sub_1002B7004(v0, v1, v2, 3.8521e-34);
  sub_100057420((void *)&_mh_execute_header, v5, v3, "publishAccRemoteFirmware GAPA handler: Invalid type ID (%lu) expecting CFArrayRef (%lu)", v4);
}

void sub_1007508DC()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Invalid GAPAAuthState=%d dismiss challenge", v2, v3, v4, v5, v6);
}

void sub_100750944()
{
  sub_1002B70D4();
  sub_1002B7004(v0, v1, v2, 3.8521e-34);
  sub_100057420((void *)&_mh_execute_header, v5, v3, "publishAccRemoteFirmware GAPA handler: Invalid type ID (%lu) expecting CFNumberRef (%lu)", v4);
}

void sub_100750980()
{
  sub_10005732C();
  sub_100057438((void *)&_mh_execute_header, v0, v1, "publishAccRemoteFirmware cert required handler: No AACP connection for connection %@", v2);
}

void sub_1007509EC()
{
  sub_1002B701C();
  sub_100057420((void *)&_mh_execute_header, v0, (uint64_t)v0, "publishAccRemoteFirmware cert required handler: UUIDs %@ and %@ do not match", v1);
}

void sub_100750A60()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "unPublishAccRemoteFirmware: No AACP connection", v2, v3, v4, v5, v6);
}

void sub_100750A94()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "unPublishAccRemoteFirmware: Error destroying connection", v2, v3, v4, v5, v6);
}

void sub_100750AC8()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "AACPConnection: failed to retrieve pid, setting to 0", v2, v3, v4, v5, v6);
}

void sub_100750AFC(uint64_t a1, id *a2)
{
  sub_1000486F0(a1 + 704, *(void **)(a1 + 712));
  uint64_t v4 = *(void **)(a1 + 680);
  if (v4)
  {
    *(void *)(a1 + 688) = v4;
    operator delete(v4);
  }
  sub_1002B2F94((void *)(a1 + 632));

  sub_100052DA4(a1 + 536);
  uint64_t v5 = *(void **)(a1 + 504);
  if (v5)
  {
    *(void *)(a1 + 512) = v5;
    operator delete(v5);
  }
  sub_100052DA4(a1 + 440);
  sub_1002B308C((void *)(a1 + 416));

  if (*(char *)(a1 + 79) < 0)
  {
    uint8_t v6 = *(void **)(a1 + 56);
    operator delete(v6);
  }
}

void sub_100750BA4()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "dispatchCertificates: No CoreAcc connection", v2, v3, v4, v5, v6);
}

void sub_100750BD8()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "dispatchCertificates: No cert endpoint", v2, v3, v4, v5, v6);
}

void sub_100750C0C()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "dispatchCertificates: No certificates", v2, v3, v4, v5, v6);
}

void sub_100750C40(uint64_t a1, uint64_t a2, NSObject *a3)
{
  *(_DWORD *)a1 = 134217984;
  *(void *)(a1 + 4) = a2;
  sub_100057404((void *)&_mh_execute_header, a2, a3, "dispatchCertificates: Failed to publish %lu certificates", (uint8_t *)a1);
}

void sub_100750C7C(NSObject *a1, uint64_t a2, uint64_t a3)
{
  int v3 = 134217984;
  uint64_t v4 = 0x4000000000000000;
  sub_100057438((void *)&_mh_execute_header, a1, a3, "No response for TiPi connectin priority list request from Wx within %f seconds, reset pending flag", (uint8_t *)&v3);
}

void sub_100750CF4()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Invalid handle(s)", v2, v3, v4, v5, v6);
}

void sub_100750D28()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Get battery info was not sent successfully. Result Error Code %d", v2, v3, v4, v5, v6);
}

void sub_100750D90()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Get in ear state info was not sent successfully. Result Error Code %d", v2, v3, v4, v5, v6);
}

void sub_100750DF8()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Get role state info was not sent successfully. Result Error Code %d", v2, v3, v4, v5, v6);
}

void sub_100750E60()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Timestamp not sent successfully. Result Error Code %d", v2, v3, v4, v5, v6);
}

void sub_100750EC8()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "session state was not sent successfully. Result Error Code %d", v2, v3, v4, v5, v6);
}

void sub_100750F30()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "keys were not sent successfully. Result Error Code %d", v2, v3, v4, v5, v6);
}

void sub_100750F98()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "keys were not requested successfully. Result Error Code %d", v2, v3, v4, v5, v6);
}

void sub_100751000()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Disconnect was not sent successfully. Result Error Code %d", v2, v3, v4, v5, v6);
}

void sub_100751068()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "setup command was not sent successfully. Result Error Code %d", v2, v3, v4, v5, v6);
}

void sub_1007510D0()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "initAVRCPFastConnectL2CAP error creating AVRCP signal", v2, v3, v4, v5, v6);
}

void sub_100751104()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "composeAACPDescriptor error getting signaling L2CAP data", v2, v3, v4, v5, v6);
}

void sub_100751138(uint8_t *buf, unsigned char *a2, os_log_t log)
{
  *uint64_t buf = 0;
  *a2 = 0;
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "parseAACPDescriptor L2CAP signal channel not found", buf, 2u);
}

void sub_100751178()
{
  sub_1002B7074();
  sub_1002B7034(v1, v2, v3, 3.8521e-34);
  _os_log_debug_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEBUG, "parseAACPSetupComplete %lu new events added for %{private}s", v4, 0x16u);
  if (*(char *)(v0 + 23) < 0) {
    operator delete(*(void **)v0);
  }
}

void sub_1007511D4()
{
  sub_1002B7074();
  sub_1002B7034(v1, v2, v3, 3.8521e-34);
  _os_log_debug_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEBUG, "fastConnectAACPCleanup: cleaning up AACP Event queue of size %lu for %{private}s", v4, 0x16u);
  if (*(char *)(v0 + 23) < 0) {
    operator delete(*(void **)v0);
  }
}

void sub_100751230()
{
  sub_1000572E8();
  sub_1002B83E0((void *)&_mh_execute_header, v0, v1, "error = %d while initializing the mutex", v2, v3, v4, v5, v6);
}

void sub_100751298()
{
  sub_1000572E8();
  sub_1002B83E0((void *)&_mh_execute_header, v0, v1, "error = %d while calling destructor of mutex", v2, v3, v4, v5, v6);
}

void sub_100751300()
{
  sub_1000572E8();
  sub_1002B83E0((void *)&_mh_execute_header, v0, v1, "error = %d while trying to lock the mutex", v2, v3, v4, v5, v6);
}

void sub_100751368()
{
  sub_1000572E8();
  sub_1002B83E0((void *)&_mh_execute_header, v0, v1, "error = %d while trying to unlock the mutex", v2, v3, v4, v5, v6);
}

void sub_1007513D0(os_log_t log)
{
  int v1 = 136446210;
  uint64_t v2 = "!fIsLocked";
  _os_log_fault_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_FAULT, "Assertion failed: %{public}s", (uint8_t *)&v1, 0xCu);
}

void sub_100751454(os_log_t log)
{
  int v1 = 136446210;
  uint64_t v2 = "fIsLocked";
  _os_log_fault_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_FAULT, "Assertion failed: %{public}s", (uint8_t *)&v1, 0xCu);
}

void sub_1007514D8()
{
  sub_1000572E8();
  sub_1002B83E0((void *)&_mh_execute_header, v0, v1, "error = %d", v2, v3, v4, v5, v6);
}

void sub_100751540(NSObject *a1, uint64_t a2, uint64_t a3)
{
  int v3 = 136446210;
  uint64_t v4 = "transport != LE_TRANSPORT";
  sub_1002C5578((void *)&_mh_execute_header, a1, a3, "Assertion failed: %{public}s", (uint8_t *)&v3);
}

void sub_1007515BC()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Failed to initialize transport switching!", v2, v3, v4, v5, v6);
}

void sub_1007515F0()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "User forced upgrade forever !", v2, v3, v4, v5, v6);
}

void sub_100751624()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "User forced enable AWDL transport !", v2, v3, v4, v5, v6);
}

void sub_100751658()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Failed to initialize companion link!", v2, v3, v4, v5, v6);
}

void sub_10075168C()
{
  sub_1002C55B4(__stack_chk_guard);
  sub_1000572F4((void *)&_mh_execute_header, v0, v1, "Failed to create session for application \"%{public}s\"", v2, v3, v4, v5, 2u);
}

void sub_1007516F8()
{
  sub_1002C55B4(__stack_chk_guard);
  sub_1000572F4((void *)&_mh_execute_header, v0, v1, "Ignoring registration from application \"%{public}s\" as local device does not support scalable pipes", v2, v3, v4, v5, 2u);
}

void sub_100751764()
{
  sub_10005732C();
  sub_1002C5578((void *)&_mh_execute_header, v0, v1, "Endpoint \"%{public}s\" has been unregistered with pipes remaining!", v2);
}

void sub_1007517DC()
{
  sub_1000573EC();
  if (v4 != v5) {
    uint64_t v6 = v3;
  }
  else {
    uint64_t v6 = v1;
  }
  sub_100057464(v2, v6, 4.8751e-34);
  sub_1002C5578((void *)&_mh_execute_header, v7, (uint64_t)v7, "Couldn't find a registered scalable pipe for session \"%{public}s\"", v8);
  if (*(char *)(v0 + 23) < 0) {
    operator delete(*(void **)v0);
  }
}

void sub_100751834()
{
  sub_1002C55CC();
  sub_1002C5590(v1, v2, v3, 4.8752e-34);
  _os_log_error_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "Failed to register endpoint \"%{public}s\" as it is already registered by session \"%{public}s\"", v4, 0x16u);
  if (*(char *)(v0 + 23) < 0) {
    operator delete(*(void **)v0);
  }
}

void sub_100751890()
{
  sub_1002C55CC();
  sub_1002C5590(v1, v2, v3, 4.8752e-34);
  _os_log_error_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "Failed to register endpoint \"%{public}s\" as it is already pending registration by session \"%{public}s\"", v4, 0x16u);
  if (*(char *)(v0 + 23) < 0) {
    operator delete(*(void **)v0);
  }
}

void sub_1007518EC()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Set link-requirements attempting to configure an invalid handle", v2, v3, v4, v5, v6);
}

void sub_100751920(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_10075198C(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_1007519F8(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_100751A64()
{
  sub_10005732C();
  sub_1000572F4((void *)&_mh_execute_header, v0, v1, "Connection manager wasn't tracking a connection handle for device \"%{public}@\". Did we already disconnect ?", v2, v3, v4, v5, v6);
}

void sub_100751ACC(NSObject *a1, uint64_t a2, uint64_t a3)
{
  int v3 = 136446210;
  uint64_t v4 = "fUpgradeAssertion == NULL";
  sub_1002C5578((void *)&_mh_execute_header, a1, a3, "Assertion failed: %{public}s", (uint8_t *)&v3);
}

void sub_100751B48(const unsigned __int8 *a1, NSObject *a2)
{
  int v3 = sub_100031234(a1);
  sub_10005732C();
  _os_log_error_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_ERROR, "Trying to switch our key derivation method for device \"%{public}@\"", v4, 0xCu);
}

void sub_100751BE0()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Classic encryption failed to an unknown device", v2, v3, v4, v5, v6);
}

void sub_100751C14(unsigned __int8 a1, NSObject *a2)
{
  v3[0] = 67109376;
  v3[1] = a1;
  __int16 v4 = 1024;
  int v5 = sub_1000E95F0();
  _os_log_error_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_ERROR, "Transport upgrade to classic failed due to security error. peerCLVersion=%d localVersion=%d", (uint8_t *)v3, 0xEu);
}

void sub_100751CB8(void *a1, char a2, NSObject *a3)
{
  uint64_t v3 = (void *)*a1;
  if ((a2 & 1) == 0) {
    uint64_t v3 = a1;
  }
  int v4 = 136446210;
  int v5 = v3;
  sub_1002C5578((void *)&_mh_execute_header, a3, (uint64_t)a3, "Attempting to complete pending registration of endpoint \"%{public}s\" for non-existent session", (uint8_t *)&v4);
}

void sub_100751D38()
{
  sub_10005732C();
  sub_1002C5578((void *)&_mh_execute_header, v0, v1, "Endpoint \"%{public}s\" has been unregistered but wasn't marked as a zombie!", v2);
}

void sub_100751DA4()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "LE disconnect failed, can not recover pipe/handle mismatch, aborting", v2, v3, v4, v5, v6);
}

void sub_100751DD8()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Failed to create a nexus provider", v2, v3, v4, v5, v6);
}

void sub_100751E0C(os_log_t log)
{
  int v1 = 136446210;
  uint64_t v2 = "Enable";
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "%{public}s cross layer logs", (uint8_t *)&v1, 0xCu);
}

void sub_100751E90(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_100751F08()
{
  sub_1002CC760();
  __error();
  sub_1002CC71C();
  sub_1002CC734((void *)&_mh_execute_header, v0, v1, "Failed to create read dispatch source for pipe 0x%04x with result %d", v2, v3, v4, v5, v6);
}

void sub_100751F88()
{
  sub_1002CC760();
  __error();
  sub_1002CC71C();
  sub_1002CC734((void *)&_mh_execute_header, v0, v1, "Failed to create write dispatch source for pipe 0x%04x with result %d", v2, v3, v4, v5, v6);
}

void sub_100752008()
{
  sub_1002CC760();
  __error();
  sub_1002CC71C();
  sub_1002CC734((void *)&_mh_execute_header, v0, v1, "Failed to create socket pair for pipe 0x%04x with result %d", v2, v3, v4, v5, v6);
}

void sub_100752088()
{
  sub_1000574EC();
  sub_1002B83E0((void *)&_mh_execute_header, v0, v1, "Pipe 0x%04x is already registered in registerSocketInternal", v2, v3, v4, v5, v6);
}

void sub_1007520F4()
{
  sub_1002CC754();
  sub_1000574EC();
  sub_1002B83E0((void *)&_mh_execute_header, v0, v1, "Wasn't tracking a pipe info for pipe 0x%04x", v2, v3, v4, v5, v6);
}

BOOL sub_10075215C(NSObject *a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return *a2 == 0;
}

void sub_1007521EC(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_100752264()
{
  sub_1000574EC();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Got send data event for non-existant pipe 0x%04x", v2, v3, v4, v5, v6);
}

void sub_1007522D0()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "NetworkRelayParserReadAvailable self is null", v2, v3, v4, v5, v6);
}

void sub_100752304()
{
  sub_1000574EC();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Got output available data event for non-existant pipe 0x%04x", v2, v3, v4, v5, v6);
}

void sub_100752370(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_1007523E0(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_100752450(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_1007524C0()
{
  sub_1000574EC();
  sub_1002B83E0((void *)&_mh_execute_header, v0, v1, "Pipe 0x%04x is already registered in registerNetworkRelayPipe", v2, v3, v4, v5, v6);
}

void sub_10075252C()
{
  sub_1000574EC();
  sub_1002B83E0((void *)&_mh_execute_header, v0, v1, "Failed to unregister pipe 0x%04x, as it wasn't registered", v2, v3, v4, v5, v6);
}

void sub_100752598()
{
  sub_1002CC760();
  __error();
  sub_1002CC71C();
  sub_1002CC734((void *)&_mh_execute_header, v0, v1, "Failed to create read dispatch source for pipe 0x%04x with result %d", v2, v3, v4, v5, v6);
}

void sub_100752618()
{
  sub_1002CC760();
  __error();
  sub_1002CC71C();
  sub_1002CC734((void *)&_mh_execute_header, v0, v1, "Failed to create write dispatch source for pipe 0x%04x with result %d", v2, v3, v4, v5, v6);
}

void sub_100752698(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_100752704(NSObject *a1)
{
  uint64_t v2 = __error();
  uint64_t v3 = strerror(*v2);
  int v4 = 136315138;
  uint64_t v5 = v3;
  _os_log_fault_impl((void *)&_mh_execute_header, a1, OS_LOG_TYPE_FAULT, "serverChannel is NULL, error is %s", (uint8_t *)&v4, 0xCu);
}

void sub_10075279C()
{
  sub_1000574EC();
  sub_1002B83E0((void *)&_mh_execute_header, v0, v1, "Pipe 0x%04x is already registered in registerSkywalkPipe", v2, v3, v4, v5, v6);
}

void sub_100752808(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_100752874()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "pd already got freed up, return", v2, v3, v4, v5, v6);
}

void sub_1007528A8()
{
  sub_1002CC754();
  sub_1000574EC();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Dropping stack data for non-existant pipe 0x%04x", v2, v3, v4, v5, v6);
}

void sub_100752910()
{
  __error();
  sub_1002CC71C();
  sub_1002CC734((void *)&_mh_execute_header, v0, v1, "Failed to send data to socket on pipe 0x%04x with result %d", v2, v3, v4, v5, v6);
}

void sub_100752990()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Failed to grab a slot for data", v2, v3, v4, v5, v6);
}

void sub_1007529C4(unsigned char *a1, unsigned char *a2)
{
  sub_10026C69C(a1, a2);
  sub_1000574D0((void *)&_mh_execute_header, v2, v3, "Mismatch in # of bytes set for txLen", v4);
}

void sub_1007529F0(unsigned char *a1, unsigned char *a2)
{
  sub_10026C69C(a1, a2);
  sub_1000574D0((void *)&_mh_execute_header, v2, v3, "Tx : Failed to set metadata on tx packet", v4);
}

void sub_100752A1C(unsigned char *a1, unsigned char *a2)
{
  sub_10026C69C(a1, a2);
  sub_1000574D0((void *)&_mh_execute_header, v2, v3, "Tx : Failed to set buflet data length", v4);
}

void sub_100752A48(unsigned char *a1, unsigned char *a2)
{
  sub_10026C69C(a1, a2);
  sub_1000574D0((void *)&_mh_execute_header, v2, v3, "buflet data limit exceeds UINT16_MAX", v4);
}

void sub_100752A74(unsigned char *a1, unsigned char *a2)
{
  sub_10026C69C(a1, a2);
  sub_1000574D0((void *)&_mh_execute_header, v2, v3, "Failed to fetch buflet from txSlotPacket", v4);
}

void sub_100752AA0(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_100752B18(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_100752B84()
{
  sub_1000574EC();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Got stack ready for data event for non-existant pipe 0x%04x", v2, v3, v4, v5, v6);
}

void sub_100752BF0(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_100752C5C()
{
  __error();
  sub_1002CC76C();
  sub_1002CC734((void *)&_mh_execute_header, v0, v1, "Received error %d from socket on pipe 0x%04x", v2, v3, v4, v5, v6);
}

void sub_100752CE4(unsigned char *a1, unsigned char *a2)
{
  sub_10026C69C(a1, a2);
  _os_log_error_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_ERROR, "No data to write", v3, 2u);
}

void sub_100752D1C(unsigned char *a1, unsigned char *a2)
{
  sub_10026C69C(a1, a2);
  sub_1000574D0((void *)&_mh_execute_header, v2, v3, "Failed to fetch buflet from rxSlotPacket", v4);
}

void sub_100752D48(unsigned char *a1, unsigned char *a2)
{
  sub_10026C69C(a1, a2);
  sub_1000574D0((void *)&_mh_execute_header, v2, v3, "Skywalk pipes are only supported for CL", v4);
}

void sub_100752D74(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_100752DEC()
{
  sub_1002CC76C();
  int v3 = v0;
  _os_log_error_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_ERROR, "Failed to transmit network relay data from socket on pipe 0x%04x with result %{bluetooth:OI_STATUS}u", v2, 0xEu);
}

void sub_100752E6C()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Transport Disconnected", v2, v3, v4, v5, v6);
}

void sub_100752EA0(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_100752F20(uint64_t a1, unsigned int a2, os_log_t log)
{
  uint64_t v3 = *(int *)(a1 + 48);
  if (v3 >= 5) {
    uint64_t v4 = "Unknown BSM State";
  }
  else {
    uint64_t v4 = off_1009A3278[v3];
  }
  if (a2 >= 5) {
    uint64_t v5 = "Unknown BSM State";
  }
  else {
    uint64_t v5 = off_1009A3278[a2];
  }
  int v6 = 136446466;
  char v7 = v4;
  __int16 v8 = 2082;
  __int16 v9 = v5;
  _os_log_fault_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_FAULT, "BandSwitchManager: INVALID STATE TRANSITION %{public}s -> %{public}s", (uint8_t *)&v6, 0x16u);
}

void sub_100752FE4()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "BandSwitchManager: Received duplicate AoS disablement for the same device. Ignoring", v2, v3, v4, v5, v6);
}

void sub_100753018()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "BandSwitchManager: Received duplicate AoS enablement for the same device. Ignoring", v2, v3, v4, v5, v6);
}

void sub_10075304C()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "BandSwitchManager: Only 1 AoS device can be enabled at a time", v2, v3, v4, v5, v6);
}

void sub_100753080()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Ignoring AoS events as Device is missing or already disconnected", v2, v3, v4, v5, v6);
}

void sub_1007530B4()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "BandSwitchManager: Overriding Debounce failed. Using default", v2, v3, v4, v5, v6);
}

void sub_1007530E8(unsigned int a1, NSObject *a2)
{
  if (a1 > 3) {
    uint64_t v2 = "Unknown BSM State";
  }
  else {
    uint64_t v2 = off_1009A3258[a1];
  }
  int v3 = 136315394;
  uint64_t v4 = "BOOL BT::BandSwitchManager::BSMHRBBandEnable(OI_BD_ADDR *, uint8_t)";
  __int16 v5 = 2082;
  uint8_t v6 = v2;
  _os_log_fault_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_FAULT, "%s was called from %{public}s", (uint8_t *)&v3, 0x16u);
}

void sub_100753194()
{
  sub_1000572DC();
  _os_log_fault_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_FAULT, "Received a BandChanged CB for a device that bluetoothd isn't aware of", v1, 2u);
}

void sub_1007531D4()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Received a BandChanged CB for a device that BSM isn't aware of", v2, v3, v4, v5, v6);
}

void sub_100753208(uint64_t a1, NSObject *a2)
{
  sub_100474E18(a1, __p);
  if (v5 >= 0) {
    uint64_t v3 = __p;
  }
  else {
    uint64_t v3 = (void **)__p[0];
  }
  *(_DWORD *)uint64_t buf = 136446210;
  char v7 = v3;
  _os_log_error_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_ERROR, "Received an Allowed Band CB for device %{public}s that BSM isn't aware of", buf, 0xCu);
  if (v5 < 0) {
    operator delete(__p[0]);
  }
}

void sub_1007532BC(void *a1)
{
  xpc_dictionary_get_string(a1, _xpc_error_key_description);
  sub_10005732C();
  sub_1000E37A0((void *)&_mh_execute_header, v1, v2, "XPC connection error: %{public}s", v3, v4, v5, v6, v7);
}

void sub_100753340()
{
  sub_10005732C();
  sub_1000572F4((void *)&_mh_execute_header, v0, v1, "Unexpected XPC connection event: %{public}@", v2, v3, v4, v5, v6);
}

void sub_1007533A8()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Failed to allocate security task - using framework-provided bundle identifier!", v2, v3, v4, v5, v6);
}

void sub_1007533DC()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Failed to retrieve signing ID - using framework-provided bundle identifier!", v2, v3, v4, v5, v6);
}

void sub_100753410(void *a1)
{
  xpc_get_type(a1);
  sub_10005732C();
  sub_1000E37A0((void *)&_mh_execute_header, v1, v2, "XPC object is not an integer (type is %{public}@)", v3, v4, v5, v6, v7);
}

void sub_100753488(void *a1)
{
  xpc_get_type(a1);
  sub_10005732C();
  sub_1000E37A0((void *)&_mh_execute_header, v1, v2, "XPC object is neither data nor null (type is %{public}@)", v3, v4, v5, v6, v7);
}

void sub_100753500(void *a1)
{
  xpc_get_type(a1);
  sub_10005732C();
  sub_1000E37A0((void *)&_mh_execute_header, v1, v2, "XPC object is not a data (type is %{public}@)", v3, v4, v5, v6, v7);
}

void sub_100753578(void *a1)
{
  xpc_get_type(a1);
  sub_10005732C();
  sub_1000E37A0((void *)&_mh_execute_header, v1, v2, "XPC object is not an array (type is %{public}@)", v3, v4, v5, v6, v7);
}

void sub_1007535F0()
{
  sub_10005732C();
  sub_1000572F4((void *)&_mh_execute_header, v0, v1, "Unable to convert key %s to String", v2, v3, v4, v5, v6);
}

void sub_100753658()
{
  sub_10005732C();
  sub_1000572F4((void *)&_mh_execute_header, v0, v1, "Unable to convert key %s to Number", v2, v3, v4, v5, v6);
}

void sub_1007536C0()
{
  sub_10005732C();
  sub_1000572F4((void *)&_mh_execute_header, v0, v1, "Unable to convert key %s to BOOL", v2, v3, v4, v5, v6);
}

void sub_100753728()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Failed to convert array object to NSUUID", v2, v3, v4, v5, v6);
}

void sub_10075375C()
{
  sub_10005732C();
  sub_1000572F4((void *)&_mh_execute_header, v0, v1, "Unable to convert key %s to Array", v2, v3, v4, v5, v6);
}

void sub_1007537C4()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Failed to convert array object to NSData", v2, v3, v4, v5, v6);
}

void sub_1007537F8()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Failed to convert array object to NSNumber", v2, v3, v4, v5, v6);
}

void sub_10075382C(os_log_t log)
{
  int v1 = 136446210;
  uint64_t v2 = "0";
  _os_log_fault_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_FAULT, "Assertion failed: %{public}s", (uint8_t *)&v1, 0xCu);
}

void sub_1007538B0(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_1007538E8(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_100753920(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_100753958()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Shared memory has not been allocated yet, deferring read", v2, v3, v4, v5, v6);
}

void sub_10075398C()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "AudioRingBuffer::readFrameInternal, frame header cannot be wrapped around", v2, v3, v4, v5, v6);
}

void sub_1007539C0(uint64_t a1, uint64_t a2)
{
  if (*(void *)a2) {
    atomic_load((unint64_t *)(*(void *)a2 + 24));
  }
  sub_1002D711C();
  HIWORD(v6) = v2;
  sub_1000574F8((void *)&_mh_execute_header, v3, v4, "AudioRingBuffer::readFrameInternal, frame length(%lu) bigger than available buffer length (%lu)", v5, v6);
}

void sub_100753A40()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Shared memory has not been allocated yet, deferring write", v2, v3, v4, v5, v6);
}

void sub_100753A74(uint64_t a1)
{
  atomic_load((unint64_t *)(*(void *)a1 + 24));
  sub_1002D711C();
  HIWORD(v4) = v1;
  sub_1000574F8((void *)&_mh_execute_header, v1, v2, "Shared memory size (%lu bytes available) has less than requested buffer length (%lu), deferring write", v3, v4);
}

void sub_100753AF4()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "AudioRingBuffer::writeFrameHeader, frame header cannot be wrapped around", v2, v3, v4, v5, v6);
}

void sub_100753B28(uint64_t a1, NSObject *a2)
{
  uint64_t v2 = (void *)(a1 + 56);
  if (*(char *)(a1 + 79) < 0) {
    uint64_t v2 = (void *)*v2;
  }
  int v3 = 136446210;
  uint64_t v4 = v2;
  _os_log_fault_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_FAULT, "\"%{public}s\" has insufficient entitlements to send MBFramework XPC messages", (uint8_t *)&v3, 0xCu);
}

void sub_100753BB0()
{
  sub_1002D81BC();
  _os_log_error_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_ERROR, "Unable to handle MBFramework XPC message \"%{public}s\" from session \"%{public}s\"", v1, 0x16u);
}

void sub_100753C38()
{
  sub_1002D81BC();
  _os_log_debug_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_DEBUG, "Sending XPC message \"%{public}s\" to session \"%{public}s\"", v1, 0x16u);
}

void sub_100753CC0(os_log_t log)
{
  *(_WORD *)uint64_t v1 = 0;
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "XPC message with XPC_TYPE_ERROR", v1, 2u);
}

void sub_100753D04(unsigned __int8 a1, NSObject *a2)
{
  int v2 = 136315394;
  int v3 = "BTVirtualHCIEventPacket";
  __int16 v4 = 1024;
  int v5 = a1;
  _os_log_error_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_ERROR, "%s: opCode 0x%04X, malloc failed", (uint8_t *)&v2, 0x12u);
}

void sub_100753D94()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Received equal Zero keys in master key blob received", v2, v3, v4, v5, v6);
}

void sub_100753DC8(uint64_t a1, NSObject *a2)
{
  int v2 = 134217984;
  uint64_t v3 = a1;
  _os_log_error_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_ERROR, "Received wrong length of keys in master key blob: %zu", (uint8_t *)&v2, 0xCu);
}

void sub_100753E40(unsigned __int8 a1, NSObject *a2)
{
  v2[0] = 67109120;
  v2[1] = a1;
  _os_log_error_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_ERROR, "Received wrong number of keys in master key blob received %d, Expected : 2", (uint8_t *)v2, 8u);
}

void sub_100753EBC()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Received invalid key blob from cloud kit, Generating master keys to the cloudKit", v2, v3, v4, v5, v6);
}

void sub_100753EF0()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Received invalid device info blob  from cloud kit", v2, v3, v4, v5, v6);
}

void sub_100753F24()
{
  sub_1002DDCC4();
  sub_1000574F8((void *)&_mh_execute_header, v0, v1, "Received wrong len for deviceinfo blob.  Received length %lu, Expected lengths: %lu", v2, v3);
}

void sub_100753F8C(uint64_t a1, NSObject *a2)
{
  v2[0] = 68157954;
  v2[1] = 16;
  __int16 v3 = 2096;
  uint64_t v4 = a1;
  _os_log_error_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_ERROR, "upgradeDeviceToManatee Acc Master Hint:%.16P", (uint8_t *)v2, 0x12u);
}

void sub_100754014()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Client Received invalid key blob from cloud kit, Generating master keys to the cloudKit", v2, v3, v4, v5, v6);
}

void sub_100754048()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Client Received invalid key length from cloud kit.", v2, v3, v4, v5, v6);
}

void sub_10075407C()
{
  sub_1002DDCC4();
  sub_1000574F8((void *)&_mh_execute_header, v0, v1, "XPC Received wrong len for deviceinfo blob.  Received length %lu, Expected lengths: %lu", v2, v3);
}

void sub_1007540EC()
{
  sub_1002E4C18(__stack_chk_guard);
  sub_1002E4C00();
  sub_1002E4C28((void *)&_mh_execute_header, v0, v1, "[BTVCLinkAdvertiser] ### Activate with unsupported type: %ld (%s)\n", v2, v3, v4, v5, v6);
}

void sub_100754170(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_1007541A8()
{
  sub_1002E4C18(__stack_chk_guard);
  sub_1002E4C00();
  sub_1002E4C28((void *)&_mh_execute_header, v0, v1, "[BTVCLinkAdvertiser] ### Invalidate unsupported type: %ld (%s)\n", v2, v3, v4, v5, v6);
}

void sub_10075422C(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_100754264()
{
  sub_1002E4C18(__stack_chk_guard);
  sub_1002E4C00();
  sub_1002E4C28((void *)&_mh_execute_header, v0, v1, "[BTVCLinkAdvertiser] ### Restart unsupported type: %ld (%s)\n", v2, v3, v4, v5, v6);
}

void sub_1007542E8(char a1, NSObject *a2)
{
  uint64_t v2 = "";
  if (a1) {
    uint64_t v2 = "(force)";
  }
  int v3 = 136315138;
  uint64_t v4 = v2;
  _os_log_debug_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_DEBUG, "[BTVCLinkAdvertiser] RestartIfNeeded %s\n", (uint8_t *)&v3, 0xCu);
}

void sub_100754378(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_1007543B8(os_log_t log)
{
  *(_WORD *)uint64_t v1 = 0;
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "Audio Device properties copy failed, cannot send publish message", v1, 2u);
}

void sub_1007543FC(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_10075446C(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_1007544D8(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_100754550(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_1007545C8(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_100754634(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_1007546A0(int a1, NSObject *a2)
{
  v2[0] = 67109120;
  v2[1] = a1;
  _os_log_error_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_ERROR, "Unhandled command: %u", (uint8_t *)v2, 8u);
}

void sub_100754718(int a1, NSObject *a2)
{
  v2[0] = 67109120;
  v2[1] = a1;
  _os_log_error_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_ERROR, "Unhandled message: %u", (uint8_t *)v2, 8u);
}

void sub_100754790(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_100754808(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_100754880(uint64_t a1)
{
  sub_100052DA4(a1 + 224);
  sub_1000486F0(a1 + 200, *(void **)(a1 + 208));
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 184);
  if (v2) {
    sub_10008A294(v2);
  }
  int v3 = *(void **)(a1 + 136);
  if (v3)
  {
    *(void *)(a1 + 144) = v3;
    operator delete(v3);
  }
  sub_1000486F0(a1 + 104, *(void **)(a1 + 112));

  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 16);
  if (v4) {
    std::__shared_weak_count::__release_weak(v4);
  }
}

void sub_1007548F8(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_100754930(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_100754968(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_1007549A0(uint64_t a1, NSObject *a2)
{
  int v2 = 138412290;
  uint64_t v3 = a1;
  _os_log_error_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_ERROR, "Audio Timesync: - addTimestampWithMachAbsolute Error:%@", (uint8_t *)&v2, 0xCu);
}

uint64_t sub_100754A18(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 8))();
}

void sub_100754A3C()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Ignoring invalid override value (%d) for connection grace period - must be greater than 5s", v2, v3, v4, v5, v6);
}

void sub_100754AA4()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "TCC not available", v2, v3, v4, v5, v6);
}

void sub_100754AD8()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Session not found in AppSessionMap", v2, v3, v4, v5, v6);
}

void sub_100754B0C()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "registerAppSession: _registerAppInternal Invalid state", v2, v3, v4, v5, v6);
}

void sub_100754B40()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Cannot register for offline ADV key requests, feature is not enabled", v2, v3, v4, v5, v6);
}

void sub_100754B74()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "App restoration is forced disabled", v2, v3, v4, v5, v6);
}

void sub_100754BA8()
{
  sub_10005732C();
  sub_1000572F4((void *)&_mh_execute_header, v0, v1, "Failed to create session for application \"%{public}@\"", v2, v3, v4, v5, v6);
}

void sub_100754C10()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Session is really AppSessionTypeEither!", v2, v3, v4, v5, v6);
}

void sub_100754C44()
{
  sub_1000573EC();
  if (v4 != v5) {
    uint64_t v6 = v3;
  }
  else {
    uint64_t v6 = v1;
  }
  sub_100057464(v2, v6, 4.8751e-34);
  sub_100057438((void *)&_mh_execute_header, v7, (uint64_t)v7, "Failed to create session info for session \"%{public}s\"", v8);
  if (*(char *)(v0 + 23) < 0) {
    operator delete(*(void **)v0);
  }
}

void sub_100754C9C(unsigned int a1, uint64_t a2, os_log_t log)
{
  if (a1 > 3) {
    CFStringRef v3 = @"Unknown";
  }
  else {
    CFStringRef v3 = (const __CFString *)*((void *)&off_1009A5138 + (int)a1);
  }
  int v4 = 138543618;
  CFStringRef v5 = v3;
  __int16 v6 = 2048;
  uint64_t v7 = a2;
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "Couldn't find a registered %{public}@ app for invalid session '%p'", (uint8_t *)&v4, 0x16u);
}

void sub_100754D44()
{
  sub_10005732C();
  sub_1000572F4((void *)&_mh_execute_header, v0, v1, "Unexpected invalid session for application \"%{public}@\"", v2, v3, v4, v5, v6);
}

void sub_100754DAC()
{
  sub_1000573EC();
  if (v4 != v5) {
    uint64_t v6 = v3;
  }
  else {
    uint64_t v6 = v1;
  }
  sub_100057464(v2, v6, 4.8751e-34);
  sub_100057438((void *)&_mh_execute_header, v7, (uint64_t)v7, "Overriding background support for TCC-disabled session \"%{public}s\"", v8);
  if (*(char *)(v0 + 23) < 0) {
    operator delete(*(void **)v0);
  }
}

void sub_100754E04()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Failed to stop tracking for a session because there is no central session exist", v2, v3, v4, v5, v6);
}

void sub_100754E38()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "unpublishAllServicesForApp: Invalid session", v2, v3, v4, v5, v6);
}

void sub_100754E6C(uint64_t a1)
{
  sub_10030D0DC(a1, __stack_chk_guard, v7);
  sub_100057450();
  sub_100057470();
  sub_10030D0F8((void *)&_mh_execute_header, v1, v2, "Couldn't find a registered app for session \"%{public}s\"", v3, v4, v5, v6, v8, (uint64_t)__p, v11, v12, v14);
  if (v13 < 0) {
    operator delete(__pa);
  }
}

void sub_100754EF4()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Classic pairing agent doesn't exist", v2, v3, v4, v5, v6);
}

void sub_100754F28()
{
  sub_1000573EC();
  if (v4 != v5) {
    uint64_t v6 = v3;
  }
  else {
    uint64_t v6 = v1;
  }
  sub_100057464(v2, v6, 4.8751e-34);
  sub_100057438((void *)&_mh_execute_header, v7, (uint64_t)v7, "Session %{public}s is AppSessionTypeEither!", v8);
  if (*(char *)(v0 + 23) < 0) {
    operator delete(*(void **)v0);
  }
}

void sub_100754F80()
{
  sub_1000572DC();
  sub_10030D118((void *)&_mh_execute_header, v0, v1, "appSessionResurrected: Invalid state", v2, v3, v4, v5, v6);
}

void sub_100754FB4()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "retrieveServicesForApp: Invalid session", v2, v3, v4, v5, v6);
}

void sub_100754FE8()
{
  sub_1000572DC();
  sub_10030D118((void *)&_mh_execute_header, v0, v1, "appSessionTerminated: Invalid state", v2, v3, v4, v5, v6);
}

void sub_10075501C()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Failed to create classic pairing agent", v2, v3, v4, v5, v6);
}

void sub_100755050()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Classic pairing agent already exist", v2, v3, v4, v5, v6);
}

void sub_100755084(uint64_t a1, NSObject *a2)
{
  sub_10030D0DC(a1, __stack_chk_guard, v4);
  sub_100057450();
  sub_100057470();
  sub_100057438((void *)&_mh_execute_header, a2, v3, "Ignoring response as session \"%{public}s\" does not support programmatic pairing", v7);
  if (v6 < 0) {
    operator delete(__p);
  }
}

void sub_100755114()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "connectDeviceForApp: Invalid session", v2, v3, v4, v5, v6);
}

void sub_100755148()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "connectDeviceForApp: Unexpected session type '%d'", v2, v3, v4, v5, v6);
}

void sub_1007551B0()
{
  sub_10030D088();
  sub_10030D064(v1, v2, v3, 4.8752e-34);
  sub_10030D09C((void *)&_mh_execute_header, "connectDeviceForApp : Notifying listeners that %{public}s is interested in %{public}@", v4, v5);
  if (*(char *)(v0 + 23) < 0) {
    operator delete(*(void **)v0);
  }
}

void sub_100755200(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_100755270()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "updateAppConnectOptionsForDevice invalid parameters", v2, v3, v4, v5, v6);
}

void sub_1007552A4()
{
  sub_10030D088();
  if (v6 >= 0) {
    uint64_t v7 = v1;
  }
  else {
    uint64_t v7 = (void *)*v1;
  }
  *(_DWORD *)uint64_t v3 = 136315394;
  *(void *)(v3 + 4) = v7;
  *(_WORD *)(v3 + 12) = 2112;
  *(void *)(v3 + 14) = v2;
  _os_log_error_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "App %s is not interested in %@", v4, 0x16u);
  if (*(char *)(v0 + 23) < 0) {
    operator delete(*(void **)v0);
  }
}

void sub_10075531C()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "disconnectDeviceForApp invalid parameters", v2, v3, v4, v5, v6);
}

void sub_100755350()
{
  sub_10030D088();
  sub_10030D064(v1, v2, v3, 4.8752e-34);
  sub_10030D09C((void *)&_mh_execute_header, "disconnectDeviceForApp : Notifying listeners that %{public}s is not interested in %{public}@", v4, v5);
  if (*(char *)(v0 + 23) < 0) {
    operator delete(*(void **)v0);
  }
}

void sub_1007553A0()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "disconnectDeviceForApp: invalid session type", v2, v3, v4, v5, v6);
}

void sub_1007553D4()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Failed to start tracking because there is no central session exist", v2, v3, v4, v5, v6);
}

void sub_100755408()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Failed to start tracking because this session is not scanning", v2, v3, v4, v5, v6);
}

void sub_10075543C()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Failed to stop tracking because there is no central session exist", v2, v3, v4, v5, v6);
}

void sub_100755470()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "stopAdvertisingForApp: Invalid session", v2, v3, v4, v5, v6);
}

void sub_1007554A4()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "setConnectionLatency: Invalid Session", v2, v3, v4, v5, v6);
}

void sub_1007554D8()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "respondToATTRequest: Invalid Session", v2, v3, v4, v5, v6);
}

void sub_10075550C()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "sendUpdateForValue: Invalid Session", v2, v3, v4, v5, v6);
}

void sub_100755540()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "registerForConnectionEventsWithOptions: Invalid Session", v2, v3, v4, v5, v6);
}

void sub_100755574()
{
  sub_1000574EC();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "App session changed to  %d, but the session is no longer valid", v2, v3, v4, v5, v6);
}

void sub_1007555E0()
{
  sub_10005732C();
  sub_1000572F4((void *)&_mh_execute_header, v0, v1, "Could not find foreground app to handle queued pairing request for device \"%{public}@\"", v2, v3, v4, v5, v6);
}

void sub_100755648()
{
  sub_1002B7074();
  sub_10030D0B8(v1, v2, v3, 1.5047e-36);
  _os_log_error_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "Unable to read attribute ID 0x%0x for inactive session \"%{public}s\"", v4, 0x12u);
  if (*(char *)(v0 + 23) < 0) {
    operator delete(*(void **)v0);
  }
}

void sub_1007556A4()
{
  sub_10030D088();
  sub_10030D064(v1, v2, v3, 4.8752e-34);
  sub_10030D09C((void *)&_mh_execute_header, "getAttributeValue Notifying listeners that %{public}s is interested in %{public}@", v4, v5);
  if (*(char *)(v0 + 23) < 0) {
    operator delete(*(void **)v0);
  }
}

void sub_1007556F4()
{
  sub_10030D134();
  sub_1000574EC();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Unable to find session for attribute ID 0x%x", v2, v3, v4, v5, v6);
}

void sub_10075575C()
{
  sub_1000572DC();
  sub_10030D118((void *)&_mh_execute_header, v0, v1, "Cannot send empty write request!", v2, v3, v4, v5, v6);
}

void sub_100755790()
{
  sub_1002B7074();
  sub_10030D0B8(v1, v2, v3, 1.5047e-36);
  _os_log_error_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "Unable to write attribute ID 0x%0x for inactive session \"%{public}s\"", v4, 0x12u);
  if (*(char *)(v0 + 23) < 0) {
    operator delete(*(void **)v0);
  }
}

void sub_1007557EC()
{
  sub_10030D088();
  sub_10030D064(v1, v2, v3, 4.8752e-34);
  sub_10030D09C((void *)&_mh_execute_header, "setAttributeValues Notifying listeners that %{public}s is interested in %{public}@", v4, v5);
  if (*(char *)(v0 + 23) < 0) {
    operator delete(*(void **)v0);
  }
}

void sub_10075583C(uint64_t a1, NSObject *a2)
{
  sub_10003AE4C(*(void *)(a1 + 40), (uint64_t)&__p);
  sub_100057470();
  __int16 v7 = 2114;
  uint64_t v8 = v3;
  _os_log_debug_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_DEBUG, "deviceSubscribedNotification Notifying listeners that %{public}s is interested in %{public}@", buf, 0x16u);
  if (v5 < 0) {
    operator delete(__p);
  }
}

void sub_100755910()
{
  sub_10030D088();
  sub_10030D064(v1, v2, v3, 4.8752e-34);
  sub_10030D09C((void *)&_mh_execute_header, "deviceSubscribedNotification Notifying listeners that %{public}s is interested in %{public}@", v4, v5);
  if (*(char *)(v0 + 23) < 0) {
    operator delete(*(void **)v0);
  }
}

void sub_100755960()
{
  sub_10005732C();
  sub_1000572F4((void *)&_mh_execute_header, v0, v1, "Could not find session to handle pairing request for device \"%{public}@\"", v2, v3, v4, v5, v6);
}

void sub_1007559C8()
{
  sub_1000573EC();
  if (v4 != v5) {
    uint64_t v6 = v3;
  }
  else {
    uint64_t v6 = v1;
  }
  sub_100057464(v2, v6, 4.8751e-34);
  sub_100057438((void *)&_mh_execute_header, v7, (uint64_t)v7, "Trying to dispatch a pairing request to a session (%{public}s) without an XPC connection", v8);
  if (*(char *)(v0 + 23) < 0) {
    operator delete(*(void **)v0);
  }
}

void sub_100755A20()
{
  sub_10005732C();
  sub_1000572F4((void *)&_mh_execute_header, v0, v1, "Rejecting OOB pairing for device \"%{public}@\"", v2, v3, v4, v5, v6);
}

void sub_100755A88(uint64_t a1, char *a2, uint8_t *buf, os_log_t log)
{
  if (a2[23] >= 0) {
    uint64_t v5 = a2;
  }
  else {
    uint64_t v5 = *(char **)a2;
  }
  *(_DWORD *)uint64_t buf = 138543618;
  *(void *)(buf + 4) = a1;
  *((_WORD *)buf + 6) = 2082;
  *(void *)(buf + 14) = v5;
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "Device \"%{public}@\" with invalid security keys connected for session \"%{public}s\", reporting.", buf, 0x16u);
  if (a2[23] < 0) {
    operator delete(*(void **)a2);
  }
}

void sub_100755B0C()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Received a system keybag unlocked notification, but the system is still locked", v2, v3, v4, v5, v6);
}

void sub_100755B40()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "No restoration data to read", v2, v3, v4, v5, v6);
}

void sub_100755B74()
{
  sub_10005732C();
  sub_1000572F4((void *)&_mh_execute_header, v0, v1, "Reading state restoration data failed with error %{public}@", v2, v3, v4, v5, v6);
}

void sub_100755BDC()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "UN: notifyDeviceConnected Can't create BT UUID", v2, v3, v4, v5, v6);
}

void sub_100755C10(uint64_t a1, NSObject *a2)
{
  sub_100475EE0(a1, (uint64_t)&__p);
  sub_100057450();
  sub_100057470();
  _os_log_debug_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_DEBUG, "Device %{public}s is incoming, send an automatic connected notice", buf, 0xCu);
  if (v4 < 0) {
    operator delete(__p);
  }
}

void sub_100755CB4()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "UN: pairing failed %d", v2, v3, v4, v5, v6);
}

void sub_100755D1C(uint8_t *buf, unsigned char *a2, os_log_t log)
{
  *uint64_t buf = 0;
  *a2 = 0;
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "Session is AppSessionTypeEither", buf, 2u);
}

void sub_100755D5C()
{
  sub_10005732C();
  sub_1000572F4((void *)&_mh_execute_header, v0, v1, "Session Resurrected but pending TCC <%{public}@>", v2, v3, v4, v5, v6);
}

void sub_100755DC4()
{
  sub_10005732C();
  sub_1000572F4((void *)&_mh_execute_header, v0, v1, "Session Resurrected by not live <%{public}@>", v2, v3, v4, v5, v6);
}

void sub_100755E2C()
{
  sub_1000572E8();
  _os_log_debug_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_DEBUG, "AppManager::requestOfflineAdvertisingData reason %d", v1, 8u);
}

void sub_100755EA0()
{
  sub_1000573EC();
  if (v4 != v5) {
    uint64_t v6 = v3;
  }
  else {
    uint64_t v6 = v1;
  }
  sub_100057464(v2, v6, 4.8149e-34);
  _os_log_debug_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEBUG, "AppManager::updatedFindMyDevices session:%s", v8, 0xCu);
  if (*(char *)(v0 + 23) < 0) {
    operator delete(*(void **)v0);
  }
}

void sub_100755F00()
{
  sub_10005732C();
  _os_log_fault_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_FAULT, "Attempting to remove %{public}@ from  classic gatt device list with it wasn't originally tracked!", v1, 0xCu);
}

void sub_100755F74()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "AppManager is being asked to keep track of a nil classic device!", v2, v3, v4, v5, v6);
}

void sub_100755FA8()
{
  sub_10005732C();
  sub_1000572F4((void *)&_mh_execute_header, v0, v1, "Cannot get GATT transport for device %{public}@", v2, v3, v4, v5, v6);
}

void sub_100756010()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "FastLEConnection:enableFastLeConnectionWithDataToDevice Invalid session", v2, v3, v4, v5, v6);
}

void sub_100756044()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "FastLEConnection:enableFastLeConnectionWithDataToDevice Invalid session type", v2, v3, v4, v5, v6);
}

void sub_100756078()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "FastLEConnection:enableFastLeConnectionWithDataToDevice Device already used by another session", v2, v3, v4, v5, v6);
}

void sub_1007560B4(os_log_t log)
{
  *(_WORD *)uint64_t v1 = 0;
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "MobileAsset not available on this platform", v1, 2u);
}

void sub_1007560F8(os_log_t log)
{
  *(_WORD *)uint64_t v1 = 0;
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "com.apple.bluetooth.mobileassets failed setting state to done", v1, 2u);
}

void sub_10075613C(os_log_t log)
{
  *(_WORD *)uint64_t v1 = 0;
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "Attempting to send publish msg with a null properties dictionary!", v1, 2u);
}

void sub_100756180(int *a1, NSObject *a2)
{
  int v2 = *a1;
  v3[0] = 67109120;
  v3[1] = v2;
  _os_log_error_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_ERROR, "XPC publish msg create for deviceType %d failed", (uint8_t *)v3, 8u);
}

void sub_1007561FC(uint64_t a1, NSObject *a2)
{
  int v2 = 136315138;
  uint64_t v3 = a1;
  _os_log_debug_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_DEBUG, "XpcAudioPluginDevice sendPropertyUpdatedMsg for property %s", (uint8_t *)&v2, 0xCu);
}

void sub_100756274(uint64_t *a1, NSObject *a2)
{
  uint64_t v2 = *a1;
  int v3 = 136315138;
  uint64_t v4 = v2;
  _os_log_error_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_ERROR, "XPC msg create for %s failed", (uint8_t *)&v3, 0xCu);
}

void sub_1007562F0(int a1, NSObject *a2)
{
  v2[0] = 67109120;
  v2[1] = a1;
  _os_log_debug_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_DEBUG, "XpcAudioPluginDevice sendMsg for property %d", (uint8_t *)v2, 8u);
}

void sub_100756368(os_log_t log)
{
  *(_WORD *)uint64_t v1 = 0;
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "Plugin device is no longer published, cannot send close msg", v1, 2u);
}

void sub_1007563AC(unsigned __int8 *a1, uint64_t a2, os_log_t log)
{
  unsigned __int8 v3 = atomic_load(a1);
  unsigned __int8 v4 = atomic_load((unsigned __int8 *)(a2 + 41));
  v5[0] = 67109376;
  v5[1] = v3 & 1;
  __int16 v6 = 1024;
  int v7 = v4 & 1;
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "Dropping XPC message to XpcAudioPluginDevice. Invalid transitioning state (fIsPublished %d, fIsClosing %d)", (uint8_t *)v5, 0xEu);
}

void sub_100756448(int a1, NSObject *a2)
{
  v2[0] = 67109120;
  v2[1] = a1;
  _os_log_debug_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_DEBUG, "Received XpcAudioPluginDevice handleMsg %d", (uint8_t *)v2, 8u);
}

void sub_1007564C0(os_log_t log)
{
  *(_WORD *)uint64_t v1 = 0;
  _os_log_fault_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_FAULT, "Attempted to store an address of 00:00:00:00:00:00 into keychain", v1, 2u);
}

void sub_100756504(uint64_t a1, CFTypeRef cf, NSObject *a3)
{
  v4[0] = 68158466;
  v4[1] = 6;
  __int16 v5 = 2096;
  uint64_t v6 = a1;
  __int16 v7 = 2048;
  CFTypeID v8 = CFGetTypeID(cf);
  __int16 v9 = 2048;
  CFTypeID TypeID = CFDictionaryGetTypeID();
  _os_log_error_impl((void *)&_mh_execute_header, a3, OS_LOG_TYPE_ERROR, "datrStructure for device %{bluetooth:BD_ADDR}.6P) invalid %ld (expected %ld)", (uint8_t *)v4, 0x26u);
}

void sub_1007565CC()
{
  sub_100313A24();
  sub_100057518((void *)&_mh_execute_header, v0, v1, "Failed to add attributes to keychain for device %{public}s with result %d. File a radar to Bluetooth (new bugs) | iOS");
}

void sub_100756634()
{
  sub_100313A24();
  sub_100057518((void *)&_mh_execute_header, v0, v1, "failed to update keychain data for device %{public}s with result %d. trying to add it now");
}

void sub_10075669C(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_100057310((void *)&_mh_execute_header, a1, a3, "_BTKCGetDataCopy returned %d and _data is NULL", a5, a6, a7, a8, 0);
}

void sub_10075670C()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to query keychain with result %d", v2, v3, v4, v5, v6);
}

void sub_100756774()
{
  sub_1000572E8();
  _os_log_fault_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_FAULT, "Invalid security key type %d", v1, 8u);
}

void sub_1007567E8(os_log_t log)
{
  *(_WORD *)uint64_t v1 = 0;
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "Failed to create query dictionary for LE addresses", v1, 2u);
}

void sub_10075682C(uint8_t *buf, unsigned char *a2, os_log_t log)
{
  *uint64_t buf = 0;
  *a2 = 0;
  _os_log_fault_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_FAULT, "Could not find address from keychain!", buf, 2u);
}

void sub_10075686C(uint8_t *buf, unsigned char *a2, os_log_t log)
{
  *uint64_t buf = 0;
  *a2 = 0;
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "Address is zero! Skipping", buf, 2u);
}

void sub_1007568AC(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_100756924(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_10075699C()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Could not erase LE Data from local keychain with result %d", v2, v3, v4, v5, v6);
}

void sub_100756A04(os_log_t log)
{
  *(_WORD *)uint64_t v1 = 0;
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "Cannot deleteAllDataForService with invalid service name", v1, 2u);
}

void sub_100756A48(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_100756AC0(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_100756B38()
{
  sub_1000572DC();
  sub_10031659C((void *)&_mh_execute_header, v0, v1, "HFP ring threshold mode fAudioDevice invalid", v2);
}

void sub_100756B70(uint64_t *a1, NSObject *a2)
{
  uint64_t v2 = *a1;
  int v3 = 134217984;
  uint64_t v4 = v2;
  _os_log_error_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_ERROR, "HFP ring threshold mode device invalid %p", (uint8_t *)&v3, 0xCu);
}

void sub_100756BEC(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_100756C64(uint8_t *buf, void *a2, os_log_t log)
{
  *(_DWORD *)uint64_t buf = 136446210;
  *a2 = "fAudioBytesOutstanding <= MAX_VOICE_SIZE_IN_BYTES";
  _os_log_fault_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_FAULT, "Assertion failed: %{public}s", buf, 0xCu);
}

void sub_100756CB4(uint8_t *a1, unsigned char *a2, NSObject *a3)
{
  *a1 = 0;
  *a2 = 0;
  sub_10031659C((void *)&_mh_execute_header, a3, (uint64_t)a3, "No Sco Connection handle to write to", a1);
}

void sub_100756CEC(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_100756D64(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_100756DD0()
{
  sub_1000572DC();
  sub_1002E4C44((void *)&_mh_execute_header, v0, v1, "HF read fail first", v2, v3, v4, v5, v6);
}

void sub_100756E04()
{
  sub_1000572DC();
  sub_1002E4C44((void *)&_mh_execute_header, v0, v1, "HF read fail second", v2, v3, v4, v5, v6);
}

void sub_100756E38(uint64_t a1, uint64_t a2, os_log_t log)
{
  int v3 = 134218240;
  uint64_t v4 = a1;
  __int16 v5 = 2048;
  uint64_t v6 = a2;
  _os_log_fault_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_FAULT, "wrote %ld bytes to audio buffer when max size is %zu", (uint8_t *)&v3, 0x16u);
}

void sub_100756EC0(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_100756F38()
{
  sub_1000572DC();
  sub_1002E4C44((void *)&_mh_execute_header, v0, v1, "HF (AAC) read fail", v2, v3, v4, v5, v6);
}

void sub_100756F6C()
{
  sub_1000572DC();
  sub_1002E4C44((void *)&_mh_execute_header, v0, v1, "First read failed", v2, v3, v4, v5, v6);
}

void sub_100756FA0(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_10075700C()
{
  sub_1000572DC();
  sub_10031659C((void *)&_mh_execute_header, v0, v1, "AudioDevice is gone can't run handleOverwaitDetection", v2);
}

void sub_100757044()
{
  sub_1000574EC();
  sub_10033D554((void *)&_mh_execute_header, v0, v1, "is4388B0 = %d", v2, v3, v4, v5, v6);
}

void sub_1007570B8()
{
  sub_1000574EC();
  sub_10033D554((void *)&_mh_execute_header, v0, v1, "is4388C0 = %d", v2, v3, v4, v5, v6);
}

void sub_10075712C()
{
  sub_1000574EC();
  sub_10033D554((void *)&_mh_execute_header, v0, v1, "is4388C2 = %d", v2, v3, v4, v5, v6);
}

void sub_1007571A0()
{
  sub_1000574EC();
  sub_10033D554((void *)&_mh_execute_header, v0, v1, "is4399B0 = %d", v2, v3, v4, v5, v6);
}

void sub_100757214()
{
  sub_1000574EC();
  sub_10033D554((void *)&_mh_execute_header, v0, v1, "is4399C2 = %d", v2, v3, v4, v5, v6);
}

void sub_100757288()
{
  sub_1000574EC();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "blob mask configuration unsupported for this HW for PCF UUID (blobLen=%d)", v2, v3, v4, v5, v6);
}

void sub_1007572F4()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "setEnhancedMatchingRuleExtendedBlobAndMask failed with error %d", v2, v3, v4, v5, v6);
}

void sub_10075735C()
{
  sub_1000572E8();
  sub_100057498((void *)&_mh_execute_header, v0, v1, "Invalid %{bluetooth:OI_STATUS}u, %d,");
}

void sub_1007573D0()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Connection lookup failed with %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_100757438(uint64_t a1, NSObject *a2)
{
  sub_1006ACF44();
  if (v5 >= 0) {
    p_p = &__p;
  }
  else {
    p_p = __p;
  }
  *(_DWORD *)uint64_t buf = 136315138;
  __int16 v7 = p_p;
  _os_log_error_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_ERROR, "Scan Core Classic Connection Event: No device found for bt address: %s", buf, 0xCu);
  if (v5 < 0) {
    operator delete(__p);
  }
}

void sub_1007574EC(_DWORD *a1, NSObject *a2)
{
  int v2 = *(unsigned __int8 *)a1;
  int v3 = a1[1];
  int v4 = a1[2];
  int v5 = a1[3];
  int v6 = a1[4];
  int v7 = a1[5];
  int v8 = a1[6];
  int v9 = a1[7];
  int v10 = a1[8];
  int v12 = a1[9];
  int v11 = a1[10];
  v13[0] = 67111680;
  v13[1] = v2;
  __int16 v14 = 1024;
  int v15 = v3;
  __int16 v16 = 1024;
  int v17 = v4;
  __int16 v18 = 1024;
  int v19 = v5;
  __int16 v20 = 1024;
  int v21 = v6;
  __int16 v22 = 1024;
  int v23 = v7;
  __int16 v24 = 1024;
  int v25 = v8;
  __int16 v26 = 1024;
  int v27 = v9;
  __int16 v28 = 1024;
  int v29 = v10;
  __int16 v30 = 1024;
  int v31 = v12;
  __int16 v32 = 1024;
  int v33 = v11;
  _os_log_debug_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_DEBUG, "vseScanCoreBTLEStatsExtendedEvent: numAuxTries %u totalBTSCInquiryScanTime %u IDPackets %u totalTimeConnectionScan MCeLNAOn %u MCeLNABypass %u SCeLNAOn %u SCeLNABypass %u numConnectionCompleteAdvs MCeLNAOn %u MCeLNABypass %u SCeLNAOn %u SCeLNABypass %u", (uint8_t *)v13, 0x44u);
}

void sub_1007575D0(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_100757648(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_100757680(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_1007576B8()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "BTDebugDriver logging enable failed with status %x", v2, v3, v4, v5, v6);
}

void sub_100757720(NSObject *a1)
{
  int v2 = 136446466;
  uint64_t v3 = sub_100050714();
  __int16 v4 = 1024;
  int v5 = 0xFFFF;
  _os_log_error_impl((void *)&_mh_execute_header, a1, OS_LOG_TYPE_ERROR, "%{public}s (status=%{bluetooth:OI_STATUS}u)", (uint8_t *)&v2, 0x12u);
}

void sub_1007577BC()
{
  sub_1000574EC();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "readPowerCapState: Invalid length from VSCEvent(%d)", v2, v3, v4, v5, v6);
}

void sub_100757828()
{
  sub_1000574EC();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "enhancedReadPowerCapState: Invalid length from VSCEvent(%d)", v2, v3, v4, v5, v6);
}

void sub_100757894()
{
  sub_1000572E8();
  _os_log_fault_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_FAULT, "Unknown chipset %d", v1, 8u);
}

void sub_100757908(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_100757940(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_1007579B4(int a1, NSObject *a2)
{
  v2[0] = 67109376;
  v2[1] = 0;
  __int16 v3 = 1024;
  int v4 = a1;
  _os_log_error_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_ERROR, "Read controller RAM error with invalid length, status = %{bluetooth:OI_STATUS}u, size_t length = %d", (uint8_t *)v2, 0xEu);
}

void sub_100757A38(unsigned __int8 a1, uint64_t a2, NSObject *a3)
{
  LODWORD(v3) = 67109376;
  HIDWORD(v3) = a2;
  LOWORD(v4) = 1024;
  *(_DWORD *)((char *)&v4 + 2) = a1;
  sub_100057498((void *)&_mh_execute_header, a2, a3, "Read controller RAM error, status = %{bluetooth:OI_STATUS}u, size_t length = %d", v3, v4);
}

void sub_100757AB4()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Read controller RAM error, invalid length %d", v2, v3, v4, v5, v6);
}

void sub_100757B1C()
{
  sub_1000574EC();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "readControllerRam: Invalid length from VSCEvent(%d)", v2, v3, v4, v5, v6);
}

void sub_100757B88()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Error in loadMSFFileCB: CRCFlag: %d", v2, v3, v4, v5, v6);
}

void sub_100757BF0(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_100757C68(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_100757CE0(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_100757D58(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_100757DD0(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_100757E48(os_log_t log)
{
  int v1 = 136446210;
  uint64_t v2 = "fPowerAssertion == NULL";
  _os_log_fault_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_FAULT, "Assertion failed: %{public}s", (uint8_t *)&v1, 0xCu);
}

void sub_100757ECC(uint64_t a1, uint64_t a2, os_log_t log)
{
  uint64_t v3 = *(void *)(a1 + 48);
  int v4 = 136446466;
  uint64_t v5 = v3;
  __int16 v6 = 2048;
  uint64_t v7 = a2;
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "BlueTool failed to run %{public}s script with result %ld", (uint8_t *)&v4, 0x16u);
}

void sub_100757F58()
{
  sub_1000572DC();
}

void sub_100757F8C(uint64_t a1, NSObject *a2)
{
  uint64_t v2 = *(void *)(a1 + 48);
  int v3 = 136446210;
  uint64_t v4 = v2;
  _os_log_error_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_ERROR, "BlueTool timed out running %{public}s script!", (uint8_t *)&v3, 0xCu);
}

void sub_100758008(uint64_t a1, NSObject *a2)
{
  int v2 = 134217984;
  uint64_t v3 = a1;
  _os_log_debug_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_DEBUG, "Crashloop detection initial timestamp: %llu", (uint8_t *)&v2, 0xCu);
}

void sub_100758080(uint64_t a1, int a2, os_log_t log)
{
  v3[0] = 67109376;
  v3[1] = a2;
  __int16 v4 = 2048;
  uint64_t v5 = a1 - qword_100A123B0;
  _os_log_debug_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_DEBUG, "Crashloop detected %u errors in %llu", (uint8_t *)v3, 0x12u);
}

void sub_100758114(os_log_t log)
{
  v1[0] = 67109120;
  v1[1] = 0;
  _os_log_debug_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_DEBUG, "Crashloop detection reset, threshold timeout reached. Error count: %u", (uint8_t *)v1, 8u);
}

void sub_100758190(uint64_t a1, NSObject *a2)
{
  v2[0] = 67109376;
  v2[1] = dword_100A123A8;
  __int16 v3 = 2048;
  uint64_t v4 = a1;
  _os_log_debug_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_DEBUG, "Crashloop detection (%u) timestamp: %llu", (uint8_t *)v2, 0x12u);
}

void sub_10075821C(uint64_t a1, NSObject *a2)
{
  uint64_t v2 = *(void *)(a1 + 56);
  int v3 = 136446210;
  uint64_t v4 = v2;
  _os_log_error_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_ERROR, "BlueTool timed out running \"%{public}s\" command", (uint8_t *)&v3, 0xCu);
}

void sub_100758298()
{
  sub_1000572DC();
  _os_log_fault_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_FAULT, "Unable to get firmware image file buffer", v1, 2u);
}

void sub_1007582D8()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "'defaults write' disabled booting chipset simple and fast", v2, v3, v4, v5, v6);
}

void sub_10075830C()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Could not create date", v2, v3, v4, v5, v6);
}

void sub_100758340()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Could not create a wake request dictionary", v2, v3, v4, v5, v6);
}

void sub_100758374()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Could not schedule a wakeup ...", v2, v3, v4, v5, v6);
}

void sub_1007583A8(int *a1, uint8_t *buf, os_log_t log)
{
  int v3 = *a1;
  *(_DWORD *)uint64_t buf = 67109120;
  *((_DWORD *)buf + 1) = v3;
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "openpty failed with errno %d", buf, 8u);
}

void sub_1007583F4(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_10075842C(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_100758464(int *a1, uint8_t *buf, os_log_t log)
{
  int v3 = *a1;
  *(_DWORD *)uint64_t buf = 67109120;
  *((_DWORD *)buf + 1) = v3;
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "Error reading - errno is %d", buf, 8u);
}

void sub_1007584B0(NSObject *a1)
{
  int v2 = *__error();
  v3[0] = 67109120;
  v3[1] = v2;
  _os_log_error_impl((void *)&_mh_execute_header, a1, OS_LOG_TYPE_ERROR, "Failed writing to com port - errno is %d", (uint8_t *)v3, 8u);
}

void sub_100758540()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Failed to set diversity coex HAA maps", v2, v3, v4, v5, v6);
}

void sub_100758574()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Failed to set diversity cell coex configuration", v2, v3, v4, v5, v6);
}

void sub_1007585A8(os_log_t log, double a2)
{
  int v2 = 134217984;
  double v3 = a2;
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "Invalid sampling rate %f for acoustic tuning", (uint8_t *)&v2, 0xCu);
}

void sub_100758624()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Failed to start HCI tracing", v2, v3, v4, v5, v6);
}

void sub_100758658()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Invalid HCI tracing parameters specified.  Using defaults", v2, v3, v4, v5, v6);
}

void sub_10075868C(int a1, NSObject *a2)
{
  v2[0] = 67109632;
  v2[1] = a1;
  __int16 v3 = 1024;
  int v4 = 0;
  __int16 v5 = 1024;
  int v6 = 3;
  _os_log_error_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_ERROR, "SPMI Debug Control %d outside (%d,%d)", (uint8_t *)v2, 0x14u);
}

void sub_10075871C()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Failed to attach to BTDebug service", v2, v3, v4, v5, v6);
}

void sub_100758750()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Failed to attach to BTDebug service, skipping PCIe core dump", v2, v3, v4, v5, v6);
}

void sub_100758784()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Failed to create completion group for PCIe core dump", v2, v3, v4, v5, v6);
}

void sub_1007587B8()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Timeout waiting for PCIe core dump completion", v2, v3, v4, v5, v6);
}

void sub_1007587EC(int a1, NSObject *a2)
{
  v2[0] = 67109120;
  v2[1] = a1;
  _os_log_error_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_ERROR, "Issuing PCIe core dump request failed with 0x%08X", (uint8_t *)v2, 8u);
}

void sub_100758864(os_log_t log)
{
  int v1 = 136446210;
  uint64_t v2 = "refCount >= 2";
  _os_log_fault_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_FAULT, "Assertion failed: %{public}s", (uint8_t *)&v1, 0xCu);
}

void sub_1007588E8(os_log_t log)
{
  int v1 = 136446210;
  uint64_t v2 = "refCount >= 0";
  _os_log_fault_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_FAULT, "Assertion failed: %{public}s", (uint8_t *)&v1, 0xCu);
}

void sub_10075896C(os_log_t log)
{
  *(_WORD *)int v1 = 0;
  _os_log_debug_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_DEBUG, "QoS Config Flag Enabled", v1, 2u);
}

void sub_1007589B0()
{
  sub_1000572E8();
  _os_log_debug_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_DEBUG, "Unknown VSC (BD_SUPPORTED_VSC): %d", v1, 8u);
}

void sub_100758A24(uint64_t a1, NSObject *a2)
{
  int v3 = 136446210;
  uint64_t v4 = sub_10001AA04(a1, a1);
  _os_log_fault_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_FAULT, "Command is already outstanding %{public}s", (uint8_t *)&v3, 0xCu);
}

void sub_100758AB4(uint64_t a1, NSObject *a2)
{
  int v3 = 136446210;
  uint64_t v4 = sub_10001AA04(a1, a1);
  _os_log_error_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_ERROR, "Stack is not ready, cannot send %{public}s", (uint8_t *)&v3, 0xCu);
}

void sub_100758B44()
{
  sub_1000572E8();
  _os_log_fault_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_FAULT, "Invalid VSC Index %d", v1, 8u);
}

void sub_100758BB8()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to register the vendor callback with result %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_100758C20(uint64_t a1, int a2, NSObject *a3)
{
  int v5 = 136446466;
  uint8_t v6 = sub_10001AA04(a1, a1);
  __int16 v7 = 1024;
  int v8 = a2;
  _os_log_error_impl((void *)&_mh_execute_header, a3, OS_LOG_TYPE_ERROR, "%{public}s failed with result %{bluetooth:OI_STATUS}u", (uint8_t *)&v5, 0x12u);
}

void sub_100758CC0()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to register the reportDeviceErrorCB with result %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_100758D28()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to register the reportTransportErrorCb with result %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_100758D90()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Unknown chipset range 0x%x, returning reserved voice buffer as false", v2, v3, v4, v5, v6);
}

void sub_100758DF8(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_100758E70(uint64_t a1, uint64_t a2)
{
  sub_100359178(a1, a2, 4.8149e-34);
  sub_100057404((void *)&_mh_execute_header, v2, v3, "Failed to compile SQL statement with error \"%s\"", v4);
}

void sub_100758EA8(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_100758F20(sqlite3 **a1, NSObject *a2)
{
  os_log_t v3 = sqlite3_errmsg(*a1);
  int v5 = 136315138;
  uint8_t v6 = v3;
  sub_100057438((void *)&_mh_execute_header, a2, v4, "Failed to retrieve device info as there was an error executing lookup: \"%s\"", (uint8_t *)&v5);
}

void sub_100758FA8(uint64_t a1, uint64_t a2)
{
  sub_1003591A4(a1, a2);
  sub_100057450();
  sub_100057470();
  sub_100359184((void *)&_mh_execute_header, v2, v3, "Comparing friendly name: NULL Friendly Name for Device %{public}s, skipping name matching.", v4, v5, v6, v7, v8, (uint64_t)__p, v11, v12, v14);
  if (v13 < 0) {
    operator delete(__pa);
  }
}

void sub_100759038(uint64_t a1, NSObject *a2)
{
  sub_1003591A4(a1, (uint64_t)a2);
  sub_100057450();
  sub_100057470();
  sub_100057438((void *)&_mh_execute_header, a2, v3, "Unknown error encountered when searching database for make name of device %{public}s", v6);
  if (v5 < 0) {
    operator delete(__p);
  }
}

void sub_1007590D0(sqlite3 **a1, NSObject *a2)
{
  uint64_t v3 = sqlite3_errmsg(*a1);
  int v5 = 136315138;
  int v6 = v3;
  sub_100057438((void *)&_mh_execute_header, a2, v4, "Failed to retrieve device info as there was an error executing lookup: \"%s\"", (uint8_t *)&v5);
}

void sub_10075915C(uint64_t a1, uint64_t a2)
{
  sub_1003591A4(a1, a2);
  sub_100057450();
  sub_100057470();
  sub_100359184((void *)&_mh_execute_header, v2, v3, "Comparing friendly name: NULL Friendly Name for Device %{public}s, skipping name matching.", v4, v5, v6, v7, v8, (uint64_t)__p, v11, v12, v14);
  if (v13 < 0) {
    operator delete(__pa);
  }
}

void sub_1007591EC(uint64_t a1, NSObject *a2)
{
  sub_1003591A4(a1, (uint64_t)a2);
  sub_100057450();
  sub_100057470();
  sub_100057438((void *)&_mh_execute_header, a2, v3, "Unknown error encountered when searching database for make group of device %{public}s", v6);
  if (v5 < 0) {
    operator delete(__p);
  }
}

void sub_100759284(sqlite3 **a1, NSObject *a2)
{
  uint64_t v3 = sqlite3_errmsg(*a1);
  int v5 = 136315138;
  int v6 = v3;
  sub_100057438((void *)&_mh_execute_header, a2, v4, "Failed to retrieve device info as there was an error executing lookup: \"%s\"", (uint8_t *)&v5);
}

void sub_100759310(uint64_t a1, uint64_t a2)
{
  sub_100359178(a1, a2, 4.8149e-34);
  sub_100057404((void *)&_mh_execute_header, v2, v3, "Failed to bind values with error \"%s\"", v4);
}

void sub_100759348(uint64_t a1, uint64_t a2)
{
  sub_100359178(a1, a2, 4.8149e-34);
  sub_100057404((void *)&_mh_execute_header, v2, v3, "Failed to open device database with error \"%s\"", v4);
}

void sub_100759380(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_1007593F8()
{
  sub_1000572DC();
  _os_log_fault_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_FAULT, "Settings are not nil after unpairing", v1, 2u);
}

void sub_100759438(uint64_t a1)
{
  sub_100475F84(a1, (uint64_t)__p);
  sub_100057450();
  sub_100057470();
  sub_100360CB0((void *)&_mh_execute_header, v1, v2, "System has not passed first unlock (or device prefs not read yet). Do not delete device %s", v3, v4, v5, v6, v7, (uint64_t)__p[0], (uint64_t)__p[1], v9, v10);
  if (SHIBYTE(v9) < 0) {
    operator delete(__p[0]);
  }
}

void sub_1007594D0(uint64_t a1)
{
  sub_100474E18(a1, __p);
  sub_100057450();
  sub_100057470();
  sub_100360CB0((void *)&_mh_execute_header, v1, v2, "Detected bluetooth name issue : Unable to read name for %{public}s", v3, v4, v5, v6, v7, (uint64_t)__p[0], (uint64_t)__p[1], v9, v10);
  if (SHIBYTE(v9) < 0) {
    operator delete(__p[0]);
  }
}

void sub_100759568(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_1007595E0(char *a1, uint64_t a2, NSObject *a3)
{
  if (a1[23] >= 0) {
    int v4 = a1;
  }
  else {
    int v4 = *(char **)a1;
  }
  *(_DWORD *)a2 = 136446210;
  *(void *)(a2 + 4) = v4;
  sub_100057438((void *)&_mh_execute_header, a3, (uint64_t)a3, "%{public}s has no tags", (uint8_t *)a2);
  if (a1[23] < 0) {
    operator delete(*(void **)a1);
  }
}

void sub_10075964C()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Unable to allocate memory for SDP records returning", v2, v3, v4, v5, v6);
}

void sub_100759680()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Inconsistency in SDP records parsing found, wiping device cache", v2, v3, v4, v5, v6);
}

void sub_1007596B4()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Detected SDP read version failed, writing version", v2, v3, v4, v5, v6);
}

void sub_1007596E8()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "SDP Cache version invalid, wiping cache", v2, v3, v4, v5, v6);
}

void sub_10075971C()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Input attributes not EMPTY", v2, v3, v4, v5, v6);
}

void sub_100759750(uint64_t a1, NSObject *a2, uint64_t a3)
{
  int v3 = 134217984;
  uint64_t v4 = a1;
  sub_100057438((void *)&_mh_execute_header, a2, a3, "rdar://problem/66432832 attempting to write descriptorSize: %zu", (uint8_t *)&v3);
}

void sub_1007597C0(uint64_t *a1, NSObject *a2, uint64_t a3)
{
  uint64_t v3 = *a1;
  int v4 = 134217984;
  uint64_t v5 = v3;
  sub_100057438((void *)&_mh_execute_header, a2, a3, "rdar://problem/66432832 size mismatch, descriptorSize: %zu", (uint8_t *)&v4);
}

void sub_100759834(uint64_t a1, NSObject *a2, uint64_t a3)
{
  int v3 = 134217984;
  uint64_t v4 = a1;
  sub_100057438((void *)&_mh_execute_header, a2, a3, "rdar://problem/66432832 read descriptorSize: %zu from disk", (uint8_t *)&v3);
}

void sub_1007598A4()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "writeAACPVersionInfo: Invalid input", v2, v3, v4, v5, v6);
}

void sub_1007598D8(uint64_t a1)
{
  sub_10005747C(a1, __stack_chk_guard, v7);
  sub_100057450();
  sub_100057470();
  sub_100360CB0((void *)&_mh_execute_header, v1, v2, "Failed to read CaseInfo fw version for device: %{private}s", v3, v4, v5, v6, v8, (uint64_t)__p, v11, v12, v14);
  if (v13 < 0) {
    operator delete(__pa);
  }
}

void sub_100759960(uint64_t a1)
{
  sub_10005747C(a1, __stack_chk_guard, v7);
  sub_100057450();
  sub_100057470();
  sub_100360CB0((void *)&_mh_execute_header, v1, v2, "Failed to read CaseInfo message version for device: %{private}s", v3, v4, v5, v6, v8, (uint64_t)__p, v11, v12, v14);
  if (v13 < 0) {
    operator delete(__pa);
  }
}

void sub_1007599E8(uint64_t a1)
{
  sub_10005747C(a1, __stack_chk_guard, v7);
  sub_100057450();
  sub_100057470();
  sub_100360CB0((void *)&_mh_execute_header, v1, v2, "Did not write DID info for %{public}s to disk", v3, v4, v5, v6, v8, (uint64_t)__p, v11, v12, v14);
  if (v13 < 0) {
    operator delete(__pa);
  }
}

void sub_100759A70()
{
  sub_1000572DC();
  sub_10030D118((void *)&_mh_execute_header, v0, v1, "Shouldn't be trying to persist device without a UUID!", v2, v3, v4, v5, v6);
}

void sub_100759AA4()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Ignoring invalid override value (%d) for max number of seen devices to be cached on disk", v2, v3, v4, v5, v6);
}

void sub_100759B0C()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Ignoring invalid override value (%d) for max number of connected devices to be cached on disk", v2, v3, v4, v5, v6);
}

void sub_100759B74(uint64_t a1, uint64_t a2)
{
  sub_100359178(a1, a2, 4.8751e-34);
  sub_100057438((void *)&_mh_execute_header, v2, (uint64_t)v2, "Failed to load '%{public}s' cache", v3);
}

void sub_100759BB0()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed registration for MKB first unlock notification with error : %u", v2, v3, v4, v5, v6);
}

void sub_100759C18(id *a1, NSObject *a2)
{
  [*a1 friendlyNameForType:1];
  sub_10005732C();
  sub_100057438((void *)&_mh_execute_header, a2, v3, "Failed to load '%{public}s' cache", v4);
}

void sub_100759CA0()
{
  sub_1000572DC();
  sub_10030D118((void *)&_mh_execute_header, v0, v1, "Received MKB first unlock notification, but MKBDeviceUnlockedSinceBoot returns 0", v2, v3, v4, v5, v6);
}

void sub_100759CD4(void *a1, uint8_t *buf, int a3, os_log_t log)
{
  *(_DWORD *)uint64_t buf = 67109378;
  *((_DWORD *)buf + 1) = a3;
  *((_WORD *)buf + 4) = 2114;
  *(void *)(buf + 10) = a1;
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "Found %d stale paired device(s) with address %{public}@", buf, 0x12u);
}

void sub_100759D3C()
{
  sub_10036A490();
  uint64_t v1 = v0;
  *(_DWORD *)uint64_t v2 = 138543618;
  *(void *)(v2 + 4) = v3;
  *(_WORD *)(v2 + 12) = 2114;
  *(void *)(v2 + 14) = v0;
  _os_log_error_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "Rebuilding missing paired device \"%{public}@\" (%{public}@) from keychain data", v4, 0x16u);
}

void sub_100759DA0(void *a1, uint64_t a2)
{
  sub_100359178((uint64_t)a1, a2, 5.8381e-34);
  sub_100057438((void *)&_mh_execute_header, v3, (uint64_t)v3, "Attempting to recover paired device address %{public}@ without backup UUID - previous UUID will be invalidated", v4);
}

void sub_100759DEC(void **a1, NSObject *a2)
{
  uint64_t v3 = *a1;
  int v6 = 138543362;
  uint64_t v7 = v3;
  id v4 = v3;
  sub_100057438((void *)&_mh_execute_header, a2, v5, "Unable to locate device \"%{public}@\" in disk caches", (uint8_t *)&v6);
}

void sub_100759E80()
{
  sub_10036A490();
  int v1 = *v0;
  *(_DWORD *)uint64_t v2 = 136446722;
  *(void *)(v2 + 4) = v3;
  *(_WORD *)(v2 + 12) = 1024;
  *(_DWORD *)(v2 + 14) = v1;
  *(_WORD *)(v2 + 18) = 1024;
  *(_DWORD *)(v2 + 20) = 2;
  _os_log_fault_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_FAULT, "'%{public}s' database version (v%d) is not valid (current version is v%d)", v4, 0x18u);
}

void sub_100759EE4()
{
  sub_10036A490();
  sub_100057538(v0, v1, v2, 4.8752e-34);
  sub_10036A474((void *)&_mh_execute_header, "Found table-less '%{public}s' cache at \"%s\"", v3, v4);
}

void sub_100759F1C()
{
  sub_10036A490();
  sub_100057538(v0, v1, v2, 4.8752e-34);
  sub_10036A474((void *)&_mh_execute_header, "Found corrupt '%{public}s' cache at \"%s\"", v3, v4);
}

void sub_100759F54()
{
  sub_1000572DC();
  sub_10030D118((void *)&_mh_execute_header, v0, v1, "Found legacy plist on device with new cache - did migration fail?", v2, v3, v4, v5, v6);
}

void sub_100759F88()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Cache has not been loaded", v2, v3, v4, v5, v6);
}

void sub_100759FBC()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Failed to find the maximum last seen time", v2, v3, v4, v5, v6);
}

void sub_100759FF0()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Failed to count the number of last connected devices", v2, v3, v4, v5, v6);
}

void sub_10075A024()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Failed to count the number of last seen devices", v2, v3, v4, v5, v6);
}

void sub_10075A058()
{
  sub_10005732C();
  sub_1000574F8((void *)&_mh_execute_header, v0, v1, "Error converting Extended Properties dict to JSON: %@ - %@");
}

void sub_10075A0CC()
{
  sub_10005732C();
  sub_100057438((void *)&_mh_execute_header, v0, v1, "Extended Properties dict can not be converted to JSON: %@", v2);
}

void sub_10075A138()
{
  int v2 = 136446722;
  sub_10036A458();
  sub_100275174((void *)&_mh_execute_header, v0, v1, "%{public}s - JSON â%@ânot a dictionary: %@", v2);
}

void sub_10075A1AC()
{
  int v2 = 136446722;
  sub_10036A458();
  sub_100275174((void *)&_mh_execute_header, v0, v1, "%{public}s - JSON â%@â conversion error: %@", v2);
}

void sub_10075A220()
{
  int v2 = 136446722;
  sub_10036A458();
  sub_100275174((void *)&_mh_execute_header, v0, v1, "%{public}s - JSON â%@ânot a dictionary: %@", v2);
}

void sub_10075A294()
{
  int v2 = 136446722;
  sub_10036A458();
  sub_100275174((void *)&_mh_execute_header, v0, v1, "%{public}s - JSON â%@â conversion error: %@", v2);
}

void sub_10075A308()
{
  int v2 = 136446722;
  sub_10036A458();
  sub_100275174((void *)&_mh_execute_header, v0, v1, "%{public}s - JSON â%@ânot a dictionary: %@", v2);
}

void sub_10075A37C()
{
  int v2 = 136446722;
  sub_10036A458();
  sub_100275174((void *)&_mh_execute_header, v0, v1, "%{public}s - JSON â%@â conversion error: %@", v2);
}

void sub_10075A3F0()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Could not store custom properties - UUID is null", v2, v3, v4, v5, v6);
}

void sub_10075A424()
{
  sub_10005732C();
  sub_100057438((void *)&_mh_execute_header, v0, v1, "customPropertiesJSONFromDevice: failed to build statement with %@", v2);
}

void sub_10075A490(char a1, uint64_t a2, NSObject *a3)
{
  uint64_t v3 = "device is null";
  uint64_t v4 = "";
  if (a1) {
    uint64_t v3 = "";
  }
  if ((a2 & 1) == 0) {
    uint64_t v4 = "database is null";
  }
  LODWORD(v5) = 136315394;
  *(void *)((char *)&v5 + 4) = v3;
  WORD6(v5) = 2080;
  HIWORD(v5) = (_WORD)v4;
  sub_1000574F8((void *)&_mh_execute_header, a2, a3, "Could not store custom properties - %s %s", (const char *)v5, *((const char **)&v5 + 1));
}

void sub_10075A530()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "custom db read error %d", v2, v3, v4, v5, v6);
}

void sub_10075A598()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Could not load custom properties - UUID is null", v2, v3, v4, v5, v6);
}

void sub_10075A5CC(int a1, NSObject *a2)
{
  int v2 = 136315394;
  uint64_t v3 = "-[LeDeviceCache readDeviceFromDatabase:statement:]";
  __int16 v4 = 1024;
  int v5 = a1;
  _os_log_error_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_ERROR, "%s step failed with result:%d", (uint8_t *)&v2, 0x12u);
}

void sub_10075A658()
{
  sub_10036A490();
  *(_DWORD *)uint64_t v0 = 136446466;
  *(void *)(v0 + 4) = v1;
  *(_WORD *)(v0 + 12) = 2082;
  *(void *)(v0 + 14) = v2;
  sub_10036A474((void *)&_mh_execute_header, "Database returned invalid uuid for device address %{public}s (%{public}s)", v3, v4);
}

void sub_10075A6A0(uint64_t a1, uint64_t a2)
{
  sub_100359178(a1, a2, 4.8751e-34);
  _os_log_fault_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_FAULT, "Database returned empty address for device \"%{public}s\"", v3, 0xCu);
}

void sub_10075A6E4()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "evictIsNeeded found null UUID", v2, v3, v4, v5, v6);
}

void sub_10075A718(uint64_t *a1)
{
  sub_100474E18(*a1, __p);
  sub_100057450();
  HIDWORD(v11) = v1;
  sub_100360CB0((void *)&_mh_execute_header, v2, v3, "Failed to page device %{public}s for CATT", v4, v5, v6, v7, v8, (uint64_t)__p[0], (uint64_t)__p[1], v10, 2u);
  if (SHIBYTE(v10) < 0) {
    operator delete(__p[0]);
  }
}

void sub_10075A7B8(uint64_t *a1)
{
  sub_100474E18(*a1, __p);
  sub_100057450();
  HIDWORD(v11) = v1;
  sub_100360CB0((void *)&_mh_execute_header, v2, v3, "CATT already connected to %{public}s", v4, v5, v6, v7, v8, (uint64_t)__p[0], (uint64_t)__p[1], v10, 2u);
  if (SHIBYTE(v10) < 0) {
    operator delete(__p[0]);
  }
}

void sub_10075A858()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "No callback defined", v2, v3, v4, v5, v6);
}

void sub_10075A88C()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Failed to create a MIS client", v2, v3, v4, v5, v6);
}

void sub_10075A8C0()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "MIS doesn't allow more connections", v2, v3, v4, v5, v6);
}

void sub_10075A8F4()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Could not get interface", v2, v3, v4, v5, v6);
}

void sub_10075A928()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Callback already defined", v2, v3, v4, v5, v6);
}

void sub_10075A95C()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Could not get local address", v2, v3, v4, v5, v6);
}

void sub_10075A990()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Error unregistering with MIS", v2, v3, v4, v5, v6);
}

void sub_10075A9C4()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Error stopping MIS", v2, v3, v4, v5, v6);
}

void sub_10075A9F8()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Error unregistering the last host", v2, v3, v4, v5, v6);
}

void sub_10075AA2C()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Failed to add a host", v2, v3, v4, v5, v6);
}

void sub_10075AA60()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "BTStackReceiveCallBack is NULL", v2, v3, v4, v5, v6);
}

void sub_10075AA94()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Could not get io_interface", v2, v3, v4, v5, v6);
}

void sub_10075AAC8()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Failed to get the interface name", v2, v3, v4, v5, v6);
}

void sub_10075AAFC()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Failed to start MIS", v2, v3, v4, v5, v6);
}

void sub_10075AB30()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Could not _SCNetworkInterfaceCreateWithIONetworkInterfaceObject: %d", v2, v3, v4, v5, v6);
}

void sub_10075AB98()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Could not get SCPreferencesCreate: %d", v2, v3, v4, v5, v6);
}

void sub_10075AC00()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Could not SCPreferencesLock: %d", v2, v3, v4, v5, v6);
}

void sub_10075AC68()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Could not SCNetworkSetCopyCurrent: %d", v2, v3, v4, v5, v6);
}

void sub_10075ACD0()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "No service", v2, v3, v4, v5, v6);
}

void sub_10075AD04()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Could not SCNetworkSetCopyAll: %d", v2, v3, v4, v5, v6);
}

void sub_10075AD6C()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Could not SCNetworkSetAddService: %d", v2, v3, v4, v5, v6);
}

void sub_10075ADD4()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Could not SCPreferencesCommitChanges: %d", v2, v3, v4, v5, v6);
}

void sub_10075AE3C()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Could not SCPreferencesApplyChanges: %d", v2, v3, v4, v5, v6);
}

void sub_10075AEA4()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Could not SCNetworkSetEstablishDefaultInterfaceConfiguration: %d", v2, v3, v4, v5, v6);
}

void sub_10075AF0C()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Error: Could not SCNetworkServiceAddProtocolType: %d", v2, v3, v4, v5, v6);
}

void sub_10075AF74()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Error: Could not SCNetworkProtocolSetConfiguration: %d", v2, v3, v4, v5, v6);
}

void sub_10075AFDC(os_log_t log)
{
  int v1 = 136315138;
  uint64_t v2 = "sendTransport";
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "%s: fReadCompletionBlock is invalid", (uint8_t *)&v1, 0xCu);
}

void sub_10075B060(os_log_t log)
{
  int v1 = 136315138;
  uint64_t v2 = "sendTransportDelay";
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "%s: fReadCompletionBlock is invalid", (uint8_t *)&v1, 0xCu);
}

void sub_10075B0E4(int a1, uint8_t *buf, os_log_t log)
{
  *(_DWORD *)uint64_t buf = 67109120;
  *((_DWORD *)buf + 1) = a1;
  _os_log_fault_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_FAULT, "Unknown platform 0x%08x detected", buf, 8u);
}

void sub_10075B12C()
{
  sub_10027515C();
  sub_1000574F8((void *)&_mh_execute_header, v0, v1, "Error fetching group matching %@: %@");
}

void sub_10075B194(os_log_t log)
{
  int v1 = 136446210;
  uint64_t v2 = "groupId != BT_CONTACT_SYNC_NONE_GROUP";
  _os_log_fault_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_FAULT, "Assertion failed: %{public}s", (uint8_t *)&v1, 0xCu);
}

void sub_10075B218()
{
  sub_10027515C();
  sub_1000574F8((void *)&_mh_execute_header, v0, v1, "Error fetching contacts matching %@: %@");
}

void sub_10075B280(os_log_t log)
{
  int v1 = 136446210;
  uint64_t v2 = "uid <= kFakeEntryUidMax";
  _os_log_fault_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_FAULT, "Assertion failed: %{public}s", (uint8_t *)&v1, 0xCu);
}

void sub_10075B304(os_log_t log)
{
  *(_WORD *)int v1 = 0;
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "Couldn't retrieve own number -- using placeholder", v1, 2u);
}

void sub_10075B348(uint64_t a1, NSObject *a2)
{
  int v2 = 138412290;
  uint64_t v3 = a1;
  _os_log_error_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_ERROR, "Error in retrieving meCard : %@", (uint8_t *)&v2, 0xCu);
}

void sub_10075B3C0(os_log_t log)
{
  *(_WORD *)int v1 = 0;
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "Failed to resize phonebook image", v1, 2u);
}

void sub_10075B40C(uint64_t a1, xpc_object_t xdict, NSObject *a3)
{
  uint64_t v4 = *(void *)(a1 + 40);
  int v5 = 136446466;
  uint64_t v6 = v4;
  __int16 v7 = 2082;
  string = xpc_dictionary_get_string(xdict, _xpc_error_key_description);
  _os_log_error_impl((void *)&_mh_execute_header, a3, OS_LOG_TYPE_ERROR, "XPC error for message %{public}s: %{public}s", (uint8_t *)&v5, 0x16u);
}

void sub_10075B4BC(uint64_t a1, NSObject *a2)
{
  int v2 = 136446210;
  uint64_t v3 = a1;
  _os_log_error_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_ERROR, "XPC server error: %{public}s\n", (uint8_t *)&v2, 0xCu);
}

void sub_10075B534(uint64_t a1, NSObject *a2)
{
  int v2 = 136446210;
  uint64_t v3 = a1;
  _os_log_error_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_ERROR, "Unexpected XPC server event: %{public}s\n", (uint8_t *)&v2, 0xCu);
}

void sub_10075B5AC(os_log_t log)
{
  *(_WORD *)int v1 = 0;
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "Error, unable to sendMsg due to no available xpc client connections", v1, 2u);
}

void sub_10075B5F0(os_log_t log)
{
  *(_WORD *)int v1 = 0;
  _os_log_fault_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_FAULT, "[AudioDeviceManager sendMsg:] BTAudioMsgIdClose, uid is empty", v1, 2u);
}

void sub_10075B634(char *a1, void *a2, os_log_t log)
{
  if (*a1 < 0) {
    a2 = (void *)*a2;
  }
  int v3 = 136446210;
  uint64_t v4 = a2;
  _os_log_debug_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_DEBUG, "Handle incoming xpc message for %{public}s", (uint8_t *)&v3, 0xCu);
}

void sub_10075B6BC(os_log_t log)
{
  *(_WORD *)int v1 = 0;
  _os_log_fault_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_FAULT, "[AudioDeviceManager getDeviceForUID:] uid is empty", v1, 2u);
}

void sub_10075B700()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "PurpleMetrics not available", v2, v3, v4, v5, v6);
}

void sub_10075B734(uint64_t a1, NSObject *a2)
{
  int v2 = 138412546;
  uint64_t v3 = a1;
  __int16 v4 = 1024;
  int v5 = 1;
  _os_log_debug_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_DEBUG, "BT Stats for metric '%@' sent to CoreAnalytics with result %u", (uint8_t *)&v2, 0x12u);
}

void sub_10075B7BC()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "addExpandedArrayToDictionary: Invalid value for bytesPerEntry: %u", v2, v3, v4, v5, v6);
}

void sub_10075B824(int *a1, NSObject *a2)
{
  int v2 = *((char *)a1 + 31);
  int v3 = *a1;
  uint8_t v6 = (int *)*((void *)a1 + 1);
  uint64_t v4 = a1 + 2;
  uint64_t v5 = v6;
  if (v2 >= 0) {
    __int16 v7 = v4;
  }
  else {
    __int16 v7 = v5;
  }
  int v8 = 136315394;
  uint64_t v9 = v7;
  __int16 v10 = 1024;
  int v11 = v3;
  _os_log_debug_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_DEBUG, "Headtracking setting submitting following CA metric: HeadTrackingTransition:%s WxProductID:%u", (uint8_t *)&v8, 0x12u);
}

void sub_10075B8BC()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "sendAccessoryEventMetricCA: Unknown Accessory Event (%u).", v2, v3, v4, v5, v6);
}

void sub_10075B924(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_10075B99C(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_10075BA14(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_10075BA8C(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_10075BB04(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_10075BB7C()
{
  sub_1000574EC();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "sendAccessoryEventMetricCA: Gyro Bias Calibration - error code %u", v2, v3, v4, v5, v6);
}

void sub_10075BBEC()
{
  sub_1000574EC();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "sendAccessoryEventMetricCA: Gyro Bias Calibration - Invalid version %u", v2, v3, v4, v5, v6);
}

void sub_10075BC58(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_10075BCD0(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_10075BD48(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_10075BDC0(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_10075BE38(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_10075BEB0(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_10075BF28(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_10075BFA0(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_10075C018()
{
  sub_1000574EC();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "sendAccessoryEventMetricCA: Unexpected metric ID %u", v2, v3, v4, v5, v6);
}

void sub_10075C084()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "sendAccessoryEventMetricCA: PurpleMetrics not available", v2, v3, v4, v5, v6);
}

void sub_10075C0B8()
{
  sub_1000574EC();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "sendAACPMetricCA: Failed to retrieve event type for event name %u", v2, v3, v4, v5, v6);
}

void sub_10075C128()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "accessoryEventNameToEventType: Unknown Accessory Event (%u)", v2, v3, v4, v5, v6);
}

void sub_10075C190()
{
  sub_1000574EC();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Invalid eventType = %d", v2, v3, v4, v5, v6);
}

void sub_10075C1FC()
{
  sub_1000574EC();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Invalid number of days (%d) for BT power state metrics monitor, stop metrics monitoring", v2, v3, v4, v5, v6);
}

void sub_10075C268()
{
  sub_1000574EC();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "writeBTPowerStateMonitorNumOfDays failed : Invalid numOfDays = %d", v2, v3, v4, v5, v6);
}

void sub_10075C2D4()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "ConvertToBiomeSessionState returning default", v2, v3, v4, v5, v6);
}

void sub_10075C308(uint64_t a1, uint64_t a2, os_log_t log)
{
  uint64_t v3 = "is nil,";
  if (a1) {
    uint64_t v3 = "is initialized,";
  }
  int v4 = 136315394;
  uint64_t v5 = v3;
  __int16 v6 = 2112;
  uint64_t v7 = a2;
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "Invalid parameters passed to readStoredMetricValue. metricValues:%s metricsToRead:%@", (uint8_t *)&v4, 0x16u);
}

void sub_10075C3A8(void *a1, uint8_t *buf, os_log_t log)
{
  *(_DWORD *)uint64_t buf = 138412290;
  *(void *)(buf + 4) = a1;
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "GAPAPairingMetricUniqueIdSalt writePrefKey failed: %@", buf, 0xCu);
}

void sub_10075C400(char *a1, uint8_t *buf, os_log_t log)
{
  if (a1[23] >= 0) {
    int v4 = a1;
  }
  else {
    int v4 = *(char **)a1;
  }
  *(_DWORD *)uint64_t buf = 136315138;
  *(void *)(buf + 4) = v4;
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "getGAPATimingPoint addr=%s does not exist", buf, 0xCu);
  if (a1[23] < 0) {
    operator delete(*(void **)a1);
  }
}

void sub_10075C474()
{
  sub_1000574EC();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "ACL disconnected unable to set GAPA timing for timing point %d", v2, v3, v4, v5, v6);
}

void sub_10075C4E0(void *a1, uint8_t *buf, os_log_t log)
{
  *(_DWORD *)uint64_t buf = 138412290;
  *(void *)(buf + 4) = a1;
  _os_log_debug_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_DEBUG, "Audio Route Transition Metrics %@ ", buf, 0xCu);
}

void sub_10075C538()
{
  sub_1000572DC();
  _os_log_debug_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_DEBUG, "Ignoring Audio Route Transition metrics from the same address", v1, 2u);
}

void sub_10075C578(uint8_t *buf, unsigned char *a2, os_log_t log)
{
  *uint64_t buf = 0;
  *a2 = 0;
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "Error in Metrics: fLEDailyStats[key][0] is nil.", buf, 2u);
}

void sub_10075C5B8(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_10075C644(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_10075C6BC()
{
  sub_1000574EC();
  __int16 v3 = 1024;
  int v4 = v0;
  _os_log_error_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_ERROR, "calculateAndSendHIDLatencyStatsData -- unknown HIDType (%d) for handle 0x%04x", v2, 0xEu);
}

void sub_10075C748(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_10075C7C0()
{
  sub_1003BA578();
  sub_100057344((void *)&_mh_execute_header, v0, v1, "%s -- Did not find stored HID Latency Statistics data for LM Handle %d (0x%04x)", v2, v3, v4, v5, 2u);
}

void sub_10075C838(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_10075C8B0(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_10075C928(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_10075C9A0(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_10075CA18(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_10075CA90()
{
  sub_1003BA578();
  sub_100057344((void *)&_mh_execute_header, v0, v1, "%s -- No previous stored HID Latency Statistics data for LM Handle %d (0x%04x)", v2, v3, v4, v5, 2u);
}

void sub_10075CB08(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_10075CB80(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_10075CBF8(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_10075CC70(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_10075CCE8()
{
  sub_1003BA578();
  sub_100057344((void *)&_mh_execute_header, v0, v1, "%s -- No previous stored HID Latency data for LM Handle %d (0x%04x)", v2, v3, v4, v5, 2u);
}

void sub_10075CD60(uint64_t a1, uint8_t *buf, os_log_t log)
{
  uint64_t v4 = *(unsigned __int8 *)(a1 + 23);
  if ((v4 & 0x80u) != 0) {
    uint64_t v4 = *(void *)(a1 + 8);
  }
  *(_DWORD *)uint64_t buf = 134217984;
  *(void *)(buf + 4) = v4;
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "Unexpected pincode length of %lu", buf, 0xCu);
  if (*(char *)(a1 + 23) < 0) {
    operator delete(*(void **)a1);
  }
}

void sub_10075CDD8()
{
  sub_1000572E8();
  _os_log_error_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_ERROR, "Failed to write local address to keychain with result %d", v1, 8u);
}

void sub_10075CE4C()
{
  sub_1002B7074();
  sub_100057550(v1, v2, v3, 4.8752e-34);
  _os_log_error_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "Failed to write link key data for device %{public}s to keychain with result %d", v4, 0x12u);
  if (*(char *)(v0 + 23) < 0) {
    operator delete(*(void **)v0);
  }
}

void sub_10075CEA8()
{
  sub_1002B7074();
  sub_100057550(v1, v2, v3, 4.8752e-34);
  _os_log_error_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "Failed to write link key type for device %{public}s to keychain with result %d", v4, 0x12u);
  if (*(char *)(v0 + 23) < 0) {
    operator delete(*(void **)v0);
  }
}

void sub_10075CF04(uint64_t a1)
{
  sub_100600E8C(a1);
  sub_1000572E8();
  sub_1003BF490((void *)&_mh_execute_header, v1, v2, "Invalid Keytype %d", v3, v4, v5, v6, v7);
}

void sub_10075CF7C(char *a1, uint64_t a2, uint8_t *buf, os_log_t log)
{
  if (a1[23] >= 0) {
    uint64_t v5 = a1;
  }
  else {
    uint64_t v5 = *(char **)a1;
  }
  *(_DWORD *)uint64_t buf = 136446466;
  *(void *)(buf + 4) = v5;
  *((_WORD *)buf + 6) = 2080;
  *(void *)(buf + 14) = a2;
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "Failed to parse malformed magic key for device %{public}s - data was %s", buf, 0x16u);
  if (a1[23] < 0) {
    operator delete(*(void **)a1);
  }
}

void sub_10075D000()
{
  sub_1000572E8();
  sub_1002B83E0((void *)&_mh_execute_header, v0, v1, "Failed to set cloud master keys! res = %d", v2, v3, v4, v5, v6);
}

void sub_10075D068()
{
  sub_1000572E8();
  sub_1002B83E0((void *)&_mh_execute_header, v0, v1, "Failed to set cloud address keys! res = %d", v2, v3, v4, v5, v6);
}

void sub_10075D0D0()
{
  sub_1000572E8();
  sub_1002B83E0((void *)&_mh_execute_header, v0, v1, "Failed to set cloud IRK keys! res = %d", v2, v3, v4, v5, v6);
}

void sub_10075D140(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_10075D178(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_10075D1B0(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_10075D1E8()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "handleHIDEvent:forService: failed because event is nil", v2, v3, v4, v5, v6);
}

void sub_10075D21C()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "handleHIDEvent:forService: failed because service is nil", v2, v3, v4, v5, v6);
}

void sub_10075D250()
{
  sub_1003C8760();
  sub_1002E4C28((void *)&_mh_execute_header, v0, v1, "eventData is too short. eventData dataLength: %zd, FindingReport size: %zu", v2, v3, v4, v5, v6);
}

void sub_10075D2C0()
{
  sub_1003C8760();
  sub_1002E4C28((void *)&_mh_execute_header, v0, v1, "eventData is too short. eventData dataLength: %zd, TelemetryReport offset + size: %zu", v2, v3, v4, v5, v6);
}

void sub_10075D330()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "handleHIDEvent (Telemetry) invalid telemetry interval", v2, v3, v4, v5, v6);
}

void sub_10075D364()
{
  sub_1003C8760();
  sub_1002E4C28((void *)&_mh_execute_header, v0, v1, "eventData is too short. eventData dataLength: %zd, FoundRSSIDetectEventReport offset + size: %zu", v2, v3, v4, v5, v6);
}

void sub_10075D3D4()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "handleHIDEvent (rssiDetectReport) invalid maxRssi value", v2, v3, v4, v5, v6);
}

void sub_10075D408(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_10075D480()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "readAopCaches: _fastpathGlue is not valid", v2, v3, v4, v5, v6);
}

void sub_10075D4B4(unsigned __int8 a1, unsigned __int8 a2, os_log_t log)
{
  v3[0] = 67109376;
  v3[1] = a2;
  __int16 v4 = 1024;
  int v5 = a1;
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "### readAopCaches: handleIndex %d hi %d", (uint8_t *)v3, 0xEu);
}

void sub_10075D544()
{
  sub_10005732C();
  sub_1000572F4((void *)&_mh_execute_header, v0, v1, "readAopCaches: getReport::BtProxCtxCacheFetch failed %@", v2, v3, v4, v5, v6);
}

void sub_10075D5AC()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "_retrieveServiceState error", v2, v3, v4, v5, v6);
}

void sub_10075D5E0()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "_retrieveSectionsConfiguration returned an empty table", v2, v3, v4, v5, v6);
}

void sub_10075D614()
{
  sub_10005732C();
  sub_1000572F4((void *)&_mh_execute_header, v0, v1, "Failed to send report. Error: %@", v2, v3, v4, v5, v6);
}

void sub_10075D67C(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_10075D6F4()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "AOP Interface Not Initialized", v2, v3, v4, v5, v6);
}

void sub_10075D728()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "AOPBluetooth service not present or misbehaving!", v2, v3, v4, v5, v6);
}

void sub_10075D75C()
{
  sub_10005732C();
  sub_1000572F4((void *)&_mh_execute_header, v0, v1, "Failed to set service state. Error: %@", v2, v3, v4, v5, v6);
}

void sub_10075D7C4()
{
  sub_10005732C();
  sub_1000572F4((void *)&_mh_execute_header, v0, v1, "Failed to get service state report. Error: %@", v2, v3, v4, v5, v6);
}

void sub_10075D82C(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_10075D898(uint8_t *buf, unsigned char *a2, os_log_t log)
{
  *uint64_t buf = 0;
  *a2 = 0;
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "unexpected child class", buf, 2u);
}

void sub_10075D8D8(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_10075D944(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_10075D9B0()
{
  sub_10005732C();
  sub_1000572F4((void *)&_mh_execute_header, v0, v1, "Failed to open device. Error: %@", v2, v3, v4, v5, v6);
}

void sub_10075DA18(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_10075DA90()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "AOPBluetooth HID reset handler", v2, v3, v4, v5, v6);
}

void sub_10075DAC4()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "AOPBluetooth HID cancel handler", v2, v3, v4, v5, v6);
}

void sub_10075DAF8(unsigned __int8 *a1, uint64_t a2, os_log_t log)
{
  int v3 = *a1;
  v4[0] = 67109378;
  v4[1] = v3;
  __int16 v5 = 2112;
  uint64_t v6 = a2;
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "Send report to AOP (type %d) failed. Error: %@", (uint8_t *)v4, 0x12u);
}

void sub_10075DB84()
{
  sub_10005732C();
  sub_1000572F4((void *)&_mh_execute_header, v0, v1, "Failed to receive ServiceState report. Error: %@", v2, v3, v4, v5, v6);
}

void sub_10075DBEC()
{
  sub_10005732C();
  sub_1000572F4((void *)&_mh_execute_header, v0, v1, "Failed to receive Telemetry report. Error: %@", v2, v3, v4, v5, v6);
}

void sub_10075DC54()
{
  sub_10005732C();
  sub_1000572F4((void *)&_mh_execute_header, v0, v1, "Failed to receive MatchTableConf report. Error: %@", v2, v3, v4, v5, v6);
}

void sub_10075DCBC()
{
  sub_10005732C();
  sub_1000572F4((void *)&_mh_execute_header, v0, v1, "Failed to receive BtProxCtxCacheFetch report. Error: %@", v2, v3, v4, v5, v6);
}

void sub_10075DD24()
{
  sub_10005732C();
  sub_1000572F4((void *)&_mh_execute_header, v0, v1, "Failed to receive TypeToRssiThresholdMapFetch report. Error: %@", v2, v3, v4, v5, v6);
}

void sub_10075DD8C()
{
  sub_10005732C();
  sub_1000572F4((void *)&_mh_execute_header, v0, v1, "Failed to receive LogVerbose report. Error: %@", v2, v3, v4, v5, v6);
}

void sub_10075DDF4()
{
  sub_10005732C();
  __int16 v3 = 1024;
  int v4 = v0;
  _os_log_debug_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_DEBUG, "MBFXPC LOG: BTLocalDeviceMsgHandler::BTLocalDeviceStatusEventCallbackHandler() %p, fCallbacksRegistered:%d", v2, 0x12u);
}

void sub_10075DE78()
{
  sub_10005732C();
  sub_1003CF064((void *)&_mh_execute_header, v0, v1, "BTLocalDeviceMsgHandler::handleBTLocalDeviceGetDefaultMsg sessionID:%llx", v2, v3, v4, v5, v6);
}

void sub_10075DEE0()
{
  sub_10005732C();
  sub_1003CF064((void *)&_mh_execute_header, v0, v1, "BTLocalDeviceMsgHandler::handleBTLocalDeviceAddCallbacksMsg localDeviceId:%llx ", v2, v3, v4, v5, v6);
}

void sub_10075DF48()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "could find callbacks", v2, v3, v4, v5, v6);
}

void sub_10075DF7C()
{
  sub_10005732C();
  sub_1003CF064((void *)&_mh_execute_header, v0, v1, "BTLocalDeviceMsgHandler::handleBTLocalDeviceRemoveCallbacksMsg localDeviceId:%llx ", v2, v3, v4, v5, v6);
}

void sub_10075DFE4()
{
  sub_10005732C();
  sub_1003CF064((void *)&_mh_execute_header, v0, v1, "BTLocalDeviceMsgHandler::handleBTLocalDeviceMaskCallbacksMsg localDeviceId:%llx ", v2, v3, v4, v5, v6);
}

void sub_10075E04C(int *a1, NSObject *a2)
{
  int v2 = *a1;
  v3[0] = 67109120;
  v3[1] = v2;
  _os_log_debug_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_DEBUG, "BTLocalDeviceMsgHandler::handleBTLocalDeviceGetModulePowerMsg bluetooth power state: %x", (uint8_t *)v3, 8u);
}

void sub_10075E0C8()
{
  sub_10005732C();
  sub_1003CF064((void *)&_mh_execute_header, v0, v1, "BTLocalDeviceMsgHandler::handleBTLocalDeviceGetModulePowerMsg localDeviceId:%llx", v2, v3, v4, v5, v6);
}

void sub_10075E130()
{
  sub_10005732C();
  sub_1003CF064((void *)&_mh_execute_header, v0, v1, "BTLocalDeviceMsgHandler::handleBTLocalDeviceGetSpatialPlatformSupportMsg localDeviceId:%llx", v2, v3, v4, v5, v6);
}

void sub_10075E198()
{
  sub_10005732C();
  sub_1003CF064((void *)&_mh_execute_header, v0, v1, "BTLocalDeviceMsgHandler::handleBTLocalDevicePowerResetMsg localDeviceId:%llx", v2, v3, v4, v5, v6);
}

void sub_10075E200()
{
  sub_10005732C();
  sub_1003CF064((void *)&_mh_execute_header, v0, v1, "BTLocalDeviceMsgHandler::handleBTLocalDeviceGetAirplaneModeStatusMsg localDeviceId:%llx", v2, v3, v4, v5, v6);
}

void sub_10075E268()
{
  sub_10005732C();
  sub_1003CF064((void *)&_mh_execute_header, v0, v1, "BTLocalDeviceMsgHandler::handleBTLocalDeviceGetAddressStringMsg localDeviceId:%llx", v2, v3, v4, v5, v6);
}

void sub_10075E2D0()
{
  sub_10005732C();
  sub_1003CF064((void *)&_mh_execute_header, v0, v1, "BTLocalDeviceMsgHandler::handleBTLocalDeviceGetNameMsg localDeviceId:%llx", v2, v3, v4, v5, v6);
}

void sub_10075E338()
{
  sub_1002DDCC4();
  sub_1003CF080((void *)&_mh_execute_header, v0, v1, "BTLocalDeviceMsgHandler::handleBTLocalDeviceSetDiscoverableMsg localDeviceId:%llx discoverable:%llx", v2, v3);
}

void sub_10075E3A0()
{
  sub_10005732C();
  sub_1003CF064((void *)&_mh_execute_header, v0, v1, "BTLocalDeviceMsgHandler::handleBTLocalDeviceGetDiscoverableMsg localDeviceId:%llx", v2, v3, v4, v5, v6);
}

void sub_10075E408()
{
  sub_1002DDCC4();
  sub_1003CF080((void *)&_mh_execute_header, v0, v1, "BTLocalDeviceMsgHandler::handleBTLocalDeviceSetConnectableMsg localDeviceId:%llx discoverable:%llx", v2, v3);
}

void sub_10075E470()
{
  sub_10005732C();
  sub_1003CF064((void *)&_mh_execute_header, v0, v1, "BTLocalDeviceMsgHandler::handleBTLocalDeviceGetConnectableMsg localDeviceId:%llx", v2, v3, v4, v5, v6);
}

void sub_10075E4D8()
{
  sub_10005732C();
  sub_1003CF064((void *)&_mh_execute_header, v0, v1, "BTLocalDeviceMsgHandler::handleBTLocalDeviceGetPairedDevicesMsg localDeviceId:%llx", v2, v3, v4, v5, v6);
}

void sub_10075E540()
{
  sub_10005732C();
  sub_1003CF064((void *)&_mh_execute_header, v0, v1, "BTLocalDeviceMsgHandler::handleBTLocalDeviceGetConnectionStatusMsg localDeviceId:%llx", v2, v3, v4, v5, v6);
}

void sub_10075E5A8()
{
  sub_10005732C();
  sub_1003CF064((void *)&_mh_execute_header, v0, v1, "BTLocalDeviceMsgHandler::handleBTLocalDeviceGetConnectedDevicesMsg localDeviceId:%llx", v2, v3, v4, v5, v6);
}

void sub_10075E610()
{
  sub_10005732C();
  sub_1003CF064((void *)&_mh_execute_header, v0, v1, "BTLocalDeviceMsgHandler::handleBTLocalDeviceGetConnectingDevicesMsg localDeviceId:%llx", v2, v3, v4, v5, v6);
}

void sub_10075E678()
{
  sub_10005732C();
  sub_1003CF064((void *)&_mh_execute_header, v0, v1, "BTLocalDeviceMsgHandler::handleBTLocalDeviceGetAdvertisingStatusMsg localDeviceId:%llx", v2, v3, v4, v5, v6);
}

void sub_10075E6E0()
{
  sub_10005732C();
  sub_1003CF064((void *)&_mh_execute_header, v0, v1, "BTLocalDeviceMsgHandler::handleBTLocalDeviceGetScanningMsg localDeviceId:%llx", v2, v3, v4, v5, v6);
}

void sub_10075E748()
{
  sub_10005732C();
  sub_1003CF064((void *)&_mh_execute_header, v0, v1, "BTLocalDeviceMsgHandler::handleBTLocalDeviceGetDUTModeEnabledMsg localDeviceId:%llx", v2, v3, v4, v5, v6);
}

void sub_10075E7B0()
{
  sub_1002DDCC4();
  sub_1003CF080((void *)&_mh_execute_header, v0, v1, "BTLocalDeviceMsgHandler::handleBTLocalDeviceEnableLeRxTestModeMsg localDeviceId:%llx testFrequency:%llx", v2, v3);
}

void sub_10075E818()
{
  sub_10005732C();
  sub_1003CF064((void *)&_mh_execute_header, v0, v1, "BTLocalDeviceMsgHandler::handleBTLocalDeviceDisableLeTestModeMsg localDeviceId:%llx", v2, v3, v4, v5, v6);
}

void sub_10075E880()
{
  sub_1002DDCC4();
  sub_1003CF080((void *)&_mh_execute_header, v0, v1, "BTLocalDeviceMsgHandler::handleBTLocalDeviceSupportsServiceMsg localDeviceId:%llx service:%llx", v2, v3);
}

void sub_10075E8E8()
{
  sub_10005732C();
  sub_1003CF064((void *)&_mh_execute_header, v0, v1, "BTLocalDeviceMsgHandler::handleBTLocalDeviceAdvertiseDataMsg localDeviceId:%llx", v2, v3, v4, v5, v6);
}

void sub_10075E950()
{
  sub_10005732C();
  sub_1003CF064((void *)&_mh_execute_header, v0, v1, "BTLocalDeviceMsgHandler::handleBTLocalDeviceRemoveDataMsg localDeviceId:%llx", v2, v3, v4, v5, v6);
}

void sub_10075E9B8()
{
  sub_10005732C();
  sub_1003CF064((void *)&_mh_execute_header, v0, v1, "BTLocalDeviceMsgHandler::handleBTLocalDeviceRegisterForPowerUpdatesMsg localDeviceId:%llx ", v2, v3, v4, v5, v6);
}

void sub_10075EA20()
{
  sub_10005732C();
  sub_1003CF064((void *)&_mh_execute_header, v0, v1, "BTLocalDeviceMsgHandler::handleBTLocalDeviceUnregisterForPowerUpdatesMsg localDeviceId:%llx ", v2, v3, v4, v5, v6);
}

void sub_10075EA88()
{
  sub_10005732C();
  sub_1003CF064((void *)&_mh_execute_header, v0, v1, "BTLocalDeviceMsgHandler::handleBTLocalDeviceReadPowerConsumptionMsg localDeviceId:%llx", v2, v3, v4, v5, v6);
}

void sub_10075EAF0()
{
  sub_10005732C();
  sub_1003CF064((void *)&_mh_execute_header, v0, v1, "BTLocalDeviceMsgHandler::handleBTLocalDeviceRegisterForPowerProfileStatisticsMsg localDeviceId:%llx ", v2, v3, v4, v5, v6);
}

void sub_10075EB58()
{
  sub_10005732C();
  sub_1003CF064((void *)&_mh_execute_header, v0, v1, "BTLocalDeviceMsgHandler::handleBTLocalDeviceUnregisterForPowerProfileStatisticsMsg localDeviceId:%llx ", v2, v3, v4, v5, v6);
}

void sub_10075EBC0()
{
  sub_10005732C();
  sub_1003CF064((void *)&_mh_execute_header, v0, v1, "BTLocalDeviceMsgHandler::handleBTLocalDeviceReadPowerProfileStatisticsMsg deviceID:%llx", v2, v3, v4, v5, v6);
}

void sub_10075EC28()
{
  sub_10005732C();
  sub_1003CF064((void *)&_mh_execute_header, v0, v1, "BTLocalDeviceMsgHandler::handleBTLocalDeviceReadEnhancedPowerProfileStatisticsMsg deviceID:%llx", v2, v3, v4, v5, v6);
}

void sub_10075EC90()
{
  sub_10005732C();
  sub_1003CF064((void *)&_mh_execute_header, v0, v1, "BTLocalDeviceMsgHandler::handleBTLocalDeviceReadTransportSwitchStatisticsMsg deviceID:%llx", v2, v3, v4, v5, v6);
}

void sub_10075ECF8()
{
  sub_10005732C();
  sub_1003CF064((void *)&_mh_execute_header, v0, v1, "BTLocalDeviceMsgHandler::handleBTLocalDeviceReadDetailedPowerProfileStatisticsMsg deviceID:%llx", v2, v3, v4, v5, v6);
}

void sub_10075ED60()
{
  sub_10005732C();
  sub_1003CF064((void *)&_mh_execute_header, v0, v1, "BTLocalDeviceMsgHandler::handleBTLocalDeviceStartHCITracesMsg deviceID:%llx", v2, v3, v4, v5, v6);
}

void sub_10075EDC8()
{
  sub_10005732C();
  sub_1003CF064((void *)&_mh_execute_header, v0, v1, "BTLocalDeviceMsgHandler::handleBTLocalDeviceStopHCITracesMsg deviceID:%llx", v2, v3, v4, v5, v6);
}

void sub_10075EE30()
{
  sub_10005732C();
  sub_1003CF064((void *)&_mh_execute_header, v0, v1, "BTLocalDeviceMsgHandler::handleBTLocalDeviceShowPowerPromptMsg deviceID:%llx", v2, v3, v4, v5, v6);
}

void sub_10075EE98()
{
  sub_10005732C();
  sub_1003CF064((void *)&_mh_execute_header, v0, v1, "BTLocalDeviceMsgHandler::handleBTLocalDeviceSetAFHMapMsg deviceID:%llx", v2, v3, v4, v5, v6);
}

void sub_10075EF00()
{
  sub_1000572DC();
  _os_log_fault_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_FAULT, "Incorrect AFH Size received over XPC", v1, 2u);
}

void sub_10075EF40()
{
  sub_10005732C();
  sub_1003CF064((void *)&_mh_execute_header, v0, v1, "BTLocalDeviceMsgHandler::handleBTLocalDeviceReadAFHMapMsg deviceID:%llx", v2, v3, v4, v5, v6);
}

void sub_10075EFA8()
{
  sub_1000572DC();
  _os_log_debug_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_DEBUG, "BTLocalDeviceMsgHandler::handleBTLocalDeviceSetDelayedWakeMsg", v1, 2u);
}

void sub_10075EFE8()
{
  sub_10005732C();
  sub_1003CF064((void *)&_mh_execute_header, v0, v1, "BTLocalDeviceMsgHandler::handleBTLocalDeviceSetDenylistEnabledMsg localDeviceID:%llx", v2, v3, v4, v5, v6);
}

void sub_10075F050()
{
  sub_10005732C();
  sub_1003CF064((void *)&_mh_execute_header, v0, v1, "BTLocalDeviceMsgHandler::handleBTLocalDeviceGetDenylistEnabledMsg deviceID:%llx", v2, v3, v4, v5, v6);
}

void sub_10075F0B8()
{
  sub_10005732C();
  sub_1003CF064((void *)&_mh_execute_header, v0, v1, "BTLocalDeviceMsgHandler::handleBTLocalDeviceGetDeviceNamesThatMayBeDenylistedMsg deviceID:%llx", v2, v3, v4, v5, v6);
}

void sub_10075F120()
{
  sub_10005732C();
  sub_1003CF064((void *)&_mh_execute_header, v0, v1, "BTLocalDeviceMsgHandler::handleBTLocalDeviceGetSharingAddressesMsg deviceID:%llx", v2, v3, v4, v5, v6);
}

void sub_10075F188()
{
  sub_10005732C();
  sub_1003CF064((void *)&_mh_execute_header, v0, v1, "BTLocalDeviceMsgHandler::handleBTLocalDeviceIsSharingEnabledMsg deviceID:%llx", v2, v3, v4, v5, v6);
}

void sub_10075F1F0()
{
  sub_10005732C();
  sub_1003CF064((void *)&_mh_execute_header, v0, v1, "BTLocalDeviceMsgHandler::handleBTLocalDeviceDumpExposureNotificationDatabaseMsg localDeviceId:%llx", v2, v3, v4, v5, v6);
}

void sub_10075F258()
{
  sub_10005732C();
  sub_1003CF064((void *)&_mh_execute_header, v0, v1, "BTLocalDeviceMsgHandler::handleBTLocalDeviceLinkQualityGetDataMsg sessionID:%llx", v2, v3, v4, v5, v6);
}

void sub_10075F2C0()
{
  sub_10005732C();
  sub_1003CF064((void *)&_mh_execute_header, v0, v1, "BTLocalDeviceMsgHandler::handleBTLocalDeviceCallScreeningMsg localDeviceID:%llx", v2, v3, v4, v5, v6);
}

void sub_10075F328()
{
  sub_10005732C();
  sub_1003CF064((void *)&_mh_execute_header, v0, v1, "MBFXPC LOG: BTLocalDeviceMsgHandler::handleDisconnection() %p", v2, v3, v4, v5, v6);
}

void sub_10075F390(int a1, NSObject *a2)
{
  v2[0] = 67109120;
  v2[1] = a1;
  _os_log_error_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_ERROR, "Unknown device class %d.  Using default service set", (uint8_t *)v2, 8u);
}

void sub_10075F408()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "registerSmartCoverStateObserver failed -- observability is nil", v2, v3, v4, v5, v6);
}

void sub_10075F43C()
{
  sub_1000572DC();
  _os_log_debug_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_DEBUG, "Screen undimmed", v1, 2u);
}

void sub_10075F47C(uint64_t *a1, NSObject *a2)
{
  uint64_t v2 = *a1;
  int v3 = 134217984;
  uint64_t v4 = v2;
  _os_log_fault_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_FAULT, "Failed to find the system container: %llu", (uint8_t *)&v3, 0xCu);
}

void sub_10075F4F8()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Couldn't create a dynamic store", v2, v3, v4, v5, v6);
}

void sub_10075F52C()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Netrb Framework not available", v2, v3, v4, v5, v6);
}

void sub_10075F560()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "MobileWifi Framework not available", v2, v3, v4, v5, v6);
}

void sub_10075F594(int a1, NSObject *a2, double a3)
{
  int v3 = 134218240;
  uint64_t v4 = (uint64_t)a3;
  __int16 v5 = 1024;
  int v6 = a1;
  _os_log_error_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_ERROR, "Detected that BT did not sleep during AP sleep of %lld seconds, but not restarting due to %d connections", (uint8_t *)&v3, 0x12u);
}

void sub_10075F61C()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Read power profile statistics not available for unknown chipset", v2, v3, v4, v5, v6);
}

void sub_10075F650(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_10075F6BC()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "CoreAudio Framework not available", v2, v3, v4, v5, v6);
}

void sub_10075F6F0()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "CarKit Framework not available", v2, v3, v4, v5, v6);
}

void sub_10075F724()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "CoreMotion Framework not available", v2, v3, v4, v5, v6);
}

void sub_10075F758()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Device orientation not available", v2, v3, v4, v5, v6);
}

void sub_10075F78C()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "No HWIdentifiers property", v2, v3, v4, v5, v6);
}

void sub_10075F7C0()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Failed to get chipset(C) from HWIdentifiers property", v2, v3, v4, v5, v6);
}

void sub_10075F7F4()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Setting HWIdentifiers has failed", v2, v3, v4, v5, v6);
}

void sub_10075F828()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "No HWIdentifiers set, attemping to set HWIdentifiers...", v2, v3, v4, v5, v6);
}

void sub_10075F85C()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Failed to get HWIdentifiers property, while trying to pull chipset", v2, v3, v4, v5, v6);
}

void sub_10075F890(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_10075F900(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_10075F970(char *a1, void *a2, NSObject *a3)
{
  if (*a1 < 0) {
    a2 = (void *)*a2;
  }
  LODWORD(v3) = 136315138;
  HIDWORD(v3) = a2;
  sub_1003E68CC((void *)&_mh_execute_header, (uint64_t)a2, a3, "Something went wrong fetching values from HWIdentifiers, we can't extract file names with extension: %s", v3);
}

void sub_10075F9E8(char *a1, void *a2, NSObject *a3)
{
  if (*a1 < 0) {
    a2 = (void *)*a2;
  }
  LODWORD(v3) = 136315138;
  HIDWORD(v3) = a2;
  sub_1003E68CC((void *)&_mh_execute_header, (uint64_t)a2, a3, "No %s file found from HWIdentifiers", v3);
}

void sub_10075FA60()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "possible memory corruption on SKU?", v2, v3, v4, v5, v6);
}

void sub_10075FA94()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "bluetooth-pcie service not found", v2, v3, v4, v5, v6);
}

void sub_10075FAC8()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "IOName typeref not found", v2, v3, v4, v5, v6);
}

void sub_10075FAFC()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Error reading IOName to buffer", v2, v3, v4, v5, v6);
}

void sub_10075FB30()
{
  sub_10005732C();
  sub_1000572F4((void *)&_mh_execute_header, v0, v1, "Unmapped device id %s from IOName", v2, v3, v4, v5, v6);
}

void sub_10075FB98(uint64_t a1, void *a2, uint64_t a3)
{
  sub_1003E68B4(a1, (uint64_t)a2, a3, 5.778e-34);
  _os_log_error_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "Error occured when looking into %@ directory: %@", v4, 0x16u);
}

void sub_10075FBF0(void *a1, uint64_t a2, uint64_t a3)
{
  sub_1003E68B4((uint64_t)a1, a2, a3, 5.7781e-34);
  *(_WORD *)(v4 + 22) = 1024;
  *(_DWORD *)(v4 + 24) = 255;
  _os_log_error_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, "File: %@ found by regex: %@ is over the %d char file name limit", v5, 0x1Cu);
}

void sub_10075FC58()
{
  sub_10005732C();
  sub_1000572F4((void *)&_mh_execute_header, v0, v1, "Multiple matching filenames detected. Picking highest version out of these filenames: %@", v2, v3, v4, v5, v6);
}

void sub_10075FCC0(void *a1, void *a2, uint64_t a3)
{
  sub_1003E68B4((uint64_t)a1, (uint64_t)a2, a3, 5.778e-34);
  _os_log_error_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, "Error occured when picking out highest version filename, returning end of the filenameArray: %@  Error: %@", v5, 0x16u);
}

void sub_10075FD20()
{
  sub_1003E68EC(__stack_chk_guard);
  sub_10005732C();
  sub_100057574();
  _os_log_error_impl(v0, v1, v2, v3, v4, 0x12u);
}

void sub_10075FDA8()
{
  sub_1003E68EC(__stack_chk_guard);
  sub_10005732C();
  sub_1000572F4((void *)&_mh_execute_header, v0, v1, "Could not allocate memory for reading file: %s", v2, v3, v4, v5, v6);
}

void sub_10075FE18()
{
  sub_1003E68EC(__stack_chk_guard);
  sub_10005732C();
  sub_100057574();
  _os_log_error_impl(v0, v1, v2, v3, v4, 0x16u);
}

void sub_10075FEA0()
{
  sub_1003E68EC(__stack_chk_guard);
  sub_10005732C();
  sub_1000572F4((void *)&_mh_execute_header, v0, v1, "File: %s can not be opened", v2, v3, v4, v5, v6);
}

void sub_10075FF10(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_10075FF88()
{
  sub_100057574();
  _os_log_error_impl(v0, v1, v2, v3, v4, 0x20u);
}

void sub_10076002C()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "SKU could not be determined", v2, v3, v4, v5, v6);
}

void sub_100760060()
{
  sub_1000572DC();
  sub_10030D118((void *)&_mh_execute_header, v0, v1, "Incorrect size received over XPC", v2, v3, v4, v5, v6);
}

void sub_100760094()
{
  sub_1000572DC();
  _os_log_debug_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_DEBUG, "BTDeviceMsgHandler::handleBTDeviceAddressToStringMsg", v1, 2u);
}

void sub_1007600D4()
{
  sub_10005732C();
  sub_1003CF064((void *)&_mh_execute_header, v0, v1, "BTDeviceMsgHandler::handleBTDeviceAddressFromStringMsg %s", v2, v3, v4, v5, v6);
}

void sub_10076013C()
{
  sub_10005732C();
  sub_1003CF064((void *)&_mh_execute_header, v0, v1, "BTDeviceMsgHandler::handleBTDeviceFromAddressMsg sessionID:%llx", v2, v3, v4, v5, v6);
}

void sub_1007601A4()
{
  sub_1000572DC();
  sub_10030D118((void *)&_mh_execute_header, v0, v1, "Incorrect Address Size received over XPC", v2, v3, v4, v5, v6);
}

void sub_1007601D8()
{
  sub_10005732C();
  sub_1003CF064((void *)&_mh_execute_header, v0, v1, "BTDeviceMsgHandler::handleBTDeviceFromIdentifierMsg sessionID:%llx", v2, v3, v4, v5, v6);
}

void sub_100760240()
{
  sub_10005732C();
  sub_1003CF064((void *)&_mh_execute_header, v0, v1, "BTDeviceMsgHandler::handleBTDeviceGetAddressStringMsg device:%llx", v2, v3, v4, v5, v6);
}

void sub_1007602A8()
{
  sub_10005732C();
  sub_1003CF064((void *)&_mh_execute_header, v0, v1, "BTDeviceMsgHandler::handleBTDeviceGetDeviceTypeMsg device:%llx", v2, v3, v4, v5, v6);
}

void sub_100760310()
{
  sub_10005732C();
  sub_1003CF064((void *)&_mh_execute_header, v0, v1, "BTDeviceMsgHandler::handleBTDeviceGetDeviceClassMsg device:%llx", v2, v3, v4, v5, v6);
}

void sub_100760378()
{
  sub_10005732C();
  sub_1003CF064((void *)&_mh_execute_header, v0, v1, "BTDeviceMsgHandler::handleBTDeviceGetDefaultNameMsg device:%llx", v2, v3, v4, v5, v6);
}

void sub_1007603E0()
{
  sub_10005732C();
  sub_1003CF064((void *)&_mh_execute_header, v0, v1, "BTDeviceMsgHandler::handleBTDeviceGetNameMsg device:%llx", v2, v3, v4, v5, v6);
}

void sub_100760448()
{
  sub_10005732C();
  sub_1003CF064((void *)&_mh_execute_header, v0, v1, "BTDeviceMsgHandler::handleBTDeviceGetProductNameMsg device:%llx", v2, v3, v4, v5, v6);
}

void sub_1007604B0()
{
  sub_10005732C();
  sub_1003CF064((void *)&_mh_execute_header, v0, v1, "BTDeviceMsgHandler::handleBTDeviceSetUserNameMsg device:%llx", v2, v3, v4, v5, v6);
}

void sub_100760518()
{
  sub_10005732C();
  sub_1003CF064((void *)&_mh_execute_header, v0, v1, "BTDeviceMsgHandler::handleBTDeviceGetSyncSettingsMsg device:%llx", v2, v3, v4, v5, v6);
}

void sub_100760580()
{
  sub_10005732C();
  sub_1003CF064((void *)&_mh_execute_header, v0, v1, "BTDeviceMsgHandler::handleBTDeviceSetSyncSettingsMsg device:%llx", v2, v3, v4, v5, v6);
}

void sub_1007605E8()
{
  sub_10005732C();
  sub_1003CF064((void *)&_mh_execute_header, v0, v1, "BTDeviceMsgHandler::handleBTDeviceGetGroupsMsg device:%llx", v2, v3, v4, v5, v6);
}

void sub_100760650()
{
  sub_10005732C();
  sub_1003CF064((void *)&_mh_execute_header, v0, v1, "BTDeviceMsgHandler::handleBTDeviceSetGroupMsg device:%llx", v2, v3, v4, v5, v6);
}

void sub_1007606B8()
{
  sub_10005732C();
  sub_1003CF064((void *)&_mh_execute_header, v0, v1, "BTDeviceMsgHandler::handleBTDeviceGetPairingStatusMsg device:%llx", v2, v3, v4, v5, v6);
}

void sub_100760720()
{
  sub_10005732C();
  sub_1003CF064((void *)&_mh_execute_header, v0, v1, "BTDeviceMsgHandler::handleBTDeviceGetCloudPairingStatusMsg device:%llx", v2, v3, v4, v5, v6);
}

void sub_100760788()
{
  sub_10005732C();
  sub_1003CF064((void *)&_mh_execute_header, v0, v1, "BTDeviceMsgHandler::handleBTDeviceGetMagicPairingStatusMsg device:%llx", v2, v3, v4, v5, v6);
}

void sub_1007607F0()
{
  sub_10005732C();
  sub_1003CF064((void *)&_mh_execute_header, v0, v1, "BTDeviceMsgHandler::handleBTDeviceGetConnectionStatusMsg device:%llx", v2, v3, v4, v5, v6);
}

void sub_100760858()
{
  sub_10005732C();
  sub_1003CF064((void *)&_mh_execute_header, v0, v1, "BTDeviceMsgHandler::handleBTDeviceIsAppleAudioDeviceMsg device:%llx", v2, v3, v4, v5, v6);
}

void sub_1007608C0()
{
  sub_10005732C();
  sub_1003CF064((void *)&_mh_execute_header, v0, v1, "BTDeviceMsgHandler::handleBTDeviceSupportsHSMsg device:%llx", v2, v3, v4, v5, v6);
}

void sub_100760928()
{
  sub_10005732C();
  sub_1003CF064((void *)&_mh_execute_header, v0, v1, "BTDeviceMsgHandler::handleBTDeviceIsProControllerMsg device:%llx", v2, v3, v4, v5, v6);
}

void sub_100760990()
{
  sub_10005732C();
  __int16 v3 = 2048;
  uint64_t v4 = v0;
  _os_log_debug_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_DEBUG, "BTDeviceMsgHandler::handleBTDeviceServiceAddCallbacksMsg session:%llx cbid:%llx", v2, 0x16u);
}

void sub_100760A14()
{
  sub_1000572DC();
  _os_log_error_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_ERROR, "could find callbacks", v1, 2u);
}

void sub_100760A54()
{
  sub_10005732C();
  sub_1003CF064((void *)&_mh_execute_header, v0, v1, "BTDeviceMsgHandler::handleBTDeviceServiceRemoveCallbacksMsg session:%llx ", v2, v3, v4, v5, v6);
}

void sub_100760ABC()
{
  sub_10005732C();
  sub_1003CF064((void *)&_mh_execute_header, v0, v1, "BTDeviceMsgHandler::handleBTDeviceConnectMsg device:%llx", v2, v3, v4, v5, v6);
}

void sub_100760B24()
{
  sub_10005732C();
  sub_1003CF064((void *)&_mh_execute_header, v0, v1, "BTDeviceMsgHandler::handleBTDeviceConnectServicesMsg device:%llx", v2, v3, v4, v5, v6);
}

void sub_100760B8C()
{
  sub_10005732C();
  sub_1003CF064((void *)&_mh_execute_header, v0, v1, "BTDeviceMsgHandler::handleBTDeviceConnectServicesWithParametersMsg device:%llx", v2, v3, v4, v5, v6);
}

void sub_100760BF4()
{
  sub_10005732C();
  sub_1003CF064((void *)&_mh_execute_header, v0, v1, "BTDeviceMsgHandler::handleBTDeviceDisconnectMsg device:%llx", v2, v3, v4, v5, v6);
}

void sub_100760C5C()
{
  sub_10005732C();
  sub_1003CF064((void *)&_mh_execute_header, v0, v1, "BTDeviceMsgHandler::handleBTDeviceDisconnectServicesMsg device:%llx", v2, v3, v4, v5, v6);
}

void sub_100760CC4()
{
  sub_10005732C();
  sub_1003CF064((void *)&_mh_execute_header, v0, v1, "BTDeviceMsgHandler::handleBTDeviceGetConnectedServicesMsg device:%llx", v2, v3, v4, v5, v6);
}

void sub_100760D2C()
{
  sub_10005732C();
  sub_1003CF064((void *)&_mh_execute_header, v0, v1, "BTDeviceMsgHandler::handleBTDeviceGetSupportedServicesMsg device:%llx", v2, v3, v4, v5, v6);
}

void sub_100760D94()
{
  sub_10005732C();
  sub_1003CF064((void *)&_mh_execute_header, v0, v1, "BTDeviceMsgHandler::handleBTDeviceSetServiceSettingsMsg device:%llx", v2, v3, v4, v5, v6);
}

void sub_100760DFC()
{
  sub_10005732C();
  sub_1003CF064((void *)&_mh_execute_header, v0, v1, "BTDeviceMsgHandler::handleBTDeviceGetServiceSettingsMsg device:%llx", v2, v3, v4, v5, v6);
}

void sub_100760E64()
{
  sub_10005732C();
  sub_1003CF064((void *)&_mh_execute_header, v0, v1, "BTDeviceMsgHandler::handleBTDeviceSetVirtualTypeMsg device:%llx", v2, v3, v4, v5, v6);
}

void sub_100760ECC()
{
  sub_10005732C();
  sub_1003CF064((void *)&_mh_execute_header, v0, v1, "BTDeviceMsgHandler::handleBTDeviceGetVirtualTypeMsg device:%llx", v2, v3, v4, v5, v6);
}

void sub_100760F34()
{
  sub_10005732C();
  sub_1003CF064((void *)&_mh_execute_header, v0, v1, "BTDeviceMsgHandler::handleBTDeviceGetComPortForServiceMsg device:%llx", v2, v3, v4, v5, v6);
}

void sub_100760F9C()
{
  sub_10005732C();
  sub_1003CF064((void *)&_mh_execute_header, v0, v1, "BTDeviceMsgHandler::handleBTDeviceGetComPortForServiceWithSandboxExtensionMsg device:%llx", v2, v3, v4, v5, v6);
}

void sub_100761004()
{
  sub_10005732C();
  sub_1003CF064((void *)&_mh_execute_header, v0, v1, "BTDeviceMsgHandler::handleBTDeviceMatchesAdvertisedKeyMsg device:%llx", v2, v3, v4, v5, v6);
}

void sub_10076106C()
{
  sub_10005732C();
  sub_1003CF064((void *)&_mh_execute_header, v0, v1, "BTDeviceMsgHandler::handleBTDeviceGetAdvertisedValueForKeyMsg device:%llx", v2, v3, v4, v5, v6);
}

void sub_1007610D4()
{
  sub_10005732C();
  sub_1003CF064((void *)&_mh_execute_header, v0, v1, "BTDeviceMsgHandler::handleBTDeviceGetDeviceIdMsg device:%llx", v2, v3, v4, v5, v6);
}

void sub_10076113C()
{
  sub_10005732C();
  sub_1003CF064((void *)&_mh_execute_header, v0, v1, "BTDeviceMsgHandler::handleBTDeviceSetHIDPropertiesMsg device:%llx", v2, v3, v4, v5, v6);
}

void sub_1007611A4()
{
  sub_10005732C();
  sub_1003CF064((void *)&_mh_execute_header, v0, v1, "BTDeviceMsgHandler::handleBTDevicePhysicalLinkDisconnectMsg device:%llx", v2, v3, v4, v5, v6);
}

void sub_10076120C()
{
  sub_10005732C();
  sub_1003CF064((void *)&_mh_execute_header, v0, v1, "BTDeviceMsgHandler::handleBTDeviceConfigureLinkKeyMsg device:%llx", v2, v3, v4, v5, v6);
}

void sub_100761274()
{
  sub_10005732C();
  sub_1003CF064((void *)&_mh_execute_header, v0, v1, "BTDeviceMsgHandler::handleBTDeviceIsTemporaryPairedMsg device:%llx", v2, v3, v4, v5, v6);
}

void sub_1007612DC()
{
  sub_10005732C();
  sub_1003CF064((void *)&_mh_execute_header, v0, v1, "BTDeviceMsgHandler::handleBTDeviceIsWirelessSplitterSupportedMsg device:%llx", v2, v3, v4, v5, v6);
}

void sub_100761344()
{
  sub_10005732C();
  sub_1003CF064((void *)&_mh_execute_header, v0, v1, "BTDeviceMsgHandler::handleBTDeviceIsTemporaryPairedNotInContactsMsg device:%llx", v2, v3, v4, v5, v6);
}

void sub_1007613AC()
{
  sub_10005732C();
  sub_1003CF064((void *)&_mh_execute_header, v0, v1, "BTDeviceMsgHandler::handleBTDeviceGetLowSecurityStatusMsg device:%llx", v2, v3, v4, v5, v6);
}

void sub_100761414()
{
  sub_10005732C();
  sub_1003CF064((void *)&_mh_execute_header, v0, v1, "BTDeviceMsgHandler::handleBTDeviceGetHIDDeviceBehaviorMsg device:%llx", v2, v3, v4, v5, v6);
}

void sub_10076147C()
{
  sub_10005732C();
  sub_1003CF064((void *)&_mh_execute_header, v0, v1, "BTDeviceMsgHandler::handleBTDeviceSetHijackAudioRouteMsg device:%llx", v2, v3, v4, v5, v6);
}

void sub_1007614E4()
{
  sub_10005732C();
  sub_1003CF064((void *)&_mh_execute_header, v0, v1, "BTDeviceMsgHandler::handleBTDeviceSetACLHighPriorityMsg device:%llx", v2, v3, v4, v5, v6);
}

void sub_10076154C()
{
  sub_10005732C();
  sub_1003CF064((void *)&_mh_execute_header, v0, v1, "BTDeviceMsgHandler::handleBTDeviceIsCentralMsg device:%llx", v2, v3, v4, v5, v6);
}

void sub_1007615B4()
{
  sub_10005732C();
  sub_1003CF064((void *)&_mh_execute_header, v0, v1, "BTDeviceMsgHandler::handleBTDeviceGetUserSelectedDeviceTypeMsg device:%llx", v2, v3, v4, v5, v6);
}

void sub_10076161C()
{
  sub_10005732C();
  sub_1003CF064((void *)&_mh_execute_header, v0, v1, "BTDeviceMsgHandler::handleBTDeviceSetUserSelectedDeviceTypeMsg device:%llx", v2, v3, v4, v5, v6);
}

void sub_100761684(int *a1, uint64_t a2, os_log_t log)
{
  int v3 = *a1;
  uint64_t v4 = "non-genuine";
  int v5 = 134218498;
  uint64_t v6 = a2;
  if (v3 == -1) {
    uint64_t v4 = "genuine";
  }
  __int16 v7 = 1024;
  int v8 = v3;
  __int16 v9 = 2080;
  __int16 v10 = v4;
  _os_log_debug_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_DEBUG, "BTDeviceMsgHandler::handleBTDeviceIsGenuineAirPodsMsg device:%llx genuine:%u (%s)", (uint8_t *)&v5, 0x1Cu);
}

void sub_100761734()
{
  sub_10005732C();
  sub_1003CF064((void *)&_mh_execute_header, v0, v1, "BTDeviceMsgHandler::handleBTDeviceIsGenuineAirPodsMsg device:%llx", v2, v3, v4, v5, v6);
}

void sub_10076179C()
{
  sub_10005732C();
  sub_100057438((void *)&_mh_execute_header, v0, v1, "deleteOldLogFiles: Unable to get directory contents: %@", v2);
}

void sub_100761808(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_100761874()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "initializeAccessoryLoggingSession: No stack", v2, v3, v4, v5, v6);
}

void sub_1007618A8()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "initializeAccessoryLoggingSession: Null device", v2, v3, v4, v5, v6);
}

void sub_1007618DC()
{
  sub_1003FAE54();
  id v1 = sub_1003FAE1C(v0);
  sub_100057360();
  sub_1000DDF08((void *)&_mh_execute_header, v2, v3, "initializeAccessoryLoggingSession: Buddy command to %{public}@ for checking crash log failed; error = %d",
    v4,
    v5,
    v6,
    v7,
    v8);
}

void sub_100761964(int *a1, uint64_t a2, NSObject *a3)
{
  int v3 = *a1;
  *(_DWORD *)a2 = 67109120;
  *(_DWORD *)(a2 + 4) = v3;
  sub_100080510((void *)&_mh_execute_header, a3, (uint64_t)a3, "Accessory power log file open failure -> %d", (uint8_t *)a2);
}

void sub_1007619A8()
{
  sub_1003FAE54();
  id v1 = sub_1003FAE1C(v0);
  sub_100057360();
  sub_1000DDF08((void *)&_mh_execute_header, v2, v3, "Buddy command to %{public}@ failed; error = %d",
    v4,
    v5,
    v6,
    v7,
    v8);
}

void sub_100761A30()
{
  sub_1003FAE54();
  id v1 = sub_1003FAE1C(v0);
  sub_100057360();
  sub_1000DDF08((void *)&_mh_execute_header, v2, v3, "Send TimeStamp Request Periodically to %{public}@ failed; error = %d",
    v4,
    v5,
    v6,
    v7,
    v8);
}

void sub_100761AB8()
{
  sub_1003FAE54();
  id v1 = sub_1003FAE1C(v0);
  sub_100057360();
  sub_1000DDF08((void *)&_mh_execute_header, v2, v3, "Send Diagnostics Request Periodically to %{public}@ failed; error = %d",
    v4,
    v5,
    v6,
    v7,
    v8);
}

void sub_100761B40(uint64_t a1)
{
  id v1 = sub_1003FAE1C(a1);
  sub_1003FAE60();
  sub_1000DDF08((void *)&_mh_execute_header, v2, v3, "initializeAccessoryLoggingSession: Session for %{public}@ already exists in unexpected state %d", v4, v5, v6, v7, v8);
}

void sub_100761BD0()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "sendTimestamp: No stack", v2, v3, v4, v5, v6);
}

void sub_100761C04(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_10025B48C(a1, a2, a3, a4, a5, a6, a7, a8);
  sub_1003FADFC();
  sub_100057394((void *)&_mh_execute_header, v8, v9, "sendTimestamp: Invalid address %{private, mask.hash}s", v10, v11, v12, v13, v14);
}

void sub_100761C7C(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_10025B48C(a1, (uint64_t)a2, a3, a4, a5, a6, a7, a8);
  sub_10005732C();
  sub_100057438((void *)&_mh_execute_header, a2, v9, "sendTimestamp: No device found for %s", v10);
}

void sub_100761D00()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "sendLogCommand: No stack", v2, v3, v4, v5, v6);
}

void sub_100761D34(uint64_t a1, uint64_t a2, NSObject *a3)
{
  *(_DWORD *)a2 = 136315138;
  *(void *)(a2 + 4) = a1;
  sub_100057438((void *)&_mh_execute_header, a3, (uint64_t)a3, "sendLogCommand: No device found for %s", (uint8_t *)a2);
}

void sub_100761D74()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "sendLogCommand: AccessoryLoggingManager currently busy", v2, v3, v4, v5, v6);
}

void sub_100761DA8()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "sendLogCommand: This request is not allowed", v2, v3, v4, v5, v6);
}

void sub_100761DDC()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "collectDebugData: No stack", v2, v3, v4, v5, v6);
}

void sub_100761E10()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "collectDebugData: No AACP connection to a W1 accessory", v2, v3, v4, v5, v6);
}

void sub_100761E44(uint64_t a1, uint64_t a2, NSObject *a3)
{
  *(_DWORD *)a2 = 136315138;
  *(void *)(a2 + 4) = a1;
  sub_100057438((void *)&_mh_execute_header, a3, (uint64_t)a3, "collectDebugData: No device found for %s", (uint8_t *)a2);
}

void sub_100761E84(uint64_t a1, NSObject *a2)
{
  id v3 = *(id *)(*(void *)(a1 + 40) + 8);
  sub_10005732C();
  sub_100057438((void *)&_mh_execute_header, a2, v4, "startInactivityTimer: Timeout period for %{public}@ ended, returning no files", v5);
}

void sub_100761F18()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "finishSession: Null session", v2, v3, v4, v5, v6);
}

void sub_100761F4C()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "finishSession: Finished retrieving accessory logs, but cannot invoke non-iOS or non-internal pop-up", v2, v3, v4, v5, v6);
}

void sub_100761F80()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Send RequestPeriodically to device was not sent successfully. Result Error Code %d", v2, v3, v4, v5, v6);
}

void sub_100761FE8()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Send CancelRequestPeriodically to device was not sent successfully. Result Error Code %d", v2, v3, v4, v5, v6);
}

void sub_100762050()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "syncLogOnDemandEvent: No stack", v2, v3, v4, v5, v6);
}

void sub_100762084()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "syncLogOnDemandEvent: No AACP connection", v2, v3, v4, v5, v6);
}

void sub_1007620B8()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "syncLogOnDemandEvent: AccessoryLoggingManager called when busy", v2, v3, v4, v5, v6);
}

void sub_1007620EC()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "syncLogOnDemandEvent: This request is not allowed", v2, v3, v4, v5, v6);
}

void sub_100762120(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 40);
  uint64_t v2 = *(void *)(a1 + 48);
  if (v1 != v2)
  {
    int v3 = 0;
    do
    {
      unsigned int v4 = *(unsigned __int8 *)(*(void *)v1 + 40);
      BOOL v5 = v4 > 8;
      int v6 = (1 << v4) & 0x182;
      if (!v5 && v6 != 0) {
        ++v3;
      }
      v1 += 8;
    }
    while (v1 != v2);
  }
  sub_1000574EC();
  sub_100057310((void *)&_mh_execute_header, v8, v9, "syncLogOnDemandEvent: Accessory retrieval timed out with %d remaining session(s); sending files now",
    v10,
    v11,
    v12,
    v13,
    v14);
}

void sub_1007621D4()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "purgeCallback: No current callback from sysdiagnose", v2, v3, v4, v5, v6);
}

void sub_100762208()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "removeAccessoryLoggingSession: Session not found", v2, v3, v4, v5, v6);
}

void sub_10076223C(uint64_t a1, uint64_t a2)
{
  sub_1003FAE34(a1, a2, 7.2225e-34);
  sub_100057420((void *)&_mh_execute_header, v2, (uint64_t)v2, "recvLoggingHandler: Invalid address %{private, mask.hash}s", v3);
}

void sub_100762278()
{
  sub_1003FAE54();
  id v1 = sub_1003FAE1C(v0);
  sub_100057360();
  sub_1000DDF08((void *)&_mh_execute_header, v2, v3, "recvLoggingHandler: %{public}@ sent invalid logging type = %d", v4, v5, v6, v7, v8);
}

void sub_100762300(uint64_t a1, NSObject *a2)
{
  id v3 = sub_1003FAE1C(a1);
  sub_10005732C();
  sub_100057438((void *)&_mh_execute_header, a2, v4, "recvLoggingHandler: Ignoring log data from %{public}@", v5);
}

void sub_100762388(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_10025B48C(a1, a2, a3, a4, a5, a6, a7, a8);
  sub_1003FADFC();
  sub_100057394((void *)&_mh_execute_header, v8, v9, "recvW1SCPLogHandler: Invalid address %{private, mask.hash}s", v10, v11, v12, v13, v14);
}

void sub_100762400(uint64_t a1)
{
  id v1 = sub_1003FAE1C(a1);
  sub_1003FAE60();
  sub_1000DDF08((void *)&_mh_execute_header, v2, v3, "recvW1SCPLogHandler: %{public}@ productId = %d unsupported for SCP logging", v4, v5, v6, v7, v8);
}

void sub_10076248C(NSObject *a1)
{
  __error();
  sub_1000574EC();
  sub_100080510((void *)&_mh_execute_header, a1, v2, "recvW1SCPLogHandler: SCP log file open failure -> %d", v3);
}

void sub_100762510(NSObject *a1)
{
  __error();
  sub_1000574EC();
  sub_100080510((void *)&_mh_execute_header, a1, v2, "DebugData log file open failure -> %d", v3);
}

void sub_100762594(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_10025B48C(a1, a2, a3, a4, a5, a6, a7, a8);
  sub_1003FADFC();
  sub_100057394((void *)&_mh_execute_header, v8, v9, "recvW1AppDiagnosticsHandler: Invalid address %{private, mask.hash}s", v10, v11, v12, v13, v14);
}

void sub_100762610(NSObject *a1)
{
  __error();
  sub_1000574EC();
  sub_100080510((void *)&_mh_execute_header, a1, v2, "recvW1AppDiagnosticsHandler: AppDiag log file open failure -> %d", v3);
}

void sub_100762698()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Buddy command was not sent successfully. Result Error Code %d", v2, v3, v4, v5, v6);
}

void sub_100762700()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Send Power Logging Request Periodically to device was not sent successfully. Result Error Code %d", v2, v3, v4, v5, v6);
}

void sub_100762768(NSObject *a1)
{
  __error();
  sub_1000574EC();
  sub_100080510((void *)&_mh_execute_header, a1, v2, "Power log file open failure -> %d", v3);
}

void sub_1007627EC()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Send the Buddy Power command to Right Bud was not sent successfully. Result Error Code %d", v2, v3, v4, v5, v6);
}

void sub_100762854()
{
  sub_1003FAE54();
  id v1 = sub_1003FAE1C(v0);
  sub_100057360();
  sub_1000DDF08((void *)&_mh_execute_header, v2, v3, "recvW1CrashTraceHandler: Failed to send buddy command to to %{public}@, error = %d", v4, v5, v6, v7, v8);
}

void sub_1007628DC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_10025B48C(a1, a2, a3, a4, a5, a6, a7, a8);
  sub_1003FADFC();
  sub_100057394((void *)&_mh_execute_header, v8, v9, "recvLogHandler: Invalid address %{private, mask.hash}s", v10, v11, v12, v13, v14);
}

void sub_100762954(uint64_t a1)
{
  id v1 = sub_1003FAE1C(a1);
  sub_1001604AC();
  sub_1000DDF08((void *)&_mh_execute_header, v2, v3, "recvLogHandler: Log data for %{public}@ shorter than %d byte header", v4, v5, v6, v7, v8);
}

void sub_1007629DC()
{
  __error();
  sub_1000DDF08((void *)&_mh_execute_header, v0, v1, "recvLogHandler: Could not open file %@ (error = %d)", v2, v3, v4, v5, 2u);
}

void sub_100762A70()
{
  sub_1003FAE54();
  id v1 = sub_1003FAE1C(v0);
  sub_100057360();
  sub_1000DDF08((void *)&_mh_execute_header, v2, v3, "recvLogHandler: No open log file for %{public}@ (packetSeqNum = %d)", v4, v5, v6, v7, v8);
}

void sub_100762AF8()
{
  sub_1000574EC();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "recvLogHandler: Unrecognized requester value %u", v2, v3, v4, v5, v6);
}

void sub_100762B64()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "recvLogHandler: No recognized byte for radar requester", v2, v3, v4, v5, v6);
}

void sub_100762B98()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "recvLogHandler: No data received", v2, v3, v4, v5, v6);
}

void sub_100762BCC()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "retransBuddyCMD: No stack", v2, v3, v4, v5, v6);
}

void sub_100762C00(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_10025B48C(a1, a2, a3, a4, a5, a6, a7, a8);
  sub_1003FADFC();
  sub_100057394((void *)&_mh_execute_header, v8, v9, "retransBuddyCMD: Invalid address %{private, mask.hash}s", v10, v11, v12, v13, v14);
}

void sub_100762C78(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_10025B48C(a1 + 409, a2, a3, a4, a5, a6, a7, a8);
  sub_1000DDF08((void *)&_mh_execute_header, v8, v9, "retransBuddyCMD: Buddy retransmission hit the max limit of retries. Buddy CMD type -> %d, Remote addr -> addr \"%s\" ", v10, v11, v12, v13, 2u);
}

void sub_100762D0C()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Sync crash log with buddy comamnd failed as test mode cannot be enabled", v2, v3, v4, v5, v6);
}

void sub_100762D40(NSObject *a1)
{
  __error();
  sub_1000574EC();
  sub_100080510((void *)&_mh_execute_header, a1, v2, "Accessory crash binary log file open failure -> %d", v3);
}

void sub_100762DC4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_10025B48C(a1, a2, a3, a4, a5, a6, a7, a8);
  sub_1003FADFC();
  sub_100057394((void *)&_mh_execute_header, v8, v9, "syncW1CrashLogHandler: Invalid address %{private, mask.hash}s", v10, v11, v12, v13, v14);
}

void sub_100762E3C(uint64_t a1, uint64_t a2)
{
  sub_1003FAE34(a1, a2, 7.2225e-34);
  sub_100057420((void *)&_mh_execute_header, v2, (uint64_t)v2, "recvCrashAvailableHandler: Invalid address %{private, mask.hash}s", v3);
}

void sub_100762E78(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_10025B48C(a1, a2, a3, a4, a5, a6, a7, a8);
  sub_1003FADFC();
  sub_100057394((void *)&_mh_execute_header, v8, v9, "recvLogCompleteHandler: Invalid address %{private, mask.hash}s", v10, v11, v12, v13, v14);
}

void sub_100762EF0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_10025B48C(a1, a2, a3, a4, a5, a6, a7, a8);
  sub_1003FADFC();
  sub_100057394((void *)&_mh_execute_header, v8, v9, "recvLogForceSendHandler: Invalid address %{private, mask.hash}s", v10, v11, v12, v13, v14);
}

void sub_100762F68(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_10025B48C(a1, a2, a3, a4, a5, a6, a7, a8);
  sub_1003FADFC();
  sub_100057394((void *)&_mh_execute_header, v8, v9, "recvFileRadarRequestHandler: Invalid address %{private, mask.hash}s", v10, v11, v12, v13, v14);
}

void sub_100762FE0()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "recvFileRadarRequestHandler: Cannot retrieve logs from this accessory", v2, v3, v4, v5, v6);
}

void sub_100763014()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "recvAwdHandler: Invalid AWD packet of length %u", v2, v3, v4, v5, v6);
}

void sub_10076307C()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "recvAwdHandler: Unrecognized AWD data type: %u", v2, v3, v4, v5, v6);
}

void sub_1007630E4()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Unsupported AccessoryLogType: %d", v2, v3, v4, v5, v6);
}

void sub_10076314C()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Unsupported AccessoryLogDevice: %d", v2, v3, v4, v5, v6);
}

void sub_1007631B4(uint64_t *a1, uint64_t a2, NSObject *a3)
{
  uint64_t v3 = *a1;
  int v4 = 138412546;
  uint64_t v5 = v3;
  __int16 v6 = 2112;
  uint64_t v7 = a2;
  sub_100057420((void *)&_mh_execute_header, a3, (uint64_t)a3, "closeCurrentLogFile: Could not rename file %@ (error = %@)", (uint8_t *)&v4);
}

void sub_100763238()
{
  sub_1000574EC();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "parseCrashLogMetadata: Invalid length %d", v2, v3, v4, v5, v6);
}

void sub_1007632A4(int a1, NSObject *a2)
{
  v2[0] = 67109376;
  v2[1] = 0;
  __int16 v3 = 1024;
  int v4 = a1;
  _os_log_error_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_ERROR, "parseCrashLogMetadata: Invalid crash log length %d for log number %d", (uint8_t *)v2, 0xEu);
}

void sub_100763328()
{
  sub_1002CC76C();
  HIWORD(v4) = v0;
  sub_100057498((void *)&_mh_execute_header, v1, v2, "parseCrashLogMetadata: Unprintable character %d in core name for log number %d", v3, v4);
}

void sub_100763398()
{
  sub_1002CC76C();
  HIWORD(v4) = v0;
  sub_100057498((void *)&_mh_execute_header, v1, v2, "parseCrashLogMetadata: Length %d doesn't match num crash logs %d", v3, v4);
}

void sub_10076340C()
{
  sub_10005732C();
  __int16 v3 = 2112;
  uint64_t v4 = v0;
  sub_100057420((void *)&_mh_execute_header, v1, (uint64_t)v1, "processCrashInstanceForAnalytics: Could not produce output JSON for %@, error %@", v2);
}

void sub_100763488()
{
  sub_1001604AC();
  sub_100057518((void *)&_mh_execute_header, v0, v1, "processCrashInstanceForAnalytics: Leftover metadata for %@ after %d chunks");
}

void sub_1007634F4(uint8_t *buf, unsigned char *a2, os_log_t log)
{
  *uint64_t buf = 0;
  *a2 = 0;
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "processCrashInstanceForAnalytics: Could not create chunk", buf, 2u);
}

void sub_100763534(int a1, uint64_t a2, NSObject *a3)
{
  *(_DWORD *)__int16 v3 = 138412546;
  *(void *)&v3[4] = a2;
  *(_WORD *)&v3[12] = 1024;
  *(_DWORD *)&v3[14] = a1;
  sub_100057518((void *)&_mh_execute_header, a2, a3, "processCrashInstanceForAnalytics: Ran out of metadata for %@ on chunk %d", *(void *)v3, *(void *)&v3[8], *(_WORD *)&v3[16]);
}

void sub_1007635AC()
{
  sub_10005732C();
  sub_100057438((void *)&_mh_execute_header, v0, v1, "processCrashLogForAnalytics: Could not decode %@", v2);
}

void sub_100763618()
{
  sub_10005732C();
  sub_100057438((void *)&_mh_execute_header, v0, v1, "processCrashLogForAnalytics: Could not find crash log sections in %@", v2);
}

void sub_100763684()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "triggerW1AWDDiagnosticsEvent: No stack", v2, v3, v4, v5, v6);
}

void sub_1007636B8()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "triggerW1AWDDiagnosticsEvent: No AACP connection to a W1 accessory", v2, v3, v4, v5, v6);
}

void sub_1007636EC()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "triggerW1AWDDiagnosticsEvent: AACP_CUSTOM_MESSAGE_TYPE_APP_DIAGNOSTICS was not sent successfully. Result Error Code %d", v2, v3, v4, v5, v6);
}

void sub_100763754()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "triggerW1AWDDiagnosticsEvent: This request is only available in iOS with Internal Build", v2, v3, v4, v5, v6);
}

void sub_100763788()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "retransBuddyCMD: No AACP connection to a W1 accessory", v2, v3, v4, v5, v6);
}

void sub_1007637BC()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "retransBuddyCMD: Buddy command was not sent successfully, error: %d", v2, v3, v4, v5, v6);
}

void sub_100763824()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "No valid connection for current addr", v2, v3, v4, v5, v6);
}

void sub_100763858()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Invalid buddy command type : %d", v2, v3, v4, v5, v6);
}

void sub_1007638C0()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Not supported log type to be converted %d", v2, v3, v4, v5, v6);
}

void sub_100763928()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "sendLogCompleteCallback: deviceForCallback expected not to be NULL", v2, v3, v4, v5, v6);
}

void sub_10076395C(os_log_t log)
{
  *(_WORD *)uint64_t v1 = 0;
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "[BTVCLinkAgent] ### Ignoring update before activate\n", v1, 2u);
}

void sub_1007639A0(os_log_t log)
{
  *(_WORD *)uint64_t v1 = 0;
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "[BTVCLinkAgent] ### Ignoring reset before activate\n", v1, 2u);
}

void sub_1007639E4(os_log_t log)
{
  int v1 = 136315138;
  uint64_t v2 = "-[BTVCLinkAgent leSetExtendedAdvertisingEnable:numSets:advertisingHandles:]";
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "%s, _bleBTVCLinkAdvertiser is not initialized", (uint8_t *)&v1, 0xCu);
}

void sub_100763A68(os_log_t log)
{
  int v1 = 136315138;
  uint64_t v2 = "-[BTVCLinkAgent leSetExtendedScanEnable:]";
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "%s, _bleBTVCLinkScanner is not initialized", (uint8_t *)&v1, 0xCu);
}

void sub_100763AEC()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "LE_GetNextAvailableLePSM failed with error %d", v2, v3, v4, v5, v6);
}

void sub_100763B54()
{
  sub_1000572DC();
  sub_10030D118((void *)&_mh_execute_header, v0, v1, "pid cannot be 0", v2, v3, v4, v5, v6);
}

void sub_100763B88()
{
  sub_1000572DC();
  sub_10030D118((void *)&_mh_execute_header, v0, v1, "Listener cannot be NULL", v2, v3, v4, v5, v6);
}

void sub_100763BBC()
{
  sub_1000572DC();
  sub_10030D118((void *)&_mh_execute_header, v0, v1, "Session cannot be NULL", v2, v3, v4, v5, v6);
}

void sub_100763BF0()
{
  sub_100407670();
  _os_log_fault_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_FAULT, "L2CAP Channel 0x%04x for session type %d has been unregistered with pipes remaining!", v1, 0xEu);
}

void sub_100763C70(void *a1, uint8_t *buf, os_log_t log)
{
  *(_DWORD *)uint64_t buf = 138543362;
  *(void *)(buf + 4) = a1;
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "Classic devices doesn't exist for %{public}@", buf, 0xCu);
}

void sub_100763CC8()
{
  sub_100057584();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "No service UUID exist for classic PSM: 0x%x", v2, v3, v4, v5, v6);
}

void sub_100763D30(const unsigned __int8 *a1)
{
  sub_100401EBC(a1, __p);
  if (v5 >= 0) {
    uint64_t v3 = __p;
  }
  else {
    uint64_t v3 = (void **)__p[0];
  }
  int v6 = 136446210;
  uint64_t v7 = v3;
  sub_100407688((void *)&_mh_execute_header, v1, v2, "Already connected to device %{public}s", (uint8_t *)&v6);
  if (v5 < 0) {
    operator delete(__p[0]);
  }
}

void sub_100763DDC()
{
  sub_1000572DC();
  sub_10030D118((void *)&_mh_execute_header, v0, v1, "psm cannot be 0", v2, v3, v4, v5, v6);
}

void sub_100763E10()
{
  int v2 = 136446210;
  uint64_t v3 = sub_100050714();
  sub_100407688((void *)&_mh_execute_header, v0, v1, "%{public}s", (uint8_t *)&v2);
}

void sub_100763E90()
{
  sub_100407670();
  sub_100057498((void *)&_mh_execute_header, v0, v1, "Could not find a session, endpoint or pipe for cid:%d PSM:%d", v2, v3);
}

void sub_100763F00()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "LE_L2CAP_Accept failed with status %d", v2, v3, v4, v5, v6);
}

void sub_100763F68(_DWORD *a1)
{
  int v3 = 134217984;
  uint64_t v4 = sub_100197B34(a1);
  sub_100407688((void *)&_mh_execute_header, v1, v2, "Connection manager wasn't tracking a device for connection handle %p!", (uint8_t *)&v3);
}

void sub_100763FEC()
{
  sub_100057584();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Could not find a session, endpoint or pipe for cid:%d", v2, v3, v4, v5, v6);
}

void sub_100764054()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "L2CAP Channel connect failure %d", v2, v3, v4, v5, v6);
}

void sub_1007640BC()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Can't find service UUID associated with psm:0x%x", v2, v3, v4, v5, v6);
}

void sub_100764124()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "A2DP callback registration failed with result %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_10076418C()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "A2DP callback deregistration failed with result %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_1007641F4()
{
  sub_100057584();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "No device was found for a2dpHandle %d", v2, v3, v4, v5, v6);
}

void sub_10076425C()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to connect - result was %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_1007642C4(uint64_t a1, NSObject *a2)
{
  sub_100474E18(a1, __p);
  if (v5 >= 0) {
    uint64_t v3 = __p;
  }
  else {
    uint64_t v3 = (void **)__p[0];
  }
  *(_DWORD *)uint64_t buf = 136446210;
  uint64_t v7 = v3;
  _os_log_error_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_ERROR, "Audio sink service not supported by device %{public}s", buf, 0xCu);
  if (v5 < 0) {
    operator delete(__p[0]);
  }
}

void sub_10076437C()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Attempting to disconnect from invalid device", v2, v3, v4, v5, v6);
}

void sub_1007643B0()
{
  sub_1002B7074();
  sub_100057550(v1, v2, v3, 4.8752e-34);
  sub_10041E7D0((void *)&_mh_execute_header, "Failed to disconnect A2DP profile from device %{public}s with result %{bluetooth:OI_STATUS}u", v4, v5);
  if (*(char *)(v0 + 23) < 0) {
    operator delete(*(void **)v0);
  }
}

void sub_100764400()
{
  sub_1002B7074();
  sub_100057550(v1, v2, v3, 4.8752e-34);
  sub_10041E7D0((void *)&_mh_execute_header, "Failed to close the streaming channel from device %{public}s with result %{bluetooth:OI_STATUS}u", v4, v5);
  if (*(char *)(v0 + 23) < 0) {
    operator delete(*(void **)v0);
  }
}

void sub_100764450()
{
  sub_100057584();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "No audio device was found for a2dpHandle %d", v2, v3, v4, v5, v6);
}

void sub_1007644B8()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Failed to find AVDTP version", v2, v3, v4, v5, v6);
}

void sub_1007644EC()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "No a2dpHandle found for streamHandle %d", v2, v3, v4, v5, v6);
}

void sub_100764554()
{
  sub_1000572DC();
  _os_log_debug_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_DEBUG, "isStreamingAudioToDevice: Unable to retrieve handle for device.", v1, 2u);
}

void sub_100764594()
{
  sub_1000574EC();
  _os_log_debug_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_DEBUG, "isStreamingAudioToDevice: Non-null A2DPAudioDevice retrieved. Streaming State: %d", v1, 8u);
}

void sub_10076460C()
{
  sub_1000572DC();
  _os_log_debug_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_DEBUG, "isStreamingAudioToDevice: Non-zero handle retrieved.", v1, 2u);
}

void sub_10076464C()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Failed to start streaming as stream handle was null", v2, v3, v4, v5, v6);
}

void sub_100764680()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Failed to start streaming as device was null", v2, v3, v4, v5, v6);
}

void sub_1007646B4(uint64_t *a1, NSObject *a2)
{
  uint64_t v2 = *a1;
  int v3 = 134217984;
  uint64_t v4 = v2;
  _os_log_error_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_ERROR, "Invalid sampling rate %f for acoustic tuning", (uint8_t *)&v3, 0xCu);
}

void sub_100764730()
{
  sub_10041E83C();
  uint64_t v3 = 2000;
  sub_1000574B8((void *)&_mh_execute_header, v0, v1, "Failed to suspend A2DP stream with result %{bluetooth:OI_STATUS}u - trying again in %llu seconds", v2);
}

void sub_1007647A4()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to suspend stream with result - %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_10076480C()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to start streaming with result %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_100764874()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "OI_HCI_ReadClock failed: returned %d", v2, v3, v4, v5, v6);
}

void sub_1007648DC()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Streaming state is pending response, can't call avdtp start multiple times", v2, v3, v4, v5, v6);
}

void sub_100764910()
{
  sub_1000573EC();
  if (v4 != v5) {
    uint64_t v6 = v3;
  }
  else {
    uint64_t v6 = v1;
  }
  sub_100057464(v2, v6, 4.8751e-34);
  sub_100057404((void *)&_mh_execute_header, v7, v8, "Failed to find compatible stream configuration for device %{public}s - disconnecting", v9);
  if (*(char *)(v0 + 23) < 0) {
    operator delete(*(void **)v0);
  }
}

void sub_100764964()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to set stream configuration with result %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_1007649CC(unsigned char *a1, NSObject *a2)
{
  if (*a1) {
    uint64_t v2 = "On";
  }
  else {
    uint64_t v2 = "Off";
  }
  int v3 = 136315138;
  uint64_t v4 = v2;
  _os_log_debug_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_DEBUG, "Publish AccessHeadTrack to BTHAL: %s", (uint8_t *)&v3, 0xCu);
}

void sub_100764A60()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "AVDTP send error %d", v2, v3, v4, v5, v6);
}

void sub_100764AC8()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Fail to dequeue head: status %d", v2, v3, v4, v5, v6);
}

void sub_100764B30()
{
  sub_10041E83C();
  uint64_t v3 = v0;
  sub_1000574B8((void *)&_mh_execute_header, v1, (uint64_t)v1, "A2DP packet flushed: Audio Queue full, remove oldest and insert sequence=%d (latest), timestamp=%llu", v2);
}

void sub_100764BA4()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to discover stream endpoints with result %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_100764C0C()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to accept connection attempt - result was %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_100764C74()
{
  sub_1002B7074();
  sub_10030D0B8(v1, v2, v3, 1.5047e-36);
  sub_10041E7D0((void *)&_mh_execute_header, "SDP query failed with error %d, aborting A2DP setup to %{public}s", v4, v5);
  if (*(char *)(v0 + 23) < 0) {
    operator delete(*(void **)v0);
  }
}

void sub_100764CC4()
{
  sub_1002B7074();
  sub_100057550(v1, v2, v3, 4.8752e-34);
  sub_10041E7D0((void *)&_mh_execute_header, "Failed to lookup AVDTP handle for device %{public}s with status %{bluetooth:OI_STATUS}u", v4, v5);
  if (*(char *)(v0 + 23) < 0) {
    operator delete(*(void **)v0);
  }
}

void sub_100764D14(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_100764D8C(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_100764E04()
{
  sub_1002B7074();
  sub_100057550(v1, v2, v3, 4.8752e-34);
  sub_10041E7D0((void *)&_mh_execute_header, "Connection to device %{public}s failed - result was %{bluetooth:OI_STATUS}u", v4, v5);
  if (*(char *)(v0 + 23) < 0) {
    operator delete(*(void **)v0);
  }
}

void sub_100764E54()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Bad48KHzCodecs: Cannot set user defined A2DP Sample Rate for our endpoints to %d Hz", v2, v3, v4, v5, v6);
}

void sub_100764EBC()
{
  sub_1000572DC();
  _os_log_fault_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_FAULT, "No A2DP Handle found", v1, 2u);
}

void sub_100764EFC()
{
  sub_1000573EC();
  if (v4 != v5) {
    uint64_t v6 = v3;
  }
  else {
    uint64_t v6 = v1;
  }
  sub_100057464(v2, v6, 4.8751e-34);
  sub_100057404((void *)&_mh_execute_header, v7, v8, "Couldn't find any valid stream endpoint IDs for device %{public}s - disconnecting", v9);
  if (*(char *)(v0 + 23) < 0) {
    operator delete(*(void **)v0);
  }
}

void sub_100764F50()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to get all capabilities with result %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_100764FB8()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to get capabilities with result %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_100765020(uint64_t a1, int a2)
{
  *(void *)(sub_10041E7EC(a1, a2, 1.5047e-36) + 10) = "null";
  sub_1000574B8((void *)&_mh_execute_header, v2, (uint64_t)v2, "Received endpoint discovery failure with result %d on device %{public}s", v3);
}

void sub_100765068()
{
  sub_1002B7074();
  sub_10030D0B8(v1, v2, v3, 1.5047e-36);
  sub_10041E7D0((void *)&_mh_execute_header, "Received endpoint discovery failure with result %d on device %{public}s", v4, v5);
  if (*(char *)(v0 + 23) < 0) {
    operator delete(*(void **)v0);
  }
}

void sub_1007650B8()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to accept stream configuration with result %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_100765120()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to reject stream configuration with result %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_100765188()
{
  sub_100057584();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Rejecting the suggested stream configuration from a2dpHandle %d as we were unable to select it", v2, v3, v4, v5, v6);
}

void sub_1007651F0()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Device has gone away, skipping setting config", v2, v3, v4, v5, v6);
}

void sub_100765224()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to open stream with result %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_10076528C(uint64_t a1, int a2)
{
  *(void *)(sub_10041E7EC(a1, a2, 1.5047e-36) + 10) = "null";
  sub_1000574B8((void *)&_mh_execute_header, v2, (uint64_t)v2, "Received set stream configuration failure with result %u on device %{public}s", v3);
}

void sub_1007652D4()
{
  sub_1002B7074();
  sub_10030D0B8(v1, v2, v3, 1.5047e-36);
  sub_10041E7D0((void *)&_mh_execute_header, "Received set stream configuration failure with result %u on device %{public}s", v4, v5);
  if (*(char *)(v0 + 23) < 0) {
    operator delete(*(void **)v0);
  }
}

void sub_100765324(uint64_t a1, int a2)
{
  *(void *)(sub_10041E7EC(a1, a2, 1.5047e-36) + 10) = "null";
  sub_1000574B8((void *)&_mh_execute_header, v2, (uint64_t)v2, "Received get configuration failure with result %u on device %{public}s", v3);
}

void sub_10076536C()
{
  sub_1002B7074();
  sub_10030D0B8(v1, v2, v3, 1.5047e-36);
  sub_10041E7D0((void *)&_mh_execute_header, "Received get configuration failure with result %u on device %{public}s", v4, v5);
  if (*(char *)(v0 + 23) < 0) {
    operator delete(*(void **)v0);
  }
}

void sub_1007653BC()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to accept stream open command with result %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_100765424()
{
  sub_1000573EC();
  if (v4 != v5) {
    uint64_t v6 = v3;
  }
  else {
    uint64_t v6 = v1;
  }
  sub_100057464(v2, v6, 4.8751e-34);
  sub_100057404((void *)&_mh_execute_header, v7, v8, "A disconnection is pending for device %{public}s -- disconnecting", v9);
  if (*(char *)(v0 + 23) < 0) {
    operator delete(*(void **)v0);
  }
}

void sub_100765478()
{
  sub_1002B7074();
  sub_10030D0B8(v1, v2, v3, 1.5047e-36);
  sub_10041E7D0((void *)&_mh_execute_header, "Failed to open streaming channel failure with result %u on device %{public}s", v4, v5);
  if (*(char *)(v0 + 23) < 0) {
    operator delete(*(void **)v0);
  }
}

void sub_1007654C8(uint64_t a1, int a2)
{
  *(void *)(sub_10041E7EC(a1, a2, 1.5047e-36) + 10) = "null";
  sub_1000574B8((void *)&_mh_execute_header, v2, (uint64_t)v2, "Failed to open streaming channel failure with result %u on device %{public}s", v3);
}

void sub_100765510()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Wireless Splitter not able to locate last connected audio device", v2, v3, v4, v5, v6);
}

void sub_100765544()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Wireless Splitter device object is gone..", v2, v3, v4, v5, v6);
}

void sub_100765578()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to send security control response with result %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_1007655E0()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed send start response with result %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_100765648()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Invalid handles were passed from the stack", v2, v3, v4, v5, v6);
}

void sub_10076567C()
{
  sub_10041E824();
  sub_10041E800(1.5047e-36, v1, v2, v3);
  sub_10041E7D0((void *)&_mh_execute_header, "Failed to start streaming procedure with result %u on device %{public}s - disconnecting", v4, v5);
  if (*(char *)(v0 + 23) < 0) {
    operator delete(*(void **)v0);
  }
}

void sub_1007656CC()
{
  sub_1000574EC();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Start failed, no handles, error=%{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_100765738()
{
  sub_10041E824();
  sub_10041E800(1.5047e-36, v1, v2, v3);
  sub_10041E7D0((void *)&_mh_execute_header, "Failed to suspend stream with result %u on device %{public}s, initiate device disconnection", v4, v5);
  if (*(char *)(v0 + 23) < 0) {
    operator delete(*(void **)v0);
  }
}

void sub_100765788()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "TransitionCfm - invalid handles were passed from the stack", v2, v3, v4, v5, v6);
}

void sub_1007657BC()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to send reconfigure response with result %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_100765824()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Received abort stream request after device disconnected", v2, v3, v4, v5, v6);
}

void sub_100765858()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Received delay report on handle %d for a device that is already disconnected", v2, v3, v4, v5, v6);
}

void sub_1007658C0()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Dynamic Latency incorrect dynamicLatencyJitterBuffer value", v2, v3, v4, v5, v6);
}

void sub_1007658F4()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Dynamic Latency controller flush timeout failed with with error %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_10076595C()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Adaptive Latency controller flush timeout failed with with error %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_1007659C4()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Piconet clock read error %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_100765A2C()
{
  sub_1000574EC();
  __int16 v3 = 2048;
  uint64_t v4 = v0;
  sub_1000574B8((void *)&_mh_execute_header, v1, (uint64_t)v1, "A2DP packet flushed: L2CAP (chip) flush occured. Current sequence=%d, timestamp=%llu", v2);
}

void sub_100765AAC()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "listenModeSupport is null, returning with error BT_ERROR_INVALID_ARGUMENT", v2, v3, v4, v5, v6);
}

void sub_100765AE0()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to configure Software Volume error %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_100765B48(int a1, NSObject *a2)
{
  v2[0] = 67109376;
  v2[1] = 500;
  __int16 v3 = 1024;
  int v4 = a1;
  _os_log_error_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_ERROR, "Failed to configure jitter buffer to 0x%x with error %{bluetooth:OI_STATUS}u", (uint8_t *)v2, 0xEu);
}

void sub_100765BD0()
{
  sub_100057584();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "setAllowsAutoRoute find audio device handle failed %d", v2, v3, v4, v5, v6);
}

void sub_100765C38()
{
  sub_100057584();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "setAudioRouteHidden find audio device handle failed %d", v2, v3, v4, v5, v6);
}

void sub_100765CA0()
{
  sub_100057584();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "setHijackAudioRoute Failed to find audio device with hanlde %d", v2, v3, v4, v5, v6);
}

void sub_100765D08()
{
  sub_100057584();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "setTipiConnection Failed to find audio device with handle %d", v2, v3, v4, v5, v6);
}

void sub_100765D70()
{
  sub_100057584();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "setUserSelectedDeviceType Failed to find audio device with handle %d", v2, v3, v4, v5, v6);
}

void sub_100765DD8()
{
  sub_1000574EC();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Audio Timesync: Audio delivery failed: %d", v2, v3, v4, v5, v6);
}

void sub_100765E44()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Failed to send volume ramp end message device is null", v2, v3, v4, v5, v6);
}

void sub_100765E78()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to send volume ramp end message error %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_100765EE0()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Failed to send manual volume update message device is null", v2, v3, v4, v5, v6);
}

void sub_100765F14()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to send manual volume update message error %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_100765F7C()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Spatial Audio Mode: invalid device", v2, v3, v4, v5, v6);
}

void sub_100765FB0()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to configure PME On Buds error %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_100766018()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Device disconnected in dispatched audioErrorNeedsDisconnect", v2, v3, v4, v5, v6);
}

void sub_10076604C()
{
  sub_1000573EC();
  if (v4 != v5) {
    uint64_t v6 = v3;
  }
  else {
    uint64_t v6 = v1;
  }
  sub_100057464(v2, v6, 4.8751e-34);
  sub_100057404((void *)&_mh_execute_header, v7, v8, "Detected error from the plugin, disconnecting audio device %{public}s", v9);
  if (*(char *)(v0 + 23) < 0) {
    operator delete(*(void **)v0);
  }
}

void sub_1007660A0()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Could not transition given stream state:%d", v2, v3, v4, v5, v6);
}

void sub_100766108()
{
  sub_1000574EC();
  __int16 v3 = 1024;
  int v4 = v0;
  _os_log_error_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_ERROR, "Failed to configure jitter buffer to 0x%x with error %{bluetooth:OI_STATUS}u", v2, 0xEu);
}

void sub_100766190()
{
  sub_100057584();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Dynamic Latency audio / device object does not exist for handle %d ", v2, v3, v4, v5, v6);
}

void sub_1007661F8()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Adaptive Latency adaptiveLatencyAudioModification invalid device", v2, v3, v4, v5, v6);
}

void sub_10076622C()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "initA2DPFastConnect error creating A2DP media", v2, v3, v4, v5, v6);
}

void sub_100766260()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "composeA2DPDescriptor out of memory", v2, v3, v4, v5, v6);
}

void sub_100766294()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "composeA2DPDescriptor error getting media L2CAP data", v2, v3, v4, v5, v6);
}

void sub_1007662C8()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "composeA2DPDescriptor error getting signaling L2CAP data", v2, v3, v4, v5, v6);
}

void sub_1007662FC()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "composeA2DPDescriptor endpoints error", v2, v3, v4, v5, v6);
}

void sub_100766330(unsigned char *a1, unsigned char *a2)
{
  sub_10026C69C(a1, a2);
  sub_1000573D0((void *)&_mh_execute_header, v2, v3, "parseA2DPDescriptor L2CAP signal channel not found", v4);
}

void sub_10076635C()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "parseA2DPEndpoints - No endpoints in descriptor", v2, v3, v4, v5, v6);
}

void sub_100766390()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "parseA2DPEndpoints - Error allocating Discovery Rsp Info", v2, v3, v4, v5, v6);
}

void sub_1007663C4()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "parseA2DPEndpoints Error Endpoint Info contains extra %d bytes", v2, v3, v4, v5, v6);
}

void sub_10076642C(unsigned char *a1, unsigned char *a2)
{
  sub_10026C69C(a1, a2);
  sub_1000573D0((void *)&_mh_execute_header, v2, v3, "parseA2DPEndpoints Endpoint Caps Parse ERROR", v4);
}

void sub_100766458()
{
  sub_1000574EC();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "parseA2DPEndpoints - Error Finding A2DP Handle for CID  %d", v2, v3, v4, v5, v6);
}

void sub_1007664C4()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "SelectStreamConfigFastConnect Invalid stream state %d, cannot select stream config unless in CONNECTING or INVALID state", v2, v3, v4, v5, v6);
}

void sub_10076652C()
{
  sub_1000573EC();
  if (v4 != v5) {
    uint64_t v6 = v3;
  }
  else {
    uint64_t v6 = v1;
  }
  sub_100057464(v2, v6, 4.8751e-34);
  sub_100057404((void *)&_mh_execute_header, v7, v8, "SelectStreamConfigFastConnectFailed to find compatible stream configuration for device %{public}s - disconnecting", v9);
  if (*(char *)(v0 + 23) < 0) {
    operator delete(*(void **)v0);
  }
}

void sub_100766580()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "SelectStreamConfigFastConnect Failed to set stream configuration with result %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_1007665E8(uint8_t *buf, NSObject *a2)
{
  *(_DWORD *)uint64_t buf = 136446210;
  *(void *)(buf + 4) = "null";
  _os_log_error_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_ERROR, "fastConnectA2DPSetupComplete Failed to open streaming channel failure on device %{public}s", buf, 0xCu);
}

void sub_100766634()
{
  sub_1000573EC();
  if (v4 != v5) {
    uint64_t v6 = v3;
  }
  else {
    uint64_t v6 = v1;
  }
  sub_100057464(v2, v6, 4.8751e-34);
  sub_100057404((void *)&_mh_execute_header, v7, v8, "fastConnectA2DPSetupComplete Failed to open streaming channel failure on device %{public}s", v9);
  if (*(char *)(v0 + 23) < 0) {
    operator delete(*(void **)v0);
  }
}

void sub_100766688()
{
  sub_1000574EC();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "No audio device was found for a2dpHandle %d", v2, v3, v4, v5, v6);
}

void sub_1007666F4()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Failed to read BT clock", v2, v3, v4, v5, v6);
}

void sub_100766728()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Failed to create DIS UDI For Medical Devices value!", v2, v3, v4, v5, v6);
}

void sub_10076675C()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Failed to create DIS PNP ID value!", v2, v3, v4, v5, v6);
}

void sub_100766790()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Failed to create DIS Regulatory data value!", v2, v3, v4, v5, v6);
}

void sub_1007667C4()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Failed to create DIS System ID value!", v2, v3, v4, v5, v6);
}

void sub_1007667F8()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Failed to create DIS SW Revision value!", v2, v3, v4, v5, v6);
}

void sub_10076682C()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Failed to create DIS FW Revision value!", v2, v3, v4, v5, v6);
}

void sub_100766860()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Failed to create DIS HW Revision value!", v2, v3, v4, v5, v6);
}

void sub_100766894()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Failed to create DIS Serial Number value!", v2, v3, v4, v5, v6);
}

void sub_1007668C8()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Failed to create DIS Model Number Name value!", v2, v3, v4, v5, v6);
}

void sub_1007668FC()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Failed to create DIS MFGR Name value!", v2, v3, v4, v5, v6);
}

void sub_100766930()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Failed to create product type number value!", v2, v3, v4, v5, v6);
}

void sub_100766964()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Failed to create manufacturer name value!", v2, v3, v4, v5, v6);
}

void sub_100766998()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Failed to create GAP device name value!", v2, v3, v4, v5, v6);
}

void sub_1007669CC()
{
  sub_1000572DC();
  _os_log_fault_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_FAULT, "GattServer expects that it's always GAP, followed by GATT!", v1, 2u);
}

void sub_100766A0C(char a1, NSObject *a2, uint64_t a3)
{
  uint64_t v3 = "GATT";
  if (a1) {
    uint64_t v3 = "GAP";
  }
  int v4 = 136446210;
  uint64_t v5 = v3;
  sub_100057438((void *)&_mh_execute_header, a2, a3, "Failed to publish %{public}s service!", (uint8_t *)&v4);
}

void sub_100766A94()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Failed to initialize GATT database!", v2, v3, v4, v5, v6);
}

void sub_100766AC8()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "dummy DIS already published, cannot register a new one", v2, v3, v4, v5, v6);
}

void sub_100766AFC()
{
  sub_1000573EC();
  if (v4 != v5) {
    uint64_t v6 = v3;
  }
  else {
    uint64_t v6 = v1;
  }
  sub_100057464(v2, v6, 4.8751e-34);
  sub_100057438((void *)&_mh_execute_header, v7, (uint64_t)v7, "Application is trying to publish a characteristic value with reserved UUID %{public}s", v8);
  if (*(char *)(v0 + 23) < 0) {
    operator delete(*(void **)v0);
  }
}

void sub_100766B54()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to add characteristic descriptor with result %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_100766BBC()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to add characteristic with result %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_100766C24(char a1, NSObject *a2, uint64_t a3)
{
  uint64_t v3 = "notify";
  if ((a1 & 0x10) == 0) {
    uint64_t v3 = "indicate";
  }
  int v4 = 136446210;
  uint64_t v5 = v3;
  sub_100057438((void *)&_mh_execute_header, a2, a3, "Characteristic set for %{public}s without client configuration descriptor!", (uint8_t *)&v4);
}

void sub_100766CAC()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Characteristic set for broadcast without server configuration descriptor!", v2, v3, v4, v5, v6);
}

void sub_100766CE0()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Characteristic set for extended property without extended property descriptor!", v2, v3, v4, v5, v6);
}

void sub_100766D14()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Duplicate User Description descriptor found!", v2, v3, v4, v5, v6);
}

void sub_100766D48()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Duplicate Presentation Format descriptor found!", v2, v3, v4, v5, v6);
}

void sub_100766D7C()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Cached characteristics cannot have any write permissions!", v2, v3, v4, v5, v6);
}

void sub_100766DB0()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Cached characteristics cannot have any properties other than \"read-only\"!", v2, v3, v4, v5, v6);
}

void sub_100766DE4()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Can't register an included service that references an unknown service!", v2, v3, v4, v5, v6);
}

void sub_100766E18()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to add included service with result %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_100766E80()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to add service with result %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_100766EE8(int *a1, NSObject *a2)
{
  int v2 = *a1;
  v3[0] = 67109120;
  v3[1] = v2;
  _os_log_fault_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_FAULT, "Couldn't find service attribute with ID 0x%x!", (uint8_t *)v3, 8u);
}

void sub_100766F64(char *a1, uint8_t *buf, int a3, os_log_t log)
{
  if (a1[23] >= 0) {
    uint64_t v5 = a1;
  }
  else {
    uint64_t v5 = *(char **)a1;
  }
  *(_DWORD *)uint64_t buf = 136446466;
  *(void *)(buf + 4) = v5;
  *((_WORD *)buf + 6) = 1024;
  *(_DWORD *)(buf + 14) = a3;
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "Failed to re-publish service %{public}s with result %d!", buf, 0x12u);
  if (a1[23] < 0) {
    operator delete(*(void **)a1);
  }
}

void sub_100766FE8(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_100767058(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_1007670C8()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Unable to find characteristic with ID 0x%x!", v2, v3, v4, v5, v6);
}

void sub_100767130()
{
  sub_1000573EC();
  if (v4 != v5) {
    uint64_t v6 = v3;
  }
  else {
    uint64_t v6 = v1;
  }
  sub_100057464(v2, v6, 4.8751e-34);
  sub_100057438((void *)&_mh_execute_header, v7, (uint64_t)v7, "Unable to find Client Characteristic Configuration Descriptor for %{public}s!", v8);
  if (*(char *)(v0 + 23) < 0) {
    operator delete(*(void **)v0);
  }
}

void sub_100767188()
{
  sub_1000573EC();
  if (v4 != v5) {
    uint64_t v6 = v3;
  }
  else {
    uint64_t v6 = v1;
  }
  sub_100057464(v2, v6, 4.8751e-34);
  sub_100057438((void *)&_mh_execute_header, v7, (uint64_t)v7, "No subscribed devices for %{public}s!", v8);
  if (*(char *)(v0 + 23) < 0) {
    operator delete(*(void **)v0);
  }
}

void sub_1007671E0()
{
  sub_1000573EC();
  if (v4 != v5) {
    uint64_t v6 = v3;
  }
  else {
    uint64_t v6 = v1;
  }
  sub_100057464(v2, v6, 4.8751e-34);
  sub_100057438((void *)&_mh_execute_header, v7, (uint64_t)v7, "Ignoring update for session \"%{public}s\" as there is already one queued", v8);
  if (*(char *)(v0 + 23) < 0) {
    operator delete(*(void **)v0);
  }
}

void sub_100767238(uint8_t *buf, unsigned char *a2, os_log_t log)
{
  *uint64_t buf = 0;
  *a2 = 0;
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "Client config went away while waiting to send update!", buf, 2u);
}

void sub_100767278()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Transaction %d not in pending transaction map!", v2, v3, v4, v5, v6);
}

void sub_1007672E0()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Transaction %d timed out waiting on response", v2, v3, v4, v5, v6);
}

void sub_100767348()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Session not found in fDeviceSessions", v2, v3, v4, v5, v6);
}

void sub_10076737C(uint64_t a1, NSObject *a2)
{
  int v2 = 136315394;
  uint64_t v3 = "indicationConfirmed";
  __int16 v4 = 2114;
  uint64_t v5 = a1;
  _os_log_error_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_ERROR, "%s - Unexpected Response - Device:%{public}@", (uint8_t *)&v2, 0x16u);
}

void sub_100767408()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Connection doesn't have any prepared writes queued!", v2, v3, v4, v5, v6);
}

void sub_10076743C()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Denying value read as characteristic is not readable!", v2, v3, v4, v5, v6);
}

void sub_100767470()
{
  sub_1000572DC();
  _os_log_fault_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_FAULT, "GATT/GAP service data should always be cached!", v1, 2u);
}

void sub_1007674B0()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Couldn't find attribute!", v2, v3, v4, v5, v6);
}

void sub_1007674E4()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Denying value write as characteristic is not writeable!", v2, v3, v4, v5, v6);
}

void sub_100767518()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Refusing Prepare Write Request as no \"reliable write\" extended property was specified for this characteristic", v2, v3, v4, v5, v6);
}

void sub_10076754C(uint64_t a1, uint64_t a2, uint8_t *buf, os_log_t log)
{
  *(_DWORD *)uint64_t buf = 67109376;
  *((_DWORD *)buf + 1) = 512;
  *((_WORD *)buf + 4) = 2048;
  *(void *)(buf + 10) = a1 + a2 - 512;
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "Refusing Prepare Write Request as it would exceed the maximum amount of data queued (%u) for this connection by %lu byte(s)", buf, 0x12u);
}

void sub_1007675B0()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Refusing Prepare Write Request as the service doesn't match the other requests in the queue", v2, v3, v4, v5, v6);
}

void sub_1007675E4()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Refusing Prepare Write Request to configuration descriptor", v2, v3, v4, v5, v6);
}

void sub_100767618(uint64_t a1, NSObject *a2, uint64_t a3)
{
  int v3 = 136446210;
  uint64_t v4 = a1;
  sub_100057438((void *)&_mh_execute_header, a2, a3, "Not allowed to set configuration descriptor to \"%{public}s\"", (uint8_t *)&v3);
}

void sub_100767688()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Denying partial write to configuration descriptor (are you kidding me?)", v2, v3, v4, v5, v6);
}

void sub_1007676BC()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "GattServer, ATT db is NULL!", v2, v3, v4, v5, v6);
}

void sub_1007676F0(os_log_t log)
{
  int v1 = 136446210;
  uint64_t v2 = "deviceItr == fDeviceSessions.end()";
  _os_log_fault_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_FAULT, "Assertion failed: %{public}s", (uint8_t *)&v1, 0xCu);
}

void sub_100767774(uint64_t a1, NSObject *a2, uint64_t a3)
{
  int v3 = 138543362;
  uint64_t v4 = a1;
  sub_100057438((void *)&_mh_execute_header, a2, a3, "GattServer disconnected but cannot find session for device \"%{public}@\"", (uint8_t *)&v3);
}

void sub_1007677E4()
{
  sub_1004428CC(__stack_chk_guard);
  sub_1004428C0();
  sub_1000572F4((void *)&_mh_execute_header, v0, v1, "%{public}@ is NOT in the allowed CBCentralSession list for scanning. Please file a radar for CoreBluetooth - Framework Onboarding | All component.", v2, v3, v4, v5, v6);
}

void sub_10076784C()
{
  sub_1004428D8(__stack_chk_guard);
  sub_1004428C0();
  sub_1000572F4((void *)&_mh_execute_header, v0, v1, "%{public}@ does not provide CBUseCase in scanForPeripheralsWithServices.", v2, v3, v4, v5, v6);
}

void sub_1007678B4()
{
  sub_1004428CC(__stack_chk_guard);
  sub_1004428C0();
  sub_1003CF064((void *)&_mh_execute_header, v0, v1, "%{public}@ is in the allowed CBCentralSession list for scanning.", v2, v3, v4, v5, v6);
}

void sub_10076791C(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_100767988()
{
  sub_10005732C();
  sub_1000572F4((void *)&_mh_execute_header, v0, v1, "CL is not ready yet for device %{public}@", v2, v3, v4, v5, v6);
}

void sub_1007679F0(char *a1, uint64_t a2, uint64_t a3, NSObject *a4)
{
  if (a1[23] >= 0) {
    uint64_t v5 = a1;
  }
  else {
    uint64_t v5 = *(char **)a1;
  }
  *(_DWORD *)a3 = 136446466;
  *(void *)(a3 + 4) = v5;
  *(_WORD *)(a3 + 12) = 2114;
  *(void *)(a3 + 14) = a2;
  sub_100057420((void *)&_mh_execute_header, a4, a3, "%{public}s can't send data to %{public}@ since its not connected", (uint8_t *)a3);
  if (a1[23] < 0) {
    operator delete(*(void **)a1);
  }
}

void sub_100767A6C()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "IRK needs to be 16 bytes", v2, v3, v4, v5, v6);
}

void sub_100767AA0(uint64_t a1, char *a2, uint64_t a3, NSObject *a4)
{
  if (a2[23] >= 0) {
    uint64_t v5 = a2;
  }
  else {
    uint64_t v5 = *(char **)a2;
  }
  *(_DWORD *)a3 = 138543618;
  *(void *)(a3 + 4) = a1;
  *(_WORD *)(a3 + 12) = 2082;
  *(void *)(a3 + 14) = v5;
  sub_100057420((void *)&_mh_execute_header, a4, a3, "Device \"%{public}@\" for session \"%{public}s\" is disconnecting, lets wait for it to disconnect and try again", (uint8_t *)a3);
  if (a2[23] < 0) {
    operator delete(*(void **)a2);
  }
}

void sub_100767B1C(char a1, NSObject *a2)
{
  v2[0] = 67109120;
  v2[1] = a1 & 1;
  _os_log_debug_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_DEBUG, "Skipping Built In Service Detection Status %d", (uint8_t *)v2, 8u);
}

void sub_100767B98()
{
  sub_1004428D8(__stack_chk_guard);
  sub_1004428C0();
  sub_1000572F4((void *)&_mh_execute_header, v0, v1, "Device \"%{public}@\" is already connected with no GATT support, cannot enable GATT for this connection", v2, v3, v4, v5, v6);
}

void sub_100767C00()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Ignoring delayed connection for application that does not support backgrounding", v2, v3, v4, v5, v6);
}

void sub_100767C34()
{
  sub_1004428CC(__stack_chk_guard);
  sub_1004428C0();
  sub_1000572F4((void *)&_mh_execute_header, v0, v1, "%{public}@ is NOT in the allowed CBCentralSession list for connection.", v2, v3, v4, v5, v6);
}

void sub_100767C9C()
{
  sub_1004428D8(__stack_chk_guard);
  sub_1004428C0();
  sub_1000572F4((void *)&_mh_execute_header, v0, v1, "%{public}@ does not provide CBUseCase in connectPeripheral.", v2, v3, v4, v5, v6);
}

void sub_100767D04()
{
  sub_1004428CC(__stack_chk_guard);
  sub_1004428C0();
  sub_1003CF064((void *)&_mh_execute_header, v0, v1, "%{public}@ is in the allowed CBCentralSession list for connection.", v2, v3, v4, v5, v6);
}

void sub_100767D6C()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "setupDeviceConnectionPriority could not find a valid use case, we should not be here, file a bug to Bluetooth new bugs | iOS !", v2, v3, v4, v5, v6);
}

void sub_100767DA0()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "External Lock devices got wrong tag HasTS", v2, v3, v4, v5, v6);
}

void sub_100767DD4()
{
  sub_10005732C();
  sub_1000572F4((void *)&_mh_execute_header, v0, v1, "Forcing disconnection of device \"%{public}@\"", v2, v3, v4, v5, v6);
}

void sub_100767E3C()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Invalid device", v2, v3, v4, v5, v6);
}

void sub_100767E70(char a1, uint64_t a2, os_log_t log)
{
  int v3 = *(unsigned __int8 *)(*(void *)a2 + 304);
  v4[0] = 67109376;
  v4[1] = a1 & 1;
  __int16 v5 = 1024;
  int v6 = v3;
  _os_log_debug_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_DEBUG, "moreAvailable=%d, isFromADVBuffer=%d", (uint8_t *)v4, 0xEu);
}

void sub_100767F04()
{
  sub_10005732C();
  sub_1000572F4((void *)&_mh_execute_header, v0, v1, "Session cannot access device %@ because of Manufacturer data", v2, v3, v4, v5, v6);
}

void sub_100767F6C()
{
  sub_10005732C();
  sub_1000572F4((void *)&_mh_execute_header, v0, v1, "Session cannot access device %@ because of service data", v2, v3, v4, v5, v6);
}

void sub_100767FD4()
{
  sub_10005732C();
  sub_1000572F4((void *)&_mh_execute_header, v0, v1, "Session cannot access device %@ because of hashed service UUID", v2, v3, v4, v5, v6);
}

void sub_10076803C()
{
  sub_10005732C();
  sub_1000572F4((void *)&_mh_execute_header, v0, v1, "Session cannot access device %@ because of service UUID", v2, v3, v4, v5, v6);
}

void sub_1007680A4()
{
  sub_10005732C();
  sub_1000572F4((void *)&_mh_execute_header, v0, v1, "Session cannot access device %@", v2, v3, v4, v5, v6);
}

void sub_10076810C()
{
  sub_10005732C();
  sub_1000572F4((void *)&_mh_execute_header, v0, v1, "Could not find a device address for device %{public}@", v2, v3, v4, v5, v6);
}

void sub_100768174()
{
  sub_10005732C();
  sub_1000572F4((void *)&_mh_execute_header, v0, v1, "RestoreFromData - Central - NSKeyedUnarchiver Error:%{public}@", v2, v3, v4, v5, v6);
}

void sub_1007681DC()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Failed to unarchive bundleIdentifier or restoration identifier", v2, v3, v4, v5, v6);
}

void sub_100768210()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Bad restore connect peripherals item (non-data)", v2, v3, v4, v5, v6);
}

void sub_100768244()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Bad restore connect peripherals type (non-set)", v2, v3, v4, v5, v6);
}

void sub_100768278()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Inconsistent scanning state of restored session", v2, v3, v4, v5, v6);
}

void sub_1007682AC()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Bad restore scan service item (non-data)", v2, v3, v4, v5, v6);
}

void sub_1007682E0()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Bad restore scan service type (non-set)", v2, v3, v4, v5, v6);
}

void sub_100768314()
{
  sub_1004428CC(__stack_chk_guard);
  sub_1004428C0();
  sub_1000572F4((void *)&_mh_execute_header, v0, v1, "%@ is not pending continueAfterRestore", v2, v3, v4, v5, v6);
}

void sub_10076837C()
{
  sub_1002B701C();
  sub_100057420((void *)&_mh_execute_header, v0, (uint64_t)v0, "canSessionScanForService %@ %@", v1);
}

void sub_1007683F0()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "FastLEConnection:CBCentralSession::enableFastLeConnectionWithDataToDevice invalid version specified", v2, v3, v4, v5, v6);
}

void sub_100768424(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_100057310((void *)&_mh_execute_header, a2, a3, "FastLEConnection:CBCentralSession::enableFastLeConnectionWithDataToDevice enabling using setControllerInfoForDevice returned %d", a5, a6, a7, a8, 0);
}

void sub_100768490(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_100768504()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "FastLEConnection:CBCentralSession::enableFastLeConnectionWithDataToDevice invalid data specified", v2, v3, v4, v5, v6);
}

void sub_100768538()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "FastLEConnection:CBCentralSession::enableFastLeConnectionWithDataToDevice device already has Fast LE Connection enabled from another source", v2, v3, v4, v5, v6);
}

void sub_10076856C(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_100057310((void *)&_mh_execute_header, a2, a3, "FastLEConnection:CBCentralSession::enableFastLeConnectionWithDataToDevice disabling using setControllerInfoForDevice returned %d", a5, a6, a7, a8, 0);
}

void sub_1007685D8()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "FastLEConnection:CBCentralSession::enableFastLeConnectionWithDataToDevice cannot disable Fast LE Connection to a device this session never enabled", v2, v3, v4, v5, v6);
}

void sub_10076860C()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "FastLEConnection:CBCentralSession::enableFastLeConnectionWithDataToDevice Fast LE Connection with no LTK is unsupported", v2, v3, v4, v5, v6);
}

void sub_100768640()
{
  sub_1004428CC(__stack_chk_guard);
  sub_1004428C0();
  __int16 v3 = 2114;
  uint64_t v4 = v0;
  _os_log_debug_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_DEBUG, "session %{public}@ device %{public}@ evicted", v2, 0x16u);
}

void sub_1007686C4(unsigned __int16 a1, char *a2, uint8_t *buf, os_log_t log)
{
  if (a2[23] >= 0) {
    uint64_t v5 = a2;
  }
  else {
    uint64_t v5 = *(char **)a2;
  }
  *(_DWORD *)uint64_t buf = 67109378;
  *((_DWORD *)buf + 1) = a1;
  *((_WORD *)buf + 4) = 2082;
  *(void *)(buf + 10) = v5;
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "Couldn't find service ID 0x%x for session \"%{public}s\"", buf, 0x12u);
  if (a2[23] < 0) {
    operator delete(*(void **)a2);
  }
}

void sub_10076874C()
{
  sub_1004428CC(__stack_chk_guard);
  sub_1004428C0();
  sub_1000572F4((void *)&_mh_execute_header, v0, v1, "%{public}@ is NOT in the allowed CBPeripheralSession list for advertising. Please file a radar for CoreBluetooth - Framework Onboarding | All component.", v2, v3, v4, v5, v6);
}

void sub_1007687B4(uint64_t a1, NSObject *a2)
{
  sub_10003AE4C(a1, (uint64_t)__p);
  if (v5 >= 0) {
    uint64_t v3 = __p;
  }
  else {
    uint64_t v3 = (void **)__p[0];
  }
  *(_DWORD *)uint64_t buf = 136446210;
  int v7 = v3;
  _os_log_error_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_ERROR, "Failed to start advertising as session \"%{public}s\" is already advertising!", buf, 0xCu);
  if (v5 < 0) {
    operator delete(__p[0]);
  }
}

void sub_10076886C()
{
  sub_1004428D8(__stack_chk_guard);
  sub_1004428C0();
  sub_1000572F4((void *)&_mh_execute_header, v0, v1, "%{public}@ does not provide CBUseCase in startAdvertising.", v2, v3, v4, v5, v6);
}

void sub_1007688D4()
{
  sub_1004428CC(__stack_chk_guard);
  sub_1004428C0();
  sub_1003CF064((void *)&_mh_execute_header, v0, v1, "%{public}@ is in the allowed CBPeripheralSession list for advertising.", v2, v3, v4, v5, v6);
}

void sub_10076893C()
{
  sub_10005732C();
  sub_1000572F4((void *)&_mh_execute_header, v0, v1, "RestoreFromData - Peripheral - NSKeyedUnarchiver Error:%{public}@", v2, v3, v4, v5, v6);
}

void sub_1007689A4(os_log_t log)
{
  *(_WORD *)uint64_t v1 = 0;
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "Must specify both a key and a value", v1, 2u);
}

void sub_1007689E8(int a1, NSObject *a2)
{
  v2[0] = 67109120;
  v2[1] = a1;
  _os_log_error_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_ERROR, "Failed to generate LTK with result %{bluetooth:OI_STATUS}u", (uint8_t *)v2, 8u);
}

void sub_100768A60(int a1, NSObject *a2)
{
  v2[0] = 67109120;
  v2[1] = a1;
  _os_log_error_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_ERROR, "Failed to generate DIV with result %{bluetooth:OI_STATUS}u", (uint8_t *)v2, 8u);
}

void sub_100768AD8(int a1, NSObject *a2)
{
  v2[0] = 67109120;
  v2[1] = a1;
  _os_log_fault_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_FAULT, "Failed to generate DHK with result %{bluetooth:OI_STATUS}u", (uint8_t *)v2, 8u);
}

void sub_100768B50(os_log_t log)
{
  int v1 = 136315138;
  uint64_t v2 = "activate";
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "%s: Network.Framework is not available", (uint8_t *)&v1, 0xCu);
}

void sub_100768BD4(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_100768C0C()
{
  sub_100449684(__stack_chk_guard);
  uint64_t v2 = "Unknown AVDTP_CODEC_VENDOR_SPECIFIC";
  uint64_t v3 = "Unknown AVDTP codec";
  if (v1 == 2) {
    uint64_t v3 = "AVDTP_CODEC_MPEG_AAC";
  }
  if (v1 != 255) {
    uint64_t v2 = v3;
  }
  if (v1 == 33023) {
    uint64_t v4 = "AVDTP_CODEC_APPLE_AACELD";
  }
  else {
    uint64_t v4 = v2;
  }
  if (v1) {
    uint64_t v5 = v4;
  }
  else {
    uint64_t v5 = "AVDTP_CODEC_SBC";
  }
  int v6 = 136315138;
  int v7 = v5;
  _os_log_error_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_ERROR, "Invalid stream configuration - no remote config for codec type %s", (uint8_t *)&v6, 0xCu);
}

void sub_100768CD0()
{
  sub_100449684(__stack_chk_guard);
  uint64_t v2 = "Unknown AVDTP_CODEC_VENDOR_SPECIFIC";
  uint64_t v3 = "Unknown AVDTP codec";
  if (v1 == 2) {
    uint64_t v3 = "AVDTP_CODEC_MPEG_AAC";
  }
  if (v1 != 255) {
    uint64_t v2 = v3;
  }
  if (v1 == 33023) {
    uint64_t v4 = "AVDTP_CODEC_APPLE_AACELD";
  }
  else {
    uint64_t v4 = v2;
  }
  if (v1) {
    uint64_t v5 = v4;
  }
  else {
    uint64_t v5 = "AVDTP_CODEC_SBC";
  }
  int v6 = 136315138;
  int v7 = v5;
  _os_log_error_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_ERROR, "Invalid stream configuration - no local config for codec type %s", (uint8_t *)&v6, 0xCu);
}

void sub_100768D94()
{
  sub_1002B70BC();
  sub_100057594((void *)&_mh_execute_header, v0, (uint64_t)v0, "local sampling rate support 0x%02x, does not match remote 0x%02x", v1);
}

void sub_100768E04()
{
  sub_1002B70BC();
  sub_100057594((void *)&_mh_execute_header, v0, (uint64_t)v0, "local channel mode support 0x%02x, does not match remote 0x%02x", v1);
}

void sub_100768E74()
{
  sub_1000574EC();
  _os_log_fault_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_FAULT, "Accepting remote UNKNOWN A2DP codec %x", v1, 8u);
}

void sub_100768EEC()
{
  sub_1000574EC();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Ignoring sink's SBC Maximum Bitpool Value of %d because it is too low", v2, v3, v4, v5, v6);
}

void sub_100768F58(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_100768F90(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_100768FFC()
{
  sub_100449644();
  sub_100449690((void *)&_mh_execute_header, v0, v1, "Sink requested AAC_LC max bitrate of %lu outside the range of minimum bitrate %d and platform default of %d. Setting bitrate to platform default.", v2, v3, v4);
}

void sub_100769064()
{
  sub_1000574EC();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Invalid stream configuration - no remote config for codec type %d", v2, v3, v4, v5, v6);
}

void sub_1007690D0()
{
  sub_1000574EC();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Invalid stream configuration - no local config for codec type %d", v2, v3, v4, v5, v6);
}

void sub_10076913C()
{
  sub_100449684(__stack_chk_guard);
  sub_100449668();
  sub_100057594((void *)&_mh_execute_header, v0, v1, "Cannot set AAC-LC bitrate lower than %d kbps. Using default bitrate of %d", v2);
}

void sub_1007691A8()
{
  sub_100449644();
  sub_100449690((void *)&_mh_execute_header, v0, v1, "Sink max requested AAC-LC bitrate of %lu is outside the range of minimum bitrate %d and platform default of %d. Setting bitrate to platform default.", v2, v3, v4);
}

void sub_100769210()
{
  sub_100449684(__stack_chk_guard);
  sub_100449668();
  sub_100057594((void *)&_mh_execute_header, v0, v1, "Cannot set AAC-ELD bitrate lower than %d kbps. Using default bitrate of %d", v2);
}

void sub_10076927C(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_1007692E8(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_10076935C()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to register as an A2DP source with result %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_1007693C4()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to register local stream endpoint with result %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_10076942C()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to deregister local stream endpoint with result %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_100769494()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to deregister as an A2DP source with result %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_1007694FC()
{
  uint64_t v0 = __error();
  strerror(*v0);
  sub_1000E37A0((void *)&_mh_execute_header, v1, v2, "iconv_open failed: %s", v3, v4, v5, v6, 2u);
}

void sub_100769580(os_log_t log)
{
  *(_WORD *)uint64_t v1 = 0;
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "unexpected pointer arithmetic result", v1, 2u);
}

void sub_1007695C4(os_log_t log)
{
  *(_WORD *)uint64_t v1 = 0;
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "iconv failed, not enough room in output buffer", v1, 2u);
}

void sub_100769608()
{
  uint64_t v0 = __error();
  strerror(*v0);
  sub_1000E37A0((void *)&_mh_execute_header, v1, v2, "iconv failed with unexpected error: %s", v3, v4, v5, v6, 2u);
}

void sub_10076968C()
{
  uint64_t v0 = __error();
  strerror(*v0);
  sub_1000E37A0((void *)&_mh_execute_header, v1, v2, "iconv_close failed: %s", v3, v4, v5, v6, 2u);
}

void sub_100769710()
{
  sub_1000572DC();
  _os_log_debug_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_DEBUG, "IsENADVBuffer Packet", v1, 2u);
}

void sub_100769750(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_1007697BC()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to set address will change callbacks with result %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_100769824()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to set address change callbacks with result %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_10076988C()
{
  sub_1000572DC();
  _os_log_debug_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_DEBUG, "ContactTracingManager Power : We're going to sleep!", v1, 2u);
}

void sub_1007698CC()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "refreshCurrentAdvertisingPayload payloadBytesLen:%d or payloadBytes is NULL", v2, v3, v4, v5, v6);
}

void sub_100769934()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "refreshCurrentAdvertisingPayload encryptAEM failed %d", v2, v3, v4, v5, v6);
}

void sub_10076999C()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "refreshCurrentAdvertisingPayload getCurrentTEK failed %d", v2, v3, v4, v5, v6);
}

void sub_100769A04()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "CCRandomGenerateBytes failed: %d", v2, v3, v4, v5, v6);
}

void sub_100769A6C()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Failed to get session from sessionHandle", v2, v3, v4, v5, v6);
}

void sub_100769AA0()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to start advertising with result :%d", v2, v3, v4, v5, v6);
}

void sub_100769B08()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to start scanning with result :%d", v2, v3, v4, v5, v6);
}

void sub_100769B70(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_100769BDC(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_100769C4C()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Exposure Notification is not allowed on this device", v2, v3, v4, v5, v6);
}

void sub_100769C80()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Invalid session", v2, v3, v4, v5, v6);
}

void sub_100769CB4(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_100769D24()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to stop advertising with result :%d", v2, v3, v4, v5, v6);
}

void sub_100769D8C()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to stop scanning with result :%d", v2, v3, v4, v5, v6);
}

void sub_100769DF4()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "decryptAEM retrieveTxPowerFromEncryptedEAM failed with error:%d returning attn=0xFF", v2, v3, v4, v5, v6);
}

void sub_100769E5C(uint8_t *buf, unsigned char *a2, os_log_t log)
{
  *uint64_t buf = 0;
  *a2 = 0;
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "Report with invalid RSSI found (127)", buf, 2u);
}

void sub_100769E9C()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "CDContext Framework not available", v2, v3, v4, v5, v6);
}

void sub_100769ED0()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "accessiblityHeadTrackingChanged no valid device", v2, v3, v4, v5, v6);
}

void sub_100769F04(uint8_t *buf, NSObject *a2)
{
  *(_DWORD *)uint64_t buf = 136446210;
  *(void *)(buf + 4) = "(NULL)";
  _os_log_error_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_ERROR, "Couldn't find accessory manager for session %{public}s", buf, 0xCu);
}

void sub_100769F50(char *a1, uint8_t *buf, os_log_t log)
{
  if (a1[23] >= 0) {
    uint64_t v4 = a1;
  }
  else {
    uint64_t v4 = *(char **)a1;
  }
  *(_DWORD *)uint64_t buf = 136446210;
  *(void *)(buf + 4) = v4;
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "Couldn't find accessory manager for session %{public}s", buf, 0xCu);
  if (a1[23] < 0) {
    operator delete(*(void **)a1);
  }
}

void sub_100769FC4(uint64_t a1)
{
  sub_100474E18(a1, __p);
  sub_100057450();
  HIDWORD(v11) = v1;
  sub_100360CB0((void *)&_mh_execute_header, v2, v3, "Device %{public}s is an unknown accessory", v4, v5, v6, v7, v8, (uint64_t)__p[0], (uint64_t)__p[1], v10, 2u);
  if (SHIBYTE(v10) < 0) {
    operator delete(__p[0]);
  }
}

void sub_10076A060(uint64_t a1)
{
  sub_100474E18(a1, __p);
  sub_100057450();
  HIDWORD(v11) = v1;
  sub_100360CB0((void *)&_mh_execute_header, v2, v3, "Device %{public}s is an unknown accessory", v4, v5, v6, v7, v8, (uint64_t)__p[0], (uint64_t)__p[1], v10, 2u);
  if (SHIBYTE(v10) < 0) {
    operator delete(__p[0]);
  }
}

void sub_10076A0FC(uint64_t a1)
{
  sub_100474E18(a1, __p);
  sub_100057450();
  HIDWORD(v11) = v1;
  sub_100360CB0((void *)&_mh_execute_header, v2, v3, "Device %{public}s is an unknown accessory", v4, v5, v6, v7, v8, (uint64_t)__p[0], (uint64_t)__p[1], v10, 2u);
  if (SHIBYTE(v10) < 0) {
    operator delete(__p[0]);
  }
}

void sub_10076A194(int a1, NSObject *a2)
{
  v2[0] = 67109120;
  v2[1] = a1;
  _os_log_debug_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_DEBUG, "sensorStreamingConfigMsgReceived sendToAccessoryEventCallback with result %d", (uint8_t *)v2, 8u);
}

void sub_10076A20C(int a1, NSObject *a2)
{
  v2[0] = 67109120;
  v2[1] = a1;
  _os_log_error_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_ERROR, "remoteStreamUpdate: unknown stream state %d ", (uint8_t *)v2, 8u);
}

void sub_10076A284()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Audio Timesync: Cannot enable remote time sync, invalid device", v2, v3, v4, v5, v6);
}

void sub_10076A2B8()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Audio Timesync: not supported Apple Device, return not supported", v2, v3, v4, v5, v6);
}

void sub_10076A2EC()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Audio Timesync: non-Apple Device, return not supported", v2, v3, v4, v5, v6);
}

void sub_10076A320()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Failed to get paired devices list", v2, v3, v4, v5, v6);
}

void sub_10076A354()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Invalid handle(s)", v2, v3, v4, v5, v6);
}

void sub_10076A388()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Failed to get accessory manager handle", v2, v3, v4, v5, v6);
}

void sub_10076A3BC()
{
  sub_1000573EC();
  if (v4 != v5) {
    uint64_t v6 = v3;
  }
  else {
    uint64_t v6 = v1;
  }
  sub_100463294(v2, v6, 7.2225e-34);
  sub_1004632B4((void *)&_mh_execute_header, v7, v8, "Address %{private, mask.hash}s not valid or device has disconnected", v9);
  if (*(char *)(v0 + 23) < 0) {
    operator delete(*(void **)v0);
  }
}

void sub_10076A410()
{
  sub_1000573EC();
  if (v4 != v5) {
    uint64_t v6 = v3;
  }
  else {
    uint64_t v6 = v1;
  }
  sub_100463294(v2, v6, 7.2225e-34);
  sub_1004632B4((void *)&_mh_execute_header, v7, v8, "Failed to get device %{private, mask.hash}s", v9);
  if (*(char *)(v0 + 23) < 0) {
    operator delete(*(void **)v0);
  }
}

void sub_10076A464(char *a1, uint8_t *buf, int a3, os_log_t log)
{
  if (a1[23] >= 0) {
    char v5 = a1;
  }
  else {
    char v5 = *(char **)a1;
  }
  *(_DWORD *)uint64_t buf = 141558531;
  *(void *)(buf + 4) = 1752392040;
  *((_WORD *)buf + 6) = 2081;
  *(void *)(buf + 14) = v5;
  *((_WORD *)buf + 11) = 1024;
  *((_DWORD *)buf + 6) = a3;
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "Failed to register device %{private, mask.hash}s - result was %d", buf, 0x1Cu);
  if (a1[23] < 0) {
    operator delete(*(void **)a1);
  }
}

void sub_10076A4FC()
{
  sub_1000573EC();
  if (v4 != v5) {
    uint64_t v6 = v3;
  }
  else {
    uint64_t v6 = v1;
  }
  sub_100463294(v2, v6, 7.2225e-34);
  sub_1004632B4((void *)&_mh_execute_header, v7, v8, "Failed to get device handle for device %{private, mask.hash}s", v9);
  if (*(char *)(v0 + 23) < 0) {
    operator delete(*(void **)v0);
  }
}

void sub_10076A550()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Failed to get device handle", v2, v3, v4, v5, v6);
}

void sub_10076A584()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Invalid argument", v2, v3, v4, v5, v6);
}

void sub_10076A5B8()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Invalid arguments", v2, v3, v4, v5, v6);
}

void sub_10076A5EC()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Device not yet first unlocked yet, cannot retrieve capabilities", v2, v3, v4, v5, v6);
}

void sub_10076A620()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "TimeSyncEnable: Invalid handle", v2, v3, v4, v5, v6);
}

void sub_10076A654()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "TimeSyncEnable: Stack not ready", v2, v3, v4, v5, v6);
}

void sub_10076A688()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "TimeSyncEnable: Invalid accessory manager handle", v2, v3, v4, v5, v6);
}

void sub_10076A6BC()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "TimeSyncEnable: Invalid role", v2, v3, v4, v5, v6);
}

void sub_10076A6F0()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "TimeSyncEnable: AACP not supported", v2, v3, v4, v5, v6);
}

void sub_10076A724()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "TimeSyncEnable: Invalid argument", v2, v3, v4, v5, v6);
}

void sub_10076A758()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "TimeSyncEnable: Time Sync not supported", v2, v3, v4, v5, v6);
}

void sub_10076A78C(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_10076A7F8(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_10076A864(uint64_t a1)
{
  sub_10005747C(a1, __stack_chk_guard, v7);
  sub_100057450();
  sub_100057470();
  sub_100360CB0((void *)&_mh_execute_header, v1, v2, "BTAccessoryManagerGetSpatialAudioPlatformSupport:  \"%{public}s\" Does not support spatial", v3, v4, v5, v6, v8, (uint64_t)__p, v11, v12, v14);
  if (v13 < 0) {
    operator delete(__pa);
  }
}

void sub_10076A8EC(uint64_t a1)
{
  sub_10005747C(a1, __stack_chk_guard, v7);
  sub_100057450();
  sub_100057470();
  sub_100360CB0((void *)&_mh_execute_header, v1, v2, "BTAccessoryManagerGetStereoHFPSupport:  \"%{public}s\" supports non-headtracked spatial", v3, v4, v5, v6, v8, (uint64_t)__p, v11, v12, v14);
  if (v13 < 0) {
    operator delete(__pa);
  }
}

void sub_10076A974(uint64_t a1)
{
  sub_10005747C(a1, __stack_chk_guard, v7);
  sub_100057450();
  sub_100057470();
  sub_100360CB0((void *)&_mh_execute_header, v1, v2, "BTAccessoryManagerGetStereoHFPSupport:  \"%{public}s\" Does not support spatial", v3, v4, v5, v6, v8, (uint64_t)__p, v11, v12, v14);
  if (v13 < 0) {
    operator delete(__pa);
  }
}

void sub_10076A9FC()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Prox Card Status: Prox Card Status not read yet", v2, v3, v4, v5, v6);
}

void sub_10076AA30(uint64_t a1)
{
  sub_10005747C(a1, __stack_chk_guard, v7);
  sub_100057450();
  sub_100057470();
  sub_100360CB0((void *)&_mh_execute_header, v1, v2, "BTAccessoryManagerGetDeviceSoundProfileSupport:  \"%{public}s\" Does not support Spatial Profile", v3, v4, v5, v6, v8, (uint64_t)__p, v11, v12, v14);
  if (v13 < 0) {
    operator delete(__pa);
  }
}

void sub_10076AAB8(uint64_t a1)
{
  sub_10005747C(a1, __stack_chk_guard, v7);
  sub_100057450();
  sub_100057470();
  sub_100360CB0((void *)&_mh_execute_header, v1, v2, "BTAccessoryManagerGetDeviceSoundProfileAllowed:  \"%{public}s\" Does not support spatial", v3, v4, v5, v6, v8, (uint64_t)__p, v11, v12, v14);
  if (v13 < 0) {
    operator delete(__pa);
  }
}

void sub_10076AB40(uint64_t a1)
{
  sub_10005747C(a1, __stack_chk_guard, v7);
  sub_100057450();
  sub_100057470();
  sub_100360CB0((void *)&_mh_execute_header, v1, v2, "BTAccessoryManagerSetDeviceSoundProfileAllowed:  \"%{public}s\" Does not support spatial", v3, v4, v5, v6, v8, (uint64_t)__p, v11, v12, v14);
  if (v13 < 0) {
    operator delete(__pa);
  }
}

void sub_10076ABC8()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "BTAccessoryManagerGetAdaptiveLatencyJitterBufferLevel, Device handle not found", v2, v3, v4, v5, v6);
}

void sub_10076ABFC()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Device not support adaptive latency", v2, v3, v4, v5, v6);
}

void sub_10076AC30()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "BTAccessoryManagerGetSensorStreamingFrequency - Invalid device handle", v2, v3, v4, v5, v6);
}

void sub_10076AC64()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "BTAccessoryManagerGetSensorStreamingFrequency - No device for handle", v2, v3, v4, v5, v6);
}

void sub_10076AC98()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "BTAccessoryManagerGetGyroInformation - Invalid device handle", v2, v3, v4, v5, v6);
}

void sub_10076ACCC()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "BTAccessoryManagerGetGyroInformation - No device for handle", v2, v3, v4, v5, v6);
}

void sub_10076AD00()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "BTAccessoryManagerGetWirelessSharingSpatial - Invalid device handle", v2, v3, v4, v5, v6);
}

void sub_10076AD34()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "BTAccessoryManagerGetWirelessSharingSpatial - No device for handle", v2, v3, v4, v5, v6);
}

void sub_10076AD68(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_10076ADD4(unsigned __int16 a1, NSObject *a2)
{
  v2[0] = 67109120;
  v2[1] = a1;
  _os_log_debug_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_DEBUG, "BTAccessoryManagerGetCaseSerialNumbersForAppleProductId entered BT API productId %d", (uint8_t *)v2, 8u);
}

void sub_10076AE50(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_10076AEBC(unsigned __int8 a1, NSObject *a2)
{
  v2[0] = 67109120;
  v2[1] = a1;
  _os_log_debug_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_DEBUG, "BTAccessoryManagerGetCaseSerialNumbersForAppleProductIds entered BT API numProductIds %u", (uint8_t *)v2, 8u);
}

void sub_10076AF38()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "BTAccessoryManagerGetPrimaryBudSide - Invalid device handle", v2, v3, v4, v5, v6);
}

void sub_10076AF6C()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "BTAccessoryManagerGetPrimaryBudSide - No device for handle", v2, v3, v4, v5, v6);
}

void sub_10076AFA0()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "BTAccessoryManagerGetHeadphoneFeatureValue - Invalid device handle", v2, v3, v4, v5, v6);
}

void sub_10076AFD4()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "BTAccessoryManagerGetHeadphoneFeatureValue - No device for handle", v2, v3, v4, v5, v6);
}

void sub_10076B008(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_10076B074()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "BTAccessoryManagerSetHeadphoneFeatureValue - Invalid device handle", v2, v3, v4, v5, v6);
}

void sub_10076B0A8()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "BTAccessoryManagerSetHeadphoneFeatureValue - No device for handle", v2, v3, v4, v5, v6);
}

void sub_10076B0DC(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_10076B148()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to register SDP service record - result was %d", v2, v3, v4, v5, v6);
}

void sub_10076B1B0()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to register RFCOMM server - result was %d", v2, v3, v4, v5, v6);
}

void sub_10076B218(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_10076B28C()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Cannot connect to NULL device", v2, v3, v4, v5, v6);
}

void sub_10076B2C0()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "No rfcomm channel found for this profile", v2, v3, v4, v5, v6);
}

void sub_10076B2F4()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Braille connection failed - result was %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_10076B35C(uint64_t a1)
{
  sub_100474E18(a1, __p);
  sub_100057450();
  HIDWORD(v11) = v1;
  sub_100360CB0((void *)&_mh_execute_header, v2, v3, "Braille service not supported by device %{public}s", v4, v5, v6, v7, v8, (uint64_t)__p[0], (uint64_t)__p[1], v10, 2u);
  if (SHIBYTE(v10) < 0) {
    operator delete(__p[0]);
  }
}

void sub_10076B3F8()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Error retrieving BD_ADDR from handle - result was %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_10076B460()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to disconnect - result was %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_10076B4C8(char a1, int a2, os_log_t log)
{
  uint64_t v3 = "accept";
  if ((a1 & 1) == 0) {
    uint64_t v3 = "deny";
  }
  int v4 = 136315394;
  uint64_t v5 = v3;
  __int16 v6 = 1024;
  int v7 = a2;
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "Failed to %s connection attempt - result was %d", (uint8_t *)&v4, 0x12u);
}

void sub_10076B568(uint64_t a1)
{
  sub_100474E18(a1, __p);
  sub_100057450();
  HIDWORD(v11) = v1;
  sub_100360CB0((void *)&_mh_execute_header, v2, v3, "Failed to open serial port for braille connection to device %{public}s", v4, v5, v6, v7, v8, (uint64_t)__p[0], (uint64_t)__p[1], v10, 2u);
  if (SHIBYTE(v10) < 0) {
    operator delete(__p[0]);
  }
}

void sub_10076B600()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Cannot write to NULL device", v2, v3, v4, v5, v6);
}

void sub_10076B634()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Cannot read from NULL device", v2, v3, v4, v5, v6);
}

void sub_10076B668()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to send data to BT device - result was %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_10076B6D0()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Invalid write - result was %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_10076B738(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_10076B7A4(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_10076B7DC(char *a1, uint8_t *buf, int a3, os_log_t log)
{
  if (a1[23] >= 0) {
    uint64_t v5 = a1;
  }
  else {
    uint64_t v5 = *(char **)a1;
  }
  *(_DWORD *)uint64_t buf = 136446466;
  *(void *)(buf + 4) = v5;
  *((_WORD *)buf + 6) = 1024;
  *(_DWORD *)(buf + 14) = a3;
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "GATT Failed to disconnect GATT profile from device %{public}s with result %{bluetooth:OI_STATUS}u", buf, 0x12u);
  if (a1[23] < 0) {
    operator delete(*(void **)a1);
  }
}

void sub_10076B860(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_10076B898(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_10076B904()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "BTDeviceConnectServicesWithParameters Error, BTDeviceConnectServicesWithParameters parameters are invalid", v2, v3, v4, v5, v6);
}

void sub_10076B938()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Error, BTDeviceConnectServicesWithParameters setting key failed", v2, v3, v4, v5, v6);
}

void sub_10076B96C()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "BTDeviceConnectServicesWithParameters, BTDeviceConnectNormalMode", v2, v3, v4, v5, v6);
}

void sub_10076B9A0()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Guest Pairing: Cannot pair with mode, feature not enabled", v2, v3, v4, v5, v6);
}

void sub_10076B9D4(char a1, NSObject *a2)
{
  uint64_t v2 = "not found.";
  if (a1) {
    uint64_t v2 = "found.";
  }
  int v3 = 136315138;
  uint64_t v4 = v2;
  _os_log_error_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_ERROR, "Error, BTDeviceConfigureLinkKey device not found or linkkey %s ", (uint8_t *)&v3, 0xCu);
}

void sub_10076BA64()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Error, BTDeviceIsTemporaryPaired device not found", v2, v3, v4, v5, v6);
}

void sub_10076BA98()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Error, BTDeviceIsTemporaryPairedNotInContacts device not found", v2, v3, v4, v5, v6);
}

void sub_10076BACC()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Error, BTDeviceSetHijackAudioRoute device not found", v2, v3, v4, v5, v6);
}

void sub_10076BB00()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Error, BTDeviceSetACLHighPriority device not found", v2, v3, v4, v5, v6);
}

void sub_10076BB34(uint8_t *buf, NSObject *a2)
{
  *(_DWORD *)uint64_t buf = 136446210;
  *(void *)(buf + 4) = "(NULL)";
  _os_log_error_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_ERROR, "Failed to get default local device for session %{public}s", buf, 0xCu);
}

void sub_10076BB80(uint64_t a1, uint64_t a2, NSObject *a3)
{
  sub_10003AE4C(a1, (uint64_t)__p);
  if (v7 >= 0) {
    uint64_t v5 = __p;
  }
  else {
    uint64_t v5 = (void **)__p[0];
  }
  *(_DWORD *)a2 = 136446210;
  *(void *)(a2 + 4) = v5;
  _os_log_error_impl((void *)&_mh_execute_header, a3, OS_LOG_TYPE_ERROR, "Failed to get default local device for session %{public}s", (uint8_t *)a2, 0xCu);
  if (v7 < 0) {
    operator delete(__p[0]);
  }
}

void sub_10076BC14()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Invalid DeviceManager handle", v2, v3, v4, v5, v6);
}

void sub_10076BC48()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "BTLocalDeviceRegisterForPowerUpdates - BT_ERROR_INVALID_HANDLE", v2, v3, v4, v5, v6);
}

void sub_10076BC7C()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "BTLocalDeviceUnregisterForPowerUpdates - BT_ERROR_INVALID_HANDLE", v2, v3, v4, v5, v6);
}

void sub_10076BCB0()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "BTLocalDeviceReadPowerConsumption - BT_ERROR_INVALID_HANDLE", v2, v3, v4, v5, v6);
}

void sub_10076BCE4()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "BTLocalDeviceRegisterForPowerProfileStatistics - BT_ERROR_INVALID_HANDLE", v2, v3, v4, v5, v6);
}

void sub_10076BD18()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "BTLocalDeviceUnregisterForPowerProfileStatistics - BT_ERROR_INVALID_HANDLE", v2, v3, v4, v5, v6);
}

void sub_10076BD4C()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "BTLocalDeviceReadPowerProfileStatistics - BT_ERROR_INVALID_HANDLE", v2, v3, v4, v5, v6);
}

void sub_10076BD80()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "BTLocalDeviceReadEnhancedPowerProfileStatistics - BT_ERROR_INVALID_HANDLE", v2, v3, v4, v5, v6);
}

void sub_10076BDB4()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "BTLocalDeviceReadTransportSwitchStatistics - BT_ERROR_INVALID_HANDLE", v2, v3, v4, v5, v6);
}

void sub_10076BDE8()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "BTLocalDeviceReadDetailedPowerProfileStatistics - BT_ERROR_INVALID_HANDLE", v2, v3, v4, v5, v6);
}

void sub_10076BE1C()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "BTStartHCITraces - BT_ERROR_INVALID_HANDLE", v2, v3, v4, v5, v6);
}

void sub_10076BE50()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "BTStopHCITraces - BT_ERROR_INVALID_HANDLE", v2, v3, v4, v5, v6);
}

void sub_10076BE84()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "BTLocalDeviceShowPowerPrompt - BT_ERROR_INVALID_HANDLE", v2, v3, v4, v5, v6);
}

void sub_10076BEB8()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "BTLocalDeviceSetAFHMap - BT_ERROR_INVALID_HANDLE", v2, v3, v4, v5, v6);
}

void sub_10076BEEC()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "BTLocalDeviceReadAFHMap - BT_ERROR_INVALID_HANDLE", v2, v3, v4, v5, v6);
}

void sub_10076BF20()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "BTLQ Cannot get BT Link Quality Data, invalid data", v2, v3, v4, v5, v6);
}

void sub_10076BF54()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "BTLQ Cannot get BT Link Quality Data, invalid audioLinkManager", v2, v3, v4, v5, v6);
}

void sub_10076BF88(uint64_t a1)
{
  sub_100052DA4(a1 + 56);
  uint64_t v2 = *(void **)(a1 + 32);
  if (v2)
  {
    *(void *)(a1 + 40) = v2;
    operator delete(v2);
  }
}

void sub_10076BFD8(int a1, NSObject *a2)
{
  v2[0] = 67109120;
  v2[1] = a1;
  _os_log_fault_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_FAULT, "Received connection result without a matching attempt for service 0x%08x", (uint8_t *)v2, 8u);
}

void sub_10076C050(char *a1, uint8_t *buf, os_log_t log)
{
  if (a1[23] >= 0) {
    uint64_t v4 = a1;
  }
  else {
    uint64_t v4 = *(char **)a1;
  }
  *(_DWORD *)uint64_t buf = 136446210;
  *(void *)(buf + 4) = v4;
  _os_log_fault_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_FAULT, "We got a disconnection result without a previous connection for service %{public}s", buf, 0xCu);
  if (a1[23] < 0) {
    operator delete(*(void **)a1);
  }
}

void sub_10076C0C4()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Map settings exist on first pairing!", v2, v3, v4, v5, v6);
}

void sub_10076C0F8()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Identification - build updated wiping secondary hash", v2, v3, v4, v5, v6);
}

void sub_10076C12C()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Identification - build updated wiping primary hash", v2, v3, v4, v5, v6);
}

void sub_10076C160()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "System has not passed first unlock. Do not read/write device prefs", v2, v3, v4, v5, v6);
}

void sub_10076C194()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Identification - Failed to read primary hash data from disk", v2, v3, v4, v5, v6);
}

void sub_10076C1C8()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Identification - System has not passed first unlock, returning", v2, v3, v4, v5, v6);
}

void sub_10076C1FC()
{
  sub_10048FFC0();
  sub_10048FFD8((void *)&_mh_execute_header, v0, v1, "Apple supported feature version size is %d. Expected %lu", v2, v3, v4, v5, v6);
}

void sub_10076C26C()
{
  sub_10048FFC0();
  sub_10048FFD8((void *)&_mh_execute_header, v0, v1, "Apple extended feature ID1 size is %d. Expected %lu", v2, v3, v4, v5, v6);
}

void sub_10076C2DC()
{
  sub_10048FFC0();
  sub_10048FFD8((void *)&_mh_execute_header, v0, v1, "Apple supported feature ID0 size is %d. Expected %lu", v2, v3, v4, v5, v6);
}

void sub_10076C34C(uint64_t a1, NSObject *a2)
{
  sub_100474E18(a1, __p);
  if (v6 >= 0) {
    uint64_t v4 = __p;
  }
  else {
    uint64_t v4 = (void **)__p[0];
  }
  int v7 = 136446210;
  uint64_t v8 = v4;
  sub_100057438((void *)&_mh_execute_header, a2, v3, "Invalid operation. Trying to set HIDBehavior for %{public}s", (uint8_t *)&v7);
  if (v6 < 0) {
    operator delete(__p[0]);
  }
}

void sub_10076C3F8()
{
  sub_1000573EC();
  if (v6 != v7) {
    uint64_t v8 = v5;
  }
  else {
    uint64_t v8 = v1;
  }
  *(_DWORD *)uint64_t v2 = 136446210;
  *(void *)(v2 + 4) = v8;
  sub_100057438((void *)&_mh_execute_header, v3, (uint64_t)v3, "Failed to invoke Single Shot Role Switch WAR for %{public}s", v4);
  if (*(char *)(v0 + 23) < 0) {
    operator delete(*(void **)v0);
  }
}

void sub_10076C454()
{
  sub_1000573EC();
  if (v6 != v7) {
    uint64_t v8 = v5;
  }
  else {
    uint64_t v8 = v1;
  }
  *(_DWORD *)uint64_t v2 = 136446210;
  *(void *)(v2 + 4) = v8;
  sub_100057438((void *)&_mh_execute_header, v3, (uint64_t)v3, "could not write SDP record for device %{public}s", v4);
  if (*(char *)(v0 + 23) < 0) {
    operator delete(*(void **)v0);
  }
}

void sub_10076C4B0()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "System has not passed first unlock (or device prefs not read yet). Do not read/write device prefs", v2, v3, v4, v5, v6);
}

void sub_10076C4E4()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Invalid batteryID: %d", v2, v3, v4, v5, v6);
}

void sub_10076C54C()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "BattStatus: Invalid status pointer", v2, v3, v4, v5, v6);
}

void sub_10076C580()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Invalid battery level %d provided", v2, v3, v4, v5, v6);
}

void sub_10076C5E8()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Identification - class of device is 0, not generating", v2, v3, v4, v5, v6);
}

void sub_10076C61C()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Failed to write secondary hash to disk", v2, v3, v4, v5, v6);
}

void sub_10076C650()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Failed to write primary hash data to disk", v2, v3, v4, v5, v6);
}

void sub_10076C684()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Failed to write primary hash to disk", v2, v3, v4, v5, v6);
}

void sub_10076C6B8()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "OI_DEVMGR_GetRemoteSupportedFeatures fails with %d", v2, v3, v4, v5, v6);
}

void sub_10076C720()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "HIDIdentification - No name available to make a match", v2, v3, v4, v5, v6);
}

void sub_10076C754(uint64_t a1, NSObject *a2, uint64_t a3)
{
  int v3 = 138412290;
  uint64_t v4 = a1;
  sub_100057438((void *)&_mh_execute_header, a2, a3, "Error APPLE_AUDIO_DEVICE_NAME bad format string: %@", (uint8_t *)&v3);
}

void sub_10076C7C4(NSObject *a1, uint64_t a2, uint64_t a3)
{
  int v3 = 136446210;
  uint64_t v4 = "static void BT::Device::updateWithCurrentUserGivenName(Device *)_block_invoke";
  sub_100057438((void *)&_mh_execute_header, a1, a3, "Error occured %{public}s while trying to localize the device name with user name", (uint8_t *)&v3);
}

void sub_10076C840(NSObject *a1, uint64_t a2, uint64_t a3)
{
  int v3 = 136446210;
  uint64_t v4 = "static void BT::Device::updateWithCurrentUserGivenName(Device *)_block_invoke";
  sub_100057438((void *)&_mh_execute_header, a1, a3, "Error occurred %{public}s users name was returned empty or null", (uint8_t *)&v3);
}

void sub_10076C8BC()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Failed to read primary hash data from disk", v2, v3, v4, v5, v6);
}

void sub_10076C8F0()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "blockIncomingConnections Failed", v2, v3, v4, v5, v6);
}

void sub_10076C924()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "No incoming call to answer", v2, v3, v4, v5, v6);
}

void sub_10076C958()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "No incoming call to reject", v2, v3, v4, v5, v6);
}

void sub_10076C98C()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "No active call to disconnect", v2, v3, v4, v5, v6);
}

void sub_10076C9C0()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "No held call to disconnect", v2, v3, v4, v5, v6);
}

void sub_10076C9F4()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "No call to hold or resume", v2, v3, v4, v5, v6);
}

void sub_10076CA28()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "The TU call doesn't support holding", v2, v3, v4, v5, v6);
}

void sub_10076CA5C()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "The TU calls don't support grouping", v2, v3, v4, v5, v6);
}

void sub_10076CA90()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "No held and active calls to create a conference", v2, v3, v4, v5, v6);
}

void sub_10076CAC4()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "No call to disconnect", v2, v3, v4, v5, v6);
}

void sub_10076CAF8()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "No call to leave the conference", v2, v3, v4, v5, v6);
}

void sub_10076CB2C()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "The TU call doesn't support ungrouping", v2, v3, v4, v5, v6);
}

void sub_10076CB60()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "The TU call isn't conferenced", v2, v3, v4, v5, v6);
}

void sub_10076CB94()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Failed to play DMTF tone", v2, v3, v4, v5, v6);
}

void sub_10076CBC8(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_10076CC4C()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Adding virtual call to unempty call list - this will likely cause call state issues", v2, v3, v4, v5, v6);
}

void sub_10076CC80()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "A virtual call already exists", v2, v3, v4, v5, v6);
}

void sub_10076CCB4()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "A virtual call doesn't exist", v2, v3, v4, v5, v6);
}

void sub_10076CCE8(uint64_t a1, char a2, os_log_t log)
{
  int v3 = 138412546;
  uint64_t v4 = a1;
  __int16 v5 = 1024;
  int v6 = a2 & 1;
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "Did not find TU call to set Call Screening %@ to value:%d", (uint8_t *)&v3, 0x12u);
}

void sub_10076CD74()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Could not get the operator status", v2, v3, v4, v5, v6);
}

void sub_10076CDA8()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Could not get registration status", v2, v3, v4, v5, v6);
}

void sub_10076CDDC()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Could not get signal strength", v2, v3, v4, v5, v6);
}

void sub_10076CE10()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Could not get the subscriber number", v2, v3, v4, v5, v6);
}

void sub_10076CE44()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Could not get the IMSI", v2, v3, v4, v5, v6);
}

void sub_10076CE78()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Could not get the IMEI", v2, v3, v4, v5, v6);
}

void sub_10076CEAC(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_10076CF18()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Could not get the Tx state", v2, v3, v4, v5, v6);
}

void sub_10076CF4C(uint8_t *buf, unsigned char *a2, os_log_t log)
{
  *uint64_t buf = 0;
  *a2 = 0;
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "Invalid Device Address, skip device read", buf, 2u);
}

void sub_10076CF8C()
{
  sub_1000573EC();
  if (v4 != v5) {
    uint64_t v6 = v3;
  }
  else {
    uint64_t v6 = v1;
  }
  sub_100057464(v2, v6, 4.8751e-34);
  sub_100057438((void *)&_mh_execute_header, v7, (uint64_t)v7, "Removing Device Support Information for %{public}s", v8);
  if (*(char *)(v0 + 23) < 0) {
    operator delete(*(void **)v0);
  }
}

void sub_10076CFE4()
{
  sub_1000573EC();
  if (v4 != v5) {
    uint64_t v6 = v3;
  }
  else {
    uint64_t v6 = v1;
  }
  sub_100057464(v2, v6, 4.8751e-34);
  sub_100057438((void *)&_mh_execute_header, v7, (uint64_t)v7, "Removing Cloud Magic Settings for %{public}s", v8);
  if (*(char *)(v0 + 23) < 0) {
    operator delete(*(void **)v0);
  }
}

void sub_10076D03C()
{
  sub_1000573EC();
  if (v4 != v5) {
    uint64_t v6 = v3;
  }
  else {
    uint64_t v6 = v1;
  }
  sub_100057464(v2, v6, 4.8751e-34);
  sub_100057438((void *)&_mh_execute_header, v7, (uint64_t)v7, "Removing Device Record for %{public}s", v8);
  if (*(char *)(v0 + 23) < 0) {
    operator delete(*(void **)v0);
  }
}

void sub_10076D094()
{
  sub_1000573EC();
  if (v4 != v5) {
    uint64_t v6 = v3;
  }
  else {
    uint64_t v6 = v1;
  }
  sub_100057464(v2, v6, 4.8751e-34);
  sub_100057438((void *)&_mh_execute_header, v7, (uint64_t)v7, "Removing Magic pairing device %{public}s from device list failed", v8);
  if (*(char *)(v0 + 23) < 0) {
    operator delete(*(void **)v0);
  }
}

void sub_10076D0EC()
{
  sub_1000573EC();
  if (v4 != v5) {
    uint64_t v6 = v3;
  }
  else {
    uint64_t v6 = v1;
  }
  sub_100057464(v2, v6, 4.8149e-34);
  sub_100057438((void *)&_mh_execute_header, v7, (uint64_t)v7, "Cloud asked to unpair, dont easy unpair right now: %s", v8);
  if (*(char *)(v0 + 23) < 0) {
    operator delete(*(void **)v0);
  }
}

void sub_10076D144()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to write magic pairing device information to storage with error %d", v2, v3, v4, v5, v6);
}

void sub_10076D1AC()
{
  sub_10030D088();
  sub_1004A824C(v1, v2, v3, 4.8752e-34);
  sub_1004A8270((void *)&_mh_execute_header, "[MP-] Error removing cloud record for %{public}s with error: %@", v4, v5);
  if (*(char *)(v0 + 23) < 0) {
    operator delete(*(void **)v0);
  }
}

void sub_10076D1FC()
{
  sub_10030D088();
  sub_1004A824C(v1, v2, v3, 4.8752e-34);
  sub_1004A8270((void *)&_mh_execute_header, "[MP-] Error removing new cloud magic settings record for %{public}s with error: %@", v4, v5);
  if (*(char *)(v0 + 23) < 0) {
    operator delete(*(void **)v0);
  }
}

void sub_10076D24C()
{
  sub_10030D088();
  sub_1004A824C(v1, v2, v3, 4.8752e-34);
  sub_1004A8270((void *)&_mh_execute_header, "[MP-] Error removing Device Support Information for %{public}s with error: %@", v4, v5);
  if (*(char *)(v0 + 23) < 0) {
    operator delete(*(void **)v0);
  }
}

void sub_10076D29C()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Cannot reset magic pairing not initialized", v2, v3, v4, v5, v6);
}

void sub_10076D2D0()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "No magic pairing device to reset", v2, v3, v4, v5, v6);
}

void sub_10076D304()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Cloud main account keys are not available", v2, v3, v4, v5, v6);
}

void sub_10076D338()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Failed to reset AccKeys", v2, v3, v4, v5, v6);
}

void sub_10076D36C()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to encrypt fAccHint: %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_10076D3D4()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to encrypt fAccKey: %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_10076D43C()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Invalid Device Address", v2, v3, v4, v5, v6);
}

void sub_10076D470()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Cloud master accessory key is not available", v2, v3, v4, v5, v6);
}

void sub_10076D4A4()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Failed to init AccKeys", v2, v3, v4, v5, v6);
}

void sub_10076D4D8()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Cloud master accessory key is not available, dont generate cloudIRK", v2, v3, v4, v5, v6);
}

void sub_10076D50C()
{
  sub_1000572E8();
}

void sub_10076D574()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to encrypt fMasterAccKey: %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_10076D5DC()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to encrypt fMasterAccHint: %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_10076D644()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Cloud master IRK is not available so generate it", v2, v3, v4, v5, v6);
}

void sub_10076D678()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Update IRK: Invalid Device Address", v2, v3, v4, v5, v6);
}

void sub_10076D6AC()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Update Enc Key: Invalid Device Address", v2, v3, v4, v5, v6);
}

void sub_10076D6E0()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Update Ratchet: Invalid Device Address", v2, v3, v4, v5, v6);
}

void sub_10076D714()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Error generating RatchetAccKey: %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_10076D77C()
{
  sub_1002DDCC4();
  sub_1000574F8((void *)&_mh_execute_header, v0, v1, "Keys did not change Cloud keys AccKeyPtr %p, HintPtr %p", v2, v3);
}

void sub_10076D7E4()
{
  sub_1004A828C();
  sub_1004A82BC((void *)&_mh_execute_header, v0, v1, "Keys did not change Cloud keys AccKeyPtr %.16P, HintPtr %.16P");
}

void sub_10076D84C()
{
  sub_1002DDCC4();
  sub_1000574F8((void *)&_mh_execute_header, v0, v1, "Invalid/Equal keys AccKeyPtr %p, HintPtr %p", v2, v3);
}

void sub_10076D8B4()
{
  sub_1004A828C();
  sub_1004A82BC((void *)&_mh_execute_header, v0, v1, "Invalid/Equal Cloud keys AccKeyPtr %.16P, HintPtr %.16P");
}

void sub_10076D91C()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Magic Pairing master keys are available. Let's fetch Magic Paired Devices!", v2, v3, v4, v5, v6);
}

void sub_10076D950()
{
  sub_1000572E8();
}

void sub_10076D9B8(uint8_t *buf, unsigned char *a2, os_log_t log)
{
  *uint64_t buf = 0;
  *a2 = 0;
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "Invalid Device Address, Skip Record", buf, 2u);
}

void sub_10076D9F8()
{
  sub_10030D088();
  sub_1004A824C(v1, v2, v3, 4.8752e-34);
  sub_1004A8270((void *)&_mh_execute_header, "[MP] Error removing cloud device, %{public}s with error: %@", v4, v5);
  if (*(char *)(v0 + 23) < 0) {
    operator delete(*(void **)v0);
  }
}

void sub_10076DA48()
{
  sub_10030D088();
  sub_1004A824C(v1, v2, v3, 4.8752e-34);
  sub_1004A8270((void *)&_mh_execute_header, "[MP] Error removing new cloud magic settings, %{public}s with error: %@", v4, v5);
  if (*(char *)(v0 + 23) < 0) {
    operator delete(*(void **)v0);
  }
}

void sub_10076DA98()
{
  sub_10030D088();
  sub_1004A824C(v1, v2, v3, 4.8752e-34);
  sub_1004A8270((void *)&_mh_execute_header, "[MP] Error removing cloud info settings, %{public}s with error: %@", v4, v5);
  if (*(char *)(v0 + 23) < 0) {
    operator delete(*(void **)v0);
  }
}

void sub_10076DAE8(uint64_t a1, NSObject *a2)
{
  int v2 = *(unsigned __int8 *)(a1 + 241);
  v3[0] = 67109120;
  v3[1] = v2;
  _os_log_debug_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_DEBUG, "updateAACPVersionInfo: Invalid device or not signed in %d ", (uint8_t *)v3, 8u);
}

void sub_10076DB64()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "updateAACPVersionInfo: BTAddressFromString failed", v2, v3, v4, v5, v6);
}

void sub_10076DB98()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "updateAACPVersionInfo: getDevice failed", v2, v3, v4, v5, v6);
}

void sub_10076DBCC()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "updateAACPVersionInfo: Could not create cloudDevice", v2, v3, v4, v5, v6);
}

void sub_10076DC00()
{
  sub_1000573EC();
  if (v4 != v5) {
    uint64_t v6 = v3;
  }
  else {
    uint64_t v6 = v1;
  }
  sub_100057464(v2, v6, 4.8751e-34);
  sub_100057438((void *)&_mh_execute_header, v7, (uint64_t)v7, "updateAACPVersionInfo: No valid versionInfo for %{public}s", v8);
  if (*(char *)(v0 + 23) < 0) {
    operator delete(*(void **)v0);
  }
}

void sub_10076DC58()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "updateAACPVersionInfo: Unable to update pid/vid for cloudDevice", v2, v3, v4, v5, v6);
}

void sub_10076DC8C()
{
  sub_10005732C();
  sub_100057438((void *)&_mh_execute_header, v0, v1, "updateAACPVersionInfo: Error retrieving cloudDevice: %@", v2);
}

void sub_10076DCF8()
{
  sub_10005732C();
  sub_100057438((void *)&_mh_execute_header, v0, v1, "updateAACPVersionInfo: cloudDevice createError: %@", v2);
}

void sub_10076DD64()
{
  sub_10005732C();
  sub_100057438((void *)&_mh_execute_header, v0, v1, "updateAACPVersionInfo: Error retrieving deviceSupportInformation: %@", v2);
}

void sub_10076DDD0()
{
  sub_10005732C();
  sub_100057438((void *)&_mh_execute_header, v0, v1, "updateAACPVersionInfo: deviceSupportInformation createError %@", v2);
}

void sub_10076DE3C()
{
  sub_10005732C();
  sub_100057438((void *)&_mh_execute_header, v0, v1, "updateAACPVersionInfo: deviceSupportInformation modifyError error %@", v2);
}

void sub_10076DEA8()
{
  sub_1000573EC();
  if (v4 != v5) {
    uint64_t v6 = v3;
  }
  else {
    uint64_t v6 = v1;
  }
  sub_100057464(v2, v6, 4.8751e-34);
  sub_100057438((void *)&_mh_execute_header, v7, (uint64_t)v7, "updateCaseInfo: No valid caseInfo for %{public}s", v8);
  if (*(char *)(v0 + 23) < 0) {
    operator delete(*(void **)v0);
  }
}

void sub_10076DF00()
{
  sub_10005732C();
  sub_100057438((void *)&_mh_execute_header, v0, v1, "updateCaseInfo: Error retrieving deviceSupportInformation: %@", v2);
}

void sub_10076DF6C()
{
  sub_10005732C();
  sub_100057438((void *)&_mh_execute_header, v0, v1, "updateCaseInfo: createError %@", v2);
}

void sub_10076DFD8()
{
  sub_10005732C();
  sub_100057438((void *)&_mh_execute_header, v0, v1, "updateCaseInfo: modifyError %@", v2);
}

void sub_10076E044()
{
  sub_10005732C();
  _os_log_debug_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_DEBUG, "CloudSync: writeMagicPairingSettingToCloud, MagicSettings: %@", v1, 0xCu);
}

void sub_10076E0B8()
{
  sub_10005732C();
  _os_log_debug_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_DEBUG, "CloudSync: writeMagicPairingSettingToCloud, CloudDevice: %@", v1, 0xCu);
}

void sub_10076E12C()
{
  sub_10005732C();
  sub_100057438((void *)&_mh_execute_header, v0, v1, "writeMagicPairingSettingToCloud: cloudDevice createError: %@", v2);
}

void sub_10076E198()
{
  sub_10005732C();
  sub_100057438((void *)&_mh_execute_header, v0, v1, "Magic Setting create cloud device failed: %@", v2);
}

void sub_10076E204()
{
  sub_10030D088();
  sub_1004A824C(v1, v2, v3, 4.8752e-34);
  sub_1004A8270((void *)&_mh_execute_header, "[Pairing] Unable to fetch magic settings: %{public}s, Error: %@", v4, v5);
  if (*(char *)(v0 + 23) < 0) {
    operator delete(*(void **)v0);
  }
}

void sub_10076E254()
{
  sub_10030D088();
  sub_1004A824C(v1, v2, v3, 4.8752e-34);
  sub_1004A8270((void *)&_mh_execute_header, "[Pairing] Unable to fetch cloud device: %{public}s, Error: %@", v4, v5);
  if (*(char *)(v0 + 23) < 0) {
    operator delete(*(void **)v0);
  }
}

void sub_10076E2A4()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Failed to update cloud with current device list.", v2, v3, v4, v5, v6);
}

void sub_10076E2D8()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Received invalid device address", v2, v3, v4, v5, v6);
}

void sub_10076E30C(char *a1, void *a2, NSObject *a3)
{
  if (*a1 < 0) {
    a2 = (void *)*a2;
  }
  int v3 = 136315138;
  uint64_t v4 = a2;
  sub_100057438((void *)&_mh_execute_header, a3, (uint64_t)a3, "Cannot find device or device not paired for address: %s", (uint8_t *)&v3);
}

void sub_10076E38C()
{
  sub_10030D088();
  sub_1004A824C(v1, v2, v3, 4.8752e-34);
  sub_1004A8270((void *)&_mh_execute_header, "Unable to fetch FM Status for %{public}s due to %@", v4, v5);
  if (*(char *)(v0 + 23) < 0) {
    operator delete(*(void **)v0);
  }
}

void sub_10076E3DC()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "[deviceInfoChanged] Account not signed in.", v2, v3, v4, v5, v6);
}

void sub_10076E410()
{
  sub_10030D088();
  sub_1004A824C(v1, v2, v3, 4.8752e-34);
  sub_1004A8270((void *)&_mh_execute_header, "[3rd] Failed to remove cloud record for %{public}s with error: %@", v4, v5);
  if (*(char *)(v0 + 23) < 0) {
    operator delete(*(void **)v0);
  }
}

void sub_10076E460()
{
  sub_10030D088();
  sub_1004A824C(v1, v2, v3, 4.8752e-34);
  sub_1004A8270((void *)&_mh_execute_header, "[3rd] Failed to create cloud record for %{public}s with error: %@", v4, v5);
  if (*(char *)(v0 + 23) < 0) {
    operator delete(*(void **)v0);
  }
}

void sub_10076E4B0()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Magic Pairing error disconnect failed with status %d", v2, v3, v4, v5, v6);
}

void sub_10076E518()
{
  sub_1000573EC();
  if (v4 != v5) {
    uint64_t v6 = v3;
  }
  else {
    uint64_t v6 = v1;
  }
  sub_100057464(v2, v6, 4.8751e-34);
  sub_100057438((void *)&_mh_execute_header, v7, (uint64_t)v7, "Magic Pairing failed, force disconnecting device %{public}s", v8);
  if (*(char *)(v0 + 23) < 0) {
    operator delete(*(void **)v0);
  }
}

void sub_10076E570()
{
  sub_1000573EC();
  if (v4 != v5) {
    uint64_t v6 = v3;
  }
  else {
    uint64_t v6 = v1;
  }
  sub_100057464(v2, v6, 4.8751e-34);
  sub_100057438((void *)&_mh_execute_header, v7, (uint64_t)v7, "Magic paired device for %{public}s not found", v8);
  if (*(char *)(v0 + 23) < 0) {
    operator delete(*(void **)v0);
  }
}

void sub_10076E5C8(uint64_t a1, NSObject *a2)
{
  v2[0] = 68157954;
  v2[1] = 16;
  __int16 v3 = 2096;
  uint64_t v4 = a1 + 65;
  _os_log_error_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_ERROR, "upgradeToManatee Acc Master Hint:%.16P", (uint8_t *)v2, 0x12u);
}

void sub_10076E654(uint64_t a1, NSObject *a2)
{
  v2[0] = 68157954;
  v2[1] = 16;
  __int16 v3 = 2096;
  uint64_t v4 = a1;
  _os_log_error_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_ERROR, "upgradeToManatee Acc Master Key:%.16P", (uint8_t *)v2, 0x12u);
}

void sub_10076E6DC()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Error upgrading to Manatee: No Master or Hint Key available", v2, v3, v4, v5, v6);
}

void sub_10076E710(int a1, NSObject *a2)
{
  v2[0] = 67109120;
  v2[1] = a1;
  _os_log_fault_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_FAULT, "Failed registration for MKB first unlock notification with error : %u", (uint8_t *)v2, 8u);
}

void sub_10076E788()
{
  sub_1000572DC();
  _os_log_fault_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_FAULT, "DeviceManager: Received MKB first unlock notification, but MKBDeviceUnlockedSinceBoot returns 0", v1, 2u);
}

void sub_10076E7C8(os_log_t log)
{
  int v1 = 136446210;
  uint64_t v2 = "!address.isZero()";
  _os_log_fault_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_FAULT, "Assertion failed: %{public}s", (uint8_t *)&v1, 0xCu);
}

void sub_10076E84C(os_log_t log)
{
  int v1 = 136446210;
  uint64_t v2 = "address != BTAddressEmpty";
  _os_log_fault_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_FAULT, "Assertion failed: %{public}s", (uint8_t *)&v1, 0xCu);
}

void sub_10076E8D0()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Spatial: getSpatialAllowed: System has not passed first unlock. Do not read/write device prefs", v2, v3, v4, v5, v6);
}

void sub_10076E904()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "System has not passed first unlock. Do not read/write device prefs", v2, v3, v4, v5, v6);
}

void sub_10076E938(uint64_t a1, NSObject *a2)
{
  int v2 = *(unsigned __int8 *)(a1 + 136);
  v3[0] = 67109120;
  v3[1] = v2;
  _os_log_debug_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_DEBUG, "Is incompatible Hid device connected: %u", (uint8_t *)v3, 8u);
}

void sub_10076E9B4()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Wireless Splitter error, unable to locate guestDevice after power on", v2, v3, v4, v5, v6);
}

void sub_10076E9E8(int a1, NSObject *a2)
{
  v2[0] = 67109120;
  v2[1] = a1;
  _os_log_error_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_ERROR, "Failed to register the Device Manager callback with result %{bluetooth:OI_STATUS}u", (uint8_t *)v2, 8u);
}

void sub_10076EA60(int a1, NSObject *a2)
{
  v2[0] = 67109120;
  v2[1] = a1;
  _os_log_error_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_ERROR, "Failed to unregister the Device Manager callback with result %{bluetooth:OI_STATUS}u", (uint8_t *)v2, 8u);
}

void sub_10076EAD8(uint64_t a1, NSObject *a2)
{
  int v2 = 134217984;
  uint64_t v3 = a1;
  _os_log_error_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_ERROR, "Failed to get address from handle %p", (uint8_t *)&v2, 0xCu);
}

void sub_10076EB50(uint64_t a1, NSObject *a2)
{
  sub_1000417A8(a1, __p);
  if (v5 >= 0) {
    uint64_t v3 = __p;
  }
  else {
    uint64_t v3 = (void **)__p[0];
  }
  *(_DWORD *)uint64_t buf = 136446210;
  char v7 = v3;
  _os_log_fault_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_FAULT, "Cannot hash UUID of unexpected length (%{public}s)", buf, 0xCu);
  if (v5 < 0) {
    operator delete(__p[0]);
  }
}

void sub_10076EC0C(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_10076EC84(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_10076ECFC(NSObject *a1)
{
  dispatch_queue_get_label(a1);
  sub_1004B1134((void *)&_mh_execute_header, v1, v2, "Registering %s in Dispatcher Watchdog", v3, v4, v5, v6, 2u);
}

void sub_10076ED78(NSObject *a1)
{
  dispatch_queue_get_label(a1);
  sub_1004B1134((void *)&_mh_execute_header, v1, v2, "Unregistering %s in Dispatcher Watchdog", v3, v4, v5, v6, 2u);
}

void sub_10076EDF4(char *a1, void *a2, os_log_t log)
{
  if (*a1 >= 0) {
    uint64_t v3 = a2;
  }
  else {
    uint64_t v3 = (void *)*a2;
  }
  int v4 = 136315138;
  uint64_t v5 = v3;
  _os_log_fault_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_FAULT, "%s", (uint8_t *)&v4, 0xCu);
}

void sub_10076EE80(uint8_t *a1, dispatch_queue_t queue, const char **a3, NSObject *a4)
{
  label = dispatch_queue_get_label(queue);
  *(_DWORD *)a1 = 136315138;
  *a3 = label;
  _os_log_error_impl((void *)&_mh_execute_header, a4, OS_LOG_TYPE_ERROR, "%s", a1, 0xCu);
}

void sub_10076EEEC()
{
  sub_1000572DC();
  _os_log_error_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_ERROR, " Stuck Queues ", v1, 2u);
}

void sub_10076EF2C()
{
  sub_1000572DC();
  _os_log_error_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_ERROR, "Bluetoothd is stuck. \n Registered Queues ", v1, 2u);
}

void sub_10076EF6C(uint64_t a1)
{
  dispatch_queue_get_label(*(dispatch_queue_t *)(a1 + 40));
  sub_1004B1134((void *)&_mh_execute_header, v1, v2, "Giving task to %s", v3, v4, v5, v6, 2u);
}

void sub_10076EFEC()
{
  sub_1000572DC();
  _os_log_debug_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_DEBUG, "Checking on the Tasks", v1, 2u);
}

void sub_10076F02C()
{
  sub_1000572DC();
  _os_log_debug_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_DEBUG, "Clearing All Tasks", v1, 2u);
}

void sub_10076F06C()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Too many registered services", v2, v3, v4, v5, v6);
}

void sub_10076F0A0()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Could not update SDP", v2, v3, v4, v5, v6);
}

void sub_10076F0D4()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Could not update EIR", v2, v3, v4, v5, v6);
}

void sub_10076F108()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Invalid address during an AFH update.", v2, v3, v4, v5, v6);
}

void sub_10076F13C()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Invalid handle during an AFH update.", v2, v3, v4, v5, v6);
}

void sub_10076F170()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Failed to set AFH map.", v2, v3, v4, v5, v6);
}

void sub_10076F1A4()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Failed to start HCI tracing (already in progress ?)", v2, v3, v4, v5, v6);
}

void sub_10076F1D8()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "BT not powered ON", v2, v3, v4, v5, v6);
}

void sub_10076F20C()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Failed to stop HCI tracing (already in progress ?)", v2, v3, v4, v5, v6);
}

void sub_10076F240(uint64_t a1, NSObject *a2)
{
  int v2 = 134217984;
  uint64_t v3 = a1;
  _os_log_error_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_ERROR, "Sandbox extension consume failed with error: %lld", (uint8_t *)&v2, 0xCu);
}

void sub_10076F2B8(uint64_t a1, uint8_t *buf, uint64_t a3, os_log_t log)
{
  *(_DWORD *)uint64_t buf = 134218242;
  *(void *)(buf + 4) = a3;
  *((_WORD *)buf + 6) = 2080;
  *(void *)(buf + 14) = a1;
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "ABC Snapshot failed with code %lld and reason: %s", buf, 0x16u);
}

void sub_10076F310()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Clean power off failed - %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_10076F378()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Stack startup failed - %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_10076F3E0()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Stack shutdown failed - %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_10076F448()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Power reset failed - %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_10076F4B0()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Stack halt failed - %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_10076F518(char a1, NSObject *a2)
{
  v2[0] = 67240192;
  v2[1] = a1 & 1;
  _os_log_debug_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_DEBUG, "SystemHealth post component status: %{public, BOOL}d", (uint8_t *)v2, 8u);
}

void sub_10076F594(char a1, uint64_t a2, os_log_t log)
{
  v3[0] = 67240450;
  v3[1] = a1 & 1;
  __int16 v4 = 2112;
  uint64_t v5 = a2;
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "SystemHealth post component status: %{public, BOOL}d Error: %@", (uint8_t *)v3, 0x12u);
}

void sub_10076F620(unsigned __int16 a1, int a2, os_log_t log)
{
  v3[0] = 67109376;
  v3[1] = a1;
  __int16 v4 = 1024;
  int v5 = a2;
  _os_log_debug_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_DEBUG, "Delete %d out %d entries from PowerAssertionHistory", (uint8_t *)v3, 0xEu);
}

void sub_10076F6AC(uint64_t a1)
{
  sub_1004BED28(a1);
  sub_10005732C();
  sub_1000E37A0((void *)&_mh_execute_header, v1, v2, "Failed to start \"%{public}s\" profile - no service is attached", v3, v4, v5, v6, v7);
}

void sub_10076F720()
{
  sub_1003FAE54();
  sub_1004BED28(v0);
  sub_100057360();
  sub_1000DDF08((void *)&_mh_execute_header, v1, v2, "Failed to start \"%{public}s\" profile - profile failed registration with result %d", v3, v4, v5, v6, v7);
}

void sub_10076F794()
{
  sub_1003FAE54();
  sub_1004BED28(v0);
  sub_100057360();
  sub_1000DDF08((void *)&_mh_execute_header, v1, v2, "Failed to start \"%{public}s\" profile - profile failed initialization with result %d", v3, v4, v5, v6, v7);
}

void sub_10076F808(uint64_t a1)
{
  sub_1004BED28(a1);
  sub_10005732C();
  sub_1000E37A0((void *)&_mh_execute_header, v1, v2, "Failed to start \"%{public}s\" profile - profile is not stopped", v3, v4, v5, v6, v7);
}

void sub_10076F87C()
{
  sub_1003FAE54();
  sub_1004BED28(v0);
  sub_100057360();
  sub_1000DDF08((void *)&_mh_execute_header, v1, v2, "Can't cleanup \"%{public}s\" profile - failed to clean up with result %d", v3, v4, v5, v6, v7);
}

void sub_10076F8F0()
{
  sub_1003FAE54();
  sub_1004BED28(v0);
  sub_100057360();
  sub_1000DDF08((void *)&_mh_execute_header, v1, v2, "Can't deregister \"%{public}s\" profile - failed to deregister with result %d", v3, v4, v5, v6, v7);
}

void sub_10076F964(uint64_t a1)
{
  sub_1004BED28(a1);
  sub_10005732C();
  sub_1000E37A0((void *)&_mh_execute_header, v1, v2, "\"%{public}s\" profile is already stopped", v3, v4, v5, v6, v7);
}

void sub_10076F9D8()
{
  sub_1003FAE54();
  sub_1004BED28(v1);
  sub_10005732C();
  __int16 v4 = 2082;
  uint64_t v5 = v2;
  _os_log_error_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_ERROR, "\"%{public}s\" profile rejecting incoming connection as %{public}s", v3, 0x16u);
}

void sub_10076FA80(unsigned int a1, uint64_t a2, int a3, NSObject *a4)
{
  uint8_t v7 = sub_1004BC79C(a1);
  *(_DWORD *)a2 = 136446466;
  *(void *)(a2 + 4) = v7;
  *(_WORD *)(a2 + 12) = 1024;
  *(_DWORD *)(a2 + 14) = a3;
  _os_log_error_impl((void *)&_mh_execute_header, a4, OS_LOG_TYPE_ERROR, "\"%{public}s\" profile rejecting incoming connection as it would exceed the maximum number of connections (%d)", (uint8_t *)a2, 0x12u);
}

void sub_10076FAF4(uint64_t a1)
{
  sub_1004BED28(a1);
  sub_10005732C();
  sub_1000E37A0((void *)&_mh_execute_header, v1, v2, "\"%{public}s\" profile rejecting incoming connection as Bluetooth power is not on", v3, v4, v5, v6, v7);
}

void sub_10076FB68(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_10076FBE0(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_10076FC58(unsigned int *a1, NSObject *a2)
{
  sub_1004BC79C(*a1);
  sub_10005732C();
  _os_log_fault_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_FAULT, "Can not be connecting/connected to \"%{public}s\" profile at the same time", v3, 0xCu);
}

void sub_10076FCE4(int a1, NSObject *a2)
{
  v2[0] = 67109120;
  v2[1] = a1;
  _os_log_fault_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_FAULT, "Gatt connected with error %{bluetooth:OI_STATUS}u", (uint8_t *)v2, 8u);
}

void sub_10076FD5C(uint64_t a1, NSObject *a2)
{
  int v2 = 138543362;
  uint64_t v3 = a1;
  _os_log_fault_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_FAULT, "Gatt device %{public}@ connected over classic when it should have be rejected", (uint8_t *)&v2, 0xCu);
}

void sub_10076FDD4(os_log_t log)
{
  *(_WORD *)uint64_t v1 = 0;
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "GATT disconnected with handle that's not tracked", v1, 2u);
}

void sub_10076FE18(os_log_t log)
{
  *(_WORD *)uint64_t v1 = 0;
  _os_log_fault_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_FAULT, "GATT device ready with handle that's not tracked", v1, 2u);
}

void sub_10076FE5C(int a1, NSObject *a2)
{
  v2[0] = 67109120;
  v2[1] = a1;
  _os_log_error_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_ERROR, "Gatt device connected with error %{bluetooth:OI_STATUS}u", (uint8_t *)v2, 8u);
}

void sub_10076FED4()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to register stack callbacks with %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_10076FF3C()
{
  sub_1000572DC();
  sub_10031659C((void *)&_mh_execute_header, v0, v1, "SDP query not allowed at this time", v2);
}

void sub_10076FF74()
{
  sub_1000572DC();
  sub_10031659C((void *)&_mh_execute_header, v0, v1, "NULL device -- aborting SDP", v2);
}

void sub_10076FFAC(os_log_t log)
{
  int v1 = 136446210;
  uint64_t v2 = "!sdpQueryInfo->stackWillstop";
  _os_log_fault_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_FAULT, "Assertion failed: %{public}s", (uint8_t *)&v1, 0xCu);
}

void sub_100770030(int a1, NSObject *a2)
{
  sub_100474E18(*(void *)qword_100A132C0, __p);
  if (v6 >= 0) {
    uint64_t v4 = __p;
  }
  else {
    uint64_t v4 = (void **)__p[0];
  }
  *(_DWORD *)uint64_t buf = 136446466;
  uint64_t v8 = v4;
  __int16 v9 = 1024;
  int v10 = a1;
  _os_log_error_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_ERROR, "SDP connection to device %{public}s failed with result %{bluetooth:OI_STATUS}u", buf, 0x12u);
  if (v6 < 0) {
    operator delete(__p[0]);
  }
}

void sub_10077010C()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Service search request failed %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_100770174()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "SDP Service database state search failed with %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_1007701DC()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Response returned status = %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_100770244()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Service database state response error with status %{bluetooth:OI_STATUS}u, need to disconnect", v2, v3, v4, v5, v6);
}

void sub_1007702AC(unsigned int a1, NSObject *a2)
{
  int v3 = 136315138;
  uint64_t v4 = sub_1004C25D4(a1);
  _os_log_error_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_ERROR, "Invalid SDP state: %s", (uint8_t *)&v3, 0xCu);
}

void sub_100770338()
{
  sub_1000572DC();
  sub_10031659C((void *)&_mh_execute_header, v0, v1, "Attribute search didn't return a list", v2);
}

void sub_100770370(os_log_t log)
{
  int v1 = 136446210;
  uint64_t v2 = "!isStackShuttingDown";
  _os_log_fault_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_FAULT, "Assertion failed: %{public}s", (uint8_t *)&v1, 0xCu);
}

void sub_1007703F4()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Error while executing DID %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_10077045C()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to issue DID service search with status %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_1007704C4()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Attribute request failed with status %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_10077052C(unsigned char *a1, unsigned char *a2)
{
  sub_10026C69C(a1, a2);
  sub_10031659C((void *)&_mh_execute_header, v2, (uint64_t)v2, "AttributeValue wasn't a OI_DATAELEM_UINT, skipping", v3);
}

void sub_10077055C(unsigned char *a1, unsigned char *a2)
{
  sub_10026C69C(a1, a2);
  sub_10031659C((void *)&_mh_execute_header, v2, (uint64_t)v2, "AttributeValue inside OI_ATTRID_BluetoothProfileDescriptorList wasn't a OI_DATAELEM_SEQ, skipping", v3);
}

void sub_10077058C(unsigned char *a1, unsigned char *a2)
{
  sub_10026C69C(a1, a2);
  sub_10031659C((void *)&_mh_execute_header, v2, (uint64_t)v2, "AttributeValue wasn't a OI_DATAELEM_SEQ, skipping", v3);
}

void sub_1007705BC(unsigned char *a1, unsigned char *a2)
{
  sub_10026C69C(a1, a2);
  sub_10031659C((void *)&_mh_execute_header, v2, (uint64_t)v2, "AttributeID wasn't a UINT, skipping", v3);
}

void sub_1007705EC()
{
  sub_1000572DC();
  sub_10031659C((void *)&_mh_execute_header, v0, v1, "Service Attribute response received on already freed SDP client", v2);
}

void sub_100770624()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Service attribute response error with status %{bluetooth:OI_STATUS}u, need to disconnect", v2, v3, v4, v5, v6);
}

void sub_10077068C(unsigned int a1, NSObject *a2)
{
  if (a1 > 0xA) {
    uint64_t v2 = "unknown sdp state";
  }
  else {
    uint64_t v2 = off_1009B1370[a1];
  }
  int v3 = 136315138;
  uint64_t v4 = v2;
  _os_log_error_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_ERROR, "Invalid state while trying to update RFCOMM channel state %s", (uint8_t *)&v3, 0xCu);
}

void sub_100770724()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Service Search+Attribute response error with status %{bluetooth:OI_STATUS}u, need to disconnect", v2, v3, v4, v5, v6);
}

void sub_10077078C(uint64_t a1, NSObject *a2)
{
  int v2 = 141558531;
  uint64_t v3 = 1752392040;
  __int16 v4 = 1041;
  int v5 = 6;
  __int16 v6 = 2097;
  uint64_t v7 = a1 + 44;
  _os_log_error_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_ERROR, "Device for addr %{private,bluetooth:BD_ADDR,mask.hash}.6P not found", (uint8_t *)&v2, 0x1Cu);
}

void sub_10077082C(os_log_t log)
{
  *(_WORD *)uint64_t v1 = 0;
  _os_log_fault_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_FAULT, "SDP query complete on an invalid device!", v1, 2u);
}

void sub_100770870()
{
  sub_1004CCF14(__stack_chk_guard);
  sub_1004428C0();
  sub_1000572F4((void *)&_mh_execute_header, v0, v1, "%{public}s is already started", v2, v3, v4, v5, v6);
}

void sub_1007708E0()
{
  sub_1004CCF14(__stack_chk_guard);
  sub_1004428C0();
  sub_1000572F4((void *)&_mh_execute_header, v0, v1, "%{public}s is already stopped", v2, v3, v4, v5, v6);
}

void sub_100770950(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_1007709C8()
{
  sub_1004CCF14(__stack_chk_guard);
  sub_1004428C0();
  sub_1000572F4((void *)&_mh_execute_header, v0, v1, "%{public}s is not started", v2, v3, v4, v5, v6);
}

void sub_100770A38()
{
  sub_1004CCF14(__stack_chk_guard);
  sub_1004428C0();
  sub_1000572F4((void *)&_mh_execute_header, v0, v1, "%{public}s - profile was null", v2, v3, v4, v5, v6);
}

void sub_100770AA8(char *a1, uint64_t a2, uint8_t *buf, os_log_t log)
{
  uint64_t v5 = *(char **)a1;
  if (a1[23] >= 0) {
    uint64_t v5 = a1;
  }
  uint8_t v6 = (void *)(a2 + 8);
  if (*(char *)(a2 + 31) < 0) {
    uint8_t v6 = (void *)*v6;
  }
  *(_DWORD *)uint64_t buf = 136446466;
  *(void *)(buf + 4) = v5;
  *((_WORD *)buf + 6) = 2082;
  *(void *)(buf + 14) = v6;
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "Device %{public}s is no longer authorized for service %{public}s - disconnecting", buf, 0x16u);
  if (a1[23] < 0) {
    operator delete(*(void **)a1);
  }
}

void sub_100770B3C()
{
  sub_10005732C();
  sub_1003CF064((void *)&_mh_execute_header, v0, v1, "BTPairingMsgHandler::handleBTPairingAgentCreateMsg sessionID:%llx", v2, v3, v4, v5, v6);
}

void sub_100770BA4(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_100770C14()
{
  sub_10005732C();
  sub_1003CF064((void *)&_mh_execute_header, v0, v1, "BTPairingMsgHandler::handleBTPairingAgentStartMsg agentID:%llx", v2, v3, v4, v5, v6);
}

void sub_100770C7C()
{
  sub_10005732C();
  sub_1003CF064((void *)&_mh_execute_header, v0, v1, "BTPairingMsgHandler::handleBTPairingAgentStopMsg agentID:%llx", v2, v3, v4, v5, v6);
}

void sub_100770CE4()
{
  sub_10005732C();
  sub_1003CF064((void *)&_mh_execute_header, v0, v1, "BTPairingMsgHandler::handleBTPairingAgentCancelPairingMsg agentID:%llx", v2, v3, v4, v5, v6);
}

void sub_100770D4C()
{
  sub_10005732C();
  sub_1003CF064((void *)&_mh_execute_header, v0, v1, "BTPairingMsgHandler::handleBTPairingAgentSetPincodeMsg agentID:%llx", v2, v3, v4, v5, v6);
}

void sub_100770DB4()
{
  sub_10005732C();
  sub_1003CF064((void *)&_mh_execute_header, v0, v1, "BTPairingMsgHandler::handleBTPairingAgentAcceptSSPMsg agentID:%llx", v2, v3, v4, v5, v6);
}

void sub_100770E1C()
{
  sub_10005732C();
  sub_1003CF064((void *)&_mh_execute_header, v0, v1, "BTPairingMsgHandler::handleBTPairingAgentDeletePairedDeviceMsg agentID:%llx", v2, v3, v4, v5, v6);
}

void sub_100770E84()
{
  sub_10005732C();
  sub_1003CF064((void *)&_mh_execute_header, v0, v1, "BTPairingMsgHandler::handleBTPairingAgentSetIOCapabilityMsg agentID:%llx", v2, v3, v4, v5, v6);
}

void sub_100770EEC()
{
  sub_10005732C();
  sub_1003CF064((void *)&_mh_execute_header, v0, v1, "BTPairingMsgHandler::handleBTPairingAgentClearOOBDataForDeviceMsg agentID:%llx", v2, v3, v4, v5, v6);
}

void sub_100770F54()
{
  sub_10005732C();
  sub_1003CF064((void *)&_mh_execute_header, v0, v1, "BTPairingMsgHandler::handleBTPairingAgentSetOOBDataForDeviceMsg agentID:%llx", v2, v3, v4, v5, v6);
}

void sub_100770FBC()
{
  sub_1000572DC();
  sub_10030D118((void *)&_mh_execute_header, v0, v1, "Incorrect Buffer Length for r256", v2, v3, v4, v5, v6);
}

void sub_100770FF0()
{
  sub_1000572DC();
  sub_10030D118((void *)&_mh_execute_header, v0, v1, "Incorrect Buffer Length for c256", v2, v3, v4, v5, v6);
}

void sub_100771024()
{
  sub_1000572DC();
  sub_10030D118((void *)&_mh_execute_header, v0, v1, "Incorrect Buffer Length for r192", v2, v3, v4, v5, v6);
}

void sub_100771058()
{
  sub_1000572DC();
  sub_10030D118((void *)&_mh_execute_header, v0, v1, "Incorrect Buffer Length for c192", v2, v3, v4, v5, v6);
}

void sub_10077108C()
{
  sub_10005732C();
  sub_1003CF064((void *)&_mh_execute_header, v0, v1, "BTPairingMsgHandler::handleBTPairingAgentGetLocalOOBDataMsg agentID:%llx", v2, v3, v4, v5, v6);
}

void sub_1007710F4(uint64_t *a1, NSObject *a2)
{
  uint64_t v2 = *a1;
  int v3 = 134217984;
  uint64_t v4 = v2;
  _os_log_error_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_ERROR, "Still waiting for %lu services to shut down", (uint8_t *)&v3, 0xCu);
}

void sub_100771170(uint8_t *buf, unsigned char *a2, os_log_t log)
{
  *uint64_t buf = 0;
  *a2 = 0;
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "Service event device handle is NULL", buf, 2u);
}

void sub_1007711B0()
{
  sub_1002B7074();
  sub_100057550(v1, v2, v3, 4.8752e-34);
  _os_log_error_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "Fast connect ACL failed for device with %{public}s error %d", v4, 0x12u);
  if (*(char *)(v0 + 23) < 0) {
    operator delete(*(void **)v0);
  }
}

void sub_10077120C(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_100771244(char *a1, uint8_t *buf, os_log_t log)
{
  if (a1[23] >= 0) {
    uint64_t v4 = a1;
  }
  else {
    uint64_t v4 = *(char **)a1;
  }
  *(_DWORD *)uint64_t buf = 136446210;
  *(void *)(buf + 4) = v4;
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "Device %{public}s has empty UUID", buf, 0xCu);
  if (a1[23] < 0) {
    operator delete(*(void **)a1);
  }
}

void sub_1007712B8(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_100771324(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_100771390(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_1007713C8()
{
  sub_1002B7074();
  sub_100057550(v1, v2, v3, 4.8752e-34);
  _os_log_error_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "PFC to device %{public}s failed with %d", v4, 0x12u);
  if (*(char *)(v0 + 23) < 0) {
    operator delete(*(void **)v0);
  }
}

void sub_100771424(os_log_t log)
{
  int v1 = 136446210;
  uint64_t v2 = "device != NULL";
  _os_log_fault_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_FAULT, "Assertion failed: %{public}s", (uint8_t *)&v1, 0xCu);
}

void sub_1007714A8(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_100057310((void *)&_mh_execute_header, a2, a3, "LE disconnect returned %d", a5, a6, a7, a8, 0);
}

void sub_100771514(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_10077154C(uint64_t a1, NSObject *a2)
{
  sub_100474E18(a1, __p);
  if (v5 >= 0) {
    int v3 = __p;
  }
  else {
    int v3 = (void **)__p[0];
  }
  *(_DWORD *)uint64_t buf = 136446210;
  uint64_t v7 = v3;
  _os_log_error_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_ERROR, "fastConnectProcessNextConnection for device %{public}s", buf, 0xCu);
  if (v5 < 0) {
    operator delete(__p[0]);
  }
}

void sub_100771600()
{
  sub_1004428C0();
  sub_1000572F4((void *)&_mh_execute_header, v0, v1, "L2CAP Packet Aggregation is overriden by defaults (=%s)", v2, v3, v4, v5, v6);
}

void sub_100771684()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "OI_DI_Register failed with result %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_1007716EC()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to register the command disallowed event callback with result %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_100771754()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to register the hardware error callback with result %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_1007717BC()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to read the local address with result %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_100771824(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_100771894()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to initialize the stack wrapper with result %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_1007718FC()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "enableBTSpecAdvertisingSets cannot be false if enableExtendedAdvertising is true, overriding.", v2, v3, v4, v5, v6);
}

void sub_100771930()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Disabling Secure Connections", v2, v3, v4, v5, v6);
}

void sub_100771964()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "LMP Routing is disabled", v2, v3, v4, v5, v6);
}

void sub_100771998()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Disabling Write COD WAR", v2, v3, v4, v5, v6);
}

void sub_1007719CC()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Disabling Connection Update WAR", v2, v3, v4, v5, v6);
}

void sub_100771A00()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Forcing Phy to 1Mpbs", v2, v3, v4, v5, v6);
}

void sub_100771A34()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "OI_DEVMGR_WriteStaticSettings failed with result %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_100771A9C()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "DI dergistration failed with %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_100771B04()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "StackManager state currently in flux - not ready to start", v2, v3, v4, v5, v6);
}

void sub_100771B38()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Failed to Turn off the antenna switch VSE", v2, v3, v4, v5, v6);
}

void sub_100771B6C()
{
  sub_1000572DC();
  _os_log_debug_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_DEBUG, "QoS Config Supported", v1, 2u);
}

void sub_100771BAC()
{
  sub_1000572DC();
  _os_log_debug_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_DEBUG, "QoS Config Not Supported", v1, 2u);
}

void sub_100771BEC()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Core Stack initialization failed!", v2, v3, v4, v5, v6);
}

void sub_100771C20()
{
  sub_1000572DC();
  sub_10030D118((void *)&_mh_execute_header, v0, v1, "Unable to send sleep mode parameters to host controller", v2, v3, v4, v5, v6);
}

void sub_100771C54()
{
  sub_1000572DC();
  sub_10030D118((void *)&_mh_execute_header, v0, v1, "Unable to send calibration data to host controller", v2, v3, v4, v5, v6);
}

void sub_100771C88()
{
  sub_1000572DC();
  sub_10030D118((void *)&_mh_execute_header, v0, v1, "Unable to copy calibration data", v2, v3, v4, v5, v6);
}

void sub_100771CBC()
{
  sub_1000572DC();
  sub_10030D118((void *)&_mh_execute_header, v0, v1, "Unable to send regulatory data to host controller", v2, v3, v4, v5, v6);
}

void sub_100771CF0()
{
  sub_1000572DC();
  sub_10030D118((void *)&_mh_execute_header, v0, v1, "Unable to copy regulatory data", v2, v3, v4, v5, v6);
}

void sub_100771D24()
{
  sub_1004428C0();
  sub_1000572F4((void *)&_mh_execute_header, v0, v1, "Ignoring connectability change request as stack is not %{public}s", v2, v3, v4, v5, v6);
}

void sub_100771DA4()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Transport hard reset failed", v2, v3, v4, v5, v6);
}

void sub_100771DD8()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "StackManager state currently in flux - not ready to halt", v2, v3, v4, v5, v6);
}

void sub_100771E0C()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, " OI_HCI_Reset callback failed with result %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_100771E74()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to send HCIReset command with result %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_100771EDC()
{
  sub_1004428C0();
  sub_1000572F4((void *)&_mh_execute_header, v0, v1, "Ignoring discoverability change request as stack is not %{public}s", v2, v3, v4, v5, v6);
}

void sub_100771F60()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Stack is not ready", v2, v3, v4, v5, v6);
}

void sub_100771F94()
{
  sub_1004EB5D8();
  sub_100057518((void *)&_mh_execute_header, v0, v1, "Failed to make local device %s with result %{bluetooth:OI_STATUS}u");
}

void sub_100772010()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Cancelling discoverability change event as stack is not running", v2, v3, v4, v5, v6);
}

void sub_100772044()
{
  sub_1004428C0();
  sub_1000572F4((void *)&_mh_execute_header, v0, v1, "Failed to set local device discoverability - current state is %{public}s", v2, v3, v4, v5, v6);
}

void sub_1007720C8()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "OI_HCI_WriteEIR failed: %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_100772130(os_log_t log)
{
  int v1 = 136446210;
  uint64_t v2 = "constEirLen < OI_DHCI_EIR_DATA_LEN";
  _os_log_fault_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_FAULT, "Assertion failed: %{public}s", (uint8_t *)&v1, 0xCu);
}

void sub_1007721B4()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Could not set EIR : %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_10077221C()
{
  sub_1004428C0();
  sub_1000572F4((void *)&_mh_execute_header, v0, v1, "Failed to set local device connectability - current state is %{public}s", v2, v3, v4, v5, v6);
}

void sub_1007722A0()
{
  sub_1004EB5D8();
  sub_100057518((void *)&_mh_execute_header, v0, v1, "Failed to make local device %s with result %{bluetooth:OI_STATUS}u");
}

void sub_10077231C()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Cancelling connectability change event as stack is not running", v2, v3, v4, v5, v6);
}

void sub_100772350(uint64_t a1, uint64_t a2)
{
  sub_100359178(a1, a2, 4.8752e-34);
  *(_WORD *)(v2 + 12) = 1024;
  *(_DWORD *)(v2 + 14) = 0;
  _os_log_debug_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEBUG, "%{public}s completed with status %{bluetooth:OI_STATUS}u", v4, 0x12u);
}

void sub_1007723A0(uint64_t a1, uint64_t a2)
{
  sub_100359178(a1, a2, 4.8752e-34);
  *(_WORD *)(v2 + 12) = 1024;
  *(_DWORD *)(v2 + 14) = v3;
  _os_log_error_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "%{public}s completed with status %{bluetooth:OI_STATUS}u", v4, 0x12u);
}

void sub_1007723F4(uint64_t a1, uint64_t a2)
{
  sub_100359178(a1, a2, 4.8751e-34);
  _os_log_error_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_ERROR, "%{public}s timedout waiting for controller, however core-dump is in progress, wait for it to complete", v3, 0xCu);
}

void sub_100772438(uint64_t a1, uint64_t a2)
{
  sub_100359178(a1, a2, 4.8751e-34);
  _os_log_error_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_ERROR, "%{public}s timedout waiting for controller", v3, 0xCu);
}

void sub_10077247C()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Unable to find fail safe calibration file", v2, v3, v4, v5, v6);
}

void sub_1007724B0()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Calibration/Regulatory VSC error result of %d", v2, v3, v4, v5, v6);
}

void sub_100772518()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "StackManager Cannot set Spatial Mode with empty Bundle ID", v2, v3, v4, v5, v6);
}

void sub_10077254C()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "BundleID does not exist, return default", v2, v3, v4, v5, v6);
}

void sub_100772580()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "BundleID exist, pair dict invalid", v2, v3, v4, v5, v6);
}

void sub_1007725B4()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "BundleID mode exist, no headtrack", v2, v3, v4, v5, v6);
}

void sub_1007725E8()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Cannot get Spatial Mode with empty Bundle ID, return default value", v2, v3, v4, v5, v6);
}

void sub_10077261C()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to change local name with result %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_100772684()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "readRSSI return status %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_1007726EC()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Issuing readRSSI failed with status %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_100772754()
{
  sub_1004EB5B0();
  sub_100449690((void *)&_mh_execute_header, v0, v1, "Set disconnection timeout override for %{bluetooth:BD_ADDR}.6P failed with %{bluetooth:OI_STATUS}u");
}

void sub_1007727BC()
{
  sub_1004EB5B0();
  sub_100449690((void *)&_mh_execute_header, v0, v1, "Set disable roleswitch for single connection failed for %{bluetooth:BD_ADDR}.6P failed with %{bluetooth:OI_STATUS}u");
}

void sub_100772824()
{
  sub_1004EB5B0();
  sub_100449690((void *)&_mh_execute_header, v0, v1, "Set accept roleswitch for single connection failed for %{bluetooth:BD_ADDR}.6P failed with %{bluetooth:OI_STATUS}u");
}

void sub_10077288C()
{
  sub_1004EB5B0();
  sub_100449690((void *)&_mh_execute_header, v0, v1, "Disabling roleswitch for %{bluetooth:BD_ADDR}.6P failed with %{bluetooth:OI_STATUS}u");
}

void sub_1007728F4()
{
  sub_1004EB5B0();
  sub_100449690((void *)&_mh_execute_header, v0, v1, "Invoking reduced QoS Latency for %{bluetooth:BD_ADDR}.6P failed with %{bluetooth:OI_STATUS}u");
}

void sub_10077295C()
{
  sub_1004EB5B0();
  sub_100449690((void *)&_mh_execute_header, v0, v1, "Setting extended LSTO for %{bluetooth:BD_ADDR}.6P failed with %{bluetooth:OI_STATUS}u");
}

void sub_1007729C4()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "OI_HCI_EnableDeviceUnderTestMode callback failed with result %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_100772A2C()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to enable DUT mode with result %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_100772A94()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "OI_HCI_SetEventFilter callback failed with result %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_100772AFC()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to set event filter with result %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_100772B64()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "OI_HCICMD_WriteScanEnable callback failed with result %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_100772BCC()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to enable LE TX Test mode with result %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_100772C34()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "LE Test is already running.", v2, v3, v4, v5, v6);
}

void sub_100772C68()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "LE Test is not running.", v2, v3, v4, v5, v6);
}

void sub_100772C9C()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to stop LE Test mode with result %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_100772D04()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Ignoring error from OI_DEVMGR_WriteStaticSettings: %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_100772D6C()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "OI_DEVMGR_WriteStaticSettings callback failed with result %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_100772DD4()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to write local device EIR with result %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_100772E3C()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "OI_SECMGR_RegisterSecurityDB failed with result %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_100772EA4()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "OI_SECMGR_RegisterESE failed with result %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_100772F0C()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to set local device class with result %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_100772F74()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "OI_HCI_WriteEIR callback failed with result %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_100772FDC(uint8_t *buf, void *a2, os_log_t log)
{
  *(_DWORD *)uint64_t buf = 136446210;
  *a2 = "devicePair.second";
  _os_log_fault_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_FAULT, "Assertion failed: %{public}s", buf, 0xCu);
}

void sub_10077302C(uint64_t a1, NSObject *a2)
{
  int v2 = 138412290;
  uint64_t v3 = a1;
  _os_log_error_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_ERROR, "Failed to create HID user device with properties: %@", (uint8_t *)&v2, 0xCu);
}

void sub_1007730A4(uint64_t a1, NSObject *a2)
{
  int v2 = 138412290;
  uint64_t v3 = a1;
  _os_log_error_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_ERROR, "Failed to create non-keyholed HID user device with properties: %@", (uint8_t *)&v2, 0xCu);
}

void sub_10077311C()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Input report ID %u is not a large report", v2, v3, v4, v5, v6);
}

void sub_100773184(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_1007731BC(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_1007731F4(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_10077322C()
{
  sub_1000572E8();
  __int16 v3 = 2048;
  uint64_t v4 = v0;
  _os_log_error_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_ERROR, "getReportWithKeyhole 0x%x worked but returned wrong length (%lu)", v2, 0x12u);
}

void sub_1007732B0()
{
  sub_1000572E8();
  __int16 v3 = 1024;
  int v4 = v0;
  _os_log_error_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_ERROR, "getReportWithKeyhole 0x%x set to 0xFF failed: 0x%x", v2, 0xEu);
}

void sub_100773334()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "getReportWithKeyhole 0x%x missing report or reportLength", v2, v3, v4, v5, v6);
}

void sub_10077339C()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "setReportWithKeyhole 0x%x missing report or reportLength", v2, v3, v4, v5, v6);
}

void sub_10077340C()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Failed to rewrite page timeout.", v2, v3, v4, v5, v6);
}

void sub_100773440()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Failed to write page timeout.", v2, v3, v4, v5, v6);
}

void sub_100773474()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Invalid scan state.", v2, v3, v4, v5, v6);
}

void sub_1007734A8()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Failed to set page timeout.", v2, v3, v4, v5, v6);
}

void sub_1007734E4(int a1, NSObject *a2)
{
  v2[0] = 67109120;
  v2[1] = a1;
  _os_log_error_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_ERROR, "Unhandled XPC message: %u", (uint8_t *)v2, 8u);
}

void sub_10077355C(os_log_t log)
{
  *(_WORD *)uint64_t v1 = 0;
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "Ignoring XPC message as session is NULL", v1, 2u);
}

void sub_1007735A0(uint64_t a1, NSObject *a2)
{
  unsigned int v2 = *(_DWORD *)(a1 + 136) - 1;
  if (v2 > 9) {
    uint64_t v3 = "Unknown";
  }
  else {
    uint64_t v3 = off_1009B27B0[v2];
  }
  int v4 = 136446210;
  uint64_t v5 = v3;
  _os_log_error_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_ERROR, "Ignoring XPC message as state is \"%{public}s\"", (uint8_t *)&v4, 0xCu);
}

void sub_100773640(os_log_t log)
{
  *(_WORD *)uint64_t v1 = 0;
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "XPC message with XPC_TYPE_ERROR ", v1, 2u);
}

void sub_100773684(char *a1, unsigned __int16 a2, NSObject *a3)
{
  uint64_t v5 = (*(uint64_t (**)(char *, void))(*(void *)a1 + 56))(a1, a2);
  uint8_t v6 = a1 + 56;
  if (a1[79] < 0) {
    uint8_t v6 = (void *)*v6;
  }
  int v7 = 136446466;
  uint64_t v8 = v5;
  __int16 v9 = 2082;
  int v10 = v6;
  _os_log_debug_impl((void *)&_mh_execute_header, a3, OS_LOG_TYPE_DEBUG, "Sending XPC message \"%{public}s\" to session \"%{public}s\"", (uint8_t *)&v7, 0x16u);
}

void sub_100773754(uint8_t *a1, void *a2, NSObject *a3)
{
  *(_DWORD *)a1 = 136446210;
  *a2 = "type == GATT_ATT_TYPE_PRIMARY_SERVICE";
  sub_1004F600C((void *)&_mh_execute_header, (int)a2, a3, "Assertion failed: %{public}s", a1);
}

void sub_100773798(unsigned __int16 **a1, NSObject *a2)
{
  int v2 = **a1;
  v3[0] = 67109120;
  v3[1] = v2;
  _os_log_fault_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_FAULT, "Found orphaned handle 0x%04x in handle map", (uint8_t *)v3, 8u);
}

void sub_100773818()
{
  sub_1000573EC();
  if (v4 != v5) {
    uint64_t v6 = v3;
  }
  else {
    uint64_t v6 = v1;
  }
  sub_100057464(v2, v6, 4.8751e-34);
  sub_1004F600C((void *)&_mh_execute_header, v7, v8, "Didn't have entry in handle map for service \"%{public}s\"", v9);
  if (*(char *)(v0 + 23) < 0) {
    operator delete(*(void **)v0);
  }
}

void sub_10077386C(uint8_t *a1, void *a2, NSObject *a3)
{
  *(_DWORD *)a1 = 136446210;
  *a2 = "type == GATT_ATT_TYPE_INCLUDED_SERVICE";
  sub_1004F600C((void *)&_mh_execute_header, (int)a2, a3, "Assertion failed: %{public}s", a1);
}

void sub_1007738B0()
{
  sub_1000573EC();
  if (v4 != v5) {
    uint64_t v6 = v3;
  }
  else {
    uint64_t v6 = v1;
  }
  sub_100057464(v2, v6, 4.8751e-34);
  sub_1004F600C((void *)&_mh_execute_header, v7, v8, "Didn't have entry in handle map for characteristic \"%{public}s\"", v9);
  if (*(char *)(v0 + 23) < 0) {
    operator delete(*(void **)v0);
  }
}

void sub_100773904()
{
  sub_1000573EC();
  if (v4 != v5) {
    uint64_t v6 = v3;
  }
  else {
    uint64_t v6 = v1;
  }
  sub_100057464(v2, v6, 4.8751e-34);
  sub_100057404((void *)&_mh_execute_header, v7, v8, "Unable to find parent service for included service \"%{public}s\"!", v9);
  if (*(char *)(v0 + 23) < 0) {
    operator delete(*(void **)v0);
  }
}

void sub_100773958(uint8_t *a1, void *a2, NSObject *a3)
{
  *(_DWORD *)a1 = 136446210;
  *a2 = "type == GATT_ATT_TYPE_CHARACTERISTIC";
  sub_1004F600C((void *)&_mh_execute_header, (int)a2, a3, "Assertion failed: %{public}s", a1);
}

void sub_10077399C()
{
  sub_1000573EC();
  if (v4 != v5) {
    uint64_t v6 = v3;
  }
  else {
    uint64_t v6 = v1;
  }
  sub_100057464(v2, v6, 4.8751e-34);
  sub_100057404((void *)&_mh_execute_header, v7, v8, "Unable to find parent service for characteristic \"%{public}s\"!", v9);
  if (*(char *)(v0 + 23) < 0) {
    operator delete(*(void **)v0);
  }
}

void sub_1007739F0()
{
  sub_1000573EC();
  if (v4 != v5) {
    uint64_t v6 = v3;
  }
  else {
    uint64_t v6 = v1;
  }
  sub_100057464(v2, v6, 4.8751e-34);
  sub_100057404((void *)&_mh_execute_header, v7, v8, "Unable to find parent service for value \"%{public}s\"!", v9);
  if (*(char *)(v0 + 23) < 0) {
    operator delete(*(void **)v0);
  }
}

void sub_100773A44()
{
  sub_1000573EC();
  if (v4 != v5) {
    uint64_t v6 = v3;
  }
  else {
    uint64_t v6 = v1;
  }
  sub_100057464(v2, v6, 4.8751e-34);
  sub_100057404((void *)&_mh_execute_header, v7, v8, "Dropping value \"%{public}s\" as we couldn't find a parent characteristic", v9);
  if (*(char *)(v0 + 23) < 0) {
    operator delete(*(void **)v0);
  }
}

void sub_100773A98()
{
  sub_1000573EC();
  if (v4 != v5) {
    uint64_t v6 = v3;
  }
  else {
    uint64_t v6 = v1;
  }
  sub_100057464(v2, v6, 4.8751e-34);
  sub_1004F600C((void *)&_mh_execute_header, v7, v8, "Didn't have entry in handle map for descriptor \"%{public}s\"", v9);
  if (*(char *)(v0 + 23) < 0) {
    operator delete(*(void **)v0);
  }
}

void sub_100773AEC()
{
  sub_1000573EC();
  if (v4 != v5) {
    uint64_t v6 = v3;
  }
  else {
    uint64_t v6 = v1;
  }
  sub_100057464(v2, v6, 4.8751e-34);
  sub_100057404((void *)&_mh_execute_header, v7, v8, "Unable to find parent service for descriptor \"%{public}s\"!", v9);
  if (*(char *)(v0 + 23) < 0) {
    operator delete(*(void **)v0);
  }
}

void sub_100773B40()
{
  sub_1000573EC();
  if (v4 != v5) {
    uint64_t v6 = v3;
  }
  else {
    uint64_t v6 = v1;
  }
  sub_100057464(v2, v6, 4.8751e-34);
  sub_100057404((void *)&_mh_execute_header, v7, v8, "Dropping descriptor \"%{public}s\" as we couldn't find a parent characteristic", v9);
  if (*(char *)(v0 + 23) < 0) {
    operator delete(*(void **)v0);
  }
}

void sub_100773B94(unsigned __int16 a1, NSObject *a2)
{
  v2[0] = 67109120;
  v2[1] = a1;
  _os_log_error_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_ERROR, "Unable to find parent service for characteristic handle 0x%04x!", (uint8_t *)v2, 8u);
}

void sub_100773C10()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "[BTVCBonjourEndpoint] No remote UUID found, cancelling connection", v2, v3, v4, v5, v6);
}

void sub_100773C44()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "[BTVCBonjourEndpoint] No Server UUID header found in WS response", v2, v3, v4, v5, v6);
}

void sub_100773C78()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "[BTVCBonjourEndpoint] WebSocket protocol not found in connection parameters", v2, v3, v4, v5, v6);
}

void sub_100773CAC()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "[BTVCBonjourEndpoint] cancel called on nil connection", v2, v3, v4, v5, v6);
}

void sub_100773CE0()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "[BTVCBonjourEndpoint] receiveNextMessage called on nil connection", v2, v3, v4, v5, v6);
}

void sub_100773D14(int a1, NSObject *a2)
{
  v2[0] = 67109120;
  v2[1] = a1;
  _os_log_error_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_ERROR, "Failed to perform inquiry with result %{bluetooth:OI_STATUS}u", (uint8_t *)v2, 8u);
}

void sub_100773D8C()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Failed to create an outgoing classic conenction status state notification token", v2, v3, v4, v5, v6);
}

void sub_100773DC0()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Failed to create Le Connection Scan state notification token", v2, v3, v4, v5, v6);
}

void sub_100773DF4()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Failed to create a stream state notification token", v2, v3, v4, v5, v6);
}

void sub_100773E28()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Failed to create a CBPairing notification token", v2, v3, v4, v5, v6);
}

void sub_100773E5C()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Failed to create a pairing notification token", v2, v3, v4, v5, v6);
}

void sub_100773E90()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Failed to create a connection notification token", v2, v3, v4, v5, v6);
}

void sub_100773EC4()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Failed to create a power notification token", v2, v3, v4, v5, v6);
}

void sub_100773EF8()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "************** Unlock your phone, restart bluetoothd to try again", v2, v3, v4, v5, v6);
}

void sub_100773F2C()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "************** Remove the EraseAllPairedAndCachedDevice setting, and restart bluetoothd to continue", v2, v3, v4, v5, v6);
}

void sub_100773F60(int a1, NSObject *a2)
{
  v2[0] = 67109120;
  v2[1] = a1;
  _os_log_error_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_ERROR, "Error reading getScanStatsWithThreshold %{bluetooth:OI_STATUS}u", (uint8_t *)v2, 8u);
}

void sub_100773FD8(int a1, NSObject *a2)
{
  v2[0] = 67109120;
  v2[1] = a1;
  _os_log_error_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_ERROR, "Error reading readScanStatsWithThreshold %{bluetooth:OI_STATUS}u", (uint8_t *)v2, 8u);
}

void sub_100774050(int a1, int a2, os_log_t log)
{
  v3[0] = 67109376;
  v3[1] = a1;
  __int16 v4 = 1024;
  int v5 = a2;
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "Failed to locate dirty byte in SDP record - format was invalid (type = %d, size = %d)", (uint8_t *)v3, 0xEu);
}

void sub_1007740D8(os_log_t log)
{
  *(_WORD *)uint64_t v1 = 0;
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "Exceeded maximum amount of keys!", v1, 2u);
}

void sub_10077411C(uint8_t *buf, unsigned char *a2, os_log_t log)
{
  *uint64_t buf = 0;
  *a2 = 0;
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "Found invalid handle - removing associated callbacks", buf, 2u);
}

void sub_10077415C(os_log_t log)
{
  int v1 = 136446210;
  uint64_t v2 = "device != NULL";
  _os_log_fault_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_FAULT, "Assertion failed: %{public}s", (uint8_t *)&v1, 0xCu);
}

void sub_1007741E0(uint8_t *buf, void *a2, os_log_t log)
{
  *(_DWORD *)uint64_t buf = 136446210;
  *a2 = "(NULL)";
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "Had no object for the scan from %{public}s", buf, 0xCu);
}

void sub_100774230(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_100774268(os_log_t log)
{
  int v1 = 136315394;
  uint64_t v2 = "SCAN_CORE_PAGE_SCAN_TIMER_EXPIRED_EVENT";
  __int16 v3 = 2080;
  __int16 v4 = "SCAN_CORE_PAGE_SCAN_IDLE";
  _os_log_fault_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_FAULT, "Received '%s' when Scan Core Page Scan state is %s.", (uint8_t *)&v1, 0x16u);
}

void sub_100774300(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_10077436C(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_1007743D8(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_100774444()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Failed to create a nexus provider", v2, v3, v4, v5, v6);
}

void sub_100774478()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Failed to create kevent for read queue", v2, v3, v4, v5, v6);
}

void sub_1007744AC(os_log_t log)
{
  int v1 = 134217984;
  uint64_t v2 = 0;
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "AudioSkywalk read loop is configured to an invalid audio interval (%llu). Defaulting to 22000us", (uint8_t *)&v1, 0xCu);
}

void sub_100774528()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "No channelId for skywalk pipe", v2, v3, v4, v5, v6);
}

void sub_10077455C()
{
  sub_100407670();
  _os_log_debug_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_DEBUG, "%d bytes available skywalk slot %d", v1, 0xEu);
}

void sub_1007745D8()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Unable to create os_channel", v2, v3, v4, v5, v6);
}

void sub_10077460C()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Failed to alloc a nexus provider", v2, v3, v4, v5, v6);
}

void sub_100774640(unsigned __int16 a1, NSObject *a2)
{
  int v2 = 136315394;
  uint64_t v3 = "TransportWrite";
  __int16 v4 = 1024;
  int v5 = a1;
  _os_log_error_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_ERROR, "%s: can't find handler for opCode 0x%04X", (uint8_t *)&v2, 0x12u);
}

void sub_1007746D0(os_log_t log)
{
  int v1 = 136315138;
  int v2 = "TransportWrite";
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "%s: invalide buffer", (uint8_t *)&v1, 0xCu);
}

void sub_100774754()
{
  sub_10005732C();
  sub_1003CF064((void *)&_mh_execute_header, v0, v1, "BTDiscoveryMsgHandler::handleBTDiscoveryAgentCreateMsg sessionID:%llx", v2, v3, v4, v5, v6);
}

void sub_1007747BC(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_10077482C()
{
  sub_10005732C();
  sub_1003CF064((void *)&_mh_execute_header, v0, v1, "BTDiscoveryMsgHandler::handleBTDiscoveryAgentStartScanForAdvertizedDataMsg discvoveryAgentID:%llx", v2, v3, v4, v5, v6);
}

void sub_100774894()
{
  sub_10005732C();
  sub_1003CF064((void *)&_mh_execute_header, v0, v1, "BTDiscoveryMsgHandler::handleBTDiscoveryAgentStopScanMsg discvoveryAgentID:%llx", v2, v3, v4, v5, v6);
}

void sub_1007748FC()
{
  sub_10005732C();
  sub_1003CF064((void *)&_mh_execute_header, v0, v1, "BTLocalDeviceMsgHandler::handleBTLocalDeviceGetPairedDevicesMsg agent:%llx", v2, v3, v4, v5, v6);
}

void sub_100774964()
{
  sub_10005732C();
  sub_1003CF064((void *)&_mh_execute_header, v0, v1, "BTDiscoveryMsgHandler::handleBTDiscoveryAgentAddKeyMsg discvoveryAgentID:%llx", v2, v3, v4, v5, v6);
}

void sub_1007749CC()
{
  sub_10005732C();
  sub_1003CF064((void *)&_mh_execute_header, v0, v1, "BTDiscoveryMsgHandler::handleBTDiscoveryAgentRemoveKeyMsg discvoveryAgentID:%llx", v2, v3, v4, v5, v6);
}

void sub_100774A34()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Impossible to register PAN ...", v2, v3, v4, v5, v6);
}

void sub_100774A68()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to accept packet type filter request - %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_100774AD0()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to accept multicast filter request - %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_100774B38()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Failed to deregister PAN User", v2, v3, v4, v5, v6);
}

void sub_100774B6C()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Could not allocate buffer to store data.", v2, v3, v4, v5, v6);
}

void sub_100774BA0()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Error : could not add service record %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_100774C08()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "PanUserProfile Connection failed with %d!\n", v2, v3, v4, v5, v6);
}

void sub_100774C70()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "We could not accept the connection. Now What ??", v2, v3, v4, v5, v6);
}

void sub_100774CA4()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Failed to bring the link up", v2, v3, v4, v5, v6);
}

void sub_100774CD8()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Connection failed %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_100774D40()
{
  sub_1000574EC();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Could not get handsfree device from handle %d", v2, v3, v4, v5, v6);
}

void sub_100774DAC(uint64_t a1, uint64_t a2)
{
  sub_10052EAC8(a1, a2, 3.8521e-34);
  sub_1000574B8((void *)&_mh_execute_header, v2, (uint64_t)v2, "Received SCO data size %zu is less than %d bytes, drop the packet", v3);
}

void sub_100774DE8(uint64_t a1)
{
  int v2 = 134218240;
  uint64_t v3 = a1;
  sub_10052EAE4();
  sub_1000574B8((void *)&_mh_execute_header, v1, (uint64_t)v1, "SCO Data size %zu is less than offset %d bytes, drop the packet", (uint8_t *)&v2);
}

void sub_100774E60()
{
  sub_1001604AC();
  int v3 = 2;
  sub_1000574B8((void *)&_mh_execute_header, v0, v1, "Remaining SCO Data size %zu is less than %d bytes, drop the packet", v2);
}

void sub_100774ED4(uint64_t a1)
{
  int v2 = 134218240;
  uint64_t v3 = a1;
  sub_10052EAE4();
  sub_1000574B8((void *)&_mh_execute_header, v1, (uint64_t)v1, "Remaining SCO data size %zu is less than packetSize plus header %d, drop the packet", (uint8_t *)&v2);
}

void sub_100774F4C()
{
  sub_1000572DC();
  _os_log_debug_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_DEBUG, "SCO packet index overflow, drop the packet", v1, 2u);
}

void sub_100774F8C(uint64_t a1, uint64_t a2, NSObject *a3)
{
  *(_DWORD *)a1 = 134218240;
  *(void *)(a1 + 4) = a2;
  *(_WORD *)(a1 + 12) = 1024;
  *(_DWORD *)(a1 + 14) = 60;
  sub_1000574B8((void *)&_mh_execute_header, a3, (uint64_t)a3, "Received SCO data size %zu is less than required size for PLC %d bytes", (uint8_t *)a1);
}

void sub_100774FDC()
{
  sub_1000574EC();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Unable to find device state for HFP handle %d", v2, v3, v4, v5, v6);
}

void sub_100775048()
{
  sub_1000574EC();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "uplink frame unknown chunk :%u", v2, v3, v4, v5, v6);
}

void sub_1007750B4()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "uplink frame total voice chunk too large :%u", v2, v3, v4, v5, v6);
}

void sub_10077511C()
{
  sub_1000574EC();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "uplink frame sensor chunk too large :%u", v2, v3, v4, v5, v6);
}

void sub_100775188()
{
  sub_1000574EC();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Could not get handsfree device state from handle %d", v2, v3, v4, v5, v6);
}

void sub_1007751F4()
{
  sub_1000573EC();
  if (v4 != v5) {
    uint64_t v6 = v3;
  }
  else {
    uint64_t v6 = v1;
  }
  sub_100057464(v2, v6, 4.8149e-34);
  sub_100057404((void *)&_mh_execute_header, v7, v8, "Could not get handsfree device from '%s'", v9);
  if (*(char *)(v0 + 23) < 0) {
    operator delete(*(void **)v0);
  }
}

void sub_100775248()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Failed to reset audio session stats.", v2, v3, v4, v5, v6);
}

void sub_10077527C()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Enabling SCO Buffer Flush failed with %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_1007752E4()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "This device handle is already in use.", v2, v3, v4, v5, v6);
}

void sub_100775318()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Failed to send manual volume update message device is null", v2, v3, v4, v5, v6);
}

void sub_10077534C()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to send manual volume update message %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_1007753B4()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "ReadScoBuffer Failed %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_10077541C()
{
  sub_1000574EC();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Device state is NULL for handle %d but device is still being tracked!", v2, v3, v4, v5, v6);
}

void sub_100775488()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Disabling SCO Buffer Flush failed with %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_1007754F0()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "DeregisterScoDataApplication failed with %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_100775558()
{
  sub_1000574EC();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Can't find device state for handsfree handle %d", v2, v3, v4, v5, v6);
}

void sub_1007755C4()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to accept audio with result %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_10077562C()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Trying to transition to HandsfreeAoS while already transitioning", v2, v3, v4, v5, v6);
}

void sub_100775660()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "getSignalStrength failed", v2, v3, v4, v5, v6);
}

void sub_100775694()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "getRegistrationStatus failed", v2, v3, v4, v5, v6);
}

void sub_1007756C8()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "getOperatorStatus failed", v2, v3, v4, v5, v6);
}

void sub_1007756FC()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "getCurrentCalls failed", v2, v3, v4, v5, v6);
}

void sub_100775730()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Handsfree AG vendor callback registration failed with result %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_100775798()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Handsfree AG registration failed with result %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_100775800()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Hands-Free Profile initialization failed: %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_100775868()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "HandsfreeAOS deregistration failed with result %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_1007758D0()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Handsfree AG deregistration failed with result %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_100775938()
{
  sub_1000573EC();
  if (v4 != v5) {
    uint64_t v6 = v3;
  }
  else {
    uint64_t v6 = v1;
  }
  sub_100057464(v2, v6, 4.8751e-34);
  sub_100057404((void *)&_mh_execute_header, v7, v8, "Could not find valid RFCOMM channel in SDP record of device %{public}s", v9);
  if (*(char *)(v0 + 23) < 0) {
    operator delete(*(void **)v0);
  }
}

void sub_10077598C()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to connect HandsfreeAoS with result %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_1007759F4(int a1)
{
  LODWORD(v3) = 67109376;
  HIDWORD(v3) = a1;
  sub_10052EAB8();
  sub_100057498((void *)&_mh_execute_header, v1, v2, "Failed to connect handsfree profile on channel %d with result %{bluetooth:OI_STATUS}u", v3);
}

void sub_100775A64(unsigned __int16 a1)
{
  LODWORD(v3) = 67109376;
  HIDWORD(v3) = a1;
  sub_10052EAB8();
  sub_100057498((void *)&_mh_execute_header, v1, v2, "Failed to disconnect handsfree profile on handle %d with result %{bluetooth:OI_STATUS}u", v3);
}

void sub_100775AD8(unsigned __int16 a1)
{
  LODWORD(v3) = 67109376;
  HIDWORD(v3) = a1;
  sub_10052EAB8();
  sub_100057498((void *)&_mh_execute_header, v1, v2, "Failed to disconnect Handsfree AoS on handle %d with result %{bluetooth:OI_STATUS}u", v3);
}

void sub_100775B4C()
{
  sub_1000574EC();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "No device found to report handsfree disconnection result on handle %d", v2, v3, v4, v5, v6);
}

void sub_100775BB8()
{
  sub_1000574EC();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Unexpected event without a valid handle or a valid address... Event is %d", v2, v3, v4, v5, v6);
}

void sub_100775C24()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to send extended result code - %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_100775C8C(char a1)
{
  uint64_t v1 = "accept";
  if ((a1 & 1) == 0) {
    uint64_t v1 = "deny";
  }
  int v3 = 136446466;
  uint64_t v4 = v1;
  sub_10052EAE4();
  sub_1000574B8((void *)&_mh_execute_header, v2, (uint64_t)v2, "Failed to %{public}s connection with result %{bluetooth:OI_STATUS}u", (uint8_t *)&v3);
}

void sub_100775D1C()
{
  sub_1002B7074();
  sub_100057550(v1, v2, v3, 4.8752e-34);
  sub_1000574B8((void *)&_mh_execute_header, v6, v4, "Failed to connect to device %{public}s due to %{bluetooth:OI_STATUS}u", v5);
  if (*(char *)(v0 + 23) < 0) {
    operator delete(*(void **)v0);
  }
}

void sub_100775D70()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Received SLC connect complete event for unknown device", v2, v3, v4, v5, v6);
}

void sub_100775DA4()
{
  sub_1002B7074();
  sub_100057550(v1, v2, v3, 4.8752e-34);
  sub_1000574B8((void *)&_mh_execute_header, v6, v4, "Received SLC connection failure event for device %{public}s with result %{bluetooth:OI_STATUS}u", v5);
  if (*(char *)(v0 + 23) < 0) {
    operator delete(*(void **)v0);
  }
}

void sub_100775DF8(_DWORD *a1, int a2)
{
  *a1 = 136446466;
  sub_10052EAF4((uint64_t)a1, a2, (uint64_t)"NULL");
  sub_1000574B8((void *)&_mh_execute_header, v2, (uint64_t)v2, "Received handsfree disconnection event for device %{public}s with result %{bluetooth:OI_STATUS}u", v3);
}

void sub_100775E40()
{
  sub_1002B7074();
  sub_100057550(v1, v2, v3, 4.8752e-34);
  sub_1000574B8((void *)&_mh_execute_header, v6, v4, "Received handsfree disconnection event for device %{public}s with result %{bluetooth:OI_STATUS}u", v5);
  if (*(char *)(v0 + 23) < 0) {
    operator delete(*(void **)v0);
  }
}

void sub_100775E94()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "OI_HandsfreeAG_SendInput failed %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_100775EFC(uint64_t a1, NSObject *a2)
{
  int v3 = *(_DWORD *)(a1 + 8);
  int v2 = *(_DWORD *)(a1 + 12);
  v4[0] = 67109376;
  v4[1] = v2;
  __int16 v5 = 1024;
  int v6 = v3;
  _os_log_error_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_ERROR, "Received response error %{bluetooth:OI_STATUS}u while sending response %d - disconnecting immediately", (uint8_t *)v4, 0xEu);
}

void sub_100775F84(uint64_t a1, NSObject *a2)
{
  int v3 = a1;
  sub_100513D34(a1, a1);
  sub_1001604AC();
  int v6 = v3;
  sub_1000574B8((void *)&_mh_execute_header, a2, v4, "Unsupported Handsfree AoS codec ID - %s (%d)", v5);
}

void sub_100776010(os_log_t log)
{
  int v1 = 136446210;
  int v2 = "!addr.isZero()";
  _os_log_fault_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_FAULT, "Assertion failed: %{public}s", (uint8_t *)&v1, 0xCu);
}

void sub_100776094()
{
  sub_1000574EC();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Received command from handle %d before the device was connected. Looks like the device is sending commands before SLC is complete....", v2, v3, v4, v5, v6);
}

void sub_100776100(_DWORD *a1)
{
  LODWORD(v3) = 67109376;
  HIDWORD(v3) = *a1;
  sub_10052EAB8();
  sub_100057498((void *)&_mh_execute_header, v1, v2, "HandsfreeEvent processing for event %d failed with result code - %{bluetooth:OI_STATUS}u", v3);
}

void sub_100776174()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "SCO audio disconnect failed with result code - %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_1007761DC(_DWORD *a1, int a2)
{
  *a1 = 136446466;
  sub_10052EAF4((uint64_t)a1, a2, (uint64_t)"NULL");
  sub_1000574B8((void *)&_mh_execute_header, v2, (uint64_t)v2, "Received audio connection failure event for device %{public}s with result %{bluetooth:OI_STATUS}u", v3);
}

void sub_100776224()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Unable to find handsfree device", v2, v3, v4, v5, v6);
}

void sub_100776258()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Dial failed as no number was provided", v2, v3, v4, v5, v6);
}

void sub_10077628C()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to send subscriber number with result %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_1007762F4()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to send network operator with result %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_10077635C(char a1, NSObject *a2)
{
  uint64_t v2 = "disabled";
  if (a1) {
    uint64_t v2 = "enabled";
  }
  int v3 = 136446210;
  uint64_t v4 = v2;
  _os_log_error_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_ERROR, "Device state is null, not setting voice command to %{public}s", (uint8_t *)&v3, 0xCu);
}

void sub_1007763EC()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Received invalid HF indicator assigned number: %d", v2, v3, v4, v5, v6);
}

void sub_100776454()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Audio is not incoming on this device.", v2, v3, v4, v5, v6);
}

void sub_100776488(uint64_t a1, int a2)
{
  *(void *)(sub_10041E7EC(a1, a2, 1.5047e-36) + 10) = "NULL";
  sub_1000574B8((void *)&_mh_execute_header, v2, (uint64_t)v2, "Audio disconnection failed %{bluetooth:OI_STATUS}u - disconnecting device %{public}s", v3);
}

void sub_1007764D0()
{
  sub_1002B7074();
  sub_10030D0B8(v1, v2, v3, 1.5047e-36);
  sub_1000574B8((void *)&_mh_execute_header, v6, v4, "Audio disconnection failed %{bluetooth:OI_STATUS}u - disconnecting device %{public}s", v5);
  if (*(char *)(v0 + 23) < 0) {
    operator delete(*(void **)v0);
  }
}

void sub_100776524(uint64_t a1, int a2)
{
  *(void *)(sub_10041E7EC(a1, a2, 1.5047e-36) + 10) = "NULL";
  sub_1000574B8((void *)&_mh_execute_header, v2, (uint64_t)v2, "Audio Creation failed %{bluetooth:OI_STATUS}u - %{public}s", v3);
}

void sub_10077656C()
{
  sub_1002B7074();
  sub_10030D0B8(v1, v2, v3, 1.5047e-36);
  sub_1000574B8((void *)&_mh_execute_header, v6, v4, "Audio Creation failed %{bluetooth:OI_STATUS}u - %{public}s", v5);
  if (*(char *)(v0 + 23) < 0) {
    operator delete(*(void **)v0);
  }
}

void sub_1007765C0()
{
  sub_1000574EC();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Could not get bdaddr from handle %d", v2, v3, v4, v5, v6);
}

void sub_10077662C()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Failed to redial last call", v2, v3, v4, v5, v6);
}

void sub_100776660()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Memory dial index 0 is not a valid index", v2, v3, v4, v5, v6);
}

void sub_100776694()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Could not open memory dial AB", v2, v3, v4, v5, v6);
}

void sub_1007766C8()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Received invalid DTMF tone %c", v2, v3, v4, v5, v6);
}

void sub_100776730()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Ringing just stopped - ignoring answer event and informing device call is gone", v2, v3, v4, v5, v6);
}

void sub_100776764()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Ignoring answer event as there are no ringing or waiting calls", v2, v3, v4, v5, v6);
}

void sub_100776798()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Received unknown handsfree event - %d", v2, v3, v4, v5, v6);
}

void sub_100776800()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to list current calls with result %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_100776868()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Ignoring release held calls event as we have no held calls", v2, v3, v4, v5, v6);
}

void sub_10077689C()
{
  sub_1000573EC();
  if (v4 != v5) {
    uint64_t v6 = v3;
  }
  else {
    uint64_t v6 = v1;
  }
  sub_100057464(v2, v6, 4.8751e-34);
  sub_100057404((void *)&_mh_execute_header, v7, v8, "Ignoring release held calls event as we are still in call setup state \"%{public}s\"", v9);
  if (*(char *)(v0 + 23) < 0) {
    operator delete(*(void **)v0);
  }
}

void sub_1007768F0()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Ignoring release active calls event as there are no active or held calls", v2, v3, v4, v5, v6);
}

void sub_100776924()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Ignoring release active calls event as there are no outgoing calls", v2, v3, v4, v5, v6);
}

void sub_100776958()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Ignoring hold active calls event as there are no active or held calls", v2, v3, v4, v5, v6);
}

void sub_10077698C()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Ignoring hold active calls event as there are is an outgoing call in progress", v2, v3, v4, v5, v6);
}

void sub_1007769C0()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Ignoring add held call event as there are no held calls", v2, v3, v4, v5, v6);
}

void sub_1007769F4()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Call transfer event not supported", v2, v3, v4, v5, v6);
}

void sub_100776A28()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to release call - bad call index %d", v2, v3, v4, v5, v6);
}

void sub_100776A90()
{
  sub_1002B7074();
  sub_10052EA94(v1, v2, v3, 1.5047e-36);
  sub_1000574B8((void *)&_mh_execute_header, v6, v4, "Found invalid call in current calls at index %d (call: %s)", v5);
  if (*(char *)(v0 + 23) < 0) {
    operator delete(*(void **)v0);
  }
}

void sub_100776AE4()
{
  sub_1002B7074();
  sub_10052EA94(v1, v2, v3, 1.5047e-36);
  sub_1000574B8((void *)&_mh_execute_header, v6, v4, "Found invalid call in sent calls at index %d (call: %s)", v5);
  if (*(char *)(v0 + 23) < 0) {
    operator delete(*(void **)v0);
  }
}

void sub_100776B38()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to conference call - bad call index %d", v2, v3, v4, v5, v6);
}

void sub_100776BA0()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Local BT Clk read error %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_100776C08()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to send codec selection command with error %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_100776C70()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Could not get out of VC mode.", v2, v3, v4, v5, v6);
}

void sub_100776CA4()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Can't reject incoming call as there are no ringing or waiting calls", v2, v3, v4, v5, v6);
}

void sub_100776CD8()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to update call indicators with result %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_100776D40()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "OI_HandsfreeAG_SendCallWaitingWithName failed: %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_100776DA8()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "OI_HandsfreeAG_SendRingWithName failed: %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_100776E10()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "OI_DEVMGR_UnsetScoParams failed: %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_100776E78()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "OI_DEVMGR_SetScoParams failed: %{bluetooth:OI_STATUS}u -- failing back to sco defaults", v2, v3, v4, v5, v6);
}

void sub_100776EE0()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed register eSCO Data App: %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_100776F48()
{
  sub_1000574EC();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Set ignore chup to %d", v2, v3, v4, v5, v6);
}

void sub_100776FB4()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Invalid audio-device from HAL plugin", v2, v3, v4, v5, v6);
}

void sub_100776FE8()
{
  sub_1000572DC();
  _os_log_debug_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_DEBUG, "Voice data available", v1, 2u);
}

void sub_100777028()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Invalid device state to change volume", v2, v3, v4, v5, v6);
}

void sub_10077705C()
{
  sub_1000574EC();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Could not get handsfree device from handle %d", v2, v3, v4, v5, v6);
}

void sub_1007770C8()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Detected error from the plugin, HFP routing will have problems", v2, v3, v4, v5, v6);
}

void sub_1007770FC()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Can't setAudioCodec as device wasn't found", v2, v3, v4, v5, v6);
}

void sub_100777130()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Handling HAoS mix with other HFP", v2, v3, v4, v5, v6);
}

void sub_100777164()
{
  sub_10052EAB8();
  sub_100057498((void *)&_mh_execute_header, v0, v1, "Unknown sample rate selected for SCO - sampleRate:%d, stereoCodecID:%u", 67109376, v2);
}

void sub_1007771D4()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Unknown sample rate %d requested", v2, v3, v4, v5, v6);
}

void sub_10077723C()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Unknown codec id %d requested", v2, v3, v4, v5, v6);
}

void sub_1007772A4()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "initHFPFastConnectL2CAP error creating HFP RFCOMM Channel", v2, v3, v4, v5, v6);
}

void sub_1007772D8()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "composeHFPDescriptor error getting signaling L2CAP data for HandsfreeAoS, status %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_100777340()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "composeHFPDescriptor error getting signaling L2CAP data", v2, v3, v4, v5, v6);
}

void sub_100777374(uint8_t *buf, unsigned char *a2, os_log_t log)
{
  *uint64_t buf = 0;
  *a2 = 0;
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "parseHFPDescriptor L2CAP signal channel not found", buf, 2u);
}

void sub_1007773B4(uint8_t *buf, unsigned char *a2, os_log_t log)
{
  *uint64_t buf = 0;
  *a2 = 0;
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "parseHFPDescriptor L2CAP signal channel not found for HandsfreeAoS", buf, 2u);
}

void sub_1007773F4()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "setAllowsAutoRoute find HFP device failed", v2, v3, v4, v5, v6);
}

void sub_100777428()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "setAudioRouteHidden find HFP device failed", v2, v3, v4, v5, v6);
}

void sub_10077745C()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "setHijackAudioRoute unable to find HFP device", v2, v3, v4, v5, v6);
}

void sub_100777490()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "setSmartRouteMode unable to find HFP device", v2, v3, v4, v5, v6);
}

void sub_1007774C4()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "setUserSelectedDeviceType unable to find HFP device", v2, v3, v4, v5, v6);
}

void sub_1007774F8()
{
  sub_1000574EC();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Unable to find audio device for hfpHandle:%d", v2, v3, v4, v5, v6);
}

void sub_100777564(os_log_t log)
{
  v1[0] = 67109120;
  v1[1] = 2;
  _os_log_fault_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_FAULT, "Reached maximum attempts (%d) to establish HandsfreeAoS call", (uint8_t *)v1, 8u);
}

void sub_1007775E4(uint64_t a1, void *a2)
{
  uint64_t v4 = qword_100A19E70;
  os_log_type_enabled((os_log_t)qword_100A19E70, OS_LOG_TYPE_FAULT);
  int v5 = 134217984;
  uint64_t v6 = 24;
  _os_log_fault_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_FAULT, "Could not allocate %lu bytes", (uint8_t *)&v5, 0xCu);
  *a2 = *(void *)(*(void *)a1 + 32);
}

void sub_1007776A0()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to send call status with result %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_100777708()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to update call indicators with result %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_100777770()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to send call setup status with result %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_1007777D8()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "No UMUserManager available, so disabling multi user mode", v2, v3, v4, v5, v6);
}

void sub_10077780C()
{
  sub_10027515C();
  sub_1000574F8((void *)&_mh_execute_header, v0, v1, "[Inquiry] Unable to fetch cloud device: %@, Error: %@");
}

void sub_100777874()
{
  sub_1000572DC();
  _os_log_fault_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_FAULT, "Couldn't retrieve public local address from device tree!", v1, 2u);
}

void sub_1007778B4()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed registration for MKB first unlock notification with error : %u", v2, v3, v4, v5, v6);
}

void sub_10077791C(uint64_t a1, uint8_t *buf, os_log_t log)
{
  *(_DWORD *)uint64_t buf = 136315138;
  *(void *)(buf + 4) = a1;
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "Failed to read local device hostname - using default \"%s\"", buf, 0xCu);
}

void sub_100777964()
{
  sub_1000572E8();
  _os_log_fault_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_FAULT, "Failed to generate DHK with result %{bluetooth:OI_STATUS}u", v1, 8u);
}

void sub_1007779D8(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_100777A50()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Cloudpairing got invalid args", v2, v3, v4, v5, v6);
}

void sub_100777A84()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Error generating pairing ID, cannot cloud pair right now", v2, v3, v4, v5, v6);
}

void sub_100777AB8()
{
  sub_10005732C();
  sub_1000572F4((void *)&_mh_execute_header, v0, v1, "Invalid RemoveCloudPairedDevice value: %@", v2, v3, v4, v5, v6);
}

void sub_100777B20()
{
  sub_10005732C();
  sub_1000572F4((void *)&_mh_execute_header, v0, v1, "Invalid Device UUID value: %@", v2, v3, v4, v5, v6);
}

void sub_100777B88(uint64_t a1, NSObject *a2)
{
  int v2 = 138412546;
  uint64_t v3 = a1;
  __int16 v4 = 2112;
  uint64_t v5 = &off_1009E0F20;
  _os_log_fault_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_FAULT, "XPC Version Check failure, received version: %@, current version: %@", (uint8_t *)&v2, 0x16u);
}

void sub_100777C14(unsigned char *a1, unsigned char *a2)
{
  sub_10026C69C(a1, a2);
  sub_1000573D0((void *)&_mh_execute_header, v2, v3, "DeviceSupportInformationRecordsUpdated failed to convert address", v4);
}

void sub_100777C40(unsigned char *a1, unsigned char *a2)
{
  sub_10026C69C(a1, a2);
  sub_1000573D0((void *)&_mh_execute_header, v2, v3, "DeviceSupportInformationRecordsUpdated Unknown device", v4);
}

void sub_100777C6C(unsigned char *a1, unsigned char *a2)
{
  sub_10026C69C(a1, a2);
  sub_1000573D0((void *)&_mh_execute_header, v2, v3, "[MP] Cloud: Received invalid device address", v4);
}

void sub_100777C98(uint64_t a1, uint8_t *buf, os_log_t log)
{
  *(_DWORD *)uint64_t buf = 136315138;
  *(void *)(buf + 4) = a1;
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "Cloudpairing got invalid type: %s", buf, 0xCu);
}

void sub_100777CE0()
{
  sub_10027515C();
  sub_1000574F8((void *)&_mh_execute_header, v0, v1, "DeviceSupportInformationRecordsUpdated error retrieving cloudDevice %@: %@");
}

void sub_100777D48()
{
  sub_10005732C();
  __int16 v3 = 2160;
  uint64_t v4 = 1752392040;
  __int16 v5 = 2113;
  uint64_t v6 = v0;
  _os_log_error_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_ERROR, "CloudPairing: No XPC connection to send message: %@ - %{private, mask.hash}@", v2, 0x20u);
}

void sub_100777DE0()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Failed Registering cloudkit.xpc service", v2, v3, v4, v5, v6);
}

void sub_100777E14(uint64_t a1, uint64_t a2, uint64_t a3)
{
  sub_10053FD98(a1, a2, a3, 7.2226e-34);
  sub_10053FDC4((void *)&_mh_execute_header, "IDS device %{private, mask.hash}s is not associated with paired local device \"%@\"", v3, v4);
}

void sub_100777E50(uint64_t a1, uint64_t a2, uint64_t a3)
{
  sub_10053FD98(a1, a2, a3, 7.2226e-34);
  sub_10053FDC4((void *)&_mh_execute_header, "IDS device %{private, mask.hash}s is associated with unpaired local device \"%@\"", v3, v4);
}

void sub_100777E8C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  sub_10053FD98(a1, a2, a3, 7.2226e-34);
  sub_10053FDC4((void *)&_mh_execute_header, "IDS device %{private, mask.hash}s is associated with unknown local device \"%@\"", v3, v4);
}

void sub_100777EC8()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "MUC: failed to get IRK for RSA", v2, v3, v4, v5, v6);
}

void sub_100777EFC()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to generate CSRK with result %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_100777F64()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to generate LTK with result %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_100777FCC()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to generate DIV with result %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_100778034(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_1007780A4()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Key generation failed", v2, v3, v4, v5, v6);
}

void sub_1007780D8()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Keys not available or generated", v2, v3, v4, v5, v6);
}

void sub_10077810C()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "MUC: Could not generated IRK : %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_100778174()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "MUC - RSA is nil", v2, v3, v4, v5, v6);
}

void sub_1007781A8()
{
  sub_10005732C();
  sub_1000572F4((void *)&_mh_execute_header, v0, v1, "MUC - NO IRK for RSA: %@", v2, v3, v4, v5, v6);
}

void sub_100778210()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "MUC - multiple adv instances are not initialized yet", v2, v3, v4, v5, v6);
}

void sub_100778244()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Received invalid SmartChargeStatusHasChangedFromNotification", v2, v3, v4, v5, v6);
}

void sub_100778278()
{
  sub_10005732C();
  sub_1000572F4((void *)&_mh_execute_header, v0, v1, "Unable to find a Device matching addr format %@", v2, v3, v4, v5, v6);
}

void sub_1007782E0()
{
  sub_10005732C();
  sub_1000572F4((void *)&_mh_execute_header, v0, v1, "Unknown PowerUISmartChargingState %lu update from cloud", v2, v3, v4, v5, v6);
}

void sub_100778348()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Biome GATTSession not available", v2, v3, v4, v5, v6);
}

void sub_10077837C()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Biome DeviceBluetoothPowerEnabled not available", v2, v3, v4, v5, v6);
}

void sub_1007783B0()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "RegulatoryDomain RDEstimate not available", v2, v3, v4, v5, v6);
}

void sub_1007783E4()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "AppProtection Framework not available", v2, v3, v4, v5, v6);
}

void sub_100778418(uint64_t a1, uint64_t a2, os_log_t log)
{
  int v3 = 138412546;
  uint64_t v4 = a1;
  __int16 v5 = 2112;
  uint64_t v6 = a2;
  _os_log_debug_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_DEBUG, "[BTVCLinkScanner] Update payload filter data to %@, mask %@\n", (uint8_t *)&v3, 0x16u);
}

void sub_1007784A0()
{
  sub_1000572DC();
  sub_1002E4C44((void *)&_mh_execute_header, v0, v1, "[BTVCLinkScanner] Invalidated\n", v2, v3, v4, v5, v6);
}

void sub_1007784D4()
{
  sub_1000572DC();
  sub_1002E4C44((void *)&_mh_execute_header, v0, v1, "[BTVCLinkScanner] Invalidating\n", v2, v3, v4, v5, v6);
}

void sub_100778508()
{
  sub_1000572DC();
  sub_1002E4C44((void *)&_mh_execute_header, v0, v1, "[BTVCLinkScanner] Starting scan, need stop first\n", v2, v3, v4, v5, v6);
}

void sub_10077853C()
{
  sub_1000572DC();
  sub_1002E4C44((void *)&_mh_execute_header, v0, v1, "[BTVCLinkScanner] Starting scan\n", v2, v3, v4, v5, v6);
}

void sub_100778570()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "HID host registration failed - result was %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_1007785D8()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "HID host deregistration failed - result was %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_100778640(uint8_t *buf, int a2, os_log_t log)
{
  *(_DWORD *)uint64_t buf = 136446466;
  *(void *)(buf + 4) = "NULL";
  *((_WORD *)buf + 6) = 1024;
  *(_DWORD *)(buf + 14) = a2;
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "Unplugging virtual cable to device %{public}s failed with status %d", buf, 0x12u);
}

void sub_10077869C()
{
  sub_1002B7074();
  sub_100057550(v1, v2, v3, 4.8752e-34);
  sub_10041E7D0((void *)&_mh_execute_header, "Unplugging virtual cable to device %{public}s failed with status %d", v4, v5);
  if (*(char *)(v0 + 23) < 0) {
    operator delete(*(void **)v0);
  }
}

void sub_1007786EC(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_100778764()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to connect - result was %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_1007787CC()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to disconnect - result was %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_100778834()
{
  sub_1002CC754();
  sub_1000574EC();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Did not find session for handle 0x%x", v2, v3, v4, v5, v6);
}

void sub_10077889C()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Sent queue failed with status %d", v2, v3, v4, v5, v6);
}

void sub_100778904()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Set report failed due to hidperf is running", v2, v3, v4, v5, v6);
}

void sub_100778938()
{
  sub_1000574EC();
  __int16 v3 = 2082;
  uint64_t v4 = v0;
  _os_log_error_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_ERROR, "Received SUSPEND for untracked handle %d with reason %{public}s, Returning.", v2, 0x12u);
}

void sub_1007789E0()
{
  sub_1002CC754();
  sub_1000574EC();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Device hasn't started can not suspend for handle 0x%x", v2, v3, v4, v5, v6);
}

void sub_100778A48()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to suspend device with status %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_100778AB0()
{
  sub_1000574EC();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Received EXIT_SUSPEND for untracked handle %d. Returning.", v2, v3, v4, v5, v6);
}

void sub_100778B1C()
{
  sub_1002CC754();
  sub_1000574EC();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Device hasn't started can not exit suspend for handle 0x%x", v2, v3, v4, v5, v6);
}

void sub_100778B84()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to unsuspend device with status %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_100778BEC()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "System can sleep but screen is still on, don't suspend HID", v2, v3, v4, v5, v6);
}

void sub_100778C20()
{
  sub_10054DCE4();
  sub_100057498((void *)&_mh_execute_header, v0, v1, "Sending pending control channel operation 0x%x failed with %d", v2, v3);
}

void sub_100778C8C()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to set HID protocol with result %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_100778CF4(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_100778D6C()
{
  sub_1000574EC();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "HID connection on handle 0x%x does not map to a valid device", v2, v3, v4, v5, v6);
}

void sub_100778DD8()
{
  sub_1000573EC();
  if (v6 != v7) {
    uint64_t v8 = v5;
  }
  else {
    uint64_t v8 = v1;
  }
  *(_DWORD *)uint64_t v2 = 136446210;
  *(void *)(v2 + 4) = v8;
  sub_100057404((void *)&_mh_execute_header, v2, v3, "Handshake failed to complete on device %{public}s, disconnecting", v4);
  if (*(char *)(v0 + 23) < 0) {
    operator delete(*(void **)v0);
  }
}

uint64_t sub_100778E30(uint64_t *a1)
{
  uint64_t result = *a1;
  if (result) {
    operator delete[]();
  }
  return result;
}

void sub_100778E60(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_100778ED8()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to change connection packet type with %d", v2, v3, v4, v5, v6);
}

void sub_100778F40()
{
  sub_10054DCE4();
  sub_100057498((void *)&_mh_execute_header, v0, v1, "Failed to enable HID Latency Statistics for connection handle 0x%02x with result %d", v2, v3);
}

void sub_100778FAC()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Session is no longer valid, no input device to start", v2, v3, v4, v5, v6);
}

void sub_100778FE0()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Force sniff rate failed with status %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_100779048()
{
  sub_1002CC754();
  sub_1000574EC();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to disable HID Latency Statistics for connection handle 0x%02x", v2, v3, v4, v5, v6);
}

void sub_1007790B0()
{
  sub_1000573EC();
  if (v6 != v7) {
    uint64_t v8 = v5;
  }
  else {
    uint64_t v8 = v1;
  }
  *(_DWORD *)uint64_t v2 = 136446210;
  *(void *)(v2 + 4) = v8;
  sub_100057404((void *)&_mh_execute_header, v2, v3, "Failed to lookup HID Host handle for device %{public}s", v4);
  if (*(char *)(v0 + 23) < 0) {
    operator delete(*(void **)v0);
  }
}

void sub_100779108(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_10077917C()
{
  sub_1002B7074();
  sub_100057550(v1, v2, v3, 4.8752e-34);
  sub_10041E7D0((void *)&_mh_execute_header, "SDP failed to complete on device %{public}s with result %d", v4, v5);
  if (*(char *)(v0 + 23) < 0) {
    operator delete(*(void **)v0);
  }
}

void sub_1007791CC()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to set protocol with error %{bluetooth:OI_STATUS}u - disconnecting", v2, v3, v4, v5, v6);
}

void sub_100779234()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "HID device handshake was unsuccessful", v2, v3, v4, v5, v6);
}

void sub_100779268()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "HID handshake failed with error %d", v2, v3, v4, v5, v6);
}

void sub_1007792D0()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "modeChangedInd -- handle without session", v2, v3, v4, v5, v6);
}

void sub_100779304()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Mode check timer fired, session is no longer valid", v2, v3, v4, v5, v6);
}

void sub_100779338()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Low Latency Controller device is NULL", v2, v3, v4, v5, v6);
}

void sub_10077936C()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Handle missing, device was cleaned up", v2, v3, v4, v5, v6);
}

void sub_1007793A0()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Get report failed with status %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_100779408()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Get report queue failed due to zero session count", v2, v3, v4, v5, v6);
}

void sub_10077943C()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Get report channel busy - report queued", v2, v3, v4, v5, v6);
}

void sub_100779470()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Set report failed with status %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_1007794D8()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Report queue failed due to zero session count", v2, v3, v4, v5, v6);
}

void sub_10077950C()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Set report channel busy - report queued", v2, v3, v4, v5, v6);
}

void sub_100779540()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Send Hid Control failed with status %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_1007795A8(uint64_t a1, NSObject *a2)
{
  int v2 = 138412290;
  uint64_t v3 = a1;
  _os_log_error_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_ERROR, "Failed to exclude advertisement database from backup with error: %@", (uint8_t *)&v2, 0xCu);
}

void sub_100779620(uint64_t a1, NSObject *a2)
{
  int v2 = 138412290;
  uint64_t v3 = a1;
  _os_log_error_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_ERROR, "Failed to create directory for advertisement database with error: %@", (uint8_t *)&v2, 0xCu);
}

void sub_100779698()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "failed to purge database clone", v2, v3, v4, v5, v6);
}

void sub_1007796CC()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "xpc activity triggered database clone purge failed", v2, v3, v4, v5, v6);
}

void sub_100779700()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "xpc activity triggered database purge failed", v2, v3, v4, v5, v6);
}

void sub_100779734()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "failed to clone database", v2, v3, v4, v5, v6);
}

void sub_100779768()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "failed to create directory for database clone", v2, v3, v4, v5, v6);
}

void sub_10077979C(int a1, NSObject *a2)
{
  v2[0] = 67109120;
  v2[1] = a1;
  _os_log_error_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_ERROR, "rdar://problem/66432832 attempting to cache descriptorSize: %u", (uint8_t *)v2, 8u);
}

void sub_100779814(unsigned char *a1, unsigned char *a2)
{
  sub_10026C69C(a1, a2);
  sub_1000573D0((void *)&_mh_execute_header, v2, v3, "Invalid format", v4);
}

void sub_100779840(unsigned char *a1, unsigned char *a2)
{
  sub_10026C69C(a1, a2);
  sub_1000573D0((void *)&_mh_execute_header, v2, v3, "This is not a report descriptor", v4);
}

void sub_10077986C()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "reading root keys failed", v2, v3, v4, v5, v6);
}

void sub_1007798A0(void *a1, char a2, NSObject *a3)
{
  uint64_t v3 = (void *)*a1;
  if ((a2 & 1) == 0) {
    uint64_t v3 = a1;
  }
  int v4 = 136446210;
  uint64_t v5 = v3;
  sub_100057404((void *)&_mh_execute_header, a2, a3, "Session attach for \"%{public}s\" failed", (uint8_t *)&v4);
}

void sub_10077991C()
{
  sub_1000572DC();
  _os_log_fault_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_FAULT, "Session attached twice", v1, 2u);
}

void sub_10077995C(uint64_t a1, NSObject *a2)
{
  int v2 = 136446210;
  uint64_t v3 = a1;
  _os_log_error_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_ERROR, "Ran out of handles for session \"%{public}s\"!", (uint8_t *)&v2, 0xCu);
}

void sub_1007799D4()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "SessionManager not initialized!", v2, v3, v4, v5, v6);
}

void sub_100779A08()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Invalid session handle", v2, v3, v4, v5, v6);
}

void sub_100779A3C()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "No session found", v2, v3, v4, v5, v6);
}

void sub_100779A70(uint8_t *buf, NSObject *a2)
{
  *(_DWORD *)uint64_t buf = 136446210;
  *(void *)(buf + 4) = "(NULL)";
  _os_log_error_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_ERROR, "Ran out of handles for session %{public}s!", buf, 0xCu);
}

void sub_100779ABC()
{
  sub_1000573EC();
  if (v4 != v5) {
    uint64_t v6 = v3;
  }
  else {
    uint64_t v6 = v1;
  }
  sub_100057464(v2, v6, 4.8751e-34);
  sub_100057404((void *)&_mh_execute_header, v7, v8, "Ran out of handles for session %{public}s!", v9);
  if (*(char *)(v0 + 23) < 0) {
    operator delete(*(void **)v0);
  }
}

void sub_100779B10()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Handle was NULL", v2, v3, v4, v5, v6);
}

void sub_100779B44(uint64_t a1, NSObject *a2)
{
  int v2 = 134218240;
  uint64_t v3 = a1;
  __int16 v4 = 2048;
  uint64_t v5 = a1;
  _os_log_error_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_ERROR, "Trying to add BTHandle : %p which is same as our LocalDevice handle %p", (uint8_t *)&v2, 0x16u);
}

void sub_100779BC8()
{
  sub_1000573EC();
  if (v4 != v5) {
    uint64_t v6 = v3;
  }
  else {
    uint64_t v6 = v1;
  }
  sub_100057464(v2, v6, 4.8751e-34);
  sub_100057404((void *)&_mh_execute_header, v7, v8, "Session \"%{public}s\" already exists in SessionProcessIdentifierMap", v9);
  if (*(char *)(v0 + 23) < 0) {
    operator delete(*(void **)v0);
  }
}

void sub_100779C1C()
{
  sub_1000573EC();
  if (v4 != v5) {
    uint64_t v6 = v3;
  }
  else {
    uint64_t v6 = v1;
  }
  sub_100057464(v2, v6, 4.8751e-34);
  sub_100057404((void *)&_mh_execute_header, v7, v8, "Session \"%{public}s\" is not present in SessionProcessIdentifierMap", v9);
  if (*(char *)(v0 + 23) < 0) {
    operator delete(*(void **)v0);
  }
}

void sub_100779C70()
{
  sub_1000573EC();
  if (v4 != v5) {
    uint64_t v6 = v3;
  }
  else {
    uint64_t v6 = v1;
  }
  sub_100057464(v2, v6, 4.8751e-34);
  sub_100057404((void *)&_mh_execute_header, v7, v8, "Session \"%{public}s\" already exists in SessionManagedConfigOverrideMap", v9);
  if (*(char *)(v0 + 23) < 0) {
    operator delete(*(void **)v0);
  }
}

void sub_100779CC4()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "No mask saved for handle", v2, v3, v4, v5, v6);
}

void sub_100779CF8()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Stack not started, cannot register for role change callbacks", v2, v3, v4, v5, v6);
}

void sub_100779D2C()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Device orientation unknown", v2, v3, v4, v5, v6);
}

void sub_100779D60()
{
  sub_1000572DC();
  _os_log_debug_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_DEBUG, "Link Adaptive AAC Configs already loaded", v1, 2u);
}

void sub_100779DA0()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Error in Registering for legacyModeChangeEvent: %d", v2, v3, v4, v5, v6);
}

void sub_100779E08()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Error in Unregistering for legacyModeChangeEvent: %d", v2, v3, v4, v5, v6);
}

void sub_100779E70()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Invalid AAC Config", v2, v3, v4, v5, v6);
}

void sub_100779EA4()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Invalid Device in AudioLinkManager Devices", v2, v3, v4, v5, v6);
}

void sub_100779ED8()
{
  sub_1000574EC();
  LOWORD(v3) = 2048;
  *(void *)((char *)&v3 + 2) = v0;
  sub_100057518((void *)&_mh_execute_header, v0, v1, "Fail to load Bitrate Configs, out of range (%u of %lu).", v2, (void)v3);
}

void sub_100779F50()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Failed to configure interlaced page scan", v2, v3, v4, v5, v6);
}

void sub_100779F84()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Failed to configure interlaced inquiry scan", v2, v3, v4, v5, v6);
}

void sub_100779FB8()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Stack hasn't started -- not starting HFP metrics", v2, v3, v4, v5, v6);
}

void sub_100779FEC()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Please file a radar we are failing to submit metric for HFP audio streaming", v2, v3, v4, v5, v6);
}

void sub_10077A020(uint64_t a1, NSObject *a2)
{
  sub_100476120(a1, (uint64_t)__p);
  if (v6 >= 0) {
    uint64_t v4 = __p;
  }
  else {
    uint64_t v4 = (void **)__p[0];
  }
  int v7 = 136315138;
  os_log_t v8 = v4;
  sub_100057438((void *)&_mh_execute_header, a2, v3, "Device %s, does not exist in AudioLinkManagerDevices something went wrong", (uint8_t *)&v7);
  if (v6 < 0) {
    operator delete(__p[0]);
  }
}

void sub_10077A0D0()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "deleting the fA2DPAoSInfoMetric", v2, v3, v4, v5, v6);
}

void sub_10077A104()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "deleting the fA2DPPacketFlushInfoMetric", v2, v3, v4, v5, v6);
}

void sub_10077A138()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Please file a radar we are failing to submit metric for A2DP audio streaming", v2, v3, v4, v5, v6);
}

void sub_10077A16C(unint64_t *a1, uint64_t a2, NSObject *a3)
{
  sub_10056C53C(a2, *a1);
  sub_1000574EC();
  _os_log_error_impl((void *)&_mh_execute_header, a3, OS_LOG_TYPE_ERROR, "Low Latency Game: redundantant jitter change, mode: %d", v4, 8u);
}

void sub_10077A204(uint64_t a1, NSObject *a2, uint64_t a3)
{
  int v3 = 138412290;
  uint64_t v4 = a1;
  sub_100057438((void *)&_mh_execute_header, a2, a3, "Failed to create filepath at %@ to capture tailspin", (uint8_t *)&v3);
}

void sub_10077A274(void *a1, uint64_t a2, NSObject *a3)
{
  *(_DWORD *)a2 = 138412290;
  *(void *)(a2 + 4) = a1;
  sub_100057438((void *)&_mh_execute_header, a3, (uint64_t)a3, "Failed to open file descriptor to capture tailspin: %@", (uint8_t *)a2);
}

void sub_10077A2C4(uint64_t a1, NSObject *a2, uint64_t a3)
{
  int v3 = 138412290;
  uint64_t v4 = a1;
  sub_100057438((void *)&_mh_execute_header, a2, a3, "Trying to save tailspin %@", (uint8_t *)&v3);
}

void sub_10077A334()
{
  sub_100579750();
  sub_100057518((void *)&_mh_execute_header, v0, v1, "AudioSkywalkReadLoop overwait %llu ms occurred on device with handle %d", v2, v3);
}

void sub_10077A3A8()
{
  sub_1000574EC();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Report Audio Creation fail %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_10077A414()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Audio Timesync: Timesync unregister failed ", v2, v3, v4, v5, v6);
}

void sub_10077A448(uint64_t *a1, NSObject *a2, uint64_t a3)
{
  uint64_t v3 = *a1;
  int v4 = 134217984;
  uint64_t v5 = v3;
  sub_100057438((void *)&_mh_execute_header, a2, a3, "Audio Timesync: Remote device no longer available: %llx ", (uint8_t *)&v4);
}

void sub_10077A4BC(uint8_t *buf, unsigned char *a2, os_log_t log)
{
  *uint64_t buf = 0;
  *a2 = 0;
  _os_log_debug_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_DEBUG, "A2DP Link Adaptive invalid", buf, 2u);
}

void sub_10077A4FC()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to enable beamforming VSE logging with error %d", v2, v3, v4, v5, v6);
}

void sub_10077A564()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to disable beamforming VSE logging with error %d", v2, v3, v4, v5, v6);
}

void sub_10077A5CC()
{
  sub_100579750();
  sub_100057518((void *)&_mh_execute_header, v0, v1, "Failed to %s Global MRC control with error %d", v2, v3);
}

void sub_10077A650()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to enable beamforming MRC control VSE logging with error %d", v2, v3, v4, v5, v6);
}

void sub_10077A6B8()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to disable beamforming MRC control VSE logging with error %d", v2, v3, v4, v5, v6);
}

void sub_10077A720()
{
  sub_1000574EC();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to set default diversity antenna to %d", v2, v3, v4, v5, v6);
}

void sub_10077A78C()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to set diversity follow mode to %d", v2, v3, v4, v5, v6);
}

void sub_10077A7F4()
{
  sub_1000575AC();
  sub_100057498((void *)&_mh_execute_header, v0, v1, "Failed to set diversity mode %d on handle %d", v2, v3);
}

void sub_10077A85C()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to set diversity antenna pair to (0, %d)", v2, v3, v4, v5, v6);
}

void sub_10077A8C4()
{
  sub_1000574EC();
  LOWORD(v3) = 1024;
  HIWORD(v3) = v0;
  sub_100057498((void *)&_mh_execute_header, v0, v1, "Device orientation set to %d, but failed to set diversity antenna to %d", v2, v3);
}

void sub_10077A93C()
{
  sub_1000575AC();
  sub_100057498((void *)&_mh_execute_header, v0, v1, "Failed to set diversity log mode %d on handle %d", v2, v3);
}

void sub_10077A9A4()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "AudioLinkManager Cannot set Spatial Mode with empty Bundle ID", v2, v3, v4, v5, v6);
}

void sub_10077A9D8()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "BundleID does not exist, return default", v2, v3, v4, v5, v6);
}

void sub_10077AA0C()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "BundleID exist, pair dict invalid", v2, v3, v4, v5, v6);
}

void sub_10077AA40(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_10077AAB8(uint64_t a1, uint64_t a2)
{
  id v4 = sub_100584B94(a1, a2);
  *uint64_t v3 = 138412290;
  void *v2 = v4;
  sub_1000F24C4((void *)&_mh_execute_header, v5, v6, "Link state is stalled for device \"%@\"");
}

void sub_10077AB0C(uint64_t a1, uint64_t a2)
{
  id v4 = sub_100584B94(a1, a2);
  *uint64_t v3 = 138412290;
  void *v2 = v4;
  sub_1000F24C4((void *)&_mh_execute_header, v5, v6, "Protocol state is stalled for device \"%@\"");
}

void sub_10077AB60(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_10077ABD8(int a1, NSObject *a2)
{
  v2[0] = 67109120;
  v2[1] = a1;
  _os_log_error_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_ERROR, "LEA Start Stream failed %{bluetooth:OI_STATUS}u", (uint8_t *)v2, 8u);
}

void sub_10077AC50(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_10077ACC8(id *a1, NSObject *a2)
{
  id v3 = *a1;
  int v4 = 141558275;
  uint64_t v5 = 1752392040;
  __int16 v6 = 2113;
  id v7 = v3;
  _os_log_error_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_ERROR, "MFi authentication timed out for device %{private, mask.hash}@", (uint8_t *)&v4, 0x16u);
}

void sub_10077AD78()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "No codec found from the table", v2, v3, v4, v5, v6);
}

void sub_10077ADAC()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Detected error from the plugin, LEA routing will have problems", v2, v3, v4, v5, v6);
}

void sub_10077ADE0(unsigned __int8 a1, unsigned __int16 a2, os_log_t log)
{
  v3[0] = 67109376;
  v3[1] = a1;
  __int16 v4 = 1024;
  int v5 = a2;
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "Sending 'error (%u/%u)'", (uint8_t *)v3, 0xEu);
}

void sub_10077AE70()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "No LEA Audio context", v2, v3, v4, v5, v6);
}

void sub_10077AEA4()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "NO receive buffer", v2, v3, v4, v5, v6);
}

void sub_10077AED8(uint64_t a1, NSObject *a2)
{
  int v2 = 134217984;
  uint64_t v3 = a1;
  _os_log_debug_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_DEBUG, "LEA RX Audio: %lubytes received", (uint8_t *)&v2, 0xCu);
}

void sub_10077AF50(uint64_t a1, NSObject *a2)
{
  int v2 = 134217984;
  uint64_t v3 = a1;
  _os_log_error_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_ERROR, "Invalid audio playload of size %lu received, Trigger PLC", (uint8_t *)&v2, 0xCu);
}

void sub_10077AFC8()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Invalid incoming audio buffer", v2, v3, v4, v5, v6);
}

void sub_10077AFFC(id *a1, NSObject *a2)
{
  id v3 = *a1;
  int v4 = 138412290;
  id v5 = v3;
  _os_log_error_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_ERROR, "Device \"%@\" supports neither output nor input", (uint8_t *)&v4, 0xCu);
}

void sub_10077B098()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Could not determine LEA max packet size", v2, v3, v4, v5, v6);
}

void sub_10077B0CC()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Capabilities mismatch", v2, v3, v4, v5, v6);
}

void sub_10077B100()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Ignoring MFi Auth for default writes", v2, v3, v4, v5, v6);
}

void sub_10077B134()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Too many LEA sessions", v2, v3, v4, v5, v6);
}

void sub_10077B168(uint64_t a1, NSObject *a2)
{
  int v2 = *(unsigned __int16 *)(a1 + 484);
  int v3 = *(unsigned __int16 *)(a1 + 530);
  int v4 = *(_DWORD *)(a1 + 520);
  int v5 = *(_DWORD *)(a1 + 488);
  int v6 = *(_DWORD *)(a1 + 492);
  int v7 = *(_DWORD *)(a1 + 524);
  int v8 = *(_DWORD *)(a1 + 496);
  int v9 = *(_DWORD *)(a1 + 500);
  int v10 = *(_DWORD *)(a1 + 508);
  v11[0] = 67111168;
  v11[1] = v2;
  __int16 v12 = 1024;
  int v13 = v3;
  __int16 v14 = 1024;
  int v15 = v4;
  __int16 v16 = 1024;
  int v17 = v5;
  __int16 v18 = 1024;
  int v19 = v6;
  __int16 v20 = 1024;
  int v21 = v7;
  __int16 v22 = 1024;
  int v23 = v8;
  __int16 v24 = 1024;
  int v25 = v9;
  __int16 v26 = 1024;
  int v27 = v10;
  _os_log_debug_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_DEBUG, "handle(0x%2X):event(%d), TxTotal(%d), TxR(%u), TxF(%u), RxTotal(%d), RxE(%u), RxM(%u), rssi(%d)", (uint8_t *)v11, 0x38u);
}

void sub_10077B248(uint64_t a1, NSObject *a2, void *a3)
{
  int v4 = *(unsigned __int16 *)(a1 + 464);
  int v5 = *(unsigned __int16 *)(a1 + 528);
  int v6 = *(_DWORD *)(a1 + 512);
  int v7 = *(_DWORD *)(a1 + 468);
  int v8 = *(_DWORD *)(a1 + 472);
  int v9 = *(_DWORD *)(a1 + 516);
  int v10 = *(_DWORD *)(a1 + 476);
  int v11 = *(_DWORD *)(a1 + 480);
  int v12 = *(_DWORD *)(a1 + 504);
  v13[0] = 67111168;
  v13[1] = v4;
  __int16 v14 = 1024;
  int v15 = v5;
  __int16 v16 = 1024;
  int v17 = v6;
  __int16 v18 = 1024;
  int v19 = v7;
  __int16 v20 = 1024;
  int v21 = v8;
  __int16 v22 = 1024;
  int v23 = v9;
  __int16 v24 = 1024;
  int v25 = v10;
  __int16 v26 = 1024;
  int v27 = v11;
  __int16 v28 = 1024;
  int v29 = v12;
  _os_log_debug_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_DEBUG, "handle(0x%2X):event(%d), TxTotal(%d), TxR(%u), TxF(%u), RxTotal(%d), RxE(%u), RxM(%u), rssi(%d)", (uint8_t *)v13, 0x38u);
  *a3 = qword_100A1A008;
}

void sub_10077B344()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Ignoring LEA Easy Pairing due to feature bit", v2, v3, v4, v5, v6);
}

void sub_10077B378(void *a1, char *a2, uint8_t *buf, os_log_t log)
{
  if (a2[23] >= 0) {
    uint8_t v6 = a2;
  }
  else {
    uint8_t v6 = *(char **)a2;
  }
  *(_DWORD *)uint64_t buf = 138543618;
  *(void *)(buf + 4) = a1;
  *((_WORD *)buf + 6) = 2080;
  *(void *)(buf + 14) = v6;
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "Magnet link disconnect from \"%{public}@\" does not match connected magnet \"%s\"", buf, 0x16u);
  if (a2[23] < 0) {
    operator delete(*(void **)a2);
  }
}

void sub_10077B408(_xpc_connection_s *a1, NSObject *a2)
{
  v3[0] = 67109120;
  v3[1] = xpc_connection_get_pid(a1);
  _os_log_error_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_ERROR, "Received connection to BTAudio.xpc from unknown client pid %d, ignoring", (uint8_t *)v3, 8u);
}

void sub_10077B498(uint64_t a1, NSObject *a2)
{
  int v2 = 136446210;
  uint64_t v3 = a1;
  _os_log_error_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_ERROR, "Unexpected error: %{public}s", (uint8_t *)&v2, 0xCu);
}

void sub_10077B510(uint64_t a1, NSObject *a2)
{
  int v2 = 136446210;
  uint64_t v3 = a1;
  _os_log_error_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_ERROR, "XPC server connection error: %{public}s", (uint8_t *)&v2, 0xCu);
}

void sub_10077B588(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_10077B600(uint8_t *a1, void *a2, NSObject *a3)
{
  *(_DWORD *)a1 = 136446210;
  *a2 = "sample2Index < fCodec->bytesPerFrame";
  sub_1002C5578((void *)&_mh_execute_header, a3, (uint64_t)a3, "Assertion failed: %{public}s", a1);
}

void sub_10077B648(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_10077B6C0()
{
  sub_1000572DC();
  sub_10030D118((void *)&_mh_execute_header, v0, v1, "AudioBuffer wasn't flushed", v2, v3, v4, v5, v6);
}

void sub_10077B6F4(int a1, NSObject *a2)
{
  v2[0] = 67109120;
  v2[1] = a1;
  _os_log_error_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_ERROR, "Insufficient Buffer Length: %d", (uint8_t *)v2, 8u);
}

void sub_10077B76C(uint64_t *a1, NSObject *a2)
{
  uint64_t v2 = *a1;
  int v3 = 134217984;
  uint64_t v4 = v2;
  _os_log_debug_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_DEBUG, "Get %zubytes of audio data", (uint8_t *)&v3, 0xCu);
}

void sub_10077B7E8()
{
  sub_10058673C();
  sub_10058671C((void *)&_mh_execute_header, v0, v1, "bytesFilled: %zu, bytesPerFrame: %d", v2, v3);
}

void sub_10077B854()
{
  sub_10058673C();
  sub_10058671C((void *)&_mh_execute_header, v0, v1, "bytesRead: %zu, bytesPerFrame: %d", v2, v3);
}

void sub_10077B8C0()
{
  sub_100586754();
  sub_10058671C((void *)&_mh_execute_header, v0, v1, "bytesPerFrame(%u) is not multiples of bytesToFill(%lu)", v2, v3);
}

void sub_10077B928(uint8_t *a1, void *a2, NSObject *a3)
{
  *(_DWORD *)a1 = 136446210;
  *a2 = "status != OI_STATUS_WRITE_IN_PROGRESS";
  sub_1002C5578((void *)&_mh_execute_header, a3, (uint64_t)a3, "Assertion failed: %{public}s", a1);
}

void sub_10077B970()
{
  sub_1000572DC();
  _os_log_error_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_ERROR, "Legacy audio queue full", v1, 2u);
}

void sub_10077B9B0(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_10077BA28(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_10077BAA0()
{
  sub_1000572DC();
  sub_10030D118((void *)&_mh_execute_header, v0, v1, "bytesRead: Zero", v2, v3, v4, v5, v6);
}

void sub_10077BAD4()
{
  sub_10058673C();
  sub_10058671C((void *)&_mh_execute_header, v0, v1, "bytesFilled: %zu, bytesPerFrame: %d", v2, v3);
}

void sub_10077BB44()
{
  sub_10058673C();
  sub_10058671C((void *)&_mh_execute_header, v0, v1, "bytesRead: %zu, bytesPerFrame: %d", v2, v3);
}

void sub_10077BBB4(uint64_t *a1, NSObject *a2)
{
  uint64_t v2 = *a1;
  int v3 = 134217984;
  uint64_t v4 = v2;
  _os_log_debug_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_DEBUG, "Got %zubytes of audio data", (uint8_t *)&v3, 0xCu);
}

void sub_10077BC30(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_10077BCA8(uint8_t *buf, unsigned char *a2, os_log_t log)
{
  *uint64_t buf = 0;
  *a2 = 0;
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "Can't send invalid audio buffers", buf, 2u);
}

void sub_10077BCE8(int a1, NSObject *a2)
{
  v2[0] = 67109120;
  v2[1] = a1;
  _os_log_fault_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_FAULT, "numPacketsForFrameMinus1: %d", (uint8_t *)v2, 8u);
}

void sub_10077BD60(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 232);
  if (v2)
  {
    *(void *)(a1 + 240) = v2;
    operator delete(v2);
  }
}

void sub_10077BD88()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "LE Unknown CB MsgID %d", v2, v3, v4, v5, v6);
}

void sub_10077BDF0()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "fSession is null", v2, v3, v4, v5, v6);
}

void sub_10077BE24()
{
  sub_1004428D8(__stack_chk_guard);
  sub_1004428C0();
  sub_1000572F4((void *)&_mh_execute_header, v0, v1, "Failed to refreshPlistLimitations for %@", v2, v3, v4, v5, v6);
}

void sub_10077BE8C(int a1, NSObject *a2)
{
  v2[0] = 67109376;
  v2[1] = a1;
  __int16 v3 = 1024;
  int v4 = 20161219;
  _os_log_error_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_ERROR, "CoreBluetooth version %d differs from bluetoothd version %d", (uint8_t *)v2, 0xEu);
}

void sub_10077BF18(char *a1, void *a2, NSObject *a3)
{
  if (*a1 < 0) {
    a2 = (void *)*a2;
  }
  int v3 = 136446210;
  int v4 = a2;
  sub_100057438((void *)&_mh_execute_header, a3, (uint64_t)a3, "Duplicate XPC check-in from session \"%{public}s\"", (uint8_t *)&v3);
}

void sub_10077BF98()
{
  sub_10005732C();
  sub_1000572F4((void *)&_mh_execute_header, v0, v1, "Unknown debug command with ID %llu", v2, v3, v4, v5, v6);
}

void sub_10077C000()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Invalid debug command", v2, v3, v4, v5, v6);
}

void sub_10077C034()
{
  sub_10005732C();
  sub_1000572F4((void *)&_mh_execute_header, v0, v1, "Unknown CBDebugCommandDeviceAccessNotification debug command with ID %llu", v2, v3, v4, v5, v6);
}

void sub_10077C09C()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "CBDebugCommandResolveLERandomAddressWithIRK ignoring bad inputs, returning 0", v2, v3, v4, v5, v6);
}

void sub_10077C0D0()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "CBDebugCommandDisableHostWakeupOnLinkDrop Invalid UUID", v2, v3, v4, v5, v6);
}

void sub_10077C104()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Cannot accept out-of-band pairing request without data", v2, v3, v4, v5, v6);
}

void sub_10077C138()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Cannot accept passkey pairing request without passkey", v2, v3, v4, v5, v6);
}

void sub_10077C16C(uint64_t a1, int a2, NSObject *a3)
{
  uint64_t v4 = (void *)(a1 + 56);
  if (*(char *)(a1 + 79) < 0) {
    uint64_t v4 = (void *)*v4;
  }
  uint64_t v5 = @"CBBTErrorReasonAdvertisingWatchNotFoundInternal";
  if (!a2) {
    uint64_t v5 = @"CBBTErrorReasonUnknownInternal";
  }
  uint8_t v6 = v5;
  int v8 = 136446466;
  int v9 = v4;
  __int16 v10 = 2112;
  int v11 = v6;
  sub_100057420((void *)&_mh_execute_header, a3, v7, "BT Problem reported. Session:\"%{public}s\" reason:%@", (uint8_t *)&v8);
}

void sub_10077C238()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "key cannot be empty", v2, v3, v4, v5, v6);
}

void sub_10077C26C(uint64_t a1)
{
  int v2 = 138412546;
  uint64_t v3 = a1;
  sub_1005B9118();
  sub_100057420((void *)&_mh_execute_header, v1, (uint64_t)v1, "unknown resource key:%@ subkey:%@", (uint8_t *)&v2);
}

void sub_10077C2E4()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Retrieving resources is a restricted SPI", v2, v3, v4, v5, v6);
}

void sub_10077C318(uint64_t a1, NSObject *a2)
{
  sub_10003AE4C(*(void *)(a1 + 128), (uint64_t)__p);
  if (v6 >= 0) {
    uint64_t v4 = __p;
  }
  else {
    uint64_t v4 = (void **)__p[0];
  }
  int v7 = 136315138;
  int v8 = v4;
  sub_100057438((void *)&_mh_execute_header, a2, v3, "session %s is not allowed to queryBluetoothStatus", (uint8_t *)&v7);
  if (v6 < 0) {
    operator delete(__p[0]);
  }
}

void sub_10077C3CC()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "kCBOptionStateDetailList cannot be empty", v2, v3, v4, v5, v6);
}

void sub_10077C400()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "kCBOptionStateDetailList no valid arguments", v2, v3, v4, v5, v6);
}

void sub_10077C434()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to start advertising with error %d", v2, v3, v4, v5, v6);
}

void sub_10077C49C()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Start periodic advertising is only for internal", v2, v3, v4, v5, v6);
}

void sub_10077C4D0()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to start/stop periodic advertising with error %d", v2, v3, v4, v5, v6);
}

void sub_10077C538()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Stop periodic advertising is only for internal", v2, v3, v4, v5, v6);
}

void sub_10077C56C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  sub_1002C5590(a1, (void *)a2, a3, 4.8752e-34);
  sub_1004A8270((void *)&_mh_execute_header, "Session \"%{public}s\" is not entitled to publish built-in service %{public}s", v4, v5);
  if (*(char *)(a2 + 23) < 0) {
    operator delete(*(void **)a2);
  }
}

void sub_10077C5C8()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Failed to convert service to be added", v2, v3, v4, v5, v6);
}

void sub_10077C5FC()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "offline advertising payload is internal only", v2, v3, v4, v5, v6);
}

void sub_10077C630()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "offline advertising payload is feature is not enabled", v2, v3, v4, v5, v6);
}

void sub_10077C664(uint64_t *a1, uint64_t a2, uint64_t a3, NSObject *a4)
{
  uint64_t v4 = *a1;
  *(_DWORD *)a2 = 134218242;
  *(void *)(a2 + 4) = a3;
  *(_WORD *)(a2 + 12) = 2112;
  *(void *)(a2 + 14) = v4;
  sub_1004A8270((void *)&_mh_execute_header, "incomingAddress address buffer is invalid[%lu bytes] from %@", (uint8_t *)a2, a4);
}

void sub_10077C6B4()
{
  sub_1004428D8(__stack_chk_guard);
  sub_1004428C0();
  sub_1000572F4((void *)&_mh_execute_header, v0, v1, "incomingAddress API use unauthorized for %@", v2, v3, v4, v5, v6);
}

void sub_10077C71C()
{
  sub_1000573EC();
  if (v4 != v5) {
    uint64_t v6 = v3;
  }
  else {
    uint64_t v6 = v1;
  }
  sub_100057464(v2, v6, 4.8149e-34);
  sub_100057438((void *)&_mh_execute_header, v7, (uint64_t)v7, "session %s is not allowed to request stable address", v8);
  if (*(char *)(v0 + 23) < 0) {
    operator delete(*(void **)v0);
  }
}

void sub_10077C774()
{
  sub_1000573EC();
  if (v4 != v5) {
    uint64_t v6 = v3;
  }
  else {
    uint64_t v6 = v1;
  }
  sub_100057464(v2, v6, 4.8149e-34);
  sub_100057438((void *)&_mh_execute_header, v7, (uint64_t)v7, "session %s is not allowed to request next address rotation time", v8);
  if (*(char *)(v0 + 23) < 0) {
    operator delete(*(void **)v0);
  }
}

void sub_10077C7CC()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "RetrieveConnectionHandleForIdentifier requested by unauthorized process -- check entitlements", v2, v3, v4, v5, v6);
}

void sub_10077C800()
{
  sub_10005732C();
  sub_1000572F4((void *)&_mh_execute_header, v0, v1, "RetrieveConnectionHandleForIdentifier no connection handle for device %@", v2, v3, v4, v5, v6);
}

void sub_10077C868()
{
  sub_10005732C();
  sub_1000572F4((void *)&_mh_execute_header, v0, v1, "Device %@ does not exist", v2, v3, v4, v5, v6);
}

void sub_10077C8D0()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Invalid device", v2, v3, v4, v5, v6);
}

void sub_10077C904()
{
  sub_1000572DC();
  _os_log_debug_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_DEBUG, "Limiting access to services", v1, 2u);
}

void sub_10077C944()
{
  sub_1005B9108();
  sub_1000574EC();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Error for handleEnableMRCForPeripheral: %d", v2, v3, v4, v5, v6);
}

void sub_10077C9AC()
{
  sub_1005B9108();
  sub_1000574EC();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Error for option read handleEnableMRCForPeripheral: %d", v2, v3, v4, v5, v6);
}

void sub_10077CA14()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Unauthorized use of this API", v2, v3, v4, v5, v6);
}

void sub_10077CA48()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Ignoring command due to invalid device", v2, v3, v4, v5, v6);
}

void sub_10077CA7C(uint64_t a1)
{
  int v2 = 138412546;
  uint64_t v3 = a1;
  sub_1005B9118();
  _os_log_debug_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_DEBUG, "Temporary IRK for device  %@, missing IRK %@", (uint8_t *)&v2, 0x16u);
}

void sub_10077CAFC()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "IRK needs to be 16 bytes", v2, v3, v4, v5, v6);
}

void sub_10077CB30()
{
  sub_10005732C();
  sub_1000572F4((void *)&_mh_execute_header, v0, v1, "invalid device specified %@", v2, v3, v4, v5, v6);
}

void sub_10077CB98()
{
  sub_10005732C();
  sub_1000572F4((void *)&_mh_execute_header, v0, v1, "Ignoring command, cannot access device %@", v2, v3, v4, v5, v6);
}

void sub_10077CC00()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Ignoring command due to invalid parameters", v2, v3, v4, v5, v6);
}

void sub_10077CC34()
{
  sub_1005B9128();
  sub_1002C5590(v2, v3, v4, 5.778e-34);
  sub_1004A8270((void *)&_mh_execute_header, "Failed to create a new device for address %@ with identifier %{public}s as it already exists", v5, v6);
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
}

void sub_10077CC8C()
{
  sub_1005B9128();
  sub_1002C5590(v2, v3, v4, 5.778e-34);
  sub_1004A8270((void *)&_mh_execute_header, "Failed to create a new device for address %@ with identifier %{public}s", v5, v6);
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
}

void sub_10077CCE4()
{
  sub_10005732C();
  sub_1000572F4((void *)&_mh_execute_header, v0, v1, "Device %@ already exists, cannot create a new one", v2, v3, v4, v5, v6);
}

void sub_10077CD4C()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "AddressBytes length must be 6 or 7 bytes", v2, v3, v4, v5, v6);
}

void sub_10077CD80()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "handleCreatePeripheralWithAddressAndIdentifierMsg Private API", v2, v3, v4, v5, v6);
}

void sub_10077CDB4(unsigned char *a1, unsigned char *a2)
{
  sub_10026C69C(a1, a2);
  sub_1000573D0((void *)&_mh_execute_header, v2, v3, "RegisterForConnectionEventsWithOptions with restricted service", v4);
}

void sub_10077CDE0()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Ignoring command due to limited DeviceAccess Per Accessory extension", v2, v3, v4, v5, v6);
}

void sub_10077CE14()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Ignoring command due to limited DeviceAccess Media extension", v2, v3, v4, v5, v6);
}

void sub_10077CE48()
{
  sub_1000573EC();
  if (v4 != v5) {
    uint64_t v6 = v3;
  }
  else {
    uint64_t v6 = v1;
  }
  sub_100057464(v2, v6, 4.8149e-34);
  sub_100057438((void *)&_mh_execute_header, v7, (uint64_t)v7, "session %s is not allowed to set LE AFH map ", v8);
  if (*(char *)(v0 + 23) < 0) {
    operator delete(*(void **)v0);
  }
}

void sub_10077CEA0()
{
  sub_1002B7074();
  if (v6 >= 0) {
    int v7 = v1;
  }
  else {
    int v7 = (void *)*v1;
  }
  *(_DWORD *)uint64_t v2 = 67109378;
  *(_DWORD *)(v2 + 4) = v3;
  *(_WORD *)(v2 + 8) = 2080;
  *(void *)(v2 + 10) = v7;
  sub_1000574B8((void *)&_mh_execute_header, v5, v3, "Failed to set connection AFH Map status=%{bluetooth:OI_STATUS}u for session %s", v4);
  if (*(char *)(v0 + 23) < 0) {
    operator delete(*(void **)v0);
  }
}

void sub_10077CF10()
{
  sub_1002B7074();
  sub_1005B9140(3.8522e-34, v1, v2, v3);
  *(_WORD *)(v4 + 12) = 1024;
  *(_DWORD *)(v4 + 14) = 5;
  *(_WORD *)(v4 + 18) = 2080;
  *(void *)(v4 + 20) = v5;
  _os_log_error_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, "Ignoring LE AFH map of %ld bytes (needs to be %d bytes) from session %s", v6, 0x1Cu);
  if (*(char *)(v0 + 23) < 0) {
    operator delete(*(void **)v0);
  }
}

void sub_10077CF88()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to convertXPC kCBScanOptionAppleFilterTargetCore for handleWipeDuplicateFilter: %d", v2, v3, v4, v5, v6);
}

void sub_10077CFF0()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to convertXPC kCBMsgArgOptions for handleWipeDuplicateFilter: %d", v2, v3, v4, v5, v6);
}

void sub_10077D058()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to convert XPC kCBScanOptionAppleFilterTargetCore for handleRemoveSingleEntryDuplicateFilter %d", v2, v3, v4, v5, v6);
}

void sub_10077D0C0()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to convert XPC Agr for handleRemoveSingleEntryDuplicateFilter %d", v2, v3, v4, v5, v6);
}

void sub_10077D128()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to convert XPC kCBScanOptionAppleFilterTargetCore for handleRemoveMultipleEntriesDuplicateFilter %d", v2, v3, v4, v5, v6);
}

void sub_10077D190()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to convert XPC Agr for handleRemoveMultipleEntriesDuplicateFilter %d", v2, v3, v4, v5, v6);
}

void sub_10077D1F8()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to convert XPC kCBScanOptionRemoveMultipleDupFilterEntryPacketType for handleClearDuplicateFilterCache %d", v2, v3, v4, v5, v6);
}

void sub_10077D260()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to convert XPC Arg for handleClearDuplicateFilterCache %d", v2, v3, v4, v5, v6);
}

void sub_10077D2C8()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to convertXPC kCBScanEnableOptionAppleScanPeriod for handleEnhancedScanEnableMsg: %d", v2, v3, v4, v5, v6);
}

void sub_10077D330()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to convertXPC kCBScanEnableOptionAppleScanDuration for handleEnhancedScanEnableMsg: %d", v2, v3, v4, v5, v6);
}

void sub_10077D398()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to convertXPC kCBScanOptionAppleFilterTargetCore for handleEnhancedScanEnableMsg: %d", v2, v3, v4, v5, v6);
}

void sub_10077D400()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to convertXPC kCBScanOptionAppleFilterBypassFilterDuplicate for handleEnhancedScanEnableMsg: %d", v2, v3, v4, v5, v6);
}

void sub_10077D468()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to convertXPC kCBScanOptionAllowDuplicates for handleEnhancedScanEnableMsg: %d", v2, v3, v4, v5, v6);
}

void sub_10077D4D0()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to convertXPC kCBScanEnableOptionAppleType for handleEnhancedScanEnableMsg: %d", v2, v3, v4, v5, v6);
}

void sub_10077D538()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to convertXPC kCBScanEnableOptionAppleEnable for handleEnhancedScanEnableMsg: %d", v2, v3, v4, v5, v6);
}

void sub_10077D5A0()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to convertXPC kCBMsgArgOptions for handleEnhancedScanEnableMsg: %d", v2, v3, v4, v5, v6);
}

void sub_10077D608()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to convertXPC kCBSetScanParameterPriorityConfiguration for handleEnhancedSetScanParametersMultiCoreMsg: %d", v2, v3, v4, v5, v6);
}

void sub_10077D670()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to convertXPC kCBSetScanParameterScanTargetCore for handleEnhancedSetScanParametersMultiCoreMsg: %d", v2, v3, v4, v5, v6);
}

void sub_10077D6D8()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to convertXPC kCBSetScanParameterScanMaxWindowLECoded for handleEnhancedSetScanParametersMultiCoreMsg: %d", v2, v3, v4, v5, v6);
}

void sub_10077D740()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to convertXPC kCBSetScanParameterScanMaxWindowLE2M for handleEnhancedSetScanParametersMultiCoreMsg: %d", v2, v3, v4, v5, v6);
}

void sub_10077D7A8()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to convertXPC kCBSetScanParameterScanMaxWindowLE1M for handleEnhancedSetScanParametersMultiCoreMsg: %d", v2, v3, v4, v5, v6);
}

void sub_10077D810()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to convertXPC kCBSetScanParameterScanIsLegacy for handleEnhancedSetScanParametersMultiCoreMsg: %d", v2, v3, v4, v5, v6);
}

void sub_10077D878()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to convertXPC kCBSetScanParameterScanWindowLECoded for handleEnhancedSetScanParametersMultiCoreMsg: %d", v2, v3, v4, v5, v6);
}

void sub_10077D8E0()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to convertXPC kCBSetScanParameterScanWindowLE2M for handleEnhancedSetScanParametersMultiCoreMsg: %d", v2, v3, v4, v5, v6);
}

void sub_10077D948()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to convertXPC kCBSetScanParameterScanWindowLE1M for handleEnhancedSetScanParametersMultiCoreMsg: %d", v2, v3, v4, v5, v6);
}

void sub_10077D9B0()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to convertXPC kCBSetScanParameterScanIntervalLECoded for handleEnhancedSetScanParametersMultiCoreMsg: %d", v2, v3, v4, v5, v6);
}

void sub_10077DA18()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to convertXPC kCBSetScanParameterScanIntervalLE2M for handleEnhancedSetScanParametersMultiCoreMsg: %d", v2, v3, v4, v5, v6);
}

void sub_10077DA80()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to convertXPC kCBSetScanParameterScanIntervalLE1M for handleEnhancedSetScanParametersMultiCoreMsg: %d", v2, v3, v4, v5, v6);
}

void sub_10077DAE8()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to convertXPC kCBSetScanParameterScanTypeLECoded for handleEnhancedSetScanParametersMultiCoreMsg: %d", v2, v3, v4, v5, v6);
}

void sub_10077DB50()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to convertXPC kCBSetScanParameterScanTypeLE2M for handleEnhancedSetScanParametersMultiCoreMsg: %d", v2, v3, v4, v5, v6);
}

void sub_10077DBB8()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to convertXPC kCBSetScanParameterScanTypeLE1M for handleEnhancedSetScanParametersMultiCoreMsg: %d", v2, v3, v4, v5, v6);
}

void sub_10077DC20()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to convertXPC kCBSetScanParameterScanPHY for handleEnhancedSetScanParametersMultiCoreMsg: %d", v2, v3, v4, v5, v6);
}

void sub_10077DC88()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to convertXPC kCBSetScanParameterScanningFilterPolicy for handleEnhancedSetScanParametersMultiCoreMsg: %d", v2, v3, v4, v5, v6);
}

void sub_10077DCF0()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to convertXPC kCBSetScanParameterOwnAddress for handleEnhancedSetScanParametersMultiCoreMsg: %d", v2, v3, v4, v5, v6);
}

void sub_10077DD58()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to convertXPC kCBMsgArgOptions for handleEnhancedSetScanParametersMultiCoreMsg: %d", v2, v3, v4, v5, v6);
}

void sub_10077DDC0()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to convertXPC kCBScanOption27dBmReport for handleAddAdvancedMatchingRuleWithAddressMsg: %d", v2, v3, v4, v5, v6);
}

void sub_10077DE28()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to convertXPC kCBScanOption127dBmReport for handleAddAdvancedMatchingRuleWithAddressMsg: %d", v2, v3, v4, v5, v6);
}

void sub_10077DE90()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to convertXPC kCBScanOptionAppleFilterRSSIThresholdOrder for handleAddAdvancedMatchingRuleWithAddressMsg: %d", v2, v3, v4, v5, v6);
}

void sub_10077DEF8()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to convertXPC kCBScanOptionAppleFilterTargetCore for handleAddAdvancedMatchingRuleWithAddressMsg: %d", v2, v3, v4, v5, v6);
}

void sub_10077DF60()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to convertXPC kCBScanOptionAppleFilterBypassFilterDuplicate for handleAddAdvancedMatchingRuleWithAddressMsg: %d", v2, v3, v4, v5, v6);
}

void sub_10077DFC8()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to convertXPC kCBScanOptionAppleFilterAddressType for handleAddAdvancedMatchingRuleWithAddressMsg: %d", v2, v3, v4, v5, v6);
}

void sub_10077E030()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to convertXPC kCBScanOptionAppleFilterForceDups for handleAddAdvancedMatchingRuleWithAddressMsg: %d", v2, v3, v4, v5, v6);
}

void sub_10077E098()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to convertXPC kCBScanOptionAppleFilterRssi for handleAddAdvancedMatchingRuleWithAddressMsg: %d", v2, v3, v4, v5, v6);
}

void sub_10077E100(uint64_t a1, uint64_t a2, uint64_t a3, NSObject *a4)
{
  *(_DWORD *)a1 = 134218240;
  *(void *)(a1 + 4) = a2;
  *(_WORD *)(a1 + 12) = 2048;
  *(void *)(a1 + 14) = a3;
  sub_1004A8270((void *)&_mh_execute_header, "Blob length (%zu) or mask length(%zu) size are not supported for handleAddAdvancedMatchingRuleWithAddressMsg", (uint8_t *)a1, a4);
}

void sub_10077E14C()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "The scan options didn't contain payload filter mask for handleAddAdvancedMatchingRuleWithAddressMsg", v2, v3, v4, v5, v6);
}

void sub_10077E180()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "The scan options didn't contain payload filter data for handleAddAdvancedMatchingRuleWithAddressMsg", v2, v3, v4, v5, v6);
}

void sub_10077E1B4()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to convertXPC kCBMsgArgOptions for handleAddAdvancedMatchingRuleWithAddressMsg: %d", v2, v3, v4, v5, v6);
}

void sub_10077E21C()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to convertXPC kCBScanOptionAppleFilterRSSIThresholdOrder for handleRemoveAdvancedMatchingRuleWithAddressMsg: %d", v2, v3, v4, v5, v6);
}

void sub_10077E284()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to convertXPC kCBScanOptionAppleFilterTargetCore for handleRemoveAdvancedMatchingRuleWithAddressMsg: %d", v2, v3, v4, v5, v6);
}

void sub_10077E2EC()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to convertXPC kCBScanOptionAppleFilterBypassFilterDuplicate for handleRemoveAdvancedMatchingRuleWithAddressMsg: %d", v2, v3, v4, v5, v6);
}

void sub_10077E354()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to convertXPC kCBScanOptionAppleFilterAddressType for handleRemoveAdvancedMatchingRuleWithAddressMsg: %d", v2, v3, v4, v5, v6);
}

void sub_10077E3BC()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to convertXPC kCBScanOptionAppleFilterForceDups for handleRemoveAdvancedMatchingRuleWithAddressMsg: %d", v2, v3, v4, v5, v6);
}

void sub_10077E424()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to convertXPC kCBScanOptionAppleFilterRssi for handleRemoveAdvancedMatchingRuleWithAddressMsg: %d", v2, v3, v4, v5, v6);
}

void sub_10077E48C()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "The scan options didn't contain payload filter mask for handleRemoveAdvancedMatchingRuleWithAddressMsg", v2, v3, v4, v5, v6);
}

void sub_10077E4C0()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "The scan options didn't contain payload filter data for handleRemoveAdvancedMatchingRuleWithAddressMsg", v2, v3, v4, v5, v6);
}

void sub_10077E4F4()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to convertXPC kCBMsgArgOptions for handleRemoveAdvancedMatchingRuleWithAddressMsg: %d", v2, v3, v4, v5, v6);
}

void sub_10077E55C()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Match Action Rules are internal only", v2, v3, v4, v5, v6);
}

void sub_10077E590()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to convertXPC kCBMsgArgDataLengthMaxTxTime for handleDataLengthChangeMsg: %d", v2, v3, v4, v5, v6);
}

void sub_10077E5F8()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to convertXPC kCBMsgArgDataLengthMaxTxOctets for handleDataLengthChangeMsg: %d", v2, v3, v4, v5, v6);
}

void sub_10077E660()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to convertXPC kCBMsgArgOptions for handleDataLengthChangeMsg: %d", v2, v3, v4, v5, v6);
}

void sub_10077E6C8()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Channel Sounding handleCsReadLocalSupportedCapabilitiesMsg is only for internal", v2, v3, v4, v5, v6);
}

void sub_10077E6FC()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Channel Sounding handleCsReadLocalSupportedCapabilitiesMsg error %d", v2, v3, v4, v5, v6);
}

void sub_10077E764()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Channel Sounding is not supported for this platform", v2, v3, v4, v5, v6);
}

void sub_10077E798()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Channel Sounding handleCsReadRemoteSupportedCapabilitiesMsg is only for internal", v2, v3, v4, v5, v6);
}

void sub_10077E7CC()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Channel Sounding handleCsCreateConfigMsg is only for internal", v2, v3, v4, v5, v6);
}

void sub_10077E800()
{
  sub_1005B9108();
  sub_1000574EC();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Error for handleCsCreateConfigMsg: %d", v2, v3, v4, v5, v6);
}

void sub_10077E868(unsigned __int16 a1, uint8_t *buf, os_log_t log)
{
  *(_DWORD *)uint64_t buf = 67109376;
  *((_DWORD *)buf + 1) = 10;
  *((_WORD *)buf + 4) = 1024;
  *(_DWORD *)(buf + 10) = a1;
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "Error for handleCsCreateConfigMsg. Channel map can't be greater than %d currently at: %d", buf, 0xEu);
}

void sub_10077E8C4()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Error for handleCsCreateConfigMsg for converting raw bytes channel: %d", v2, v3, v4, v5, v6);
}

void sub_10077E92C()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Channel Sounding handleCsRemoveConfigMsg is only for internal", v2, v3, v4, v5, v6);
}

void sub_10077E960()
{
  sub_1005B9108();
  sub_1000574EC();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Error for handleCsRemoveConfigMsg: %d", v2, v3, v4, v5, v6);
}

void sub_10077E9C8()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Channel Sounding handleCsProcedureEnableMsg is only for internal", v2, v3, v4, v5, v6);
}

void sub_10077E9FC()
{
  sub_1005B9108();
  sub_1000574EC();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Error for handleCsProcedureEnableMsg: %d", v2, v3, v4, v5, v6);
}

void sub_10077EA64()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Channel Sounding handleCsSetProcedureParamsMsg is only for internal", v2, v3, v4, v5, v6);
}

void sub_10077EA98()
{
  sub_1005B9108();
  sub_1000574EC();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Error for handleCsSetProcedureParamsMsg: %d", v2, v3, v4, v5, v6);
}

void sub_10077EB00()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Channel Sounding handleCsSetAfhMsg is only for internal", v2, v3, v4, v5, v6);
}

void sub_10077EB34()
{
  sub_1005B9108();
  sub_1000574EC();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Error for handleCsSetAfhMsg: %d", v2, v3, v4, v5, v6);
}

void sub_10077EB9C()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Channel Sounding handleCsSetDefaultSettingsMsg is only for internal", v2, v3, v4, v5, v6);
}

void sub_10077EBD0()
{
  sub_1005B9108();
  sub_1000574EC();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Error for handleCsReadLocalFAETableMsg: %d", v2, v3, v4, v5, v6);
}

void sub_10077EC38()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "kCBCSReflectorFAETable is not provided as option", v2, v3, v4, v5, v6);
}

void sub_10077EC6C()
{
  sub_10005732C();
  sub_1000572F4((void *)&_mh_execute_header, v0, v1, "Error converting data for Channel Classification %@", v2, v3, v4, v5, v6);
}

void sub_10077ECD4()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to convertXPC kCBMsgArgLESetPhyPhyOptions for handleLESetPHYMsg: %d", v2, v3, v4, v5, v6);
}

void sub_10077ED3C()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to convertXPC kCBMsgArgLESetPhyRxPhys for handleLESetPHYMsg: %d", v2, v3, v4, v5, v6);
}

void sub_10077EDA4()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to convertXPC kCBMsgArgLESetPhyTxPhys for handleLESetPHYMsg: %d", v2, v3, v4, v5, v6);
}

void sub_10077EE0C()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to convertXPC kCBMsgArgLESetPhyAllPhys for handleLESetPHYMsg: %d", v2, v3, v4, v5, v6);
}

void sub_10077EE74()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to convertXPC kCBMsgArgOptions for handleLESetPHYMsg: %d", v2, v3, v4, v5, v6);
}

void sub_10077EEDC()
{
  sub_1005B9108();
  sub_1000574EC();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Error for handleConfigureRSSIDetection: %d", v2, v3, v4, v5, v6);
}

void sub_10077EF44(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_10077EFB8()
{
  sub_1005B9108();
  sub_1000574EC();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to convertXPC options  for handleConfigureRSSIDetection: %d", v2, v3, v4, v5, v6);
}

void sub_10077F020()
{
  sub_1005B9108();
  sub_1000574EC();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Error for handleConfigureUsageNotifications: %d", v2, v3, v4, v5, v6);
}

void sub_10077F088()
{
  sub_1005B9108();
  sub_1000574EC();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Error for handleConfigureUsageStatisticsNotifications: %d", v2, v3, v4, v5, v6);
}

void sub_10077F0F0()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Error in Start LE Conn trigger Control message : %d", v2, v3, v4, v5, v6);
}

void sub_10077F158()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Cannot start event counter indications to an invalid device", v2, v3, v4, v5, v6);
}

void sub_10077F18C()
{
  sub_1004428D8(__stack_chk_guard);
  int v2 = 134218242;
  uint64_t v3 = v0;
  sub_1005B9118();
  sub_100057420((void *)&_mh_execute_header, v1, (uint64_t)v1, "connection handle %p for device %@ is invalud", (uint8_t *)&v2);
}

void sub_10077F204()
{
  sub_10005732C();
  sub_1000572F4((void *)&_mh_execute_header, v0, v1, "Could not get a connection handle for device %@", v2, v3, v4, v5, v6);
}

void sub_10077F26C()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Not allowed to start event counter SPMI", v2, v3, v4, v5, v6);
}

void sub_10077F2A0()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Not allowed to stop event counter SPMI", v2, v3, v4, v5, v6);
}

void sub_10077F2D4()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Set IRK for Device is only for internal", v2, v3, v4, v5, v6);
}

void sub_10077F308()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Remove IRK for Device is only for internal", v2, v3, v4, v5, v6);
}

void sub_10077F33C()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Delete Device is only for internal", v2, v3, v4, v5, v6);
}

void sub_10077F370()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Get Num Connected Peripherals Per Application not allowed", v2, v3, v4, v5, v6);
}

void sub_10077F3A4()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Not a msg with replyable context", v2, v3, v4, v5, v6);
}

void sub_10077F3D8()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Get LPEM Data not allowed", v2, v3, v4, v5, v6);
}

void sub_10077F40C()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Get WhbGetOptimalHost not allowed", v2, v3, v4, v5, v6);
}

void sub_10077F440()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Get handleWhbGetLocalDevice not allowed", v2, v3, v4, v5, v6);
}

void sub_10077F474()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "This command is only accessible for system processes", v2, v3, v4, v5, v6);
}

void sub_10077F4A8()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "This command is only accessible for internal processes", v2, v3, v4, v5, v6);
}

void sub_10077F4DC()
{
  sub_1004428D8(__stack_chk_guard);
  sub_1004428C0();
  sub_1000572F4((void *)&_mh_execute_header, v0, v1, "Refresh identity is not allowed for App %@ :", v2, v3, v4, v5, v6);
}

void sub_10077F544()
{
  sub_1004428D8(__stack_chk_guard);
  sub_1004428C0();
  sub_1000572F4((void *)&_mh_execute_header, v0, v1, "Get identity is not allowed for App %@ :", v2, v3, v4, v5, v6);
}

void sub_10077F5AC()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Invalid identifier", v2, v3, v4, v5, v6);
}

void sub_10077F5E0(uint64_t a1, uint8_t *buf, uint64_t a3, os_log_t log)
{
  *(_DWORD *)uint64_t buf = 138412802;
  *(void *)(buf + 4) = a1;
  *((_WORD *)buf + 6) = 2048;
  *(void *)(buf + 14) = a3;
  *((_WORD *)buf + 11) = 1024;
  *((_DWORD *)buf + 6) = 1024;
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "Could not store custom property %@, value is longer than maximum permitted (string is %lu, max allowed is %d)", buf, 0x1Cu);
}

void sub_10077F644()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Attempting to write custom property without âcom.apple.bluetooth.custom.properties.writableâ entitlement.", v2, v3, v4, v5, v6);
}

void sub_10077F678()
{
  sub_10005732C();
  sub_1000572F4((void *)&_mh_execute_header, v0, v1, "Session cannot access device %@", v2, v3, v4, v5, v6);
}

void sub_10077F6E0()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "No identifier", v2, v3, v4, v5, v6);
}

void sub_10077F714()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "No duration", v2, v3, v4, v5, v6);
}

void sub_10077F748()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Identifier is nil", v2, v3, v4, v5, v6);
}

void sub_10077F77C()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to convert args with error: %d", v2, v3, v4, v5, v6);
}

void sub_10077F7E4()
{
  sub_1000574EC();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Unsupported apply type: %d", v2, v3, v4, v5, v6);
}

void sub_10077F850()
{
  sub_1000573EC();
  if (v4 != v5) {
    uint64_t v6 = v3;
  }
  else {
    uint64_t v6 = v1;
  }
  sub_100057464(v2, v6, 4.8149e-34);
  sub_100057438((void *)&_mh_execute_header, v7, (uint64_t)v7, "session %s is not allowed to change LE power control ", v8);
  if (*(char *)(v0 + 23) < 0) {
    operator delete(*(void **)v0);
  }
}

void sub_10077F8A8()
{
  sub_1000572E8();
  __int16 v3 = 2080;
  char v4 = "handlesetLePowerControlMsg";
  sub_1000574B8((void *)&_mh_execute_header, v0, v1, "Failed to convertXpcObject  uint64_t result = %d, function=%s", v2);
}

void sub_10077F928()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to convertXpcObject kCBMsgArgOptions = %d", v2, v3, v4, v5, v6);
}

void sub_10077F990()
{
  sub_1000574EC();
  __int16 v3 = 2112;
  uint64_t v4 = v0;
  sub_1000574B8((void *)&_mh_execute_header, v1, (uint64_t)v1, "Someone is accessing handle 0x%04x on device \"%@\", but we don't have the service for it! à² _à² ", v2);
}

void sub_10077FA10()
{
  sub_1004428D8(__stack_chk_guard);
  uint64_t v1 = *(void *)(v0 + 224);
  int v4 = 138412546;
  uint64_t v5 = v2;
  __int16 v6 = 2112;
  uint64_t v7 = v1;
  sub_100057420((void *)&_mh_execute_header, v3, (uint64_t)v3, "Missing plist limitation for a DA session bundle %@ client %@", (uint8_t *)&v4);
}

void sub_10077FA94()
{
  sub_100579750();
  int v4 = v0;
  sub_1000574B8((void *)&_mh_execute_header, v1, v2, "%@ isCBPrivacySupported %d is not authorized to use bluetooth", v3);
}

void sub_10077FB0C()
{
  sub_10005732C();
  sub_1000572F4((void *)&_mh_execute_header, v0, v1, "debugAddDeviceToOutgoingLEConnectionDenyList: %@", v2, v3, v4, v5, v6);
}

void sub_10077FB74()
{
  sub_10005732C();
  sub_1000572F4((void *)&_mh_execute_header, v0, v1, "debugRemoveDeviceFromOutgoingLEConnectionDenyList: %@", v2, v3, v4, v5, v6);
}

void sub_10077FBDC(uint64_t a1, void *a2, uint64_t a3, NSObject *a4)
{
  id v7 = a2;
  *(_DWORD *)a3 = 138412546;
  *(void *)(a3 + 4) = a1;
  *(_WORD *)(a3 + 12) = 2112;
  *(void *)(a3 + 14) = v7;
  _os_log_error_impl((void *)&_mh_execute_header, a4, OS_LOG_TYPE_ERROR, "Overriding address with Invalid address string %@ (%@)", (uint8_t *)a3, 0x16u);
}

void sub_10077FC5C(unsigned char *a1, unsigned char *a2)
{
  sub_10026C69C(a1, a2);
  sub_1000573D0((void *)&_mh_execute_header, v2, v3, "Cannot advertise service data for UUID of more than 2 bytes", v4);
}

void sub_10077FC88(uint8_t *buf, _DWORD *a2, os_log_t log)
{
  *(_DWORD *)uint64_t buf = 67109120;
  *a2 = 20;
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "service data cannot exceed %d bytes", buf, 8u);
}

void sub_10077FCD4()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "service data invalid size", v2, v3, v4, v5, v6);
}

void sub_10077FD08()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Contact tracing is not allowed on this device", v2, v3, v4, v5, v6);
}

void sub_10077FD3C(uint64_t a1, uint64_t a2, NSObject *a3)
{
  *(_DWORD *)a1 = 134349056;
  *(void *)(a1 + 4) = a2;
  sub_100057438((void *)&_mh_execute_header, a3, (uint64_t)a3, "TDS data too short %{public}zu", (uint8_t *)a1);
}

void sub_10077FD7C()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Failure converting XPC data for DBAF.", v2, v3, v4, v5, v6);
}

void sub_10077FDB0(uint64_t a1, uint64_t a2, NSObject *a3)
{
  *(_DWORD *)a2 = 138543362;
  *(void *)(a2 + 4) = a1;
  sub_100057438((void *)&_mh_execute_header, a3, (uint64_t)a3, "XPC object is not an dictionary (type is %{public}@)", (uint8_t *)a2);
}

void sub_10077FDF0(void *a1, NSObject *a2)
{
  xpc_get_type(a1);
  sub_10005732C();
  sub_100057438((void *)&_mh_execute_header, a2, v3, "XPC object is not an array (type is %{public}@)", v4);
}

void sub_10077FE70()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to add service with error %d", v2, v3, v4, v5, v6);
}

void sub_10077FED8()
{
  sub_1004428C0();
  sub_1000572F4((void *)&_mh_execute_header, v0, v1, "Failed to set private mode for client session %@", v2, v3, v4, v5, v6);
}

void sub_10077FF44()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "TDS scan not allowed.", v2, v3, v4, v5, v6);
}

void sub_10077FF78()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Cannot use Legacy FindMy usecase without disabling the feature flag", v2, v3, v4, v5, v6);
}

void sub_10077FFAC()
{
  sub_1004428C0();
  sub_1000572F4((void *)&_mh_execute_header, v0, v1, "Session \"%s\" is using kCBScanOptionHWObjectDiscovery, move to kCBScanOptionHWObjectDiscoveryWild", v2, v3, v4, v5, v6);
}

void sub_100780024()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Cannot use FindMy usecase without enabling the feature flag", v2, v3, v4, v5, v6);
}

void sub_100780058()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "handleCreatePeripheralFromIdentifierMsg Failed to create a new device from invalid identifier", v2, v3, v4, v5, v6);
}

void sub_10078008C()
{
  sub_1004428D8(__stack_chk_guard);
  sub_1004428C0();
  sub_1000572F4((void *)&_mh_execute_header, v0, v1, "handleCreatePeripheralFromIdentifierMsg Device %@ already exists, cannot create a new one", v2, v3, v4, v5, v6);
}

void sub_1007800F4()
{
  sub_1004428D8(__stack_chk_guard);
  sub_1004428C0();
  sub_1000572F4((void *)&_mh_execute_header, v0, v1, "handleCreatePeripheralFromIdentifierMsg Failed to create a new device from identifier %{public}@ ", v2, v3, v4, v5, v6);
}

void sub_10078015C()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "handleCreatePeripheralFromIdentifierMsg Private API", v2, v3, v4, v5, v6);
}

void sub_100780190()
{
  sub_1004428C0();
  sub_1000572F4((void *)&_mh_execute_header, v0, v1, "%@ cannot use this API", v2, v3, v4, v5, v6);
}

void sub_1007801FC()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Invalid device", v2, v3, v4, v5, v6);
}

void sub_100780230()
{
  sub_1004428D8(__stack_chk_guard);
  sub_100579750();
  int v3 = v0;
  sub_1000574B8((void *)&_mh_execute_header, v1, (uint64_t)v1, "Failed to set GAP name for device \"%@\" due to error %d", v2);
}

void sub_1007802A4()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "FastLEConnection:handlePeripheralEnableFastLeConnectionWithData invalid device specified", v2, v3, v4, v5, v6);
}

void sub_1007802D8()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "FastLEConnection:handlePeripheralEnableFastLeConnectionWithData no access to this SPI", v2, v3, v4, v5, v6);
}

void sub_10078030C()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "local address should be 6 bytes, ignoring invalid data", v2, v3, v4, v5, v6);
}

void sub_100780340()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Peer address should be 6 bytes, ignoring invalid data", v2, v3, v4, v5, v6);
}

void sub_100780374()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Invalid User Description Length", v2, v3, v4, v5, v6);
}

void sub_1007803A8()
{
  sub_10005732C();
  sub_1000572F4((void *)&_mh_execute_header, v0, v1, "Invalid zone %{public}@", v2, v3, v4, v5, v6);
}

void sub_100780410()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "The scan options didn't contact a puck filter type", v2, v3, v4, v5, v6);
}

void sub_100780444()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "The scan options didn't contain an RSSI threshold value", v2, v3, v4, v5, v6);
}

void sub_100780478()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "The scan options didn't contain payload filter mask", v2, v3, v4, v5, v6);
}

void sub_1007804AC()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "The scan options didn't contain payload filter data", v2, v3, v4, v5, v6);
}

void sub_1007804E0()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "The scan options didn't contain a valid Name Match Option", v2, v3, v4, v5, v6);
}

void sub_100780514()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "The scan options didn't contain a valid RSSI threshold value", v2, v3, v4, v5, v6);
}

void sub_100780548()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "ruleID could not be converted", v2, v3, v4, v5, v6);
}

void sub_10078057C()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "serviceUUID could not be converted", v2, v3, v4, v5, v6);
}

void sub_1007805B0()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Puck ScanIntervalBackground could not be converted", v2, v3, v4, v5, v6);
}

void sub_1007805E4()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Puck ScanInterval could not be converted", v2, v3, v4, v5, v6);
}

void sub_100780618()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Puck ScanWindow could not be converted", v2, v3, v4, v5, v6);
}

void sub_10078064C()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "UseCaseList could not be converted", v2, v3, v4, v5, v6);
}

void sub_100780680()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "ObjectLocatorWithThisType options  could not be converted", v2, v3, v4, v5, v6);
}

void sub_1007806B4()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Address type could not be converted", v2, v3, v4, v5, v6);
}

void sub_1007806E8()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Filtered peers could not be converted", v2, v3, v4, v5, v6);
}

void sub_10078071C()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "RSSI Threshold options  could not be converted", v2, v3, v4, v5, v6);
}

void sub_100780750()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Target Core options  could not be converted", v2, v3, v4, v5, v6);
}

void sub_100780784()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "bypass Filter Duplicate options could not be converted", v2, v3, v4, v5, v6);
}

void sub_1007807B8()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Force dups could not be converted", v2, v3, v4, v5, v6);
}

void sub_1007807EC()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "ManufacturerID could not be converted", v2, v3, v4, v5, v6);
}

void sub_100780820(unsigned char *a1, unsigned char *a2)
{
  sub_10026C69C(a1, a2);
  sub_1000573D0((void *)&_mh_execute_header, v2, v3, "createXpcAdvData lenError", v4);
}

void sub_10078084C()
{
  sub_1002B7074();
  sub_1005B9140(5.778e-34, v1, v2, v3);
  *(_WORD *)(v4 + 12) = 2080;
  *(void *)(v4 + 14) = v5;
  sub_1004A8270((void *)&_mh_execute_header, "createXpcAdvData error device:%@ address:%s, invalid length, not enough room for the len field.", v6, v7);
  if (*(char *)(v0 + 23) < 0) {
    operator delete(*(void **)v0);
  }
}

void sub_1007808A8(int a1, NSObject *a2)
{
  v2[0] = 67109120;
  v2[1] = a1;
  _os_log_error_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_ERROR, "Could not register MAP: %{bluetooth:OI_STATUS}u", (uint8_t *)v2, 8u);
}

void sub_100780920(char *a1, uint8_t *buf, int a3, os_log_t log)
{
  if (a1[23] >= 0) {
    uint64_t v5 = a1;
  }
  else {
    uint64_t v5 = *(char **)a1;
  }
  *(_DWORD *)uint64_t buf = 136446466;
  *(void *)(buf + 4) = v5;
  *((_WORD *)buf + 6) = 1024;
  *(_DWORD *)(buf + 14) = a3;
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "Failed to disconnect from device %{public}s due to %{bluetooth:OI_STATUS}u", buf, 0x12u);
  if (a1[23] < 0) {
    operator delete(*(void **)a1);
  }
}

void sub_1007809A4(char a1, int a2, os_log_t log)
{
  uint64_t v3 = "accept";
  if ((a1 & 1) == 0) {
    uint64_t v3 = "deny";
  }
  int v4 = 136315394;
  uint64_t v5 = v3;
  __int16 v6 = 1024;
  int v7 = a2;
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "Failed to %s connection attempt - result was %{bluetooth:OI_STATUS}u", (uint8_t *)&v4, 0x12u);
}

void sub_100780A44(char *a1, uint8_t *buf, os_log_t log)
{
  if (a1[23] >= 0) {
    int v4 = a1;
  }
  else {
    int v4 = *(char **)a1;
  }
  *(_DWORD *)uint64_t buf = 136446210;
  *(void *)(buf + 4) = v4;
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "Denying connection attempt from device %{public}s. Is MAP enabled? Is MAP connected to some other device?", buf, 0xCu);
  if (a1[23] < 0) {
    operator delete(*(void **)a1);
  }
}

void sub_100780AB8(unsigned __int16 a1, NSObject *a2)
{
  v2[0] = 67109120;
  v2[1] = a1;
  _os_log_error_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_ERROR, "Received disconnect event with no connected device for connectionId %d", (uint8_t *)v2, 8u);
}

void sub_100780B34(os_log_t log)
{
  *(_WORD *)uint64_t v1 = 0;
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "CK asked us to undelete message, which is unsupported", v1, 2u);
}

void sub_100780B78(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_100780BF0(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_100780C68(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_100780CE0()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Failed to create session for FastConnectACL Manager", v2, v3, v4, v5, v6);
}

void sub_100780D14(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_100780D8C()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Fail to pause LEConnectionManager", v2, v3, v4, v5, v6);
}

void sub_100780DC0()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Fail to set iCloud RPA, skip BBFC", v2, v3, v4, v5, v6);
}

void sub_100780DF4(uint64_t a1, NSObject *a2)
{
  sub_100475EE0(a1, (uint64_t)__p);
  if (v5 >= 0) {
    uint64_t v3 = __p;
  }
  else {
    uint64_t v3 = (void **)__p[0];
  }
  *(_DWORD *)uint64_t buf = 136446210;
  int v7 = v3;
  _os_log_error_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_ERROR, "Can't start scan for \"%{public}s\" since Scan is running already", buf, 0xCu);
  if (v5 < 0) {
    operator delete(__p[0]);
  }
}

void sub_100780EA8()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Fail to register connectCfm CB for FastConnectACL", v2, v3, v4, v5, v6);
}

void sub_100780EDC()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Previous connection request wasn't completed", v2, v3, v4, v5, v6);
}

void sub_100780F10(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_100780F88()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "serviceConnection - m_Device is null", v2, v3, v4, v5, v6);
}

BOOL sub_100780FBC(NSObject *a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return *a2 == 0;
}

void sub_10078104C()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Fail to pause LEObserver, Skip BBFC", v2, v3, v4, v5, v6);
}

void sub_100781080()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "LEObserver Already Paused, Kickstart BBFC", v2, v3, v4, v5, v6);
}

void sub_1007810B4()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Fail to register connectCfm CB", v2, v3, v4, v5, v6);
}

void sub_1007810E8()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Fail to unregister connectCfm CB for FastConnectACL", v2, v3, v4, v5, v6);
}

void sub_10078111C()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Error trying to create IOHIDManager", v2, v3, v4, v5, v6);
}

void sub_100781150()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Error trying to open Apple USB Pairing HID Manager", v2, v3, v4, v5, v6);
}

void sub_100781184(char *a1, uint8_t *buf, os_log_t log)
{
  if (a1[23] >= 0) {
    uint64_t v4 = a1;
  }
  else {
    uint64_t v4 = *(char **)a1;
  }
  *(_DWORD *)uint64_t buf = 136315138;
  *(void *)(buf + 4) = v4;
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "Unable to find HID device %s to remove", buf, 0xCu);
  if (a1[23] < 0) {
    operator delete(*(void **)a1);
  }
}

void sub_1007811F8()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Coud not copy BT ADDR because BT ADDR is all Zero", v2, v3, v4, v5, v6);
}

void sub_10078122C(uint64_t *a1, NSObject *a2)
{
  if (*((char *)a1 + 23) >= 0) {
    uint64_t v2 = a1;
  }
  else {
    uint64_t v2 = (uint64_t *)*a1;
  }
  int v3 = 136315138;
  uint64_t v4 = v2;
  _os_log_error_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_ERROR, "Failed to Send Link Key to device %s", (uint8_t *)&v3, 0xCu);
}

void sub_1007812B4()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Could not generate link key", v2, v3, v4, v5, v6);
}

void sub_1007812E8()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "USB Pairing: failed - Failed to open device (%04X); retrying in 5s...\n",
    v2,
    v3,
    v4,
    v5,
    v6);
}

void sub_100781350()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Could not open USB Device", v2, v3, v4, v5, v6);
}

void sub_100781384(uint64_t a1, uint64_t a2, os_log_t log)
{
  int v3 = 134218240;
  uint64_t v4 = a1;
  __int16 v5 = 2048;
  uint64_t v6 = a2;
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "USB Pairing: Invalid context (%p) / device (%p)\n", (uint8_t *)&v3, 0x16u);
}

void sub_10078140C()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "ERR: Unable to get location ID for a device\n", v2, v3, v4, v5, v6);
}

void sub_100781440(uint64_t a1, NSObject *a2)
{
  int v2 = 134217984;
  uint64_t v3 = a1;
  _os_log_error_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_ERROR, "Unable to find bluetooth device for iohid ref %p", (uint8_t *)&v2, 0xCu);
}

void sub_1007814B8()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Sending existing LinkKey Failed", v2, v3, v4, v5, v6);
}

void sub_1007814EC()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Data sent to device does not match data being read back with status %d", v2, v3, v4, v5, v6);
}

void sub_100781554()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to Send Link Key to device with status %d", v2, v3, v4, v5, v6);
}

void sub_1007815BC()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Could not set link key to the device", v2, v3, v4, v5, v6);
}

void sub_1007815F0(int a1, NSObject *a2)
{
  v2[0] = 67109120;
  v2[1] = a1;
  _os_log_error_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_ERROR, "Unknown CB MsgID %d", (uint8_t *)v2, 8u);
}

void sub_100781668(uint64_t a1, NSObject *a2)
{
  int v2 = 138543362;
  uint64_t v3 = a1;
  _os_log_error_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_ERROR, "Ignoring mismatched check-in from client \"%{public}@\"", (uint8_t *)&v2, 0xCu);
}

void sub_1007816E0(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_10078174C(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_1007817B8(os_log_t log)
{
  *(_WORD *)uint64_t v1 = 0;
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "Failed to bring the link up", v1, 2u);
}

void sub_1007817FC()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Impossible to register PAN ...", v2, v3, v4, v5, v6);
}

void sub_100781830(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_10078189C(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_100781908()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Failed to deregister PAN", v2, v3, v4, v5, v6);
}

void sub_10078193C(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_1007819A8()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Failed to bring the link up", v2, v3, v4, v5, v6);
}

void sub_1007819DC()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Connection failed!", v2, v3, v4, v5, v6);
}

void sub_100781A10(os_log_t log)
{
  int v1 = 136446210;
  uint64_t v2 = "fNetIfc == NULL";
  _os_log_fault_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_FAULT, "Assertion failed: %{public}s", (uint8_t *)&v1, 0xCu);
}

void sub_100781A94()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Invalid size input report", v2, v3, v4, v5, v6);
}

void sub_100781AC8(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_100781B34(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_100781BA0()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "The HID device is not ready for a spoofed click", v2, v3, v4, v5, v6);
}

void sub_100781BD4()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Failed to create Management HID device", v2, v3, v4, v5, v6);
}

void sub_100781C08()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Failed to create Mouse HID device", v2, v3, v4, v5, v6);
}

void sub_100781C3C()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Failed to create Accelerometer HID device", v2, v3, v4, v5, v6);
}

void sub_100781C70()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "startTracking: sensor tracking is not supported on this platform", v2, v3, v4, v5, v6);
}

void sub_100781CA4()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "startTracking: session is nil", v2, v3, v4, v5, v6);
}

void sub_100781CD8()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "startTracking: device is nil", v2, v3, v4, v5, v6);
}

void sub_100781D0C(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_100781D78(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_100781DE4()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "startTracking:failed to create session ID string", v2, v3, v4, v5, v6);
}

void sub_100781E18()
{
  sub_100313A24();
  sub_100057518((void *)&_mh_execute_header, v0, v1, "Failed to configure sensor track Increase Scan Params device %{public}@ with status %d");
}

void sub_100781E80()
{
  sub_100313A24();
  sub_100057518((void *)&_mh_execute_header, v0, v1, "Failed to start tracking device %{public}@ with status %d");
}

void sub_100781EE8(void *a1, uint8_t *buf, os_log_t log)
{
  *(_DWORD *)uint64_t buf = 138543362;
  *(void *)(buf + 4) = a1;
  _os_log_debug_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_DEBUG, "Currently tracking apple types: %{public}@", buf, 0xCu);
}

void sub_100781F40()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "stopTracking: sensor tracking is not supported on this platform", v2, v3, v4, v5, v6);
}

void sub_100781F74()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "stopTracking: session is nil", v2, v3, v4, v5, v6);
}

void sub_100781FA8()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "stopTracking: device is nil", v2, v3, v4, v5, v6);
}

void sub_100781FDC(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_100782048()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "stopTracking: failed to create session ID string", v2, v3, v4, v5, v6);
}

void sub_10078207C()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "stopTrackingForSession: sensor tracking is not supported on this platform", v2, v3, v4, v5, v6);
}

void sub_1007820B0()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "topTrackingForSession: session is nil", v2, v3, v4, v5, v6);
}

void sub_1007820E4()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "stopTrackingForSession: failed to create session ID string", v2, v3, v4, v5, v6);
}

void sub_100782118(os_log_t log)
{
  int v1 = 136446210;
  uint64_t v2 = "index < fSize";
  _os_log_fault_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_FAULT, "Assertion failed: %{public}s", (uint8_t *)&v1, 0xCu);
}

void sub_10078219C()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Invalid Phonebook character set.", v2, v3, v4, v5, v6);
}

void sub_1007821D0()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Could not find phonebook", v2, v3, v4, v5, v6);
}

void sub_100782204()
{
  sub_10005732C();
  sub_1000572F4((void *)&_mh_execute_header, v0, v1, "Missing first argument in +XAPL command: %{public}s", v2, v3, v4, v5, v6);
}

void sub_10078226C()
{
  sub_10005732C();
  sub_1000572F4((void *)&_mh_execute_header, v0, v1, "Missing second argument +XAPL command: %{public}s", v2, v3, v4, v5, v6);
}

void sub_1007822D4()
{
  sub_10005732C();
  sub_1000572F4((void *)&_mh_execute_header, v0, v1, "Incorrect argument in +IPHONEACCEV command: %{public}s", v2, v3, v4, v5, v6);
}

void sub_10078233C()
{
  sub_10005732C();
  sub_1000572F4((void *)&_mh_execute_header, v0, v1, "Incorrect event count in +IPHONEACCEV command: %{public}s", v2, v3, v4, v5, v6);
}

void sub_1007823A4()
{
  sub_10005732C();
  sub_1000572F4((void *)&_mh_execute_header, v0, v1, "Unknown event in +IPHONEACCEV command: %{public}s", v2, v3, v4, v5, v6);
}

void sub_10078240C()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Error in +IPHONEACCEV command - device is not custom command compliant", v2, v3, v4, v5, v6);
}

void sub_100782440()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Error in +IPHONEACCEV command - invalid command", v2, v3, v4, v5, v6);
}

void sub_100782474()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Error in +IPHONEACCEV command - invalid command received", v2, v3, v4, v5, v6);
}

void sub_1007824A8()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Error in +IPHONEEV command - device is not custom command compliant", v2, v3, v4, v5, v6);
}

void sub_1007824DC()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Error in +IPHONEACCNAME command - device is not custom command compliant", v2, v3, v4, v5, v6);
}

void sub_100782510()
{
  sub_10005732C();
  sub_1000572F4((void *)&_mh_execute_header, v0, v1, "Incorrect argument in +IPHONEACCINDICATOR command: %{public}s", v2, v3, v4, v5, v6);
}

void sub_100782578()
{
  sub_10005732C();
  sub_1000572F4((void *)&_mh_execute_header, v0, v1, "Incorrect event count in +IPHONEACCINDICATOR command: %{public}s", v2, v3, v4, v5, v6);
}

void sub_1007825E0()
{
  sub_10005732C();
  sub_1000572F4((void *)&_mh_execute_header, v0, v1, "Unknown event in +IPHONEACCINDICATOR command: %{public}s", v2, v3, v4, v5, v6);
}

void sub_100782648()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Error in +IPHONEACCINDICATOR command - device is not custom command compliant", v2, v3, v4, v5, v6);
}

void sub_10078267C()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Error in +IPHONEACCINDICATOR command - invalid command", v2, v3, v4, v5, v6);
}

void sub_1007826B0()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Error in +APLSIRI command - device is not custom command compliant", v2, v3, v4, v5, v6);
}

void sub_1007826E4()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Error in APLEFM command", v2, v3, v4, v5, v6);
}

void sub_100782718()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Error in APLEFM  command - device is not custom command compliant", v2, v3, v4, v5, v6);
}

void sub_10078274C()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Error in +APLNRSTAT", v2, v3, v4, v5, v6);
}

void sub_100782780()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Error in +APLNRSTAT  command - device is not custom command compliant", v2, v3, v4, v5, v6);
}

void sub_1007827B4(int *a1)
{
  do
  {
    if (*((char *)a1 - 1) < 0) {
      operator delete(*((void **)a1 - 3));
    }
    a1 -= 8;
  }
  while (a1 != dword_100A139B0);
}

void sub_1007827F8(os_log_t log)
{
  *(_WORD *)uint64_t v1 = 0;
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "Unknown command type.", v1, 2u);
}

void sub_10078283C(os_log_t log)
{
  *(_WORD *)uint64_t v1 = 0;
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "Failed to open AB", v1, 2u);
}

void sub_100782880()
{
  sub_10005732C();
  sub_1003CF064((void *)&_mh_execute_header, v0, v1, "BTAccessoryMsgHandler::handleBTAccessoryGetDefaultMsg sessionID:%lld", v2, v3, v4, v5, v6);
}

void sub_1007828E8()
{
  sub_10005732C();
  sub_1003CF064((void *)&_mh_execute_header, v0, v1, "BTAccessoryMsgHandler::handleBTAccessoryAddCallbacksMsg accessoryManager:%llx ", v2, v3, v4, v5, v6);
}

void sub_100782950()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "could not find callbacks (or) no callbacks were registered ", v2, v3, v4, v5, v6);
}

void sub_100782984()
{
  sub_10005732C();
  sub_1003CF064((void *)&_mh_execute_header, v0, v1, "BTAccessoryMsgHandler::handleBTAccessoryRemoveCallbacksMsg accessoryManager:%llx ", v2, v3, v4, v5, v6);
}

void sub_1007829EC()
{
  sub_10005732C();
  sub_1003CF064((void *)&_mh_execute_header, v0, v1, "BTAccessoryMsgHandler::handleBTAccessoryRegisterDeviceMsg accessoryManagerID:%llx", v2, v3, v4, v5, v6);
}

void sub_100782A54()
{
  sub_10005732C();
  sub_1003CF064((void *)&_mh_execute_header, v0, v1, "BTAccessoryMsgHandler::handleBTAccessoryPlugInDeviceMsg accessoryManagerID:%llx", v2, v3, v4, v5, v6);
}

void sub_100782ABC()
{
  sub_10005732C();
  sub_1003CF064((void *)&_mh_execute_header, v0, v1, "BTAccessoryMsgHandler::handleBTAccessoryUnplugDeviceMsg accessoryManagerID:%llx", v2, v3, v4, v5, v6);
}

void sub_100782B24()
{
  sub_10005732C();
  sub_1003CF064((void *)&_mh_execute_header, v0, v1, "BTAccessoryMsgHandler::handleBTAccessoryGetDeviceStateMsg accessoryManagerID:%llx", v2, v3, v4, v5, v6);
}

void sub_100782B8C()
{
  sub_10005732C();
  sub_1003CF064((void *)&_mh_execute_header, v0, v1, "BTAccessoryMsgHandler::handleBTAccessoryGetDevicesMsg accessoryManagerID:%llx", v2, v3, v4, v5, v6);
}

void sub_100782BF4()
{
  sub_10005732C();
  sub_1003CF064((void *)&_mh_execute_header, v0, v1, "BTAccessoryMsgHandler::handleBTAccessoryGetDeviceBatteryLevelMsg accessoryManagerID:%llx", v2, v3, v4, v5, v6);
}

void sub_100782C5C()
{
  sub_10005732C();
  sub_1003CF064((void *)&_mh_execute_header, v0, v1, "BTAccessoryMsgHandler::handleBTAccessoryGetDeviceBatteryStatusMsg accessoryManagerID:%llx", v2, v3, v4, v5, v6);
}

void sub_100782CC4()
{
  sub_10005732C();
  sub_1003CF064((void *)&_mh_execute_header, v0, v1, "BTAccessoryMsgHandler::handleBTAccessoryGetTimeSyncIdMsg accessoryManagerID:%llx", v2, v3, v4, v5, v6);
}

void sub_100782D2C()
{
  sub_10005732C();
  sub_1003CF064((void *)&_mh_execute_header, v0, v1, "BTAccessoryMsgHandler::handleBTAccessoryIsAccessoryMsg accessoryManagerID:%llx", v2, v3, v4, v5, v6);
}

void sub_100782D94()
{
  sub_10005732C();
  sub_1003CF064((void *)&_mh_execute_header, v0, v1, "BTAccessoryMsgHandler::handleBTAccessoryGenerateLinkKeyMsg accessoryManagerID:%llx", v2, v3, v4, v5, v6);
}

void sub_100782DFC()
{
  sub_10005732C();
  sub_1003CF064((void *)&_mh_execute_header, v0, v1, "BTAccessoryMsgHandler::handleBTAccessorySetLinkKeyExMsg accessoryManagerID:%llx", v2, v3, v4, v5, v6);
}

void sub_100782E64()
{
  sub_10005732C();
  sub_1003CF064((void *)&_mh_execute_header, v0, v1, "BTAccessoryMsgHandler::handleBTAccessorySetFirstSettingMsg accessoryManagerID:%llx", v2, v3, v4, v5, v6);
}

void sub_100782ECC()
{
  sub_10005732C();
  sub_1003CF064((void *)&_mh_execute_header, v0, v1, "BTAccessoryMsgHandler::handleBTAccessorySetSecondSettingMsg accessoryManagerID:%llx", v2, v3, v4, v5, v6);
}

void sub_100782F34()
{
  sub_10005732C();
  sub_1003CF064((void *)&_mh_execute_header, v0, v1, "BTAccessoryMsgHandler::handleBTAccessoryGetFirstSettingMsg accessoryManagerID:%llx", v2, v3, v4, v5, v6);
}

void sub_100782F9C()
{
  sub_10005732C();
  sub_1003CF064((void *)&_mh_execute_header, v0, v1, "BTAccessoryMsgHandler::handleBTAccessorySetRemoteTimeSyncMsg accessoryManagerID:%llx", v2, v3, v4, v5, v6);
}

void sub_100783004()
{
  sub_10005732C();
  sub_1003CF064((void *)&_mh_execute_header, v0, v1, "BTAccessoryMsgHandler::handleBTAccessoryGetSecondSettingMsg accessoryManagerID:%llx", v2, v3, v4, v5, v6);
}

void sub_10078306C()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Failed to register a BTAccessoryManagerRegisterCustomMessageClient", v2, v3, v4, v5, v6);
}

void sub_1007830A0()
{
  sub_10005732C();
  sub_1003CF064((void *)&_mh_execute_header, v0, v1, "BTAccessoryMsgHandler::handleBTAccessoryRegisterCustomMessageClientMsg accessoryManager:%llx ", v2, v3, v4, v5, v6);
}

void sub_100783108()
{
  sub_10005732C();
  sub_1003CF064((void *)&_mh_execute_header, v0, v1, "BTAccessoryMsgHandler::handleBTAccessoryDeregisterCustomMessageClientMsg accessoryManager:%llx ", v2, v3, v4, v5, v6);
}

void sub_100783170()
{
  sub_10005732C();
  sub_1003CF064((void *)&_mh_execute_header, v0, v1, "BTAccessoryMsgHandler::handleBTAccessorySendCustomMessageMsg accessoryManagerID:%llx", v2, v3, v4, v5, v6);
}

void sub_1007831D8()
{
  sub_10005732C();
  sub_1003CF064((void *)&_mh_execute_header, v0, v1, "BTAccessoryMsgHandler::handleBTAccessoryGetDeviceDiagnosticsMsg accessoryManagerID:%llx", v2, v3, v4, v5, v6);
}

void sub_100783240()
{
  sub_10005732C();
  sub_1003CF064((void *)&_mh_execute_header, v0, v1, "BTAccessoryMsgHandler::handleBTAccessorySendRequestPeriodicallyMsg accessoryManagerID:%llx", v2, v3, v4, v5, v6);
}

void sub_1007832A8()
{
  sub_10005732C();
  sub_1003CF064((void *)&_mh_execute_header, v0, v1, "BTAccessoryMsgHandler::handleBTAccessoryCancelRequestPeriodicallyMsg accessoryManagerID:%llx", v2, v3, v4, v5, v6);
}

void sub_100783310()
{
  sub_10005732C();
  sub_1003CF064((void *)&_mh_execute_header, v0, v1, "BTAccessoryMsgHandler::handleBTAccessorySendControlCommandMsg accessoryManagerID:%llx", v2, v3, v4, v5, v6);
}

void sub_100783378()
{
  sub_10005732C();
  sub_1003CF064((void *)&_mh_execute_header, v0, v1, "BTAccessoryMsgHandler::handleBTAccessoryGetDoubleTapActionMsg accessoryManagerID:%llx", v2, v3, v4, v5, v6);
}

void sub_1007833E0()
{
  sub_10005732C();
  sub_1003CF064((void *)&_mh_execute_header, v0, v1, "BTAccessoryMsgHandler::handleBTAccessoryGetControlCommandMsg accessoryManagerID:%llx", v2, v3, v4, v5, v6);
}

void sub_100783448()
{
  sub_10005732C();
  sub_1003CF064((void *)&_mh_execute_header, v0, v1, "BTAccessoryMsgHandler::handleBTAccessoryGetDoubleTapActionExMsg accessoryManagerID:%llx", v2, v3, v4, v5, v6);
}

void sub_1007834B0()
{
  sub_10005732C();
  sub_1003CF064((void *)&_mh_execute_header, v0, v1, "BTAccessoryMsgHandler::handleBTAccessoryGetDoubleTapCapabilityMsg accessoryManagerID:%llx", v2, v3, v4, v5, v6);
}

void sub_100783518()
{
  sub_10005732C();
  sub_1003CF064((void *)&_mh_execute_header, v0, v1, "BTAccessoryMsgHandler::handleBTAccessoryGetInEarStatusMsg accessoryManagerID:%llx", v2, v3, v4, v5, v6);
}

void sub_100783580()
{
  sub_10005732C();
  sub_1003CF064((void *)&_mh_execute_header, v0, v1, "BTAccessoryMsgHandler::handleBTAccessoryGetFeatureCapabilityMsg accessoryManagerID:%llx", v2, v3, v4, v5, v6);
}

void sub_1007835E8()
{
  sub_10005732C();
  sub_1003CF064((void *)&_mh_execute_header, v0, v1, "BTAccessoryMsgHandler::handleBTAccessorySetDoubleTapActionMsg accessoryManagerID:%llx", v2, v3, v4, v5, v6);
}

void sub_100783650()
{
  sub_10005732C();
  sub_1003CF064((void *)&_mh_execute_header, v0, v1, "BTAccessoryMsgHandler::handleBTAccessorySetDoubleTapActionExMsg accessoryManagerID:%llx", v2, v3, v4, v5, v6);
}

void sub_1007836B8()
{
  sub_10005732C();
  sub_1003CF064((void *)&_mh_execute_header, v0, v1, "BTAccessoryMsgHandler::handleBTAccessoryGetSettingFeatureBitMaskMsg accessoryManagerID:%llx", v2, v3, v4, v5, v6);
}

void sub_100783720()
{
  sub_10005732C();
  sub_1003CF064((void *)&_mh_execute_header, v0, v1, "BTAccessoryMsgHandler::handleBTAccessoryGetAccessoryInfoMsg accessoryManagerID:%llx", v2, v3, v4, v5, v6);
}

void sub_100783788()
{
  sub_1000572DC();
  _os_log_debug_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_DEBUG, "BTAccessoryMsgHandler::handleBTAccessoryReadDeviceVersionInfoMsg ", v1, 2u);
}

void sub_1007837C8()
{
  sub_10005732C();
  sub_1003CF064((void *)&_mh_execute_header, v0, v1, "BTAccessoryMsgHandler::handleBTAccessoryGetDeviceColorMsg accessoryManagerID:%llx", v2, v3, v4, v5, v6);
}

void sub_100783830()
{
  sub_10005732C();
  sub_1003CF064((void *)&_mh_execute_header, v0, v1, "BTAccessoryMsgHandler::handleBTAccessoryGetWirelessSharingSpatialMsg accessoryManagerID:%llx", v2, v3, v4, v5, v6);
}

void sub_100783898()
{
  sub_10005732C();
  sub_1003CF064((void *)&_mh_execute_header, v0, v1, "BTAccessoryMsgHandler::handleBTAccessorySetupCommandMsg accessoryManagerID:%llx", v2, v3, v4, v5, v6);
}

void sub_100783900()
{
  sub_10005732C();
  sub_1003CF064((void *)&_mh_execute_header, v0, v1, "BTAccessoryMsgHandler::handleBTAccessorySendRelayMsgMsg accessoryManagerID:%llx", v2, v3, v4, v5, v6);
}

void sub_100783968()
{
  sub_10005732C();
  sub_1003CF064((void *)&_mh_execute_header, v0, v1, "BTAccessoryMsgHandler::handleBTAccessoryUpdateConnPriorityListMsg accessoryManagerID:%llx", v2, v3, v4, v5, v6);
}

void sub_1007839D0()
{
  sub_10005732C();
  sub_1003CF064((void *)&_mh_execute_header, v0, v1, "BTAccessoryMsgHandler::handleBTAccessoryGetNonAppleHAEPairedDevicesMsg accessoryManagerID:%llx", v2, v3, v4, v5, v6);
}

void sub_100783A38()
{
  sub_10005732C();
  sub_1003CF064((void *)&_mh_execute_header, v0, v1, "BTAccessoryMsgHandler::handleBTAccessoryManagerSmartRouteModeMsg accessoryManagerID:%llx", v2, v3, v4, v5, v6);
}

void sub_100783AA0()
{
  sub_10005732C();
  sub_1003CF064((void *)&_mh_execute_header, v0, v1, "BTAccessoryMsgHandler::handleBTAccessoryGetSmartRouteModeMsg accessoryManagerID:%llx", v2, v3, v4, v5, v6);
}

void sub_100783B08()
{
  sub_10005732C();
  sub_1003CF064((void *)&_mh_execute_header, v0, v1, "BTAccessoryMsgHandler::handleBTAccessoryGetSmartRouteSupportMsg accessoryManagerID:%llx", v2, v3, v4, v5, v6);
}

void sub_100783B70()
{
  sub_10005732C();
  sub_1003CF064((void *)&_mh_execute_header, v0, v1, "BTAccessoryMsgHandler::handleBTAccessorySetDeviceStateOnPeerSrcMsg accessoryManagerID:%llx", v2, v3, v4, v5, v6);
}

void sub_100783BD8()
{
  sub_10005732C();
  sub_1003CF064((void *)&_mh_execute_header, v0, v1, "BTAccessoryMsgHandler::handleBTAccessoryGetSpatialAudioPlatformSupportMsg accessoryManagerID:%llx", v2, v3, v4, v5, v6);
}

void sub_100783C40()
{
  sub_10005732C();
  sub_1003CF064((void *)&_mh_execute_header, v0, v1, "BTAccessoryMsgHandler::handleBTAccessoryGetDeviceSoundProfileSupportMsg accessoryManagerID:%llx", v2, v3, v4, v5, v6);
}

void sub_100783CA8()
{
  sub_10005732C();
  sub_1003CF064((void *)&_mh_execute_header, v0, v1, "BTAccessoryMsgHandler::handleBTAccessoryGetDeviceSoundProfileAllowedMsg accessoryManagerID:%llx", v2, v3, v4, v5, v6);
}

void sub_100783D10()
{
  sub_10005732C();
  sub_1003CF064((void *)&_mh_execute_header, v0, v1, "BTAccessoryMsgHandler::handleBTAccessorySetDeviceSoundProfileAllowedMsg accessoryManagerID:%llx", v2, v3, v4, v5, v6);
}

void sub_100783D78()
{
  sub_10005732C();
  sub_1003CF064((void *)&_mh_execute_header, v0, v1, "BTAccessoryMsgHandler::handleBTAccessoryGetCallManagementConfigMsg accessoryManagerID:%llx", v2, v3, v4, v5, v6);
}

void sub_100783DE0()
{
  sub_10005732C();
  sub_1003CF064((void *)&_mh_execute_header, v0, v1, "BTAccessoryMsgHandler::handleBTAccessoryGetFeatureProxCardStatusMsg accessoryManagerID:%llx", v2, v3, v4, v5, v6);
}

void sub_100783E48()
{
  sub_10005732C();
  sub_1003CF064((void *)&_mh_execute_header, v0, v1, "BTAccessoryMsgHandler::handleBTAccessorySetFeatureProxCardStatusMsg accessoryManagerID:%llx", v2, v3, v4, v5, v6);
}

void sub_100783EB0()
{
  sub_10005732C();
  sub_1003CF064((void *)&_mh_execute_header, v0, v1, "BTAccessoryMsgHandler::handleBTAccessoryGetStereoHFPSupportMsg accessoryManagerID:%llx", v2, v3, v4, v5, v6);
}

void sub_100783F18()
{
  sub_10005732C();
  sub_1003CF064((void *)&_mh_execute_header, v0, v1, "BTAccessoryMsgHandler::handleBTAccessoryGetAnnounceMessagesSupport accessoryManagerID:%llx", v2, v3, v4, v5, v6);
}

void sub_100783F80()
{
  sub_10005732C();
  sub_1003CF064((void *)&_mh_execute_header, v0, v1, "BTAccessoryMsgHandler::handleBTAccessoryGetAACPCapabilityBitsMsg accessoryManagerID:%llx", v2, v3, v4, v5, v6);
}

void sub_100783FE8()
{
  sub_10005732C();
  sub_1003CF064((void *)&_mh_execute_header, v0, v1, "BTAccessoryMsgHandler::handleBTAccessoryGetAACPCapabilityIntegerMsg accessoryManagerID:%llx", v2, v3, v4, v5, v6);
}

void sub_100784050()
{
  sub_10005732C();
  sub_1003CF064((void *)&_mh_execute_header, v0, v1, "BTAccessoryMsgHandler::handleBTAccessorySensorStreamTimeSyncEnableMsg accessoryManagerID:%llx", v2, v3, v4, v5, v6);
}

void sub_1007840B8()
{
  sub_10005732C();
  sub_1003CF064((void *)&_mh_execute_header, v0, v1, "BTAccessoryMsgHandler::handleBTAccessoryGetAnnounceCallsSupportMsg accessoryManagerID:%llx", v2, v3, v4, v5, v6);
}

void sub_100784120()
{
  sub_10005732C();
  sub_1003CF064((void *)&_mh_execute_header, v0, v1, "BTAccessoryMsgHandler::handleBTAccessorySpatialAudioModeMsg accessoryManagerID:%llx", v2, v3, v4, v5, v6);
}

void sub_100784188()
{
  sub_10005732C();
  sub_1003CF064((void *)&_mh_execute_header, v0, v1, "BTAccessoryMsgHandler::handleBTAccessoryGetSpatialAudioModeMsg accessoryManagerID:%llx", v2, v3, v4, v5, v6);
}

void sub_1007841F0()
{
  sub_10005732C();
  __int16 v3 = 2048;
  uint64_t v4 = v0;
  _os_log_debug_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_DEBUG, "BTAccessoryMsgHandler::handleBTAccessorySpatialAudioAllowedMsg accessoryManagerID:%llx, spatial mode is %llu", v2, 0x16u);
}

void sub_100784274()
{
  sub_10005732C();
  __int16 v2 = 1024;
  int v3 = 0;
  _os_log_debug_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_DEBUG, "BTAccessoryMsgHandler::handleBTAccessoryGetSpatialAudioAllowedMsg accessoryManagerID:%llx, , spatial mode is %d", v1, 0x12u);
}

void sub_1007842F4()
{
  sub_10005732C();
  sub_1003CF064((void *)&_mh_execute_header, v0, v1, "BTAccessoryMsgHandler::handleBTAccessoryGetAdaptiveLatencyJitterBufferLevelMsg accessoryManagerID:%llx", v2, v3, v4, v5, v6);
}

void sub_10078435C()
{
  sub_10005732C();
  sub_1003CF064((void *)&_mh_execute_header, v0, v1, "BTAccessoryMsgHandler::handleBTAccessoryGetSpatialAudioActiveMsg accessoryManagerID:%llx", v2, v3, v4, v5, v6);
}

void sub_1007843C4()
{
  sub_10005732C();
  sub_1003CF064((void *)&_mh_execute_header, v0, v1, "BTAccessoryMsgHandler::handleBTAccessorySetIsHiddenMsg accessoryManagerID:%llx", v2, v3, v4, v5, v6);
}

void sub_10078442C()
{
  sub_10005732C();
  sub_1003CF064((void *)&_mh_execute_header, v0, v1, "BTAccessoryMsgHandler::handleBTAccessoryGetGyroInformationMsg - accessoryManagerID: %llx", v2, v3, v4, v5, v6);
}

void sub_100784494()
{
  sub_10005732C();
  sub_1003CF064((void *)&_mh_execute_header, v0, v1, "BTAccessoryMsgHandler::handleBTAccessoryGetSensorStreamingFrequencyMsg - accessoryManagerID: %llx", v2, v3, v4, v5, v6);
}

void sub_1007844FC()
{
  sub_10005732C();
  sub_1003CF064((void *)&_mh_execute_header, v0, v1, "BTAccessoryMsgHandler::handleBTAccessoryGetCaseSerialNumbersForAppleProductIdMsg accessoryManagerID:%llx", v2, v3, v4, v5, v6);
}

void sub_100784564()
{
  sub_10005732C();
  sub_1003CF064((void *)&_mh_execute_header, v0, v1, "BTAccessoryMsgHandler::handleBTAccessoryGetCaseSerialNumbersForAppleProductIdsMsg accessoryManagerID:%llx", v2, v3, v4, v5, v6);
}

void sub_1007845CC()
{
  sub_10005732C();
  sub_1003CF064((void *)&_mh_execute_header, v0, v1, "BTAccessoryMsgHandler::handleBTAccessoryGetPrimaryBudSide - accessoryManagerID: %llx", v2, v3, v4, v5, v6);
}

void sub_100784634()
{
  sub_10005732C();
  sub_1003CF064((void *)&_mh_execute_header, v0, v1, "BTAccessoryMsgHandler::handleBTAccessoryGetHeadphoneFeatureValueMsg - accessoryManagerID: %llx", v2, v3, v4, v5, v6);
}

void sub_10078469C()
{
  sub_10005732C();
  sub_1003CF064((void *)&_mh_execute_header, v0, v1, "BTAccessoryMsgHandler::handleBTAccessorySetHeadphoneFeatureValueMsg - accessoryManagerID: %llx", v2, v3, v4, v5, v6);
}

void sub_100784704()
{
  sub_10005732C();
  sub_1003CF064((void *)&_mh_execute_header, v0, v1, "BTAccessoryMsgHandler::handleBTAccessorySendAdaptiveVolumeMessageMsg accessoryManagerID:%llx", v2, v3, v4, v5, v6);
}

void sub_10078476C()
{
  sub_1005EE070();
  sub_100057518((void *)&_mh_execute_header, v0, v1, "handleBTAccessorySendAdaptiveVolumeMessageMsg: incorrect message size received over XPC, expected: %u, got: %zu", v2, v3);
}

void sub_1007847D4()
{
  sub_10005732C();
  sub_1003CF064((void *)&_mh_execute_header, v0, v1, "handleBTAccessorySendPMEConfigMessageMsg accessoryManagerID:%llx", v2, v3, v4, v5, v6);
}

void sub_10078483C()
{
  sub_1005EE070();
  sub_100057518((void *)&_mh_execute_header, v0, v1, "handleBTAccessorySendPMEConfigMessageMsg: incorrect message size received over XPC, expected: %u, got: %zu", v2, v3);
}

void sub_1007848A4(os_log_t log)
{
  int v1 = 136446210;
  int v2 = "fSession == NULL";
  _os_log_fault_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_FAULT, "Assertion failed: %{public}s", (uint8_t *)&v1, 0xCu);
}

void sub_100784928()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to register as an AVRCP controller - result was %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_100784990()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to register as an AVRCP Target - result was %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_1007849F8()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to register AVRCP callbacks - result was %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_100784A60()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to deregister AVRCP callbacks - result was %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_100784AC8()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to deregister as an AVRCP controller - result was %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_100784B30()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to deregister as an AVRCP Target - result was %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_100784B98()
{
  sub_1002B7074();
  sub_100057550(v1, v2, v3, 4.8752e-34);
  sub_10041E7D0((void *)&_mh_execute_header, "Failed to connect to device %{public}s: %{bluetooth:OI_STATUS}u", v4, v5);
  if (*(char *)(v0 + 23) < 0) {
    operator delete(*(void **)v0);
  }
}

void sub_100784BE8()
{
  sub_1002B7074();
  sub_100057550(v1, v2, v3, 4.8752e-34);
  sub_10041E7D0((void *)&_mh_execute_header, "Failed to disconnect from device %{public}s: %{bluetooth:OI_STATUS}u", v4, v5);
  if (*(char *)(v0 + 23) < 0) {
    operator delete(*(void **)v0);
  }
}

void sub_100784C38(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_100784CB0()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to send capability request - result was %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_100784D18(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_100784D90()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Received disconnectCfm without a connectCfm, likely because the connection request was rejected.", v2, v3, v4, v5, v6);
}

void sub_100784DC4()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Skipped queryDeviceCapabilities, Absolute Volume may not set up properly.", v2, v3, v4, v5, v6);
}

void sub_100784DF8()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Stale AVRCP command, device has disconnected already", v2, v3, v4, v5, v6);
}

void sub_100784E2C()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to respond to command: %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_100784E94()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to respond to capability request - result was %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_100784EFC()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to respond to list request - result was %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_100784F64()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to respond to list value request - result was %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_100784FCC()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to respond to 'get player attribute value' request: %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_100785034()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to respond with error to set attribute value request - result was %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_10078509C()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to set attribute value(s) - result was %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_100785104()
{
  sub_1000573EC();
  if (v4 != v5) {
    uint64_t v6 = v3;
  }
  else {
    uint64_t v6 = v1;
  }
  sub_100057464(v2, v6, 4.8751e-34);
  sub_100057404((void *)&_mh_execute_header, v7, v8, "device %{public}s not found", v9);
  if (*(char *)(v0 + 23) < 0) {
    operator delete(*(void **)v0);
  }
}

void sub_100785158()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to respond to 'get play status' request: %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_1007851C0()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to send response to SetAddressedPlayer: %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_100785228()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to send browsing response to SetBrowsedPlayer: %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_100785290(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_100785308()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to send browsing response to ChangePath: %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_100785370(uint64_t *a1, uint64_t a2)
{
  sub_1003591A4(*a1, a2);
  sub_100057450();
  sub_100057470();
  sub_100360CB0((void *)&_mh_execute_header, v2, v3, "Cannot find the MTU for device %{public}s", v4, v5, v6, v7, v8, (uint64_t)__p, v11, v12, v14);
  if (v13 < 0) {
    operator delete(__pa);
  }
}

void sub_100785404()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to send browsing response to GetFolderItems: %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_10078546C(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_1007854E4(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_10078555C(uint64_t *a1, uint64_t a2)
{
  sub_1003591A4(*a1, a2);
  sub_100057450();
  sub_100057470();
  sub_100360CB0((void *)&_mh_execute_header, v2, v3, "Cannot find the MTU for device %{public}s", v4, v5, v6, v7, v8, (uint64_t)__p, v11, v12, v14);
  if (v13 < 0) {
    operator delete(__pa);
  }
}

void sub_1007855F0()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to send browsing response to GetItemAttributes: %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_100785658(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_1007856D0()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to send browsing response to Search: %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_100785738()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to send browsing response to GetTotalNumberOfItems: %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_1007857A0()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to send response to PlayItem: %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_100785808()
{
  sub_1000573EC();
  if (v4 != v5) {
    uint64_t v6 = v3;
  }
  else {
    uint64_t v6 = v1;
  }
  sub_100057464(v2, v6, 4.8751e-34);
  sub_100057404((void *)&_mh_execute_header, v7, v8, "device %{public}s not found. Dropping", v9);
  if (*(char *)(v0 + 23) < 0) {
    operator delete(*(void **)v0);
  }
}

void sub_10078585C(uint64_t a1, uint64_t a2)
{
  sub_1003591A4(*(void *)(a1 + 64), a2);
  sub_100057450();
  sub_100057470();
  sub_100360CB0((void *)&_mh_execute_header, v2, v3, "Dropping 'GetImageProperties' response as BIP connection no longer exists with device %{public}s", v4, v5, v6, v7, v8, (uint64_t)__p, v11, v12, v14);
  if (v13 < 0) {
    operator delete(__pa);
  }
}

void sub_1007858F0()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to send response to GetImageProperties: %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_100785958(uint64_t a1, uint64_t a2)
{
  sub_1003591A4(*(void *)(a1 + 64), a2);
  sub_100057450();
  sub_100057470();
  sub_100360CB0((void *)&_mh_execute_header, v2, v3, "Dropping 'GetImage' response as BIP connection no longer exists with device %{public}s", v4, v5, v6, v7, v8, (uint64_t)__p, v11, v12, v14);
  if (v13 < 0) {
    operator delete(__pa);
  }
}

void sub_1007859EC()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to send response to GetImage: %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_100785A54(uint64_t a1, uint64_t a2)
{
  sub_1003591A4(*(void *)(a1 + 64), a2);
  sub_100057450();
  sub_100057470();
  sub_100360CB0((void *)&_mh_execute_header, v2, v3, "Dropping 'GetLinkedThumbnail' response as BIP connection no longer exists with device %{public}s", v4, v5, v6, v7, v8, (uint64_t)__p, v11, v12, v14);
  if (v13 < 0) {
    operator delete(__pa);
  }
}

void sub_100785AE8()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to send response to GetLinkedThumbnail: %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_100785B50()
{
  sub_1002B7074();
  sub_100057550(v1, v2, v3, 4.8752e-34);
  sub_10041E7D0((void *)&_mh_execute_header, "Failed to respond to 'get element attributes' request on device %{public}s: %{bluetooth:OI_STATUS}u", v4, v5);
  if (*(char *)(v0 + 23) < 0) {
    operator delete(*(void **)v0);
  }
}

void sub_100785BA0()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to register for volume change notifications - result was %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_100785C08()
{
  sub_1002B7074();
  sub_100057550(v1, v2, v3, 4.8752e-34);
  sub_10041E7D0((void *)&_mh_execute_header, "Failed to re-register for absolute volume change events on device %{public}s - result was %{bluetooth:OI_STATUS}u", v4, v5);
  if (*(char *)(v0 + 23) < 0) {
    operator delete(*(void **)v0);
  }
}

void sub_100785C58(uint64_t *a1, uint64_t a2)
{
  sub_1003591A4(*a1, a2);
  sub_100057450();
  sub_100057470();
  sub_100360CB0((void *)&_mh_execute_header, v2, v3, "Failed to set volume on the remote device %{public}s", v4, v5, v6, v7, v8, (uint64_t)__p, v11, v12, v14);
  if (v13 < 0) {
    operator delete(__pa);
  }
}

void sub_100785CEC()
{
  sub_1002B7074();
  sub_100057550(v1, v2, v3, 4.8752e-34);
  sub_10041E7D0((void *)&_mh_execute_header, "Failed to send mute button release to device %{public}s - result was %{bluetooth:OI_STATUS}u", v4, v5);
  if (*(char *)(v0 + 23) < 0) {
    operator delete(*(void **)v0);
  }
}

void sub_100785D3C()
{
  sub_1002B7074();
  sub_100057550(v1, v2, v3, 4.8752e-34);
  sub_10041E7D0((void *)&_mh_execute_header, "Failed to send mute button press to device %{public}s - result was %{bluetooth:OI_STATUS}u", v4, v5);
  if (*(char *)(v0 + 23) < 0) {
    operator delete(*(void **)v0);
  }
}

void sub_100785D8C()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "initAVRCPFastConnectL2CAP error creating AVRCP signal", v2, v3, v4, v5, v6);
}

void sub_100785DC0()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "composeAVRCPDescriptor error getting browse L2CAP data", v2, v3, v4, v5, v6);
}

void sub_100785DF4()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "composeAVRCPDescriptor error getting signaling L2CAP data", v2, v3, v4, v5, v6);
}

void sub_100785E28(uint8_t *buf, unsigned char *a2, os_log_t log)
{
  *uint64_t buf = 0;
  *a2 = 0;
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "parseAVRCPDescriptor L2CAP signal channel not found", buf, 2u);
}

void sub_100785E68(uint8_t *buf, unsigned char *a2, os_log_t log)
{
  *uint64_t buf = 0;
  *a2 = 0;
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "parseAVRCPDescriptor L2CAP browse channel not found", buf, 2u);
}

void sub_100785EA8(uint64_t a1, NSObject *a2)
{
  int v2 = 138412290;
  uint64_t v3 = a1;
  _os_log_error_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_ERROR, "Failed to validate format string: %@", (uint8_t *)&v2, 0xCu);
}

void sub_100785F20(os_log_t log)
{
  *(_WORD *)uint64_t v1 = 0;
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "User responded with unknown response. Not unsetting tag 'RequiresANCSAuth'. Will ask again later", v1, 2u);
}

void sub_100785F64()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "No pairing callbacks registered", v2, v3, v4, v5, v6);
}

void sub_100785F98()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Pairing agent is not started", v2, v3, v4, v5, v6);
}

void sub_100785FCC()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "No pairing attempts currently pending", v2, v3, v4, v5, v6);
}

void sub_100786000()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "SMP_DeriveLTKFromLinkKey failed with error %d", v2, v3, v4, v5, v6);
}

void sub_100786068()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "getLinkKey failed with error %d", v2, v3, v4, v5, v6);
}

void sub_1007860D0()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Attempting to dispatch a cancellation event without creating one", v2, v3, v4, v5, v6);
}

void sub_100786104()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to start Classic SMP Pairing, no key derivation, classic pairing is done. (status=%d)", v2, v3, v4, v5, v6);
}

void sub_10078616C()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Encryption is not AES_CCM, not doing Classic SMP", v2, v3, v4, v5, v6);
}

void sub_1007861A0()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Failed to grab paired devices", v2, v3, v4, v5, v6);
}

void sub_1007861D4()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Stack is not running - rejecting pairing attempt", v2, v3, v4, v5, v6);
}

void sub_100786208()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "No pairing agent - rejecting pairing attempt", v2, v3, v4, v5, v6);
}

void sub_10078623C()
{
  sub_1000573EC();
  if (v4 != v5) {
    uint64_t v6 = v3;
  }
  else {
    uint64_t v6 = v1;
  }
  sub_100057464(v2, v6, 4.8751e-34);
  sub_100057404((void *)&_mh_execute_header, v7, v8, "We already have OOB data for device %{public}s, aborting pincode pairing", v9);
  if (*(char *)(v0 + 23) < 0) {
    operator delete(*(void **)v0);
  }
}

void sub_100786290()
{
  sub_1000573EC();
  if (v4 != v5) {
    uint64_t v6 = v3;
  }
  else {
    uint64_t v6 = v1;
  }
  sub_100057464(v2, v6, 4.8751e-34);
  sub_100057404((void *)&_mh_execute_header, v7, v8, "We already have OOB data for device %{public}s, aborting numeric comparison pairing", v9);
  if (*(char *)(v0 + 23) < 0) {
    operator delete(*(void **)v0);
  }
}

void sub_1007862E4()
{
  sub_1000573EC();
  if (v4 != v5) {
    uint64_t v6 = v3;
  }
  else {
    uint64_t v6 = v1;
  }
  sub_100057464(v2, v6, 4.8751e-34);
  sub_100057404((void *)&_mh_execute_header, v7, v8, "We already have OOB data for device %{public}s, aborting passkey pairing", v9);
  if (*(char *)(v0 + 23) < 0) {
    operator delete(*(void **)v0);
  }
}

void sub_100786338()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Stack is not running - cannot deliver local OOB Data", v2, v3, v4, v5, v6);
}

void sub_10078636C()
{
  sub_1000573EC();
  if (v4 != v5) {
    uint64_t v6 = v3;
  }
  else {
    uint64_t v6 = v1;
  }
  sub_100057464(v2, v6, 4.8751e-34);
  sub_100057404((void *)&_mh_execute_header, v7, v8, "Pairing timedout, request for device %{public}s not found", v9);
  if (*(char *)(v0 + 23) < 0) {
    operator delete(*(void **)v0);
  }
}

void sub_1007863C0()
{
  sub_1000573EC();
  if (v4 != v5) {
    uint64_t v6 = v3;
  }
  else {
    uint64_t v6 = v1;
  }
  sub_100057464(v2, v6, 4.8751e-34);
  sub_100057404((void *)&_mh_execute_header, v7, v8, "Reached pairing timeout for pending attempt with device %{public}s", v9);
  if (*(char *)(v0 + 23) < 0) {
    operator delete(*(void **)v0);
  }
}

void sub_100786414()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Stack is not running", v2, v3, v4, v5, v6);
}

void sub_100786448(uint8_t *buf, uint64_t a2, os_log_t log)
{
  *(_DWORD *)uint64_t buf = 136315394;
  *(void *)(buf + 4) = "setPincode";
  *((_WORD *)buf + 6) = 2048;
  *(void *)(buf + 14) = a2;
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "%s: Rejecting Pairing Request because PIN code length is %zu", buf, 0x16u);
}

void sub_1007864A4()
{
  sub_1000573EC();
  if (v4 != v5) {
    uint64_t v6 = v3;
  }
  else {
    uint64_t v6 = v1;
  }
  sub_100057464(v2, v6, 4.8751e-34);
  sub_100057404((void *)&_mh_execute_header, v7, v8, "No authentification request found for device %{public}s", v9);
  if (*(char *)(v0 + 23) < 0) {
    operator delete(*(void **)v0);
  }
}

void sub_1007864F8()
{
  sub_1000573EC();
  if (v4 != v5) {
    uint64_t v6 = v3;
  }
  else {
    uint64_t v6 = v1;
  }
  sub_100057464(v2, v6, 4.8751e-34);
  sub_100057404((void *)&_mh_execute_header, v7, v8, "No pending pairing attempts for device %{public}s", v9);
  if (*(char *)(v0 + 23) < 0) {
    operator delete(*(void **)v0);
  }
}

void sub_10078654C(uint8_t *buf, NSObject *a2)
{
  *(_DWORD *)uint64_t buf = 136446210;
  *(void *)(buf + 4) = "NULL";
  _os_log_error_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_ERROR, "Pairing failure reported for device %{public}s", buf, 0xCu);
}

void sub_100786598()
{
  sub_1000573EC();
  if (v4 != v5) {
    uint64_t v6 = v3;
  }
  else {
    uint64_t v6 = v1;
  }
  sub_100057464(v2, v6, 4.8751e-34);
  sub_100057404((void *)&_mh_execute_header, v7, v8, "Pairing failure reported for device %{public}s", v9);
  if (*(char *)(v0 + 23) < 0) {
    operator delete(*(void **)v0);
  }
}

void sub_1007865EC(uint64_t a1, NSObject *a2)
{
  sub_100474E18(a1, __p);
  if (v5 >= 0) {
    uint64_t v3 = __p;
  }
  else {
    uint64_t v3 = (void **)__p[0];
  }
  *(_DWORD *)uint64_t buf = 136446210;
  int v7 = v3;
  _os_log_error_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_ERROR, "Unpairing device %{public}s - failed as stack is not running", buf, 0xCu);
  if (v5 < 0) {
    operator delete(__p[0]);
  }
}

void sub_1007866A4()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "KeyChain delete link-key failed", v2, v3, v4, v5, v6);
}

void sub_1007866D8(void *a1, uint64_t a2, NSObject *a3)
{
  *(_DWORD *)a2 = 138412290;
  *(void *)(a2 + 4) = a1;
  sub_100057404((void *)&_mh_execute_header, a2, a3, "LE device for addr %@ does not exist", (uint8_t *)a2);
}

void sub_100786724()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Error: Unrecognized pairingType %d", v2, v3, v4, v5, v6);
}

void sub_10078678C()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "privacySyncAlertCB received with no pending device", v2, v3, v4, v5, v6);
}

void sub_1007867C0()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "No pending devices for _showPrivacySyncAlertForNextPendingDevice", v2, v3, v4, v5, v6);
}

void sub_1007867F4()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Failed to create run loop source", v2, v3, v4, v5, v6);
}

void sub_100786830(uint64_t a1, uint64_t a2, NSObject *a3)
{
  *(_DWORD *)uint64_t v3 = 136446466;
  *(void *)&v3[4] = a1;
  *(_WORD *)&uint8_t v3[12] = 2082;
  *(void *)&uint8_t v3[14] = a2;
  sub_1000574F8((void *)&_mh_execute_header, a2, a3, "XPC service \"%{public}s\" server error: %{public}s", *(void *)v3, *(void *)&v3[8], *(void *)&v3[16]);
}

void sub_1007868A8(uint64_t a1, uint64_t a2, NSObject *a3)
{
  *(_DWORD *)uint64_t v3 = 136446466;
  *(void *)&v3[4] = a1;
  *(_WORD *)&uint8_t v3[12] = 2114;
  *(void *)&uint8_t v3[14] = a2;
  sub_1000574F8((void *)&_mh_execute_header, a2, a3, "Unexpected XPC service \"%{public}s\" server event: %{public}@", *(void *)v3, *(void *)&v3[8], *(void *)&v3[16]);
}

void sub_100786920(os_log_t log)
{
  int v1 = 136446210;
  uint64_t v2 = "it != fClientInfoMap.end()";
  _os_log_fault_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_FAULT, "Assertion failed: %{public}s", (uint8_t *)&v1, 0xCu);
}

void sub_1007869A4(os_log_t log)
{
  *(_WORD *)int v1 = 0;
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "OOB data for this device is already present", v1, 2u);
}

void sub_1007869E8()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "OI_SECMGR_ReadLocalOobExtendedData returned %d", v2, v3, v4, v5, v6);
}

void sub_100786A50()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "OI_SECMGR_ReadLocalOobData returned %d", v2, v3, v4, v5, v6);
}

void sub_100786AB8(os_log_t log)
{
  *(_WORD *)uint64_t v1 = 0;
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "User responded with unknown response. Not updating 'isUsingLowSecurity' status.", v1, 2u);
}

void sub_100786AFC()
{
  sub_10061D874();
  sub_10061D8A4((void *)&_mh_execute_header, v0, v1, "Failed to set new link key for %{private,bluetooth:BD_ADDR,mask.hash}.6P", v2, v3, v4, v5, v6);
}

void sub_100786B64()
{
  sub_10061D874();
  sub_10061D8A4((void *)&_mh_execute_header, v0, v1, "Invalid device %{private,bluetooth:BD_ADDR,mask.hash}.6P", v2, v3, v4, v5, v6);
}

void sub_100786BCC()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "OI_HCI_ReadEncryptionKeySize failed: returned %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_100786C34()
{
  sub_10061D874();
  __int16 v3 = 1024;
  int v4 = v0;
  _os_log_error_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_ERROR, "Encryption key size for device %{private,bluetooth:BD_ADDR,mask.hash}.6P is %u", v2, 0x22u);
}

void sub_100786CB8()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Read Encryption Key Size failed with error %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_100786D20(os_log_t log)
{
  *(_WORD *)uint64_t v1 = 0;
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "Audio Timesync: Getting BTTimeSync referene failed: make sure that you are registed with TimeSync", v1, 2u);
}

void sub_100786D64(os_log_t log)
{
  *(_WORD *)uint64_t v1 = 0;
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "Audio Timesync: Invalid Spedup parameters: Targeted input will not work with default speed", v1, 2u);
}

void sub_100786DB0(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_100786E28(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_100786E94()
{
  sub_1000574EC();
  __int16 v3 = 1024;
  int v4 = v0;
  _os_log_error_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_ERROR, "Failed to set MTU to %d with result %{bluetooth:OI_STATUS}u", v2, 0xEu);
}

void sub_100786F1C(uint64_t a1)
{
  id v1 = sub_10062E468(a1);
  sub_10005732C();
  sub_1000E37A0((void *)&_mh_execute_header, v2, v3, "No primary services found on device \"%@\"", v4, v5, v6, v7, v8);
}

void sub_100786F9C(uint64_t a1)
{
  id v7 = *(id *)(a1 + 16);
  sub_10062E448((void *)&_mh_execute_header, v1, v2, "No characteristics found in range [0x%04x, 0x%04x] on device \"%@\"", v3, v4, v5, v6, 2u);
}

void sub_100787050()
{
  sub_1003FAE54();
  id v1 = sub_1000575C8(v0);
  sub_10062E408();
  sub_10062E448((void *)&_mh_execute_header, v2, v3, "No characteristic value could be read at handle 0x%04x on device \"%@\" - result was %{bluetooth:OI_STATUS}u", v4, v5, v6, v7, v8);
}

void sub_1007870D8(uint64_t a1, uint64_t a2)
{
  id v2 = sub_10062E42C(a1, a2);
  sub_10062E3F0();
  sub_1000DDF08((void *)&_mh_execute_header, v3, v4, "Couldn't find characteristic at handle 0x%04x on device \"%@\"", v5, v6, v7, v8, v9);
}

void sub_100787160()
{
  sub_1000574EC();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Characteristic handle 0x%04x is not readable!", v2, v3, v4, v5, v6);
}

void sub_1007871CC(uint64_t a1, uint64_t a2)
{
  id v2 = sub_10062E42C(a1, a2);
  sub_10062E3F0();
  sub_1000DDF08((void *)&_mh_execute_header, v3, v4, "Handle 0x%04x is not a characteristic on device \"%@\"", v5, v6, v7, v8, v9);
}

void sub_100787254(char *a1, uint64_t a2, uint64_t a3, NSObject *a4)
{
  if (a1[23] >= 0) {
    uint64_t v7 = a1;
  }
  else {
    uint64_t v7 = *(char **)a1;
  }
  int v8 = *(unsigned __int16 *)(a2 + 64);
  int v9 = *(unsigned __int16 *)(a2 + 66);
  id v10 = *(id *)(a2 + 16);
  *(_DWORD *)a3 = 136446978;
  *(void *)(a3 + 4) = v7;
  *(_WORD *)(a3 + 12) = 1024;
  *(_DWORD *)(a3 + 14) = v8;
  *(_WORD *)(a3 + 18) = 1024;
  *(_DWORD *)(a3 + 20) = v9;
  *(_WORD *)(a3 + 24) = 2112;
  *(void *)(a3 + 26) = v10;
  _os_log_error_impl((void *)&_mh_execute_header, a4, OS_LOG_TYPE_ERROR, "No characteristic values with UUID %{public}s could be read in range [0x%04x, 0x%04x] on device \"%@\"", (uint8_t *)a3, 0x22u);
  if (a1[23] < 0) {
    operator delete(*(void **)a1);
  }
}

void sub_100787320()
{
  sub_1003FAE54();
  id v1 = sub_1000575C8(v0);
  sub_10062E408();
  sub_10062E448((void *)&_mh_execute_header, v2, v3, "No characteristic value could be read at handle 0x%04x on device \"%@\" - result was %{bluetooth:OI_STATUS}u", v4, v5, v6, v7, v8);
}

void sub_1007873A8()
{
  sub_1003FAE54();
  id v1 = sub_1000575C8(v0);
  sub_10062E408();
  sub_10062E448((void *)&_mh_execute_header, v2, v3, "No descriptor could be read at handle 0x%04x on device \"%@\" - result was %{bluetooth:OI_STATUS}u", v4, v5, v6, v7, v8);
}

void sub_100787430()
{
  sub_1003FAE54();
  id v1 = sub_1000575C8(v0);
  sub_10062E408();
  sub_10062E448((void *)&_mh_execute_header, v2, v3, "Failed to write characteristic value at handle 0x%04x on device \"%@\" - result was %{bluetooth:OI_STATUS}u", v4, v5, v6, v7, v8);
}

void sub_1007874B4()
{
  sub_1003FAE54();
  id v1 = sub_1000575C8(v0);
  sub_10062E408();
  sub_10062E448((void *)&_mh_execute_header, v2, v3, "Failed to write long characteristic value at handle 0x%04x on device \"%@\" - result was %{bluetooth:OI_STATUS}u", v4, v5, v6, v7, v8);
}

void sub_100787538()
{
  sub_1003FAE54();
  id v1 = sub_1000575C8(v0);
  sub_10062E408();
  sub_10062E448((void *)&_mh_execute_header, v2, v3, "Failed to write descriptor at handle 0x%04x on device \"%@\" - result was %{bluetooth:OI_STATUS}u", v4, v5, v6, v7, v8);
}

void sub_1007875BC(uint64_t a1)
{
  id v1 = sub_10062E468(a1);
  sub_10005732C();
  sub_1000E37A0((void *)&_mh_execute_header, v2, v3, "Failed to locate GAP device name characteristic on device \"%@\"", v4, v5, v6, v7, v8);
}

void sub_10078763C(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_1007876A8(uint64_t a1)
{
  id v1 = sub_10062E468(a1);
  sub_10005732C();
  sub_1000E37A0((void *)&_mh_execute_header, v2, v3, "Failed to locate GAP primary service on device \"%@\"", v4, v5, v6, v7, v8);
}

void sub_100787728(uint64_t a1)
{
  id v1 = sub_10062E468(a1);
  sub_10005732C();
  sub_1000E37A0((void *)&_mh_execute_header, v2, v3, "Failed to locate GAP primary service on device \"%@\"", v4, v5, v6, v7, v8);
}

void sub_1007877A8(uint64_t a1, uint64_t a2)
{
  id v2 = sub_10062E42C(a1, a2);
  sub_10062E3F0();
  sub_1000DDF08((void *)&_mh_execute_header, v3, v4, "Unable to find service for characteristic handle 0x%04x on device \"%@\"", v5, v6, v7, v8, v9);
}

void sub_100787830(uint64_t a1, uint64_t a2)
{
  id v2 = sub_10062E42C(a1, a2);
  sub_10062E3F0();
  sub_1000DDF08((void *)&_mh_execute_header, v3, v4, "Couldn't find handle 0x%04x on device \"%@\"", v5, v6, v7, v8, v9);
}

void sub_1007878B8(uint64_t a1, uint64_t a2)
{
  id v2 = sub_10062E42C(a1, a2);
  sub_10062E3F0();
  sub_1000DDF08((void *)&_mh_execute_header, v3, v4, "Couldn't find characteristic at handle 0x%04x on device \"%@\"", v5, v6, v7, v8, v9);
}

void sub_100787940(uint64_t a1, uint64_t a2)
{
  id v2 = sub_10062E42C(a1, a2);
  sub_10062E3F0();
  sub_1000DDF08((void *)&_mh_execute_header, v3, v4, "Characteristic at handle 0x%04x does not support notifications or indications on device \"%@\"", v5, v6, v7, v8, v9);
}

void sub_1007879C8(uint64_t a1, uint64_t a2)
{
  id v2 = sub_10062E42C(a1, a2);
  sub_10062E3F0();
  sub_1000DDF08((void *)&_mh_execute_header, v3, v4, "Handle 0x%04x is not a characteristic on device \"%@\"", v5, v6, v7, v8, v9);
}

void sub_100787A50(uint64_t a1, uint64_t a2)
{
  id v2 = sub_10062E42C(a1, a2);
  sub_10062E3F0();
  sub_1000DDF08((void *)&_mh_execute_header, v3, v4, "Couldn't find handle 0x%04x on device \"%@\"", v5, v6, v7, v8, v9);
}

void sub_100787AD8(uint64_t a1, uint64_t a2)
{
  id v2 = sub_10062E42C(a1, a2);
  sub_10062E3F0();
  sub_1000DDF08((void *)&_mh_execute_header, v3, v4, "Couldn't find characteristic at handle 0x%04x on device \"%@\"", v5, v6, v7, v8, v9);
}

void sub_100787B60(uint64_t a1, uint64_t a2)
{
  id v2 = sub_10062E42C(a1, a2);
  sub_10062E3F0();
  sub_1000DDF08((void *)&_mh_execute_header, v3, v4, "Characteristic at handle 0x%04x does not support notifications or indications on device \"%@\"", v5, v6, v7, v8, v9);
}

void sub_100787BE8(uint64_t a1, uint64_t a2)
{
  id v2 = sub_10062E42C(a1, a2);
  sub_10062E3F0();
  sub_1000DDF08((void *)&_mh_execute_header, v3, v4, "Handle 0x%04x is not a characteristic on device \"%@\"", v5, v6, v7, v8, v9);
}

void sub_100787C70(uint64_t a1, uint64_t a2)
{
  id v2 = sub_10062E42C(a1, a2);
  sub_10062E3F0();
  sub_1000DDF08((void *)&_mh_execute_header, v3, v4, "Couldn't find handle 0x%04x on device \"%@\"", v5, v6, v7, v8, v9);
}

void sub_100787CF8()
{
  sub_1000574EC();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Characteristic handle 0x%04x is not writeable w/o response!", v2, v3, v4, v5, v6);
}

void sub_100787D64()
{
  sub_1000574EC();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Characteristic handle 0x%04x is not writeable!", v2, v3, v4, v5, v6);
}

void sub_100787DD0(uint64_t a1, uint64_t a2)
{
  id v2 = sub_10062E42C(a1, a2);
  sub_10062E3F0();
  sub_1000DDF08((void *)&_mh_execute_header, v3, v4, "Handle 0x%04x is not a characteristic on device \"%@\"", v5, v6, v7, v8, v9);
}

void sub_100787E58(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_100787ED0(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

uint64_t sub_100787F48()
{
  sub_10062E480();
  return (*(uint64_t (**)(void))(v0 + 8))();
}

void sub_100787F7C(uint64_t a1)
{
  id v1 = sub_10062E468(a1);
  sub_10005732C();
  sub_1000E37A0((void *)&_mh_execute_header, v2, v3, "Failed to locate GAP primary service on device \"%@\"", v4, v5, v6, v7, v8);
}

void sub_100787FFC(uint64_t a1)
{
  id v1 = sub_10062E468(a1);
  sub_10005732C();
  sub_1000E37A0((void *)&_mh_execute_header, v2, v3, "Failed to locate GAP primary service on device \"%@\"", v4, v5, v6, v7, v8);
}

void sub_10078807C(uint64_t a1)
{
  id v1 = sub_10062E468(a1);
  sub_10005732C();
  sub_1000E37A0((void *)&_mh_execute_header, v2, v3, "Failed to locate GAP reconnection characteristic handle on device \"%@\"", v4, v5, v6, v7, v8);
}

void sub_1007880FC(uint64_t a1)
{
  id v1 = sub_10062E468(a1);
  sub_10005732C();
  sub_1000E37A0((void *)&_mh_execute_header, v2, v3, "Failed to locate GATT primary service on device \"%@\"", v4, v5, v6, v7, v8);
}

void sub_10078817C(uint64_t a1)
{
  if (*(char *)(a1 + 23) < 0) {
    operator delete(*(void **)a1);
  }
}

void sub_100788190()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to register WiAP v2 SDP service record - result was %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_1007881F8()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to register SDP service record - result was %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_100788260()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to register RFCOMM server - result was %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_1007882C8(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_10078833C()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Cannot connect to NULL device", v2, v3, v4, v5, v6);
}

void sub_100788370()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "No rfcomm channel found for this profile", v2, v3, v4, v5, v6);
}

void sub_1007883A4()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Wireless IAP connection failed - result was %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_10078840C(char *a1, uint8_t *buf, os_log_t log)
{
  if (a1[23] >= 0) {
    uint64_t v4 = a1;
  }
  else {
    uint64_t v4 = *(char **)a1;
  }
  *(_DWORD *)uint64_t buf = 136446210;
  *(void *)(buf + 4) = v4;
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "Wireless IAP Service is not supported by device %{public}s", buf, 0xCu);
  if (a1[23] < 0) {
    operator delete(*(void **)a1);
  }
}

void sub_100788480(char a1, int a2, os_log_t log)
{
  uint64_t v3 = "accept";
  if ((a1 & 1) == 0) {
    uint64_t v3 = "deny";
  }
  int v4 = 136446466;
  uint64_t v5 = v3;
  __int16 v6 = 1024;
  int v7 = a2;
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "Failed to %{public}s connection attempt - result was %{bluetooth:OI_STATUS}u", (uint8_t *)&v4, 0x12u);
}

void sub_100788520()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Error retrieving device from handle", v2, v3, v4, v5, v6);
}

void sub_100788554(uint64_t a1, NSObject *a2)
{
  sub_100474E18(a1, __p);
  if (v5 >= 0) {
    uint64_t v3 = __p;
  }
  else {
    uint64_t v3 = (void **)__p[0];
  }
  *(_DWORD *)uint64_t buf = 136446210;
  int v7 = v3;
  _os_log_error_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_ERROR, "Failed to open serial port for device %{public}s", buf, 0xCu);
  if (v5 < 0) {
    operator delete(__p[0]);
  }
}

void sub_10078860C()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Could not establish connection to IAP", v2, v3, v4, v5, v6);
}

void sub_100788640()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Could not establish endpoint to IAP", v2, v3, v4, v5, v6);
}

void sub_100788674(uint64_t a1, NSObject *a2)
{
  int v2 = 138412290;
  uint64_t v3 = a1;
  _os_log_error_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_ERROR, "WiAPProfile::connectedCfm: Endpoint %@ doesn't exist", (uint8_t *)&v2, 0xCu);
}

void sub_1007886EC()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Cannot write data to NULL device", v2, v3, v4, v5, v6);
}

void sub_100788720()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Failed to queue data for processing", v2, v3, v4, v5, v6);
}

void sub_100788754()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Cannot read from NULL device", v2, v3, v4, v5, v6);
}

void sub_100788788()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to send data to BT device - result was %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_1007887F0()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Invalid write - result was %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_100788858(uint8_t *buf, unsigned char *a2, os_log_t log)
{
  *uint64_t buf = 0;
  *a2 = 0;
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "Invalid format", buf, 2u);
}

void sub_100788898(int a1, int a2, os_log_t log)
{
  v3[0] = 67109376;
  v3[1] = a1;
  __int16 v4 = 1024;
  int v5 = a2;
  _os_log_fault_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_FAULT, "Num frames to send (%d) exceeds maximum frame count (%d)", (uint8_t *)v3, 0xEu);
}

void sub_100788920()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Forcing init sequence on connection complete instead of link ready", v2, v3, v4, v5, v6);
}

void sub_100788954()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Ignoring invalid override value (%d) for unpaired databases to be cached", v2, v3, v4, v5, v6);
}

void sub_1007889BC()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "GATT Init failed with status %d", v2, v3, v4, v5, v6);
}

void sub_100788A24()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Indication for an invalid handle, ignoring", v2, v3, v4, v5, v6);
}

void sub_100788A58()
{
  sub_1000572DC();
  _os_log_debug_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_DEBUG, "Not detecting built in services", v1, 2u);
}

void sub_100788A98()
{
  sub_10005732C();
  sub_1000572F4((void *)&_mh_execute_header, v0, v1, "Invalid database for device %@", v2, v3, v4, v5, v6);
}

void sub_100788B00(void *a1, uint8_t *buf, os_log_t log)
{
  *(_DWORD *)uint64_t buf = 138412290;
  *(void *)(buf + 4) = a1;
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "Failed to redact HID reports for device %@", buf, 0xCu);
}

void sub_100788B58()
{
  sub_10005732C();
  sub_1000572F4((void *)&_mh_execute_header, v0, v1, "MIDI: Invalid database for device %@", v2, v3, v4, v5, v6);
}

void sub_100788BC0()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "MIDI: No manufacturer name to identify apple device - No AutoConnect", v2, v3, v4, v5, v6);
}

void sub_100788BF4(char a1, uint64_t a2, uint8_t *buf, os_log_t log)
{
  *(_DWORD *)uint64_t buf = 67109376;
  *((_DWORD *)buf + 1) = a1 & 1;
  *((_WORD *)buf + 4) = 2048;
  *(void *)(buf + 10) = a2;
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "MIDI: ff %d, midi %p", buf, 0x12u);
}

void sub_100788C50()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "MIDI: should notify builtin service returned false - No AutoConnect", v2, v3, v4, v5, v6);
}

void sub_100788C84()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "LE disconnect failed with result %d", v2, v3, v4, v5, v6);
}

void sub_100788CEC()
{
  sub_1000572DC();
  _os_log_fault_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_FAULT, "Gatt Gateway can not find device in scheduler map!", v1, 2u);
}

void sub_100788D2C()
{
  sub_10005732C();
  sub_1000572F4((void *)&_mh_execute_header, v0, v1, "Failed to create a GATT session for device \"%{public}@\"", v2, v3, v4, v5, v6);
}

void sub_100788D94(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_100788E0C(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_100788E84(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_100788EFC(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_100788F74(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_100788FEC(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_100789064()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Unhandled stack status: %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_1007890CC()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "LeDeviceManager wasn't tracking a device for connection handle", v2, v3, v4, v5, v6);
}

void sub_100789100()
{
  sub_10005732C();
  sub_1000572F4((void *)&_mh_execute_header, v0, v1, "No database exists for device \"%{public}@\" ", v2, v3, v4, v5, v6);
}

void sub_100789168()
{
  sub_10005732C();
  sub_1000572F4((void *)&_mh_execute_header, v0, v1, "Received a notification for an unknown device %{public}@. Ignoring.", v2, v3, v4, v5, v6);
}

void sub_1007891D0()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Received an indication on handle 0x%04x but no session is subscribed", v2, v3, v4, v5, v6);
}

void sub_100789238(unsigned __int16 a1, unsigned __int16 a2, os_log_t log)
{
  v3[0] = 67109376;
  v3[1] = a1;
  __int16 v4 = 1024;
  int v5 = a2;
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "Received \"service changed\" notification for [0x%04x;0x%04x] for an unknown device. Ignoring.",
    (uint8_t *)v3,
    0xEu);
}

void sub_1007892C8(uint64_t a1, char *a2, uint8_t *buf, os_log_t log)
{
  if (a2[23] >= 0) {
    int v5 = a2;
  }
  else {
    int v5 = *(char **)a2;
  }
  *(_DWORD *)uint64_t buf = 138543618;
  *(void *)(buf + 4) = a1;
  *((_WORD *)buf + 6) = 2082;
  *(void *)(buf + 14) = v5;
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "Dropping notification from device \"%{public}@\" of non-characteristic value attribute \"%{public}s\"", buf, 0x16u);
  if (a2[23] < 0) {
    operator delete(*(void **)a2);
  }
}

uint64_t sub_10078934C(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 8))();
}

void sub_100789370()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Unable to read RSSI : %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_1007893D8()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Error parsing XPC Args", v2, v3, v4, v5, v6);
}

void sub_10078940C()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Unable to change connection packet type : %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_100789474()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Error retrieving connection handle\n", v2, v3, v4, v5, v6);
}

void sub_1007894A8()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "ReadTransmitPowerLevel returned error %d", v2, v3, v4, v5, v6);
}

void sub_100789510()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Received XPC ReadTransmitPowerLevel request while another request was in flight. Dropping request", v2, v3, v4, v5, v6);
}

void sub_100789544()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Error in Country Code Action : %d", v2, v3, v4, v5, v6);
}

void sub_1007895AC()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Error in Country Code Multi Band : %d", v2, v3, v4, v5, v6);
}

void sub_100789614()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Country Code Multi Band is not supported.", v2, v3, v4, v5, v6);
}

void sub_100789648()
{
  sub_10005732C();
  _os_log_debug_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_DEBUG, "handleSimulateLocationUpdateMsg: countryString = %@", v1, 0xCu);
}

void sub_1007896BC()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Unable to set Cellular Transmit State : %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_100789724()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Error sending VSC to read factory cal table : %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_10078978C()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Unable to send gizmo detected : %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_1007897F4()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Error in HCI_StartRxTest : %d", v2, v3, v4, v5, v6);
}

void sub_10078985C()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Received XPC RxTest request while another request was in flight. Dropping request", v2, v3, v4, v5, v6);
}

void sub_100789890()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Error in HCI_StartTxTest : %d", v2, v3, v4, v5, v6);
}

void sub_1007898F8()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Received XPC TxTest request while another request was in flight. Dropping request", v2, v3, v4, v5, v6);
}

void sub_10078992C()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Error in HCI_LeTestEnd : %d", v2, v3, v4, v5, v6);
}

void sub_100789994()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Received XPC LeTestEnd request while another request was in flight. Dropping request", v2, v3, v4, v5, v6);
}

void sub_1007899C8()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Error in HCI_StartRxEnhancedTest : %d", v2, v3, v4, v5, v6);
}

void sub_100789A30()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Received XPC RxEnhancedTest request while another request was in flight. Dropping request", v2, v3, v4, v5, v6);
}

void sub_100789A64()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Error in HCI_StartTxEnhancedTest : %d", v2, v3, v4, v5, v6);
}

void sub_100789ACC()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Received XPC TxEnhancedTest request while another request was in flight. Dropping request", v2, v3, v4, v5, v6);
}

void sub_100789B00()
{
  sub_100407670();
  _os_log_debug_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_DEBUG, "Got CC: %d LEFlag: %d", v1, 0xEu);
}

void sub_100789B80()
{
  sub_10005732C();
  _os_log_debug_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_DEBUG, "Got countryCode: %@", v1, 0xCu);
}

void sub_100789BF4()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Error in read GPIO status : %d", v2, v3, v4, v5, v6);
}

void sub_100789C5C()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Unable to set SAR state : %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_100789CC4()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Unable to set WiFi 5G state : %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_100789D2C()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "No value for the key kCBMsgArgs\n", v2, v3, v4, v5, v6);
}

void sub_100789D60()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Unable to write cellular antenna", v2, v3, v4, v5, v6);
}

void sub_100789D94()
{
  sub_100407670();
  sub_100057498((void *)&_mh_execute_header, v0, v1, "Failed to set diversity mode %d on handle %d", v2, v3);
}

void sub_100789E04()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Unable to enable/disable tunables read", v2, v3, v4, v5, v6);
}

void sub_100789E38()
{
  sub_100407670();
  sub_100057498((void *)&_mh_execute_header, v0, v1, "Failed to set BT diversity antenna to Ant%d on handle %d", v2, v3);
}

void sub_100789EA8()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Error to send ADV Buffer Configuration : %d", v2, v3, v4, v5, v6);
}

void sub_100789F10()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Error in AdvMatch Control message : %d", v2, v3, v4, v5, v6);
}

void sub_100789F78()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Error in read ADV buffer command : %d", v2, v3, v4, v5, v6);
}

void sub_100789FE0()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Error to send Match table Configuration : %d", v2, v3, v4, v5, v6);
}

void sub_10078A048()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Error to send Match table Extended Filter Configuration : %d", v2, v3, v4, v5, v6);
}

void sub_10078A0B0()
{
  sub_1001004CC();
  HIWORD(v3) = v0;
  sub_100057498((void *)&_mh_execute_header, v0, v1, "Error invalid endEntry (%d) or startEntry (%d) ", v2, v3);
}

void sub_10078A11C()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Error to send match table parmater command : %d", v2, v3, v4, v5, v6);
}

void sub_10078A184()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Error to send match table parmater command; LE addr Convert failed : %d",
    v2,
    v3,
    v4,
    v5,
    v6);
}

void sub_10078A1EC()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Error to send Match Buffer Configuration : %d", v2, v3, v4, v5, v6);
}

void sub_10078A254()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Error in SPMI Diagnostic message : %d", v2, v3, v4, v5, v6);
}

void sub_10078A2BC()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Error in BTCLK SensorC Time Sync Control message : %d", v2, v3, v4, v5, v6);
}

void sub_10078A324()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Error in Tx ADV Trig Time Stamp Control message : %d", v2, v3, v4, v5, v6);
}

void sub_10078A38C()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Error in Read LE Conn Event Counter message : %d", v2, v3, v4, v5, v6);
}

void sub_10078A3F4()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Error in SPMI debug control VSE message : %d", v2, v3, v4, v5, v6);
}

void sub_10078A45C()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Error in set GPIO state message : %d", v2, v3, v4, v5, v6);
}

void sub_10078A4C4()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Error parsing XPC Args", v2, v3, v4, v5, v6);
}

void sub_10078A4F8()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Error in HDR Setup Sync message : %d", v2, v3, v4, v5, v6);
}

void sub_10078A560()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Error in HDR Accept Sync message message : %d", v2, v3, v4, v5, v6);
}

void sub_10078A5C8()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Error in SCO Buffer Size Control message : %d", v2, v3, v4, v5, v6);
}

void sub_10078A630()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "SCO Buffer Size Control is not supported.", v2, v3, v4, v5, v6);
}

void sub_10078A664()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Error in HRB Control message : %d", v2, v3, v4, v5, v6);
}

void sub_10078A6CC()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "HRB is not supported.", v2, v3, v4, v5, v6);
}

void sub_10078A700()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Error in HRB Allowed Bands message : %d", v2, v3, v4, v5, v6);
}

void sub_10078A768()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Failed to retrieve connection handle.", v2, v3, v4, v5, v6);
}

void sub_10078A79C()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Error in HRB Change Connection Band message : %d", v2, v3, v4, v5, v6);
}

void sub_10078A804()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Error in HRB Write Scan Enable message : %d", v2, v3, v4, v5, v6);
}

void sub_10078A86C()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Error in HRB Write Page Scan Activity message : %d", v2, v3, v4, v5, v6);
}

void sub_10078A8D4()
{
  sub_1001004CC();
  int v2 = 3;
  _os_log_error_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_ERROR, "Error in HRB Set AFH Host Channel Classification message numberOfGroups is invalid: %d(shall be <= %d)", v1, 0xEu);
}

void sub_10078A950()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Error in HRB Set AFH Host Channel Classification message : %d", v2, v3, v4, v5, v6);
}

void sub_10078A9B8()
{
  sub_10005732C();
  __int16 v3 = 1024;
  int v4 = v0;
  _os_log_error_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_ERROR, "Error in HRB Set AFH Host Channel Classification message channel map size is invalid: %zu (shall be %d)", v2, 0x12u);
}

void sub_10078AA3C()
{
  sub_1002DDCC4();
  sub_1000574F8((void *)&_mh_execute_header, v0, v1, "Error in HRB Set AFH Host Channel Classification message size of gr channel map param  is invalid: %zu (shall be %lu)", v2, v3);
}

void sub_10078AAA4()
{
  sub_1002DDCC4();
  sub_1000574F8((void *)&_mh_execute_header, v0, v1, "Error in HRB Set AFH Host Channel Classification start freq param size is invalid: %zu (shall be %lu)", v2, v3);
}

void sub_10078AB0C()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Error in Get Essential Power Database Entries message : %d", v2, v3, v4, v5, v6);
}

void sub_10078AB74()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Error in HRB Read Transmit Power Level message : %d", v2, v3, v4, v5, v6);
}

void sub_10078ABDC()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Error in HRB Read AFH Channel Map message : %d", v2, v3, v4, v5, v6);
}

void sub_10078AC44()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Error in HRB Limit Channel Map message : %d", v2, v3, v4, v5, v6);
}

void sub_10078ACAC()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Error in HRB Set Band Edges message : %d", v2, v3, v4, v5, v6);
}

void sub_10078AD14()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "HRB Set Band Edges is not supported.", v2, v3, v4, v5, v6);
}

void sub_10078AD48()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Couldn't find the device", v2, v3, v4, v5, v6);
}

void sub_10078AD7C()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Error in Enter Sniff Mode message : %d", v2, v3, v4, v5, v6);
}

void sub_10078ADE4()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Error in Exit Sniff Mode message : %d", v2, v3, v4, v5, v6);
}

void sub_10078AE4C()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Error in Enable Phy Stats message : %d", v2, v3, v4, v5, v6);
}

void sub_10078AEB4()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Error in Enable Phy Stats converting xpc args : %d", v2, v3, v4, v5, v6);
}

void sub_10078AF1C()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Error in Advanced Sniff Mode message : %d", v2, v3, v4, v5, v6);
}

void sub_10078AF84()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Advanced Sniff Mode is not supported.", v2, v3, v4, v5, v6);
}

void sub_10078AFB8()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Error in Exit Advanced Sniff Mode message : %d", v2, v3, v4, v5, v6);
}

void sub_10078B020()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Exit Advanced Sniff Mode is not supported.", v2, v3, v4, v5, v6);
}

void sub_10078B054()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Error in Advanced Sniff Reconfigure message : %d", v2, v3, v4, v5, v6);
}

void sub_10078B0BC()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Advanced Sniff Reconfigure is not supported.", v2, v3, v4, v5, v6);
}

void sub_10078B0F0()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Error in Set Peripheral Max Age message : %d", v2, v3, v4, v5, v6);
}

void sub_10078B158()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Set Peripheral Max Age is not supported.", v2, v3, v4, v5, v6);
}

void sub_10078B18C()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Error in LMP Flow message : %d", v2, v3, v4, v5, v6);
}

void sub_10078B1F4()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "LMP Flow is not supported.", v2, v3, v4, v5, v6);
}

void sub_10078B228()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Error in AoS Empty Packet Report message : %d", v2, v3, v4, v5, v6);
}

void sub_10078B290()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "AoS Empty Packet Report is not supported.", v2, v3, v4, v5, v6);
}

void sub_10078B2C4()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Error in Control AoS message : %d", v2, v3, v4, v5, v6);
}

void sub_10078B32C()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Control AoS is not supported.", v2, v3, v4, v5, v6);
}

void sub_10078B360()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Error in BTSC Page Scan message : %d", v2, v3, v4, v5, v6);
}

void sub_10078B3C8()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Error to Set QoS Config : %d", v2, v3, v4, v5, v6);
}

void sub_10078B430()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Error in SPMI Coex Debug Counters Command : %d", v2, v3, v4, v5, v6);
}

void sub_10078B498()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Error in SPMI Test Write Command : %d", v2, v3, v4, v5, v6);
}

void sub_10078B500()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Error in SPMI Coex Tx Control Command : %d", v2, v3, v4, v5, v6);
}

void sub_10078B568()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Error in SPMI Type 53 Config Command : %d", v2, v3, v4, v5, v6);
}

void sub_10078B5D0()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Error in SPMI Type 60 Config Command : %d", v2, v3, v4, v5, v6);
}

void sub_10078B638()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Error in Read Controller RAM : %d", v2, v3, v4, v5, v6);
}

void sub_10078B6A0()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Error in set min encryption key size Command : %d", v2, v3, v4, v5, v6);
}

void sub_10078B708()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Error in Factory Cal Set Tx Power : %d", v2, v3, v4, v5, v6);
}

void sub_10078B770()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Error in Cal Set Tx Power Command invalid Mode: %d", v2, v3, v4, v5, v6);
}

void sub_10078B7D8()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Exiting", v2, v3, v4, v5, v6);
}

void sub_10078B80C(unsigned __int16 a1, NSObject *a2)
{
  v2[0] = 67109632;
  v2[1] = a1;
  __int16 v3 = 1024;
  int v4 = 210;
  __int16 v5 = 1024;
  int v6 = 250;
  _os_log_error_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_ERROR, "Error: Unexpected File size %d; Expected File size %d or %d, Exiting\n",
    (uint8_t *)v2,
    0x14u);
}

void sub_10078B8A4()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Error Downloading Power Regulatory File, Exiting", v2, v3, v4, v5, v6);
}

void sub_10078B8D8()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Device is not connected", v2, v3, v4, v5, v6);
}

void sub_10078B90C()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Error parsing XPC Args: handleSimulateBudswapCmd", v2, v3, v4, v5, v6);
}

void sub_10078B940()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Error writing BD Address : %d", v2, v3, v4, v5, v6);
}

void sub_10078B9A8()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Error in Crc Erred Pdu Report Enable message : %d", v2, v3, v4, v5, v6);
}

void sub_10078BA10()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Error in Apple Extended Adv Report Enable message : %d", v2, v3, v4, v5, v6);
}

void sub_10078BA78()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "_findTypeFromLength cannot find type!!! This shall not happen!!", v2, v3, v4, v5, v6);
}

void sub_10078BAAC()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Perf recv data ind get connection handle failed with status %d", v2, v3, v4, v5, v6);
}

void sub_10078BB14()
{
  sub_10005732C();
  _os_log_error_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_ERROR, "Unable to open, file path=%s\n", v1, 0xCu);
}

void sub_10078BB88()
{
  sub_10005732C();
  _os_log_error_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_ERROR, "EOF found, file path=%s\n", v1, 0xCu);
}

void sub_10078BBFC()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Error reading file", v2, v3, v4, v5, v6);
}

void sub_10078BC30(NSObject *a1)
{
  int v2 = *__error();
  v3[0] = 67109120;
  v3[1] = v2;
  _os_log_error_impl((void *)&_mh_execute_header, a1, OS_LOG_TYPE_ERROR, "loadFile: Error Reading File Stat: errno = %d\n", (uint8_t *)v3, 8u);
}

void sub_10078BCC0()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to write ACL data : %d\n", v2, v3, v4, v5, v6);
}

void sub_10078BD28()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Invalid size input report", v2, v3, v4, v5, v6);
}

void sub_10078BD5C()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "The HID device is not ready for a spoofed click", v2, v3, v4, v5, v6);
}

void sub_10078BD90()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Failed to create Management HID device", v2, v3, v4, v5, v6);
}

void sub_10078BDC4()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Failed to create Trackpad HID device", v2, v3, v4, v5, v6);
}

void sub_10078BDF8()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Failed to create Actuator HID device", v2, v3, v4, v5, v6);
}

void sub_10078BE2C()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Failed to create Accelerometer HID device", v2, v3, v4, v5, v6);
}

void sub_10078BE60()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "AdvertisementInterval defaults is now obsolete. Please use ConnectableAdvInt, NonConnectableAdvInt, ObjectDiscoveryAdvInt and ExtAdvInt instead", v2, v3, v4, v5, v6);
}

void sub_10078BE94()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "LE_GAP_InitPeriodicAdvertising failed with status %d", v2, v3, v4, v5, v6);
}

void sub_10078BEFC()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "LE_GAP_InitAdvertising failed with status %d", v2, v3, v4, v5, v6);
}

void sub_10078BF64()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to set address change callbacks with result %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_10078BFCC(uint64_t a1, NSObject *a2)
{
  sub_10003AE4C(a1, (uint64_t)__p);
  if (v6 >= 0) {
    uint64_t v4 = __p;
  }
  else {
    uint64_t v4 = (void **)__p[0];
  }
  int v7 = 136446210;
  uint8_t v8 = v4;
  sub_100057438((void *)&_mh_execute_header, a2, v3, "Already not advertising data for session \"%{public}s\"", (uint8_t *)&v7);
  if (v6 < 0) {
    operator delete(__p[0]);
  }
}

void sub_10078C078()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Cannot disable setLEAdvTxPowerIncrease response on handle %d", v2, v3, v4, v5, v6);
}

void sub_10078C0E0()
{
  sub_1006673B8();
  sub_100057498((void *)&_mh_execute_header, v0, v1, "setLEAdvTxPowerIncrease disable on handle %d returned %d", v2, v3);
}

void sub_10078C148()
{
  sub_1006673B8();
  sub_100057498((void *)&_mh_execute_header, v0, v1, "btleTxAdvTrigTimeStamp disable on handle %d returned %d", v2, v3);
}

void sub_10078C1B0()
{
  sub_100579750();
  int v2 = 0;
  _os_log_debug_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_DEBUG, "updateAdvertisement currentState:%{public}s, trying again in %dms", v1, 0x12u);
}

void sub_10078C248()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Advertising tech still unknown. We'll revisit once we know how to advertise", v2, v3, v4, v5, v6);
}

void sub_10078C27C()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Resetting advertising internal states", v2, v3, v4, v5, v6);
}

void sub_10078C2B0()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to start advertising with result %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_10078C318()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to stop advertising with result %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_10078C380(char a1, uint64_t a2, os_log_t log)
{
  uint64_t v3 = "YES";
  int v4 = *(unsigned __int8 *)(a2 + 16945);
  if (a1) {
    uint64_t v5 = "YES";
  }
  else {
    uint64_t v5 = "NO";
  }
  int v6 = 136446722;
  int v7 = v5;
  __int16 v8 = 2082;
  if (!v4) {
    uint64_t v3 = "NO";
  }
  uint8_t v9 = v3;
  __int16 v10 = 2082;
  uint64_t v11 = "NO";
  _os_log_debug_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_DEBUG, "updateAdvertisement deferred:%{public}s fDeferringUpdateAdvertisingState:%{public}s fAddressChangeInProgress:%{public}s", (uint8_t *)&v6, 0x20u);
}

void sub_10078C438()
{
  sub_1000572DC();
  sub_1002E4C44((void *)&_mh_execute_header, v0, v1, "We're already deferred, skipping", v2, v3, v4, v5, v6);
}

void sub_10078C46C()
{
  sub_10030D088();
  sub_1006673F0(4.8752e-34, v1, v2, v3);
  _os_log_error_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "Rejecting advertising from \"%{public}s\" for list type %d", v4, 0x12u);
  if (*(char *)(v0 + 23) < 0) {
    operator delete(*(void **)v0);
  }
}

void sub_10078C4DC()
{
  sub_1006673B8();
  sub_100057498((void *)&_mh_execute_header, v0, v1, "setLEAdvTxPowerIncrease enable on handle %d returned %d", v2, v3);
}

void sub_10078C544()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "setLEAdvTxPowerIncrease on advertising handle is already set up on handle %d", v2, v3, v4, v5, v6);
}

void sub_10078C5AC()
{
  sub_1006673B8();
  sub_100057498((void *)&_mh_execute_header, v0, v1, "btleTxAdvTrigTimeStamp enable on handle %d returned %d", v2, v3);
}

void sub_10078C614()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "SPMI Debug Control spmiDebugVSEControl returned %d", v2, v3, v4, v5, v6);
}

void sub_10078C67C()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "ObjectLocator Response on advertising handle is already set up on handle %d", v2, v3, v4, v5, v6);
}

void sub_10078C6E4()
{
  sub_1000573EC();
  if (v4 != v5) {
    uint64_t v6 = v3;
  }
  else {
    uint64_t v6 = v1;
  }
  sub_100057464(v2, v6, 4.8751e-34);
  sub_100057438((void *)&_mh_execute_header, v7, (uint64_t)v7, "Already advertising data for session \"%{public}s\"", v8);
  if (*(char *)(v0 + 23) < 0) {
    operator delete(*(void **)v0);
  }
}

void sub_10078C73C()
{
  sub_1000572DC();
  sub_1002E4C44((void *)&_mh_execute_header, v0, v1, "appSessionStateChanged - backgrounded sessions", v2, v3, v4, v5, v6);
}

void sub_10078C770()
{
  sub_1000573EC();
  if (v4 != v5) {
    uint64_t v6 = v3;
  }
  else {
    uint64_t v6 = v1;
  }
  sub_100057464(v2, v6, 4.8751e-34);
  sub_1006673D4((void *)&_mh_execute_header, v7, v8, "Pushing session %{public}s to the front of the line", v9);
  if (*(char *)(v0 + 23) < 0) {
    operator delete(*(void **)v0);
  }
}

void sub_10078C7C4()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "LeBroadcaster::_LE_GAP_ParseAppleManufacturingData returned %d", v2, v3, v4, v5, v6);
}

void sub_10078C82C(char a1, NSObject *a2)
{
  v2[0] = 67109120;
  v2[1] = a1 & 1;
  _os_log_debug_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_DEBUG, "LeBroadcaster::sendAppleManufacturingPayloadMetrics called with start:%d", (uint8_t *)v2, 8u);
}

void sub_10078C8A8()
{
  sub_1000573EC();
  if (v4 != v5) {
    uint64_t v6 = v3;
  }
  else {
    uint64_t v6 = v1;
  }
  sub_100057464(v2, v6, 4.8751e-34);
  sub_1006673D4((void *)&_mh_execute_header, v7, v8, "Removing session %{public}s from the line", v9);
  if (*(char *)(v0 + 23) < 0) {
    operator delete(*(void **)v0);
  }
}

void sub_10078C8FC()
{
  sub_1000573EC();
  if (v4 != v5) {
    uint64_t v6 = v3;
  }
  else {
    uint64_t v6 = v1;
  }
  sub_100057464(v2, v6, 4.8751e-34);
  sub_100057438((void *)&_mh_execute_header, v7, (uint64_t)v7, "Already not advertising data for session \"%{public}s\"", v8);
  if (*(char *)(v0 + 23) < 0) {
    operator delete(*(void **)v0);
  }
}

void sub_10078C954()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to start periodic advertising with result %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_10078C9BC()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to stop periodic advertising with result %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_10078CA24(uint64_t a1, NSObject *a2, uint64_t a3)
{
  int v3 = 138412290;
  uint64_t v4 = a1;
  sub_100057438((void *)&_mh_execute_header, a2, a3, "LTV parsing failed, invalid length [%@]", (uint8_t *)&v3);
}

void sub_10078CA94()
{
  sub_1000572DC();
  _os_log_fault_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_FAULT, "Scan Response should *always* have room for the UUID hash!", v1, 2u);
}

void sub_10078CAD4(uint8_t *buf, unsigned char *a2, os_log_t log)
{
  *uint64_t buf = 0;
  *a2 = 0;
  _os_log_debug_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_DEBUG, "Extended advertising for background advertising is disabled", buf, 2u);
}

void sub_10078CB14(uint8_t *buf, unsigned char *a2, os_log_t log)
{
  *uint64_t buf = 0;
  *a2 = 0;
  _os_log_debug_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_DEBUG, "We dont support extended advertising", buf, 2u);
}

void sub_10078CB54()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Ignoring watchdog, coredump in progress", v2, v3, v4, v5, v6);
}

void sub_10078CB88(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_10078CBFC(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_10078CC70()
{
  sub_10030D088();
  sub_1006673F0(4.8752e-34, v1, v2, v3);
  _os_log_debug_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEBUG, "Session %{public}s is now %d", v4, 0x12u);
  if (*(char *)(v0 + 23) < 0) {
    operator delete(*(void **)v0);
  }
}

void sub_10078CCDC()
{
  sub_1000573EC();
  if (v4 != v5) {
    uint64_t v6 = v3;
  }
  else {
    uint64_t v6 = v1;
  }
  sub_100057464(v2, v6, 4.8751e-34);
  sub_1006673D4((void *)&_mh_execute_header, v7, v8, "Session %{public}s does not support backgrounding", v9);
  if (*(char *)(v0 + 23) < 0) {
    operator delete(*(void **)v0);
  }
}

void sub_10078CD30()
{
  sub_100579750();
  int v3 = v0;
  _os_log_error_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_ERROR, "Advertising failed to %{public}s with result %{bluetooth:OI_STATUS}u", v2, 0x12u);
}

void sub_10078CDC8()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Faking unsettled state, ignoring advertisingComplete event, staying in a bad state", v2, v3, v4, v5, v6);
}

void sub_10078CDFC(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_100057310((void *)&_mh_execute_header, a2, a3, "fControllerMaxExtendedAdvertisingPayloadSize=%d", a5, a6, a7, a8, 0);
}

void sub_10078CE6C()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "LE_GAP_SetNonConnectableAddress failed with error %d", v2, v3, v4, v5, v6);
}

void sub_10078CED4()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "generateNonConnectableIdentity failed with error %d", v2, v3, v4, v5, v6);
}

void sub_10078CF3C()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "LE_GAP_OverrideLocalAddress returned %d", v2, v3, v4, v5, v6);
}

void sub_10078CFA4()
{
  sub_1000572DC();
  sub_1002E4C44((void *)&_mh_execute_header, v0, v1, "Source supports Remote", v2, v3, v4, v5, v6);
}

void sub_10078CFD8()
{
  sub_1000572DC();
  sub_1002E4C44((void *)&_mh_execute_header, v0, v1, "Source supports AACP", v2, v3, v4, v5, v6);
}

void sub_10078D00C()
{
  sub_1000572DC();
  sub_1002E4C44((void *)&_mh_execute_header, v0, v1, "Source supports A2DP", v2, v3, v4, v5, v6);
}

void sub_10078D040()
{
  sub_1000572DC();
  sub_1002E4C44((void *)&_mh_execute_header, v0, v1, "Source supports HFP and HandsfreeAoS", v2, v3, v4, v5, v6);
}

void sub_10078D074()
{
  sub_1000572DC();
  sub_1002E4C44((void *)&_mh_execute_header, v0, v1, "Source supports HFP", v2, v3, v4, v5, v6);
}

void sub_10078D0A8()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Forcing GATT Clean", v2, v3, v4, v5, v6);
}

void sub_10078D0DC()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Forcing AVRCP Clean", v2, v3, v4, v5, v6);
}

void sub_10078D110()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Forcing AACP Clean", v2, v3, v4, v5, v6);
}

void sub_10078D144()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Forcing HandsfreeAoS Clean", v2, v3, v4, v5, v6);
}

void sub_10078D178()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Forcing HFP Clean", v2, v3, v4, v5, v6);
}

void sub_10078D1AC()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Forcing A2DP Clean", v2, v3, v4, v5, v6);
}

void sub_10078D1E0()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to allocate fast connect channel with status %d", v2, v3, v4, v5, v6);
}

void sub_10078D248()
{
  sub_1000572DC();
  sub_1002E4C44((void *)&_mh_execute_header, v0, v1, "fastConnectEchoRspCB", v2, v3, v4, v5, v6);
}

void sub_10078D27C()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "composeGATTDescriptor error getting signaling L2CAP data", v2, v3, v4, v5, v6);
}

void sub_10078D2B0(uint64_t a1, uint64_t a2, void *a3)
{
  sub_1004428C0();
  sub_1000573B4((void *)&_mh_execute_header, v4, v5, "Descriptor was already sent once! FCState %s", v6, v7, v8, v9, v10);
  *a3 = qword_100A1A038;
}

void sub_10078D358(unsigned char *a1, unsigned char *a2)
{
  sub_10026C69C(a1, a2);
  sub_10031659C((void *)&_mh_execute_header, v2, (uint64_t)v2, "fastConnectParseProfileDescriptorMessage: Parse A2DP error!!!!", v3);
}

void sub_10078D388(unsigned char *a1, unsigned char *a2)
{
  sub_10026C69C(a1, a2);
  sub_10031659C((void *)&_mh_execute_header, v2, (uint64_t)v2, "Parse HFP error!!!!", v3);
}

void sub_10078D3B8(unsigned char *a1, unsigned char *a2)
{
  sub_10026C69C(a1, a2);
  sub_10031659C((void *)&_mh_execute_header, v2, (uint64_t)v2, "Parse AACP error!!!!", v3);
}

void sub_10078D3E8(unsigned char *a1, unsigned char *a2)
{
  sub_10026C69C(a1, a2);
  sub_10031659C((void *)&_mh_execute_header, v2, (uint64_t)v2, "Parse AVRCP error!!!!", v3);
}

void sub_10078D418()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "fastConnectParseProfileDescriptorMessage FC_ELEMENT_PROFILE_LIST Expected but received %d", v2, v3, v4, v5, v6);
}

void sub_10078D480()
{
  sub_1004428C0();
  sub_1000573B4((void *)&_mh_execute_header, v0, v1, "Descriptor was already received once! FCState %s", v2, v3, v4, v5, v6);
}

void sub_10078D50C()
{
  sub_100057584();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Wrong CID %d came with profile descriptor message", v2, v3, v4, v5, v6);
}

void sub_10078D574()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Expected Device Info but received %d", v2, v3, v4, v5, v6);
}

void sub_10078D5DC(unsigned char *a1, unsigned char *a2)
{
  sub_10026C69C(a1, a2);
  sub_10031659C((void *)&_mh_execute_header, v2, (uint64_t)v2, "parseGATTDescriptor L2CAP signal channel not found", v3);
}

void sub_10078D60C()
{
  sub_1004428C0();
  sub_1000573B4((void *)&_mh_execute_header, v0, v1, "Configure was already sent once! FCState %s", v2, v3, v4, v5, v6);
}

void sub_10078D698()
{
  sub_100057584();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "fastConnectComposeServiceConfigureMessage Wrong CID %d came with fast connect channel support event", v2, v3, v4, v5, v6);
}

void sub_10078D700()
{
  sub_100671A04(__stack_chk_guard);
  sub_10054DCE4();
  sub_100057498((void *)&_mh_execute_header, v0, v1, "Failed to find GATT signaling channel CID:%d Result:%d to report connection attempt", v2, v3);
}

void sub_10078D768()
{
  sub_100671A04(__stack_chk_guard);
  sub_10054DCE4();
  sub_100057498((void *)&_mh_execute_header, v0, v1, "Failed to find AVRCP signaling channel CID:%d Result:%d to report connection attempt", v2, v3);
}

void sub_10078D7D0()
{
  sub_100671A04(__stack_chk_guard);
  sub_10054DCE4();
  sub_100057498((void *)&_mh_execute_header, v0, v1, "Failed to find AACP signaling channel CID:%d Result:%d to report connection attempt", v2, v3);
}

void sub_10078D838()
{
  sub_100671A04(__stack_chk_guard);
  sub_10054DCE4();
  sub_100057498((void *)&_mh_execute_header, v0, v1, "Failed to find HFP signaling channel CID:%d Result:%d to report connection attempt", v2, v3);
}

void sub_10078D8A0()
{
  sub_100671A04(__stack_chk_guard);
  sub_10054DCE4();
  sub_100057498((void *)&_mh_execute_header, v0, v1, "Failed to find A2DP media or signaling channel mediaCID:%d mediaResult:%d to report connection attempt", v2, v3);
}

void sub_10078D908()
{
  sub_100671A04(__stack_chk_guard);
  sub_10054DCE4();
  sub_100057498((void *)&_mh_execute_header, v0, v1, "Failed to complete GATT connect Cfm for CID:%d Result:%d to report connection result", v2, v3);
}

void sub_10078D970()
{
  sub_100671A04(__stack_chk_guard);
  sub_10054DCE4();
  sub_100057498((void *)&_mh_execute_header, v0, v1, "Failed to find AVRCP signaling channel CID:%d Result:%d to report connection result", v2, v3);
}

void sub_10078D9D8()
{
  sub_100671A04(__stack_chk_guard);
  sub_10054DCE4();
  sub_100057498((void *)&_mh_execute_header, v0, v1, "Failed to find AACP signaling channel CID:%d Result:%d to report connection result", v2, v3);
}

void sub_10078DA40()
{
  sub_100671A04(__stack_chk_guard);
  sub_10054DCE4();
  sub_100057498((void *)&_mh_execute_header, v0, v1, "Failed to find HFP signaling channel CID:%d Result:%d to report connection result", v2, v3);
}

void sub_10078DAA8()
{
  sub_100671A04(__stack_chk_guard);
  sub_10054DCE4();
  sub_100057498((void *)&_mh_execute_header, v0, v1, "Failed to find A2DP media or signaling channel mediaCID:%d mediaResult:%d to report connection result", v2, v3);
}

void sub_10078DB10()
{
  sub_1000573EC();
  if (v6 != v7) {
    uint64_t v8 = v5;
  }
  else {
    uint64_t v8 = v1;
  }
  *(_DWORD *)uint64_t v2 = 136446210;
  *(void *)(v2 + 4) = v8;
  sub_100057404((void *)&_mh_execute_header, v2, v3, "No fast connect device found for %{public}s", v4);
  if (*(char *)(v0 + 23) < 0) {
    operator delete(*(void **)v0);
  }
}

void sub_10078DB68()
{
  sub_1000572DC();
  _os_log_fault_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_FAULT, "Fast Connect Profile Mask Mismatch!", v1, 2u);
}

void sub_10078DBA8(unsigned char *a1, unsigned char *a2)
{
  sub_10026C69C(a1, a2);
  sub_10031659C((void *)&_mh_execute_header, v2, (uint64_t)v2, "Parse AACP setup complete error", v3);
}

void sub_10078DBD8()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "fastConnectParseSetupCompleteMessage FC_ELEMENT_PROFILE_LIST Expected but received %d", v2, v3, v4, v5, v6);
}

void sub_10078DC40()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Device Info Expected but received %d", v2, v3, v4, v5, v6);
}

void sub_10078DCA8()
{
  sub_1004428C0();
  sub_1000573B4((void *)&_mh_execute_header, v0, v1, "Setup Complete was already received once! FCState %s", v2, v3, v4, v5, v6);
}

void sub_10078DD28()
{
  sub_100057584();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Wrong CID %d came with setup complete message", v2, v3, v4, v5, v6);
}

void sub_10078DD90()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "FastConnectMagicPolicyCB: Channel not found in PolicyCB!", v2, v3, v4, v5, v6);
}

void sub_10078DDC4(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v9 = 136315138;
  uint64_t v10 = sub_10025B48C(a1, (uint64_t)a2, a3, a4, a5, a6, a7, a8);
  _os_log_error_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_ERROR, "Failed to find PFC device for address: %s", (uint8_t *)&v9, 0xCu);
}

void sub_10078DE54()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Authentication failed: cleaning up fast connect channel", v2, v3, v4, v5, v6);
}

void sub_10078DE88(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_10078DEF8()
{
  sub_1000573EC();
  if (v6 != v7) {
    uint64_t v8 = v5;
  }
  else {
    uint64_t v8 = v1;
  }
  *(_DWORD *)uint64_t v2 = 136446210;
  *(void *)(v2 + 4) = v8;
  sub_100057404((void *)&_mh_execute_header, v2, v3, "Device %{public}s has empty UUID", v4);
  if (*(char *)(v0 + 23) < 0) {
    operator delete(*(void **)v0);
  }
}

void sub_10078DF50()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to baseband retry for echo request, took %d ms", v2, v3, v4, v5, v6);
}

void sub_10078DFB8()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "PFC failed with status %d", v2, v3, v4, v5, v6);
}

void sub_10078E020()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Could not create fast connect device for incoming connection", v2, v3, v4, v5, v6);
}

void sub_10078E054()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Could not find fast connect device for outgoing connection", v2, v3, v4, v5, v6);
}

void sub_10078E088()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Unknown message %d received", v2, v3, v4, v5, v6);
}

void sub_10078E0F0()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Error Message received", v2, v3, v4, v5, v6);
}

void sub_10078E124()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to register L2CAP Queue with status %d", v2, v3, v4, v5, v6);
}

void sub_10078E18C(unsigned __int16 a1, uint64_t a2, uint8_t *buf, os_log_t log)
{
  int v4 = *(unsigned __int16 *)(a2 + 36);
  *(_DWORD *)uint64_t buf = 67109376;
  *((_DWORD *)buf + 1) = a1;
  *((_WORD *)buf + 4) = 1024;
  *(_DWORD *)(buf + 10) = v4;
  _os_log_debug_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_DEBUG, "L2CAP channel info local CID %d local MTU %d", buf, 0xEu);
}

void sub_10078E1EC()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "parseFastConnectEchoReq L2CAP channel alloc failed result %d", v2, v3, v4, v5, v6);
}

void sub_10078E254()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "PFC Source Not Supported", v2, v3, v4, v5, v6);
}

void sub_10078E288()
{
  sub_1002B70BC();
  sub_100057498((void *)&_mh_execute_header, v0, v1, "parseFastConnectEchoReq SDP expected %x received %x", v2, v3);
}

void sub_10078E2F0()
{
  sub_1002B7074();
  sub_100057550(v1, v2, v3, 4.8151e-34);
  _os_log_error_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "Updating DID for device %s to %d", v4, 0x12u);
  if (*(char *)(v0 + 23) < 0) {
    operator delete(*(void **)v0);
  }
}

void sub_10078E34C()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "device is not paired!", v2, v3, v4, v5, v6);
}

void sub_10078E380()
{
  sub_1000573EC();
  if (v6 != v7) {
    uint64_t v8 = v5;
  }
  else {
    uint64_t v8 = v1;
  }
  *(_DWORD *)uint64_t v2 = 136315138;
  *(void *)(v2 + 4) = v8;
  sub_100057404((void *)&_mh_execute_header, v2, v3, "Not responding to echo request from %s, as PFC already in progress", v4);
  if (*(char *)(v0 + 23) < 0) {
    operator delete(*(void **)v0);
  }
}

void sub_10078E3D8()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "fastConnectGetAppleFeaturesAndSDPDatabaseState failed to find device", v2, v3, v4, v5, v6);
}

void sub_10078E40C()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "fastConnectGetDeviceExtendedFeatures failed to find device", v2, v3, v4, v5, v6);
}

void sub_10078E440(uint64_t *a1, int a2, os_log_t log)
{
  uint64_t v3 = *a1;
  v4[0] = 67109376;
  v4[1] = a2;
  __int16 v5 = 2048;
  uint64_t v6 = v3;
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "fastConnectEchoRspEvent NULL channel result %d channel %p", (uint8_t *)v4, 0x12u);
}

void sub_10078E4CC()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "fastConnectEchoRspEvent with result %d", v2, v3, v4, v5, v6);
}

void sub_10078E534()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "fastConnectEchoRspEvent failed with status %d", v2, v3, v4, v5, v6);
}

void sub_10078E59C()
{
  sub_1002B70BC();
  sub_100057498((void *)&_mh_execute_header, v0, v1, "SDP expected %x received %x", v2, v3);
}

void sub_10078E604()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Do not set ConnScanTimeoutExtendPercent %d percent - invalid", v2, v3, v4, v5, v6);
}

void sub_10078E66C()
{
  sub_1000575E4();
  sub_100057498((void *)&_mh_execute_header, v0, v1, "Overriding MainCore Disabled for Connection Scan, invaid Overriding Scan Window %d, Scan Interval %d.", v2, v3);
}

void sub_10078E6D4()
{
  sub_1000575E4();
  sub_100057498((void *)&_mh_execute_header, v0, v1, "Overriding ScanCore Disabled for Connection Scan, invaid Overriding Scan Window %d, Scan Interval %d.", v2, v3);
}

void sub_10078E73C()
{
  sub_1006ACD30();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Ignoring invalid override value (%d) for fFastConnectionScanIntervalMsCoexCarPlayNoAudio", v2, v3, v4, v5, v6);
}

void sub_10078E7A8()
{
  sub_1006ACD30();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Ignoring invalid override value (%d) for fFastConnectionScanIntervalMsCoexCarPlayWithAudio", v2, v3, v4, v5, v6);
}

void sub_10078E814()
{
  sub_1006ACD30();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Ignoring invalid override value (%d) for connection parameter updates", v2, v3, v4, v5, v6);
}

void sub_10078E880()
{
  sub_1006ACD30();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Ignoring invalid override value (%d) for default connection interval", v2, v3, v4, v5, v6);
}

void sub_10078E8EC()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Ignoring invalid override value (%d) for default connection interval", v2, v3, v4, v5, v6);
}

void sub_10078E954()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Ignoring invalid override value (%d) for max number of devices in connection Filter Accept List", v2, v3, v4, v5, v6);
}

void sub_10078E9BC()
{
  sub_1000575E4();
  sub_1006ACCB8((void *)&_mh_execute_header, v0, v1, "maxInterval:%d is smaller than minInterval:%d LeConnectionLatencyVeryHigh", v2, v3);
}

void sub_10078EA24()
{
  sub_1000575E4();
  sub_1006ACCB8((void *)&_mh_execute_header, v0, v1, "maxInterval:%d is smaller than minInterval:%d LeConnectionLatencyHigh", v2, v3);
}

float sub_10078EA8C(unsigned __int16 a1, unsigned __int16 a2, os_log_t log)
{
  v4[0] = 67109888;
  v4[1] = a1;
  __int16 v5 = 1024;
  int v6 = a2;
  __int16 v7 = 1024;
  int v8 = 120;
  __int16 v9 = 1024;
  int v10 = 100;
  _os_log_fault_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_FAULT, "maxInterval:%d is smaller than minInterval:%d Use default maxInterval %d and minInterval %d LeConnectionLatencyMedium", (uint8_t *)v4, 0x1Au);
  return result;
}

void sub_10078EB30()
{
  sub_1000575E4();
  sub_1006ACCB8((void *)&_mh_execute_header, v0, v1, "maxInterval:%d is smaller than minInterval:%d LeConnectionLatencyLow", v2, v3);
}

void sub_10078EB98(uint64_t a1, uint64_t a2, NSObject *a3)
{
  uint64_t v4 = sub_1006AD3F0();
  sub_1006ACD18();
  sub_1000574B8((void *)&_mh_execute_header, a3, v5, "Failed to add address \"%{public}@\" to filter accept list with status:%d, restarting", v6);
}

void sub_10078EC34(uint64_t a1, uint64_t a2, NSObject *a3)
{
  uint64_t v4 = sub_1006AD3F0();
  sub_1006ACD18();
  sub_1000574B8((void *)&_mh_execute_header, a3, v5, "Failed to remove address \"%{public}@\" from filter accept list with status:%d, restarting", v6);
}

void sub_10078ECD0()
{
  sub_10005732C();
  sub_100057438((void *)&_mh_execute_header, v0, v1, "Unable to find connected device for HCI handle %p", v2);
}

void sub_10078ED3C()
{
  sub_1001004CC();
  int v3 = 0;
  __int16 v4 = v0;
  int v5 = 0xFFFF;
  _os_log_error_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_ERROR, "Overriding LEInstantFactor with a value %u out side range min %u max %d.", v2, 0x14u);
}

void sub_10078EDC0()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to add filter accept list callbacks with result %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_10078EE28()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to set address will change callbacks with result %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_10078EE90()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to set address change callbacks with result %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_10078EEF8()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to set Channel Sounding callbacks with result %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_10078EF60()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to set connection callbacks with result %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_10078EFC8()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to set peripheral role with result %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_10078F030()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to set central role with result %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_10078F098()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "connectionParametersUpdateRequestCallback: invalid handle", v2, v3, v4, v5, v6);
}

void sub_10078F0CC()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to read local Fast LE Connection data from controller with result:%d", v2, v3, v4, v5, v6);
}

void sub_10078F134()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Fast LE Connection disabled due to controller overrides", v2, v3, v4, v5, v6);
}

void sub_10078F168()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to unset central role with result %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_10078F1D0()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Timed out while waiting for all LE connections to complete disconnection", v2, v3, v4, v5, v6);
}

void sub_10078F204()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Timed out while cancelling all pending connections", v2, v3, v4, v5, v6);
}

void sub_10078F238()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "failed to cancel a connection. This should not happen, file a radar ! status=%{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_10078F2A0()
{
  sub_1004428C0();
  sub_1003CF064((void *)&_mh_execute_header, v0, v1, "Already in state %{public}s, ignoring state change", v2, v3, v4, v5, v6);
}

void sub_10078F328()
{
  sub_1000572E8();
  sub_10033D554((void *)&_mh_execute_header, v0, v1, "Subrate Change Event masking status: %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_10078F390()
{
  sub_10030D088();
  sub_1006ACC78(v1, v2, v3, 4.8151e-34);
  sub_1000574B8((void *)&_mh_execute_header, v6, v4, "Failed to disable HID Latency Statistics for %s with LMhandle 0x%02x", v5);
  if (*(char *)(v0 + 23) < 0) {
    operator delete(*(void **)v0);
  }
}

void sub_10078F3E4()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to send command to setting event mask for connection subrating with result %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_10078F44C()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Magnet phy enable failed with status %d", v2, v3, v4, v5, v6);
}

void sub_10078F4B4()
{
  sub_1000572E8();
  sub_10033D554((void *)&_mh_execute_header, v0, v1, "Subrate Change Event un-masking status: %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_10078F51C()
{
  sub_10030D088();
  sub_1006ACC78(v1, v2, v3, 4.8151e-34);
  sub_1000574B8((void *)&_mh_execute_header, v6, v4, "Failed to enable HID Latency Statistics for %s with LMHandle 0x%02x", v5);
  if (*(char *)(v0 + 23) < 0) {
    operator delete(*(void **)v0);
  }
}

void sub_10078F570()
{
  sub_1006ACD00(__stack_chk_guard);
  sub_1004428C0();
  sub_100057438((void *)&_mh_execute_header, v0, (uint64_t)v0, "updateLeConnectionRSSIThresholdState: %{public}s is in invalid state", v1);
}

void sub_10078F5E0()
{
  sub_10005732C();
  sub_100057438((void *)&_mh_execute_header, v0, v1, "Failed to set connection interval for device \"%{public}@\" as it isn't connected", v2);
}

void sub_10078F64C()
{
  sub_10005732C();
  sub_100057438((void *)&_mh_execute_header, v0, v1, "Magnet Subrating requested for device \"%{public}@\" which is not a Magnet link or does not support subrating.", v2);
}

void sub_10078F6B8(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_10078F730()
{
  sub_10005732C();
  sub_1003CF064((void *)&_mh_execute_header, v0, v1, "Magnet link to \"%{public}@\" is currently not subrated. Using default Magnet parameters.", v2, v3, v4, v5, v6);
}

void sub_10078F798()
{
  sub_10005732C();
  sub_1003CF064((void *)&_mh_execute_header, v0, v1, "Magnet Latency requested for device \"%{public}@\" that does not support subrating but is Magnet-capable. Using default Magnet parameters.", v2, v3, v4, v5, v6);
}

void sub_10078F800()
{
  sub_10005732C();
  sub_100057438((void *)&_mh_execute_header, v0, v1, "Magnet Latency requested for device \"%{public}@\" that is not Magnet-capable.", v2);
}

void sub_10078F86C()
{
  sub_1000572DC();
  _os_log_debug_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_DEBUG, "aopRssiDetectEvent: inDeviceEntry not valid", v1, 2u);
}

void sub_10078F8AC()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Ignoring invalid data length %d", v2, v3, v4, v5, v6);
}

void sub_10078F914(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_10033D554((void *)&_mh_execute_header, a1, a3, "aopRssiDetectEvent: Event size=%d", a5, a6, a7, a8, 0);
}

void sub_10078F988(const unsigned __int8 *a1, NSObject *a2)
{
  sub_1006ACCA0(a1, (uint64_t)a2);
  sub_100057450();
  sub_100057470();
  sub_100057438((void *)&_mh_execute_header, a2, v3, "AutoReconnected to a device never requested \"%{public}s\"", v6);
  if (v5 < 0) {
    operator delete(__p);
  }
}

void sub_10078FA1C()
{
  sub_10005732C();
  sub_100057438((void *)&_mh_execute_header, v0, v1, "Device \"%{public}@\" no more valid keys/mac addresses", v2);
}

void sub_10078FA88()
{
  sub_10005732C();
  sub_100057438((void *)&_mh_execute_header, v0, v1, "Ignoring connection request for unknown device \"%{public}@\"", v2);
}

void sub_10078FAF4()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Cannot start a new connection, stack is shutting down", v2, v3, v4, v5, v6);
}

void sub_10078FB28()
{
  sub_1001604AC();
  int v3 = 103;
  sub_1000574B8((void *)&_mh_execute_header, v0, v1, "Failed to add device \"%{public}@\" to filter accept list with result due to shutdown %{bluetooth:OI_STATUS}u", v2);
}

void sub_10078FB9C(int a1, uint64_t a2, NSObject *a3)
{
  int v6 = 136315394;
  __int16 v7 = sub_10003D640(a1);
  __int16 v8 = 2114;
  uint64_t v9 = a2;
  sub_100057420((void *)&_mh_execute_header, a3, v5, "UseCase %s cannot be considered for device \"%{public}@\"", (uint8_t *)&v6);
}

void sub_10078FC30()
{
  sub_10005732C();
  sub_100057438((void *)&_mh_execute_header, v0, v1, "LeConnectionDenyList: Failed to add device \"%{public}@\" to filter accept list because is currently blocked", v2);
}

void sub_10078FC9C()
{
  sub_10005732C();
  sub_1000573B4((void *)&_mh_execute_header, v0, v1, "device \"%{public}@\" already in fConnectingDevices", v2, v3, v4, v5, v6);
}

void sub_10078FD04()
{
  sub_1001604AC();
  int v3 = v0;
  sub_1000574B8((void *)&_mh_execute_header, v1, (uint64_t)v1, "Failed to add device \"%{public}@\" to filter accept list with result %{bluetooth:OI_STATUS}u", v2);
}

void sub_10078FD78(void *a1, _DWORD *a2, void *a3)
{
  id v5 = a1;
  *a2 = 138412290;
  *a3 = v5;
  sub_1000F24C4((void *)&_mh_execute_header, v6, v7, "address %@ is already in the FilterAcceptList");
}

void sub_10078FDDC(os_log_t log)
{
  int v1 = 136446466;
  uint64_t v2 = "Idle";
  __int16 v3 = 2082;
  uint64_t v4 = "Active";
  _os_log_fault_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_FAULT, "Unexpected connection state (%{public}s) in ConnectionManager state (%{public}s) for disconnect request event", (uint8_t *)&v1, 0x16u);
}

void sub_10078FE74()
{
  sub_1000573EC();
  if (v4 != v5) {
    uint64_t v6 = v3;
  }
  else {
    uint64_t v6 = v1;
  }
  sub_100057464(v2, v6, 4.8751e-34);
  sub_100057438((void *)&_mh_execute_header, v7, (uint64_t)v7, "Device \"%{public}s\" is not connected nor pending connection", v8);
  if (*(char *)(v0 + 23) < 0) {
    operator delete(*(void **)v0);
  }
}

void sub_10078FECC()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Unknown connection latency", v2, v3, v4, v5, v6);
}

void sub_10078FF00()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Enabling event for connection subrating failed with result %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_10078FF68()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Disabling event for connection subrating failed with result %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_10078FFD0()
{
  sub_10005732C();
  sub_1003CF064((void *)&_mh_execute_header, v0, v1, "Removed pending connection subrating parameters for handle %p", v2, v3, v4, v5, v6);
}

void sub_100790038()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "No handle exists for device", v2, v3, v4, v5, v6);
}

void sub_10079006C(uint64_t a1, NSObject *a2, uint64_t a3)
{
  int v3 = 138543618;
  uint64_t v4 = 0;
  __int16 v5 = 2114;
  uint64_t v6 = a1;
  sub_100057420((void *)&_mh_execute_header, a2, a3, "device is null \"%{public}@\" for session %{public}@ ", (uint8_t *)&v3);
}

void sub_1007900E8()
{
  sub_10005732C();
  sub_100057438((void *)&_mh_execute_header, v0, v1, "Device \"%{public}@\" needs to be connected for using  RSSI detection", v2);
}

void sub_100790154()
{
  sub_1004428D8(__stack_chk_guard);
  sub_1004428C0();
  sub_1000574F8((void *)&_mh_execute_header, v0, v1, "Unable to convert handle from device \"%{public}@\" for session %{public}@ ");
}

void sub_1007901C8()
{
  sub_1006ACC60();
  sub_1000574F8((void *)&_mh_execute_header, v0, v1, "Failed to disable RSSI statistics and detection for \"%{public}@\". The session  %{public}@  is not currently detecting RSSI ");
}

void sub_100790230()
{
  sub_1006ACC60();
  sub_1000574F8((void *)&_mh_execute_header, v0, v1, "The session %{public}@ is already detecting RSSI statistics and detection for \"%{public}@\"  ");
}

void sub_100790298()
{
  sub_1006ACCF4();
  sub_100359178(v1, v2, 5.8381e-34);
  sub_100057438((void *)&_mh_execute_header, v3, (uint64_t)v3, "Device \"%{public}@\" needs to be connected for configuring BT Usage notifications", v4);
}

void sub_1007902E0()
{
  sub_10005732C();
  sub_100057438((void *)&_mh_execute_header, v0, v1, "Failed to configurate BT Usage notification for \"%{public}@\". Another session already owns bluetooth usage notifications ", v2);
}

void sub_10079034C()
{
  sub_10005732C();
  sub_100057438((void *)&_mh_execute_header, v0, v1, "Unable to find device \"%{public}@\" for session", v2);
}

void sub_1007903B8()
{
  sub_1006ACC60();
  sub_1000574F8((void *)&_mh_execute_header, v0, v1, "Unable to find device \"%{public}@\" for session %{public}@ ");
}

void sub_100790420(uint64_t a1, uint64_t a2)
{
  sub_100359178(a1, a2, 4.8751e-34);
  sub_100057438((void *)&_mh_execute_header, v2, (uint64_t)v2, "%{public}s", v3);
}

void sub_10079045C(const unsigned __int8 *a1, NSObject *a2)
{
  sub_1006ACCA0(a1, (uint64_t)a2);
  sub_100057450();
  sub_100057470();
  sub_100057438((void *)&_mh_execute_header, a2, v3, "Device \"%{public}s\" is not connected nor pending connection", v6);
  if (v5 < 0) {
    operator delete(__p);
  }
}

void sub_1007904F4(const unsigned __int8 *a1, NSObject *a2)
{
  sub_1006ACCA0(a1, (uint64_t)a2);
  sub_100057450();
  sub_100057470();
  sub_100057438((void *)&_mh_execute_header, a2, v3, "Device \"%{public}s\" is not connected nor pending connection", v6);
  if (v5 < 0) {
    operator delete(__p);
  }
}

void sub_10079058C(const unsigned __int8 *a1, NSObject *a2)
{
  sub_1006ACCA0(a1, (uint64_t)a2);
  sub_100057450();
  sub_100057470();
  sub_100057438((void *)&_mh_execute_header, a2, v3, "Device \"%{public}s\" is not connected nor pending connection", v6);
  if (v5 < 0) {
    operator delete(__p);
  }
}

void sub_100790624(const unsigned __int8 *a1, NSObject *a2)
{
  sub_1006ACCA0(a1, (uint64_t)a2);
  sub_100057450();
  sub_100057470();
  sub_100057438((void *)&_mh_execute_header, a2, v3, "Device \"%{public}s\" is not connected nor pending connection", v6);
  if (v5 < 0) {
    operator delete(__p);
  }
}

void sub_1007906BC(const unsigned __int8 *a1, NSObject *a2)
{
  sub_1006ACCA0(a1, (uint64_t)a2);
  sub_100057450();
  sub_100057470();
  sub_100057438((void *)&_mh_execute_header, a2, v3, "Device \"%{public}s\" is not connected nor pending connection", v6);
  if (v5 < 0) {
    operator delete(__p);
  }
}

void sub_100790754()
{
  sub_10005732C();
  sub_100057438((void *)&_mh_execute_header, v0, v1, "CsAgent for session %{public}@ is not found for ", v2);
}

void sub_1007907C0(const unsigned __int8 *a1, NSObject *a2)
{
  sub_1006ACCA0(a1, (uint64_t)a2);
  sub_100057450();
  sub_100057470();
  sub_100057438((void *)&_mh_execute_header, a2, v3, "Device \"%{public}s\" is not connected nor pending connection", v6);
  if (v5 < 0) {
    operator delete(__p);
  }
}

void sub_100790858()
{
  sub_10005732C();
  sub_100057438((void *)&_mh_execute_header, v0, v1, "CsAgent for session %{public}@ is not found", v2);
}

void sub_1007908C4(const unsigned __int8 *a1, NSObject *a2)
{
  sub_1006ACCA0(a1, (uint64_t)a2);
  sub_100057450();
  sub_100057470();
  sub_100057438((void *)&_mh_execute_header, a2, v3, "Device \"%{public}s\" is not connected nor pending connection", v6);
  if (v5 < 0) {
    operator delete(__p);
  }
}

void sub_10079095C()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to start connection with result %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_1007909C4()
{
  sub_1000572DC();
  _os_log_debug_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_DEBUG, "Successfully execute btscLeSetConnectionScan", v1, 2u);
}

void sub_100790A04()
{
  sub_1004428C0();
  sub_100057438((void *)&_mh_execute_header, v0, v1, "We're not supposed to be here, in processConnectingDevices when LE Connection Manager State is %{public}s", v2);
}

void sub_100790A94()
{
  sub_10005732C();
  sub_100057438((void *)&_mh_execute_header, v0, v1, "Device \"%{public}@\" is not in our list, cannot remove it", v2);
}

void sub_100790B00()
{
  sub_10005732C();
  sub_100057438((void *)&_mh_execute_header, v0, v1, "add device %{public}@ with options ignored since it is not supported", v2);
}

void sub_100790B6C()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to remove device from FilterAcceptList with error %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_100790BD4()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to add device to FilterAcceptList with error %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_100790C3C()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "CommandDisableHostWakeupOnLinkDrop autoReconnect flag ignored due to NOT supported", v2, v3, v4, v5, v6);
}

void sub_100790C70()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "DisableHostWakeupOnLinkDrop device NOT connected", v2, v3, v4, v5, v6);
}

void sub_100790CA4()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "CommandDisableHostWakeupOnLinkDrop NOT supported", v2, v3, v4, v5, v6);
}

void sub_100790CD8()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Invalid value for windowConfiguration=(%d). Only valid values are 0,1,2", v2, v3, v4, v5, v6);
}

void sub_100790D40()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Invalid value for enableDebugging=(%d). Only valid values are 0,1", v2, v3, v4, v5, v6);
}

void sub_100790DA8()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "CBUseCaseDigitalID connection prioritization parameters are out of range.", v2, v3, v4, v5, v6);
}

void sub_100790DDC()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "CBUseCaseDigitalIDTSA connection prioritization parameters are out of range.", v2, v3, v4, v5, v6);
}

void sub_100790E10()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Failed to set prioritization threshold", v2, v3, v4, v5, v6);
}

void sub_100790E44()
{
  sub_1006ACCF4();
  sub_100359178(v1, v2, 5.8381e-34);
  sub_100057438((void *)&_mh_execute_header, v3, (uint64_t)v3, "We have a successful outgoing connection to address \"%{public}@\" with new device UUID mapped :( Sadly, we say goodbye to old device.", v4);
}

void sub_100790E8C()
{
  sub_1006ACCF4();
  sub_100359178(v1, v2, 5.8381e-34);
  sub_100057438((void *)&_mh_execute_header, v3, (uint64_t)v3, "We may have an un-tracked connection to address \"%{public}@\" :( Sadly, we say goodbye.", v4);
}

void sub_100790ED4(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_100790F4C()
{
  sub_10030D088();
  if (v6 >= 0) {
    uint64_t v7 = v1;
  }
  else {
    uint64_t v7 = (void *)*v1;
  }
  *(_DWORD *)uint64_t v3 = 136446466;
  *(void *)(v3 + 4) = v7;
  *(_WORD *)(v3 + 12) = 2048;
  *(void *)(v3 + 14) = v2;
  sub_100057420((void *)&_mh_execute_header, v5, v3, "Already have a connection to device \"%{public}s\" (handle %p)", v4);
  if (*(char *)(v0 + 23) < 0) {
    operator delete(*(void **)v0);
  }
}

void sub_100790FBC()
{
  sub_1006ACCF4();
  sub_100359178(v1, v2, 5.8381e-34);
  sub_100057438((void *)&_mh_execute_header, v3, (uint64_t)v3, "We may have an un-tracked connection to address \"%{public}@\" :(", v4);
}

void sub_100791004()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Controller is too busy (result %{bluetooth:OI_STATUS}u), we need to wait until something disconnects.", v2, v3, v4, v5, v6);
}

void sub_10079106C(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_1007910E0()
{
  sub_1006ACD3C();
  sub_100057498((void *)&_mh_execute_header, v0, v1, "Failed to cancel pending connection(s) with result %{bluetooth:OI_STATUS}u ConnectionState=%d");
}

void sub_100791150()
{
  sub_1004428C0();
  __int16 v4 = 1024;
  int v5 = v0;
  sub_1000574B8((void *)&_mh_execute_header, v1, v2, "Got a connection cancel complete event in wrong state %{public}s(%d)", v3);
}

void sub_1007911E8()
{
  sub_1002B7074();
  sub_100057550(v1, v2, v3, 4.8752e-34);
  sub_1000574B8((void *)&_mh_execute_header, v6, v4, "Disconnected unexpectedly from device \"%{public}s\" with error %{bluetooth:OI_STATUS}u", v5);
  if (*(char *)(v0 + 23) < 0) {
    operator delete(*(void **)v0);
  }
}

void sub_10079123C()
{
  sub_1000573EC();
  if (v4 != v5) {
    uint64_t v6 = v3;
  }
  else {
    uint64_t v6 = v1;
  }
  sub_100057464(v2, v6, 4.8751e-34);
  sub_100057438((void *)&_mh_execute_header, v7, (uint64_t)v7, "Connection failed to device \"%{public}s\", Retrying", v8);
  if (*(char *)(v0 + 23) < 0) {
    operator delete(*(void **)v0);
  }
}

void sub_100791294()
{
  sub_1000573EC();
  if (v4 != v5) {
    uint64_t v6 = v3;
  }
  else {
    uint64_t v6 = v1;
  }
  sub_100057464(v2, v6, 4.8751e-34);
  sub_100057438((void *)&_mh_execute_header, v7, (uint64_t)v7, "Connection timed out to device \"%{public}s\"", v8);
  if (*(char *)(v0 + 23) < 0) {
    operator delete(*(void **)v0);
  }
}

void sub_1007912EC()
{
  sub_1000573EC();
  if (v4 != v5) {
    uint64_t v6 = v3;
  }
  else {
    uint64_t v6 = v1;
  }
  sub_100057464(v2, v6, 4.8751e-34);
  sub_100057438((void *)&_mh_execute_header, v7, (uint64_t)v7, "Disconnected from device \"%{public}s\" due to hardware reset", v8);
  if (*(char *)(v0 + 23) < 0) {
    operator delete(*(void **)v0);
  }
}

void sub_100791344()
{
  sub_1000573EC();
  if (v4 != v5) {
    uint64_t v6 = v3;
  }
  else {
    uint64_t v6 = v1;
  }
  sub_100057464(v2, v6, 4.8751e-34);
  sub_100057438((void *)&_mh_execute_header, v7, (uint64_t)v7, "Device \"%{public}s\" no more valid addresses or LTK's", v8);
  if (*(char *)(v0 + 23) < 0) {
    operator delete(*(void **)v0);
  }
}

void sub_10079139C()
{
  sub_1000573EC();
  if (v4 != v5) {
    uint64_t v6 = v3;
  }
  else {
    uint64_t v6 = v1;
  }
  sub_100057464(v2, v6, 4.8751e-34);
  sub_100057438((void *)&_mh_execute_header, v7, (uint64_t)v7, "Automatically retrying connection to FindMy device \"%{public}s\"", v8);
  if (*(char *)(v0 + 23) < 0) {
    operator delete(*(void **)v0);
  }
}

void sub_1007913F4()
{
  sub_1000573EC();
  if (v4 != v5) {
    uint64_t v6 = v3;
  }
  else {
    uint64_t v6 = v1;
  }
  sub_100057464(v2, v6, 4.8751e-34);
  sub_100057438((void *)&_mh_execute_header, v7, (uint64_t)v7, "Disconnected from device \"%{public}s\" due to encryption timeout", v8);
  if (*(char *)(v0 + 23) < 0) {
    operator delete(*(void **)v0);
  }
}

void sub_10079144C()
{
  sub_1000573EC();
  if (v4 != v5) {
    uint64_t v6 = v3;
  }
  else {
    uint64_t v6 = v1;
  }
  sub_100057464(v2, v6, 4.8751e-34);
  sub_100057438((void *)&_mh_execute_header, v7, (uint64_t)v7, "Disconnected from device \"%{public}s\" becuase we have too many paired devices.", v8);
  if (*(char *)(v0 + 23) < 0) {
    operator delete(*(void **)v0);
  }
}

void sub_1007914A4()
{
  sub_1000573EC();
  if (v4 != v5) {
    uint64_t v6 = v3;
  }
  else {
    uint64_t v6 = v1;
  }
  sub_100057464(v2, v6, 4.8751e-34);
  sub_100057438((void *)&_mh_execute_header, v7, (uint64_t)v7, "Disconnected from device \"%{public}s\" due to MIC failure", v8);
  if (*(char *)(v0 + 23) < 0) {
    operator delete(*(void **)v0);
  }
}

void sub_1007914FC()
{
  sub_1000573EC();
  if (v4 != v5) {
    uint64_t v6 = v3;
  }
  else {
    uint64_t v6 = v1;
  }
  sub_100057464(v2, v6, 4.8751e-34);
  sub_100057438((void *)&_mh_execute_header, v7, (uint64_t)v7, "Disconnected from device \"%{public}s\", Fast LE Connection establishment failed", v8);
  if (*(char *)(v0 + 23) < 0) {
    operator delete(*(void **)v0);
  }
}

void sub_100791554()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Unable to find connected device, most likely because the device probably had a bad address and we ignored it when it connected.", v2, v3, v4, v5, v6);
}

void sub_100791588(void *a1, uint64_t a2)
{
  id v3 = a1;
  *(_DWORD *)a2 = 138543362;
  *(void *)(a2 + 4) = v3;
  sub_1006ACD50((void *)&_mh_execute_header, v4, v5, "Removing entry for address %{public}@ from pending parameters map");
}

void sub_1007915E8(void *a1, uint64_t a2)
{
  id v3 = a1;
  *(_DWORD *)a2 = 138543362;
  *(void *)(a2 + 4) = v3;
  sub_1006ACD50((void *)&_mh_execute_header, v4, v5, "Removing entry for address %{public}@ from configured parameters map");
}

void sub_100791648()
{
  sub_1006ACCD8();
  _os_log_debug_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_DEBUG, "purgeDisconnectionHistoryLeConnectionRSSIThresholdState: count %d maxDisconnectionHistoryUUIDs %d not full", v1, 0xEu);
}

void sub_1007916BC()
{
  sub_1004428D8(__stack_chk_guard);
  sub_1006ACD3C();
  int v3 = v0;
  _os_log_debug_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_DEBUG, "purgeDisconnectionHistoryLeConnectionRSSIThresholdState: count %d -> %d", v2, 0xEu);
}

void sub_100791738(NSObject *a1, double a2, double a3, uint64_t a4, uint64_t a5)
{
  int v5 = 134218240;
  double v6 = a2;
  __int16 v7 = 2048;
  double v8 = a3;
  sub_100057420((void *)&_mh_execute_header, a1, a5, "purgeDisconnectionHistoryLeConnectionRSSIThresholdState: invalid currentTime %f cutoffTime %f", (uint8_t *)&v5);
}

void sub_1007917B8()
{
  sub_1003E68EC(__stack_chk_guard);
  sub_10005732C();
  sub_1003CF064((void *)&_mh_execute_header, v0, v1, "upsertDisconnectionHistoryElement %{public}s not found from fDisconnectionHistoryMap. Create a new entry.", v2, v3, v4, v5, v6);
}

void sub_100791828()
{
  sub_100057584();
  sub_10033D554((void *)&_mh_execute_header, v0, v1, "upsertDisconnectionHistoryElement map is full delete %d keys", v2, v3, v4, v5, v6);
}

void sub_100791890()
{
  sub_1003E68EC(__stack_chk_guard);
  sub_10005732C();
  sub_1003CF064((void *)&_mh_execute_header, v0, v1, "upsertDisconnectionHistoryElement %{public}s found from fDisconnectionHistoryMap", v2, v3, v4, v5, v6);
}

BOOL sub_100791900(uint64_t a1, void *a2)
{
  sub_1000572DC();
  _os_log_fault_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_FAULT, "fFastConnectionScanTimer is already running!", v5, 2u);
  return *a2 == 0;
}

void sub_100791958()
{
  sub_1004428C0();
  sub_1003CF064((void *)&_mh_execute_header, v0, v1, "fConnectingDevices.size:%ld", v2, v3, v4, v5, v6);
}

void sub_1007919C4()
{
  sub_1004428C0();
  __int16 v3 = 2048;
  uint64_t v4 = v0;
  _os_log_debug_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_DEBUG, "fConnectionState:%{public}s fConnectingDevices.size:%ld", v2, 0x16u);
}

void sub_100791A70()
{
  sub_10005732C();
  sub_100057438((void *)&_mh_execute_header, v0, v1, "Unable to find device for HCI handle %p", v2);
}

void sub_100791ADC()
{
  sub_10005732C();
  sub_100057438((void *)&_mh_execute_header, v0, v1, "Unable to find a listener for device \"%{public}@\"", v2);
}

void sub_100791B48()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "No device for handle!", v2, v3, v4, v5, v6);
}

void sub_100791B7C()
{
  sub_1004428D8(__stack_chk_guard);
  sub_1004428C0();
  sub_100057438((void *)&_mh_execute_header, v0, v1, "Unable to find connected device for HCI handle %p", v2);
}

void sub_100791BE8()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "LE link is down, wait for disconnection complete", v2, v3, v4, v5, v6);
}

void sub_100791C1C()
{
  sub_1002B7074();
  sub_100057550(v1, v2, v3, 4.8752e-34);
  sub_1000574B8((void *)&_mh_execute_header, v6, v4, "Le link \"%{public}s\" is ready with error %{bluetooth:OI_STATUS}u", v5);
  if (*(char *)(v0 + 23) < 0) {
    operator delete(*(void **)v0);
  }
}

void sub_100791C70()
{
  sub_10005732C();
  sub_1000573B4((void *)&_mh_execute_header, v0, v1, "Unable to find connected device for HCI handle %p", v2, v3, v4, v5, v6);
}

void sub_100791CD8(uint8_t *buf, unsigned char *a2, os_log_t log)
{
  *uint64_t buf = 0;
  *a2 = 0;
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "Failed to set prioritization threshold", buf, 2u);
}

void sub_100791D18(uint8_t *buf, unsigned char *a2, os_log_t log)
{
  *uint64_t buf = 0;
  *a2 = 0;
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "Invalid LE connection handle!!", buf, 2u);
}

void sub_100791D58()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to update connection parameters with status=%{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_100791DC0()
{
  sub_100057584();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Invalid minimum interval: %u", v2, v3, v4, v5, v6);
}

void sub_100791E28()
{
  sub_100057584();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Invalid maximum interval: %u", v2, v3, v4, v5, v6);
}

void sub_100791E90()
{
  sub_1000575E4();
  sub_100057498((void *)&_mh_execute_header, v0, v1, "Maximum interval is smaller than minimum interval: %u > %u", v2, v3);
}

void sub_100791EF8()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Invalid peripheral latency: %u", v2, v3, v4, v5, v6);
}

void sub_100791F60()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Invalid timeout multiplier: %u", v2, v3, v4, v5, v6);
}

void sub_100791FC8()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Remote side wants an interval that would provide a poor user experience (more than 2 seconds syncups)", v2, v3, v4, v5, v6);
}

void sub_100791FFC()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Remote side wants an interval / latency combination that would provide a poor user experience (more than 6 seconds syncups)", v2, v3, v4, v5, v6);
}

void sub_100792030(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_1007920A4(unsigned __int16 *a1, NSObject *a2, uint64_t a3, float a4)
{
  int v4 = *a1;
  v5[0] = 67109376;
  v5[1] = v4;
  __int16 v6 = 2048;
  double v7 = a4;
  sub_1000574B8((void *)&_mh_execute_header, a2, a3, "The min requested is lower that the desired min: %u < %f", (uint8_t *)v5);
}

void sub_100792128()
{
  sub_1001004CC();
  int v2 = 18000;
  _os_log_error_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_ERROR, "Remote side (peripheral) asks for a timeout (%u ms) of more than %d seconds. This is not very user friendly - refusing", v1, 0xEu);
}

void sub_1007921A4(_DWORD *a1, uint64_t a2, void *a3)
{
  uint64_t v5 = sub_1006AD3F0();
  *a1 = 138543362;
  *a3 = v5;
  sub_1000F24C4((void *)&_mh_execute_header, v6, v7, "We may have an un-tracked auto-reconnect to address \"%{public}@\" :( Sadly, we say goodbye.");
}

void sub_10079220C()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Invalid state", v2, v3, v4, v5, v6);
}

void sub_100792240()
{
  sub_1003E68EC(__stack_chk_guard);
  sub_10005732C();
  sub_1003CF064((void *)&_mh_execute_header, v0, v1, "deleteDisconnectionHistoryElement: %{public}s", v2, v3, v4, v5, v6);
}

void sub_1007922B0()
{
  sub_1006ACD00(__stack_chk_guard);
  sub_1004428C0();
  sub_100057438((void *)&_mh_execute_header, v0, (uint64_t)v0, "getNextLeConnectionRSSIThresholdState: %{public}s is in invalid state", v1);
}

void sub_100792320()
{
  sub_1003E68EC(__stack_chk_guard);
  sub_10005732C();
  sub_1003CF064((void *)&_mh_execute_header, v0, v1, "deleteLeConnectionRSSIThresholdState: %{public}s", v2, v3, v4, v5, v6);
}

void sub_100792390()
{
  sub_1006ACCD8();
  _os_log_debug_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_DEBUG, "capDisconnectionHistoryLeConnectionRSSIThresholdState: count %d maxDisconnectionHistoryUUIDs %d not full", v1, 0xEu);
}

void sub_100792404(const unsigned __int8 *a1, NSObject *a2)
{
  uint64_t v3 = sub_100031234(a1);
  sub_10005732C();
  sub_100057438((void *)&_mh_execute_header, a2, v4, "Failed to set connection AFH Map for device \"%{public}@\" as it isn't connected", v5);
}

void sub_100792494()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to set connection AFH Map status=%{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_1007924FC()
{
  sub_1003E68EC(__stack_chk_guard);
  sub_10005732C();
  sub_100057438((void *)&_mh_execute_header, v0, v1, "handleConnScanRxStoppedCB: uuid %s cannot be found from fConnScanUseCaseParamsMap", v2);
}

void sub_100792570(int a1, NSObject *a2)
{
  sub_10003D640(a1);
  sub_10005732C();
  sub_100057438((void *)&_mh_execute_header, a2, v3, "handleConnScanRxStoppedCB: unexpected useCase %s", v4);
}

void sub_1007925F0()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "address data cannot be nil", v2, v3, v4, v5, v6);
}

void sub_100792624(uint64_t a1, NSObject *a2, uint64_t a3)
{
  int v3 = 138412290;
  uint64_t v4 = a1;
  sub_100057438((void *)&_mh_execute_header, a2, a3, "Invalid address %@", (uint8_t *)&v3);
}

void sub_100792694()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Invalid findMyID", v2, v3, v4, v5, v6);
}

void sub_1007926C8(void *a1, uint64_t a2, NSObject *a3)
{
  *(_DWORD *)a2 = 138412290;
  *(void *)(a2 + 4) = a1;
  sub_100057438((void *)&_mh_execute_header, a3, (uint64_t)a3, "Invalid allowed sessions for FindMy device %@", (uint8_t *)a2);
}

void sub_100792718(void *a1, uint64_t a2, NSObject *a3)
{
  *(_DWORD *)a2 = 138412290;
  *(void *)(a2 + 4) = a1;
  sub_100057438((void *)&_mh_execute_header, a3, (uint64_t)a3, "Invalid addresses for FindMy device %@", (uint8_t *)a2);
}

void sub_100792768()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Invalid serialNumber", v2, v3, v4, v5, v6);
}

void sub_10079279C(uint64_t a1, void *a2, uint64_t a3)
{
  sub_1003E68B4(a1, (uint64_t)a2, a3, 5.778e-34);
  _os_log_error_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "Invalid address (%@) for FindMy device %@", v4, 0x16u);
}

void sub_1007927F4(uint64_t a1, void *a2, uint64_t a3)
{
  sub_1003E68B4(a1, (uint64_t)a2, a3, 5.778e-34);
  _os_log_error_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "Invalid LTK (%@) for FindMy device %@", v4, 0x16u);
}

void sub_10079284C()
{
  sub_1004428D8(__stack_chk_guard);
  sub_1004428C0();
  __int16 v2 = 1024;
  int v3 = 0;
  _os_log_error_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_ERROR, "FastLeConnection:setControllerInfo not enabling Fast LE Connection to device %@ fFastLeConnectionAllowed:%d", v1, 0x12u);
}

void sub_1007928CC()
{
  sub_1004428D8(__stack_chk_guard);
  sub_1004428C0();
  sub_100057438((void *)&_mh_execute_header, v0, v1, "FastLeConnection:enableFastLEConnection %@ Address cannot be 0", v2);
}

void sub_100792938()
{
  sub_1004428D8(__stack_chk_guard);
  sub_1004428C0();
  sub_100057438((void *)&_mh_execute_header, v0, v1, "FastLEConnection:LeDevice::enableFastLEConnection %@ cannot enable, peer does not have our updated info", v2);
}

void sub_1007929A4()
{
  sub_1000572DC();
  _os_log_fault_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_FAULT, "FastLEConnection:LeDevice::setLEPaired FastLEConnection:Address cannot be 0", v1, 2u);
}

void sub_1007929E4()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Invalid property", v2, v3, v4, v5, v6);
}

void sub_100792A18(uint64_t a1, uint64_t a2, os_log_t log)
{
  int v3 = 138412546;
  uint64_t v4 = a1;
  __int16 v5 = 2112;
  uint64_t v6 = a2;
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "Invalid property value (too long): %@ = %@", (uint8_t *)&v3, 0x16u);
}

void sub_100792AA0()
{
  sub_1004428D8(__stack_chk_guard);
  sub_1004428C0();
  sub_100057438((void *)&_mh_execute_header, v0, v1, "setCustomProperty device %@ does not have a resolvable or linked address", v2);
}

void sub_100792B0C()
{
  sub_1000572DC();
  _os_log_fault_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_FAULT, "Invalid state, device is neither CTKD or linked transport", v1, 2u);
}

void sub_100792B4C(uint64_t a1, NSObject *a2)
{
  sub_1006ACF44();
  if (v6 >= 0) {
    p_p = &__p;
  }
  else {
    p_p = __p;
  }
  int v7 = 136315138;
  double v8 = p_p;
  sub_100057438((void *)&_mh_execute_header, a2, v3, "setCustomProperty Failed to get a classic device for address %s", (uint8_t *)&v7);
  if (v6 < 0) {
    operator delete(__p);
  }
}

void sub_100792C00(uint64_t a1, uint8_t *buf, int a3, os_log_t log)
{
  *(_DWORD *)uint64_t buf = 136315394;
  *(void *)(buf + 4) = a1;
  *((_WORD *)buf + 6) = 1024;
  *(_DWORD *)(buf + 14) = a3;
  _os_log_fault_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_FAULT, "Failed to take assertionId for name: %s, return value was: %d", buf, 0x12u);
}

void sub_100792C58(int *a1, int a2, os_log_t log)
{
  int v3 = *a1;
  v4[0] = 67109376;
  v4[1] = v3;
  __int16 v5 = 1024;
  int v6 = a2;
  _os_log_fault_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_FAULT, "Failed to release assertionId: %d, return value was %d", (uint8_t *)v4, 0xEu);
}

void sub_100792CE4()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Ignoring invalid override value (%d) for max number of devices to be cached in memory", v2, v3, v4, v5, v6);
}

void sub_100792D4C(os_log_t log)
{
  int v1 = 136446210;
  uint64_t v2 = "uuid";
  _os_log_fault_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_FAULT, "Assertion failed: %{public}s", (uint8_t *)&v1, 0xCu);
}

void sub_100792DD0(uint8_t *buf, unsigned char *a2, os_log_t log)
{
  *uint64_t buf = 0;
  *a2 = 0;
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "Ignoring device with no keys", buf, 2u);
}

void sub_100792E10(uint8_t *buf, unsigned char *a2, os_log_t log)
{
  *uint64_t buf = 0;
  *a2 = 0;
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "Skipping due to missing addresses", buf, 2u);
}

void sub_100792E50(void *a1, uint64_t a2, NSObject *a3)
{
  *(_DWORD *)a2 = 138543362;
  *(void *)(a2 + 4) = a1;
  sub_100057438((void *)&_mh_execute_header, a3, (uint64_t)a3, "Remote Bluetooth address \"%{public}@\" is invalid!", (uint8_t *)a2);
}

void sub_100792EA0()
{
  sub_1000572DC();
  sub_10030D118((void *)&_mh_execute_header, v0, v1, "Trying to create new device from empty address!", v2, v3, v4, v5, v6);
}

void sub_100792ED4()
{
  sub_1005B9128();
  sub_1002C5590(v2, v3, v4, 5.8382e-34);
  sub_10030D09C((void *)&_mh_execute_header, "Now tracking new address \"%{public}@\" as device \"%{public}s\"", v5, v6);
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
}

void sub_100792F2C()
{
  sub_1000573EC();
  if (v4 != v5) {
    uint64_t v6 = v3;
  }
  else {
    uint64_t v6 = v1;
  }
  sub_100057464(v2, v6, 4.8751e-34);
  sub_100057438((void *)&_mh_execute_header, v7, (uint64_t)v7, "UUID generation collision - UUID \"%{public}s\" already exists!", v8);
  if (*(char *)(v0 + 23) < 0) {
    operator delete(*(void **)v0);
  }
}

void sub_100792F84()
{
  sub_1006D0FBC();
  sub_1006D0FA4(v1, v2, v3, 5.8382e-34);
  sub_10036A474((void *)&_mh_execute_header, "Address \"%{public}@\" was not in the address map, but WAS in the device map as device \"%{public}@\"", v4, v5);
}

void sub_100792FC8()
{
  sub_1006D0FBC();
  sub_1006D0FA4(v1, v2, v3, 5.8382e-34);
  sub_1004A8270((void *)&_mh_execute_header, "Address \"%{public}@\" is already associated with device \"%{public}@\", cannot use alternate identifier", v4, v5);
}

void sub_10079300C()
{
  sub_1005B9128();
  sub_1002C5590(v2, v3, v4, 5.8382e-34);
  sub_1004A8270((void *)&_mh_execute_header, "Already tracking address \"%{public}@\" as device \"%{public}s\", cannot re-assign a new identifier to it", v5, v6);
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
}

void sub_100793064()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Cannot specify an identifier and not set create and requiresProtectedCache to true", v2, v3, v4, v5, v6);
}

void sub_100793098()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Failed to load device caches - device information will not be persisted", v2, v3, v4, v5, v6);
}

void sub_1007930CC()
{
  sub_1002C55CC();
  sub_1002C5590(v1, v2, v3, 5.8382e-34);
  sub_10030D09C((void *)&_mh_execute_header, "Unset tag: \"%{public}@\" for valid classicDevice %{public}s", v4, v5);
  if (*(char *)(v0 + 23) < 0) {
    operator delete(*(void **)v0);
  }
}

void sub_10079311C()
{
  sub_1002C55CC();
  sub_1002C5590(v1, v2, v3, 5.8382e-34);
  sub_1004A8270((void *)&_mh_execute_header, "Unable to unset tag: \"%{public}@\" for valid classicDevice %{public}s", v4, v5);
  if (*(char *)(v0 + 23) < 0) {
    operator delete(*(void **)v0);
  }
}

void sub_10079316C()
{
  sub_1002C55CC();
  if (v5 >= 0) {
    uint8_t v6 = v1;
  }
  else {
    uint8_t v6 = (void *)*v1;
  }
  *(_DWORD *)uint64_t v2 = 136315138;
  *(void *)(v2 + 4) = v6;
  sub_100057438((void *)&_mh_execute_header, v4, v2, "LeDeviceManager::persistDevice - could not find device for UUID %s", v3);
  if (*(char *)(v0 + 23) < 0) {
    operator delete(*(void **)v0);
  }
}

void sub_1007931D0()
{
  sub_1000573EC();
  if (v4 != v5) {
    uint64_t v6 = v3;
  }
  else {
    uint64_t v6 = v1;
  }
  sub_100057464(v2, v6, 4.8751e-34);
  sub_100057438((void *)&_mh_execute_header, v7, (uint64_t)v7, "Attempting to persist non-paired device \"%{public}s\" before the protected cache has been loaded.", v8);
  if (*(char *)(v0 + 23) < 0) {
    operator delete(*(void **)v0);
  }
}

void sub_100793228()
{
  sub_10005732C();
  sub_1000572F4((void *)&_mh_execute_header, v0, v1, "No address for unknown device \"%{public}@\"", v2, v3, v4, v5, v6);
}

void sub_100793290(void *a1, uint64_t a2, NSObject *a3)
{
  *(_DWORD *)a2 = 138543362;
  *(void *)(a2 + 4) = a1;
  sub_1004F600C((void *)&_mh_execute_header, a2, a3, "Device \"%{public}@\" has no address!", (uint8_t *)a2);
}

void sub_1007932DC(uint64_t a1, NSObject *a2)
{
  int v2 = *(unsigned __int8 *)(a1 + 320);
  v3[0] = 67109120;
  v3[1] = v2;
  _os_log_debug_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_DEBUG, "Is incompatible BLE HID device connected: %u", (uint8_t *)v3, 8u);
}

void sub_100793358()
{
  sub_1002C55CC();
  sub_1002C5590(v1, v2, v3, 4.8752e-34);
  sub_10030D09C((void *)&_mh_execute_header, "Set tag: \"%{public}s\" for valid classicDevice %{public}s", v4, v5);
  if (*(char *)(v0 + 23) < 0) {
    operator delete(*(void **)v0);
  }
}

void sub_1007933A8()
{
  sub_1002C55CC();
  sub_1002C5590(v1, v2, v3, 4.8752e-34);
  sub_1004A8270((void *)&_mh_execute_header, "Unable to set tag: \"%{public}s\" for valid classicDevice %{public}s", v4, v5);
  if (*(char *)(v0 + 23) < 0) {
    operator delete(*(void **)v0);
  }
}

void sub_1007933F8()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Unable to remove device INVALIDATE_CARKEY_DEVICE since paired", v2, v3, v4, v5, v6);
}

void sub_10079342C()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "External Lock devices got set with wrong tag HasTS", v2, v3, v4, v5, v6);
}

void sub_100793460()
{
  sub_10005732C();
  sub_1000572F4((void *)&_mh_execute_header, v0, v1, "No device found for identifier %{public}@", v2, v3, v4, v5, v6);
}

void sub_1007934C8()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Invalid property", v2, v3, v4, v5, v6);
}

void sub_1007934FC()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "device not found", v2, v3, v4, v5, v6);
}

void sub_100793530()
{
  sub_1000572E8();
  _os_log_fault_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_FAULT, "SetInitPHYs invalid initPHYs=%x", v1, 8u);
}

void sub_1007935A4()
{
  sub_1000572E8();
  _os_log_fault_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_FAULT, "SetPHYOptions invalid PHYOptions=%x", v1, 8u);
}

void sub_100793618(char a1, NSObject *a2)
{
  v2[0] = 67109120;
  v2[1] = a1 & 1;
  _os_log_debug_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_DEBUG, "updateBTClock =%x", (uint8_t *)v2, 8u);
}

void sub_100793694(uint8_t *a1, void *a2, NSObject *a3)
{
  *(_DWORD *)a1 = 136446210;
  *a2 = "aDevice";
  sub_1004F600C((void *)&_mh_execute_header, (int)a2, a3, "Assertion failed: %{public}s", a1);
}

void sub_1007936D8()
{
  sub_1000572E8();
  __int16 v3 = 1024;
  int v4 = v0;
  _os_log_debug_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_DEBUG, "Device cache size exceeded limit %d (fDeviceLRUList size %d)", v2, 0xEu);
}

void sub_10079375C()
{
  sub_1000572DC();
  sub_10030D118((void *)&_mh_execute_header, v0, v1, "Unexpected null LeDeviceManager::indexLeDevice parameter", v2, v3, v4, v5, v6);
}

void sub_100793790(os_log_t log)
{
  int v1 = 136446210;
  uint64_t v2 = "it != fDeviceLRUList.end()";
  _os_log_fault_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_FAULT, "Assertion failed: %{public}s", (uint8_t *)&v1, 0xCu);
}

void sub_100793814()
{
  sub_10005732C();
  sub_1000572F4((void *)&_mh_execute_header, v0, v1, "Failed to create a peripheral with identifier \"%{public}@\"", v2, v3, v4, v5, v6);
}

void sub_10079387C()
{
  sub_1006D0FBC();
  sub_1006D0FA4(v1, v2, v3, 5.8382e-34);
  sub_10030D09C((void *)&_mh_execute_header, "Now tracking new address \"%{public}@\" as device \"%{public}@\"", v4, v5);
}

void sub_1007938C0()
{
  sub_1000573EC();
  if (v4 != v5) {
    uint64_t v6 = v3;
  }
  else {
    uint64_t v6 = v1;
  }
  sub_100057464(v2, v6, 4.8751e-34);
  sub_1004F600C((void *)&_mh_execute_header, v7, v8, "Trying to set a resolved address that is neither public nor static for device \"%{public}s\"", v9);
  if (*(char *)(v0 + 23) < 0) {
    operator delete(*(void **)v0);
  }
}

void sub_100793914()
{
  sub_1000572DC();
  sub_10030D118((void *)&_mh_execute_header, v0, v1, "cacheEvictedDeviceIfNeeded we need at least one old device to remove at this point", v2, v3, v4, v5, v6);
}

void sub_100793948()
{
  sub_10005732C();
  sub_1000572F4((void *)&_mh_execute_header, v0, v1, "Failed to get Firmware version for device %{public}@", v2, v3, v4, v5, v6);
}

void sub_1007939B0()
{
  sub_10005732C();
  __int16 v3 = 2112;
  uint64_t v4 = v0;
  _os_log_error_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_ERROR, "createLexiconWithLocale Failed to create %@ LXLexiconRef: %@", v2, 0x16u);
}

void sub_100793A34(unsigned __int16 a1, unsigned __int8 *a2, uint8_t *buf, os_log_t log)
{
  int v4 = *a2;
  *(_DWORD *)uint64_t buf = 67109376;
  *((_DWORD *)buf + 1) = a1;
  *((_WORD *)buf + 4) = 1024;
  *(_DWORD *)(buf + 10) = v4;
  _os_log_fault_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_FAULT, "_retrieveRecentDevicesInfo array count %d larger than max %d", buf, 0xEu);
}

void sub_100793A94()
{
  sub_1006D0FCC(__stack_chk_guard);
  sub_1004428C0();
  __int16 v3 = 1024;
  int v4 = v0;
  _os_log_error_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_ERROR, "[BTGlobalTCCNames] Failed to detach session %@ with error %d", v2, 0x12u);
}

void sub_100793B18()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "[BTGlobalTCCNames] Failed to get session from sessionHandle", v2, v3, v4, v5, v6);
}

void sub_100793B4C()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "[BTGlobalTCCNames] Failed to create session", v2, v3, v4, v5, v6);
}

void sub_100793B80()
{
  sub_1006D0FCC(__stack_chk_guard);
  sub_1004428C0();
  sub_1000572F4((void *)&_mh_execute_header, v0, v1, "[BTGlobalTCCNames] session %@ is already using this manager", v2, v3, v4, v5, v6);
}

void sub_100793BE8()
{
  sub_1006D0FCC(__stack_chk_guard);
  sub_1004428C0();
  sub_1000572F4((void *)&_mh_execute_header, v0, v1, "[BTGlobalTCCNames] Failed to detach session %@", v2, v3, v4, v5, v6);
}

void sub_100793C50()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "[BTGlobalTCCNames] Failed to stop scanning with result :%d", v2, v3, v4, v5, v6);
}

void sub_100793CB8()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "OI_DEVMGR_GetLeRemoteSupportedFeatures fails with %d", v2, v3, v4, v5, v6);
}

void sub_100793D20()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "OI_DEVMGR_GetLeRemoteVersioning fails with %d", v2, v3, v4, v5, v6);
}

void sub_100793D88(void *a1)
{
  do
  {
    if (*((char *)a1 - 9) < 0) {
      operator delete((void *)*(a1 - 4));
    }
    a1 -= 4;
  }
  while (a1 != qword_100A145C0);
}

void sub_100793DCC()
{
  sub_1000572DC();
  sub_1002E4C44((void *)&_mh_execute_header, v0, v1, "LeObserver Power : We're going to sleep!", v2, v3, v4, v5, v6);
}

void sub_100793E00()
{
  sub_1006F7358();
  sub_1000574B8((void *)&_mh_execute_header, v0, (uint64_t)v0, "ADVBUFF(%{public}@): Failed to disable adv Buffer : %d", v1);
}

void sub_100793E98()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Invalid address", v2, v3, v4, v5, v6);
}

void sub_100793ECC()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Invalid encryption key specified", v2, v3, v4, v5, v6);
}

void sub_100793F00()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Failed to convert address to string", v2, v3, v4, v5, v6);
}

void sub_100793F34()
{
  sub_1000572DC();
  sub_1002E4C44((void *)&_mh_execute_header, v0, v1, "Configuration Timer Already Started", v2, v3, v4, v5, v6);
}

void sub_100793F68()
{
  sub_1000572E8();
  sub_10033D554((void *)&_mh_execute_header, v0, v1, "Controller configuration took: %d ms", v2, v3, v4, v5, v6);
}

void sub_100793FD0()
{
  sub_1000572DC();
  sub_1002E4C44((void *)&_mh_execute_header, v0, v1, "aopReceivedDeviceFoundEvent: inDeviceEntry not valid", v2, v3, v4, v5, v6);
}

void sub_100794004()
{
  sub_1000574EC();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Ignoring invalid data length %d", v2, v3, v4, v5, v6);
}

void sub_100794070(uint64_t a1, NSObject *a2)
{
  uint64_t v3 = sub_1006AD3F0();
  int v5 = 138412290;
  uint8_t v6 = v3;
  sub_100057438((void *)&_mh_execute_header, a2, v4, "aopReceivedDeviceFoundEvent: Bluetooth address \"%@\" is invalid!", (uint8_t *)&v5);
}

void sub_100794104(uint64_t a1, NSObject *a2)
{
  v2[0] = 68157954;
  v2[1] = 43;
  __int16 v3 = 2096;
  uint64_t v4 = a1;
  _os_log_debug_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_DEBUG, "aopReceivedDeviceFoundEvent: AOPBTDeviceEntry entry, entry_buff:%.43P", (uint8_t *)v2, 0x12u);
}

void sub_10079418C()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "LeObserver::FoundCb _LE_GAP_ParseAppleManufacturingData returned %d", v2, v3, v4, v5, v6);
}

void sub_1007941F4()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "enableMatchTable(Proximity Pairing) failed with result %d", v2, v3, v4, v5, v6);
}

void sub_10079425C()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "enableMatchTable(All Types) failed with result %d", v2, v3, v4, v5, v6);
}

void sub_1007942C4()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "enableMatchTable(People Discovery) failed with result %d", v2, v3, v4, v5, v6);
}

void sub_10079432C()
{
  sub_10052EAB8();
  sub_100057498((void *)&_mh_execute_header, v0, v1, "Failed to create Match Table for type %d with result %d", 67109376, v2);
}

void sub_1007943A0()
{
  sub_10052EAB8();
  sub_100057498((void *)&_mh_execute_header, v0, v1, "Failed to destroy Match Table for type %d with result %d", 67109376, v2);
}

void sub_100794414()
{
  sub_1000574EC();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "match table for type %d does not exists", v2, v3, v4, v5, v6);
}

void sub_100794480()
{
  sub_10052EAB8();
  sub_100057498((void *)&_mh_execute_header, v0, v1, "Failed to send type %d match table parameter command : %d", 67109376, v2);
}

void sub_1007944F0()
{
  sub_10052EAB8();
  sub_100057498((void *)&_mh_execute_header, v0, v1, "Failed to send type %d match table config command with match table extended filter config command: %d", 67109376, v2);
}

void sub_100794560()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "createAOPBTBufferMatchTable: getNextMatchRuleAvailableHandle returned %d", v2, v3, v4, v5, v6);
}

void sub_1007945C8()
{
  sub_1000572DC();
  sub_1002E4C44((void *)&_mh_execute_header, v0, v1, "Creating an AOP match table with all types", v2, v3, v4, v5, v6);
}

void sub_1007945FC()
{
  sub_1000574EC();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "ADVBUFF Unknown buffer size %d", v2, v3, v4, v5, v6);
}

void sub_100794668(unsigned char *a1, unsigned char *a2)
{
  sub_10026C69C(a1, a2);
  _os_log_fault_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_FAULT, "Controller failed to read ADV buffers", v3, 2u);
}

void sub_1007946A0()
{
  sub_1006F7358();
  sub_1000574B8((void *)&_mh_execute_header, v0, (uint64_t)v0, "ADVBUFF(%{public}@): Failed to enable adv Buffer : %d", v1);
}

void sub_100794738()
{
  sub_1000572E8();
  sub_10033D554((void *)&_mh_execute_header, v0, v1, "enableMatchActionRulesBuffering returned %d", v2, v3, v4, v5, v6);
}

void sub_1007947A0()
{
  sub_1000572E8();
  sub_10033D554((void *)&_mh_execute_header, v0, v1, "configureMatchActionRulesTableInternal returned %d", v2, v3, v4, v5, v6);
}

void sub_100794808()
{
  sub_1000572DC();
  _os_log_fault_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_FAULT, "We were not expecting to get anything right now", v1, 2u);
}

void sub_100794848()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to create Match Action Rules table with result %d", v2, v3, v4, v5, v6);
}

void sub_1007948B0()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to enable and resume: %d", v2, v3, v4, v5, v6);
}

void sub_100794918()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to send match table parmater command : %d", v2, v3, v4, v5, v6);
}

void sub_100794980()
{
  sub_1000572E8();
  sub_10033D554((void *)&_mh_execute_header, v0, v1, "fMatchActionTableRules numOfRules=%d", v2, v3, v4, v5, v6);
}

void sub_1007949E8()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to pause: %d", v2, v3, v4, v5, v6);
}

void sub_100794A50()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "No buffers to read, skipping", v2, v3, v4, v5, v6);
}

void sub_100794A84()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Already reading buffers, skipping", v2, v3, v4, v5, v6);
}

void sub_100794AB8()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "AOPBTProxCtxBuffer failed to pause Proximity Pairing match table with result %d, skipping read", v2, v3, v4, v5, v6);
}

void sub_100794B20()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "AOPBTProxCtxBuffer failed to pause All Types match table with result %d, skipping read", v2, v3, v4, v5, v6);
}

void sub_100794B88(unsigned __int8 a1, uint64_t a2, NSObject *a3)
{
  LOWORD(v3) = 1024;
  HIWORD(v3) = a1;
  sub_100057498((void *)&_mh_execute_header, a2, a3, "Match Table handle:%d type:%d out of range", 67109376, v3);
}

void sub_100794C04()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "AOPBTADPDBuff Failed to pause match table with result %d, skipping read", v2, v3, v4, v5, v6);
}

void sub_100794C6C(uint64_t a1, NSObject *a2)
{
  sub_1006DA91C(a1, 1);
  sub_1000572E8();
  _os_log_debug_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_DEBUG, "enableMatchActionRulesBuffering returned %d", v3, 8u);
}

void sub_100794CF8(uint64_t a1, uint64_t a2, NSObject *a3)
{
  sub_1006DD0C0(a1);
  sub_1000572E8();
  __int16 v6 = 1024;
  int v7 = v4;
  _os_log_debug_impl((void *)&_mh_execute_header, a3, OS_LOG_TYPE_DEBUG, "Match Buffer readMatchBuffers returned %d, fMatchBufferExpectedEntries:%d", v5, 0xEu);
}

void sub_100794D94(uint64_t a1, NSObject *a2)
{
  int v2 = *(_DWORD *)(a1 + 268);
  int v3 = *(_DWORD *)(a1 + 272);
  v4[0] = 67109376;
  v4[1] = v2;
  __int16 v5 = 1024;
  int v6 = v3;
  _os_log_debug_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_DEBUG, "BLEScanStat: PageScan totalBTSCPageScanTime %d totalBTSCPageScanNumIDPackets %d", (uint8_t *)v4, 0xEu);
}

void sub_100794E20()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Error reading getScanStats %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_100794E88()
{
  sub_1000572E8();
  sub_10033D554((void *)&_mh_execute_header, v0, v1, "BLEScanStat: numScanRequests increments %d", v2, v3, v4, v5, v6);
}

void sub_100794EF0()
{
  sub_1000572E8();
  sub_10033D554((void *)&_mh_execute_header, v0, v1, "BLEScanStat: numPriorityCriticalScanRequests increments %d", v2, v3, v4, v5, v6);
}

void sub_100794F58()
{
  sub_1000572E8();
  sub_10033D554((void *)&_mh_execute_header, v0, v1, "BLEScanStat: numRangeScanRequests increments %d", v2, v3, v4, v5, v6);
}

void sub_100794FC0()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to create ADV Buffer NO with result %d", v2, v3, v4, v5, v6);
}

void sub_100795028()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Cannot create NO OjectDiscovery buffer, not enough free buffers", v2, v3, v4, v5, v6);
}

void sub_10079505C()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to create ADV Buffer wild with result %d", v2, v3, v4, v5, v6);
}

void sub_1007950C4(char *a1, int *a2, uint8_t *buf, os_log_t log)
{
  if (a1[23] >= 0) {
    uint64_t v5 = a1;
  }
  else {
    uint64_t v5 = *(char **)a1;
  }
  int v6 = *a2;
  *(_DWORD *)uint64_t buf = 136446466;
  *(void *)(buf + 4) = v5;
  *((_WORD *)buf + 6) = 1024;
  *(_DWORD *)(buf + 14) = v6;
  _os_log_debug_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_DEBUG, "ScanAgentType for %{public}s is %d", buf, 0x12u);
  if (a1[23] < 0) {
    operator delete(*(void **)a1);
  }
}

void sub_10079514C()
{
  v2[0] = 138543618;
  sub_10026C6AC();
  sub_1000574B8((void *)&_mh_execute_header, v0, v1, "ADVBUFF(%{public}@): Failed to configure buffer adv buffer: %d", (uint8_t *)v2);
}

void sub_1007951C4()
{
  sub_1006F7358();
  sub_1000574B8((void *)&_mh_execute_header, v0, (uint64_t)v0, "ADVBUFF(%{public}@): Failed to configure buffer adv buffer: %d", v1);
}

void sub_10079525C()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to enable and pause: %d", v2, v3, v4, v5, v6);
}

void sub_1007952C4()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "getNextMatchRuleAvailableHandle returned %d", v2, v3, v4, v5, v6);
}

void sub_10079532C()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "ClearDuplicateFilterCache failed due to scan not in progress", v2, v3, v4, v5, v6);
}

void sub_100795360()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "ClearDuplicateFilterCache failed due to invalid packeType", v2, v3, v4, v5, v6);
}

void sub_100795394()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "clearDuplicateFilterCache failed with result %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_1007953FC()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "removeDuplicateFilterEntry failed with result %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_100795464()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "removeMultipleLEEntriesFromDuplicateFilter failed with result %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_1007954CC()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "addEnhancedMatchingRule failed with result %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_100795534()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "removeEnhancedMatchingRule failed with result %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_10079559C()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "wipeMatchingRuleFilter failed with result %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_100795604()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "wipeMatchingRuleFilter failed with result %{bluetooth:OI_STATUS}u ", v2, v3, v4, v5, v6);
}

void sub_10079566C()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Scan started improperly with result %{bluetooth:OI_STATUS}u -- now what?", v2, v3, v4, v5, v6);
}

void sub_1007956D4(os_log_t log)
{
  int v1 = 136446210;
  uint64_t v2 = "fState == kStateStarting";
  _os_log_fault_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_FAULT, "Assertion failed: %{public}s", (uint8_t *)&v1, 0xCu);
}

void sub_100795758()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to stop scanning with result %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_1007957C0()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to start scanning with result %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_100795828()
{
  sub_1000573EC();
  if (v4 != v5) {
    uint64_t v6 = v3;
  }
  else {
    uint64_t v6 = v1;
  }
  sub_100057464(v2, v6, 4.8751e-34);
  sub_1006673D4((void *)&_mh_execute_header, v7, v8, "Agents: %{public}s", v9);
  if (*(char *)(v0 + 23) < 0) {
    operator delete(*(void **)v0);
  }
}

void sub_10079587C()
{
  sub_1000573EC();
  if (v4 != v5) {
    uint64_t v6 = v3;
  }
  else {
    uint64_t v6 = v1;
  }
  sub_100057464(v2, v6, 4.8751e-34);
  sub_1006673D4((void *)&_mh_execute_header, v7, v8, "%{public}s", v9);
  if (*(char *)(v0 + 23) < 0) {
    operator delete(*(void **)v0);
  }
}

void sub_1007958D0()
{
  sub_1000572E8();
  sub_10033D554((void *)&_mh_execute_header, v0, v1, "ScanCoreBLEConnectionScanStat: MainCore is used for LE Connection %d times", v2, v3, v4, v5, v6);
}

void sub_100795938()
{
  sub_1000572E8();
  sub_10033D554((void *)&_mh_execute_header, v0, v1, "ScanCoreBLEConnectionScanStat: ScanCore is used for LE Connection %d times", v2, v3, v4, v5, v6);
}

void sub_1007959A0()
{
  sub_1000572E8();
  sub_10033D554((void *)&_mh_execute_header, v0, v1, "Set GHSDeviceType: %d", v2, v3, v4, v5, v6);
}

void sub_100795A08()
{
  sub_1006F7370();
  _os_log_debug_impl(v0, v1, v2, v3, v4, 0x38u);
}

void sub_100795AE4()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to decrypt adv: %{public}u", v2, v3, v4, v5, v6);
}

void sub_100795B4C()
{
  sub_1002B7074();
  sub_100057550(v1, v2, v3, 4.8752e-34);
  sub_1000574B8((void *)&_mh_execute_header, v6, v4, "### Decrypt AccessoryStatus ADV failed: %{public}s, %{bluetooth:OI_STATUS}u", v5);
  if (*(char *)(v0 + 23) < 0) {
    operator delete(*(void **)v0);
  }
}

void sub_100795BA0()
{
  sub_1002B7074();
  sub_100057550(v1, v2, v3, 4.8752e-34);
  sub_1000574B8((void *)&_mh_execute_header, v6, v4, "### Decrypt FindMyAccessory ADV failed: %{public}s, %{bluetooth:OI_STATUS}u", v5);
  if (*(char *)(v0 + 23) < 0) {
    operator delete(*(void **)v0);
  }
}

void sub_100795BF4()
{
  sub_1000573EC();
  if (v4 != v5) {
    uint64_t v6 = v3;
  }
  else {
    uint64_t v6 = v1;
  }
  sub_100057464(v2, v6, 4.8751e-34);
  sub_1006673D4((void *)&_mh_execute_header, v7, v8, "Decrypt AccessoryStatus ADV failed: no key, %{public}s", v9);
  if (*(char *)(v0 + 23) < 0) {
    operator delete(*(void **)v0);
  }
}

void sub_100795C48()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Couldn't find IRK for subtype 8", v2, v3, v4, v5, v6);
}

void sub_100795C7C()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Scan stopped improperly with result %{bluetooth:OI_STATUS}u -- restart", v2, v3, v4, v5, v6);
}

void sub_100795CE4(uint64_t a1, NSObject *a2)
{
  v2[0] = 67109632;
  v2[1] = 18;
  __int16 v3 = 2048;
  uint64_t v4 = a1;
  __int16 v5 = 2048;
  uint64_t v6 = 29;
  _os_log_error_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_ERROR, "Error parsing puck %d, invalid size %zu, we can only fit %zu bytes", (uint8_t *)v2, 0x1Cu);
}

void sub_100795D78()
{
  sub_1000574EC();
  unint64_t v5 = *(void *)&v4 & (v3 >> 40);
  if (v5) {
    int v6 = 0;
  }
  else {
    int v6 = v1;
  }
  __int16 v10 = 1024;
  if (v5 == 64) {
    int v7 = v1;
  }
  else {
    int v7 = 0;
  }
  int v11 = v7;
  __int16 v12 = 1024;
  int v13 = v6;
  if (v5 == 192) {
    int v8 = v1;
  }
  else {
    int v8 = 0;
  }
  __int16 v14 = 1024;
  int v15 = v2;
  __int16 v16 = 1024;
  int v17 = v8;
  _os_log_error_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_ERROR, "leSensorStateChanged: No uuid found for a device with address type valid? %d, resolvable? %d, non-resolvable? %d, public? %d, static? %d", v9, 0x20u);
}

void sub_100795E68()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to send match buffer config command : %d", v2, v3, v4, v5, v6);
}

void sub_100795ED0(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_100795F44()
{
  sub_10052EAB8();
  sub_1006F7370();
  _os_log_debug_impl(v0, v1, v2, v3, v4, 0xEu);
}

void sub_100795FBC()
{
  sub_1000572E8();
  sub_10033D554((void *)&_mh_execute_header, v0, v1, "MATCH TABLE It has same type (%d)", v2, v3, v4, v5, v6);
}

void sub_100796024(uint8_t *buf, _DWORD *a2, os_log_t log)
{
  *(_DWORD *)uint64_t buf = 67109120;
  *a2 = 0;
  _os_log_debug_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_DEBUG, "MATCH TABLE first empty unused and uninitialized handle:%d", buf, 8u);
}

void sub_10079606C(unsigned char *a1, unsigned char *a2)
{
  sub_10026C69C(a1, a2);
  _os_log_debug_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEBUG, "MATCH TABLE It is not created", v3, 2u);
}

void sub_1007960A4(unsigned char *a1, unsigned char *a2)
{
  sub_10026C69C(a1, a2);
  _os_log_fault_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_FAULT, "A Used slot has to have a size and a type", v3, 2u);
}

void sub_1007960DC()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to destroy Proximity Pairing Match Table with result %d", v2, v3, v4, v5, v6);
}

void sub_100796144()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to create Proximity Pairing Match Table with result %d", v2, v3, v4, v5, v6);
}

void sub_1007961AC()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to destroy All types Match Table with result %d", v2, v3, v4, v5, v6);
}

void sub_100796214()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to create all types Match Table with result %d", v2, v3, v4, v5, v6);
}

void sub_10079627C()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to destroy People Discovery Match Table with result %d", v2, v3, v4, v5, v6);
}

void sub_1007962E4()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to create People Discovery Match Table with result %d", v2, v3, v4, v5, v6);
}

void sub_10079634C()
{
  sub_1000573EC();
  if (v4 != v5) {
    uint64_t v6 = v3;
  }
  else {
    uint64_t v6 = v1;
  }
  sub_100057464(v2, v6, 4.8751e-34);
  sub_100057438((void *)&_mh_execute_header, v7, (uint64_t)v7, "addScanFilterByUUIDWithBlobAndMask failed %{public}s", v8);
  if (*(char *)(v0 + 23) < 0) {
    operator delete(*(void **)v0);
  }
}

void sub_1007963A4()
{
  sub_1000573EC();
  if (v4 != v5) {
    uint64_t v6 = v3;
  }
  else {
    uint64_t v6 = v1;
  }
  sub_100057464(v2, v6, 4.8751e-34);
  sub_100057438((void *)&_mh_execute_header, v7, (uint64_t)v7, "addScanFilterByUUID failed %{public}s", v8);
  if (*(char *)(v0 + 23) < 0) {
    operator delete(*(void **)v0);
  }
}

void sub_1007963FC()
{
  sub_1000574EC();
  sub_10033D554((void *)&_mh_execute_header, v0, v1, "Setting duplicate filter bypass config to 0x%08x", v2, v3, v4, v5, v6);
}

void sub_100796468(unsigned char *a1, unsigned char *a2)
{
  sub_10026C69C(a1, a2);
  sub_1000573D0((void *)&_mh_execute_header, v2, v3, "Exceeded address matching list size. Matching all devices", v4);
}

void sub_100796494()
{
  sub_1004428C0();
  sub_1006F7370();
  _os_log_debug_impl(v0, v1, v2, v3, v4, 0x16u);
}

void sub_100796538()
{
  sub_1004428C0();
  sub_1006F7370();
  _os_log_debug_impl(v0, v1, v2, v3, v4, 0x20u);
}

void sub_1007965F0()
{
  sub_1000572E8();
  sub_10033D554((void *)&_mh_execute_header, v0, v1, "enableADVBuffering returned %d", v2, v3, v4, v5, v6);
}

void sub_100796658(os_log_t log)
{
  int v1 = 138543362;
  CFStringRef v2 = @"EN";
  _os_log_fault_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_FAULT, "Controller failed to read ADV buffers for %{public}@", (uint8_t *)&v1, 0xCu);
}

void sub_1007966DC(os_log_t log)
{
  v1[0] = 67109376;
  v1[1] = 0;
  __int16 v2 = 1024;
  int v3 = 1;
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "Unexpected combination of enabled cores: scanLPCoreEnable %d, isScanCoreEnabled %d", (uint8_t *)v1, 0xEu);
}

void sub_100796768(unsigned __int16 a1)
{
  sub_1006F7324((double)a1);
  _os_log_debug_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_DEBUG, "Override full duty cycle scan parameter %.2fms/%.2fms by %.2fms/%.2fms", v2, 0x2Au);
}

void sub_1007967E4(unsigned char *a1, unsigned char *a2)
{
  sub_10026C69C(a1, a2);
  _os_log_debug_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEBUG, "allowDups not used because it hasPuckFilter and hasNoServiceUUID", v3, 2u);
}

void sub_10079681C(unsigned char *a1, unsigned char *a2)
{
  sub_10026C69C(a1, a2);
  sub_1000573D0((void *)&_mh_execute_header, v2, v3, "Not supported config on mac", v4);
}

void sub_100796848(uint64_t a1, NSObject *a2)
{
  sub_1000417A8(a1, __p);
  if (v6 >= 0) {
    uint64_t v4 = __p;
  }
  else {
    uint64_t v4 = (void **)__p[0];
  }
  int v7 = 136446210;
  int v8 = v4;
  sub_100057438((void *)&_mh_execute_header, a2, v3, "addScanFilterByUUID failed %{public}s", (uint8_t *)&v7);
  if (v6 < 0) {
    operator delete(__p[0]);
  }
}

void sub_1007968F8()
{
  sub_1004428C0();
  sub_1003CF064((void *)&_mh_execute_header, v0, v1, "fAllUuids.size:%lu", v2, v3, v4, v5, v6);
}

void sub_100796964(unsigned char *a1, unsigned char *a2)
{
  sub_10026C69C(a1, a2);
  sub_1000573D0((void *)&_mh_execute_header, v2, v3, "Failed to add rule", v4);
}

void sub_100796990()
{
  sub_1004428C0();
  sub_1003CF064((void *)&_mh_execute_header, v0, v1, "fEnhancedMatchRules %@", v2, v3, v4, v5, v6);
}

void sub_1007969FC(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_100796A68()
{
  sub_1004428C0();
  sub_1003CF064((void *)&_mh_execute_header, v0, v1, "fZones %@", v2, v3, v4, v5, v6);
}

void sub_100796AD4()
{
  sub_1004428C0();
  sub_1003CF064((void *)&_mh_execute_header, v0, v1, "Dispatching controllerZoneAndFilterConfigComplete somethingChanged:%{public}s", v2, v3, v4, v5, v6);
}

void sub_100796B54()
{
  sub_1004428C0();
  sub_1003CF064((void *)&_mh_execute_header, v0, v1, "Executing controllerZoneAndFilterConfigComplete fControllerConfigInProgress:%{public}s", v2, v3, v4, v5, v6);
}

void sub_100796BDC()
{
  sub_1006FE628();
  _os_log_debug_impl(v0, v1, v2, v3, v4, 2u);
}

void sub_100796C1C(int a1, char *a2, uint8_t *buf, os_log_t log)
{
  if (a2[23] >= 0) {
    uint64_t v5 = a2;
  }
  else {
    uint64_t v5 = *(char **)a2;
  }
  *(_DWORD *)uint64_t buf = 136446210;
  *(void *)(buf + 4) = v5;
  _os_log_debug_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_DEBUG, "No match found for device \"%{public}s\"", buf, 0xCu);
  if (a2[23] < 0) {
    operator delete(*(void **)a2);
  }
}

void sub_100796C94(uint8_t *buf, unsigned char *a2, os_log_t log)
{
  *uint64_t buf = 0;
  *a2 = 0;
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "Invalid zone (nil or 0 length).", buf, 2u);
}

void sub_100796CD4()
{
  sub_1006FE618(__stack_chk_guard);
  sub_100579750();
  sub_1006FE628();
  _os_log_debug_impl(v0, v1, v2, v3, v4, 0x12u);
}

void sub_100796D50()
{
  sub_1006FE618(__stack_chk_guard);
  sub_100579750();
  sub_1006FE628();
  _os_log_debug_impl(v0, v1, v2, v3, v4, 0x18u);
}

void sub_100796DD8()
{
  sub_1006FE618(__stack_chk_guard);
  sub_1006FE628();
  _os_log_debug_impl(v0, v1, v2, v3, v4, 0xCu);
}

void sub_100796E54()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Ignoring serialized OOB data of invalid length %u", v2, v3, v4, v5, v6);
}

void sub_100796EBC()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "still getting errSecUpgradePending when reading non connectable address", v2, v3, v4, v5, v6);
}

void sub_100796EF0()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "still getting errSecUpgradePending when calling readRootKeys", v2, v3, v4, v5, v6);
}

void sub_100796F24()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Could not generated Non Connectable IRK : %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_100796F8C()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Failed to set new identity non connectable root!", v2, v3, v4, v5, v6);
}

void sub_100796FC0()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Failed to set new non connectable static random address", v2, v3, v4, v5, v6);
}

void sub_100796FF4()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "TTD: Could not generated Non Connectable IRK : %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_10079705C()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "TTD: Could not generated DHK : %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_1007970C4()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "TTD: Could not generated IRK : %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_10079712C()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "still getting errSecUpgradePending when calling cloudNonce", v2, v3, v4, v5, v6);
}

void sub_100797160()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Generated new root keys while paired to other devices, please file a radar to Bluetooth (new bugs) | iOS", v2, v3, v4, v5, v6);
}

void sub_100797194()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "still getting errSecUpgradePending when reading local static address", v2, v3, v4, v5, v6);
}

void sub_1007971C8()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Failed to set new local static random address", v2, v3, v4, v5, v6);
}

void sub_1007971FC()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Generating new local static random", v2, v3, v4, v5, v6);
}

void sub_100797230()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Could not generated DHK : %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_100797298()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Could not generated IRK : %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_100797300()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Failed to set new Cloud Nonce", v2, v3, v4, v5, v6);
}

void sub_100797334()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Generating new Cloud Nonce", v2, v3, v4, v5, v6);
}

void sub_100797368()
{
  sub_1000572DC();
  sub_10030D118((void *)&_mh_execute_header, v0, v1, "Failed to set Cloud Private!", v2, v3, v4, v5, v6);
}

void sub_10079739C()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Generating new Cloud Private and Cloud Public key", v2, v3, v4, v5, v6);
}

void sub_1007973D0()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "still getting errSecUpgradePending when calling read cloudPublicKey", v2, v3, v4, v5, v6);
}

void sub_100797404()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Failed to set new encryption root!", v2, v3, v4, v5, v6);
}

void sub_100797438()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Generating new encryption root", v2, v3, v4, v5, v6);
}

void sub_10079746C()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Failed to set new identity root!", v2, v3, v4, v5, v6);
}

void sub_1007974A0()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Generating new identity root", v2, v3, v4, v5, v6);
}

void sub_1007974D4()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "readTEKsFromKeychain empty kContactTracingTEKBuffer, will generate a new TEK when advertising starts", v2, v3, v4, v5, v6);
}

void sub_100797508()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "readTEKsFromKeychain kContactTracingTEKBuffer invalid size, will generate a new TEK when advertising starts", v2, v3, v4, v5, v6);
}

void sub_10079753C()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Diagnostics mode is ON, skipping keychain", v2, v3, v4, v5, v6);
}

void sub_100797570()
{
  sub_1006ACCF4();
  *uint64_t v1 = 138543362;
  *uint64_t v3 = v2;
  sub_1002C5578((void *)&_mh_execute_header, v5, (uint64_t)v3, "Failed to retrieve UUID for paired address %{public}@", v4);
}

void sub_1007975C0()
{
  sub_1006ACCF4();
  *uint64_t v1 = 138543362;
  *uint64_t v3 = v2;
  sub_100057438((void *)&_mh_execute_header, v5, (uint64_t)v3, "Removing incomplete pairing info for device %{public}@", v4);
}

void sub_100797610()
{
  sub_1000573EC();
  if (v6 != v7) {
    uint64_t v8 = v5;
  }
  else {
    uint64_t v8 = v1;
  }
  *(_DWORD *)uint64_t v2 = 136446210;
  *(void *)(v2 + 4) = v8;
  sub_100057438((void *)&_mh_execute_header, v3, (uint64_t)v3, "Found missing/bad keys for device %{public}s, dropping pairing info", v4);
  if (*(char *)(v0 + 23) < 0) {
    operator delete(*(void **)v0);
  }
}

void sub_10079766C()
{
  sub_1006ACCF4();
  sub_100359178(v1, v2, 5.8381e-34);
  sub_1002C5578((void *)&_mh_execute_header, v3, (uint64_t)v3, "Failed to retrieve UUID for paired address %{public}@", v4);
}

void sub_1007976B4()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Peer device using a debug LTK, removing.", v2, v3, v4, v5, v6);
}

void sub_1007976E8()
{
  sub_100313A24();
  sub_100057518((void *)&_mh_execute_header, v0, v1, "Error for adding IRK before device: %{public}@ with BTResult: %d");
}

void sub_100797750()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed registration for MKB first unlock notification with error : %u", v2, v3, v4, v5, v6);
}

void sub_1007977B8()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to set ourselves bondable with result %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_100797820()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to register state change callbacks with result %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_100797888()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to register pairing callbacks with result %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_1007978F0()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to register security callbacks with result %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_100797958()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to set root keys with result %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_1007979C0(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_100797A34()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "We don't have any root keys, so we can't pair.", v2, v3, v4, v5, v6);
}

void sub_100797A68()
{
  sub_100313A24();
  sub_100057518((void *)&_mh_execute_header, v0, v1, "Failed to pair device \"%{public}@\" with result %{bluetooth:OI_STATUS}u");
}

void sub_100797AD0()
{
  sub_10005732C();
  sub_100057438((void *)&_mh_execute_header, v0, v1, "Device \"%{public}@\" isn't connected!", v2);
}

void sub_100797B3C()
{
  sub_10005732C();
  sub_100057438((void *)&_mh_execute_header, v0, v1, "Failed to set CTKD for device %{public}@ as it is unknown", v2);
}

void sub_100797BA8()
{
  sub_100313A24();
  sub_100057518((void *)&_mh_execute_header, v0, v1, "Failed to accept pairing for device \"%{public}@\" with result %{bluetooth:OI_STATUS}u - cancelling...");
}

void sub_100797C10()
{
  sub_100313A24();
  sub_100057518((void *)&_mh_execute_header, v0, v1, "Failed to cancel pairing to device \"%{public}@\" with result %{bluetooth:OI_STATUS}u");
}

void sub_100797C78()
{
  sub_100313A24();
  sub_100057518((void *)&_mh_execute_header, v0, v1, "Failed to generate OOB data for device \"%{public}@\" with result %{bluetooth:OI_STATUS}u");
}

void sub_100797CE0()
{
  sub_10005732C();
  sub_100057438((void *)&_mh_execute_header, v0, v1, "Failed to enable OOB pairing for device \"%{public}@\"", v2);
}

void sub_100797D4C()
{
  sub_100313A24();
  sub_100057518((void *)&_mh_execute_header, v0, v1, "Failed to disable OOB pairing for device \"%{public}@\" with status %d");
}

void sub_100797DB4(NSObject *a1, uint64_t a2, uint64_t a3)
{
  int v3 = 136446210;
  uint64_t v4 = "fInProgressKeys.find(device) == fInProgressKeys.end()";
  sub_1002C5578((void *)&_mh_execute_header, a1, a3, "Assertion failed: %{public}s", (uint8_t *)&v3);
}

void sub_100797E30()
{
  sub_1000572DC();
  sub_10030D118((void *)&_mh_execute_header, v0, v1, "We received BT_ERROR_PAIRING_ALREADY_PAIRED but could not find an original. Thats strange.", v2, v3, v4, v5, v6);
}

void sub_100797E64()
{
  sub_1006ACCF4();
  if (*((char *)v1 + 23) >= 0) {
    uint8_t v6 = v1;
  }
  else {
    uint8_t v6 = (uint64_t *)*v1;
  }
  *(_DWORD *)uint64_t v2 = 136446466;
  *(void *)(v2 + 4) = v6;
  *(_WORD *)(v2 + 12) = 1024;
  *(_DWORD *)(v2 + 14) = v3;
  _os_log_error_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "Pairing failed to device \"%{public}s\" with error %{bluetooth:OI_STATUS}u", v4, 0x12u);
  if (*(char *)(v0 + 23) < 0) {
    operator delete(*(void **)v0);
  }
}

void sub_100797EE4(void *a1, uint64_t a2, NSObject *a3)
{
  id v5 = a1;
  *(_DWORD *)a2 = 138543362;
  *(void *)(a2 + 4) = v5;
  _os_log_fault_impl((void *)&_mh_execute_header, a3, OS_LOG_TYPE_FAULT, "Received remote address but have no IRK for device \"%{public}@\"", (uint8_t *)a2, 0xCu);
}

void sub_100797F54(void *a1, void *a2, uint64_t a3, NSObject *a4)
{
  id v7 = a2;
  *(_DWORD *)a3 = 138543618;
  *(void *)(a3 + 4) = a1;
  *(_WORD *)(a3 + 12) = 2114;
  *(void *)(a3 + 14) = v7;
  _os_log_fault_impl((void *)&_mh_execute_header, a4, OS_LOG_TYPE_FAULT, "Resolved address we got on pairing completion (%{public}@) doesn't match the one that was distributed (%{public}@)!", (uint8_t *)a3, 0x16u);
}

void sub_100797FDC()
{
  sub_1000572DC();
  sub_10030D118((void *)&_mh_execute_header, v0, v1, "Attempting to remove cloud paired device without iCloud identifier!", v2, v3, v4, v5, v6);
}

void sub_100798010(char *a1, void *a2, NSObject *a3)
{
  if (*a1 < 0) {
    a2 = (void *)*a2;
  }
  int v3 = 136315138;
  uint64_t v4 = a2;
  sub_100057438((void *)&_mh_execute_header, a3, (uint64_t)a3, "Unable to find locally paired device with iCloud identifier \"%s\"", (uint8_t *)&v3);
}

void sub_100798090()
{
  sub_1006ACCF4();
  sub_100359178(v1, v2, 5.8381e-34);
  sub_100057438((void *)&_mh_execute_header, v3, (uint64_t)v3, "Found multiple paired devices referencing address \"%{public}@\" - leaving key(s)", v4);
}

void sub_1007980D8(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_100798148()
{
  sub_10005732C();
  sub_100057438((void *)&_mh_execute_header, v0, v1, "FindMy device %@ does not have a valid LTK for its current address", v2);
}

void sub_1007981B4(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_100798228()
{
  sub_1006ACCF4();
  sub_100359178(v1, v2, 5.8381e-34);
  sub_100057438((void *)&_mh_execute_header, v3, (uint64_t)v3, "Device %{public}@ is already LE Paired, cannot add temporary keys", v4);
}

void sub_100798270()
{
  sub_1006ACCF4();
  sub_100359178(v1, v2, 5.8381e-34);
  sub_100057438((void *)&_mh_execute_header, v3, (uint64_t)v3, "LE Pairing in progress for device %{public}@", v4);
}

void sub_1007982B8()
{
  sub_1006ACCF4();
  sub_100359178(v1, v2, 5.8381e-34);
  sub_1002C5578((void *)&_mh_execute_header, v3, (uint64_t)v3, "Device \"%{public}@\" wasn't being tracked by device manager!", v4);
}

void sub_100798300()
{
  sub_1006ACCF4();
  sub_100359178(v1, v2, 5.8381e-34);
  sub_1002C5578((void *)&_mh_execute_header, v3, (uint64_t)v3, "Device \"%{public}@\" wasn't being tracked by LE Connection Manager!", v4);
}

void sub_100798348()
{
  sub_1006ACCF4();
  sub_100359178(v1, v2, 5.8381e-34);
  sub_1002C5578((void *)&_mh_execute_header, v3, (uint64_t)v3, "Device \"%{public}@\" requested security but wasn't being tracked by device manager!", v4);
}

void sub_100798390()
{
  sub_1000573EC();
  if (v6 != v7) {
    uint64_t v8 = v5;
  }
  else {
    uint64_t v8 = v1;
  }
  *(_DWORD *)uint64_t v2 = 136446210;
  *(void *)(v2 + 4) = v8;
  sub_100057438((void *)&_mh_execute_header, v3, (uint64_t)v3, "Denying pairing request from device \"%{public}s\" as there's no one to handle the request", v4);
  if (*(char *)(v0 + 23) < 0) {
    operator delete(*(void **)v0);
  }
}

void sub_1007983EC()
{
  sub_1006ACCF4();
  sub_100359178(v1, v2, 5.8382e-34);
  *(_WORD *)(v3 + 12) = 1024;
  *(_DWORD *)(v3 + 14) = v4;
  _os_log_error_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, "Failed to cancel pairing to device \"%{public}@\" with result %{bluetooth:OI_STATUS}u", v5, 0x12u);
}

void sub_10079844C(const unsigned __int8 *a1, NSObject *a2)
{
  sub_100401EBC(a1, __p);
  if (v6 >= 0) {
    int v4 = __p;
  }
  else {
    int v4 = (void **)__p[0];
  }
  int v7 = 136446210;
  uint64_t v8 = v4;
  sub_100057438((void *)&_mh_execute_header, a2, v3, "Couldn't find pairing agent to handle request for device \"%{public}s\" - cancelling pairing", (uint8_t *)&v7);
  if (v6 < 0) {
    operator delete(__p[0]);
  }
}

void sub_1007984FC(uint64_t a1, NSObject *a2)
{
  uint64_t v3 = sub_1006AD3F0();
  sub_10005732C();
  sub_1002C5578((void *)&_mh_execute_header, a2, v4, "Device \"%{public}@\" requested pairing but wasn't being tracked by device manager!", v5);
}

void sub_10079858C()
{
  sub_10005732C();
  sub_100057438((void *)&_mh_execute_header, v0, v1, "ALERT_LOCALIZED_MESSAGE_KEY validation failed: %@", v2);
}

void sub_1007985F8()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "User responded with unknown response.", v2, v3, v4, v5, v6);
}

void sub_10079862C()
{
  sub_10005732C();
  sub_100057438((void *)&_mh_execute_header, v0, v1, "Device %{public}@ is already paired and bonded, cannot create a new pairing record", v2);
}

void sub_100798698()
{
  sub_10005732C();
  sub_100057438((void *)&_mh_execute_header, v0, v1, "Device %{public}@ is already in pairing process, cannot create a new pairing record", v2);
}

void sub_100798704()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to set tek buffer length, res = %d", v2, v3, v4, v5, v6);
}

void sub_10079876C()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to set tek buffer, res = %d", v2, v3, v4, v5, v6);
}

void sub_1007987D4(uint64_t a1, NSObject *a2)
{
  uint64_t v2 = *(void *)(a1 + 24);
  int v3 = 138412290;
  uint64_t v4 = v2;
  _os_log_debug_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_DEBUG, "storeTEKsInKeychain fTEKArray:%@", (uint8_t *)&v3, 0xCu);
}

void sub_100798850(uint64_t *a1, NSObject *a2)
{
  uint64_t v2 = *a1;
  int v3 = 138412290;
  uint64_t v4 = v2;
  _os_log_debug_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_DEBUG, "invalidateCurrentKey new fTEKArray:%@", (uint8_t *)&v3, 0xCu);
}

void sub_1007988CC(uint64_t a1, NSObject *a2)
{
  v2[0] = 68157954;
  v2[1] = 21;
  __int16 v3 = 2096;
  uint64_t v4 = a1;
  _os_log_debug_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_DEBUG, "invalidateCurrentTEK new TEK:%.21P", (uint8_t *)v2, 0x12u);
}

void sub_100798954()
{
  sub_1000572E8();
  _os_log_debug_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_DEBUG, "invalidateCurrentTEK previous TEK rolling period delta:%d", v1, 8u);
}

void sub_1007989C8()
{
  sub_1000572DC();
  _os_log_debug_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_DEBUG, "invalidateCurrentTEK current key already invalid, or missing", v1, 2u);
}

void sub_100798A08()
{
  sub_1002B70BC();
  sub_10071B754((void *)&_mh_execute_header, v0, v1, "maintainTEKList currentInterval:%d oldestInterval:%d", v2, v3);
}

void sub_100798A70(uint64_t a1, uint64_t a2, NSObject *a3)
{
  LOWORD(v3) = 1024;
  *(_DWORD *)((char *)&v3 + 2) = *(_DWORD *)(a2 + 32);
  sub_10071B754((void *)&_mh_execute_header, a2, a3, "isCurrentTEKValid lastActivePeriod:%d fEKRollingPeriod:%d", 67109376, v3);
}

void sub_100798AF0()
{
  sub_1000572E8();
  _os_log_debug_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_DEBUG, "debugFillTEKHistory pastDays:%d", v1, 8u);
}

void sub_100798B64()
{
  sub_10005732C();
  __int16 v3 = 2112;
  uint64_t v4 = v0;
  _os_log_debug_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_DEBUG, "addTEK tek:%@ fTEKArray:%@", v2, 0x16u);
}

void sub_100798BEC()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Cannot load payload payloadBytesLength=%d", v2, v3, v4, v5, v6);
}

void sub_100798C54()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Cannot store payload payloadBytesLength=%d", v2, v3, v4, v5, v6);
}

void sub_100798CBC()
{
  sub_1002B70BC();
  _os_log_fault_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_FAULT, "Known keys are up to 16 bytes for now. %d is too large for type %d.", v1, 0xEu);
}

void sub_100798D34()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "PowerLogger not available", v2, v3, v4, v5, v6);
}

void sub_100798D68(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 32);
  if (v2)
  {
    *(void *)(a1 + 40) = v2;
    operator delete(v2);
  }
}

void sub_100798D80(void *a1, uint8_t *buf, os_log_t log)
{
  *(_DWORD *)uint64_t buf = 138412290;
  *(void *)(buf + 4) = a1;
  _os_log_fault_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_FAULT, "Unable to extract country code plist. %@", buf, 0xCu);
}

void sub_100798DD8(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_100798E10(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_100798E48(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_100798E80()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to register WiAP Sink v2 SDP service record - result was %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_100798EE8()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to register SDP service record - result was %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_100798F50()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to register RFCOMM server - result was %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_100798FB8()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Cannot connect to NULL device", v2, v3, v4, v5, v6);
}

void sub_100798FEC()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "No rfcomm channel found for this profile", v2, v3, v4, v5, v6);
}

void sub_100799020()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Wireless IAP connection failed - result was %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_100799088()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Error retrieving device from handle", v2, v3, v4, v5, v6);
}

void sub_1007990BC(uint64_t a1, NSObject *a2)
{
  sub_100474E18(a1, __p);
  if (v5 >= 0) {
    uint64_t v3 = __p;
  }
  else {
    uint64_t v3 = (void **)__p[0];
  }
  *(_DWORD *)uint64_t buf = 136446210;
  int v7 = v3;
  _os_log_error_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_ERROR, "Failed to open serial port for device %{public}s", buf, 0xCu);
  if (v5 < 0) {
    operator delete(__p[0]);
  }
}

void sub_100799174()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Cannot write data to NULL device", v2, v3, v4, v5, v6);
}

void sub_1007991A8()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Cannot read from NULL device", v2, v3, v4, v5, v6);
}

void sub_1007991DC()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to send data to BT device - result was %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_100799244()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Invalid write - result was %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
}

void sub_1007992AC()
{
  sub_10005732C();
  sub_1000574F8((void *)&_mh_execute_header, v0, v1, "bundleId \"%@\"is not in the applicationMap. Could not set isAlive: %s");
}

void sub_100799338(uint64_t a1, uint64_t a2)
{
  sub_100359178(a1, a2, 4.8751e-34);
  sub_100057438((void *)&_mh_execute_header, v2, (uint64_t)v2, "Application \"%{public}s\" wasn't registered!", v3);
}

void sub_100799374()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Cancelling Launch Attempt, Retry Limit Reached", v2, v3, v4, v5, v6);
}

void sub_1007993A8(uint64_t *a1, NSObject *a2, uint64_t a3)
{
  uint64_t v3 = *a1;
  int v4 = 138412290;
  uint64_t v5 = v3;
  sub_100057438((void *)&_mh_execute_header, a2, a3, "bundleId \"%@\"is not in the applicationMap. Could not complete application launch path", (uint8_t *)&v4);
}

void sub_10079941C(uint64_t a1, NSObject *a2, uint64_t a3)
{
  uint64_t v3 = *(void *)(a1 + 32);
  int v4 = 138543362;
  uint64_t v5 = v3;
  sub_100057438((void *)&_mh_execute_header, a2, a3, "Failed to lookup the process ID of %{public}@", (uint8_t *)&v4);
}

void sub_100799490(uint64_t a1, uint64_t a2, NSObject *a3)
{
  *(_DWORD *)uint64_t v3 = 138543618;
  *(void *)&v3[4] = *(void *)(a1 + 32);
  *(_WORD *)&uint8_t v3[12] = 2114;
  *(void *)&uint8_t v3[14] = a2;
  sub_1000574F8((void *)&_mh_execute_header, a2, a3, "Failed To Launch Application %{public}@ Error %{public}@", *(void *)v3, *(void *)&v3[8], *(void *)&v3[16]);
}

void sub_10079950C(uint64_t a1, uint64_t a2)
{
  sub_100359178(a1, a2, 4.8751e-34);
  sub_100057438((void *)&_mh_execute_header, v2, (uint64_t)v2, "No pid for bundle \"%{public}s\"", v3);
}

void sub_100799548(uint64_t a1, uint64_t a2)
{
  sub_100359178(a1, a2, 4.8751e-34);
  sub_100057438((void *)&_mh_execute_header, v2, (uint64_t)v2, "Attempting to take process assertion for untracked process \"%{public}s\"", v3);
}

void sub_100799584(uint64_t a1, uint64_t a2)
{
  sub_100359178(a1, a2, 4.8751e-34);
  sub_100057438((void *)&_mh_execute_header, v2, (uint64_t)v2, "Unable to acquire process assertion for application \"%{public}s\"", v3);
}

void sub_1007995C0()
{
  sub_10005732C();
  sub_100057438((void *)&_mh_execute_header, v0, v1, "Failed to validate format for LE_POWER_OFF_HEADER: %@", v2);
}

void sub_10079962C(uint64_t a1, uint64_t a2)
{
  sub_100359178(a1, a2, 4.8751e-34);
  sub_100057438((void *)&_mh_execute_header, v2, (uint64_t)v2, "Failed to create power notification for application \"%{public}s\"", v3);
}

void sub_100799668(uint64_t a1, uint64_t a2)
{
  sub_100359178(a1, a2, 4.8751e-34);
  sub_100057438((void *)&_mh_execute_header, v2, (uint64_t)v2, "Failed to create power notification run loop for application \"%{public}s\"", v3);
}

void sub_1007996A4()
{
  sub_10005732C();
  sub_100057438((void *)&_mh_execute_header, v0, v1, "Failed to validate format for LE_DENYLIST_ENABLED_HEADER: %@", v2);
}

void sub_100799710()
{
  sub_10005732C();
  sub_100057438((void *)&_mh_execute_header, v0, v1, "Failed to validate UserNotificationTypeDeviceDisconnection format string: %@", v2);
}

void sub_10079977C(uint64_t a1, uint64_t a2)
{
  sub_100359178(a1, a2, 4.8751e-34);
  sub_100057438((void *)&_mh_execute_header, v2, (uint64_t)v2, "Failed to create app notification for application \"%{public}s\"", v3);
}

void sub_1007997B8(uint64_t a1, uint64_t a2)
{
  sub_100359178(a1, a2, 4.8751e-34);
  sub_100057438((void *)&_mh_execute_header, v2, (uint64_t)v2, "Failed to create app notification run loop for application \"%{public}s\"", v3);
}

void sub_1007997F4()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Received app launch notification callback for unknown notification - ignoring...", v2, v3, v4, v5, v6);
}

void sub_100799828()
{
  sub_1000572DC();
  _os_log_fault_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_FAULT, "Unsupported pairing type for pairing notification", v1, 2u);
}

void sub_100799868(void *a1, uint64_t a2)
{
  sub_100359178((uint64_t)a1, a2, 5.7779e-34);
  sub_100057438((void *)&_mh_execute_header, v3, (uint64_t)v3, "Failed to create pairing notification for device \"%@\"", v4);
}

void sub_1007998B4(void *a1, uint64_t a2)
{
  sub_100359178((uint64_t)a1, a2, 5.7779e-34);
  sub_100057438((void *)&_mh_execute_header, v3, (uint64_t)v3, "Failed to create run loop source for device \"%@\"", v4);
}

void sub_100799900()
{
  sub_10005732C();
  sub_100057438((void *)&_mh_execute_header, v0, v1, "Failed to validate JUST_WORKS_MESSAGE format string: %@", v2);
}

void sub_10079996C()
{
  sub_10005732C();
  sub_100057438((void *)&_mh_execute_header, v0, v1, "Failed to validate JUST_WORKS_MESSAGE_HID_OLD format string: %@", v2);
}

void sub_1007999D8()
{
  sub_10005732C();
  sub_100057438((void *)&_mh_execute_header, v0, v1, "Failed to validate PASSKEY_DISPLAY_MESSAGE format string: %@", v2);
}

void sub_100799A44()
{
  sub_10005732C();
  sub_100057438((void *)&_mh_execute_header, v0, v1, "Failed to validate PASSKEY_ENTRY_MESSAGE format string: %@", v2);
}

void sub_100799AB0()
{
  sub_10005732C();
  sub_100057438((void *)&_mh_execute_header, v0, v1, "Failed to validate NUMERIC_MESSAGE format string: %@", v2);
}

void sub_100799B1C()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Received pairing notification callback for unknown notification - ignoring...", v2, v3, v4, v5, v6);
}

void sub_100799B50()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "displayAirWaveLaunchNotification: Ignoring. An alert was shown less than 24 hours ago.", v2, v3, v4, v5, v6);
}

void sub_100799B84()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "displayAirWaveLaunchNotification: Invalid productID: %u", v2, v3, v4, v5, v6);
}

void sub_100799BEC()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "showFoundAccessoryCrashAlert: Invalid productID: %d", v2, v3, v4, v5, v6);
}

void sub_100799C54()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "showFoundAccessoryCrashAlert: No response", v2, v3, v4, v5, v6);
}

void sub_100799C88()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "showFoundAccessoryLogAlert: called with no filenames", v2, v3, v4, v5, v6);
}

void sub_100799CBC()
{
  sub_10005732C();
  sub_100057438((void *)&_mh_execute_header, v0, v1, "showFoundAccessoryLogAlert: Invalid Product ID: %lu", v2);
}

void sub_100799D28()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "showFileRadarNotification: Unhandled reason %d", v2, v3, v4, v5, v6);
}

void sub_100799D90()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "openTapToRadarWithAccessoryLogs: Unhandled reason %d", v2, v3, v4, v5, v6);
}

void sub_100799DF8()
{
  sub_10005732C();
  sub_100057438((void *)&_mh_execute_header, v0, v1, "openTapToRadarWithAccessoryLogs: Failed to launch TTR with error %@", v2);
}

void sub_100799E64(char *a1, uint8_t *buf, os_log_t log)
{
  if (a1[23] >= 0) {
    uint64_t v4 = a1;
  }
  else {
    uint64_t v4 = *(char **)a1;
  }
  *(_DWORD *)uint64_t buf = 136446210;
  *(void *)(buf + 4) = v4;
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "Unable to create device from address \"%{public}s\"", buf, 0xCu);
  if (a1[23] < 0) {
    operator delete(*(void **)a1);
  }
}

void sub_100799ED8()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Received invalid device address on DisconnectClassicDevice", v2, v3, v4, v5, v6);
}

void sub_100799F0C()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Received invalid device address on ClassicPairStateRequest", v2, v3, v4, v5, v6);
}

void sub_100799F40()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Received invalid device address on ClassicPairStateResponse", v2, v3, v4, v5, v6);
}

void sub_100799F74()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Received invalid link key on StoreClassicLinkKeyRequest", v2, v3, v4, v5, v6);
}

void sub_100799FA8()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Device is not valid or already un-paired", v2, v3, v4, v5, v6);
}

void sub_100799FDC()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Received StoreClassicLinkKeyRequest, remove magic pairing", v2, v3, v4, v5, v6);
}

void sub_10079A010()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Received StoreClassicLinkKeyRequest to trigger unpairing", v2, v3, v4, v5, v6);
}

void sub_10079A044()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Received invalid device address on StoreClassicLinkKeyRequest", v2, v3, v4, v5, v6);
}

void sub_10079A078()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Received invalid device address on StoreClassicLinkKeyResponse", v2, v3, v4, v5, v6);
}

void sub_10079A0AC(char *a1, void *a2, os_log_t log)
{
  if (*a1 >= 0) {
    uint64_t v3 = a2;
  }
  else {
    uint64_t v3 = (void *)*a2;
  }
  int v4 = 141558275;
  uint64_t v5 = 1752392040;
  __int16 v6 = 2081;
  int v7 = v3;
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "Received StoreClassicDeviceSettings for device %{private, mask.hash}s that is not paired", (uint8_t *)&v4, 0x16u);
}

void sub_10079A14C()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Received invalid device address on StoreClassicDeviceSettings", v2, v3, v4, v5, v6);
}

void sub_10079A180()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Device not valid or not paired", v2, v3, v4, v5, v6);
}

void sub_10079A1B4()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Received invalid device address on ClassicDeviceUnexpectedDisconnection", v2, v3, v4, v5, v6);
}

void sub_10079A1E8()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "ConnectClassicDevice: No magnet link UUID", v2, v3, v4, v5, v6);
}

void sub_10079A21C()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Received invalid device address on ConnectClassicDevice", v2, v3, v4, v5, v6);
}

void sub_10079A250()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Received invalid device address on LeaEasyPairRequest", v2, v3, v4, v5, v6);
}

void sub_10079A284()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Received invalid rand on LeaStoreBondingInfoRequest", v2, v3, v4, v5, v6);
}

void sub_10079A2B8()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Received invalid LTK on LeaStoreBondingInfoRequest", v2, v3, v4, v5, v6);
}

void sub_10079A2EC()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Received invalid IRK on LeaStoreBondingInfoRequest", v2, v3, v4, v5, v6);
}

void sub_10079A320()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "UARPDataOverAACP - device doesn't exist!", v2, v3, v4, v5, v6);
}

void sub_10079A354()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "UARPDataOverAACP - Received invalid data from BTLEServer", v2, v3, v4, v5, v6);
}

void sub_10079A388()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "UARPDataOverAACP - Error allocating memory for uarpData", v2, v3, v4, v5, v6);
}

void sub_10079A3BC()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "UARPDataOverAACP - AACPClient::sendUARPData failed", v2, v3, v4, v5, v6);
}

void sub_10079A3F0(os_log_t log)
{
  *(_WORD *)uint64_t v1 = 0;
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "Session is empty in getConnectionUseCase.", v1, 2u);
}

void sub_10079A434()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "WirelessCoexManager not available, not creating service", v2, v3, v4, v5, v6);
}

void sub_10079A468(void *a1, NSObject *a2)
{
  xpc_dictionary_get_string(a1, _xpc_error_key_description);
  sub_10005732C();
  sub_100057438((void *)&_mh_execute_header, a2, v3, "PurpleCoexManager XPC connection error: %{public}s", v4);
}

void sub_10079A4F4()
{
  sub_10005732C();
  sub_100057438((void *)&_mh_execute_header, v0, v1, "PurpleCoexManager Unexpected XPC connection event: %{public}s", v2);
}

void sub_10079A560()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "WirelessCoexManager not available, not checking in", v2, v3, v4, v5, v6);
}

void sub_10079A594()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "WirelessCoexManager not available", v2, v3, v4, v5, v6);
}

void sub_10079A5C8()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "UpdateWifiState arguments missing", v2, v3, v4, v5, v6);
}

void sub_10079A5FC()
{
  sub_1000572DC();
  sub_1002E4C44((void *)&_mh_execute_header, v0, v1, "UCMBTConnectionScanDutyCycle default", v2, v3, v4, v5, v6);
}

void sub_10079A630()
{
  sub_1000572DC();
  sub_1002E4C44((void *)&_mh_execute_header, v0, v1, "UCMBTConnectionScanDutyCycle kWCMWiFiStateDesiredBtDc_30_40_", v2, v3, v4, v5, v6);
}

void sub_10079A664()
{
  sub_1000572DC();
  sub_1002E4C44((void *)&_mh_execute_header, v0, v1, "UCMBTConnectionScanDutyCycle kWCMWiFiStateDesiredBtDc_30_60_", v2, v3, v4, v5, v6);
}

void sub_10079A698()
{
  sub_1000572DC();
  sub_1002E4C44((void *)&_mh_execute_header, v0, v1, "UCMBTConnectionScanDutyCycle kWCMWiFiStateDesiredBtDc_30_90_", v2, v3, v4, v5, v6);
}

void sub_10079A6CC()
{
  sub_1000572DC();
  sub_1002E4C44((void *)&_mh_execute_header, v0, v1, "UCMBTConnectionScanDutyCycle kWCMWiFiStateDesiredBtDc_30_300_", v2, v3, v4, v5, v6);
}

void sub_10079A700()
{
  sub_1000572DC();
  sub_1002E4C44((void *)&_mh_execute_header, v0, v1, "UCMBTConnectionScanDutyCycle kWCMWiFiStateDesiredBtDc_30_30_", v2, v3, v4, v5, v6);
}

void sub_10079A734()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Failed to set LE AFH map.", v2, v3, v4, v5, v6);
}

void sub_10079A768()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "No arguments passed to set diversity host assisted AFH maps", v2, v3, v4, v5, v6);
}

void sub_10079A79C()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Invalid diversity channel maps", v2, v3, v4, v5, v6);
}

void sub_10079A7D0()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Invalid size of the period type array", v2, v3, v4, v5, v6);
}

void sub_10079A804(unsigned __int8 a1, xpc_object_t xarray, NSObject *a3)
{
  v4[0] = 67109376;
  v4[1] = a1;
  __int16 v5 = 2048;
  size_t count = xpc_array_get_count(xarray);
  _os_log_error_impl((void *)&_mh_execute_header, a3, OS_LOG_TYPE_ERROR, "Invalid size of the period duration array(numPeriods: %d, period count %zu)", (uint8_t *)v4, 0x12u);
}

void sub_10079A8A4()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Invalid parameters", v2, v3, v4, v5, v6);
}

void sub_10079A8D8(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_10079A948()
{
  sub_10005732C();
  sub_100057438((void *)&_mh_execute_header, v0, v1, "No classic device for %@", v2);
}

void sub_10079A9B4()
{
  sub_10005732C();
  sub_100057438((void *)&_mh_execute_header, v0, v1, "Failed to parse LTE Link Quality mode addr %@", v2);
}

void sub_10079AA20()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "No arguments passed to antenna preference", v2, v3, v4, v5, v6);
}

void sub_10079AA54()
{
  sub_10005732C();
  sub_100057438((void *)&_mh_execute_header, v0, v1, "Invalid antenna action %llu", v2);
}

void sub_10079AAC0(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_10079AB30()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Number of Scan Frequencies don't match scan freq array sent", v2, v3, v4, v5, v6);
}

void sub_10079AB64()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "SetCoexRxMode arguments missing", v2, v3, v4, v5, v6);
}

void sub_10079AB98()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "SetAWDLActive arguments missing", v2, v3, v4, v5, v6);
}

void sub_10079ABCC()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "SetLowWiFiRate arguments missing", v2, v3, v4, v5, v6);
}

void sub_10079AC00()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "SetAWDLRTGActive arguments missing", v2, v3, v4, v5, v6);
}

void sub_10079AC34()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "SetUWB5GHzActive arguments missing", v2, v3, v4, v5, v6);
}

void sub_10079AC68()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "SetNANActive arguments missing", v2, v3, v4, v5, v6);
}

void sub_10079AC9C()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Set5GHzHostAPActive arguments missing", v2, v3, v4, v5, v6);
}

void sub_10079ACD0()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "SetBTCoexParameters arguments missing", v2, v3, v4, v5, v6);
}

void sub_10079AD04()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "No arguments passed to setGrantRC2Medium", v2, v3, v4, v5, v6);
}

void sub_10079AD38()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "RC2 is not supported", v2, v3, v4, v5, v6);
}

void sub_10079AD6C()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "No arguments passed to setWifiCriticalBuffering", v2, v3, v4, v5, v6);
}

void sub_10079ADA0(NSObject *a1, uint64_t a2, uint64_t a3)
{
  int v3 = 136315138;
  uint64_t v4 = "void BT::PurpleCoexManager::SetHRBChannelMap(xpc_object_t)";
  sub_100057438((void *)&_mh_execute_header, a1, a3, "%s, Error: While reading in HRB AFH Map from UCM", (uint8_t *)&v3);
}

void sub_10079AE1C()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Error: UCM message WCMBTSetAntennaRequest received is null", v2, v3, v4, v5, v6);
}

void sub_10079AE50()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "PurpleCoexManager Error: SPMI Type 60 Config Command : %d", v2, v3, v4, v5, v6);
}

void sub_10079AEB8()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Error: SPMI Type 53 Config Command : %d", v2, v3, v4, v5, v6);
}

void sub_10079AF20()
{
  sub_1000572E8();
  __int16 v2 = 1024;
  int v3 = 144;
  _os_log_error_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_ERROR, "WCMWifiState undefined for window=%d interval=%d", v1, 0xEu);
}

void sub_10079AFA4()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to get connection handle %d", v2, v3, v4, v5, v6);
}

void sub_10079B00C()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to get Voice connection info, status %d", v2, v3, v4, v5, v6);
}

void sub_10079B074()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Failed to get ACL connection info, status %d", v2, v3, v4, v5, v6);
}

void sub_10079B0DC()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Bandwidth: Audio connection type 0x%1X, is already in the map", v2, v3, v4, v5, v6);
}

void sub_10079B144()
{
  sub_1000572E8();
  sub_100057310((void *)&_mh_execute_header, v0, v1, "Bandwidth: Audio Audio connection type 0x%1X, is not in the map", v2, v3, v4, v5, v6);
}

void sub_10079B1AC()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Bandwidth: Connection type not in the ActiveAudioConnectionType enum!", v2, v3, v4, v5, v6);
}

void sub_10079B1E0()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Bandwidth: Audio connection type unknown!!!", v2, v3, v4, v5, v6);
}

void sub_10079B214(uint64_t a1, NSObject *a2, uint64_t a3)
{
  *(_DWORD *)a1 = 136446210;
  *(void *)(a1 + 4) = "Null Object!";
  sub_100057438((void *)&_mh_execute_header, a2, a3, "Bandwidth: Error obtaining HFP Audio Device %{public}s", (uint8_t *)a1);
}

void sub_10079B258()
{
  sub_1000573EC();
  if (v6 != v7) {
    uint64_t v8 = v5;
  }
  else {
    uint64_t v8 = v1;
  }
  *(_DWORD *)uint64_t v2 = 136446210;
  *(void *)(v2 + 4) = v8;
  sub_100057438((void *)&_mh_execute_header, v3, (uint64_t)v3, "Bandwidth: Error obtaining HFP Audio Device %{public}s", v4);
  if (*(char *)(v0 + 23) < 0) {
    operator delete(*(void **)v0);
  }
}

void sub_10079B2B4()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Bandwidth: Error - a second A2DP Audio Connection was received while one was already active.", v2, v3, v4, v5, v6);
}

void sub_10079B2E8()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Bandwidth: LEA Hearing device is operating at an unrecognized LEA connection interval", v2, v3, v4, v5, v6);
}

void sub_10079B31C()
{
  sub_1000573EC();
  if (v6 != v7) {
    uint64_t v8 = v5;
  }
  else {
    uint64_t v8 = v1;
  }
  *(_DWORD *)uint64_t v2 = 136315138;
  *(void *)(v2 + 4) = v8;
  sub_100057438((void *)&_mh_execute_header, v3, (uint64_t)v3, "Bandwidth: Received LEA Audio Disconnect for device %s, when none of the LEA Audio profiles were running", v4);
  if (*(char *)(v0 + 23) < 0) {
    operator delete(*(void **)v0);
  }
}

void sub_10079B378()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Bandwidth: Classic device recived was null!", v2, v3, v4, v5, v6);
}

void sub_10079B3AC()
{
  sub_1000572DC();
  sub_1000804F4((void *)&_mh_execute_header, v0, v1, "Bandwidth: LE Connection Recived had a null NSUUID", v2, v3, v4, v5, v6);
}

uint64_t AMFDRSealingMapCopyLocalDictForClass()
{
  return _AMFDRSealingMapCopyLocalDictForClass();
}

uint64_t AnalyticsSendEventLazy()
{
  return _AnalyticsSendEventLazy();
}

uint64_t AppleConvergedTransportCreate()
{
  return _AppleConvergedTransportCreate();
}

uint64_t AppleConvergedTransportFree()
{
  return _AppleConvergedTransportFree();
}

uint64_t AppleConvergedTransportInitParameters()
{
  return _AppleConvergedTransportInitParameters();
}

uint64_t AppleConvergedTransportIsValid()
{
  return _AppleConvergedTransportIsValid();
}

uint64_t AppleConvergedTransportRegisterEventBlockQ()
{
  return _AppleConvergedTransportRegisterEventBlockQ();
}

uint64_t AppleConvergedTransportRegisterTimeSyncEventBlockQ()
{
  return _AppleConvergedTransportRegisterTimeSyncEventBlockQ();
}

uint64_t AppleConvergedTransportSendImage()
{
  return _AppleConvergedTransportSendImage();
}

uint64_t AppleConvergedTransportWrite()
{
  return _AppleConvergedTransportWrite();
}

uint64_t BYSetupAssistantNeedsToRun()
{
  return _BYSetupAssistantNeedsToRun();
}

uint64_t BiomeLibrary()
{
  return _BiomeLibrary();
}

uint64_t CBDeviceTypeToNSLocalizedString()
{
  return _CBDeviceTypeToNSLocalizedString();
}

uint64_t CBDiscoveryFlagsToString()
{
  return _CBDiscoveryFlagsToString();
}

uint64_t CBDiscoveryTypesAddTypes()
{
  return _CBDiscoveryTypesAddTypes();
}

uint64_t CBDiscoveryTypesAppendString()
{
  return _CBDiscoveryTypesAppendString();
}

uint64_t CBDiscoveryTypesEnumToString()
{
  return _CBDiscoveryTypesEnumToString();
}

uint64_t CBDiscoveryTypesNearbyActionV1()
{
  return _CBDiscoveryTypesNearbyActionV1();
}

uint64_t CBDiscoveryTypesNearbyActionV2()
{
  return _CBDiscoveryTypesNearbyActionV2();
}

uint64_t CBDiscoveryTypesNearbyInfoV2()
{
  return _CBDiscoveryTypesNearbyInfoV2();
}

uint64_t CBDiscoveryTypesNeedsIdentify()
{
  return _CBDiscoveryTypesNeedsIdentify();
}

uint64_t CBDiscoveryTypesNeedsObjectLocator()
{
  return _CBDiscoveryTypesNeedsObjectLocator();
}

uint64_t CBDiscoveryTypesProximityService()
{
  return _CBDiscoveryTypesProximityService();
}

uint64_t CBDiscoveryTypesToString()
{
  return _CBDiscoveryTypesToString();
}

uint64_t CBErrorF()
{
  return _CBErrorF();
}

uint64_t CBGenerateObfuscatedSHA256HashedString()
{
  return _CBGenerateObfuscatedSHA256HashedString();
}

uint64_t CBProductIDFromNSString()
{
  return _CBProductIDFromNSString();
}

uint64_t CBXPCGetNextClientID()
{
  return _CBXPCGetNextClientID();
}

CCCryptorStatus CCCryptorCreate(CCOperation op, CCAlgorithm alg, CCOptions options, const void *key, size_t keyLength, const void *iv, CCCryptorRef *cryptorRef)
{
  return _CCCryptorCreate(op, alg, options, key, keyLength, iv, cryptorRef);
}

CCCryptorStatus CCCryptorRelease(CCCryptorRef cryptorRef)
{
  return _CCCryptorRelease(cryptorRef);
}

CCCryptorStatus CCCryptorUpdate(CCCryptorRef cryptorRef, const void *dataIn, size_t dataInLength, void *dataOut, size_t dataOutAvailable, size_t *dataOutMoved)
{
  return _CCCryptorUpdate(cryptorRef, dataIn, dataInLength, dataOut, dataOutAvailable, dataOutMoved);
}

CCRNGStatus CCRandomGenerateBytes(void *bytes, size_t count)
{
  return _CCRandomGenerateBytes(bytes, count);
}

unsigned __int8 *__cdecl CC_SHA1(const void *data, CC_LONG len, unsigned __int8 *md)
{
  return _CC_SHA1(data, len, md);
}

unsigned __int8 *__cdecl CC_SHA256(const void *data, CC_LONG len, unsigned __int8 *md)
{
  return _CC_SHA256(data, len, md);
}

CFAbsoluteTime CFAbsoluteTimeGetCurrent(void)
{
  return _CFAbsoluteTimeGetCurrent();
}

void CFArrayAppendValue(CFMutableArrayRef theArray, const void *value)
{
}

Boolean CFArrayContainsValue(CFArrayRef theArray, CFRange range, const void *value)
{
  return _CFArrayContainsValue(theArray, range, value);
}

CFMutableArrayRef CFArrayCreateMutable(CFAllocatorRef allocator, CFIndex capacity, const CFArrayCallBacks *callBacks)
{
  return _CFArrayCreateMutable(allocator, capacity, callBacks);
}

CFIndex CFArrayGetCount(CFArrayRef theArray)
{
  return _CFArrayGetCount(theArray);
}

CFTypeID CFArrayGetTypeID(void)
{
  return _CFArrayGetTypeID();
}

const void *__cdecl CFArrayGetValueAtIndex(CFArrayRef theArray, CFIndex idx)
{
  return _CFArrayGetValueAtIndex(theArray, idx);
}

void CFArrayRemoveAllValues(CFMutableArrayRef theArray)
{
}

CFTypeRef CFAutorelease(CFTypeRef arg)
{
  return _CFAutorelease(arg);
}

CFTypeID CFBooleanGetTypeID(void)
{
  return _CFBooleanGetTypeID();
}

Boolean CFBooleanGetValue(CFBooleanRef BOOLean)
{
  return _CFBooleanGetValue(BOOLean);
}

CFBundleRef CFBundleCreate(CFAllocatorRef allocator, CFURLRef bundleURL)
{
  return _CFBundleCreate(allocator, bundleURL);
}

void *__cdecl CFBundleGetDataPointerForName(CFBundleRef bundle, CFStringRef symbolName)
{
  return _CFBundleGetDataPointerForName(bundle, symbolName);
}

void *__cdecl CFBundleGetFunctionPointerForName(CFBundleRef bundle, CFStringRef functionName)
{
  return _CFBundleGetFunctionPointerForName(bundle, functionName);
}

CFDataRef CFDataCreate(CFAllocatorRef allocator, const UInt8 *bytes, CFIndex length)
{
  return _CFDataCreate(allocator, bytes, length);
}

CFDataRef CFDataCreateCopy(CFAllocatorRef allocator, CFDataRef theData)
{
  return _CFDataCreateCopy(allocator, theData);
}

const UInt8 *__cdecl CFDataGetBytePtr(CFDataRef theData)
{
  return _CFDataGetBytePtr(theData);
}

void CFDataGetBytes(CFDataRef theData, CFRange range, UInt8 *buffer)
{
}

CFIndex CFDataGetLength(CFDataRef theData)
{
  return _CFDataGetLength(theData);
}

CFTypeID CFDataGetTypeID(void)
{
  return _CFDataGetTypeID();
}

CFComparisonResult CFDateCompare(CFDateRef theDate, CFDateRef otherDate, void *context)
{
  return _CFDateCompare(theDate, otherDate, context);
}

CFDateRef CFDateCreate(CFAllocatorRef allocator, CFAbsoluteTime at)
{
  return _CFDateCreate(allocator, at);
}

CFDateFormatterRef CFDateFormatterCreate(CFAllocatorRef allocator, CFLocaleRef locale, CFDateFormatterStyle dateStyle, CFDateFormatterStyle timeStyle)
{
  return _CFDateFormatterCreate(allocator, locale, dateStyle, timeStyle);
}

CFDateRef CFDateFormatterCreateDateFromString(CFAllocatorRef allocator, CFDateFormatterRef formatter, CFStringRef string, CFRange *rangep)
{
  return _CFDateFormatterCreateDateFromString(allocator, formatter, string, rangep);
}

CFStringRef CFDateFormatterCreateStringWithAbsoluteTime(CFAllocatorRef allocator, CFDateFormatterRef formatter, CFAbsoluteTime at)
{
  return _CFDateFormatterCreateStringWithAbsoluteTime(allocator, formatter, at);
}

CFStringRef CFDateFormatterCreateStringWithDate(CFAllocatorRef allocator, CFDateFormatterRef formatter, CFDateRef date)
{
  return _CFDateFormatterCreateStringWithDate(allocator, formatter, date);
}

CFStringRef CFDateFormatterGetFormat(CFDateFormatterRef formatter)
{
  return _CFDateFormatterGetFormat(formatter);
}

void CFDateFormatterSetFormat(CFDateFormatterRef formatter, CFStringRef formatString)
{
}

CFAbsoluteTime CFDateGetAbsoluteTime(CFDateRef theDate)
{
  return _CFDateGetAbsoluteTime(theDate);
}

void CFDictionaryAddValue(CFMutableDictionaryRef theDict, const void *key, const void *value)
{
}

Boolean CFDictionaryContainsKey(CFDictionaryRef theDict, const void *key)
{
  return _CFDictionaryContainsKey(theDict, key);
}

CFDictionaryRef CFDictionaryCreate(CFAllocatorRef allocator, const void **keys, const void **values, CFIndex numValues, const CFDictionaryKeyCallBacks *keyCallBacks, const CFDictionaryValueCallBacks *valueCallBacks)
{
  return _CFDictionaryCreate(allocator, keys, values, numValues, keyCallBacks, valueCallBacks);
}

CFDictionaryRef CFDictionaryCreateCopy(CFAllocatorRef allocator, CFDictionaryRef theDict)
{
  return _CFDictionaryCreateCopy(allocator, theDict);
}

CFMutableDictionaryRef CFDictionaryCreateMutable(CFAllocatorRef allocator, CFIndex capacity, const CFDictionaryKeyCallBacks *keyCallBacks, const CFDictionaryValueCallBacks *valueCallBacks)
{
  return _CFDictionaryCreateMutable(allocator, capacity, keyCallBacks, valueCallBacks);
}

CFMutableDictionaryRef CFDictionaryCreateMutableCopy(CFAllocatorRef allocator, CFIndex capacity, CFDictionaryRef theDict)
{
  return _CFDictionaryCreateMutableCopy(allocator, capacity, theDict);
}

uint64_t CFDictionaryGetCFDataOfLength()
{
  return _CFDictionaryGetCFDataOfLength();
}

CFIndex CFDictionaryGetCount(CFDictionaryRef theDict)
{
  return _CFDictionaryGetCount(theDict);
}

uint64_t CFDictionaryGetData()
{
  return _CFDictionaryGetData();
}

uint64_t CFDictionaryGetDouble()
{
  return _CFDictionaryGetDouble();
}

uint64_t CFDictionaryGetInt64()
{
  return _CFDictionaryGetInt64();
}

uint64_t CFDictionaryGetInt64Ranged()
{
  return _CFDictionaryGetInt64Ranged();
}

CFTypeID CFDictionaryGetTypeID(void)
{
  return _CFDictionaryGetTypeID();
}

uint64_t CFDictionaryGetTypedValue()
{
  return _CFDictionaryGetTypedValue();
}

const void *__cdecl CFDictionaryGetValue(CFDictionaryRef theDict, const void *key)
{
  return _CFDictionaryGetValue(theDict, key);
}

Boolean CFDictionaryGetValueIfPresent(CFDictionaryRef theDict, const void *key, const void **value)
{
  return _CFDictionaryGetValueIfPresent(theDict, key, value);
}

void CFDictionaryRemoveValue(CFMutableDictionaryRef theDict, const void *key)
{
}

void CFDictionarySetValue(CFMutableDictionaryRef theDict, const void *key, const void *value)
{
}

Boolean CFEqual(CFTypeRef cf1, CFTypeRef cf2)
{
  return _CFEqual(cf1, cf2);
}

CFIndex CFErrorGetCode(CFErrorRef err)
{
  return _CFErrorGetCode(err);
}

CFTypeID CFGetTypeID(CFTypeRef cf)
{
  return _CFGetTypeID(cf);
}

CFLocaleRef CFLocaleCopyCurrent(void)
{
  return _CFLocaleCopyCurrent();
}

void CFNotificationCenterAddObserver(CFNotificationCenterRef center, const void *observer, CFNotificationCallback callBack, CFStringRef name, const void *object, CFNotificationSuspensionBehavior suspensionBehavior)
{
}

CFNotificationCenterRef CFNotificationCenterGetDarwinNotifyCenter(void)
{
  return _CFNotificationCenterGetDarwinNotifyCenter();
}

CFNotificationCenterRef CFNotificationCenterGetLocalCenter(void)
{
  return _CFNotificationCenterGetLocalCenter();
}

void CFNotificationCenterPostNotification(CFNotificationCenterRef center, CFNotificationName name, const void *object, CFDictionaryRef userInfo, Boolean deliverImmediately)
{
}

void CFNotificationCenterRemoveObserver(CFNotificationCenterRef center, const void *observer, CFNotificationName name, const void *object)
{
}

CFNumberRef CFNumberCreate(CFAllocatorRef allocator, CFNumberType theType, const void *valuePtr)
{
  return _CFNumberCreate(allocator, theType, valuePtr);
}

CFTypeID CFNumberGetTypeID(void)
{
  return _CFNumberGetTypeID();
}

Boolean CFNumberGetValue(CFNumberRef number, CFNumberType theType, void *valuePtr)
{
  return _CFNumberGetValue(number, theType, valuePtr);
}

Boolean CFNumberIsFloatType(CFNumberRef number)
{
  return _CFNumberIsFloatType(number);
}

Boolean CFPreferencesAppSynchronize(CFStringRef applicationID)
{
  return _CFPreferencesAppSynchronize(applicationID);
}

CFPropertyListRef CFPreferencesCopyAppValue(CFStringRef key, CFStringRef applicationID)
{
  return _CFPreferencesCopyAppValue(key, applicationID);
}

CFArrayRef CFPreferencesCopyKeyList(CFStringRef applicationID, CFStringRef userName, CFStringRef hostName)
{
  return _CFPreferencesCopyKeyList(applicationID, userName, hostName);
}

CFPropertyListRef CFPreferencesCopyValue(CFStringRef key, CFStringRef applicationID, CFStringRef userName, CFStringRef hostName)
{
  return _CFPreferencesCopyValue(key, applicationID, userName, hostName);
}

Boolean CFPreferencesGetAppBooleanValue(CFStringRef key, CFStringRef applicationID, Boolean *keyExistsAndHasValidFormat)
{
  return _CFPreferencesGetAppBooleanValue(key, applicationID, keyExistsAndHasValidFormat);
}

CFIndex CFPreferencesGetAppIntegerValue(CFStringRef key, CFStringRef applicationID, Boolean *keyExistsAndHasValidFormat)
{
  return _CFPreferencesGetAppIntegerValue(key, applicationID, keyExistsAndHasValidFormat);
}

void CFPreferencesSetAppValue(CFStringRef key, CFPropertyListRef value, CFStringRef applicationID)
{
}

void CFPreferencesSetValue(CFStringRef key, CFPropertyListRef value, CFStringRef applicationID, CFStringRef userName, CFStringRef hostName)
{
}

Boolean CFPreferencesSynchronize(CFStringRef applicationID, CFStringRef userName, CFStringRef hostName)
{
  return _CFPreferencesSynchronize(applicationID, userName, hostName);
}

uint64_t CFPrefs_CopyKeys()
{
  return _CFPrefs_CopyKeys();
}

uint64_t CFPrefs_CopyTypedValue()
{
  return _CFPrefs_CopyTypedValue();
}

uint64_t CFPrefs_GetDouble()
{
  return _CFPrefs_GetDouble();
}

uint64_t CFPrefs_GetInt64()
{
  return _CFPrefs_GetInt64();
}

uint64_t CFPrefs_RemoveValue()
{
  return _CFPrefs_RemoveValue();
}

uint64_t CFPrefs_SetInt64()
{
  return _CFPrefs_SetInt64();
}

uint64_t CFPrefs_SetValue()
{
  return _CFPrefs_SetValue();
}

CFDataRef CFPropertyListCreateData(CFAllocatorRef allocator, CFPropertyListRef propertyList, CFPropertyListFormat format, CFOptionFlags options, CFErrorRef *error)
{
  return _CFPropertyListCreateData(allocator, propertyList, format, options, error);
}

CFPropertyListRef CFPropertyListCreateWithData(CFAllocatorRef allocator, CFDataRef data, CFOptionFlags options, CFPropertyListFormat *format, CFErrorRef *error)
{
  return _CFPropertyListCreateWithData(allocator, data, options, format, error);
}

void CFRelease(CFTypeRef cf)
{
}

CFTypeRef CFRetain(CFTypeRef cf)
{
  return _CFRetain(cf);
}

void CFRunLoopAddSource(CFRunLoopRef rl, CFRunLoopSourceRef source, CFRunLoopMode mode)
{
}

CFRunLoopRef CFRunLoopGetCurrent(void)
{
  return _CFRunLoopGetCurrent();
}

CFRunLoopRef CFRunLoopGetMain(void)
{
  return _CFRunLoopGetMain();
}

void CFRunLoopRemoveSource(CFRunLoopRef rl, CFRunLoopSourceRef source, CFRunLoopMode mode)
{
}

void CFRunLoopRun(void)
{
}

CFRunLoopRunResult CFRunLoopRunInMode(CFRunLoopMode mode, CFTimeInterval seconds, Boolean returnAfterSourceHandled)
{
  return _CFRunLoopRunInMode(mode, seconds, returnAfterSourceHandled);
}

void CFRunLoopStop(CFRunLoopRef rl)
{
}

void CFSetApplyFunction(CFSetRef theSet, CFSetApplierFunction applier, void *context)
{
}

CFMutableSetRef CFSetCreateMutable(CFAllocatorRef allocator, CFIndex capacity, const CFSetCallBacks *callBacks)
{
  return _CFSetCreateMutable(allocator, capacity, callBacks);
}

CFIndex CFSetGetCount(CFSetRef theSet)
{
  return _CFSetGetCount(theSet);
}

void CFSetRemoveValue(CFMutableSetRef theSet, const void *value)
{
}

void CFSetSetValue(CFMutableSetRef theSet, const void *value)
{
}

CFComparisonResult CFStringCompare(CFStringRef theString1, CFStringRef theString2, CFStringCompareFlags compareOptions)
{
  return _CFStringCompare(theString1, theString2, compareOptions);
}

CFComparisonResult CFStringCompareWithOptions(CFStringRef theString1, CFStringRef theString2, CFRange rangeToCompare, CFStringCompareFlags compareOptions)
{
  return _CFStringCompareWithOptions(theString1, theString2, rangeToCompare, compareOptions);
}

CFStringRef CFStringCreateCopy(CFAllocatorRef alloc, CFStringRef theString)
{
  return _CFStringCreateCopy(alloc, theString);
}

CFStringRef CFStringCreateWithBytes(CFAllocatorRef alloc, const UInt8 *bytes, CFIndex numBytes, CFStringEncoding encoding, Boolean isExternalRepresentation)
{
  return _CFStringCreateWithBytes(alloc, bytes, numBytes, encoding, isExternalRepresentation);
}

CFStringRef CFStringCreateWithCString(CFAllocatorRef alloc, const char *cStr, CFStringEncoding encoding)
{
  return _CFStringCreateWithCString(alloc, cStr, encoding);
}

CFStringRef CFStringCreateWithCStringNoCopy(CFAllocatorRef alloc, const char *cStr, CFStringEncoding encoding, CFAllocatorRef contentsDeallocator)
{
  return _CFStringCreateWithCStringNoCopy(alloc, cStr, encoding, contentsDeallocator);
}

CFStringRef CFStringCreateWithFormat(CFAllocatorRef alloc, CFDictionaryRef formatOptions, CFStringRef format, ...)
{
  return _CFStringCreateWithFormat(alloc, formatOptions, format);
}

CFRange CFStringFind(CFStringRef theString, CFStringRef stringToFind, CFStringCompareFlags compareOptions)
{
  CFRange v5 = _CFStringFind(theString, stringToFind, compareOptions);
  CFIndex length = v5.length;
  CFIndex location = v5.location;
  result.CFIndex length = length;
  result.CFIndex location = location;
  return result;
}

CFIndex CFStringGetBytes(CFStringRef theString, CFRange range, CFStringEncoding encoding, UInt8 lossByte, Boolean isExternalRepresentation, UInt8 *buffer, CFIndex maxBufLen, CFIndex *usedBufLen)
{
  return _CFStringGetBytes(theString, range, encoding, lossByte, isExternalRepresentation, buffer, maxBufLen, usedBufLen);
}

Boolean CFStringGetCString(CFStringRef theString, char *buffer, CFIndex bufferSize, CFStringEncoding encoding)
{
  return _CFStringGetCString(theString, buffer, bufferSize, encoding);
}

const char *__cdecl CFStringGetCStringPtr(CFStringRef theString, CFStringEncoding encoding)
{
  return _CFStringGetCStringPtr(theString, encoding);
}

UniChar CFStringGetCharacterAtIndex(CFStringRef theString, CFIndex idx)
{
  return _CFStringGetCharacterAtIndex(theString, idx);
}

double CFStringGetDoubleValue(CFStringRef str)
{
  return _CFStringGetDoubleValue(str);
}

SInt32 CFStringGetIntValue(CFStringRef str)
{
  return _CFStringGetIntValue(str);
}

CFIndex CFStringGetLength(CFStringRef theString)
{
  return _CFStringGetLength(theString);
}

CFIndex CFStringGetMaximumSizeForEncoding(CFIndex length, CFStringEncoding encoding)
{
  return _CFStringGetMaximumSizeForEncoding(length, encoding);
}

CFTypeID CFStringGetTypeID(void)
{
  return _CFStringGetTypeID();
}

CFURLRef CFURLCreateWithFileSystemPath(CFAllocatorRef allocator, CFStringRef filePath, CFURLPathStyle pathStyle, Boolean isDirectory)
{
  return _CFURLCreateWithFileSystemPath(allocator, filePath, pathStyle, isDirectory);
}

CFUUIDRef CFUUIDCreateFromUUIDBytes(CFAllocatorRef alloc, CFUUIDBytes bytes)
{
  return _CFUUIDCreateFromUUIDBytes(alloc, bytes);
}

CFUUIDRef CFUUIDGetConstantUUIDWithBytes(CFAllocatorRef alloc, UInt8 byte0, UInt8 byte1, UInt8 byte2, UInt8 byte3, UInt8 byte4, UInt8 byte5, UInt8 byte6, UInt8 byte7, UInt8 byte8, UInt8 byte9, UInt8 byte10, UInt8 byte11, UInt8 byte12, UInt8 byte13, UInt8 byte14, UInt8 byte15)
{
  return _CFUUIDGetConstantUUIDWithBytes(alloc, byte0, byte1, byte2, byte3, byte4, byte5, byte6, byte7, byte8, byte9, byte10, byte11, byte12, byte13, byte14, byte15);
}

CFUUIDBytes CFUUIDGetUUIDBytes(CFUUIDRef uuid)
{
  CFUUIDBytes v3 = _CFUUIDGetUUIDBytes(uuid);
  uint64_t v2 = *(void *)&v3.byte8;
  uint64_t v1 = *(void *)&v3.byte0;
  result.byte8 = v2;
  result.byte9 = BYTE1(v2);
  result.byte10 = BYTE2(v2);
  result.byte11 = BYTE3(v2);
  result.byte12 = BYTE4(v2);
  result.byte13 = BYTE5(v2);
  result.byte14 = BYTE6(v2);
  result.byte15 = HIBYTE(v2);
  result.byte0 = v1;
  result.byte1 = BYTE1(v1);
  result.byte2 = BYTE2(v1);
  result.byte3 = BYTE3(v1);
  result.byte4 = BYTE4(v1);
  result.byte5 = BYTE5(v1);
  result.byte6 = BYTE6(v1);
  result.byte7 = HIBYTE(v1);
  return result;
}

SInt32 CFUserNotificationCancel(CFUserNotificationRef userNotification)
{
  return _CFUserNotificationCancel(userNotification);
}

CFUserNotificationRef CFUserNotificationCreate(CFAllocatorRef allocator, CFTimeInterval timeout, CFOptionFlags flags, SInt32 *error, CFDictionaryRef dictionary)
{
  return _CFUserNotificationCreate(allocator, timeout, flags, error, dictionary);
}

CFRunLoopSourceRef CFUserNotificationCreateRunLoopSource(CFAllocatorRef allocator, CFUserNotificationRef userNotification, CFUserNotificationCallBack callout, CFIndex order)
{
  return _CFUserNotificationCreateRunLoopSource(allocator, userNotification, callout, order);
}

SInt32 CFUserNotificationDisplayAlert(CFTimeInterval timeout, CFOptionFlags flags, CFURLRef iconURL, CFURLRef soundURL, CFURLRef localizationURL, CFStringRef alertHeader, CFStringRef alertMessage, CFStringRef defaultButtonTitle, CFStringRef alternateButtonTitle, CFStringRef otherButtonTitle, CFOptionFlags *responseFlags)
{
  return _CFUserNotificationDisplayAlert(timeout, flags, iconURL, soundURL, localizationURL, alertHeader, alertMessage, defaultButtonTitle, alternateButtonTitle, otherButtonTitle, responseFlags);
}

CFStringRef CFUserNotificationGetResponseValue(CFUserNotificationRef userNotification, CFStringRef key, CFIndex idx)
{
  return _CFUserNotificationGetResponseValue(userNotification, key, idx);
}

void CGImageDestinationAddImage(CGImageDestinationRef idst, CGImageRef image, CFDictionaryRef properties)
{
}

CGImageDestinationRef CGImageDestinationCreateWithData(CFMutableDataRef data, CFStringRef type, size_t count, CFDictionaryRef options)
{
  return _CGImageDestinationCreateWithData(data, type, count, options);
}

BOOL CGImageDestinationFinalize(CGImageDestinationRef idst)
{
  return _CGImageDestinationFinalize(idst);
}

CGImageRef CGImageSourceCreateThumbnailAtIndex(CGImageSourceRef isrc, size_t index, CFDictionaryRef options)
{
  return _CGImageSourceCreateThumbnailAtIndex(isrc, index, options);
}

CGImageSourceRef CGImageSourceCreateWithData(CFDataRef data, CFDictionaryRef options)
{
  return _CGImageSourceCreateWithData(data, options);
}

uint64_t CRIsCarPlayAllowed()
{
  return _CRIsCarPlayAllowed();
}

uint64_t CUAppendF()
{
  return _CUAppendF();
}

uint64_t CUDescriptionWithLevel()
{
  return _CUDescriptionWithLevel();
}

uint64_t CUDispatchTimerSet()
{
  return _CUDispatchTimerSet();
}

uint64_t CUFatalErrorF()
{
  return _CUFatalErrorF();
}

uint64_t CUPrintAddress()
{
  return _CUPrintAddress();
}

uint64_t CUPrintDuration64()
{
  return _CUPrintDuration64();
}

uint64_t CUPrintDurationDouble()
{
  return _CUPrintDurationDouble();
}

uint64_t CUPrintErrorCode()
{
  return _CUPrintErrorCode();
}

uint64_t CUPrintFlags32()
{
  return _CUPrintFlags32();
}

uint64_t CUPrintFlags64()
{
  return _CUPrintFlags64();
}

uint64_t CUPrintHex()
{
  return _CUPrintHex();
}

uint64_t CUPrintNSDataAddress()
{
  return _CUPrintNSDataAddress();
}

uint64_t CUPrintNSDataHex()
{
  return _CUPrintNSDataHex();
}

uint64_t CUPrintNSError()
{
  return _CUPrintNSError();
}

uint64_t CUPrintNSObjectMasked()
{
  return _CUPrintNSObjectMasked();
}

uint64_t CUPrintNSObjectOneLine()
{
  return _CUPrintNSObjectOneLine();
}

uint64_t CUPrintPID()
{
  return _CUPrintPID();
}

uint64_t CUPrintXPC()
{
  return _CUPrintXPC();
}

uint64_t CUXPCCreateCFObjectFromXPCObject()
{
  return _CUXPCCreateCFObjectFromXPCObject();
}

uint64_t CUXPCDecodeDouble()
{
  return _CUXPCDecodeDouble();
}

uint64_t CUXPCDecodeNSArrayOfNSString()
{
  return _CUXPCDecodeNSArrayOfNSString();
}

uint64_t CUXPCDecodeNSData()
{
  return _CUXPCDecodeNSData();
}

uint64_t CUXPCDecodeNSString()
{
  return _CUXPCDecodeNSString();
}

uint64_t CUXPCDecodeObject()
{
  return _CUXPCDecodeObject();
}

uint64_t CUXPCDecodeSInt64RangedEx()
{
  return _CUXPCDecodeSInt64RangedEx();
}

uint64_t CUXPCDecodeUInt64RangedEx()
{
  return _CUXPCDecodeUInt64RangedEx();
}

uint64_t CUXPCDictionaryCreateReply()
{
  return _CUXPCDictionaryCreateReply();
}

uint64_t CUXPCDictionaryExpectsReply()
{
  return _CUXPCDictionaryExpectsReply();
}

uint64_t CUXPCEncodeNSArrayOfObjects()
{
  return _CUXPCEncodeNSArrayOfObjects();
}

uint64_t CUXPCEncodeNSError()
{
  return _CUXPCEncodeNSError();
}

uint64_t CUXPCEncodeObject()
{
  return _CUXPCEncodeObject();
}

uint64_t CUXPCObjectGetResponseHandler()
{
  return _CUXPCObjectGetResponseHandler();
}

uint64_t CUXPCObjectSetResponseHandler()
{
  return _CUXPCObjectSetResponseHandler();
}

uint64_t CryptoHKDF()
{
  return _CryptoHKDF();
}

uint64_t DADeviceStateToString()
{
  return _DADeviceStateToString();
}

uint64_t DAEventTypeToString()
{
  return _DAEventTypeToString();
}

uint64_t DebugGetErrorString()
{
  return _DebugGetErrorString();
}

uint64_t ENAEMCrypt()
{
  return _ENAEMCrypt();
}

uint64_t ENAEMKDerive()
{
  return _ENAEMKDerive();
}

uint64_t ENErrorMetricTypeToString()
{
  return _ENErrorMetricTypeToString();
}

uint64_t ENRPIDerive()
{
  return _ENRPIDerive();
}

uint64_t ENRPIDeriveBatch()
{
  return _ENRPIDeriveBatch();
}

uint64_t ENRPIKDerive()
{
  return _ENRPIKDerive();
}

uint64_t ENRPIMetadataDeserialize()
{
  return _ENRPIMetadataDeserialize();
}

uint64_t ENRPIMetadataSerialize()
{
  return _ENRPIMetadataSerialize();
}

uint64_t FatalErrorF()
{
  return _FatalErrorF();
}

uint64_t GestaltGetDeviceClass()
{
  return _GestaltGetDeviceClass();
}

IOReturn IOAllowPowerChange(io_connect_t kernelPort, intptr_t notificationID)
{
  return _IOAllowPowerChange(kernelPort, notificationID);
}

IOReturn IOCancelPowerChange(io_connect_t kernelPort, intptr_t notificationID)
{
  return _IOCancelPowerChange(kernelPort, notificationID);
}

kern_return_t IOConnectCallAsyncMethod(mach_port_t connection, uint32_t selector, mach_port_t wake_port, uint64_t *reference, uint32_t referenceCnt, const uint64_t *input, uint32_t inputCnt, const void *inputStruct, size_t inputStructCnt, uint64_t *output, uint32_t *outputCnt, void *outputStruct, size_t *outputStructCnt)
{
  return _IOConnectCallAsyncMethod(connection, selector, wake_port, reference, referenceCnt, input, inputCnt, inputStruct, inputStructCnt, output, outputCnt, outputStruct, outputStructCnt);
}

kern_return_t IOConnectCallMethod(mach_port_t connection, uint32_t selector, const uint64_t *input, uint32_t inputCnt, const void *inputStruct, size_t inputStructCnt, uint64_t *output, uint32_t *outputCnt, void *outputStruct, size_t *outputStructCnt)
{
  return _IOConnectCallMethod(connection, selector, input, inputCnt, inputStruct, inputStructCnt, output, outputCnt, outputStruct, outputStructCnt);
}

kern_return_t IOConnectCallScalarMethod(mach_port_t connection, uint32_t selector, const uint64_t *input, uint32_t inputCnt, uint64_t *output, uint32_t *outputCnt)
{
  return _IOConnectCallScalarMethod(connection, selector, input, inputCnt, output, outputCnt);
}

kern_return_t IOConnectCallStructMethod(mach_port_t connection, uint32_t selector, const void *inputStruct, size_t inputStructCnt, void *outputStruct, size_t *outputStructCnt)
{
  return _IOConnectCallStructMethod(connection, selector, inputStruct, inputStructCnt, outputStruct, outputStructCnt);
}

kern_return_t IOCreatePlugInInterfaceForService(io_service_t service, CFUUIDRef pluginType, CFUUIDRef interfaceType, IOCFPlugInInterface ***theInterface, SInt32 *theScore)
{
  return _IOCreatePlugInInterfaceForService(service, pluginType, interfaceType, theInterface, theScore);
}

IOReturn IODeregisterForSystemPower(io_object_t *notifier)
{
  return _IODeregisterForSystemPower(notifier);
}

kern_return_t IODestroyPlugInInterface(IOCFPlugInInterface **interface)
{
  return _IODestroyPlugInInterface(interface);
}

uint64_t IOEthernetControllerCreate()
{
  return _IOEthernetControllerCreate();
}

uint64_t IOEthernetControllerGetIONetworkInterfaceObject()
{
  return _IOEthernetControllerGetIONetworkInterfaceObject();
}

uint64_t IOEthernetControllerReadPacket()
{
  return _IOEthernetControllerReadPacket();
}

uint64_t IOEthernetControllerRegisterDisableCallback()
{
  return _IOEthernetControllerRegisterDisableCallback();
}

uint64_t IOEthernetControllerRegisterEnableCallback()
{
  return _IOEthernetControllerRegisterEnableCallback();
}

uint64_t IOEthernetControllerScheduleWithRunLoop()
{
  return _IOEthernetControllerScheduleWithRunLoop();
}

uint64_t IOEthernetControllerSetLinkStatus()
{
  return _IOEthernetControllerSetLinkStatus();
}

uint64_t IOEthernetControllerUnscheduleFromRunLoop()
{
  return _IOEthernetControllerUnscheduleFromRunLoop();
}

uint64_t IOEthernetControllerWritePacket()
{
  return _IOEthernetControllerWritePacket();
}

CFTypeRef IOHIDDeviceGetProperty(IOHIDDeviceRef device, CFStringRef key)
{
  return _IOHIDDeviceGetProperty(device, key);
}

IOReturn IOHIDDeviceGetReport(IOHIDDeviceRef device, IOHIDReportType reportType, CFIndex reportID, uint8_t *report, CFIndex *pReportLength)
{
  return _IOHIDDeviceGetReport(device, reportType, reportID, report, pReportLength);
}

IOReturn IOHIDDeviceOpen(IOHIDDeviceRef device, IOOptionBits options)
{
  return _IOHIDDeviceOpen(device, options);
}

IOReturn IOHIDDeviceSetReport(IOHIDDeviceRef device, IOHIDReportType reportType, CFIndex reportID, const uint8_t *report, CFIndex reportLength)
{
  return _IOHIDDeviceSetReport(device, reportType, reportID, report, reportLength);
}

uint64_t IOHIDEventGetDataValue()
{
  return _IOHIDEventGetDataValue();
}

IOReturn IOHIDManagerClose(IOHIDManagerRef manager, IOOptionBits options)
{
  return _IOHIDManagerClose(manager, options);
}

IOHIDManagerRef IOHIDManagerCreate(CFAllocatorRef allocator, IOOptionBits options)
{
  return _IOHIDManagerCreate(allocator, options);
}

IOReturn IOHIDManagerOpen(IOHIDManagerRef manager, IOOptionBits options)
{
  return _IOHIDManagerOpen(manager, options);
}

void IOHIDManagerRegisterDeviceMatchingCallback(IOHIDManagerRef manager, IOHIDDeviceCallback callback, void *context)
{
}

void IOHIDManagerRegisterDeviceRemovalCallback(IOHIDManagerRef manager, IOHIDDeviceCallback callback, void *context)
{
}

void IOHIDManagerScheduleWithRunLoop(IOHIDManagerRef manager, CFRunLoopRef runLoop, CFStringRef runLoopMode)
{
}

void IOHIDManagerSetDeviceMatchingMultiple(IOHIDManagerRef manager, CFArrayRef multiple)
{
}

void IOHIDManagerUnscheduleFromRunLoop(IOHIDManagerRef manager, CFRunLoopRef runLoop, CFStringRef runLoopMode)
{
}

uint64_t IOHIDUserDeviceCreateWithOptions()
{
  return _IOHIDUserDeviceCreateWithOptions();
}

IOReturn IOHIDUserDeviceHandleReportWithTimeStamp(IOHIDUserDeviceRef device, uint64_t timestamp, const uint8_t *report, CFIndex reportLength)
{
  return _IOHIDUserDeviceHandleReportWithTimeStamp(device, timestamp, report, reportLength);
}

uint64_t IOHIDUserDeviceRegisterGetReportWithReturnLengthCallback()
{
  return _IOHIDUserDeviceRegisterGetReportWithReturnLengthCallback();
}

uint64_t IOHIDUserDeviceRegisterSetReportCallback()
{
  return _IOHIDUserDeviceRegisterSetReportCallback();
}

uint64_t IOHIDUserDeviceScheduleWithDispatchQueue()
{
  return _IOHIDUserDeviceScheduleWithDispatchQueue();
}

uint64_t IOHIDUserDeviceUnscheduleFromDispatchQueue()
{
  return _IOHIDUserDeviceUnscheduleFromDispatchQueue();
}

BOOLean_t IOIteratorIsValid(io_iterator_t iterator)
{
  return _IOIteratorIsValid(iterator);
}

io_object_t IOIteratorNext(io_iterator_t iterator)
{
  return _IOIteratorNext(iterator);
}

IONotificationPortRef IONotificationPortCreate(mach_port_t mainPort)
{
  return _IONotificationPortCreate(mainPort);
}

void IONotificationPortDestroy(IONotificationPortRef notify)
{
}

mach_port_t IONotificationPortGetMachPort(IONotificationPortRef notify)
{
  return _IONotificationPortGetMachPort(notify);
}

CFRunLoopSourceRef IONotificationPortGetRunLoopSource(IONotificationPortRef notify)
{
  return _IONotificationPortGetRunLoopSource(notify);
}

void IONotificationPortSetDispatchQueue(IONotificationPortRef notify, dispatch_queue_t queue)
{
}

CFStringRef IOObjectCopyClass(io_object_t object)
{
  return _IOObjectCopyClass(object);
}

kern_return_t IOObjectRelease(io_object_t object)
{
  return _IOObjectRelease(object);
}

IOReturn IOPMAssertionCreateWithName(CFStringRef AssertionType, IOPMAssertionLevel AssertionLevel, CFStringRef AssertionName, IOPMAssertionID *AssertionID)
{
  return _IOPMAssertionCreateWithName(AssertionType, AssertionLevel, AssertionName, AssertionID);
}

uint64_t IOPMAssertionDeclareSystemActivityWithProperties()
{
  return _IOPMAssertionDeclareSystemActivityWithProperties();
}

IOReturn IOPMAssertionRelease(IOPMAssertionID AssertionID)
{
  return _IOPMAssertionRelease(AssertionID);
}

uint64_t IOPMClaimSystemWakeEvent()
{
  return _IOPMClaimSystemWakeEvent();
}

uint64_t IOPMRequestSysWake()
{
  return _IOPMRequestSysWake();
}

CFDictionaryRef IOPSCopyExternalPowerAdapterDetails(void)
{
  return _IOPSCopyExternalPowerAdapterDetails();
}

uint64_t IOPSCopyPowerSourcesByType()
{
  return _IOPSCopyPowerSourcesByType();
}

CFTypeRef IOPSCopyPowerSourcesInfo(void)
{
  return _IOPSCopyPowerSourcesInfo();
}

CFArrayRef IOPSCopyPowerSourcesList(CFTypeRef blob)
{
  return _IOPSCopyPowerSourcesList(blob);
}

uint64_t IOPSCreatePowerSource()
{
  return _IOPSCreatePowerSource();
}

uint64_t IOPSGetPercentRemaining()
{
  return _IOPSGetPercentRemaining();
}

CFDictionaryRef IOPSGetPowerSourceDescription(CFTypeRef blob, CFTypeRef ps)
{
  return _IOPSGetPowerSourceDescription(blob, ps);
}

CFStringRef IOPSGetProvidingPowerSourceType(CFTypeRef snapshot)
{
  return _IOPSGetProvidingPowerSourceType(snapshot);
}

uint64_t IOPSReleasePowerSource()
{
  return _IOPSReleasePowerSource();
}

uint64_t IOPSSetPowerSourceDetails()
{
  return _IOPSSetPowerSourceDetails();
}

io_connect_t IORegisterForSystemPower(void *refcon, IONotificationPortRef *thePortRef, IOServiceInterestCallback callback, io_object_t *notifier)
{
  return _IORegisterForSystemPower(refcon, thePortRef, callback, notifier);
}

kern_return_t IORegistryEntryCreateCFProperties(io_registry_entry_t entry, CFMutableDictionaryRef *properties, CFAllocatorRef allocator, IOOptionBits options)
{
  return _IORegistryEntryCreateCFProperties(entry, properties, allocator, options);
}

CFTypeRef IORegistryEntryCreateCFProperty(io_registry_entry_t entry, CFStringRef key, CFAllocatorRef allocator, IOOptionBits options)
{
  return _IORegistryEntryCreateCFProperty(entry, key, allocator, options);
}

io_registry_entry_t IORegistryEntryFromPath(mach_port_t mainPort, const io_string_t path)
{
  return _IORegistryEntryFromPath(mainPort, path);
}

kern_return_t IORegistryEntryGetChildEntry(io_registry_entry_t entry, const io_name_t plane, io_registry_entry_t *child)
{
  return _IORegistryEntryGetChildEntry(entry, plane, child);
}

kern_return_t IORegistryEntryGetChildIterator(io_registry_entry_t entry, const io_name_t plane, io_iterator_t *iterator)
{
  return _IORegistryEntryGetChildIterator(entry, plane, iterator);
}

kern_return_t IORegistryEntryGetName(io_registry_entry_t entry, io_name_t name)
{
  return _IORegistryEntryGetName(entry, name);
}

kern_return_t IORegistryEntryGetParentEntry(io_registry_entry_t entry, const io_name_t plane, io_registry_entry_t *parent)
{
  return _IORegistryEntryGetParentEntry(entry, plane, parent);
}

kern_return_t IORegistryEntryGetRegistryEntryID(io_registry_entry_t entry, uint64_t *entryID)
{
  return _IORegistryEntryGetRegistryEntryID(entry, entryID);
}

CFTypeRef IORegistryEntrySearchCFProperty(io_registry_entry_t entry, const io_name_t plane, CFStringRef key, CFAllocatorRef allocator, IOOptionBits options)
{
  return _IORegistryEntrySearchCFProperty(entry, plane, key, allocator, options);
}

kern_return_t IORegistryEntrySetCFProperty(io_registry_entry_t entry, CFStringRef propertyName, CFTypeRef property)
{
  return _IORegistryEntrySetCFProperty(entry, propertyName, property);
}

kern_return_t IOServiceAddInterestNotification(IONotificationPortRef notifyPort, io_service_t service, const io_name_t interestType, IOServiceInterestCallback callback, void *refCon, io_object_t *notification)
{
  return _IOServiceAddInterestNotification(notifyPort, service, interestType, callback, refCon, notification);
}

kern_return_t IOServiceAddMatchingNotification(IONotificationPortRef notifyPort, const io_name_t notificationType, CFDictionaryRef matching, IOServiceMatchingCallback callback, void *refCon, io_iterator_t *notification)
{
  return _IOServiceAddMatchingNotification(notifyPort, notificationType, matching, callback, refCon, notification);
}

kern_return_t IOServiceClose(io_connect_t connect)
{
  return _IOServiceClose(connect);
}

io_service_t IOServiceGetMatchingService(mach_port_t mainPort, CFDictionaryRef matching)
{
  return _IOServiceGetMatchingService(mainPort, matching);
}

kern_return_t IOServiceGetMatchingServices(mach_port_t mainPort, CFDictionaryRef matching, io_iterator_t *existing)
{
  return _IOServiceGetMatchingServices(mainPort, matching, existing);
}

CFMutableDictionaryRef IOServiceMatching(const char *name)
{
  return _IOServiceMatching(name);
}

CFMutableDictionaryRef IOServiceNameMatching(const char *name)
{
  return _IOServiceNameMatching(name);
}

kern_return_t IOServiceOpen(io_service_t service, task_port_t owningTask, uint32_t type, io_connect_t *connect)
{
  return _IOServiceOpen(service, owningTask, type, connect);
}

uint64_t IsAppleInternalBuild()
{
  return _IsAppleInternalBuild();
}

uint64_t LXEntryCopyString()
{
  return _LXEntryCopyString();
}

uint64_t LXEntryGetMetaFlags()
{
  return _LXEntryGetMetaFlags();
}

uint64_t LXLexiconCreate()
{
  return _LXLexiconCreate();
}

uint64_t LXLexiconEnumerateEntriesForString()
{
  return _LXLexiconEnumerateEntriesForString();
}

uint64_t LogCategory_Remove()
{
  return _LogCategory_Remove();
}

uint64_t LogControl()
{
  return _LogControl();
}

uint64_t LogPrintF_safe()
{
  return _LogPrintF_safe();
}

uint64_t LogSetAppID()
{
  return _LogSetAppID();
}

uint64_t LogShow()
{
  return _LogShow();
}

uint64_t MGCopyAnswer()
{
  return _MGCopyAnswer();
}

uint64_t MGGetBoolAnswer()
{
  return _MGGetBoolAnswer();
}

uint64_t MGGetProductType()
{
  return _MGGetProductType();
}

uint64_t MGGetSInt32Answer()
{
  return _MGGetSInt32Answer();
}

uint64_t MGGetStringAnswer()
{
  return _MGGetStringAnswer();
}

uint64_t MGIsDeviceOfType()
{
  return _MGIsDeviceOfType();
}

uint64_t MGIsDeviceOneOfType()
{
  return _MGIsDeviceOneOfType();
}

uint64_t MKBDeviceUnlockedSinceBoot()
{
  return _MKBDeviceUnlockedSinceBoot();
}

uint64_t MillisecondsToUpTicks()
{
  return _MillisecondsToUpTicks();
}

uint64_t NRBluetoothPacketParserCreate()
{
  return _NRBluetoothPacketParserCreate();
}

uint64_t NRBluetoothPacketParserCreateReadContext()
{
  return _NRBluetoothPacketParserCreateReadContext();
}

uint64_t NRBluetoothPacketParserCreateWriteContext()
{
  return _NRBluetoothPacketParserCreateWriteContext();
}

uint64_t NRBluetoothPacketParserGetSlotCount()
{
  return _NRBluetoothPacketParserGetSlotCount();
}

uint64_t NRBluetoothPacketParserResetContext()
{
  return _NRBluetoothPacketParserResetContext();
}

uint64_t NRBluetoothPacketParserStart()
{
  return _NRBluetoothPacketParserStart();
}

uint64_t NSAppendPrintF()
{
  return _NSAppendPrintF();
}

uint64_t NSAppendPrintF_safe()
{
  return _NSAppendPrintF_safe();
}

Class NSClassFromString(NSString *aClassName)
{
  return _NSClassFromString(aClassName);
}

uint64_t NSDictionaryGetNSNumber()
{
  return _NSDictionaryGetNSNumber();
}

uint64_t NSErrorF_safe()
{
  return _NSErrorF_safe();
}

uint64_t NSErrorNestedF()
{
  return _NSErrorNestedF();
}

uint64_t NSGetNextSearchPathEnumeration()
{
  return _NSGetNextSearchPathEnumeration();
}

void NSLog(NSString *format, ...)
{
}

uint64_t NSPrintF()
{
  return _NSPrintF();
}

uint64_t NSPrintF_safe()
{
  return _NSPrintF_safe();
}

uint64_t NSRandomData()
{
  return _NSRandomData();
}

NSArray *__cdecl NSSearchPathForDirectoriesInDomains(NSSearchPathDirectory directory, NSSearchPathDomainMask domainMask, BOOL expandTilde)
{
  return _NSSearchPathForDirectoriesInDomains(directory, domainMask, expandTilde);
}

uint64_t NSStartSearchPathEnumerationPrivate()
{
  return _NSStartSearchPathEnumerationPrivate();
}

NSString *__cdecl NSStringFromClass(Class aClass)
{
  return _NSStringFromClass(aClass);
}

NSString *__cdecl NSStringFromSelector(SEL aSelector)
{
  return _NSStringFromSelector(aSelector);
}

uint64_t OPACKDecodeData()
{
  return _OPACKDecodeData();
}

uint64_t OPACKEncoderCreateData()
{
  return _OPACKEncoderCreateData();
}

uint64_t PLLogRegisteredEvent()
{
  return _PLLogRegisteredEvent();
}

uint64_t RTBuddyCrashlogDecode()
{
  return _RTBuddyCrashlogDecode();
}

uint64_t RandomBytes()
{
  return _RandomBytes();
}

uint64_t RandomString()
{
  return _RandomString();
}

CFStringRef SCDynamicStoreCopyComputerName(SCDynamicStoreRef store, CFStringEncoding *nameEncoding)
{
  return _SCDynamicStoreCopyComputerName(store, nameEncoding);
}

CFPropertyListRef SCDynamicStoreCopyValue(SCDynamicStoreRef store, CFStringRef key)
{
  return _SCDynamicStoreCopyValue(store, key);
}

SCDynamicStoreRef SCDynamicStoreCreate(CFAllocatorRef allocator, CFStringRef name, SCDynamicStoreCallBack callout, SCDynamicStoreContext *context)
{
  return _SCDynamicStoreCreate(allocator, name, callout, context);
}

CFStringRef SCDynamicStoreKeyCreateComputerName(CFAllocatorRef allocator)
{
  return _SCDynamicStoreKeyCreateComputerName(allocator);
}

Boolean SCDynamicStoreRemoveValue(SCDynamicStoreRef store, CFStringRef key)
{
  return _SCDynamicStoreRemoveValue(store, key);
}

uint64_t SCDynamicStoreSetDisconnectCallBack()
{
  return _SCDynamicStoreSetDisconnectCallBack();
}

Boolean SCDynamicStoreSetDispatchQueue(SCDynamicStoreRef store, dispatch_queue_t queue)
{
  return _SCDynamicStoreSetDispatchQueue(store, queue);
}

Boolean SCDynamicStoreSetNotificationKeys(SCDynamicStoreRef store, CFArrayRef keys, CFArrayRef patterns)
{
  return _SCDynamicStoreSetNotificationKeys(store, keys, patterns);
}

Boolean SCDynamicStoreSetValue(SCDynamicStoreRef store, CFStringRef key, CFPropertyListRef value)
{
  return _SCDynamicStoreSetValue(store, key, value);
}

int SCError(void)
{
  return _SCError();
}

const char *__cdecl SCErrorString(int status)
{
  return _SCErrorString(status);
}

SCNetworkInterfaceRef SCNetworkInterfaceGetInterface(SCNetworkInterfaceRef interface)
{
  return _SCNetworkInterfaceGetInterface(interface);
}

CFDictionaryRef SCNetworkProtocolGetConfiguration(SCNetworkProtocolRef protocol)
{
  return _SCNetworkProtocolGetConfiguration(protocol);
}

Boolean SCNetworkProtocolSetConfiguration(SCNetworkProtocolRef protocol, CFDictionaryRef config)
{
  return _SCNetworkProtocolSetConfiguration(protocol, config);
}

Boolean SCNetworkServiceAddProtocolType(SCNetworkServiceRef service, CFStringRef protocolType)
{
  return _SCNetworkServiceAddProtocolType(service, protocolType);
}

CFArrayRef SCNetworkServiceCopyAll(SCPreferencesRef prefs)
{
  return _SCNetworkServiceCopyAll(prefs);
}

SCNetworkProtocolRef SCNetworkServiceCopyProtocol(SCNetworkServiceRef service, CFStringRef protocolType)
{
  return _SCNetworkServiceCopyProtocol(service, protocolType);
}

SCNetworkInterfaceRef SCNetworkServiceGetInterface(SCNetworkServiceRef service)
{
  return _SCNetworkServiceGetInterface(service);
}

Boolean SCNetworkSetAddService(SCNetworkSetRef set, SCNetworkServiceRef service)
{
  return _SCNetworkSetAddService(set, service);
}

CFArrayRef SCNetworkSetCopyAll(SCPreferencesRef prefs)
{
  return _SCNetworkSetCopyAll(prefs);
}

SCNetworkSetRef SCNetworkSetCopyCurrent(SCPreferencesRef prefs)
{
  return _SCNetworkSetCopyCurrent(prefs);
}

CFArrayRef SCNetworkSetCopyServices(SCNetworkSetRef set)
{
  return _SCNetworkSetCopyServices(set);
}

uint64_t SCNetworkSetEstablishDefaultInterfaceConfiguration()
{
  return _SCNetworkSetEstablishDefaultInterfaceConfiguration();
}

Boolean SCPreferencesApplyChanges(SCPreferencesRef prefs)
{
  return _SCPreferencesApplyChanges(prefs);
}

Boolean SCPreferencesCommitChanges(SCPreferencesRef prefs)
{
  return _SCPreferencesCommitChanges(prefs);
}

SCPreferencesRef SCPreferencesCreate(CFAllocatorRef allocator, CFStringRef name, CFStringRef prefsID)
{
  return _SCPreferencesCreate(allocator, name, prefsID);
}

SCPreferencesRef SCPreferencesCreateWithAuthorization(CFAllocatorRef allocator, CFStringRef name, CFStringRef prefsID, AuthorizationRef authorization)
{
  return _SCPreferencesCreateWithAuthorization(allocator, name, prefsID, authorization);
}

uint64_t SCPreferencesGetHostName()
{
  return _SCPreferencesGetHostName();
}

CFPropertyListRef SCPreferencesGetValue(SCPreferencesRef prefs, CFStringRef key)
{
  return _SCPreferencesGetValue(prefs, key);
}

Boolean SCPreferencesLock(SCPreferencesRef prefs, Boolean wait)
{
  return _SCPreferencesLock(prefs, wait);
}

Boolean SCPreferencesSetCallback(SCPreferencesRef prefs, SCPreferencesCallBack callout, SCPreferencesContext *context)
{
  return _SCPreferencesSetCallback(prefs, callout, context);
}

Boolean SCPreferencesSetDispatchQueue(SCPreferencesRef prefs, dispatch_queue_t queue)
{
  return _SCPreferencesSetDispatchQueue(prefs, queue);
}

void SCPreferencesSynchronize(SCPreferencesRef prefs)
{
}

Boolean SCPreferencesUnlock(SCPreferencesRef prefs)
{
  return _SCPreferencesUnlock(prefs);
}

OSStatus SecItemAdd(CFDictionaryRef attributes, CFTypeRef *result)
{
  return _SecItemAdd(attributes, result);
}

OSStatus SecItemCopyMatching(CFDictionaryRef query, CFTypeRef *result)
{
  return _SecItemCopyMatching(query, result);
}

OSStatus SecItemDelete(CFDictionaryRef query)
{
  return _SecItemDelete(query);
}

OSStatus SecItemUpdate(CFDictionaryRef query, CFDictionaryRef attributesToUpdate)
{
  return _SecItemUpdate(query, attributesToUpdate);
}

CFStringRef SecTaskCopySigningIdentifier(SecTaskRef task, CFErrorRef *error)
{
  return _SecTaskCopySigningIdentifier(task, error);
}

SecTaskRef SecTaskCreateWithAuditToken(CFAllocatorRef allocator, audit_token_t *token)
{
  return _SecTaskCreateWithAuditToken(allocator, token);
}

uint64_t SipHash()
{
  return _SipHash();
}

uint64_t TCCAccessCopyBundleIdentifiersDisabledForService()
{
  return _TCCAccessCopyBundleIdentifiersDisabledForService();
}

uint64_t TCCAccessCopyBundleIdentifiersForService()
{
  return _TCCAccessCopyBundleIdentifiersForService();
}

uint64_t TMGetReferenceTime()
{
  return _TMGetReferenceTime();
}

uint64_t TMIsAutomaticTimeEnabled()
{
  return _TMIsAutomaticTimeEnabled();
}

uint64_t TextToHardwareAddress()
{
  return _TextToHardwareAddress();
}

uint64_t UpTicksToMilliseconds()
{
  return _UpTicksToMilliseconds();
}

uint64_t UpTicksToSeconds()
{
  return _UpTicksToSeconds();
}

uint64_t UpTicksToSecondsF()
{
  return _UpTicksToSecondsF();
}

uint64_t WiFiDeviceClientCopyCurrentNetwork()
{
  return _WiFiDeviceClientCopyCurrentNetwork();
}

uint64_t WiFiDeviceClientGetPower()
{
  return _WiFiDeviceClientGetPower();
}

uint64_t WiFiDeviceClientRegister24GHzNetworkInCriticalStateCallback()
{
  return _WiFiDeviceClientRegister24GHzNetworkInCriticalStateCallback();
}

uint64_t WiFiDeviceClientRegisterBssidChangeCallback()
{
  return _WiFiDeviceClientRegisterBssidChangeCallback();
}

uint64_t WiFiDeviceClientRegisterExtendedLinkCallback()
{
  return _WiFiDeviceClientRegisterExtendedLinkCallback();
}

uint64_t WiFiDeviceClientRegisterM1M4Handshake24GHzCountCallback()
{
  return _WiFiDeviceClientRegisterM1M4Handshake24GHzCountCallback();
}

uint64_t WiFiDeviceClientRegisterPowerCallback()
{
  return _WiFiDeviceClientRegisterPowerCallback();
}

uint64_t WiFiDeviceClientRegisterVirtualInterfaceStateChangeCallback()
{
  return _WiFiDeviceClientRegisterVirtualInterfaceStateChangeCallback();
}

uint64_t WiFiManagerClientCopyDevices()
{
  return _WiFiManagerClientCopyDevices();
}

uint64_t WiFiManagerClientCreate()
{
  return _WiFiManagerClientCreate();
}

uint64_t WiFiManagerClientScheduleWithRunLoop()
{
  return _WiFiManagerClientScheduleWithRunLoop();
}

uint64_t WiFiNetworkGetOperatingBand()
{
  return _WiFiNetworkGetOperatingBand();
}

uint64_t WriteStackshotReport_stdc()
{
  return _WriteStackshotReport_stdc();
}

void *__cdecl _Block_copy(const void *aBlock)
{
  return __Block_copy(aBlock);
}

void _Block_object_dispose(const void *a1, const int a2)
{
}

void _Block_release(const void *aBlock)
{
}

uint64_t _CFCopySystemVersionDictionary()
{
  return __CFCopySystemVersionDictionary();
}

uint64_t _CFPreferencesCopyKeyListWithContainer()
{
  return __CFPreferencesCopyKeyListWithContainer();
}

uint64_t _CFPreferencesSetDaemonCacheEnabled()
{
  return __CFPreferencesSetDaemonCacheEnabled();
}

uint64_t _CFXPCCreateCFObjectFromXPCMessage()
{
  return __CFXPCCreateCFObjectFromXPCMessage();
}

uint64_t _CFXPCCreateCFObjectFromXPCObject()
{
  return __CFXPCCreateCFObjectFromXPCObject();
}

uint64_t _CFXPCCreateXPCMessageWithCFObject()
{
  return __CFXPCCreateXPCMessageWithCFObject();
}

uint64_t _CFXPCCreateXPCObjectFromCFObject()
{
  return __CFXPCCreateXPCObjectFromCFObject();
}

uint64_t _CTServerConnectionCopyCellularTransmitState()
{
  return __CTServerConnectionCopyCellularTransmitState();
}

uint64_t _CTServerConnectionCopyISOForMCC()
{
  return __CTServerConnectionCopyISOForMCC();
}

uint64_t _CTServerConnectionCopyMobileEquipmentInfo()
{
  return __CTServerConnectionCopyMobileEquipmentInfo();
}

uint64_t _CTServerConnectionCopySystemCapabilities()
{
  return __CTServerConnectionCopySystemCapabilities();
}

uint64_t _CTServerConnectionCreateOnTargetQueue()
{
  return __CTServerConnectionCreateOnTargetQueue();
}

uint64_t _CTServerConnectionEchoCancelationAndNoiseReduction()
{
  return __CTServerConnectionEchoCancelationAndNoiseReduction();
}

uint64_t _CTServerConnectionGetNetworkSelectionMode()
{
  return __CTServerConnectionGetNetworkSelectionMode();
}

uint64_t _CTServerConnectionRegisterBlockForNotification()
{
  return __CTServerConnectionRegisterBlockForNotification();
}

uint64_t _CTServerConnectionUnregisterForAllNotifications()
{
  return __CTServerConnectionUnregisterForAllNotifications();
}

uint64_t _LogCategory_Initialize()
{
  return __LogCategory_Initialize();
}

uint64_t _NETRBClientAddHost()
{
  return __NETRBClientAddHost();
}

uint64_t _NETRBClientCreate()
{
  return __NETRBClientCreate();
}

uint64_t _NETRBClientDestroy()
{
  return __NETRBClientDestroy();
}

uint64_t _NETRBClientIsAllowedMoreHost()
{
  return __NETRBClientIsAllowedMoreHost();
}

uint64_t _NETRBClientRemoveHost()
{
  return __NETRBClientRemoveHost();
}

uint64_t _NETRBClientSetHostCount()
{
  return __NETRBClientSetHostCount();
}

uint64_t _NETRBClientStartService()
{
  return __NETRBClientStartService();
}

uint64_t _NETRBClientStopService()
{
  return __NETRBClientStopService();
}

uint64_t _SCNetworkInterfaceCreateWithIONetworkInterfaceObject()
{
  return __SCNetworkInterfaceCreateWithIONetworkInterfaceObject();
}

void _Unwind_Resume(_Unwind_Exception *exception_object)
{
}

std::string::size_type std::string::copy(const std::string *this, std::string::value_type *__s, std::string::size_type __n, std::string::size_type __pos)
{
  return std::string::copy(this, __s, __n, __pos);
}

std::string::size_type std::string::find(const std::string *this, std::string::value_type __c, std::string::size_type __pos)
{
  return std::string::find(this, __c, __pos);
}

std::string::size_type std::string::rfind(const std::string *this, std::string::value_type __c, std::string::size_type __pos)
{
  return std::string::rfind(this, __c, __pos);
}

int std::string::compare(const std::string *this, const std::string::value_type *__s)
{
  return std::string::compare(this, __s);
}

int std::string::compare(const std::string *this, std::string::size_type __pos1, std::string::size_type __n1, const std::string::value_type *__s)
{
  return std::string::compare(this, __pos1, __n1, __s);
}

int std::string::compare(const std::string *this, std::string::size_type __pos1, std::string::size_type __n1, const std::string *__str, std::string::size_type __pos2, std::string::size_type __n2)
{
  return std::string::compare(this, __pos1, __n1, __str, __pos2, __n2);
}

uint64_t std::stringbuf::str()
{
  return std::stringbuf::str();
}

const std::locale::facet *__cdecl std::locale::use_facet(const std::locale *this, std::locale::id *a2)
{
  return std::locale::use_facet(this, a2);
}

std::locale std::ios_base::getloc(const std::ios_base *this)
{
  return std::ios_base::getloc(this);
}

size_t std::__next_prime(size_t __n)
{
  return std::__next_prime(__n);
}

std::string *__cdecl std::string::erase(std::string *this, std::string::size_type __pos, std::string::size_type __n)
{
  return std::string::erase(this, __pos, __n);
}

std::string *__cdecl std::string::append(std::string *this, const std::string::value_type *__s)
{
  return std::string::append(this, __s);
}

std::string *__cdecl std::string::append(std::string *this, const std::string::value_type *__s, std::string::size_type __n)
{
  return std::string::append(this, __s, __n);
}

std::string *__cdecl std::string::assign(std::string *this, const std::string::value_type *__s)
{
  return std::string::assign(this, __s);
}

std::string *__cdecl std::string::insert(std::string *this, std::string::size_type __pos, const std::string::value_type *__s)
{
  return std::string::insert(this, __pos, __s);
}

std::string *__cdecl std::string::insert(std::string *this, std::string::size_type __pos, const std::string::value_type *__s, std::string::size_type __n)
{
  return std::string::insert(this, __pos, __s, __n);
}

std::string *__cdecl std::string::insert(std::string *this, std::string::size_type __pos, std::string::size_type __n, std::string::value_type __c)
{
  return std::string::insert(this, __pos, __n, __c);
}

void std::string::resize(std::string *this, std::string::size_type __n, std::string::value_type __c)
{
}

std::string *__cdecl std::string::replace(std::string *this, std::string::size_type __pos, std::string::size_type __n1, const std::string::value_type *__s, std::string::size_type __n2)
{
  return std::string::replace(this, __pos, __n1, __s, __n2);
}

void std::string::push_back(std::string *this, std::string::value_type __c)
{
}

std::string *__cdecl std::string::basic_string(std::string *this, const std::string *__str, std::string::size_type __pos, std::string::size_type __n, std::allocator<char> *__a)
{
  return std::string::basic_string(this, __str, __pos, __n, __a);
}

std::string *__cdecl std::string::operator=(std::string *this, const std::string *__str)
{
  return std::string::operator=(this, __str);
}

uint64_t std::filebuf::open()
{
  return std::filebuf::open();
}

uint64_t std::filebuf::close()
{
  return std::filebuf::close();
}

uint64_t std::filebuf::basic_filebuf()
{
  return std::filebuf::basic_filebuf();
}

uint64_t std::filebuf::~filebuf()
{
  return std::filebuf::~filebuf();
}

uint64_t std::istream::read()
{
  return std::istream::read();
}

uint64_t std::istream::seekg()
{
  return std::istream::seekg();
}

uint64_t std::istream::tellg()
{
  return std::istream::tellg();
}

uint64_t std::istream::sentry::sentry()
{
  return std::istream::sentry::sentry();
}

uint64_t std::istream::~istream()
{
  return std::istream::~istream();
}

uint64_t std::ostream::put()
{
  return std::ostream::put();
}

uint64_t std::ostream::flush()
{
  return std::ostream::flush();
}

uint64_t std::ostream::sentry::sentry()
{
  return std::ostream::sentry::sentry();
}

uint64_t std::ostream::sentry::~sentry()
{
  return std::ostream::sentry::~sentry();
}

uint64_t std::ostream::~ostream()
{
  return std::ostream::~ostream();
}

uint64_t std::ostream::operator<<()
{
  return std::ostream::operator<<();
}

{
  return std::ostream::operator<<();
}

{
  return std::ostream::operator<<();
}

{
  return std::ostream::operator<<();
}

{
  return std::ostream::operator<<();
}

{
  return std::ostream::operator<<();
}

{
  return std::ostream::operator<<();
}

{
  return std::ostream::operator<<();
}

{
  return std::ostream::operator<<();
}

{
  return std::ostream::operator<<();
}

uint64_t std::iostream::~basic_iostream()
{
  return std::iostream::~basic_iostream();
}

uint64_t std::streambuf::basic_streambuf()
{
  return std::streambuf::basic_streambuf();
}

uint64_t std::streambuf::~streambuf()
{
  return std::streambuf::~streambuf();
}

void std::__shared_weak_count::__release_weak(std::__shared_weak_count *this)
{
}

std::__shared_weak_count *__cdecl std::__shared_weak_count::lock(std::__shared_weak_count *this)
{
  return std::__shared_weak_count::lock(this);
}

void std::__shared_weak_count::~__shared_weak_count(std::__shared_weak_count *this)
{
}

void std::__libcpp_verbose_abort(const char *__format, ...)
{
}

void std::mutex::lock(std::mutex *this)
{
}

void std::mutex::unlock(std::mutex *this)
{
}

void std::mutex::~mutex(std::mutex *this)
{
}

unint64_t std::stoul(const std::string *__str, size_t *__idx, int __base)
{
  return std::stoul(__str, __idx, __base);
}

uint64_t std::__sort<std::__less<int,int> &,int *>()
{
  return std::__sort<std::__less<int,int> &,int *>();
}

void std::locale::~locale(std::locale *this)
{
}

unint64_t std::stoull(const std::string *__str, size_t *__idx, int __base)
{
  return std::stoull(__str, __idx, __base);
}

void std::ios_base::init(std::ios_base *this, void *__sb)
{
}

void std::ios_base::clear(std::ios_base *this, std::ios_base::iostate __state)
{
}

uint64_t std::ios::~ios()
{
  return std::ios::~ios();
}

std::string *__cdecl std::to_string(std::string *__return_ptr retstr, int __val)
{
  return std::to_string(retstr, __val);
}

std::string *__cdecl std::to_string(std::string *__return_ptr retstr, unsigned int __val)
{
  return std::to_string(retstr, __val);
}

std::string *__cdecl std::to_string(std::string *__return_ptr retstr, unint64_t __val)
{
  return std::to_string(retstr, __val);
}

uint64_t std::operator+<char>()
{
  return std::operator+<char>();
}

void std::terminate(void)
{
}

void operator delete[]()
{
  while (1)
    ;
}

void operator delete(void *__p)
{
  while (1)
    ;
}

void operator delete()
{
  while (1)
    ;
}

void operator new[]()
{
  while (1)
    ;
}

void *__cdecl operator new(size_t __sz)
{
  while (1)
    ;
}

void operator new()
{
  while (1)
    ;
}

void __assert_rtn(const char *a1, const char *a2, int a3, const char *a4)
{
}

int __cxa_atexit(void (*lpfunc)(void *), void *obj, void *lpdso_handle)
{
  return ___cxa_atexit(lpfunc, obj, lpdso_handle);
}

void *__cxa_begin_catch(void *a1)
{
  return ___cxa_begin_catch(a1);
}

void __cxa_guard_abort(__guard *a1)
{
}

int __cxa_guard_acquire(__guard *a1)
{
  return ___cxa_guard_acquire((uint64_t *)a1);
}

void __cxa_guard_release(__guard *a1)
{
}

int __darwin_check_fd_set_overflow(int a1, const void *a2, int a3)
{
  return ___darwin_check_fd_set_overflow(a1, a2, a3);
}

int *__error(void)
{
  return ___error();
}

double __exp10(double a1)
{
  return ___exp10(a1);
}

int __maskrune(__darwin_ct_rune_t a1, unint64_t a2)
{
  return ___maskrune(a1, a2);
}

uint64_t __memcpy_chk()
{
  return ___memcpy_chk();
}

uint64_t __memmove_chk()
{
  return ___memmove_chk();
}

uint64_t __memset_chk()
{
  return ___memset_chk();
}

int __sprintf_chk(char *a1, int a2, size_t a3, const char *a4, ...)
{
  return ___sprintf_chk(a1, a2, a3, a4);
}

uint64_t __strcat_chk()
{
  return ___strcat_chk();
}

uint64_t __strlcat_chk()
{
  return ___strlcat_chk();
}

uint64_t __strlcpy_chk()
{
  return ___strlcpy_chk();
}

uint64_t __strncpy_chk()
{
  return ___strncpy_chk();
}

__darwin_ct_rune_t __tolower(__darwin_ct_rune_t a1)
{
  return ___tolower(a1);
}

__darwin_ct_rune_t __toupper(__darwin_ct_rune_t a1)
{
  return ___toupper(a1);
}

void _exit(int a1)
{
}

uint64_t _os_feature_enabled_impl()
{
  return __os_feature_enabled_impl();
}

void _os_log_debug_impl(void *dso, os_log_t log, os_log_type_t type, const char *format, uint8_t *buf, uint32_t size)
{
}

void _os_log_error_impl(void *dso, os_log_t log, os_log_type_t type, const char *format, uint8_t *buf, uint32_t size)
{
}

void _os_log_fault_impl(void *dso, os_log_t log, os_log_type_t type, const char *format, uint8_t *buf, uint32_t size)
{
}

void _os_log_impl(void *dso, os_log_t log, os_log_type_t type, const char *format, uint8_t *buf, uint32_t size)
{
}

uint64_t _os_log_pack_fill()
{
  return __os_log_pack_fill();
}

uint64_t _os_log_pack_size()
{
  return __os_log_pack_size();
}

void _os_signpost_emit_with_name_impl(void *dso, os_log_t log, os_signpost_type_t type, os_signpost_id_t spid, const char *name, const char *format, uint8_t *buf, uint32_t size)
{
}

uint64_t _set_user_dir_suffix()
{
  return __set_user_dir_suffix();
}

uint64_t _sl_dlopen()
{
  return __sl_dlopen();
}

void abort(void)
{
}

uint64_t abort_with_payload()
{
  return _abort_with_payload();
}

uint64_t acc_transportClient_copyPropertiesForEndpointWithUUID()
{
  return _acc_transportClient_copyPropertiesForEndpointWithUUID();
}

uint64_t acc_transportClient_createConnection()
{
  return _acc_transportClient_createConnection();
}

uint64_t acc_transportClient_createEndpoint()
{
  return _acc_transportClient_createEndpoint();
}

uint64_t acc_transportClient_destroyConnection()
{
  return _acc_transportClient_destroyConnection();
}

uint64_t acc_transportClient_isConnectionAuthenticated()
{
  return _acc_transportClient_isConnectionAuthenticated();
}

uint64_t acc_transportClient_processIncomingData()
{
  return _acc_transportClient_processIncomingData();
}

uint64_t acc_transportClient_publishConnection()
{
  return _acc_transportClient_publishConnection();
}

uint64_t acc_transportClient_setAccessoryInfo()
{
  return _acc_transportClient_setAccessoryInfo();
}

uint64_t acc_transportClient_setConnectionAuthStatusDidChangeHandler()
{
  return _acc_transportClient_setConnectionAuthStatusDidChangeHandler();
}

uint64_t acc_transportClient_setEndpointPropertiesDidChangeHandler()
{
  return _acc_transportClient_setEndpointPropertiesDidChangeHandler();
}

uint64_t acc_transportClient_setEndpointPropertyDidChangeHandler()
{
  return _acc_transportClient_setEndpointPropertyDidChangeHandler();
}

uint64_t acc_transportClient_setPropertyForConnectionWithUUID()
{
  return _acc_transportClient_setPropertyForConnectionWithUUID();
}

uint64_t acc_transportClient_setPropertyForEndpointWithUUID()
{
  return _acc_transportClient_setPropertyForEndpointWithUUID();
}

int access(const char *a1, int a2)
{
  return _access(a1, a2);
}

uint32_t arc4random(void)
{
  return _arc4random();
}

void arc4random_buf(void *__buf, size_t __nbytes)
{
}

uint32_t arc4random_uniform(uint32_t __upper_bound)
{
  return _arc4random_uniform(__upper_bound);
}

int asprintf(char **a1, const char *a2, ...)
{
  return _asprintf(a1, a2);
}

int atoi(const char *a1)
{
  return _atoi(a1);
}

uint64_t atol(const char *a1)
{
  return _atol(a1);
}

void bzero(void *a1, size_t a2)
{
}

uint64_t cc_clear()
{
  return _cc_clear();
}

uint64_t ccaes_ecb_decrypt_mode()
{
  return _ccaes_ecb_decrypt_mode();
}

uint64_t ccaes_ecb_encrypt_mode()
{
  return _ccaes_ecb_encrypt_mode();
}

uint64_t ccaes_siv_decrypt_mode()
{
  return _ccaes_siv_decrypt_mode();
}

uint64_t ccaes_siv_encrypt_mode()
{
  return _ccaes_siv_encrypt_mode();
}

uint64_t ccdigest()
{
  return _ccdigest();
}

uint64_t ccec_cp_256()
{
  return _ccec_cp_256();
}

uint64_t ccec_generate_key()
{
  return _ccec_generate_key();
}

uint64_t ccec_make_priv()
{
  return _ccec_make_priv();
}

uint64_t ccec_make_pub()
{
  return _ccec_make_pub();
}

uint64_t ccec_x963_export()
{
  return _ccec_x963_export();
}

uint64_t ccecb_context_size()
{
  return _ccecb_context_size();
}

uint64_t ccecb_init()
{
  return _ccecb_init();
}

uint64_t ccecb_one_shot()
{
  return _ccecb_one_shot();
}

uint64_t ccecdh_compute_shared_secret()
{
  return _ccecdh_compute_shared_secret();
}

uint64_t cclr_aes_init()
{
  return _cclr_aes_init();
}

uint64_t cclr_encrypt_block()
{
  return _cclr_encrypt_block();
}

uint64_t ccrng()
{
  return _ccrng();
}

uint64_t ccsha256_di()
{
  return _ccsha256_di();
}

uint64_t ccsiv_ciphertext_size()
{
  return _ccsiv_ciphertext_size();
}

uint64_t ccsiv_one_shot()
{
  return _ccsiv_one_shot();
}

uint64_t ccsiv_plaintext_size()
{
  return _ccsiv_plaintext_size();
}

uint64_t cczp_bitlen()
{
  return _cczp_bitlen();
}

void cfmakeraw(termios *a1)
{
}

int cfsetspeed(termios *a1, speed_t a2)
{
  return _cfsetspeed(a1, a2);
}

int chdir(const char *a1)
{
  return _chdir(a1);
}

int chmod(const char *a1, mode_t a2)
{
  return _chmod(a1, a2);
}

__uint64_t clock_gettime_nsec_np(clockid_t __clock_id)
{
  return _clock_gettime_nsec_np(__clock_id);
}

int close(int a1)
{
  return _close(a1);
}

int closedir(DIR *a1)
{
  return _closedir(a1);
}

size_t confstr(int a1, char *a2, size_t a3)
{
  return _confstr(a1, a2, a3);
}

int connect(int a1, const sockaddr *a2, socklen_t a3)
{
  return _connect(a1, a2, a3);
}

uint64_t container_system_group_path_for_identifier()
{
  return _container_system_group_path_for_identifier();
}

uint64_t ct_green_tea_logger_create()
{
  return _ct_green_tea_logger_create();
}

char *__cdecl ctime(const time_t *a1)
{
  return _ctime(a1);
}

void dispatch_activate(dispatch_object_t object)
{
}

void dispatch_after(dispatch_time_t when, dispatch_queue_t queue, dispatch_block_t block)
{
}

void dispatch_after_f(dispatch_time_t when, dispatch_queue_t queue, void *context, dispatch_function_t work)
{
}

void dispatch_assert_queue_V2(dispatch_queue_t queue)
{
}

void dispatch_async(dispatch_queue_t queue, dispatch_block_t block)
{
}

void dispatch_async_and_wait(dispatch_queue_t queue, dispatch_block_t block)
{
}

void dispatch_async_f(dispatch_queue_t queue, void *context, dispatch_function_t work)
{
}

void dispatch_block_cancel(dispatch_block_t block)
{
}

dispatch_block_t dispatch_block_create(dispatch_block_flags_t flags, dispatch_block_t block)
{
  return _dispatch_block_create(flags, block);
}

dispatch_block_t dispatch_block_create_with_qos_class(dispatch_block_flags_t flags, dispatch_qos_class_t qos_class, int relative_priority, dispatch_block_t block)
{
  return _dispatch_block_create_with_qos_class(flags, qos_class, relative_priority, block);
}

dispatch_data_t dispatch_data_create(const void *buffer, size_t size, dispatch_queue_t queue, dispatch_block_t destructor)
{
  return _dispatch_data_create(buffer, size, queue, destructor);
}

void *__cdecl dispatch_get_context(dispatch_object_t object)
{
  return _dispatch_get_context(object);
}

dispatch_queue_global_t dispatch_get_global_queue(intptr_t identifier, uintptr_t flags)
{
  return _dispatch_get_global_queue(identifier, flags);
}

dispatch_group_t dispatch_group_create(void)
{
  return _dispatch_group_create();
}

void dispatch_group_enter(dispatch_group_t group)
{
}

void dispatch_group_leave(dispatch_group_t group)
{
}

void dispatch_group_notify(dispatch_group_t group, dispatch_queue_t queue, dispatch_block_t block)
{
}

intptr_t dispatch_group_wait(dispatch_group_t group, dispatch_time_t timeout)
{
  return _dispatch_group_wait(group, timeout);
}

void dispatch_once(dispatch_once_t *predicate, dispatch_block_t block)
{
}

uint64_t dispatch_pthread_root_queue_create()
{
  return _dispatch_pthread_root_queue_create();
}

dispatch_queue_attr_t dispatch_queue_attr_make_with_autorelease_frequency(dispatch_queue_attr_t attr, dispatch_autorelease_frequency_t frequency)
{
  return _dispatch_queue_attr_make_with_autorelease_frequency(attr, frequency);
}

dispatch_queue_attr_t dispatch_queue_attr_make_with_qos_class(dispatch_queue_attr_t attr, dispatch_qos_class_t qos_class, int relative_priority)
{
  return _dispatch_queue_attr_make_with_qos_class(attr, qos_class, relative_priority);
}

dispatch_queue_t dispatch_queue_create(const char *label, dispatch_queue_attr_t attr)
{
  return _dispatch_queue_create(label, attr);
}

dispatch_queue_t dispatch_queue_create_with_target_V2(const char *label, dispatch_queue_attr_t attr, dispatch_queue_t target)
{
  return _dispatch_queue_create_with_target_V2(label, attr, target);
}

const char *__cdecl dispatch_queue_get_label(dispatch_queue_t queue)
{
  return _dispatch_queue_get_label(queue);
}

dispatch_qos_class_t dispatch_queue_get_qos_class(dispatch_queue_t queue, int *relative_priority_ptr)
{
  return _dispatch_queue_get_qos_class(queue, relative_priority_ptr);
}

void dispatch_release(dispatch_object_t object)
{
}

void dispatch_resume(dispatch_object_t object)
{
}

void dispatch_retain(dispatch_object_t object)
{
}

dispatch_semaphore_t dispatch_semaphore_create(intptr_t value)
{
  return _dispatch_semaphore_create(value);
}

intptr_t dispatch_semaphore_signal(dispatch_semaphore_t dsema)
{
  return _dispatch_semaphore_signal(dsema);
}

intptr_t dispatch_semaphore_wait(dispatch_semaphore_t dsema, dispatch_time_t timeout)
{
  return _dispatch_semaphore_wait(dsema, timeout);
}

void dispatch_set_context(dispatch_object_t object, void *context)
{
}

void dispatch_set_finalizer_f(dispatch_object_t object, dispatch_function_t finalizer)
{
}

void dispatch_source_cancel(dispatch_source_t source)
{
}

dispatch_source_t dispatch_source_create(dispatch_source_type_t type, uintptr_t handle, uintptr_t mask, dispatch_queue_t queue)
{
  return _dispatch_source_create(type, handle, mask, queue);
}

uintptr_t dispatch_source_get_data(dispatch_source_t source)
{
  return _dispatch_source_get_data(source);
}

void dispatch_source_set_cancel_handler(dispatch_source_t source, dispatch_block_t handler)
{
}

void dispatch_source_set_event_handler(dispatch_source_t source, dispatch_block_t handler)
{
}

void dispatch_source_set_event_handler_f(dispatch_source_t source, dispatch_function_t handler)
{
}

void dispatch_source_set_timer(dispatch_source_t source, dispatch_time_t start, uint64_t interval, uint64_t leeway)
{
}

void dispatch_suspend(dispatch_object_t object)
{
}

void dispatch_sync(dispatch_queue_t queue, dispatch_block_t block)
{
}

dispatch_time_t dispatch_time(dispatch_time_t when, int64_t delta)
{
  return _dispatch_time(when, delta);
}

dispatch_time_t dispatch_walltime(const timespec *when, int64_t delta)
{
  return _dispatch_walltime(when, delta);
}

dispatch_workloop_t dispatch_workloop_create(const char *label)
{
  return _dispatch_workloop_create(label);
}

char *dlerror(void)
{
  return _dlerror();
}

void *__cdecl dlsym(void *__handle, const char *__symbol)
{
  return _dlsym(__handle, __symbol);
}

int dprintf(int a1, const char *a2, ...)
{
  return _dprintf(a1, a2);
}

void errx(int a1, const char *a2, ...)
{
}

void exit(int a1)
{
}

int fclose(FILE *a1)
{
  return _fclose(a1);
}

int fcntl(int a1, int a2, ...)
{
  return _fcntl(a1, a2);
}

int feof(FILE *a1)
{
  return _feof(a1);
}

int ferror(FILE *a1)
{
  return _ferror(a1);
}

FILE *__cdecl fopen(const char *__filename, const char *__mode)
{
  return _fopen(__filename, __mode);
}

int fprintf(FILE *a1, const char *a2, ...)
{
  return _fprintf(a1, a2);
}

int fputc(int a1, FILE *a2)
{
  return _fputc(a1, a2);
}

size_t fread(void *__ptr, size_t __size, size_t __nitems, FILE *__stream)
{
  return _fread(__ptr, __size, __nitems, __stream);
}

void free(void *a1)
{
}

size_t fwrite(const void *__ptr, size_t __size, size_t __nitems, FILE *__stream)
{
  return _fwrite(__ptr, __size, __nitems, __stream);
}

char *__cdecl gcvt(double a1, int a2, char *a3)
{
  return _gcvt(a1, a2, a3);
}

uint64_t getCTGreenTeaOsLogHandle()
{
  return _getCTGreenTeaOsLogHandle();
}

char *__cdecl getenv(const char *a1)
{
  return _getenv(a1);
}

pid_t getpid(void)
{
  return _getpid();
}

int getsockopt(int a1, int a2, int a3, void *a4, socklen_t *a5)
{
  return _getsockopt(a1, a2, a3, a4, a5);
}

int gettimeofday(timeval *a1, void *a2)
{
  return _gettimeofday(a1, a2);
}

tm *__cdecl gmtime(const time_t *a1)
{
  return _gmtime(a1);
}

kern_return_t host_get_special_port(host_priv_t host_priv, int node, int which, mach_port_t *port)
{
  return _host_get_special_port(host_priv, node, which, port);
}

kern_return_t host_request_notification(host_t host, host_flavor_t notify_type, mach_port_t notify_port)
{
  return _host_request_notification(host, notify_type, notify_port);
}

size_t iconv(iconv_t a1, char **a2, size_t *a3, char **a4, size_t *a5)
{
  return _iconv(a1, a2, a3, a4, a5);
}

int iconv_close(iconv_t a1)
{
  return _iconv_close(a1);
}

iconv_t iconv_open(const char *a1, const char *a2)
{
  return _iconv_open(a1, a2);
}

int ioctl(int a1, unint64_t a2, ...)
{
  return _ioctl(a1, a2);
}

uint64_t kdebug_trace()
{
  return _kdebug_trace();
}

int kevent(int kq, const kevent *changelist, int nchanges, kevent *eventlist, int nevents, const timespec *timeout)
{
  return _kevent(kq, changelist, nchanges, eventlist, nevents, timeout);
}

int kqueue(void)
{
  return _kqueue();
}

tm *__cdecl localtime(const time_t *a1)
{
  return _localtime(a1);
}

tm *__cdecl localtime_r(const time_t *a1, tm *a2)
{
  return _localtime_r(a1, a2);
}

uint64_t lockdown_checkin_xpc()
{
  return _lockdown_checkin_xpc();
}

uint64_t lockdown_disconnect()
{
  return _lockdown_disconnect();
}

uint64_t lockdown_send()
{
  return _lockdown_send();
}

uint64_t mach_absolute_time(void)
{
  return _mach_absolute_time();
}

uint64_t mach_continuous_time(void)
{
  return _mach_continuous_time();
}

mach_port_t mach_host_self(void)
{
  return _mach_host_self();
}

void mach_msg_destroy(mach_msg_header_t *a1)
{
}

mach_msg_return_t mach_msg_receive(mach_msg_header_t *a1)
{
  return _mach_msg_receive(a1);
}

kern_return_t mach_port_allocate(ipc_space_t task, mach_port_right_t right, mach_port_name_t *name)
{
  return _mach_port_allocate(task, right, name);
}

kern_return_t mach_port_deallocate(ipc_space_t task, mach_port_name_t name)
{
  return _mach_port_deallocate(task, name);
}

mach_port_t mach_thread_self(void)
{
  return _mach_thread_self();
}

kern_return_t mach_timebase_info(mach_timebase_info_t info)
{
  return _mach_timebase_info(info);
}

kern_return_t mach_wait_until(uint64_t deadline)
{
  return _mach_wait_until(deadline);
}

malloc_zone_t *__cdecl malloc_create_zone(vm_size_t start_size, unsigned int flags)
{
  return _malloc_create_zone(start_size, flags);
}

void malloc_destroy_zone(malloc_zone_t *zone)
{
}

void malloc_set_zone_name(malloc_zone_t *zone, const char *name)
{
}

void *__cdecl malloc_type_calloc(size_t count, size_t size, malloc_type_id_t type_id)
{
  return _malloc_type_calloc(count, size, type_id);
}

void *__cdecl malloc_type_malloc(size_t size, malloc_type_id_t type_id)
{
  return _malloc_type_malloc(size, type_id);
}

void *__cdecl malloc_type_realloc(void *ptr, size_t size, malloc_type_id_t type_id)
{
  return _malloc_type_realloc(ptr, size, type_id);
}

void *__cdecl malloc_type_zone_calloc(malloc_zone_t *zone, size_t count, size_t size, malloc_type_id_t type_id)
{
  return _malloc_type_zone_calloc(zone, count, size, type_id);
}

void *__cdecl malloc_type_zone_malloc(malloc_zone_t *zone, size_t size, malloc_type_id_t type_id)
{
  return _malloc_type_zone_malloc(zone, size, type_id);
}

void malloc_zone_free(malloc_zone_t *zone, void *ptr)
{
}

int mbr_uid_to_uuid(uid_t uid, uuid_t uu)
{
  return _mbr_uid_to_uuid(uid, uu);
}

void *__cdecl memchr(void *__s, int __c, size_t __n)
{
  return _memchr(__s, __c, __n);
}

int memcmp(const void *__s1, const void *__s2, size_t __n)
{
  return _memcmp(__s1, __s2, __n);
}

void *__cdecl memcpy(void *__dst, const void *__src, size_t __n)
{
  return _memcpy(__dst, __src, __n);
}

void *__cdecl memmove(void *__dst, const void *__src, size_t __len)
{
  return _memmove(__dst, __src, __len);
}

void *__cdecl memset(void *__b, int __c, size_t __len)
{
  return _memset(__b, __c, __len);
}

int mkdir(const char *a1, mode_t a2)
{
  return _mkdir(a1, a2);
}

int munmap(void *a1, size_t a2)
{
  return _munmap(a1, a2);
}

uint32_t notify_cancel(int token)
{
  return _notify_cancel(token);
}

uint32_t notify_get_state(int token, uint64_t *state64)
{
  return _notify_get_state(token, state64);
}

uint32_t notify_post(const char *name)
{
  return _notify_post(name);
}

uint32_t notify_register_check(const char *name, int *out_token)
{
  return _notify_register_check(name, out_token);
}

uint32_t notify_register_dispatch(const char *name, int *out_token, dispatch_queue_t queue, notify_handler_t handler)
{
  return _notify_register_dispatch(name, out_token, queue, handler);
}

uint32_t notify_set_state(int token, uint64_t state64)
{
  return _notify_set_state(token, state64);
}

nw_advertise_descriptor_t nw_advertise_descriptor_create_bonjour_service(const char *name, const char *type, const char *domain)
{
  return _nw_advertise_descriptor_create_bonjour_service(name, type, domain);
}

nw_browse_descriptor_t nw_browse_descriptor_create_bonjour_service(const char *type, const char *domain)
{
  return _nw_browse_descriptor_create_bonjour_service(type, domain);
}

nw_endpoint_t nw_browse_result_copy_endpoint(nw_browse_result_t result)
{
  return _nw_browse_result_copy_endpoint(result);
}

nw_browse_result_change_t nw_browse_result_get_changes(nw_browse_result_t old_result, nw_browse_result_t new_result)
{
  return _nw_browse_result_get_changes(old_result, new_result);
}

void nw_browser_cancel(nw_browser_t browser)
{
}

nw_browser_t nw_browser_create(nw_browse_descriptor_t descriptor, nw_parameters_t parameters)
{
  return _nw_browser_create(descriptor, parameters);
}

void nw_browser_set_browse_results_changed_handler(nw_browser_t browser, nw_browser_browse_results_changed_handler_t handler)
{
}

void nw_browser_set_queue(nw_browser_t browser, dispatch_queue_t queue)
{
}

void nw_browser_set_state_changed_handler(nw_browser_t browser, nw_browser_state_changed_handler_t state_changed_handler)
{
}

void nw_browser_start(nw_browser_t browser)
{
}

void nw_connection_cancel(nw_connection_t connection)
{
}

nw_endpoint_t nw_connection_copy_endpoint(nw_connection_t connection)
{
  return _nw_connection_copy_endpoint(connection);
}

nw_parameters_t nw_connection_copy_parameters(nw_connection_t connection)
{
  return _nw_connection_copy_parameters(connection);
}

nw_protocol_metadata_t nw_connection_copy_protocol_metadata(nw_connection_t connection, nw_protocol_definition_t definition)
{
  return _nw_connection_copy_protocol_metadata(connection, definition);
}

nw_connection_t nw_connection_create(nw_endpoint_t endpoint, nw_parameters_t parameters)
{
  return _nw_connection_create(endpoint, parameters);
}

void nw_connection_receive_message(nw_connection_t connection, nw_connection_receive_completion_t completion)
{
}

void nw_connection_send(nw_connection_t connection, dispatch_data_t content, nw_content_context_t context, BOOL is_complete, nw_connection_send_completion_t completion)
{
}

void nw_connection_set_queue(nw_connection_t connection, dispatch_queue_t queue)
{
}

void nw_connection_set_state_changed_handler(nw_connection_t connection, nw_connection_state_changed_handler_t handler)
{
}

void nw_connection_start(nw_connection_t connection)
{
}

nw_content_context_t nw_content_context_create(const char *context_identifier)
{
  return _nw_content_context_create(context_identifier);
}

BOOL nw_content_context_get_is_final(nw_content_context_t context)
{
  return _nw_content_context_get_is_final(context);
}

void nw_content_context_set_metadata_for_protocol(nw_content_context_t context, nw_protocol_metadata_t protocol_metadata)
{
}

const char *__cdecl nw_endpoint_get_bonjour_service_name(nw_endpoint_t endpoint)
{
  return _nw_endpoint_get_bonjour_service_name(endpoint);
}

const char *__cdecl nw_endpoint_get_hostname(nw_endpoint_t endpoint)
{
  return _nw_endpoint_get_hostname(endpoint);
}

uint16_t nw_endpoint_get_port(nw_endpoint_t endpoint)
{
  return _nw_endpoint_get_port(endpoint);
}

CFErrorRef nw_error_copy_cf_error(nw_error_t error)
{
  return _nw_error_copy_cf_error(error);
}

int nw_error_get_error_code(nw_error_t error)
{
  return _nw_error_get_error_code(error);
}

uint64_t nw_interface_create_with_name()
{
  return _nw_interface_create_with_name();
}

void nw_listener_cancel(nw_listener_t listener)
{
}

nw_listener_t nw_listener_create(nw_parameters_t parameters)
{
  return _nw_listener_create(parameters);
}

void nw_listener_set_advertise_descriptor(nw_listener_t listener, nw_advertise_descriptor_t advertise_descriptor)
{
}

void nw_listener_set_new_connection_handler(nw_listener_t listener, nw_listener_new_connection_handler_t handler)
{
}

void nw_listener_set_queue(nw_listener_t listener, dispatch_queue_t queue)
{
}

void nw_listener_set_state_changed_handler(nw_listener_t listener, nw_listener_state_changed_handler_t handler)
{
}

void nw_listener_start(nw_listener_t listener)
{
}

nw_protocol_stack_t nw_parameters_copy_default_protocol_stack(nw_parameters_t parameters)
{
  return _nw_parameters_copy_default_protocol_stack(parameters);
}

nw_parameters_t nw_parameters_create(void)
{
  return _nw_parameters_create();
}

nw_parameters_t nw_parameters_create_secure_tcp(nw_parameters_configure_protocol_block_t configure_tls, nw_parameters_configure_protocol_block_t configure_tcp)
{
  return _nw_parameters_create_secure_tcp(configure_tls, configure_tcp);
}

void nw_parameters_prohibit_interface(nw_parameters_t parameters, nw_interface_t interface)
{
}

void nw_parameters_require_interface(nw_parameters_t parameters, nw_interface_t interface)
{
}

void nw_parameters_set_include_peer_to_peer(nw_parameters_t parameters, BOOL include_peer_to_peer)
{
}

nw_protocol_definition_t nw_protocol_copy_ws_definition(void)
{
  return _nw_protocol_copy_ws_definition();
}

BOOL nw_protocol_definition_is_equal(nw_protocol_definition_t definition1, nw_protocol_definition_t definition2)
{
  return _nw_protocol_definition_is_equal(definition1, definition2);
}

nw_protocol_definition_t nw_protocol_options_copy_definition(nw_protocol_options_t options)
{
  return _nw_protocol_options_copy_definition(options);
}

void nw_protocol_stack_iterate_application_protocols(nw_protocol_stack_t stack, nw_protocol_stack_iterate_protocols_block_t iterate_block)
{
}

void nw_protocol_stack_prepend_application_protocol(nw_protocol_stack_t stack, nw_protocol_options_t protocol)
{
}

void nw_tcp_options_set_enable_fast_open(nw_protocol_options_t options, BOOL enable_fast_open)
{
}

void nw_tcp_options_set_enable_keepalive(nw_protocol_options_t options, BOOL enable_keepalive)
{
}

void nw_tcp_options_set_keepalive_idle_time(nw_protocol_options_t options, uint32_t keepalive_idle_time)
{
}

void nw_tcp_options_set_no_delay(nw_protocol_options_t options, BOOL no_delay)
{
}

nw_protocol_metadata_t nw_ws_create_metadata(nw_ws_opcode_t opcode)
{
  return _nw_ws_create_metadata(opcode);
}

nw_protocol_options_t nw_ws_create_options(nw_ws_version_t version)
{
  return _nw_ws_create_options(version);
}

nw_ws_response_t nw_ws_metadata_copy_server_response(nw_protocol_metadata_t metadata)
{
  return _nw_ws_metadata_copy_server_response(metadata);
}

void nw_ws_options_add_additional_header(nw_protocol_options_t options, const char *name, const char *value)
{
}

void nw_ws_options_set_auto_reply_ping(nw_protocol_options_t options, BOOL auto_reply_ping)
{
}

void nw_ws_options_set_client_request_handler(nw_protocol_options_t options, dispatch_queue_t client_queue, nw_ws_client_request_handler_t handler)
{
}

BOOL nw_ws_request_enumerate_additional_headers(nw_ws_request_t request, nw_ws_additional_header_enumerator_t enumerator)
{
  return _nw_ws_request_enumerate_additional_headers(request, enumerator);
}

void nw_ws_response_add_additional_header(nw_ws_response_t response, const char *name, const char *value)
{
}

nw_ws_response_t nw_ws_response_create(nw_ws_response_status_t status, const char *selected_subprotocol)
{
  return _nw_ws_response_create(status, selected_subprotocol);
}

BOOL nw_ws_response_enumerate_additional_headers(nw_ws_response_t response, nw_ws_additional_header_enumerator_t enumerator)
{
  return _nw_ws_response_enumerate_additional_headers(response, enumerator);
}

id objc_alloc(Class a1)
{
  return _[a1 alloc];
}

uint64_t objc_alloc_init()
{
  return _objc_alloc_init();
}

id objc_autorelease(id a1)
{
  return _objc_autorelease(a1);
}

{
}

{
}

id objc_autoreleaseReturnValue(id a1)
{
  return _objc_autoreleaseReturnValue(a1);
}

uint64_t objc_claimAutoreleasedReturnValue()
{
  return _objc_claimAutoreleasedReturnValue();
}

void objc_copyWeak(id *to, id *from)
{
}

void objc_destroyWeak(id *location)
{
}

void objc_enumerationMutation(id obj)
{
}

Class objc_getClass(const char *name)
{
  return _objc_getClass(name);
}

id objc_getProperty(id self, SEL _cmd, ptrdiff_t offset, BOOL atomic)
{
  return _objc_getProperty(self, _cmd, offset, atomic);
}

id objc_initWeak(id *location, id val)
{
  return _objc_initWeak(location, val);
}

id objc_loadWeakRetained(id *location)
{
  return _objc_loadWeakRetained(location);
}

id objc_msgSendSuper2(objc_super *a1, SEL a2, ...)
{
  return [super a2];
}

uint64_t objc_opt_class()
{
  return _objc_opt_class();
}

uint64_t objc_opt_isKindOfClass()
{
  return _objc_opt_isKindOfClass();
}

uint64_t objc_opt_new()
{
  return _objc_opt_new();
}

uint64_t objc_opt_respondsToSelector()
{
  return _objc_opt_respondsToSelector();
}

void objc_release(id a1)
{
}

id objc_retain(id a1)
{
  return _objc_retain(a1);
}

id objc_retainAutorelease(id a1)
{
  return _a1;
}

id objc_retainAutoreleaseReturnValue(id a1)
{
  return _a1;
}

id objc_retainAutoreleasedReturnValue(id a1)
{
  return _a1;
}

id objc_retainBlock(id a1)
{
  return _objc_retainBlock(a1);
}

void objc_setProperty_atomic(id self, SEL _cmd, id newValue, ptrdiff_t offset)
{
}

void objc_setProperty_atomic_copy(id self, SEL _cmd, id newValue, ptrdiff_t offset)
{
}

void objc_setProperty_nonatomic_copy(id self, SEL _cmd, id newValue, ptrdiff_t offset)
{
}

void objc_storeStrong(id *location, id obj)
{
}

id objc_storeWeak(id *location, id obj)
{
  return _objc_storeWeak(location, obj);
}

int objc_sync_enter(id obj)
{
  return _objc_sync_enter(obj);
}

int objc_sync_exit(id obj)
{
  return _objc_sync_exit(obj);
}

void objc_terminate(void)
{
}

id objc_unsafeClaimAutoreleasedReturnValue(id a1)
{
  return _objc_unsafeClaimAutoreleasedReturnValue(a1);
}

int open(const char *a1, int a2, ...)
{
  return _open(a1, a2);
}

DIR *__cdecl opendir(const char *a1)
{
  return _opendir(a1);
}

int openpty(int *a1, int *a2, char *a3, termios *a4, winsize *a5)
{
  return _openpty(a1, a2, a3, a4, a5);
}

uint64_t os_buflet_get_data_length()
{
  return _os_buflet_get_data_length();
}

uint64_t os_buflet_get_data_limit()
{
  return _os_buflet_get_data_limit();
}

uint64_t os_buflet_get_data_offset()
{
  return _os_buflet_get_data_offset();
}

uint64_t os_buflet_get_object_address()
{
  return _os_buflet_get_object_address();
}

uint64_t os_buflet_set_data_length()
{
  return _os_buflet_set_data_length();
}

uint64_t os_channel_advance_slot()
{
  return _os_channel_advance_slot();
}

uint64_t os_channel_attr_create()
{
  return _os_channel_attr_create();
}

uint64_t os_channel_attr_destroy()
{
  return _os_channel_attr_destroy();
}

uint64_t os_channel_attr_get()
{
  return _os_channel_attr_get();
}

uint64_t os_channel_attr_set()
{
  return _os_channel_attr_set();
}

uint64_t os_channel_attr_set_key()
{
  return _os_channel_attr_set_key();
}

uint64_t os_channel_available_slot_count()
{
  return _os_channel_available_slot_count();
}

uint64_t os_channel_create()
{
  return _os_channel_create();
}

uint64_t os_channel_create_extended()
{
  return _os_channel_create_extended();
}

uint64_t os_channel_destroy()
{
  return _os_channel_destroy();
}

uint64_t os_channel_get_fd()
{
  return _os_channel_get_fd();
}

uint64_t os_channel_get_next_slot()
{
  return _os_channel_get_next_slot();
}

uint64_t os_channel_read_attr()
{
  return _os_channel_read_attr();
}

uint64_t os_channel_ring_id()
{
  return _os_channel_ring_id();
}

uint64_t os_channel_rx_ring()
{
  return _os_channel_rx_ring();
}

uint64_t os_channel_set_slot_properties()
{
  return _os_channel_set_slot_properties();
}

uint64_t os_channel_slot_get_packet()
{
  return _os_channel_slot_get_packet();
}

uint64_t os_channel_sync()
{
  return _os_channel_sync();
}

uint64_t os_channel_tx_ring()
{
  return _os_channel_tx_ring();
}

uint64_t os_fault_with_payload()
{
  return _os_fault_with_payload();
}

os_log_t os_log_create(const char *subsystem, const char *category)
{
  return _os_log_create(subsystem, category);
}

uint64_t os_log_pack_send_and_compose()
{
  return _os_log_pack_send_and_compose();
}

BOOL os_log_type_enabled(os_log_t oslog, os_log_type_t type)
{
  return _os_log_type_enabled(oslog, type);
}

uint64_t os_nexus_attr_create()
{
  return _os_nexus_attr_create();
}

uint64_t os_nexus_attr_destroy()
{
  return _os_nexus_attr_destroy();
}

uint64_t os_nexus_attr_set()
{
  return _os_nexus_attr_set();
}

uint64_t os_nexus_controller_alloc_provider_instance()
{
  return _os_nexus_controller_alloc_provider_instance();
}

uint64_t os_nexus_controller_bind_provider_instance()
{
  return _os_nexus_controller_bind_provider_instance();
}

uint64_t os_nexus_controller_create()
{
  return _os_nexus_controller_create();
}

uint64_t os_nexus_controller_deregister_provider()
{
  return _os_nexus_controller_deregister_provider();
}

uint64_t os_nexus_controller_destroy()
{
  return _os_nexus_controller_destroy();
}

uint64_t os_nexus_controller_free_provider_instance()
{
  return _os_nexus_controller_free_provider_instance();
}

uint64_t os_nexus_controller_register_provider()
{
  return _os_nexus_controller_register_provider();
}

uint64_t os_packet_finalize()
{
  return _os_packet_finalize();
}

uint64_t os_packet_get_flow_uuid()
{
  return _os_packet_get_flow_uuid();
}

uint64_t os_packet_get_next_buflet()
{
  return _os_packet_get_next_buflet();
}

uint64_t os_packet_set_flow_uuid()
{
  return _os_packet_set_flow_uuid();
}

BOOL os_signpost_enabled(os_log_t log)
{
  return _os_signpost_enabled(log);
}

os_signpost_id_t os_signpost_id_generate(os_log_t log)
{
  return _os_signpost_id_generate(log);
}

os_signpost_id_t os_signpost_id_make_with_pointer(os_log_t log, const void *ptr)
{
  return _os_signpost_id_make_with_pointer(log, ptr);
}

uint64_t os_state_add_handler()
{
  return _os_state_add_handler();
}

uint64_t os_state_remove_handler()
{
  return _os_state_remove_handler();
}

uint64_t os_transaction_create()
{
  return _os_transaction_create();
}

void os_unfair_lock_assert_not_owner(const os_unfair_lock *lock)
{
}

void os_unfair_lock_assert_owner(const os_unfair_lock *lock)
{
}

void os_unfair_lock_lock(os_unfair_lock_t lock)
{
}

void os_unfair_lock_unlock(os_unfair_lock_t lock)
{
}

uint64_t os_variant_has_internal_diagnostics()
{
  return _os_variant_has_internal_diagnostics();
}

uint64_t os_variant_is_recovery()
{
  return _os_variant_is_recovery();
}

void perror(const char *a1)
{
}

int printf(const char *a1, ...)
{
  return _printf(a1);
}

uint64_t proc_disable_wakemon()
{
  return _proc_disable_wakemon();
}

int pthread_attr_destroy(pthread_attr_t *a1)
{
  return _pthread_attr_destroy(a1);
}

int pthread_attr_getschedparam(const pthread_attr_t *a1, sched_param *a2)
{
  return _pthread_attr_getschedparam(a1, a2);
}

int pthread_attr_init(pthread_attr_t *a1)
{
  return _pthread_attr_init(a1);
}

int pthread_attr_set_qos_class_np(pthread_attr_t *__attr, qos_class_t __qos_class, int __relative_priority)
{
  return _pthread_attr_set_qos_class_np(__attr, __qos_class, __relative_priority);
}

int pthread_attr_setdetachstate(pthread_attr_t *a1, int a2)
{
  return _pthread_attr_setdetachstate(a1, a2);
}

int pthread_attr_setschedparam(pthread_attr_t *a1, const sched_param *a2)
{
  return _pthread_attr_setschedparam(a1, a2);
}

int pthread_cancel(pthread_t a1)
{
  return _pthread_cancel(a1);
}

int pthread_cond_broadcast(pthread_cond_t *a1)
{
  return _pthread_cond_broadcast(a1);
}

int pthread_cond_destroy(pthread_cond_t *a1)
{
  return _pthread_cond_destroy(a1);
}

int pthread_cond_init(pthread_cond_t *a1, const pthread_condattr_t *a2)
{
  return _pthread_cond_init(a1, a2);
}

int pthread_cond_signal(pthread_cond_t *a1)
{
  return _pthread_cond_signal(a1);
}

int pthread_cond_timedwait_relative_np(pthread_cond_t *a1, pthread_mutex_t *a2, const timespec *a3)
{
  return _pthread_cond_timedwait_relative_np(a1, a2, a3);
}

int pthread_cond_wait(pthread_cond_t *a1, pthread_mutex_t *a2)
{
  return _pthread_cond_wait(a1, a2);
}

int pthread_create(pthread_t *a1, const pthread_attr_t *a2, void *(__cdecl *a3)(void *), void *a4)
{
  return _pthread_create(a1, a2, a3, a4);
}

int pthread_getname_np(pthread_t a1, char *a2, size_t a3)
{
  return _pthread_getname_np(a1, a2, a3);
}

int pthread_join(pthread_t a1, void **a2)
{
  return _pthread_join(a1, a2);
}

mach_port_t pthread_mach_thread_np(pthread_t a1)
{
  return _pthread_mach_thread_np(a1);
}

int pthread_mutex_destroy(pthread_mutex_t *a1)
{
  return _pthread_mutex_destroy(a1);
}

int pthread_mutex_init(pthread_mutex_t *a1, const pthread_mutexattr_t *a2)
{
  return _pthread_mutex_init(a1, a2);
}

int pthread_mutex_lock(pthread_mutex_t *a1)
{
  return _pthread_mutex_lock(a1);
}

int pthread_mutex_trylock(pthread_mutex_t *a1)
{
  return _pthread_mutex_trylock(a1);
}

int pthread_mutex_unlock(pthread_mutex_t *a1)
{
  return _pthread_mutex_unlock(a1);
}

int pthread_mutexattr_destroy(pthread_mutexattr_t *a1)
{
  return _pthread_mutexattr_destroy(a1);
}

int pthread_mutexattr_init(pthread_mutexattr_t *a1)
{
  return _pthread_mutexattr_init(a1);
}

int pthread_mutexattr_settype(pthread_mutexattr_t *a1, int a2)
{
  return _pthread_mutexattr_settype(a1, a2);
}

pthread_t pthread_self(void)
{
  return _pthread_self();
}

uint64_t pthread_set_fixedpriority_self()
{
  return _pthread_set_fixedpriority_self();
}

int pthread_set_qos_class_self_np(qos_class_t __qos_class, int __relative_priority)
{
  return _pthread_set_qos_class_self_np(__qos_class, __relative_priority);
}

int pthread_setname_np(const char *a1)
{
  return _pthread_setname_np(a1);
}

int pthread_setschedparam(pthread_t a1, int a2, const sched_param *a3)
{
  return _pthread_setschedparam(a1, a2, a3);
}

void pthread_yield_np(void)
{
}

ssize_t read(int a1, void *a2, size_t a3)
{
  return _read(a1, a2, a3);
}

dirent *__cdecl readdir(DIR *a1)
{
  return _readdir(a1);
}

BOOL remove(const std::__fs::filesystem::path *__p, std::error_code *__ec)
{
  return _remove(__p, __ec);
}

void rename(const std::__fs::filesystem::path *__from, const std::__fs::filesystem::path *__to, std::error_code *__ec)
{
}

uint64_t sandbox_extension_issue_file()
{
  return _sandbox_extension_issue_file();
}

int select(int a1, fd_set *a2, fd_set *a3, fd_set *a4, timeval *a5)
{
  return _select(a1, a2, a3, a4, a5);
}

int setenv(const char *__name, const char *__value, int __overwrite)
{
  return _setenv(__name, __value, __overwrite);
}

int setsockopt(int a1, int a2, int a3, const void *a4, socklen_t a5)
{
  return _setsockopt(a1, a2, a3, a4, a5);
}

int shm_unlink(const char *a1)
{
  return _shm_unlink(a1);
}

void (__cdecl *__cdecl signal(int a1, void (__cdecl *a2)(int)))(int)
{
  return _signal(a1, a2);
}

unsigned int sleep(unsigned int a1)
{
  return _sleep(a1);
}

int snprintf(char *__str, size_t __size, const char *__format, ...)
{
  return _snprintf(__str, __size, __format);
}

int socket(int a1, int a2, int a3)
{
  return _socket(a1, a2, a3);
}

int socketpair(int a1, int a2, int a3, int *a4)
{
  return _socketpair(a1, a2, a3, a4);
}

int sprintf(char *a1, const char *a2, ...)
{
  return _sprintf(a1, a2);
}

int sqlite3_bind_blob(sqlite3_stmt *a1, int a2, const void *a3, int n, void (__cdecl *a5)(void *))
{
  return _sqlite3_bind_blob(a1, a2, a3, n, a5);
}

int sqlite3_bind_int(sqlite3_stmt *a1, int a2, int a3)
{
  return _sqlite3_bind_int(a1, a2, a3);
}

int sqlite3_bind_text(sqlite3_stmt *a1, int a2, const char *a3, int a4, void (__cdecl *a5)(void *))
{
  return _sqlite3_bind_text(a1, a2, a3, a4, a5);
}

int sqlite3_clear_bindings(sqlite3_stmt *a1)
{
  return _sqlite3_clear_bindings(a1);
}

int sqlite3_close(sqlite3 *a1)
{
  return _sqlite3_close(a1);
}

int sqlite3_close_v2(sqlite3 *a1)
{
  return _sqlite3_close_v2(a1);
}

int sqlite3_column_count(sqlite3_stmt *pStmt)
{
  return _sqlite3_column_count(pStmt);
}

int sqlite3_column_int(sqlite3_stmt *a1, int iCol)
{
  return _sqlite3_column_int(a1, iCol);
}

const char *__cdecl sqlite3_column_name(sqlite3_stmt *a1, int N)
{
  return _sqlite3_column_name(a1, N);
}

const unsigned __int8 *__cdecl sqlite3_column_text(sqlite3_stmt *a1, int iCol)
{
  return _sqlite3_column_text(a1, iCol);
}

const char *__cdecl sqlite3_errmsg(sqlite3 *a1)
{
  return _sqlite3_errmsg(a1);
}

int sqlite3_exec(sqlite3 *a1, const char *sql, int (__cdecl *callback)(void *, int, char **, char **), void *a4, char **errmsg)
{
  return _sqlite3_exec(a1, sql, callback, a4, errmsg);
}

int sqlite3_extended_errcode(sqlite3 *db)
{
  return _sqlite3_extended_errcode(db);
}

int sqlite3_extended_result_codes(sqlite3 *a1, int onoff)
{
  return _sqlite3_extended_result_codes(a1, onoff);
}

int sqlite3_finalize(sqlite3_stmt *pStmt)
{
  return _sqlite3_finalize(pStmt);
}

int sqlite3_open_v2(const char *filename, sqlite3 **ppDb, int flags, const char *zVfs)
{
  return _sqlite3_open_v2(filename, ppDb, flags, zVfs);
}

int sqlite3_prepare(sqlite3 *db, const char *zSql, int nByte, sqlite3_stmt **ppStmt, const char **pzTail)
{
  return _sqlite3_prepare(db, zSql, nByte, ppStmt, pzTail);
}

int sqlite3_prepare_v2(sqlite3 *db, const char *zSql, int nByte, sqlite3_stmt **ppStmt, const char **pzTail)
{
  return _sqlite3_prepare_v2(db, zSql, nByte, ppStmt, pzTail);
}

int sqlite3_reset(sqlite3_stmt *pStmt)
{
  return _sqlite3_reset(pStmt);
}

int sqlite3_step(sqlite3_stmt *a1)
{
  return _sqlite3_step(a1);
}

int sscanf(const char *a1, const char *a2, ...)
{
  return _sscanf(a1, a2);
}

int stat(const char *a1, stat *a2)
{
  return _stat(a1, a2);
}

int strcasecmp(const char *a1, const char *a2)
{
  return _strcasecmp(a1, a2);
}

char *__cdecl strchr(char *__s, int __c)
{
  return _strchr(__s, __c);
}

int strcmp(const char *__s1, const char *__s2)
{
  return _strcmp(__s1, __s2);
}

char *__cdecl strcpy(char *__dst, const char *__src)
{
  return _strcpy(__dst, __src);
}

char *__cdecl strdup(const char *__s1)
{
  return _strdup(__s1);
}

char *__cdecl strerror(int __errnum)
{
  return _strerror(__errnum);
}

size_t strftime(char *a1, size_t a2, const char *a3, const tm *a4)
{
  return _strftime(a1, a2, a3, a4);
}

uint64_t stricmp_prefix()
{
  return _stricmp_prefix();
}

size_t strlcat(char *__dst, const char *__source, size_t __size)
{
  return _strlcat(__dst, __source, __size);
}

size_t strlcpy(char *__dst, const char *__source, size_t __size)
{
  return _strlcpy(__dst, __source, __size);
}

size_t strlen(const char *__s)
{
  return _strlen(__s);
}

int strncmp(const char *__s1, const char *__s2, size_t __n)
{
  return _strncmp(__s1, __s2, __n);
}

char *__cdecl strncpy(char *__dst, const char *__src, size_t __n)
{
  return _strncpy(__dst, __src, __n);
}

uint64_t strnicmpx()
{
  return _strnicmpx();
}

size_t strnlen(const char *__s1, size_t __n)
{
  return _strnlen(__s1, __n);
}

char *__cdecl strnstr(const char *__big, const char *__little, size_t __len)
{
  return _strnstr(__big, __little, __len);
}

char *__cdecl strrchr(char *__s, int __c)
{
  return _strrchr(__s, __c);
}

char *__cdecl strstr(char *__s1, const char *__s2)
{
  return _strstr(__s1, __s2);
}

char *__cdecl strtok(char *__str, const char *__sep)
{
  return _strtok(__str, __sep);
}

char *__cdecl strtok_r(char *__str, const char *__sep, char **__lasts)
{
  return _strtok_r(__str, __sep, __lasts);
}

uint64_t strtol(const char *__str, char **__endptr, int __base)
{
  return _strtol(__str, __endptr, __base);
}

uint64_t strtoq(const char *__str, char **__endptr, int __base)
{
  return _strtoq(__str, __endptr, __base);
}

unint64_t strtoul(const char *__str, char **__endptr, int __base)
{
  return _strtoul(__str, __endptr, __base);
}

void sync(void)
{
}

int sysctl(int *a1, u_int a2, void *a3, size_t *a4, void *a5, size_t a6)
{
  return _sysctl(a1, a2, a3, a4, a5, a6);
}

int sysctlbyname(const char *a1, void *a2, size_t *a3, void *a4, size_t a5)
{
  return _sysctlbyname(a1, a2, a3, a4, a5);
}

sysdir_search_path_enumeration_state sysdir_get_next_search_path_enumeration(sysdir_search_path_enumeration_state state, char *path)
{
  return _sysdir_get_next_search_path_enumeration(state, path);
}

uint64_t sysdir_start_search_path_enumeration_private()
{
  return _sysdir_start_search_path_enumeration_private();
}

uint64_t tcc_authorization_record_get_authorization_right()
{
  return _tcc_authorization_record_get_authorization_right();
}

uint64_t tcc_credential_create_for_process_with_audit_token()
{
  return _tcc_credential_create_for_process_with_audit_token();
}

uint64_t tcc_message_options_create()
{
  return _tcc_message_options_create();
}

uint64_t tcc_message_options_set_client_dict()
{
  return _tcc_message_options_set_client_dict();
}

uint64_t tcc_message_options_set_reply_handler_policy()
{
  return _tcc_message_options_set_reply_handler_policy();
}

uint64_t tcc_message_options_set_request_prompt_policy()
{
  return _tcc_message_options_set_request_prompt_policy();
}

uint64_t tcc_server_create()
{
  return _tcc_server_create();
}

uint64_t tcc_server_message_request_authorization()
{
  return _tcc_server_message_request_authorization();
}

uint64_t tcc_service_singleton_for_CF_name()
{
  return _tcc_service_singleton_for_CF_name();
}

int tcgetattr(int a1, termios *a2)
{
  return _tcgetattr(a1, a2);
}

int tcsetattr(int a1, int a2, const termios *a3)
{
  return _tcsetattr(a1, a2, a3);
}

kern_return_t thread_policy_get(thread_inspect_t thread, thread_policy_flavor_t flavor, thread_policy_t policy_info, mach_msg_type_number_t *policy_infoCnt, BOOLean_t *get_default)
{
  return _thread_policy_get(thread, flavor, policy_info, policy_infoCnt, get_default);
}

kern_return_t thread_policy_set(thread_act_t thread, thread_policy_flavor_t flavor, thread_policy_t policy_info, mach_msg_type_number_t policy_infoCnt)
{
  return _thread_policy_set(thread, flavor, policy_info, policy_infoCnt);
}

time_t time(time_t *a1)
{
  return _time(a1);
}

int uname(utsname *a1)
{
  return _uname(a1);
}

int usleep(useconds_t a1)
{
  return _usleep(a1);
}

void uuid_clear(uuid_t uu)
{
}

int uuid_compare(const uuid_t uu1, const uuid_t uu2)
{
  return _uuid_compare(uu1, uu2);
}

void uuid_copy(uuid_t dst, const uuid_t src)
{
}

void uuid_generate(uuid_t out)
{
}

int uuid_is_null(const uuid_t uu)
{
  return _uuid_is_null(uu);
}

int uuid_parse(const uuid_string_t in, uuid_t uu)
{
  return _uuid_parse(in, uu);
}

void uuid_unparse_upper(const uuid_t uu, uuid_string_t out)
{
}

ssize_t write(int __fd, const void *__buf, size_t __nbyte)
{
  return _write(__fd, __buf, __nbyte);
}

xpc_activity_state_t xpc_activity_get_state(xpc_activity_t activity)
{
  return _xpc_activity_get_state(activity);
}

void xpc_activity_register(const char *identifier, xpc_object_t criteria, xpc_activity_handler_t handler)
{
}

BOOL xpc_activity_set_state(xpc_activity_t activity, xpc_activity_state_t state)
{
  return _xpc_activity_set_state(activity, state);
}

BOOL xpc_activity_should_defer(xpc_activity_t activity)
{
  return _xpc_activity_should_defer(activity);
}

void xpc_activity_unregister(const char *identifier)
{
}

void xpc_array_append_value(xpc_object_t xarray, xpc_object_t value)
{
}

BOOL xpc_array_apply(xpc_object_t xarray, xpc_array_applier_t applier)
{
  return _xpc_array_apply(xarray, applier);
}

xpc_object_t xpc_array_create(xpc_object_t *objects, size_t count)
{
  return _xpc_array_create(objects, count);
}

size_t xpc_array_get_count(xpc_object_t xarray)
{
  return _xpc_array_get_count(xarray);
}

const void *__cdecl xpc_array_get_data(xpc_object_t xarray, size_t index, size_t *length)
{
  return _xpc_array_get_data(xarray, index, length);
}

int64_t xpc_array_get_int64(xpc_object_t xarray, size_t index)
{
  return _xpc_array_get_int64(xarray, index);
}

const char *__cdecl xpc_array_get_string(xpc_object_t xarray, size_t index)
{
  return _xpc_array_get_string(xarray, index);
}

uint64_t xpc_array_get_uint64(xpc_object_t xarray, size_t index)
{
  return _xpc_array_get_uint64(xarray, index);
}

xpc_object_t xpc_array_get_value(xpc_object_t xarray, size_t index)
{
  return _xpc_array_get_value(xarray, index);
}

void xpc_array_set_data(xpc_object_t xarray, size_t index, const void *bytes, size_t length)
{
}

void xpc_array_set_int64(xpc_object_t xarray, size_t index, int64_t value)
{
}

void xpc_array_set_string(xpc_object_t xarray, size_t index, const char *string)
{
}

void xpc_array_set_uint64(xpc_object_t xarray, size_t index, uint64_t value)
{
}

void xpc_array_set_uuid(xpc_object_t xarray, size_t index, const unsigned __int8 *uuid)
{
}

void xpc_array_set_value(xpc_object_t xarray, size_t index, xpc_object_t value)
{
}

xpc_object_t xpc_BOOL_create(BOOL value)
{
  return _xpc_BOOL_create(value);
}

BOOL xpc_BOOL_get_value(xpc_object_t xBOOL)
{
  return _xpc_BOOL_get_value(xBOOL);
}

void xpc_connection_activate(xpc_connection_t connection)
{
}

void xpc_connection_cancel(xpc_connection_t connection)
{
}

uint64_t xpc_connection_copy_entitlement_value()
{
  return _xpc_connection_copy_entitlement_value();
}

xpc_connection_t xpc_connection_create_mach_service(const char *name, dispatch_queue_t targetq, uint64_t flags)
{
  return _xpc_connection_create_mach_service(name, targetq, flags);
}

au_asid_t xpc_connection_get_asid(xpc_connection_t connection)
{
  return _xpc_connection_get_asid(connection);
}

uint64_t xpc_connection_get_audit_token()
{
  return _xpc_connection_get_audit_token();
}

uid_t xpc_connection_get_euid(xpc_connection_t connection)
{
  return _xpc_connection_get_euid(connection);
}

pid_t xpc_connection_get_pid(xpc_connection_t connection)
{
  return _xpc_connection_get_pid(connection);
}

void xpc_connection_resume(xpc_connection_t connection)
{
}

void xpc_connection_send_message(xpc_connection_t connection, xpc_object_t message)
{
}

void xpc_connection_send_message_with_reply(xpc_connection_t connection, xpc_object_t message, dispatch_queue_t replyq, xpc_handler_t handler)
{
}

xpc_object_t xpc_connection_send_message_with_reply_sync(xpc_connection_t connection, xpc_object_t message)
{
  return _xpc_connection_send_message_with_reply_sync(connection, message);
}

void xpc_connection_set_context(xpc_connection_t connection, void *context)
{
}

void xpc_connection_set_event_handler(xpc_connection_t connection, xpc_handler_t handler)
{
}

void xpc_connection_set_finalizer_f(xpc_connection_t connection, xpc_finalizer_t finalizer)
{
}

void xpc_connection_set_target_queue(xpc_connection_t connection, dispatch_queue_t targetq)
{
}

uint64_t xpc_copy_code_signing_identity_for_token()
{
  return _xpc_copy_code_signing_identity_for_token();
}

char *__cdecl xpc_copy_description(xpc_object_t object)
{
  return _xpc_copy_description(object);
}

uint64_t xpc_copy_entitlement_for_token()
{
  return _xpc_copy_entitlement_for_token();
}

xpc_object_t xpc_data_create(const void *bytes, size_t length)
{
  return _xpc_data_create(bytes, length);
}

size_t xpc_data_get_bytes(xpc_object_t xdata, void *buffer, size_t off, size_t length)
{
  return _xpc_data_get_bytes(xdata, buffer, off, length);
}

const void *__cdecl xpc_data_get_bytes_ptr(xpc_object_t xdata)
{
  return _xpc_data_get_bytes_ptr(xdata);
}

size_t xpc_data_get_length(xpc_object_t xdata)
{
  return _xpc_data_get_length(xdata);
}

int64_t xpc_date_get_value(xpc_object_t xdate)
{
  return _xpc_date_get_value(xdate);
}

BOOL xpc_dictionary_apply(xpc_object_t xdict, xpc_dictionary_applier_t applier)
{
  return _xpc_dictionary_apply(xdict, applier);
}

xpc_object_t xpc_dictionary_create(const char *const *keys, xpc_object_t *values, size_t count)
{
  return _xpc_dictionary_create(keys, values, count);
}

xpc_object_t xpc_dictionary_create_reply(xpc_object_t original)
{
  return _xpc_dictionary_create_reply(original);
}

uint64_t xpc_dictionary_expects_reply()
{
  return _xpc_dictionary_expects_reply();
}

xpc_object_t xpc_dictionary_get_array(xpc_object_t xdict, const char *key)
{
  return _xpc_dictionary_get_array(xdict, key);
}

BOOL xpc_dictionary_get_BOOL(xpc_object_t xdict, const char *key)
{
  return _xpc_dictionary_get_BOOL(xdict, key);
}

size_t xpc_dictionary_get_count(xpc_object_t xdict)
{
  return _xpc_dictionary_get_count(xdict);
}

const void *__cdecl xpc_dictionary_get_data(xpc_object_t xdict, const char *key, size_t *length)
{
  return _xpc_dictionary_get_data(xdict, key, length);
}

int64_t xpc_dictionary_get_date(xpc_object_t xdict, const char *key)
{
  return _xpc_dictionary_get_date(xdict, key);
}

xpc_object_t xpc_dictionary_get_dictionary(xpc_object_t xdict, const char *key)
{
  return _xpc_dictionary_get_dictionary(xdict, key);
}

double xpc_dictionary_get_double(xpc_object_t xdict, const char *key)
{
  return _xpc_dictionary_get_double(xdict, key);
}

int64_t xpc_dictionary_get_int64(xpc_object_t xdict, const char *key)
{
  return _xpc_dictionary_get_int64(xdict, key);
}

xpc_connection_t xpc_dictionary_get_remote_connection(xpc_object_t xdict)
{
  return _xpc_dictionary_get_remote_connection(xdict);
}

const char *__cdecl xpc_dictionary_get_string(xpc_object_t xdict, const char *key)
{
  return _xpc_dictionary_get_string(xdict, key);
}

uint64_t xpc_dictionary_get_uint64(xpc_object_t xdict, const char *key)
{
  return _xpc_dictionary_get_uint64(xdict, key);
}

const uint8_t *__cdecl xpc_dictionary_get_uuid(xpc_object_t xdict, const char *key)
{
  return _xpc_dictionary_get_uuid(xdict, key);
}

xpc_object_t xpc_dictionary_get_value(xpc_object_t xdict, const char *key)
{
  return _xpc_dictionary_get_value(xdict, key);
}

void xpc_dictionary_set_BOOL(xpc_object_t xdict, const char *key, BOOL value)
{
}

void xpc_dictionary_set_data(xpc_object_t xdict, const char *key, const void *bytes, size_t length)
{
}

void xpc_dictionary_set_date(xpc_object_t xdict, const char *key, int64_t value)
{
}

void xpc_dictionary_set_double(xpc_object_t xdict, const char *key, double value)
{
}

void xpc_dictionary_set_fd(xpc_object_t xdict, const char *key, int fd)
{
}

void xpc_dictionary_set_int64(xpc_object_t xdict, const char *key, int64_t value)
{
}

void xpc_dictionary_set_string(xpc_object_t xdict, const char *key, const char *string)
{
}

void xpc_dictionary_set_uint64(xpc_object_t xdict, const char *key, uint64_t value)
{
}

void xpc_dictionary_set_uuid(xpc_object_t xdict, const char *key, const unsigned __int8 *uuid)
{
}

void xpc_dictionary_set_value(xpc_object_t xdict, const char *key, xpc_object_t value)
{
}

xpc_object_t xpc_double_create(double value)
{
  return _xpc_double_create(value);
}

double xpc_double_get_value(xpc_object_t xdouble)
{
  return _xpc_double_get_value(xdouble);
}

xpc_endpoint_t xpc_endpoint_create(xpc_connection_t connection)
{
  return _xpc_endpoint_create(connection);
}

uint64_t xpc_event_publisher_activate()
{
  return _xpc_event_publisher_activate();
}

uint64_t xpc_event_publisher_create()
{
  return _xpc_event_publisher_create();
}

uint64_t xpc_event_publisher_fire()
{
  return _xpc_event_publisher_fire();
}

uint64_t xpc_event_publisher_set_error_handler()
{
  return _xpc_event_publisher_set_error_handler();
}

uint64_t xpc_event_publisher_set_handler()
{
  return _xpc_event_publisher_set_handler();
}

uint64_t xpc_event_publisher_set_subscriber_keepalive()
{
  return _xpc_event_publisher_set_subscriber_keepalive();
}

int xpc_fd_dup(xpc_object_t xfd)
{
  return _xpc_fd_dup(xfd);
}

xpc_type_t xpc_get_type(xpc_object_t object)
{
  return _xpc_get_type(object);
}

xpc_object_t xpc_int64_create(int64_t value)
{
  return _xpc_int64_create(value);
}

int64_t xpc_int64_get_value(xpc_object_t xint)
{
  return _xpc_int64_get_value(xint);
}

xpc_object_t xpc_null_create(void)
{
  return _xpc_null_create();
}

void xpc_release(xpc_object_t object)
{
}

xpc_object_t xpc_retain(xpc_object_t object)
{
  return _xpc_retain(object);
}

uint64_t xpc_set_event()
{
  return _xpc_set_event();
}

void xpc_set_event_stream_handler(const char *stream, dispatch_queue_t targetq, xpc_handler_t handler)
{
}

size_t xpc_shmem_map(xpc_object_t xshmem, void **region)
{
  return _xpc_shmem_map(xshmem, region);
}

xpc_object_t xpc_string_create(const char *string)
{
  return _xpc_string_create(string);
}

const char *__cdecl xpc_string_get_string_ptr(xpc_object_t xstring)
{
  return _xpc_string_get_string_ptr(xstring);
}

const char *__cdecl xpc_type_get_name(xpc_type_t type)
{
  return _xpc_type_get_name(type);
}

xpc_object_t xpc_uint64_create(uint64_t value)
{
  return _xpc_uint64_create(value);
}

uint64_t xpc_uint64_get_value(xpc_object_t xuint)
{
  return _xpc_uint64_get_value(xuint);
}

xpc_object_t xpc_uuid_create(const unsigned __int8 *uuid)
{
  return _xpc_uuid_create(uuid);
}

const uint8_t *__cdecl xpc_uuid_get_bytes(xpc_object_t xuuid)
{
  return _xpc_uuid_get_bytes(xuuid);
}

id objc_msgSend_BluetoothGATTSession(void *a1, const char *a2, ...)
{
  return [a1 BluetoothGATTSession];
}

id objc_msgSend_BluetoothPowerEnabled(void *a1, const char *a2, ...)
{
  return [a1 BluetoothPowerEnabled];
}

id objc_msgSend_Device(void *a1, const char *a2, ...)
{
  return [a1 Device];
}

id objc_msgSend_PHYOptions(void *a1, const char *a2, ...)
{
  return [a1 PHYOptions];
}

id objc_msgSend_UID(void *a1, const char *a2, ...)
{
  return [a1 UID];
}

id objc_msgSend_URL(void *a1, const char *a2, ...)
{
  return [a1 URL];
}

id objc_msgSend_URLByDeletingLastPathComponent(void *a1, const char *a2, ...)
{
  return [a1 URLByDeletingLastPathComponent];
}

id objc_msgSend_UTF8String(void *a1, const char *a2, ...)
{
  return [a1 UTF8String];
}

id objc_msgSend_UUID(void *a1, const char *a2, ...)
{
  return [a1 UUID];
}

id objc_msgSend_UUID128(void *a1, const char *a2, ...)
{
  return [a1 UUID128];
}

id objc_msgSend_UUIDString(void *a1, const char *a2, ...)
{
  return [a1 UUIDString];
}

id objc_msgSend_Wireless(void *a1, const char *a2, ...)
{
  return [a1 Wireless];
}

id objc_msgSend__accessoryDaemonEnsureStarted(void *a1, const char *a2, ...)
{
  return [a1 _accessoryDaemonEnsureStarted];
}

id objc_msgSend__accessoryDaemonEnsureStopped(void *a1, const char *a2, ...)
{
  return [a1 _accessoryDaemonEnsureStopped];
}

id objc_msgSend__accessoryDiscoveryEnsureStarted(void *a1, const char *a2, ...)
{
  return [a1 _accessoryDiscoveryEnsureStarted];
}

id objc_msgSend__accessoryDiscoveryEnsureStopped(void *a1, const char *a2, ...)
{
  return [a1 _accessoryDiscoveryEnsureStopped];
}

id objc_msgSend__bleAddressMonitorEnsureStarted(void *a1, const char *a2, ...)
{
  return [a1 _bleAddressMonitorEnsureStarted];
}

id objc_msgSend__bleAddressMonitorEnsureStopped(void *a1, const char *a2, ...)
{
  return [a1 _bleAddressMonitorEnsureStopped];
}

id objc_msgSend__bleAdvertiserEnsureStarted(void *a1, const char *a2, ...)
{
  return [a1 _bleAdvertiserEnsureStarted];
}

id objc_msgSend__bleAdvertiserEnsureStopped(void *a1, const char *a2, ...)
{
  return [a1 _bleAdvertiserEnsureStopped];
}

id objc_msgSend__bleAdvertiserShouldRun(void *a1, const char *a2, ...)
{
  return [a1 _bleAdvertiserShouldRun];
}

id objc_msgSend__bleAdvertiserUpdateSpatialInteraction(void *a1, const char *a2, ...)
{
  return [a1 _bleAdvertiserUpdateSpatialInteraction];
}

id objc_msgSend__bleAdvertiserUpdateWithAuthTagNC(void *a1, const char *a2, ...)
{
  return [a1 _bleAdvertiserUpdateWithAuthTagNC];
}

id objc_msgSend__bleBTVCLinkAdvertiserEnsureStarted(void *a1, const char *a2, ...)
{
  return [a1 _bleBTVCLinkAdvertiserEnsureStarted];
}

id objc_msgSend__bleBTVCLinkAdvertiserEnsureStopped(void *a1, const char *a2, ...)
{
  return [a1 _bleBTVCLinkAdvertiserEnsureStopped];
}

id objc_msgSend__bleBTVCLinkAdvertiserShouldAdvertise(void *a1, const char *a2, ...)
{
  return [a1 _bleBTVCLinkAdvertiserShouldAdvertise];
}

id objc_msgSend__bleBTVCLinkScannerEnsureStarted(void *a1, const char *a2, ...)
{
  return [a1 _bleBTVCLinkScannerEnsureStarted];
}

id objc_msgSend__bleBTVCLinkScannerEnsureStopped(void *a1, const char *a2, ...)
{
  return [a1 _bleBTVCLinkScannerEnsureStopped];
}

id objc_msgSend__bleBTVCLinkScannerShouldScan(void *a1, const char *a2, ...)
{
  return [a1 _bleBTVCLinkScannerShouldScan];
}

id objc_msgSend__cleanupAdvertiser(void *a1, const char *a2, ...)
{
  return [a1 _cleanupAdvertiser];
}

id objc_msgSend__cleanupBrowser(void *a1, const char *a2, ...)
{
  return [a1 _cleanupBrowser];
}

id objc_msgSend__connectionMonitorEnsureStarted(void *a1, const char *a2, ...)
{
  return [a1 _connectionMonitorEnsureStarted];
}

id objc_msgSend__connectionMonitorEnsureStopped(void *a1, const char *a2, ...)
{
  return [a1 _connectionMonitorEnsureStopped];
}

id objc_msgSend__connectionMonitorUpdate(void *a1, const char *a2, ...)
{
  return [a1 _connectionMonitorUpdate];
}

id objc_msgSend__deleteAllDevices(void *a1, const char *a2, ...)
{
  return [a1 _deleteAllDevices];
}

id objc_msgSend__extensionsEnsureStarted(void *a1, const char *a2, ...)
{
  return [a1 _extensionsEnsureStarted];
}

id objc_msgSend__extensionsEnsureStopped(void *a1, const char *a2, ...)
{
  return [a1 _extensionsEnsureStopped];
}

id objc_msgSend__findExtensionsStart(void *a1, const char *a2, ...)
{
  return [a1 _findExtensionsStart];
}

id objc_msgSend__firstUnlockedOrAllowedBefore(void *a1, const char *a2, ...)
{
  return [a1 _firstUnlockedOrAllowedBefore];
}

id objc_msgSend__generateKeys(void *a1, const char *a2, ...)
{
  return [a1 _generateKeys];
}

id objc_msgSend__getPowerObserver(void *a1, const char *a2, ...)
{
  return [a1 _getPowerObserver];
}

id objc_msgSend__getSubscriptionContext(void *a1, const char *a2, ...)
{
  return [a1 _getSubscriptionContext];
}

id objc_msgSend__handleUUIDHeaders(void *a1, const char *a2, ...)
{
  return [a1 _handleUUIDHeaders];
}

id objc_msgSend__identitiesEnsureStarted(void *a1, const char *a2, ...)
{
  return [a1 _identitiesEnsureStarted];
}

id objc_msgSend__identitiesEnsureStopped(void *a1, const char *a2, ...)
{
  return [a1 _identitiesEnsureStopped];
}

id objc_msgSend__identitiesGet(void *a1, const char *a2, ...)
{
  return [a1 _identitiesGet];
}

id objc_msgSend__identitiesReevaluateDevices(void *a1, const char *a2, ...)
{
  return [a1 _identitiesReevaluateDevices];
}

id objc_msgSend__identitiesShouldRun(void *a1, const char *a2, ...)
{
  return [a1 _identitiesShouldRun];
}

id objc_msgSend__initializeDatabaseIdentifer(void *a1, const char *a2, ...)
{
  return [a1 _initializeDatabaseIdentifer];
}

id objc_msgSend__initializePrimaryFolderVersions(void *a1, const char *a2, ...)
{
  return [a1 _initializePrimaryFolderVersions];
}

id objc_msgSend__initializeSecondaryFolderVersions(void *a1, const char *a2, ...)
{
  return [a1 _initializeSecondaryFolderVersions];
}

id objc_msgSend__invalidateUserController(void *a1, const char *a2, ...)
{
  return [a1 _invalidateUserController];
}

id objc_msgSend__invalidated(void *a1, const char *a2, ...)
{
  return [a1 _invalidated];
}

id objc_msgSend__isAdvertisingEnabled(void *a1, const char *a2, ...)
{
  return [a1 _isAdvertisingEnabled];
}

id objc_msgSend__listenForBTVCBonjourEvents(void *a1, const char *a2, ...)
{
  return [a1 _listenForBTVCBonjourEvents];
}

id objc_msgSend__myNumber(void *a1, const char *a2, ...)
{
  return [a1 _myNumber];
}

id objc_msgSend__oobKeysRemoveAll(void *a1, const char *a2, ...)
{
  return [a1 _oobKeysRemoveAll];
}

id objc_msgSend__oobKeysUpdate(void *a1, const char *a2, ...)
{
  return [a1 _oobKeysUpdate];
}

id objc_msgSend__pairingAgentTearDown(void *a1, const char *a2, ...)
{
  return [a1 _pairingAgentTearDown];
}

id objc_msgSend__powerStateForClient(void *a1, const char *a2, ...)
{
  return [a1 _powerStateForClient];
}

id objc_msgSend__prefsChanged(void *a1, const char *a2, ...)
{
  return [a1 _prefsChanged];
}

id objc_msgSend__remoteEnsureStarted(void *a1, const char *a2, ...)
{
  return [a1 _remoteEnsureStarted];
}

id objc_msgSend__remoteEnsureStopped(void *a1, const char *a2, ...)
{
  return [a1 _remoteEnsureStopped];
}

id objc_msgSend__remoteInvalidate(void *a1, const char *a2, ...)
{
  return [a1 _remoteInvalidate];
}

id objc_msgSend__remoteInvalidateInactiveXPC(void *a1, const char *a2, ...)
{
  return [a1 _remoteInvalidateInactiveXPC];
}

id objc_msgSend__reportAggressiveScanIfNeeded(void *a1, const char *a2, ...)
{
  return [a1 _reportAggressiveScanIfNeeded];
}

id objc_msgSend__reportEvents(void *a1, const char *a2, ...)
{
  return [a1 _reportEvents];
}

id objc_msgSend__resetAdvertisingEnable(void *a1, const char *a2, ...)
{
  return [a1 _resetAdvertisingEnable];
}

id objc_msgSend__scanRequestCreate(void *a1, const char *a2, ...)
{
  return [a1 _scanRequestCreate];
}

id objc_msgSend__scheduleReport(void *a1, const char *a2, ...)
{
  return [a1 _scheduleReport];
}

id objc_msgSend__sensorTrackingUpdate(void *a1, const char *a2, ...)
{
  return [a1 _sensorTrackingUpdate];
}

id objc_msgSend__setupAggressiveScanMetricExportTimer(void *a1, const char *a2, ...)
{
  return [a1 _setupAggressiveScanMetricExportTimer];
}

id objc_msgSend__spatialInteractionReevaluateDevices(void *a1, const char *a2, ...)
{
  return [a1 _spatialInteractionReevaluateDevices];
}

id objc_msgSend__stackAccessoryMonitorEnsureStarted(void *a1, const char *a2, ...)
{
  return [a1 _stackAccessoryMonitorEnsureStarted];
}

id objc_msgSend__stackAccessoryMonitorEnsureStopped(void *a1, const char *a2, ...)
{
  return [a1 _stackAccessoryMonitorEnsureStopped];
}

id objc_msgSend__stackAccessoryMonitorShouldRun(void *a1, const char *a2, ...)
{
  return [a1 _stackAccessoryMonitorShouldRun];
}

id objc_msgSend__stackBLEScannerEnsureStarted(void *a1, const char *a2, ...)
{
  return [a1 _stackBLEScannerEnsureStarted];
}

id objc_msgSend__stackBLEScannerEnsureStopped(void *a1, const char *a2, ...)
{
  return [a1 _stackBLEScannerEnsureStopped];
}

id objc_msgSend__stackBLEScannerShouldRun(void *a1, const char *a2, ...)
{
  return [a1 _stackBLEScannerShouldRun];
}

id objc_msgSend__stackClassicScannerEnsureStarted(void *a1, const char *a2, ...)
{
  return [a1 _stackClassicScannerEnsureStarted];
}

id objc_msgSend__stackClassicScannerEnsureStopped(void *a1, const char *a2, ...)
{
  return [a1 _stackClassicScannerEnsureStopped];
}

id objc_msgSend__stackClassicScannerShouldRun(void *a1, const char *a2, ...)
{
  return [a1 _stackClassicScannerShouldRun];
}

id objc_msgSend__stackControllerEnsureStarted(void *a1, const char *a2, ...)
{
  return [a1 _stackControllerEnsureStarted];
}

id objc_msgSend__stackControllerEnsureStopped(void *a1, const char *a2, ...)
{
  return [a1 _stackControllerEnsureStopped];
}

id objc_msgSend__stackDeviceMonitorEnsureStarted(void *a1, const char *a2, ...)
{
  return [a1 _stackDeviceMonitorEnsureStarted];
}

id objc_msgSend__stackDeviceMonitorEnsureStopped(void *a1, const char *a2, ...)
{
  return [a1 _stackDeviceMonitorEnsureStopped];
}

id objc_msgSend__stackDeviceMonitorShouldRun(void *a1, const char *a2, ...)
{
  return [a1 _stackDeviceMonitorShouldRun];
}

id objc_msgSend__startAdvertiser(void *a1, const char *a2, ...)
{
  return [a1 _startAdvertiser];
}

id objc_msgSend__startBrowser(void *a1, const char *a2, ...)
{
  return [a1 _startBrowser];
}

id objc_msgSend__startConnection(void *a1, const char *a2, ...)
{
  return [a1 _startConnection];
}

id objc_msgSend__startIfNeeded(void *a1, const char *a2, ...)
{
  return [a1 _startIfNeeded];
}

id objc_msgSend__startTimeoutIfNeeded(void *a1, const char *a2, ...)
{
  return [a1 _startTimeoutIfNeeded];
}

id objc_msgSend__stopAdvertising(void *a1, const char *a2, ...)
{
  return [a1 _stopAdvertising];
}

id objc_msgSend__stopBrowser(void *a1, const char *a2, ...)
{
  return [a1 _stopBrowser];
}

id objc_msgSend__supportsProxControl(void *a1, const char *a2, ...)
{
  return [a1 _supportsProxControl];
}

id objc_msgSend__triggerPendingExtension(void *a1, const char *a2, ...)
{
  return [a1 _triggerPendingExtension];
}

id objc_msgSend__typeToRssiThresholdUpdate(void *a1, const char *a2, ...)
{
  return [a1 _typeToRssiThresholdUpdate];
}

id objc_msgSend__update(void *a1, const char *a2, ...)
{
  return [a1 _update];
}

id objc_msgSend__updateAdvertiserState(void *a1, const char *a2, ...)
{
  return [a1 _updateAdvertiserState];
}

id objc_msgSend__updateBrowserState(void *a1, const char *a2, ...)
{
  return [a1 _updateBrowserState];
}

id objc_msgSend__updateCalls(void *a1, const char *a2, ...)
{
  return [a1 _updateCalls];
}

id objc_msgSend__updateConnectable(void *a1, const char *a2, ...)
{
  return [a1 _updateConnectable];
}

id objc_msgSend__updateConnectedAudioAccessories(void *a1, const char *a2, ...)
{
  return [a1 _updateConnectedAudioAccessories];
}

id objc_msgSend__updateDevicesConnected(void *a1, const char *a2, ...)
{
  return [a1 _updateDevicesConnected];
}

id objc_msgSend__updateDevicesPaired(void *a1, const char *a2, ...)
{
  return [a1 _updateDevicesPaired];
}

id objc_msgSend__updateFIDOAdvertising(void *a1, const char *a2, ...)
{
  return [a1 _updateFIDOAdvertising];
}

id objc_msgSend__updateFIDOPayload(void *a1, const char *a2, ...)
{
  return [a1 _updateFIDOPayload];
}

id objc_msgSend__updateNonConnectable(void *a1, const char *a2, ...)
{
  return [a1 _updateNonConnectable];
}

id objc_msgSend__updateNonConnectableContact(void *a1, const char *a2, ...)
{
  return [a1 _updateNonConnectableContact];
}

id objc_msgSend__updatePowerSources(void *a1, const char *a2, ...)
{
  return [a1 _updatePowerSources];
}

id objc_msgSend__updateRSSIFilter(void *a1, const char *a2, ...)
{
  return [a1 _updateRSSIFilter];
}

id objc_msgSend__updateSafetyAlertsAdvertising(void *a1, const char *a2, ...)
{
  return [a1 _updateSafetyAlertsAdvertising];
}

id objc_msgSend__updateSafetyAlertsPayload(void *a1, const char *a2, ...)
{
  return [a1 _updateSafetyAlertsPayload];
}

id objc_msgSend__updateSelfAuthTag(void *a1, const char *a2, ...)
{
  return [a1 _updateSelfAuthTag];
}

id objc_msgSend__updateUserControllerCloudDevices(void *a1, const char *a2, ...)
{
  return [a1 _updateUserControllerCloudDevices];
}

id objc_msgSend__updateWatchSetupAdvertising(void *a1, const char *a2, ...)
{
  return [a1 _updateWatchSetupAdvertising];
}

id objc_msgSend__updateWatchSetupPayload(void *a1, const char *a2, ...)
{
  return [a1 _updateWatchSetupPayload];
}

id objc_msgSend__userControllerUploadLocalControllerInfo(void *a1, const char *a2, ...)
{
  return [a1 _userControllerUploadLocalControllerInfo];
}

id objc_msgSend__whbDiscoveryEnsureStarted(void *a1, const char *a2, ...)
{
  return [a1 _whbDiscoveryEnsureStarted];
}

id objc_msgSend__whbDiscoveryEnsureStopped(void *a1, const char *a2, ...)
{
  return [a1 _whbDiscoveryEnsureStopped];
}

id objc_msgSend__whbDiscoveryShouldRun(void *a1, const char *a2, ...)
{
  return [a1 _whbDiscoveryShouldRun];
}

id objc_msgSend__xpcAdvertisingAddressChanged(void *a1, const char *a2, ...)
{
  return [a1 _xpcAdvertisingAddressChanged];
}

id objc_msgSend__xpcDiagnosticAdvertiser(void *a1, const char *a2, ...)
{
  return [a1 _xpcDiagnosticAdvertiser];
}

id objc_msgSend__xpcDiagnosticAssertion(void *a1, const char *a2, ...)
{
  return [a1 _xpcDiagnosticAssertion];
}

id objc_msgSend__xpcDiagnosticDiscovery(void *a1, const char *a2, ...)
{
  return [a1 _xpcDiagnosticDiscovery];
}

id objc_msgSend__xpcDiagnosticTipiChanged(void *a1, const char *a2, ...)
{
  return [a1 _xpcDiagnosticTipiChanged];
}

id objc_msgSend_absoluteString(void *a1, const char *a2, ...)
{
  return [a1 absoluteString];
}

id objc_msgSend_accessoryDaemon(void *a1, const char *a2, ...)
{
  return [a1 accessoryDaemon];
}

id objc_msgSend_accessoryHint(void *a1, const char *a2, ...)
{
  return [a1 accessoryHint];
}

id objc_msgSend_accessoryKey(void *a1, const char *a2, ...)
{
  return [a1 accessoryKey];
}

id objc_msgSend_accessoryMonitorClass(void *a1, const char *a2, ...)
{
  return [a1 accessoryMonitorClass];
}

id objc_msgSend_accessoryOptions(void *a1, const char *a2, ...)
{
  return [a1 accessoryOptions];
}

id objc_msgSend_accessoryStatusFlags(void *a1, const char *a2, ...)
{
  return [a1 accessoryStatusFlags];
}

id objc_msgSend_accessoryStatusOBCTime(void *a1, const char *a2, ...)
{
  return [a1 accessoryStatusOBCTime];
}

id objc_msgSend_aclPriority(void *a1, const char *a2, ...)
{
  return [a1 aclPriority];
}

id objc_msgSend_acquire(void *a1, const char *a2, ...)
{
  return [a1 acquire];
}

id objc_msgSend_action(void *a1, const char *a2, ...)
{
  return [a1 action];
}

id objc_msgSend_actionType(void *a1, const char *a2, ...)
{
  return [a1 actionType];
}

id objc_msgSend_activate(void *a1, const char *a2, ...)
{
  return [a1 activate];
}

id objc_msgSend_activatedAdvertiser(void *a1, const char *a2, ...)
{
  return [a1 activatedAdvertiser];
}

id objc_msgSend_activatedConnection(void *a1, const char *a2, ...)
{
  return [a1 activatedConnection];
}

id objc_msgSend_activatedController(void *a1, const char *a2, ...)
{
  return [a1 activatedController];
}

id objc_msgSend_activatedDiscovery(void *a1, const char *a2, ...)
{
  return [a1 activatedDiscovery];
}

id objc_msgSend_activatedDiscoveryWHB(void *a1, const char *a2, ...)
{
  return [a1 activatedDiscoveryWHB];
}

id objc_msgSend_activatedSpatialInteractionSession(void *a1, const char *a2, ...)
{
  return [a1 activatedSpatialInteractionSession];
}

id objc_msgSend_activeDevices(void *a1, const char *a2, ...)
{
  return [a1 activeDevices];
}

id objc_msgSend_adaptiveVolumeCapability(void *a1, const char *a2, ...)
{
  return [a1 adaptiveVolumeCapability];
}

id objc_msgSend_adaptiveVolumeConfig(void *a1, const char *a2, ...)
{
  return [a1 adaptiveVolumeConfig];
}

id objc_msgSend_addressMonitor(void *a1, const char *a2, ...)
{
  return [a1 addressMonitor];
}

id objc_msgSend_addressMonitorClass(void *a1, const char *a2, ...)
{
  return [a1 addressMonitorClass];
}

id objc_msgSend_addressType(void *a1, const char *a2, ...)
{
  return [a1 addressType];
}

id objc_msgSend_advReportReceiveHandler(void *a1, const char *a2, ...)
{
  return [a1 advReportReceiveHandler];
}

id objc_msgSend_advToBrowserNwToSFendpoints(void *a1, const char *a2, ...)
{
  return [a1 advToBrowserNwToSFendpoints];
}

id objc_msgSend_advToBrowserUuidToSFendpoints(void *a1, const char *a2, ...)
{
  return [a1 advToBrowserUuidToSFendpoints];
}

id objc_msgSend_advertiseRate(void *a1, const char *a2, ...)
{
  return [a1 advertiseRate];
}

id objc_msgSend_advertiserAdvs(void *a1, const char *a2, ...)
{
  return [a1 advertiserAdvs];
}

id objc_msgSend_advertiserArray(void *a1, const char *a2, ...)
{
  return [a1 advertiserArray];
}

id objc_msgSend_advertiserEnableEPA(void *a1, const char *a2, ...)
{
  return [a1 advertiserEnableEPA];
}

id objc_msgSend_advertiserState(void *a1, const char *a2, ...)
{
  return [a1 advertiserState];
}

id objc_msgSend_advertisingAddressChanged(void *a1, const char *a2, ...)
{
  return [a1 advertisingAddressChanged];
}

id objc_msgSend_advertisingAddressChangedHandler(void *a1, const char *a2, ...)
{
  return [a1 advertisingAddressChangedHandler];
}

id objc_msgSend_advertisingAddressData(void *a1, const char *a2, ...)
{
  return [a1 advertisingAddressData];
}

id objc_msgSend_advertisingAddressDataConnectable(void *a1, const char *a2, ...)
{
  return [a1 advertisingAddressDataConnectable];
}

id objc_msgSend_advertisingAddressDataNonConnectable(void *a1, const char *a2, ...)
{
  return [a1 advertisingAddressDataNonConnectable];
}

id objc_msgSend_advertisingAddressDataNonConnectableSecondary(void *a1, const char *a2, ...)
{
  return [a1 advertisingAddressDataNonConnectableSecondary];
}

id objc_msgSend_advertisingManager(void *a1, const char *a2, ...)
{
  return [a1 advertisingManager];
}

id objc_msgSend_advertisingRate(void *a1, const char *a2, ...)
{
  return [a1 advertisingRate];
}

id objc_msgSend_advertisingStateUpdateHandler(void *a1, const char *a2, ...)
{
  return [a1 advertisingStateUpdateHandler];
}

id objc_msgSend_aggregateDiscoveryFlags(void *a1, const char *a2, ...)
{
  return [a1 aggregateDiscoveryFlags];
}

id objc_msgSend_aggregateDiscoveryTypes(void *a1, const char *a2, ...)
{
  return [a1 aggregateDiscoveryTypes];
}

id objc_msgSend_airdropConfigData(void *a1, const char *a2, ...)
{
  return [a1 airdropConfigData];
}

id objc_msgSend_airdropFlags(void *a1, const char *a2, ...)
{
  return [a1 airdropFlags];
}

id objc_msgSend_airdropHash1(void *a1, const char *a2, ...)
{
  return [a1 airdropHash1];
}

id objc_msgSend_airdropHash2(void *a1, const char *a2, ...)
{
  return [a1 airdropHash2];
}

id objc_msgSend_airdropHash3(void *a1, const char *a2, ...)
{
  return [a1 airdropHash3];
}

id objc_msgSend_airdropHash4(void *a1, const char *a2, ...)
{
  return [a1 airdropHash4];
}

id objc_msgSend_airdropModel(void *a1, const char *a2, ...)
{
  return [a1 airdropModel];
}

id objc_msgSend_airdropTempAuthTagData(void *a1, const char *a2, ...)
{
  return [a1 airdropTempAuthTagData];
}

id objc_msgSend_airdropVersion(void *a1, const char *a2, ...)
{
  return [a1 airdropVersion];
}

id objc_msgSend_airplaySourceAuthTagData(void *a1, const char *a2, ...)
{
  return [a1 airplaySourceAuthTagData];
}

id objc_msgSend_airplaySourceFlags(void *a1, const char *a2, ...)
{
  return [a1 airplaySourceFlags];
}

id objc_msgSend_airplaySourceUWBConfigData(void *a1, const char *a2, ...)
{
  return [a1 airplaySourceUWBConfigData];
}

id objc_msgSend_airplayTargetConfigSeed(void *a1, const char *a2, ...)
{
  return [a1 airplayTargetConfigSeed];
}

id objc_msgSend_airplayTargetFlags(void *a1, const char *a2, ...)
{
  return [a1 airplayTargetFlags];
}

id objc_msgSend_airplayTargetIPv4(void *a1, const char *a2, ...)
{
  return [a1 airplayTargetIPv4];
}

id objc_msgSend_airplayTargetPort(void *a1, const char *a2, ...)
{
  return [a1 airplayTargetPort];
}

id objc_msgSend_allKeys(void *a1, const char *a2, ...)
{
  return [a1 allKeys];
}

id objc_msgSend_allObjects(void *a1, const char *a2, ...)
{
  return [a1 allObjects];
}

id objc_msgSend_allValues(void *a1, const char *a2, ...)
{
  return [a1 allValues];
}

id objc_msgSend_allowOffListeningMode(void *a1, const char *a2, ...)
{
  return [a1 allowOffListeningMode];
}

id objc_msgSend_allowedSessions(void *a1, const char *a2, ...)
{
  return [a1 allowedSessions];
}

id objc_msgSend_allowsAutoRoute(void *a1, const char *a2, ...)
{
  return [a1 allowsAutoRoute];
}

id objc_msgSend_alphanumericCharacterSet(void *a1, const char *a2, ...)
{
  return [a1 alphanumericCharacterSet];
}

id objc_msgSend_ancAssetVersion(void *a1, const char *a2, ...)
{
  return [a1 ancAssetVersion];
}

id objc_msgSend_ancsRequired(void *a1, const char *a2, ...)
{
  return [a1 ancsRequired];
}

id objc_msgSend_anyObject(void *a1, const char *a2, ...)
{
  return [a1 anyObject];
}

id objc_msgSend_aopDataHandler(void *a1, const char *a2, ...)
{
  return [a1 aopDataHandler];
}

id objc_msgSend_appAccessInfoMap(void *a1, const char *a2, ...)
{
  return [a1 appAccessInfoMap];
}

id objc_msgSend_appID(void *a1, const char *a2, ...)
{
  return [a1 appID];
}

id objc_msgSend_appearanceValue(void *a1, const char *a2, ...)
{
  return [a1 appearanceValue];
}

id objc_msgSend_applePayloadType(void *a1, const char *a2, ...)
{
  return [a1 applePayloadType];
}

id objc_msgSend_appleTypes(void *a1, const char *a2, ...)
{
  return [a1 appleTypes];
}

id objc_msgSend_applicationIdentifier(void *a1, const char *a2, ...)
{
  return [a1 applicationIdentifier];
}

id objc_msgSend_arguments(void *a1, const char *a2, ...)
{
  return [a1 arguments];
}

id objc_msgSend_array(void *a1, const char *a2, ...)
{
  return [a1 array];
}

id objc_msgSend_assertionFlags(void *a1, const char *a2, ...)
{
  return [a1 assertionFlags];
}

id objc_msgSend_assetId(void *a1, const char *a2, ...)
{
  return [a1 assetId];
}

id objc_msgSend_attributeInternalFlags(void *a1, const char *a2, ...)
{
  return [a1 attributeInternalFlags];
}

id objc_msgSend_attributes(void *a1, const char *a2, ...)
{
  return [a1 attributes];
}

id objc_msgSend_audioRouteHidden(void *a1, const char *a2, ...)
{
  return [a1 audioRouteHidden];
}

id objc_msgSend_audioStreamState(void *a1, const char *a2, ...)
{
  return [a1 audioStreamState];
}

id objc_msgSend_autoANCCapability(void *a1, const char *a2, ...)
{
  return [a1 autoANCCapability];
}

id objc_msgSend_autoANCStrength(void *a1, const char *a2, ...)
{
  return [a1 autoANCStrength];
}

id objc_msgSend_autoAncCapability(void *a1, const char *a2, ...)
{
  return [a1 autoAncCapability];
}

id objc_msgSend_automotive(void *a1, const char *a2, ...)
{
  return [a1 automotive];
}

id objc_msgSend_autoupdatingCurrentCalendar(void *a1, const char *a2, ...)
{
  return [a1 autoupdatingCurrentCalendar];
}

id objc_msgSend_availableDevices(void *a1, const char *a2, ...)
{
  return [a1 availableDevices];
}

id objc_msgSend_bars(void *a1, const char *a2, ...)
{
  return [a1 bars];
}

id objc_msgSend_batteryInfoCase(void *a1, const char *a2, ...)
{
  return [a1 batteryInfoCase];
}

id objc_msgSend_batteryInfoLeft(void *a1, const char *a2, ...)
{
  return [a1 batteryInfoLeft];
}

id objc_msgSend_batteryInfoMain(void *a1, const char *a2, ...)
{
  return [a1 batteryInfoMain];
}

id objc_msgSend_batteryInfoRight(void *a1, const char *a2, ...)
{
  return [a1 batteryInfoRight];
}

id objc_msgSend_batteryLevelCase(void *a1, const char *a2, ...)
{
  return [a1 batteryLevelCase];
}

id objc_msgSend_batteryLevelLeft(void *a1, const char *a2, ...)
{
  return [a1 batteryLevelLeft];
}

id objc_msgSend_batteryLevelRight(void *a1, const char *a2, ...)
{
  return [a1 batteryLevelRight];
}

id objc_msgSend_batteryStateCase(void *a1, const char *a2, ...)
{
  return [a1 batteryStateCase];
}

id objc_msgSend_batteryStateLeft(void *a1, const char *a2, ...)
{
  return [a1 batteryStateLeft];
}

id objc_msgSend_batteryStateMain(void *a1, const char *a2, ...)
{
  return [a1 batteryStateMain];
}

id objc_msgSend_batteryStateRight(void *a1, const char *a2, ...)
{
  return [a1 batteryStateRight];
}

id objc_msgSend_beaconIdentifier(void *a1, const char *a2, ...)
{
  return [a1 beaconIdentifier];
}

id objc_msgSend_bleAdvRSSI(void *a1, const char *a2, ...)
{
  return [a1 bleAdvRSSI];
}

id objc_msgSend_bleAdvertiserClass(void *a1, const char *a2, ...)
{
  return [a1 bleAdvertiserClass];
}

id objc_msgSend_bleRSSI(void *a1, const char *a2, ...)
{
  return [a1 bleRSSI];
}

id objc_msgSend_bleRSSIThresholdHint(void *a1, const char *a2, ...)
{
  return [a1 bleRSSIThresholdHint];
}

id objc_msgSend_bleRSSIThresholdOrder(void *a1, const char *a2, ...)
{
  return [a1 bleRSSIThresholdOrder];
}

id objc_msgSend_bleScanRate(void *a1, const char *a2, ...)
{
  return [a1 bleScanRate];
}

id objc_msgSend_bleScanRateOverride(void *a1, const char *a2, ...)
{
  return [a1 bleScanRateOverride];
}

id objc_msgSend_bleScanRateScreenOff(void *a1, const char *a2, ...)
{
  return [a1 bleScanRateScreenOff];
}

id objc_msgSend_bleScannerClass(void *a1, const char *a2, ...)
{
  return [a1 bleScannerClass];
}

id objc_msgSend_bleSensorEnableRssiIncreaseScan(void *a1, const char *a2, ...)
{
  return [a1 bleSensorEnableRssiIncreaseScan];
}

id objc_msgSend_bleSensorIncreaseScanRate(void *a1, const char *a2, ...)
{
  return [a1 bleSensorIncreaseScanRate];
}

id objc_msgSend_bleSensorIncreaseScanTimeout(void *a1, const char *a2, ...)
{
  return [a1 bleSensorIncreaseScanTimeout];
}

id objc_msgSend_bleSensorRssiIncreaseScanThreshold(void *a1, const char *a2, ...)
{
  return [a1 bleSensorRssiIncreaseScanThreshold];
}

id objc_msgSend_bleSensorTimeoutBetweenIncreaseScan(void *a1, const char *a2, ...)
{
  return [a1 bleSensorTimeoutBetweenIncreaseScan];
}

id objc_msgSend_blob(void *a1, const char *a2, ...)
{
  return [a1 blob];
}

id objc_msgSend_blobData(void *a1, const char *a2, ...)
{
  return [a1 blobData];
}

id objc_msgSend_bluetoothAddress(void *a1, const char *a2, ...)
{
  return [a1 bluetoothAddress];
}

id objc_msgSend_bluetoothAddressKey(void *a1, const char *a2, ...)
{
  return [a1 bluetoothAddressKey];
}

id objc_msgSend_bluetoothDevices(void *a1, const char *a2, ...)
{
  return [a1 bluetoothDevices];
}

id objc_msgSend_bluetoothIdentifier(void *a1, const char *a2, ...)
{
  return [a1 bluetoothIdentifier];
}

id objc_msgSend_bluetoothModificationAllowed(void *a1, const char *a2, ...)
{
  return [a1 bluetoothModificationAllowed];
}

id objc_msgSend_bluetoothNameKey(void *a1, const char *a2, ...)
{
  return [a1 bluetoothNameKey];
}

id objc_msgSend_bluetoothStateChangedHandler(void *a1, const char *a2, ...)
{
  return [a1 bluetoothStateChangedHandler];
}

id objc_msgSend_bobbleCapability(void *a1, const char *a2, ...)
{
  return [a1 bobbleCapability];
}

id objc_msgSend_BOOLValue(void *a1, const char *a2, ...)
{
  return [a1 BOOLValue];
}

id objc_msgSend_browserState(void *a1, const char *a2, ...)
{
  return [a1 browserState];
}

id objc_msgSend_browserToAdvNwToSFendpoints(void *a1, const char *a2, ...)
{
  return [a1 browserToAdvNwToSFendpoints];
}

id objc_msgSend_browserToAdvUuidToSFendpoints(void *a1, const char *a2, ...)
{
  return [a1 browserToAdvUuidToSFendpoints];
}

id objc_msgSend_btAddress(void *a1, const char *a2, ...)
{
  return [a1 btAddress];
}

id objc_msgSend_btAddressData(void *a1, const char *a2, ...)
{
  return [a1 btAddressData];
}

id objc_msgSend_btAddressType(void *a1, const char *a2, ...)
{
  return [a1 btAddressType];
}

id objc_msgSend_btSessionHandle(void *a1, const char *a2, ...)
{
  return [a1 btSessionHandle];
}

id objc_msgSend_btVersion(void *a1, const char *a2, ...)
{
  return [a1 btVersion];
}

id objc_msgSend_btvcLinkClient(void *a1, const char *a2, ...)
{
  return [a1 btvcLinkClient];
}

id objc_msgSend_budsFirmwareVersion(void *a1, const char *a2, ...)
{
  return [a1 budsFirmwareVersion];
}

id objc_msgSend_bundleID(void *a1, const char *a2, ...)
{
  return [a1 bundleID];
}

id objc_msgSend_bundleId(void *a1, const char *a2, ...)
{
  return [a1 bundleId];
}

id objc_msgSend_bundleIdentifier(void *a1, const char *a2, ...)
{
  return [a1 bundleIdentifier];
}

id objc_msgSend_bundleIdentifiers(void *a1, const char *a2, ...)
{
  return [a1 bundleIdentifiers];
}

id objc_msgSend_buttonModes(void *a1, const char *a2, ...)
{
  return [a1 buttonModes];
}

id objc_msgSend_bytes(void *a1, const char *a2, ...)
{
  return [a1 bytes];
}

id objc_msgSend_callMgmtMsg(void *a1, const char *a2, ...)
{
  return [a1 callMgmtMsg];
}

id objc_msgSend_callServicesClientCapabilities(void *a1, const char *a2, ...)
{
  return [a1 callServicesClientCapabilities];
}

id objc_msgSend_calls(void *a1, const char *a2, ...)
{
  return [a1 calls];
}

id objc_msgSend_cancel(void *a1, const char *a2, ...)
{
  return [a1 cancel];
}

id objc_msgSend_caseFirmwareVersion(void *a1, const char *a2, ...)
{
  return [a1 caseFirmwareVersion];
}

id objc_msgSend_caseName(void *a1, const char *a2, ...)
{
  return [a1 caseName];
}

id objc_msgSend_caseSerialNumber(void *a1, const char *a2, ...)
{
  return [a1 caseSerialNumber];
}

id objc_msgSend_caseSoundCapability(void *a1, const char *a2, ...)
{
  return [a1 caseSoundCapability];
}

id objc_msgSend_caseVersion(void *a1, const char *a2, ...)
{
  return [a1 caseVersion];
}

id objc_msgSend_cbPeripheralManagementSession(void *a1, const char *a2, ...)
{
  return [a1 cbPeripheralManagementSession];
}

id objc_msgSend_change(void *a1, const char *a2, ...)
{
  return [a1 change];
}

id objc_msgSend_changeFlags(void *a1, const char *a2, ...)
{
  return [a1 changeFlags];
}

id objc_msgSend_changedTypesNeedsIdentify(void *a1, const char *a2, ...)
{
  return [a1 changedTypesNeedsIdentify];
}

id objc_msgSend_changedTypesRemoveAll(void *a1, const char *a2, ...)
{
  return [a1 changedTypesRemoveAll];
}

id objc_msgSend_charValue(void *a1, const char *a2, ...)
{
  return [a1 charValue];
}

id objc_msgSend_chipsetID(void *a1, const char *a2, ...)
{
  return [a1 chipsetID];
}

id objc_msgSend_city(void *a1, const char *a2, ...)
{
  return [a1 city];
}

id objc_msgSend_classicRSSI(void *a1, const char *a2, ...)
{
  return [a1 classicRSSI];
}

id objc_msgSend_classicScannerClass(void *a1, const char *a2, ...)
{
  return [a1 classicScannerClass];
}

id objc_msgSend_clearAllDatabases(void *a1, const char *a2, ...)
{
  return [a1 clearAllDatabases];
}

id objc_msgSend_clickHoldModeLeft(void *a1, const char *a2, ...)
{
  return [a1 clickHoldModeLeft];
}

id objc_msgSend_clickHoldModeRight(void *a1, const char *a2, ...)
{
  return [a1 clickHoldModeRight];
}

id objc_msgSend_clientBundleID(void *a1, const char *a2, ...)
{
  return [a1 clientBundleID];
}

id objc_msgSend_clientID(void *a1, const char *a2, ...)
{
  return [a1 clientID];
}

id objc_msgSend_clientIdentifierData(void *a1, const char *a2, ...)
{
  return [a1 clientIdentifierData];
}

id objc_msgSend_clientIrkData(void *a1, const char *a2, ...)
{
  return [a1 clientIrkData];
}

id objc_msgSend_clientProcessID(void *a1, const char *a2, ...)
{
  return [a1 clientProcessID];
}

id objc_msgSend_close(void *a1, const char *a2, ...)
{
  return [a1 close];
}

id objc_msgSend_cloudClient(void *a1, const char *a2, ...)
{
  return [a1 cloudClient];
}

id objc_msgSend_cloudSyncStatus(void *a1, const char *a2, ...)
{
  return [a1 cloudSyncStatus];
}

id objc_msgSend_code(void *a1, const char *a2, ...)
{
  return [a1 code];
}

id objc_msgSend_coexUsage(void *a1, const char *a2, ...)
{
  return [a1 coexUsage];
}

id objc_msgSend_color(void *a1, const char *a2, ...)
{
  return [a1 color];
}

id objc_msgSend_colorInfo(void *a1, const char *a2, ...)
{
  return [a1 colorInfo];
}

id objc_msgSend_completedFlags(void *a1, const char *a2, ...)
{
  return [a1 completedFlags];
}

id objc_msgSend_completionHandler(void *a1, const char *a2, ...)
{
  return [a1 completionHandler];
}

id objc_msgSend_confidence(void *a1, const char *a2, ...)
{
  return [a1 confidence];
}

id objc_msgSend_configureXPCListener(void *a1, const char *a2, ...)
{
  return [a1 configureXPCListener];
}

id objc_msgSend_connectTimeoutSeconds(void *a1, const char *a2, ...)
{
  return [a1 connectTimeoutSeconds];
}

id objc_msgSend_connectable(void *a1, const char *a2, ...)
{
  return [a1 connectable];
}

id objc_msgSend_connectableAddressData(void *a1, const char *a2, ...)
{
  return [a1 connectableAddressData];
}

id objc_msgSend_connectedAccessories(void *a1, const char *a2, ...)
{
  return [a1 connectedAccessories];
}

id objc_msgSend_connectedDeviceCount(void *a1, const char *a2, ...)
{
  return [a1 connectedDeviceCount];
}

id objc_msgSend_connectedServices(void *a1, const char *a2, ...)
{
  return [a1 connectedServices];
}

id objc_msgSend_connectedTime(void *a1, const char *a2, ...)
{
  return [a1 connectedTime];
}

id objc_msgSend_connectingClients(void *a1, const char *a2, ...)
{
  return [a1 connectingClients];
}

id objc_msgSend_connectingToPANServices(void *a1, const char *a2, ...)
{
  return [a1 connectingToPANServices];
}

id objc_msgSend_connection(void *a1, const char *a2, ...)
{
  return [a1 connection];
}

id objc_msgSend_connectionAlerts(void *a1, const char *a2, ...)
{
  return [a1 connectionAlerts];
}

id objc_msgSend_connectionFlags(void *a1, const char *a2, ...)
{
  return [a1 connectionFlags];
}

id objc_msgSend_connectionHandle(void *a1, const char *a2, ...)
{
  return [a1 connectionHandle];
}

id objc_msgSend_connectionUUID(void *a1, const char *a2, ...)
{
  return [a1 connectionUUID];
}

id objc_msgSend_connectionUseCase(void *a1, const char *a2, ...)
{
  return [a1 connectionUseCase];
}

id objc_msgSend_contact(void *a1, const char *a2, ...)
{
  return [a1 contact];
}

id objc_msgSend_contactProperty(void *a1, const char *a2, ...)
{
  return [a1 contactProperty];
}

id objc_msgSend_contactType(void *a1, const char *a2, ...)
{
  return [a1 contactType];
}

id objc_msgSend_controlFlags(void *a1, const char *a2, ...)
{
  return [a1 controlFlags];
}

id objc_msgSend_controllerClass(void *a1, const char *a2, ...)
{
  return [a1 controllerClass];
}

id objc_msgSend_controllerDataChangedHandler(void *a1, const char *a2, ...)
{
  return [a1 controllerDataChangedHandler];
}

id objc_msgSend_controllerID(void *a1, const char *a2, ...)
{
  return [a1 controllerID];
}

id objc_msgSend_controllerInfo(void *a1, const char *a2, ...)
{
  return [a1 controllerInfo];
}

id objc_msgSend_conversationDetectCapability(void *a1, const char *a2, ...)
{
  return [a1 conversationDetectCapability];
}

id objc_msgSend_conversationDetectConfig(void *a1, const char *a2, ...)
{
  return [a1 conversationDetectConfig];
}

id objc_msgSend_copy(void *a1, const char *a2, ...)
{
  return [a1 copy];
}

id objc_msgSend_count(void *a1, const char *a2, ...)
{
  return [a1 count];
}

id objc_msgSend_country(void *a1, const char *a2, ...)
{
  return [a1 country];
}

id objc_msgSend_countryCode(void *a1, const char *a2, ...)
{
  return [a1 countryCode];
}

id objc_msgSend_createConnectionParameters(void *a1, const char *a2, ...)
{
  return [a1 createConnectionParameters];
}

id objc_msgSend_crownRotationDirection(void *a1, const char *a2, ...)
{
  return [a1 crownRotationDirection];
}

id objc_msgSend_ctClient(void *a1, const char *a2, ...)
{
  return [a1 ctClient];
}

id objc_msgSend_ctServerConnection(void *a1, const char *a2, ...)
{
  return [a1 ctServerConnection];
}

id objc_msgSend_ctkdChosenTransport(void *a1, const char *a2, ...)
{
  return [a1 ctkdChosenTransport];
}

id objc_msgSend_currentAudioAndVideoCalls(void *a1, const char *a2, ...)
{
  return [a1 currentAudioAndVideoCalls];
}

id objc_msgSend_currentCalendar(void *a1, const char *a2, ...)
{
  return [a1 currentCalendar];
}

id objc_msgSend_currentEstimates(void *a1, const char *a2, ...)
{
  return [a1 currentEstimates];
}

id objc_msgSend_currentHandler(void *a1, const char *a2, ...)
{
  return [a1 currentHandler];
}

id objc_msgSend_currentIDSUser(void *a1, const char *a2, ...)
{
  return [a1 currentIDSUser];
}

id objc_msgSend_currentLocale(void *a1, const char *a2, ...)
{
  return [a1 currentLocale];
}

id objc_msgSend_currentRoute(void *a1, const char *a2, ...)
{
  return [a1 currentRoute];
}

id objc_msgSend_currentState(void *a1, const char *a2, ...)
{
  return [a1 currentState];
}

id objc_msgSend_currentStoreType(void *a1, const char *a2, ...)
{
  return [a1 currentStoreType];
}

id objc_msgSend_currentUserRandomAddress(void *a1, const char *a2, ...)
{
  return [a1 currentUserRandomAddress];
}

id objc_msgSend_cycling(void *a1, const char *a2, ...)
{
  return [a1 cycling];
}

id objc_msgSend_daemonServer(void *a1, const char *a2, ...)
{
  return [a1 daemonServer];
}

id objc_msgSend_data(void *a1, const char *a2, ...)
{
  return [a1 data];
}

id objc_msgSend_databaseContainerURL(void *a1, const char *a2, ...)
{
  return [a1 databaseContainerURL];
}

id objc_msgSend_databaseIdentifier(void *a1, const char *a2, ...)
{
  return [a1 databaseIdentifier];
}

id objc_msgSend_date(void *a1, const char *a2, ...)
{
  return [a1 date];
}

id objc_msgSend_day(void *a1, const char *a2, ...)
{
  return [a1 day];
}

id objc_msgSend_debugDescription(void *a1, const char *a2, ...)
{
  return [a1 debugDescription];
}

id objc_msgSend_decimalDigitCharacterSet(void *a1, const char *a2, ...)
{
  return [a1 decimalDigitCharacterSet];
}

id objc_msgSend_defaultCStringEncoding(void *a1, const char *a2, ...)
{
  return [a1 defaultCStringEncoding];
}

id objc_msgSend_defaultCenter(void *a1, const char *a2, ...)
{
  return [a1 defaultCenter];
}

id objc_msgSend_defaultManager(void *a1, const char *a2, ...)
{
  return [a1 defaultManager];
}

id objc_msgSend_defaultWorkspace(void *a1, const char *a2, ...)
{
  return [a1 defaultWorkspace];
}

id objc_msgSend_delay(void *a1, const char *a2, ...)
{
  return [a1 delay];
}

id objc_msgSend_delegate(void *a1, const char *a2, ...)
{
  return [a1 delegate];
}

id objc_msgSend_denyLowPowerModeScans(void *a1, const char *a2, ...)
{
  return [a1 denyLowPowerModeScans];
}

id objc_msgSend_denyScreenLockedScans(void *a1, const char *a2, ...)
{
  return [a1 denyScreenLockedScans];
}

id objc_msgSend_departmentName(void *a1, const char *a2, ...)
{
  return [a1 departmentName];
}

id objc_msgSend_description(void *a1, const char *a2, ...)
{
  return [a1 description];
}

id objc_msgSend_descriptionInternalDebug(void *a1, const char *a2, ...)
{
  return [a1 descriptionInternalDebug];
}

id objc_msgSend_device(void *a1, const char *a2, ...)
{
  return [a1 device];
}

id objc_msgSend_deviceControllerMap(void *a1, const char *a2, ...)
{
  return [a1 deviceControllerMap];
}

id objc_msgSend_deviceDidConnectHandler(void *a1, const char *a2, ...)
{
  return [a1 deviceDidConnectHandler];
}

id objc_msgSend_deviceDidDisconnectHandler(void *a1, const char *a2, ...)
{
  return [a1 deviceDidDisconnectHandler];
}

id objc_msgSend_deviceDidReceiveDataHandler(void *a1, const char *a2, ...)
{
  return [a1 deviceDidReceiveDataHandler];
}

id objc_msgSend_deviceDidStartScanning(void *a1, const char *a2, ...)
{
  return [a1 deviceDidStartScanning];
}

id objc_msgSend_deviceDidStopScanning(void *a1, const char *a2, ...)
{
  return [a1 deviceDidStopScanning];
}

id objc_msgSend_deviceFilter(void *a1, const char *a2, ...)
{
  return [a1 deviceFilter];
}

id objc_msgSend_deviceFlags(void *a1, const char *a2, ...)
{
  return [a1 deviceFlags];
}

id objc_msgSend_deviceFlagsMask(void *a1, const char *a2, ...)
{
  return [a1 deviceFlagsMask];
}

id objc_msgSend_deviceFlagsValue(void *a1, const char *a2, ...)
{
  return [a1 deviceFlagsValue];
}

id objc_msgSend_deviceFoundHandler(void *a1, const char *a2, ...)
{
  return [a1 deviceFoundHandler];
}

id objc_msgSend_deviceIDFeatureBitsV1(void *a1, const char *a2, ...)
{
  return [a1 deviceIDFeatureBitsV1];
}

id objc_msgSend_deviceIDFeatureBitsV2(void *a1, const char *a2, ...)
{
  return [a1 deviceIDFeatureBitsV2];
}

id objc_msgSend_deviceIRKData(void *a1, const char *a2, ...)
{
  return [a1 deviceIRKData];
}

id objc_msgSend_deviceList(void *a1, const char *a2, ...)
{
  return [a1 deviceList];
}

id objc_msgSend_deviceLostHandler(void *a1, const char *a2, ...)
{
  return [a1 deviceLostHandler];
}

id objc_msgSend_deviceMap(void *a1, const char *a2, ...)
{
  return [a1 deviceMap];
}

id objc_msgSend_deviceMonitorClass(void *a1, const char *a2, ...)
{
  return [a1 deviceMonitorClass];
}

id objc_msgSend_deviceName(void *a1, const char *a2, ...)
{
  return [a1 deviceName];
}

id objc_msgSend_deviceOrientationBlocking(void *a1, const char *a2, ...)
{
  return [a1 deviceOrientationBlocking];
}

id objc_msgSend_deviceSetupState(void *a1, const char *a2, ...)
{
  return [a1 deviceSetupState];
}

id objc_msgSend_deviceType(void *a1, const char *a2, ...)
{
  return [a1 deviceType];
}

id objc_msgSend_deviceUUID(void *a1, const char *a2, ...)
{
  return [a1 deviceUUID];
}

id objc_msgSend_devicesBufferedHandler(void *a1, const char *a2, ...)
{
  return [a1 devicesBufferedHandler];
}

id objc_msgSend_dictionary(void *a1, const char *a2, ...)
{
  return [a1 dictionary];
}

id objc_msgSend_dictionaryRepresentation(void *a1, const char *a2, ...)
{
  return [a1 dictionaryRepresentation];
}

id objc_msgSend_didConnectHandler(void *a1, const char *a2, ...)
{
  return [a1 didConnectHandler];
}

id objc_msgSend_didDisconnectHandler(void *a1, const char *a2, ...)
{
  return [a1 didDisconnectHandler];
}

id objc_msgSend_didReceiveDataHandler(void *a1, const char *a2, ...)
{
  return [a1 didReceiveDataHandler];
}

id objc_msgSend_disableHIP(void *a1, const char *a2, ...)
{
  return [a1 disableHIP];
}

id objc_msgSend_disableLeGATT(void *a1, const char *a2, ...)
{
  return [a1 disableLeGATT];
}

id objc_msgSend_disabledActive(void *a1, const char *a2, ...)
{
  return [a1 disabledActive];
}

id objc_msgSend_disabledPending(void *a1, const char *a2, ...)
{
  return [a1 disabledPending];
}

id objc_msgSend_disconnectCurrentCallAndActivateHeld(void *a1, const char *a2, ...)
{
  return [a1 disconnectCurrentCallAndActivateHeld];
}

id objc_msgSend_disconnectionAlerts(void *a1, const char *a2, ...)
{
  return [a1 disconnectionAlerts];
}

id objc_msgSend_discoverableState(void *a1, const char *a2, ...)
{
  return [a1 discoverableState];
}

id objc_msgSend_discoverableStateChangedHandler(void *a1, const char *a2, ...)
{
  return [a1 discoverableStateChangedHandler];
}

id objc_msgSend_discoveredDevices(void *a1, const char *a2, ...)
{
  return [a1 discoveredDevices];
}

id objc_msgSend_discoveryArray(void *a1, const char *a2, ...)
{
  return [a1 discoveryArray];
}

id objc_msgSend_discoveryFlags(void *a1, const char *a2, ...)
{
  return [a1 discoveryFlags];
}

id objc_msgSend_discoveryInfo(void *a1, const char *a2, ...)
{
  return [a1 discoveryInfo];
}

id objc_msgSend_discoveryTypesInternalPtr(void *a1, const char *a2, ...)
{
  return [a1 discoveryTypesInternalPtr];
}

id objc_msgSend_discoveryTypesPtr(void *a1, const char *a2, ...)
{
  return [a1 discoveryTypesPtr];
}

id objc_msgSend_dispatchQueue(void *a1, const char *a2, ...)
{
  return [a1 dispatchQueue];
}

id objc_msgSend_displayName(void *a1, const char *a2, ...)
{
  return [a1 displayName];
}

id objc_msgSend_doubleTapActionLeft(void *a1, const char *a2, ...)
{
  return [a1 doubleTapActionLeft];
}

id objc_msgSend_doubleTapActionRight(void *a1, const char *a2, ...)
{
  return [a1 doubleTapActionRight];
}

id objc_msgSend_doubleTapCapability(void *a1, const char *a2, ...)
{
  return [a1 doubleTapCapability];
}

id objc_msgSend_doubleValue(void *a1, const char *a2, ...)
{
  return [a1 doubleValue];
}

id objc_msgSend_droppedAdvertisementCount(void *a1, const char *a2, ...)
{
  return [a1 droppedAdvertisementCount];
}

id objc_msgSend_dsActionFlags(void *a1, const char *a2, ...)
{
  return [a1 dsActionFlags];
}

id objc_msgSend_dsActionMeasuredPower(void *a1, const char *a2, ...)
{
  return [a1 dsActionMeasuredPower];
}

id objc_msgSend_dsActionTieBreaker(void *a1, const char *a2, ...)
{
  return [a1 dsActionTieBreaker];
}

id objc_msgSend_dsInfoVehicleConfidence(void *a1, const char *a2, ...)
{
  return [a1 dsInfoVehicleConfidence];
}

id objc_msgSend_dsInfoVehicleState(void *a1, const char *a2, ...)
{
  return [a1 dsInfoVehicleState];
}

id objc_msgSend_dumpDaemonState(void *a1, const char *a2, ...)
{
  return [a1 dumpDaemonState];
}

id objc_msgSend_duplicateCount(void *a1, const char *a2, ...)
{
  return [a1 duplicateCount];
}

id objc_msgSend_dynamicAlgorithmEnabled(void *a1, const char *a2, ...)
{
  return [a1 dynamicAlgorithmEnabled];
}

id objc_msgSend_dynamicThrottleDownAdvDensity(void *a1, const char *a2, ...)
{
  return [a1 dynamicThrottleDownAdvDensity];
}

id objc_msgSend_dynamicThrottleDownDuration(void *a1, const char *a2, ...)
{
  return [a1 dynamicThrottleDownDuration];
}

id objc_msgSend_dynamicThrottleDownRSSI(void *a1, const char *a2, ...)
{
  return [a1 dynamicThrottleDownRSSI];
}

id objc_msgSend_earTipFitTestCapability(void *a1, const char *a2, ...)
{
  return [a1 earTipFitTestCapability];
}

id objc_msgSend_elements(void *a1, const char *a2, ...)
{
  return [a1 elements];
}

id objc_msgSend_emailAddresses(void *a1, const char *a2, ...)
{
  return [a1 emailAddresses];
}

id objc_msgSend_enableAutoReconnect(void *a1, const char *a2, ...)
{
  return [a1 enableAutoReconnect];
}

id objc_msgSend_enableControllerBTClockUpdates(void *a1, const char *a2, ...)
{
  return [a1 enableControllerBTClockUpdates];
}

id objc_msgSend_enableEPAForLEAdvertisement(void *a1, const char *a2, ...)
{
  return [a1 enableEPAForLEAdvertisement];
}

id objc_msgSend_enableHearingAidGainSwipe(void *a1, const char *a2, ...)
{
  return [a1 enableHearingAidGainSwipe];
}

id objc_msgSend_enableHearingAssist(void *a1, const char *a2, ...)
{
  return [a1 enableHearingAssist];
}

id objc_msgSend_enableHeartRateMonitor(void *a1, const char *a2, ...)
{
  return [a1 enableHeartRateMonitor];
}

id objc_msgSend_enableScanCore(void *a1, const char *a2, ...)
{
  return [a1 enableScanCore];
}

id objc_msgSend_enableSiriMultitone(void *a1, const char *a2, ...)
{
  return [a1 enableSiriMultitone];
}

id objc_msgSend_enableTransportBridging(void *a1, const char *a2, ...)
{
  return [a1 enableTransportBridging];
}

id objc_msgSend_encodedData(void *a1, const char *a2, ...)
{
  return [a1 encodedData];
}

id objc_msgSend_encryptionKey(void *a1, const char *a2, ...)
{
  return [a1 encryptionKey];
}

id objc_msgSend_endCallConfig(void *a1, const char *a2, ...)
{
  return [a1 endCallConfig];
}

id objc_msgSend_endpointUUID(void *a1, const char *a2, ...)
{
  return [a1 endpointUUID];
}

id objc_msgSend_entitlements(void *a1, const char *a2, ...)
{
  return [a1 entitlements];
}

id objc_msgSend_entries(void *a1, const char *a2, ...)
{
  return [a1 entries];
}

id objc_msgSend_environment(void *a1, const char *a2, ...)
{
  return [a1 environment];
}

id objc_msgSend_error(void *a1, const char *a2, ...)
{
  return [a1 error];
}

id objc_msgSend_estimatedConnections(void *a1, const char *a2, ...)
{
  return [a1 estimatedConnections];
}

id objc_msgSend_estimatedConnectionsLastUpdatedTicks(void *a1, const char *a2, ...)
{
  return [a1 estimatedConnectionsLastUpdatedTicks];
}

id objc_msgSend_eventConfiguration(void *a1, const char *a2, ...)
{
  return [a1 eventConfiguration];
}

id objc_msgSend_eventType(void *a1, const char *a2, ...)
{
  return [a1 eventType];
}

id objc_msgSend_extensionsDaemon(void *a1, const char *a2, ...)
{
  return [a1 extensionsDaemon];
}

id objc_msgSend_extraDiscoveryFlags(void *a1, const char *a2, ...)
{
  return [a1 extraDiscoveryFlags];
}

id objc_msgSend_failedDirect(void *a1, const char *a2, ...)
{
  return [a1 failedDirect];
}

id objc_msgSend_fakeNonConnectableAddressData(void *a1, const char *a2, ...)
{
  return [a1 fakeNonConnectableAddressData];
}

id objc_msgSend_familyName(void *a1, const char *a2, ...)
{
  return [a1 familyName];
}

id objc_msgSend_fastLEConnectionAllowed(void *a1, const char *a2, ...)
{
  return [a1 fastLEConnectionAllowed];
}

id objc_msgSend_fastLEConnectionInfoData(void *a1, const char *a2, ...)
{
  return [a1 fastLEConnectionInfoData];
}

id objc_msgSend_fastLEConnectionInfoVersion(void *a1, const char *a2, ...)
{
  return [a1 fastLEConnectionInfoVersion];
}

id objc_msgSend_fetchManateeStatus(void *a1, const char *a2, ...)
{
  return [a1 fetchManateeStatus];
}

id objc_msgSend_fetchSoundProfile(void *a1, const char *a2, ...)
{
  return [a1 fetchSoundProfile];
}

id objc_msgSend_fidoPayloadData(void *a1, const char *a2, ...)
{
  return [a1 fidoPayloadData];
}

id objc_msgSend_filepath(void *a1, const char *a2, ...)
{
  return [a1 filepath];
}

id objc_msgSend_filter(void *a1, const char *a2, ...)
{
  return [a1 filter];
}

id objc_msgSend_findMyCaseIdentifier(void *a1, const char *a2, ...)
{
  return [a1 findMyCaseIdentifier];
}

id objc_msgSend_findMyGroupIdentifier(void *a1, const char *a2, ...)
{
  return [a1 findMyGroupIdentifier];
}

id objc_msgSend_firmwareName(void *a1, const char *a2, ...)
{
  return [a1 firmwareName];
}

id objc_msgSend_firmwareRevision(void *a1, const char *a2, ...)
{
  return [a1 firmwareRevision];
}

id objc_msgSend_firmwareRevisionActive(void *a1, const char *a2, ...)
{
  return [a1 firmwareRevisionActive];
}

id objc_msgSend_firmwareRevisionPending(void *a1, const char *a2, ...)
{
  return [a1 firmwareRevisionPending];
}

id objc_msgSend_firmwareVersion(void *a1, const char *a2, ...)
{
  return [a1 firmwareVersion];
}

id objc_msgSend_firstObject(void *a1, const char *a2, ...)
{
  return [a1 firstObject];
}

id objc_msgSend_firstUnlocked(void *a1, const char *a2, ...)
{
  return [a1 firstUnlocked];
}

id objc_msgSend_firstUnlockedSync(void *a1, const char *a2, ...)
{
  return [a1 firstUnlockedSync];
}

id objc_msgSend_flags(void *a1, const char *a2, ...)
{
  return [a1 flags];
}

id objc_msgSend_floatValue(void *a1, const char *a2, ...)
{
  return [a1 floatValue];
}

id objc_msgSend_flushCache(void *a1, const char *a2, ...)
{
  return [a1 flushCache];
}

id objc_msgSend_frequencyBand(void *a1, const char *a2, ...)
{
  return [a1 frequencyBand];
}

id objc_msgSend_freshResult(void *a1, const char *a2, ...)
{
  return [a1 freshResult];
}

id objc_msgSend_gapaFlags(void *a1, const char *a2, ...)
{
  return [a1 gapaFlags];
}

id objc_msgSend_generateKeys(void *a1, const char *a2, ...)
{
  return [a1 generateKeys];
}

id objc_msgSend_getAccessibilityHeadtrackingEnabled(void *a1, const char *a2, ...)
{
  return [a1 getAccessibilityHeadtrackingEnabled];
}

id objc_msgSend_getAccountStatus(void *a1, const char *a2, ...)
{
  return [a1 getAccountStatus];
}

id objc_msgSend_getAudioAccessoryDeviceArray(void *a1, const char *a2, ...)
{
  return [a1 getAudioAccessoryDeviceArray];
}

id objc_msgSend_getAudioSkywalkProvider(void *a1, const char *a2, ...)
{
  return [a1 getAudioSkywalkProvider];
}

id objc_msgSend_getClientBundleIDs(void *a1, const char *a2, ...)
{
  return [a1 getClientBundleIDs];
}

id objc_msgSend_getCountryCode(void *a1, const char *a2, ...)
{
  return [a1 getCountryCode];
}

id objc_msgSend_getCountryCodeIdentifer(void *a1, const char *a2, ...)
{
  return [a1 getCountryCodeIdentifer];
}

id objc_msgSend_getLocalFileUrl(void *a1, const char *a2, ...)
{
  return [a1 getLocalFileUrl];
}

id objc_msgSend_getLocalUrl(void *a1, const char *a2, ...)
{
  return [a1 getLocalUrl];
}

id objc_msgSend_getRegistrationStatus(void *a1, const char *a2, ...)
{
  return [a1 getRegistrationStatus];
}

id objc_msgSend_getUniqueServiceNameForAdvertiser(void *a1, const char *a2, ...)
{
  return [a1 getUniqueServiceNameForAdvertiser];
}

id objc_msgSend_getXpcQueue(void *a1, const char *a2, ...)
{
  return [a1 getXpcQueue];
}

id objc_msgSend_givenName(void *a1, const char *a2, ...)
{
  return [a1 givenName];
}

id objc_msgSend_groupIdentifier(void *a1, const char *a2, ...)
{
  return [a1 groupIdentifier];
}

id objc_msgSend_handle(void *a1, const char *a2, ...)
{
  return [a1 handle];
}

id objc_msgSend_hardwareRevision(void *a1, const char *a2, ...)
{
  return [a1 hardwareRevision];
}

id objc_msgSend_hardwareVersion(void *a1, const char *a2, ...)
{
  return [a1 hardwareVersion];
}

id objc_msgSend_hasSentInvitation(void *a1, const char *a2, ...)
{
  return [a1 hasSentInvitation];
}

id objc_msgSend_hash(void *a1, const char *a2, ...)
{
  return [a1 hash];
}

id objc_msgSend_hciTransportType(void *a1, const char *a2, ...)
{
  return [a1 hciTransportType];
}

id objc_msgSend_hearingAidCapability(void *a1, const char *a2, ...)
{
  return [a1 hearingAidCapability];
}

id objc_msgSend_hearingAidConfig(void *a1, const char *a2, ...)
{
  return [a1 hearingAidConfig];
}

id objc_msgSend_hearingAidEnrolled(void *a1, const char *a2, ...)
{
  return [a1 hearingAidEnrolled];
}

id objc_msgSend_hearingAidGainSwipeEnabled(void *a1, const char *a2, ...)
{
  return [a1 hearingAidGainSwipeEnabled];
}

id objc_msgSend_hearingAidSupport(void *a1, const char *a2, ...)
{
  return [a1 hearingAidSupport];
}

id objc_msgSend_hearingAidToggle(void *a1, const char *a2, ...)
{
  return [a1 hearingAidToggle];
}

id objc_msgSend_hearingAssistEnabled(void *a1, const char *a2, ...)
{
  return [a1 hearingAssistEnabled];
}

id objc_msgSend_hearingProtectionCapability(void *a1, const char *a2, ...)
{
  return [a1 hearingProtectionCapability];
}

id objc_msgSend_hearingTestCapability(void *a1, const char *a2, ...)
{
  return [a1 hearingTestCapability];
}

id objc_msgSend_hearingTestSupport(void *a1, const char *a2, ...)
{
  return [a1 hearingTestSupport];
}

id objc_msgSend_heartRateMonitorEnabled(void *a1, const char *a2, ...)
{
  return [a1 heartRateMonitorEnabled];
}

id objc_msgSend_heySiriConfidence(void *a1, const char *a2, ...)
{
  return [a1 heySiriConfidence];
}

id objc_msgSend_heySiriDeviceClass(void *a1, const char *a2, ...)
{
  return [a1 heySiriDeviceClass];
}

id objc_msgSend_heySiriPerceptualHash(void *a1, const char *a2, ...)
{
  return [a1 heySiriPerceptualHash];
}

id objc_msgSend_heySiriProductType(void *a1, const char *a2, ...)
{
  return [a1 heySiriProductType];
}

id objc_msgSend_heySiriRandom(void *a1, const char *a2, ...)
{
  return [a1 heySiriRandom];
}

id objc_msgSend_heySiriSNR(void *a1, const char *a2, ...)
{
  return [a1 heySiriSNR];
}

id objc_msgSend_hid3ppLELegacyMode(void *a1, const char *a2, ...)
{
  return [a1 hid3ppLELegacyMode];
}

id objc_msgSend_hideEarDetectionCapability(void *a1, const char *a2, ...)
{
  return [a1 hideEarDetectionCapability];
}

id objc_msgSend_hideFromBTSettings(void *a1, const char *a2, ...)
{
  return [a1 hideFromBTSettings];
}

id objc_msgSend_hideOffListeningModeCapability(void *a1, const char *a2, ...)
{
  return [a1 hideOffListeningModeCapability];
}

id objc_msgSend_hostMap(void *a1, const char *a2, ...)
{
  return [a1 hostMap];
}

id objc_msgSend_hour(void *a1, const char *a2, ...)
{
  return [a1 hour];
}

id objc_msgSend_iCloudSignedIn(void *a1, const char *a2, ...)
{
  return [a1 iCloudSignedIn];
}

id objc_msgSend_iOSLegacyIdentifier(void *a1, const char *a2, ...)
{
  return [a1 iOSLegacyIdentifier];
}

id objc_msgSend_identifier(void *a1, const char *a2, ...)
{
  return [a1 identifier];
}

id objc_msgSend_identifierData(void *a1, const char *a2, ...)
{
  return [a1 identifierData];
}

id objc_msgSend_identityArray(void *a1, const char *a2, ...)
{
  return [a1 identityArray];
}

id objc_msgSend_idsDeviceID(void *a1, const char *a2, ...)
{
  return [a1 idsDeviceID];
}

id objc_msgSend_idsDeviceIdentifier(void *a1, const char *a2, ...)
{
  return [a1 idsDeviceIdentifier];
}

id objc_msgSend_infoDictionary(void *a1, const char *a2, ...)
{
  return [a1 infoDictionary];
}

id objc_msgSend_init(void *a1, const char *a2, ...)
{
  return [a1 init];
}

id objc_msgSend_initPHYs(void *a1, const char *a2, ...)
{
  return [a1 initPHYs];
}

id objc_msgSend_inquiryState(void *a1, const char *a2, ...)
{
  return [a1 inquiryState];
}

id objc_msgSend_inquiryStateChangedHandler(void *a1, const char *a2, ...)
{
  return [a1 inquiryStateChangedHandler];
}

id objc_msgSend_instance(void *a1, const char *a2, ...)
{
  return [a1 instance];
}

id objc_msgSend_intValue(void *a1, const char *a2, ...)
{
  return [a1 intValue];
}

id objc_msgSend_integerValue(void *a1, const char *a2, ...)
{
  return [a1 integerValue];
}

id objc_msgSend_interestedBundleIDs(void *a1, const char *a2, ...)
{
  return [a1 interestedBundleIDs];
}

id objc_msgSend_internalFlags(void *a1, const char *a2, ...)
{
  return [a1 internalFlags];
}

id objc_msgSend_interval(void *a1, const char *a2, ...)
{
  return [a1 interval];
}

id objc_msgSend_invalidRssiHandling(void *a1, const char *a2, ...)
{
  return [a1 invalidRssiHandling];
}

id objc_msgSend_invalidate(void *a1, const char *a2, ...)
{
  return [a1 invalidate];
}

id objc_msgSend_invalidateAssertionTimer(void *a1, const char *a2, ...)
{
  return [a1 invalidateAssertionTimer];
}

id objc_msgSend_invalidateDirect(void *a1, const char *a2, ...)
{
  return [a1 invalidateDirect];
}

id objc_msgSend_invertedSet(void *a1, const char *a2, ...)
{
  return [a1 invertedSet];
}

id objc_msgSend_irk(void *a1, const char *a2, ...)
{
  return [a1 irk];
}

id objc_msgSend_irkData(void *a1, const char *a2, ...)
{
  return [a1 irkData];
}

id objc_msgSend_isAdvToBrowserConnection(void *a1, const char *a2, ...)
{
  return [a1 isAdvToBrowserConnection];
}

id objc_msgSend_isAlive(void *a1, const char *a2, ...)
{
  return [a1 isAlive];
}

id objc_msgSend_isAlwaysOnEnabled(void *a1, const char *a2, ...)
{
  return [a1 isAlwaysOnEnabled];
}

id objc_msgSend_isApp(void *a1, const char *a2, ...)
{
  return [a1 isApp];
}

id objc_msgSend_isBluetoothModificationAllowed(void *a1, const char *a2, ...)
{
  return [a1 isBluetoothModificationAllowed];
}

id objc_msgSend_isConferenced(void *a1, const char *a2, ...)
{
  return [a1 isConferenced];
}

id objc_msgSend_isConnected(void *a1, const char *a2, ...)
{
  return [a1 isConnected];
}

id objc_msgSend_isHoldAndAnswerAllowed(void *a1, const char *a2, ...)
{
  return [a1 isHoldAndAnswerAllowed];
}

id objc_msgSend_isLatencyCritical(void *a1, const char *a2, ...)
{
  return [a1 isLatencyCritical];
}

id objc_msgSend_isLocked(void *a1, const char *a2, ...)
{
  return [a1 isLocked];
}

id objc_msgSend_isLowPowerModeEnabled(void *a1, const char *a2, ...)
{
  return [a1 isLowPowerModeEnabled];
}

id objc_msgSend_isMultiUser(void *a1, const char *a2, ...)
{
  return [a1 isMultiUser];
}

id objc_msgSend_isOutgoing(void *a1, const char *a2, ...)
{
  return [a1 isOutgoing];
}

id objc_msgSend_isRestrictedCharacteristicsAccessAllowed(void *a1, const char *a2, ...)
{
  return [a1 isRestrictedCharacteristicsAccessAllowed];
}

id objc_msgSend_isRunningInRecovery(void *a1, const char *a2, ...)
{
  return [a1 isRunningInRecovery];
}

id objc_msgSend_isScanningEnabled(void *a1, const char *a2, ...)
{
  return [a1 isScanningEnabled];
}

id objc_msgSend_isScreening(void *a1, const char *a2, ...)
{
  return [a1 isScreening];
}

id objc_msgSend_isValid(void *a1, const char *a2, ...)
{
  return [a1 isValid];
}

id objc_msgSend_jobTitle(void *a1, const char *a2, ...)
{
  return [a1 jobTitle];
}

id objc_msgSend_keepAlive(void *a1, const char *a2, ...)
{
  return [a1 keepAlive];
}

id objc_msgSend_keyEnumerator(void *a1, const char *a2, ...)
{
  return [a1 keyEnumerator];
}

id objc_msgSend_keyLength(void *a1, const char *a2, ...)
{
  return [a1 keyLength];
}

id objc_msgSend_keyType(void *a1, const char *a2, ...)
{
  return [a1 keyType];
}

id objc_msgSend_label(void *a1, const char *a2, ...)
{
  return [a1 label];
}

id objc_msgSend_lastConnectedLEMAC(void *a1, const char *a2, ...)
{
  return [a1 lastConnectedLEMAC];
}

id objc_msgSend_lastKnownEstimates(void *a1, const char *a2, ...)
{
  return [a1 lastKnownEstimates];
}

id objc_msgSend_lastObject(void *a1, const char *a2, ...)
{
  return [a1 lastObject];
}

id objc_msgSend_lastPathComponent(void *a1, const char *a2, ...)
{
  return [a1 lastPathComponent];
}

id objc_msgSend_lastSeenTicks(void *a1, const char *a2, ...)
{
  return [a1 lastSeenTicks];
}

id objc_msgSend_leftBudSerialNumber(void *a1, const char *a2, ...)
{
  return [a1 leftBudSerialNumber];
}

id objc_msgSend_length(void *a1, const char *a2, ...)
{
  return [a1 length];
}

id objc_msgSend_listener(void *a1, const char *a2, ...)
{
  return [a1 listener];
}

id objc_msgSend_listeningMode(void *a1, const char *a2, ...)
{
  return [a1 listeningMode];
}

id objc_msgSend_listeningModeConfigs(void *a1, const char *a2, ...)
{
  return [a1 listeningModeConfigs];
}

id objc_msgSend_listeningServices(void *a1, const char *a2, ...)
{
  return [a1 listeningServices];
}

id objc_msgSend_listeningServicesV2(void *a1, const char *a2, ...)
{
  return [a1 listeningServicesV2];
}

id objc_msgSend_localDevice(void *a1, const char *a2, ...)
{
  return [a1 localDevice];
}

id objc_msgSend_localTimeZone(void *a1, const char *a2, ...)
{
  return [a1 localTimeZone];
}

id objc_msgSend_localeIdentifier(void *a1, const char *a2, ...)
{
  return [a1 localeIdentifier];
}

id objc_msgSend_localizations(void *a1, const char *a2, ...)
{
  return [a1 localizations];
}

id objc_msgSend_localizedDescription(void *a1, const char *a2, ...)
{
  return [a1 localizedDescription];
}

id objc_msgSend_lockState(void *a1, const char *a2, ...)
{
  return [a1 lockState];
}

id objc_msgSend_logAsset(void *a1, const char *a2, ...)
{
  return [a1 logAsset];
}

id objc_msgSend_longLongValue(void *a1, const char *a2, ...)
{
  return [a1 longLongValue];
}

id objc_msgSend_longTermKeyMap(void *a1, const char *a2, ...)
{
  return [a1 longTermKeyMap];
}

id objc_msgSend_longValue(void *a1, const char *a2, ...)
{
  return [a1 longValue];
}

id objc_msgSend_lowercaseString(void *a1, const char *a2, ...)
{
  return [a1 lowercaseString];
}

id objc_msgSend_macAddress(void *a1, const char *a2, ...)
{
  return [a1 macAddress];
}

id objc_msgSend_mainQueue(void *a1, const char *a2, ...)
{
  return [a1 mainQueue];
}

id objc_msgSend_mainRunLoop(void *a1, const char *a2, ...)
{
  return [a1 mainRunLoop];
}

id objc_msgSend_managedByFindMy(void *a1, const char *a2, ...)
{
  return [a1 managedByFindMy];
}

id objc_msgSend_manufacturer(void *a1, const char *a2, ...)
{
  return [a1 manufacturer];
}

id objc_msgSend_mask(void *a1, const char *a2, ...)
{
  return [a1 mask];
}

id objc_msgSend_maskData(void *a1, const char *a2, ...)
{
  return [a1 maskData];
}

id objc_msgSend_masterHint(void *a1, const char *a2, ...)
{
  return [a1 masterHint];
}

id objc_msgSend_masterKey(void *a1, const char *a2, ...)
{
  return [a1 masterKey];
}

id objc_msgSend_maxAllowedConnectionDelay(void *a1, const char *a2, ...)
{
  return [a1 maxAllowedConnectionDelay];
}

id objc_msgSend_maxConnectedDevices(void *a1, const char *a2, ...)
{
  return [a1 maxConnectedDevices];
}

id objc_msgSend_maxSeenDevices(void *a1, const char *a2, ...)
{
  return [a1 maxSeenDevices];
}

id objc_msgSend_memoryPressureFlags(void *a1, const char *a2, ...)
{
  return [a1 memoryPressureFlags];
}

id objc_msgSend_mergeTemporaryStores(void *a1, const char *a2, ...)
{
  return [a1 mergeTemporaryStores];
}

id objc_msgSend_microphoneMode(void *a1, const char *a2, ...)
{
  return [a1 microphoneMode];
}

id objc_msgSend_middleName(void *a1, const char *a2, ...)
{
  return [a1 middleName];
}

id objc_msgSend_minRSSILevelForConnection(void *a1, const char *a2, ...)
{
  return [a1 minRSSILevelForConnection];
}

id objc_msgSend_minute(void *a1, const char *a2, ...)
{
  return [a1 minute];
}

id objc_msgSend_mixesVoiceWithMedia(void *a1, const char *a2, ...)
{
  return [a1 mixesVoiceWithMedia];
}

id objc_msgSend_model(void *a1, const char *a2, ...)
{
  return [a1 model];
}

id objc_msgSend_modelNumber(void *a1, const char *a2, ...)
{
  return [a1 modelNumber];
}

id objc_msgSend_modelUser(void *a1, const char *a2, ...)
{
  return [a1 modelUser];
}

id objc_msgSend_mrcEnable(void *a1, const char *a2, ...)
{
  return [a1 mrcEnable];
}

id objc_msgSend_msgId(void *a1, const char *a2, ...)
{
  return [a1 msgId];
}

id objc_msgSend_multipleAdvInitialized(void *a1, const char *a2, ...)
{
  return [a1 multipleAdvInitialized];
}

id objc_msgSend_mutableBytes(void *a1, const char *a2, ...)
{
  return [a1 mutableBytes];
}

id objc_msgSend_mutableCopy(void *a1, const char *a2, ...)
{
  return [a1 mutableCopy];
}

id objc_msgSend_muteControlConfig(void *a1, const char *a2, ...)
{
  return [a1 muteControlConfig];
}

id objc_msgSend_myNumber(void *a1, const char *a2, ...)
{
  return [a1 myNumber];
}

id objc_msgSend_name(void *a1, const char *a2, ...)
{
  return [a1 name];
}

id objc_msgSend_namePrefix(void *a1, const char *a2, ...)
{
  return [a1 namePrefix];
}

id objc_msgSend_nameSuffix(void *a1, const char *a2, ...)
{
  return [a1 nameSuffix];
}

id objc_msgSend_nearbyActionAuthTagData(void *a1, const char *a2, ...)
{
  return [a1 nearbyActionAuthTagData];
}

id objc_msgSend_nearbyActionExtraData(void *a1, const char *a2, ...)
{
  return [a1 nearbyActionExtraData];
}

id objc_msgSend_nearbyActionFlags(void *a1, const char *a2, ...)
{
  return [a1 nearbyActionFlags];
}

id objc_msgSend_nearbyActionNWPrecisionFindingStatus(void *a1, const char *a2, ...)
{
  return [a1 nearbyActionNWPrecisionFindingStatus];
}

id objc_msgSend_nearbyActionNoWakeAuthTagData(void *a1, const char *a2, ...)
{
  return [a1 nearbyActionNoWakeAuthTagData];
}

id objc_msgSend_nearbyActionNoWakeConfigData(void *a1, const char *a2, ...)
{
  return [a1 nearbyActionNoWakeConfigData];
}

id objc_msgSend_nearbyActionNoWakeType(void *a1, const char *a2, ...)
{
  return [a1 nearbyActionNoWakeType];
}

id objc_msgSend_nearbyActionTargetData(void *a1, const char *a2, ...)
{
  return [a1 nearbyActionTargetData];
}

id objc_msgSend_nearbyActionType(void *a1, const char *a2, ...)
{
  return [a1 nearbyActionType];
}

id objc_msgSend_nearbyActionV2Flags(void *a1, const char *a2, ...)
{
  return [a1 nearbyActionV2Flags];
}

id objc_msgSend_nearbyActionV2TargetData(void *a1, const char *a2, ...)
{
  return [a1 nearbyActionV2TargetData];
}

id objc_msgSend_nearbyActionV2Type(void *a1, const char *a2, ...)
{
  return [a1 nearbyActionV2Type];
}

id objc_msgSend_nearbyAuthTag(void *a1, const char *a2, ...)
{
  return [a1 nearbyAuthTag];
}

id objc_msgSend_nearbyInfoFlags(void *a1, const char *a2, ...)
{
  return [a1 nearbyInfoFlags];
}

id objc_msgSend_nearbyInfoStatusProgress(void *a1, const char *a2, ...)
{
  return [a1 nearbyInfoStatusProgress];
}

id objc_msgSend_nearbyInfoStatusTime(void *a1, const char *a2, ...)
{
  return [a1 nearbyInfoStatusTime];
}

id objc_msgSend_nearbyInfoStatusType(void *a1, const char *a2, ...)
{
  return [a1 nearbyInfoStatusType];
}

id objc_msgSend_nearbyInfoV2AuthIntegrityTagData(void *a1, const char *a2, ...)
{
  return [a1 nearbyInfoV2AuthIntegrityTagData];
}

id objc_msgSend_nearbyInfoV2AuthTagData(void *a1, const char *a2, ...)
{
  return [a1 nearbyInfoV2AuthTagData];
}

id objc_msgSend_nearbyInfoV2DecryptedFlags(void *a1, const char *a2, ...)
{
  return [a1 nearbyInfoV2DecryptedFlags];
}

id objc_msgSend_nearbyInfoV2EncryptedData(void *a1, const char *a2, ...)
{
  return [a1 nearbyInfoV2EncryptedData];
}

id objc_msgSend_nearbyInfoV2EncryptedFlags(void *a1, const char *a2, ...)
{
  return [a1 nearbyInfoV2EncryptedFlags];
}

id objc_msgSend_nearbyInfoV2Flags(void *a1, const char *a2, ...)
{
  return [a1 nearbyInfoV2Flags];
}

id objc_msgSend_nearbyInfoV2InvitationCounter(void *a1, const char *a2, ...)
{
  return [a1 nearbyInfoV2InvitationCounter];
}

id objc_msgSend_nearbyInfoV2InvitationRouteType(void *a1, const char *a2, ...)
{
  return [a1 nearbyInfoV2InvitationRouteType];
}

id objc_msgSend_nearbyInfoV2RapportIRKData(void *a1, const char *a2, ...)
{
  return [a1 nearbyInfoV2RapportIRKData];
}

id objc_msgSend_needsAdvertisingAddress(void *a1, const char *a2, ...)
{
  return [a1 needsAdvertisingAddress];
}

id objc_msgSend_needsBLEScan(void *a1, const char *a2, ...)
{
  return [a1 needsBLEScan];
}

id objc_msgSend_needsIdentify(void *a1, const char *a2, ...)
{
  return [a1 needsIdentify];
}

id objc_msgSend_needsToRun(void *a1, const char *a2, ...)
{
  return [a1 needsToRun];
}

id objc_msgSend_nextObject(void *a1, const char *a2, ...)
{
  return [a1 nextObject];
}

id objc_msgSend_nickname(void *a1, const char *a2, ...)
{
  return [a1 nickname];
}

id objc_msgSend_nonConnectableAddressData(void *a1, const char *a2, ...)
{
  return [a1 nonConnectableAddressData];
}

id objc_msgSend_nonConnectableSecondaryAddressData(void *a1, const char *a2, ...)
{
  return [a1 nonConnectableSecondaryAddressData];
}

id objc_msgSend_notification(void *a1, const char *a2, ...)
{
  return [a1 notification];
}

id objc_msgSend_notificationAlerts(void *a1, const char *a2, ...)
{
  return [a1 notificationAlerts];
}

id objc_msgSend_now(void *a1, const char *a2, ...)
{
  return [a1 now];
}

id objc_msgSend_null(void *a1, const char *a2, ...)
{
  return [a1 null];
}

id objc_msgSend_numLEConnection(void *a1, const char *a2, ...)
{
  return [a1 numLEConnection];
}

id objc_msgSend_numberOfRanges(void *a1, const char *a2, ...)
{
  return [a1 numberOfRanges];
}

id objc_msgSend_object(void *a1, const char *a2, ...)
{
  return [a1 object];
}

id objc_msgSend_objectEnumerator(void *a1, const char *a2, ...)
{
  return [a1 objectEnumerator];
}

id objc_msgSend_oldDiscoveryFlags(void *a1, const char *a2, ...)
{
  return [a1 oldDiscoveryFlags];
}

id objc_msgSend_oldResult(void *a1, const char *a2, ...)
{
  return [a1 oldResult];
}

id objc_msgSend_oobKeys(void *a1, const char *a2, ...)
{
  return [a1 oobKeys];
}

id objc_msgSend_open(void *a1, const char *a2, ...)
{
  return [a1 open];
}

id objc_msgSend_operatingSystemVersionString(void *a1, const char *a2, ...)
{
  return [a1 operatingSystemVersionString];
}

id objc_msgSend_opportunistic(void *a1, const char *a2, ...)
{
  return [a1 opportunistic];
}

id objc_msgSend_optimizedBatteryCharging(void *a1, const char *a2, ...)
{
  return [a1 optimizedBatteryCharging];
}

id objc_msgSend_optimizedBatteryFullChargeDeadline(void *a1, const char *a2, ...)
{
  return [a1 optimizedBatteryFullChargeDeadline];
}

id objc_msgSend_organizationName(void *a1, const char *a2, ...)
{
  return [a1 organizationName];
}

id objc_msgSend_orientation(void *a1, const char *a2, ...)
{
  return [a1 orientation];
}

id objc_msgSend_outputs(void *a1, const char *a2, ...)
{
  return [a1 outputs];
}

id objc_msgSend_ownerSession(void *a1, const char *a2, ...)
{
  return [a1 ownerSession];
}

id objc_msgSend_pairingCompletedHandler(void *a1, const char *a2, ...)
{
  return [a1 pairingCompletedHandler];
}

id objc_msgSend_pairingPromptHandler(void *a1, const char *a2, ...)
{
  return [a1 pairingPromptHandler];
}

id objc_msgSend_pairingType(void *a1, const char *a2, ...)
{
  return [a1 pairingType];
}

id objc_msgSend_partIdentifier(void *a1, const char *a2, ...)
{
  return [a1 partIdentifier];
}

id objc_msgSend_passkey(void *a1, const char *a2, ...)
{
  return [a1 passkey];
}

id objc_msgSend_path(void *a1, const char *a2, ...)
{
  return [a1 path];
}

id objc_msgSend_peerDevice(void *a1, const char *a2, ...)
{
  return [a1 peerDevice];
}

id objc_msgSend_peerID(void *a1, const char *a2, ...)
{
  return [a1 peerID];
}

id objc_msgSend_phoneNumber(void *a1, const char *a2, ...)
{
  return [a1 phoneNumber];
}

id objc_msgSend_phoneNumbers(void *a1, const char *a2, ...)
{
  return [a1 phoneNumbers];
}

id objc_msgSend_phoneticFamilyName(void *a1, const char *a2, ...)
{
  return [a1 phoneticFamilyName];
}

id objc_msgSend_phoneticGivenName(void *a1, const char *a2, ...)
{
  return [a1 phoneticGivenName];
}

id objc_msgSend_pid(void *a1, const char *a2, ...)
{
  return [a1 pid];
}

id objc_msgSend_pin(void *a1, const char *a2, ...)
{
  return [a1 pin];
}

id objc_msgSend_pipeHandle(void *a1, const char *a2, ...)
{
  return [a1 pipeHandle];
}

id objc_msgSend_placementMode(void *a1, const char *a2, ...)
{
  return [a1 placementMode];
}

id objc_msgSend_portType(void *a1, const char *a2, ...)
{
  return [a1 portType];
}

id objc_msgSend_postalAddresses(void *a1, const char *a2, ...)
{
  return [a1 postalAddresses];
}

id objc_msgSend_postalCode(void *a1, const char *a2, ...)
{
  return [a1 postalCode];
}

id objc_msgSend_powerSourceUpdate(void *a1, const char *a2, ...)
{
  return [a1 powerSourceUpdate];
}

id objc_msgSend_powerState(void *a1, const char *a2, ...)
{
  return [a1 powerState];
}

id objc_msgSend_poweredOn(void *a1, const char *a2, ...)
{
  return [a1 poweredOn];
}

id objc_msgSend_prefCBExtensionRSSIOverride(void *a1, const char *a2, ...)
{
  return [a1 prefCBExtensionRSSIOverride];
}

id objc_msgSend_prefEnforceApprovedExtensions(void *a1, const char *a2, ...)
{
  return [a1 prefEnforceApprovedExtensions];
}

id objc_msgSend_prefEnforceApprovedList(void *a1, const char *a2, ...)
{
  return [a1 prefEnforceApprovedList];
}

id objc_msgSend_prefFilterNearbyActionExtraData(void *a1, const char *a2, ...)
{
  return [a1 prefFilterNearbyActionExtraData];
}

id objc_msgSend_prefSystemReferenceTimeDisabled(void *a1, const char *a2, ...)
{
  return [a1 prefSystemReferenceTimeDisabled];
}

id objc_msgSend_prefWiProxAdvertising(void *a1, const char *a2, ...)
{
  return [a1 prefWiProxAdvertising];
}

id objc_msgSend_preferredLanguages(void *a1, const char *a2, ...)
{
  return [a1 preferredLanguages];
}

id objc_msgSend_prefsChanged(void *a1, const char *a2, ...)
{
  return [a1 prefsChanged];
}

id objc_msgSend_presenceConfigData(void *a1, const char *a2, ...)
{
  return [a1 presenceConfigData];
}

id objc_msgSend_present(void *a1, const char *a2, ...)
{
  return [a1 present];
}

id objc_msgSend_primaryBudSide(void *a1, const char *a2, ...)
{
  return [a1 primaryBudSide];
}

id objc_msgSend_primaryCBDevice(void *a1, const char *a2, ...)
{
  return [a1 primaryCBDevice];
}

id objc_msgSend_primaryFolderVersions(void *a1, const char *a2, ...)
{
  return [a1 primaryFolderVersions];
}

id objc_msgSend_primaryPlacement(void *a1, const char *a2, ...)
{
  return [a1 primaryPlacement];
}

id objc_msgSend_printDebug(void *a1, const char *a2, ...)
{
  return [a1 printDebug];
}

id objc_msgSend_processInfo(void *a1, const char *a2, ...)
{
  return [a1 processInfo];
}

id objc_msgSend_productID(void *a1, const char *a2, ...)
{
  return [a1 productID];
}

id objc_msgSend_productName(void *a1, const char *a2, ...)
{
  return [a1 productName];
}

id objc_msgSend_proximityPairingProductID(void *a1, const char *a2, ...)
{
  return [a1 proximityPairingProductID];
}

id objc_msgSend_publicAddress(void *a1, const char *a2, ...)
{
  return [a1 publicAddress];
}

id objc_msgSend_punctuationCharacterSet(void *a1, const char *a2, ...)
{
  return [a1 punctuationCharacterSet];
}

id objc_msgSend_purgeAllStoresInActiveDatabasePath(void *a1, const char *a2, ...)
{
  return [a1 purgeAllStoresInActiveDatabasePath];
}

id objc_msgSend_randomUUID(void *a1, const char *a2, ...)
{
  return [a1 randomUUID];
}

id objc_msgSend_ratchet(void *a1, const char *a2, ...)
{
  return [a1 ratchet];
}

id objc_msgSend_reason(void *a1, const char *a2, ...)
{
  return [a1 reason];
}

id objc_msgSend_receiveNextMessage(void *a1, const char *a2, ...)
{
  return [a1 receiveNextMessage];
}

id objc_msgSend_registrationDisplayStatus(void *a1, const char *a2, ...)
{
  return [a1 registrationDisplayStatus];
}

id objc_msgSend_relayMessageHandler(void *a1, const char *a2, ...)
{
  return [a1 relayMessageHandler];
}

id objc_msgSend_relinquishAudioRoute(void *a1, const char *a2, ...)
{
  return [a1 relinquishAudioRoute];
}

id objc_msgSend_remoteAdvDataSet(void *a1, const char *a2, ...)
{
  return [a1 remoteAdvDataSet];
}

id objc_msgSend_remoteControllersChanged(void *a1, const char *a2, ...)
{
  return [a1 remoteControllersChanged];
}

id objc_msgSend_remoteDevice(void *a1, const char *a2, ...)
{
  return [a1 remoteDevice];
}

id objc_msgSend_remoteEndpoint(void *a1, const char *a2, ...)
{
  return [a1 remoteEndpoint];
}

id objc_msgSend_remoteHostID(void *a1, const char *a2, ...)
{
  return [a1 remoteHostID];
}

id objc_msgSend_remoteUniqueIDString(void *a1, const char *a2, ...)
{
  return [a1 remoteUniqueIDString];
}

id objc_msgSend_removeAllObjects(void *a1, const char *a2, ...)
{
  return [a1 removeAllObjects];
}

id objc_msgSend_removeLastObject(void *a1, const char *a2, ...)
{
  return [a1 removeLastObject];
}

id objc_msgSend_republishAllAudioDevices(void *a1, const char *a2, ...)
{
  return [a1 republishAllAudioDevices];
}

id objc_msgSend_request(void *a1, const char *a2, ...)
{
  return [a1 request];
}

id objc_msgSend_requestFlags(void *a1, const char *a2, ...)
{
  return [a1 requestFlags];
}

id objc_msgSend_requiresLowLatency(void *a1, const char *a2, ...)
{
  return [a1 requiresLowLatency];
}

id objc_msgSend_reset(void *a1, const char *a2, ...)
{
  return [a1 reset];
}

id objc_msgSend_resetDisconnectionHistory(void *a1, const char *a2, ...)
{
  return [a1 resetDisconnectionHistory];
}

id objc_msgSend_resetNearbyInfoV2SensitiveProperties(void *a1, const char *a2, ...)
{
  return [a1 resetNearbyInfoV2SensitiveProperties];
}

id objc_msgSend_resetServerConnection(void *a1, const char *a2, ...)
{
  return [a1 resetServerConnection];
}

id objc_msgSend_response(void *a1, const char *a2, ...)
{
  return [a1 response];
}

id objc_msgSend_resultChanges(void *a1, const char *a2, ...)
{
  return [a1 resultChanges];
}

id objc_msgSend_results(void *a1, const char *a2, ...)
{
  return [a1 results];
}

id objc_msgSend_reverseObjectEnumerator(void *a1, const char *a2, ...)
{
  return [a1 reverseObjectEnumerator];
}

id objc_msgSend_rightBudSerialNumber(void *a1, const char *a2, ...)
{
  return [a1 rightBudSerialNumber];
}

id objc_msgSend_roaming(void *a1, const char *a2, ...)
{
  return [a1 roaming];
}

id objc_msgSend_roomName(void *a1, const char *a2, ...)
{
  return [a1 roomName];
}

id objc_msgSend_rssi(void *a1, const char *a2, ...)
{
  return [a1 rssi];
}

id objc_msgSend_rssiIncreaseScanIntervalThreshold(void *a1, const char *a2, ...)
{
  return [a1 rssiIncreaseScanIntervalThreshold];
}

id objc_msgSend_rssiIncreaseScanThreshold(void *a1, const char *a2, ...)
{
  return [a1 rssiIncreaseScanThreshold];
}

id objc_msgSend_rssiIncreaseScanTimeoutThreshold(void *a1, const char *a2, ...)
{
  return [a1 rssiIncreaseScanTimeoutThreshold];
}

id objc_msgSend_rssiIncreaseScanWindowThreshold(void *a1, const char *a2, ...)
{
  return [a1 rssiIncreaseScanWindowThreshold];
}

id objc_msgSend_rssiPrecision(void *a1, const char *a2, ...)
{
  return [a1 rssiPrecision];
}

id objc_msgSend_rssiPrecisionGone(void *a1, const char *a2, ...)
{
  return [a1 rssiPrecisionGone];
}

id objc_msgSend_rssiThreshold(void *a1, const char *a2, ...)
{
  return [a1 rssiThreshold];
}

id objc_msgSend_rssiThresholdGone(void *a1, const char *a2, ...)
{
  return [a1 rssiThresholdGone];
}

id objc_msgSend_running(void *a1, const char *a2, ...)
{
  return [a1 running];
}

id objc_msgSend_safetyAlertsAlertData(void *a1, const char *a2, ...)
{
  return [a1 safetyAlertsAlertData];
}

id objc_msgSend_safetyAlertsAlertID(void *a1, const char *a2, ...)
{
  return [a1 safetyAlertsAlertID];
}

id objc_msgSend_safetyAlertsSegmentSegmentNumber(void *a1, const char *a2, ...)
{
  return [a1 safetyAlertsSegmentSegmentNumber];
}

id objc_msgSend_safetyAlertsSegmentSegmentsTotal(void *a1, const char *a2, ...)
{
  return [a1 safetyAlertsSegmentSegmentsTotal];
}

id objc_msgSend_safetyAlertsSignature(void *a1, const char *a2, ...)
{
  return [a1 safetyAlertsSignature];
}

id objc_msgSend_safetyAlertsVersion(void *a1, const char *a2, ...)
{
  return [a1 safetyAlertsVersion];
}

id objc_msgSend_save(void *a1, const char *a2, ...)
{
  return [a1 save];
}

id objc_msgSend_scanRate(void *a1, const char *a2, ...)
{
  return [a1 scanRate];
}

id objc_msgSend_scanRateScreenOff(void *a1, const char *a2, ...)
{
  return [a1 scanRateScreenOff];
}

id objc_msgSend_scanRateScreenOn(void *a1, const char *a2, ...)
{
  return [a1 scanRateScreenOn];
}

id objc_msgSend_scanScreenOffCount(void *a1, const char *a2, ...)
{
  return [a1 scanScreenOffCount];
}

id objc_msgSend_scanScreenOnCount(void *a1, const char *a2, ...)
{
  return [a1 scanScreenOnCount];
}

id objc_msgSend_scanWithRetainDuplicates(void *a1, const char *a2, ...)
{
  return [a1 scanWithRetainDuplicates];
}

id objc_msgSend_sceneIdentifier(void *a1, const char *a2, ...)
{
  return [a1 sceneIdentifier];
}

id objc_msgSend_screenLocked(void *a1, const char *a2, ...)
{
  return [a1 screenLocked];
}

id objc_msgSend_screenLockedSync(void *a1, const char *a2, ...)
{
  return [a1 screenLockedSync];
}

id objc_msgSend_screenOn(void *a1, const char *a2, ...)
{
  return [a1 screenOn];
}

id objc_msgSend_screenState(void *a1, const char *a2, ...)
{
  return [a1 screenState];
}

id objc_msgSend_second(void *a1, const char *a2, ...)
{
  return [a1 second];
}

id objc_msgSend_secondaryFolderVersions(void *a1, const char *a2, ...)
{
  return [a1 secondaryFolderVersions];
}

id objc_msgSend_secondaryPlacement(void *a1, const char *a2, ...)
{
  return [a1 secondaryPlacement];
}

id objc_msgSend_secondsLeft(void *a1, const char *a2, ...)
{
  return [a1 secondsLeft];
}

id objc_msgSend_seenDeviceCount(void *a1, const char *a2, ...)
{
  return [a1 seenDeviceCount];
}

id objc_msgSend_selectiveSpeechListeningCapability(void *a1, const char *a2, ...)
{
  return [a1 selectiveSpeechListeningCapability];
}

id objc_msgSend_selectiveSpeechListeningConfig(void *a1, const char *a2, ...)
{
  return [a1 selectiveSpeechListeningConfig];
}

id objc_msgSend_selfAuthTag(void *a1, const char *a2, ...)
{
  return [a1 selfAuthTag];
}

id objc_msgSend_selfAuthTagNonConnectable(void *a1, const char *a2, ...)
{
  return [a1 selfAuthTagNonConnectable];
}

id objc_msgSend_sendCloudKitPush(void *a1, const char *a2, ...)
{
  return [a1 sendCloudKitPush];
}

id objc_msgSend_sensorTimeoutBetweenIncreaseScan(void *a1, const char *a2, ...)
{
  return [a1 sensorTimeoutBetweenIncreaseScan];
}

id objc_msgSend_serialNumber(void *a1, const char *a2, ...)
{
  return [a1 serialNumber];
}

id objc_msgSend_serialNumberLeft(void *a1, const char *a2, ...)
{
  return [a1 serialNumberLeft];
}

id objc_msgSend_serialNumberRight(void *a1, const char *a2, ...)
{
  return [a1 serialNumberRight];
}

id objc_msgSend_serialQueue(void *a1, const char *a2, ...)
{
  return [a1 serialQueue];
}

id objc_msgSend_serverConnection(void *a1, const char *a2, ...)
{
  return [a1 serverConnection];
}

id objc_msgSend_service(void *a1, const char *a2, ...)
{
  return [a1 service];
}

id objc_msgSend_serviceData(void *a1, const char *a2, ...)
{
  return [a1 serviceData];
}

id objc_msgSend_serviceFlags(void *a1, const char *a2, ...)
{
  return [a1 serviceFlags];
}

id objc_msgSend_serviceTypes(void *a1, const char *a2, ...)
{
  return [a1 serviceTypes];
}

id objc_msgSend_serviceUUID(void *a1, const char *a2, ...)
{
  return [a1 serviceUUID];
}

id objc_msgSend_serviceUUID16(void *a1, const char *a2, ...)
{
  return [a1 serviceUUID16];
}

id objc_msgSend_serviceUUIDs(void *a1, const char *a2, ...)
{
  return [a1 serviceUUIDs];
}

id objc_msgSend_serviceWithDefaultShellEndpoint(void *a1, const char *a2, ...)
{
  return [a1 serviceWithDefaultShellEndpoint];
}

id objc_msgSend_sessionHandle(void *a1, const char *a2, ...)
{
  return [a1 sessionHandle];
}

id objc_msgSend_set(void *a1, const char *a2, ...)
{
  return [a1 set];
}

id objc_msgSend_settingsMask(void *a1, const char *a2, ...)
{
  return [a1 settingsMask];
}

id objc_msgSend_setupAssistantIfNoKeyboard(void *a1, const char *a2, ...)
{
  return [a1 setupAssistantIfNoKeyboard];
}

id objc_msgSend_setupAssistantIfNoPointingDevice(void *a1, const char *a2, ...)
{
  return [a1 setupAssistantIfNoPointingDevice];
}

id objc_msgSend_sharedAccessoryManager(void *a1, const char *a2, ...)
{
  return [a1 sharedAccessoryManager];
}

id objc_msgSend_sharedBTVCLinkAgent(void *a1, const char *a2, ...)
{
  return [a1 sharedBTVCLinkAgent];
}

id objc_msgSend_sharedBacklight(void *a1, const char *a2, ...)
{
  return [a1 sharedBacklight];
}

id objc_msgSend_sharedCBMetricsDaemon(void *a1, const char *a2, ...)
{
  return [a1 sharedCBMetricsDaemon];
}

id objc_msgSend_sharedClockManager(void *a1, const char *a2, ...)
{
  return [a1 sharedClockManager];
}

id objc_msgSend_sharedConfiguration(void *a1, const char *a2, ...)
{
  return [a1 sharedConfiguration];
}

id objc_msgSend_sharedConnection(void *a1, const char *a2, ...)
{
  return [a1 sharedConnection];
}

id objc_msgSend_sharedDaemonBridge(void *a1, const char *a2, ...)
{
  return [a1 sharedDaemonBridge];
}

id objc_msgSend_sharedDefaults(void *a1, const char *a2, ...)
{
  return [a1 sharedDefaults];
}

id objc_msgSend_sharedHardwareManager(void *a1, const char *a2, ...)
{
  return [a1 sharedHardwareManager];
}

id objc_msgSend_sharedInstance(void *a1, const char *a2, ...)
{
  return [a1 sharedInstance];
}

id objc_msgSend_sharedManager(void *a1, const char *a2, ...)
{
  return [a1 sharedManager];
}

id objc_msgSend_sharedPreferences(void *a1, const char *a2, ...)
{
  return [a1 sharedPreferences];
}

id objc_msgSend_siriMultitoneCapability(void *a1, const char *a2, ...)
{
  return [a1 siriMultitoneCapability];
}

id objc_msgSend_smartRoutingMode(void *a1, const char *a2, ...)
{
  return [a1 smartRoutingMode];
}

id objc_msgSend_sortOrder(void *a1, const char *a2, ...)
{
  return [a1 sortOrder];
}

id objc_msgSend_soundProfileChanged(void *a1, const char *a2, ...)
{
  return [a1 soundProfileChanged];
}

id objc_msgSend_soundProfileData(void *a1, const char *a2, ...)
{
  return [a1 soundProfileData];
}

id objc_msgSend_source(void *a1, const char *a2, ...)
{
  return [a1 source];
}

id objc_msgSend_sourceVersion(void *a1, const char *a2, ...)
{
  return [a1 sourceVersion];
}

id objc_msgSend_spatialAudioAllowed(void *a1, const char *a2, ...)
{
  return [a1 spatialAudioAllowed];
}

id objc_msgSend_spatialAudioMode(void *a1, const char *a2, ...)
{
  return [a1 spatialAudioMode];
}

id objc_msgSend_spatialInteractionAdvertiseRate(void *a1, const char *a2, ...)
{
  return [a1 spatialInteractionAdvertiseRate];
}

id objc_msgSend_spatialInteractionConfigFlags(void *a1, const char *a2, ...)
{
  return [a1 spatialInteractionConfigFlags];
}

id objc_msgSend_spatialInteractionDeviceTimestampArrayClientIDs(void *a1, const char *a2, ...)
{
  return [a1 spatialInteractionDeviceTimestampArrayClientIDs];
}

id objc_msgSend_spatialInteractionDeviceTimestampArrayDictionary(void *a1, const char *a2, ...)
{
  return [a1 spatialInteractionDeviceTimestampArrayDictionary];
}

id objc_msgSend_spatialInteractionFlags(void *a1, const char *a2, ...)
{
  return [a1 spatialInteractionFlags];
}

id objc_msgSend_spatialInteractionIdentifiers(void *a1, const char *a2, ...)
{
  return [a1 spatialInteractionIdentifiers];
}

id objc_msgSend_spatialInteractionPeerID(void *a1, const char *a2, ...)
{
  return [a1 spatialInteractionPeerID];
}

id objc_msgSend_spatialInteractionPresenceConfigData(void *a1, const char *a2, ...)
{
  return [a1 spatialInteractionPresenceConfigData];
}

id objc_msgSend_spatialInteractionUWBConfigData(void *a1, const char *a2, ...)
{
  return [a1 spatialInteractionUWBConfigData];
}

id objc_msgSend_spatialInteractionfilter(void *a1, const char *a2, ...)
{
  return [a1 spatialInteractionfilter];
}

id objc_msgSend_spatialSoundProfileAllowed(void *a1, const char *a2, ...)
{
  return [a1 spatialSoundProfileAllowed];
}

id objc_msgSend_stableIdentifier(void *a1, const char *a2, ...)
{
  return [a1 stableIdentifier];
}

id objc_msgSend_stackBLEScanner(void *a1, const char *a2, ...)
{
  return [a1 stackBLEScanner];
}

id objc_msgSend_stackController(void *a1, const char *a2, ...)
{
  return [a1 stackController];
}

id objc_msgSend_startAssertionTimer(void *a1, const char *a2, ...)
{
  return [a1 startAssertionTimer];
}

id objc_msgSend_startDate(void *a1, const char *a2, ...)
{
  return [a1 startDate];
}

id objc_msgSend_startDirect(void *a1, const char *a2, ...)
{
  return [a1 startDirect];
}

id objc_msgSend_startDiscovery(void *a1, const char *a2, ...)
{
  return [a1 startDiscovery];
}

id objc_msgSend_startListening(void *a1, const char *a2, ...)
{
  return [a1 startListening];
}

id objc_msgSend_startListeningToPowerUIStatusChanges(void *a1, const char *a2, ...)
{
  return [a1 startListeningToPowerUIStatusChanges];
}

id objc_msgSend_startTicks(void *a1, const char *a2, ...)
{
  return [a1 startTicks];
}

id objc_msgSend_startUpServices(void *a1, const char *a2, ...)
{
  return [a1 startUpServices];
}

id objc_msgSend_state(void *a1, const char *a2, ...)
{
  return [a1 state];
}

id objc_msgSend_stationary(void *a1, const char *a2, ...)
{
  return [a1 stationary];
}

id objc_msgSend_status(void *a1, const char *a2, ...)
{
  return [a1 status];
}

id objc_msgSend_stopActivityUpdates(void *a1, const char *a2, ...)
{
  return [a1 stopActivityUpdates];
}

id objc_msgSend_stopDiscovery(void *a1, const char *a2, ...)
{
  return [a1 stopDiscovery];
}

id objc_msgSend_storedAdvertisementCount(void *a1, const char *a2, ...)
{
  return [a1 storedAdvertisementCount];
}

id objc_msgSend_streamStateAoS(void *a1, const char *a2, ...)
{
  return [a1 streamStateAoS];
}

id objc_msgSend_street(void *a1, const char *a2, ...)
{
  return [a1 street];
}

id objc_msgSend_string(void *a1, const char *a2, ...)
{
  return [a1 string];
}

id objc_msgSend_stringByDeletingPathExtension(void *a1, const char *a2, ...)
{
  return [a1 stringByDeletingPathExtension];
}

id objc_msgSend_stringValue(void *a1, const char *a2, ...)
{
  return [a1 stringValue];
}

id objc_msgSend_subjectMonitorRegistry(void *a1, const char *a2, ...)
{
  return [a1 subjectMonitorRegistry];
}

id objc_msgSend_subscribeToCoexStateUpdates(void *a1, const char *a2, ...)
{
  return [a1 subscribeToCoexStateUpdates];
}

id objc_msgSend_subscriptions(void *a1, const char *a2, ...)
{
  return [a1 subscriptions];
}

id objc_msgSend_succeededDirect(void *a1, const char *a2, ...)
{
  return [a1 succeededDirect];
}

id objc_msgSend_supportedServices(void *a1, const char *a2, ...)
{
  return [a1 supportedServices];
}

id objc_msgSend_supportsBackgroundedCentrals(void *a1, const char *a2, ...)
{
  return [a1 supportsBackgroundedCentrals];
}

id objc_msgSend_supportsBackgroundedPeripherals(void *a1, const char *a2, ...)
{
  return [a1 supportsBackgroundedPeripherals];
}

id objc_msgSend_supportsDTMF(void *a1, const char *a2, ...)
{
  return [a1 supportsDTMF];
}

id objc_msgSend_supportsHolding(void *a1, const char *a2, ...)
{
  return [a1 supportsHolding];
}

id objc_msgSend_supportsNCSecondaryAdvertisingInstance(void *a1, const char *a2, ...)
{
  return [a1 supportsNCSecondaryAdvertisingInstance];
}

id objc_msgSend_supportsUngrouping(void *a1, const char *a2, ...)
{
  return [a1 supportsUngrouping];
}

id objc_msgSend_swapCalls(void *a1, const char *a2, ...)
{
  return [a1 swapCalls];
}

id objc_msgSend_switchToCentralStore(void *a1, const char *a2, ...)
{
  return [a1 switchToCentralStore];
}

id objc_msgSend_symbolCharacterSet(void *a1, const char *a2, ...)
{
  return [a1 symbolCharacterSet];
}

id objc_msgSend_systemLockStateSync(void *a1, const char *a2, ...)
{
  return [a1 systemLockStateSync];
}

id objc_msgSend_systemOverrideFlags(void *a1, const char *a2, ...)
{
  return [a1 systemOverrideFlags];
}

id objc_msgSend_systemOverrideHandler(void *a1, const char *a2, ...)
{
  return [a1 systemOverrideHandler];
}

id objc_msgSend_systemUIFlags(void *a1, const char *a2, ...)
{
  return [a1 systemUIFlags];
}

id objc_msgSend_targetCore(void *a1, const char *a2, ...)
{
  return [a1 targetCore];
}

id objc_msgSend_telephonyProvider(void *a1, const char *a2, ...)
{
  return [a1 telephonyProvider];
}

id objc_msgSend_temporaryIRK(void *a1, const char *a2, ...)
{
  return [a1 temporaryIRK];
}

id objc_msgSend_temporaryIdentityAddress(void *a1, const char *a2, ...)
{
  return [a1 temporaryIdentityAddress];
}

id objc_msgSend_temporaryLTK(void *a1, const char *a2, ...)
{
  return [a1 temporaryLTK];
}

id objc_msgSend_temporaryStoresPresent(void *a1, const char *a2, ...)
{
  return [a1 temporaryStoresPresent];
}

id objc_msgSend_testAdvertiser(void *a1, const char *a2, ...)
{
  return [a1 testAdvertiser];
}

id objc_msgSend_testAssertion(void *a1, const char *a2, ...)
{
  return [a1 testAssertion];
}

id objc_msgSend_testDiscovery(void *a1, const char *a2, ...)
{
  return [a1 testDiscovery];
}

id objc_msgSend_thumbnailImageData(void *a1, const char *a2, ...)
{
  return [a1 thumbnailImageData];
}

id objc_msgSend_timeIntervalSince1970(void *a1, const char *a2, ...)
{
  return [a1 timeIntervalSince1970];
}

id objc_msgSend_timeIntervalSinceNow(void *a1, const char *a2, ...)
{
  return [a1 timeIntervalSinceNow];
}

id objc_msgSend_timeIntervalSinceReferenceDate(void *a1, const char *a2, ...)
{
  return [a1 timeIntervalSinceReferenceDate];
}

id objc_msgSend_timeoutSeconds(void *a1, const char *a2, ...)
{
  return [a1 timeoutSeconds];
}

id objc_msgSend_timeoutValue(void *a1, const char *a2, ...)
{
  return [a1 timeoutValue];
}

id objc_msgSend_timer(void *a1, const char *a2, ...)
{
  return [a1 timer];
}

id objc_msgSend_timestamp(void *a1, const char *a2, ...)
{
  return [a1 timestamp];
}

id objc_msgSend_tipiChangedHandler(void *a1, const char *a2, ...)
{
  return [a1 tipiChangedHandler];
}

id objc_msgSend_tokenData(void *a1, const char *a2, ...)
{
  return [a1 tokenData];
}

id objc_msgSend_triggerIfPending(void *a1, const char *a2, ...)
{
  return [a1 triggerIfPending];
}

id objc_msgSend_triggerTicks(void *a1, const char *a2, ...)
{
  return [a1 triggerTicks];
}

id objc_msgSend_triggeredDeviceMap(void *a1, const char *a2, ...)
{
  return [a1 triggeredDeviceMap];
}

id objc_msgSend_tryLoadProtectedCache(void *a1, const char *a2, ...)
{
  return [a1 tryLoadProtectedCache];
}

id objc_msgSend_tuCallCenter(void *a1, const char *a2, ...)
{
  return [a1 tuCallCenter];
}

id objc_msgSend_txPowerAuxConnectReq(void *a1, const char *a2, ...)
{
  return [a1 txPowerAuxConnectReq];
}

id objc_msgSend_txPowerConnectInd(void *a1, const char *a2, ...)
{
  return [a1 txPowerConnectInd];
}

id objc_msgSend_type(void *a1, const char *a2, ...)
{
  return [a1 type];
}

id objc_msgSend_typeToRssiThresholds(void *a1, const char *a2, ...)
{
  return [a1 typeToRssiThresholds];
}

id objc_msgSend_uiTicks(void *a1, const char *a2, ...)
{
  return [a1 uiTicks];
}

id objc_msgSend_unSubscribeFromCoexStateUpdates(void *a1, const char *a2, ...)
{
  return [a1 unSubscribeFromCoexStateUpdates];
}

id objc_msgSend_uniqueProxyIdentifier(void *a1, const char *a2, ...)
{
  return [a1 uniqueProxyIdentifier];
}

id objc_msgSend_unknown(void *a1, const char *a2, ...)
{
  return [a1 unknown];
}

id objc_msgSend_unsignedCharValue(void *a1, const char *a2, ...)
{
  return [a1 unsignedCharValue];
}

id objc_msgSend_unsignedIntValue(void *a1, const char *a2, ...)
{
  return [a1 unsignedIntValue];
}

id objc_msgSend_unsignedIntegerValue(void *a1, const char *a2, ...)
{
  return [a1 unsignedIntegerValue];
}

id objc_msgSend_unsignedLongLongValue(void *a1, const char *a2, ...)
{
  return [a1 unsignedLongLongValue];
}

id objc_msgSend_unsignedLongValue(void *a1, const char *a2, ...)
{
  return [a1 unsignedLongValue];
}

id objc_msgSend_unsignedShortValue(void *a1, const char *a2, ...)
{
  return [a1 unsignedShortValue];
}

id objc_msgSend_updateDevices(void *a1, const char *a2, ...)
{
  return [a1 updateDevices];
}

id objc_msgSend_updateProtectedCacheMetrics(void *a1, const char *a2, ...)
{
  return [a1 updateProtectedCacheMetrics];
}

id objc_msgSend_uppercaseString(void *a1, const char *a2, ...)
{
  return [a1 uppercaseString];
}

id objc_msgSend_urlAddresses(void *a1, const char *a2, ...)
{
  return [a1 urlAddresses];
}

id objc_msgSend_useCase(void *a1, const char *a2, ...)
{
  return [a1 useCase];
}

id objc_msgSend_useCaseList(void *a1, const char *a2, ...)
{
  return [a1 useCaseList];
}

id objc_msgSend_userContext(void *a1, const char *a2, ...)
{
  return [a1 userContext];
}

id objc_msgSend_userControllerClass(void *a1, const char *a2, ...)
{
  return [a1 userControllerClass];
}

id objc_msgSend_userDefaultVoice(void *a1, const char *a2, ...)
{
  return [a1 userDefaultVoice];
}

id objc_msgSend_userIdentifier(void *a1, const char *a2, ...)
{
  return [a1 userIdentifier];
}

id objc_msgSend_userInfo(void *a1, const char *a2, ...)
{
  return [a1 userInfo];
}

id objc_msgSend_utf8ValueSafe(void *a1, const char *a2, ...)
{
  return [a1 utf8ValueSafe];
}

id objc_msgSend_uwbConfigData(void *a1, const char *a2, ...)
{
  return [a1 uwbConfigData];
}

id objc_msgSend_uwbTokenFlags(void *a1, const char *a2, ...)
{
  return [a1 uwbTokenFlags];
}

id objc_msgSend_value(void *a1, const char *a2, ...)
{
  return [a1 value];
}

id objc_msgSend_vendorID(void *a1, const char *a2, ...)
{
  return [a1 vendorID];
}

id objc_msgSend_vendorIDSource(void *a1, const char *a2, ...)
{
  return [a1 vendorIDSource];
}

id objc_msgSend_version(void *a1, const char *a2, ...)
{
  return [a1 version];
}

id objc_msgSend_viewControllerClassName(void *a1, const char *a2, ...)
{
  return [a1 viewControllerClassName];
}

id objc_msgSend_voiceTriggerEnabled(void *a1, const char *a2, ...)
{
  return [a1 voiceTriggerEnabled];
}

id objc_msgSend_vseBuffering(void *a1, const char *a2, ...)
{
  return [a1 vseBuffering];
}

id objc_msgSend_waitForConnectionPoll(void *a1, const char *a2, ...)
{
  return [a1 waitForConnectionPoll];
}

id objc_msgSend_walking(void *a1, const char *a2, ...)
{
  return [a1 walking];
}

id objc_msgSend_wantsObjectDiscoveryData(void *a1, const char *a2, ...)
{
  return [a1 wantsObjectDiscoveryData];
}

id objc_msgSend_wasLocal(void *a1, const char *a2, ...)
{
  return [a1 wasLocal];
}

id objc_msgSend_watchSetupData(void *a1, const char *a2, ...)
{
  return [a1 watchSetupData];
}

id objc_msgSend_whbDeviceMap(void *a1, const char *a2, ...)
{
  return [a1 whbDeviceMap];
}

id objc_msgSend_whbDiscoveryDaemon(void *a1, const char *a2, ...)
{
  return [a1 whbDiscoveryDaemon];
}

id objc_msgSend_whbStop(void *a1, const char *a2, ...)
{
  return [a1 whbStop];
}

id objc_msgSend_whitespaceAndNewlineCharacterSet(void *a1, const char *a2, ...)
{
  return [a1 whitespaceAndNewlineCharacterSet];
}

id objc_msgSend_wifiCriticalOverride(void *a1, const char *a2, ...)
{
  return [a1 wifiCriticalOverride];
}

id objc_msgSend_wifiFlags(void *a1, const char *a2, ...)
{
  return [a1 wifiFlags];
}

id objc_msgSend_xpcCnx(void *a1, const char *a2, ...)
{
  return [a1 xpcCnx];
}

id objc_msgSend_xpcConnections(void *a1, const char *a2, ...)
{
  return [a1 xpcConnections];
}

id objc_msgSend_xpcDiscoveryInfo(void *a1, const char *a2, ...)
{
  return [a1 xpcDiscoveryInfo];
}

id objc_msgSend_xpcEventRepresentation(void *a1, const char *a2, ...)
{
  return [a1 xpcEventRepresentation];
}

id objc_msgSend_xpcListenerEndpoint(void *a1, const char *a2, ...)
{
  return [a1 xpcListenerEndpoint];
}

id objc_msgSend_xpcObjectRepresentation(void *a1, const char *a2, ...)
{
  return [a1 xpcObjectRepresentation];
}

id objc_msgSend_xpcToken(void *a1, const char *a2, ...)
{
  return [a1 xpcToken];
}