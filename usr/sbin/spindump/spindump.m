#error "100004F70: too big function (funcsize=0)"

int *sub_100020D90()
{
  if (sub_10002B86C("/var/db/.spindump_ignore_thermal_pressure")) {
    __int16 v0 = 2;
  }
  else {
    __int16 v0 = 0;
  }
  word_1000EBD38 = word_1000EBD38 & 0xFFFD | v0;
  if (qword_1000EBBE0 != -1) {
    dispatch_once(&qword_1000EBBE0, &stru_1000DD0E0);
  }
  word_1000EBD38 = word_1000EBD38 & 0xFFFE | byte_1000EBBD8;
  if (qword_1000EBBF0 != -1) {
    dispatch_once(&qword_1000EBBF0, &stru_1000DD100);
  }
  word_1000EBD38 = word_1000EBD38 & 0xFFFB | (4 * byte_1000EBBE8);
  if (qword_1000EBC00 != -1) {
    dispatch_once(&qword_1000EBC00, &stru_1000DD120);
  }
  char v1 = word_1000EBD38;
  word_1000EBD38 = word_1000EBD38 & 0xFFF7 | (8 * byte_1000EBBF8);
  if ((v1 & 4) != 0)
  {
    if (byte_1000EBCF8)
    {
      int v2 = *__error();
      v3 = sub_10002E548();
      if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Submissions suppressed", buf, 2u);
      }
      *__error() = v2;
    }
    if (byte_1000EBCF9 && dword_1000EB4A8 <= 2)
    {
      int v4 = *__error();
      CFStringRef v5 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"Submissions suppressed");
      if (v5)
      {
        CFStringRef v6 = v5;
        CStringPtr = CFStringGetCStringPtr(v5, 0x8000100u);
        if (CStringPtr)
        {
          v8 = (char *)CStringPtr;
          v9 = 0;
        }
        else
        {
          v8 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x6C895723uLL);
          CFStringGetCString(v6, v8, 1024, 0x8000100u);
          v9 = v8;
        }
        if (qword_1000EBD00) {
          v19 = (FILE *)qword_1000EBD00;
        }
        else {
          v19 = __stderrp;
        }
        fprintf(v19, "%s\n", v8);
        if (v9) {
          free(v9);
        }
        CFRelease(v6);
      }
      else
      {
        v10 = sub_10002E548();
        if (os_log_type_enabled(v10, OS_LOG_TYPE_FAULT)) {
          sub_100088E48(v10, v11, v12, v13, v14, v15, v16, v17);
        }
        if (qword_1000EBD00) {
          v18 = (FILE *)qword_1000EBD00;
        }
        else {
          v18 = __stderrp;
        }
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v18);
      }
      *__error() = v4;
    }
  }
  if ((word_1000EBD38 & 8) != 0)
  {
    if (byte_1000EBCF8)
    {
      int v20 = *__error();
      v21 = sub_10002E548();
      if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "Submissions forced enabled", buf, 2u);
      }
      *__error() = v20;
    }
    if (byte_1000EBCF9 && dword_1000EB4A8 <= 2)
    {
      int v22 = *__error();
      CFStringRef v23 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"Submissions forced enabled");
      if (v23)
      {
        CFStringRef v24 = v23;
        v25 = CFStringGetCStringPtr(v23, 0x8000100u);
        if (v25)
        {
          v26 = (char *)v25;
          v27 = 0;
        }
        else
        {
          v26 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x4DE31EA0uLL);
          CFStringGetCString(v24, v26, 1024, 0x8000100u);
          v27 = v26;
        }
        if (qword_1000EBD00) {
          v37 = (FILE *)qword_1000EBD00;
        }
        else {
          v37 = __stderrp;
        }
        fprintf(v37, "%s\n", v26);
        if (v27) {
          free(v27);
        }
        CFRelease(v24);
      }
      else
      {
        v28 = sub_10002E548();
        if (os_log_type_enabled(v28, OS_LOG_TYPE_FAULT)) {
          sub_100088E10(v28, v29, v30, v31, v32, v33, v34, v35);
        }
        if (qword_1000EBD00) {
          v36 = (FILE *)qword_1000EBD00;
        }
        else {
          v36 = __stderrp;
        }
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v36);
      }
      *__error() = v22;
    }
  }
  if (word_1000EBD38)
  {
    qword_1000EBD10 = 0x4059000000000000;
    if (byte_1000EBCF8)
    {
      int v38 = *__error();
      v39 = sub_10002E548();
      if (os_log_type_enabled(v39, OS_LOG_TYPE_INFO))
      {
        *(_DWORD *)buf = 134217984;
        *(void *)v154 = qword_1000EBD10;
        _os_log_impl((void *)&_mh_execute_header, v39, OS_LOG_TYPE_INFO, "Apple Internal: reporting full spins %.1f%% of the time", buf, 0xCu);
      }
      *__error() = v38;
    }
    if (byte_1000EBCF9 && dword_1000EB4A8 <= 1)
    {
      int v40 = *__error();
      CFStringRef v41 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"Apple Internal: reporting full spins %.1f%% of the time", qword_1000EBD10);
      if (v41)
      {
        CFStringRef v42 = v41;
        v43 = CFStringGetCStringPtr(v41, 0x8000100u);
        if (v43)
        {
          v44 = (char *)v43;
          v45 = 0;
        }
        else
        {
          v44 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x631A51D4uLL);
          CFStringGetCString(v42, v44, 1024, 0x8000100u);
          v45 = v44;
        }
        if (qword_1000EBD00) {
          v48 = (FILE *)qword_1000EBD00;
        }
        else {
          v48 = __stderrp;
        }
        fprintf(v48, "%s\n", v44);
        if (v45) {
          free(v45);
        }
        CFRelease(v42);
      }
      else
      {
        v46 = sub_10002E548();
        if (os_log_type_enabled(v46, OS_LOG_TYPE_FAULT)) {
          sub_100088D9C();
        }
        if (qword_1000EBD00) {
          v47 = (FILE *)qword_1000EBD00;
        }
        else {
          v47 = __stderrp;
        }
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v47);
      }
      *__error() = v40;
    }
  }
  else
  {
    sub_100047614(@"spindump_percent_full_spin_reports", (uint64_t)&qword_1000EBD10, 0.0);
  }
  double v49 = 25.0;
  if (word_1000EBD38) {
    double v49 = 100.0;
  }
  sub_100047614(@"io_exception_sampling_percentage", (uint64_t)&qword_1000EBD28, v49);
  double v50 = 5.0;
  if (word_1000EBD38) {
    double v50 = 100.0;
  }
  sub_100047614(@"cpu_resource_1st_party_sampling_percentage", (uint64_t)&qword_1000EBD30, v50);
  sub_100047614(@"spindump_percent_short_spins_reported", (uint64_t)&unk_1000EBD18, 10.0);
  sub_100047614(@"spindump_threshold_defining_short_spins_s", (uint64_t)&unk_1000EBD20, 2.0);
  word_1000EBD38 &= 0xFF9Fu;
  if (byte_1000EBCF8)
  {
    int v51 = *__error();
    v52 = sub_10002E548();
    if (os_log_type_enabled(v52, OS_LOG_TYPE_DEBUG)) {
      sub_100088D24();
    }
    *__error() = v51;
  }
  if (byte_1000EBCF9 && dword_1000EB4A8 <= 0)
  {
    int v53 = *__error();
    CFStringRef v54 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"Submit spins:%d hangs:%d unavilable on this platform", ((unsigned __int16)word_1000EBD38 >> 5) & 1, ((unsigned __int16)word_1000EBD38 >> 6) & 1);
    if (v54)
    {
      CFStringRef v55 = v54;
      v56 = CFStringGetCStringPtr(v54, 0x8000100u);
      if (v56)
      {
        v57 = (char *)v56;
        v58 = 0;
      }
      else
      {
        v57 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x14529887uLL);
        CFStringGetCString(v55, v57, 1024, 0x8000100u);
        v58 = v57;
      }
      if (qword_1000EBD00) {
        v61 = (FILE *)qword_1000EBD00;
      }
      else {
        v61 = __stderrp;
      }
      fprintf(v61, "%s\n", v57);
      if (v58) {
        free(v58);
      }
      CFRelease(v55);
    }
    else
    {
      v59 = sub_10002E548();
      if (os_log_type_enabled(v59, OS_LOG_TYPE_FAULT)) {
        sub_100088CB8();
      }
      if (qword_1000EBD00) {
        v60 = (FILE *)qword_1000EBD00;
      }
      else {
        v60 = __stderrp;
      }
      fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v60);
    }
    *__error() = v53;
  }
  word_1000EBD38 = (word_1000EBD38 & 0xDE7F | ((((unsigned __int16)word_1000EBD38 >> 2) & 1) << 7) & 0xDEFF | ((((unsigned __int16)word_1000EBD38 >> 2) & 1) << 13) | ((((unsigned __int16)word_1000EBD38 >> 2) & 1) << 8)) ^ 0x2180;
  if (byte_1000EBCF8)
  {
    int v62 = *__error();
    v63 = sub_10002E548();
    if (os_log_type_enabled(v63, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 67109632;
      *(_DWORD *)v154 = ((unsigned __int16)word_1000EBD38 >> 7) & 1;
      *(_WORD *)&v154[4] = 1024;
      *(_DWORD *)&v154[6] = HIBYTE(word_1000EBD38) & 1;
      __int16 v155 = 1024;
      int v156 = ((unsigned __int16)word_1000EBD38 >> 2) & 1;
      _os_log_impl((void *)&_mh_execute_header, v63, OS_LOG_TYPE_INFO, "Submit resource reports cpu:%d io:%d due to suppression:%d", buf, 0x14u);
    }
    *__error() = v62;
  }
  if (byte_1000EBCF9 && dword_1000EB4A8 <= 1)
  {
    int v64 = *__error();
    CFStringRef v65 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"Submit resource reports cpu:%d io:%d due to suppression:%d", ((unsigned __int16)word_1000EBD38 >> 7) & 1, HIBYTE(word_1000EBD38) & 1, ((unsigned __int16)word_1000EBD38 >> 2) & 1);
    if (v65)
    {
      CFStringRef v66 = v65;
      v67 = CFStringGetCStringPtr(v65, 0x8000100u);
      if (v67)
      {
        v68 = (char *)v67;
        v69 = 0;
      }
      else
      {
        v68 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xFE16B315uLL);
        CFStringGetCString(v66, v68, 1024, 0x8000100u);
        v69 = v68;
      }
      if (qword_1000EBD00) {
        v72 = (FILE *)qword_1000EBD00;
      }
      else {
        v72 = __stderrp;
      }
      fprintf(v72, "%s\n", v68);
      if (v69) {
        free(v69);
      }
      CFRelease(v66);
    }
    else
    {
      v70 = sub_10002E548();
      if (os_log_type_enabled(v70, OS_LOG_TYPE_FAULT)) {
        sub_100088C20();
      }
      if (qword_1000EBD00) {
        v71 = (FILE *)qword_1000EBD00;
      }
      else {
        v71 = __stderrp;
      }
      fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v71);
    }
    *__error() = v64;
  }
  word_1000EBD38 = ((word_1000EBD38 << 8) & 0x400 | word_1000EBD38 & 0xF1FF | (word_1000EBD38 << 7) & 0x200 | (word_1000EBD38 << 9) & 0x800) ^ 0xE00;
  if (byte_1000EBCF8)
  {
    int v73 = *__error();
    v74 = sub_10002E548();
    if (os_log_type_enabled(v74, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 67109888;
      *(_DWORD *)v154 = ((unsigned __int16)word_1000EBD38 >> 9) & 1;
      *(_WORD *)&v154[4] = 1024;
      *(_DWORD *)&v154[6] = ((unsigned __int16)word_1000EBD38 >> 10) & 1;
      __int16 v155 = 1024;
      int v156 = ((unsigned __int16)word_1000EBD38 >> 11) & 1;
      __int16 v157 = 1024;
      int v158 = ((unsigned __int16)word_1000EBD38 >> 2) & 1;
      _os_log_impl((void *)&_mh_execute_header, v74, OS_LOG_TYPE_INFO, "Submit systemstats:%d sleep/wake failure:%d watchdog:%d due to suppression:%d", buf, 0x1Au);
    }
    *__error() = v73;
  }
  if (byte_1000EBCF9 && dword_1000EB4A8 <= 1)
  {
    int v75 = *__error();
    CFStringRef v76 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"Submit systemstats:%d sleep/wake failure:%d watchdog:%d due to suppression:%d", ((unsigned __int16)word_1000EBD38 >> 9) & 1, ((unsigned __int16)word_1000EBD38 >> 10) & 1, ((unsigned __int16)word_1000EBD38 >> 11) & 1, ((unsigned __int16)word_1000EBD38 >> 2) & 1);
    if (v76)
    {
      CFStringRef v77 = v76;
      v78 = CFStringGetCStringPtr(v76, 0x8000100u);
      if (v78)
      {
        v79 = (char *)v78;
        v80 = 0;
      }
      else
      {
        v79 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x27FCBE94uLL);
        CFStringGetCString(v77, v79, 1024, 0x8000100u);
        v80 = v79;
      }
      if (qword_1000EBD00) {
        v83 = (FILE *)qword_1000EBD00;
      }
      else {
        v83 = __stderrp;
      }
      fprintf(v83, "%s\n", v79);
      if (v80) {
        free(v80);
      }
      CFRelease(v77);
    }
    else
    {
      v81 = sub_10002E548();
      if (os_log_type_enabled(v81, OS_LOG_TYPE_FAULT)) {
        sub_100088B84();
      }
      if (qword_1000EBD00) {
        v82 = (FILE *)qword_1000EBD00;
      }
      else {
        v82 = __stderrp;
      }
      fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v82);
    }
    *__error() = v75;
  }
  word_1000EBD38 &= ~0x1000u;
  if (byte_1000EBCF8)
  {
    int v84 = *__error();
    v85 = sub_10002E548();
    if (os_log_type_enabled(v85, OS_LOG_TYPE_DEBUG)) {
      sub_100088B0C();
    }
    *__error() = v84;
  }
  if (byte_1000EBCF9 && dword_1000EB4A8 <= 0)
  {
    int v86 = *__error();
    CFStringRef v87 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"Submit service watchdog:%d unavilable on this platform", ((unsigned __int16)word_1000EBD38 >> 12) & 1);
    if (v87)
    {
      CFStringRef v88 = v87;
      v89 = CFStringGetCStringPtr(v87, 0x8000100u);
      if (v89)
      {
        v90 = (char *)v89;
        v91 = 0;
      }
      else
      {
        v90 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x108F8061uLL);
        CFStringGetCString(v88, v90, 1024, 0x8000100u);
        v91 = v90;
      }
      if (qword_1000EBD00) {
        v94 = (FILE *)qword_1000EBD00;
      }
      else {
        v94 = __stderrp;
      }
      fprintf(v94, "%s\n", v90);
      if (v91) {
        free(v91);
      }
      CFRelease(v88);
    }
    else
    {
      v92 = sub_10002E548();
      if (os_log_type_enabled(v92, OS_LOG_TYPE_FAULT)) {
        sub_100088AA0();
      }
      if (qword_1000EBD00) {
        v93 = (FILE *)qword_1000EBD00;
      }
      else {
        v93 = __stderrp;
      }
      fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v93);
    }
    *__error() = v86;
  }
  byte_1000EBD0C = (byte_1000EBD0C & 0xFC | (2 * (word_1000EBD38 & 1))) ^ 2;
  if (byte_1000EBCF8)
  {
    int v95 = *__error();
    v96 = sub_10002E548();
    if (os_log_type_enabled(v96, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 67109376;
      *(_DWORD *)v154 = (byte_1000EBD0C >> 1) & 1;
      *(_WORD *)&v154[4] = 1024;
      *(_DWORD *)&v154[6] = word_1000EBD38 & 1;
      _os_log_impl((void *)&_mh_execute_header, v96, OS_LOG_TYPE_INFO, "Avoid affecting audio:%d due to internal:%d", buf, 0xEu);
    }
    *__error() = v95;
  }
  if (byte_1000EBCF9 && dword_1000EB4A8 <= 1)
  {
    int v97 = *__error();
    CFStringRef v98 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"Avoid affecting audio:%d due to internal:%d", (byte_1000EBD0C >> 1) & 1, word_1000EBD38 & 1);
    if (v98)
    {
      CFStringRef v99 = v98;
      v100 = CFStringGetCStringPtr(v98, 0x8000100u);
      if (v100)
      {
        v101 = (char *)v100;
        v102 = 0;
      }
      else
      {
        v101 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xEC869ACuLL);
        CFStringGetCString(v99, v101, 1024, 0x8000100u);
        v102 = v101;
      }
      if (qword_1000EBD00) {
        v105 = (FILE *)qword_1000EBD00;
      }
      else {
        v105 = __stderrp;
      }
      fprintf(v105, "%s\n", v101);
      if (v102) {
        free(v102);
      }
      CFRelease(v99);
    }
    else
    {
      v103 = sub_10002E548();
      if (os_log_type_enabled(v103, OS_LOG_TYPE_FAULT)) {
        sub_100088A10();
      }
      if (qword_1000EBD00) {
        v104 = (FILE *)qword_1000EBD00;
      }
      else {
        v104 = __stderrp;
      }
      fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v104);
    }
    *__error() = v97;
  }
  if (sub_10002B86C("/var/db/.spindump_enable_symbolication")) {
    char v106 = 8;
  }
  else {
    char v106 = 0;
  }
  byte_1000EBD0C = byte_1000EBD0C & 0xF7 | v106;
  if (byte_1000EBCF8)
  {
    int v107 = *__error();
    v108 = sub_10002E548();
    if (os_log_type_enabled(v108, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 67109376;
      *(_DWORD *)v154 = (byte_1000EBD0C >> 3) & 1;
      *(_WORD *)&v154[4] = 1024;
      *(_DWORD *)&v154[6] = *(_DWORD *)v154;
      _os_log_impl((void *)&_mh_execute_header, v108, OS_LOG_TYPE_INFO, "Symbolicate:%d due to enable symbolication file existing:%d", buf, 0xEu);
    }
    *__error() = v107;
  }
  if (byte_1000EBCF9 && dword_1000EB4A8 <= 1)
  {
    int v109 = *__error();
    CFStringRef v110 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"Symbolicate:%d due to enable symbolication file existing:%d", (byte_1000EBD0C >> 3) & 1, (byte_1000EBD0C >> 3) & 1);
    if (v110)
    {
      CFStringRef v111 = v110;
      v112 = CFStringGetCStringPtr(v110, 0x8000100u);
      if (v112)
      {
        v113 = (char *)v112;
        v114 = 0;
      }
      else
      {
        v113 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x2FA5331EuLL);
        CFStringGetCString(v111, v113, 1024, 0x8000100u);
        v114 = v113;
      }
      if (qword_1000EBD00) {
        v117 = (FILE *)qword_1000EBD00;
      }
      else {
        v117 = __stderrp;
      }
      fprintf(v117, "%s\n", v113);
      if (v114) {
        free(v114);
      }
      CFRelease(v111);
    }
    else
    {
      v115 = sub_10002E548();
      if (os_log_type_enabled(v115, OS_LOG_TYPE_FAULT)) {
        sub_10008898C();
      }
      if (qword_1000EBD00) {
        v116 = (FILE *)qword_1000EBD00;
      }
      else {
        v116 = __stderrp;
      }
      fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v116);
    }
    *__error() = v109;
  }
  byte_1000EBD0C |= 0x10u;
  if (byte_1000EBCF8)
  {
    int v118 = *__error();
    v119 = sub_10002E548();
    if (os_log_type_enabled(v119, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 67109120;
      *(_DWORD *)v154 = (byte_1000EBD0C >> 4) & 1;
      _os_log_impl((void *)&_mh_execute_header, v119, OS_LOG_TYPE_INFO, "NoBulkSymbolication:%d", buf, 8u);
    }
    *__error() = v118;
  }
  if (byte_1000EBCF9 && dword_1000EB4A8 <= 1)
  {
    int v120 = *__error();
    CFStringRef v121 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"NoBulkSymbolication:%d", (byte_1000EBD0C >> 4) & 1);
    if (v121)
    {
      CFStringRef v122 = v121;
      v123 = CFStringGetCStringPtr(v121, 0x8000100u);
      if (v123)
      {
        v124 = (char *)v123;
        v125 = 0;
      }
      else
      {
        v124 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xBEB0062AuLL);
        CFStringGetCString(v122, v124, 1024, 0x8000100u);
        v125 = v124;
      }
      if (qword_1000EBD00) {
        v128 = (FILE *)qword_1000EBD00;
      }
      else {
        v128 = __stderrp;
      }
      fprintf(v128, "%s\n", v124);
      if (v125) {
        free(v125);
      }
      CFRelease(v122);
    }
    else
    {
      v126 = sub_10002E548();
      if (os_log_type_enabled(v126, OS_LOG_TYPE_FAULT)) {
        sub_10008891C();
      }
      if (qword_1000EBD00) {
        v127 = (FILE *)qword_1000EBD00;
      }
      else {
        v127 = __stderrp;
      }
      fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v127);
    }
    *__error() = v120;
  }
  byte_1000EBD0C &= ~4u;
  if (byte_1000EBCF8)
  {
    int v129 = *__error();
    v130 = sub_10002E548();
    if (os_log_type_enabled(v130, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 67109120;
      *(_DWORD *)v154 = (byte_1000EBD0C >> 2) & 1;
      _os_log_impl((void *)&_mh_execute_header, v130, OS_LOG_TYPE_INFO, "UseDsymForUUID:%d", buf, 8u);
    }
    *__error() = v129;
  }
  if (byte_1000EBCF9 && dword_1000EB4A8 <= 1)
  {
    int v131 = *__error();
    CFStringRef v132 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"UseDsymForUUID:%d", (byte_1000EBD0C >> 2) & 1);
    if (v132)
    {
      CFStringRef v133 = v132;
      v134 = CFStringGetCStringPtr(v132, 0x8000100u);
      if (v134)
      {
        v135 = (char *)v134;
        v136 = 0;
      }
      else
      {
        v135 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x8C1902D4uLL);
        CFStringGetCString(v133, v135, 1024, 0x8000100u);
        v136 = v135;
      }
      if (qword_1000EBD00) {
        v139 = (FILE *)qword_1000EBD00;
      }
      else {
        v139 = __stderrp;
      }
      fprintf(v139, "%s\n", v135);
      if (v136) {
        free(v136);
      }
      CFRelease(v133);
    }
    else
    {
      v137 = sub_10002E548();
      if (os_log_type_enabled(v137, OS_LOG_TYPE_FAULT)) {
        sub_1000888AC();
      }
      if (qword_1000EBD00) {
        v138 = (FILE *)qword_1000EBD00;
      }
      else {
        v138 = __stderrp;
      }
      fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v138);
    }
    *__error() = v131;
  }
  result = (int *)sub_10002B86C("/var/db/.spindump_disable_exclaves");
  if (result) {
    char v141 = 32;
  }
  else {
    char v141 = 0;
  }
  byte_1000EBD0C = byte_1000EBD0C & 0xDF | v141;
  if (byte_1000EBCF8)
  {
    int v142 = *__error();
    v143 = sub_10002E548();
    if (os_log_type_enabled(v143, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 67109120;
      *(_DWORD *)v154 = (byte_1000EBD0C >> 5) & 1;
      _os_log_impl((void *)&_mh_execute_header, v143, OS_LOG_TYPE_INFO, "NoExclaves:%d", buf, 8u);
    }
    result = __error();
    int *result = v142;
  }
  if (byte_1000EBCF9 && dword_1000EB4A8 <= 1)
  {
    int v144 = *__error();
    CFStringRef v145 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"NoExclaves:%d", (byte_1000EBD0C >> 5) & 1);
    if (v145)
    {
      CFStringRef v146 = v145;
      v147 = CFStringGetCStringPtr(v145, 0x8000100u);
      if (v147)
      {
        v148 = (char *)v147;
        v149 = 0;
      }
      else
      {
        v148 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x98B21CFCuLL);
        CFStringGetCString(v146, v148, 1024, 0x8000100u);
        v149 = v148;
      }
      if (qword_1000EBD00) {
        v152 = (FILE *)qword_1000EBD00;
      }
      else {
        v152 = __stderrp;
      }
      fprintf(v152, "%s\n", v148);
      if (v149) {
        free(v149);
      }
      CFRelease(v146);
    }
    else
    {
      v150 = sub_10002E548();
      if (os_log_type_enabled(v150, OS_LOG_TYPE_FAULT)) {
        sub_10008883C();
      }
      if (qword_1000EBD00) {
        v151 = (FILE *)qword_1000EBD00;
      }
      else {
        v151 = __stderrp;
      }
      fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v151);
    }
    result = __error();
    int *result = v144;
  }
  return result;
}

uint64_t sub_100022478(uint64_t a1)
{
  v2[0] = _NSConcreteStackBlock;
  v2[1] = 3221225472;
  v3 = sub_100022520;
  int v4 = &unk_1000DD170;
  uint64_t v5 = a1;
  sub_100022520((uint64_t)v2, 2);
  v3((uint64_t)v2, 15);
  v3((uint64_t)v2, 1);
  return ((uint64_t (*)(void *, uint64_t))v3)(v2, 3);
}

void sub_100022520(uint64_t a1, int a2)
{
  uintptr_t v4 = a2;
  global_queue = dispatch_get_global_queue(25, 2uLL);
  dispatch_source_t v6 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_signal, v4, 0, global_queue);
  if (!v6)
  {
    if (byte_1000EBCF8)
    {
      int v13 = *__error();
      uint64_t v14 = sub_10002E548();
      if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR)) {
        sub_100092DE4(v14);
      }
      *__error() = v13;
    }
    if (byte_1000EBCF9) {
      BOOL v15 = dword_1000EB4A8 <= 3;
    }
    else {
      BOOL v15 = 0;
    }
    if (v15)
    {
      int v16 = *__error();
      CFStringRef v17 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%s: unable to allocate source", "source");
      if (v17)
      {
        int v31 = v16;
        CFStringRef theString = v17;
        CStringPtr = CFStringGetCStringPtr(v17, 0x8000100u);
        if (CStringPtr)
        {
          v28 = (char *)CStringPtr;
          uint64_t v29 = 0;
        }
        else
        {
          v28 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x6B7D9D72uLL);
          CFStringGetCString(theString, v28, 1024, 0x8000100u);
          uint64_t v29 = v28;
        }
        if (qword_1000EBD00) {
          uint64_t v30 = (FILE *)qword_1000EBD00;
        }
        else {
          uint64_t v30 = __stderrp;
        }
        fprintf(v30, "%s\n", v28);
        if (v29) {
          free(v29);
        }
        CFRelease(theString);
        int v16 = v31;
      }
      else
      {
        v18 = sub_10002E548();
        if (os_log_type_enabled(v18, OS_LOG_TYPE_FAULT)) {
          sub_100092D6C(v18, v19, v20, v21, v22, v23, v24, v25);
        }
        if (qword_1000EBD00) {
          v26 = (FILE *)qword_1000EBD00;
        }
        else {
          v26 = __stderrp;
        }
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v26);
      }
      *__error() = v16;
    }
    sub_10002E41C("RegisterExitHandlers_block_invoke", "spindump.m", 4145, "%s: unable to allocate source", v7, v8, v9, v10, (char)"source");
    abort();
  }
  uint64_t v11 = v6;
  signal(a2, (void (__cdecl *)(int))1);
  handler[0] = _NSConcreteStackBlock;
  handler[1] = 3221225472;
  handler[2] = sub_10005DD3C;
  handler[3] = &unk_1000DD790;
  uint64_t v12 = *(void *)(a1 + 32);
  handler[4] = v11;
  handler[5] = v12;
  dispatch_source_set_event_handler(v11, handler);
  dispatch_resume(v11);
}

void sub_1000227A8()
{
  __int16 v0 = dispatch_queue_attr_make_with_autorelease_frequency(0, DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM);
  char v1 = dispatch_queue_attr_make_with_qos_class(v0, QOS_CLASS_USER_INITIATED, 0);
  int v2 = dispatch_queue_create("com.apple.spindump.communication", v1);
  dispatch_release(v1);
  dispatch_release(v0);
  if (!v2)
  {
    if (byte_1000EBCF8)
    {
      int v8 = *__error();
      uint64_t v9 = sub_10002E548();
      if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR)) {
        sub_10008995C(v9, v10, v11, v12, v13, v14, v15, v16);
      }
      *__error() = v8;
    }
    if (byte_1000EBCF9) {
      BOOL v17 = dword_1000EB4A8 <= 3;
    }
    else {
      BOOL v17 = 0;
    }
    if (v17)
    {
      int v18 = *__error();
      CFStringRef v19 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%s: unable to allocate communication queue", "communication_queue");
      if (v19)
      {
        int v33 = v18;
        CFStringRef theString = v19;
        CStringPtr = CFStringGetCStringPtr(v19, 0x8000100u);
        if (CStringPtr)
        {
          uint64_t v30 = (char *)CStringPtr;
          int v31 = 0;
        }
        else
        {
          uint64_t v30 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x70E88092uLL);
          CFStringGetCString(theString, v30, 1024, 0x8000100u);
          int v31 = v30;
        }
        if (qword_1000EBD00) {
          uint64_t v32 = (FILE *)qword_1000EBD00;
        }
        else {
          uint64_t v32 = __stderrp;
        }
        fprintf(v32, "%s\n", v30);
        if (v31) {
          free(v31);
        }
        CFRelease(theString);
        int v18 = v33;
      }
      else
      {
        uint64_t v20 = sub_10002E548();
        if (os_log_type_enabled(v20, OS_LOG_TYPE_FAULT)) {
          sub_1000898E4(v20, v21, v22, v23, v24, v25, v26, v27);
        }
        if (qword_1000EBD00) {
          v28 = (FILE *)qword_1000EBD00;
        }
        else {
          v28 = __stderrp;
        }
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v28);
      }
      *__error() = v18;
    }
    sub_10002E41C("startup_ports", "reading.m", 99, "%s: unable to allocate communication queue", v3, v4, v5, v6, (char)"communication_queue");
    abort();
  }
  mach_service = xpc_connection_create_mach_service("com.apple.spindump", v2, 1uLL);
  handler[0] = _NSConcreteStackBlock;
  handler[1] = 3221225472;
  handler[2] = sub_10002453C;
  handler[3] = &unk_1000DD1B8;
  handler[4] = v2;
  xpc_connection_set_event_handler(mach_service, handler);
  xpc_connection_resume(mach_service);
  dispatch_release(v2);
  sub_10004DBD0();
}

_DWORD *sub_100022A50(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (byte_1000EBD0C)
  {
    if (byte_1000EBCF8)
    {
      int v124 = *__error();
      v125 = sub_10002E548();
      if (os_log_type_enabled(v125, OS_LOG_TYPE_ERROR)) {
        sub_1000887BC();
      }
      *__error() = v124;
    }
    if (byte_1000EBCF9) {
      BOOL v126 = dword_1000EB4A8 <= 3;
    }
    else {
      BOOL v126 = 0;
    }
    if (v126)
    {
      int v127 = *__error();
      CFStringRef v128 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%s: Getting prefs for user %d as command-line", "!global_preferences.command_line", a1);
      if (v128)
      {
        CFStringRef v159 = v128;
        CStringPtr = CFStringGetCStringPtr(v128, 0x8000100u);
        if (CStringPtr)
        {
          v161 = (char *)CStringPtr;
          v162 = 0;
        }
        else
        {
          v161 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x5F9EAF6uLL);
          CFStringGetCString(v159, v161, 1024, 0x8000100u);
          v162 = v161;
        }
        if (qword_1000EBD00) {
          v167 = (FILE *)qword_1000EBD00;
        }
        else {
          v167 = __stderrp;
        }
        fprintf(v167, "%s\n", v161);
        if (v162) {
          free(v162);
        }
        CFRelease(v159);
      }
      else
      {
        int v129 = sub_10002E548();
        if (os_log_type_enabled(v129, OS_LOG_TYPE_FAULT)) {
          sub_10008873C();
        }
        if (qword_1000EBD00) {
          v130 = (FILE *)qword_1000EBD00;
        }
        else {
          v130 = __stderrp;
        }
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v130);
      }
      *__error() = v127;
    }
    sub_10002E41C("get_user_preferences", "preferences.m", 98, "%s: Getting prefs for user %d as command-line", a5, a6, a7, a8, (char)"!global_preferences.command_line");
LABEL_281:
    abort();
  }
  os_unfair_lock_lock((os_unfair_lock_t)&unk_1000EBBB8);
  id v9 = (id)qword_1000EBBC0;
  if (!qword_1000EBBC0)
  {
    id v9 = [objc_alloc((Class)NSMutableDictionary) initWithCapacity:1];
    qword_1000EBBC0 = (uint64_t)v9;
    if (!v9)
    {
      if (byte_1000EBCF8)
      {
        int v145 = *__error();
        CFStringRef v146 = sub_10002E548();
        if (os_log_type_enabled(v146, OS_LOG_TYPE_ERROR)) {
          sub_1000880E4(v146);
        }
        *__error() = v145;
      }
      if (byte_1000EBCF9) {
        BOOL v147 = dword_1000EB4A8 <= 3;
      }
      else {
        BOOL v147 = 0;
      }
      if (v147)
      {
        int v148 = *__error();
        CFStringRef v149 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%s: unable to allocate prefs dict", "user_preferences_dict");
        if (v149)
        {
          CFStringRef v168 = v149;
          v169 = CFStringGetCStringPtr(v149, 0x8000100u);
          if (v169)
          {
            v170 = (char *)v169;
            v171 = 0;
          }
          else
          {
            v170 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x30812793uLL);
            CFStringGetCString(v168, v170, 1024, 0x8000100u);
            v171 = v170;
          }
          if (qword_1000EBD00) {
            v173 = (FILE *)qword_1000EBD00;
          }
          else {
            v173 = __stderrp;
          }
          fprintf(v173, "%s\n", v170);
          if (v171) {
            free(v171);
          }
          CFRelease(v168);
        }
        else
        {
          v150 = sub_10002E548();
          if (os_log_type_enabled(v150, OS_LOG_TYPE_FAULT)) {
            sub_10008806C(v150, v151, v152, v153, v154, v155, v156, v157);
          }
          if (qword_1000EBD00) {
            int v158 = (FILE *)qword_1000EBD00;
          }
          else {
            int v158 = __stderrp;
          }
          fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v158);
        }
        *__error() = v148;
      }
      sub_10002E41C("get_user_preferences", "preferences.m", 106, "%s: unable to allocate prefs dict", v10, v11, v12, v13, (char)"user_preferences_dict");
      goto LABEL_281;
    }
  }
  id v14 = [v9 objectForKeyedSubscript:+[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", a1)];
  if (v14)
  {
    uint64_t v15 = v14;
    os_unfair_lock_unlock((os_unfair_lock_t)&unk_1000EBBB8);
    return [v15 bytes];
  }
  BOOL v17 = malloc_type_calloc(1uLL, 0xCuLL, 0x1000040261CCB9FuLL);
  if (!v17)
  {
    if (byte_1000EBCF8)
    {
      int v131 = *__error();
      CFStringRef v132 = sub_10002E548();
      if (os_log_type_enabled(v132, OS_LOG_TYPE_ERROR)) {
        sub_1000881E0(v132);
      }
      *__error() = v131;
    }
    if (byte_1000EBCF9) {
      BOOL v133 = dword_1000EB4A8 <= 3;
    }
    else {
      BOOL v133 = 0;
    }
    if (v133)
    {
      int v134 = *__error();
      CFStringRef v135 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%s: unable to allocate prefs", "prefs_for_uid");
      if (v135)
      {
        CFStringRef v163 = v135;
        v164 = CFStringGetCStringPtr(v135, 0x8000100u);
        if (v164)
        {
          v165 = (char *)v164;
          v166 = 0;
        }
        else
        {
          v165 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x59946E74uLL);
          CFStringGetCString(v163, v165, 1024, 0x8000100u);
          v166 = v165;
        }
        if (qword_1000EBD00) {
          v172 = (FILE *)qword_1000EBD00;
        }
        else {
          v172 = __stderrp;
        }
        fprintf(v172, "%s\n", v165);
        if (v166) {
          free(v166);
        }
        CFRelease(v163);
      }
      else
      {
        v136 = sub_10002E548();
        if (os_log_type_enabled(v136, OS_LOG_TYPE_FAULT)) {
          sub_100088168(v136, v137, v138, v139, v140, v141, v142, v143);
        }
        if (qword_1000EBD00) {
          int v144 = (FILE *)qword_1000EBD00;
        }
        else {
          int v144 = __stderrp;
        }
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v144);
      }
      *__error() = v134;
    }
    sub_10002E41C("get_user_preferences", "preferences.m", 116, "%s: unable to allocate prefs", v18, v19, v20, v21, (char)"prefs_for_uid");
    goto LABEL_281;
  }
  uint64_t v22 = v17;
  *BOOL v17 = a1;
  id v23 = [objc_alloc((Class)NSData) initWithBytesNoCopy:v17 length:12 freeWhenDone:1];
  [objc_msgSend((id)qword_1000EBBC0, "setObject:forKeyedSubscript:", v23, +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", a1));
  if (byte_1000EBCF8)
  {
    int v24 = *__error();
    uint64_t v25 = sub_10002E548();
    if (os_log_type_enabled(v25, OS_LOG_TYPE_DEBUG)) {
      sub_1000886C8();
    }
    *__error() = v24;
  }
  if (byte_1000EBCF9 && dword_1000EB4A8 <= 0)
  {
    int v26 = *__error();
    CFStringRef v27 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"Initializing prefs for user %d", a1);
    if (v27)
    {
      CFStringRef v28 = v27;
      uint64_t v29 = CFStringGetCStringPtr(v27, 0x8000100u);
      if (v29)
      {
        uint64_t v30 = (char *)v29;
        int v31 = 0;
      }
      else
      {
        uint64_t v30 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x1696F1BDuLL);
        CFStringGetCString(v28, v30, 1024, 0x8000100u);
        int v31 = v30;
      }
      if (qword_1000EBD00) {
        uint64_t v34 = (FILE *)qword_1000EBD00;
      }
      else {
        uint64_t v34 = __stderrp;
      }
      fprintf(v34, "%s\n", v30);
      if (v31) {
        free(v31);
      }
      CFRelease(v28);
    }
    else
    {
      uint64_t v32 = sub_10002E548();
      if (os_log_type_enabled(v32, OS_LOG_TYPE_FAULT)) {
        sub_100088660();
      }
      if (qword_1000EBD00) {
        int v33 = (FILE *)qword_1000EBD00;
      }
      else {
        int v33 = __stderrp;
      }
      fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v33);
    }
    *__error() = v26;
  }
  v36 = (__int16 *)(v22 + 2);
  __int16 v35 = *((_WORD *)v22 + 4);
  v22[1] = -1;
  *((_WORD *)v22 + 4) = v35 & 0xFFC0 | 8;
  if (byte_1000EBCF8)
  {
    int v37 = *__error();
    int v38 = sub_10002E548();
    if (os_log_type_enabled(v38, OS_LOG_TYPE_INFO))
    {
      unsigned int v39 = (unsigned __int16)*v36;
      *(_DWORD *)buf = 67109888;
      int v175 = a1;
      __int16 v176 = 1024;
      int v177 = (v39 >> 5) & 1;
      __int16 v178 = 1024;
      int v179 = (v39 >> 3) & 1;
      __int16 v180 = 1024;
      int v181 = (v39 >> 2) & 1;
      _os_log_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_INFO, "UID %d: Present UI:%d due to server mode:%d admin:%d", buf, 0x1Au);
    }
    *__error() = v37;
  }
  if (byte_1000EBCF9 && dword_1000EB4A8 <= 1)
  {
    int v40 = *__error();
    CFStringRef v41 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"UID %d: Present UI:%d due to server mode:%d admin:%d", a1, ((unsigned __int16)*v36 >> 5) & 1, ((unsigned __int16)*v36 >> 3) & 1, ((unsigned __int16)*v36 >> 2) & 1);
    if (v41)
    {
      CFStringRef v42 = v41;
      v43 = CFStringGetCStringPtr(v41, 0x8000100u);
      if (v43)
      {
        v44 = (char *)v43;
        v45 = 0;
      }
      else
      {
        v44 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x13FE1A5DuLL);
        CFStringGetCString(v42, v44, 1024, 0x8000100u);
        v45 = v44;
      }
      if (qword_1000EBD00) {
        v48 = (FILE *)qword_1000EBD00;
      }
      else {
        v48 = __stderrp;
      }
      fprintf(v48, "%s\n", v44);
      if (v45) {
        free(v45);
      }
      CFRelease(v42);
    }
    else
    {
      v46 = sub_10002E548();
      if (os_log_type_enabled(v46, OS_LOG_TYPE_FAULT)) {
        sub_1000885E8();
      }
      if (qword_1000EBD00) {
        v47 = (FILE *)qword_1000EBD00;
      }
      else {
        v47 = __stderrp;
      }
      fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v47);
    }
    *__error() = v40;
  }
  *v36 &= 0xFF3Fu;
  if (byte_1000EBCF8)
  {
    int v49 = *__error();
    double v50 = sub_10002E548();
    if (os_log_type_enabled(v50, OS_LOG_TYPE_DEBUG)) {
      sub_100088570();
    }
    *__error() = v49;
  }
  if (byte_1000EBCF9 && dword_1000EB4A8 <= 0)
  {
    int v51 = *__error();
    CFStringRef v52 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"UID %d: User requested spins:%d hangs:%d unavilable on this platform", a1, ((unsigned __int16)*v36 >> 6) & 1, ((unsigned __int16)*v36 >> 7) & 1);
    if (v52)
    {
      CFStringRef v53 = v52;
      CFStringRef v54 = CFStringGetCStringPtr(v52, 0x8000100u);
      if (v54)
      {
        CFStringRef v55 = (char *)v54;
        v56 = 0;
      }
      else
      {
        CFStringRef v55 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xFD96B4FFuLL);
        CFStringGetCString(v53, v55, 1024, 0x8000100u);
        v56 = v55;
      }
      if (qword_1000EBD00) {
        v59 = (FILE *)qword_1000EBD00;
      }
      else {
        v59 = __stderrp;
      }
      fprintf(v59, "%s\n", v55);
      if (v56) {
        free(v56);
      }
      CFRelease(v53);
    }
    else
    {
      v57 = sub_10002E548();
      if (os_log_type_enabled(v57, OS_LOG_TYPE_FAULT)) {
        sub_100088508();
      }
      if (qword_1000EBD00) {
        v58 = (FILE *)qword_1000EBD00;
      }
      else {
        v58 = __stderrp;
      }
      fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v58);
    }
    *__error() = v51;
  }
  __int16 v60 = *v36;
  if ((*v36 & 0x20) != 0 || (int v61 = v60 & 0x80 | word_1000EBD38 & 0x40) != 0) {
    LOWORD(v61) = 256;
  }
  __int16 *v36 = v61 | v60 & 0xFEFF;
  if (byte_1000EBCF8)
  {
    int v62 = *__error();
    v63 = sub_10002E548();
    if (os_log_type_enabled(v63, OS_LOG_TYPE_INFO))
    {
      unsigned int v64 = (unsigned __int16)*v36;
      *(_DWORD *)buf = 67110144;
      int v175 = a1;
      __int16 v176 = 1024;
      int v177 = (v64 >> 8) & 1;
      __int16 v178 = 1024;
      int v179 = (v64 >> 5) & 1;
      __int16 v180 = 1024;
      int v181 = ((unsigned __int16)word_1000EBD38 >> 6) & 1;
      __int16 v182 = 1024;
      int v183 = (v64 >> 7) & 1;
      _os_log_impl((void *)&_mh_execute_header, v63, OS_LOG_TYPE_INFO, "UID %d: Gather samples for hangs:%d due to present:%d submit:%d user requested:%d", buf, 0x20u);
    }
    *__error() = v62;
  }
  if (byte_1000EBCF9 && dword_1000EB4A8 <= 1)
  {
    int v65 = *__error();
    CFStringRef v66 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"UID %d: Gather samples for hangs:%d due to present:%d submit:%d user requested:%d", a1, HIBYTE(*v36) & 1, ((unsigned __int16)*v36 >> 5) & 1, ((unsigned __int16)word_1000EBD38 >> 6) & 1, ((unsigned __int16)*v36 >> 7) & 1);
    if (v66)
    {
      CFStringRef v67 = v66;
      v68 = CFStringGetCStringPtr(v66, 0x8000100u);
      if (v68)
      {
        v69 = (char *)v68;
        v70 = 0;
      }
      else
      {
        v69 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x4C2359A4uLL);
        CFStringGetCString(v67, v69, 1024, 0x8000100u);
        v70 = v69;
      }
      if (qword_1000EBD00) {
        int v73 = (FILE *)qword_1000EBD00;
      }
      else {
        int v73 = __stderrp;
      }
      fprintf(v73, "%s\n", v69);
      if (v70) {
        free(v70);
      }
      CFRelease(v67);
    }
    else
    {
      v71 = sub_10002E548();
      if (os_log_type_enabled(v71, OS_LOG_TYPE_FAULT)) {
        sub_100088484();
      }
      if (qword_1000EBD00) {
        v72 = (FILE *)qword_1000EBD00;
      }
      else {
        v72 = __stderrp;
      }
      fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v72);
    }
    *__error() = v65;
  }
  __int16 *v36 = *v36 & 0xFDFF | (((word_1000EBD38 & 0x20 | *v36 & 0x40) != 0) << 9);
  if (byte_1000EBCF8)
  {
    int v74 = *__error();
    int v75 = sub_10002E548();
    if (os_log_type_enabled(v75, OS_LOG_TYPE_INFO))
    {
      unsigned int v76 = (unsigned __int16)*v36;
      *(_DWORD *)buf = 67109888;
      int v175 = a1;
      __int16 v176 = 1024;
      int v177 = (v76 >> 9) & 1;
      __int16 v178 = 1024;
      int v179 = ((unsigned __int16)word_1000EBD38 >> 5) & 1;
      __int16 v180 = 1024;
      int v181 = (v76 >> 6) & 1;
      _os_log_impl((void *)&_mh_execute_header, v75, OS_LOG_TYPE_INFO, "UID %d: Gather samples for spins:%d due to submit:%d user requested:%d", buf, 0x1Au);
    }
    *__error() = v74;
  }
  if (byte_1000EBCF9 && dword_1000EB4A8 <= 1)
  {
    int v77 = *__error();
    CFStringRef v78 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"UID %d: Gather samples for spins:%d due to submit:%d user requested:%d", a1, ((unsigned __int16)*v36 >> 9) & 1, ((unsigned __int16)word_1000EBD38 >> 5) & 1, ((unsigned __int16)*v36 >> 6) & 1);
    if (v78)
    {
      CFStringRef v79 = v78;
      v80 = CFStringGetCStringPtr(v78, 0x8000100u);
      if (v80)
      {
        v81 = (char *)v80;
        v82 = 0;
      }
      else
      {
        v81 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x6CBB54A9uLL);
        CFStringGetCString(v79, v81, 1024, 0x8000100u);
        v82 = v81;
      }
      if (qword_1000EBD00) {
        v85 = (FILE *)qword_1000EBD00;
      }
      else {
        v85 = __stderrp;
      }
      fprintf(v85, "%s\n", v81);
      if (v82) {
        free(v82);
      }
      CFRelease(v79);
    }
    else
    {
      v83 = sub_10002E548();
      if (os_log_type_enabled(v83, OS_LOG_TYPE_FAULT)) {
        sub_1000883F0();
      }
      if (qword_1000EBD00) {
        int v84 = (FILE *)qword_1000EBD00;
      }
      else {
        int v84 = __stderrp;
      }
      fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v84);
    }
    *__error() = v77;
  }
  if (word_1000EBD38)
  {
    __int16 v87 = *v36;
    __int16 v86 = ((word_1000EBD38 & 0x20 | *v36 & 0x40) != 0) << 10;
  }
  else
  {
    __int16 v86 = 0;
    __int16 v87 = *v36;
  }
  __int16 *v36 = v87 & 0xFBFF | v86;
  if (byte_1000EBCF8)
  {
    int v88 = *__error();
    v89 = sub_10002E548();
    if (os_log_type_enabled(v89, OS_LOG_TYPE_INFO))
    {
      unsigned int v90 = (unsigned __int16)*v36;
      *(_DWORD *)buf = 67110144;
      int v175 = a1;
      __int16 v176 = 1024;
      int v177 = (v90 >> 10) & 1;
      __int16 v178 = 1024;
      int v179 = word_1000EBD38 & 1;
      __int16 v180 = 1024;
      int v181 = ((unsigned __int16)word_1000EBD38 >> 5) & 1;
      __int16 v182 = 1024;
      int v183 = (v90 >> 6) & 1;
      _os_log_impl((void *)&_mh_execute_header, v89, OS_LOG_TYPE_INFO, "UID %d: Gather samples for stuck apps:%d due to internal:%d submit:%d user requested:%d", buf, 0x20u);
    }
    *__error() = v88;
  }
  if (byte_1000EBCF9 && dword_1000EB4A8 <= 1)
  {
    int v91 = *__error();
    CFStringRef v92 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"UID %d: Gather samples for stuck apps:%d due to internal:%d submit:%d user requested:%d", a1, ((unsigned __int16)*v36 >> 10) & 1, word_1000EBD38 & 1, ((unsigned __int16)word_1000EBD38 >> 5) & 1, ((unsigned __int16)*v36 >> 6) & 1);
    if (v92)
    {
      CFStringRef v93 = v92;
      v94 = CFStringGetCStringPtr(v92, 0x8000100u);
      if (v94)
      {
        int v95 = (char *)v94;
        v96 = 0;
      }
      else
      {
        int v95 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xB8DDEB4AuLL);
        CFStringGetCString(v93, v95, 1024, 0x8000100u);
        v96 = v95;
      }
      if (qword_1000EBD00) {
        CFStringRef v99 = (FILE *)qword_1000EBD00;
      }
      else {
        CFStringRef v99 = __stderrp;
      }
      fprintf(v99, "%s\n", v95);
      if (v96) {
        free(v96);
      }
      CFRelease(v93);
    }
    else
    {
      int v97 = sub_10002E548();
      if (os_log_type_enabled(v97, OS_LOG_TYPE_FAULT)) {
        sub_10008836C();
      }
      if (qword_1000EBD00) {
        CFStringRef v98 = (FILE *)qword_1000EBD00;
      }
      else {
        CFStringRef v98 = __stderrp;
      }
      fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v98);
    }
    *__error() = v91;
  }
  __int16 *v36 = *v36 & 0xF7FF | ((unsigned __int16)word_1000EBD38 >> 1) & 0x800;
  if (byte_1000EBCF8)
  {
    int v100 = *__error();
    v101 = sub_10002E548();
    if (os_log_type_enabled(v101, OS_LOG_TYPE_INFO))
    {
      int v102 = ((unsigned __int16)*v36 >> 11) & 1;
      *(_DWORD *)buf = 67109632;
      int v175 = a1;
      __int16 v176 = 1024;
      int v177 = v102;
      __int16 v178 = 1024;
      int v179 = ((unsigned __int16)word_1000EBD38 >> 12) & 1;
      _os_log_impl((void *)&_mh_execute_header, v101, OS_LOG_TYPE_INFO, "UID %d: Gather samples for service watchdog:%d due to submit:%d", buf, 0x14u);
    }
    *__error() = v100;
  }
  if (byte_1000EBCF9 && dword_1000EB4A8 <= 1)
  {
    int v103 = *__error();
    CFStringRef v104 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"UID %d: Gather samples for service watchdog:%d due to submit:%d", a1, ((unsigned __int16)*v36 >> 11) & 1, ((unsigned __int16)word_1000EBD38 >> 12) & 1);
    if (v104)
    {
      CFStringRef v105 = v104;
      char v106 = CFStringGetCStringPtr(v104, 0x8000100u);
      if (v106)
      {
        int v107 = (char *)v106;
        v108 = 0;
      }
      else
      {
        int v107 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x500B269uLL);
        CFStringGetCString(v105, v107, 1024, 0x8000100u);
        v108 = v107;
      }
      if (qword_1000EBD00) {
        CFStringRef v111 = (FILE *)qword_1000EBD00;
      }
      else {
        CFStringRef v111 = __stderrp;
      }
      fprintf(v111, "%s\n", v107);
      if (v108) {
        free(v108);
      }
      CFRelease(v105);
    }
    else
    {
      int v109 = sub_10002E548();
      if (os_log_type_enabled(v109, OS_LOG_TYPE_FAULT)) {
        sub_1000882DC();
      }
      if (qword_1000EBD00) {
        CFStringRef v110 = (FILE *)qword_1000EBD00;
      }
      else {
        CFStringRef v110 = __stderrp;
      }
      fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v110);
    }
    *__error() = v103;
  }
  __int16 *v36 = (*v36 << 12) & (*v36 << 11) & 0x1000 | *v36 & 0xEFFF;
  if (byte_1000EBCF8)
  {
    int v112 = *__error();
    v113 = sub_10002E548();
    if (os_log_type_enabled(v113, OS_LOG_TYPE_INFO))
    {
      unsigned int v114 = (unsigned __int16)*v36;
      *(_DWORD *)buf = 67109888;
      int v175 = a1;
      __int16 v176 = 1024;
      int v177 = (v114 >> 12) & 1;
      __int16 v178 = 1024;
      int v179 = v114 & 1;
      __int16 v180 = 1024;
      int v181 = (v114 >> 1) & 1;
      _os_log_impl((void *)&_mh_execute_header, v113, OS_LOG_TYPE_INFO, "UID %d: Don't throttle short spin reports:%d due to pref isset:%d value:%d", buf, 0x1Au);
    }
    *__error() = v112;
  }
  if (byte_1000EBCF9 && dword_1000EB4A8 <= 1)
  {
    int v115 = *__error();
    CFStringRef v116 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"UID %d: Don't throttle short spin reports:%d due to pref isset:%d value:%d", a1, ((unsigned __int16)*v36 >> 12) & 1, *v36 & 1, ((unsigned __int16)*v36 >> 1) & 1);
    if (v116)
    {
      CFStringRef v117 = v116;
      int v118 = CFStringGetCStringPtr(v116, 0x8000100u);
      if (v118)
      {
        v119 = (char *)v118;
        int v120 = 0;
      }
      else
      {
        v119 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xDB399A88uLL);
        CFStringGetCString(v117, v119, 1024, 0x8000100u);
        int v120 = v119;
      }
      if (qword_1000EBD00) {
        v123 = (FILE *)qword_1000EBD00;
      }
      else {
        v123 = __stderrp;
      }
      fprintf(v123, "%s\n", v119);
      if (v120) {
        free(v120);
      }
      CFRelease(v117);
    }
    else
    {
      CFStringRef v121 = sub_10002E548();
      if (os_log_type_enabled(v121, OS_LOG_TYPE_FAULT)) {
        sub_100088264();
      }
      if (qword_1000EBD00) {
        CFStringRef v122 = (FILE *)qword_1000EBD00;
      }
      else {
        CFStringRef v122 = __stderrp;
      }
      fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v122);
    }
    *__error() = v115;
  }
  os_unfair_lock_unlock((os_unfair_lock_t)&unk_1000EBBB8);
  return v22;
}

BOOL sub_1000240E8(pid_t a1)
{
  return !a1 || kill(a1, 0) == 0;
}

uint64_t sub_10002411C()
{
  if (qword_1000EBC48 != -1) {
    dispatch_once(&qword_1000EBC48, &stru_1000DD7B0);
  }
  if (qword_1000EB4B8)
  {
    int v16 = 0;
    size_t v15 = 4;
    if (sysctl(dword_1000EBC34, qword_1000EB4B8, &v16, &v15, 0, 0))
    {
      int v1 = *__error();
      int v2 = sub_10002E548();
      if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
        sub_100092CE4();
      }
      *__error() = v1;
      if (byte_1000EBCF9 && dword_1000EB4A8 <= 4)
      {
        int v3 = *__error();
        uint64_t v4 = *__error();
        uint64_t v5 = __error();
        uint64_t v6 = strerror(*v5);
        CFStringRef v7 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"sysctl for security.mac.sandbox.audio_active failed: %d (%s)", v4, v6);
        if (v7)
        {
          CFStringRef theString = v7;
          CStringPtr = CFStringGetCStringPtr(v7, 0x8000100u);
          if (CStringPtr)
          {
            id v9 = (char *)CStringPtr;
            uint64_t v10 = 0;
          }
          else
          {
            id v9 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x92D6838EuLL);
            CFStringGetCString(theString, v9, 1024, 0x8000100u);
            uint64_t v10 = v9;
          }
          if (qword_1000EBD00) {
            uint64_t v13 = (FILE *)qword_1000EBD00;
          }
          else {
            uint64_t v13 = __stderrp;
          }
          fprintf(v13, "%s\n", v9);
          if (v10) {
            free(v10);
          }
          CFRelease(theString);
        }
        else
        {
          uint64_t v11 = sub_10002E548();
          if (os_log_type_enabled(v11, OS_LOG_TYPE_FAULT)) {
            sub_100092C5C();
          }
          if (qword_1000EBD00) {
            uint64_t v12 = (FILE *)qword_1000EBD00;
          }
          else {
            uint64_t v12 = __stderrp;
          }
          fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v12);
        }
        *__error() = v3;
      }
      qword_1000EB4B8 = 0;
    }
    else if (v16)
    {
      return 1;
    }
  }
  return 0;
}

void sub_100024354(id a1)
{
  if (sysctlnametomib("security.mac.sandbox.audio_active", dword_1000EBC34, (size_t *)&qword_1000EB4B8))
  {
    int v1 = *__error();
    int v2 = sub_10002E548();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      sub_100092EF0();
    }
    *__error() = v1;
    if (byte_1000EBCF9) {
      BOOL v3 = dword_1000EB4A8 <= 4;
    }
    else {
      BOOL v3 = 0;
    }
    if (v3)
    {
      int v15 = *__error();
      uint64_t v4 = *__error();
      uint64_t v5 = __error();
      uint64_t v6 = strerror(*v5);
      CFStringRef v7 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"sysctlnametomib for security.mac.sandbox.audio_active failed: %d (%s)", v4, v6);
      if (v7)
      {
        CFStringRef theString = v7;
        CStringPtr = CFStringGetCStringPtr(v7, 0x8000100u);
        if (CStringPtr)
        {
          id v9 = (char *)CStringPtr;
          uint64_t v10 = 0;
        }
        else
        {
          id v9 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xF32869A9uLL);
          CFStringGetCString(theString, v9, 1024, 0x8000100u);
          uint64_t v10 = v9;
        }
        if (qword_1000EBD00) {
          uint64_t v13 = (FILE *)qword_1000EBD00;
        }
        else {
          uint64_t v13 = __stderrp;
        }
        fprintf(v13, "%s\n", v9);
        if (v10) {
          free(v10);
        }
        CFRelease(theString);
      }
      else
      {
        uint64_t v11 = sub_10002E548();
        if (os_log_type_enabled(v11, OS_LOG_TYPE_FAULT)) {
          sub_100092E68();
        }
        if (qword_1000EBD00) {
          uint64_t v12 = (FILE *)qword_1000EBD00;
        }
        else {
          uint64_t v12 = __stderrp;
        }
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v12);
      }
      *__error() = v15;
    }
    qword_1000EB4B8 = 0;
  }
}

void sub_10002453C(uint64_t a1, xpc_object_t object)
{
  if (xpc_get_type(object) == (xpc_type_t)&_xpc_type_error)
  {
    if (byte_1000EBCF8)
    {
      int v9 = *__error();
      uint64_t v10 = sub_10002E548();
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG)) {
        sub_100089A4C(object);
      }
      *__error() = v9;
    }
    if (byte_1000EBCF9) {
      BOOL v11 = dword_1000EB4A8 <= 0;
    }
    else {
      BOOL v11 = 0;
    }
    if (v11)
    {
      int v12 = *__error();
      string = xpc_dictionary_get_string(object, _xpc_error_key_description);
      CFStringRef v14 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"Got xpc error for peer: %s", string);
      if (v14)
      {
        CFStringRef v15 = v14;
        CStringPtr = CFStringGetCStringPtr(v14, 0x8000100u);
        if (CStringPtr)
        {
          BOOL v17 = (char *)CStringPtr;
          uint64_t v18 = 0;
        }
        else
        {
          BOOL v17 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xB3D357ACuLL);
          CFStringGetCString(v15, v17, 1024, 0x8000100u);
          uint64_t v18 = v17;
        }
        if (qword_1000EBD00) {
          uint64_t v21 = (FILE *)qword_1000EBD00;
        }
        else {
          uint64_t v21 = __stderrp;
        }
        fprintf(v21, "%s\n", v17);
        if (v18) {
          free(v18);
        }
        CFRelease(v15);
      }
      else
      {
        uint64_t v19 = sub_10002E548();
        if (os_log_type_enabled(v19, OS_LOG_TYPE_FAULT)) {
          sub_1000899D4(object, _xpc_error_key_description);
        }
        if (qword_1000EBD00) {
          uint64_t v20 = (FILE *)qword_1000EBD00;
        }
        else {
          uint64_t v20 = __stderrp;
        }
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v20);
      }
      *__error() = v12;
    }
  }
  else if (xpc_get_type(object) == (xpc_type_t)&_xpc_type_connection)
  {
    pid_t pid = xpc_connection_get_pid((xpc_connection_t)object);
    uid_t euid = xpc_connection_get_euid((xpc_connection_t)object);
    uint64_t v6 = (void *)xpc_connection_copy_entitlement_value();
    if (v6)
    {
      CFStringRef v7 = v6;
      BOOL v8 = xpc_get_type(v6) == (xpc_type_t)&_xpc_type_BOOL && xpc_BOOL_get_value(v7);
      xpc_release(v7);
    }
    else
    {
      BOOL v8 = 0;
    }
    xpc_connection_set_target_queue((xpc_connection_t)object, *(dispatch_queue_t *)(a1 + 32));
    handler[0] = _NSConcreteStackBlock;
    handler[1] = 3221225472;
    handler[2] = sub_10004865C;
    handler[3] = &unk_1000DD190;
    pid_t v23 = pid;
    uid_t v24 = euid;
    BOOL v25 = v8;
    __int16 v26 = 0;
    char v27 = 0;
    xpc_connection_set_event_handler((xpc_connection_t)object, handler);
    xpc_connection_resume((xpc_connection_t)object);
  }
}

size_t sub_100024838(char *a1, size_t a2, int a3, long double a4)
{
  size_t result = 0;
  if (a1 && a2)
  {
    memset(&v17, 0, sizeof(v17));
    time_t v16 = (uint64_t)(kCFAbsoluteTimeIntervalSince1970 + a4);
    localtime_r(&v16, &v17);
    size_t result = strftime(a1, a2, "%Y-%m-%d %T", &v17);
    if (result)
    {
      size_t v9 = result;
      uint64_t v10 = &a1[result];
      size_t v11 = a2 - result;
      if (a3)
      {
        double v12 = fmod(a4, 1.0);
        if (v12 > 0.0)
        {
          snprintf(&__str, 0x10uLL, "%f", v12);
          size_t v13 = strlcpy(v10, v19, v11);
          BOOL v14 = v11 > v13;
          v11 -= v13;
          if (!v14) {
            return a2 - 1;
          }
          v9 += v13;
          v10 += v13;
        }
      }
      size_t v15 = strftime(v10, v11, " %z", &v17);
      if (!v15) {
        v10[v9] = 0;
      }
      return v15 + v9;
    }
    else
    {
      *a1 = 0;
    }
  }
  return result;
}

const char *sub_1000249A0(unsigned int a1, int a2)
{
  int v2 = "hang";
  if (a2) {
    int v2 = "hang-lite";
  }
  if (a1 <= 0xE)
  {
    BOOL v3 = &off_1000DD388;
    if (a2) {
      BOOL v3 = &off_1000DD310;
    }
    return v3[a1];
  }
  return v2;
}

void sub_1000249E4(uint64_t a1, id a2, uint64_t a3, uint64_t a4, uint64_t a5, double a6, double a7, double a8, double a9, double a10)
{
  if ((a1 & 0x80000000) == 0)
  {
    if (byte_1000EBCF8)
    {
      int v20 = *__error();
      uint64_t v21 = sub_10002E548();
      if (os_log_type_enabled(v21, OS_LOG_TYPE_INFO))
      {
        *(_DWORD *)buf = 136447490;
        CFStringRef v149 = sub_10002E4E8(a1);
        __int16 v150 = 1024;
        *(_DWORD *)uint64_t v151 = a1;
        *(_WORD *)&v151[4] = 2048;
        *(void *)&v151[6] = a3;
        *(_WORD *)&v151[14] = 2048;
        *(double *)&v151[16] = a6;
        *(_WORD *)&v151[24] = 2048;
        *(double *)&v151[26] = a7;
        __int16 v152 = 2048;
        uint64_t v153 = a4;
        _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_INFO, "%{public}s [%d]: cpu resource: thread %#llx using %.0fs cpu over the last %.0f seconds with flags %#llx", buf, 0x3Au);
      }
      *__error() = v20;
    }
    if (byte_1000EBCF9) {
      BOOL v22 = dword_1000EB4A8 <= 1;
    }
    else {
      BOOL v22 = 0;
    }
    if (!v22) {
      goto LABEL_52;
    }
    int v23 = *__error();
    uid_t v24 = sub_10002E4E8(a1);
    CFStringRef v25 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%s [%d]: cpu resource: thread %#llx using %.0fs cpu over the last %.0f seconds with flags %#llx", v24, a1, a3, *(void *)&a6, *(void *)&a7, a4);
    if (v25)
    {
      CFStringRef v26 = v25;
      CStringPtr = CFStringGetCStringPtr(v25, 0x8000100u);
      if (CStringPtr)
      {
        CFStringRef v28 = (char *)CStringPtr;
        uint64_t v29 = 0;
      }
      else
      {
        CFStringRef v28 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xE54B822BuLL);
        CFStringGetCString(v26, v28, 1024, 0x8000100u);
        uint64_t v29 = v28;
      }
      if (qword_1000EBD00) {
        unsigned int v39 = (FILE *)qword_1000EBD00;
      }
      else {
        unsigned int v39 = __stderrp;
      }
      fprintf(v39, "%s\n", v28);
      if (v29) {
        free(v29);
      }
LABEL_50:
      CFRelease(v26);
      goto LABEL_51;
    }
    int v37 = sub_10002E548();
    if (os_log_type_enabled(v37, OS_LOG_TYPE_FAULT))
    {
      CFStringRef v135 = sub_10002E4E8(a1);
      *(_DWORD *)buf = 136316418;
      CFStringRef v149 = v135;
      __int16 v150 = 1024;
      *(_DWORD *)uint64_t v151 = a1;
      *(_WORD *)&v151[4] = 2048;
      *(void *)&v151[6] = a3;
      *(_WORD *)&v151[14] = 2048;
      *(double *)&v151[16] = a6;
      *(_WORD *)&v151[24] = 2048;
      *(double *)&v151[26] = a7;
      __int16 v152 = 2048;
      uint64_t v153 = a4;
      _os_log_fault_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_FAULT, "Unable to format: %s [%d]: cpu resource: thread %#llx using %.0fs cpu over the last %.0f seconds with flags %#llx", buf, 0x3Au);
    }
    if (qword_1000EBD00) {
      int v38 = (FILE *)qword_1000EBD00;
    }
    else {
      int v38 = __stderrp;
    }
    goto LABEL_31;
  }
  if (byte_1000EBCF8)
  {
    int v30 = *__error();
    int v31 = sub_10002E548();
    if (os_log_type_enabled(v31, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 134218752;
      CFStringRef v149 = (_DWORD *)a3;
      __int16 v150 = 2048;
      *(double *)uint64_t v151 = a6;
      *(_WORD *)&v151[8] = 2048;
      *(double *)&v151[10] = a7;
      *(_WORD *)&v151[18] = 2048;
      *(void *)&v151[20] = a4;
      _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_INFO, "cpu resource: thread %#llx using %.0fs cpu over the last %.0f seconds with flags %#llx", buf, 0x2Au);
    }
    *__error() = v30;
  }
  if (byte_1000EBCF9) {
    BOOL v32 = dword_1000EB4A8 <= 1;
  }
  else {
    BOOL v32 = 0;
  }
  if (v32)
  {
    int v23 = *__error();
    CFStringRef v33 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"cpu resource: thread %#llx using %.0fs cpu over the last %.0f seconds with flags %#llx", a3, *(void *)&a6, *(void *)&a7, a4);
    if (v33)
    {
      CFStringRef v26 = v33;
      uint64_t v34 = CFStringGetCStringPtr(v33, 0x8000100u);
      if (v34)
      {
        __int16 v35 = (char *)v34;
        v36 = 0;
      }
      else
      {
        __int16 v35 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xE54B822BuLL);
        CFStringGetCString(v26, v35, 1024, 0x8000100u);
        v36 = v35;
      }
      if (qword_1000EBD00) {
        CFStringRef v41 = (FILE *)qword_1000EBD00;
      }
      else {
        CFStringRef v41 = __stderrp;
      }
      fprintf(v41, "%s\n", v35);
      if (v36) {
        free(v36);
      }
      goto LABEL_50;
    }
    int v40 = sub_10002E548();
    if (os_log_type_enabled(v40, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)buf = 134218752;
      CFStringRef v149 = (_DWORD *)a3;
      __int16 v150 = 2048;
      *(double *)uint64_t v151 = a6;
      *(_WORD *)&v151[8] = 2048;
      *(double *)&v151[10] = a7;
      *(_WORD *)&v151[18] = 2048;
      *(void *)&v151[20] = a4;
      _os_log_fault_impl((void *)&_mh_execute_header, v40, OS_LOG_TYPE_FAULT, "Unable to format: cpu resource: thread %#llx using %.0fs cpu over the last %.0f seconds with flags %#llx", buf, 0x2Au);
    }
    if (qword_1000EBD00) {
      int v38 = (FILE *)qword_1000EBD00;
    }
    else {
      int v38 = __stderrp;
    }
LABEL_31:
    fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v38);
LABEL_51:
    *__error() = v23;
  }
LABEL_52:
  uint64_t v144 = sub_10002E5C4(a1);
  if (!a2) {
    a2 = sub_10002E60C(a1);
  }
  uint64_t v147 = 0;
  uint64_t v42 = sub_100040988(a1, (uint64_t)"cpu resource", 160, &v147);
  if ((word_1000EBD38 & 0x80) == 0)
  {
    if ((a1 & 0x80000000) != 0)
    {
      if (byte_1000EBCF8)
      {
        int v49 = *__error();
        double v50 = sub_10002E548();
        if (os_log_type_enabled(v50, OS_LOG_TYPE_DEBUG)) {
          sub_100085EDC();
        }
        *__error() = v49;
      }
      if (!byte_1000EBCF9 || dword_1000EB4A8 > 0) {
        goto LABEL_88;
      }
      int v45 = *__error();
      CFStringRef v47 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"cpu resource: not monitoring due to suppression cookie file");
      if (!v47)
      {
        v57 = sub_10002E548();
        if (os_log_type_enabled(v57, OS_LOG_TYPE_FAULT)) {
          sub_100085EA8();
        }
        goto LABEL_83;
      }
    }
    else
    {
      if (byte_1000EBCF8)
      {
        int v43 = *__error();
        v44 = sub_10002E548();
        if (os_log_type_enabled(v44, OS_LOG_TYPE_DEBUG)) {
          sub_100085E30();
        }
        *__error() = v43;
      }
      if (!byte_1000EBCF9 || dword_1000EB4A8 > 0) {
        goto LABEL_88;
      }
      int v45 = *__error();
      v46 = sub_10002E4E8(a1);
      CFStringRef v47 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%s [%d]: cpu resource: not monitoring due to suppression cookie file", v46, a1);
      if (!v47)
      {
        v48 = sub_10002E548();
        if (os_log_type_enabled(v48, OS_LOG_TYPE_FAULT)) {
          sub_100085DB8();
        }
LABEL_83:
        if (qword_1000EBD00) {
          v58 = (FILE *)qword_1000EBD00;
        }
        else {
          v58 = __stderrp;
        }
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v58);
LABEL_87:
        *__error() = v45;
LABEL_88:
        v42 |= 0x8000uLL;
        goto LABEL_89;
      }
    }
    CFStringRef v51 = v47;
    uint64_t v140 = a5;
    id v141 = a2;
    uint64_t v52 = a4;
    CFStringRef v53 = CFStringGetCStringPtr(v47, 0x8000100u);
    if (v53)
    {
      CFStringRef v54 = (char *)v53;
      CFStringRef v55 = 0;
    }
    else
    {
      CFStringRef v54 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xD868E7ACuLL);
      CFStringGetCString(v51, v54, 1024, 0x8000100u);
      CFStringRef v55 = v54;
    }
    if (qword_1000EBD00) {
      v56 = (FILE *)qword_1000EBD00;
    }
    else {
      v56 = __stderrp;
    }
    fprintf(v56, "%s\n", v54);
    if (v55) {
      free(v55);
    }
    CFRelease(v51);
    a4 = v52;
    a5 = v140;
    a2 = v141;
    goto LABEL_87;
  }
LABEL_89:
  if ((sub_10004B288((const char *)[a2 UTF8String], 1) & 1) != 0
    || !sub_100041218(*(double *)&qword_1000EBD30))
  {
    if (v42) {
      goto LABEL_167;
    }
    uint64_t v65 = v147;
    if ((v147 & 0x80000000000) == 0)
    {
LABEL_103:
      uint64_t v66 = sub_10002E390("CPU resource for [%d] thread %#llx", a1, a3);
      global_queue = dispatch_get_global_queue(9, 0);
      block[0] = _NSConcreteStackBlock;
      block[1] = 3221225472;
      block[2] = sub_10004154C;
      block[3] = &unk_1000DCFC8;
      int v146 = a1;
      block[7] = a3;
      block[8] = a4;
      block[4] = a2;
      block[5] = a5;
      *(double *)&block[9] = a6;
      *(double *)&block[10] = a7;
      *(double *)&block[11] = a8;
      *(double *)&block[12] = a9;
      *(double *)&block[13] = a10;
      block[14] = v144;
      block[15] = v65;
      block[6] = v66;
      dispatch_async(global_queue, block);
      return;
    }
    if (sub_10004DBA8())
    {
      if ((a1 & 0x80000000) != 0)
      {
        if (byte_1000EBCF8)
        {
          uint64_t v90 = a3;
          int v91 = *__error();
          CFStringRef v92 = sub_10002E548();
          if (os_log_type_enabled(v92, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)buf = 0;
            _os_log_impl((void *)&_mh_execute_header, v92, OS_LOG_TYPE_DEFAULT, "cpu resource: deferring report generation due to game mode", buf, 2u);
          }
          *__error() = v91;
          a3 = v90;
        }
        if (!byte_1000EBCF9 || dword_1000EB4A8 > 2) {
          goto LABEL_223;
        }
        uint64_t v142 = a3;
        int v72 = *__error();
        CFStringRef v74 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"cpu resource: deferring report generation due to game mode");
        if (!v74)
        {
          v136 = sub_10002E548();
          if (os_log_type_enabled(v136, OS_LOG_TYPE_FAULT)) {
            sub_1000859EC();
          }
          goto LABEL_218;
        }
      }
      else
      {
        if (byte_1000EBCF8)
        {
          uint64_t v68 = a3;
          int v69 = *__error();
          v70 = sub_10002E548();
          if (os_log_type_enabled(v70, OS_LOG_TYPE_DEFAULT))
          {
            v71 = sub_10002E4E8(a1);
            *(_DWORD *)buf = 136446466;
            CFStringRef v149 = v71;
            __int16 v150 = 1024;
            *(_DWORD *)uint64_t v151 = a1;
            _os_log_impl((void *)&_mh_execute_header, v70, OS_LOG_TYPE_DEFAULT, "%{public}s [%d]: cpu resource: deferring report generation due to game mode", buf, 0x12u);
          }
          *__error() = v69;
          a3 = v68;
        }
        if (!byte_1000EBCF9 || dword_1000EB4A8 > 2) {
          goto LABEL_223;
        }
        uint64_t v142 = a3;
        int v72 = *__error();
        int v73 = sub_10002E4E8(a1);
        CFStringRef v74 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%s [%d]: cpu resource: deferring report generation due to game mode", v73, a1);
        if (!v74)
        {
          int v75 = sub_10002E548();
          if (os_log_type_enabled(v75, OS_LOG_TYPE_FAULT)) {
            sub_100085974();
          }
LABEL_218:
          if (qword_1000EBD00) {
            uint64_t v137 = (FILE *)qword_1000EBD00;
          }
          else {
            uint64_t v137 = __stderrp;
          }
          fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v137);
LABEL_222:
          *__error() = v72;
          a3 = v142;
LABEL_223:
          sub_10004E3CC(a1, (uint64_t)a2, a3, a4, a5, a6, a7, a8, a9, a10);
          uint64_t v126 = v65 | 0x100000000000;
          double v127 = a8 - a7;
          char v128 = a4 & 1;
          int v129 = a1;
          v130 = a2;
          uint64_t v131 = v144;
          uint64_t v132 = 0;
          goto LABEL_201;
        }
      }
      CFStringRef v93 = v74;
      id v94 = a2;
      uint64_t v95 = a5;
      v96 = CFStringGetCStringPtr(v74, 0x8000100u);
      if (v96)
      {
        int v97 = (char *)v96;
        CFStringRef v98 = 0;
      }
      else
      {
        int v97 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x3AE2B06FuLL);
        CFStringGetCString(v93, v97, 1024, 0x8000100u);
        CFStringRef v98 = v97;
      }
      if (qword_1000EBD00) {
        BOOL v133 = (FILE *)qword_1000EBD00;
      }
      else {
        BOOL v133 = __stderrp;
      }
      fprintf(v133, "%s\n", v97);
      if (v98) {
        free(v98);
      }
      CFRelease(v93);
      a5 = v95;
      a2 = v94;
      goto LABEL_222;
    }
    if ((a1 & 0x80000000) != 0)
    {
      if (byte_1000EBCF8)
      {
        uint64_t v99 = a3;
        int v100 = *__error();
        v101 = sub_10002E548();
        if (os_log_type_enabled(v101, OS_LOG_TYPE_DEBUG)) {
          sub_100085B44();
        }
        *__error() = v100;
        a3 = v99;
      }
      if (!byte_1000EBCF9 || dword_1000EB4A8 > 0) {
        goto LABEL_103;
      }
      uint64_t v143 = a3;
      int v85 = *__error();
      CFStringRef v87 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"cpu resource: cannot defer report generation for game mode");
      if (!v87)
      {
        uint64_t v138 = sub_10002E548();
        if (os_log_type_enabled(v138, OS_LOG_TYPE_FAULT)) {
          sub_100085B10();
        }
        goto LABEL_226;
      }
    }
    else
    {
      if (byte_1000EBCF8)
      {
        uint64_t v82 = a3;
        int v83 = *__error();
        int v84 = sub_10002E548();
        if (os_log_type_enabled(v84, OS_LOG_TYPE_DEBUG)) {
          sub_100085A98();
        }
        *__error() = v83;
        a3 = v82;
      }
      if (!byte_1000EBCF9 || dword_1000EB4A8 > 0) {
        goto LABEL_103;
      }
      uint64_t v143 = a3;
      int v85 = *__error();
      __int16 v86 = sub_10002E4E8(a1);
      CFStringRef v87 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%s [%d]: cpu resource: cannot defer report generation for game mode", v86, a1);
      if (!v87)
      {
        int v88 = sub_10002E548();
        if (os_log_type_enabled(v88, OS_LOG_TYPE_FAULT)) {
          sub_100085A20();
        }
LABEL_226:
        if (qword_1000EBD00) {
          uint64_t v139 = (FILE *)qword_1000EBD00;
        }
        else {
          uint64_t v139 = __stderrp;
        }
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v139);
LABEL_230:
        *__error() = v85;
        a3 = v143;
        goto LABEL_103;
      }
    }
    CFStringRef v102 = v87;
    id v103 = a2;
    uint64_t v104 = a5;
    CFStringRef v105 = CFStringGetCStringPtr(v87, 0x8000100u);
    if (v105)
    {
      char v106 = (char *)v105;
      int v107 = 0;
    }
    else
    {
      char v106 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xED78B3E4uLL);
      CFStringGetCString(v102, v106, 1024, 0x8000100u);
      int v107 = v106;
    }
    if (qword_1000EBD00) {
      int v134 = (FILE *)qword_1000EBD00;
    }
    else {
      int v134 = __stderrp;
    }
    fprintf(v134, "%s\n", v106);
    if (v107) {
      free(v107);
    }
    CFRelease(v102);
    a5 = v104;
    a2 = v103;
    goto LABEL_230;
  }
  if ((a1 & 0x80000000) != 0)
  {
    if (byte_1000EBCF8)
    {
      int v76 = *__error();
      int v77 = sub_10002E548();
      if (os_log_type_enabled(v77, OS_LOG_TYPE_DEBUG)) {
        sub_100085D84();
      }
      *__error() = v76;
    }
    if (!byte_1000EBCF9 || dword_1000EB4A8 > 0) {
      goto LABEL_166;
    }
    int v61 = *__error();
    CFStringRef v63 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"cpu resource: not monitoring due to throttling the number of reports generated for 1st party processes");
    if (!v63)
    {
      v108 = sub_10002E548();
      if (os_log_type_enabled(v108, OS_LOG_TYPE_FAULT)) {
        sub_100085D50();
      }
      goto LABEL_161;
    }
LABEL_122:
    CFStringRef v78 = v63;
    CFStringRef v79 = CFStringGetCStringPtr(v63, 0x8000100u);
    if (v79)
    {
      v80 = (char *)v79;
      v81 = 0;
    }
    else
    {
      v80 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x9746029EuLL);
      CFStringGetCString(v78, v80, 1024, 0x8000100u);
      v81 = v80;
    }
    if (qword_1000EBD00) {
      v89 = (FILE *)qword_1000EBD00;
    }
    else {
      v89 = __stderrp;
    }
    fprintf(v89, "%s\n", v80);
    if (v81) {
      free(v81);
    }
    CFRelease(v78);
    goto LABEL_165;
  }
  if (byte_1000EBCF8)
  {
    int v59 = *__error();
    __int16 v60 = sub_10002E548();
    if (os_log_type_enabled(v60, OS_LOG_TYPE_DEBUG)) {
      sub_100085CD8();
    }
    *__error() = v59;
  }
  if (!byte_1000EBCF9 || dword_1000EB4A8 > 0) {
    goto LABEL_166;
  }
  int v61 = *__error();
  int v62 = sub_10002E4E8(a1);
  CFStringRef v63 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%s [%d]: cpu resource: not monitoring due to throttling the number of reports generated for 1st party processes", v62, a1);
  if (v63) {
    goto LABEL_122;
  }
  unsigned int v64 = sub_10002E548();
  if (os_log_type_enabled(v64, OS_LOG_TYPE_FAULT)) {
    sub_100085C60();
  }
LABEL_161:
  if (qword_1000EBD00) {
    int v109 = (FILE *)qword_1000EBD00;
  }
  else {
    int v109 = __stderrp;
  }
  fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v109);
LABEL_165:
  *__error() = v61;
LABEL_166:
  v42 |= 0x200000uLL;
LABEL_167:
  if ((a1 & 0x80000000) != 0)
  {
    if (byte_1000EBCF8)
    {
      int v117 = *__error();
      int v118 = sub_10002E548();
      if (os_log_type_enabled(v118, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 134217984;
        CFStringRef v149 = (_DWORD *)v42;
        _os_log_impl((void *)&_mh_execute_header, v118, OS_LOG_TYPE_DEFAULT, "cpu resource: not monitoring due to conditions %#llx", buf, 0xCu);
      }
      *__error() = v117;
    }
    if (!byte_1000EBCF9 || dword_1000EB4A8 > 2) {
      goto LABEL_200;
    }
    int v113 = *__error();
    CFStringRef v115 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"cpu resource: not monitoring due to conditions %#llx", v42);
    if (!v115)
    {
      int v124 = sub_10002E548();
      if (os_log_type_enabled(v124, OS_LOG_TYPE_FAULT)) {
        sub_100085BF8();
      }
      goto LABEL_195;
    }
LABEL_184:
    CFStringRef v119 = v115;
    int v120 = CFStringGetCStringPtr(v115, 0x8000100u);
    if (v120)
    {
      CFStringRef v121 = (char *)v120;
      CFStringRef v122 = 0;
    }
    else
    {
      CFStringRef v121 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xDAF86EE3uLL);
      CFStringGetCString(v119, v121, 1024, 0x8000100u);
      CFStringRef v122 = v121;
    }
    if (qword_1000EBD00) {
      v123 = (FILE *)qword_1000EBD00;
    }
    else {
      v123 = __stderrp;
    }
    fprintf(v123, "%s\n", v121);
    if (v122) {
      free(v122);
    }
    CFRelease(v119);
    goto LABEL_199;
  }
  if (byte_1000EBCF8)
  {
    int v110 = *__error();
    CFStringRef v111 = sub_10002E548();
    if (os_log_type_enabled(v111, OS_LOG_TYPE_DEFAULT))
    {
      int v112 = sub_10002E4E8(a1);
      *(_DWORD *)buf = 136446722;
      CFStringRef v149 = v112;
      __int16 v150 = 1024;
      *(_DWORD *)uint64_t v151 = a1;
      *(_WORD *)&v151[4] = 2048;
      *(void *)&v151[6] = v42;
      _os_log_impl((void *)&_mh_execute_header, v111, OS_LOG_TYPE_DEFAULT, "%{public}s [%d]: cpu resource: not monitoring due to conditions %#llx", buf, 0x1Cu);
    }
    *__error() = v110;
  }
  if (!byte_1000EBCF9 || dword_1000EB4A8 > 2) {
    goto LABEL_200;
  }
  int v113 = *__error();
  unsigned int v114 = sub_10002E4E8(a1);
  CFStringRef v115 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%s [%d]: cpu resource: not monitoring due to conditions %#llx", v114, a1, v42);
  if (v115) {
    goto LABEL_184;
  }
  CFStringRef v116 = sub_10002E548();
  if (os_log_type_enabled(v116, OS_LOG_TYPE_FAULT)) {
    sub_100085B78();
  }
LABEL_195:
  if (qword_1000EBD00) {
    v125 = (FILE *)qword_1000EBD00;
  }
  else {
    v125 = __stderrp;
  }
  fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v125);
LABEL_199:
  *__error() = v113;
LABEL_200:
  uint64_t v126 = v147;
  double v127 = a8 - a7;
  char v128 = a4 & 1;
  int v129 = a1;
  v130 = a2;
  uint64_t v131 = v144;
  uint64_t v132 = v42;
LABEL_201:
  sub_10002EFB4(v129, v130, v131, v132, v126, v128, v127, a8, a6);
}

uint64_t sub_100025D2C(char *a1, off_t a2, uint64_t a3, unsigned char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, double a9, double a10, double a11, double a12, double a13, double a14, double a15, unsigned int a16, unsigned __int8 a17, uint64_t a18, uint64_t a19, char a20,int a21,unsigned int a22,char a23,void *a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,unsigned int a29,unsigned int a30,void *a31,uint64_t a32)
{
  if (a16 - 5 >= 6)
  {
    if ((a3 & 0x80000000) != 0)
    {
      if (byte_1000EBCF8)
      {
        int v372 = *__error();
        v373 = sub_10002E548();
        if (os_log_type_enabled(v373, OS_LOG_TYPE_ERROR)) {
          sub_10008CF5C();
        }
        *__error() = v372;
      }
      if (byte_1000EBCF9 && dword_1000EB4A8 <= 3)
      {
        int v374 = *__error();
        CFStringRef v375 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%s: Bad report type for microstackshots %d", "report_type == DID_SYSTEM_STATS || report_type == DID_SYSTEM_STATS_IO || report_type == DID_MANUAL_MICROSTACKSHOTS || report_type == DID_MANUAL_MICROSTACKSHOTS_IO || report_type == DID_CPU_RESOURCE || report_type == DID_DISK_WRITES_RESOURCE", a16);
        if (v375)
        {
          CFStringRef v382 = v375;
          CStringPtr = CFStringGetCStringPtr(v375, 0x8000100u);
          if (CStringPtr)
          {
            v384 = (char *)CStringPtr;
            v385 = 0;
          }
          else
          {
            v384 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x626963BuLL);
            CFStringGetCString(v382, v384, 1024, 0x8000100u);
            v385 = v384;
          }
          if (qword_1000EBD00) {
            v387 = (FILE *)qword_1000EBD00;
          }
          else {
            v387 = __stderrp;
          }
          fprintf(v387, "%s\n", v384);
          if (v385) {
            free(v385);
          }
          CFRelease(v382);
        }
        else
        {
          v376 = sub_10002E548();
          if (os_log_type_enabled(v376, OS_LOG_TYPE_FAULT)) {
            sub_10008CEE4();
          }
          if (qword_1000EBD00) {
            v377 = (FILE *)qword_1000EBD00;
          }
          else {
            v377 = __stderrp;
          }
          fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v377);
        }
        *__error() = v374;
      }
      v388 = "report_type == DID_SYSTEM_STATS || report_type == DID_SYSTEM_STATS_IO || report_type == DID_MANUAL_MICROSTA"
             "CKSHOTS || report_type == DID_MANUAL_MICROSTACKSHOTS_IO || report_type == DID_CPU_RESOURCE || report_type ="
             "= DID_DISK_WRITES_RESOURCE";
      v339 = "%s: Bad report type for microstackshots %d";
    }
    else
    {
      if (byte_1000EBCF8)
      {
        int v363 = *__error();
        v364 = sub_10002E548();
        if (os_log_type_enabled(v364, OS_LOG_TYPE_ERROR)) {
          sub_10008CE58();
        }
        *__error() = v363;
      }
      if (byte_1000EBCF9 && dword_1000EB4A8 <= 3)
      {
        int v365 = *__error();
        v366 = sub_10002E4E8(a3);
        CFStringRef v367 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%s [%d]: %s: Bad report type for microstackshots %d", v366, a3, "report_type == DID_SYSTEM_STATS || report_type == DID_SYSTEM_STATS_IO || report_type == DID_MANUAL_MICROSTACKSHOTS || report_type == DID_MANUAL_MICROSTACKSHOTS_IO || report_type == DID_CPU_RESOURCE || report_type == DID_DISK_WRITES_RESOURCE", a16);
        if (v367)
        {
          CFStringRef v378 = v367;
          v379 = CFStringGetCStringPtr(v367, 0x8000100u);
          if (v379)
          {
            v380 = (char *)v379;
            v381 = 0;
          }
          else
          {
            v380 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x626963BuLL);
            CFStringGetCString(v378, v380, 1024, 0x8000100u);
            v381 = v380;
          }
          if (qword_1000EBD00) {
            v386 = (FILE *)qword_1000EBD00;
          }
          else {
            v386 = __stderrp;
          }
          fprintf(v386, "%s\n", v380);
          if (v381) {
            free(v381);
          }
          CFRelease(v378);
        }
        else
        {
          v368 = sub_10002E548();
          if (os_log_type_enabled(v368, OS_LOG_TYPE_FAULT)) {
            sub_10008CDCC();
          }
          if (qword_1000EBD00) {
            v369 = (FILE *)qword_1000EBD00;
          }
          else {
            v369 = __stderrp;
          }
          fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v369);
        }
        *__error() = v365;
      }
      LOBYTE(v388) = sub_10002E4E8(a3);
      v339 = "%s [%d]: %s: Bad report type for microstackshots %d";
    }
    int v341 = 153;
LABEL_554:
    sub_10002E41C("DoMicrostackshotsOnly", "microstackshot.m", v341, v339, a5, a6, a7, a8, (char)v388);
    abort();
  }
  if (a16 - 7 < 2 != [a24 systemstatsFormat])
  {
    if ((a3 & 0x80000000) != 0)
    {
      if (byte_1000EBCF8)
      {
        int v323 = *__error();
        v324 = sub_10002E548();
        if (os_log_type_enabled(v324, OS_LOG_TYPE_ERROR)) {
          sub_10008B820(a24, a16, v324);
        }
        *__error() = v323;
      }
      if (byte_1000EBCF9 && dword_1000EB4A8 <= 3)
      {
        int v325 = *__error();
        CFStringRef v326 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%s: report_type %d, but systemstatsFormat %d", "((!!(report_type == DID_SYSTEM_STATS || report_type == DID_SYSTEM_STATS_IO)) == (!!printOptions.systemstatsFormat))", a16, [a24 systemstatsFormat]);
        if (v326)
        {
          CFStringRef v333 = v326;
          v334 = CFStringGetCStringPtr(v326, 0x8000100u);
          if (v334)
          {
            v335 = (char *)v334;
            v336 = 0;
          }
          else
          {
            v335 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xBFB587AEuLL);
            CFStringGetCString(v333, v335, 1024, 0x8000100u);
            v336 = v335;
          }
          if (qword_1000EBD00) {
            v340 = (FILE *)qword_1000EBD00;
          }
          else {
            v340 = __stderrp;
          }
          fprintf(v340, "%s\n", v335);
          if (v336) {
            free(v336);
          }
          CFRelease(v333);
        }
        else
        {
          v327 = sub_10002E548();
          if (os_log_type_enabled(v327, OS_LOG_TYPE_FAULT)) {
            sub_10008B798(a24);
          }
          if (qword_1000EBD00) {
            v328 = (FILE *)qword_1000EBD00;
          }
          else {
            v328 = __stderrp;
          }
          fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v328);
        }
        *__error() = v325;
      }
      [a24 systemstatsFormat];
      v388 = "((!!(report_type == DID_SYSTEM_STATS || report_type == DID_SYSTEM_STATS_IO)) == (!!printOptions.systemstatsFormat))";
      v339 = "%s: report_type %d, but systemstatsFormat %d";
    }
    else
    {
      if (byte_1000EBCF8)
      {
        int v314 = *__error();
        v315 = sub_10002E548();
        if (os_log_type_enabled(v315, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136316162;
          *(void *)&uint8_t buf[4] = sub_10002E4E8(a3);
          __int16 v403 = 1024;
          __int16 v405 = 2080;
          int v404 = a3;
          v406 = "((!!(report_type == DID_SYSTEM_STATS || report_type == DID_SYSTEM_STATS_IO)) == (!!printOptions.systemstatsFormat))";
          __int16 v407 = 1024;
          unsigned int v408 = a16;
          __int16 v409 = 1024;
          unsigned int v410 = [a24 systemstatsFormat];
          _os_log_error_impl((void *)&_mh_execute_header, v315, OS_LOG_TYPE_ERROR, "%s [%d]: %s: report_type %d, but systemstatsFormat %d", buf, 0x28u);
        }
        *__error() = v314;
      }
      if (byte_1000EBCF9 && dword_1000EB4A8 <= 3)
      {
        int v316 = *__error();
        v317 = sub_10002E4E8(a3);
        CFStringRef v318 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%s [%d]: %s: report_type %d, but systemstatsFormat %d", v317, a3, "((!!(report_type == DID_SYSTEM_STATS || report_type == DID_SYSTEM_STATS_IO)) == (!!printOptions.systemstatsFormat))", a16, [a24 systemstatsFormat]);
        if (v318)
        {
          CFStringRef v329 = v318;
          v330 = CFStringGetCStringPtr(v318, 0x8000100u);
          if (v330)
          {
            v331 = (char *)v330;
            v332 = 0;
          }
          else
          {
            v331 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xBFB587AEuLL);
            CFStringGetCString(v329, v331, 1024, 0x8000100u);
            v332 = v331;
          }
          if (qword_1000EBD00) {
            v337 = (FILE *)qword_1000EBD00;
          }
          else {
            v337 = __stderrp;
          }
          fprintf(v337, "%s\n", v331);
          if (v332) {
            free(v332);
          }
          CFRelease(v329);
        }
        else
        {
          v319 = sub_10002E548();
          if (os_log_type_enabled(v319, OS_LOG_TYPE_FAULT))
          {
            v320 = sub_10002E4E8(a3);
            unsigned int v321 = [a24 systemstatsFormat];
            *(_DWORD *)buf = 136316162;
            *(void *)&uint8_t buf[4] = v320;
            __int16 v403 = 1024;
            int v404 = a3;
            __int16 v405 = 2080;
            v406 = "((!!(report_type == DID_SYSTEM_STATS || report_type == DID_SYSTEM_STATS_IO)) == (!!printOptions.systemstatsFormat))";
            __int16 v407 = 1024;
            unsigned int v408 = a16;
            __int16 v409 = 1024;
            unsigned int v410 = v321;
            _os_log_fault_impl((void *)&_mh_execute_header, v319, OS_LOG_TYPE_FAULT, "Unable to format: %s [%d]: %s: report_type %d, but systemstatsFormat %d", buf, 0x28u);
          }
          if (qword_1000EBD00) {
            v322 = (FILE *)qword_1000EBD00;
          }
          else {
            v322 = __stderrp;
          }
          fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v322);
        }
        *__error() = v316;
      }
      unsigned __int8 v338 = sub_10002E4E8(a3);
      [a24 systemstatsFormat];
      LOBYTE(v388) = v338;
      v339 = "%s [%d]: %s: report_type %d, but systemstatsFormat %d";
    }
    int v341 = 155;
    goto LABEL_554;
  }
  unsigned int v33 = a16 - 5;
  unsigned int v394 = a16 - 5;
  if (a16 == 5 && a6)
  {
    id v46 = +[SAAuxiliaryData auxiliaryDataForTimestamp:](SAAuxiliaryData, "auxiliaryDataForTimestamp:", +[SATimestamp timestamp]);
    id v47 = sub_10004BB60(a3, a4, 1);
LABEL_7:
    int v51 = sub_10004B288((const char *)[v47 UTF8String], a6);
    uint64_t v49 = 0;
    if (v51) {
      int v50 = a3;
    }
    else {
      int v50 = -1;
    }
    id v48 = v46;
    goto LABEL_11;
  }
  id v47 = sub_10004BB60(a3, a4, a6);
  id v46 = 0;
  id v48 = 0;
  uint64_t v49 = a5;
  int v50 = a3;
  if (v33 <= 1) {
    goto LABEL_7;
  }
LABEL_11:
  id v52 = v48;
  id v53 = sub_10002905C(a1, a2, v50, v49, a6, 1, 0, a22, a9, a10, a27, a28, a29, a30, a32);
  CFStringRef v54 = v53;
  uint64_t v55 = a3;
  uint64_t v56 = a16;
  if (!v53) {
    goto LABEL_24;
  }
  if ((v55 & 0x80000000) == 0) {
    [v53 setTargetProcessId:v55];
  }
  if (a5) {
    [v54 setTargetThreadId:a5];
  }
  if (v47)
  {
    if ((objc_msgSend(objc_msgSend(objc_msgSend(v54, "targetProcess"), "mainBinaryPath"), "isAbsolutePath") & 1) == 0)
    {
      id v57 = [v54 targetProcess];
      if (v57)
      {
        [v57 setMainBinaryPath:v47];
        [v54 postprocess];
      }
    }
  }
  if (!objc_msgSend(objc_msgSend(v54, "tasksByPid"), "count"))
  {
LABEL_24:
    if ((v55 & 0x80000000) != 0)
    {
      if (byte_1000EBCF8)
      {
        int v64 = *__error();
        uint64_t v65 = sub_10002E548();
        if (os_log_type_enabled(v65, OS_LOG_TYPE_ERROR)) {
          sub_10008B9DC();
        }
        *__error() = v64;
      }
      if (!byte_1000EBCF9 || dword_1000EB4A8 > 3) {
        goto LABEL_92;
      }
      int v60 = *__error();
      CFStringRef v62 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"No microstackshots found");
      if (!v62)
      {
        v96 = sub_10002E548();
        if (os_log_type_enabled(v96, OS_LOG_TYPE_FAULT)) {
          sub_10008B9A8();
        }
        goto LABEL_87;
      }
LABEL_41:
      CFStringRef v66 = v62;
      CFStringRef v67 = CFStringGetCStringPtr(v62, 0x8000100u);
      if (v67)
      {
        uint64_t v68 = (char *)v67;
        int v69 = 0;
      }
      else
      {
        uint64_t v68 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xF8B452BuLL);
        CFStringGetCString(v66, v68, 1024, 0x8000100u);
        int v69 = v68;
      }
      if (qword_1000EBD00) {
        int v85 = (FILE *)qword_1000EBD00;
      }
      else {
        int v85 = __stderrp;
      }
      fprintf(v85, "%s\n", v68);
      if (v69) {
        free(v69);
      }
      CFRelease(v66);
      goto LABEL_91;
    }
LABEL_25:
    if (byte_1000EBCF8)
    {
      int v58 = *__error();
      int v59 = sub_10002E548();
      if (os_log_type_enabled(v59, OS_LOG_TYPE_ERROR)) {
        sub_10008B930();
      }
      *__error() = v58;
    }
    if (!byte_1000EBCF9 || dword_1000EB4A8 > 3) {
      goto LABEL_92;
    }
    int v60 = *__error();
    int v61 = sub_10002E4E8(v55);
    CFStringRef v62 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%s [%d]: No microstackshots found", v61, v55);
    if (!v62)
    {
      CFStringRef v63 = sub_10002E548();
      if (os_log_type_enabled(v63, OS_LOG_TYPE_FAULT)) {
        sub_10008B8B8();
      }
LABEL_87:
      if (qword_1000EBD00) {
        int v97 = (FILE *)qword_1000EBD00;
      }
      else {
        int v97 = __stderrp;
      }
      fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v97);
LABEL_91:
      *__error() = v60;
LABEL_92:

      return 0x800000;
    }
    goto LABEL_41;
  }
  if (a5 && v33 <= 1)
  {
    if (![[[objc_msgSend(objc_msgSend(objc_msgSend(v54, "targetProcess"), "threads"), "objectForKeyedSubscript:", +[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:", a5)]];
  }
    }
  else if ((v55 & 0x80000000) == 0 && !a5 && v33 <= 1 && ![v54 targetProcess])
  {
    goto LABEL_25;
  }
  uint64_t v393 = v55;
  unsigned int v392 = a16 - 9;
  BOOL v71 = (byte_1000EBD0C & 0x10) == 0 && a16 - 9 < 2;
  sub_10005EB20(v54, (byte_1000EBD0C >> 3) & 1, (byte_1000EBD0C >> 2) & 1, v71);
  long long v399 = 0u;
  long long v400 = 0u;
  long long v397 = 0u;
  long long v398 = 0u;
  id v72 = [a31 countByEnumeratingWithState:&v397 objects:v401 count:16];
  if (v72)
  {
    id v73 = v72;
    uint64_t v74 = *(void *)v398;
    do
    {
      for (i = 0; i != v73; i = (char *)i + 1)
      {
        if (*(void *)v398 != v74) {
          objc_enumerationMutation(a31);
        }
        [v54 useDsymForUUIDFor:*(void *)(*((void *)&v397 + 1) + 8 * i)];
      }
      id v73 = [a31 countByEnumeratingWithState:&v397 objects:v401 count:16];
    }
    while (v73);
  }
  id v76 = [objc_alloc((Class)SASamplePrinter) initWithSampleStore:v54];
  int v77 = v76;
  if (a24) {
    [v76 setOptions:];
  }
  if (a11 != 0.0)
  {
    id v78 = [v54 endTime];
    if (v78)
    {
      CFStringRef v79 = v78;
      [v78 machContTimeSeconds];
      if (v80 != 0.0)
      {
        [v79 machContTimeSeconds];
        if (v81 > a11)
        {
          [v79 machContTimeSeconds];
          double v83 = v82 - a11;
          double v84 = 0.0;
LABEL_96:
          double v88 = 0.0;
LABEL_97:
          CFStringRef v102 = +[SATimestamp timestampWithMachAbsTime:0 machAbsTimeSec:0 machContTime:v84 machContTimeSec:v83 wallTime:v88];
          if (v102)
          {
            id v103 = [v54 indexOfFirstSampleOnOrAfterTimestamp:v102];
            if (v103 == (id)0x7FFFFFFFFFFFFFFFLL)
            {
              id v104 = [v54 endTime];
              if (!v104)
              {
                id v104 = [v54 startTime];
                if (!v104) {
                  goto LABEL_104;
                }
              }
            }
            else
            {
              id v104 = [objc_msgSend(v54, "sampleTimestamps") objectAtIndexedSubscript:v103];
            }
            [(SATimestamp *)v102 guessMissingTimesBasedOnTimestamp:v104];
          }
LABEL_104:
          [v77 filterToTimestampRangeStart:v102 end:0];
          goto LABEL_105;
        }
      }
      [v79 wallTime];
      if (v86 != 0.0)
      {
        [v79 wallTime];
        double v88 = v87 - a11;
        double v84 = 0.0;
        double v83 = 0.0;
        goto LABEL_97;
      }
      [v79 machAbsTimeSeconds];
      if (v99 != 0.0)
      {
        [v79 machAbsTimeSeconds];
        if (v100 > a11)
        {
          [v79 machAbsTimeSeconds];
          double v84 = v101 - a11;
          double v83 = 0.0;
          goto LABEL_96;
        }
      }
      if (byte_1000EBCF8)
      {
        int v144 = *__error();
        int v145 = sub_10002E548();
        if (os_log_type_enabled(v145, OS_LOG_TYPE_ERROR)) {
          sub_10008CD40(v79);
        }
        *__error() = v144;
      }
      if (!byte_1000EBCF9 || dword_1000EB4A8 > 3)
      {
LABEL_290:

        goto LABEL_92;
      }
      int v91 = *__error();
      CFStringRef v146 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"-last provided, but unable to calculate %.0f seconds earlier than %@", *(void *)&a11, [v79 debugDescription]);
      if (v146)
      {
        CFStringRef v93 = v146;
        id v94 = CFStringGetCStringPtr(v146, 0x8000100u);
        if (v94) {
          goto LABEL_197;
        }
        malloc_type_id_t v95 = 434494585;
        goto LABEL_282;
      }
      int v177 = sub_10002E548();
      if (os_log_type_enabled(v177, OS_LOG_TYPE_FAULT)) {
        sub_10008CCB4(v79);
      }
    }
    else
    {
      if (byte_1000EBCF8)
      {
        int v89 = *__error();
        uint64_t v90 = sub_10002E548();
        if (os_log_type_enabled(v90, OS_LOG_TYPE_ERROR)) {
          sub_10008BA98(v54, v90);
        }
        *__error() = v89;
      }
      if (!byte_1000EBCF9 || dword_1000EB4A8 > 3) {
        goto LABEL_290;
      }
      int v91 = *__error();
      CFStringRef v92 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"-last provided, but unable to get data end time (%lu samples)", [v54 numSamples]);
      if (v92)
      {
        CFStringRef v93 = v92;
        id v94 = CFStringGetCStringPtr(v92, 0x8000100u);
        if (v94)
        {
LABEL_197:
          uint64_t v147 = (char *)v94;
          int v148 = 0;
LABEL_283:
          if (qword_1000EBD00) {
            v188 = (FILE *)qword_1000EBD00;
          }
          else {
            v188 = __stderrp;
          }
          fprintf(v188, "%s\n", v147);
          if (v148) {
            free(v148);
          }
          CFRelease(v93);
          goto LABEL_289;
        }
        malloc_type_id_t v95 = 3859832266;
LABEL_282:
        uint64_t v147 = (char *)malloc_type_calloc(0x400uLL, 1uLL, v95);
        CFStringGetCString(v93, v147, 1024, 0x8000100u);
        int v148 = v147;
        goto LABEL_283;
      }
      v161 = sub_10002E548();
      if (os_log_type_enabled(v161, OS_LOG_TYPE_FAULT)) {
        sub_10008BA10(v54, v161);
      }
    }
    if (qword_1000EBD00) {
      __int16 v178 = (FILE *)qword_1000EBD00;
    }
    else {
      __int16 v178 = __stderrp;
    }
    fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v178);
LABEL_289:
    *__error() = v91;
    goto LABEL_290;
  }
LABEL_105:
  if (v52) {
    [v54 addAuxiliaryData:v52];
  }
  CFStringRef v105 = &AnalyticsIsEventUsed_ptr;
  [v54 setEvent:[NSString stringWithUTF8String:sub_1000249A0(a16, 0)]];
  unsigned int v106 = a16 - 5;
  if (a16 != 5)
  {
    if (a16 == 6)
    {
      [v54 setBytesWritten:a18];
      [v54 setBytesWrittenLimit:a19];
      [v54 setWriteDuration:a13];
      [v54 setWriteLimitDuration:a15];
      [objc_msgSend(v77, "options") setPrintSpinSignatureStack:1];
    }
    else if ((a16 | 2) != 0xA)
    {
      goto LABEL_113;
    }
    [v54 setStepsNote:+[NSString stringWithFormat:](NSString, @"%s/step", objc_msgSend((id)SAFormattedBytes(), "UTF8String"))];
    goto LABEL_113;
  }
  [v54 setCpuUsed:a12];
  [v54 setCpuLimit:a14];
  [v54 setCpuDuration:a13];
  [v54 setCpuLimitDuration:a15];
  [objc_msgSend(v77, "options") setPrintSpinSignatureStack:1];
LABEL_113:
  if (a9 > 0.0 && a10 > 0.0)
  {
    uint64_t v56 = a16;
    objc_msgSend(v54, "setEventTimeRange:", +[SATimeRange timeRangeStart:end:](SATimeRange, "timeRangeStart:end:", +[SATimestamp timestampWithMachAbsTime:machAbsTimeSec:machContTime:machContTimeSec:wallTime:](SATimestamp, "timestampWithMachAbsTime:machAbsTimeSec:machContTime:machContTimeSec:wallTime:", 0, 0, 0.0, 0.0, a9), +[SATimestamp timestampWithMachAbsTime:machAbsTimeSec:machContTime:machContTimeSec:wallTime:](SATimestamp, "timestampWithMachAbsTime:machAbsTimeSec:machContTime:machContTimeSec:wallTime:", 0, 0, 0.0,
          0.0,
          a10)));
  }
  if (a7)
  {
    CFStringRef v107 = +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:");
  }
  else
  {
    if (v394 > 1) {
      goto LABEL_121;
    }
    CFStringRef v107 = @"none";
  }
  [v54 setActionTaken:v107];
LABEL_121:
  if (a25) {
    [v54 setSignature:+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", a25)];
  }
  if (v392 >= 2) {
    [v54 setSanitizePaths:1];
  }
  if (v394 > 1)
  {
    uint64_t v108 = 0;
  }
  else
  {
    [v77 setIncidentUUID:[+[NSUUID UUID](NSUUID, "UUID")]];
    uint64_t v108 = 5;
  }
  [v77 setShareWithAppDevs:AppAnalyticsEnabled()];
  [objc_msgSend(v77, "options") setMicrostackshotsFormat:1];
  [objc_msgSend(v77, "options") setOmitTasksBelowPercentOfTotalSamples:v108];
  if (v56 != 5)
  {
    if (v56 != 6)
    {
      if ((v393 & 0x80000000) != 0)
      {
        if (byte_1000EBCF8)
        {
          int v154 = *__error();
          uint64_t v155 = sub_10002E548();
          if (os_log_type_enabled(v155, OS_LOG_TYPE_DEBUG)) {
            sub_10008CC3C(v56, v155);
          }
          *__error() = v154;
        }
        if (!byte_1000EBCF9 || dword_1000EB4A8 > 0) {
          goto LABEL_313;
        }
        int v129 = *__error();
        CFStringRef v131 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"Not providing unsupported report type (%d) to MetricKit", v56);
        if (!v131)
        {
          __int16 v180 = sub_10002E548();
          if (os_log_type_enabled(v180, OS_LOG_TYPE_FAULT)) {
            sub_10008CBD0(v56, v180, v181, v182, v183, v184, v185, v186);
          }
          goto LABEL_307;
        }
      }
      else
      {
        if (byte_1000EBCF8)
        {
          int v127 = *__error();
          char v128 = sub_10002E548();
          if (os_log_type_enabled(v128, OS_LOG_TYPE_DEBUG)) {
            sub_10008CB40();
          }
          *__error() = v127;
        }
        if (!byte_1000EBCF9 || dword_1000EB4A8 > 0) {
          goto LABEL_313;
        }
        int v129 = *__error();
        v130 = sub_10002E4E8(v393);
        CFStringRef v131 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%s [%d]: Not providing unsupported report type (%d) to MetricKit", v130, v393, v56);
        if (!v131)
        {
          uint64_t v132 = sub_10002E548();
          if (os_log_type_enabled(v132, OS_LOG_TYPE_FAULT)) {
            sub_10008CAC0();
          }
          goto LABEL_307;
        }
      }
      CFStringRef v156 = v131;
      uint64_t v157 = CFStringGetCStringPtr(v131, 0x8000100u);
      if (!v157)
      {
        malloc_type_id_t v158 = 1502923171;
LABEL_298:
        v173 = (char *)malloc_type_calloc(0x400uLL, 1uLL, v158);
        CFStringGetCString(v156, v173, 1024, 0x8000100u);
        v174 = v173;
        goto LABEL_299;
      }
LABEL_254:
      v173 = (char *)v157;
      v174 = 0;
LABEL_299:
      if (qword_1000EBD00) {
        v191 = (FILE *)qword_1000EBD00;
      }
      else {
        v191 = __stderrp;
      }
      fprintf(v191, "%s\n", v173);
      if (v174) {
        free(v174);
      }
      CFRelease(v156);
      uint64_t v56 = a16;
      unsigned int v106 = a16 - 5;
      goto LABEL_311;
    }
    if (!objc_opt_class())
    {
      if ((v393 & 0x80000000) != 0)
      {
        CFStringRef v105 = &AnalyticsIsEventUsed_ptr;
        if (byte_1000EBCF8)
        {
          int v171 = *__error();
          v172 = sub_10002E548();
          if (os_log_type_enabled(v172, OS_LOG_TYPE_ERROR)) {
            sub_10008C9E0();
          }
          *__error() = v171;
        }
        if (!byte_1000EBCF9 || dword_1000EB4A8 > 3) {
          goto LABEL_313;
        }
        int v129 = *__error();
        CFStringRef v152 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"MetricKit unavailable, not providing disk writes report");
        if (!v152)
        {
          v192 = sub_10002E548();
          if (os_log_type_enabled(v192, OS_LOG_TYPE_FAULT)) {
            sub_10008C9AC();
          }
          goto LABEL_307;
        }
      }
      else
      {
        CFStringRef v105 = &AnalyticsIsEventUsed_ptr;
        if (byte_1000EBCF8)
        {
          int v149 = *__error();
          __int16 v150 = sub_10002E548();
          if (os_log_type_enabled(v150, OS_LOG_TYPE_ERROR)) {
            sub_10008C934();
          }
          *__error() = v149;
        }
        if (!byte_1000EBCF9 || dword_1000EB4A8 > 3) {
          goto LABEL_313;
        }
        int v129 = *__error();
        uint64_t v151 = sub_10002E4E8(v393);
        CFStringRef v152 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%s [%d]: MetricKit unavailable, not providing disk writes report", v151, v393);
        if (!v152)
        {
          uint64_t v153 = sub_10002E548();
          if (os_log_type_enabled(v153, OS_LOG_TYPE_FAULT)) {
            sub_10008C8BC();
          }
          goto LABEL_307;
        }
      }
      CFStringRef v156 = v152;
      uint64_t v157 = CFStringGetCStringPtr(v152, 0x8000100u);
      if (!v157)
      {
        malloc_type_id_t v158 = 1407155682;
        goto LABEL_298;
      }
      goto LABEL_254;
    }
    if ((v393 & 0x80000000) != 0)
    {
      if (byte_1000EBCF8)
      {
        int v162 = *__error();
        CFStringRef v163 = sub_10002E548();
        if (os_log_type_enabled(v163, OS_LOG_TYPE_INFO))
        {
          *(_WORD *)buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v163, OS_LOG_TYPE_INFO, "Providing disk writes report to MetricKit", buf, 2u);
        }
        *__error() = v162;
      }
      if (!byte_1000EBCF9 || dword_1000EB4A8 > 1) {
        goto LABEL_275;
      }
      id v121 = v47;
      int v122 = *__error();
      CFStringRef v124 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"Providing disk writes report to MetricKit");
      if (!v124)
      {
        v189 = sub_10002E548();
        if (os_log_type_enabled(v189, OS_LOG_TYPE_FAULT)) {
          sub_10008CA8C();
        }
        if (qword_1000EBD00) {
          v190 = (FILE *)qword_1000EBD00;
        }
        else {
          v190 = __stderrp;
        }
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v190);
        goto LABEL_274;
      }
    }
    else
    {
      if (byte_1000EBCF8)
      {
        int v118 = *__error();
        CFStringRef v119 = sub_10002E548();
        if (os_log_type_enabled(v119, OS_LOG_TYPE_INFO))
        {
          int v120 = sub_10002E4E8(v393);
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = v120;
          __int16 v403 = 1024;
          int v404 = v393;
          uint64_t v56 = a16;
          _os_log_impl((void *)&_mh_execute_header, v119, OS_LOG_TYPE_INFO, "%{public}s [%d]: Providing disk writes report to MetricKit", buf, 0x12u);
        }
        *__error() = v118;
      }
      if (!byte_1000EBCF9 || dword_1000EB4A8 > 1) {
        goto LABEL_275;
      }
      id v121 = v47;
      int v122 = *__error();
      v123 = sub_10002E4E8(v393);
      CFStringRef v124 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%s [%d]: Providing disk writes report to MetricKit", v123, v393);
      if (!v124)
      {
        v125 = sub_10002E548();
        if (os_log_type_enabled(v125, OS_LOG_TYPE_FAULT)) {
          sub_10008CA14();
        }
        if (qword_1000EBD00) {
          uint64_t v126 = (FILE *)qword_1000EBD00;
        }
        else {
          uint64_t v126 = __stderrp;
        }
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v126);
        uint64_t v56 = a16;
LABEL_274:
        *__error() = v122;
        id v47 = v121;
LABEL_275:
        v169 = v77;
        uint64_t v170 = 1;
        goto LABEL_276;
      }
    }
    CFStringRef v164 = v124;
    v165 = CFStringGetCStringPtr(v124, 0x8000100u);
    if (v165)
    {
      v166 = (char *)v165;
      v167 = 0;
    }
    else
    {
      v166 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xF02548F1uLL);
      CFStringGetCString(v164, v166, 1024, 0x8000100u);
      v167 = v166;
    }
    if (qword_1000EBD00) {
      int v179 = (FILE *)qword_1000EBD00;
    }
    else {
      int v179 = __stderrp;
    }
    fprintf(v179, "%s\n", v166);
    if (v167) {
      free(v167);
    }
    CFRelease(v164);
    uint64_t v56 = a16;
    unsigned int v106 = a16 - 5;
    goto LABEL_274;
  }
  if (objc_opt_class())
  {
    if ((v393 & 0x80000000) != 0)
    {
      if (byte_1000EBCF8)
      {
        int v138 = *__error();
        uint64_t v139 = sub_10002E548();
        if (os_log_type_enabled(v139, OS_LOG_TYPE_INFO))
        {
          *(_WORD *)buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v139, OS_LOG_TYPE_INFO, "Providing cpu usage report to MetricKit", buf, 2u);
        }
        *__error() = v138;
      }
      if (!byte_1000EBCF9 || dword_1000EB4A8 > 1) {
        goto LABEL_245;
      }
      id v112 = v47;
      int v113 = *__error();
      CFStringRef v115 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"Providing cpu usage report to MetricKit");
      if (!v115)
      {
        int v175 = sub_10002E548();
        if (os_log_type_enabled(v175, OS_LOG_TYPE_FAULT)) {
          sub_10008C888();
        }
        if (qword_1000EBD00) {
          __int16 v176 = (FILE *)qword_1000EBD00;
        }
        else {
          __int16 v176 = __stderrp;
        }
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v176);
        goto LABEL_244;
      }
    }
    else
    {
      if (byte_1000EBCF8)
      {
        int v109 = *__error();
        int v110 = sub_10002E548();
        if (os_log_type_enabled(v110, OS_LOG_TYPE_INFO))
        {
          CFStringRef v111 = sub_10002E4E8(v393);
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = v111;
          __int16 v403 = 1024;
          int v404 = v393;
          uint64_t v56 = a16;
          _os_log_impl((void *)&_mh_execute_header, v110, OS_LOG_TYPE_INFO, "%{public}s [%d]: Providing cpu usage report to MetricKit", buf, 0x12u);
        }
        *__error() = v109;
      }
      if (!byte_1000EBCF9 || dword_1000EB4A8 > 1) {
        goto LABEL_245;
      }
      id v112 = v47;
      int v113 = *__error();
      unsigned int v114 = sub_10002E4E8(v393);
      CFStringRef v115 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%s [%d]: Providing cpu usage report to MetricKit", v114, v393);
      if (!v115)
      {
        CFStringRef v116 = sub_10002E548();
        if (os_log_type_enabled(v116, OS_LOG_TYPE_FAULT)) {
          sub_10008C810();
        }
        if (qword_1000EBD00) {
          int v117 = (FILE *)qword_1000EBD00;
        }
        else {
          int v117 = __stderrp;
        }
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v117);
        uint64_t v56 = a16;
LABEL_244:
        *__error() = v113;
        id v47 = v112;
LABEL_245:
        v169 = v77;
        uint64_t v170 = 0;
LABEL_276:
        +[MXSampleAnalysisParser sendDiagnosticReport:v169 forType:v170 forSourceID:4];
LABEL_312:
        CFStringRef v105 = &AnalyticsIsEventUsed_ptr;
        goto LABEL_313;
      }
    }
    CFStringRef v140 = v115;
    id v141 = CFStringGetCStringPtr(v115, 0x8000100u);
    if (v141)
    {
      uint64_t v142 = (char *)v141;
      uint64_t v143 = 0;
    }
    else
    {
      uint64_t v142 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x60328999uLL);
      CFStringGetCString(v140, v142, 1024, 0x8000100u);
      uint64_t v143 = v142;
    }
    if (qword_1000EBD00) {
      CFStringRef v168 = (FILE *)qword_1000EBD00;
    }
    else {
      CFStringRef v168 = __stderrp;
    }
    fprintf(v168, "%s\n", v142);
    if (v143) {
      free(v143);
    }
    CFRelease(v140);
    uint64_t v56 = a16;
    unsigned int v106 = a16 - 5;
    goto LABEL_244;
  }
  if ((v393 & 0x80000000) != 0)
  {
    CFStringRef v105 = &AnalyticsIsEventUsed_ptr;
    if (byte_1000EBCF8)
    {
      int v159 = *__error();
      v160 = sub_10002E548();
      if (os_log_type_enabled(v160, OS_LOG_TYPE_ERROR)) {
        sub_10008C7DC();
      }
      *__error() = v159;
    }
    if (byte_1000EBCF9 && dword_1000EB4A8 <= 3)
    {
      int v129 = *__error();
      CFStringRef v136 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"MetricKit unavailable, not providing cpu usage report");
      if (!v136)
      {
        v187 = sub_10002E548();
        if (os_log_type_enabled(v187, OS_LOG_TYPE_FAULT)) {
          sub_10008C7A8();
        }
        goto LABEL_307;
      }
LABEL_224:
      CFStringRef v156 = v136;
      uint64_t v157 = CFStringGetCStringPtr(v136, 0x8000100u);
      if (!v157)
      {
        malloc_type_id_t v158 = 3490226989;
        goto LABEL_298;
      }
      goto LABEL_254;
    }
  }
  else
  {
    CFStringRef v105 = &AnalyticsIsEventUsed_ptr;
    if (byte_1000EBCF8)
    {
      int v133 = *__error();
      int v134 = sub_10002E548();
      if (os_log_type_enabled(v134, OS_LOG_TYPE_ERROR)) {
        sub_10008C730();
      }
      *__error() = v133;
    }
    if (byte_1000EBCF9 && dword_1000EB4A8 <= 3)
    {
      int v129 = *__error();
      CFStringRef v135 = sub_10002E4E8(v393);
      CFStringRef v136 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%s [%d]: MetricKit unavailable, not providing cpu usage report", v135, v393);
      if (!v136)
      {
        uint64_t v137 = sub_10002E548();
        if (os_log_type_enabled(v137, OS_LOG_TYPE_FAULT)) {
          sub_10008C6B8();
        }
LABEL_307:
        if (qword_1000EBD00) {
          v193 = (FILE *)qword_1000EBD00;
        }
        else {
          v193 = __stderrp;
        }
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v193);
LABEL_311:
        *__error() = v129;
        goto LABEL_312;
      }
      goto LABEL_224;
    }
  }
LABEL_313:
  if (a26)
  {
    *(void *)buf = 0;
    id v194 = [objc_alloc((Class)NSData) initWithContentsOfFile:[v105[311] stringWithUTF8String:a26] options:1 error:buf];
    if (v194)
    {
      if (byte_1000EBCF8)
      {
        int v195 = *__error();
        v196 = sub_10002E548();
        if (os_log_type_enabled(v196, OS_LOG_TYPE_DEBUG)) {
          sub_10008C644();
        }
        *__error() = v195;
      }
      if (byte_1000EBCF9 && dword_1000EB4A8 <= 0)
      {
        id v197 = v47;
        int v198 = *__error();
        CFStringRef v199 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"Appending data file %s", a26);
        if (v199)
        {
          CFStringRef v200 = v199;
          v201 = CFStringGetCStringPtr(v199, 0x8000100u);
          if (!v201)
          {
            malloc_type_id_t v202 = 2124346485;
LABEL_365:
            v214 = (char *)malloc_type_calloc(0x400uLL, 1uLL, v202);
            CFStringGetCString(v200, v214, 1024, 0x8000100u);
            v215 = v214;
            goto LABEL_366;
          }
          goto LABEL_341;
        }
        v216 = sub_10002E548();
        if (os_log_type_enabled(v216, OS_LOG_TYPE_FAULT)) {
          sub_10008C5DC();
        }
        goto LABEL_360;
      }
    }
    else
    {
      if (byte_1000EBCF8)
      {
        int v211 = *__error();
        v212 = sub_10002E548();
        if (os_log_type_enabled(v212, OS_LOG_TYPE_ERROR)) {
          sub_10008C554(a26, (id *)buf);
        }
        *__error() = v211;
      }
      if (byte_1000EBCF9 && dword_1000EB4A8 <= 3)
      {
        id v197 = v47;
        int v198 = *__error();
        CFStringRef v213 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"reading in data file %s failed: %@", a26, [*(id *)buf localizedDescription]);
        if (v213)
        {
          CFStringRef v200 = v213;
          v201 = CFStringGetCStringPtr(v213, 0x8000100u);
          if (!v201)
          {
            malloc_type_id_t v202 = 3841089587;
            goto LABEL_365;
          }
LABEL_341:
          v214 = (char *)v201;
          v215 = 0;
LABEL_366:
          if (qword_1000EBD00) {
            v222 = (FILE *)qword_1000EBD00;
          }
          else {
            v222 = __stderrp;
          }
          fprintf(v222, "%s\n", v214);
          if (v215) {
            free(v215);
          }
          CFRelease(v200);
          uint64_t v56 = a16;
          unsigned int v106 = a16 - 5;
          goto LABEL_372;
        }
        v220 = sub_10002E548();
        if (os_log_type_enabled(v220, OS_LOG_TYPE_FAULT)) {
          sub_10008C4CC(a26, (id *)buf);
        }
LABEL_360:
        if (qword_1000EBD00) {
          v221 = (FILE *)qword_1000EBD00;
        }
        else {
          v221 = __stderrp;
        }
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v221);
LABEL_372:
        *__error() = v198;
        id v47 = v197;
      }
    }
  }
  else
  {
    if (byte_1000EBCF8)
    {
      int v203 = *__error();
      v204 = sub_10002E548();
      if (os_log_type_enabled(v204, OS_LOG_TYPE_DEBUG)) {
        sub_10008C48C();
      }
      *__error() = v203;
    }
    id v194 = 0;
    if (byte_1000EBCF9 && dword_1000EB4A8 <= 0)
    {
      int v205 = *__error();
      CFStringRef v206 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"No file to append");
      if (v206)
      {
        CFStringRef v207 = v206;
        v208 = CFStringGetCStringPtr(v206, 0x8000100u);
        if (v208)
        {
          v209 = (char *)v208;
          v210 = 0;
        }
        else
        {
          v209 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x9AFC83C5uLL);
          CFStringGetCString(v207, v209, 1024, 0x8000100u);
          v210 = v209;
        }
        if (qword_1000EBD00) {
          v219 = (FILE *)qword_1000EBD00;
        }
        else {
          v219 = __stderrp;
        }
        fprintf(v219, "%s\n", v209);
        if (v210) {
          free(v210);
        }
        CFRelease(v207);
        uint64_t v56 = a16;
        unsigned int v106 = a16 - 5;
      }
      else
      {
        v217 = sub_10002E548();
        if (os_log_type_enabled(v217, OS_LOG_TYPE_FAULT)) {
          sub_10008C458();
        }
        if (qword_1000EBD00) {
          v218 = (FILE *)qword_1000EBD00;
        }
        else {
          v218 = __stderrp;
        }
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v218);
      }
      id v194 = 0;
      *__error() = v205;
    }
  }
  if (v106 <= 3)
  {
    if (v106 > 1)
    {
      uint64_t v224 = 0;
      long double v223 = 0.0;
    }
    else
    {
      [objc_msgSend(v54, "startTime") wallTime];
      uint64_t v224 = a20 & 1;
    }
    int v225 = sub_10004BC40(v77, v223, a13, 0, (uint64_t)v194, v56, 0, v224, a17, 0, 0, 0);
    goto LABEL_501;
  }
  if (a23)
  {
    [v77 printToStream:__stdoutp];
    int v225 = 1;
    goto LABEL_501;
  }
  if (v392 >= 2)
  {
    if ((v393 & 0x80000000) != 0)
    {
      if (byte_1000EBCF8)
      {
        int v349 = *__error();
        v350 = sub_10002E548();
        if (os_log_type_enabled(v350, OS_LOG_TYPE_ERROR)) {
          sub_10008C3E0();
        }
        *__error() = v349;
      }
      if (byte_1000EBCF9 && dword_1000EB4A8 <= 3)
      {
        int v351 = *__error();
        CFStringRef v352 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%s: Bad report type %d", "report_type == DID_MANUAL_MICROSTACKSHOTS_IO || report_type == DID_MANUAL_MICROSTACKSHOTS", a16);
        if (v352)
        {
          CFStringRef v359 = v352;
          v360 = CFStringGetCStringPtr(v352, 0x8000100u);
          if (v360)
          {
            v361 = (char *)v360;
            v362 = 0;
          }
          else
          {
            v361 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x95521467uLL);
            CFStringGetCString(v359, v361, 1024, 0x8000100u);
            v362 = v361;
          }
          if (qword_1000EBD00) {
            v371 = (FILE *)qword_1000EBD00;
          }
          else {
            v371 = __stderrp;
          }
          fprintf(v371, "%s\n", v361);
          if (v362) {
            free(v362);
          }
          CFRelease(v359);
        }
        else
        {
          v353 = sub_10002E548();
          if (os_log_type_enabled(v353, OS_LOG_TYPE_FAULT)) {
            sub_10008C368();
          }
          if (qword_1000EBD00) {
            v354 = (FILE *)qword_1000EBD00;
          }
          else {
            v354 = __stderrp;
          }
          fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v354);
        }
        *__error() = v351;
      }
      v388 = "report_type == DID_MANUAL_MICROSTACKSHOTS_IO || report_type == DID_MANUAL_MICROSTACKSHOTS";
      v339 = "%s: Bad report type %d";
    }
    else
    {
      if (byte_1000EBCF8)
      {
        int v342 = *__error();
        v343 = sub_10002E548();
        if (os_log_type_enabled(v343, OS_LOG_TYPE_ERROR)) {
          sub_10008C2DC();
        }
        *__error() = v342;
      }
      if (byte_1000EBCF9 && dword_1000EB4A8 <= 3)
      {
        int v344 = *__error();
        v345 = sub_10002E4E8(v393);
        CFStringRef v346 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%s [%d]: %s: Bad report type %d", v345, v393, "report_type == DID_MANUAL_MICROSTACKSHOTS_IO || report_type == DID_MANUAL_MICROSTACKSHOTS", a16);
        if (v346)
        {
          CFStringRef v355 = v346;
          v356 = CFStringGetCStringPtr(v346, 0x8000100u);
          if (v356)
          {
            v357 = (char *)v356;
            v358 = 0;
          }
          else
          {
            v357 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x95521467uLL);
            CFStringGetCString(v355, v357, 1024, 0x8000100u);
            v358 = v357;
          }
          if (qword_1000EBD00) {
            v370 = (FILE *)qword_1000EBD00;
          }
          else {
            v370 = __stderrp;
          }
          fprintf(v370, "%s\n", v357);
          if (v358) {
            free(v358);
          }
          CFRelease(v355);
        }
        else
        {
          v347 = sub_10002E548();
          if (os_log_type_enabled(v347, OS_LOG_TYPE_FAULT)) {
            sub_10008C250();
          }
          if (qword_1000EBD00) {
            v348 = (FILE *)qword_1000EBD00;
          }
          else {
            v348 = __stderrp;
          }
          fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v348);
        }
        *__error() = v344;
      }
      LOBYTE(v388) = sub_10002E4E8(v393);
      v339 = "%s [%d]: %s: Bad report type %d";
    }
    int v341 = 397;
    goto LABEL_554;
  }
  if (v56 == 9) {
    v226 = "Powerstats";
  }
  else {
    v226 = "IOStats";
  }
  id v396 = 0;
  uint64_t v227 = v393;
  if (a8) {
    v228 = +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:");
  }
  else {
    v228 = 0;
  }
  v229 = +[NSString stringWithUTF8String:v226];
  uid_t v230 = geteuid();
  int v231 = sub_10004D99C(v228, v229, 0xFFFFFFFFLL, 1537, v230, 0x1A4u, &v396);
  if (v231 != -1)
  {
    int v232 = v231;
    v233 = fdopen(v231, "w");
    int v225 = v233 != 0;
    if (v233)
    {
      v234 = v233;
      [v77 printToStream:v233];
      fclose(v234);
      if (byte_1000EBCF8)
      {
        int v235 = *__error();
        v236 = sub_10002E548();
        if (os_log_type_enabled(v236, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 138412290;
          *(void *)&uint8_t buf[4] = v396;
          _os_log_impl((void *)&_mh_execute_header, v236, OS_LOG_TYPE_DEFAULT, "Spindump analysis written to file %@", buf, 0xCu);
        }
        *__error() = v235;
      }
      if (!byte_1000EBCF9 || dword_1000EB4A8 > 2) {
        goto LABEL_500;
      }
      int v237 = *__error();
      CFStringRef v238 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"Spindump analysis written to file %@", v396);
      if (v238)
      {
        CFStringRef v239 = v238;
        v240 = CFStringGetCStringPtr(v238, 0x8000100u);
        if (!v240)
        {
          malloc_type_id_t v241 = 3008392109;
LABEL_486:
          v309 = (char *)malloc_type_calloc(0x400uLL, 1uLL, v241);
          CFStringGetCString(v239, v309, 1024, 0x8000100u);
          v310 = v309;
          goto LABEL_487;
        }
        goto LABEL_484;
      }
      v280 = sub_10002E548();
      if (os_log_type_enabled(v280, OS_LOG_TYPE_FAULT)) {
        sub_10008BD60((uint64_t)&v396, v280, v281, v282, v283, v284, v285, v286);
      }
      goto LABEL_495;
    }
    if ((v393 & 0x80000000) != 0)
    {
      if (byte_1000EBCF8)
      {
        int v270 = *__error();
        v271 = sub_10002E548();
        if (os_log_type_enabled(v271, OS_LOG_TYPE_ERROR)) {
          sub_10008C1C4();
        }
        *__error() = v270;
      }
      if (byte_1000EBCF9 && dword_1000EB4A8 <= 3)
      {
        int v395 = *__error();
        id v272 = v396;
        uint64_t v273 = *__error();
        v274 = __error();
        v275 = strerror(*v274);
        CFStringRef v258 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"could not fdopen log file %@: %d (%s)", v272, v273, v275);
        if (!v258)
        {
          v292 = sub_10002E548();
          if (os_log_type_enabled(v292, OS_LOG_TYPE_FAULT)) {
            sub_10008C138();
          }
          goto LABEL_461;
        }
LABEL_434:
        CFStringRef v276 = v258;
        v277 = CFStringGetCStringPtr(v258, 0x8000100u);
        if (v277)
        {
          v278 = (char *)v277;
          v279 = 0;
        }
        else
        {
          v278 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x23CB35F5uLL);
          CFStringGetCString(v276, v278, 1024, 0x8000100u);
          v279 = v278;
        }
        int v288 = v395;
        if (qword_1000EBD00) {
          v289 = (FILE *)qword_1000EBD00;
        }
        else {
          v289 = __stderrp;
        }
        fprintf(v289, "%s\n", v278);
        if (v279) {
          free(v279);
        }
        CFRelease(v276);
        uint64_t v227 = v393;
        goto LABEL_465;
      }
    }
    else
    {
      if (byte_1000EBCF8)
      {
        int v251 = *__error();
        v252 = sub_10002E548();
        if (os_log_type_enabled(v252, OS_LOG_TYPE_ERROR)) {
          sub_10008C0A4(v393, &v396, v252);
        }
        *__error() = v251;
      }
      if (byte_1000EBCF9 && dword_1000EB4A8 <= 3)
      {
        int v395 = *__error();
        v253 = sub_10002E4E8(v393);
        id v254 = v396;
        uint64_t v255 = *__error();
        v256 = __error();
        v257 = strerror(*v256);
        uint64_t v389 = v255;
        uint64_t v227 = v393;
        CFStringRef v258 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%s [%d]: could not fdopen log file %@: %d (%s)", v253, v393, v254, v389, v257);
        if (!v258)
        {
          v259 = sub_10002E548();
          if (os_log_type_enabled(v259, OS_LOG_TYPE_FAULT)) {
            sub_10008C010(v393, &v396, v259);
          }
LABEL_461:
          if (qword_1000EBD00) {
            v293 = (FILE *)qword_1000EBD00;
          }
          else {
            v293 = __stderrp;
          }
          fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v293);
          int v288 = v395;
LABEL_465:
          *__error() = v288;
          goto LABEL_466;
        }
        goto LABEL_434;
      }
    }
LABEL_466:

    close(v232);
    if ((v227 & 0x80000000) != 0)
    {
      if (byte_1000EBCF8)
      {
        int v303 = *__error();
        v304 = sub_10002E548();
        if (os_log_type_enabled(v304, OS_LOG_TYPE_ERROR)) {
          sub_10008BF84();
        }
        *__error() = v303;
      }
      if (!byte_1000EBCF9 || dword_1000EB4A8 > 3) {
        goto LABEL_500;
      }
      int v237 = *__error();
      id v305 = v396;
      uint64_t v306 = *__error();
      v307 = __error();
      v308 = strerror(*v307);
      CFStringRef v301 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"could not write to file %@: %d (%s)", v305, v306, v308);
      if (!v301)
      {
        v312 = sub_10002E548();
        if (os_log_type_enabled(v312, OS_LOG_TYPE_FAULT)) {
          sub_10008BEF8();
        }
        goto LABEL_495;
      }
    }
    else
    {
      if (byte_1000EBCF8)
      {
        int v294 = *__error();
        v295 = sub_10002E548();
        if (os_log_type_enabled(v295, OS_LOG_TYPE_ERROR)) {
          sub_10008BE64(v227, &v396, v295);
        }
        *__error() = v294;
      }
      if (!byte_1000EBCF9 || dword_1000EB4A8 > 3) {
        goto LABEL_500;
      }
      int v237 = *__error();
      v296 = sub_10002E4E8(v227);
      id v297 = v396;
      uint64_t v298 = *__error();
      v299 = __error();
      v300 = strerror(*v299);
      CFStringRef v301 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%s [%d]: could not write to file %@: %d (%s)", v296, v393, v297, v298, v300);
      if (!v301)
      {
        v302 = sub_10002E548();
        if (os_log_type_enabled(v302, OS_LOG_TYPE_FAULT)) {
          sub_10008BDD0(v393, &v396, v302);
        }
LABEL_495:
        if (qword_1000EBD00) {
          v313 = (FILE *)qword_1000EBD00;
        }
        else {
          v313 = __stderrp;
        }
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v313);
        goto LABEL_499;
      }
    }
    CFStringRef v239 = v301;
    v240 = CFStringGetCStringPtr(v301, 0x8000100u);
    if (!v240)
    {
      malloc_type_id_t v241 = 1573601823;
      goto LABEL_486;
    }
LABEL_484:
    v309 = (char *)v240;
    v310 = 0;
LABEL_487:
    if (qword_1000EBD00) {
      v311 = (FILE *)qword_1000EBD00;
    }
    else {
      v311 = __stderrp;
    }
    fprintf(v311, "%s\n", v309);
    if (v310) {
      free(v310);
    }
    CFRelease(v239);
    goto LABEL_499;
  }
  if ((v393 & 0x80000000) != 0)
  {
    if (byte_1000EBCF8)
    {
      int v260 = *__error();
      v261 = sub_10002E548();
      if (os_log_type_enabled(v261, OS_LOG_TYPE_ERROR)) {
        sub_10008BCD4();
      }
      *__error() = v260;
    }
    int v225 = 0;
    if (!byte_1000EBCF9 || dword_1000EB4A8 > 3) {
      goto LABEL_500;
    }
    int v237 = *__error();
    id v262 = v396;
    uint64_t v263 = *__error();
    v264 = __error();
    v265 = strerror(*v264);
    CFStringRef v249 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"could not open log file %@: %d (%s)", v262, v263, v265);
    if (!v249)
    {
      v290 = sub_10002E548();
      if (os_log_type_enabled(v290, OS_LOG_TYPE_FAULT)) {
        sub_10008BC48();
      }
      goto LABEL_454;
    }
LABEL_425:
    CFStringRef v266 = v249;
    v267 = CFStringGetCStringPtr(v249, 0x8000100u);
    if (v267)
    {
      v268 = (char *)v267;
      v269 = 0;
    }
    else
    {
      v268 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xDD127B48uLL);
      CFStringGetCString(v266, v268, 1024, 0x8000100u);
      v269 = v268;
    }
    if (qword_1000EBD00) {
      v287 = (FILE *)qword_1000EBD00;
    }
    else {
      v287 = __stderrp;
    }
    fprintf(v287, "%s\n", v268);
    if (v269) {
      free(v269);
    }
    CFRelease(v266);
    goto LABEL_458;
  }
  if (byte_1000EBCF8)
  {
    int v242 = *__error();
    v243 = sub_10002E548();
    if (os_log_type_enabled(v243, OS_LOG_TYPE_ERROR)) {
      sub_10008BBB4(v393, &v396, v243);
    }
    *__error() = v242;
  }
  int v225 = 0;
  if (!byte_1000EBCF9 || dword_1000EB4A8 > 3) {
    goto LABEL_500;
  }
  int v237 = *__error();
  v244 = sub_10002E4E8(v393);
  id v245 = v396;
  uint64_t v246 = *__error();
  v247 = __error();
  v248 = strerror(*v247);
  CFStringRef v249 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%s [%d]: could not open log file %@: %d (%s)", v244, v393, v245, v246, v248);
  if (v249) {
    goto LABEL_425;
  }
  v250 = sub_10002E548();
  if (os_log_type_enabled(v250, OS_LOG_TYPE_FAULT)) {
    sub_10008BB20(v393, &v396, v250);
  }
LABEL_454:
  if (qword_1000EBD00) {
    v291 = (FILE *)qword_1000EBD00;
  }
  else {
    v291 = __stderrp;
  }
  fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v291);
LABEL_458:
  int v225 = 0;
LABEL_499:
  *__error() = v237;
LABEL_500:

LABEL_501:
  +[SABinary clearCoreSymbolicationCaches];

  if (v225) {
    return 0;
  }
  else {
    return 0x1000000;
  }
}

id sub_10002905C(char *a1, off_t a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, double a9, double a10, uint64_t a11, uint64_t a12, unsigned int a13, unsigned int a14, uint64_t a15)
{
  uint64_t v15 = a8;
  int v16 = a6;
  int v17 = a5;
  int value = a3;
  if ((a6 & 1) == 0 && (a7 & 1) == 0)
  {
    if (byte_1000EBCF8)
    {
      int v151 = *__error();
      CFStringRef v152 = sub_10002E548();
      if (os_log_type_enabled(v152, OS_LOG_TYPE_ERROR)) {
        sub_10008B720(v152, v153, v154, v155, v156, v157, v158, v159);
      }
      *__error() = v151;
    }
    if (byte_1000EBCF9) {
      BOOL v160 = dword_1000EB4A8 <= 3;
    }
    else {
      BOOL v160 = 0;
    }
    if (v160)
    {
      int v171 = *__error();
      CFStringRef v172 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%s: Nothing to do", "report || save");
      CFStringRef v173 = v172;
      if (v172)
      {
        CStringPtr = (char *)CFStringGetCStringPtr(v172, 0x8000100u);
        if (CStringPtr)
        {
          v196 = 0;
        }
        else
        {
          CStringPtr = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x4D2EE15AuLL);
          CFStringGetCString(v173, CStringPtr, 1024, 0x8000100u);
          v196 = CStringPtr;
        }
        if (qword_1000EBD00) {
          int v211 = (FILE *)qword_1000EBD00;
        }
        else {
          int v211 = __stderrp;
        }
        fprintf(v211, "%s\n", CStringPtr);
        if (v196) {
          free(v196);
        }
        CFRelease(v173);
      }
      else
      {
        v174 = sub_10002E548();
        if (os_log_type_enabled(v174, OS_LOG_TYPE_FAULT)) {
          sub_10008B6A8(v174, v175, v176, v177, v178, v179, v180, v181);
        }
        if (qword_1000EBD00) {
          uint64_t v182 = (FILE *)qword_1000EBD00;
        }
        else {
          uint64_t v182 = __stderrp;
        }
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v182);
      }
      *__error() = v171;
    }
    sub_10002E41C("_HandleMicrostackshots", "microstackshot.m", 450, "%s: Nothing to do", a5, a6, a7, a8, (char)"report || save");
    abort();
  }
  int v22 = a7 ^ 1;
  if (!a1 && (v22 & 1) == 0)
  {
    if (byte_1000EBCF8)
    {
      int v161 = *__error();
      int v162 = sub_10002E548();
      if (os_log_type_enabled(v162, OS_LOG_TYPE_ERROR)) {
        sub_10008B630(v162, v163, v164, v165, v166, v167, v168, v169);
      }
      *__error() = v161;
    }
    if (byte_1000EBCF9) {
      BOOL v170 = dword_1000EB4A8 <= 3;
    }
    else {
      BOOL v170 = 0;
    }
    if (v170)
    {
      int v183 = *__error();
      CFStringRef v184 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%s: No datastore path provided for saving", "!save || datastorePath");
      CFStringRef v185 = v184;
      if (v184)
      {
        id v197 = (char *)CFStringGetCStringPtr(v184, 0x8000100u);
        if (v197)
        {
          int v198 = 0;
        }
        else
        {
          id v197 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x730FC77uLL);
          CFStringGetCString(v185, v197, 1024, 0x8000100u);
          int v198 = v197;
        }
        if (qword_1000EBD00) {
          v212 = (FILE *)qword_1000EBD00;
        }
        else {
          v212 = __stderrp;
        }
        fprintf(v212, "%s\n", v197);
        if (v198) {
          free(v198);
        }
        CFRelease(v185);
      }
      else
      {
        uint64_t v186 = sub_10002E548();
        if (os_log_type_enabled(v186, OS_LOG_TYPE_FAULT)) {
          sub_10008B5B8(v186, v187, v188, v189, v190, v191, v192, v193);
        }
        if (qword_1000EBD00) {
          id v194 = (FILE *)qword_1000EBD00;
        }
        else {
          id v194 = __stderrp;
        }
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v194);
      }
      *__error() = v183;
    }
    sub_10002E41C("_HandleMicrostackshots", "microstackshot.m", 451, "%s: No datastore path provided for saving", a5, a6, a7, a8, (char)"!save || datastorePath");
    abort();
  }
  if (a1) {
    int v23 = a6;
  }
  else {
    int v23 = 0;
  }
  if ((v23 & v22) != 1)
  {
    if (!&_systemstats_copy_microstackshots_to_file) {
      return 0;
    }
    if (a1 && a7)
    {
      uid_t v31 = geteuid();
      int v222 = sub_10002B934(a1, 1537, v31, 0x1A4u);
      if (v222 == -1)
      {
        int v221 = v15;
        if (byte_1000EBCF8)
        {
          int v32 = *__error();
          unsigned int v33 = sub_10002E548();
          if (os_log_type_enabled(v33, OS_LOG_TYPE_ERROR)) {
            sub_10008B438();
          }
          *__error() = v32;
        }
        if (byte_1000EBCF9 && dword_1000EB4A8 <= 3)
        {
          int v216 = *__error();
          uint64_t v34 = *__error();
          __int16 v35 = __error();
          v36 = strerror(*v35);
          CFStringRef v37 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"Unable to open datastore file %s: %d (%s)", a1, v34, v36);
          CFStringRef theString = v37;
          if (v37)
          {
            int v38 = (char *)CFStringGetCStringPtr(v37, 0x8000100u);
            if (v38)
            {
              unsigned int v39 = 0;
            }
            else
            {
              int v38 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xD0D3A15AuLL);
              CFStringGetCString(theString, v38, 1024, 0x8000100u);
              unsigned int v39 = v38;
            }
            if (qword_1000EBD00) {
              CFStringRef v102 = (FILE *)qword_1000EBD00;
            }
            else {
              CFStringRef v102 = __stderrp;
            }
            fprintf(v102, "%s\n", v38);
            if (v39) {
              free(v39);
            }
            CFRelease(theString);
          }
          else
          {
            int v97 = sub_10002E548();
            if (os_log_type_enabled(v97, OS_LOG_TYPE_FAULT)) {
              sub_10008B3A4();
            }
            if (qword_1000EBD00) {
              CFStringRef v98 = (FILE *)qword_1000EBD00;
            }
            else {
              CFStringRef v98 = __stderrp;
            }
            fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v98);
          }
          *__error() = v216;
          LODWORD(v15) = v221;
        }
        if (!v16) {
          return 0;
        }
      }
      int v51 = v15;
      if (a2 && lseek(v222, a2, 0) == -1)
      {
        if (byte_1000EBCF8)
        {
          int theStringa = *__error();
          id v103 = sub_10002E548();
          if (os_log_type_enabled(v103, OS_LOG_TYPE_ERROR)) {
            sub_10008B310();
          }
          *__error() = theStringa;
        }
        if (byte_1000EBCF9 && dword_1000EB4A8 <= 3)
        {
          int v217 = *__error();
          uint64_t v104 = *__error();
          CFStringRef v105 = __error();
          unsigned int v106 = strerror(*v105);
          CFStringRef v107 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"Unable to seek %s to offset %lld: %d (%s)", a1, a2, v104, v106);
          CFStringRef theStringb = v107;
          if (v107)
          {
            uint64_t v108 = (char *)CFStringGetCStringPtr(v107, 0x8000100u);
            if (v108)
            {
              int v109 = 0;
            }
            else
            {
              uint64_t v108 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xC6A5190EuLL);
              CFStringGetCString(theStringb, v108, 1024, 0x8000100u);
              int v109 = v108;
            }
            if (qword_1000EBD00) {
              int v113 = (FILE *)qword_1000EBD00;
            }
            else {
              int v113 = __stderrp;
            }
            fprintf(v113, "%s\n", v108);
            if (v109) {
              free(v109);
            }
            CFRelease(theStringb);
          }
          else
          {
            int v110 = sub_10002E548();
            if (os_log_type_enabled(v110, OS_LOG_TYPE_FAULT)) {
              sub_10008B27C();
            }
            if (qword_1000EBD00) {
              CFStringRef v111 = (FILE *)qword_1000EBD00;
            }
            else {
              CFStringRef v111 = __stderrp;
            }
            fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v111);
          }
          *__error() = v217;
        }
        if ((v16 & 1) == 0)
        {
          close(v222);
          return 0;
        }
      }
      xpc_object_t empty = xpc_dictionary_create_empty();
      CFStringRef v115 = empty;
      if (a9 > 0.0) {
        xpc_dictionary_set_uint64(empty, "time", (unint64_t)(kCFAbsoluteTimeIntervalSince1970 + a9));
      }
      systemstats_copy_microstackshots_to_file();
      close(v222);
      xpc_release(v115);
      if ((v16 & 1) == 0) {
        return 0;
      }
    }
    else
    {
      int v51 = a8;
      if ((a6 & 1) == 0)
      {
        if (byte_1000EBCF8)
        {
          int v52 = *__error();
          id v53 = sub_10002E548();
          if (os_log_type_enabled(v53, OS_LOG_TYPE_ERROR)) {
            sub_10008B540(v53, v54, v55, v56, v57, v58, v59, v60);
          }
          *__error() = v52;
        }
        if (byte_1000EBCF9) {
          BOOL v61 = dword_1000EB4A8 <= 3;
        }
        else {
          BOOL v61 = 0;
        }
        if (v61)
        {
          int v199 = *__error();
          CFStringRef v200 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%s: Didn't already return without report option", "report");
          CFStringRef v201 = v200;
          if (v200)
          {
            CFStringRef v213 = (char *)CFStringGetCStringPtr(v200, 0x8000100u);
            if (v213)
            {
              v214 = 0;
            }
            else
            {
              CFStringRef v213 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xA3F8821CuLL);
              CFStringGetCString(v201, v213, 1024, 0x8000100u);
              v214 = v213;
            }
            if (qword_1000EBD00) {
              v215 = (FILE *)qword_1000EBD00;
            }
            else {
              v215 = __stderrp;
            }
            fprintf(v215, "%s\n", v213);
            if (v214) {
              free(v214);
            }
            CFRelease(v201);
          }
          else
          {
            malloc_type_id_t v202 = sub_10002E548();
            if (os_log_type_enabled(v202, OS_LOG_TYPE_FAULT)) {
              sub_10008B4C8(v202, v203, v204, v205, v206, v207, v208, v209);
            }
            if (qword_1000EBD00) {
              v210 = (FILE *)qword_1000EBD00;
            }
            else {
              v210 = __stderrp;
            }
            fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v210);
          }
          *__error() = v199;
        }
        sub_10002E41C("_HandleMicrostackshots", "microstackshot.m", 555, "%s: Didn't already return without report option", a5, a6, a7, a8, (char)"report");
        abort();
      }
    }
    id v116 = objc_alloc((Class)SASampleStore);
    if (v17)
    {
      id v30 = [v116 initForLiveSampling];
      [v30 setShouldGatherKextStat:0];
      if (!a11)
      {
LABEL_199:
        if (a12 && *(_DWORD *)a12 && *(_DWORD *)(a12 + 4)) {
          [v30 setMachTimebase:*(void *)a12];
        }
        if (a13) {
          [v30 setHwPageSize:a13];
        }
        if (a14) {
          [v30 setVmPageSize:a14];
        }
        if ((byte_1000EBD0C & 2) != 0 && sub_10002411C())
        {
          if (byte_1000EBCF8)
          {
            int v117 = *__error();
            int v118 = sub_10002E548();
            if (os_log_type_enabled(v118, OS_LOG_TYPE_DEFAULT))
            {
              *(_WORD *)buf = 0;
              _os_log_impl((void *)&_mh_execute_header, v118, OS_LOG_TYPE_DEFAULT, "Avoiding inspecting live processes for microstackshot report due to audio running", buf, 2u);
            }
            *__error() = v117;
          }
          if (byte_1000EBCF9 && dword_1000EB4A8 <= 2)
          {
            int v119 = *__error();
            CFStringRef v120 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"Avoiding inspecting live processes for microstackshot report due to audio running");
            CFStringRef v121 = v120;
            if (v120)
            {
              int v122 = (char *)CFStringGetCStringPtr(v120, 0x8000100u);
              if (v122)
              {
                v123 = 0;
              }
              else
              {
                int v122 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x998CF6E7uLL);
                CFStringGetCString(v121, v122, 1024, 0x8000100u);
                v123 = v122;
              }
              if (qword_1000EBD00) {
                uint64_t v126 = (FILE *)qword_1000EBD00;
              }
              else {
                uint64_t v126 = __stderrp;
              }
              fprintf(v126, "%s\n", v122);
              if (v123) {
                free(v123);
              }
              CFRelease(v121);
            }
            else
            {
              CFStringRef v124 = sub_10002E548();
              if (os_log_type_enabled(v124, OS_LOG_TYPE_FAULT)) {
                sub_10008B0A4();
              }
              if (qword_1000EBD00) {
                v125 = (FILE *)qword_1000EBD00;
              }
              else {
                v125 = __stderrp;
              }
              fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v125);
            }
            *__error() = v119;
          }
          [v30 setDataGatheringOptions:((unint64_t)[v30 dataGatheringOptions] & 0xFFFFFFFFFFFFFFFDLL)];
        }
        sub_10005EB20(v30, (byte_1000EBD0C >> 3) & 1, (byte_1000EBD0C >> 2) & 1, (byte_1000EBD0C & 0x10) == 0);
        *(void *)buf = 0;
        CFStringRef v249 = buf;
        uint64_t v250 = 0x2020000000;
        uint64_t v251 = 0;
        v246[0] = 0;
        v246[1] = v246;
        v246[2] = 0x2020000000;
        int v247 = 0;
        int v127 = dispatch_semaphore_create(0);
        dispatch_retain(v127);
        xpc_object_t v128 = xpc_dictionary_create_empty();
        int v129 = v128;
        if (a9 > 0.0) {
          xpc_dictionary_set_uint64(v128, "time", (unint64_t)(kCFAbsoluteTimeIntervalSince1970 + a9));
        }
        if (value >= 1) {
          xpc_dictionary_set_uint64(v129, "pid", value);
        }
        v130 = dispatch_queue_attr_make_with_autorelease_frequency(0, DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM);
        CFStringRef v131 = dispatch_queue_create("com.apple.spindump.microstackshot_parsing", v130);
        dispatch_release(v130);
        dispatch_retain(v131);
        uid_t v230 = _NSConcreteStackBlock;
        uint64_t v231 = 3221225472;
        int v232 = sub_10002A9CC;
        v233 = &unk_1000DD280;
        qos_class_t v243 = qos_class_self();
        int v244 = v51;
        int v245 = value;
        double v241 = a9;
        double v242 = a10;
        id v234 = v30;
        uint64_t v235 = a15;
        int v237 = v131;
        CFStringRef v238 = v246;
        CFStringRef v239 = buf;
        uint64_t v240 = a4;
        v236 = v127;
        systemstats_get_microstackshots();
        xpc_release(v129);
        uint64_t v226 = 0;
        uint64_t v227 = &v226;
        uint64_t v228 = 0x2020000000;
        char v229 = 0;
        do
        {
          dispatch_time_t v132 = dispatch_time(0, 30000000000);
          if (!dispatch_semaphore_wait(v127, v132)) {
            break;
          }
          value_4[0] = _NSConcreteStackBlock;
          value_4[1] = 3221225472;
          value_4[2] = sub_10004B624;
          value_4[3] = &unk_1000DD2A8;
          value_4[4] = v246;
          value_4[5] = &v226;
          dispatch_sync(v131, value_4);
        }
        while (!*((unsigned char *)v227 + 24));
        dispatch_release(v127);
        dispatch_release(v131);
        if (*((void *)v249 + 3))
        {
          if (byte_1000EBCF8)
          {
            int v133 = *__error();
            int v134 = sub_10002E548();
            if (os_log_type_enabled(v134, OS_LOG_TYPE_ERROR))
            {
              int v135 = *((_DWORD *)v249 + 6);
              CFStringRef v136 = strerror(v135);
              sub_10008B23C((uint64_t)v136, (uint64_t)v253, v135);
            }
            *__error() = v133;
          }
          if (byte_1000EBCF9) {
            BOOL v137 = dword_1000EB4A8 <= 3;
          }
          else {
            BOOL v137 = 0;
          }
          if (v137)
          {
            int v138 = *__error();
            uint64_t v139 = *((unsigned int *)v249 + 6);
            CFStringRef v140 = strerror(*((_DWORD *)v249 + 6));
            CFStringRef v141 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"Error grabbing microstackshots: %d (%s)", v139, v140);
            CFStringRef v142 = v141;
            if (v141)
            {
              uint64_t v143 = (char *)CFStringGetCStringPtr(v141, 0x8000100u);
              if (v143)
              {
                int v144 = 0;
              }
              else
              {
                uint64_t v143 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x186D4021uLL);
                CFStringGetCString(v142, v143, 1024, 0x8000100u);
                int v144 = v143;
              }
              if (qword_1000EBD00) {
                int v149 = (FILE *)qword_1000EBD00;
              }
              else {
                int v149 = __stderrp;
              }
              fprintf(v149, "%s\n", v143);
              if (v144) {
                free(v144);
              }
              CFRelease(v142);
            }
            else
            {
              int v145 = sub_10002E548();
              if (os_log_type_enabled(v145, OS_LOG_TYPE_FAULT))
              {
                int v146 = *((_DWORD *)v249 + 6);
                uint64_t v147 = strerror(v146);
                sub_10008B1FC((uint64_t)v147, (uint64_t)v252, v146);
              }
              if (qword_1000EBD00) {
                int v148 = (FILE *)qword_1000EBD00;
              }
              else {
                int v148 = __stderrp;
              }
              fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v148);
            }
            *__error() = v138;
          }
        }
        [v30 postprocess];
        _Block_object_dispose(&v226, 8);
        _Block_object_dispose(v246, 8);
        _Block_object_dispose(buf, 8);
        return v30;
      }
    }
    else
    {
      id v30 = [v116 initForFileParsing];
      if (!a11) {
        goto LABEL_199;
      }
    }
    [v30 setMachineArchitecture:[NSString stringWithUTF8String:a11]];
    goto LABEL_199;
  }
  int v25 = open(a1, 0);
  if (v25 != -1)
  {
    int v26 = v25;
    if (a2 && lseek(v25, a2, 0) == -1)
    {
      if (byte_1000EBCF8)
      {
        int v79 = *__error();
        double v80 = sub_10002E548();
        if (os_log_type_enabled(v80, OS_LOG_TYPE_ERROR)) {
          sub_10008B16C();
        }
        *__error() = v79;
      }
      if (byte_1000EBCF9 && dword_1000EB4A8 <= 3)
      {
        int v81 = *__error();
        uint64_t v82 = *__error();
        double v83 = __error();
        double v84 = strerror(*v83);
        CFStringRef v85 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"Unable to seek %s to offset %lld: %d (%s)", a1, a2, v82, v84);
        CFStringRef v86 = v85;
        if (v85)
        {
          double v87 = (char *)CFStringGetCStringPtr(v85, 0x8000100u);
          if (v87)
          {
            double v88 = 0;
          }
          else
          {
            double v87 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x8B1AFD4uLL);
            CFStringGetCString(v86, v87, 1024, 0x8000100u);
            double v88 = v87;
          }
          if (qword_1000EBD00) {
            double v99 = (FILE *)qword_1000EBD00;
          }
          else {
            double v99 = __stderrp;
          }
          fprintf(v99, "%s\n", v87);
          if (v88) {
            free(v88);
          }
          CFRelease(v86);
        }
        else
        {
          id v94 = sub_10002E548();
          if (os_log_type_enabled(v94, OS_LOG_TYPE_FAULT)) {
            sub_10008B0D8();
          }
          if (qword_1000EBD00) {
            malloc_type_id_t v95 = (FILE *)qword_1000EBD00;
          }
          else {
            malloc_type_id_t v95 = __stderrp;
          }
          fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v95);
        }
        *__error() = v81;
      }
    }
    else
    {
      gzFile v27 = gzdopen(v26, "r");
      if (v27)
      {
        CFStringRef v28 = v27;
        id v29 = objc_alloc((Class)SASampleStore);
        if (v17)
        {
          id v30 = [v29 initForLiveSampling];
          [v30 setShouldGatherKextStat:0];
          if (!a11)
          {
LABEL_62:
            if (a12 && *(_DWORD *)a12 && *(_DWORD *)(a12 + 4)) {
              [v30 setMachTimebase:*(void *)a12];
            }
            if (a13) {
              [v30 setHwPageSize:a13];
            }
            if (a14) {
              [v30 setVmPageSize:a14];
            }
            if ((byte_1000EBD0C & 2) != 0 && sub_10002411C())
            {
              if (byte_1000EBCF8)
              {
                int v72 = *__error();
                id v73 = sub_10002E548();
                if (os_log_type_enabled(v73, OS_LOG_TYPE_DEFAULT))
                {
                  *(_WORD *)buf = 0;
                  _os_log_impl((void *)&_mh_execute_header, v73, OS_LOG_TYPE_DEFAULT, "Avoiding inspecting live processes for microstackshot report due to audio running", buf, 2u);
                }
                *__error() = v72;
              }
              if (byte_1000EBCF9 && dword_1000EB4A8 <= 2)
              {
                int v74 = *__error();
                CFStringRef v75 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"Avoiding inspecting live processes for microstackshot report due to audio running");
                CFStringRef v76 = v75;
                if (v75)
                {
                  int v77 = (char *)CFStringGetCStringPtr(v75, 0x8000100u);
                  if (v77)
                  {
                    id v78 = 0;
                  }
                  else
                  {
                    int v77 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xC4DFE513uLL);
                    CFStringGetCString(v76, v77, 1024, 0x8000100u);
                    id v78 = v77;
                  }
                  if (qword_1000EBD00) {
                    id v112 = (FILE *)qword_1000EBD00;
                  }
                  else {
                    id v112 = __stderrp;
                  }
                  fprintf(v112, "%s\n", v77);
                  if (v78) {
                    free(v78);
                  }
                  CFRelease(v76);
                }
                else
                {
                  double v100 = sub_10002E548();
                  if (os_log_type_enabled(v100, OS_LOG_TYPE_FAULT)) {
                    sub_10008B0A4();
                  }
                  if (qword_1000EBD00) {
                    double v101 = (FILE *)qword_1000EBD00;
                  }
                  else {
                    double v101 = __stderrp;
                  }
                  fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v101);
                }
                *__error() = v74;
              }
              [v30 setDataGatheringOptions:((unint64_t)[v30 dataGatheringOptions] & 0xFFFFFFFFFFFFFFFDLL)];
            }
            sub_10005EB20(v30, (byte_1000EBD0C >> 3) & 1, (byte_1000EBD0C >> 2) & 1, (byte_1000EBD0C & 0x10) == 0);
            sub_10002AACC(v30, v28, 0, 0, v15, value, a4, a15, a9, a10);
            gzclose(v28);
            [v30 postprocess];
            return v30;
          }
        }
        else
        {
          id v30 = [v29 initForFileParsing];
          if (!a11) {
            goto LABEL_62;
          }
        }
        [v30 setMachineArchitecture:[NSString stringWithUTF8String:a11]];
        goto LABEL_62;
      }
      if (byte_1000EBCF8)
      {
        int v62 = *__error();
        CFStringRef v63 = sub_10002E548();
        if (os_log_type_enabled(v63, OS_LOG_TYPE_ERROR)) {
          sub_10008B014();
        }
        *__error() = v62;
      }
      if (byte_1000EBCF9 && dword_1000EB4A8 <= 3)
      {
        int v64 = *__error();
        uint64_t v65 = *__error();
        CFStringRef v66 = __error();
        CFStringRef v67 = strerror(*v66);
        CFStringRef v68 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"Unable to gzdopen datastore file %s: %d (%s)", a1, v65, v67);
        CFStringRef v69 = v68;
        if (v68)
        {
          v70 = (char *)CFStringGetCStringPtr(v68, 0x8000100u);
          if (v70)
          {
            BOOL v71 = 0;
          }
          else
          {
            v70 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x9BD42F74uLL);
            CFStringGetCString(v69, v70, 1024, 0x8000100u);
            BOOL v71 = v70;
          }
          if (qword_1000EBD00) {
            v96 = (FILE *)qword_1000EBD00;
          }
          else {
            v96 = __stderrp;
          }
          fprintf(v96, "%s\n", v70);
          if (v71) {
            free(v71);
          }
          CFRelease(v69);
        }
        else
        {
          CFStringRef v92 = sub_10002E548();
          if (os_log_type_enabled(v92, OS_LOG_TYPE_FAULT)) {
            sub_10008AF80();
          }
          if (qword_1000EBD00) {
            CFStringRef v93 = (FILE *)qword_1000EBD00;
          }
          else {
            CFStringRef v93 = __stderrp;
          }
          fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v93);
        }
        *__error() = v64;
      }
    }
    close(v26);
    return 0;
  }
  if (byte_1000EBCF8)
  {
    int v40 = *__error();
    CFStringRef v41 = sub_10002E548();
    if (os_log_type_enabled(v41, OS_LOG_TYPE_ERROR)) {
      sub_10008AEF0();
    }
    *__error() = v40;
  }
  if (byte_1000EBCF9) {
    BOOL v42 = dword_1000EB4A8 <= 3;
  }
  else {
    BOOL v42 = 0;
  }
  if (!v42) {
    return 0;
  }
  int v43 = *__error();
  uint64_t v44 = *__error();
  int v45 = __error();
  id v46 = strerror(*v45);
  CFStringRef v47 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"Unable to open %s: %d (%s)", a1, v44, v46);
  CFStringRef v48 = v47;
  if (v47)
  {
    uint64_t v49 = (char *)CFStringGetCStringPtr(v47, 0x8000100u);
    if (v49)
    {
      int v50 = 0;
    }
    else
    {
      uint64_t v49 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x49473BC4uLL);
      CFStringGetCString(v48, v49, 1024, 0x8000100u);
      int v50 = v49;
    }
    if (qword_1000EBD00) {
      int v91 = (FILE *)qword_1000EBD00;
    }
    else {
      int v91 = __stderrp;
    }
    fprintf(v91, "%s\n", v49);
    if (v50) {
      free(v50);
    }
    CFRelease(v48);
  }
  else
  {
    int v89 = sub_10002E548();
    if (os_log_type_enabled(v89, OS_LOG_TYPE_FAULT)) {
      sub_10008AE5C();
    }
    if (qword_1000EBD00) {
      uint64_t v90 = (FILE *)qword_1000EBD00;
    }
    else {
      uint64_t v90 = __stderrp;
    }
    fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v90);
  }
  id v30 = 0;
  *__error() = v43;
  return v30;
}

void sub_10002A964(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  _Block_object_dispose(&a26, 8);
  _Block_object_dispose((const void *)(v26 - 256), 8);
  _Block_object_dispose((const void *)(v26 - 224), 8);
  _Unwind_Resume(a1);
}

void sub_10002A9CC(uint64_t a1, int a2, uint64_t a3, int a4)
{
  if (a4 != 54)
  {
    uint64_t v19 = v4;
    uint64_t v20 = v5;
    dispatch_qos_class_t v8 = *(_DWORD *)(a1 + 104);
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472;
    block[2] = sub_10004B388;
    block[3] = &unk_1000DD258;
    block[4] = a3;
    uint64_t v16 = *(void *)(a1 + 108);
    uint64_t v14 = *(void *)(a1 + 80);
    long long v15 = *(_OWORD *)(a1 + 88);
    long long v11 = *(_OWORD *)(a1 + 32);
    char v18 = a2;
    long long v13 = *(_OWORD *)(a1 + 64);
    int v17 = a4;
    uint64_t v12 = *(void *)(a1 + 48);
    dispatch_block_t v9 = dispatch_block_create_with_qos_class((dispatch_block_flags_t)0, v8, 0, block);
    dispatch_sync(*(dispatch_queue_t *)(a1 + 56), v9);
    _Block_release(v9);
    if (a2)
    {
      dispatch_release(*(dispatch_object_t *)(a1 + 56));
      dispatch_release(*(dispatch_object_t *)(a1 + 48));
    }
  }
}

void sub_10002AACC(void *a1, gzFile_s *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, double a9, double a10)
{
  uint64_t v10 = (void *)a8;
  uint64_t v13 = a7;
  if (a3)
  {
    id v17 = [objc_alloc((Class)NSData) initWithBytesNoCopy:a3 length:a4 freeWhenDone:0];
    unint64_t v18 = (unint64_t)[a1 addMicrostackshotsFromData:v17 ofTypes:a5 inTimeRangeStart:a6 end:v13 onlyPid:v10 onlyTid:a9 statistics:a10];

    if ((v18 & 0x8000000000000000) == 0) {
      return;
    }
    if (byte_1000EBCF8)
    {
      int v19 = *__error();
      uint64_t v20 = sub_10002E548();
      if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR)) {
        sub_10008D0F8();
      }
      *__error() = v19;
    }
    if (!byte_1000EBCF9 || dword_1000EB4A8 > 3) {
      return;
    }
    int v22 = *__error();
    CFStringRef v23 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"Data does not contain microstackshots");
    if (v23)
    {
      CFStringRef v24 = v23;
      CStringPtr = CFStringGetCStringPtr(v23, 0x8000100u);
      if (!CStringPtr)
      {
        malloc_type_id_t v26 = 1380284601;
LABEL_112:
        double v87 = (char *)malloc_type_calloc(0x400uLL, 1uLL, v26);
        CFStringGetCString(v24, v87, 1024, 0x8000100u);
        double v88 = v87;
        goto LABEL_113;
      }
      goto LABEL_104;
    }
    CFStringRef v66 = sub_10002E548();
    if (os_log_type_enabled(v66, OS_LOG_TYPE_FAULT)) {
      sub_10008D0C4();
    }
    goto LABEL_107;
  }
  if (!a2)
  {
    if (byte_1000EBCF8)
    {
      int v102 = *__error();
      id v103 = sub_10002E548();
      if (os_log_type_enabled(v103, OS_LOG_TYPE_ERROR)) {
        sub_10008D04C(v103, v104, v105, v106, v107, v108, v109, v110);
      }
      *__error() = v102;
    }
    if (byte_1000EBCF9) {
      BOOL v111 = dword_1000EB4A8 <= 3;
    }
    else {
      BOOL v111 = 0;
    }
    if (v111)
    {
      int v112 = *__error();
      CFStringRef v113 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%s: No tracebuf nor gzfile", "gzfile");
      if (v113)
      {
        CFStringRef v129 = v113;
        v130 = CFStringGetCStringPtr(v113, 0x8000100u);
        if (v130)
        {
          CFStringRef v131 = (char *)v130;
          dispatch_time_t v132 = 0;
        }
        else
        {
          CFStringRef v131 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xBD5BE80DuLL);
          CFStringGetCString(v129, v131, 1024, 0x8000100u);
          dispatch_time_t v132 = v131;
        }
        if (qword_1000EBD00) {
          int v133 = (FILE *)qword_1000EBD00;
        }
        else {
          int v133 = __stderrp;
        }
        fprintf(v133, "%s\n", v131);
        if (v132) {
          free(v132);
        }
        CFRelease(v129);
      }
      else
      {
        unsigned int v114 = sub_10002E548();
        if (os_log_type_enabled(v114, OS_LOG_TYPE_FAULT)) {
          sub_10008CFD4(v114, v115, v116, v117, v118, v119, v120, v121);
        }
        if (qword_1000EBD00) {
          int v122 = (FILE *)qword_1000EBD00;
        }
        else {
          int v122 = __stderrp;
        }
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v122);
      }
      *__error() = v112;
    }
    sub_10002E41C("_ParseMicrostackshot", "microstackshot.m", 699, "%s: No tracebuf nor gzfile", a5, a6, a7, a8, (char)"gzfile");
LABEL_183:
    abort();
  }
  unsigned int v134 = a5;
  CFStringRef v28 = (char *)malloc_type_calloc(1uLL, 0x20000uLL, 0xDB5703AFuLL);
  unint64_t v29 = 0x20000;
  id v30 = v28;
  size_t v31 = 0;
  char v32 = 0;
  while (1)
  {
    unint64_t v33 = v29;
    int v34 = gzread(a2, &v30[v31], v29 - v31);
    char v135 = v32;
    if (v34 <= 0) {
      break;
    }
    size_t v35 = v31 + v34;
    id v36 = [objc_alloc((Class)NSData) initWithBytesNoCopy:v30 length:v35 freeWhenDone:0];
    uint64_t v37 = v13;
    uint64_t v38 = v13;
    unsigned int v39 = v10;
    unint64_t v40 = (unint64_t)[a1 addMicrostackshotsFromData:v36 ofTypes:v134 inTimeRangeStart:a6 end:v38 onlyPid:v10 onlyTid:a9 statistics:a10];

    if ((v40 & 0x8000000000000000) != 0) {
      goto LABEL_92;
    }
    size_t v31 = v35 - v40;
    if (!v31) {
      goto LABEL_22;
    }
    if (v40)
    {
      memmove(v30, &v30[v40], v31);
LABEL_22:
      unint64_t v29 = v33;
      goto LABEL_25;
    }
    size_t v45 = 2 * v33;
    id v46 = (char *)reallocf(v30, v45);
    if (!v46)
    {
      if (byte_1000EBCF8)
      {
        int v92 = *__error();
        CFStringRef v93 = sub_10002E548();
        if (os_log_type_enabled(v93, OS_LOG_TYPE_ERROR)) {
          sub_10008D4BC();
        }
        *__error() = v92;
      }
      if (byte_1000EBCF9 && dword_1000EB4A8 <= 3)
      {
        int v94 = *__error();
        CFStringRef v95 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%s: realloc to %lu failed", "buf", v45);
        if (v95)
        {
          CFStringRef v124 = v95;
          v125 = CFStringGetCStringPtr(v95, 0x8000100u);
          if (v125)
          {
            uint64_t v126 = (char *)v125;
            int v127 = 0;
          }
          else
          {
            uint64_t v126 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x25C99642uLL);
            CFStringGetCString(v124, v126, 1024, 0x8000100u);
            int v127 = v126;
          }
          if (qword_1000EBD00) {
            xpc_object_t v128 = (FILE *)qword_1000EBD00;
          }
          else {
            xpc_object_t v128 = __stderrp;
          }
          fprintf(v128, "%s\n", v126);
          if (v127) {
            free(v127);
          }
          CFRelease(v124);
        }
        else
        {
          v96 = sub_10002E548();
          if (os_log_type_enabled(v96, OS_LOG_TYPE_FAULT)) {
            sub_10008D43C();
          }
          if (qword_1000EBD00) {
            int v97 = (FILE *)qword_1000EBD00;
          }
          else {
            int v97 = __stderrp;
          }
          fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v97);
        }
        *__error() = v94;
      }
      sub_10002E41C("_ParseMicrostackshot", "microstackshot.m", 750, "%s: realloc to %lu failed", v41, v42, v43, v44, (char)"buf");
      goto LABEL_183;
    }
    id v30 = v46;
    unint64_t v29 = v45;
LABEL_25:
    char v32 = 1;
    uint64_t v10 = v39;
    uint64_t v13 = v37;
    if (v31 >= v29)
    {
      if (byte_1000EBCF8)
      {
        unint64_t v47 = v29;
        int v48 = *__error();
        uint64_t v49 = sub_10002E548();
        if (os_log_type_enabled(v49, OS_LOG_TYPE_ERROR)) {
          sub_10008D3B8();
        }
        *__error() = v48;
        unint64_t v29 = v47;
      }
      if (byte_1000EBCF9 && dword_1000EB4A8 <= 3)
      {
        unint64_t v50 = v29;
        int v51 = *__error();
        CFStringRef v52 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%s: buf %lu, cap %lu", "bufLength < bufCapacity", v31, v50);
        if (v52)
        {
          CFStringRef v98 = v52;
          double v99 = CFStringGetCStringPtr(v52, 0x8000100u);
          if (v99)
          {
            double v100 = (char *)v99;
            double v101 = 0;
          }
          else
          {
            double v100 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x49E8A663uLL);
            CFStringGetCString(v98, v100, 1024, 0x8000100u);
            double v101 = v100;
          }
          if (qword_1000EBD00) {
            v123 = (FILE *)qword_1000EBD00;
          }
          else {
            v123 = __stderrp;
          }
          fprintf(v123, "%s\n", v100);
          if (v101) {
            free(v101);
          }
          CFRelease(v98);
        }
        else
        {
          id v53 = sub_10002E548();
          if (os_log_type_enabled(v53, OS_LOG_TYPE_FAULT)) {
            sub_10008D334();
          }
          if (qword_1000EBD00) {
            uint64_t v54 = (FILE *)qword_1000EBD00;
          }
          else {
            uint64_t v54 = __stderrp;
          }
          fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v54);
        }
        *__error() = v51;
      }
      sub_10002E41C("_ParseMicrostackshot", "microstackshot.m", 753, "%s: buf %lu, cap %lu", v41, v42, v43, v44, (char)"bufLength < bufCapacity");
      goto LABEL_183;
    }
  }
  if (v34 != -1)
  {
    [v10 setBytes_not_microstackshots:(char *)[v10 bytes_not_microstackshots] + v31];
    goto LABEL_92;
  }
  int errnum = 0;
  uint64_t v55 = gzerror(a2, &errnum);
  if (errnum != -1)
  {
    uint64_t v56 = (uint64_t)v55;
    if (byte_1000EBCF8)
    {
      int v57 = *__error();
      uint64_t v58 = sub_10002E548();
      if (os_log_type_enabled(v58, OS_LOG_TYPE_ERROR)) {
        sub_10008D2B0(&errnum, v56, v58);
      }
      *__error() = v57;
    }
    if (byte_1000EBCF9) {
      BOOL v59 = dword_1000EB4A8 <= 3;
    }
    else {
      BOOL v59 = 0;
    }
    if (!v59) {
      goto LABEL_92;
    }
    int v60 = *__error();
    CFStringRef v61 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"Read failed for microstackshots: %d (%s)", errnum, v56);
    if (v61)
    {
      CFStringRef v62 = v61;
      CFStringRef v63 = CFStringGetCStringPtr(v61, 0x8000100u);
      if (v63)
      {
        int v64 = (char *)v63;
        uint64_t v65 = 0;
      }
      else
      {
        int v64 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xCD438DFBuLL);
        CFStringGetCString(v62, v64, 1024, 0x8000100u);
        uint64_t v65 = v64;
      }
      if (qword_1000EBD00) {
        id v78 = (FILE *)qword_1000EBD00;
      }
      else {
        id v78 = __stderrp;
      }
      fprintf(v78, "%s\n", v64);
      if (v65) {
        free(v65);
      }
      CFStringRef v79 = v62;
      goto LABEL_90;
    }
    int v77 = sub_10002E548();
    if (os_log_type_enabled(v77, OS_LOG_TYPE_FAULT)) {
      sub_10008D22C(&errnum, v56, v77);
    }
LABEL_79:
    if (qword_1000EBD00) {
      int v81 = (FILE *)qword_1000EBD00;
    }
    else {
      int v81 = __stderrp;
    }
    fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v81);
    goto LABEL_91;
  }
  int errnum = *__error();
  if (byte_1000EBCF8)
  {
    int v67 = *__error();
    CFStringRef v68 = sub_10002E548();
    if (os_log_type_enabled(v68, OS_LOG_TYPE_ERROR)) {
      sub_10008D1AC(&errnum);
    }
    *__error() = v67;
  }
  if (byte_1000EBCF9) {
    BOOL v69 = dword_1000EB4A8 <= 3;
  }
  else {
    BOOL v69 = 0;
  }
  if (v69)
  {
    int v60 = *__error();
    uint64_t v70 = errnum;
    BOOL v71 = strerror(errnum);
    CFStringRef v72 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"Read failed for microstackshots: %d (%s)", v70, v71);
    if (!v72)
    {
      double v80 = sub_10002E548();
      if (os_log_type_enabled(v80, OS_LOG_TYPE_FAULT)) {
        sub_10008D12C(&errnum);
      }
      goto LABEL_79;
    }
    CFStringRef v73 = v72;
    int v74 = CFStringGetCStringPtr(v72, 0x8000100u);
    if (v74)
    {
      CFStringRef v75 = (char *)v74;
      CFStringRef v76 = 0;
    }
    else
    {
      CFStringRef v75 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x547E2851uLL);
      CFStringGetCString(v73, v75, 1024, 0x8000100u);
      CFStringRef v76 = v75;
    }
    if (qword_1000EBD00) {
      uint64_t v82 = (FILE *)qword_1000EBD00;
    }
    else {
      uint64_t v82 = __stderrp;
    }
    fprintf(v82, "%s\n", v75);
    if (v76) {
      free(v76);
    }
    CFStringRef v79 = v73;
LABEL_90:
    CFRelease(v79);
LABEL_91:
    *__error() = v60;
  }
LABEL_92:
  if ((v135 & 1) == 0)
  {
    if (byte_1000EBCF8)
    {
      int v83 = *__error();
      double v84 = sub_10002E548();
      if (os_log_type_enabled(v84, OS_LOG_TYPE_ERROR)) {
        sub_10008D0F8();
      }
      *__error() = v83;
    }
    if (byte_1000EBCF9 && dword_1000EB4A8 <= 3)
    {
      int v22 = *__error();
      CFStringRef v86 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"Data does not contain microstackshots");
      if (v86)
      {
        CFStringRef v24 = v86;
        CStringPtr = CFStringGetCStringPtr(v86, 0x8000100u);
        if (!CStringPtr)
        {
          malloc_type_id_t v26 = 2824655356;
          goto LABEL_112;
        }
LABEL_104:
        double v87 = (char *)CStringPtr;
        double v88 = 0;
LABEL_113:
        if (qword_1000EBD00) {
          int v91 = (FILE *)qword_1000EBD00;
        }
        else {
          int v91 = __stderrp;
        }
        fprintf(v91, "%s\n", v87);
        if (v88) {
          free(v88);
        }
        CFRelease(v24);
LABEL_119:
        *__error() = v22;
        return;
      }
      int v89 = sub_10002E548();
      if (os_log_type_enabled(v89, OS_LOG_TYPE_FAULT)) {
        sub_10008D0C4();
      }
LABEL_107:
      if (qword_1000EBD00) {
        uint64_t v90 = (FILE *)qword_1000EBD00;
      }
      else {
        uint64_t v90 = __stderrp;
      }
      fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v90);
      goto LABEL_119;
    }
  }
}

uint64_t sub_10002B778(char *a1, int a2, long double a3, long double a4)
{
  uint64_t v8 = a2;
  int v9 = snprintf(a1, a2, "Start time:      ");
  uint64_t v10 = &a1[v9];
  long long v11 = &a1[a2];
  if (v9 < a2) {
    v10 += sub_100024838(&a1[v9], v8 - v9, 0, a3);
  }
  if (v10 < v11) {
    v10 += snprintf(v10, &a1[v8] - v10, "\nEnd time:        ");
  }
  if (v10 < v11) {
    v10 += sub_100024838(v10, &a1[v8] - v10, 0, a4);
  }
  if (v10 < v11) {
    LODWORD(v10) = v10 + snprintf(v10, &a1[v8] - v10, "\n");
  }
  return (v10 - a1);
}

BOOL sub_10002B86C(const char *a1)
{
  memset(&v2, 0, sizeof(v2));
  return lstat(a1, &v2) == 0;
}

BOOL sub_10002B8B0()
{
  byte_1000EBD0C = byte_1000EBD0C & 0xFC | 1;
  if (sub_10002B86C("/var/db/.spindump_enable_symbolication")) {
    char v0 = 8;
  }
  else {
    char v0 = 16;
  }
  byte_1000EBD0C = v0 | byte_1000EBD0C & 0xE3;
  BOOL result = sub_10002B86C("/var/db/.spindump_disable_exclaves");
  if (result) {
    char v2 = 32;
  }
  else {
    char v2 = 0;
  }
  byte_1000EBD0C = byte_1000EBD0C & 0xDF | v2;
  return result;
}

uint64_t sub_10002B934(const char *a1, int a2, int a3, unsigned int a4)
{
  __int16 v6 = a2;
  memset(&v16, 0, sizeof(v16));
  memset(&v15.st_atimespec, 0, 112);
  if ((a2 & 0x200) != 0) {
    int v8 = -3585;
  }
  else {
    int v8 = -1025;
  }
  int v9 = v8 & a2;
  memset(&v15, 0, 32);
  if (lstat(a1, &v15) < 0)
  {
    uint64_t v12 = __error();
    uint64_t v10 = 0xFFFFFFFFLL;
    if ((v6 & 0x200) != 0 && *v12 == 2)
    {
      int v13 = open(a1, v9 | 0xA00, a4);
      if (v13 < 0) {
        return 0xFFFFFFFFLL;
      }
      else {
        return v13;
      }
    }
  }
  else
  {
    uint64_t v10 = 0xFFFFFFFFLL;
    if ((v15.st_mode & 0xF000) == 0x8000 && v15.st_nlink == 1 && v15.st_uid == a3 && (v15.st_mode & 0xFFF) == a4)
    {
      uint64_t v11 = open(a1, v9, 0);
      if ((v11 & 0x80000000) == 0)
      {
        uint64_t v10 = v11;
        if (!fstat(v11, &v16)
          && v16.st_nlink == v15.st_nlink
          && v16.st_uid == v15.st_uid
          && v16.st_mode == v15.st_mode
          && v16.st_ino == v15.st_ino
          && v16.st_dev == v15.st_dev)
        {
          if ((v6 & 0x400) != 0) {
            ftruncate(v10, 0);
          }
        }
        else
        {
          close(v10);
          return 0xFFFFFFFFLL;
        }
      }
    }
  }
  return v10;
}

void sub_10002BAD4(const char *a1)
{
  __endptr = 0;
  uint64_t v2 = strtol(a1, &__endptr, 0);
  if (__endptr != a1 && !*__endptr)
  {
    uint64_t v10 = v2;
    if (byte_1000EBCF8)
    {
      int v11 = *__error();
      uint64_t v12 = sub_10002E548();
      if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG)) {
        sub_100090E08();
      }
      *__error() = v11;
    }
    if (byte_1000EBCF9) {
      BOOL v13 = dword_1000EB4A8 <= 0;
    }
    else {
      BOOL v13 = 0;
    }
    if (v13)
    {
      int v14 = *__error();
      CFStringRef v15 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"Found unix timestamp %ld", v10);
      if (v15)
      {
        CFStringRef v16 = v15;
        CStringPtr = CFStringGetCStringPtr(v15, 0x8000100u);
        if (CStringPtr)
        {
          unint64_t v18 = (char *)CStringPtr;
          int v19 = 0;
        }
        else
        {
          unint64_t v18 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xA0A622E3uLL);
          CFStringGetCString(v16, v18, 1024, 0x8000100u);
          int v19 = v18;
        }
        if (qword_1000EBD00) {
          int v83 = (FILE *)qword_1000EBD00;
        }
        else {
          int v83 = __stderrp;
        }
        fprintf(v83, "%s\n", v18);
        if (v19) {
          free(v19);
        }
        CFRelease(v16);
      }
      else
      {
        uint64_t v56 = sub_10002E548();
        if (os_log_type_enabled(v56, OS_LOG_TYPE_FAULT)) {
          sub_100090DA0();
        }
        if (qword_1000EBD00) {
          int v57 = (FILE *)qword_1000EBD00;
        }
        else {
          int v57 = __stderrp;
        }
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v57);
      }
      *__error() = v14;
    }
    return;
  }
  memset(&v119, 0, sizeof(v119));
  v119.tm_isdst = -1;
  BOOL v3 = strptime(a1, "%Y-%m-%d %T %z", &v119);
  __endptr = v3;
  if (v3 && !*v3)
  {
    time_t v20 = mktime(&v119);
    if (byte_1000EBCF8)
    {
      int v21 = *__error();
      int v22 = sub_10002E548();
      if (os_log_type_enabled(v22, OS_LOG_TYPE_DEBUG)) {
        sub_100090D38();
      }
      *__error() = v21;
    }
    if (byte_1000EBCF9) {
      BOOL v23 = dword_1000EB4A8 <= 0;
    }
    else {
      BOOL v23 = 0;
    }
    if (!v23) {
      return;
    }
    int v24 = *__error();
    CFStringRef v25 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"Found ISO timestamp with time zone number %ld", v20);
    if (v25)
    {
      CFStringRef v26 = v25;
      gzFile v27 = CFStringGetCStringPtr(v25, 0x8000100u);
      if (!v27)
      {
        malloc_type_id_t v28 = 1503249402;
        goto LABEL_192;
      }
      goto LABEL_69;
    }
    BOOL v71 = sub_10002E548();
    if (!os_log_type_enabled(v71, OS_LOG_TYPE_FAULT)) {
      goto LABEL_159;
    }
LABEL_113:
    sub_100090CD0();
    goto LABEL_159;
  }
  uint64_t v4 = strptime(a1, "%Y-%m-%dT%T %z", &v119);
  if (v4 && !*v4)
  {
    time_t v29 = mktime(&v119);
    if (byte_1000EBCF8)
    {
      int v30 = *__error();
      size_t v31 = sub_10002E548();
      if (os_log_type_enabled(v31, OS_LOG_TYPE_DEBUG)) {
        sub_100090D38();
      }
      *__error() = v30;
    }
    if (byte_1000EBCF9) {
      BOOL v32 = dword_1000EB4A8 <= 0;
    }
    else {
      BOOL v32 = 0;
    }
    if (!v32) {
      return;
    }
    int v24 = *__error();
    CFStringRef v33 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"Found ISO timestamp with time zone number %ld", v29);
    if (v33)
    {
      CFStringRef v26 = v33;
      gzFile v27 = CFStringGetCStringPtr(v33, 0x8000100u);
      if (!v27)
      {
        malloc_type_id_t v28 = 40582745;
        goto LABEL_192;
      }
      goto LABEL_69;
    }
    double v84 = sub_10002E548();
    if (!os_log_type_enabled(v84, OS_LOG_TYPE_FAULT)) {
      goto LABEL_159;
    }
    goto LABEL_113;
  }
  uint64_t v5 = strptime(a1, "%Y-%m-%d %T %Z", &v119);
  __endptr = v5;
  if (v5 && !*v5)
  {
    time_t v34 = mktime(&v119);
    if (byte_1000EBCF8)
    {
      int v35 = *__error();
      id v36 = sub_10002E548();
      if (os_log_type_enabled(v36, OS_LOG_TYPE_DEBUG)) {
        sub_100090C68();
      }
      *__error() = v35;
    }
    if (!byte_1000EBCF9 || dword_1000EB4A8 > 0) {
      return;
    }
    int v24 = *__error();
    CFStringRef v37 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"Found ISO timestamp with time zone name %ld", v34);
    if (!v37)
    {
      CFStringRef v85 = sub_10002E548();
      if (os_log_type_enabled(v85, OS_LOG_TYPE_FAULT)) {
LABEL_158:
      }
        sub_100090C00();
LABEL_159:
      if (qword_1000EBD00) {
        int v91 = (FILE *)qword_1000EBD00;
      }
      else {
        int v91 = __stderrp;
      }
      fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v91);
LABEL_199:
      *__error() = v24;
      return;
    }
    CFStringRef v26 = v37;
    gzFile v27 = CFStringGetCStringPtr(v37, 0x8000100u);
    if (!v27)
    {
      malloc_type_id_t v28 = 1147833939;
      goto LABEL_192;
    }
LABEL_69:
    uint64_t v42 = (char *)v27;
    uint64_t v43 = 0;
LABEL_193:
    if (qword_1000EBD00) {
      double v100 = (FILE *)qword_1000EBD00;
    }
    else {
      double v100 = __stderrp;
    }
    fprintf(v100, "%s\n", v42);
    if (v43) {
      free(v43);
    }
    CFRelease(v26);
    goto LABEL_199;
  }
  __int16 v6 = strptime(a1, "%Y-%m-%dT%T %Z", &v119);
  if (v6 && !*v6)
  {
    time_t v38 = mktime(&v119);
    if (byte_1000EBCF8)
    {
      int v39 = *__error();
      unint64_t v40 = sub_10002E548();
      if (os_log_type_enabled(v40, OS_LOG_TYPE_DEBUG)) {
        sub_100090C68();
      }
      *__error() = v39;
    }
    if (!byte_1000EBCF9 || dword_1000EB4A8 > 0) {
      return;
    }
    int v24 = *__error();
    CFStringRef v41 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"Found ISO timestamp with time zone name %ld", v38);
    if (v41)
    {
      CFStringRef v26 = v41;
      gzFile v27 = CFStringGetCStringPtr(v41, 0x8000100u);
      if (v27) {
        goto LABEL_69;
      }
      malloc_type_id_t v28 = 134103016;
LABEL_192:
      uint64_t v42 = (char *)malloc_type_calloc(0x400uLL, 1uLL, v28);
      CFStringGetCString(v26, v42, 1024, 0x8000100u);
      uint64_t v43 = v42;
      goto LABEL_193;
    }
    uint64_t v90 = sub_10002E548();
    if (os_log_type_enabled(v90, OS_LOG_TYPE_FAULT)) {
      goto LABEL_158;
    }
    goto LABEL_159;
  }
  CFStringRef v7 = strptime(a1, "%Y-%m-%d %T", &v119);
  __endptr = v7;
  if (v7 || (CFStringRef v7 = strptime(a1, "%Y-%m-%dT%T", &v119), (__endptr = v7) != 0))
  {
    if (*v7 == 46)
    {
      *(void *)&v121[0] = 0;
      double v48 = strtod(v7 - 2, (char **)v121);
      if (*(void *)&v121[0] <= (unint64_t)v7)
      {
        if (byte_1000EBCF8)
        {
          int v105 = *__error();
          uint64_t v106 = sub_10002E548();
          if (os_log_type_enabled(v106, OS_LOG_TYPE_ERROR)) {
            sub_100090B78();
          }
          *__error() = v105;
        }
        if (byte_1000EBCF9 && dword_1000EB4A8 <= 3)
        {
          int v107 = *__error();
          CFStringRef v108 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%s: endOfSecs %p endPtr %p", "endOfSecs && endOfSecs > endptr", *(void *)&v121[0], v7);
          if (v108)
          {
            CFStringRef v111 = v108;
            int v112 = CFStringGetCStringPtr(v108, 0x8000100u);
            if (v112)
            {
              CFStringRef v113 = (char *)v112;
              unsigned int v114 = 0;
            }
            else
            {
              CFStringRef v113 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xE3D25C61uLL);
              CFStringGetCString(v111, v113, 1024, 0x8000100u);
              unsigned int v114 = v113;
            }
            if (qword_1000EBD00) {
              uint64_t v115 = (FILE *)qword_1000EBD00;
            }
            else {
              uint64_t v115 = __stderrp;
            }
            fprintf(v115, "%s\n", v113);
            if (v114) {
              free(v114);
            }
            CFRelease(v111);
          }
          else
          {
            uint64_t v109 = sub_10002E548();
            if (os_log_type_enabled(v109, OS_LOG_TYPE_FAULT)) {
              sub_100090AF0();
            }
            if (qword_1000EBD00) {
              uint64_t v110 = (FILE *)qword_1000EBD00;
            }
            else {
              uint64_t v110 = __stderrp;
            }
            fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v110);
          }
          *__error() = v107;
        }
        sub_10002E41C("TimeFromString", "spindump.m", 4001, "%s: endOfSecs %p endPtr %p", v44, v45, v46, v47, (char)"endOfSecs && endOfSecs > endptr");
        abort();
      }
      double v9 = v48;
      if (!**(unsigned char **)&v121[0]
        || ((uint64_t v49 = strptime(*(const char **)&v121[0], " %z", &v119), (__endptr = v49) != 0)
         || (uint64_t v49 = strptime(*(const char **)&v121[0], " %Z", &v119), (__endptr = v49) != 0))
        && !*v49)
      {
        time_t v8 = mktime(&v119);
        if (v9 > 0.0)
        {
          if (byte_1000EBCF8)
          {
            int v58 = *__error();
            BOOL v59 = sub_10002E548();
            if (os_log_type_enabled(v59, OS_LOG_TYPE_DEBUG)) {
              sub_100090980(v8, v59, v9);
            }
            *__error() = v58;
          }
          if (!byte_1000EBCF9 || dword_1000EB4A8 > 0) {
            goto LABEL_175;
          }
          int v60 = *__error();
          double v61 = fmod(v9, 1.0);
          CFStringRef v62 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"Found ISO timestamp %ld with subseconds %f", v8, *(void *)&v61);
          if (v62)
          {
            CFStringRef v63 = v62;
            int v64 = CFStringGetCStringPtr(v62, 0x8000100u);
            if (v64)
            {
LABEL_111:
              BOOL v69 = (char *)v64;
              uint64_t v70 = 0;
LABEL_168:
              if (qword_1000EBD00) {
                CFStringRef v98 = (FILE *)qword_1000EBD00;
              }
              else {
                CFStringRef v98 = __stderrp;
              }
              fprintf(v98, "%s\n", v69);
              if (v70) {
                free(v70);
              }
              CFRelease(v63);
LABEL_174:
              *__error() = v60;
LABEL_175:
              fmod(v9, 1.0);
              return;
            }
            malloc_type_id_t v65 = 1035006030;
LABEL_167:
            BOOL v69 = (char *)malloc_type_calloc(0x400uLL, 1uLL, v65);
            CFStringGetCString(v63, v69, 1024, 0x8000100u);
            uint64_t v70 = v69;
            goto LABEL_168;
          }
          id v103 = sub_10002E548();
          if (os_log_type_enabled(v103, OS_LOG_TYPE_FAULT)) {
            sub_1000908FC(v8, v103, v61);
          }
LABEL_147:
          if (qword_1000EBD00) {
            double v87 = (FILE *)qword_1000EBD00;
          }
          else {
            double v87 = __stderrp;
          }
          fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v87);
          goto LABEL_174;
        }
LABEL_103:
        if (byte_1000EBCF8)
        {
          int v66 = *__error();
          int v67 = sub_10002E548();
          if (os_log_type_enabled(v67, OS_LOG_TYPE_DEBUG)) {
            sub_100090A88();
          }
          *__error() = v66;
        }
        if (!byte_1000EBCF9 || dword_1000EB4A8 > 0) {
          goto LABEL_175;
        }
        int v60 = *__error();
        CFStringRef v68 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"Found ISO timestamp %ld", v8);
        if (v68)
        {
          CFStringRef v63 = v68;
          int v64 = CFStringGetCStringPtr(v68, 0x8000100u);
          if (v64) {
            goto LABEL_111;
          }
          malloc_type_id_t v65 = 2120532020;
          goto LABEL_167;
        }
        CFStringRef v86 = sub_10002E548();
        if (os_log_type_enabled(v86, OS_LOG_TYPE_FAULT)) {
          sub_100090A20();
        }
        goto LABEL_147;
      }
    }
    else if (!*v7)
    {
      time_t v8 = mktime(&v119);
      double v9 = 0.0;
      goto LABEL_103;
    }
  }
  CFAbsoluteTime atp = 0.0;
  CFLocaleRef v50 = CFLocaleCopyCurrent();
  if (v50)
  {
    CFStringRef v51 = CFStringCreateWithCString(0, a1, 0x8000100u);
    if (v51)
    {
      uint64_t v52 = 0;
      id v53 = 0;
LABEL_78:
      uint64_t v54 = 0;
      while (1)
      {
        if (v53) {
          CFRelease(v53);
        }
        uint64_t v55 = CFDateFormatterCreate(0, v50, (CFDateFormatterStyle)qword_1000A0CC8[v52], (CFDateFormatterStyle)qword_1000A0CC8[v54]);
        if (!v55) {
          break;
        }
        id v53 = v55;
        CFDateFormatterSetProperty(v55, kCFDateFormatterIsLenient, kCFBooleanTrue);
        if (CFDateFormatterGetAbsoluteTimeFromString(v53, v51, 0, &atp)) {
          goto LABEL_123;
        }
        if (++v54 == 4)
        {
          if (++v52 != 4) {
            goto LABEL_78;
          }
          goto LABEL_123;
        }
      }
      if (byte_1000EBCF8)
      {
        int v72 = *__error();
        CFStringRef v73 = sub_10002E548();
        if (os_log_type_enabled(v73, OS_LOG_TYPE_ERROR)) {
          sub_1000908BC();
        }
        *__error() = v72;
      }
      if (byte_1000EBCF9) {
        BOOL v74 = dword_1000EB4A8 <= 3;
      }
      else {
        BOOL v74 = 0;
      }
      if (v74)
      {
        int v92 = *__error();
        CFStringRef v93 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"Unable to create date formatter");
        if (v93)
        {
          CFStringRef v94 = v93;
          CFStringRef v95 = CFStringGetCStringPtr(v93, 0x8000100u);
          if (v95)
          {
            v96 = (char *)v95;
            int v97 = 0;
          }
          else
          {
            v96 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xA74AC0B4uLL);
            CFStringGetCString(v94, v96, 1024, 0x8000100u);
            int v97 = v96;
          }
          if (qword_1000EBD00) {
            uint64_t v104 = (FILE *)qword_1000EBD00;
          }
          else {
            uint64_t v104 = __stderrp;
          }
          fprintf(v104, "%s\n", v96);
          if (v97) {
            free(v97);
          }
          CFRelease(v94);
        }
        else
        {
          double v101 = sub_10002E548();
          if (os_log_type_enabled(v101, OS_LOG_TYPE_FAULT)) {
            sub_100090888();
          }
          if (qword_1000EBD00) {
            int v102 = (FILE *)qword_1000EBD00;
          }
          else {
            int v102 = __stderrp;
          }
          fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v102);
        }
        id v53 = 0;
        *__error() = v92;
        goto LABEL_123;
      }
    }
  }
  else
  {
    CFStringRef v51 = 0;
  }
  id v53 = 0;
LABEL_123:
  if (atp == 0.0)
  {
    memset(v121, 0, sizeof(v121));
    memset(&v117, 0, sizeof(v117));
    time_t v116 = (uint64_t)(CFAbsoluteTimeGetCurrent() + kCFAbsoluteTimeIntervalSince1970);
    localtime_r(&v116, &v117);
    strftime((char *)v121, 0x80uLL, "%Y-%m-%dT%T%z", &v117);
    if (byte_1000EBCF8)
    {
      int v75 = *__error();
      CFStringRef v76 = sub_10002E548();
      if (os_log_type_enabled(v76, OS_LOG_TYPE_ERROR)) {
        sub_100090810();
      }
      *__error() = v75;
    }
    if (byte_1000EBCF9 && dword_1000EB4A8 <= 3)
    {
      int v77 = *__error();
      CFStringRef v78 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"Unable to parse time string %s, try using format '%%Y-%%m-%%dT%%T%%z', e.g. %s", a1, v121);
      if (v78)
      {
        CFStringRef v79 = v78;
        double v80 = CFStringGetCStringPtr(v78, 0x8000100u);
        if (v80)
        {
          int v81 = (char *)v80;
          uint64_t v82 = 0;
        }
        else
        {
          int v81 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x8F7724A9uLL);
          CFStringGetCString(v79, v81, 1024, 0x8000100u);
          uint64_t v82 = v81;
        }
        if (qword_1000EBD00) {
          double v99 = (FILE *)qword_1000EBD00;
        }
        else {
          double v99 = __stderrp;
        }
        fprintf(v99, "%s\n", v81);
        if (v82) {
          free(v82);
        }
        CFRelease(v79);
      }
      else
      {
        double v88 = sub_10002E548();
        if (os_log_type_enabled(v88, OS_LOG_TYPE_FAULT)) {
          sub_1000907A8();
        }
        if (qword_1000EBD00) {
          int v89 = (FILE *)qword_1000EBD00;
        }
        else {
          int v89 = __stderrp;
        }
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v89);
      }
      *__error() = v77;
    }
  }
  if (v51) {
    CFRelease(v51);
  }
  if (v50) {
    CFRelease(v50);
  }
  if (v53) {
    CFRelease(v53);
  }
}

uint64_t sub_10002CC18()
{
  if (qword_1000EB510 != -1) {
    dispatch_once(&qword_1000EB510, &stru_1000DCB58);
  }
  return dword_1000EB508;
}

void sub_10002CC5C(id a1)
{
  *(void *)uint64_t v2 = 0x600000001;
  size_t v1 = 4;
  if (sysctl(v2, 2u, &dword_1000EB508, &v1, 0, 0) == -1) {
    sub_1000828A0();
  }
}

uint64_t sub_10002CCE8(const char *a1, int a2, int a3, char a4, char **a5)
{
  pid_t v190 = getpid();
  __endptr = 0;
  if (!a1 || !*a1) {
    return 4294967294;
  }
  uint64_t v9 = strtol(a1, &__endptr, 0);
  if (__endptr != a1 && !*__endptr)
  {
    uint64_t v32 = v9;
    if (!v9 || !kill(v9, 0))
    {
      if (a5)
      {
        if (proc_pidpath(v32, &buffer, 0x400u) >= 1)
        {
          BOOL v71 = (char *)malloc_type_malloc(0x400uLL, 0xAB8C5037uLL);
          *a5 = v71;
          basename_r((const char *)&buffer, v71);
        }
        if (byte_1000EBCF8)
        {
          int v72 = *__error();
          CFStringRef v73 = sub_10002E548();
          if (os_log_type_enabled(v73, OS_LOG_TYPE_DEBUG)) {
            sub_100082AB0();
          }
          *__error() = v72;
        }
        if (!byte_1000EBCF9 || dword_1000EB4A8 > 0) {
          return v32;
        }
        int v74 = *__error();
        CFStringRef v75 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"Found pid %s [%d]", *a5, v32);
        if (v75)
        {
          CFStringRef v76 = v75;
          CStringPtr = CFStringGetCStringPtr(v75, 0x8000100u);
          if (!CStringPtr)
          {
            malloc_type_id_t v78 = 3504435981;
LABEL_314:
            uint64_t v153 = (char *)malloc_type_calloc(0x400uLL, 1uLL, v78);
            CFStringGetCString(v76, v153, 1024, 0x8000100u);
            uint64_t v154 = v153;
            goto LABEL_315;
          }
          goto LABEL_246;
        }
        uint64_t v175 = sub_10002E548();
        if (os_log_type_enabled(v175, OS_LOG_TYPE_FAULT)) {
          sub_100082A34();
        }
      }
      else
      {
        if (byte_1000EBCF8)
        {
          int v150 = *__error();
          int v151 = sub_10002E548();
          if (os_log_type_enabled(v151, OS_LOG_TYPE_DEBUG)) {
            sub_1000829BC(v32, v151);
          }
          *__error() = v150;
        }
        if (!byte_1000EBCF9 || dword_1000EB4A8 > 0) {
          return v32;
        }
        int v74 = *__error();
        CFStringRef v152 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"Found pid [%d]", v32);
        if (v152)
        {
          CFStringRef v76 = v152;
          CStringPtr = CFStringGetCStringPtr(v152, 0x8000100u);
          if (!CStringPtr)
          {
            malloc_type_id_t v78 = 683168702;
            goto LABEL_314;
          }
LABEL_246:
          uint64_t v153 = (char *)CStringPtr;
          uint64_t v154 = 0;
LABEL_315:
          if (qword_1000EBD00) {
            uint64_t v180 = (FILE *)qword_1000EBD00;
          }
          else {
            uint64_t v180 = __stderrp;
          }
          fprintf(v180, "%s\n", v153);
          if (v154) {
            free(v154);
          }
          CFRelease(v76);
LABEL_321:
          *__error() = v74;
          return v32;
        }
        uint64_t v178 = sub_10002E548();
        if (os_log_type_enabled(v178, OS_LOG_TYPE_FAULT)) {
          sub_100082944(v32, v178);
        }
      }
      if (qword_1000EBD00) {
        uint64_t v179 = (FILE *)qword_1000EBD00;
      }
      else {
        uint64_t v179 = __stderrp;
      }
      fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v179);
      goto LABEL_321;
    }
  }
  if (qword_1000EB510 != -1) {
    dispatch_once(&qword_1000EB510, &stru_1000DCB58);
  }
  int v10 = dword_1000EB508;
  CFStringRef v185 = (unsigned int *)malloc_type_calloc(dword_1000EB508, 4uLL, 0x100004052888210uLL);
  int v11 = proc_listallpids(v185, 4 * v10);
  if (v11 == -1)
  {
    perror("proc_listallpids");
    free(v185);
    return 4294967294;
  }
  int v12 = v11;
  BOOL v13 = (char *)malloc_type_calloc(v11, 0x400uLL, 0x1000040D7EB2065uLL);
  CFStringRef v184 = v13;
  if (v12 < 1)
  {
    if (a3)
    {
      sub_10002E4A0((char *)&buffer, 0x100uLL, "Multiple matches for \"%s\": ", v14, v15, v16, v17, v18, (char)a1);
      CFStringRef v51 = 0;
LABEL_133:
      uint64_t v32 = 4294967294;
LABEL_134:
      if (a5) {
        goto LABEL_301;
      }
      goto LABEL_302;
    }
    unsigned int v181 = v12;
    uint64_t v182 = a5;
    unsigned int v187 = -1;
LABEL_95:
    if (int)v181 < 1 || (a2) {
      goto LABEL_131;
    }
    uint64_t v79 = v181;
    CFAllocatorRef alloc = (CFAllocatorRef)v181;
    int v81 = v184;
    double v80 = v185;
    uint64_t v82 = v184;
    do
    {
      if (!strncasecmp(v81, a1, 0x400uLL))
      {
        if (byte_1000EBCF8)
        {
          int v83 = *__error();
          double v84 = sub_10002E548();
          if (os_log_type_enabled(v84, OS_LOG_TYPE_DEBUG))
          {
            unsigned int v95 = *v80;
            int buffer = 136315394;
            int v195 = v82;
            __int16 v196 = 1024;
            unsigned int v197 = v95;
            _os_log_debug_impl((void *)&_mh_execute_header, v84, OS_LOG_TYPE_DEBUG, "Found case insensitive match %s [%d]", (uint8_t *)&buffer, 0x12u);
          }
          *__error() = v83;
        }
        if (byte_1000EBCF9) {
          BOOL v85 = dword_1000EB4A8 <= 0;
        }
        else {
          BOOL v85 = 0;
        }
        if (v85)
        {
          int v86 = *__error();
          CFStringRef v87 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"Found case insensitive match %s [%d]", v81, *v80);
          if (v87)
          {
            CFStringRef v88 = v87;
            int v89 = CFStringGetCStringPtr(v87, 0x8000100u);
            if (v89)
            {
              uint64_t v90 = (char *)v89;
              int v91 = 0;
            }
            else
            {
              uint64_t v90 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x6C3642E0uLL);
              CFStringGetCString(v88, v90, 1024, 0x8000100u);
              int v91 = v90;
            }
            if (qword_1000EBD00) {
              CFStringRef v94 = (FILE *)qword_1000EBD00;
            }
            else {
              CFStringRef v94 = __stderrp;
            }
            fprintf(v94, "%s\n", v90);
            if (v91) {
              free(v91);
            }
            CFRelease(v88);
          }
          else
          {
            int v92 = sub_10002E548();
            if (os_log_type_enabled(v92, OS_LOG_TYPE_FAULT))
            {
              unsigned int v96 = *v80;
              int buffer = 136315394;
              int v195 = v82;
              __int16 v196 = 1024;
              unsigned int v197 = v96;
              _os_log_fault_impl((void *)&_mh_execute_header, v92, OS_LOG_TYPE_FAULT, "Unable to format: Found case insensitive match %s [%d]", (uint8_t *)&buffer, 0x12u);
            }
            if (qword_1000EBD00) {
              CFStringRef v93 = (FILE *)qword_1000EBD00;
            }
            else {
              CFStringRef v93 = __stderrp;
            }
            fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v93);
          }
          *__error() = v86;
        }
        uint64_t v32 = *v80;
        if ((a4 & 1) != 0 || v190 != v32)
        {
          if (v190 != v32)
          {
LABEL_249:
            if (v182) {
              *uint64_t v182 = strdup(v81);
            }
            goto LABEL_302;
          }
          unsigned int v187 = *v80;
        }
      }
      ++v80;
      v81 += 1024;
      v82 += 1024;
      --v79;
    }
    while (v79);
    size_t v97 = strlen(a1);
    if (v97 > 0x3FF)
    {
LABEL_131:
      uint64_t v32 = v187;
      goto LABEL_302;
    }
    size_t v98 = v97;
    uint64_t v99 = v181;
    id v53 = v184;
    double v100 = v184;
    double v101 = v185;
    while (1)
    {
      if (!strncmp(v53, a1, v98))
      {
        if (byte_1000EBCF8)
        {
          int v102 = *__error();
          id v103 = sub_10002E548();
          if (os_log_type_enabled(v103, OS_LOG_TYPE_DEBUG))
          {
            unsigned int v114 = *v101;
            int buffer = 136315394;
            int v195 = v100;
            __int16 v196 = 1024;
            unsigned int v197 = v114;
            _os_log_debug_impl((void *)&_mh_execute_header, v103, OS_LOG_TYPE_DEBUG, "Found prefix match %s [%d]", (uint8_t *)&buffer, 0x12u);
          }
          *__error() = v102;
        }
        if (byte_1000EBCF9) {
          BOOL v104 = dword_1000EB4A8 <= 0;
        }
        else {
          BOOL v104 = 0;
        }
        if (v104)
        {
          int v105 = *__error();
          CFStringRef v106 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"Found prefix match %s [%d]", v53, *v101);
          if (v106)
          {
            CFStringRef v107 = v106;
            CFStringRef v108 = CFStringGetCStringPtr(v106, 0x8000100u);
            if (v108)
            {
              uint64_t v109 = (char *)v108;
              uint64_t v110 = 0;
            }
            else
            {
              uint64_t v109 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x43C6907CuLL);
              CFStringGetCString(v107, v109, 1024, 0x8000100u);
              uint64_t v110 = v109;
            }
            if (qword_1000EBD00) {
              CFStringRef v113 = (FILE *)qword_1000EBD00;
            }
            else {
              CFStringRef v113 = __stderrp;
            }
            fprintf(v113, "%s\n", v109);
            if (v110) {
              free(v110);
            }
            CFRelease(v107);
          }
          else
          {
            CFStringRef v111 = sub_10002E548();
            if (os_log_type_enabled(v111, OS_LOG_TYPE_FAULT))
            {
              unsigned int v115 = *v101;
              int buffer = 136315394;
              int v195 = v100;
              __int16 v196 = 1024;
              unsigned int v197 = v115;
              _os_log_fault_impl((void *)&_mh_execute_header, v111, OS_LOG_TYPE_FAULT, "Unable to format: Found prefix match %s [%d]", (uint8_t *)&buffer, 0x12u);
            }
            if (qword_1000EBD00) {
              int v112 = (FILE *)qword_1000EBD00;
            }
            else {
              int v112 = __stderrp;
            }
            fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v112);
          }
          *__error() = v105;
        }
        uint64_t v32 = *v101;
        if ((a4 & 1) != 0 || v190 != v32)
        {
          if (v190 != v32) {
            goto LABEL_203;
          }
          unsigned int v187 = *v101;
        }
      }
      ++v101;
      v53 += 1024;
      v100 += 1024;
      if (!--v99)
      {
        uint64_t v116 = v181;
        id v53 = v184;
        tm v117 = v184;
        uint64_t v118 = v185;
        while (1)
        {
          if (!strncasecmp(v53, a1, v98))
          {
            if (byte_1000EBCF8)
            {
              int v119 = *__error();
              uint64_t v120 = sub_10002E548();
              if (os_log_type_enabled(v120, OS_LOG_TYPE_DEBUG))
              {
                unsigned int v131 = *v118;
                int buffer = 136315394;
                int v195 = v117;
                __int16 v196 = 1024;
                unsigned int v197 = v131;
                _os_log_debug_impl((void *)&_mh_execute_header, v120, OS_LOG_TYPE_DEBUG, "Found case insensitive prefix match %s [%d]", (uint8_t *)&buffer, 0x12u);
              }
              *__error() = v119;
            }
            if (byte_1000EBCF9) {
              BOOL v121 = dword_1000EB4A8 <= 0;
            }
            else {
              BOOL v121 = 0;
            }
            if (v121)
            {
              int v122 = *__error();
              CFStringRef v123 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"Found case insensitive prefix match %s [%d]", v53, *v118);
              if (v123)
              {
                CFStringRef v124 = v123;
                v125 = CFStringGetCStringPtr(v123, 0x8000100u);
                if (v125)
                {
                  uint64_t v126 = (char *)v125;
                  int v127 = 0;
                }
                else
                {
                  uint64_t v126 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x88FE65CEuLL);
                  CFStringGetCString(v124, v126, 1024, 0x8000100u);
                  int v127 = v126;
                }
                if (qword_1000EBD00) {
                  v130 = (FILE *)qword_1000EBD00;
                }
                else {
                  v130 = __stderrp;
                }
                fprintf(v130, "%s\n", v126);
                if (v127) {
                  free(v127);
                }
                CFRelease(v124);
              }
              else
              {
                xpc_object_t v128 = sub_10002E548();
                if (os_log_type_enabled(v128, OS_LOG_TYPE_FAULT))
                {
                  unsigned int v132 = *v118;
                  int buffer = 136315394;
                  int v195 = v117;
                  __int16 v196 = 1024;
                  unsigned int v197 = v132;
                  _os_log_fault_impl((void *)&_mh_execute_header, v128, OS_LOG_TYPE_FAULT, "Unable to format: Found case insensitive prefix match %s [%d]", (uint8_t *)&buffer, 0x12u);
                }
                if (qword_1000EBD00) {
                  CFStringRef v129 = (FILE *)qword_1000EBD00;
                }
                else {
                  CFStringRef v129 = __stderrp;
                }
                fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v129);
              }
              *__error() = v122;
            }
            uint64_t v32 = *v118;
            if ((a4 & 1) != 0 || v190 != v32)
            {
              if (v190 != v32) {
                goto LABEL_203;
              }
              unsigned int v187 = *v118;
            }
          }
          ++v118;
          v53 += 1024;
          v117 += 1024;
          if (!--v116)
          {
            uint64_t v133 = v181;
            int v81 = v184;
            unsigned int v134 = v184;
            char v135 = v185;
            while (1)
            {
              if (strstr(v81, a1))
              {
                if (byte_1000EBCF8)
                {
                  int v136 = *__error();
                  BOOL v137 = sub_10002E548();
                  if (os_log_type_enabled(v137, OS_LOG_TYPE_DEBUG))
                  {
                    unsigned int v148 = *v135;
                    int buffer = 136315394;
                    int v195 = v134;
                    __int16 v196 = 1024;
                    unsigned int v197 = v148;
                    _os_log_debug_impl((void *)&_mh_execute_header, v137, OS_LOG_TYPE_DEBUG, "Found partial match %s [%d]", (uint8_t *)&buffer, 0x12u);
                  }
                  *__error() = v136;
                }
                if (byte_1000EBCF9) {
                  BOOL v138 = dword_1000EB4A8 <= 0;
                }
                else {
                  BOOL v138 = 0;
                }
                if (v138)
                {
                  int v139 = *__error();
                  CFStringRef v140 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"Found partial match %s [%d]", v81, *v135);
                  if (v140)
                  {
                    CFStringRef v141 = v140;
                    CFStringRef v142 = CFStringGetCStringPtr(v140, 0x8000100u);
                    if (v142)
                    {
                      uint64_t v143 = (char *)v142;
                      int v144 = 0;
                    }
                    else
                    {
                      uint64_t v143 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x7D3F60F8uLL);
                      CFStringGetCString(v141, v143, 1024, 0x8000100u);
                      int v144 = v143;
                    }
                    if (qword_1000EBD00) {
                      uint64_t v147 = (FILE *)qword_1000EBD00;
                    }
                    else {
                      uint64_t v147 = __stderrp;
                    }
                    fprintf(v147, "%s\n", v143);
                    if (v144) {
                      free(v144);
                    }
                    CFRelease(v141);
                  }
                  else
                  {
                    int v145 = sub_10002E548();
                    if (os_log_type_enabled(v145, OS_LOG_TYPE_FAULT))
                    {
                      unsigned int v149 = *v135;
                      int buffer = 136315394;
                      int v195 = v134;
                      __int16 v196 = 1024;
                      unsigned int v197 = v149;
                      _os_log_fault_impl((void *)&_mh_execute_header, v145, OS_LOG_TYPE_FAULT, "Unable to format: Found partial match %s [%d]", (uint8_t *)&buffer, 0x12u);
                    }
                    if (qword_1000EBD00) {
                      int v146 = (FILE *)qword_1000EBD00;
                    }
                    else {
                      int v146 = __stderrp;
                    }
                    fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v146);
                  }
                  *__error() = v139;
                }
                uint64_t v32 = *v135;
                if ((a4 & 1) != 0 || v190 != v32)
                {
                  if (v190 != v32) {
                    goto LABEL_249;
                  }
                  unsigned int v187 = *v135;
                }
              }
              ++v135;
              v81 += 1024;
              v134 += 1024;
              if (!--v133)
              {
                uint64_t v155 = v184;
                uint64_t v156 = v185;
                uint64_t v157 = v184;
                uint64_t v32 = v187;
                while (1)
                {
                  if (strcasestr(v155, a1))
                  {
                    if (byte_1000EBCF8)
                    {
                      int v158 = *__error();
                      uint64_t v159 = sub_10002E548();
                      if (os_log_type_enabled(v159, OS_LOG_TYPE_DEBUG))
                      {
                        unsigned int v171 = *v156;
                        int buffer = 136315394;
                        int v195 = v157;
                        __int16 v196 = 1024;
                        unsigned int v197 = v171;
                        _os_log_debug_impl((void *)&_mh_execute_header, v159, OS_LOG_TYPE_DEBUG, "Found case insensitive partial match %s [%d]", (uint8_t *)&buffer, 0x12u);
                      }
                      *__error() = v158;
                    }
                    if (byte_1000EBCF9) {
                      BOOL v160 = dword_1000EB4A8 <= 0;
                    }
                    else {
                      BOOL v160 = 0;
                    }
                    if (v160)
                    {
                      int v161 = *__error();
                      CFStringRef v162 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"Found case insensitive partial match %s [%d]", v155, *v156);
                      if (v162)
                      {
                        CFStringRef v163 = v162;
                        uint64_t v164 = CFStringGetCStringPtr(v162, 0x8000100u);
                        if (v164)
                        {
                          uint64_t v165 = (char *)v164;
                          uint64_t v166 = 0;
                        }
                        else
                        {
                          uint64_t v165 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xC82CF512uLL);
                          CFStringGetCString(v163, v165, 1024, 0x8000100u);
                          uint64_t v166 = v165;
                        }
                        if (qword_1000EBD00) {
                          uint64_t v169 = (FILE *)qword_1000EBD00;
                        }
                        else {
                          uint64_t v169 = __stderrp;
                        }
                        fprintf(v169, "%s\n", v165);
                        if (v166) {
                          free(v166);
                        }
                        CFRelease(v163);
                      }
                      else
                      {
                        uint64_t v167 = sub_10002E548();
                        if (os_log_type_enabled(v167, OS_LOG_TYPE_FAULT))
                        {
                          unsigned int v172 = *v156;
                          int buffer = 136315394;
                          int v195 = v157;
                          __int16 v196 = 1024;
                          unsigned int v197 = v172;
                          _os_log_fault_impl((void *)&_mh_execute_header, v167, OS_LOG_TYPE_FAULT, "Unable to format: Found case insensitive partial match %s [%d]", (uint8_t *)&buffer, 0x12u);
                        }
                        if (qword_1000EBD00) {
                          uint64_t v168 = (FILE *)qword_1000EBD00;
                        }
                        else {
                          uint64_t v168 = __stderrp;
                        }
                        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v168);
                      }
                      *__error() = v161;
                    }
                    uint64_t v170 = *v156;
                    if ((a4 & 1) != 0 || v190 != v170)
                    {
                      if (v190 != v170)
                      {
                        if (v182) {
                          *uint64_t v182 = strdup(v155);
                        }
                        uint64_t v32 = v170;
                        goto LABEL_302;
                      }
                      uint64_t v32 = *v156;
                    }
                  }
                  ++v156;
                  v155 += 1024;
                  v157 += 1024;
                  CFAllocatorRef alloc = (CFAllocatorRef)((char *)alloc - 1);
                  if (!alloc) {
                    goto LABEL_302;
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  unsigned int v181 = v12;
  uint64_t v19 = v12;
  uint64_t v20 = v12;
  int v21 = v13;
  int v22 = (int *)v185;
  do
  {
    int v23 = *v22++;
    if (proc_pidpath(v23, &buffer, 0x400u) >= 1) {
      basename_r((const char *)&buffer, v21);
    }
    v21 += 1024;
    --v20;
  }
  while (v20);
  uint64_t v182 = a5;
  int v188 = a2;
  if ((a3 & 1) == 0)
  {
    unsigned int v187 = -1;
    uint64_t v52 = &byte_1000EBCF8;
    id v53 = v184;
    uint64_t v54 = v185;
    uint64_t v55 = v184;
    do
    {
      if (!strncmp(v53, a1, 0x400uLL))
      {
        if (*v52)
        {
          int v56 = *__error();
          int v57 = sub_10002E548();
          if (os_log_type_enabled(v57, OS_LOG_TYPE_DEBUG))
          {
            unsigned int v69 = *v54;
            int buffer = 136315394;
            int v195 = v55;
            __int16 v196 = 1024;
            unsigned int v197 = v69;
            _os_log_debug_impl((void *)&_mh_execute_header, v57, OS_LOG_TYPE_DEBUG, "Found exact match %s [%d]", (uint8_t *)&buffer, 0x12u);
          }
          *__error() = v56;
        }
        if (byte_1000EBCF9) {
          BOOL v58 = dword_1000EB4A8 <= 0;
        }
        else {
          BOOL v58 = 0;
        }
        if (v58)
        {
          BOOL v59 = v52;
          int v60 = *__error();
          CFStringRef v61 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"Found exact match %s [%d]", v53, *v54);
          if (v61)
          {
            CFStringRef v62 = v61;
            CFStringRef v63 = CFStringGetCStringPtr(v61, 0x8000100u);
            if (v63)
            {
              int v64 = (char *)v63;
              malloc_type_id_t v65 = 0;
            }
            else
            {
              int v64 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x1EFAEFDAuLL);
              CFStringGetCString(v62, v64, 1024, 0x8000100u);
              malloc_type_id_t v65 = v64;
            }
            if (qword_1000EBD00) {
              CFStringRef v68 = (FILE *)qword_1000EBD00;
            }
            else {
              CFStringRef v68 = __stderrp;
            }
            fprintf(v68, "%s\n", v64);
            if (v65) {
              free(v65);
            }
            CFRelease(v62);
          }
          else
          {
            int v66 = sub_10002E548();
            if (os_log_type_enabled(v66, OS_LOG_TYPE_FAULT))
            {
              unsigned int v70 = *v54;
              int buffer = 136315394;
              int v195 = v55;
              __int16 v196 = 1024;
              unsigned int v197 = v70;
              _os_log_fault_impl((void *)&_mh_execute_header, v66, OS_LOG_TYPE_FAULT, "Unable to format: Found exact match %s [%d]", (uint8_t *)&buffer, 0x12u);
            }
            if (qword_1000EBD00) {
              int v67 = (FILE *)qword_1000EBD00;
            }
            else {
              int v67 = __stderrp;
            }
            fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v67);
          }
          LOBYTE(a2) = v188;
          *__error() = v60;
          uint64_t v52 = v59;
        }
        uint64_t v32 = *v54;
        if ((a4 & 1) != 0 || v190 != v32)
        {
          if (v190 != v32)
          {
LABEL_203:
            if (v182) {
              *uint64_t v182 = strdup(v53);
            }
            goto LABEL_302;
          }
          unsigned int v187 = *v54;
        }
      }
      ++v54;
      v53 += 1024;
      v55 += 1024;
      --v19;
    }
    while (v19);
    goto LABEL_95;
  }
  uint64_t v186 = 0;
  char v29 = 0;
  int v30 = 0;
  size_t v31 = (char *)&buffer
      + (int)sub_10002E4A0((char *)&buffer, 0x100uLL, "Multiple matches for \"%s\": ", v24, v25, v26, v27, v28, (char)a1);
  uint64_t v32 = 0xFFFFFFFFLL;
  CFStringRef v33 = v184;
  time_t v34 = v185;
  do
  {
    if (a2)
    {
      if (strncmp(v33, a1, 0x400uLL)) {
        goto LABEL_30;
      }
    }
    else if (!strcasestr(v33, a1))
    {
      goto LABEL_30;
    }
    uint64_t v40 = *v34;
    if ((a4 & 1) != 0 || v190 != v40)
    {
      if (v190 != v40)
      {
        if (a5 && !v30) {
          uint64_t v186 = strdup(v33);
        }
        CFStringRef v41 = ", ";
        if (!v29) {
          CFStringRef v41 = "";
        }
        v31 += (int)sub_10002E4A0(v31, (char *)&v198 - v31, "%s%s [%d]", v35, v36, v37, v38, v39, (char)v41);
        ++v30;
        ++v29;
      }
      uint64_t v32 = v40;
    }
    a2 = v188;
LABEL_30:
    ++v34;
    v33 += 1024;
    --v19;
  }
  while (v19);
  if (v30 < 2)
  {
    CFStringRef v51 = v186;
    if (v30) {
      goto LABEL_134;
    }
    goto LABEL_133;
  }
  if (byte_1000EBCF8)
  {
    int v42 = *__error();
    uint64_t v43 = sub_10002E548();
    if (os_log_type_enabled(v43, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136315138;
      p_int buffer = &buffer;
      _os_log_impl((void *)&_mh_execute_header, v43, OS_LOG_TYPE_DEFAULT, "%s", buf, 0xCu);
    }
    *__error() = v42;
  }
  if (byte_1000EBCF9) {
    BOOL v44 = dword_1000EB4A8 <= 2;
  }
  else {
    BOOL v44 = 0;
  }
  if (v44)
  {
    int v45 = *__error();
    CFStringRef v46 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%s", &buffer);
    if (v46)
    {
      CFStringRef v47 = v46;
      double v48 = CFStringGetCStringPtr(v46, 0x8000100u);
      if (v48)
      {
        uint64_t v49 = (char *)v48;
        CFLocaleRef v50 = 0;
      }
      else
      {
        uint64_t v49 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xAC4F944CuLL);
        CFStringGetCString(v47, v49, 1024, 0x8000100u);
        CFLocaleRef v50 = v49;
      }
      if (qword_1000EBD00) {
        uint64_t v176 = (FILE *)qword_1000EBD00;
      }
      else {
        uint64_t v176 = __stderrp;
      }
      fprintf(v176, "%s\n", v49);
      if (v50) {
        free(v50);
      }
      CFRelease(v47);
    }
    else
    {
      CFStringRef v173 = sub_10002E548();
      if (os_log_type_enabled(v173, OS_LOG_TYPE_FAULT)) {
        sub_1000828CC((uint64_t)&buffer, v173);
      }
      if (qword_1000EBD00) {
        v174 = (FILE *)qword_1000EBD00;
      }
      else {
        v174 = __stderrp;
      }
      fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v174);
    }
    *__error() = v45;
  }
  free(v186);
  CFStringRef v51 = 0;
  uint64_t v32 = 0xFFFFFFFFLL;
  if (a5) {
LABEL_301:
  }
    *a5 = v51;
LABEL_302:
  free(v185);
  free(v184);
  return v32;
}

uint64_t sub_10002E390(char *__format, ...)
{
  va_start(va, __format);
  vsnprintf(__str, 0x200uLL, __format, va);
  return os_transaction_create();
}

uint64_t sub_10002E41C(const char *a1, const char *a2, int a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  uint64_t result = snprintf(byte_1000EB518, 0x400uLL, "Assertion Failed %s %s:%d ", a1, a2, a3);
  if ((result - 1) <= 0x3FE) {
    uint64_t result = vsnprintf(&byte_1000EB518[result], 1024 - result, a4, &a9);
  }
  qword_1000EB4D0 = (uint64_t)byte_1000EB518;
  return result;
}

uint64_t sub_10002E4A0(char *a1, size_t a2, const char *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  LODWORD(result) = vsnprintf(a1, a2, a3, &a9);
  if ((int)result >= a2) {
    return (a2 - 1);
  }
  else {
    return result;
  }
}

_DWORD *sub_10002E4E8(int a1)
{
  unsigned int add_explicit = atomic_fetch_add_explicit(dword_1000EBB18, 1u, memory_order_relaxed);
  int v2 = add_explicit & 3;
  int v4 = -add_explicit;
  BOOL v3 = v4 < 0;
  int v5 = v4 & 3;
  if (v3) {
    int v6 = v2;
  }
  else {
    int v6 = -v5;
  }
  CFStringRef v7 = (_DWORD *)((char *)&unk_1000EB918 + 128 * (uint64_t)v6);
  *CFStringRef v7 = 0;
  proc_name(a1, v7, 0x80u);
  return v7;
}

uint64_t sub_10002E548()
{
  if (qword_1000EBB28 != -1) {
    dispatch_once(&qword_1000EBB28, &stru_1000DCB98);
  }
  return qword_1000EBB20;
}

void sub_10002E58C(id a1)
{
  qword_1000EBB20 = (uint64_t)os_log_create("com.apple.spindump", "logging");
  if (!qword_1000EBB20) {
    sub_100082B2C();
  }
}

uint64_t sub_10002E5C4(int a1)
{
  uint64_t v3 = 0;
  memset(v2, 0, sizeof(v2));
  if (proc_pidinfo(a1, 20, 1uLL, v2, 40) == 40) {
    return *(void *)&v2[0];
  }
  else {
    return 0;
  }
}

id sub_10002E60C(int a1)
{
  if (proc_pidpath(a1, buffer, 0x400u) < 1) {
    return 0;
  }
  else {
    return [objc_alloc((Class)NSString) initWithUTF8String:buffer];
  }
}

void sub_10002E68C(int a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 3221225472;
  v7[2] = sub_10002E900;
  v7[3] = &unk_1000DCC28;
  int v8 = a1;
  v7[4] = a4;
  v7[5] = a5;
  sub_10002E718(a1, a2, a3, 0, a6, a7, 0, 0, 0.0, 0.0, (uint64_t)v7);
}

void sub_10002E718(int a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, double a9, double a10, uint64_t a11)
{
  if (qword_1000EBB78 != -1) {
    dispatch_once(&qword_1000EBB78, &stru_1000DCCF8);
  }
  int v21 = *off_1000DCD38[a4];
  if (os_signpost_enabled(v21) || sub_10002EADC())
  {
    if (!a3)
    {
      memset(buffer, 0, 40);
      if (proc_pidinfo(a1, 20, 1uLL, buffer, 40) == 40) {
        a3 = buffer[0];
      }
      else {
        a3 = 0;
      }
    }
    if (a2) {
      id v22 = a2;
    }
    else {
      id v22 = sub_10002E60C(a1);
    }
    id v23 = v22;
    id v24 = +[SATimestamp timestamp];
    uint64_t v25 = sub_10002E390("Event rate report for [%d] type %lu", a1, a4);
    if (qword_1000EBB88 != -1) {
      dispatch_once(&qword_1000EBB88, &stru_1000DCD18);
    }
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472;
    block[2] = sub_10003079C;
    block[3] = &unk_1000DCCD8;
    block[10] = a6;
    block[11] = a7;
    block[12] = a8;
    block[4] = v23;
    void block[5] = v24;
    *(double *)&block[13] = a9;
    *(double *)&block[14] = a10;
    int v27 = a1;
    block[8] = a11;
    block[9] = a5;
    block[15] = a3;
    block[6] = v21;
    block[7] = v25;
    dispatch_async((dispatch_queue_t)qword_1000EBB80, block);
  }
}

void sub_10002E900(uint64_t a1, os_log_t log, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  if (os_signpost_enabled(log))
  {
    int v12 = *(_DWORD *)(a1 + 48);
    uint64_t v13 = *(void *)(a1 + 32);
    uint64_t v14 = *(void *)(a1 + 40);
    *(_DWORD *)buf = 138544642;
    uint64_t v17 = a4;
    __int16 v18 = 2050;
    uint64_t v19 = a5;
    __int16 v20 = 2050;
    uint64_t v21 = a3;
    __int16 v22 = 1026;
    int v23 = v12;
    __int16 v24 = 2050;
    uint64_t v25 = v13;
    __int16 v26 = 2050;
    uint64_t v27 = v14;
    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, log, OS_SIGNPOST_INTERVAL_BEGIN, 0xEEEEB0B5B2B2EEEELL, "Hang", "BundleIdOverride=%{public, signpost.description:attribute}@ %{public, signpost.description:begin_time}llu cid=%{public,name=cid}llu pid=%{public,name=pid}u conditionsPreventingSubmission=%{public,name=conditionsPreventingSubmission}#llx otherConditions=%{public,name=otherConditions}#llx enableTelemetry=YES ", buf, 0x3Au);
  }
  if (os_signpost_enabled(log))
  {
    *(_DWORD *)buf = 134349056;
    uint64_t v17 = a6;
    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, log, OS_SIGNPOST_INTERVAL_END, 0xEEEEB0B5B2B2EEEELL, "Hang", "%{public, signpost.description:end_time}llu", buf, 0xCu);
  }
  if (&_AnalyticsIsEventUsed)
  {
    int IsEventUsed = AnalyticsIsEventUsed();
    if (a4)
    {
      if (IsEventUsed) {
        AnalyticsSendEventLazy();
      }
    }
  }
}

uint64_t sub_10002EADC()
{
  if (&_AnalyticsIsEventUsed) {
    return AnalyticsIsEventUsed();
  }
  else {
    return 0;
  }
}

NSDictionary *sub_10002EB2C(void *a1)
{
  uint64_t v2 = a1[5];
  v5[0] = a1[4];
  v5[1] = +[NSString stringWithFormat:@"%llu", v2, @"BundleID", @"CoalitionID"];
  v4[2] = @"Duration";
  SASecondsFromMachTimeUsingLiveTimebase();
  v5[2] = +[NSNumber numberWithDouble:](NSNumber, "numberWithDouble:");
  v4[3] = @"ConditionsPreventingSubmission";
  v5[3] = +[NSNumber numberWithUnsignedLongLong:a1[8]];
  v4[4] = @"OtherConditions";
  v5[4] = +[NSNumber numberWithUnsignedLongLong:a1[9]];
  return +[NSDictionary dictionaryWithObjects:v5 forKeys:v4 count:5];
}

void sub_10002EC3C(int a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 3221225472;
  v7[2] = sub_10002ECCC;
  v7[3] = &unk_1000DCC48;
  int v8 = a1;
  v7[4] = a4;
  v7[5] = a5;
  void v7[6] = a7;
  v7[7] = a6;
  sub_10002E718(a1, a2, a3, 1, 0, 0, a6, a7, 0.0, 0.0, (uint64_t)v7);
}

void sub_10002ECCC(uint64_t a1, os_log_t log, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  if (os_signpost_enabled(log))
  {
    int v12 = *(_DWORD *)(a1 + 64);
    uint64_t v13 = *(void *)(a1 + 32);
    uint64_t v14 = *(void *)(a1 + 40);
    *(_DWORD *)buf = 138544642;
    uint64_t v17 = a4;
    __int16 v18 = 2050;
    uint64_t v19 = a5;
    __int16 v20 = 2050;
    uint64_t v21 = a3;
    __int16 v22 = 1026;
    int v23 = v12;
    __int16 v24 = 2050;
    uint64_t v25 = v13;
    __int16 v26 = 2050;
    uint64_t v27 = v14;
    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, log, OS_SIGNPOST_INTERVAL_BEGIN, 0xEEEEB0B5B2B2EEEELL, "SlowHIDResponse", "BundleIdOverride=%{public, signpost.description:attribute}@ %{public, signpost.description:begin_time}llu cid=%{public,name=cid}llu pid=%{public,name=pid}u conditionsPreventingSubmission=%{public,name=conditionsPreventingSubmission}#llx otherConditions=%{public,name=otherConditions}#llx enableTelemetry=YES ", buf, 0x3Au);
  }
  if (os_signpost_enabled(log))
  {
    *(_DWORD *)buf = 134349056;
    uint64_t v17 = a6;
    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, log, OS_SIGNPOST_INTERVAL_END, 0xEEEEB0B5B2B2EEEELL, "SlowHIDResponse", "%{public, signpost.description:end_time}llu", buf, 0xCu);
  }
  if (&_AnalyticsIsEventUsed)
  {
    int IsEventUsed = AnalyticsIsEventUsed();
    if (a4)
    {
      if (IsEventUsed) {
        AnalyticsSendEventLazy();
      }
    }
  }
}

NSDictionary *sub_10002EEA4(void *a1)
{
  uint64_t v2 = a1[5];
  v5[0] = a1[4];
  v5[1] = +[NSString stringWithFormat:@"%llu", v2, @"BundleID", @"CoalitionID"];
  v4[2] = @"Duration";
  SASecondsFromMachTimeUsingLiveTimebase();
  v5[2] = +[NSNumber numberWithDouble:](NSNumber, "numberWithDouble:");
  v4[3] = @"ConditionsPreventingSubmission";
  v5[3] = +[NSNumber numberWithUnsignedLongLong:a1[8]];
  v4[4] = @"OtherConditions";
  v5[4] = +[NSNumber numberWithUnsignedLongLong:a1[9]];
  return +[NSDictionary dictionaryWithObjects:v5 forKeys:v4 count:5];
}

void sub_10002EFB4(int a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, char a6, double a7, double a8, double a9)
{
  v9[0] = _NSConcreteStackBlock;
  v9[1] = 3221225472;
  v9[2] = sub_10002F044;
  v9[3] = &unk_1000DCC90;
  int v10 = a1;
  char v11 = a6;
  *(double *)&v9[4] = a9;
  v9[5] = a4;
  v9[6] = a5;
  *(double *)&v9[7] = a8;
  *(double *)&v9[8] = a7;
  sub_10002E718(a1, a2, a3, 2, 0, 0, 0, 0, a7, a8, (uint64_t)v9);
}

void sub_10002F044(uint64_t a1, os_log_t log, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  if (os_signpost_enabled(log))
  {
    int v12 = *(_DWORD *)(a1 + 72);
    int v13 = *(unsigned __int8 *)(a1 + 76);
    double v14 = round(*(double *)(a1 + 32));
    uint64_t v15 = *(void *)(a1 + 40);
    uint64_t v16 = *(void *)(a1 + 48);
    *(_DWORD *)buf = 138545154;
    uint64_t v19 = a4;
    __int16 v20 = 2050;
    uint64_t v21 = a5;
    __int16 v22 = 2050;
    uint64_t v23 = a3;
    __int16 v24 = 1026;
    int v25 = v12;
    __int16 v26 = 1026;
    int v27 = v13;
    __int16 v28 = 2050;
    double v29 = v14;
    __int16 v30 = 2050;
    uint64_t v31 = v15;
    __int16 v32 = 2050;
    uint64_t v33 = v16;
    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, log, OS_SIGNPOST_INTERVAL_BEGIN, 0xEEEEB0B5B2B2EEEELL, "CPUResource", "BundleIdOverride=%{public,signpost.description:attribute}@ %{public,signpost.description:begin_time}llu cid=%{public,name=cid}llu pid=%{public,name=pid}u fatal=%{public,name=fatal}d cpuUsed=%{public,name=cpuUsed}.0f conditionsPreventingSubmission=%{public,name=conditionsPreventingSubmission}#llx otherConditions=%{public,name=otherConditions}#llx enableTelemetry=YES ", buf, 0x4Au);
  }
  if (os_signpost_enabled(log))
  {
    *(_DWORD *)buf = 134349056;
    uint64_t v19 = a6;
    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, log, OS_SIGNPOST_INTERVAL_END, 0xEEEEB0B5B2B2EEEELL, "CPUResource", "%{public, signpost.description:end_time}llu", buf, 0xCu);
  }
  if (&_AnalyticsIsEventUsed)
  {
    int IsEventUsed = AnalyticsIsEventUsed();
    if (a4)
    {
      if (IsEventUsed) {
        AnalyticsSendEventLazy();
      }
    }
  }
}

NSDictionary *sub_10002F254(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 40);
  v5[0] = *(void *)(a1 + 32);
  v5[1] = +[NSString stringWithFormat:@"%llu", v2, @"BundleID", @"CoalitionID"];
  v4[2] = @"Duration";
  v5[2] = +[NSNumber numberWithDouble:*(double *)(a1 + 48) - *(double *)(a1 + 56)];
  v4[3] = @"CpuUsedS";
  v5[3] = +[NSNumber numberWithDouble:*(double *)(a1 + 64)];
  v4[4] = @"ConditionsPreventingSubmission";
  v5[4] = +[NSNumber numberWithUnsignedLongLong:*(void *)(a1 + 72)];
  void v4[5] = @"OtherConditions";
  void v5[5] = +[NSNumber numberWithUnsignedLongLong:*(void *)(a1 + 80)];
  return +[NSDictionary dictionaryWithObjects:v5 forKeys:v4 count:6];
}

void sub_10002F370(int a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, double a7, double a8)
{
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 3221225472;
  v8[2] = sub_10002F3FC;
  v8[3] = &unk_1000DCCB0;
  int v9 = a1;
  v8[4] = a6;
  v8[5] = a4;
  v8[6] = a5;
  *(double *)&v8[7] = a8;
  *(double *)&v8[8] = a7;
  sub_10002E718(a1, a2, a3, 3, 0, 0, 0, 0, a7, a8, (uint64_t)v8);
}

void sub_10002F3FC(uint64_t a1, os_log_t log, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  if (os_signpost_enabled(log))
  {
    int v12 = *(_DWORD *)(a1 + 72);
    uint64_t v13 = *(void *)(a1 + 40);
    unint64_t v14 = *(void *)(a1 + 32) / 0xF4240uLL;
    uint64_t v15 = *(void *)(a1 + 48);
    *(_DWORD *)buf = 138544898;
    uint64_t v18 = a4;
    __int16 v19 = 2050;
    uint64_t v20 = a5;
    __int16 v21 = 2050;
    uint64_t v22 = a3;
    __int16 v23 = 1026;
    int v24 = v12;
    __int16 v25 = 2050;
    unint64_t v26 = v14;
    __int16 v27 = 2050;
    uint64_t v28 = v13;
    __int16 v29 = 2050;
    uint64_t v30 = v15;
    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, log, OS_SIGNPOST_INTERVAL_BEGIN, 0xEEEEB0B5B2B2EEEELL, "DiskWritesResource", "BundleIdOverride=%{public, signpost.description:attribute}@ %{public, signpost.description:begin_time}llu cid=%{public,name=cid}llu pid=%{public,name=pid}u ioMB=%{public,name=ioMB}llu conditionsPreventingSubmission=%{public,name=conditionsPreventingSubmission}#llx otherConditions=%{public,name=otherConditions}#llx enableTelemetry=YES ", buf, 0x44u);
  }
  if (os_signpost_enabled(log))
  {
    *(_DWORD *)buf = 134349056;
    uint64_t v18 = a6;
    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, log, OS_SIGNPOST_INTERVAL_END, 0xEEEEB0B5B2B2EEEELL, "DiskWritesResource", "%{public, signpost.description:end_time}llu", buf, 0xCu);
  }
  if (&_AnalyticsIsEventUsed)
  {
    int IsEventUsed = AnalyticsIsEventUsed();
    if (a4)
    {
      if (IsEventUsed) {
        AnalyticsSendEventLazy();
      }
    }
  }
}

NSDictionary *sub_10002F60C(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 40);
  v5[0] = *(void *)(a1 + 32);
  v5[1] = +[NSString stringWithFormat:@"%llu", v2, @"BundleID", @"CoalitionID"];
  v4[2] = @"Duration";
  v5[2] = +[NSNumber numberWithDouble:*(double *)(a1 + 48) - *(double *)(a1 + 56)];
  v4[3] = @"Bytes";
  v5[3] = +[NSNumber numberWithUnsignedLongLong:*(void *)(a1 + 64)];
  v4[4] = @"ConditionsPreventingSubmission";
  v5[4] = +[NSNumber numberWithUnsignedLongLong:*(void *)(a1 + 72)];
  void v4[5] = @"OtherConditions";
  void v5[5] = +[NSNumber numberWithUnsignedLongLong:*(void *)(a1 + 80)];
  return +[NSDictionary dictionaryWithObjects:v5 forKeys:v4 count:6];
}

void sub_10002F728(int a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 3221225472;
  v7[2] = sub_10002F7B8;
  v7[3] = &unk_1000DCC48;
  int v8 = a1;
  v7[4] = a6;
  v7[5] = a7;
  void v7[6] = a4;
  v7[7] = a5;
  sub_10002E718(a1, a2, a3, 4, 0, 0, 0, 0, 0.0, 0.0, (uint64_t)v7);
}

void sub_10002F7B8(uint64_t a1, os_log_t log, uint64_t a3, uint64_t a4)
{
  if (os_signpost_enabled(log))
  {
    int v8 = *(_DWORD *)(a1 + 64);
    uint64_t v9 = *(void *)(a1 + 32);
    uint64_t v10 = *(void *)(a1 + 40);
    uint64_t v11 = *(void *)(a1 + 48);
    uint64_t v12 = *(void *)(a1 + 56);
    *(_DWORD *)buf = 138544898;
    uint64_t v15 = a4;
    __int16 v16 = 2050;
    uint64_t v17 = a3;
    __int16 v18 = 1026;
    int v19 = v8;
    __int16 v20 = 2050;
    uint64_t v21 = v9;
    __int16 v22 = 2050;
    uint64_t v23 = v10;
    __int16 v24 = 2050;
    uint64_t v25 = v11;
    __int16 v26 = 2050;
    uint64_t v27 = v12;
    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, log, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "FileDescriptorExhaustion", "BundleIdOverride=%{public, signpost.description:attribute}@ cid=%{public,name=cid}llu pid=%{public,name=pid}u numFDs=%{public,name=numFDs}llu numFDsLimit=%{public,name=numFDsLimit}llu conditionsPreventingSubmission=%{public,name=conditionsPreventingSubmission}#llx otherConditions=%{public,name=otherConditions}#llx enableTelemetry=YES ", buf, 0x44u);
  }
  if (&_AnalyticsIsEventUsed)
  {
    int IsEventUsed = AnalyticsIsEventUsed();
    if (a4)
    {
      if (IsEventUsed) {
        AnalyticsSendEventLazy();
      }
    }
  }
}

NSDictionary *sub_10002F93C(void *a1)
{
  uint64_t v2 = a1[5];
  v5[0] = a1[4];
  v5[1] = +[NSString stringWithFormat:@"%llu", v2, @"BundleID", @"CoalitionID"];
  v4[2] = @"NumFileDescriptors";
  v5[2] = +[NSNumber numberWithUnsignedLongLong:a1[6]];
  v4[3] = @"NumFileDescriptorsLimit";
  v5[3] = +[NSNumber numberWithUnsignedLongLong:a1[7]];
  v4[4] = @"ConditionsPreventingSubmission";
  v5[4] = +[NSNumber numberWithUnsignedLongLong:a1[8]];
  void v4[5] = @"OtherConditions";
  void v5[5] = +[NSNumber numberWithUnsignedLongLong:a1[9]];
  return +[NSDictionary dictionaryWithObjects:v5 forKeys:v4 count:6];
}

void sub_10002FA54(int a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 3221225472;
  v7[2] = sub_10002FAE4;
  v7[3] = &unk_1000DCC48;
  int v8 = a1;
  v7[4] = a6;
  v7[5] = a7;
  void v7[6] = a4;
  v7[7] = a5;
  sub_10002E718(a1, a2, a3, 5, 0, 0, 0, 0, 0.0, 0.0, (uint64_t)v7);
}

void sub_10002FAE4(uint64_t a1, os_log_t log, uint64_t a3, uint64_t a4)
{
  if (os_signpost_enabled(log))
  {
    int v8 = *(_DWORD *)(a1 + 64);
    uint64_t v9 = *(void *)(a1 + 32);
    uint64_t v10 = *(void *)(a1 + 40);
    uint64_t v11 = *(void *)(a1 + 48);
    uint64_t v12 = *(void *)(a1 + 56);
    *(_DWORD *)buf = 138544898;
    uint64_t v15 = a4;
    __int16 v16 = 2050;
    uint64_t v17 = a3;
    __int16 v18 = 1026;
    int v19 = v8;
    __int16 v20 = 2050;
    uint64_t v21 = v9;
    __int16 v22 = 2050;
    uint64_t v23 = v10;
    __int16 v24 = 2050;
    uint64_t v25 = v11;
    __int16 v26 = 2050;
    uint64_t v27 = v12;
    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, log, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "PortExhaustion", "BundleIdOverride=%{public, signpost.description:attribute}@ cid=%{public,name=cid}llu pid=%{public,name=pid}u numPorts=%{public,name=numPorts}llu numPortsLimit=%{public,name=numPortsLimit}llu conditionsPreventingSubmission=%{public,name=conditionsPreventingSubmission}#llx otherConditions=%{public,name=otherConditions}#llx enableTelemetry=YES ", buf, 0x44u);
  }
  if (&_AnalyticsIsEventUsed)
  {
    int IsEventUsed = AnalyticsIsEventUsed();
    if (a4)
    {
      if (IsEventUsed) {
        AnalyticsSendEventLazy();
      }
    }
  }
}

NSDictionary *sub_10002FC68(void *a1)
{
  uint64_t v2 = a1[5];
  v5[0] = a1[4];
  v5[1] = +[NSString stringWithFormat:@"%llu", v2, @"BundleID", @"CoalitionID"];
  v4[2] = @"NumPorts";
  v5[2] = +[NSNumber numberWithUnsignedLongLong:a1[6]];
  v4[3] = @"NumPortsLimit";
  v5[3] = +[NSNumber numberWithUnsignedLongLong:a1[7]];
  v4[4] = @"ConditionsPreventingSubmission";
  v5[4] = +[NSNumber numberWithUnsignedLongLong:a1[8]];
  void v4[5] = @"OtherConditions";
  void v5[5] = +[NSNumber numberWithUnsignedLongLong:a1[9]];
  return +[NSDictionary dictionaryWithObjects:v5 forKeys:v4 count:6];
}

void sub_10002FD80(int a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 3221225472;
  v7[2] = sub_10002FE10;
  v7[3] = &unk_1000DCC48;
  int v8 = a1;
  v7[4] = a6;
  v7[5] = a7;
  void v7[6] = a4;
  v7[7] = a5;
  sub_10002E718(a1, a2, a3, 6, 0, 0, 0, 0, 0.0, 0.0, (uint64_t)v7);
}

void sub_10002FE10(uint64_t a1, os_log_t log, uint64_t a3, uint64_t a4)
{
  if (os_signpost_enabled(log))
  {
    int v8 = *(_DWORD *)(a1 + 64);
    uint64_t v9 = *(void *)(a1 + 32);
    uint64_t v10 = *(void *)(a1 + 40);
    uint64_t v11 = *(void *)(a1 + 48);
    uint64_t v12 = *(void *)(a1 + 56);
    *(_DWORD *)buf = 138544898;
    uint64_t v15 = a4;
    __int16 v16 = 2050;
    uint64_t v17 = a3;
    __int16 v18 = 1026;
    int v19 = v8;
    __int16 v20 = 2050;
    uint64_t v21 = v9;
    __int16 v22 = 2050;
    uint64_t v23 = v10;
    __int16 v24 = 2050;
    uint64_t v25 = v11;
    __int16 v26 = 2050;
    uint64_t v27 = v12;
    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, log, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "KQWorkLoopExhaustion", "BundleIdOverride=%{public, signpost.description:attribute}@ cid=%{public,name=cid}llu pid=%{public,name=pid}u numKQWorkLoops=%{public,name=numKQWorkLoops}llu numKQWorkLoopsLimit=%{public,name=numKQWorkLoopsLimit}llu conditionsPreventingSubmission=%{public,name=conditionsPreventingSubmission}#llx otherConditions=%{public,name=otherConditions}#llx enableTelemetry=YES ", buf, 0x44u);
  }
  if (&_AnalyticsIsEventUsed)
  {
    int IsEventUsed = AnalyticsIsEventUsed();
    if (a4)
    {
      if (IsEventUsed) {
        AnalyticsSendEventLazy();
      }
    }
  }
}

NSDictionary *sub_10002FF94(void *a1)
{
  uint64_t v2 = a1[5];
  v5[0] = a1[4];
  v5[1] = +[NSString stringWithFormat:@"%llu", v2, @"BundleID", @"CoalitionID"];
  v4[2] = @"NumKQWorkLoops";
  v5[2] = +[NSNumber numberWithUnsignedLongLong:a1[6]];
  v4[3] = @"NumKQWorkLoopsLimit";
  v5[3] = +[NSNumber numberWithUnsignedLongLong:a1[7]];
  v4[4] = @"ConditionsPreventingSubmission";
  v5[4] = +[NSNumber numberWithUnsignedLongLong:a1[8]];
  void v4[5] = @"OtherConditions";
  void v5[5] = +[NSNumber numberWithUnsignedLongLong:a1[9]];
  return +[NSDictionary dictionaryWithObjects:v5 forKeys:v4 count:6];
}

void sub_1000300AC(int a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 3221225472;
  v7[2] = sub_10003013C;
  v7[3] = &unk_1000DCC48;
  int v8 = a1;
  v7[4] = a4;
  v7[5] = a5;
  void v7[6] = a7;
  v7[7] = a6;
  sub_10002E718(a1, a2, a3, 7, 0, 0, a6, a7, 0.0, 0.0, (uint64_t)v7);
}

void sub_10003013C(uint64_t a1, os_log_t log, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  if (os_signpost_enabled(log))
  {
    int v12 = *(_DWORD *)(a1 + 64);
    uint64_t v13 = *(void *)(a1 + 32);
    uint64_t v14 = *(void *)(a1 + 40);
    *(_DWORD *)buf = 138544642;
    uint64_t v17 = a4;
    __int16 v18 = 2050;
    uint64_t v19 = a5;
    __int16 v20 = 2050;
    uint64_t v21 = a3;
    __int16 v22 = 1026;
    int v23 = v12;
    __int16 v24 = 2050;
    uint64_t v25 = v13;
    __int16 v26 = 2050;
    uint64_t v27 = v14;
    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, log, OS_SIGNPOST_INTERVAL_BEGIN, 0xEEEEB0B5B2B2EEEELL, "StuckApp", "BundleIdOverride=%{public, signpost.description:attribute}@ %{public, signpost.description:begin_time}llu cid=%{public,name=cid}llu pid=%{public,name=pid}u conditionsPreventingSubmission=%{public,name=conditionsPreventingSubmission}#llx otherConditions=%{public,name=otherConditions}#llx enableTelemetry=YES ", buf, 0x3Au);
  }
  if (os_signpost_enabled(log))
  {
    *(_DWORD *)buf = 134349056;
    uint64_t v17 = a6;
    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, log, OS_SIGNPOST_INTERVAL_END, 0xEEEEB0B5B2B2EEEELL, "StuckApp", "%{public, signpost.description:end_time}llu", buf, 0xCu);
  }
  if (&_AnalyticsIsEventUsed)
  {
    int IsEventUsed = AnalyticsIsEventUsed();
    if (a4)
    {
      if (IsEventUsed) {
        AnalyticsSendEventLazy();
      }
    }
  }
}

NSDictionary *sub_100030314(void *a1)
{
  uint64_t v2 = a1[5];
  v5[0] = a1[4];
  v5[1] = +[NSString stringWithFormat:@"%llu", v2, @"BundleID", @"CoalitionID"];
  v4[2] = @"Duration";
  SASecondsFromMachTimeUsingLiveTimebase();
  v5[2] = +[NSNumber numberWithDouble:](NSNumber, "numberWithDouble:");
  v4[3] = @"ConditionsPreventingSubmission";
  v5[3] = +[NSNumber numberWithUnsignedLongLong:a1[8]];
  v4[4] = @"OtherConditions";
  v5[4] = +[NSNumber numberWithUnsignedLongLong:a1[9]];
  return +[NSDictionary dictionaryWithObjects:v5 forKeys:v4 count:5];
}

void sub_100030424(int a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 3221225472;
  v7[2] = sub_1000304B4;
  v7[3] = &unk_1000DCC48;
  int v8 = a1;
  v7[4] = a4;
  v7[5] = a5;
  void v7[6] = a7;
  v7[7] = a6;
  sub_10002E718(a1, a2, a3, 8, 0, 0, a6, a7, 0.0, 0.0, (uint64_t)v7);
}

void sub_1000304B4(uint64_t a1, os_log_t log, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  if (os_signpost_enabled(log))
  {
    int v12 = *(_DWORD *)(a1 + 64);
    uint64_t v13 = *(void *)(a1 + 32);
    uint64_t v14 = *(void *)(a1 + 40);
    *(_DWORD *)buf = 138544642;
    uint64_t v17 = a4;
    __int16 v18 = 2050;
    uint64_t v19 = a5;
    __int16 v20 = 2050;
    uint64_t v21 = a3;
    __int16 v22 = 1026;
    int v23 = v12;
    __int16 v24 = 2050;
    uint64_t v25 = v13;
    __int16 v26 = 2050;
    uint64_t v27 = v14;
    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, log, OS_SIGNPOST_INTERVAL_BEGIN, 0xEEEEB0B5B2B2EEEELL, "ServiceWatchdog", "BundleIdOverride=%{public, signpost.description:attribute}@ %{public, signpost.description:begin_time}llu cid=%{public,name=cid}llu pid=%{public,name=pid}u conditionsPreventingSubmission=%{public,name=conditionsPreventingSubmission}#llx otherConditions=%{public,name=otherConditions}#llx enableTelemetry=YES ", buf, 0x3Au);
  }
  if (os_signpost_enabled(log))
  {
    *(_DWORD *)buf = 134349056;
    uint64_t v17 = a6;
    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, log, OS_SIGNPOST_INTERVAL_END, 0xEEEEB0B5B2B2EEEELL, "ServiceWatchdog", "%{public, signpost.description:end_time}llu", buf, 0xCu);
  }
  if (&_AnalyticsIsEventUsed)
  {
    int IsEventUsed = AnalyticsIsEventUsed();
    if (a4)
    {
      if (IsEventUsed) {
        AnalyticsSendEventLazy();
      }
    }
  }
}

NSDictionary *sub_10003068C(void *a1)
{
  uint64_t v2 = a1[5];
  v5[0] = a1[4];
  v5[1] = +[NSString stringWithFormat:@"%llu", v2, @"BundleID", @"CoalitionID"];
  v4[2] = @"Duration";
  SASecondsFromMachTimeUsingLiveTimebase();
  v5[2] = +[NSNumber numberWithDouble:](NSNumber, "numberWithDouble:");
  v4[3] = @"ConditionsPreventingSubmission";
  v5[3] = +[NSNumber numberWithUnsignedLongLong:a1[8]];
  v4[4] = @"OtherConditions";
  v5[4] = +[NSNumber numberWithUnsignedLongLong:a1[9]];
  return +[NSDictionary dictionaryWithObjects:v5 forKeys:v4 count:5];
}

void sub_10003079C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = *(void *)(a1 + 32);
  if (v9
    && (id v10 = [objc_alloc((Class)NSURL) initFileURLWithPath:v9 isDirectory:0]) != 0)
  {
    uint64_t v11 = v10;
    int v12 = (__CFBundle *)_CFBundleCreateWithExecutableURLIfLooksLikeBundle();
    if (v12)
    {
      uint64_t v13 = v12;
      CFStringRef v79 = (id)CFBundleGetIdentifier(v12);
      CFRelease(v13);
    }
    else
    {
      CFStringRef v79 = 0;
    }

    CFStringRef v14 = v79;
  }
  else
  {
    CFStringRef v14 = 0;
  }
  uint64_t v16 = *(void *)(a1 + 72);
  uint64_t v15 = *(void *)(a1 + 80);
  if (v16) {
    BOOL v17 = v15 == 0;
  }
  else {
    BOOL v17 = 1;
  }
  double v80 = (__CFString *)v14;
  if (v17)
  {
    uint64_t v18 = *(void *)(a1 + 88);
    if (v18 && *(void *)(a1 + 96))
    {
      [*(id *)(a1 + 40) machContTime];
      [*(id *)(a1 + 40) machAbsTime];
    }
    else
    {
      double v19 = *(double *)(a1 + 104);
      if (v19 == 0.0 || *(double *)(a1 + 112) == 0.0)
      {
        if (v16 | v18 | v15
          || (v19 == 0.0 ? (BOOL v20 = *(void *)(a1 + 96) == 0) : (BOOL v20 = 0), !v20 || *(double *)(a1 + 112) != 0.0))
        {
          if ((*(_DWORD *)(a1 + 128) & 0x80000000) != 0)
          {
            if (byte_1000EBCF8)
            {
              int v45 = *__error();
              CFStringRef v46 = sub_10002E548();
              if (os_log_type_enabled(v46, OS_LOG_TYPE_ERROR))
              {
                uint64_t v47 = *(void *)(a1 + 72);
                uint64_t v48 = *(void *)(a1 + 80);
                uint64_t v49 = *(void *)(a1 + 88);
                uint64_t v50 = *(void *)(a1 + 96);
                uint64_t v51 = *(void *)(a1 + 104);
                uint64_t v52 = *(void *)(a1 + 112);
                *(_DWORD *)buf = 136316674;
                uint64_t v82 = "startTimeMachCont == 0 && endTimeMachCont == 0 && startTimeMachAbs == 0 && endTimeMachAbs == 0 && "
                      "startTimeCF == 0 && endTimeCF == 0";
                __int16 v83 = 2048;
                *(void *)double v84 = v47;
                *(_WORD *)&v84[8] = 2048;
                *(void *)&v84[10] = v48;
                *(_WORD *)&v84[18] = 2048;
                *(void *)&v84[20] = v49;
                *(_WORD *)&v84[28] = 2048;
                *(void *)&v84[30] = v50;
                *(_WORD *)&v84[38] = 2048;
                *(void *)&v84[40] = v51;
                *(_WORD *)&v84[48] = 2048;
                *(void *)&v84[50] = v52;
                _os_log_error_impl((void *)&_mh_execute_header, v46, OS_LOG_TYPE_ERROR, "%s: No matching timestamps provided: %llu-%llu, %llu-%llu, %.2f-%.2f", buf, 0x48u);
              }
              *__error() = v45;
            }
            if (byte_1000EBCF9) {
              BOOL v53 = dword_1000EB4A8 <= 3;
            }
            else {
              BOOL v53 = 0;
            }
            if (v53)
            {
              int v54 = *__error();
              CFStringRef v55 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%s: No matching timestamps provided: %llu-%llu, %llu-%llu, %.2f-%.2f", "startTimeMachCont == 0 && endTimeMachCont == 0 && startTimeMachAbs == 0 && endTimeMachAbs == 0 && startTimeCF == 0 && endTimeCF == 0", *(void *)(a1 + 72), *(void *)(a1 + 80), *(void *)(a1 + 88), *(void *)(a1 + 96), *(void *)(a1 + 104), *(void *)(a1 + 112));
              if (v55)
              {
                CFStringRef v68 = v55;
                CStringPtr = CFStringGetCStringPtr(v55, 0x8000100u);
                if (CStringPtr)
                {
                  unsigned int v70 = (char *)CStringPtr;
                  BOOL v71 = 0;
                }
                else
                {
                  unsigned int v70 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x6B85B7B6uLL);
                  CFStringGetCString(v68, v70, 1024, 0x8000100u);
                  BOOL v71 = v70;
                }
                if (qword_1000EBD00) {
                  malloc_type_id_t v78 = (FILE *)qword_1000EBD00;
                }
                else {
                  malloc_type_id_t v78 = __stderrp;
                }
                fprintf(v78, "%s\n", v70);
                if (v71) {
                  free(v71);
                }
                CFRelease(v68);
              }
              else
              {
                int v56 = sub_10002E548();
                if (os_log_type_enabled(v56, OS_LOG_TYPE_FAULT))
                {
                  uint64_t v57 = *(void *)(a1 + 72);
                  uint64_t v58 = *(void *)(a1 + 80);
                  uint64_t v59 = *(void *)(a1 + 88);
                  uint64_t v60 = *(void *)(a1 + 96);
                  uint64_t v61 = *(void *)(a1 + 104);
                  uint64_t v62 = *(void *)(a1 + 112);
                  *(_DWORD *)buf = 136316674;
                  uint64_t v82 = "startTimeMachCont == 0 && endTimeMachCont == 0 && startTimeMachAbs == 0 && endTimeMachAbs == 0 &"
                        "& startTimeCF == 0 && endTimeCF == 0";
                  __int16 v83 = 2048;
                  *(void *)double v84 = v57;
                  *(_WORD *)&v84[8] = 2048;
                  *(void *)&v84[10] = v58;
                  *(_WORD *)&v84[18] = 2048;
                  *(void *)&v84[20] = v59;
                  *(_WORD *)&v84[28] = 2048;
                  *(void *)&v84[30] = v60;
                  *(_WORD *)&v84[38] = 2048;
                  *(void *)&v84[40] = v61;
                  *(_WORD *)&v84[48] = 2048;
                  *(void *)&v84[50] = v62;
                  _os_log_fault_impl((void *)&_mh_execute_header, v56, OS_LOG_TYPE_FAULT, "Unable to format: %s: No matching timestamps provided: %llu-%llu, %llu-%llu, %.2f-%.2f", buf, 0x48u);
                }
                if (qword_1000EBD00) {
                  CFStringRef v63 = (FILE *)qword_1000EBD00;
                }
                else {
                  CFStringRef v63 = __stderrp;
                }
                fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v63);
              }
              *__error() = v54;
            }
            sub_10002E41C("_SPEventRateReportEvent_block_invoke", "SPEventRate.m", 339, "%s: No matching timestamps provided: %llu-%llu, %llu-%llu, %.2f-%.2f", a5, v15, a7, a8, (char)"startTimeMachCont == 0 && endTimeMachCont == 0 && startTimeMachAbs == 0 && endTimeMachAbs == 0 && startTimeCF == 0 && endTimeCF == 0");
          }
          else
          {
            if (byte_1000EBCF8)
            {
              int v21 = *__error();
              __int16 v22 = sub_10002E548();
              if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
              {
                int v23 = (const char *)sub_10002E4E8(*(_DWORD *)(a1 + 128));
                int v24 = *(_DWORD *)(a1 + 128);
                uint64_t v25 = *(void *)(a1 + 72);
                uint64_t v26 = *(void *)(a1 + 80);
                uint64_t v27 = *(void *)(a1 + 88);
                uint64_t v28 = *(void *)(a1 + 96);
                uint64_t v29 = *(void *)(a1 + 104);
                uint64_t v30 = *(void *)(a1 + 112);
                *(_DWORD *)buf = 136317186;
                uint64_t v82 = v23;
                __int16 v83 = 1024;
                *(_DWORD *)double v84 = v24;
                *(_WORD *)&v84[4] = 2080;
                *(void *)&v84[6] = "startTimeMachCont == 0 && endTimeMachCont == 0 && startTimeMachAbs == 0 && endTimeM"
                                     "achAbs == 0 && startTimeCF == 0 && endTimeCF == 0";
                *(_WORD *)&v84[14] = 2048;
                *(void *)&v84[16] = v25;
                *(_WORD *)&v84[24] = 2048;
                *(void *)&v84[26] = v26;
                *(_WORD *)&v84[34] = 2048;
                *(void *)&v84[36] = v27;
                *(_WORD *)&v84[44] = 2048;
                *(void *)&v84[46] = v28;
                *(_WORD *)&v84[54] = 2048;
                *(void *)&v84[56] = v29;
                __int16 v85 = 2048;
                uint64_t v86 = v30;
                _os_log_error_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_ERROR, "%s [%d]: %s: No matching timestamps provided: %llu-%llu, %llu-%llu, %.2f-%.2f", buf, 0x58u);
              }
              *__error() = v21;
            }
            if (byte_1000EBCF9) {
              BOOL v31 = dword_1000EB4A8 <= 3;
            }
            else {
              BOOL v31 = 0;
            }
            if (v31)
            {
              int v32 = *__error();
              uint64_t v33 = sub_10002E4E8(*(_DWORD *)(a1 + 128));
              CFStringRef v34 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%s [%d]: %s: No matching timestamps provided: %llu-%llu, %llu-%llu, %.2f-%.2f", v33, *(unsigned int *)(a1 + 128), "startTimeMachCont == 0 && endTimeMachCont == 0 && startTimeMachAbs == 0 && endTimeMachAbs == 0 && startTimeCF == 0 && endTimeCF == 0", *(void *)(a1 + 72), *(void *)(a1 + 80), *(void *)(a1 + 88), *(void *)(a1 + 96), *(void *)(a1 + 104), *(void *)(a1 + 112));
              if (v34)
              {
                CFStringRef v64 = v34;
                malloc_type_id_t v65 = CFStringGetCStringPtr(v34, 0x8000100u);
                if (v65)
                {
                  int v66 = (char *)v65;
                  int v67 = 0;
                }
                else
                {
                  int v66 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x6B85B7B6uLL);
                  CFStringGetCString(v64, v66, 1024, 0x8000100u);
                  int v67 = v66;
                }
                if (qword_1000EBD00) {
                  int v72 = (FILE *)qword_1000EBD00;
                }
                else {
                  int v72 = __stderrp;
                }
                fprintf(v72, "%s\n", v66);
                if (v67) {
                  free(v67);
                }
                CFRelease(v64);
              }
              else
              {
                uint64_t v35 = sub_10002E548();
                if (os_log_type_enabled(v35, OS_LOG_TYPE_FAULT))
                {
                  uint64_t v36 = (const char *)sub_10002E4E8(*(_DWORD *)(a1 + 128));
                  int v37 = *(_DWORD *)(a1 + 128);
                  uint64_t v38 = *(void *)(a1 + 72);
                  uint64_t v39 = *(void *)(a1 + 80);
                  uint64_t v40 = *(void *)(a1 + 88);
                  uint64_t v41 = *(void *)(a1 + 96);
                  uint64_t v42 = *(void *)(a1 + 104);
                  uint64_t v43 = *(void *)(a1 + 112);
                  *(_DWORD *)buf = 136317186;
                  uint64_t v82 = v36;
                  __int16 v83 = 1024;
                  *(_DWORD *)double v84 = v37;
                  *(_WORD *)&v84[4] = 2080;
                  *(void *)&v84[6] = "startTimeMachCont == 0 && endTimeMachCont == 0 && startTimeMachAbs == 0 && endTim"
                                       "eMachAbs == 0 && startTimeCF == 0 && endTimeCF == 0";
                  *(_WORD *)&v84[14] = 2048;
                  *(void *)&v84[16] = v38;
                  *(_WORD *)&v84[24] = 2048;
                  *(void *)&v84[26] = v39;
                  *(_WORD *)&v84[34] = 2048;
                  *(void *)&v84[36] = v40;
                  *(_WORD *)&v84[44] = 2048;
                  *(void *)&v84[46] = v41;
                  *(_WORD *)&v84[54] = 2048;
                  *(void *)&v84[56] = v42;
                  __int16 v85 = 2048;
                  uint64_t v86 = v43;
                  _os_log_fault_impl((void *)&_mh_execute_header, v35, OS_LOG_TYPE_FAULT, "Unable to format: %s [%d]: %s: No matching timestamps provided: %llu-%llu, %llu-%llu, %.2f-%.2f", buf, 0x58u);
                }
                if (qword_1000EBD00) {
                  BOOL v44 = (FILE *)qword_1000EBD00;
                }
                else {
                  BOOL v44 = __stderrp;
                }
                fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v44);
              }
              *__error() = v32;
            }
            char v73 = sub_10002E4E8(*(_DWORD *)(a1 + 128));
            sub_10002E41C("_SPEventRateReportEvent_block_invoke", "SPEventRate.m", 339, "%s [%d]: %s: No matching timestamps provided: %llu-%llu, %llu-%llu, %.2f-%.2f", v74, v75, v76, v77, v73);
          }
          abort();
        }
      }
      else
      {
        [*(id *)(a1 + 40) machContTime];
        [*(id *)(a1 + 40) wallTime];
        SAMachTimeFromSecondsUsingLiveTimebase();
        [*(id *)(a1 + 40) machContTime];
        [*(id *)(a1 + 40) wallTime];
        SAMachTimeFromSecondsUsingLiveTimebase();
      }
    }
  }
  (*(void (**)(void))(*(void *)(a1 + 64) + 16))();
}

void sub_100030F84(id a1)
{
  qword_1000EBB30 = (uint64_t)os_log_create("com.apple.spindump", "SpinTelemetry");
  qword_1000EBB38 = (uint64_t)os_log_create("com.apple.spindump", "HangTelemetry");
  qword_1000EBB40 = (uint64_t)os_log_create("com.apple.spindump", "CPUResourceTelemetry");
  qword_1000EBB48 = (uint64_t)os_log_create("com.apple.spindump", "DiskWritesResourceTelemetry");
  qword_1000EBB50 = (uint64_t)os_log_create("com.apple.spindump", "FileDescriptorExhaustion");
  qword_1000EBB58 = (uint64_t)os_log_create("com.apple.spindump", "PortExhaustion");
  qword_1000EBB60 = (uint64_t)os_log_create("com.apple.spindump", "KQWorkLoopExhaustion");
  qword_1000EBB68 = (uint64_t)os_log_create("com.apple.spindump", "StuckApp");
  qword_1000EBB70 = (uint64_t)os_log_create("com.apple.spindump", "ServiceWatchdog");
}

void sub_100031080(id a1)
{
  size_t v1 = dispatch_queue_attr_make_with_autorelease_frequency(0, DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM);
  uint64_t v2 = dispatch_queue_attr_make_with_qos_class(v1, QOS_CLASS_BACKGROUND, 0);
  qword_1000EBB80 = (uint64_t)dispatch_queue_create("com.apple.spindump.eventrate", v2);
  dispatch_release(v2);

  dispatch_release(v1);
}

void sub_100031520(const char *a1)
{
  uint64_t v3 = strdup(a1);
  int v4 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xA21A560AuLL);
  basename_r(v3, v4);
  uint64_t v5 = sub_10002E390("WR for %s", v4);
  free(v4);
  if (qword_1000EBB98 != -1) {
    dispatch_once(&qword_1000EBB98, &stru_1000DCE60);
  }
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_10003162C;
  block[3] = &unk_1000DCE40;
  block[4] = v5;
  void block[5] = v3;
  dispatch_async((dispatch_queue_t)qword_1000EBB90, block);
}

void sub_10003162C(uint64_t a1)
{
  id v2 = objc_alloc_init((Class)NSUUID);
  if (!objc_opt_class())
  {
    if (byte_1000EBCF8)
    {
      int v12 = *__error();
      uint64_t v13 = sub_10002E548();
      if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR)) {
        sub_100082CA0();
      }
      *__error() = v12;
    }
    if (byte_1000EBCF9) {
      BOOL v14 = dword_1000EB4A8 <= 3;
    }
    else {
      BOOL v14 = 0;
    }
    if (v14)
    {
      int v15 = *__error();
      CFStringRef v16 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"WR: WorkflowResponsivness unavailable, not generating spindump report(s) for %s", *(void *)(a1 + 40));
      CFStringRef v17 = v16;
      if (v16)
      {
        CStringPtr = (char *)CFStringGetCStringPtr(v16, 0x8000100u);
        if (CStringPtr)
        {
          double v19 = 0;
        }
        else
        {
          CStringPtr = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x248574ACuLL);
          CFStringGetCString(v17, CStringPtr, 1024, 0x8000100u);
          double v19 = CStringPtr;
        }
        if (qword_1000EBD00) {
          CFStringRef v68 = (FILE *)qword_1000EBD00;
        }
        else {
          CFStringRef v68 = __stderrp;
        }
        fprintf(v68, "%s\n", CStringPtr);
        if (v19) {
          free(v19);
        }
        CFRelease(v17);
      }
      else
      {
        uint64_t v29 = sub_10002E548();
        if (os_log_type_enabled(v29, OS_LOG_TYPE_FAULT)) {
          sub_100082C38();
        }
        if (qword_1000EBD00) {
          uint64_t v30 = (FILE *)qword_1000EBD00;
        }
        else {
          uint64_t v30 = __stderrp;
        }
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v30);
      }
      *__error() = v15;
    }

    unsigned int v69 = *(void **)(a1 + 40);
    goto LABEL_188;
  }
  v493 = v2;
  uint64_t v564 = 0;
  uint64_t v499 = a1;
  v494 = (void **)(a1 + 40);
  id v3 = [objc_alloc((Class)WRWorkflowEventTracker) initWithTailspin:+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", *(void *)(a1 + 40)) error:&v564];
  v525 = v3;
  if (!v3)
  {
    if (byte_1000EBCF8)
    {
      int v20 = *__error();
      int v21 = sub_10002E548();
      if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR)) {
        sub_100082D74();
      }
      *__error() = v20;
    }
    if (byte_1000EBCF9 && dword_1000EB4A8 <= 3)
    {
      int v22 = *__error();
      CFStringRef v23 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"WR: Unable to decode workflow event tracker: %@", v564);
      CFStringRef v24 = v23;
      if (v23)
      {
        uint64_t v25 = (char *)CFStringGetCStringPtr(v23, 0x8000100u);
        if (v25)
        {
          uint64_t v26 = 0;
        }
        else
        {
          uint64_t v25 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x3CD3BE78uLL);
          CFStringGetCString(v24, v25, 1024, 0x8000100u);
          uint64_t v26 = v25;
        }
        if (qword_1000EBD00) {
          CFStringRef v79 = (FILE *)qword_1000EBD00;
        }
        else {
          CFStringRef v79 = __stderrp;
        }
        fprintf(v79, "%s\n", v25);
        if (v26) {
          free(v26);
        }
        CFRelease(v24);
      }
      else
      {
        unsigned int v70 = sub_10002E548();
        if (os_log_type_enabled(v70, OS_LOG_TYPE_FAULT)) {
          sub_100082D0C();
        }
        if (qword_1000EBD00) {
          BOOL v71 = (FILE *)qword_1000EBD00;
        }
        else {
          BOOL v71 = __stderrp;
        }
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v71);
      }
      *__error() = v22;
    }
    goto LABEL_187;
  }
  id v495 = [[[v3 workflow] name];
  if (byte_1000EBCF8)
  {
    int v4 = *__error();
    uint64_t v5 = sub_10002E548();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      int v6 = *v494;
      *(_DWORD *)buf = 138412546;
      id v605 = v495;
      __int16 v606 = 2080;
      id v607 = v6;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "WR: %@: Received tailspin path %s", buf, 0x16u);
    }
    *__error() = v4;
  }
  if (byte_1000EBCF9 && dword_1000EB4A8 <= 2)
  {
    int v7 = *__error();
    CFStringRef v8 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"WR: %@: Received tailspin path %s", v495, *v494);
    CFStringRef v9 = v8;
    if (v8)
    {
      id v10 = (char *)CFStringGetCStringPtr(v8, 0x8000100u);
      if (v10)
      {
        uint64_t v11 = 0;
      }
      else
      {
        id v10 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x50D503B8uLL);
        CFStringGetCString(v9, v10, 1024, 0x8000100u);
        uint64_t v11 = v10;
      }
      if (qword_1000EBD00) {
        BOOL v31 = (FILE *)qword_1000EBD00;
      }
      else {
        BOOL v31 = __stderrp;
      }
      fprintf(v31, "%s\n", v10);
      if (v11) {
        free(v11);
      }
      CFRelease(v9);
    }
    else
    {
      uint64_t v27 = sub_10002E548();
      if (os_log_type_enabled(v27, OS_LOG_TYPE_FAULT)) {
        sub_100083A7C();
      }
      if (qword_1000EBD00) {
        uint64_t v28 = (FILE *)qword_1000EBD00;
      }
      else {
        uint64_t v28 = __stderrp;
      }
      fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v28);
    }
    *__error() = v7;
  }
  id v32 = [v525 eventStart];
  if (!v32)
  {
    if (byte_1000EBCF8)
    {
      int v47 = *__error();
      uint64_t v48 = sub_10002E548();
      if (os_log_type_enabled(v48, OS_LOG_TYPE_ERROR)) {
        sub_100082E44();
      }
      *__error() = v47;
    }
    if (byte_1000EBCF9 && dword_1000EB4A8 <= 3)
    {
      int v49 = *__error();
      CFStringRef v50 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"WR: %@: No workflow event start", v495);
      CFStringRef v51 = v50;
      if (v50)
      {
        uint64_t v52 = (char *)CFStringGetCStringPtr(v50, 0x8000100u);
        if (v52)
        {
          BOOL v53 = 0;
        }
        else
        {
          uint64_t v52 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xC01D22FAuLL);
          CFStringGetCString(v51, v52, 1024, 0x8000100u);
          BOOL v53 = v52;
        }
        if (qword_1000EBD00) {
          uint64_t v82 = (FILE *)qword_1000EBD00;
        }
        else {
          uint64_t v82 = __stderrp;
        }
        fprintf(v82, "%s\n", v52);
        if (v53) {
          free(v53);
        }
        CFRelease(v51);
      }
      else
      {
        double v80 = sub_10002E548();
        if (os_log_type_enabled(v80, OS_LOG_TYPE_FAULT)) {
          sub_100082DDC();
        }
        if (qword_1000EBD00) {
          int v81 = (FILE *)qword_1000EBD00;
        }
        else {
          int v81 = __stderrp;
        }
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v81);
      }
      *__error() = v49;
    }
    goto LABEL_187;
  }
  id v33 = [v525 eventEnd];
  if (!v33)
  {
    if (byte_1000EBCF8)
    {
      int v54 = *__error();
      CFStringRef v55 = sub_10002E548();
      if (os_log_type_enabled(v55, OS_LOG_TYPE_ERROR)) {
        sub_100082F14();
      }
      *__error() = v54;
    }
    if (byte_1000EBCF9 && dword_1000EB4A8 <= 3)
    {
      int v56 = *__error();
      CFStringRef v57 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"WR: %@: No workflow event end", v495);
      CFStringRef v58 = v57;
      if (v57)
      {
        uint64_t v59 = (char *)CFStringGetCStringPtr(v57, 0x8000100u);
        if (v59)
        {
          uint64_t v60 = 0;
        }
        else
        {
          uint64_t v59 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x7704C0F4uLL);
          CFStringGetCString(v58, v59, 1024, 0x8000100u);
          uint64_t v60 = v59;
        }
        if (qword_1000EBD00) {
          CFStringRef v87 = (FILE *)qword_1000EBD00;
        }
        else {
          CFStringRef v87 = __stderrp;
        }
        fprintf(v87, "%s\n", v59);
        if (v60) {
          free(v60);
        }
        CFRelease(v58);
      }
      else
      {
        __int16 v83 = sub_10002E548();
        if (os_log_type_enabled(v83, OS_LOG_TYPE_FAULT)) {
          sub_100082EAC();
        }
        if (qword_1000EBD00) {
          double v84 = (FILE *)qword_1000EBD00;
        }
        else {
          double v84 = __stderrp;
        }
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v84);
      }
      *__error() = v56;
    }
    goto LABEL_187;
  }
  CFStringRef v34 = [v33 machContTimeNs];
  uint64_t v35 = v34 - (unsigned char *)[v32 machContTimeNs];
  double v36 = (double)v35 / 1000000000.0;
  if (v36 <= 0.0)
  {
    if (byte_1000EBCF8)
    {
      int v61 = *__error();
      uint64_t v62 = sub_10002E548();
      if (os_log_type_enabled(v62, OS_LOG_TYPE_ERROR)) {
        sub_100083A08();
      }
      *__error() = v61;
    }
    if (byte_1000EBCF9 && dword_1000EB4A8 <= 3)
    {
      int v63 = *__error();
      CFStringRef v64 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"WR: %@: Workflow event has invalid duration %.3f", v495, *(void *)&v36);
      CFStringRef v65 = v64;
      if (v64)
      {
        int v66 = (char *)CFStringGetCStringPtr(v64, 0x8000100u);
        if (v66)
        {
          int v67 = 0;
        }
        else
        {
          int v66 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xB6FBD131uLL);
          CFStringGetCString(v65, v66, 1024, 0x8000100u);
          int v67 = v66;
        }
        if (qword_1000EBD00) {
          CFStringRef v88 = (FILE *)qword_1000EBD00;
        }
        else {
          CFStringRef v88 = __stderrp;
        }
        fprintf(v88, "%s\n", v66);
        if (v67) {
          free(v67);
        }
        CFRelease(v65);
      }
      else
      {
        __int16 v85 = sub_10002E548();
        if (os_log_type_enabled(v85, OS_LOG_TYPE_FAULT)) {
          sub_10008399C();
        }
        if (qword_1000EBD00) {
          uint64_t v86 = (FILE *)qword_1000EBD00;
        }
        else {
          uint64_t v86 = __stderrp;
        }
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v86);
      }
      *__error() = v63;
    }
LABEL_187:

    unsigned int v69 = *(void **)(v499 + 40);
LABEL_188:
    free(v69);
    return;
  }
  id v37 = [v525 error];
  uint64_t v38 = v37;
  if (v37)
  {
    id v39 = [v37 domain];
    if ([v39 isEqualToString:WRErrorDomain] && objc_msgSend(v38, "code") == (id)4)
    {
      if (byte_1000EBCF8)
      {
        int v40 = *__error();
        uint64_t v41 = sub_10002E548();
        if (os_log_type_enabled(v41, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 138412546;
          id v605 = v495;
          __int16 v606 = 2112;
          id v607 = v38;
          _os_log_impl((void *)&_mh_execute_header, v41, OS_LOG_TYPE_DEFAULT, "WR: %@: Workflow event has error %@, still considering for diagnostics", buf, 0x16u);
        }
        *__error() = v40;
      }
      if (byte_1000EBCF9 && dword_1000EB4A8 <= 2)
      {
        int v42 = *__error();
        CFStringRef v43 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"WR: %@: Workflow event has error %@, still considering for diagnostics", v495, v38);
        CFStringRef v44 = v43;
        if (v43)
        {
          int v45 = (char *)CFStringGetCStringPtr(v43, 0x8000100u);
          if (v45)
          {
            CFStringRef v46 = 0;
          }
          else
          {
            int v45 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x9807387BuLL);
            CFStringGetCString(v44, v45, 1024, 0x8000100u);
            CFStringRef v46 = v45;
          }
          if (qword_1000EBD00) {
            CFStringRef v94 = (FILE *)qword_1000EBD00;
          }
          else {
            CFStringRef v94 = __stderrp;
          }
          fprintf(v94, "%s\n", v45);
          if (v46) {
            free(v46);
          }
          CFRelease(v44);
        }
        else
        {
          int v92 = sub_10002E548();
          if (os_log_type_enabled(v92, OS_LOG_TYPE_FAULT)) {
            sub_1000838BC();
          }
          if (qword_1000EBD00) {
            CFStringRef v93 = (FILE *)qword_1000EBD00;
          }
          else {
            CFStringRef v93 = __stderrp;
          }
          fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v93);
        }
        *__error() = v42;
      }
      goto LABEL_203;
    }
    if (byte_1000EBCF8)
    {
      int v72 = *__error();
      char v73 = sub_10002E548();
      if (os_log_type_enabled(v73, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 138412546;
        id v605 = v495;
        __int16 v606 = 2112;
        id v607 = v38;
        _os_log_impl((void *)&_mh_execute_header, v73, OS_LOG_TYPE_DEFAULT, "WR: %@: Workflow event has error %@, not considering for diagnostics", buf, 0x16u);
      }
      *__error() = v72;
    }
    if (byte_1000EBCF9 && dword_1000EB4A8 <= 2)
    {
      int v74 = *__error();
      CFStringRef v75 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"WR: %@: Workflow event has error %@, not considering for diagnostics", v495, v38);
      CFStringRef v76 = v75;
      if (v75)
      {
        uint64_t v77 = (char *)CFStringGetCStringPtr(v75, 0x8000100u);
        if (v77)
        {
          malloc_type_id_t v78 = 0;
        }
        else
        {
          uint64_t v77 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x1C15E2B5uLL);
          CFStringGetCString(v76, v77, 1024, 0x8000100u);
          malloc_type_id_t v78 = v77;
        }
        if (qword_1000EBD00) {
          int v91 = (FILE *)qword_1000EBD00;
        }
        else {
          int v91 = __stderrp;
        }
        fprintf(v91, "%s\n", v77);
        if (v78) {
          free(v78);
        }
        CFRelease(v76);
      }
      else
      {
        int v89 = sub_10002E548();
        if (os_log_type_enabled(v89, OS_LOG_TYPE_FAULT)) {
          sub_10008392C();
        }
        if (qword_1000EBD00) {
          uint64_t v90 = (FILE *)qword_1000EBD00;
        }
        else {
          uint64_t v90 = __stderrp;
        }
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v90);
      }
      *__error() = v74;
    }
    goto LABEL_187;
  }
LABEL_203:
  v562[0] = 0;
  v562[1] = v562;
  v562[2] = 0x2020000000;
  char v563 = 0;
  uint64_t v556 = 0;
  v557 = &v556;
  uint64_t v558 = 0x3052000000;
  v559 = sub_100036E28;
  v560 = sub_100036E38;
  uint64_t v561 = 0;
  uint64_t v550 = 0;
  v551 = &v550;
  uint64_t v552 = 0x3052000000;
  v553 = sub_100036E28;
  v554 = sub_100036E38;
  uint64_t v555 = 0;
  v543[0] = _NSConcreteStackBlock;
  v543[1] = 3221225472;
  v544 = sub_100036E44;
  v545 = &unk_1000DCDC8;
  unsigned int v95 = *v494;
  v548 = &v556;
  v549 = v95;
  v547 = v562;
  id v546 = v495;
  v538[0] = _NSConcreteStackBlock;
  v538[1] = 3221225472;
  v539 = sub_100037484;
  v540 = &unk_1000DCDF0;
  v541 = &v550;
  v542 = &v556;
  uint64_t v564 = 0;
  id v487 = [v525 encodedStringWithError:&v564];
  if (!v487)
  {
    int v400 = *__error();
    v401 = sub_10002E548();
    if (os_log_type_enabled(v401, OS_LOG_TYPE_FAULT)) {
      sub_100083854();
    }
    *__error() = v400;
    if (byte_1000EBCF9 && dword_1000EB4A8 <= 4)
    {
      int v402 = *__error();
      CFStringRef v403 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"Unable to encode workflow event tracked into a string: %@", v564);
      CFStringRef v404 = v403;
      if (v403)
      {
        __int16 v405 = (char *)CFStringGetCStringPtr(v403, 0x8000100u);
        if (v405)
        {
          v406 = 0;
        }
        else
        {
          __int16 v405 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xC0A1F5DDuLL);
          CFStringGetCString(v404, v405, 1024, 0x8000100u);
          v406 = v405;
        }
        if (qword_1000EBD00) {
          v457 = (FILE *)qword_1000EBD00;
        }
        else {
          v457 = __stderrp;
        }
        fprintf(v457, "%s\n", v405);
        if (v406) {
          free(v406);
        }
        CFRelease(v404);
      }
      else
      {
        v455 = sub_10002E548();
        if (os_log_type_enabled(v455, OS_LOG_TYPE_FAULT)) {
          sub_1000837EC();
        }
        if (qword_1000EBD00) {
          v456 = (FILE *)qword_1000EBD00;
        }
        else {
          v456 = __stderrp;
        }
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v456);
      }
      *__error() = v402;
    }
  }
  id v524 = objc_alloc_init((Class)NSMutableArray);
  id v480 = objc_alloc_init((Class)NSMutableArray);
  id v482 = objc_alloc_init((Class)NSMutableDictionary);
  unint64_t v536 = 0;
  unint64_t v535 = 0;
  uint64_t v537 = 0;
  [v525 stats];
  long long v582 = 0u;
  long long v583 = 0u;
  long long v584 = 0u;
  long long v585 = 0u;
  id v96 = [objc_msgSend(v525, "workflow") workflowDiagnostics];
  id v97 = [v96 countByEnumeratingWithState:&v582 objects:buf count:16];
  if (!v97) {
    goto LABEL_293;
  }
  id obj = v96;
  uint64_t v483 = v35;
  char v98 = 0;
  CFAllocatorRef v492 = *(CFAllocatorRef *)v583;
  uint64_t v488 = WRErrorDomain;
  while (2)
  {
    for (i = 0; i != v97; i = (char *)i + 1)
    {
      if (*(CFAllocatorRef *)v583 != v492) {
        objc_enumerationMutation(obj);
      }
      v521 = *(void **)(*((void *)&v582 + 1) + 8 * i);
      v518 = [[SPWRReportReason alloc] initWithWorkflowTracker:v525 signpostTracker:0 diagnostic:v521];
      if (![v521 hasTriggerThresholdDurationSingle]) {
        goto LABEL_213;
      }
      double v99 = (double)0;
      if (([v521 reportOmittingNetworkBoundIntervals] & 1) == 0)
      {
        id v100 = [objc_msgSend(v525, "eventEnd") machContTimeNs];
        double v99 = (double)(unint64_t)v100
            - (double)(unint64_t)[v525 eventStart].machContTimeNs;
      }
      [v521 triggerThresholdDurationSingle];
      double v101 = v99 / 1000000000.0;
      if (v102 <= v101)
      {
        if ([v521 reportOmittingNetworkBoundIntervals]) {
          [(SPWRReportReason *)v518 setWorkflowDurationOmittingNetworkBoundIntervals:v101];
        }
        else {
          [(SPWRReportReason *)v518 setWorkflowDuration:v101];
        }
        int v103 = 1;
      }
      else
      {
LABEL_213:
        int v103 = 0;
      }
      if ([v521 triggerEventTimeout]
        && (id v104 = [v525 error],
            objc_msgSend(objc_msgSend(v104, "domain"), "isEqualToString:", v488))
        && [v104 code] == (id)4)
      {
        [(SPWRReportReason *)v518 setWorkflowEventTimedOut:1];
      }
      else if (!v103)
      {
        goto LABEL_287;
      }
      if ([v521 hasAnySpindumpReports])
      {
        v515 = (void *)v544(v543);
        if (!v515)
        {

          uint64_t v35 = v483;
LABEL_292:
          [v480 addObject:@"overall"];
          goto LABEL_293;
        }
        int v105 = (void *)((uint64_t (*)(void *))v539)(v538);
        id v106 = [v521 reportProcessesWithName];
        if (v106)
        {
          id v512 = objc_alloc_init((Class)NSMutableArray);
          *(void *)&long long v565 = _NSConcreteStackBlock;
          *((void *)&v565 + 1) = 3221225472;
          *(void *)&long long v566 = sub_100037D4C;
          *((void *)&v566 + 1) = &unk_1000DCE88;
          *(void *)&long long v567 = v106;
          *((void *)&v567 + 1) = v512;
          [v515 enumerateTasks:&v565];
        }
        else
        {
          id v512 = 0;
        }
        id v107 = [v521 reportOtherSignpostWithName];
        if (v107)
        {
          id v108 = [[objc_msgSend(v525, "allSignpostTrackers") mutableCopy];
          if ([v108 count])
          {
            unint64_t v109 = 0;
            do
            {
              if ([[[v108 objectAtIndexedSubscript:v109] signpost] name] isEqualToString:v107)v109--;
              ++v109;
              }
            }
            while (v109 < (unint64_t)[v108 count]);
          }
          long long v580 = 0u;
          long long v579 = 0u;
          long long v578 = 0u;
          long long v577 = 0u;
          id v110 = [v108 countByEnumeratingWithState:&v577 objects:v599 count:16];
          if (v110)
          {
            id v502 = v97;
            CFAllocatorRef v504 = *(CFAllocatorRef *)v578;
            id v500 = v108;
            do
            {
              id v506 = v110;
              for (j = 0; j != v506; j = (char *)j + 1)
              {
                if (*(CFAllocatorRef *)v578 != v504) {
                  objc_enumerationMutation(v108);
                }
                CFStringRef v111 = *(void **)(*((void *)&v577 + 1) + 8 * (void)j);
                id v112 = [v111 intervals];
                id v113 = [v111 incompleteIntervalStarts];
                id v114 = [v112 count];
                if ((char *)[v113 count] + (void)v114)
                {
                  long long v576 = 0u;
                  long long v575 = 0u;
                  long long v574 = 0u;
                  *(_OWORD *)v573 = 0u;
                  id v123 = [v111 intervals];
                  id v124 = [v123 countByEnumeratingWithState:v573 objects:v590 count:16];
                  if (v124)
                  {
                    uint64_t v125 = *(void *)v574;
                    do
                    {
                      for (k = 0; k != v124; k = (char *)k + 1)
                      {
                        if (*(void *)v574 != v125) {
                          objc_enumerationMutation(v123);
                        }
                        sub_100037DA8(v524, (uint64_t)v518, v515, v525, 0, v521, (uint64_t)v111, v512, v105, (uint64_t)objc_msgSend(objc_msgSend(*(id *)(*(void *)&v573[8] + 8 * (void)k), "start"), "threadID"), (uint64_t)objc_msgSend(objc_msgSend(*(id *)(*(void *)&v573[8] + 8 * (void)k), "end"), "threadID"), (unint64_t)objc_msgSend(objc_msgSend(*(id *)(*(void *)&v573[8] + 8 * (void)k), "start"), "machContTimeNs"), (unint64_t)objc_msgSend(
                                              [*(id *)(*(void *)&v573[8] + 8 * (void)k) end],
                                              "machContTimeNs"));
                      }
                      id v124 = [v123 countByEnumeratingWithState:v573 objects:v590 count:16];
                    }
                    while (v124);
                  }
                  long long v572 = 0u;
                  long long v570 = 0u;
                  long long v571 = 0u;
                  *(_OWORD *)v569 = 0u;
                  id v97 = v502;
                  id v108 = v500;
                  id v127 = [v111 incompleteIntervalStarts];
                  id v128 = [v127 countByEnumeratingWithState:v569 objects:v589 count:16];
                  if (v128)
                  {
                    uint64_t v129 = *(void *)v570;
                    do
                    {
                      for (m = 0; m != v128; m = (char *)m + 1)
                      {
                        if (*(void *)v570 != v129) {
                          objc_enumerationMutation(v127);
                        }
                        sub_100037DA8(v524, (uint64_t)v518, v515, v525, 0, v521, (uint64_t)v111, v512, v105, (uint64_t)[*(id *)(*(void *)&v569[8] + 8 * (void)m) threadID], 0, (unint64_t)[*(id *)(*(void *)&v569[8] + 8 * (void)m) threadID], (unint64_t)[objc_msgSend(objc_msgSend(v525, "eventEnd"), "machContTimeNs")]);
                      }
                      id v128 = [v127 countByEnumeratingWithState:v569 objects:v589 count:16];
                    }
                    while (v128);
                  }
                }
                else
                {
                  if (byte_1000EBCF8)
                  {
                    int v115 = *__error();
                    uint64_t v116 = sub_10002E548();
                    if (os_log_type_enabled(v116, OS_LOG_TYPE_ERROR))
                    {
                      id v134 = [[[v525 workflow] name];
                      id v135 = [objc_msgSend(v111, "signpost") name];
                      id v136 = [v521 name];
                      *(_DWORD *)v600 = 138412802;
                      *(void *)&v600[4] = v134;
                      *(_WORD *)&v600[12] = 2112;
                      *(void *)&v600[14] = v135;
                      *(_WORD *)&v600[22] = 2112;
                      v601 = v136;
                      _os_log_error_impl((void *)&_mh_execute_header, v116, OS_LOG_TYPE_ERROR, "WR: %@: %@: diagnostic %@: Reporting spindump for this signpost due to overall workflow, but no intervals to report", v600, 0x20u);
                    }
                    *__error() = v115;
                  }
                  if (byte_1000EBCF9) {
                    BOOL v117 = dword_1000EB4A8 <= 3;
                  }
                  else {
                    BOOL v117 = 0;
                  }
                  if (v117)
                  {
                    int v118 = *__error();
                    CFStringRef v119 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"WR: %@: %@: diagnostic %@: Reporting spindump for this signpost due to overall workflow, but no intervals to report", [objc_msgSend(objc_msgSend(v525, "workflow"), "name")], [objc_msgSend(objc_msgSend(v111, "signpost"), "name")], [objc_msgSend(v521, "name")]);
                    CFStringRef v120 = v119;
                    if (v119)
                    {
                      BOOL v121 = (char *)CFStringGetCStringPtr(v119, 0x8000100u);
                      if (v121)
                      {
                        int v122 = 0;
                      }
                      else
                      {
                        BOOL v121 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x6CD67639uLL);
                        CFStringGetCString(v120, v121, 1024, 0x8000100u);
                        int v122 = v121;
                      }
                      if (qword_1000EBD00) {
                        uint64_t v133 = (FILE *)qword_1000EBD00;
                      }
                      else {
                        uint64_t v133 = __stderrp;
                      }
                      fprintf(v133, "%s\n", v121);
                      if (v122) {
                        free(v122);
                      }
                      CFRelease(v120);
                    }
                    else
                    {
                      unsigned int v131 = sub_10002E548();
                      if (os_log_type_enabled(v131, OS_LOG_TYPE_FAULT))
                      {
                        id v137 = [[[v525 workflow] name];
                        id v138 = [objc_msgSend(v111, "signpost") name];
                        id v139 = [v521 name];
                        *(_DWORD *)v600 = 138412802;
                        *(void *)&v600[4] = v137;
                        *(_WORD *)&v600[12] = 2112;
                        *(void *)&v600[14] = v138;
                        *(_WORD *)&v600[22] = 2112;
                        v601 = v139;
                        _os_log_fault_impl((void *)&_mh_execute_header, v131, OS_LOG_TYPE_FAULT, "Unable to format: WR: %@: %@: diagnostic %@: Reporting spindump for this signpost due to overall workflow, but no intervals to report", v600, 0x20u);
                      }
                      if (qword_1000EBD00) {
                        unsigned int v132 = (FILE *)qword_1000EBD00;
                      }
                      else {
                        unsigned int v132 = __stderrp;
                      }
                      fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v132);
                    }
                    *__error() = v118;
                  }
                }
              }
              id v110 = [v108 countByEnumeratingWithState:&v577 objects:v599 count:16];
            }
            while (v110);
          }
        }
        else
        {
          sub_100037DA8(v524, (uint64_t)v518, v515, v525, 0, v521, 0, v512, v105, (uint64_t)[objc_msgSend(objc_msgSend(v525, "eventStart"), "threadID")], (uint64_t)[objc_msgSend(objc_msgSend(v525, "eventEnd"), "threadID")], (unint64_t)[objc_msgSend(objc_msgSend(v525, "eventStart"), "machContTimeNs")], (unint64_t)[objc_msgSend(objc_msgSend(v525, "eventEnd"), "machContTimeNs")]);
        }
      }
      char v98 = 1;
LABEL_287:
    }
    id v97 = [obj countByEnumeratingWithState:&v582 objects:buf count:16];
    if (v97) {
      continue;
    }
    break;
  }
  uint64_t v35 = v483;
  if (v98) {
    goto LABEL_292;
  }
LABEL_293:
  id v140 = objc_alloc_init((Class)NSMutableDictionary);
  if (v536 != v35) {
    [v140 setObject:+[NSNumber numberWithDouble:](NSNumber, "numberWithDouble:", (double)v536 / 1000000000.0) forKeyedSubscript:@"nonNetworkS"];
  }
  if (v537) {
    [v140 setObject:+[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:") forKeyedSubscript:@"numIncomplete"];
  }
  if (v535) {
    [v140 setObject:[+[NSNumber numberWithDouble:](NSNumber, "numberWithDouble:", (double)v535 / 1000000000.0)] forKeyedSubscript:@"untrackedS"];
  }
  if ([v140 count]) {
    [v482 setObject:v140 forKeyedSubscript:@"overall"];
  }

  long long v533 = 0u;
  long long v534 = 0u;
  long long v531 = 0u;
  long long v532 = 0u;
  id v141 = [v525 allSignpostTrackers];
  id v142 = [v141 countByEnumeratingWithState:&v531 objects:v588 count:16];
  if (v142)
  {
    uint64_t v481 = *(void *)v532;
    id v477 = v141;
    do
    {
      v489 = 0;
      id v478 = v142;
      do
      {
        if (*(void *)v532 != v481) {
          objc_enumerationMutation(v141);
        }
        v519 = *(void **)(*((void *)&v531 + 1) + 8 * (void)v489);
        long long v587 = 0u;
        long long v586 = 0u;
        long long v585 = 0u;
        long long v584 = 0u;
        long long v583 = 0u;
        long long v582 = 0u;
        id v143 = [[objc_msgSend(v525, "eventEnd") machContTimeNs];
        if (!v519) {
          goto LABEL_455;
        }
        [v519 statsWithEventEndNs:v143];
        unint64_t v485 = v582;
        if (!(void)v582) {
          goto LABEL_455;
        }
        long long v144 = v583;
        long long v577 = 0u;
        long long v578 = 0u;
        long long v579 = 0u;
        long long v580 = 0u;
        id v145 = [objc_msgSend(v519, "signpost") diagnostics];
        id v146 = [v145 countByEnumeratingWithState:&v577 objects:buf count:16];
        if (!v146) {
          goto LABEL_439;
        }
        id v484 = v146;
        id v479 = v145;
        char v147 = 0;
        uint64_t v486 = *(void *)v578;
        double v148 = (double)*((unint64_t *)&v144 + 1) / 1000000000.0;
        do
        {
          id obja = 0;
          do
          {
            if (*(void *)v578 != v486) {
              objc_enumerationMutation(v479);
            }
            v522 = *(void **)(*((void *)&v577 + 1) + 8 * (void)obja);
            v516 = [[SPWRReportReason alloc] initWithWorkflowTracker:v525 signpostTracker:v519 diagnostic:v522];
            if ([v522 hasTriggerThresholdCount]
              && v485 >= [v522 triggerThresholdCount])
            {
              if ([v522 reportOtherSignpostWithName] || (void)v144)
              {
                [(SPWRReportReason *)v516 setSignpostCount:v485];
                int v149 = 1;
              }
              else
              {
                if (byte_1000EBCF8)
                {
                  int v156 = *__error();
                  uint64_t v157 = sub_10002E548();
                  if (os_log_type_enabled(v157, OS_LOG_TYPE_ERROR))
                  {
                    id v206 = [objc_msgSend(v525, "workflow") name];
                    id v207 = [objc_msgSend(v519, "signpost") name];
                    id v208 = [v522 name];
                    *(_DWORD *)v591 = 138412802;
                    id v592 = v206;
                    __int16 v593 = 2112;
                    id v594 = v207;
                    __int16 v595 = 2112;
                    id v596 = v208;
                    _os_log_error_impl((void *)&_mh_execute_header, v157, OS_LOG_TYPE_ERROR, "WR: %@: %@: diagnostic %@: Reporting spindump for this signpost due to count threshold, but no intervals to report", v591, 0x20u);
                  }
                  *__error() = v156;
                }
                int v149 = 0;
                if (byte_1000EBCF9 && dword_1000EB4A8 <= 3)
                {
                  int v158 = *__error();
                  CFStringRef v159 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"WR: %@: %@: diagnostic %@: Reporting spindump for this signpost due to count threshold, but no intervals to report", [objc_msgSend(objc_msgSend(v525, "workflow"), "name") stringByAppendingPathComponent:[objc_msgSend(objc_msgSend(v519, "signpost"), "name") stringByAppendingPathComponent:[objc_msgSend(v522, "name") stringByAppendingPathComponent:@"WR: %@: %@: diagnostic %@: Reporting spindump for this signpost due to count threshold, but no intervals to report"]]]);
                  CFStringRef v160 = v159;
                  if (v159)
                  {
                    int v161 = (char *)CFStringGetCStringPtr(v159, 0x8000100u);
                    if (v161)
                    {
                      CFStringRef v162 = 0;
                    }
                    else
                    {
                      int v161 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x8DCEACBFuLL);
                      CFStringGetCString(v160, v161, 1024, 0x8000100u);
                      CFStringRef v162 = v161;
                    }
                    if (qword_1000EBD00) {
                      uint64_t v205 = (FILE *)qword_1000EBD00;
                    }
                    else {
                      uint64_t v205 = __stderrp;
                    }
                    fprintf(v205, "%s\n", v161);
                    if (v162) {
                      free(v162);
                    }
                    CFRelease(v160);
                  }
                  else
                  {
                    uint64_t v203 = sub_10002E548();
                    if (os_log_type_enabled(v203, OS_LOG_TYPE_FAULT))
                    {
                      id v209 = [[objc_msgSend(v525, "workflow") name];
                      id v210 = [objc_msgSend(v519, "signpost") name];
                      id v211 = [v522 name];
                      *(_DWORD *)v591 = 138412802;
                      id v592 = v209;
                      __int16 v593 = 2112;
                      id v594 = v210;
                      __int16 v595 = 2112;
                      id v596 = v211;
                      _os_log_fault_impl((void *)&_mh_execute_header, v203, OS_LOG_TYPE_FAULT, "Unable to format: WR: %@: %@: diagnostic %@: Reporting spindump for this signpost due to count threshold, but no intervals to report", v591, 0x20u);
                    }
                    if (qword_1000EBD00) {
                      uint64_t v204 = (FILE *)qword_1000EBD00;
                    }
                    else {
                      uint64_t v204 = __stderrp;
                    }
                    fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v204);
                  }
                  int v149 = 0;
                  *__error() = v158;
                }
              }
            }
            else
            {
              int v149 = 0;
            }
            double v150 = 0.0;
            if ([v522 hasTriggerThresholdDurationSingle])
            {
              [v522 triggerThresholdDurationSingle];
              if (v151 <= v148)
              {
                [(SPWRReportReason *)v516 setSignpostDurationSingle:v148];
                [v522 triggerThresholdDurationSingle];
                double v150 = v152;
              }
            }
            if ([v522 hasTriggerThresholdDurationSum])
            {
              [v522 triggerThresholdDurationSum];
              if (v153 <= v148)
              {
                [(SPWRReportReason *)v516 setSignpostDurationSum:v148];
                int v149 = 1;
              }
            }
            if ([v522 hasTriggerThresholdDurationUnion]
              && ([v522 triggerThresholdDurationUnion], v154 <= v148))
            {
              [(SPWRReportReason *)v516 setSignpostDurationUnion:v148];
              LOBYTE(v149) = 1;
            }
            else
            {
              if (v150 > 0.0) {
                int v155 = 1;
              }
              else {
                int v155 = v149;
              }
              if (v155 != 1) {
                goto LABEL_417;
              }
            }
            if ([v522 hasAnySpindumpReports])
            {
              v513 = (void *)v544(v543);
              if (!v513)
              {

                id v141 = v477;
                goto LABEL_437;
              }
              v507 = (void *)((uint64_t (*)(void *))v539)(v538);
              id v163 = [v522 reportOtherSignpostWithName];
              if (v163)
              {
                id v164 = [[objc_msgSend(v525, "allSignpostTrackers") mutableCopy];
                if ([v164 count])
                {
                  unint64_t v165 = 0;
                  do
                  {
                    id v166 = [v164 objectAtIndexedSubscript:v165];
                    id v167 = [v166 signpost];
                    if (!objc_msgSend(objc_msgSend(v167, "name"), "isEqualToString:", v163)
                      || objc_msgSend(objc_msgSend(v519, "signpost"), "individuationFieldName")
                      && [v167 individuationFieldName]
                      && (![v519 individuationIdentifier]
                       || ![v166 individuationIdentifier]
                       || (objc_msgSend(objc_msgSend(v519, "individuationIdentifier"), "isEqualToString:", objc_msgSend(v166, "individuationIdentifier")) & 1) == 0))
                    {
                      [v164 removeObjectAtIndex:v165--];
                    }
                    ++v165;
                  }
                  while (v165 < (unint64_t)[v164 count]);
                }
                id alloc = [v164 copy];

                LOBYTE(v149) = 1;
              }
              else
              {
                id alloc = [objc_alloc((Class)NSArray) initWithObjects:v519, 0];
              }
              id v168 = [v522 reportProcessesWithName];
              if (v168)
              {
                id v510 = objc_alloc_init((Class)NSMutableArray);
                *(void *)v600 = _NSConcreteStackBlock;
                *(void *)&v600[8] = 3221225472;
                *(void *)&v600[16] = sub_10003BE14;
                v601 = &unk_1000DCE88;
                id v602 = v168;
                id v603 = v510;
                [v513 enumerateTasks:v600];
              }
              else
              {
                id v510 = 0;
              }
              long long v576 = 0u;
              long long v575 = 0u;
              long long v574 = 0u;
              *(_OWORD *)v573 = 0u;
              CFAllocatorRef v169 = (const __CFAllocator *)[alloc countByEnumeratingWithState:v573 objects:v599 count:16];
              if (v169)
              {
                uint64_t v170 = *(void *)v574;
                uint64_t v497 = *(void *)v574;
                do
                {
                  CFAllocatorRef v505 = 0;
                  CFAllocatorRef v501 = v169;
                  do
                  {
                    if (*(void *)v574 != v170) {
                      objc_enumerationMutation(alloc);
                    }
                    unsigned int v171 = *(void **)(*(void *)&v573[8] + 8 * (void)v505);
                    id v172 = [v171 intervals];
                    id v503 = [v171 incompleteIntervalStarts];
                    id v173 = [v172 count];
                    if ((char *)[v503 count] + (void)v173)
                    {
                      long long v572 = 0u;
                      long long v570 = 0u;
                      long long v571 = 0u;
                      *(_OWORD *)v569 = 0u;
                      id v182 = [v172 countByEnumeratingWithState:v569 objects:v590 count:16];
                      if (v182)
                      {
                        uint64_t v183 = *(void *)v570;
                        do
                        {
                          for (n = 0; n != v182; n = (char *)n + 1)
                          {
                            if (*(void *)v570 != v183) {
                              objc_enumerationMutation(v172);
                            }
                            CFStringRef v185 = *(void **)(*(void *)&v569[8] + 8 * (void)n);
                            if ((v149 & 1) == 0)
                            {
                              id v186 = [objc_msgSend(*(id *)(*(void *)&v569[8] + 8 * (void)n), "start") machContTimeNs];
                              if (v150 + (double)(unint64_t)v186 > (double)(unint64_t)objc_msgSend(objc_msgSend(v185, "end"), "machContTimeNs")) {
                                continue;
                              }
                            }
                            sub_100037DA8(v524, (uint64_t)v516, v513, v525, v519, v522, (uint64_t)v171, v510, v507, (uint64_t)[objc_msgSend(objc_msgSend(v185, "start"), "threadID")], (uint64_t)[objc_msgSend(objc_msgSend(v185, "end"), "threadID")], (unint64_t)[objc_msgSend(objc_msgSend(v185, "start"), "machContTimeNs")], (unint64_t)[objc_msgSend(objc_msgSend(v185, "end"), "machContTimeNs")]);
                          }
                          id v182 = [v172 countByEnumeratingWithState:v569 objects:v590 count:16];
                        }
                        while (v182);
                      }
                      long long v567 = 0u;
                      long long v568 = 0u;
                      long long v565 = 0u;
                      long long v566 = 0u;
                      uint64_t v170 = v497;
                      id v187 = [v503 countByEnumeratingWithState:&v565 objects:v589 count:16];
                      if (v187)
                      {
                        uint64_t v188 = *(void *)v566;
                        do
                        {
                          for (ii = 0; ii != v187; ii = (char *)ii + 1)
                          {
                            if (*(void *)v566 != v188) {
                              objc_enumerationMutation(v503);
                            }
                            pid_t v190 = *(void **)(*((void *)&v565 + 1) + 8 * (void)ii);
                            if ((v149 & 1) == 0)
                            {
                              id v191 = [*(id *)(*((void *)&v565 + 1) + 8 * (void)ii) machContTimeNs];
                              if (v150 + (double)(unint64_t)v191 > (double)(unint64_t)objc_msgSend(objc_msgSend(v525, "eventEnd"), "machContTimeNs")) {
                                continue;
                              }
                            }
                            sub_100037DA8(v524, (uint64_t)v516, v513, v525, v519, v522, (uint64_t)v171, v510, v507, (uint64_t)[v190 threadID], 0, (unint64_t)[objc_msgSend(v190, "machContTimeNs")], (unint64_t)[objc_msgSend(objc_msgSend(v525, "eventEnd"), "machContTimeNs")]);
                          }
                          id v187 = [v503 countByEnumeratingWithState:&v565 objects:v589 count:16];
                        }
                        while (v187);
                      }
                    }
                    else
                    {
                      if (byte_1000EBCF8)
                      {
                        int v174 = *__error();
                        uint64_t v175 = sub_10002E548();
                        if (os_log_type_enabled(v175, OS_LOG_TYPE_ERROR))
                        {
                          id v195 = [[objc_msgSend(v525, "workflow") name];
                          id v196 = [objc_msgSend(v171, "signpost") name];
                          id v197 = [v522 name];
                          id v198 = [objc_msgSend(v171, "signpost") name];
                          *(_DWORD *)v591 = 138413058;
                          id v592 = v195;
                          __int16 v593 = 2112;
                          id v594 = v196;
                          __int16 v595 = 2112;
                          id v596 = v197;
                          __int16 v597 = 2112;
                          id v598 = v198;
                          _os_log_error_impl((void *)&_mh_execute_header, v175, OS_LOG_TYPE_ERROR, "WR: %@: %@: diagnostic %@: Reporting spindump for this signpost due to %@, but no intervals to report", v591, 0x2Au);
                        }
                        *__error() = v174;
                      }
                      if (byte_1000EBCF9) {
                        BOOL v176 = dword_1000EB4A8 <= 3;
                      }
                      else {
                        BOOL v176 = 0;
                      }
                      if (v176)
                      {
                        int v177 = *__error();
                        CFStringRef v178 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"WR: %@: %@: diagnostic %@: Reporting spindump for this signpost due to %@, but no intervals to report", [objc_msgSend(objc_msgSend(v525, "workflow"), "name")], [objc_msgSend(objc_msgSend(v171, "signpost"), "name")], [objc_msgSend(v522, "name")], [objc_msgSend(objc_msgSend(v171, "signpost"), "name")]);
                        CFStringRef v179 = v178;
                        if (v178)
                        {
                          uint64_t v180 = (char *)CFStringGetCStringPtr(v178, 0x8000100u);
                          if (v180)
                          {
                            unsigned int v181 = 0;
                          }
                          else
                          {
                            uint64_t v180 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x2BF4310CuLL);
                            CFStringGetCString(v179, v180, 1024, 0x8000100u);
                            unsigned int v181 = v180;
                          }
                          if (qword_1000EBD00) {
                            id v194 = (FILE *)qword_1000EBD00;
                          }
                          else {
                            id v194 = __stderrp;
                          }
                          fprintf(v194, "%s\n", v180);
                          if (v181) {
                            free(v181);
                          }
                          CFRelease(v179);
                        }
                        else
                        {
                          uint64_t v192 = sub_10002E548();
                          if (os_log_type_enabled(v192, OS_LOG_TYPE_FAULT))
                          {
                            id v199 = [objc_msgSend(v525, "workflow") name];
                            id v200 = [objc_msgSend(v171, "signpost") name];
                            id v201 = [v522 name];
                            id v202 = [objc_msgSend(v171, "signpost") name];
                            *(_DWORD *)v591 = 138413058;
                            id v592 = v199;
                            __int16 v593 = 2112;
                            id v594 = v200;
                            __int16 v595 = 2112;
                            id v596 = v201;
                            __int16 v597 = 2112;
                            id v598 = v202;
                            _os_log_fault_impl((void *)&_mh_execute_header, v192, OS_LOG_TYPE_FAULT, "Unable to format: WR: %@: %@: diagnostic %@: Reporting spindump for this signpost due to %@, but no intervals to report", v591, 0x2Au);
                          }
                          if (qword_1000EBD00) {
                            uint64_t v193 = (FILE *)qword_1000EBD00;
                          }
                          else {
                            uint64_t v193 = __stderrp;
                          }
                          fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v193);
                        }
                        *__error() = v177;
                      }
                    }
                    CFAllocatorRef v505 = (CFAllocatorRef)((char *)v505 + 1);
                  }
                  while (v505 != v501);
                  CFAllocatorRef v169 = (const __CFAllocator *)[alloc countByEnumeratingWithState:v573 objects:v599 count:16];
                }
                while (v169);
              }
            }
            char v147 = 1;
LABEL_417:

            id obja = (char *)obja + 1;
          }
          while (obja != v484);
          id v212 = [v479 countByEnumeratingWithState:&v577 objects:buf count:16];
          id v484 = v212;
        }
        while (v212);
        id v141 = v477;
        if ((v147 & 1) == 0) {
          goto LABEL_439;
        }
LABEL_437:
        if ((objc_msgSend(v480, "containsObject:", objc_msgSend(objc_msgSend(v519, "signpost"), "name")) & 1) == 0) {
          [v480 addObject:[objc_msgSend(objc_msgSend(v519, "signpost"), "name")];
        }
LABEL_439:
        id v142 = v478;
        id v213 = objc_alloc_init((Class)NSMutableDictionary);
        uint64_t v214 = v582;
        if ((unint64_t)v582 >= 2)
        {
          [v213 setObject:+[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:") forKeyedSubscript:@"num"];
          uint64_t v214 = v582;
        }
        if (v214 != (void)v585) {
          [v213 setObject:+[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:") forKeyedSubscript:@"numIncomplete"];
        }
        uint64_t v215 = *((void *)&v585 + 1);
        if (*((void *)&v585 + 1))
        {
          [v213 setObject:+[NSNumber numberWithDouble:](NSNumber, "numberWithDouble:", (double)*((unint64_t *)&v585 + 1) / 1000000000.0) forKeyedSubscript:@"unionS"];
          uint64_t v215 = *((void *)&v585 + 1);
        }
        if (v215 != (void)v586)
        {
          [v213 setObject:+[NSNumber numberWithDouble:](NSNumber, "numberWithDouble:", (double)(unint64_t)v586 / 1000000000.0) forKeyedSubscript:@"sumS"];
          uint64_t v215 = *((void *)&v585 + 1);
        }
        if (v215 != *((void *)&v586 + 1)) {
          [v213 setObject:[+[NSNumber numberWithDouble:](NSNumber, "numberWithDouble:", (double)*((unint64_t *)&v586 + 1) / 1000000000.0)] forKeyedSubscript:@"maxS"];
        }
        id v216 = [v519 environment];
        v530[0] = _NSConcreteStackBlock;
        v530[1] = 3221225472;
        v530[2] = sub_1000376AC;
        v530[3] = &unk_1000DCE18;
        v530[4] = v213;
        v530[5] = v495;
        v530[6] = v519;
        [v216 enumerateKeysAndObjectsUsingBlock:v530];
        if ([v213 count])
        {
          if ([v519 individuationIdentifier]) {
            +[NSString stringWithFormat:@"%@-%@", [objc_msgSend(objc_msgSend(v519, "signpost"), "name")], [objc_msgSend(v519, "individuationIdentifier")]];
          }
          else {
            [objc_msgSend(v519, "signpost") name];
          }
          [v482 setObject:v213 forKeyedSubscript:WRSanitizeForCA()];
        }

LABEL_455:
        v489 = (char *)v489 + 1;
      }
      while (v489 != v142);
      id v142 = [v141 countByEnumeratingWithState:&v531 objects:v588 count:16];
    }
    while (v142);
  }
  if (![v524 count])
  {
    if (byte_1000EBCF8)
    {
      int v227 = *__error();
      uint64_t v228 = sub_10002E548();
      if (os_log_type_enabled(v228, OS_LOG_TYPE_INFO))
      {
        *(_DWORD *)buf = 138412290;
        id v605 = v495;
        _os_log_impl((void *)&_mh_execute_header, v228, OS_LOG_TYPE_INFO, "WR: %@: no spindump reports to generate", buf, 0xCu);
      }
      *__error() = v227;
    }
    if (!byte_1000EBCF9 || dword_1000EB4A8 > 1) {
      goto LABEL_534;
    }
    int v222 = *__error();
    CFStringRef v229 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"WR: %@: no spindump reports to generate", v495);
    CFStringRef v230 = v229;
    if (!v229)
    {
      uint64_t v246 = sub_10002E548();
      if (os_log_type_enabled(v246, OS_LOG_TYPE_FAULT)) {
        sub_100083284();
      }
      if (qword_1000EBD00) {
        int v247 = (FILE *)qword_1000EBD00;
      }
      else {
        int v247 = __stderrp;
      }
      goto LABEL_518;
    }
    uint64_t v231 = (char *)CFStringGetCStringPtr(v229, 0x8000100u);
    if (v231)
    {
      int v232 = 0;
    }
    else
    {
      uint64_t v231 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x7D19C526uLL);
      CFStringGetCString(v230, v231, 1024, 0x8000100u);
      int v232 = v231;
    }
    if (qword_1000EBD00) {
      CFStringRef v249 = (FILE *)qword_1000EBD00;
    }
    else {
      CFStringRef v249 = __stderrp;
    }
    fprintf(v249, "%s\n", v231);
    if (v232) {
      free(v232);
    }
    goto LABEL_532;
  }
  int v217 = (void *)v557[5];
  if (!v217)
  {
    int v233 = *__error();
    id v234 = sub_10002E548();
    if (os_log_type_enabled(v234, OS_LOG_TYPE_FAULT)) {
      sub_100083334(v599, (uint64_t)[v524 count], v234);
    }
    *__error() = v233;
    if (!byte_1000EBCF9 || dword_1000EB4A8 > 4) {
      goto LABEL_534;
    }
    int v222 = *__error();
    CFStringRef v235 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"WR: have %lu reports, but no sampleStore", [v524 count]);
    CFStringRef v230 = v235;
    if (!v235)
    {
      uint64_t v250 = sub_10002E548();
      if (os_log_type_enabled(v250, OS_LOG_TYPE_FAULT)) {
        sub_1000832EC(v590, (uint64_t)[v524 count], v250);
      }
      if (qword_1000EBD00) {
        int v247 = (FILE *)qword_1000EBD00;
      }
      else {
        int v247 = __stderrp;
      }
      goto LABEL_518;
    }
    v236 = (char *)CFStringGetCStringPtr(v235, 0x8000100u);
    if (v236)
    {
      int v237 = 0;
    }
    else
    {
      v236 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xADD1E47CuLL);
      CFStringGetCString(v230, v236, 1024, 0x8000100u);
      int v237 = v236;
    }
    if (qword_1000EBD00) {
      v252 = (FILE *)qword_1000EBD00;
    }
    else {
      v252 = __stderrp;
    }
    fprintf(v252, "%s\n", v236);
    if (v237) {
      free(v237);
    }
LABEL_532:
    CFRelease(v230);
    goto LABEL_533;
  }
  id v218 = [v217 startTime];
  if (v218 || (id v218 = [(id)v557[5] endTime]) != 0)
  {
    [v218 machContTimeSeconds];
    if (v219 != 0.0)
    {
      if (byte_1000EBCF8)
      {
        int v238 = *__error();
        CFStringRef v239 = sub_10002E548();
        if (os_log_type_enabled(v239, OS_LOG_TYPE_DEFAULT))
        {
          id v240 = [v524 count];
          *(_DWORD *)buf = 138412546;
          id v605 = v495;
          __int16 v606 = 2048;
          id v607 = v240;
          _os_log_impl((void *)&_mh_execute_header, v239, OS_LOG_TYPE_DEFAULT, "WR: %@: generating %lu spindump reports", buf, 0x16u);
        }
        *__error() = v238;
      }
      if (byte_1000EBCF9 && dword_1000EB4A8 <= 2)
      {
        int v241 = *__error();
        CFStringRef v242 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"WR: %@: generating %lu spindump reports", v495, [v524 count]);
        CFStringRef v243 = v242;
        if (v242)
        {
          int v244 = (char *)CFStringGetCStringPtr(v242, 0x8000100u);
          if (v244)
          {
            int v245 = 0;
          }
          else
          {
            int v244 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x7CE89AEEuLL);
            CFStringGetCString(v243, v244, 1024, 0x8000100u);
            int v245 = v244;
          }
          if (qword_1000EBD00) {
            uint64_t v298 = (FILE *)qword_1000EBD00;
          }
          else {
            uint64_t v298 = __stderrp;
          }
          fprintf(v298, "%s\n", v244);
          if (v245) {
            free(v245);
          }
          CFRelease(v243);
        }
        else
        {
          v291 = sub_10002E548();
          if (os_log_type_enabled(v291, OS_LOG_TYPE_FAULT))
          {
            [v524 count];
            sub_1000837A0();
          }
          if (qword_1000EBD00) {
            v292 = (FILE *)qword_1000EBD00;
          }
          else {
            v292 = __stderrp;
          }
          fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v292);
        }
        *__error() = v241;
      }
      [(id)v557[5] setWrWorkflowName:v495];
      id v299 = [v525 error];
      [(id)v557[5] setWrError:v299];
      long long v528 = 0u;
      long long v529 = 0u;
      long long v526 = 0u;
      long long v527 = 0u;
      id v511 = [v524 countByEnumeratingWithState:&v526 objects:v581 count:16];
      if (v511)
      {
        uint64_t v508 = *(void *)v527;
        do
        {
          for (jj = 0; jj != v511; jj = (char *)jj + 1)
          {
            if (*(void *)v527 != v508) {
              objc_enumerationMutation(v524);
            }
            v300 = *(void **)(*((void *)&v526 + 1) + 8 * (void)jj);
            CFStringRef v301 = (void *)v557[5];
            id v302 = [v300 reportReason];
            id v303 = [objc_msgSend(v302, "workflowTracker") workflow];
            id v520 = [v303 name];
            id v304 = [v302 signpostTracker];
            id v305 = [v300 reportedSignpostTracker];
            id v523 = [v300 timeRange];
            id v514 = [v300 task];
            [v301 setWrWorkflowTimeoutDuration:0.0];
            [v301 setWrWorkflowDuration:0.0];
            [v301 setWrWorkflowDurationThreshold:0.0];
            [v301 setWrWorkflowDurationOmittingNetworkBoundIntervals:0.0];
            [v301 setWrWorkflowDurationOmittingNetworkBoundIntervalsThreshold:0.0];
            [v301 setWrSignpostName:0];
            [v301 setWrSignpostSubsystem:0];
            [v301 setWrSignpostCategory:0];
            [v301 setWrTriggeringSignpostName:0];
            [v301 setWrTriggeringSignpostSubsystem:0];
            [v301 setWrTriggeringSignpostCategory:0];
            [v301 setWrSignpostDurationUnion:0.0];
            [v301 setWrSignpostDurationUnionThreshold:0.0];
            [v301 setWrSignpostDurationSum:0.0];
            [v301 setWrSignpostDurationSumThreshold:0.0];
            [v301 setWrSignpostDurationSingle:0.0];
            [v301 setWrSignpostDurationSingleThreshold:0.0];
            [v301 setWrSignpostCount:0];
            [v301 setWrSignpostCountThreshold:0];
            if (v305)
            {
              [v301 setWrSignpostName:[objc_msgSend(objc_msgSend(v305, "signpost"), "name")];
              [v301 setWrSignpostSubsystem:[objc_msgSend(objc_msgSend(v305, "signpost"), "subsystem")];
              [v301 setWrSignpostCategory:[objc_msgSend(objc_msgSend(v305, "signpost"), "category")]];
              if (v304)
              {
                if (byte_1000EBCF8)
                {
                  int v306 = *__error();
                  v307 = sub_10002E548();
                  if (os_log_type_enabled(v307, OS_LOG_TYPE_INFO))
                  {
                    id v308 = [objc_msgSend(v305, "signpost") name];
                    id v309 = [objc_msgSend(v304, "signpost") name];
                    id v310 = [v514 name];
                    unsigned int v311 = [v514 pid];
                    *(_DWORD *)buf = 138413314;
                    id v605 = v520;
                    __int16 v606 = 2112;
                    id v607 = v308;
                    __int16 v608 = 2112;
                    NSUInteger v609 = (NSUInteger)v309;
                    __int16 v610 = 2112;
                    id v611 = v310;
                    __int16 v612 = 1024;
                    unsigned int v613 = v311;
                    _os_log_impl((void *)&_mh_execute_header, v307, OS_LOG_TYPE_INFO, "WR: %@ generating report for %@ due to %@ for %@ [%d]", buf, 0x30u);
                  }
                  *__error() = v306;
                }
                if (byte_1000EBCF9 && dword_1000EB4A8 <= 1)
                {
                  int v312 = *__error();
                  CFStringRef v313 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"WR: %@ generating report for %@ due to %@ for %@ [%d]", v520, [objc_msgSend(objc_msgSend(v305, "signpost"), "name")], [objc_msgSend(objc_msgSend(v304, "signpost"), "name")], [objc_msgSend(v514, "name")], [objc_msgSend(v514, "pid")]);
                  CFStringRef v314 = v313;
                  if (v313)
                  {
                    v315 = (char *)CFStringGetCStringPtr(v313, 0x8000100u);
                    if (v315)
                    {
                      int v316 = 0;
                    }
                    else
                    {
                      v315 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x6A3A786uLL);
                      CFStringGetCString(v314, v315, 1024, 0x8000100u);
                      int v316 = v315;
                    }
                    if (qword_1000EBD00) {
                      v340 = (FILE *)qword_1000EBD00;
                    }
                    else {
                      v340 = __stderrp;
                    }
                    fprintf(v340, "%s\n", v315);
                    if (v316) {
                      free(v316);
                    }
                    CFRelease(v314);
                  }
                  else
                  {
                    v336 = sub_10002E548();
                    if (os_log_type_enabled(v336, OS_LOG_TYPE_FAULT))
                    {
                      id v368 = [objc_msgSend(v305, "signpost") name];
                      id v369 = [objc_msgSend(v304, "signpost") name];
                      id v370 = [v514 name];
                      unsigned int v371 = [v514 pid];
                      *(_DWORD *)buf = 138413314;
                      id v605 = v520;
                      __int16 v606 = 2112;
                      id v607 = v368;
                      __int16 v608 = 2112;
                      NSUInteger v609 = (NSUInteger)v369;
                      __int16 v610 = 2112;
                      id v611 = v370;
                      __int16 v612 = 1024;
                      unsigned int v613 = v371;
                      _os_log_fault_impl((void *)&_mh_execute_header, v336, OS_LOG_TYPE_FAULT, "Unable to format: WR: %@ generating report for %@ due to %@ for %@ [%d]", buf, 0x30u);
                    }
                    if (qword_1000EBD00) {
                      v337 = (FILE *)qword_1000EBD00;
                    }
                    else {
                      v337 = __stderrp;
                    }
                    fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v337);
                  }
                  *__error() = v312;
                }
                [v301 setWrTriggeringSignpostName:[objc_msgSend(objc_msgSend(v304, "signpost"), "name")];
                [v301 setWrTriggeringSignpostSubsystem:[objc_msgSend(objc_msgSend(v304, "signpost"), "subsystem")];
                [v301 setWrTriggeringSignpostCategory:[objc_msgSend(objc_msgSend(v304, "signpost"), "category")]];
              }
              else
              {
                if (byte_1000EBCF8)
                {
                  int v326 = *__error();
                  v327 = sub_10002E548();
                  if (os_log_type_enabled(v327, OS_LOG_TYPE_INFO))
                  {
                    id v328 = [objc_msgSend(v305, "signpost") name];
                    id v329 = [v514 name];
                    unsigned int v330 = [v514 pid];
                    *(_DWORD *)buf = 138413058;
                    id v605 = v520;
                    __int16 v606 = 2112;
                    id v607 = v328;
                    __int16 v608 = 2112;
                    NSUInteger v609 = (NSUInteger)v329;
                    __int16 v610 = 1024;
                    LODWORD(v611) = v330;
                    _os_log_impl((void *)&_mh_execute_header, v327, OS_LOG_TYPE_INFO, "WR: %@ generating report for %@ due to overall workflow for %@ [%d]", buf, 0x26u);
                  }
                  *__error() = v326;
                }
                if (byte_1000EBCF9 && dword_1000EB4A8 <= 1)
                {
                  int v331 = *__error();
                  CFStringRef v332 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"WR: %@ generating report for %@ due to overall workflow for %@ [%d]", v520, [objc_msgSend(objc_msgSend(v305, "signpost"), "name")], [objc_msgSend(v514, "name")], [objc_msgSend(v514, "pid")]);
                  CFStringRef v333 = v332;
                  if (v332)
                  {
                    v334 = (char *)CFStringGetCStringPtr(v332, 0x8000100u);
                    if (v334)
                    {
                      v335 = 0;
                    }
                    else
                    {
                      v334 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xCFC5CE55uLL);
                      CFStringGetCString(v333, v334, 1024, 0x8000100u);
                      v335 = v334;
                    }
                    if (qword_1000EBD00) {
                      CFStringRef v346 = (FILE *)qword_1000EBD00;
                    }
                    else {
                      CFStringRef v346 = __stderrp;
                    }
                    fprintf(v346, "%s\n", v334);
                    if (v335) {
                      free(v335);
                    }
                    CFRelease(v333);
                  }
                  else
                  {
                    int v344 = sub_10002E548();
                    if (os_log_type_enabled(v344, OS_LOG_TYPE_FAULT))
                    {
                      id v374 = [objc_msgSend(v305, "signpost") name];
                      id v375 = [v514 name];
                      unsigned int v376 = [v514 pid];
                      *(_DWORD *)buf = 138413058;
                      id v605 = v520;
                      __int16 v606 = 2112;
                      id v607 = v374;
                      __int16 v608 = 2112;
                      NSUInteger v609 = (NSUInteger)v375;
                      __int16 v610 = 1024;
                      LODWORD(v611) = v376;
                      _os_log_fault_impl((void *)&_mh_execute_header, v344, OS_LOG_TYPE_FAULT, "Unable to format: WR: %@ generating report for %@ due to overall workflow for %@ [%d]", buf, 0x26u);
                    }
                    if (qword_1000EBD00) {
                      v345 = (FILE *)qword_1000EBD00;
                    }
                    else {
                      v345 = __stderrp;
                    }
                    fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v345);
                  }
                  *__error() = v331;
                }
              }
              if ([v302 signpostCount])
              {
                [v301 setWrSignpostCount:[v302 signpostCount]];
                [v301 setWrSignpostCountThreshold:[objc_msgSend(objc_msgSend(v302, "diagnostic"), "triggerThresholdCount")];
              }
              [v302 signpostDurationUnion];
              if (v347 > 0.0)
              {
                [v302 signpostDurationUnion];
                [v301 setWrSignpostDurationUnion:];
                [objc_msgSend(v302, "diagnostic") triggerThresholdDurationUnion];
                [v301 setWrSignpostDurationUnionThreshold:];
              }
              [v302 signpostDurationSum];
              if (v348 > 0.0)
              {
                [v302 signpostDurationSum];
                [v301 setWrSignpostDurationSum:];
                [objc_msgSend(v302, "diagnostic") triggerThresholdDurationSum];
                [v301 setWrSignpostDurationSumThreshold:];
              }
              [v302 signpostDurationSingle];
              if (v349 > 0.0)
              {
                [v302 signpostDurationSingle];
                [v301 setWrSignpostDurationSingle:];
                [objc_msgSend(v302, "diagnostic") triggerThresholdDurationSingle];
                [v301 setWrSignpostDurationSingleThreshold:];
              }
            }
            else
            {
              if (byte_1000EBCF8)
              {
                int v317 = *__error();
                CFStringRef v318 = sub_10002E548();
                if (os_log_type_enabled(v318, OS_LOG_TYPE_INFO))
                {
                  id v319 = [v514 name];
                  unsigned int v320 = [v514 pid];
                  *(_DWORD *)buf = 138412802;
                  id v605 = v520;
                  __int16 v606 = 2112;
                  id v607 = v319;
                  __int16 v608 = 1024;
                  LODWORD(v609) = v320;
                  _os_log_impl((void *)&_mh_execute_header, v318, OS_LOG_TYPE_INFO, "WR: %@ generating overall workflow report for %@ [%d]", buf, 0x1Cu);
                }
                *__error() = v317;
              }
              if (byte_1000EBCF9 && dword_1000EB4A8 <= 1)
              {
                int v321 = *__error();
                CFStringRef v322 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"WR: %@ generating overall workflow report for %@ [%d]", v520, [v514 name], [v514 pid]);
                CFStringRef v323 = v322;
                if (v322)
                {
                  v324 = (char *)CFStringGetCStringPtr(v322, 0x8000100u);
                  if (v324)
                  {
                    int v325 = 0;
                  }
                  else
                  {
                    v324 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x59970C77uLL);
                    CFStringGetCString(v323, v324, 1024, 0x8000100u);
                    int v325 = v324;
                  }
                  if (qword_1000EBD00) {
                    int v341 = (FILE *)qword_1000EBD00;
                  }
                  else {
                    int v341 = __stderrp;
                  }
                  fprintf(v341, "%s\n", v324);
                  if (v325) {
                    free(v325);
                  }
                  CFRelease(v323);
                }
                else
                {
                  unsigned __int8 v338 = sub_10002E548();
                  if (os_log_type_enabled(v338, OS_LOG_TYPE_FAULT))
                  {
                    id v372 = [v514 name];
                    unsigned int v373 = [v514 pid];
                    *(_DWORD *)buf = 138412802;
                    id v605 = v520;
                    __int16 v606 = 2112;
                    id v607 = v372;
                    __int16 v608 = 1024;
                    LODWORD(v609) = v373;
                    _os_log_fault_impl((void *)&_mh_execute_header, v338, OS_LOG_TYPE_FAULT, "Unable to format: WR: %@ generating overall workflow report for %@ [%d]", buf, 0x1Cu);
                  }
                  if (qword_1000EBD00) {
                    v339 = (FILE *)qword_1000EBD00;
                  }
                  else {
                    v339 = __stderrp;
                  }
                  fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v339);
                }
                *__error() = v321;
              }
              [v302 workflowDuration];
              if (v342 > 0.0)
              {
                [v302 workflowDuration];
                [v301 setWrWorkflowDuration:];
                [objc_msgSend(v302, "diagnostic") triggerThresholdDurationSingle];
                [v301 setWrWorkflowDurationThreshold:];
              }
              [v302 workflowDurationOmittingNetworkBoundIntervals];
              if (v343 > 0.0)
              {
                [v302 workflowDurationOmittingNetworkBoundIntervals];
                [v301 setWrWorkflowDurationOmittingNetworkBoundIntervals:];
                [objc_msgSend(v302, "diagnostic") triggerThresholdDurationSingle];
                [v301 setWrWorkflowDurationOmittingNetworkBoundIntervalsThreshold:];
              }
              if ([v302 workflowEventTimedOut])
              {
                [v303 maximumEventDuration];
                [v301 setWrWorkflowTimeoutDuration:];
              }
            }
            if (v304) {
              v350 = +[NSString stringWithFormat:](NSString, @"Workflow responsiveness delay with %@ (%@)", v520, [objc_msgSend(objc_msgSend(v304, "signpost"), "name")]);
            }
            else {
              v350 = +[NSString stringWithFormat:@"Workflow responsiveness delay with %@", v520];
            }
            [v301 setReason:v350];
            if (objc_msgSend(v301, "indexOfFirstSampleOnOrAfterTimestamp:", objc_msgSend(v523, "startTime")) == (id)0x7FFFFFFFFFFFFFFFLL
              || objc_msgSend(v301, "indexOfLastSampleOnOrBeforeTimestamp:", objc_msgSend(v523, "endTime")) == (id)0x7FFFFFFFFFFFFFFFLL)
            {
              if (byte_1000EBCF8)
              {
                int v351 = *__error();
                CFStringRef v352 = sub_10002E548();
                if (os_log_type_enabled(v352, OS_LOG_TYPE_ERROR)) {
                  sub_100083440(v573, &v573[1], v352);
                }
                *__error() = v351;
              }
              if (byte_1000EBCF9 && dword_1000EB4A8 <= 3)
              {
                int v353 = *__error();
                CFStringRef v354 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"Sample store contains no samples for the signpost interval, not generating spindump report");
                CFStringRef v355 = v354;
                if (v354)
                {
                  v356 = (char *)CFStringGetCStringPtr(v354, 0x8000100u);
                  if (v356)
                  {
                    v357 = 0;
                  }
                  else
                  {
                    v356 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x554CB48EuLL);
                    CFStringGetCString(v355, v356, 1024, 0x8000100u);
                    v357 = v356;
                  }
                  if (qword_1000EBD00) {
                    CFStringRef v367 = (FILE *)qword_1000EBD00;
                  }
                  else {
                    CFStringRef v367 = __stderrp;
                  }
                  fprintf(v367, "%s\n", v356);
                  if (v357) {
                    free(v357);
                  }
                  CFRelease(v355);
                }
                else
                {
                  v361 = sub_10002E548();
                  if (os_log_type_enabled(v361, OS_LOG_TYPE_FAULT)) {
                    sub_100083400(v569, &v569[1], v361);
                  }
                  if (qword_1000EBD00) {
                    v362 = (FILE *)qword_1000EBD00;
                  }
                  else {
                    v362 = __stderrp;
                  }
                  fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v362);
                }
                *__error() = v353;
              }
            }
            else
            {
              [v301 setTargetProcess:[v300 task]];
              if ([v300 thread])
              {
                [v301 setTargetThreadId:[objc_msgSend(objc_msgSend(v300, "thread"), "threadId")];
                id v358 = [v301 targetDispatchQueueId];
                if (v358 != objc_msgSend(objc_msgSend(v300, "dispatchQueue"), "identifier"))
                {
                  if (([v514 pid] & 0x80000000) == 0)
                  {
                    if (byte_1000EBCF8)
                    {
                      int v433 = *__error();
                      v434 = sub_10002E548();
                      if (os_log_type_enabled(v434, OS_LOG_TYPE_ERROR))
                      {
                        sub_10002E4E8((int)[v514 pid]);
                        [v514 pid];
                        sub_100083660();
                      }
                      *__error() = v433;
                    }
                    if (byte_1000EBCF9 && dword_1000EB4A8 <= 3)
                    {
                      int v388 = *__error();
                      uint64_t v389 = sub_10002E4E8((int)[v514 pid]);
                      CFStringRef v390 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%s [%d]: %s: Unable to set target thread", v389, [v514 pid], "sampleStore.targetDispatchQueueId == report.dispatchQueue.identifier");
                      CFStringRef v391 = v390;
                      if (v390)
                      {
                        v464 = (char *)CFStringGetCStringPtr(v390, 0x8000100u);
                        if (v464)
                        {
                          v465 = 0;
                        }
                        else
                        {
                          v464 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x8AC3D246uLL);
                          CFStringGetCString(v391, v464, 1024, 0x8000100u);
                          v465 = v464;
                        }
                        if (qword_1000EBD00) {
                          v468 = (FILE *)qword_1000EBD00;
                        }
                        else {
                          v468 = __stderrp;
                        }
                        fprintf(v468, "%s\n", v464);
                        if (v465) {
                          free(v465);
                        }
                        CFRelease(v391);
                      }
                      else
                      {
                        unsigned int v392 = sub_10002E548();
                        if (os_log_type_enabled(v392, OS_LOG_TYPE_FAULT))
                        {
                          sub_10002E4E8((int)[v514 pid]);
                          [v514 pid];
                          sub_100083610();
                        }
                        if (qword_1000EBD00) {
                          uint64_t v393 = (FILE *)qword_1000EBD00;
                        }
                        else {
                          uint64_t v393 = __stderrp;
                        }
                        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v393);
                      }
                      *__error() = v388;
                    }
                    char v469 = sub_10002E4E8((int)[v514 pid]);
                    [v514 pid];
                    v474 = "%s [%d]: %s: Unable to set target thread";
                    int v475 = 236;
LABEL_920:
                    sub_10002E41C("GenerateWorkflowResponsivenessReport", "monitor-WorkflowResponsiveness.m", v475, v474, v470, v471, v472, v473, v469);
LABEL_897:
                    abort();
                  }
                  if (byte_1000EBCF8)
                  {
                    int v435 = *__error();
                    v436 = sub_10002E548();
                    if (os_log_type_enabled(v436, OS_LOG_TYPE_ERROR)) {
                      sub_100083728(v436, v437, v438, v439, v440, v441, v442, v443);
                    }
                    *__error() = v435;
                  }
                  __int16 v407 = "%s: Unable to set target thread";
                  int v408 = 236;
                  if (byte_1000EBCF9 && dword_1000EB4A8 <= 3)
                  {
                    int v409 = *__error();
                    CFStringRef v410 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%s: Unable to set target thread", "sampleStore.targetDispatchQueueId == report.dispatchQueue.identifier");
                    CFStringRef v411 = v410;
                    if (v410)
                    {
                      v458 = (char *)CFStringGetCStringPtr(v410, 0x8000100u);
                      if (v458)
                      {
                        v459 = 0;
                      }
                      else
                      {
                        v458 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x8AC3D246uLL);
                        CFStringGetCString(v411, v458, 1024, 0x8000100u);
                        v459 = v458;
                      }
                      if (qword_1000EBD00) {
                        v462 = (FILE *)qword_1000EBD00;
                      }
                      else {
                        v462 = __stderrp;
                      }
                      fprintf(v462, "%s\n", v458);
                      if (v459) {
                        free(v459);
                      }
                      CFRelease(v411);
                    }
                    else
                    {
                      v412 = sub_10002E548();
                      if (os_log_type_enabled(v412, OS_LOG_TYPE_FAULT)) {
                        sub_1000836B0(v412, v413, v414, v415, v416, v417, v418, v419);
                      }
                      if (qword_1000EBD00) {
                        v420 = (FILE *)qword_1000EBD00;
                      }
                      else {
                        v420 = __stderrp;
                      }
                      fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v420);
                    }
                    *__error() = v409;
                    __int16 v407 = "%s: Unable to set target thread";
                    int v408 = 236;
                  }
LABEL_896:
                  sub_10002E41C("GenerateWorkflowResponsivenessReport", "monitor-WorkflowResponsiveness.m", v408, v407, v384, v385, v386, v387, (char)"sampleStore.targetDispatchQueueId == report.dispatchQueue.identifier");
                  goto LABEL_897;
                }
              }
              if ([v300 dispatchQueue])
              {
                [v301 setTargetDispatchQueueId:[objc_msgSend(objc_msgSend(v300, "dispatchQueue"), "identifier")];
                id v359 = [v301 targetDispatchQueueId];
                if (v359 != objc_msgSend(objc_msgSend(v300, "dispatchQueue"), "identifier"))
                {
                  if (([v514 pid] & 0x80000000) == 0)
                  {
                    if (byte_1000EBCF8)
                    {
                      int v444 = *__error();
                      v445 = sub_10002E548();
                      if (os_log_type_enabled(v445, OS_LOG_TYPE_ERROR))
                      {
                        sub_10002E4E8((int)[v514 pid]);
                        [v514 pid];
                        sub_1000834D0();
                      }
                      *__error() = v444;
                    }
                    if (byte_1000EBCF9 && dword_1000EB4A8 <= 3)
                    {
                      int v394 = *__error();
                      int v395 = sub_10002E4E8((int)[v514 pid]);
                      CFStringRef v396 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%s [%d]: %s: Unable to set target dispatch queue", v395, [v514 pid], "sampleStore.targetDispatchQueueId == report.dispatchQueue.identifier");
                      CFStringRef v397 = v396;
                      if (v396)
                      {
                        v466 = (char *)CFStringGetCStringPtr(v396, 0x8000100u);
                        if (v466)
                        {
                          v467 = 0;
                        }
                        else
                        {
                          v466 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x70AE332DuLL);
                          CFStringGetCString(v397, v466, 1024, 0x8000100u);
                          v467 = v466;
                        }
                        if (qword_1000EBD00) {
                          v476 = (FILE *)qword_1000EBD00;
                        }
                        else {
                          v476 = __stderrp;
                        }
                        fprintf(v476, "%s\n", v466);
                        if (v467) {
                          free(v467);
                        }
                        CFRelease(v397);
                      }
                      else
                      {
                        long long v398 = sub_10002E548();
                        if (os_log_type_enabled(v398, OS_LOG_TYPE_FAULT))
                        {
                          sub_10002E4E8((int)[v514 pid]);
                          [v514 pid];
                          sub_100083480();
                        }
                        if (qword_1000EBD00) {
                          long long v399 = (FILE *)qword_1000EBD00;
                        }
                        else {
                          long long v399 = __stderrp;
                        }
                        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v399);
                      }
                      *__error() = v394;
                    }
                    char v469 = sub_10002E4E8((int)[v514 pid]);
                    [v514 pid];
                    v474 = "%s [%d]: %s: Unable to set target dispatch queue";
                    int v475 = 240;
                    goto LABEL_920;
                  }
                  if (byte_1000EBCF8)
                  {
                    int v446 = *__error();
                    v447 = sub_10002E548();
                    if (os_log_type_enabled(v447, OS_LOG_TYPE_ERROR)) {
                      sub_100083598(v447, v448, v449, v450, v451, v452, v453, v454);
                    }
                    *__error() = v446;
                  }
                  __int16 v407 = "%s: Unable to set target dispatch queue";
                  int v408 = 240;
                  if (byte_1000EBCF9 && dword_1000EB4A8 <= 3)
                  {
                    int v421 = *__error();
                    CFStringRef v422 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%s: Unable to set target dispatch queue", "sampleStore.targetDispatchQueueId == report.dispatchQueue.identifier");
                    CFStringRef v423 = v422;
                    if (v422)
                    {
                      v460 = (char *)CFStringGetCStringPtr(v422, 0x8000100u);
                      if (v460)
                      {
                        v461 = 0;
                      }
                      else
                      {
                        v460 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x70AE332DuLL);
                        CFStringGetCString(v423, v460, 1024, 0x8000100u);
                        v461 = v460;
                      }
                      if (qword_1000EBD00) {
                        v463 = (FILE *)qword_1000EBD00;
                      }
                      else {
                        v463 = __stderrp;
                      }
                      fprintf(v463, "%s\n", v460);
                      if (v461) {
                        free(v461);
                      }
                      CFRelease(v423);
                    }
                    else
                    {
                      v424 = sub_10002E548();
                      if (os_log_type_enabled(v424, OS_LOG_TYPE_FAULT)) {
                        sub_100083520(v424, v425, v426, v427, v428, v429, v430, v431);
                      }
                      if (qword_1000EBD00) {
                        v432 = (FILE *)qword_1000EBD00;
                      }
                      else {
                        v432 = __stderrp;
                      }
                      fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v432);
                    }
                    *__error() = v421;
                    __int16 v407 = "%s: Unable to set target dispatch queue";
                    int v408 = 240;
                  }
                  goto LABEL_896;
                }
              }
              [v301 setEvent:@"Workflow Responsiveness Delay"];
              if (v304) {
                v360 = [NSString stringWithFormat:@"%@, %@.%@.%@, %@", v520, objc_msgSend(objc_msgSend(v304, "signpost"), "subsystem"), objc_msgSend(objc_msgSend(v304, "signpost"), "category"), objc_msgSend(objc_msgSend(v304, "signpost"), "name"), objc_msgSend(objc_msgSend(v302, "diagnostic"), "name")];
              }
              else {
                v360 = [NSString stringWithFormat:@"%@, %@", v520, [objc_msgSend(objc_msgSend(v302, "diagnostic"), "name")];
              }
              [v301 setEventNote:v360];
              [v301 setEventTimeRange:v523];
              [v301 setCustomOutput:v487];
              id v363 = [objc_alloc((Class)SASamplePrinter) initWithSampleStore:v301];
              [objc_msgSend(v363, "options") setPrintHeavyStacks:1];
              [objc_msgSend(v363, "options") setPrintSpinSignatureStack:1];
              [objc_msgSend(v363, "options") setForceOneBasedTimeIndexes:1];
              [v363 setIncidentUUID:v493];
              [v363 filterToTimestampRangeStart:objc_msgSend(v523, "startTime") end:objc_msgSend(v523, "endTime")];
              [objc_msgSend(v523, "startTime") deltaSecondsTo:objc_msgSend(v523, "endTime") timeDomainPriorityList:&off_1000E6A08 timeDomainUsed:0];
              double v365 = v364;
              [objc_msgSend(v523, "startTime") wallTime];
              sub_10004BC40(v363, v366, v365, 0, 0, 14, 0, 0, 1, 0, 0, 0);
            }
          }
          id v511 = [v524 countByEnumeratingWithState:&v526 objects:v581 count:16];
        }
        while (v511);
      }
      goto LABEL_534;
    }
  }
  if (byte_1000EBCF8)
  {
    int v220 = *__error();
    int v221 = sub_10002E548();
    if (os_log_type_enabled(v221, OS_LOG_TYPE_ERROR))
    {
      [v218 debugDescription];
      sub_1000833B8();
    }
    *__error() = v220;
  }
  if (!byte_1000EBCF9 || dword_1000EB4A8 > 3) {
    goto LABEL_534;
  }
  int v222 = *__error();
  CFStringRef v223 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"WR: %@: Unable to compare timesamps with tailspin data (%@)", v495, [v218 debugDescription]);
  CFStringRef v224 = v223;
  if (!v223)
  {
    v248 = sub_10002E548();
    if (os_log_type_enabled(v248, OS_LOG_TYPE_FAULT))
    {
      [v218 debugDescription];
      sub_10008337C();
    }
    if (qword_1000EBD00) {
      int v247 = (FILE *)qword_1000EBD00;
    }
    else {
      int v247 = __stderrp;
    }
LABEL_518:
    fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v247);
    goto LABEL_533;
  }
  int v225 = (char *)CFStringGetCStringPtr(v223, 0x8000100u);
  if (v225)
  {
    uint64_t v226 = 0;
  }
  else
  {
    int v225 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xE753EFuLL);
    CFStringGetCString(v224, v225, 1024, 0x8000100u);
    uint64_t v226 = v225;
  }
  if (qword_1000EBD00) {
    uint64_t v251 = (FILE *)qword_1000EBD00;
  }
  else {
    uint64_t v251 = __stderrp;
  }
  fprintf(v251, "%s\n", v225);
  if (v226) {
    free(v226);
  }
  CFRelease(v224);
LABEL_533:
  *__error() = v222;
LABEL_534:

  if (&_DRShouldGatherLog)
  {
    sub_1000379D8(v482);
    id v253 = [objc_alloc((Class)NSMutableDictionary) initWithObjectsAndKeys:+[NSNumber numberWithDouble:](NSNumber, "numberWithDouble:", v36 * 1000.0), @"durationms", @"239", @"bugtype", v495, @"workflow", v480, @"exceededThresholds", objc_msgSend(v493, "UUIDString"), @"IncidentUUID", v482, @"stats", 0];
    if ([v525 error])
    {
      id v254 = [[objc_msgSend(v525, "error") domain];
      if ([v254 isEqualToString:WRErrorDomain]) {
        [v253 setObject:+[NSNumber numberWithInteger:](NSNumber, "numberWithInteger:", [objc_msgSend(objc_msgSend(v525, "error"), "code")]) forKeyedSubscript:@"error"];
      }
      else {
        [v253 setObject:&off_1000E6960 forKeyedSubscript:@"error"];
      }
    }
    *(void *)&long long v577 = 0;
    if (!DRShouldGatherLog())
    {
      if ((void)v577)
      {
        if (byte_1000EBCF8)
        {
          int v262 = *__error();
          uint64_t v263 = sub_10002E548();
          if (os_log_type_enabled(v263, OS_LOG_TYPE_ERROR))
          {
            [(id)v577 description];
            sub_10008324C();
          }
          *__error() = v262;
        }
        if (!byte_1000EBCF9 || dword_1000EB4A8 > 3) {
          goto LABEL_799;
        }
        int v264 = *__error();
        CFStringRef v265 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"WR: %@: error in DRShouldGatherLog call: %@", v495, [(id)v577 description]);
        CFStringRef v266 = v265;
        if (!v265)
        {
          v289 = sub_10002E548();
          if (os_log_type_enabled(v289, OS_LOG_TYPE_FAULT))
          {
            [(id)v577 description];
            sub_100083210();
          }
          if (qword_1000EBD00) {
            v290 = (FILE *)qword_1000EBD00;
          }
          else {
            v290 = __stderrp;
          }
          goto LABEL_635;
        }
        v267 = (char *)CFStringGetCStringPtr(v265, 0x8000100u);
        if (v267)
        {
          v268 = 0;
        }
        else
        {
          v267 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x903F011DuLL);
          CFStringGetCString(v266, v267, 1024, 0x8000100u);
          v268 = v267;
        }
        if (qword_1000EBD00) {
          v296 = (FILE *)qword_1000EBD00;
        }
        else {
          v296 = __stderrp;
        }
        fprintf(v296, "%s\n", v267);
        if (v268) {
          free(v268);
        }
      }
      else
      {
        if (byte_1000EBCF8)
        {
          int v269 = *__error();
          int v270 = sub_10002E548();
          if (os_log_type_enabled(v270, OS_LOG_TYPE_DEBUG)) {
            sub_10008319C();
          }
          *__error() = v269;
        }
        if (!byte_1000EBCF9 || dword_1000EB4A8 > 0) {
          goto LABEL_799;
        }
        int v264 = *__error();
        CFStringRef v271 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"WR: %@: DRShouldGatherLog return false, not submitting tailspin", v495);
        CFStringRef v266 = v271;
        if (!v271)
        {
          id v297 = sub_10002E548();
          if (os_log_type_enabled(v297, OS_LOG_TYPE_FAULT)) {
            sub_100083134();
          }
          if (qword_1000EBD00) {
            v290 = (FILE *)qword_1000EBD00;
          }
          else {
            v290 = __stderrp;
          }
          goto LABEL_635;
        }
        id v272 = (char *)CFStringGetCStringPtr(v271, 0x8000100u);
        if (v272)
        {
          uint64_t v273 = 0;
        }
        else
        {
          id v272 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x12D257D7uLL);
          CFStringGetCString(v266, v272, 1024, 0x8000100u);
          uint64_t v273 = v272;
        }
        if (qword_1000EBD00) {
          v383 = (FILE *)qword_1000EBD00;
        }
        else {
          v383 = __stderrp;
        }
        fprintf(v383, "%s\n", v272);
        if (v273) {
          free(v273);
        }
      }
LABEL_797:
      CFRelease(v266);
      goto LABEL_798;
    }
    if (byte_1000EBCF8)
    {
      int v255 = *__error();
      v256 = sub_10002E548();
      if (os_log_type_enabled(v256, OS_LOG_TYPE_DEBUG)) {
        sub_1000830C0();
      }
      *__error() = v255;
    }
    if (byte_1000EBCF9 && dword_1000EB4A8 <= 0)
    {
      int v257 = *__error();
      CFStringRef v258 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"WR: %@: submitting tailspin to Diagnostic Pipeline", v495);
      CFStringRef v259 = v258;
      if (v258)
      {
        int v260 = (char *)CFStringGetCStringPtr(v258, 0x8000100u);
        if (v260)
        {
          v261 = 0;
        }
        else
        {
          int v260 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xB07D7A88uLL);
          CFStringGetCString(v259, v260, 1024, 0x8000100u);
          v261 = v260;
        }
        if (qword_1000EBD00) {
          CFStringRef v276 = (FILE *)qword_1000EBD00;
        }
        else {
          CFStringRef v276 = __stderrp;
        }
        fprintf(v276, "%s\n", v260);
        if (v261) {
          free(v261);
        }
        CFRelease(v259);
      }
      else
      {
        v274 = sub_10002E548();
        if (os_log_type_enabled(v274, OS_LOG_TYPE_FAULT)) {
          sub_100083058();
        }
        if (qword_1000EBD00) {
          v275 = (FILE *)qword_1000EBD00;
        }
        else {
          v275 = __stderrp;
        }
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v275);
      }
      *__error() = v257;
    }
    +[NSString stringWithUTF8String:*v494];
    if (DRSubmitLog())
    {
      if (byte_1000EBCF8)
      {
        int v277 = *__error();
        v278 = sub_10002E548();
        if (os_log_type_enabled(v278, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 138412290;
          id v605 = v495;
          _os_log_impl((void *)&_mh_execute_header, v278, OS_LOG_TYPE_DEFAULT, "WR: %@: submitted tailspin to Diagnostic Pipeline", buf, 0xCu);
        }
        *__error() = v277;
      }
      if (byte_1000EBCF9 && dword_1000EB4A8 <= 2)
      {
        int v264 = *__error();
        CFStringRef v279 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"WR: %@: submitted tailspin to Diagnostic Pipeline", v495);
        CFStringRef v266 = v279;
        if (v279)
        {
          v280 = (char *)CFStringGetCStringPtr(v279, 0x8000100u);
          if (v280)
          {
            uint64_t v281 = 0;
          }
          else
          {
            v280 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x337AF97FuLL);
            CFStringGetCString(v266, v280, 1024, 0x8000100u);
            uint64_t v281 = v280;
          }
          if (qword_1000EBD00) {
            v377 = (FILE *)qword_1000EBD00;
          }
          else {
            v377 = __stderrp;
          }
          fprintf(v377, "%s\n", v280);
          if (v281) {
            free(v281);
          }
          goto LABEL_797;
        }
        v293 = sub_10002E548();
        if (os_log_type_enabled(v293, OS_LOG_TYPE_FAULT)) {
          sub_100082F7C();
        }
        if (qword_1000EBD00) {
          v290 = (FILE *)qword_1000EBD00;
        }
        else {
          v290 = __stderrp;
        }
LABEL_635:
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v290);
LABEL_798:
        *__error() = v264;
      }
    }
    else
    {
      if (byte_1000EBCF8)
      {
        int v282 = *__error();
        uint64_t v283 = sub_10002E548();
        if (os_log_type_enabled(v283, OS_LOG_TYPE_ERROR))
        {
          [(id)v577 description];
          sub_100083020();
        }
        *__error() = v282;
      }
      if (byte_1000EBCF9 && dword_1000EB4A8 <= 3)
      {
        int v284 = *__error();
        CFStringRef v285 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"WR: %@: error trying to provide tailspin to Diagnostic Pipeline: %@", v495, [(id)v577 description]);
        CFStringRef v286 = v285;
        if (v285)
        {
          v287 = (char *)CFStringGetCStringPtr(v285, 0x8000100u);
          if (v287)
          {
            int v288 = 0;
          }
          else
          {
            v287 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x86C0BA83uLL);
            CFStringGetCString(v286, v287, 1024, 0x8000100u);
            int v288 = v287;
          }
          if (qword_1000EBD00) {
            CFStringRef v378 = (FILE *)qword_1000EBD00;
          }
          else {
            CFStringRef v378 = __stderrp;
          }
          fprintf(v378, "%s\n", v287);
          if (v288) {
            free(v288);
          }
          CFRelease(v286);
        }
        else
        {
          int v294 = sub_10002E548();
          if (os_log_type_enabled(v294, OS_LOG_TYPE_FAULT))
          {
            [(id)v577 description];
            sub_100082FE4();
          }
          if (qword_1000EBD00) {
            v295 = (FILE *)qword_1000EBD00;
          }
          else {
            v295 = __stderrp;
          }
          fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v295);
        }
        *__error() = v284;
      }
      v379 = +[NSPropertyListSerialization dataWithPropertyList:v253 format:200 options:0 error:0];
      v380 = sub_10002E548();
      if (os_signpost_enabled(v380))
      {
        id v381 = [(id)v577 localizedDescription];
        NSUInteger v382 = [(NSData *)v379 length];
        *(_DWORD *)buf = 138543874;
        id v605 = v495;
        __int16 v606 = 2114;
        id v607 = v381;
        __int16 v608 = 2050;
        NSUInteger v609 = v382;
        _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v380, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "DPFailure", "Workflow:%{signpost.telemetry:string1,public}@ error:%{signpost.telemetry:string2,public}@ contextDictionarySize:%{signpost.telemetry:number1,public}lu enableTelemetry=YES ", buf, 0x20u);
      }
    }
LABEL_799:
  }
  free(*v494);
  _Block_object_dispose(&v550, 8);
  _Block_object_dispose(&v556, 8);
  _Block_object_dispose(v562, 8);
}

void sub_100036C10(_Unwind_Exception *a1)
{
}

void sub_100036E28(uint64_t a1, uint64_t a2)
{
}

void sub_100036E38(uint64_t a1)
{
}

uint64_t sub_100036E44(void *a1)
{
  size_t v1 = a1;
  uint64_t v2 = *(void *)(a1[5] + 8);
  if (!*(unsigned char *)(v2 + 24))
  {
    *(unsigned char *)(v2 + 24) = 1;
    id v3 = +[NSMutableArray array];
    CFStringRef v60 = 0;
    *(void *)(*(void *)(v1[6] + 8) + 40) = [objc_alloc((Class)SASampleStore) initForLiveSampling];
    unsigned __int8 v53 = [*(id *)(*(void *)(v1[6] + 8) + 40) parseKTraceFile:v1[7] warningsOut:v3 errorOut:&v60];
    long long v56 = 0u;
    long long v57 = 0u;
    long long v58 = 0u;
    long long v59 = 0u;
    id obj = v3;
    id v4 = [v3 countByEnumeratingWithState:&v56 objects:v67 count:16];
    uint64_t v5 = &byte_1000EBCF8;
    int v6 = &byte_1000EBCF9;
    int v7 = &dword_1000EB4A8;
    if (v4)
    {
      id v8 = v4;
      uint64_t v9 = *(void *)v57;
      do
      {
        for (i = 0; i != v8; i = (char *)i + 1)
        {
          if (*(void *)v57 != v9) {
            objc_enumerationMutation(obj);
          }
          CFStringRef v11 = *(const __CFString **)(*((void *)&v56 + 1) + 8 * i);
          if (*v5)
          {
            int v12 = *__error();
            uint64_t v13 = sub_10002E548();
            if (os_log_type_enabled(v13, OS_LOG_TYPE_INFO))
            {
              uint64_t v14 = v1[4];
              uint64_t v15 = v1[7];
              *(_DWORD *)buf = 138412802;
              uint64_t v62 = v14;
              __int16 v63 = 2080;
              uint64_t v64 = v15;
              __int16 v65 = 2112;
              CFStringRef v66 = v11;
              _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_INFO, "WR: %@: WARNING trying to create sample store from %s: %@\n", buf, 0x20u);
            }
            *__error() = v12;
          }
          if (*v6) {
            BOOL v16 = *v7 <= 1;
          }
          else {
            BOOL v16 = 0;
          }
          if (v16)
          {
            int v17 = *__error();
            CFStringRef v18 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"WR: %@: WARNING trying to create sample store from %s: %@\n", v1[4], v1[7], v11);
            if (v18)
            {
              CFStringRef v19 = v18;
              int v55 = v17;
              id v20 = v8;
              uint64_t v21 = v9;
              int v22 = v1;
              CFStringRef v23 = v5;
              CFStringRef v24 = v6;
              uint64_t v25 = v7;
              CStringPtr = CFStringGetCStringPtr(v18, 0x8000100u);
              if (CStringPtr)
              {
                uint64_t v27 = (char *)CStringPtr;
                uint64_t v28 = 0;
              }
              else
              {
                uint64_t v27 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xE2A57329uLL);
                CFStringGetCString(v19, v27, 1024, 0x8000100u);
                uint64_t v28 = v27;
              }
              if (qword_1000EBD00) {
                BOOL v31 = (FILE *)qword_1000EBD00;
              }
              else {
                BOOL v31 = __stderrp;
              }
              fprintf(v31, "%s\n", v27);
              if (v28) {
                free(v28);
              }
              CFRelease(v19);
              int v7 = v25;
              int v6 = v24;
              uint64_t v5 = v23;
              size_t v1 = v22;
              uint64_t v9 = v21;
              id v8 = v20;
              int v17 = v55;
            }
            else
            {
              uint64_t v29 = sub_10002E548();
              if (os_log_type_enabled(v29, OS_LOG_TYPE_FAULT))
              {
                uint64_t v32 = v1[4];
                uint64_t v33 = v1[7];
                *(_DWORD *)buf = 138412802;
                uint64_t v62 = v32;
                __int16 v63 = 2080;
                uint64_t v64 = v33;
                __int16 v65 = 2112;
                CFStringRef v66 = v11;
                _os_log_fault_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_FAULT, "Unable to format: WR: %@: WARNING trying to create sample store from %s: %@\n", buf, 0x20u);
              }
              if (qword_1000EBD00) {
                uint64_t v30 = (FILE *)qword_1000EBD00;
              }
              else {
                uint64_t v30 = __stderrp;
              }
              fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v30);
            }
            *__error() = v17;
          }
        }
        id v8 = [obj countByEnumeratingWithState:&v56 objects:v67 count:16];
      }
      while (v8);
    }
    if ((v53 & 1) == 0)
    {
      if (*v5)
      {
        int v34 = *__error();
        uint64_t v35 = sub_10002E548();
        if (os_log_type_enabled(v35, OS_LOG_TYPE_ERROR))
        {
          uint64_t v47 = v1[4];
          uint64_t v48 = v1[7];
          CFStringRef v49 = v60;
          if (!v60) {
            CFStringRef v49 = @"Unknown error";
          }
          *(_DWORD *)buf = 138412802;
          uint64_t v62 = v47;
          __int16 v63 = 2080;
          uint64_t v64 = v48;
          __int16 v65 = 2112;
          CFStringRef v66 = v49;
          _os_log_error_impl((void *)&_mh_execute_header, v35, OS_LOG_TYPE_ERROR, "WR: %@: Not generating any spindump reports, unable to create sample store for %s: %@\n", buf, 0x20u);
        }
        *__error() = v34;
      }
      if (*v6 && *v7 <= 3)
      {
        int v36 = *__error();
        CFStringRef v37 = v60;
        if (!v60) {
          CFStringRef v37 = @"Unknown error";
        }
        CFStringRef v38 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"WR: %@: Not generating any spindump reports, unable to create sample store for %s: %@\n", v1[4], v1[7], v37);
        if (v38)
        {
          CFStringRef v39 = v38;
          int v40 = CFStringGetCStringPtr(v38, 0x8000100u);
          if (v40)
          {
            uint64_t v41 = (char *)v40;
            int v42 = 0;
          }
          else
          {
            uint64_t v41 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xE9E19820uLL);
            CFStringGetCString(v39, v41, 1024, 0x8000100u);
            int v42 = v41;
          }
          if (qword_1000EBD00) {
            int v45 = (FILE *)qword_1000EBD00;
          }
          else {
            int v45 = __stderrp;
          }
          fprintf(v45, "%s\n", v41);
          if (v42) {
            free(v42);
          }
          CFRelease(v39);
        }
        else
        {
          CFStringRef v43 = sub_10002E548();
          if (os_log_type_enabled(v43, OS_LOG_TYPE_FAULT))
          {
            uint64_t v50 = v1[4];
            uint64_t v51 = v1[7];
            CFStringRef v52 = v60;
            if (!v60) {
              CFStringRef v52 = @"Unknown error";
            }
            *(_DWORD *)buf = 138412802;
            uint64_t v62 = v50;
            __int16 v63 = 2080;
            uint64_t v64 = v51;
            __int16 v65 = 2112;
            CFStringRef v66 = v52;
            _os_log_fault_impl((void *)&_mh_execute_header, v43, OS_LOG_TYPE_FAULT, "Unable to format: WR: %@: Not generating any spindump reports, unable to create sample store for %s: %@\n", buf, 0x20u);
          }
          if (qword_1000EBD00) {
            CFStringRef v44 = (FILE *)qword_1000EBD00;
          }
          else {
            CFStringRef v44 = __stderrp;
          }
          fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v44);
        }
        *__error() = v36;
      }

      *(void *)(*(void *)(v1[6] + 8) + 40) = 0;
    }
  }
  return *(void *)(*(void *)(v1[6] + 8) + 40);
}

uint64_t sub_100037484(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t result = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 40);
  if (!result)
  {
    id v10 = *(void **)(*(void *)(*(void *)(a1 + 40) + 8) + 40);
    if (!v10)
    {
      if (byte_1000EBCF8)
      {
        int v11 = *__error();
        int v12 = sub_10002E548();
        if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR)) {
          sub_100083B74(v12, v13, v14, v15, v16, v17, v18, v19);
        }
        *__error() = v11;
      }
      if (byte_1000EBCF9) {
        BOOL v20 = dword_1000EB4A8 <= 3;
      }
      else {
        BOOL v20 = 0;
      }
      if (v20)
      {
        int v21 = *__error();
        CFStringRef v22 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%s: TidToPidDictPromise called with no sample store", "sampleStore");
        if (v22)
        {
          CFStringRef v32 = v22;
          CStringPtr = CFStringGetCStringPtr(v22, 0x8000100u);
          if (CStringPtr)
          {
            int v34 = (char *)CStringPtr;
            uint64_t v35 = 0;
          }
          else
          {
            int v34 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x9FF2D1CCuLL);
            CFStringGetCString(v32, v34, 1024, 0x8000100u);
            uint64_t v35 = v34;
          }
          if (qword_1000EBD00) {
            int v36 = (FILE *)qword_1000EBD00;
          }
          else {
            int v36 = __stderrp;
          }
          fprintf(v36, "%s\n", v34);
          if (v35) {
            free(v35);
          }
          CFRelease(v32);
        }
        else
        {
          CFStringRef v23 = sub_10002E548();
          if (os_log_type_enabled(v23, OS_LOG_TYPE_FAULT)) {
            sub_100083AFC(v23, v24, v25, v26, v27, v28, v29, v30);
          }
          if (qword_1000EBD00) {
            BOOL v31 = (FILE *)qword_1000EBD00;
          }
          else {
            BOOL v31 = __stderrp;
          }
          fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v31);
        }
        *__error() = v21;
      }
      sub_10002E41C("DoWorkflowResponsivenessDelay_block_invoke", "monitor-WorkflowResponsiveness.m", 935, "%s: TidToPidDictPromise called with no sample store", a5, a6, a7, a8, (char)"sampleStore");
      abort();
    }
    *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 40) = [v10 tidToPidDict];
    return *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 40);
  }
  return result;
}

void sub_1000376AC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) == 0)
  {
    id v6 = [objc_alloc((Class)NSString) initWithFormat:@"env_%@", WRSanitizeForCA()];
    if ([*(id *)(a1 + 32) objectForKeyedSubscript:v6])
    {
      if (byte_1000EBCF8)
      {
        int v7 = *__error();
        id v8 = sub_10002E548();
        if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
        {
          uint64_t v19 = *(void *)(a1 + 40);
          id v20 = [objc_msgSend(*(id *)(a1 + 48), "signpost") name];
          *(_DWORD *)buf = 138413058;
          uint64_t v24 = v19;
          __int16 v25 = 2112;
          id v26 = v20;
          __int16 v27 = 2112;
          uint64_t v28 = a2;
          __int16 v29 = 2112;
          uint64_t v30 = a3;
          _os_log_error_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "WR: %@: %@: %@ -> %@, conflicts with existing entry", buf, 0x2Au);
        }
        *__error() = v7;
      }
      if (byte_1000EBCF9) {
        BOOL v9 = dword_1000EB4A8 <= 3;
      }
      else {
        BOOL v9 = 0;
      }
      if (v9)
      {
        int v10 = *__error();
        CFStringRef v11 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"WR: %@: %@: %@ -> %@, conflicts with existing entry", *(void *)(a1 + 40), [objc_msgSend(objc_msgSend(*(id *)(a1 + 48), "signpost"), "name") stringByAppendingPathComponent:a2], a3);
        if (v11)
        {
          CFStringRef v12 = v11;
          CStringPtr = CFStringGetCStringPtr(v11, 0x8000100u);
          if (CStringPtr)
          {
            uint64_t v14 = (char *)CStringPtr;
            uint64_t v15 = 0;
          }
          else
          {
            uint64_t v14 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x45918A1CuLL);
            CFStringGetCString(v12, v14, 1024, 0x8000100u);
            uint64_t v15 = v14;
          }
          if (qword_1000EBD00) {
            uint64_t v18 = (FILE *)qword_1000EBD00;
          }
          else {
            uint64_t v18 = __stderrp;
          }
          fprintf(v18, "%s\n", v14);
          if (v15) {
            free(v15);
          }
          CFRelease(v12);
        }
        else
        {
          uint64_t v16 = sub_10002E548();
          if (os_log_type_enabled(v16, OS_LOG_TYPE_FAULT))
          {
            uint64_t v21 = *(void *)(a1 + 40);
            id v22 = [objc_msgSend(*(id *)(a1 + 48), "signpost") name];
            *(_DWORD *)buf = 138413058;
            uint64_t v24 = v21;
            __int16 v25 = 2112;
            id v26 = v22;
            __int16 v27 = 2112;
            uint64_t v28 = a2;
            __int16 v29 = 2112;
            uint64_t v30 = a3;
            _os_log_fault_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_FAULT, "Unable to format: WR: %@: %@: %@ -> %@, conflicts with existing entry", buf, 0x2Au);
          }
          if (qword_1000EBD00) {
            uint64_t v17 = (FILE *)qword_1000EBD00;
          }
          else {
            uint64_t v17 = __stderrp;
          }
          fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v17);
        }
        *__error() = v10;
      }
    }
    else
    {
      [*(id *)(a1 + 32) setObject:a3 forKeyedSubscript:v6];
    }
  }
}

void sub_1000379D8(void *a1)
{
  objc_opt_class();
  if (objc_opt_isKindOfClass())
  {
    long long v26 = 0u;
    long long v27 = 0u;
    long long v24 = 0u;
    long long v25 = 0u;
    id v2 = [a1 allKeys];
    id v3 = [v2 countByEnumeratingWithState:&v24 objects:v29 count:16];
    if (v3)
    {
      id v4 = v3;
      uint64_t v5 = *(void *)v25;
      do
      {
        for (i = 0; i != v4; i = (char *)i + 1)
        {
          if (*(void *)v25 != v5) {
            objc_enumerationMutation(v2);
          }
          uint64_t v7 = *(void *)(*((void *)&v24 + 1) + 8 * i);
          id v8 = [a1 objectForKeyedSubscript:v7];
          v23[0] = _NSConcreteStackBlock;
          v23[1] = 3221225472;
          v23[2] = sub_10003BFE4;
          v23[3] = &unk_1000DCF28;
          v23[4] = a1;
          v23[5] = v7;
          sub_10003BE70(v8, (uint64_t)v23);
        }
        id v4 = [v2 countByEnumeratingWithState:&v24 objects:v29 count:16];
      }
      while (v4);
    }
  }
  else
  {
    objc_opt_class();
    if (objc_opt_isKindOfClass())
    {
      if ([a1 count])
      {
        unint64_t v9 = 0;
        do
        {
          id v10 = [a1 objectAtIndexedSubscript:v9];
          v22[0] = _NSConcreteStackBlock;
          v22[1] = 3221225472;
          v22[2] = sub_10003BFF4;
          v22[3] = &unk_1000DCF50;
          v22[4] = a1;
          v22[5] = v9;
          sub_10003BE70(v10, (uint64_t)v22);
          ++v9;
        }
        while (v9 < (unint64_t)[a1 count]);
      }
    }
    else
    {
      objc_opt_class();
      if (objc_opt_isKindOfClass())
      {
        id v11 = [a1 copy];
        long long v18 = 0u;
        long long v19 = 0u;
        long long v20 = 0u;
        long long v21 = 0u;
        id v12 = [v11 countByEnumeratingWithState:&v18 objects:v28 count:16];
        if (v12)
        {
          id v13 = v12;
          uint64_t v14 = *(void *)v19;
          do
          {
            for (j = 0; j != v13; j = (char *)j + 1)
            {
              if (*(void *)v19 != v14) {
                objc_enumerationMutation(v11);
              }
              uint64_t v16 = *(void **)(*((void *)&v18 + 1) + 8 * (void)j);
              v17[0] = _NSConcreteStackBlock;
              v17[1] = 3221225472;
              v17[2] = sub_10003C004;
              v17[3] = &unk_1000DCF28;
              v17[4] = a1;
              v17[5] = v16;
              sub_10003BE70(v16, (uint64_t)v17);
            }
            id v13 = [v11 countByEnumeratingWithState:&v18 objects:v28 count:16];
          }
          while (v13);
        }
      }
    }
  }
}

void sub_100037CE8(id a1)
{
  size_t v1 = dispatch_queue_attr_make_with_autorelease_frequency(0, DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM);
  id v2 = dispatch_queue_attr_make_with_qos_class(v1, QOS_CLASS_BACKGROUND, 0);
  qword_1000EBB90 = (uint64_t)dispatch_queue_create("WR processing", v2);

  dispatch_release(v2);
}

id sub_100037D4C(uint64_t a1, void *a2)
{
  id result = [objc_msgSend(a2, "name") isEqualToString:*(void *)(a1 + 32)];
  if (result)
  {
    uint64_t v5 = *(void **)(a1 + 40);
    return [v5 addObject:a2];
  }
  return result;
}

void sub_100037DA8(void *a1, uint64_t a2, void *a3, void *a4, void *a5, void *a6, uint64_t a7, void *a8, void *a9, uint64_t a10, uint64_t a11, unint64_t a12, unint64_t a13)
{
  uint64_t v14 = a5;
  uint64_t v15 = a4;
  unint64_t v17 = a12;
  uint64_t v18 = a10;
  if (a8)
  {
    long long v19 = a4;
    long long v20 = a5;
    long long v21 = a6;
    id v22 = a8;
LABEL_22:
    id v38 = +[SATimeRange timeRangeStart:end:](SATimeRange, "timeRangeStart:end:", +[SATimestamp timestampWithMachAbsTime:machAbsTimeSec:machContTime:machContTimeSec:wallTime:](SATimestamp, "timestampWithMachAbsTime:machAbsTimeSec:machContTime:machContTimeSec:wallTime:", 0, 0, 0.0, (double)v17 / 1000000000.0, 0.0), +[SATimestamp timestampWithMachAbsTime:0 machAbsTimeSec:0 machContTime:0.0 machContTimeSec:(double)a13 / 1000000000.0 wallTime:0.0]);
    long long v111 = 0u;
    long long v112 = 0u;
    long long v113 = 0u;
    long long v114 = 0u;
    id v39 = [v22 countByEnumeratingWithState:&v111 objects:v115 count:16];
    if (v39)
    {
      id v40 = v39;
      uint64_t v41 = *(void *)v112;
      do
      {
        for (i = 0; i != v40; i = (char *)i + 1)
        {
          if (*(void *)v112 != v41) {
            objc_enumerationMutation(v22);
          }
          sub_100038A64(a1, a2, v19, v20, v21, a7, a10, a11, v38, *(void **)(*((void *)&v111 + 1) + 8 * i));
        }
        id v40 = [v22 countByEnumeratingWithState:&v111 objects:v115 count:16];
      }
      while (v40);
    }

    return;
  }
  if (a11)
  {
    unint64_t v108 = a12;
    CFStringRef v23 = sub_1000388B0(a3, a9, a11, a13);
    if (!v23)
    {
      if (byte_1000EBCF8)
      {
        int v24 = *__error();
        long long v25 = sub_10002E548();
        if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
        {
          id v83 = [objc_msgSend(v15, "workflow") name];
          CFStringRef v84 = (const __CFString *)[v14 signpost].name;
          __int16 v85 = v15;
          uint64_t v86 = v14;
          if (v84) {
            CFStringRef v87 = v84;
          }
          else {
            CFStringRef v87 = @"<entire workflow>";
          }
          *(_DWORD *)buf = 138413314;
          id v117 = v83;
          __int16 v118 = 2112;
          CFStringRef v119 = v87;
          uint64_t v14 = v86;
          uint64_t v15 = v85;
          __int16 v120 = 2112;
          id v121 = [a6 name];
          __int16 v122 = 2048;
          uint64_t v123 = a11;
          __int16 v124 = 2048;
          unint64_t v125 = a13;
          _os_log_error_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_ERROR, "WR: %@: %@: diagnostic %@: Unable to find task with thread 0x%llx at %llu, cannot generate report", buf, 0x34u);
        }
        *__error() = v24;
      }
      if (byte_1000EBCF9) {
        BOOL v26 = dword_1000EB4A8 <= 3;
      }
      else {
        BOOL v26 = 0;
      }
      if (v26)
      {
        int v27 = *__error();
        id v28 = [[[v15 workflow] name];
        CFStringRef v29 = (const __CFString *)[v14 signpost].name;
        uint64_t v30 = v15;
        BOOL v31 = v14;
        if (v29) {
          CFStringRef v32 = v29;
        }
        else {
          CFStringRef v32 = @"<entire workflow>";
        }
        CFStringRef v33 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"WR: %@: %@: diagnostic %@: Unable to find task with thread 0x%llx at %llu, cannot generate report", v28, v32, [a6 name], a11, a13);
        if (v33)
        {
          CFStringRef v34 = v33;
          CStringPtr = CFStringGetCStringPtr(v33, 0x8000100u);
          if (CStringPtr)
          {
            int v36 = (char *)CStringPtr;
            CFStringRef v37 = 0;
          }
          else
          {
            int v36 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x2688D5C7uLL);
            CFStringGetCString(v34, v36, 1024, 0x8000100u);
            CFStringRef v37 = v36;
          }
          if (qword_1000EBD00) {
            CFStringRef v76 = (FILE *)qword_1000EBD00;
          }
          else {
            CFStringRef v76 = __stderrp;
          }
          fprintf(v76, "%s\n", v36);
          if (v37) {
            free(v37);
          }
          CFRelease(v34);
        }
        else
        {
          int v74 = sub_10002E548();
          if (os_log_type_enabled(v74, OS_LOG_TYPE_FAULT))
          {
            id v96 = [objc_msgSend(v30, "workflow") name];
            CFStringRef v97 = (const __CFString *)[v31 signpost].name;
            if (v97) {
              CFStringRef v98 = v97;
            }
            else {
              CFStringRef v98 = @"<entire workflow>";
            }
            id v99 = [a6 name];
            *(_DWORD *)buf = 138413314;
            id v117 = v96;
            __int16 v118 = 2112;
            CFStringRef v119 = v98;
            __int16 v120 = 2112;
            id v121 = v99;
            __int16 v122 = 2048;
            uint64_t v123 = a11;
            __int16 v124 = 2048;
            unint64_t v125 = a13;
            _os_log_fault_impl((void *)&_mh_execute_header, v74, OS_LOG_TYPE_FAULT, "Unable to format: WR: %@: %@: diagnostic %@: Unable to find task with thread 0x%llx at %llu, cannot generate report", buf, 0x34u);
          }
          if (qword_1000EBD00) {
            CFStringRef v75 = (FILE *)qword_1000EBD00;
          }
          else {
            CFStringRef v75 = __stderrp;
          }
          fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v75);
        }
        *__error() = v27;
      }
      return;
    }
LABEL_21:
    long long v19 = v15;
    long long v20 = v14;
    long long v21 = a6;
    id v22 = [objc_alloc((Class)NSArray) initWithObjects:v23];
    unint64_t v17 = v108;
    goto LABEL_22;
  }
  if (a10)
  {
    unint64_t v108 = a12;
    CFStringRef v23 = sub_1000388B0(a3, a9, a10, a12);
    if (v23) {
      goto LABEL_21;
    }
    if (byte_1000EBCF8)
    {
      long long v58 = v15;
      int v59 = *__error();
      CFStringRef v60 = sub_10002E548();
      if (os_log_type_enabled(v60, OS_LOG_TYPE_ERROR))
      {
        id v92 = [[objc_msgSend(v58, "workflow") name];
        CFStringRef v93 = (const __CFString *)[v14 signpost].name;
        CFStringRef v94 = v14;
        if (v93) {
          CFStringRef v95 = v93;
        }
        else {
          CFStringRef v95 = @"<entire workflow>";
        }
        *(_DWORD *)buf = 138413314;
        id v117 = v92;
        __int16 v118 = 2112;
        CFStringRef v119 = v95;
        uint64_t v14 = v94;
        uint64_t v18 = a10;
        __int16 v120 = 2112;
        id v121 = [a6 name];
        __int16 v122 = 2048;
        uint64_t v123 = a10;
        __int16 v124 = 2048;
        unint64_t v125 = a12;
        _os_log_error_impl((void *)&_mh_execute_header, v60, OS_LOG_TYPE_ERROR, "WR: %@: %@: diagnostic %@: Unable to find task with thread 0x%llx at %llu, cannot generate report", buf, 0x34u);
      }
      *__error() = v59;
      uint64_t v15 = v58;
    }
    if (byte_1000EBCF9) {
      BOOL v61 = dword_1000EB4A8 <= 3;
    }
    else {
      BOOL v61 = 0;
    }
    if (v61)
    {
      int v62 = *__error();
      __int16 v63 = v15;
      id v64 = [[[v15 workflow] name];
      CFStringRef v65 = (const __CFString *)[v14 signpost].name;
      uint64_t v66 = v18;
      int v67 = v14;
      if (v65) {
        CFStringRef v68 = v65;
      }
      else {
        CFStringRef v68 = @"<entire workflow>";
      }
      CFStringRef v69 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"WR: %@: %@: diagnostic %@: Unable to find task with thread 0x%llx at %llu, cannot generate report", v64, v68, [a6 name], v66, a12);
      if (v69)
      {
        CFStringRef v70 = v69;
        BOOL v71 = CFStringGetCStringPtr(v69, 0x8000100u);
        if (v71)
        {
          int v72 = (char *)v71;
          char v73 = 0;
        }
        else
        {
          int v72 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x7130A33DuLL);
          CFStringGetCString(v70, v72, 1024, 0x8000100u);
          char v73 = v72;
        }
        if (qword_1000EBD00) {
          uint64_t v82 = (FILE *)qword_1000EBD00;
        }
        else {
          uint64_t v82 = __stderrp;
        }
        fprintf(v82, "%s\n", v72);
        if (v73) {
          free(v73);
        }
        CFRelease(v70);
      }
      else
      {
        double v80 = sub_10002E548();
        if (os_log_type_enabled(v80, OS_LOG_TYPE_FAULT))
        {
          id v104 = [[objc_msgSend(v63, "workflow") name];
          CFStringRef v105 = (const __CFString *)[v67 signpost].name;
          if (v105) {
            CFStringRef v106 = v105;
          }
          else {
            CFStringRef v106 = @"<entire workflow>";
          }
          id v107 = [a6 name];
          *(_DWORD *)buf = 138413314;
          id v117 = v104;
          __int16 v118 = 2112;
          CFStringRef v119 = v106;
          __int16 v120 = 2112;
          id v121 = v107;
          __int16 v122 = 2048;
          uint64_t v123 = v66;
          __int16 v124 = 2048;
          unint64_t v125 = a12;
          _os_log_fault_impl((void *)&_mh_execute_header, v80, OS_LOG_TYPE_FAULT, "Unable to format: WR: %@: %@: diagnostic %@: Unable to find task with thread 0x%llx at %llu, cannot generate report", buf, 0x34u);
        }
        if (qword_1000EBD00) {
          int v81 = (FILE *)qword_1000EBD00;
        }
        else {
          int v81 = __stderrp;
        }
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v81);
      }
      *__error() = v62;
    }
  }
  else
  {
    if (byte_1000EBCF8)
    {
      int v44 = *__error();
      int v45 = sub_10002E548();
      if (os_log_type_enabled(v45, OS_LOG_TYPE_ERROR))
      {
        id v88 = [objc_msgSend(a4, "workflow") name];
        CFStringRef v89 = (const __CFString *)[v14 signpost].name;
        uint64_t v90 = v14;
        if (v89) {
          CFStringRef v91 = v89;
        }
        else {
          CFStringRef v91 = @"<entire workflow>";
        }
        *(_DWORD *)buf = 138412802;
        id v117 = v88;
        __int16 v118 = 2112;
        CFStringRef v119 = v91;
        uint64_t v14 = v90;
        __int16 v120 = 2112;
        id v121 = [a6 name];
        _os_log_error_impl((void *)&_mh_execute_header, v45, OS_LOG_TYPE_ERROR, "WR: %@: %@: diagnostic %@: Unable to find task given no threads, cannot generate report", buf, 0x20u);
      }
      *__error() = v44;
      uint64_t v15 = a4;
    }
    if (byte_1000EBCF9) {
      BOOL v46 = dword_1000EB4A8 <= 3;
    }
    else {
      BOOL v46 = 0;
    }
    if (v46)
    {
      int v47 = *__error();
      uint64_t v48 = v15;
      id v49 = [[[v15 workflow] name];
      CFStringRef v50 = (const __CFString *)[v14 signpost].name;
      uint64_t v51 = v14;
      if (v50) {
        CFStringRef v52 = v50;
      }
      else {
        CFStringRef v52 = @"<entire workflow>";
      }
      CFStringRef v53 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"WR: %@: %@: diagnostic %@: Unable to find task given no threads, cannot generate report", v49, v52, [a6 name]);
      if (v53)
      {
        CFStringRef v54 = v53;
        int v55 = CFStringGetCStringPtr(v53, 0x8000100u);
        if (v55)
        {
          long long v56 = (char *)v55;
          long long v57 = 0;
        }
        else
        {
          long long v56 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x6AB5B559uLL);
          CFStringGetCString(v54, v56, 1024, 0x8000100u);
          long long v57 = v56;
        }
        if (qword_1000EBD00) {
          CFStringRef v79 = (FILE *)qword_1000EBD00;
        }
        else {
          CFStringRef v79 = __stderrp;
        }
        fprintf(v79, "%s\n", v56);
        if (v57) {
          free(v57);
        }
        CFRelease(v54);
      }
      else
      {
        uint64_t v77 = sub_10002E548();
        if (os_log_type_enabled(v77, OS_LOG_TYPE_FAULT))
        {
          id v100 = [[[v48 workflow] name];
          CFStringRef v101 = (const __CFString *)[v51 signpost].name;
          if (v101) {
            CFStringRef v102 = v101;
          }
          else {
            CFStringRef v102 = @"<entire workflow>";
          }
          id v103 = [a6 name];
          *(_DWORD *)buf = 138412802;
          id v117 = v100;
          __int16 v118 = 2112;
          CFStringRef v119 = v102;
          __int16 v120 = 2112;
          id v121 = v103;
          _os_log_fault_impl((void *)&_mh_execute_header, v77, OS_LOG_TYPE_FAULT, "Unable to format: WR: %@: %@: diagnostic %@: Unable to find task given no threads, cannot generate report", buf, 0x20u);
        }
        if (qword_1000EBD00) {
          malloc_type_id_t v78 = (FILE *)qword_1000EBD00;
        }
        else {
          malloc_type_id_t v78 = __stderrp;
        }
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v78);
      }
      *__error() = v47;
    }
  }
}

void *sub_1000388B0(void *a1, void *a2, uint64_t a3, unint64_t a4)
{
  id v7 = [a2 objectForKeyedSubscript:[+[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:")]];
  if (!v7) {
    return 0;
  }
  long long v24 = 0u;
  long long v25 = 0u;
  long long v22 = 0u;
  long long v23 = 0u;
  id v8 = [[objc_msgSend(a1, "tasksByPid", 0) objectForKeyedSubscript:v7];
  id v9 = [v8 countByEnumeratingWithState:&v22 objects:v26 count:16];
  if (!v9) {
    return 0;
  }
  id v10 = v9;
  double v11 = (double)a4 / 1000000000.0;
  uint64_t v12 = *(void *)v23;
  do
  {
    for (i = 0; i != v10; i = (char *)i + 1)
    {
      if (*(void *)v23 != v12) {
        objc_enumerationMutation(v8);
      }
      uint64_t v14 = *(void **)(*((void *)&v22 + 1) + 8 * i);
      if (objc_msgSend(objc_msgSend(v14, "threads"), "objectForKeyedSubscript:", +[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:", a3)))
      {
        id v15 = [v14 startTimestamp];
        if (v15)
        {
          [v15 machContTimeSeconds];
          if (v16 != 0.0 && v11 < v16) {
            return 0;
          }
          id v18 = [v14 endTimestamp];
          if (v18)
          {
            [v18 machContTimeSeconds];
            if (v19 != 0.0 && v11 < v19) {
              return v14;
            }
          }
        }
      }
    }
    id v10 = [v8 countByEnumeratingWithState:&v22 objects:v26 count:16];
    uint64_t v14 = 0;
  }
  while (v10);
  return v14;
}

void sub_100038A64(void *a1, uint64_t a2, void *a3, void *a4, void *a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9, void *a10)
{
  if ([a5 reportSpindumpForThisThread])
  {
    if (a7 == a8 || a7 == 0) {
      uint64_t v14 = a8;
    }
    else {
      uint64_t v14 = 0;
    }
    if (a8) {
      uint64_t v15 = v14;
    }
    else {
      uint64_t v15 = a7;
    }
    if (v15)
    {
      id v16 = [objc_msgSend(a10, "threads") objectForKeyedSubscript:+[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:", v15)];
      if (v16)
      {
        unint64_t v17 = [[SPWRReport alloc] initWithReportReason:a2 reportedSignpostTracker:a6 task:a10 timeRange:a9 thread:v16 dispatchQueue:0];
        [a1 addObject:v17];
      }
      else
      {
        if (byte_1000EBCF8)
        {
          int v30 = *__error();
          BOOL v31 = sub_10002E548();
          if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR))
          {
            id v321 = [objc_msgSend(a3, "workflow") name];
            CFStringRef v174 = (const __CFString *)[objc_msgSend(a4, "signpost") name];
            CFStringRef v175 = @"<entire workflow>";
            if (v174) {
              CFStringRef v175 = v174;
            }
            *(_DWORD *)buf = 138413570;
            *(void *)&uint8_t buf[4] = v321;
            *(_WORD *)&unsigned char buf[12] = 2112;
            *(void *)&buf[14] = v175;
            *(_WORD *)&buf[22] = 2112;
            id v356 = [a5 name];
            *(_WORD *)v357 = 2112;
            *(void *)&v357[2] = [a10 name];
            *(_WORD *)&v357[10] = 1024;
            *(_DWORD *)&v357[12] = [a10 pid];
            *(_WORD *)&v357[16] = 2048;
            *(void *)&v357[18] = v15;
            _os_log_error_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_ERROR, "WR: %@: %@: diagnostic %@: %@ [%d] has no thread 0x%llx, cannot generate report", buf, 0x3Au);
          }
          *__error() = v30;
        }
        if (byte_1000EBCF9) {
          BOOL v32 = dword_1000EB4A8 <= 3;
        }
        else {
          BOOL v32 = 0;
        }
        if (v32)
        {
          int v313 = *__error();
          id v33 = [objc_msgSend(a3, "workflow") name];
          CFStringRef v34 = (const __CFString *)[a4 signpost].name;
          if (v34) {
            CFStringRef v35 = v34;
          }
          else {
            CFStringRef v35 = @"<entire workflow>";
          }
          CFStringRef v36 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"WR: %@: %@: diagnostic %@: %@ [%d] has no thread 0x%llx, cannot generate report", v33, v35, [a5 name], [a10 name], [a10 pid], v15);
          CFStringRef v37 = v36;
          if (v36)
          {
            CStringPtr = (char *)CFStringGetCStringPtr(v36, 0x8000100u);
            if (CStringPtr)
            {
              id v39 = 0;
            }
            else
            {
              CStringPtr = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x216E16A9uLL);
              CFStringGetCString(v37, CStringPtr, 1024, 0x8000100u);
              id v39 = CStringPtr;
            }
            if (qword_1000EBD00) {
              int v45 = (FILE *)qword_1000EBD00;
            }
            else {
              int v45 = __stderrp;
            }
            fprintf(v45, "%s\n", CStringPtr);
            if (v39) {
              free(v39);
            }
            CFRelease(v37);
          }
          else
          {
            CFStringRef v43 = sub_10002E548();
            if (os_log_type_enabled(v43, OS_LOG_TYPE_FAULT))
            {
              id v312 = [objc_msgSend(a3, "workflow") name];
              CFStringRef v212 = (const __CFString *)[a4 signpost].name;
              if (v212) {
                CFStringRef v213 = v212;
              }
              else {
                CFStringRef v213 = @"<entire workflow>";
              }
              id v214 = [a5 name];
              id v215 = [a10 name];
              unsigned int v216 = [a10 pid];
              *(_DWORD *)buf = 138413570;
              *(void *)&uint8_t buf[4] = v312;
              *(_WORD *)&unsigned char buf[12] = 2112;
              *(void *)&buf[14] = v213;
              *(_WORD *)&buf[22] = 2112;
              id v356 = v214;
              *(_WORD *)v357 = 2112;
              *(void *)&v357[2] = v215;
              *(_WORD *)&v357[10] = 1024;
              *(_DWORD *)&v357[12] = v216;
              *(_WORD *)&v357[16] = 2048;
              *(void *)&v357[18] = v15;
              _os_log_fault_impl((void *)&_mh_execute_header, v43, OS_LOG_TYPE_FAULT, "Unable to format: WR: %@: %@: diagnostic %@: %@ [%d] has no thread 0x%llx, cannot generate report", buf, 0x3Au);
            }
            if (qword_1000EBD00) {
              int v44 = (FILE *)qword_1000EBD00;
            }
            else {
              int v44 = __stderrp;
            }
            fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v44);
          }
          *__error() = v313;
        }
      }
    }
    else
    {
      if (byte_1000EBCF8)
      {
        int v18 = *__error();
        double v19 = sub_10002E548();
        if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
        {
          id v162 = [[objc_msgSend(a3, "workflow") name];
          CFStringRef v163 = (const __CFString *)[[objc_msgSend(a4, "signpost") name];
          if (v163) {
            CFStringRef v164 = v163;
          }
          else {
            CFStringRef v164 = @"<entire workflow>";
          }
          *(_DWORD *)buf = 138413314;
          *(void *)&uint8_t buf[4] = v162;
          *(_WORD *)&unsigned char buf[12] = 2112;
          *(void *)&buf[14] = v164;
          *(_WORD *)&buf[22] = 2112;
          id v356 = [a5 name];
          *(_WORD *)v357 = 2048;
          *(void *)&v357[2] = a7;
          *(_WORD *)&v357[10] = 2048;
          *(void *)&v357[12] = a8;
          _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "WR: %@: %@: diagnostic %@ reports this thread, but signpost starts on 0x%llx and ends on 0x%llx", buf, 0x34u);
        }
        *__error() = v18;
      }
      if (byte_1000EBCF9) {
        BOOL v20 = dword_1000EB4A8 <= 3;
      }
      else {
        BOOL v20 = 0;
      }
      if (v20)
      {
        int v21 = *__error();
        id v22 = [[objc_msgSend(a3, "workflow") name];
        CFStringRef v23 = (const __CFString *)[a4 signpost].name;
        CFStringRef v24 = @"<entire workflow>";
        if (v23) {
          CFStringRef v25 = v23;
        }
        else {
          CFStringRef v25 = @"<entire workflow>";
        }
        CFStringRef v26 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"WR: %@: %@: diagnostic %@ reports this thread, but signpost starts on 0x%llx and ends on 0x%llx", v22, v25, [a5 name], a7, a8);
        CFStringRef v27 = v26;
        if (v26)
        {
          id v28 = (char *)CFStringGetCStringPtr(v26, 0x8000100u);
          if (v28)
          {
            CFStringRef v29 = 0;
          }
          else
          {
            id v28 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xC3558D9FuLL);
            CFStringGetCString(v27, v28, 1024, 0x8000100u);
            CFStringRef v29 = v28;
          }
          if (qword_1000EBD00) {
            int v42 = (FILE *)qword_1000EBD00;
          }
          else {
            int v42 = __stderrp;
          }
          fprintf(v42, "%s\n", v28);
          if (v29) {
            free(v29);
          }
          CFRelease(v27);
        }
        else
        {
          id v40 = sub_10002E548();
          if (os_log_type_enabled(v40, OS_LOG_TYPE_FAULT))
          {
            id v196 = [objc_msgSend(a3, "workflow") name];
            CFStringRef v197 = (const __CFString *)[a4 signpost].name;
            if (v197) {
              CFStringRef v24 = v197;
            }
            id v198 = [a5 name];
            *(_DWORD *)buf = 138413314;
            *(void *)&uint8_t buf[4] = v196;
            *(_WORD *)&unsigned char buf[12] = 2112;
            *(void *)&buf[14] = v24;
            *(_WORD *)&buf[22] = 2112;
            id v356 = v198;
            *(_WORD *)v357 = 2048;
            *(void *)&v357[2] = a7;
            *(_WORD *)&v357[10] = 2048;
            *(void *)&v357[12] = a8;
            _os_log_fault_impl((void *)&_mh_execute_header, v40, OS_LOG_TYPE_FAULT, "Unable to format: WR: %@: %@: diagnostic %@ reports this thread, but signpost starts on 0x%llx and ends on 0x%llx", buf, 0x34u);
          }
          if (qword_1000EBD00) {
            uint64_t v41 = (FILE *)qword_1000EBD00;
          }
          else {
            uint64_t v41 = __stderrp;
          }
          fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v41);
        }
        *__error() = v21;
      }
    }
  }
  id v46 = [a5 reportSpindumpForThreadWithName];
  int v47 = v46;
  if (v46)
  {
    if ([v46 hasPrefix:@"^"]
      && [v47 hasSuffix:@"$"])
    {
      *(void *)CFStringRef v352 = 0;
      id v48 = [objc_alloc((Class)NSRegularExpression) initWithPattern:v47 options:0 error:v352];
      if (!v48)
      {
        if (byte_1000EBCF8)
        {
          int v49 = *__error();
          CFStringRef v50 = sub_10002E548();
          if (os_log_type_enabled(v50, OS_LOG_TYPE_ERROR))
          {
            id v187 = [[objc_msgSend(a3, "workflow") name];
            CFStringRef v188 = (const __CFString *)[objc_msgSend(a4, "signpost") name];
            if (v188) {
              CFStringRef v189 = v188;
            }
            else {
              CFStringRef v189 = @"<entire workflow>";
            }
            id v190 = [a5 name];
            *(_DWORD *)buf = 138413314;
            *(void *)&uint8_t buf[4] = v187;
            *(_WORD *)&unsigned char buf[12] = 2112;
            *(void *)&buf[14] = v189;
            *(_WORD *)&buf[22] = 2112;
            id v356 = v190;
            *(_WORD *)v357 = 2112;
            *(void *)&v357[2] = v47;
            *(_WORD *)&v357[10] = 2112;
            *(void *)&v357[12] = *(void *)v352;
            _os_log_error_impl((void *)&_mh_execute_header, v50, OS_LOG_TYPE_ERROR, "WR: %@: %@: diagnostic %@ reports thread %@, but regex failed to compile: %@", buf, 0x34u);
          }
          *__error() = v49;
        }
        if (byte_1000EBCF9 && dword_1000EB4A8 <= 3)
        {
          int v51 = *__error();
          id v52 = [[objc_msgSend(a3, "workflow") name];
          CFStringRef v53 = (const __CFString *)[a4 signpost].name;
          CFStringRef v54 = @"<entire workflow>";
          if (v53) {
            CFStringRef v55 = v53;
          }
          else {
            CFStringRef v55 = @"<entire workflow>";
          }
          id v56 = [a5 name];
          CFStringRef v57 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"WR: %@: %@: diagnostic %@ reports thread %@, but regex failed to compile: %@", v52, v55, v56, v47, *(void *)v352);
          CFStringRef v58 = v57;
          if (v57)
          {
            int v59 = (char *)CFStringGetCStringPtr(v57, 0x8000100u);
            if (v59)
            {
              CFStringRef v60 = 0;
            }
            else
            {
              int v59 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x65F27258uLL);
              CFStringGetCString(v58, v59, 1024, 0x8000100u);
              CFStringRef v60 = v59;
            }
            if (qword_1000EBD00) {
              uint64_t v170 = (FILE *)qword_1000EBD00;
            }
            else {
              uint64_t v170 = __stderrp;
            }
            fprintf(v170, "%s\n", v59);
            if (v60) {
              free(v60);
            }
            CFRelease(v58);
          }
          else
          {
            id v146 = sub_10002E548();
            if (os_log_type_enabled(v146, OS_LOG_TYPE_FAULT))
            {
              id v270 = [[objc_msgSend(a3, "workflow") name];
              CFStringRef v271 = (const __CFString *)[objc_msgSend(a4, "signpost") name];
              if (v271) {
                CFStringRef v54 = v271;
              }
              id v272 = [a5 name];
              *(_DWORD *)buf = 138413314;
              *(void *)&uint8_t buf[4] = v270;
              *(_WORD *)&unsigned char buf[12] = 2112;
              *(void *)&buf[14] = v54;
              *(_WORD *)&buf[22] = 2112;
              id v356 = v272;
              *(_WORD *)v357 = 2112;
              *(void *)&v357[2] = v47;
              *(_WORD *)&v357[10] = 2112;
              *(void *)&v357[12] = *(void *)v352;
              _os_log_fault_impl((void *)&_mh_execute_header, v146, OS_LOG_TYPE_FAULT, "Unable to format: WR: %@: %@: diagnostic %@ reports thread %@, but regex failed to compile: %@", buf, 0x34u);
            }
            if (qword_1000EBD00) {
              char v147 = (FILE *)qword_1000EBD00;
            }
            else {
              char v147 = __stderrp;
            }
            fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v147);
          }
          *__error() = v51;
        }
        goto LABEL_109;
      }
    }
    else
    {
      id v48 = 0;
    }
    v339 = 0;
    uint64_t v340 = (uint64_t)&v339;
    uint64_t v341 = 0x2020000000;
    LOBYTE(v342) = 0;
    id v61 = [a10 threads];
    *(void *)buf = _NSConcreteStackBlock;
    *(void *)&uint8_t buf[8] = 3221225472;
    *(void *)&buf[16] = sub_10003B79C;
    id v356 = &unk_1000DCED8;
    *(void *)v357 = a9;
    *(void *)&v357[8] = v48;
    *(void *)&v357[16] = v47;
    *(void *)&v357[24] = a2;
    uint64_t v358 = a6;
    id v359 = a10;
    v360 = a1;
    v361 = &v339;
    [v61 enumerateKeysAndObjectsUsingBlock:buf];
    if (!*(unsigned char *)(v340 + 24))
    {
      if (byte_1000EBCF8)
      {
        int v62 = *__error();
        __int16 v63 = sub_10002E548();
        if (os_log_type_enabled(v63, OS_LOG_TYPE_ERROR))
        {
          id v319 = [[objc_msgSend(a3, "workflow") name];
          CFStringRef v157 = (const __CFString *)[a4 signpost].name;
          CFStringRef v158 = @"<entire workflow>";
          if (v157) {
            CFStringRef v158 = v157;
          }
          CFStringRef v310 = v158;
          id v308 = [a5 name];
          id v307 = [a10 name];
          unsigned int v304 = [a10 pid];
          id v159 = [[objc_msgSend(a9, "startTime") debugDescription];
          id v160 = [[objc_msgSend(a9, "endTime") debugDescription];
          *(_DWORD *)CFStringRef v352 = 138414082;
          *(void *)&v352[4] = v319;
          *(_WORD *)&v352[12] = 2112;
          *(void *)&v352[14] = v310;
          *(_WORD *)&v352[22] = 2112;
          *(void *)&v352[24] = v308;
          *(_WORD *)&v352[32] = 2112;
          *(void *)&v352[34] = v47;
          *(_WORD *)&v352[42] = 2112;
          *(void *)&v352[44] = v307;
          *(_WORD *)&v352[52] = 1024;
          *(_DWORD *)&v352[54] = v304;
          *(_WORD *)&v352[58] = 2112;
          *(void *)&v352[60] = v159;
          __int16 v353 = 2112;
          id v354 = v160;
          _os_log_error_impl((void *)&_mh_execute_header, v63, OS_LOG_TYPE_ERROR, "WR: %@: %@: diagnostic %@ reports thread %@, but %@ [%d] has no thread with that name during the interval %@ - %@", v352, 0x4Eu);
        }
        *__error() = v62;
      }
      if (byte_1000EBCF9 && dword_1000EB4A8 <= 3)
      {
        int v306 = *__error();
        id v314 = [objc_msgSend(a3, "workflow") name];
        CFStringRef v64 = (const __CFString *)[a4 signpost].name;
        CFStringRef v65 = @"<entire workflow>";
        if (v64) {
          CFStringRef v65 = v64;
        }
        CFStringRef v66 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"WR: %@: %@: diagnostic %@ reports thread %@, but %@ [%d] has no thread with that name during the interval %@ - %@", v314, v65, [a5 name], v47, [a10 name], [a10 pid], [objc_msgSend(objc_msgSend(a9, "startTime"), "debugDescription")], [objc_msgSend(objc_msgSend(a9, "endTime"), "debugDescription")]);
        CFStringRef v67 = v66;
        if (v66)
        {
          CFStringRef v68 = (char *)CFStringGetCStringPtr(v66, 0x8000100u);
          if (v68)
          {
            CFStringRef v69 = 0;
          }
          else
          {
            CFStringRef v68 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xBB352E6BuLL);
            CFStringGetCString(v67, v68, 1024, 0x8000100u);
            CFStringRef v69 = v68;
          }
          if (qword_1000EBD00) {
            int v72 = (FILE *)qword_1000EBD00;
          }
          else {
            int v72 = __stderrp;
          }
          fprintf(v72, "%s\n", v68);
          if (v69) {
            free(v69);
          }
          CFRelease(v67);
        }
        else
        {
          CFStringRef v70 = sub_10002E548();
          if (os_log_type_enabled(v70, OS_LOG_TYPE_FAULT))
          {
            id v322 = [objc_msgSend(a3, "workflow") name];
            CFStringRef v182 = (const __CFString *)[objc_msgSend(a4, "signpost") name];
            CFStringRef v183 = @"<entire workflow>";
            if (v182) {
              CFStringRef v183 = v182;
            }
            CFStringRef v311 = v183;
            id v309 = [a5 name];
            id v305 = [a10 name];
            unsigned int v184 = [a10 pid];
            id v185 = [objc_msgSend(a9, "startTime") debugDescription];
            id v186 = [[objc_msgSend(a9, "endTime") debugDescription];
            *(_DWORD *)CFStringRef v352 = 138414082;
            *(void *)&v352[4] = v322;
            *(_WORD *)&v352[12] = 2112;
            *(void *)&v352[14] = v311;
            *(_WORD *)&v352[22] = 2112;
            *(void *)&v352[24] = v309;
            *(_WORD *)&v352[32] = 2112;
            *(void *)&v352[34] = v47;
            *(_WORD *)&v352[42] = 2112;
            *(void *)&v352[44] = v305;
            *(_WORD *)&v352[52] = 1024;
            *(_DWORD *)&v352[54] = v184;
            *(_WORD *)&v352[58] = 2112;
            *(void *)&v352[60] = v185;
            __int16 v353 = 2112;
            id v354 = v186;
            _os_log_fault_impl((void *)&_mh_execute_header, v70, OS_LOG_TYPE_FAULT, "Unable to format: WR: %@: %@: diagnostic %@ reports thread %@, but %@ [%d] has no thread with that name during the interval %@ - %@", v352, 0x4Eu);
          }
          if (qword_1000EBD00) {
            BOOL v71 = (FILE *)qword_1000EBD00;
          }
          else {
            BOOL v71 = __stderrp;
          }
          fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v71);
        }
        *__error() = v306;
      }
    }

    _Block_object_dispose(&v339, 8);
  }
LABEL_109:
  if ([a5 reportSpindumpForMainThread])
  {
    id v73 = [a10 mainThread];
    if (v73)
    {
      int v74 = [[SPWRReport alloc] initWithReportReason:a2 reportedSignpostTracker:a6 task:a10 timeRange:a9 thread:v73 dispatchQueue:0];
      [a1 addObject:v74];
    }
    else
    {
      if (byte_1000EBCF8)
      {
        int v75 = *__error();
        CFStringRef v76 = sub_10002E548();
        if (os_log_type_enabled(v76, OS_LOG_TYPE_ERROR))
        {
          id v320 = [[[a3 workflow] name];
          CFStringRef v165 = (const __CFString *)[objc_msgSend(objc_msgSend(a4, "signpost"), "name")];
          if (v165) {
            CFStringRef v166 = v165;
          }
          else {
            CFStringRef v166 = @"<entire workflow>";
          }
          id v167 = [a5 name];
          id v168 = [a10 name];
          unsigned int v169 = [a10 pid];
          *(_DWORD *)buf = 138413314;
          *(void *)&uint8_t buf[4] = v320;
          *(_WORD *)&unsigned char buf[12] = 2112;
          *(void *)&buf[14] = v166;
          *(_WORD *)&buf[22] = 2112;
          id v356 = v167;
          *(_WORD *)v357 = 2112;
          *(void *)&v357[2] = v168;
          *(_WORD *)&v357[10] = 1024;
          *(_DWORD *)&v357[12] = v169;
          _os_log_error_impl((void *)&_mh_execute_header, v76, OS_LOG_TYPE_ERROR, "WR: %@: %@: diagnostic %@ reports main thread, but %@ [%d] has no main thread", buf, 0x30u);
        }
        *__error() = v75;
      }
      if (byte_1000EBCF9 && dword_1000EB4A8 <= 3)
      {
        int v315 = *__error();
        id v77 = [[objc_msgSend(a3, "workflow") name];
        CFStringRef v78 = (const __CFString *)[a4 signpost].name;
        if (v78) {
          CFStringRef v79 = v78;
        }
        else {
          CFStringRef v79 = @"<entire workflow>";
        }
        CFStringRef v80 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"WR: %@: %@: diagnostic %@ reports main thread, but %@ [%d] has no main thread", v77, v79, [a5 name], [a10 name], [a10 pid]);
        CFStringRef v81 = v80;
        if (v80)
        {
          uint64_t v82 = (char *)CFStringGetCStringPtr(v80, 0x8000100u);
          if (v82)
          {
            id v83 = 0;
          }
          else
          {
            uint64_t v82 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x8B62C4B8uLL);
            CFStringGetCString(v81, v82, 1024, 0x8000100u);
            id v83 = v82;
          }
          if (qword_1000EBD00) {
            uint64_t v86 = (FILE *)qword_1000EBD00;
          }
          else {
            uint64_t v86 = __stderrp;
          }
          fprintf(v86, "%s\n", v82);
          if (v83) {
            free(v83);
          }
          CFRelease(v81);
        }
        else
        {
          CFStringRef v84 = sub_10002E548();
          if (os_log_type_enabled(v84, OS_LOG_TYPE_FAULT))
          {
            id v199 = [[objc_msgSend(a3, "workflow") name];
            CFStringRef v200 = (const __CFString *)[a4 signpost].name;
            if (v200) {
              CFStringRef v201 = v200;
            }
            else {
              CFStringRef v201 = @"<entire workflow>";
            }
            id v202 = [a5 name];
            id v203 = [a10 name];
            unsigned int v204 = [a10 pid];
            *(_DWORD *)buf = 138413314;
            *(void *)&uint8_t buf[4] = v199;
            *(_WORD *)&unsigned char buf[12] = 2112;
            *(void *)&buf[14] = v201;
            *(_WORD *)&buf[22] = 2112;
            id v356 = v202;
            *(_WORD *)v357 = 2112;
            *(void *)&v357[2] = v203;
            *(_WORD *)&v357[10] = 1024;
            *(_DWORD *)&v357[12] = v204;
            _os_log_fault_impl((void *)&_mh_execute_header, v84, OS_LOG_TYPE_FAULT, "Unable to format: WR: %@: %@: diagnostic %@ reports main thread, but %@ [%d] has no main thread", buf, 0x30u);
          }
          if (qword_1000EBD00) {
            __int16 v85 = (FILE *)qword_1000EBD00;
          }
          else {
            __int16 v85 = __stderrp;
          }
          fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v85);
        }
        *__error() = v315;
      }
    }
  }
  if (![a5 reportSpindumpForThisDispatchQueue]) {
    goto LABEL_332;
  }
  id v87 = [[[objc_msgSend(objc_msgSend(objc_msgSend(a10, "threads"), "objectForKeyedSubscript:", +[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:", a7))) firstThreadStateOnOrAfterTime:objc_msgSend(a9, "startTime")] sampleIndex:0x7FFFFFFFFFFFFFFFLL];
  id v88 = [objc_msgSend(objc_msgSend(objc_msgSend(a10, "threads"), "objectForKeyedSubscript:", +[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:", a8)), "lastThreadStateOnOrBeforeTime:sampleIndex:", objc_msgSend(a9, "endTime"), 0x7FFFFFFFFFFFFFFFLL);
  uint64_t v89 = (uint64_t)[v87 dispatchQueue];
  unint64_t v90 = (unint64_t)[v88 dispatchQueue];
  int v316 = (void *)v90;
  if (!(v89 | v90))
  {
    if (byte_1000EBCF8)
    {
      int v92 = *__error();
      CFStringRef v93 = sub_10002E548();
      if (os_log_type_enabled(v93, OS_LOG_TYPE_ERROR))
      {
        id v318 = [[objc_msgSend(a3, "workflow") name];
        CFStringRef v150 = (const __CFString *)[a4 signpost].name;
        if (v150) {
          CFStringRef v151 = v150;
        }
        else {
          CFStringRef v151 = @"<entire workflow>";
        }
        id v152 = [a5 name];
        id v153 = [[objc_msgSend(a9, "startTime") debugDescription];
        id v154 = [[objc_msgSend(a9, "endTime") debugDescription];
        *(_DWORD *)buf = 138413826;
        *(void *)&uint8_t buf[4] = v318;
        *(_WORD *)&unsigned char buf[12] = 2112;
        *(void *)&buf[14] = v151;
        *(_WORD *)&buf[22] = 2112;
        id v356 = v152;
        *(_WORD *)v357 = 2048;
        *(void *)&v357[2] = a7;
        *(_WORD *)&v357[10] = 2112;
        *(void *)&v357[12] = v153;
        *(_WORD *)&v357[20] = 2048;
        *(void *)&v357[22] = a8;
        *(_WORD *)&v357[30] = 2112;
        uint64_t v358 = (uint64_t)v154;
        _os_log_error_impl((void *)&_mh_execute_header, v93, OS_LOG_TYPE_ERROR, "WR: %@: %@: diagnostic %@ reports this dispatch queue, but neither start %llu@%@ nor end %llu@%@ are on a dispatch queue", buf, 0x48u);
      }
      *__error() = v92;
    }
    if (byte_1000EBCF9 && dword_1000EB4A8 <= 3)
    {
      int v317 = *__error();
      id v94 = [[objc_msgSend(a3, "workflow") name];
      CFStringRef v95 = (const __CFString *)[a4 signpost].name;
      if (v95) {
        CFStringRef v96 = v95;
      }
      else {
        CFStringRef v96 = @"<entire workflow>";
      }
      CFStringRef v97 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"WR: %@: %@: diagnostic %@ reports this dispatch queue, but neither start %@ nor end %@ are on a dispatch queue", v94, v96, [a5 name], [a9 startTime], [a9 endTime]);
      CFStringRef v98 = v97;
      if (v97)
      {
        id v99 = (char *)CFStringGetCStringPtr(v97, 0x8000100u);
        if (v99)
        {
          id v100 = 0;
        }
        else
        {
          id v99 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x16E96651uLL);
          CFStringGetCString(v98, v99, 1024, 0x8000100u);
          id v100 = v99;
        }
        if (qword_1000EBD00) {
          id v134 = (FILE *)qword_1000EBD00;
        }
        else {
          id v134 = __stderrp;
        }
        fprintf(v134, "%s\n", v99);
        if (v100) {
          free(v100);
        }
        CFRelease(v98);
      }
      else
      {
        uint64_t v123 = sub_10002E548();
        if (os_log_type_enabled(v123, OS_LOG_TYPE_FAULT))
        {
          id v176 = [objc_msgSend(a3, "workflow") name];
          CFStringRef v177 = (const __CFString *)[objc_msgSend(a4, "signpost") name];
          if (v177) {
            CFStringRef v178 = v177;
          }
          else {
            CFStringRef v178 = @"<entire workflow>";
          }
          id v179 = [a5 name];
          id v180 = [objc_msgSend(a9, "startTime") debugDescription];
          id v181 = [[objc_msgSend(a9, "endTime") debugDescription];
          *(_DWORD *)buf = 138413826;
          *(void *)&uint8_t buf[4] = v176;
          *(_WORD *)&unsigned char buf[12] = 2112;
          *(void *)&buf[14] = v178;
          *(_WORD *)&buf[22] = 2112;
          id v356 = v179;
          *(_WORD *)v357 = 2048;
          *(void *)&v357[2] = a7;
          *(_WORD *)&v357[10] = 2112;
          *(void *)&v357[12] = v180;
          *(_WORD *)&v357[20] = 2048;
          *(void *)&v357[22] = a8;
          *(_WORD *)&v357[30] = 2112;
          uint64_t v358 = (uint64_t)v181;
          _os_log_fault_impl((void *)&_mh_execute_header, v123, OS_LOG_TYPE_FAULT, "Unable to format: WR: %@: %@: diagnostic %@ reports this dispatch queue, but neither start %llu@%@ nor end %llu@%@ are on a dispatch queue", buf, 0x48u);
        }
        if (qword_1000EBD00) {
          __int16 v124 = (FILE *)qword_1000EBD00;
        }
        else {
          __int16 v124 = __stderrp;
        }
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v124);
      }
      id v135 = __error();
      int v136 = v317;
      goto LABEL_284;
    }
    goto LABEL_332;
  }
  if (v89 == v90)
  {
LABEL_330:
    if (v89) {
      sub_10003BC98(a1, a2, a6, (uint64_t)a9, (uint64_t)a10, v89);
    }
    goto LABEL_332;
  }
  if (objc_msgSend(objc_msgSend(v87, "startTimestamp"), "le:", objc_msgSend(a9, "startTime"))) {
    unsigned int v91 = [objc_msgSend(objc_msgSend(v87, "endTimestamp")) ge:objc_msgSend(a9, "startTime")];
  }
  else {
    unsigned int v91 = 0;
  }
  if (objc_msgSend(objc_msgSend(v88, "startTimestamp"), "le:", objc_msgSend(a9, "endTime")))
  {
    unsigned int v101 = [objc_msgSend(objc_msgSend(v88, "endTimestamp"), "ge:", objc_msgSend(a9, "endTime"));
    if ((v91 & v101) == 1)
    {
      if (byte_1000EBCF8)
      {
        int v102 = *__error();
        id v103 = sub_10002E548();
        if (os_log_type_enabled(v103, OS_LOG_TYPE_ERROR))
        {
          id v336 = [objc_msgSend(a3, "workflow") name];
          CFStringRef v207 = (const __CFString *)[a4 signpost].name;
          CFStringRef v208 = @"<entire workflow>";
          if (v207) {
            CFStringRef v208 = v207;
          }
          CFStringRef v328 = v208;
          id v209 = [a5 name];
          id v210 = [(id)v89 debugDescription];
          id v211 = [v316 debugDescription];
          *(_DWORD *)buf = 138413314;
          *(void *)&uint8_t buf[4] = v336;
          *(_WORD *)&unsigned char buf[12] = 2112;
          *(void *)&buf[14] = v328;
          *(_WORD *)&buf[22] = 2112;
          id v356 = v209;
          *(_WORD *)v357 = 2112;
          *(void *)&v357[2] = v210;
          *(_WORD *)&v357[10] = 2112;
          *(void *)&v357[12] = v211;
          _os_log_error_impl((void *)&_mh_execute_header, v103, OS_LOG_TYPE_ERROR, "WR: %@: %@: diagnostic %@ reports this dispatch queue, but signpost starts on %@ and ends on %@, so not reporting", buf, 0x34u);
        }
        *__error() = v102;
      }
      if (byte_1000EBCF9 && dword_1000EB4A8 <= 3)
      {
        int v332 = *__error();
        id v104 = [[objc_msgSend(a3, "workflow") name];
        CFStringRef v105 = (const __CFString *)[objc_msgSend(a4, "signpost") name];
        if (v105) {
          CFStringRef v106 = v105;
        }
        else {
          CFStringRef v106 = @"<entire workflow>";
        }
        CFStringRef v107 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"WR: %@: %@: diagnostic %@ reports this dispatch queue, but signpost starts on %@ and ends on %@, so not reporting", v104, v106, [a5 name], [v89 debugDescription], [v316 debugDescription]);
        CFStringRef v108 = v107;
        if (v107)
        {
          unint64_t v109 = (char *)CFStringGetCStringPtr(v107, 0x8000100u);
          if (v109)
          {
            id v110 = 0;
          }
          else
          {
            unint64_t v109 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xCE1E73F9uLL);
            CFStringGetCString(v108, v109, 1024, 0x8000100u);
            id v110 = v109;
          }
          if (qword_1000EBD00) {
            id v173 = (FILE *)qword_1000EBD00;
          }
          else {
            id v173 = __stderrp;
          }
          fprintf(v173, "%s\n", v109);
          if (v110) {
            free(v110);
          }
LABEL_282:
          CFRelease(v108);
          goto LABEL_283;
        }
        int v161 = sub_10002E548();
        if (os_log_type_enabled(v161, OS_LOG_TYPE_FAULT))
        {
          id v287 = [objc_msgSend(a3, "workflow") name];
          CFStringRef v288 = (const __CFString *)[a4 signpost].name;
          if (v288) {
            CFStringRef v289 = v288;
          }
          else {
            CFStringRef v289 = @"<entire workflow>";
          }
          id v290 = [a5 name];
          id v291 = [(id)v89 debugDescription];
          id v292 = [v316 debugDescription];
          *(_DWORD *)buf = 138413314;
          *(void *)&uint8_t buf[4] = v287;
          *(_WORD *)&unsigned char buf[12] = 2112;
          *(void *)&buf[14] = v289;
          *(_WORD *)&buf[22] = 2112;
          id v356 = v290;
          *(_WORD *)v357 = 2112;
          *(void *)&v357[2] = v291;
          *(_WORD *)&v357[10] = 2112;
          *(void *)&v357[12] = v292;
          _os_log_fault_impl((void *)&_mh_execute_header, v161, OS_LOG_TYPE_FAULT, "Unable to format: WR: %@: %@: diagnostic %@ reports this dispatch queue, but signpost starts on %@ and ends on %@, so not reporting", buf, 0x34u);
        }
        if (qword_1000EBD00) {
          int v156 = (FILE *)qword_1000EBD00;
        }
        else {
          int v156 = __stderrp;
        }
        goto LABEL_244;
      }
      goto LABEL_332;
    }
    if (v91) {
      goto LABEL_188;
    }
    if (v101)
    {
      if (byte_1000EBCF8)
      {
        int v137 = *__error();
        id v138 = sub_10002E548();
        if (os_log_type_enabled(v138, OS_LOG_TYPE_DEBUG))
        {
          id v337 = [[objc_msgSend(a3, "workflow") name];
          CFStringRef v293 = (const __CFString *)[objc_msgSend(a4, "signpost") name];
          CFStringRef v294 = @"<entire workflow>";
          if (v293) {
            CFStringRef v294 = v293;
          }
          CFStringRef v330 = v294;
          id v295 = [a5 name];
          id v296 = [(id)v89 debugDescription];
          id v297 = [v316 debugDescription];
          *(_DWORD *)buf = 138413314;
          *(void *)&uint8_t buf[4] = v337;
          *(_WORD *)&unsigned char buf[12] = 2112;
          *(void *)&buf[14] = v330;
          *(_WORD *)&buf[22] = 2112;
          id v356 = v295;
          *(_WORD *)v357 = 2112;
          *(void *)&v357[2] = v296;
          *(_WORD *)&v357[10] = 2112;
          *(void *)&v357[12] = v297;
          _os_log_debug_impl((void *)&_mh_execute_header, v138, OS_LOG_TYPE_DEBUG, "WR: %@: %@: diagnostic %@ reports this dispatch queue, signpost starts on %@ and ends on %@, and end is at the exact time, so using that", buf, 0x34u);
        }
        *__error() = v137;
      }
      if (!byte_1000EBCF9 || dword_1000EB4A8 > 0)
      {
        uint64_t v89 = (uint64_t)v316;
        goto LABEL_330;
      }
      int v334 = *__error();
      id v139 = [[objc_msgSend(a3, "workflow") name];
      CFStringRef v140 = (const __CFString *)[objc_msgSend(a4, "signpost") name];
      if (v140) {
        CFStringRef v141 = v140;
      }
      else {
        CFStringRef v141 = @"<entire workflow>";
      }
      CFStringRef v142 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"WR: %@: %@: diagnostic %@ reports this dispatch queue, signpost starts on %@ and ends on %@, and end is at the exact time, so using that", v139, v141, [a5 name], [v89 debugDescription], [v316 debugDescription]);
      CFStringRef v143 = v142;
      if (v142)
      {
        long long v144 = (char *)CFStringGetCStringPtr(v142, 0x8000100u);
        if (v144)
        {
          id v145 = 0;
        }
        else
        {
          long long v144 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xF98E1683uLL);
          CFStringGetCString(v143, v144, 1024, 0x8000100u);
          id v145 = v144;
        }
        if (qword_1000EBD00) {
          int v217 = (FILE *)qword_1000EBD00;
        }
        else {
          int v217 = __stderrp;
        }
        fprintf(v217, "%s\n", v144);
        if (v145) {
          free(v145);
        }
        CFRelease(v143);
      }
      else
      {
        uint64_t v205 = sub_10002E548();
        if (os_log_type_enabled(v205, OS_LOG_TYPE_FAULT))
        {
          id v298 = [objc_msgSend(a3, "workflow") name];
          CFStringRef v299 = (const __CFString *)[a4 signpost].name;
          if (v299) {
            CFStringRef v300 = v299;
          }
          else {
            CFStringRef v300 = @"<entire workflow>";
          }
          id v301 = [a5 name];
          id v302 = [(id)v89 debugDescription];
          id v303 = [v316 debugDescription];
          *(_DWORD *)buf = 138413314;
          *(void *)&uint8_t buf[4] = v298;
          *(_WORD *)&unsigned char buf[12] = 2112;
          *(void *)&buf[14] = v300;
          *(_WORD *)&buf[22] = 2112;
          id v356 = v301;
          *(_WORD *)v357 = 2112;
          *(void *)&v357[2] = v302;
          *(_WORD *)&v357[10] = 2112;
          *(void *)&v357[12] = v303;
          _os_log_fault_impl((void *)&_mh_execute_header, v205, OS_LOG_TYPE_FAULT, "Unable to format: WR: %@: %@: diagnostic %@ reports this dispatch queue, signpost starts on %@ and ends on %@, and end is at the exact time, so using that", buf, 0x34u);
        }
        if (qword_1000EBD00) {
          id v206 = (FILE *)qword_1000EBD00;
        }
        else {
          id v206 = __stderrp;
        }
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v206);
      }
      uint64_t v89 = (uint64_t)v316;
      goto LABEL_329;
    }
  }
  else if (v91)
  {
LABEL_188:
    if (byte_1000EBCF8)
    {
      int v125 = *__error();
      uint64_t v126 = sub_10002E548();
      if (os_log_type_enabled(v126, OS_LOG_TYPE_DEBUG))
      {
        id v335 = [objc_msgSend(a3, "workflow") name];
        CFStringRef v191 = (const __CFString *)[a4 signpost].name;
        CFStringRef v192 = @"<entire workflow>";
        if (v191) {
          CFStringRef v192 = v191;
        }
        CFStringRef v327 = v192;
        id v193 = [a5 name];
        id v194 = [(id)v89 debugDescription];
        id v195 = [v316 debugDescription];
        *(_DWORD *)buf = 138413314;
        *(void *)&uint8_t buf[4] = v335;
        *(_WORD *)&unsigned char buf[12] = 2112;
        *(void *)&buf[14] = v327;
        *(_WORD *)&buf[22] = 2112;
        id v356 = v193;
        *(_WORD *)v357 = 2112;
        *(void *)&v357[2] = v194;
        *(_WORD *)&v357[10] = 2112;
        *(void *)&v357[12] = v195;
        _os_log_debug_impl((void *)&_mh_execute_header, v126, OS_LOG_TYPE_DEBUG, "WR: %@: %@: diagnostic %@ reports this dispatch queue, signpost starts on %@ and ends on %@, and start is at the exact time, so using that", buf, 0x34u);
      }
      *__error() = v125;
    }
    if (!byte_1000EBCF9 || dword_1000EB4A8 > 0) {
      goto LABEL_330;
    }
    int v334 = *__error();
    id v127 = [objc_msgSend(a3, "workflow") name];
    CFStringRef v128 = (const __CFString *)[a4 signpost].name;
    if (v128) {
      CFStringRef v129 = v128;
    }
    else {
      CFStringRef v129 = @"<entire workflow>";
    }
    CFStringRef v130 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"WR: %@: %@: diagnostic %@ reports this dispatch queue, signpost starts on %@ and ends on %@, and start is at the exact time, so using that", v127, v129, [a5 name], [v89 debugDescription], [v316 debugDescription]);
    CFStringRef v131 = v130;
    if (v130)
    {
      unsigned int v132 = (char *)CFStringGetCStringPtr(v130, 0x8000100u);
      if (v132)
      {
        uint64_t v133 = 0;
      }
      else
      {
        unsigned int v132 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x350E1AF7uLL);
        CFStringGetCString(v131, v132, 1024, 0x8000100u);
        uint64_t v133 = v132;
      }
      if (qword_1000EBD00) {
        unsigned int v171 = (FILE *)qword_1000EBD00;
      }
      else {
        unsigned int v171 = __stderrp;
      }
      fprintf(v171, "%s\n", v132);
      if (v133) {
        free(v133);
      }
      CFRelease(v131);
    }
    else
    {
      double v148 = sub_10002E548();
      if (os_log_type_enabled(v148, OS_LOG_TYPE_FAULT))
      {
        id v329 = [[objc_msgSend(a3, "workflow") name];
        CFStringRef v273 = (const __CFString *)[objc_msgSend(a4, "signpost") name];
        if (v273) {
          CFStringRef v274 = v273;
        }
        else {
          CFStringRef v274 = @"<entire workflow>";
        }
        id v275 = [a5 name];
        id v276 = [(id)v89 debugDescription];
        id v277 = [v316 debugDescription];
        *(_DWORD *)buf = 138413314;
        *(void *)&uint8_t buf[4] = v329;
        *(_WORD *)&unsigned char buf[12] = 2112;
        *(void *)&buf[14] = v274;
        *(_WORD *)&buf[22] = 2112;
        id v356 = v275;
        *(_WORD *)v357 = 2112;
        *(void *)&v357[2] = v276;
        *(_WORD *)&v357[10] = 2112;
        *(void *)&v357[12] = v277;
        _os_log_fault_impl((void *)&_mh_execute_header, v148, OS_LOG_TYPE_FAULT, "Unable to format: WR: %@: %@: diagnostic %@ reports this dispatch queue, signpost starts on %@ and ends on %@, and start is at the exact time, so using that", buf, 0x34u);
      }
      if (qword_1000EBD00) {
        int v149 = (FILE *)qword_1000EBD00;
      }
      else {
        int v149 = __stderrp;
      }
      fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v149);
    }
LABEL_329:
    *__error() = v334;
    goto LABEL_330;
  }
  if (byte_1000EBCF8)
  {
    int v333 = *__error();
    long long v111 = sub_10002E548();
    if (os_log_type_enabled(v111, OS_LOG_TYPE_DEFAULT))
    {
      id v326 = [[[a3 workflow] name];
      CFStringRef v112 = (const __CFString *)[a4 signpost].name;
      if (v112) {
        CFStringRef v113 = v112;
      }
      else {
        CFStringRef v113 = @"<entire workflow>";
      }
      id v114 = [a5 name];
      id v115 = [(id)v89 debugDescription];
      id v116 = [v316 debugDescription];
      *(_DWORD *)buf = 138413314;
      *(void *)&uint8_t buf[4] = v326;
      *(_WORD *)&unsigned char buf[12] = 2112;
      *(void *)&buf[14] = v113;
      *(_WORD *)&buf[22] = 2112;
      id v356 = v114;
      *(_WORD *)v357 = 2112;
      *(void *)&v357[2] = v115;
      *(_WORD *)&v357[10] = 2112;
      *(void *)&v357[12] = v116;
      _os_log_impl((void *)&_mh_execute_header, v111, OS_LOG_TYPE_DEFAULT, "WR: %@: %@: diagnostic %@ reports this dispatch queue, but signpost starts on %@ and ends on %@, neither at the exact right time, so not reporting", buf, 0x34u);
    }
    *__error() = v333;
  }
  if (byte_1000EBCF9 && dword_1000EB4A8 <= 2)
  {
    int v332 = *__error();
    id v117 = [objc_msgSend(a3, "workflow") name];
    CFStringRef v118 = (const __CFString *)[a4 signpost].name;
    if (v118) {
      CFStringRef v119 = v118;
    }
    else {
      CFStringRef v119 = @"<entire workflow>";
    }
    CFStringRef v120 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"WR: %@: %@: diagnostic %@ reports this dispatch queue, but signpost starts on %@ and ends on %@, neither at the exact right time, so not reporting", v117, v119, [a5 name], [v89 debugDescription], [v316 debugDescription]);
    CFStringRef v108 = v120;
    if (v120)
    {
      id v121 = (char *)CFStringGetCStringPtr(v120, 0x8000100u);
      if (v121)
      {
        __int16 v122 = 0;
      }
      else
      {
        id v121 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xDC7792EAuLL);
        CFStringGetCString(v108, v121, 1024, 0x8000100u);
        __int16 v122 = v121;
      }
      if (qword_1000EBD00) {
        id v172 = (FILE *)qword_1000EBD00;
      }
      else {
        id v172 = __stderrp;
      }
      fprintf(v172, "%s\n", v121);
      if (v122) {
        free(v122);
      }
      goto LABEL_282;
    }
    int v155 = sub_10002E548();
    if (os_log_type_enabled(v155, OS_LOG_TYPE_FAULT))
    {
      id v281 = [objc_msgSend(a3, "workflow") name];
      CFStringRef v282 = (const __CFString *)[objc_msgSend(a4, "signpost") name];
      if (v282) {
        CFStringRef v283 = v282;
      }
      else {
        CFStringRef v283 = @"<entire workflow>";
      }
      id v284 = [a5 name];
      id v285 = [(id)v89 debugDescription];
      id v286 = [v316 debugDescription];
      *(_DWORD *)buf = 138413314;
      *(void *)&uint8_t buf[4] = v281;
      *(_WORD *)&unsigned char buf[12] = 2112;
      *(void *)&buf[14] = v283;
      *(_WORD *)&buf[22] = 2112;
      id v356 = v284;
      *(_WORD *)v357 = 2112;
      *(void *)&v357[2] = v285;
      *(_WORD *)&v357[10] = 2112;
      *(void *)&v357[12] = v286;
      _os_log_fault_impl((void *)&_mh_execute_header, v155, OS_LOG_TYPE_FAULT, "Unable to format: WR: %@: %@: diagnostic %@ reports this dispatch queue, but signpost starts on %@ and ends on %@, neither at the exact right time, so not reporting", buf, 0x34u);
    }
    if (qword_1000EBD00) {
      int v156 = (FILE *)qword_1000EBD00;
    }
    else {
      int v156 = __stderrp;
    }
LABEL_244:
    fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v156);
LABEL_283:
    id v135 = __error();
    int v136 = v332;
LABEL_284:
    int *v135 = v136;
  }
LABEL_332:
  id v218 = [a5 reportSpindumpForDispatchQueueWithLabel];
  double v219 = v218;
  if (!v218) {
    return;
  }
  if ([v218 hasPrefix:@"^"]
    && [v219 hasSuffix:@"$"])
  {
    *(void *)CFStringRef v352 = 0;
    id v220 = [objc_alloc((Class)NSRegularExpression) initWithPattern:v219 options:0 error:v352];
    if (!v220)
    {
      if (byte_1000EBCF8)
      {
        int v221 = *__error();
        int v222 = sub_10002E548();
        if (os_log_type_enabled(v222, OS_LOG_TYPE_ERROR))
        {
          id v266 = [objc_msgSend(a3, "workflow") name];
          CFStringRef v267 = (const __CFString *)[objc_msgSend(a4, "signpost") name];
          if (v267) {
            CFStringRef v268 = v267;
          }
          else {
            CFStringRef v268 = @"<entire workflow>";
          }
          id v269 = [a5 name];
          *(_DWORD *)buf = 138413314;
          *(void *)&uint8_t buf[4] = v266;
          *(_WORD *)&unsigned char buf[12] = 2112;
          *(void *)&buf[14] = v268;
          *(_WORD *)&buf[22] = 2112;
          id v356 = v269;
          *(_WORD *)v357 = 2112;
          *(void *)&v357[2] = v219;
          *(_WORD *)&v357[10] = 2112;
          *(void *)&v357[12] = *(void *)v352;
          _os_log_error_impl((void *)&_mh_execute_header, v222, OS_LOG_TYPE_ERROR, "WR: %@: %@: diagnostic %@ reports dispatch queue %@, but regex failed to compile: %@", buf, 0x34u);
        }
        *__error() = v221;
      }
      if (byte_1000EBCF9 && dword_1000EB4A8 <= 3)
      {
        int v223 = *__error();
        id v224 = [objc_msgSend(a3, "workflow") name];
        CFStringRef v225 = (const __CFString *)[objc_msgSend(a4, "signpost") name];
        CFStringRef v226 = @"<entire workflow>";
        if (v225) {
          CFStringRef v227 = v225;
        }
        else {
          CFStringRef v227 = @"<entire workflow>";
        }
        id v228 = [a5 name];
        CFStringRef v229 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"WR: %@: %@: diagnostic %@ reports dispatch queue %@, but regex failed to compile: %@", v224, v227, v228, v219, *(void *)v352);
        CFStringRef v230 = v229;
        if (v229)
        {
          uint64_t v231 = (char *)CFStringGetCStringPtr(v229, 0x8000100u);
          if (v231)
          {
            int v232 = 0;
          }
          else
          {
            uint64_t v231 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xF2FD6954uLL);
            CFStringGetCString(v230, v231, 1024, 0x8000100u);
            int v232 = v231;
          }
          if (qword_1000EBD00) {
            CFStringRef v259 = (FILE *)qword_1000EBD00;
          }
          else {
            CFStringRef v259 = __stderrp;
          }
          fprintf(v259, "%s\n", v231);
          if (v232) {
            free(v232);
          }
          CFRelease(v230);
        }
        else
        {
          uint64_t v251 = sub_10002E548();
          if (os_log_type_enabled(v251, OS_LOG_TYPE_FAULT))
          {
            id v278 = [objc_msgSend(a3, "workflow") name];
            CFStringRef v279 = (const __CFString *)[objc_msgSend(objc_msgSend(a4, "signpost"), "name")];
            if (v279) {
              CFStringRef v226 = v279;
            }
            id v280 = [a5 name];
            *(_DWORD *)buf = 138413314;
            *(void *)&uint8_t buf[4] = v278;
            *(_WORD *)&unsigned char buf[12] = 2112;
            *(void *)&buf[14] = v226;
            *(_WORD *)&buf[22] = 2112;
            id v356 = v280;
            *(_WORD *)v357 = 2112;
            *(void *)&v357[2] = v219;
            *(_WORD *)&v357[10] = 2112;
            *(void *)&v357[12] = *(void *)v352;
            _os_log_fault_impl((void *)&_mh_execute_header, v251, OS_LOG_TYPE_FAULT, "Unable to format: WR: %@: %@: diagnostic %@ reports dispatch queue %@, but regex failed to compile: %@", buf, 0x34u);
          }
          if (qword_1000EBD00) {
            v252 = (FILE *)qword_1000EBD00;
          }
          else {
            v252 = __stderrp;
          }
          fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v252);
        }
        *__error() = v223;
      }
      return;
    }
  }
  else
  {
    id v220 = 0;
  }
  uint64_t v346 = 0;
  double v347 = &v346;
  uint64_t v348 = 0x3052000000;
  double v349 = sub_100036E28;
  v350 = sub_100036E38;
  uint64_t v351 = 0;
  id v233 = [a10 dispatchQueues];
  v339 = _NSConcreteStackBlock;
  uint64_t v340 = 3221225472;
  uint64_t v341 = (uint64_t)sub_10003BD30;
  double v342 = &unk_1000DCF00;
  id v343 = v220;
  int v344 = v219;
  v345 = &v346;
  [v233 enumerateKeysAndObjectsUsingBlock:&v339];
  id v234 = (void *)v347[5];
  if (v234)
  {
    memset(v352, 0, 64);
    id v235 = [v234 countByEnumeratingWithState:v352 objects:buf count:16];
    if (v235)
    {
      uint64_t v236 = **(void **)&v352[16];
      do
      {
        for (i = 0; i != v235; i = (char *)i + 1)
        {
          if (**(void **)&v352[16] != v236) {
            objc_enumerationMutation(v234);
          }
          sub_10003BC98(a1, a2, a6, (uint64_t)a9, (uint64_t)a10, *(void *)(*(void *)&v352[8] + 8 * i));
        }
        id v235 = [v234 countByEnumeratingWithState:v352 objects:buf count:16];
      }
      while (v235);
    }
  }
  else
  {
    if (byte_1000EBCF8)
    {
      int v238 = *__error();
      CFStringRef v239 = sub_10002E548();
      if (os_log_type_enabled(v239, OS_LOG_TYPE_ERROR))
      {
        id v253 = [objc_msgSend(a3, "workflow") name];
        CFStringRef v254 = (const __CFString *)[a4 signpost].name;
        if (v254) {
          CFStringRef v255 = v254;
        }
        else {
          CFStringRef v255 = @"<entire workflow>";
        }
        id v256 = [a5 name];
        id v257 = [a10 name];
        unsigned int v258 = [a10 pid];
        *(_DWORD *)buf = 138413570;
        *(void *)&uint8_t buf[4] = v253;
        *(_WORD *)&unsigned char buf[12] = 2112;
        *(void *)&buf[14] = v255;
        *(_WORD *)&buf[22] = 2112;
        id v356 = v256;
        *(_WORD *)v357 = 2112;
        *(void *)&v357[2] = v219;
        *(_WORD *)&v357[10] = 2112;
        *(void *)&v357[12] = v257;
        *(_WORD *)&v357[20] = 1024;
        *(_DWORD *)&v357[22] = v258;
        _os_log_error_impl((void *)&_mh_execute_header, v239, OS_LOG_TYPE_ERROR, "WR: %@: %@: diagnostic %@ reports dispatch queue %@, but %@ [%d] has no such dispatch queue", buf, 0x3Au);
      }
      *__error() = v238;
    }
    if (byte_1000EBCF9 && dword_1000EB4A8 <= 3)
    {
      int v240 = *__error();
      id v241 = [[objc_msgSend(a3, "workflow") name];
      CFStringRef v242 = (const __CFString *)[a4 signpost].name;
      if (v242) {
        CFStringRef v243 = v242;
      }
      else {
        CFStringRef v243 = @"<entire workflow>";
      }
      CFStringRef v244 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"WR: %@: %@: diagnostic %@ reports dispatch queue %@, but %@ [%d] has no such dispatch queue", v241, v243, [a5 name], v219, [a10 name], [a10 pid]);
      CFStringRef v245 = v244;
      if (v244)
      {
        uint64_t v246 = (char *)CFStringGetCStringPtr(v244, 0x8000100u);
        if (v246)
        {
          int v247 = 0;
        }
        else
        {
          uint64_t v246 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xD1CB472uLL);
          CFStringGetCString(v245, v246, 1024, 0x8000100u);
          int v247 = v246;
        }
        if (qword_1000EBD00) {
          uint64_t v250 = (FILE *)qword_1000EBD00;
        }
        else {
          uint64_t v250 = __stderrp;
        }
        fprintf(v250, "%s\n", v246);
        if (v247) {
          free(v247);
        }
        CFRelease(v245);
      }
      else
      {
        v248 = sub_10002E548();
        if (os_log_type_enabled(v248, OS_LOG_TYPE_FAULT))
        {
          id v260 = [[objc_msgSend(a3, "workflow") name];
          CFStringRef v261 = (const __CFString *)[a4 signpost].name;
          if (v261) {
            CFStringRef v262 = v261;
          }
          else {
            CFStringRef v262 = @"<entire workflow>";
          }
          id v263 = [a5 name];
          id v264 = [a10 name];
          unsigned int v265 = [a10 pid];
          *(_DWORD *)buf = 138413570;
          *(void *)&uint8_t buf[4] = v260;
          *(_WORD *)&unsigned char buf[12] = 2112;
          *(void *)&buf[14] = v262;
          *(_WORD *)&buf[22] = 2112;
          id v356 = v263;
          *(_WORD *)v357 = 2112;
          *(void *)&v357[2] = v219;
          *(_WORD *)&v357[10] = 2112;
          *(void *)&v357[12] = v264;
          *(_WORD *)&v357[20] = 1024;
          *(_DWORD *)&v357[22] = v265;
          _os_log_fault_impl((void *)&_mh_execute_header, v248, OS_LOG_TYPE_FAULT, "Unable to format: WR: %@: %@: diagnostic %@ reports dispatch queue %@, but %@ [%d] has no such dispatch queue", buf, 0x3Au);
        }
        if (qword_1000EBD00) {
          CFStringRef v249 = (FILE *)qword_1000EBD00;
        }
        else {
          CFStringRef v249 = __stderrp;
        }
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v249);
      }
      *__error() = v240;
    }
  }

  _Block_object_dispose(&v346, 8);
}

void sub_10003B71C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,char a35)
{
}

void sub_10003B79C(uint64_t a1, uint64_t a2, void *a3)
{
  v36[0] = 0;
  v36[1] = v36;
  v36[2] = 0x2020000000;
  char v37 = 0;
  uint64_t v30 = 0;
  BOOL v31 = &v30;
  uint64_t v32 = 0x3052000000;
  id v33 = sub_100036E28;
  CFStringRef v34 = sub_100036E38;
  uint64_t v35 = 0;
  uint64_t v24 = 0;
  CFStringRef v25 = &v24;
  uint64_t v26 = 0x3052000000;
  CFStringRef v27 = sub_100036E28;
  id v28 = sub_100036E38;
  uint64_t v29 = 0;
  id v5 = [*(id *)(a1 + 32) startTime];
  id v6 = [*(id *)(a1 + 32) endTime];
  v14[0] = _NSConcreteStackBlock;
  v14[1] = 3221225472;
  v14[2] = sub_10003BA88;
  v14[3] = &unk_1000DCEB0;
  long long v15 = *(_OWORD *)(a1 + 40);
  int v21 = &v30;
  id v22 = &v24;
  CFStringRef v23 = v36;
  uint64_t v16 = *(void *)(a1 + 32);
  long long v17 = *(_OWORD *)(a1 + 56);
  uint64_t v18 = *(void *)(a1 + 72);
  double v19 = a3;
  long long v20 = *(_OWORD *)(a1 + 80);
  [a3 enumerateThreadStatesBetweenStartTime:v5 startSampleIndex:0x7FFFFFFFFFFFFFFFLL endTime:v6 endSampleIndex:0x7FFFFFFFFFFFFFFFLL reverseOrder:0 block:v14];
  id v7 = (void *)v31[5];
  if (v7 && v25[5])
  {
    if ([v7 startTimestamp] > [*(id *)(a1 + 32) startTime]) {
    id v8 = [v31[5] startTimestamp];
}
    else
    }
      id v8 = [*(id *)(a1 + 32) startTime];
    id v9 = v8;
    if ([v31[5] endTimestamp] < [*(id *)(a1 + 32) endTime])id v10 = [v31[5] endTimestamp]; {
    else
    }
      id v10 = [*(id *)(a1 + 32) endTime];
    id v11 = v10;
    if (v9 == [*(id *)(a1 + 32) startTime] && v11 == objc_msgSend(*(id *)(a1 + 32), "endTime")) {
      id v12 = *(id *)(a1 + 32);
    }
    else {
      id v12 = +[SATimeRange timeRangeStart:v9 end:v11];
    }
    id v13 = [[SPWRReport alloc] initWithReportReason:*(void *)(a1 + 56) reportedSignpostTracker:*(void *)(a1 + 64) task:*(void *)(a1 + 72) timeRange:v12 thread:a3 dispatchQueue:0];
    [*(id *)(a1 + 80) addObject:v13];
  }
  _Block_object_dispose(&v24, 8);
  _Block_object_dispose(&v30, 8);
  _Block_object_dispose(v36, 8);
}

void sub_10003BA48(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, ...)
{
  va_start(va, a17);
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v17 - 128), 8);
  _Block_object_dispose((const void *)(v17 - 80), 8);
  _Unwind_Resume(a1);
}

void sub_10003BA88(uint64_t a1, void *a2)
{
  id v4 = [a2 name];
  if (v4)
  {
    id v5 = v4;
    id v6 = *(void **)(a1 + 32);
    if (!v6) {
      goto LABEL_27;
    }
    if (objc_msgSend(v6, "numberOfMatchesInString:options:range:", v4, 4, 0, objc_msgSend(v4, "length")))
    {
LABEL_6:
      *(unsigned char *)(*(void *)(*(void *)(a1 + 96) + 8) + 24) = 1;
      uint64_t v7 = *(void *)(*(void *)(a1 + 104) + 8);
      if (!*(void *)(v7 + 40)) {
        *(void *)(v7 + 40) = a2;
      }
      *(void *)(*(void *)(*(void *)(a1 + 112) + 8) + 40) = a2;
      return;
    }
    if (!*(void *)(a1 + 32))
    {
LABEL_27:
      if ([v5 isEqualToString:*(void *)(a1 + 40)]) {
        goto LABEL_6;
      }
    }
  }
  *(unsigned char *)(*(void *)(*(void *)(a1 + 120) + 8) + 24) = 1;
  id v8 = *(void **)(*(void *)(*(void *)(a1 + 104) + 8) + 40);
  if (v8 && *(void *)(*(void *)(*(void *)(a1 + 112) + 8) + 40))
  {
    if ([[v8 startTimestamp] gt:[*(id *)(*(void *)(*(void *)(a1 + 104) + 8) + 40) startTime]])id v9 = [[*(id *)(*(void *)(*(void *)(a1 + 104) + 8) + 40) startTimestamp]; {
    else
    }
      id v9 = [*(id *)(a1 + 48) startTime];
    id v10 = v9;
    if ([(*(id *)(*(void *)(*(void *)(a1 + 104) + 8) + 40)) endTimestamp] < [(*(id *)(a1 + 48)) endTime]) {
    else
    }
      id v11 = [*(id *)(a1 + 48) endTime];
    id v12 = v11;
    if (v10 == [*(id *)(a1 + 48) startTime] && v12 == objc_msgSend(*(id *)(a1 + 48), "endTime")) {
      id v13 = *(id *)(a1 + 48);
    }
    else {
      id v13 = +[SATimeRange timeRangeStart:v10 end:v12];
    }
    uint64_t v14 = [[SPWRReport alloc] initWithReportReason:*(void *)(a1 + 56) reportedSignpostTracker:*(void *)(a1 + 64) task:*(void *)(a1 + 72) timeRange:v13 thread:*(void *)(a1 + 80) dispatchQueue:0];
    [*(id *)(a1 + 88) addObject:v14];
  }
}

void sub_10003BC98(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v7 = [[SPWRReport alloc] initWithReportReason:a2 reportedSignpostTracker:a3 task:a5 timeRange:a4 thread:0 dispatchQueue:a6];
  [a1 addObject:v7];
}

id sub_10003BD30(void *a1, uint64_t a2, void *a3)
{
  id result = [a3 dispatchQueueLabel];
  if (!result) {
    return result;
  }
  id v6 = result;
  uint64_t v7 = (void *)a1[4];
  if (!v7) {
    goto LABEL_5;
  }
  id result = [v7 numberOfMatchesInString:result options:4 range:[result length]];
  if (!result)
  {
    if (a1[4]) {
      return result;
    }
LABEL_5:
    id result = [v6 isEqualToString:a1[5]];
    if (!result) {
      return result;
    }
  }
  id v8 = *(void **)(*(void *)(a1[6] + 8) + 40);
  if (v8)
  {
    return [v8 addObject:a3];
  }
  else
  {
    id result = [objc_alloc((Class)NSMutableArray) initWithObjects:a3, 0];
    *(void *)(*(void *)(a1[6] + 8) + 40) = result;
  }
  return result;
}

id sub_10003BE14(uint64_t a1, void *a2)
{
  id result = [objc_msgSend(a2, "name") isEqualToString:*(void *)(a1 + 32)];
  if (result)
  {
    id v5 = *(void **)(a1 + 40);
    return [v5 addObject:a2];
  }
  return result;
}

uint64_t sub_10003BE70(void *a1, uint64_t a2)
{
  objc_opt_class();
  if (objc_opt_isKindOfClass())
  {
    [a1 doubleValue];
    BOOL v5 = v4 < 0.0;
    if (v4 == 0.0)
    {
      uint64_t result = +[NSDecimalNumber zero];
    }
    else
    {
      double v7 = v4;
      double v8 = -v4;
      if (!v5) {
        double v8 = v7;
      }
      unsigned int v9 = vcvtpd_s64_f64(log10(v8));
      uint64_t v10 = llround(v7 * __exp10((double)(int)(3 - v9)));
      if (v10 >= 0) {
        uint64_t v11 = v10;
      }
      else {
        uint64_t v11 = -v10;
      }
      uint64_t result = +[NSDecimalNumber decimalNumberWithMantissa:v11 exponent:(__int16)(v9 - 3) isNegative:(unint64_t)v10 >> 63];
    }
    if ((void *)result != a1)
    {
      id v12 = *(uint64_t (**)(uint64_t, uint64_t))(a2 + 16);
      return v12(a2, result);
    }
  }
  else
  {
    objc_opt_class();
    if ((objc_opt_isKindOfClass() & 1) != 0
      || (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0)
      || (objc_opt_class(), uint64_t result = objc_opt_isKindOfClass(), (result & 1) != 0))
    {
      return sub_1000379D8(a1);
    }
  }
  return result;
}

id sub_10003BFE4(uint64_t a1, uint64_t a2)
{
  return [*(id *)(a1 + 32) setObject:a2 forKeyedSubscript:*(void *)(a1 + 40)];
}

id sub_10003BFF4(uint64_t a1, uint64_t a2)
{
  return [*(id *)(a1 + 32) setObject:a2 atIndexedSubscript:*(void *)(a1 + 40)];
}

id sub_10003C004(uint64_t a1, uint64_t a2)
{
  [*(id *)(a1 + 32) removeObject:*(void *)(a1 + 40)];
  double v4 = *(void **)(a1 + 32);

  return [v4 addObject:a2];
}

void sub_10003C04C(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_fault_impl(a1, a2, OS_LOG_TYPE_FAULT, a4, &a9, 0xCu);
}

uint64_t sub_10003C068(uint64_t result, uint64_t a2, int a3, float a4)
{
  *(float *)a2 = a4;
  *(void *)(a2 + 4) = result;
  *(_WORD *)(a2 + 12) = 1024;
  *(_DWORD *)(a2 + 14) = a3;
  *(_WORD *)(a2 + 1_Block_object_dispose(&STACK[0x378], 8) = 2080;
  return result;
}

uint64_t sub_10003C088(uint64_t result, uint64_t a2, uint64_t a3, float a4)
{
  *(float *)a3 = a4;
  *(void *)(a3 + 4) = result;
  *(_WORD *)(a3 + 12) = 2112;
  *(void *)(a3 + 14) = a2;
  return result;
}

void sub_10003C0A0(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_error_impl(a1, a2, OS_LOG_TYPE_ERROR, a4, &a9, 0xCu);
}

void sub_10003C0C8(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint8_t *a5)
{
  _os_log_fault_impl(a1, a2, OS_LOG_TYPE_FAULT, a4, a5, 0x16u);
}

void sub_10003C11C(uint64_t a1@<X8>)
{
  *(void *)(v1 - _Block_object_dispose(&STACK[0x378], 8) = a1;
}

void sub_10003C128(void *a1@<X0>, const char *a2@<X3>, uint8_t *a3@<X4>, NSObject *a4@<X8>)
{
  _os_log_error_impl(a1, a4, OS_LOG_TYPE_ERROR, a2, a3, 0x16u);
}

void sub_10003C15C(unint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, const char *a7, const char *a8, double a9, double a10, uint64_t a11)
{
  unint64_t v18 = HIDWORD(a1);
  memset(buffer, 0, sizeof(buffer));
  proc_name(a1, buffer, 0x80u);
  if ((a3 & 0x80000000) == 0)
  {
    if (byte_1000EBCF8)
    {
      int v19 = *__error();
      long long v20 = sub_10002E548();
      if (os_log_type_enabled(v20, OS_LOG_TYPE_INFO))
      {
        *(_DWORD *)buf = 136449282;
        *(void *)&uint8_t buf[4] = sub_10002E4E8(a3);
        *(_WORD *)&unsigned char buf[12] = 1024;
        *(_DWORD *)&buf[14] = a3;
        *(_WORD *)&buf[18] = 2082;
        *(void *)&buf[20] = buffer;
        *(_WORD *)&buf[28] = 1024;
        *(_DWORD *)&buf[30] = a1;
        *(_WORD *)&buf[34] = 1024;
        *(_DWORD *)&buf[36] = v18;
        *(_WORD *)&buf[40] = 2048;
        *(void *)&buf[42] = a4;
        *(_WORD *)&buf[50] = 2048;
        *(double *)&buf[52] = a9;
        *(_WORD *)&buf[60] = 2048;
        *(double *)&buf[62] = a10;
        *(_WORD *)&buf[70] = 2048;
        *(void *)&buf[72] = a5;
        *(_WORD *)&buf[80] = 2080;
        *(void *)&buf[82] = a6;
        *(_WORD *)&buf[90] = 2080;
        *(void *)&buf[92] = a7;
        __int16 v324 = 2080;
        int v325 = a8;
        __int16 v326 = 1024;
        BOOL v327 = a11 != 0;
        _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_INFO, "%{public}s [%d]: generate spindump: requested by %{public}s [%d] uid %d, thread:%#llx duration:%.3f interval:%.6f flags:%#llx reason:%s signature:%s filename:%s callback:%d", buf, 0x74u);
      }
      *__error() = v19;
    }
    if (byte_1000EBCF9) {
      BOOL v21 = dword_1000EB4A8 <= 1;
    }
    else {
      BOOL v21 = 0;
    }
    if (!v21) {
      goto LABEL_39;
    }
    int v22 = *__error();
    CFStringRef v23 = sub_10002E4E8(a3);
    CFStringRef v24 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%s [%d]: generate spindump: requested by %s [%d] uid %d, thread:%#llx duration:%.3f interval:%.6f flags:%#llx reason:%s signature:%s filename:%s callback:%d", v23, a3, buffer, a1, v18, a4, *(void *)&a9, *(void *)&a10, a5, a6, a7, a8, a11 != 0);
    if (!v24)
    {
      CFStringRef v25 = sub_10002E548();
      if (os_log_type_enabled(v25, OS_LOG_TYPE_FAULT))
      {
        uint64_t v26 = sub_10002E4E8(a3);
        *(_DWORD *)buf = 136318210;
        *(void *)&uint8_t buf[4] = v26;
        *(_WORD *)&unsigned char buf[12] = 1024;
        *(_DWORD *)&buf[14] = a3;
        *(_WORD *)&buf[18] = 2080;
        *(void *)&buf[20] = buffer;
        *(_WORD *)&buf[28] = 1024;
        *(_DWORD *)&buf[30] = a1;
        *(_WORD *)&buf[34] = 1024;
        *(_DWORD *)&buf[36] = v18;
        *(_WORD *)&buf[40] = 2048;
        *(void *)&buf[42] = a4;
        *(_WORD *)&buf[50] = 2048;
        *(double *)&buf[52] = a9;
        *(_WORD *)&buf[60] = 2048;
        *(double *)&buf[62] = a10;
        *(_WORD *)&buf[70] = 2048;
        *(void *)&buf[72] = a5;
        *(_WORD *)&buf[80] = 2080;
        *(void *)&buf[82] = a6;
        *(_WORD *)&buf[90] = 2080;
        *(void *)&buf[92] = a7;
        __int16 v324 = 2080;
        int v325 = a8;
        __int16 v326 = 1024;
        BOOL v327 = a11 != 0;
        CFStringRef v27 = "Unable to format: %s [%d]: generate spindump: requested by %s [%d] uid %d, thread:%#llx duration:%.3f inte"
              "rval:%.6f flags:%#llx reason:%s signature:%s filename:%s callback:%d";
        id v28 = v25;
        uint32_t v29 = 116;
LABEL_254:
        _os_log_fault_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_FAULT, v27, buf, v29);
        goto LABEL_34;
      }
      goto LABEL_34;
    }
    goto LABEL_24;
  }
  if (byte_1000EBCF8)
  {
    int v30 = *__error();
    BOOL v31 = sub_10002E548();
    if (os_log_type_enabled(v31, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 136448770;
      *(void *)&uint8_t buf[4] = buffer;
      *(_WORD *)&unsigned char buf[12] = 1024;
      *(_DWORD *)&buf[14] = a1;
      *(_WORD *)&buf[18] = 1024;
      *(_DWORD *)&buf[20] = v18;
      *(_WORD *)&unsigned char buf[24] = 2048;
      *(void *)&buf[26] = a4;
      *(_WORD *)&buf[34] = 2048;
      *(double *)&buf[36] = a9;
      *(_WORD *)&buf[44] = 2048;
      *(double *)&buf[46] = a10;
      *(_WORD *)&buf[54] = 2048;
      *(void *)&buf[56] = a5;
      *(_WORD *)&buf[64] = 2080;
      *(void *)&buf[66] = a6;
      *(_WORD *)&buf[74] = 2080;
      *(void *)&buf[76] = a7;
      *(_WORD *)&buf[84] = 2080;
      *(void *)&buf[86] = a8;
      *(_WORD *)&buf[94] = 1024;
      *(_DWORD *)&buf[96] = a11 != 0;
      _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_INFO, "generate spindump: requested by %{public}s [%d] uid %d, thread:%#llx duration:%.3f interval:%.6f flags:%#llx reason:%s signature:%s filename:%s callback:%d", buf, 0x64u);
    }
    *__error() = v30;
  }
  if (byte_1000EBCF9) {
    BOOL v32 = dword_1000EB4A8 <= 1;
  }
  else {
    BOOL v32 = 0;
  }
  if (v32)
  {
    int v22 = *__error();
    CFStringRef v24 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"generate spindump: requested by %s [%d] uid %d, thread:%#llx duration:%.3f interval:%.6f flags:%#llx reason:%s signature:%s filename:%s callback:%d", buffer, a1, v18, a4, *(void *)&a9, *(void *)&a10, a5, a6, a7, a8, a11 != 0);
    if (!v24)
    {
      id v38 = sub_10002E548();
      if (os_log_type_enabled(v38, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)buf = 136317698;
        *(void *)&uint8_t buf[4] = buffer;
        *(_WORD *)&unsigned char buf[12] = 1024;
        *(_DWORD *)&buf[14] = a1;
        *(_WORD *)&buf[18] = 1024;
        *(_DWORD *)&buf[20] = v18;
        *(_WORD *)&unsigned char buf[24] = 2048;
        *(void *)&buf[26] = a4;
        *(_WORD *)&buf[34] = 2048;
        *(double *)&buf[36] = a9;
        *(_WORD *)&buf[44] = 2048;
        *(double *)&buf[46] = a10;
        *(_WORD *)&buf[54] = 2048;
        *(void *)&buf[56] = a5;
        *(_WORD *)&buf[64] = 2080;
        *(void *)&buf[66] = a6;
        *(_WORD *)&buf[74] = 2080;
        *(void *)&buf[76] = a7;
        *(_WORD *)&buf[84] = 2080;
        *(void *)&buf[86] = a8;
        *(_WORD *)&buf[94] = 1024;
        *(_DWORD *)&buf[96] = a11 != 0;
        CFStringRef v27 = "Unable to format: generate spindump: requested by %s [%d] uid %d, thread:%#llx duration:%.3f interval:%.6f"
              " flags:%#llx reason:%s signature:%s filename:%s callback:%d";
        id v28 = v38;
        uint32_t v29 = 100;
        goto LABEL_254;
      }
LABEL_34:
      if (qword_1000EBD00) {
        id v39 = (FILE *)qword_1000EBD00;
      }
      else {
        id v39 = __stderrp;
      }
      fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v39);
LABEL_38:
      *__error() = v22;
      goto LABEL_39;
    }
LABEL_24:
    CFStringRef v33 = v24;
    CStringPtr = CFStringGetCStringPtr(v24, 0x8000100u);
    if (CStringPtr)
    {
      uint64_t v35 = (char *)CStringPtr;
      CFStringRef v36 = 0;
    }
    else
    {
      uint64_t v35 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x35FDA1C5uLL);
      CFStringGetCString(v33, v35, 1024, 0x8000100u);
      CFStringRef v36 = v35;
    }
    if (qword_1000EBD00) {
      char v37 = (FILE *)qword_1000EBD00;
    }
    else {
      char v37 = __stderrp;
    }
    fprintf(v37, "%s\n", v35);
    if (v36) {
      free(v36);
    }
    CFRelease(v33);
    goto LABEL_38;
  }
LABEL_39:
  if (a9 == 0.0) {
    a9 = 10.0;
  }
  if (a10 == 0.0) {
    double v40 = 0.01;
  }
  else {
    double v40 = a10;
  }
  *(_OWORD *)id v321 = 0u;
  long long v322 = 0u;
  memset(&v318, 0, sizeof(v318));
  time_t v317 = time(0);
  localtime_r(&v317, &v318);
  strftime(v321, 0x20uLL, "%Y-%m-%d-%T", &v318);
  uint64_t v41 = (char *)malloc_type_calloc(1uLL, 0x400uLL, 0x971D7D68uLL);
  int v42 = v41;
  if (!a8 || !*a8) {
    a8 = (const char *)buffer;
  }
  if (snprintf(v41, 0x400uLL, "/var/mobile/Library/Logs/CrashReporter/%s.%s.spindump.txt", a8, v321) < 0x400)
  {
    CFStringRef v43 = (char *)malloc_type_calloc(1uLL, 0x400uLL, 0xE6F55970uLL);
    if (dirname_r(v42, v43))
    {
      int v44 = (char *)malloc_type_calloc(1uLL, 0x400uLL, 0xA63C2646uLL);
      if (basename_r(v42, v44))
      {
        int v45 = realpath_DARWIN_EXTSN(v43, 0);
        if (v45)
        {
          id v46 = v45;
          int v47 = realpath_DARWIN_EXTSN("/var/mobile/Library/Logs/CrashReporter", 0);
          if (v47)
          {
            id v52 = v47;
            if (strcmp("/", v47))
            {
              id v302 = v44;
              if ((a3 & 0x80000000) != 0)
              {
                if (byte_1000EBCF8)
                {
                  int v73 = *__error();
                  int v74 = sub_10002E548();
                  if (os_log_type_enabled(v74, OS_LOG_TYPE_DEBUG))
                  {
                    *(_DWORD *)buf = 136315906;
                    *(void *)&uint8_t buf[4] = v43;
                    *(_WORD *)&unsigned char buf[12] = 2080;
                    *(void *)&buf[14] = v302;
                    *(_WORD *)&buf[22] = 2080;
                    *(void *)&unsigned char buf[24] = v46;
                    *(_WORD *)&buf[32] = 2080;
                    *(void *)&buf[34] = v52;
                    _os_log_debug_impl((void *)&_mh_execute_header, v74, OS_LOG_TYPE_DEBUG, "dir %s, fullfilename %s, realDir %s, expectedRealDir %s", buf, 0x2Au);
                  }
                  *__error() = v73;
                }
                CFStringRef v55 = v302;
                if (byte_1000EBCF9 && dword_1000EB4A8 <= 0)
                {
                  int v75 = *__error();
                  CFStringRef v76 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"dir %s, fullfilename %s, realDir %s, expectedRealDir %s", v43, v302, v46, v52);
                  if (!v76)
                  {
                    id v139 = sub_10002E548();
                    if (os_log_type_enabled(v139, OS_LOG_TYPE_FAULT))
                    {
                      *(_DWORD *)buf = 136315906;
                      *(void *)&uint8_t buf[4] = v43;
                      *(_WORD *)&unsigned char buf[12] = 2080;
                      *(void *)&buf[14] = v302;
                      *(_WORD *)&buf[22] = 2080;
                      *(void *)&unsigned char buf[24] = v46;
                      *(_WORD *)&buf[32] = 2080;
                      *(void *)&buf[34] = v52;
                      _os_log_fault_impl((void *)&_mh_execute_header, v139, OS_LOG_TYPE_FAULT, "Unable to format: dir %s, fullfilename %s, realDir %s, expectedRealDir %s", buf, 0x2Au);
                    }
                    if (qword_1000EBD00) {
                      CFStringRef v140 = (FILE *)qword_1000EBD00;
                    }
                    else {
                      CFStringRef v140 = __stderrp;
                    }
                    fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v140);
                    goto LABEL_116;
                  }
                  CFStringRef v58 = v76;
                  int v301 = v75;
                  goto LABEL_86;
                }
              }
              else
              {
                if (byte_1000EBCF8)
                {
                  int v53 = *__error();
                  CFStringRef v54 = sub_10002E548();
                  if (os_log_type_enabled(v54, OS_LOG_TYPE_DEBUG))
                  {
                    int v156 = sub_10002E4E8(a3);
                    *(_DWORD *)buf = 136447490;
                    *(void *)&uint8_t buf[4] = v156;
                    *(_WORD *)&unsigned char buf[12] = 1024;
                    *(_DWORD *)&buf[14] = a3;
                    *(_WORD *)&buf[18] = 2080;
                    *(void *)&buf[20] = v43;
                    *(_WORD *)&buf[28] = 2080;
                    *(void *)&buf[30] = v302;
                    *(_WORD *)&buf[38] = 2080;
                    *(void *)&buf[40] = v46;
                    *(_WORD *)&buf[48] = 2080;
                    *(void *)&buf[50] = v52;
                    _os_log_debug_impl((void *)&_mh_execute_header, v54, OS_LOG_TYPE_DEBUG, "%{public}s [%d]: dir %s, fullfilename %s, realDir %s, expectedRealDir %s", buf, 0x3Au);
                  }
                  *__error() = v53;
                }
                CFStringRef v55 = v302;
                if (byte_1000EBCF9 && dword_1000EB4A8 <= 0)
                {
                  int v301 = *__error();
                  id v56 = sub_10002E4E8(a3);
                  CFStringRef v57 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%s [%d]: dir %s, fullfilename %s, realDir %s, expectedRealDir %s", v56, a3, v43, v302, v46, v52);
                  if (!v57)
                  {
                    uint64_t v89 = sub_10002E548();
                    if (os_log_type_enabled(v89, OS_LOG_TYPE_FAULT))
                    {
                      CFStringRef v165 = sub_10002E4E8(a3);
                      *(_DWORD *)buf = 136316418;
                      *(void *)&uint8_t buf[4] = v165;
                      *(_WORD *)&unsigned char buf[12] = 1024;
                      *(_DWORD *)&buf[14] = a3;
                      *(_WORD *)&buf[18] = 2080;
                      *(void *)&buf[20] = v43;
                      *(_WORD *)&buf[28] = 2080;
                      *(void *)&buf[30] = v302;
                      *(_WORD *)&buf[38] = 2080;
                      *(void *)&buf[40] = v46;
                      *(_WORD *)&buf[48] = 2080;
                      *(void *)&buf[50] = v52;
                      _os_log_fault_impl((void *)&_mh_execute_header, v89, OS_LOG_TYPE_FAULT, "Unable to format: %s [%d]: dir %s, fullfilename %s, realDir %s, expectedRealDir %s", buf, 0x3Au);
                    }
                    if (qword_1000EBD00) {
                      unint64_t v90 = (FILE *)qword_1000EBD00;
                    }
                    else {
                      unint64_t v90 = __stderrp;
                    }
                    fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v90);
                    goto LABEL_115;
                  }
                  CFStringRef v58 = v57;
LABEL_86:
                  CFStringRef v300 = v42;
                  id v77 = CFStringGetCStringPtr(v58, 0x8000100u);
                  if (v77)
                  {
                    CFStringRef v78 = (char *)v77;
                    CFStringRef v79 = 0;
                  }
                  else
                  {
                    CFStringRef v78 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x886D6286uLL);
                    CFStringGetCString(v58, v78, 1024, 0x8000100u);
                    CFStringRef v79 = v78;
                  }
                  if (qword_1000EBD00) {
                    unsigned int v91 = (FILE *)qword_1000EBD00;
                  }
                  else {
                    unsigned int v91 = __stderrp;
                  }
                  fprintf(v91, "%s\n", v78);
                  if (v79) {
                    free(v79);
                  }
                  CFRelease(v58);
                  int v42 = v300;
LABEL_115:
                  int v75 = v301;
LABEL_116:
                  *__error() = v75;
                  CFStringRef v55 = v302;
                }
              }
              int v92 = strcmp(v52, v46);
              free(v43);
              free(v52);
              if (!v92)
              {
                unsigned int v93 = snprintf(v42, 0x400uLL, "%s/%s", v46, v55);
                free(v55);
                free(v46);
                if (v93 < 0x400)
                {
                  int v316 = 0;
                  if (a6) {
                    asprintf(&v316, "Requested by %s [%d] - %s");
                  }
                  else {
                    asprintf(&v316, "Requested by %s [%d]");
                  }
                  if ((a5 & 0x80) == 0)
                  {
                    id v94 = v42;
                    SAMachAbsTimeSecondsGetCurrent();
                    double v96 = v95;
                    if ((a5 & 0x20) != 0) {
                      unsigned __int8 v97 = 2;
                    }
                    else {
                      unsigned __int8 v97 = 3;
                    }
                    if ((a5 & 0x40) != 0) {
                      unint64_t v98 = 384;
                    }
                    else {
                      unint64_t v98 = 385;
                    }
                    if (a7) {
                      id v99 = strdup(a7);
                    }
                    else {
                      id v99 = 0;
                    }
                    double v105 = a9 + v96;
                    if (a11) {
                      qos_class_t v106 = qos_class_self();
                    }
                    else {
                      qos_class_t v106 = QOS_CLASS_BACKGROUND;
                    }
                    dispatch_queue_global_t global_queue = dispatch_get_global_queue(v106, 0);
                    v306[0] = _NSConcreteStackBlock;
                    v306[1] = 3221225472;
                    v306[2] = sub_10003EE60;
                    v306[3] = &unk_1000DCFA0;
                    int v307 = a3;
                    v306[6] = v99;
                    v306[7] = a5;
                    v306[8] = v42;
                    v306[4] = a11;
                    v306[5] = v316;
                    unint64_t v308 = a1;
                    int v309 = a2;
                    if (sub_10006BED8(a3, (v40 * 1000000.0), 0, v97, 0, v98, (uint64_t)global_queue, (uint64_t)v306, v105))
                    {
                      return;
                    }
                    if ((a3 & 0x80000000) != 0)
                    {
                      if (byte_1000EBCF8)
                      {
                        int v141 = *__error();
                        CFStringRef v142 = sub_10002E548();
                        if (os_log_type_enabled(v142, OS_LOG_TYPE_ERROR)) {
                          sub_10008463C();
                        }
                        *__error() = v141;
                      }
                      if (!byte_1000EBCF9 || dword_1000EB4A8 > 3) {
                        goto LABEL_264;
                      }
                      int v111 = *__error();
                      uint64_t v143 = *__error();
                      long long v144 = __error();
                      id v145 = strerror(*v144);
                      CFStringRef v146 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"generate spindump: unable to sample process: %d (%s)", v143, v145);
                      if (!v146)
                      {
                        int v161 = sub_10002E548();
                        if (os_log_type_enabled(v161, OS_LOG_TYPE_FAULT)) {
                          sub_1000845B4();
                        }
                        if (qword_1000EBD00) {
                          id v162 = (FILE *)qword_1000EBD00;
                        }
                        else {
                          id v162 = __stderrp;
                        }
                        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v162);
                        goto LABEL_263;
                      }
                      CFStringRef v147 = v146;
                      double v148 = CFStringGetCStringPtr(v146, 0x8000100u);
                      if (v148)
                      {
                        int v149 = (char *)v148;
                        CFStringRef v150 = 0;
                      }
                      else
                      {
                        int v149 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xE6E8C840uLL);
                        CFStringGetCString(v147, v149, 1024, 0x8000100u);
                        CFStringRef v150 = v149;
                      }
                      if (qword_1000EBD00) {
                        CFStringRef v163 = (FILE *)qword_1000EBD00;
                      }
                      else {
                        CFStringRef v163 = __stderrp;
                      }
                      fprintf(v163, "%s\n", v149);
                      if (v150) {
                        free(v150);
                      }
                      CFStringRef v160 = v147;
                    }
                    else
                    {
                      if (byte_1000EBCF8)
                      {
                        int v109 = *__error();
                        id v110 = sub_10002E548();
                        if (os_log_type_enabled(v110, OS_LOG_TYPE_ERROR)) {
                          sub_10008450C();
                        }
                        *__error() = v109;
                      }
                      if (!byte_1000EBCF9 || dword_1000EB4A8 > 3) {
                        goto LABEL_264;
                      }
                      int v111 = *__error();
                      CFStringRef v112 = sub_10002E4E8(a3);
                      uint64_t v113 = *__error();
                      id v114 = __error();
                      id v115 = strerror(*v114);
                      CFStringRef v116 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%s [%d]: generate spindump: unable to sample process: %d (%s)", v112, a3, v113, v115);
                      if (!v116)
                      {
                        CFStringRef v157 = sub_10002E548();
                        if (os_log_type_enabled(v157, OS_LOG_TYPE_FAULT)) {
                          sub_100084464();
                        }
                        if (qword_1000EBD00) {
                          CFStringRef v158 = (FILE *)qword_1000EBD00;
                        }
                        else {
                          CFStringRef v158 = __stderrp;
                        }
                        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v158);
                        int v42 = v94;
                        goto LABEL_263;
                      }
                      CFStringRef v117 = v116;
                      CFStringRef v118 = CFStringGetCStringPtr(v116, 0x8000100u);
                      if (v118)
                      {
                        CFStringRef v119 = (char *)v118;
                        CFStringRef v120 = 0;
                      }
                      else
                      {
                        CFStringRef v119 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xE6E8C840uLL);
                        CFStringGetCString(v117, v119, 1024, 0x8000100u);
                        CFStringRef v120 = v119;
                      }
                      int v42 = v94;
                      if (qword_1000EBD00) {
                        id v159 = (FILE *)qword_1000EBD00;
                      }
                      else {
                        id v159 = __stderrp;
                      }
                      fprintf(v159, "%s\n", v119);
                      if (v120) {
                        free(v120);
                      }
                      CFStringRef v160 = v117;
                    }
                    CFRelease(v160);
LABEL_263:
                    *__error() = v111;
LABEL_264:
                    if (a11)
                    {
                      CFStringRef v164 = __error();
                      (*(void (**)(uint64_t, void, void))(a11 + 16))(a11, *v164, 0);
                    }
                    free(v42);
                    if (v316) {
                      free(v316);
                    }
                    if (v99) {
                      free(v99);
                    }
                    return;
                  }
                  id v100 = v316;
                  v310[0] = _NSConcreteStackBlock;
                  v310[1] = 3221225472;
                  CFStringRef v311 = sub_10003EDE8;
                  id v312 = &unk_1000DCF78;
                  id v314 = v42;
                  int v315 = v316;
                  uint64_t v313 = a11;
                  unsigned int v101 = 2;
                  int v102 = (char **)malloc_type_calloc(2uLL, 8uLL, 0x10040436913F5uLL);
                  id v103 = v102;
                  uint64_t v320 = 0;
                  FILE *v102 = "/usr/sbin/spindump";
                  v102[1] = "-noIPC";
                  if ((a3 & 0x80000000) != 0)
                  {
                    int v104 = 0;
                  }
                  else
                  {
                    id v103 = (char **)malloc_type_realloc(v102, 0x18uLL, 0x10040436913F5uLL);
                    asprintf(v103 + 2, "%d", a3);
                    unsigned int v101 = 3;
                    int v104 = 4;
                  }
                  CFStringRef v107 = v42;
                  if (a4)
                  {
                    id v103 = (char **)malloc_type_realloc(v103, 8 * v101 + 16, 0x10040436913F5uLL);
                    v103[v101] = "-targetThreadID";
                    asprintf(&v103[v101 + 1], "%d", a3);
                    v104 |= 2 << v101;
                    v101 += 2;
                  }
                  uint64_t v121 = v101 + 2;
                  __int16 v122 = (char **)malloc_type_realloc(v103, 8 * v121, 0x10040436913F5uLL);
                  if (round(a9) <= 0.0) {
                    double v123 = 1.0;
                  }
                  else {
                    double v123 = a9;
                  }
                  asprintf(&v122[v101], "%.0f", v123);
                  double v124 = v40 * 1000000.0;
                  if (round(v40 * 1000000.0) <= 0.0) {
                    double v124 = 1.0;
                  }
                  asprintf(&v122[v101 + 1], "%.0fu", v124);
                  LOBYTE(v320) = (3 << v101) | v104;
                  if (a5)
                  {
                    if ((a5 & 2) != 0)
                    {
LABEL_158:
                      __int16 v122 = (char **)malloc_type_realloc(v122, 8 * (v121 + 1), 0x10040436913F5uLL);
                      v122[v121] = "-noText";
                      LODWORD(v121) = v121 + 1;
                      if ((a5 & 4) != 0) {
                        goto LABEL_159;
                      }
                      goto LABEL_166;
                    }
                  }
                  else
                  {
                    __int16 v122 = (char **)malloc_type_realloc(v122, 8 * (v101 + 3), 0x10040436913F5uLL);
                    v122[v121] = "-timeline";
                    LODWORD(v121) = v101 + 3;
                    if ((a5 & 2) != 0) {
                      goto LABEL_158;
                    }
                  }
                  if ((a5 & 4) != 0)
                  {
LABEL_159:
                    __int16 v122 = (char **)malloc_type_realloc(v122, 8 * (v121 + 1), 0x10040436913F5uLL);
                    v122[v121] = "-noBinary";
                    LODWORD(v121) = v121 + 1;
                    if ((a5 & 8) != 0) {
                      goto LABEL_160;
                    }
                    goto LABEL_167;
                  }
LABEL_166:
                  if ((a5 & 8) != 0)
                  {
LABEL_160:
                    __int16 v122 = (char **)malloc_type_realloc(v122, 8 * (v121 + 1), 0x10040436913F5uLL);
                    v122[v121] = "-noSymbolicate";
                    LODWORD(v121) = v121 + 1;
                    if ((a5 & 0x20) != 0) {
                      goto LABEL_161;
                    }
                    goto LABEL_168;
                  }
LABEL_167:
                  if ((a5 & 0x20) != 0)
                  {
LABEL_161:
                    __int16 v122 = (char **)malloc_type_realloc(v122, 8 * (v121 + 1), 0x10040436913F5uLL);
                    v122[v121] = "-onlyTarget";
                    LODWORD(v121) = v121 + 1;
                    if ((a5 & 0x40) != 0) {
                      goto LABEL_162;
                    }
                    goto LABEL_169;
                  }
LABEL_168:
                  if ((a5 & 0x40) != 0)
                  {
LABEL_162:
                    __int16 v122 = (char **)malloc_type_realloc(v122, 8 * (v121 + 1), 0x10040436913F5uLL);
                    v122[v121] = "-sampleWithoutTarget";
                    LODWORD(v121) = v121 + 1;
                    if (!v100) {
                      goto LABEL_171;
                    }
                    goto LABEL_170;
                  }
LABEL_169:
                  if (!v100)
                  {
LABEL_171:
                    if (a7)
                    {
                      __int16 v122 = (char **)malloc_type_realloc(v122, 8 * (v121 + 2), 0x10040436913F5uLL);
                      v122[v121] = "-signature";
                      v122[(v121 + 1)] = (char *)a7;
                      LODWORD(v121) = v121 + 2;
                    }
                    if (v107)
                    {
                      uint64_t v125 = (v121 + 2);
                      __int16 v122 = (char **)malloc_type_realloc(v122, 8 * v125, 0x10040436913F5uLL);
                      v122[v121] = "-o";
                      v122[(v121 + 1)] = v107;
                      LODWORD(v121) = v121 + 2;
                    }
                    else
                    {
                      uint64_t v125 = v121;
                    }
                    uint64_t v126 = malloc_type_realloc(v122, 8 * (v121 + 1), 0x10040436913F5uLL);
                    v126[v125] = 0;
                    id v127 = (const void **)_NSGetEnviron();
                    unsigned int v128 = 1;
                    do
                      uint64_t v129 = v128++ - 1;
                    while (*((void *)*v127 + v129));
                    CFStringRef v130 = malloc_type_malloc(8 * v128, 0x10040436913F5uLL);
                    memmove(v130, *v127, 8 * v129);
                    *((void *)v130 + v129) = "XPC_NULL_BOOTSTRAP=1";
                    *((void *)v130 + v128 - 1) = 0;
                    int v319 = 0;
                    int v131 = SASpawnPlatformBinaryWithSigningIdentifier();
                    free(v130);
                    if ((v121 & 0x80000000) == 0)
                    {
                      uint64_t v132 = 0;
                      do
                      {
                        if ((v321[(v132 >> 3) - 8] >> (v132 & 7))) {
                          free((void *)v126[v132]);
                        }
                        ++v132;
                      }
                      while (v121 + 1 != v132);
                    }
                    free(v126);
                    if (v131 < 1)
                    {
                      int v136 = __error();
                      ((void (*)(void *, void, void))v311)(v310, *v136, 0);
                    }
                    else
                    {
                      qos_class_t v133 = qos_class_self();
                      id v134 = dispatch_get_global_queue(v133, 0);
                      id v135 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_proc, v131, 0x80000000uLL, v134);
                      *(void *)buf = _NSConcreteStackBlock;
                      *(void *)&uint8_t buf[8] = 3221225472;
                      *(void *)&buf[16] = sub_100045EC4;
                      *(void *)&unsigned char buf[24] = &unk_1000DD040;
                      *(_DWORD *)&buf[48] = v131;
                      *(_DWORD *)&buf[52] = v319;
                      *(void *)&buf[32] = v135;
                      *(void *)&buf[40] = v310;
                      dispatch_source_set_event_handler(v135, buf);
                      dispatch_activate(v135);
                    }
                    return;
                  }
LABEL_170:
                  __int16 v122 = (char **)malloc_type_realloc(v122, 8 * (v121 + 2), 0x10040436913F5uLL);
                  v122[v121] = "-reason";
                  v122[(v121 + 1)] = v100;
                  LODWORD(v121) = v121 + 2;
                  goto LABEL_171;
                }
                int v235 = *__error();
                uint64_t v236 = sub_10002E548();
                BOOL v237 = os_log_type_enabled(v236, OS_LOG_TYPE_FAULT);
                if ((a3 & 0x80000000) != 0)
                {
                  if (v237) {
                    sub_10008482C();
                  }
                  *__error() = v235;
                  int v238 = v42;
                  if (!byte_1000EBCF9 || dword_1000EB4A8 > 4) {
                    goto LABEL_489;
                  }
                  int v239 = *__error();
                  CFStringRef v241 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"generate spindump: filepath %s too large", v42);
                  if (!v241)
                  {
                    id v295 = sub_10002E548();
                    if (os_log_type_enabled(v295, OS_LOG_TYPE_FAULT)) {
                      sub_1000847C4();
                    }
                    goto LABEL_484;
                  }
                }
                else
                {
                  if (v237) {
                    sub_100084744();
                  }
                  *__error() = v235;
                  int v238 = v42;
                  if (!byte_1000EBCF9 || dword_1000EB4A8 > 4) {
                    goto LABEL_489;
                  }
                  int v239 = *__error();
                  int v240 = sub_10002E4E8(a3);
                  CFStringRef v241 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%s [%d]: generate spindump: filepath %s too large", v240, a3, v42);
                  if (!v241)
                  {
                    CFStringRef v242 = sub_10002E548();
                    if (os_log_type_enabled(v242, OS_LOG_TYPE_FAULT)) {
                      sub_1000846C4();
                    }
LABEL_484:
                    if (qword_1000EBD00) {
                      id v296 = (FILE *)qword_1000EBD00;
                    }
                    else {
                      id v296 = __stderrp;
                    }
                    fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v296);
LABEL_488:
                    *__error() = v239;
                    int v238 = v42;
LABEL_489:
                    id v297 = v238;
                    goto LABEL_500;
                  }
                }
                CFStringRef v256 = v241;
                id v257 = CFStringGetCStringPtr(v241, 0x8000100u);
                if (v257)
                {
                  unsigned int v258 = (char *)v257;
                  CFStringRef v259 = 0;
                }
                else
                {
                  unsigned int v258 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xCA570F56uLL);
                  CFStringGetCString(v256, v258, 1024, 0x8000100u);
                  CFStringRef v259 = v258;
                }
                if (qword_1000EBD00) {
                  CFStringRef v289 = (FILE *)qword_1000EBD00;
                }
                else {
                  CFStringRef v289 = __stderrp;
                }
                fprintf(v289, "%s\n", v258);
                if (v259) {
                  free(v259);
                }
                CFRelease(v256);
                goto LABEL_488;
              }
              int v224 = *__error();
              CFStringRef v225 = sub_10002E548();
              BOOL v226 = os_log_type_enabled(v225, OS_LOG_TYPE_FAULT);
              if ((a3 & 0x80000000) != 0)
              {
                if (v226) {
                  sub_1000849FC();
                }
                *__error() = v224;
                CFStringRef v227 = v42;
                if (!byte_1000EBCF9 || dword_1000EB4A8 > 4) {
                  goto LABEL_499;
                }
                int v228 = *__error();
                CFStringRef v251 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"generate spindump: filepath %s not in /var/mobile/Library/Logs/CrashReporter", v42);
                if (v251)
                {
                  CFStringRef v252 = v251;
                  id v253 = CFStringGetCStringPtr(v251, 0x8000100u);
                  if (v253)
                  {
                    CFStringRef v254 = (char *)v253;
                    CFStringRef v255 = 0;
                  }
                  else
                  {
                    CFStringRef v254 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xC3BC4965uLL);
                    CFStringGetCString(v252, v254, 1024, 0x8000100u);
                    CFStringRef v255 = v254;
                  }
                  if (qword_1000EBD00) {
                    id v298 = (FILE *)qword_1000EBD00;
                  }
                  else {
                    id v298 = __stderrp;
                  }
                  fprintf(v298, "%s\n", v254);
                  if (v255) {
                    free(v255);
                  }
                  CFStringRef v292 = v252;
                  goto LABEL_497;
                }
                CFStringRef v293 = sub_10002E548();
                if (os_log_type_enabled(v293, OS_LOG_TYPE_FAULT)) {
                  sub_100084994();
                }
              }
              else
              {
                if (v226) {
                  sub_100084914();
                }
                *__error() = v224;
                CFStringRef v227 = v42;
                if (!byte_1000EBCF9 || dword_1000EB4A8 > 4) {
                  goto LABEL_499;
                }
                int v228 = *__error();
                CFStringRef v229 = sub_10002E4E8(a3);
                CFStringRef v230 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%s [%d]: generate spindump: filepath %s not in /var/mobile/Library/Logs/CrashReporter", v229, a3, v42);
                if (v230)
                {
                  CFStringRef v231 = v230;
                  int v232 = CFStringGetCStringPtr(v230, 0x8000100u);
                  if (v232)
                  {
                    id v233 = (char *)v232;
                    id v234 = 0;
                  }
                  else
                  {
                    id v233 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xC3BC4965uLL);
                    CFStringGetCString(v231, v233, 1024, 0x8000100u);
                    id v234 = v233;
                  }
                  if (qword_1000EBD00) {
                    id v291 = (FILE *)qword_1000EBD00;
                  }
                  else {
                    id v291 = __stderrp;
                  }
                  fprintf(v291, "%s\n", v233);
                  if (v234) {
                    free(v234);
                  }
                  CFStringRef v292 = v231;
LABEL_497:
                  CFRelease(v292);
LABEL_498:
                  *__error() = v228;
                  CFStringRef v227 = v42;
LABEL_499:
                  free(v46);
                  free(v302);
                  id v297 = v227;
LABEL_500:
                  free(v297);
                  if (a11) {
                    (*(void (**)(uint64_t, uint64_t, void))(a11 + 16))(a11, 22, 0);
                  }
                  return;
                }
                CFStringRef v288 = sub_10002E548();
                if (os_log_type_enabled(v288, OS_LOG_TYPE_FAULT)) {
                  sub_100084894();
                }
              }
              if (qword_1000EBD00) {
                CFStringRef v294 = (FILE *)qword_1000EBD00;
              }
              else {
                CFStringRef v294 = __stderrp;
              }
              fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v294);
              goto LABEL_498;
            }
            if ((a3 & 0x80000000) != 0)
            {
              if (byte_1000EBCF8)
              {
                int v211 = *__error();
                CFStringRef v212 = sub_10002E548();
                if (os_log_type_enabled(v212, OS_LOG_TYPE_ERROR)) {
                  sub_1000843E0(v212);
                }
                *__error() = v211;
              }
              if (byte_1000EBCF9 && dword_1000EB4A8 <= 3)
              {
                int v213 = *__error();
                CFStringRef v214 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%s: expectedRealDir of / (from /var/mobile/Library/Logs/CrashReporter)", "0 != strcmp(\"/\", expectedRealDir)");
                if (v214)
                {
                  CFStringRef v273 = v214;
                  CFStringRef v274 = CFStringGetCStringPtr(v214, 0x8000100u);
                  if (v274)
                  {
                    id v275 = (char *)v274;
                    id v276 = 0;
                  }
                  else
                  {
                    id v275 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x2ED733D5uLL);
                    CFStringGetCString(v273, v275, 1024, 0x8000100u);
                    id v276 = v275;
                  }
                  if (qword_1000EBD00) {
                    id v287 = (FILE *)qword_1000EBD00;
                  }
                  else {
                    id v287 = __stderrp;
                  }
                  fprintf(v287, "%s\n", v275);
                  if (v276) {
                    free(v276);
                  }
                  CFRelease(v273);
                }
                else
                {
                  id v215 = sub_10002E548();
                  if (os_log_type_enabled(v215, OS_LOG_TYPE_FAULT)) {
                    sub_100084368(v215, v216, v217, v218, v219, v220, v221, v222);
                  }
                  if (qword_1000EBD00) {
                    int v223 = (FILE *)qword_1000EBD00;
                  }
                  else {
                    int v223 = __stderrp;
                  }
                  fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v223);
                }
                *__error() = v213;
              }
              CFStringRef v299 = "0 != strcmp(\"/\", expectedRealDir)";
              CFStringRef v283 = "%s: expectedRealDir of / (from /var/mobile/Library/Logs/CrashReporter)";
            }
            else
            {
              if (byte_1000EBCF8)
              {
                int v191 = *__error();
                CFStringRef v192 = sub_10002E548();
                if (os_log_type_enabled(v192, OS_LOG_TYPE_ERROR)) {
                  sub_1000842E4();
                }
                *__error() = v191;
              }
              if (byte_1000EBCF9 && dword_1000EB4A8 <= 3)
              {
                int v193 = *__error();
                id v194 = sub_10002E4E8(a3);
                CFStringRef v195 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%s [%d]: %s: expectedRealDir of / (from /var/mobile/Library/Logs/CrashReporter)", v194, a3, "0 != strcmp(\"/\", expectedRealDir)");
                if (v195)
                {
                  CFStringRef v269 = v195;
                  id v270 = CFStringGetCStringPtr(v195, 0x8000100u);
                  if (v270)
                  {
                    CFStringRef v271 = (char *)v270;
                    id v272 = 0;
                  }
                  else
                  {
                    CFStringRef v271 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x2ED733D5uLL);
                    CFStringGetCString(v269, v271, 1024, 0x8000100u);
                    id v272 = v271;
                  }
                  if (qword_1000EBD00) {
                    id v286 = (FILE *)qword_1000EBD00;
                  }
                  else {
                    id v286 = __stderrp;
                  }
                  fprintf(v286, "%s\n", v271);
                  if (v272) {
                    free(v272);
                  }
                  CFRelease(v269);
                }
                else
                {
                  id v196 = sub_10002E548();
                  if (os_log_type_enabled(v196, OS_LOG_TYPE_FAULT)) {
                    sub_100084260();
                  }
                  if (qword_1000EBD00) {
                    CFStringRef v197 = (FILE *)qword_1000EBD00;
                  }
                  else {
                    CFStringRef v197 = __stderrp;
                  }
                  fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v197);
                }
                *__error() = v193;
              }
              LOBYTE(v299) = sub_10002E4E8(a3);
              CFStringRef v283 = "%s [%d]: %s: expectedRealDir of / (from /var/mobile/Library/Logs/CrashReporter)";
            }
            int v285 = 1528;
          }
          else
          {
            if ((a3 & 0x80000000) != 0)
            {
              if (byte_1000EBCF8)
              {
                int v198 = *__error();
                id v199 = sub_10002E548();
                if (os_log_type_enabled(v199, OS_LOG_TYPE_ERROR)) {
                  sub_1000841DC(v199);
                }
                *__error() = v198;
              }
              if (byte_1000EBCF9 && dword_1000EB4A8 <= 3)
              {
                int v200 = *__error();
                CFStringRef v201 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%s: NULL expectedRealDir (from /var/mobile/Library/Logs/CrashReporter)", "expectedRealDir");
                if (v201)
                {
                  CFStringRef v265 = v201;
                  id v266 = CFStringGetCStringPtr(v201, 0x8000100u);
                  if (v266)
                  {
                    CFStringRef v267 = (char *)v266;
                    CFStringRef v268 = 0;
                  }
                  else
                  {
                    CFStringRef v267 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xC958969EuLL);
                    CFStringGetCString(v265, v267, 1024, 0x8000100u);
                    CFStringRef v268 = v267;
                  }
                  if (qword_1000EBD00) {
                    id v284 = (FILE *)qword_1000EBD00;
                  }
                  else {
                    id v284 = __stderrp;
                  }
                  fprintf(v284, "%s\n", v267);
                  if (v268) {
                    free(v268);
                  }
                  CFRelease(v265);
                }
                else
                {
                  id v202 = sub_10002E548();
                  if (os_log_type_enabled(v202, OS_LOG_TYPE_FAULT)) {
                    sub_100084164(v202, v203, v204, v205, v206, v207, v208, v209);
                  }
                  if (qword_1000EBD00) {
                    id v210 = (FILE *)qword_1000EBD00;
                  }
                  else {
                    id v210 = __stderrp;
                  }
                  fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v210);
                }
                *__error() = v200;
              }
              CFStringRef v299 = "expectedRealDir";
              CFStringRef v283 = "%s: NULL expectedRealDir (from /var/mobile/Library/Logs/CrashReporter)";
            }
            else
            {
              if (byte_1000EBCF8)
              {
                int v184 = *__error();
                id v185 = sub_10002E548();
                if (os_log_type_enabled(v185, OS_LOG_TYPE_ERROR)) {
                  sub_1000840E0();
                }
                *__error() = v184;
              }
              if (byte_1000EBCF9 && dword_1000EB4A8 <= 3)
              {
                int v186 = *__error();
                id v187 = sub_10002E4E8(a3);
                CFStringRef v188 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%s [%d]: %s: NULL expectedRealDir (from /var/mobile/Library/Logs/CrashReporter)", v187, a3, "expectedRealDir");
                if (v188)
                {
                  CFStringRef v261 = v188;
                  CFStringRef v262 = CFStringGetCStringPtr(v188, 0x8000100u);
                  if (v262)
                  {
                    id v263 = (char *)v262;
                    id v264 = 0;
                  }
                  else
                  {
                    id v263 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xC958969EuLL);
                    CFStringGetCString(v261, v263, 1024, 0x8000100u);
                    id v264 = v263;
                  }
                  if (qword_1000EBD00) {
                    CFStringRef v282 = (FILE *)qword_1000EBD00;
                  }
                  else {
                    CFStringRef v282 = __stderrp;
                  }
                  fprintf(v282, "%s\n", v263);
                  if (v264) {
                    free(v264);
                  }
                  CFRelease(v261);
                }
                else
                {
                  CFStringRef v189 = sub_10002E548();
                  if (os_log_type_enabled(v189, OS_LOG_TYPE_FAULT)) {
                    sub_10008405C();
                  }
                  if (qword_1000EBD00) {
                    id v190 = (FILE *)qword_1000EBD00;
                  }
                  else {
                    id v190 = __stderrp;
                  }
                  fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v190);
                }
                *__error() = v186;
              }
              LOBYTE(v299) = sub_10002E4E8(a3);
              CFStringRef v283 = "%s [%d]: %s: NULL expectedRealDir (from /var/mobile/Library/Logs/CrashReporter)";
            }
            int v285 = 1527;
          }
          sub_10002E41C("DoGenerateSpindump", "monitor.m", v285, v283, v48, v49, v50, v51, (char)v299);
          abort();
        }
        int v174 = *__error();
        CFStringRef v175 = sub_10002E548();
        BOOL v176 = os_log_type_enabled(v175, OS_LOG_TYPE_FAULT);
        if ((a3 & 0x80000000) != 0)
        {
          if (v176) {
            sub_100083FF4();
          }
          *__error() = v174;
          if (!byte_1000EBCF9 || dword_1000EB4A8 > 4) {
            goto LABEL_230;
          }
          CFStringRef v177 = v44;
          int v178 = *__error();
          id v180 = v42;
          CFStringRef v181 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"NULL realDir (dir %s from %s)", v43, v42);
          if (!v181)
          {
            id v280 = sub_10002E548();
            if (os_log_type_enabled(v280, OS_LOG_TYPE_FAULT)) {
              sub_100083F8C();
            }
            goto LABEL_416;
          }
        }
        else
        {
          if (v176)
          {
            id v290 = sub_10002E4E8(a3);
            *(_DWORD *)buf = 136446978;
            *(void *)&uint8_t buf[4] = v290;
            *(_WORD *)&unsigned char buf[12] = 1024;
            *(_DWORD *)&buf[14] = a3;
            *(_WORD *)&buf[18] = 2080;
            *(void *)&buf[20] = v43;
            *(_WORD *)&buf[28] = 2080;
            *(void *)&buf[30] = v42;
            _os_log_fault_impl((void *)&_mh_execute_header, v175, OS_LOG_TYPE_FAULT, "%{public}s [%d]: NULL realDir (dir %s from %s)", buf, 0x26u);
          }
          *__error() = v174;
          if (!byte_1000EBCF9 || dword_1000EB4A8 > 4) {
            goto LABEL_230;
          }
          CFStringRef v177 = v44;
          int v178 = *__error();
          id v179 = sub_10002E4E8(a3);
          id v180 = v42;
          CFStringRef v181 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%s [%d]: NULL realDir (dir %s from %s)", v179, a3, v43, v42);
          if (!v181)
          {
            CFStringRef v182 = sub_10002E548();
            if (os_log_type_enabled(v182, OS_LOG_TYPE_FAULT))
            {
              CFStringRef v183 = sub_10002E4E8(a3);
              *(_DWORD *)buf = 136315906;
              *(void *)&uint8_t buf[4] = v183;
              *(_WORD *)&unsigned char buf[12] = 1024;
              *(_DWORD *)&buf[14] = a3;
              *(_WORD *)&buf[18] = 2080;
              *(void *)&buf[20] = v43;
              *(_WORD *)&buf[28] = 2080;
              *(void *)&buf[30] = v42;
              _os_log_fault_impl((void *)&_mh_execute_header, v182, OS_LOG_TYPE_FAULT, "Unable to format: %s [%d]: NULL realDir (dir %s from %s)", buf, 0x26u);
            }
LABEL_416:
            if (qword_1000EBD00) {
              id v281 = (FILE *)qword_1000EBD00;
            }
            else {
              id v281 = __stderrp;
            }
            fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v281);
LABEL_420:
            *__error() = v178;
            int v42 = v180;
            int v44 = v177;
            goto LABEL_230;
          }
        }
        CFStringRef v247 = v181;
        v248 = CFStringGetCStringPtr(v181, 0x8000100u);
        if (v248)
        {
          CFStringRef v249 = (char *)v248;
          uint64_t v250 = 0;
        }
        else
        {
          CFStringRef v249 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x1F180941uLL);
          CFStringGetCString(v247, v249, 1024, 0x8000100u);
          uint64_t v250 = v249;
        }
        if (qword_1000EBD00) {
          id v277 = (FILE *)qword_1000EBD00;
        }
        else {
          id v277 = __stderrp;
        }
        fprintf(v277, "%s\n", v249);
        if (v250) {
          free(v250);
        }
        CFRelease(v247);
        goto LABEL_420;
      }
      int v66 = *__error();
      CFStringRef v67 = sub_10002E548();
      BOOL v68 = os_log_type_enabled(v67, OS_LOG_TYPE_FAULT);
      if ((a3 & 0x80000000) != 0)
      {
        if (v68) {
          sub_100083F24();
        }
        *__error() = v66;
        if (!byte_1000EBCF9 || dword_1000EB4A8 > 4) {
          goto LABEL_230;
        }
        int v69 = *__error();
        CFStringRef v71 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"Unable to get basename of %s", v42);
        if (!v71)
        {
          id v154 = sub_10002E548();
          if (os_log_type_enabled(v154, OS_LOG_TYPE_FAULT)) {
            sub_100083EBC();
          }
          goto LABEL_225;
        }
      }
      else
      {
        if (v68) {
          sub_100083E3C();
        }
        *__error() = v66;
        if (!byte_1000EBCF9 || dword_1000EB4A8 > 4) {
          goto LABEL_230;
        }
        int v69 = *__error();
        CFStringRef v70 = sub_10002E4E8(a3);
        CFStringRef v71 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%s [%d]: Unable to get basename of %s", v70, a3, v42);
        if (!v71)
        {
          int v72 = sub_10002E548();
          if (os_log_type_enabled(v72, OS_LOG_TYPE_FAULT)) {
            sub_100083DBC();
          }
LABEL_225:
          if (qword_1000EBD00) {
            int v155 = (FILE *)qword_1000EBD00;
          }
          else {
            int v155 = __stderrp;
          }
          fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v155);
LABEL_229:
          *__error() = v69;
LABEL_230:
          free(v42);
          free(v43);
          id v153 = v44;
          goto LABEL_231;
        }
      }
      CFStringRef v84 = v71;
      __int16 v85 = v44;
      uint64_t v86 = CFStringGetCStringPtr(v71, 0x8000100u);
      if (v86)
      {
        id v87 = (char *)v86;
        id v88 = 0;
      }
      else
      {
        id v87 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x75D7549FuLL);
        CFStringGetCString(v84, v87, 1024, 0x8000100u);
        id v88 = v87;
      }
      if (qword_1000EBD00) {
        id v138 = (FILE *)qword_1000EBD00;
      }
      else {
        id v138 = __stderrp;
      }
      fprintf(v138, "%s\n", v87);
      if (v88) {
        free(v88);
      }
      CFRelease(v84);
      int v44 = v85;
      goto LABEL_229;
    }
    int v59 = *__error();
    CFStringRef v60 = sub_10002E548();
    BOOL v61 = os_log_type_enabled(v60, OS_LOG_TYPE_FAULT);
    if ((a3 & 0x80000000) != 0)
    {
      if (v61) {
        sub_100083D54();
      }
      *__error() = v59;
      if (!byte_1000EBCF9 || dword_1000EB4A8 > 4) {
        goto LABEL_222;
      }
      int v62 = *__error();
      CFStringRef v64 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"Unable to get dirname of %s", v42);
      if (!v64)
      {
        CFStringRef v151 = sub_10002E548();
        if (os_log_type_enabled(v151, OS_LOG_TYPE_FAULT)) {
          sub_100083CEC();
        }
        goto LABEL_217;
      }
    }
    else
    {
      if (v61) {
        sub_100083C6C();
      }
      *__error() = v59;
      if (!byte_1000EBCF9 || dword_1000EB4A8 > 4) {
        goto LABEL_222;
      }
      int v62 = *__error();
      __int16 v63 = sub_10002E4E8(a3);
      CFStringRef v64 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%s [%d]: Unable to get dirname of %s", v63, a3, v42);
      if (!v64)
      {
        CFStringRef v65 = sub_10002E548();
        if (os_log_type_enabled(v65, OS_LOG_TYPE_FAULT)) {
          sub_100083BEC();
        }
LABEL_217:
        if (qword_1000EBD00) {
          id v152 = (FILE *)qword_1000EBD00;
        }
        else {
          id v152 = __stderrp;
        }
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v152);
LABEL_221:
        *__error() = v62;
LABEL_222:
        free(v42);
        id v153 = v43;
        goto LABEL_231;
      }
    }
    CFStringRef v80 = v64;
    CFStringRef v81 = CFStringGetCStringPtr(v64, 0x8000100u);
    if (v81)
    {
      uint64_t v82 = (char *)v81;
      id v83 = 0;
    }
    else
    {
      uint64_t v82 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x14E61BCFuLL);
      CFStringGetCString(v80, v82, 1024, 0x8000100u);
      id v83 = v82;
    }
    if (qword_1000EBD00) {
      int v137 = (FILE *)qword_1000EBD00;
    }
    else {
      int v137 = __stderrp;
    }
    fprintf(v137, "%s\n", v82);
    if (v83) {
      free(v83);
    }
    CFRelease(v80);
    goto LABEL_221;
  }
  int v166 = *__error();
  id v167 = sub_10002E548();
  BOOL v168 = os_log_type_enabled(v167, OS_LOG_TYPE_FAULT);
  if ((a3 & 0x80000000) != 0)
  {
    if (v168) {
      sub_10008482C();
    }
    *__error() = v166;
    if (!byte_1000EBCF9 || dword_1000EB4A8 > 4) {
      goto LABEL_413;
    }
    int v169 = *__error();
    unsigned int v171 = v42;
    CFStringRef v172 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"generate spindump: filepath %s too large", v42);
    if (!v172)
    {
      id v278 = sub_10002E548();
      if (os_log_type_enabled(v278, OS_LOG_TYPE_FAULT)) {
        sub_1000847C4();
      }
      goto LABEL_408;
    }
LABEL_361:
    CFStringRef v243 = v172;
    CFStringRef v244 = CFStringGetCStringPtr(v172, 0x8000100u);
    if (v244)
    {
      CFStringRef v245 = (char *)v244;
      uint64_t v246 = 0;
    }
    else
    {
      CFStringRef v245 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x95C905D9uLL);
      CFStringGetCString(v243, v245, 1024, 0x8000100u);
      uint64_t v246 = v245;
    }
    if (qword_1000EBD00) {
      id v260 = (FILE *)qword_1000EBD00;
    }
    else {
      id v260 = __stderrp;
    }
    fprintf(v260, "%s\n", v245);
    if (v246) {
      free(v246);
    }
    CFRelease(v243);
    goto LABEL_412;
  }
  if (v168) {
    sub_100084744();
  }
  *__error() = v166;
  if (!byte_1000EBCF9 || dword_1000EB4A8 > 4) {
    goto LABEL_413;
  }
  int v169 = *__error();
  uint64_t v170 = sub_10002E4E8(a3);
  unsigned int v171 = v42;
  CFStringRef v172 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%s [%d]: generate spindump: filepath %s too large", v170, a3, v42);
  if (v172) {
    goto LABEL_361;
  }
  id v173 = sub_10002E548();
  if (os_log_type_enabled(v173, OS_LOG_TYPE_FAULT)) {
    sub_1000846C4();
  }
LABEL_408:
  if (qword_1000EBD00) {
    CFStringRef v279 = (FILE *)qword_1000EBD00;
  }
  else {
    CFStringRef v279 = __stderrp;
  }
  fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v279);
LABEL_412:
  int v42 = v171;
  *__error() = v169;
LABEL_413:
  id v153 = v42;
LABEL_231:
  free(v153);
  if (a11) {
    (*(void (**)(uint64_t, uint64_t, void))(a11 + 16))(a11, 22, 0);
  }
}

uint64_t sub_10003EDE8(uint64_t a1)
{
  free(*(void **)(a1 + 40));
  free(*(void **)(a1 + 48));
  uint64_t result = *(void *)(a1 + 32);
  if (result)
  {
    id v3 = *(uint64_t (**)(void))(result + 16);
    return v3();
  }
  return result;
}

void sub_10003EE60(uint64_t a1, void *a2, int a3)
{
  id v6 = (int *)(a1 + 72);
  if ((*(_DWORD *)(a1 + 72) & 0x80000000) == 0)
  {
    if (byte_1000EBCF8)
    {
      int v7 = *__error();
      double v8 = sub_10002E548();
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG)) {
        sub_100085030(v6, a3);
      }
      *__error() = v7;
    }
    if (byte_1000EBCF9) {
      BOOL v9 = dword_1000EB4A8 <= 0;
    }
    else {
      BOOL v9 = 0;
    }
    if (!v9) {
      goto LABEL_52;
    }
    int v10 = *__error();
    uint64_t v11 = sub_10002E4E8(*v6);
    uint64_t v12 = *v6;
    id v13 = sub_10006DC4C(a3);
    CFStringRef v14 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%s [%d]: generate spindump: done monitoring due to %s", v11, v12, v13);
    if (v14)
    {
      CFStringRef v15 = v14;
      CStringPtr = CFStringGetCStringPtr(v14, 0x8000100u);
      if (CStringPtr)
      {
        uint64_t v17 = (char *)CStringPtr;
        unint64_t v18 = 0;
      }
      else
      {
        uint64_t v17 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x7F5502D7uLL);
        CFStringGetCString(v15, v17, 1024, 0x8000100u);
        unint64_t v18 = v17;
      }
      if (qword_1000EBD00) {
        uint32_t v29 = (FILE *)qword_1000EBD00;
      }
      else {
        uint32_t v29 = __stderrp;
      }
      fprintf(v29, "%s\n", v17);
      if (v18) {
        free(v18);
      }
LABEL_50:
      CFRelease(v15);
      goto LABEL_51;
    }
    CFStringRef v27 = sub_10002E548();
    if (os_log_type_enabled(v27, OS_LOG_TYPE_FAULT)) {
      sub_100084F78(v6, a3);
    }
    if (qword_1000EBD00) {
      id v28 = (FILE *)qword_1000EBD00;
    }
    else {
      id v28 = __stderrp;
    }
    goto LABEL_31;
  }
  if (byte_1000EBCF8)
  {
    int v19 = *__error();
    long long v20 = sub_10002E548();
    if (os_log_type_enabled(v20, OS_LOG_TYPE_DEBUG)) {
      sub_100085164(a3, v20);
    }
    *__error() = v19;
  }
  if (byte_1000EBCF9) {
    BOOL v21 = dword_1000EB4A8 <= 0;
  }
  else {
    BOOL v21 = 0;
  }
  if (v21)
  {
    int v10 = *__error();
    int v22 = sub_10006DC4C(a3);
    CFStringRef v23 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"generate spindump: done monitoring due to %s", v22);
    if (v23)
    {
      CFStringRef v15 = v23;
      CFStringRef v24 = CFStringGetCStringPtr(v23, 0x8000100u);
      if (v24)
      {
        CFStringRef v25 = (char *)v24;
        uint64_t v26 = 0;
      }
      else
      {
        CFStringRef v25 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x7F5502D7uLL);
        CFStringGetCString(v15, v25, 1024, 0x8000100u);
        uint64_t v26 = v25;
      }
      if (qword_1000EBD00) {
        BOOL v31 = (FILE *)qword_1000EBD00;
      }
      else {
        BOOL v31 = __stderrp;
      }
      fprintf(v31, "%s\n", v25);
      if (v26) {
        free(v26);
      }
      goto LABEL_50;
    }
    int v30 = sub_10002E548();
    if (os_log_type_enabled(v30, OS_LOG_TYPE_FAULT)) {
      sub_1000850D8(a3, v30);
    }
    if (qword_1000EBD00) {
      id v28 = (FILE *)qword_1000EBD00;
    }
    else {
      id v28 = __stderrp;
    }
LABEL_31:
    fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v28);
LABEL_51:
    *__error() = v10;
  }
LABEL_52:
  if (*(void *)(a1 + 40)) {
    [a2 setReason:+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:")];
  }
  if (*(void *)(a1 + 48)) {
    [a2 setSignature:+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:")];
  }
  uint64_t v32 = *(void *)(a1 + 56);
  if (v32)
  {
    [objc_msgSend(a2, "printOptions") setPrintHeavyStacks:1];
    uint64_t v32 = *(void *)(a1 + 56);
  }
  [a2 setIncludeTextualFormatInReport:(v32 & 2) == 0];
  [a2 setIncludeBinaryFormatInReport:(*(void *)(a1 + 56) & 4) == 0];
  uint64_t v33 = *(void *)(a1 + 56);
  if ((v33 & 0x10) != 0)
  {
    [a2 setShouldSymbolicate:1];
    [a2 setShouldUseBulkSymbolication:0];
    uint64_t v33 = *(void *)(a1 + 56);
  }
  if ((v33 & 8) != 0)
  {
    [a2 setShouldSymbolicate:0];
    [a2 setShouldUseBulkSymbolication:0];
  }
  CFStringRef v34 = (uint64_t *)(a1 + 64);
  uint64_t v35 = *(const char **)(a1 + 64);
  uid_t v36 = geteuid();
  int v37 = sub_10002B934(v35, 536872449, v36, 0x1A4u);
  if ((v37 & 0x80000000) == 0)
  {
    id v38 = fdopen(v37, "w");
    if (v38)
    {
      id v39 = v38;
      [a2 saveReportToStream:v38];
      fclose(v39);
      if (*v6 < 0)
      {
        if (byte_1000EBCF8)
        {
          int v82 = *__error();
          id v83 = sub_10002E548();
          if (os_log_type_enabled(v83, OS_LOG_TYPE_DEFAULT))
          {
            CFStringRef v84 = sub_10002E4E8(*(_DWORD *)(a1 + 76));
            int v85 = *(_DWORD *)(a1 + 76);
            uint64_t v86 = *(_DWORD **)(a1 + 64);
            *(_DWORD *)buf = 136446722;
            unsigned int v128 = v84;
            __int16 v129 = 1024;
            int v130 = v85;
            __int16 v131 = 2080;
            uint64_t v132 = v86;
            _os_log_impl((void *)&_mh_execute_header, v83, OS_LOG_TYPE_DEFAULT, "generate spindump: saved report (requested by %{public}s [%d]) to %s", buf, 0x1Cu);
          }
          *__error() = v82;
        }
        if (!byte_1000EBCF9 || dword_1000EB4A8 > 2) {
          goto LABEL_139;
        }
        int v47 = *__error();
        id v87 = sub_10002E4E8(*(_DWORD *)(a1 + 76));
        CFStringRef v51 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"generate spindump: saved report (requested by %s [%d]) to %s", v87, *(unsigned int *)(a1 + 76), *(void *)(a1 + 64));
        if (!v51)
        {
          id v114 = sub_10002E548();
          if (os_log_type_enabled(v114, OS_LOG_TYPE_FAULT)) {
            sub_100084ED4();
          }
          goto LABEL_134;
        }
      }
      else
      {
        if (byte_1000EBCF8)
        {
          int v40 = *__error();
          uint64_t v41 = sub_10002E548();
          if (os_log_type_enabled(v41, OS_LOG_TYPE_DEFAULT))
          {
            int v42 = sub_10002E4E8(*(_DWORD *)(a1 + 72));
            int v43 = *(_DWORD *)(a1 + 72);
            int v44 = sub_10002E4E8(*(_DWORD *)(a1 + 76));
            int v45 = *(_DWORD *)(a1 + 76);
            uint64_t v46 = *(void *)(a1 + 64);
            *(_DWORD *)buf = 136447234;
            unsigned int v128 = v42;
            __int16 v129 = 1024;
            int v130 = v43;
            __int16 v131 = 2082;
            uint64_t v132 = v44;
            __int16 v133 = 1024;
            int v134 = v45;
            __int16 v135 = 2080;
            uint64_t v136 = v46;
            _os_log_impl((void *)&_mh_execute_header, v41, OS_LOG_TYPE_DEFAULT, "%{public}s [%d]: generate spindump: saved report (requested by %{public}s [%d]) to %s", buf, 0x2Cu);
          }
          *__error() = v40;
        }
        if (!byte_1000EBCF9 || dword_1000EB4A8 > 2) {
          goto LABEL_139;
        }
        int v47 = *__error();
        uint64_t v48 = sub_10002E4E8(*(_DWORD *)(a1 + 72));
        uint64_t v49 = *(unsigned int *)(a1 + 72);
        uint64_t v50 = sub_10002E4E8(*(_DWORD *)(a1 + 76));
        CFStringRef v51 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%s [%d]: generate spindump: saved report (requested by %s [%d]) to %s", v48, v49, v50, *(unsigned int *)(a1 + 76), *(void *)(a1 + 64));
        if (!v51)
        {
          id v52 = sub_10002E548();
          if (os_log_type_enabled(v52, OS_LOG_TYPE_FAULT))
          {
            int v53 = sub_10002E4E8(*(_DWORD *)(a1 + 72));
            int v54 = *(_DWORD *)(a1 + 72);
            CFStringRef v55 = sub_10002E4E8(*(_DWORD *)(a1 + 76));
            int v56 = *(_DWORD *)(a1 + 76);
            uint64_t v57 = *(void *)(a1 + 64);
            *(_DWORD *)buf = 136316162;
            unsigned int v128 = v53;
            __int16 v129 = 1024;
            int v130 = v54;
            __int16 v131 = 2080;
            uint64_t v132 = v55;
            __int16 v133 = 1024;
            int v134 = v56;
            __int16 v135 = 2080;
            uint64_t v136 = v57;
            _os_log_fault_impl((void *)&_mh_execute_header, v52, OS_LOG_TYPE_FAULT, "Unable to format: %s [%d]: generate spindump: saved report (requested by %s [%d]) to %s", buf, 0x2Cu);
          }
LABEL_134:
          if (qword_1000EBD00) {
            id v115 = (FILE *)qword_1000EBD00;
          }
          else {
            id v115 = __stderrp;
          }
          fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v115);
LABEL_138:
          *__error() = v47;
LABEL_139:
          uint64_t v116 = *(void *)(a1 + 32);
          if (v116) {
            (*(void (**)(uint64_t, void, uint64_t))(v116 + 16))(v116, 0, *v34);
          }
          goto LABEL_169;
        }
      }
      CFStringRef v88 = v51;
      uint64_t v89 = CFStringGetCStringPtr(v51, 0x8000100u);
      if (v89)
      {
        unint64_t v90 = (char *)v89;
        unsigned int v91 = 0;
      }
      else
      {
        unint64_t v90 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x8DF10488uLL);
        CFStringGetCString(v88, v90, 1024, 0x8000100u);
        unsigned int v91 = v90;
      }
      if (qword_1000EBD00) {
        int v111 = (FILE *)qword_1000EBD00;
      }
      else {
        int v111 = __stderrp;
      }
      fprintf(v111, "%s\n", v90);
      if (v91) {
        free(v91);
      }
      CFRelease(v88);
      goto LABEL_138;
    }
    if ((*v6 & 0x80000000) == 0)
    {
      if (byte_1000EBCF8)
      {
        int v71 = *__error();
        int v72 = sub_10002E548();
        if (os_log_type_enabled(v72, OS_LOG_TYPE_ERROR)) {
          sub_100084D2C(v6, a1 + 64, v72);
        }
        *__error() = v71;
      }
      if (!byte_1000EBCF9 || dword_1000EB4A8 > 3) {
        goto LABEL_167;
      }
      int v60 = *__error();
      int v73 = sub_10002E4E8(*v6);
      uint64_t v74 = *v34;
      uint64_t v75 = *v6;
      uint64_t v76 = *__error();
      id v77 = __error();
      CFStringRef v78 = strerror(*v77);
      CFStringRef v79 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%s [%d]: generate spindump: unable to fdopen %s for writing: %d (%s)", v73, v75, v74, v76, v78);
      if (v79)
      {
        CFStringRef v68 = v79;
        int v69 = CFStringGetCStringPtr(v79, 0x8000100u);
        if (v69) {
          goto LABEL_93;
        }
        malloc_type_id_t v70 = 572460254;
LABEL_144:
        CFStringRef v80 = (char *)malloc_type_calloc(0x400uLL, 1uLL, v70);
        CFStringGetCString(v68, v80, 1024, 0x8000100u);
        CFStringRef v81 = v80;
        goto LABEL_145;
      }
      uint64_t v113 = sub_10002E548();
      if (os_log_type_enabled(v113, OS_LOG_TYPE_FAULT)) {
        sub_100084C9C(v6, a1 + 64, v113);
      }
LABEL_153:
      if (qword_1000EBD00) {
        uint64_t v121 = (FILE *)qword_1000EBD00;
      }
      else {
        uint64_t v121 = __stderrp;
      }
      fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v121);
      goto LABEL_166;
    }
    if (byte_1000EBCF8)
    {
      int v102 = *__error();
      id v103 = sub_10002E548();
      if (os_log_type_enabled(v103, OS_LOG_TYPE_ERROR)) {
        sub_100084E48();
      }
      *__error() = v102;
    }
    if (!byte_1000EBCF9 || dword_1000EB4A8 > 3) {
      goto LABEL_167;
    }
    int v60 = *__error();
    uint64_t v104 = *v34;
    uint64_t v105 = *__error();
    qos_class_t v106 = __error();
    CFStringRef v107 = strerror(*v106);
    CFStringRef v108 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"generate spindump: unable to fdopen %s for writing: %d (%s)", v104, v105, v107);
    if (!v108)
    {
      CFStringRef v120 = sub_10002E548();
      if (os_log_type_enabled(v120, OS_LOG_TYPE_FAULT)) {
        sub_100084DBC();
      }
      goto LABEL_153;
    }
    CFStringRef v99 = v108;
    id v100 = CFStringGetCStringPtr(v108, 0x8000100u);
    if (v100) {
      goto LABEL_120;
    }
    malloc_type_id_t v101 = 572460254;
    goto LABEL_158;
  }
  if (*v6 < 0)
  {
    if (byte_1000EBCF8)
    {
      int v92 = *__error();
      unsigned int v93 = sub_10002E548();
      if (os_log_type_enabled(v93, OS_LOG_TYPE_ERROR)) {
        sub_100084C10();
      }
      *__error() = v92;
    }
    if (!byte_1000EBCF9 || dword_1000EB4A8 > 3) {
      goto LABEL_167;
    }
    int v60 = *__error();
    uint64_t v94 = *v34;
    uint64_t v95 = *__error();
    double v96 = __error();
    unsigned __int8 v97 = strerror(*v96);
    CFStringRef v98 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"generate spindump: unable to open %s for writing: %d (%s)", v94, v95, v97);
    if (!v98)
    {
      CFStringRef v117 = sub_10002E548();
      if (os_log_type_enabled(v117, OS_LOG_TYPE_FAULT)) {
        sub_100084B84();
      }
      goto LABEL_153;
    }
    CFStringRef v99 = v98;
    id v100 = CFStringGetCStringPtr(v98, 0x8000100u);
    if (v100)
    {
LABEL_120:
      int v109 = (char *)v100;
      id v110 = 0;
LABEL_159:
      if (qword_1000EBD00) {
        __int16 v122 = (FILE *)qword_1000EBD00;
      }
      else {
        __int16 v122 = __stderrp;
      }
      fprintf(v122, "%s\n", v109);
      if (v110) {
        free(v110);
      }
      CFStringRef v119 = v99;
      goto LABEL_165;
    }
    malloc_type_id_t v101 = 1300378867;
LABEL_158:
    int v109 = (char *)malloc_type_calloc(0x400uLL, 1uLL, v101);
    CFStringGetCString(v99, v109, 1024, 0x8000100u);
    id v110 = v109;
    goto LABEL_159;
  }
  if (byte_1000EBCF8)
  {
    int v58 = *__error();
    int v59 = sub_10002E548();
    if (os_log_type_enabled(v59, OS_LOG_TYPE_ERROR)) {
      sub_100084AF4(v6, a1 + 64, v59);
    }
    *__error() = v58;
  }
  if (!byte_1000EBCF9 || dword_1000EB4A8 > 3) {
    goto LABEL_167;
  }
  int v60 = *__error();
  BOOL v61 = sub_10002E4E8(*v6);
  uint64_t v62 = *v34;
  uint64_t v63 = *v6;
  uint64_t v64 = *__error();
  CFStringRef v65 = __error();
  int v66 = strerror(*v65);
  CFStringRef v67 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%s [%d]: generate spindump: unable to open %s for writing: %d (%s)", v61, v63, v62, v64, v66);
  if (!v67)
  {
    CFStringRef v112 = sub_10002E548();
    if (os_log_type_enabled(v112, OS_LOG_TYPE_FAULT)) {
      sub_100084A64(v6, a1 + 64, v112);
    }
    goto LABEL_153;
  }
  CFStringRef v68 = v67;
  int v69 = CFStringGetCStringPtr(v67, 0x8000100u);
  if (!v69)
  {
    malloc_type_id_t v70 = 1300378867;
    goto LABEL_144;
  }
LABEL_93:
  CFStringRef v80 = (char *)v69;
  CFStringRef v81 = 0;
LABEL_145:
  if (qword_1000EBD00) {
    CFStringRef v118 = (FILE *)qword_1000EBD00;
  }
  else {
    CFStringRef v118 = __stderrp;
  }
  fprintf(v118, "%s\n", v80);
  if (v81) {
    free(v81);
  }
  CFStringRef v119 = v68;
LABEL_165:
  CFRelease(v119);
LABEL_166:
  *__error() = v60;
LABEL_167:
  uint64_t v123 = *(void *)(a1 + 32);
  if (v123)
  {
    uint64_t v124 = *__error();
    (*(void (**)(uint64_t, uint64_t, void))(v123 + 16))(v123, v124, 0);
  }
LABEL_169:
  free(*(void **)(a1 + 64));
  uint64_t v125 = *(void **)(a1 + 40);
  if (v125) {
    free(v125);
  }
  uint64_t v126 = *(void **)(a1 + 48);
  if (v126) {
    free(v126);
  }
}

uint64_t sub_10003FC18(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, void *a5, double a6, double a7, double a8, double a9, double a10)
{
  id v20 = objc_alloc_init((Class)SAMicrostackshotStatistics);
  BOOL v21 = [a2 UTF8String];
  id v22 = [a5 UTF8String];
  uint64_t v23 = sub_100025D2C(0, 0, a1, v21, a3, 1, (uint64_t)v22, 0, a8 - a7, a8, 0.0, a6, a7, a9, a10, 5u, (word_1000EBD38 & 0x80) != 0, 0, 0,
          a4,
          SHIDWORD(a4),
          0x11u,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          (uint64_t)v20);
  uint64_t v24 = [[[v20 total] num_out_of_order] != 0];
  if (objc_msgSend(objc_msgSend(v20, "total"), "num_missing_load_info")) {
    uint64_t v25 = ((unint64_t)(v24 & 1) << 41) | 0x10000000000;
  }
  else {
    uint64_t v25 = v24 << 41;
  }
  if (objc_msgSend(v20, "bytes_not_microstackshots")) {
    v25 |= 0x40000000000uLL;
  }
  if ((v23 & 0x800000) != 0)
  {
    if ((a1 & 0x80000000) == 0)
    {
      if (byte_1000EBCF8)
      {
        int v34 = *__error();
        uint64_t v35 = sub_10002E548();
        if (os_log_type_enabled(v35, OS_LOG_TYPE_ERROR)) {
          sub_1000857C0(a1, v20, v35);
        }
        *__error() = v34;
      }
      if (byte_1000EBCF9 && dword_1000EB4A8 <= 3)
      {
        int v28 = *__error();
        uid_t v36 = sub_10002E4E8(a1);
        CFStringRef v37 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%s [%d]: cpu resource: no microstackshots: %llu out-of-order microstackshots, %llu microstackshots missing load infos, %llu bytes invalid", v36, a1, [objc_msgSend(objc_msgSend(v20, "total"), "num_out_of_order")], [objc_msgSend(objc_msgSend(v20, "total"), "num_missing_load_info")], [v20 bytes_not_microstackshots]);
        if (v37)
        {
          CFStringRef v31 = v37;
          CStringPtr = CFStringGetCStringPtr(v37, 0x8000100u);
          if (!CStringPtr)
          {
            malloc_type_id_t v33 = 3782911556;
            goto LABEL_80;
          }
LABEL_37:
          int v42 = (char *)CStringPtr;
          int v43 = 0;
LABEL_81:
          if (qword_1000EBD00) {
            CFStringRef v65 = (FILE *)qword_1000EBD00;
          }
          else {
            CFStringRef v65 = __stderrp;
          }
          fprintf(v65, "%s\n", v42);
          if (v43) {
            free(v43);
          }
          CFRelease(v31);
          goto LABEL_87;
        }
        int v59 = sub_10002E548();
        if (os_log_type_enabled(v59, OS_LOG_TYPE_FAULT)) {
          sub_10008572C(a1, v20, v59);
        }
LABEL_73:
        if (qword_1000EBD00) {
          uint64_t v63 = (FILE *)qword_1000EBD00;
        }
        else {
          uint64_t v63 = __stderrp;
        }
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v63);
LABEL_87:
        *__error() = v28;
      }
LABEL_88:
      if (byte_1000EBCF8)
      {
        int v66 = *__error();
        CFStringRef v67 = sub_10002E548();
        if (os_log_type_enabled(v67, OS_LOG_TYPE_DEBUG)) {
          sub_100085270();
        }
        *__error() = v66;
      }
      if (byte_1000EBCF9 && dword_1000EB4A8 <= 0)
      {
        int v68 = *__error();
        int v69 = sub_10002E4E8(a1);
        CFStringRef v70 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%s [%d]: cpu resource: done reporting (%#llx)", v69, a1, v23);
        if (v70)
        {
          CFStringRef v71 = v70;
          int v72 = CFStringGetCStringPtr(v70, 0x8000100u);
          if (v72)
          {
            int v73 = (char *)v72;
            uint64_t v74 = 0;
          }
          else
          {
            int v73 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x7EBBEB3BuLL);
            CFStringGetCString(v71, v73, 1024, 0x8000100u);
            uint64_t v74 = v73;
          }
          if (qword_1000EBD00) {
            uint64_t v76 = (FILE *)qword_1000EBD00;
          }
          else {
            uint64_t v76 = __stderrp;
          }
          fprintf(v76, "%s\n", v73);
          if (v74) {
            free(v74);
          }
          CFStringRef v77 = v71;
LABEL_143:
          CFRelease(v77);
LABEL_144:
          *__error() = v68;
          goto LABEL_145;
        }
        uint64_t v75 = sub_10002E548();
        if (os_log_type_enabled(v75, OS_LOG_TYPE_FAULT)) {
          sub_1000851F0();
        }
        goto LABEL_132;
      }
      goto LABEL_145;
    }
    if (byte_1000EBCF8)
    {
      int v44 = *__error();
      int v45 = sub_10002E548();
      if (os_log_type_enabled(v45, OS_LOG_TYPE_ERROR)) {
        sub_1000858E4();
      }
      *__error() = v44;
    }
    if (byte_1000EBCF9 && dword_1000EB4A8 <= 3)
    {
      int v46 = *__error();
      CFStringRef v47 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"cpu resource: no microstackshots: %llu out-of-order microstackshots, %llu microstackshots missing load infos, %llu bytes invalid", [objc_msgSend(objc_msgSend(v20, "total"), "num_out_of_order"), [objc_msgSend(objc_msgSend(v20, "total"), "num_missing_load_info"), [v20 bytes_not_microstackshots]];
      if (v47)
      {
        CFStringRef v48 = v47;
        uint64_t v49 = CFStringGetCStringPtr(v47, 0x8000100u);
        if (!v49)
        {
          malloc_type_id_t v50 = 3782911556;
LABEL_113:
          uint64_t v57 = (char *)malloc_type_calloc(0x400uLL, 1uLL, v50);
          CFStringGetCString(v48, v57, 1024, 0x8000100u);
          int v58 = v57;
          goto LABEL_114;
        }
LABEL_64:
        uint64_t v57 = (char *)v49;
        int v58 = 0;
LABEL_114:
        if (qword_1000EBD00) {
          CFStringRef v80 = (FILE *)qword_1000EBD00;
        }
        else {
          CFStringRef v80 = __stderrp;
        }
        fprintf(v80, "%s\n", v57);
        if (v58) {
          free(v58);
        }
        CFRelease(v48);
        goto LABEL_120;
      }
      BOOL v61 = sub_10002E548();
      if (os_log_type_enabled(v61, OS_LOG_TYPE_FAULT)) {
        sub_100085854();
      }
LABEL_108:
      if (qword_1000EBD00) {
        CFStringRef v79 = (FILE *)qword_1000EBD00;
      }
      else {
        CFStringRef v79 = __stderrp;
      }
      fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v79);
LABEL_120:
      *__error() = v46;
    }
  }
  else if (v25)
  {
    if ((a1 & 0x80000000) == 0)
    {
      if (byte_1000EBCF8)
      {
        int v26 = *__error();
        CFStringRef v27 = sub_10002E548();
        if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136447234;
          unsigned int v93 = sub_10002E4E8(a1);
          __int16 v94 = 1024;
          *(_DWORD *)uint64_t v95 = a1;
          *(_WORD *)&v95[4] = 2048;
          *(void *)&v95[6] = [objc_msgSend(objc_msgSend(v20, "total"), "num_out_of_order")];
          *(_WORD *)&v95[14] = 2048;
          *(void *)&v95[16] = [objc_msgSend(v20, "total") num_missing_load_info];
          __int16 v96 = 2048;
          id v97 = [v20 bytes_not_microstackshots];
          _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "%{public}s [%d]: cpu resource: some microstackshots with errors: %llu out-of-order microstackshots, %llu microstackshots missing load infos, %llu bytes invalid", buf, 0x30u);
        }
        *__error() = v26;
      }
      if (byte_1000EBCF9 && dword_1000EB4A8 <= 2)
      {
        int v28 = *__error();
        uint32_t v29 = sub_10002E4E8(a1);
        CFStringRef v30 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%s [%d]: cpu resource: some microstackshots with errors: %llu out-of-order microstackshots, %llu microstackshots missing load infos, %llu bytes invalid", v29, a1, [objc_msgSend(objc_msgSend(v20, "total"), "num_out_of_order")], [objc_msgSend(objc_msgSend(v20, "total"), "num_missing_load_info")], [v20 bytes_not_microstackshots]);
        if (v30)
        {
          CFStringRef v31 = v30;
          CStringPtr = CFStringGetCStringPtr(v30, 0x8000100u);
          if (!CStringPtr)
          {
            malloc_type_id_t v33 = 1311273892;
LABEL_80:
            int v42 = (char *)malloc_type_calloc(0x400uLL, 1uLL, v33);
            CFStringGetCString(v31, v42, 1024, 0x8000100u);
            int v43 = v42;
            goto LABEL_81;
          }
          goto LABEL_37;
        }
        int v60 = sub_10002E548();
        if (os_log_type_enabled(v60, OS_LOG_TYPE_FAULT)) {
          sub_100085608(a1, v20, v60);
        }
        goto LABEL_73;
      }
      goto LABEL_88;
    }
    if (byte_1000EBCF8)
    {
      int v51 = *__error();
      id v52 = sub_10002E548();
      if (os_log_type_enabled(v52, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 134218496;
        unsigned int v93 = [[[v20 total] num_out_of_order];
        __int16 v94 = 2048;
        *(void *)uint64_t v95 = [v20 total].num_missing_load_info;
        *(_WORD *)&v95[8] = 2048;
        *(void *)&v95[10] = [v20 bytes_not_microstackshots];
        _os_log_impl((void *)&_mh_execute_header, v52, OS_LOG_TYPE_DEFAULT, "cpu resource: some microstackshots with errors: %llu out-of-order microstackshots, %llu microstackshots missing load infos, %llu bytes invalid", buf, 0x20u);
      }
      *__error() = v51;
    }
    if (byte_1000EBCF9 && dword_1000EB4A8 <= 2)
    {
      int v46 = *__error();
      CFStringRef v53 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"cpu resource: some microstackshots with errors: %llu out-of-order microstackshots, %llu microstackshots missing load infos, %llu bytes invalid", [objc_msgSend(objc_msgSend(v20, "total"), "num_out_of_order"), objc_msgSend(objc_msgSend(v20, "total"), "num_missing_load_info"), objc_msgSend(v20, "bytes_not_microstackshots")]);
      if (v53)
      {
        CFStringRef v48 = v53;
        uint64_t v49 = CFStringGetCStringPtr(v53, 0x8000100u);
        if (!v49)
        {
          malloc_type_id_t v50 = 1311273892;
          goto LABEL_113;
        }
        goto LABEL_64;
      }
      uint64_t v64 = sub_10002E548();
      if (os_log_type_enabled(v64, OS_LOG_TYPE_FAULT)) {
        sub_10008569C();
      }
      goto LABEL_108;
    }
  }
  else
  {
    if ((a1 & 0x80000000) == 0)
    {
      if (byte_1000EBCF8)
      {
        int v38 = *__error();
        id v39 = sub_10002E548();
        if (os_log_type_enabled(v39, OS_LOG_TYPE_DEBUG)) {
          sub_100085384(a1, v20, v39);
        }
        *__error() = v38;
      }
      if (byte_1000EBCF9 && dword_1000EB4A8 <= 0)
      {
        int v28 = *__error();
        int v40 = sub_10002E4E8(a1);
        CFStringRef v41 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%s [%d]: cpu resource: all microstackshots without errors: %llu out-of-order microstackshots, %llu microstackshots missing load infos, %llu bytes invalid", v40, a1, [objc_msgSend(objc_msgSend(v20, "total"), "num_out_of_order")], [objc_msgSend(objc_msgSend(v20, "total"), "num_missing_load_info")], [v20 bytes_not_microstackshots]);
        if (v41)
        {
          CFStringRef v31 = v41;
          CStringPtr = CFStringGetCStringPtr(v41, 0x8000100u);
          if (!CStringPtr)
          {
            malloc_type_id_t v33 = 3072135930;
            goto LABEL_80;
          }
          goto LABEL_37;
        }
        uint64_t v62 = sub_10002E548();
        if (os_log_type_enabled(v62, OS_LOG_TYPE_FAULT)) {
          sub_1000852F0(a1, v20, v62);
        }
        goto LABEL_73;
      }
      goto LABEL_88;
    }
    if (byte_1000EBCF8)
    {
      int v54 = *__error();
      CFStringRef v55 = sub_10002E548();
      if (os_log_type_enabled(v55, OS_LOG_TYPE_DEBUG)) {
        sub_100085578();
      }
      *__error() = v54;
    }
    if (byte_1000EBCF9 && dword_1000EB4A8 <= 0)
    {
      int v46 = *__error();
      CFStringRef v56 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"cpu resource: all microstackshots without errors: %llu out-of-order microstackshots, %llu microstackshots missing load infos, %llu bytes invalid", [objc_msgSend(objc_msgSend(v20, "total"), "num_out_of_order")], [objc_msgSend(objc_msgSend(v20, "total"), "num_missing_load_info")], [objc_msgSend(v20, "bytes_not_microstackshots")]);
      if (v56)
      {
        CFStringRef v48 = v56;
        uint64_t v49 = CFStringGetCStringPtr(v56, 0x8000100u);
        if (!v49)
        {
          malloc_type_id_t v50 = 3072135930;
          goto LABEL_113;
        }
        goto LABEL_64;
      }
      CFStringRef v78 = sub_10002E548();
      if (os_log_type_enabled(v78, OS_LOG_TYPE_FAULT)) {
        sub_1000854E8();
      }
      goto LABEL_108;
    }
  }
  if (byte_1000EBCF8)
  {
    int v81 = *__error();
    int v82 = sub_10002E548();
    if (os_log_type_enabled(v82, OS_LOG_TYPE_DEBUG)) {
      sub_100085480();
    }
    *__error() = v81;
  }
  if (byte_1000EBCF9 && dword_1000EB4A8 <= 0)
  {
    int v68 = *__error();
    CFStringRef v83 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"cpu resource: done reporting (%#llx)", v23);
    if (v83)
    {
      CFStringRef v84 = v83;
      int v85 = CFStringGetCStringPtr(v83, 0x8000100u);
      if (v85)
      {
        uint64_t v86 = (char *)v85;
        id v87 = 0;
      }
      else
      {
        uint64_t v86 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x7EBBEB3BuLL);
        CFStringGetCString(v84, v86, 1024, 0x8000100u);
        id v87 = v86;
      }
      if (qword_1000EBD00) {
        unint64_t v90 = (FILE *)qword_1000EBD00;
      }
      else {
        unint64_t v90 = __stderrp;
      }
      fprintf(v90, "%s\n", v86);
      if (v87) {
        free(v87);
      }
      CFStringRef v77 = v84;
      goto LABEL_143;
    }
    CFStringRef v88 = sub_10002E548();
    if (os_log_type_enabled(v88, OS_LOG_TYPE_FAULT)) {
      sub_100085418();
    }
LABEL_132:
    if (qword_1000EBD00) {
      uint64_t v89 = (FILE *)qword_1000EBD00;
    }
    else {
      uint64_t v89 = __stderrp;
    }
    fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v89);
    goto LABEL_144;
  }
LABEL_145:

  return v23;
}

uint64_t sub_100040988(uint64_t a1, uint64_t a2, char a3, void *a4)
{
  if (!sub_10005CBDC(a1))
  {
    uint64_t v15 = 0;
    uint64_t v16 = 0;
    goto LABEL_45;
  }
  if ((a3 & 0x10) != 0)
  {
    uint64_t v16 = 0;
    uint64_t v15 = 16;
    goto LABEL_45;
  }
  if ((a1 & 0x80000000) != 0)
  {
    if (byte_1000EBCF8)
    {
      int v17 = *__error();
      unint64_t v18 = sub_10002E548();
      if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG)) {
        sub_100086454();
      }
      *__error() = v17;
    }
    if (byte_1000EBCF9) {
      BOOL v19 = dword_1000EB4A8 <= 0;
    }
    else {
      BOOL v19 = 0;
    }
    if (!v19) {
      goto LABEL_26;
    }
    int v11 = *__error();
    CFStringRef v13 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%s: being debugged", a2);
    if (!v13)
    {
      uint64_t v25 = sub_10002E548();
      if (os_log_type_enabled(v25, OS_LOG_TYPE_FAULT)) {
        sub_1000863EC();
      }
      goto LABEL_39;
    }
LABEL_28:
    CFStringRef v20 = v13;
    CStringPtr = CFStringGetCStringPtr(v13, 0x8000100u);
    if (CStringPtr)
    {
      id v22 = (char *)CStringPtr;
      uint64_t v23 = 0;
    }
    else
    {
      id v22 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xF5392463uLL);
      CFStringGetCString(v20, v22, 1024, 0x8000100u);
      uint64_t v23 = v22;
    }
    if (qword_1000EBD00) {
      uint64_t v24 = (FILE *)qword_1000EBD00;
    }
    else {
      uint64_t v24 = __stderrp;
    }
    fprintf(v24, "%s\n", v22);
    if (v23) {
      free(v23);
    }
    CFRelease(v20);
    goto LABEL_43;
  }
  if (byte_1000EBCF8)
  {
    int v8 = *__error();
    BOOL v9 = sub_10002E548();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG)) {
      sub_100086360();
    }
    *__error() = v8;
  }
  if (byte_1000EBCF9) {
    BOOL v10 = dword_1000EB4A8 <= 0;
  }
  else {
    BOOL v10 = 0;
  }
  if (v10)
  {
    int v11 = *__error();
    uint64_t v12 = sub_10002E4E8(a1);
    CFStringRef v13 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%s [%d]: %s: being debugged", v12, a1, a2);
    if (!v13)
    {
      CFStringRef v14 = sub_10002E548();
      if (os_log_type_enabled(v14, OS_LOG_TYPE_FAULT)) {
        sub_1000862E0();
      }
LABEL_39:
      if (qword_1000EBD00) {
        int v26 = (FILE *)qword_1000EBD00;
      }
      else {
        int v26 = __stderrp;
      }
      fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v26);
LABEL_43:
      uint64_t v15 = 0;
      *__error() = v11;
      goto LABEL_44;
    }
    goto LABEL_28;
  }
LABEL_26:
  uint64_t v15 = 0;
LABEL_44:
  uint64_t v16 = 16;
LABEL_45:
  if (sub_100046AE8()) {
    v15 |= 0x100uLL;
  }
  if (sub_10005DD50()) {
    uint64_t v27 = v15 | 0x80;
  }
  else {
    uint64_t v27 = v15;
  }
  if (qword_1000EBBB0 != -1) {
    dispatch_once(&qword_1000EBBB0, &stru_1000DD080);
  }
  if (byte_1000EBBA8) {
    goto LABEL_125;
  }
  task_name_t v73 = 0;
  uint64_t v28 = task_inspect_for_pid();
  if (v28)
  {
    uint64_t v29 = v28;
    if ((a1 & 0x80000000) == 0)
    {
      if (byte_1000EBCF8)
      {
        int v30 = *__error();
        CFStringRef v31 = sub_10002E548();
        if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR)) {
          sub_100086178();
        }
        *__error() = v30;
      }
      if (byte_1000EBCF9 && dword_1000EB4A8 <= 3)
      {
        int v32 = *__error();
        malloc_type_id_t v33 = sub_10002E4E8(a1);
        CFStringRef v34 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%s [%d]: Unable to inspect task for suspended state (%d), assuming not suspended", v33, a1, v29);
        if (v34)
        {
          CFStringRef v35 = v34;
          uid_t v36 = CFStringGetCStringPtr(v34, 0x8000100u);
          if (!v36)
          {
            malloc_type_id_t v37 = 3738017222;
LABEL_102:
            int v44 = (char *)malloc_type_calloc(0x400uLL, 1uLL, v37);
            CFStringGetCString(v35, v44, 1024, 0x8000100u);
            int v45 = v44;
            goto LABEL_103;
          }
          goto LABEL_74;
        }
        uint64_t v57 = sub_10002E548();
        if (os_log_type_enabled(v57, OS_LOG_TYPE_FAULT)) {
          sub_1000860F8();
        }
        goto LABEL_111;
      }
      goto LABEL_125;
    }
    if (byte_1000EBCF8)
    {
      int v46 = *__error();
      CFStringRef v47 = sub_10002E548();
      if (os_log_type_enabled(v47, OS_LOG_TYPE_ERROR)) {
        sub_10008626C();
      }
      *__error() = v46;
    }
    if (!byte_1000EBCF9 || dword_1000EB4A8 > 3) {
      goto LABEL_125;
    }
    int v32 = *__error();
    CFStringRef v48 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"Unable to inspect task for suspended state (%d), assuming not suspended", v29);
    if (!v48)
    {
      int v58 = sub_10002E548();
      if (os_log_type_enabled(v58, OS_LOG_TYPE_FAULT)) {
        sub_1000861F8();
      }
      goto LABEL_111;
    }
    CFStringRef v49 = v48;
    malloc_type_id_t v50 = CFStringGetCStringPtr(v48, 0x8000100u);
    if (!v50)
    {
      malloc_type_id_t v51 = 3738017222;
LABEL_116:
      CFStringRef v55 = (char *)malloc_type_calloc(0x400uLL, 1uLL, v51);
      CFStringGetCString(v49, v55, 1024, 0x8000100u);
      CFStringRef v56 = v55;
      goto LABEL_117;
    }
    goto LABEL_94;
  }
  uint64_t v72 = 0;
  *(_OWORD *)task_info_out = 0u;
  long long v71 = 0u;
  mach_msg_type_number_t task_info_outCnt = 10;
  uint64_t v38 = task_info(v73, 0x12u, task_info_out, &task_info_outCnt);
  if (!v38)
  {
    if (task_info_out[0]) {
      v27 |= 0x20uLL;
    }
    goto LABEL_125;
  }
  uint64_t v39 = v38;
  if ((a1 & 0x80000000) != 0)
  {
    if (byte_1000EBCF8)
    {
      int v52 = *__error();
      CFStringRef v53 = sub_10002E548();
      if (os_log_type_enabled(v53, OS_LOG_TYPE_ERROR)) {
        sub_100086084();
      }
      *__error() = v52;
    }
    if (!byte_1000EBCF9 || dword_1000EB4A8 > 3) {
      goto LABEL_125;
    }
    int v32 = *__error();
    CFStringRef v54 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"Unable to get suspended state (%d), assuming not suspended", v39);
    if (!v54)
    {
      uint64_t v62 = sub_10002E548();
      if (os_log_type_enabled(v62, OS_LOG_TYPE_FAULT)) {
        sub_100086010();
      }
      goto LABEL_111;
    }
    CFStringRef v49 = v54;
    malloc_type_id_t v50 = CFStringGetCStringPtr(v54, 0x8000100u);
    if (!v50)
    {
      malloc_type_id_t v51 = 1475203759;
      goto LABEL_116;
    }
LABEL_94:
    CFStringRef v55 = (char *)v50;
    CFStringRef v56 = 0;
LABEL_117:
    if (qword_1000EBD00) {
      uint64_t v64 = (FILE *)qword_1000EBD00;
    }
    else {
      uint64_t v64 = __stderrp;
    }
    fprintf(v64, "%s\n", v55);
    if (v56) {
      free(v56);
    }
    CFStringRef v61 = v49;
    goto LABEL_123;
  }
  if (byte_1000EBCF8)
  {
    int v40 = *__error();
    CFStringRef v41 = sub_10002E548();
    if (os_log_type_enabled(v41, OS_LOG_TYPE_ERROR)) {
      sub_100085F90();
    }
    *__error() = v40;
  }
  if (byte_1000EBCF9 && dword_1000EB4A8 <= 3)
  {
    int v32 = *__error();
    int v42 = sub_10002E4E8(a1);
    CFStringRef v43 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%s [%d]: Unable to get suspended state (%d), assuming not suspended", v42, a1, v39);
    if (v43)
    {
      CFStringRef v35 = v43;
      uid_t v36 = CFStringGetCStringPtr(v43, 0x8000100u);
      if (!v36)
      {
        malloc_type_id_t v37 = 1475203759;
        goto LABEL_102;
      }
LABEL_74:
      int v44 = (char *)v36;
      int v45 = 0;
LABEL_103:
      if (qword_1000EBD00) {
        int v60 = (FILE *)qword_1000EBD00;
      }
      else {
        int v60 = __stderrp;
      }
      fprintf(v60, "%s\n", v44);
      if (v45) {
        free(v45);
      }
      CFStringRef v61 = v35;
LABEL_123:
      CFRelease(v61);
LABEL_124:
      *__error() = v32;
      goto LABEL_125;
    }
    int v59 = sub_10002E548();
    if (os_log_type_enabled(v59, OS_LOG_TYPE_FAULT)) {
      sub_100085F10();
    }
LABEL_111:
    if (qword_1000EBD00) {
      uint64_t v63 = (FILE *)qword_1000EBD00;
    }
    else {
      uint64_t v63 = __stderrp;
    }
    fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v63);
    goto LABEL_124;
  }
LABEL_125:
  if (sub_10002411C()) {
    uint64_t v65 = v27 | 0x400000000;
  }
  else {
    uint64_t v65 = v27;
  }
  BOOL v66 = sub_100047080();
  uint64_t v67 = v65 | 0x80000000000;
  if (!v66) {
    uint64_t v67 = v65;
  }
  *a4 |= v67;
  return v16;
}

uint64_t sub_100041218(double a1)
{
  if (a1 > 0.0)
  {
    if (a1 < 100.0)
    {
      if (qword_1000EBBA0 != -1) {
        dispatch_once(&qword_1000EBBA0, &stru_1000DD060);
      }
      double v2 = (double)rand() * 100.0 / 2147483650.0;
      BOOL v3 = v2 > a1;
      if (v2 > a1)
      {
        if (byte_1000EBCF8)
        {
          int v4 = *__error();
          uint64_t v5 = sub_10002E548();
          if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG)) {
            sub_100086534();
          }
          *__error() = v4;
        }
        if (byte_1000EBCF9) {
          BOOL v6 = dword_1000EB4A8 <= 0;
        }
        else {
          BOOL v6 = 0;
        }
        if (!v6) {
          return 1;
        }
        int v10 = *__error();
        CFStringRef v11 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"Should restrict submission due to roll of %.4f (pref is %.4f)", *(void *)&v2, *(void *)&a1);
        if (v11)
        {
          CFStringRef v12 = v11;
          CStringPtr = CFStringGetCStringPtr(v11, 0x8000100u);
          if (!CStringPtr)
          {
            malloc_type_id_t v14 = 340758073;
LABEL_39:
            uint64_t v16 = (char *)malloc_type_calloc(0x400uLL, 1uLL, v14);
            CFStringGetCString(v12, v16, 1024, 0x8000100u);
            int v17 = v16;
            goto LABEL_40;
          }
          goto LABEL_29;
        }
        unint64_t v18 = sub_10002E548();
        if (os_log_type_enabled(v18, OS_LOG_TYPE_FAULT)) {
          sub_1000864BC();
        }
        goto LABEL_34;
      }
      if (byte_1000EBCF8)
      {
        int v7 = *__error();
        int v8 = sub_10002E548();
        if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG)) {
          sub_100086624();
        }
        *__error() = v7;
      }
      if (byte_1000EBCF9) {
        BOOL v9 = dword_1000EB4A8 <= 0;
      }
      else {
        BOOL v9 = 0;
      }
      if (v9)
      {
        int v10 = *__error();
        CFStringRef v15 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"Should not restrict submission due to roll of %.4f (pref is %.4f)", *(void *)&v2, *(void *)&a1);
        if (v15)
        {
          CFStringRef v12 = v15;
          CStringPtr = CFStringGetCStringPtr(v15, 0x8000100u);
          if (!CStringPtr)
          {
            malloc_type_id_t v14 = 1617739763;
            goto LABEL_39;
          }
LABEL_29:
          uint64_t v16 = (char *)CStringPtr;
          int v17 = 0;
LABEL_40:
          if (qword_1000EBD00) {
            BOOL v21 = (FILE *)qword_1000EBD00;
          }
          else {
            BOOL v21 = __stderrp;
          }
          fprintf(v21, "%s\n", v16);
          if (v17) {
            free(v17);
          }
          CFRelease(v12);
LABEL_46:
          *__error() = v10;
          return v3;
        }
        BOOL v19 = sub_10002E548();
        if (os_log_type_enabled(v19, OS_LOG_TYPE_FAULT)) {
          sub_1000865AC();
        }
LABEL_34:
        if (qword_1000EBD00) {
          CFStringRef v20 = (FILE *)qword_1000EBD00;
        }
        else {
          CFStringRef v20 = __stderrp;
        }
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v20);
        goto LABEL_46;
      }
    }
    return 0;
  }
  return 1;
}

void sub_10004154C(uint64_t a1)
{
  uint64_t v2 = sub_10003FC18(*(unsigned int *)(a1 + 128), *(void **)(a1 + 32), *(void *)(a1 + 56), *(void *)(a1 + 64), *(void **)(a1 + 40), *(double *)(a1 + 72), *(double *)(a1 + 80), *(double *)(a1 + 88), *(double *)(a1 + 96), *(double *)(a1 + 104));
  sub_10002EFB4(*(_DWORD *)(a1 + 128), *(void **)(a1 + 32), *(void *)(a1 + 112), v2, *(void *)(a1 + 120) | v3, *(_DWORD *)(a1 + 64) & 1, *(double *)(a1 + 88) - *(double *)(a1 + 80), *(double *)(a1 + 88), *(double *)(a1 + 72));
  int v4 = *(void **)(a1 + 48);
}

uint64_t sub_1000415CC(uint64_t a1, void *a2, uint64_t a3, void *a4, uint64_t a5, uint64_t a6, double a7, double a8, double a9)
{
  id v18 = objc_alloc_init((Class)SAMicrostackshotStatistics);
  BOOL v19 = [a2 UTF8String];
  id v20 = [a4 UTF8String];
  uint64_t v21 = sub_100025D2C(0, 0, a1, v19, 0, 1, (uint64_t)v20, 0, a8 - a7, a8, 0.0, 0.0, a7, 0.0, a9, 6u, HIBYTE(word_1000EBD38) & 1, a5, a6,
          a3,
          SHIDWORD(a3),
          8u,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          (uint64_t)v18);
  uint64_t v22 = [[[v18 total] num_out_of_order] != 0;
  if (objc_msgSend(objc_msgSend(v18, "total"), "num_missing_load_info")) {
    uint64_t v23 = ((unint64_t)(v22 & 1) << 41) | 0x10000000000;
  }
  else {
    uint64_t v23 = v22 << 41;
  }
  if (objc_msgSend(v18, "bytes_not_microstackshots")) {
    v23 |= 0x40000000000uLL;
  }
  if ((v21 & 0x800000) != 0)
  {
    if ((a1 & 0x80000000) == 0)
    {
      if (byte_1000EBCF8)
      {
        int v32 = *__error();
        malloc_type_id_t v33 = sub_10002E548();
        if (os_log_type_enabled(v33, OS_LOG_TYPE_ERROR)) {
          sub_100086C6C(a1, v18, v33);
        }
        *__error() = v32;
      }
      if (byte_1000EBCF9 && dword_1000EB4A8 <= 3)
      {
        int v26 = *__error();
        CFStringRef v34 = sub_10002E4E8(a1);
        CFStringRef v35 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%s [%d]: disk writes: no microstackshots: %llu out-of-order microstackshots, %llu microstackshots missing load infos, %llu bytes invalid", v34, a1, [objc_msgSend(objc_msgSend(v18, "total"), "num_out_of_order")], [objc_msgSend(objc_msgSend(v18, "total"), "num_missing_load_info")], [v18 bytes_not_microstackshots]);
        if (v35)
        {
          CFStringRef v29 = v35;
          CStringPtr = CFStringGetCStringPtr(v35, 0x8000100u);
          if (!CStringPtr)
          {
            malloc_type_id_t v31 = 3820453995;
            goto LABEL_80;
          }
LABEL_37:
          int v40 = (char *)CStringPtr;
          CFStringRef v41 = 0;
LABEL_81:
          if (qword_1000EBD00) {
            uint64_t v63 = (FILE *)qword_1000EBD00;
          }
          else {
            uint64_t v63 = __stderrp;
          }
          fprintf(v63, "%s\n", v40);
          if (v41) {
            free(v41);
          }
          CFRelease(v29);
          goto LABEL_87;
        }
        uint64_t v57 = sub_10002E548();
        if (os_log_type_enabled(v57, OS_LOG_TYPE_FAULT)) {
          sub_100086BD8(a1, v18, v57);
        }
LABEL_73:
        if (qword_1000EBD00) {
          CFStringRef v61 = (FILE *)qword_1000EBD00;
        }
        else {
          CFStringRef v61 = __stderrp;
        }
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v61);
LABEL_87:
        *__error() = v26;
      }
LABEL_88:
      if (byte_1000EBCF8)
      {
        int v64 = *__error();
        uint64_t v65 = sub_10002E548();
        if (os_log_type_enabled(v65, OS_LOG_TYPE_DEBUG)) {
          sub_10008671C();
        }
        *__error() = v64;
      }
      if (byte_1000EBCF9 && dword_1000EB4A8 <= 0)
      {
        int v66 = *__error();
        uint64_t v67 = sub_10002E4E8(a1);
        CFStringRef v68 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%s [%d]: disk writes: done reporting (%#llx)", v67, a1, v21);
        if (v68)
        {
          CFStringRef v69 = v68;
          CFStringRef v70 = CFStringGetCStringPtr(v68, 0x8000100u);
          if (v70)
          {
            long long v71 = (char *)v70;
            uint64_t v72 = 0;
          }
          else
          {
            long long v71 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x2BF25E08uLL);
            CFStringGetCString(v69, v71, 1024, 0x8000100u);
            uint64_t v72 = v71;
          }
          if (qword_1000EBD00) {
            uint64_t v74 = (FILE *)qword_1000EBD00;
          }
          else {
            uint64_t v74 = __stderrp;
          }
          fprintf(v74, "%s\n", v71);
          if (v72) {
            free(v72);
          }
          CFStringRef v75 = v69;
LABEL_143:
          CFRelease(v75);
LABEL_144:
          *__error() = v66;
          goto LABEL_145;
        }
        task_name_t v73 = sub_10002E548();
        if (os_log_type_enabled(v73, OS_LOG_TYPE_FAULT)) {
          sub_10008669C();
        }
        goto LABEL_132;
      }
      goto LABEL_145;
    }
    if (byte_1000EBCF8)
    {
      int v42 = *__error();
      CFStringRef v43 = sub_10002E548();
      if (os_log_type_enabled(v43, OS_LOG_TYPE_ERROR)) {
        sub_100086D90();
      }
      *__error() = v42;
    }
    if (byte_1000EBCF9 && dword_1000EB4A8 <= 3)
    {
      int v44 = *__error();
      CFStringRef v45 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"disk writes: no microstackshots: %llu out-of-order microstackshots, %llu microstackshots missing load infos, %llu bytes invalid", [objc_msgSend(objc_msgSend(v18, "total"), "num_out_of_order"), [objc_msgSend(objc_msgSend(v18, "total"), "num_missing_load_info"), [v18 bytes_not_microstackshots];
      if (v45)
      {
        CFStringRef v46 = v45;
        CFStringRef v47 = CFStringGetCStringPtr(v45, 0x8000100u);
        if (!v47)
        {
          malloc_type_id_t v48 = 3820453995;
LABEL_113:
          CFStringRef v55 = (char *)malloc_type_calloc(0x400uLL, 1uLL, v48);
          CFStringGetCString(v46, v55, 1024, 0x8000100u);
          CFStringRef v56 = v55;
          goto LABEL_114;
        }
LABEL_64:
        CFStringRef v55 = (char *)v47;
        CFStringRef v56 = 0;
LABEL_114:
        if (qword_1000EBD00) {
          CFStringRef v78 = (FILE *)qword_1000EBD00;
        }
        else {
          CFStringRef v78 = __stderrp;
        }
        fprintf(v78, "%s\n", v55);
        if (v56) {
          free(v56);
        }
        CFRelease(v46);
        goto LABEL_120;
      }
      int v59 = sub_10002E548();
      if (os_log_type_enabled(v59, OS_LOG_TYPE_FAULT)) {
        sub_100086D00();
      }
LABEL_108:
      if (qword_1000EBD00) {
        CFStringRef v77 = (FILE *)qword_1000EBD00;
      }
      else {
        CFStringRef v77 = __stderrp;
      }
      fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v77);
LABEL_120:
      *__error() = v44;
    }
  }
  else if (v23)
  {
    if ((a1 & 0x80000000) == 0)
    {
      if (byte_1000EBCF8)
      {
        int v24 = *__error();
        uint64_t v25 = sub_10002E548();
        if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136447234;
          unsigned int v91 = sub_10002E4E8(a1);
          __int16 v92 = 1024;
          *(_DWORD *)unsigned int v93 = a1;
          *(_WORD *)&v93[4] = 2048;
          *(void *)&v93[6] = [objc_msgSend(v18, "total") num_out_of_order];
          *(_WORD *)&v93[14] = 2048;
          *(void *)&v93[16] = [objc_msgSend(objc_msgSend(v18, "total"), "num_missing_load_info")];
          __int16 v94 = 2048;
          id v95 = [v18 bytes_not_microstackshots];
          _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "%{public}s [%d]: disk writes: some microstackshots with errors: %llu out-of-order microstackshots, %llu microstackshots missing load infos, %llu bytes invalid", buf, 0x30u);
        }
        *__error() = v24;
      }
      if (byte_1000EBCF9 && dword_1000EB4A8 <= 2)
      {
        int v26 = *__error();
        uint64_t v27 = sub_10002E4E8(a1);
        CFStringRef v28 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%s [%d]: disk writes: some microstackshots with errors: %llu out-of-order microstackshots, %llu microstackshots missing load infos, %llu bytes invalid", v27, a1, [objc_msgSend(objc_msgSend(v18, "total"), "num_out_of_order")], [objc_msgSend(objc_msgSend(v18, "total"), "num_missing_load_info")], [v18 bytes_not_microstackshots]);
        if (v28)
        {
          CFStringRef v29 = v28;
          CStringPtr = CFStringGetCStringPtr(v28, 0x8000100u);
          if (!CStringPtr)
          {
            malloc_type_id_t v31 = 2227676325;
LABEL_80:
            int v40 = (char *)malloc_type_calloc(0x400uLL, 1uLL, v31);
            CFStringGetCString(v29, v40, 1024, 0x8000100u);
            CFStringRef v41 = v40;
            goto LABEL_81;
          }
          goto LABEL_37;
        }
        int v58 = sub_10002E548();
        if (os_log_type_enabled(v58, OS_LOG_TYPE_FAULT)) {
          sub_100086AB4(a1, v18, v58);
        }
        goto LABEL_73;
      }
      goto LABEL_88;
    }
    if (byte_1000EBCF8)
    {
      int v49 = *__error();
      malloc_type_id_t v50 = sub_10002E548();
      if (os_log_type_enabled(v50, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 134218496;
        unsigned int v91 = [v18 total].num_out_of_order;
        __int16 v92 = 2048;
        *(void *)unsigned int v93 = [v18 total].num_missing_load_info;
        *(_WORD *)&v93[8] = 2048;
        *(void *)&v93[10] = [v18 bytes_not_microstackshots];
        _os_log_impl((void *)&_mh_execute_header, v50, OS_LOG_TYPE_DEFAULT, "disk writes: some microstackshots with errors: %llu out-of-order microstackshots, %llu microstackshots missing load infos, %llu bytes invalid", buf, 0x20u);
      }
      *__error() = v49;
    }
    if (byte_1000EBCF9 && dword_1000EB4A8 <= 2)
    {
      int v44 = *__error();
      CFStringRef v51 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"disk writes: some microstackshots with errors: %llu out-of-order microstackshots, %llu microstackshots missing load infos, %llu bytes invalid", [objc_msgSend(objc_msgSend(v18, "total"), "num_out_of_order"), [objc_msgSend(objc_msgSend(v18, "total"), "num_missing_load_info"), [v18 bytes_not_microstackshots]]);
      if (v51)
      {
        CFStringRef v46 = v51;
        CFStringRef v47 = CFStringGetCStringPtr(v51, 0x8000100u);
        if (!v47)
        {
          malloc_type_id_t v48 = 2227676325;
          goto LABEL_113;
        }
        goto LABEL_64;
      }
      uint64_t v62 = sub_10002E548();
      if (os_log_type_enabled(v62, OS_LOG_TYPE_FAULT)) {
        sub_100086B48();
      }
      goto LABEL_108;
    }
  }
  else
  {
    if ((a1 & 0x80000000) == 0)
    {
      if (byte_1000EBCF8)
      {
        int v36 = *__error();
        malloc_type_id_t v37 = sub_10002E548();
        if (os_log_type_enabled(v37, OS_LOG_TYPE_DEBUG)) {
          sub_100086830(a1, v18, v37);
        }
        *__error() = v36;
      }
      if (byte_1000EBCF9 && dword_1000EB4A8 <= 0)
      {
        int v26 = *__error();
        uint64_t v38 = sub_10002E4E8(a1);
        CFStringRef v39 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%s [%d]: disk writes: all microstackshots without errors: %llu out-of-order microstackshots, %llu microstackshots missing load infos, %llu bytes invalid", v38, a1, [objc_msgSend(objc_msgSend(v18, "total"), "num_out_of_order")], [objc_msgSend(objc_msgSend(v18, "total"), "num_missing_load_info")], [v18 bytes_not_microstackshots]);
        if (v39)
        {
          CFStringRef v29 = v39;
          CStringPtr = CFStringGetCStringPtr(v39, 0x8000100u);
          if (!CStringPtr)
          {
            malloc_type_id_t v31 = 4090237050;
            goto LABEL_80;
          }
          goto LABEL_37;
        }
        int v60 = sub_10002E548();
        if (os_log_type_enabled(v60, OS_LOG_TYPE_FAULT)) {
          sub_10008679C(a1, v18, v60);
        }
        goto LABEL_73;
      }
      goto LABEL_88;
    }
    if (byte_1000EBCF8)
    {
      int v52 = *__error();
      CFStringRef v53 = sub_10002E548();
      if (os_log_type_enabled(v53, OS_LOG_TYPE_DEBUG)) {
        sub_100086A24();
      }
      *__error() = v52;
    }
    if (byte_1000EBCF9 && dword_1000EB4A8 <= 0)
    {
      int v44 = *__error();
      CFStringRef v54 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"disk writes: all microstackshots without errors: %llu out-of-order microstackshots, %llu microstackshots missing load infos, %llu bytes invalid", [objc_msgSend(objc_msgSend(v18, "total"), "num_out_of_order")], [objc_msgSend(objc_msgSend(v18, "total"), "num_missing_load_info")], [objc_msgSend(v18, "bytes_not_microstackshots")]);
      if (v54)
      {
        CFStringRef v46 = v54;
        CFStringRef v47 = CFStringGetCStringPtr(v54, 0x8000100u);
        if (!v47)
        {
          malloc_type_id_t v48 = 4090237050;
          goto LABEL_113;
        }
        goto LABEL_64;
      }
      uint64_t v76 = sub_10002E548();
      if (os_log_type_enabled(v76, OS_LOG_TYPE_FAULT)) {
        sub_100086994();
      }
      goto LABEL_108;
    }
  }
  if (byte_1000EBCF8)
  {
    int v79 = *__error();
    CFStringRef v80 = sub_10002E548();
    if (os_log_type_enabled(v80, OS_LOG_TYPE_DEBUG)) {
      sub_10008692C();
    }
    *__error() = v79;
  }
  if (byte_1000EBCF9 && dword_1000EB4A8 <= 0)
  {
    int v66 = *__error();
    CFStringRef v81 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"disk writes: done reporting (%#llx)", v21);
    if (v81)
    {
      CFStringRef v82 = v81;
      CFStringRef v83 = CFStringGetCStringPtr(v81, 0x8000100u);
      if (v83)
      {
        CFStringRef v84 = (char *)v83;
        int v85 = 0;
      }
      else
      {
        CFStringRef v84 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x2BF25E08uLL);
        CFStringGetCString(v82, v84, 1024, 0x8000100u);
        int v85 = v84;
      }
      if (qword_1000EBD00) {
        CFStringRef v88 = (FILE *)qword_1000EBD00;
      }
      else {
        CFStringRef v88 = __stderrp;
      }
      fprintf(v88, "%s\n", v84);
      if (v85) {
        free(v85);
      }
      CFStringRef v75 = v82;
      goto LABEL_143;
    }
    uint64_t v86 = sub_10002E548();
    if (os_log_type_enabled(v86, OS_LOG_TYPE_FAULT)) {
      sub_1000868C4();
    }
LABEL_132:
    if (qword_1000EBD00) {
      id v87 = (FILE *)qword_1000EBD00;
    }
    else {
      id v87 = __stderrp;
    }
    fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v87);
    goto LABEL_144;
  }
LABEL_145:

  return v21;
}

void sub_100042330(uint64_t a1, id a2, uint64_t a3, uint64_t a4, _DWORD *a5, uint64_t a6, double a7, double a8, double a9)
{
  if ((a1 & 0x80000000) == 0)
  {
    if (byte_1000EBCF8)
    {
      int v17 = *__error();
      id v18 = sub_10002E548();
      if (os_log_type_enabled(v18, OS_LOG_TYPE_INFO))
      {
        *(_DWORD *)buf = 136447234;
        CFStringRef v150 = sub_10002E4E8(a1);
        __int16 v151 = 1024;
        *(_DWORD *)id v152 = a1;
        *(_WORD *)&v152[4] = 2048;
        *(void *)&v152[6] = a5;
        *(_WORD *)&v152[14] = 2048;
        *(double *)&v152[16] = a7;
        __int16 v153 = 2048;
        uint64_t v154 = a3;
        _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_INFO, "%{public}s [%d]: disk writes: %llu bytes over the last %.0f seconds with flags %#llx", buf, 0x30u);
      }
      *__error() = v17;
    }
    if (byte_1000EBCF9) {
      BOOL v19 = dword_1000EB4A8 <= 1;
    }
    else {
      BOOL v19 = 0;
    }
    if (!v19) {
      goto LABEL_52;
    }
    int v20 = *__error();
    uint64_t v21 = sub_10002E4E8(a1);
    CFStringRef v22 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%s [%d]: disk writes: %llu bytes over the last %.0f seconds with flags %#llx", v21, a1, a5, *(void *)&a7, a3);
    if (v22)
    {
      CFStringRef v23 = v22;
      id v24 = a2;
      CStringPtr = CFStringGetCStringPtr(v22, 0x8000100u);
      if (CStringPtr)
      {
        int v26 = (char *)CStringPtr;
        uint64_t v27 = 0;
      }
      else
      {
        int v26 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x36D359F3uLL);
        CFStringGetCString(v23, v26, 1024, 0x8000100u);
        uint64_t v27 = v26;
      }
      if (qword_1000EBD00) {
        CFStringRef v39 = (FILE *)qword_1000EBD00;
      }
      else {
        CFStringRef v39 = __stderrp;
      }
      fprintf(v39, "%s\n", v26);
      if (v27) {
        free(v27);
      }
      CFRelease(v23);
      a2 = v24;
      goto LABEL_51;
    }
    malloc_type_id_t v37 = sub_10002E548();
    if (os_log_type_enabled(v37, OS_LOG_TYPE_FAULT))
    {
      __int16 v135 = sub_10002E4E8(a1);
      *(_DWORD *)buf = 136316162;
      CFStringRef v150 = v135;
      __int16 v151 = 1024;
      *(_DWORD *)id v152 = a1;
      *(_WORD *)&v152[4] = 2048;
      *(void *)&v152[6] = a5;
      *(_WORD *)&v152[14] = 2048;
      *(double *)&v152[16] = a7;
      __int16 v153 = 2048;
      uint64_t v154 = a3;
      _os_log_fault_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_FAULT, "Unable to format: %s [%d]: disk writes: %llu bytes over the last %.0f seconds with flags %#llx", buf, 0x30u);
    }
    if (qword_1000EBD00) {
      uint64_t v38 = (FILE *)qword_1000EBD00;
    }
    else {
      uint64_t v38 = __stderrp;
    }
LABEL_31:
    fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v38);
LABEL_51:
    *__error() = v20;
    goto LABEL_52;
  }
  if (byte_1000EBCF8)
  {
    int v28 = *__error();
    CFStringRef v29 = sub_10002E548();
    if (os_log_type_enabled(v29, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 134218496;
      CFStringRef v150 = a5;
      __int16 v151 = 2048;
      *(double *)id v152 = a7;
      *(_WORD *)&v152[8] = 2048;
      *(void *)&v152[10] = a3;
      _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_INFO, "disk writes: %llu bytes over the last %.0f seconds with flags %#llx", buf, 0x20u);
    }
    *__error() = v28;
  }
  if (byte_1000EBCF9) {
    BOOL v30 = dword_1000EB4A8 <= 1;
  }
  else {
    BOOL v30 = 0;
  }
  if (v30)
  {
    int v20 = *__error();
    CFStringRef v31 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"disk writes: %llu bytes over the last %.0f seconds with flags %#llx", a5, *(void *)&a7, a3);
    if (v31)
    {
      CFStringRef v32 = v31;
      id v33 = a2;
      CFStringRef v34 = CFStringGetCStringPtr(v31, 0x8000100u);
      if (v34)
      {
        CFStringRef v35 = (char *)v34;
        int v36 = 0;
      }
      else
      {
        CFStringRef v35 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x36D359F3uLL);
        CFStringGetCString(v32, v35, 1024, 0x8000100u);
        int v36 = v35;
      }
      if (qword_1000EBD00) {
        CFStringRef v41 = (FILE *)qword_1000EBD00;
      }
      else {
        CFStringRef v41 = __stderrp;
      }
      fprintf(v41, "%s\n", v35);
      if (v36) {
        free(v36);
      }
      CFRelease(v32);
      a2 = v33;
      goto LABEL_51;
    }
    int v40 = sub_10002E548();
    if (os_log_type_enabled(v40, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)buf = 134218496;
      CFStringRef v150 = a5;
      __int16 v151 = 2048;
      *(double *)id v152 = a7;
      *(_WORD *)&v152[8] = 2048;
      *(void *)&v152[10] = a3;
      _os_log_fault_impl((void *)&_mh_execute_header, v40, OS_LOG_TYPE_FAULT, "Unable to format: disk writes: %llu bytes over the last %.0f seconds with flags %#llx", buf, 0x20u);
    }
    if (qword_1000EBD00) {
      uint64_t v38 = (FILE *)qword_1000EBD00;
    }
    else {
      uint64_t v38 = __stderrp;
    }
    goto LABEL_31;
  }
LABEL_52:
  uint64_t v145 = sub_10002E5C4(a1);
  if (!a2) {
    a2 = sub_10002E60C(a1);
  }
  id v42 = a2;
  uint64_t v148 = 0;
  uint64_t v43 = sub_100040988(a1, (uint64_t)"disk writes", 160, &v148);
  if ((word_1000EBD38 & 0x100) == 0)
  {
    if ((a1 & 0x80000000) != 0)
    {
      if (byte_1000EBCF8)
      {
        int v50 = *__error();
        CFStringRef v51 = sub_10002E548();
        if (os_log_type_enabled(v51, OS_LOG_TYPE_DEBUG)) {
          sub_100087388();
        }
        *__error() = v50;
      }
      if (!byte_1000EBCF9 || dword_1000EB4A8 > 0) {
        goto LABEL_88;
      }
      uint64_t v142 = a6;
      id v143 = v42;
      int v46 = *__error();
      CFStringRef v48 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"disk writes: not monitoring due to suppression cookie file");
      if (!v48)
      {
        int v59 = sub_10002E548();
        if (os_log_type_enabled(v59, OS_LOG_TYPE_FAULT)) {
          sub_100087354();
        }
        goto LABEL_83;
      }
    }
    else
    {
      if (byte_1000EBCF8)
      {
        int v44 = *__error();
        CFStringRef v45 = sub_10002E548();
        if (os_log_type_enabled(v45, OS_LOG_TYPE_DEBUG)) {
          sub_1000872DC();
        }
        *__error() = v44;
      }
      if (!byte_1000EBCF9 || dword_1000EB4A8 > 0) {
        goto LABEL_88;
      }
      uint64_t v142 = a6;
      id v143 = v42;
      int v46 = *__error();
      CFStringRef v47 = sub_10002E4E8(a1);
      CFStringRef v48 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%s [%d]: disk writes: not monitoring due to suppression cookie file", v47, a1);
      if (!v48)
      {
        int v49 = sub_10002E548();
        if (os_log_type_enabled(v49, OS_LOG_TYPE_FAULT)) {
          sub_100087264();
        }
LABEL_83:
        if (qword_1000EBD00) {
          int v60 = (FILE *)qword_1000EBD00;
        }
        else {
          int v60 = __stderrp;
        }
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v60);
LABEL_87:
        *__error() = v46;
        a6 = v142;
        id v42 = v143;
LABEL_88:
        v43 |= 0x8000uLL;
        goto LABEL_89;
      }
    }
    CFStringRef v52 = v48;
    uint64_t v53 = a3;
    CFStringRef v54 = a5;
    CFStringRef v55 = CFStringGetCStringPtr(v48, 0x8000100u);
    if (v55)
    {
      CFStringRef v56 = (char *)v55;
      uint64_t v57 = 0;
    }
    else
    {
      CFStringRef v56 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x28AEDC45uLL);
      CFStringGetCString(v52, v56, 1024, 0x8000100u);
      uint64_t v57 = v56;
    }
    if (qword_1000EBD00) {
      int v58 = (FILE *)qword_1000EBD00;
    }
    else {
      int v58 = __stderrp;
    }
    fprintf(v58, "%s\n", v56);
    if (v57) {
      free(v57);
    }
    CFRelease(v52);
    a5 = v54;
    a3 = v53;
    goto LABEL_87;
  }
LABEL_89:
  if (!sub_100041218(*(double *)&qword_1000EBD28))
  {
    if (v43) {
      goto LABEL_148;
    }
    uint64_t v67 = (uint64_t)a5;
    uint64_t v68 = v148;
    uint64_t v69 = (uint64_t)v42;
    if ((v148 & 0x80000000000) == 0)
    {
LABEL_102:
      uint64_t v70 = sub_10002E390("Disk writes resource for [%d]", a1);
      dispatch_queue_global_t global_queue = dispatch_get_global_queue(9, 0);
      block[0] = _NSConcreteStackBlock;
      block[1] = 3221225472;
      block[2] = sub_100043620;
      block[3] = &unk_1000DCFF0;
      int v147 = a1;
      block[4] = v69;
      void block[5] = a4;
      block[7] = a3;
      block[8] = v67;
      *(double *)&block[9] = a7;
      *(double *)&block[10] = a8;
      block[11] = a6;
      *(double *)&block[12] = a9;
      block[13] = v145;
      block[14] = v68;
      void block[6] = v70;
      dispatch_async(global_queue, block);
      return;
    }
    uint64_t v78 = a6;
    if (sub_10004DBA8())
    {
      if ((a1 & 0x80000000) != 0)
      {
        if (byte_1000EBCF8)
        {
          int v119 = *__error();
          CFStringRef v120 = sub_10002E548();
          if (os_log_type_enabled(v120, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)buf = 0;
            _os_log_impl((void *)&_mh_execute_header, v120, OS_LOG_TYPE_DEFAULT, "disk writes: deferring report generation due to game mode", buf, 2u);
          }
          *__error() = v119;
        }
        if (!byte_1000EBCF9 || dword_1000EB4A8 > 2) {
          goto LABEL_222;
        }
        int v82 = *__error();
        CFStringRef v84 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"disk writes: deferring report generation due to game mode");
        if (!v84)
        {
          id v138 = sub_10002E548();
          if (os_log_type_enabled(v138, OS_LOG_TYPE_FAULT)) {
            sub_1000870D8();
          }
          goto LABEL_217;
        }
      }
      else
      {
        if (byte_1000EBCF8)
        {
          int v79 = *__error();
          CFStringRef v80 = sub_10002E548();
          if (os_log_type_enabled(v80, OS_LOG_TYPE_DEFAULT))
          {
            CFStringRef v81 = sub_10002E4E8(a1);
            *(_DWORD *)buf = 136446466;
            CFStringRef v150 = v81;
            __int16 v151 = 1024;
            *(_DWORD *)id v152 = a1;
            _os_log_impl((void *)&_mh_execute_header, v80, OS_LOG_TYPE_DEFAULT, "%{public}s [%d]: disk writes: deferring report generation due to game mode", buf, 0x12u);
          }
          *__error() = v79;
          uint64_t v69 = (uint64_t)v42;
        }
        if (!byte_1000EBCF9 || dword_1000EB4A8 > 2) {
          goto LABEL_222;
        }
        int v82 = *__error();
        CFStringRef v83 = sub_10002E4E8(a1);
        CFStringRef v84 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%s [%d]: disk writes: deferring report generation due to game mode", v83, a1);
        if (!v84)
        {
          int v85 = sub_10002E548();
          if (os_log_type_enabled(v85, OS_LOG_TYPE_FAULT)) {
            sub_100087060();
          }
LABEL_217:
          if (qword_1000EBD00) {
            id v139 = (FILE *)qword_1000EBD00;
          }
          else {
            id v139 = __stderrp;
          }
          fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v139);
          uint64_t v69 = (uint64_t)v42;
LABEL_221:
          *__error() = v82;
LABEL_222:
          sub_10004F54C(a1, v69, a3, a4, v67, v78, a7, a8, a9);
          uint64_t v111 = v68 | 0x100000000000;
          double v112 = a8 - a7;
          int v113 = a1;
          id v114 = (void *)v69;
          uint64_t v115 = v145;
          uint64_t v116 = 0;
          double v117 = a8;
          uint64_t v118 = v67;
          goto LABEL_182;
        }
      }
      CFStringRef v121 = v84;
      uint64_t v122 = a3;
      uint64_t v123 = (uint64_t)v42;
      uint64_t v124 = CFStringGetCStringPtr(v84, 0x8000100u);
      if (v124)
      {
        uint64_t v125 = (char *)v124;
        uint64_t v126 = 0;
      }
      else
      {
        uint64_t v125 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xD316BA6BuLL);
        CFStringGetCString(v121, v125, 1024, 0x8000100u);
        uint64_t v126 = v125;
      }
      if (qword_1000EBD00) {
        uint64_t v136 = (FILE *)qword_1000EBD00;
      }
      else {
        uint64_t v136 = __stderrp;
      }
      fprintf(v136, "%s\n", v125);
      if (v126) {
        free(v126);
      }
      CFRelease(v121);
      uint64_t v69 = v123;
      a3 = v122;
      goto LABEL_221;
    }
    if ((a1 & 0x80000000) != 0)
    {
      if (byte_1000EBCF8)
      {
        int v127 = *__error();
        unsigned int v128 = sub_10002E548();
        if (os_log_type_enabled(v128, OS_LOG_TYPE_DEBUG)) {
          sub_100087230();
        }
        *__error() = v127;
      }
      a6 = v78;
      if (!byte_1000EBCF9 || dword_1000EB4A8 > 0) {
        goto LABEL_102;
      }
      int v89 = *__error();
      CFStringRef v91 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"disk writes: cannot defer report generation for game mode");
      if (!v91)
      {
        CFStringRef v140 = sub_10002E548();
        if (os_log_type_enabled(v140, OS_LOG_TYPE_FAULT)) {
          sub_1000871FC();
        }
        goto LABEL_225;
      }
    }
    else
    {
      if (byte_1000EBCF8)
      {
        int v87 = *__error();
        CFStringRef v88 = sub_10002E548();
        if (os_log_type_enabled(v88, OS_LOG_TYPE_DEBUG)) {
          sub_100087184();
        }
        *__error() = v87;
      }
      a6 = v78;
      if (!byte_1000EBCF9 || dword_1000EB4A8 > 0) {
        goto LABEL_102;
      }
      int v89 = *__error();
      unint64_t v90 = sub_10002E4E8(a1);
      CFStringRef v91 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%s [%d]: disk writes: cannot defer report generation for game mode", v90, a1);
      if (!v91)
      {
        __int16 v92 = sub_10002E548();
        if (os_log_type_enabled(v92, OS_LOG_TYPE_FAULT)) {
          sub_10008710C();
        }
LABEL_225:
        if (qword_1000EBD00) {
          int v141 = (FILE *)qword_1000EBD00;
        }
        else {
          int v141 = __stderrp;
        }
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v141);
        uint64_t v69 = (uint64_t)v42;
LABEL_229:
        *__error() = v89;
        a6 = v78;
        goto LABEL_102;
      }
    }
    CFStringRef v129 = v91;
    uint64_t v130 = a3;
    uint64_t v131 = (uint64_t)v42;
    uint64_t v132 = CFStringGetCStringPtr(v91, 0x8000100u);
    if (v132)
    {
      __int16 v133 = (char *)v132;
      int v134 = 0;
    }
    else
    {
      __int16 v133 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xEE8D44B6uLL);
      CFStringGetCString(v129, v133, 1024, 0x8000100u);
      int v134 = v133;
    }
    if (qword_1000EBD00) {
      int v137 = (FILE *)qword_1000EBD00;
    }
    else {
      int v137 = __stderrp;
    }
    fprintf(v137, "%s\n", v133);
    if (v134) {
      free(v134);
    }
    CFRelease(v129);
    uint64_t v69 = v131;
    a3 = v130;
    goto LABEL_229;
  }
  if ((a1 & 0x80000000) != 0)
  {
    if (byte_1000EBCF8)
    {
      int v72 = *__error();
      task_name_t v73 = sub_10002E548();
      if (os_log_type_enabled(v73, OS_LOG_TYPE_DEBUG)) {
        sub_10008702C();
      }
      *__error() = v72;
    }
    if (!byte_1000EBCF9 || dword_1000EB4A8 > 0) {
      goto LABEL_147;
    }
    int v63 = *__error();
    CFStringRef v65 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"disk writes: not monitoring due to tasking-specified sampling");
    if (!v65)
    {
      unsigned int v93 = sub_10002E548();
      if (os_log_type_enabled(v93, OS_LOG_TYPE_FAULT)) {
        sub_100086FF8();
      }
      goto LABEL_142;
    }
LABEL_110:
    CFStringRef v74 = v65;
    CFStringRef v75 = CFStringGetCStringPtr(v65, 0x8000100u);
    if (v75)
    {
      uint64_t v76 = (char *)v75;
      CFStringRef v77 = 0;
    }
    else
    {
      uint64_t v76 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xE8279266uLL);
      CFStringGetCString(v74, v76, 1024, 0x8000100u);
      CFStringRef v77 = v76;
    }
    if (qword_1000EBD00) {
      uint64_t v86 = (FILE *)qword_1000EBD00;
    }
    else {
      uint64_t v86 = __stderrp;
    }
    fprintf(v86, "%s\n", v76);
    if (v77) {
      free(v77);
    }
    CFRelease(v74);
    goto LABEL_146;
  }
  if (byte_1000EBCF8)
  {
    int v61 = *__error();
    uint64_t v62 = sub_10002E548();
    if (os_log_type_enabled(v62, OS_LOG_TYPE_DEBUG)) {
      sub_100086F80();
    }
    *__error() = v61;
  }
  if (!byte_1000EBCF9 || dword_1000EB4A8 > 0) {
    goto LABEL_147;
  }
  int v63 = *__error();
  int v64 = sub_10002E4E8(a1);
  CFStringRef v65 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%s [%d]: disk writes: not monitoring due to tasking-specified sampling", v64, a1);
  if (v65) {
    goto LABEL_110;
  }
  int v66 = sub_10002E548();
  if (os_log_type_enabled(v66, OS_LOG_TYPE_FAULT)) {
    sub_100086F08();
  }
LABEL_142:
  if (qword_1000EBD00) {
    __int16 v94 = (FILE *)qword_1000EBD00;
  }
  else {
    __int16 v94 = __stderrp;
  }
  fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v94);
LABEL_146:
  *__error() = v63;
LABEL_147:
  v43 |= 0x200000uLL;
LABEL_148:
  if ((a1 & 0x80000000) != 0)
  {
    if (byte_1000EBCF8)
    {
      int v102 = *__error();
      id v103 = sub_10002E548();
      if (os_log_type_enabled(v103, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 134217984;
        CFStringRef v150 = (_DWORD *)v43;
        _os_log_impl((void *)&_mh_execute_header, v103, OS_LOG_TYPE_DEFAULT, "disk writes: not monitoring due to conditions %#llx", buf, 0xCu);
      }
      *__error() = v102;
    }
    if (!byte_1000EBCF9 || dword_1000EB4A8 > 2) {
      goto LABEL_181;
    }
    int v98 = *__error();
    CFStringRef v100 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"disk writes: not monitoring due to conditions %#llx", v43);
    if (!v100)
    {
      int v109 = sub_10002E548();
      if (os_log_type_enabled(v109, OS_LOG_TYPE_FAULT)) {
        sub_100086EA0();
      }
      goto LABEL_176;
    }
LABEL_165:
    CFStringRef v104 = v100;
    uint64_t v105 = CFStringGetCStringPtr(v100, 0x8000100u);
    if (v105)
    {
      qos_class_t v106 = (char *)v105;
      CFStringRef v107 = 0;
    }
    else
    {
      qos_class_t v106 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x9A00514DuLL);
      CFStringGetCString(v104, v106, 1024, 0x8000100u);
      CFStringRef v107 = v106;
    }
    if (qword_1000EBD00) {
      CFStringRef v108 = (FILE *)qword_1000EBD00;
    }
    else {
      CFStringRef v108 = __stderrp;
    }
    fprintf(v108, "%s\n", v106);
    if (v107) {
      free(v107);
    }
    CFRelease(v104);
    goto LABEL_180;
  }
  if (byte_1000EBCF8)
  {
    int v95 = *__error();
    __int16 v96 = sub_10002E548();
    if (os_log_type_enabled(v96, OS_LOG_TYPE_DEFAULT))
    {
      id v97 = sub_10002E4E8(a1);
      *(_DWORD *)buf = 136446722;
      CFStringRef v150 = v97;
      __int16 v151 = 1024;
      *(_DWORD *)id v152 = a1;
      *(_WORD *)&v152[4] = 2048;
      *(void *)&v152[6] = v43;
      _os_log_impl((void *)&_mh_execute_header, v96, OS_LOG_TYPE_DEFAULT, "%{public}s [%d]: disk writes: not monitoring due to conditions %#llx", buf, 0x1Cu);
    }
    *__error() = v95;
  }
  if (!byte_1000EBCF9 || dword_1000EB4A8 > 2) {
    goto LABEL_181;
  }
  int v98 = *__error();
  CFStringRef v99 = sub_10002E4E8(a1);
  CFStringRef v100 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%s [%d]: disk writes: not monitoring due to conditions %#llx", v99, a1, v43);
  if (v100) {
    goto LABEL_165;
  }
  malloc_type_id_t v101 = sub_10002E548();
  if (os_log_type_enabled(v101, OS_LOG_TYPE_FAULT)) {
    sub_100086E20();
  }
LABEL_176:
  if (qword_1000EBD00) {
    id v110 = (FILE *)qword_1000EBD00;
  }
  else {
    id v110 = __stderrp;
  }
  fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v110);
LABEL_180:
  *__error() = v98;
LABEL_181:
  uint64_t v111 = v148;
  double v112 = a8 - a7;
  int v113 = a1;
  id v114 = v42;
  uint64_t v115 = v145;
  uint64_t v116 = v43;
  double v117 = a8;
  uint64_t v118 = (uint64_t)a5;
LABEL_182:
  sub_10002F370(v113, v114, v115, v116, v111, v118, v112, v117);
}

void sub_100043620(uint64_t a1)
{
  uint64_t v2 = sub_1000415CC(*(unsigned int *)(a1 + 120), *(void **)(a1 + 32), *(void *)(a1 + 56), *(void **)(a1 + 40), *(void *)(a1 + 64), *(void *)(a1 + 88), *(double *)(a1 + 72), *(double *)(a1 + 80), *(double *)(a1 + 96));
  sub_10002F370(*(_DWORD *)(a1 + 120), *(void **)(a1 + 32), *(void *)(a1 + 104), v2, *(void *)(a1 + 112) | v3, *(void *)(a1 + 64), *(double *)(a1 + 80) - *(double *)(a1 + 72), *(double *)(a1 + 80));
  int v4 = *(void **)(a1 + 48);
}

void sub_100043698(uint64_t a1, id a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, mach_port_name_t a7)
{
  mach_port_name_t v7 = a7;
  uint64_t v96 = a4;
  unsigned int v98 = a7 - 1;
  if (a7 - 1 > 0xFFFFFFFD)
  {
    if ((a1 & 0x80000000) != 0)
    {
      if (byte_1000EBCF8)
      {
        int v36 = *__error();
        malloc_type_id_t v37 = sub_10002E548();
        if (os_log_type_enabled(v37, OS_LOG_TYPE_INFO))
        {
          *(_DWORD *)buf = 134218240;
          CFStringRef v104 = (_DWORD *)a5;
          __int16 v105 = 2048;
          *(void *)qos_class_t v106 = a3;
          _os_log_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_INFO, "file descriptor exhaustion: %llu fds with flags %#llx", buf, 0x16u);
        }
        *__error() = v36;
      }
      if (byte_1000EBCF9) {
        BOOL v38 = dword_1000EB4A8 <= 1;
      }
      else {
        BOOL v38 = 0;
      }
      if (v38)
      {
        int v16 = *__error();
        CFStringRef v39 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"file descriptor exhaustion: %llu fds with flags %#llx", a5, a3);
        if (v39)
        {
          CFStringRef v40 = v39;
          id v41 = a2;
          uint64_t v42 = a5;
          uint64_t v43 = a6;
          mach_port_name_t v44 = v7;
          CStringPtr = CFStringGetCStringPtr(v39, 0x8000100u);
          if (CStringPtr)
          {
            int v46 = (char *)CStringPtr;
            CFStringRef v47 = 0;
          }
          else
          {
            int v46 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xC4C3C77BuLL);
            CFStringGetCString(v40, v46, 1024, 0x8000100u);
            CFStringRef v47 = v46;
          }
          if (qword_1000EBD00) {
            CFStringRef v55 = (FILE *)qword_1000EBD00;
          }
          else {
            CFStringRef v55 = __stderrp;
          }
          fprintf(v55, "%s\n", v46);
          if (v47) {
            free(v47);
          }
          CFRelease(v40);
          mach_port_name_t v7 = v44;
          a6 = v43;
          a5 = v42;
          a2 = v41;
          goto LABEL_80;
        }
        CFStringRef v54 = sub_10002E548();
        if (os_log_type_enabled(v54, OS_LOG_TYPE_FAULT)) {
          sub_100087664();
        }
        uint64_t v51 = qword_1000EBD00;
        CFStringRef v52 = __stderrp;
        goto LABEL_66;
      }
    }
    else
    {
      if (byte_1000EBCF8)
      {
        int v22 = *__error();
        CFStringRef v23 = sub_10002E548();
        if (os_log_type_enabled(v23, OS_LOG_TYPE_INFO))
        {
          *(_DWORD *)buf = 136446978;
          CFStringRef v104 = sub_10002E4E8(a1);
          __int16 v105 = 1024;
          *(_DWORD *)qos_class_t v106 = a1;
          *(_WORD *)&v106[4] = 2048;
          *(void *)&v106[6] = a5;
          __int16 v107 = 2048;
          uint64_t v108 = a3;
          _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_INFO, "%{public}s [%d]: file descriptor exhaustion: %llu fds with flags %#llx", buf, 0x26u);
        }
        *__error() = v22;
      }
      if (byte_1000EBCF9) {
        BOOL v24 = dword_1000EB4A8 <= 1;
      }
      else {
        BOOL v24 = 0;
      }
      if (v24)
      {
        int v16 = *__error();
        uint64_t v25 = sub_10002E4E8(a1);
        CFStringRef v26 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%s [%d]: file descriptor exhaustion: %llu fds with flags %#llx", v25, a1, a5, a3, v96);
        if (!v26)
        {
          BOOL v19 = sub_10002E548();
          if (os_log_type_enabled(v19, OS_LOG_TYPE_FAULT))
          {
            CFStringRef v48 = sub_10002E4E8(a1);
            *(_DWORD *)buf = 136315906;
            CFStringRef v104 = v48;
            __int16 v105 = 1024;
            *(_DWORD *)qos_class_t v106 = a1;
            *(_WORD *)&v106[4] = 2048;
            *(void *)&v106[6] = a5;
            __int16 v107 = 2048;
            uint64_t v108 = a3;
            uint64_t v21 = "Unable to format: %s [%d]: file descriptor exhaustion: %llu fds with flags %#llx";
            goto LABEL_54;
          }
LABEL_65:
          uint64_t v51 = qword_1000EBD00;
          CFStringRef v52 = __stderrp;
LABEL_66:
          if (v51) {
            uint64_t v53 = (FILE *)v51;
          }
          else {
            uint64_t v53 = v52;
          }
          fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v53);
LABEL_80:
          *__error() = v16;
          goto LABEL_81;
        }
        CFStringRef v27 = v26;
        mach_port_name_t v28 = v7;
        CFStringRef v29 = CFStringGetCStringPtr(v26, 0x8000100u);
        if (v29) {
          goto LABEL_39;
        }
        malloc_type_id_t v30 = 3301164923;
        goto LABEL_56;
      }
    }
  }
  else
  {
    if ((a1 & 0x80000000) == 0)
    {
      if (byte_1000EBCF8)
      {
        int v13 = *__error();
        malloc_type_id_t v14 = sub_10002E548();
        if (os_log_type_enabled(v14, OS_LOG_TYPE_INFO))
        {
          *(_DWORD *)buf = 136446978;
          CFStringRef v104 = sub_10002E4E8(a1);
          __int16 v105 = 1024;
          *(_DWORD *)qos_class_t v106 = a1;
          *(_WORD *)&v106[4] = 2048;
          *(void *)&v106[6] = a5;
          __int16 v107 = 2048;
          uint64_t v108 = a3;
          _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_INFO, "%{public}s [%d]: file descriptor exhaustion: fatal, %llu fds with flags %#llx", buf, 0x26u);
        }
        *__error() = v13;
      }
      if (byte_1000EBCF9) {
        BOOL v15 = dword_1000EB4A8 <= 1;
      }
      else {
        BOOL v15 = 0;
      }
      if (!v15) {
        goto LABEL_81;
      }
      int v16 = *__error();
      int v17 = sub_10002E4E8(a1);
      CFStringRef v18 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%s [%d]: file descriptor exhaustion: fatal, %llu fds with flags %#llx", v17, a1, a5, a3, v96);
      if (!v18)
      {
        BOOL v19 = sub_10002E548();
        if (os_log_type_enabled(v19, OS_LOG_TYPE_FAULT))
        {
          int v20 = sub_10002E4E8(a1);
          *(_DWORD *)buf = 136315906;
          CFStringRef v104 = v20;
          __int16 v105 = 1024;
          *(_DWORD *)qos_class_t v106 = a1;
          *(_WORD *)&v106[4] = 2048;
          *(void *)&v106[6] = a5;
          __int16 v107 = 2048;
          uint64_t v108 = a3;
          uint64_t v21 = "Unable to format: %s [%d]: file descriptor exhaustion: fatal, %llu fds with flags %#llx";
LABEL_54:
          _os_log_fault_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_FAULT, v21, buf, 0x26u);
          goto LABEL_65;
        }
        goto LABEL_65;
      }
      goto LABEL_38;
    }
    if (byte_1000EBCF8)
    {
      int v31 = *__error();
      CFStringRef v32 = sub_10002E548();
      if (os_log_type_enabled(v32, OS_LOG_TYPE_INFO))
      {
        *(_DWORD *)buf = 134218240;
        CFStringRef v104 = (_DWORD *)a5;
        __int16 v105 = 2048;
        *(void *)qos_class_t v106 = a3;
        _os_log_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_INFO, "file descriptor exhaustion: fatal, %llu fds with flags %#llx", buf, 0x16u);
      }
      *__error() = v31;
    }
    if (byte_1000EBCF9) {
      BOOL v33 = dword_1000EB4A8 <= 1;
    }
    else {
      BOOL v33 = 0;
    }
    if (v33)
    {
      int v16 = *__error();
      CFStringRef v18 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"file descriptor exhaustion: fatal, %llu fds with flags %#llx", a5, a3);
      if (!v18)
      {
        int v50 = sub_10002E548();
        if (os_log_type_enabled(v50, OS_LOG_TYPE_FAULT)) {
          sub_1000875FC();
        }
        goto LABEL_65;
      }
LABEL_38:
      CFStringRef v27 = v18;
      mach_port_name_t v28 = v7;
      CFStringRef v29 = CFStringGetCStringPtr(v18, 0x8000100u);
      if (v29)
      {
LABEL_39:
        CFStringRef v34 = (char *)v29;
        CFStringRef v35 = 0;
LABEL_57:
        if (qword_1000EBD00) {
          int v49 = (FILE *)qword_1000EBD00;
        }
        else {
          int v49 = __stderrp;
        }
        fprintf(v49, "%s\n", v34);
        if (v35) {
          free(v35);
        }
        CFRelease(v27);
        mach_port_name_t v7 = v28;
        goto LABEL_80;
      }
      malloc_type_id_t v30 = 3088225285;
LABEL_56:
      CFStringRef v34 = (char *)malloc_type_calloc(0x400uLL, 1uLL, v30);
      CFStringGetCString(v27, v34, 1024, 0x8000100u);
      CFStringRef v35 = v34;
      goto LABEL_57;
    }
  }
LABEL_81:
  uint64_t v99 = sub_10002E5C4(a1);
  if (!a2) {
    a2 = sub_10002E60C(a1);
  }
  uint64_t v102 = 0;
  uint64_t v56 = sub_100040988(a1, (uint64_t)"file descriptor exhaustion", 176, &v102);
  uint64_t v57 = v56;
  if ((word_1000EBD38 & 4) != 0)
  {
    if ((a1 & 0x80000000) != 0)
    {
      if (byte_1000EBCF8)
      {
        int v64 = *__error();
        CFStringRef v65 = sub_10002E548();
        if (os_log_type_enabled(v65, OS_LOG_TYPE_DEBUG)) {
          sub_1000875C8();
        }
        *__error() = v64;
      }
      if (!byte_1000EBCF9 || dword_1000EB4A8 > 0) {
        goto LABEL_119;
      }
      int v60 = *__error();
      CFStringRef v62 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"file descriptor exhaustion: not monitoring due to suppression cookie file");
      if (!v62)
      {
        CFStringRef v74 = sub_10002E548();
        if (os_log_type_enabled(v74, OS_LOG_TYPE_FAULT)) {
          sub_100087594();
        }
        goto LABEL_114;
      }
    }
    else
    {
      if (byte_1000EBCF8)
      {
        int v58 = *__error();
        int v59 = sub_10002E548();
        if (os_log_type_enabled(v59, OS_LOG_TYPE_DEBUG)) {
          sub_10008751C();
        }
        *__error() = v58;
      }
      if (!byte_1000EBCF9 || dword_1000EB4A8 > 0) {
        goto LABEL_119;
      }
      int v60 = *__error();
      int v61 = sub_10002E4E8(a1);
      CFStringRef v62 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%s [%d]: file descriptor exhaustion: not monitoring due to suppression cookie file", v61, a1);
      if (!v62)
      {
        int v63 = sub_10002E548();
        if (os_log_type_enabled(v63, OS_LOG_TYPE_FAULT)) {
          sub_1000874A4();
        }
LABEL_114:
        if (qword_1000EBD00) {
          CFStringRef v75 = (FILE *)qword_1000EBD00;
        }
        else {
          CFStringRef v75 = __stderrp;
        }
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v75);
LABEL_118:
        *__error() = v60;
LABEL_119:
        v57 |= 0x8000uLL;
        goto LABEL_120;
      }
    }
    CFStringRef v66 = v62;
    int v97 = v60;
    uint64_t v67 = a5;
    uint64_t v68 = a6;
    mach_port_name_t v69 = v7;
    uint64_t v70 = CFStringGetCStringPtr(v62, 0x8000100u);
    if (v70)
    {
      long long v71 = (char *)v70;
      int v72 = 0;
    }
    else
    {
      long long v71 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xAE71E29uLL);
      CFStringGetCString(v66, v71, 1024, 0x8000100u);
      int v72 = v71;
    }
    if (qword_1000EBD00) {
      task_name_t v73 = (FILE *)qword_1000EBD00;
    }
    else {
      task_name_t v73 = __stderrp;
    }
    fprintf(v73, "%s\n", v71);
    if (v72) {
      free(v72);
    }
    CFRelease(v66);
    mach_port_name_t v7 = v69;
    a6 = v68;
    a5 = v67;
    int v60 = v97;
    goto LABEL_118;
  }
  if (!v56)
  {
    v100[0] = _NSConcreteStackBlock;
    v100[1] = 3221225472;
    v100[2] = sub_1000443E0;
    v100[3] = &unk_1000DD018;
    int v101 = a1;
    v100[4] = a2;
    v100[5] = v99;
    v100[6] = v102;
    v100[7] = a5;
    v100[8] = a6;
    sub_1000525DC(0, a1, (uint64_t)a2, a3, v96, a5, a6, v7, (uint64_t)v100);
    return;
  }
LABEL_120:
  if ((a1 & 0x80000000) != 0)
  {
    if (byte_1000EBCF8)
    {
      int v83 = *__error();
      CFStringRef v84 = sub_10002E548();
      if (os_log_type_enabled(v84, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 134217984;
        CFStringRef v104 = (_DWORD *)v57;
        _os_log_impl((void *)&_mh_execute_header, v84, OS_LOG_TYPE_DEFAULT, "file descriptor exhaustion: not monitoring due to conditions %#llx", buf, 0xCu);
      }
      *__error() = v83;
    }
    if (!byte_1000EBCF9 || dword_1000EB4A8 > 2) {
      goto LABEL_153;
    }
    int v79 = *__error();
    CFStringRef v81 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"file descriptor exhaustion: not monitoring due to conditions %#llx", v57);
    if (!v81)
    {
      __int16 v94 = sub_10002E548();
      if (os_log_type_enabled(v94, OS_LOG_TYPE_FAULT)) {
        sub_10008743C();
      }
      goto LABEL_148;
    }
LABEL_137:
    CFStringRef v85 = v81;
    id v86 = a2;
    uint64_t v87 = a5;
    uint64_t v88 = a6;
    mach_port_name_t v89 = v7;
    unint64_t v90 = CFStringGetCStringPtr(v81, 0x8000100u);
    if (v90)
    {
      CFStringRef v91 = (char *)v90;
      __int16 v92 = 0;
    }
    else
    {
      CFStringRef v91 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x9A45AC0AuLL);
      CFStringGetCString(v85, v91, 1024, 0x8000100u);
      __int16 v92 = v91;
    }
    if (qword_1000EBD00) {
      unsigned int v93 = (FILE *)qword_1000EBD00;
    }
    else {
      unsigned int v93 = __stderrp;
    }
    fprintf(v93, "%s\n", v91);
    if (v92) {
      free(v92);
    }
    CFRelease(v85);
    mach_port_name_t v7 = v89;
    a6 = v88;
    a5 = v87;
    a2 = v86;
    goto LABEL_152;
  }
  if (byte_1000EBCF8)
  {
    int v76 = *__error();
    CFStringRef v77 = sub_10002E548();
    if (os_log_type_enabled(v77, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v78 = sub_10002E4E8(a1);
      *(_DWORD *)buf = 136446722;
      CFStringRef v104 = v78;
      __int16 v105 = 1024;
      *(_DWORD *)qos_class_t v106 = a1;
      *(_WORD *)&v106[4] = 2048;
      *(void *)&v106[6] = v57;
      _os_log_impl((void *)&_mh_execute_header, v77, OS_LOG_TYPE_DEFAULT, "%{public}s [%d]: file descriptor exhaustion: not monitoring due to conditions %#llx", buf, 0x1Cu);
    }
    *__error() = v76;
  }
  if (!byte_1000EBCF9 || dword_1000EB4A8 > 2) {
    goto LABEL_153;
  }
  int v79 = *__error();
  CFStringRef v80 = sub_10002E4E8(a1);
  CFStringRef v81 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%s [%d]: file descriptor exhaustion: not monitoring due to conditions %#llx", v80, a1, v57);
  if (v81) {
    goto LABEL_137;
  }
  int v82 = sub_10002E548();
  if (os_log_type_enabled(v82, OS_LOG_TYPE_FAULT)) {
    sub_1000873BC();
  }
LABEL_148:
  if (qword_1000EBD00) {
    int v95 = (FILE *)qword_1000EBD00;
  }
  else {
    int v95 = __stderrp;
  }
  fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v95);
LABEL_152:
  *__error() = v79;
LABEL_153:
  sub_10002F728(a1, a2, v99, v57, v102, a5, a6);
  if (v98 <= 0xFFFFFFFD) {
    sub_10005427C(0, a1, v7);
  }
}

void sub_1000443E0(uint64_t a1, uint64_t a2)
{
}

void sub_1000443FC(uint64_t a1, id a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, mach_port_name_t a7)
{
  mach_port_name_t v7 = a7;
  uint64_t v96 = a4;
  unsigned int v98 = a7 - 1;
  if (a7 - 1 > 0xFFFFFFFD)
  {
    if ((a1 & 0x80000000) != 0)
    {
      if (byte_1000EBCF8)
      {
        int v36 = *__error();
        malloc_type_id_t v37 = sub_10002E548();
        if (os_log_type_enabled(v37, OS_LOG_TYPE_INFO))
        {
          *(_DWORD *)buf = 134218240;
          CFStringRef v104 = (_DWORD *)a5;
          __int16 v105 = 2048;
          *(void *)qos_class_t v106 = a3;
          _os_log_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_INFO, "port exhaustion: %llu ports with flags %#llx", buf, 0x16u);
        }
        *__error() = v36;
      }
      if (byte_1000EBCF9) {
        BOOL v38 = dword_1000EB4A8 <= 1;
      }
      else {
        BOOL v38 = 0;
      }
      if (v38)
      {
        int v16 = *__error();
        CFStringRef v39 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"port exhaustion: %llu ports with flags %#llx", a5, a3);
        if (v39)
        {
          CFStringRef v40 = v39;
          id v41 = a2;
          uint64_t v42 = a5;
          uint64_t v43 = a6;
          mach_port_name_t v44 = v7;
          CStringPtr = CFStringGetCStringPtr(v39, 0x8000100u);
          if (CStringPtr)
          {
            int v46 = (char *)CStringPtr;
            CFStringRef v47 = 0;
          }
          else
          {
            int v46 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xE108FAADuLL);
            CFStringGetCString(v40, v46, 1024, 0x8000100u);
            CFStringRef v47 = v46;
          }
          if (qword_1000EBD00) {
            CFStringRef v55 = (FILE *)qword_1000EBD00;
          }
          else {
            CFStringRef v55 = __stderrp;
          }
          fprintf(v55, "%s\n", v46);
          if (v47) {
            free(v47);
          }
          CFRelease(v40);
          mach_port_name_t v7 = v44;
          a6 = v43;
          a5 = v42;
          a2 = v41;
          goto LABEL_80;
        }
        CFStringRef v54 = sub_10002E548();
        if (os_log_type_enabled(v54, OS_LOG_TYPE_FAULT)) {
          sub_100087974();
        }
        uint64_t v51 = qword_1000EBD00;
        CFStringRef v52 = __stderrp;
        goto LABEL_66;
      }
    }
    else
    {
      if (byte_1000EBCF8)
      {
        int v22 = *__error();
        CFStringRef v23 = sub_10002E548();
        if (os_log_type_enabled(v23, OS_LOG_TYPE_INFO))
        {
          *(_DWORD *)buf = 136446978;
          CFStringRef v104 = sub_10002E4E8(a1);
          __int16 v105 = 1024;
          *(_DWORD *)qos_class_t v106 = a1;
          *(_WORD *)&v106[4] = 2048;
          *(void *)&v106[6] = a5;
          __int16 v107 = 2048;
          uint64_t v108 = a3;
          _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_INFO, "%{public}s [%d]: port exhaustion: %llu ports with flags %#llx", buf, 0x26u);
        }
        *__error() = v22;
      }
      if (byte_1000EBCF9) {
        BOOL v24 = dword_1000EB4A8 <= 1;
      }
      else {
        BOOL v24 = 0;
      }
      if (v24)
      {
        int v16 = *__error();
        uint64_t v25 = sub_10002E4E8(a1);
        CFStringRef v26 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%s [%d]: port exhaustion: %llu ports with flags %#llx", v25, a1, a5, a3, v96);
        if (!v26)
        {
          BOOL v19 = sub_10002E548();
          if (os_log_type_enabled(v19, OS_LOG_TYPE_FAULT))
          {
            CFStringRef v48 = sub_10002E4E8(a1);
            *(_DWORD *)buf = 136315906;
            CFStringRef v104 = v48;
            __int16 v105 = 1024;
            *(_DWORD *)qos_class_t v106 = a1;
            *(_WORD *)&v106[4] = 2048;
            *(void *)&v106[6] = a5;
            __int16 v107 = 2048;
            uint64_t v108 = a3;
            uint64_t v21 = "Unable to format: %s [%d]: port exhaustion: %llu ports with flags %#llx";
            goto LABEL_54;
          }
LABEL_65:
          uint64_t v51 = qword_1000EBD00;
          CFStringRef v52 = __stderrp;
LABEL_66:
          if (v51) {
            uint64_t v53 = (FILE *)v51;
          }
          else {
            uint64_t v53 = v52;
          }
          fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v53);
LABEL_80:
          *__error() = v16;
          goto LABEL_81;
        }
        CFStringRef v27 = v26;
        mach_port_name_t v28 = v7;
        CFStringRef v29 = CFStringGetCStringPtr(v26, 0x8000100u);
        if (v29) {
          goto LABEL_39;
        }
        malloc_type_id_t v30 = 3775462061;
        goto LABEL_56;
      }
    }
  }
  else
  {
    if ((a1 & 0x80000000) == 0)
    {
      if (byte_1000EBCF8)
      {
        int v13 = *__error();
        malloc_type_id_t v14 = sub_10002E548();
        if (os_log_type_enabled(v14, OS_LOG_TYPE_INFO))
        {
          *(_DWORD *)buf = 136446978;
          CFStringRef v104 = sub_10002E4E8(a1);
          __int16 v105 = 1024;
          *(_DWORD *)qos_class_t v106 = a1;
          *(_WORD *)&v106[4] = 2048;
          *(void *)&v106[6] = a5;
          __int16 v107 = 2048;
          uint64_t v108 = a3;
          _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_INFO, "%{public}s [%d]: port exhaustion: fatal, %llu ports with flags %#llx", buf, 0x26u);
        }
        *__error() = v13;
      }
      if (byte_1000EBCF9) {
        BOOL v15 = dword_1000EB4A8 <= 1;
      }
      else {
        BOOL v15 = 0;
      }
      if (!v15) {
        goto LABEL_81;
      }
      int v16 = *__error();
      int v17 = sub_10002E4E8(a1);
      CFStringRef v18 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%s [%d]: port exhaustion: fatal, %llu ports with flags %#llx", v17, a1, a5, a3, v96);
      if (!v18)
      {
        BOOL v19 = sub_10002E548();
        if (os_log_type_enabled(v19, OS_LOG_TYPE_FAULT))
        {
          int v20 = sub_10002E4E8(a1);
          *(_DWORD *)buf = 136315906;
          CFStringRef v104 = v20;
          __int16 v105 = 1024;
          *(_DWORD *)qos_class_t v106 = a1;
          *(_WORD *)&v106[4] = 2048;
          *(void *)&v106[6] = a5;
          __int16 v107 = 2048;
          uint64_t v108 = a3;
          uint64_t v21 = "Unable to format: %s [%d]: port exhaustion: fatal, %llu ports with flags %#llx";
LABEL_54:
          _os_log_fault_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_FAULT, v21, buf, 0x26u);
          goto LABEL_65;
        }
        goto LABEL_65;
      }
      goto LABEL_38;
    }
    if (byte_1000EBCF8)
    {
      int v31 = *__error();
      CFStringRef v32 = sub_10002E548();
      if (os_log_type_enabled(v32, OS_LOG_TYPE_INFO))
      {
        *(_DWORD *)buf = 134218240;
        CFStringRef v104 = (_DWORD *)a5;
        __int16 v105 = 2048;
        *(void *)qos_class_t v106 = a3;
        _os_log_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_INFO, "port exhaustion: fatal, %llu ports with flags %#llx", buf, 0x16u);
      }
      *__error() = v31;
    }
    if (byte_1000EBCF9) {
      BOOL v33 = dword_1000EB4A8 <= 1;
    }
    else {
      BOOL v33 = 0;
    }
    if (v33)
    {
      int v16 = *__error();
      CFStringRef v18 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"port exhaustion: fatal, %llu ports with flags %#llx", a5, a3);
      if (!v18)
      {
        int v50 = sub_10002E548();
        if (os_log_type_enabled(v50, OS_LOG_TYPE_FAULT)) {
          sub_10008790C();
        }
        goto LABEL_65;
      }
LABEL_38:
      CFStringRef v27 = v18;
      mach_port_name_t v28 = v7;
      CFStringRef v29 = CFStringGetCStringPtr(v18, 0x8000100u);
      if (v29)
      {
LABEL_39:
        CFStringRef v34 = (char *)v29;
        CFStringRef v35 = 0;
LABEL_57:
        if (qword_1000EBD00) {
          int v49 = (FILE *)qword_1000EBD00;
        }
        else {
          int v49 = __stderrp;
        }
        fprintf(v49, "%s\n", v34);
        if (v35) {
          free(v35);
        }
        CFRelease(v27);
        mach_port_name_t v7 = v28;
        goto LABEL_80;
      }
      malloc_type_id_t v30 = 2613214847;
LABEL_56:
      CFStringRef v34 = (char *)malloc_type_calloc(0x400uLL, 1uLL, v30);
      CFStringGetCString(v27, v34, 1024, 0x8000100u);
      CFStringRef v35 = v34;
      goto LABEL_57;
    }
  }
LABEL_81:
  uint64_t v99 = sub_10002E5C4(a1);
  if (!a2) {
    a2 = sub_10002E60C(a1);
  }
  uint64_t v102 = 0;
  uint64_t v56 = sub_100040988(a1, (uint64_t)"port exhaustion", 176, &v102);
  uint64_t v57 = v56;
  if ((word_1000EBD38 & 4) != 0)
  {
    if ((a1 & 0x80000000) != 0)
    {
      if (byte_1000EBCF8)
      {
        int v64 = *__error();
        CFStringRef v65 = sub_10002E548();
        if (os_log_type_enabled(v65, OS_LOG_TYPE_DEBUG)) {
          sub_1000878D8();
        }
        *__error() = v64;
      }
      if (!byte_1000EBCF9 || dword_1000EB4A8 > 0) {
        goto LABEL_119;
      }
      int v60 = *__error();
      CFStringRef v62 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"port exhaustion: not monitoring due to suppression cookie file");
      if (!v62)
      {
        CFStringRef v74 = sub_10002E548();
        if (os_log_type_enabled(v74, OS_LOG_TYPE_FAULT)) {
          sub_1000878A4();
        }
        goto LABEL_114;
      }
    }
    else
    {
      if (byte_1000EBCF8)
      {
        int v58 = *__error();
        int v59 = sub_10002E548();
        if (os_log_type_enabled(v59, OS_LOG_TYPE_DEBUG)) {
          sub_10008782C();
        }
        *__error() = v58;
      }
      if (!byte_1000EBCF9 || dword_1000EB4A8 > 0) {
        goto LABEL_119;
      }
      int v60 = *__error();
      int v61 = sub_10002E4E8(a1);
      CFStringRef v62 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%s [%d]: port exhaustion: not monitoring due to suppression cookie file", v61, a1);
      if (!v62)
      {
        int v63 = sub_10002E548();
        if (os_log_type_enabled(v63, OS_LOG_TYPE_FAULT)) {
          sub_1000877B4();
        }
LABEL_114:
        if (qword_1000EBD00) {
          CFStringRef v75 = (FILE *)qword_1000EBD00;
        }
        else {
          CFStringRef v75 = __stderrp;
        }
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v75);
LABEL_118:
        *__error() = v60;
LABEL_119:
        v57 |= 0x8000uLL;
        goto LABEL_120;
      }
    }
    CFStringRef v66 = v62;
    int v97 = v60;
    uint64_t v67 = a5;
    uint64_t v68 = a6;
    mach_port_name_t v69 = v7;
    uint64_t v70 = CFStringGetCStringPtr(v62, 0x8000100u);
    if (v70)
    {
      long long v71 = (char *)v70;
      int v72 = 0;
    }
    else
    {
      long long v71 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x80B6D712uLL);
      CFStringGetCString(v66, v71, 1024, 0x8000100u);
      int v72 = v71;
    }
    if (qword_1000EBD00) {
      task_name_t v73 = (FILE *)qword_1000EBD00;
    }
    else {
      task_name_t v73 = __stderrp;
    }
    fprintf(v73, "%s\n", v71);
    if (v72) {
      free(v72);
    }
    CFRelease(v66);
    mach_port_name_t v7 = v69;
    a6 = v68;
    a5 = v67;
    int v60 = v97;
    goto LABEL_118;
  }
  if (!v56)
  {
    v100[0] = _NSConcreteStackBlock;
    v100[1] = 3221225472;
    v100[2] = sub_100045144;
    v100[3] = &unk_1000DD018;
    int v101 = a1;
    v100[4] = a2;
    v100[5] = v99;
    v100[6] = v102;
    v100[7] = a5;
    v100[8] = a6;
    sub_1000525DC(1, a1, (uint64_t)a2, a3, v96, a5, a6, v7, (uint64_t)v100);
    return;
  }
LABEL_120:
  if ((a1 & 0x80000000) != 0)
  {
    if (byte_1000EBCF8)
    {
      int v83 = *__error();
      CFStringRef v84 = sub_10002E548();
      if (os_log_type_enabled(v84, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 134217984;
        CFStringRef v104 = (_DWORD *)v57;
        _os_log_impl((void *)&_mh_execute_header, v84, OS_LOG_TYPE_DEFAULT, "port exhaustion: not monitoring due to conditions %#llx", buf, 0xCu);
      }
      *__error() = v83;
    }
    if (!byte_1000EBCF9 || dword_1000EB4A8 > 2) {
      goto LABEL_153;
    }
    int v79 = *__error();
    CFStringRef v81 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"port exhaustion: not monitoring due to conditions %#llx", v57);
    if (!v81)
    {
      __int16 v94 = sub_10002E548();
      if (os_log_type_enabled(v94, OS_LOG_TYPE_FAULT)) {
        sub_10008774C();
      }
      goto LABEL_148;
    }
LABEL_137:
    CFStringRef v85 = v81;
    id v86 = a2;
    uint64_t v87 = a5;
    uint64_t v88 = a6;
    mach_port_name_t v89 = v7;
    unint64_t v90 = CFStringGetCStringPtr(v81, 0x8000100u);
    if (v90)
    {
      CFStringRef v91 = (char *)v90;
      __int16 v92 = 0;
    }
    else
    {
      CFStringRef v91 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x3474168uLL);
      CFStringGetCString(v85, v91, 1024, 0x8000100u);
      __int16 v92 = v91;
    }
    if (qword_1000EBD00) {
      unsigned int v93 = (FILE *)qword_1000EBD00;
    }
    else {
      unsigned int v93 = __stderrp;
    }
    fprintf(v93, "%s\n", v91);
    if (v92) {
      free(v92);
    }
    CFRelease(v85);
    mach_port_name_t v7 = v89;
    a6 = v88;
    a5 = v87;
    a2 = v86;
    goto LABEL_152;
  }
  if (byte_1000EBCF8)
  {
    int v76 = *__error();
    CFStringRef v77 = sub_10002E548();
    if (os_log_type_enabled(v77, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v78 = sub_10002E4E8(a1);
      *(_DWORD *)buf = 136446722;
      CFStringRef v104 = v78;
      __int16 v105 = 1024;
      *(_DWORD *)qos_class_t v106 = a1;
      *(_WORD *)&v106[4] = 2048;
      *(void *)&v106[6] = v57;
      _os_log_impl((void *)&_mh_execute_header, v77, OS_LOG_TYPE_DEFAULT, "%{public}s [%d]: port exhaustion: not monitoring due to conditions %#llx", buf, 0x1Cu);
    }
    *__error() = v76;
  }
  if (!byte_1000EBCF9 || dword_1000EB4A8 > 2) {
    goto LABEL_153;
  }
  int v79 = *__error();
  CFStringRef v80 = sub_10002E4E8(a1);
  CFStringRef v81 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%s [%d]: port exhaustion: not monitoring due to conditions %#llx", v80, a1, v57);
  if (v81) {
    goto LABEL_137;
  }
  int v82 = sub_10002E548();
  if (os_log_type_enabled(v82, OS_LOG_TYPE_FAULT)) {
    sub_1000876CC();
  }
LABEL_148:
  if (qword_1000EBD00) {
    int v95 = (FILE *)qword_1000EBD00;
  }
  else {
    int v95 = __stderrp;
  }
  fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v95);
LABEL_152:
  *__error() = v79;
LABEL_153:
  sub_10002FA54(a1, a2, v99, v57, v102, a5, a6);
  if (v98 <= 0xFFFFFFFD) {
    sub_10005427C(1, a1, v7);
  }
}

void sub_100045144(uint64_t a1, uint64_t a2)
{
}

void sub_100045160(uint64_t a1, id a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, mach_port_name_t a7)
{
  mach_port_name_t v7 = a7;
  uint64_t v96 = a4;
  unsigned int v98 = a7 - 1;
  if (a7 - 1 > 0xFFFFFFFD)
  {
    if ((a1 & 0x80000000) != 0)
    {
      if (byte_1000EBCF8)
      {
        int v36 = *__error();
        malloc_type_id_t v37 = sub_10002E548();
        if (os_log_type_enabled(v37, OS_LOG_TYPE_INFO))
        {
          *(_DWORD *)buf = 134218240;
          CFStringRef v104 = (_DWORD *)a5;
          __int16 v105 = 2048;
          *(void *)qos_class_t v106 = a3;
          _os_log_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_INFO, "kqworkloop exhaustion: %llu kqworkloops with flags %#llx", buf, 0x16u);
        }
        *__error() = v36;
      }
      if (byte_1000EBCF9) {
        BOOL v38 = dword_1000EB4A8 <= 1;
      }
      else {
        BOOL v38 = 0;
      }
      if (v38)
      {
        int v16 = *__error();
        CFStringRef v39 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"kqworkloop exhaustion: %llu kqworkloops with flags %#llx", a5, a3);
        if (v39)
        {
          CFStringRef v40 = v39;
          id v41 = a2;
          uint64_t v42 = a5;
          uint64_t v43 = a6;
          mach_port_name_t v44 = v7;
          CStringPtr = CFStringGetCStringPtr(v39, 0x8000100u);
          if (CStringPtr)
          {
            int v46 = (char *)CStringPtr;
            CFStringRef v47 = 0;
          }
          else
          {
            int v46 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x9EF37C76uLL);
            CFStringGetCString(v40, v46, 1024, 0x8000100u);
            CFStringRef v47 = v46;
          }
          if (qword_1000EBD00) {
            CFStringRef v55 = (FILE *)qword_1000EBD00;
          }
          else {
            CFStringRef v55 = __stderrp;
          }
          fprintf(v55, "%s\n", v46);
          if (v47) {
            free(v47);
          }
          CFRelease(v40);
          mach_port_name_t v7 = v44;
          a6 = v43;
          a5 = v42;
          a2 = v41;
          goto LABEL_80;
        }
        CFStringRef v54 = sub_10002E548();
        if (os_log_type_enabled(v54, OS_LOG_TYPE_FAULT)) {
          sub_100087C84();
        }
        uint64_t v51 = qword_1000EBD00;
        CFStringRef v52 = __stderrp;
        goto LABEL_66;
      }
    }
    else
    {
      if (byte_1000EBCF8)
      {
        int v22 = *__error();
        CFStringRef v23 = sub_10002E548();
        if (os_log_type_enabled(v23, OS_LOG_TYPE_INFO))
        {
          *(_DWORD *)buf = 136446978;
          CFStringRef v104 = sub_10002E4E8(a1);
          __int16 v105 = 1024;
          *(_DWORD *)qos_class_t v106 = a1;
          *(_WORD *)&v106[4] = 2048;
          *(void *)&v106[6] = a5;
          __int16 v107 = 2048;
          uint64_t v108 = a3;
          _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_INFO, "%{public}s [%d]: kqworkloop exhaustion: %llu kqworkloops with flags %#llx", buf, 0x26u);
        }
        *__error() = v22;
      }
      if (byte_1000EBCF9) {
        BOOL v24 = dword_1000EB4A8 <= 1;
      }
      else {
        BOOL v24 = 0;
      }
      if (v24)
      {
        int v16 = *__error();
        uint64_t v25 = sub_10002E4E8(a1);
        CFStringRef v26 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%s [%d]: kqworkloop exhaustion: %llu kqworkloops with flags %#llx", v25, a1, a5, a3, v96);
        if (!v26)
        {
          BOOL v19 = sub_10002E548();
          if (os_log_type_enabled(v19, OS_LOG_TYPE_FAULT))
          {
            CFStringRef v48 = sub_10002E4E8(a1);
            *(_DWORD *)buf = 136315906;
            CFStringRef v104 = v48;
            __int16 v105 = 1024;
            *(_DWORD *)qos_class_t v106 = a1;
            *(_WORD *)&v106[4] = 2048;
            *(void *)&v106[6] = a5;
            __int16 v107 = 2048;
            uint64_t v108 = a3;
            uint64_t v21 = "Unable to format: %s [%d]: kqworkloop exhaustion: %llu kqworkloops with flags %#llx";
            goto LABEL_54;
          }
LABEL_65:
          uint64_t v51 = qword_1000EBD00;
          CFStringRef v52 = __stderrp;
LABEL_66:
          if (v51) {
            uint64_t v53 = (FILE *)v51;
          }
          else {
            uint64_t v53 = v52;
          }
          fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v53);
LABEL_80:
          *__error() = v16;
          goto LABEL_81;
        }
        CFStringRef v27 = v26;
        mach_port_name_t v28 = v7;
        CFStringRef v29 = CFStringGetCStringPtr(v26, 0x8000100u);
        if (v29) {
          goto LABEL_39;
        }
        malloc_type_id_t v30 = 2666757238;
        goto LABEL_56;
      }
    }
  }
  else
  {
    if ((a1 & 0x80000000) == 0)
    {
      if (byte_1000EBCF8)
      {
        int v13 = *__error();
        malloc_type_id_t v14 = sub_10002E548();
        if (os_log_type_enabled(v14, OS_LOG_TYPE_INFO))
        {
          *(_DWORD *)buf = 136446978;
          CFStringRef v104 = sub_10002E4E8(a1);
          __int16 v105 = 1024;
          *(_DWORD *)qos_class_t v106 = a1;
          *(_WORD *)&v106[4] = 2048;
          *(void *)&v106[6] = a5;
          __int16 v107 = 2048;
          uint64_t v108 = a3;
          _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_INFO, "%{public}s [%d]: kqworkloop exhaustion: fatal, %llu kqworkloops with flags %#llx", buf, 0x26u);
        }
        *__error() = v13;
      }
      if (byte_1000EBCF9) {
        BOOL v15 = dword_1000EB4A8 <= 1;
      }
      else {
        BOOL v15 = 0;
      }
      if (!v15) {
        goto LABEL_81;
      }
      int v16 = *__error();
      int v17 = sub_10002E4E8(a1);
      CFStringRef v18 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%s [%d]: kqworkloop exhaustion: fatal, %llu kqworkloops with flags %#llx", v17, a1, a5, a3, v96);
      if (!v18)
      {
        BOOL v19 = sub_10002E548();
        if (os_log_type_enabled(v19, OS_LOG_TYPE_FAULT))
        {
          int v20 = sub_10002E4E8(a1);
          *(_DWORD *)buf = 136315906;
          CFStringRef v104 = v20;
          __int16 v105 = 1024;
          *(_DWORD *)qos_class_t v106 = a1;
          *(_WORD *)&v106[4] = 2048;
          *(void *)&v106[6] = a5;
          __int16 v107 = 2048;
          uint64_t v108 = a3;
          uint64_t v21 = "Unable to format: %s [%d]: kqworkloop exhaustion: fatal, %llu kqworkloops with flags %#llx";
LABEL_54:
          _os_log_fault_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_FAULT, v21, buf, 0x26u);
          goto LABEL_65;
        }
        goto LABEL_65;
      }
      goto LABEL_38;
    }
    if (byte_1000EBCF8)
    {
      int v31 = *__error();
      CFStringRef v32 = sub_10002E548();
      if (os_log_type_enabled(v32, OS_LOG_TYPE_INFO))
      {
        *(_DWORD *)buf = 134218240;
        CFStringRef v104 = (_DWORD *)a5;
        __int16 v105 = 2048;
        *(void *)qos_class_t v106 = a3;
        _os_log_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_INFO, "kqworkloop exhaustion: fatal, %llu kqworkloops with flags %#llx", buf, 0x16u);
      }
      *__error() = v31;
    }
    if (byte_1000EBCF9) {
      BOOL v33 = dword_1000EB4A8 <= 1;
    }
    else {
      BOOL v33 = 0;
    }
    if (v33)
    {
      int v16 = *__error();
      CFStringRef v18 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"kqworkloop exhaustion: fatal, %llu kqworkloops with flags %#llx", a5, a3);
      if (!v18)
      {
        int v50 = sub_10002E548();
        if (os_log_type_enabled(v50, OS_LOG_TYPE_FAULT)) {
          sub_100087C1C();
        }
        goto LABEL_65;
      }
LABEL_38:
      CFStringRef v27 = v18;
      mach_port_name_t v28 = v7;
      CFStringRef v29 = CFStringGetCStringPtr(v18, 0x8000100u);
      if (v29)
      {
LABEL_39:
        CFStringRef v34 = (char *)v29;
        CFStringRef v35 = 0;
LABEL_57:
        if (qword_1000EBD00) {
          int v49 = (FILE *)qword_1000EBD00;
        }
        else {
          int v49 = __stderrp;
        }
        fprintf(v49, "%s\n", v34);
        if (v35) {
          free(v35);
        }
        CFRelease(v27);
        mach_port_name_t v7 = v28;
        goto LABEL_80;
      }
      malloc_type_id_t v30 = 1786011096;
LABEL_56:
      CFStringRef v34 = (char *)malloc_type_calloc(0x400uLL, 1uLL, v30);
      CFStringGetCString(v27, v34, 1024, 0x8000100u);
      CFStringRef v35 = v34;
      goto LABEL_57;
    }
  }
LABEL_81:
  uint64_t v99 = sub_10002E5C4(a1);
  if (!a2) {
    a2 = sub_10002E60C(a1);
  }
  uint64_t v102 = 0;
  uint64_t v56 = sub_100040988(a1, (uint64_t)"kqworkloop exhaustion", 176, &v102);
  uint64_t v57 = v56;
  if ((word_1000EBD38 & 4) != 0)
  {
    if ((a1 & 0x80000000) != 0)
    {
      if (byte_1000EBCF8)
      {
        int v64 = *__error();
        CFStringRef v65 = sub_10002E548();
        if (os_log_type_enabled(v65, OS_LOG_TYPE_DEBUG)) {
          sub_100087BE8();
        }
        *__error() = v64;
      }
      if (!byte_1000EBCF9 || dword_1000EB4A8 > 0) {
        goto LABEL_119;
      }
      int v60 = *__error();
      CFStringRef v62 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"kqworkloop exhaustion: not monitoring due to suppression cookie file");
      if (!v62)
      {
        CFStringRef v74 = sub_10002E548();
        if (os_log_type_enabled(v74, OS_LOG_TYPE_FAULT)) {
          sub_100087BB4();
        }
        goto LABEL_114;
      }
    }
    else
    {
      if (byte_1000EBCF8)
      {
        int v58 = *__error();
        int v59 = sub_10002E548();
        if (os_log_type_enabled(v59, OS_LOG_TYPE_DEBUG)) {
          sub_100087B3C();
        }
        *__error() = v58;
      }
      if (!byte_1000EBCF9 || dword_1000EB4A8 > 0) {
        goto LABEL_119;
      }
      int v60 = *__error();
      int v61 = sub_10002E4E8(a1);
      CFStringRef v62 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%s [%d]: kqworkloop exhaustion: not monitoring due to suppression cookie file", v61, a1);
      if (!v62)
      {
        int v63 = sub_10002E548();
        if (os_log_type_enabled(v63, OS_LOG_TYPE_FAULT)) {
          sub_100087AC4();
        }
LABEL_114:
        if (qword_1000EBD00) {
          CFStringRef v75 = (FILE *)qword_1000EBD00;
        }
        else {
          CFStringRef v75 = __stderrp;
        }
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v75);
LABEL_118:
        *__error() = v60;
LABEL_119:
        v57 |= 0x8000uLL;
        goto LABEL_120;
      }
    }
    CFStringRef v66 = v62;
    int v97 = v60;
    uint64_t v67 = a5;
    uint64_t v68 = a6;
    mach_port_name_t v69 = v7;
    uint64_t v70 = CFStringGetCStringPtr(v62, 0x8000100u);
    if (v70)
    {
      long long v71 = (char *)v70;
      int v72 = 0;
    }
    else
    {
      long long v71 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x1FEA8E90uLL);
      CFStringGetCString(v66, v71, 1024, 0x8000100u);
      int v72 = v71;
    }
    if (qword_1000EBD00) {
      task_name_t v73 = (FILE *)qword_1000EBD00;
    }
    else {
      task_name_t v73 = __stderrp;
    }
    fprintf(v73, "%s\n", v71);
    if (v72) {
      free(v72);
    }
    CFRelease(v66);
    mach_port_name_t v7 = v69;
    a6 = v68;
    a5 = v67;
    int v60 = v97;
    goto LABEL_118;
  }
  if (!v56)
  {
    v100[0] = _NSConcreteStackBlock;
    v100[1] = 3221225472;
    v100[2] = sub_100045EA8;
    v100[3] = &unk_1000DD018;
    int v101 = a1;
    v100[4] = a2;
    v100[5] = v99;
    v100[6] = v102;
    v100[7] = a5;
    v100[8] = a6;
    sub_1000525DC(2, a1, (uint64_t)a2, a3, v96, a5, a6, v7, (uint64_t)v100);
    return;
  }
LABEL_120:
  if ((a1 & 0x80000000) != 0)
  {
    if (byte_1000EBCF8)
    {
      int v83 = *__error();
      CFStringRef v84 = sub_10002E548();
      if (os_log_type_enabled(v84, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 134217984;
        CFStringRef v104 = (_DWORD *)v57;
        _os_log_impl((void *)&_mh_execute_header, v84, OS_LOG_TYPE_DEFAULT, "kqworkloop exhaustion: not monitoring due to conditions %#llx", buf, 0xCu);
      }
      *__error() = v83;
    }
    if (!byte_1000EBCF9 || dword_1000EB4A8 > 2) {
      goto LABEL_153;
    }
    int v79 = *__error();
    CFStringRef v81 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"kqworkloop exhaustion: not monitoring due to conditions %#llx", v57);
    if (!v81)
    {
      __int16 v94 = sub_10002E548();
      if (os_log_type_enabled(v94, OS_LOG_TYPE_FAULT)) {
        sub_100087A5C();
      }
      goto LABEL_148;
    }
LABEL_137:
    CFStringRef v85 = v81;
    id v86 = a2;
    uint64_t v87 = a5;
    uint64_t v88 = a6;
    mach_port_name_t v89 = v7;
    unint64_t v90 = CFStringGetCStringPtr(v81, 0x8000100u);
    if (v90)
    {
      CFStringRef v91 = (char *)v90;
      __int16 v92 = 0;
    }
    else
    {
      CFStringRef v91 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x9911A9C9uLL);
      CFStringGetCString(v85, v91, 1024, 0x8000100u);
      __int16 v92 = v91;
    }
    if (qword_1000EBD00) {
      unsigned int v93 = (FILE *)qword_1000EBD00;
    }
    else {
      unsigned int v93 = __stderrp;
    }
    fprintf(v93, "%s\n", v91);
    if (v92) {
      free(v92);
    }
    CFRelease(v85);
    mach_port_name_t v7 = v89;
    a6 = v88;
    a5 = v87;
    a2 = v86;
    goto LABEL_152;
  }
  if (byte_1000EBCF8)
  {
    int v76 = *__error();
    CFStringRef v77 = sub_10002E548();
    if (os_log_type_enabled(v77, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v78 = sub_10002E4E8(a1);
      *(_DWORD *)buf = 136446722;
      CFStringRef v104 = v78;
      __int16 v105 = 1024;
      *(_DWORD *)qos_class_t v106 = a1;
      *(_WORD *)&v106[4] = 2048;
      *(void *)&v106[6] = v57;
      _os_log_impl((void *)&_mh_execute_header, v77, OS_LOG_TYPE_DEFAULT, "%{public}s [%d]: kqworkloop exhaustion: not monitoring due to conditions %#llx", buf, 0x1Cu);
    }
    *__error() = v76;
  }
  if (!byte_1000EBCF9 || dword_1000EB4A8 > 2) {
    goto LABEL_153;
  }
  int v79 = *__error();
  CFStringRef v80 = sub_10002E4E8(a1);
  CFStringRef v81 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%s [%d]: kqworkloop exhaustion: not monitoring due to conditions %#llx", v80, a1, v57);
  if (v81) {
    goto LABEL_137;
  }
  int v82 = sub_10002E548();
  if (os_log_type_enabled(v82, OS_LOG_TYPE_FAULT)) {
    sub_1000879DC();
  }
LABEL_148:
  if (qword_1000EBD00) {
    int v95 = (FILE *)qword_1000EBD00;
  }
  else {
    int v95 = __stderrp;
  }
  fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v95);
LABEL_152:
  *__error() = v79;
LABEL_153:
  sub_10002FD80(a1, a2, v99, v57, v102, a5, a6);
  if (v98 <= 0xFFFFFFFD) {
    sub_10005427C(2, a1, v7);
  }
}

void sub_100045EA8(uint64_t a1, uint64_t a2)
{
}

void sub_100045EC4(uint64_t a1)
{
  while (waitpid(*(_DWORD *)(a1 + 48), 0, 0) == -1 && *__error() == 4)
    ;
  size_t v2 = 0x4000;
  uint64_t v3 = (char *)malloc_type_malloc(0x4000uLL, 0xBD8B5ECBuLL);
  unint64_t v4 = 0;
  do
  {
    size_t v5 = v4;
    if (v2 - 1 <= v4)
    {
      v2 *= 2;
      uint64_t v3 = (char *)reallocf(v3, v2);
    }
    ssize_t v6 = read(*(_DWORD *)(a1 + 52), &v3[v5], v2 + ~v5);
    unint64_t v4 = v6 + v5;
  }
  while (v6 > 0);
  if (v6 < 0)
  {
    if (byte_1000EBCF8)
    {
      int v7 = *__error();
      int v8 = sub_10002E548();
      if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR)) {
        sub_100087FE4();
      }
      *__error() = v7;
    }
    if (byte_1000EBCF9) {
      BOOL v9 = dword_1000EB4A8 <= 3;
    }
    else {
      BOOL v9 = 0;
    }
    if (v9)
    {
      int v10 = *__error();
      uint64_t v11 = *__error();
      CFStringRef v12 = __error();
      int v13 = strerror(*v12);
      CFStringRef v14 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"read from child returned error: %d (%s)", v11, v13);
      if (v14)
      {
        CFStringRef v15 = v14;
        CStringPtr = CFStringGetCStringPtr(v14, 0x8000100u);
        if (CStringPtr)
        {
          int v17 = (char *)CStringPtr;
          CFStringRef v18 = 0;
        }
        else
        {
          int v17 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x51DC4D27uLL);
          CFStringGetCString(v15, v17, 1024, 0x8000100u);
          CFStringRef v18 = v17;
        }
        if (qword_1000EBD00) {
          uint64_t v21 = (FILE *)qword_1000EBD00;
        }
        else {
          uint64_t v21 = __stderrp;
        }
        fprintf(v21, "%s\n", v17);
        if (v18) {
          free(v18);
        }
        CFRelease(v15);
      }
      else
      {
        BOOL v19 = sub_10002E548();
        if (os_log_type_enabled(v19, OS_LOG_TYPE_FAULT)) {
          sub_100087F5C();
        }
        if (qword_1000EBD00) {
          int v20 = (FILE *)qword_1000EBD00;
        }
        else {
          int v20 = __stderrp;
        }
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v20);
      }
      *__error() = v10;
    }
  }
  close(*(_DWORD *)(a1 + 52));
  v3[v5] = 0;
  int v22 = strnstr(v3, "Spindump analysis written to file ", v5);
  if (!v22)
  {
    int v26 = *__error();
    CFStringRef v27 = sub_10002E548();
    if (os_log_type_enabled(v27, OS_LOG_TYPE_FAULT)) {
      sub_100087D54();
    }
    *__error() = v26;
    if (!byte_1000EBCF9 || dword_1000EB4A8 > 4) {
      goto LABEL_78;
    }
    int v28 = *__error();
    CFStringRef v29 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"Spindump output doesn't contain output path: %s", v3);
    if (!v29)
    {
      id v41 = sub_10002E548();
      if (os_log_type_enabled(v41, OS_LOG_TYPE_FAULT)) {
        sub_100087CEC();
      }
      goto LABEL_65;
    }
    CFStringRef v30 = v29;
    int v31 = CFStringGetCStringPtr(v29, 0x8000100u);
    if (!v31)
    {
      malloc_type_id_t v32 = 822493246;
      goto LABEL_70;
    }
    goto LABEL_58;
  }
  CFStringRef v23 = v22 + 34;
  BOOL v24 = strnstr(v22 + 34, "\n", &v3[v5] - (v22 + 34));
  if (!v24)
  {
    int v33 = *__error();
    CFStringRef v34 = sub_10002E548();
    if (os_log_type_enabled(v34, OS_LOG_TYPE_FAULT)) {
      sub_100087E24();
    }
    *__error() = v33;
    if (!byte_1000EBCF9 || dword_1000EB4A8 > 4) {
      goto LABEL_78;
    }
    int v28 = *__error();
    CFStringRef v35 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"No newline in spindump output: %s", v3);
    if (!v35)
    {
      uint64_t v42 = sub_10002E548();
      if (os_log_type_enabled(v42, OS_LOG_TYPE_FAULT)) {
        sub_100087DBC();
      }
      goto LABEL_65;
    }
    CFStringRef v30 = v35;
    int v31 = CFStringGetCStringPtr(v35, 0x8000100u);
    if (!v31)
    {
      malloc_type_id_t v32 = 3463048555;
      goto LABEL_70;
    }
LABEL_58:
    CFStringRef v39 = (char *)v31;
    CFStringRef v40 = 0;
LABEL_71:
    if (qword_1000EBD00) {
      CFStringRef v45 = (FILE *)qword_1000EBD00;
    }
    else {
      CFStringRef v45 = __stderrp;
    }
    fprintf(v45, "%s\n", v39);
    if (v40) {
      free(v40);
    }
    CFRelease(v30);
LABEL_77:
    *__error() = v28;
LABEL_78:
    uint64_t v25 = *(void (**)(void))(*(void *)(a1 + 40) + 16);
    goto LABEL_79;
  }
  *BOOL v24 = 0;
  if (!sub_10002B86C(v23))
  {
    int v36 = *__error();
    malloc_type_id_t v37 = sub_10002E548();
    if (os_log_type_enabled(v37, OS_LOG_TYPE_FAULT)) {
      sub_100087EF4();
    }
    *__error() = v36;
    if (!byte_1000EBCF9 || dword_1000EB4A8 > 4) {
      goto LABEL_78;
    }
    int v28 = *__error();
    CFStringRef v38 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"Spindump output file doesn't exist: %s", v23);
    if (v38)
    {
      CFStringRef v30 = v38;
      int v31 = CFStringGetCStringPtr(v38, 0x8000100u);
      if (v31) {
        goto LABEL_58;
      }
      malloc_type_id_t v32 = 426082597;
LABEL_70:
      CFStringRef v39 = (char *)malloc_type_calloc(0x400uLL, 1uLL, v32);
      CFStringGetCString(v30, v39, 1024, 0x8000100u);
      CFStringRef v40 = v39;
      goto LABEL_71;
    }
    uint64_t v43 = sub_10002E548();
    if (os_log_type_enabled(v43, OS_LOG_TYPE_FAULT)) {
      sub_100087E8C();
    }
LABEL_65:
    if (qword_1000EBD00) {
      mach_port_name_t v44 = (FILE *)qword_1000EBD00;
    }
    else {
      mach_port_name_t v44 = __stderrp;
    }
    fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v44);
    goto LABEL_77;
  }
  uint64_t v25 = *(void (**)(void))(*(void *)(a1 + 40) + 16);
LABEL_79:
  v25();
  free(v3);
  dispatch_source_cancel(*(dispatch_source_t *)(a1 + 32));
  dispatch_release(*(dispatch_object_t *)(a1 + 32));
}

void sub_1000464F0(id a1)
{
  uint64_t v1 = getenv("SPINDUMP_IGNORE_SUSPENSION");
  if (v1)
  {
    if (strcmp(v1, "0")) {
      byte_1000EBBA8 = 1;
    }
  }
}

void sub_1000465A0(void *a1, uint64_t a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_fault_impl(a1, v9, OS_LOG_TYPE_FAULT, a4, &a9, 0x1Cu);
}

void sub_100046614(void *a1, uint64_t a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_fault_impl(a1, v9, OS_LOG_TYPE_FAULT, a4, &a9, 0x12u);
}

void sub_100046674(void *a1, uint64_t a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_debug_impl(a1, v9, OS_LOG_TYPE_DEBUG, a4, &a9, 0x12u);
}

void sub_100046694(void *a1, uint64_t a2, os_log_t log, const char *a4, ...)
{
  va_start(va, a4);
  _os_log_fault_impl(a1, log, OS_LOG_TYPE_FAULT, a4, (uint8_t *)va, 0x16u);
}

void sub_1000466D8(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_fault_impl(a1, a2, OS_LOG_TYPE_FAULT, a4, &a9, 2u);
}

void sub_100046758(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_debug_impl(a1, a2, OS_LOG_TYPE_DEBUG, a4, &a9, 2u);
}

void sub_100046774(void *a1, uint64_t a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_fault_impl(a1, v9, OS_LOG_TYPE_FAULT, a4, &a9, 0x30u);
}

void sub_100046794(void *a1, uint64_t a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_fault_impl(a1, v9, OS_LOG_TYPE_FAULT, a4, &a9, 0x20u);
}

id sub_10004680C()
{
  return [v0 total];
}

id sub_100046824()
{
  return [v0 bytes_not_microstackshots];
}

id sub_10004683C()
{
  return [v0 total];
}

void sub_100046854(void *a1, uint64_t a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_debug_impl(a1, v9, OS_LOG_TYPE_DEBUG, a4, &a9, 0x1Cu);
}

void sub_100046874(void *a1, uint64_t a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_error_impl(a1, v9, OS_LOG_TYPE_ERROR, a4, &a9, 0x1Cu);
}

id sub_100046894()
{
  return [v0 bytes_not_microstackshots];
}

id sub_1000468AC()
{
  return [v0 total];
}

int *sub_1000468F0()
{
  return __error();
}

void sub_10004690C(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_debug_impl(a1, a2, OS_LOG_TYPE_DEBUG, a4, &a9, 0xCu);
}

_DWORD *sub_100046958(int *a1)
{
  int v2 = *a1;
  return sub_10002E4E8(v2);
}

void sub_100046970(void *a1, uint64_t a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_debug_impl(a1, v9, OS_LOG_TYPE_DEBUG, a4, &a9, 0x30u);
}

void sub_100046990(void *a1, uint64_t a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_debug_impl(a1, v9, OS_LOG_TYPE_DEBUG, a4, &a9, 0x20u);
}

void sub_1000469B0(void *a1, uint64_t a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_error_impl(a1, v9, OS_LOG_TYPE_ERROR, a4, &a9, 0x30u);
}

void sub_1000469D0(void *a1, uint64_t a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_error_impl(a1, v9, OS_LOG_TYPE_ERROR, a4, &a9, 0x20u);
}

void sub_1000469F0(void *a1, uint64_t a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_error_impl(a1, v9, OS_LOG_TYPE_ERROR, a4, &a9, 0x2Cu);
}

void sub_100046A10(void *a1, uint64_t a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_error_impl(a1, v9, OS_LOG_TYPE_ERROR, a4, &a9, 0x18u);
}

void sub_100046A30(void *a1, uint64_t a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_error_impl(a1, v9, OS_LOG_TYPE_ERROR, a4, &a9, 0x12u);
}

void sub_100046A50(void *a1, uint64_t a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_fault_impl(a1, v9, OS_LOG_TYPE_FAULT, a4, &a9, 0x2Cu);
}

void sub_100046A70(void *a1, uint64_t a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_fault_impl(a1, v9, OS_LOG_TYPE_FAULT, a4, &a9, 0x18u);
}

int *sub_100046A9C()
{
  return __error();
}

_DWORD *sub_100046AB4(_DWORD *result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a2)
  {
    int v8 = a2;
    uint64_t result = sub_100022A50((uint64_t)result, a2, a3, a4, a5, a6, a7, a8);
    if (result) {
      result[1] = v8;
    }
  }
  return result;
}

BOOL sub_100046AE8()
{
  if (qword_1000EBBC8 != -1) {
    dispatch_once(&qword_1000EBBC8, &stru_1000DD0A0);
  }
  if (dword_1000EB4AC == -1) {
    return 0;
  }
  uint64_t state64 = 0;
  uint64_t state = notify_get_state(dword_1000EB4AC, &state64);
  if (state)
  {
    uint64_t v1 = state;
    if (byte_1000EBCF8)
    {
      int v2 = *__error();
      uint64_t v3 = sub_10002E548();
      if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR)) {
        sub_100088FC4();
      }
      *__error() = v2;
    }
    if (byte_1000EBCF9) {
      BOOL v4 = dword_1000EB4A8 <= 3;
    }
    else {
      BOOL v4 = 0;
    }
    if (!v4) {
      return 0;
    }
    int v15 = *__error();
    CFStringRef v16 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"Failed to get thermal level: %d", v1);
    if (v16)
    {
      CFStringRef v17 = v16;
      CStringPtr = CFStringGetCStringPtr(v16, 0x8000100u);
      if (CStringPtr)
      {
        BOOL v19 = (char *)CStringPtr;
        int v20 = 0;
      }
      else
      {
        BOOL v19 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x109ABBF4uLL);
        CFStringGetCString(v17, v19, 1024, 0x8000100u);
        int v20 = v19;
      }
      if (qword_1000EBD00) {
        CFStringRef v23 = (FILE *)qword_1000EBD00;
      }
      else {
        CFStringRef v23 = __stderrp;
      }
      fprintf(v23, "%s\n", v19);
      if (v20) {
        free(v20);
      }
      CFRelease(v17);
    }
    else
    {
      uint64_t v21 = sub_10002E548();
      if (os_log_type_enabled(v21, OS_LOG_TYPE_FAULT)) {
        sub_100088F5C();
      }
      if (qword_1000EBD00) {
        int v22 = (FILE *)qword_1000EBD00;
      }
      else {
        int v22 = __stderrp;
      }
      fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v22);
    }
    BOOL v24 = __error();
    BOOL result = 0;
    *BOOL v24 = v15;
  }
  else
  {
    if (byte_1000EBCF8)
    {
      int v6 = *__error();
      int v7 = sub_10002E548();
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG)) {
        sub_100088EE8();
      }
      *__error() = v6;
    }
    if (byte_1000EBCF9) {
      BOOL v8 = dword_1000EB4A8 <= 0;
    }
    else {
      BOOL v8 = 0;
    }
    if (v8)
    {
      int v9 = *__error();
      CFStringRef v10 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"Got thermal level: %lld", state64);
      if (v10)
      {
        CFStringRef v11 = v10;
        CFStringRef v12 = CFStringGetCStringPtr(v10, 0x8000100u);
        if (v12)
        {
          int v13 = (char *)v12;
          CFStringRef v14 = 0;
        }
        else
        {
          int v13 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x4B3E5399uLL);
          CFStringGetCString(v11, v13, 1024, 0x8000100u);
          CFStringRef v14 = v13;
        }
        if (qword_1000EBD00) {
          CFStringRef v27 = (FILE *)qword_1000EBD00;
        }
        else {
          CFStringRef v27 = __stderrp;
        }
        fprintf(v27, "%s\n", v13);
        if (v14) {
          free(v14);
        }
        CFRelease(v11);
      }
      else
      {
        uint64_t v25 = sub_10002E548();
        if (os_log_type_enabled(v25, OS_LOG_TYPE_FAULT)) {
          sub_100088E80();
        }
        if (qword_1000EBD00) {
          int v26 = (FILE *)qword_1000EBD00;
        }
        else {
          int v26 = __stderrp;
        }
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v26);
      }
      *__error() = v9;
    }
    return state64 > 0x1D;
  }
  return result;
}

void sub_100046E98(id a1)
{
  uint64_t v1 = notify_register_check(kOSThermalNotificationPressureLevelName, &dword_1000EB4AC);
  if (v1)
  {
    uint64_t v2 = v1;
    if (byte_1000EBCF8)
    {
      int v3 = *__error();
      BOOL v4 = sub_10002E548();
      if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR)) {
        sub_100089094();
      }
      *__error() = v3;
    }
    if (byte_1000EBCF9) {
      BOOL v5 = dword_1000EB4A8 <= 3;
    }
    else {
      BOOL v5 = 0;
    }
    if (v5)
    {
      int v6 = *__error();
      CFStringRef v7 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"Failed to register for thermal level: %d", v2);
      if (v7)
      {
        CFStringRef v8 = v7;
        CStringPtr = CFStringGetCStringPtr(v7, 0x8000100u);
        if (CStringPtr)
        {
          CFStringRef v10 = (char *)CStringPtr;
          CFStringRef v11 = 0;
        }
        else
        {
          CFStringRef v10 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x236BBEA6uLL);
          CFStringGetCString(v8, v10, 1024, 0x8000100u);
          CFStringRef v11 = v10;
        }
        if (qword_1000EBD00) {
          CFStringRef v14 = (FILE *)qword_1000EBD00;
        }
        else {
          CFStringRef v14 = __stderrp;
        }
        fprintf(v14, "%s\n", v10);
        if (v11) {
          free(v11);
        }
        CFRelease(v8);
      }
      else
      {
        CFStringRef v12 = sub_10002E548();
        if (os_log_type_enabled(v12, OS_LOG_TYPE_FAULT)) {
          sub_10008902C();
        }
        if (qword_1000EBD00) {
          int v13 = (FILE *)qword_1000EBD00;
        }
        else {
          int v13 = __stderrp;
        }
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v13);
      }
      *__error() = v6;
    }
    dword_1000EB4AC = -1;
  }
}

BOOL sub_100047080()
{
  if (qword_1000EBBD0 != -1) {
    dispatch_once(&qword_1000EBBD0, &stru_1000DD0C0);
  }
  if (dword_1000EB4B0 == -1) {
    return 0;
  }
  uint64_t state64 = 0;
  uint64_t state = notify_get_state(dword_1000EB4B0, &state64);
  if (state)
  {
    uint64_t v1 = state;
    if (byte_1000EBCF8)
    {
      int v2 = *__error();
      int v3 = sub_10002E548();
      if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR)) {
        sub_100089240();
      }
      *__error() = v2;
    }
    if (byte_1000EBCF9) {
      BOOL v4 = dword_1000EB4A8 <= 3;
    }
    else {
      BOOL v4 = 0;
    }
    if (!v4) {
      return 0;
    }
    int v15 = *__error();
    CFStringRef v16 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"GM check: Failed to get game mode state: %d", v1);
    if (v16)
    {
      CFStringRef v17 = v16;
      CStringPtr = CFStringGetCStringPtr(v16, 0x8000100u);
      if (CStringPtr)
      {
        BOOL v19 = (char *)CStringPtr;
        int v20 = 0;
      }
      else
      {
        BOOL v19 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xCC4A1843uLL);
        CFStringGetCString(v17, v19, 1024, 0x8000100u);
        int v20 = v19;
      }
      if (qword_1000EBD00) {
        CFStringRef v23 = (FILE *)qword_1000EBD00;
      }
      else {
        CFStringRef v23 = __stderrp;
      }
      fprintf(v23, "%s\n", v19);
      if (v20) {
        free(v20);
      }
      CFRelease(v17);
    }
    else
    {
      uint64_t v21 = sub_10002E548();
      if (os_log_type_enabled(v21, OS_LOG_TYPE_FAULT)) {
        sub_1000891D8();
      }
      if (qword_1000EBD00) {
        int v22 = (FILE *)qword_1000EBD00;
      }
      else {
        int v22 = __stderrp;
      }
      fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v22);
    }
    BOOL v24 = __error();
    BOOL result = 0;
    *BOOL v24 = v15;
  }
  else
  {
    if (byte_1000EBCF8)
    {
      int v6 = *__error();
      CFStringRef v7 = sub_10002E548();
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG)) {
        sub_100089164();
      }
      *__error() = v6;
    }
    if (byte_1000EBCF9) {
      BOOL v8 = dword_1000EB4A8 <= 0;
    }
    else {
      BOOL v8 = 0;
    }
    if (v8)
    {
      int v9 = *__error();
      CFStringRef v10 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"GM check: Got game mode: %lld", state64);
      if (v10)
      {
        CFStringRef v11 = v10;
        CFStringRef v12 = CFStringGetCStringPtr(v10, 0x8000100u);
        if (v12)
        {
          int v13 = (char *)v12;
          CFStringRef v14 = 0;
        }
        else
        {
          int v13 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xCC103072uLL);
          CFStringGetCString(v11, v13, 1024, 0x8000100u);
          CFStringRef v14 = v13;
        }
        if (qword_1000EBD00) {
          CFStringRef v27 = (FILE *)qword_1000EBD00;
        }
        else {
          CFStringRef v27 = __stderrp;
        }
        fprintf(v27, "%s\n", v13);
        if (v14) {
          free(v14);
        }
        CFRelease(v11);
      }
      else
      {
        uint64_t v25 = sub_10002E548();
        if (os_log_type_enabled(v25, OS_LOG_TYPE_FAULT)) {
          sub_1000890FC();
        }
        if (qword_1000EBD00) {
          int v26 = (FILE *)qword_1000EBD00;
        }
        else {
          int v26 = __stderrp;
        }
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v26);
      }
      *__error() = v9;
    }
    return state64 != 0;
  }
  return result;
}

void sub_100047430(id a1)
{
  uint64_t v1 = notify_register_check("com.apple.system.console_mode_changed", &dword_1000EB4B0);
  if (v1)
  {
    uint64_t v2 = v1;
    if (byte_1000EBCF8)
    {
      int v3 = *__error();
      BOOL v4 = sub_10002E548();
      if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR)) {
        sub_100089310();
      }
      *__error() = v3;
    }
    if (byte_1000EBCF9) {
      BOOL v5 = dword_1000EB4A8 <= 3;
    }
    else {
      BOOL v5 = 0;
    }
    if (v5)
    {
      int v6 = *__error();
      CFStringRef v7 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"Failed to register for game mode state: %d", v2);
      if (v7)
      {
        CFStringRef v8 = v7;
        CStringPtr = CFStringGetCStringPtr(v7, 0x8000100u);
        if (CStringPtr)
        {
          CFStringRef v10 = (char *)CStringPtr;
          CFStringRef v11 = 0;
        }
        else
        {
          CFStringRef v10 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x359574B8uLL);
          CFStringGetCString(v8, v10, 1024, 0x8000100u);
          CFStringRef v11 = v10;
        }
        if (qword_1000EBD00) {
          CFStringRef v14 = (FILE *)qword_1000EBD00;
        }
        else {
          CFStringRef v14 = __stderrp;
        }
        fprintf(v14, "%s\n", v10);
        if (v11) {
          free(v11);
        }
        CFRelease(v8);
      }
      else
      {
        CFStringRef v12 = sub_10002E548();
        if (os_log_type_enabled(v12, OS_LOG_TYPE_FAULT)) {
          sub_1000892A8();
        }
        if (qword_1000EBD00) {
          int v13 = (FILE *)qword_1000EBD00;
        }
        else {
          int v13 = __stderrp;
        }
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v13);
      }
      *__error() = v6;
    }
    dword_1000EB4B0 = -1;
  }
}

uint64_t sub_100047614(uint64_t a1, uint64_t a2, double a3)
{
  v21[0] = _NSConcreteStackBlock;
  v21[1] = 3221225472;
  int v22 = sub_100047AFC;
  CFStringRef v23 = &unk_1000DD148;
  uint64_t v24 = a1;
  uint64_t v25 = a2;
  double v26 = a3;
  int v3 = dispatch_queue_attr_make_with_autorelease_frequency(0, DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM);
  BOOL v4 = dispatch_queue_create("Tasking notification", v3);
  dispatch_release(v3);
  int out_token = 0;
  handler[0] = _NSConcreteStackBlock;
  handler[1] = 3221225472;
  handler[2] = sub_1000480C8;
  handler[3] = &unk_1000DD170;
  void handler[4] = v21;
  uint64_t v5 = notify_register_dispatch("com.apple.da.tasking_changed", &out_token, v4, handler);
  if (v5)
  {
    uint64_t v6 = v5;
    if (byte_1000EBCF8)
    {
      int v7 = *__error();
      CFStringRef v8 = sub_10002E548();
      if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR)) {
        sub_1000893E0();
      }
      *__error() = v7;
    }
    if (byte_1000EBCF9 && dword_1000EB4A8 <= 3)
    {
      int v9 = *__error();
      CFStringRef v10 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"Unable to register for tasking update notifications: %d", v6);
      if (v10)
      {
        CFStringRef v11 = v10;
        CStringPtr = CFStringGetCStringPtr(v10, 0x8000100u);
        if (CStringPtr)
        {
          int v13 = (char *)CStringPtr;
          CFStringRef v14 = 0;
        }
        else
        {
          int v13 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xBDEC8572uLL);
          CFStringGetCString(v11, v13, 1024, 0x8000100u);
          CFStringRef v14 = v13;
        }
        if (qword_1000EBD00) {
          CFStringRef v17 = (FILE *)qword_1000EBD00;
        }
        else {
          CFStringRef v17 = __stderrp;
        }
        fprintf(v17, "%s\n", v13);
        if (v14) {
          free(v14);
        }
        CFRelease(v11);
      }
      else
      {
        int v15 = sub_10002E548();
        if (os_log_type_enabled(v15, OS_LOG_TYPE_FAULT)) {
          sub_100089378();
        }
        if (qword_1000EBD00) {
          CFStringRef v16 = (FILE *)qword_1000EBD00;
        }
        else {
          CFStringRef v16 = __stderrp;
        }
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v16);
      }
      *__error() = v9;
    }
  }
  return ((uint64_t (*)(void *))v22)(v21);
}

void sub_1000478C8(id a1)
{
  int has_internal_diagnostics = os_variant_has_internal_diagnostics();
  byte_1000EBBD8 = has_internal_diagnostics;
  if (has_internal_diagnostics)
  {
    if (byte_1000EBCF8)
    {
      int v2 = *__error();
      int v3 = sub_10002E548();
      if (os_log_type_enabled(v3, OS_LOG_TYPE_INFO))
      {
        *(_WORD *)buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_INFO, "apple internal", buf, 2u);
      }
      *__error() = v2;
    }
    if (byte_1000EBCF9) {
      BOOL v4 = dword_1000EB4A8 <= 1;
    }
    else {
      BOOL v4 = 0;
    }
    if (v4)
    {
      int v5 = *__error();
      CFStringRef v6 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"apple internal");
      if (v6)
      {
        CFStringRef v7 = v6;
        CStringPtr = CFStringGetCStringPtr(v6, 0x8000100u);
        if (CStringPtr)
        {
          int v9 = (char *)CStringPtr;
          CFStringRef v10 = 0;
        }
        else
        {
          int v9 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x6C2873C8uLL);
          CFStringGetCString(v7, v9, 1024, 0x8000100u);
          CFStringRef v10 = v9;
        }
        if (qword_1000EBD00) {
          int v20 = (FILE *)qword_1000EBD00;
        }
        else {
          int v20 = __stderrp;
        }
        fprintf(v20, "%s\n", v9);
        if (v10) {
          free(v10);
        }
        CFRelease(v7);
      }
      else
      {
        CFStringRef v11 = sub_10002E548();
        if (os_log_type_enabled(v11, OS_LOG_TYPE_FAULT)) {
          sub_100089448(v11, v12, v13, v14, v15, v16, v17, v18);
        }
        if (qword_1000EBD00) {
          BOOL v19 = (FILE *)qword_1000EBD00;
        }
        else {
          BOOL v19 = __stderrp;
        }
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v19);
      }
      *__error() = v5;
    }
  }
}

void sub_100047AAC(id a1)
{
  byte_1000EBBE8 = sub_10002B86C("/var/db/.suppress_spin_reports");
}

void sub_100047AD4(id a1)
{
  byte_1000EBBF8 = sub_10002B86C("/var/db/.enable_spin_reports");
}

double sub_100047AFC(uint64_t a1)
{
  int v2 = (void *)(a1 + 32);
  uint64_t v3 = OSAGetDATaskingValue();
  if (!v3)
  {
    if (byte_1000EBCF8)
    {
      int v19 = *__error();
      int v20 = sub_10002E548();
      if (os_log_type_enabled(v20, OS_LOG_TYPE_INFO))
      {
        uint64_t v21 = *(void *)(a1 + 32);
        uint64_t v22 = *(void *)(a1 + 48);
        *(_DWORD *)buf = 138543618;
        uint64_t v48 = v21;
        __int16 v49 = 2048;
        uint64_t v50 = v22;
        _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_INFO, "Tasking setting for %{public}@ not available, using default %.1f", buf, 0x16u);
      }
      *__error() = v19;
    }
    if (byte_1000EBCF9) {
      BOOL v23 = dword_1000EB4A8 <= 1;
    }
    else {
      BOOL v23 = 0;
    }
    if (!v23) {
      goto LABEL_77;
    }
    int v24 = *__error();
    CFStringRef v25 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"Tasking setting for %@ not available, using default %.1f", *(void *)(a1 + 32), *(void *)(a1 + 48));
    if (v25)
    {
      CFStringRef v26 = v25;
      CStringPtr = CFStringGetCStringPtr(v25, 0x8000100u);
      if (CStringPtr)
      {
        int v28 = (char *)CStringPtr;
        CFStringRef v29 = 0;
      }
      else
      {
        int v28 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x5A7E4DA9uLL);
        CFStringGetCString(v26, v28, 1024, 0x8000100u);
        CFStringRef v29 = v28;
      }
      if (qword_1000EBD00) {
        uint64_t v43 = (FILE *)qword_1000EBD00;
      }
      else {
        uint64_t v43 = __stderrp;
      }
      fprintf(v43, "%s\n", v28);
      if (v29) {
        free(v29);
      }
      CFStringRef v44 = v26;
      goto LABEL_75;
    }
    CFStringRef v38 = sub_10002E548();
    if (os_log_type_enabled(v38, OS_LOG_TYPE_FAULT)) {
      sub_100089480();
    }
LABEL_49:
    if (qword_1000EBD00) {
      uint64_t v42 = (FILE *)qword_1000EBD00;
    }
    else {
      uint64_t v42 = __stderrp;
    }
    fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v42);
    goto LABEL_76;
  }
  BOOL v4 = (void *)v3;
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) == 0)
  {
    if (byte_1000EBCF8)
    {
      int v30 = *__error();
      int v31 = sub_10002E548();
      if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR)) {
        sub_1000895D8();
      }
      *__error() = v30;
    }
    if (byte_1000EBCF9) {
      BOOL v32 = dword_1000EB4A8 <= 3;
    }
    else {
      BOOL v32 = 0;
    }
    if (!v32) {
      goto LABEL_77;
    }
    int v24 = *__error();
    CFStringRef v33 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"Tasking setting for %@: %@ isn't a number", *v2, v4);
    if (v33)
    {
      CFStringRef v34 = v33;
      CFStringRef v35 = CFStringGetCStringPtr(v33, 0x8000100u);
      if (v35)
      {
        int v36 = (char *)v35;
        malloc_type_id_t v37 = 0;
      }
      else
      {
        int v36 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x26601C8DuLL);
        CFStringGetCString(v34, v36, 1024, 0x8000100u);
        malloc_type_id_t v37 = v36;
      }
      if (qword_1000EBD00) {
        int v46 = (FILE *)qword_1000EBD00;
      }
      else {
        int v46 = __stderrp;
      }
      fprintf(v46, "%s\n", v36);
      if (v37) {
        free(v37);
      }
      CFStringRef v44 = v34;
LABEL_75:
      CFRelease(v44);
LABEL_76:
      *__error() = v24;
LABEL_77:
      double result = *(double *)(a1 + 48);
      **(double **)(a1 + 40) = result;
      return result;
    }
    id v41 = sub_10002E548();
    if (os_log_type_enabled(v41, OS_LOG_TYPE_FAULT)) {
      sub_100089564();
    }
    goto LABEL_49;
  }
  [v4 doubleValue];
  CFStringRef v7 = *(double **)(a1 + 40);
  CFStringRef v6 = (uint64_t **)(a1 + 40);
  *CFStringRef v7 = result;
  if (byte_1000EBCF8)
  {
    int v8 = *__error();
    int v9 = sub_10002E548();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v10 = *v2;
      uint64_t v11 = **v6;
      *(_DWORD *)buf = 138543618;
      uint64_t v48 = v10;
      __int16 v49 = 2048;
      uint64_t v50 = v11;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "Tasking setting for %{public}@: %.1f", buf, 0x16u);
    }
    *__error() = v8;
  }
  if (byte_1000EBCF9) {
    BOOL v12 = dword_1000EB4A8 <= 2;
  }
  else {
    BOOL v12 = 0;
  }
  if (v12)
  {
    int v13 = *__error();
    CFStringRef v14 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"Tasking setting for %@: %.1f", *v2, **v6);
    if (v14)
    {
      CFStringRef v15 = v14;
      uint64_t v16 = CFStringGetCStringPtr(v14, 0x8000100u);
      if (v16)
      {
        uint64_t v17 = (char *)v16;
        uint64_t v18 = 0;
      }
      else
      {
        uint64_t v17 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x547149F3uLL);
        CFStringGetCString(v15, v17, 1024, 0x8000100u);
        uint64_t v18 = v17;
      }
      if (qword_1000EBD00) {
        CFStringRef v45 = (FILE *)qword_1000EBD00;
      }
      else {
        CFStringRef v45 = __stderrp;
      }
      fprintf(v45, "%s\n", v17);
      if (v18) {
        free(v18);
      }
      CFRelease(v15);
    }
    else
    {
      CFStringRef v39 = sub_10002E548();
      if (os_log_type_enabled(v39, OS_LOG_TYPE_FAULT)) {
        sub_1000894F0();
      }
      if (qword_1000EBD00) {
        CFStringRef v40 = (FILE *)qword_1000EBD00;
      }
      else {
        CFStringRef v40 = __stderrp;
      }
      fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v40);
    }
    *__error() = v13;
  }
  return result;
}

uint64_t sub_1000480C8(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

void sub_1000480D8(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_fault_impl(a1, a2, OS_LOG_TYPE_FAULT, a4, &a9, 8u);
}

void sub_100048148(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_error_impl(a1, a2, OS_LOG_TYPE_ERROR, a4, &a9, 8u);
}

void sub_100048184(void *a1, uint64_t a2, os_log_t log, const char *a4, ...)
{
  va_start(va, a4);
  _os_log_fault_impl(a1, log, OS_LOG_TYPE_FAULT, a4, (uint8_t *)va, 0x1Au);
}

void sub_1000481CC(uint64_t a1@<X8>)
{
  *(void *)(v1 - _Block_object_dispose(&STACK[0x378], 8) = a1;
}

void sub_1000481E8(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_fault_impl(a1, a2, OS_LOG_TYPE_FAULT, a4, &a9, 0xEu);
}

double sub_100048230()
{
  return 2.0542726e-289;
}

void sub_100048250(void *a1, uint64_t a2, os_log_t log, const char *a4, ...)
{
  va_start(va, a4);
  _os_log_fault_impl(a1, log, OS_LOG_TYPE_FAULT, a4, (uint8_t *)va, 0x14u);
}

void sub_100048270(void *a1, uint64_t a2, os_log_t log, const char *a4, ...)
{
  va_start(va, a4);
  _os_log_fault_impl(a1, log, OS_LOG_TYPE_FAULT, a4, (uint8_t *)va, 0x20u);
}

void sub_1000482A4(uint64_t a1@<X8>)
{
  *(void *)(v1 - _Block_object_dispose(&STACK[0x378], 8) = a1;
}

uint64_t sub_1000482B8(uint64_t a1)
{
  long long v34 = 0u;
  long long v35 = 0u;
  memset(buffer, 0, sizeof(buffer));
  if (proc_pidinfo(a1, 13, 1uLL, buffer, 64)) {
    return DWORD1(v34);
  }
  if ((a1 & 0x80000000) != 0)
  {
    if (byte_1000EBCF8)
    {
      int v16 = *__error();
      uint64_t v17 = sub_10002E548();
      if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR)) {
        sub_10008984C(v17);
      }
      *__error() = v16;
    }
    if (byte_1000EBCF9) {
      BOOL v18 = dword_1000EB4A8 <= 3;
    }
    else {
      BOOL v18 = 0;
    }
    if (!v18) {
      return 0xFFFFFFFFLL;
    }
    int v6 = *__error();
    uint64_t v19 = *__error();
    int v20 = __error();
    uint64_t v21 = strerror(*v20);
    CFStringRef v22 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"Unable to get uid: %d (%s)", v19, v21);
    if (v22)
    {
      CFStringRef v23 = v22;
      CStringPtr = CFStringGetCStringPtr(v22, 0x8000100u);
      if (CStringPtr)
      {
        CFStringRef v25 = (char *)CStringPtr;
        CFStringRef v26 = 0;
      }
      else
      {
        CFStringRef v25 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x8DD57E13uLL);
        CFStringGetCString(v23, v25, 1024, 0x8000100u);
        CFStringRef v26 = v25;
      }
      if (qword_1000EBD00) {
        BOOL v32 = (FILE *)qword_1000EBD00;
      }
      else {
        BOOL v32 = __stderrp;
      }
      fprintf(v32, "%s\n", v25);
      if (v26) {
        free(v26);
      }
      CFStringRef v29 = v23;
      goto LABEL_50;
    }
    int v30 = sub_10002E548();
    if (os_log_type_enabled(v30, OS_LOG_TYPE_FAULT)) {
      sub_1000897B4(v30);
    }
LABEL_39:
    if (qword_1000EBD00) {
      int v31 = (FILE *)qword_1000EBD00;
    }
    else {
      int v31 = __stderrp;
    }
    fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v31);
    goto LABEL_51;
  }
  if (byte_1000EBCF8)
  {
    int v3 = *__error();
    uint64_t v4 = sub_10002E548();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR)) {
      sub_100089708(a1, v4);
    }
    *__error() = v3;
  }
  if (byte_1000EBCF9) {
    BOOL v5 = dword_1000EB4A8 <= 3;
  }
  else {
    BOOL v5 = 0;
  }
  if (!v5) {
    return 0xFFFFFFFFLL;
  }
  int v6 = *__error();
  CFStringRef v7 = sub_10002E4E8(a1);
  uint64_t v8 = *__error();
  uint64_t v9 = __error();
  uint64_t v10 = strerror(*v9);
  CFStringRef v11 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%s [%d]: Unable to get uid: %d (%s)", v7, a1, v8, v10);
  if (!v11)
  {
    CFStringRef v27 = sub_10002E548();
    if (os_log_type_enabled(v27, OS_LOG_TYPE_FAULT)) {
      sub_10008965C(a1, v27);
    }
    goto LABEL_39;
  }
  CFStringRef v12 = v11;
  int v13 = CFStringGetCStringPtr(v11, 0x8000100u);
  if (v13)
  {
    CFStringRef v14 = (char *)v13;
    CFStringRef v15 = 0;
  }
  else
  {
    CFStringRef v14 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x8DD57E13uLL);
    CFStringGetCString(v12, v14, 1024, 0x8000100u);
    CFStringRef v15 = v14;
  }
  if (qword_1000EBD00) {
    int v28 = (FILE *)qword_1000EBD00;
  }
  else {
    int v28 = __stderrp;
  }
  fprintf(v28, "%s\n", v14);
  if (v15) {
    free(v15);
  }
  CFStringRef v29 = v12;
LABEL_50:
  CFRelease(v29);
LABEL_51:
  *__error() = v6;
  return 0xFFFFFFFFLL;
}

void sub_10004865C(uint64_t a1, xpc_object_t object)
{
  if (xpc_get_type(object) == (xpc_type_t)&_xpc_type_error)
  {
    if (byte_1000EBCF8)
    {
      int v6 = *__error();
      CFStringRef v7 = sub_10002E548();
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG)) {
        sub_100089B48(object);
      }
      *__error() = v6;
    }
    if (byte_1000EBCF9) {
      BOOL v8 = dword_1000EB4A8 <= 0;
    }
    else {
      BOOL v8 = 0;
    }
    if (v8)
    {
      int v9 = *__error();
      string = xpc_dictionary_get_string(object, _xpc_error_key_description);
      CFStringRef v11 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"Got xpc error message in libspindump client connection: %s", string);
      if (v11)
      {
        CFStringRef v12 = v11;
        CStringPtr = CFStringGetCStringPtr(v11, 0x8000100u);
        if (CStringPtr)
        {
          CFStringRef v14 = (char *)CStringPtr;
          CFStringRef v15 = 0;
        }
        else
        {
          CFStringRef v14 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xD22276FFuLL);
          CFStringGetCString(v12, v14, 1024, 0x8000100u);
          CFStringRef v15 = v14;
        }
        if (qword_1000EBD00) {
          BOOL v18 = (FILE *)qword_1000EBD00;
        }
        else {
          BOOL v18 = __stderrp;
        }
        fprintf(v18, "%s\n", v14);
        if (v15) {
          free(v15);
        }
        CFRelease(v12);
      }
      else
      {
        int v16 = sub_10002E548();
        if (os_log_type_enabled(v16, OS_LOG_TYPE_FAULT)) {
          sub_100089AD0(object, _xpc_error_key_description);
        }
        if (qword_1000EBD00) {
          uint64_t v17 = (FILE *)qword_1000EBD00;
        }
        else {
          uint64_t v17 = __stderrp;
        }
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v17);
      }
      *__error() = v9;
    }
  }
  else if (xpc_get_type(object) == (xpc_type_t)&_xpc_type_dictionary)
  {
    unint64_t v4 = *(void *)(a1 + 32);
    int v5 = *(_DWORD *)(a1 + 40);
    sub_1000488A0(v4, v5, object);
  }
}

void sub_1000488A0(unint64_t a1, int a2, xpc_object_t xdict)
{
  int64_t int64 = xpc_dictionary_get_int64(xdict, "message");
  switch(int64)
  {
    case 3:
      int64_t v7 = xpc_dictionary_get_int64(xdict, "pid");
      if (v7)
      {
        uint64_t int64 = xpc_dictionary_get_uint64(xdict, "tid");
        uint64_t v9 = xpc_dictionary_get_uint64(xdict, "flags");
        xpc_object_t value = xpc_dictionary_get_value(xdict, "cpu");
        if (value && (CFStringRef v11 = value, xpc_get_type(value) == (xpc_type_t)&_xpc_type_double))
        {
          double v141 = xpc_double_get_value(v11);
          if (v141 <= 0.0)
          {
            if (byte_1000EBCF8)
            {
              int v166 = *__error();
              id v167 = sub_10002E548();
              if (os_log_type_enabled(v167, OS_LOG_TYPE_ERROR)) {
                sub_10008A670();
              }
              *__error() = v166;
            }
            if (!byte_1000EBCF9 || dword_1000EB4A8 > 3) {
              return;
            }
            int v15 = *__error();
            CFStringRef v168 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"Error reporting CPU resource: bad cpu_used (%f)", *(void *)&v141);
            if (!v168)
            {
              CFStringRef v195 = sub_10002E548();
              if (os_log_type_enabled(v195, OS_LOG_TYPE_FAULT)) {
                sub_10008A604();
              }
              goto LABEL_380;
            }
            CFStringRef v17 = v168;
            CStringPtr = CFStringGetCStringPtr(v168, 0x8000100u);
            if (CStringPtr) {
              goto LABEL_322;
            }
            malloc_type_id_t v19 = 2357158955;
          }
          else
          {
            xpc_object_t v142 = xpc_dictionary_get_value(xdict, "duration");
            if (v142 && (id v143 = v142, xpc_get_type(v142) == (xpc_type_t)&_xpc_type_double))
            {
              double v189 = xpc_double_get_value(v143);
              if (v189 <= 0.0)
              {
                if (byte_1000EBCF8)
                {
                  int v205 = *__error();
                  uint64_t v206 = sub_10002E548();
                  if (os_log_type_enabled(v206, OS_LOG_TYPE_ERROR)) {
                    sub_10008A598();
                  }
                  *__error() = v205;
                }
                if (!byte_1000EBCF9 || dword_1000EB4A8 > 3) {
                  return;
                }
                int v15 = *__error();
                CFStringRef v207 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"Error reporting CPU resource: bad duration (%f)", *(void *)&v189);
                if (!v207)
                {
                  uint64_t v221 = sub_10002E548();
                  if (os_log_type_enabled(v221, OS_LOG_TYPE_FAULT)) {
                    sub_10008A52C();
                  }
                  goto LABEL_380;
                }
                CFStringRef v17 = v207;
                CStringPtr = CFStringGetCStringPtr(v207, 0x8000100u);
                if (CStringPtr) {
                  goto LABEL_322;
                }
                malloc_type_id_t v19 = 1383719025;
              }
              else
              {
                xpc_object_t v190 = xpc_dictionary_get_value(xdict, "endtime");
                if (v190 && (int v191 = v190, xpc_get_type(v190) == (xpc_type_t)&_xpc_type_double))
                {
                  double v215 = xpc_double_get_value(v191);
                  xpc_object_t v216 = xpc_dictionary_get_value(xdict, "cpu_limit");
                  if (v216 && (uint64_t v217 = v216, xpc_get_type(v216) == (xpc_type_t)&_xpc_type_double))
                  {
                    double v226 = xpc_double_get_value(v217);
                    if (v226 >= 0.0)
                    {
                      xpc_object_t v235 = xpc_dictionary_get_value(xdict, "duration_limit");
                      if (v235 && (uint64_t v236 = v235, xpc_get_type(v235) == (xpc_type_t)&_xpc_type_double))
                      {
                        double v282 = xpc_double_get_value(v236);
                        if (v282 >= 0.0)
                        {
                          string = xpc_dictionary_get_string(xdict, "pname");
                          if (string) {
                            id v297 = +[NSString stringWithUTF8String:string];
                          }
                          else {
                            id v297 = 0;
                          }
                          CFStringRef v300 = xpc_dictionary_get_string(xdict, "action");
                          if (v300)
                          {
                            int v301 = sub_10005705C(v300);
                            id v302 = +[NSString stringWithUTF8String:v301];
                            free(v301);
                          }
                          else
                          {
                            id v302 = 0;
                          }
                          sub_1000249E4(v7, v297, uint64, v9, (uint64_t)v302, v141, v189, v215, v226, v282);
                          return;
                        }
                        if (byte_1000EBCF8)
                        {
                          int v283 = *__error();
                          id v284 = sub_10002E548();
                          if (os_log_type_enabled(v284, OS_LOG_TYPE_ERROR)) {
                            sub_10008A4C0();
                          }
                          *__error() = v283;
                        }
                        if (!byte_1000EBCF9 || dword_1000EB4A8 > 3) {
                          return;
                        }
                        int v15 = *__error();
                        CFStringRef v285 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"Error reporting CPU resource: bad duration_limit (%f)", *(void *)&v282);
                        if (!v285)
                        {
                          id v303 = sub_10002E548();
                          if (os_log_type_enabled(v303, OS_LOG_TYPE_FAULT)) {
                            sub_10008A454();
                          }
                          goto LABEL_380;
                        }
                        CFStringRef v17 = v285;
                        CStringPtr = CFStringGetCStringPtr(v285, 0x8000100u);
                        if (CStringPtr) {
                          goto LABEL_322;
                        }
                        malloc_type_id_t v19 = 1515738748;
                      }
                      else
                      {
                        if (byte_1000EBCF8)
                        {
                          int v237 = *__error();
                          int v238 = sub_10002E548();
                          if (os_log_type_enabled(v238, OS_LOG_TYPE_ERROR)) {
                            sub_10008A420();
                          }
                          *__error() = v237;
                        }
                        if (!byte_1000EBCF9 || dword_1000EB4A8 > 3) {
                          return;
                        }
                        int v15 = *__error();
                        CFStringRef v239 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"Error reporting CPU resource: no duration_limit provided");
                        if (!v239)
                        {
                          id v287 = sub_10002E548();
                          if (os_log_type_enabled(v287, OS_LOG_TYPE_FAULT)) {
                            sub_10008A3EC();
                          }
                          goto LABEL_380;
                        }
                        CFStringRef v17 = v239;
                        CStringPtr = CFStringGetCStringPtr(v239, 0x8000100u);
                        if (CStringPtr) {
                          goto LABEL_322;
                        }
                        malloc_type_id_t v19 = 3046861743;
                      }
                    }
                    else
                    {
                      if (byte_1000EBCF8)
                      {
                        int v227 = *__error();
                        int v228 = sub_10002E548();
                        if (os_log_type_enabled(v228, OS_LOG_TYPE_ERROR)) {
                          sub_10008A380();
                        }
                        *__error() = v227;
                      }
                      if (!byte_1000EBCF9 || dword_1000EB4A8 > 3) {
                        return;
                      }
                      int v15 = *__error();
                      CFStringRef v229 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"Error reporting CPU resource: bad cpu_used_limit (%f)", *(void *)&v226);
                      if (!v229)
                      {
                        id v286 = sub_10002E548();
                        if (os_log_type_enabled(v286, OS_LOG_TYPE_FAULT)) {
                          sub_10008A314();
                        }
                        goto LABEL_380;
                      }
                      CFStringRef v17 = v229;
                      CStringPtr = CFStringGetCStringPtr(v229, 0x8000100u);
                      if (CStringPtr) {
                        goto LABEL_322;
                      }
                      malloc_type_id_t v19 = 2882860621;
                    }
                  }
                  else
                  {
                    if (byte_1000EBCF8)
                    {
                      int v218 = *__error();
                      uint64_t v219 = sub_10002E548();
                      if (os_log_type_enabled(v219, OS_LOG_TYPE_ERROR)) {
                        sub_10008A2E0();
                      }
                      *__error() = v218;
                    }
                    if (!byte_1000EBCF9 || dword_1000EB4A8 > 3) {
                      return;
                    }
                    int v15 = *__error();
                    CFStringRef v220 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"Error reporting CPU resource: no cpu_used_limit provided");
                    if (!v220)
                    {
                      id v233 = sub_10002E548();
                      if (os_log_type_enabled(v233, OS_LOG_TYPE_FAULT)) {
                        sub_10008A2AC();
                      }
                      goto LABEL_380;
                    }
                    CFStringRef v17 = v220;
                    CStringPtr = CFStringGetCStringPtr(v220, 0x8000100u);
                    if (CStringPtr) {
                      goto LABEL_322;
                    }
                    malloc_type_id_t v19 = 3759030299;
                  }
                }
                else
                {
                  if (byte_1000EBCF8)
                  {
                    int v192 = *__error();
                    int v193 = sub_10002E548();
                    if (os_log_type_enabled(v193, OS_LOG_TYPE_ERROR)) {
                      sub_10008A278();
                    }
                    *__error() = v192;
                  }
                  if (!byte_1000EBCF9 || dword_1000EB4A8 > 3) {
                    return;
                  }
                  int v15 = *__error();
                  CFStringRef v194 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"Error reporting CPU resource: no endtime provided");
                  if (!v194)
                  {
                    CFStringRef v225 = sub_10002E548();
                    if (os_log_type_enabled(v225, OS_LOG_TYPE_FAULT)) {
                      sub_10008A244();
                    }
                    goto LABEL_380;
                  }
                  CFStringRef v17 = v194;
                  CStringPtr = CFStringGetCStringPtr(v194, 0x8000100u);
                  if (CStringPtr) {
                    goto LABEL_322;
                  }
                  malloc_type_id_t v19 = 55076039;
                }
              }
            }
            else
            {
              if (byte_1000EBCF8)
              {
                int v144 = *__error();
                uint64_t v145 = sub_10002E548();
                if (os_log_type_enabled(v145, OS_LOG_TYPE_ERROR)) {
                  sub_10008A210();
                }
                *__error() = v144;
              }
              if (!byte_1000EBCF9 || dword_1000EB4A8 > 3) {
                return;
              }
              int v15 = *__error();
              CFStringRef v146 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"Error reporting CPU resource: no duration provided");
              if (!v146)
              {
                uint64_t v203 = sub_10002E548();
                if (os_log_type_enabled(v203, OS_LOG_TYPE_FAULT)) {
                  sub_10008A1DC();
                }
                goto LABEL_380;
              }
              CFStringRef v17 = v146;
              CStringPtr = CFStringGetCStringPtr(v146, 0x8000100u);
              if (CStringPtr) {
                goto LABEL_322;
              }
              malloc_type_id_t v19 = 3572982591;
            }
          }
        }
        else
        {
          if (byte_1000EBCF8)
          {
            int v12 = *__error();
            int v13 = sub_10002E548();
            if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR)) {
              sub_10008A1A8();
            }
            *__error() = v12;
          }
          if (byte_1000EBCF9) {
            BOOL v14 = dword_1000EB4A8 <= 3;
          }
          else {
            BOOL v14 = 0;
          }
          if (!v14) {
            return;
          }
          int v15 = *__error();
          CFStringRef v16 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"Error reporting CPU resource: no cpu_used provided");
          if (!v16)
          {
            CFStringRef v165 = sub_10002E548();
            if (os_log_type_enabled(v165, OS_LOG_TYPE_FAULT)) {
              sub_10008A174();
            }
            goto LABEL_380;
          }
          CFStringRef v17 = v16;
          CStringPtr = CFStringGetCStringPtr(v16, 0x8000100u);
          if (CStringPtr) {
            goto LABEL_322;
          }
          malloc_type_id_t v19 = 4240323128;
        }
      }
      else
      {
        if (byte_1000EBCF8)
        {
          int v81 = *__error();
          int v82 = sub_10002E548();
          if (os_log_type_enabled(v82, OS_LOG_TYPE_ERROR)) {
            sub_10008A140();
          }
          *__error() = v81;
        }
        if (byte_1000EBCF9) {
          BOOL v83 = dword_1000EB4A8 <= 3;
        }
        else {
          BOOL v83 = 0;
        }
        if (!v83) {
          return;
        }
        int v15 = *__error();
        CFStringRef v84 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"Error reporting CPU resource: no pid provided");
        if (!v84)
        {
          int v169 = sub_10002E548();
          if (os_log_type_enabled(v169, OS_LOG_TYPE_FAULT)) {
            sub_10008A10C();
          }
          goto LABEL_380;
        }
        CFStringRef v17 = v84;
        CStringPtr = CFStringGetCStringPtr(v84, 0x8000100u);
        if (CStringPtr) {
          goto LABEL_322;
        }
        malloc_type_id_t v19 = 2818817574;
      }
      goto LABEL_385;
    case 5:
      int64_t v27 = xpc_dictionary_get_int64(xdict, "pid");
      if (v27)
      {
        uint64_t v28 = xpc_dictionary_get_uint64(xdict, "flags");
        int64_t v29 = xpc_dictionary_get_int64(xdict, "io");
        if (v29)
        {
          int v30 = (_DWORD *)v29;
          xpc_object_t v31 = xpc_dictionary_get_value(xdict, "duration");
          if (v31 && (BOOL v32 = v31, xpc_get_type(v31) == (xpc_type_t)&_xpc_type_double))
          {
            double v159 = xpc_double_get_value(v32);
            if (v159 <= 0.0)
            {
              if (byte_1000EBCF8)
              {
                int v178 = *__error();
                id v179 = sub_10002E548();
                if (os_log_type_enabled(v179, OS_LOG_TYPE_ERROR)) {
                  sub_10008AA28();
                }
                *__error() = v178;
              }
              if (!byte_1000EBCF9 || dword_1000EB4A8 > 3) {
                return;
              }
              int v15 = *__error();
              CFStringRef v180 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"Error reporting disk writes resource: bad duration (%f)", *(void *)&v159);
              if (!v180)
              {
                uint64_t v204 = sub_10002E548();
                if (os_log_type_enabled(v204, OS_LOG_TYPE_FAULT)) {
                  sub_10008A9BC();
                }
                goto LABEL_380;
              }
              CFStringRef v17 = v180;
              CStringPtr = CFStringGetCStringPtr(v180, 0x8000100u);
              if (CStringPtr) {
                goto LABEL_322;
              }
              malloc_type_id_t v19 = 3150712307;
            }
            else
            {
              xpc_object_t v160 = xpc_dictionary_get_value(xdict, "endtime");
              if (v160 && (int v161 = v160, xpc_get_type(v160) == (xpc_type_t)&_xpc_type_double))
              {
                double v196 = xpc_double_get_value(v161);
                int64_t v197 = xpc_dictionary_get_int64(xdict, "io_limit");
                xpc_object_t v198 = xpc_dictionary_get_value(xdict, "duration_limit");
                if (v198 && (id v199 = v198, xpc_get_type(v198) == (xpc_type_t)&_xpc_type_double))
                {
                  double v211 = xpc_double_get_value(v199);
                  if (v211 >= 0.0)
                  {
                    int v223 = xpc_dictionary_get_string(xdict, "pname");
                    if (v223) {
                      int v224 = +[NSString stringWithUTF8String:v223];
                    }
                    else {
                      int v224 = 0;
                    }
                    CFStringRef v230 = xpc_dictionary_get_string(xdict, "action");
                    if (v230)
                    {
                      CFStringRef v231 = sub_10005705C(v230);
                      int v232 = +[NSString stringWithUTF8String:v231];
                      free(v231);
                    }
                    else
                    {
                      int v232 = 0;
                    }
                    sub_100042330(v27, v224, v28, (uint64_t)v232, v30, v197, v159, v196, v211);
                    return;
                  }
                  if (byte_1000EBCF8)
                  {
                    int v212 = *__error();
                    int v213 = sub_10002E548();
                    if (os_log_type_enabled(v213, OS_LOG_TYPE_ERROR)) {
                      sub_10008A950();
                    }
                    *__error() = v212;
                  }
                  if (!byte_1000EBCF9 || dword_1000EB4A8 > 3) {
                    return;
                  }
                  int v15 = *__error();
                  CFStringRef v214 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"Error reporting disk writes resource: bad duration_limit (%f)", *(void *)&v211);
                  if (!v214)
                  {
                    id v234 = sub_10002E548();
                    if (os_log_type_enabled(v234, OS_LOG_TYPE_FAULT)) {
                      sub_10008A8E4();
                    }
                    goto LABEL_380;
                  }
                  CFStringRef v17 = v214;
                  CStringPtr = CFStringGetCStringPtr(v214, 0x8000100u);
                  if (CStringPtr) {
                    goto LABEL_322;
                  }
                  malloc_type_id_t v19 = 4107497684;
                }
                else
                {
                  if (byte_1000EBCF8)
                  {
                    int v200 = *__error();
                    CFStringRef v201 = sub_10002E548();
                    if (os_log_type_enabled(v201, OS_LOG_TYPE_ERROR)) {
                      sub_10008A8B0();
                    }
                    *__error() = v200;
                  }
                  if (!byte_1000EBCF9 || dword_1000EB4A8 > 3) {
                    return;
                  }
                  int v15 = *__error();
                  CFStringRef v202 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"Error reporting disk writes resource: no duration_limit provided");
                  if (!v202)
                  {
                    uint64_t v222 = sub_10002E548();
                    if (os_log_type_enabled(v222, OS_LOG_TYPE_FAULT)) {
                      sub_10008A87C();
                    }
                    goto LABEL_380;
                  }
                  CFStringRef v17 = v202;
                  CStringPtr = CFStringGetCStringPtr(v202, 0x8000100u);
                  if (CStringPtr) {
                    goto LABEL_322;
                  }
                  malloc_type_id_t v19 = 3165192007;
                }
              }
              else
              {
                if (byte_1000EBCF8)
                {
                  int v162 = *__error();
                  CFStringRef v163 = sub_10002E548();
                  if (os_log_type_enabled(v163, OS_LOG_TYPE_ERROR)) {
                    sub_10008A848();
                  }
                  *__error() = v162;
                }
                if (!byte_1000EBCF9 || dword_1000EB4A8 > 3) {
                  return;
                }
                int v15 = *__error();
                CFStringRef v164 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"Error reporting disk writes resource: no endtime provided");
                if (!v164)
                {
                  uint64_t v208 = sub_10002E548();
                  if (os_log_type_enabled(v208, OS_LOG_TYPE_FAULT)) {
                    sub_10008A814();
                  }
                  goto LABEL_380;
                }
                CFStringRef v17 = v164;
                CStringPtr = CFStringGetCStringPtr(v164, 0x8000100u);
                if (CStringPtr) {
                  goto LABEL_322;
                }
                malloc_type_id_t v19 = 2065113971;
              }
            }
          }
          else
          {
            if (byte_1000EBCF8)
            {
              int v33 = *__error();
              long long v34 = sub_10002E548();
              if (os_log_type_enabled(v34, OS_LOG_TYPE_ERROR)) {
                sub_10008A7E0();
              }
              *__error() = v33;
            }
            if (byte_1000EBCF9) {
              BOOL v35 = dword_1000EB4A8 <= 3;
            }
            else {
              BOOL v35 = 0;
            }
            if (!v35) {
              return;
            }
            int v15 = *__error();
            CFStringRef v36 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"Error reporting disk writes resource: no duration provided");
            if (!v36)
            {
              CFStringRef v177 = sub_10002E548();
              if (os_log_type_enabled(v177, OS_LOG_TYPE_FAULT)) {
                sub_10008A7AC();
              }
              goto LABEL_380;
            }
            CFStringRef v17 = v36;
            CStringPtr = CFStringGetCStringPtr(v36, 0x8000100u);
            if (CStringPtr) {
              goto LABEL_322;
            }
            malloc_type_id_t v19 = 3858714645;
          }
        }
        else
        {
          if (byte_1000EBCF8)
          {
            int v106 = *__error();
            __int16 v107 = sub_10002E548();
            if (os_log_type_enabled(v107, OS_LOG_TYPE_ERROR)) {
              sub_10008A778();
            }
            *__error() = v106;
          }
          if (byte_1000EBCF9) {
            BOOL v108 = dword_1000EB4A8 <= 3;
          }
          else {
            BOOL v108 = 0;
          }
          if (!v108) {
            return;
          }
          int v15 = *__error();
          CFStringRef v109 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"Error reporting disk writes resource: no num bytes provided");
          if (!v109)
          {
            CFStringRef v183 = sub_10002E548();
            if (os_log_type_enabled(v183, OS_LOG_TYPE_FAULT)) {
              sub_10008A744();
            }
            goto LABEL_380;
          }
          CFStringRef v17 = v109;
          CStringPtr = CFStringGetCStringPtr(v109, 0x8000100u);
          if (CStringPtr) {
            goto LABEL_322;
          }
          malloc_type_id_t v19 = 2654307608;
        }
      }
      else
      {
        if (byte_1000EBCF8)
        {
          int v86 = *__error();
          uint64_t v87 = sub_10002E548();
          if (os_log_type_enabled(v87, OS_LOG_TYPE_ERROR)) {
            sub_10008A710();
          }
          *__error() = v86;
        }
        if (byte_1000EBCF9) {
          BOOL v88 = dword_1000EB4A8 <= 3;
        }
        else {
          BOOL v88 = 0;
        }
        if (!v88) {
          return;
        }
        int v15 = *__error();
        CFStringRef v89 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"Error reporting disk writes resource: no pid provided");
        if (!v89)
        {
          unsigned int v171 = sub_10002E548();
          if (os_log_type_enabled(v171, OS_LOG_TYPE_FAULT)) {
            sub_10008A6DC();
          }
          goto LABEL_380;
        }
        CFStringRef v17 = v89;
        CStringPtr = CFStringGetCStringPtr(v89, 0x8000100u);
        if (CStringPtr) {
          goto LABEL_322;
        }
        malloc_type_id_t v19 = 743219392;
      }
      goto LABEL_385;
    case 9:
      BOOL v37 = xpc_dictionary_get_BOOL(xdict, "callback");
      if (v37)
      {
        xpc_connection_t remote_connection = xpc_dictionary_get_remote_connection(xdict);
        if (remote_connection)
        {
          uint64_t v43 = remote_connection;
          xpc_object_t reply = xpc_dictionary_create_reply(xdict);
          if (reply)
          {
            __int16 v49 = reply;
            if (a2)
            {
LABEL_48:
              unsigned int v304 = v49;
              uint64_t v50 = v43;
              if (xpc_dictionary_get_value(xdict, "pid")) {
                int64_t v51 = xpc_dictionary_get_int64(xdict, "pid");
              }
              else {
                int64_t v51 = 0xFFFFFFFFLL;
              }
              int64_t v122 = xpc_dictionary_get_int64(xdict, "tid");
              xpc_object_t v123 = xpc_dictionary_get_value(xdict, "duration");
              double v124 = 0.0;
              double v125 = 0.0;
              if (v123)
              {
                uint64_t v126 = v123;
                if (xpc_get_type(v123) == (xpc_type_t)&_xpc_type_double) {
                  double v125 = xpc_double_get_value(v126);
                }
              }
              xpc_object_t v127 = xpc_dictionary_get_value(xdict, "interval");
              if (v127)
              {
                unsigned int v128 = v127;
                if (xpc_get_type(v127) == (xpc_type_t)&_xpc_type_double) {
                  double v124 = xpc_double_get_value(v128);
                }
              }
              uint64_t v129 = xpc_dictionary_get_uint64(xdict, "flags");
              uint64_t v130 = xpc_dictionary_get_string(xdict, "reason");
              uint64_t v131 = (char *)xpc_dictionary_get_string(xdict, "signature");
              uint64_t v132 = xpc_dictionary_get_string(xdict, "filename");
              if (v37)
              {
                xpc_retain(v50);
                __int16 v133 = v305;
                v305[0] = _NSConcreteStackBlock;
                v305[1] = 3221225472;
                v305[2] = sub_10004AF9C;
                v305[3] = &unk_1000DD1E0;
                v305[4] = v304;
                v305[5] = v50;
                v305[6] = sub_10002E390("Pending reply for spindump request from [%d] for app [%d] thread %#llx", a1, v51, v122);
              }
              else
              {
                __int16 v133 = 0;
              }
              if (v131) {
                uint64_t v131 = sub_10005705C(v131);
              }
              sub_10003C15C(a1, a2, v51, v122, v129, (uint64_t)v130, v131, v132, v125, v124, (uint64_t)v133);
              free(v131);
              return;
            }
LABEL_67:
            if ((a1 & 0x80000000) != 0)
            {
              if (byte_1000EBCF8)
              {
                int v134 = *__error();
                __int16 v135 = sub_10002E548();
                if (os_log_type_enabled(v135, OS_LOG_TYPE_ERROR)) {
                  sub_10008A0D8();
                }
                *__error() = v134;
              }
              if (byte_1000EBCF9) {
                BOOL v136 = dword_1000EB4A8 <= 3;
              }
              else {
                BOOL v136 = 0;
              }
              if (!v136) {
                goto LABEL_338;
              }
              int v77 = *__error();
              CFStringRef v79 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"Attemping to generate spindump, but not entitled");
              if (!v79)
              {
                id v187 = sub_10002E548();
                if (os_log_type_enabled(v187, OS_LOG_TYPE_FAULT)) {
                  sub_10008A0A4();
                }
                goto LABEL_333;
              }
            }
            else
            {
              if (byte_1000EBCF8)
              {
                int v74 = *__error();
                CFStringRef v75 = sub_10002E548();
                if (os_log_type_enabled(v75, OS_LOG_TYPE_ERROR)) {
                  sub_10008A018(a1, v75);
                }
                *__error() = v74;
              }
              if (byte_1000EBCF9) {
                BOOL v76 = dword_1000EB4A8 <= 3;
              }
              else {
                BOOL v76 = 0;
              }
              if (!v76) {
                goto LABEL_338;
              }
              int v77 = *__error();
              uint64_t v78 = sub_10002E4E8(a1);
              CFStringRef v79 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%s [%d]: Attemping to generate spindump, but not entitled", v78, a1);
              if (!v79)
              {
                CFStringRef v80 = sub_10002E548();
                if (os_log_type_enabled(v80, OS_LOG_TYPE_FAULT)) {
                  sub_100089F8C(a1, v80);
                }
LABEL_333:
                if (qword_1000EBD00) {
                  CFStringRef v188 = (FILE *)qword_1000EBD00;
                }
                else {
                  CFStringRef v188 = __stderrp;
                }
                fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v188);
LABEL_337:
                *__error() = v77;
LABEL_338:
                if (v37)
                {
                  xpc_dictionary_set_int64(v49, "errno", 1);
                  xpc_connection_send_message(v43, v49);
                  xpc_release(v49);
                }
                return;
              }
            }
            CFStringRef v137 = v79;
            id v138 = CFStringGetCStringPtr(v79, 0x8000100u);
            if (v138)
            {
              id v139 = (char *)v138;
              CFStringRef v140 = 0;
            }
            else
            {
              id v139 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xB551BC43uLL);
              CFStringGetCString(v137, v139, 1024, 0x8000100u);
              CFStringRef v140 = v139;
            }
            if (qword_1000EBD00) {
              BOOL v176 = (FILE *)qword_1000EBD00;
            }
            else {
              BOOL v176 = __stderrp;
            }
            fprintf(v176, "%s\n", v139);
            if (v140) {
              free(v140);
            }
            CFRelease(v137);
            goto LABEL_337;
          }
          if (byte_1000EBCF8)
          {
            int v261 = *__error();
            CFStringRef v262 = sub_10002E548();
            if (os_log_type_enabled(v262, OS_LOG_TYPE_ERROR)) {
              sub_100089F14(v262, v263, v264, v265, v266, v267, v268, v269);
            }
            *__error() = v261;
          }
          if (byte_1000EBCF9) {
            BOOL v270 = dword_1000EB4A8 <= 3;
          }
          else {
            BOOL v270 = 0;
          }
          if (v270)
          {
            int v271 = *__error();
            CFStringRef v272 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%s: unable to create reply", "reply");
            if (v272)
            {
              CFStringRef v292 = v272;
              CFStringRef v293 = CFStringGetCStringPtr(v272, 0x8000100u);
              if (v293)
              {
                CFStringRef v294 = (char *)v293;
                id v295 = 0;
              }
              else
              {
                CFStringRef v294 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x7D8A2820uLL);
                CFStringGetCString(v292, v294, 1024, 0x8000100u);
                id v295 = v294;
              }
              if (qword_1000EBD00) {
                CFStringRef v299 = (FILE *)qword_1000EBD00;
              }
              else {
                CFStringRef v299 = __stderrp;
              }
              fprintf(v299, "%s\n", v294);
              if (v295) {
                free(v295);
              }
              CFRelease(v292);
            }
            else
            {
              CFStringRef v273 = sub_10002E548();
              if (os_log_type_enabled(v273, OS_LOG_TYPE_FAULT)) {
                sub_100089E9C(v273, v274, v275, v276, v277, v278, v279, v280);
              }
              if (qword_1000EBD00) {
                id v281 = (FILE *)qword_1000EBD00;
              }
              else {
                id v281 = __stderrp;
              }
              fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v281);
            }
            *__error() = v271;
          }
          sub_10002E41C("SPHandleGenerateSpindump", "reading.m", 257, "%s: unable to create reply", v45, v46, v47, v48, (char)"reply");
        }
        else
        {
          if (byte_1000EBCF8)
          {
            int v240 = *__error();
            CFStringRef v241 = sub_10002E548();
            if (os_log_type_enabled(v241, OS_LOG_TYPE_ERROR)) {
              sub_100089E24(v241, v242, v243, v244, v245, v246, v247, v248);
            }
            *__error() = v240;
          }
          if (byte_1000EBCF9) {
            BOOL v249 = dword_1000EB4A8 <= 3;
          }
          else {
            BOOL v249 = 0;
          }
          if (v249)
          {
            int v250 = *__error();
            CFStringRef v251 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%s: unable to get connection", "connection");
            if (v251)
            {
              CFStringRef v288 = v251;
              CFStringRef v289 = CFStringGetCStringPtr(v251, 0x8000100u);
              if (v289)
              {
                id v290 = (char *)v289;
                id v291 = 0;
              }
              else
              {
                id v290 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x6BAC03FAuLL);
                CFStringGetCString(v288, v290, 1024, 0x8000100u);
                id v291 = v290;
              }
              if (qword_1000EBD00) {
                id v298 = (FILE *)qword_1000EBD00;
              }
              else {
                id v298 = __stderrp;
              }
              fprintf(v298, "%s\n", v290);
              if (v291) {
                free(v291);
              }
              CFRelease(v288);
            }
            else
            {
              CFStringRef v252 = sub_10002E548();
              if (os_log_type_enabled(v252, OS_LOG_TYPE_FAULT)) {
                sub_100089DAC(v252, v253, v254, v255, v256, v257, v258, v259);
              }
              if (qword_1000EBD00) {
                id v260 = (FILE *)qword_1000EBD00;
              }
              else {
                id v260 = __stderrp;
              }
              fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v260);
            }
            *__error() = v250;
          }
          sub_10002E41C("SPHandleGenerateSpindump", "reading.m", 255, "%s: unable to get connection", v39, v40, v41, v42, (char)"connection");
        }
        abort();
      }
      __int16 v49 = 0;
      uint64_t v43 = 0;
      if (a2) {
        goto LABEL_48;
      }
      goto LABEL_67;
    case 11:
      int64_t v52 = xpc_dictionary_get_int64(xdict, "pid");
      if (v52)
      {
        uint64_t v53 = xpc_dictionary_get_uint64(xdict, "flags");
        int64_t v54 = xpc_dictionary_get_int64(xdict, "num_fds");
        if (v54)
        {
          uint64_t v55 = v54;
          int64_t v56 = xpc_dictionary_get_int64(xdict, "num_fds_limit");
          uint64_t v57 = xpc_dictionary_get_string(xdict, "pname");
          if (v57) {
            int v58 = +[NSString stringWithUTF8String:v57];
          }
          else {
            int v58 = 0;
          }
          int v147 = xpc_dictionary_get_string(xdict, "action");
          if (v147)
          {
            uint64_t v148 = sub_10005705C(v147);
            int v149 = +[NSString stringWithUTF8String:v148];
            free(v148);
          }
          else
          {
            int v149 = 0;
          }
          mach_port_name_t v156 = xpc_dictionary_copy_mach_send();
          sub_100043698(v52, v58, v53, (uint64_t)v149, v55, v56, v156);
          return;
        }
        if (byte_1000EBCF8)
        {
          int v110 = *__error();
          uint64_t v111 = sub_10002E548();
          if (os_log_type_enabled(v111, OS_LOG_TYPE_ERROR)) {
            sub_10008AB30();
          }
          *__error() = v110;
        }
        if (byte_1000EBCF9) {
          BOOL v112 = dword_1000EB4A8 <= 3;
        }
        else {
          BOOL v112 = 0;
        }
        if (!v112) {
          return;
        }
        int v15 = *__error();
        CFStringRef v113 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"Error reporting fd exhaustion: no num fds provided");
        if (!v113)
        {
          int v184 = sub_10002E548();
          if (os_log_type_enabled(v184, OS_LOG_TYPE_FAULT)) {
            sub_10008AAFC();
          }
          goto LABEL_380;
        }
        CFStringRef v17 = v113;
        CStringPtr = CFStringGetCStringPtr(v113, 0x8000100u);
        if (CStringPtr) {
          goto LABEL_322;
        }
        malloc_type_id_t v19 = 1745781157;
      }
      else
      {
        if (byte_1000EBCF8)
        {
          int v90 = *__error();
          CFStringRef v91 = sub_10002E548();
          if (os_log_type_enabled(v91, OS_LOG_TYPE_ERROR)) {
            sub_10008AAC8();
          }
          *__error() = v90;
        }
        if (byte_1000EBCF9) {
          BOOL v92 = dword_1000EB4A8 <= 3;
        }
        else {
          BOOL v92 = 0;
        }
        if (!v92) {
          return;
        }
        int v15 = *__error();
        CFStringRef v93 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"Error reporting fd exhaustion: no pid provided");
        if (!v93)
        {
          CFStringRef v172 = sub_10002E548();
          if (os_log_type_enabled(v172, OS_LOG_TYPE_FAULT)) {
            sub_10008AA94();
          }
          goto LABEL_380;
        }
        CFStringRef v17 = v93;
        CStringPtr = CFStringGetCStringPtr(v93, 0x8000100u);
        if (CStringPtr) {
          goto LABEL_322;
        }
        malloc_type_id_t v19 = 3055471800;
      }
      goto LABEL_385;
    case 12:
      int64_t v59 = xpc_dictionary_get_int64(xdict, "pid");
      if (v59)
      {
        uint64_t v60 = xpc_dictionary_get_uint64(xdict, "flags");
        int64_t v61 = xpc_dictionary_get_int64(xdict, "num_ports");
        if (v61)
        {
          uint64_t v62 = v61;
          int64_t v63 = xpc_dictionary_get_int64(xdict, "num_ports_limit");
          int v64 = xpc_dictionary_get_string(xdict, "pname");
          if (v64) {
            CFStringRef v65 = +[NSString stringWithUTF8String:v64];
          }
          else {
            CFStringRef v65 = 0;
          }
          CFStringRef v150 = xpc_dictionary_get_string(xdict, "action");
          if (v150)
          {
            __int16 v151 = sub_10005705C(v150);
            id v152 = +[NSString stringWithUTF8String:v151];
            free(v151);
          }
          else
          {
            id v152 = 0;
          }
          mach_port_name_t v157 = xpc_dictionary_copy_mach_send();
          sub_1000443FC(v59, v65, v60, (uint64_t)v152, v62, v63, v157);
          return;
        }
        if (byte_1000EBCF8)
        {
          int v114 = *__error();
          uint64_t v115 = sub_10002E548();
          if (os_log_type_enabled(v115, OS_LOG_TYPE_ERROR)) {
            sub_10008AC00();
          }
          *__error() = v114;
        }
        if (byte_1000EBCF9) {
          BOOL v116 = dword_1000EB4A8 <= 3;
        }
        else {
          BOOL v116 = 0;
        }
        if (!v116) {
          return;
        }
        int v15 = *__error();
        CFStringRef v117 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"Error reporting port exhaustion: no num ports provided");
        if (!v117)
        {
          id v185 = sub_10002E548();
          if (os_log_type_enabled(v185, OS_LOG_TYPE_FAULT)) {
            sub_10008ABCC();
          }
          goto LABEL_380;
        }
        CFStringRef v17 = v117;
        CStringPtr = CFStringGetCStringPtr(v117, 0x8000100u);
        if (CStringPtr) {
          goto LABEL_322;
        }
        malloc_type_id_t v19 = 193025320;
      }
      else
      {
        if (byte_1000EBCF8)
        {
          int v94 = *__error();
          int v95 = sub_10002E548();
          if (os_log_type_enabled(v95, OS_LOG_TYPE_ERROR)) {
            sub_10008AB98();
          }
          *__error() = v94;
        }
        if (byte_1000EBCF9) {
          BOOL v96 = dword_1000EB4A8 <= 3;
        }
        else {
          BOOL v96 = 0;
        }
        if (!v96) {
          return;
        }
        int v15 = *__error();
        CFStringRef v97 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"Error reporting port exhaustion: no pid provided");
        if (!v97)
        {
          id v173 = sub_10002E548();
          if (os_log_type_enabled(v173, OS_LOG_TYPE_FAULT)) {
            sub_10008AB64();
          }
          goto LABEL_380;
        }
        CFStringRef v17 = v97;
        CStringPtr = CFStringGetCStringPtr(v97, 0x8000100u);
        if (CStringPtr) {
          goto LABEL_322;
        }
        malloc_type_id_t v19 = 1819847248;
      }
      goto LABEL_385;
    case 13:
      CFStringRef v66 = xpc_dictionary_get_string(xdict, "filename");
      if (v66)
      {
        sub_100031520(v66);
        return;
      }
      if (byte_1000EBCF8)
      {
        int v98 = *__error();
        uint64_t v99 = sub_10002E548();
        if (os_log_type_enabled(v99, OS_LOG_TYPE_ERROR)) {
          sub_10008AD38();
        }
        *__error() = v98;
      }
      if (byte_1000EBCF9) {
        BOOL v100 = dword_1000EB4A8 <= 3;
      }
      else {
        BOOL v100 = 0;
      }
      if (!v100) {
        return;
      }
      int v15 = *__error();
      CFStringRef v101 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"Error reporting workflow repsonsiveness delay: no tailspin file provided");
      if (!v101)
      {
        int v174 = sub_10002E548();
        if (os_log_type_enabled(v174, OS_LOG_TYPE_FAULT)) {
          sub_10008AD04();
        }
        goto LABEL_380;
      }
      CFStringRef v17 = v101;
      CStringPtr = CFStringGetCStringPtr(v101, 0x8000100u);
      if (CStringPtr) {
        goto LABEL_322;
      }
      malloc_type_id_t v19 = 2112575672;
      goto LABEL_385;
    case 14:
      int64_t v67 = xpc_dictionary_get_int64(xdict, "pid");
      if (v67)
      {
        uint64_t v68 = xpc_dictionary_get_uint64(xdict, "flags");
        int64_t v69 = xpc_dictionary_get_int64(xdict, "num_kqworkloops");
        if (v69)
        {
          uint64_t v70 = v69;
          int64_t v71 = xpc_dictionary_get_int64(xdict, "num_kqworkloops_limit");
          int v72 = xpc_dictionary_get_string(xdict, "pname");
          if (v72) {
            task_name_t v73 = +[NSString stringWithUTF8String:v72];
          }
          else {
            task_name_t v73 = 0;
          }
          __int16 v153 = xpc_dictionary_get_string(xdict, "action");
          if (v153)
          {
            uint64_t v154 = sub_10005705C(v153);
            int v155 = +[NSString stringWithUTF8String:v154];
            free(v154);
          }
          else
          {
            int v155 = 0;
          }
          mach_port_name_t v158 = xpc_dictionary_copy_mach_send();
          sub_100045160(v67, v73, v68, (uint64_t)v155, v70, v71, v158);
          return;
        }
        if (byte_1000EBCF8)
        {
          int v118 = *__error();
          int v119 = sub_10002E548();
          if (os_log_type_enabled(v119, OS_LOG_TYPE_ERROR)) {
            sub_10008ACD0();
          }
          *__error() = v118;
        }
        if (byte_1000EBCF9) {
          BOOL v120 = dword_1000EB4A8 <= 3;
        }
        else {
          BOOL v120 = 0;
        }
        if (!v120) {
          return;
        }
        int v15 = *__error();
        CFStringRef v121 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"Error reporting kqworkloop exhaustion: no num kqworkloops provided");
        if (!v121)
        {
          int v186 = sub_10002E548();
          if (os_log_type_enabled(v186, OS_LOG_TYPE_FAULT)) {
            sub_10008AC9C();
          }
          goto LABEL_380;
        }
        CFStringRef v17 = v121;
        CStringPtr = CFStringGetCStringPtr(v121, 0x8000100u);
        if (CStringPtr) {
          goto LABEL_322;
        }
        malloc_type_id_t v19 = 4099477833;
      }
      else
      {
        if (byte_1000EBCF8)
        {
          int v102 = *__error();
          id v103 = sub_10002E548();
          if (os_log_type_enabled(v103, OS_LOG_TYPE_ERROR)) {
            sub_10008AC68();
          }
          *__error() = v102;
        }
        if (byte_1000EBCF9) {
          BOOL v104 = dword_1000EB4A8 <= 3;
        }
        else {
          BOOL v104 = 0;
        }
        if (!v104) {
          return;
        }
        int v15 = *__error();
        CFStringRef v105 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"Error reporting kqworkloop exhaustion: no pid provided");
        if (!v105)
        {
          CFStringRef v175 = sub_10002E548();
          if (os_log_type_enabled(v175, OS_LOG_TYPE_FAULT)) {
            sub_10008AC34();
          }
          goto LABEL_380;
        }
        CFStringRef v17 = v105;
        CStringPtr = CFStringGetCStringPtr(v105, 0x8000100u);
        if (CStringPtr) {
          goto LABEL_322;
        }
        malloc_type_id_t v19 = 2322554561;
      }
      goto LABEL_385;
    default:
      int v20 = *__error();
      uint64_t v21 = sub_10002E548();
      BOOL v22 = os_log_type_enabled(v21, OS_LOG_TYPE_FAULT);
      if ((a1 & 0x80000000) == 0)
      {
        if (v22) {
          sub_100089C54(a1);
        }
        *__error() = v20;
        if (byte_1000EBCF9) {
          BOOL v23 = dword_1000EB4A8 <= 4;
        }
        else {
          BOOL v23 = 0;
        }
        if (!v23) {
          return;
        }
        int v15 = *__error();
        int v24 = sub_10002E4E8(a1);
        CFStringRef v25 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%s [%d]: Unknown message to libspindump (%lld)", v24, a1, int64);
        if (!v25)
        {
          CFStringRef v26 = sub_10002E548();
          if (os_log_type_enabled(v26, OS_LOG_TYPE_FAULT)) {
            sub_100089BCC(a1);
          }
LABEL_380:
          if (qword_1000EBD00) {
            uint64_t v209 = (FILE *)qword_1000EBD00;
          }
          else {
            uint64_t v209 = __stderrp;
          }
          fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v209);
LABEL_392:
          *__error() = v15;
          return;
        }
        goto LABEL_100;
      }
      if (v22) {
        sub_100089D44();
      }
      *__error() = v20;
      if (byte_1000EBCF9) {
        BOOL v85 = dword_1000EB4A8 <= 4;
      }
      else {
        BOOL v85 = 0;
      }
      if (v85)
      {
        int v15 = *__error();
        CFStringRef v25 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"Unknown message to libspindump (%lld)", int64);
        if (!v25)
        {
          uint64_t v170 = sub_10002E548();
          if (os_log_type_enabled(v170, OS_LOG_TYPE_FAULT)) {
            sub_100089CDC();
          }
          goto LABEL_380;
        }
LABEL_100:
        CFStringRef v17 = v25;
        CStringPtr = CFStringGetCStringPtr(v25, 0x8000100u);
        if (CStringPtr)
        {
LABEL_322:
          CFStringRef v181 = (char *)CStringPtr;
          CFStringRef v182 = 0;
        }
        else
        {
          malloc_type_id_t v19 = 1447658915;
LABEL_385:
          CFStringRef v181 = (char *)malloc_type_calloc(0x400uLL, 1uLL, v19);
          CFStringGetCString(v17, v181, 1024, 0x8000100u);
          CFStringRef v182 = v181;
        }
        if (qword_1000EBD00) {
          id v210 = (FILE *)qword_1000EBD00;
        }
        else {
          id v210 = __stderrp;
        }
        fprintf(v210, "%s\n", v181);
        if (v182) {
          free(v182);
        }
        CFRelease(v17);
        goto LABEL_392;
      }
      return;
  }
}

void sub_10004AF9C(uint64_t a1, int a2, const char *a3)
{
  xpc_dictionary_set_int64(*(xpc_object_t *)(a1 + 32), "errno", a2);
  if (a3) {
    xpc_dictionary_set_string(*(xpc_object_t *)(a1 + 32), "path", a3);
  }
  xpc_connection_send_message(*(xpc_connection_t *)(a1 + 40), *(xpc_object_t *)(a1 + 32));

  xpc_release(*(xpc_object_t *)(a1 + 32));
  int v5 = *(void **)(a1 + 40);

  xpc_release(v5);
}

void sub_10004B018(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_error_impl(a1, a2, OS_LOG_TYPE_ERROR, a4, &a9, 2u);
}

void sub_10004B040(void *a1, uint64_t a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_fault_impl(a1, v9, OS_LOG_TYPE_FAULT, a4, &a9, 0xCu);
}

void sub_10004B060(void *a1, uint64_t a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_debug_impl(a1, v9, OS_LOG_TYPE_DEBUG, a4, &a9, 0xCu);
}

id sub_10004B080(char *a1, off_t a2, int a3, uint64_t a4, double a5, double a6)
{
  id result = sub_10002905C(a1, a2, a3, 0, a4, 0, 1, 0xFFFFFFFFLL, a5, a6, 0, 0, 0, 0, 0);
  if (result)
  {
    if (byte_1000EBCF8)
    {
      int v11 = *__error();
      int v12 = sub_10002E548();
      if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR)) {
        sub_10008ADE4(v12, v13, v14, v15, v16, v17, v18, v19);
      }
      *__error() = v11;
    }
    if (byte_1000EBCF9) {
      BOOL v20 = dword_1000EB4A8 <= 3;
    }
    else {
      BOOL v20 = 0;
    }
    if (v20)
    {
      int v21 = *__error();
      CFStringRef v22 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%s: _HandleMicrostackshots returned a SASampleStore when saving to a file", "!sampleStore");
      int v37 = v21;
      if (v22)
      {
        CFStringRef theString = v22;
        CStringPtr = CFStringGetCStringPtr(v22, 0x8000100u);
        if (CStringPtr)
        {
          int v33 = (char *)CStringPtr;
          long long v34 = 0;
        }
        else
        {
          int v33 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x322EB21DuLL);
          CFStringGetCString(theString, v33, 1024, 0x8000100u);
          long long v34 = v33;
        }
        if (qword_1000EBD00) {
          BOOL v35 = (FILE *)qword_1000EBD00;
        }
        else {
          BOOL v35 = __stderrp;
        }
        fprintf(v35, "%s\n", v33);
        if (v34) {
          free(v34);
        }
        CFRelease(theString);
      }
      else
      {
        BOOL v23 = sub_10002E548();
        if (os_log_type_enabled(v23, OS_LOG_TYPE_FAULT)) {
          sub_10008AD6C(v23, v24, v25, v26, v27, v28, v29, v30);
        }
        if (qword_1000EBD00) {
          xpc_object_t v31 = (FILE *)qword_1000EBD00;
        }
        else {
          xpc_object_t v31 = __stderrp;
        }
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v31);
      }
      *__error() = v37;
    }
    sub_10002E41C("SaveMicrostackshotsToFile", "microstackshot.m", 88, "%s: _HandleMicrostackshots returned a SASampleStore when saving to a file", v7, v8, v9, v10, (char)"!sampleStore");
    abort();
  }
  return result;
}

uint64_t sub_10004B288(const char *a1, int a2)
{
  if (!a1 || *a1 != 47) {
    return 1;
  }
  for (uint64_t i = 0; i != 6; ++i)
  {
    size_t v5 = strlen((&off_1000DD200)[i]);
    if (!strncmp(a1, (&off_1000DD200)[i], v5)) {
      return 0;
    }
  }
  if (!a2) {
    return 1;
  }
  id v6 = [objc_alloc((Class)NSURL) initFileURLWithFileSystemRepresentation:a1 isDirectory:0 relativeToURL:0];
  if (!v6) {
    return 1;
  }
  uint64_t v7 = v6;
  uint64_t v8 = (__CFBundle *)_CFBundleCreateWithExecutableURLIfLooksLikeBundle();

  if (!v8) {
    return 1;
  }
  Identifier = (__CFString *)CFBundleGetIdentifier(v8);
  BOOL v10 = !Identifier || ([(__CFString *)Identifier hasPrefix:@"com.apple."] & 1) == 0;
  CFRelease(v8);
  return v10;
}

void sub_10004B388(uint64_t a1)
{
  uint64_t v1 = *(void *)(*(void *)(a1 + 64) + 8);
  if (*(_DWORD *)(v1 + 24) == 2)
  {
    if (qword_1000EBC08 != -1)
    {
      dispatch_once(&qword_1000EBC08, &stru_1000DD230);
    }
  }
  else
  {
    *(_DWORD *)(v1 + 24) = 1;
    int v3 = *(void **)(a1 + 32);
    if (v3)
    {
      bytes_ptr = xpc_data_get_bytes_ptr(v3);
      size_t length = xpc_data_get_length(*(xpc_object_t *)(a1 + 32));
      sub_10002AACC(*(void **)(a1 + 40), 0, (uint64_t)bytes_ptr, length, *(unsigned int *)(a1 + 104), *(unsigned int *)(a1 + 108), *(void *)(a1 + 80), *(void *)(a1 + 48), *(double *)(a1 + 88), *(double *)(a1 + 96));
    }
    if (*(unsigned char *)(a1 + 116))
    {
      *(void *)(*(void *)(*(void *)(a1 + 72) + 8) + 24) = *(int *)(a1 + 112);
      id v6 = *(NSObject **)(a1 + 56);
      dispatch_semaphore_signal(v6);
    }
  }
}

void sub_10004B474(id a1)
{
  if (byte_1000EBCF8)
  {
    int v1 = *__error();
    int v2 = sub_10002E548();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEBUG)) {
      sub_10008D570();
    }
    *__error() = v1;
  }
  if (byte_1000EBCF9) {
    BOOL v3 = dword_1000EB4A8 <= 0;
  }
  else {
    BOOL v3 = 0;
  }
  if (v3)
  {
    int v4 = *__error();
    CFStringRef v5 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"Already timed out, not parsing system stats microstackshots");
    if (v5)
    {
      CFStringRef v6 = v5;
      CStringPtr = CFStringGetCStringPtr(v5, 0x8000100u);
      if (CStringPtr)
      {
        uint64_t v8 = (char *)CStringPtr;
        uint64_t v9 = 0;
      }
      else
      {
        uint64_t v8 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x1B58D7CEuLL);
        CFStringGetCString(v6, v8, 1024, 0x8000100u);
        uint64_t v9 = v8;
      }
      if (qword_1000EBD00) {
        int v12 = (FILE *)qword_1000EBD00;
      }
      else {
        int v12 = __stderrp;
      }
      fprintf(v12, "%s\n", v8);
      if (v9) {
        free(v9);
      }
      CFRelease(v6);
    }
    else
    {
      BOOL v10 = sub_10002E548();
      if (os_log_type_enabled(v10, OS_LOG_TYPE_FAULT)) {
        sub_10008D53C();
      }
      if (qword_1000EBD00) {
        int v11 = (FILE *)qword_1000EBD00;
      }
      else {
        int v11 = __stderrp;
      }
      fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v11);
    }
    *__error() = v4;
  }
}

int *sub_10004B624(int *result)
{
  uint64_t v1 = *(void *)(*((void *)result + 4) + 8);
  if (*(_DWORD *)(v1 + 24))
  {
    *(_DWORD *)(v1 + 24) = 0;
    if (byte_1000EBCF8)
    {
      int v2 = *__error();
      BOOL v3 = sub_10002E548();
      if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 67109120;
        int v21 = 30;
        _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Timed out system stats microstackshots after %d seconds, but it's parsing, so waiting a bit longer", buf, 8u);
      }
      id result = __error();
      int *result = v2;
    }
    if (byte_1000EBCF9) {
      BOOL v4 = dword_1000EB4A8 <= 2;
    }
    else {
      BOOL v4 = 0;
    }
    if (!v4) {
      return result;
    }
    int v5 = *__error();
    CFStringRef v6 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"Timed out system stats microstackshots after %d seconds, but it's parsing, so waiting a bit longer", 30);
    if (v6)
    {
      CFStringRef v7 = v6;
      CStringPtr = CFStringGetCStringPtr(v6, 0x8000100u);
      if (!CStringPtr)
      {
        malloc_type_id_t v9 = 1668640244;
LABEL_35:
        uint64_t v14 = (char *)malloc_type_calloc(0x400uLL, 1uLL, v9);
        CFStringGetCString(v7, v14, 1024, 0x8000100u);
        uint64_t v15 = v14;
        goto LABEL_36;
      }
      goto LABEL_25;
    }
    uint64_t v16 = sub_10002E548();
    if (os_log_type_enabled(v16, OS_LOG_TYPE_FAULT)) {
      sub_10008D694();
    }
    goto LABEL_30;
  }
  *(_DWORD *)(v1 + 24) = 2;
  *(unsigned char *)(*(void *)(*((void *)result + 5) + 8) + 24) = 1;
  if (byte_1000EBCF8)
  {
    int v10 = *__error();
    int v11 = sub_10002E548();
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR)) {
      sub_10008D61C();
    }
    id result = __error();
    int *result = v10;
  }
  if (byte_1000EBCF9) {
    BOOL v12 = dword_1000EB4A8 <= 3;
  }
  else {
    BOOL v12 = 0;
  }
  if (v12)
  {
    int v5 = *__error();
    CFStringRef v13 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"Timed out waiting for system stats microstackshots after %d seconds", 30);
    if (v13)
    {
      CFStringRef v7 = v13;
      CStringPtr = CFStringGetCStringPtr(v13, 0x8000100u);
      if (!CStringPtr)
      {
        malloc_type_id_t v9 = 3412819671;
        goto LABEL_35;
      }
LABEL_25:
      uint64_t v14 = (char *)CStringPtr;
      uint64_t v15 = 0;
LABEL_36:
      if (qword_1000EBD00) {
        uint64_t v19 = (FILE *)qword_1000EBD00;
      }
      else {
        uint64_t v19 = __stderrp;
      }
      fprintf(v19, "%s\n", v14);
      if (v15) {
        free(v15);
      }
      CFRelease(v7);
LABEL_42:
      id result = __error();
      int *result = v5;
      return result;
    }
    uint64_t v17 = sub_10002E548();
    if (os_log_type_enabled(v17, OS_LOG_TYPE_FAULT)) {
      sub_10008D5B0();
    }
LABEL_30:
    if (qword_1000EBD00) {
      uint64_t v18 = (FILE *)qword_1000EBD00;
    }
    else {
      uint64_t v18 = __stderrp;
    }
    fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v18);
    goto LABEL_42;
  }
  return result;
}

void sub_10004B9C4(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint8_t *a5)
{
  _os_log_fault_impl(a1, a2, OS_LOG_TYPE_FAULT, a4, a5, 0x12u);
}

void sub_10004B9DC(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint8_t *a5)
{
  _os_log_error_impl(a1, a2, OS_LOG_TYPE_ERROR, a4, a5, 0x12u);
}

int *sub_10004BA14()
{
  return __error();
}

uint64_t sub_10004BA64(uint64_t result, uint64_t a2, int a3, float a4)
{
  *(float *)a2 = a4;
  *(_DWORD *)(a2 + 4) = a3;
  *(_WORD *)(a2 + _Block_object_dispose(&STACK[0x378], 8) = 2080;
  *(void *)(a2 + 10) = result;
  return result;
}

void sub_10004BA8C(void *a1, uint64_t a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_error_impl(a1, v9, OS_LOG_TYPE_ERROR, a4, &a9, 0x22u);
}

void sub_10004BAAC(void *a1, uint64_t a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_error_impl(a1, v9, OS_LOG_TYPE_ERROR, a4, &a9, 0x16u);
}

void sub_10004BACC(void *a1, uint64_t a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_error_impl(a1, v9, OS_LOG_TYPE_ERROR, a4, &a9, 0x26u);
}

void sub_10004BAEC(void *a1, uint64_t a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_fault_impl(a1, v9, OS_LOG_TYPE_FAULT, a4, &a9, 0x22u);
}

void sub_10004BB0C(void *a1, uint64_t a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_fault_impl(a1, v9, OS_LOG_TYPE_FAULT, a4, &a9, 0x16u);
}

void sub_10004BB2C(void *a1, uint64_t a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_fault_impl(a1, v9, OS_LOG_TYPE_FAULT, a4, &a9, 0x26u);
}

id sub_10004BB60(int a1, unsigned char *a2, int a3)
{
  if (a2 && *a2 == 47)
  {
    id v4 = objc_alloc((Class)NSString);
    return [v4 initWithUTF8String:a2];
  }
  else if (a3 && proc_pidpath(a1, buffer, 0x400u) > 0)
  {
    return [objc_alloc((Class)NSString) initWithUTF8String:buffer];
  }
  else
  {
    return 0;
  }
}

uint64_t sub_10004BC40(void *a1, long double a2, double a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  int v14 = a10;
  int v15 = a8;
  int v16 = a7;
  if (byte_1000EBCF8)
  {
    int v19 = *__error();
    BOOL v20 = sub_10002E548();
    if (os_log_type_enabled(v20, OS_LOG_TYPE_DEBUG)) {
      sub_10008DCE4(a6, v16, v20);
    }
    *__error() = v19;
  }
  if (byte_1000EBCF9) {
    BOOL v21 = dword_1000EB4A8 <= 0;
  }
  else {
    BOOL v21 = 0;
  }
  if (v21)
  {
    int v22 = *__error();
    BOOL v23 = sub_1000249A0(a6, v16);
    CFStringRef v24 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"Saving %s report", v23);
    if (v24)
    {
      CFStringRef v25 = v24;
      CStringPtr = CFStringGetCStringPtr(v24, 0x8000100u);
      if (CStringPtr)
      {
        uint64_t v27 = (char *)CStringPtr;
        uint64_t v28 = 0;
      }
      else
      {
        uint64_t v27 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xC56AE213uLL);
        CFStringGetCString(v25, v27, 1024, 0x8000100u);
        uint64_t v28 = v27;
      }
      if (qword_1000EBD00) {
        xpc_object_t v31 = (FILE *)qword_1000EBD00;
      }
      else {
        xpc_object_t v31 = __stderrp;
      }
      fprintf(v31, "%s\n", v27);
      if (v28) {
        free(v28);
      }
      CFRelease(v25);
    }
    else
    {
      uint64_t v29 = sub_10002E548();
      if (os_log_type_enabled(v29, OS_LOG_TYPE_FAULT)) {
        sub_10008DC78();
      }
      if (qword_1000EBD00) {
        uint64_t v30 = (FILE *)qword_1000EBD00;
      }
      else {
        uint64_t v30 = __stderrp;
      }
      fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v30);
    }
    *__error() = v22;
  }
  BOOL v32 = @"periodic-io-microstackshot-report";
  switch((int)a6)
  {
    case 3:
      if (byte_1000EBCF8)
      {
        int v33 = *__error();
        long long v34 = sub_10002E548();
        if (os_log_type_enabled(v34, OS_LOG_TYPE_ERROR)) {
          sub_10008DBD8(a1);
        }
        *__error() = v33;
      }
      if (byte_1000EBCF9) {
        BOOL v35 = dword_1000EB4A8 <= 3;
      }
      else {
        BOOL v35 = 0;
      }
      if (v35)
      {
        int v36 = *__error();
        int v37 = (const char *)[[[objc_msgSend(objc_msgSend(objc_msgSend(a1, "sampleStore"), "targetProcess"), "name") UTF8String];
        if (v37) {
          CFStringRef v38 = v37;
        }
        else {
          CFStringRef v38 = "No app";
        }
        CFStringRef v39 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%s: %s: DID_MANUAL status while reporting", "status != DID_MANUAL", v38);
        if (v39)
        {
          CFStringRef v76 = v39;
          int v77 = CFStringGetCStringPtr(v39, 0x8000100u);
          if (v77)
          {
            uint64_t v78 = (char *)v77;
            CFStringRef v79 = 0;
          }
          else
          {
            uint64_t v78 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x6C65238BuLL);
            CFStringGetCString(v76, v78, 1024, 0x8000100u);
            CFStringRef v79 = v78;
          }
          if (qword_1000EBD00) {
            int v82 = (FILE *)qword_1000EBD00;
          }
          else {
            int v82 = __stderrp;
          }
          fprintf(v82, "%s\n", v78);
          if (v79) {
            free(v79);
          }
          CFRelease(v76);
        }
        else
        {
          uint64_t v40 = sub_10002E548();
          if (os_log_type_enabled(v40, OS_LOG_TYPE_FAULT)) {
            sub_10008DB38(a1);
          }
          if (qword_1000EBD00) {
            uint64_t v41 = (FILE *)qword_1000EBD00;
          }
          else {
            uint64_t v41 = __stderrp;
          }
          fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v41);
        }
        *__error() = v36;
      }
      [objc_msgSend(objc_msgSend(objc_msgSend(objc_msgSend(a1, "sampleStore"), "targetProcess"), "name"), "UTF8String"]
      sub_10002E41C("SaveReport", "reporting.m", 453, "%s: %s: DID_MANUAL status while reporting", v83, v84, v85, v86, (char)"status != DID_MANUAL");
      goto LABEL_131;
    case 4:
      id v42 = objc_alloc_init((Class)NSDate);
      id v43 = objc_alloc_init((Class)NSDateFormatter);
      [v43 setDateFormat:@"yyyy-MM-dd-HHmmss"];
      id v44 = [v43 stringFromDate:v42];

      id v45 = [objc_alloc((Class)NSString) initWithFormat:@"/var/mobile/Library/Logs/CrashReporter/ShutdownStall-%@.txt", v44];
      uint64_t v46 = fopen((const char *)[v45 UTF8String], "wx");
      if (v46)
      {
        uint64_t v47 = v46;
        uint64_t v48 = 1;
        fwrite("Use spindump -i to generate textual report\n\n", 0x2CuLL, 1uLL, v46);
        [objc_msgSend(a1, "sampleStore") saveBinaryFormatToStream:v47];
        fclose(v47);
      }
      else
      {
        int v97 = *__error();
        int v98 = sub_10002E548();
        if (os_log_type_enabled(v98, OS_LOG_TYPE_FAULT)) {
          sub_10008D884();
        }
        *__error() = v97;
        if (byte_1000EBCF9 && dword_1000EB4A8 <= 4)
        {
          int v99 = *__error();
          uint64_t v100 = *__error();
          CFStringRef v101 = __error();
          int v102 = strerror(*v101);
          CFStringRef v103 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"Unable to create stream from %@: %d (%s)", v45, v100, v102);
          if (v103)
          {
            CFStringRef v104 = v103;
            CFStringRef v105 = CFStringGetCStringPtr(v103, 0x8000100u);
            if (v105)
            {
              int v106 = (char *)v105;
              __int16 v107 = 0;
            }
            else
            {
              int v106 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xA6CB246EuLL);
              CFStringGetCString(v104, v106, 1024, 0x8000100u);
              __int16 v107 = v106;
            }
            if (qword_1000EBD00) {
              CFStringRef v137 = (FILE *)qword_1000EBD00;
            }
            else {
              CFStringRef v137 = __stderrp;
            }
            fprintf(v137, "%s\n", v106);
            if (v107) {
              free(v107);
            }
            CFRelease(v104);
          }
          else
          {
            xpc_object_t v127 = sub_10002E548();
            if (os_log_type_enabled(v127, OS_LOG_TYPE_FAULT)) {
              sub_10008D7F0();
            }
            if (qword_1000EBD00) {
              unsigned int v128 = (FILE *)qword_1000EBD00;
            }
            else {
              unsigned int v128 = __stderrp;
            }
            fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v128);
          }
          *__error() = v99;
        }

        return 0;
      }
      return v48;
    case 5:
      id v49 = [[[a1 sampleStore] targetProcess] name];
      if (v49)
      {
        id v50 = v49;
        id v51 = objc_alloc((Class)NSString);
        if (v15) {
          BOOL v32 = (__CFString *)[v51 initWithFormat:@"%@.cpu_resource_fatal", v50];
        }
        else {
          BOOL v32 = (__CFString *)[v51 initWithFormat:@"%@.cpu_resource", v50];
        }
        goto LABEL_70;
      }
      if (byte_1000EBCF8)
      {
        int v112 = *__error();
        CFStringRef v113 = sub_10002E548();
        if (os_log_type_enabled(v113, OS_LOG_TYPE_ERROR)) {
          sub_10008D9A8(a1);
        }
        *__error() = v112;
      }
      if (byte_1000EBCF9) {
        BOOL v114 = dword_1000EB4A8 <= 3;
      }
      else {
        BOOL v114 = 0;
      }
      if (v114)
      {
        int v115 = *__error();
        CFStringRef v116 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%s: No app name for cpu resource report %s", "appName", [[[objc_msgSend(objc_msgSend(objc_msgSend(objc_msgSend(a1, "sampleStore"), "targetProcess"), "debugDescription"), "UTF8String")];
        if (v116)
        {
          CFStringRef v129 = v116;
          uint64_t v130 = CFStringGetCStringPtr(v116, 0x8000100u);
          if (v130)
          {
            uint64_t v131 = (char *)v130;
            uint64_t v132 = 0;
          }
          else
          {
            uint64_t v131 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xD1AC7067uLL);
            CFStringGetCString(v129, v131, 1024, 0x8000100u);
            uint64_t v132 = v131;
          }
          if (qword_1000EBD00) {
            id v138 = (FILE *)qword_1000EBD00;
          }
          else {
            id v138 = __stderrp;
          }
          fprintf(v138, "%s\n", v131);
          if (v132) {
            free(v132);
          }
          CFRelease(v129);
        }
        else
        {
          CFStringRef v117 = sub_10002E548();
          if (os_log_type_enabled(v117, OS_LOG_TYPE_FAULT)) {
            sub_10008D918(a1);
          }
          if (qword_1000EBD00) {
            int v118 = (FILE *)qword_1000EBD00;
          }
          else {
            int v118 = __stderrp;
          }
          fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v118);
        }
        *__error() = v115;
      }
      [objc_msgSend(objc_msgSend(objc_msgSend(objc_msgSend(a1, "sampleStore"), "targetProcess"), "debugDescription"), "UTF8String");
      sub_10002E41C("SaveReport", "reporting.m", 383, "%s: No app name for cpu resource report %s", v139, v140, v141, v142, (char)"appName");
      goto LABEL_131;
    case 6:
      id v52 = [[[a1 sampleStore] targetProcess] name];
      if (!v52)
      {
        if (byte_1000EBCF8)
        {
          int v119 = *__error();
          BOOL v120 = sub_10002E548();
          if (os_log_type_enabled(v120, OS_LOG_TYPE_ERROR)) {
            sub_10008D9A8(a1);
          }
          *__error() = v119;
        }
        if (byte_1000EBCF9) {
          BOOL v121 = dword_1000EB4A8 <= 3;
        }
        else {
          BOOL v121 = 0;
        }
        if (v121)
        {
          int v122 = *__error();
          CFStringRef v123 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%s: No app name for cpu resource report %s", "appName", [[objc_msgSend(objc_msgSend(objc_msgSend(objc_msgSend(a1, "sampleStore"), "targetProcess"), "debugDescription"), "UTF8String");
          if (v123)
          {
            CFStringRef v133 = v123;
            int v134 = CFStringGetCStringPtr(v123, 0x8000100u);
            if (v134)
            {
              __int16 v135 = (char *)v134;
              BOOL v136 = 0;
            }
            else
            {
              __int16 v135 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x4B8C3696uLL);
              CFStringGetCString(v133, v135, 1024, 0x8000100u);
              BOOL v136 = v135;
            }
            if (qword_1000EBD00) {
              id v143 = (FILE *)qword_1000EBD00;
            }
            else {
              id v143 = __stderrp;
            }
            fprintf(v143, "%s\n", v135);
            if (v136) {
              free(v136);
            }
            CFRelease(v133);
          }
          else
          {
            double v124 = sub_10002E548();
            if (os_log_type_enabled(v124, OS_LOG_TYPE_FAULT)) {
              sub_10008D918(a1);
            }
            if (qword_1000EBD00) {
              double v125 = (FILE *)qword_1000EBD00;
            }
            else {
              double v125 = __stderrp;
            }
            fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v125);
          }
          *__error() = v122;
        }
        [objc_msgSend(objc_msgSend(objc_msgSend(objc_msgSend(a1, "sampleStore"), "targetProcess"), "debugDescription"), "UTF8String");
        sub_10002E41C("SaveReport", "reporting.m", 409, "%s: No app name for cpu resource report %s", v144, v145, v146, v147, (char)"appName");
LABEL_131:
        abort();
      }
      BOOL v32 = (__CFString *)[objc_alloc((Class)NSString) initWithFormat:@"%@.diskwrites_resource", v52];
      if (v15 && qword_1000EBC10 != -1) {
        dispatch_once(&qword_1000EBC10, &stru_1000DD2C8);
      }
LABEL_70:
      if (a12)
      {
        if (byte_1000EBCF8)
        {
          int v88 = *__error();
          CFStringRef v89 = sub_10002E548();
          if (os_log_type_enabled(v89, OS_LOG_TYPE_ERROR)) {
            sub_10008DAB4(v89);
          }
          *__error() = v88;
        }
        if (byte_1000EBCF9) {
          BOOL v90 = dword_1000EB4A8 <= 3;
        }
        else {
          BOOL v90 = 0;
        }
        if (v90)
        {
          int v91 = *__error();
          CFStringRef v92 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%s: asking for URL when generating report via OSA", "!url_out");
          if (v92)
          {
            CFStringRef v108 = v92;
            CFStringRef v109 = CFStringGetCStringPtr(v92, 0x8000100u);
            if (v109)
            {
              int v110 = (char *)v109;
              uint64_t v111 = 0;
            }
            else
            {
              int v110 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xBE5AC277uLL);
              CFStringGetCString(v108, v110, 1024, 0x8000100u);
              uint64_t v111 = v110;
            }
            if (qword_1000EBD00) {
              uint64_t v126 = (FILE *)qword_1000EBD00;
            }
            else {
              uint64_t v126 = __stderrp;
            }
            fprintf(v126, "%s\n", v110);
            if (v111) {
              free(v111);
            }
            CFRelease(v108);
          }
          else
          {
            CFStringRef v93 = sub_10002E548();
            if (os_log_type_enabled(v93, OS_LOG_TYPE_FAULT)) {
              sub_10008DA38(v93, v94, v95);
            }
            if (qword_1000EBD00) {
              BOOL v96 = (FILE *)qword_1000EBD00;
            }
            else {
              BOOL v96 = __stderrp;
            }
            fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v96);
          }
          *__error() = v91;
        }
        sub_10002E41C("SaveReport", "reporting.m", 554, "%s: asking for URL when generating report via OSA", a7, a8, a9, a10, (char)"!url_out");
        goto LABEL_131;
      }
      id v62 = [objc_msgSend(a1, "sampleStore") targetProcess];
      if ([v62 developerType] == 1)
      {
        uint64_t v63 = 1;
      }
      else if ([v62 developerType] == -1 && objc_msgSend(v62, "bundleIdentifier"))
      {
        uint64_t v63 = (uint64_t)[objc_msgSend(objc_msgSend(v62, "bundleIdentifier"), "hasPrefix:", @"com.apple.")];
      }
      else
      {
        uint64_t v63 = 0;
      }
      v149[0] = kOSALogMetadataAppName;
      if (a6 == 4)
      {
        CFStringRef v64 = @"shutdown_stall";
      }
      else
      {
        CFStringRef v65 = (const __CFString *)[v62 name];
        if (v65) {
          CFStringRef v64 = v65;
        }
        else {
          CFStringRef v64 = @"Unknown";
        }
      }
      v150[0] = v64;
      v149[1] = @"app_name";
      CFStringRef v66 = (const __CFString *)[v62 name];
      if (v66) {
        CFStringRef v67 = v66;
      }
      else {
        CFStringRef v67 = @"Unknown";
      }
      v150[1] = v67;
      v149[2] = @"is_first_party";
      v150[2] = +[NSNumber numberWithBool:v63];
      v149[3] = @"share_with_app_devs";
      v150[3] = +[NSNumber numberWithBool:](NSNumber, "numberWithBool:", [+[OSASystemConfiguration sharedInstance] optIn3rdParty]);
      id v68 = [+[NSDictionary dictionaryWithObjects:v150 forKeys:v149 count:4] mutableCopy];
      if ([a1 incidentUUID])
      {
        id v69 = [[objc_msgSend(a1, "incidentUUID") UUIDString];
        [v68 setObject:v69 forKeyedSubscript:kOSALogMetadataIncidentID];
      }
      if ([v62 mainBinary])
      {
        CFStringRef v70 = (const __CFString *)[v62 mainBinary].uuid.UUIDString;
        if (v70) {
          CFStringRef v71 = v70;
        }
        else {
          CFStringRef v71 = &stru_1000E0D58;
        }
        [v68 setObject:v71 forKeyedSubscript:@"slice_uuid"];
      }
      if ([v62 bundleIdentifier])
      {
        id v72 = [v62 bundleIdentifier];
        [v68 setObject:v72 forKeyedSubscript:kOSALogMetadataBundleID];
      }
      if ([v62 bundleVersion]) {
        [v68 setObject:objc_msgSend(v62, "bundleVersion") forKeyedSubscript:@"build_version"];
      }
      if ([v62 bundleShortVersion]) {
        [v68 setObject:objc_msgSend(v62, "bundleShortVersion") forKeyedSubscript:@"app_version"];
      }
      if ([v62 isBeta])
      {
        [v68 setObject:&__kCFBooleanTrue forKeyedSubscript:@"is_beta"];
        if ([v62 cohortID]) {
          [v68 setObject:objc_msgSend(v62, "cohortID") forKeyedSubscript:@"app_cohort"];
        }
      }
      if ([v62 adamID]) {
        [v68 setObject:+[NSString stringWithFormat:](NSString, @"%llu", objc_msgSend(v62, "adamID")), @"adam_id" forKeyedSubscript];
      }
      if ([v62 distributorID]) {
        [v68 setObject:objc_msgSend(v62, "distributorID") forKeyedSubscript:@"distributor_id"];
      }
      if (v14 && objc_msgSend(objc_msgSend(v62, "mainBinaryPath"), "isAbsolutePath"))
      {
        id v73 = [v62 mainBinaryPath];
        [v68 setObject:v73 forKeyedSubscript:kOSALogOptionReopenPath];
      }
      if (a2 > 0.0)
      {
        sub_100024838(v148, 0x32uLL, 0, a2);
        [v68 setObject:+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v148) forKeyedSubscript:@"timestamp"];
      }
      if (a3 > 0.0) {
        [v68 setObject:+[NSString stringWithFormat:](NSString, "stringWithFormat:", @"%.0f", a3 * 1000.0), @"duration_ms" forKeyedSubscript];
      }
      id v74 = v68;
      uint64_t v48 = OSAWriteLogForSubmission();

      return v48;
    case 7:
      BOOL v32 = @"periodic-microstackshot-report";
      goto LABEL_70;
    case 8:
      goto LABEL_70;
    case 9:
    case 10:
      BOOL v32 = 0;
      goto LABEL_70;
    case 14:
      BOOL v32 = 0;
      goto LABEL_70;
    default:
      int v53 = *__error();
      int64_t v54 = sub_10002E548();
      if (os_log_type_enabled(v54, OS_LOG_TYPE_FAULT)) {
        sub_10008D778(a6, v54);
      }
      *__error() = v53;
      if (byte_1000EBCF9) {
        BOOL v55 = dword_1000EB4A8 <= 4;
      }
      else {
        BOOL v55 = 0;
      }
      if (!v55) {
        return 0;
      }
      int v56 = *__error();
      CFStringRef v57 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"SaveReport: Unsupported status %d", a6);
      if (v57)
      {
        CFStringRef v58 = v57;
        int64_t v59 = CFStringGetCStringPtr(v57, 0x8000100u);
        if (v59)
        {
          uint64_t v60 = (char *)v59;
          int64_t v61 = 0;
        }
        else
        {
          uint64_t v60 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xECEB58AFuLL);
          CFStringGetCString(v58, v60, 1024, 0x8000100u);
          int64_t v61 = v60;
        }
        if (qword_1000EBD00) {
          uint64_t v87 = (FILE *)qword_1000EBD00;
        }
        else {
          uint64_t v87 = __stderrp;
        }
        fprintf(v87, "%s\n", v60);
        if (v61) {
          free(v61);
        }
        CFRelease(v58);
      }
      else
      {
        CFStringRef v80 = sub_10002E548();
        if (os_log_type_enabled(v80, OS_LOG_TYPE_FAULT)) {
          sub_10008D700(a6, v80);
        }
        if (qword_1000EBD00) {
          int v81 = (FILE *)qword_1000EBD00;
        }
        else {
          int v81 = __stderrp;
        }
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v81);
      }
      uint64_t v48 = 0;
      *__error() = v56;
      return v48;
  }
}

void sub_10004CF14(id a1)
{
  int v1 = *__error();
  int v2 = sub_10002E548();
  if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
    sub_10008DDB4(v2);
  }
  *__error() = v1;
  if (byte_1000EBCF9) {
    BOOL v3 = dword_1000EB4A8 <= 4;
  }
  else {
    BOOL v3 = 0;
  }
  if (v3)
  {
    int v4 = *__error();
    CFStringRef v5 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"No bug type for fatal disk writes reports, using non-fatal bug type");
    if (v5)
    {
      CFStringRef v6 = v5;
      CStringPtr = CFStringGetCStringPtr(v5, 0x8000100u);
      if (CStringPtr)
      {
        uint64_t v8 = (char *)CStringPtr;
        malloc_type_id_t v9 = 0;
      }
      else
      {
        uint64_t v8 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xE9C6C32uLL);
        CFStringGetCString(v6, v8, 1024, 0x8000100u);
        malloc_type_id_t v9 = v8;
      }
      if (qword_1000EBD00) {
        BOOL v12 = (FILE *)qword_1000EBD00;
      }
      else {
        BOOL v12 = __stderrp;
      }
      fprintf(v12, "%s\n", v8);
      if (v9) {
        free(v9);
      }
      CFRelease(v6);
    }
    else
    {
      uint64_t v10 = sub_10002E548();
      if (os_log_type_enabled(v10, OS_LOG_TYPE_FAULT)) {
        sub_10008DD70(v10);
      }
      if (qword_1000EBD00) {
        int v11 = (FILE *)qword_1000EBD00;
      }
      else {
        int v11 = __stderrp;
      }
      fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v11);
    }
    *__error() = v4;
  }
}

int *sub_10004D0B4(uint64_t a1, void *a2)
{
  if ([a2 fileDescriptor] == -1)
  {
    int v35 = *__error();
    int v36 = sub_10002E548();
    if (os_log_type_enabled(v36, OS_LOG_TYPE_FAULT)) {
      sub_10008DE78(a2, v36);
    }
    id result = __error();
    int *result = v35;
    if (byte_1000EBCF9) {
      BOOL v37 = dword_1000EB4A8 <= 4;
    }
    else {
      BOOL v37 = 0;
    }
    if (v37)
    {
      int v38 = *__error();
      CFStringRef v39 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"OSAWriteLogForSubmission provided invalid fd: %@", [a2 debugDescription]);
      if (v39)
      {
        CFStringRef v40 = v39;
        CStringPtr = CFStringGetCStringPtr(v39, 0x8000100u);
        if (CStringPtr)
        {
          id v42 = (char *)CStringPtr;
          id v43 = 0;
        }
        else
        {
          id v42 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xCB4EB3E7uLL);
          CFStringGetCString(v40, v42, 1024, 0x8000100u);
          id v43 = v42;
        }
        if (qword_1000EBD00) {
          uint64_t v60 = (FILE *)qword_1000EBD00;
        }
        else {
          uint64_t v60 = __stderrp;
        }
        fprintf(v60, "%s\n", v42);
        if (v43) {
          free(v43);
        }
        CFStringRef v61 = v40;
        goto LABEL_111;
      }
      CFStringRef v58 = sub_10002E548();
      if (os_log_type_enabled(v58, OS_LOG_TYPE_FAULT)) {
        sub_10008DDF8(a2, v58);
      }
      goto LABEL_99;
    }
  }
  else
  {
    int v4 = dup((int)[a2 fileDescriptor]);
    if (v4 == -1)
    {
      int v51 = *__error();
      id v52 = sub_10002E548();
      if (os_log_type_enabled(v52, OS_LOG_TYPE_FAULT)) {
        sub_10008DF74();
      }
      id result = __error();
      int *result = v51;
      if (byte_1000EBCF9) {
        BOOL v53 = dword_1000EB4A8 <= 4;
      }
      else {
        BOOL v53 = 0;
      }
      if (v53)
      {
        int v38 = *__error();
        int64_t v54 = __error();
        CFStringRef v55 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"dup of OSA file handle failed: %{errnod}d", *v54);
        if (v55)
        {
          CFStringRef v48 = v55;
          id v49 = CFStringGetCStringPtr(v55, 0x8000100u);
          if (!v49)
          {
            malloc_type_id_t v50 = 1681766229;
            goto LABEL_104;
          }
LABEL_85:
          int v56 = (char *)v49;
          CFStringRef v57 = 0;
LABEL_105:
          if (qword_1000EBD00) {
            CFStringRef v64 = (FILE *)qword_1000EBD00;
          }
          else {
            CFStringRef v64 = __stderrp;
          }
          fprintf(v64, "%s\n", v56);
          if (v57) {
            free(v57);
          }
          CFStringRef v61 = v48;
LABEL_111:
          CFRelease(v61);
LABEL_112:
          id result = __error();
          int *result = v38;
          return result;
        }
        id v62 = sub_10002E548();
        if (os_log_type_enabled(v62, OS_LOG_TYPE_FAULT)) {
          sub_10008DEF8();
        }
LABEL_99:
        if (qword_1000EBD00) {
          uint64_t v63 = (FILE *)qword_1000EBD00;
        }
        else {
          uint64_t v63 = __stderrp;
        }
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v63);
        goto LABEL_112;
      }
    }
    else
    {
      CFStringRef v5 = fdopen(v4, "a");
      if (v5)
      {
        CFStringRef v6 = v5;
        if (*(_DWORD *)(a1 + 56) == 4)
        {
          fwrite("Use spindump -i to generate textual report\n\n", 0x2CuLL, 1uLL, v5);
          [objc_msgSend(*(id *)(a1 + 32), "sampleStore") saveBinaryFormatToStream:v6];
        }
        else
        {
          CFStringRef v7 = *(void **)(a1 + 40);
          if (v7)
          {
            if (fwrite([v7 bytes], (size_t)objc_msgSend(*(id *)(a1 + 40), "length"), 1uLL, v6) != 1)
            {
              if (byte_1000EBCF8)
              {
                int v8 = *__error();
                malloc_type_id_t v9 = sub_10002E548();
                if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR)) {
                  sub_10008E268(v6);
                }
                *__error() = v8;
              }
              if (byte_1000EBCF9 && dword_1000EB4A8 <= 3)
              {
                int v10 = *__error();
                uint64_t v11 = ferror(v6);
                BOOL v12 = strerror(v11);
                CFStringRef v13 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"Unable to write pre-blob to output file: %d (%s)", v11, v12);
                if (v13)
                {
                  CFStringRef v14 = v13;
                  int v15 = CFStringGetCStringPtr(v13, 0x8000100u);
                  if (v15)
                  {
                    int v16 = (char *)v15;
                    uint64_t v17 = 0;
                  }
                  else
                  {
                    int v16 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x1BE1B1BEuLL);
                    CFStringGetCString(v14, v16, 1024, 0x8000100u);
                    uint64_t v17 = v16;
                  }
                  if (qword_1000EBD00) {
                    BOOL v20 = (FILE *)qword_1000EBD00;
                  }
                  else {
                    BOOL v20 = __stderrp;
                  }
                  fprintf(v20, "%s\n", v16);
                  if (v17) {
                    free(v17);
                  }
                  CFRelease(v14);
                }
                else
                {
                  uint64_t v18 = sub_10002E548();
                  if (os_log_type_enabled(v18, OS_LOG_TYPE_FAULT)) {
                    sub_10008E1E8(v6);
                  }
                  if (qword_1000EBD00) {
                    int v19 = (FILE *)qword_1000EBD00;
                  }
                  else {
                    int v19 = __stderrp;
                  }
                  fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v19);
                }
                *__error() = v10;
              }
            }
            fwrite("\n================================================================\n", 0x42uLL, 1uLL, v6);
          }
          [*(id *)(a1 + 32) printToStream:v6];
          if (*(void *)(a1 + 48))
          {
            fwrite("\n================================================================\n", 0x42uLL, 1uLL, v6);
            if (fwrite([*(id *)(a1 + 48) bytes], (size_t)objc_msgSend(*(id *)(a1 + 48), "length"), 1uLL, v6) != 1)
            {
              if (byte_1000EBCF8)
              {
                int v21 = *__error();
                int v22 = sub_10002E548();
                if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR)) {
                  sub_10008E168(v6);
                }
                *__error() = v21;
              }
              if (byte_1000EBCF9 && dword_1000EB4A8 <= 3)
              {
                int v23 = *__error();
                uint64_t v24 = ferror(v6);
                CFStringRef v25 = strerror(v24);
                CFStringRef v26 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"Unable to write post-blob to output file: %d (%s)", v24, v25);
                if (v26)
                {
                  CFStringRef v27 = v26;
                  uint64_t v28 = CFStringGetCStringPtr(v26, 0x8000100u);
                  if (v28)
                  {
                    uint64_t v29 = (char *)v28;
                    uint64_t v30 = 0;
                  }
                  else
                  {
                    uint64_t v29 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xD5B11B88uLL);
                    CFStringGetCString(v27, v29, 1024, 0x8000100u);
                    uint64_t v30 = v29;
                  }
                  if (qword_1000EBD00) {
                    int v33 = (FILE *)qword_1000EBD00;
                  }
                  else {
                    int v33 = __stderrp;
                  }
                  fprintf(v33, "%s\n", v29);
                  if (v30) {
                    free(v30);
                  }
                  CFRelease(v27);
                }
                else
                {
                  xpc_object_t v31 = sub_10002E548();
                  if (os_log_type_enabled(v31, OS_LOG_TYPE_FAULT)) {
                    sub_10008E0E8(v6);
                  }
                  if (qword_1000EBD00) {
                    BOOL v32 = (FILE *)qword_1000EBD00;
                  }
                  else {
                    BOOL v32 = __stderrp;
                  }
                  fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v32);
                }
                *__error() = v23;
              }
            }
          }
        }
        return (int *)fclose(v6);
      }
      int v44 = *__error();
      id v45 = sub_10002E548();
      if (os_log_type_enabled(v45, OS_LOG_TYPE_FAULT)) {
        sub_10008E06C();
      }
      id result = __error();
      int *result = v44;
      if (byte_1000EBCF9 && dword_1000EB4A8 <= 4)
      {
        int v38 = *__error();
        uint64_t v46 = __error();
        CFStringRef v47 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"unable to fdopen OSA dup fd: %{errno}d", *v46);
        if (v47)
        {
          CFStringRef v48 = v47;
          id v49 = CFStringGetCStringPtr(v47, 0x8000100u);
          if (!v49)
          {
            malloc_type_id_t v50 = 3094833571;
LABEL_104:
            int v56 = (char *)malloc_type_calloc(0x400uLL, 1uLL, v50);
            CFStringGetCString(v48, v56, 1024, 0x8000100u);
            CFStringRef v57 = v56;
            goto LABEL_105;
          }
          goto LABEL_85;
        }
        int64_t v59 = sub_10002E548();
        if (os_log_type_enabled(v59, OS_LOG_TYPE_FAULT)) {
          sub_10008DFF0();
        }
        goto LABEL_99;
      }
    }
  }
  return result;
}

CFStringRef sub_10004D904(int a1, int a2)
{
  CFStringRef v2 = @"--------------------------------------------------\nTimeline format: stacks are sorted chronologically\nUse -i and -heavy to re-report with count sorting\n--------------------------------------------------";
  if (a1) {
    CFStringRef v2 = @"------------------------------------------------------------\nHeavy format: stacks are sorted by count\nUse -i and -timeline to re-report with chronological sorting\n------------------------------------------------------------";
  }
  CFStringRef v3 = @"--------------------------------------------------\nTimeline format: stacks are sorted chronologically\n--------------------------------------------------";
  if (a1) {
    CFStringRef v3 = @"----------------------------------------\nHeavy format: stacks are sorted by count\n----------------------------------------";
  }
  if (a2) {
    return v2;
  }
  else {
    return v3;
  }
}

void sub_10004D950(void *a1, uint64_t a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_fault_impl(a1, v9, OS_LOG_TYPE_FAULT, a4, &a9, 8u);
}

void sub_10004D970(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint8_t *a5)
{
  _os_log_fault_impl(a1, a2, OS_LOG_TYPE_FAULT, a4, a5, 0xCu);
}

uint64_t sub_10004D99C(NSString *a1, void *a2, uint64_t a3, int a4, int a5, unsigned int a6, void *a7)
{
  memset(&v25, 0, sizeof(v25));
  if (a1)
  {
    BOOL v12 = a1;
    if (stat([(NSString *)a1 fileSystemRepresentation], &v25)
      || (v25.st_mode & 0xF000) != 0x4000)
    {
      uint64_t v14 = sub_10002B934([(NSString *)v12 UTF8String], a4, a5, a6);
      if (!a7) {
        return v14;
      }
      goto LABEL_21;
    }
    CFStringRef v13 = (const __CFString *)v12;
  }
  else
  {
    CFStringRef v13 = @"/tmp";
  }
  int v22 = a7;
  if (a2)
  {
    if ((a3 & 0x80000000) != 0) {
      int v15 = (NSString *)[a2 stringByReplacingOccurrencesOfString:@" " withString:@"_"];
    }
    else {
      int v15 = +[NSString stringWithFormat:](NSString, "stringWithFormat:", @"%@_%i", [a2 stringByReplacingOccurrencesOfString:@" " withString:@"_"], a3);
    }
    CFStringRef v16 = (const __CFString *)v15;
    CFStringRef v17 = @".spindump.txt";
  }
  else
  {
    CFStringRef v16 = @"spindump";
    CFStringRef v17 = @".txt";
  }
  BOOL v12 = +[NSString stringWithFormat:@"%@/%@%@", v13, v16, v17];
  int v18 = a4 | 0x800;
  LODWORD(v19) = 1;
  memset(&v24, 0, sizeof(v24));
  do
  {
    for (i = v12; !stat([(NSString *)i fileSystemRepresentation], &v24); BOOL v12 = i)
    {
      uint64_t v19 = (v19 + 1);
      uint64_t i = +[NSString stringWithFormat:@"%@/%@.%d%@", v13, v16, v19, v17];
    }
    uint64_t v14 = sub_10002B934([(NSString *)v12 UTF8String], v18, a5, a6);
  }
  while (v14 == -1 && *__error() == 17);
  a7 = v22;
  if (v22) {
LABEL_21:
  }
    *a7 = v12;
  return v14;
}

BOOL sub_10004DBA8()
{
  return objc_opt_class() != 0;
}

void sub_10004DBD0()
{
  if (objc_opt_class())
  {
    if (qword_1000EBC20 != -1) {
      dispatch_once(&qword_1000EBC20, &stru_1000DD4B0);
    }
    uint64_t v0 = qword_1000EBC18;
    dispatch_async(v0, &stru_1000DD400);
  }
  else
  {
    if (byte_1000EBCF8)
    {
      int v1 = *__error();
      CFStringRef v2 = sub_10002E548();
      if (os_log_type_enabled(v2, OS_LOG_TYPE_INFO))
      {
        *(_WORD *)buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_INFO, "Deferred reports not supported, not checking for them", buf, 2u);
      }
      *__error() = v1;
    }
    if (byte_1000EBCF9) {
      BOOL v3 = dword_1000EB4A8 <= 1;
    }
    else {
      BOOL v3 = 0;
    }
    if (v3)
    {
      int v4 = *__error();
      CFStringRef v5 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"Deferred reports not supported, not checking for them");
      if (v5)
      {
        CFStringRef v6 = v5;
        CStringPtr = CFStringGetCStringPtr(v5, 0x8000100u);
        if (CStringPtr)
        {
          int v8 = (char *)CStringPtr;
          malloc_type_id_t v9 = 0;
        }
        else
        {
          int v8 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xF8EFF864uLL);
          CFStringGetCString(v6, v8, 1024, 0x8000100u);
          malloc_type_id_t v9 = v8;
        }
        if (qword_1000EBD00) {
          BOOL v12 = (FILE *)qword_1000EBD00;
        }
        else {
          BOOL v12 = __stderrp;
        }
        fprintf(v12, "%s\n", v8);
        if (v9) {
          free(v9);
        }
        CFRelease(v6);
      }
      else
      {
        uint64_t v10 = sub_10002E548();
        if (os_log_type_enabled(v10, OS_LOG_TYPE_FAULT)) {
          sub_10008E2E8();
        }
        if (qword_1000EBD00) {
          uint64_t v11 = (FILE *)qword_1000EBD00;
        }
        else {
          uint64_t v11 = __stderrp;
        }
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v11);
      }
      *__error() = v4;
    }
  }
}

void sub_10004DE08(id a1)
{
  id v1 = +[BGSystemTaskScheduler sharedScheduler];
  if (qword_1000EBC20 != -1) {
    dispatch_once(&qword_1000EBC20, &stru_1000DD4B0);
  }
  if ([v1 registerForTaskWithIdentifier:@"com.apple.spindump.deferred_report_generation" usingQueue:qword_1000EBC18 launchHandler:&stru_1000DD440])
  {
    if (byte_1000EBCF8)
    {
      int v2 = *__error();
      BOOL v3 = sub_10002E548();
      if (os_log_type_enabled(v3, OS_LOG_TYPE_DEBUG)) {
        sub_10008E350();
      }
      *__error() = v2;
    }
    if (byte_1000EBCF9) {
      BOOL v4 = dword_1000EB4A8 <= 0;
    }
    else {
      BOOL v4 = 0;
    }
    if (!v4) {
      return;
    }
    int v5 = *__error();
    CFStringRef v6 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"Registered for deferred report generation");
    if (v6)
    {
      CFStringRef v7 = v6;
      CStringPtr = CFStringGetCStringPtr(v6, 0x8000100u);
      if (!CStringPtr)
      {
        malloc_type_id_t v9 = 1255908753;
LABEL_35:
        uint64_t v14 = (char *)malloc_type_calloc(0x400uLL, 1uLL, v9);
        CFStringGetCString(v7, v14, 1024, 0x8000100u);
        int v15 = v14;
        goto LABEL_36;
      }
      goto LABEL_25;
    }
    CFStringRef v16 = sub_10002E548();
    if (os_log_type_enabled(v16, OS_LOG_TYPE_FAULT)) {
      sub_10008E31C();
    }
    goto LABEL_30;
  }
  int v10 = *__error();
  uint64_t v11 = sub_10002E548();
  if (os_log_type_enabled(v11, OS_LOG_TYPE_FAULT)) {
    sub_10008E3B8();
  }
  *__error() = v10;
  if (byte_1000EBCF9) {
    BOOL v12 = dword_1000EB4A8 <= 4;
  }
  else {
    BOOL v12 = 0;
  }
  if (v12)
  {
    int v5 = *__error();
    CFStringRef v13 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"Failed to register for deferred report generation");
    if (v13)
    {
      CFStringRef v7 = v13;
      CStringPtr = CFStringGetCStringPtr(v13, 0x8000100u);
      if (!CStringPtr)
      {
        malloc_type_id_t v9 = 3015652427;
        goto LABEL_35;
      }
LABEL_25:
      uint64_t v14 = (char *)CStringPtr;
      int v15 = 0;
LABEL_36:
      if (qword_1000EBD00) {
        uint64_t v19 = (FILE *)qword_1000EBD00;
      }
      else {
        uint64_t v19 = __stderrp;
      }
      fprintf(v19, "%s\n", v14);
      if (v15) {
        free(v15);
      }
      CFRelease(v7);
LABEL_42:
      *__error() = v5;
      return;
    }
    CFStringRef v17 = sub_10002E548();
    if (os_log_type_enabled(v17, OS_LOG_TYPE_FAULT)) {
      sub_10008E384();
    }
LABEL_30:
    if (qword_1000EBD00) {
      int v18 = (FILE *)qword_1000EBD00;
    }
    else {
      int v18 = __stderrp;
    }
    fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v18);
    goto LABEL_42;
  }
}

void sub_10004E0D8(id a1, BGNonRepeatingSystemTask *a2)
{
  v16[0] = 0;
  v16[1] = v16;
  v16[2] = 0x3020000000;
  char v17 = 0;
  v15[0] = _NSConcreteStackBlock;
  v15[1] = 3221225472;
  v15[2] = sub_10004F858;
  v15[3] = &unk_1000DD4D8;
  v15[4] = v16;
  [(BGNonRepeatingSystemTask *)a2 setExpirationHandler:v15];
  v14[0] = _NSConcreteStackBlock;
  v14[1] = 3221225472;
  v14[2] = sub_10004FA24;
  v14[3] = &unk_1000DD500;
  void v14[4] = v16;
  if ((sub_10004FA34((uint64_t)v14) & 1) == 0)
  {
    uint64_t v13 = 0;
    if ([(BGNonRepeatingSystemTask *)a2 setTaskExpiredWithRetryAfter:&v13 error:0.0])goto LABEL_4; {
    int v3 = *__error();
    }
    BOOL v4 = sub_10002E548();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      sub_10008E454();
    }
    *__error() = v3;
    if (byte_1000EBCF9 && dword_1000EB4A8 <= 4)
    {
      int v5 = *__error();
      CFStringRef v6 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"Failed to set expiry: %@", v13);
      CFStringRef v7 = v6;
      if (v6)
      {
        CStringPtr = (char *)CFStringGetCStringPtr(v6, 0x8000100u);
        if (CStringPtr)
        {
          malloc_type_id_t v9 = 0;
        }
        else
        {
          CStringPtr = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xC676F883uLL);
          CFStringGetCString(v7, CStringPtr, 1024, 0x8000100u);
          malloc_type_id_t v9 = CStringPtr;
        }
        if (qword_1000EBD00) {
          BOOL v12 = (FILE *)qword_1000EBD00;
        }
        else {
          BOOL v12 = __stderrp;
        }
        fprintf(v12, "%s\n", CStringPtr);
        if (v9) {
          free(v9);
        }
        CFRelease(v7);
      }
      else
      {
        int v10 = sub_10002E548();
        if (os_log_type_enabled(v10, OS_LOG_TYPE_FAULT)) {
          sub_10008E3EC();
        }
        if (qword_1000EBD00) {
          uint64_t v11 = (FILE *)qword_1000EBD00;
        }
        else {
          uint64_t v11 = __stderrp;
        }
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v11);
      }
      *__error() = v5;
    }
  }
  [(BGNonRepeatingSystemTask *)a2 setTaskCompleted];
LABEL_4:
  _Block_object_dispose(v16, 8);
}

void sub_10004E390(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_start(va, a13);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_10004E3CC(int a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, double a6, double a7, double a8, double a9, double a10)
{
  uint64_t v20 = sub_10002E390("create deferred cpu usage report for [%d]", a1);
  if (qword_1000EBC20 != -1) {
    dispatch_once(&qword_1000EBC20, &stru_1000DD4B0);
  }
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_10004E4EC;
  block[3] = &unk_1000DD468;
  int v22 = a1;
  block[7] = a3;
  block[8] = a4;
  block[4] = a2;
  void block[5] = a5;
  *(double *)&block[9] = a6;
  *(double *)&block[10] = a7;
  *(double *)&block[11] = a8;
  *(double *)&block[12] = a9;
  *(double *)&block[13] = a10;
  void block[6] = v20;
  dispatch_async((dispatch_queue_t)qword_1000EBC18, block);
}

void sub_10004E4EC(uint64_t a1)
{
  id v2 = objc_alloc_init((Class)NSMutableDictionary);
  [v2 setObject:&off_1000E69C0 forKeyedSubscript:@"message"];
  [v2 setObject:[NSNumber numberWithInt:*((unsigned int *)(a1 + 112))] forKeyedSubscript:@"pid"];
  [v2 setObject:*(void *)(a1 + 32) forKeyedSubscript:@"pname"];
  if (*(void *)(a1 + 56)) {
    [v2 setObject:+[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:") forKeyedSubscript:@"tid"];
  }
  [v2 setObject:+[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:", *(void *)(a1 + 64)) forKeyedSubscript:@"flags"];
  [v2 setObject:*(void *)(a1 + 40) forKeyedSubscript:@"action"];
  [v2 setObject:[NSNumber numberWithDouble:*((double *)(a1 + 72))] forKeyedSubscript:@"cpu"];
  [v2 setObject:[+[NSNumber numberWithDouble:](NSNumber, "numberWithDouble:", *(double *)(a1 + 80))] forKeyedSubscript:@"duration"];
  [v2 setObject:[+[NSNumber numberWithDouble:](NSNumber, "numberWithDouble:", *(double *)(a1 + 88))] forKeyedSubscript:@"endtime"];
  if (*(double *)(a1 + 96) > 0.0 && *(double *)(a1 + 104) > 0.0)
  {
    [v2 setObject:+[NSNumber numberWithDouble:](NSNumber, "numberWithDouble:") forKeyedSubscript:@"cpu_limit"];
    [v2 setObject:[+[NSNumber numberWithDouble:](NSNumber, "numberWithDouble:", *(double *)(a1 + 104))] forKeyedSubscript:@"duration_limit"];
  }
  sub_10004E6A0((uint64_t)v2);
}

void sub_10004E6A0(uint64_t a1)
{
  id v2 = +[NSURL fileURLWithPath:@"/private/var/db/spindump/DeferredReports.plist" isDirectory:0];
  int v3 = &AnalyticsIsEventUsed_ptr;
  if ([+[NSFileManager defaultManager] fileExistsAtPath:@"/private/var/db/spindump/DeferredReports.plist"])
  {
    *(void *)buf = 0;
    id v4 = [+[NSArray arrayWithContentsOfURL:v2 error:buf] mutableCopy];
    if (v4) {
      goto LABEL_52;
    }
    int v5 = *__error();
    CFStringRef v6 = sub_10002E548();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_FAULT)) {
      sub_10008E970();
    }
    *__error() = v5;
    if (byte_1000EBCF9 && dword_1000EB4A8 <= 4)
    {
      int v7 = *__error();
      CFStringRef v8 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"Unable to read deferred reports plist, overwriting it: %@", *(void *)buf);
      if (v8)
      {
        CFStringRef v9 = v8;
        CStringPtr = CFStringGetCStringPtr(v8, 0x8000100u);
        if (CStringPtr)
        {
          uint64_t v11 = (char *)CStringPtr;
          BOOL v12 = 0;
        }
        else
        {
          uint64_t v11 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x547D7233uLL);
          CFStringGetCString(v9, v11, 1024, 0x8000100u);
          BOOL v12 = v11;
        }
        if (qword_1000EBD00) {
          CFStringRef v27 = (FILE *)qword_1000EBD00;
        }
        else {
          CFStringRef v27 = __stderrp;
        }
        fprintf(v27, "%s\n", v11);
        if (v12) {
          free(v12);
        }
        CFRelease(v9);
      }
      else
      {
        stat v25 = sub_10002E548();
        if (os_log_type_enabled(v25, OS_LOG_TYPE_FAULT)) {
          sub_10008E908();
        }
        if (qword_1000EBD00) {
          CFStringRef v26 = (FILE *)qword_1000EBD00;
        }
        else {
          CFStringRef v26 = __stderrp;
        }
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v26);
      }
      *__error() = v7;
    }
    uint64_t v100 = 0;
    if (![+[NSFileManager defaultManager] removeItemAtURL:v2 error:&v100])
    {
      int v88 = *__error();
      CFStringRef v89 = sub_10002E548();
      if (os_log_type_enabled(v89, OS_LOG_TYPE_FAULT)) {
        sub_10008E7A8();
      }
      *__error() = v88;
      if (byte_1000EBCF9 && dword_1000EB4A8 <= 4)
      {
        int v90 = *__error();
        CFStringRef v91 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"Unable to remove deferred reports plist: %@", v100);
        if (v91)
        {
          CFStringRef v92 = v91;
          CFStringRef v93 = CFStringGetCStringPtr(v91, 0x8000100u);
          if (v93)
          {
            uint64_t v94 = (char *)v93;
            uint64_t v95 = 0;
          }
          else
          {
            uint64_t v94 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xC44A159DuLL);
            CFStringGetCString(v92, v94, 1024, 0x8000100u);
            uint64_t v95 = v94;
          }
          if (qword_1000EBD00) {
            int v99 = (FILE *)qword_1000EBD00;
          }
          else {
            int v99 = __stderrp;
          }
          fprintf(v99, "%s\n", v94);
          if (v95) {
            free(v95);
          }
          CFRelease(v92);
        }
        else
        {
          int v97 = sub_10002E548();
          if (os_log_type_enabled(v97, OS_LOG_TYPE_FAULT)) {
            sub_10008E740();
          }
          if (qword_1000EBD00) {
            int v98 = (FILE *)qword_1000EBD00;
          }
          else {
            int v98 = __stderrp;
          }
          fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v98);
        }
        *__error() = v90;
      }
    }
  }
  else
  {
    if (byte_1000EBCF8)
    {
      int v13 = *__error();
      uint64_t v14 = sub_10002E548();
      if (os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG)) {
        sub_10008EA0C();
      }
      *__error() = v13;
    }
    if (byte_1000EBCF9) {
      BOOL v15 = dword_1000EB4A8 <= 0;
    }
    else {
      BOOL v15 = 0;
    }
    if (v15)
    {
      int v16 = *__error();
      CFStringRef v17 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"No existing deferred reports, creating new plist");
      if (v17)
      {
        CFStringRef v18 = v17;
        uint64_t v19 = CFStringGetCStringPtr(v17, 0x8000100u);
        if (v19)
        {
          uint64_t v20 = (char *)v19;
          int v21 = 0;
        }
        else
        {
          uint64_t v20 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xDBF725E7uLL);
          CFStringGetCString(v18, v20, 1024, 0x8000100u);
          int v21 = v20;
        }
        if (qword_1000EBD00) {
          stat v24 = (FILE *)qword_1000EBD00;
        }
        else {
          stat v24 = __stderrp;
        }
        fprintf(v24, "%s\n", v20);
        if (v21) {
          free(v21);
        }
        CFRelease(v18);
      }
      else
      {
        int v22 = sub_10002E548();
        if (os_log_type_enabled(v22, OS_LOG_TYPE_FAULT)) {
          sub_10008E9D8();
        }
        if (qword_1000EBD00) {
          int v23 = (FILE *)qword_1000EBD00;
        }
        else {
          int v23 = __stderrp;
        }
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v23);
      }
      *__error() = v16;
      int v3 = &AnalyticsIsEventUsed_ptr;
    }
  }
  id v4 = [objc_alloc((Class)NSMutableArray) initWithCapacity:1];
LABEL_52:
  [v4 addObject:a1];
  uint64_t v100 = 0;
  if ([v4 writeToURL:v2 error:&v100])
  {
    if (byte_1000EBCF8)
    {
      int v28 = *__error();
      uint64_t v29 = sub_10002E548();
      if (os_log_type_enabled(v29, OS_LOG_TYPE_INFO))
      {
        id v30 = [v4 count];
        *(_DWORD *)buf = 134217984;
        *(void *)&uint8_t buf[4] = v30;
        _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_INFO, "Added report to pending deferred reports (have %lu)", buf, 0xCu);
      }
      *__error() = v28;
    }
    if (byte_1000EBCF9 && dword_1000EB4A8 <= 1)
    {
      int v31 = *__error();
      CFStringRef v32 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"Added report to pending deferred reports (have %lu)", [v4 count]);
      if (v32)
      {
        CFStringRef v33 = v32;
        long long v34 = CFStringGetCStringPtr(v32, 0x8000100u);
        if (v34)
        {
          int v35 = (char *)v34;
          int v36 = 0;
        }
        else
        {
          int v35 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xA2C9B765uLL);
          CFStringGetCString(v33, v35, 1024, 0x8000100u);
          int v36 = v35;
        }
        if (qword_1000EBD00) {
          malloc_type_id_t v50 = (FILE *)qword_1000EBD00;
        }
        else {
          malloc_type_id_t v50 = __stderrp;
        }
        fprintf(v50, "%s\n", v35);
        if (v36) {
          free(v36);
        }
        CFRelease(v33);
      }
      else
      {
        uint64_t v46 = sub_10002E548();
        if (os_log_type_enabled(v46, OS_LOG_TYPE_FAULT)) {
          sub_10008E6C4(v4);
        }
        if (qword_1000EBD00) {
          CFStringRef v47 = (FILE *)qword_1000EBD00;
        }
        else {
          CFStringRef v47 = __stderrp;
        }
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v47);
      }
      *__error() = v31;
    }

    if (!objc_opt_class())
    {
      int v58 = *__error();
      int64_t v59 = sub_10002E548();
      if (os_log_type_enabled(v59, OS_LOG_TYPE_FAULT)) {
        sub_10008E4F0();
      }
      *__error() = v58;
      if (byte_1000EBCF9 && dword_1000EB4A8 <= 4)
      {
        int v53 = *__error();
        CFStringRef v60 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"Attempting to defer reports when not supported. Caller should check before calling");
        if (v60)
        {
          CFStringRef v55 = v60;
          int v56 = CFStringGetCStringPtr(v60, 0x8000100u);
          if (!v56)
          {
            malloc_type_id_t v57 = 39118979;
            goto LABEL_149;
          }
          goto LABEL_106;
        }
        int v81 = sub_10002E548();
        if (os_log_type_enabled(v81, OS_LOG_TYPE_FAULT)) {
          sub_10008E4BC();
        }
        goto LABEL_144;
      }
      return;
    }
    if (objc_msgSend(+[BGSystemTaskScheduler sharedScheduler](BGSystemTaskScheduler, "sharedScheduler"), "taskRequestForIdentifier:", @"com.apple.spindump.deferred_report_generation"))
    {
      if (byte_1000EBCF8)
      {
        int v51 = *__error();
        id v52 = sub_10002E548();
        if (os_log_type_enabled(v52, OS_LOG_TYPE_DEBUG)) {
          sub_10008E690();
        }
        *__error() = v51;
      }
      if (byte_1000EBCF9 && dword_1000EB4A8 <= 0)
      {
        int v53 = *__error();
        CFStringRef v54 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"Deferred report task already exists");
        if (v54)
        {
          CFStringRef v55 = v54;
          int v56 = CFStringGetCStringPtr(v54, 0x8000100u);
          if (!v56)
          {
            malloc_type_id_t v57 = 1778843600;
LABEL_149:
            CFStringRef v61 = (char *)malloc_type_calloc(0x400uLL, 1uLL, v57);
            CFStringGetCString(v55, v61, 1024, 0x8000100u);
            id v62 = v61;
            goto LABEL_150;
          }
          goto LABEL_106;
        }
        CFStringRef v80 = sub_10002E548();
        if (os_log_type_enabled(v80, OS_LOG_TYPE_FAULT)) {
          sub_10008E65C();
        }
        goto LABEL_144;
      }
      return;
    }
    id v63 = [objc_alloc((Class)BGNonRepeatingSystemTaskRequest) initWithIdentifier:@"com.apple.spindump.deferred_report_generation"];
    [v63 setPriority:1];
    [v63 setScheduleAfter:1.0];
    [v63 setRequiresNetworkConnectivity:0];
    [v63 setRequiresExternalPower:0];
    *(void *)buf = 0;
    if (objc_msgSend(+[BGSystemTaskScheduler sharedScheduler](BGSystemTaskScheduler, "sharedScheduler"), "submitTaskRequest:error:", v63, buf))
    {
      if (byte_1000EBCF8)
      {
        int v64 = *__error();
        CFStringRef v65 = sub_10002E548();
        if (os_log_type_enabled(v65, OS_LOG_TYPE_DEBUG)) {
          sub_10008E558();
        }
        *__error() = v64;
      }
      if (!byte_1000EBCF9 || dword_1000EB4A8 > 0) {
        goto LABEL_174;
      }
      int v66 = *__error();
      CFStringRef v67 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"Submitted deferred report task successfully");
      if (v67)
      {
        CFStringRef v68 = v67;
        id v69 = CFStringGetCStringPtr(v67, 0x8000100u);
        if (!v69)
        {
          malloc_type_id_t v70 = 3303021729;
LABEL_166:
          id v74 = (char *)malloc_type_calloc(0x400uLL, 1uLL, v70);
          CFStringGetCString(v68, v74, 1024, 0x8000100u);
          CFStringRef v75 = v74;
          goto LABEL_167;
        }
        goto LABEL_123;
      }
      uint64_t v84 = sub_10002E548();
      if (os_log_type_enabled(v84, OS_LOG_TYPE_FAULT)) {
        sub_10008E524();
      }
    }
    else
    {
      int v71 = *__error();
      id v72 = sub_10002E548();
      if (os_log_type_enabled(v72, OS_LOG_TYPE_FAULT)) {
        sub_10008E5F4();
      }
      *__error() = v71;
      if (!byte_1000EBCF9 || dword_1000EB4A8 > 4) {
        goto LABEL_174;
      }
      int v66 = *__error();
      CFStringRef v73 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"Failed to submit task with error: %@", *(void *)buf);
      if (v73)
      {
        CFStringRef v68 = v73;
        id v69 = CFStringGetCStringPtr(v73, 0x8000100u);
        if (!v69)
        {
          malloc_type_id_t v70 = 1018071091;
          goto LABEL_166;
        }
LABEL_123:
        id v74 = (char *)v69;
        CFStringRef v75 = 0;
LABEL_167:
        if (qword_1000EBD00) {
          uint64_t v87 = (FILE *)qword_1000EBD00;
        }
        else {
          uint64_t v87 = __stderrp;
        }
        fprintf(v87, "%s\n", v74);
        if (v75) {
          free(v75);
        }
        CFRelease(v68);
        goto LABEL_173;
      }
      uint64_t v85 = sub_10002E548();
      if (os_log_type_enabled(v85, OS_LOG_TYPE_FAULT)) {
        sub_10008E58C();
      }
    }
    if (qword_1000EBD00) {
      uint64_t v86 = (FILE *)qword_1000EBD00;
    }
    else {
      uint64_t v86 = __stderrp;
    }
    fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v86);
LABEL_173:
    *__error() = v66;
LABEL_174:

    return;
  }
  int v37 = *__error();
  int v38 = sub_10002E548();
  if (os_log_type_enabled(v38, OS_LOG_TYPE_FAULT)) {
    sub_10008E88C();
  }
  *__error() = v37;
  if (byte_1000EBCF9 && dword_1000EB4A8 <= 4)
  {
    int v39 = *__error();
    id v40 = [v4 count];
    CFStringRef v41 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"Unable to write %lu deferred reports to plist: %@", v40, v100);
    if (v41)
    {
      CFStringRef v42 = v41;
      id v43 = CFStringGetCStringPtr(v41, 0x8000100u);
      if (v43)
      {
        int v44 = (char *)v43;
        id v45 = 0;
      }
      else
      {
        int v44 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xD19FDEA4uLL);
        CFStringGetCString(v42, v44, 1024, 0x8000100u);
        id v45 = v44;
      }
      if (qword_1000EBD00) {
        CFStringRef v76 = (FILE *)qword_1000EBD00;
      }
      else {
        CFStringRef v76 = __stderrp;
      }
      fprintf(v76, "%s\n", v44);
      if (v45) {
        free(v45);
      }
      CFRelease(v42);
    }
    else
    {
      CFStringRef v48 = sub_10002E548();
      if (os_log_type_enabled(v48, OS_LOG_TYPE_FAULT)) {
        sub_10008E810();
      }
      if (qword_1000EBD00) {
        id v49 = (FILE *)qword_1000EBD00;
      }
      else {
        id v49 = __stderrp;
      }
      fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v49);
    }
    *__error() = v39;
  }

  *(void *)buf = 0;
  if ((objc_msgSend(objc_msgSend(v3[301], "defaultManager"), "removeItemAtURL:error:", v2, buf) & 1) == 0)
  {
    int v77 = *__error();
    uint64_t v78 = sub_10002E548();
    if (os_log_type_enabled(v78, OS_LOG_TYPE_FAULT)) {
      sub_10008E7A8();
    }
    *__error() = v77;
    if (byte_1000EBCF9)
    {
      if (dword_1000EB4A8 <= 4)
      {
        int v53 = *__error();
        CFStringRef v79 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"Unable to remove deferred reports plist: %@", *(void *)buf);
        if (v79)
        {
          CFStringRef v55 = v79;
          int v56 = CFStringGetCStringPtr(v79, 0x8000100u);
          if (!v56)
          {
            malloc_type_id_t v57 = 331909043;
            goto LABEL_149;
          }
LABEL_106:
          CFStringRef v61 = (char *)v56;
          id v62 = 0;
LABEL_150:
          if (qword_1000EBD00) {
            uint64_t v83 = (FILE *)qword_1000EBD00;
          }
          else {
            uint64_t v83 = __stderrp;
          }
          fprintf(v83, "%s\n", v61);
          if (v62) {
            free(v62);
          }
          CFRelease(v55);
LABEL_156:
          *__error() = v53;
          return;
        }
        BOOL v96 = sub_10002E548();
        if (os_log_type_enabled(v96, OS_LOG_TYPE_FAULT)) {
          sub_10008E740();
        }
LABEL_144:
        if (qword_1000EBD00) {
          int v82 = (FILE *)qword_1000EBD00;
        }
        else {
          int v82 = __stderrp;
        }
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v82);
        goto LABEL_156;
      }
    }
  }
}

void sub_10004F54C(int a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, double a7, double a8, double a9)
{
  uint64_t v18 = sub_10002E390("create deferred disk writes report for [%d]", a1);
  if (qword_1000EBC20 != -1) {
    dispatch_once(&qword_1000EBC20, &stru_1000DD4B0);
  }
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_10004F668;
  block[3] = &unk_1000DD490;
  int v20 = a1;
  block[4] = a2;
  void block[5] = a4;
  block[7] = a3;
  block[8] = a5;
  *(double *)&block[9] = a7;
  *(double *)&block[10] = a8;
  block[11] = a6;
  *(double *)&block[12] = a9;
  void block[6] = v18;
  dispatch_async((dispatch_queue_t)qword_1000EBC18, block);
}

void sub_10004F668(uint64_t a1)
{
  id v2 = objc_alloc_init((Class)NSMutableDictionary);
  [v2 setObject:&off_1000E69D8 forKeyedSubscript:@"message"];
  [v2 setObject:[+[NSNumber numberWithInt:](NSNumber, "numberWithInt:", *(unsigned int *)(a1 + 104))] forKeyedSubscript:@"pid"];
  [v2 setObject:*(void *)(a1 + 32) forKeyedSubscript:@"pname"];
  [v2 setObject:+[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:", *(void *)(a1 + 56)) forKeyedSubscript:@"flags"];
  [v2 setObject:*(void *)(a1 + 40) forKeyedSubscript:@"action"];
  [v2 setObject:+[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:", *(void *)(a1 + 64)) forKeyedSubscript:@"io"];
  [v2 setObject:[+[NSNumber numberWithDouble:](NSNumber, "numberWithDouble:", *(double *)(a1 + 72))] forKeyedSubscript:@"duration"];
  [v2 setObject:[+[NSNumber numberWithDouble:](NSNumber, "numberWithDouble:", *(double *)(a1 + 80))] forKeyedSubscript:@"endtime"];
  if (*(void *)(a1 + 88) && *(double *)(a1 + 96) > 0.0)
  {
    [v2 setObject:[+[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:") unsignedLongLongValue] forKeyedSubscript:@"io_limit"];
    [v2 setObject:[+[NSNumber numberWithDouble:](NSNumber, "numberWithDouble:", *(double *)(a1 + 96))] forKeyedSubscript:@"duration_limit"];
  }
  sub_10004E6A0((uint64_t)v2);
}

void sub_10004F7F4(id a1)
{
  id v1 = dispatch_queue_attr_make_with_autorelease_frequency(0, DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM);
  id v2 = dispatch_queue_attr_make_with_qos_class(v1, QOS_CLASS_BACKGROUND, 0);
  qword_1000EBC18 = (uint64_t)dispatch_queue_create("com.apple.spindump.deferred_report_generation", v2);

  dispatch_release(v2);
}

int *sub_10004F858(int *result)
{
  id v1 = result;
  if (byte_1000EBCF8)
  {
    int v2 = *__error();
    int v3 = sub_10002E548();
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEBUG)) {
      sub_10008EA74();
    }
    id result = __error();
    int *result = v2;
  }
  if (byte_1000EBCF9) {
    BOOL v4 = dword_1000EB4A8 <= 0;
  }
  else {
    BOOL v4 = 0;
  }
  if (v4)
  {
    int v5 = *__error();
    CFStringRef v6 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"Deferred tasks expired");
    if (v6)
    {
      CFStringRef v7 = v6;
      CStringPtr = CFStringGetCStringPtr(v6, 0x8000100u);
      if (CStringPtr)
      {
        CFStringRef v9 = (char *)CStringPtr;
        int v10 = 0;
      }
      else
      {
        CFStringRef v9 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xCD89AA88uLL);
        CFStringGetCString(v7, v9, 1024, 0x8000100u);
        int v10 = v9;
      }
      if (qword_1000EBD00) {
        int v13 = (FILE *)qword_1000EBD00;
      }
      else {
        int v13 = __stderrp;
      }
      fprintf(v13, "%s\n", v9);
      if (v10) {
        free(v10);
      }
      CFRelease(v7);
    }
    else
    {
      uint64_t v11 = sub_10002E548();
      if (os_log_type_enabled(v11, OS_LOG_TYPE_FAULT)) {
        sub_10008EA40();
      }
      if (qword_1000EBD00) {
        BOOL v12 = (FILE *)qword_1000EBD00;
      }
      else {
        BOOL v12 = __stderrp;
      }
      fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v12);
    }
    id result = __error();
    int *result = v5;
  }
  *(unsigned char *)(*(void *)(*((void *)v1 + 4) + 8) + 40) = 1;
  return result;
}

uint64_t sub_10004FA24(uint64_t a1)
{
  return *(unsigned __int8 *)(*(void *)(*(void *)(a1 + 32) + 8) + 40);
}

uint64_t sub_10004FA34(uint64_t a1)
{
  if (byte_1000EBCF8)
  {
    int v2 = *__error();
    int v3 = sub_10002E548();
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Generating deferred reports", buf, 2u);
    }
    *__error() = v2;
  }
  if (byte_1000EBCF9) {
    BOOL v4 = dword_1000EB4A8 <= 2;
  }
  else {
    BOOL v4 = 0;
  }
  if (v4)
  {
    int v5 = *__error();
    CFStringRef v6 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"Generating deferred reports");
    if (v6)
    {
      CFStringRef v7 = v6;
      CStringPtr = CFStringGetCStringPtr(v6, 0x8000100u);
      if (CStringPtr)
      {
        CFStringRef v9 = (char *)CStringPtr;
        int v10 = 0;
      }
      else
      {
        CFStringRef v9 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xC85E0EAAuLL);
        CFStringGetCString(v7, v9, 1024, 0x8000100u);
        int v10 = v9;
      }
      if (qword_1000EBD00) {
        int v13 = (FILE *)qword_1000EBD00;
      }
      else {
        int v13 = __stderrp;
      }
      fprintf(v13, "%s\n", v9);
      if (v10) {
        free(v10);
      }
      CFRelease(v7);
    }
    else
    {
      uint64_t v11 = sub_10002E548();
      if (os_log_type_enabled(v11, OS_LOG_TYPE_FAULT)) {
        sub_10008F10C();
      }
      if (qword_1000EBD00) {
        BOOL v12 = (FILE *)qword_1000EBD00;
      }
      else {
        BOOL v12 = __stderrp;
      }
      fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v12);
    }
    *__error() = v5;
  }
  if (![+[NSFileManager defaultManager] fileExistsAtPath:@"/private/var/db/spindump/DeferredReports.plist"])
  {
    if (byte_1000EBCF8)
    {
      int v162 = *__error();
      CFStringRef v163 = sub_10002E548();
      if (os_log_type_enabled(v163, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v163, OS_LOG_TYPE_DEFAULT, "No deferred reports", buf, 2u);
      }
      *__error() = v162;
    }
    if (byte_1000EBCF9) {
      BOOL v164 = dword_1000EB4A8 <= 2;
    }
    else {
      BOOL v164 = 0;
    }
    if (!v164) {
      return 1;
    }
    int v165 = *__error();
    CFStringRef v166 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"No deferred reports");
    if (v166)
    {
      CFStringRef v167 = v166;
      CFStringRef v168 = CFStringGetCStringPtr(v166, 0x8000100u);
      if (!v168)
      {
        malloc_type_id_t v213 = 1034863384;
        goto LABEL_388;
      }
      goto LABEL_331;
    }
    int v200 = sub_10002E548();
    if (os_log_type_enabled(v200, OS_LOG_TYPE_FAULT)) {
      sub_10008F0D8();
    }
    goto LABEL_371;
  }
  uint64_t v14 = +[NSURL fileURLWithPath:@"/private/var/db/spindump/DeferredReports.plist" isDirectory:0];
  uint64_t v276 = 0;
  BOOL v15 = +[NSArray arrayWithContentsOfURL:v14 error:&v276];
  if (!v15)
  {
    if (byte_1000EBCF8)
    {
      int v181 = *__error();
      CFStringRef v182 = sub_10002E548();
      if (os_log_type_enabled(v182, OS_LOG_TYPE_ERROR)) {
        sub_10008EB10();
      }
      *__error() = v181;
    }
    if (byte_1000EBCF9) {
      BOOL v183 = dword_1000EB4A8 <= 3;
    }
    else {
      BOOL v183 = 0;
    }
    if (v183)
    {
      int v184 = *__error();
      CFStringRef v185 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"Unable to read deferred reports plist: %@", v276);
      if (v185)
      {
        CFStringRef v186 = v185;
        id v187 = CFStringGetCStringPtr(v185, 0x8000100u);
        if (v187)
        {
          CFStringRef v188 = (char *)v187;
          double v189 = 0;
        }
        else
        {
          CFStringRef v188 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xA9096A30uLL);
          CFStringGetCString(v186, v188, 1024, 0x8000100u);
          double v189 = v188;
        }
        if (qword_1000EBD00) {
          int v223 = (FILE *)qword_1000EBD00;
        }
        else {
          int v223 = __stderrp;
        }
        fprintf(v223, "%s\n", v188);
        if (v189) {
          free(v189);
        }
        CFRelease(v186);
      }
      else
      {
        uint64_t v217 = sub_10002E548();
        if (os_log_type_enabled(v217, OS_LOG_TYPE_FAULT)) {
          sub_10008EAA8();
        }
        if (qword_1000EBD00) {
          int v218 = (FILE *)qword_1000EBD00;
        }
        else {
          int v218 = __stderrp;
        }
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v218);
      }
      *__error() = v184;
    }
    *(void *)buf = 0;
    if ([+[NSFileManager defaultManager] removeItemAtURL:v14 error:buf])
    {
      return 1;
    }
    int v224 = *__error();
    CFStringRef v225 = sub_10002E548();
    if (os_log_type_enabled(v225, OS_LOG_TYPE_FAULT)) {
      sub_10008E7A8();
    }
    *__error() = v224;
    if (!byte_1000EBCF9 || dword_1000EB4A8 > 4) {
      return 1;
    }
    int v165 = *__error();
    CFStringRef v226 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"Unable to remove deferred reports plist: %@", *(void *)buf);
    if (v226)
    {
      CFStringRef v167 = v226;
      CFStringRef v168 = CFStringGetCStringPtr(v226, 0x8000100u);
      if (v168) {
        goto LABEL_331;
      }
      malloc_type_id_t v213 = 2680440707;
      goto LABEL_388;
    }
    CFStringRef v252 = sub_10002E548();
    if (!os_log_type_enabled(v252, OS_LOG_TYPE_FAULT)) {
      goto LABEL_371;
    }
LABEL_503:
    sub_10008E740();
    goto LABEL_371;
  }
  int v16 = v15;
  objc_opt_class();
  long long v301 = 0u;
  long long v302 = 0u;
  long long v303 = 0u;
  long long v304 = 0u;
  id v17 = [(NSArray *)v16 countByEnumeratingWithState:&v301 objects:buf count:16];
  if (!v17) {
    goto LABEL_37;
  }
  id v18 = v17;
  uint64_t v19 = *(void *)v302;
LABEL_31:
  uint64_t v20 = 0;
  while (1)
  {
    if (*(void *)v302 != v19) {
      objc_enumerationMutation(v16);
    }
    if ((objc_opt_isKindOfClass() & 1) == 0) {
      break;
    }
    if (v18 == (id)++v20)
    {
      id v18 = [(NSArray *)v16 countByEnumeratingWithState:&v301 objects:buf count:16];
      if (!v18)
      {
LABEL_37:
        unint64_t v21 = 0;
        if ([(NSArray *)v16 count])
        {
          while (1)
          {
            if ((*(uint64_t (**)(uint64_t))(a1 + 16))(a1)) {
              goto LABEL_356;
            }
            id v22 = [(NSArray *)v16 objectAtIndexedSubscript:v21];
            id v23 = sub_10005248C(v22, @"message");
            if (!v23) {
              break;
            }
            stat v24 = v23;
            id v25 = [v23 longLongValue];
            if (v25 == (id)5)
            {
              id v51 = [[sub_10005248C(v22, @"pid") intValue];
              if (v51)
              {
                uint64_t v52 = (uint64_t)v51;
                id v53 = [[sub_10005248C(v22, @"flags") unsignedLongLongValue];
                id v54 = [sub_10005248C(v22, @"io") longLongValue];
                if ((uint64_t)v54 <= 0)
                {
                  if (byte_1000EBCF8)
                  {
                    int v83 = *__error();
                    uint64_t v84 = sub_10002E548();
                    if (os_log_type_enabled(v84, OS_LOG_TYPE_ERROR))
                    {
                      *(_DWORD *)buf = 134217984;
                      *(void *)&uint8_t buf[4] = v54;
                      _os_log_error_impl((void *)&_mh_execute_header, v84, OS_LOG_TYPE_ERROR, "deferred disk writes resource: bad bytes (%lld)", buf, 0xCu);
                    }
                    *__error() = v83;
                  }
                  if (!byte_1000EBCF9 || dword_1000EB4A8 > 3) {
                    goto LABEL_279;
                  }
                  int v40 = *__error();
                  CFStringRef v85 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"deferred disk writes resource: bad bytes (%lld)", v54);
                  if (!v85)
                  {
                    __int16 v107 = sub_10002E548();
                    if (os_log_type_enabled(v107, OS_LOG_TYPE_FAULT))
                    {
                      *(_DWORD *)buf = 134217984;
                      *(void *)&uint8_t buf[4] = v54;
                      CFStringRef v105 = v107;
                      int v106 = "Unable to format: deferred disk writes resource: bad bytes (%lld)";
                      goto LABEL_220;
                    }
                    goto LABEL_274;
                  }
                  CFStringRef v42 = v85;
                  id v43 = CFStringGetCStringPtr(v85, 0x8000100u);
                  if (v43) {
                    goto LABEL_67;
                  }
                  malloc_type_id_t v44 = 3046411982;
                }
                else
                {
                  [sub_10005248C(v22, @"duration") doubleValue];
                  double v56 = v55;
                  if (v55 <= 0.0)
                  {
                    if (byte_1000EBCF8)
                    {
                      int v88 = *__error();
                      CFStringRef v89 = sub_10002E548();
                      if (os_log_type_enabled(v89, OS_LOG_TYPE_ERROR))
                      {
                        *(_DWORD *)buf = 134217984;
                        *(double *)&uint8_t buf[4] = v56;
                        _os_log_error_impl((void *)&_mh_execute_header, v89, OS_LOG_TYPE_ERROR, "deferred disk writes resource: bad duration (%f)", buf, 0xCu);
                      }
                      *__error() = v88;
                    }
                    if (!byte_1000EBCF9 || dword_1000EB4A8 > 3) {
                      goto LABEL_279;
                    }
                    int v40 = *__error();
                    CFStringRef v90 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"deferred disk writes resource: bad duration (%f)", *(void *)&v56);
                    if (!v90)
                    {
                      CFStringRef v116 = sub_10002E548();
                      if (os_log_type_enabled(v116, OS_LOG_TYPE_FAULT))
                      {
                        *(_DWORD *)buf = 134217984;
                        *(double *)&uint8_t buf[4] = v56;
                        CFStringRef v105 = v116;
                        int v106 = "Unable to format: deferred disk writes resource: bad duration (%f)";
                        goto LABEL_220;
                      }
                      goto LABEL_274;
                    }
                    CFStringRef v42 = v90;
                    id v43 = CFStringGetCStringPtr(v90, 0x8000100u);
                    if (v43) {
                      goto LABEL_67;
                    }
                    malloc_type_id_t v44 = 4207070971;
                  }
                  else
                  {
                    [sub_10005248C(v22, @"endtime") doubleValue];
                    if (v57 <= 0.0)
                    {
                      if (byte_1000EBCF8)
                      {
                        int v96 = *__error();
                        int v97 = sub_10002E548();
                        if (os_log_type_enabled(v97, OS_LOG_TYPE_ERROR)) {
                          sub_10008F038(&v291, v292);
                        }
                        *__error() = v96;
                      }
                      if (!byte_1000EBCF9 || dword_1000EB4A8 > 3) {
                        goto LABEL_279;
                      }
                      int v40 = *__error();
                      CFStringRef v98 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"deferred disk writes resource: no endtime provided");
                      if (!v98)
                      {
                        int v122 = sub_10002E548();
                        if (os_log_type_enabled(v122, OS_LOG_TYPE_FAULT)) {
                          sub_10008F008(&v289, v290);
                        }
                        goto LABEL_274;
                      }
                      CFStringRef v42 = v98;
                      id v43 = CFStringGetCStringPtr(v98, 0x8000100u);
                      if (v43) {
                        goto LABEL_67;
                      }
                      malloc_type_id_t v44 = 4271087085;
                    }
                    else
                    {
                      double v58 = v57;
                      uint64_t v59 = (uint64_t)[sub_10005248C(v22, @"io_limit") longLongValue];
                      if (v59 < 0)
                      {
                        if (byte_1000EBCF8)
                        {
                          int v113 = *__error();
                          BOOL v114 = sub_10002E548();
                          if (os_log_type_enabled(v114, OS_LOG_TYPE_ERROR))
                          {
                            *(_DWORD *)buf = 134217984;
                            *(void *)&uint8_t buf[4] = v59;
                            _os_log_error_impl((void *)&_mh_execute_header, v114, OS_LOG_TYPE_ERROR, "deferred disk writes resource: bad io_limit_bytes (%lld)", buf, 0xCu);
                          }
                          *__error() = v113;
                        }
                        if (!byte_1000EBCF9 || dword_1000EB4A8 > 3) {
                          goto LABEL_279;
                        }
                        int v40 = *__error();
                        CFStringRef v115 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"deferred disk writes resource: bad io_limit_bytes (%lld)", v59);
                        if (!v115)
                        {
                          uint64_t v148 = sub_10002E548();
                          if (os_log_type_enabled(v148, OS_LOG_TYPE_FAULT))
                          {
                            *(_DWORD *)buf = 134217984;
                            *(void *)&uint8_t buf[4] = v59;
                            CFStringRef v105 = v148;
                            int v106 = "Unable to format: deferred disk writes resource: bad io_limit_bytes (%lld)";
                            goto LABEL_220;
                          }
                          goto LABEL_274;
                        }
                        CFStringRef v42 = v115;
                        id v43 = CFStringGetCStringPtr(v115, 0x8000100u);
                        if (v43) {
                          goto LABEL_67;
                        }
                        malloc_type_id_t v44 = 406402714;
                      }
                      else
                      {
                        [sub_10005248C(v22, @"duration_limit") doubleValue];
                        double v61 = v60;
                        if (v60 >= 0.0)
                        {
                          id v267 = sub_1000524F0(v22, @"pname");
                          id v117 = sub_1000524F0(v22, @"action");
                          if (v117)
                          {
                            int v118 = sub_10005705C((const char *)[v117 UTF8String]);
                            uint64_t v269 = +[NSString stringWithUTF8String:v118];
                            free(v118);
                          }
                          else
                          {
                            uint64_t v269 = 0;
                          }
                          if ((v52 & 0x80000000) != 0)
                          {
                            if (byte_1000EBCF8)
                            {
                              int v265 = *__error();
                              uint64_t v131 = sub_10002E548();
                              if (os_log_type_enabled(v131, OS_LOG_TYPE_INFO))
                              {
                                *(_WORD *)buf = 0;
                                _os_log_impl((void *)&_mh_execute_header, v131, OS_LOG_TYPE_INFO, "deferred disk writes resource: generating deferred report", buf, 2u);
                              }
                              *__error() = v265;
                            }
                            if (byte_1000EBCF9 && dword_1000EB4A8 <= 1)
                            {
                              int v264 = *__error();
                              CFStringRef v132 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"deferred disk writes resource: generating deferred report");
                              if (!v132)
                              {
                                mach_port_name_t v157 = sub_10002E548();
                                if (os_log_type_enabled(v157, OS_LOG_TYPE_FAULT)) {
                                  sub_10008EFD8(&v287, v288);
                                }
                                goto LABEL_299;
                              }
                              CFStringRef cf = v132;
                              CFStringRef v133 = CFStringGetCStringPtr(v132, 0x8000100u);
                              if (v133)
                              {
                                int v134 = (char *)v133;
                                id v260 = 0;
                              }
                              else
                              {
                                int v134 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x446032A7uLL);
                                CFStringGetCString(cf, v134, 1024, 0x8000100u);
                                id v260 = v134;
                              }
                              if (qword_1000EBD00) {
                                int v161 = (FILE *)qword_1000EBD00;
                              }
                              else {
                                int v161 = __stderrp;
                              }
                              fprintf(v161, "%s\n", v134);
                              mach_port_name_t v156 = v260;
                              if (v260) {
LABEL_295:
                              }
                                free(v156);
LABEL_296:
                              CFRelease(cf);
LABEL_303:
                              *__error() = v264;
                            }
                          }
                          else
                          {
                            if (byte_1000EBCF8)
                            {
                              int v263 = *__error();
                              double v124 = sub_10002E548();
                              if (os_log_type_enabled(v124, OS_LOG_TYPE_INFO))
                              {
                                double v125 = sub_10002E4E8(v52);
                                *(_DWORD *)buf = 136446466;
                                *(void *)&uint8_t buf[4] = v125;
                                __int16 v299 = 1024;
                                LODWORD(v300) = v52;
                                _os_log_impl((void *)&_mh_execute_header, v124, OS_LOG_TYPE_INFO, "%{public}s [%d]: deferred disk writes resource: generating deferred report", buf, 0x12u);
                              }
                              *__error() = v263;
                            }
                            if (byte_1000EBCF9 && dword_1000EB4A8 <= 1)
                            {
                              int v264 = *__error();
                              uint64_t v126 = sub_10002E4E8(v52);
                              CFStringRef v127 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%s [%d]: deferred disk writes resource: generating deferred report", v126, v52);
                              if (v127)
                              {
                                uint64_t v259 = v59;
                                CFStringRef v128 = v127;
                                CFStringRef v129 = CFStringGetCStringPtr(v127, 0x8000100u);
                                CFStringRef cf = v128;
                                if (v129)
                                {
                                  uint64_t v130 = (char *)v129;
                                  uint64_t v258 = 0;
                                }
                                else
                                {
                                  uint64_t v130 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x446032A7uLL);
                                  CFStringGetCString(v128, v130, 1024, 0x8000100u);
                                  uint64_t v258 = v130;
                                }
                                if (qword_1000EBD00) {
                                  int v155 = (FILE *)qword_1000EBD00;
                                }
                                else {
                                  int v155 = __stderrp;
                                }
                                fprintf(v155, "%s\n", v130);
                                mach_port_name_t v156 = v258;
                                uint64_t v59 = v259;
                                if (v258) {
                                  goto LABEL_295;
                                }
                                goto LABEL_296;
                              }
                              id v152 = sub_10002E548();
                              if (os_log_type_enabled(v152, OS_LOG_TYPE_FAULT))
                              {
                                __int16 v153 = sub_10002E4E8(v52);
                                *(_DWORD *)buf = 136315394;
                                *(void *)&uint8_t buf[4] = v153;
                                __int16 v299 = 1024;
                                LODWORD(v300) = v52;
                                _os_log_fault_impl((void *)&_mh_execute_header, v152, OS_LOG_TYPE_FAULT, "Unable to format: %s [%d]: deferred disk writes resource: generating deferred report", buf, 0x12u);
                              }
LABEL_299:
                              if (qword_1000EBD00) {
                                mach_port_name_t v158 = (FILE *)qword_1000EBD00;
                              }
                              else {
                                mach_port_name_t v158 = __stderrp;
                              }
                              fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v158);
                              goto LABEL_303;
                            }
                          }
                          sub_1000415CC(v52, v267, (uint64_t)v53, v269, (uint64_t)v54, v59, v56, v58, v61);
                          goto LABEL_279;
                        }
                        if (byte_1000EBCF8)
                        {
                          int v62 = *__error();
                          id v63 = sub_10002E548();
                          if (os_log_type_enabled(v63, OS_LOG_TYPE_ERROR))
                          {
                            *(_DWORD *)buf = 134217984;
                            *(double *)&uint8_t buf[4] = v61;
                            _os_log_error_impl((void *)&_mh_execute_header, v63, OS_LOG_TYPE_ERROR, "deferred disk writes resource: bad duration_limit (%f)", buf, 0xCu);
                          }
                          *__error() = v62;
                        }
                        if (!byte_1000EBCF9 || dword_1000EB4A8 > 3) {
                          goto LABEL_279;
                        }
                        int v40 = *__error();
                        CFStringRef v64 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"deferred disk writes resource: bad duration_limit (%f)", *(void *)&v61);
                        if (!v64)
                        {
                          int v149 = sub_10002E548();
                          if (os_log_type_enabled(v149, OS_LOG_TYPE_FAULT))
                          {
                            *(_DWORD *)buf = 134217984;
                            *(double *)&uint8_t buf[4] = v61;
                            CFStringRef v105 = v149;
                            int v106 = "Unable to format: deferred disk writes resource: bad duration_limit (%f)";
                            goto LABEL_220;
                          }
LABEL_274:
                          if (qword_1000EBD00) {
                            __int16 v151 = (FILE *)qword_1000EBD00;
                          }
                          else {
                            __int16 v151 = __stderrp;
                          }
                          fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v151);
                          goto LABEL_278;
                        }
                        CFStringRef v42 = v64;
                        id v43 = CFStringGetCStringPtr(v64, 0x8000100u);
                        if (v43) {
                          goto LABEL_67;
                        }
                        malloc_type_id_t v44 = 984245784;
                      }
                    }
                  }
                }
              }
              else
              {
                if (byte_1000EBCF8)
                {
                  int v76 = *__error();
                  int v77 = sub_10002E548();
                  if (os_log_type_enabled(v77, OS_LOG_TYPE_ERROR)) {
                    sub_10008EFAC(&v295, v296);
                  }
                  *__error() = v76;
                }
                if (!byte_1000EBCF9 || dword_1000EB4A8 > 3) {
                  goto LABEL_279;
                }
                int v40 = *__error();
                CFStringRef v78 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"deferred disk writes resource: no pid provided");
                if (!v78)
                {
                  CFStringRef v103 = sub_10002E548();
                  if (os_log_type_enabled(v103, OS_LOG_TYPE_FAULT)) {
                    sub_10008EF7C(&v293, v294);
                  }
                  goto LABEL_274;
                }
                CFStringRef v42 = v78;
                id v43 = CFStringGetCStringPtr(v78, 0x8000100u);
                if (v43) {
                  goto LABEL_67;
                }
                malloc_type_id_t v44 = 395052147;
              }
              goto LABEL_134;
            }
            if (v25 == (id)3)
            {
              id v26 = [[sub_10005248C(v22, @"pid") intValue];
              if (v26)
              {
                uint64_t v27 = (uint64_t)v26;
                id v28 = [sub_10005248C(v22, @"tid") unsignedLongLongValue];
                id v29 = [[sub_10005248C(v22, @"flags") unsignedLongLongValue];
                [sub_10005248C(v22, @"cpu") doubleValue];
                double v31 = v30;
                if (v30 <= 0.0)
                {
                  if (byte_1000EBCF8)
                  {
                    int v80 = *__error();
                    int v81 = sub_10002E548();
                    if (os_log_type_enabled(v81, OS_LOG_TYPE_ERROR))
                    {
                      *(_DWORD *)buf = 134217984;
                      *(double *)&uint8_t buf[4] = v31;
                      _os_log_error_impl((void *)&_mh_execute_header, v81, OS_LOG_TYPE_ERROR, "deferred cpu resource: bad cpu_used (%f)", buf, 0xCu);
                    }
                    *__error() = v80;
                  }
                  if (!byte_1000EBCF9 || dword_1000EB4A8 > 3) {
                    goto LABEL_279;
                  }
                  int v40 = *__error();
                  CFStringRef v82 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"deferred cpu resource: bad cpu_used (%f)", *(void *)&v31);
                  if (!v82)
                  {
                    CFStringRef v104 = sub_10002E548();
                    if (os_log_type_enabled(v104, OS_LOG_TYPE_FAULT))
                    {
                      *(_DWORD *)buf = 134217984;
                      *(double *)&uint8_t buf[4] = v31;
                      CFStringRef v105 = v104;
                      int v106 = "Unable to format: deferred cpu resource: bad cpu_used (%f)";
                      goto LABEL_220;
                    }
                    goto LABEL_274;
                  }
                  CFStringRef v42 = v82;
                  id v43 = CFStringGetCStringPtr(v82, 0x8000100u);
                  if (v43) {
                    goto LABEL_67;
                  }
                  malloc_type_id_t v44 = 4027693846;
                }
                else
                {
                  [sub_10005248C(v22, @"duration") doubleValue];
                  double v33 = v32;
                  if (v32 <= 0.0)
                  {
                    if (byte_1000EBCF8)
                    {
                      int v92 = *__error();
                      CFStringRef v93 = sub_10002E548();
                      if (os_log_type_enabled(v93, OS_LOG_TYPE_ERROR))
                      {
                        *(_DWORD *)buf = 134217984;
                        *(double *)&uint8_t buf[4] = v33;
                        _os_log_error_impl((void *)&_mh_execute_header, v93, OS_LOG_TYPE_ERROR, "deferred cpu resource: bad duration (%f)", buf, 0xCu);
                      }
                      *__error() = v92;
                    }
                    if (!byte_1000EBCF9 || dword_1000EB4A8 > 3) {
                      goto LABEL_279;
                    }
                    int v40 = *__error();
                    CFStringRef v94 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"deferred cpu resource: bad duration (%f)", *(void *)&v33);
                    if (!v94)
                    {
                      int v119 = sub_10002E548();
                      if (os_log_type_enabled(v119, OS_LOG_TYPE_FAULT))
                      {
                        *(_DWORD *)buf = 134217984;
                        *(double *)&uint8_t buf[4] = v33;
                        CFStringRef v105 = v119;
                        int v106 = "Unable to format: deferred cpu resource: bad duration (%f)";
                        goto LABEL_220;
                      }
                      goto LABEL_274;
                    }
                    CFStringRef v42 = v94;
                    id v43 = CFStringGetCStringPtr(v94, 0x8000100u);
                    if (v43) {
                      goto LABEL_67;
                    }
                    malloc_type_id_t v44 = 2044966629;
                  }
                  else
                  {
                    [sub_10005248C(v22, @"endtime") doubleValue];
                    if (v34 <= 0.0)
                    {
                      if (byte_1000EBCF8)
                      {
                        int v99 = *__error();
                        uint64_t v100 = sub_10002E548();
                        if (os_log_type_enabled(v100, OS_LOG_TYPE_ERROR)) {
                          sub_10008EF50(&v281, v282);
                        }
                        *__error() = v99;
                      }
                      if (!byte_1000EBCF9 || dword_1000EB4A8 > 3) {
                        goto LABEL_279;
                      }
                      int v40 = *__error();
                      CFStringRef v101 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"deferred cpu resource: no endtime provided");
                      if (!v101)
                      {
                        CFStringRef v123 = sub_10002E548();
                        if (os_log_type_enabled(v123, OS_LOG_TYPE_FAULT)) {
                          sub_10008EF20(&v279, v280);
                        }
                        goto LABEL_274;
                      }
                      CFStringRef v42 = v101;
                      id v43 = CFStringGetCStringPtr(v101, 0x8000100u);
                      if (v43) {
                        goto LABEL_67;
                      }
                      malloc_type_id_t v44 = 1943661059;
                    }
                    else
                    {
                      double v35 = v34;
                      [sub_10005248C(v22, @"cpu_limit") doubleValue];
                      double v37 = v36;
                      if (v36 < 0.0)
                      {
                        if (byte_1000EBCF8)
                        {
                          int v38 = *__error();
                          int v39 = sub_10002E548();
                          if (os_log_type_enabled(v39, OS_LOG_TYPE_ERROR))
                          {
                            *(_DWORD *)buf = 134217984;
                            *(double *)&uint8_t buf[4] = v37;
                            _os_log_error_impl((void *)&_mh_execute_header, v39, OS_LOG_TYPE_ERROR, "deferred cpu resource: bad cpu_used_limit (%f)", buf, 0xCu);
                          }
                          *__error() = v38;
                        }
                        if (!byte_1000EBCF9 || dword_1000EB4A8 > 3) {
                          goto LABEL_279;
                        }
                        int v40 = *__error();
                        CFStringRef v41 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"deferred cpu resource: bad cpu_used_limit (%f)", *(void *)&v37);
                        if (!v41)
                        {
                          __int16 v135 = sub_10002E548();
                          if (os_log_type_enabled(v135, OS_LOG_TYPE_FAULT))
                          {
                            *(_DWORD *)buf = 134217984;
                            *(double *)&uint8_t buf[4] = v37;
                            CFStringRef v105 = v135;
                            int v106 = "Unable to format: deferred cpu resource: bad cpu_used_limit (%f)";
                            goto LABEL_220;
                          }
                          goto LABEL_274;
                        }
                        CFStringRef v42 = v41;
                        id v43 = CFStringGetCStringPtr(v41, 0x8000100u);
                        if (!v43)
                        {
                          malloc_type_id_t v44 = 2429807285;
                          goto LABEL_134;
                        }
LABEL_67:
                        id v49 = (char *)v43;
                        malloc_type_id_t v50 = 0;
LABEL_135:
                        if (qword_1000EBD00) {
                          uint64_t v86 = (FILE *)qword_1000EBD00;
                        }
                        else {
                          uint64_t v86 = __stderrp;
                        }
                        fprintf(v86, "%s\n", v49);
                        if (v50) {
                          free(v50);
                        }
                        CFStringRef v87 = v42;
                        goto LABEL_168;
                      }
                      [sub_10005248C(v22, @"duration_limit") doubleValue];
                      double v109 = v108;
                      if (v108 >= 0.0)
                      {
                        id v270 = sub_1000524F0(v22, @"pname");
                        id v120 = sub_1000524F0(v22, @"action");
                        if (v120)
                        {
                          BOOL v121 = sub_10005705C((const char *)[v120 UTF8String]);
                          uint64_t v268 = +[NSString stringWithUTF8String:v121];
                          free(v121);
                        }
                        else
                        {
                          uint64_t v268 = 0;
                        }
                        if ((v27 & 0x80000000) != 0)
                        {
                          if (byte_1000EBCF8)
                          {
                            int v143 = *__error();
                            uint64_t v144 = sub_10002E548();
                            if (os_log_type_enabled(v144, OS_LOG_TYPE_INFO))
                            {
                              *(_WORD *)buf = 0;
                              _os_log_impl((void *)&_mh_execute_header, v144, OS_LOG_TYPE_INFO, "deferred cpu resource: generating deferred report", buf, 2u);
                            }
                            *__error() = v143;
                          }
                          if (byte_1000EBCF9 && dword_1000EB4A8 <= 1)
                          {
                            int v266 = *__error();
                            CFStringRef v140 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"deferred cpu resource: generating deferred report");
                            if (v140) {
                              goto LABEL_267;
                            }
                            double v159 = sub_10002E548();
                            if (os_log_type_enabled(v159, OS_LOG_TYPE_FAULT)) {
                              sub_10008EEF0(&v277, v278);
                            }
LABEL_307:
                            if (qword_1000EBD00) {
                              xpc_object_t v160 = (FILE *)qword_1000EBD00;
                            }
                            else {
                              xpc_object_t v160 = __stderrp;
                            }
                            fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v160);
LABEL_311:
                            *__error() = v266;
                          }
                        }
                        else
                        {
                          if (byte_1000EBCF8)
                          {
                            int v136 = *__error();
                            CFStringRef v137 = sub_10002E548();
                            if (os_log_type_enabled(v137, OS_LOG_TYPE_INFO))
                            {
                              id v138 = sub_10002E4E8(v27);
                              *(_DWORD *)buf = 136446466;
                              *(void *)&uint8_t buf[4] = v138;
                              __int16 v299 = 1024;
                              LODWORD(v300) = v27;
                              _os_log_impl((void *)&_mh_execute_header, v137, OS_LOG_TYPE_INFO, "%{public}s [%d]: deferred cpu resource: generating deferred report", buf, 0x12u);
                            }
                            *__error() = v136;
                          }
                          if (byte_1000EBCF9 && dword_1000EB4A8 <= 1)
                          {
                            int v266 = *__error();
                            uint64_t v139 = sub_10002E4E8(v27);
                            CFStringRef v140 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%s [%d]: deferred cpu resource: generating deferred report", v139, v27);
                            if (!v140)
                            {
                              uint64_t v141 = sub_10002E548();
                              if (os_log_type_enabled(v141, OS_LOG_TYPE_FAULT))
                              {
                                uint64_t v142 = sub_10002E4E8(v27);
                                *(_DWORD *)buf = 136315394;
                                *(void *)&uint8_t buf[4] = v142;
                                __int16 v299 = 1024;
                                LODWORD(v300) = v27;
                                _os_log_fault_impl((void *)&_mh_execute_header, v141, OS_LOG_TYPE_FAULT, "Unable to format: %s [%d]: deferred cpu resource: generating deferred report", buf, 0x12u);
                              }
                              goto LABEL_307;
                            }
LABEL_267:
                            CFStringRef v145 = v140;
                            uint64_t v146 = CFStringGetCStringPtr(v140, 0x8000100u);
                            if (v146)
                            {
                              uint64_t v147 = (char *)v146;
                              cfa = 0;
                            }
                            else
                            {
                              uint64_t v147 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x50C48E61uLL);
                              CFStringGetCString(v145, v147, 1024, 0x8000100u);
                              cfa = v147;
                            }
                            if (qword_1000EBD00) {
                              uint64_t v154 = (FILE *)qword_1000EBD00;
                            }
                            else {
                              uint64_t v154 = __stderrp;
                            }
                            fprintf(v154, "%s\n", v147);
                            if (cfa) {
                              free(cfa);
                            }
                            CFRelease(v145);
                            goto LABEL_311;
                          }
                        }
                        sub_10003FC18(v27, v270, (uint64_t)v28, (uint64_t)v29, v268, v31, v33, v35, v37, v109);
                        goto LABEL_279;
                      }
                      if (byte_1000EBCF8)
                      {
                        int v110 = *__error();
                        uint64_t v111 = sub_10002E548();
                        if (os_log_type_enabled(v111, OS_LOG_TYPE_ERROR))
                        {
                          *(_DWORD *)buf = 134217984;
                          *(double *)&uint8_t buf[4] = v109;
                          _os_log_error_impl((void *)&_mh_execute_header, v111, OS_LOG_TYPE_ERROR, "deferred cpu resource: bad duration_limit (%f)", buf, 0xCu);
                        }
                        *__error() = v110;
                      }
                      if (!byte_1000EBCF9 || dword_1000EB4A8 > 3) {
                        goto LABEL_279;
                      }
                      int v40 = *__error();
                      CFStringRef v112 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"deferred cpu resource: bad duration_limit (%f)", *(void *)&v109);
                      if (!v112)
                      {
                        CFStringRef v150 = sub_10002E548();
                        if (os_log_type_enabled(v150, OS_LOG_TYPE_FAULT))
                        {
                          *(_DWORD *)buf = 134217984;
                          *(double *)&uint8_t buf[4] = v109;
                          CFStringRef v105 = v150;
                          int v106 = "Unable to format: deferred cpu resource: bad duration_limit (%f)";
LABEL_220:
                          _os_log_fault_impl((void *)&_mh_execute_header, v105, OS_LOG_TYPE_FAULT, v106, buf, 0xCu);
                        }
                        goto LABEL_274;
                      }
                      CFStringRef v42 = v112;
                      id v43 = CFStringGetCStringPtr(v112, 0x8000100u);
                      if (v43) {
                        goto LABEL_67;
                      }
                      malloc_type_id_t v44 = 2641072546;
                    }
                  }
                }
              }
              else
              {
                if (byte_1000EBCF8)
                {
                  int v73 = *__error();
                  id v74 = sub_10002E548();
                  if (os_log_type_enabled(v74, OS_LOG_TYPE_ERROR)) {
                    sub_10008EEC4(&v285, v286);
                  }
                  *__error() = v73;
                }
                if (!byte_1000EBCF9 || dword_1000EB4A8 > 3) {
                  goto LABEL_279;
                }
                int v40 = *__error();
                CFStringRef v75 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"deferred cpu resource: no pid provided");
                if (!v75)
                {
                  int v102 = sub_10002E548();
                  if (os_log_type_enabled(v102, OS_LOG_TYPE_FAULT)) {
                    sub_10008EE94(&v283, v284);
                  }
                  goto LABEL_274;
                }
                CFStringRef v42 = v75;
                id v43 = CFStringGetCStringPtr(v75, 0x8000100u);
                if (v43) {
                  goto LABEL_67;
                }
                malloc_type_id_t v44 = 1292592631;
              }
LABEL_134:
              id v49 = (char *)malloc_type_calloc(0x400uLL, 1uLL, v44);
              CFStringGetCString(v42, v49, 1024, 0x8000100u);
              malloc_type_id_t v50 = v49;
              goto LABEL_135;
            }
            if (byte_1000EBCF8)
            {
              int v65 = *__error();
              int v66 = sub_10002E548();
              if (os_log_type_enabled(v66, OS_LOG_TYPE_ERROR)) {
                sub_10008EE38((uint64_t)&v301, v24);
              }
              *__error() = v65;
            }
            if (byte_1000EBCF9) {
              BOOL v67 = dword_1000EB4A8 <= 3;
            }
            else {
              BOOL v67 = 0;
            }
            if (!v67) {
              goto LABEL_279;
            }
            int v40 = *__error();
            CFStringRef v68 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"Unhandled deferred report type %llu", [v24 longLongValue]);
            if (!v68)
            {
              CFStringRef v91 = sub_10002E548();
              if (os_log_type_enabled(v91, OS_LOG_TYPE_FAULT)) {
                sub_10008EDDC((uint64_t)v297, v24);
              }
              goto LABEL_274;
            }
            CFStringRef v69 = v68;
            malloc_type_id_t v70 = CFStringGetCStringPtr(v68, 0x8000100u);
            if (v70)
            {
              int v71 = (char *)v70;
              id v72 = 0;
            }
            else
            {
              int v71 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x713FB94BuLL);
              CFStringGetCString(v69, v71, 1024, 0x8000100u);
              id v72 = v71;
            }
            if (qword_1000EBD00) {
              uint64_t v95 = (FILE *)qword_1000EBD00;
            }
            else {
              uint64_t v95 = __stderrp;
            }
            fprintf(v95, "%s\n", v71);
            if (v72) {
              free(v72);
            }
            CFStringRef v87 = v69;
LABEL_168:
            CFRelease(v87);
LABEL_278:
            *__error() = v40;
LABEL_279:
            if (++v21 >= [(NSArray *)v16 count]) {
              goto LABEL_356;
            }
          }
          if (byte_1000EBCF8)
          {
            int v45 = *__error();
            uint64_t v46 = sub_10002E548();
            if (os_log_type_enabled(v46, OS_LOG_TYPE_ERROR)) {
              sub_10008EDB0(&v274, v275);
            }
            *__error() = v45;
          }
          if (byte_1000EBCF9) {
            BOOL v47 = dword_1000EB4A8 <= 3;
          }
          else {
            BOOL v47 = 0;
          }
          if (!v47) {
            goto LABEL_279;
          }
          int v40 = *__error();
          CFStringRef v48 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"Bad deferred report type value type");
          if (!v48)
          {
            CFStringRef v79 = sub_10002E548();
            if (os_log_type_enabled(v79, OS_LOG_TYPE_FAULT)) {
              sub_10008ED80(&v272, v273);
            }
            goto LABEL_274;
          }
          CFStringRef v42 = v48;
          id v43 = CFStringGetCStringPtr(v48, 0x8000100u);
          if (v43) {
            goto LABEL_67;
          }
          malloc_type_id_t v44 = 3044858836;
          goto LABEL_134;
        }
LABEL_356:
        if (v21 < [(NSArray *)v16 count])
        {
          if (byte_1000EBCF8)
          {
            int v190 = *__error();
            int v191 = sub_10002E548();
            if (os_log_type_enabled(v191, OS_LOG_TYPE_DEFAULT))
            {
              int v192 = [(NSArray *)v16 count];
              *(_DWORD *)buf = 134218240;
              *(void *)&uint8_t buf[4] = &v192[-v21];
              __int16 v299 = 2048;
              unint64_t v300 = v21;
              _os_log_impl((void *)&_mh_execute_header, v191, OS_LOG_TYPE_DEFAULT, "Task expired with %lu remaining deferred reports (generated %lu)", buf, 0x16u);
            }
            *__error() = v190;
          }
          if (byte_1000EBCF9) {
            BOOL v193 = dword_1000EB4A8 <= 2;
          }
          else {
            BOOL v193 = 0;
          }
          if (v193)
          {
            int v194 = *__error();
            CFStringRef v195 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"Task expired with %lu remaining deferred reports (generated %lu)", (char *)[(NSArray *)v16 count] - v21, v21);
            if (v195)
            {
              CFStringRef v196 = v195;
              int64_t v197 = CFStringGetCStringPtr(v195, 0x8000100u);
              if (v197)
              {
                xpc_object_t v198 = (char *)v197;
                id v199 = 0;
              }
              else
              {
                xpc_object_t v198 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x7474524CuLL);
                CFStringGetCString(v196, v198, 1024, 0x8000100u);
                id v199 = v198;
              }
              if (qword_1000EBD00) {
                CFStringRef v231 = (FILE *)qword_1000EBD00;
              }
              else {
                CFStringRef v231 = __stderrp;
              }
              fprintf(v231, "%s\n", v198);
              if (v199) {
                free(v199);
              }
              CFRelease(v196);
            }
            else
            {
              int v227 = sub_10002E548();
              if (os_log_type_enabled(v227, OS_LOG_TYPE_FAULT)) {
                sub_10008EC7C();
              }
              if (qword_1000EBD00) {
                int v228 = (FILE *)qword_1000EBD00;
              }
              else {
                int v228 = __stderrp;
              }
              fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v228);
            }
            *__error() = v194;
          }
          if (!v21) {
            return 0;
          }
          int v232 = -[NSArray subarrayWithRange:](v16, "subarrayWithRange:", v21, (char *)[(NSArray *)v16 count] - v21);
          *(void *)buf = 0;
          if ([(NSArray *)v232 writeToURL:v14 error:buf]) {
            return 0;
          }
          int v234 = *__error();
          xpc_object_t v235 = sub_10002E548();
          if (os_log_type_enabled(v235, OS_LOG_TYPE_FAULT)) {
            sub_10008EC00();
          }
          *__error() = v234;
          uint64_t v236 = &AnalyticsIsEventUsed_ptr;
          if (byte_1000EBCF9 && dword_1000EB4A8 <= 4)
          {
            int v237 = *__error();
            id v238 = [(NSArray *)v232 count];
            CFStringRef v239 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"Unable to write %lu remaining deferred reports to plist: %@", v238, *(void *)buf);
            if (v239)
            {
              CFStringRef v240 = v239;
              CFStringRef v241 = CFStringGetCStringPtr(v239, 0x8000100u);
              if (v241)
              {
                uint64_t v242 = (char *)v241;
                uint64_t v243 = 0;
              }
              else
              {
                uint64_t v242 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x3B6DB5E1uLL);
                CFStringGetCString(v240, v242, 1024, 0x8000100u);
                uint64_t v243 = v242;
              }
              if (qword_1000EBD00) {
                int v250 = (FILE *)qword_1000EBD00;
              }
              else {
                int v250 = __stderrp;
              }
              fprintf(v250, "%s\n", v242);
              if (v243) {
                free(v243);
              }
              CFRelease(v240);
              uint64_t v236 = &AnalyticsIsEventUsed_ptr;
            }
            else
            {
              uint64_t v248 = sub_10002E548();
              if (os_log_type_enabled(v248, OS_LOG_TYPE_FAULT)) {
                sub_10008EB84();
              }
              if (qword_1000EBD00) {
                BOOL v249 = (FILE *)qword_1000EBD00;
              }
              else {
                BOOL v249 = __stderrp;
              }
              fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v249);
            }
            *__error() = v237;
          }
          uint64_t v271 = 0;
          if ([objc_msgSend(objc_msgSend(v236[301], "defaultManager"), "removeItemAtURL:error:", v14, &v271])return 1; {
          int v253 = *__error();
          }
          uint64_t v254 = sub_10002E548();
          if (os_log_type_enabled(v254, OS_LOG_TYPE_FAULT)) {
            sub_10008E7A8();
          }
          *__error() = v253;
          if (!byte_1000EBCF9 || dword_1000EB4A8 > 4) {
            return 1;
          }
          int v165 = *__error();
          CFStringRef v255 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"Unable to remove deferred reports plist: %@", v271);
          if (v255)
          {
            CFStringRef v167 = v255;
            CFStringRef v168 = CFStringGetCStringPtr(v255, 0x8000100u);
            if (v168) {
              goto LABEL_331;
            }
            malloc_type_id_t v213 = 2875848191;
            goto LABEL_388;
          }
          uint64_t v257 = sub_10002E548();
          if (os_log_type_enabled(v257, OS_LOG_TYPE_FAULT)) {
            sub_10008E740();
          }
LABEL_371:
          if (qword_1000EBD00) {
            CFStringRef v201 = (FILE *)qword_1000EBD00;
          }
          else {
            CFStringRef v201 = __stderrp;
          }
          fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v201);
          goto LABEL_395;
        }
        if (byte_1000EBCF8)
        {
          int v202 = *__error();
          uint64_t v203 = sub_10002E548();
          if (os_log_type_enabled(v203, OS_LOG_TYPE_DEFAULT))
          {
            NSUInteger v204 = [(NSArray *)v16 count];
            *(_DWORD *)buf = 134217984;
            *(void *)&uint8_t buf[4] = v204;
            _os_log_impl((void *)&_mh_execute_header, v203, OS_LOG_TYPE_DEFAULT, "Generated %lu deferred reports", buf, 0xCu);
          }
          *__error() = v202;
        }
        if (byte_1000EBCF9) {
          BOOL v205 = dword_1000EB4A8 <= 2;
        }
        else {
          BOOL v205 = 0;
        }
        uint64_t v206 = &AnalyticsIsEventUsed_ptr;
        if (v205)
        {
          int v207 = *__error();
          CFStringRef v208 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"Generated %lu deferred reports", [(NSArray *)v16 count]);
          if (v208)
          {
            CFStringRef v209 = v208;
            id v210 = CFStringGetCStringPtr(v208, 0x8000100u);
            if (v210)
            {
              double v211 = (char *)v210;
              int v212 = 0;
            }
            else
            {
              double v211 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x77E7693FuLL);
              CFStringGetCString(v209, v211, 1024, 0x8000100u);
              int v212 = v211;
            }
            if (qword_1000EBD00) {
              uint64_t v244 = (FILE *)qword_1000EBD00;
            }
            else {
              uint64_t v244 = __stderrp;
            }
            fprintf(v244, "%s\n", v211);
            if (v212) {
              free(v212);
            }
            CFRelease(v209);
            uint64_t v206 = &AnalyticsIsEventUsed_ptr;
          }
          else
          {
            CFStringRef v229 = sub_10002E548();
            if (os_log_type_enabled(v229, OS_LOG_TYPE_FAULT)) {
              sub_10008ED04(v16);
            }
            if (qword_1000EBD00) {
              CFStringRef v230 = (FILE *)qword_1000EBD00;
            }
            else {
              CFStringRef v230 = __stderrp;
            }
            fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v230);
          }
          *__error() = v207;
        }
        *(void *)buf = 0;
        if (objc_msgSend(objc_msgSend(v206[301], "defaultManager"), "removeItemAtURL:error:", v14, buf)) {
          return 1;
        }
        int v245 = *__error();
        uint64_t v246 = sub_10002E548();
        if (os_log_type_enabled(v246, OS_LOG_TYPE_FAULT)) {
          sub_10008E7A8();
        }
        *__error() = v245;
        if (!byte_1000EBCF9 || dword_1000EB4A8 > 4) {
          return 1;
        }
        int v165 = *__error();
        CFStringRef v247 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"Unable to remove deferred reports plist: %@", *(void *)buf);
        if (!v247)
        {
          uint64_t v256 = sub_10002E548();
          if (os_log_type_enabled(v256, OS_LOG_TYPE_FAULT)) {
            sub_10008E740();
          }
          goto LABEL_371;
        }
        CFStringRef v167 = v247;
        CFStringRef v168 = CFStringGetCStringPtr(v247, 0x8000100u);
        if (v168) {
          goto LABEL_331;
        }
        malloc_type_id_t v213 = 1690975433;
LABEL_388:
        int v169 = (char *)malloc_type_calloc(0x400uLL, 1uLL, v213);
        CFStringGetCString(v167, v169, 1024, 0x8000100u);
        uint64_t v170 = v169;
        goto LABEL_389;
      }
      goto LABEL_31;
    }
  }
  unsigned int v171 = &AnalyticsIsEventUsed_ptr;
  if (byte_1000EBCF8)
  {
    int v172 = *__error();
    id v173 = sub_10002E548();
    if (os_log_type_enabled(v173, OS_LOG_TYPE_ERROR)) {
      sub_10008F098();
    }
    *__error() = v172;
  }
  if (byte_1000EBCF9) {
    BOOL v174 = dword_1000EB4A8 <= 3;
  }
  else {
    BOOL v174 = 0;
  }
  if (v174)
  {
    int v175 = *__error();
    CFStringRef v176 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"Invalid deferred reports plist");
    if (v176)
    {
      CFStringRef v177 = v176;
      int v178 = CFStringGetCStringPtr(v176, 0x8000100u);
      if (v178)
      {
        id v179 = (char *)v178;
        CFStringRef v180 = 0;
      }
      else
      {
        id v179 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x6638AFB2uLL);
        CFStringGetCString(v177, v179, 1024, 0x8000100u);
        CFStringRef v180 = v179;
      }
      if (qword_1000EBD00) {
        uint64_t v219 = (FILE *)qword_1000EBD00;
      }
      else {
        uint64_t v219 = __stderrp;
      }
      fprintf(v219, "%s\n", v179);
      if (v180) {
        free(v180);
      }
      CFRelease(v177);
      unsigned int v171 = &AnalyticsIsEventUsed_ptr;
    }
    else
    {
      double v215 = sub_10002E548();
      if (os_log_type_enabled(v215, OS_LOG_TYPE_FAULT)) {
        sub_10008F064();
      }
      if (qword_1000EBD00) {
        xpc_object_t v216 = (FILE *)qword_1000EBD00;
      }
      else {
        xpc_object_t v216 = __stderrp;
      }
      fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v216);
    }
    *__error() = v175;
  }
  *(void *)buf = 0;
  if (objc_msgSend(objc_msgSend(v171[301], "defaultManager"), "removeItemAtURL:error:", v14, buf)) {
    return 1;
  }
  int v220 = *__error();
  uint64_t v221 = sub_10002E548();
  if (os_log_type_enabled(v221, OS_LOG_TYPE_FAULT)) {
    sub_10008E7A8();
  }
  *__error() = v220;
  if (!byte_1000EBCF9 || dword_1000EB4A8 > 4) {
    return 1;
  }
  int v165 = *__error();
  CFStringRef v222 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"Unable to remove deferred reports plist: %@", *(void *)buf);
  if (!v222)
  {
    CFStringRef v251 = sub_10002E548();
    if (!os_log_type_enabled(v251, OS_LOG_TYPE_FAULT)) {
      goto LABEL_371;
    }
    goto LABEL_503;
  }
  CFStringRef v167 = v222;
  CFStringRef v168 = CFStringGetCStringPtr(v222, 0x8000100u);
  if (!v168)
  {
    malloc_type_id_t v213 = 1724433624;
    goto LABEL_388;
  }
LABEL_331:
  int v169 = (char *)v168;
  uint64_t v170 = 0;
LABEL_389:
  if (qword_1000EBD00) {
    CFStringRef v214 = (FILE *)qword_1000EBD00;
  }
  else {
    CFStringRef v214 = __stderrp;
  }
  fprintf(v214, "%s\n", v169);
  if (v170) {
    free(v170);
  }
  CFRelease(v167);
LABEL_395:
  *__error() = v165;
  return 1;
}

id sub_10005248C(void *a1, uint64_t a2)
{
  objc_opt_class();
  id v4 = [a1 objectForKeyedSubscript:a2];
  if (!v4) {
    return 0;
  }
  id v5 = v4;
  if ((objc_opt_isKindOfClass() & 1) == 0) {
    return 0;
  }
  return v5;
}

id sub_1000524F0(void *a1, uint64_t a2)
{
  objc_opt_class();
  id v4 = [a1 objectForKeyedSubscript:a2];
  if (!v4) {
    return 0;
  }
  id v5 = v4;
  if ((objc_opt_isKindOfClass() & 1) == 0) {
    return 0;
  }
  return v5;
}

unsigned char *sub_100052554(unsigned char *result, unsigned char *a2)
{
  int *result = 0;
  *a2 = 0;
  return result;
}

void sub_100052564(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint8_t *a5)
{
  _os_log_fault_impl(a1, a2, OS_LOG_TYPE_FAULT, a4, a5, 2u);
}

void sub_100052594(void *a1, int a2, os_log_t log, const char *a4, uint8_t *a5)
{
  _os_log_error_impl(a1, log, OS_LOG_TYPE_ERROR, a4, a5, 2u);
}

id sub_1000525BC(uint64_t a1, void *a2)
{
  return [a2 longLongValue];
}

void sub_1000525DC(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, int a8, uint64_t a9)
{
  uint64_t v17 = sub_10002E390("Resource exhaustion for [%d]", a2);
  dispatch_queue_global_t global_queue = dispatch_get_global_queue(25, 0);
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_1000526C4;
  block[3] = &unk_1000DD550;
  int v20 = a2;
  int v21 = a8;
  block[8] = a1;
  block[9] = a4;
  block[4] = v17;
  void block[5] = a3;
  void block[6] = a5;
  block[7] = a9;
  block[10] = a6;
  block[11] = a7;
  dispatch_async(global_queue, block);
}

void sub_1000526C4(uint64_t a1)
{
  sub_10005E318();
  time_t v2 = time(0);
  id v3 = +[NSMutableString string];
  id v4 = (unsigned int *)(a1 + 96);
  snprintf(__str, 8uLL, "%d", *(_DWORD *)(a1 + 96));
  if ((unint64_t)(*(void *)(a1 + 64) - 1) <= 1)
  {
    [v3 appendFormat:@"ddt %d\n", *v4];
    *(void *)int v218 = "/usr/local/bin/ddt";
    *(void *)&v218[8] = __str;
    *(void *)&v218[16] = 0;
    int v217 = -1;
    uint64_t v198 = 0;
    LOBYTE(v197) = 0;
    uint64_t v195 = 0;
    pid_t v5 = SASpawnPlatformBinaryWithSigningIdentifier();
    if ((v5 & 0x80000000) == 0)
    {
      pid_t v6 = v5;
      CFStringRef v7 = malloc_type_calloc(0x20uLL, 0x400uLL, 0x34CD9B87uLL);
      ssize_t v8 = read(v217, v7, vm_page_size - 1);
      if (v8 >= 1)
      {
        ssize_t v9 = v8;
        pid_t v201 = v6;
        time_t v203 = v2;
        uint64_t v205 = a1;
        char v10 = 0;
        do
        {
          *((unsigned char *)v7 + v9) = 0;
          id v11 = [objc_alloc((Class)NSString) initWithBytesNoCopy:v7 length:v9 encoding:4 freeWhenDone:0];
          if (v11)
          {
            BOOL v12 = v11;
            [v3 appendString:v11];

            char v10 = 1;
          }
          else if ((*v4 & 0x80000000) != 0)
          {
            if (byte_1000EBCF8)
            {
              int v24 = *__error();
              id v25 = sub_10002E548();
              if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
              {
                *(_DWORD *)buf = 136315138;
                *(void *)&uint8_t buf[4] = v7;
                _os_log_error_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_ERROR, "Unable to convert ddt output to NSString: %s", buf, 0xCu);
              }
              *__error() = v24;
            }
            if (byte_1000EBCF9) {
              BOOL v26 = dword_1000EB4A8 <= 3;
            }
            else {
              BOOL v26 = 0;
            }
            if (v26)
            {
              int v27 = *__error();
              CFStringRef v28 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"Unable to convert ddt output to NSString: %s", v7, v197, v198);
              if (v28)
              {
                CFStringRef v29 = v28;
                id v30 = v3;
                CStringPtr = CFStringGetCStringPtr(v28, 0x8000100u);
                if (CStringPtr)
                {
                  double v32 = (char *)CStringPtr;
                  double v33 = 0;
                }
                else
                {
                  double v32 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x38C52AAuLL);
                  CFStringGetCString(v29, v32, 1024, 0x8000100u);
                  double v33 = v32;
                }
                if (qword_1000EBD00) {
                  int v39 = (FILE *)qword_1000EBD00;
                }
                else {
                  int v39 = __stderrp;
                }
                fprintf(v39, "%s\n", v32);
                if (v33) {
                  free(v33);
                }
                CFRelease(v29);
                id v3 = v30;
              }
              else
              {
                double v37 = sub_10002E548();
                if (os_log_type_enabled(v37, OS_LOG_TYPE_FAULT))
                {
                  *(_DWORD *)buf = 136315138;
                  *(void *)&uint8_t buf[4] = v7;
                  _os_log_fault_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_FAULT, "Unable to format: Unable to convert ddt output to NSString: %s", buf, 0xCu);
                }
                if (qword_1000EBD00) {
                  int v38 = (FILE *)qword_1000EBD00;
                }
                else {
                  int v38 = __stderrp;
                }
                fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v38);
              }
              *__error() = v27;
            }
          }
          else
          {
            if (byte_1000EBCF8)
            {
              int v13 = *__error();
              uint64_t v14 = sub_10002E548();
              if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
              {
                int v40 = sub_10002E4E8(*v4);
                int v41 = *v4;
                *(_DWORD *)buf = 136446722;
                *(void *)&uint8_t buf[4] = v40;
                *(_WORD *)&unsigned char buf[12] = 1024;
                *(_DWORD *)&buf[14] = v41;
                *(_WORD *)&buf[18] = 2080;
                *(void *)&buf[20] = v7;
                _os_log_error_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, "%{public}s [%d]: Unable to convert ddt output to NSString: %s", buf, 0x1Cu);
              }
              *__error() = v13;
            }
            if (byte_1000EBCF9) {
              BOOL v15 = dword_1000EB4A8 <= 3;
            }
            else {
              BOOL v15 = 0;
            }
            if (v15)
            {
              int v16 = *__error();
              uint64_t v17 = sub_10002E4E8(*v4);
              CFStringRef v18 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%s [%d]: Unable to convert ddt output to NSString: %s", v17, *v4, v7);
              if (v18)
              {
                CFStringRef v19 = v18;
                id v20 = v3;
                int v21 = CFStringGetCStringPtr(v18, 0x8000100u);
                if (v21)
                {
                  id v22 = (char *)v21;
                  id v23 = 0;
                }
                else
                {
                  id v22 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x38C52AAuLL);
                  CFStringGetCString(v19, v22, 1024, 0x8000100u);
                  id v23 = v22;
                }
                if (qword_1000EBD00) {
                  double v36 = (FILE *)qword_1000EBD00;
                }
                else {
                  double v36 = __stderrp;
                }
                fprintf(v36, "%s\n", v22);
                if (v23) {
                  free(v23);
                }
                CFRelease(v19);
                id v3 = v20;
              }
              else
              {
                double v34 = sub_10002E548();
                if (os_log_type_enabled(v34, OS_LOG_TYPE_FAULT))
                {
                  CFStringRef v42 = sub_10002E4E8(*v4);
                  int v43 = *v4;
                  *(_DWORD *)buf = 136315650;
                  *(void *)&uint8_t buf[4] = v42;
                  *(_WORD *)&unsigned char buf[12] = 1024;
                  *(_DWORD *)&buf[14] = v43;
                  *(_WORD *)&buf[18] = 2080;
                  *(void *)&buf[20] = v7;
                  _os_log_fault_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_FAULT, "Unable to format: %s [%d]: Unable to convert ddt output to NSString: %s", buf, 0x1Cu);
                }
                if (qword_1000EBD00) {
                  double v35 = (FILE *)qword_1000EBD00;
                }
                else {
                  double v35 = __stderrp;
                }
                fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v35);
              }
              *__error() = v16;
            }
          }
          ssize_t v9 = read(v217, v7, vm_page_size - 1);
        }
        while (v9 > 0);
        waitpid(v201, 0, 0);
        free(v7);
        [v3 appendFormat:@"\n", v195];
        a1 = v205;
        if (v10)
        {
          time_t v2 = v203;
          goto LABEL_64;
        }
LABEL_190:
        BOOL v133 = sub_1000240E8(*v4);
        int v134 = *v4;
        if (v133)
        {
          if ((v134 & 0x80000000) == 0)
          {
            if (byte_1000EBCF8)
            {
              int v135 = *__error();
              int v136 = sub_10002E548();
              if (os_log_type_enabled(v136, OS_LOG_TYPE_ERROR)) {
                sub_10008F1B8();
              }
              *__error() = v135;
            }
            if (!byte_1000EBCF9 || dword_1000EB4A8 > 3) {
              goto LABEL_321;
            }
            int v137 = *__error();
            id v138 = sub_10002E4E8(*v4);
            CFStringRef v139 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%s [%d]: Unable to gather ddt for resource exhaustion report, though process is alive", v138, *v4);
            if (!v139)
            {
              mach_port_name_t v156 = sub_10002E548();
              if (os_log_type_enabled(v156, OS_LOG_TYPE_FAULT)) {
                sub_10008F140();
              }
              goto LABEL_307;
            }
            CFStringRef v140 = v139;
            uint64_t v141 = CFStringGetCStringPtr(v139, 0x8000100u);
            if (v141) {
              goto LABEL_272;
            }
            malloc_type_id_t v142 = 4172334830;
LABEL_296:
            BOOL v174 = (char *)malloc_type_calloc(0x400uLL, 1uLL, v142);
            CFStringGetCString(v140, v174, 1024, 0x8000100u);
            int v175 = v174;
            goto LABEL_297;
          }
          if (byte_1000EBCF8)
          {
            int v147 = *__error();
            uint64_t v148 = sub_10002E548();
            if (os_log_type_enabled(v148, OS_LOG_TYPE_ERROR)) {
              sub_10008F264();
            }
            *__error() = v147;
          }
          if (!byte_1000EBCF9 || dword_1000EB4A8 > 3) {
            goto LABEL_321;
          }
          int v137 = *__error();
          CFStringRef v149 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"Unable to gather ddt for resource exhaustion report, though process is alive");
          if (!v149)
          {
            mach_port_name_t v158 = sub_10002E548();
            if (os_log_type_enabled(v158, OS_LOG_TYPE_FAULT)) {
              sub_10008F230();
            }
            goto LABEL_307;
          }
          CFStringRef v150 = v149;
          __int16 v151 = CFStringGetCStringPtr(v149, 0x8000100u);
          if (v151) {
            goto LABEL_290;
          }
          malloc_type_id_t v152 = 4172334830;
        }
        else
        {
          if ((v134 & 0x80000000) == 0)
          {
            if (byte_1000EBCF8)
            {
              int v143 = *__error();
              uint64_t v144 = sub_10002E548();
              if (os_log_type_enabled(v144, OS_LOG_TYPE_ERROR)) {
                sub_10008F310();
              }
              *__error() = v143;
            }
            if (!byte_1000EBCF9 || dword_1000EB4A8 > 3) {
              goto LABEL_321;
            }
            int v137 = *__error();
            CFStringRef v145 = sub_10002E4E8(*v4);
            CFStringRef v146 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%s [%d]: Unable to gather ddt for resource exhaustion report; process is no longer around",
                     v145,
                     *v4);
            if (!v146)
            {
              mach_port_name_t v157 = sub_10002E548();
              if (os_log_type_enabled(v157, OS_LOG_TYPE_FAULT)) {
                sub_10008F298();
              }
              goto LABEL_307;
            }
            CFStringRef v140 = v146;
            uint64_t v141 = CFStringGetCStringPtr(v146, 0x8000100u);
            if (v141) {
              goto LABEL_272;
            }
            malloc_type_id_t v142 = 3600909264;
            goto LABEL_296;
          }
          if (byte_1000EBCF8)
          {
            int v153 = *__error();
            uint64_t v154 = sub_10002E548();
            if (os_log_type_enabled(v154, OS_LOG_TYPE_ERROR)) {
              sub_10008F3BC();
            }
            *__error() = v153;
          }
          if (!byte_1000EBCF9 || dword_1000EB4A8 > 3) {
            goto LABEL_321;
          }
          int v137 = *__error();
          CFStringRef v155 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"Unable to gather ddt for resource exhaustion report; process is no longer around");
          if (!v155)
          {
            double v159 = sub_10002E548();
            if (os_log_type_enabled(v159, OS_LOG_TYPE_FAULT)) {
              sub_10008F388();
            }
            goto LABEL_307;
          }
          CFStringRef v150 = v155;
          __int16 v151 = CFStringGetCStringPtr(v155, 0x8000100u);
          if (v151) {
            goto LABEL_290;
          }
          malloc_type_id_t v152 = 3600909264;
        }
LABEL_312:
        CFStringRef v182 = (char *)malloc_type_calloc(0x400uLL, 1uLL, v152);
        CFStringGetCString(v150, v182, 1024, 0x8000100u);
        BOOL v183 = v182;
        goto LABEL_313;
      }
      waitpid(v6, 0, 0);
      free(v7);
      CFStringRef v94 = @"\n";
LABEL_189:
      [v3 appendFormat:v94, v195, v197];
      goto LABEL_190;
    }
    if ((*v4 & 0x80000000) != 0)
    {
      if (byte_1000EBCF8)
      {
        int v110 = *__error();
        uint64_t v111 = sub_10002E548();
        if (os_log_type_enabled(v111, OS_LOG_TYPE_ERROR)) {
          sub_10008F598();
        }
        *__error() = v110;
      }
      if (!byte_1000EBCF9 || dword_1000EB4A8 > 3) {
        goto LABEL_188;
      }
      int v86 = *__error();
      uint64_t v112 = *__error();
      int v113 = __error();
      BOOL v114 = strerror(*v113);
      CFStringRef v92 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"Unable to spawn ddt: %d (%s)", v112, v114, 0);
      if (!v92)
      {
        CFStringRef v129 = sub_10002E548();
        if (os_log_type_enabled(v129, OS_LOG_TYPE_FAULT)) {
          sub_10008F510();
        }
        goto LABEL_183;
      }
    }
    else
    {
      if (byte_1000EBCF8)
      {
        int v84 = *__error();
        CFStringRef v85 = sub_10002E548();
        if (os_log_type_enabled(v85, OS_LOG_TYPE_ERROR)) {
          sub_10008F480();
        }
        *__error() = v84;
      }
      if (!byte_1000EBCF9 || dword_1000EB4A8 > 3) {
        goto LABEL_188;
      }
      int v86 = *__error();
      CFStringRef v87 = sub_10002E4E8(*v4);
      uint64_t v88 = *v4;
      uint64_t v89 = *__error();
      CFStringRef v90 = __error();
      CFStringRef v91 = strerror(*v90);
      CFStringRef v92 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%s [%d]: Unable to spawn ddt: %d (%s)", v87, v88, v89, v91);
      if (!v92)
      {
        CFStringRef v93 = sub_10002E548();
        if (os_log_type_enabled(v93, OS_LOG_TYPE_FAULT)) {
          sub_10008F3F0();
        }
LABEL_183:
        if (qword_1000EBD00) {
          uint64_t v130 = (FILE *)qword_1000EBD00;
        }
        else {
          uint64_t v130 = __stderrp;
        }
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v130);
LABEL_187:
        *__error() = v86;
LABEL_188:
        uint64_t v131 = *__error();
        CFStringRef v132 = __error();
        uint64_t v195 = v131;
        int64_t v197 = strerror(*v132);
        CFStringRef v94 = @"Unable to spawn ddt: %d (%s)\n\n";
        goto LABEL_189;
      }
    }
    CFStringRef v115 = v92;
    CFStringRef v116 = CFStringGetCStringPtr(v92, 0x8000100u);
    if (v116)
    {
      id v117 = (char *)v116;
      int v118 = 0;
    }
    else
    {
      id v117 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xD9FA48E4uLL);
      CFStringGetCString(v115, v117, 1024, 0x8000100u);
      int v118 = v117;
    }
    if (qword_1000EBD00) {
      CFStringRef v128 = (FILE *)qword_1000EBD00;
    }
    else {
      CFStringRef v128 = __stderrp;
    }
    fprintf(v128, "%s\n", v117);
    if (v118) {
      free(v118);
    }
    CFRelease(v115);
    goto LABEL_187;
  }
LABEL_64:
  if (byte_1000EBD0C & 2) != 0 && (sub_10002411C())
  {
    id v44 = 0;
  }
  else
  {
    uint64_t v45 = stackshot_config_create();
    stackshot_config_set_flags();
    id v44 = sub_10006DF74(v45, +[NSMutableSet setWithObject:](NSMutableSet, "setWithObject:", +[NSNumber numberWithInt:*v4]));
    stackshot_config_dealloc();
  }
  if ((unint64_t)(*(void *)(a1 + 64) - 3) > 0xFFFFFFFFFFFFFFFDLL) {
    goto LABEL_142;
  }
  [v3 appendFormat:@"lsof -n -M -P -T -w +c 0 -s +fg +L -p %d\n", *v4];
  *(void *)buf = "/usr/sbin/lsof";
  *(void *)&uint8_t buf[8] = "-n";
  *(void *)&uint8_t buf[16] = "-M";
  *(void *)&uint8_t buf[24] = "-P";
  int v220 = "-T";
  uint64_t v221 = "-w";
  CFStringRef v222 = "+c";
  int v223 = "0";
  int v224 = "-s";
  CFStringRef v225 = "+fg";
  CFStringRef v226 = "+L";
  int v227 = "-p";
  int v228 = __str;
  uint64_t v229 = 0;
  int v217 = -1;
  uint64_t v199 = 0;
  LOBYTE(v197) = 0;
  uint64_t v196 = 0;
  pid_t v46 = SASpawnPlatformBinaryWithSigningIdentifier();
  if (v46 < 0)
  {
    if ((*v4 & 0x80000000) != 0)
    {
      if (byte_1000EBCF8)
      {
        int v119 = *__error();
        id v120 = sub_10002E548();
        if (os_log_type_enabled(v120, OS_LOG_TYPE_ERROR)) {
          sub_10008FA78();
        }
        *__error() = v119;
      }
      if (!byte_1000EBCF9 || dword_1000EB4A8 > 3) {
        goto LABEL_251;
      }
      int v102 = *__error();
      uint64_t v121 = *__error();
      int v122 = __error();
      CFStringRef v123 = strerror(*v122);
      CFStringRef v108 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"Unable to spawn lsof: %d (%s)", v121, v123, 0);
      if (!v108)
      {
        int v161 = sub_10002E548();
        if (os_log_type_enabled(v161, OS_LOG_TYPE_FAULT)) {
          sub_10008F9F0();
        }
        goto LABEL_246;
      }
    }
    else
    {
      if (byte_1000EBCF8)
      {
        int v100 = *__error();
        CFStringRef v101 = sub_10002E548();
        if (os_log_type_enabled(v101, OS_LOG_TYPE_ERROR)) {
          sub_10008F960();
        }
        *__error() = v100;
      }
      if (!byte_1000EBCF9 || dword_1000EB4A8 > 3) {
        goto LABEL_251;
      }
      int v102 = *__error();
      CFStringRef v103 = sub_10002E4E8(*v4);
      uint64_t v104 = *v4;
      uint64_t v105 = *__error();
      int v106 = __error();
      __int16 v107 = strerror(*v106);
      CFStringRef v108 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%s [%d]: Unable to spawn lsof: %d (%s)", v103, v104, v105, v107);
      if (!v108)
      {
        double v109 = sub_10002E548();
        if (os_log_type_enabled(v109, OS_LOG_TYPE_FAULT)) {
          sub_10008F8D0();
        }
LABEL_246:
        if (qword_1000EBD00) {
          int v162 = (FILE *)qword_1000EBD00;
        }
        else {
          int v162 = __stderrp;
        }
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v162);
LABEL_250:
        *__error() = v102;
LABEL_251:
        uint64_t v163 = *__error();
        BOOL v164 = __error();
        [v3 appendFormat:@"Unable to spawn lsof: %d (%s)\n\n", v163, strerror(*v164)];
        goto LABEL_252;
      }
    }
    CFStringRef v124 = v108;
    double v125 = CFStringGetCStringPtr(v108, 0x8000100u);
    if (v125)
    {
      uint64_t v126 = (char *)v125;
      CFStringRef v127 = 0;
    }
    else
    {
      uint64_t v126 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xBF99A0uLL);
      CFStringGetCString(v124, v126, 1024, 0x8000100u);
      CFStringRef v127 = v126;
    }
    if (qword_1000EBD00) {
      xpc_object_t v160 = (FILE *)qword_1000EBD00;
    }
    else {
      xpc_object_t v160 = __stderrp;
    }
    fprintf(v160, "%s\n", v126);
    if (v127) {
      free(v127);
    }
    CFRelease(v124);
    goto LABEL_250;
  }
  pid_t v47 = v46;
  time_t v204 = v2;
  uint64_t v206 = a1;
  CFStringRef v48 = malloc_type_calloc(0x20uLL, 0x400uLL, 0xFCAD8550uLL);
  ssize_t v49 = read(v217, v48, vm_page_size - 1);
  if (v49 < 1)
  {
    waitpid(v47, 0, 0);
    free(v48);
    [v3 appendFormat:@"\n", v197];
    a1 = v206;
  }
  else
  {
    ssize_t v50 = v49;
    pid_t v202 = v47;
    id v200 = v44;
    char v51 = 0;
    do
    {
      *((unsigned char *)v48 + v50) = 0;
      id v52 = [objc_alloc((Class)NSString) initWithBytesNoCopy:v48 length:v50 encoding:4 freeWhenDone:0];
      if (v52)
      {
        id v53 = v52;
        [v3 appendString:v52];

        char v51 = 1;
      }
      else if ((*v4 & 0x80000000) != 0)
      {
        if (byte_1000EBCF8)
        {
          int v65 = *__error();
          int v66 = sub_10002E548();
          if (os_log_type_enabled(v66, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)int v218 = 136315138;
            *(void *)&v218[4] = v48;
            _os_log_error_impl((void *)&_mh_execute_header, v66, OS_LOG_TYPE_ERROR, "Unable to convert lsof output to NSString: %s", v218, 0xCu);
          }
          *__error() = v65;
        }
        if (byte_1000EBCF9) {
          BOOL v67 = dword_1000EB4A8 <= 3;
        }
        else {
          BOOL v67 = 0;
        }
        if (v67)
        {
          int v68 = *__error();
          CFStringRef v69 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"Unable to convert lsof output to NSString: %s", v48, v197, v199);
          if (v69)
          {
            CFStringRef v70 = v69;
            int v71 = CFStringGetCStringPtr(v69, 0x8000100u);
            if (v71)
            {
              id v72 = (char *)v71;
              int v73 = 0;
            }
            else
            {
              id v72 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x50D1E49DuLL);
              CFStringGetCString(v70, v72, 1024, 0x8000100u);
              int v73 = v72;
            }
            if (qword_1000EBD00) {
              CFStringRef v79 = (FILE *)qword_1000EBD00;
            }
            else {
              CFStringRef v79 = __stderrp;
            }
            fprintf(v79, "%s\n", v72);
            if (v73) {
              free(v73);
            }
            CFRelease(v70);
          }
          else
          {
            int v77 = sub_10002E548();
            if (os_log_type_enabled(v77, OS_LOG_TYPE_FAULT))
            {
              *(_DWORD *)int v218 = 136315138;
              *(void *)&v218[4] = v48;
              _os_log_fault_impl((void *)&_mh_execute_header, v77, OS_LOG_TYPE_FAULT, "Unable to format: Unable to convert lsof output to NSString: %s", v218, 0xCu);
            }
            if (qword_1000EBD00) {
              CFStringRef v78 = (FILE *)qword_1000EBD00;
            }
            else {
              CFStringRef v78 = __stderrp;
            }
            fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v78);
          }
          *__error() = v68;
        }
      }
      else
      {
        if (byte_1000EBCF8)
        {
          int v54 = *__error();
          double v55 = sub_10002E548();
          if (os_log_type_enabled(v55, OS_LOG_TYPE_ERROR))
          {
            int v80 = sub_10002E4E8(*v4);
            int v81 = *v4;
            *(_DWORD *)int v218 = 136446722;
            *(void *)&v218[4] = v80;
            *(_WORD *)&v218[12] = 1024;
            *(_DWORD *)&v218[14] = v81;
            *(_WORD *)&v218[18] = 2080;
            *(void *)&v218[20] = v48;
            _os_log_error_impl((void *)&_mh_execute_header, v55, OS_LOG_TYPE_ERROR, "%{public}s [%d]: Unable to convert lsof output to NSString: %s", v218, 0x1Cu);
          }
          *__error() = v54;
        }
        if (byte_1000EBCF9) {
          BOOL v56 = dword_1000EB4A8 <= 3;
        }
        else {
          BOOL v56 = 0;
        }
        if (v56)
        {
          id v57 = v3;
          int v58 = *__error();
          uint64_t v59 = sub_10002E4E8(*v4);
          CFStringRef v60 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%s [%d]: Unable to convert lsof output to NSString: %s", v59, *v4, v48);
          if (v60)
          {
            CFStringRef v61 = v60;
            int v62 = CFStringGetCStringPtr(v60, 0x8000100u);
            if (v62)
            {
              id v63 = (char *)v62;
              CFStringRef v64 = 0;
            }
            else
            {
              id v63 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x50D1E49DuLL);
              CFStringGetCString(v61, v63, 1024, 0x8000100u);
              CFStringRef v64 = v63;
            }
            if (qword_1000EBD00) {
              int v76 = (FILE *)qword_1000EBD00;
            }
            else {
              int v76 = __stderrp;
            }
            fprintf(v76, "%s\n", v63);
            if (v64) {
              free(v64);
            }
            CFRelease(v61);
          }
          else
          {
            id v74 = sub_10002E548();
            if (os_log_type_enabled(v74, OS_LOG_TYPE_FAULT))
            {
              CFStringRef v82 = sub_10002E4E8(*v4);
              int v83 = *v4;
              *(_DWORD *)int v218 = 136315650;
              *(void *)&v218[4] = v82;
              *(_WORD *)&v218[12] = 1024;
              *(_DWORD *)&v218[14] = v83;
              *(_WORD *)&v218[18] = 2080;
              *(void *)&v218[20] = v48;
              _os_log_fault_impl((void *)&_mh_execute_header, v74, OS_LOG_TYPE_FAULT, "Unable to format: %s [%d]: Unable to convert lsof output to NSString: %s", v218, 0x1Cu);
            }
            if (qword_1000EBD00) {
              CFStringRef v75 = (FILE *)qword_1000EBD00;
            }
            else {
              CFStringRef v75 = __stderrp;
            }
            fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v75);
          }
          *__error() = v58;
          id v3 = v57;
        }
      }
      ssize_t v50 = read(v217, v48, vm_page_size - 1);
    }
    while (v50 > 0);
    waitpid(v202, 0, 0);
    free(v48);
    [v3 appendFormat:@"\n", v196];
    a1 = v206;
    if (v51)
    {
      time_t v2 = v204;
      id v44 = v200;
LABEL_142:
      mach_port_name_t v95 = *(_DWORD *)(a1 + 100);
      if (v95 + 1 >= 2) {
        sub_10005427C(*(void *)(a1 + 64), *(unsigned int *)(a1 + 96), v95);
      }
      dispatch_queue_global_t global_queue = dispatch_get_global_queue(9, 0);
      block[0] = _NSConcreteStackBlock;
      block[1] = 3221225472;
      long long v97 = *(_OWORD *)(a1 + 80);
      long long v213 = *(_OWORD *)(a1 + 64);
      int8x16_t v208 = vextq_s8(*(int8x16_t *)(a1 + 32), *(int8x16_t *)(a1 + 32), 8uLL);
      block[2] = sub_100054A58;
      block[3] = &unk_1000DD528;
      time_t v214 = v2;
      int v216 = *(_DWORD *)(a1 + 96);
      uint64_t v99 = *(void *)(a1 + 48);
      uint64_t v98 = *(void *)(a1 + 56);
      id v209 = v44;
      uint64_t v210 = v99;
      long long v215 = v97;
      id v211 = v3;
      uint64_t v212 = v98;
      dispatch_async(global_queue, block);
      return;
    }
  }
LABEL_252:
  BOOL v133 = sub_1000240E8(*v4);
  int v165 = *v4;
  if (!v133)
  {
    if ((v165 & 0x80000000) == 0)
    {
      if (byte_1000EBCF8)
      {
        int v170 = *__error();
        unsigned int v171 = sub_10002E548();
        if (os_log_type_enabled(v171, OS_LOG_TYPE_ERROR)) {
          sub_10008F7F0();
        }
        *__error() = v170;
      }
      if (!byte_1000EBCF9 || dword_1000EB4A8 > 3) {
        goto LABEL_321;
      }
      int v137 = *__error();
      int v172 = sub_10002E4E8(*v4);
      CFStringRef v173 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%s [%d]: Unable to gather lsof for resource exhaustion report; process is no longer around",
               v172,
               *v4);
      if (v173)
      {
        CFStringRef v140 = v173;
        uint64_t v141 = CFStringGetCStringPtr(v173, 0x8000100u);
        if (!v141)
        {
          malloc_type_id_t v142 = 2726677414;
          goto LABEL_296;
        }
        goto LABEL_272;
      }
      CFStringRef v185 = sub_10002E548();
      if (os_log_type_enabled(v185, OS_LOG_TYPE_FAULT)) {
        sub_10008F778();
      }
LABEL_307:
      if (qword_1000EBD00) {
        int v190 = (FILE *)qword_1000EBD00;
      }
      else {
        int v190 = __stderrp;
      }
      fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v190);
      goto LABEL_320;
    }
    if (byte_1000EBCF8)
    {
      int v179 = *__error();
      CFStringRef v180 = sub_10002E548();
      if (os_log_type_enabled(v180, OS_LOG_TYPE_ERROR)) {
        sub_10008F89C();
      }
      *__error() = v179;
    }
    if (!byte_1000EBCF9 || dword_1000EB4A8 > 3) {
      goto LABEL_321;
    }
    int v137 = *__error();
    CFStringRef v181 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"Unable to gather lsof for resource exhaustion report; process is no longer around");
    if (!v181)
    {
      double v189 = sub_10002E548();
      if (os_log_type_enabled(v189, OS_LOG_TYPE_FAULT)) {
        sub_10008F868();
      }
      goto LABEL_307;
    }
    CFStringRef v150 = v181;
    __int16 v151 = CFStringGetCStringPtr(v181, 0x8000100u);
    if (!v151)
    {
      malloc_type_id_t v152 = 2726677414;
      goto LABEL_312;
    }
    goto LABEL_290;
  }
  if (v165 < 0)
  {
    if (byte_1000EBCF8)
    {
      int v176 = *__error();
      CFStringRef v177 = sub_10002E548();
      if (os_log_type_enabled(v177, OS_LOG_TYPE_ERROR)) {
        sub_10008F744();
      }
      *__error() = v176;
    }
    if (!byte_1000EBCF9 || dword_1000EB4A8 > 3) {
      goto LABEL_321;
    }
    int v137 = *__error();
    CFStringRef v178 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"Unable to gather lsof for resource exhaustion report, though process is alive");
    if (!v178)
    {
      CFStringRef v188 = sub_10002E548();
      if (os_log_type_enabled(v188, OS_LOG_TYPE_FAULT)) {
        sub_10008F710();
      }
      goto LABEL_307;
    }
    CFStringRef v150 = v178;
    __int16 v151 = CFStringGetCStringPtr(v178, 0x8000100u);
    if (!v151)
    {
      malloc_type_id_t v152 = 1843175792;
      goto LABEL_312;
    }
LABEL_290:
    CFStringRef v182 = (char *)v151;
    BOOL v183 = 0;
LABEL_313:
    if (qword_1000EBD00) {
      int v191 = (FILE *)qword_1000EBD00;
    }
    else {
      int v191 = __stderrp;
    }
    fprintf(v191, "%s\n", v182);
    if (v183) {
      free(v183);
    }
    CFStringRef v187 = v150;
    goto LABEL_319;
  }
  if (byte_1000EBCF8)
  {
    int v166 = *__error();
    CFStringRef v167 = sub_10002E548();
    if (os_log_type_enabled(v167, OS_LOG_TYPE_ERROR)) {
      sub_10008F698();
    }
    *__error() = v166;
  }
  if (!byte_1000EBCF9 || dword_1000EB4A8 > 3) {
    goto LABEL_321;
  }
  int v137 = *__error();
  CFStringRef v168 = sub_10002E4E8(*v4);
  CFStringRef v169 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%s [%d]: Unable to gather lsof for resource exhaustion report, though process is alive", v168, *v4);
  if (!v169)
  {
    int v184 = sub_10002E548();
    if (os_log_type_enabled(v184, OS_LOG_TYPE_FAULT)) {
      sub_10008F620();
    }
    goto LABEL_307;
  }
  CFStringRef v140 = v169;
  uint64_t v141 = CFStringGetCStringPtr(v169, 0x8000100u);
  if (!v141)
  {
    malloc_type_id_t v142 = 1843175792;
    goto LABEL_296;
  }
LABEL_272:
  BOOL v174 = (char *)v141;
  int v175 = 0;
LABEL_297:
  if (qword_1000EBD00) {
    CFStringRef v186 = (FILE *)qword_1000EBD00;
  }
  else {
    CFStringRef v186 = __stderrp;
  }
  fprintf(v186, "%s\n", v174);
  if (v175) {
    free(v175);
  }
  CFStringRef v187 = v140;
LABEL_319:
  CFRelease(v187);
LABEL_320:
  *__error() = v137;
LABEL_321:
  mach_port_name_t v192 = *(_DWORD *)(a1 + 100);
  if (v192 + 1 >= 2) {
    sub_10005427C(*(void *)(a1 + 64), *(unsigned int *)(a1 + 96), v192);
  }
  uint64_t v193 = *(void *)(a1 + 56);
  if (v193)
  {
    if (v133) {
      uint64_t v194 = 0x2000000000;
    }
    else {
      uint64_t v194 = 0x1000000000;
    }
    (*(void (**)(uint64_t, uint64_t))(v193 + 16))(v193, v194);
  }
}

uint64_t sub_10005427C(uint64_t a1, uint64_t a2, mach_port_name_t name)
{
  if (a1 != 2)
  {
    if (a1 != 1)
    {
      if (a1) {
        return mach_port_deallocate(mach_task_self_, name);
      }
      if ((a2 & 0x80000000) == 0)
      {
        if (byte_1000EBCF8)
        {
          int v5 = *__error();
          pid_t v6 = sub_10002E548();
          if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 136446466;
            double v55 = sub_10002E4E8(a2);
            __int16 v56 = 1024;
            int v57 = a2;
            _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "%{public}s [%d]: file descriptor exhaustion: deallocating fatal port, allowing process to exit due to fatal resource exhaustion", buf, 0x12u);
          }
          *__error() = v5;
        }
        if (byte_1000EBCF9) {
          BOOL v7 = dword_1000EB4A8 <= 2;
        }
        else {
          BOOL v7 = 0;
        }
        if (!v7) {
          return mach_port_deallocate(mach_task_self_, name);
        }
        int v8 = *__error();
        ssize_t v9 = sub_10002E4E8(a2);
        CFStringRef v10 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%s [%d]: file descriptor exhaustion: deallocating fatal port, allowing process to exit due to fatal resource exhaustion", v9, a2);
        if (v10)
        {
          CFStringRef v11 = v10;
          CStringPtr = CFStringGetCStringPtr(v10, 0x8000100u);
          if (!CStringPtr)
          {
            malloc_type_id_t v13 = 446669766;
LABEL_86:
            int v24 = (char *)malloc_type_calloc(0x400uLL, 1uLL, v13);
            CFStringGetCString(v11, v24, 1024, 0x8000100u);
            id v25 = v24;
            goto LABEL_87;
          }
          goto LABEL_42;
        }
        uint64_t v45 = sub_10002E548();
        if (os_log_type_enabled(v45, OS_LOG_TYPE_FAULT)) {
          sub_10008FB00(a2);
        }
        goto LABEL_99;
      }
      if (byte_1000EBCF8)
      {
        int v37 = *__error();
        int v38 = sub_10002E548();
        if (os_log_type_enabled(v38, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_DEFAULT, "file descriptor exhaustion: deallocating fatal port, allowing process to exit due to fatal resource exhaustion", buf, 2u);
        }
        *__error() = v37;
      }
      if (byte_1000EBCF9) {
        BOOL v39 = dword_1000EB4A8 <= 2;
      }
      else {
        BOOL v39 = 0;
      }
      if (!v39) {
        return mach_port_deallocate(mach_task_self_, name);
      }
      int v8 = *__error();
      CFStringRef v40 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"file descriptor exhaustion: deallocating fatal port, allowing process to exit due to fatal resource exhaustion");
      if (!v40)
      {
        ssize_t v50 = sub_10002E548();
        if (os_log_type_enabled(v50, OS_LOG_TYPE_FAULT)) {
          sub_10008FB7C();
        }
        goto LABEL_99;
      }
      CFStringRef v30 = v40;
      double v31 = CFStringGetCStringPtr(v40, 0x8000100u);
      if (v31) {
        goto LABEL_78;
      }
      malloc_type_id_t v32 = 446669766;
LABEL_104:
      int v41 = (char *)malloc_type_calloc(0x400uLL, 1uLL, v32);
      CFStringGetCString(v30, v41, 1024, 0x8000100u);
      CFStringRef v42 = v41;
      goto LABEL_105;
    }
    if ((a2 & 0x80000000) == 0)
    {
      if (byte_1000EBCF8)
      {
        int v19 = *__error();
        id v20 = sub_10002E548();
        if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136446466;
          double v55 = sub_10002E4E8(a2);
          __int16 v56 = 1024;
          int v57 = a2;
          _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "%{public}s [%d]: port exhaustion: deallocating fatal port, allowing process to exit due to fatal resource exhaustion", buf, 0x12u);
        }
        *__error() = v19;
      }
      if (byte_1000EBCF9) {
        BOOL v21 = dword_1000EB4A8 <= 2;
      }
      else {
        BOOL v21 = 0;
      }
      if (v21)
      {
        int v8 = *__error();
        id v22 = sub_10002E4E8(a2);
        CFStringRef v23 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%s [%d]: port exhaustion: deallocating fatal port, allowing process to exit due to fatal resource exhaustion", v22, a2);
        if (v23)
        {
          CFStringRef v11 = v23;
          CStringPtr = CFStringGetCStringPtr(v23, 0x8000100u);
          if (!CStringPtr)
          {
            malloc_type_id_t v13 = 3880392626;
            goto LABEL_86;
          }
          goto LABEL_42;
        }
        id v44 = sub_10002E548();
        if (os_log_type_enabled(v44, OS_LOG_TYPE_FAULT)) {
          sub_10008FBB0(a2);
        }
        goto LABEL_99;
      }
      return mach_port_deallocate(mach_task_self_, name);
    }
    if (byte_1000EBCF8)
    {
      int v33 = *__error();
      double v34 = sub_10002E548();
      if (os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_DEFAULT, "port exhaustion: deallocating fatal port, allowing process to exit due to fatal resource exhaustion", buf, 2u);
      }
      *__error() = v33;
    }
    if (byte_1000EBCF9) {
      BOOL v35 = dword_1000EB4A8 <= 2;
    }
    else {
      BOOL v35 = 0;
    }
    if (!v35) {
      return mach_port_deallocate(mach_task_self_, name);
    }
    int v8 = *__error();
    CFStringRef v36 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"port exhaustion: deallocating fatal port, allowing process to exit due to fatal resource exhaustion");
    if (!v36)
    {
      ssize_t v49 = sub_10002E548();
      if (os_log_type_enabled(v49, OS_LOG_TYPE_FAULT)) {
        sub_10008FC2C();
      }
      goto LABEL_99;
    }
    CFStringRef v30 = v36;
    double v31 = CFStringGetCStringPtr(v36, 0x8000100u);
    if (!v31)
    {
      malloc_type_id_t v32 = 3880392626;
      goto LABEL_104;
    }
    goto LABEL_78;
  }
  if ((a2 & 0x80000000) != 0)
  {
    if (byte_1000EBCF8)
    {
      int v26 = *__error();
      int v27 = sub_10002E548();
      if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "kqworkloop exhaustion: deallocating fatal port, allowing process to exit due to fatal resource exhaustion", buf, 2u);
      }
      *__error() = v26;
    }
    if (byte_1000EBCF9) {
      BOOL v28 = dword_1000EB4A8 <= 2;
    }
    else {
      BOOL v28 = 0;
    }
    if (!v28) {
      return mach_port_deallocate(mach_task_self_, name);
    }
    int v8 = *__error();
    CFStringRef v29 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"kqworkloop exhaustion: deallocating fatal port, allowing process to exit due to fatal resource exhaustion");
    if (!v29)
    {
      CFStringRef v48 = sub_10002E548();
      if (os_log_type_enabled(v48, OS_LOG_TYPE_FAULT)) {
        sub_10008FCDC();
      }
      goto LABEL_99;
    }
    CFStringRef v30 = v29;
    double v31 = CFStringGetCStringPtr(v29, 0x8000100u);
    if (!v31)
    {
      malloc_type_id_t v32 = 1526647797;
      goto LABEL_104;
    }
LABEL_78:
    int v41 = (char *)v31;
    CFStringRef v42 = 0;
LABEL_105:
    if (qword_1000EBD00) {
      id v52 = (FILE *)qword_1000EBD00;
    }
    else {
      id v52 = __stderrp;
    }
    fprintf(v52, "%s\n", v41);
    if (v42) {
      free(v42);
    }
    CFStringRef v47 = v30;
    goto LABEL_111;
  }
  if (byte_1000EBCF8)
  {
    int v14 = *__error();
    BOOL v15 = sub_10002E548();
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136446466;
      double v55 = sub_10002E4E8(a2);
      __int16 v56 = 1024;
      int v57 = a2;
      _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "%{public}s [%d]: kqworkloop exhaustion: deallocating fatal port, allowing process to exit due to fatal resource exhaustion", buf, 0x12u);
    }
    *__error() = v14;
  }
  if (byte_1000EBCF9) {
    BOOL v16 = dword_1000EB4A8 <= 2;
  }
  else {
    BOOL v16 = 0;
  }
  if (v16)
  {
    int v8 = *__error();
    uint64_t v17 = sub_10002E4E8(a2);
    CFStringRef v18 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%s [%d]: kqworkloop exhaustion: deallocating fatal port, allowing process to exit due to fatal resource exhaustion", v17, a2);
    if (v18)
    {
      CFStringRef v11 = v18;
      CStringPtr = CFStringGetCStringPtr(v18, 0x8000100u);
      if (!CStringPtr)
      {
        malloc_type_id_t v13 = 1526647797;
        goto LABEL_86;
      }
LABEL_42:
      int v24 = (char *)CStringPtr;
      id v25 = 0;
LABEL_87:
      if (qword_1000EBD00) {
        pid_t v46 = (FILE *)qword_1000EBD00;
      }
      else {
        pid_t v46 = __stderrp;
      }
      fprintf(v46, "%s\n", v24);
      if (v25) {
        free(v25);
      }
      CFStringRef v47 = v11;
LABEL_111:
      CFRelease(v47);
LABEL_112:
      *__error() = v8;
      return mach_port_deallocate(mach_task_self_, name);
    }
    int v43 = sub_10002E548();
    if (os_log_type_enabled(v43, OS_LOG_TYPE_FAULT)) {
      sub_10008FC60(a2);
    }
LABEL_99:
    if (qword_1000EBD00) {
      char v51 = (FILE *)qword_1000EBD00;
    }
    else {
      char v51 = __stderrp;
    }
    fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v51);
    goto LABEL_112;
  }
  return mach_port_deallocate(mach_task_self_, name);
}

void sub_100054A58(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 80);
  if (v2 == 2)
  {
    char v3 = *(unsigned char *)(a1 + 88);
    id v4 = "ExhaustionFatal_KQWorkLoops";
    int v5 = "Exhaustion_KQWorkLoops";
  }
  else if (v2 == 1)
  {
    char v3 = *(unsigned char *)(a1 + 88);
    id v4 = "ExhaustionFatal_Ports";
    int v5 = "Exhaustion_Ports";
  }
  else
  {
    if (v2)
    {
      pid_t v6 = 0;
      goto LABEL_11;
    }
    char v3 = *(unsigned char *)(a1 + 88);
    id v4 = "ExhaustionFatal_FileDescriptors";
    int v5 = "Exhaustion_FileDescriptors";
  }
  if (v3) {
    pid_t v6 = v4;
  }
  else {
    pid_t v6 = v5;
  }
LABEL_11:
  memset(&v161, 0, sizeof(v161));
  localtime_r((const time_t *)(a1 + 96), &v161);
  strftime(v170, 0x40uLL, "%F_%H-%M-%S", &v161);
  BOOL v7 = +[NSString stringWithFormat:](NSString, @"/private/var/db/spindump/%s_%@_%s.txt", v6, [objc_msgSend(*(id *)(a1 + 32), "lastPathComponent") stringByReplacingOccurrencesOfString:@" " withString:@"_"], v170);
  uid_t v8 = geteuid();
  int v9 = sub_10004D99C(v7, 0, 0, 1538, v8, 0x1A4u, 0);
  if ((v9 & 0x80000000) == 0)
  {
    int v10 = v9;
    CFStringRef v11 = (int *)dup(v9);
    BOOL v12 = fdopen(v10, "w");
    if (v12)
    {
      malloc_type_id_t v13 = v12;
      id v14 = [objc_alloc((Class)SASampleStore) initForLiveSampling];
      sub_10005EB20(v14, (byte_1000EBD0C >> 3) & 1, (byte_1000EBD0C >> 2) & 1, (byte_1000EBD0C >> 4) & 1);
      [v14 addKCDataStackshot:*(void *)(a1 + 48)];
      BOOL v15 = (int *)(a1 + 120);
      [v14 setTargetProcessId:*(unsigned int *)(a1 + 120)];
      [v14 postprocess];
      if (*(void *)(a1 + 56)) {
        CFStringRef v16 = *(const __CFString **)(a1 + 56);
      }
      else {
        CFStringRef v16 = @"none";
      }
      [v14 setActionTaken:v16];
      unint64_t v17 = *(void *)(a1 + 80);
      if (v17 <= 2) {
        [v14 setEvent:off_1000DD570[v17]];
      }
      if (*(void *)(a1 + 88)) {
        CFStringRef v18 = @" (fatal)";
      }
      else {
        CFStringRef v18 = &stru_1000E0D58;
      }
      [v14 setEventNote:+[NSString stringWithFormat:](NSString, "stringWithFormat:", @"%llu allocated, exceeding limit of %llu%@", *(void *)(a1 + 104), *(void *)(a1 + 112), v18)];
      if (*(void *)(a1 + 88)) {
        CFStringRef v19 = @"Process killed";
      }
      else {
        CFStringRef v19 = @"none";
      }
      [v14 setActionTaken:v19];
      id v20 = [objc_alloc((Class)SASamplePrinter) initWithSampleStore:v14];
      [objc_msgSend(v20, "options") setDisplayHeader:1];
      [objc_msgSend(v20, "options") setDisplayBody:0];
      [objc_msgSend(v20, "options") setDisplayFooter:0];
      [v20 setIncidentUUID:+[NSUUID UUID](NSUUID, "UUID")];
      [v20 printToStream:v13];
      fputc(10, v13);
      id v21 = [*(id *)(a1 + 64) lengthOfBytesUsingEncoding:4];
      if (!v21)
      {
LABEL_216:
        [objc_msgSend(v20, "options") setDisplayHeader:0];
        [objc_msgSend(v20, "options") setDisplayBody:1];
        [objc_msgSend(v20, "options") setDisplayFooter:1];
        [v20 printToStream:v13];

        fwrite("\n\n", 2uLL, 1uLL, v13);
        [v14 setCustomOutput:*(void *)(a1 + 64)];
        [v14 saveBinaryFormatToStream:v13];

        fclose(v13);
        if (v11 != -1)
        {
          sub_100056B00(v11);
          close((int)v11);
        }
        if (byte_1000EBCF8)
        {
          int v140 = *__error();
          uint64_t v141 = sub_10002E548();
          if (os_log_type_enabled(v141, OS_LOG_TYPE_DEFAULT))
          {
            id v142 = [*(id *)(a1 + 32) lastPathComponent];
            int v143 = *(_DWORD *)(a1 + 120);
            *(_DWORD *)buf = 138413058;
            id v163 = v142;
            __int16 v164 = 1024;
            int v165 = v143;
            __int16 v166 = 2082;
            CFStringRef v167 = v6;
            __int16 v168 = 2112;
            CFStringRef v169 = v7;
            _os_log_impl((void *)&_mh_execute_header, v141, OS_LOG_TYPE_DEFAULT, "%@ [%d] Saved %{public}s report to %@", buf, 0x26u);
          }
          *__error() = v140;
        }
        if (byte_1000EBCF9 && dword_1000EB4A8 <= 2)
        {
          int v144 = *__error();
          CFStringRef v145 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%@ [%d] Saved %s report to %@", [*(id *)(a1 + 32) lastPathComponent], *(unsigned int *)(a1 + 120), v6, v7);
          if (v145)
          {
            CFStringRef v146 = v145;
            CStringPtr = CFStringGetCStringPtr(v145, 0x8000100u);
            if (CStringPtr)
            {
              uint64_t v148 = (char *)CStringPtr;
              CFStringRef v149 = 0;
            }
            else
            {
              uint64_t v148 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x7912DBE8uLL);
              CFStringGetCString(v146, v148, 1024, 0x8000100u);
              CFStringRef v149 = v148;
            }
            if (qword_1000EBD00) {
              malloc_type_id_t v152 = (FILE *)qword_1000EBD00;
            }
            else {
              malloc_type_id_t v152 = __stderrp;
            }
            fprintf(v152, "%s\n", v148);
            if (v149) {
              free(v149);
            }
            CFRelease(v146);
          }
          else
          {
            CFStringRef v150 = sub_10002E548();
            if (os_log_type_enabled(v150, OS_LOG_TYPE_FAULT))
            {
              id v154 = [*(id *)(a1 + 32) lastPathComponent];
              int v155 = *(_DWORD *)(a1 + 120);
              *(_DWORD *)buf = 138413058;
              id v163 = v154;
              __int16 v164 = 1024;
              int v165 = v155;
              __int16 v166 = 2080;
              CFStringRef v167 = v6;
              __int16 v168 = 2112;
              CFStringRef v169 = v7;
              _os_log_fault_impl((void *)&_mh_execute_header, v150, OS_LOG_TYPE_FAULT, "Unable to format: %@ [%d] Saved %s report to %@", buf, 0x26u);
            }
            if (qword_1000EBD00) {
              __int16 v151 = (FILE *)qword_1000EBD00;
            }
            else {
              __int16 v151 = __stderrp;
            }
            fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v151);
          }
          *__error() = v144;
        }
        sub_100056054(v6, 3600);
        uint64_t v153 = *(void *)(a1 + 72);
        if (v153)
        {
          CFStringRef v123 = *(void (**)(void))(v153 + 16);
          goto LABEL_243;
        }
        goto LABEL_244;
      }
      size_t v22 = (size_t)v21;
      unsigned int v160 = v11;
      CFStringRef v23 = malloc_type_malloc((size_t)v21, 0x23BFECBCuLL);
      if ([*(id *)(a1 + 64) getCString:v23 maxLength:v22 encoding:4])
      {
        size_t v24 = fwrite(v23, v22, 1uLL, v13);
        id v25 = v23;
        if (v24 != 1)
        {
          if ((*v15 & 0x80000000) == 0)
          {
            if (byte_1000EBCF8)
            {
              int v26 = *__error();
              int v27 = sub_10002E548();
              if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR)) {
                sub_100090238();
              }
              *__error() = v26;
              id v25 = v23;
            }
            if (!byte_1000EBCF9 || dword_1000EB4A8 > 3) {
              goto LABEL_215;
            }
            double v159 = v25;
            int v158 = *__error();
            BOOL v28 = sub_10002E4E8(*v15);
            uint64_t v29 = *v15;
            uint64_t v30 = ferror(v13);
            double v31 = strerror(v30);
            CFStringRef v32 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%s [%d]: Unable to write ddt/lsof output to buffer: %d (%s)", v28, v29, v30, v31);
            if (v32)
            {
              CFStringRef v33 = v32;
              double v34 = CFStringGetCStringPtr(v32, 0x8000100u);
              if (!v34)
              {
                malloc_type_id_t v35 = 3700517583;
LABEL_173:
                CFStringRef v91 = (char *)malloc_type_calloc(0x400uLL, 1uLL, v35);
                CFStringGetCString(v33, v91, 1024, 0x8000100u);
                CFStringRef v92 = v91;
                goto LABEL_174;
              }
              goto LABEL_96;
            }
            CFStringRef v124 = sub_10002E548();
            if (os_log_type_enabled(v124, OS_LOG_TYPE_FAULT)) {
              goto LABEL_161;
            }
            goto LABEL_162;
          }
          if (byte_1000EBCF8)
          {
            int v96 = *__error();
            long long v97 = sub_10002E548();
            if (os_log_type_enabled(v97, OS_LOG_TYPE_ERROR)) {
              sub_100090340(v13);
            }
            *__error() = v96;
            id v25 = v23;
          }
          if (!byte_1000EBCF9 || dword_1000EB4A8 > 3) {
            goto LABEL_215;
          }
          int v98 = *__error();
          uint64_t v99 = ferror(v13);
          int v100 = strerror(v99);
          CFStringRef v101 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"Unable to write ddt/lsof output to buffer: %d (%s)", v99, v100);
          if (!v101)
          {
            CFStringRef v128 = sub_10002E548();
            if (os_log_type_enabled(v128, OS_LOG_TYPE_FAULT)) {
              sub_1000902C0(v13);
            }
            if (qword_1000EBD00) {
              CFStringRef v129 = (FILE *)qword_1000EBD00;
            }
            else {
              CFStringRef v129 = __stderrp;
            }
            fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v129);
            goto LABEL_214;
          }
          CFStringRef v102 = v101;
          int v158 = v98;
          double v159 = v25;
          CFStringRef v103 = CFStringGetCStringPtr(v101, 0x8000100u);
          if (v103)
          {
            uint64_t v104 = (char *)v103;
            uint64_t v105 = 0;
          }
          else
          {
            uint64_t v104 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xDC916ACFuLL);
            CFStringGetCString(v102, v104, 1024, 0x8000100u);
            uint64_t v105 = v104;
          }
          goto LABEL_199;
        }
LABEL_215:
        free(v25);
        CFStringRef v11 = (int *)v160;
        goto LABEL_216;
      }
      double v159 = v23;
      id v69 = [*(id *)(a1 + 64) dataUsingEncoding:4 allowLossyConversion:1];
      if (v69)
      {
        id v25 = v23;
        if (fwrite([v69 bytes], (size_t)objc_msgSend(v69, "length"), 1uLL, v13) == 1) {
          goto LABEL_215;
        }
        if ((*v15 & 0x80000000) == 0)
        {
          if (byte_1000EBCF8)
          {
            int v70 = *__error();
            int v71 = sub_10002E548();
            if (os_log_type_enabled(v71, OS_LOG_TYPE_ERROR)) {
              sub_100090238();
            }
            *__error() = v70;
            id v25 = v23;
          }
          if (!byte_1000EBCF9 || dword_1000EB4A8 > 3) {
            goto LABEL_215;
          }
          int v158 = *__error();
          id v72 = sub_10002E4E8(*v15);
          uint64_t v73 = *v15;
          uint64_t v74 = ferror(v13);
          CFStringRef v75 = strerror(v74);
          CFStringRef v76 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%s [%d]: Unable to write ddt/lsof output to buffer: %d (%s)", v72, v73, v74, v75);
          if (v76)
          {
            CFStringRef v33 = v76;
            int v77 = CFStringGetCStringPtr(v76, 0x8000100u);
            if (v77)
            {
              CFStringRef v78 = (char *)v77;
              CFAllocatorRef alloc = 0;
            }
            else
            {
              CFStringRef v78 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xABF51116uLL);
              CFStringGetCString(v33, v78, 1024, 0x8000100u);
              CFAllocatorRef alloc = (CFAllocatorRef)v78;
            }
            if (qword_1000EBD00) {
              int v134 = (FILE *)qword_1000EBD00;
            }
            else {
              int v134 = __stderrp;
            }
            fprintf(v134, "%s\n", v78);
            CFAllocatorRef v131 = alloc;
            if (!alloc) {
              goto LABEL_191;
            }
            goto LABEL_190;
          }
          uint64_t v126 = sub_10002E548();
          if (os_log_type_enabled(v126, OS_LOG_TYPE_FAULT)) {
LABEL_161:
          }
            sub_1000901B0();
LABEL_162:
          if (qword_1000EBD00) {
            CFStringRef v127 = (FILE *)qword_1000EBD00;
          }
          else {
            CFStringRef v127 = __stderrp;
          }
          fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v127);
          goto LABEL_212;
        }
        if (byte_1000EBCF8)
        {
          int v114 = *__error();
          CFStringRef v115 = sub_10002E548();
          if (os_log_type_enabled(v115, OS_LOG_TYPE_ERROR)) {
            sub_100090340(v13);
          }
          *__error() = v114;
        }
        if (!byte_1000EBCF9 || dword_1000EB4A8 > 3) {
          goto LABEL_215;
        }
        int v158 = *__error();
        uint64_t v116 = ferror(v13);
        id v117 = strerror(v116);
        CFStringRef v118 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"Unable to write ddt/lsof output to buffer: %d (%s)", v116, v117);
        if (v118)
        {
          CFStringRef v102 = v118;
          int v119 = CFStringGetCStringPtr(v118, 0x8000100u);
          if (v119)
          {
            id v120 = (char *)v119;
            CFAllocatorRef alloca = 0;
          }
          else
          {
            id v120 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xABF51116uLL);
            CFStringGetCString(v102, v120, 1024, 0x8000100u);
            CFAllocatorRef alloca = (CFAllocatorRef)v120;
          }
          if (qword_1000EBD00) {
            CFStringRef v139 = (FILE *)qword_1000EBD00;
          }
          else {
            CFStringRef v139 = __stderrp;
          }
          fprintf(v139, "%s\n", v120);
          CFAllocatorRef v138 = alloca;
          if (!alloca) {
            goto LABEL_210;
          }
          goto LABEL_209;
        }
        int v136 = sub_10002E548();
        if (os_log_type_enabled(v136, OS_LOG_TYPE_FAULT)) {
          sub_1000902C0(v13);
        }
        if (qword_1000EBD00) {
          BOOL v133 = (FILE *)qword_1000EBD00;
        }
        else {
          BOOL v133 = __stderrp;
        }
      }
      else
      {
        if ((*v15 & 0x80000000) == 0)
        {
          if (byte_1000EBCF8)
          {
            int v87 = *__error();
            uint64_t v88 = sub_10002E548();
            if (os_log_type_enabled(v88, OS_LOG_TYPE_ERROR)) {
              sub_100090438();
            }
            *__error() = v87;
          }
          id v25 = v23;
          if (!byte_1000EBCF9 || dword_1000EB4A8 > 3) {
            goto LABEL_215;
          }
          int v158 = *__error();
          uint64_t v89 = sub_10002E4E8(*v15);
          CFStringRef v90 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%s [%d]: Unable to convert ddt/lsof output to buffer", v89, *v15);
          if (v90)
          {
            CFStringRef v33 = v90;
            double v34 = CFStringGetCStringPtr(v90, 0x8000100u);
            if (!v34)
            {
              malloc_type_id_t v35 = 2270732346;
              goto LABEL_173;
            }
LABEL_96:
            CFStringRef v91 = (char *)v34;
            CFStringRef v92 = 0;
LABEL_174:
            if (qword_1000EBD00) {
              uint64_t v130 = (FILE *)qword_1000EBD00;
            }
            else {
              uint64_t v130 = __stderrp;
            }
            fprintf(v130, "%s\n", v91);
            if (!v92) {
              goto LABEL_191;
            }
            CFAllocatorRef v131 = (CFAllocatorRef)v92;
LABEL_190:
            free(v131);
LABEL_191:
            CFStringRef v135 = v33;
LABEL_211:
            CFRelease(v135);
LABEL_212:
            id v25 = v159;
            goto LABEL_213;
          }
          double v125 = sub_10002E548();
          if (os_log_type_enabled(v125, OS_LOG_TYPE_FAULT)) {
            sub_1000903C0();
          }
          goto LABEL_162;
        }
        if (byte_1000EBCF8)
        {
          int v106 = *__error();
          __int16 v107 = sub_10002E548();
          if (os_log_type_enabled(v107, OS_LOG_TYPE_ERROR)) {
            sub_1000904E4();
          }
          *__error() = v106;
        }
        id v25 = v23;
        if (!byte_1000EBCF9 || dword_1000EB4A8 > 3) {
          goto LABEL_215;
        }
        int v158 = *__error();
        CFStringRef v108 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"Unable to convert ddt/lsof output to buffer");
        if (v108)
        {
          CFStringRef v102 = v108;
          double v109 = CFStringGetCStringPtr(v108, 0x8000100u);
          if (v109)
          {
            uint64_t v104 = (char *)v109;
            uint64_t v105 = 0;
          }
          else
          {
            uint64_t v104 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x8758A03AuLL);
            CFStringGetCString(v102, v104, 1024, 0x8000100u);
            uint64_t v105 = v104;
          }
LABEL_199:
          if (qword_1000EBD00) {
            int v137 = (FILE *)qword_1000EBD00;
          }
          else {
            int v137 = __stderrp;
          }
          fprintf(v137, "%s\n", v104);
          if (!v105) {
            goto LABEL_210;
          }
          CFAllocatorRef v138 = (CFAllocatorRef)v105;
LABEL_209:
          free(v138);
LABEL_210:
          CFStringRef v135 = v102;
          goto LABEL_211;
        }
        CFStringRef v132 = sub_10002E548();
        if (os_log_type_enabled(v132, OS_LOG_TYPE_FAULT)) {
          sub_1000904B0();
        }
        if (qword_1000EBD00) {
          BOOL v133 = (FILE *)qword_1000EBD00;
        }
        else {
          BOOL v133 = __stderrp;
        }
      }
      fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v133);
LABEL_213:
      int v98 = v158;
LABEL_214:
      *__error() = v98;
      goto LABEL_215;
    }
    ssize_t v49 = (int *)(a1 + 120);
    if ((*(_DWORD *)(a1 + 120) & 0x80000000) == 0)
    {
      if (byte_1000EBCF8)
      {
        int v50 = *__error();
        char v51 = sub_10002E548();
        if (os_log_type_enabled(v51, OS_LOG_TYPE_ERROR)) {
          sub_10008FFF8();
        }
        *__error() = v50;
      }
      if (byte_1000EBCF9 && dword_1000EB4A8 <= 3)
      {
        int v39 = *__error();
        id v52 = sub_10002E4E8(*v49);
        uint64_t v53 = *v49;
        uint64_t v54 = *__error();
        double v55 = __error();
        __int16 v56 = strerror(*v55);
        CFStringRef v57 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%s [%d]: could not fdopen log file %@: %d (%s)", v52, v53, v7, v54, v56);
        if (v57)
        {
          CFStringRef v46 = v57;
          CFStringRef v47 = CFStringGetCStringPtr(v57, 0x8000100u);
          if (v47) {
            goto LABEL_56;
          }
          malloc_type_id_t v48 = 2643340271;
          goto LABEL_122;
        }
        CFStringRef v94 = sub_10002E548();
        if (os_log_type_enabled(v94, OS_LOG_TYPE_FAULT)) {
          sub_10008FF60();
        }
        goto LABEL_131;
      }
      goto LABEL_154;
    }
    if (byte_1000EBCF8)
    {
      int v79 = *__error();
      int v80 = sub_10002E548();
      if (os_log_type_enabled(v80, OS_LOG_TYPE_ERROR)) {
        sub_100090120();
      }
      *__error() = v79;
    }
    if (!byte_1000EBCF9 || dword_1000EB4A8 > 3) {
      goto LABEL_154;
    }
    int v39 = *__error();
    uint64_t v81 = *__error();
    CFStringRef v82 = __error();
    int v83 = strerror(*v82);
    CFStringRef v84 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"could not fdopen log file %@: %d (%s)", v7, v81, v83);
    if (!v84)
    {
      uint64_t v112 = sub_10002E548();
      if (os_log_type_enabled(v112, OS_LOG_TYPE_FAULT)) {
        sub_100090090();
      }
      goto LABEL_131;
    }
    CFStringRef v66 = v84;
    BOOL v67 = CFStringGetCStringPtr(v84, 0x8000100u);
    if (v67) {
      goto LABEL_86;
    }
    malloc_type_id_t v68 = 2643340271;
    goto LABEL_145;
  }
  CFStringRef v36 = (int *)(a1 + 120);
  if ((*(_DWORD *)(a1 + 120) & 0x80000000) != 0)
  {
    if (byte_1000EBCF8)
    {
      int v60 = *__error();
      CFStringRef v61 = sub_10002E548();
      if (os_log_type_enabled(v61, OS_LOG_TYPE_ERROR)) {
        sub_10008FED0();
      }
      *__error() = v60;
    }
    if (!byte_1000EBCF9 || dword_1000EB4A8 > 3) {
      goto LABEL_154;
    }
    int v39 = *__error();
    uint64_t v62 = *__error();
    id v63 = __error();
    CFStringRef v64 = strerror(*v63);
    CFStringRef v65 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"could not open log file %@: %d (%s)", v7, v62, v64);
    if (!v65)
    {
      mach_port_name_t v95 = sub_10002E548();
      if (os_log_type_enabled(v95, OS_LOG_TYPE_FAULT)) {
        sub_10008FE40();
      }
      goto LABEL_131;
    }
    CFStringRef v66 = v65;
    BOOL v67 = CFStringGetCStringPtr(v65, 0x8000100u);
    if (v67)
    {
LABEL_86:
      CFStringRef v85 = (char *)v67;
      int v86 = 0;
LABEL_146:
      if (qword_1000EBD00) {
        uint64_t v121 = (FILE *)qword_1000EBD00;
      }
      else {
        uint64_t v121 = __stderrp;
      }
      fprintf(v121, "%s\n", v85);
      if (v86) {
        free(v86);
      }
      CFStringRef v111 = v66;
      goto LABEL_152;
    }
    malloc_type_id_t v68 = 4058203421;
LABEL_145:
    CFStringRef v85 = (char *)malloc_type_calloc(0x400uLL, 1uLL, v68);
    CFStringGetCString(v66, v85, 1024, 0x8000100u);
    int v86 = v85;
    goto LABEL_146;
  }
  if (byte_1000EBCF8)
  {
    int v37 = *__error();
    int v38 = sub_10002E548();
    if (os_log_type_enabled(v38, OS_LOG_TYPE_ERROR)) {
      sub_10008FDA8();
    }
    *__error() = v37;
  }
  if (byte_1000EBCF9 && dword_1000EB4A8 <= 3)
  {
    int v39 = *__error();
    CFStringRef v40 = sub_10002E4E8(*v36);
    uint64_t v41 = *v36;
    uint64_t v42 = *__error();
    int v43 = __error();
    id v44 = strerror(*v43);
    CFStringRef v45 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%s [%d]: could not open log file %@: %d (%s)", v40, v41, v7, v42, v44);
    if (v45)
    {
      CFStringRef v46 = v45;
      CFStringRef v47 = CFStringGetCStringPtr(v45, 0x8000100u);
      if (v47)
      {
LABEL_56:
        int v58 = (char *)v47;
        uint64_t v59 = 0;
LABEL_123:
        if (qword_1000EBD00) {
          int v110 = (FILE *)qword_1000EBD00;
        }
        else {
          int v110 = __stderrp;
        }
        fprintf(v110, "%s\n", v58);
        if (v59) {
          free(v59);
        }
        CFStringRef v111 = v46;
LABEL_152:
        CFRelease(v111);
LABEL_153:
        *__error() = v39;
        goto LABEL_154;
      }
      malloc_type_id_t v48 = 4058203421;
LABEL_122:
      int v58 = (char *)malloc_type_calloc(0x400uLL, 1uLL, v48);
      CFStringGetCString(v46, v58, 1024, 0x8000100u);
      uint64_t v59 = v58;
      goto LABEL_123;
    }
    CFStringRef v93 = sub_10002E548();
    if (os_log_type_enabled(v93, OS_LOG_TYPE_FAULT)) {
      sub_10008FD10();
    }
LABEL_131:
    if (qword_1000EBD00) {
      int v113 = (FILE *)qword_1000EBD00;
    }
    else {
      int v113 = __stderrp;
    }
    fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v113);
    goto LABEL_153;
  }
LABEL_154:
  uint64_t v122 = *(void *)(a1 + 72);
  if (v122)
  {
    CFStringRef v123 = *(void (**)(void))(v122 + 16);
LABEL_243:
    v123();
  }
LABEL_244:
}

_DWORD *sub_100055FD8(int *a1)
{
  int v2 = *a1;
  return sub_10002E4E8(v2);
}

_DWORD *sub_100055FF0(int *a1)
{
  int v2 = *a1;
  return sub_10002E4E8(v2);
}

uint64_t sub_100056008()
{
  return ferror(v0);
}

int *sub_100056024()
{
  return __error();
}

int *sub_10005603C()
{
  return __error();
}

void sub_100056054(const char *a1, uint64_t a2)
{
  time_t v4 = time(0);
  int v5 = strdup(a1);
  uint64_t v6 = sub_10002E390("Cleanup spindump dir for %s", a1);
  dispatch_queue_global_t global_queue = dispatch_get_global_queue(9, 0);
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_100056114;
  block[3] = &unk_1000DD590;
  void block[6] = v4;
  block[7] = a2;
  void block[4] = v6;
  void block[5] = v5;
  dispatch_async(global_queue, block);
}

void sub_100056114(uint64_t a1)
{
  int v2 = opendir("/private/var/db/spindump");
  if (v2)
  {
    char v3 = v2;
    *__error() = 0;
    for (uint64_t i = readdir(v3); i; uint64_t i = readdir(v3))
    {
      d_name = i->d_name;
      size_t v6 = strlen(*(const char **)(a1 + 40));
      if (!strncmp(d_name, *(const char **)(a1 + 40), v6))
      {
        snprintf(__str, 0x80uLL, "/private/var/db/spindump/%s", d_name);
        memset(&v86, 0, sizeof(v86));
        if (stat(__str, &v86))
        {
          if (byte_1000EBCF8)
          {
            int v16 = *__error();
            unint64_t v17 = sub_10002E548();
            if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
            {
              int v60 = *__error();
              CFStringRef v61 = __error();
              uint64_t v62 = strerror(*v61);
              *(_DWORD *)buf = 136315650;
              int v83 = __str;
              __int16 v84 = 1024;
              *(_DWORD *)CFStringRef v85 = v60;
              *(_WORD *)&v85[4] = 2080;
              *(void *)&v85[6] = v62;
              _os_log_error_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_ERROR, "Stat failed, attemping unlink of %s: %d (%s)", buf, 0x1Cu);
            }
            *__error() = v16;
          }
          if (byte_1000EBCF9) {
            BOOL v18 = dword_1000EB4A8 <= 3;
          }
          else {
            BOOL v18 = 0;
          }
          if (!v18) {
            goto LABEL_82;
          }
          int v19 = *__error();
          uint64_t v20 = *__error();
          id v21 = __error();
          size_t v22 = strerror(*v21);
          CFStringRef v23 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"Stat failed, attemping unlink of %s: %d (%s)", __str, v20, v22);
          if (v23)
          {
            CFStringRef v24 = v23;
            CStringPtr = CFStringGetCStringPtr(v23, 0x8000100u);
            if (CStringPtr) {
              goto LABEL_61;
            }
            malloc_type_id_t v26 = 4028211986;
            goto LABEL_74;
          }
          uint64_t v41 = sub_10002E548();
          if (os_log_type_enabled(v41, OS_LOG_TYPE_FAULT))
          {
            int v42 = *__error();
            int v43 = __error();
            id v44 = strerror(*v43);
            *(_DWORD *)buf = 136315650;
            int v83 = __str;
            __int16 v84 = 1024;
            *(_DWORD *)CFStringRef v85 = v42;
            *(_WORD *)&v85[4] = 2080;
            *(void *)&v85[6] = v44;
            CFStringRef v45 = v41;
            CFStringRef v46 = "Unable to format: Stat failed, attemping unlink of %s: %d (%s)";
            uint32_t v47 = 28;
            goto LABEL_68;
          }
          goto LABEL_69;
        }
        if (v86.st_ctimespec.tv_sec <= *(void *)(a1 + 48) - *(void *)(a1 + 56))
        {
          if (byte_1000EBCF8)
          {
            int v34 = *__error();
            malloc_type_id_t v35 = sub_10002E548();
            if (os_log_type_enabled(v35, OS_LOG_TYPE_INFO))
            {
              uint64_t v36 = *(void *)(a1 + 56);
              __darwin_time_t v37 = *(void *)(a1 + 48) - v86.st_ctimespec.tv_sec;
              *(_DWORD *)buf = 136315650;
              int v83 = __str;
              __int16 v84 = 2048;
              *(void *)CFStringRef v85 = v37;
              *(_WORD *)&v85[8] = 2048;
              *(void *)&v85[10] = v36;
              _os_log_impl((void *)&_mh_execute_header, v35, OS_LOG_TYPE_INFO, "Unlinking %s which is %lds old (>=%lds)", buf, 0x20u);
            }
            *__error() = v34;
          }
          if (!byte_1000EBCF9 || dword_1000EB4A8 > 1) {
            goto LABEL_82;
          }
          int v19 = *__error();
          CFStringRef v38 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"Unlinking %s which is %lds old (>=%lds)", __str, *(void *)(a1 + 48) - v86.st_ctimespec.tv_sec, *(void *)(a1 + 56));
          if (v38)
          {
            CFStringRef v24 = v38;
            CStringPtr = CFStringGetCStringPtr(v38, 0x8000100u);
            if (CStringPtr)
            {
LABEL_61:
              int v39 = (char *)CStringPtr;
              CFStringRef v40 = 0;
              goto LABEL_75;
            }
            malloc_type_id_t v26 = 2546796519;
LABEL_74:
            int v39 = (char *)malloc_type_calloc(0x400uLL, 1uLL, v26);
            CFStringGetCString(v24, v39, 1024, 0x8000100u);
            CFStringRef v40 = v39;
LABEL_75:
            if (qword_1000EBD00) {
              id v63 = (FILE *)qword_1000EBD00;
            }
            else {
              id v63 = __stderrp;
            }
            fprintf(v63, "%s\n", v39);
            if (v40) {
              free(v40);
            }
            CFRelease(v24);
LABEL_81:
            *__error() = v19;
LABEL_82:
            unlink(__str);
            continue;
          }
          __int16 v56 = sub_10002E548();
          if (os_log_type_enabled(v56, OS_LOG_TYPE_FAULT))
          {
            uint64_t v57 = *(void *)(a1 + 56);
            __darwin_time_t v58 = *(void *)(a1 + 48) - v86.st_ctimespec.tv_sec;
            *(_DWORD *)buf = 136315650;
            int v83 = __str;
            __int16 v84 = 2048;
            *(void *)CFStringRef v85 = v58;
            *(_WORD *)&v85[8] = 2048;
            *(void *)&v85[10] = v57;
            CFStringRef v45 = v56;
            CFStringRef v46 = "Unable to format: Unlinking %s which is %lds old (>=%lds)";
            uint32_t v47 = 32;
LABEL_68:
            _os_log_fault_impl((void *)&_mh_execute_header, v45, OS_LOG_TYPE_FAULT, v46, buf, v47);
          }
LABEL_69:
          if (qword_1000EBD00) {
            uint64_t v59 = (FILE *)qword_1000EBD00;
          }
          else {
            uint64_t v59 = __stderrp;
          }
          fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v59);
          goto LABEL_81;
        }
        if (byte_1000EBCF8)
        {
          int v27 = *__error();
          BOOL v28 = sub_10002E548();
          if (os_log_type_enabled(v28, OS_LOG_TYPE_DEBUG))
          {
            uint64_t v65 = *(void *)(a1 + 56);
            __darwin_time_t v66 = *(void *)(a1 + 48) - v86.st_ctimespec.tv_sec;
            *(_DWORD *)buf = 136315650;
            int v83 = __str;
            __int16 v84 = 2048;
            *(void *)CFStringRef v85 = v66;
            *(_WORD *)&v85[8] = 2048;
            *(void *)&v85[10] = v65;
            _os_log_debug_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEBUG, "Not unlinking %s which is %lds old (<%lds)", buf, 0x20u);
          }
          *__error() = v27;
        }
        if (!byte_1000EBCF9 || dword_1000EB4A8 > 0) {
          continue;
        }
        int v10 = *__error();
        CFStringRef v29 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"Not unlinking %s which is %lds old (<%lds)", __str, *(void *)(a1 + 48) - v86.st_ctimespec.tv_sec, *(void *)(a1 + 56));
        if (!v29)
        {
          ssize_t v49 = sub_10002E548();
          if (os_log_type_enabled(v49, OS_LOG_TYPE_FAULT))
          {
            uint64_t v50 = *(void *)(a1 + 56);
            __darwin_time_t v51 = *(void *)(a1 + 48) - v86.st_ctimespec.tv_sec;
            *(_DWORD *)buf = 136315650;
            int v83 = __str;
            __int16 v84 = 2048;
            *(void *)CFStringRef v85 = v51;
            *(_WORD *)&v85[8] = 2048;
            *(void *)&v85[10] = v50;
            id v52 = buf;
            uint64_t v53 = v49;
            uint64_t v54 = "Unable to format: Not unlinking %s which is %lds old (<%lds)";
            uint32_t v55 = 32;
            goto LABEL_86;
          }
LABEL_40:
          if (qword_1000EBD00) {
            CFStringRef v32 = (FILE *)qword_1000EBD00;
          }
          else {
            CFStringRef v32 = __stderrp;
          }
          fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v32);
          goto LABEL_52;
        }
        CFStringRef v12 = v29;
        malloc_type_id_t v13 = CFStringGetCStringPtr(v29, 0x8000100u);
        if (!v13)
        {
          malloc_type_id_t v30 = 860181693;
LABEL_45:
          id v14 = (char *)malloc_type_calloc(0x400uLL, 1uLL, v30);
          CFStringGetCString(v12, v14, 1024, 0x8000100u);
          BOOL v15 = v14;
          goto LABEL_46;
        }
      }
      else
      {
        if (byte_1000EBCF8)
        {
          int v7 = *__error();
          uid_t v8 = sub_10002E548();
          if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
          {
            __darwin_ino64_t v48 = *(void *)(a1 + 40);
            v86.st_dev = 136315394;
            *(void *)&v86.st_mode = d_name;
            WORD2(v86.st_ino) = 2080;
            *(__darwin_ino64_t *)((char *)&v86.st_ino + 6) = v48;
            _os_log_debug_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEBUG, "File %s doesn't match prefix %s", (uint8_t *)&v86, 0x16u);
          }
          *__error() = v7;
        }
        if (byte_1000EBCF9) {
          BOOL v9 = dword_1000EB4A8 <= 0;
        }
        else {
          BOOL v9 = 0;
        }
        if (!v9) {
          continue;
        }
        int v10 = *__error();
        CFStringRef v11 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"File %s doesn't match prefix %s", d_name, *(void *)(a1 + 40));
        if (!v11)
        {
          double v31 = sub_10002E548();
          if (os_log_type_enabled(v31, OS_LOG_TYPE_FAULT))
          {
            __darwin_ino64_t v64 = *(void *)(a1 + 40);
            v86.st_dev = 136315394;
            *(void *)&v86.st_mode = d_name;
            WORD2(v86.st_ino) = 2080;
            *(__darwin_ino64_t *)((char *)&v86.st_ino + 6) = v64;
            id v52 = (uint8_t *)&v86;
            uint64_t v53 = v31;
            uint64_t v54 = "Unable to format: File %s doesn't match prefix %s";
            uint32_t v55 = 22;
LABEL_86:
            _os_log_fault_impl((void *)&_mh_execute_header, v53, OS_LOG_TYPE_FAULT, v54, v52, v55);
          }
          goto LABEL_40;
        }
        CFStringRef v12 = v11;
        malloc_type_id_t v13 = CFStringGetCStringPtr(v11, 0x8000100u);
        if (!v13)
        {
          malloc_type_id_t v30 = 1347677374;
          goto LABEL_45;
        }
      }
      id v14 = (char *)v13;
      BOOL v15 = 0;
LABEL_46:
      if (qword_1000EBD00) {
        CFStringRef v33 = (FILE *)qword_1000EBD00;
      }
      else {
        CFStringRef v33 = __stderrp;
      }
      fprintf(v33, "%s\n", v14);
      if (v15) {
        free(v15);
      }
      CFRelease(v12);
LABEL_52:
      *__error() = v10;
    }

    closedir(v3);
    free(*(void **)(a1 + 40));
  }
  else
  {
    if (byte_1000EBCF8)
    {
      int v67 = *__error();
      malloc_type_id_t v68 = sub_10002E548();
      if (os_log_type_enabled(v68, OS_LOG_TYPE_ERROR)) {
        sub_1000905A0();
      }
      *__error() = v67;
    }
    if (byte_1000EBCF9) {
      BOOL v69 = dword_1000EB4A8 <= 3;
    }
    else {
      BOOL v69 = 0;
    }
    if (v69)
    {
      int v70 = *__error();
      uint64_t v71 = *__error();
      id v72 = __error();
      uint64_t v73 = strerror(*v72);
      CFStringRef v74 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"Unable to opendir /private/var/db/spindump: %d (%s)", v71, v73);
      if (v74)
      {
        CFStringRef v75 = v74;
        CFStringRef v76 = CFStringGetCStringPtr(v74, 0x8000100u);
        if (v76)
        {
          int v77 = (char *)v76;
          CFStringRef v78 = 0;
        }
        else
        {
          int v77 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x7297CD3AuLL);
          CFStringGetCString(v75, v77, 1024, 0x8000100u);
          CFStringRef v78 = v77;
        }
        if (qword_1000EBD00) {
          uint64_t v81 = (FILE *)qword_1000EBD00;
        }
        else {
          uint64_t v81 = __stderrp;
        }
        fprintf(v81, "%s\n", v77);
        if (v78) {
          free(v78);
        }
        CFRelease(v75);
      }
      else
      {
        int v79 = sub_10002E548();
        if (os_log_type_enabled(v79, OS_LOG_TYPE_FAULT)) {
          sub_100090518();
        }
        if (qword_1000EBD00) {
          int v80 = (FILE *)qword_1000EBD00;
        }
        else {
          int v80 = __stderrp;
        }
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v80);
      }
      *__error() = v70;
    }
  }
}

int *sub_100056B00(int *result)
{
  if ((result & 0x80000000) != 0) {
    return result;
  }
  uint64_t v26 = 66053;
  id result = (int *)ffsctl((int)result, 0xC0084A44uLL, &v26, 0);
  if (result)
  {
    uint64_t v1 = result;
    if (byte_1000EBCF8)
    {
      int v2 = *__error();
      char v3 = sub_10002E548();
      if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR)) {
        sub_10009072C((int)v1);
      }
      id result = __error();
      int *result = v2;
    }
    if (byte_1000EBCF9) {
      BOOL v4 = dword_1000EB4A8 <= 3;
    }
    else {
      BOOL v4 = 0;
    }
    if (!v4) {
      return result;
    }
    int v5 = *__error();
    size_t v6 = strerror((int)v1);
    CFStringRef v7 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"Failed to mark file purgeable: %d (%s)", v1, v6);
    if (v7)
    {
      CFStringRef v8 = v7;
      CStringPtr = CFStringGetCStringPtr(v7, 0x8000100u);
      if (CStringPtr)
      {
        int v10 = (char *)CStringPtr;
        CFStringRef v11 = 0;
      }
      else
      {
        int v10 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x1C943F89uLL);
        CFStringGetCString(v8, v10, 1024, 0x8000100u);
        CFStringRef v11 = v10;
      }
      if (qword_1000EBD00) {
        id v21 = (FILE *)qword_1000EBD00;
      }
      else {
        id v21 = __stderrp;
      }
      fprintf(v21, "%s\n", v10);
      if (v11) {
        free(v11);
      }
      CFStringRef v22 = v8;
LABEL_49:
      CFRelease(v22);
LABEL_50:
      id result = __error();
      int *result = v5;
      return result;
    }
    uint64_t v20 = sub_10002E548();
    if (os_log_type_enabled(v20, OS_LOG_TYPE_FAULT)) {
      sub_1000906B0((int)v1);
    }
    goto LABEL_38;
  }
  if (byte_1000EBCF8)
  {
    int v12 = *__error();
    malloc_type_id_t v13 = sub_10002E548();
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG)) {
      sub_10009066C(v13);
    }
    id result = __error();
    int *result = v12;
  }
  if (byte_1000EBCF9) {
    BOOL v14 = dword_1000EB4A8 <= 0;
  }
  else {
    BOOL v14 = 0;
  }
  if (v14)
  {
    int v5 = *__error();
    CFStringRef v15 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"Marked file purgeable");
    if (v15)
    {
      CFStringRef v16 = v15;
      unint64_t v17 = CFStringGetCStringPtr(v15, 0x8000100u);
      if (v17)
      {
        BOOL v18 = (char *)v17;
        int v19 = 0;
      }
      else
      {
        BOOL v18 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x82F5EFFuLL);
        CFStringGetCString(v16, v18, 1024, 0x8000100u);
        int v19 = v18;
      }
      if (qword_1000EBD00) {
        id v25 = (FILE *)qword_1000EBD00;
      }
      else {
        id v25 = __stderrp;
      }
      fprintf(v25, "%s\n", v18);
      if (v19) {
        free(v19);
      }
      CFStringRef v22 = v16;
      goto LABEL_49;
    }
    CFStringRef v23 = sub_10002E548();
    if (os_log_type_enabled(v23, OS_LOG_TYPE_FAULT)) {
      sub_100090628(v23);
    }
LABEL_38:
    if (qword_1000EBD00) {
      CFStringRef v24 = (FILE *)qword_1000EBD00;
    }
    else {
      CFStringRef v24 = __stderrp;
    }
    fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v24);
    goto LABEL_50;
  }
  return result;
}

void sub_100056E30(id a1, OS_dispatch_source *a2)
{
  if (byte_1000EBCF8)
  {
    int v3 = *__error();
    BOOL v4 = sub_10002E548();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 134217984;
      uintptr_t handle = dispatch_source_get_handle((dispatch_source_t)a2);
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_INFO, "Received signal %ld, exiting", buf, 0xCu);
    }
    *__error() = v3;
  }
  if (byte_1000EBCF9) {
    BOOL v5 = dword_1000EB4A8 <= 1;
  }
  else {
    BOOL v5 = 0;
  }
  if (v5)
  {
    int v6 = *__error();
    uintptr_t v7 = dispatch_source_get_handle((dispatch_source_t)a2);
    CFStringRef v8 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"Received signal %ld, exiting", v7);
    if (v8)
    {
      CFStringRef v12 = v8;
      CStringPtr = CFStringGetCStringPtr(v8, 0x8000100u);
      if (CStringPtr)
      {
        BOOL v14 = (char *)CStringPtr;
        CFStringRef v15 = 0;
      }
      else
      {
        BOOL v14 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xF4B2BA26uLL);
        CFStringGetCString(v12, v14, 1024, 0x8000100u);
        CFStringRef v15 = v14;
      }
      if (qword_1000EBD00) {
        CFStringRef v16 = (FILE *)qword_1000EBD00;
      }
      else {
        CFStringRef v16 = __stderrp;
      }
      fprintf(v16, "%s\n", v14);
      if (v15) {
        free(v15);
      }
      CFRelease(v12);
    }
    else
    {
      BOOL v9 = sub_10002E548();
      if (os_log_type_enabled(v9, OS_LOG_TYPE_FAULT))
      {
        uintptr_t v10 = dispatch_source_get_handle((dispatch_source_t)a2);
        *(_DWORD *)buf = 134217984;
        uintptr_t handle = v10;
        _os_log_fault_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_FAULT, "Unable to format: Received signal %ld, exiting", buf, 0xCu);
      }
      if (qword_1000EBD00) {
        CFStringRef v11 = (FILE *)qword_1000EBD00;
      }
      else {
        CFStringRef v11 = __stderrp;
      }
      fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v11);
    }
    *__error() = v6;
  }
  exit(0);
}

unsigned char *sub_10005705C(const char *a1)
{
  if (!a1) {
    return 0;
  }
  int v2 = strnlen(a1, 0x100uLL);
  if (v2 < 256)
  {
    int v3 = strdup(a1);
    if (v2 < 1) {
      return v3;
    }
  }
  else
  {
    int v3 = malloc_type_malloc(0x100uLL, 0xE1E07A57uLL);
    __strlcpy_chk();
    int v2 = 255;
  }
  for (uint64_t i = 0; i != v2; ++i)
  {
    if (v3[i] - 9 <= 1) {
      v3[i] = 32;
    }
  }
  return v3;
}

int *sub_100057114(void *a1)
{
  if (objc_msgSend(objc_msgSend(a1, "total"), "num_missing_load_info")
    || objc_msgSend(objc_msgSend(a1, "total"), "num_out_of_order")
    || (id result = (int *)objc_msgSend(a1, "bytes_not_microstackshots")) != 0)
  {
    if (objc_msgSend(objc_msgSend(a1, "total"), "num_missing_load_info"))
    {
      if (byte_1000EBCF8)
      {
        int v3 = *__error();
        BOOL v4 = sub_10002E548();
        if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR)) {
          sub_1000919D4(a1);
        }
        *__error() = v3;
      }
      if (byte_1000EBCF9) {
        BOOL v5 = dword_1000EB4A8 <= 3;
      }
      else {
        BOOL v5 = 0;
      }
      if (v5)
      {
        int v6 = *__error();
        CFStringRef v7 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%llu microstackshots dropped due to missing load infos", [objc_msgSend(objc_msgSend(a1, "total"), "num_missing_load_info")]);
        if (v7)
        {
          CFStringRef v8 = v7;
          CStringPtr = CFStringGetCStringPtr(v7, 0x8000100u);
          if (CStringPtr)
          {
            uintptr_t v10 = (char *)CStringPtr;
            CFStringRef v11 = 0;
          }
          else
          {
            uintptr_t v10 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xEC2DED5BuLL);
            CFStringGetCString(v8, v10, 1024, 0x8000100u);
            CFStringRef v11 = v10;
          }
          if (qword_1000EBD00) {
            BOOL v14 = (FILE *)qword_1000EBD00;
          }
          else {
            BOOL v14 = __stderrp;
          }
          fprintf(v14, "%s\n", v10);
          if (v11) {
            free(v11);
          }
          CFRelease(v8);
        }
        else
        {
          CFStringRef v12 = sub_10002E548();
          if (os_log_type_enabled(v12, OS_LOG_TYPE_FAULT)) {
            sub_100091958(a1);
          }
          if (qword_1000EBD00) {
            malloc_type_id_t v13 = (FILE *)qword_1000EBD00;
          }
          else {
            malloc_type_id_t v13 = __stderrp;
          }
          fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v13);
        }
        *__error() = v6;
      }
    }
    if (objc_msgSend(objc_msgSend(a1, "total"), "num_out_of_order"))
    {
      if (byte_1000EBCF8)
      {
        int v15 = *__error();
        CFStringRef v16 = sub_10002E548();
        if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR)) {
          sub_1000918DC(a1);
        }
        *__error() = v15;
      }
      if (byte_1000EBCF9) {
        BOOL v17 = dword_1000EB4A8 <= 3;
      }
      else {
        BOOL v17 = 0;
      }
      if (v17)
      {
        int v18 = *__error();
        CFStringRef v19 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%llu microstackshots dropped due to being out of order", [objc_msgSend(objc_msgSend(a1, "total"), "num_out_of_order")]);
        if (v19)
        {
          CFStringRef v20 = v19;
          id v21 = CFStringGetCStringPtr(v19, 0x8000100u);
          if (v21)
          {
            CFStringRef v22 = (char *)v21;
            CFStringRef v23 = 0;
          }
          else
          {
            CFStringRef v22 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x620541CCuLL);
            CFStringGetCString(v20, v22, 1024, 0x8000100u);
            CFStringRef v23 = v22;
          }
          if (qword_1000EBD00) {
            uint64_t v26 = (FILE *)qword_1000EBD00;
          }
          else {
            uint64_t v26 = __stderrp;
          }
          fprintf(v26, "%s\n", v22);
          if (v23) {
            free(v23);
          }
          CFRelease(v20);
        }
        else
        {
          CFStringRef v24 = sub_10002E548();
          if (os_log_type_enabled(v24, OS_LOG_TYPE_FAULT)) {
            sub_100091860(a1);
          }
          if (qword_1000EBD00) {
            id v25 = (FILE *)qword_1000EBD00;
          }
          else {
            id v25 = __stderrp;
          }
          fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v25);
        }
        *__error() = v18;
      }
    }
    id result = (int *)[a1 bytes_not_microstackshots];
    if (result)
    {
      if (byte_1000EBCF8)
      {
        int v27 = *__error();
        BOOL v28 = sub_10002E548();
        if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR)) {
          sub_1000917E8(a1);
        }
        id result = __error();
        int *result = v27;
      }
      if (byte_1000EBCF9 && dword_1000EB4A8 <= 3)
      {
        int v29 = *__error();
        CFStringRef v30 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%llu bytes of microstackshot data was invalid (ignored)", [a1 bytes_not_microstackshots]);
        if (v30)
        {
          CFStringRef v31 = v30;
          CFStringRef v32 = CFStringGetCStringPtr(v30, 0x8000100u);
          if (v32)
          {
            CFStringRef v33 = (char *)v32;
            int v34 = 0;
          }
          else
          {
            CFStringRef v33 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x135F7D42uLL);
            CFStringGetCString(v31, v33, 1024, 0x8000100u);
            int v34 = v33;
          }
          if (qword_1000EBD00) {
            __darwin_time_t v37 = (FILE *)qword_1000EBD00;
          }
          else {
            __darwin_time_t v37 = __stderrp;
          }
          fprintf(v37, "%s\n", v33);
          if (v34) {
            free(v34);
          }
          CFRelease(v31);
        }
        else
        {
          malloc_type_id_t v35 = sub_10002E548();
          if (os_log_type_enabled(v35, OS_LOG_TYPE_FAULT)) {
            sub_100091770(a1);
          }
          if (qword_1000EBD00) {
            uint64_t v36 = (FILE *)qword_1000EBD00;
          }
          else {
            uint64_t v36 = __stderrp;
          }
          fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v36);
        }
        id result = __error();
        int *result = v29;
      }
    }
  }
  if (byte_1000EBCF8)
  {
    int v38 = *__error();
    int v39 = sub_10002E548();
    if (os_log_type_enabled(v39, OS_LOG_TYPE_INFO))
    {
      int v191 = v38;
      CFStringRef v40 = (char *)[a1 total];
      log = v39;
      uint64_t v41 = &v40[(void)[[[a1 total] bytes_duplicate];
      id v42 = [objc_msgSend(a1, "total") bytes_out_of_order];
      int v43 = &v41[(unint64_t)[(unint64_t)[a1 total] bytes_missing_load_info] + (void)v42];
      CFStringRef v188 = (char *)[a1 bytes_not_microstackshots] + v43;
      id v186 = [a1 bytes_not_microstackshots];
      id v184 = [a1 num_microstackshots_filtered_out];
      id v182 = [objc_msgSend(a1, "total") count];
      id v180 = [objc_msgSend(a1, "total") bytes];
      id v178 = [objc_msgSend(a1, "total") num_load_infos];
      id v176 = [objc_msgSend(a1, "total") num_frames];
      id v174 = [objc_msgSend(a1, "total") num_duplicate];
      id v172 = [objc_msgSend(a1, "total") bytes_duplicate];
      id v170 = [objc_msgSend(a1, "total") num_out_of_order];
      id v168 = [objc_msgSend(a1, "total") bytes_out_of_order];
      id v166 = [objc_msgSend(a1, "total") num_missing_load_info];
      id v164 = [[objc_msgSend(a1, "total") bytes_missing_load_info];
      id v162 = [objc_msgSend(a1, "interrupt") count];
      id v160 = [objc_msgSend(a1, "interrupt") bytes];
      id v158 = [objc_msgSend(a1, "interrupt") num_load_infos];
      id v156 = [objc_msgSend(a1, "interrupt") num_frames];
      id v154 = [objc_msgSend(a1, "interrupt") num_duplicate];
      id v152 = [objc_msgSend(a1, "interrupt") bytes_duplicate];
      id v150 = [[objc_msgSend(a1, "interrupt") num_out_of_order];
      id v148 = [objc_msgSend(a1, "interrupt") bytes_out_of_order];
      id v146 = [objc_msgSend(a1, "interrupt") num_missing_load_info];
      id v144 = [objc_msgSend(a1, "interrupt") bytes_missing_load_info];
      id v142 = [[objc_msgSend(a1, "timer") count];
      id v140 = [objc_msgSend(a1, "timer") bytes];
      id v138 = [objc_msgSend(a1, "timer") num_load_infos];
      id v136 = [objc_msgSend(a1, "timer") num_frames];
      id v134 = [objc_msgSend(a1, "timer") num_duplicate];
      id v132 = [objc_msgSend(a1, "timer") bytes_duplicate];
      id v130 = [objc_msgSend(a1, "timer") num_out_of_order];
      id v128 = [objc_msgSend(a1, "timer") bytes_out_of_order];
      id v126 = [objc_msgSend(a1, "timer") num_missing_load_info];
      id v124 = [objc_msgSend(a1, "timer") bytes_missing_load_info];
      id v122 = [a1 io count];
      id v118 = [objc_msgSend(a1, "io") bytes];
      id v114 = [objc_msgSend(a1, "io") num_load_infos];
      id v108 = [objc_msgSend(a1, "io") num_frames];
      id v104 = [objc_msgSend(a1, "io") num_duplicate];
      id v100 = [objc_msgSend(a1, "io") bytes_duplicate];
      id v96 = [objc_msgSend(a1, "io") num_out_of_order];
      id v92 = [objc_msgSend(a1, "io") bytes_out_of_order];
      id v88 = [[objc_msgSend(a1, "io") num_missing_load_info];
      id v84 = [objc_msgSend(a1, "io") bytes_missing_load_info];
      id v112 = [objc_msgSend(a1, "pmi") count];
      id v120 = [objc_msgSend(a1, "pmi") bytes];
      id v116 = [objc_msgSend(a1, "pmi") num_load_infos];
      id v110 = [[[a1 pmi] num_frames];
      id v106 = [objc_msgSend(a1, "pmi") num_duplicate];
      id v102 = [objc_msgSend(a1, "pmi") bytes_duplicate];
      id v98 = [objc_msgSend(a1, "pmi") num_out_of_order];
      id v94 = [objc_msgSend(objc_msgSend(a1, "pmi"), "bytes_out_of_order")];
      id v90 = [objc_msgSend(a1, "pmi") num_missing_load_info];
      id v86 = [objc_msgSend(a1, "pmi") bytes_missing_load_info];
      id v82 = [[objc_msgSend(a1, "macf") count];
      id v80 = [objc_msgSend(a1, "macf") bytes];
      id v78 = [objc_msgSend(a1, "macf") num_load_infos];
      id v76 = [objc_msgSend(a1, "macf") num_frames];
      id v74 = [objc_msgSend(a1, "macf") num_duplicate];
      id v72 = [objc_msgSend(a1, "macf") bytes_duplicate];
      id v70 = [objc_msgSend(a1, "macf") num_out_of_order];
      id v69 = [objc_msgSend(a1, "macf") bytes_out_of_order];
      id v68 = [objc_msgSend(a1, "macf") num_missing_load_info];
      id v67 = [objc_msgSend(a1, "macf") bytes_missing_load_info];
      id v66 = [objc_msgSend(a1, "unknown_type") count];
      id v44 = [objc_msgSend(a1, "unknown_type") bytes];
      id v45 = [objc_msgSend(a1, "unknown_type") num_load_infos];
      id v46 = [objc_msgSend(objc_msgSend(a1, "unknown_type"), "num_frames")];
      id v47 = [objc_msgSend(objc_msgSend(a1, "unknown_type"), "num_duplicate")];
      id v48 = [objc_msgSend(a1, "unknown_type") bytes_duplicate];
      id v49 = [objc_msgSend(a1, "unknown_type") num_out_of_order];
      id v50 = [objc_msgSend(a1, "unknown_type") bytes_out_of_order];
      id v51 = [[objc_msgSend(a1, "unknown_type") num_missing_load_info];
      id v52 = [objc_msgSend(objc_msgSend(a1, "unknown_type"), "bytes_missing_load_info")];
      uint64_t v194 = v188;
      id v196 = v186;
      id v198 = v184;
      id v200 = v182;
      id v202 = v180;
      id v204 = v178;
      id v206 = v176;
      id v208 = v174;
      id v210 = v172;
      id v212 = v170;
      id v214 = v168;
      id v216 = v166;
      id v218 = v164;
      id v220 = v162;
      id v222 = v160;
      id v224 = v158;
      id v226 = v156;
      id v228 = v154;
      id v230 = v152;
      id v232 = v150;
      id v234 = v148;
      id v236 = v146;
      id v238 = v144;
      id v240 = v142;
      id v242 = v140;
      id v244 = v138;
      id v246 = v136;
      id v248 = v134;
      id v250 = v132;
      id v252 = v130;
      id v254 = v128;
      id v256 = v126;
      id v258 = v124;
      id v260 = v122;
      id v262 = v118;
      id v264 = v114;
      id v266 = v108;
      id v268 = v104;
      id v270 = v100;
      id v272 = v96;
      id v274 = v92;
      id v276 = v88;
      id v278 = v84;
      *(_DWORD *)buf = 134236416;
      id v280 = v112;
      __int16 v195 = 2048;
      __int16 v197 = 2048;
      __int16 v199 = 2048;
      __int16 v201 = 2048;
      __int16 v203 = 2048;
      __int16 v205 = 2048;
      __int16 v207 = 2048;
      __int16 v209 = 2048;
      __int16 v211 = 2048;
      __int16 v213 = 2048;
      __int16 v215 = 2048;
      __int16 v217 = 2048;
      __int16 v219 = 2048;
      __int16 v221 = 2048;
      __int16 v223 = 2048;
      __int16 v225 = 2048;
      __int16 v227 = 2048;
      __int16 v229 = 2048;
      __int16 v231 = 2048;
      __int16 v233 = 2048;
      __int16 v235 = 2048;
      __int16 v237 = 2048;
      __int16 v239 = 2048;
      __int16 v241 = 2048;
      __int16 v243 = 2048;
      __int16 v245 = 2048;
      __int16 v247 = 2048;
      __int16 v249 = 2048;
      __int16 v251 = 2048;
      __int16 v253 = 2048;
      __int16 v255 = 2048;
      __int16 v257 = 2048;
      __int16 v259 = 2048;
      __int16 v261 = 2048;
      __int16 v263 = 2048;
      __int16 v265 = 2048;
      __int16 v267 = 2048;
      __int16 v269 = 2048;
      __int16 v271 = 2048;
      __int16 v273 = 2048;
      __int16 v275 = 2048;
      __int16 v277 = 2048;
      __int16 v279 = 2048;
      __int16 v281 = 2048;
      id v282 = v120;
      __int16 v283 = 2048;
      id v284 = v116;
      __int16 v285 = 2048;
      id v286 = v110;
      __int16 v287 = 2048;
      id v288 = v106;
      __int16 v289 = 2048;
      id v290 = v102;
      __int16 v291 = 2048;
      id v292 = v98;
      __int16 v293 = 2048;
      id v294 = v94;
      __int16 v295 = 2048;
      id v296 = v90;
      __int16 v297 = 2048;
      id v298 = v86;
      __int16 v299 = 2048;
      id v300 = v82;
      __int16 v301 = 2048;
      id v302 = v80;
      __int16 v303 = 2048;
      id v304 = v78;
      __int16 v305 = 2048;
      id v306 = v76;
      __int16 v307 = 2048;
      id v308 = v74;
      __int16 v309 = 2048;
      id v310 = v72;
      __int16 v311 = 2048;
      id v312 = v70;
      __int16 v313 = 2048;
      id v314 = v69;
      __int16 v315 = 2048;
      id v316 = v68;
      __int16 v317 = 2048;
      id v318 = v67;
      __int16 v319 = 2048;
      id v320 = v66;
      char v321 = 0;
      char v322 = 8;
      id v323 = v44;
      char v324 = 0;
      char v325 = 8;
      id v326 = v45;
      char v327 = 0;
      char v328 = 8;
      id v329 = v46;
      char v330 = 0;
      char v331 = 8;
      id v332 = v47;
      char v333 = 0;
      char v334 = 8;
      id v335 = v48;
      int v38 = v191;
      char v336 = 0;
      char v337 = 8;
      id v338 = v49;
      char v339 = 0;
      char v340 = 8;
      id v341 = v50;
      char v342 = 0;
      char v343 = 8;
      id v344 = v51;
      char v345 = 0;
      char v346 = 8;
      id v347 = v52;
      _os_log_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_INFO, "Microstackshot statistics:\n%llu bytes parsed (%llu bytes invalid)\n%llu filtered out\n\ntotal     count          %llu (%llu bytes)\n          num_load_infos %llu\n          num_frames     %llu\n          duplicate      %llu (%llu bytes)\n          out_of_order   %llu (%llu bytes)\n          no_load_info   %llu (%llu bytes)\n\ninterrupt count          %llu (%llu bytes)\n          num_load_infos %llu\n          num_frames     %llu\n          duplicate      %llu (%llu bytes)\n          out_of_order   %llu (%llu bytes)\n"
        "          no_load_info   %llu (%llu bytes)\n"
        "\n"
        "timer     count          %llu (%llu bytes)\n"
        "          num_load_infos %llu\n"
        "          num_frames     %llu\n"
        "          duplicate      %llu (%llu bytes)\n"
        "          out_of_order   %llu (%llu bytes)\n"
        "          no_load_info   %llu (%llu bytes)\n"
        "\n"
        "io        count          %llu (%llu bytes)\n"
        "          num_load_infos %llu\n"
        "          num_frames     %llu\n"
        "          duplicate      %llu (%llu bytes)\n"
        "          out_of_order   %llu (%llu bytes)\n"
        "          no_load_info   %llu (%llu bytes)\n"
        "\n"
        "pmi       count          %llu (%llu bytes)\n"
        "          num_load_infos %llu\n"
        "          num_frames     %llu\n"
        "          duplicate      %llu (%llu bytes)\n"
        "          out_of_order   %llu (%llu bytes)\n"
        "          no_load_info   %llu (%llu bytes)\n"
        "\n"
        "macf      count          %llu (%llu bytes)\n"
        "          num_load_infos %llu\n"
        "          num_frames     %llu\n"
        "          duplicate      %llu (%llu bytes)\n"
        "          out_of_order   %llu (%llu bytes)\n"
        "          no_load_info   %llu (%llu bytes)\n"
        "\n"
        "unknown   count          %llu (%llu bytes)\n"
        "          num_load_infos %llu\n"
        "          num_frames     %llu\n"
        "          duplicate      %llu (%llu bytes)\n"
        "          out_of_order   %llu (%llu bytes)\n"
        "          no_load_info   %llu (%llu bytes)",
        buf,
        0x2DCu);
    }
    id result = __error();
    int *result = v38;
  }
  if (byte_1000EBCF9) {
    BOOL v53 = dword_1000EB4A8 <= 1;
  }
  else {
    BOOL v53 = 0;
  }
  if (v53)
  {
    int v192 = *__error();
    uint64_t v54 = (char *)[a1 total].bytes;
    uint32_t v55 = &v54[(void)[[[a1 total] bytes_duplicate]];
    id v56 = [objc_msgSend(a1, "total") bytes_out_of_order];
    uint64_t v57 = &v55[([a1 total] bytes_missing_load_info) + v56];
    double v189 = (char *)[a1 bytes_not_microstackshots] + (void)v57;
    id v187 = [a1 bytes_not_microstackshots];
    id v185 = [a1 num_microstackshots_filtered_out];
    id v183 = [objc_msgSend(a1, "total") count];
    id v181 = [objc_msgSend(a1, "total") bytes];
    id v179 = [objc_msgSend(a1, "total") num_load_infos];
    id v177 = [objc_msgSend(a1, "total") num_frames];
    id v175 = [objc_msgSend(a1, "total") num_duplicate];
    id v173 = [objc_msgSend(a1, "total") bytes_duplicate];
    id v171 = [objc_msgSend(a1, "total") num_out_of_order];
    id v169 = [objc_msgSend(a1, "total") bytes_out_of_order];
    id v167 = [objc_msgSend(a1, "total") num_missing_load_info];
    id v165 = [objc_msgSend(a1, "total") bytes_missing_load_info];
    id v163 = [[objc_msgSend(a1, "interrupt") count];
    id v161 = [objc_msgSend(a1, "interrupt") bytes];
    id v159 = [[objc_msgSend(a1, "interrupt") num_load_infos];
    id v157 = [objc_msgSend(a1, "interrupt") num_frames];
    id v155 = [objc_msgSend(a1, "interrupt") num_duplicate];
    id v153 = [objc_msgSend(a1, "interrupt") bytes_duplicate];
    id v151 = [[objc_msgSend(a1, "interrupt") num_out_of_order];
    id v149 = [[objc_msgSend(a1, "interrupt") bytes_out_of_order];
    id v147 = [objc_msgSend(a1, "interrupt") num_missing_load_info];
    id v145 = [objc_msgSend(a1, "interrupt") bytes_missing_load_info];
    id v143 = [objc_msgSend(a1, "timer") count];
    id v141 = [objc_msgSend(a1, "timer") bytes];
    id v139 = [objc_msgSend(a1, "timer") num_load_infos];
    id v137 = [objc_msgSend(a1, "timer") num_frames];
    id v135 = [objc_msgSend(a1, "timer") num_duplicate];
    id v133 = [objc_msgSend(a1, "timer") bytes_duplicate];
    id v131 = [objc_msgSend(a1, "timer") num_out_of_order];
    id v129 = [objc_msgSend(a1, "timer") bytes_out_of_order];
    id v127 = [[objc_msgSend(a1, "timer") num_missing_load_info];
    id v125 = [objc_msgSend(a1, "timer") bytes_missing_load_info];
    id v123 = [a1 io].count;
    id v121 = [objc_msgSend(a1, "io") bytes];
    id v119 = [objc_msgSend(a1, "io") num_load_infos];
    id v117 = [objc_msgSend(a1, "io") num_frames];
    id v115 = [objc_msgSend(a1, "io") num_duplicate];
    id v113 = [objc_msgSend(a1, "io") bytes_duplicate];
    id v111 = [objc_msgSend(a1, "io") num_out_of_order];
    id v109 = [objc_msgSend(a1, "io") bytes_out_of_order];
    id v107 = [objc_msgSend(a1, "io") num_missing_load_info];
    id v105 = [objc_msgSend(a1, "io") bytes_missing_load_info];
    id v103 = [objc_msgSend(a1, "pmi") count];
    id v101 = [objc_msgSend(a1, "pmi") bytes];
    id v99 = [[objc_msgSend(a1, "pmi") num_load_infos];
    id v97 = [objc_msgSend(a1, "pmi") num_frames];
    id v95 = [objc_msgSend(a1, "pmi") num_duplicate];
    id v93 = [[objc_msgSend(a1, "pmi") bytes_duplicate];
    id v91 = [objc_msgSend(a1, "pmi") num_out_of_order];
    id v89 = [objc_msgSend(a1, "pmi") bytes_out_of_order];
    id v87 = [[[a1 pmi] num_missing_load_info];
    id v85 = [objc_msgSend(a1, "pmi") bytes_missing_load_info];
    id v83 = [objc_msgSend(a1, "macf") count];
    id v81 = [objc_msgSend(a1, "macf") bytes];
    id v79 = [objc_msgSend(a1, "macf") num_load_infos];
    id v77 = [objc_msgSend(a1, "macf") num_frames];
    id v75 = [objc_msgSend(a1, "macf") num_duplicate];
    id v73 = [objc_msgSend(a1, "macf") bytes_duplicate];
    id v71 = [objc_msgSend(a1, "macf") num_out_of_order];
    [objc_msgSend(a1, "macf") bytes_out_of_order];
    [objc_msgSend(a1, "macf") num_missing_load_info];
    [objc_msgSend(a1, "macf") bytes_missing_load_info];
    [objc_msgSend(a1, "unknown_type") count];
    [objc_msgSend(a1, "unknown_type") bytes];
    [objc_msgSend(a1, "unknown_type") num_load_infos];
    [objc_msgSend(a1, "unknown_type") num_frames];
    [objc_msgSend(a1, "unknown_type") num_duplicate];
    [objc_msgSend(a1, "unknown_type") bytes_duplicate];
    [objc_msgSend(a1, "unknown_type") num_out_of_order];
    [objc_msgSend(a1, "unknown_type") bytes_out_of_order];
    [objc_msgSend(a1, "unknown_type") num_missing_load_info];
    [objc_msgSend(a1, "unknown_type") bytes_missing_load_info];
    CFStringRef v58 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"Microstackshot statistics:\n%llu bytes parsed (%llu bytes invalid)\n%llu filtered out\n\ntotal     count          %llu (%llu bytes)\n          num_load_infos %llu\n          num_frames     %llu\n          duplicate      %llu (%llu bytes)\n          out_of_order   %llu (%llu bytes)\n          no_load_info   %llu (%llu bytes)\n\ninterrupt count          %llu (%llu bytes)\n          num_load_infos %llu\n          num_frames     %llu\n          duplicate      %llu (%llu bytes)\n          out_of_order   %llu (%llu bytes)\n          no_load_info   %llu (%llu bytes)\n\ntimer     count          %llu (%llu bytes)\n          num_load_infos %llu\n          num_frames     %llu\n          duplicate      %llu (%llu bytes)\n          out_of_order   %llu (%llu bytes)\n          no_load_info   %llu (%llu bytes)\n\nio        count          %llu (%llu bytes)\n          num_load_infos %llu\n          num_frames     %llu\n          duplicate      %llu (%llu bytes)\n          out_of_order   %llu (%llu bytes)\n          no_load_info   %llu (%llu bytes)\n\npmi       count          %llu (%llu bytes)\n          num_load_infos %llu\n          num_frames     %llu\n          duplicate      %llu (%llu bytes)\n          out_of_order   %llu (%llu bytes)\n          no_load_info   %llu (%llu bytes)\n\nmacf      count          %llu (%llu bytes)\n          num_load_infos %llu\n          num_frames     %llu\n          duplicate      %llu (%llu bytes)\n          out_of_order   %llu (%llu bytes)\n          no_load_info   %llu (%llu bytes)\n\nunknown   count          %llu (%llu bytes)\n          num_load_infos %llu\n          num_frames     %llu\n          duplicate      %llu (%llu bytes)\n          out_of_order   %llu (%llu bytes)\n          no_load_info   %llu (%llu bytes)", v189, v187, v185, v183, v181, v179, v177, v175, v173, v171, v169, v167, v165, v163, v161, v159,
            v157,
            v155,
            v153,
            v151,
            v149,
            v147,
            v145,
            v143,
            v141,
            v139,
            v137,
            v135,
            v133,
            v131,
            v129,
            v127,
            v125,
            v123,
            v121,
            v119,
            v117,
            v115,
            v113,
            v111,
            v109,
            v107,
            v105,
            v103,
            v101,
            v99,
            v97,
            v95,
            v93,
            v91,
            v89,
            v87,
            v85,
            v83,
            v81,
            v79,
            v77,
            v75,
            v73,
            v71);
    if (v58)
    {
      CFStringRef v59 = v58;
      int v60 = CFStringGetCStringPtr(v58, 0x8000100u);
      if (v60)
      {
        CFStringRef v61 = (char *)v60;
        uint64_t v62 = 0;
      }
      else
      {
        CFStringRef v61 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xB326FB3uLL);
        CFStringGetCString(v59, v61, 1024, 0x8000100u);
        uint64_t v62 = v61;
      }
      if (qword_1000EBD00) {
        uint64_t v65 = (FILE *)qword_1000EBD00;
      }
      else {
        uint64_t v65 = __stderrp;
      }
      fprintf(v65, "%s\n", v61);
      if (v62) {
        free(v62);
      }
      CFRelease(v59);
    }
    else
    {
      id v63 = sub_10002E548();
      if (os_log_type_enabled(v63, OS_LOG_TYPE_FAULT)) {
        sub_100090E70(a1, v63);
      }
      if (qword_1000EBD00) {
        __darwin_ino64_t v64 = (FILE *)qword_1000EBD00;
      }
      else {
        __darwin_ino64_t v64 = __stderrp;
      }
      fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v64);
    }
    id result = __error();
    int *result = v192;
  }
  return result;
}

void sub_100058734(uint64_t a1)
{
  dispatch_group_leave((dispatch_group_t)qword_1000EBD58);
  dispatch_source_cancel(*(dispatch_source_t *)(a1 + 32));
  int v2 = *(NSObject **)(a1 + 32);

  dispatch_release(v2);
}

void sub_100058780(id a1)
{
  if (byte_1000EBCF8)
  {
    int v1 = *__error();
    int v2 = sub_10002E548();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Timed out, exiting", buf, 2u);
    }
    *__error() = v1;
  }
  if (byte_1000EBCF9) {
    BOOL v3 = dword_1000EB4A8 <= 2;
  }
  else {
    BOOL v3 = 0;
  }
  if (v3)
  {
    int v4 = *__error();
    CFStringRef v5 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"Timed out, exiting");
    if (v5)
    {
      CFStringRef v8 = v5;
      CStringPtr = CFStringGetCStringPtr(v5, 0x8000100u);
      if (CStringPtr)
      {
        uintptr_t v10 = (char *)CStringPtr;
        CFStringRef v11 = 0;
      }
      else
      {
        uintptr_t v10 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xA9DE7514uLL);
        CFStringGetCString(v8, v10, 1024, 0x8000100u);
        CFStringRef v11 = v10;
      }
      if (qword_1000EBD00) {
        CFStringRef v12 = (FILE *)qword_1000EBD00;
      }
      else {
        CFStringRef v12 = __stderrp;
      }
      fprintf(v12, "%s\n", v10);
      if (v11) {
        free(v11);
      }
      CFRelease(v8);
    }
    else
    {
      int v6 = sub_10002E548();
      if (os_log_type_enabled(v6, OS_LOG_TYPE_FAULT))
      {
        *(_WORD *)malloc_type_id_t v13 = 0;
        _os_log_fault_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_FAULT, "Unable to format: Timed out, exiting", v13, 2u);
      }
      if (qword_1000EBD00) {
        CFStringRef v7 = (FILE *)qword_1000EBD00;
      }
      else {
        CFStringRef v7 = __stderrp;
      }
      fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v7);
    }
    *__error() = v4;
  }
  exit(75);
}

id sub_10005895C(uint64_t a1, void *a2)
{
  [a2 setEvent:@"shutdown stall"];
  [a2 setEventNote:0];
  int v4 = *(NSString **)(a1 + 32);
  if (v4) {
    int v4 = +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:");
  }
  [a2 setSignature:v4];
  CFStringRef v5 = *(NSString **)(a1 + 40);
  if (v5) {
    CFStringRef v5 = +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:");
  }
  [a2 setReason:v5];
  if (*(_DWORD *)(a1 + 56)) {
    int v6 = +[NSString stringWithFormat:@"sampling started after %d seconds", *(unsigned int *)(a1 + 56)];
  }
  else {
    int v6 = 0;
  }
  [a2 setDurationNote:v6];
  [a2 setExtraDuration:(double)*(int *)(a1 + 56)];
  [a2 setStepsNote:0];
  [a2 setSanitizePaths:0];
  [a2 setOmitThirdPartyProcessStacks:0];
  [a2 setIncludeBinaryFormatInReport:1];
  [a2 setIncludeTextualFormatInReport:0];
  id v7 = objc_alloc_init((Class)NSMutableString);
  int v8 = sub_10002CC18();
  BOOL v9 = (unsigned int *)malloc_type_calloc(v8, 4uLL, 0x100004052888210uLL);
  uint64_t v10 = proc_listallpids(v9, 4 * v8);
  if (v10 == -1)
  {
    if (byte_1000EBCF8)
    {
      int v20 = *__error();
      id v21 = sub_10002E548();
      if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR)) {
        sub_100091AD8();
      }
      *__error() = v20;
    }
    if (byte_1000EBCF9 && dword_1000EB4A8 <= 3)
    {
      int v22 = *__error();
      uint64_t v23 = *__error();
      CFStringRef v24 = __error();
      id v25 = strerror(*v24);
      CFStringRef v26 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"Unable to get pid list: %d (%s)", v23, v25);
      if (v26)
      {
        CFStringRef v27 = v26;
        CStringPtr = CFStringGetCStringPtr(v26, 0x8000100u);
        if (CStringPtr)
        {
          int v29 = (char *)CStringPtr;
          CFStringRef v30 = 0;
        }
        else
        {
          int v29 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x3970AD45uLL);
          CFStringGetCString(v27, v29, 1024, 0x8000100u);
          CFStringRef v30 = v29;
        }
        if (qword_1000EBD00) {
          id v160 = (FILE *)qword_1000EBD00;
        }
        else {
          id v160 = __stderrp;
        }
        fprintf(v160, "%s\n", v29);
        if (v30) {
          free(v30);
        }
        CFRelease(v27);
      }
      else
      {
        id v155 = sub_10002E548();
        if (os_log_type_enabled(v155, OS_LOG_TYPE_FAULT)) {
          sub_100091A50();
        }
        if (qword_1000EBD00) {
          id v156 = (FILE *)qword_1000EBD00;
        }
        else {
          id v156 = __stderrp;
        }
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v156);
      }
      *__error() = v22;
    }
    uint64_t v161 = *__error();
    id v162 = __error();
    [v7 appendFormat:@"Unable to get pid list for heap/ddt: %d %s\n", v161, strerror(*v162)];
  }
  else
  {
    uint64_t v11 = v10;
    if (byte_1000EBCF8)
    {
      int v12 = *__error();
      malloc_type_id_t v13 = sub_10002E548();
      if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 67109120;
        int v236 = v11;
        _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "Running heap/ddt for all (%d) processes", buf, 8u);
      }
      *__error() = v12;
    }
    if (byte_1000EBCF9 && dword_1000EB4A8 <= 2)
    {
      int v14 = *__error();
      CFStringRef v15 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"Running heap/ddt for all (%d) processes", v11);
      if (v15)
      {
        CFStringRef v16 = v15;
        BOOL v17 = CFStringGetCStringPtr(v15, 0x8000100u);
        if (v17)
        {
          int v18 = (char *)v17;
          CFStringRef v19 = 0;
        }
        else
        {
          int v18 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xDD07B922uLL);
          CFStringGetCString(v16, v18, 1024, 0x8000100u);
          CFStringRef v19 = v18;
        }
        if (qword_1000EBD00) {
          CFStringRef v33 = (FILE *)qword_1000EBD00;
        }
        else {
          CFStringRef v33 = __stderrp;
        }
        fprintf(v33, "%s\n", v18);
        if (v19) {
          free(v19);
        }
        CFRelease(v16);
      }
      else
      {
        CFStringRef v31 = sub_10002E548();
        if (os_log_type_enabled(v31, OS_LOG_TYPE_FAULT)) {
          sub_100091CAC();
        }
        if (qword_1000EBD00) {
          CFStringRef v32 = (FILE *)qword_1000EBD00;
        }
        else {
          CFStringRef v32 = __stderrp;
        }
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v32);
      }
      *__error() = v14;
    }
    qsort_b(v9, (int)v11, 4uLL, &stru_1000DD678);
    dsema = dispatch_semaphore_create(8);
    object = dispatch_group_create();
    int v34 = *(_DWORD *)(a1 + 60);
    if (v34)
    {
      dispatch_time_t v35 = *(void *)(a1 + 48);
      if (v34 >= 11) {
        dispatch_time_t v35 = dispatch_time(v35, 1000000000 * (v34 - 10));
      }
      dispatch_time_t timeout = v35;
    }
    else
    {
      dispatch_time_t timeout = -1;
    }
    id v36 = [objc_alloc((Class)NSMutableArray) initWithCapacity:2 * (int)v11];
    if ((int)v11 >= 1)
    {
      for (uint64_t i = 0; v11 != i; ++i)
      {
        int v39 = v9[i];
        if (v39 < 2 || v39 == getpid()) {
          goto LABEL_61;
        }
        int v40 = *(_DWORD *)(a1 + 60);
        if (v40)
        {
          double v41 = *(double *)&qword_1000EBCF0 + (double)v40;
          if (v41 - CFAbsoluteTimeGetCurrent() < 10.0) {
            goto LABEL_59;
          }
        }
        if (sub_1000240E8(v9[i]))
        {
          bzero(buf, 0x400uLL);
          if (proc_pidpath(v9[i], buf, 0x400u) < 1
            || !strnstr((const char *)buf, "dext", 0x400uLL)
            && !strnstr((const char *)buf, "/DriverExtensions/", 0x400uLL))
          {
            if (!dispatch_semaphore_wait(dsema, timeout))
            {
              int v43 = *(_DWORD *)(a1 + 60);
              if (v43)
              {
                double v44 = *(double *)&qword_1000EBCF0 + (double)v43;
                if (v44 - CFAbsoluteTimeGetCurrent() < 10.0)
                {
                  id v52 = +[NSString stringWithFormat:@"\nOut of time, skipping heap/ddt for %d\n", v9[i], v165, v166];
                  goto LABEL_78;
                }
              }
              if (!sub_1000240E8(v9[i]))
              {
                id v52 = +[NSString stringWithFormat:@"[%d] has exited, cannot take heap/ddt\n", v9[i], v165, v166];
                goto LABEL_78;
              }
              snprintf(__str, 8uLL, "%d", v9[i]);
              __int16 v229 = "/usr/bin/heap";
              id v230 = "--addresses=.*transaction.*";
              __int16 v231 = "--forkCorpseRetryTime=0";
              id v232 = __str;
              uint64_t v233 = 0;
              int v219 = -1;
              int v218 = -1;
              uint64_t v166 = 0;
              LOBYTE(v165) = 0;
              unsigned int v45 = SASpawnPlatformBinaryWithSigningIdentifier();
              id v207 = v7;
              id v208 = v36;
              if ((v45 & 0x80000000) == 0)
              {
                unsigned int v198 = v45;
                if (byte_1000EBCF8)
                {
                  int cf = *__error();
                  id v46 = sub_10002E548();
                  if (os_log_type_enabled(v46, OS_LOG_TYPE_DEBUG))
                  {
                    unsigned int v104 = v9[i];
                    *(_DWORD *)__int16 v223 = 136315394;
                    *(void *)id v224 = buf;
                    *(_WORD *)&v224[8] = 1024;
                    *(_DWORD *)&v224[10] = v104;
                    _os_log_debug_impl((void *)&_mh_execute_header, v46, OS_LOG_TYPE_DEBUG, "Running heap for %s [%d]", v223, 0x12u);
                  }
                  *__error() = cf;
                }
                if (byte_1000EBCF9 && dword_1000EB4A8 <= 0)
                {
                  int v47 = *__error();
                  CFStringRef v48 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"Running heap for %s [%d]", buf, v9[i], 0);
                  if (v48)
                  {
                    int v172 = v47;
                    CFStringRef v49 = v48;
                    id v50 = CFStringGetCStringPtr(v48, 0x8000100u);
                    CFStringRef cfa = v49;
                    if (v50)
                    {
                      id v51 = (char *)v50;
                      id v167 = 0;
                    }
                    else
                    {
                      id v51 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xF4632515uLL);
                      CFStringGetCString(v49, v51, 1024, 0x8000100u);
                      id v167 = v51;
                    }
                    if (qword_1000EBD00) {
                      id v73 = (FILE *)qword_1000EBD00;
                    }
                    else {
                      id v73 = __stderrp;
                    }
                    fprintf(v73, "%s\n", v51);
                    int v47 = v172;
                    if (v167) {
                      free(v167);
                    }
                    CFRelease(cfa);
                  }
                  else
                  {
                    id v71 = sub_10002E548();
                    if (os_log_type_enabled(v71, OS_LOG_TYPE_FAULT))
                    {
                      unsigned int v117 = v9[i];
                      *(_DWORD *)__int16 v223 = 136315394;
                      *(void *)id v224 = buf;
                      *(_WORD *)&v224[8] = 1024;
                      *(_DWORD *)&v224[10] = v117;
                      _os_log_fault_impl((void *)&_mh_execute_header, v71, OS_LOG_TYPE_FAULT, "Unable to format: Running heap for %s [%d]", v223, 0x12u);
                    }
                    if (qword_1000EBD00) {
                      id v72 = (FILE *)qword_1000EBD00;
                    }
                    else {
                      id v72 = __stderrp;
                    }
                    fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v72);
                  }
                  *__error() = v47;
                }
                dispatch_retain(object);
                id v74 = dsema;
                dispatch_retain(dsema);
                dispatch_group_enter(object);
                id v75 = [objc_alloc((Class)NSMutableString) initWithFormat:@"\nheap --addresses=.*transaction.* --forkCorpseRetryTime=0 %d\n", v9[i], v165];
                [v208 addObject:v75];
                v216[0] = _NSConcreteStackBlock;
                v216[1] = 3221225472;
                v216[2] = sub_10005A838;
                v216[3] = &unk_1000DD6A0;
                int v217 = i;
                v216[4] = v75;
                v216[5] = dsema;
                v216[6] = object;
                v216[7] = v9;
                sub_10005A50C(v198, v219, v218, (uint64_t)v75, (uint64_t)v216);
LABEL_127:
                if (dispatch_semaphore_wait(v74, timeout))
                {
                  id v36 = v208;
                  [v208 addObject:+[NSString stringWithFormat:](NSString, "stringWithFormat:", @"\nOut of time, skipping ddt for %d\n", v9[i])];
LABEL_129:
                  id v7 = v207;
                  goto LABEL_61;
                }
                int v81 = *(_DWORD *)(a1 + 60);
                id v7 = v207;
                id v36 = v208;
                if (v81 && (double v82 = *(double *)&qword_1000EBCF0 + (double)v81, v82 - CFAbsoluteTimeGetCurrent() < 10.0))
                {
                  id v52 = +[NSString stringWithFormat:@"\nOut of time, skipping ddt for %d\n", v9[i], v165, v166];
                }
                else if (sub_1000240E8(v9[i]))
                {
                  id v220 = "/usr/local/bin/ddt";
                  __int16 v221 = __str;
                  uint64_t v222 = 0;
                  int v215 = -1;
                  int v214 = -1;
                  uint64_t v166 = 0;
                  LOBYTE(v165) = 0;
                  unsigned int v83 = SASpawnPlatformBinaryWithSigningIdentifier();
                  if ((v83 & 0x80000000) == 0)
                  {
                    unsigned int v203 = v83;
                    if (byte_1000EBCF8)
                    {
                      int v84 = *__error();
                      id v85 = sub_10002E548();
                      if (os_log_type_enabled(v85, OS_LOG_TYPE_DEBUG))
                      {
                        unsigned int v125 = v9[i];
                        *(_DWORD *)__int16 v223 = 136315394;
                        *(void *)id v224 = buf;
                        *(_WORD *)&v224[8] = 1024;
                        *(_DWORD *)&v224[10] = v125;
                        _os_log_debug_impl((void *)&_mh_execute_header, v85, OS_LOG_TYPE_DEBUG, "Running ddt for %s [%d]", v223, 0x12u);
                      }
                      *__error() = v84;
                    }
                    if (byte_1000EBCF9 && dword_1000EB4A8 <= 0)
                    {
                      int v86 = *__error();
                      uint64_t v165 = v9[i];
                      CFStringRef v87 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"Running ddt for %s [%d]", buf);
                      if (v87)
                      {
                        int v176 = v86;
                        CFStringRef v88 = v87;
                        id v89 = CFStringGetCStringPtr(v87, 0x8000100u);
                        CFStringRef cfc = v88;
                        if (v89)
                        {
                          id v90 = (char *)v89;
                          id v91 = 0;
                        }
                        else
                        {
                          id v90 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xE9AFAE9AuLL);
                          CFStringGetCString(v88, v90, 1024, 0x8000100u);
                          id v91 = v90;
                        }
                        if (qword_1000EBD00) {
                          id v113 = (FILE *)qword_1000EBD00;
                        }
                        else {
                          id v113 = __stderrp;
                        }
                        fprintf(v113, "%s\n", v90);
                        int v86 = v176;
                        if (v91) {
                          free(v91);
                        }
                        CFRelease(cfc);
                      }
                      else
                      {
                        id v111 = sub_10002E548();
                        if (os_log_type_enabled(v111, OS_LOG_TYPE_FAULT))
                        {
                          unsigned int v130 = v9[i];
                          *(_DWORD *)__int16 v223 = 136315394;
                          *(void *)id v224 = buf;
                          *(_WORD *)&v224[8] = 1024;
                          *(_DWORD *)&v224[10] = v130;
                          _os_log_fault_impl((void *)&_mh_execute_header, v111, OS_LOG_TYPE_FAULT, "Unable to format: Running ddt for %s [%d]", v223, 0x12u);
                        }
                        if (qword_1000EBD00) {
                          id v112 = (FILE *)qword_1000EBD00;
                        }
                        else {
                          id v112 = __stderrp;
                        }
                        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v112);
                      }
                      *__error() = v86;
                    }
                    dispatch_retain(object);
                    dispatch_retain(dsema);
                    dispatch_group_enter(object);
                    id v114 = [objc_alloc((Class)NSMutableString) initWithFormat:@"\nddt %d\n", v9[i]];
                    id v36 = v208;
                    [v208 addObject:v114];
                    v212[0] = _NSConcreteStackBlock;
                    v212[1] = 3221225472;
                    v212[2] = sub_10005ACE0;
                    v212[3] = &unk_1000DD6A0;
                    int v213 = i;
                    v212[4] = v114;
                    v212[5] = dsema;
                    v212[6] = object;
                    v212[7] = v9;
                    sub_10005A50C(v203, v215, v214, (uint64_t)v114, (uint64_t)v212);
                    goto LABEL_129;
                  }
                  if ((v9[i] & 0x80000000) != 0)
                  {
                    if (byte_1000EBCF8)
                    {
                      int v206 = *__error();
                      id v105 = sub_10002E548();
                      if (os_log_type_enabled(v105, OS_LOG_TYPE_ERROR))
                      {
                        int cfl = *__error();
                        id v131 = __error();
                        id v132 = strerror(*v131);
                        *(_DWORD *)__int16 v223 = 67109378;
                        *(_DWORD *)id v224 = cfl;
                        *(_WORD *)&v224[4] = 2080;
                        *(void *)&v224[6] = v132;
                        _os_log_error_impl((void *)&_mh_execute_header, v105, OS_LOG_TYPE_ERROR, "Unable to spawn ddt: %d (%s)", v223, 0x12u);
                      }
                      *__error() = v206;
                    }
                    if (byte_1000EBCF9 && dword_1000EB4A8 <= 3)
                    {
                      int v205 = *__error();
                      uint64_t v106 = *__error();
                      id v107 = __error();
                      id v108 = strerror(*v107);
                      CFStringRef v97 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"Unable to spawn ddt: %d (%s)", v106, v108, 0);
                      if (v97) {
                        goto LABEL_162;
                      }
                      id v121 = sub_10002E548();
                      if (os_log_type_enabled(v121, OS_LOG_TYPE_FAULT))
                      {
                        int cfo = *__error();
                        id v133 = __error();
                        id v134 = strerror(*v133);
                        *(_DWORD *)__int16 v223 = 67109378;
                        *(_DWORD *)id v224 = cfo;
                        *(_WORD *)&v224[4] = 2080;
                        *(void *)&v224[6] = v134;
                        id v101 = v121;
                        id v102 = "Unable to format: Unable to spawn ddt: %d (%s)";
                        uint32_t v103 = 18;
LABEL_196:
                        _os_log_fault_impl((void *)&_mh_execute_header, v101, OS_LOG_TYPE_FAULT, v102, v223, v103);
                      }
LABEL_187:
                      if (qword_1000EBD00) {
                        id v122 = (FILE *)qword_1000EBD00;
                      }
                      else {
                        id v122 = __stderrp;
                      }
                      fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v122);
LABEL_191:
                      *__error() = v205;
                    }
                  }
                  else
                  {
                    if (byte_1000EBCF8)
                    {
                      int v204 = *__error();
                      id v92 = sub_10002E548();
                      if (os_log_type_enabled(v92, OS_LOG_TYPE_ERROR))
                      {
                        id v181 = sub_10002E4E8(v9[i]);
                        cfuint64_t i = v9[i];
                        int v171 = *__error();
                        id v128 = __error();
                        id v129 = strerror(*v128);
                        *(_DWORD *)__int16 v223 = 136446978;
                        *(void *)id v224 = v181;
                        *(_WORD *)&v224[8] = 1024;
                        *(_DWORD *)&v224[10] = cfi;
                        __int16 v225 = 1024;
                        int v226 = v171;
                        __int16 v227 = 2080;
                        id v228 = v129;
                        _os_log_error_impl((void *)&_mh_execute_header, v92, OS_LOG_TYPE_ERROR, "%{public}s [%d]: Unable to spawn ddt: %d (%s)", v223, 0x22u);
                      }
                      *__error() = v204;
                    }
                    if (byte_1000EBCF9 && dword_1000EB4A8 <= 3)
                    {
                      int v205 = *__error();
                      id v93 = sub_10002E4E8(v9[i]);
                      id v177 = (void *)v9[i];
                      CFTypeRef cfj = v93;
                      uint64_t v94 = *__error();
                      id v95 = __error();
                      id v96 = strerror(*v95);
                      CFStringRef v97 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%s [%d]: Unable to spawn ddt: %d (%s)", cfj, v177, v94, v96);
                      if (!v97)
                      {
                        id v98 = sub_10002E548();
                        if (os_log_type_enabled(v98, OS_LOG_TYPE_FAULT))
                        {
                          id v178 = sub_10002E4E8(v9[i]);
                          unsigned int cfk = v9[i];
                          int v169 = *__error();
                          id v99 = __error();
                          id v100 = strerror(*v99);
                          *(_DWORD *)__int16 v223 = 136315906;
                          *(void *)id v224 = v178;
                          *(_WORD *)&v224[8] = 1024;
                          *(_DWORD *)&v224[10] = cfk;
                          __int16 v225 = 1024;
                          int v226 = v169;
                          __int16 v227 = 2080;
                          id v228 = v100;
                          id v101 = v98;
                          id v102 = "Unable to format: %s [%d]: Unable to spawn ddt: %d (%s)";
                          uint32_t v103 = 34;
                          goto LABEL_196;
                        }
                        goto LABEL_187;
                      }
LABEL_162:
                      CFStringRef cfd = v97;
                      id v109 = CFStringGetCStringPtr(v97, 0x8000100u);
                      if (v109)
                      {
                        id v110 = (char *)v109;
                        id v179 = 0;
                      }
                      else
                      {
                        id v110 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x763578B6uLL);
                        CFStringGetCString(cfd, v110, 1024, 0x8000100u);
                        id v179 = v110;
                      }
                      if (qword_1000EBD00) {
                        id v118 = (FILE *)qword_1000EBD00;
                      }
                      else {
                        id v118 = __stderrp;
                      }
                      fprintf(v118, "%s\n", v110);
                      if (v179) {
                        free(v179);
                      }
                      CFRelease(cfd);
                      goto LABEL_191;
                    }
                  }
                  CFTypeRef cfm = (CFTypeRef)v9[i];
                  uint64_t v123 = *__error();
                  id v124 = __error();
                  id v52 = +[NSString stringWithFormat:@"Unable to spawn ddt for %d: %d %s\n", cfm, v123, strerror(*v124)];
                }
                else
                {
                  id v52 = +[NSString stringWithFormat:@"[%d] has exited, cannot take ddt\n", v9[i], v165, v166];
                }
LABEL_78:
                [v36 addObject:v52];
                dispatch_semaphore_signal(dsema);
                goto LABEL_61;
              }
              if ((v9[i] & 0x80000000) != 0)
              {
                if (byte_1000EBCF8)
                {
                  int v201 = *__error();
                  uint64_t v65 = sub_10002E548();
                  if (os_log_type_enabled(v65, OS_LOG_TYPE_ERROR))
                  {
                    int cfh = *__error();
                    id v119 = __error();
                    id v120 = strerror(*v119);
                    *(_DWORD *)__int16 v223 = 67109378;
                    *(_DWORD *)id v224 = cfh;
                    *(_WORD *)&v224[4] = 2080;
                    *(void *)&v224[6] = v120;
                    _os_log_error_impl((void *)&_mh_execute_header, v65, OS_LOG_TYPE_ERROR, "Unable to spawn heap: %d (%s)", v223, 0x12u);
                  }
                  *__error() = v201;
                }
                if (byte_1000EBCF9 && dword_1000EB4A8 <= 3)
                {
                  int v200 = *__error();
                  uint64_t v66 = *__error();
                  id v67 = __error();
                  id v68 = strerror(*v67);
                  CFStringRef v58 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"Unable to spawn heap: %d (%s)", v66, v68, 0);
                  if (v58) {
                    goto LABEL_96;
                  }
                  id v77 = sub_10002E548();
                  if (os_log_type_enabled(v77, OS_LOG_TYPE_FAULT))
                  {
                    int cfn = *__error();
                    id v126 = __error();
                    id v127 = strerror(*v126);
                    *(_DWORD *)__int16 v223 = 67109378;
                    *(_DWORD *)id v224 = cfn;
                    *(_WORD *)&v224[4] = 2080;
                    *(void *)&v224[6] = v127;
                    uint64_t v62 = v77;
                    id v63 = "Unable to format: Unable to spawn heap: %d (%s)";
                    uint32_t v64 = 18;
LABEL_194:
                    _os_log_fault_impl((void *)&_mh_execute_header, v62, OS_LOG_TYPE_FAULT, v63, v223, v64);
                  }
LABEL_121:
                  if (qword_1000EBD00) {
                    id v78 = (FILE *)qword_1000EBD00;
                  }
                  else {
                    id v78 = __stderrp;
                  }
                  fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v78);
LABEL_125:
                  *__error() = v200;
                }
              }
              else
              {
                if (byte_1000EBCF8)
                {
                  int v199 = *__error();
                  BOOL v53 = sub_10002E548();
                  if (os_log_type_enabled(v53, OS_LOG_TYPE_ERROR))
                  {
                    id v180 = sub_10002E4E8(v9[i]);
                    unsigned int cfe = v9[i];
                    int v170 = *__error();
                    id v115 = __error();
                    id v116 = strerror(*v115);
                    *(_DWORD *)__int16 v223 = 136446978;
                    *(void *)id v224 = v180;
                    *(_WORD *)&v224[8] = 1024;
                    *(_DWORD *)&v224[10] = cfe;
                    __int16 v225 = 1024;
                    int v226 = v170;
                    __int16 v227 = 2080;
                    id v228 = v116;
                    _os_log_error_impl((void *)&_mh_execute_header, v53, OS_LOG_TYPE_ERROR, "%{public}s [%d]: Unable to spawn heap: %d (%s)", v223, 0x22u);
                  }
                  *__error() = v199;
                }
                if (byte_1000EBCF9 && dword_1000EB4A8 <= 3)
                {
                  int v200 = *__error();
                  uint64_t v54 = sub_10002E4E8(v9[i]);
                  id v173 = (void *)v9[i];
                  CFTypeRef cff = v54;
                  uint64_t v55 = *__error();
                  id v56 = __error();
                  uint64_t v57 = strerror(*v56);
                  CFStringRef v58 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%s [%d]: Unable to spawn heap: %d (%s)", cff, v173, v55, v57);
                  if (!v58)
                  {
                    CFStringRef v59 = sub_10002E548();
                    if (os_log_type_enabled(v59, OS_LOG_TYPE_FAULT))
                    {
                      id v174 = sub_10002E4E8(v9[i]);
                      unsigned int cfg = v9[i];
                      int v168 = *__error();
                      int v60 = __error();
                      CFStringRef v61 = strerror(*v60);
                      *(_DWORD *)__int16 v223 = 136315906;
                      *(void *)id v224 = v174;
                      *(_WORD *)&v224[8] = 1024;
                      *(_DWORD *)&v224[10] = cfg;
                      __int16 v225 = 1024;
                      int v226 = v168;
                      __int16 v227 = 2080;
                      id v228 = v61;
                      uint64_t v62 = v59;
                      id v63 = "Unable to format: %s [%d]: Unable to spawn heap: %d (%s)";
                      uint32_t v64 = 34;
                      goto LABEL_194;
                    }
                    goto LABEL_121;
                  }
LABEL_96:
                  CFStringRef cfb = v58;
                  id v69 = CFStringGetCStringPtr(v58, 0x8000100u);
                  if (v69)
                  {
                    id v70 = (char *)v69;
                    id v175 = 0;
                  }
                  else
                  {
                    id v70 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xD2AA5B1CuLL);
                    CFStringGetCString(cfb, v70, 1024, 0x8000100u);
                    id v175 = v70;
                  }
                  if (qword_1000EBD00) {
                    id v76 = (FILE *)qword_1000EBD00;
                  }
                  else {
                    id v76 = __stderrp;
                  }
                  fprintf(v76, "%s\n", v70);
                  if (v175) {
                    free(v175);
                  }
                  CFRelease(cfb);
                  goto LABEL_125;
                }
              }
              uint64_t v202 = v9[i];
              uint64_t v79 = *__error();
              id v80 = __error();
              [v36 addObject:+[NSString stringWithFormat:](NSString, "stringWithFormat:", @"Unable to spawn heap for %d: %d %s\n", v202, v79, strerror(*v80))];
              id v74 = dsema;
              dispatch_semaphore_signal(dsema);
              goto LABEL_127;
            }
LABEL_59:
            id v42 = +[NSString stringWithFormat:@"\nOut of time, skipping heap/ddt for %d\n", v9[i]];
            goto LABEL_60;
          }
          id v42 = +[NSString stringWithFormat:@"[%d] is DriverKit, skipping heap/ddt\n", v9[i]];
        }
        else
        {
          id v42 = +[NSString stringWithFormat:@"[%d] has exited, cannot take heap/ddt\n", v9[i]];
        }
LABEL_60:
        [v36 addObject:v42];
LABEL_61:
      }
    }
    if (dispatch_group_wait(object, timeout))
    {
      if (byte_1000EBCF8)
      {
        int v135 = *__error();
        id v136 = sub_10002E548();
        if (os_log_type_enabled(v136, OS_LOG_TYPE_ERROR)) {
          sub_100091C38();
        }
        *__error() = v135;
      }
      if (byte_1000EBCF9) {
        BOOL v137 = dword_1000EB4A8 <= 3;
      }
      else {
        BOOL v137 = 0;
      }
      if (v137)
      {
        int v138 = *__error();
        CFStringRef v139 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"Timed out running heap/ddt for all (%d) processes", v11);
        if (v139)
        {
          CFStringRef v140 = v139;
          id v141 = CFStringGetCStringPtr(v139, 0x8000100u);
          if (v141)
          {
            id v142 = (char *)v141;
            id v143 = 0;
          }
          else
          {
            id v142 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x58E719CFuLL);
            CFStringGetCString(v140, v142, 1024, 0x8000100u);
            id v143 = v142;
          }
          if (qword_1000EBD00) {
            id v157 = (FILE *)qword_1000EBD00;
          }
          else {
            id v157 = __stderrp;
          }
          fprintf(v157, "%s\n", v142);
          if (v143) {
            free(v143);
          }
          CFRelease(v140);
        }
        else
        {
          id v153 = sub_10002E548();
          if (os_log_type_enabled(v153, OS_LOG_TYPE_FAULT)) {
            sub_100091BCC();
          }
          if (qword_1000EBD00) {
            id v154 = (FILE *)qword_1000EBD00;
          }
          else {
            id v154 = __stderrp;
          }
          fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v154);
        }
        *__error() = v138;
      }
      [v7 appendFormat:@"Timed out waiting for heap/ddt, last %d heap/ddt invocations may be truncated\n", 8];
    }
    else
    {
      if (byte_1000EBCF8)
      {
        int v144 = *__error();
        id v145 = sub_10002E548();
        if (os_log_type_enabled(v145, OS_LOG_TYPE_INFO))
        {
          *(_DWORD *)buf = 67109120;
          int v236 = v11;
          _os_log_impl((void *)&_mh_execute_header, v145, OS_LOG_TYPE_INFO, "Done running heap/ddt for all (%d) processes", buf, 8u);
        }
        *__error() = v144;
      }
      if (byte_1000EBCF9) {
        BOOL v146 = dword_1000EB4A8 <= 1;
      }
      else {
        BOOL v146 = 0;
      }
      if (v146)
      {
        int v147 = *__error();
        CFStringRef v148 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"Done running heap/ddt for all (%d) processes", v11);
        if (v148)
        {
          CFStringRef v149 = v148;
          id v150 = CFStringGetCStringPtr(v148, 0x8000100u);
          if (v150)
          {
            id v151 = (char *)v150;
            id v152 = 0;
          }
          else
          {
            id v151 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x22DCC959uLL);
            CFStringGetCString(v149, v151, 1024, 0x8000100u);
            id v152 = v151;
          }
          if (qword_1000EBD00) {
            id v163 = (FILE *)qword_1000EBD00;
          }
          else {
            id v163 = __stderrp;
          }
          fprintf(v163, "%s\n", v151);
          if (v152) {
            free(v152);
          }
          CFRelease(v149);
        }
        else
        {
          id v158 = sub_10002E548();
          if (os_log_type_enabled(v158, OS_LOG_TYPE_FAULT)) {
            sub_100091B60();
          }
          if (qword_1000EBD00) {
            id v159 = (FILE *)qword_1000EBD00;
          }
          else {
            id v159 = __stderrp;
          }
          fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v159);
        }
        *__error() = v147;
      }
    }
    dispatch_release(object);
    dispatch_release(dsema);
    [v7 appendString:[v36 componentsJoinedByString:&stru_1000E0D58]];
  }
  [a2 setCustomOutput:v7];

  return [a2 performSamplePrinterWork:&stru_1000DD6E0];
}

int sub_10005A4FC(id a1, const void *a2, const void *a3)
{
  return *(_DWORD *)a2 - *(_DWORD *)a3;
}

void sub_10005A50C(unsigned int a1, int a2, int a3, uint64_t a4, uint64_t a5)
{
  BOOL v9 = dispatch_queue_attr_make_with_autorelease_frequency(0, DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM);
  uint64_t v10 = dispatch_queue_create("com.apple.spindump.readchildren", v9);
  fcntl(a2, 4, 4);
  fcntl(a3, 4, 4);
  v28[0] = 0;
  v28[1] = v28;
  v28[2] = 0x2020000000;
  int v29 = 0;
  int v29 = malloc_type_calloc(1uLL, 0x400uLL, 0xF79D37D3uLL);
  uint64_t v11 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_read, a2, 0, v10);
  handler[0] = _NSConcreteStackBlock;
  handler[1] = 3221225472;
  handler[2] = sub_10005EBC4;
  handler[3] = &unk_1000DD818;
  int v27 = a2;
  void handler[4] = a4;
  void handler[5] = v28;
  dispatch_source_set_event_handler(v11, handler);
  v24[0] = _NSConcreteStackBlock;
  v24[1] = 3221225472;
  v24[2] = sub_10005EC60;
  v24[3] = &unk_1000DD840;
  int v25 = a2;
  v24[4] = v11;
  dispatch_source_set_cancel_handler(v11, v24);
  dispatch_activate(v11);
  int v12 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_read, a3, 0, v10);
  v22[0] = _NSConcreteStackBlock;
  v22[1] = 3221225472;
  v22[2] = sub_10005EC9C;
  v22[3] = &unk_1000DD818;
  int v23 = a3;
  v22[4] = a4;
  v22[5] = v28;
  dispatch_source_set_event_handler(v12, v22);
  v20[0] = _NSConcreteStackBlock;
  v20[1] = 3221225472;
  v20[2] = sub_10005ED38;
  v20[3] = &unk_1000DD840;
  int v21 = a3;
  v20[4] = v12;
  dispatch_source_set_cancel_handler(v12, v20);
  dispatch_activate(v12);
  malloc_type_id_t v13 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_proc, a1, 0x80000000uLL, v10);
  v16[0] = _NSConcreteStackBlock;
  v16[1] = 3221225472;
  v16[2] = sub_10005ED74;
  v16[3] = &unk_1000DD868;
  v16[4] = v11;
  void v16[5] = v12;
  unsigned int v17 = a1;
  int v18 = a2;
  int v19 = a3;
  v16[6] = v13;
  v16[7] = a4;
  v16[8] = a5;
  v16[9] = v28;
  dispatch_source_set_event_handler(v13, v16);
  v15[0] = _NSConcreteStackBlock;
  v15[1] = 3221225472;
  v15[2] = sub_10005EF14;
  v15[3] = &unk_1000DD618;
  v15[4] = v13;
  dispatch_source_set_cancel_handler(v13, v15);
  dispatch_activate(v13);
  dispatch_release(v10);
  _Block_object_dispose(v28, 8);
}

void sub_10005A838(uint64_t a1)
{
  if (![*(id *)(a1 + 32) length])
  {
    int v2 = (void *)(a1 + 56);
    BOOL v3 = (int *)(a1 + 64);
    if ((*(_DWORD *)(*(void *)(a1 + 56) + 4 * *(int *)(a1 + 64)) & 0x80000000) != 0)
    {
      if (byte_1000EBCF8)
      {
        int v11 = *__error();
        int v12 = sub_10002E548();
        if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR)) {
          sub_100091F50();
        }
        *__error() = v11;
      }
      if (byte_1000EBCF9) {
        BOOL v13 = dword_1000EB4A8 <= 3;
      }
      else {
        BOOL v13 = 0;
      }
      if (!v13) {
        goto LABEL_41;
      }
      int v7 = *__error();
      CFStringRef v9 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"No output from heap for %d", *(unsigned int *)(*v2 + 4 * *v3));
      if (!v9)
      {
        int v19 = sub_10002E548();
        if (os_log_type_enabled(v19, OS_LOG_TYPE_FAULT)) {
          sub_100091EE8();
        }
        goto LABEL_36;
      }
    }
    else
    {
      if (byte_1000EBCF8)
      {
        int v4 = *__error();
        CFStringRef v5 = sub_10002E548();
        if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR)) {
          sub_100091E68();
        }
        *__error() = v4;
      }
      if (byte_1000EBCF9) {
        BOOL v6 = dword_1000EB4A8 <= 3;
      }
      else {
        BOOL v6 = 0;
      }
      if (!v6) {
        goto LABEL_41;
      }
      int v7 = *__error();
      int v8 = sub_10002E4E8(*(_DWORD *)(*v2 + 4 * *v3));
      CFStringRef v9 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%s [%d]: No output from heap for %d", v8, *(unsigned int *)(*v2 + 4 * *v3), *(unsigned int *)(*v2 + 4 * *v3));
      if (!v9)
      {
        uint64_t v10 = sub_10002E548();
        if (os_log_type_enabled(v10, OS_LOG_TYPE_FAULT)) {
          sub_100091DE8();
        }
LABEL_36:
        if (qword_1000EBD00) {
          int v20 = (FILE *)qword_1000EBD00;
        }
        else {
          int v20 = __stderrp;
        }
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v20);
LABEL_40:
        *__error() = v7;
LABEL_41:
        [*(id *)(a1 + 32) appendFormat:@"No output from heap for %d\n", *(unsigned int *)(*(void *)(a1 + 56) + 4 * *(int *)(a1 + 64))];
        goto LABEL_42;
      }
    }
    CFStringRef v14 = v9;
    CStringPtr = CFStringGetCStringPtr(v9, 0x8000100u);
    if (CStringPtr)
    {
      CFStringRef v16 = (char *)CStringPtr;
      unsigned int v17 = 0;
    }
    else
    {
      CFStringRef v16 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x1A296697uLL);
      CFStringGetCString(v14, v16, 1024, 0x8000100u);
      unsigned int v17 = v16;
    }
    if (qword_1000EBD00) {
      int v18 = (FILE *)qword_1000EBD00;
    }
    else {
      int v18 = __stderrp;
    }
    fprintf(v18, "%s\n", v16);
    if (v17) {
      free(v17);
    }
    CFRelease(v14);
    goto LABEL_40;
  }
LABEL_42:

  if (byte_1000EBCF8)
  {
    int v21 = *__error();
    int v22 = sub_10002E548();
    if (os_log_type_enabled(v22, OS_LOG_TYPE_DEBUG)) {
      sub_100091D80();
    }
    *__error() = v21;
  }
  if (byte_1000EBCF9) {
    BOOL v23 = dword_1000EB4A8 <= 0;
  }
  else {
    BOOL v23 = 0;
  }
  if (v23)
  {
    int v24 = *__error();
    CFStringRef v25 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"heap for [%d] completed", *(unsigned int *)(*(void *)(a1 + 56) + 4 * *(int *)(a1 + 64)));
    if (v25)
    {
      CFStringRef v26 = v25;
      int v27 = CFStringGetCStringPtr(v25, 0x8000100u);
      if (v27)
      {
        BOOL v28 = (char *)v27;
        int v29 = 0;
      }
      else
      {
        BOOL v28 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x2807575AuLL);
        CFStringGetCString(v26, v28, 1024, 0x8000100u);
        int v29 = v28;
      }
      if (qword_1000EBD00) {
        CFStringRef v32 = (FILE *)qword_1000EBD00;
      }
      else {
        CFStringRef v32 = __stderrp;
      }
      fprintf(v32, "%s\n", v28);
      if (v29) {
        free(v29);
      }
      CFRelease(v26);
    }
    else
    {
      CFStringRef v30 = sub_10002E548();
      if (os_log_type_enabled(v30, OS_LOG_TYPE_FAULT)) {
        sub_100091D18();
      }
      if (qword_1000EBD00) {
        CFStringRef v31 = (FILE *)qword_1000EBD00;
      }
      else {
        CFStringRef v31 = __stderrp;
      }
      fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v31);
    }
    *__error() = v24;
  }
  dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 40));
  dispatch_group_leave(*(dispatch_group_t *)(a1 + 48));
  dispatch_release(*(dispatch_object_t *)(a1 + 48));
  dispatch_release(*(dispatch_object_t *)(a1 + 40));
}

void sub_10005ACE0(uint64_t a1)
{
  if (![*(id *)(a1 + 32) length])
  {
    int v2 = (void *)(a1 + 56);
    BOOL v3 = (int *)(a1 + 64);
    if ((*(_DWORD *)(*(void *)(a1 + 56) + 4 * *(int *)(a1 + 64)) & 0x80000000) != 0)
    {
      if (byte_1000EBCF8)
      {
        int v11 = *__error();
        int v12 = sub_10002E548();
        if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR)) {
          sub_1000921F0();
        }
        *__error() = v11;
      }
      if (byte_1000EBCF9) {
        BOOL v13 = dword_1000EB4A8 <= 3;
      }
      else {
        BOOL v13 = 0;
      }
      if (!v13) {
        goto LABEL_41;
      }
      int v7 = *__error();
      CFStringRef v9 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"No output from ddt for %d", *(unsigned int *)(*v2 + 4 * *v3));
      if (!v9)
      {
        int v19 = sub_10002E548();
        if (os_log_type_enabled(v19, OS_LOG_TYPE_FAULT)) {
          sub_100092188();
        }
        goto LABEL_36;
      }
    }
    else
    {
      if (byte_1000EBCF8)
      {
        int v4 = *__error();
        CFStringRef v5 = sub_10002E548();
        if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR)) {
          sub_100092108();
        }
        *__error() = v4;
      }
      if (byte_1000EBCF9) {
        BOOL v6 = dword_1000EB4A8 <= 3;
      }
      else {
        BOOL v6 = 0;
      }
      if (!v6) {
        goto LABEL_41;
      }
      int v7 = *__error();
      int v8 = sub_10002E4E8(*(_DWORD *)(*v2 + 4 * *v3));
      CFStringRef v9 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%s [%d]: No output from ddt for %d", v8, *(unsigned int *)(*v2 + 4 * *v3), *(unsigned int *)(*v2 + 4 * *v3));
      if (!v9)
      {
        uint64_t v10 = sub_10002E548();
        if (os_log_type_enabled(v10, OS_LOG_TYPE_FAULT)) {
          sub_100092088();
        }
LABEL_36:
        if (qword_1000EBD00) {
          int v20 = (FILE *)qword_1000EBD00;
        }
        else {
          int v20 = __stderrp;
        }
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v20);
LABEL_40:
        *__error() = v7;
LABEL_41:
        [*(id *)(a1 + 32) appendFormat:@"No output from ddt for %d\n", *(unsigned int *)(*(void *)(a1 + 56) + 4 * *(int *)(a1 + 64))];
        goto LABEL_42;
      }
    }
    CFStringRef v14 = v9;
    CStringPtr = CFStringGetCStringPtr(v9, 0x8000100u);
    if (CStringPtr)
    {
      CFStringRef v16 = (char *)CStringPtr;
      unsigned int v17 = 0;
    }
    else
    {
      CFStringRef v16 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xC9814882uLL);
      CFStringGetCString(v14, v16, 1024, 0x8000100u);
      unsigned int v17 = v16;
    }
    if (qword_1000EBD00) {
      int v18 = (FILE *)qword_1000EBD00;
    }
    else {
      int v18 = __stderrp;
    }
    fprintf(v18, "%s\n", v16);
    if (v17) {
      free(v17);
    }
    CFRelease(v14);
    goto LABEL_40;
  }
LABEL_42:

  if (byte_1000EBCF8)
  {
    int v21 = *__error();
    int v22 = sub_10002E548();
    if (os_log_type_enabled(v22, OS_LOG_TYPE_DEBUG)) {
      sub_100092020();
    }
    *__error() = v21;
  }
  if (byte_1000EBCF9) {
    BOOL v23 = dword_1000EB4A8 <= 0;
  }
  else {
    BOOL v23 = 0;
  }
  if (v23)
  {
    int v24 = *__error();
    CFStringRef v25 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"ddt for [%d] completed", *(unsigned int *)(*(void *)(a1 + 56) + 4 * *(int *)(a1 + 64)));
    if (v25)
    {
      CFStringRef v26 = v25;
      int v27 = CFStringGetCStringPtr(v25, 0x8000100u);
      if (v27)
      {
        BOOL v28 = (char *)v27;
        int v29 = 0;
      }
      else
      {
        BOOL v28 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xAD774FBFuLL);
        CFStringGetCString(v26, v28, 1024, 0x8000100u);
        int v29 = v28;
      }
      if (qword_1000EBD00) {
        CFStringRef v32 = (FILE *)qword_1000EBD00;
      }
      else {
        CFStringRef v32 = __stderrp;
      }
      fprintf(v32, "%s\n", v28);
      if (v29) {
        free(v29);
      }
      CFRelease(v26);
    }
    else
    {
      CFStringRef v30 = sub_10002E548();
      if (os_log_type_enabled(v30, OS_LOG_TYPE_FAULT)) {
        sub_100091FB8();
      }
      if (qword_1000EBD00) {
        CFStringRef v31 = (FILE *)qword_1000EBD00;
      }
      else {
        CFStringRef v31 = __stderrp;
      }
      fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v31);
    }
    *__error() = v24;
  }
  dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 40));
  dispatch_group_leave(*(dispatch_group_t *)(a1 + 48));
  dispatch_release(*(dispatch_object_t *)(a1 + 48));
  dispatch_release(*(dispatch_object_t *)(a1 + 40));
}

void sub_10005B188(id a1, SASamplePrinter *a2)
{
  if (sub_10004BC40(a2, 0.0, 0.0, 0, 0, 4, 0, 0, 0, 0, 0, 0))
  {
    if (byte_1000EBCF8)
    {
      int v2 = *__error();
      BOOL v3 = sub_10002E548();
      if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Saved shutdown report", buf, 2u);
      }
      *__error() = v2;
    }
    if (byte_1000EBCF9) {
      BOOL v4 = dword_1000EB4A8 <= 2;
    }
    else {
      BOOL v4 = 0;
    }
    if (v4)
    {
      int v5 = *__error();
      CFStringRef v6 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"Saved shutdown report");
      if (v6)
      {
        CFStringRef v16 = v6;
        CStringPtr = CFStringGetCStringPtr(v6, 0x8000100u);
        if (CStringPtr)
        {
          int v18 = (char *)CStringPtr;
          int v19 = 0;
        }
        else
        {
          int v18 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xBD8ED855uLL);
          CFStringGetCString(v16, v18, 1024, 0x8000100u);
          int v19 = v18;
        }
        if (qword_1000EBD00) {
          int v24 = (FILE *)qword_1000EBD00;
        }
        else {
          int v24 = __stderrp;
        }
        fprintf(v24, "%s\n", v18);
        if (v19) {
          free(v19);
        }
        CFRelease(v16);
      }
      else
      {
        int v7 = sub_10002E548();
        if (os_log_type_enabled(v7, OS_LOG_TYPE_FAULT))
        {
          *(_WORD *)CFStringRef v26 = 0;
          _os_log_fault_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_FAULT, "Unable to format: Saved shutdown report", v26, 2u);
        }
        if (qword_1000EBD00) {
          int v8 = (FILE *)qword_1000EBD00;
        }
        else {
          int v8 = __stderrp;
        }
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v8);
      }
      *__error() = v5;
    }
    exit(0);
  }
  if (byte_1000EBCF8)
  {
    int v9 = *__error();
    uint64_t v10 = sub_10002E548();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)int v29 = 0;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "Failed to save shutdown report", v29, 2u);
    }
    *__error() = v9;
  }
  if (byte_1000EBCF9) {
    BOOL v11 = dword_1000EB4A8 <= 2;
  }
  else {
    BOOL v11 = 0;
  }
  if (v11)
  {
    int v12 = *__error();
    CFStringRef v13 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"Failed to save shutdown report");
    if (v13)
    {
      CFStringRef v20 = v13;
      int v21 = CFStringGetCStringPtr(v13, 0x8000100u);
      if (v21)
      {
        int v22 = (char *)v21;
        BOOL v23 = 0;
      }
      else
      {
        int v22 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x7D62EB02uLL);
        CFStringGetCString(v20, v22, 1024, 0x8000100u);
        BOOL v23 = v22;
      }
      if (qword_1000EBD00) {
        CFStringRef v25 = (FILE *)qword_1000EBD00;
      }
      else {
        CFStringRef v25 = __stderrp;
      }
      fprintf(v25, "%s\n", v22);
      if (v23) {
        free(v23);
      }
      CFRelease(v20);
    }
    else
    {
      CFStringRef v14 = sub_10002E548();
      if (os_log_type_enabled(v14, OS_LOG_TYPE_FAULT))
      {
        *(_WORD *)BOOL v28 = 0;
        _os_log_fault_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_FAULT, "Unable to format: Failed to save shutdown report", v28, 2u);
      }
      if (qword_1000EBD00) {
        CFStringRef v15 = (FILE *)qword_1000EBD00;
      }
      else {
        CFStringRef v15 = __stderrp;
      }
      fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v15);
    }
    *__error() = v12;
  }
  exit(69);
}

id sub_10005B550(uint64_t a1, NSObject *a2)
{
  SAMachAbsTimeSecondsGetCurrent();
  double v5 = v4;
  id v6 = +[SPSampledProcess allSampledProcesses];
  if (byte_1000EBC30)
  {
    double v7 = v5 - *(double *)&qword_1000EBC28;
    if (v5 - *(double *)&qword_1000EBC28 > 1.0)
    {
      if (byte_1000EBCF8)
      {
        int v65 = *__error();
        uint64_t v66 = sub_10002E548();
        if (os_log_type_enabled(v66, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 134217984;
          double v84 = COERCE_DOUBLE(dispatch_source_get_handle(a2));
          _os_log_impl((void *)&_mh_execute_header, v66, OS_LOG_TYPE_DEFAULT, "Interrupted again by signal %ld, exiting", buf, 0xCu);
        }
        *__error() = v65;
      }
      if (byte_1000EBCF9) {
        BOOL v67 = dword_1000EB4A8 <= 2;
      }
      else {
        BOOL v67 = 0;
      }
      if (v67)
      {
        int v68 = *__error();
        uintptr_t handle = dispatch_source_get_handle(a2);
        CFStringRef v70 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"Interrupted again by signal %ld, exiting", handle);
        if (v70)
        {
          CFStringRef v73 = v70;
          CStringPtr = CFStringGetCStringPtr(v70, 0x8000100u);
          if (CStringPtr)
          {
            id v75 = (char *)CStringPtr;
            id v76 = 0;
          }
          else
          {
            id v75 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x9D326124uLL);
            CFStringGetCString(v73, v75, 1024, 0x8000100u);
            id v76 = v75;
          }
          if (qword_1000EBD00) {
            id v77 = (FILE *)qword_1000EBD00;
          }
          else {
            id v77 = __stderrp;
          }
          fprintf(v77, "%s\n", v75);
          if (v76) {
            free(v76);
          }
          CFRelease(v73);
        }
        else
        {
          id v71 = sub_10002E548();
          if (os_log_type_enabled(v71, OS_LOG_TYPE_FAULT)) {
            sub_100092258(a2);
          }
          if (qword_1000EBD00) {
            id v72 = (FILE *)qword_1000EBD00;
          }
          else {
            id v72 = __stderrp;
          }
          fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v72);
        }
        *__error() = v68;
      }
      exit(75);
    }
    if (byte_1000EBCF8)
    {
      int v8 = *__error();
      int v9 = sub_10002E548();
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 134218240;
        double v84 = v5 - *(double *)&qword_1000EBC28;
        __int16 v85 = 2048;
        uintptr_t v86 = dispatch_source_get_handle(a2);
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "Interrupted again after %.2f seconds by signal %ld, not exiting", buf, 0x16u);
      }
      *__error() = v8;
    }
    if (byte_1000EBCF9) {
      BOOL v10 = dword_1000EB4A8 <= 2;
    }
    else {
      BOOL v10 = 0;
    }
    if (v10)
    {
      int v11 = *__error();
      double v12 = v5 - *(double *)&qword_1000EBC28;
      uintptr_t v13 = dispatch_source_get_handle(a2);
      CFStringRef v14 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"Interrupted again after %.2f seconds by signal %ld, not exiting", *(void *)&v12, v13);
      if (v14)
      {
        CFStringRef v15 = v14;
        CFStringRef v16 = CFStringGetCStringPtr(v14, 0x8000100u);
        if (v16)
        {
          unsigned int v17 = (char *)v16;
          int v18 = 0;
        }
        else
        {
          unsigned int v17 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x1A09CBB6uLL);
          CFStringGetCString(v15, v17, 1024, 0x8000100u);
          int v18 = v17;
        }
        if (qword_1000EBD00) {
          int v21 = (FILE *)qword_1000EBD00;
        }
        else {
          int v21 = __stderrp;
        }
        fprintf(v21, "%s\n", v17);
        if (v18) {
          free(v18);
        }
        CFRelease(v15);
      }
      else
      {
        int v19 = sub_10002E548();
        if (os_log_type_enabled(v19, OS_LOG_TYPE_FAULT)) {
          sub_100092450(a2);
        }
        if (qword_1000EBD00) {
          CFStringRef v20 = (FILE *)qword_1000EBD00;
        }
        else {
          CFStringRef v20 = __stderrp;
        }
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v20);
      }
      *__error() = v11;
    }
  }
  else
  {
    qword_1000EBC28 = *(void *)&v5;
    byte_1000EBC30 = 1;
  }
  if (!objc_msgSend(v6, "count", v7))
  {
    if (byte_1000EBCF8)
    {
      int v36 = *__error();
      __darwin_time_t v37 = sub_10002E548();
      if (os_log_type_enabled(v37, OS_LOG_TYPE_DEFAULT))
      {
        double v38 = COERCE_DOUBLE(dispatch_source_get_handle(a2));
        *(_DWORD *)buf = 134217984;
        double v84 = v38;
        _os_log_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_DEFAULT, "Interrupted by signal %ld while saving report. Interrupt again after a second to exit early", buf, 0xCu);
      }
      *__error() = v36;
    }
    if (byte_1000EBCF9) {
      BOOL v39 = dword_1000EB4A8 <= 2;
    }
    else {
      BOOL v39 = 0;
    }
    if (!v39) {
      goto LABEL_100;
    }
    int v40 = *__error();
    uintptr_t v41 = dispatch_source_get_handle(a2);
    CFStringRef v42 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"Interrupted by signal %ld while saving report. Interrupt again after a second to exit early", v41);
    if (v42)
    {
      CFStringRef v43 = v42;
      double v44 = CFStringGetCStringPtr(v42, 0x8000100u);
      if (v44)
      {
LABEL_67:
        id v52 = (char *)v44;
        BOOL v53 = 0;
LABEL_93:
        if (qword_1000EBD00) {
          int v60 = (FILE *)qword_1000EBD00;
        }
        else {
          int v60 = __stderrp;
        }
        fprintf(v60, "%s\n", v52);
        if (v53) {
          free(v53);
        }
        CFRelease(v43);
        goto LABEL_99;
      }
      malloc_type_id_t v45 = 1456550084;
LABEL_92:
      id v52 = (char *)malloc_type_calloc(0x400uLL, 1uLL, v45);
      CFStringGetCString(v43, v52, 1024, 0x8000100u);
      BOOL v53 = v52;
      goto LABEL_93;
    }
    id v56 = sub_10002E548();
    if (os_log_type_enabled(v56, OS_LOG_TYPE_FAULT)) {
      sub_1000922D0(a2);
    }
LABEL_87:
    if (qword_1000EBD00) {
      CFStringRef v59 = (FILE *)qword_1000EBD00;
    }
    else {
      CFStringRef v59 = __stderrp;
    }
    fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v59);
LABEL_99:
    *__error() = v40;
    goto LABEL_100;
  }
  int v23 = *(_DWORD *)(a1 + 32);
  int v22 = (unsigned int *)(a1 + 32);
  if (v23)
  {
    if (byte_1000EBCF8)
    {
      int v24 = *__error();
      CFStringRef v25 = sub_10002E548();
      if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
      {
        double v26 = COERCE_DOUBLE(dispatch_source_get_handle(a2));
        unsigned int v27 = *v22;
        *(_DWORD *)buf = 134218240;
        double v84 = v26;
        __int16 v85 = 1024;
        LODWORD(v86) = v27;
        _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "Interrupted by signal %ld, waiting %d seconds...", buf, 0x12u);
      }
      *__error() = v24;
    }
    if (byte_1000EBCF9) {
      BOOL v28 = dword_1000EB4A8 <= 2;
    }
    else {
      BOOL v28 = 0;
    }
    if (v28)
    {
      int v29 = *__error();
      uintptr_t v30 = dispatch_source_get_handle(a2);
      CFStringRef v31 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"Interrupted by signal %ld, waiting %d seconds...", v30, *v22);
      if (v31)
      {
        CFStringRef v32 = v31;
        CFStringRef v33 = CFStringGetCStringPtr(v31, 0x8000100u);
        if (v33)
        {
          int v34 = (char *)v33;
          dispatch_time_t v35 = 0;
        }
        else
        {
          int v34 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x8FC039E6uLL);
          CFStringGetCString(v32, v34, 1024, 0x8000100u);
          dispatch_time_t v35 = v34;
        }
        if (qword_1000EBD00) {
          uint64_t v57 = (FILE *)qword_1000EBD00;
        }
        else {
          uint64_t v57 = __stderrp;
        }
        fprintf(v57, "%s\n", v34);
        if (v35) {
          free(v35);
        }
        CFRelease(v32);
      }
      else
      {
        uint64_t v54 = sub_10002E548();
        if (os_log_type_enabled(v54, OS_LOG_TYPE_FAULT)) {
          sub_1000923C0(a2);
        }
        if (qword_1000EBD00) {
          uint64_t v55 = (FILE *)qword_1000EBD00;
        }
        else {
          uint64_t v55 = __stderrp;
        }
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v55);
      }
      *__error() = v29;
    }
    sleep(*v22);
    goto LABEL_100;
  }
  if (byte_1000EBCF8)
  {
    int v46 = *__error();
    int v47 = sub_10002E548();
    if (os_log_type_enabled(v47, OS_LOG_TYPE_DEFAULT))
    {
      double v48 = COERCE_DOUBLE(dispatch_source_get_handle(a2));
      *(_DWORD *)buf = 134217984;
      double v84 = v48;
      _os_log_impl((void *)&_mh_execute_header, v47, OS_LOG_TYPE_DEFAULT, "Interrupted by signal %ld", buf, 0xCu);
    }
    *__error() = v46;
  }
  if (byte_1000EBCF9) {
    BOOL v49 = dword_1000EB4A8 <= 2;
  }
  else {
    BOOL v49 = 0;
  }
  if (v49)
  {
    int v40 = *__error();
    uintptr_t v50 = dispatch_source_get_handle(a2);
    CFStringRef v51 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"Interrupted by signal %ld", v50);
    if (v51)
    {
      CFStringRef v43 = v51;
      double v44 = CFStringGetCStringPtr(v51, 0x8000100u);
      if (v44) {
        goto LABEL_67;
      }
      malloc_type_id_t v45 = 2954543306;
      goto LABEL_92;
    }
    CFStringRef v58 = sub_10002E548();
    if (os_log_type_enabled(v58, OS_LOG_TYPE_FAULT)) {
      sub_100092348(a2);
    }
    goto LABEL_87;
  }
LABEL_100:
  long long v80 = 0u;
  long long v81 = 0u;
  long long v78 = 0u;
  long long v79 = 0u;
  id result = [v6 countByEnumeratingWithState:&v78 objects:v82 count:16];
  if (result)
  {
    id v62 = result;
    uint64_t v63 = *(void *)v79;
    do
    {
      uint32_t v64 = 0;
      do
      {
        if (*(void *)v79 != v63) {
          objc_enumerationMutation(v6);
        }
        [*(id *)(*((void *)&v78 + 1) + 8 * (void)v64) stopSamplingWithReason:5];
        uint32_t v64 = (char *)v64 + 1;
      }
      while (v62 != v64);
      id result = [v6 countByEnumeratingWithState:&v78 objects:v82 count:16];
      id v62 = result;
    }
    while (result);
  }
  return result;
}

void sub_10005BF18(id a1)
{
  uint64_t v1 = getpid();
  if (sub_10005CBDC(v1))
  {
    if (byte_1000EBCF8)
    {
      int v2 = *__error();
      BOOL v3 = sub_10002E548();
      if (os_log_type_enabled(v3, OS_LOG_TYPE_DEBUG)) {
        sub_100092528();
      }
      *__error() = v2;
    }
    if (byte_1000EBCF9) {
      BOOL v4 = dword_1000EB4A8 <= 0;
    }
    else {
      BOOL v4 = 0;
    }
    if (!v4) {
      return;
    }
    int v5 = *__error();
    CFStringRef v6 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"spindump-stuck: Running under debugger, ignoring");
    if (v6)
    {
      CFStringRef v7 = v6;
      CStringPtr = CFStringGetCStringPtr(v6, 0x8000100u);
      if (!CStringPtr)
      {
        malloc_type_id_t v9 = 2269146905;
LABEL_118:
        uint64_t v54 = (char *)malloc_type_calloc(0x400uLL, 1uLL, v9);
        CFStringGetCString(v7, v54, 1024, 0x8000100u);
        uint64_t v55 = v54;
        goto LABEL_119;
      }
      goto LABEL_88;
    }
    int v21 = sub_10002E548();
    if (os_log_type_enabled(v21, OS_LOG_TYPE_FAULT)) {
      sub_1000924F4();
    }
    goto LABEL_127;
  }
  BOOL v10 = getenv("XPC_NULL_BOOTSTRAP");
  if (v10) {
    int v11 = v10;
  }
  else {
    int v11 = "0";
  }
  if (strcmp("1", v11))
  {
    if (byte_1000EBCF8)
    {
      int v12 = *__error();
      uintptr_t v13 = sub_10002E548();
      if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "spindump-stuck: Spindump has taken over a minute to process samples and may be stuck, try using -noIPC", buf, 2u);
      }
      *__error() = v12;
    }
    if (byte_1000EBCF9) {
      BOOL v14 = dword_1000EB4A8 <= 2;
    }
    else {
      BOOL v14 = 0;
    }
    if (v14)
    {
      int v15 = *__error();
      CFStringRef v16 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"spindump-stuck: Spindump has taken over a minute to process samples and may be stuck, try using -noIPC");
      if (v16)
      {
        CFStringRef v17 = v16;
        int v18 = CFStringGetCStringPtr(v16, 0x8000100u);
        if (v18)
        {
          int v19 = (char *)v18;
          CFStringRef v20 = 0;
        }
        else
        {
          int v19 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xCC9C2C22uLL);
          CFStringGetCString(v17, v19, 1024, 0x8000100u);
          CFStringRef v20 = v19;
        }
        if (qword_1000EBD00) {
          int v24 = (FILE *)qword_1000EBD00;
        }
        else {
          int v24 = __stderrp;
        }
        fprintf(v24, "%s\n", v19);
        if (v20) {
          free(v20);
        }
        CFRelease(v17);
      }
      else
      {
        int v22 = sub_10002E548();
        if (os_log_type_enabled(v22, OS_LOG_TYPE_FAULT)) {
          sub_1000929D0();
        }
        if (qword_1000EBD00) {
          int v23 = (FILE *)qword_1000EBD00;
        }
        else {
          int v23 = __stderrp;
        }
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v23);
      }
      *__error() = v15;
    }
  }
  if ((byte_1000EBD0C & 2) != 0 && sub_10002411C())
  {
    if (byte_1000EBCF8)
    {
      int v25 = *__error();
      double v26 = sub_10002E548();
      if (os_log_type_enabled(v26, OS_LOG_TYPE_DEBUG)) {
        sub_100092990();
      }
      *__error() = v25;
    }
    if (byte_1000EBCF9 && dword_1000EB4A8 <= 0)
    {
      int v5 = *__error();
      CFStringRef v27 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"spindump-stuck: Audio running, avoiding stackshot");
      if (v27)
      {
        CFStringRef v7 = v27;
        CStringPtr = CFStringGetCStringPtr(v27, 0x8000100u);
        if (!CStringPtr)
        {
          malloc_type_id_t v9 = 3430403329;
          goto LABEL_118;
        }
LABEL_88:
        uint64_t v54 = (char *)CStringPtr;
        uint64_t v55 = 0;
LABEL_119:
        if (qword_1000EBD00) {
          id v71 = (FILE *)qword_1000EBD00;
        }
        else {
          id v71 = __stderrp;
        }
        fprintf(v71, "%s\n", v54);
        if (v55) {
          free(v55);
        }
        CFRelease(v7);
LABEL_131:
        *__error() = v5;
        return;
      }
      id v69 = sub_10002E548();
      if (os_log_type_enabled(v69, OS_LOG_TYPE_FAULT)) {
        sub_10009295C();
      }
LABEL_127:
      if (qword_1000EBD00) {
        CFStringRef v73 = (FILE *)qword_1000EBD00;
      }
      else {
        CFStringRef v73 = __stderrp;
      }
      fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v73);
      goto LABEL_131;
    }
  }
  else
  {
    strcpy((char *)buf, "/var/tmp/spindump-stuck-stackshot.");
    memset(&v89, 0, sizeof(v89));
    time_t v88 = time(0);
    localtime_r(&v88, &v89);
    size_t v28 = strftime((char *)&buf[34], 0x3DEuLL, "%Y-%m-%d-%T", &v89);
    size_t v29 = v28 + 34;
    if (v28 + 34 >= 0x400)
    {
      int v77 = *__error();
      long long v78 = sub_10002E548();
      if (os_log_type_enabled(v78, OS_LOG_TYPE_FAULT)) {
        sub_1000928F4();
      }
      *__error() = v77;
      if (byte_1000EBCF9 && dword_1000EB4A8 <= 4)
      {
        int v79 = *__error();
        CFStringRef v80 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"filePath %s cut off with date (needed %zu chars)", buf, v29);
        if (v80)
        {
          CFStringRef v81 = v80;
          double v82 = CFStringGetCStringPtr(v80, 0x8000100u);
          if (v82)
          {
            unsigned int v83 = (char *)v82;
            double v84 = 0;
          }
          else
          {
            unsigned int v83 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x62ADF942uLL);
            CFStringGetCString(v81, v83, 1024, 0x8000100u);
            double v84 = v83;
          }
          if (qword_1000EBD00) {
            CFStringRef v87 = (FILE *)qword_1000EBD00;
          }
          else {
            CFStringRef v87 = __stderrp;
          }
          fprintf(v87, "%s\n", v83);
          if (v84) {
            free(v84);
          }
          CFRelease(v81);
        }
        else
        {
          __int16 v85 = sub_10002E548();
          if (os_log_type_enabled(v85, OS_LOG_TYPE_FAULT)) {
            sub_10009288C();
          }
          if (qword_1000EBD00) {
            uintptr_t v86 = (FILE *)qword_1000EBD00;
          }
          else {
            uintptr_t v86 = __stderrp;
          }
          fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v86);
        }
        *__error() = v79;
      }
    }
    pid_t v30 = getpid();
    snprintf((char *)&buf[v29], 990 - v28, ".%d.buf", v30);
    CFStringRef v31 = fopen((const char *)buf, "w");
    if (v31)
    {
      CFStringRef v32 = v31;
      uint64_t v33 = stackshot_config_create();
      stackshot_config_set_flags();
      id v34 = sub_10006DF74(v33, 0);
      dispatch_time_t v35 = v34;
      if (v34 && [v34 length])
      {
        size_t v36 = fwrite([v35 bytes], (size_t)[v35 length], 1uLL, v32);

        stackshot_config_dealloc();
        if (v36 == 1)
        {
          fclose(v32);
          if (byte_1000EBCF8)
          {
            int v37 = *__error();
            double v38 = sub_10002E548();
            if (os_log_type_enabled(v38, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)id v90 = 136315138;
              id v91 = buf;
              _os_log_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_DEFAULT, "spindump-stuck: Wrote stackshot to %s", v90, 0xCu);
            }
            *__error() = v37;
          }
          if (byte_1000EBCF9 && dword_1000EB4A8 <= 2)
          {
            int v5 = *__error();
            CFStringRef v39 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"spindump-stuck: Wrote stackshot to %s", buf);
            if (v39)
            {
              CFStringRef v7 = v39;
              CStringPtr = CFStringGetCStringPtr(v39, 0x8000100u);
              if (!CStringPtr)
              {
                malloc_type_id_t v9 = 1186232392;
                goto LABEL_118;
              }
              goto LABEL_88;
            }
            id v72 = sub_10002E548();
            if (os_log_type_enabled(v72, OS_LOG_TYPE_FAULT)) {
              sub_100092704();
            }
            goto LABEL_127;
          }
        }
        else
        {
          if (byte_1000EBCF8)
          {
            int v56 = *__error();
            uint64_t v57 = sub_10002E548();
            if (os_log_type_enabled(v57, OS_LOG_TYPE_ERROR)) {
              sub_1000927FC((int)buf, v32);
            }
            *__error() = v56;
          }
          if (byte_1000EBCF9 && dword_1000EB4A8 <= 3)
          {
            int v58 = *__error();
            uint64_t v59 = ferror(v32);
            int v60 = strerror(v59);
            CFStringRef v61 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"Unable to write stackshot to %s: %d (%s)", buf, v59, v60);
            if (v61)
            {
              CFStringRef v62 = v61;
              uint64_t v63 = CFStringGetCStringPtr(v61, 0x8000100u);
              if (v63)
              {
                uint32_t v64 = (char *)v63;
                int v65 = 0;
              }
              else
              {
                uint32_t v64 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x5C58F1D1uLL);
                CFStringGetCString(v62, v64, 1024, 0x8000100u);
                int v65 = v64;
              }
              if (qword_1000EBD00) {
                id v76 = (FILE *)qword_1000EBD00;
              }
              else {
                id v76 = __stderrp;
              }
              fprintf(v76, "%s\n", v64);
              if (v65) {
                free(v65);
              }
              CFRelease(v62);
            }
            else
            {
              id v74 = sub_10002E548();
              if (os_log_type_enabled(v74, OS_LOG_TYPE_FAULT)) {
                sub_10009276C((int)buf, v32);
              }
              if (qword_1000EBD00) {
                id v75 = (FILE *)qword_1000EBD00;
              }
              else {
                id v75 = __stderrp;
              }
              fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v75);
            }
            *__error() = v58;
          }
          fclose(v32);
        }
      }
      else
      {
        if (byte_1000EBCF8)
        {
          int v40 = *__error();
          uintptr_t v41 = sub_10002E548();
          if (os_log_type_enabled(v41, OS_LOG_TYPE_ERROR)) {
            sub_1000926C4();
          }
          *__error() = v40;
        }
        if (byte_1000EBCF9 && dword_1000EB4A8 <= 3)
        {
          int v42 = *__error();
          CFStringRef v43 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"spindump-stuck: Unable to take stackshot");
          if (v43)
          {
            CFStringRef v44 = v43;
            malloc_type_id_t v45 = CFStringGetCStringPtr(v43, 0x8000100u);
            if (v45)
            {
              int v46 = (char *)v45;
              int v47 = 0;
            }
            else
            {
              int v46 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x7735B98AuLL);
              CFStringGetCString(v44, v46, 1024, 0x8000100u);
              int v47 = v46;
            }
            if (qword_1000EBD00) {
              CFStringRef v70 = (FILE *)qword_1000EBD00;
            }
            else {
              CFStringRef v70 = __stderrp;
            }
            fprintf(v70, "%s\n", v46);
            if (v47) {
              free(v47);
            }
            CFRelease(v44);
          }
          else
          {
            uint64_t v66 = sub_10002E548();
            if (os_log_type_enabled(v66, OS_LOG_TYPE_FAULT)) {
              sub_100092690();
            }
            if (qword_1000EBD00) {
              BOOL v67 = (FILE *)qword_1000EBD00;
            }
            else {
              BOOL v67 = __stderrp;
            }
            fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v67);
          }
          *__error() = v42;
        }

        stackshot_config_dealloc();
      }
    }
    else
    {
      if (byte_1000EBCF8)
      {
        int v48 = *__error();
        BOOL v49 = sub_10002E548();
        if (os_log_type_enabled(v49, OS_LOG_TYPE_ERROR)) {
          sub_1000925FC();
        }
        *__error() = v48;
      }
      if (byte_1000EBCF9 && dword_1000EB4A8 <= 3)
      {
        int v5 = *__error();
        uint64_t v50 = *__error();
        CFStringRef v51 = __error();
        id v52 = strerror(*v51);
        CFStringRef v53 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"spindump-stuck: Unable to open %s: %d (%s)", buf, v50, v52);
        if (v53)
        {
          CFStringRef v7 = v53;
          CStringPtr = CFStringGetCStringPtr(v53, 0x8000100u);
          if (!CStringPtr)
          {
            malloc_type_id_t v9 = 3207779541;
            goto LABEL_118;
          }
          goto LABEL_88;
        }
        int v68 = sub_10002E548();
        if (os_log_type_enabled(v68, OS_LOG_TYPE_FAULT)) {
          sub_100092568();
        }
        goto LABEL_127;
      }
    }
  }
}

BOOL sub_10005CBDC(uint64_t a1)
{
  long long v34 = 0u;
  long long v35 = 0u;
  memset(buffer, 0, sizeof(buffer));
  if (!proc_pidinfo(a1, 13, 1uLL, buffer, 64))
  {
    if ((a1 & 0x80000000) != 0)
    {
      if (byte_1000EBCF8)
      {
        int v16 = *__error();
        CFStringRef v17 = sub_10002E548();
        if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR)) {
          sub_100092BD4();
        }
        *__error() = v16;
      }
      if (byte_1000EBCF9) {
        BOOL v18 = dword_1000EB4A8 <= 3;
      }
      else {
        BOOL v18 = 0;
      }
      if (!v18) {
        return 0;
      }
      int v6 = *__error();
      uint64_t v19 = *__error();
      CFStringRef v20 = __error();
      int v21 = strerror(*v20);
      CFStringRef v22 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"Unable to get proc info, assuming not being debugged: %d (%s)", v19, v21);
      if (v22)
      {
        CFStringRef v23 = v22;
        CStringPtr = CFStringGetCStringPtr(v22, 0x8000100u);
        if (CStringPtr)
        {
          int v25 = (char *)CStringPtr;
          double v26 = 0;
        }
        else
        {
          int v25 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x878C781uLL);
          CFStringGetCString(v23, v25, 1024, 0x8000100u);
          double v26 = v25;
        }
        if (qword_1000EBD00) {
          CFStringRef v32 = (FILE *)qword_1000EBD00;
        }
        else {
          CFStringRef v32 = __stderrp;
        }
        fprintf(v32, "%s\n", v25);
        if (v26) {
          free(v26);
        }
        CFStringRef v29 = v23;
        goto LABEL_51;
      }
      pid_t v30 = sub_10002E548();
      if (os_log_type_enabled(v30, OS_LOG_TYPE_FAULT)) {
        sub_100092B4C();
      }
    }
    else
    {
      if (byte_1000EBCF8)
      {
        int v3 = *__error();
        BOOL v4 = sub_10002E548();
        if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR)) {
          sub_100092AA4();
        }
        *__error() = v3;
      }
      if (byte_1000EBCF9) {
        BOOL v5 = dword_1000EB4A8 <= 3;
      }
      else {
        BOOL v5 = 0;
      }
      if (!v5) {
        return 0;
      }
      int v6 = *__error();
      CFStringRef v7 = sub_10002E4E8(a1);
      uint64_t v8 = *__error();
      malloc_type_id_t v9 = __error();
      BOOL v10 = strerror(*v9);
      CFStringRef v11 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%s [%d]: Unable to get proc info, assuming not being debugged: %d (%s)", v7, a1, v8, v10);
      if (v11)
      {
        CFStringRef v12 = v11;
        uintptr_t v13 = CFStringGetCStringPtr(v11, 0x8000100u);
        if (v13)
        {
          BOOL v14 = (char *)v13;
          int v15 = 0;
        }
        else
        {
          BOOL v14 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x878C781uLL);
          CFStringGetCString(v12, v14, 1024, 0x8000100u);
          int v15 = v14;
        }
        if (qword_1000EBD00) {
          size_t v28 = (FILE *)qword_1000EBD00;
        }
        else {
          size_t v28 = __stderrp;
        }
        fprintf(v28, "%s\n", v14);
        if (v15) {
          free(v15);
        }
        CFStringRef v29 = v12;
LABEL_51:
        CFRelease(v29);
LABEL_52:
        *__error() = v6;
        return 0;
      }
      CFStringRef v27 = sub_10002E548();
      if (os_log_type_enabled(v27, OS_LOG_TYPE_FAULT)) {
        sub_100092A04();
      }
    }
    if (qword_1000EBD00) {
      CFStringRef v31 = (FILE *)qword_1000EBD00;
    }
    else {
      CFStringRef v31 = __stderrp;
    }
    fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v31);
    goto LABEL_52;
  }
  return (v34 & 2) != 0;
}

void sub_10005CF88(uint64_t a1, void *a2)
{
  [a2 setIncidentUUID:0];
  id v98 = (NSString *)[a2 targetProcessName];
  if (!v98)
  {
    if (*(void *)(a1 + 64)) {
      id v98 = +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:");
    }
    else {
      id v98 = 0;
    }
  }
  if (*(unsigned char *)(a1 + 108))
  {
    dispatch_group_wait((dispatch_group_t)qword_1000EBD58, 0xFFFFFFFFFFFFFFFFLL);
    if ((byte_1000EBD0C & 0x18) == 0x10)
    {
      if (byte_1000EBCF8)
      {
        int v4 = *__error();
        BOOL v5 = sub_10002E548();
        if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "SIGINFO received, generating report...", buf, 2u);
        }
        *__error() = v4;
      }
      if (byte_1000EBCF9) {
        BOOL v6 = dword_1000EB4A8 <= 2;
      }
      else {
        BOOL v6 = 0;
      }
      if (!v6) {
        goto LABEL_49;
      }
      int v7 = *__error();
      CFStringRef v8 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"SIGINFO received, generating report...");
      if (!v8)
      {
        malloc_type_id_t v9 = sub_10002E548();
        if (os_log_type_enabled(v9, OS_LOG_TYPE_FAULT))
        {
          *(_WORD *)buf = 0;
          BOOL v10 = "Unable to format: SIGINFO received, generating report...";
LABEL_31:
          _os_log_fault_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_FAULT, v10, buf, 2u);
          goto LABEL_32;
        }
        goto LABEL_32;
      }
      CFStringRef v16 = v8;
      CStringPtr = CFStringGetCStringPtr(v8, 0x8000100u);
      if (!CStringPtr)
      {
        malloc_type_id_t v18 = 1481238127;
LABEL_40:
        uint64_t v19 = (char *)malloc_type_calloc(0x400uLL, 1uLL, v18);
        CFStringGetCString(v16, v19, 1024, 0x8000100u);
        CFStringRef v20 = v19;
LABEL_42:
        if (qword_1000EBD00) {
          int v21 = (FILE *)qword_1000EBD00;
        }
        else {
          int v21 = __stderrp;
        }
        fprintf(v21, "%s\n", v19);
        if (v20) {
          free(v20);
        }
        CFRelease(v16);
        goto LABEL_48;
      }
      goto LABEL_41;
    }
    if (byte_1000EBCF8)
    {
      int v11 = *__error();
      CFStringRef v12 = sub_10002E548();
      if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "SIGINFO received, processing symbols...", buf, 2u);
      }
      *__error() = v11;
    }
    if (byte_1000EBCF9) {
      BOOL v13 = dword_1000EB4A8 <= 2;
    }
    else {
      BOOL v13 = 0;
    }
    if (v13)
    {
      int v7 = *__error();
      CFStringRef v14 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"SIGINFO received, processing symbols...");
      if (!v14)
      {
        malloc_type_id_t v9 = sub_10002E548();
        if (os_log_type_enabled(v9, OS_LOG_TYPE_FAULT))
        {
          *(_WORD *)buf = 0;
          BOOL v10 = "Unable to format: SIGINFO received, processing symbols...";
          goto LABEL_31;
        }
LABEL_32:
        if (qword_1000EBD00) {
          int v15 = (FILE *)qword_1000EBD00;
        }
        else {
          int v15 = __stderrp;
        }
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v15);
LABEL_48:
        *__error() = v7;
        goto LABEL_49;
      }
      CFStringRef v16 = v14;
      CStringPtr = CFStringGetCStringPtr(v14, 0x8000100u);
      if (!CStringPtr)
      {
        malloc_type_id_t v18 = 461140569;
        goto LABEL_40;
      }
LABEL_41:
      uint64_t v19 = (char *)CStringPtr;
      CFStringRef v20 = 0;
      goto LABEL_42;
    }
  }
LABEL_49:
  if (*(void *)(a1 + 32)) {
    [a2 setPrintOptions:];
  }
  [a2 setForceOneBasedTimeIndexes:*(unsigned __int8 *)(a1 + 109)];
  if (*(void *)(a1 + 72)) {
    [a2 setTargetThreadId:];
  }
  if ((int)[a2 numSamplesAvoidedDueToAudio] >= 1 && !objc_msgSend(a2, "numSamples"))
  {
    if (byte_1000EBCF8)
    {
      int v22 = *__error();
      CFStringRef v23 = sub_10002E548();
      if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)buf = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_ERROR, "Unable to sample due to audio running", buf, 2u);
      }
      *__error() = v22;
    }
    if (byte_1000EBCF9 && dword_1000EB4A8 <= 3)
    {
      int v24 = *__error();
      CFStringRef v25 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"Unable to sample due to audio running");
      if (v25)
      {
        CFStringRef v88 = v25;
        tm v89 = CFStringGetCStringPtr(v25, 0x8000100u);
        if (v89)
        {
          id v90 = (char *)v89;
          id v91 = 0;
        }
        else
        {
          id v90 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x8ED665AAuLL);
          CFStringGetCString(v88, v90, 1024, 0x8000100u);
          id v91 = v90;
        }
        if (qword_1000EBD00) {
          id v92 = (FILE *)qword_1000EBD00;
        }
        else {
          id v92 = __stderrp;
        }
        fprintf(v92, "%s\n", v90);
        if (v91) {
          free(v91);
        }
        CFRelease(v88);
      }
      else
      {
        double v26 = sub_10002E548();
        if (os_log_type_enabled(v26, OS_LOG_TYPE_FAULT))
        {
          *(_WORD *)buf = 0;
          _os_log_fault_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_FAULT, "Unable to format: Unable to sample due to audio running", buf, 2u);
        }
        if (qword_1000EBD00) {
          CFStringRef v27 = (FILE *)qword_1000EBD00;
        }
        else {
          CFStringRef v27 = __stderrp;
        }
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v27);
      }
      *__error() = v24;
    }
LABEL_174:
    exit(69);
  }
  uint64_t v28 = *(void *)(a1 + 88);
  uint64_t v30 = *(void *)(a1 + 40);
  uint64_t v29 = *(void *)(a1 + 48);
  int v31 = *(unsigned __int8 *)(a1 + 110);
  int v32 = *(unsigned __int8 *)(a1 + 111);
  int v33 = *(unsigned __int8 *)(a1 + 112);
  long long v34 = *(uint8_t **)(a1 + 96);
  int v35 = *(_DWORD *)(a1 + 104);
  if (*(void *)(a1 + 80)) {
    [a2 setSignature:+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:")];
  }
  if (v28) {
    [a2 setReason:+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v28)];
  }
  [a2 setUseDsymForUUIDForEverything:v31 != 0];
  [a2 setFindDsymsForIDs:v30];
  [a2 setIncludeBinaryFormatInReport:v33 == 0];
  [a2 setIncludeTextualFormatInReport:v32 == 0];
  [a2 setHeaderOnly:0];
  [a2 setDsymPaths:v29];
  id v100 = 0;
  if (v34)
  {
    while (1)
    {
      size_t v36 = (NSString *)[objc_alloc((Class)NSString) initWithUTF8String:v34];
      id v37 = [a2 targetProcessId];
      uid_t v38 = geteuid();
      int v39 = sub_10004D99C(v36, v98, (uint64_t)v37, 1537, v38, 0x1A4u, &v100);
      if (v36) {

      }
      if (v39 != -1)
      {
        int v40 = fdopen(v39, "w");
        if (v40) {
          break;
        }
      }
      if (byte_1000EBCF8)
      {
        int v41 = *__error();
        int v42 = sub_10002E548();
        if (os_log_type_enabled(v42, OS_LOG_TYPE_ERROR))
        {
          id v72 = v34;
          if (v100) {
            id v72 = (uint8_t *)[v100 UTF8String];
          }
          int v73 = *__error();
          id v74 = __error();
          id v75 = strerror(*v74);
          *(_DWORD *)id v101 = 136315650;
          *(void *)&v101[4] = v72;
          __int16 v102 = 1024;
          int v103 = v73;
          __int16 v104 = 2080;
          id v105 = v75;
          _os_log_error_impl((void *)&_mh_execute_header, v42, OS_LOG_TYPE_ERROR, "Spindump failed to save report to %s: %d (%s)", v101, 0x1Cu);
        }
        *__error() = v41;
      }
      if (byte_1000EBCF9) {
        BOOL v43 = dword_1000EB4A8 <= 3;
      }
      else {
        BOOL v43 = 0;
      }
      if (v43)
      {
        int v44 = *__error();
        malloc_type_id_t v45 = v34;
        if (v100) {
          malloc_type_id_t v45 = (uint8_t *)[v100 UTF8String];
        }
        uint64_t v46 = *__error();
        int v47 = __error();
        int v48 = strerror(*v47);
        CFStringRef v49 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"Spindump failed to save report to %s: %d (%s)", v45, v46, v48);
        if (v49)
        {
          CFStringRef v50 = v49;
          CFStringRef v51 = CFStringGetCStringPtr(v49, 0x8000100u);
          if (v51)
          {
            id v52 = (char *)v51;
            CFStringRef v53 = 0;
          }
          else
          {
            id v52 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xD0108B9BuLL);
            CFStringGetCString(v50, v52, 1024, 0x8000100u);
            CFStringRef v53 = v52;
          }
          if (qword_1000EBD00) {
            int v56 = (FILE *)qword_1000EBD00;
          }
          else {
            int v56 = __stderrp;
          }
          fprintf(v56, "%s\n", v52);
          if (v53) {
            free(v53);
          }
          CFRelease(v50);
        }
        else
        {
          uint64_t v54 = sub_10002E548();
          if (os_log_type_enabled(v54, OS_LOG_TYPE_FAULT))
          {
            id v76 = v34;
            if (v100) {
              id v76 = (uint8_t *)[v100 UTF8String];
            }
            int v77 = *__error();
            long long v78 = __error();
            int v79 = strerror(*v78);
            *(_DWORD *)id v101 = 136315650;
            *(void *)&v101[4] = v76;
            __int16 v102 = 1024;
            int v103 = v77;
            __int16 v104 = 2080;
            id v105 = v79;
            _os_log_fault_impl((void *)&_mh_execute_header, v54, OS_LOG_TYPE_FAULT, "Unable to format: Spindump failed to save report to %s: %d (%s)", v101, 0x1Cu);
          }
          if (qword_1000EBD00) {
            uint64_t v55 = (FILE *)qword_1000EBD00;
          }
          else {
            uint64_t v55 = __stderrp;
          }
          fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v55);
        }
        *__error() = v44;
      }

      id v100 = 0;
      if (v39 != -1) {
        close(v39);
      }
      *(void *)id v101 = 0;
      if (byte_1000EBCF8)
      {
        int v57 = *__error();
        int v58 = sub_10002E548();
        if (os_log_type_enabled(v58, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)id v99 = 0;
          _os_log_impl((void *)&_mh_execute_header, v58, OS_LOG_TYPE_DEFAULT, "Please enter a new output location (or an empty line to output to stdout, including spindump binary format)", v99, 2u);
        }
        *__error() = v57;
      }
      if (byte_1000EBCF9 && dword_1000EB4A8 <= 2)
      {
        int v59 = *__error();
        CFStringRef v60 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"Please enter a new output location (or an empty line to output to stdout, including spindump binary format)");
        if (v60)
        {
          CFStringRef v61 = v60;
          CFStringRef v62 = CFStringGetCStringPtr(v60, 0x8000100u);
          if (v62)
          {
            uint64_t v63 = (char *)v62;
            uint32_t v64 = 0;
          }
          else
          {
            uint64_t v63 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x8C6F58D1uLL);
            CFStringGetCString(v61, v63, 1024, 0x8000100u);
            uint32_t v64 = v63;
          }
          if (qword_1000EBD00) {
            BOOL v67 = (FILE *)qword_1000EBD00;
          }
          else {
            BOOL v67 = __stderrp;
          }
          fprintf(v67, "%s\n", v63);
          if (v64) {
            free(v64);
          }
          CFRelease(v61);
        }
        else
        {
          int v65 = sub_10002E548();
          if (os_log_type_enabled(v65, OS_LOG_TYPE_FAULT))
          {
            *(_WORD *)id v99 = 0;
            _os_log_fault_impl((void *)&_mh_execute_header, v65, OS_LOG_TYPE_FAULT, "Unable to format: Please enter a new output location (or an empty line to output to stdout, including spindump binary format)", v99, 2u);
          }
          if (qword_1000EBD00) {
            uint64_t v66 = (FILE *)qword_1000EBD00;
          }
          else {
            uint64_t v66 = __stderrp;
          }
          fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v66);
        }
        *__error() = v59;
      }
      int v68 = fgetln(__stdinp, (size_t *)v101);
      uint64_t v69 = *(void *)v101;
      if (!*(void *)v101) {
        goto LABEL_141;
      }
      unint64_t v70 = *(void *)v101 - 1;
      if (v68[*(void *)v101 - 1] == 10)
      {
        v68[v70] = 0;
        uint64_t v71 = *(void *)v101;
        uint64_t v69 = --*(void *)v101;
        unint64_t v70 = v71 - 2;
      }
      if (v70 >= 0x3FF)
      {
LABEL_141:
        char v80 = 1;
        goto LABEL_143;
      }
      long long v34 = buf;
      __memcpy_chk();
      buf[v69] = 0;
    }
    CFStringRef v81 = v40;
    [a2 saveReportToStream:v40];
    fclose(v81);
    if (byte_1000EBCF8)
    {
      int v82 = *__error();
      unsigned int v83 = sub_10002E548();
      if (os_log_type_enabled(v83, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 138412290;
        id v107 = v100;
        _os_log_impl((void *)&_mh_execute_header, v83, OS_LOG_TYPE_DEFAULT, "Spindump analysis written to file %@", buf, 0xCu);
      }
      *__error() = v82;
    }
    if (byte_1000EBCF9 && dword_1000EB4A8 <= 2)
    {
      int v84 = *__error();
      CFStringRef v85 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"Spindump analysis written to file %@", v100);
      if (v85)
      {
        CFStringRef v93 = v85;
        uint64_t v94 = CFStringGetCStringPtr(v85, 0x8000100u);
        if (v94)
        {
          id v95 = (char *)v94;
          id v96 = 0;
        }
        else
        {
          id v95 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xD8E4F539uLL);
          CFStringGetCString(v93, v95, 1024, 0x8000100u);
          id v96 = v95;
        }
        if (qword_1000EBD00) {
          CFStringRef v97 = (FILE *)qword_1000EBD00;
        }
        else {
          CFStringRef v97 = __stderrp;
        }
        fprintf(v97, "%s\n", v95);
        if (v96) {
          free(v96);
        }
        CFRelease(v93);
      }
      else
      {
        uintptr_t v86 = sub_10002E548();
        if (os_log_type_enabled(v86, OS_LOG_TYPE_FAULT))
        {
          *(_DWORD *)buf = 138412290;
          id v107 = v100;
          _os_log_fault_impl((void *)&_mh_execute_header, v86, OS_LOG_TYPE_FAULT, "Unable to format: Spindump analysis written to file %@", buf, 0xCu);
        }
        if (qword_1000EBD00) {
          CFStringRef v87 = (FILE *)qword_1000EBD00;
        }
        else {
          CFStringRef v87 = __stderrp;
        }
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v87);
      }
      *__error() = v84;
      if (!v35) {
        goto LABEL_164;
      }
    }
    else if (!v35)
    {
      goto LABEL_164;
    }
    [a2 setIncludeBinaryFormatInReport:0];
    char v80 = 0;
  }
  else
  {
    if (!v35) {
      goto LABEL_165;
    }
    long long v34 = 0;
    char v80 = 1;
  }
LABEL_143:
  [a2 saveReportToStream:__stdoutp];
  if ([a2 includeBinaryFormatInReport]) {
    putchar(10);
  }
  if (v80)
  {

    if (v34) {
      goto LABEL_174;
    }
LABEL_165:
    exit(0);
  }
LABEL_164:

  goto LABEL_165;
}

uint64_t sub_10005DD3C(uint64_t a1)
{
  return (*(uint64_t (**)(void, void))(*(void *)(a1 + 40) + 16))(*(void *)(a1 + 40), *(void *)(a1 + 32));
}

BOOL sub_10005DD50()
{
  if (qword_1000EBC60 != -1) {
    dispatch_once(&qword_1000EBC60, &stru_1000DD7D0);
  }
  if (!qword_1000EB4C0) {
    return 0;
  }
  unsigned int v28 = 0;
  size_t v27 = 4;
  if (sysctl(dword_1000EBC50, qword_1000EB4C0, &v28, &v27, 0, 0))
  {
    int v13 = *__error();
    CFStringRef v14 = sub_10002E548();
    if (os_log_type_enabled(v14, OS_LOG_TYPE_FAULT)) {
      sub_1000930DC();
    }
    *__error() = v13;
    if (byte_1000EBCF9 && dword_1000EB4A8 <= 4)
    {
      int v15 = *__error();
      uint64_t v16 = *__error();
      CFStringRef v17 = __error();
      malloc_type_id_t v18 = strerror(*v17);
      CFStringRef v19 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"sysctl for kern.memorystatus_vm_pressure_level failed: %d (%s)", v16, v18);
      if (v19)
      {
        CFStringRef v20 = v19;
        CStringPtr = CFStringGetCStringPtr(v19, 0x8000100u);
        if (CStringPtr)
        {
          int v22 = (char *)CStringPtr;
          CFStringRef v23 = 0;
        }
        else
        {
          int v22 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x73292CDDuLL);
          CFStringGetCString(v20, v22, 1024, 0x8000100u);
          CFStringRef v23 = v22;
        }
        if (qword_1000EBD00) {
          double v26 = (FILE *)qword_1000EBD00;
        }
        else {
          double v26 = __stderrp;
        }
        fprintf(v26, "%s\n", v22);
        if (v23) {
          free(v23);
        }
        CFRelease(v20);
      }
      else
      {
        int v24 = sub_10002E548();
        if (os_log_type_enabled(v24, OS_LOG_TYPE_FAULT)) {
          sub_100093054();
        }
        if (qword_1000EBD00) {
          CFStringRef v25 = (FILE *)qword_1000EBD00;
        }
        else {
          CFStringRef v25 = __stderrp;
        }
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v25);
      }
      *__error() = v15;
    }
    unsigned int v28 = 0;
    qword_1000EB4C0 = 0;
  }
  if (byte_1000EBCF8)
  {
    int v0 = *__error();
    uint64_t v1 = sub_10002E548();
    if (os_log_type_enabled(v1, OS_LOG_TYPE_DEBUG)) {
      sub_100092FE8();
    }
    *__error() = v0;
  }
  if (byte_1000EBCF9) {
    BOOL v2 = dword_1000EB4A8 <= 0;
  }
  else {
    BOOL v2 = 0;
  }
  if (v2)
  {
    int v3 = *__error();
    CFStringRef v4 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"Memory pressure %d", v28);
    if (v4)
    {
      CFStringRef v5 = v4;
      BOOL v6 = CFStringGetCStringPtr(v4, 0x8000100u);
      if (v6)
      {
        int v7 = (char *)v6;
        CFStringRef v8 = 0;
      }
      else
      {
        int v7 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xBD26F3BEuLL);
        CFStringGetCString(v5, v7, 1024, 0x8000100u);
        CFStringRef v8 = v7;
      }
      if (qword_1000EBD00) {
        int v11 = (FILE *)qword_1000EBD00;
      }
      else {
        int v11 = __stderrp;
      }
      fprintf(v11, "%s\n", v7);
      if (v8) {
        free(v8);
      }
      CFRelease(v5);
    }
    else
    {
      malloc_type_id_t v9 = sub_10002E548();
      if (os_log_type_enabled(v9, OS_LOG_TYPE_FAULT)) {
        sub_100092F78();
      }
      if (qword_1000EBD00) {
        BOOL v10 = (FILE *)qword_1000EBD00;
      }
      else {
        BOOL v10 = __stderrp;
      }
      fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v10);
    }
    *__error() = v3;
  }
  return v28 > 3;
}

void sub_10005E130(id a1)
{
  if (sysctlnametomib("kern.memorystatus_vm_pressure_level", dword_1000EBC50, (size_t *)&qword_1000EB4C0))
  {
    int v1 = *__error();
    BOOL v2 = sub_10002E548();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      sub_1000931EC();
    }
    *__error() = v1;
    if (byte_1000EBCF9) {
      BOOL v3 = dword_1000EB4A8 <= 4;
    }
    else {
      BOOL v3 = 0;
    }
    if (v3)
    {
      int v15 = *__error();
      uint64_t v4 = *__error();
      CFStringRef v5 = __error();
      BOOL v6 = strerror(*v5);
      CFStringRef v7 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"sysctlnametomib for kern.memorystatus_vm_pressure_level failed: %d (%s)", v4, v6);
      if (v7)
      {
        CFStringRef theString = v7;
        CStringPtr = CFStringGetCStringPtr(v7, 0x8000100u);
        if (CStringPtr)
        {
          malloc_type_id_t v9 = (char *)CStringPtr;
          BOOL v10 = 0;
        }
        else
        {
          malloc_type_id_t v9 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xCAABF600uLL);
          CFStringGetCString(theString, v9, 1024, 0x8000100u);
          BOOL v10 = v9;
        }
        if (qword_1000EBD00) {
          int v13 = (FILE *)qword_1000EBD00;
        }
        else {
          int v13 = __stderrp;
        }
        fprintf(v13, "%s\n", v9);
        if (v10) {
          free(v10);
        }
        CFRelease(theString);
      }
      else
      {
        int v11 = sub_10002E548();
        if (os_log_type_enabled(v11, OS_LOG_TYPE_FAULT)) {
          sub_100093164();
        }
        if (qword_1000EBD00) {
          CFStringRef v12 = (FILE *)qword_1000EBD00;
        }
        else {
          CFStringRef v12 = __stderrp;
        }
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v12);
      }
      *__error() = v15;
    }
    qword_1000EB4C0 = 0;
  }
}

void sub_10005E318()
{
  if (geteuid())
  {
    if (byte_1000EBCF8)
    {
      int v0 = *__error();
      int v1 = sub_10002E548();
      if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR)) {
        sub_1000932F8();
      }
      *__error() = v0;
    }
    if (byte_1000EBCF9) {
      BOOL v2 = dword_1000EB4A8 <= 3;
    }
    else {
      BOOL v2 = 0;
    }
    if (v2)
    {
      int v3 = *__error();
      uint64_t v4 = geteuid();
      CFStringRef v5 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%s: spindump must run as root to create spindump directory (running as %d)", "geteuid() == 0", v4);
      if (v5)
      {
        CFStringRef v8 = v5;
        CStringPtr = CFStringGetCStringPtr(v5, 0x8000100u);
        if (CStringPtr)
        {
          BOOL v10 = 0;
        }
        else
        {
          BOOL v10 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x1BA0901DuLL);
          CFStringGetCString(v8, v10, 1024, 0x8000100u);
          CStringPtr = v10;
        }
        int v11 = (FILE *)qword_1000EBD00;
        if (!qword_1000EBD00) {
          int v11 = __stderrp;
        }
        fprintf(v11, "%s\n", CStringPtr);
        if (v10) {
          free(v10);
        }
        CFRelease(v8);
      }
      else
      {
        BOOL v6 = sub_10002E548();
        if (os_log_type_enabled(v6, OS_LOG_TYPE_FAULT)) {
          sub_100093274();
        }
        if (qword_1000EBD00) {
          CFStringRef v7 = (FILE *)qword_1000EBD00;
        }
        else {
          CFStringRef v7 = __stderrp;
        }
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v7);
      }
      *__error() = v3;
    }
    geteuid();
    sub_10002E41C("MakeSpindumpDirectory", "spindump.m", 4222, "%s: spindump must run as root to create spindump directory (running as %d)", v12, v13, v14, v15, (char)"geteuid() == 0");
    abort();
  }
  if (qword_1000EBC68 != -1)
  {
    dispatch_once(&qword_1000EBC68, &stru_1000DD7F0);
  }
}

void sub_10005E54C(id a1)
{
  memset(&v57, 0, sizeof(v57));
  if (!stat("/private/var/db/spindump", &v57))
  {
    if ((v57.st_mode & 0xF000) == 0x4000) {
      return;
    }
    if (byte_1000EBCF8)
    {
      int v15 = *__error();
      uint64_t v16 = sub_10002E548();
      if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR)) {
        sub_1000933F4(v16);
      }
      *__error() = v15;
    }
    if (byte_1000EBCF9) {
      BOOL v17 = dword_1000EB4A8 <= 3;
    }
    else {
      BOOL v17 = 0;
    }
    if (v17)
    {
      int v18 = *__error();
      CFStringRef v19 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%s: /private/var/db/spindump already exists and isnt a directory!", "(((st.st_mode) & 0170000) == 0040000)");
      if (v19)
      {
        CFStringRef v46 = v19;
        CStringPtr = CFStringGetCStringPtr(v19, 0x8000100u);
        if (CStringPtr)
        {
          int v48 = (char *)CStringPtr;
          CFStringRef v49 = 0;
        }
        else
        {
          int v48 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xD5916B7BuLL);
          CFStringGetCString(v46, v48, 1024, 0x8000100u);
          CFStringRef v49 = v48;
        }
        if (qword_1000EBD00) {
          int v56 = (FILE *)qword_1000EBD00;
        }
        else {
          int v56 = __stderrp;
        }
        fprintf(v56, "%s\n", v48);
        if (v49) {
          free(v49);
        }
        CFRelease(v46);
      }
      else
      {
        CFStringRef v20 = sub_10002E548();
        if (os_log_type_enabled(v20, OS_LOG_TYPE_FAULT)) {
          sub_10009337C(v20, v21, v22, v23, v24, v25, v26, v27);
        }
        if (qword_1000EBD00) {
          unsigned int v28 = (FILE *)qword_1000EBD00;
        }
        else {
          unsigned int v28 = __stderrp;
        }
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v28);
      }
      *__error() = v18;
    }
    sub_10002E41C("MakeSpindumpDirectory_block_invoke", "spindump.m", 4237, "%s: /private/var/db/spindump already exists and isnt a directory!", v1, v2, v3, v4, (char)"(((st.st_mode) & 0170000) == 0040000)");
LABEL_82:
    abort();
  }
  uint64_t v5 = *__error();
  if (byte_1000EBCF8)
  {
    int v6 = *__error();
    CFStringRef v7 = sub_10002E548();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG)) {
      sub_10009363C();
    }
    *__error() = v6;
  }
  if (byte_1000EBCF9) {
    BOOL v8 = dword_1000EB4A8 <= 0;
  }
  else {
    BOOL v8 = 0;
  }
  if (v8)
  {
    int v9 = *__error();
    CFStringRef v10 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"Creating spindump directory /private/var/db/spindump after stat said %d", v5);
    if (v10)
    {
      CFStringRef v11 = v10;
      uint64_t v12 = CFStringGetCStringPtr(v10, 0x8000100u);
      if (v12)
      {
        uint64_t v13 = (char *)v12;
        uint64_t v14 = 0;
      }
      else
      {
        uint64_t v13 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xD5916B7BuLL);
        CFStringGetCString(v11, v13, 1024, 0x8000100u);
        uint64_t v14 = v13;
      }
      if (qword_1000EBD00) {
        int v31 = (FILE *)qword_1000EBD00;
      }
      else {
        int v31 = __stderrp;
      }
      fprintf(v31, "%s\n", v13);
      if (v14) {
        free(v14);
      }
      CFRelease(v11);
    }
    else
    {
      uint64_t v29 = sub_10002E548();
      if (os_log_type_enabled(v29, OS_LOG_TYPE_FAULT)) {
        sub_1000935D0();
      }
      if (qword_1000EBD00) {
        uint64_t v30 = (FILE *)qword_1000EBD00;
      }
      else {
        uint64_t v30 = __stderrp;
      }
      fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v30);
    }
    *__error() = v9;
  }
  if (mkdir("/private/var/db/spindump", 0x1EDu))
  {
    if (byte_1000EBCF8)
    {
      int v32 = *__error();
      int v33 = sub_10002E548();
      if (os_log_type_enabled(v33, OS_LOG_TYPE_ERROR)) {
        sub_100093520();
      }
      *__error() = v32;
    }
    if (byte_1000EBCF9 && dword_1000EB4A8 <= 3)
    {
      int v34 = *__error();
      int v35 = strerror(v5);
      uint64_t v36 = *__error();
      id v37 = __error();
      uid_t v38 = strerror(*v37);
      CFStringRef v39 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%s: unable to create /private/var/db/spindump after state failed with %d (%s): %d (%s)", "ret == 0", v5, v35, v36, v38);
      if (v39)
      {
        CFStringRef v42 = v39;
        BOOL v43 = CFStringGetCStringPtr(v39, 0x8000100u);
        if (v43)
        {
          int v44 = (char *)v43;
          malloc_type_id_t v45 = 0;
        }
        else
        {
          int v44 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xD5916B7BuLL);
          CFStringGetCString(v42, v44, 1024, 0x8000100u);
          malloc_type_id_t v45 = v44;
        }
        if (qword_1000EBD00) {
          CFStringRef v50 = (FILE *)qword_1000EBD00;
        }
        else {
          CFStringRef v50 = __stderrp;
        }
        fprintf(v50, "%s\n", v44);
        if (v45) {
          free(v45);
        }
        CFRelease(v42);
      }
      else
      {
        int v40 = sub_10002E548();
        if (os_log_type_enabled(v40, OS_LOG_TYPE_FAULT)) {
          sub_100093478();
        }
        if (qword_1000EBD00) {
          int v41 = (FILE *)qword_1000EBD00;
        }
        else {
          int v41 = __stderrp;
        }
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v41);
      }
      *__error() = v34;
    }
    strerror(v5);
    __error();
    CFStringRef v51 = __error();
    strerror(*v51);
    sub_10002E41C("MakeSpindumpDirectory_block_invoke", "spindump.m", 4234, "%s: unable to create /private/var/db/spindump after state failed with %d (%s): %d (%s)", v52, v53, v54, v55, (char)"ret == 0");
    goto LABEL_82;
  }
}

id sub_10005EB20(void *a1, int a2, int a3, int a4)
{
  unint64_t v8 = (unint64_t)[a1 dataGatheringOptions];
  if (a2)
  {
    [a1 setDataGatheringOptions:v8 | 0x60];
    unint64_t v9 = (unint64_t)[a1 dataGatheringOptions];
    if (a3) {
      unint64_t v10 = v9 | 8;
    }
    else {
      unint64_t v10 = v9 & 0xFFFFFFFFFFFFFFF7;
    }
  }
  else
  {
    unint64_t v10 = v8 & 0xFFFFFFFFFFFFFF97;
  }
  [a1 setDataGatheringOptions:v10];
  unint64_t v11 = (unint64_t)[a1 dataGatheringOptions] & 0xFFFFFFFFFFFFFFEFLL;
  uint64_t v12 = 16;
  if (!a4) {
    uint64_t v12 = 0;
  }

  return [a1 setDataGatheringOptions:v11 | v12];
}

ssize_t sub_10005EBC4(ssize_t result)
{
  uint64_t v1 = *(void **)(*(void *)(*(void *)(result + 40) + 8) + 24);
  if (v1)
  {
    ssize_t v2 = result;
    id result = read(*(_DWORD *)(result + 48), v1, 0x3FFuLL);
    if (result >= 1)
    {
      do
      {
        *(unsigned char *)(*(void *)(*(void *)(*(void *)(v2 + 40) + 8) + 24) + result) = 0;
        [*(id *)(v2 + 32) appendFormat:@"%s", *(void *)(*(void *)(*(void *)(v2 + 40) + 8) + 24)];
        id result = read(*(_DWORD *)(v2 + 48), *(void **)(*(void *)(*(void *)(v2 + 40) + 8) + 24), 0x3FFuLL);
      }
      while (result > 0);
    }
  }
  return result;
}

void sub_10005EC60(uint64_t a1)
{
  close(*(_DWORD *)(a1 + 40));
  ssize_t v2 = *(NSObject **)(a1 + 32);

  dispatch_release(v2);
}

ssize_t sub_10005EC9C(ssize_t result)
{
  uint64_t v1 = *(void **)(*(void *)(*(void *)(result + 40) + 8) + 24);
  if (v1)
  {
    ssize_t v2 = result;
    id result = read(*(_DWORD *)(result + 48), v1, 0x3FFuLL);
    if (result >= 1)
    {
      do
      {
        *(unsigned char *)(*(void *)(*(void *)(*(void *)(v2 + 40) + 8) + 24) + result) = 0;
        [*(id *)(v2 + 32) appendFormat:@"%s", *(void *)(*(void *)(*(void *)(v2 + 40) + 8) + 24)];
        id result = read(*(_DWORD *)(v2 + 48), *(void **)(*(void *)(*(void *)(v2 + 40) + 8) + 24), 0x3FFuLL);
      }
      while (result > 0);
    }
  }
  return result;
}

void sub_10005ED38(uint64_t a1)
{
  close(*(_DWORD *)(a1 + 40));
  ssize_t v2 = *(NSObject **)(a1 + 32);

  dispatch_release(v2);
}

uint64_t sub_10005ED74(uint64_t a1)
{
  int v5 = 0;
  while (waitpid(*(_DWORD *)(a1 + 80), &v5, 0) == -1 && *__error() == 4)
    ;
  dispatch_source_cancel(*(dispatch_source_t *)(a1 + 32));
  dispatch_source_cancel(*(dispatch_source_t *)(a1 + 40));
  dispatch_source_cancel(*(dispatch_source_t *)(a1 + 48));
  fcntl(*(_DWORD *)(a1 + 84), 4, 0);
  fcntl(*(_DWORD *)(a1 + 88), 4, 0);
  ssize_t v2 = read(*(_DWORD *)(a1 + 84), *(void **)(*(void *)(*(void *)(a1 + 72) + 8) + 24), 0x3FFuLL);
  if (v2 >= 1)
  {
    do
    {
      *(unsigned char *)(*(void *)(*(void *)(*(void *)(a1 + 72) + 8) + 24) + v2) = 0;
      [*(id *)(a1 + 56) appendFormat:@"%s", *(void *)(*(void *)(*(void *)(a1 + 72) + 8) + 24)];
      ssize_t v2 = read(*(_DWORD *)(a1 + 84), *(void **)(*(void *)(*(void *)(a1 + 72) + 8) + 24), 0x3FFuLL);
    }
    while (v2 > 0);
  }
  ssize_t v3 = read(*(_DWORD *)(a1 + 88), *(void **)(*(void *)(*(void *)(a1 + 72) + 8) + 24), 0x3FFuLL);
  if (v3 >= 1)
  {
    do
    {
      *(unsigned char *)(*(void *)(*(void *)(*(void *)(a1 + 72) + 8) + 24) + v3) = 0;
      [*(id *)(a1 + 56) appendFormat:@"%s", *(void *)(*(void *)(*(void *)(a1 + 72) + 8) + 24)];
      ssize_t v3 = read(*(_DWORD *)(a1 + 88), *(void **)(*(void *)(*(void *)(a1 + 72) + 8) + 24), 0x3FFuLL);
    }
    while (v3 > 0);
  }
  free(*(void **)(*(void *)(*(void *)(a1 + 72) + 8) + 24));
  *(void *)(*(void *)(*(void *)(a1 + 72) + 8) + 24) = 0;
  return (*(uint64_t (**)(void))(*(void *)(a1 + 64) + 16))();
}

void sub_10005EF14(uint64_t a1)
{
}

_DWORD *sub_10005EF84(void *a1, int *a2)
{
  int v3 = *(_DWORD *)(*a1 + 4 * *a2);
  return sub_10002E4E8(v3);
}

void sub_10005EFA4(void *a1, uint64_t a2, os_log_t log, const char *a4, ...)
{
  va_start(va, a4);
  _os_log_fault_impl(a1, log, OS_LOG_TYPE_FAULT, a4, (uint8_t *)va, 8u);
}

void sub_10005EFC4(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint8_t *a5)
{
  _os_log_fault_impl(a1, a2, OS_LOG_TYPE_FAULT, a4, a5, 8u);
}

void sub_10005EFEC(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_debug_impl(a1, a2, OS_LOG_TYPE_DEBUG, a4, &a9, 8u);
}

void sub_10005F008(void *a1, uint64_t a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_error_impl(a1, v9, OS_LOG_TYPE_ERROR, a4, &a9, 0xCu);
}

void sub_10005F068(void *a1, uint64_t a2, os_log_t log, const char *a4, ...)
{
  va_start(va, a4);
  _os_log_error_impl(a1, log, OS_LOG_TYPE_ERROR, a4, (uint8_t *)va, 8u);
}

void sub_10005FBD0(id a1, void *a2, unint64_t a3)
{
}

void sub_10005FBF4(uint64_t a1@<X8>)
{
  *(void *)(v1 - _Block_object_dispose(&STACK[0x378], 8) = a1;
}

void sub_10005FC00(uint64_t a1@<X8>)
{
  *(void *)(v1 - _Block_object_dispose(&STACK[0x378], 8) = a1;
}

double sub_100060284(void *a1, void *a2)
{
  [a1 machAbsTimeSeconds];
  if (v4 != 0.0)
  {
    [a2 machAbsTimeSeconds];
    if (v5 != 0.0)
    {
      [a2 machAbsTimeSeconds];
      double v7 = v6;
      [a1 machAbsTimeSeconds];
      return v7 - v8;
    }
  }
  [a1 machContTimeSeconds];
  if (v9 != 0.0)
  {
    [a2 machContTimeSeconds];
    if (v10 != 0.0)
    {
      [a2 machContTimeSeconds];
      double v7 = v11;
      [a1 machContTimeSeconds];
      return v7 - v8;
    }
  }
  [a1 wallTime];
  double v12 = 0.0;
  if (v13 != 0.0)
  {
    [a2 wallTime];
    if (v14 != 0.0)
    {
      [a2 wallTime];
      double v7 = v15;
      [a1 wallTime];
      return v7 - v8;
    }
  }
  return v12;
}

void sub_100062244(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_10006225C(id a1)
{
  qword_1000EBC78 = (uint64_t)objc_alloc_init((Class)NSMutableDictionary);
  uint64_t v1 = dispatch_queue_attr_make_with_autorelease_frequency(0, DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM);
  qword_1000EBC80 = (uint64_t)dispatch_queue_create("com.apple.spindump.create_sampled_process", v1);

  dispatch_release(v1);
}

void sub_1000622C8(uint64_t a1, uint64_t a2)
{
}

void sub_1000622D8(uint64_t a1)
{
}

id sub_1000622E4(uint64_t a1)
{
  *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 40) = [(id)qword_1000EBC78 objectForKey:*(void *)(a1 + 32)];
  id result = *(id *)(*(void *)(*(void *)(a1 + 40) + 8) + 40);
  if (result)
  {
    int v3 = *(unsigned char **)(a1 + 48);
    if (v3)
    {
      unsigned char *v3 = 1;
      id result = *(id *)(*(void *)(*(void *)(a1 + 40) + 8) + 40);
    }
    id result = [result isWSBased];
    uint64_t v4 = *(void *)(*(void *)(a1 + 40) + 8);
    if (*(unsigned __int8 *)(a1 + 61) == result)
    {
      double v5 = *(void **)(v4 + 40);
      return v5;
    }
    else
    {
      *(void *)(v4 + 40) = 0;
    }
  }
  else
  {
    if (*(unsigned char *)(a1 + 60))
    {
      *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 40) = [[SPSampledProcess alloc] initWithPid:*(unsigned int *)(a1 + 56) isWSBased:*(unsigned __int8 *)(a1 + 61)];
      id result = [(id)qword_1000EBC78 setObject:*(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 40) forKey:*(void *)(a1 + 32)];
      *(unsigned char *)(*(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 40) + 299) = 1;
    }
    double v6 = *(unsigned char **)(a1 + 48);
    if (v6) {
      *double v6 = 0;
    }
  }
  return result;
}

id sub_100062484(uint64_t a1)
{
  id v2 = [objc_alloc((Class)NSNumber) initWithInt:*(unsigned int *)(a1 + 40)];
  id v3 = *(id *)(a1 + 32);
  if (v3 == [(id)qword_1000EBC78 objectForKey:v2]) {
    [(id)qword_1000EBC78 removeObjectForKey:v2];
  }

  id result = [(id)qword_1000EBC78 count];
  if (!result)
  {
    return +[SPSampledProcess stopMemoryPressureTimer];
  }
  return result;
}

id sub_1000628DC(uint64_t a1)
{
  uint64_t v1 = (id *)(a1 + 32);
  if ((*(_DWORD *)(*(void *)(a1 + 32) + 72) & 0x80000000) == 0)
  {
    if (byte_1000EBCF8)
    {
      int v2 = *__error();
      id v3 = sub_10002E548();
      if (os_log_type_enabled(v3, OS_LOG_TYPE_INFO))
      {
        uint64_t v4 = sub_10002E4E8(*((_DWORD *)*v1 + 18));
        int v5 = *((_DWORD *)*v1 + 18);
        *(_DWORD *)buf = 136446466;
        uint64_t v24 = v4;
        __int16 v25 = 1024;
        int v26 = v5;
        _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_INFO, "%{public}s [%d]: exited - HID", buf, 0x12u);
      }
      *__error() = v2;
    }
    if (byte_1000EBCF9) {
      BOOL v6 = dword_1000EB4A8 <= 1;
    }
    else {
      BOOL v6 = 0;
    }
    if (!v6) {
      goto LABEL_40;
    }
    int v7 = *__error();
    double v8 = sub_10002E4E8(*((_DWORD *)*v1 + 18));
    CFStringRef v9 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%s [%d]: exited - HID", v8, *((unsigned int *)*v1 + 18));
    if (!v9)
    {
      double v10 = sub_10002E548();
      if (os_log_type_enabled(v10, OS_LOG_TYPE_FAULT)) {
        sub_1000945E4();
      }
LABEL_35:
      if (qword_1000EBD00) {
        CFStringRef v20 = (FILE *)qword_1000EBD00;
      }
      else {
        CFStringRef v20 = __stderrp;
      }
      fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v20);
LABEL_39:
      *__error() = v7;
      goto LABEL_40;
    }
    goto LABEL_24;
  }
  if (byte_1000EBCF8)
  {
    int v11 = *__error();
    double v12 = sub_10002E548();
    if (os_log_type_enabled(v12, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_INFO, "exited - HID", buf, 2u);
    }
    *__error() = v11;
  }
  if (byte_1000EBCF9) {
    BOOL v13 = dword_1000EB4A8 <= 1;
  }
  else {
    BOOL v13 = 0;
  }
  if (v13)
  {
    int v7 = *__error();
    CFStringRef v9 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"exited - HID");
    if (!v9)
    {
      CFStringRef v19 = sub_10002E548();
      if (os_log_type_enabled(v19, OS_LOG_TYPE_FAULT)) {
        sub_10009465C();
      }
      goto LABEL_35;
    }
LABEL_24:
    CFStringRef v14 = v9;
    CStringPtr = CFStringGetCStringPtr(v9, 0x8000100u);
    if (CStringPtr)
    {
      uint64_t v16 = (char *)CStringPtr;
      BOOL v17 = 0;
    }
    else
    {
      uint64_t v16 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xB473D439uLL);
      CFStringGetCString(v14, v16, 1024, 0x8000100u);
      BOOL v17 = v16;
    }
    if (qword_1000EBD00) {
      int v18 = (FILE *)qword_1000EBD00;
    }
    else {
      int v18 = __stderrp;
    }
    fprintf(v18, "%s\n", v16);
    if (v17) {
      free(v17);
    }
    CFRelease(v14);
    goto LABEL_39;
  }
LABEL_40:
  v22[0] = _NSConcreteStackBlock;
  v22[1] = 3221225472;
  v22[2] = sub_100062CF8;
  v22[3] = &unk_1000DD948;
  v22[4] = *v1;
  sub_100062C50((uint64_t)v22);
  return [*v1 deleteHIDExitSource];
}

void sub_100062C50(uint64_t a1)
{
  if (qword_1000EBC98 != -1) {
    dispatch_once(&qword_1000EBC98, &stru_1000DDAF8);
  }
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_10006DCE4;
  block[3] = &unk_1000DDB20;
  void block[4] = a1;
  dispatch_sync((dispatch_queue_t)qword_1000EBC88, block);
}

int *sub_100062CF8(uint64_t a1, void *a2)
{
  id v3 = (int **)(a1 + 32);
  id result = (int *)[a2 objectForKeyedSubscript:+[NSNumber numberWithInt:](NSNumber, "numberWithInt:", *(unsigned int *)(*(void *)(a1 + 32) + 72))];
  int v5 = *v3;
  if (result) {
    BOOL v6 = result == v5;
  }
  else {
    BOOL v6 = 0;
  }
  if (v6)
  {
    BOOL v17 = result;
    if (result[18] < 0)
    {
      if (byte_1000EBCF8)
      {
        int v33 = *__error();
        int v34 = sub_10002E548();
        if (os_log_type_enabled(v34, OS_LOG_TYPE_DEBUG)) {
          sub_1000947B4();
        }
        *__error() = v33;
      }
      if (byte_1000EBCF9) {
        BOOL v35 = dword_1000EB4A8 <= 0;
      }
      else {
        BOOL v35 = 0;
      }
      if (!v35) {
        goto LABEL_84;
      }
      int v21 = *__error();
      CFStringRef v23 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"Process exited, no longer waiting for HID event");
      if (!v23)
      {
        CFStringRef v46 = sub_10002E548();
        if (os_log_type_enabled(v46, OS_LOG_TYPE_FAULT)) {
          sub_100094780();
        }
        goto LABEL_79;
      }
    }
    else
    {
      if (byte_1000EBCF8)
      {
        int v18 = *__error();
        CFStringRef v19 = sub_10002E548();
        if (os_log_type_enabled(v19, OS_LOG_TYPE_DEBUG)) {
          sub_100094708();
        }
        *__error() = v18;
      }
      if (byte_1000EBCF9) {
        BOOL v20 = dword_1000EB4A8 <= 0;
      }
      else {
        BOOL v20 = 0;
      }
      if (!v20) {
        goto LABEL_84;
      }
      int v21 = *__error();
      uint64_t v22 = sub_10002E4E8((*v3)[18]);
      CFStringRef v23 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%s [%d]: Process exited, no longer waiting for HID event", v22, (*v3)[18]);
      if (!v23)
      {
        uint64_t v24 = sub_10002E548();
        if (os_log_type_enabled(v24, OS_LOG_TYPE_FAULT)) {
          sub_100094690();
        }
LABEL_79:
        if (qword_1000EBD00) {
          int v47 = (FILE *)qword_1000EBD00;
        }
        else {
          int v47 = __stderrp;
        }
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v47);
LABEL_83:
        *__error() = v21;
LABEL_84:
        dispatch_semaphore_signal(*((dispatch_semaphore_t *)v17 + 53));
        return (int *)[a2 setObject:0 forKeyedSubscript:+[NSNumber numberWithInt:](NSNumber, "numberWithInt:", (*v3)[18])];
      }
    }
    CFStringRef v36 = v23;
    CStringPtr = CFStringGetCStringPtr(v23, 0x8000100u);
    if (CStringPtr)
    {
      uid_t v38 = (char *)CStringPtr;
      CFStringRef v39 = 0;
    }
    else
    {
      uid_t v38 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xE906A8A2uLL);
      CFStringGetCString(v36, v38, 1024, 0x8000100u);
      CFStringRef v39 = v38;
    }
    if (qword_1000EBD00) {
      int v41 = (FILE *)qword_1000EBD00;
    }
    else {
      int v41 = __stderrp;
    }
    fprintf(v41, "%s\n", v38);
    if (v39) {
      free(v39);
    }
    CFRelease(v36);
    goto LABEL_83;
  }
  if ((v5[18] & 0x80000000) == 0)
  {
    if (byte_1000EBCF8)
    {
      int v7 = *__error();
      double v8 = sub_10002E548();
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG)) {
        sub_100094860();
      }
      id result = __error();
      int *result = v7;
    }
    if (byte_1000EBCF9) {
      BOOL v9 = dword_1000EB4A8 <= 0;
    }
    else {
      BOOL v9 = 0;
    }
    if (!v9) {
      return result;
    }
    int v10 = *__error();
    int v11 = sub_10002E4E8((*v3)[18]);
    CFStringRef v12 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%s [%d]: Process exited, and not waiting for a HID event", v11, (*v3)[18]);
    if (v12)
    {
      CFStringRef v13 = v12;
      CFStringRef v14 = CFStringGetCStringPtr(v12, 0x8000100u);
      if (v14)
      {
        double v15 = (char *)v14;
        uint64_t v16 = 0;
      }
      else
      {
        double v15 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xB89FEB8EuLL);
        CFStringGetCString(v13, v15, 1024, 0x8000100u);
        uint64_t v16 = v15;
      }
      if (qword_1000EBD00) {
        CFStringRef v42 = (FILE *)qword_1000EBD00;
      }
      else {
        CFStringRef v42 = __stderrp;
      }
      fprintf(v42, "%s\n", v15);
      if (v16) {
        free(v16);
      }
      CFStringRef v43 = v13;
LABEL_92:
      CFRelease(v43);
LABEL_93:
      id result = __error();
      int *result = v10;
      return result;
    }
    int v40 = sub_10002E548();
    if (os_log_type_enabled(v40, OS_LOG_TYPE_FAULT)) {
      sub_1000947E8();
    }
    goto LABEL_73;
  }
  if (byte_1000EBCF8)
  {
    int v25 = *__error();
    int v26 = sub_10002E548();
    if (os_log_type_enabled(v26, OS_LOG_TYPE_DEBUG)) {
      sub_10009490C();
    }
    id result = __error();
    int *result = v25;
  }
  if (byte_1000EBCF9) {
    BOOL v27 = dword_1000EB4A8 <= 0;
  }
  else {
    BOOL v27 = 0;
  }
  if (v27)
  {
    int v10 = *__error();
    CFStringRef v28 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"Process exited, and not waiting for a HID event");
    if (v28)
    {
      CFStringRef v29 = v28;
      uint64_t v30 = CFStringGetCStringPtr(v28, 0x8000100u);
      if (v30)
      {
        int v31 = (char *)v30;
        int v32 = 0;
      }
      else
      {
        int v31 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xB89FEB8EuLL);
        CFStringGetCString(v29, v31, 1024, 0x8000100u);
        int v32 = v31;
      }
      if (qword_1000EBD00) {
        int v48 = (FILE *)qword_1000EBD00;
      }
      else {
        int v48 = __stderrp;
      }
      fprintf(v48, "%s\n", v31);
      if (v32) {
        free(v32);
      }
      CFStringRef v43 = v29;
      goto LABEL_92;
    }
    int v44 = sub_10002E548();
    if (os_log_type_enabled(v44, OS_LOG_TYPE_FAULT)) {
      sub_1000948D8();
    }
LABEL_73:
    if (qword_1000EBD00) {
      malloc_type_id_t v45 = (FILE *)qword_1000EBD00;
    }
    else {
      malloc_type_id_t v45 = __stderrp;
    }
    fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v45);
    goto LABEL_93;
  }
  return result;
}

void sub_100063380(uint64_t a1)
{
  v1[0] = _NSConcreteStackBlock;
  v1[1] = 3221225472;
  v1[2] = sub_1000633F8;
  v1[3] = &unk_1000DD970;
  v1[4] = *(void *)(a1 + 32);
  char v2 = *(unsigned char *)(a1 + 40);
  sub_100062C50((uint64_t)v1);
}

int *sub_1000633F8(uint64_t a1, void *a2)
{
  id v3 = (int **)(a1 + 32);
  id result = (int *)[a2 objectForKeyedSubscript:[NSNumber numberWithInt:objc_msgSend(*(id *)(a1 + 32), "targetProcessId")]];
  int v5 = *v3;
  if (!*((unsigned char *)v3 + 8))
  {
    if (result)
    {
      if (result != v5)
      {
        if (v5[18] < 0)
        {
          if (byte_1000EBCF8)
          {
            int v67 = *__error();
            int v68 = sub_10002E548();
            if (os_log_type_enabled(v68, OS_LOG_TYPE_DEBUG)) {
              sub_100095134();
            }
            *__error() = v67;
          }
          if (byte_1000EBCF9) {
            BOOL v69 = dword_1000EB4A8 <= 0;
          }
          else {
            BOOL v69 = 0;
          }
          if (!v69) {
            goto LABEL_216;
          }
          int v18 = *__error();
          CFStringRef v20 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"Previous spin waiting for HID event");
          if (!v20)
          {
            id v107 = sub_10002E548();
            if (os_log_type_enabled(v107, OS_LOG_TYPE_FAULT)) {
              sub_100095100();
            }
            goto LABEL_211;
          }
        }
        else
        {
          if (byte_1000EBCF8)
          {
            int v15 = *__error();
            uint64_t v16 = sub_10002E548();
            if (os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG)) {
              sub_100095088();
            }
            *__error() = v15;
          }
          if (byte_1000EBCF9) {
            BOOL v17 = dword_1000EB4A8 <= 0;
          }
          else {
            BOOL v17 = 0;
          }
          if (!v17) {
            goto LABEL_216;
          }
          int v18 = *__error();
          CFStringRef v19 = sub_10002E4E8((*v3)[18]);
          CFStringRef v20 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%s [%d]: Previous spin waiting for HID event", v19, (*v3)[18]);
          if (!v20)
          {
            int v21 = sub_10002E548();
            if (os_log_type_enabled(v21, OS_LOG_TYPE_FAULT)) {
              sub_100095010();
            }
LABEL_211:
            if (qword_1000EBD00) {
              id v108 = (FILE *)qword_1000EBD00;
            }
            else {
              id v108 = __stderrp;
            }
            fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v108);
LABEL_215:
            *__error() = v18;
LABEL_216:
            id result = *v3;
            if (!*((void *)*v3 + 53)) {
              return result;
            }
            if (([result targetProcessId] & 0x80000000) != 0)
            {
              if (byte_1000EBCF8)
              {
                int v135 = *__error();
                id v136 = sub_10002E548();
                if (os_log_type_enabled(v136, OS_LOG_TYPE_ERROR)) {
                  sub_100094F98(v136, v137, v138, v139, v140, v141, v142, v143);
                }
                *__error() = v135;
              }
              if (byte_1000EBCF9 && dword_1000EB4A8 <= 3)
              {
                int v144 = *__error();
                CFStringRef v145 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%s: _hidEventSem non-NULL when already tracking this process in previous spin", "_hidEventSem == NULL");
                if (v145)
                {
                  CFStringRef v179 = v145;
                  CStringPtr = CFStringGetCStringPtr(v145, 0x8000100u);
                  if (CStringPtr)
                  {
                    id v181 = (char *)CStringPtr;
                    id v182 = 0;
                  }
                  else
                  {
                    id v181 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x81381D63uLL);
                    CFStringGetCString(v179, v181, 1024, 0x8000100u);
                    id v182 = v181;
                  }
                  if (qword_1000EBD00) {
                    uint64_t v194 = (FILE *)qword_1000EBD00;
                  }
                  else {
                    uint64_t v194 = __stderrp;
                  }
                  fprintf(v194, "%s\n", v181);
                  if (v182) {
                    free(v182);
                  }
                  CFRelease(v179);
                }
                else
                {
                  BOOL v146 = sub_10002E548();
                  if (os_log_type_enabled(v146, OS_LOG_TYPE_FAULT)) {
                    sub_100094F20(v146, v147, v148, v149, v150, v151, v152, v153);
                  }
                  if (qword_1000EBD00) {
                    id v154 = (FILE *)qword_1000EBD00;
                  }
                  else {
                    id v154 = __stderrp;
                  }
                  fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v154);
                }
                *__error() = v144;
              }
              int v199 = "_hidEventSem == NULL";
              uint64_t v193 = "%s: _hidEventSem non-NULL when already tracking this process in previous spin";
            }
            else
            {
              if (byte_1000EBCF8)
              {
                int v113 = *__error();
                id v114 = sub_10002E548();
                if (os_log_type_enabled(v114, OS_LOG_TYPE_ERROR)) {
                  sub_100094E90();
                }
                *__error() = v113;
              }
              if (byte_1000EBCF9 && dword_1000EB4A8 <= 3)
              {
                int v115 = *__error();
                id v116 = sub_10002E4E8((int)[*v3 targetProcessId]);
                CFStringRef v117 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%s [%d]: %s: _hidEventSem non-NULL when already tracking this process in previous spin", v116, [*v3 targetProcessId], "_hidEventSem == NULL");
                if (v117)
                {
                  CFStringRef v175 = v117;
                  int v176 = CFStringGetCStringPtr(v117, 0x8000100u);
                  if (v176)
                  {
                    id v177 = (char *)v176;
                    id v178 = 0;
                  }
                  else
                  {
                    id v177 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x81381D63uLL);
                    CFStringGetCString(v175, v177, 1024, 0x8000100u);
                    id v178 = v177;
                  }
                  if (qword_1000EBD00) {
                    int v191 = (FILE *)qword_1000EBD00;
                  }
                  else {
                    int v191 = __stderrp;
                  }
                  fprintf(v191, "%s\n", v177);
                  if (v178) {
                    free(v178);
                  }
                  CFRelease(v175);
                }
                else
                {
                  id v118 = sub_10002E548();
                  if (os_log_type_enabled(v118, OS_LOG_TYPE_FAULT)) {
                    sub_100094E00();
                  }
                  if (qword_1000EBD00) {
                    id v119 = (FILE *)qword_1000EBD00;
                  }
                  else {
                    id v119 = __stderrp;
                  }
                  fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v119);
                }
                *__error() = v115;
              }
              unsigned __int8 v192 = sub_10002E4E8((int)[*v3 targetProcessId]);
              [*v3 targetProcessId];
              LOBYTE(v199) = v192;
              uint64_t v193 = "%s [%d]: %s: _hidEventSem non-NULL when already tracking this process in previous spin";
            }
            int v195 = 951;
            goto LABEL_356;
          }
        }
        CFStringRef v70 = v20;
        uint64_t v71 = CFStringGetCStringPtr(v20, 0x8000100u);
        if (v71)
        {
          id v72 = (char *)v71;
          int v73 = 0;
        }
        else
        {
          id v72 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x6906A0A6uLL);
          CFStringGetCString(v70, v72, 1024, 0x8000100u);
          int v73 = v72;
        }
        if (qword_1000EBD00) {
          id v101 = (FILE *)qword_1000EBD00;
        }
        else {
          id v101 = __stderrp;
        }
        fprintf(v101, "%s\n", v72);
        if (v73) {
          free(v73);
        }
        CFRelease(v70);
        goto LABEL_215;
      }
      if (result[18] < 0)
      {
        if (byte_1000EBCF8)
        {
          int v89 = *__error();
          id v90 = sub_10002E548();
          if (os_log_type_enabled(v90, OS_LOG_TYPE_DEBUG)) {
            sub_100094DCC();
          }
          *__error() = v89;
        }
        if (byte_1000EBCF9) {
          BOOL v91 = dword_1000EB4A8 <= 0;
        }
        else {
          BOOL v91 = 0;
        }
        if (!v91) {
          goto LABEL_282;
        }
        int v56 = *__error();
        CFStringRef v58 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"No longer waiting for HID event");
        if (!v58)
        {
          id v133 = sub_10002E548();
          if (os_log_type_enabled(v133, OS_LOG_TYPE_FAULT)) {
            sub_100094D98();
          }
          goto LABEL_277;
        }
      }
      else
      {
        if (byte_1000EBCF8)
        {
          int v53 = *__error();
          uint64_t v54 = sub_10002E548();
          if (os_log_type_enabled(v54, OS_LOG_TYPE_DEBUG)) {
            sub_100094D20();
          }
          *__error() = v53;
        }
        if (byte_1000EBCF9) {
          BOOL v55 = dword_1000EB4A8 <= 0;
        }
        else {
          BOOL v55 = 0;
        }
        if (!v55) {
          goto LABEL_282;
        }
        int v56 = *__error();
        stat v57 = sub_10002E4E8((*v3)[18]);
        CFStringRef v58 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%s [%d]: No longer waiting for HID event", v57, (*v3)[18]);
        if (!v58)
        {
          int v59 = sub_10002E548();
          if (os_log_type_enabled(v59, OS_LOG_TYPE_FAULT)) {
            sub_100094CA8();
          }
LABEL_277:
          if (qword_1000EBD00) {
            id v134 = (FILE *)qword_1000EBD00;
          }
          else {
            id v134 = __stderrp;
          }
          fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v134);
LABEL_281:
          *__error() = v56;
LABEL_282:
          dispatch_semaphore_signal(*((dispatch_semaphore_t *)*v3 + 53));
          dispatch_release(*((dispatch_object_t *)*v3 + 53));
          *((void *)*v3 + 53) = 0;
          [a2 setObject:0 forKeyedSubscript:[NSNumber numberWithInt:objc_msgSend(*v3, "targetProcessId")]];
          return (int *)[*v3 deleteHIDExitSource];
        }
      }
      CFStringRef v92 = v58;
      CFStringRef v93 = CFStringGetCStringPtr(v58, 0x8000100u);
      if (v93)
      {
        uint64_t v94 = (char *)v93;
        id v95 = 0;
      }
      else
      {
        uint64_t v94 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xFAF3B7D1uLL);
        CFStringGetCString(v92, v94, 1024, 0x8000100u);
        id v95 = v94;
      }
      if (qword_1000EBD00) {
        id v122 = (FILE *)qword_1000EBD00;
      }
      else {
        id v122 = __stderrp;
      }
      fprintf(v122, "%s\n", v94);
      if (v95) {
        free(v95);
      }
      CFRelease(v92);
      goto LABEL_281;
    }
    if (v5[18] < 0)
    {
      if (byte_1000EBCF8)
      {
        int v82 = *__error();
        unsigned int v83 = sub_10002E548();
        if (os_log_type_enabled(v83, OS_LOG_TYPE_DEBUG)) {
          sub_100094C74();
        }
        *__error() = v82;
      }
      if (byte_1000EBCF9) {
        BOOL v84 = dword_1000EB4A8 <= 0;
      }
      else {
        BOOL v84 = 0;
      }
      if (!v84) {
        goto LABEL_251;
      }
      int v42 = *__error();
      CFStringRef v44 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"Doesn't require HID event and we weren't waiting before anyway");
      if (!v44)
      {
        uint64_t v123 = sub_10002E548();
        if (os_log_type_enabled(v123, OS_LOG_TYPE_FAULT)) {
          sub_100094C40();
        }
        goto LABEL_246;
      }
    }
    else
    {
      if (byte_1000EBCF8)
      {
        int v39 = *__error();
        int v40 = sub_10002E548();
        if (os_log_type_enabled(v40, OS_LOG_TYPE_DEBUG)) {
          sub_100094BC8();
        }
        *__error() = v39;
      }
      if (byte_1000EBCF9) {
        BOOL v41 = dword_1000EB4A8 <= 0;
      }
      else {
        BOOL v41 = 0;
      }
      if (!v41) {
        goto LABEL_251;
      }
      int v42 = *__error();
      CFStringRef v43 = sub_10002E4E8((*v3)[18]);
      CFStringRef v44 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%s [%d]: Doesn't require HID event and we weren't waiting before anyway", v43, (*v3)[18]);
      if (!v44)
      {
        malloc_type_id_t v45 = sub_10002E548();
        if (os_log_type_enabled(v45, OS_LOG_TYPE_FAULT)) {
          sub_100094B50();
        }
LABEL_246:
        if (qword_1000EBD00) {
          id v124 = (FILE *)qword_1000EBD00;
        }
        else {
          id v124 = __stderrp;
        }
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v124);
LABEL_250:
        *__error() = v42;
LABEL_251:
        id result = *v3;
        if (!*((void *)*v3 + 53)) {
          return result;
        }
        if (([result targetProcessId] & 0x80000000) != 0)
        {
          if (byte_1000EBCF8)
          {
            int v155 = *__error();
            id v156 = sub_10002E548();
            if (os_log_type_enabled(v156, OS_LOG_TYPE_ERROR)) {
              sub_100094AD8(v156, v157, v158, v159, v160, v161, v162, v163);
            }
            *__error() = v155;
          }
          if (byte_1000EBCF9 && dword_1000EB4A8 <= 3)
          {
            int v164 = *__error();
            CFStringRef v165 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%s: _hidEventSem non-NULL when not requiring HID event", "_hidEventSem == NULL");
            if (v165)
            {
              CFStringRef v187 = v165;
              CFStringRef v188 = CFStringGetCStringPtr(v165, 0x8000100u);
              if (v188)
              {
                double v189 = (char *)v188;
                int v190 = 0;
              }
              else
              {
                double v189 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x161961A5uLL);
                CFStringGetCString(v187, v189, 1024, 0x8000100u);
                int v190 = v189;
              }
              if (qword_1000EBD00) {
                unsigned int v198 = (FILE *)qword_1000EBD00;
              }
              else {
                unsigned int v198 = __stderrp;
              }
              fprintf(v198, "%s\n", v189);
              if (v190) {
                free(v190);
              }
              CFRelease(v187);
            }
            else
            {
              uint64_t v166 = sub_10002E548();
              if (os_log_type_enabled(v166, OS_LOG_TYPE_FAULT)) {
                sub_100094A60(v166, v167, v168, v169, v170, v171, v172, v173);
              }
              if (qword_1000EBD00) {
                id v174 = (FILE *)qword_1000EBD00;
              }
              else {
                id v174 = __stderrp;
              }
              fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v174);
            }
            *__error() = v164;
          }
          int v199 = "_hidEventSem == NULL";
          uint64_t v193 = "%s: _hidEventSem non-NULL when not requiring HID event";
        }
        else
        {
          if (byte_1000EBCF8)
          {
            int v125 = *__error();
            id v126 = sub_10002E548();
            if (os_log_type_enabled(v126, OS_LOG_TYPE_ERROR)) {
              sub_1000949D0();
            }
            *__error() = v125;
          }
          if (byte_1000EBCF9 && dword_1000EB4A8 <= 3)
          {
            int v127 = *__error();
            id v128 = sub_10002E4E8((int)[*v3 targetProcessId]);
            CFStringRef v129 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%s [%d]: %s: _hidEventSem non-NULL when not requiring HID event", v128, [*v3 targetProcessId], "_hidEventSem == NULL");
            if (v129)
            {
              CFStringRef v183 = v129;
              id v184 = CFStringGetCStringPtr(v129, 0x8000100u);
              if (v184)
              {
                id v185 = (char *)v184;
                id v186 = 0;
              }
              else
              {
                id v185 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x161961A5uLL);
                CFStringGetCString(v183, v185, 1024, 0x8000100u);
                id v186 = v185;
              }
              if (qword_1000EBD00) {
                id v196 = (FILE *)qword_1000EBD00;
              }
              else {
                id v196 = __stderrp;
              }
              fprintf(v196, "%s\n", v185);
              if (v186) {
                free(v186);
              }
              CFRelease(v183);
            }
            else
            {
              unsigned int v130 = sub_10002E548();
              if (os_log_type_enabled(v130, OS_LOG_TYPE_FAULT)) {
                sub_100094940();
              }
              if (qword_1000EBD00) {
                id v131 = (FILE *)qword_1000EBD00;
              }
              else {
                id v131 = __stderrp;
              }
              fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v131);
            }
            *__error() = v127;
          }
          unsigned __int8 v197 = sub_10002E4E8((int)[*v3 targetProcessId]);
          [*v3 targetProcessId];
          LOBYTE(v199) = v197;
          uint64_t v193 = "%s [%d]: %s: _hidEventSem non-NULL when not requiring HID event";
        }
        int v195 = 963;
LABEL_356:
        sub_10002E41C("-[SPSampledProcess requireHIDEvent:]_block_invoke", "SPProcessEvent.m", v195, v193, v109, v110, v111, v112, (char)v199);
        abort();
      }
    }
    CFStringRef v85 = v44;
    uintptr_t v86 = CFStringGetCStringPtr(v44, 0x8000100u);
    if (v86)
    {
      CFStringRef v87 = (char *)v86;
      CFStringRef v88 = 0;
    }
    else
    {
      CFStringRef v87 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x8DBCFFB8uLL);
      CFStringGetCString(v85, v87, 1024, 0x8000100u);
      CFStringRef v88 = v87;
    }
    if (qword_1000EBD00) {
      __int16 v104 = (FILE *)qword_1000EBD00;
    }
    else {
      __int16 v104 = __stderrp;
    }
    fprintf(v104, "%s\n", v87);
    if (v88) {
      free(v88);
    }
    CFRelease(v85);
    goto LABEL_250;
  }
  if (!result)
  {
    if (v5[18] < 0)
    {
      if (byte_1000EBCF8)
      {
        int v60 = *__error();
        CFStringRef v61 = sub_10002E548();
        if (os_log_type_enabled(v61, OS_LOG_TYPE_DEBUG)) {
          sub_10009528C();
        }
        *__error() = v60;
      }
      if (byte_1000EBCF9) {
        BOOL v62 = dword_1000EB4A8 <= 0;
      }
      else {
        BOOL v62 = 0;
      }
      if (!v62) {
        goto LABEL_194;
      }
      int v25 = *__error();
      CFStringRef v27 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"Requires HID event");
      if (!v27)
      {
        __int16 v102 = sub_10002E548();
        if (os_log_type_enabled(v102, OS_LOG_TYPE_FAULT)) {
          sub_100095258();
        }
        goto LABEL_189;
      }
    }
    else
    {
      if (byte_1000EBCF8)
      {
        int v22 = *__error();
        CFStringRef v23 = sub_10002E548();
        if (os_log_type_enabled(v23, OS_LOG_TYPE_DEBUG)) {
          sub_1000951E0();
        }
        *__error() = v22;
      }
      if (byte_1000EBCF9) {
        BOOL v24 = dword_1000EB4A8 <= 0;
      }
      else {
        BOOL v24 = 0;
      }
      if (!v24) {
        goto LABEL_194;
      }
      int v25 = *__error();
      int v26 = sub_10002E4E8((*v3)[18]);
      CFStringRef v27 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%s [%d]: Requires HID event", v26, (*v3)[18]);
      if (!v27)
      {
        CFStringRef v28 = sub_10002E548();
        if (os_log_type_enabled(v28, OS_LOG_TYPE_FAULT)) {
          sub_100095168();
        }
LABEL_189:
        if (qword_1000EBD00) {
          int v103 = (FILE *)qword_1000EBD00;
        }
        else {
          int v103 = __stderrp;
        }
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v103);
LABEL_193:
        *__error() = v25;
LABEL_194:
        *((void *)*v3 + 53) = dispatch_semaphore_create(0);
        [a2 setObject:*v3 forKeyedSubscript:[NSNumber numberWithInt:objc_msgSend(*v3, "targetProcessId")]];
        return (int *)[*v3 createHIDExitSource];
      }
    }
    CFStringRef v63 = v27;
    uint32_t v64 = CFStringGetCStringPtr(v27, 0x8000100u);
    if (v64)
    {
      int v65 = (char *)v64;
      uint64_t v66 = 0;
    }
    else
    {
      int v65 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x75711560uLL);
      CFStringGetCString(v63, v65, 1024, 0x8000100u);
      uint64_t v66 = v65;
    }
    if (qword_1000EBD00) {
      CFStringRef v97 = (FILE *)qword_1000EBD00;
    }
    else {
      CFStringRef v97 = __stderrp;
    }
    fprintf(v97, "%s\n", v65);
    if (v66) {
      free(v66);
    }
    CFRelease(v63);
    goto LABEL_193;
  }
  if (result != v5)
  {
    if (v5[18] < 0)
    {
      if (byte_1000EBCF8)
      {
        int v46 = *__error();
        int v47 = sub_10002E548();
        if (os_log_type_enabled(v47, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v47, OS_LOG_TYPE_DEFAULT, "Already waiting for HID event from previous spin, canceling this spin", buf, 2u);
        }
        *__error() = v46;
      }
      if (byte_1000EBCF9) {
        BOOL v48 = dword_1000EB4A8 <= 2;
      }
      else {
        BOOL v48 = 0;
      }
      if (!v48) {
        return (int *)[*v3 stopSamplingWithReason:7];
      }
      int v11 = *__error();
      CFStringRef v13 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"Already waiting for HID event from previous spin, canceling this spin");
      if (!v13)
      {
        id v99 = sub_10002E548();
        if (os_log_type_enabled(v99, OS_LOG_TYPE_FAULT)) {
          sub_100095490();
        }
        goto LABEL_174;
      }
    }
    else
    {
      if (byte_1000EBCF8)
      {
        int v6 = *__error();
        int v7 = sub_10002E548();
        if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
        {
          double v8 = sub_10002E4E8((*v3)[18]);
          int v9 = (*v3)[18];
          *(_DWORD *)buf = 136446466;
          int v201 = v8;
          __int16 v202 = 1024;
          int v203 = v9;
          _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "%{public}s [%d]: Already waiting for HID event from previous spin, canceling this spin", buf, 0x12u);
        }
        *__error() = v6;
      }
      if (byte_1000EBCF9) {
        BOOL v10 = dword_1000EB4A8 <= 2;
      }
      else {
        BOOL v10 = 0;
      }
      if (!v10) {
        return (int *)[*v3 stopSamplingWithReason:7];
      }
      int v11 = *__error();
      CFStringRef v12 = sub_10002E4E8((*v3)[18]);
      CFStringRef v13 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%s [%d]: Already waiting for HID event from previous spin, canceling this spin", v12, (*v3)[18]);
      if (!v13)
      {
        CFStringRef v14 = sub_10002E548();
        if (os_log_type_enabled(v14, OS_LOG_TYPE_FAULT)) {
          sub_100095418();
        }
LABEL_174:
        if (qword_1000EBD00) {
          id v100 = (FILE *)qword_1000EBD00;
        }
        else {
          id v100 = __stderrp;
        }
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v100);
LABEL_178:
        *__error() = v11;
        return (int *)[*v3 stopSamplingWithReason:7];
      }
    }
    CFStringRef v49 = v13;
    CFStringRef v50 = CFStringGetCStringPtr(v13, 0x8000100u);
    if (v50)
    {
      CFStringRef v51 = (char *)v50;
      uint64_t v52 = 0;
    }
    else
    {
      CFStringRef v51 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x53D45D73uLL);
      CFStringGetCString(v49, v51, 1024, 0x8000100u);
      uint64_t v52 = v51;
    }
    if (qword_1000EBD00) {
      id v96 = (FILE *)qword_1000EBD00;
    }
    else {
      id v96 = __stderrp;
    }
    fprintf(v96, "%s\n", v51);
    if (v52) {
      free(v52);
    }
    CFRelease(v49);
    goto LABEL_178;
  }
  if ((result[18] & 0x80000000) == 0)
  {
    if (byte_1000EBCF8)
    {
      int v29 = *__error();
      uint64_t v30 = sub_10002E548();
      if (os_log_type_enabled(v30, OS_LOG_TYPE_DEBUG)) {
        sub_100095338();
      }
      id result = __error();
      int *result = v29;
    }
    if (byte_1000EBCF9) {
      BOOL v31 = dword_1000EB4A8 <= 0;
    }
    else {
      BOOL v31 = 0;
    }
    if (!v31) {
      return result;
    }
    int v32 = *__error();
    int v33 = sub_10002E4E8((*v3)[18]);
    CFStringRef v34 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%s [%d]: Already waiting for HID event", v33, (*v3)[18]);
    if (v34)
    {
      CFStringRef v35 = v34;
      CFStringRef v36 = CFStringGetCStringPtr(v34, 0x8000100u);
      if (v36)
      {
        id v37 = (char *)v36;
        uid_t v38 = 0;
      }
      else
      {
        id v37 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xBD0A292AuLL);
        CFStringGetCString(v35, v37, 1024, 0x8000100u);
        uid_t v38 = v37;
      }
      if (qword_1000EBD00) {
        id v105 = (FILE *)qword_1000EBD00;
      }
      else {
        id v105 = __stderrp;
      }
      fprintf(v105, "%s\n", v37);
      if (v38) {
        free(v38);
      }
      CFStringRef v106 = v35;
LABEL_273:
      CFRelease(v106);
LABEL_274:
      id result = __error();
      int *result = v32;
      return result;
    }
    id v98 = sub_10002E548();
    if (os_log_type_enabled(v98, OS_LOG_TYPE_FAULT)) {
      sub_1000952C0();
    }
    goto LABEL_233;
  }
  if (byte_1000EBCF8)
  {
    int v74 = *__error();
    id v75 = sub_10002E548();
    if (os_log_type_enabled(v75, OS_LOG_TYPE_DEBUG)) {
      sub_1000953E4();
    }
    id result = __error();
    int *result = v74;
  }
  if (byte_1000EBCF9) {
    BOOL v76 = dword_1000EB4A8 <= 0;
  }
  else {
    BOOL v76 = 0;
  }
  if (v76)
  {
    int v32 = *__error();
    CFStringRef v77 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"Already waiting for HID event");
    if (v77)
    {
      CFStringRef v78 = v77;
      int v79 = CFStringGetCStringPtr(v77, 0x8000100u);
      if (v79)
      {
        char v80 = (char *)v79;
        CFStringRef v81 = 0;
      }
      else
      {
        char v80 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xBD0A292AuLL);
        CFStringGetCString(v78, v80, 1024, 0x8000100u);
        CFStringRef v81 = v80;
      }
      if (qword_1000EBD00) {
        id v132 = (FILE *)qword_1000EBD00;
      }
      else {
        id v132 = __stderrp;
      }
      fprintf(v132, "%s\n", v80);
      if (v81) {
        free(v81);
      }
      CFStringRef v106 = v78;
      goto LABEL_273;
    }
    id v120 = sub_10002E548();
    if (os_log_type_enabled(v120, OS_LOG_TYPE_FAULT)) {
      sub_1000953B0();
    }
LABEL_233:
    if (qword_1000EBD00) {
      id v121 = (FILE *)qword_1000EBD00;
    }
    else {
      id v121 = __stderrp;
    }
    fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v121);
    goto LABEL_274;
  }
  return result;
}

int *sub_100064C30(uint64_t a1, void *a2)
{
  uint64_t v4 = (unsigned int *)(a1 + 64);
  id result = [(int *)[a2 objectForKeyedSubscript:+[NSNumber numberWithInt:](NSNumber, "numberWithInt:", *(unsigned int *)(a1 + 64))];
  if (result)
  {
    uint64_t v6 = (uint64_t)result;
    int v7 = (id *)(a1 + 32);
    id result = (int *)[*((id *)result + 52) gt:*(void *)(a1 + 32)];
    if (result)
    {
      if ((*v4 & 0x80000000) == 0)
      {
        if (byte_1000EBCF8)
        {
          int v8 = *__error();
          int v9 = sub_10002E548();
          if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
          {
            id v90 = sub_10002E4E8(*v4);
            int v91 = *v4;
            [*(id *)(v6 + 416) machAbsTimeSeconds];
            double v93 = v92;
            [*v7 machAbsTimeSeconds];
            *(_DWORD *)buf = 136446722;
            id v101 = v90;
            __int16 v102 = 1024;
            int v103 = v91;
            __int16 v104 = 2048;
            double v105 = v93 - v94;
            _os_log_debug_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEBUG, "%{public}s [%d]: Got hid event from %.1fs earlier than the spin we monitored, continuing to wait", buf, 0x1Cu);
          }
          id result = __error();
          int *result = v8;
        }
        if (byte_1000EBCF9) {
          BOOL v10 = dword_1000EB4A8 <= 0;
        }
        else {
          BOOL v10 = 0;
        }
        if (v10)
        {
          int v11 = *__error();
          CFStringRef v12 = sub_10002E4E8(*v4);
          uint64_t v13 = *v4;
          [*(id *)(v6 + 416) machAbsTimeSeconds];
          double v15 = v14;
          [*v7 machAbsTimeSeconds];
          CFStringRef v17 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%s [%d]: Got hid event from %.1fs earlier than the spin we monitored, continuing to wait", v12, v13, v15 - v16);
          if (v17)
          {
            CFStringRef v18 = v17;
            CStringPtr = CFStringGetCStringPtr(v17, 0x8000100u);
            if (CStringPtr)
            {
              CFStringRef v20 = (char *)CStringPtr;
              int v21 = 0;
            }
            else
            {
              CFStringRef v20 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xDF1739DAuLL);
              CFStringGetCString(v18, v20, 1024, 0x8000100u);
              int v21 = v20;
            }
            if (qword_1000EBD00) {
              int v79 = (FILE *)qword_1000EBD00;
            }
            else {
              int v79 = __stderrp;
            }
            fprintf(v79, "%s\n", v20);
            if (v21) {
              free(v21);
            }
            CFRelease(v18);
          }
          else
          {
            int v74 = sub_10002E548();
            if (os_log_type_enabled(v74, OS_LOG_TYPE_FAULT))
            {
              id v95 = sub_10002E4E8(*v4);
              int v96 = *v4;
              [*(id *)(v6 + 416) machAbsTimeSeconds];
              double v98 = v97;
              [*v7 machAbsTimeSeconds];
              *(_DWORD *)buf = 136315650;
              id v101 = v95;
              __int16 v102 = 1024;
              int v103 = v96;
              __int16 v104 = 2048;
              double v105 = v98 - v99;
              _os_log_fault_impl((void *)&_mh_execute_header, v74, OS_LOG_TYPE_FAULT, "Unable to format: %s [%d]: Got hid event from %.1fs earlier than the spin we monitored, continuing to wait", buf, 0x1Cu);
            }
            if (qword_1000EBD00) {
              id v75 = (FILE *)qword_1000EBD00;
            }
            else {
              id v75 = __stderrp;
            }
            fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v75);
          }
          id result = __error();
          int *result = v11;
        }
        return result;
      }
      if (byte_1000EBCF8)
      {
        int v53 = *__error();
        uint64_t v54 = sub_10002E548();
        if (os_log_type_enabled(v54, OS_LOG_TYPE_DEBUG)) {
          sub_1000956C8(v6, v7, v54);
        }
        id result = __error();
        int *result = v53;
      }
      if (byte_1000EBCF9) {
        BOOL v55 = dword_1000EB4A8 <= 0;
      }
      else {
        BOOL v55 = 0;
      }
      if (!v55) {
        return result;
      }
      int v47 = *__error();
      [*(id *)(v6 + 416) machAbsTimeSeconds];
      double v57 = v56;
      [*v7 machAbsTimeSeconds];
      CFStringRef v59 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"Got hid event from %.1fs earlier than the spin we monitored, continuing to wait", v57 - v58);
      if (v59)
      {
        CFStringRef v60 = v59;
        CFStringRef v61 = CFStringGetCStringPtr(v59, 0x8000100u);
        if (v61)
        {
          BOOL v62 = (char *)v61;
          CFStringRef v63 = 0;
        }
        else
        {
          BOOL v62 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xDF1739DAuLL);
          CFStringGetCString(v60, v62, 1024, 0x8000100u);
          CFStringRef v63 = v62;
        }
        if (qword_1000EBD00) {
          CFStringRef v88 = (FILE *)qword_1000EBD00;
        }
        else {
          CFStringRef v88 = __stderrp;
        }
        fprintf(v88, "%s\n", v62);
        if (v63) {
          free(v63);
        }
        CFStringRef v87 = v60;
LABEL_143:
        CFRelease(v87);
LABEL_144:
        id result = __error();
        int *result = v47;
        return result;
      }
      int v82 = sub_10002E548();
      if (os_log_type_enabled(v82, OS_LOG_TYPE_FAULT)) {
        sub_10009561C(v6, v7);
      }
      goto LABEL_119;
    }
    *(unsigned char *)(*(void *)(*(void *)(a1 + 48) + 8) + 24) = 1;
    if ((*(_DWORD *)(a1 + 64) & 0x80000000) != 0)
    {
      if (byte_1000EBCF8)
      {
        int v64 = *__error();
        int v65 = sub_10002E548();
        if (os_log_type_enabled(v65, OS_LOG_TYPE_INFO))
        {
          *(_WORD *)buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v65, OS_LOG_TYPE_INFO, "Got hid event", buf, 2u);
        }
        *__error() = v64;
      }
      if (byte_1000EBCF9) {
        BOOL v66 = dword_1000EB4A8 <= 1;
      }
      else {
        BOOL v66 = 0;
      }
      if (!v66) {
        goto LABEL_154;
      }
      int v37 = *__error();
      CFStringRef v67 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"Got hid event");
      if (v67)
      {
        CFStringRef v68 = v67;
        BOOL v69 = CFStringGetCStringPtr(v67, 0x8000100u);
        if (v69)
        {
          CFStringRef v70 = (char *)v69;
          uint64_t v71 = 0;
        }
        else
        {
          CFStringRef v70 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x3E502C52uLL);
          CFStringGetCString(v68, v70, 1024, 0x8000100u);
          uint64_t v71 = v70;
        }
        if (qword_1000EBD00) {
          int v89 = (FILE *)qword_1000EBD00;
        }
        else {
          int v89 = __stderrp;
        }
        fprintf(v89, "%s\n", v70);
        if (v71) {
          free(v71);
        }
        CFStringRef v81 = v68;
        goto LABEL_152;
      }
      BOOL v84 = sub_10002E548();
      if (os_log_type_enabled(v84, OS_LOG_TYPE_FAULT)) {
        sub_1000957F4();
      }
    }
    else
    {
      if (byte_1000EBCF8)
      {
        int v32 = *__error();
        int v33 = sub_10002E548();
        if (os_log_type_enabled(v33, OS_LOG_TYPE_INFO))
        {
          CFStringRef v34 = sub_10002E4E8(*v4);
          int v35 = *v4;
          *(_DWORD *)buf = 136446466;
          id v101 = v34;
          __int16 v102 = 1024;
          int v103 = v35;
          _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_INFO, "%{public}s [%d]: Got hid event", buf, 0x12u);
        }
        *__error() = v32;
      }
      if (byte_1000EBCF9) {
        BOOL v36 = dword_1000EB4A8 <= 1;
      }
      else {
        BOOL v36 = 0;
      }
      if (!v36) {
        goto LABEL_154;
      }
      int v37 = *__error();
      uid_t v38 = sub_10002E4E8(*v4);
      CFStringRef v39 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%s [%d]: Got hid event", v38, *v4);
      if (v39)
      {
        CFStringRef v40 = v39;
        BOOL v41 = CFStringGetCStringPtr(v39, 0x8000100u);
        if (v41)
        {
          int v42 = (char *)v41;
          CFStringRef v43 = 0;
        }
        else
        {
          int v42 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x3E502C52uLL);
          CFStringGetCString(v40, v42, 1024, 0x8000100u);
          CFStringRef v43 = v42;
        }
        if (qword_1000EBD00) {
          char v80 = (FILE *)qword_1000EBD00;
        }
        else {
          char v80 = __stderrp;
        }
        fprintf(v80, "%s\n", v42);
        if (v43) {
          free(v43);
        }
        CFStringRef v81 = v40;
LABEL_152:
        CFRelease(v81);
LABEL_153:
        *__error() = v37;
LABEL_154:
        [v6 setEventTimeRange:[SATimeRange timeRangeStart:end:](SATimeRange, "timeRangeStart:end:", *(void *)(a1 + 40), *(void *)(a1 + 32))];
        [(id)v6 setReportTimeStart:*(void *)(a1 + 40)];
        [(id)v6 setReportTimeEnd:*(void *)(a1 + 32)];
        [(id)v6 setTargetHIDEventMachAbs:*(void *)(a1 + 56)];
        [v6 setTargetHIDEventEndMachAbs:[*(id *)(a1 + 32) machAbsTime]];
        dispatch_semaphore_signal(*(dispatch_semaphore_t *)(v6 + 424));
        [a2 setObject:0 forKeyedSubscript:[NSNumber numberWithInt:*(unsigned int *)(a1 + 64)]];
        return (int *)[(id)v6 deleteHIDExitSource];
      }
      BOOL v76 = sub_10002E548();
      if (os_log_type_enabled(v76, OS_LOG_TYPE_FAULT)) {
        sub_10009577C();
      }
    }
    if (qword_1000EBD00) {
      CFStringRef v85 = (FILE *)qword_1000EBD00;
    }
    else {
      CFStringRef v85 = __stderrp;
    }
    fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v85);
    goto LABEL_153;
  }
  if ((*v4 & 0x80000000) == 0)
  {
    if (byte_1000EBCF8)
    {
      int v22 = *__error();
      CFStringRef v23 = sub_10002E548();
      if (os_log_type_enabled(v23, OS_LOG_TYPE_DEBUG)) {
        sub_10009553C();
      }
      id result = __error();
      int *result = v22;
    }
    if (byte_1000EBCF9) {
      BOOL v24 = dword_1000EB4A8 <= 0;
    }
    else {
      BOOL v24 = 0;
    }
    if (v24)
    {
      int v25 = *__error();
      int v26 = sub_10002E4E8(*v4);
      CFStringRef v27 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%s [%d]: No sampled process for hid event", v26, *v4);
      if (v27)
      {
        CFStringRef v28 = v27;
        int v29 = CFStringGetCStringPtr(v27, 0x8000100u);
        if (v29)
        {
          uint64_t v30 = (char *)v29;
          BOOL v31 = 0;
        }
        else
        {
          uint64_t v30 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x54607810uLL);
          CFStringGetCString(v28, v30, 1024, 0x8000100u);
          BOOL v31 = v30;
        }
        if (qword_1000EBD00) {
          CFStringRef v77 = (FILE *)qword_1000EBD00;
        }
        else {
          CFStringRef v77 = __stderrp;
        }
        fprintf(v77, "%s\n", v30);
        if (v31) {
          free(v31);
        }
        CFRelease(v28);
      }
      else
      {
        id v72 = sub_10002E548();
        if (os_log_type_enabled(v72, OS_LOG_TYPE_FAULT)) {
          sub_1000954C4();
        }
        if (qword_1000EBD00) {
          int v73 = (FILE *)qword_1000EBD00;
        }
        else {
          int v73 = __stderrp;
        }
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v73);
      }
      id result = __error();
      int *result = v25;
    }
    return result;
  }
  if (byte_1000EBCF8)
  {
    int v44 = *__error();
    malloc_type_id_t v45 = sub_10002E548();
    if (os_log_type_enabled(v45, OS_LOG_TYPE_DEBUG)) {
      sub_1000955E8();
    }
    id result = __error();
    int *result = v44;
  }
  if (byte_1000EBCF9) {
    BOOL v46 = dword_1000EB4A8 <= 0;
  }
  else {
    BOOL v46 = 0;
  }
  if (v46)
  {
    int v47 = *__error();
    CFStringRef v48 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"No sampled process for hid event");
    if (v48)
    {
      CFStringRef v49 = v48;
      CFStringRef v50 = CFStringGetCStringPtr(v48, 0x8000100u);
      if (v50)
      {
        CFStringRef v51 = (char *)v50;
        uint64_t v52 = 0;
      }
      else
      {
        CFStringRef v51 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x54607810uLL);
        CFStringGetCString(v49, v51, 1024, 0x8000100u);
        uint64_t v52 = v51;
      }
      if (qword_1000EBD00) {
        uintptr_t v86 = (FILE *)qword_1000EBD00;
      }
      else {
        uintptr_t v86 = __stderrp;
      }
      fprintf(v86, "%s\n", v51);
      if (v52) {
        free(v52);
      }
      CFStringRef v87 = v49;
      goto LABEL_143;
    }
    CFStringRef v78 = sub_10002E548();
    if (os_log_type_enabled(v78, OS_LOG_TYPE_FAULT)) {
      sub_1000955B4();
    }
LABEL_119:
    if (qword_1000EBD00) {
      unsigned int v83 = (FILE *)qword_1000EBD00;
    }
    else {
      unsigned int v83 = __stderrp;
    }
    fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v83);
    goto LABEL_144;
  }
  return result;
}

void sub_100066ECC(uint64_t a1)
{
  id v3 = (uint64_t *)(a1 + 32);
  uint64_t v2 = *(void *)(a1 + 32);
  if (!*(unsigned char *)(v2 + 298) || *(unsigned char *)(v2 + 297))
  {
    uint64_t v4 = *(NSObject **)(v2 + 32);
    if (!v4)
    {
      dispatch_queue_global_t global_queue = dispatch_get_global_queue(25, 2uLL);
      *(void *)(*v3 + 32) = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_timer, 0, 0, global_queue);
      uint64_t v6 = *v3;
      int v7 = *(NSObject **)(*v3 + 32);
      handler[0] = _NSConcreteStackBlock;
      handler[1] = 3221225472;
      handler[2] = sub_1000672F8;
      handler[3] = &unk_1000DD618;
      void handler[4] = v6;
      dispatch_source_set_event_handler(v7, handler);
      dispatch_resume(*(dispatch_object_t *)(*v3 + 32));
      uint64_t v2 = *v3;
      uint64_t v4 = *(NSObject **)(*v3 + 32);
    }
    unsigned int v8 = *(_DWORD *)(v2 + 400);
    if (v8 >= 0x3E8) {
      uint64_t v9 = 1000000;
    }
    else {
      uint64_t v9 = 1000 * v8;
    }
    dispatch_time_t v10 = dispatch_time(0, (unint64_t)((*(double *)(a1 + 40) - *(double *)(a1 + 48)) * 1000000000.0));
    dispatch_source_set_timer(v4, v10, 0xFFFFFFFFFFFFFFFFLL, v9);
    return;
  }
  if ((*(_DWORD *)(v2 + 72) & 0x80000000) == 0)
  {
    if (byte_1000EBCF8)
    {
      int v11 = *__error();
      CFStringRef v12 = sub_10002E548();
      if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG)) {
        sub_100095F74();
      }
      *__error() = v11;
    }
    if (byte_1000EBCF9) {
      BOOL v13 = dword_1000EB4A8 <= 0;
    }
    else {
      BOOL v13 = 0;
    }
    if (!v13) {
      return;
    }
    int v14 = *__error();
    double v15 = sub_10002E4E8(*(_DWORD *)(*v3 + 72));
    CFStringRef v16 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%s [%d]: Lost race: already done sampling", v15, *(unsigned int *)(*v3 + 72));
    if (v16)
    {
      CFStringRef v17 = v16;
      CStringPtr = CFStringGetCStringPtr(v16, 0x8000100u);
      if (CStringPtr)
      {
        CFStringRef v19 = (char *)CStringPtr;
        CFStringRef v20 = 0;
      }
      else
      {
        CFStringRef v19 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x665C327uLL);
        CFStringGetCString(v17, v19, 1024, 0x8000100u);
        CFStringRef v20 = v19;
      }
      if (qword_1000EBD00) {
        uint64_t v30 = (FILE *)qword_1000EBD00;
      }
      else {
        uint64_t v30 = __stderrp;
      }
      fprintf(v30, "%s\n", v19);
      if (v20) {
        free(v20);
      }
      CFStringRef v31 = v17;
LABEL_56:
      CFRelease(v31);
LABEL_57:
      *__error() = v14;
      return;
    }
    int v29 = sub_10002E548();
    if (os_log_type_enabled(v29, OS_LOG_TYPE_FAULT)) {
      sub_100095EFC();
    }
    goto LABEL_45;
  }
  if (byte_1000EBCF8)
  {
    int v21 = *__error();
    int v22 = sub_10002E548();
    if (os_log_type_enabled(v22, OS_LOG_TYPE_DEBUG)) {
      sub_100096020();
    }
    *__error() = v21;
  }
  if (byte_1000EBCF9) {
    BOOL v23 = dword_1000EB4A8 <= 0;
  }
  else {
    BOOL v23 = 0;
  }
  if (v23)
  {
    int v14 = *__error();
    CFStringRef v24 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"Lost race: already done sampling");
    if (v24)
    {
      CFStringRef v25 = v24;
      int v26 = CFStringGetCStringPtr(v24, 0x8000100u);
      if (v26)
      {
        CFStringRef v27 = (char *)v26;
        CFStringRef v28 = 0;
      }
      else
      {
        CFStringRef v27 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x665C327uLL);
        CFStringGetCString(v25, v27, 1024, 0x8000100u);
        CFStringRef v28 = v27;
      }
      if (qword_1000EBD00) {
        CFStringRef v34 = (FILE *)qword_1000EBD00;
      }
      else {
        CFStringRef v34 = __stderrp;
      }
      fprintf(v34, "%s\n", v27);
      if (v28) {
        free(v28);
      }
      CFStringRef v31 = v25;
      goto LABEL_56;
    }
    int v32 = sub_10002E548();
    if (os_log_type_enabled(v32, OS_LOG_TYPE_FAULT)) {
      sub_100095FEC();
    }
LABEL_45:
    if (qword_1000EBD00) {
      int v33 = (FILE *)qword_1000EBD00;
    }
    else {
      int v33 = __stderrp;
    }
    fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v33);
    goto LABEL_57;
  }
}

_DWORD *sub_1000672F8(uint64_t a1)
{
  uint64_t v1 = (id *)(a1 + 32);
  double v2 = *(double *)(*(void *)(a1 + 32) + 48);
  id result = (_DWORD *)SAMachAbsTimeSecondsGetCurrent();
  int v4 = *((_DWORD *)*v1 + 18);
  if (v2 <= v5)
  {
    if (v4 < 0)
    {
      if (byte_1000EBCF8)
      {
        int v31 = *__error();
        int v32 = sub_10002E548();
        if (os_log_type_enabled(v32, OS_LOG_TYPE_DEBUG)) {
          sub_1000962D0();
        }
        *__error() = v31;
      }
      if (byte_1000EBCF9) {
        BOOL v33 = dword_1000EB4A8 <= 0;
      }
      else {
        BOOL v33 = 0;
      }
      if (!v33) {
        return [*v1 stopSamplingWithReason:3];
      }
      int v19 = *__error();
      CFStringRef v21 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"Monitoring timed out");
      if (!v21)
      {
        int v44 = sub_10002E548();
        if (os_log_type_enabled(v44, OS_LOG_TYPE_FAULT)) {
          sub_10009629C();
        }
        goto LABEL_76;
      }
    }
    else
    {
      if (byte_1000EBCF8)
      {
        int v16 = *__error();
        CFStringRef v17 = sub_10002E548();
        if (os_log_type_enabled(v17, OS_LOG_TYPE_DEBUG)) {
          sub_100096224();
        }
        *__error() = v16;
      }
      if (byte_1000EBCF9) {
        BOOL v18 = dword_1000EB4A8 <= 0;
      }
      else {
        BOOL v18 = 0;
      }
      if (!v18) {
        return [*v1 stopSamplingWithReason:3];
      }
      int v19 = *__error();
      CFStringRef v20 = sub_10002E4E8(*((_DWORD *)*v1 + 18));
      CFStringRef v21 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%s [%d]: Monitoring timed out", v20, *((unsigned int *)*v1 + 18));
      if (!v21)
      {
        int v22 = sub_10002E548();
        if (os_log_type_enabled(v22, OS_LOG_TYPE_FAULT)) {
          sub_1000961AC();
        }
LABEL_76:
        if (qword_1000EBD00) {
          malloc_type_id_t v45 = (FILE *)qword_1000EBD00;
        }
        else {
          malloc_type_id_t v45 = __stderrp;
        }
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v45);
LABEL_80:
        *__error() = v19;
        return [*v1 stopSamplingWithReason:3];
      }
    }
    CFStringRef v34 = v21;
    CStringPtr = CFStringGetCStringPtr(v21, 0x8000100u);
    if (CStringPtr)
    {
      BOOL v36 = (char *)CStringPtr;
      int v37 = 0;
    }
    else
    {
      BOOL v36 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xD1519969uLL);
      CFStringGetCString(v34, v36, 1024, 0x8000100u);
      int v37 = v36;
    }
    if (qword_1000EBD00) {
      CFStringRef v39 = (FILE *)qword_1000EBD00;
    }
    else {
      CFStringRef v39 = __stderrp;
    }
    fprintf(v39, "%s\n", v36);
    if (v37) {
      free(v37);
    }
    CFRelease(v34);
    goto LABEL_80;
  }
  if ((v4 & 0x80000000) == 0)
  {
    if (byte_1000EBCF8)
    {
      int v6 = *__error();
      int v7 = sub_10002E548();
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG)) {
        sub_1000960CC();
      }
      id result = __error();
      _DWORD *result = v6;
    }
    if (byte_1000EBCF9) {
      BOOL v8 = dword_1000EB4A8 <= 0;
    }
    else {
      BOOL v8 = 0;
    }
    if (!v8) {
      return result;
    }
    int v9 = *__error();
    dispatch_time_t v10 = sub_10002E4E8(*((_DWORD *)*v1 + 18));
    CFStringRef v11 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%s [%d]: Monitoring timeout was extended, doing nothing", v10, *((unsigned int *)*v1 + 18));
    if (v11)
    {
      CFStringRef v12 = v11;
      BOOL v13 = CFStringGetCStringPtr(v11, 0x8000100u);
      if (v13)
      {
        int v14 = (char *)v13;
        double v15 = 0;
      }
      else
      {
        int v14 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xD262D5CCuLL);
        CFStringGetCString(v12, v14, 1024, 0x8000100u);
        double v15 = v14;
      }
      if (qword_1000EBD00) {
        CFStringRef v40 = (FILE *)qword_1000EBD00;
      }
      else {
        CFStringRef v40 = __stderrp;
      }
      fprintf(v40, "%s\n", v14);
      if (v15) {
        free(v15);
      }
      CFStringRef v41 = v12;
LABEL_89:
      CFRelease(v41);
LABEL_90:
      id result = __error();
      _DWORD *result = v9;
      return result;
    }
    uid_t v38 = sub_10002E548();
    if (os_log_type_enabled(v38, OS_LOG_TYPE_FAULT)) {
      sub_100096054();
    }
    goto LABEL_70;
  }
  if (byte_1000EBCF8)
  {
    int v23 = *__error();
    CFStringRef v24 = sub_10002E548();
    if (os_log_type_enabled(v24, OS_LOG_TYPE_DEBUG)) {
      sub_100096178();
    }
    id result = __error();
    _DWORD *result = v23;
  }
  if (byte_1000EBCF9) {
    BOOL v25 = dword_1000EB4A8 <= 0;
  }
  else {
    BOOL v25 = 0;
  }
  if (v25)
  {
    int v9 = *__error();
    CFStringRef v26 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"Monitoring timeout was extended, doing nothing");
    if (v26)
    {
      CFStringRef v27 = v26;
      CFStringRef v28 = CFStringGetCStringPtr(v26, 0x8000100u);
      if (v28)
      {
        int v29 = (char *)v28;
        uint64_t v30 = 0;
      }
      else
      {
        int v29 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xD262D5CCuLL);
        CFStringGetCString(v27, v29, 1024, 0x8000100u);
        uint64_t v30 = v29;
      }
      if (qword_1000EBD00) {
        BOOL v46 = (FILE *)qword_1000EBD00;
      }
      else {
        BOOL v46 = __stderrp;
      }
      fprintf(v46, "%s\n", v29);
      if (v30) {
        free(v30);
      }
      CFStringRef v41 = v27;
      goto LABEL_89;
    }
    int v42 = sub_10002E548();
    if (os_log_type_enabled(v42, OS_LOG_TYPE_FAULT)) {
      sub_100096144();
    }
LABEL_70:
    if (qword_1000EBD00) {
      CFStringRef v43 = (FILE *)qword_1000EBD00;
    }
    else {
      CFStringRef v43 = __stderrp;
    }
    fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v43);
    goto LABEL_90;
  }
  return result;
}

void sub_100067CC4(void *a1)
{
  uint64_t v2 = a1[4];
  id v3 = *(NSObject **)(v2 + 56);
  if (v3)
  {
    dispatch_release(v3);
    uint64_t v2 = a1[4];
  }
  int v4 = *(const void **)(v2 + 64);
  if (v4)
  {
    _Block_release(v4);
    uint64_t v2 = a1[4];
  }
  *(void *)(v2 + 56) = a1[5];
  *(void *)(a1[4] + 64) = a1[6];
}

void sub_100067D94(uint64_t a1)
{
  uint64_t v2 = (uint64_t *)(a1 + 32);
  uint64_t v1 = *(void *)(a1 + 32);
  int v3 = *(unsigned __int8 *)(a1 + 40);
  int v4 = *(NSObject **)(v1 + 40);
  if (!v3)
  {
    if (v4)
    {
      dispatch_release(v4);
      *(void *)(*v2 + 40) = 0;
    }
    return;
  }
  if (v4) {
    return;
  }
  if (!*(unsigned char *)(v1 + 298) || *(unsigned char *)(v1 + 297))
  {
    uintptr_t v5 = *(unsigned int *)(v1 + 72);
    if ((int)v5 >= 1)
    {
      dispatch_queue_global_t global_queue = dispatch_get_global_queue(25, 2uLL);
      *(void *)(*v2 + 40) = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_proc, v5, 0xA0000000uLL, global_queue);
      uint64_t v7 = *v2;
      BOOL v8 = *(NSObject **)(*v2 + 40);
      if (v8)
      {
        handler[0] = _NSConcreteStackBlock;
        handler[1] = 3221225472;
        handler[2] = sub_100068528;
        handler[3] = &unk_1000DD618;
        void handler[4] = v7;
        dispatch_source_set_event_handler(v8, handler);
        dispatch_resume(*(dispatch_object_t *)(*v2 + 40));
        return;
      }
      if ((*(_DWORD *)(v7 + 72) & 0x80000000) == 0)
      {
        if (byte_1000EBCF8)
        {
          int v25 = *__error();
          CFStringRef v26 = sub_10002E548();
          if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR)) {
            sub_100096574();
          }
          *__error() = v25;
        }
        if (byte_1000EBCF9 && dword_1000EB4A8 <= 3)
        {
          int v12 = *__error();
          CFStringRef v27 = sub_10002E4E8(*(_DWORD *)(*v2 + 72));
          CFStringRef v28 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%s [%d]: Unable to allocate proc exit dispatch source", v27, *(unsigned int *)(*v2 + 72));
          if (v28)
          {
            CFStringRef v22 = v28;
            CStringPtr = CFStringGetCStringPtr(v28, 0x8000100u);
            if (CStringPtr) {
              goto LABEL_45;
            }
            malloc_type_id_t v24 = 3829306288;
            goto LABEL_90;
          }
          BOOL v46 = sub_10002E548();
          if (os_log_type_enabled(v46, OS_LOG_TYPE_FAULT)) {
            sub_1000964FC();
          }
          goto LABEL_99;
        }
        return;
      }
      if (byte_1000EBCF8)
      {
        int v39 = *__error();
        CFStringRef v40 = sub_10002E548();
        if (os_log_type_enabled(v40, OS_LOG_TYPE_ERROR)) {
          sub_100096620();
        }
        *__error() = v39;
      }
      if (!byte_1000EBCF9 || dword_1000EB4A8 > 3) {
        return;
      }
      int v12 = *__error();
      CFStringRef v41 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"Unable to allocate proc exit dispatch source");
      if (!v41)
      {
        CFStringRef v51 = sub_10002E548();
        if (os_log_type_enabled(v51, OS_LOG_TYPE_FAULT)) {
          sub_1000965EC();
        }
        goto LABEL_99;
      }
      CFStringRef v14 = v41;
      double v15 = CFStringGetCStringPtr(v41, 0x8000100u);
      if (v15) {
        goto LABEL_78;
      }
      malloc_type_id_t v16 = 3829306288;
LABEL_104:
      int v42 = (char *)malloc_type_calloc(0x400uLL, 1uLL, v16);
      CFStringGetCString(v14, v42, 1024, 0x8000100u);
      CFStringRef v43 = v42;
      goto LABEL_105;
    }
    if (v5)
    {
      if (byte_1000EBCF8)
      {
        int v9 = *__error();
        dispatch_time_t v10 = sub_10002E548();
        if (os_log_type_enabled(v10, OS_LOG_TYPE_INFO))
        {
          *(_WORD *)buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_INFO, "No target process to monitor for exiting", buf, 2u);
        }
        *__error() = v9;
      }
      if (byte_1000EBCF9) {
        BOOL v11 = dword_1000EB4A8 <= 1;
      }
      else {
        BOOL v11 = 0;
      }
      if (!v11) {
        return;
      }
      int v12 = *__error();
      CFStringRef v13 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"No target process to monitor for exiting");
      if (!v13)
      {
        int v44 = sub_10002E548();
        if (os_log_type_enabled(v44, OS_LOG_TYPE_FAULT)) {
          sub_100096688();
        }
        goto LABEL_99;
      }
      CFStringRef v14 = v13;
      double v15 = CFStringGetCStringPtr(v13, 0x8000100u);
      if (!v15)
      {
        malloc_type_id_t v16 = 4191268265;
        goto LABEL_104;
      }
    }
    else
    {
      if (byte_1000EBCF8)
      {
        int v31 = *__error();
        int v32 = sub_10002E548();
        if (os_log_type_enabled(v32, OS_LOG_TYPE_INFO))
        {
          *(_WORD *)buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_INFO, "Can't stop when kernel exits", buf, 2u);
        }
        *__error() = v31;
      }
      if (byte_1000EBCF9) {
        BOOL v33 = dword_1000EB4A8 <= 1;
      }
      else {
        BOOL v33 = 0;
      }
      if (!v33) {
        return;
      }
      int v12 = *__error();
      CFStringRef v34 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"Can't stop when kernel exits");
      if (!v34)
      {
        int v47 = sub_10002E548();
        if (os_log_type_enabled(v47, OS_LOG_TYPE_FAULT)) {
          sub_100096654();
        }
        goto LABEL_99;
      }
      CFStringRef v14 = v34;
      double v15 = CFStringGetCStringPtr(v34, 0x8000100u);
      if (!v15)
      {
        malloc_type_id_t v16 = 3080682967;
        goto LABEL_104;
      }
    }
LABEL_78:
    int v42 = (char *)v15;
    CFStringRef v43 = 0;
LABEL_105:
    if (qword_1000EBD00) {
      int v53 = (FILE *)qword_1000EBD00;
    }
    else {
      int v53 = __stderrp;
    }
    fprintf(v53, "%s\n", v42);
    if (v43) {
      free(v43);
    }
    CFStringRef v50 = v14;
    goto LABEL_111;
  }
  if ((*(_DWORD *)(v1 + 72) & 0x80000000) != 0)
  {
    if (byte_1000EBCF8)
    {
      int v35 = *__error();
      BOOL v36 = sub_10002E548();
      if (os_log_type_enabled(v36, OS_LOG_TYPE_DEBUG)) {
        sub_100096020();
      }
      *__error() = v35;
    }
    if (byte_1000EBCF9) {
      BOOL v37 = dword_1000EB4A8 <= 0;
    }
    else {
      BOOL v37 = 0;
    }
    if (!v37) {
      return;
    }
    int v12 = *__error();
    CFStringRef v38 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"Lost race: already done sampling");
    if (!v38)
    {
      CFStringRef v48 = sub_10002E548();
      if (os_log_type_enabled(v48, OS_LOG_TYPE_FAULT)) {
        sub_100095FEC();
      }
      goto LABEL_99;
    }
    CFStringRef v14 = v38;
    double v15 = CFStringGetCStringPtr(v38, 0x8000100u);
    if (!v15)
    {
      malloc_type_id_t v16 = 668362104;
      goto LABEL_104;
    }
    goto LABEL_78;
  }
  if (byte_1000EBCF8)
  {
    int v17 = *__error();
    BOOL v18 = sub_10002E548();
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG)) {
      sub_100095F74();
    }
    *__error() = v17;
  }
  if (byte_1000EBCF9) {
    BOOL v19 = dword_1000EB4A8 <= 0;
  }
  else {
    BOOL v19 = 0;
  }
  if (v19)
  {
    int v12 = *__error();
    CFStringRef v20 = sub_10002E4E8(*(_DWORD *)(*v2 + 72));
    CFStringRef v21 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%s [%d]: Lost race: already done sampling", v20, *(unsigned int *)(*v2 + 72));
    if (v21)
    {
      CFStringRef v22 = v21;
      CStringPtr = CFStringGetCStringPtr(v21, 0x8000100u);
      if (CStringPtr)
      {
LABEL_45:
        int v29 = (char *)CStringPtr;
        uint64_t v30 = 0;
LABEL_91:
        if (qword_1000EBD00) {
          CFStringRef v49 = (FILE *)qword_1000EBD00;
        }
        else {
          CFStringRef v49 = __stderrp;
        }
        fprintf(v49, "%s\n", v29);
        if (v30) {
          free(v30);
        }
        CFStringRef v50 = v22;
LABEL_111:
        CFRelease(v50);
LABEL_112:
        *__error() = v12;
        return;
      }
      malloc_type_id_t v24 = 668362104;
LABEL_90:
      int v29 = (char *)malloc_type_calloc(0x400uLL, 1uLL, v24);
      CFStringGetCString(v22, v29, 1024, 0x8000100u);
      uint64_t v30 = v29;
      goto LABEL_91;
    }
    malloc_type_id_t v45 = sub_10002E548();
    if (os_log_type_enabled(v45, OS_LOG_TYPE_FAULT)) {
      sub_100095EFC();
    }
LABEL_99:
    if (qword_1000EBD00) {
      uint64_t v52 = (FILE *)qword_1000EBD00;
    }
    else {
      uint64_t v52 = __stderrp;
    }
    fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v52);
    goto LABEL_112;
  }
}

id sub_100068528(uint64_t a1)
{
  uint64_t v1 = (id *)(a1 + 32);
  if ((*(_DWORD *)(*(void *)(a1 + 32) + 72) & 0x80000000) == 0)
  {
    if (byte_1000EBCF8)
    {
      int v2 = *__error();
      int v3 = sub_10002E548();
      if (os_log_type_enabled(v3, OS_LOG_TYPE_DEBUG)) {
        sub_100096734();
      }
      *__error() = v2;
    }
    if (byte_1000EBCF9) {
      BOOL v4 = dword_1000EB4A8 <= 0;
    }
    else {
      BOOL v4 = 0;
    }
    if (!v4) {
      return [*v1 stopSamplingWithReason:2];
    }
    int v5 = *__error();
    int v6 = sub_10002E4E8(*((_DWORD *)*v1 + 18));
    CFStringRef v7 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%s [%d]: exited", v6, *((unsigned int *)*v1 + 18));
    if (!v7)
    {
      BOOL v8 = sub_10002E548();
      if (os_log_type_enabled(v8, OS_LOG_TYPE_FAULT)) {
        sub_1000966BC();
      }
LABEL_35:
      if (qword_1000EBD00) {
        BOOL v18 = (FILE *)qword_1000EBD00;
      }
      else {
        BOOL v18 = __stderrp;
      }
      fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v18);
LABEL_39:
      *__error() = v5;
      return [*v1 stopSamplingWithReason:2];
    }
    goto LABEL_24;
  }
  if (byte_1000EBCF8)
  {
    int v9 = *__error();
    dispatch_time_t v10 = sub_10002E548();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG)) {
      sub_1000967E0();
    }
    *__error() = v9;
  }
  if (byte_1000EBCF9) {
    BOOL v11 = dword_1000EB4A8 <= 0;
  }
  else {
    BOOL v11 = 0;
  }
  if (v11)
  {
    int v5 = *__error();
    CFStringRef v7 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"exited");
    if (!v7)
    {
      int v17 = sub_10002E548();
      if (os_log_type_enabled(v17, OS_LOG_TYPE_FAULT)) {
        sub_1000967AC();
      }
      goto LABEL_35;
    }
LABEL_24:
    CFStringRef v12 = v7;
    CStringPtr = CFStringGetCStringPtr(v7, 0x8000100u);
    if (CStringPtr)
    {
      CFStringRef v14 = (char *)CStringPtr;
      double v15 = 0;
    }
    else
    {
      CFStringRef v14 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xA6C15D34uLL);
      CFStringGetCString(v12, v14, 1024, 0x8000100u);
      double v15 = v14;
    }
    if (qword_1000EBD00) {
      malloc_type_id_t v16 = (FILE *)qword_1000EBD00;
    }
    else {
      malloc_type_id_t v16 = __stderrp;
    }
    fprintf(v16, "%s\n", v14);
    if (v15) {
      free(v15);
    }
    CFRelease(v12);
    goto LABEL_39;
  }
  return [*v1 stopSamplingWithReason:2];
}

id sub_100068C40(id result)
{
  uint64_t v1 = *((void *)result + 4);
  if (*(unsigned char *)(v1 + 297))
  {
    int v2 = result;
    *(unsigned char *)(v1 + 297) = 0;
    [*((id *)result + 4) removeSelfFromPidCache];
    uint64_t v3 = v2[4];
    BOOL v4 = *(NSObject **)(v3 + 32);
    if (v4)
    {
      dispatch_release(v4);
      *(void *)(v2[4] + 32) = 0;
      uint64_t v3 = v2[4];
    }
    int v5 = *(NSObject **)(v3 + 40);
    if (v5)
    {
      dispatch_release(v5);
      *(void *)(v2[4] + 40) = 0;
      uint64_t v3 = v2[4];
    }
    BOOL v6 = *(unsigned char *)(v3 + 301) == 0;
    uint64_t v8 = *(void *)(v3 + 16);
    CFStringRef v7 = *(void **)(v3 + 24);
    v9[0] = _NSConcreteStackBlock;
    v9[1] = 3221225472;
    v9[2] = sub_100068D1C;
    v9[3] = &unk_1000DDA10;
    v9[4] = v3;
    char v10 = *((unsigned char *)v2 + 40);
    return [v7 stopAndWaitForAllSamplingToComplete:v6 withCompletionCallbackOnQueue:v8 withBlock:v9];
  }
  return result;
}

id sub_100068D1C(uint64_t a1, uint64_t a2)
{
  return [*(id *)(a1 + 32) _samplingHasCompletedWithEndSnapshot:a2 withReason:*(unsigned __int8 *)(a1 + 40)];
}

BOOL sub_100069F2C(int a1)
{
  return (a1 - 6) < 0xFFFFFFFC;
}

_DWORD *sub_100069F3C(uint64_t a1, void *a2)
{
  uint64_t v3 = (id *)(a1 + 32);
  id result = [a2 objectForKeyedSubscript:+[NSNumber numberWithInt:](NSNumber, "numberWithInt:", *(unsigned int *)(*(void *)(a1 + 32) + 72))];
  if (result && result == *v3)
  {
    if ((result[18] & 0x80000000) != 0)
    {
      if (byte_1000EBCF8)
      {
        int v12 = *__error();
        CFStringRef v13 = sub_10002E548();
        if (os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG)) {
          sub_1000970D8();
        }
        *__error() = v12;
      }
      if (byte_1000EBCF9) {
        BOOL v14 = dword_1000EB4A8 <= 0;
      }
      else {
        BOOL v14 = 0;
      }
      if (!v14) {
        goto LABEL_42;
      }
      int v8 = *__error();
      CFStringRef v10 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"Removing self from processes waiting on HID event list");
      if (!v10)
      {
        CFStringRef v20 = sub_10002E548();
        if (os_log_type_enabled(v20, OS_LOG_TYPE_FAULT)) {
          sub_1000970A4();
        }
        goto LABEL_37;
      }
    }
    else
    {
      if (byte_1000EBCF8)
      {
        int v5 = *__error();
        BOOL v6 = sub_10002E548();
        if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG)) {
          sub_10009702C();
        }
        *__error() = v5;
      }
      if (byte_1000EBCF9) {
        BOOL v7 = dword_1000EB4A8 <= 0;
      }
      else {
        BOOL v7 = 0;
      }
      if (!v7) {
        goto LABEL_42;
      }
      int v8 = *__error();
      int v9 = sub_10002E4E8(*((_DWORD *)*v3 + 18));
      CFStringRef v10 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%s [%d]: Removing self from processes waiting on HID event list", v9, *((unsigned int *)*v3 + 18));
      if (!v10)
      {
        BOOL v11 = sub_10002E548();
        if (os_log_type_enabled(v11, OS_LOG_TYPE_FAULT)) {
          sub_100096FB4();
        }
LABEL_37:
        if (qword_1000EBD00) {
          CFStringRef v21 = (FILE *)qword_1000EBD00;
        }
        else {
          CFStringRef v21 = __stderrp;
        }
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v21);
LABEL_41:
        *__error() = v8;
LABEL_42:
        [a2 setObject:0 forKeyedSubscript:[NSNumber numberWithInt:*((unsigned int *)*v3 + 18)]];
        return [*v3 deleteHIDExitSource];
      }
    }
    CFStringRef v15 = v10;
    CStringPtr = CFStringGetCStringPtr(v10, 0x8000100u);
    if (CStringPtr)
    {
      int v17 = (char *)CStringPtr;
      BOOL v18 = 0;
    }
    else
    {
      int v17 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x34677251uLL);
      CFStringGetCString(v15, v17, 1024, 0x8000100u);
      BOOL v18 = v17;
    }
    if (qword_1000EBD00) {
      BOOL v19 = (FILE *)qword_1000EBD00;
    }
    else {
      BOOL v19 = __stderrp;
    }
    fprintf(v19, "%s\n", v17);
    if (v18) {
      free(v18);
    }
    CFRelease(v15);
    goto LABEL_41;
  }
  return result;
}

void sub_10006A228(uint64_t a1)
{
  *(void *)(*(void *)(a1 + 32) + 64) = 0;
}

void sub_10006A274(uint64_t a1, void *a2)
{
  [a2 setTargetThreadId:0];
  int v5 = (id *)(a1 + 32);
  BOOL v4 = *(_DWORD **)(a1 + 32);
  if ((v4[18] & 0x80000000) == 0)
  {
    [a2 setTargetProcessId:];
    BOOL v4 = *v5;
  }
  if (*((void *)v4 + 19))
  {
    [a2 setTargetThreadId:];
    BOOL v4 = *v5;
  }
  if (*((void *)v4 + 15))
  {
    if ((objc_msgSend(objc_msgSend(objc_msgSend(a2, "targetProcess"), "mainBinaryPath"), "isAbsolutePath") & 1) == 0)
    {
      id v6 = [a2 targetProcess];
      if (v6) {
        [v6 setMainBinaryPath:*((void *)*v5 + 15)];
      }
    }
  }
  [a2 setTargetHIDEventMachAbs:*((void *)*v5 + 20)];
  [a2 setTargetHIDEventEndMachAbs:*((void *)*v5 + 21)];

  *((void *)*v5 + 10) = [objc_msgSend(objc_msgSend(a2, "targetProcess"), "name")];
  if (objc_msgSend(objc_msgSend(objc_msgSend(a2, "targetProcess"), "mainBinaryPath"), "isAbsolutePath")) {
    id v7 = [[objc_msgSend(a2, "targetProcess") mainBinaryPath];
  }
  else {
    id v7 = 0;
  }
  *((void *)*v5 + 15) = v7;
  unsigned int v8 = [[objc_msgSend(a2, "targetProcess") isUnresponsive];
  uint64_t v9 = 0;
  if (v8) {
    [objc_msgSend(a2, "targetProcess", 0.0) timeOfLastResponse];
  }
  *(void *)(*(void *)(a1 + 32) + 144) = v9;
  CFStringRef v10 = *(void **)(a1 + 40);
  if (!v10)
  {
    char v11 = 1;
    goto LABEL_40;
  }
  char v11 = *(unsigned char *)(a1 + 48);
  if ([v10 stackshotProvider] != *((id *)*v5 + 3))
  {
    if ((*((_DWORD *)*v5 + 18) & 0x80000000) != 0)
    {
      if (byte_1000EBCF8)
      {
        int v37 = *__error();
        CFStringRef v38 = sub_10002E548();
        if (os_log_type_enabled(v38, OS_LOG_TYPE_ERROR)) {
          sub_1000972A8(v38, v39, v40, v41, v42, v43, v44, v45);
        }
        *__error() = v37;
      }
      if (byte_1000EBCF9 && dword_1000EB4A8 <= 3)
      {
        int v46 = *__error();
        CFStringRef v47 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%s: Mismatched sample providers", "endSnapshot.stackshotProvider == _sampleProvider");
        if (v47)
        {
          CFStringRef v61 = v47;
          CStringPtr = CFStringGetCStringPtr(v47, 0x8000100u);
          if (CStringPtr)
          {
            CFStringRef v63 = (char *)CStringPtr;
            int v64 = 0;
          }
          else
          {
            CFStringRef v63 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x5B2C2171uLL);
            CFStringGetCString(v61, v63, 1024, 0x8000100u);
            int v64 = v63;
          }
          if (qword_1000EBD00) {
            uint64_t v71 = (FILE *)qword_1000EBD00;
          }
          else {
            uint64_t v71 = __stderrp;
          }
          fprintf(v71, "%s\n", v63);
          if (v64) {
            free(v64);
          }
          CFRelease(v61);
        }
        else
        {
          CFStringRef v48 = sub_10002E548();
          if (os_log_type_enabled(v48, OS_LOG_TYPE_FAULT)) {
            sub_100097230(v48, v49, v50, v51, v52, v53, v54, v55);
          }
          if (qword_1000EBD00) {
            double v56 = (FILE *)qword_1000EBD00;
          }
          else {
            double v56 = __stderrp;
          }
          fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v56);
        }
        *__error() = v46;
      }
      sub_10002E41C("-[SPSampledProcess _samplingHasCompletedWithEndSnapshot:withReason:]_block_invoke", "SPProcessEvent.m", 1346, "%s: Mismatched sample providers", v12, v13, v14, v15, (char)"endSnapshot.stackshotProvider == _sampleProvider");
    }
    else
    {
      if (byte_1000EBCF8)
      {
        int v30 = *__error();
        int v31 = sub_10002E548();
        if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR)) {
          sub_1000971A0();
        }
        *__error() = v30;
      }
      if (byte_1000EBCF9 && dword_1000EB4A8 <= 3)
      {
        int v32 = *__error();
        BOOL v33 = sub_10002E4E8(*((_DWORD *)*v5 + 18));
        CFStringRef v34 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%s [%d]: %s: Mismatched sample providers", v33, *((unsigned int *)*v5 + 18), "endSnapshot.stackshotProvider == _sampleProvider");
        if (v34)
        {
          CFStringRef v57 = v34;
          double v58 = CFStringGetCStringPtr(v34, 0x8000100u);
          if (v58)
          {
            CFStringRef v59 = (char *)v58;
            CFStringRef v60 = 0;
          }
          else
          {
            CFStringRef v59 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x5B2C2171uLL);
            CFStringGetCString(v57, v59, 1024, 0x8000100u);
            CFStringRef v60 = v59;
          }
          if (qword_1000EBD00) {
            int v65 = (FILE *)qword_1000EBD00;
          }
          else {
            int v65 = __stderrp;
          }
          fprintf(v65, "%s\n", v59);
          if (v60) {
            free(v60);
          }
          CFRelease(v57);
        }
        else
        {
          int v35 = sub_10002E548();
          if (os_log_type_enabled(v35, OS_LOG_TYPE_FAULT)) {
            sub_10009710C();
          }
          if (qword_1000EBD00) {
            BOOL v36 = (FILE *)qword_1000EBD00;
          }
          else {
            BOOL v36 = __stderrp;
          }
          fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v36);
        }
        *__error() = v32;
      }
      char v66 = sub_10002E4E8(*((_DWORD *)*v5 + 18));
      sub_10002E41C("-[SPSampledProcess _samplingHasCompletedWithEndSnapshot:withReason:]_block_invoke", "SPProcessEvent.m", 1346, "%s [%d]: %s: Mismatched sample providers", v67, v68, v69, v70, v66);
    }
    abort();
  }
  *(_DWORD *)(*(void *)(a1 + 32) + 284) = [*(id *)(a1 + 40) numSamplesAvoidedDueToAudio];
  *(_DWORD *)(*(void *)(a1 + 32) + 276) = [*(id *)(a1 + 40) numSamples];
  if (![*(id *)(a1 + 32) eventTimeRange])
  {
    id v16 = *v5;
    double v17 = *((double *)*v5 + 18);
    if (v17 > 0.0)
    {
      BOOL v18 = (void *)*((void *)v16 + 52);
      if (!v18) {
        goto LABEL_21;
      }
      [v18 wallTime];
      if (v17 < v19) {
        goto LABEL_22;
      }
      id v16 = *v5;
      if (!*((void *)*v5 + 52))
      {
LABEL_21:
        double v20 = *((double *)v16 + 18);
        [objc_msgSend(*(id *)(a1 + 40), "timestamp") wallTime];
        if (v20 < v21)
        {
LABEL_22:
          CFStringRef v22 = +[SATimestamp timestampWithMachAbsTime:0 machAbsTimeSec:0 machContTime:0.0 machContTimeSec:0.0 wallTime:*((double *)*v5 + 18)];
          id v23 = (id)*((void *)*v5 + 52);
          if (!v23) {
            id v23 = [*(id *)(a1 + 40) timestamp];
          }
          [(SATimestamp *)v22 guessMissingTimesBasedOnTimestamp:v23];
          if (!v22) {
            goto LABEL_30;
          }
          goto LABEL_29;
        }
        id v16 = *v5;
      }
    }
    CFStringRef v22 = (SATimestamp *)*((void *)v16 + 52);
    if (v22)
    {
LABEL_29:
      [*(id *)(a1 + 32) setEventTimeRange:[+[SATimeRange timeRangeStart:end:](SATimeRange, "timeRangeStart:end:", v22, objc_msgSend(*(id *)(a1 + 40), "timestamp"))];
      [*(id *)(a1 + 32) setReportTimeStart:v22];
      [*(id *)(a1 + 32) setReportTimeEnd:[*(id *)(a1 + 40) timestamp]];
    }
  }
LABEL_30:
  if (*((int *)*v5 + 18) >= 1 && [*v5 eventTimeRange])
  {
    uint64_t v75 = 0;
    BOOL v76 = &v75;
    uint64_t v77 = 0x2020000000;
    uint64_t v78 = 0;
    id v24 = [*v5 reportTimeStart];
    if (!v24) {
      id v24 = [objc_msgSend(*v5, "eventTimeRange") startTime];
    }
    id v25 = [a2 indexOfFirstSampleOnOrAfterTimestamp:v24];
    id v26 = [*v5 reportTimeEnd];
    if (!v26) {
      id v26 = [objc_msgSend(*v5, "eventTimeRange") endTime];
    }
    id v27 = [a2 indexOfLastSampleOnOrBeforeTimestamp:v26];
    if (v25 != (id)0x7FFFFFFFFFFFFFFFLL && v27 != (id)0x7FFFFFFFFFFFFFFFLL)
    {
      v74[0] = _NSConcreteStackBlock;
      v74[1] = 3221225472;
      v74[2] = sub_10006AA94;
      v74[3] = &unk_1000DDA38;
      v74[4] = &v75;
      v74[5] = v25;
      v74[6] = v27;
      [objc_msgSend(a2, "targetProcess") enumerateTaskStatesBetweenStartTime:v24 startSampleIndex:v25 endTime:v26 endSampleIndex:v27 reverseOrder:0 block:v74];
    }
    *((_DWORD *)*v5 + 72) = v76[3];
    _Block_object_dispose(&v75, 8);
  }
LABEL_40:
  CFStringRef v28 = *v5;
  int v29 = *((void *)*v5 + 7);
  if (v29)
  {
    if (v28[8])
    {
      block[0] = _NSConcreteStackBlock;
      block[1] = 3221225472;
      block[2] = sub_10006AAF0;
      block[3] = &unk_1000DD998;
      void block[4] = v28;
      char v73 = v11;
      dispatch_async(v29, block);
      dispatch_release(*((dispatch_object_t *)*v5 + 7));
      *((void *)*v5 + 7) = 0;
    }
  }
}

void sub_10006AA70(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 112), 8);
  _Unwind_Resume(a1);
}

id sub_10006AA94(void *a1, void *a2)
{
  if ([a2 suspendCount] || (id result = objc_msgSend(a2, "isPidSuspended"), result))
  {
    id result = [a2 sampleCountInSampleIndexRangeStart:a1[5] end:a1[6]];
    *(void *)(*(void *)(a1[4] + 8) + 24) += result;
  }
  return result;
}

void sub_10006AAF0(uint64_t a1)
{
  *(void *)(*(void *)(a1 + 32) + 64) = 0;
}

id sub_10006B484(uint64_t a1, void *a2, double a3)
{
  LODWORD(a3) = *(_DWORD *)(*(void *)(a1 + 32) + 400);
  [a2 setAttemptedSamplingInterval:(double)*(unint64_t *)&a3 / 1000000.0];
  [*(id *)(a1 + 32) reportTimeThreshold];
  [a2 setReportTimeThreshold:];
  int v5 = *(void **)(a1 + 32);
  uint64_t v6 = *(void *)(a1 + 40);

  return [v5 _saveReportToStream:v6 withSampleStore:a2];
}

uint64_t sub_10006BE40(uint64_t a1, void *a2, double a3)
{
  LODWORD(a3) = *(_DWORD *)(*(void *)(a1 + 32) + 400);
  [a2 setAttemptedSamplingInterval:(double)*(unint64_t *)&a3 / 1000000.0];
  [*(id *)(a1 + 32) reportTimeThreshold];
  [a2 setReportTimeThreshold:];
  [*(id *)(a1 + 32) _samplePrinterForSampleStore:a2];
  int v5 = *(uint64_t (**)(void))(*(void *)(a1 + 40) + 16);

  return v5();
}

id sub_10006BED8(uint64_t pid, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, unint64_t a6, uint64_t a7, uint64_t a8, double a9)
{
  if (!a4 || !a7 || !a8)
  {
    BOOL v18 = __error();
    id result = 0;
    int v20 = 22;
LABEL_377:
    int *v18 = v20;
    return result;
  }
  if ((pid & 0x80000000) != 0) {
    goto LABEL_17;
  }
  if (proc_pidpath(pid, &buffer, 0x400u) >= 1)
  {
    double v17 = +[NSString stringWithUTF8String:&buffer];
    if ((a6 & 1) == 0) {
      goto LABEL_19;
    }
LABEL_18:
    if (sub_1000240E8(pid)) {
      goto LABEL_19;
    }
    if ((pid & 0x80000000) != 0)
    {
      if (byte_1000EBCF8)
      {
        int v64 = *__error();
        int v65 = sub_10002E548();
        if (os_log_type_enabled(v65, OS_LOG_TYPE_ERROR)) {
          sub_1000980F0();
        }
        *__error() = v64;
      }
      if (!byte_1000EBCF9 || dword_1000EB4A8 > 3) {
        goto LABEL_196;
      }
      int v37 = *__error();
      CFStringRef v39 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"process doesn't exist, not sampling");
      if (!v39)
      {
        id v118 = sub_10002E548();
        if (os_log_type_enabled(v118, OS_LOG_TYPE_FAULT)) {
          sub_1000980BC();
        }
        goto LABEL_191;
      }
    }
    else
    {
      if (byte_1000EBCF8)
      {
        int v35 = *__error();
        BOOL v36 = sub_10002E548();
        if (os_log_type_enabled(v36, OS_LOG_TYPE_ERROR)) {
          sub_100098044();
        }
        *__error() = v35;
      }
      if (!byte_1000EBCF9 || dword_1000EB4A8 > 3) {
        goto LABEL_196;
      }
      int v37 = *__error();
      CFStringRef v38 = sub_10002E4E8(pid);
      CFStringRef v39 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%s [%d]: process doesn't exist, not sampling", v38, pid);
      if (!v39)
      {
        uint64_t v40 = sub_10002E548();
        if (os_log_type_enabled(v40, OS_LOG_TYPE_FAULT)) {
          sub_100097FCC();
        }
LABEL_191:
        if (qword_1000EBD00) {
          id v119 = (FILE *)qword_1000EBD00;
        }
        else {
          id v119 = __stderrp;
        }
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v119);
LABEL_195:
        *__error() = v37;
LABEL_196:
        BOOL v18 = __error();
        id result = 0;
        int v20 = 2;
        goto LABEL_377;
      }
    }
    CFStringRef v66 = v39;
    CStringPtr = CFStringGetCStringPtr(v39, 0x8000100u);
    if (CStringPtr)
    {
      uint64_t v68 = (char *)CStringPtr;
      uint64_t v69 = 0;
    }
    else
    {
      uint64_t v68 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x332A953AuLL);
      CFStringGetCString(v66, v68, 1024, 0x8000100u);
      uint64_t v69 = v68;
    }
    if (qword_1000EBD00) {
      id v100 = (FILE *)qword_1000EBD00;
    }
    else {
      id v100 = __stderrp;
    }
    fprintf(v100, "%s\n", v68);
    if (v69) {
      free(v69);
    }
    CFRelease(v66);
    goto LABEL_195;
  }
  if (byte_1000EBCF8)
  {
    int v21 = *__error();
    CFStringRef v22 = sub_10002E548();
    if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR)) {
      sub_1000981C4();
    }
    *__error() = v21;
  }
  if (!byte_1000EBCF9 || dword_1000EB4A8 > 3)
  {
LABEL_17:
    double v17 = 0;
    if ((a6 & 1) == 0) {
      goto LABEL_19;
    }
    goto LABEL_18;
  }
  int v187 = *__error();
  int v46 = sub_10002E4E8(pid);
  uint64_t v47 = *__error();
  CFStringRef v48 = __error();
  uint64_t v49 = strerror(*v48);
  CFStringRef v50 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%s [%d]: Unable to get path: %d (%s)", v46, pid, v47, v49);
  if (v50)
  {
    CFStringRef v51 = v50;
    uint64_t v52 = CFStringGetCStringPtr(v50, 0x8000100u);
    if (v52)
    {
      uint64_t v53 = (char *)v52;
      uint64_t v54 = 0;
    }
    else
    {
      uint64_t v53 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x9981D8F0uLL);
      CFStringGetCString(v51, v53, 1024, 0x8000100u);
      uint64_t v54 = v53;
    }
    if (qword_1000EBD00) {
      id v101 = (FILE *)qword_1000EBD00;
    }
    else {
      id v101 = __stderrp;
    }
    fprintf(v101, "%s\n", v53);
    if (v54) {
      free(v54);
    }
    CFRelease(v51);
  }
  else
  {
    uintptr_t v86 = sub_10002E548();
    if (os_log_type_enabled(v86, OS_LOG_TYPE_FAULT)) {
      sub_100098124();
    }
    if (qword_1000EBD00) {
      CFStringRef v87 = (FILE *)qword_1000EBD00;
    }
    else {
      CFStringRef v87 = __stderrp;
    }
    fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v87);
  }
  double v17 = 0;
  *__error() = v187;
  if (a6) {
    goto LABEL_18;
  }
LABEL_19:
  id v186 = v17;
  char v190 = 0;
  id v24 = +[SPSampledProcess copySampledProcessForPid:pid isWSBased:(a6 >> 2) & 1 createIfUnsampled:1 wasSampled:&v190];
  if (v24) {
    goto LABEL_20;
  }
  if ((a6 & 2) == 0 || !v190)
  {
LABEL_326:
    if ((pid & 0x80000000) != 0)
    {
      if (byte_1000EBCF8)
      {
        int v166 = *__error();
        uint64_t v167 = sub_10002E548();
        if (os_log_type_enabled(v167, OS_LOG_TYPE_ERROR)) {
          sub_1000975D8();
        }
        *__error() = v166;
      }
      if (!byte_1000EBCF9 || dword_1000EB4A8 > 3) {
        goto LABEL_376;
      }
      int v162 = *__error();
      CFStringRef v164 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"Unable to create SPSampledProcess");
      if (!v164)
      {
        uint64_t v173 = sub_10002E548();
        if (os_log_type_enabled(v173, OS_LOG_TYPE_FAULT)) {
          sub_1000975A4();
        }
        goto LABEL_354;
      }
    }
    else
    {
      if (byte_1000EBCF8)
      {
        int v160 = *__error();
        uint64_t v161 = sub_10002E548();
        if (os_log_type_enabled(v161, OS_LOG_TYPE_ERROR)) {
          sub_10009752C();
        }
        *__error() = v160;
      }
      if (!byte_1000EBCF9 || dword_1000EB4A8 > 3) {
        goto LABEL_376;
      }
      int v162 = *__error();
      uint64_t v163 = sub_10002E4E8(pid);
      CFStringRef v164 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%s [%d]: Unable to create SPSampledProcess", v163, pid);
      if (!v164)
      {
        CFStringRef v165 = sub_10002E548();
        if (os_log_type_enabled(v165, OS_LOG_TYPE_FAULT)) {
          sub_1000974B4();
        }
LABEL_354:
        if (qword_1000EBD00) {
          id v174 = (FILE *)qword_1000EBD00;
        }
        else {
          id v174 = __stderrp;
        }
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v174);
LABEL_358:
        *__error() = v162;
LABEL_376:
        BOOL v18 = __error();
        id result = 0;
        int v20 = 37;
        goto LABEL_377;
      }
    }
    CFStringRef v168 = v164;
    uint64_t v169 = CFStringGetCStringPtr(v164, 0x8000100u);
    if (v169)
    {
      uint64_t v170 = (char *)v169;
      uint64_t v171 = 0;
    }
    else
    {
      uint64_t v170 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xE0166F76uLL);
      CFStringGetCString(v168, v170, 1024, 0x8000100u);
      uint64_t v171 = v170;
    }
    if (qword_1000EBD00) {
      uint64_t v172 = (FILE *)qword_1000EBD00;
    }
    else {
      uint64_t v172 = __stderrp;
    }
    fprintf(v172, "%s\n", v170);
    if (v171) {
      free(v171);
    }
    CFRelease(v168);
    goto LABEL_358;
  }
  id v33 = +[SPSampledProcess copySampledProcessForPid:pid isWSBased:(a6 & 4) == 0 createIfUnsampled:0 wasSampled:0];
  if (v33)
  {
    CFStringRef v34 = v33;
    [v33 stopSamplingWithReason:9];

    goto LABEL_325;
  }
  if ((pid & 0x80000000) != 0)
  {
    if (byte_1000EBCF8)
    {
      int v185 = *__error();
      id v114 = sub_10002E548();
      if (os_log_type_enabled(v114, OS_LOG_TYPE_DEBUG)) {
        sub_100097F3C((a6 & 4) != 0, v114);
      }
      *__error() = v185;
    }
    if (byte_1000EBCF9 && dword_1000EB4A8 <= 0)
    {
      int v184 = *__error();
      if ((a6 & 4) != 0) {
        int v115 = "non-";
      }
      else {
        int v115 = "";
      }
      CFStringRef v84 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"Unable to find existing %sWindowServer-based sampled process", v115);
      if (!v84)
      {
        CFAllocatorRef allocb = (CFAllocatorRef)v115;
        uint64_t v152 = sub_10002E548();
        if (os_log_type_enabled(v152, OS_LOG_TYPE_FAULT)) {
          sub_100097ED0((uint64_t)allocb, v152, v153, v154, v155, v156, v157, v158);
        }
        goto LABEL_320;
      }
LABEL_187:
      CFStringRef alloca = v84;
      id v116 = CFStringGetCStringPtr(v84, 0x8000100u);
      if (v116)
      {
        CFStringRef v117 = (char *)v116;
        id v178 = 0;
      }
      else
      {
        CFStringRef v117 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x7CACA105uLL);
        CFStringGetCString(alloca, v117, 1024, 0x8000100u);
        id v178 = v117;
      }
      if (qword_1000EBD00) {
        unsigned int v130 = (FILE *)qword_1000EBD00;
      }
      else {
        unsigned int v130 = __stderrp;
      }
      fprintf(v130, "%s\n", v117);
      if (v178) {
        free(v178);
      }
      CFRelease(alloca);
      goto LABEL_324;
    }
  }
  else
  {
    if (byte_1000EBCF8)
    {
      int v183 = *__error();
      CFStringRef v81 = sub_10002E548();
      if (os_log_type_enabled(v81, OS_LOG_TYPE_DEBUG)) {
        sub_100097E14(pid);
      }
      *__error() = v183;
    }
    if (byte_1000EBCF9 && dword_1000EB4A8 <= 0)
    {
      int v184 = *__error();
      int v82 = sub_10002E4E8(pid);
      if ((a6 & 4) != 0) {
        unsigned int v83 = "non-";
      }
      else {
        unsigned int v83 = "";
      }
      CFStringRef v84 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%s [%d]: Unable to find existing %sWindowServer-based sampled process", v82, pid, v83);
      if (!v84)
      {
        CFStringRef v85 = sub_10002E548();
        if (os_log_type_enabled(v85, OS_LOG_TYPE_FAULT)) {
          sub_100097D70(pid);
        }
LABEL_320:
        if (qword_1000EBD00) {
          uint64_t v159 = (FILE *)qword_1000EBD00;
        }
        else {
          uint64_t v159 = __stderrp;
        }
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v159);
LABEL_324:
        *__error() = v184;
        goto LABEL_325;
      }
      goto LABEL_187;
    }
  }
LABEL_325:
  id v24 = +[SPSampledProcess copySampledProcessForPid:pid isWSBased:(a6 >> 2) & 1 createIfUnsampled:1 wasSampled:&v190];
  if (!v24) {
    goto LABEL_326;
  }
LABEL_20:
  if (!v190)
  {
    [v24 setSamplingIntervalUs:a2];
    [v24 setOccasionalDataIntervalSec:a3];
    [v24 setSamplingMode:a4 withAdditionalSampledProcesses:a5];
    [v24 setOmitSensitiveStrings:(a6 >> 4) & 1];
    [v24 setCancelOnMemoryPressure:(a6 >> 5) & 1];
    if ([v24 startSampling])
    {
      if ((a6 & 0x40) != 0) {
        [v24 requireHIDEvent:1];
      }
      goto LABEL_289;
    }
    if ((pid & 0x80000000) != 0)
    {
      if (byte_1000EBCF8)
      {
        int v93 = *__error();
        double v94 = sub_10002E548();
        if (os_log_type_enabled(v94, OS_LOG_TYPE_ERROR)) {
          sub_100097730();
        }
        *__error() = v93;
      }
      if (!byte_1000EBCF9 || dword_1000EB4A8 > 3) {
        goto LABEL_249;
      }
      int v57 = *__error();
      CFStringRef v95 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"Failed to start sampling");
      if (v95)
      {
        CFStringRef v96 = v95;
        double v97 = CFStringGetCStringPtr(v95, 0x8000100u);
        if (v97)
        {
          double v98 = (char *)v97;
          double v99 = 0;
        }
        else
        {
          double v98 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x176201E8uLL);
          CFStringGetCString(v96, v98, 1024, 0x8000100u);
          double v99 = v98;
        }
        if (qword_1000EBD00) {
          id v132 = (FILE *)qword_1000EBD00;
        }
        else {
          id v132 = __stderrp;
        }
        fprintf(v132, "%s\n", v98);
        if (v99) {
          free(v99);
        }
        CFStringRef v126 = v96;
        goto LABEL_247;
      }
      id v128 = sub_10002E548();
      if (os_log_type_enabled(v128, OS_LOG_TYPE_FAULT)) {
        sub_1000976FC();
      }
    }
    else
    {
      if (byte_1000EBCF8)
      {
        int v55 = *__error();
        double v56 = sub_10002E548();
        if (os_log_type_enabled(v56, OS_LOG_TYPE_ERROR)) {
          sub_100097684();
        }
        *__error() = v55;
      }
      if (!byte_1000EBCF9 || dword_1000EB4A8 > 3) {
        goto LABEL_249;
      }
      int v57 = *__error();
      double v58 = sub_10002E4E8(pid);
      CFStringRef v59 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%s [%d]: Failed to start sampling", v58, pid);
      if (v59)
      {
        CFStringRef v60 = v59;
        CFStringRef v61 = CFStringGetCStringPtr(v59, 0x8000100u);
        if (v61)
        {
          BOOL v62 = (char *)v61;
          CFStringRef v63 = 0;
        }
        else
        {
          BOOL v62 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x176201E8uLL);
          CFStringGetCString(v60, v62, 1024, 0x8000100u);
          CFStringRef v63 = v62;
        }
        if (qword_1000EBD00) {
          int v125 = (FILE *)qword_1000EBD00;
        }
        else {
          int v125 = __stderrp;
        }
        fprintf(v125, "%s\n", v62);
        if (v63) {
          free(v63);
        }
        CFStringRef v126 = v60;
LABEL_247:
        CFRelease(v126);
LABEL_248:
        *__error() = v57;
LABEL_249:
        [v24 removeSelfFromPidCache];
LABEL_375:

        goto LABEL_376;
      }
      uint64_t v123 = sub_10002E548();
      if (os_log_type_enabled(v123, OS_LOG_TYPE_FAULT)) {
        sub_10009760C();
      }
    }
    if (qword_1000EBD00) {
      CFStringRef v129 = (FILE *)qword_1000EBD00;
    }
    else {
      CFStringRef v129 = __stderrp;
    }
    fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v129);
    goto LABEL_248;
  }
  if ((a6 & 0x102) == 0x100)
  {
    if ((pid & 0x80000000) == 0)
    {
      if (byte_1000EBCF8)
      {
        int v25 = *__error();
        id v26 = sub_10002E548();
        if (os_log_type_enabled(v26, OS_LOG_TYPE_DEBUG)) {
          sub_1000977DC();
        }
        *__error() = v25;
      }
      if (!byte_1000EBCF9 || dword_1000EB4A8 > 0) {
        goto LABEL_375;
      }
      int v27 = *__error();
      CFStringRef v28 = sub_10002E4E8(pid);
      CFStringRef v29 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%s [%d]: Not overriding existing sampling callback", v28, pid);
      if (v29)
      {
        CFStringRef v30 = v29;
        int v31 = CFStringGetCStringPtr(v29, 0x8000100u);
        if (!v31)
        {
          malloc_type_id_t v32 = 356614855;
LABEL_309:
          uint64_t v140 = (char *)malloc_type_calloc(0x400uLL, 1uLL, v32);
          CFStringGetCString(v30, v140, 1024, 0x8000100u);
          uint64_t v141 = v140;
          goto LABEL_310;
        }
        goto LABEL_276;
      }
      int v113 = sub_10002E548();
      if (os_log_type_enabled(v113, OS_LOG_TYPE_FAULT)) {
        sub_100097764();
      }
      goto LABEL_370;
    }
    if (byte_1000EBCF8)
    {
      int v70 = *__error();
      uint64_t v71 = sub_10002E548();
      if (os_log_type_enabled(v71, OS_LOG_TYPE_DEBUG)) {
        sub_100097888();
      }
      *__error() = v70;
    }
    if (!byte_1000EBCF9 || dword_1000EB4A8 > 0) {
      goto LABEL_375;
    }
    int v27 = *__error();
    CFStringRef v72 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"Not overriding existing sampling callback");
    if (!v72)
    {
      id v124 = sub_10002E548();
      if (os_log_type_enabled(v124, OS_LOG_TYPE_FAULT)) {
        sub_100097854();
      }
      goto LABEL_370;
    }
    CFStringRef v73 = v72;
    int v74 = CFStringGetCStringPtr(v72, 0x8000100u);
    if (!v74)
    {
      malloc_type_id_t v75 = 356614855;
LABEL_360:
      CFStringRef v145 = (char *)malloc_type_calloc(0x400uLL, 1uLL, v75);
      CFStringGetCString(v73, v145, 1024, 0x8000100u);
      BOOL v146 = v145;
      goto LABEL_361;
    }
    goto LABEL_285;
  }
  if ((a6 & 0x10) != 0 && ([v24 omitSensitiveStrings] & 1) == 0)
  {
    if ((pid & 0x80000000) == 0)
    {
      if (byte_1000EBCF8)
      {
        int v88 = *__error();
        int v89 = sub_10002E548();
        if (os_log_type_enabled(v89, OS_LOG_TYPE_DEFAULT))
        {
          id v90 = sub_10002E4E8(pid);
          int buffer = 136446466;
          unsigned __int8 v192 = v90;
          __int16 v193 = 1024;
          int v194 = pid;
          _os_log_impl((void *)&_mh_execute_header, v89, OS_LOG_TYPE_DEFAULT, "%{public}s [%d]: Already sampling with sensitive strings", (uint8_t *)&buffer, 0x12u);
        }
        *__error() = v88;
      }
      if (!byte_1000EBCF9 || dword_1000EB4A8 > 2) {
        goto LABEL_375;
      }
      int v27 = *__error();
      int v91 = sub_10002E4E8(pid);
      CFStringRef v92 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%s [%d]: Already sampling with sensitive strings", v91, pid);
      if (v92)
      {
        CFStringRef v30 = v92;
        int v31 = CFStringGetCStringPtr(v92, 0x8000100u);
        if (!v31)
        {
          malloc_type_id_t v32 = 3335414674;
          goto LABEL_309;
        }
LABEL_276:
        uint64_t v140 = (char *)v31;
        uint64_t v141 = 0;
LABEL_310:
        if (qword_1000EBD00) {
          uint64_t v149 = (FILE *)qword_1000EBD00;
        }
        else {
          uint64_t v149 = __stderrp;
        }
        fprintf(v149, "%s\n", v140);
        if (v141) {
          free(v141);
        }
        CFStringRef v150 = v30;
LABEL_367:
        CFRelease(v150);
LABEL_374:
        *__error() = v27;
        goto LABEL_375;
      }
      id v131 = sub_10002E548();
      if (os_log_type_enabled(v131, OS_LOG_TYPE_FAULT)) {
        sub_100097CC4();
      }
LABEL_370:
      if (qword_1000EBD00) {
        id v177 = (FILE *)qword_1000EBD00;
      }
      else {
        id v177 = __stderrp;
      }
      fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v177);
      goto LABEL_374;
    }
    if (byte_1000EBCF8)
    {
      int v120 = *__error();
      id v121 = sub_10002E548();
      if (os_log_type_enabled(v121, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(buffer) = 0;
        _os_log_impl((void *)&_mh_execute_header, v121, OS_LOG_TYPE_DEFAULT, "Already sampling with sensitive strings", (uint8_t *)&buffer, 2u);
      }
      *__error() = v120;
    }
    if (!byte_1000EBCF9 || dword_1000EB4A8 > 2) {
      goto LABEL_375;
    }
    int v27 = *__error();
    CFStringRef v122 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"Already sampling with sensitive strings");
    if (!v122)
    {
      int v176 = sub_10002E548();
      if (os_log_type_enabled(v176, OS_LOG_TYPE_FAULT)) {
        sub_100097D3C();
      }
      goto LABEL_370;
    }
    CFStringRef v73 = v122;
    int v74 = CFStringGetCStringPtr(v122, 0x8000100u);
    if (!v74)
    {
      malloc_type_id_t v75 = 3335414674;
      goto LABEL_360;
    }
LABEL_285:
    CFStringRef v145 = (char *)v74;
    BOOL v146 = 0;
LABEL_361:
    if (qword_1000EBD00) {
      CFStringRef v175 = (FILE *)qword_1000EBD00;
    }
    else {
      CFStringRef v175 = __stderrp;
    }
    fprintf(v175, "%s\n", v145);
    if (v146) {
      free(v146);
    }
    CFStringRef v150 = v73;
    goto LABEL_367;
  }
  if ((a6 & 2) != 0)
  {
    if ((pid & 0x80000000) != 0)
    {
      if (byte_1000EBCF8)
      {
        int v108 = *__error();
        uint64_t v109 = sub_10002E548();
        if (os_log_type_enabled(v109, OS_LOG_TYPE_DEBUG)) {
          sub_100097C90();
        }
        *__error() = v108;
      }
      if (!byte_1000EBCF9 || dword_1000EB4A8 > 0) {
        goto LABEL_259;
      }
      int v110 = *__error();
      CFStringRef v79 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"Already sampling, overriding existing callback");
      int v182 = v110;
      if (!v79)
      {
        id v134 = sub_10002E548();
        if (os_log_type_enabled(v134, OS_LOG_TYPE_FAULT)) {
          sub_100097C5C();
        }
        goto LABEL_254;
      }
    }
    else
    {
      if (byte_1000EBCF8)
      {
        int v76 = *__error();
        uint64_t v77 = sub_10002E548();
        if (os_log_type_enabled(v77, OS_LOG_TYPE_DEBUG)) {
          sub_100097BE4();
        }
        *__error() = v76;
      }
      if (!byte_1000EBCF9 || dword_1000EB4A8 > 0) {
        goto LABEL_259;
      }
      int v182 = *__error();
      uint64_t v78 = sub_10002E4E8(pid);
      CFStringRef v79 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%s [%d]: Already sampling, overriding existing callback", v78, pid);
      if (!v79)
      {
        char v80 = sub_10002E548();
        if (os_log_type_enabled(v80, OS_LOG_TYPE_FAULT)) {
          sub_100097B6C();
        }
        goto LABEL_254;
      }
    }
    CFStringRef v105 = v79;
    CFStringRef v106 = CFStringGetCStringPtr(v79, 0x8000100u);
    CFAllocatorRef alloc = (CFAllocatorRef)v105;
    if (!v106)
    {
      malloc_type_id_t v107 = 3527695562;
      goto LABEL_218;
    }
LABEL_174:
    uint64_t v111 = (char *)v106;
    uint64_t v112 = 0;
LABEL_219:
    if (qword_1000EBD00) {
      int v127 = (FILE *)qword_1000EBD00;
    }
    else {
      int v127 = __stderrp;
    }
    fprintf(v127, "%s\n", v111);
    if (v112) {
      free(v112);
    }
    CFRelease(alloc);
    goto LABEL_258;
  }
  if ((pid & 0x80000000) != 0)
  {
    if (byte_1000EBCF8)
    {
      int v102 = *__error();
      int v103 = sub_10002E548();
      if (os_log_type_enabled(v103, OS_LOG_TYPE_DEBUG)) {
        sub_100097B38();
      }
      *__error() = v102;
    }
    if (byte_1000EBCF9 && dword_1000EB4A8 <= 0)
    {
      int v104 = *__error();
      CFStringRef v44 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"Already sampling, not overriding existing callback");
      int v182 = v104;
      if (!v44)
      {
        id v133 = sub_10002E548();
        if (os_log_type_enabled(v133, OS_LOG_TYPE_FAULT)) {
          sub_100097B04();
        }
        goto LABEL_254;
      }
LABEL_164:
      CFStringRef v105 = v44;
      CFStringRef v106 = CFStringGetCStringPtr(v44, 0x8000100u);
      CFAllocatorRef alloc = (CFAllocatorRef)v105;
      if (!v106)
      {
        malloc_type_id_t v107 = 816801464;
LABEL_218:
        uint64_t v111 = (char *)malloc_type_calloc(0x400uLL, 1uLL, v107);
        CFStringGetCString(v105, v111, 1024, 0x8000100u);
        uint64_t v112 = v111;
        goto LABEL_219;
      }
      goto LABEL_174;
    }
  }
  else
  {
    if (byte_1000EBCF8)
    {
      int v41 = *__error();
      uint64_t v42 = sub_10002E548();
      if (os_log_type_enabled(v42, OS_LOG_TYPE_DEBUG)) {
        sub_100097A8C();
      }
      *__error() = v41;
    }
    if (byte_1000EBCF9 && dword_1000EB4A8 <= 0)
    {
      int v182 = *__error();
      uint64_t v43 = sub_10002E4E8(pid);
      CFStringRef v44 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%s [%d]: Already sampling, not overriding existing callback", v43, pid);
      if (!v44)
      {
        uint64_t v45 = sub_10002E548();
        if (os_log_type_enabled(v45, OS_LOG_TYPE_FAULT)) {
          sub_100097A14();
        }
LABEL_254:
        if (qword_1000EBD00) {
          int v135 = (FILE *)qword_1000EBD00;
        }
        else {
          int v135 = __stderrp;
        }
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v135);
LABEL_258:
        *__error() = v182;
        goto LABEL_259;
      }
      goto LABEL_164;
    }
  }
LABEL_259:
  if ([v24 samplingIntervalUs] != a2
    || a3
    && [v24 occasionalDataIntervalSec]
    && [v24 occasionalDataIntervalSec] != a3)
  {
    if ((pid & 0x80000000) == 0)
    {
      if (byte_1000EBCF8)
      {
        int v136 = *__error();
        uint64_t v137 = sub_10002E548();
        if (os_log_type_enabled(v137, OS_LOG_TYPE_ERROR)) {
          sub_100097934();
        }
        *__error() = v136;
      }
      if (!byte_1000EBCF9 || dword_1000EB4A8 > 3) {
        goto LABEL_375;
      }
      int v27 = *__error();
      uint64_t v138 = sub_10002E4E8(pid);
      CFStringRef v139 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%s [%d]: Already sampling with incompatible parameters", v138, pid);
      if (v139)
      {
        CFStringRef v30 = v139;
        int v31 = CFStringGetCStringPtr(v139, 0x8000100u);
        if (!v31)
        {
          malloc_type_id_t v32 = 32670908;
          goto LABEL_309;
        }
        goto LABEL_276;
      }
      uint64_t v148 = sub_10002E548();
      if (os_log_type_enabled(v148, OS_LOG_TYPE_FAULT)) {
        sub_1000978BC();
      }
      goto LABEL_370;
    }
    if (byte_1000EBCF8)
    {
      int v142 = *__error();
      uint64_t v143 = sub_10002E548();
      if (os_log_type_enabled(v143, OS_LOG_TYPE_ERROR)) {
        sub_1000979E0();
      }
      *__error() = v142;
    }
    if (!byte_1000EBCF9 || dword_1000EB4A8 > 3) {
      goto LABEL_375;
    }
    int v27 = *__error();
    CFStringRef v144 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"Already sampling with incompatible parameters");
    if (!v144)
    {
      uint64_t v151 = sub_10002E548();
      if (os_log_type_enabled(v151, OS_LOG_TYPE_FAULT)) {
        sub_1000979AC();
      }
      goto LABEL_370;
    }
    CFStringRef v73 = v144;
    int v74 = CFStringGetCStringPtr(v144, 0x8000100u);
    if (!v74)
    {
      malloc_type_id_t v75 = 32670908;
      goto LABEL_360;
    }
    goto LABEL_285;
  }
  if ([v24 samplingMode] >= a4)
  {
    if ((a6 & 2) != 0)
    {
      [v24 setSamplingMode:a4 withAdditionalSampledProcesses:a5];
      [v24 setCancelOnMemoryPressure:(a6 >> 5) & 1];
LABEL_293:
      [v24 requireHIDEvent:(a6 >> 6) & 1];
      LODWORD(v147) = 1;
LABEL_294:
      if ((a6 & 8) != 0) {
        [v24 setIsUrgent:1];
      }
      v189[0] = _NSConcreteStackBlock;
      v189[1] = 3221225472;
      v189[2] = sub_10006D96C;
      v189[3] = &unk_1000DDAD8;
      v189[4] = v24;
      v189[5] = a8;
      [v24 setSamplingCompletionHandlerQueue:a7 andBlock:v189];
      goto LABEL_297;
    }
    if ((a6 & 0x20) == 0) {
      [v24 setCancelOnMemoryPressure:0, a5];
    }
  }
  else
  {
    [v24 setSamplingMode:a4 withAdditionalSampledProcesses:a5];
    if ((a6 & 0x22) != 0x20)
    {
      [v24 setCancelOnMemoryPressure:(a6 >> 5) & 1];
      if ((a6 & 2) != 0) {
        goto LABEL_293;
      }
    }
  }
LABEL_289:
  uint64_t v147 = (a6 >> 1) & 1;
  if ((a6 & 2) != 0 || !v190) {
    goto LABEL_294;
  }
LABEL_297:
  if (a9 > 0.0) {
    [v24 setSamplingTimeoutAtTime:a9];
  }
  if (((v190 != 0) & ~v147) == 0) {
    [v24 setStopWhenProcessExits:a6 & 1];
  }
  if ((a6 & 0x80) != 0) {
    [v24 gatherLoadInfoForPid:pid];
  }
  if (v186) {
    [v24 setTargetProcessAbsolutePath:v186];
  }
  return v24;
}

uint64_t sub_10006D96C(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void, void, uint64_t))(*(void *)(a1 + 40) + 16))(*(void *)(a1 + 40), *(void *)(a1 + 32), a2);
}

uint64_t sub_10006D984(int a1)
{
  uint64_t v1 = 0x400000;
  if (a1 == 37) {
    uint64_t v1 = 0x4000;
  }
  if (a1 == 2) {
    return 0x8000000000;
  }
  else {
    return v1;
  }
}

const char *sub_10006DC4C(int a1)
{
  if ((a1 - 1) > 9) {
    return "unknown";
  }
  else {
    return off_1000DDB40[(char)(a1 - 1)];
  }
}

void sub_10006DC78(id a1)
{
  qword_1000EBC90 = (uint64_t)objc_alloc_init((Class)NSMutableDictionary);
  uint64_t v1 = dispatch_queue_attr_make_with_autorelease_frequency(0, DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM);
  qword_1000EBC88 = (uint64_t)dispatch_queue_create("com.apple.spindump.processes_waiting_for_hid_event", v1);

  dispatch_release(v1);
}

uint64_t sub_10006DCE4(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

_DWORD *sub_10006DCFC(uint64_t a1)
{
  int v2 = *(_DWORD *)(*(void *)a1 + 72);
  return sub_10002E4E8(v2);
}

_DWORD *sub_10006DDC4@<X0>(int *a1@<X0>, uint64_t a2@<X8>)
{
  *(void *)(v2 - 24) = a2;
  int v4 = *a1;
  return sub_10002E4E8(v4);
}

void sub_10006DDDC(uint64_t a1@<X8>)
{
  *(void *)(v1 - _Block_object_dispose(&STACK[0x378], 8) = a1;
}

void sub_10006DDF0(void *a1, uint64_t a2, os_log_t log, const char *a4, ...)
{
  va_start(va, a4);
  _os_log_fault_impl(a1, log, OS_LOG_TYPE_FAULT, a4, (uint8_t *)va, 0xEu);
}

void sub_10006DE10(void *a1, uint64_t a2, os_log_t log, const char *a4, ...)
{
  va_start(va, a4);
  _os_log_error_impl(a1, log, OS_LOG_TYPE_ERROR, a4, (uint8_t *)va, 0x1Eu);
}

void sub_10006DE30(void *a1, uint64_t a2, os_log_t log, const char *a4, ...)
{
  va_start(va, a4);
  _os_log_error_impl(a1, log, OS_LOG_TYPE_ERROR, a4, (uint8_t *)va, 0xEu);
}

id sub_10006DE50(void **a1)
{
  uint64_t v2 = *a1;
  return [v2 targetProcessId];
}

id sub_10006DE68()
{
  uint64_t v2 = *v0;
  return [v2 targetProcessId];
}

id sub_10006DF74(uint64_t a1, void *a2)
{
  if (a2)
  {
    uint64_t v2 = a2;
    long long v38 = 0u;
    long long v39 = 0u;
    long long v36 = 0u;
    long long v37 = 0u;
    id v3 = [a2 countByEnumeratingWithState:&v36 objects:v44 count:16];
    if (v3)
    {
      id v4 = v3;
      id v5 = 0;
      uint64_t v6 = *(void *)v37;
      do
      {
        id v7 = 0;
        do
        {
          if (*(void *)v37 != v6) {
            objc_enumerationMutation(v2);
          }
          unsigned int v8 = *(void **)(*((void *)&v36 + 1) + 8 * (void)v7);
          [v8 intValue];
          stackshot_config_set_pid();
          int v9 = stackshot_capture_with_config();
          if (v9)
          {
            if (v9 == 2)
            {
              if (byte_1000EBCF8)
              {
                int v10 = *__error();
                char v11 = sub_10002E548();
                if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG)) {
                  sub_1000982C8((uint64_t)v43, v8);
                }
                *__error() = v10;
              }
              if (byte_1000EBCF9) {
                BOOL v12 = dword_1000EB4A8 <= 0;
              }
              else {
                BOOL v12 = 0;
              }
              if (v12)
              {
                int v13 = *__error();
                CFStringRef v14 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"pid %d doesn't exist", [v8 intValue]);
                if (v14)
                {
                  CFStringRef v15 = v14;
                  int v33 = v13;
                  id v16 = v2;
                  id v17 = v5;
                  CStringPtr = CFStringGetCStringPtr(v14, 0x8000100u);
                  if (CStringPtr)
                  {
                    double v19 = (char *)CStringPtr;
                    int v20 = 0;
                  }
                  else
                  {
                    double v19 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x3561A610uLL);
                    CFStringGetCString(v15, v19, 1024, 0x8000100u);
                    int v20 = v19;
                  }
                  if (qword_1000EBD00) {
                    id v26 = (FILE *)qword_1000EBD00;
                  }
                  else {
                    id v26 = __stderrp;
                  }
                  fprintf(v26, "%s\n", v19);
                  if (v20) {
                    free(v20);
                  }
                  CFRelease(v15);
                  id v5 = v17;
                  uint64_t v2 = v16;
                  int v13 = v33;
                }
                else
                {
                  id v24 = sub_10002E548();
                  if (os_log_type_enabled(v24, OS_LOG_TYPE_FAULT)) {
                    sub_10009826C((uint64_t)v42, v8);
                  }
                  if (qword_1000EBD00) {
                    int v25 = (FILE *)qword_1000EBD00;
                  }
                  else {
                    int v25 = __stderrp;
                  }
                  fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v25);
                }
                *__error() = v13;
              }
              [v2 removeObject:v8];
            }
            else
            {
              block[0] = _NSConcreteStackBlock;
              block[1] = 3221225472;
              block[2] = sub_10006E654;
              block[3] = &unk_1000DDB90;
              int v35 = v9;
              if (qword_1000EBCA8 != -1) {
                dispatch_once(&qword_1000EBCA8, block);
              }
            }
          }
          else
          {
            if (v5)
            {
              stackshot_int buffer = stackshot_config_get_stackshot_buffer();
              [v5 appendBytes:stackshot_buffer length:stackshot_config_get_stackshot_size()];
            }
            else
            {
              id v22 = objc_alloc((Class)NSMutableData);
              uint64_t v23 = stackshot_config_get_stackshot_buffer();
              id v5 = [v22 initWithBytes:v23 length:stackshot_config_get_stackshot_size()];
            }
            stackshot_config_dealloc_buffer();
          }
          id v7 = (char *)v7 + 1;
        }
        while (v4 != v7);
        id v27 = [v2 countByEnumeratingWithState:&v36 objects:v44 count:16];
        id v4 = v27;
      }
      while (v27);
      return v5;
    }
    return 0;
  }
  stackshot_config_set_pid();
  int v28 = stackshot_capture_with_config();
  if (v28)
  {
    v40[0] = _NSConcreteStackBlock;
    v40[1] = 3221225472;
    v40[2] = sub_10006E490;
    v40[3] = &unk_1000DDB90;
    int v41 = v28;
    if (qword_1000EBCA0 == -1) {
      return 0;
    }
    dispatch_once(&qword_1000EBCA0, v40);
    return 0;
  }
  id v29 = objc_alloc((Class)NSData);
  uint64_t v30 = stackshot_config_get_stackshot_buffer();
  uint64_t stackshot_size = stackshot_config_get_stackshot_size();

  return [v29 initWithBytesNoCopy:v30 length:stackshot_size freeWhenDone:0];
}

int *sub_10006E490(int *result)
{
  uint64_t v1 = result;
  if (byte_1000EBCF8)
  {
    int v2 = *__error();
    id v3 = sub_10002E548();
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR)) {
      sub_100098390();
    }
    id result = __error();
    _DWORD *result = v2;
  }
  if (byte_1000EBCF9) {
    BOOL v4 = dword_1000EB4A8 <= 3;
  }
  else {
    BOOL v4 = 0;
  }
  if (v4)
  {
    int v5 = *__error();
    CFStringRef v6 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"Stackshot failed: %d", v1[8]);
    if (v6)
    {
      CFStringRef v7 = v6;
      CStringPtr = CFStringGetCStringPtr(v6, 0x8000100u);
      if (CStringPtr)
      {
        int v9 = (char *)CStringPtr;
        int v10 = 0;
      }
      else
      {
        int v9 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x1EA7E9DEuLL);
        CFStringGetCString(v7, v9, 1024, 0x8000100u);
        int v10 = v9;
      }
      if (qword_1000EBD00) {
        int v13 = (FILE *)qword_1000EBD00;
      }
      else {
        int v13 = __stderrp;
      }
      fprintf(v13, "%s\n", v9);
      if (v10) {
        free(v10);
      }
      CFRelease(v7);
    }
    else
    {
      char v11 = sub_10002E548();
      if (os_log_type_enabled(v11, OS_LOG_TYPE_FAULT)) {
        sub_100098324();
      }
      if (qword_1000EBD00) {
        BOOL v12 = (FILE *)qword_1000EBD00;
      }
      else {
        BOOL v12 = __stderrp;
      }
      fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v12);
    }
    id result = __error();
    _DWORD *result = v5;
  }
  return result;
}

int *sub_10006E654(int *result)
{
  uint64_t v1 = result;
  if (byte_1000EBCF8)
  {
    int v2 = *__error();
    id v3 = sub_10002E548();
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR)) {
      sub_100098390();
    }
    id result = __error();
    _DWORD *result = v2;
  }
  if (byte_1000EBCF9) {
    BOOL v4 = dword_1000EB4A8 <= 3;
  }
  else {
    BOOL v4 = 0;
  }
  if (v4)
  {
    int v5 = *__error();
    CFStringRef v6 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"Stackshot failed: %d", v1[8]);
    if (v6)
    {
      CFStringRef v7 = v6;
      CStringPtr = CFStringGetCStringPtr(v6, 0x8000100u);
      if (CStringPtr)
      {
        int v9 = (char *)CStringPtr;
        int v10 = 0;
      }
      else
      {
        int v9 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x1EAC331uLL);
        CFStringGetCString(v7, v9, 1024, 0x8000100u);
        int v10 = v9;
      }
      if (qword_1000EBD00) {
        int v13 = (FILE *)qword_1000EBD00;
      }
      else {
        int v13 = __stderrp;
      }
      fprintf(v13, "%s\n", v9);
      if (v10) {
        free(v10);
      }
      CFRelease(v7);
    }
    else
    {
      char v11 = sub_10002E548();
      if (os_log_type_enabled(v11, OS_LOG_TYPE_FAULT)) {
        sub_100098324();
      }
      if (qword_1000EBD00) {
        BOOL v12 = (FILE *)qword_1000EBD00;
      }
      else {
        BOOL v12 = __stderrp;
      }
      fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v12);
    }
    id result = __error();
    _DWORD *result = v5;
  }
  return result;
}

void sub_10006F4C0(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_10006F538(uint64_t a1)
{
  integer_t policy_info = 0;
  int v2 = pthread_self();
  thread_act_t v3 = pthread_mach_thread_np(v2);
  if (thread_policy_set(v3, 1u, &policy_info, 1u))
  {
    int v82 = *__error();
    unsigned int v83 = sub_10002E548();
    if (os_log_type_enabled(v83, OS_LOG_TYPE_FAULT)) {
      sub_1000988B4();
    }
    *__error() = v82;
    if (byte_1000EBCF9 && dword_1000EB4A8 <= 4)
    {
      int v84 = *__error();
      CFStringRef v85 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"failed to set the sampling thread to a fixed-priority policy");
      CFStringRef v86 = v85;
      if (v85)
      {
        CStringPtr = (char *)CFStringGetCStringPtr(v85, 0x8000100u);
        if (CStringPtr)
        {
          int v88 = 0;
        }
        else
        {
          CStringPtr = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xA0579F5AuLL);
          CFStringGetCString(v86, CStringPtr, 1024, 0x8000100u);
          int v88 = CStringPtr;
        }
        if (qword_1000EBD00) {
          malloc_type_id_t v107 = (FILE *)qword_1000EBD00;
        }
        else {
          malloc_type_id_t v107 = __stderrp;
        }
        fprintf(v107, "%s\n", CStringPtr);
        if (v88) {
          free(v88);
        }
        CFRelease(v86);
      }
      else
      {
        double v98 = sub_10002E548();
        if (os_log_type_enabled(v98, OS_LOG_TYPE_FAULT)) {
          sub_100098880();
        }
        if (qword_1000EBD00) {
          double v99 = (FILE *)qword_1000EBD00;
        }
        else {
          double v99 = __stderrp;
        }
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v99);
      }
      *__error() = v84;
    }
  }
  integer_t v132 = 63;
  BOOL v4 = pthread_self();
  thread_act_t v5 = pthread_mach_thread_np(v4);
  if (thread_policy_set(v5, 3u, &v132, 1u))
  {
    int v89 = *__error();
    id v90 = sub_10002E548();
    if (os_log_type_enabled(v90, OS_LOG_TYPE_FAULT)) {
      sub_10009884C();
    }
    *__error() = v89;
    if (byte_1000EBCF9 && dword_1000EB4A8 <= 4)
    {
      int v91 = *__error();
      CFStringRef v92 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"failed to set sampling thread's priority");
      CFStringRef v93 = v92;
      if (v92)
      {
        double v94 = (char *)CFStringGetCStringPtr(v92, 0x8000100u);
        if (v94)
        {
          CFStringRef v95 = 0;
        }
        else
        {
          double v94 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x729B46B9uLL);
          CFStringGetCString(v93, v94, 1024, 0x8000100u);
          CFStringRef v95 = v94;
        }
        if (qword_1000EBD00) {
          int v108 = (FILE *)qword_1000EBD00;
        }
        else {
          int v108 = __stderrp;
        }
        fprintf(v108, "%s\n", v94);
        if (v95) {
          free(v95);
        }
        CFRelease(v93);
      }
      else
      {
        id v100 = sub_10002E548();
        if (os_log_type_enabled(v100, OS_LOG_TYPE_FAULT)) {
          sub_100098818();
        }
        if (qword_1000EBD00) {
          id v101 = (FILE *)qword_1000EBD00;
        }
        else {
          id v101 = __stderrp;
        }
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v101);
      }
      *__error() = v91;
    }
  }
  dispatch_semaphore_t v6 = 0;
  uint64_t v128 = 0;
  CFStringRef v129 = &v128;
  uint64_t v130 = 0x2020000000;
  uint64_t v131 = 0;
  if (!(byte_1000EBD50 | byte_1000EBD51)) {
    dispatch_semaphore_t v6 = dispatch_semaphore_create(0);
  }
  dsema = v6;
  group = dispatch_group_create();
  int v7 = byte_1000EBD51;
  if (byte_1000EBD51) {
    dispatch_suspend(*(dispatch_object_t *)(a1 + 24));
  }
  uint64_t v124 = 0;
  int v125 = &v124;
  uint64_t v126 = 0x2020000000;
  uint64_t v127 = 0;
  dispatch_time_t v8 = dispatch_time(0, 0);
  SAMachAbsTimeSecondsGetCurrent();
  double v10 = v9;
  int v109 = v7;
  [*(id *)(a1 + 8) startingSamplingLiveSystem];
  unsigned __int8 v115 = 0;
  id v114 = 0;
  uint64_t v11 = 0;
  do
  {
    if ((byte_1000EBD0C & 2) != 0 && sub_10002411C())
    {
      ++*(_DWORD *)(a1 + 88);
      goto LABEL_113;
    }
    ++*(_DWORD *)(a1 + 84);
    if (dispatch_semaphore_wait(*(dispatch_semaphore_t *)(a1 + 112), 0))
    {
      if (byte_1000EBCF8)
      {
        int v13 = *__error();
        CFStringRef v14 = sub_10002E548();
        if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR)) {
          sub_1000987E8(&v122, v123);
        }
        *__error() = v13;
      }
      if (byte_1000EBCF9) {
        BOOL v15 = dword_1000EB4A8 <= 3;
      }
      else {
        BOOL v15 = 0;
      }
      if (v15)
      {
        int v17 = *__error();
        CFStringRef v18 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"Unable to update sampling pid list");
        CFStringRef v19 = v18;
        if (v18)
        {
          int v20 = (char *)CFStringGetCStringPtr(v18, 0x8000100u);
          if (v20)
          {
            int v21 = 0;
          }
          else
          {
            int v20 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x8800F6EBuLL);
            CFStringGetCString(v19, v20, 1024, 0x8000100u);
            int v21 = v20;
          }
          if (qword_1000EBD00) {
            id v24 = (FILE *)qword_1000EBD00;
          }
          else {
            id v24 = __stderrp;
          }
          fprintf(v24, "%s\n", v20);
          if (v21) {
            free(v21);
          }
          CFRelease(v19);
        }
        else
        {
          id v22 = sub_10002E548();
          if (os_log_type_enabled(v22, OS_LOG_TYPE_FAULT)) {
            sub_1000987B0(&v120, v121);
          }
          if (qword_1000EBD00) {
            uint64_t v23 = (FILE *)qword_1000EBD00;
          }
          else {
            uint64_t v23 = __stderrp;
          }
          fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v23);
        }
        BOOL v16 = 0;
        *__error() = v17;
      }
      else
      {
        BOOL v16 = 0;
      }
    }
    else
    {
      BOOL v16 = *(unsigned char *)(a1 + 104) != 0;
      if (*(unsigned char *)(a1 + 104))
      {
        *(unsigned char *)(a1 + 104) = 0;

        id v114 = [*(id *)(a1 + 96) mutableCopy];
      }
      dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 112));
    }
    uint64_t v25 = v125[3];
    if (v25) {
      v125[3] = 0;
    }
    else {
      uint64_t v25 = stackshot_config_create();
    }
    if (v11) {
      int v26 = v16;
    }
    else {
      int v26 = 1;
    }
    if (v26 == 1)
    {
      stackshot_config_set_flags();
      stackshot_config_set_delta_timestamp();
    }
    else
    {
      stackshot_config_set_flags();
      stackshot_config_set_delta_timestamp();
      if (dword_1000EBCD0)
      {
        uint64_t v27 = (((double)dword_1000EBCD0 * 1.2) + 0x3FFFF) & 0xFFFC0000;
        stackshot_config_set_size_hint();
        goto LABEL_52;
      }
    }
    uint64_t v27 = 0;
LABEL_52:
    uint64_t v11 = mach_absolute_time();
    id v28 = sub_10006DF74(v25, v114);
    if (v28)
    {
      SASecondsFromMachTimeUsingLiveTimebase();
      uint64_t v30 = v29;
      if ((unint64_t)[v28 length] >= 0xFFFFFFFF)
      {
        if (byte_1000EBCF8)
        {
          int v80 = *__error();
          CFStringRef v81 = sub_10002E548();
          if (os_log_type_enabled(v81, OS_LOG_TYPE_ERROR)) {
            sub_100098760(buf, (uint64_t)[v28 length]);
          }
          *__error() = v80;
        }
        if (byte_1000EBCF9 && dword_1000EB4A8 <= 3)
        {
          int v75 = *__error();
          CFStringRef v76 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%s: bad stackshot data length %lu", "stackshotData.length < 4294967295U", [v28 length]);
          CFStringRef v77 = v76;
          if (v76)
          {
            CFStringRef v96 = (char *)CFStringGetCStringPtr(v76, 0x8000100u);
            if (v96)
            {
              double v97 = 0;
            }
            else
            {
              CFStringRef v96 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xC6745CE3uLL);
              CFStringGetCString(v77, v96, 1024, 0x8000100u);
              double v97 = v96;
            }
            if (qword_1000EBD00) {
              int v102 = (FILE *)qword_1000EBD00;
            }
            else {
              int v102 = __stderrp;
            }
            fprintf(v102, "%s\n", v96);
            if (v97) {
              free(v97);
            }
            CFRelease(v77);
          }
          else
          {
            uint64_t v78 = sub_10002E548();
            if (os_log_type_enabled(v78, OS_LOG_TYPE_FAULT)) {
              sub_10009871C(v134, (uint64_t)[v28 length]);
            }
            if (qword_1000EBD00) {
              CFStringRef v79 = (FILE *)qword_1000EBD00;
            }
            else {
              CFStringRef v79 = __stderrp;
            }
            fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v79);
          }
          *__error() = v75;
        }
        [v28 length];
        sub_10002E41C("_SamplingThread", "SPSampleProvider.m", 270, "%s: bad stackshot data length %lu", v103, v104, v105, v106, (char)"stackshotData.length < 4294967295U");
        abort();
      }
      id v31 = [v28 length];
      id v32 = v31;
      if ((v26 & 1) == 0)
      {
        if (v27 && v27 < v31)
        {
          if (byte_1000EBCF8)
          {
            int v33 = *__error();
            CFStringRef v34 = sub_10002E548();
            if (os_log_type_enabled(v34, OS_LOG_TYPE_DEBUG))
            {
              *(_DWORD *)buf = 67109632;
              int v136 = dword_1000EBCD0;
              __int16 v137 = 1024;
              *(_DWORD *)uint64_t v138 = v27;
              *(_WORD *)&v138[4] = 1024;
              *(_DWORD *)&v138[6] = v32;
              _os_log_debug_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_DEBUG, "Hint too small (previous %d, hint %d, actual %d)", buf, 0x14u);
            }
            *__error() = v33;
          }
          if (byte_1000EBCF9 && dword_1000EB4A8 <= 0)
          {
            int v111 = *__error();
            CFStringRef v35 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"Hint too small (previous %d, hint %d, actual %d)", dword_1000EBCD0, v27, v32);
            CFStringRef v36 = v35;
            if (v35)
            {
              long long v37 = (char *)CFStringGetCStringPtr(v35, 0x8000100u);
              if (v37)
              {
                long long v38 = 0;
              }
              else
              {
                long long v37 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xF03250C4uLL);
                CFStringGetCString(v36, v37, 1024, 0x8000100u);
                long long v38 = v37;
              }
              if (qword_1000EBD00) {
                int v41 = (FILE *)qword_1000EBD00;
              }
              else {
                int v41 = __stderrp;
              }
              fprintf(v41, "%s\n", v37);
              if (v38) {
                free(v38);
              }
              CFRelease(v36);
            }
            else
            {
              long long v39 = sub_10002E548();
              if (os_log_type_enabled(v39, OS_LOG_TYPE_FAULT))
              {
                *(_DWORD *)buf = 67109632;
                int v136 = dword_1000EBCD0;
                __int16 v137 = 1024;
                *(_DWORD *)uint64_t v138 = v27;
                *(_WORD *)&v138[4] = 1024;
                *(_DWORD *)&v138[6] = v32;
                _os_log_fault_impl((void *)&_mh_execute_header, v39, OS_LOG_TYPE_FAULT, "Unable to format: Hint too small (previous %d, hint %d, actual %d)", buf, 0x14u);
              }
              if (qword_1000EBD00) {
                uint64_t v40 = (FILE *)qword_1000EBD00;
              }
              else {
                uint64_t v40 = __stderrp;
              }
              fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v40);
            }
            *__error() = v111;
          }
        }
        if (dword_1000EBCD0 < v32) {
          dword_1000EBCD0 = (int)v32;
        }
      }
      if (dsema) {
        v115 |= (uint64_t)(atomic_fetch_add_explicit(v129 + 3, v32, memory_order_relaxed)
      }
                        + v32) > 20971519;
      dispatch_queue_global_t global_queue = dispatch_get_global_queue(25, 0);
      block[0] = _NSConcreteStackBlock;
      block[1] = 3221225472;
      block[2] = sub_100073A1C;
      block[3] = &unk_1000DDC78;
      void block[6] = v30;
      void block[4] = a1;
      void block[5] = group;
      dispatch_async(global_queue, block);
      if (qword_1000EBCE0 != -1) {
        dispatch_once(&qword_1000EBCE0, &stru_1000DDC98);
      }
      if (qword_1000EBCD8)
      {
        id v43 = [v28 bytes];
        id v44 = [v28 length];
        if (fwrite(v43, (size_t)v44, 1uLL, (FILE *)qword_1000EBCD8) != 1)
        {
          if (byte_1000EBCF8)
          {
            int v45 = *__error();
            int v46 = sub_10002E548();
            if (os_log_type_enabled(v46, OS_LOG_TYPE_ERROR))
            {
              int v60 = ferror((FILE *)qword_1000EBCD8);
              CFStringRef v61 = strerror(v60);
              *(_DWORD *)buf = 67109378;
              int v136 = v60;
              __int16 v137 = 2080;
              *(void *)uint64_t v138 = v61;
              _os_log_error_impl((void *)&_mh_execute_header, v46, OS_LOG_TYPE_ERROR, "Unable to write stackshot: %d (%s)", buf, 0x12u);
            }
            *__error() = v45;
          }
          if (byte_1000EBCF9 && dword_1000EB4A8 <= 3)
          {
            int v112 = *__error();
            uint64_t v47 = ferror((FILE *)qword_1000EBCD8);
            CFStringRef v48 = strerror(v47);
            CFStringRef v49 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"Unable to write stackshot: %d (%s)", v47, v48);
            CFStringRef v50 = v49;
            if (v49)
            {
              CFStringRef v51 = (char *)CFStringGetCStringPtr(v49, 0x8000100u);
              if (v51)
              {
                uint64_t v52 = 0;
              }
              else
              {
                CFStringRef v51 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x1704688FuLL);
                CFStringGetCString(v50, v51, 1024, 0x8000100u);
                uint64_t v52 = v51;
              }
              if (qword_1000EBD00) {
                int v55 = (FILE *)qword_1000EBD00;
              }
              else {
                int v55 = __stderrp;
              }
              fprintf(v55, "%s\n", v51);
              if (v52) {
                free(v52);
              }
              CFRelease(v50);
            }
            else
            {
              uint64_t v53 = sub_10002E548();
              if (os_log_type_enabled(v53, OS_LOG_TYPE_FAULT))
              {
                int v62 = ferror((FILE *)qword_1000EBCD8);
                CFStringRef v63 = strerror(v62);
                *(_DWORD *)buf = 67109378;
                int v136 = v62;
                __int16 v137 = 2080;
                *(void *)uint64_t v138 = v63;
                _os_log_fault_impl((void *)&_mh_execute_header, v53, OS_LOG_TYPE_FAULT, "Unable to format: Unable to write stackshot: %d (%s)", buf, 0x12u);
              }
              if (qword_1000EBD00) {
                uint64_t v54 = (FILE *)qword_1000EBD00;
              }
              else {
                uint64_t v54 = __stderrp;
              }
              fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v54);
            }
            *__error() = v112;
          }
          fclose((FILE *)qword_1000EBCD8);
          qword_1000EBCD8 = 0;
        }
      }
      double v56 = *(NSObject **)(a1 + 24);
      v117[0] = _NSConcreteStackBlock;
      v117[1] = 3221225472;
      v117[2] = sub_100074050;
      v117[3] = &unk_1000DDCC0;
      v117[4] = a1;
      v117[5] = v28;
      v117[7] = &v124;
      v117[6] = dsema;
      int v118 = (int)v32;
      v117[8] = &v128;
      v117[9] = v25;
      dispatch_group_async(group, v56, v117);
    }
LABEL_113:
    if (((dsema != 0) & v115) == 1)
    {
      if (qword_1000EBCE8 != -1) {
        dispatch_once(&qword_1000EBCE8, &stru_1000DDCE0);
      }
      dispatch_semaphore_wait(dsema, 0xFFFFFFFFFFFFFFFFLL);
      unsigned __int8 v115 = 0;
    }
    SAMachAbsTimeSecondsGetCurrent();
    double v58 = v57;
    unsigned int v59 = *(_DWORD *)(a1 + 64);
    double v10 = v10 + (double)v59 / 1000000.0;
    if (v10 <= v57)
    {
      dispatch_time_t v8 = dispatch_time(0, 0);
      double v10 = v58;
    }
    else
    {
      dispatch_time_t v8 = dispatch_time(v8, 1000 * v59);
    }
  }
  while (dispatch_semaphore_wait(*(dispatch_semaphore_t *)(a1 + 48), v8));
  [*(id *)(a1 + 8) finishedSamplingLiveSystem];

  if (v109)
  {
    if (qword_1000EBD58 && dispatch_group_wait((dispatch_group_t)qword_1000EBD58, 0))
    {
      if (byte_1000EBCF8)
      {
        int v64 = *__error();
        int v65 = sub_10002E548();
        if (os_log_type_enabled(v65, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v65, OS_LOG_TYPE_DEFAULT, "Sampling completed, waiting for SIGINFO...", buf, 2u);
        }
        *__error() = v64;
      }
      if (byte_1000EBCF9 && dword_1000EB4A8 <= 2)
      {
        int v66 = *__error();
        CFStringRef v67 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"Sampling completed, waiting for SIGINFO...");
        CFStringRef v68 = v67;
        if (v67)
        {
          uint64_t v69 = (char *)CFStringGetCStringPtr(v67, 0x8000100u);
          if (v69)
          {
            int v70 = 0;
          }
          else
          {
            uint64_t v69 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x5EB25A47uLL);
            CFStringGetCString(v68, v69, 1024, 0x8000100u);
            int v70 = v69;
          }
          if (qword_1000EBD00) {
            CFStringRef v73 = (FILE *)qword_1000EBD00;
          }
          else {
            CFStringRef v73 = __stderrp;
          }
          fprintf(v73, "%s\n", v69);
          if (v70) {
            free(v70);
          }
          CFRelease(v68);
        }
        else
        {
          uint64_t v71 = sub_10002E548();
          if (os_log_type_enabled(v71, OS_LOG_TYPE_FAULT)) {
            sub_1000986E8();
          }
          if (qword_1000EBD00) {
            CFStringRef v72 = (FILE *)qword_1000EBD00;
          }
          else {
            CFStringRef v72 = __stderrp;
          }
          fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v72);
        }
        *__error() = v66;
      }
      dispatch_group_wait((dispatch_group_t)qword_1000EBD58, 0xFFFFFFFFFFFFFFFFLL);
    }
    dispatch_resume(*(dispatch_object_t *)(a1 + 24));
  }
  dispatch_group_wait(group, 0xFFFFFFFFFFFFFFFFLL);
  if (v125[3]) {
    stackshot_config_dealloc();
  }
  if (dsema) {
    dispatch_release(dsema);
  }
  dispatch_release(group);
  _Block_object_dispose(&v124, 8);
  _Block_object_dispose(&v128, 8);
  return 0;
}

void sub_1000707D8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,char a50)
{
  _Block_object_dispose(&a50, 8);
  _Block_object_dispose((const void *)(v50 - 248), 8);
  _Unwind_Resume(a1);
}

void sub_100071160(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_100071244(id a1)
{
  uint64_t v1 = dispatch_queue_attr_make_with_autorelease_frequency(0, DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM);
  qword_1000EBCB8 = (uint64_t)dispatch_queue_create("com.apple.spindump.sample_provider_singleton", v1);

  dispatch_release(v1);
}

void sub_1000713B4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1000713CC(uint64_t a1, uint64_t a2)
{
}

void sub_1000713DC(uint64_t a1)
{
}

void sub_1000713E8(uint64_t a1)
{
  int v2 = dword_1000EBCC0;
  if (!dword_1000EBCC0)
  {
    qword_1000EBCC8 = objc_alloc_init(SPStackshotProvider);
    int v2 = dword_1000EBCC0;
  }
  dword_1000EBCC0 = v2 + 1;
  id v3 = +[SATimestamp timestamp];
  uint64_t v4 = *(unsigned int *)(qword_1000EBCC8 + 84);
  uint64_t v5 = *(unsigned int *)(qword_1000EBCC8 + 88);
  if ([(id)qword_1000EBCC8 startWithSamplingIntervalUs:*(unsigned int *)(a1 + 48) andOccasionalDataIntervalSec:*(unsigned int *)(a1 + 52) andOnlySampleProcesses:*(void *)(a1 + 32) andOnlySampleMainThreads:*(unsigned __int8 *)(a1 + 56) andOmitSensitiveStrings:*(unsigned __int8 *)(a1 + 57)])
  {
    dispatch_semaphore_t v6 = [SPStackshotProviderSnapshot alloc];
    *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 40) = [(SPStackshotProviderSnapshot *)v6 initWithStackshotProvider:qword_1000EBCC8 timestamp:v3 numSamples:v4 numSamplesAvoidedDueToAudio:v5];
  }
  else
  {
    *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 40) = 0;
    if (!--dword_1000EBCC0)
    {
      int v7 = *__error();
      dispatch_time_t v8 = sub_10002E548();
      if (os_log_type_enabled(v8, OS_LOG_TYPE_FAULT)) {
        sub_100098A20();
      }
      *__error() = v7;
      if (byte_1000EBCF9 && dword_1000EB4A8 <= 4)
      {
        int v9 = *__error();
        CFStringRef v10 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"shared instance has 0 references");
        if (v10)
        {
          CFStringRef v11 = v10;
          CStringPtr = CFStringGetCStringPtr(v10, 0x8000100u);
          if (CStringPtr)
          {
            int v13 = (char *)CStringPtr;
            CFStringRef v14 = 0;
          }
          else
          {
            int v13 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xAA0D9545uLL);
            CFStringGetCString(v11, v13, 1024, 0x8000100u);
            CFStringRef v14 = v13;
          }
          if (qword_1000EBD00) {
            int v17 = (FILE *)qword_1000EBD00;
          }
          else {
            int v17 = __stderrp;
          }
          fprintf(v17, "%s\n", v13);
          if (v14) {
            free(v14);
          }
          CFRelease(v11);
        }
        else
        {
          BOOL v15 = sub_10002E548();
          if (os_log_type_enabled(v15, OS_LOG_TYPE_FAULT)) {
            sub_1000989EC();
          }
          if (qword_1000EBD00) {
            BOOL v16 = (FILE *)qword_1000EBD00;
          }
          else {
            BOOL v16 = __stderrp;
          }
          fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v16);
        }
        *__error() = v9;
      }

      qword_1000EBCC8 = 0;
    }
  }
}

void sub_100071E7C(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_100072F90(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_1000730A0(uint64_t a1, double a2, double a3, double a4, double a5)
{
  double v5 = *(double *)(a1 + 40);
  uint64_t v6 = *(void *)(a1 + 32);
  double v7 = *(double *)(v6 + 56);
  if (v5 + -1.0 > v7)
  {
    LODWORD(a5) = *(_DWORD *)(v6 + 68);
    if (v5 + 1.0 < v7 + (double)*(unint64_t *)&a5)
    {
      *(double *)(v6 + 56) = v5;
      id v9 = +[SAAuxiliaryData auxiliaryDataForTimestamp:0];
      uint64_t v10 = *(void *)(a1 + 32);
      CFStringRef v11 = *(NSObject **)(v10 + 24);
      v12[0] = _NSConcreteStackBlock;
      v12[1] = 3221225472;
      v12[2] = sub_100073170;
      v12[3] = &unk_1000DDC00;
      v12[4] = v10;
      v12[5] = v9;
      dispatch_async(v11, v12);
    }
  }
}

id sub_100073170(uint64_t a1)
{
  return [*(id *)(*(void *)(a1 + 32) + 8) addAuxiliaryData:*(void *)(a1 + 40)];
}

void sub_10007334C(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_100073364(uint64_t a1)
{
  if (qword_1000EBCC8 == *(void *)(a1 + 32))
  {
    if (--dword_1000EBCC0)
    {
      if (byte_1000EBCF8)
      {
        int v1 = *__error();
        int v2 = sub_10002E548();
        if (os_log_type_enabled(v2, OS_LOG_TYPE_DEBUG)) {
          sub_100098F40();
        }
        *__error() = v1;
      }
      if (byte_1000EBCF9) {
        BOOL v3 = dword_1000EB4A8 <= 0;
      }
      else {
        BOOL v3 = 0;
      }
      if (!v3) {
        return;
      }
      int v4 = *__error();
      CFStringRef v5 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"Stackshot provider shared instance not yet done");
      if (v5)
      {
        CFStringRef v6 = v5;
        CStringPtr = CFStringGetCStringPtr(v5, 0x8000100u);
        if (!CStringPtr)
        {
          malloc_type_id_t v8 = 3084941988;
LABEL_36:
          int v13 = (char *)malloc_type_calloc(0x400uLL, 1uLL, v8);
          CFStringGetCString(v6, v13, 1024, 0x8000100u);
          CFStringRef v14 = v13;
          goto LABEL_37;
        }
        goto LABEL_26;
      }
      BOOL v15 = sub_10002E548();
      if (os_log_type_enabled(v15, OS_LOG_TYPE_FAULT)) {
        sub_100098F0C();
      }
      goto LABEL_31;
    }

    qword_1000EBCC8 = 0;
    if (byte_1000EBCF8)
    {
      int v9 = *__error();
      uint64_t v10 = sub_10002E548();
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG)) {
        sub_100098ED8();
      }
      *__error() = v9;
    }
    if (byte_1000EBCF9) {
      BOOL v11 = dword_1000EB4A8 <= 0;
    }
    else {
      BOOL v11 = 0;
    }
    if (v11)
    {
      int v4 = *__error();
      CFStringRef v12 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"Stackshot provider shared instance done");
      if (v12)
      {
        CFStringRef v6 = v12;
        CStringPtr = CFStringGetCStringPtr(v12, 0x8000100u);
        if (!CStringPtr)
        {
          malloc_type_id_t v8 = 3990020178;
          goto LABEL_36;
        }
LABEL_26:
        int v13 = (char *)CStringPtr;
        CFStringRef v14 = 0;
LABEL_37:
        if (qword_1000EBD00) {
          CFStringRef v18 = (FILE *)qword_1000EBD00;
        }
        else {
          CFStringRef v18 = __stderrp;
        }
        fprintf(v18, "%s\n", v13);
        if (v14) {
          free(v14);
        }
        CFRelease(v6);
LABEL_43:
        *__error() = v4;
        return;
      }
      BOOL v16 = sub_10002E548();
      if (os_log_type_enabled(v16, OS_LOG_TYPE_FAULT)) {
        sub_100098EA4();
      }
LABEL_31:
      if (qword_1000EBD00) {
        int v17 = (FILE *)qword_1000EBD00;
      }
      else {
        int v17 = __stderrp;
      }
      fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v17);
      goto LABEL_43;
    }
  }
  else
  {
    int v19 = *__error();
    int v20 = sub_10002E548();
    if (os_log_type_enabled(v20, OS_LOG_TYPE_FAULT)) {
      sub_100098FA8();
    }
    *__error() = v19;
    if (byte_1000EBCF9) {
      BOOL v21 = dword_1000EB4A8 <= 4;
    }
    else {
      BOOL v21 = 0;
    }
    if (v21)
    {
      int v4 = *__error();
      CFStringRef v22 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"shared instance isn't self");
      if (v22)
      {
        CFStringRef v6 = v22;
        CStringPtr = CFStringGetCStringPtr(v22, 0x8000100u);
        if (!CStringPtr)
        {
          malloc_type_id_t v8 = 1307034781;
          goto LABEL_36;
        }
        goto LABEL_26;
      }
      uint64_t v23 = sub_10002E548();
      if (os_log_type_enabled(v23, OS_LOG_TYPE_FAULT)) {
        sub_100098F74();
      }
      goto LABEL_31;
    }
  }
}

uint64_t sub_1000736DC(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

void sub_1000736F0(uint64_t a1)
{
  [*(id *)(a1 + 32) machAbsTimeSeconds];
  if (v2 + -1.0 > *(double *)(*(void *)(a1 + 40) + 56))
  {
    [*(id *)(a1 + 32) machAbsTimeSeconds];
    *(void *)(*(void *)(a1 + 40) + 56) = v3;
    id v4 = +[SAAuxiliaryData auxiliaryDataForTimestamp:0];
    uint64_t v5 = *(void *)(a1 + 40);
    CFStringRef v6 = *(NSObject **)(v5 + 24);
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472;
    block[2] = sub_100073844;
    block[3] = &unk_1000DDC00;
    void block[4] = v5;
    void block[5] = v4;
    dispatch_async(v6, block);
  }
  double v7 = *(NSObject **)(a1 + 48);
  if (v7)
  {
    uint64_t v8 = *(void *)(a1 + 56);
    if (v8)
    {
      v11[0] = _NSConcreteStackBlock;
      v11[1] = 3221225472;
      v11[2] = sub_100073850;
      v11[3] = &unk_1000DDC28;
      uint64_t v10 = *(void *)(a1 + 32);
      uint64_t v9 = *(void *)(a1 + 40);
      v11[4] = v9;
      v11[5] = v10;
      v11[7] = *(void *)(a1 + 64);
      v11[6] = v8;
      if (*(unsigned char *)(a1 + 72)) {
        dispatch_group_notify(*(dispatch_group_t *)(v9 + 32), v7, v11);
      }
      else {
        dispatch_async(v7, v11);
      }
    }
  }
}

id sub_100073844(uint64_t a1)
{
  return [*(id *)(*(void *)(a1 + 32) + 8) addAuxiliaryData:*(void *)(a1 + 40)];
}

uint64_t sub_100073850(uint64_t a1)
{
  [[SPStackshotProviderSnapshot alloc] initWithStackshotProvider:*(void *)(a1 + 32) timestamp:*(void *)(a1 + 40) numSamples:*(unsigned int *)(a1 + 56) numSamplesAvoidedDueToAudio:*(unsigned int *)(a1 + 60)];
  double v2 = *(uint64_t (**)(void))(*(void *)(a1 + 48) + 16);

  return v2();
}

uint64_t sub_10007392C(uint64_t a1)
{
  return (*(uint64_t (**)(void, void))(*(void *)(a1 + 40) + 16))(*(void *)(a1 + 40), *(void *)(*(void *)(a1 + 32) + 8));
}

id sub_1000739BC(uint64_t a1)
{
  int v1 = *(void **)(*(void *)(a1 + 32) + 120);
  double v2 = +[NSNumber numberWithInt:*(unsigned int *)(a1 + 40)];

  return [v1 addObject:v2];
}

void sub_100073A1C(double *a1)
{
  uint64_t v1 = *((void *)a1 + 4);
  unsigned int v2 = *(_DWORD *)(v1 + 68);
  if (v2)
  {
    if (a1[6] > *(double *)(v1 + 56) + (double)v2)
    {
      *(double *)(*((void *)a1 + 4) + 56) = a1[6];
      id v5 = +[SAAuxiliaryData auxiliaryDataForTimestamp:0];
      uint64_t v7 = *((void *)a1 + 4);
      CFStringRef v6 = *((void *)a1 + 5);
      uint64_t v8 = *(NSObject **)(v7 + 24);
      v9[0] = _NSConcreteStackBlock;
      v9[1] = 3221225472;
      v9[2] = sub_100073AF0;
      v9[3] = &unk_1000DDC00;
      v9[4] = v7;
      void v9[5] = v5;
      dispatch_group_async(v6, v8, v9);
    }
  }
}

id sub_100073AF0(uint64_t a1)
{
  return [*(id *)(*(void *)(a1 + 32) + 8) addAuxiliaryData:*(void *)(a1 + 40)];
}

void sub_100073AFC(id a1)
{
  uint64_t v1 = getenv("SPINDUMP_SAVE_STACKSHOTS");
  if (v1 && strcmp(v1, "0"))
  {
    strcpy(__filename, "/var/mobile/stackshots.");
    memset(&v36, 0, sizeof(v36));
    time_t v35 = time(0);
    localtime_r(&v35, &v36);
    size_t v2 = strftime(&__filename[23], 0x3E9uLL, "%Y-%m-%d-%T", &v36);
    size_t v3 = v2 + 23;
    if (v2 + 23 >= 0x400)
    {
      size_t v34 = v2;
      int v23 = *__error();
      id v24 = sub_10002E548();
      if (os_log_type_enabled(v24, OS_LOG_TYPE_FAULT)) {
        sub_100099208();
      }
      *__error() = v23;
      size_t v2 = v34;
      if (byte_1000EBCF9 && dword_1000EB4A8 <= 4)
      {
        int v25 = *__error();
        CFStringRef v26 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"filePath %s cut off with date (needed %zu chars)", __filename, v3);
        if (v26)
        {
          CFStringRef v27 = v26;
          CStringPtr = CFStringGetCStringPtr(v26, 0x8000100u);
          if (CStringPtr)
          {
            uint64_t v29 = (char *)CStringPtr;
            uint64_t v30 = 0;
          }
          else
          {
            uint64_t v29 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x2F5E82CEuLL);
            CFStringGetCString(v27, v29, 1024, 0x8000100u);
            uint64_t v30 = v29;
          }
          if (qword_1000EBD00) {
            int v33 = (FILE *)qword_1000EBD00;
          }
          else {
            int v33 = __stderrp;
          }
          fprintf(v33, "%s\n", v29);
          if (v30) {
            free(v30);
          }
          CFRelease(v27);
        }
        else
        {
          id v31 = sub_10002E548();
          if (os_log_type_enabled(v31, OS_LOG_TYPE_FAULT)) {
            sub_10009919C();
          }
          if (qword_1000EBD00) {
            id v32 = (FILE *)qword_1000EBD00;
          }
          else {
            id v32 = __stderrp;
          }
          fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v32);
        }
        *__error() = v25;
        size_t v2 = v34;
      }
    }
    size_t v4 = 1001 - v2;
    pid_t v5 = getpid();
    snprintf(&__filename[v3], v4, ".%d.buf", v5);
    qword_1000EBCD8 = (uint64_t)fopen(__filename, "w");
    if (qword_1000EBCD8)
    {
      if (byte_1000EBCF8)
      {
        int v6 = *__error();
        uint64_t v7 = sub_10002E548();
        if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136315138;
          long long v38 = __filename;
          _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "Saving stackshots to %s", buf, 0xCu);
        }
        *__error() = v6;
      }
      if (byte_1000EBCF9 && dword_1000EB4A8 <= 2)
      {
        int v8 = *__error();
        CFStringRef v9 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"Saving stackshots to %s", __filename);
        if (!v9)
        {
          uint64_t v10 = sub_10002E548();
          if (os_log_type_enabled(v10, OS_LOG_TYPE_FAULT)) {
            sub_100099124((uint64_t)__filename, v10);
          }
LABEL_32:
          if (qword_1000EBD00) {
            CFStringRef v22 = (FILE *)qword_1000EBD00;
          }
          else {
            CFStringRef v22 = __stderrp;
          }
          fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v22);
LABEL_36:
          *__error() = v8;
          return;
        }
        goto LABEL_21;
      }
    }
    else
    {
      if (byte_1000EBCF8)
      {
        int v11 = *__error();
        CFStringRef v12 = sub_10002E548();
        if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR)) {
          sub_100099080((uint64_t)__filename, v12);
        }
        *__error() = v11;
      }
      if (byte_1000EBCF9 && dword_1000EB4A8 <= 3)
      {
        int v8 = *__error();
        uint64_t v13 = *__error();
        CFStringRef v14 = __error();
        BOOL v15 = strerror(*v14);
        CFStringRef v9 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"Unable to open %s to save stackshots: %d (%s)", __filename, v13, v15);
        if (!v9)
        {
          BOOL v21 = sub_10002E548();
          if (os_log_type_enabled(v21, OS_LOG_TYPE_FAULT)) {
            sub_100098FDC((uint64_t)__filename, v21);
          }
          goto LABEL_32;
        }
LABEL_21:
        CFStringRef v16 = v9;
        int v17 = CFStringGetCStringPtr(v9, 0x8000100u);
        if (v17)
        {
          CFStringRef v18 = (char *)v17;
          int v19 = 0;
        }
        else
        {
          CFStringRef v18 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x2F5E82CEuLL);
          CFStringGetCString(v16, v18, 1024, 0x8000100u);
          int v19 = v18;
        }
        if (qword_1000EBD00) {
          int v20 = (FILE *)qword_1000EBD00;
        }
        else {
          int v20 = __stderrp;
        }
        fprintf(v20, "%s\n", v18);
        if (v19) {
          free(v19);
        }
        CFRelease(v16);
        goto LABEL_36;
      }
    }
  }
}

intptr_t sub_100074050(uint64_t a1)
{
  [*(id *)(*(void *)(a1 + 32) + 8) addKCDataStackshots:*(void *)(a1 + 40) createSeparateSamplePerStackshot:0];
  long long v44 = 0u;
  long long v45 = 0u;
  long long v46 = 0u;
  long long v47 = 0u;
  size_t v2 = *(void **)(*(void *)(a1 + 32) + 120);
  id v3 = [v2 countByEnumeratingWithState:&v44 objects:v52 count:16];
  if (!v3) {
    goto LABEL_58;
  }
  id v4 = v3;
  uint64_t v5 = *(void *)v45;
  do
  {
    for (uint64_t i = 0; i != v4; uint64_t i = (char *)i + 1)
    {
      if (*(void *)v45 != v5) {
        objc_enumerationMutation(v2);
      }
      uint64_t v7 = *(void **)(*((void *)&v44 + 1) + 8 * i);
      if ((objc_msgSend(*(id *)(*(void *)(a1 + 32) + 8), "cacheLoadInfoForProcess:", objc_msgSend(v7, "intValue")) & 1) == 0)
      {
        if (([v7 intValue] & 0x80000000) != 0)
        {
          if (byte_1000EBCF8)
          {
            int v18 = *__error();
            int v19 = sub_10002E548();
            if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR)) {
              sub_1000992AC(&v42, v43);
            }
            *__error() = v18;
          }
          if (byte_1000EBCF9) {
            BOOL v20 = dword_1000EB4A8 <= 3;
          }
          else {
            BOOL v20 = 0;
          }
          if (v20)
          {
            int v11 = *__error();
            CFStringRef v21 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"Unable to cache load info");
            if (v21)
            {
              CFStringRef v22 = v21;
              CStringPtr = CFStringGetCStringPtr(v21, 0x8000100u);
              if (CStringPtr)
              {
                id v24 = (char *)CStringPtr;
                int v25 = 0;
              }
              else
              {
                id v24 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xB6C826B9uLL);
                CFStringGetCString(v22, v24, 1024, 0x8000100u);
                int v25 = v24;
              }
              if (qword_1000EBD00) {
                int v33 = (FILE *)qword_1000EBD00;
              }
              else {
                int v33 = __stderrp;
              }
              fprintf(v33, "%s\n", v24);
              if (v25) {
                free(v25);
              }
              CFStringRef v30 = v22;
LABEL_54:
              CFRelease(v30);
LABEL_55:
              *__error() = v11;
              continue;
            }
            id v31 = sub_10002E548();
            if (os_log_type_enabled(v31, OS_LOG_TYPE_FAULT)) {
              sub_100099274(&v40, v41);
            }
LABEL_43:
            if (qword_1000EBD00) {
              id v32 = (FILE *)qword_1000EBD00;
            }
            else {
              id v32 = __stderrp;
            }
            fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v32);
            goto LABEL_55;
          }
        }
        else
        {
          if (byte_1000EBCF8)
          {
            int v8 = *__error();
            CFStringRef v9 = sub_10002E548();
            if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
            {
              size_t v34 = sub_10002E4E8((int)[v7 intValue]);
              unsigned int v35 = [v7 intValue];
              *(_DWORD *)buf = 136446466;
              CFStringRef v49 = v34;
              __int16 v50 = 1024;
              unsigned int v51 = v35;
              _os_log_error_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "%{public}s [%d]: Unable to cache load info", buf, 0x12u);
            }
            *__error() = v8;
          }
          if (byte_1000EBCF9) {
            BOOL v10 = dword_1000EB4A8 <= 3;
          }
          else {
            BOOL v10 = 0;
          }
          if (v10)
          {
            int v11 = *__error();
            CFStringRef v12 = sub_10002E4E8((int)[v7 intValue]);
            CFStringRef v13 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%s [%d]: Unable to cache load info", v12, [v7 intValue]);
            if (v13)
            {
              CFStringRef v14 = v13;
              BOOL v15 = CFStringGetCStringPtr(v13, 0x8000100u);
              if (v15)
              {
                CFStringRef v16 = (char *)v15;
                int v17 = 0;
              }
              else
              {
                CFStringRef v16 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xB6C826B9uLL);
                CFStringGetCString(v14, v16, 1024, 0x8000100u);
                int v17 = v16;
              }
              if (qword_1000EBD00) {
                uint64_t v29 = (FILE *)qword_1000EBD00;
              }
              else {
                uint64_t v29 = __stderrp;
              }
              fprintf(v29, "%s\n", v16);
              if (v17) {
                free(v17);
              }
              CFStringRef v30 = v14;
              goto LABEL_54;
            }
            CFStringRef v26 = sub_10002E548();
            if (os_log_type_enabled(v26, OS_LOG_TYPE_FAULT))
            {
              CFStringRef v27 = sub_10002E4E8((int)[v7 intValue]);
              unsigned int v28 = [v7 intValue];
              *(_DWORD *)buf = 136315394;
              CFStringRef v49 = v27;
              __int16 v50 = 1024;
              unsigned int v51 = v28;
              _os_log_fault_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_FAULT, "Unable to format: %s [%d]: Unable to cache load info", buf, 0x12u);
            }
            goto LABEL_43;
          }
        }
      }
    }
    id v4 = [v2 countByEnumeratingWithState:&v44 objects:v52 count:16];
  }
  while (v4);
LABEL_58:
  [*(id *)(*(void *)(a1 + 32) + 120) removeAllObjects];

  if (*(void *)(*(void *)(*(void *)(a1 + 56) + 8) + 24))
  {
    intptr_t result = stackshot_config_dealloc();
  }
  else
  {
    intptr_t result = stackshot_config_dealloc_buffer();
    *(void *)(*(void *)(*(void *)(a1 + 56) + 8) + 24) = *(void *)(a1 + 72);
  }
  if (*(void *)(a1 + 48))
  {
    uint64_t v37 = *(unsigned int *)(a1 + 80);
    uint64_t v38 = atomic_fetch_add_explicit((atomic_ullong *volatile)(*(void *)(*(void *)(a1 + 64) + 8) + 24), -v37, memory_order_relaxed)- v37;
    if (v38 <= 20971519 && v38 + *(unsigned int *)(a1 + 80) >= 20971520) {
      return dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 48));
    }
  }
  return result;
}

void sub_1000745EC(id a1)
{
  if (byte_1000EBCF8)
  {
    int v1 = *__error();
    size_t v2 = sub_10002E548();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR)) {
      sub_100099310();
    }
    *__error() = v1;
  }
  if (byte_1000EBCF9) {
    BOOL v3 = dword_1000EB4A8 <= 3;
  }
  else {
    BOOL v3 = 0;
  }
  if (v3)
  {
    int v4 = *__error();
    CFStringRef v5 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"Unable to process samples fast enough, throttling sampling rate to avoid bloating memory. Use -noThrottle to avoid this.");
    if (v5)
    {
      CFStringRef v6 = v5;
      CStringPtr = CFStringGetCStringPtr(v5, 0x8000100u);
      if (CStringPtr)
      {
        int v8 = (char *)CStringPtr;
        CFStringRef v9 = 0;
      }
      else
      {
        int v8 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xA1741278uLL);
        CFStringGetCString(v6, v8, 1024, 0x8000100u);
        CFStringRef v9 = v8;
      }
      if (qword_1000EBD00) {
        CFStringRef v12 = (FILE *)qword_1000EBD00;
      }
      else {
        CFStringRef v12 = __stderrp;
      }
      fprintf(v12, "%s\n", v8);
      if (v9) {
        free(v9);
      }
      CFRelease(v6);
    }
    else
    {
      BOOL v10 = sub_10002E548();
      if (os_log_type_enabled(v10, OS_LOG_TYPE_FAULT)) {
        sub_1000992DC();
      }
      if (qword_1000EBD00) {
        int v11 = (FILE *)qword_1000EBD00;
      }
      else {
        int v11 = __stderrp;
      }
      fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v11);
    }
    *__error() = v4;
  }
}

uint64_t sub_10007479C(uint64_t result, uint64_t a2, int a3)
{
  *(void *)(a2 + 4) = v3;
  *(_WORD *)(a2 + 12) = 1024;
  *(_DWORD *)(a2 + 14) = a3;
  *(_WORD *)(a2 + 1_Block_object_dispose(&STACK[0x378], 8) = 2080;
  *(void *)(a2 + 20) = result;
  return result;
}

void sub_1000747BC(void *a1, int a2, os_log_t log, const char *a4, uint8_t *a5)
{
  _os_log_fault_impl(a1, log, OS_LOG_TYPE_FAULT, a4, a5, 0x16u);
}

void sub_1000747D8(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint8_t *a5)
{
  _os_log_error_impl(a1, a2, OS_LOG_TYPE_ERROR, a4, a5, 2u);
}

void sub_10007481C(uint64_t a1@<X8>)
{
  *(void *)(v1 - _Block_object_dispose(&STACK[0x378], 8) = a1;
}

uint64_t sub_100074828@<X0>(uint64_t result@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  *(void *)(result + 4) = a3;
  *(_WORD *)(result + 12) = 2048;
  *(void *)(result + 14) = a2;
  return result;
}

id sub_10007483C(uint64_t a1, void *a2)
{
  return [a2 intValue];
}

id *sub_10007524C(uint64_t a1, void *a2, char a3, void *a4, void *a5, void *a6, void *a7)
{
  CFStringRef v13 = (objc_class *)self;
  if (a4 && a7)
  {
    if (byte_1000EBCF8)
    {
      int v20 = *__error();
      CFStringRef v21 = sub_10002E548();
      if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR)) {
        sub_1000997C0(a4, a7);
      }
      *__error() = v20;
    }
    if (byte_1000EBCF9) {
      BOOL v22 = dword_1000EB4A8 <= 3;
    }
    else {
      BOOL v22 = 0;
    }
    if (v22)
    {
      int v23 = *__error();
      CFStringRef v24 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%s: bodies (%s) and angle bracket contents (%s)", "!(bodies && angleBracketContents)", [objc_msgSend(objc_msgSend(a4, "debugDescription"), "UTF8String") UTF8String], [objc_msgSend(objc_msgSend(a7, "debugDescription"), "UTF8String") UTF8String]);
      if (v24)
      {
        CFStringRef theString = v24;
        CStringPtr = CFStringGetCStringPtr(v24, 0x8000100u);
        if (CStringPtr)
        {
          unsigned int v35 = (char *)CStringPtr;
          tm v36 = 0;
        }
        else
        {
          unsigned int v35 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xB1C9ED6FuLL);
          CFStringGetCString(theString, v35, 1024, 0x8000100u);
          tm v36 = v35;
        }
        if (qword_1000EBD00) {
          int v41 = (FILE *)qword_1000EBD00;
        }
        else {
          int v41 = __stderrp;
        }
        fprintf(v41, "%s\n", v35);
        if (v36) {
          free(v36);
        }
        CFRelease(theString);
      }
      else
      {
        int v25 = sub_10002E548();
        if (os_log_type_enabled(v25, OS_LOG_TYPE_FAULT)) {
          sub_10009971C(a4, a7);
        }
        if (qword_1000EBD00) {
          CFStringRef v26 = (FILE *)qword_1000EBD00;
        }
        else {
          CFStringRef v26 = __stderrp;
        }
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v26);
      }
      *__error() = v23;
    }
    [objc_msgSend(a4, "debugDescription") UTF8String];
    [objc_msgSend(a7, "debugDescription") UTF8String];
    sub_10002E41C("+[SPTreeNode nodeWithParent:isKernel:bodies:address:stateInfo:angleBracketContents:]", "SPTextualReportParser.m", 69, "%s: bodies (%s) and angle bracket contents (%s)", v42, v43, v44, v45, (char)"!(bodies && angleBracketContents)");
LABEL_63:
    abort();
  }
  if (!a7 && !a6 && !a4)
  {
    if (byte_1000EBCF8)
    {
      int v27 = *__error();
      unsigned int v28 = sub_10002E548();
      if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR)) {
        sub_1000998E8(v28);
      }
      *__error() = v27;
    }
    if (byte_1000EBCF9) {
      BOOL v29 = dword_1000EB4A8 <= 3;
    }
    else {
      BOOL v29 = 0;
    }
    if (v29)
    {
      int v30 = *__error();
      CFStringRef v31 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%s: No frame bodies, state, nor angle bracket contents", "bodies || angleBracketContents || stateInfo");
      if (v31)
      {
        CFStringRef v37 = v31;
        uint64_t v38 = CFStringGetCStringPtr(v31, 0x8000100u);
        if (v38)
        {
          long long v39 = (char *)v38;
          char v40 = 0;
        }
        else
        {
          long long v39 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xA4170E1uLL);
          CFStringGetCString(v37, v39, 1024, 0x8000100u);
          char v40 = v39;
        }
        if (qword_1000EBD00) {
          long long v46 = (FILE *)qword_1000EBD00;
        }
        else {
          long long v46 = __stderrp;
        }
        fprintf(v46, "%s\n", v39);
        if (v40) {
          free(v40);
        }
        CFRelease(v37);
      }
      else
      {
        id v32 = sub_10002E548();
        if (os_log_type_enabled(v32, OS_LOG_TYPE_FAULT)) {
          sub_100099864(v32);
        }
        if (qword_1000EBD00) {
          int v33 = (FILE *)qword_1000EBD00;
        }
        else {
          int v33 = __stderrp;
        }
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v33);
      }
      *__error() = v30;
    }
    sub_10002E41C("+[SPTreeNode nodeWithParent:isKernel:bodies:address:stateInfo:angleBracketContents:]", "SPTextualReportParser.m", 70, "%s: No frame bodies, state, nor angle bracket contents", v14, v15, v16, v17, (char)"bodies || angleBracketContents || stateInfo");
    goto LABEL_63;
  }
  int v18 = (id *)objc_alloc_init(v13);
  objc_storeWeak(v18 + 7, a2);
  *((unsigned char *)v18 + _Block_object_dispose(&STACK[0x378], 8) = a3;
  v18[2] = [a4 copy];
  v18[4] = a5;
  v18[5] = [a6 copy];
  v18[3] = [a7 copy];

  return v18;
}

id *sub_100075720(uint64_t a1, int a2, void *a3, void *a4, void *a5, void *a6)
{
  if (!a1) {
    return 0;
  }
  int v11 = (id *)a1;
  CFStringRef v12 = *(void **)(a1 + 48);
  if (!v12)
  {
    *(void *)(a1 + 4_Block_object_dispose(&STACK[0x378], 8) = objc_alloc_init((Class)NSMutableArray);
    goto LABEL_13;
  }
  long long v22 = 0u;
  long long v23 = 0u;
  long long v20 = 0u;
  long long v21 = 0u;
  id v13 = [v12 countByEnumeratingWithState:&v20 objects:v24 count:16];
  if (!v13)
  {
LABEL_13:
    uint64_t v17 = sub_10007524C((uint64_t)SPTreeNode, v11, a2, a3, a4, a5, a6);
    [v11[6] addObject:v17];
    return v17;
  }
  id v14 = v13;
  uint64_t v15 = *(void *)v21;
  int v19 = v11;
LABEL_5:
  uint64_t v16 = 0;
  while (1)
  {
    if (*(void *)v21 != v15) {
      objc_enumerationMutation(v12);
    }
    uint64_t v17 = *(id **)(*((void *)&v20 + 1) + 8 * v16);
    if (sub_1000758AC((uint64_t)v17, a2, a3, (uint64_t)a4, (uint64_t)a5, (uint64_t)a6)) {
      return v17;
    }
    if (v14 == (id)++v16)
    {
      id v14 = [v12 countByEnumeratingWithState:&v20 objects:v24 count:16];
      int v11 = v19;
      if (v14) {
        goto LABEL_5;
      }
      goto LABEL_13;
    }
  }
}

uint64_t sub_1000758AC(uint64_t result, int a2, void *a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  if (result)
  {
    uint64_t v6 = result;
    if (*(unsigned __int8 *)(result + 8) == a2 && *(void *)(result + 32) == a4)
    {
      uint64_t v9 = *(void *)(result + 40);
      if (!(a5 | v9)
        || (intptr_t result = 0, a5)
        && v9
        && (intptr_t result = (uint64_t)[*(id *)(v6 + 40) isEqualToString:a5], result))
      {
        uint64_t v10 = *(void *)(v6 + 24);
        if (!(a6 | v10)
          || (intptr_t result = 0, a6)
          && v10
          && (intptr_t result = (uint64_t)[*(id *)(v6 + 24) isEqualToString:a6], result))
        {
          if (*(void *)(v6 + 32) == -1) {
            return 1;
          }
          unint64_t v11 = (unint64_t)[*(id *)(v6 + 16) firstObject];
          unint64_t v12 = (unint64_t)[a3 firstObject];
          if (!(v11 | v12)) {
            return 1;
          }
          unint64_t v13 = v12;
          intptr_t result = 0;
          if (v11)
          {
            if (v13)
            {
              intptr_t result = (uint64_t)[v11 isEqualToString:];
              if (result) {
                return 1;
              }
            }
          }
        }
      }
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t sub_100075A94(uint64_t result)
{
  if (result) {
    return *(unsigned int *)(result + 12);
  }
  return result;
}

uint64_t sub_100075AA0(uint64_t result, int a2)
{
  if (result) {
    *(_DWORD *)(result + 12) = a2;
  }
  return result;
}

uint64_t sub_100075AAC(uint64_t result)
{
  if (result) {
    return *(unsigned char *)(result + 8) & 1;
  }
  return result;
}

uint64_t sub_100075ABC(uint64_t result)
{
  if (result) {
    return *(void *)(result + 16);
  }
  return result;
}

uint64_t sub_100075AC8(uint64_t result)
{
  if (result) {
    return *(void *)(result + 24);
  }
  return result;
}

uint64_t sub_100075AD4(uint64_t result)
{
  if (result) {
    return *(void *)(result + 32);
  }
  return result;
}

uint64_t sub_100075AE0(uint64_t result)
{
  if (result) {
    return *(void *)(result + 40);
  }
  return result;
}

uint64_t sub_100075AEC(uint64_t result)
{
  if (result) {
    return *(void *)(result + 48);
  }
  return result;
}

id *sub_100075AF8(id *result)
{
  if (result) {
    return (id *)objc_loadWeak(result + 7);
  }
  return result;
}

void *sub_100075B10(void *a1, void *a2, char a3, uint64_t a4, uint64_t a5, void *a6, void *a7, void *a8, void *a9)
{
  if (!a1) {
    return 0;
  }
  v18.receiver = a1;
  v18.super_class = (Class)SPLoadInfo;
  uint64_t v16 = [super init];
  if (v16)
  {
    void v16[5] = a2;
    *((unsigned char *)v16 + 32) = a3;
    v16[7] = a4;
    v16[8] = a5;
    v16[1] = [a6 copy];
    v16[2] = [a7 copy];
    v16[3] = [a8 copy];
    v16[6] = [a9 copy];
  }
  return v16;
}

id *sub_100075CB0(id *result)
{
  if (result)
  {
    uint64_t v1 = result;
    intptr_t result = (id *)[result[5] bundleIdentifier];
    if (!result) {
      return (id *)v1[1];
    }
  }
  return result;
}

id *sub_100075CE8(id *result)
{
  if (result)
  {
    uint64_t v1 = result;
    intptr_t result = (id *)[result[5] name];
    if (!result) {
      return (id *)v1[2];
    }
  }
  return result;
}

void *sub_100075D20(uint64_t a1)
{
  if (!a1) {
    return 0;
  }
  uint64_t v2 = *(void **)(a1 + 24);
  if (!v2)
  {
    unint64_t v3 = (unint64_t)[*(id *)(a1 + 40) bundleVersion];
    id v4 = [*(id *)(a1 + 40) bundleShortVersion];
    id v5 = [*(id *)(a1 + 40) binaryVersion];
    unint64_t v6 = (unint64_t)v5;
    if (!v4 && !v3 && !v5) {
      return 0;
    }
    id v7 = +[NSMutableString string];
    uint64_t v2 = v7;
    if (v4)
    {
      [v7 appendString:v4];
      if (!(v3 | v6)) {
        return v2;
      }
      [v2 appendString:@" "];
    }
    if (v3 | v6)
    {
      if (v3) {
        unint64_t v8 = v3;
      }
      else {
        unint64_t v8 = v6;
      }
      [v2 appendFormat:@"(%@)", v8];
    }
  }
  return v2;
}

uint64_t sub_100075DFC(uint64_t result)
{
  if (result) {
    return *(unsigned char *)(result + 32) & 1;
  }
  return result;
}

uint64_t sub_100075E0C(uint64_t result)
{
  if (result) {
    return *(void *)(result + 56);
  }
  return result;
}

uint64_t sub_100075E18(uint64_t result)
{
  if (result) {
    return *(void *)(result + 64);
  }
  return result;
}

void sub_10007C104(_Unwind_Exception *a1)
{
}

void *sub_10007C53C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = a1 + 32;
  uint64_t v10 = *(void *)(*(void *)(a1 + 32) + 8);
  int v11 = *(_DWORD *)(v10 + 24);
  if (v11)
  {
    *(_DWORD *)(v10 + 24) = 2 * v11;
    int v12 = *(_DWORD *)(*(void *)(*(void *)v9 + 8) + 24);
    if (v12 <= 0)
    {
      if (byte_1000EBCF8)
      {
        int v13 = *__error();
        id v14 = sub_10002E548();
        if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR)) {
          sub_10009A30C();
        }
        *__error() = v13;
      }
      if (byte_1000EBCF9) {
        BOOL v15 = dword_1000EB4A8 <= 3;
      }
      else {
        BOOL v15 = 0;
      }
      if (v15)
      {
        int v16 = *__error();
        CFStringRef v17 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%s: bufSize overflow (%d)", "bufSize > 0", *(unsigned int *)(*(void *)(*(void *)v9 + 8) + 24));
        if (v17)
        {
          CFStringRef v36 = v17;
          CStringPtr = CFStringGetCStringPtr(v17, 0x8000100u);
          if (CStringPtr)
          {
            uint64_t v38 = (char *)CStringPtr;
            long long v39 = 0;
          }
          else
          {
            uint64_t v38 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x9B1926D1uLL);
            CFStringGetCString(v36, v38, 1024, 0x8000100u);
            long long v39 = v38;
          }
          if (qword_1000EBD00) {
            char v40 = (FILE *)qword_1000EBD00;
          }
          else {
            char v40 = __stderrp;
          }
          fprintf(v40, "%s\n", v38);
          if (v39) {
            free(v39);
          }
          CFRelease(v36);
        }
        else
        {
          objc_super v18 = sub_10002E548();
          if (os_log_type_enabled(v18, OS_LOG_TYPE_FAULT)) {
            sub_10009A294();
          }
          if (qword_1000EBD00) {
            int v19 = (FILE *)qword_1000EBD00;
          }
          else {
            int v19 = __stderrp;
          }
          fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v19);
        }
        *__error() = v16;
      }
      sub_10002E41C("-[SPTextualReportParser parseSpindumpFile:andReportToStream:]_block_invoke", "SPTextualReportParser.m", 287, "%s: bufSize overflow (%d)", a5, a6, a7, a8, (char)"bufSize > 0");
      goto LABEL_56;
    }
  }
  else
  {
    *(_DWORD *)(v10 + 24) = 0x4000;
    int v12 = *(_DWORD *)(*(void *)(*(void *)v9 + 8) + 24);
  }
  intptr_t result = reallocf(*(void **)(*(void *)(*(void *)(a1 + 40) + 8) + 24), v12);
  *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = result;
  if (!*(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 24))
  {
    if (byte_1000EBCF8)
    {
      int v25 = *__error();
      CFStringRef v26 = sub_10002E548();
      if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR)) {
        sub_10009A220();
      }
      *__error() = v25;
    }
    if (byte_1000EBCF9 && dword_1000EB4A8 <= 3)
    {
      int v27 = *__error();
      CFStringRef v28 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%s: Unable to allocate %d buffer", "buf", *(unsigned int *)(*(void *)(*(void *)v9 + 8) + 24));
      if (v28)
      {
        CFStringRef v31 = v28;
        id v32 = CFStringGetCStringPtr(v28, 0x8000100u);
        if (v32)
        {
          int v33 = (char *)v32;
          size_t v34 = 0;
        }
        else
        {
          int v33 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xB6298B8AuLL);
          CFStringGetCString(v31, v33, 1024, 0x8000100u);
          size_t v34 = v33;
        }
        if (qword_1000EBD00) {
          unsigned int v35 = (FILE *)qword_1000EBD00;
        }
        else {
          unsigned int v35 = __stderrp;
        }
        fprintf(v35, "%s\n", v33);
        if (v34) {
          free(v34);
        }
        CFRelease(v31);
      }
      else
      {
        BOOL v29 = sub_10002E548();
        if (os_log_type_enabled(v29, OS_LOG_TYPE_FAULT)) {
          sub_10009A1A8();
        }
        if (qword_1000EBD00) {
          int v30 = (FILE *)qword_1000EBD00;
        }
        else {
          int v30 = __stderrp;
        }
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v30);
      }
      *__error() = v27;
    }
    sub_10002E41C("-[SPTextualReportParser parseSpindumpFile:andReportToStream:]_block_invoke", "SPTextualReportParser.m", 290, "%s: Unable to allocate %d buffer", v21, v22, v23, v24, (char)"buf");
LABEL_56:
    abort();
  }
  return result;
}

void sub_10007C994(FILE *a1, uint64_t a2, uint64_t a3, char a4, char a5, uint64_t a6)
{
  id v12 = +[NSMutableDictionary dictionary];
  id v13 = +[NSMutableDictionary dictionary];
  v27[0] = 0;
  v27[1] = v27;
  v27[2] = 0x2020000000;
  char v28 = a5;
  id v14 = +[NSMutableSet set];
  uint64_t v21 = 0;
  uint64_t v22 = &v21;
  uint64_t v23 = 0x3052000000;
  uint64_t v24 = sub_1000810D8;
  int v25 = sub_1000810E8;
  uint64_t v26 = 0;
  id v15 = sub_10007CBB4(a1, 0, a3, a4);
  void v22[5] = (uint64_t)v15;
  v18[0] = _NSConcreteStackBlock;
  v18[1] = 3221225472;
  v18[2] = sub_1000810F4;
  v18[3] = &unk_1000DDD90;
  char v19 = a5;
  char v20 = a4;
  v18[10] = v27;
  v18[11] = &v21;
  v18[12] = a1;
  v18[4] = a6;
  v18[5] = a3;
  v18[6] = a2;
  v18[7] = v12;
  v18[8] = v14;
  v18[9] = v13;
  sub_10007F43C(a1, 0, (uint64_t)v18);

  v17[0] = _NSConcreteStackBlock;
  v17[1] = 3221225472;
  v17[2] = sub_100081440;
  v17[3] = &unk_1000DDDE0;
  v17[4] = v14;
  v17[5] = v13;
  [v12 enumerateKeysAndObjectsUsingBlock:v17];
  _Block_object_dispose(&v21, 8);
  _Block_object_dispose(v27, 8);
}

void sub_10007CB88(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 136), 8);
  _Unwind_Resume(a1);
}

id sub_10007CBB4(FILE *a1, int a2, uint64_t a3, char a4)
{
  id v9 = objc_alloc_init((Class)NSMutableArray);
  uint64_t v13 = 0;
  id v14 = &v13;
  uint64_t v15 = 0x2020000000;
  char v16 = 0;
  v11[0] = _NSConcreteStackBlock;
  v11[1] = 3221225472;
  v11[2] = sub_10007FB58;
  v11[3] = &unk_1000DDD48;
  v11[5] = v9;
  v11[6] = &v13;
  v11[4] = a3;
  char v12 = a4;
  sub_10007F43C(a1, a2, (uint64_t)v11);
  if (!*((unsigned char *)v14 + 24))
  {

    id v9 = 0;
  }
  _Block_object_dispose(&v13, 8);
  return v9;
}

void sub_10007CCB4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

unint64_t sub_10007CCCC(void *a1, void *a2, int a3, int a4, int a5)
{
  if (a3)
  {
    id v6 = [a2 rangeWithName:@"indentCount"];
    if (v6 == (id)0x7FFFFFFFFFFFFFFFLL) {
      return 0xFFFFFFFFLL;
    }
    else {
      return sub_10007E83C([a1 substringWithRange:v6, v7]);
    }
  }
  else
  {
    if ([a2 rangeWithName:@"indentWhitespace"] == (id)0x7FFFFFFFFFFFFFFFLL) {
      unint64_t result = 0xFFFFFFFFLL;
    }
    else {
      unint64_t result = v11;
    }
    if ((result & 0x80000000) == 0) {
      return (((int)result - a4) / a5);
    }
  }
  return result;
}

id sub_10007CD64(void *a1, uint64_t a2, void *a3, void *a4, int a5, unint64_t *a6)
{
  uint64_t v13 = v12;
  *a6 = -1;
  if (a5)
  {
    id v14 = [a3 rangeWithName:@"binaryIndex"];
    if (v14 == (id)0x7FFFFFFFFFFFFFFFLL) {
      goto LABEL_3;
    }
    unint64_t v25 = sub_10007E83C([a1 substringWithRange:v14, v15]);
    if (v25 < (unint64_t)[a4 count])
    {
      id v16 = [a4 objectAtIndexedSubscript:v25];
      id v26 = [a3 rangeWithName:@"offsetIntoBinary"];
      if (v26 == (id)0x7FFFFFFFFFFFFFFFLL)
      {
        if (byte_1000EBCF8)
        {
          int v150 = *__error();
          uint64_t v151 = sub_10002E548();
          if (os_log_type_enabled(v151, OS_LOG_TYPE_ERROR)) {
            sub_10009A404();
          }
          *__error() = v150;
        }
        if (byte_1000EBCF9 && dword_1000EB4A8 <= 3)
        {
          int v152 = *__error();
          CFStringRef v153 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%s: load info has binary but no offset into binary (%d: %s)", "range.location != NSNotFound", a2, [a1 UTF8String]);
          if (v153)
          {
            CFStringRef v162 = v153;
            CStringPtr = CFStringGetCStringPtr(v153, 0x8000100u);
            if (CStringPtr)
            {
              CFStringRef v164 = (char *)CStringPtr;
              CFStringRef v165 = 0;
            }
            else
            {
              CFStringRef v164 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xAF47D90FuLL);
              CFStringGetCString(v162, v164, 1024, 0x8000100u);
              CFStringRef v165 = v164;
            }
            if (qword_1000EBD00) {
              int v166 = (FILE *)qword_1000EBD00;
            }
            else {
              int v166 = __stderrp;
            }
            fprintf(v166, "%s\n", v164);
            if (v165) {
              free(v165);
            }
            CFRelease(v162);
          }
          else
          {
            uint64_t v154 = sub_10002E548();
            if (os_log_type_enabled(v154, OS_LOG_TYPE_FAULT)) {
              sub_10009A380();
            }
            if (qword_1000EBD00) {
              uint64_t v155 = (FILE *)qword_1000EBD00;
            }
            else {
              uint64_t v155 = __stderrp;
            }
            fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v155);
          }
          *__error() = v152;
        }
        [a1 UTF8String];
        sub_10002E41C("LoadInfoForFrameLine", "SPTextualReportParser.m", 1117, "%s: load info has binary but no offset into binary (%d: %s)", v167, v168, v169, v170, (char)"range.location != NSNotFound");
        goto LABEL_299;
      }
      id v28 = v26;
      BOOL v29 = a1;
      goto LABEL_233;
    }
    if (byte_1000EBCF8)
    {
      uint64_t v53 = v13;
      int v54 = *__error();
      int v55 = sub_10002E548();
      if (os_log_type_enabled(v55, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 134218754;
        id v206 = (id)v25;
        __int16 v207 = 2048;
        *(void *)id v208 = [a4 count];
        *(_WORD *)&v208[8] = 1024;
        *(_DWORD *)&v208[10] = a2;
        *(_WORD *)&v208[14] = 2112;
        *(void *)&v208[16] = a1;
        _os_log_error_impl((void *)&_mh_execute_header, v55, OS_LOG_TYPE_ERROR, "Parsing spindump text: corrupt condensed file, frame line has out-of-bounds binary index %lu (%lu binaries) (%d: %@)", buf, 0x26u);
      }
      *__error() = v54;
      uint64_t v13 = v53;
    }
    if (!byte_1000EBCF9 || dword_1000EB4A8 > 3)
    {
LABEL_3:
      id v16 = 0;
      goto LABEL_235;
    }
    int v48 = *__error();
    CFStringRef v57 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"Parsing spindump text: corrupt condensed file, frame line has out-of-bounds binary index %lu (%lu binaries) (%d: %@)", v25, [a4 count], a2, a1);
    if (v57)
    {
      CFStringRef v50 = v57;
      unsigned int v51 = CFStringGetCStringPtr(v57, 0x8000100u);
      if (!v51)
      {
        malloc_type_id_t v52 = 1712542635;
        goto LABEL_169;
      }
      goto LABEL_108;
    }
    double v98 = sub_10002E548();
    if (!os_log_type_enabled(v98, OS_LOG_TYPE_FAULT)) {
      goto LABEL_182;
    }
    id v99 = [a4 count];
    *(_DWORD *)buf = 134218754;
    id v206 = (id)v25;
    __int16 v207 = 2048;
    *(void *)id v208 = v99;
    *(_WORD *)&v208[8] = 1024;
    *(_DWORD *)&v208[10] = a2;
    *(_WORD *)&v208[14] = 2112;
    *(void *)&v208[16] = a1;
    id v100 = "Unable to format: Parsing spindump text: corrupt condensed file, frame line has out-of-bounds binary index %l"
           "u (%lu binaries) (%d: %@)";
    id v101 = v98;
    uint32_t v102 = 38;
LABEL_181:
    _os_log_fault_impl((void *)&_mh_execute_header, v101, OS_LOG_TYPE_FAULT, v100, buf, v102);
    goto LABEL_182;
  }
  CFStringRef v17 = v12;
  id v18 = [a3 rangeWithName:@"address"];
  if (v18 != (id)0x7FFFFFFFFFFFFFFFLL)
  {
    int v30 = a1;
    unint64_t v31 = sub_10007E83C([a1 substringWithRange:v18, v19]);
    int v199 = _NSConcreteStackBlock;
    uint64_t v200 = 3221225472;
    int v201 = sub_1000810B4;
    __int16 v202 = &unk_1000DDD68;
    unint64_t v203 = v31;
    unint64_t v32 = SABinarySearchArray();
    if (v32 >= (unint64_t)[a4 count])
    {
      id v16 = 0;
      uint64_t v13 = v17;
    }
    else
    {
      int v33 = [a4 objectAtIndexedSubscript:v32];
      if (v33) {
        unint64_t v34 = v33[7];
      }
      else {
        unint64_t v34 = 0;
      }
      uint64_t v13 = v17;
      if (v34 <= v31) {
        id v16 = v33;
      }
      else {
        id v16 = 0;
      }
      if (v16) {
        goto LABEL_64;
      }
    }
    if (v32)
    {
      id v58 = [a4 objectAtIndexedSubscript:v32 - 1];
      if (v58)
      {
        id v16 = v58;
        if (*((void *)v58 + 8) - 1 >= v31) {
          goto LABEL_65;
        }
      }
      goto LABEL_61;
    }
LABEL_64:
    if (v16)
    {
LABEL_65:
      unint64_t v24 = v31 - *((void *)v16 + 7);
      goto LABEL_234;
    }
LABEL_61:
    if ([a3 rangeWithName:@"binaryName"] != (id)0x7FFFFFFFFFFFFFFFLL
      || [a3 rangeWithName:@"binaryUuid"] != (id)0x7FFFFFFFFFFFFFFFLL)
    {
      if (byte_1000EBCF8)
      {
        int v59 = *__error();
        int v60 = sub_10002E548();
        if (os_log_type_enabled(v60, OS_LOG_TYPE_ERROR)) {
          sub_10009A600();
        }
        *__error() = v59;
      }
      id v16 = 0;
      uint64_t v13 = v17;
      if (!byte_1000EBCF9 || dword_1000EB4A8 > 3) {
        goto LABEL_235;
      }
      int v48 = *__error();
      CFStringRef v61 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"Parsing spindump text: Unable to find load info for (%d: %@)", a2, v30);
      if (v61)
      {
        CFStringRef v50 = v61;
        unsigned int v51 = CFStringGetCStringPtr(v61, 0x8000100u);
        if (!v51)
        {
          malloc_type_id_t v52 = 2963936884;
          goto LABEL_169;
        }
        goto LABEL_108;
      }
      malloc_type_id_t v107 = sub_10002E548();
      if (os_log_type_enabled(v107, OS_LOG_TYPE_FAULT)) {
        sub_10009A590();
      }
      goto LABEL_182;
    }
    id v16 = 0;
    goto LABEL_109;
  }
  uint64_t v190 = a2;
  id v20 = [a3 rangeWithName:@"binaryUuid"];
  if (v20 != (id)0x7FFFFFFFFFFFFFFFLL)
  {
    id v35 = v20;
    uint64_t v36 = v21;
    double v189 = a1;
    id v37 = sub_100080F84([a1 substringWithRange:v20, v21]);
    if (!v37)
    {
      if (byte_1000EBCF8)
      {
        int v73 = *__error();
        int v74 = sub_10002E548();
        if (os_log_type_enabled(v74, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 138412802;
          id v206 = [a1 substringWithRange:v35, v36];
          __int16 v207 = 1024;
          *(_DWORD *)id v208 = v190;
          *(_WORD *)&v208[4] = 2112;
          *(void *)&v208[6] = a1;
          _os_log_impl((void *)&_mh_execute_header, v74, OS_LOG_TYPE_DEFAULT, "Parsing spindump text: unable to parse UUID %@ in line (%d: %@)", buf, 0x1Cu);
        }
        *__error() = v73;
      }
      id v16 = 0;
      if (byte_1000EBCF9)
      {
        uint64_t v13 = v17;
        if (dword_1000EB4A8 > 2) {
          goto LABEL_235;
        }
        int v48 = *__error();
        CFStringRef v75 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"Parsing spindump text: unable to parse UUID %@ in line (%d: %@)", [a1 substringWithRange:v35, v36], v190, a1);
        if (v75)
        {
          CFStringRef v50 = v75;
          unsigned int v51 = CFStringGetCStringPtr(v75, 0x8000100u);
          if (v51) {
            goto LABEL_108;
          }
          malloc_type_id_t v52 = 3349150436;
LABEL_169:
          CFStringRef v76 = (char *)malloc_type_calloc(0x400uLL, 1uLL, v52);
          CFStringGetCString(v50, v76, 1024, 0x8000100u);
          CFStringRef v77 = v76;
          goto LABEL_170;
        }
        int v112 = sub_10002E548();
        if (os_log_type_enabled(v112, OS_LOG_TYPE_FAULT))
        {
          id v113 = [a1 substringWithRange:v35, v36];
          *(_DWORD *)buf = 138412802;
          id v206 = v113;
          __int16 v207 = 1024;
          *(_DWORD *)id v208 = v190;
          *(_WORD *)&v208[4] = 2112;
          *(void *)&v208[6] = a1;
          id v100 = "Unable to format: Parsing spindump text: unable to parse UUID %@ in line (%d: %@)";
          goto LABEL_180;
        }
        goto LABEL_182;
      }
LABEL_109:
      uint64_t v13 = v17;
      goto LABEL_235;
    }
    id v38 = v37;
    long long v197 = 0u;
    long long v198 = 0u;
    long long v195 = 0u;
    long long v196 = 0u;
    id v39 = [a4 countByEnumeratingWithState:&v195 objects:v211 count:16];
    if (!v39) {
      goto LABEL_36;
    }
    id v40 = v39;
    int v41 = 0;
    uint64_t v42 = *(void *)v196;
    while (1)
    {
      uint64_t v43 = 0;
      id v16 = v41;
      do
      {
        if (*(void *)v196 != v42) {
          objc_enumerationMutation(a4);
        }
        int v41 = *(void **)(*((void *)&v195 + 1) + 8 * (void)v43);
        if (v41) {
          uint64_t v44 = (void *)v41[5];
        }
        else {
          uint64_t v44 = 0;
        }
        if (objc_msgSend(objc_msgSend(v44, "uuid"), "isEqual:", v38))
        {
          if (v16)
          {
            if (*((void *)v16 + 6))
            {
              if (byte_1000EBCF8)
              {
                int v78 = *__error();
                CFStringRef v79 = sub_10002E548();
                if (os_log_type_enabled(v79, OS_LOG_TYPE_DEFAULT))
                {
                  id v80 = [*((id *)v16 + 5) uuid];
                  uint64_t v81 = *((void *)v16 + 6);
                  *(_DWORD *)buf = 138413314;
                  id v206 = v38;
                  __int16 v207 = 2112;
                  *(void *)id v208 = v80;
                  *(_WORD *)&v208[8] = 2112;
                  *(void *)&v208[10] = v81;
                  *(_WORD *)&v208[18] = 1024;
                  *(_DWORD *)&v208[20] = v190;
                  __int16 v209 = 2112;
                  id v210 = v189;
                  _os_log_impl((void *)&_mh_execute_header, v79, OS_LOG_TYPE_DEFAULT, "Parsing spindump text: No address for frame line, and binary UUID %@ matches multiple load infos, assuming %@ segment %@ (%d: %@)", buf, 0x30u);
                }
                *__error() = v78;
              }
              if (byte_1000EBCF9) {
                BOOL v82 = dword_1000EB4A8 <= 2;
              }
              else {
                BOOL v82 = 0;
              }
              if (!v82)
              {
LABEL_146:
                uint64_t v13 = v17;
                goto LABEL_208;
              }
              int v83 = *__error();
              CFStringRef v84 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"Parsing spindump text: No address for frame line, and binary UUID %@ matches multiple load infos, assuming %@ segment %@ (%d: %@)", v38, [*((id *)v16 + 5) uuid], *((void *)v16 + 6), v190, v189);
              uint64_t v13 = v17;
              if (v84)
              {
                CFStringRef v85 = v84;
                CFStringRef v86 = CFStringGetCStringPtr(v84, 0x8000100u);
                if (!v86)
                {
                  malloc_type_id_t v87 = 2876111463;
                  goto LABEL_200;
                }
LABEL_162:
                unsigned __int8 v115 = (char *)v86;
                id v116 = 0;
                goto LABEL_201;
              }
              id v121 = sub_10002E548();
              if (os_log_type_enabled(v121, OS_LOG_TYPE_FAULT))
              {
                id v122 = [*((id *)v16 + 5) uuid];
                uint64_t v123 = *((void *)v16 + 6);
                *(_DWORD *)buf = 138413314;
                id v206 = v38;
                __int16 v207 = 2112;
                *(void *)id v208 = v122;
                *(_WORD *)&v208[8] = 2112;
                *(void *)&v208[10] = v123;
                *(_WORD *)&v208[18] = 1024;
                *(_DWORD *)&v208[20] = v190;
                __int16 v209 = 2112;
                id v210 = v189;
                uint64_t v124 = "Unable to format: Parsing spindump text: No address for frame line, and binary UUID %@ matches mu"
                       "ltiple load infos, assuming %@ segment %@ (%d: %@)";
                int v125 = v121;
                uint32_t v126 = 48;
                goto LABEL_237;
              }
              goto LABEL_190;
            }
            if (byte_1000EBCF8)
            {
              int v103 = *__error();
              uint64_t v104 = sub_10002E548();
              if (os_log_type_enabled(v104, OS_LOG_TYPE_DEFAULT))
              {
                id v105 = [*((id *)v16 + 5) uuid];
                *(_DWORD *)buf = 138413058;
                id v206 = v38;
                __int16 v207 = 2112;
                *(void *)id v208 = v105;
                *(_WORD *)&v208[8] = 1024;
                *(_DWORD *)&v208[10] = v190;
                *(_WORD *)&v208[14] = 2112;
                *(void *)&v208[16] = v189;
                _os_log_impl((void *)&_mh_execute_header, v104, OS_LOG_TYPE_DEFAULT, "Parsing spindump text: No address for frame line, and binary UUID %@ matches multiple load infos, assuming %@ (%d: %@)", buf, 0x26u);
              }
              *__error() = v103;
            }
            if (byte_1000EBCF9) {
              BOOL v106 = dword_1000EB4A8 <= 2;
            }
            else {
              BOOL v106 = 0;
            }
            if (!v106) {
              goto LABEL_146;
            }
            int v83 = *__error();
            CFStringRef v114 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"Parsing spindump text: No address for frame line, and binary UUID %@ matches multiple load infos, assuming %@ (%d: %@)", v38, [*((id *)v16 + 5) uuid], v190, v189);
            uint64_t v13 = v17;
            if (v114)
            {
              CFStringRef v85 = v114;
              CFStringRef v86 = CFStringGetCStringPtr(v114, 0x8000100u);
              if (v86) {
                goto LABEL_162;
              }
              malloc_type_id_t v87 = 1508442993;
LABEL_200:
              unsigned __int8 v115 = (char *)malloc_type_calloc(0x400uLL, 1uLL, v87);
              CFStringGetCString(v85, v115, 1024, 0x8000100u);
              id v116 = v115;
LABEL_201:
              if (qword_1000EBD00) {
                uint64_t v138 = (FILE *)qword_1000EBD00;
              }
              else {
                uint64_t v138 = __stderrp;
              }
              fprintf(v138, "%s\n", v115);
              if (v116) {
                free(v116);
              }
              CFRelease(v85);
            }
            else
            {
              id v134 = sub_10002E548();
              if (os_log_type_enabled(v134, OS_LOG_TYPE_FAULT))
              {
                id v148 = [*((id *)v16 + 5) uuid];
                *(_DWORD *)buf = 138413058;
                id v206 = v38;
                __int16 v207 = 2112;
                *(void *)id v208 = v148;
                *(_WORD *)&v208[8] = 1024;
                *(_DWORD *)&v208[10] = v190;
                *(_WORD *)&v208[14] = 2112;
                *(void *)&v208[16] = v189;
                uint64_t v124 = "Unable to format: Parsing spindump text: No address for frame line, and binary UUID %@ matches mu"
                       "ltiple load infos, assuming %@ (%d: %@)";
                int v125 = v134;
                uint32_t v126 = 38;
LABEL_237:
                _os_log_fault_impl((void *)&_mh_execute_header, v125, OS_LOG_TYPE_FAULT, v124, buf, v126);
              }
LABEL_190:
              if (qword_1000EBD00) {
                int v135 = (FILE *)qword_1000EBD00;
              }
              else {
                int v135 = __stderrp;
              }
              fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v135);
            }
            *__error() = v83;
            goto LABEL_208;
          }
        }
        else
        {
          int v41 = v16;
        }
        uint64_t v43 = (char *)v43 + 1;
        id v16 = v41;
      }
      while (v40 != v43);
      id v45 = [a4 countByEnumeratingWithState:&v195 objects:v211 count:16];
      id v40 = v45;
      if (!v45)
      {
        id v16 = v41;
        uint64_t v13 = v17;
        if (!v41)
        {
LABEL_36:
          if (byte_1000EBCF8)
          {
            int v46 = *__error();
            long long v47 = sub_10002E548();
            if (os_log_type_enabled(v47, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)buf = 138412802;
              id v206 = v38;
              __int16 v207 = 1024;
              *(_DWORD *)id v208 = v190;
              *(_WORD *)&v208[4] = 2112;
              *(void *)&v208[6] = v189;
              _os_log_error_impl((void *)&_mh_execute_header, v47, OS_LOG_TYPE_ERROR, "Parsing spindump text: No matching binary for frame line with binary UUID %@! (%d: %@)", buf, 0x1Cu);
            }
            *__error() = v46;
          }
          id v16 = 0;
          if (byte_1000EBCF9)
          {
            uint64_t v13 = v17;
            if (dword_1000EB4A8 > 3) {
              goto LABEL_235;
            }
            int v48 = *__error();
            CFStringRef v49 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"Parsing spindump text: No matching binary for frame line with binary UUID %@! (%d: %@)", v38, v190, v189);
            if (v49)
            {
              CFStringRef v50 = v49;
              unsigned int v51 = CFStringGetCStringPtr(v49, 0x8000100u);
              if (!v51)
              {
                malloc_type_id_t v52 = 4010476091;
                goto LABEL_169;
              }
              goto LABEL_108;
            }
            int v112 = sub_10002E548();
            if (os_log_type_enabled(v112, OS_LOG_TYPE_FAULT))
            {
              *(_DWORD *)buf = 138412802;
              id v206 = v38;
              __int16 v207 = 1024;
              *(_DWORD *)id v208 = v190;
              *(_WORD *)&v208[4] = 2112;
              *(void *)&v208[6] = v189;
              id v100 = "Unable to format: Parsing spindump text: No matching binary for frame line with binary UUID %@! (%d: %@)";
              goto LABEL_180;
            }
LABEL_182:
            if (qword_1000EBD00) {
              uint64_t v127 = (FILE *)qword_1000EBD00;
            }
            else {
              uint64_t v127 = __stderrp;
            }
            fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v127);
            goto LABEL_186;
          }
          goto LABEL_109;
        }
LABEL_208:
        id v139 = [a3 rangeWithName:@"offsetIntoBinary"];
        if (v139 == (id)0x7FFFFFFFFFFFFFFFLL)
        {
          if (byte_1000EBCF8)
          {
            int v140 = *__error();
            uint64_t v141 = sub_10002E548();
            if (os_log_type_enabled(v141, OS_LOG_TYPE_ERROR)) {
              sub_10009A50C();
            }
            *__error() = v140;
          }
          if (byte_1000EBCF9 && dword_1000EB4A8 <= 3)
          {
            int v142 = *__error();
            CFStringRef v143 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%s: frame regex returned binary but no offset into binary (%d: %s)", "range.location != NSNotFound", v190, [v189 UTF8String]);
            if (v143)
            {
              CFStringRef v171 = v143;
              uint64_t v172 = CFStringGetCStringPtr(v143, 0x8000100u);
              if (v172)
              {
                uint64_t v173 = (char *)v172;
                id v174 = 0;
              }
              else
              {
                uint64_t v173 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x6CD03AA1uLL);
                CFStringGetCString(v171, v173, 1024, 0x8000100u);
                id v174 = v173;
              }
              if (qword_1000EBD00) {
                CFStringRef v179 = (FILE *)qword_1000EBD00;
              }
              else {
                CFStringRef v179 = __stderrp;
              }
              fprintf(v179, "%s\n", v173);
              if (v174) {
                free(v174);
              }
              CFRelease(v171);
            }
            else
            {
              CFStringRef v144 = sub_10002E548();
              if (os_log_type_enabled(v144, OS_LOG_TYPE_FAULT)) {
                sub_10009A488();
              }
              if (qword_1000EBD00) {
                CFStringRef v145 = (FILE *)qword_1000EBD00;
              }
              else {
                CFStringRef v145 = __stderrp;
              }
              fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v145);
            }
            *__error() = v142;
          }
          [v189 UTF8String];
          sub_10002E41C("LoadInfoForFrameLine", "SPTextualReportParser.m", 1197, "%s: frame regex returned binary but no offset into binary (%d: %s)", v180, v181, v182, v183, (char)"range.location != NSNotFound");
LABEL_299:
          abort();
        }
LABEL_232:
        id v28 = v139;
        BOOL v29 = v189;
LABEL_233:
        unint64_t v24 = sub_10007E83C([v29 substringWithRange:v28, v27]);
LABEL_234:
        *a6 = v24;
        goto LABEL_235;
      }
    }
  }
  id v22 = [a3 rangeWithName:@"binaryName"];
  uint64_t v13 = v17;
  if (v22 == (id)0x7FFFFFFFFFFFFFFFLL)
  {
    id v16 = 0;
    unint64_t v24 = -1;
    goto LABEL_234;
  }
  double v189 = a1;
  id v62 = [a1 substringWithRange:v22, v23];
  long long v191 = 0u;
  long long v192 = 0u;
  long long v193 = 0u;
  long long v194 = 0u;
  id v63 = [a4 countByEnumeratingWithState:&v191 objects:v204 count:16];
  if (!v63) {
    goto LABEL_91;
  }
  id v64 = v63;
  int v65 = 0;
  uint64_t v66 = *(void *)v192;
  do
  {
    CFStringRef v67 = 0;
    id v16 = v65;
    do
    {
      if (*(void *)v192 != v66) {
        objc_enumerationMutation(a4);
      }
      int v65 = *(void **)(*((void *)&v191 + 1) + 8 * (void)v67);
      if (v65) {
        CFStringRef v68 = (void *)v65[5];
      }
      else {
        CFStringRef v68 = 0;
      }
      if (objc_msgSend(objc_msgSend(v68, "name"), "isEqualToString:", v62))
      {
        if (v16)
        {
          if (*((void *)v16 + 6))
          {
            if (byte_1000EBCF8)
            {
              int v88 = *__error();
              int v89 = sub_10002E548();
              if (os_log_type_enabled(v89, OS_LOG_TYPE_DEFAULT))
              {
                id v90 = [*((id *)v16 + 5) uuid];
                uint64_t v91 = *((void *)v16 + 6);
                *(_DWORD *)buf = 138413314;
                id v206 = v62;
                __int16 v207 = 2112;
                *(void *)id v208 = v90;
                *(_WORD *)&v208[8] = 2112;
                *(void *)&v208[10] = v91;
                *(_WORD *)&v208[18] = 1024;
                *(_DWORD *)&v208[20] = v190;
                __int16 v209 = 2112;
                id v210 = v189;
                _os_log_impl((void *)&_mh_execute_header, v89, OS_LOG_TYPE_DEFAULT, "Parsing spindump text: No address for frame line, and binary name %@ matches multiple load infos, assuming %@ segment %@ (%d: %@)", buf, 0x30u);
              }
              *__error() = v88;
            }
            if (byte_1000EBCF9) {
              BOOL v92 = dword_1000EB4A8 <= 2;
            }
            else {
              BOOL v92 = 0;
            }
            if (!v92)
            {
LABEL_157:
              uint64_t v13 = v17;
              goto LABEL_231;
            }
            int v93 = *__error();
            CFStringRef v94 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"Parsing spindump text: No address for frame line, and binary name %@ matches multiple load infos, assuming %@ segment %@ (%d: %@)", v62, [*((id *)v16 + 5) uuid], *((void *)v16 + 6), v190, v189);
            uint64_t v13 = v17;
            if (v94)
            {
              CFStringRef v95 = v94;
              CFStringRef v96 = CFStringGetCStringPtr(v94, 0x8000100u);
              if (!v96)
              {
                malloc_type_id_t v97 = 2443886973;
LABEL_223:
                int v118 = (char *)malloc_type_calloc(0x400uLL, 1uLL, v97);
                CFStringGetCString(v95, v118, 1024, 0x8000100u);
                id v119 = v118;
                goto LABEL_224;
              }
              goto LABEL_165;
            }
            uint64_t v128 = sub_10002E548();
            if (os_log_type_enabled(v128, OS_LOG_TYPE_FAULT))
            {
              id v129 = [*((id *)v16 + 5) uuid];
              uint64_t v130 = *((void *)v16 + 6);
              *(_DWORD *)buf = 138413314;
              id v206 = v62;
              __int16 v207 = 2112;
              *(void *)id v208 = v129;
              *(_WORD *)&v208[8] = 2112;
              *(void *)&v208[10] = v130;
              *(_WORD *)&v208[18] = 1024;
              *(_DWORD *)&v208[20] = v190;
              __int16 v209 = 2112;
              id v210 = v189;
              uint64_t v131 = "Unable to format: Parsing spindump text: No address for frame line, and binary name %@ matches mult"
                     "iple load infos, assuming %@ segment %@ (%d: %@)";
              integer_t v132 = v128;
              uint32_t v133 = 48;
LABEL_239:
              _os_log_fault_impl((void *)&_mh_execute_header, v132, OS_LOG_TYPE_FAULT, v131, buf, v133);
            }
          }
          else
          {
            if (byte_1000EBCF8)
            {
              int v108 = *__error();
              int v109 = sub_10002E548();
              if (os_log_type_enabled(v109, OS_LOG_TYPE_DEFAULT))
              {
                id v110 = [*((id *)v16 + 5) uuid];
                *(_DWORD *)buf = 138413058;
                id v206 = v62;
                __int16 v207 = 2112;
                *(void *)id v208 = v110;
                *(_WORD *)&v208[8] = 1024;
                *(_DWORD *)&v208[10] = v190;
                *(_WORD *)&v208[14] = 2112;
                *(void *)&v208[16] = v189;
                _os_log_impl((void *)&_mh_execute_header, v109, OS_LOG_TYPE_DEFAULT, "Parsing spindump text: No address for frame line, and binary name %@ matches multiple load infos, assuming %@ (%d: %@)", buf, 0x26u);
              }
              *__error() = v108;
            }
            if (byte_1000EBCF9) {
              BOOL v111 = dword_1000EB4A8 <= 2;
            }
            else {
              BOOL v111 = 0;
            }
            if (!v111) {
              goto LABEL_157;
            }
            int v93 = *__error();
            CFStringRef v117 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"Parsing spindump text: No address for frame line, and binary name %@ matches multiple load infos, assuming %@ (%d: %@)", v62, [*((id *)v16 + 5) uuid], v190, v189);
            uint64_t v13 = v17;
            if (v117)
            {
              CFStringRef v95 = v117;
              CFStringRef v96 = CFStringGetCStringPtr(v117, 0x8000100u);
              if (!v96)
              {
                malloc_type_id_t v97 = 2084680403;
                goto LABEL_223;
              }
LABEL_165:
              int v118 = (char *)v96;
              id v119 = 0;
LABEL_224:
              if (qword_1000EBD00) {
                BOOL v146 = (FILE *)qword_1000EBD00;
              }
              else {
                BOOL v146 = __stderrp;
              }
              fprintf(v146, "%s\n", v118);
              if (v119) {
                free(v119);
              }
              CFRelease(v95);
              goto LABEL_230;
            }
            int v136 = sub_10002E548();
            if (os_log_type_enabled(v136, OS_LOG_TYPE_FAULT))
            {
              id v149 = [*((id *)v16 + 5) uuid];
              *(_DWORD *)buf = 138413058;
              id v206 = v62;
              __int16 v207 = 2112;
              *(void *)id v208 = v149;
              *(_WORD *)&v208[8] = 1024;
              *(_DWORD *)&v208[10] = v190;
              *(_WORD *)&v208[14] = 2112;
              *(void *)&v208[16] = v189;
              uint64_t v131 = "Unable to format: Parsing spindump text: No address for frame line, and binary name %@ matches mult"
                     "iple load infos, assuming %@ (%d: %@)";
              integer_t v132 = v136;
              uint32_t v133 = 38;
              goto LABEL_239;
            }
          }
          if (qword_1000EBD00) {
            __int16 v137 = (FILE *)qword_1000EBD00;
          }
          else {
            __int16 v137 = __stderrp;
          }
          fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v137);
LABEL_230:
          *__error() = v93;
LABEL_231:
          id v139 = [a3 rangeWithName:@"offsetIntoBinary"];
          if (v139 == (id)0x7FFFFFFFFFFFFFFFLL)
          {
            if (byte_1000EBCF8)
            {
              int v156 = *__error();
              uint64_t v157 = sub_10002E548();
              if (os_log_type_enabled(v157, OS_LOG_TYPE_ERROR)) {
                sub_10009A50C();
              }
              *__error() = v156;
            }
            if (byte_1000EBCF9 && dword_1000EB4A8 <= 3)
            {
              int v158 = *__error();
              CFStringRef v159 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%s: frame regex returned binary but no offset into binary (%d: %s)", "range.location != NSNotFound", v190, [v189 UTF8String]);
              if (v159)
              {
                CFStringRef v175 = v159;
                int v176 = CFStringGetCStringPtr(v159, 0x8000100u);
                if (v176)
                {
                  id v177 = (char *)v176;
                  id v178 = 0;
                }
                else
                {
                  id v177 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x73195142uLL);
                  CFStringGetCString(v175, v177, 1024, 0x8000100u);
                  id v178 = v177;
                }
                if (qword_1000EBD00) {
                  int v184 = (FILE *)qword_1000EBD00;
                }
                else {
                  int v184 = __stderrp;
                }
                fprintf(v184, "%s\n", v177);
                if (v178) {
                  free(v178);
                }
                CFRelease(v175);
              }
              else
              {
                int v160 = sub_10002E548();
                if (os_log_type_enabled(v160, OS_LOG_TYPE_FAULT)) {
                  sub_10009A488();
                }
                if (qword_1000EBD00) {
                  uint64_t v161 = (FILE *)qword_1000EBD00;
                }
                else {
                  uint64_t v161 = __stderrp;
                }
                fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v161);
              }
              *__error() = v158;
            }
            [v189 UTF8String];
            sub_10002E41C("LoadInfoForFrameLine", "SPTextualReportParser.m", 1225, "%s: frame regex returned binary but no offset into binary (%d: %s)", v185, v186, v187, v188, (char)"range.location != NSNotFound");
            goto LABEL_299;
          }
          goto LABEL_232;
        }
      }
      else
      {
        int v65 = v16;
      }
      CFStringRef v67 = (char *)v67 + 1;
      id v16 = v65;
    }
    while (v64 != v67);
    id v69 = [a4 countByEnumeratingWithState:&v191 objects:v204 count:16];
    id v64 = v69;
  }
  while (v69);
  id v16 = v65;
  uint64_t v13 = v17;
  if (v65) {
    goto LABEL_231;
  }
LABEL_91:
  if (byte_1000EBCF8)
  {
    int v70 = *__error();
    uint64_t v71 = sub_10002E548();
    if (os_log_type_enabled(v71, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 138412802;
      id v206 = v62;
      __int16 v207 = 1024;
      *(_DWORD *)id v208 = v190;
      *(_WORD *)&v208[4] = 2112;
      *(void *)&v208[6] = v189;
      _os_log_error_impl((void *)&_mh_execute_header, v71, OS_LOG_TYPE_ERROR, "Parsing spindump text: No matching binary for frame line with binary name %@! (%d: %@)", buf, 0x1Cu);
    }
    *__error() = v70;
    uint64_t v13 = v17;
  }
  id v16 = 0;
  if (!byte_1000EBCF9 || dword_1000EB4A8 > 3) {
    goto LABEL_235;
  }
  int v48 = *__error();
  CFStringRef v72 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"Parsing spindump text: No matching binary for frame line with binary name %@! (%d: %@)", v62, v190, v189);
  if (!v72)
  {
    int v112 = sub_10002E548();
    if (!os_log_type_enabled(v112, OS_LOG_TYPE_FAULT)) {
      goto LABEL_182;
    }
    *(_DWORD *)buf = 138412802;
    id v206 = v62;
    __int16 v207 = 1024;
    *(_DWORD *)id v208 = v190;
    *(_WORD *)&v208[4] = 2112;
    *(void *)&v208[6] = v189;
    id v100 = "Unable to format: Parsing spindump text: No matching binary for frame line with binary name %@! (%d: %@)";
LABEL_180:
    id v101 = v112;
    uint32_t v102 = 28;
    goto LABEL_181;
  }
  CFStringRef v50 = v72;
  unsigned int v51 = CFStringGetCStringPtr(v72, 0x8000100u);
  if (!v51)
  {
    malloc_type_id_t v52 = 950882490;
    goto LABEL_169;
  }
LABEL_108:
  CFStringRef v76 = (char *)v51;
  CFStringRef v77 = 0;
LABEL_170:
  if (qword_1000EBD00) {
    char v120 = (FILE *)qword_1000EBD00;
  }
  else {
    char v120 = __stderrp;
  }
  fprintf(v120, "%s\n", v76);
  if (v77) {
    free(v77);
  }
  CFRelease(v50);
LABEL_186:
  id v16 = 0;
  *__error() = v48;
LABEL_235:
  return v16;
}

unint64_t sub_10007E83C(void *a1)
{
  unint64_t v3 = (const char *)[a1 UTF8String];
  if (!v3)
  {
    id v4 = [a1 dataUsingEncoding:4 allowLossyConversion:1];
    if (!v4)
    {
      unint64_t v5 = 0;
      goto LABEL_5;
    }
    unint64_t v3 = (const char *)[v4 bytes];
  }
  unint64_t v5 = strtoull(v3, 0, 0);
LABEL_5:
  return v5;
}

uint64_t sub_10007E8AC(FILE *a1, int a2, int a3, int a4, int a5, const char *a6, uint64_t a7, const char *a8, int a9, int a10)
{
  id v16 = "";
  if (a3) {
    id v16 = "*";
  }
  fprintf(a1, "%*s", a2, v16);
  fprintf(a1, "%-*d", a5, a4);
  fputs(a6, a1);
  if (a7 != -1) {
    fprintf(a1, " [0x%llx]", a7);
  }
  if (a8) {
    fprintf(a1, " (%s)", a8);
  }
  if (a9)
  {
    fprintf(a1, " %d", a9);
    if (a9 != a10) {
      fprintf(a1, "-%d", a10);
    }
  }

  return fputc(10, a1);
}

void sub_10007E9CC(void *a1, uint64_t a2, void *a3, int a4, int a5, int a6, _DWORD *a7, _DWORD *a8, BOOL *a9, _DWORD *a10, int *a11, void *a12, void *a13, int *a14, _DWORD *a15)
{
  id v18 = a15;
  id v19 = [a3 rangeWithName:@"angleBracketContents"];
  if (v19 != (id)0x7FFFFFFFFFFFFFFFLL
    || (id v19 = [a3 rangeWithName:@"otherInfo"], v19 != (id)0x7FFFFFFFFFFFFFFFLL))
  {
    *a12 = [a1 substringWithRange:v19, v20];
  }
  id v21 = [a3 rangeWithName:@"stateInfo"];
  if (v21 != (id)0x7FFFFFFFFFFFFFFFLL)
  {
    id v23 = [a1 substringWithRange:v21, v22];
    if (a4)
    {
      unint64_t v24 = sub_10007E83C(v23);
      id v25 = objc_alloc_init((Class)NSMutableString);
      id v26 = v25;
      if ((v24 & 2) != 0) {
        CFStringRef v27 = @"Frontmost App";
      }
      else {
        CFStringRef v27 = @"Non-Frontmost App";
      }
      [v25 appendString:v27];
      if ((v24 & 0x20) != 0) {
        CFStringRef v28 = @", Suppressed";
      }
      else {
        CFStringRef v28 = @", Non-Suppressed";
      }
      [v26 appendString:v28];
      if ((v24 & 0x80) != 0) {
        CFStringRef v29 = @", Kernel mode";
      }
      else {
        CFStringRef v29 = @", User mode";
      }
      [v26 appendString:v29];
      if ((v24 & 0x10) != 0)
      {
        if ((v24 & 4) != 0) {
          CFStringRef v30 = @", User Idle";
        }
        else {
          CFStringRef v30 = @", User Active";
        }
        [v26 appendString:v30];
      }
      if ((v24 & 8) != 0) {
        CFStringRef v31 = @", On Battery";
      }
      else {
        CFStringRef v31 = @", On AC";
      }
      [v26 appendString:v31];
      uint64_t v32 = ((v24 >> 8) & 7) - 1;
      if (v32 > 6) {
        int v33 = "Thread QoS Unknown";
      }
      else {
        int v33 = (&off_1000DDEA0)[v32];
      }
      [v26 appendFormat:@", Effective %s", v33];
      uint64_t v34 = ((v24 >> 11) & 7) - 1;
      if (v34 > 6) {
        id v35 = "Thread QoS Unknown";
      }
      else {
        id v35 = (&off_1000DDEA0)[v34];
      }
      [v26 appendFormat:@", Requested %s", v35];
      uint64_t v36 = ((v24 >> 14) & 7) - 1;
      if (v36 > 6) {
        id v37 = "Thread QoS Unknown";
      }
      else {
        id v37 = (&off_1000DDEA0)[v36];
      }
      [v26 appendFormat:@", Override %s", v37];
    }
    else
    {
      id v26 = v23;
    }
    *a13 = v26;
    id v18 = a15;
  }
  id v38 = [a3 rangeWithName:@"count"];
  if (v38 == (id)0x7FFFFFFFFFFFFFFFLL)
  {
    *a10 = -1;
    *a11 = -1;
  }
  else
  {
    *a10 = sub_10007E83C([a1 substringWithRange:v38, v39]);
    if (a4)
    {
      int v40 = -1;
    }
    else if ([a3 rangeWithName:@"countAndWhitespace"] == (id)0x7FFFFFFFFFFFFFFFLL)
    {
      if (byte_1000EBCF8)
      {
        int v50 = *__error();
        unsigned int v51 = sub_10002E548();
        if (os_log_type_enabled(v51, OS_LOG_TYPE_ERROR)) {
          sub_10009A6EC();
        }
        *__error() = v50;
      }
      if (byte_1000EBCF9 && dword_1000EB4A8 <= 3)
      {
        int v52 = *__error();
        CFStringRef v53 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%s: frame match with no count and whitespace (%d: %s)", "range.location != NSNotFound", a2, [a1 UTF8String]);
        if (v53)
        {
          CFStringRef v62 = v53;
          CStringPtr = CFStringGetCStringPtr(v53, 0x8000100u);
          if (CStringPtr)
          {
            id v64 = (char *)CStringPtr;
            int v65 = 0;
          }
          else
          {
            id v64 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x446AA138uLL);
            CFStringGetCString(v62, v64, 1024, 0x8000100u);
            int v65 = v64;
          }
          if (qword_1000EBD00) {
            int v70 = (FILE *)qword_1000EBD00;
          }
          else {
            int v70 = __stderrp;
          }
          fprintf(v70, "%s\n", v64);
          if (v65) {
            free(v65);
          }
          CFRelease(v62);
        }
        else
        {
          int v54 = sub_10002E548();
          if (os_log_type_enabled(v54, OS_LOG_TYPE_FAULT)) {
            sub_10009A668();
          }
          if (qword_1000EBD00) {
            int v55 = (FILE *)qword_1000EBD00;
          }
          else {
            int v55 = __stderrp;
          }
          fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v55);
        }
        *__error() = v52;
      }
      [a1 UTF8String];
      sub_10002E41C("ParseCallTreeNonFrameLine", "SPTextualReportParser.m", 2228, "%s: frame match with no count and whitespace (%d: %s)", v71, v72, v73, v74, (char)"range.location != NSNotFound");
LABEL_104:
      abort();
    }
    *a11 = v40;
    *a7 = sub_10007CCCC(a1, a3, a4, a5, a6);
  }
  if ([a3 rangeWithName:@"indentWhitespace"] != (id)0x7FFFFFFFFFFFFFFFLL) {
    *a8 = v41;
  }
  *a9 = [a3 rangeWithName:@"kernelDot"] != (id)0x7FFFFFFFFFFFFFFFLL;
  id v42 = [a3 rangeWithName:@"count"];
  if (v42 == (id)0x7FFFFFFFFFFFFFFFLL)
  {
    int v44 = -1;
    *a10 = -1;
    goto LABEL_48;
  }
  *a10 = sub_10007E83C([a1 substringWithRange:v42, v43]);
  if (a4)
  {
    int v44 = -1;
    goto LABEL_48;
  }
  if ([a3 rangeWithName:@"countAndWhitespace"] == (id)0x7FFFFFFFFFFFFFFFLL)
  {
    if (byte_1000EBCF8)
    {
      int v56 = *__error();
      CFStringRef v57 = sub_10002E548();
      if (os_log_type_enabled(v57, OS_LOG_TYPE_ERROR)) {
        sub_10009A6EC();
      }
      *__error() = v56;
    }
    if (byte_1000EBCF9 && dword_1000EB4A8 <= 3)
    {
      int v58 = *__error();
      CFStringRef v59 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%s: frame match with no count and whitespace (%d: %s)", "range.location != NSNotFound", a2, [a1 UTF8String]);
      if (v59)
      {
        CFStringRef v66 = v59;
        CFStringRef v67 = CFStringGetCStringPtr(v59, 0x8000100u);
        if (v67)
        {
          CFStringRef v68 = (char *)v67;
          id v69 = 0;
        }
        else
        {
          CFStringRef v68 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x1863B9A1uLL);
          CFStringGetCString(v66, v68, 1024, 0x8000100u);
          id v69 = v68;
        }
        if (qword_1000EBD00) {
          CFStringRef v75 = (FILE *)qword_1000EBD00;
        }
        else {
          CFStringRef v75 = __stderrp;
        }
        fprintf(v75, "%s\n", v68);
        if (v69) {
          free(v69);
        }
        CFRelease(v66);
      }
      else
      {
        int v60 = sub_10002E548();
        if (os_log_type_enabled(v60, OS_LOG_TYPE_FAULT)) {
          sub_10009A668();
        }
        if (qword_1000EBD00) {
          CFStringRef v61 = (FILE *)qword_1000EBD00;
        }
        else {
          CFStringRef v61 = __stderrp;
        }
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v61);
      }
      *__error() = v58;
    }
    [a1 UTF8String];
    sub_10002E41C("ParseCallTreeNonFrameLine", "SPTextualReportParser.m", 2261, "%s: frame match with no count and whitespace (%d: %s)", v76, v77, v78, v79, (char)"range.location != NSNotFound");
    goto LABEL_104;
  }
LABEL_48:
  *a11 = v44;
  id v45 = [a3 rangeWithName:@"startIndex"];
  if (v45 == (id)0x7FFFFFFFFFFFFFFFLL)
  {
    int v47 = 0;
    *a14 = 0;
  }
  else
  {
    *a14 = sub_10007E83C([a1 substringWithRange:v45, v46]);
    id v48 = [a3 rangeWithName:@"endIndex"];
    if (v48 == (id)0x7FFFFFFFFFFFFFFFLL) {
      int v47 = *a14;
    }
    else {
      int v47 = sub_10007E83C([a1 substringWithRange:v48, v49]);
    }
  }
  _DWORD *v18 = v47;
}

uint64_t sub_10007F1D4(FILE *a1, int a2, int a3, int a4, int a5, const char *a6, uint64_t a7, int a8, int a9)
{
  uint64_t v15 = "*";
  if (!a3) {
    uint64_t v15 = "";
  }
  fprintf(a1, "%*s", a2, v15);
  if (a4 < 1)
  {
    if (a5 >= 1) {
      fprintf(a1, "%*s");
    }
  }
  else
  {
    fprintf(a1, "%-*d");
  }
  if (a6)
  {
    fprintf(a1, "<%s>", a6);
    if (a7) {
      fprintf(a1, " (%s)");
    }
  }
  else if (a7)
  {
    fprintf(a1, "<%s>");
  }
  if (a8)
  {
    fprintf(a1, " %d", a8);
    if (a8 != a9) {
      fprintf(a1, "-%d", a9);
    }
  }

  return fputc(10, a1);
}

int64_t sub_10007F314(id a1, SPTreeNode *a2, SPTreeNode *a3)
{
  if (a2)
  {
    int count = a2->_count;
    if (a3)
    {
LABEL_3:
      int v4 = a3->_count;
      goto LABEL_4;
    }
  }
  else
  {
    int count = 0;
    if (a3) {
      goto LABEL_3;
    }
  }
  int v4 = 0;
LABEL_4:
  if (count < v4) {
    return 1;
  }
  if (a2)
  {
    int v6 = a2->_count;
    if (a3)
    {
LABEL_8:
      int v7 = a3->_count;
      goto LABEL_9;
    }
  }
  else
  {
    int v6 = 0;
    if (a3) {
      goto LABEL_8;
    }
  }
  int v7 = 0;
LABEL_9:
  if (v6 <= v7) {
    return 0;
  }
  else {
    return -1;
  }
}

void sub_10007F43C(FILE *a1, int a2, uint64_t a3)
{
  LODWORD(v4) = a2;
  off_t v6 = ftello(a1);
  if (v6 == -1)
  {
    if (byte_1000EBCF8)
    {
      int v19 = *__error();
      uint64_t v20 = sub_10002E548();
      if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR)) {
        sub_10009A808();
      }
      *__error() = v19;
    }
    if (byte_1000EBCF9) {
      BOOL v21 = dword_1000EB4A8 <= 3;
    }
    else {
      BOOL v21 = 0;
    }
    if (v21)
    {
      int v49 = *__error();
      uint64_t v50 = *__error();
      unsigned int v51 = __error();
      int v52 = strerror(*v51);
      CFStringRef v53 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%s: ftello failed: %d (%s)", "pos != -1", v50, v52);
      CFStringRef v54 = v53;
      if (v53)
      {
        CStringPtr = (char *)CFStringGetCStringPtr(v53, 0x8000100u);
        if (CStringPtr)
        {
          int v58 = 0;
        }
        else
        {
          CStringPtr = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x18926F60uLL);
          CFStringGetCString(v54, CStringPtr, 1024, 0x8000100u);
          int v58 = CStringPtr;
        }
        if (qword_1000EBD00) {
          CFStringRef v59 = (FILE *)qword_1000EBD00;
        }
        else {
          CFStringRef v59 = __stderrp;
        }
        fprintf(v59, "%s\n", CStringPtr);
        if (v58) {
          free(v58);
        }
        CFRelease(v54);
      }
      else
      {
        int v55 = sub_10002E548();
        if (os_log_type_enabled(v55, OS_LOG_TYPE_FAULT)) {
          sub_10009A770();
        }
        if (qword_1000EBD00) {
          int v56 = (FILE *)qword_1000EBD00;
        }
        else {
          int v56 = __stderrp;
        }
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v56);
      }
      *__error() = v49;
    }
    __error();
    uint64_t v22 = __error();
    strerror(*v22);
    sub_10002E41C("LookaheadLines", "SPTextualReportParser.m", 965, "%s: ftello failed: %d (%s)", v23, v24, v25, v26, (char)"pos != -1");
    abort();
  }
  off_t v14 = v6;
  uint64_t v72 = 0;
  uint64_t v73 = &v72;
  uint64_t v74 = 0x2020000000;
  uint64_t v75 = 0;
  uint64_t v68 = 0;
  id v69 = &v68;
  uint64_t v70 = 0x2020000000;
  int v71 = 0;
  v63[0] = _NSConcreteStackBlock;
  v63[1] = 3221225472;
  id v64 = sub_100080B2C;
  int v65 = &unk_1000DD2A8;
  CFStringRef v66 = &v68;
  CFStringRef v67 = &v72;
  sub_100080B2C((uint64_t)v63, v7, v8, v9, v10, v11, v12, v13);
  if (fgets((char *)v73[3], *((_DWORD *)v69 + 6), a1))
  {
    do
    {
      uint64_t v15 = (const char *)v73[3];
      int v16 = strnlen(v15, *((int *)v69 + 6));
      if (v15[v16 - 1] == 10)
      {
        v15[v16 - 1] = 0;
        id v17 = objc_alloc((Class)NSString);
        id v18 = [v17 initWithUTF8String:v73[3]];
        uint64_t v4 = (v4 + 1);
        buf[0] = 0;
        (*(void (**)(uint64_t, id, uint64_t, uint8_t *))(a3 + 16))(a3, v18, v4, buf);

        if (buf[0]) {
          break;
        }
        int v16 = 0;
      }
      else
      {
        ((void (*)(void *))v64)(v63);
      }
    }
    while (fgets((char *)(v73[3] + v16), *((_DWORD *)v69 + 6) - v16, a1));
  }
  free((void *)v73[3]);
  if (fseeko(a1, v14, 0))
  {
    if (byte_1000EBCF8)
    {
      int v27 = *__error();
      CFStringRef v28 = sub_10002E548();
      if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR))
      {
        int v29 = *__error();
        CFStringRef v30 = __error();
        CFStringRef v31 = strerror(*v30);
        *(_DWORD *)buf = 136315906;
        uint64_t v77 = "ret == 0";
        __int16 v78 = 2048;
        off_t v79 = v14;
        __int16 v80 = 1024;
        int v81 = v29;
        __int16 v82 = 2080;
        int v83 = v31;
        _os_log_error_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_ERROR, "%s: Unable to seek back to %lld after searching for load infos: %d (%s)", buf, 0x26u);
      }
      *__error() = v27;
    }
    if (byte_1000EBCF9) {
      BOOL v32 = dword_1000EB4A8 <= 3;
    }
    else {
      BOOL v32 = 0;
    }
    if (v32)
    {
      int v33 = *__error();
      uint64_t v34 = *__error();
      id v35 = __error();
      uint64_t v36 = strerror(*v35);
      CFStringRef v37 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%s: Unable to seek back to %lld after searching for load infos: %d (%s)", "ret == 0", v14, v34, v36);
      CFStringRef v38 = v37;
      if (v37)
      {
        int v60 = (char *)CFStringGetCStringPtr(v37, 0x8000100u);
        if (v60)
        {
          CFStringRef v61 = 0;
        }
        else
        {
          int v60 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x140109E3uLL);
          CFStringGetCString(v38, v60, 1024, 0x8000100u);
          CFStringRef v61 = v60;
        }
        if (qword_1000EBD00) {
          CFStringRef v62 = (FILE *)qword_1000EBD00;
        }
        else {
          CFStringRef v62 = __stderrp;
        }
        fprintf(v62, "%s\n", v60);
        if (v61) {
          free(v61);
        }
        CFRelease(v38);
      }
      else
      {
        uint64_t v39 = sub_10002E548();
        if (os_log_type_enabled(v39, OS_LOG_TYPE_FAULT))
        {
          int v40 = *__error();
          int v41 = __error();
          id v42 = strerror(*v41);
          *(_DWORD *)buf = 136315906;
          uint64_t v77 = "ret == 0";
          __int16 v78 = 2048;
          off_t v79 = v14;
          __int16 v80 = 1024;
          int v81 = v40;
          __int16 v82 = 2080;
          int v83 = v42;
          _os_log_fault_impl((void *)&_mh_execute_header, v39, OS_LOG_TYPE_FAULT, "Unable to format: %s: Unable to seek back to %lld after searching for load infos: %d (%s)", buf, 0x26u);
        }
        if (qword_1000EBD00) {
          uint64_t v43 = (FILE *)qword_1000EBD00;
        }
        else {
          uint64_t v43 = __stderrp;
        }
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v43);
      }
      *__error() = v33;
    }
    __error();
    int v44 = __error();
    strerror(*v44);
    sub_10002E41C("LookaheadLines", "SPTextualReportParser.m", 1008, "%s: Unable to seek back to %lld after searching for load infos: %d (%s)", v45, v46, v47, v48, (char)"ret == 0");
    abort();
  }
  _Block_object_dispose(&v68, 8);
  _Block_object_dispose(&v72, 8);
}

void sub_10007FAF8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va1, a11);
  va_start(va, a11);
  uint64_t v12 = va_arg(va1, void);
  uint64_t v14 = va_arg(va1, void);
  uint64_t v15 = va_arg(va1, void);
  uint64_t v16 = va_arg(va1, void);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

int *sub_10007FB58(uint64_t a1, void *a2, uint64_t a3, unsigned char *a4)
{
  if (*(unsigned char *)(*(void *)(*(void *)(a1 + 48) + 8) + 24))
  {
    id v8 = [[*(id *)(a1 + 32) firstMatchInString:a2 options:0 range:[a2 length]];
    if (v8)
    {
      uint64_t v9 = v8;
      int v10 = *(unsigned __int8 *)(a1 + 56);
      id v11 = [v8 rangeWithName:@"kernelDot"];
      if (v10)
      {
        id v12 = [v9 rangeWithName:@"binaryIndex"];
        if (v12 == (id)0x7FFFFFFFFFFFFFFFLL)
        {
          uint64_t v97 = a3;
          if (byte_1000EBCF8)
          {
            int v98 = *__error();
            id v99 = sub_10002E548();
            if (os_log_type_enabled(v99, OS_LOG_TYPE_ERROR)) {
              sub_10009AC78();
            }
            *__error() = v98;
          }
          if (byte_1000EBCF9) {
            BOOL v100 = dword_1000EB4A8 <= 3;
          }
          else {
            BOOL v100 = 0;
          }
          if (v100)
          {
            int v101 = *__error();
            CFStringRef v102 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%s: Parsing spindump text: No binary index (%d: %s)", "range.location != NSNotFound", v97, [a2 UTF8String]);
            if (v102)
            {
              CFStringRef v113 = v102;
              CStringPtr = CFStringGetCStringPtr(v102, 0x8000100u);
              if (CStringPtr)
              {
                unsigned __int8 v115 = (char *)CStringPtr;
                id v116 = 0;
              }
              else
              {
                unsigned __int8 v115 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x4D37C403uLL);
                CFStringGetCString(v113, v115, 1024, 0x8000100u);
                id v116 = v115;
              }
              if (qword_1000EBD00) {
                uint64_t v127 = (FILE *)qword_1000EBD00;
              }
              else {
                uint64_t v127 = __stderrp;
              }
              fprintf(v127, "%s\n", v115);
              if (v116) {
                free(v116);
              }
              CFRelease(v113);
            }
            else
            {
              int v103 = sub_10002E548();
              if (os_log_type_enabled(v103, OS_LOG_TYPE_FAULT)) {
                sub_10009ABF4();
              }
              if (qword_1000EBD00) {
                uint64_t v104 = (FILE *)qword_1000EBD00;
              }
              else {
                uint64_t v104 = __stderrp;
              }
              fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v104);
            }
            *__error() = v101;
          }
          [a2 UTF8String];
          sub_10002E41C("ParseLoadInfoLine", "SPTextualReportParser.m", 2343, "%s: Parsing spindump text: No binary index (%d: %s)", v128, v129, v130, v131, (char)"range.location != NSNotFound");
          goto LABEL_198;
        }
        unint64_t v14 = sub_10007E83C([a2 substringWithRange:v12, v13]);
      }
      else
      {
        unint64_t v14 = 0;
      }
      id v25 = [v9 rangeWithName:@"startAddress"];
      if (v25 == (id)0x7FFFFFFFFFFFFFFFLL) {
        unint64_t v135 = 0;
      }
      else {
        unint64_t v135 = sub_10007E83C([a2 substringWithRange:v25, v26]);
      }
      integer_t v132 = a4;
      id v27 = [v9 rangeWithName:@"endAddress"];
      if (v27 == (id)0x7FFFFFFFFFFFFFFFLL) {
        unint64_t v134 = 0;
      }
      else {
        unint64_t v134 = sub_10007E83C([a2 substringWithRange:v27, v28]);
      }
      id v29 = [v9 rangeWithName:@"bundleIdentifier"];
      if (v29 == (id)0x7FFFFFFFFFFFFFFFLL) {
        id v31 = 0;
      }
      else {
        id v31 = [a2 substringWithRange:v29, v30];
      }
      id v32 = [v9 rangeWithName:@"name"];
      if (v32 == (id)0x7FFFFFFFFFFFFFFFLL) {
        id v34 = 0;
      }
      else {
        id v34 = [a2 substringWithRange:v32, v33];
      }
      int v136 = (int *)v14;
      id v35 = [v9 rangeWithName:@"version"];
      if (v35 == (id)0x7FFFFFFFFFFFFFFFLL) {
        id v37 = 0;
      }
      else {
        id v37 = [a2 substringWithRange:v35, v36];
      }
      id v38 = [v9 rangeWithName:@"binaryUuid"];
      if (v38 == (id)0x7FFFFFFFFFFFFFFFLL)
      {
        if (byte_1000EBCF8)
        {
          int v85 = *__error();
          CFStringRef v86 = sub_10002E548();
          if (os_log_type_enabled(v86, OS_LOG_TYPE_ERROR)) {
            sub_10009AA68();
          }
          *__error() = v85;
        }
        if (byte_1000EBCF9 && dword_1000EB4A8 <= 3)
        {
          int v87 = *__error();
          CFStringRef v88 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%s: No uuid in load info (%d: %s)", "range.location != NSNotFound", a3, [a2 UTF8String]);
          if (v88)
          {
            CFStringRef v105 = v88;
            BOOL v106 = CFStringGetCStringPtr(v88, 0x8000100u);
            if (v106)
            {
              malloc_type_id_t v107 = (char *)v106;
              int v108 = 0;
            }
            else
            {
              malloc_type_id_t v107 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x7086F3D7uLL);
              CFStringGetCString(v105, v107, 1024, 0x8000100u);
              int v108 = v107;
            }
            if (qword_1000EBD00) {
              CFStringRef v117 = (FILE *)qword_1000EBD00;
            }
            else {
              CFStringRef v117 = __stderrp;
            }
            fprintf(v117, "%s\n", v107);
            if (v108) {
              free(v108);
            }
            CFRelease(v105);
          }
          else
          {
            int v89 = sub_10002E548();
            if (os_log_type_enabled(v89, OS_LOG_TYPE_FAULT)) {
              sub_10009A9E4();
            }
            if (qword_1000EBD00) {
              id v90 = (FILE *)qword_1000EBD00;
            }
            else {
              id v90 = __stderrp;
            }
            fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v90);
          }
          *__error() = v87;
        }
        [a2 UTF8String];
        sub_10002E41C("ParseLoadInfoLine", "SPTextualReportParser.m", 2391, "%s: No uuid in load info (%d: %s)", v118, v119, v120, v121, (char)"range.location != NSNotFound");
      }
      else
      {
        uint64_t v133 = a3;
        id v40 = sub_100080F84([a2 substringWithRange:v38, v39]);
        id v41 = [v9 rangeWithName:@"segmentName"];
        if (v41 == (id)0x7FFFFFFFFFFFFFFFLL) {
          id v43 = 0;
        }
        else {
          id v43 = [a2 substringWithRange:v41, v42];
        }
        id v44 = [v9 rangeWithName:@"binaryPath"];
        if (v44 == (id)0x7FFFFFFFFFFFFFFFLL) {
          id v46 = 0;
        }
        else {
          id v46 = [a2 substringWithRange:v44, v45];
        }
        id v47 = v31;
        id v48 = v34;
        id v49 = v37;
        id v50 = v40;
        id v51 = v43;
        id v52 = v46;
        if (v40)
        {
          if (*(unsigned char *)(a1 + 56) && (unint64_t result = (int *)[*(id *)(a1 + 40) count], v136 != result))
          {
            if (byte_1000EBCF8)
            {
              int v57 = *__error();
              int v58 = sub_10002E548();
              if (os_log_type_enabled(v58, OS_LOG_TYPE_ERROR))
              {
                id v82 = [*(id *)(a1 + 40) count];
                *(_DWORD *)buf = 134218754;
                *(void *)uint64_t v138 = v82;
                *(_WORD *)&v138[8] = 2048;
                *(void *)&unsigned char v138[10] = v136;
                __int16 v139 = 1024;
                int v140 = v133;
                __int16 v141 = 2112;
                int v142 = a2;
                _os_log_error_impl((void *)&_mh_execute_header, v58, OS_LOG_TYPE_ERROR, "Parsing spindump text: corrupt condensed file, binary at position %lu has index %lu (%d: %@)", buf, 0x26u);
              }
              unint64_t result = __error();
              int *result = v57;
            }
            if (byte_1000EBCF9 && dword_1000EB4A8 <= 3)
            {
              int v59 = *__error();
              CFStringRef v60 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"Parsing spindump text: corrupt condensed file, binary at position %lu has index %lu (%d: %@)", [*(id *)(a1 + 40) count], v136, v133, a2);
              if (v60)
              {
                CFStringRef v61 = v60;
                CFStringRef v62 = CFStringGetCStringPtr(v60, 0x8000100u);
                if (v62)
                {
                  id v63 = (char *)v62;
                  id v64 = 0;
                }
                else
                {
                  id v63 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xDA92CAC3uLL);
                  CFStringGetCString(v61, v63, 1024, 0x8000100u);
                  id v64 = v63;
                }
                if (qword_1000EBD00) {
                  off_t v79 = (FILE *)qword_1000EBD00;
                }
                else {
                  off_t v79 = __stderrp;
                }
                fprintf(v79, "%s\n", v63);
                if (v64) {
                  free(v64);
                }
                CFRelease(v61);
              }
              else
              {
                uint64_t v76 = sub_10002E548();
                if (os_log_type_enabled(v76, OS_LOG_TYPE_FAULT))
                {
                  id v84 = [*(id *)(a1 + 40) count];
                  *(_DWORD *)buf = 134218754;
                  *(void *)uint64_t v138 = v84;
                  *(_WORD *)&v138[8] = 2048;
                  *(void *)&unsigned char v138[10] = v136;
                  __int16 v139 = 1024;
                  int v140 = v133;
                  __int16 v141 = 2112;
                  int v142 = a2;
                  _os_log_fault_impl((void *)&_mh_execute_header, v76, OS_LOG_TYPE_FAULT, "Unable to format: Parsing spindump text: corrupt condensed file, binary at position %lu has index %lu (%d: %@)", buf, 0x26u);
                }
                if (qword_1000EBD00) {
                  uint64_t v77 = (FILE *)qword_1000EBD00;
                }
                else {
                  uint64_t v77 = __stderrp;
                }
                fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v77);
              }
              unint64_t result = __error();
              int *result = v59;
            }
            *(unsigned char *)(*(void *)(*(void *)(a1 + 48) + 8) + 24) = 0;
            *integer_t v132 = 1;
          }
          else
          {
            if ([v46 isAbsolutePath]) {
              id v53 = v46;
            }
            else {
              id v53 = 0;
            }
            CFStringRef v54 = +[SABinary binaryWithUUID:v40 absolutePath:v53];
            if (![(SABinary *)v54 path] && v46) {
              [(SABinary *)v54 addPath:v46];
            }
            int v55 = sub_100075B10([SPLoadInfo alloc], v54, v11 != (id)0x7FFFFFFFFFFFFFFFLL, v135, v134, v31, v34, v37, v43);
            int v56 = *(void **)(a1 + 40);
            return (int *)[v56 addObject:v55];
          }
          return result;
        }
        if (byte_1000EBCF8)
        {
          int v91 = *__error();
          BOOL v92 = sub_10002E548();
          if (os_log_type_enabled(v92, OS_LOG_TYPE_ERROR)) {
            sub_10009AB70();
          }
          *__error() = v91;
        }
        if (byte_1000EBCF9 && dword_1000EB4A8 <= 3)
        {
          int v93 = *__error();
          CFStringRef v94 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%s: No UUID in (%d: %s)", "uuid", v133, [a2 UTF8String]);
          if (v94)
          {
            CFStringRef v109 = v94;
            id v110 = CFStringGetCStringPtr(v94, 0x8000100u);
            if (v110)
            {
              BOOL v111 = (char *)v110;
              int v112 = 0;
            }
            else
            {
              BOOL v111 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xEFE6DB91uLL);
              CFStringGetCString(v109, v111, 1024, 0x8000100u);
              int v112 = v111;
            }
            if (qword_1000EBD00) {
              id v122 = (FILE *)qword_1000EBD00;
            }
            else {
              id v122 = __stderrp;
            }
            fprintf(v122, "%s\n", v111);
            if (v112) {
              free(v112);
            }
            CFRelease(v109);
          }
          else
          {
            CFStringRef v95 = sub_10002E548();
            if (os_log_type_enabled(v95, OS_LOG_TYPE_FAULT)) {
              sub_10009AAEC();
            }
            if (qword_1000EBD00) {
              CFStringRef v96 = (FILE *)qword_1000EBD00;
            }
            else {
              CFStringRef v96 = __stderrp;
            }
            fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v96);
          }
          *__error() = v93;
        }
        [a2 UTF8String];
        sub_10002E41C("CopyNextLoadInfos_block_invoke", "SPTextualReportParser.m", 1066, "%s: No UUID in (%d: %s)", v123, v124, v125, v126, (char)"uuid");
      }
LABEL_198:
      abort();
    }
    unint64_t result = (int *)[a2 length];
    if (result)
    {
      if (byte_1000EBCF8)
      {
        int v16 = *__error();
        id v17 = sub_10002E548();
        if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR)) {
          sub_10009A97C();
        }
        unint64_t result = __error();
        int *result = v16;
      }
      if (byte_1000EBCF9) {
        BOOL v18 = dword_1000EB4A8 <= 3;
      }
      else {
        BOOL v18 = 0;
      }
      if (v18)
      {
        int v19 = *__error();
        CFStringRef v20 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"Parsing spindump text: Unexpected line in load infos, ignoring (%d: %@)", a3, a2);
        if (v20)
        {
          CFStringRef v21 = v20;
          uint64_t v22 = CFStringGetCStringPtr(v20, 0x8000100u);
          if (v22)
          {
            uint64_t v23 = (char *)v22;
            uint64_t v24 = 0;
          }
          else
          {
            uint64_t v23 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x620F5784uLL);
            CFStringGetCString(v21, v23, 1024, 0x8000100u);
            uint64_t v24 = v23;
          }
          if (qword_1000EBD00) {
            __int16 v78 = (FILE *)qword_1000EBD00;
          }
          else {
            __int16 v78 = __stderrp;
          }
          fprintf(v78, "%s\n", v23);
          if (v24) {
            free(v24);
          }
          CFRelease(v21);
        }
        else
        {
          uint64_t v74 = sub_10002E548();
          if (os_log_type_enabled(v74, OS_LOG_TYPE_FAULT)) {
            sub_10009A90C();
          }
          if (qword_1000EBD00) {
            uint64_t v75 = (FILE *)qword_1000EBD00;
          }
          else {
            uint64_t v75 = __stderrp;
          }
          fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v75);
        }
        unint64_t result = __error();
        int *result = v19;
      }
    }
    else
    {
      unint64_t result = (int *)[*(id *)(a1 + 40) count];
      if (!result)
      {
        if (byte_1000EBCF8)
        {
          int v65 = *__error();
          CFStringRef v66 = sub_10002E548();
          if (os_log_type_enabled(v66, OS_LOG_TYPE_INFO))
          {
            *(_DWORD *)buf = 67109378;
            *(_DWORD *)uint64_t v138 = a3;
            *(_WORD *)&v138[4] = 2112;
            *(void *)&v138[6] = a2;
            _os_log_impl((void *)&_mh_execute_header, v66, OS_LOG_TYPE_INFO, "Parsing spindump text: No load infos, ended at line (%d: %@)", buf, 0x12u);
          }
          unint64_t result = __error();
          int *result = v65;
        }
        if (byte_1000EBCF9) {
          BOOL v67 = dword_1000EB4A8 <= 1;
        }
        else {
          BOOL v67 = 0;
        }
        if (v67)
        {
          int v68 = *__error();
          CFStringRef v69 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"Parsing spindump text: No load infos, ended at line (%d: %@)", a3, a2);
          if (v69)
          {
            CFStringRef v70 = v69;
            int v71 = CFStringGetCStringPtr(v69, 0x8000100u);
            if (v71)
            {
              uint64_t v72 = (char *)v71;
              uint64_t v73 = 0;
            }
            else
            {
              uint64_t v72 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x6C14095BuLL);
              CFStringGetCString(v70, v72, 1024, 0x8000100u);
              uint64_t v73 = v72;
            }
            if (qword_1000EBD00) {
              int v83 = (FILE *)qword_1000EBD00;
            }
            else {
              int v83 = __stderrp;
            }
            fprintf(v83, "%s\n", v72);
            if (v73) {
              free(v73);
            }
            CFRelease(v70);
          }
          else
          {
            __int16 v80 = sub_10002E548();
            if (os_log_type_enabled(v80, OS_LOG_TYPE_FAULT)) {
              sub_10009A89C();
            }
            if (qword_1000EBD00) {
              int v81 = (FILE *)qword_1000EBD00;
            }
            else {
              int v81 = __stderrp;
            }
            fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v81);
          }
          unint64_t result = __error();
          int *result = v68;
        }
      }
      *a4 = 1;
    }
  }
  else
  {
    unint64_t result = (int *)[a2 containsString:@"Binary Images:"];
    if (result) {
      *(unsigned char *)(*(void *)(*(void *)(a1 + 48) + 8) + 24) = 1;
    }
  }
  return result;
}

void *sub_100080B2C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = a1 + 32;
  uint64_t v10 = *(void *)(*(void *)(a1 + 32) + 8);
  int v11 = *(_DWORD *)(v10 + 24);
  if (v11)
  {
    *(_DWORD *)(v10 + 24) = 2 * v11;
    int v12 = *(_DWORD *)(*(void *)(*(void *)v9 + 8) + 24);
    if (v12 <= 0)
    {
      if (byte_1000EBCF8)
      {
        int v13 = *__error();
        unint64_t v14 = sub_10002E548();
        if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR)) {
          sub_10009A30C();
        }
        *__error() = v13;
      }
      if (byte_1000EBCF9) {
        BOOL v15 = dword_1000EB4A8 <= 3;
      }
      else {
        BOOL v15 = 0;
      }
      if (v15)
      {
        int v16 = *__error();
        CFStringRef v17 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%s: bufSize overflow (%d)", "bufSize > 0", *(unsigned int *)(*(void *)(*(void *)v9 + 8) + 24));
        if (v17)
        {
          CFStringRef v36 = v17;
          CStringPtr = CFStringGetCStringPtr(v17, 0x8000100u);
          if (CStringPtr)
          {
            id v38 = (char *)CStringPtr;
            uint64_t v39 = 0;
          }
          else
          {
            id v38 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x91C41402uLL);
            CFStringGetCString(v36, v38, 1024, 0x8000100u);
            uint64_t v39 = v38;
          }
          if (qword_1000EBD00) {
            id v40 = (FILE *)qword_1000EBD00;
          }
          else {
            id v40 = __stderrp;
          }
          fprintf(v40, "%s\n", v38);
          if (v39) {
            free(v39);
          }
          CFRelease(v36);
        }
        else
        {
          BOOL v18 = sub_10002E548();
          if (os_log_type_enabled(v18, OS_LOG_TYPE_FAULT)) {
            sub_10009A294();
          }
          if (qword_1000EBD00) {
            int v19 = (FILE *)qword_1000EBD00;
          }
          else {
            int v19 = __stderrp;
          }
          fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v19);
        }
        *__error() = v16;
      }
      sub_10002E41C("LookaheadLines_block_invoke", "SPTextualReportParser.m", 976, "%s: bufSize overflow (%d)", a5, a6, a7, a8, (char)"bufSize > 0");
      goto LABEL_56;
    }
  }
  else
  {
    *(_DWORD *)(v10 + 24) = 0x4000;
    int v12 = *(_DWORD *)(*(void *)(*(void *)v9 + 8) + 24);
  }
  unint64_t result = reallocf(*(void **)(*(void *)(*(void *)(a1 + 40) + 8) + 24), v12);
  *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = result;
  if (!*(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 24))
  {
    if (byte_1000EBCF8)
    {
      int v25 = *__error();
      uint64_t v26 = sub_10002E548();
      if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR)) {
        sub_10009A220();
      }
      *__error() = v25;
    }
    if (byte_1000EBCF9 && dword_1000EB4A8 <= 3)
    {
      int v27 = *__error();
      CFStringRef v28 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%s: Unable to allocate %d buffer", "buf", *(unsigned int *)(*(void *)(*(void *)v9 + 8) + 24));
      if (v28)
      {
        CFStringRef v31 = v28;
        id v32 = CFStringGetCStringPtr(v28, 0x8000100u);
        if (v32)
        {
          uint64_t v33 = (char *)v32;
          id v34 = 0;
        }
        else
        {
          uint64_t v33 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xFCFB37F6uLL);
          CFStringGetCString(v31, v33, 1024, 0x8000100u);
          id v34 = v33;
        }
        if (qword_1000EBD00) {
          id v35 = (FILE *)qword_1000EBD00;
        }
        else {
          id v35 = __stderrp;
        }
        fprintf(v35, "%s\n", v33);
        if (v34) {
          free(v34);
        }
        CFRelease(v31);
      }
      else
      {
        id v29 = sub_10002E548();
        if (os_log_type_enabled(v29, OS_LOG_TYPE_FAULT)) {
          sub_10009A1A8();
        }
        if (qword_1000EBD00) {
          uint64_t v30 = (FILE *)qword_1000EBD00;
        }
        else {
          uint64_t v30 = __stderrp;
        }
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v30);
      }
      *__error() = v27;
    }
    sub_10002E41C("LookaheadLines_block_invoke", "SPTextualReportParser.m", 979, "%s: Unable to allocate %d buffer", v21, v22, v23, v24, (char)"buf");
LABEL_56:
    abort();
  }
  return result;
}

id sub_100080F84(void *a1)
{
  id v2 = [objc_alloc((Class)NSUUID) initWithUUIDString:a1];
  if (!v2)
  {
    if ((unint64_t)[a1 length] < 0x20)
    {
      id v2 = 0;
    }
    else
    {
      id v3 = [objc_alloc((Class)NSString) initWithFormat:@"%@-%@-%@-%@-%@", [a1 substringWithRange:0, 8], [a1 substringWithRange:8, 4], [a1 substringWithRange:12, 4], [a1 substringWithRange:16, 4], [a1 substringWithRange:20, 12]];
      id v2 = [objc_alloc((Class)NSUUID) initWithUUIDString:v3];
    }
  }

  return v2;
}

uint64_t sub_1000810B4(uint64_t a1, uint64_t a2)
{
  if (a2) {
    unint64_t v2 = *(void *)(a2 + 56);
  }
  else {
    unint64_t v2 = 0;
  }
  unint64_t v3 = *(void *)(a1 + 32);
  BOOL v4 = v3 > v2;
  if (v3 >= v2) {
    uint64_t v5 = 0;
  }
  else {
    uint64_t v5 = -1;
  }
  if (v4) {
    return 1;
  }
  else {
    return v5;
  }
}

void sub_1000810D8(uint64_t a1, uint64_t a2)
{
}

void sub_1000810E8(uint64_t a1)
{
}

id *sub_1000810F4(uint64_t a1, void *a2, uint64_t a3, unsigned char *a4)
{
  if (!*(unsigned char *)(a1 + 104)
    && (([a2 hasPrefix:@"Process:"] & 1) != 0
     || [a2 hasPrefix:@"Powerstats for:"]))
  {
    long long v23 = 0u;
    long long v24 = 0u;
    long long v21 = 0u;
    long long v22 = 0u;
    id v8 = *(void **)(a1 + 32);
    id v9 = [v8 countByEnumeratingWithState:&v21 objects:v25 count:16];
    if (v9)
    {
      id v10 = v9;
      uint64_t v11 = *(void *)v22;
      do
      {
        for (uint64_t i = 0; i != v10; uint64_t i = (char *)i + 1)
        {
          if (*(void *)v22 != v11) {
            objc_enumerationMutation(v8);
          }
          *(unsigned char *)(*(void *)(*(void *)(a1 + 80) + 8) + 24) = [a2 containsString:*(void *)(*((void *)&v21 + 1) + 8 * i)];
        }
        id v10 = [v8 countByEnumeratingWithState:&v21 objects:v25 count:16];
      }
      while (v10);
    }
  }
  unint64_t result = (id *)[a2 containsString:@"Binary Images:"];
  if (result)
  {
    if (!*(unsigned char *)(a1 + 105))
    {

      unint64_t result = (id *)sub_10007CBB4(*(FILE **)(a1 + 96), a3, *(void *)(a1 + 40), *(unsigned char *)(a1 + 105));
      *(void *)(*(void *)(*(void *)(a1 + 88) + 8) + 40) = result;
      if (!*(void *)(*(void *)(*(void *)(a1 + 88) + 8) + 40)) {
        *a4 = 1;
      }
    }
  }
  else
  {
    unint64_t result = [(id *)objc_msgSend(*(id *)(a1 + 48), "firstMatchInString:options:range:", a2, 0, 0, objc_msgSend(a2, "length"))];
    if (result)
    {
      unint64_t v20 = -1;
      unint64_t result = (id *)sub_10007CD64(a2, a3, result, *(void **)(*(void *)(*(void *)(a1 + 88) + 8) + 40), *(unsigned __int8 *)(a1 + 105), &v20);
      if (result)
      {
        unint64_t v14 = result;
        if (!objc_msgSend(*(id *)(a1 + 56), "objectForKeyedSubscript:", objc_msgSend(result[5], "uuid"))) {
          [*(id *)(a1 + 56) setObject:v14[5] forKeyedSubscript:[v14[5] uuid]];
        }
        if (*(unsigned char *)(*(void *)(*(void *)(a1 + 80) + 8) + 24)) {
          [*(id *)(a1 + 64) addObject:[v14[5] uuid]];
        }
        id v15 = [[*(id *)(a1 + 72) objectForKeyedSubscript:objc_msgSend(v14[5], "uuid")];
        if (!v15)
        {
          id v15 = +[NSMutableDictionary dictionary];
          [*(id *)(a1 + 72) setObject:v15 forKeyedSubscript:[v14[5] uuid]];
        }
        int v16 = (NSNull *)v14[6];
        if (!v16) {
          int v16 = +[NSNull null];
        }
        id v17 = [v15 objectForKeyedSubscript:v16];
        if (!v17)
        {
          id v17 = +[NSMutableSet set];
          BOOL v18 = (NSNull *)v14[6];
          if (!v18) {
            BOOL v18 = +[NSNull null];
          }
          [v15 setObject:v17 forKeyedSubscript:v18];
        }
        unint64_t v19 = v20;
        [v17 addObject:[+[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:", v20)]];
        return (id *)[v17 addObject:+[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:", v19 - 1)];
      }
    }
  }
  return result;
}

int *sub_100081440(uint64_t a1, uint64_t a2, void *a3)
{
  if (objc_msgSend(*(id *)(a1 + 32), "containsObject:", objc_msgSend(a3, "uuid"))) {
    uint64_t v5 = 636;
  }
  else {
    uint64_t v5 = 628;
  }
  unint64_t result = (int *)[a3 cacheSymbolOwnerWithOptions:v5 pid:0xFFFFFFFFLL];
  if (result)
  {
    id v7 = [[*(id *)(a1 + 40) objectForKeyedSubscript:objc_msgSend(a3, "uuid")];
    v24[0] = _NSConcreteStackBlock;
    v24[1] = 3221225472;
    v24[2] = sub_100081760;
    v24[3] = &unk_1000DDDB8;
    v24[4] = a3;
    [v7 enumerateKeysAndObjectsUsingBlock:v24];
    [a3 symbolicateAllInstructionsWithOptions:628 pid:0xFFFFFFFFLL];
    return (int *)[a3 clearCoreSymbolicationCache];
  }
  else
  {
    if (byte_1000EBCF8)
    {
      int v8 = *__error();
      id v9 = sub_10002E548();
      if (os_log_type_enabled(v9, OS_LOG_TYPE_INFO))
      {
        id v10 = [a3 uuid];
        id v11 = [a3 path];
        if (!v11) {
          id v11 = [a3 name];
        }
        *(_DWORD *)buf = 138412546;
        id v26 = v10;
        __int16 v27 = 2112;
        id v28 = v11;
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_INFO, "Parsing spindump text: Unable to find symbol owner for %@ %@", buf, 0x16u);
      }
      unint64_t result = __error();
      int *result = v8;
    }
    if (byte_1000EBCF9) {
      BOOL v12 = dword_1000EB4A8 <= 1;
    }
    else {
      BOOL v12 = 0;
    }
    if (v12)
    {
      int v13 = *__error();
      id v14 = [a3 uuid];
      id v15 = [a3 path];
      if (!v15) {
        id v15 = [a3 name];
      }
      CFStringRef v16 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"Parsing spindump text: Unable to find symbol owner for %@ %@", v14, v15);
      if (v16)
      {
        CFStringRef v17 = v16;
        CStringPtr = CFStringGetCStringPtr(v16, 0x8000100u);
        if (CStringPtr)
        {
          unint64_t v19 = (char *)CStringPtr;
          unint64_t v20 = 0;
        }
        else
        {
          unint64_t v19 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x2EC80C27uLL);
          CFStringGetCString(v17, v19, 1024, 0x8000100u);
          unint64_t v20 = v19;
        }
        if (qword_1000EBD00) {
          long long v23 = (FILE *)qword_1000EBD00;
        }
        else {
          long long v23 = __stderrp;
        }
        fprintf(v23, "%s\n", v19);
        if (v20) {
          free(v20);
        }
        CFRelease(v17);
      }
      else
      {
        long long v21 = sub_10002E548();
        if (os_log_type_enabled(v21, OS_LOG_TYPE_FAULT)) {
          sub_10009ACFC(a3, v21);
        }
        if (qword_1000EBD00) {
          long long v22 = (FILE *)qword_1000EBD00;
        }
        else {
          long long v22 = __stderrp;
        }
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v22);
      }
      unint64_t result = __error();
      int *result = v13;
    }
  }
  return result;
}

int *sub_100081760(uint64_t a1, NSNull *a2, void *a3)
{
  if (+[NSNull null] == a2)
  {
    long long v30 = 0u;
    long long v31 = 0u;
    long long v28 = 0u;
    long long v29 = 0u;
    unint64_t result = (int *)[a3 countByEnumeratingWithState:&v28 objects:v36 count:16];
    if (result)
    {
      int v13 = result;
      uint64_t v14 = *(void *)v29;
      do
      {
        id v15 = 0;
        do
        {
          if (*(void *)v29 != v14) {
            objc_enumerationMutation(a3);
          }
          [*(id *)(a1 + 32) instructionAtOffsetIntoBinary:[*(id *)(*((void *)&v28 + 1) + 8 * (void)v15) unsignedLongLongValue]];
          id v15 = (int *)((char *)v15 + 1);
        }
        while (v13 != v15);
        unint64_t result = (int *)[a3 countByEnumeratingWithState:&v28 objects:v36 count:16];
        int v13 = result;
      }
      while (result);
    }
  }
  else
  {
    id v7 = *(void **)(a1 + 32);
    off_t v6 = (id *)(a1 + 32);
    unint64_t result = (int *)[v7 segmentWithName:a2];
    if (result)
    {
      id v9 = result;
      long long v34 = 0u;
      long long v35 = 0u;
      long long v32 = 0u;
      long long v33 = 0u;
      unint64_t result = (int *)[a3 countByEnumeratingWithState:&v32 objects:v37 count:16];
      if (result)
      {
        id v10 = result;
        uint64_t v11 = *(void *)v33;
        do
        {
          BOOL v12 = 0;
          do
          {
            if (*(void *)v33 != v11) {
              objc_enumerationMutation(a3);
            }
            [v9 instructionAtOffsetIntoSegment:[*(id *)(*((void *)&v32 + 1) + 8 * (void)v12) unsignedLongLongValue]];
            BOOL v12 = (int *)((char *)v12 + 1);
          }
          while (v10 != v12);
          unint64_t result = (int *)[a3 countByEnumeratingWithState:&v32 objects:v37 count:16];
          id v10 = result;
        }
        while (result);
      }
    }
    else
    {
      if (byte_1000EBCF8)
      {
        int v16 = *__error();
        CFStringRef v17 = sub_10002E548();
        if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR)) {
          sub_10009AE50((uint64_t)a2, v6);
        }
        unint64_t result = __error();
        int *result = v16;
      }
      if (byte_1000EBCF9) {
        BOOL v18 = dword_1000EB4A8 <= 3;
      }
      else {
        BOOL v18 = 0;
      }
      if (v18)
      {
        int v19 = *__error();
        CFStringRef v20 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"Parsing spindump text: Unable to find segment %@ in %@ %@", a2, [*v6 uuid], [*v6 name]);
        if (v20)
        {
          CFStringRef v21 = v20;
          CStringPtr = CFStringGetCStringPtr(v20, 0x8000100u);
          if (CStringPtr)
          {
            long long v23 = (char *)CStringPtr;
            long long v24 = 0;
          }
          else
          {
            long long v23 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xCE4B975BuLL);
            CFStringGetCString(v21, v23, 1024, 0x8000100u);
            long long v24 = v23;
          }
          if (qword_1000EBD00) {
            __int16 v27 = (FILE *)qword_1000EBD00;
          }
          else {
            __int16 v27 = __stderrp;
          }
          fprintf(v27, "%s\n", v23);
          if (v24) {
            free(v24);
          }
          CFRelease(v21);
        }
        else
        {
          int v25 = sub_10002E548();
          if (os_log_type_enabled(v25, OS_LOG_TYPE_FAULT)) {
            sub_10009ADB8((uint64_t)a2, v6);
          }
          if (qword_1000EBD00) {
            id v26 = (FILE *)qword_1000EBD00;
          }
          else {
            id v26 = __stderrp;
          }
          fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v26);
        }
        unint64_t result = __error();
        int *result = v19;
      }
    }
  }
  return result;
}

id sub_100081AD4(void *a1, void *a2, uint64_t a3, uint64_t a4, unsigned int a5, int a6)
{
  id v13 = [a2 rangeWithName:@"fakeFrameInfo"];
  if (v13 != (id)0x7FFFFFFFFFFFFFFFLL)
  {
    id v18 = [objc_alloc((Class)NSArray) initWithObjects:[a1 substringWithRange:v13, v14], 0];
LABEL_5:
    id v19 = v18;
    goto LABEL_22;
  }
  id v15 = [a2 rangeWithName:@"symbolName"];
  id v43 = v12;
  if (v15 == (id)0x7FFFFFFFFFFFFFFFLL)
  {
    id v17 = 0;
  }
  else
  {
    id v20 = [a1 substringWithRange:v15, v16];
    if ([v20 isEqualToString:@"???"]) {
      id v17 = 0;
    }
    else {
      id v17 = v20;
    }
  }
  id v21 = [a2 rangeWithName:@"sourceFilepath"];
  if (v21 == (id)0x7FFFFFFFFFFFFFFFLL) {
    id v23 = 0;
  }
  else {
    id v23 = [a1 substringWithRange:v21, v22];
  }
  id v24 = [a2 rangeWithName:@"binaryName"];
  if (v24 != (id)0x7FFFFFFFFFFFFFFFLL)
  {
    long long v29 = (NSString *)[a1 substringWithRange:v24, v25];
LABEL_17:
    long long v28 = v29;
    goto LABEL_18;
  }
  id v26 = [a2 rangeWithName:@"binaryUuid"];
  if (v26 != (id)0x7FFFFFFFFFFFFFFFLL)
  {
    long long v29 = +[NSString stringWithFormat:@"<%@>", [a1 substringWithRange:v26, v27]];
    goto LABEL_17;
  }
  long long v28 = 0;
LABEL_18:
  v46[0] = _NSConcreteStackBlock;
  v46[1] = 3221225472;
  id v47 = sub_100081F30;
  id v48 = &unk_1000DDE08;
  id v49 = a2;
  id v50 = a1;
  id v51 = v17;
  id v52 = v23;
  id v53 = v28;
  if (a6 || a4 == 0x7FFFFFFFFFFFFFFFLL) {
    goto LABEL_20;
  }
  if (!a3 || (long long v32 = *(void **)(a3 + 40)) == 0)
  {
    id v35 = objc_alloc((Class)NSArray);
    BOOL v12 = v43;
    if (v28)
    {
      id v18 = [v35 initWithObjects:v47((uint64_t)v46), 0];
    }
    else
    {
      id v41 = +[NSMutableString string];
      [v41 appendString:@"???"];
      id v18 = [v35 initWithObjects:v41];
    }
    goto LABEL_5;
  }
  if (*(void *)(a3 + 48))
  {
    id v33 = [[*(id *)(a3 + 40) segmentWithName:];
    if (!v33) {
      goto LABEL_20;
    }
    id v34 = [v33 instructionAtOffsetIntoSegment:a4 - a5];
  }
  else
  {
    id v34 = [*(id *)(a3 + 40) instructionAtOffsetIntoBinary:a4 - a5];
  }
  CFStringRef v36 = v34;
  if (!v34)
  {
    id v38 = objc_alloc((Class)NSArray);
    id v39 = +[NSMutableString string];
    [v39 appendString:@"???"];
    id v30 = [v38 initWithObjects:v39];
    goto LABEL_21;
  }
  if ((unint64_t)[v34 numSymbols] <= 1)
  {
    if (v23 || (unsigned __int8 v40 = [v36 hasSourceInfo], v17) && (v40 & 1) == 0)
    {
LABEL_20:
      id v30 = [objc_alloc((Class)NSArray) initWithObjects:v47((uint64_t)v46), 0];
LABEL_21:
      id v19 = v30;
      BOOL v12 = v43;
      goto LABEL_22;
    }
  }
  if ([v32 name]) {
    id v37 = (NSString *)[v32 name];
  }
  else {
    id v37 = [NSString stringWithFormat:@"<%@>", [objc_msgSend(objc_msgSend(v32, "uuid"), "UUIDString") UUIDString]];
  }
  uint64_t v42 = (uint64_t)v37;
  id v19 = objc_alloc_init((Class)NSMutableArray);
  v44[0] = _NSConcreteStackBlock;
  v44[1] = 3221225472;
  v44[2] = sub_1000821DC;
  v44[3] = &unk_1000DDE30;
  char v45 = a5;
  v44[4] = v36;
  v44[5] = v42;
  v44[6] = v19;
  v44[7] = a4;
  [v36 enumerateSymbols:v44];
  BOOL v12 = v43;
  if (![v19 count])
  {

    id v18 = [objc_alloc((Class)NSArray) initWithObjects:sub_100082080(0, -1, 0, 0, 0, v42, a4), 0];
    goto LABEL_5;
  }
LABEL_22:
  return v19;
}

void *sub_100081F30(uint64_t a1)
{
  id v2 = [*(id *)(a1 + 32) rangeWithName:@"offsetIntoSymbol"];
  if (v2 == (id)0x7FFFFFFFFFFFFFFFLL
    && (id v2 = [*(id *)(a1 + 32) rangeWithName:@"offsetIntoUnknownSymbol"],
        v2 == (id)0x7FFFFFFFFFFFFFFFLL))
  {
    unint64_t v4 = -1;
  }
  else
  {
    unint64_t v4 = sub_10007E83C([*(id *)(a1 + 40) substringWithRange:v2, v3]);
  }
  id v5 = [*(id *)(a1 + 32) rangeWithName:@"sourceLineNumber"];
  if (v5 == (id)0x7FFFFFFFFFFFFFFFLL) {
    unint64_t v7 = 0;
  }
  else {
    unint64_t v7 = sub_10007E83C([*(id *)(a1 + 40) substringWithRange:v5, v6]);
  }
  id v8 = [*(id *)(a1 + 32) rangeWithName:@"sourceColumnNumber"];
  if (v8 == (id)0x7FFFFFFFFFFFFFFFLL) {
    unint64_t v10 = 0;
  }
  else {
    unint64_t v10 = sub_10007E83C([*(id *)(a1 + 40) substringWithRange:v8, v9]);
  }
  id v11 = [*(id *)(a1 + 32) rangeWithName:@"offsetIntoBinary"];
  if (v11 == (id)0x7FFFFFFFFFFFFFFFLL) {
    unint64_t v13 = -1;
  }
  else {
    unint64_t v13 = sub_10007E83C([*(id *)(a1 + 40) substringWithRange:v11, v12]);
  }
  uint64_t v14 = *(void *)(a1 + 48);
  uint64_t v15 = *(void *)(a1 + 56);
  uint64_t v16 = *(void *)(a1 + 64);

  return sub_100082080(v14, v4, v15, v7, v10, v16, v13);
}

void *sub_100082080(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  id v14 = +[NSMutableString string];
  uint64_t v15 = v14;
  if (!a1)
  {
    [v14 appendString:@"???"];
    if (!a6) {
      return v15;
    }
    goto LABEL_7;
  }
  [v14 appendString:a1];
  if (a2 != -1) {
    [v15 appendFormat:@" + %llu", a2];
  }
  if (a6)
  {
LABEL_7:
    [v15 appendString:@" ("];
    if (a3)
    {
      [v15 appendString:a3];
      if ((int)a4 >= 1)
      {
        [v15 appendFormat:@":%u", a4];
        if ((int)a5 >= 1) {
          [v15 appendFormat:@",%u", a5];
        }
      }
      [v15 appendString:@" in "];
    }
    [v15 appendFormat:@"%@", a6];
    if (a7 != -1) {
      [v15 appendFormat:@" + %llu", a7];
    }
    [v15 appendString:@""]);
  }
  return v15;
}

id sub_1000821DC(uint64_t a1, void *a2, void *a3)
{
  unint64_t v4 = sub_100082080([a2 name], [*(id *)(a1 + 32) offsetIntoSegment] - [a2 offsetIntoSegment] + *(unsigned __int8 *)(a1 + 64), [a3 fileName], [a3 lineNum], [a3 columnNum], *(void *)(a1 + 40), *(void *)(a1 + 56));
  id v5 = *(void **)(a1 + 48);

  return [v5 addObject:v4];
}

unint64_t sub_100082298(uint64_t a1, void *a2, uint64_t a3, unsigned char *a4)
{
  id v8 = [[*(id *)(a1 + 32) firstMatchInString:a2 options:0 range:[a2 length]];
  if (v8)
  {
    uint64_t v9 = v8;
    *a4 = 1;
    unint64_t result = sub_10007CCCC(a2, v8, *(unsigned __int8 *)(a1 + 116), *(_DWORD *)(a1 + 104), *(_DWORD *)(a1 + 108));
    BOOL v11 = 0;
    if ((int)result > *(_DWORD *)(a1 + 112))
    {
      if (*(unsigned char *)(a1 + 117)
        || (unint64_t result = (unint64_t)[v9 rangeWithName:@"kernelDot"],
            result == 0x7FFFFFFFFFFFFFFFLL))
      {
        BOOL v11 = 1;
      }
    }
    uint64_t v12 = *(unsigned char **)(a1 + 80);
    **(unsigned char **)(a1 + 72) = v11;
    if (!*v12)
    {
      uint64_t v13 = *(void *)(a1 + 48);
      if (v13)
      {
        if (*(void *)(v13 + 40))
        {
          if (*(void *)(a1 + 88) != -1)
          {
            unint64_t v17 = -1;
            unint64_t result = (unint64_t)sub_10007CD64(a2, a3, v9, *(void **)(a1 + 56), *(unsigned __int8 *)(a1 + 116), &v17);
            if (*(void *)(a1 + 48) == result && v17 == *(void *)(a1 + 88))
            {
              unint64_t result = (unint64_t)[v9 rangeWithName:@"symbolName"];
              uint64_t v15 = *(void *)(a1 + 64);
              if (result == 0x7FFFFFFFFFFFFFFFLL)
              {
                if (v15)
                {
LABEL_23:
                  **(unsigned char **)(a1 + 80) = 1;
                  return result;
                }
              }
              else
              {
                if (!v15) {
                  goto LABEL_23;
                }
                unint64_t result = (unint64_t)[*(id *)(a1 + 64) isEqual:[a2 substringWithRange:result, v14]];
                if ((result & 1) == 0) {
                  goto LABEL_23;
                }
              }
              unint64_t result = (unint64_t)[v9 rangeWithName:@"offsetIntoSymbol"];
              if (result != 0x7FFFFFFFFFFFFFFFLL)
              {
                unint64_t result = sub_10007E83C([a2 substringWithRange:result, v16]);
                if (result != *(void *)(a1 + 96)) {
                  goto LABEL_23;
                }
              }
            }
          }
        }
      }
    }
  }
  else
  {
    unint64_t result = (unint64_t)[*(id *)(a1 + 40) firstMatchInString:a2 options:0 range:[a2 length]];
    if (!result) {
      *a4 = 1;
    }
  }
  return result;
}

id sub_100082498(uint64_t a1, void *a2, uint64_t a3, unsigned char *a4)
{
  id result = [[*(id *)(a1 + 32) firstMatchInString:a2 options:0 range:[a2 length]];
  if (result)
  {
    uint64_t v9 = result;
    **(unsigned char **)(a1 + 40) = [result rangeWithName:@"startIndex"] == (id)0x7FFFFFFFFFFFFFFFLL;
    id result = [v9 rangeWithName:@"indentWhitespace"];
    if (result == (id)0x7FFFFFFFFFFFFFFFLL) {
      int v11 = -1;
    }
    else {
      int v11 = v10;
    }
    if (v11 < 0)
    {
      if (byte_1000EBCF8)
      {
        int v16 = *__error();
        unint64_t v17 = sub_10002E548();
        if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR)) {
          sub_10009AF6C();
        }
        *__error() = v16;
      }
      if (byte_1000EBCF9) {
        BOOL v18 = dword_1000EB4A8 <= 3;
      }
      else {
        BOOL v18 = 0;
      }
      if (v18)
      {
        int v19 = *__error();
        CFStringRef v20 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%s: frame match with no whitespace indent (%d: %s)", "whitespaceLength >= 0", a3, [a2 UTF8String]);
        if (v20)
        {
          CFStringRef v23 = v20;
          CStringPtr = CFStringGetCStringPtr(v20, 0x8000100u);
          if (CStringPtr)
          {
            uint64_t v25 = (char *)CStringPtr;
            id v26 = 0;
          }
          else
          {
            uint64_t v25 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x6E2BE878uLL);
            CFStringGetCString(v23, v25, 1024, 0x8000100u);
            id v26 = v25;
          }
          if (qword_1000EBD00) {
            uint64_t v27 = (FILE *)qword_1000EBD00;
          }
          else {
            uint64_t v27 = __stderrp;
          }
          fprintf(v27, "%s\n", v25);
          if (v26) {
            free(v26);
          }
          CFRelease(v23);
        }
        else
        {
          id v21 = sub_10002E548();
          if (os_log_type_enabled(v21, OS_LOG_TYPE_FAULT)) {
            sub_10009AEE8();
          }
          if (qword_1000EBD00) {
            uint64_t v22 = (FILE *)qword_1000EBD00;
          }
          else {
            uint64_t v22 = __stderrp;
          }
          fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v22);
        }
        *__error() = v19;
      }
      [a2 UTF8String];
      sub_10002E41C("LookaheadForIndentStyleAndHeavyMode_block_invoke", "SPTextualReportParser.m", 1738, "%s: frame match with no whitespace indent (%d: %s)", v28, v29, v30, v31, (char)"whitespaceLength >= 0");
      abort();
    }
    uint64_t v12 = *(int **)(a1 + 48);
    int v13 = *v12;
    if (*v12 == -1)
    {
      *uint64_t v12 = v11;
    }
    else
    {
      BOOL v14 = __OFSUB__(v11, v13);
      int v15 = v11 - v13;
      if (!((v15 < 0) ^ v14 | (v15 == 0)))
      {
        **(_DWORD **)(a1 + 56) = v15;
        *a4 = 1;
      }
    }
  }
  return result;
}

uint64_t sub_100082778@<X0>(uint64_t result@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  *(void *)(a2 + 4) = a3;
  *(_WORD *)(a2 + 12) = 2080;
  *(void *)(a2 + 14) = result;
  return result;
}

void sub_10008278C(uint64_t a1@<X8>)
{
  *(void *)(v1 - _Block_object_dispose(&STACK[0x2F8], 8) = a1;
}

void sub_1000827B8(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_error_impl(a1, a2, OS_LOG_TYPE_ERROR, a4, &a9, 0x12u);
}

void sub_1000827D4(void *a1, int a2, os_log_t log, const char *a4, uint8_t *a5)
{
  _os_log_error_impl(a1, log, OS_LOG_TYPE_ERROR, a4, a5, 0x16u);
}

uint64_t sub_10008282C(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(void *)(a2 + 4) = v3;
  *(_WORD *)(a2 + 12) = 2080;
  *(void *)(a2 + 14) = a3;
  *(_WORD *)(a2 + 22) = 2080;
  *(void *)(a2 + 24) = result;
  return result;
}

void sub_100082848(void *a1@<X0>, const char *a2@<X3>, uint8_t *a3@<X4>, NSObject *a4@<X8>)
{
  _os_log_error_impl(a1, a4, OS_LOG_TYPE_ERROR, a2, a3, 0x1Cu);
}

void sub_100082864(void *a1@<X0>, const char *a2@<X3>, uint8_t *a3@<X4>, NSObject *a4@<X8>)
{
  _os_log_fault_impl(a1, a4, OS_LOG_TYPE_FAULT, a2, a3, 0x1Cu);
}

void sub_100082880(void *a1, uint64_t a2, os_log_t log, const char *a4, ...)
{
  va_start(va, a4);
  _os_log_error_impl(a1, log, OS_LOG_TYPE_ERROR, a4, (uint8_t *)va, 0x12u);
}

void sub_1000828A0()
{
  dword_1000EB508 = 1064;
}

void sub_1000828CC(uint64_t a1, NSObject *a2)
{
  int v2 = 136315138;
  uint64_t v3 = a1;
  _os_log_fault_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_FAULT, "Unable to format: %s", (uint8_t *)&v2, 0xCu);
}

void sub_100082944(int a1, NSObject *a2)
{
  v2[0] = 67109120;
  v2[1] = a1;
  _os_log_fault_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_FAULT, "Unable to format: Found pid [%d]", (uint8_t *)v2, 8u);
}

void sub_1000829BC(int a1, NSObject *a2)
{
  v2[0] = 67109120;
  v2[1] = a1;
  _os_log_debug_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_DEBUG, "Found pid [%d]", (uint8_t *)v2, 8u);
}

void sub_100082A34()
{
  sub_10002E404();
  _os_log_fault_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_FAULT, "Unable to format: Found pid %s [%d]", v1, 0x12u);
}

void sub_100082AB0()
{
  sub_10002E404();
  _os_log_debug_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_DEBUG, "Found pid %s [%d]", v1, 0x12u);
}

void sub_100082B2C()
{
}

void sub_100082B48(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_100082BC0(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_100082C38()
{
  sub_10003C11C(__stack_chk_guard);
  sub_10003C0EC();
  sub_10003C04C((void *)&_mh_execute_header, v0, v1, "Unable to format: WR: WorkflowResponsivness unavailable, not generating spindump report(s) for %s", v2, v3, v4, v5, v6);
}

void sub_100082CA0()
{
  sub_10003C0EC();
  sub_10003C0A0((void *)&_mh_execute_header, v0, v1, "WR: WorkflowResponsivness unavailable, not generating spindump report(s) for %s", v2, v3, v4, v5, v6);
}

void sub_100082D0C()
{
  sub_10003C11C(__stack_chk_guard);
  sub_10003C0EC();
  sub_10003C04C((void *)&_mh_execute_header, v0, v1, "Unable to format: WR: Unable to decode workflow event tracker: %@", v2, v3, v4, v5, v6);
}

void sub_100082D74()
{
  sub_10003C11C(__stack_chk_guard);
  sub_10003C0EC();
  sub_10003C0A0((void *)&_mh_execute_header, v0, v1, "WR: Unable to decode workflow event tracker: %@", v2, v3, v4, v5, v6);
}

void sub_100082DDC()
{
  sub_10003C0BC();
  sub_10003C04C((void *)&_mh_execute_header, v0, v1, "Unable to format: WR: %@: No workflow event start", v2, v3, v4, v5, v6);
}

void sub_100082E44()
{
  sub_10003C0BC();
  sub_10003C0A0((void *)&_mh_execute_header, v0, v1, "WR: %@: No workflow event start", v2, v3, v4, v5, v6);
}

void sub_100082EAC()
{
  sub_10003C0BC();
  sub_10003C04C((void *)&_mh_execute_header, v0, v1, "Unable to format: WR: %@: No workflow event end", v2, v3, v4, v5, v6);
}

void sub_100082F14()
{
  sub_10003C0BC();
  sub_10003C0A0((void *)&_mh_execute_header, v0, v1, "WR: %@: No workflow event end", v2, v3, v4, v5, v6);
}

void sub_100082F7C()
{
  sub_10003C0BC();
  sub_10003C04C((void *)&_mh_execute_header, v0, v1, "Unable to format: WR: %@: submitted tailspin to Diagnostic Pipeline", v2, v3, v4, v5, v6);
}

void sub_100082FE4()
{
  sub_10003C0E0();
  sub_10003C088(v0, v1, v2, 5.778e-34);
  sub_10003C0C8((void *)&_mh_execute_header, v5, v3, "Unable to format: WR: %@: error trying to provide tailspin to Diagnostic Pipeline: %@", v4);
}

void sub_100083020()
{
  sub_10003C0E0();
  sub_10003C088(v0, v1, v2, 5.778e-34);
  sub_10003C128((void *)&_mh_execute_header, "WR: %@: error trying to provide tailspin to Diagnostic Pipeline: %@", v3, v4);
}

void sub_100083058()
{
  sub_10003C0BC();
  sub_10003C04C((void *)&_mh_execute_header, v0, v1, "Unable to format: WR: %@: submitting tailspin to Diagnostic Pipeline", v2, v3, v4, v5, v6);
}

void sub_1000830C0()
{
  sub_10003C0BC();
  _os_log_debug_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_DEBUG, "WR: %@: submitting tailspin to Diagnostic Pipeline", v1, 0xCu);
}

void sub_100083134()
{
  sub_10003C0BC();
  sub_10003C04C((void *)&_mh_execute_header, v0, v1, "Unable to format: WR: %@: DRShouldGatherLog return false, not submitting tailspin", v2, v3, v4, v5, v6);
}

void sub_10008319C()
{
  sub_10003C0BC();
  _os_log_debug_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_DEBUG, "WR: %@: DRShouldGatherLog return false, not submitting tailspin", v1, 0xCu);
}

void sub_100083210()
{
  sub_10003C0E0();
  sub_10003C088(v0, v1, v2, 5.778e-34);
  sub_10003C0C8((void *)&_mh_execute_header, v5, v3, "Unable to format: WR: %@: error in DRShouldGatherLog call: %@", v4);
}

void sub_10008324C()
{
  sub_10003C0E0();
  sub_10003C088(v0, v1, v2, 5.778e-34);
  sub_10003C128((void *)&_mh_execute_header, "WR: %@: error in DRShouldGatherLog call: %@", v3, v4);
}

void sub_100083284()
{
  sub_10003C0BC();
  sub_10003C04C((void *)&_mh_execute_header, v0, v1, "Unable to format: WR: %@: no spindump reports to generate", v2, v3, v4, v5, v6);
}

void sub_1000832EC(uint8_t *buf, uint64_t a2, os_log_t log)
{
  *(_DWORD *)buf = 134217984;
  *(void *)(buf + 4) = a2;
  _os_log_fault_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_FAULT, "Unable to format: WR: have %lu reports, but no sampleStore", buf, 0xCu);
}

void sub_100083334(uint8_t *buf, uint64_t a2, os_log_t log)
{
  *(_DWORD *)buf = 134217984;
  *(void *)(buf + 4) = a2;
  _os_log_fault_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_FAULT, "WR: have %lu reports, but no sampleStore", buf, 0xCu);
}

void sub_10008337C()
{
  sub_10003C0E0();
  sub_10003C088(v0, v1, v2, 5.778e-34);
  sub_10003C0C8((void *)&_mh_execute_header, v5, v3, "Unable to format: WR: %@: Unable to compare timesamps with tailspin data (%@)", v4);
}

void sub_1000833B8()
{
  sub_10003C0E0();
  *(_DWORD *)uint64_t v0 = 138412546;
  *(void *)(v0 + 4) = v1;
  *(_WORD *)(v0 + 12) = 2114;
  *(void *)(v0 + 14) = v2;
  sub_10003C128((void *)&_mh_execute_header, "WR: %@: Unable to compare timesamps with tailspin data (%{public}@)", v3, v4);
}

void sub_100083400(uint8_t *buf, unsigned char *a2, os_log_t log)
{
  *buf = 0;
  *a2 = 0;
  _os_log_fault_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_FAULT, "Unable to format: Sample store contains no samples for the signpost interval, not generating spindump report", buf, 2u);
}

void sub_100083440(uint8_t *buf, unsigned char *a2, os_log_t log)
{
  *buf = 0;
  *a2 = 0;
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "Sample store contains no samples for the signpost interval, not generating spindump report", buf, 2u);
}

void sub_100083480()
{
  sub_10003C0F8();
  sub_10003C068(v0, v1, v2, 4.8152e-34);
  *(void *)(v3 + 20) = "sampleStore.targetDispatchQueueId == report.dispatchQueue.identifier";
  _os_log_fault_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_FAULT, "Unable to format: %s [%d]: %s: Unable to set target dispatch queue", v4, 0x1Cu);
}

void sub_1000834D0()
{
  sub_10003C0F8();
  sub_10003C068(v0, v1, v2, 4.8152e-34);
  *(void *)(v3 + 20) = "sampleStore.targetDispatchQueueId == report.dispatchQueue.identifier";
  _os_log_error_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "%s [%d]: %s: Unable to set target dispatch queue", v4, 0x1Cu);
}

void sub_100083520(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_100083598(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_100083610()
{
  sub_10003C0F8();
  sub_10003C068(v0, v1, v2, 4.8152e-34);
  *(void *)(v3 + 20) = "sampleStore.targetDispatchQueueId == report.dispatchQueue.identifier";
  _os_log_fault_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_FAULT, "Unable to format: %s [%d]: %s: Unable to set target thread", v4, 0x1Cu);
}

void sub_100083660()
{
  sub_10003C0F8();
  sub_10003C068(v0, v1, v2, 4.8152e-34);
  *(void *)(v3 + 20) = "sampleStore.targetDispatchQueueId == report.dispatchQueue.identifier";
  _os_log_error_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "%s [%d]: %s: Unable to set target thread", v4, 0x1Cu);
}

void sub_1000836B0(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_100083728(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_1000837A0()
{
  sub_10003C0F8();
  *(_DWORD *)uint64_t v0 = 138412546;
  *(void *)(v0 + 4) = v1;
  *(_WORD *)(v0 + 12) = 2048;
  *(void *)(v0 + 14) = v2;
  sub_10003C0C8((void *)&_mh_execute_header, v4, v2, "Unable to format: WR: %@: generating %lu spindump reports", v3);
}

void sub_1000837EC()
{
  sub_10003C11C(__stack_chk_guard);
  sub_10003C0EC();
  sub_10003C04C((void *)&_mh_execute_header, v0, v1, "Unable to format: Unable to encode workflow event tracked into a string: %@", v2, v3, v4, v5, v6);
}

void sub_100083854()
{
  sub_10003C11C(__stack_chk_guard);
  sub_10003C0EC();
  sub_10003C04C((void *)&_mh_execute_header, v0, v1, "Unable to encode workflow event tracked into a string: %@", v2, v3, v4, v5, v6);
}

void sub_1000838BC()
{
  sub_10003C104();
  sub_10003C0C8((void *)&_mh_execute_header, v0, (uint64_t)v0, "Unable to format: WR: %@: Workflow event has error %@, still considering for diagnostics", v1);
}

void sub_10008392C()
{
  sub_10003C104();
  sub_10003C0C8((void *)&_mh_execute_header, v0, (uint64_t)v0, "Unable to format: WR: %@: Workflow event has error %@, not considering for diagnostics", v1);
}

void sub_10008399C()
{
  sub_10003C144();
  sub_10003C0C8((void *)&_mh_execute_header, v0, v1, "Unable to format: WR: %@: Workflow event has invalid duration %.3f", v2);
}

void sub_100083A08()
{
  sub_10003C144();
  _os_log_error_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_ERROR, "WR: %@: Workflow event has invalid duration %.3f", v1, 0x16u);
}

void sub_100083A7C()
{
  sub_10003C0BC();
  __int16 v3 = 2080;
  uint64_t v4 = v0;
  sub_10003C0C8((void *)&_mh_execute_header, v1, (uint64_t)v1, "Unable to format: WR: %@: Received tailspin path %s", v2);
}

void sub_100083AFC(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_100083B74(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_100083BEC()
{
  sub_1000465C0();
  sub_10002E4E8(v0);
  sub_10004657C();
  sub_1000465A0((void *)&_mh_execute_header, v1, v2, "Unable to format: %s [%d]: Unable to get dirname of %s", v3, v4, v5, v6, v7);
}

void sub_100083C6C()
{
  sub_1000465C0();
  sub_10002E4E8(v0);
  sub_10004657C();
  sub_1000465A0((void *)&_mh_execute_header, v1, v2, "%{public}s [%d]: Unable to get dirname of %s", v3, v4, v5, v6, v7);
}

void sub_100083CEC()
{
  sub_10003C0BC();
  sub_10003C04C((void *)&_mh_execute_header, v0, v1, "Unable to format: Unable to get dirname of %s", v2, v3, v4, v5, v6);
}

void sub_100083D54()
{
  sub_10003C0BC();
  sub_10003C04C((void *)&_mh_execute_header, v0, v1, "Unable to get dirname of %s", v2, v3, v4, v5, v6);
}

void sub_100083DBC()
{
  sub_1000465C0();
  sub_10002E4E8(v0);
  sub_10004657C();
  sub_1000465A0((void *)&_mh_execute_header, v1, v2, "Unable to format: %s [%d]: Unable to get basename of %s", v3, v4, v5, v6, v7);
}

void sub_100083E3C()
{
  sub_1000465C0();
  sub_10002E4E8(v0);
  sub_10004657C();
  sub_1000465A0((void *)&_mh_execute_header, v1, v2, "%{public}s [%d]: Unable to get basename of %s", v3, v4, v5, v6, v7);
}

void sub_100083EBC()
{
  sub_10003C0BC();
  sub_10003C04C((void *)&_mh_execute_header, v0, v1, "Unable to format: Unable to get basename of %s", v2, v3, v4, v5, v6);
}

void sub_100083F24()
{
  sub_10003C0BC();
  sub_10003C04C((void *)&_mh_execute_header, v0, v1, "Unable to get basename of %s", v2, v3, v4, v5, v6);
}

void sub_100083F8C()
{
  sub_100046940();
  sub_100046694((void *)&_mh_execute_header, v0, v1, "Unable to format: NULL realDir (dir %s from %s)", v2, v3);
}

void sub_100083FF4()
{
  sub_100046940();
  sub_100046694((void *)&_mh_execute_header, v0, v1, "NULL realDir (dir %s from %s)", v2, v3);
}

void sub_10008405C()
{
  sub_100046668();
  sub_10002E4E8(v0);
  sub_100046718();
  sub_1000465A0((void *)&_mh_execute_header, v1, v2, "Unable to format: %s [%d]: %s: NULL expectedRealDir (from /var/mobile/Library/Logs/CrashReporter)", v3, v4, v5, v6, v7);
}

void sub_1000840E0()
{
  sub_100046668();
  sub_10002E4E8(v0);
  sub_100046718();
  sub_100046874((void *)&_mh_execute_header, v1, v2, "%s [%d]: %s: NULL expectedRealDir (from /var/mobile/Library/Logs/CrashReporter)", v3, v4, v5, v6, v7);
}

void sub_100084164(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_1000841DC(os_log_t log)
{
  int v1 = 136315138;
  uint64_t v2 = "expectedRealDir";
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "%s: NULL expectedRealDir (from /var/mobile/Library/Logs/CrashReporter)", (uint8_t *)&v1, 0xCu);
}

void sub_100084260()
{
  sub_100046668();
  sub_10002E4E8(v0);
  sub_100046718();
  sub_1000465A0((void *)&_mh_execute_header, v1, v2, "Unable to format: %s [%d]: %s: expectedRealDir of / (from /var/mobile/Library/Logs/CrashReporter)", v3, v4, v5, v6, v7);
}

void sub_1000842E4()
{
  sub_100046668();
  sub_10002E4E8(v0);
  sub_100046718();
  sub_100046874((void *)&_mh_execute_header, v1, v2, "%s [%d]: %s: expectedRealDir of / (from /var/mobile/Library/Logs/CrashReporter)", v3, v4, v5, v6, v7);
}

void sub_100084368(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_1000843E0(os_log_t log)
{
  int v1 = 136315138;
  uint64_t v2 = "0 != strcmp(\"/\", expectedRealDir)";
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "%s: expectedRealDir of / (from /var/mobile/Library/Logs/CrashReporter)", (uint8_t *)&v1, 0xCu);
}

void sub_100084464()
{
  sub_100046668();
  sub_10002E4E8(v1);
  __error();
  uint64_t v2 = __error();
  strerror(*v2);
  sub_1000468C4();
  _os_log_fault_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_FAULT, "Unable to format: %s [%d]: generate spindump: unable to sample process: %d (%s)", v3, 0x22u);
}

void sub_10008450C()
{
  sub_100046668();
  sub_10002E4E8(v1);
  __error();
  uint64_t v2 = __error();
  strerror(*v2);
  sub_1000468C4();
  _os_log_error_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_ERROR, "%{public}s [%d]: generate spindump: unable to sample process: %d (%s)", v3, 0x22u);
}

void sub_1000845B4()
{
  __error();
  int v0 = __error();
  strerror(*v0);
  sub_1000467CC();
  sub_100046614((void *)&_mh_execute_header, v1, v2, "Unable to format: generate spindump: unable to sample process: %d (%s)", v3, v4, v5, v6, v7);
}

void sub_10008463C()
{
  __error();
  int v0 = __error();
  strerror(*v0);
  sub_1000467CC();
  sub_100046A30((void *)&_mh_execute_header, v1, v2, "generate spindump: unable to sample process: %d (%s)", v3, v4, v5, v6, v7);
}

void sub_1000846C4()
{
  sub_1000465C0();
  sub_10002E4E8(v0);
  sub_10004657C();
  sub_1000465A0((void *)&_mh_execute_header, v1, v2, "Unable to format: %s [%d]: generate spindump: filepath %s too large", v3, v4, v5, v6, v7);
}

void sub_100084744()
{
  sub_1000465C0();
  sub_10002E4E8(v0);
  sub_10004657C();
  sub_1000465A0((void *)&_mh_execute_header, v1, v2, "%{public}s [%d]: generate spindump: filepath %s too large", v3, v4, v5, v6, v7);
}

void sub_1000847C4()
{
  sub_10003C0BC();
  sub_10003C04C((void *)&_mh_execute_header, v0, v1, "Unable to format: generate spindump: filepath %s too large", v2, v3, v4, v5, v6);
}

void sub_10008482C()
{
  sub_10003C0BC();
  sub_10003C04C((void *)&_mh_execute_header, v0, v1, "generate spindump: filepath %s too large", v2, v3, v4, v5, v6);
}

void sub_100084894()
{
  sub_1000465C0();
  sub_10002E4E8(v0);
  sub_10004657C();
  sub_1000465A0((void *)&_mh_execute_header, v1, v2, "Unable to format: %s [%d]: generate spindump: filepath %s not in /var/mobile/Library/Logs/CrashReporter", v3, v4, v5, v6, v7);
}

void sub_100084914()
{
  sub_1000465C0();
  sub_10002E4E8(v0);
  sub_10004657C();
  sub_1000465A0((void *)&_mh_execute_header, v1, v2, "%{public}s [%d]: generate spindump: filepath %s not in /var/mobile/Library/Logs/CrashReporter", v3, v4, v5, v6, v7);
}

void sub_100084994()
{
  sub_10003C0BC();
  sub_10003C04C((void *)&_mh_execute_header, v0, v1, "Unable to format: generate spindump: filepath %s not in /var/mobile/Library/Logs/CrashReporter", v2, v3, v4, v5, v6);
}

void sub_1000849FC()
{
  sub_10003C0BC();
  sub_10003C04C((void *)&_mh_execute_header, v0, v1, "generate spindump: filepath %s not in /var/mobile/Library/Logs/CrashReporter", v2, v3, v4, v5, v6);
}

#error "100084AC0: call analysis failed (funcsize=34)"

#error "100084B50: call analysis failed (funcsize=34)"

void sub_100084B84()
{
  sub_100046A9C();
  int v0 = __error();
  strerror(*v0);
  sub_1000466B4();
  sub_1000465A0((void *)&_mh_execute_header, v1, v2, "Unable to format: generate spindump: unable to open %s for writing: %d (%s)", v3, v4, v5, v6, v7);
}

void sub_100084C10()
{
  sub_100046A9C();
  int v0 = __error();
  strerror(*v0);
  sub_1000466B4();
  sub_100046874((void *)&_mh_execute_header, v1, v2, "generate spindump: unable to open %s for writing: %d (%s)", v3, v4, v5, v6, v7);
}

#error "100084CF8: call analysis failed (funcsize=34)"

#error "100084D88: call analysis failed (funcsize=34)"

void sub_100084DBC()
{
  sub_100046A9C();
  int v0 = __error();
  strerror(*v0);
  sub_1000466B4();
  sub_1000465A0((void *)&_mh_execute_header, v1, v2, "Unable to format: generate spindump: unable to fdopen %s for writing: %d (%s)", v3, v4, v5, v6, v7);
}

void sub_100084E48()
{
  sub_100046A9C();
  int v0 = __error();
  strerror(*v0);
  sub_1000466B4();
  sub_100046874((void *)&_mh_execute_header, v1, v2, "generate spindump: unable to fdopen %s for writing: %d (%s)", v3, v4, v5, v6, v7);
}

void sub_100084ED4()
{
  sub_1000465C0();
  sub_10002E4E8(*v0);
  sub_10003C0BC();
  sub_1000465A0((void *)&_mh_execute_header, v1, v2, "Unable to format: generate spindump: saved report (requested by %s [%d]) to %s", v3, v4, v5, v6, v7);
}

void sub_100084F78(int *a1, unsigned __int8 a2)
{
  sub_10002E4E8(*a1);
  sub_10006DC4C(a2);
  sub_1000465A0((void *)&_mh_execute_header, v3, v4, "Unable to format: %s [%d]: generate spindump: done monitoring due to %s", v5, v6, v7, v8, 2u);
}

void sub_100085030(int *a1, unsigned __int8 a2)
{
  sub_10002E4E8(*a1);
  sub_10006DC4C(a2);
  sub_100046928();
  sub_100046854((void *)&_mh_execute_header, v3, v4, "%{public}s [%d]: generate spindump: done monitoring due to %{public}s", v5, v6, v7, v8, 2u);
}

void sub_1000850D8(unsigned __int8 a1, NSObject *a2)
{
  sub_10006DC4C(a1);
  sub_10003C0BC();
  _os_log_fault_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_FAULT, "Unable to format: generate spindump: done monitoring due to %s", v3, 0xCu);
}

void sub_100085164(unsigned __int8 a1, NSObject *a2)
{
  sub_10006DC4C(a1);
  sub_10003C0BC();
  _os_log_debug_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_DEBUG, "generate spindump: done monitoring due to %{public}s", v3, 0xCu);
}

void sub_1000851F0()
{
  sub_1000465C0();
  sub_10002E4E8(v0);
  sub_1000465D0();
  sub_1000465A0((void *)&_mh_execute_header, v1, v2, "Unable to format: %s [%d]: cpu resource: done reporting (%#llx)", v3, v4, v5, v6, v7);
}

void sub_100085270()
{
  sub_1000465C0();
  sub_10002E4E8(v0);
  sub_1000465D0();
  sub_100046854((void *)&_mh_execute_header, v1, v2, "%{public}s [%d]: cpu resource: done reporting (%#llx)", v3, v4, v5, v6, v7);
}

#error "100085350: call analysis failed (funcsize=35)"

#error "1000853E4: call analysis failed (funcsize=35)"

void sub_100085418()
{
  sub_10003C0BC();
  sub_10003C04C((void *)&_mh_execute_header, v0, v1, "Unable to format: cpu resource: done reporting (%#llx)", v2, v3, v4, v5, v6);
}

void sub_100085480()
{
  sub_10003C0BC();
  sub_10004690C((void *)&_mh_execute_header, v0, v1, "cpu resource: done reporting (%#llx)", v2, v3, v4, v5, v6);
}

void sub_1000854E8()
{
  sub_100046668();
  [objc_msgSend(v0, "total") num_out_of_order];
  [sub_10004683C() num_missing_load_info];
  sub_100046824();
  sub_1000465F4();
  sub_100046794((void *)&_mh_execute_header, v1, v2, "Unable to format: cpu resource: all microstackshots without errors: %llu out-of-order microstackshots, %llu microstackshots missing load infos, %llu bytes invalid", v3, v4, v5, v6, v7);
}

void sub_100085578()
{
  sub_100046668();
  [objc_msgSend(v0, "total") num_out_of_order];
  [sub_10004683C() num_missing_load_info];
  sub_100046824();
  sub_1000465F4();
  sub_100046990((void *)&_mh_execute_header, v1, v2, "cpu resource: all microstackshots without errors: %llu out-of-order microstackshots, %llu microstackshots missing load infos, %llu bytes invalid", v3, v4, v5, v6, v7);
}

#error "100085668: call analysis failed (funcsize=35)"

void sub_10008569C()
{
  sub_100046668();
  [objc_msgSend(v0, "total") num_out_of_order];
  [sub_10004683C() num_missing_load_info];
  sub_100046824();
  sub_1000465F4();
  sub_100046794((void *)&_mh_execute_header, v1, v2, "Unable to format: cpu resource: some microstackshots with errors: %llu out-of-order microstackshots, %llu microstackshots missing load infos, %llu bytes invalid", v3, v4, v5, v6, v7);
}

#error "10008578C: call analysis failed (funcsize=35)"

#error "100085820: call analysis failed (funcsize=35)"

void sub_100085854()
{
  sub_100046668();
  [objc_msgSend(v0, "total") num_out_of_order];
  [sub_10004683C() num_missing_load_info];
  sub_100046824();
  sub_1000465F4();
  sub_100046794((void *)&_mh_execute_header, v1, v2, "Unable to format: cpu resource: no microstackshots: %llu out-of-order microstackshots, %llu microstackshots missing load infos, %llu bytes invalid", v3, v4, v5, v6, v7);
}

void sub_1000858E4()
{
  sub_100046668();
  [objc_msgSend(v0, "total") num_out_of_order];
  [sub_10004683C() num_missing_load_info];
  sub_100046824();
  sub_1000465F4();
  sub_1000469D0((void *)&_mh_execute_header, v1, v2, "cpu resource: no microstackshots: %llu out-of-order microstackshots, %llu microstackshots missing load infos, %llu bytes invalid", v3, v4, v5, v6, v7);
}

void sub_100085974()
{
  sub_100046668();
  sub_10002E4E8(v0);
  sub_100046564();
  sub_100046614((void *)&_mh_execute_header, v1, v2, "Unable to format: %s [%d]: cpu resource: deferring report generation due to game mode", v3, v4, v5, v6, v7);
}

void sub_1000859EC()
{
  sub_10004670C();
  sub_1000466D8((void *)&_mh_execute_header, v0, v1, "Unable to format: cpu resource: deferring report generation due to game mode", v2, v3, v4, v5, v6);
}

void sub_100085A20()
{
  sub_100046668();
  sub_10002E4E8(v0);
  sub_100046564();
  sub_100046614((void *)&_mh_execute_header, v1, v2, "Unable to format: %s [%d]: cpu resource: cannot defer report generation for game mode", v3, v4, v5, v6, v7);
}

void sub_100085A98()
{
  sub_100046668();
  sub_10002E4E8(v0);
  sub_100046564();
  sub_100046674((void *)&_mh_execute_header, v1, v2, "%{public}s [%d]: cpu resource: cannot defer report generation for game mode", v3, v4, v5, v6, v7);
}

void sub_100085B10()
{
  sub_10004670C();
  sub_1000466D8((void *)&_mh_execute_header, v0, v1, "Unable to format: cpu resource: cannot defer report generation for game mode", v2, v3, v4, v5, v6);
}

void sub_100085B44()
{
  sub_10004670C();
  sub_100046758((void *)&_mh_execute_header, v0, v1, "cpu resource: cannot defer report generation for game mode", v2, v3, v4, v5, v6);
}

void sub_100085B78()
{
  sub_1000465C0();
  sub_10002E4E8(v0);
  sub_1000465D0();
  sub_1000465A0((void *)&_mh_execute_header, v1, v2, "Unable to format: %s [%d]: cpu resource: not monitoring due to conditions %#llx", v3, v4, v5, v6, v7);
}

void sub_100085BF8()
{
  sub_10003C0BC();
  sub_10003C04C((void *)&_mh_execute_header, v0, v1, "Unable to format: cpu resource: not monitoring due to conditions %#llx", v2, v3, v4, v5, v6);
}

void sub_100085C60()
{
  sub_100046668();
  sub_10002E4E8(v0);
  sub_100046564();
  sub_100046614((void *)&_mh_execute_header, v1, v2, "Unable to format: %s [%d]: cpu resource: not monitoring due to throttling the number of reports generated for 1st party processes", v3, v4, v5, v6, v7);
}

void sub_100085CD8()
{
  sub_100046668();
  sub_10002E4E8(v0);
  sub_100046564();
  sub_100046674((void *)&_mh_execute_header, v1, v2, "%{public}s [%d]: cpu resource: not monitoring due to throttling the number of reports generated for 1st party processes", v3, v4, v5, v6, v7);
}

void sub_100085D50()
{
  sub_10004670C();
  sub_1000466D8((void *)&_mh_execute_header, v0, v1, "Unable to format: cpu resource: not monitoring due to throttling the number of reports generated for 1st party processes", v2, v3, v4, v5, v6);
}

void sub_100085D84()
{
  sub_10004670C();
  sub_100046758((void *)&_mh_execute_header, v0, v1, "cpu resource: not monitoring due to throttling the number of reports generated for 1st party processes", v2, v3, v4, v5, v6);
}

void sub_100085DB8()
{
  sub_100046668();
  sub_10002E4E8(v0);
  sub_100046564();
  sub_100046614((void *)&_mh_execute_header, v1, v2, "Unable to format: %s [%d]: cpu resource: not monitoring due to suppression cookie file", v3, v4, v5, v6, v7);
}

void sub_100085E30()
{
  sub_100046668();
  sub_10002E4E8(v0);
  sub_100046564();
  sub_100046674((void *)&_mh_execute_header, v1, v2, "%{public}s [%d]: cpu resource: not monitoring due to suppression cookie file", v3, v4, v5, v6, v7);
}

void sub_100085EA8()
{
  sub_10004670C();
  sub_1000466D8((void *)&_mh_execute_header, v0, v1, "Unable to format: cpu resource: not monitoring due to suppression cookie file", v2, v3, v4, v5, v6);
}

void sub_100085EDC()
{
  sub_10004670C();
  sub_100046758((void *)&_mh_execute_header, v0, v1, "cpu resource: not monitoring due to suppression cookie file", v2, v3, v4, v5, v6);
}

void sub_100085F10()
{
  sub_1000465C0();
  sub_10002E4E8(v0);
  sub_100046738();
  sub_100046A70((void *)&_mh_execute_header, v1, v2, "Unable to format: %s [%d]: Unable to get suspended state (%d), assuming not suspended", v3, v4, v5, v6, v7);
}

void sub_100085F90()
{
  sub_1000465C0();
  sub_10002E4E8(v0);
  sub_100046738();
  sub_100046A10((void *)&_mh_execute_header, v1, v2, "%{public}s [%d]: Unable to get suspended state (%d), assuming not suspended", v3, v4, v5, v6, v7);
}

void sub_100086010()
{
  sub_100046A90();
  _os_log_fault_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_FAULT, "Unable to format: Unable to get suspended state (%d), assuming not suspended", v1, 8u);
}

void sub_100086084()
{
  sub_100046A90();
  _os_log_error_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_ERROR, "Unable to get suspended state (%d), assuming not suspended", v1, 8u);
}

void sub_1000860F8()
{
  sub_1000465C0();
  sub_10002E4E8(v0);
  sub_100046738();
  sub_100046A70((void *)&_mh_execute_header, v1, v2, "Unable to format: %s [%d]: Unable to inspect task for suspended state (%d), assuming not suspended", v3, v4, v5, v6, v7);
}

void sub_100086178()
{
  sub_1000465C0();
  sub_10002E4E8(v0);
  sub_100046738();
  sub_100046A10((void *)&_mh_execute_header, v1, v2, "%{public}s [%d]: Unable to inspect task for suspended state (%d), assuming not suspended", v3, v4, v5, v6, v7);
}

void sub_1000861F8()
{
  sub_100046A90();
  _os_log_fault_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_FAULT, "Unable to format: Unable to inspect task for suspended state (%d), assuming not suspended", v1, 8u);
}

void sub_10008626C()
{
  sub_100046A90();
  _os_log_error_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_ERROR, "Unable to inspect task for suspended state (%d), assuming not suspended", v1, 8u);
}

void sub_1000862E0()
{
  sub_1000465C0();
  sub_10002E4E8(v0);
  sub_10004657C();
  sub_1000465A0((void *)&_mh_execute_header, v1, v2, "Unable to format: %s [%d]: %s: being debugged", v3, v4, v5, v6, v7);
}

void sub_100086360()
{
  sub_1000465C0();
  sub_10002E4E8(v0);
  sub_100046928();
  sub_100046854((void *)&_mh_execute_header, v1, v2, "%{public}s [%d]: %{public}s: being debugged", v3, v4, v5, v6, 2u);
}

void sub_1000863EC()
{
  sub_10003C0BC();
  sub_10003C04C((void *)&_mh_execute_header, v0, v1, "Unable to format: %s: being debugged", v2, v3, v4, v5, v6);
}

void sub_100086454()
{
  sub_10003C0BC();
  sub_10004690C((void *)&_mh_execute_header, v0, v1, "%{public}s: being debugged", v2, v3, v4, v5, v6);
}

void sub_1000864BC()
{
  sub_1000467B4();
  _os_log_fault_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_FAULT, "Unable to format: Should restrict submission due to roll of %.4f (pref is %.4f)", v1, 0x16u);
}

void sub_100086534()
{
  sub_1000467B4();
  _os_log_debug_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_DEBUG, "Should restrict submission due to roll of %.4f (pref is %.4f)", v1, 0x16u);
}

void sub_1000865AC()
{
  sub_1000467B4();
  _os_log_fault_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_FAULT, "Unable to format: Should not restrict submission due to roll of %.4f (pref is %.4f)", v1, 0x16u);
}

void sub_100086624()
{
  sub_1000467B4();
  _os_log_debug_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_DEBUG, "Should not restrict submission due to roll of %.4f (pref is %.4f)", v1, 0x16u);
}

void sub_10008669C()
{
  sub_1000465C0();
  sub_10002E4E8(v0);
  sub_1000465D0();
  sub_1000465A0((void *)&_mh_execute_header, v1, v2, "Unable to format: %s [%d]: disk writes: done reporting (%#llx)", v3, v4, v5, v6, v7);
}

void sub_10008671C()
{
  sub_1000465C0();
  sub_10002E4E8(v0);
  sub_1000465D0();
  sub_100046854((void *)&_mh_execute_header, v1, v2, "%{public}s [%d]: disk writes: done reporting (%#llx)", v3, v4, v5, v6, v7);
}

#error "1000867FC: call analysis failed (funcsize=35)"

#error "100086890: call analysis failed (funcsize=35)"

void sub_1000868C4()
{
  sub_10003C0BC();
  sub_10003C04C((void *)&_mh_execute_header, v0, v1, "Unable to format: disk writes: done reporting (%#llx)", v2, v3, v4, v5, v6);
}

void sub_10008692C()
{
  sub_10003C0BC();
  sub_10004690C((void *)&_mh_execute_header, v0, v1, "disk writes: done reporting (%#llx)", v2, v3, v4, v5, v6);
}

void sub_100086994()
{
  sub_100046668();
  [objc_msgSend(v0, "total") num_out_of_order];
  [sub_10004683C() num_missing_load_info];
  sub_100046824();
  sub_1000465F4();
  sub_100046794((void *)&_mh_execute_header, v1, v2, "Unable to format: disk writes: all microstackshots without errors: %llu out-of-order microstackshots, %llu microstackshots missing load infos, %llu bytes invalid", v3, v4, v5, v6, v7);
}

void sub_100086A24()
{
  sub_100046668();
  [objc_msgSend(v0, "total") num_out_of_order];
  [sub_10004683C() num_missing_load_info];
  sub_100046824();
  sub_1000465F4();
  sub_100046990((void *)&_mh_execute_header, v1, v2, "disk writes: all microstackshots without errors: %llu out-of-order microstackshots, %llu microstackshots missing load infos, %llu bytes invalid", v3, v4, v5, v6, v7);
}

#error "100086B14: call analysis failed (funcsize=35)"

void sub_100086B48()
{
  sub_100046668();
  [objc_msgSend(v0, "total") num_out_of_order];
  [sub_10004683C() num_missing_load_info];
  sub_100046824();
  sub_1000465F4();
  sub_100046794((void *)&_mh_execute_header, v1, v2, "Unable to format: disk writes: some microstackshots with errors: %llu out-of-order microstackshots, %llu microstackshots missing load infos, %llu bytes invalid", v3, v4, v5, v6, v7);
}

#error "100086C38: call analysis failed (funcsize=35)"

#error "100086CCC: call analysis failed (funcsize=35)"

void sub_100086D00()
{
  sub_100046668();
  [objc_msgSend(v0, "total") num_out_of_order];
  [sub_10004683C() num_missing_load_info];
  sub_100046824();
  sub_1000465F4();
  sub_100046794((void *)&_mh_execute_header, v1, v2, "Unable to format: disk writes: no microstackshots: %llu out-of-order microstackshots, %llu microstackshots missing load infos, %llu bytes invalid", v3, v4, v5, v6, v7);
}

void sub_100086D90()
{
  sub_100046668();
  [objc_msgSend(v0, "total") num_out_of_order];
  [sub_10004683C() num_missing_load_info];
  sub_100046824();
  sub_1000465F4();
  sub_1000469D0((void *)&_mh_execute_header, v1, v2, "disk writes: no microstackshots: %llu out-of-order microstackshots, %llu microstackshots missing load infos, %llu bytes invalid", v3, v4, v5, v6, v7);
}

void sub_100086E20()
{
  sub_1000465C0();
  sub_10002E4E8(v0);
  sub_1000465D0();
  sub_1000465A0((void *)&_mh_execute_header, v1, v2, "Unable to format: %s [%d]: disk writes: not monitoring due to conditions %#llx", v3, v4, v5, v6, v7);
}

void sub_100086EA0()
{
  sub_10003C0BC();
  sub_10003C04C((void *)&_mh_execute_header, v0, v1, "Unable to format: disk writes: not monitoring due to conditions %#llx", v2, v3, v4, v5, v6);
}

void sub_100086F08()
{
  sub_100046668();
  sub_10002E4E8(v0);
  sub_100046564();
  sub_100046614((void *)&_mh_execute_header, v1, v2, "Unable to format: %s [%d]: disk writes: not monitoring due to tasking-specified sampling", v3, v4, v5, v6, v7);
}

void sub_100086F80()
{
  sub_100046668();
  sub_10002E4E8(v0);
  sub_100046564();
  sub_100046674((void *)&_mh_execute_header, v1, v2, "%{public}s [%d]: disk writes: not monitoring due to tasking-specified sampling", v3, v4, v5, v6, v7);
}

void sub_100086FF8()
{
  sub_10004670C();
  sub_1000466D8((void *)&_mh_execute_header, v0, v1, "Unable to format: disk writes: not monitoring due to tasking-specified sampling", v2, v3, v4, v5, v6);
}

void sub_10008702C()
{
  sub_10004670C();
  sub_100046758((void *)&_mh_execute_header, v0, v1, "disk writes: not monitoring due to tasking-specified sampling", v2, v3, v4, v5, v6);
}

void sub_100087060()
{
  sub_100046668();
  sub_10002E4E8(v0);
  sub_100046564();
  sub_100046614((void *)&_mh_execute_header, v1, v2, "Unable to format: %s [%d]: disk writes: deferring report generation due to game mode", v3, v4, v5, v6, v7);
}

void sub_1000870D8()
{
  sub_10004670C();
  sub_1000466D8((void *)&_mh_execute_header, v0, v1, "Unable to format: disk writes: deferring report generation due to game mode", v2, v3, v4, v5, v6);
}

void sub_10008710C()
{
  sub_100046668();
  sub_10002E4E8(v0);
  sub_100046564();
  sub_100046614((void *)&_mh_execute_header, v1, v2, "Unable to format: %s [%d]: disk writes: cannot defer report generation for game mode", v3, v4, v5, v6, v7);
}

void sub_100087184()
{
  sub_100046668();
  sub_10002E4E8(v0);
  sub_100046564();
  sub_100046674((void *)&_mh_execute_header, v1, v2, "%{public}s [%d]: disk writes: cannot defer report generation for game mode", v3, v4, v5, v6, v7);
}

void sub_1000871FC()
{
  sub_10004670C();
  sub_1000466D8((void *)&_mh_execute_header, v0, v1, "Unable to format: disk writes: cannot defer report generation for game mode", v2, v3, v4, v5, v6);
}

void sub_100087230()
{
  sub_10004670C();
  sub_100046758((void *)&_mh_execute_header, v0, v1, "disk writes: cannot defer report generation for game mode", v2, v3, v4, v5, v6);
}

void sub_100087264()
{
  sub_100046668();
  sub_10002E4E8(v0);
  sub_100046564();
  sub_100046614((void *)&_mh_execute_header, v1, v2, "Unable to format: %s [%d]: disk writes: not monitoring due to suppression cookie file", v3, v4, v5, v6, v7);
}

void sub_1000872DC()
{
  sub_100046668();
  sub_10002E4E8(v0);
  sub_100046564();
  sub_100046674((void *)&_mh_execute_header, v1, v2, "%{public}s [%d]: disk writes: not monitoring due to suppression cookie file", v3, v4, v5, v6, v7);
}

void sub_100087354()
{
  sub_10004670C();
  sub_1000466D8((void *)&_mh_execute_header, v0, v1, "Unable to format: disk writes: not monitoring due to suppression cookie file", v2, v3, v4, v5, v6);
}

void sub_100087388()
{
  sub_10004670C();
  sub_100046758((void *)&_mh_execute_header, v0, v1, "disk writes: not monitoring due to suppression cookie file", v2, v3, v4, v5, v6);
}

void sub_1000873BC()
{
  sub_1000465C0();
  sub_10002E4E8(v0);
  sub_1000465D0();
  sub_1000465A0((void *)&_mh_execute_header, v1, v2, "Unable to format: %s [%d]: file descriptor exhaustion: not monitoring due to conditions %#llx", v3, v4, v5, v6, v7);
}

void sub_10008743C()
{
  sub_10003C0BC();
  sub_10003C04C((void *)&_mh_execute_header, v0, v1, "Unable to format: file descriptor exhaustion: not monitoring due to conditions %#llx", v2, v3, v4, v5, v6);
}

void sub_1000874A4()
{
  sub_100046668();
  sub_10002E4E8(v0);
  sub_100046564();
  sub_100046614((void *)&_mh_execute_header, v1, v2, "Unable to format: %s [%d]: file descriptor exhaustion: not monitoring due to suppression cookie file", v3, v4, v5, v6, v7);
}

void sub_10008751C()
{
  sub_100046668();
  sub_10002E4E8(v0);
  sub_100046564();
  sub_100046674((void *)&_mh_execute_header, v1, v2, "%{public}s [%d]: file descriptor exhaustion: not monitoring due to suppression cookie file", v3, v4, v5, v6, v7);
}

void sub_100087594()
{
  sub_10004670C();
  sub_1000466D8((void *)&_mh_execute_header, v0, v1, "Unable to format: file descriptor exhaustion: not monitoring due to suppression cookie file", v2, v3, v4, v5, v6);
}

void sub_1000875C8()
{
  sub_10004670C();
  sub_100046758((void *)&_mh_execute_header, v0, v1, "file descriptor exhaustion: not monitoring due to suppression cookie file", v2, v3, v4, v5, v6);
}

void sub_1000875FC()
{
  sub_1000466F4();
  sub_100046694((void *)&_mh_execute_header, v0, v1, "Unable to format: file descriptor exhaustion: fatal, %llu fds with flags %#llx", v2, v3);
}

void sub_100087664()
{
  sub_1000466F4();
  sub_100046694((void *)&_mh_execute_header, v0, v1, "Unable to format: file descriptor exhaustion: %llu fds with flags %#llx", v2, v3);
}

void sub_1000876CC()
{
  sub_1000465C0();
  sub_10002E4E8(v0);
  sub_1000465D0();
  sub_1000465A0((void *)&_mh_execute_header, v1, v2, "Unable to format: %s [%d]: port exhaustion: not monitoring due to conditions %#llx", v3, v4, v5, v6, v7);
}

void sub_10008774C()
{
  sub_10003C0BC();
  sub_10003C04C((void *)&_mh_execute_header, v0, v1, "Unable to format: port exhaustion: not monitoring due to conditions %#llx", v2, v3, v4, v5, v6);
}

void sub_1000877B4()
{
  sub_100046668();
  sub_10002E4E8(v0);
  sub_100046564();
  sub_100046614((void *)&_mh_execute_header, v1, v2, "Unable to format: %s [%d]: port exhaustion: not monitoring due to suppression cookie file", v3, v4, v5, v6, v7);
}

void sub_10008782C()
{
  sub_100046668();
  sub_10002E4E8(v0);
  sub_100046564();
  sub_100046674((void *)&_mh_execute_header, v1, v2, "%{public}s [%d]: port exhaustion: not monitoring due to suppression cookie file", v3, v4, v5, v6, v7);
}

void sub_1000878A4()
{
  sub_10004670C();
  sub_1000466D8((void *)&_mh_execute_header, v0, v1, "Unable to format: port exhaustion: not monitoring due to suppression cookie file", v2, v3, v4, v5, v6);
}

void sub_1000878D8()
{
  sub_10004670C();
  sub_100046758((void *)&_mh_execute_header, v0, v1, "port exhaustion: not monitoring due to suppression cookie file", v2, v3, v4, v5, v6);
}

void sub_10008790C()
{
  sub_1000466F4();
  sub_100046694((void *)&_mh_execute_header, v0, v1, "Unable to format: port exhaustion: fatal, %llu ports with flags %#llx", v2, v3);
}

void sub_100087974()
{
  sub_1000466F4();
  sub_100046694((void *)&_mh_execute_header, v0, v1, "Unable to format: port exhaustion: %llu ports with flags %#llx", v2, v3);
}

void sub_1000879DC()
{
  sub_1000465C0();
  sub_10002E4E8(v0);
  sub_1000465D0();
  sub_1000465A0((void *)&_mh_execute_header, v1, v2, "Unable to format: %s [%d]: kqworkloop exhaustion: not monitoring due to conditions %#llx", v3, v4, v5, v6, v7);
}

void sub_100087A5C()
{
  sub_10003C0BC();
  sub_10003C04C((void *)&_mh_execute_header, v0, v1, "Unable to format: kqworkloop exhaustion: not monitoring due to conditions %#llx", v2, v3, v4, v5, v6);
}

void sub_100087AC4()
{
  sub_100046668();
  sub_10002E4E8(v0);
  sub_100046564();
  sub_100046614((void *)&_mh_execute_header, v1, v2, "Unable to format: %s [%d]: kqworkloop exhaustion: not monitoring due to suppression cookie file", v3, v4, v5, v6, v7);
}

void sub_100087B3C()
{
  sub_100046668();
  sub_10002E4E8(v0);
  sub_100046564();
  sub_100046674((void *)&_mh_execute_header, v1, v2, "%{public}s [%d]: kqworkloop exhaustion: not monitoring due to suppression cookie file", v3, v4, v5, v6, v7);
}

void sub_100087BB4()
{
  sub_10004670C();
  sub_1000466D8((void *)&_mh_execute_header, v0, v1, "Unable to format: kqworkloop exhaustion: not monitoring due to suppression cookie file", v2, v3, v4, v5, v6);
}

void sub_100087BE8()
{
  sub_10004670C();
  sub_100046758((void *)&_mh_execute_header, v0, v1, "kqworkloop exhaustion: not monitoring due to suppression cookie file", v2, v3, v4, v5, v6);
}

void sub_100087C1C()
{
  sub_1000466F4();
  sub_100046694((void *)&_mh_execute_header, v0, v1, "Unable to format: kqworkloop exhaustion: fatal, %llu kqworkloops with flags %#llx", v2, v3);
}

void sub_100087C84()
{
  sub_1000466F4();
  sub_100046694((void *)&_mh_execute_header, v0, v1, "Unable to format: kqworkloop exhaustion: %llu kqworkloops with flags %#llx", v2, v3);
}

void sub_100087CEC()
{
  sub_10003C0BC();
  sub_10003C04C((void *)&_mh_execute_header, v0, v1, "Unable to format: Spindump output doesn't contain output path: %s", v2, v3, v4, v5, v6);
}

void sub_100087D54()
{
  sub_10003C0BC();
  sub_10003C04C((void *)&_mh_execute_header, v0, v1, "Spindump output doesn't contain output path: %s", v2, v3, v4, v5, v6);
}

void sub_100087DBC()
{
  sub_10003C0BC();
  sub_10003C04C((void *)&_mh_execute_header, v0, v1, "Unable to format: No newline in spindump output: %s", v2, v3, v4, v5, v6);
}

void sub_100087E24()
{
  sub_10003C0BC();
  sub_10003C04C((void *)&_mh_execute_header, v0, v1, "No newline in spindump output: %s", v2, v3, v4, v5, v6);
}

void sub_100087E8C()
{
  sub_10003C0BC();
  sub_10003C04C((void *)&_mh_execute_header, v0, v1, "Unable to format: Spindump output file doesn't exist: %s", v2, v3, v4, v5, v6);
}

void sub_100087EF4()
{
  sub_10003C0BC();
  sub_10003C04C((void *)&_mh_execute_header, v0, v1, "Spindump output file doesn't exist: %s", v2, v3, v4, v5, v6);
}

void sub_100087F5C()
{
  __error();
  uint64_t v0 = __error();
  strerror(*v0);
  sub_1000467CC();
  sub_100046614((void *)&_mh_execute_header, v1, v2, "Unable to format: read from child returned error: %d (%s)", v3, v4, v5, v6, v7);
}

void sub_100087FE4()
{
  __error();
  uint64_t v0 = __error();
  strerror(*v0);
  sub_1000467CC();
  sub_100046A30((void *)&_mh_execute_header, v1, v2, "read from child returned error: %d (%s)", v3, v4, v5, v6, v7);
}

void sub_10008806C(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_1000880E4(os_log_t log)
{
  int v1 = 136315138;
  uint64_t v2 = "user_preferences_dict";
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "%s: unable to allocate prefs dict", (uint8_t *)&v1, 0xCu);
}

void sub_100088168(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_1000881E0(os_log_t log)
{
  int v1 = 136315138;
  uint64_t v2 = "prefs_for_uid";
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "%s: unable to allocate prefs", (uint8_t *)&v1, 0xCu);
}

void sub_100088264()
{
  sub_100048230();
  sub_100048164();
  sub_100048184((void *)&_mh_execute_header, v0, v1, "Unable to format: UID %d: Don't throttle short spin reports:%d due to pref isset:%d value:%d", v2, v3, v4, v5);
}

void sub_1000882DC()
{
  sub_1000481CC(__stack_chk_guard);
  LOWORD(v3) = 1024;
  HIWORD(v3) = (v0 >> 11) & 1;
  sub_100048250((void *)&_mh_execute_header, v1, v2, "Unable to format: UID %d: Gather samples for service watchdog:%d due to submit:%d", 67109632, v3, ((unsigned __int16)word_1000EBD38 >> 12) & 1);
}

void sub_10008836C()
{
  sub_1000481CC(__stack_chk_guard);
  sub_1000480F4();
  sub_100048270((void *)&_mh_execute_header, v0, v1, "Unable to format: UID %d: Gather samples for stuck apps:%d due to internal:%d submit:%d user requested:%d", 67110144, v2, v3, v4, v5);
}

void sub_1000883F0()
{
  sub_1000481CC(__stack_chk_guard);
  sub_100048230();
  LOWORD(v6) = 1024;
  HIWORD(v6) = v2;
  LOWORD(v7) = ((v1 >> 6) & 1) >> 16;
  sub_100048184((void *)&_mh_execute_header, v3, v4, "Unable to format: UID %d: Gather samples for spins:%d due to submit:%d user requested:%d", v5, v6, (v0 >> 5) & 1, v7);
}

void sub_100088484()
{
  sub_1000481CC(__stack_chk_guard);
  sub_1000480F4();
  sub_100048270((void *)&_mh_execute_header, v0, v1, "Unable to format: UID %d: Gather samples for hangs:%d due to present:%d submit:%d user requested:%d", 67110144, v2, v3, v4, v5);
}

void sub_100088508()
{
  sub_1000481CC(__stack_chk_guard);
  sub_100048120();
  sub_100048250((void *)&_mh_execute_header, v0, v1, "Unable to format: UID %d: User requested spins:%d hangs:%d unavilable on this platform", v2, v3, v4);
}

void sub_100088570()
{
  sub_1000481CC(__stack_chk_guard);
  sub_100048120();
  _os_log_debug_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_DEBUG, "UID %d: User requested spins:%d hangs:%d unavilable on this platform", v1, 0x14u);
}

void sub_1000885E8()
{
  sub_100048230();
  sub_100048164();
  sub_100048184((void *)&_mh_execute_header, v0, v1, "Unable to format: UID %d: Present UI:%d due to server mode:%d admin:%d", v2, v3, v4, v5);
}

void sub_100088660()
{
  sub_100046A90();
  sub_1000480D8((void *)&_mh_execute_header, v0, v1, "Unable to format: Initializing prefs for user %d", v2, v3, v4, v5, v6);
}

void sub_1000886C8()
{
  sub_100046A90();
  _os_log_debug_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_DEBUG, "Initializing prefs for user %d", v1, 8u);
}

void sub_10008873C()
{
  v1[0] = 136315394;
  sub_100048290();
  _os_log_fault_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_FAULT, "Unable to format: %s: Getting prefs for user %d as command-line", (uint8_t *)v1, 0x12u);
}

void sub_1000887BC()
{
  v1[0] = 136315394;
  sub_100048290();
  _os_log_error_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_ERROR, "%s: Getting prefs for user %d as command-line", (uint8_t *)v1, 0x12u);
}

void sub_10008883C()
{
  sub_1000481D8();
  sub_1000481A4();
  sub_1000480D8((void *)&_mh_execute_header, v0, v1, "Unable to format: NoExclaves:%d", v2, v3, v4, v5, v6);
}

void sub_1000888AC()
{
  sub_1000481D8();
  sub_1000481A4();
  sub_1000480D8((void *)&_mh_execute_header, v0, v1, "Unable to format: UseDsymForUUID:%d", v2, v3, v4, v5, v6);
}

void sub_10008891C()
{
  sub_1000481D8();
  sub_1000481A4();
  sub_1000480D8((void *)&_mh_execute_header, v0, v1, "Unable to format: NoBulkSymbolication:%d", v2, v3, v4, v5, v6);
}

void sub_10008898C()
{
  sub_1000481A4();
  sub_1000481E8((void *)&_mh_execute_header, v0, v1, "Unable to format: Symbolicate:%d due to enable symbolication file existing:%d", v2, v3, v4, v5, v6);
}

void sub_100088A10()
{
  sub_1000481A4();
  sub_1000481E8((void *)&_mh_execute_header, v0, v1, "Unable to format: Avoid affecting audio:%d due to internal:%d", v2, v3, v4, v5, v6);
}

void sub_100088AA0()
{
  sub_10004821C();
  sub_1000481A4();
  sub_1000480D8((void *)&_mh_execute_header, v0, v1, "Unable to format: Submit service watchdog:%d unavilable on this platform", v2, v3, v4, v5, v6);
}

void sub_100088B0C()
{
  sub_10004821C();
  sub_1000481A4();
  _os_log_debug_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_DEBUG, "Submit service watchdog:%d unavilable on this platform", v1, 8u);
}

void sub_100088B84()
{
  sub_100048230();
  int v6 = v0;
  sub_10004823C();
  int v7 = v1;
  __int16 v8 = v2;
  int v9 = v3;
  _os_log_fault_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_FAULT, "Unable to format: Submit systemstats:%d sleep/wake failure:%d watchdog:%d due to suppression:%d", v5, 0x1Au);
}

void sub_100088C20()
{
  v2[0] = 67109632;
  v2[1] = ((unsigned __int16)word_1000EBD38 >> 7) & 1;
  sub_10004823C();
  v2[4] = v0;
  _os_log_fault_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_FAULT, "Unable to format: Submit resource reports cpu:%d io:%d due to suppression:%d", (uint8_t *)v2, 0x14u);
}

void sub_100088CB8()
{
  sub_1000482A4(__stack_chk_guard);
  sub_1000481B0();
  sub_1000481E8((void *)&_mh_execute_header, v0, v1, "Unable to format: Submit spins:%d hangs:%d unavilable on this platform", v2, v3, v4, v5, v6);
}

void sub_100088D24()
{
  sub_1000482A4(__stack_chk_guard);
  sub_1000481B0();
  _os_log_debug_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_DEBUG, "Submit spins:%d hangs:%d unavilable on this platform", v1, 0xEu);
}

void sub_100088D9C()
{
  sub_10003C0EC();
  sub_10003C04C((void *)&_mh_execute_header, v0, v1, "Unable to format: Apple Internal: reporting full spins %.1f%% of the time", v2, v3, v4, v5, v6);
}

void sub_100088E10(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_100088E48(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_100088E80()
{
  sub_10003C11C(__stack_chk_guard);
  sub_10003C0EC();
  sub_10003C04C((void *)&_mh_execute_header, v0, v1, "Unable to format: Got thermal level: %lld", v2, v3, v4, v5, v6);
}

void sub_100088EE8()
{
  sub_10003C11C(__stack_chk_guard);
  sub_10003C0EC();
  _os_log_debug_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_DEBUG, "Got thermal level: %lld", v1, 0xCu);
}

void sub_100088F5C()
{
  sub_100046A90();
  sub_1000480D8((void *)&_mh_execute_header, v0, v1, "Unable to format: Failed to get thermal level: %d", v2, v3, v4, v5, v6);
}

void sub_100088FC4()
{
  sub_100046A90();
  sub_100048148((void *)&_mh_execute_header, v0, v1, "Failed to get thermal level: %d", v2, v3, v4, v5, v6);
}

void sub_10008902C()
{
  sub_100046A90();
  sub_1000480D8((void *)&_mh_execute_header, v0, v1, "Unable to format: Failed to register for thermal level: %d", v2, v3, v4, v5, v6);
}

void sub_100089094()
{
  sub_100046A90();
  sub_100048148((void *)&_mh_execute_header, v0, v1, "Failed to register for thermal level: %d", v2, v3, v4, v5, v6);
}

void sub_1000890FC()
{
  sub_10003C11C(__stack_chk_guard);
  sub_10003C0EC();
  sub_10003C04C((void *)&_mh_execute_header, v0, v1, "Unable to format: GM check: Got game mode: %lld", v2, v3, v4, v5, v6);
}

void sub_100089164()
{
  sub_10003C11C(__stack_chk_guard);
  sub_10003C0EC();
  _os_log_debug_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_DEBUG, "GM check: Got game mode: %lld", v1, 0xCu);
}

void sub_1000891D8()
{
  sub_100046A90();
  sub_1000480D8((void *)&_mh_execute_header, v0, v1, "Unable to format: GM check: Failed to get game mode state: %d", v2, v3, v4, v5, v6);
}

void sub_100089240()
{
  sub_100046A90();
  sub_100048148((void *)&_mh_execute_header, v0, v1, "GM check: Failed to get game mode state: %d", v2, v3, v4, v5, v6);
}

void sub_1000892A8()
{
  sub_100046A90();
  sub_1000480D8((void *)&_mh_execute_header, v0, v1, "Unable to format: Failed to register for game mode state: %d", v2, v3, v4, v5, v6);
}

void sub_100089310()
{
  sub_100046A90();
  sub_100048148((void *)&_mh_execute_header, v0, v1, "Failed to register for game mode state: %d", v2, v3, v4, v5, v6);
}

void sub_100089378()
{
  sub_100046A90();
  sub_1000480D8((void *)&_mh_execute_header, v0, v1, "Unable to format: Unable to register for tasking update notifications: %d", v2, v3, v4, v5, v6);
}

void sub_1000893E0()
{
  sub_100046A90();
  sub_100048148((void *)&_mh_execute_header, v0, v1, "Unable to register for tasking update notifications: %d", v2, v3, v4, v5, v6);
}

void sub_100089448(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_100089480()
{
  sub_100048204();
  sub_100046694((void *)&_mh_execute_header, v0, v1, "Unable to format: Tasking setting for %@ not available, using default %.1f");
}

void sub_1000894F0()
{
  sub_100048204();
  sub_100046694((void *)&_mh_execute_header, v0, v1, "Unable to format: Tasking setting for %@: %.1f");
}

void sub_100089564()
{
  sub_10003C11C(__stack_chk_guard);
  sub_10003C0EC();
  sub_100046694((void *)&_mh_execute_header, v0, v1, "Unable to format: Tasking setting for %@: %@ isn't a number");
}

void sub_1000895D8()
{
  sub_10003C11C(__stack_chk_guard);
  sub_10003C0EC();
  __int16 v3 = 2114;
  uint64_t v4 = v0;
  _os_log_error_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_ERROR, "Tasking setting for %{public}@: %{public}@ isn't a number", v2, 0x16u);
}

void sub_10008965C(int a1, NSObject *a2)
{
  sub_10002E4E8(a1);
  __error();
  __int16 v3 = __error();
  strerror(*v3);
  sub_1000468C4();
  _os_log_fault_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_FAULT, "Unable to format: %s [%d]: Unable to get uid: %d (%s)", v4, 0x22u);
}

void sub_100089708(int a1, NSObject *a2)
{
  sub_10002E4E8(a1);
  __error();
  __int16 v3 = __error();
  strerror(*v3);
  sub_1000468C4();
  _os_log_error_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_ERROR, "%{public}s [%d]: Unable to get uid: %d (%s)", v4, 0x22u);
}

void sub_1000897B4(NSObject *a1)
{
  __error();
  uint64_t v2 = __error();
  strerror(*v2);
  sub_1000467CC();
  _os_log_fault_impl((void *)&_mh_execute_header, a1, OS_LOG_TYPE_FAULT, "Unable to format: Unable to get uid: %d (%s)", v3, 0x12u);
}

void sub_10008984C(NSObject *a1)
{
  __error();
  uint64_t v2 = __error();
  strerror(*v2);
  sub_1000467CC();
  _os_log_error_impl((void *)&_mh_execute_header, a1, OS_LOG_TYPE_ERROR, "Unable to get uid: %d (%s)", v3, 0x12u);
}

void sub_1000898E4(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_10008995C(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_1000899D4(void *a1, const char *a2)
{
  xpc_dictionary_get_string(a1, a2);
  sub_10003C0BC();
  sub_10004B040((void *)&_mh_execute_header, v2, v3, "Unable to format: Got xpc error for peer: %s", v4, v5, v6, v7, v8);
}

void sub_100089A4C(void *a1)
{
  xpc_dictionary_get_string(a1, _xpc_error_key_description);
  sub_10003C0BC();
  sub_10004B060((void *)&_mh_execute_header, v1, v2, "Got xpc error for peer: %{public}s", v3, v4, v5, v6, v7);
}

void sub_100089AD0(void *a1, const char *a2)
{
  xpc_dictionary_get_string(a1, a2);
  sub_10003C0BC();
  sub_10004B040((void *)&_mh_execute_header, v2, v3, "Unable to format: Got xpc error message in libspindump client connection: %s", v4, v5, v6, v7, v8);
}

void sub_100089B48(void *a1)
{
  xpc_dictionary_get_string(a1, _xpc_error_key_description);
  sub_10003C0BC();
  sub_10004B060((void *)&_mh_execute_header, v1, v2, "Got xpc error message in libspindump client connection: %{public}s", v3, v4, v5, v6, v7);
}

void sub_100089BCC(int a1)
{
  sub_10002E4E8(a1);
  sub_1000465D0();
  sub_1000465A0((void *)&_mh_execute_header, v1, v2, "Unable to format: %s [%d]: Unknown message to libspindump (%lld)", v3, v4, v5, v6, v7);
}

void sub_100089C54(int a1)
{
  sub_10002E4E8(a1);
  sub_1000465D0();
  sub_1000465A0((void *)&_mh_execute_header, v1, v2, "%{public}s [%d]: Unknown message to libspindump (%lld)", v3, v4, v5, v6, v7);
}

void sub_100089CDC()
{
  sub_10003C0BC();
  sub_10003C04C((void *)&_mh_execute_header, v0, v1, "Unable to format: Unknown message to libspindump (%lld)", v2, v3, v4, v5, v6);
}

void sub_100089D44()
{
  sub_10003C0BC();
  sub_10003C04C((void *)&_mh_execute_header, v0, v1, "Unknown message to libspindump (%lld)", v2, v3, v4, v5, v6);
}

void sub_100089DAC(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_100089E24(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_100089E9C(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_100089F14(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_100089F8C(int a1, NSObject *a2)
{
  sub_10002E4E8(a1);
  sub_100046564();
  _os_log_fault_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_FAULT, "Unable to format: %s [%d]: Attemping to generate spindump, but not entitled", v3, 0x12u);
}

void sub_10008A018(int a1, NSObject *a2)
{
  sub_10002E4E8(a1);
  sub_100046564();
  _os_log_error_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_ERROR, "%{public}s [%d]: Attemping to generate spindump, but not entitled", v3, 0x12u);
}

void sub_10008A0A4()
{
  sub_10004670C();
  sub_1000466D8((void *)&_mh_execute_header, v0, v1, "Unable to format: Attemping to generate spindump, but not entitled", v2, v3, v4, v5, v6);
}

void sub_10008A0D8()
{
  sub_10004670C();
  sub_10004B018((void *)&_mh_execute_header, v0, v1, "Attemping to generate spindump, but not entitled", v2, v3, v4, v5, v6);
}

void sub_10008A10C()
{
  sub_10004670C();
  sub_1000466D8((void *)&_mh_execute_header, v0, v1, "Unable to format: Error reporting CPU resource: no pid provided", v2, v3, v4, v5, v6);
}

void sub_10008A140()
{
  sub_10004670C();
  sub_10004B018((void *)&_mh_execute_header, v0, v1, "Error reporting CPU resource: no pid provided", v2, v3, v4, v5, v6);
}

void sub_10008A174()
{
  sub_10004670C();
  sub_1000466D8((void *)&_mh_execute_header, v0, v1, "Unable to format: Error reporting CPU resource: no cpu_used provided", v2, v3, v4, v5, v6);
}

void sub_10008A1A8()
{
  sub_10004670C();
  sub_10004B018((void *)&_mh_execute_header, v0, v1, "Error reporting CPU resource: no cpu_used provided", v2, v3, v4, v5, v6);
}

void sub_10008A1DC()
{
  sub_10004670C();
  sub_1000466D8((void *)&_mh_execute_header, v0, v1, "Unable to format: Error reporting CPU resource: no duration provided", v2, v3, v4, v5, v6);
}

void sub_10008A210()
{
  sub_10004670C();
  sub_10004B018((void *)&_mh_execute_header, v0, v1, "Error reporting CPU resource: no duration provided", v2, v3, v4, v5, v6);
}

void sub_10008A244()
{
  sub_10004670C();
  sub_1000466D8((void *)&_mh_execute_header, v0, v1, "Unable to format: Error reporting CPU resource: no endtime provided", v2, v3, v4, v5, v6);
}

void sub_10008A278()
{
  sub_10004670C();
  sub_10004B018((void *)&_mh_execute_header, v0, v1, "Error reporting CPU resource: no endtime provided", v2, v3, v4, v5, v6);
}

void sub_10008A2AC()
{
  sub_10004670C();
  sub_1000466D8((void *)&_mh_execute_header, v0, v1, "Unable to format: Error reporting CPU resource: no cpu_used_limit provided", v2, v3, v4, v5, v6);
}

void sub_10008A2E0()
{
  sub_10004670C();
  sub_10004B018((void *)&_mh_execute_header, v0, v1, "Error reporting CPU resource: no cpu_used_limit provided", v2, v3, v4, v5, v6);
}

void sub_10008A314()
{
  sub_10004B034();
  sub_10003C04C((void *)&_mh_execute_header, v0, v1, "Unable to format: Error reporting CPU resource: bad cpu_used_limit (%f)", v2, v3, v4, v5, v6);
}

void sub_10008A380()
{
  sub_10004B034();
  sub_10003C0A0((void *)&_mh_execute_header, v0, v1, "Error reporting CPU resource: bad cpu_used_limit (%f)", v2, v3, v4, v5, v6);
}

void sub_10008A3EC()
{
  sub_10004670C();
  sub_1000466D8((void *)&_mh_execute_header, v0, v1, "Unable to format: Error reporting CPU resource: no duration_limit provided", v2, v3, v4, v5, v6);
}

void sub_10008A420()
{
  sub_10004670C();
  sub_10004B018((void *)&_mh_execute_header, v0, v1, "Error reporting CPU resource: no duration_limit provided", v2, v3, v4, v5, v6);
}

void sub_10008A454()
{
  sub_10004B034();
  sub_10003C04C((void *)&_mh_execute_header, v0, v1, "Unable to format: Error reporting CPU resource: bad duration_limit (%f)", v2, v3, v4, v5, v6);
}

void sub_10008A4C0()
{
  sub_10004B034();
  sub_10003C0A0((void *)&_mh_execute_header, v0, v1, "Error reporting CPU resource: bad duration_limit (%f)", v2, v3, v4, v5, v6);
}

void sub_10008A52C()
{
  sub_10004B034();
  sub_10003C04C((void *)&_mh_execute_header, v0, v1, "Unable to format: Error reporting CPU resource: bad duration (%f)", v2, v3, v4, v5, v6);
}

void sub_10008A598()
{
  sub_10004B034();
  sub_10003C0A0((void *)&_mh_execute_header, v0, v1, "Error reporting CPU resource: bad duration (%f)", v2, v3, v4, v5, v6);
}

void sub_10008A604()
{
  sub_10004B034();
  sub_10003C04C((void *)&_mh_execute_header, v0, v1, "Unable to format: Error reporting CPU resource: bad cpu_used (%f)", v2, v3, v4, v5, v6);
}

void sub_10008A670()
{
  sub_10004B034();
  sub_10003C0A0((void *)&_mh_execute_header, v0, v1, "Error reporting CPU resource: bad cpu_used (%f)", v2, v3, v4, v5, v6);
}

void sub_10008A6DC()
{
  sub_10004670C();
  sub_1000466D8((void *)&_mh_execute_header, v0, v1, "Unable to format: Error reporting disk writes resource: no pid provided", v2, v3, v4, v5, v6);
}

void sub_10008A710()
{
  sub_10004670C();
  sub_10004B018((void *)&_mh_execute_header, v0, v1, "Error reporting disk writes resource: no pid provided", v2, v3, v4, v5, v6);
}

void sub_10008A744()
{
  sub_10004670C();
  sub_1000466D8((void *)&_mh_execute_header, v0, v1, "Unable to format: Error reporting disk writes resource: no num bytes provided", v2, v3, v4, v5, v6);
}

void sub_10008A778()
{
  sub_10004670C();
  sub_10004B018((void *)&_mh_execute_header, v0, v1, "Error reporting disk writes resource: no num bytes provided", v2, v3, v4, v5, v6);
}

void sub_10008A7AC()
{
  sub_10004670C();
  sub_1000466D8((void *)&_mh_execute_header, v0, v1, "Unable to format: Error reporting disk writes resource: no duration provided", v2, v3, v4, v5, v6);
}

void sub_10008A7E0()
{
  sub_10004670C();
  sub_10004B018((void *)&_mh_execute_header, v0, v1, "Error reporting disk writes resource: no duration provided", v2, v3, v4, v5, v6);
}

void sub_10008A814()
{
  sub_10004670C();
  sub_1000466D8((void *)&_mh_execute_header, v0, v1, "Unable to format: Error reporting disk writes resource: no endtime provided", v2, v3, v4, v5, v6);
}

void sub_10008A848()
{
  sub_10004670C();
  sub_10004B018((void *)&_mh_execute_header, v0, v1, "Error reporting disk writes resource: no endtime provided", v2, v3, v4, v5, v6);
}

void sub_10008A87C()
{
  sub_10004670C();
  sub_1000466D8((void *)&_mh_execute_header, v0, v1, "Unable to format: Error reporting disk writes resource: no duration_limit provided", v2, v3, v4, v5, v6);
}

void sub_10008A8B0()
{
  sub_10004670C();
  sub_10004B018((void *)&_mh_execute_header, v0, v1, "Error reporting disk writes resource: no duration_limit provided", v2, v3, v4, v5, v6);
}

void sub_10008A8E4()
{
  sub_10004B034();
  sub_10003C04C((void *)&_mh_execute_header, v0, v1, "Unable to format: Error reporting disk writes resource: bad duration_limit (%f)", v2, v3, v4, v5, v6);
}

void sub_10008A950()
{
  sub_10004B034();
  sub_10003C0A0((void *)&_mh_execute_header, v0, v1, "Error reporting disk writes resource: bad duration_limit (%f)", v2, v3, v4, v5, v6);
}

void sub_10008A9BC()
{
  sub_10004B034();
  sub_10003C04C((void *)&_mh_execute_header, v0, v1, "Unable to format: Error reporting disk writes resource: bad duration (%f)", v2, v3, v4, v5, v6);
}

void sub_10008AA28()
{
  sub_10004B034();
  sub_10003C0A0((void *)&_mh_execute_header, v0, v1, "Error reporting disk writes resource: bad duration (%f)", v2, v3, v4, v5, v6);
}

void sub_10008AA94()
{
  sub_10004670C();
  sub_1000466D8((void *)&_mh_execute_header, v0, v1, "Unable to format: Error reporting fd exhaustion: no pid provided", v2, v3, v4, v5, v6);
}

void sub_10008AAC8()
{
  sub_10004670C();
  sub_10004B018((void *)&_mh_execute_header, v0, v1, "Error reporting fd exhaustion: no pid provided", v2, v3, v4, v5, v6);
}

void sub_10008AAFC()
{
  sub_10004670C();
  sub_1000466D8((void *)&_mh_execute_header, v0, v1, "Unable to format: Error reporting fd exhaustion: no num fds provided", v2, v3, v4, v5, v6);
}

void sub_10008AB30()
{
  sub_10004670C();
  sub_10004B018((void *)&_mh_execute_header, v0, v1, "Error reporting fd exhaustion: no num fds provided", v2, v3, v4, v5, v6);
}

void sub_10008AB64()
{
  sub_10004670C();
  sub_1000466D8((void *)&_mh_execute_header, v0, v1, "Unable to format: Error reporting port exhaustion: no pid provided", v2, v3, v4, v5, v6);
}

void sub_10008AB98()
{
  sub_10004670C();
  sub_10004B018((void *)&_mh_execute_header, v0, v1, "Error reporting port exhaustion: no pid provided", v2, v3, v4, v5, v6);
}

void sub_10008ABCC()
{
  sub_10004670C();
  sub_1000466D8((void *)&_mh_execute_header, v0, v1, "Unable to format: Error reporting port exhaustion: no num ports provided", v2, v3, v4, v5, v6);
}

void sub_10008AC00()
{
  sub_10004670C();
  sub_10004B018((void *)&_mh_execute_header, v0, v1, "Error reporting port exhaustion: no num ports provided", v2, v3, v4, v5, v6);
}

void sub_10008AC34()
{
  sub_10004670C();
  sub_1000466D8((void *)&_mh_execute_header, v0, v1, "Unable to format: Error reporting kqworkloop exhaustion: no pid provided", v2, v3, v4, v5, v6);
}

void sub_10008AC68()
{
  sub_10004670C();
  sub_10004B018((void *)&_mh_execute_header, v0, v1, "Error reporting kqworkloop exhaustion: no pid provided", v2, v3, v4, v5, v6);
}

void sub_10008AC9C()
{
  sub_10004670C();
  sub_1000466D8((void *)&_mh_execute_header, v0, v1, "Unable to format: Error reporting kqworkloop exhaustion: no num kqworkloops provided", v2, v3, v4, v5, v6);
}

void sub_10008ACD0()
{
  sub_10004670C();
  sub_10004B018((void *)&_mh_execute_header, v0, v1, "Error reporting kqworkloop exhaustion: no num kqworkloops provided", v2, v3, v4, v5, v6);
}

void sub_10008AD04()
{
  sub_10004670C();
  sub_1000466D8((void *)&_mh_execute_header, v0, v1, "Unable to format: Error reporting workflow repsonsiveness delay: no tailspin file provided", v2, v3, v4, v5, v6);
}

void sub_10008AD38()
{
  sub_10004670C();
  sub_10004B018((void *)&_mh_execute_header, v0, v1, "Error reporting workflow repsonsiveness delay: no tailspin file provided", v2, v3, v4, v5, v6);
}

void sub_10008AD6C(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_10003C04C((void *)&_mh_execute_header, a1, a3, "Unable to format: %s: _HandleMicrostackshots returned a SASampleStore when saving to a file", a5, a6, a7, a8, 2u);
}

void sub_10008ADE4(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_10003C0A0((void *)&_mh_execute_header, a1, a3, "%s: _HandleMicrostackshots returned a SASampleStore when saving to a file", a5, a6, a7, a8, 2u);
}

void sub_10008AE5C()
{
  sub_100046668();
  __error();
  uint64_t v0 = __error();
  strerror(*v0);
  sub_1000466B4();
  sub_1000465A0((void *)&_mh_execute_header, v1, v2, "Unable to format: Unable to open %s: %d (%s)", v3, v4, v5, v6, v7);
}

void sub_10008AEF0()
{
  sub_100046668();
  __error();
  uint64_t v0 = __error();
  strerror(*v0);
  sub_1000466B4();
  sub_100046874((void *)&_mh_execute_header, v1, v2, "Unable to open %s: %d (%s)", v3, v4, v5, v6, v7);
}

void sub_10008AF80()
{
  sub_100046668();
  __error();
  uint64_t v0 = __error();
  strerror(*v0);
  sub_1000466B4();
  sub_1000465A0((void *)&_mh_execute_header, v1, v2, "Unable to format: Unable to gzdopen datastore file %s: %d (%s)", v3, v4, v5, v6, v7);
}

void sub_10008B014()
{
  sub_100046668();
  __error();
  uint64_t v0 = __error();
  strerror(*v0);
  sub_1000466B4();
  sub_100046874((void *)&_mh_execute_header, v1, v2, "Unable to gzdopen datastore file %s: %d (%s)", v3, v4, v5, v6, v7);
}

void sub_10008B0A4()
{
  sub_10004670C();
  sub_1000466D8((void *)&_mh_execute_header, v0, v1, "Unable to format: Avoiding inspecting live processes for microstackshot report due to audio running", v2, v3, v4, v5, v6);
}

void sub_10008B0D8()
{
  sub_1000465C0();
  __error();
  uint64_t v0 = __error();
  strerror(*v0);
  sub_10004B974();
  sub_10004BB2C((void *)&_mh_execute_header, v1, v2, "Unable to format: Unable to seek %s to offset %lld: %d (%s)", v3, v4, v5, v6, v7);
}

void sub_10008B16C()
{
  sub_1000465C0();
  __error();
  uint64_t v0 = __error();
  strerror(*v0);
  sub_10004B974();
  sub_10004BACC((void *)&_mh_execute_header, v1, v2, "Unable to seek %s to offset %lld: %d (%s)", v3, v4, v5, v6, v7);
}

void sub_10008B1FC(uint64_t a1, uint64_t a2, int a3)
{
  sub_10004BA64(a1, a2, a3, 1.5047e-36);
  sub_10004B9C4((void *)&_mh_execute_header, v5, v3, "Unable to format: Error grabbing microstackshots: %d (%s)", v4);
}

void sub_10008B23C(uint64_t a1, uint64_t a2, int a3)
{
  sub_10004BA64(a1, a2, a3, 1.5047e-36);
  sub_10004B9DC((void *)&_mh_execute_header, v5, v3, "Error grabbing microstackshots: %d (%s)", v4);
}

void sub_10008B27C()
{
  sub_1000465C0();
  __error();
  uint64_t v0 = __error();
  strerror(*v0);
  sub_10004B974();
  sub_10004BB2C((void *)&_mh_execute_header, v1, v2, "Unable to format: Unable to seek %s to offset %lld: %d (%s)", v3, v4, v5, v6, v7);
}

void sub_10008B310()
{
  sub_1000465C0();
  __error();
  uint64_t v0 = __error();
  strerror(*v0);
  sub_10004B974();
  sub_10004BACC((void *)&_mh_execute_header, v1, v2, "Unable to seek %s to offset %lld: %d (%s)", v3, v4, v5, v6, v7);
}

void sub_10008B3A4()
{
  sub_100046668();
  __error();
  uint64_t v0 = __error();
  strerror(*v0);
  sub_1000466B4();
  sub_1000465A0((void *)&_mh_execute_header, v1, v2, "Unable to format: Unable to open datastore file %s: %d (%s)", v3, v4, v5, v6, v7);
}

void sub_10008B438()
{
  sub_100046668();
  __error();
  uint64_t v0 = __error();
  strerror(*v0);
  sub_1000466B4();
  sub_100046874((void *)&_mh_execute_header, v1, v2, "Unable to open datastore file %s: %d (%s)", v3, v4, v5, v6, v7);
}

void sub_10008B4C8(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_10003C04C((void *)&_mh_execute_header, a1, a3, "Unable to format: %s: Didn't already return without report option", a5, a6, a7, a8, 2u);
}

void sub_10008B540(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_10003C0A0((void *)&_mh_execute_header, a1, a3, "%s: Didn't already return without report option", a5, a6, a7, a8, 2u);
}

void sub_10008B5B8(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_10008B630(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_10008B6A8(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_10008B720(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_10008B798(void *a1)
{
  [a1 systemstatsFormat];
  sub_10004BA48();
  sub_100046A70((void *)&_mh_execute_header, v1, v2, "Unable to format: %s: report_type %d, but systemstatsFormat %d", v3, v4, v5, v6, 2u);
}

void sub_10008B820(void *a1, uint64_t a2, NSObject *a3)
{
  [a1 systemstatsFormat];
  v4[0] = 136315650;
  sub_10004BA48();
  _os_log_error_impl((void *)&_mh_execute_header, a3, OS_LOG_TYPE_ERROR, "%s: report_type %d, but systemstatsFormat %d", (uint8_t *)v4, 0x18u);
}

void sub_10008B8B8()
{
  sub_100046668();
  sub_10002E4E8(v0);
  sub_100046564();
  sub_100046614((void *)&_mh_execute_header, v1, v2, "Unable to format: %s [%d]: No microstackshots found", v3, v4, v5, v6, v7);
}

void sub_10008B930()
{
  sub_100046668();
  sub_10002E4E8(v0);
  sub_100046564();
  sub_100046A30((void *)&_mh_execute_header, v1, v2, "%{public}s [%d]: No microstackshots found", v3, v4, v5, v6, v7);
}

void sub_10008B9A8()
{
  sub_10004670C();
  sub_1000466D8((void *)&_mh_execute_header, v0, v1, "Unable to format: No microstackshots found", v2, v3, v4, v5, v6);
}

void sub_10008B9DC()
{
  sub_10004670C();
  sub_10004B018((void *)&_mh_execute_header, v0, v1, "No microstackshots found", v2, v3, v4, v5, v6);
}

void sub_10008BA10(void *a1, NSObject *a2)
{
  [a1 numSamples];
  sub_10003C0BC();
  _os_log_fault_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_FAULT, "Unable to format: -last provided, but unable to get data end time (%lu samples)", v3, 0xCu);
}

void sub_10008BA98(void *a1, NSObject *a2)
{
  [a1 numSamples];
  sub_10003C0BC();
  _os_log_error_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_ERROR, "-last provided, but unable to get data end time (%lu samples)", v3, 0xCu);
}

#error "10008BB80: call analysis failed (funcsize=35)"

#error "10008BC14: call analysis failed (funcsize=35)"

void sub_10008BC48()
{
  sub_100046A9C();
  int v0 = __error();
  strerror(*v0);
  sub_1000466B4();
  sub_1000465A0((void *)&_mh_execute_header, v1, v2, "Unable to format: could not open log file %@: %d (%s)", v3, v4, v5, v6, v7);
}

void sub_10008BCD4()
{
  sub_100046A9C();
  int v0 = __error();
  strerror(*v0);
  sub_1000466B4();
  sub_100046874((void *)&_mh_execute_header, v1, v2, "could not open log file %@: %d (%s)", v3, v4, v5, v6, v7);
}

void sub_10008BD60(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

#error "10008BE30: call analysis failed (funcsize=35)"

#error "10008BEC4: call analysis failed (funcsize=35)"

void sub_10008BEF8()
{
  sub_100046A9C();
  int v0 = __error();
  strerror(*v0);
  sub_1000466B4();
  sub_1000465A0((void *)&_mh_execute_header, v1, v2, "Unable to format: could not write to file %@: %d (%s)", v3, v4, v5, v6, v7);
}

void sub_10008BF84()
{
  sub_100046A9C();
  int v0 = __error();
  strerror(*v0);
  sub_1000466B4();
  sub_100046874((void *)&_mh_execute_header, v1, v2, "could not write to file %@: %d (%s)", v3, v4, v5, v6, v7);
}

#error "10008C070: call analysis failed (funcsize=35)"

#error "10008C104: call analysis failed (funcsize=35)"

void sub_10008C138()
{
  sub_100046A9C();
  int v0 = __error();
  strerror(*v0);
  sub_1000466B4();
  sub_1000465A0((void *)&_mh_execute_header, v1, v2, "Unable to format: could not fdopen log file %@: %d (%s)", v3, v4, v5, v6, v7);
}

void sub_10008C1C4()
{
  sub_100046A9C();
  int v0 = __error();
  strerror(*v0);
  sub_1000466B4();
  sub_100046874((void *)&_mh_execute_header, v1, v2, "could not fdopen log file %@: %d (%s)", v3, v4, v5, v6, v7);
}

void sub_10008C250()
{
  sub_1000465C0();
  sub_10002E4E8(v0);
  sub_10004B9A4();
  sub_10004BA04();
  sub_10004BAEC((void *)&_mh_execute_header, v1, v2, "Unable to format: %s [%d]: %s: Bad report type %d", v3, v4, v5, v6, v7);
}

void sub_10008C2DC()
{
  sub_1000465C0();
  sub_10002E4E8(v0);
  sub_10004B9A4();
  sub_10004BA04();
  sub_10004BA8C((void *)&_mh_execute_header, v1, v2, "%s [%d]: %s: Bad report type %d", v3, v4, v5, v6, v7);
}

void sub_10008C368()
{
  v2[0] = 136315394;
  sub_100048290();
  sub_10004B9C4((void *)&_mh_execute_header, v0, v1, "Unable to format: %s: Bad report type %d", (uint8_t *)v2);
}

void sub_10008C3E0()
{
  v2[0] = 136315394;
  sub_100048290();
  sub_10004B9DC((void *)&_mh_execute_header, v0, v1, "%s: Bad report type %d", (uint8_t *)v2);
}

void sub_10008C458()
{
  sub_10004670C();
  sub_1000466D8((void *)&_mh_execute_header, v0, v1, "Unable to format: No file to append", v2, v3, v4, v5, v6);
}

void sub_10008C48C()
{
  sub_10004670C();
  _os_log_debug_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_DEBUG, "No file to append", v1, 2u);
}

void sub_10008C4CC(uint64_t a1, id *a2)
{
  [*a2 localizedDescription];
  sub_10004B9F4();
  sub_10004BB0C((void *)&_mh_execute_header, v2, v3, "Unable to format: reading in data file %s failed: %@", v4, v5, v6, v7, 2u);
}

void sub_10008C554(uint64_t a1, id *a2)
{
  [*a2 localizedDescription];
  sub_10004B9F4();
  sub_10004BAAC((void *)&_mh_execute_header, v2, v3, "reading in data file %s failed: %@", v4, v5, v6, v7, 2u);
}

void sub_10008C5DC()
{
  sub_10003C0BC();
  sub_10003C04C((void *)&_mh_execute_header, v0, v1, "Unable to format: Appending data file %s", v2, v3, v4, v5, v6);
}

void sub_10008C644()
{
  sub_10003C0BC();
  _os_log_debug_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_DEBUG, "Appending data file %s", v1, 0xCu);
}

void sub_10008C6B8()
{
  sub_100046668();
  sub_10002E4E8(v0);
  sub_100046564();
  sub_100046614((void *)&_mh_execute_header, v1, v2, "Unable to format: %s [%d]: MetricKit unavailable, not providing cpu usage report", v3, v4, v5, v6, v7);
}

void sub_10008C730()
{
  sub_100046668();
  sub_10002E4E8(v0);
  sub_100046564();
  sub_100046A30((void *)&_mh_execute_header, v1, v2, "%{public}s [%d]: MetricKit unavailable, not providing cpu usage report", v3, v4, v5, v6, v7);
}

void sub_10008C7A8()
{
  sub_10004670C();
  sub_1000466D8((void *)&_mh_execute_header, v0, v1, "Unable to format: MetricKit unavailable, not providing cpu usage report", v2, v3, v4, v5, v6);
}

void sub_10008C7DC()
{
  sub_10004670C();
  sub_10004B018((void *)&_mh_execute_header, v0, v1, "MetricKit unavailable, not providing cpu usage report", v2, v3, v4, v5, v6);
}

void sub_10008C810()
{
  sub_100046668();
  sub_10002E4E8(v0);
  sub_100046564();
  sub_100046614((void *)&_mh_execute_header, v1, v2, "Unable to format: %s [%d]: Providing cpu usage report to MetricKit", v3, v4, v5, v6, v7);
}

void sub_10008C888()
{
  sub_10004670C();
  sub_1000466D8((void *)&_mh_execute_header, v0, v1, "Unable to format: Providing cpu usage report to MetricKit", v2, v3, v4, v5, v6);
}

void sub_10008C8BC()
{
  sub_100046668();
  sub_10002E4E8(v0);
  sub_100046564();
  sub_100046614((void *)&_mh_execute_header, v1, v2, "Unable to format: %s [%d]: MetricKit unavailable, not providing disk writes report", v3, v4, v5, v6, v7);
}

void sub_10008C934()
{
  sub_100046668();
  sub_10002E4E8(v0);
  sub_100046564();
  sub_100046A30((void *)&_mh_execute_header, v1, v2, "%{public}s [%d]: MetricKit unavailable, not providing disk writes report", v3, v4, v5, v6, v7);
}

void sub_10008C9AC()
{
  sub_10004670C();
  sub_1000466D8((void *)&_mh_execute_header, v0, v1, "Unable to format: MetricKit unavailable, not providing disk writes report", v2, v3, v4, v5, v6);
}

void sub_10008C9E0()
{
  sub_10004670C();
  sub_10004B018((void *)&_mh_execute_header, v0, v1, "MetricKit unavailable, not providing disk writes report", v2, v3, v4, v5, v6);
}

void sub_10008CA14()
{
  sub_100046668();
  sub_10002E4E8(v0);
  sub_100046564();
  sub_100046614((void *)&_mh_execute_header, v1, v2, "Unable to format: %s [%d]: Providing disk writes report to MetricKit", v3, v4, v5, v6, v7);
}

void sub_10008CA8C()
{
  sub_10004670C();
  sub_1000466D8((void *)&_mh_execute_header, v0, v1, "Unable to format: Providing disk writes report to MetricKit", v2, v3, v4, v5, v6);
}

void sub_10008CAC0()
{
  sub_1000465C0();
  sub_10002E4E8(v0);
  sub_100046738();
  sub_100046A70((void *)&_mh_execute_header, v1, v2, "Unable to format: %s [%d]: Not providing unsupported report type (%d) to MetricKit", v3, v4, v5, v6, v7);
}

void sub_10008CB40()
{
  sub_1000465C0();
  sub_10002E4E8(v1);
  sub_100046738();
  _os_log_debug_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_DEBUG, "%{public}s [%d]: Not providing unsupported report type (%d) to MetricKit", v2, 0x18u);
}

void sub_10008CBD0(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_10008CC3C(int a1, NSObject *a2)
{
  v2[0] = 67109120;
  v2[1] = a1;
  _os_log_debug_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_DEBUG, "Not providing unsupported report type (%d) to MetricKit", (uint8_t *)v2, 8u);
}

void sub_10008CCB4(void *a1)
{
  [a1 debugDescription];
  sub_10004B9F4();
  sub_10004BB0C((void *)&_mh_execute_header, v1, v2, "Unable to format: -last provided, but unable to calculate %.0f seconds earlier than %@", v3, v4, v5, v6, 2u);
}

void sub_10008CD40(void *a1)
{
  [a1 debugDescription];
  sub_10004B9F4();
  sub_10004BAAC((void *)&_mh_execute_header, v1, v2, "-last provided, but unable to calculate %.0f seconds earlier than %@", v3, v4, v5, v6, 2u);
}

void sub_10008CDCC()
{
  sub_1000465C0();
  sub_10002E4E8(v0);
  sub_10004B9A4();
  sub_10004BA04();
  sub_10004BAEC((void *)&_mh_execute_header, v1, v2, "Unable to format: %s [%d]: %s: Bad report type for microstackshots %d", v3, v4, v5, v6, v7);
}

void sub_10008CE58()
{
  sub_1000465C0();
  sub_10002E4E8(v0);
  sub_10004B9A4();
  sub_10004BA04();
  sub_10004BA8C((void *)&_mh_execute_header, v1, v2, "%s [%d]: %s: Bad report type for microstackshots %d", v3, v4, v5, v6, v7);
}

void sub_10008CEE4()
{
  v2[0] = 136315394;
  sub_100048290();
  sub_10004B9C4((void *)&_mh_execute_header, v0, v1, "Unable to format: %s: Bad report type for microstackshots %d", (uint8_t *)v2);
}

void sub_10008CF5C()
{
  v2[0] = 136315394;
  sub_100048290();
  sub_10004B9DC((void *)&_mh_execute_header, v0, v1, "%s: Bad report type for microstackshots %d", (uint8_t *)v2);
}

void sub_10008CFD4(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_10008D04C(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_10008D0C4()
{
  sub_10004670C();
  sub_1000466D8((void *)&_mh_execute_header, v0, v1, "Unable to format: Data does not contain microstackshots", v2, v3, v4, v5, v6);
}

void sub_10008D0F8()
{
  sub_10004670C();
  sub_10004B018((void *)&_mh_execute_header, v0, v1, "Data does not contain microstackshots", v2, v3, v4, v5, v6);
}

void sub_10008D12C(int *a1)
{
  strerror(*a1);
  sub_1000467CC();
  sub_100046614((void *)&_mh_execute_header, v1, v2, "Unable to format: Read failed for microstackshots: %d (%s)", v3, v4, v5, v6, v7);
}

void sub_10008D1AC(int *a1)
{
  strerror(*a1);
  sub_1000467CC();
  sub_100046A30((void *)&_mh_execute_header, v1, v2, "Read failed for microstackshots: %d (%s)", v3, v4, v5, v6, v7);
}

void sub_10008D22C(int *a1, uint64_t a2, NSObject *a3)
{
  int v3 = *a1;
  v4[0] = 67109378;
  v4[1] = v3;
  __int16 v5 = 2080;
  uint64_t v6 = a2;
  sub_10004B9C4((void *)&_mh_execute_header, a3, (uint64_t)a3, "Unable to format: Read failed for microstackshots: %d (%s)", (uint8_t *)v4);
}

void sub_10008D2B0(int *a1, uint64_t a2, NSObject *a3)
{
  int v3 = *a1;
  v4[0] = 67109378;
  v4[1] = v3;
  __int16 v5 = 2082;
  uint64_t v6 = a2;
  sub_10004B9DC((void *)&_mh_execute_header, a3, (uint64_t)a3, "Read failed for microstackshots: %d (%{public}s)", (uint8_t *)v4);
}

void sub_10008D334()
{
  v1[0] = 136315650;
  sub_10004BA2C();
  _os_log_fault_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_FAULT, "Unable to format: %s: buf %lu, cap %lu", (uint8_t *)v1, 0x20u);
}

void sub_10008D3B8()
{
  v1[0] = 136315650;
  sub_10004BA2C();
  _os_log_error_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_ERROR, "%s: buf %lu, cap %lu", (uint8_t *)v1, 0x20u);
}

void sub_10008D43C()
{
  v1[0] = 136315394;
  sub_10004BB4C();
  _os_log_fault_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_FAULT, "Unable to format: %s: realloc to %lu failed", (uint8_t *)v1, 0x16u);
}

void sub_10008D4BC()
{
  v1[0] = 136315394;
  sub_10004BB4C();
  _os_log_error_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_ERROR, "%s: realloc to %lu failed", (uint8_t *)v1, 0x16u);
}

void sub_10008D53C()
{
  sub_10004670C();
  sub_1000466D8((void *)&_mh_execute_header, v0, v1, "Unable to format: Already timed out, not parsing system stats microstackshots", v2, v3, v4, v5, v6);
}

void sub_10008D570()
{
  sub_10004670C();
  _os_log_debug_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_DEBUG, "Already timed out, not parsing system stats microstackshots", v1, 2u);
}

void sub_10008D5B0()
{
  sub_10004BA7C();
  sub_1000480D8((void *)&_mh_execute_header, v0, v1, "Unable to format: Timed out waiting for system stats microstackshots after %d seconds", v2, v3, v4, v5, v6);
}

void sub_10008D61C()
{
  sub_10004BA7C();
  _os_log_error_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_ERROR, "Timed out waiting for system stats microstackshots after %d seconds", v1, 8u);
}

void sub_10008D694()
{
  sub_10004BA7C();
  sub_1000480D8((void *)&_mh_execute_header, v0, v1, "Unable to format: Timed out system stats microstackshots after %d seconds, but it's parsing, so waiting a bit longer", v2, v3, v4, v5, v6);
}

void sub_10008D700(int a1, NSObject *a2)
{
  v2[0] = 67109120;
  v2[1] = a1;
  _os_log_fault_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_FAULT, "Unable to format: SaveReport: Unsupported status %d", (uint8_t *)v2, 8u);
}

void sub_10008D778(int a1, NSObject *a2)
{
  v2[0] = 67109120;
  v2[1] = a1;
  _os_log_fault_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_FAULT, "SaveReport: Unsupported status %d", (uint8_t *)v2, 8u);
}

void sub_10008D7F0()
{
  __error();
  os_log_t v0 = __error();
  strerror(*v0);
  sub_1000466B4();
  sub_1000465A0((void *)&_mh_execute_header, v1, v2, "Unable to format: Unable to create stream from %@: %d (%s)", v3, v4, v5, v6, v7);
}

void sub_10008D884()
{
  __error();
  os_log_t v0 = __error();
  strerror(*v0);
  sub_1000466B4();
  sub_1000465A0((void *)&_mh_execute_header, v1, v2, "Unable to create stream from %@: %d (%s)", v3, v4, v5, v6, v7);
}

void sub_10008D918(void *a1)
{
  [objc_msgSend(objc_msgSend(objc_msgSend(objc_msgSend(a1, "sampleStore"), "targetProcess"), "debugDescription"), "UTF8String");
  sub_10004D93C();
  sub_10004BB0C((void *)&_mh_execute_header, v1, v2, "Unable to format: %s: No app name for cpu resource report %s", v3, v4, v5, v6, 2u);
}

void sub_10008D9A8(void *a1)
{
  [objc_msgSend(objc_msgSend(objc_msgSend(objc_msgSend(a1, "sampleStore"), "targetProcess"), "debugDescription"), "UTF8String"];
  sub_10004D93C();
  sub_10004BAAC((void *)&_mh_execute_header, v1, v2, "%s: No app name for cpu resource report %s", v3, v4, v5, v6, 2u);
}

void sub_10008DA38(NSObject *a1, uint64_t a2, uint64_t a3)
{
  int v3 = 136315138;
  uint64_t v4 = "!url_out";
  sub_10004D970((void *)&_mh_execute_header, a1, a3, "Unable to format: %s: asking for URL when generating report via OSA", (uint8_t *)&v3);
}

void sub_10008DAB4(os_log_t log)
{
  int v1 = 136315138;
  uint64_t v2 = "!url_out";
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "%s: asking for URL when generating report via OSA", (uint8_t *)&v1, 0xCu);
}

void sub_10008DB38(void *a1)
{
  [objc_msgSend(objc_msgSend(objc_msgSend(objc_msgSend(a1, "sampleStore"), "targetProcess"), "name"), "UTF8String"]
  sub_10004D988();
  sub_10004BB0C((void *)&_mh_execute_header, v1, v2, "Unable to format: %s: %s: DID_MANUAL status while reporting", v3, v4, v5, v6, 2u);
}

void sub_10008DBD8(void *a1)
{
  [objc_msgSend(objc_msgSend(objc_msgSend(objc_msgSend(a1, "sampleStore"), "targetProcess"), "name"), "UTF8String");
  sub_10004D988();
  sub_10004BAAC((void *)&_mh_execute_header, v1, v2, "%s: %s: DID_MANUAL status while reporting", v3, v4, v5, v6, 2u);
}

void sub_10008DC78()
{
  sub_10003C0BC();
  sub_10004D970((void *)&_mh_execute_header, v0, v1, "Unable to format: Saving %s report", v2);
}

void sub_10008DCE4(unsigned int a1, char a2, NSObject *a3)
{
  sub_1000249A0(a1, a2 & 1);
  sub_10003C0BC();
  _os_log_debug_impl((void *)&_mh_execute_header, a3, OS_LOG_TYPE_DEBUG, "Saving %s report", v4, 0xCu);
}

void sub_10008DD70(os_log_t log)
{
  *(_WORD *)uint64_t v1 = 0;
  _os_log_fault_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_FAULT, "Unable to format: No bug type for fatal disk writes reports, using non-fatal bug type", v1, 2u);
}

void sub_10008DDB4(os_log_t log)
{
  *(_WORD *)uint64_t v1 = 0;
  _os_log_fault_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_FAULT, "No bug type for fatal disk writes reports, using non-fatal bug type", v1, 2u);
}

void sub_10008DDF8(void *a1, NSObject *a2)
{
  [a1 debugDescription];
  sub_10003C0BC();
  sub_10004D970((void *)&_mh_execute_header, a2, v3, "Unable to format: OSAWriteLogForSubmission provided invalid fd: %@", v4);
}

void sub_10008DE78(void *a1, NSObject *a2)
{
  [a1 debugDescription];
  sub_10003C0BC();
  sub_10004D970((void *)&_mh_execute_header, a2, v3, "OSAWriteLogForSubmission provided invalid fd: %@", v4);
}

void sub_10008DEF8()
{
  __error();
  sub_1000481A4();
  sub_10004D950((void *)&_mh_execute_header, v0, v1, "Unable to format: dup of OSA file handle failed: %{errnod}d", v2, v3, v4, v5, v6);
}

void sub_10008DF74()
{
  __error();
  sub_1000481A4();
  sub_10004D950((void *)&_mh_execute_header, v0, v1, "dup of OSA file handle failed: %{errnod}d", v2, v3, v4, v5, v6);
}

void sub_10008DFF0()
{
  __error();
  sub_1000481A4();
  sub_10004D950((void *)&_mh_execute_header, v0, v1, "Unable to format: unable to fdopen OSA dup fd: %{errno}d", v2, v3, v4, v5, v6);
}

void sub_10008E06C()
{
  __error();
  sub_1000481A4();
  sub_10004D950((void *)&_mh_execute_header, v0, v1, "unable to fdopen OSA dup fd: %{errno}d", v2, v3, v4, v5, v6);
}

void sub_10008E0E8(FILE *a1)
{
  int v1 = ferror(a1);
  strerror(v1);
  sub_1000467CC();
  sub_100046614((void *)&_mh_execute_header, v2, v3, "Unable to format: Unable to write post-blob to output file: %d (%s)", v4, v5, v6, v7, v8);
}

void sub_10008E168(FILE *a1)
{
  int v1 = ferror(a1);
  strerror(v1);
  sub_1000467CC();
  sub_100046A30((void *)&_mh_execute_header, v2, v3, "Unable to write post-blob to output file: %d (%s)", v4, v5, v6, v7, v8);
}

void sub_10008E1E8(FILE *a1)
{
  int v1 = ferror(a1);
  strerror(v1);
  sub_1000467CC();
  sub_100046614((void *)&_mh_execute_header, v2, v3, "Unable to format: Unable to write pre-blob to output file: %d (%s)", v4, v5, v6, v7, v8);
}

void sub_10008E268(FILE *a1)
{
  int v1 = ferror(a1);
  strerror(v1);
  sub_1000467CC();
  sub_100046A30((void *)&_mh_execute_header, v2, v3, "Unable to write pre-blob to output file: %d (%s)", v4, v5, v6, v7, v8);
}

void sub_10008E2E8()
{
  sub_10004670C();
  sub_1000466D8((void *)&_mh_execute_header, v0, v1, "Unable to format: Deferred reports not supported, not checking for them", v2, v3, v4, v5, v6);
}

void sub_10008E31C()
{
  sub_10004670C();
  sub_1000466D8((void *)&_mh_execute_header, v0, v1, "Unable to format: Registered for deferred report generation", v2, v3, v4, v5, v6);
}

void sub_10008E350()
{
  sub_10004670C();
  sub_100046758((void *)&_mh_execute_header, v0, v1, "Registered for deferred report generation", v2, v3, v4, v5, v6);
}

void sub_10008E384()
{
  sub_10004670C();
  sub_1000466D8((void *)&_mh_execute_header, v0, v1, "Unable to format: Failed to register for deferred report generation", v2, v3, v4, v5, v6);
}

void sub_10008E3B8()
{
  sub_10004670C();
  sub_1000466D8((void *)&_mh_execute_header, v0, v1, "Failed to register for deferred report generation", v2, v3, v4, v5, v6);
}

void sub_10008E3EC()
{
  sub_10003C11C(__stack_chk_guard);
  sub_10003C0EC();
  sub_10003C04C((void *)&_mh_execute_header, v0, v1, "Unable to format: Failed to set expiry: %@", v2, v3, v4, v5, v6);
}

void sub_10008E454()
{
  sub_10003C11C(__stack_chk_guard);
  sub_10003C0EC();
  sub_10003C04C((void *)&_mh_execute_header, v0, v1, "Failed to set expiry: %@", v2, v3, v4, v5, v6);
}

void sub_10008E4BC()
{
  sub_10004670C();
  sub_1000466D8((void *)&_mh_execute_header, v0, v1, "Unable to format: Attempting to defer reports when not supported. Caller should check before calling", v2, v3, v4, v5, v6);
}

void sub_10008E4F0()
{
  sub_10004670C();
  sub_1000466D8((void *)&_mh_execute_header, v0, v1, "Attempting to defer reports when not supported. Caller should check before calling", v2, v3, v4, v5, v6);
}

void sub_10008E524()
{
  sub_10004670C();
  sub_1000466D8((void *)&_mh_execute_header, v0, v1, "Unable to format: Submitted deferred report task successfully", v2, v3, v4, v5, v6);
}

void sub_10008E558()
{
  sub_10004670C();
  sub_100046758((void *)&_mh_execute_header, v0, v1, "Submitted deferred report task successfully", v2, v3, v4, v5, v6);
}

void sub_10008E58C()
{
  sub_10003C11C(__stack_chk_guard);
  sub_10003C0EC();
  sub_10003C04C((void *)&_mh_execute_header, v0, v1, "Unable to format: Failed to submit task with error: %@", v2, v3, v4, v5, v6);
}

void sub_10008E5F4()
{
  sub_10003C11C(__stack_chk_guard);
  sub_10003C0EC();
  sub_10003C04C((void *)&_mh_execute_header, v0, v1, "Failed to submit task with error: %@", v2, v3, v4, v5, v6);
}

void sub_10008E65C()
{
  sub_10004670C();
  sub_1000466D8((void *)&_mh_execute_header, v0, v1, "Unable to format: Deferred report task already exists", v2, v3, v4, v5, v6);
}

void sub_10008E690()
{
  sub_10004670C();
  sub_100046758((void *)&_mh_execute_header, v0, v1, "Deferred report task already exists", v2, v3, v4, v5, v6);
}

void sub_10008E6C4(void *a1)
{
  [a1 count];
  sub_10004B040((void *)&_mh_execute_header, v1, v2, "Unable to format: Added report to pending deferred reports (have %lu)", v3, v4, v5, v6, 0);
}

void sub_10008E740()
{
  sub_10003C11C(__stack_chk_guard);
  sub_10003C0EC();
  sub_10003C04C((void *)&_mh_execute_header, v0, v1, "Unable to format: Unable to remove deferred reports plist: %@", v2, v3, v4, v5, v6);
}

void sub_10008E7A8()
{
  sub_10003C11C(__stack_chk_guard);
  sub_10003C0EC();
  sub_10003C04C((void *)&_mh_execute_header, v0, v1, "Unable to remove deferred reports plist: %@", v2, v3, v4, v5, v6);
}

void sub_10008E810()
{
  sub_1000525B0();
  [v0 count];
  sub_10005257C();
  sub_10004BB0C((void *)&_mh_execute_header, v1, v2, "Unable to format: Unable to write %lu deferred reports to plist: %@", v3, v4, v5, v6, v7);
}

void sub_10008E88C()
{
  sub_1000525B0();
  [v0 count];
  sub_10005257C();
  sub_10004BB0C((void *)&_mh_execute_header, v1, v2, "Unable to write %lu deferred reports to plist: %@", v3, v4, v5, v6, v7);
}

void sub_10008E908()
{
  sub_10003C11C(__stack_chk_guard);
  sub_10003C0EC();
  sub_10003C04C((void *)&_mh_execute_header, v0, v1, "Unable to format: Unable to read deferred reports plist, overwriting it: %@", v2, v3, v4, v5, v6);
}

void sub_10008E970()
{
  sub_10003C11C(__stack_chk_guard);
  sub_10003C0EC();
  sub_10003C04C((void *)&_mh_execute_header, v0, v1, "Unable to read deferred reports plist, overwriting it: %@", v2, v3, v4, v5, v6);
}

void sub_10008E9D8()
{
  sub_10004670C();
  sub_1000466D8((void *)&_mh_execute_header, v0, v1, "Unable to format: No existing deferred reports, creating new plist", v2, v3, v4, v5, v6);
}

void sub_10008EA0C()
{
  sub_10004670C();
  sub_100046758((void *)&_mh_execute_header, v0, v1, "No existing deferred reports, creating new plist", v2, v3, v4, v5, v6);
}

void sub_10008EA40()
{
  sub_10004670C();
  sub_1000466D8((void *)&_mh_execute_header, v0, v1, "Unable to format: Deferred tasks expired", v2, v3, v4, v5, v6);
}

void sub_10008EA74()
{
  sub_10004670C();
  sub_100046758((void *)&_mh_execute_header, v0, v1, "Deferred tasks expired", v2, v3, v4, v5, v6);
}

void sub_10008EAA8()
{
  sub_10003C11C(__stack_chk_guard);
  sub_10003C0EC();
  sub_10003C04C((void *)&_mh_execute_header, v0, v1, "Unable to format: Unable to read deferred reports plist: %@", v2, v3, v4, v5, v6);
}

void sub_10008EB10()
{
  sub_10003C11C(__stack_chk_guard);
  sub_10003C0EC();
  _os_log_error_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_ERROR, "Unable to read deferred reports plist: %@", v1, 0xCu);
}

void sub_10008EB84()
{
  sub_1000525B0();
  [v0 count];
  sub_10005257C();
  sub_10004BB0C((void *)&_mh_execute_header, v1, v2, "Unable to format: Unable to write %lu remaining deferred reports to plist: %@", v3, v4, v5, v6, v7);
}

void sub_10008EC00()
{
  sub_1000525B0();
  [v0 count];
  sub_10005257C();
  sub_10004BB0C((void *)&_mh_execute_header, v1, v2, "Unable to write %lu remaining deferred reports to plist: %@", v3, v4, v5, v6, v7);
}

void sub_10008EC7C()
{
  sub_1000525B0();
  [v0 count];
  sub_10003C0EC();
  sub_10004BB0C((void *)&_mh_execute_header, v1, v2, "Unable to format: Task expired with %lu remaining deferred reports (generated %lu)", v3, v4, v5, v6, v7);
}

void sub_10008ED04(void *a1)
{
  [a1 count];
  sub_10004B040((void *)&_mh_execute_header, v1, v2, "Unable to format: Generated %lu deferred reports", v3, v4, v5, v6, 0);
}

void sub_10008ED80(unsigned char *a1, unsigned char *a2)
{
  sub_100052554(a1, a2);
  sub_100052564((void *)&_mh_execute_header, v2, (uint64_t)v2, "Unable to format: Bad deferred report type value type", v3);
}

void sub_10008EDB0(unsigned char *a1, unsigned char *a2)
{
  sub_100052554(a1, a2);
  sub_100052594((void *)&_mh_execute_header, v2, v3, "Bad deferred report type value type", v4);
}

void sub_10008EDDC(uint64_t a1, void *a2)
{
  id v5 = sub_1000525BC(a1, a2);
  *(_DWORD *)uint64_t v4 = 134217984;
  void *v3 = v5;
  _os_log_fault_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_FAULT, "Unable to format: Unhandled deferred report type %llu", v4, 0xCu);
}

void sub_10008EE38(uint64_t a1, void *a2)
{
  id v5 = sub_1000525BC(a1, a2);
  *(_DWORD *)uint64_t v4 = 134217984;
  void *v3 = v5;
  _os_log_error_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_ERROR, "Unhandled deferred report type %llu", v4, 0xCu);
}

void sub_10008EE94(unsigned char *a1, unsigned char *a2)
{
  sub_100052554(a1, a2);
  sub_100052564((void *)&_mh_execute_header, v2, (uint64_t)v2, "Unable to format: deferred cpu resource: no pid provided", v3);
}

void sub_10008EEC4(unsigned char *a1, unsigned char *a2)
{
  sub_100052554(a1, a2);
  sub_100052594((void *)&_mh_execute_header, v2, v3, "deferred cpu resource: no pid provided", v4);
}

void sub_10008EEF0(unsigned char *a1, unsigned char *a2)
{
  sub_100052554(a1, a2);
  sub_100052564((void *)&_mh_execute_header, v2, (uint64_t)v2, "Unable to format: deferred cpu resource: generating deferred report", v3);
}

void sub_10008EF20(unsigned char *a1, unsigned char *a2)
{
  sub_100052554(a1, a2);
  sub_100052564((void *)&_mh_execute_header, v2, (uint64_t)v2, "Unable to format: deferred cpu resource: no endtime provided", v3);
}

void sub_10008EF50(unsigned char *a1, unsigned char *a2)
{
  sub_100052554(a1, a2);
  sub_100052594((void *)&_mh_execute_header, v2, v3, "deferred cpu resource: no endtime provided", v4);
}

void sub_10008EF7C(unsigned char *a1, unsigned char *a2)
{
  sub_100052554(a1, a2);
  sub_100052564((void *)&_mh_execute_header, v2, (uint64_t)v2, "Unable to format: deferred disk writes resource: no pid provided", v3);
}

void sub_10008EFAC(unsigned char *a1, unsigned char *a2)
{
  sub_100052554(a1, a2);
  sub_100052594((void *)&_mh_execute_header, v2, v3, "deferred disk writes resource: no pid provided", v4);
}

void sub_10008EFD8(unsigned char *a1, unsigned char *a2)
{
  sub_100052554(a1, a2);
  sub_100052564((void *)&_mh_execute_header, v2, (uint64_t)v2, "Unable to format: deferred disk writes resource: generating deferred report", v3);
}

void sub_10008F008(unsigned char *a1, unsigned char *a2)
{
  sub_100052554(a1, a2);
  sub_100052564((void *)&_mh_execute_header, v2, (uint64_t)v2, "Unable to format: deferred disk writes resource: no endtime provided", v3);
}

void sub_10008F038(unsigned char *a1, unsigned char *a2)
{
  sub_100052554(a1, a2);
  sub_100052594((void *)&_mh_execute_header, v2, v3, "deferred disk writes resource: no endtime provided", v4);
}

void sub_10008F064()
{
  sub_10004670C();
  sub_1000466D8((void *)&_mh_execute_header, v0, v1, "Unable to format: Invalid deferred reports plist", v2, v3, v4, v5, v6);
}

void sub_10008F098()
{
  sub_10004670C();
  _os_log_error_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_ERROR, "Invalid deferred reports plist", v1, 2u);
}

void sub_10008F0D8()
{
  sub_10004670C();
  sub_1000466D8((void *)&_mh_execute_header, v0, v1, "Unable to format: No deferred reports", v2, v3, v4, v5, v6);
}

void sub_10008F10C()
{
  sub_10004670C();
  sub_1000466D8((void *)&_mh_execute_header, v0, v1, "Unable to format: Generating deferred reports", v2, v3, v4, v5, v6);
}

void sub_10008F140()
{
  sub_100046668();
  sub_100055FD8(v0);
  sub_100055F94();
  sub_100046614((void *)&_mh_execute_header, v1, v2, "Unable to format: %s [%d]: Unable to gather ddt for resource exhaustion report, though process is alive", v3, v4, v5, v6, v7);
}

void sub_10008F1B8()
{
  sub_100046668();
  sub_100055FD8(v0);
  sub_100055F94();
  sub_100046A30((void *)&_mh_execute_header, v1, v2, "%{public}s [%d]: Unable to gather ddt for resource exhaustion report, though process is alive", v3, v4, v5, v6, v7);
}

void sub_10008F230()
{
  sub_10004670C();
  sub_1000466D8((void *)&_mh_execute_header, v0, v1, "Unable to format: Unable to gather ddt for resource exhaustion report, though process is alive", v2, v3, v4, v5, v6);
}

void sub_10008F264()
{
  sub_10004670C();
  sub_10004B018((void *)&_mh_execute_header, v0, v1, "Unable to gather ddt for resource exhaustion report, though process is alive", v2, v3, v4, v5, v6);
}

void sub_10008F298()
{
  sub_100046668();
  sub_100055FD8(v0);
  sub_100055F94();
  sub_100046614((void *)&_mh_execute_header, v1, v2, "Unable to format: %s [%d]: Unable to gather ddt for resource exhaustion report; process is no longer around",
    v3,
    v4,
    v5,
    v6,
    v7);
}

void sub_10008F310()
{
  sub_100046668();
  sub_100055FD8(v0);
  sub_100055F94();
  sub_100046A30((void *)&_mh_execute_header, v1, v2, "%{public}s [%d]: Unable to gather ddt for resource exhaustion report; process is no longer around",
    v3,
    v4,
    v5,
    v6,
    v7);
}

void sub_10008F388()
{
  sub_10004670C();
  sub_1000466D8((void *)&_mh_execute_header, v0, v1, "Unable to format: Unable to gather ddt for resource exhaustion report; process is no longer around",
    v2,
    v3,
    v4,
    v5,
    v6);
}

void sub_10008F3BC()
{
  sub_10004670C();
  sub_10004B018((void *)&_mh_execute_header, v0, v1, "Unable to gather ddt for resource exhaustion report; process is no longer around",
    v2,
    v3,
    v4,
    v5,
    v6);
}

void sub_10008F3F0()
{
  sub_100046668();
  sub_100055FF0(v0);
  sub_10005603C();
  uint64_t v1 = __error();
  strerror(*v1);
  sub_1000468C4();
  sub_10004BAEC((void *)&_mh_execute_header, v2, v3, "Unable to format: %s [%d]: Unable to spawn ddt: %d (%s)", v4, v5, v6, v7, v8);
}

void sub_10008F480()
{
  sub_100046668();
  sub_100055FF0(v0);
  sub_10005603C();
  uint64_t v1 = __error();
  strerror(*v1);
  sub_1000468C4();
  sub_10004BA8C((void *)&_mh_execute_header, v2, v3, "%{public}s [%d]: Unable to spawn ddt: %d (%s)", v4, v5, v6, v7, v8);
}

void sub_10008F510()
{
  __error();
  os_log_t v0 = __error();
  strerror(*v0);
  sub_1000467CC();
  sub_100046614((void *)&_mh_execute_header, v1, v2, "Unable to format: Unable to spawn ddt: %d (%s)", v3, v4, v5, v6, v7);
}

void sub_10008F598()
{
  __error();
  os_log_t v0 = __error();
  strerror(*v0);
  sub_1000467CC();
  sub_100046A30((void *)&_mh_execute_header, v1, v2, "Unable to spawn ddt: %d (%s)", v3, v4, v5, v6, v7);
}

void sub_10008F620()
{
  sub_100046668();
  sub_100055FD8(v0);
  sub_100055F94();
  sub_100046614((void *)&_mh_execute_header, v1, v2, "Unable to format: %s [%d]: Unable to gather lsof for resource exhaustion report, though process is alive", v3, v4, v5, v6, v7);
}

void sub_10008F698()
{
  sub_100046668();
  sub_100055FD8(v0);
  sub_100055F94();
  sub_100046A30((void *)&_mh_execute_header, v1, v2, "%{public}s [%d]: Unable to gather lsof for resource exhaustion report, though process is alive", v3, v4, v5, v6, v7);
}

void sub_10008F710()
{
  sub_10004670C();
  sub_1000466D8((void *)&_mh_execute_header, v0, v1, "Unable to format: Unable to gather lsof for resource exhaustion report, though process is alive", v2, v3, v4, v5, v6);
}

void sub_10008F744()
{
  sub_10004670C();
  sub_10004B018((void *)&_mh_execute_header, v0, v1, "Unable to gather lsof for resource exhaustion report, though process is alive", v2, v3, v4, v5, v6);
}

void sub_10008F778()
{
  sub_100046668();
  sub_100055FD8(v0);
  sub_100055F94();
  sub_100046614((void *)&_mh_execute_header, v1, v2, "Unable to format: %s [%d]: Unable to gather lsof for resource exhaustion report; process is no longer around",
    v3,
    v4,
    v5,
    v6,
    v7);
}

void sub_10008F7F0()
{
  sub_100046668();
  sub_100055FD8(v0);
  sub_100055F94();
  sub_100046A30((void *)&_mh_execute_header, v1, v2, "%{public}s [%d]: Unable to gather lsof for resource exhaustion report; process is no longer around",
    v3,
    v4,
    v5,
    v6,
    v7);
}

void sub_10008F868()
{
  sub_10004670C();
  sub_1000466D8((void *)&_mh_execute_header, v0, v1, "Unable to format: Unable to gather lsof for resource exhaustion report; process is no longer around",
    v2,
    v3,
    v4,
    v5,
    v6);
}

void sub_10008F89C()
{
  sub_10004670C();
  sub_10004B018((void *)&_mh_execute_header, v0, v1, "Unable to gather lsof for resource exhaustion report; process is no longer around",
    v2,
    v3,
    v4,
    v5,
    v6);
}

void sub_10008F8D0()
{
  sub_100046668();
  sub_100055FF0(v0);
  sub_10005603C();
  uint64_t v1 = __error();
  strerror(*v1);
  sub_1000468C4();
  sub_10004BAEC((void *)&_mh_execute_header, v2, v3, "Unable to format: %s [%d]: Unable to spawn lsof: %d (%s)", v4, v5, v6, v7, v8);
}

void sub_10008F960()
{
  sub_100046668();
  sub_100055FF0(v0);
  sub_10005603C();
  uint64_t v1 = __error();
  strerror(*v1);
  sub_1000468C4();
  sub_10004BA8C((void *)&_mh_execute_header, v2, v3, "%{public}s [%d]: Unable to spawn lsof: %d (%s)", v4, v5, v6, v7, v8);
}

void sub_10008F9F0()
{
  __error();
  os_log_t v0 = __error();
  strerror(*v0);
  sub_1000467CC();
  sub_100046614((void *)&_mh_execute_header, v1, v2, "Unable to format: Unable to spawn lsof: %d (%s)", v3, v4, v5, v6, v7);
}

void sub_10008FA78()
{
  __error();
  os_log_t v0 = __error();
  strerror(*v0);
  sub_1000467CC();
  sub_100046A30((void *)&_mh_execute_header, v1, v2, "Unable to spawn lsof: %d (%s)", v3, v4, v5, v6, v7);
}

void sub_10008FB00(int a1)
{
  sub_10002E4E8(a1);
  sub_100046564();
  sub_100046614((void *)&_mh_execute_header, v1, v2, "Unable to format: %s [%d]: file descriptor exhaustion: deallocating fatal port, allowing process to exit due to fatal resource exhaustion", v3, v4, v5, v6, v7);
}

void sub_10008FB7C()
{
  sub_10004670C();
  sub_1000466D8((void *)&_mh_execute_header, v0, v1, "Unable to format: file descriptor exhaustion: deallocating fatal port, allowing process to exit due to fatal resource exhaustion", v2, v3, v4, v5, v6);
}

void sub_10008FBB0(int a1)
{
  sub_10002E4E8(a1);
  sub_100046564();
  sub_100046614((void *)&_mh_execute_header, v1, v2, "Unable to format: %s [%d]: port exhaustion: deallocating fatal port, allowing process to exit due to fatal resource exhaustion", v3, v4, v5, v6, v7);
}

void sub_10008FC2C()
{
  sub_10004670C();
  sub_1000466D8((void *)&_mh_execute_header, v0, v1, "Unable to format: port exhaustion: deallocating fatal port, allowing process to exit due to fatal resource exhaustion", v2, v3, v4, v5, v6);
}

void sub_10008FC60(int a1)
{
  sub_10002E4E8(a1);
  sub_100046564();
  sub_100046614((void *)&_mh_execute_header, v1, v2, "Unable to format: %s [%d]: kqworkloop exhaustion: deallocating fatal port, allowing process to exit due to fatal resource exhaustion", v3, v4, v5, v6, v7);
}

void sub_10008FCDC()
{
  sub_10004670C();
  sub_1000466D8((void *)&_mh_execute_header, v0, v1, "Unable to format: kqworkloop exhaustion: deallocating fatal port, allowing process to exit due to fatal resource exhaustion", v2, v3, v4, v5, v6);
}

void sub_10008FD10()
{
  sub_1000465C0();
  sub_100046958(v0);
  sub_100056024();
  uint64_t v1 = __error();
  strerror(*v1);
  sub_10004B93C();
  sub_100046A50((void *)&_mh_execute_header, v2, v3, "Unable to format: %s [%d]: could not open log file %@: %d (%s)", v4, v5, v6, v7, v8);
}

void sub_10008FDA8()
{
  sub_1000465C0();
  sub_100046958(v0);
  sub_100056024();
  uint64_t v1 = __error();
  strerror(*v1);
  sub_10004B93C();
  sub_1000469F0((void *)&_mh_execute_header, v2, v3, "%{public}s [%d]: could not open log file %@: %d (%s)", v4, v5, v6, v7, v8);
}

void sub_10008FE40()
{
  sub_100046668();
  __error();
  os_log_t v0 = __error();
  strerror(*v0);
  sub_1000466B4();
  sub_1000465A0((void *)&_mh_execute_header, v1, v2, "Unable to format: could not open log file %@: %d (%s)", v3, v4, v5, v6, v7);
}

void sub_10008FED0()
{
  sub_100046668();
  __error();
  os_log_t v0 = __error();
  strerror(*v0);
  sub_1000466B4();
  sub_100046874((void *)&_mh_execute_header, v1, v2, "could not open log file %@: %d (%s)", v3, v4, v5, v6, v7);
}

void sub_10008FF60()
{
  sub_1000465C0();
  sub_100046958(v0);
  sub_100056024();
  uint64_t v1 = __error();
  strerror(*v1);
  sub_10004B93C();
  sub_100046A50((void *)&_mh_execute_header, v2, v3, "Unable to format: %s [%d]: could not fdopen log file %@: %d (%s)", v4, v5, v6, v7, v8);
}

void sub_10008FFF8()
{
  sub_1000465C0();
  sub_100046958(v0);
  sub_100056024();
  uint64_t v1 = __error();
  strerror(*v1);
  sub_10004B93C();
  sub_1000469F0((void *)&_mh_execute_header, v2, v3, "%{public}s [%d]: could not fdopen log file %@: %d (%s)", v4, v5, v6, v7, v8);
}

void sub_100090090()
{
  sub_100046668();
  __error();
  os_log_t v0 = __error();
  strerror(*v0);
  sub_1000466B4();
  sub_1000465A0((void *)&_mh_execute_header, v1, v2, "Unable to format: could not fdopen log file %@: %d (%s)", v3, v4, v5, v6, v7);
}

void sub_100090120()
{
  sub_100046668();
  __error();
  os_log_t v0 = __error();
  strerror(*v0);
  sub_1000466B4();
  sub_100046874((void *)&_mh_execute_header, v1, v2, "could not fdopen log file %@: %d (%s)", v3, v4, v5, v6, v7);
}

void sub_1000901B0()
{
  sub_1000465C0();
  sub_100055FF0(v0);
  int v1 = sub_100056008();
  strerror(v1);
  sub_100055FAC();
  sub_10004BAEC((void *)&_mh_execute_header, v2, v3, "Unable to format: %s [%d]: Unable to write ddt/lsof output to buffer: %d (%s)", v4, v5, v6, v7, v8);
}

void sub_100090238()
{
  sub_1000465C0();
  sub_100055FF0(v0);
  int v1 = sub_100056008();
  strerror(v1);
  sub_100055FAC();
  sub_10004BA8C((void *)&_mh_execute_header, v2, v3, "%{public}s [%d]: Unable to write ddt/lsof output to buffer: %d (%s)", v4, v5, v6, v7, v8);
}

void sub_1000902C0(FILE *a1)
{
  int v1 = ferror(a1);
  strerror(v1);
  sub_1000467CC();
  sub_100046614((void *)&_mh_execute_header, v2, v3, "Unable to format: Unable to write ddt/lsof output to buffer: %d (%s)", v4, v5, v6, v7, v8);
}

void sub_100090340(FILE *a1)
{
  int v1 = ferror(a1);
  strerror(v1);
  sub_1000467CC();
  sub_100046A30((void *)&_mh_execute_header, v2, v3, "Unable to write ddt/lsof output to buffer: %d (%s)", v4, v5, v6, v7, v8);
}

void sub_1000903C0()
{
  sub_100046668();
  sub_100055FD8(v0);
  sub_100055F94();
  sub_100046614((void *)&_mh_execute_header, v1, v2, "Unable to format: %s [%d]: Unable to convert ddt/lsof output to buffer", v3, v4, v5, v6, v7);
}

void sub_100090438()
{
  sub_100046668();
  sub_100055FD8(v0);
  sub_100055F94();
  sub_100046A30((void *)&_mh_execute_header, v1, v2, "%{public}s [%d]: Unable to convert ddt/lsof output to buffer", v3, v4, v5, v6, v7);
}

void sub_1000904B0()
{
  sub_10004670C();
  sub_1000466D8((void *)&_mh_execute_header, v0, v1, "Unable to format: Unable to convert ddt/lsof output to buffer", v2, v3, v4, v5, v6);
}

void sub_1000904E4()
{
  sub_10004670C();
  sub_10004B018((void *)&_mh_execute_header, v0, v1, "Unable to convert ddt/lsof output to buffer", v2, v3, v4, v5, v6);
}

void sub_100090518()
{
  __error();
  os_log_t v0 = __error();
  strerror(*v0);
  sub_1000467CC();
  sub_100046614((void *)&_mh_execute_header, v1, v2, "Unable to format: Unable to opendir /private/var/db/spindump: %d (%s)", v3, v4, v5, v6, v7);
}

void sub_1000905A0()
{
  __error();
  os_log_t v0 = __error();
  strerror(*v0);
  sub_1000467CC();
  sub_100046A30((void *)&_mh_execute_header, v1, v2, "Unable to opendir /private/var/db/spindump: %d (%s)", v3, v4, v5, v6, v7);
}

void sub_100090628(os_log_t log)
{
  *(_WORD *)uint64_t v1 = 0;
  _os_log_fault_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_FAULT, "Unable to format: Marked file purgeable", v1, 2u);
}

void sub_10009066C(os_log_t log)
{
  *(_WORD *)uint64_t v1 = 0;
  _os_log_debug_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_DEBUG, "Marked file purgeable", v1, 2u);
}

void sub_1000906B0(int a1)
{
  strerror(a1);
  sub_1000467CC();
  sub_100046614((void *)&_mh_execute_header, v1, v2, "Unable to format: Failed to mark file purgeable: %d (%s)", v3, v4, v5, v6, v7);
}

void sub_10009072C(int a1)
{
  strerror(a1);
  sub_1000467CC();
  sub_100046A30((void *)&_mh_execute_header, v1, v2, "Failed to mark file purgeable: %d (%s)", v3, v4, v5, v6, v7);
}

void sub_1000907A8()
{
  sub_100046940();
  sub_100046694((void *)&_mh_execute_header, v0, v1, "Unable to format: Unable to parse time string %s, try using format '%%Y-%%m-%%dT%%T%%z', e.g. %s", v2, v3);
}

void sub_100090810()
{
  sub_100046940();
  _os_log_error_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_ERROR, "Unable to parse time string %s, try using format '%%Y-%%m-%%dT%%T%%z', e.g. %s", v1, 0x16u);
}

void sub_100090888()
{
  sub_10004670C();
  sub_1000466D8((void *)&_mh_execute_header, v0, v1, "Unable to format: Unable to create date formatter", v2, v3, v4, v5, v6);
}

void sub_1000908BC()
{
  sub_10004670C();
  _os_log_error_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_ERROR, "Unable to create date formatter", v1, 2u);
}

void sub_1000908FC(uint64_t a1, NSObject *a2, double a3)
{
  int v3 = 134218240;
  uint64_t v4 = a1;
  __int16 v5 = 2048;
  double v6 = a3;
  _os_log_fault_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_FAULT, "Unable to format: Found ISO timestamp %ld with subseconds %f", (uint8_t *)&v3, 0x16u);
}

void sub_100090980(uint64_t a1, NSObject *a2, long double a3)
{
  int v4 = 134218240;
  uint64_t v5 = a1;
  __int16 v6 = 2048;
  long double v7 = fmod(a3, 1.0);
  _os_log_debug_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_DEBUG, "Found ISO timestamp %ld with subseconds %f", (uint8_t *)&v4, 0x16u);
}

void sub_100090A20()
{
  sub_10003C0BC();
  sub_10003C04C((void *)&_mh_execute_header, v0, v1, "Unable to format: Found ISO timestamp %ld", v2, v3, v4, v5, v6);
}

void sub_100090A88()
{
  sub_10003C0BC();
  sub_10004690C((void *)&_mh_execute_header, v0, v1, "Found ISO timestamp %ld", v2, v3, v4, v5, v6);
}

void sub_100090AF0()
{
  v1[0] = 136315650;
  sub_10005F028();
  _os_log_fault_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_FAULT, "Unable to format: %s: endOfSecs %p endPtr %p", (uint8_t *)v1, 0x20u);
}

void sub_100090B78()
{
  v1[0] = 136315650;
  sub_10005F028();
  _os_log_error_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_ERROR, "%s: endOfSecs %p endPtr %p", (uint8_t *)v1, 0x20u);
}

void sub_100090C00()
{
  sub_10003C0BC();
  sub_10003C04C((void *)&_mh_execute_header, v0, v1, "Unable to format: Found ISO timestamp with time zone name %ld", v2, v3, v4, v5, v6);
}

void sub_100090C68()
{
  sub_10003C0BC();
  sub_10004690C((void *)&_mh_execute_header, v0, v1, "Found ISO timestamp with time zone name %ld", v2, v3, v4, v5, v6);
}

void sub_100090CD0()
{
  sub_10003C0BC();
  sub_10003C04C((void *)&_mh_execute_header, v0, v1, "Unable to format: Found ISO timestamp with time zone number %ld", v2, v3, v4, v5, v6);
}

void sub_100090D38()
{
  sub_10003C0BC();
  sub_10004690C((void *)&_mh_execute_header, v0, v1, "Found ISO timestamp with time zone number %ld", v2, v3, v4, v5, v6);
}

void sub_100090DA0()
{
  sub_10003C0BC();
  sub_10003C04C((void *)&_mh_execute_header, v0, v1, "Unable to format: Found unix timestamp %ld", v2, v3, v4, v5, v6);
}

void sub_100090E08()
{
  sub_10003C0BC();
  sub_10004690C((void *)&_mh_execute_header, v0, v1, "Found unix timestamp %ld", v2, v3, v4, v5, v6);
}

void sub_100090E70(void *a1, NSObject *a2)
{
  uint64_t v3 = [(char *)[a1 total] bytes];
  uint64_t v4 = &v3[(void)[[[a1 total] bytes_duplicate]];
  id v5 = [objc_msgSend(a1, "total") bytes_out_of_order];
  uint8_t v6 = &v4[(unint64_t)[a1 total] + (void)v5];
  int v9 = (char *)[a1 bytes_not_microstackshots] + v6;
  id v11 = [a1 bytes_not_microstackshots];
  id v13 = [a1 num_microstackshots_filtered_out];
  id v15 = [[[a1 total] count];
  id v17 = [objc_msgSend(a1, "total") bytes];
  id v19 = [objc_msgSend(a1, "total") num_load_infos];
  id v21 = [objc_msgSend(a1, "total") num_frames];
  id v23 = [objc_msgSend(a1, "total") num_duplicate];
  id v25 = [[objc_msgSend(a1, "total") bytes_duplicate];
  id v27 = [objc_msgSend(a1, "total") num_out_of_order];
  id v29 = [objc_msgSend(a1, "total") bytes_out_of_order];
  id v31 = [objc_msgSend(a1, "total") num_missing_load_info];
  id v33 = [objc_msgSend(a1, "total") bytes_missing_load_info];
  id v35 = [objc_msgSend(a1, "interrupt") count];
  id v37 = [objc_msgSend(a1, "interrupt") bytes];
  id v39 = [objc_msgSend(a1, "interrupt") num_load_infos];
  id v41 = [objc_msgSend(a1, "interrupt") num_frames];
  id v43 = [objc_msgSend(a1, "interrupt") num_duplicate];
  id v45 = [objc_msgSend(a1, "interrupt") bytes_duplicate];
  id v47 = [objc_msgSend(a1, "interrupt") num_out_of_order];
  id v49 = [objc_msgSend(a1, "interrupt") bytes_out_of_order];
  id v51 = [[objc_msgSend(a1, "interrupt") num_missing_load_info];
  id v53 = [objc_msgSend(a1, "interrupt") bytes_missing_load_info];
  id v55 = [objc_msgSend(a1, "timer") count];
  id v57 = [objc_msgSend(a1, "timer") bytes];
  id v59 = [objc_msgSend(a1, "timer") num_load_infos];
  id v61 = [objc_msgSend(a1, "timer") num_frames];
  id v63 = [objc_msgSend(a1, "timer") num_duplicate];
  id v65 = [objc_msgSend(a1, "timer") bytes_duplicate];
  id v67 = [objc_msgSend(a1, "timer") num_out_of_order];
  id v69 = [objc_msgSend(a1, "timer") bytes_out_of_order];
  id v71 = [[objc_msgSend(a1, "timer") num_missing_load_info];
  id v73 = [objc_msgSend(a1, "timer") bytes_missing_load_info];
  id v75 = [objc_msgSend(a1, "io") count];
  id v77 = [objc_msgSend(a1, "io") bytes];
  id v79 = [objc_msgSend(a1, "io") num_load_infos];
  id v81 = [objc_msgSend(a1, "io") num_frames];
  id v83 = [objc_msgSend(a1, "io") num_duplicate];
  id v85 = [objc_msgSend(a1, "io") bytes_duplicate];
  id v87 = [[objc_msgSend(a1, "io") num_out_of_order];
  id v89 = [objc_msgSend(a1, "io") bytes_out_of_order];
  id v91 = [objc_msgSend(a1, "io") num_missing_load_info];
  id v93 = [objc_msgSend(a1, "io") bytes_missing_load_info];
  id v95 = [[objc_msgSend(a1, "pmi") count];
  *(_DWORD *)buf = 134236416;
  id v97 = [[objc_msgSend(a1, "pmi") bytes];
  __int16 v10 = 2048;
  __int16 v12 = 2048;
  __int16 v14 = 2048;
  __int16 v16 = 2048;
  __int16 v18 = 2048;
  __int16 v20 = 2048;
  __int16 v22 = 2048;
  __int16 v24 = 2048;
  __int16 v26 = 2048;
  __int16 v28 = 2048;
  __int16 v30 = 2048;
  __int16 v32 = 2048;
  __int16 v34 = 2048;
  __int16 v36 = 2048;
  __int16 v38 = 2048;
  __int16 v40 = 2048;
  __int16 v42 = 2048;
  __int16 v44 = 2048;
  __int16 v46 = 2048;
  __int16 v48 = 2048;
  __int16 v50 = 2048;
  __int16 v52 = 2048;
  __int16 v54 = 2048;
  __int16 v56 = 2048;
  __int16 v58 = 2048;
  __int16 v60 = 2048;
  __int16 v62 = 2048;
  __int16 v64 = 2048;
  __int16 v66 = 2048;
  __int16 v68 = 2048;
  __int16 v70 = 2048;
  __int16 v72 = 2048;
  __int16 v74 = 2048;
  __int16 v76 = 2048;
  __int16 v78 = 2048;
  __int16 v80 = 2048;
  __int16 v82 = 2048;
  __int16 v84 = 2048;
  __int16 v86 = 2048;
  __int16 v88 = 2048;
  __int16 v90 = 2048;
  __int16 v92 = 2048;
  __int16 v94 = 2048;
  __int16 v96 = 2048;
  __int16 v98 = 2048;
  id v99 = [objc_msgSend(a1, "pmi") num_load_infos];
  __int16 v100 = 2048;
  id v101 = [objc_msgSend(a1, "pmi") num_frames];
  __int16 v102 = 2048;
  id v103 = [[objc_msgSend(a1, "pmi") num_duplicate];
  __int16 v104 = 2048;
  id v105 = [[[a1 pmi] bytes_duplicate];
  __int16 v106 = 2048;
  id v107 = [objc_msgSend(a1, "pmi") num_out_of_order];
  __int16 v108 = 2048;
  id v109 = [[objc_msgSend(a1, "pmi") bytes_out_of_order];
  __int16 v110 = 2048;
  id v111 = [objc_msgSend(a1, "pmi") num_missing_load_info];
  __int16 v112 = 2048;
  id v113 = [[objc_msgSend(a1, "pmi") bytes_missing_load_info];
  __int16 v114 = 2048;
  id v115 = [objc_msgSend(a1, "macf") count];
  __int16 v116 = 2048;
  id v117 = [objc_msgSend(a1, "macf") bytes];
  __int16 v118 = 2048;
  id v119 = [[objc_msgSend(a1, "macf") num_load_infos];
  __int16 v120 = 2048;
  id v121 = [objc_msgSend(a1, "macf") num_frames];
  __int16 v122 = 2048;
  id v123 = [objc_msgSend(a1, "macf") num_duplicate];
  __int16 v124 = 2048;
  id v125 = [[objc_msgSend(a1, "macf") bytes_duplicate];
  __int16 v126 = 2048;
  id v127 = [objc_msgSend(a1, "macf") num_out_of_order];
  __int16 v128 = 2048;
  id v129 = [objc_msgSend(a1, "macf") bytes_out_of_order];
  __int16 v130 = 2048;
  id v131 = [objc_msgSend(a1, "macf") num_missing_load_info];
  __int16 v132 = 2048;
  id v133 = [objc_msgSend(a1, "macf") bytes_missing_load_info];
  __int16 v134 = 2048;
  id v135 = [objc_msgSend(a1, "unknown_type") count];
  __int16 v136 = 2048;
  id v137 = [objc_msgSend(a1, "unknown_type") bytes];
  __int16 v138 = 2048;
  id v139 = [objc_msgSend(a1, "unknown_type") num_load_infos];
  __int16 v140 = 2048;
  id v141 = [objc_msgSend(a1, "unknown_type") num_frames];
  __int16 v142 = 2048;
  id v143 = [objc_msgSend(a1, "unknown_type") num_duplicate];
  __int16 v144 = 2048;
  id v145 = [objc_msgSend(a1, "unknown_type") bytes_duplicate];
  __int16 v146 = 2048;
  id v147 = [objc_msgSend(a1, "unknown_type") num_out_of_order];
  __int16 v148 = 2048;
  id v149 = [objc_msgSend(objc_msgSend(a1, "unknown_type"), "bytes_out_of_order")];
  __int16 v150 = 2048;
  id v151 = [objc_msgSend(a1, "unknown_type") num_missing_load_info];
  __int16 v152 = 2048;
  id v153 = [objc_msgSend(a1, "unknown_type") bytes_missing_load_info];
  _os_log_fault_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_FAULT, "Unable to format: Microstackshot statistics:\n%llu bytes parsed (%llu bytes invalid)\n%llu filtered out\n\ntotal     count          %llu (%llu bytes)\n          num_load_infos %llu\n          num_frames     %llu\n          duplicate      %llu (%llu bytes)\n          out_of_order   %llu (%llu bytes)\n          no_load_info   %llu (%llu bytes)\n\ninterrupt count          %llu (%llu bytes)\n          num_load_infos %llu\n          num_frames     %llu\n          duplicate      %llu (%llu bytes)\n          out_of_order   %llu (%llu bytes)\n"
    "          no_load_info   %llu (%llu bytes)\n"
    "\n"
    "timer     count          %llu (%llu bytes)\n"
    "          num_load_infos %llu\n"
    "          num_frames     %llu\n"
    "          duplicate      %llu (%llu bytes)\n"
    "          out_of_order   %llu (%llu bytes)\n"
    "          no_load_info   %llu (%llu bytes)\n"
    "\n"
    "io        count          %llu (%llu bytes)\n"
    "          num_load_infos %llu\n"
    "          num_frames     %llu\n"
    "          duplicate      %llu (%llu bytes)\n"
    "          out_of_order   %llu (%llu bytes)\n"
    "          no_load_info   %llu (%llu bytes)\n"
    "\n"
    "pmi       count          %llu (%llu bytes)\n"
    "          num_load_infos %llu\n"
    "          num_frames     %llu\n"
    "          duplicate      %llu (%llu bytes)\n"
    "          out_of_order   %llu (%llu bytes)\n"
    "          no_load_info   %llu (%llu bytes)\n"
    "\n"
    "macf      count          %llu (%llu bytes)\n"
    "          num_load_infos %llu\n"
    "          num_frames     %llu\n"
    "          duplicate      %llu (%llu bytes)\n"
    "          out_of_order   %llu (%llu bytes)\n"
    "          no_load_info   %llu (%llu bytes)\n"
    "\n"
    "unknown   count          %llu (%llu bytes)\n"
    "          num_load_infos %llu\n"
    "          num_frames     %llu\n"
    "          duplicate      %llu (%llu bytes)\n"
    "          out_of_order   %llu (%llu bytes)\n"
    "          no_load_info   %llu (%llu bytes)",
    buf,
    0x2DCu);
}

void sub_100091770(void *a1)
{
  [a1 bytes_not_microstackshots];
  sub_10003C0BC();
  sub_10004B040((void *)&_mh_execute_header, v1, v2, "Unable to format: %llu bytes of microstackshot data was invalid (ignored)", v3, v4, v5, v6, v7);
}

void sub_1000917E8(void *a1)
{
  [a1 bytes_not_microstackshots];
  sub_10003C0BC();
  sub_10005F008((void *)&_mh_execute_header, v1, v2, "%llu bytes of microstackshot data was invalid (ignored)", v3, v4, v5, v6, v7);
}

void sub_100091860(void *a1)
{
  [objc_msgSend(a1, "total") num_out_of_order];
  sub_10003C0BC();
  sub_10004B040((void *)&_mh_execute_header, v1, v2, "Unable to format: %llu microstackshots dropped due to being out of order", v3, v4, v5, v6, v7);
}

void sub_1000918DC(void *a1)
{
  [objc_msgSend(a1, "total") num_out_of_order];
  sub_10003C0BC();
  sub_10005F008((void *)&_mh_execute_header, v1, v2, "%llu microstackshots dropped due to being out of order", v3, v4, v5, v6, v7);
}

void sub_100091958(void *a1)
{
  [objc_msgSend(a1, "total") num_missing_load_info];
  sub_10003C0BC();
  sub_10004B040((void *)&_mh_execute_header, v1, v2, "Unable to format: %llu microstackshots dropped due to missing load infos", v3, v4, v5, v6, v7);
}

void sub_1000919D4(void *a1)
{
  [objc_msgSend(a1, "total") num_missing_load_info];
  sub_10003C0BC();
  sub_10005F008((void *)&_mh_execute_header, v1, v2, "%llu microstackshots dropped due to missing load infos", v3, v4, v5, v6, v7);
}

void sub_100091A50()
{
  __error();
  os_log_t v0 = __error();
  strerror(*v0);
  sub_1000467CC();
  sub_100046614((void *)&_mh_execute_header, v1, v2, "Unable to format: Unable to get pid list: %d (%s)", v3, v4, v5, v6, v7);
}

void sub_100091AD8()
{
  __error();
  os_log_t v0 = __error();
  strerror(*v0);
  sub_1000467CC();
  sub_100046A30((void *)&_mh_execute_header, v1, v2, "Unable to get pid list: %d (%s)", v3, v4, v5, v6, v7);
}

void sub_100091B60()
{
  sub_100046A90();
  sub_10005EFC4((void *)&_mh_execute_header, v0, v1, "Unable to format: Done running heap/ddt for all (%d) processes", v2);
}

void sub_100091BCC()
{
  sub_100046A90();
  sub_10005EFC4((void *)&_mh_execute_header, v0, v1, "Unable to format: Timed out running heap/ddt for all (%d) processes", v2);
}

void sub_100091C38()
{
  sub_100046A90();
  _os_log_error_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_ERROR, "Timed out running heap/ddt for all (%d) processes", v1, 8u);
}

void sub_100091CAC()
{
  sub_100046A90();
  sub_10005EFC4((void *)&_mh_execute_header, v0, v1, "Unable to format: Running heap/ddt for all (%d) processes", v2);
}

void sub_100091D18()
{
  sub_10005EF3C();
  sub_1000481A4();
  sub_10005EFA4((void *)&_mh_execute_header, v0, v1, "Unable to format: heap for [%d] completed", v2);
}

void sub_100091D80()
{
  sub_10005F054();
  sub_1000481A4();
  sub_10005EFEC((void *)&_mh_execute_header, v0, v1, "heap for [%d] completed", v2, v3, v4, v5, v6);
}

void sub_100091DE8()
{
  sub_1000465C0();
  sub_10005EF84(v0, v1);
  sub_10005EFDC();
  sub_10005EF1C();
  sub_100046A70((void *)&_mh_execute_header, v2, v3, "Unable to format: %s [%d]: No output from heap for %d", v4, v5, v6, v7, v8);
}

void sub_100091E68()
{
  sub_1000465C0();
  sub_10005EF84(v0, v1);
  sub_10005EFDC();
  sub_10005EF1C();
  sub_100046A10((void *)&_mh_execute_header, v2, v3, "%{public}s [%d]: No output from heap for %d", v4, v5, v6, v7, v8);
}

void sub_100091EE8()
{
  sub_10005EF3C();
  sub_1000481A4();
  sub_10005EFA4((void *)&_mh_execute_header, v0, v1, "Unable to format: No output from heap for %d", v2);
}

void sub_100091F50()
{
  sub_10005EF3C();
  sub_1000481A4();
  sub_10005F068((void *)&_mh_execute_header, v0, v1, "No output from heap for %d", v2);
}

void sub_100091FB8()
{
  sub_10005EF3C();
  sub_1000481A4();
  sub_10005EFA4((void *)&_mh_execute_header, v0, v1, "Unable to format: ddt for [%d] completed", v2);
}

void sub_100092020()
{
  sub_10005F054();
  sub_1000481A4();
  sub_10005EFEC((void *)&_mh_execute_header, v0, v1, "ddt for [%d] completed", v2, v3, v4, v5, v6);
}

void sub_100092088()
{
  sub_1000465C0();
  sub_10005EF84(v0, v1);
  sub_10005EFDC();
  sub_10005EF1C();
  sub_100046A70((void *)&_mh_execute_header, v2, v3, "Unable to format: %s [%d]: No output from ddt for %d", v4, v5, v6, v7, v8);
}

void sub_100092108()
{
  sub_1000465C0();
  sub_10005EF84(v0, v1);
  sub_10005EFDC();
  sub_10005EF1C();
  sub_100046A10((void *)&_mh_execute_header, v2, v3, "%{public}s [%d]: No output from ddt for %d", v4, v5, v6, v7, v8);
}

void sub_100092188()
{
  sub_10005EF3C();
  sub_1000481A4();
  sub_10005EFA4((void *)&_mh_execute_header, v0, v1, "Unable to format: No output from ddt for %d", v2);
}

void sub_1000921F0()
{
  sub_10005EF3C();
  sub_1000481A4();
  sub_10005F068((void *)&_mh_execute_header, v0, v1, "No output from ddt for %d", v2);
}

void sub_100092258(NSObject *a1)
{
  dispatch_source_get_handle(a1);
  sub_10003C0BC();
  sub_10004B040((void *)&_mh_execute_header, v1, v2, "Unable to format: Interrupted again by signal %ld, exiting", v3, v4, v5, v6, v7);
}

void sub_1000922D0(NSObject *a1)
{
  dispatch_source_get_handle(a1);
  sub_10003C0BC();
  sub_10004B040((void *)&_mh_execute_header, v1, v2, "Unable to format: Interrupted by signal %ld while saving report. Interrupt again after a second to exit early", v3, v4, v5, v6, v7);
}

void sub_100092348(NSObject *a1)
{
  dispatch_source_get_handle(a1);
  sub_10003C0BC();
  sub_10004B040((void *)&_mh_execute_header, v1, v2, "Unable to format: Interrupted by signal %ld", v3, v4, v5, v6, v7);
}

void sub_1000923C0(NSObject *a1)
{
  dispatch_source_get_handle(a1);
  sub_100046614((void *)&_mh_execute_header, v1, v2, "Unable to format: Interrupted by signal %ld, waiting %d seconds...", v3, v4, v5, v6, 0);
}

void sub_100092450(NSObject *a1)
{
  dispatch_source_get_handle(a1);
  sub_10005F044();
  _os_log_fault_impl(v1, v2, v3, v4, v5, 0x16u);
}

void sub_1000924F4()
{
  sub_10004670C();
  sub_1000466D8((void *)&_mh_execute_header, v0, v1, "Unable to format: spindump-stuck: Running under debugger, ignoring", v2, v3, v4, v5, v6);
}

void sub_100092528()
{
  sub_10004670C();
  _os_log_debug_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_DEBUG, "spindump-stuck: Running under debugger, ignoring", v1, 2u);
}

void sub_100092568()
{
  __error();
  os_log_t v0 = __error();
  strerror(*v0);
  sub_1000466B4();
  sub_1000465A0((void *)&_mh_execute_header, v1, v2, "Unable to format: spindump-stuck: Unable to open %s: %d (%s)", v3, v4, v5, v6, v7);
}

void sub_1000925FC()
{
  __error();
  os_log_t v0 = __error();
  strerror(*v0);
  sub_1000466B4();
  sub_100046874((void *)&_mh_execute_header, v1, v2, "spindump-stuck: Unable to open %s: %d (%s)", v3, v4, v5, v6, v7);
}

void sub_100092690()
{
  sub_10004670C();
  sub_1000466D8((void *)&_mh_execute_header, v0, v1, "Unable to format: spindump-stuck: Unable to take stackshot", v2, v3, v4, v5, v6);
}

void sub_1000926C4()
{
  sub_10004670C();
  _os_log_error_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_ERROR, "spindump-stuck: Unable to take stackshot", v1, 2u);
}

void sub_100092704()
{
  sub_10003C0BC();
  sub_10003C04C((void *)&_mh_execute_header, v0, v1, "Unable to format: spindump-stuck: Wrote stackshot to %s", v2, v3, v4, v5, v6);
}

void sub_10009276C(int a1, FILE *a2)
{
  int v2 = ferror(a2);
  strerror(v2);
  sub_1000466B4();
  sub_1000465A0((void *)&_mh_execute_header, v3, v4, "Unable to format: Unable to write stackshot to %s: %d (%s)", v5, v6, v7, v8, v9);
}

void sub_1000927FC(int a1, FILE *a2)
{
  int v2 = ferror(a2);
  strerror(v2);
  sub_1000466B4();
  sub_100046874((void *)&_mh_execute_header, v3, v4, "Unable to write stackshot to %s: %d (%s)", v5, v6, v7, v8, v9);
}

void sub_10009288C()
{
  sub_1000466F4();
  sub_100046694((void *)&_mh_execute_header, v0, v1, "Unable to format: filePath %s cut off with date (needed %zu chars)", v2, v3);
}

void sub_1000928F4()
{
  sub_1000466F4();
  sub_100046694((void *)&_mh_execute_header, v0, v1, "filePath %s cut off with date (needed %zu chars)", v2, v3);
}

void sub_10009295C()
{
  sub_10004670C();
  sub_1000466D8((void *)&_mh_execute_header, v0, v1, "Unable to format: spindump-stuck: Audio running, avoiding stackshot", v2, v3, v4, v5, v6);
}

void sub_100092990()
{
  sub_10004670C();
  _os_log_debug_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_DEBUG, "spindump-stuck: Audio running, avoiding stackshot", v1, 2u);
}

void sub_1000929D0()
{
  sub_10004670C();
  sub_1000466D8((void *)&_mh_execute_header, v0, v1, "Unable to format: spindump-stuck: Spindump has taken over a minute to process samples and may be stuck, try using -noIPC", v2, v3, v4, v5, v6);
}

void sub_100092A04()
{
  sub_100046668();
  sub_10002E4E8(v0);
  __error();
  uint64_t v1 = __error();
  strerror(*v1);
  sub_1000468C4();
  sub_10005F044();
  _os_log_fault_impl(v2, v3, v4, v5, v6, 0x22u);
}

void sub_100092AA4()
{
  sub_100046668();
  sub_10002E4E8(v1);
  __error();
  uint64_t v2 = __error();
  strerror(*v2);
  sub_1000468C4();
  _os_log_error_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_ERROR, "%{public}s [%d]: Unable to get proc info, assuming not being debugged: %d (%s)", v3, 0x22u);
}

void sub_100092B4C()
{
  __error();
  int v0 = __error();
  strerror(*v0);
  sub_1000467CC();
  sub_100046614((void *)&_mh_execute_header, v1, v2, "Unable to format: Unable to get proc info, assuming not being debugged: %d (%s)", v3, v4, v5, v6, v7);
}

void sub_100092BD4()
{
  __error();
  int v0 = __error();
  strerror(*v0);
  sub_1000467CC();
  sub_100046A30((void *)&_mh_execute_header, v1, v2, "Unable to get proc info, assuming not being debugged: %d (%s)", v3, v4, v5, v6, v7);
}

void sub_100092C5C()
{
  __error();
  int v0 = __error();
  strerror(*v0);
  sub_1000467CC();
  sub_100046614((void *)&_mh_execute_header, v1, v2, "Unable to format: sysctl for security.mac.sandbox.audio_active failed: %d (%s)", v3, v4, v5, v6, v7);
}

void sub_100092CE4()
{
  __error();
  int v0 = __error();
  strerror(*v0);
  sub_1000467CC();
  sub_100046614((void *)&_mh_execute_header, v1, v2, "sysctl for security.mac.sandbox.audio_active failed: %d (%s)", v3, v4, v5, v6, v7);
}

void sub_100092D6C(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_100092DE4(os_log_t log)
{
  int v1 = 136315138;
  uint64_t v2 = "source";
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "%s: unable to allocate source", (uint8_t *)&v1, 0xCu);
}

void sub_100092E68()
{
  __error();
  int v0 = __error();
  strerror(*v0);
  sub_1000467CC();
  sub_100046614((void *)&_mh_execute_header, v1, v2, "Unable to format: sysctlnametomib for security.mac.sandbox.audio_active failed: %d (%s)", v3, v4, v5, v6, v7);
}

void sub_100092EF0()
{
  __error();
  int v0 = __error();
  strerror(*v0);
  sub_1000467CC();
  sub_100046614((void *)&_mh_execute_header, v1, v2, "sysctlnametomib for security.mac.sandbox.audio_active failed: %d (%s)", v3, v4, v5, v6, v7);
}

void sub_100092F78()
{
  sub_1000481A4();
  sub_10005EFC4((void *)&_mh_execute_header, v0, v1, "Unable to format: Memory pressure %d", v2);
}

void sub_100092FE8()
{
  sub_1000481A4();
  sub_10005EFEC((void *)&_mh_execute_header, v0, v1, "Memory pressure %d", v2, v3, v4, v5, v6);
}

void sub_100093054()
{
  __error();
  int v0 = __error();
  strerror(*v0);
  sub_1000467CC();
  sub_100046614((void *)&_mh_execute_header, v1, v2, "Unable to format: sysctl for kern.memorystatus_vm_pressure_level failed: %d (%s)", v3, v4, v5, v6, v7);
}

void sub_1000930DC()
{
  __error();
  int v0 = __error();
  strerror(*v0);
  sub_1000467CC();
  sub_100046614((void *)&_mh_execute_header, v1, v2, "sysctl for kern.memorystatus_vm_pressure_level failed: %d (%s)", v3, v4, v5, v6, v7);
}

void sub_100093164()
{
  __error();
  int v0 = __error();
  strerror(*v0);
  sub_1000467CC();
  sub_100046614((void *)&_mh_execute_header, v1, v2, "Unable to format: sysctlnametomib for kern.memorystatus_vm_pressure_level failed: %d (%s)", v3, v4, v5, v6, v7);
}

void sub_1000931EC()
{
  __error();
  int v0 = __error();
  strerror(*v0);
  sub_1000467CC();
  sub_100046614((void *)&_mh_execute_header, v1, v2, "sysctlnametomib for kern.memorystatus_vm_pressure_level failed: %d (%s)", v3, v4, v5, v6, v7);
}

void sub_100093274()
{
  geteuid();
  sub_100048290();
  sub_100046614((void *)&_mh_execute_header, v0, v1, "Unable to format: %s: spindump must run as root to create spindump directory (running as %d)", v2, v3, v4, v5, 2u);
}

void sub_1000932F8()
{
  geteuid();
  sub_100048290();
  sub_100046A30((void *)&_mh_execute_header, v0, v1, "%s: spindump must run as root to create spindump directory (running as %d)", v2, v3, v4, v5, 2u);
}

void sub_10009337C(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_1000933F4(os_log_t log)
{
  int v1 = 136315138;
  uint64_t v2 = "(((st.st_mode) & 0170000) == 0040000)";
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "%s: /private/var/db/spindump already exists and isnt a directory!", (uint8_t *)&v1, 0xCu);
}

void sub_100093478()
{
  sub_100046668();
  strerror(v0);
  __error();
  int v1 = __error();
  strerror(*v1);
  sub_10005EF50();
  sub_10005F044();
  _os_log_fault_impl(v2, v3, v4, v5, v6, 0x2Cu);
}

void sub_100093520()
{
  sub_100046668();
  strerror(v1);
  __error();
  uint64_t v2 = __error();
  strerror(*v2);
  sub_10005EF50();
  _os_log_error_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_ERROR, "%s: unable to create /private/var/db/spindump after state failed with %d (%s): %d (%s)", v3, 0x2Cu);
}

void sub_1000935D0()
{
  sub_100046A90();
  sub_10005EFC4((void *)&_mh_execute_header, v0, v1, "Unable to format: Creating spindump directory /private/var/db/spindump after stat said %d", v2);
}

void sub_10009363C()
{
  sub_100046A90();
  sub_10005EFEC((void *)&_mh_execute_header, v0, v1, "Creating spindump directory /private/var/db/spindump after stat said %{errno}d", v2, v3, v4, v5, v6);
}

void sub_1000936A4()
{
  sub_100046668();
  __error();
  int v0 = __error();
  strerror(*v0);
  sub_1000466B4();
  sub_1000465A0((void *)&_mh_execute_header, v1, v2, "Unable to format: Unable to open %s: %d (%s)", v3, v4, v5, v6, v7);
}

void sub_100093734()
{
  sub_10005FBF4(__stack_chk_guard);
  sub_10005FBDC();
  sub_100046694((void *)&_mh_execute_header, v0, v1, "Unable to format: %s isn't big enough for a kcdata header (only %lld bytes)", v2, v3);
}

void sub_10009379C()
{
  sub_10005FBF4(__stack_chk_guard);
  sub_10005FBDC();
  _os_log_error_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_ERROR, "%s isn't big enough for a kcdata header (only %lld bytes)", v1, 0x16u);
}

void sub_100093814()
{
  sub_100046668();
  __error();
  os_log_t v0 = __error();
  strerror(*v0);
  sub_1000466B4();
  sub_1000465A0((void *)&_mh_execute_header, v1, v2, "Unable to format: Unable to map %s: %d (%s)", v3, v4, v5, v6, v7);
}

void sub_1000938A4()
{
  sub_100046668();
  __error();
  os_log_t v0 = __error();
  strerror(*v0);
  sub_1000466B4();
  sub_100046874((void *)&_mh_execute_header, v1, v2, "Unable to map %s: %d (%s)", v3, v4, v5, v6, v7);
}

void sub_100093934()
{
  sub_10005FBF4(__stack_chk_guard);
  sub_10005FBDC();
  sub_100046694((void *)&_mh_execute_header, v0, v1, "Unable to format: Not a kcdata file: kcdata in %s not valid (file length %lld)", v2, v3);
}

void sub_10009399C()
{
  sub_10005FBF4(__stack_chk_guard);
  sub_10005FBDC();
  _os_log_debug_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_DEBUG, "Not a kcdata file: kcdata in %s not valid (file length %lld)", v1, 0x16u);
}

void sub_100093A14(os_log_t log)
{
  *(_WORD *)os_log_t v1 = 0;
  _os_log_fault_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_FAULT, "Unable to format: Avoiding inspecting live processes for stackshot file due to audio running", v1, 2u);
}

void sub_100093A58()
{
  sub_10005FC00(__stack_chk_guard);
  sub_100055F94();
  _os_log_fault_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_FAULT, "Unable to format: %s isn't a kcdata stackshot file (header type %#x)", v1, 0x12u);
}

void sub_100093AD8()
{
  sub_10005FC00(__stack_chk_guard);
  sub_100055F94();
  _os_log_error_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_ERROR, "%s isn't a kcdata stackshot file (header type %#x)", v1, 0x12u);
}

void sub_100093B58()
{
  sub_100046668();
  __error();
  os_log_t v0 = __error();
  strerror(*v0);
  sub_1000466B4();
  sub_1000465A0((void *)&_mh_execute_header, v1, v2, "Unable to format: Unable to stat %s: %d (%s)", v3, v4, v5, v6, v7);
}

void sub_100093BE8()
{
  sub_100046668();
  __error();
  os_log_t v0 = __error();
  strerror(*v0);
  sub_1000466B4();
  sub_100046874((void *)&_mh_execute_header, v1, v2, "Unable to stat %s: %d (%s)", v3, v4, v5, v6, v7);
}

void sub_100093C78(int *a1)
{
  sub_10002E4E8(*a1);
  sub_10006DD7C();
  sub_1000465A0((void *)&_mh_execute_header, v1, v2, "Unable to format: %s [%d]: dealloc with %p transaction", v3, v4, v5, v6, v7);
}

void sub_100093D0C(int *a1)
{
  sub_10002E4E8(*a1);
  sub_10006DD7C();
  sub_100046854((void *)&_mh_execute_header, v1, v2, "%{public}s [%d]: dealloc with %p transaction", v3, v4, v5, v6, v7);
}

void sub_100093DA0(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_100093E10(uint64_t a1, NSObject *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  int v3 = 134217984;
  uint64_t v4 = v2;
  _os_log_debug_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_DEBUG, "dealloc with %p transaction", (uint8_t *)&v3, 0xCu);
}

void sub_100093E8C()
{
  sub_100046668();
  sub_10006DDC4(v0, __stack_chk_guard);
  sub_10006DD24();
  sub_1000465A0((void *)&_mh_execute_header, v1, v2, "Unable to format: %s [%d]: %s: nil sampleStore", v3, v4, v5, v6, v7);
}

void sub_100093F10()
{
  sub_100046668();
  sub_10006DDC4(v0, __stack_chk_guard);
  sub_10006DD24();
  sub_100046874((void *)&_mh_execute_header, v1, v2, "%s [%d]: %s: nil sampleStore", v3, v4, v5, v6, v7);
}

void sub_100093F94(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_10009400C(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_100094084()
{
  sub_100046668();
  sub_100055FD8(v0);
  sub_100055F94();
  sub_100046614((void *)&_mh_execute_header, v1, v2, "Unable to format: %s [%d]: Generating report", v3, v4, v5, v6, v7);
}

void sub_1000940FC()
{
  sub_10004670C();
  sub_1000466D8((void *)&_mh_execute_header, v0, v1, "Unable to format: Generating report", v2, v3, v4, v5, v6);
}

void sub_100094130()
{
  sub_100046668();
  sub_100055FD8(v0);
  sub_100055F94();
  sub_100046614((void *)&_mh_execute_header, v1, v2, "Unable to format: %s [%d]: Unable to create sample printer", v3, v4, v5, v6, v7);
}

void sub_1000941A8()
{
  sub_100046668();
  sub_100055FD8(v0);
  sub_100055F94();
  sub_100046A30((void *)&_mh_execute_header, v1, v2, "%{public}s [%d]: Unable to create sample printer", v3, v4, v5, v6, v7);
}

void sub_100094220()
{
  sub_10004670C();
  sub_1000466D8((void *)&_mh_execute_header, v0, v1, "Unable to format: Unable to create sample printer", v2, v3, v4, v5, v6);
}

void sub_100094254()
{
  sub_10004670C();
  sub_10004B018((void *)&_mh_execute_header, v0, v1, "Unable to create sample printer", v2, v3, v4, v5, v6);
}

void sub_100094288()
{
  sub_100046668();
  sub_100055FD8(v0);
  sub_100055F94();
  sub_100046614((void *)&_mh_execute_header, v1, v2, "Unable to format: %s [%d]: Done generating report", v3, v4, v5, v6, v7);
}

void sub_100094300()
{
  sub_10004670C();
  sub_1000466D8((void *)&_mh_execute_header, v0, v1, "Unable to format: Done generating report", v2, v3, v4, v5, v6);
}

void sub_100094334()
{
  sub_100046668();
  sub_100055FD8(v0);
  sub_100055F94();
  sub_100046614((void *)&_mh_execute_header, v1, v2, "Unable to format: %s [%d]: Unable to save spindump binary format", v3, v4, v5, v6, v7);
}

void sub_1000943AC()
{
  sub_100046668();
  sub_100055FD8(v0);
  sub_100055F94();
  sub_100046A30((void *)&_mh_execute_header, v1, v2, "%{public}s [%d]: Unable to save spindump binary format", v3, v4, v5, v6, v7);
}

void sub_100094424()
{
  sub_10004670C();
  sub_1000466D8((void *)&_mh_execute_header, v0, v1, "Unable to format: Unable to save spindump binary format", v2, v3, v4, v5, v6);
}

void sub_100094458()
{
  sub_10004670C();
  sub_10004B018((void *)&_mh_execute_header, v0, v1, "Unable to save spindump binary format", v2, v3, v4, v5, v6);
}

void sub_10009448C()
{
  sub_100046668();
  sub_100055FD8(v0);
  sub_100055F94();
  sub_100046614((void *)&_mh_execute_header, v1, v2, "Unable to format: %s [%d]: Unable to allocate proc exit HID dispatch source", v3, v4, v5, v6, v7);
}

void sub_100094504()
{
  sub_100046668();
  sub_100055FD8(v0);
  sub_100055F94();
  sub_100046A30((void *)&_mh_execute_header, v1, v2, "%{public}s [%d]: Unable to allocate proc exit HID dispatch source", v3, v4, v5, v6, v7);
}

void sub_10009457C()
{
  sub_10004670C();
  sub_1000466D8((void *)&_mh_execute_header, v0, v1, "Unable to format: Unable to allocate proc exit HID dispatch source", v2, v3, v4, v5, v6);
}

void sub_1000945B0()
{
  sub_10004670C();
  sub_10004B018((void *)&_mh_execute_header, v0, v1, "Unable to allocate proc exit HID dispatch source", v2, v3, v4, v5, v6);
}

void sub_1000945E4()
{
  sub_100046668();
  sub_10006DCFC(v0);
  sub_10006DD18();
  sub_100055F94();
  sub_100046614((void *)&_mh_execute_header, v1, v2, "Unable to format: %s [%d]: exited - HID", v3, v4, v5, v6, v7);
}

void sub_10009465C()
{
  sub_10004670C();
  sub_1000466D8((void *)&_mh_execute_header, v0, v1, "Unable to format: exited - HID", v2, v3, v4, v5, v6);
}

void sub_100094690()
{
  sub_100046668();
  sub_10006DCFC(v0);
  sub_10006DD18();
  sub_100055F94();
  sub_100046614((void *)&_mh_execute_header, v1, v2, "Unable to format: %s [%d]: Process exited, no longer waiting for HID event", v3, v4, v5, v6, v7);
}

void sub_100094708()
{
  sub_100046668();
  sub_10006DCFC(v0);
  sub_10006DD18();
  sub_100055F94();
  sub_100046674((void *)&_mh_execute_header, v1, v2, "%{public}s [%d]: Process exited, no longer waiting for HID event", v3, v4, v5, v6, v7);
}

void sub_100094780()
{
  sub_10004670C();
  sub_1000466D8((void *)&_mh_execute_header, v0, v1, "Unable to format: Process exited, no longer waiting for HID event", v2, v3, v4, v5, v6);
}

void sub_1000947B4()
{
  sub_10004670C();
  sub_100046758((void *)&_mh_execute_header, v0, v1, "Process exited, no longer waiting for HID event", v2, v3, v4, v5, v6);
}

void sub_1000947E8()
{
  sub_100046668();
  sub_10006DCFC(v0);
  sub_10006DD18();
  sub_100055F94();
  sub_100046614((void *)&_mh_execute_header, v1, v2, "Unable to format: %s [%d]: Process exited, and not waiting for a HID event", v3, v4, v5, v6, v7);
}

void sub_100094860()
{
  sub_100046668();
  sub_10006DCFC(v0);
  sub_10006DD18();
  sub_100055F94();
  sub_100046674((void *)&_mh_execute_header, v1, v2, "%{public}s [%d]: Process exited, and not waiting for a HID event", v3, v4, v5, v6, v7);
}

void sub_1000948D8()
{
  sub_10004670C();
  sub_1000466D8((void *)&_mh_execute_header, v0, v1, "Unable to format: Process exited, and not waiting for a HID event", v2, v3, v4, v5, v6);
}

void sub_10009490C()
{
  sub_10004670C();
  sub_100046758((void *)&_mh_execute_header, v0, v1, "Process exited, and not waiting for a HID event", v2, v3, v4, v5, v6);
}

void sub_100094940()
{
  sub_100046668();
  int v1 = sub_10006DE50(v0);
  sub_10002E4E8(v1);
  sub_10006DE68();
  sub_10006DD44();
  sub_1000465A0((void *)&_mh_execute_header, v2, v3, "Unable to format: %s [%d]: %s: _hidEventSem non-NULL when not requiring HID event", v4, v5, v6, v7, v8);
}

void sub_1000949D0()
{
  sub_100046668();
  int v1 = sub_10006DE50(v0);
  sub_10002E4E8(v1);
  sub_10006DE68();
  sub_10006DD44();
  sub_100046874((void *)&_mh_execute_header, v2, v3, "%s [%d]: %s: _hidEventSem non-NULL when not requiring HID event", v4, v5, v6, v7, v8);
}

void sub_100094A60(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_100094AD8(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_100094B50()
{
  sub_100046668();
  sub_10006DCFC(v0);
  sub_10006DD18();
  sub_100055F94();
  sub_100046614((void *)&_mh_execute_header, v1, v2, "Unable to format: %s [%d]: Doesn't require HID event and we weren't waiting before anyway", v3, v4, v5, v6, v7);
}

void sub_100094BC8()
{
  sub_100046668();
  sub_10006DCFC(v0);
  sub_10006DD18();
  sub_100055F94();
  sub_100046674((void *)&_mh_execute_header, v1, v2, "%{public}s [%d]: Doesn't require HID event and we weren't waiting before anyway", v3, v4, v5, v6, v7);
}

void sub_100094C40()
{
  sub_10004670C();
  sub_1000466D8((void *)&_mh_execute_header, v0, v1, "Unable to format: Doesn't require HID event and we weren't waiting before anyway", v2, v3, v4, v5, v6);
}

void sub_100094C74()
{
  sub_10004670C();
  sub_100046758((void *)&_mh_execute_header, v0, v1, "Doesn't require HID event and we weren't waiting before anyway", v2, v3, v4, v5, v6);
}

void sub_100094CA8()
{
  sub_100046668();
  sub_10006DCFC(v0);
  sub_10006DD18();
  sub_100055F94();
  sub_100046614((void *)&_mh_execute_header, v1, v2, "Unable to format: %s [%d]: No longer waiting for HID event", v3, v4, v5, v6, v7);
}

void sub_100094D20()
{
  sub_100046668();
  sub_10006DCFC(v0);
  sub_10006DD18();
  sub_100055F94();
  sub_100046674((void *)&_mh_execute_header, v1, v2, "%{public}s [%d]: No longer waiting for HID event", v3, v4, v5, v6, v7);
}

void sub_100094D98()
{
  sub_10004670C();
  sub_1000466D8((void *)&_mh_execute_header, v0, v1, "Unable to format: No longer waiting for HID event", v2, v3, v4, v5, v6);
}

void sub_100094DCC()
{
  sub_10004670C();
  sub_100046758((void *)&_mh_execute_header, v0, v1, "No longer waiting for HID event", v2, v3, v4, v5, v6);
}

void sub_100094E00()
{
  sub_100046668();
  int v1 = sub_10006DE50(v0);
  sub_10002E4E8(v1);
  sub_10006DE68();
  sub_10006DD44();
  sub_1000465A0((void *)&_mh_execute_header, v2, v3, "Unable to format: %s [%d]: %s: _hidEventSem non-NULL when already tracking this process in previous spin", v4, v5, v6, v7, v8);
}

void sub_100094E90()
{
  sub_100046668();
  int v1 = sub_10006DE50(v0);
  sub_10002E4E8(v1);
  sub_10006DE68();
  sub_10006DD44();
  sub_100046874((void *)&_mh_execute_header, v2, v3, "%s [%d]: %s: _hidEventSem non-NULL when already tracking this process in previous spin", v4, v5, v6, v7, v8);
}

void sub_100094F20(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_100094F98(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_100095010()
{
  sub_100046668();
  sub_10006DCFC(v0);
  sub_10006DD18();
  sub_100055F94();
  sub_100046614((void *)&_mh_execute_header, v1, v2, "Unable to format: %s [%d]: Previous spin waiting for HID event", v3, v4, v5, v6, v7);
}

void sub_100095088()
{
  sub_100046668();
  sub_10006DCFC(v0);
  sub_10006DD18();
  sub_100055F94();
  sub_100046674((void *)&_mh_execute_header, v1, v2, "%{public}s [%d]: Previous spin waiting for HID event", v3, v4, v5, v6, v7);
}

void sub_100095100()
{
  sub_10004670C();
  sub_1000466D8((void *)&_mh_execute_header, v0, v1, "Unable to format: Previous spin waiting for HID event", v2, v3, v4, v5, v6);
}

void sub_100095134()
{
  sub_10004670C();
  sub_100046758((void *)&_mh_execute_header, v0, v1, "Previous spin waiting for HID event", v2, v3, v4, v5, v6);
}

void sub_100095168()
{
  sub_100046668();
  sub_10006DCFC(v0);
  sub_10006DD18();
  sub_100055F94();
  sub_100046614((void *)&_mh_execute_header, v1, v2, "Unable to format: %s [%d]: Requires HID event", v3, v4, v5, v6, v7);
}

void sub_1000951E0()
{
  sub_100046668();
  sub_10006DCFC(v0);
  sub_10006DD18();
  sub_100055F94();
  sub_100046674((void *)&_mh_execute_header, v1, v2, "%{public}s [%d]: Requires HID event", v3, v4, v5, v6, v7);
}

void sub_100095258()
{
  sub_10004670C();
  sub_1000466D8((void *)&_mh_execute_header, v0, v1, "Unable to format: Requires HID event", v2, v3, v4, v5, v6);
}

void sub_10009528C()
{
  sub_10004670C();
  sub_100046758((void *)&_mh_execute_header, v0, v1, "Requires HID event", v2, v3, v4, v5, v6);
}

void sub_1000952C0()
{
  sub_100046668();
  sub_10006DCFC(v0);
  sub_10006DD18();
  sub_100055F94();
  sub_100046614((void *)&_mh_execute_header, v1, v2, "Unable to format: %s [%d]: Already waiting for HID event", v3, v4, v5, v6, v7);
}

void sub_100095338()
{
  sub_100046668();
  sub_10006DCFC(v0);
  sub_10006DD18();
  sub_100055F94();
  sub_100046674((void *)&_mh_execute_header, v1, v2, "%{public}s [%d]: Already waiting for HID event", v3, v4, v5, v6, v7);
}

void sub_1000953B0()
{
  sub_10004670C();
  sub_1000466D8((void *)&_mh_execute_header, v0, v1, "Unable to format: Already waiting for HID event", v2, v3, v4, v5, v6);
}

void sub_1000953E4()
{
  sub_10004670C();
  sub_100046758((void *)&_mh_execute_header, v0, v1, "Already waiting for HID event", v2, v3, v4, v5, v6);
}

void sub_100095418()
{
  sub_100046668();
  sub_10006DCFC(v0);
  sub_10006DD18();
  sub_100055F94();
  sub_100046614((void *)&_mh_execute_header, v1, v2, "Unable to format: %s [%d]: Already waiting for HID event from previous spin, canceling this spin", v3, v4, v5, v6, v7);
}

void sub_100095490()
{
  sub_10004670C();
  sub_1000466D8((void *)&_mh_execute_header, v0, v1, "Unable to format: Already waiting for HID event from previous spin, canceling this spin", v2, v3, v4, v5, v6);
}

void sub_1000954C4()
{
  sub_100046668();
  sub_100055FD8(v0);
  sub_100055F94();
  sub_100046614((void *)&_mh_execute_header, v1, v2, "Unable to format: %s [%d]: No sampled process for hid event", v3, v4, v5, v6, v7);
}

void sub_10009553C()
{
  sub_100046668();
  sub_100055FD8(v0);
  sub_100055F94();
  sub_100046674((void *)&_mh_execute_header, v1, v2, "%{public}s [%d]: No sampled process for hid event", v3, v4, v5, v6, v7);
}

void sub_1000955B4()
{
  sub_10004670C();
  sub_1000466D8((void *)&_mh_execute_header, v0, v1, "Unable to format: No sampled process for hid event", v2, v3, v4, v5, v6);
}

void sub_1000955E8()
{
  sub_10004670C();
  sub_100046758((void *)&_mh_execute_header, v0, v1, "No sampled process for hid event", v2, v3, v4, v5, v6);
}

void sub_10009561C(uint64_t a1, id *a2)
{
  [*(id *)(a1 + 416) machAbsTimeSeconds];
  [*a2 machAbsTimeSeconds];
  sub_10005F044();
  _os_log_fault_impl(v3, v4, v5, v6, v7, 0xCu);
}

void sub_1000956C8(uint64_t a1, id *a2, NSObject *a3)
{
  [*(id *)(a1 + 416) machAbsTimeSeconds];
  double v6 = v5;
  [*a2 machAbsTimeSeconds];
  int v8 = 134217984;
  double v9 = v6 - v7;
  _os_log_debug_impl((void *)&_mh_execute_header, a3, OS_LOG_TYPE_DEBUG, "Got hid event from %.1fs earlier than the spin we monitored, continuing to wait", (uint8_t *)&v8, 0xCu);
}

void sub_10009577C()
{
  sub_100046668();
  sub_100055FD8(v0);
  sub_100055F94();
  sub_100046614((void *)&_mh_execute_header, v1, v2, "Unable to format: %s [%d]: Got hid event", v3, v4, v5, v6, v7);
}

void sub_1000957F4()
{
  sub_10004670C();
  sub_1000466D8((void *)&_mh_execute_header, v0, v1, "Unable to format: Got hid event", v2, v3, v4, v5, v6);
}

void sub_100095828()
{
  sub_100046668();
  sub_100055FD8(v0);
  sub_100055F94();
  sub_100046614((void *)&_mh_execute_header, v1, v2, "Unable to format: %s [%d]: Attempted to change sampling target after done sampling", v3, v4, v5, v6, v7);
}

void sub_1000958A0()
{
  sub_100046668();
  sub_100055FD8(v0);
  sub_100055F94();
  sub_100046A30((void *)&_mh_execute_header, v1, v2, "%{public}s [%d]: Attempted to change sampling target after done sampling", v3, v4, v5, v6, v7);
}

void sub_100095918()
{
  sub_10004670C();
  sub_1000466D8((void *)&_mh_execute_header, v0, v1, "Unable to format: Attempted to change sampling target after done sampling", v2, v3, v4, v5, v6);
}

void sub_10009594C()
{
  sub_10004670C();
  sub_10004B018((void *)&_mh_execute_header, v0, v1, "Attempted to change sampling target after done sampling", v2, v3, v4, v5, v6);
}

void sub_100095980()
{
  sub_100046668();
  sub_100055FD8(v0);
  sub_100055F94();
  sub_100046614((void *)&_mh_execute_header, v1, v2, "Unable to format: %s [%d]: Pids is ignored when sampling all processes", v3, v4, v5, v6, v7);
}

void sub_1000959F8()
{
  sub_100046668();
  sub_100055FD8(v0);
  sub_100055F94();
  sub_100046A30((void *)&_mh_execute_header, v1, v2, "%{public}s [%d]: Pids is ignored when sampling all processes", v3, v4, v5, v6, v7);
}

void sub_100095A70()
{
  sub_10004670C();
  sub_1000466D8((void *)&_mh_execute_header, v0, v1, "Unable to format: Pids is ignored when sampling all processes", v2, v3, v4, v5, v6);
}

void sub_100095AA4()
{
  sub_10004670C();
  sub_10004B018((void *)&_mh_execute_header, v0, v1, "Pids is ignored when sampling all processes", v2, v3, v4, v5, v6);
}

void sub_100095AD8()
{
  sub_10006DD64();
  sub_10006DDF0((void *)&_mh_execute_header, v0, v1, "Unable to format: Attempted to change sampling interval to %uus while already sampling/sampled at %uus", v2, v3);
}

void sub_100095B44()
{
  sub_10006DD64();
  sub_10006DE30((void *)&_mh_execute_header, v0, v1, "Attempted to change sampling interval to %uus while already sampling/sampled at %uus", v2, v3);
}

void sub_100095BB8()
{
  sub_10006DD64();
  sub_10006DDF0((void *)&_mh_execute_header, v0, v1, "Unable to format: Attempted to change occasional data interval to %uus while already sampling/sampled at %uus", v2, v3);
}

void sub_100095C24()
{
  sub_10006DD64();
  sub_10006DE30((void *)&_mh_execute_header, v0, v1, "Attempted to change occasional data interval to %uus while already sampling/sampled at %uus", v2, v3);
}

void sub_100095C98()
{
  sub_100046668();
  sub_100055FD8(v0);
  sub_100055F94();
  sub_100046614((void *)&_mh_execute_header, v1, v2, "Unable to format: %s [%d]: Asked to stop sooner than the existing timeout", v3, v4, v5, v6, v7);
}

void sub_100095D10()
{
  sub_100046668();
  sub_100055FD8(v0);
  sub_100055F94();
  sub_100046674((void *)&_mh_execute_header, v1, v2, "%{public}s [%d]: Asked to stop sooner than the existing timeout", v3, v4, v5, v6, v7);
}

void sub_100095D88()
{
  sub_10004670C();
  sub_1000466D8((void *)&_mh_execute_header, v0, v1, "Unable to format: Asked to stop sooner than the existing timeout", v2, v3, v4, v5, v6);
}

void sub_100095DBC()
{
  sub_10004670C();
  sub_100046758((void *)&_mh_execute_header, v0, v1, "Asked to stop sooner than the existing timeout", v2, v3, v4, v5, v6);
}

void sub_100095DF0(int *a1)
{
  sub_10002E4E8(*a1);
  sub_100055F94();
  sub_1000465A0((void *)&_mh_execute_header, v1, v2, "Unable to format: %s [%d]: Setting sampling timeout for %.2f seconds from now", v3, v4, v5, v6, v7);
}

void sub_100095E8C(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_100095EFC()
{
  sub_100046668();
  sub_10006DCFC(v0);
  sub_10006DD18();
  sub_100055F94();
  sub_100046614((void *)&_mh_execute_header, v1, v2, "Unable to format: %s [%d]: Lost race: already done sampling", v3, v4, v5, v6, v7);
}

void sub_100095F74()
{
  sub_100046668();
  sub_10006DCFC(v0);
  sub_10006DD18();
  sub_100055F94();
  sub_100046674((void *)&_mh_execute_header, v1, v2, "%{public}s [%d]: Lost race: already done sampling", v3, v4, v5, v6, v7);
}

void sub_100095FEC()
{
  sub_10004670C();
  sub_1000466D8((void *)&_mh_execute_header, v0, v1, "Unable to format: Lost race: already done sampling", v2, v3, v4, v5, v6);
}

void sub_100096020()
{
  sub_10004670C();
  sub_100046758((void *)&_mh_execute_header, v0, v1, "Lost race: already done sampling", v2, v3, v4, v5, v6);
}

void sub_100096054()
{
  sub_100046668();
  sub_10006DCFC(v0);
  sub_10006DD18();
  sub_100055F94();
  sub_100046614((void *)&_mh_execute_header, v1, v2, "Unable to format: %s [%d]: Monitoring timeout was extended, doing nothing", v3, v4, v5, v6, v7);
}

void sub_1000960CC()
{
  sub_100046668();
  sub_10006DCFC(v0);
  sub_10006DD18();
  sub_100055F94();
  sub_100046674((void *)&_mh_execute_header, v1, v2, "%{public}s [%d]: Monitoring timeout was extended, doing nothing", v3, v4, v5, v6, v7);
}

void sub_100096144()
{
  sub_10004670C();
  sub_1000466D8((void *)&_mh_execute_header, v0, v1, "Unable to format: Monitoring timeout was extended, doing nothing", v2, v3, v4, v5, v6);
}

void sub_100096178()
{
  sub_10004670C();
  sub_100046758((void *)&_mh_execute_header, v0, v1, "Monitoring timeout was extended, doing nothing", v2, v3, v4, v5, v6);
}

void sub_1000961AC()
{
  sub_100046668();
  sub_10006DCFC(v0);
  sub_10006DD18();
  sub_100055F94();
  sub_100046614((void *)&_mh_execute_header, v1, v2, "Unable to format: %s [%d]: Monitoring timed out", v3, v4, v5, v6, v7);
}

void sub_100096224()
{
  sub_100046668();
  sub_10006DCFC(v0);
  sub_10006DD18();
  sub_100055F94();
  sub_100046674((void *)&_mh_execute_header, v1, v2, "%{public}s [%d]: Monitoring timed out", v3, v4, v5, v6, v7);
}

void sub_10009629C()
{
  sub_10004670C();
  sub_1000466D8((void *)&_mh_execute_header, v0, v1, "Unable to format: Monitoring timed out", v2, v3, v4, v5, v6);
}

void sub_1000962D0()
{
  sub_10004670C();
  sub_100046758((void *)&_mh_execute_header, v0, v1, "Monitoring timed out", v2, v3, v4, v5, v6);
}

void sub_100096304()
{
  sub_100046668();
  sub_10006DDC4(v0, __stack_chk_guard);
  sub_10006DD24();
  sub_1000465A0((void *)&_mh_execute_header, v1, v2, "Unable to format: %s [%d]: %s: Must provide both queue and block", v3, v4, v5, v6, v7);
}

void sub_100096388()
{
  sub_100046668();
  sub_10006DDC4(v0, __stack_chk_guard);
  sub_10006DD24();
  sub_100046874((void *)&_mh_execute_header, v1, v2, "%s [%d]: %s: Must provide both queue and block", v3, v4, v5, v6, v7);
}

void sub_10009640C(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_100096484(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_1000964FC()
{
  sub_100046668();
  sub_10006DCFC(v0);
  sub_10006DD18();
  sub_100055F94();
  sub_100046614((void *)&_mh_execute_header, v1, v2, "Unable to format: %s [%d]: Unable to allocate proc exit dispatch source", v3, v4, v5, v6, v7);
}

void sub_100096574()
{
  sub_100046668();
  sub_10006DCFC(v0);
  sub_10006DD18();
  sub_100055F94();
  sub_100046A30((void *)&_mh_execute_header, v1, v2, "%{public}s [%d]: Unable to allocate proc exit dispatch source", v3, v4, v5, v6, v7);
}

void sub_1000965EC()
{
  sub_10004670C();
  sub_1000466D8((void *)&_mh_execute_header, v0, v1, "Unable to format: Unable to allocate proc exit dispatch source", v2, v3, v4, v5, v6);
}

void sub_100096620()
{
  sub_10004670C();
  sub_10004B018((void *)&_mh_execute_header, v0, v1, "Unable to allocate proc exit dispatch source", v2, v3, v4, v5, v6);
}

void sub_100096654()
{
  sub_10004670C();
  sub_1000466D8((void *)&_mh_execute_header, v0, v1, "Unable to format: Can't stop when kernel exits", v2, v3, v4, v5, v6);
}

void sub_100096688()
{
  sub_10004670C();
  sub_1000466D8((void *)&_mh_execute_header, v0, v1, "Unable to format: No target process to monitor for exiting", v2, v3, v4, v5, v6);
}

void sub_1000966BC()
{
  sub_100046668();
  sub_10006DCFC(v0);
  sub_10006DD18();
  sub_100055F94();
  sub_100046614((void *)&_mh_execute_header, v1, v2, "Unable to format: %s [%d]: exited", v3, v4, v5, v6, v7);
}

void sub_100096734()
{
  sub_100046668();
  sub_10006DCFC(v0);
  sub_10006DD18();
  sub_100055F94();
  sub_100046674((void *)&_mh_execute_header, v1, v2, "%{public}s [%d]: exited", v3, v4, v5, v6, v7);
}

void sub_1000967AC()
{
  sub_10004670C();
  sub_1000466D8((void *)&_mh_execute_header, v0, v1, "Unable to format: exited", v2, v3, v4, v5, v6);
}

void sub_1000967E0()
{
  sub_10004670C();
  sub_100046758((void *)&_mh_execute_header, v0, v1, "exited", v2, v3, v4, v5, v6);
}

void sub_100096814(int *a1)
{
  sub_100055FD8(a1);
  sub_100055F94();
  sub_10005F044();
  _os_log_fault_impl(v1, v2, v3, v4, v5, 0x18u);
}

void sub_1000968AC(int *a1, unsigned __int8 a2, NSObject *a3)
{
  uint8_t v6 = sub_100055FD8(a1);
  int v7 = *a1;
  int v8 = 136446722;
  double v9 = v6;
  __int16 v10 = 1024;
  int v11 = v7;
  __int16 v12 = 1024;
  int v13 = a2;
  _os_log_debug_impl((void *)&_mh_execute_header, a3, OS_LOG_TYPE_DEBUG, "%{public}s [%d]: Already not sampling when stopped with reason %d", (uint8_t *)&v8, 0x18u);
}

void sub_100096960(int a1, NSObject *a2)
{
  v2[0] = 67109120;
  v2[1] = a1;
  _os_log_fault_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_FAULT, "Unable to format: Already not sampling when stopped with reason %d", (uint8_t *)v2, 8u);
}

void sub_1000969D8(unsigned __int8 a1, NSObject *a2)
{
  v2[0] = 67109120;
  v2[1] = a1;
  _os_log_debug_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_DEBUG, "Already not sampling when stopped with reason %d", (uint8_t *)v2, 8u);
}

void sub_100096A54()
{
  sub_100046668();
  sub_100055FD8(v0);
  sub_100055F94();
  sub_100046614((void *)&_mh_execute_header, v1, v2, "Unable to format: %s [%d]: No HID event required", v3, v4, v5, v6, v7);
}

void sub_100096ACC()
{
  sub_100046668();
  sub_100055FD8(v0);
  sub_100055F94();
  sub_100046674((void *)&_mh_execute_header, v1, v2, "%{public}s [%d]: No HID event required", v3, v4, v5, v6, v7);
}

void sub_100096B44()
{
  sub_10004670C();
  sub_1000466D8((void *)&_mh_execute_header, v0, v1, "Unable to format: No HID event required", v2, v3, v4, v5, v6);
}

void sub_100096B78()
{
  sub_10004670C();
  sub_100046758((void *)&_mh_execute_header, v0, v1, "No HID event required", v2, v3, v4, v5, v6);
}

void sub_100096BAC()
{
  sub_100046668();
  sub_100055FD8(v0);
  sub_100055F94();
  sub_100046614((void *)&_mh_execute_header, v1, v2, "Unable to format: %s [%d]: Canceling spin with no HID event where process exited", v3, v4, v5, v6, v7);
}

void sub_100096C24()
{
  sub_10004670C();
  sub_1000466D8((void *)&_mh_execute_header, v0, v1, "Unable to format: Canceling spin with no HID event where process exited", v2, v3, v4, v5, v6);
}

void sub_100096C58()
{
  sub_100046668();
  sub_100055FD8(v0);
  sub_100055F94();
  sub_100046614((void *)&_mh_execute_header, v1, v2, "Unable to format: %s [%d]: Received HID event, reporting spin", v3, v4, v5, v6, v7);
}

void sub_100096CD0()
{
  sub_100046668();
  sub_100055FD8(v0);
  sub_100055F94();
  sub_100046674((void *)&_mh_execute_header, v1, v2, "%{public}s [%d]: Received HID event, reporting spin", v3, v4, v5, v6, v7);
}

void sub_100096D48()
{
  sub_10004670C();
  sub_1000466D8((void *)&_mh_execute_header, v0, v1, "Unable to format: Received HID event, reporting spin", v2, v3, v4, v5, v6);
}

void sub_100096D7C()
{
  sub_10004670C();
  sub_100046758((void *)&_mh_execute_header, v0, v1, "Received HID event, reporting spin", v2, v3, v4, v5, v6);
}

void sub_100096DB0()
{
  sub_100046668();
  sub_100055FD8(v0);
  sub_100055F94();
  sub_100046614((void *)&_mh_execute_header, v1, v2, "Unable to format: %s [%d]: Canceling spin with no HID event in its time range", v3, v4, v5, v6, v7);
}

void sub_100096E28()
{
  sub_10004670C();
  sub_1000466D8((void *)&_mh_execute_header, v0, v1, "Unable to format: Canceling spin with no HID event in its time range", v2, v3, v4, v5, v6);
}

void sub_100096E5C()
{
  sub_100046668();
  sub_100055FD8(v0);
  sub_100055F94();
  sub_100046614((void *)&_mh_execute_header, v1, v2, "Unable to format: %s [%d]: Timed out waiting for HID event, canceling spin", v3, v4, v5, v6, v7);
}

void sub_100096ED4()
{
  sub_10004670C();
  sub_1000466D8((void *)&_mh_execute_header, v0, v1, "Unable to format: Timed out waiting for HID event, canceling spin", v2, v3, v4, v5, v6);
}

void sub_100096F08()
{
  sub_100046668();
  sub_100055FD8(v0);
  sub_100055F94();
  sub_100046614((void *)&_mh_execute_header, v1, v2, "Unable to format: %s [%d]: Waiting for HID event...", v3, v4, v5, v6, v7);
}

void sub_100096F80()
{
  sub_10004670C();
  sub_1000466D8((void *)&_mh_execute_header, v0, v1, "Unable to format: Waiting for HID event...", v2, v3, v4, v5, v6);
}

void sub_100096FB4()
{
  sub_100046668();
  sub_10006DCFC(v0);
  sub_10006DD18();
  sub_100055F94();
  sub_100046614((void *)&_mh_execute_header, v1, v2, "Unable to format: %s [%d]: Removing self from processes waiting on HID event list", v3, v4, v5, v6, v7);
}

void sub_10009702C()
{
  sub_100046668();
  sub_10006DCFC(v0);
  sub_10006DD18();
  sub_100055F94();
  sub_100046674((void *)&_mh_execute_header, v1, v2, "%{public}s [%d]: Removing self from processes waiting on HID event list", v3, v4, v5, v6, v7);
}

void sub_1000970A4()
{
  sub_10004670C();
  sub_1000466D8((void *)&_mh_execute_header, v0, v1, "Unable to format: Removing self from processes waiting on HID event list", v2, v3, v4, v5, v6);
}

void sub_1000970D8()
{
  sub_10004670C();
  sub_100046758((void *)&_mh_execute_header, v0, v1, "Removing self from processes waiting on HID event list", v2, v3, v4, v5, v6);
}

void sub_10009710C()
{
  sub_100046668();
  sub_10002E4E8(*(_DWORD *)(*(void *)v0 + 72));
  sub_10006DD18();
  sub_10006DD24();
  sub_1000465A0((void *)&_mh_execute_header, v1, v2, "Unable to format: %s [%d]: %s: Mismatched sample providers", v3, v4, v5, v6, v7);
}

void sub_1000971A0()
{
  sub_100046668();
  sub_10002E4E8(*(_DWORD *)(*(void *)v0 + 72));
  sub_10006DD18();
  sub_10006DD24();
  sub_100046874((void *)&_mh_execute_header, v1, v2, "%s [%d]: %s: Mismatched sample providers", v3, v4, v5, v6, v7);
}

void sub_100097230(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_1000972A8(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_100097320()
{
  sub_10006DDDC(__stack_chk_guard);
  LODWORD(v2) = 136315906;
  sub_10006DDA0();
  sub_10006DE10((void *)&_mh_execute_header, v0, v1, "%s: save report fail %d %d %d", v2, v3, v4, v5);
}

void sub_100097394()
{
  sub_100046668();
  sub_100055FD8(v0);
  sub_100055F94();
  sub_100046614((void *)&_mh_execute_header, v1, v2, "Unable to format: %s [%d]: Waiting for sampling to complete", v3, v4, v5, v6, v7);
}

void sub_10009740C()
{
  sub_10004670C();
  sub_1000466D8((void *)&_mh_execute_header, v0, v1, "Unable to format: Waiting for sampling to complete", v2, v3, v4, v5, v6);
}

void sub_100097440()
{
  sub_10006DDDC(__stack_chk_guard);
  LODWORD(v2) = 136315906;
  sub_10006DDA0();
  sub_10006DE10((void *)&_mh_execute_header, v0, v1, "%s: save report fail %d %d %d", v2, v3, v4, v5);
}

void sub_1000974B4()
{
  sub_100046668();
  sub_10002E4E8(v0);
  sub_100046564();
  sub_100046614((void *)&_mh_execute_header, v1, v2, "Unable to format: %s [%d]: Unable to create SPSampledProcess", v3, v4, v5, v6, v7);
}

void sub_10009752C()
{
  sub_100046668();
  sub_10002E4E8(v0);
  sub_100046564();
  sub_100046A30((void *)&_mh_execute_header, v1, v2, "%{public}s [%d]: Unable to create SPSampledProcess", v3, v4, v5, v6, v7);
}

void sub_1000975A4()
{
  sub_10004670C();
  sub_1000466D8((void *)&_mh_execute_header, v0, v1, "Unable to format: Unable to create SPSampledProcess", v2, v3, v4, v5, v6);
}

void sub_1000975D8()
{
  sub_10004670C();
  sub_10004B018((void *)&_mh_execute_header, v0, v1, "Unable to create SPSampledProcess", v2, v3, v4, v5, v6);
}

void sub_10009760C()
{
  sub_100046668();
  sub_10002E4E8(v0);
  sub_100046564();
  sub_100046614((void *)&_mh_execute_header, v1, v2, "Unable to format: %s [%d]: Failed to start sampling", v3, v4, v5, v6, v7);
}

void sub_100097684()
{
  sub_100046668();
  sub_10002E4E8(v0);
  sub_100046564();
  sub_100046A30((void *)&_mh_execute_header, v1, v2, "%{public}s [%d]: Failed to start sampling", v3, v4, v5, v6, v7);
}

void sub_1000976FC()
{
  sub_10004670C();
  sub_1000466D8((void *)&_mh_execute_header, v0, v1, "Unable to format: Failed to start sampling", v2, v3, v4, v5, v6);
}

void sub_100097730()
{
  sub_10004670C();
  sub_10004B018((void *)&_mh_execute_header, v0, v1, "Failed to start sampling", v2, v3, v4, v5, v6);
}

void sub_100097764()
{
  sub_100046668();
  sub_10002E4E8(v0);
  sub_100046564();
  sub_100046614((void *)&_mh_execute_header, v1, v2, "Unable to format: %s [%d]: Not overriding existing sampling callback", v3, v4, v5, v6, v7);
}

void sub_1000977DC()
{
  sub_100046668();
  sub_10002E4E8(v0);
  sub_100046564();
  sub_100046674((void *)&_mh_execute_header, v1, v2, "%{public}s [%d]: Not overriding existing sampling callback", v3, v4, v5, v6, v7);
}

void sub_100097854()
{
  sub_10004670C();
  sub_1000466D8((void *)&_mh_execute_header, v0, v1, "Unable to format: Not overriding existing sampling callback", v2, v3, v4, v5, v6);
}

void sub_100097888()
{
  sub_10004670C();
  sub_100046758((void *)&_mh_execute_header, v0, v1, "Not overriding existing sampling callback", v2, v3, v4, v5, v6);
}

void sub_1000978BC()
{
  sub_100046668();
  sub_10002E4E8(v0);
  sub_100046564();
  sub_100046614((void *)&_mh_execute_header, v1, v2, "Unable to format: %s [%d]: Already sampling with incompatible parameters", v3, v4, v5, v6, v7);
}

void sub_100097934()
{
  sub_100046668();
  sub_10002E4E8(v0);
  sub_100046564();
  sub_100046A30((void *)&_mh_execute_header, v1, v2, "%{public}s [%d]: Already sampling with incompatible parameters", v3, v4, v5, v6, v7);
}

void sub_1000979AC()
{
  sub_10004670C();
  sub_1000466D8((void *)&_mh_execute_header, v0, v1, "Unable to format: Already sampling with incompatible parameters", v2, v3, v4, v5, v6);
}

void sub_1000979E0()
{
  sub_10004670C();
  sub_10004B018((void *)&_mh_execute_header, v0, v1, "Already sampling with incompatible parameters", v2, v3, v4, v5, v6);
}

void sub_100097A14()
{
  sub_100046668();
  sub_10002E4E8(v0);
  sub_100046564();
  sub_100046614((void *)&_mh_execute_header, v1, v2, "Unable to format: %s [%d]: Already sampling, not overriding existing callback", v3, v4, v5, v6, v7);
}

void sub_100097A8C()
{
  sub_100046668();
  sub_10002E4E8(v0);
  sub_100046564();
  sub_100046674((void *)&_mh_execute_header, v1, v2, "%{public}s [%d]: Already sampling, not overriding existing callback", v3, v4, v5, v6, v7);
}

void sub_100097B04()
{
  sub_10004670C();
  sub_1000466D8((void *)&_mh_execute_header, v0, v1, "Unable to format: Already sampling, not overriding existing callback", v2, v3, v4, v5, v6);
}

void sub_100097B38()
{
  sub_10004670C();
  sub_100046758((void *)&_mh_execute_header, v0, v1, "Already sampling, not overriding existing callback", v2, v3, v4, v5, v6);
}

void sub_100097B6C()
{
  sub_100046668();
  sub_10002E4E8(v0);
  sub_100046564();
  sub_100046614((void *)&_mh_execute_header, v1, v2, "Unable to format: %s [%d]: Already sampling, overriding existing callback", v3, v4, v5, v6, v7);
}

void sub_100097BE4()
{
  sub_100046668();
  sub_10002E4E8(v0);
  sub_100046564();
  sub_100046674((void *)&_mh_execute_header, v1, v2, "%{public}s [%d]: Already sampling, overriding existing callback", v3, v4, v5, v6, v7);
}

void sub_100097C5C()
{
  sub_10004670C();
  sub_1000466D8((void *)&_mh_execute_header, v0, v1, "Unable to format: Already sampling, overriding existing callback", v2, v3, v4, v5, v6);
}

void sub_100097C90()
{
  sub_10004670C();
  sub_100046758((void *)&_mh_execute_header, v0, v1, "Already sampling, overriding existing callback", v2, v3, v4, v5, v6);
}

void sub_100097CC4()
{
  sub_100046668();
  sub_10002E4E8(v0);
  sub_100046564();
  sub_100046614((void *)&_mh_execute_header, v1, v2, "Unable to format: %s [%d]: Already sampling with sensitive strings", v3, v4, v5, v6, v7);
}

void sub_100097D3C()
{
  sub_10004670C();
  sub_1000466D8((void *)&_mh_execute_header, v0, v1, "Unable to format: Already sampling with sensitive strings", v2, v3, v4, v5, v6);
}

void sub_100097D70(int a1)
{
  sub_10002E4E8(a1);
  sub_1000465A0((void *)&_mh_execute_header, v1, v2, "Unable to format: %s [%d]: Unable to find existing %sWindowServer-based sampled process", v3, v4, v5, v6, 2u);
}

void sub_100097E14(int a1)
{
  sub_10002E4E8(a1);
  sub_100046854((void *)&_mh_execute_header, v1, v2, "%{public}s [%d]: Unable to find existing %sWindowServer-based sampled process", v3, v4, v5, v6, 2u);
}

void sub_100097ED0(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_100097F3C(char a1, NSObject *a2)
{
  uint64_t v2 = "";
  if (a1) {
    uint64_t v2 = "non-";
  }
  int v3 = 136315138;
  uint64_t v4 = v2;
  _os_log_debug_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_DEBUG, "Unable to find existing %sWindowServer-based sampled process", (uint8_t *)&v3, 0xCu);
}

void sub_100097FCC()
{
  sub_100046668();
  sub_10002E4E8(v0);
  sub_100046564();
  sub_100046614((void *)&_mh_execute_header, v1, v2, "Unable to format: %s [%d]: process doesn't exist, not sampling", v3, v4, v5, v6, v7);
}

void sub_100098044()
{
  sub_100046668();
  sub_10002E4E8(v0);
  sub_100046564();
  sub_100046A30((void *)&_mh_execute_header, v1, v2, "%{public}s [%d]: process doesn't exist, not sampling", v3, v4, v5, v6, v7);
}

void sub_1000980BC()
{
  sub_10004670C();
  sub_1000466D8((void *)&_mh_execute_header, v0, v1, "Unable to format: process doesn't exist, not sampling", v2, v3, v4, v5, v6);
}

void sub_1000980F0()
{
  sub_10004670C();
  sub_10004B018((void *)&_mh_execute_header, v0, v1, "process doesn't exist, not sampling", v2, v3, v4, v5, v6);
}

void sub_100098124()
{
  sub_100046668();
  sub_10002E4E8(v0);
  __error();
  uint64_t v1 = __error();
  strerror(*v1);
  sub_1000468C4();
  sub_10005F044();
  _os_log_fault_impl(v2, v3, v4, v5, v6, 0x22u);
}

void sub_1000981C4()
{
  sub_100046668();
  sub_10002E4E8(v1);
  __error();
  uint64_t v2 = __error();
  strerror(*v2);
  sub_1000468C4();
  _os_log_error_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_ERROR, "%{public}s [%d]: Unable to get path: %d (%s)", v3, 0x22u);
}

void sub_10009826C(uint64_t a1, void *a2)
{
  unsigned int v5 = sub_10007483C(a1, a2);
  *(_DWORD *)os_log_type_t v4 = 67109120;
  unsigned int *v3 = v5;
  _os_log_fault_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_FAULT, "Unable to format: pid %d doesn't exist", v4, 8u);
}

void sub_1000982C8(uint64_t a1, void *a2)
{
  unsigned int v5 = sub_10007483C(a1, a2);
  *(_DWORD *)os_log_type_t v4 = 67109120;
  unsigned int *v3 = v5;
  _os_log_debug_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEBUG, "pid %d doesn't exist", v4, 8u);
}

void sub_100098324()
{
  sub_1000481A4();
  sub_1000480D8((void *)&_mh_execute_header, v0, v1, "Unable to format: Stackshot failed: %d", v2, v3, v4, v5, v6);
}

void sub_100098390()
{
  sub_1000481A4();
  _os_log_error_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_ERROR, "Stackshot failed: %d", v1, 8u);
}

void sub_100098408()
{
  sub_10004670C();
  sub_1000466D8((void *)&_mh_execute_header, v0, v1, "Unable to format: Created shared SPStackshotProvider", v2, v3, v4, v5, v6);
}

void sub_10009843C()
{
  sub_10004670C();
  sub_100046758((void *)&_mh_execute_header, v0, v1, "Created shared SPStackshotProvider", v2, v3, v4, v5, v6);
}

void sub_100098470()
{
  sub_10004670C();
  sub_1000466D8((void *)&_mh_execute_header, v0, v1, "Unable to format: Avoiding inspecting live processes for stackshot report due to audio running", v2, v3, v4, v5, v6);
}

void sub_1000984A4()
{
  sub_10007481C(__stack_chk_guard);
  v1[0] = 136315394;
  sub_100074808();
  _os_log_fault_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_FAULT, "Unable to format: %s: Still have %d clients sampling when dealloc'ed", (uint8_t *)v1, 0x12u);
}

void sub_100098524()
{
  sub_10007481C(__stack_chk_guard);
  v1[0] = 136315394;
  sub_100074808();
  _os_log_error_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_ERROR, "%s: Still have %d clients sampling when dealloc'ed", (uint8_t *)v1, 0x12u);
}

void sub_1000985A4(uint64_t a1, _DWORD *a2, int a3)
{
  *a2 = 136315650;
  sub_10007479C(a1, (uint64_t)a2, a3);
  _os_log_fault_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_FAULT, "Unable to format: %s: Unable to create sampling thread: %d (%s)", v3, 0x1Cu);
}

void sub_1000985F8(uint64_t a1, _DWORD *a2, int a3)
{
  *a2 = 136315650;
  sub_10007479C(a1, (uint64_t)a2, a3);
  _os_log_error_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_ERROR, "%s: Unable to create sampling thread: %d (%s)", v3, 0x1Cu);
}

void sub_10009864C()
{
  sub_10004670C();
  sub_1000466D8((void *)&_mh_execute_header, v0, v1, "Unable to format: Starting sampling thread", v2, v3, v4, v5, v6);
}

void sub_100098680()
{
  sub_10004670C();
  sub_1000466D8((void *)&_mh_execute_header, v0, v1, "Unable to format: Already have a sampling thread", v2, v3, v4, v5, v6);
}

void sub_1000986B4()
{
  sub_10004670C();
  sub_100046758((void *)&_mh_execute_header, v0, v1, "Already have a sampling thread", v2, v3, v4, v5, v6);
}

void sub_1000986E8()
{
  sub_10004670C();
  sub_1000466D8((void *)&_mh_execute_header, v0, v1, "Unable to format: Sampling completed, waiting for SIGINFO...", v2, v3, v4, v5, v6);
}

void sub_10009871C(_DWORD *a1, uint64_t a2)
{
  *a1 = 136315394;
  sub_100074828((uint64_t)a1, a2, (uint64_t)"stackshotData.length < 4294967295U");
  sub_1000747BC((void *)&_mh_execute_header, v2, v3, "Unable to format: %s: bad stackshot data length %lu", v4);
}

void sub_100098760(_DWORD *a1, uint64_t a2)
{
  *a1 = 136315394;
  sub_100074828((uint64_t)a1, a2, (uint64_t)"stackshotData.length < 4294967295U");
  _os_log_error_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_ERROR, "%s: bad stackshot data length %lu", v3, 0x16u);
}

void sub_1000987B0(unsigned char *a1, unsigned char *a2)
{
  sub_100052554(a1, a2);
  _os_log_fault_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_FAULT, "Unable to format: Unable to update sampling pid list", v3, 2u);
}

void sub_1000987E8(unsigned char *a1, unsigned char *a2)
{
  sub_100052554(a1, a2);
  sub_1000747D8((void *)&_mh_execute_header, v2, (uint64_t)v2, "Unable to update sampling pid list", v3);
}

void sub_100098818()
{
  sub_10004670C();
  sub_1000466D8((void *)&_mh_execute_header, v0, v1, "Unable to format: failed to set sampling thread's priority", v2, v3, v4, v5, v6);
}

void sub_10009884C()
{
  sub_10004670C();
  sub_1000466D8((void *)&_mh_execute_header, v0, v1, "failed to set sampling thread's priority", v2, v3, v4, v5, v6);
}

void sub_100098880()
{
  sub_10004670C();
  sub_1000466D8((void *)&_mh_execute_header, v0, v1, "Unable to format: failed to set the sampling thread to a fixed-priority policy", v2, v3, v4, v5, v6);
}

void sub_1000988B4()
{
  sub_10004670C();
  sub_1000466D8((void *)&_mh_execute_header, v0, v1, "failed to set the sampling thread to a fixed-priority policy", v2, v3, v4, v5, v6);
}

void sub_1000988E8()
{
  sub_10004670C();
  sub_1000466D8((void *)&_mh_execute_header, v0, v1, "Unable to format: No sampling thread to stop", v2, v3, v4, v5, v6);
}

void sub_10009891C()
{
  sub_10004670C();
  sub_100046758((void *)&_mh_execute_header, v0, v1, "No sampling thread to stop", v2, v3, v4, v5, v6);
}

void sub_100098950()
{
  sub_10004670C();
  sub_1000466D8((void *)&_mh_execute_header, v0, v1, "Unable to format: Stopping sampling thread", v2, v3, v4, v5, v6);
}

void sub_100098984()
{
  sub_10004670C();
  sub_1000466D8((void *)&_mh_execute_header, v0, v1, "Unable to format: Sampling completed, generating report...", v2, v3, v4, v5, v6);
}

void sub_1000989B8()
{
  sub_10004670C();
  sub_1000466D8((void *)&_mh_execute_header, v0, v1, "Unable to format: Sampling completed, processing symbols...", v2, v3, v4, v5, v6);
}

void sub_1000989EC()
{
  sub_10004670C();
  sub_1000466D8((void *)&_mh_execute_header, v0, v1, "Unable to format: shared instance has 0 references", v2, v3, v4, v5, v6);
}

void sub_100098A20()
{
  sub_10004670C();
  sub_1000466D8((void *)&_mh_execute_header, v0, v1, "shared instance has 0 references", v2, v3, v4, v5, v6);
}

void sub_100098A54(uint64_t a1, uint8_t *buf, int a3, os_log_t log)
{
  *(_DWORD *)buf = 138412546;
  *(void *)(buf + 4) = a1;
  *((_WORD *)buf + 6) = 1024;
  *(_DWORD *)(buf + 14) = a3;
  _os_log_fault_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_FAULT, "Unable to format: No one's sampling when requested to adjust sampling target to %@ %d", buf, 0x12u);
}

void sub_100098AAC(uint64_t a1, char a2, uint8_t *buf, os_log_t log)
{
  *(_DWORD *)buf = 138543618;
  *(void *)(buf + 4) = a1;
  *((_WORD *)buf + 6) = 1024;
  *(_DWORD *)(buf + 14) = a2 & 1;
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "No one's sampling when requested to adjust sampling target to %{public}@ %d", buf, 0x12u);
}

void sub_100098B08()
{
  sub_10004670C();
  sub_1000466D8((void *)&_mh_execute_header, v0, v1, "Unable to format: Changing to sampling everything", v2, v3, v4, v5, v6);
}

void sub_100098B3C()
{
  sub_10004670C();
  sub_1000466D8((void *)&_mh_execute_header, v0, v1, "Unable to format: Upping sampling to include non-main threads", v2, v3, v4, v5, v6);
}

void sub_100098B70(uint64_t a1, uint8_t *buf, os_log_t log)
{
  *(_DWORD *)buf = 136315138;
  *(void *)(buf + 4) = a1;
  _os_log_fault_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_FAULT, "Unable to format: Changing to sampling %s also", buf, 0xCu);
}

void sub_100098BB8()
{
  sub_10004670C();
  sub_1000466D8((void *)&_mh_execute_header, v0, v1, "Unable to format: Sampling everything", v2, v3, v4, v5, v6);
}

void sub_100098BEC()
{
  sub_10004670C();
  sub_100046758((void *)&_mh_execute_header, v0, v1, "Sampling everything", v2, v3, v4, v5, v6);
}

void sub_100098C20(uint64_t a1, uint8_t *buf, os_log_t log)
{
  *(_DWORD *)buf = 136315138;
  *(void *)(buf + 4) = a1;
  _os_log_fault_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_FAULT, "Unable to format: Sampling only %s", buf, 0xCu);
}

void sub_100098C68()
{
  sub_10004670C();
  sub_1000466D8((void *)&_mh_execute_header, v0, v1, "Unable to format: Caught a sampling provider that isn't sampling, but has already sampled", v2, v3, v4, v5, v6);
}

void sub_100098C9C()
{
  sub_10004670C();
  sub_1000747D8((void *)&_mh_execute_header, v0, v1, "Caught a sampling provider that isn't sampling, but has already sampled", v2);
}

void sub_100098CD4()
{
  sub_10004670C();
  sub_1000466D8((void *)&_mh_execute_header, v0, v1, "Unable to format: Already sampling with sensitive strings, so can't start monitoring since we don't want sensitive strings", v2, v3, v4, v5, v6);
}

void sub_100098D08()
{
  sub_10004670C();
  sub_1000747D8((void *)&_mh_execute_header, v0, v1, "Already sampling with sensitive strings, so can't start monitoring since we don't want sensitive strings", v2);
}

void sub_100098D40()
{
  sub_1000481A4();
  sub_1000480D8((void *)&_mh_execute_header, v0, v1, "Unable to format: Turned on occasional data gathering at %us-intervals for additional client", v2, v3, v4, v5, v6);
}

void sub_100098DAC()
{
  sub_10007481C(__stack_chk_guard);
  sub_1000747F0();
  _os_log_fault_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_FAULT, "Unable to format: Already sampling with %uus-interval stackshots and %us-interval occasional data", v1, 0xEu);
}

void sub_100098E28()
{
  sub_10007481C(__stack_chk_guard);
  sub_1000747F0();
  _os_log_debug_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_DEBUG, "Already sampling with %uus-interval stackshots and %us-interval occasional data", v1, 0xEu);
}

void sub_100098EA4()
{
  sub_10004670C();
  sub_1000466D8((void *)&_mh_execute_header, v0, v1, "Unable to format: Stackshot provider shared instance done", v2, v3, v4, v5, v6);
}

void sub_100098ED8()
{
  sub_10004670C();
  sub_100046758((void *)&_mh_execute_header, v0, v1, "Stackshot provider shared instance done", v2, v3, v4, v5, v6);
}

void sub_100098F0C()
{
  sub_10004670C();
  sub_1000466D8((void *)&_mh_execute_header, v0, v1, "Unable to format: Stackshot provider shared instance not yet done", v2, v3, v4, v5, v6);
}

void sub_100098F40()
{
  sub_10004670C();
  sub_100046758((void *)&_mh_execute_header, v0, v1, "Stackshot provider shared instance not yet done", v2, v3, v4, v5, v6);
}

void sub_100098F74()
{
  sub_10004670C();
  sub_1000466D8((void *)&_mh_execute_header, v0, v1, "Unable to format: shared instance isn't self", v2, v3, v4, v5, v6);
}

void sub_100098FA8()
{
  sub_10004670C();
  sub_1000466D8((void *)&_mh_execute_header, v0, v1, "shared instance isn't self", v2, v3, v4, v5, v6);
}

void sub_100098FDC(uint64_t a1, NSObject *a2)
{
  __error();
  uint64_t v3 = __error();
  strerror(*v3);
  sub_1000466B4();
  _os_log_fault_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_FAULT, "Unable to format: Unable to open %s to save stackshots: %d (%s)", v4, 0x1Cu);
}

void sub_100099080(uint64_t a1, NSObject *a2)
{
  __error();
  uint64_t v3 = __error();
  strerror(*v3);
  sub_1000466B4();
  _os_log_error_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_ERROR, "Unable to open %s to save stackshots: %d (%s)", v4, 0x1Cu);
}

void sub_100099124(uint64_t a1, NSObject *a2)
{
  int v2 = 136315138;
  uint64_t v3 = a1;
  _os_log_fault_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_FAULT, "Unable to format: Saving stackshots to %s", (uint8_t *)&v2, 0xCu);
}

void sub_10009919C()
{
  sub_1000466F4();
  sub_1000747BC((void *)&_mh_execute_header, v0, v1, "Unable to format: filePath %s cut off with date (needed %zu chars)", v2);
}

void sub_100099208()
{
  sub_1000466F4();
  sub_1000747BC((void *)&_mh_execute_header, v0, v1, "filePath %s cut off with date (needed %zu chars)", v2);
}

void sub_100099274(unsigned char *a1, unsigned char *a2)
{
  sub_100052554(a1, a2);
  _os_log_fault_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_FAULT, "Unable to format: Unable to cache load info", v3, 2u);
}

void sub_1000992AC(unsigned char *a1, unsigned char *a2)
{
  sub_100052554(a1, a2);
  sub_1000747D8((void *)&_mh_execute_header, v2, (uint64_t)v2, "Unable to cache load info", v3);
}

void sub_1000992DC()
{
  sub_10004670C();
  sub_1000466D8((void *)&_mh_execute_header, v0, v1, "Unable to format: Unable to process samples fast enough, throttling sampling rate to avoid bloating memory. Use -noThrottle to avoid this.", v2, v3, v4, v5, v6);
}

void sub_100099310()
{
  sub_10004670C();
  sub_1000747D8((void *)&_mh_execute_header, v0, v1, "Unable to process samples fast enough, throttling sampling rate to avoid bloating memory. Use -noThrottle to avoid this.", v2);
}

void sub_100099348()
{
  sub_10003C0BC();
  _os_log_fault_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_FAULT, "Unable to format: ERROR trying to create sample store from %s: Unknown error", v1, 0xCu);
}

void sub_1000993BC()
{
  sub_10003C0BC();
  _os_log_error_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_ERROR, "ERROR trying to create sample store from %s: Unknown error", v1, 0xCu);
}

void sub_100099430()
{
  sub_10005FBF4(__stack_chk_guard);
  sub_10005257C();
  sub_100046694((void *)&_mh_execute_header, v0, v1, "Unable to format: ERROR trying to create sample store from %s: %@");
}

void sub_100099498()
{
  sub_10005FBF4(__stack_chk_guard);
  sub_10005257C();
  _os_log_error_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_ERROR, "ERROR trying to create sample store from %s: %@", v1, 0x16u);
}

void sub_100099510(os_log_t log)
{
  *(_WORD *)os_log_t v1 = 0;
  _os_log_fault_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_FAULT, "Unable to format: Avoiding inspecting live processes for tailspin file due to audio running", v1, 2u);
}

void sub_100099554()
{
  sub_10003C0BC();
  _os_log_fault_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_FAULT, "Unable to format: Could not open %s as a ktrace file for unknown reason", v1, 0xCu);
}

void sub_1000995C8()
{
  sub_10003C0BC();
  _os_log_debug_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_DEBUG, "Could not open %s as a ktrace file for unknown reason", v1, 0xCu);
}

void sub_10009963C()
{
  sub_10005FBF4(__stack_chk_guard);
  sub_10005257C();
  sub_100046694((void *)&_mh_execute_header, v0, v1, "Unable to format: Could not open %s as a ktrace file: %@");
}

void sub_1000996A4()
{
  sub_10005FBF4(__stack_chk_guard);
  sub_10005257C();
  _os_log_debug_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_DEBUG, "Could not open %s as a ktrace file: %@", v1, 0x16u);
}

void sub_10009971C(void *a1, void *a2)
{
  [objc_msgSend(a1, "debugDescription") UTF8String];
  [objc_msgSend(a2, "debugDescription") UTF8String];
  sub_100082810();
  sub_100046794((void *)&_mh_execute_header, v3, v4, "Unable to format: %s: bodies (%s) and angle bracket contents (%s)", v5, v6, v7, v8, 2u);
}

void sub_1000997C0(void *a1, void *a2)
{
  [objc_msgSend(a1, "debugDescription") UTF8String];
  [objc_msgSend(a2, "debugDescription") UTF8String];
  sub_100082810();
  sub_1000469D0((void *)&_mh_execute_header, v3, v4, "%s: bodies (%s) and angle bracket contents (%s)", v5, v6, v7, v8, 2u);
}

void sub_100099864(os_log_t log)
{
  int v1 = 136315138;
  uint64_t v2 = "bodies || angleBracketContents || stateInfo";
  _os_log_fault_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_FAULT, "Unable to format: %s: No frame bodies, state, nor angle bracket contents", (uint8_t *)&v1, 0xCu);
}

void sub_1000998E8(os_log_t log)
{
  int v1 = 136315138;
  uint64_t v2 = "bodies || angleBracketContents || stateInfo";
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "%s: No frame bodies, state, nor angle bracket contents", (uint8_t *)&v1, 0xCu);
}

void sub_10009996C()
{
  __error();
  os_log_t v0 = __error();
  strerror(*v0);
  sub_1000466B4();
  sub_1000465A0((void *)&_mh_execute_header, v1, v2, "Unable to format: Unable to open %s: %d (%s)", v3, v4, v5, v6, v7);
}

void sub_100099A00()
{
  __error();
  os_log_t v0 = __error();
  strerror(*v0);
  sub_1000466B4();
  sub_100046874((void *)&_mh_execute_header, v1, v2, "Unable to open %s: %d (%s)", v3, v4, v5, v6, v7);
}

void sub_100099A94()
{
  sub_10004670C();
  sub_1000466D8((void *)&_mh_execute_header, v0, v1, "Unable to format: Parsing spindump text: No report version. Not a spindump file?", v2, v3, v4, v5, v6);
}

void sub_100099AC8()
{
  sub_10004670C();
  sub_10004B018((void *)&_mh_execute_header, v0, v1, "Parsing spindump text: No report version. Not a spindump file?", v2, v3, v4, v5, v6);
}

void sub_100099AFC()
{
  sub_10004670C();
  sub_1000466D8((void *)&_mh_execute_header, v0, v1, "Unable to format: Parsing spindump text: Unable to parse text of the report: spindump report version 20+ required", v2, v3, v4, v5, v6);
}

void sub_100099B30()
{
  sub_10004670C();
  sub_10004B018((void *)&_mh_execute_header, v0, v1, "Parsing spindump text: Unable to parse text of the report: spindump report version 20+ required", v2, v3, v4, v5, v6);
}

void sub_100099B64()
{
  sub_10003C0F8();
  *os_log_t v0 = 136315650;
  sub_10008282C(v1, (uint64_t)v0, v2);
  _os_log_fault_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_FAULT, "Unable to format: %s: Unable to compile regex %s: %s", v3, 0x20u);
}

void sub_100099BB4()
{
  sub_10003C0F8();
  *os_log_t v0 = 136315650;
  sub_10008282C(v1, (uint64_t)v0, v2);
  _os_log_error_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_ERROR, "%s: Unable to compile regex %s: %s", v3, 0x20u);
}

void sub_100099C04(uint64_t a1, _DWORD *a2)
{
  *a2 = 136315394;
  sub_100082778(a1, (uint64_t)a2, (uint64_t)"regex");
  sub_1000747BC((void *)&_mh_execute_header, v2, v3, "Unable to format: %s: Unable to compile regex %s", v4);
}

void sub_100099C48(uint64_t a1, _DWORD *a2)
{
  *a2 = 136315394;
  sub_100082778(a1, (uint64_t)a2, (uint64_t)"regex");
  sub_1000827D4((void *)&_mh_execute_header, v2, v3, "%s: Unable to compile regex %s", v4);
}

void sub_100099C8C()
{
  sub_10004670C();
  sub_1000466D8((void *)&_mh_execute_header, v0, v1, "Unable to format: Parsing spindump text: Unable to find any Binary Images", v2, v3, v4, v5, v6);
}

void sub_100099CC0()
{
  sub_10004670C();
  sub_10004B018((void *)&_mh_execute_header, v0, v1, "Parsing spindump text: Unable to find any Binary Images", v2, v3, v4, v5, v6);
}

void sub_100099CF4(uint64_t a1, _DWORD *a2)
{
  *a2 = 136315394;
  sub_100082778(a1, (uint64_t)a2, (uint64_t)"heaviestNode.angleBracketContents || heaviestNode.stateInfo");
  sub_1000747BC((void *)&_mh_execute_header, v2, v3, "Unable to format: %s: No angle bracket contents nor state info for non-frame (%s)", v4);
}

void sub_100099D38(uint64_t a1, _DWORD *a2)
{
  *a2 = 136315394;
  sub_100082778(a1, (uint64_t)a2, (uint64_t)"heaviestNode.angleBracketContents || heaviestNode.stateInfo");
  sub_1000827D4((void *)&_mh_execute_header, v2, v3, "%s: No angle bracket contents nor state info for non-frame (%s)", v4);
}

void sub_100099D7C()
{
  sub_10003C0F8();
  *os_log_t v0 = 136315650;
  sub_10007479C(v1, (uint64_t)v0, v2);
  sub_100082864((void *)&_mh_execute_header, "Unable to format: %s: Non-frame line has count but no indent level (%d: %s)", v3, v4);
}

void sub_100099DC0()
{
  sub_10003C0F8();
  *os_log_t v0 = 136315650;
  sub_10007479C(v1, (uint64_t)v0, v2);
  sub_100082848((void *)&_mh_execute_header, "%s: Non-frame line has count but no indent level (%d: %s)", v3, v4);
}

void sub_100099E04()
{
  sub_10003C0F8();
  *os_log_t v0 = 136315650;
  sub_10007479C(v1, (uint64_t)v0, v2);
  sub_100082864((void *)&_mh_execute_header, "Unable to format: %s: frame match with no count (%d: %s)", v3, v4);
}

void sub_100099E48()
{
  sub_10003C0F8();
  *os_log_t v0 = 136315650;
  sub_10007479C(v1, (uint64_t)v0, v2);
  sub_100082848((void *)&_mh_execute_header, "%s: frame match with no count (%d: %s)", v3, v4);
}

void sub_100099E8C()
{
  sub_10003C0F8();
  *os_log_t v0 = 136315650;
  sub_10007479C(v1, (uint64_t)v0, v2);
  sub_100082864((void *)&_mh_execute_header, "Unable to format: %s: frame match with no count and whitespace (%d: %s)", v3, v4);
}

void sub_100099ED0()
{
  sub_10003C0F8();
  *os_log_t v0 = 136315650;
  sub_10007479C(v1, (uint64_t)v0, v2);
  sub_100082848((void *)&_mh_execute_header, "%s: frame match with no count and whitespace (%d: %s)", v3, v4);
}

void sub_100099F14()
{
  sub_10004670C();
  sub_1000466D8((void *)&_mh_execute_header, v0, v1, "Unable to format: Parsing spindump text: Symbolicating...", v2, v3, v4, v5, v6);
}

void sub_100099F48()
{
  sub_10004670C();
  sub_1000466D8((void *)&_mh_execute_header, v0, v1, "Unable to format: Parsing spindump text: Stacks will be filtered to the sample index range specified, but process and thread summary information and timestamps will still reflect full time range", v2, v3, v4, v5, v6);
}

void sub_100099F7C()
{
  sub_10004670C();
  sub_1000466D8((void *)&_mh_execute_header, v0, v1, "Unable to format: Parsing spindump text: Original report is not in timeline mode, so unable to filter to start/end indexes", v2, v3, v4, v5, v6);
}

void sub_100099FB0()
{
  sub_10004670C();
  sub_10004B018((void *)&_mh_execute_header, v0, v1, "Parsing spindump text: Original report is not in timeline mode, so unable to filter to start/end indexes", v2, v3, v4, v5, v6);
}

void sub_100099FE4()
{
  sub_10004670C();
  sub_1000466D8((void *)&_mh_execute_header, v0, v1, "Unable to format: Parsing spindump text: Original report is not in timeline mode, so unable to output timeline mode", v2, v3, v4, v5, v6);
}

void sub_10009A018()
{
  sub_10004670C();
  sub_10004B018((void *)&_mh_execute_header, v0, v1, "Parsing spindump text: Original report is not in timeline mode, so unable to output timeline mode", v2, v3, v4, v5, v6);
}

void sub_10009A04C()
{
  sub_10004670C();
  sub_1000466D8((void *)&_mh_execute_header, v0, v1, "Unable to format: Parsing spindump text: Unable to detect incremental indentation, using 2", v2, v3, v4, v5, v6);
}

void sub_10009A080()
{
  sub_10004670C();
  sub_1000466D8((void *)&_mh_execute_header, v0, v1, "Unable to format: Parsing spindump text: Unable to detect initial indentation, using 2", v2, v3, v4, v5, v6);
}

void sub_10009A0B4()
{
  sub_10003C0F8();
  sub_10004BA64(v0, v1, v2, 1.5047e-36);
  sub_10004B9C4((void *)&_mh_execute_header, v5, v3, "Unable to format: Parsing spindump text requires a seekable file: %d (%s)", v4);
}

void sub_10009A0F0()
{
  sub_10003C0F8();
  sub_10004BA64(v0, v1, v2, 1.5047e-36);
  _os_log_error_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_ERROR, "Parsing spindump text requires a seekable file: %d (%s)", v3, 0x12u);
}

void sub_10009A134()
{
  sub_10004670C();
  sub_1000466D8((void *)&_mh_execute_header, v0, v1, "Unable to format: Parsing spindump text: Detected condensed report variant", v2, v3, v4, v5, v6);
}

void sub_10009A168()
{
  sub_10004670C();
  _os_log_debug_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_DEBUG, "Parsing spindump text: Detected condensed report variant", v1, 2u);
}

void sub_10009A1A8()
{
  sub_10008278C(__stack_chk_guard);
  v2[0] = 136315394;
  sub_100074808();
  sub_10004B9C4((void *)&_mh_execute_header, v0, v1, "Unable to format: %s: Unable to allocate %d buffer", (uint8_t *)v2);
}

void sub_10009A220()
{
  sub_10008278C(__stack_chk_guard);
  sub_100074808();
  sub_1000827B8((void *)&_mh_execute_header, v0, v1, "%s: Unable to allocate %d buffer", v2, v3, v4, v5, 2u);
}

void sub_10009A294()
{
  sub_10008278C(__stack_chk_guard);
  v2[0] = 136315394;
  sub_100074808();
  sub_10004B9C4((void *)&_mh_execute_header, v0, v1, "Unable to format: %s: bufSize overflow (%d)", (uint8_t *)v2);
}

void sub_10009A30C()
{
  sub_10008278C(__stack_chk_guard);
  sub_100074808();
  sub_1000827B8((void *)&_mh_execute_header, v0, v1, "%s: bufSize overflow (%d)", v2, v3, v4, v5, 2u);
}

void sub_10009A380()
{
  sub_1000525B0();
  [v0 UTF8String];
  sub_100082758();
  sub_1000465A0((void *)&_mh_execute_header, v1, v2, "Unable to format: %s: load info has binary but no offset into binary (%d: %s)", v3, v4, v5, v6, 2u);
}

void sub_10009A404()
{
  sub_1000525B0();
  [v0 UTF8String];
  sub_100082758();
  sub_100046874((void *)&_mh_execute_header, v1, v2, "%s: load info has binary but no offset into binary (%d: %s)", v3, v4, v5, v6, 2u);
}

void sub_10009A488()
{
  sub_1000525B0();
  [v0 UTF8String];
  sub_100082758();
  sub_1000465A0((void *)&_mh_execute_header, v1, v2, "Unable to format: %s: frame regex returned binary but no offset into binary (%d: %s)", v3, v4, v5, v6, 2u);
}

void sub_10009A50C()
{
  sub_1000525B0();
  [v0 UTF8String];
  sub_100082758();
  sub_100046874((void *)&_mh_execute_header, v1, v2, "%s: frame regex returned binary but no offset into binary (%d: %s)", v3, v4, v5, v6, 2u);
}

void sub_10009A590()
{
  sub_1000827A0();
  sub_10004B9C4((void *)&_mh_execute_header, v0, (uint64_t)v0, "Unable to format: Parsing spindump text: Unable to find load info for (%d: %@)", v1);
}

void sub_10009A600()
{
  sub_1000827A0();
  sub_100082880((void *)&_mh_execute_header, v0, v1, "Parsing spindump text: Unable to find load info for (%d: %@)");
}

void sub_10009A668()
{
  sub_1000525B0();
  [v0 UTF8String];
  sub_100082758();
  sub_1000465A0((void *)&_mh_execute_header, v1, v2, "Unable to format: %s: frame match with no count and whitespace (%d: %s)", v3, v4, v5, v6, 2u);
}

void sub_10009A6EC()
{
  sub_1000525B0();
  [v0 UTF8String];
  sub_100082758();
  sub_100046874((void *)&_mh_execute_header, v1, v2, "%s: frame match with no count and whitespace (%d: %s)", v3, v4, v5, v6, 2u);
}

void sub_10009A770()
{
  __error();
  id v0 = __error();
  strerror(*v0);
  sub_100082758();
  sub_1000465A0((void *)&_mh_execute_header, v1, v2, "Unable to format: %s: ftello failed: %d (%s)", v3, v4, v5, v6, 2u);
}

void sub_10009A808()
{
  __error();
  id v0 = __error();
  strerror(*v0);
  sub_100082758();
  sub_100046874((void *)&_mh_execute_header, v1, v2, "%s: ftello failed: %d (%s)", v3, v4, v5, v6, 2u);
}

void sub_10009A89C()
{
  sub_1000827A0();
  sub_10004B9C4((void *)&_mh_execute_header, v0, (uint64_t)v0, "Unable to format: Parsing spindump text: No load infos, ended at line (%d: %@)", v1);
}

void sub_10009A90C()
{
  sub_1000827A0();
  sub_10004B9C4((void *)&_mh_execute_header, v0, (uint64_t)v0, "Unable to format: Parsing spindump text: Unexpected line in load infos, ignoring (%d: %@)", v1);
}

void sub_10009A97C()
{
  sub_1000827A0();
  sub_100082880((void *)&_mh_execute_header, v0, v1, "Parsing spindump text: Unexpected line in load infos, ignoring (%d: %@)");
}

void sub_10009A9E4()
{
  sub_1000525B0();
  [v0 UTF8String];
  sub_100082758();
  sub_1000465A0((void *)&_mh_execute_header, v1, v2, "Unable to format: %s: No uuid in load info (%d: %s)", v3, v4, v5, v6, 2u);
}

void sub_10009AA68()
{
  sub_1000525B0();
  [v0 UTF8String];
  sub_100082758();
  sub_100046874((void *)&_mh_execute_header, v1, v2, "%s: No uuid in load info (%d: %s)", v3, v4, v5, v6, 2u);
}

void sub_10009AAEC()
{
  sub_1000525B0();
  [v0 UTF8String];
  sub_100082758();
  sub_1000465A0((void *)&_mh_execute_header, v1, v2, "Unable to format: %s: No UUID in (%d: %s)", v3, v4, v5, v6, 2u);
}

void sub_10009AB70()
{
  sub_1000525B0();
  [v0 UTF8String];
  sub_100082758();
  sub_100046874((void *)&_mh_execute_header, v1, v2, "%s: No UUID in (%d: %s)", v3, v4, v5, v6, 2u);
}

void sub_10009ABF4()
{
  sub_1000525B0();
  [v0 UTF8String];
  sub_100082758();
  sub_1000465A0((void *)&_mh_execute_header, v1, v2, "Unable to format: %s: Parsing spindump text: No binary index (%d: %s)", v3, v4, v5, v6, 2u);
}

void sub_10009AC78()
{
  sub_1000525B0();
  [v0 UTF8String];
  sub_100082758();
  sub_100046874((void *)&_mh_execute_header, v1, v2, "%s: Parsing spindump text: No binary index (%d: %s)", v3, v4, v5, v6, 2u);
}

void sub_10009ACFC(void *a1, NSObject *a2)
{
  id v4 = [a1 uuid];
  id v5 = [a1 path];
  if (!v5) {
    id v5 = [a1 name];
  }
  int v6 = 138412546;
  id v7 = v4;
  __int16 v8 = 2112;
  id v9 = v5;
  _os_log_fault_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_FAULT, "Unable to format: Parsing spindump text: Unable to find symbol owner for %@ %@", (uint8_t *)&v6, 0x16u);
}

void sub_10009ADB8(uint64_t a1, id *a2)
{
  [*a2 uuid];
  [*a2 name];
  sub_1000827F0();
  sub_100046794((void *)&_mh_execute_header, v3, v4, "Unable to format: Parsing spindump text: Unable to find segment %@ in %@ %@", v5, v6, v7, v8, v9);
}

void sub_10009AE50(uint64_t a1, id *a2)
{
  [*a2 uuid];
  [*a2 name];
  sub_1000827F0();
  sub_1000469D0((void *)&_mh_execute_header, v3, v4, "Parsing spindump text: Unable to find segment %@ in %@ %@", v5, v6, v7, v8, v9);
}

void sub_10009AEE8()
{
  sub_1000525B0();
  [v0 UTF8String];
  sub_100082758();
  sub_1000465A0((void *)&_mh_execute_header, v1, v2, "Unable to format: %s: frame match with no whitespace indent (%d: %s)", v3, v4, v5, v6, 2u);
}

void sub_10009AF6C()
{
  sub_1000525B0();
  [v0 UTF8String];
  sub_100082758();
  sub_100046874((void *)&_mh_execute_header, v1, v2, "%s: frame match with no whitespace indent (%d: %s)", v3, v4, v5, v6, 2u);
}

uint64_t AnalyticsIsEventUsed()
{
  return _AnalyticsIsEventUsed();
}

uint64_t AnalyticsSendEventLazy()
{
  return _AnalyticsSendEventLazy();
}

uint64_t AppAnalyticsEnabled()
{
  return _AppAnalyticsEnabled();
}

CFAbsoluteTime CFAbsoluteTimeGetCurrent(void)
{
  return _CFAbsoluteTimeGetCurrent();
}

CFStringRef CFBundleGetIdentifier(CFBundleRef bundle)
{
  return _CFBundleGetIdentifier(bundle);
}

CFDateFormatterRef CFDateFormatterCreate(CFAllocatorRef allocator, CFLocaleRef locale, CFDateFormatterStyle dateStyle, CFDateFormatterStyle timeStyle)
{
  return _CFDateFormatterCreate(allocator, locale, dateStyle, timeStyle);
}

Boolean CFDateFormatterGetAbsoluteTimeFromString(CFDateFormatterRef formatter, CFStringRef string, CFRange *rangep, CFAbsoluteTime *atp)
{
  return _CFDateFormatterGetAbsoluteTimeFromString(formatter, string, rangep, atp);
}

void CFDateFormatterSetProperty(CFDateFormatterRef formatter, CFStringRef key, CFTypeRef value)
{
}

CFLocaleRef CFLocaleCopyCurrent(void)
{
  return _CFLocaleCopyCurrent();
}

void CFRelease(CFTypeRef cf)
{
}

CFStringRef CFStringCreateWithCString(CFAllocatorRef alloc, const char *cStr, CFStringEncoding encoding)
{
  return _CFStringCreateWithCString(alloc, cStr, encoding);
}

CFStringRef CFStringCreateWithFormat(CFAllocatorRef alloc, CFDictionaryRef formatOptions, CFStringRef format, ...)
{
  return _CFStringCreateWithFormat(alloc, formatOptions, format);
}

Boolean CFStringGetCString(CFStringRef theString, char *buffer, CFIndex bufferSize, CFStringEncoding encoding)
{
  return _CFStringGetCString(theString, buffer, bufferSize, encoding);
}

const char *__cdecl CFStringGetCStringPtr(CFStringRef theString, CFStringEncoding encoding)
{
  return _CFStringGetCStringPtr(theString, encoding);
}

uint64_t CSArchitectureGetArchitectureForName()
{
  return _CSArchitectureGetArchitectureForName();
}

uint64_t CSArchitectureGetFamilyName()
{
  return _CSArchitectureGetFamilyName();
}

uint64_t DRShouldGatherLog()
{
  return _DRShouldGatherLog();
}

uint64_t DRSubmitLog()
{
  return _DRSubmitLog();
}

uint64_t OSAGetDATaskingValue()
{
  return _OSAGetDATaskingValue();
}

uint64_t OSAWriteLogForSubmission()
{
  return _OSAWriteLogForSubmission();
}

uint64_t SABinarySearchArray()
{
  return _SABinarySearchArray();
}

uint64_t SAExecPlatformBinaryWithSigningIdentifier()
{
  return _SAExecPlatformBinaryWithSigningIdentifier();
}

uint64_t SAFormattedBytes()
{
  return _SAFormattedBytes();
}

uint64_t SAMachAbsTimeSecondsGetCurrent()
{
  return _SAMachAbsTimeSecondsGetCurrent();
}

uint64_t SAMachTimeFromSecondsUsingLiveTimebase()
{
  return _SAMachTimeFromSecondsUsingLiveTimebase();
}

uint64_t SASecondsFromMachTimeUsingLiveTimebase()
{
  return _SASecondsFromMachTimeUsingLiveTimebase();
}

uint64_t SASpawnPlatformBinaryWithSigningIdentifier()
{
  return _SASpawnPlatformBinaryWithSigningIdentifier();
}

uint64_t WRSanitizeForCA()
{
  return _WRSanitizeForCA();
}

void *__cdecl _Block_copy(const void *aBlock)
{
  return __Block_copy(aBlock);
}

void _Block_object_assign(void *a1, const void *a2, const int a3)
{
}

void _Block_object_dispose(const void *a1, const int a2)
{
}

void _Block_release(const void *aBlock)
{
}

uint64_t _CFBundleCreateWithExecutableURLIfLooksLikeBundle()
{
  return __CFBundleCreateWithExecutableURLIfLooksLikeBundle();
}

char ***_NSGetEnviron(void)
{
  return __NSGetEnviron();
}

int _NSGetExecutablePath(char *buf, uint32_t *bufsize)
{
  return __NSGetExecutablePath(buf, bufsize);
}

void _Unwind_Resume(_Unwind_Exception *exception_object)
{
}

int *__error(void)
{
  return ___error();
}

double __exp10(double a1)
{
  return ___exp10(a1);
}

uint64_t __memcpy_chk()
{
  return ___memcpy_chk();
}

uint64_t __strlcpy_chk()
{
  return ___strlcpy_chk();
}

uint64_t _os_assert_log()
{
  return __os_assert_log();
}

uint64_t _os_crash()
{
  return __os_crash();
}

void _os_log_debug_impl(void *dso, os_log_t log, os_log_type_t type, const char *format, uint8_t *buf, uint32_t size)
{
}

void _os_log_error_impl(void *dso, os_log_t log, os_log_type_t type, const char *format, uint8_t *buf, uint32_t size)
{
}

void _os_log_fault_impl(void *dso, os_log_t log, os_log_type_t type, const char *format, uint8_t *buf, uint32_t size)
{
}

void _os_log_impl(void *dso, os_log_t log, os_log_type_t type, const char *format, uint8_t *buf, uint32_t size)
{
}

void _os_signpost_emit_with_name_impl(void *dso, os_log_t log, os_signpost_type_t type, os_signpost_id_t spid, const char *name, const char *format, uint8_t *buf, uint32_t size)
{
}

void abort(void)
{
}

int access(const char *a1, int a2)
{
  return _access(a1, a2);
}

int asprintf(char **a1, const char *a2, ...)
{
  return _asprintf(a1, a2);
}

char *__cdecl basename(char *a1)
{
  return _basename(a1);
}

char *__cdecl basename_r(const char *a1, char *a2)
{
  return _basename_r(a1, a2);
}

void bzero(void *a1, size_t a2)
{
}

int close(int a1)
{
  return _close(a1);
}

int closedir(DIR *a1)
{
  return _closedir(a1);
}

char *__cdecl dirname_r(const char *a1, char *a2)
{
  return _dirname_r(a1, a2);
}

void dispatch_activate(dispatch_object_t object)
{
}

void dispatch_after(dispatch_time_t when, dispatch_queue_t queue, dispatch_block_t block)
{
}

void dispatch_async(dispatch_queue_t queue, dispatch_block_t block)
{
}

dispatch_block_t dispatch_block_create_with_qos_class(dispatch_block_flags_t flags, dispatch_qos_class_t qos_class, int relative_priority, dispatch_block_t block)
{
  return _dispatch_block_create_with_qos_class(flags, qos_class, relative_priority, block);
}

dispatch_queue_global_t dispatch_get_global_queue(intptr_t identifier, uintptr_t flags)
{
  return _dispatch_get_global_queue(identifier, flags);
}

void dispatch_group_async(dispatch_group_t group, dispatch_queue_t queue, dispatch_block_t block)
{
}

dispatch_group_t dispatch_group_create(void)
{
  return _dispatch_group_create();
}

void dispatch_group_enter(dispatch_group_t group)
{
}

void dispatch_group_leave(dispatch_group_t group)
{
}

void dispatch_group_notify(dispatch_group_t group, dispatch_queue_t queue, dispatch_block_t block)
{
}

intptr_t dispatch_group_wait(dispatch_group_t group, dispatch_time_t timeout)
{
  return _dispatch_group_wait(group, timeout);
}

void dispatch_main(void)
{
}

void dispatch_once(dispatch_once_t *predicate, dispatch_block_t block)
{
}

dispatch_queue_attr_t dispatch_queue_attr_make_with_autorelease_frequency(dispatch_queue_attr_t attr, dispatch_autorelease_frequency_t frequency)
{
  return _dispatch_queue_attr_make_with_autorelease_frequency(attr, frequency);
}

dispatch_queue_attr_t dispatch_queue_attr_make_with_qos_class(dispatch_queue_attr_t attr, dispatch_qos_class_t qos_class, int relative_priority)
{
  return _dispatch_queue_attr_make_with_qos_class(attr, qos_class, relative_priority);
}

dispatch_queue_t dispatch_queue_create(const char *label, dispatch_queue_attr_t attr)
{
  return _dispatch_queue_create(label, attr);
}

void dispatch_release(dispatch_object_t object)
{
}

void dispatch_resume(dispatch_object_t object)
{
}

void dispatch_retain(dispatch_object_t object)
{
}

dispatch_semaphore_t dispatch_semaphore_create(intptr_t value)
{
  return _dispatch_semaphore_create(value);
}

intptr_t dispatch_semaphore_signal(dispatch_semaphore_t dsema)
{
  return _dispatch_semaphore_signal(dsema);
}

intptr_t dispatch_semaphore_wait(dispatch_semaphore_t dsema, dispatch_time_t timeout)
{
  return _dispatch_semaphore_wait(dsema, timeout);
}

void dispatch_source_cancel(dispatch_source_t source)
{
}

dispatch_source_t dispatch_source_create(dispatch_source_type_t type, uintptr_t handle, uintptr_t mask, dispatch_queue_t queue)
{
  return _dispatch_source_create(type, handle, mask, queue);
}

uintptr_t dispatch_source_get_handle(dispatch_source_t source)
{
  return _dispatch_source_get_handle(source);
}

void dispatch_source_set_cancel_handler(dispatch_source_t source, dispatch_block_t handler)
{
}

void dispatch_source_set_event_handler(dispatch_source_t source, dispatch_block_t handler)
{
}

void dispatch_source_set_timer(dispatch_source_t source, dispatch_time_t start, uint64_t interval, uint64_t leeway)
{
}

void dispatch_suspend(dispatch_object_t object)
{
}

void dispatch_sync(dispatch_queue_t queue, dispatch_block_t block)
{
}

dispatch_time_t dispatch_time(dispatch_time_t when, int64_t delta)
{
  return _dispatch_time(when, delta);
}

int dup(int a1)
{
  return _dup(a1);
}

void exit(int a1)
{
}

int fclose(FILE *a1)
{
  return _fclose(a1);
}

int fcntl(int a1, int a2, ...)
{
  return _fcntl(a1, a2);
}

FILE *__cdecl fdopen(int a1, const char *a2)
{
  return _fdopen(a1, a2);
}

int ferror(FILE *a1)
{
  return _ferror(a1);
}

int fflush(FILE *a1)
{
  return _fflush(a1);
}

int ffsctl(int a1, unint64_t a2, void *a3, unsigned int a4)
{
  return _ffsctl(a1, a2, a3, a4);
}

char *__cdecl fgetln(FILE *a1, size_t *a2)
{
  return _fgetln(a1, a2);
}

char *__cdecl fgets(char *a1, int a2, FILE *a3)
{
  return _fgets(a1, a2, a3);
}

long double fmod(long double __x, long double __y)
{
  return _fmod(__x, __y);
}

FILE *__cdecl fopen(const char *__filename, const char *__mode)
{
  return _fopen(__filename, __mode);
}

int fprintf(FILE *a1, const char *a2, ...)
{
  return _fprintf(a1, a2);
}

int fputc(int a1, FILE *a2)
{
  return _fputc(a1, a2);
}

int fputs(const char *a1, FILE *a2)
{
  return _fputs(a1, a2);
}

void free(void *a1)
{
}

int fseek(FILE *a1, uint64_t a2, int a3)
{
  return _fseek(a1, a2, a3);
}

int fseeko(FILE *__stream, off_t a2, int __whence)
{
  return _fseeko(__stream, a2, __whence);
}

int fstat(int a1, stat *a2)
{
  return _fstat(a1, a2);
}

off_t ftello(FILE *__stream)
{
  return _ftello(__stream);
}

int ftruncate(int a1, off_t a2)
{
  return _ftruncate(a1, a2);
}

size_t fwrite(const void *__ptr, size_t __size, size_t __nitems, FILE *__stream)
{
  return _fwrite(__ptr, __size, __nitems, __stream);
}

char *__cdecl getenv(const char *a1)
{
  return _getenv(a1);
}

uid_t geteuid(void)
{
  return _geteuid();
}

int getmntinfo_r_np(statfs **a1, int a2)
{
  return _getmntinfo_r_np(a1, a2);
}

pid_t getpid(void)
{
  return _getpid();
}

int gzclose(gzFile file)
{
  return _gzclose(file);
}

gzFile gzdopen(int fd, const char *mode)
{
  return _gzdopen(fd, mode);
}

const char *__cdecl gzerror(gzFile file, int *errnum)
{
  return _gzerror(file, errnum);
}

int gzread(gzFile file, voidp buf, unsigned int len)
{
  return _gzread(file, buf, len);
}

int kill(pid_t a1, int a2)
{
  return _kill(a1, a2);
}

tm *__cdecl localtime_r(const time_t *a1, tm *a2)
{
  return _localtime_r(a1, a2);
}

long double log10(long double __x)
{
  return _log10(__x);
}

off_t lseek(int a1, off_t a2, int a3)
{
  return _lseek(a1, a2, a3);
}

int lstat(const char *a1, stat *a2)
{
  return _lstat(a1, a2);
}

uint64_t mach_absolute_time(void)
{
  return _mach_absolute_time();
}

void mach_error(const char *str, mach_error_t error_value)
{
}

kern_return_t mach_port_deallocate(ipc_space_t task, mach_port_name_t name)
{
  return _mach_port_deallocate(task, name);
}

void *__cdecl malloc_type_calloc(size_t count, size_t size, malloc_type_id_t type_id)
{
  return _malloc_type_calloc(count, size, type_id);
}

void *__cdecl malloc_type_malloc(size_t size, malloc_type_id_t type_id)
{
  return _malloc_type_malloc(size, type_id);
}

void *__cdecl malloc_type_realloc(void *ptr, size_t size, malloc_type_id_t type_id)
{
  return _malloc_type_realloc(ptr, size, type_id);
}

void *__cdecl memmove(void *__dst, const void *__src, size_t __len)
{
  return _memmove(__dst, __src, __len);
}

int mkdir(const char *a1, mode_t a2)
{
  return _mkdir(a1, a2);
}

time_t mktime(tm *a1)
{
  return _mktime(a1);
}

void *__cdecl mmap(void *a1, size_t a2, int a3, int a4, int a5, off_t a6)
{
  return _mmap(a1, a2, a3, a4, a5, a6);
}

int munmap(void *a1, size_t a2)
{
  return _munmap(a1, a2);
}

uint32_t notify_get_state(int token, uint64_t *state64)
{
  return _notify_get_state(token, state64);
}

uint32_t notify_register_check(const char *name, int *out_token)
{
  return _notify_register_check(name, out_token);
}

uint32_t notify_register_dispatch(const char *name, int *out_token, dispatch_queue_t queue, notify_handler_t handler)
{
  return _notify_register_dispatch(name, out_token, queue, handler);
}

id objc_alloc(Class a1)
{
  return _[a1 alloc];
}

uint64_t objc_alloc_init()
{
  return _objc_alloc_init();
}

id objc_autorelease(id a1)
{
  return _objc_autorelease(a1);
}

{
}

{
}

void objc_destroyWeak(id *location)
{
}

void objc_enumerationMutation(id obj)
{
}

void objc_exception_throw(id exception)
{
}

id objc_getProperty(id self, SEL _cmd, ptrdiff_t offset, BOOL atomic)
{
  return _objc_getProperty(self, _cmd, offset, atomic);
}

id objc_loadWeak(id *location)
{
  return _objc_loadWeak(location);
}

id objc_msgSendSuper2(objc_super *a1, SEL a2, ...)
{
  return [super a2];
}

uint64_t objc_opt_class()
{
  return _objc_opt_class();
}

uint64_t objc_opt_isKindOfClass()
{
  return _objc_opt_isKindOfClass();
}

uint64_t self
{
  return _self;
}

void objc_release(id a1)
{
}

id objc_retain(id a1)
{
  return _objc_retain(a1);
}

void objc_setProperty_atomic(id self, SEL _cmd, id newValue, ptrdiff_t offset)
{
}

void objc_setProperty_atomic_copy(id self, SEL _cmd, id newValue, ptrdiff_t offset)
{
}

id objc_storeWeak(id *location, id obj)
{
  return _objc_storeWeak(location, obj);
}

int objc_sync_enter(id obj)
{
  return _objc_sync_enter(obj);
}

int objc_sync_exit(id obj)
{
  return _objc_sync_exit(obj);
}

int open(const char *a1, int a2, ...)
{
  return _open(a1, a2);
}

DIR *__cdecl opendir(const char *a1)
{
  return _opendir(a1);
}

os_log_t os_log_create(const char *subsystem, const char *category)
{
  return _os_log_create(subsystem, category);
}

BOOL os_log_type_enabled(os_log_t oslog, os_log_type_t type)
{
  return _os_log_type_enabled(oslog, type);
}

BOOL os_signpost_enabled(os_log_t log)
{
  return _os_signpost_enabled(log);
}

uint64_t os_transaction_create()
{
  return _os_transaction_create();
}

void os_unfair_lock_lock(os_unfair_lock_t lock)
{
}

void os_unfair_lock_unlock(os_unfair_lock_t lock)
{
}

uint64_t os_variant_has_internal_diagnostics()
{
  return _os_variant_has_internal_diagnostics();
}

void perror(const char *a1)
{
}

int printf(const char *a1, ...)
{
  return _printf(a1);
}

int proc_listallpids(void *buffer, int buffersize)
{
  return _proc_listallpids(buffer, buffersize);
}

int proc_name(int pid, void *buffer, uint32_t buffersize)
{
  return _proc_name(pid, buffer, buffersize);
}

int proc_pidinfo(int pid, int flavor, uint64_t arg, void *buffer, int buffersize)
{
  return _proc_pidinfo(pid, flavor, arg, buffer, buffersize);
}

int proc_pidpath(int pid, void *buffer, uint32_t buffersize)
{
  return _proc_pidpath(pid, buffer, buffersize);
}

int pthread_create(pthread_t *a1, const pthread_attr_t *a2, void *(__cdecl *a3)(void *), void *a4)
{
  return _pthread_create(a1, a2, a3, a4);
}

int pthread_join(pthread_t a1, void **a2)
{
  return _pthread_join(a1, a2);
}

mach_port_t pthread_mach_thread_np(pthread_t a1)
{
  return _pthread_mach_thread_np(a1);
}

pthread_t pthread_self(void)
{
  return _pthread_self();
}

int putchar(int a1)
{
  return _putchar(a1);
}

qos_class_t qos_class_self(void)
{
  return _qos_class_self();
}

void qsort_b(void *__base, size_t __nel, size_t __width, void *__compar)
{
}

int rand(void)
{
  return _rand();
}

ssize_t read(int a1, void *a2, size_t a3)
{
  return _read(a1, a2, a3);
}

dirent *__cdecl readdir(DIR *a1)
{
  return _readdir(a1);
}

void *__cdecl reallocf(void *__ptr, size_t __size)
{
  return _reallocf(__ptr, __size);
}

char *__cdecl realpath_DARWIN_EXTSN(const char *a1, char *a2)
{
  return _realpath_DARWIN_EXTSN(a1, a2);
}

void setbuf(FILE *a1, char *a2)
{
}

int setenv(const char *__name, const char *__value, int __overwrite)
{
  return _setenv(__name, __value, __overwrite);
}

void (__cdecl *__cdecl signal(int a1, void (__cdecl *a2)(int)))(int)
{
  return _signal(a1, a2);
}

unsigned int sleep(unsigned int a1)
{
  return _sleep(a1);
}

int snprintf(char *__str, size_t __size, const char *__format, ...)
{
  return _snprintf(__str, __size, __format);
}

void sranddev(void)
{
}

uint64_t stackshot_capture_with_config()
{
  return _stackshot_capture_with_config();
}

uint64_t stackshot_config_create()
{
  return _stackshot_config_create();
}

uint64_t stackshot_config_dealloc()
{
  return _stackshot_config_dealloc();
}

uint64_t stackshot_config_dealloc_buffer()
{
  return _stackshot_config_dealloc_buffer();
}

uint64_t stackshot_config_get_stackshot_buffer()
{
  return _stackshot_config_get_stackshot_buffer();
}

uint64_t stackshot_config_get_stackshot_size()
{
  return _stackshot_config_get_stackshot_size();
}

uint64_t stackshot_config_set_delta_timestamp()
{
  return _stackshot_config_set_delta_timestamp();
}

uint64_t stackshot_config_set_flags()
{
  return _stackshot_config_set_flags();
}

uint64_t stackshot_config_set_pid()
{
  return _stackshot_config_set_pid();
}

uint64_t stackshot_config_set_size_hint()
{
  return _stackshot_config_set_size_hint();
}

int stat(const char *a1, stat *a2)
{
  return _stat(a1, a2);
}

int strcasecmp(const char *a1, const char *a2)
{
  return _strcasecmp(a1, a2);
}

char *__cdecl strcasestr(const char *__big, const char *__little)
{
  return _strcasestr(__big, __little);
}

int strcmp(const char *__s1, const char *__s2)
{
  return _strcmp(__s1, __s2);
}

char *__cdecl strdup(const char *__s1)
{
  return _strdup(__s1);
}

char *__cdecl strerror(int __errnum)
{
  return _strerror(__errnum);
}

size_t strftime(char *a1, size_t a2, const char *a3, const tm *a4)
{
  return _strftime(a1, a2, a3, a4);
}

size_t strlcpy(char *__dst, const char *__source, size_t __size)
{
  return _strlcpy(__dst, __source, __size);
}

size_t strlen(const char *__s)
{
  return _strlen(__s);
}

int strncasecmp(const char *a1, const char *a2, size_t a3)
{
  return _strncasecmp(a1, a2, a3);
}

int strncmp(const char *__s1, const char *__s2, size_t __n)
{
  return _strncmp(__s1, __s2, __n);
}

size_t strnlen(const char *__s1, size_t __n)
{
  return _strnlen(__s1, __n);
}

char *__cdecl strnstr(const char *__big, const char *__little, size_t __len)
{
  return _strnstr(__big, __little, __len);
}

char *__cdecl strptime(const char *a1, const char *a2, tm *a3)
{
  return _strptime(a1, a2, a3);
}

char *__cdecl strstr(char *__s1, const char *__s2)
{
  return _strstr(__s1, __s2);
}

double strtod(const char *a1, char **a2)
{
  return _strtod(a1, a2);
}

float strtof(const char *a1, char **a2)
{
  return _strtof(a1, a2);
}

uint64_t strtol(const char *__str, char **__endptr, int __base)
{
  return _strtol(__str, __endptr, __base);
}

uint64_t strtoll(const char *__str, char **__endptr, int __base)
{
  return _strtoll(__str, __endptr, __base);
}

unint64_t strtoul(const char *__str, char **__endptr, int __base)
{
  return _strtoul(__str, __endptr, __base);
}

unint64_t strtoull(const char *__str, char **__endptr, int __base)
{
  return _strtoull(__str, __endptr, __base);
}

int sysctl(int *a1, u_int a2, void *a3, size_t *a4, void *a5, size_t a6)
{
  return _sysctl(a1, a2, a3, a4, a5, a6);
}

int sysctlnametomib(const char *a1, int *a2, size_t *a3)
{
  return _sysctlnametomib(a1, a2, a3);
}

uint64_t systemstats_copy_microstackshots_to_file()
{
  return _systemstats_copy_microstackshots_to_file();
}

uint64_t systemstats_get_microstackshots()
{
  return _systemstats_get_microstackshots();
}

kern_return_t task_info(task_name_t target_task, task_flavor_t flavor, task_info_t task_info_out, mach_msg_type_number_t *task_info_outCnt)
{
  return _task_info(target_task, flavor, task_info_out, task_info_outCnt);
}

uint64_t task_inspect_for_pid()
{
  return _task_inspect_for_pid();
}

kern_return_t task_policy_set(task_policy_set_t task, task_policy_flavor_t flavor, task_policy_t policy_info, mach_msg_type_number_t policy_infoCnt)
{
  return _task_policy_set(task, flavor, policy_info, policy_infoCnt);
}

kern_return_t task_set_special_port(task_t task, int which_port, mach_port_t special_port)
{
  return _task_set_special_port(task, which_port, special_port);
}

kern_return_t thread_policy_set(thread_act_t thread, thread_policy_flavor_t flavor, thread_policy_t policy_info, mach_msg_type_number_t policy_infoCnt)
{
  return _thread_policy_set(thread, flavor, policy_info, policy_infoCnt);
}

time_t time(time_t *a1)
{
  return _time(a1);
}

int unlink(const char *a1)
{
  return _unlink(a1);
}

int usleep(useconds_t a1)
{
  return _usleep(a1);
}

uint64_t vproc_swap_integer()
{
  return _vproc_swap_integer();
}

int vsnprintf(char *__str, size_t __size, const char *__format, va_list a4)
{
  return _vsnprintf(__str, __size, __format, a4);
}

pid_t waitpid(pid_t a1, int *a2, int a3)
{
  return _waitpid(a1, a2, a3);
}

BOOL xpc_BOOL_get_value(xpc_object_t xBOOL)
{
  return _xpc_BOOL_get_value(xBOOL);
}

uint64_t xpc_connection_copy_entitlement_value()
{
  return _xpc_connection_copy_entitlement_value();
}

xpc_connection_t xpc_connection_create_mach_service(const char *name, dispatch_queue_t targetq, uint64_t flags)
{
  return _xpc_connection_create_mach_service(name, targetq, flags);
}

uid_t xpc_connection_get_euid(xpc_connection_t connection)
{
  return _xpc_connection_get_euid(connection);
}

pid_t xpc_connection_get_pid(xpc_connection_t connection)
{
  return _xpc_connection_get_pid(connection);
}

void xpc_connection_resume(xpc_connection_t connection)
{
}

void xpc_connection_send_message(xpc_connection_t connection, xpc_object_t message)
{
}

void xpc_connection_set_event_handler(xpc_connection_t connection, xpc_handler_t handler)
{
}

void xpc_connection_set_target_queue(xpc_connection_t connection, dispatch_queue_t targetq)
{
}

const void *__cdecl xpc_data_get_bytes_ptr(xpc_object_t xdata)
{
  return _xpc_data_get_bytes_ptr(xdata);
}

size_t xpc_data_get_length(xpc_object_t xdata)
{
  return _xpc_data_get_length(xdata);
}

uint64_t xpc_dictionary_copy_mach_send()
{
  return _xpc_dictionary_copy_mach_send();
}

xpc_object_t xpc_dictionary_create_empty(void)
{
  return _xpc_dictionary_create_empty();
}

xpc_object_t xpc_dictionary_create_reply(xpc_object_t original)
{
  return _xpc_dictionary_create_reply(original);
}

BOOL xpc_dictionary_get_BOOL(xpc_object_t xdict, const char *key)
{
  return _xpc_dictionary_get_BOOL(xdict, key);
}

int64_t xpc_dictionary_get_int64(xpc_object_t xdict, const char *key)
{
  return _xpc_dictionary_get_int64(xdict, key);
}

xpc_connection_t xpc_dictionary_get_remote_connection(xpc_object_t xdict)
{
  return _xpc_dictionary_get_remote_connection(xdict);
}

const char *__cdecl xpc_dictionary_get_string(xpc_object_t xdict, const char *key)
{
  return _xpc_dictionary_get_string(xdict, key);
}

uint64_t xpc_dictionary_get_uint64(xpc_object_t xdict, const char *key)
{
  return _xpc_dictionary_get_uint64(xdict, key);
}

xpc_object_t xpc_dictionary_get_value(xpc_object_t xdict, const char *key)
{
  return _xpc_dictionary_get_value(xdict, key);
}

void xpc_dictionary_set_int64(xpc_object_t xdict, const char *key, int64_t value)
{
}

void xpc_dictionary_set_string(xpc_object_t xdict, const char *key, const char *string)
{
}

void xpc_dictionary_set_uint64(xpc_object_t xdict, const char *key, uint64_t value)
{
}

double xpc_double_get_value(xpc_object_t xdouble)
{
  return _xpc_double_get_value(xdouble);
}

xpc_type_t xpc_get_type(xpc_object_t object)
{
  return _xpc_get_type(object);
}

void xpc_release(xpc_object_t object)
{
}

xpc_object_t xpc_retain(xpc_object_t object)
{
  return _xpc_retain(object);
}

uint64_t xpc_transaction_exit_clean()
{
  return _xpc_transaction_exit_clean();
}

id objc_msgSend_UTF8String(void *a1, const char *a2, ...)
{
  return [a1 UTF8String];
}

id objc_msgSend_UUID(void *a1, const char *a2, ...)
{
  return [a1 UUID];
}

id objc_msgSend_UUIDString(void *a1, const char *a2, ...)
{
  return [a1 UUIDString];
}

id objc_msgSend_adamID(void *a1, const char *a2, ...)
{
  return [a1 adamID];
}

id objc_msgSend_allKeys(void *a1, const char *a2, ...)
{
  return [a1 allKeys];
}

id objc_msgSend_allSampledProcesses(void *a1, const char *a2, ...)
{
  return [a1 allSampledProcesses];
}

id objc_msgSend_allSignpostTrackers(void *a1, const char *a2, ...)
{
  return [a1 allSignpostTrackers];
}

id objc_msgSend_array(void *a1, const char *a2, ...)
{
  return [a1 array];
}

id objc_msgSend_binaryVersion(void *a1, const char *a2, ...)
{
  return [a1 binaryVersion];
}

id objc_msgSend_bundleIdentifier(void *a1, const char *a2, ...)
{
  return [a1 bundleIdentifier];
}

id objc_msgSend_bundleName(void *a1, const char *a2, ...)
{
  return [a1 bundleName];
}

id objc_msgSend_bundleShortVersion(void *a1, const char *a2, ...)
{
  return [a1 bundleShortVersion];
}

id objc_msgSend_bundleVersion(void *a1, const char *a2, ...)
{
  return [a1 bundleVersion];
}

id objc_msgSend_bytes(void *a1, const char *a2, ...)
{
  return [a1 bytes];
}

id objc_msgSend_callTreeAggregation(void *a1, const char *a2, ...)
{
  return [a1 callTreeAggregation];
}

id objc_msgSend_callTreeSortAttributes(void *a1, const char *a2, ...)
{
  return [a1 callTreeSortAttributes];
}

id objc_msgSend_callTreeTimestampsTimeDomain(void *a1, const char *a2, ...)
{
  return [a1 callTreeTimestampsTimeDomain];
}

id objc_msgSend_category(void *a1, const char *a2, ...)
{
  return [a1 category];
}

id objc_msgSend_clearCoreSymbolicationCache(void *a1, const char *a2, ...)
{
  return [a1 clearCoreSymbolicationCache];
}

id objc_msgSend_clearCoreSymbolicationCaches(void *a1, const char *a2, ...)
{
  return [a1 clearCoreSymbolicationCaches];
}

id objc_msgSend_code(void *a1, const char *a2, ...)
{
  return [a1 code];
}

id objc_msgSend_cohortID(void *a1, const char *a2, ...)
{
  return [a1 cohortID];
}

id objc_msgSend_columnNum(void *a1, const char *a2, ...)
{
  return [a1 columnNum];
}

id objc_msgSend_copy(void *a1, const char *a2, ...)
{
  return [a1 copy];
}

id objc_msgSend_count(void *a1, const char *a2, ...)
{
  return [a1 count];
}

id objc_msgSend_createHIDExitSource(void *a1, const char *a2, ...)
{
  return [a1 createHIDExitSource];
}

id objc_msgSend_customOutput(void *a1, const char *a2, ...)
{
  return [a1 customOutput];
}

id objc_msgSend_dataGatheringOptions(void *a1, const char *a2, ...)
{
  return [a1 dataGatheringOptions];
}

id objc_msgSend_debugDescription(void *a1, const char *a2, ...)
{
  return [a1 debugDescription];
}

id objc_msgSend_defaultManager(void *a1, const char *a2, ...)
{
  return [a1 defaultManager];
}

id objc_msgSend_deleteHIDExitSource(void *a1, const char *a2, ...)
{
  return [a1 deleteHIDExitSource];
}

id objc_msgSend_description(void *a1, const char *a2, ...)
{
  return [a1 description];
}

id objc_msgSend_developerType(void *a1, const char *a2, ...)
{
  return [a1 developerType];
}

id objc_msgSend_diagnostic(void *a1, const char *a2, ...)
{
  return [a1 diagnostic];
}

id objc_msgSend_diagnostics(void *a1, const char *a2, ...)
{
  return [a1 diagnostics];
}

id objc_msgSend_dictionary(void *a1, const char *a2, ...)
{
  return [a1 dictionary];
}

id objc_msgSend_dispatchQueue(void *a1, const char *a2, ...)
{
  return [a1 dispatchQueue];
}

id objc_msgSend_dispatchQueueLabel(void *a1, const char *a2, ...)
{
  return [a1 dispatchQueueLabel];
}

id objc_msgSend_dispatchQueues(void *a1, const char *a2, ...)
{
  return [a1 dispatchQueues];
}

id objc_msgSend_displayBlockedThreads(void *a1, const char *a2, ...)
{
  return [a1 displayBlockedThreads];
}

id objc_msgSend_displayRunnableThreads(void *a1, const char *a2, ...)
{
  return [a1 displayRunnableThreads];
}

id objc_msgSend_distributorID(void *a1, const char *a2, ...)
{
  return [a1 distributorID];
}

id objc_msgSend_domain(void *a1, const char *a2, ...)
{
  return [a1 domain];
}

id objc_msgSend_doubleValue(void *a1, const char *a2, ...)
{
  return [a1 doubleValue];
}

id objc_msgSend_dropTransaction(void *a1, const char *a2, ...)
{
  return [a1 dropTransaction];
}

id objc_msgSend_durationNote(void *a1, const char *a2, ...)
{
  return [a1 durationNote];
}

id objc_msgSend_end(void *a1, const char *a2, ...)
{
  return [a1 end];
}

id objc_msgSend_endTime(void *a1, const char *a2, ...)
{
  return [a1 endTime];
}

id objc_msgSend_endTimestamp(void *a1, const char *a2, ...)
{
  return [a1 endTimestamp];
}

id objc_msgSend_environment(void *a1, const char *a2, ...)
{
  return [a1 environment];
}

id objc_msgSend_error(void *a1, const char *a2, ...)
{
  return [a1 error];
}

id objc_msgSend_event(void *a1, const char *a2, ...)
{
  return [a1 event];
}

id objc_msgSend_eventEnd(void *a1, const char *a2, ...)
{
  return [a1 eventEnd];
}

id objc_msgSend_eventNote(void *a1, const char *a2, ...)
{
  return [a1 eventNote];
}

id objc_msgSend_eventStart(void *a1, const char *a2, ...)
{
  return [a1 eventStart];
}

id objc_msgSend_eventTimeRange(void *a1, const char *a2, ...)
{
  return [a1 eventTimeRange];
}

id objc_msgSend_extraDuration(void *a1, const char *a2, ...)
{
  return [a1 extraDuration];
}

id objc_msgSend_fileDescriptor(void *a1, const char *a2, ...)
{
  return [a1 fileDescriptor];
}

id objc_msgSend_fileName(void *a1, const char *a2, ...)
{
  return [a1 fileName];
}

id objc_msgSend_fileSystemRepresentation(void *a1, const char *a2, ...)
{
  return [a1 fileSystemRepresentation];
}

id objc_msgSend_finishedSamplingLiveSystem(void *a1, const char *a2, ...)
{
  return [a1 finishedSamplingLiveSystem];
}

id objc_msgSend_firstObject(void *a1, const char *a2, ...)
{
  return [a1 firstObject];
}

id objc_msgSend_gatherMachineArchitecture(void *a1, const char *a2, ...)
{
  return [a1 gatherMachineArchitecture];
}

id objc_msgSend_hardwareModel(void *a1, const char *a2, ...)
{
  return [a1 hardwareModel];
}

id objc_msgSend_hasAnySpindumpReports(void *a1, const char *a2, ...)
{
  return [a1 hasAnySpindumpReports];
}

id objc_msgSend_hasSourceInfo(void *a1, const char *a2, ...)
{
  return [a1 hasSourceInfo];
}

id objc_msgSend_hasTriggerThresholdCount(void *a1, const char *a2, ...)
{
  return [a1 hasTriggerThresholdCount];
}

id objc_msgSend_hasTriggerThresholdDurationSingle(void *a1, const char *a2, ...)
{
  return [a1 hasTriggerThresholdDurationSingle];
}

id objc_msgSend_hasTriggerThresholdDurationSum(void *a1, const char *a2, ...)
{
  return [a1 hasTriggerThresholdDurationSum];
}

id objc_msgSend_hasTriggerThresholdDurationUnion(void *a1, const char *a2, ...)
{
  return [a1 hasTriggerThresholdDurationUnion];
}

id objc_msgSend_identifier(void *a1, const char *a2, ...)
{
  return [a1 identifier];
}

id objc_msgSend_incidentUUID(void *a1, const char *a2, ...)
{
  return [a1 incidentUUID];
}

id objc_msgSend_includeBinaryFormatInReport(void *a1, const char *a2, ...)
{
  return [a1 includeBinaryFormatInReport];
}

id objc_msgSend_incompleteIntervalStarts(void *a1, const char *a2, ...)
{
  return [a1 incompleteIntervalStarts];
}

id objc_msgSend_individuationFieldName(void *a1, const char *a2, ...)
{
  return [a1 individuationFieldName];
}

id objc_msgSend_individuationIdentifier(void *a1, const char *a2, ...)
{
  return [a1 individuationIdentifier];
}

id objc_msgSend_init(void *a1, const char *a2, ...)
{
  return [a1 init];
}

id objc_msgSend_initForFileParsing(void *a1, const char *a2, ...)
{
  return [a1 initForFileParsing];
}

id objc_msgSend_initForLiveSampling(void *a1, const char *a2, ...)
{
  return [a1 initForLiveSampling];
}

id objc_msgSend_intValue(void *a1, const char *a2, ...)
{
  return [a1 intValue];
}

id objc_msgSend_interrupt(void *a1, const char *a2, ...)
{
  return [a1 interrupt];
}

id objc_msgSend_intervals(void *a1, const char *a2, ...)
{
  return [a1 intervals];
}

id objc_msgSend_io(void *a1, const char *a2, ...)
{
  return [a1 io];
}

id objc_msgSend_isAbsolutePath(void *a1, const char *a2, ...)
{
  return [a1 isAbsolutePath];
}

id objc_msgSend_isBeta(void *a1, const char *a2, ...)
{
  return [a1 isBeta];
}

id objc_msgSend_isPidSuspended(void *a1, const char *a2, ...)
{
  return [a1 isPidSuspended];
}

id objc_msgSend_isUnresponsive(void *a1, const char *a2, ...)
{
  return [a1 isUnresponsive];
}

id objc_msgSend_isWSBased(void *a1, const char *a2, ...)
{
  return [a1 isWSBased];
}

id objc_msgSend_lastObject(void *a1, const char *a2, ...)
{
  return [a1 lastObject];
}

id objc_msgSend_lastPathComponent(void *a1, const char *a2, ...)
{
  return [a1 lastPathComponent];
}

id objc_msgSend_length(void *a1, const char *a2, ...)
{
  return [a1 length];
}

id objc_msgSend_lineNum(void *a1, const char *a2, ...)
{
  return [a1 lineNum];
}

id objc_msgSend_localizedDescription(void *a1, const char *a2, ...)
{
  return [a1 localizedDescription];
}

id objc_msgSend_longLongValue(void *a1, const char *a2, ...)
{
  return [a1 longLongValue];
}

id objc_msgSend_macf(void *a1, const char *a2, ...)
{
  return [a1 macf];
}

id objc_msgSend_machAbsTime(void *a1, const char *a2, ...)
{
  return [a1 machAbsTime];
}

id objc_msgSend_machAbsTimeSeconds(void *a1, const char *a2, ...)
{
  return [a1 machAbsTimeSeconds];
}

id objc_msgSend_machContTime(void *a1, const char *a2, ...)
{
  return [a1 machContTime];
}

id objc_msgSend_machContTimeNs(void *a1, const char *a2, ...)
{
  return [a1 machContTimeNs];
}

id objc_msgSend_machContTimeSeconds(void *a1, const char *a2, ...)
{
  return [a1 machContTimeSeconds];
}

id objc_msgSend_mainBinary(void *a1, const char *a2, ...)
{
  return [a1 mainBinary];
}

id objc_msgSend_mainBinaryPath(void *a1, const char *a2, ...)
{
  return [a1 mainBinaryPath];
}

id objc_msgSend_mainThread(void *a1, const char *a2, ...)
{
  return [a1 mainThread];
}

id objc_msgSend_maximumEventDuration(void *a1, const char *a2, ...)
{
  return [a1 maximumEventDuration];
}

id objc_msgSend_mutableCopy(void *a1, const char *a2, ...)
{
  return [a1 mutableCopy];
}

id objc_msgSend_name(void *a1, const char *a2, ...)
{
  return [a1 name];
}

id objc_msgSend_null(void *a1, const char *a2, ...)
{
  return [a1 null];
}

id objc_msgSend_numSamples(void *a1, const char *a2, ...)
{
  return [a1 numSamples];
}

id objc_msgSend_numSamplesAvoidedDueToAudio(void *a1, const char *a2, ...)
{
  return [a1 numSamplesAvoidedDueToAudio];
}

id objc_msgSend_numSymbols(void *a1, const char *a2, ...)
{
  return [a1 numSymbols];
}

id objc_msgSend_occasionalDataIntervalSec(void *a1, const char *a2, ...)
{
  return [a1 occasionalDataIntervalSec];
}

id objc_msgSend_offsetIntoSegment(void *a1, const char *a2, ...)
{
  return [a1 offsetIntoSegment];
}

id objc_msgSend_omitFramesBelowSampleCount(void *a1, const char *a2, ...)
{
  return [a1 omitFramesBelowSampleCount];
}

id objc_msgSend_omitSensitiveStrings(void *a1, const char *a2, ...)
{
  return [a1 omitSensitiveStrings];
}

id objc_msgSend_omitStacksAboveBasePriority(void *a1, const char *a2, ...)
{
  return [a1 omitStacksAboveBasePriority];
}

id objc_msgSend_omitStacksBelowBasePriority(void *a1, const char *a2, ...)
{
  return [a1 omitStacksBelowBasePriority];
}

id objc_msgSend_omitStacksOnAC(void *a1, const char *a2, ...)
{
  return [a1 omitStacksOnAC];
}

id objc_msgSend_omitStacksOnBattery(void *a1, const char *a2, ...)
{
  return [a1 omitStacksOnBattery];
}

id objc_msgSend_omitStacksWithUserActive(void *a1, const char *a2, ...)
{
  return [a1 omitStacksWithUserActive];
}

id objc_msgSend_omitStacksWithUserIdle(void *a1, const char *a2, ...)
{
  return [a1 omitStacksWithUserIdle];
}

id objc_msgSend_optIn3rdParty(void *a1, const char *a2, ...)
{
  return [a1 optIn3rdParty];
}

id objc_msgSend_options(void *a1, const char *a2, ...)
{
  return [a1 options];
}

id objc_msgSend_path(void *a1, const char *a2, ...)
{
  return [a1 path];
}

id objc_msgSend_pid(void *a1, const char *a2, ...)
{
  return [a1 pid];
}

id objc_msgSend_pmi(void *a1, const char *a2, ...)
{
  return [a1 pmi];
}

id objc_msgSend_postprocess(void *a1, const char *a2, ...)
{
  return [a1 postprocess];
}

id objc_msgSend_printHeavyStacks(void *a1, const char *a2, ...)
{
  return [a1 printHeavyStacks];
}

id objc_msgSend_printOptions(void *a1, const char *a2, ...)
{
  return [a1 printOptions];
}

id objc_msgSend_processSortAttributes(void *a1, const char *a2, ...)
{
  return [a1 processSortAttributes];
}

id objc_msgSend_removeAllObjects(void *a1, const char *a2, ...)
{
  return [a1 removeAllObjects];
}

id objc_msgSend_removeLastObject(void *a1, const char *a2, ...)
{
  return [a1 removeLastObject];
}

id objc_msgSend_removeSelfFromPidCache(void *a1, const char *a2, ...)
{
  return [a1 removeSelfFromPidCache];
}

id objc_msgSend_reportOmittingNetworkBoundIntervals(void *a1, const char *a2, ...)
{
  return [a1 reportOmittingNetworkBoundIntervals];
}

id objc_msgSend_reportOtherSignpostWithName(void *a1, const char *a2, ...)
{
  return [a1 reportOtherSignpostWithName];
}

id objc_msgSend_reportProcessesWithName(void *a1, const char *a2, ...)
{
  return [a1 reportProcessesWithName];
}

id objc_msgSend_reportReason(void *a1, const char *a2, ...)
{
  return [a1 reportReason];
}

id objc_msgSend_reportSpindumpForDispatchQueueWithLabel(void *a1, const char *a2, ...)
{
  return [a1 reportSpindumpForDispatchQueueWithLabel];
}

id objc_msgSend_reportSpindumpForMainThread(void *a1, const char *a2, ...)
{
  return [a1 reportSpindumpForMainThread];
}

id objc_msgSend_reportSpindumpForThisDispatchQueue(void *a1, const char *a2, ...)
{
  return [a1 reportSpindumpForThisDispatchQueue];
}

id objc_msgSend_reportSpindumpForThisThread(void *a1, const char *a2, ...)
{
  return [a1 reportSpindumpForThisThread];
}

id objc_msgSend_reportSpindumpForThreadWithName(void *a1, const char *a2, ...)
{
  return [a1 reportSpindumpForThreadWithName];
}

id objc_msgSend_reportTimeEnd(void *a1, const char *a2, ...)
{
  return [a1 reportTimeEnd];
}

id objc_msgSend_reportTimeStart(void *a1, const char *a2, ...)
{
  return [a1 reportTimeStart];
}

id objc_msgSend_reportTimeThreshold(void *a1, const char *a2, ...)
{
  return [a1 reportTimeThreshold];
}

id objc_msgSend_reportedSignpostTracker(void *a1, const char *a2, ...)
{
  return [a1 reportedSignpostTracker];
}

id objc_msgSend_sampleOnlyMainThreads(void *a1, const char *a2, ...)
{
  return [a1 sampleOnlyMainThreads];
}

id objc_msgSend_sampleStore(void *a1, const char *a2, ...)
{
  return [a1 sampleStore];
}

id objc_msgSend_sampleTimestamps(void *a1, const char *a2, ...)
{
  return [a1 sampleTimestamps];
}

id objc_msgSend_samplingIntervalUs(void *a1, const char *a2, ...)
{
  return [a1 samplingIntervalUs];
}

id objc_msgSend_samplingMode(void *a1, const char *a2, ...)
{
  return [a1 samplingMode];
}

id objc_msgSend_set(void *a1, const char *a2, ...)
{
  return [a1 set];
}

id objc_msgSend_setTaskCompleted(void *a1, const char *a2, ...)
{
  return [a1 setTaskCompleted];
}

id objc_msgSend_sharedInstance(void *a1, const char *a2, ...)
{
  return [a1 sharedInstance];
}

id objc_msgSend_sharedInstanceLock(void *a1, const char *a2, ...)
{
  return [a1 sharedInstanceLock];
}

id objc_msgSend_sharedScheduler(void *a1, const char *a2, ...)
{
  return [a1 sharedScheduler];
}

id objc_msgSend_signature(void *a1, const char *a2, ...)
{
  return [a1 signature];
}

id objc_msgSend_signpost(void *a1, const char *a2, ...)
{
  return [a1 signpost];
}

id objc_msgSend_signpostCount(void *a1, const char *a2, ...)
{
  return [a1 signpostCount];
}

id objc_msgSend_signpostDurationSingle(void *a1, const char *a2, ...)
{
  return [a1 signpostDurationSingle];
}

id objc_msgSend_signpostDurationSum(void *a1, const char *a2, ...)
{
  return [a1 signpostDurationSum];
}

id objc_msgSend_signpostDurationUnion(void *a1, const char *a2, ...)
{
  return [a1 signpostDurationUnion];
}

id objc_msgSend_signpostTracker(void *a1, const char *a2, ...)
{
  return [a1 signpostTracker];
}

id objc_msgSend_stackshotProvider(void *a1, const char *a2, ...)
{
  return [a1 stackshotProvider];
}

id objc_msgSend_start(void *a1, const char *a2, ...)
{
  return [a1 start];
}

id objc_msgSend_startSampling(void *a1, const char *a2, ...)
{
  return [a1 startSampling];
}

id objc_msgSend_startSamplingThread(void *a1, const char *a2, ...)
{
  return [a1 startSamplingThread];
}

id objc_msgSend_startTime(void *a1, const char *a2, ...)
{
  return [a1 startTime];
}

id objc_msgSend_startTimestamp(void *a1, const char *a2, ...)
{
  return [a1 startTimestamp];
}

id objc_msgSend_startingSamplingLiveSystem(void *a1, const char *a2, ...)
{
  return [a1 startingSamplingLiveSystem];
}

id objc_msgSend_stats(void *a1, const char *a2, ...)
{
  return [a1 stats];
}

id objc_msgSend_stepsNote(void *a1, const char *a2, ...)
{
  return [a1 stepsNote];
}

id objc_msgSend_stopSamplingThread(void *a1, const char *a2, ...)
{
  return [a1 stopSamplingThread];
}

id objc_msgSend_string(void *a1, const char *a2, ...)
{
  return [a1 string];
}

id objc_msgSend_subsystem(void *a1, const char *a2, ...)
{
  return [a1 subsystem];
}

id objc_msgSend_suspendCount(void *a1, const char *a2, ...)
{
  return [a1 suspendCount];
}

id objc_msgSend_swiftAsyncCallTreeAggregation(void *a1, const char *a2, ...)
{
  return [a1 swiftAsyncCallTreeAggregation];
}

id objc_msgSend_systemstatsFormat(void *a1, const char *a2, ...)
{
  return [a1 systemstatsFormat];
}

id objc_msgSend_takeTransaction(void *a1, const char *a2, ...)
{
  return [a1 takeTransaction];
}

id objc_msgSend_targetDispatchQueueId(void *a1, const char *a2, ...)
{
  return [a1 targetDispatchQueueId];
}

id objc_msgSend_targetHIDEventEndMachAbs(void *a1, const char *a2, ...)
{
  return [a1 targetHIDEventEndMachAbs];
}

id objc_msgSend_targetHIDEventMachAbs(void *a1, const char *a2, ...)
{
  return [a1 targetHIDEventMachAbs];
}

id objc_msgSend_targetProcess(void *a1, const char *a2, ...)
{
  return [a1 targetProcess];
}

id objc_msgSend_targetProcessId(void *a1, const char *a2, ...)
{
  return [a1 targetProcessId];
}

id objc_msgSend_targetProcessName(void *a1, const char *a2, ...)
{
  return [a1 targetProcessName];
}

id objc_msgSend_targetThreadId(void *a1, const char *a2, ...)
{
  return [a1 targetThreadId];
}

id objc_msgSend_task(void *a1, const char *a2, ...)
{
  return [a1 task];
}

id objc_msgSend_taskAggregation(void *a1, const char *a2, ...)
{
  return [a1 taskAggregation];
}

id objc_msgSend_tasksByPid(void *a1, const char *a2, ...)
{
  return [a1 tasksByPid];
}

id objc_msgSend_thread(void *a1, const char *a2, ...)
{
  return [a1 thread];
}

id objc_msgSend_threadID(void *a1, const char *a2, ...)
{
  return [a1 threadID];
}

id objc_msgSend_threadId(void *a1, const char *a2, ...)
{
  return [a1 threadId];
}

id objc_msgSend_threads(void *a1, const char *a2, ...)
{
  return [a1 threads];
}

id objc_msgSend_tidToPidDict(void *a1, const char *a2, ...)
{
  return [a1 tidToPidDict];
}

id objc_msgSend_timeOfLastResponse(void *a1, const char *a2, ...)
{
  return [a1 timeOfLastResponse];
}

id objc_msgSend_timeRange(void *a1, const char *a2, ...)
{
  return [a1 timeRange];
}

id objc_msgSend_timer(void *a1, const char *a2, ...)
{
  return [a1 timer];
}

id objc_msgSend_timestamp(void *a1, const char *a2, ...)
{
  return [a1 timestamp];
}

id objc_msgSend_total(void *a1, const char *a2, ...)
{
  return [a1 total];
}

id objc_msgSend_triggerEventTimeout(void *a1, const char *a2, ...)
{
  return [a1 triggerEventTimeout];
}

id objc_msgSend_triggerThresholdCount(void *a1, const char *a2, ...)
{
  return [a1 triggerThresholdCount];
}

id objc_msgSend_triggerThresholdDurationSingle(void *a1, const char *a2, ...)
{
  return [a1 triggerThresholdDurationSingle];
}

id objc_msgSend_triggerThresholdDurationSum(void *a1, const char *a2, ...)
{
  return [a1 triggerThresholdDurationSum];
}

id objc_msgSend_triggerThresholdDurationUnion(void *a1, const char *a2, ...)
{
  return [a1 triggerThresholdDurationUnion];
}

id objc_msgSend_unsignedLongLongValue(void *a1, const char *a2, ...)
{
  return [a1 unsignedLongLongValue];
}

id objc_msgSend_uuid(void *a1, const char *a2, ...)
{
  return [a1 uuid];
}

id objc_msgSend_waitForSamplingToComplete(void *a1, const char *a2, ...)
{
  return [a1 waitForSamplingToComplete];
}

id objc_msgSend_wallTime(void *a1, const char *a2, ...)
{
  return [a1 wallTime];
}

id objc_msgSend_workflow(void *a1, const char *a2, ...)
{
  return [a1 workflow];
}

id objc_msgSend_workflowDiagnostics(void *a1, const char *a2, ...)
{
  return [a1 workflowDiagnostics];
}

id objc_msgSend_workflowDuration(void *a1, const char *a2, ...)
{
  return [a1 workflowDuration];
}

id objc_msgSend_workflowDurationOmittingNetworkBoundIntervals(void *a1, const char *a2, ...)
{
  return [a1 workflowDurationOmittingNetworkBoundIntervals];
}

id objc_msgSend_workflowEventTimedOut(void *a1, const char *a2, ...)
{
  return [a1 workflowEventTimedOut];
}

id objc_msgSend_workflowTracker(void *a1, const char *a2, ...)
{
  return [a1 workflowTracker];
}

id objc_msgSend_zero(void *a1, const char *a2, ...)
{
  return [a1 zero];
}